{
  "module_name": "intel8x0.c",
  "hash_id": "1bb8b78d07b0ee69fd212b8cd3b7a750c2e0390496df555c2f9ff719943b1b9a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/intel8x0.c",
  "human_readable_source": "\n       \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Intel 82801AA,82901AB,i810,i820,i830,i840,i845,MX440; SiS 7012; Ali 5455\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int ac97_clock;\nstatic char *ac97_quirk;\nstatic bool buggy_semaphore;\nstatic int buggy_irq = -1;  \nstatic bool xbox;\nstatic int spdif_aclink = -1;\nstatic int inside_vm = -1;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for Intel i8x0 soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for Intel i8x0 soundcard.\");\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (0 = allowlist + auto-detect, 1 = force autodetect).\");\nmodule_param(ac97_quirk, charp, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 workaround for strange hardware.\");\nmodule_param(buggy_semaphore, bool, 0444);\nMODULE_PARM_DESC(buggy_semaphore, \"Enable workaround for hardwares with problematic codec semaphores.\");\nmodule_param(buggy_irq, bint, 0444);\nMODULE_PARM_DESC(buggy_irq, \"Enable workaround for buggy interrupts on some motherboards.\");\nmodule_param(xbox, bool, 0444);\nMODULE_PARM_DESC(xbox, \"Set to 1 for Xbox, if you have problems with the AC'97 codec detection.\");\nmodule_param(spdif_aclink, int, 0444);\nMODULE_PARM_DESC(spdif_aclink, \"S/PDIF over AC-link.\");\nmodule_param(inside_vm, bint, 0444);\nMODULE_PARM_DESC(inside_vm, \"KVM/Parallels optimization.\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\nstatic int joystick;\nmodule_param(joystick, int, 0444);\n\n \nenum { DEVICE_INTEL, DEVICE_INTEL_ICH4, DEVICE_SIS, DEVICE_ALI, DEVICE_NFORCE };\n\n#define ICHREG(x) ICH_REG_##x\n\n#define DEFINE_REGSET(name,base) \\\nenum { \\\n\tICH_REG_##name##_BDBAR\t= base + 0x0,\t  \\\n\tICH_REG_##name##_CIV\t= base + 0x04,\t  \\\n\tICH_REG_##name##_LVI\t= base + 0x05,\t  \\\n\tICH_REG_##name##_SR\t= base + 0x06,\t  \\\n\tICH_REG_##name##_PICB\t= base + 0x08,\t  \\\n\tICH_REG_##name##_PIV\t= base + 0x0a,\t  \\\n\tICH_REG_##name##_CR\t= base + 0x0b,\t  \\\n}\n\n \nDEFINE_REGSET(OFF, 0);\t\t \nDEFINE_REGSET(PI, 0x00);\t \nDEFINE_REGSET(PO, 0x10);\t \nDEFINE_REGSET(MC, 0x20);\t \n\n \nDEFINE_REGSET(MC2, 0x40);\t \nDEFINE_REGSET(PI2, 0x50);\t \nDEFINE_REGSET(SP, 0x60);\t \n\n \n\n \n#define ICH_REG_LVI_MASK\t\t0x1f\n\n \n#define ICH_FIFOE\t\t\t0x10\t \n#define ICH_BCIS\t\t\t0x08\t \n#define ICH_LVBCI\t\t\t0x04\t \n#define ICH_CELV\t\t\t0x02\t \n#define ICH_DCH\t\t\t\t0x01\t \n\n \n#define ICH_REG_PIV_MASK\t\t0x1f\t \n\n \n#define ICH_IOCE\t\t\t0x10\t \n#define ICH_FEIE\t\t\t0x08\t \n#define ICH_LVBIE\t\t\t0x04\t \n#define ICH_RESETREGS\t\t\t0x02\t \n#define ICH_STARTBM\t\t\t0x01\t \n\n\n \n#define ICH_REG_GLOB_CNT\t\t0x2c\t \n#define   ICH_PCM_SPDIF_MASK\t0xc0000000\t \n#define   ICH_PCM_SPDIF_NONE\t0x00000000\t \n#define   ICH_PCM_SPDIF_78\t0x40000000\t \n#define   ICH_PCM_SPDIF_69\t0x80000000\t \n#define   ICH_PCM_SPDIF_1011\t0xc0000000\t \n#define   ICH_PCM_20BIT\t\t0x00400000\t \n#define   ICH_PCM_246_MASK\t0x00300000\t \n#define   ICH_PCM_8\t\t0x00300000       \n#define   ICH_PCM_6\t\t0x00200000\t \n#define   ICH_PCM_4\t\t0x00100000\t \n#define   ICH_PCM_2\t\t0x00000000\t \n#define   ICH_SIS_PCM_246_MASK\t0x000000c0\t \n#define   ICH_SIS_PCM_6\t\t0x00000080\t \n#define   ICH_SIS_PCM_4\t\t0x00000040\t \n#define   ICH_SIS_PCM_2\t\t0x00000000\t \n#define   ICH_TRIE\t\t0x00000040\t \n#define   ICH_SRIE\t\t0x00000020\t \n#define   ICH_PRIE\t\t0x00000010\t \n#define   ICH_ACLINK\t\t0x00000008\t \n#define   ICH_AC97WARM\t\t0x00000004\t \n#define   ICH_AC97COLD\t\t0x00000002\t \n#define   ICH_GIE\t\t0x00000001\t \n#define ICH_REG_GLOB_STA\t\t0x30\t \n#define   ICH_TRI\t\t0x20000000\t \n#define   ICH_TCR\t\t0x10000000\t \n#define   ICH_BCS\t\t0x08000000\t \n#define   ICH_SPINT\t\t0x04000000\t \n#define   ICH_P2INT\t\t0x02000000\t \n#define   ICH_M2INT\t\t0x01000000\t \n#define   ICH_SAMPLE_CAP\t0x00c00000\t \n#define   ICH_SAMPLE_16_20\t0x00400000\t \n#define   ICH_MULTICHAN_CAP\t0x00300000\t \n#define   ICH_SIS_TRI\t\t0x00080000\t \n#define   ICH_SIS_TCR\t\t0x00040000\t \n#define   ICH_MD3\t\t0x00020000\t \n#define   ICH_AD3\t\t0x00010000\t \n#define   ICH_RCS\t\t0x00008000\t \n#define   ICH_BIT3\t\t0x00004000\t \n#define   ICH_BIT2\t\t0x00002000\t \n#define   ICH_BIT1\t\t0x00001000\t \n#define   ICH_SRI\t\t0x00000800\t \n#define   ICH_PRI\t\t0x00000400\t \n#define   ICH_SCR\t\t0x00000200\t \n#define   ICH_PCR\t\t0x00000100\t \n#define   ICH_MCINT\t\t0x00000080\t \n#define   ICH_POINT\t\t0x00000040\t \n#define   ICH_PIINT\t\t0x00000020\t \n#define   ICH_NVSPINT\t\t0x00000010\t \n#define   ICH_MOINT\t\t0x00000004\t \n#define   ICH_MIINT\t\t0x00000002\t \n#define   ICH_GSCI\t\t0x00000001\t \n#define ICH_REG_ACC_SEMA\t\t0x34\t \n#define   ICH_CAS\t\t0x01\t\t \n#define ICH_REG_SDM\t\t0x80\n#define   ICH_DI2L_MASK\t\t0x000000c0\t \n#define   ICH_DI2L_SHIFT\t6\n#define   ICH_DI1L_MASK\t\t0x00000030\t \n#define   ICH_DI1L_SHIFT\t4\n#define   ICH_SE\t\t0x00000008\t \n#define   ICH_LDI_MASK\t\t0x00000003\t \n\n#define ICH_MAX_FRAGS\t\t32\t\t \n\n\n \n\n \nDEFINE_REGSET(AL_PI, 0x40);\t \nDEFINE_REGSET(AL_PO, 0x50);\t \nDEFINE_REGSET(AL_MC, 0x60);\t \nDEFINE_REGSET(AL_CDC_SPO, 0x70);\t \nDEFINE_REGSET(AL_CENTER, 0x80);\t\t \nDEFINE_REGSET(AL_LFE, 0x90);\t\t \nDEFINE_REGSET(AL_CLR_SPI, 0xa0);\t \nDEFINE_REGSET(AL_CLR_SPO, 0xb0);\t \nDEFINE_REGSET(AL_I2S, 0xc0);\t \nDEFINE_REGSET(AL_PI2, 0xd0);\t \nDEFINE_REGSET(AL_MC2, 0xe0);\t \n\nenum {\n\tICH_REG_ALI_SCR = 0x00,\t\t \n\tICH_REG_ALI_SSR = 0x04,\t\t \n\tICH_REG_ALI_DMACR = 0x08,\t \n\tICH_REG_ALI_FIFOCR1 = 0x0c,\t \n\tICH_REG_ALI_INTERFACECR = 0x10,\t \n\tICH_REG_ALI_INTERRUPTCR = 0x14,\t \n\tICH_REG_ALI_INTERRUPTSR = 0x18,\t \n\tICH_REG_ALI_FIFOCR2 = 0x1c,\t \n\tICH_REG_ALI_CPR = 0x20,\t\t \n\tICH_REG_ALI_CPR_ADDR = 0x22,\t \n\tICH_REG_ALI_SPR = 0x24,\t\t \n\tICH_REG_ALI_SPR_ADDR = 0x26,\t \n\tICH_REG_ALI_FIFOCR3 = 0x2c,\t \n\tICH_REG_ALI_TTSR = 0x30,\t \n\tICH_REG_ALI_RTSR = 0x34,\t \n\tICH_REG_ALI_CSPSR = 0x38,\t \n\tICH_REG_ALI_CAS = 0x3c,\t\t \n\tICH_REG_ALI_HWVOL = 0xf0,\t \n\tICH_REG_ALI_I2SCR = 0xf4,\t \n\tICH_REG_ALI_SPDIFCSR = 0xf8,\t \n\tICH_REG_ALI_SPDIFICS = 0xfc,\t \n};\n\n#define ALI_CAS_SEM_BUSY\t0x80000000\n#define ALI_CPR_ADDR_SECONDARY\t0x100\n#define ALI_CPR_ADDR_READ\t0x80\n#define ALI_CSPSR_CODEC_READY\t0x08\n#define ALI_CSPSR_READ_OK\t0x02\n#define ALI_CSPSR_WRITE_OK\t0x01\n\n \n \n#define ALI_INT_MICIN2\t\t(1<<26)\n#define ALI_INT_PCMIN2\t\t(1<<25)\n#define ALI_INT_I2SIN\t\t(1<<24)\n#define ALI_INT_SPDIFOUT\t(1<<23)\t \n#define ALI_INT_SPDIFIN\t\t(1<<22)\n#define ALI_INT_LFEOUT\t\t(1<<21)\n#define ALI_INT_CENTEROUT\t(1<<20)\n#define ALI_INT_CODECSPDIFOUT\t(1<<19)\n#define ALI_INT_MICIN\t\t(1<<18)\n#define ALI_INT_PCMOUT\t\t(1<<17)\n#define ALI_INT_PCMIN\t\t(1<<16)\n#define ALI_INT_CPRAIS\t\t(1<<7)\t \n#define ALI_INT_SPRAIS\t\t(1<<5)\t \n#define ALI_INT_GPIO\t\t(1<<1)\n#define ALI_INT_MASK\t\t(ALI_INT_SPDIFOUT|ALI_INT_CODECSPDIFOUT|\\\n\t\t\t\t ALI_INT_MICIN|ALI_INT_PCMOUT|ALI_INT_PCMIN)\n\n#define ICH_ALI_SC_RESET\t(1<<31)\t \n#define ICH_ALI_SC_AC97_DBL\t(1<<30)\n#define ICH_ALI_SC_CODEC_SPDF\t(3<<20)\t \n#define ICH_ALI_SC_IN_BITS\t(3<<18)\n#define ICH_ALI_SC_OUT_BITS\t(3<<16)\n#define ICH_ALI_SC_6CH_CFG\t(3<<14)\n#define ICH_ALI_SC_PCM_4\t(1<<8)\n#define ICH_ALI_SC_PCM_6\t(2<<8)\n#define ICH_ALI_SC_PCM_246_MASK\t(3<<8)\n\n#define ICH_ALI_SS_SEC_ID\t(3<<5)\n#define ICH_ALI_SS_PRI_ID\t(3<<3)\n\n#define ICH_ALI_IF_AC97SP\t(1<<21)\n#define ICH_ALI_IF_MC\t\t(1<<20)\n#define ICH_ALI_IF_PI\t\t(1<<19)\n#define ICH_ALI_IF_MC2\t\t(1<<18)\n#define ICH_ALI_IF_PI2\t\t(1<<17)\n#define ICH_ALI_IF_LINE_SRC\t(1<<15)\t \n#define ICH_ALI_IF_MIC_SRC\t(1<<14)\t \n#define ICH_ALI_IF_SPDF_SRC\t(3<<12)\t \n#define ICH_ALI_IF_AC97_OUT\t(3<<8)\t \n#define ICH_ALI_IF_PO_SPDF\t(1<<3)\n#define ICH_ALI_IF_PO\t\t(1<<1)\n\n \n\nenum {\n\tICHD_PCMIN,\n\tICHD_PCMOUT,\n\tICHD_MIC,\n\tICHD_MIC2,\n\tICHD_PCM2IN,\n\tICHD_SPBAR,\n\tICHD_LAST = ICHD_SPBAR\n};\nenum {\n\tNVD_PCMIN,\n\tNVD_PCMOUT,\n\tNVD_MIC,\n\tNVD_SPBAR,\n\tNVD_LAST = NVD_SPBAR\n};\nenum {\n\tALID_PCMIN,\n\tALID_PCMOUT,\n\tALID_MIC,\n\tALID_AC97SPDIFOUT,\n\tALID_SPDIFIN,\n\tALID_SPDIFOUT,\n\tALID_LAST = ALID_SPDIFOUT\n};\n\n#define get_ichdev(substream) (substream->runtime->private_data)\n\nstruct ichdev {\n\tunsigned int ichd;\t\t\t \n\tunsigned long reg_offset;\t\t \n\t__le32 *bdbar;\t\t\t\t \n\tunsigned int bdbar_addr;\t\t \n\tstruct snd_pcm_substream *substream;\n\tunsigned int physbuf;\t\t\t \n        unsigned int size;\n        unsigned int fragsize;\n        unsigned int fragsize1;\n        unsigned int position;\n\tunsigned int pos_shift;\n\tunsigned int last_pos;\n        int frags;\n        int lvi;\n        int lvi_frag;\n\tint civ;\n\tint ack;\n\tint ack_reload;\n\tunsigned int ack_bit;\n\tunsigned int roff_sr;\n\tunsigned int roff_picb;\n\tunsigned int int_sta_mask;\t\t \n\tunsigned int ali_slot;\t\t\t \n\tstruct ac97_pcm *pcm;\n\tint pcm_open_flag;\n\tunsigned int prepared:1;\n\tunsigned int suspended: 1;\n};\n\nstruct intel8x0 {\n\tunsigned int device_type;\n\n\tint irq;\n\n\tvoid __iomem *addr;\n\tvoid __iomem *bmaddr;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\n\tint pcm_devs;\n\tstruct snd_pcm *pcm[6];\n\tstruct ichdev ichd[6];\n\n\tunsigned multi4: 1,\n\t\t multi6: 1,\n\t\t multi8 :1,\n\t\t dra: 1,\n\t\t smp20bit: 1;\n\tunsigned in_ac97_init: 1,\n\t\t in_sdin_init: 1;\n\tunsigned in_measurement: 1;\t \n\tunsigned fix_nocache: 1; \t \n\tunsigned buggy_irq: 1;\t\t \n\tunsigned xbox: 1;\t\t \n\tunsigned buggy_semaphore: 1;\t \n\tunsigned inside_vm: 1;\t\t \n\n\tint spdif_idx;\t \n\tunsigned int sdm_saved;\t \n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97[3];\n\tunsigned int ac97_sdin[3];\n\tunsigned int max_codecs, ncodecs;\n\tconst unsigned int *codec_bit;\n\tunsigned int codec_isr_bits;\n\tunsigned int codec_ready_bits;\n\n\tspinlock_t reg_lock;\n\t\n\tu32 bdbars_count;\n\tstruct snd_dma_buffer *bdbars;\n\tu32 int_sta_reg;\t\t \n\tu32 int_sta_mask;\t\t \n};\n\nstatic const struct pci_device_id snd_intel8x0_ids[] = {\n\t{ PCI_VDEVICE(INTEL, 0x2415), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2425), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2445), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2485), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x24c5), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x24d5), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x25a6), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x266e), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x27de), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x2698), DEVICE_INTEL_ICH4 },  \n\t{ PCI_VDEVICE(INTEL, 0x7195), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(SI, 0x7012), DEVICE_SIS },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x01b1), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x003a), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x006a), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0059), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x008a), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x00da), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x00ea), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x026b), DEVICE_NFORCE },\t \n\t{ PCI_VDEVICE(AMD, 0x746d), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(AMD, 0x7445), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(AL, 0x5455), DEVICE_ALI },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_intel8x0_ids);\n\n \n\nstatic inline u8 igetbyte(struct intel8x0 *chip, u32 offset)\n{\n\treturn ioread8(chip->bmaddr + offset);\n}\n\nstatic inline u16 igetword(struct intel8x0 *chip, u32 offset)\n{\n\treturn ioread16(chip->bmaddr + offset);\n}\n\nstatic inline u32 igetdword(struct intel8x0 *chip, u32 offset)\n{\n\treturn ioread32(chip->bmaddr + offset);\n}\n\nstatic inline void iputbyte(struct intel8x0 *chip, u32 offset, u8 val)\n{\n\tiowrite8(val, chip->bmaddr + offset);\n}\n\nstatic inline void iputword(struct intel8x0 *chip, u32 offset, u16 val)\n{\n\tiowrite16(val, chip->bmaddr + offset);\n}\n\nstatic inline void iputdword(struct intel8x0 *chip, u32 offset, u32 val)\n{\n\tiowrite32(val, chip->bmaddr + offset);\n}\n\n \n\nstatic inline u16 iagetword(struct intel8x0 *chip, u32 offset)\n{\n\treturn ioread16(chip->addr + offset);\n}\n\nstatic inline void iaputword(struct intel8x0 *chip, u32 offset, u16 val)\n{\n\tiowrite16(val, chip->addr + offset);\n}\n\n \n\n \n\nstatic int snd_intel8x0_codec_semaphore(struct intel8x0 *chip, unsigned int codec)\n{\n\tint time;\n\t\n\tif (codec > 2)\n\t\treturn -EIO;\n\tif (chip->in_sdin_init) {\n\t\t \n\t\t \n\t\tcodec = chip->codec_isr_bits;\n\t} else {\n\t\tcodec = chip->codec_bit[chip->ac97_sdin[codec]];\n\t}\n\n\t \n\tif ((igetdword(chip, ICHREG(GLOB_STA)) & codec) == 0)\n\t\treturn -EIO;\n\n\tif (chip->buggy_semaphore)\n\t\treturn 0;  \n\n\t \n\ttime = 100;\n      \tdo {\n      \t\tif (!(igetbyte(chip, ICHREG(ACC_SEMA)) & ICH_CAS))\n      \t\t\treturn 0;\n\t\tudelay(10);\n\t} while (time--);\n\n\t \n\tdev_err(chip->card->dev,\n\t\t\"codec_semaphore: semaphore is not ready [0x%x][0x%x]\\n\",\n\t\t\tigetbyte(chip, ICHREG(ACC_SEMA)), igetdword(chip, ICHREG(GLOB_STA)));\n\tiagetword(chip, 0);\t \n\t \n\treturn -EBUSY;\n}\n \nstatic void snd_intel8x0_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t     unsigned short reg,\n\t\t\t\t     unsigned short val)\n{\n\tstruct intel8x0 *chip = ac97->private_data;\n\t\n\tif (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {\n\t\tif (! chip->in_ac97_init)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_write %d: semaphore is not ready for register 0x%x\\n\",\n\t\t\t\tac97->num, reg);\n\t}\n\tiaputword(chip, reg + ac97->num * 0x80, val);\n}\n\nstatic unsigned short snd_intel8x0_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t      unsigned short reg)\n{\n\tstruct intel8x0 *chip = ac97->private_data;\n\tunsigned short res;\n\tunsigned int tmp;\n\n\tif (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {\n\t\tif (! chip->in_ac97_init)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_read %d: semaphore is not ready for register 0x%x\\n\",\n\t\t\t\tac97->num, reg);\n\t\tres = 0xffff;\n\t} else {\n\t\tres = iagetword(chip, reg + ac97->num * 0x80);\n\t\ttmp = igetdword(chip, ICHREG(GLOB_STA));\n\t\tif (tmp & ICH_RCS) {\n\t\t\t \n\t\t\tiputdword(chip, ICHREG(GLOB_STA), tmp &\n\t\t\t\t  ~(chip->codec_ready_bits | ICH_GSCI));\n\t\t\tif (! chip->in_ac97_init)\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"codec_read %d: read timeout for register 0x%x\\n\",\n\t\t\t\t\tac97->num, reg);\n\t\t\tres = 0xffff;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void snd_intel8x0_codec_read_test(struct intel8x0 *chip,\n\t\t\t\t\t unsigned int codec)\n{\n\tunsigned int tmp;\n\n\tif (snd_intel8x0_codec_semaphore(chip, codec) >= 0) {\n\t\tiagetword(chip, codec * 0x80);\n\t\ttmp = igetdword(chip, ICHREG(GLOB_STA));\n\t\tif (tmp & ICH_RCS) {\n\t\t\t \n\t\t\tiputdword(chip, ICHREG(GLOB_STA), tmp &\n\t\t\t\t  ~(chip->codec_ready_bits | ICH_GSCI));\n\t\t}\n\t}\n}\n\n \nstatic int snd_intel8x0_ali_codec_ready(struct intel8x0 *chip, int mask)\n{\n\tint count = 0;\n\tfor (count = 0; count < 0x7f; count++) {\n\t\tint val = igetbyte(chip, ICHREG(ALI_CSPSR));\n\t\tif (val & mask)\n\t\t\treturn 0;\n\t}\n\tif (! chip->in_ac97_init)\n\t\tdev_warn(chip->card->dev, \"AC97 codec ready timeout.\\n\");\n\treturn -EBUSY;\n}\n\nstatic int snd_intel8x0_ali_codec_semaphore(struct intel8x0 *chip)\n{\n\tint time = 100;\n\tif (chip->buggy_semaphore)\n\t\treturn 0;  \n\twhile (--time && (igetdword(chip, ICHREG(ALI_CAS)) & ALI_CAS_SEM_BUSY))\n\t\tudelay(1);\n\tif (! time && ! chip->in_ac97_init)\n\t\tdev_warn(chip->card->dev, \"ali_codec_semaphore timeout\\n\");\n\treturn snd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_CODEC_READY);\n}\n\nstatic unsigned short snd_intel8x0_ali_codec_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct intel8x0 *chip = ac97->private_data;\n\tunsigned short data = 0xffff;\n\n\tif (snd_intel8x0_ali_codec_semaphore(chip))\n\t\tgoto __err;\n\treg |= ALI_CPR_ADDR_READ;\n\tif (ac97->num)\n\t\treg |= ALI_CPR_ADDR_SECONDARY;\n\tiputword(chip, ICHREG(ALI_CPR_ADDR), reg);\n\tif (snd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_READ_OK))\n\t\tgoto __err;\n\tdata = igetword(chip, ICHREG(ALI_SPR));\n __err:\n\treturn data;\n}\n\nstatic void snd_intel8x0_ali_codec_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\t\t unsigned short val)\n{\n\tstruct intel8x0 *chip = ac97->private_data;\n\n\tif (snd_intel8x0_ali_codec_semaphore(chip))\n\t\treturn;\n\tiputword(chip, ICHREG(ALI_CPR), val);\n\tif (ac97->num)\n\t\treg |= ALI_CPR_ADDR_SECONDARY;\n\tiputword(chip, ICHREG(ALI_CPR_ADDR), reg);\n\tsnd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_WRITE_OK);\n}\n\n\n \nstatic void snd_intel8x0_setup_periods(struct intel8x0 *chip, struct ichdev *ichdev) \n{\n\tint idx;\n\t__le32 *bdbar = ichdev->bdbar;\n\tunsigned long port = ichdev->reg_offset;\n\n\tiputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\n\tif (ichdev->size == ichdev->fragsize) {\n\t\tichdev->ack_reload = ichdev->ack = 2;\n\t\tichdev->fragsize1 = ichdev->fragsize >> 1;\n\t\tfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 4) {\n\t\t\tbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf);\n\t\t\tbdbar[idx + 1] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize1 >> ichdev->pos_shift);\n\t\t\tbdbar[idx + 2] = cpu_to_le32(ichdev->physbuf + (ichdev->size >> 1));\n\t\t\tbdbar[idx + 3] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize1 >> ichdev->pos_shift);\n\t\t}\n\t\tichdev->frags = 2;\n\t} else {\n\t\tichdev->ack_reload = ichdev->ack = 1;\n\t\tichdev->fragsize1 = ichdev->fragsize;\n\t\tfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 2) {\n\t\t\tbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf +\n\t\t\t\t\t\t     (((idx >> 1) * ichdev->fragsize) %\n\t\t\t\t\t\t      ichdev->size));\n\t\t\tbdbar[idx + 1] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize >> ichdev->pos_shift);\n#if 0\n\t\t\tdev_dbg(chip->card->dev, \"bdbar[%i] = 0x%x [0x%x]\\n\",\n\t\t\t       idx + 0, bdbar[idx + 0], bdbar[idx + 1]);\n#endif\n\t\t}\n\t\tichdev->frags = ichdev->size / ichdev->fragsize;\n\t}\n\tiputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi = ICH_REG_LVI_MASK);\n\tichdev->civ = 0;\n\tiputbyte(chip, port + ICH_REG_OFF_CIV, 0);\n\tichdev->lvi_frag = ICH_REG_LVI_MASK % ichdev->frags;\n\tichdev->position = 0;\n#if 0\n\tdev_dbg(chip->card->dev,\n\t\t\"lvi_frag = %i, frags = %i, period_size = 0x%x, period_size1 = 0x%x\\n\",\n\t       ichdev->lvi_frag, ichdev->frags, ichdev->fragsize,\n\t       ichdev->fragsize1);\n#endif\n\t \n\tiputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\n}\n\n \n\nstatic inline void snd_intel8x0_update(struct intel8x0 *chip, struct ichdev *ichdev)\n{\n\tunsigned long port = ichdev->reg_offset;\n\tunsigned long flags;\n\tint status, civ, i, step;\n\tint ack = 0;\n\n\tif (!(ichdev->prepared || chip->in_measurement) || ichdev->suspended)\n\t\treturn;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tstatus = igetbyte(chip, port + ichdev->roff_sr);\n\tciv = igetbyte(chip, port + ICH_REG_OFF_CIV);\n\tif (!(status & ICH_BCIS)) {\n\t\tstep = 0;\n\t} else if (civ == ichdev->civ) {\n\t\t\n\t\tstep = 1;\n\t\tichdev->civ++;\n\t\tichdev->civ &= ICH_REG_LVI_MASK;\n\t} else {\n\t\tstep = civ - ichdev->civ;\n\t\tif (step < 0)\n\t\t\tstep += ICH_REG_LVI_MASK + 1;\n\t\t\n\t\t\n\t\tichdev->civ = civ;\n\t}\n\n\tichdev->position += step * ichdev->fragsize1;\n\tif (! chip->in_measurement)\n\t\tichdev->position %= ichdev->size;\n\tichdev->lvi += step;\n\tichdev->lvi &= ICH_REG_LVI_MASK;\n\tiputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\n\tfor (i = 0; i < step; i++) {\n\t\tichdev->lvi_frag++;\n\t\tichdev->lvi_frag %= ichdev->frags;\n\t\tichdev->bdbar[ichdev->lvi * 2] = cpu_to_le32(ichdev->physbuf + ichdev->lvi_frag * ichdev->fragsize1);\n#if 0\n\tdev_dbg(chip->card->dev,\n\t\t\"new: bdbar[%i] = 0x%x [0x%x], prefetch = %i, all = 0x%x, 0x%x\\n\",\n\t       ichdev->lvi * 2, ichdev->bdbar[ichdev->lvi * 2],\n\t       ichdev->bdbar[ichdev->lvi * 2 + 1], inb(ICH_REG_OFF_PIV + port),\n\t       inl(port + 4), inb(port + ICH_REG_OFF_CR));\n#endif\n\t\tif (--ichdev->ack == 0) {\n\t\t\tichdev->ack = ichdev->ack_reload;\n\t\t\tack = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tif (ack && ichdev->substream) {\n\t\tsnd_pcm_period_elapsed(ichdev->substream);\n\t}\n\tiputbyte(chip, port + ichdev->roff_sr,\n\t\t status & (ICH_FIFOE | ICH_BCIS | ICH_LVBCI));\n}\n\nstatic irqreturn_t snd_intel8x0_interrupt(int irq, void *dev_id)\n{\n\tstruct intel8x0 *chip = dev_id;\n\tstruct ichdev *ichdev;\n\tunsigned int status;\n\tunsigned int i;\n\n\tstatus = igetdword(chip, chip->int_sta_reg);\n\tif (status == 0xffffffff)\t \n\t\treturn IRQ_NONE;\n\n\tif ((status & chip->int_sta_mask) == 0) {\n\t\tif (status) {\n\t\t\t \n\t\t\tiputdword(chip, chip->int_sta_reg, status);\n\t\t\tif (! chip->buggy_irq)\n\t\t\t\tstatus = 0;\n\t\t}\n\t\treturn IRQ_RETVAL(status);\n\t}\n\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tif (status & ichdev->int_sta_mask)\n\t\t\tsnd_intel8x0_update(chip, ichdev);\n\t}\n\n\t \n\tiputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);\n\t\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int snd_intel8x0_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tunsigned char val = 0;\n\tunsigned long port = ichdev->reg_offset;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tichdev->suspended = 0;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = ICH_IOCE | ICH_STARTBM;\n\t\tichdev->last_pos = ichdev->position;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tichdev->suspended = 1;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tval = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = ICH_IOCE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tiputbyte(chip, port + ICH_REG_OFF_CR, val);\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\t \n\t\twhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH)) ;\n\t\t \n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\n\t}\n\treturn 0;\n}\n\nstatic int snd_intel8x0_ali_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tunsigned long port = ichdev->reg_offset;\n\tstatic const int fiforeg[] = {\n\t\tICHREG(ALI_FIFOCR1), ICHREG(ALI_FIFOCR2), ICHREG(ALI_FIFOCR3)\n\t};\n\tunsigned int val, fifo;\n\n\tval = igetdword(chip, ICHREG(ALI_DMACR));\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tichdev->suspended = 0;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t \n\t\t\tfifo = igetdword(chip, fiforeg[ichdev->ali_slot / 4]);\n\t\t\tfifo &= ~(0xff << (ichdev->ali_slot % 4));  \n\t\t\tfifo |= 0x83 << (ichdev->ali_slot % 4); \n\t\t\tiputdword(chip, fiforeg[ichdev->ali_slot / 4], fifo);\n\t\t}\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE);\n\t\tval &= ~(1 << (ichdev->ali_slot + 16));  \n\t\t \n\t\tiputdword(chip, ICHREG(ALI_DMACR), val | (1 << ichdev->ali_slot));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tichdev->suspended = 1;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tiputdword(chip, ICHREG(ALI_DMACR), val | (1 << (ichdev->ali_slot + 16)));\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, 0);\n\t\twhile (igetbyte(chip, port + ICH_REG_OFF_CR))\n\t\t\t;\n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\n\t\t\tbreak;\n\t\t \n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\n\t\t \n\t\tiputbyte(chip, port + ICH_REG_OFF_SR,\n\t\t\t igetbyte(chip, port + ICH_REG_OFF_SR) | 0x1e);\n\t\tiputdword(chip, ICHREG(ALI_INTERRUPTSR),\n\t\t\t  igetdword(chip, ICHREG(ALI_INTERRUPTSR)) & ichdev->int_sta_mask);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_intel8x0_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tint dbl = params_rate(hw_params) > 48000;\n\tint err;\n\n\tif (ichdev->pcm_open_flag) {\n\t\tsnd_ac97_pcm_close(ichdev->pcm);\n\t\tichdev->pcm_open_flag = 0;\n\t\tichdev->prepared = 0;\n\t}\n\terr = snd_ac97_pcm_open(ichdev->pcm, params_rate(hw_params),\n\t\t\t\tparams_channels(hw_params),\n\t\t\t\tichdev->pcm->r[dbl].slots);\n\tif (err >= 0) {\n\t\tichdev->pcm_open_flag = 1;\n\t\t \n\t\tif (ichdev->ichd == ICHD_PCMOUT && chip->spdif_idx < 0)\n\t\t\tsnd_ac97_set_rate(ichdev->pcm->r[0].codec[0], AC97_SPDIF,\n\t\t\t\t\t  params_rate(hw_params));\n\t}\n\treturn err;\n}\n\nstatic int snd_intel8x0_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\n\tif (ichdev->pcm_open_flag) {\n\t\tsnd_ac97_pcm_close(ichdev->pcm);\n\t\tichdev->pcm_open_flag = 0;\n\t\tichdev->prepared = 0;\n\t}\n\treturn 0;\n}\n\nstatic void snd_intel8x0_setup_pcm_out(struct intel8x0 *chip,\n\t\t\t\t       struct snd_pcm_runtime *runtime)\n{\n\tunsigned int cnt;\n\tint dbl = runtime->rate > 48000;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tswitch (chip->device_type) {\n\tcase DEVICE_ALI:\n\t\tcnt = igetdword(chip, ICHREG(ALI_SCR));\n\t\tcnt &= ~ICH_ALI_SC_PCM_246_MASK;\n\t\tif (runtime->channels == 4 || dbl)\n\t\t\tcnt |= ICH_ALI_SC_PCM_4;\n\t\telse if (runtime->channels == 6)\n\t\t\tcnt |= ICH_ALI_SC_PCM_6;\n\t\tiputdword(chip, ICHREG(ALI_SCR), cnt);\n\t\tbreak;\n\tcase DEVICE_SIS:\n\t\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\t\tcnt &= ~ICH_SIS_PCM_246_MASK;\n\t\tif (runtime->channels == 4 || dbl)\n\t\t\tcnt |= ICH_SIS_PCM_4;\n\t\telse if (runtime->channels == 6)\n\t\t\tcnt |= ICH_SIS_PCM_6;\n\t\tiputdword(chip, ICHREG(GLOB_CNT), cnt);\n\t\tbreak;\n\tdefault:\n\t\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\t\tcnt &= ~(ICH_PCM_246_MASK | ICH_PCM_20BIT);\n\t\tif (runtime->channels == 4 || dbl)\n\t\t\tcnt |= ICH_PCM_4;\n\t\telse if (runtime->channels == 6)\n\t\t\tcnt |= ICH_PCM_6;\n\t\telse if (runtime->channels == 8)\n\t\t\tcnt |= ICH_PCM_8;\n\t\tif (chip->device_type == DEVICE_NFORCE) {\n\t\t\t \n\t\t\tif (cnt & ICH_PCM_246_MASK) {\n\t\t\t\tiputdword(chip, ICHREG(GLOB_CNT), cnt & ~ICH_PCM_246_MASK);\n\t\t\t\tspin_unlock_irq(&chip->reg_lock);\n\t\t\t\tmsleep(50);  \n\t\t\t\tspin_lock_irq(&chip->reg_lock);\n\t\t\t}\n\t\t} else if (chip->device_type == DEVICE_INTEL_ICH4) {\n\t\t\tif (runtime->sample_bits > 16)\n\t\t\t\tcnt |= ICH_PCM_20BIT;\n\t\t}\n\t\tiputdword(chip, ICHREG(GLOB_CNT), cnt);\n\t\tbreak;\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n}\n\nstatic int snd_intel8x0_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\n\tichdev->physbuf = runtime->dma_addr;\n\tichdev->size = snd_pcm_lib_buffer_bytes(substream);\n\tichdev->fragsize = snd_pcm_lib_period_bytes(substream);\n\tif (ichdev->ichd == ICHD_PCMOUT) {\n\t\tsnd_intel8x0_setup_pcm_out(chip, runtime);\n\t\tif (chip->device_type == DEVICE_INTEL_ICH4)\n\t\t\tichdev->pos_shift = (runtime->sample_bits > 16) ? 2 : 1;\n\t}\n\tsnd_intel8x0_setup_periods(chip, ichdev);\n\tichdev->prepared = 1;\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_intel8x0_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tsize_t ptr1, ptr;\n\tint civ, timeout = 10;\n\tunsigned int position;\n\n\tspin_lock(&chip->reg_lock);\n\tdo {\n\t\tciv = igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV);\n\t\tptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb);\n\t\tposition = ichdev->position;\n\t\tif (ptr1 == 0) {\n\t\t\tudelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\tif (civ != igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (chip->inside_vm)\n\t\t\tbreak;\n\t\tif (ptr1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))\n\t\t\tbreak;\n\t} while (timeout--);\n\tptr = ichdev->last_pos;\n\tif (ptr1 != 0) {\n\t\tptr1 <<= ichdev->pos_shift;\n\t\tptr = ichdev->fragsize1 - ptr1;\n\t\tptr += position;\n\t\tif (ptr < ichdev->last_pos) {\n\t\t\tunsigned int pos_base, last_base;\n\t\t\tpos_base = position / ichdev->fragsize1;\n\t\t\tlast_base = ichdev->last_pos / ichdev->fragsize1;\n\t\t\t \n\t\t\tif (pos_base == last_base)\n\t\t\t\tptr = ichdev->last_pos;\n\t\t}\n\t}\n\tichdev->last_pos = ptr;\n\tspin_unlock(&chip->reg_lock);\n\tif (ptr >= ichdev->size)\n\t\treturn 0;\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic const struct snd_pcm_hardware snd_intel8x0_stream =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t128 * 1024,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t128 * 1024,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const unsigned int channels4[] = {\n\t2, 4,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels4 = {\n\t.count = ARRAY_SIZE(channels4),\n\t.list = channels4,\n\t.mask = 0,\n};\n\nstatic const unsigned int channels6[] = {\n\t2, 4, 6,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels6 = {\n\t.count = ARRAY_SIZE(channels6),\n\t.list = channels6,\n\t.mask = 0,\n};\n\nstatic const unsigned int channels8[] = {\n\t2, 4, 6, 8,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels8 = {\n\t.count = ARRAY_SIZE(channels8),\n\t.list = channels8,\n\t.mask = 0,\n};\n\nstatic int snd_intel8x0_pcm_open(struct snd_pcm_substream *substream, struct ichdev *ichdev)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tichdev->substream = substream;\n\truntime->hw = snd_intel8x0_stream;\n\truntime->hw.rates = ichdev->pcm->rates;\n\tsnd_pcm_limit_hw_rates(runtime);\n\tif (chip->device_type == DEVICE_SIS) {\n\t\truntime->hw.buffer_bytes_max = 64*1024;\n\t\truntime->hw.period_bytes_max = 64*1024;\n\t}\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\truntime->private_data = ichdev;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\terr = snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMOUT]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->multi8) {\n\t\truntime->hw.channels_max = 8;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t\t&hw_constraints_channels8);\n\t} else if (chip->multi6) {\n\t\truntime->hw.channels_max = 6;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   &hw_constraints_channels6);\n\t} else if (chip->multi4) {\n\t\truntime->hw.channels_max = 4;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   &hw_constraints_channels4);\n\t}\n\tif (chip->dra) {\n\t\tsnd_ac97_pcm_double_rate_rules(runtime);\n\t}\n\tif (chip->smp20bit) {\n\t\truntime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\n\t}\n\treturn 0;\n}\n\nstatic int snd_intel8x0_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_PCMOUT].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMIN]);\n}\n\nstatic int snd_intel8x0_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_PCMIN].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_mic_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC]);\n}\n\nstatic int snd_intel8x0_mic_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_MIC].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_mic2_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC2]);\n}\n\nstatic int snd_intel8x0_mic2_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_MIC2].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_capture2_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCM2IN]);\n}\n\nstatic int snd_intel8x0_capture2_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_PCM2IN].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tint idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[idx]);\n}\n\nstatic int snd_intel8x0_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tint idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;\n\n\tchip->ichd[idx].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_ali_ac97spdifout_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tunsigned int val;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tval = igetdword(chip, ICHREG(ALI_INTERFACECR));\n\tval |= ICH_ALI_IF_AC97SP;\n\tiputdword(chip, ICHREG(ALI_INTERFACECR), val);\n\t \n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_AC97SPDIFOUT]);\n}\n\nstatic int snd_intel8x0_ali_ac97spdifout_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\tunsigned int val;\n\n\tchip->ichd[ALID_AC97SPDIFOUT].substream = NULL;\n\tspin_lock_irq(&chip->reg_lock);\n\tval = igetdword(chip, ICHREG(ALI_INTERFACECR));\n\tval &= ~ICH_ALI_IF_AC97SP;\n\tiputdword(chip, ICHREG(ALI_INTERFACECR), val);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn 0;\n}\n\n#if 0 \nstatic int snd_intel8x0_ali_spdifin_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_SPDIFIN]);\n}\n\nstatic int snd_intel8x0_ali_spdifin_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ALID_SPDIFIN].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0_ali_spdifout_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_SPDIFOUT]);\n}\n\nstatic int snd_intel8x0_ali_spdifout_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ALID_SPDIFOUT].substream = NULL;\n\treturn 0;\n}\n#endif\n\nstatic const struct snd_pcm_ops snd_intel8x0_playback_ops = {\n\t.open =\t\tsnd_intel8x0_playback_open,\n\t.close =\tsnd_intel8x0_playback_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_capture_ops = {\n\t.open =\t\tsnd_intel8x0_capture_open,\n\t.close =\tsnd_intel8x0_capture_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_capture_mic_ops = {\n\t.open =\t\tsnd_intel8x0_mic_open,\n\t.close =\tsnd_intel8x0_mic_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_capture_mic2_ops = {\n\t.open =\t\tsnd_intel8x0_mic2_open,\n\t.close =\tsnd_intel8x0_mic2_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_capture2_ops = {\n\t.open =\t\tsnd_intel8x0_capture2_open,\n\t.close =\tsnd_intel8x0_capture2_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_spdif_ops = {\n\t.open =\t\tsnd_intel8x0_spdif_open,\n\t.close =\tsnd_intel8x0_spdif_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_ali_playback_ops = {\n\t.open =\t\tsnd_intel8x0_playback_open,\n\t.close =\tsnd_intel8x0_playback_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_ali_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_ali_capture_ops = {\n\t.open =\t\tsnd_intel8x0_capture_open,\n\t.close =\tsnd_intel8x0_capture_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_ali_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_ali_capture_mic_ops = {\n\t.open =\t\tsnd_intel8x0_mic_open,\n\t.close =\tsnd_intel8x0_mic_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_ali_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0_ali_ac97spdifout_ops = {\n\t.open =\t\tsnd_intel8x0_ali_ac97spdifout_open,\n\t.close =\tsnd_intel8x0_ali_ac97spdifout_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_ali_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\n#if 0 \nstatic struct snd_pcm_ops snd_intel8x0_ali_spdifin_ops = {\n\t.open =\t\tsnd_intel8x0_ali_spdifin_open,\n\t.close =\tsnd_intel8x0_ali_spdifin_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n\nstatic struct snd_pcm_ops snd_intel8x0_ali_spdifout_ops = {\n\t.open =\t\tsnd_intel8x0_ali_spdifout_open,\n\t.close =\tsnd_intel8x0_ali_spdifout_close,\n\t.hw_params =\tsnd_intel8x0_hw_params,\n\t.hw_free =\tsnd_intel8x0_hw_free,\n\t.prepare =\tsnd_intel8x0_pcm_prepare,\n\t.trigger =\tsnd_intel8x0_pcm_trigger,\n\t.pointer =\tsnd_intel8x0_pcm_pointer,\n};\n#endif \n\nstruct ich_pcm_table {\n\tchar *suffix;\n\tconst struct snd_pcm_ops *playback_ops;\n\tconst struct snd_pcm_ops *capture_ops;\n\tsize_t prealloc_size;\n\tsize_t prealloc_max_size;\n\tint ac97_idx;\n};\n\n#define intel8x0_dma_type(chip) \\\n\t((chip)->fix_nocache ? SNDRV_DMA_TYPE_DEV_WC : SNDRV_DMA_TYPE_DEV)\n\nstatic int snd_intel8x0_pcm1(struct intel8x0 *chip, int device,\n\t\t\t     const struct ich_pcm_table *rec)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\tchar name[32];\n\n\tif (rec->suffix)\n\t\tsprintf(name, \"Intel ICH - %s\", rec->suffix);\n\telse\n\t\tstrcpy(name, \"Intel ICH\");\n\terr = snd_pcm_new(chip->card, name, device,\n\t\t\t  rec->playback_ops ? 1 : 0,\n\t\t\t  rec->capture_ops ? 1 : 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rec->playback_ops)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);\n\tif (rec->capture_ops)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tif (rec->suffix)\n\t\tsprintf(pcm->name, \"%s - %s\", chip->card->shortname, rec->suffix);\n\telse\n\t\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm[device] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, intel8x0_dma_type(chip),\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       rec->prealloc_size, rec->prealloc_max_size);\n\n\tif (rec->playback_ops &&\n\t    rec->playback_ops->open == snd_intel8x0_playback_open) {\n\t\tstruct snd_pcm_chmap *chmap;\n\t\tint chs = 2;\n\t\tif (chip->multi8)\n\t\t\tchs = 8;\n\t\telse if (chip->multi6)\n\t\t\tchs = 6;\n\t\telse if (chip->multi4)\n\t\t\tchs = 4;\n\t\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t     snd_pcm_alt_chmaps, chs, 0,\n\t\t\t\t\t     &chmap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\n\t\tchip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ich_pcm_table intel_pcms[] = {\n\t{\n\t\t.playback_ops = &snd_intel8x0_playback_ops,\n\t\t.capture_ops = &snd_intel8x0_capture_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t},\n\t{\n\t\t.suffix = \"MIC ADC\",\n\t\t.capture_ops = &snd_intel8x0_capture_mic_ops,\n\t\t.prealloc_size = 0,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ICHD_MIC,\n\t},\n\t{\n\t\t.suffix = \"MIC2 ADC\",\n\t\t.capture_ops = &snd_intel8x0_capture_mic2_ops,\n\t\t.prealloc_size = 0,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ICHD_MIC2,\n\t},\n\t{\n\t\t.suffix = \"ADC2\",\n\t\t.capture_ops = &snd_intel8x0_capture2_ops,\n\t\t.prealloc_size = 0,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ICHD_PCM2IN,\n\t},\n\t{\n\t\t.suffix = \"IEC958\",\n\t\t.playback_ops = &snd_intel8x0_spdif_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ICHD_SPBAR,\n\t},\n};\n\nstatic const struct ich_pcm_table nforce_pcms[] = {\n\t{\n\t\t.playback_ops = &snd_intel8x0_playback_ops,\n\t\t.capture_ops = &snd_intel8x0_capture_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t},\n\t{\n\t\t.suffix = \"MIC ADC\",\n\t\t.capture_ops = &snd_intel8x0_capture_mic_ops,\n\t\t.prealloc_size = 0,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = NVD_MIC,\n\t},\n\t{\n\t\t.suffix = \"IEC958\",\n\t\t.playback_ops = &snd_intel8x0_spdif_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = NVD_SPBAR,\n\t},\n};\n\nstatic const struct ich_pcm_table ali_pcms[] = {\n\t{\n\t\t.playback_ops = &snd_intel8x0_ali_playback_ops,\n\t\t.capture_ops = &snd_intel8x0_ali_capture_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t},\n\t{\n\t\t.suffix = \"MIC ADC\",\n\t\t.capture_ops = &snd_intel8x0_ali_capture_mic_ops,\n\t\t.prealloc_size = 0,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ALID_MIC,\n\t},\n\t{\n\t\t.suffix = \"IEC958\",\n\t\t.playback_ops = &snd_intel8x0_ali_ac97spdifout_ops,\n\t\t \n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t\t.ac97_idx = ALID_AC97SPDIFOUT,\n\t},\n#if 0 \n\t{\n\t\t.suffix = \"HW IEC958\",\n\t\t.playback_ops = &snd_intel8x0_ali_spdifout_ops,\n\t\t.prealloc_size = 64 * 1024,\n\t\t.prealloc_max_size = 128 * 1024,\n\t},\n#endif\n};\n\nstatic int snd_intel8x0_pcm(struct intel8x0 *chip)\n{\n\tint i, tblsize, device, err;\n\tconst struct ich_pcm_table *tbl, *rec;\n\n\tswitch (chip->device_type) {\n\tcase DEVICE_INTEL_ICH4:\n\t\ttbl = intel_pcms;\n\t\ttblsize = ARRAY_SIZE(intel_pcms);\n\t\tif (spdif_aclink)\n\t\t\ttblsize--;\n\t\tbreak;\n\tcase DEVICE_NFORCE:\n\t\ttbl = nforce_pcms;\n\t\ttblsize = ARRAY_SIZE(nforce_pcms);\n\t\tif (spdif_aclink)\n\t\t\ttblsize--;\n\t\tbreak;\n\tcase DEVICE_ALI:\n\t\ttbl = ali_pcms;\n\t\ttblsize = ARRAY_SIZE(ali_pcms);\n\t\tbreak;\n\tdefault:\n\t\ttbl = intel_pcms;\n\t\ttblsize = 2;\n\t\tbreak;\n\t}\n\n\tdevice = 0;\n\tfor (i = 0; i < tblsize; i++) {\n\t\trec = tbl + i;\n\t\tif (i > 0 && rec->ac97_idx) {\n\t\t\t \n\t\t\tif (! chip->ichd[rec->ac97_idx].pcm)\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = snd_intel8x0_pcm1(chip, device, rec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdevice++;\n\t}\n\n\tchip->pcm_devs = device;\n\treturn 0;\n}\n\t\n\n \n\nstatic void snd_intel8x0_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct intel8x0 *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_intel8x0_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct intel8x0 *chip = ac97->private_data;\n\tchip->ac97[ac97->num] = NULL;\n}\n\nstatic const struct ac97_pcm ac97_pcm_defs[] = {\n\t \n\t{\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_CENTER) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_SLEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_SRIGHT) |\n\t\t\t\t\t (1 << AC97_SLOT_LFE)\n\t\t\t},\n\t\t\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_LEFT_0) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT_0)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_MIC)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.exclusive = 1,\n\t\t.spdif = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_SPDIF_LEFT2) |\n\t\t\t\t\t (1 << AC97_SLOT_SPDIF_RIGHT2)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_MIC)\n\t\t\t}\n\t\t}\n\t},\n};\n\nstatic const struct ac97_quirk ac97_quirks[] = {\n        {\n\t\t.subvendor = 0x0e11,\n\t\t.subdevice = 0x000e,\n\t\t.name = \"Compaq Deskpro EN\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n        },\n\t{\n\t\t.subvendor = 0x0e11,\n\t\t.subdevice = 0x008a,\n\t\t.name = \"Compaq Evo W4000\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x0e11,\n\t\t.subdevice = 0x00b8,\n\t\t.name = \"Compaq Evo D510C\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n        {\n\t\t.subvendor = 0x0e11,\n\t\t.subdevice = 0x0860,\n\t\t.name = \"HP/Compaq nx7010\",\n\t\t.type = AC97_TUNE_MUTE_LED\n        },\n\t{\n\t\t.subvendor = 0x1014,\n\t\t.subdevice = 0x0534,\n\t\t.name = \"ThinkPad X31\",\n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x1014,\n\t\t.subdevice = 0x1f00,\n\t\t.name = \"MS-9128\",\n\t\t.type = AC97_TUNE_ALC_JACK\n\t},\n\t{\n\t\t.subvendor = 0x1014,\n\t\t.subdevice = 0x0267,\n\t\t.name = \"IBM NetVista A30p\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1025,\n\t\t.subdevice = 0x0082,\n\t\t.name = \"Acer Travelmate 2310\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1025,\n\t\t.subdevice = 0x0083,\n\t\t.name = \"Acer Aspire 3003LCi\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x00d8,\n\t\t.name = \"Dell Precision 530\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x010d,\n\t\t.name = \"Dell\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0126,\n\t\t.name = \"Dell Optiplex GX260\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x012c,\n\t\t.name = \"Dell Precision 650\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x012d,\n\t\t.name = \"Dell Precision 450\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0147,\n\t\t.name = \"Dell\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0151,\n\t\t.name = \"Dell Optiplex GX270\",   \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x014e,\n\t\t.name = \"Dell D800\",  \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0163,\n\t\t.name = \"Dell Unknown\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x016a,\n\t\t.name = \"Dell Inspiron 8600\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0182,\n\t\t.name = \"Dell Latitude D610\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0186,\n\t\t.name = \"Dell Latitude D810\",  \n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0188,\n\t\t.name = \"Dell Inspiron 6000\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED  \n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0189,\n\t\t.name = \"Dell Inspiron 9300\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x1028,\n\t\t.subdevice = 0x0191,\n\t\t.name = \"Dell Inspiron 8600\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x006d,\n\t\t.name = \"HP zv5000\",\n\t\t.type = AC97_TUNE_MUTE_LED\t \n\t},\n\t{\t \n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x00c3,\n\t\t.name = \"HP xw6000\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x088c,\n\t\t.name = \"HP nc8000\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x0890,\n\t\t.name = \"HP nc6000\",\n\t\t.type = AC97_TUNE_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x129d,\n\t\t.name = \"HP xw8000\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x0938,\n\t\t.name = \"HP nc4200\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x099c,\n\t\t.name = \"HP nx6110/nc6120\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x0944,\n\t\t.name = \"HP nc6220\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x0934,\n\t\t.name = \"HP nc8220\",\n\t\t.type = AC97_TUNE_HP_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x12f1,\n\t\t.name = \"HP xw8200\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x12f2,\n\t\t.name = \"HP xw6200\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x3008,\n\t\t.name = \"HP xw4200\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x104d,\n\t\t.subdevice = 0x8144,\n\t\t.name = \"Sony\",\n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x104d,\n\t\t.subdevice = 0x8197,\n\t\t.name = \"Sony S1XP\",\n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x104d,\n\t\t.subdevice = 0x81c0,\n\t\t.name = \"Sony VAIO VGN-T350P\",  \n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x104d,\n\t\t.subdevice = 0x81c5,\n\t\t.name = \"Sony VAIO VGN-B1VP\",  \n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n \t{\n\t\t.subvendor = 0x1043,\n\t\t.subdevice = 0x80f3,\n\t\t.name = \"ASUS ICH5/AD1985\",\n\t\t.type = AC97_TUNE_AD_SHARING\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x11c3,\n\t\t.name = \"Fujitsu-Siemens E4010\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x1225,\n\t\t.name = \"Fujitsu-Siemens T3010\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x1253,\n\t\t.name = \"Fujitsu S6210\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x127d,\n\t\t.name = \"Fujitsu Lifebook P7010\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x127e,\n\t\t.name = \"Fujitsu Lifebook C1211D\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x12ec,\n\t\t.name = \"Fujitsu-Siemens 4010\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10cf,\n\t\t.subdevice = 0x12f2,\n\t\t.name = \"Fujitsu-Siemens Celsius H320\",\n\t\t.type = AC97_TUNE_SWAP_HP\n\t},\n\t{\n\t\t.subvendor = 0x10f1,\n\t\t.subdevice = 0x2665,\n\t\t.name = \"Fujitsu-Siemens Celsius\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10f1,\n\t\t.subdevice = 0x2885,\n\t\t.name = \"AMD64 Mobo\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10f1,\n\t\t.subdevice = 0x2895,\n\t\t.name = \"Tyan Thunder K8WE\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x10f7,\n\t\t.subdevice = 0x834c,\n\t\t.name = \"Panasonic CF-R4\",\n\t\t.type = AC97_TUNE_HP_ONLY,\n\t},\n\t{\n\t\t.subvendor = 0x110a,\n\t\t.subdevice = 0x0056,\n\t\t.name = \"Fujitsu-Siemens Scenic\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x11d4,\n\t\t.subdevice = 0x5375,\n\t\t.name = \"ADI AD1985 (discrete)\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1462,\n\t\t.subdevice = 0x5470,\n\t\t.name = \"MSI P4 ATX 645 Ultra\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x161f,\n\t\t.subdevice = 0x202f,\n\t\t.name = \"Gateway M520\",\n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x161f,\n\t\t.subdevice = 0x203a,\n\t\t.name = \"Gateway 4525GZ\",\t\t \n\t\t.type = AC97_TUNE_INV_EAPD\n\t},\n\t{\n\t\t.subvendor = 0x1734,\n\t\t.subdevice = 0x0088,\n\t\t.name = \"Fujitsu-Siemens D1522\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x2000,\n\t\t.mask = 0xfff0,\n\t\t.name = \"Intel ICH5/AD1985\",\n\t\t.type = AC97_TUNE_AD_SHARING\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x4000,\n\t\t.mask = 0xfff0,\n\t\t.name = \"Intel ICH5/AD1985\",\n\t\t.type = AC97_TUNE_AD_SHARING\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x4856,\n\t\t.name = \"Intel D845WN (82801BA)\",\n\t\t.type = AC97_TUNE_SWAP_HP\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x4d44,\n\t\t.name = \"Intel D850EMV2\",\t \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x4d56,\n\t\t.name = \"Intel ICH/AD1885\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0x6000,\n\t\t.mask = 0xfff0,\n\t\t.name = \"Intel ICH5/AD1985\",\n\t\t.type = AC97_TUNE_AD_SHARING\n\t},\n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0xe000,\n\t\t.mask = 0xfff0,\n\t\t.name = \"Intel ICH5/AD1985\",\n\t\t.type = AC97_TUNE_AD_SHARING\n\t},\n#if 0  \n\t{\n\t\t.subvendor = 0x8086,\n\t\t.subdevice = 0xa000,\n\t\t.mask = 0xfff0,\n\t\t.name = \"Intel ICH5/AD1985\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n#endif\n\t{ }  \n};\n\nstatic int snd_intel8x0_mixer(struct intel8x0 *chip, int ac97_clock,\n\t\t\t      const char *quirk_override)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tunsigned int i, codecs;\n\tunsigned int glob_sta = 0;\n\tconst struct snd_ac97_bus_ops *ops;\n\tstatic const struct snd_ac97_bus_ops standard_bus_ops = {\n\t\t.write = snd_intel8x0_codec_write,\n\t\t.read = snd_intel8x0_codec_read,\n\t};\n\tstatic const struct snd_ac97_bus_ops ali_bus_ops = {\n\t\t.write = snd_intel8x0_ali_codec_write,\n\t\t.read = snd_intel8x0_ali_codec_read,\n\t};\n\n\tchip->spdif_idx = -1;  \n\tif (!spdif_aclink) {\n\t\tswitch (chip->device_type) {\n\t\tcase DEVICE_NFORCE:\n\t\t\tchip->spdif_idx = NVD_SPBAR;\n\t\t\tbreak;\n\t\tcase DEVICE_ALI:\n\t\t\tchip->spdif_idx = ALID_AC97SPDIFOUT;\n\t\t\tbreak;\n\t\tcase DEVICE_INTEL_ICH4:\n\t\t\tchip->spdif_idx = ICHD_SPBAR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchip->in_ac97_init = 1;\n\t\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_intel8x0_mixer_free_ac97;\n\tac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;\n\tif (chip->xbox)\n\t\tac97.scaps |= AC97_SCAP_DETECT_BY_VENDOR;\n\tif (chip->device_type != DEVICE_ALI) {\n\t\tglob_sta = igetdword(chip, ICHREG(GLOB_STA));\n\t\tops = &standard_bus_ops;\n\t\tchip->in_sdin_init = 1;\n\t\tcodecs = 0;\n\t\tfor (i = 0; i < chip->max_codecs; i++) {\n\t\t\tif (! (glob_sta & chip->codec_bit[i]))\n\t\t\t\tcontinue;\n\t\t\tif (chip->device_type == DEVICE_INTEL_ICH4) {\n\t\t\t\tsnd_intel8x0_codec_read_test(chip, codecs);\n\t\t\t\tchip->ac97_sdin[codecs] =\n\t\t\t\t\tigetbyte(chip, ICHREG(SDM)) & ICH_LDI_MASK;\n\t\t\t\tif (snd_BUG_ON(chip->ac97_sdin[codecs] >= 3))\n\t\t\t\t\tchip->ac97_sdin[codecs] = 0;\n\t\t\t} else\n\t\t\t\tchip->ac97_sdin[codecs] = i;\n\t\t\tcodecs++;\n\t\t}\n\t\tchip->in_sdin_init = 0;\n\t\tif (! codecs)\n\t\t\tcodecs = 1;\n\t} else {\n\t\tops = &ali_bus_ops;\n\t\tcodecs = 1;\n\t\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tunsigned int reg = igetdword(chip, ICHREG(ALI_RTSR));\n\t\t\tif (reg & 0x40) {\n\t\t\t\tcodecs = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiputdword(chip, ICHREG(ALI_RTSR), reg | 0x40);\n\t\t\tudelay(1);\n\t\t}\n\t}\n\terr = snd_ac97_bus(chip->card, 0, ops, chip, &pbus);\n\tif (err < 0)\n\t\tgoto __err;\n\tpbus->private_free = snd_intel8x0_mixer_free_ac97_bus;\n\tif (ac97_clock >= 8000 && ac97_clock <= 48000)\n\t\tpbus->clock = ac97_clock;\n\t \n\tif (chip->device_type == DEVICE_ALI)\n\t\tpbus->no_vra = 1;\n\telse\n\t\tpbus->dra = 1;\n\tchip->ac97_bus = pbus;\n\tchip->ncodecs = codecs;\n\n\tac97.pci = chip->pci;\n\tfor (i = 0; i < codecs; i++) {\n\t\tac97.num = i;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i]);\n\t\tif (err < 0) {\n\t\t\tif (err != -EACCES)\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"Unable to initialize codec #%d\\n\", i);\n\t\t\tif (i == 0)\n\t\t\t\tgoto __err;\n\t\t}\n\t}\n\t \n\tsnd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);\n\t \n\tif (chip->device_type == DEVICE_INTEL_ICH4)\n\t\tpbus->isdin = 1;\n\t \n\ti = ARRAY_SIZE(ac97_pcm_defs);\n\tif (chip->device_type != DEVICE_INTEL_ICH4)\n\t\ti -= 2;\t\t \n\tif (chip->spdif_idx < 0)\n\t\ti--;\t\t \n\terr = snd_ac97_pcm_assign(pbus, i, ac97_pcm_defs);\n\tif (err < 0)\n\t\tgoto __err;\n\tchip->ichd[ICHD_PCMOUT].pcm = &pbus->pcms[0];\n\tchip->ichd[ICHD_PCMIN].pcm = &pbus->pcms[1];\n\tchip->ichd[ICHD_MIC].pcm = &pbus->pcms[2];\n\tif (chip->spdif_idx >= 0)\n\t\tchip->ichd[chip->spdif_idx].pcm = &pbus->pcms[3];\n\tif (chip->device_type == DEVICE_INTEL_ICH4) {\n\t\tchip->ichd[ICHD_PCM2IN].pcm = &pbus->pcms[4];\n\t\tchip->ichd[ICHD_MIC2].pcm = &pbus->pcms[5];\n\t}\n\t \n\tif (chip->device_type == DEVICE_INTEL_ICH4) {\n\t\tstruct ac97_pcm *pcm = chip->ichd[ICHD_PCM2IN].pcm;\n\t\tu8 tmp = igetbyte(chip, ICHREG(SDM));\n\t\ttmp &= ~(ICH_DI2L_MASK|ICH_DI1L_MASK);\n\t\tif (pcm) {\n\t\t\ttmp |= ICH_SE;\t \n\t\t\ttmp |= chip->ac97_sdin[0] << ICH_DI1L_SHIFT;\n\t\t\tfor (i = 1; i < 4; i++) {\n\t\t\t\tif (pcm->r[0].codec[i]) {\n\t\t\t\t\ttmp |= chip->ac97_sdin[pcm->r[0].codec[1]->num] << ICH_DI2L_SHIFT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp &= ~ICH_SE;  \n\t\t}\n\t\tiputbyte(chip, ICHREG(SDM), tmp);\n\t}\n\tif (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {\n\t\tchip->multi4 = 1;\n\t\tif (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_LFE)) {\n\t\t\tchip->multi6 = 1;\n\t\t\tif (chip->ac97[0]->flags & AC97_HAS_8CH)\n\t\t\t\tchip->multi8 = 1;\n\t\t}\n\t}\n\tif (pbus->pcms[0].r[1].rslots[0]) {\n\t\tchip->dra = 1;\n\t}\n\tif (chip->device_type == DEVICE_INTEL_ICH4) {\n\t\tif ((igetdword(chip, ICHREG(GLOB_STA)) & ICH_SAMPLE_CAP) == ICH_SAMPLE_16_20)\n\t\t\tchip->smp20bit = 1;\n\t}\n\tif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\n\t\t \n\t\tchip->ichd[chip->spdif_idx].pcm->rates = SNDRV_PCM_RATE_48000;\n\t}\n\tif (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {\n\t\t \n\t\tu32 val;\n\t\tval = igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_PCM_SPDIF_MASK;\n\t\tval |= ICH_PCM_SPDIF_1011;\n\t\tiputdword(chip, ICHREG(GLOB_CNT), val);\n\t\tsnd_ac97_update_bits(chip->ac97[0], AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);\n\t}\n\tchip->in_ac97_init = 0;\n\treturn 0;\n\n __err:\n\t \n\tif (chip->device_type != DEVICE_ALI)\n\t\tiputdword(chip, ICHREG(GLOB_CNT),\n\t\t\t  igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_AC97COLD);\n\treturn err;\n}\n\n\n \n\nstatic void do_ali_reset(struct intel8x0 *chip)\n{\n\tiputdword(chip, ICHREG(ALI_SCR), ICH_ALI_SC_RESET);\n\tiputdword(chip, ICHREG(ALI_FIFOCR1), 0x83838383);\n\tiputdword(chip, ICHREG(ALI_FIFOCR2), 0x83838383);\n\tiputdword(chip, ICHREG(ALI_FIFOCR3), 0x83838383);\n\tiputdword(chip, ICHREG(ALI_INTERFACECR),\n\t\t  ICH_ALI_IF_PI|ICH_ALI_IF_PO);\n\tiputdword(chip, ICHREG(ALI_INTERRUPTCR), 0x00000000);\n\tiputdword(chip, ICHREG(ALI_INTERRUPTSR), 0x00000000);\n}\n\n#ifdef CONFIG_SND_AC97_POWER_SAVE\nstatic const struct snd_pci_quirk ich_chip_reset_mode[] = {\n\tSND_PCI_QUIRK(0x1014, 0x051f, \"Thinkpad R32\", 1),\n\t{ }  \n};\n\nstatic int snd_intel8x0_ich_chip_cold_reset(struct intel8x0 *chip)\n{\n\tunsigned int cnt;\n\t \n\n\tif (snd_pci_quirk_lookup(chip->pci, ich_chip_reset_mode))\n\t\treturn -EIO;\n\n\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\tcnt &= ~(ICH_ACLINK | ICH_PCM_246_MASK);\n\n\t \n\tiputdword(chip, ICHREG(GLOB_CNT), cnt & ~ICH_AC97COLD);\n\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\tudelay(10);\n\tiputdword(chip, ICHREG(GLOB_CNT), cnt | ICH_AC97COLD);\n\tmsleep(1);\n\treturn 0;\n}\n#define snd_intel8x0_ich_chip_can_cold_reset(chip) \\\n\t(!snd_pci_quirk_lookup(chip->pci, ich_chip_reset_mode))\n#else\n#define snd_intel8x0_ich_chip_cold_reset(chip)\t0\n#define snd_intel8x0_ich_chip_can_cold_reset(chip) (0)\n#endif\n\nstatic int snd_intel8x0_ich_chip_reset(struct intel8x0 *chip)\n{\n\tunsigned long end_time;\n\tunsigned int cnt;\n\t \n\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\tcnt &= ~(ICH_ACLINK | ICH_PCM_246_MASK);\n\t \n\tcnt |= (cnt & ICH_AC97COLD) == 0 ? ICH_AC97COLD : ICH_AC97WARM;\n\tiputdword(chip, ICHREG(GLOB_CNT), cnt);\n\tend_time = (jiffies + (HZ / 4)) + 1;\n\tdo {\n\t\tif ((igetdword(chip, ICHREG(GLOB_CNT)) & ICH_AC97WARM) == 0)\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(chip->card->dev, \"AC'97 warm reset still in progress? [0x%x]\\n\",\n\t\t   igetdword(chip, ICHREG(GLOB_CNT)));\n\treturn -EIO;\n}\n\nstatic int snd_intel8x0_ich_chip_init(struct intel8x0 *chip, int probing)\n{\n\tunsigned long end_time;\n\tunsigned int status, nstatus;\n\tunsigned int cnt;\n\tint err;\n\n\t \n\t \n\tstatus = ICH_RCS | ICH_MCINT | ICH_POINT | ICH_PIINT;\n\tif (chip->device_type == DEVICE_NFORCE)\n\t\tstatus |= ICH_NVSPINT;\n\tcnt = igetdword(chip, ICHREG(GLOB_STA));\n\tiputdword(chip, ICHREG(GLOB_STA), cnt & status);\n\n\tif (snd_intel8x0_ich_chip_can_cold_reset(chip))\n\t\terr = snd_intel8x0_ich_chip_cold_reset(chip);\n\telse\n\t\terr = snd_intel8x0_ich_chip_reset(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (probing) {\n\t\t \n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tstatus = igetdword(chip, ICHREG(GLOB_STA)) &\n\t\t\t\tchip->codec_isr_bits;\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tif (! status) {\n\t\t\t \n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_ready: codec is not ready [0x%x]\\n\",\n\t\t\t\t   igetdword(chip, ICHREG(GLOB_STA)));\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tend_time = jiffies + HZ / 4;\n\t\twhile (status != chip->codec_isr_bits &&\n\t\t       time_after_eq(end_time, jiffies)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tstatus |= igetdword(chip, ICHREG(GLOB_STA)) &\n\t\t\t\tchip->codec_isr_bits;\n\t\t}\n\n\t} else {\n\t\t \n\t\tint i;\n\t\tstatus = 0;\n\t\tfor (i = 0; i < chip->ncodecs; i++)\n\t\t\tif (chip->ac97[i])\n\t\t\t\tstatus |= chip->codec_bit[chip->ac97_sdin[i]];\n\t\t \n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tnstatus = igetdword(chip, ICHREG(GLOB_STA)) &\n\t\t\t\tchip->codec_isr_bits;\n\t\t\tif (status == nstatus)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t}\n\n\tif (chip->device_type == DEVICE_SIS) {\n\t\t \n\t\tiputword(chip, 0x4c, igetword(chip, 0x4c) | 1);\n\t}\n\tif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\n\t\t \n\t\tunsigned int val;\n\t\tpci_read_config_dword(chip->pci, 0x4c, &val);\n\t\tval |= 0x1000000;\n\t\tpci_write_config_dword(chip->pci, 0x4c, val);\n\t}\n      \treturn 0;\n}\n\nstatic int snd_intel8x0_ali_chip_init(struct intel8x0 *chip, int probing)\n{\n\tu32 reg;\n\tint i = 0;\n\n\treg = igetdword(chip, ICHREG(ALI_SCR));\n\tif ((reg & 2) == 0)\t \n\t\treg |= 2;\n\telse\n\t\treg |= 1;\t \n\treg &= ~0x80000000;\t \n\tiputdword(chip, ICHREG(ALI_SCR), reg);\n\n\tfor (i = 0; i < HZ / 2; i++) {\n\t\tif (! (igetdword(chip, ICHREG(ALI_INTERRUPTSR)) & ALI_INT_GPIO))\n\t\t\tgoto __ok;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tdev_err(chip->card->dev, \"AC'97 reset failed.\\n\");\n\tif (probing)\n\t\treturn -EIO;\n\n __ok:\n\tfor (i = 0; i < HZ / 2; i++) {\n\t\treg = igetdword(chip, ICHREG(ALI_RTSR));\n\t\tif (reg & 0x80)  \n\t\t\tbreak;\n\t\tiputdword(chip, ICHREG(ALI_RTSR), reg | 0x80);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\tdo_ali_reset(chip);\n\treturn 0;\n}\n\nstatic int snd_intel8x0_chip_init(struct intel8x0 *chip, int probing)\n{\n\tunsigned int i, timeout;\n\tint err;\n\t\n\tif (chip->device_type != DEVICE_ALI) {\n\t\terr = snd_intel8x0_ich_chip_init(chip, probing);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tiagetword(chip, 0);\t \n\t} else {\n\t\terr = snd_intel8x0_ali_chip_init(chip, probing);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t        timeout = 100000;\n\t        while (--timeout != 0) {\n        \t\tif ((igetbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset) & ICH_RESETREGS) == 0)\n        \t\t        break;\n                }\n                if (timeout == 0)\n\t\t\tdev_err(chip->card->dev, \"reset of registers failed?\\n\");\n        }\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset,\n\t\t\t  chip->ichd[i].bdbar_addr);\n\treturn 0;\n}\n\nstatic void snd_intel8x0_free(struct snd_card *card)\n{\n\tstruct intel8x0 *chip = card->private_data;\n\tunsigned int i;\n\n\tif (chip->irq < 0)\n\t\tgoto __hw_end;\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\n\tif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\n\t\t \n\t\tunsigned int val;\n\t\tpci_read_config_dword(chip->pci, 0x4c, &val);\n\t\tval &= ~0x1000000;\n\t\tpci_write_config_dword(chip->pci, 0x4c, val);\n\t}\n\t \n\n      __hw_end:\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int intel8x0_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct intel8x0 *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tfor (i = 0; i < chip->ncodecs; i++)\n\t\tsnd_ac97_suspend(chip->ac97[i]);\n\tif (chip->device_type == DEVICE_INTEL_ICH4)\n\t\tchip->sdm_saved = igetbyte(chip, ICHREG(SDM));\n\n\tif (chip->irq >= 0) {\n\t\tfree_irq(chip->irq, chip);\n\t\tchip->irq = -1;\n\t\tcard->sync_irq = -1;\n\t}\n\treturn 0;\n}\n\nstatic int intel8x0_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct intel8x0 *chip = card->private_data;\n\tint i;\n\n\tsnd_intel8x0_chip_init(chip, 0);\n\tif (request_irq(pci->irq, snd_intel8x0_interrupt,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(dev, \"unable to grab IRQ %d, disabling device\\n\",\n\t\t\tpci->irq);\n\t\tsnd_card_disconnect(card);\n\t\treturn -EIO;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\t \n\tif (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {\n\t\t \n\t\tiputbyte(chip, ICHREG(SDM), chip->sdm_saved);\n\t\t \n\t\tiputdword(chip, ICHREG(GLOB_CNT),\n\t\t\t  (igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_PCM_SPDIF_MASK) |\n\t\t\t  ICH_PCM_SPDIF_1011);\n\t}\n\n\tfor (i = 0; i < chip->ncodecs; i++)\n\t\tsnd_ac97_resume(chip->ac97[i]);\n\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tstruct ichdev *ichdev = &chip->ichd[i];\n\t\tunsigned long port = ichdev->reg_offset;\n\t\tif (! ichdev->substream || ! ichdev->suspended)\n\t\t\tcontinue;\n\t\tif (ichdev->ichd == ICHD_PCMOUT)\n\t\t\tsnd_intel8x0_setup_pcm_out(chip, ichdev->substream->runtime);\n\t\tiputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\n\t\tiputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\n\t\tiputbyte(chip, port + ICH_REG_OFF_CIV, ichdev->civ);\n\t\tiputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\n\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(intel8x0_pm, intel8x0_suspend, intel8x0_resume);\n#define INTEL8X0_PM_OPS\t&intel8x0_pm\n#else\n#define INTEL8X0_PM_OPS\tNULL\n#endif  \n\n#define INTEL8X0_TESTBUF_SIZE\t32768\t \n\nstatic void intel8x0_measure_ac97_clock(struct intel8x0 *chip)\n{\n\tstruct snd_pcm_substream *subs;\n\tstruct ichdev *ichdev;\n\tunsigned long port;\n\tunsigned long pos, pos1, t;\n\tint civ, timeout = 1000, attempt = 1;\n\tktime_t start_time, stop_time;\n\n\tif (chip->ac97_bus->clock != 48000)\n\t\treturn;  \n\tif (chip->inside_vm && !ac97_clock)\n\t\treturn;  \n\n      __again:\n\tsubs = chip->pcm[0]->streams[0].substream;\n\tif (! subs || subs->dma_buffer.bytes < INTEL8X0_TESTBUF_SIZE) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t \"no playback buffer allocated - aborting measure ac97 clock\\n\");\n\t\treturn;\n\t}\n\tichdev = &chip->ichd[ICHD_PCMOUT];\n\tichdev->physbuf = subs->dma_buffer.addr;\n\tichdev->size = ichdev->fragsize = INTEL8X0_TESTBUF_SIZE;\n\tichdev->substream = NULL;  \n\n\t \n\tif (snd_ac97_set_rate(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 48000) < 0) {\n\t\tdev_err(chip->card->dev, \"cannot set ac97 rate: clock = %d\\n\",\n\t\t\tchip->ac97_bus->clock);\n\t\treturn;\n\t}\n\tsnd_intel8x0_setup_periods(chip, ichdev);\n\tport = ichdev->reg_offset;\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->in_measurement = 1;\n\t \n\tif (chip->device_type != DEVICE_ALI)\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE | ICH_STARTBM);\n\telse {\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE);\n\t\tiputdword(chip, ICHREG(ALI_DMACR), 1 << ichdev->ali_slot);\n\t}\n\tstart_time = ktime_get();\n\tspin_unlock_irq(&chip->reg_lock);\n\tmsleep(50);\n\tspin_lock_irq(&chip->reg_lock);\n\t \n\tdo {\n\t\tciv = igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV);\n\t\tpos1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb);\n\t\tif (pos1 == 0) {\n\t\t\tudelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\tif (civ == igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV) &&\n\t\t    pos1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))\n\t\t\tbreak;\n\t} while (timeout--);\n\tif (pos1 == 0) {\t \n\t\tpos = 0;\n\t} else {\n\t\tpos = ichdev->fragsize1;\n\t\tpos -= pos1 << ichdev->pos_shift;\n\t\tpos += ichdev->position;\n\t}\n\tchip->in_measurement = 0;\n\tstop_time = ktime_get();\n\t \n\tif (chip->device_type == DEVICE_ALI) {\n\t\tiputdword(chip, ICHREG(ALI_DMACR), 1 << (ichdev->ali_slot + 16));\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, 0);\n\t\twhile (igetbyte(chip, port + ICH_REG_OFF_CR))\n\t\t\t;\n\t} else {\n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, 0);\n\t\twhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH))\n\t\t\t;\n\t}\n\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tif (pos == 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"measure - unreliable DMA position..\\n\");\n\t      __retry:\n\t\tif (attempt < 3) {\n\t\t\tmsleep(300);\n\t\t\tattempt++;\n\t\t\tgoto __again;\n\t\t}\n\t\tgoto __end;\n\t}\n\n\tpos /= 4;\n\tt = ktime_us_delta(stop_time, start_time);\n\tdev_info(chip->card->dev,\n\t\t \"%s: measured %lu usecs (%lu samples)\\n\", __func__, t, pos);\n\tif (t == 0) {\n\t\tdev_err(chip->card->dev, \"?? calculation error..\\n\");\n\t\tgoto __retry;\n\t}\n\tpos *= 1000;\n\tpos = (pos / t) * 1000 + ((pos % t) * 1000) / t;\n\tif (pos < 40000 || pos >= 60000) {\n\t\t \n\t\tdev_info(chip->card->dev, \"measured clock %ld rejected\\n\", pos);\n\t\tgoto __retry;\n\t} else if (pos > 40500 && pos < 41500)\n\t\t \n\t\tchip->ac97_bus->clock = 41000;\n\telse if (pos > 43600 && pos < 44600)\n\t\t \n\t\tchip->ac97_bus->clock = 44100;\n\telse if (pos < 47500 || pos > 48500)\n\t\t \n\t\tchip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;\n      __end:\n\tdev_info(chip->card->dev, \"clocking to %d\\n\", chip->ac97_bus->clock);\n\tsnd_ac97_update_power(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 0);\n}\n\nstatic const struct snd_pci_quirk intel8x0_clock_list[] = {\n\tSND_PCI_QUIRK(0x0e11, 0x008a, \"AD1885\", 41000),\n\tSND_PCI_QUIRK(0x1014, 0x0581, \"AD1981B\", 48000),\n\tSND_PCI_QUIRK(0x1028, 0x00be, \"AD1885\", 44100),\n\tSND_PCI_QUIRK(0x1028, 0x0177, \"AD1980\", 48000),\n\tSND_PCI_QUIRK(0x1028, 0x01ad, \"AD1981B\", 48000),\n\tSND_PCI_QUIRK(0x1043, 0x80f3, \"AD1985\", 48000),\n\t{ }\t \n};\n\nstatic int intel8x0_in_clock_list(struct intel8x0 *chip)\n{\n\tstruct pci_dev *pci = chip->pci;\n\tconst struct snd_pci_quirk *wl;\n\n\twl = snd_pci_quirk_lookup(pci, intel8x0_clock_list);\n\tif (!wl)\n\t\treturn 0;\n\tdev_info(chip->card->dev, \"allow list rate for %04x:%04x is %i\\n\",\n\t       pci->subsystem_vendor, pci->subsystem_device, wl->value);\n\tchip->ac97_bus->clock = wl->value;\n\treturn 1;\n}\n\nstatic void snd_intel8x0_proc_read(struct snd_info_entry * entry,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct intel8x0 *chip = entry->private_data;\n\tunsigned int tmp;\n\n\tsnd_iprintf(buffer, \"Intel8x0\\n\\n\");\n\tif (chip->device_type == DEVICE_ALI)\n\t\treturn;\n\ttmp = igetdword(chip, ICHREG(GLOB_STA));\n\tsnd_iprintf(buffer, \"Global control        : 0x%08x\\n\", igetdword(chip, ICHREG(GLOB_CNT)));\n\tsnd_iprintf(buffer, \"Global status         : 0x%08x\\n\", tmp);\n\tif (chip->device_type == DEVICE_INTEL_ICH4)\n\t\tsnd_iprintf(buffer, \"SDM                   : 0x%08x\\n\", igetdword(chip, ICHREG(SDM)));\n\tsnd_iprintf(buffer, \"AC'97 codecs ready    :\");\n\tif (tmp & chip->codec_isr_bits) {\n\t\tint i;\n\t\tstatic const char *codecs[3] = {\n\t\t\t\"primary\", \"secondary\", \"tertiary\"\n\t\t};\n\t\tfor (i = 0; i < chip->max_codecs; i++)\n\t\t\tif (tmp & chip->codec_bit[i])\n\t\t\t\tsnd_iprintf(buffer, \" %s\", codecs[i]);\n\t} else\n\t\tsnd_iprintf(buffer, \" none\");\n\tsnd_iprintf(buffer, \"\\n\");\n\tif (chip->device_type == DEVICE_INTEL_ICH4 ||\n\t    chip->device_type == DEVICE_SIS)\n\t\tsnd_iprintf(buffer, \"AC'97 codecs SDIN     : %i %i %i\\n\",\n\t\t\tchip->ac97_sdin[0],\n\t\t\tchip->ac97_sdin[1],\n\t\t\tchip->ac97_sdin[2]);\n}\n\nstatic void snd_intel8x0_proc_init(struct intel8x0 *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"intel8x0\", chip,\n\t\t\t     snd_intel8x0_proc_read);\n}\n\nstruct ich_reg_info {\n\tunsigned int int_sta_mask;\n\tunsigned int offset;\n};\n\nstatic const unsigned int ich_codec_bits[3] = {\n\tICH_PCR, ICH_SCR, ICH_TCR\n};\nstatic const unsigned int sis_codec_bits[3] = {\n\tICH_PCR, ICH_SCR, ICH_SIS_TCR\n};\n\nstatic int snd_intel8x0_inside_vm(struct pci_dev *pci)\n{\n\tint result  = inside_vm;\n\tchar *msg   = NULL;\n\n\t \n\tif (result >= 0) {\n\t\tmsg = result ? \"enable (forced) VM\" : \"disable (forced) VM\";\n\t\tgoto fini;\n\t}\n\n\t \n\tresult = 0;\n\tif (pci->subsystem_vendor == PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&\n\t    pci->subsystem_device == PCI_SUBDEVICE_ID_QEMU) {\n\t\t \n\t\tmsg = \"enable KVM\";\n\t\tresult = 1;\n\t} else if (pci->subsystem_vendor == 0x1ab8) {\n\t\t \n\t\tmsg = \"enable Parallels VM\";\n\t\tresult = 1;\n\t}\n\nfini:\n\tif (msg != NULL)\n\t\tdev_info(&pci->dev, \"%s optimization\\n\", msg);\n\n\treturn result;\n}\n\nstatic int snd_intel8x0_init(struct snd_card *card,\n\t\t\t     struct pci_dev *pci,\n\t\t\t     unsigned long device_type)\n{\n\tstruct intel8x0 *chip = card->private_data;\n\tint err;\n\tunsigned int i;\n\tunsigned int int_sta_masks;\n\tstruct ichdev *ichdev;\n\n\tstatic const unsigned int bdbars[] = {\n\t\t3,  \n\t\t6,  \n\t\t3,  \n\t\t6,  \n\t\t4,  \n\t};\n\tstatic const struct ich_reg_info intel_regs[6] = {\n\t\t{ ICH_PIINT, 0 },\n\t\t{ ICH_POINT, 0x10 },\n\t\t{ ICH_MCINT, 0x20 },\n\t\t{ ICH_M2INT, 0x40 },\n\t\t{ ICH_P2INT, 0x50 },\n\t\t{ ICH_SPINT, 0x60 },\n\t};\n\tstatic const struct ich_reg_info nforce_regs[4] = {\n\t\t{ ICH_PIINT, 0 },\n\t\t{ ICH_POINT, 0x10 },\n\t\t{ ICH_MCINT, 0x20 },\n\t\t{ ICH_NVSPINT, 0x70 },\n\t};\n\tstatic const struct ich_reg_info ali_regs[6] = {\n\t\t{ ALI_INT_PCMIN, 0x40 },\n\t\t{ ALI_INT_PCMOUT, 0x50 },\n\t\t{ ALI_INT_MICIN, 0x60 },\n\t\t{ ALI_INT_CODECSPDIFOUT, 0x70 },\n\t\t{ ALI_INT_SPDIFIN, 0xa0 },\n\t\t{ ALI_INT_SPDIFOUT, 0xb0 },\n\t};\n\tconst struct ich_reg_info *tbl;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tchip->device_type = device_type;\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\t \n\tchip->buggy_irq = buggy_irq;\n\tchip->buggy_semaphore = buggy_semaphore;\n\tif (xbox)\n\t\tchip->xbox = 1;\n\n\tchip->inside_vm = snd_intel8x0_inside_vm(pci);\n\n\t \n\tif (pci->vendor == PCI_VENDOR_ID_INTEL &&\n\t    pci->device == PCI_DEVICE_ID_INTEL_440MX)\n\t\tchip->fix_nocache = 1;  \n\n\terr = pci_request_regions(pci, card->shortname);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (device_type == DEVICE_ALI) {\n\t\t \n\t\tchip->bmaddr = pcim_iomap(pci, 0, 0);\n\t} else {\n\t\tif (pci_resource_flags(pci, 2) & IORESOURCE_MEM)  \n\t\t\tchip->addr = pcim_iomap(pci, 2, 0);\n\t\telse\n\t\t\tchip->addr = pcim_iomap(pci, 0, 0);\n\t\tif (pci_resource_flags(pci, 3) & IORESOURCE_MEM)  \n\t\t\tchip->bmaddr = pcim_iomap(pci, 3, 0);\n\t\telse\n\t\t\tchip->bmaddr = pcim_iomap(pci, 1, 0);\n\t}\n\n\tchip->bdbars_count = bdbars[device_type];\n\n\t \n\tswitch (device_type) {\n\tcase DEVICE_NFORCE:\n\t\ttbl = nforce_regs;\n\t\tbreak;\n\tcase DEVICE_ALI:\n\t\ttbl = ali_regs;\n\t\tbreak;\n\tdefault:\n\t\ttbl = intel_regs;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tichdev->ichd = i;\n\t\tichdev->reg_offset = tbl[i].offset;\n\t\tichdev->int_sta_mask = tbl[i].int_sta_mask;\n\t\tif (device_type == DEVICE_SIS) {\n\t\t\t \n\t\t\tichdev->roff_sr = ICH_REG_OFF_PICB;\n\t\t\tichdev->roff_picb = ICH_REG_OFF_SR;\n\t\t} else {\n\t\t\tichdev->roff_sr = ICH_REG_OFF_SR;\n\t\t\tichdev->roff_picb = ICH_REG_OFF_PICB;\n\t\t}\n\t\tif (device_type == DEVICE_ALI)\n\t\t\tichdev->ali_slot = (ichdev->reg_offset - 0x40) / 0x10;\n\t\t \n\t\tichdev->pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;\n\t}\n\n\t \n\t \n\tchip->bdbars = snd_devm_alloc_pages(&pci->dev, intel8x0_dma_type(chip),\n\t\t\t\t\t    chip->bdbars_count * sizeof(u32) *\n\t\t\t\t\t    ICH_MAX_FRAGS * 2);\n\tif (!chip->bdbars)\n\t\treturn -ENOMEM;\n\n\t \n\tint_sta_masks = 0;\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tichdev->bdbar = ((__le32 *)chip->bdbars->area) +\n\t\t\t(i * ICH_MAX_FRAGS * 2);\n\t\tichdev->bdbar_addr = chip->bdbars->addr +\n\t\t\t(i * sizeof(u32) * ICH_MAX_FRAGS * 2);\n\t\tint_sta_masks |= ichdev->int_sta_mask;\n\t}\n\tchip->int_sta_reg = device_type == DEVICE_ALI ?\n\t\tICH_REG_ALI_INTERRUPTSR : ICH_REG_GLOB_STA;\n\tchip->int_sta_mask = int_sta_masks;\n\n\tpci_set_master(pci);\n\n\tswitch(chip->device_type) {\n\tcase DEVICE_INTEL_ICH4:\n\t\t \n\t\tchip->max_codecs = 3;\n\t\tchip->codec_bit = ich_codec_bits;\n\t\tchip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_TRI;\n\t\tbreak;\n\tcase DEVICE_SIS:\n\t\t \n\t\tchip->max_codecs = 3;\n\t\tchip->codec_bit = sis_codec_bits;\n\t\tchip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_SIS_TRI;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tchip->max_codecs = 2;\n\t\tchip->codec_bit = ich_codec_bits;\n\t\tchip->codec_ready_bits = ICH_PRI | ICH_SRI;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < chip->max_codecs; i++)\n\t\tchip->codec_isr_bits |= chip->codec_bit[i];\n\n\terr = snd_intel8x0_chip_init(chip, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\t \n\tif (request_irq(pci->irq, snd_intel8x0_interrupt,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\tcard->private_free = snd_intel8x0_free;\n\n\treturn 0;\n}\n\nstatic struct shortname_table {\n\tunsigned int id;\n\tconst char *s;\n} shortnames[] = {\n\t{ PCI_DEVICE_ID_INTEL_82801AA_5, \"Intel 82801AA-ICH\" },\n\t{ PCI_DEVICE_ID_INTEL_82801AB_5, \"Intel 82901AB-ICH0\" },\n\t{ PCI_DEVICE_ID_INTEL_82801BA_4, \"Intel 82801BA-ICH2\" },\n\t{ PCI_DEVICE_ID_INTEL_440MX, \"Intel 440MX\" },\n\t{ PCI_DEVICE_ID_INTEL_82801CA_5, \"Intel 82801CA-ICH3\" },\n\t{ PCI_DEVICE_ID_INTEL_82801DB_5, \"Intel 82801DB-ICH4\" },\n\t{ PCI_DEVICE_ID_INTEL_82801EB_5, \"Intel ICH5\" },\n\t{ PCI_DEVICE_ID_INTEL_ESB_5, \"Intel 6300ESB\" },\n\t{ PCI_DEVICE_ID_INTEL_ICH6_18, \"Intel ICH6\" },\n\t{ PCI_DEVICE_ID_INTEL_ICH7_20, \"Intel ICH7\" },\n\t{ PCI_DEVICE_ID_INTEL_ESB2_14, \"Intel ESB2\" },\n\t{ PCI_DEVICE_ID_SI_7012, \"SiS SI7012\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO, \"NVidia nForce\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO, \"NVidia nForce2\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO, \"NVidia nForce3\" },\n\t{ PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO, \"NVidia CK8S\" },\n\t{ PCI_DEVICE_ID_NVIDIA_CK804_AUDIO, \"NVidia CK804\" },\n\t{ PCI_DEVICE_ID_NVIDIA_CK8_AUDIO, \"NVidia CK8\" },\n\t{ 0x003a, \"NVidia MCP04\" },\n\t{ 0x746d, \"AMD AMD8111\" },\n\t{ 0x7445, \"AMD AMD768\" },\n\t{ 0x5455, \"ALi M5455\" },\n\t{ 0, NULL },\n};\n\nstatic const struct snd_pci_quirk spdif_aclink_defaults[] = {\n\tSND_PCI_QUIRK(0x147b, 0x1c1a, \"ASUS KN8\", 1),\n\t{ }  \n};\n\n \nstatic int check_default_spdif_aclink(struct pci_dev *pci)\n{\n\tconst struct snd_pci_quirk *w;\n\n\tw = snd_pci_quirk_lookup(pci, spdif_aclink_defaults);\n\tif (w) {\n\t\tif (w->value)\n\t\t\tdev_dbg(&pci->dev,\n\t\t\t\t\"Using SPDIF over AC-Link for %s\\n\",\n\t\t\t\t    snd_pci_quirk_name(w));\n\t\telse\n\t\t\tdev_dbg(&pci->dev,\n\t\t\t\t\"Using integrated SPDIF DMA for %s\\n\",\n\t\t\t\t    snd_pci_quirk_name(w));\n\t\treturn w->value;\n\t}\n\treturn 0;\n}\n\nstatic int __snd_intel8x0_probe(struct pci_dev *pci,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct intel8x0 *chip;\n\tint err;\n\tstruct shortname_table *name;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tif (spdif_aclink < 0)\n\t\tspdif_aclink = check_default_spdif_aclink(pci);\n\n\tstrcpy(card->driver, \"ICH\");\n\tif (!spdif_aclink) {\n\t\tswitch (pci_id->driver_data) {\n\t\tcase DEVICE_NFORCE:\n\t\t\tstrcpy(card->driver, \"NFORCE\");\n\t\t\tbreak;\n\t\tcase DEVICE_INTEL_ICH4:\n\t\t\tstrcpy(card->driver, \"ICH4\");\n\t\t}\n\t}\n\n\tstrcpy(card->shortname, \"Intel ICH\");\n\tfor (name = shortnames; name->id; name++) {\n\t\tif (pci->device == name->id) {\n\t\t\tstrcpy(card->shortname, name->s);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (buggy_irq < 0) {\n\t\t \n\t\tif (pci_id->driver_data == DEVICE_NFORCE)\n\t\t\tbuggy_irq = 1;\n\t\telse\n\t\t\tbuggy_irq = 0;\n\t}\n\n\terr = snd_intel8x0_init(card, pci, pci_id->driver_data);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_intel8x0_mixer(chip, ac97_clock, ac97_quirk);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_intel8x0_pcm(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_intel8x0_proc_init(chip);\n\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s with %s at irq %i\", card->shortname,\n\t\t snd_ac97_get_short_name(chip->ac97[0]), chip->irq);\n\n\tif (ac97_clock == 0 || ac97_clock == 1) {\n\t\tif (ac97_clock == 0) {\n\t\t\tif (intel8x0_in_clock_list(chip) == 0)\n\t\t\t\tintel8x0_measure_ac97_clock(chip);\n\t\t} else {\n\t\t\tintel8x0_measure_ac97_clock(chip);\n\t\t}\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_intel8x0_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_intel8x0_probe(pci, pci_id));\n}\n\nstatic struct pci_driver intel8x0_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_intel8x0_ids,\n\t.probe = snd_intel8x0_probe,\n\t.driver = {\n\t\t.pm = INTEL8X0_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(intel8x0_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}