{
  "module_name": "trident_memory.c",
  "hash_id": "b2907151df4167e9f06d0b840b9b3c8d6849347b4452a5282b763856b6988c95",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/trident/trident_memory.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include \"trident.h\"\n\n \n#define __set_tlb_bus(trident,page,addr) \\\n\t(trident)->tlb.entries[page] = cpu_to_le32((addr) & ~(SNDRV_TRIDENT_PAGE_SIZE-1))\n#define __tlb_to_addr(trident,page) \\\n\t(dma_addr_t)le32_to_cpu((trident->tlb.entries[page]) & ~(SNDRV_TRIDENT_PAGE_SIZE - 1))\n\n#if PAGE_SIZE == 4096\n \n#define ALIGN_PAGE_SIZE\t\tPAGE_SIZE\t \n#define MAX_ALIGN_PAGES\t\tSNDRV_TRIDENT_MAX_PAGES\t \n \n#define set_tlb_bus(trident,page,addr) __set_tlb_bus(trident,page,addr)\n \n#define set_silent_tlb(trident,page)\t__set_tlb_bus(trident, page, trident->tlb.silent_page->addr)\n \n#define get_aligned_page(offset)\t((offset) >> 12)\n \n#define aligned_page_offset(page)\t((page) << 12)\n \n#define page_to_addr(trident,page)\t__tlb_to_addr(trident, page)\n\n#elif PAGE_SIZE == 8192\n \n#define ALIGN_PAGE_SIZE\t\tPAGE_SIZE\n#define MAX_ALIGN_PAGES\t\t(SNDRV_TRIDENT_MAX_PAGES / 2)\n#define get_aligned_page(offset)\t((offset) >> 13)\n#define aligned_page_offset(page)\t((page) << 13)\n#define page_to_addr(trident,page)\t__tlb_to_addr(trident, (page) << 1)\n\n \nstatic inline void set_tlb_bus(struct snd_trident *trident, int page,\n\t\t\t       dma_addr_t addr)\n{\n\tpage <<= 1;\n\t__set_tlb_bus(trident, page, addr);\n\t__set_tlb_bus(trident, page+1, addr + SNDRV_TRIDENT_PAGE_SIZE);\n}\nstatic inline void set_silent_tlb(struct snd_trident *trident, int page)\n{\n\tpage <<= 1;\n\t__set_tlb_bus(trident, page, trident->tlb.silent_page->addr);\n\t__set_tlb_bus(trident, page+1, trident->tlb.silent_page->addr);\n}\n\n#else\n \n#define UNIT_PAGES\t\t(PAGE_SIZE / SNDRV_TRIDENT_PAGE_SIZE)\n#define ALIGN_PAGE_SIZE\t\t(SNDRV_TRIDENT_PAGE_SIZE * UNIT_PAGES)\n#define MAX_ALIGN_PAGES\t\t(SNDRV_TRIDENT_MAX_PAGES / UNIT_PAGES)\n \n#define get_aligned_page(offset)\t((offset) / ALIGN_PAGE_SIZE)\n#define aligned_page_offset(page)\t((page) * ALIGN_PAGE_SIZE)\n#define page_to_addr(trident,page)\t__tlb_to_addr(trident, (page) * UNIT_PAGES)\n\n \nstatic inline void set_tlb_bus(struct snd_trident *trident, int page,\n\t\t\t       dma_addr_t addr)\n{\n\tint i;\n\tpage *= UNIT_PAGES;\n\tfor (i = 0; i < UNIT_PAGES; i++, page++) {\n\t\t__set_tlb_bus(trident, page, addr);\n\t\taddr += SNDRV_TRIDENT_PAGE_SIZE;\n\t}\n}\nstatic inline void set_silent_tlb(struct snd_trident *trident, int page)\n{\n\tint i;\n\tpage *= UNIT_PAGES;\n\tfor (i = 0; i < UNIT_PAGES; i++, page++)\n\t\t__set_tlb_bus(trident, page, trident->tlb.silent_page->addr);\n}\n\n#endif  \n\n \n#define firstpg(blk)\t(((struct snd_trident_memblk_arg *)snd_util_memblk_argptr(blk))->first_page)\n#define lastpg(blk)\t(((struct snd_trident_memblk_arg *)snd_util_memblk_argptr(blk))->last_page)\n\n \nstatic struct snd_util_memblk *\nsearch_empty(struct snd_util_memhdr *hdr, int size)\n{\n\tstruct snd_util_memblk *blk;\n\tint page, psize;\n\tstruct list_head *p;\n\n\tpsize = get_aligned_page(size + ALIGN_PAGE_SIZE -1);\n\tpage = 0;\n\tlist_for_each(p, &hdr->block) {\n\t\tblk = list_entry(p, struct snd_util_memblk, list);\n\t\tif (page + psize <= firstpg(blk))\n\t\t\tgoto __found_pages;\n\t\tpage = lastpg(blk) + 1;\n\t}\n\tif (page + psize > MAX_ALIGN_PAGES)\n\t\treturn NULL;\n\n__found_pages:\n\t \n\tblk = __snd_util_memblk_new(hdr, psize * ALIGN_PAGE_SIZE, p->prev);\n\tif (blk == NULL)\n\t\treturn NULL;\n\tblk->offset = aligned_page_offset(page);  \n\tfirstpg(blk) = page;\n\tlastpg(blk) = page + psize - 1;\n\treturn blk;\n}\n\n\n \nstatic int is_valid_page(unsigned long ptr)\n{\n\tif (ptr & ~0x3fffffffUL) {\n\t\tsnd_printk(KERN_ERR \"max memory size is 1GB!!\\n\");\n\t\treturn 0;\n\t}\n\tif (ptr & (SNDRV_TRIDENT_PAGE_SIZE-1)) {\n\t\tsnd_printk(KERN_ERR \"page is not aligned\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic struct snd_util_memblk *\nsnd_trident_alloc_sg_pages(struct snd_trident *trident,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_util_memhdr *hdr;\n\tstruct snd_util_memblk *blk;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint idx, page;\n\n\tif (snd_BUG_ON(runtime->dma_bytes <= 0 ||\n\t\t       runtime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *\n\t\t\t\t\tSNDRV_TRIDENT_PAGE_SIZE))\n\t\treturn NULL;\n\thdr = trident->tlb.memhdr;\n\tif (snd_BUG_ON(!hdr))\n\t\treturn NULL;\n\n\t\n\n\tmutex_lock(&hdr->block_mutex);\n\tblk = search_empty(hdr, runtime->dma_bytes);\n\tif (blk == NULL) {\n\t\tmutex_unlock(&hdr->block_mutex);\n\t\treturn NULL;\n\t}\n\t\t\t   \n\t \n\tidx = 0;\n\tfor (page = firstpg(blk); page <= lastpg(blk); page++, idx++) {\n\t\tunsigned long ofs = idx << PAGE_SHIFT;\n\t\tdma_addr_t addr = snd_pcm_sgbuf_get_addr(substream, ofs);\n\t\tif (! is_valid_page(addr)) {\n\t\t\t__snd_util_mem_free(hdr, blk);\n\t\t\tmutex_unlock(&hdr->block_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t\tset_tlb_bus(trident, page, addr);\n\t}\n\tmutex_unlock(&hdr->block_mutex);\n\treturn blk;\n}\n\n \nstatic struct snd_util_memblk *\nsnd_trident_alloc_cont_pages(struct snd_trident *trident,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_util_memhdr *hdr;\n\tstruct snd_util_memblk *blk;\n\tint page;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tdma_addr_t addr;\n\n\tif (snd_BUG_ON(runtime->dma_bytes <= 0 ||\n\t\t       runtime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *\n\t\t\t\t\tSNDRV_TRIDENT_PAGE_SIZE))\n\t\treturn NULL;\n\thdr = trident->tlb.memhdr;\n\tif (snd_BUG_ON(!hdr))\n\t\treturn NULL;\n\n\tmutex_lock(&hdr->block_mutex);\n\tblk = search_empty(hdr, runtime->dma_bytes);\n\tif (blk == NULL) {\n\t\tmutex_unlock(&hdr->block_mutex);\n\t\treturn NULL;\n\t}\n\t\t\t   \n\t \n\taddr = runtime->dma_addr;\n\tfor (page = firstpg(blk); page <= lastpg(blk); page++,\n\t     addr += SNDRV_TRIDENT_PAGE_SIZE) {\n\t\tif (! is_valid_page(addr)) {\n\t\t\t__snd_util_mem_free(hdr, blk);\n\t\t\tmutex_unlock(&hdr->block_mutex);\n\t\t\treturn NULL;\n\t\t}\n\t\tset_tlb_bus(trident, page, addr);\n\t}\n\tmutex_unlock(&hdr->block_mutex);\n\treturn blk;\n}\n\n \nstruct snd_util_memblk *\nsnd_trident_alloc_pages(struct snd_trident *trident,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tif (snd_BUG_ON(!trident || !substream))\n\t\treturn NULL;\n\tif (substream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV_SG)\n\t\treturn snd_trident_alloc_sg_pages(trident, substream);\n\telse\n\t\treturn snd_trident_alloc_cont_pages(trident, substream);\n}\n\n\n \nint snd_trident_free_pages(struct snd_trident *trident,\n\t\t\t   struct snd_util_memblk *blk)\n{\n\tstruct snd_util_memhdr *hdr;\n\tint page;\n\n\tif (snd_BUG_ON(!trident || !blk))\n\t\treturn -EINVAL;\n\n\thdr = trident->tlb.memhdr;\n\tmutex_lock(&hdr->block_mutex);\n\t \n\tfor (page = firstpg(blk); page <= lastpg(blk); page++)\n\t\tset_silent_tlb(trident, page);\n\t \n\t__snd_util_mem_free(hdr, blk);\n\tmutex_unlock(&hdr->block_mutex);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}