{
  "module_name": "trident_main.c",
  "hash_id": "e184f440e7ba757d6749914a9c91cc977c51224422e0dfbb5556746e4f9ea95e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/trident/trident_main.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/gameport.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"trident.h\"\n#include <sound/asoundef.h>\n\nstatic int snd_trident_pcm_mixer_build(struct snd_trident *trident,\n\t\t\t\t       struct snd_trident_voice * voice,\n\t\t\t\t       struct snd_pcm_substream *substream);\nstatic int snd_trident_pcm_mixer_free(struct snd_trident *trident,\n\t\t\t\t      struct snd_trident_voice * voice,\n\t\t\t\t      struct snd_pcm_substream *substream);\nstatic irqreturn_t snd_trident_interrupt(int irq, void *dev_id);\nstatic int snd_trident_sis_reset(struct snd_trident *trident);\n\nstatic void snd_trident_clear_voices(struct snd_trident * trident,\n\t\t\t\t     unsigned short v_min, unsigned short v_max);\nstatic void snd_trident_free(struct snd_card *card);\n\n \n\n\n#if 0\nstatic void snd_trident_print_voice_regs(struct snd_trident *trident, int voice)\n{\n\tunsigned int val, tmp;\n\n\tdev_dbg(trident->card->dev, \"Trident voice %i:\\n\", voice);\n\toutb(voice, TRID_REG(trident, T4D_LFO_GC_CIR));\n\tval = inl(TRID_REG(trident, CH_LBA));\n\tdev_dbg(trident->card->dev, \"LBA: 0x%x\\n\", val);\n\tval = inl(TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));\n\tdev_dbg(trident->card->dev, \"GVSel: %i\\n\", val >> 31);\n\tdev_dbg(trident->card->dev, \"Pan: 0x%x\\n\", (val >> 24) & 0x7f);\n\tdev_dbg(trident->card->dev, \"Vol: 0x%x\\n\", (val >> 16) & 0xff);\n\tdev_dbg(trident->card->dev, \"CTRL: 0x%x\\n\", (val >> 12) & 0x0f);\n\tdev_dbg(trident->card->dev, \"EC: 0x%x\\n\", val & 0x0fff);\n\tif (trident->device != TRIDENT_DEVICE_ID_NX) {\n\t\tval = inl(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS));\n\t\tdev_dbg(trident->card->dev, \"CSO: 0x%x\\n\", val >> 16);\n\t\tdev_dbg(trident->card->dev, \"Alpha: 0x%x\\n\", (val >> 4) & 0x0fff);\n\t\tdev_dbg(trident->card->dev, \"FMS: 0x%x\\n\", val & 0x0f);\n\t\tval = inl(TRID_REG(trident, CH_DX_ESO_DELTA));\n\t\tdev_dbg(trident->card->dev, \"ESO: 0x%x\\n\", val >> 16);\n\t\tdev_dbg(trident->card->dev, \"Delta: 0x%x\\n\", val & 0xffff);\n\t\tval = inl(TRID_REG(trident, CH_DX_FMC_RVOL_CVOL));\n\t} else {\t\t\n\t\tval = inl(TRID_REG(trident, CH_NX_DELTA_CSO));\n\t\ttmp = (val >> 24) & 0xff;\n\t\tdev_dbg(trident->card->dev, \"CSO: 0x%x\\n\", val & 0x00ffffff);\n\t\tval = inl(TRID_REG(trident, CH_NX_DELTA_ESO));\n\t\ttmp |= (val >> 16) & 0xff00;\n\t\tdev_dbg(trident->card->dev, \"Delta: 0x%x\\n\", tmp);\n\t\tdev_dbg(trident->card->dev, \"ESO: 0x%x\\n\", val & 0x00ffffff);\n\t\tval = inl(TRID_REG(trident, CH_NX_ALPHA_FMS_FMC_RVOL_CVOL));\n\t\tdev_dbg(trident->card->dev, \"Alpha: 0x%x\\n\", val >> 20);\n\t\tdev_dbg(trident->card->dev, \"FMS: 0x%x\\n\", (val >> 16) & 0x0f);\n\t}\n\tdev_dbg(trident->card->dev, \"FMC: 0x%x\\n\", (val >> 14) & 3);\n\tdev_dbg(trident->card->dev, \"RVol: 0x%x\\n\", (val >> 7) & 0x7f);\n\tdev_dbg(trident->card->dev, \"CVol: 0x%x\\n\", val & 0x7f);\n}\n#endif\n\n \nstatic unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tunsigned int data = 0, treg;\n\tunsigned short count = 0xffff;\n\tunsigned long flags;\n\tstruct snd_trident *trident = ac97->private_data;\n\n\tspin_lock_irqsave(&trident->reg_lock, flags);\n\tif (trident->device == TRIDENT_DEVICE_ID_DX) {\n\t\tdata = (DX_AC97_BUSY_READ | (reg & 0x000000ff));\n\t\toutl(data, TRID_REG(trident, DX_ACR1_AC97_R));\n\t\tdo {\n\t\t\tdata = inl(TRID_REG(trident, DX_ACR1_AC97_R));\n\t\t\tif ((data & DX_AC97_BUSY_READ) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\t} else if (trident->device == TRIDENT_DEVICE_ID_NX) {\n\t\tdata = (NX_AC97_BUSY_READ | (reg & 0x000000ff));\n\t\ttreg = ac97->num == 0 ? NX_ACR2_AC97_R_PRIMARY : NX_ACR3_AC97_R_SECONDARY;\n\t\toutl(data, TRID_REG(trident, treg));\n\t\tdo {\n\t\t\tdata = inl(TRID_REG(trident, treg));\n\t\t\tif ((data & 0x00000C00) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\t} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\tdata = SI_AC97_BUSY_READ | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);\n\t\tif (ac97->num == 1)\n\t\t\tdata |= SI_AC97_SECONDARY;\n\t\toutl(data, TRID_REG(trident, SI_AC97_READ));\n\t\tdo {\n\t\t\tdata = inl(TRID_REG(trident, SI_AC97_READ));\n\t\t\tif ((data & (SI_AC97_BUSY_READ)) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\t}\n\n\tif (count == 0 && !trident->ac97_detect) {\n\t\tdev_err(trident->card->dev,\n\t\t\t\"ac97 codec read TIMEOUT [0x%x/0x%x]!!!\\n\",\n\t\t\t   reg, data);\n\t\tdata = 0;\n\t}\n\n\tspin_unlock_irqrestore(&trident->reg_lock, flags);\n\treturn ((unsigned short) (data >> 16));\n}\n\n \nstatic void snd_trident_codec_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\t    unsigned short wdata)\n{\n\tunsigned int address, data;\n\tunsigned short count = 0xffff;\n\tunsigned long flags;\n\tstruct snd_trident *trident = ac97->private_data;\n\n\tdata = ((unsigned long) wdata) << 16;\n\n\tspin_lock_irqsave(&trident->reg_lock, flags);\n\tif (trident->device == TRIDENT_DEVICE_ID_DX) {\n\t\taddress = DX_ACR0_AC97_W;\n\n\t\t \n\t\tdo {\n\t\t\tif ((inw(TRID_REG(trident, address)) & DX_AC97_BUSY_WRITE) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\n\t\tdata |= (DX_AC97_BUSY_WRITE | (reg & 0x000000ff));\n\t} else if (trident->device == TRIDENT_DEVICE_ID_NX) {\n\t\taddress = NX_ACR1_AC97_W;\n\n\t\t \n\t\tdo {\n\t\t\tif ((inw(TRID_REG(trident, address)) & NX_AC97_BUSY_WRITE) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\n\t\tdata |= (NX_AC97_BUSY_WRITE | (ac97->num << 8) | (reg & 0x000000ff));\n\t} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\taddress = SI_AC97_WRITE;\n\n\t\t \n\t\tdo {\n\t\t\tif ((inw(TRID_REG(trident, address)) & (SI_AC97_BUSY_WRITE)) == 0)\n\t\t\t\tbreak;\n\t\t} while (--count);\n\n\t\tdata |= SI_AC97_BUSY_WRITE | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);\n\t\tif (ac97->num == 1)\n\t\t\tdata |= SI_AC97_SECONDARY;\n\t} else {\n\t\taddress = 0;\t \n\t\tcount = 0;\t \n\t}\n\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&trident->reg_lock, flags);\n\t\treturn;\n\t}\n\toutl(data, TRID_REG(trident, address));\n\tspin_unlock_irqrestore(&trident->reg_lock, flags);\n}\n\n \n\nstatic void snd_trident_enable_eso(struct snd_trident * trident)\n{\n\tunsigned int val;\n\n\tval = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\n\tval |= ENDLP_IE;\n\tval |= MIDLP_IE;\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018)\n\t\tval |= BANK_B_EN;\n\toutl(val, TRID_REG(trident, T4D_LFO_GC_CIR));\n}\n\n \n\nstatic void snd_trident_disable_eso(struct snd_trident * trident)\n{\n\tunsigned int tmp;\n\n\ttmp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\n\ttmp &= ~ENDLP_IE;\n\ttmp &= ~MIDLP_IE;\n\toutl(tmp, TRID_REG(trident, T4D_LFO_GC_CIR));\n}\n\n \n\nvoid snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)\n{\n\tunsigned int mask = 1 << (voice & 0x1f);\n\tunsigned int reg = (voice & 0x20) ? T4D_START_B : T4D_START_A;\n\n\toutl(mask, TRID_REG(trident, reg));\n}\n\nEXPORT_SYMBOL(snd_trident_start_voice);\n\n \n\nvoid snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)\n{\n\tunsigned int mask = 1 << (voice & 0x1f);\n\tunsigned int reg = (voice & 0x20) ? T4D_STOP_B : T4D_STOP_A;\n\n\toutl(mask, TRID_REG(trident, reg));\n}\n\nEXPORT_SYMBOL(snd_trident_stop_voice);\n\n \n\nstatic int snd_trident_allocate_pcm_channel(struct snd_trident * trident)\n{\n\tint idx;\n\n\tif (trident->ChanPCMcnt >= trident->ChanPCM)\n\t\treturn -1;\n\tfor (idx = 31; idx >= 0; idx--) {\n\t\tif (!(trident->ChanMap[T4D_BANK_B] & (1 << idx))) {\n\t\t\ttrident->ChanMap[T4D_BANK_B] |= 1 << idx;\n\t\t\ttrident->ChanPCMcnt++;\n\t\t\treturn idx + 32;\n\t\t}\n\t}\n\treturn -1;\n}\n\n \n\nstatic void snd_trident_free_pcm_channel(struct snd_trident *trident, int channel)\n{\n\tif (channel < 32 || channel > 63)\n\t\treturn;\n\tchannel &= 0x1f;\n\tif (trident->ChanMap[T4D_BANK_B] & (1 << channel)) {\n\t\ttrident->ChanMap[T4D_BANK_B] &= ~(1 << channel);\n\t\ttrident->ChanPCMcnt--;\n\t}\n}\n\n \n\nstatic int snd_trident_allocate_synth_channel(struct snd_trident * trident)\n{\n\tint idx;\n\n\tfor (idx = 31; idx >= 0; idx--) {\n\t\tif (!(trident->ChanMap[T4D_BANK_A] & (1 << idx))) {\n\t\t\ttrident->ChanMap[T4D_BANK_A] |= 1 << idx;\n\t\t\ttrident->synth.ChanSynthCount++;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}\n\n \n\nstatic void snd_trident_free_synth_channel(struct snd_trident *trident, int channel)\n{\n\tif (channel < 0 || channel > 31)\n\t\treturn;\n\tchannel &= 0x1f;\n\tif (trident->ChanMap[T4D_BANK_A] & (1 << channel)) {\n\t\ttrident->ChanMap[T4D_BANK_A] &= ~(1 << channel);\n\t\ttrident->synth.ChanSynthCount--;\n\t}\n}\n\n \n\nvoid snd_trident_write_voice_regs(struct snd_trident * trident,\n\t\t\t\t  struct snd_trident_voice * voice)\n{\n\tunsigned int FmcRvolCvol;\n\tunsigned int regs[5];\n\n\tregs[1] = voice->LBA;\n\tregs[4] = (voice->GVSel << 31) |\n\t\t  ((voice->Pan & 0x0000007f) << 24) |\n\t\t  ((voice->CTRL & 0x0000000f) << 12);\n\tFmcRvolCvol = ((voice->FMC & 3) << 14) |\n\t              ((voice->RVol & 0x7f) << 7) |\n\t              (voice->CVol & 0x7f);\n\n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\tregs[4] |= voice->number > 31 ?\n\t\t\t\t(voice->Vol & 0x000003ff) :\n\t\t\t\t((voice->Vol & 0x00003fc) << (16-2)) |\n\t\t\t\t(voice->EC & 0x00000fff);\n\t\tregs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |\n\t\t\t(voice->FMS & 0x0000000f);\n\t\tregs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);\n\t\tregs[3] = (voice->Attribute << 16) | FmcRvolCvol;\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_DX:\n\t\tregs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |\n\t\t\t   (voice->EC & 0x00000fff);\n\t\tregs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |\n\t\t\t(voice->FMS & 0x0000000f);\n\t\tregs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);\n\t\tregs[3] = FmcRvolCvol;\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\tregs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |\n\t\t\t   (voice->EC & 0x00000fff);\n\t\tregs[0] = (voice->Delta << 24) | (voice->CSO & 0x00ffffff);\n\t\tregs[2] = ((voice->Delta << 16) & 0xff000000) |\n\t\t\t(voice->ESO & 0x00ffffff);\n\t\tregs[3] = (voice->Alpha << 20) |\n\t\t\t((voice->FMS & 0x0000000f) << 16) | FmcRvolCvol;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn;\n\t}\n\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\toutl(regs[0], TRID_REG(trident, CH_START + 0));\n\toutl(regs[1], TRID_REG(trident, CH_START + 4));\n\toutl(regs[2], TRID_REG(trident, CH_START + 8));\n\toutl(regs[3], TRID_REG(trident, CH_START + 12));\n\toutl(regs[4], TRID_REG(trident, CH_START + 16));\n\n#if 0\n\tdev_dbg(trident->card->dev, \"written %i channel:\\n\", voice->number);\n\tdev_dbg(trident->card->dev, \"  regs[0] = 0x%x/0x%x\\n\",\n\t       regs[0], inl(TRID_REG(trident, CH_START + 0)));\n\tdev_dbg(trident->card->dev, \"  regs[1] = 0x%x/0x%x\\n\",\n\t       regs[1], inl(TRID_REG(trident, CH_START + 4)));\n\tdev_dbg(trident->card->dev, \"  regs[2] = 0x%x/0x%x\\n\",\n\t       regs[2], inl(TRID_REG(trident, CH_START + 8)));\n\tdev_dbg(trident->card->dev, \"  regs[3] = 0x%x/0x%x\\n\",\n\t       regs[3], inl(TRID_REG(trident, CH_START + 12)));\n\tdev_dbg(trident->card->dev, \"  regs[4] = 0x%x/0x%x\\n\",\n\t       regs[4], inl(TRID_REG(trident, CH_START + 16)));\n#endif\n}\n\nEXPORT_SYMBOL(snd_trident_write_voice_regs);\n\n \n\nstatic void snd_trident_write_cso_reg(struct snd_trident * trident,\n\t\t\t\t      struct snd_trident_voice * voice,\n\t\t\t\t      unsigned int CSO)\n{\n\tvoice->CSO = CSO;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\tif (trident->device != TRIDENT_DEVICE_ID_NX) {\n\t\toutw(voice->CSO, TRID_REG(trident, CH_DX_CSO_ALPHA_FMS) + 2);\n\t} else {\n\t\toutl((voice->Delta << 24) |\n\t\t     (voice->CSO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_CSO));\n\t}\n}\n\n \n\nstatic void snd_trident_write_eso_reg(struct snd_trident * trident,\n\t\t\t\t      struct snd_trident_voice * voice,\n\t\t\t\t      unsigned int ESO)\n{\n\tvoice->ESO = ESO;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\tif (trident->device != TRIDENT_DEVICE_ID_NX) {\n\t\toutw(voice->ESO, TRID_REG(trident, CH_DX_ESO_DELTA) + 2);\n\t} else {\n\t\toutl(((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff),\n\t\t     TRID_REG(trident, CH_NX_DELTA_ESO));\n\t}\n}\n\n \n\nstatic void snd_trident_write_vol_reg(struct snd_trident * trident,\n\t\t\t\t      struct snd_trident_voice * voice,\n\t\t\t\t      unsigned int Vol)\n{\n\tvoice->Vol = Vol;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_DX:\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\toutb(voice->Vol >> 2, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 2));\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\t \n\t\toutw((voice->CTRL << 12) | voice->Vol,\n\t\t     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void snd_trident_write_pan_reg(struct snd_trident * trident,\n\t\t\t\t      struct snd_trident_voice * voice,\n\t\t\t\t      unsigned int Pan)\n{\n\tvoice->Pan = Pan;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\toutb(((voice->GVSel & 0x01) << 7) | (voice->Pan & 0x7f),\n\t     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 3));\n}\n\n \n\nstatic void snd_trident_write_rvol_reg(struct snd_trident * trident,\n\t\t\t\t       struct snd_trident_voice * voice,\n\t\t\t\t       unsigned int RVol)\n{\n\tvoice->RVol = RVol;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\toutw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |\n\t     (voice->CVol & 0x007f),\n\t     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?\n\t\t      CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));\n}\n\n \n\nstatic void snd_trident_write_cvol_reg(struct snd_trident * trident,\n\t\t\t\t       struct snd_trident_voice * voice,\n\t\t\t\t       unsigned int CVol)\n{\n\tvoice->CVol = CVol;\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\toutw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |\n\t     (voice->CVol & 0x007f),\n\t     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?\n\t\t      CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));\n}\n\n \nstatic unsigned int snd_trident_convert_rate(unsigned int rate)\n{\n\tunsigned int delta;\n\n\t\n\t\n\t\n\t\n\tif (rate == 44100)\n\t\tdelta = 0xeb3;\n\telse if (rate == 8000)\n\t\tdelta = 0x2ab;\n\telse if (rate == 48000)\n\t\tdelta = 0x1000;\n\telse\n\t\tdelta = DIV_ROUND_CLOSEST(rate << 12, 48000) & 0x0000ffff;\n\treturn delta;\n}\n\n \nstatic unsigned int snd_trident_convert_adc_rate(unsigned int rate)\n{\n\tunsigned int delta;\n\n\t\n\t\n\t\n\t\n\tif (rate == 44100)\n\t\tdelta = 0x116a;\n\telse if (rate == 8000)\n\t\tdelta = 0x6000;\n\telse if (rate == 48000)\n\t\tdelta = 0x1000;\n\telse\n\t\tdelta = ((48000 << 12) / rate) & 0x0000ffff;\n\treturn delta;\n}\n\n \nstatic unsigned int snd_trident_spurious_threshold(unsigned int rate,\n\t\t\t\t\t\t   unsigned int period_size)\n{\n\tunsigned int res = (rate * period_size) / 48000;\n\tif (res < 64)\n\t\tres = res / 2;\n\telse\n\t\tres -= 32;\n\treturn res;\n}\n\n \nstatic unsigned int snd_trident_control_mode(struct snd_pcm_substream *substream)\n{\n\tunsigned int CTRL;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t \n\tCTRL = 0x00000001;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tCTRL |= 0x00000008;\t\n\tif (snd_pcm_format_signed(runtime->format))\n\t\tCTRL |= 0x00000002;\t\n\tif (runtime->channels > 1)\n\t\tCTRL |= 0x00000004;\t\n\treturn CTRL;\n}\n\n \n\n \n\nstatic int snd_trident_allocate_pcm_mem(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\n\tif (trident->tlb.entries) {\n\t\tif (runtime->buffer_changed) {\n\t\t\tif (voice->memblk)\n\t\t\t\tsnd_trident_free_pages(trident, voice->memblk);\n\t\t\tvoice->memblk = snd_trident_alloc_pages(trident, substream);\n\t\t\tif (voice->memblk == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_allocate_evoice(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice->extra;\n\n\t \n\n\tif (params_buffer_size(hw_params) / 2 != params_period_size(hw_params)) {\n\t\tif (evoice == NULL) {\n\t\t\tevoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\n\t\t\tif (evoice == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tvoice->extra = evoice;\n\t\t\tevoice->substream = substream;\n\t\t}\n\t} else {\n\t\tif (evoice != NULL) {\n\t\t\tsnd_trident_free_voice(trident, evoice);\n\t\t\tvoice->extra = evoice = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tint err;\n\n\terr = snd_trident_allocate_pcm_mem(substream, hw_params);\n\tif (err >= 0)\n\t\terr = snd_trident_allocate_evoice(substream, hw_params);\n\treturn err;\n}\n\n \n\nstatic int snd_trident_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice ? voice->extra : NULL;\n\n\tif (trident->tlb.entries) {\n\t\tif (voice && voice->memblk) {\n\t\t\tsnd_trident_free_pages(trident, voice->memblk);\n\t\t\tvoice->memblk = NULL;\n\t\t}\n\t}\n\tif (evoice != NULL) {\n\t\tsnd_trident_free_voice(trident, evoice);\n\t\tvoice->extra = NULL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice->extra;\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];\n\n\tspin_lock_irq(&trident->reg_lock);\t\n\n\t \n\tvoice->Delta = snd_trident_convert_rate(runtime->rate);\n\tvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\n\n\t \n\tif (voice->memblk)\n\t\tvoice->LBA = voice->memblk->offset;\n\telse\n\t\tvoice->LBA = runtime->dma_addr;\n \n\tvoice->CSO = 0;\n\tvoice->ESO = runtime->buffer_size - 1;\t \n\tvoice->CTRL = snd_trident_control_mode(substream);\n\tvoice->FMC = 3;\n\tvoice->GVSel = 1;\n\tvoice->EC = 0;\n\tvoice->Alpha = 0;\n\tvoice->FMS = 0;\n\tvoice->Vol = mix->vol;\n\tvoice->RVol = mix->rvol;\n\tvoice->CVol = mix->cvol;\n\tvoice->Pan = mix->pan;\n\tvoice->Attribute = 0;\n#if 0\n\tvoice->Attribute = (1<<(30-16))|(2<<(26-16))|\n\t\t\t   (0<<(24-16))|(0x1f<<(19-16));\n#else\n\tvoice->Attribute = 0;\n#endif\n\n\tsnd_trident_write_voice_regs(trident, voice);\n\n\tif (evoice != NULL) {\n\t\tevoice->Delta = voice->Delta;\n\t\tevoice->spurious_threshold = voice->spurious_threshold;\n\t\tevoice->LBA = voice->LBA;\n\t\tevoice->CSO = 0;\n\t\tevoice->ESO = (runtime->period_size * 2) + 4 - 1;  \n\t\tevoice->CTRL = voice->CTRL;\n\t\tevoice->FMC = 3;\n\t\tevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\n\t\tevoice->EC = 0;\n\t\tevoice->Alpha = 0;\n\t\tevoice->FMS = 0;\n\t\tevoice->Vol = 0x3ff;\t\t\t \n\t\tevoice->RVol = evoice->CVol = 0x7f;\t \n\t\tevoice->Pan = 0x7f;\t\t\t \n#if 0\n\t\tevoice->Attribute = (1<<(30-16))|(2<<(26-16))|\n\t\t\t\t    (0<<(24-16))|(0x1f<<(19-16));\n#else\n\t\tevoice->Attribute = 0;\n#endif\n\t\tsnd_trident_write_voice_regs(trident, evoice);\n\t\tevoice->isync2 = 1;\n\t\tevoice->isync_mark = runtime->period_size;\n\t\tevoice->ESO = (runtime->period_size * 2) - 1;\n\t}\n\n\tspin_unlock_irq(&trident->reg_lock);\n\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\treturn snd_trident_allocate_pcm_mem(substream, hw_params);\n}\n\n \n\nstatic int snd_trident_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tunsigned int val, ESO_bytes;\n\n\tspin_lock_irq(&trident->reg_lock);\n\n\t\n\toutb(0, TRID_REG(trident, LEGACY_DMAR15));\n\n\t\n\toutb(0x54, TRID_REG(trident, LEGACY_DMAR11));\n\n\t\n\tvoice->LBA = runtime->dma_addr;\n\toutl(voice->LBA, TRID_REG(trident, LEGACY_DMAR0));\n\tif (voice->memblk)\n\t\tvoice->LBA = voice->memblk->offset;\n\n\t\n\tESO_bytes = snd_pcm_lib_buffer_bytes(substream) - 1;\n\toutb((ESO_bytes & 0x00ff0000) >> 16, TRID_REG(trident, LEGACY_DMAR6));\n\toutw((ESO_bytes & 0x0000ffff), TRID_REG(trident, LEGACY_DMAR4));\n\tESO_bytes++;\n\n\t\n\tval = DIV_ROUND_CLOSEST(48000U << 12, runtime->rate);\n\toutw(val, TRID_REG(trident, T4D_SBDELTA_DELTA_R));\n\n\t\n\tif (snd_pcm_format_width(runtime->format) == 16) {\n\t\tval = (unsigned short) ((ESO_bytes >> 1) - 1);\n\t} else {\n\t\tval = (unsigned short) (ESO_bytes - 1);\n\t}\n\n\toutl((val << 16) | val, TRID_REG(trident, T4D_SBBL_SBCL));\n\n\t\n\t\n\ttrident->bDMAStart = 0x19;\t\n\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\ttrident->bDMAStart |= 0x80;\n\tif (snd_pcm_format_signed(runtime->format))\n\t\ttrident->bDMAStart |= 0x20;\n\tif (runtime->channels > 1)\n\t\ttrident->bDMAStart |= 0x40;\n\n\t\n\n\tvoice->Delta = snd_trident_convert_rate(runtime->rate);\n\tvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\n\tvoice->isync = 1;\n\tvoice->isync_mark = runtime->period_size;\n\tvoice->isync_max = runtime->buffer_size;\n\n\t\n\tvoice->CSO = 0;\n\tvoice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;\n\tvoice->CTRL = snd_trident_control_mode(substream);\n\tvoice->FMC = 3;\n\tvoice->RVol = 0x7f;\n\tvoice->CVol = 0x7f;\n\tvoice->GVSel = 1;\n\tvoice->Pan = 0x7f;\t\t \n\tvoice->Vol = 0x3ff;\t\t \n\tvoice->EC = 0;\n\tvoice->Alpha = 0;\n\tvoice->FMS = 0;\n\tvoice->Attribute = 0;\n\n\tsnd_trident_write_voice_regs(trident, voice);\n\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_si7018_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\treturn snd_trident_allocate_evoice(substream, hw_params);\n}\n\n \n\nstatic int snd_trident_si7018_capture_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice ? voice->extra : NULL;\n\n\tif (evoice != NULL) {\n\t\tsnd_trident_free_voice(trident, evoice);\n\t\tvoice->extra = NULL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_si7018_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice->extra;\n\n\tspin_lock_irq(&trident->reg_lock);\n\n\tvoice->LBA = runtime->dma_addr;\n\tvoice->Delta = snd_trident_convert_adc_rate(runtime->rate);\n\tvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\n\n\t\n\tvoice->CSO = 0;\n\tvoice->ESO = runtime->buffer_size - 1;\t\t \n\tvoice->CTRL = snd_trident_control_mode(substream);\n\tvoice->FMC = 0;\n\tvoice->RVol = 0;\n\tvoice->CVol = 0;\n\tvoice->GVSel = 1;\n\tvoice->Pan = T4D_DEFAULT_PCM_PAN;\n\tvoice->Vol = 0;\n\tvoice->EC = 0;\n\tvoice->Alpha = 0;\n\tvoice->FMS = 0;\n\n\tvoice->Attribute = (2 << (30-16)) |\n\t\t\t   (2 << (26-16)) |\n\t\t\t   (2 << (24-16)) |\n\t\t\t   (1 << (23-16));\n\n\tsnd_trident_write_voice_regs(trident, voice);\n\n\tif (evoice != NULL) {\n\t\tevoice->Delta = snd_trident_convert_rate(runtime->rate);\n\t\tevoice->spurious_threshold = voice->spurious_threshold;\n\t\tevoice->LBA = voice->LBA;\n\t\tevoice->CSO = 0;\n\t\tevoice->ESO = (runtime->period_size * 2) + 20 - 1;  \n\t\tevoice->CTRL = voice->CTRL;\n\t\tevoice->FMC = 3;\n\t\tevoice->GVSel = 0;\n\t\tevoice->EC = 0;\n\t\tevoice->Alpha = 0;\n\t\tevoice->FMS = 0;\n\t\tevoice->Vol = 0x3ff;\t\t\t \n\t\tevoice->RVol = evoice->CVol = 0x7f;\t \n\t\tevoice->Pan = 0x7f;\t\t\t \n\t\tevoice->Attribute = 0;\n\t\tsnd_trident_write_voice_regs(trident, evoice);\n\t\tevoice->isync2 = 1;\n\t\tevoice->isync_mark = runtime->period_size;\n\t\tevoice->ESO = (runtime->period_size * 2) - 1;\n\t}\n\t\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_foldback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice->extra;\n\n\tspin_lock_irq(&trident->reg_lock);\n\n\t \n\tif (voice->memblk)\n\t\tvoice->LBA = voice->memblk->offset;\n\telse\n\t\tvoice->LBA = runtime->dma_addr;\n\n\t \n\tvoice->ESO = runtime->buffer_size - 1;\t \n\n\t \n\tvoice->Delta = 0x1000;\n\tvoice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);\n\n\tvoice->CSO = 0;\n\tvoice->CTRL = snd_trident_control_mode(substream);\n\tvoice->FMC = 3;\n\tvoice->RVol = 0x7f;\n\tvoice->CVol = 0x7f;\n\tvoice->GVSel = 1;\n\tvoice->Pan = 0x7f;\t \n\tvoice->Vol = 0x3ff;\t \n\tvoice->EC = 0;\n\tvoice->Alpha = 0;\n\tvoice->FMS = 0;\n\tvoice->Attribute = 0;\n\n\t \n\toutb(((voice->number & 0x3f) | 0x80), TRID_REG(trident, T4D_RCI + voice->foldback_chan));\n\n\tsnd_trident_write_voice_regs(trident, voice);\n\n\tif (evoice != NULL) {\n\t\tevoice->Delta = voice->Delta;\n\t\tevoice->spurious_threshold = voice->spurious_threshold;\n\t\tevoice->LBA = voice->LBA;\n\t\tevoice->CSO = 0;\n\t\tevoice->ESO = (runtime->period_size * 2) + 4 - 1;  \n\t\tevoice->CTRL = voice->CTRL;\n\t\tevoice->FMC = 3;\n\t\tevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\n\t\tevoice->EC = 0;\n\t\tevoice->Alpha = 0;\n\t\tevoice->FMS = 0;\n\t\tevoice->Vol = 0x3ff;\t\t\t \n\t\tevoice->RVol = evoice->CVol = 0x7f;\t \n\t\tevoice->Pan = 0x7f;\t\t\t \n\t\tevoice->Attribute = 0;\n\t\tsnd_trident_write_voice_regs(trident, evoice);\n\t\tevoice->isync2 = 1;\n\t\tevoice->isync_mark = runtime->period_size;\n\t\tevoice->ESO = (runtime->period_size * 2) - 1;\n\t}\n\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tunsigned int old_bits = 0, change = 0;\n\tint err;\n\n\terr = snd_trident_allocate_pcm_mem(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\terr = snd_trident_allocate_evoice(substream, hw_params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tspin_lock_irq(&trident->reg_lock);\n\told_bits = trident->spdif_pcm_bits;\n\tif (old_bits & IEC958_AES0_PROFESSIONAL)\n\t\ttrident->spdif_pcm_bits &= ~IEC958_AES0_PRO_FS;\n\telse\n\t\ttrident->spdif_pcm_bits &= ~(IEC958_AES3_CON_FS << 24);\n\tif (params_rate(hw_params) >= 48000) {\n\t\ttrident->spdif_pcm_ctrl = 0x3c;\t\n\t\ttrident->spdif_pcm_bits |=\n\t\t\ttrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\n\t\t\t\tIEC958_AES0_PRO_FS_48000 :\n\t\t\t\t(IEC958_AES3_CON_FS_48000 << 24);\n\t}\n\telse if (params_rate(hw_params) >= 44100) {\n\t\ttrident->spdif_pcm_ctrl = 0x3e;\t\n\t\ttrident->spdif_pcm_bits |=\n\t\t\ttrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\n\t\t\t\tIEC958_AES0_PRO_FS_44100 :\n\t\t\t\t(IEC958_AES3_CON_FS_44100 << 24);\n\t}\n\telse {\n\t\ttrident->spdif_pcm_ctrl = 0x3d;\t\n\t\ttrident->spdif_pcm_bits |=\n\t\t\ttrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\n\t\t\t\tIEC958_AES0_PRO_FS_32000 :\n\t\t\t\t(IEC958_AES3_CON_FS_32000 << 24);\n\t}\n\tchange = old_bits != trident->spdif_pcm_bits;\n\tspin_unlock_irq(&trident->reg_lock);\n\n\tif (change)\n\t\tsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE, &trident->spdif_pcm_ctl->id);\n\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_spdif_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident_voice *evoice = voice->extra;\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];\n\tunsigned int RESO, LBAO;\n\tunsigned int temp;\n\n\tspin_lock_irq(&trident->reg_lock);\n\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\n\t\t \n\t\tvoice->Delta = snd_trident_convert_rate(runtime->rate);\n\t\tvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\n\n\t\t \n\t\tLBAO = runtime->dma_addr;\n\t\tif (voice->memblk)\n\t\t\tvoice->LBA = voice->memblk->offset;\n\t\telse\n\t\t\tvoice->LBA = LBAO;\n\n\t\tvoice->isync = 1;\n\t\tvoice->isync3 = 1;\n\t\tvoice->isync_mark = runtime->period_size;\n\t\tvoice->isync_max = runtime->buffer_size;\n\n\t\t \n\t\tRESO = runtime->buffer_size - 1;\n\t\tvoice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;\n\n\t\t \n\t\tvoice->CTRL = snd_trident_control_mode(substream);\n\n\t\tvoice->FMC = 3;\n\t\tvoice->RVol = 0x7f;\n\t\tvoice->CVol = 0x7f;\n\t\tvoice->GVSel = 1;\n\t\tvoice->Pan = 0x7f;\n\t\tvoice->Vol = 0x3ff;\n\t\tvoice->EC = 0;\n\t\tvoice->CSO = 0;\n\t\tvoice->Alpha = 0;\n\t\tvoice->FMS = 0;\n\t\tvoice->Attribute = 0;\n\n\t\t \n\t\tsnd_trident_write_voice_regs(trident, voice);\n\n\t\toutw((RESO & 0xffff), TRID_REG(trident, NX_SPESO));\n\t\toutb((RESO >> 16), TRID_REG(trident, NX_SPESO + 2));\n\t\toutl((LBAO & 0xfffffffc), TRID_REG(trident, NX_SPLBA));\n\t\toutw((voice->CSO & 0xffff), TRID_REG(trident, NX_SPCTRL_SPCSO));\n\t\toutb((voice->CSO >> 16), TRID_REG(trident, NX_SPCTRL_SPCSO + 2));\n\n\t\t \n\t\toutb(trident->spdif_pcm_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\t\toutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\n\n\t} else {\t \n\t\n\t\t \n\t\tvoice->Delta = 0x800;\n\t\tvoice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);\n\n\t\t \n\t\tif (voice->memblk)\n\t\t\tvoice->LBA = voice->memblk->offset;\n\t\telse\n\t\t\tvoice->LBA = runtime->dma_addr;\n\n\t\tvoice->CSO = 0;\n\t\tvoice->ESO = runtime->buffer_size - 1;\t \n\t\tvoice->CTRL = snd_trident_control_mode(substream);\n\t\tvoice->FMC = 3;\n\t\tvoice->GVSel = 1;\n\t\tvoice->EC = 0;\n\t\tvoice->Alpha = 0;\n\t\tvoice->FMS = 0;\n\t\tvoice->Vol = mix->vol;\n\t\tvoice->RVol = mix->rvol;\n\t\tvoice->CVol = mix->cvol;\n\t\tvoice->Pan = mix->pan;\n\t\tvoice->Attribute = (1<<(30-16))|(7<<(26-16))|\n\t\t\t\t   (0<<(24-16))|(0<<(19-16));\n\n\t\tsnd_trident_write_voice_regs(trident, voice);\n\n\t\tif (evoice != NULL) {\n\t\t\tevoice->Delta = voice->Delta;\n\t\t\tevoice->spurious_threshold = voice->spurious_threshold;\n\t\t\tevoice->LBA = voice->LBA;\n\t\t\tevoice->CSO = 0;\n\t\t\tevoice->ESO = (runtime->period_size * 2) + 4 - 1;  \n\t\t\tevoice->CTRL = voice->CTRL;\n\t\t\tevoice->FMC = 3;\n\t\t\tevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\n\t\t\tevoice->EC = 0;\n\t\t\tevoice->Alpha = 0;\n\t\t\tevoice->FMS = 0;\n\t\t\tevoice->Vol = 0x3ff;\t\t\t \n\t\t\tevoice->RVol = evoice->CVol = 0x7f;\t \n\t\t\tevoice->Pan = 0x7f;\t\t\t \n\t\t\tevoice->Attribute = 0;\n\t\t\tsnd_trident_write_voice_regs(trident, evoice);\n\t\t\tevoice->isync2 = 1;\n\t\t\tevoice->isync_mark = runtime->period_size;\n\t\t\tevoice->ESO = (runtime->period_size * 2) - 1;\n\t\t}\n\n\t\toutl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t\ttemp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\n\t\ttemp &= ~(1<<19);\n\t\toutl(temp, TRID_REG(trident, T4D_LFO_GC_CIR));\n\t\ttemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t\ttemp |= SPDIF_EN;\n\t\toutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t}\n\n\tspin_unlock_irq(&trident->reg_lock);\n\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd)\n\t\t\t\t    \n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tunsigned int what, whati, capture_flag, spdif_flag;\n\tstruct snd_trident_voice *voice, *evoice;\n\tunsigned int val, go;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tgo = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tgo = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twhat = whati = capture_flag = spdif_flag = 0;\n\tspin_lock(&trident->reg_lock);\n\tval = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif ((struct snd_trident *) snd_pcm_substream_chip(s) == trident) {\n\t\t\tvoice = s->runtime->private_data;\n\t\t\tevoice = voice->extra;\n\t\t\twhat |= 1 << (voice->number & 0x1f);\n\t\t\tif (evoice == NULL) {\n\t\t\t\twhati |= 1 << (voice->number & 0x1f);\n\t\t\t} else {\n\t\t\t\twhat |= 1 << (evoice->number & 0x1f);\n\t\t\t\twhati |= 1 << (evoice->number & 0x1f);\n\t\t\t\tif (go)\n\t\t\t\t\tevoice->stimer = val;\n\t\t\t}\n\t\t\tif (go) {\n\t\t\t\tvoice->running = 1;\n\t\t\t\tvoice->stimer = val;\n\t\t\t} else {\n\t\t\t\tvoice->running = 0;\n\t\t\t}\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\tif (voice->capture)\n\t\t\t\tcapture_flag = 1;\n\t\t\tif (voice->spdif)\n\t\t\t\tspdif_flag = 1;\n\t\t}\n\t}\n\tif (spdif_flag) {\n\t\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\t\toutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\n\t\t\tval = trident->spdif_pcm_ctrl;\n\t\t\tif (!go)\n\t\t\t\tval &= ~(0x28);\n\t\t\toutb(val, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\t\t} else {\n\t\t\toutl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t\t\tval = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) | SPDIF_EN;\n\t\t\toutl(val, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t\t}\n\t}\n\tif (!go)\n\t\toutl(what, TRID_REG(trident, T4D_STOP_B));\n\tval = inl(TRID_REG(trident, T4D_AINTEN_B));\n\tif (go) {\n\t\tval |= whati;\n\t} else {\n\t\tval &= ~whati;\n\t}\n\toutl(val, TRID_REG(trident, T4D_AINTEN_B));\n\tif (go) {\n\t\toutl(what, TRID_REG(trident, T4D_START_B));\n\n\t\tif (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)\n\t\t\toutb(trident->bDMAStart, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));\n\t} else {\n\t\tif (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)\n\t\t\toutb(0x00, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));\n\t}\n\tspin_unlock(&trident->reg_lock);\n\treturn 0;\n}\n\n \n\nstatic snd_pcm_uframes_t snd_trident_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tunsigned int cso;\n\n\tif (!voice->running)\n\t\treturn 0;\n\n\tspin_lock(&trident->reg_lock);\n\n\toutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\n\n\tif (trident->device != TRIDENT_DEVICE_ID_NX) {\n\t\tcso = inw(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS + 2));\n\t} else {\t\t\n\t\tcso = (unsigned int) inl(TRID_REG(trident, CH_NX_DELTA_CSO)) & 0x00ffffff;\n\t}\n\n\tspin_unlock(&trident->reg_lock);\n\n\tif (cso >= runtime->buffer_size)\n\t\tcso = 0;\n\n\treturn cso;\n}\n\n \n\nstatic snd_pcm_uframes_t snd_trident_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tunsigned int result;\n\n\tif (!voice->running)\n\t\treturn 0;\n\n\tresult = inw(TRID_REG(trident, T4D_SBBL_SBCL));\n\tif (runtime->channels > 1)\n\t\tresult >>= 1;\n\tif (result > 0)\n\t\tresult = runtime->buffer_size - result;\n\n\treturn result;\n}\n\n \n\nstatic snd_pcm_uframes_t snd_trident_spdif_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tunsigned int result;\n\n\tif (!voice->running)\n\t\treturn 0;\n\n\tresult = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;\n\n\treturn result;\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_trident_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE  ),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(256*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(256*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic const struct snd_pcm_hardware snd_trident_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE  ),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic const struct snd_pcm_hardware snd_trident_foldback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE  ),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic const struct snd_pcm_hardware snd_trident_spdif =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE  ),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\t(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t\t SNDRV_PCM_RATE_48000),\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_trident_spdif_7018 =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE  ),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic void snd_trident_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\tstruct snd_trident *trident;\n\n\tif (voice) {\n\t\ttrident = voice->trident;\n\t\tsnd_trident_free_voice(trident, voice);\n\t}\n}\n\nstatic int snd_trident_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice;\n\n\tvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\n\tif (voice == NULL)\n\t\treturn -EAGAIN;\n\tsnd_trident_pcm_mixer_build(trident, voice, substream);\n\tvoice->substream = substream;\n\truntime->private_data = voice;\n\truntime->private_free = snd_trident_pcm_free_substream;\n\truntime->hw = snd_trident_playback;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\n\treturn 0;\n}\n\n \nstatic int snd_trident_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_trident_voice *voice = runtime->private_data;\n\n\tsnd_trident_pcm_mixer_free(trident, voice, substream);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_trident_voice *voice;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\tvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\n\tif (voice == NULL)\n\t\treturn -EAGAIN;\n\tvoice->spdif = 1;\n\tvoice->substream = substream;\n\tspin_lock_irq(&trident->reg_lock);\n\ttrident->spdif_pcm_bits = trident->spdif_bits;\n\tspin_unlock_irq(&trident->reg_lock);\n\n\truntime->private_data = voice;\n\truntime->private_free = snd_trident_pcm_free_substream;\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\truntime->hw = snd_trident_spdif;\n\t} else {\n\t\truntime->hw = snd_trident_spdif_7018;\n\t}\n\n\ttrident->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);\n\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\n\treturn 0;\n}\n\n\n \n\nstatic int snd_trident_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tunsigned int temp;\n\n\tspin_lock_irq(&trident->reg_lock);\n\t\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\toutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\t\toutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\n\t} else {\n\t\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t\ttemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t\tif (trident->spdif_ctrl) {\n\t\t\ttemp |= SPDIF_EN;\n\t\t} else {\n\t\t\ttemp &= ~SPDIF_EN;\n\t\t}\n\t\toutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t}\n\tspin_unlock_irq(&trident->reg_lock);\n\ttrident->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_trident_voice *voice;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\n\tif (voice == NULL)\n\t\treturn -EAGAIN;\n\tvoice->capture = 1;\n\tvoice->substream = substream;\n\truntime->private_data = voice;\n\truntime->private_free = snd_trident_pcm_free_substream;\n\truntime->hw = snd_trident_capture;\n\tsnd_pcm_set_sync(substream);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\n\treturn 0;\n}\n\n \nstatic int snd_trident_capture_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_foldback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_trident_voice *voice;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\n\tif (voice == NULL)\n\t\treturn -EAGAIN;\n\tvoice->foldback_chan = substream->number;\n\tvoice->substream = substream;\n\truntime->private_data = voice;\n\truntime->private_free = snd_trident_pcm_free_substream;\n\truntime->hw = snd_trident_foldback;\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\n\treturn 0;\n}\n\n \nstatic int snd_trident_foldback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident *trident = snd_pcm_substream_chip(substream);\n\tstruct snd_trident_voice *voice;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tvoice = runtime->private_data;\n\t\n\t \n\tspin_lock_irq(&trident->reg_lock);\n\toutb(0x00, TRID_REG(trident, T4D_RCI + voice->foldback_chan));\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_ops snd_trident_playback_ops = {\n\t.open =\t\tsnd_trident_playback_open,\n\t.close =\tsnd_trident_playback_close,\n\t.hw_params =\tsnd_trident_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_playback_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_nx_playback_ops = {\n\t.open =\t\tsnd_trident_playback_open,\n\t.close =\tsnd_trident_playback_close,\n\t.hw_params =\tsnd_trident_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_playback_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_capture_ops = {\n\t.open =\t\tsnd_trident_capture_open,\n\t.close =\tsnd_trident_capture_close,\n\t.hw_params =\tsnd_trident_capture_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_capture_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_capture_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_si7018_capture_ops = {\n\t.open =\t\tsnd_trident_capture_open,\n\t.close =\tsnd_trident_capture_close,\n\t.hw_params =\tsnd_trident_si7018_capture_hw_params,\n\t.hw_free =\tsnd_trident_si7018_capture_hw_free,\n\t.prepare =\tsnd_trident_si7018_capture_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_foldback_ops = {\n\t.open =\t\tsnd_trident_foldback_open,\n\t.close =\tsnd_trident_foldback_close,\n\t.hw_params =\tsnd_trident_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_foldback_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_nx_foldback_ops = {\n\t.open =\t\tsnd_trident_foldback_open,\n\t.close =\tsnd_trident_foldback_close,\n\t.hw_params =\tsnd_trident_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_foldback_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_spdif_ops = {\n\t.open =\t\tsnd_trident_spdif_open,\n\t.close =\tsnd_trident_spdif_close,\n\t.hw_params =\tsnd_trident_spdif_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_spdif_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_spdif_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_trident_spdif_7018_ops = {\n\t.open =\t\tsnd_trident_spdif_open,\n\t.close =\tsnd_trident_spdif_close,\n\t.hw_params =\tsnd_trident_spdif_hw_params,\n\t.hw_free =\tsnd_trident_hw_free,\n\t.prepare =\tsnd_trident_spdif_prepare,\n\t.trigger =\tsnd_trident_trigger,\n\t.pointer =\tsnd_trident_playback_pointer,\n};\n\n \n\nint snd_trident_pcm(struct snd_trident *trident, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(trident->card, \"trident_dx_nx\", device, trident->ChanPCM, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = trident;\n\n\tif (trident->tlb.entries) {\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_nx_playback_ops);\n\t} else {\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_playback_ops);\n\t}\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\ttrident->device != TRIDENT_DEVICE_ID_SI7018 ?\n\t\t\t&snd_trident_capture_ops :\n\t\t\t&snd_trident_si7018_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tstrcpy(pcm->name, \"Trident 4DWave\");\n\ttrident->pcm = pcm;\n\n\tif (trident->tlb.entries) {\n\t\tstruct snd_pcm_substream *substream;\n\t\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\n\t\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t\t   &trident->pci->dev,\n\t\t\t\t\t\t   64*1024, 128*1024);\n\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t\t   SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &trident->pci->dev,\n\t\t\t\t\t   64*1024, 128*1024);\n\t} else {\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       &trident->pci->dev,\n\t\t\t\t\t       64*1024, 128*1024);\n\t}\n\n\treturn 0;\n}\n\n \n\nint snd_trident_foldback_pcm(struct snd_trident *trident, int device)\n{\n\tstruct snd_pcm *foldback;\n\tint err;\n\tint num_chan = 3;\n\tstruct snd_pcm_substream *substream;\n\n\tif (trident->device == TRIDENT_DEVICE_ID_NX)\n\t\tnum_chan = 4;\n\terr = snd_pcm_new(trident->card, \"trident_dx_nx\", device, 0, num_chan, &foldback);\n\tif (err < 0)\n\t\treturn err;\n\n\tfoldback->private_data = trident;\n\tif (trident->tlb.entries)\n\t\tsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_nx_foldback_ops);\n\telse\n\t\tsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_foldback_ops);\n\tfoldback->info_flags = 0;\n\tstrcpy(foldback->name, \"Trident 4DWave\");\n\tsubstream = foldback->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\tstrcpy(substream->name, \"Front Mixer\");\n\tsubstream = substream->next;\n\tstrcpy(substream->name, \"Reverb Mixer\");\n\tsubstream = substream->next;\n\tstrcpy(substream->name, \"Chorus Mixer\");\n\tif (num_chan == 4) {\n\t\tsubstream = substream->next;\n\t\tstrcpy(substream->name, \"Second AC'97 ADC\");\n\t}\n\ttrident->foldback = foldback;\n\n\tif (trident->tlb.entries)\n\t\tsnd_pcm_set_managed_buffer_all(foldback, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t       &trident->pci->dev,\n\t\t\t\t\t       0, 128*1024);\n\telse\n\t\tsnd_pcm_set_managed_buffer_all(foldback, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       &trident->pci->dev,\n\t\t\t\t\t       64*1024, 128*1024);\n\n\treturn 0;\n}\n\n \n\nint snd_trident_spdif_pcm(struct snd_trident *trident, int device)\n{\n\tstruct snd_pcm *spdif;\n\tint err;\n\n\terr = snd_pcm_new(trident->card, \"trident_dx_nx IEC958\", device, 1, 0, &spdif);\n\tif (err < 0)\n\t\treturn err;\n\n\tspdif->private_data = trident;\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\tsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_ops);\n\t} else {\n\t\tsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_7018_ops);\n\t}\n\tspdif->info_flags = 0;\n\tstrcpy(spdif->name, \"Trident 4DWave IEC958\");\n\ttrident->spdif = spdif;\n\n\tsnd_pcm_set_managed_buffer_all(spdif, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &trident->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\n \n\n\n \n\n#define snd_trident_spdif_control_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_trident_spdif_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\n\tspin_lock_irq(&trident->reg_lock);\n\tval = trident->spdif_ctrl;\n\tucontrol->value.integer.value[0] = val == kcontrol->private_value;\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\tint change;\n\n\tval = ucontrol->value.integer.value[0] ? (unsigned char) kcontrol->private_value : 0x00;\n\tspin_lock_irq(&trident->reg_lock);\n\t \n\tchange = trident->spdif_ctrl != val;\n\ttrident->spdif_ctrl = val;\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\tif ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0) {\n\t\t\toutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\n\t\t\toutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\t\t}\n\t} else {\n\t\tif (trident->spdif == NULL) {\n\t\t\tunsigned int temp;\n\t\t\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t\t\ttemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & ~SPDIF_EN;\n\t\t\tif (val)\n\t\t\t\ttemp |= SPDIF_EN;\n\t\t\toutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t\t}\n\t}\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_spdif_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,SWITCH),\n\t.info =\t\tsnd_trident_spdif_control_info,\n\t.get =\t\tsnd_trident_spdif_control_get,\n\t.put =\t\tsnd_trident_spdif_control_put,\n\t.private_value = 0x28,\n};\n\n \n\nstatic int snd_trident_spdif_default_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&trident->reg_lock);\n\tucontrol->value.iec958.status[0] = (trident->spdif_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (trident->spdif_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (trident->spdif_bits >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (trident->spdif_bits >> 24) & 0xff;\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8) |\n\t      (ucontrol->value.iec958.status[2] << 16) |\n\t      (ucontrol->value.iec958.status[3] << 24);\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = trident->spdif_bits != val;\n\ttrident->spdif_bits = val;\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\tif ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0)\n\t\t\toutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\n\t} else {\n\t\tif (trident->spdif == NULL)\n\t\t\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t}\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_spdif_default =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_trident_spdif_default_info,\n\t.get =\t\tsnd_trident_spdif_default_get,\n\t.put =\t\tsnd_trident_spdif_default_put\n};\n\n \n\nstatic int snd_trident_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_spdif_mask =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.info =\t\tsnd_trident_spdif_mask_info,\n\t.get =\t\tsnd_trident_spdif_mask_get,\n};\n\n \n\nstatic int snd_trident_spdif_stream_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&trident->reg_lock);\n\tucontrol->value.iec958.status[0] = (trident->spdif_pcm_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (trident->spdif_pcm_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (trident->spdif_pcm_bits >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (trident->spdif_pcm_bits >> 24) & 0xff;\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_trident_spdif_stream_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8) |\n\t      (ucontrol->value.iec958.status[2] << 16) |\n\t      (ucontrol->value.iec958.status[3] << 24);\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = trident->spdif_pcm_bits != val;\n\ttrident->spdif_pcm_bits = val;\n\tif (trident->spdif != NULL) {\n\t\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\t\toutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\n\t\t} else {\n\t\t\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\t\t}\n\t}\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_spdif_stream =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_trident_spdif_stream_info,\n\t.get =\t\tsnd_trident_spdif_stream_get,\n\t.put =\t\tsnd_trident_spdif_stream_put\n};\n\n \n\n#define snd_trident_ac97_control_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_trident_ac97_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\n\tspin_lock_irq(&trident->reg_lock);\n\tval = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\tucontrol->value.integer.value[0] = (val & (1 << kcontrol->private_value)) ? 1 : 0;\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_trident_ac97_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned char val;\n\tint change = 0;\n\n\tspin_lock_irq(&trident->reg_lock);\n\tval = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\tval &= ~(1 << kcontrol->private_value);\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= 1 << kcontrol->private_value;\n\tchange = val != trident->ac97_ctrl;\n\ttrident->ac97_ctrl = val;\n\toutl(trident->ac97_ctrl = val, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_ac97_rear_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Rear Path\",\n\t.info =\t\tsnd_trident_ac97_control_info,\n\t.get =\t\tsnd_trident_ac97_control_get,\n\t.put =\t\tsnd_trident_ac97_control_put,\n\t.private_value = 4,\n};\n\n \n\nstatic int snd_trident_vol_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_trident_vol_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\n\tval = trident->musicvol_wavevol;\n\tucontrol->value.integer.value[0] = 255 - ((val >> kcontrol->private_value) & 0xff);\n\tucontrol->value.integer.value[1] = 255 - ((val >> (kcontrol->private_value + 8)) & 0xff);\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_gvol, -6375, 25, 0);\n\nstatic int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tspin_lock_irq(&trident->reg_lock);\n\tval = trident->musicvol_wavevol;\n\tval &= ~(0xffff << kcontrol->private_value);\n\tval |= ((255 - (ucontrol->value.integer.value[0] & 0xff)) |\n\t        ((255 - (ucontrol->value.integer.value[1] & 0xff)) << 8)) << kcontrol->private_value;\n\tchange = val != trident->musicvol_wavevol;\n\toutl(trident->musicvol_wavevol = val, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_vol_music_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Music Playback Volume\",\n\t.info =\t\tsnd_trident_vol_control_info,\n\t.get =\t\tsnd_trident_vol_control_get,\n\t.put =\t\tsnd_trident_vol_control_put,\n\t.private_value = 16,\n\t.tlv = { .p = db_scale_gvol },\n};\n\nstatic const struct snd_kcontrol_new snd_trident_vol_wave_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Wave Playback Volume\",\n\t.info =\t\tsnd_trident_vol_control_info,\n\t.get =\t\tsnd_trident_vol_control_get,\n\t.put =\t\tsnd_trident_vol_control_put,\n\t.private_value = 0,\n\t.tlv = { .p = db_scale_gvol },\n};\n\n \n\nstatic int snd_trident_pcm_vol_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018)\n\t\tuinfo->value.integer.max = 1023;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_vol_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\tucontrol->value.integer.value[0] = 1023 - mix->vol;\n\t} else {\n\t\tucontrol->value.integer.value[0] = 255 - (mix->vol>>2);\n\t}\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_vol_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\tunsigned int val;\n\tint change = 0;\n\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\tval = 1023 - (ucontrol->value.integer.value[0] & 1023);\n\t} else {\n\t\tval = (255 - (ucontrol->value.integer.value[0] & 255)) << 2;\n\t}\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = val != mix->vol;\n\tmix->vol = val;\n\tif (mix->voice != NULL)\n\t\tsnd_trident_write_vol_reg(trident, mix->voice, val);\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_pcm_vol_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"PCM Front Playback Volume\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.count =\t32,\n\t.info =\t\tsnd_trident_pcm_vol_control_info,\n\t.get =\t\tsnd_trident_pcm_vol_control_get,\n\t.put =\t\tsnd_trident_pcm_vol_control_put,\n\t \n};\n\n \n\nstatic int snd_trident_pcm_pan_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_pan_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\n\tucontrol->value.integer.value[0] = mix->pan;\n\tif (ucontrol->value.integer.value[0] & 0x40) {\n\t\tucontrol->value.integer.value[0] = (0x3f - (ucontrol->value.integer.value[0] & 0x3f));\n\t} else {\n\t\tucontrol->value.integer.value[0] |= 0x40;\n\t}\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_pan_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\tunsigned char val;\n\tint change = 0;\n\n\tif (ucontrol->value.integer.value[0] & 0x40)\n\t\tval = ucontrol->value.integer.value[0] & 0x3f;\n\telse\n\t\tval = (0x3f - (ucontrol->value.integer.value[0] & 0x3f)) | 0x40;\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = val != mix->pan;\n\tmix->pan = val;\n\tif (mix->voice != NULL)\n\t\tsnd_trident_write_pan_reg(trident, mix->voice, val);\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_pcm_pan_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"PCM Pan Playback Control\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.count =\t32,\n\t.info =\t\tsnd_trident_pcm_pan_control_info,\n\t.get =\t\tsnd_trident_pcm_pan_control_get,\n\t.put =\t\tsnd_trident_pcm_pan_control_put,\n};\n\n \n\nstatic int snd_trident_pcm_rvol_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_rvol_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\n\tucontrol->value.integer.value[0] = 127 - mix->rvol;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\tunsigned short val;\n\tint change = 0;\n\n\tval = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = val != mix->rvol;\n\tmix->rvol = val;\n\tif (mix->voice != NULL)\n\t\tsnd_trident_write_rvol_reg(trident, mix->voice, val);\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);\n\nstatic const struct snd_kcontrol_new snd_trident_pcm_rvol_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"PCM Reverb Playback Volume\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.count = \t32,\n\t.info =\t\tsnd_trident_pcm_rvol_control_info,\n\t.get =\t\tsnd_trident_pcm_rvol_control_get,\n\t.put =\t\tsnd_trident_pcm_rvol_control_put,\n\t.tlv = { .p = db_scale_crvol },\n};\n\n \n\nstatic int snd_trident_pcm_cvol_control_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 127;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_cvol_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\n\tucontrol->value.integer.value[0] = 127 - mix->cvol;\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_cvol_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\n\tstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\n\tunsigned short val;\n\tint change = 0;\n\n\tval = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);\n\tspin_lock_irq(&trident->reg_lock);\n\tchange = val != mix->cvol;\n\tmix->cvol = val;\n\tif (mix->voice != NULL)\n\t\tsnd_trident_write_cvol_reg(trident, mix->voice, val);\n\tspin_unlock_irq(&trident->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_trident_pcm_cvol_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"PCM Chorus Playback Volume\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.count =\t32,\n\t.info =\t\tsnd_trident_pcm_cvol_control_info,\n\t.get =\t\tsnd_trident_pcm_cvol_control_get,\n\t.put =\t\tsnd_trident_pcm_cvol_control_put,\n\t.tlv = { .p = db_scale_crvol },\n};\n\nstatic void snd_trident_notify_pcm_change1(struct snd_card *card,\n\t\t\t\t\t   struct snd_kcontrol *kctl,\n\t\t\t\t\t   int num, int activate)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (! kctl)\n\t\treturn;\n\tif (activate)\n\t\tkctl->vd[num].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\telse\n\t\tkctl->vd[num].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t       snd_ctl_build_ioff(&id, kctl, num));\n}\n\nstatic void snd_trident_notify_pcm_change(struct snd_trident *trident,\n\t\t\t\t\t  struct snd_trident_pcm_mixer *tmix,\n\t\t\t\t\t  int num, int activate)\n{\n\tsnd_trident_notify_pcm_change1(trident->card, trident->ctl_vol, num, activate);\n\tsnd_trident_notify_pcm_change1(trident->card, trident->ctl_pan, num, activate);\n\tsnd_trident_notify_pcm_change1(trident->card, trident->ctl_rvol, num, activate);\n\tsnd_trident_notify_pcm_change1(trident->card, trident->ctl_cvol, num, activate);\n}\n\nstatic int snd_trident_pcm_mixer_build(struct snd_trident *trident,\n\t\t\t\t       struct snd_trident_voice *voice,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident_pcm_mixer *tmix;\n\n\tif (snd_BUG_ON(!trident || !voice || !substream))\n\t\treturn -EINVAL;\n\ttmix = &trident->pcm_mixer[substream->number];\n\ttmix->voice = voice;\n\ttmix->vol = T4D_DEFAULT_PCM_VOL;\n\ttmix->pan = T4D_DEFAULT_PCM_PAN;\n\ttmix->rvol = T4D_DEFAULT_PCM_RVOL;\n\ttmix->cvol = T4D_DEFAULT_PCM_CVOL;\n\tsnd_trident_notify_pcm_change(trident, tmix, substream->number, 1);\n\treturn 0;\n}\n\nstatic int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_trident_voice *voice, struct snd_pcm_substream *substream)\n{\n\tstruct snd_trident_pcm_mixer *tmix;\n\n\tif (snd_BUG_ON(!trident || !substream))\n\t\treturn -EINVAL;\n\ttmix = &trident->pcm_mixer[substream->number];\n\ttmix->voice = NULL;\n\tsnd_trident_notify_pcm_change(trident, tmix, substream->number, 0);\n\treturn 0;\n}\n\n \n\nstatic int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)\n{\n\tstruct snd_ac97_template _ac97;\n\tstruct snd_card *card = trident->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_value *uctl;\n\tint idx, err, retries = 2;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_trident_codec_write,\n\t\t.read = snd_trident_codec_read,\n\t};\n\n\tuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (!uctl)\n\t\treturn -ENOMEM;\n\n\terr = snd_ac97_bus(trident->card, 0, &ops, NULL, &trident->ac97_bus);\n\tif (err < 0)\n\t\tgoto __out;\n\n\tmemset(&_ac97, 0, sizeof(_ac97));\n\t_ac97.private_data = trident;\n\ttrident->ac97_detect = 1;\n\n      __again:\n\terr = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97);\n\tif (err < 0) {\n\t\tif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\t\terr = snd_trident_sis_reset(trident);\n\t\t\tif (err < 0)\n\t\t\t\tgoto __out;\n\t\t\tif (retries-- > 0)\n\t\t\t\tgoto __again;\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto __out;\n\t}\n\t\n\t \n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018 &&\n\t    (inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0) {\n\t\t_ac97.num = 1;\n\t\terr = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97_sec);\n\t\tif (err < 0)\n\t\t\tdev_err(trident->card->dev,\n\t\t\t\t\"SI7018: the secondary codec - invalid access\\n\");\n#if 0\t\n\t\t{\n\t\t\tstruct snd_ac97 *mc97;\n\t\t\terr = snd_ac97_modem(trident->card, &_ac97, &mc97);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(trident->card->dev,\n\t\t\t\t\t\"snd_ac97_modem returned error %i\\n\", err);\n\t\t}\n#endif\n\t}\n\t\n\ttrident->ac97_detect = 0;\n\n\tif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\n\t\tkctl = snd_ctl_new1(&snd_trident_vol_wave_control, trident);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\t\tkctl->put(kctl, uctl);\n\t\tkctl = snd_ctl_new1(&snd_trident_vol_music_control, trident);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\t\tkctl->put(kctl, uctl);\n\t\toutl(trident->musicvol_wavevol = 0x00000000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\n\t} else {\n\t\toutl(trident->musicvol_wavevol = 0xffff0000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\n\t}\n\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tstruct snd_trident_pcm_mixer *tmix;\n\t\t\n\t\ttmix = &trident->pcm_mixer[idx];\n\t\ttmix->voice = NULL;\n\t}\n\ttrident->ctl_vol = snd_ctl_new1(&snd_trident_pcm_vol_control, trident);\n\tif (!trident->ctl_vol)\n\t\tgoto __nomem;\n\terr = snd_ctl_add(card, trident->ctl_vol);\n\tif (err)\n\t\tgoto __out;\n\t\t\n\ttrident->ctl_pan = snd_ctl_new1(&snd_trident_pcm_pan_control, trident);\n\tif (!trident->ctl_pan)\n\t\tgoto __nomem;\n\terr = snd_ctl_add(card, trident->ctl_pan);\n\tif (err)\n\t\tgoto __out;\n\n\ttrident->ctl_rvol = snd_ctl_new1(&snd_trident_pcm_rvol_control, trident);\n\tif (!trident->ctl_rvol)\n\t\tgoto __nomem;\n\terr = snd_ctl_add(card, trident->ctl_rvol);\n\tif (err)\n\t\tgoto __out;\n\n\ttrident->ctl_cvol = snd_ctl_new1(&snd_trident_pcm_cvol_control, trident);\n\tif (!trident->ctl_cvol)\n\t\tgoto __nomem;\n\terr = snd_ctl_add(card, trident->ctl_cvol);\n\tif (err)\n\t\tgoto __out;\n\n\tif (trident->device == TRIDENT_DEVICE_ID_NX) {\n\t\tkctl = snd_ctl_new1(&snd_trident_ac97_rear_control, trident);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\t\tkctl->put(kctl, uctl);\n\t}\n\tif (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\n\t\tkctl = snd_ctl_new1(&snd_trident_spdif_control, trident);\n\t\tif (kctl == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __out;\n\t\t}\n\t\tif (trident->ac97->ext_id & AC97_EI_SPDIF)\n\t\t\tkctl->id.index++;\n\t\tif (trident->ac97_sec && (trident->ac97_sec->ext_id & AC97_EI_SPDIF))\n\t\t\tkctl->id.index++;\n\t\tidx = kctl->id.index;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\t\tkctl->put(kctl, uctl);\n\n\t\tkctl = snd_ctl_new1(&snd_trident_spdif_default, trident);\n\t\tif (kctl == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __out;\n\t\t}\n\t\tkctl->id.index = idx;\n\t\tkctl->id.device = pcm_spdif_device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\n\t\tkctl = snd_ctl_new1(&snd_trident_spdif_mask, trident);\n\t\tif (kctl == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __out;\n\t\t}\n\t\tkctl->id.index = idx;\n\t\tkctl->id.device = pcm_spdif_device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\n\t\tkctl = snd_ctl_new1(&snd_trident_spdif_stream, trident);\n\t\tif (kctl == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __out;\n\t\t}\n\t\tkctl->id.index = idx;\n\t\tkctl->id.device = pcm_spdif_device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto __out;\n\t\ttrident->spdif_pcm_ctl = kctl;\n\t}\n\n\terr = 0;\n\tgoto __out;\n\n __nomem:\n\terr = -ENOMEM;\n\n __out:\n\tkfree(uctl);\n\n\treturn err;\n}\n\n \n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n\nstatic unsigned char snd_trident_gameport_read(struct gameport *gameport)\n{\n\tstruct snd_trident *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\treturn inb(TRID_REG(chip, GAMEPORT_LEGACY));\n}\n\nstatic void snd_trident_gameport_trigger(struct gameport *gameport)\n{\n\tstruct snd_trident *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn;\n\toutb(0xff, TRID_REG(chip, GAMEPORT_LEGACY));\n}\n\nstatic int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tstruct snd_trident *chip = gameport_get_port_data(gameport);\n\tint i;\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\n\t*buttons = (~inb(TRID_REG(chip, GAMEPORT_LEGACY)) >> 4) & 0xf;\n\n\tfor (i = 0; i < 4; i++) {\n\t\taxes[i] = inw(TRID_REG(chip, GAMEPORT_AXES + i * 2));\n\t\tif (axes[i] == 0xffff) axes[i] = -1;\n\t}\n        \n        return 0;\n}\n\nstatic int snd_trident_gameport_open(struct gameport *gameport, int mode)\n{\n\tstruct snd_trident *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\n\tswitch (mode) {\n\t\tcase GAMEPORT_MODE_COOKED:\n\t\t\toutb(GAMEPORT_MODE_ADC, TRID_REG(chip, GAMEPORT_GCR));\n\t\t\tmsleep(20);\n\t\t\treturn 0;\n\t\tcase GAMEPORT_MODE_RAW:\n\t\t\toutb(0, TRID_REG(chip, GAMEPORT_GCR));\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}\n\nint snd_trident_create_gameport(struct snd_trident *chip)\n{\n\tstruct gameport *gp;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"Trident 4DWave\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\n\tgameport_set_port_data(gp, chip);\n\tgp->fuzz = 64;\n\tgp->read = snd_trident_gameport_read;\n\tgp->trigger = snd_trident_gameport_trigger;\n\tgp->cooked_read = snd_trident_gameport_cooked_read;\n\tgp->open = snd_trident_gameport_open;\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic inline void snd_trident_free_gameport(struct snd_trident *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nint snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }\nstatic inline void snd_trident_free_gameport(struct snd_trident *chip) { }\n#endif  \n\n \nstatic inline void do_delay(struct snd_trident *chip)\n{\n\tschedule_timeout_uninterruptible(1);\n}\n\n \n\nstatic int snd_trident_sis_reset(struct snd_trident *trident)\n{\n\tunsigned long end_time;\n\tunsigned int i;\n\tint r;\n\n\tr = trident->in_suspend ? 0 : 2;\t \n      __si7018_retry:\n\tpci_write_config_byte(trident->pci, 0x46, 0x04);\t \n\tudelay(100);\n\tpci_write_config_byte(trident->pci, 0x46, 0x00);\n\tudelay(100);\n\t \n\toutb(0x00, TRID_REG(trident, SI_AC97_GPIO));\n\t \n\ti = PCMOUT|SURROUT|CENTEROUT|LFEOUT|SECONDARY_ID|COLD_RESET;\n\toutl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\tudelay(1000);\n\t \n\ti &= ~COLD_RESET;\n\toutl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\tudelay(2000);\n\t \n\tend_time = (jiffies + (HZ * 3) / 4) + 1;\n\tdo {\n\t\tif ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0)\n\t\t\tgoto __si7018_ok;\n\t\tdo_delay(trident);\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(trident->card->dev, \"AC'97 codec ready error [0x%x]\\n\",\n\t\tinl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));\n\tif (r-- > 0) {\n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tdo_delay(trident);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tgoto __si7018_retry;\n\t}\n      __si7018_ok:\n\t \n\tdo {\n\t\tif ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_SECONDARY_READY) != 0)\n\t\t\tbreak;\n\t\tdo_delay(trident);\n\t} while (time_after_eq(end_time, jiffies));\n\t \n\toutl(BANK_B_EN, TRID_REG(trident, T4D_LFO_GC_CIR));\n\treturn 0;\n}\n\n \n\nstatic void snd_trident_proc_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_trident *trident = entry->private_data;\n\tchar *s;\n\n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\ts = \"SiS 7018 Audio\";\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_DX:\n\t\ts = \"Trident 4DWave PCI DX\";\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\ts = \"Trident 4DWave PCI NX\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"???\";\n\t}\n\tsnd_iprintf(buffer, \"%s\\n\\n\", s);\n\tsnd_iprintf(buffer, \"Spurious IRQs    : %d\\n\", trident->spurious_irq_count);\n\tsnd_iprintf(buffer, \"Spurious IRQ dlta: %d\\n\", trident->spurious_irq_max_delta);\n\tif (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018)\n\t\tsnd_iprintf(buffer, \"IEC958 Mixer Out : %s\\n\", trident->spdif_ctrl == 0x28 ? \"on\" : \"off\");\n\tif (trident->device == TRIDENT_DEVICE_ID_NX) {\n\t\tsnd_iprintf(buffer, \"Rear Speakers    : %s\\n\", trident->ac97_ctrl & 0x00000010 ? \"on\" : \"off\");\n\t\tif (trident->tlb.entries) {\n\t\t\tsnd_iprintf(buffer,\"\\nVirtual Memory\\n\");\n\t\t\tsnd_iprintf(buffer, \"Memory Maximum : %d\\n\", trident->tlb.memhdr->size);\n\t\t\tsnd_iprintf(buffer, \"Memory Used    : %d\\n\", trident->tlb.memhdr->used);\n\t\t\tsnd_iprintf(buffer, \"Memory Free    : %d\\n\", snd_util_mem_avail(trident->tlb.memhdr));\n\t\t}\n\t}\n}\n\nstatic void snd_trident_proc_init(struct snd_trident *trident)\n{\n\tconst char *s = \"trident\";\n\t\n\tif (trident->device == TRIDENT_DEVICE_ID_SI7018)\n\t\ts = \"sis7018\";\n\tsnd_card_ro_proc_new(trident->card, s, trident, snd_trident_proc_read);\n}\n\n \n\nstatic int snd_trident_tlb_alloc(struct snd_trident *trident)\n{\n\tint i;\n\n\t \n\n\ttrident->tlb.buffer =\n\t\tsnd_devm_alloc_pages(&trident->pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t     2 * SNDRV_TRIDENT_MAX_PAGES * 4);\n\tif (!trident->tlb.buffer) {\n\t\tdev_err(trident->card->dev, \"unable to allocate TLB buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttrident->tlb.entries = (__le32 *)ALIGN((unsigned long)trident->tlb.buffer->area, SNDRV_TRIDENT_MAX_PAGES * 4);\n\ttrident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer->addr, SNDRV_TRIDENT_MAX_PAGES * 4);\n\n\t \n\ttrident->tlb.silent_page =\n\t\tsnd_devm_alloc_pages(&trident->pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t     SNDRV_TRIDENT_PAGE_SIZE);\n\tif (!trident->tlb.silent_page) {\n\t\tdev_err(trident->card->dev, \"unable to allocate silent page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(trident->tlb.silent_page->area, 0, SNDRV_TRIDENT_PAGE_SIZE);\n\tfor (i = 0; i < SNDRV_TRIDENT_MAX_PAGES; i++)\n\t\ttrident->tlb.entries[i] = cpu_to_le32(trident->tlb.silent_page->addr & ~(SNDRV_TRIDENT_PAGE_SIZE-1));\n\n\t \n\ttrident->tlb.memhdr = snd_util_memhdr_new(SNDRV_TRIDENT_PAGE_SIZE * SNDRV_TRIDENT_MAX_PAGES);\n\tif (trident->tlb.memhdr == NULL)\n\t\treturn -ENOMEM;\n\n\ttrident->tlb.memhdr->block_extra_size = sizeof(struct snd_trident_memblk_arg);\n\treturn 0;\n}\n\n \n\nstatic void snd_trident_stop_all_voices(struct snd_trident *trident)\n{\n\toutl(0xffffffff, TRID_REG(trident, T4D_STOP_A));\n\toutl(0xffffffff, TRID_REG(trident, T4D_STOP_B));\n\toutl(0, TRID_REG(trident, T4D_AINTEN_A));\n\toutl(0, TRID_REG(trident, T4D_AINTEN_B));\n}\n\nstatic int snd_trident_4d_dx_init(struct snd_trident *trident)\n{\n\tstruct pci_dev *pci = trident->pci;\n\tunsigned long end_time;\n\n\t \n\tpci_write_config_dword(pci, 0x40, 0);\t \n\tpci_write_config_byte(pci, 0x44, 0);\t \n\tpci_write_config_byte(pci, 0x45, 0);\t \n\tpci_write_config_byte(pci, 0x46, 4);  \n\tudelay(100);\n\tpci_write_config_byte(pci, 0x46, 0);  \n\tudelay(100);\n\t\n\t \n\toutl(0x00000001, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\n\tudelay(100);\n\toutl(0x00000000, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\n\t \n\ttrident->ac97_ctrl = 0x0000004a;\n\toutl(trident->ac97_ctrl, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\n\t \n\tend_time = (jiffies + (HZ * 3) / 4) + 1;\n\tdo {\n\t\tif ((inl(TRID_REG(trident, DX_ACR2_AC97_COM_STAT)) & 0x0010) != 0)\n\t\t\tgoto __dx_ok;\n\t\tdo_delay(trident);\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(trident->card->dev, \"AC'97 codec ready error\\n\");\n\treturn -EIO;\n\n __dx_ok:\n\tsnd_trident_stop_all_voices(trident);\n\n\treturn 0;\n}\n\n \nstatic int snd_trident_4d_nx_init(struct snd_trident *trident)\n{\n\tstruct pci_dev *pci = trident->pci;\n\tunsigned long end_time;\n\n\t \n\tpci_write_config_dword(pci, 0x40, 0);\t \n\tpci_write_config_byte(pci, 0x44, 0);\t \n\tpci_write_config_byte(pci, 0x45, 0);\t \n\n\tpci_write_config_byte(pci, 0x46, 1);  \n\tudelay(100);\n\tpci_write_config_byte(pci, 0x46, 0);  \n\tudelay(100);\n\n\t \n\toutl(0x00000001, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\tudelay(100);\n\toutl(0x00000000, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\t \n\tend_time = (jiffies + (HZ * 3) / 4) + 1;\n\tdo {\n\t\tif ((inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)) & 0x0008) != 0)\n\t\t\tgoto __nx_ok;\n\t\tdo_delay(trident);\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(trident->card->dev, \"AC'97 codec ready error [0x%x]\\n\",\n\t\tinl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)));\n\treturn -EIO;\n\n __nx_ok:\n\t \n\ttrident->ac97_ctrl = 0x00000002;\n\toutl(trident->ac97_ctrl, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\n\t \n\toutl(NX_SB_IRQ_DISABLE, TRID_REG(trident, T4D_MISCINT));\n\n\tsnd_trident_stop_all_voices(trident);\n\n\tif (trident->tlb.entries != NULL) {\n\t\tunsigned int i;\n\t\t \n\t\ti = trident->tlb.entries_dmaaddr;\n\t\ti |= 0x00000001;\n\t\toutl(i, TRID_REG(trident, NX_TLBC));\n\t} else {\n\t\toutl(0, TRID_REG(trident, NX_TLBC));\n\t}\n\t \n\toutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\n\toutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\n\treturn 0;\n}\n\n \nstatic int snd_trident_sis_init(struct snd_trident *trident)\n{\n\tint err;\n\n\terr = snd_trident_sis_reset(trident);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_trident_stop_all_voices(trident);\n\n\t \n\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\n\treturn 0;\n}\n\n \n\nint snd_trident_create(struct snd_card *card,\n\t\t       struct pci_dev *pci,\n\t\t       int pcm_streams,\n\t\t       int pcm_spdif_device,\n\t\t       int max_wavetable_size)\n{\n\tstruct snd_trident *trident = card->private_data;\n\tint i, err;\n\tstruct snd_trident_voice *voice;\n\tstruct snd_trident_pcm_mixer *tmix;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(30))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 30bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\t\n\ttrident->device = (pci->vendor << 16) | pci->device;\n\ttrident->card = card;\n\ttrident->pci = pci;\n\tspin_lock_init(&trident->reg_lock);\n\tspin_lock_init(&trident->event_lock);\n\tspin_lock_init(&trident->voice_alloc);\n\tif (pcm_streams < 1)\n\t\tpcm_streams = 1;\n\tif (pcm_streams > 32)\n\t\tpcm_streams = 32;\n\ttrident->ChanPCM = pcm_streams;\n\tif (max_wavetable_size < 0 )\n\t\tmax_wavetable_size = 0;\n\ttrident->synth.max_size = max_wavetable_size * 1024;\n\ttrident->irq = -1;\n\tcard->private_free = snd_trident_free;\n\n\ttrident->midi_port = TRID_REG(trident, T4D_MPU401_BASE);\n\tpci_set_master(pci);\n\n\terr = pci_request_regions(pci, \"Trident Audio\");\n\tif (err < 0)\n\t\treturn err;\n\ttrident->port = pci_resource_start(pci, 0);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_trident_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, trident)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\ttrident->irq = pci->irq;\n\tcard->sync_irq = trident->irq;\n\n\t \n\ttrident->tlb.entries = NULL;\n\tif (trident->device == TRIDENT_DEVICE_ID_NX) {\n\t\terr = snd_trident_tlb_alloc(trident);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttrident->spdif_bits = trident->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\n\t \n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_DX:\n\t\terr = snd_trident_4d_dx_init(trident);\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\terr = snd_trident_4d_nx_init(trident);\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\terr = snd_trident_sis_init(trident);\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_trident_mixer(trident, pcm_spdif_device);\n\tif (err < 0)\n\t\treturn err;\n\t\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\tvoice = &trident->synth.voices[i];\n\t\tvoice->number = i;\n\t\tvoice->trident = trident;\n\t}\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\ttmix = &trident->pcm_mixer[i];\n\t\ttmix->vol = T4D_DEFAULT_PCM_VOL;\n\t\ttmix->pan = T4D_DEFAULT_PCM_PAN;\n\t\ttmix->rvol = T4D_DEFAULT_PCM_RVOL;\n\t\ttmix->cvol = T4D_DEFAULT_PCM_CVOL;\n\t}\n\n\tsnd_trident_enable_eso(trident);\n\n\tsnd_trident_proc_init(trident);\n\treturn 0;\n}\n\n \n\nstatic void snd_trident_free(struct snd_card *card)\n{\n\tstruct snd_trident *trident = card->private_data;\n\n\tsnd_trident_free_gameport(trident);\n\tsnd_trident_disable_eso(trident);\n\t \n\tif (trident->device == TRIDENT_DEVICE_ID_NX)\n\t\toutb(0x00, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\n\telse if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\n\t\toutl(0, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\n\t}\n\tif (trident->tlb.buffer) {\n\t\toutl(0, TRID_REG(trident, NX_TLBC));\n\t\tsnd_util_memhdr_free(trident->tlb.memhdr);\n\t}\n}\n\n \n\nstatic irqreturn_t snd_trident_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_trident *trident = dev_id;\n\tunsigned int audio_int, chn_int, stimer, channel, mask, tmp;\n\tint delta;\n\tstruct snd_trident_voice *voice;\n\n\taudio_int = inl(TRID_REG(trident, T4D_MISCINT));\n\tif ((audio_int & (ADDRESS_IRQ|MPU401_IRQ)) == 0)\n\t\treturn IRQ_NONE;\n\tif (audio_int & ADDRESS_IRQ) {\n\t\t\n\t\tspin_lock(&trident->reg_lock);\n\t\tstimer = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;\n\t\tchn_int = inl(TRID_REG(trident, T4D_AINT_A));\n\t\tif (chn_int == 0)\n\t\t\tgoto __skip1;\n\t\toutl(chn_int, TRID_REG(trident, T4D_AINT_A));\t \n\t      __skip1:\n\t\tchn_int = inl(TRID_REG(trident, T4D_AINT_B));\n\t\tif (chn_int == 0)\n\t\t\tgoto __skip2;\n\t\tfor (channel = 63; channel >= 32; channel--) {\n\t\t\tmask = 1 << (channel&0x1f);\n\t\t\tif ((chn_int & mask) == 0)\n\t\t\t\tcontinue;\n\t\t\tvoice = &trident->synth.voices[channel];\n\t\t\tif (!voice->pcm || voice->substream == NULL) {\n\t\t\t\toutl(mask, TRID_REG(trident, T4D_STOP_B));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdelta = (int)stimer - (int)voice->stimer;\n\t\t\tif (delta < 0)\n\t\t\t\tdelta = -delta;\n\t\t\tif ((unsigned int)delta < voice->spurious_threshold) {\n\t\t\t\t \n\t\t\t\ttrident->spurious_irq_count++;\n\t\t\t\tif (trident->spurious_irq_max_delta < (unsigned int)delta)\n\t\t\t\t\ttrident->spurious_irq_max_delta = delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvoice->stimer = stimer;\n\t\t\tif (voice->isync) {\n\t\t\t\tif (!voice->isync3) {\n\t\t\t\t\ttmp = inw(TRID_REG(trident, T4D_SBBL_SBCL));\n\t\t\t\t\tif (trident->bDMAStart & 0x40)\n\t\t\t\t\t\ttmp >>= 1;\n\t\t\t\t\tif (tmp > 0)\n\t\t\t\t\t\ttmp = voice->isync_max - tmp;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;\n\t\t\t\t}\n\t\t\t\tif (tmp < voice->isync_mark) {\n\t\t\t\t\tif (tmp > 0x10)\n\t\t\t\t\t\ttmp = voice->isync_ESO - 7;\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp = voice->isync_ESO + 2;\n\t\t\t\t\t \n\t\t\t\t\tsnd_trident_stop_voice(trident, voice->number);\n\t\t\t\t\tsnd_trident_write_eso_reg(trident, voice, tmp);\n\t\t\t\t\tsnd_trident_start_voice(trident, voice->number);\n\t\t\t\t}\n\t\t\t} else if (voice->isync2) {\n\t\t\t\tvoice->isync2 = 0;\n\t\t\t\t \n\t\t\t\tsnd_trident_stop_voice(trident, voice->number);\n\t\t\t\tsnd_trident_write_cso_reg(trident, voice, voice->isync_mark);\n\t\t\t\tsnd_trident_write_eso_reg(trident, voice, voice->ESO);\n\t\t\t\tsnd_trident_start_voice(trident, voice->number);\n\t\t\t}\n#if 0\n\t\t\tif (voice->extra) {\n\t\t\t\t \n\t\t\t\tsnd_trident_stop_voice(trident, voice->extra->number);\n\t\t\t\tsnd_trident_write_cso_reg(trident, voice->extra, 0);\n\t\t\t\tsnd_trident_start_voice(trident, voice->extra->number);\n\t\t\t}\n#endif\n\t\t\tspin_unlock(&trident->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(voice->substream);\n\t\t\tspin_lock(&trident->reg_lock);\n\t\t}\n\t\toutl(chn_int, TRID_REG(trident, T4D_AINT_B));\t \n\t      __skip2:\n\t\tspin_unlock(&trident->reg_lock);\n\t}\n\tif (audio_int & MPU401_IRQ) {\n\t\tif (trident->rmidi) {\n\t\t\tsnd_mpu401_uart_interrupt(irq, trident->rmidi->private_data);\n\t\t} else {\n\t\t\tinb(TRID_REG(trident, T4D_MPUR0));\n\t\t}\n\t}\n\t\n\treturn IRQ_HANDLED;\n}\n\nstruct snd_trident_voice *snd_trident_alloc_voice(struct snd_trident * trident, int type, int client, int port)\n{\n\tstruct snd_trident_voice *pvoice;\n\tunsigned long flags;\n\tint idx;\n\n\tspin_lock_irqsave(&trident->voice_alloc, flags);\n\tif (type == SNDRV_TRIDENT_VOICE_TYPE_PCM) {\n\t\tidx = snd_trident_allocate_pcm_channel(trident);\n\t\tif(idx < 0) {\n\t\t\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\t\t\treturn NULL;\n\t\t}\n\t\tpvoice = &trident->synth.voices[idx];\n\t\tpvoice->use = 1;\n\t\tpvoice->pcm = 1;\n\t\tpvoice->capture = 0;\n\t\tpvoice->spdif = 0;\n\t\tpvoice->memblk = NULL;\n\t\tpvoice->substream = NULL;\n\t\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\t\treturn pvoice;\n\t}\n\tif (type == SNDRV_TRIDENT_VOICE_TYPE_SYNTH) {\n\t\tidx = snd_trident_allocate_synth_channel(trident);\n\t\tif(idx < 0) {\n\t\t\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\t\t\treturn NULL;\n\t\t}\n\t\tpvoice = &trident->synth.voices[idx];\n\t\tpvoice->use = 1;\n\t\tpvoice->synth = 1;\n\t\tpvoice->client = client;\n\t\tpvoice->port = port;\n\t\tpvoice->memblk = NULL;\n\t\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\t\treturn pvoice;\n\t}\n\tif (type == SNDRV_TRIDENT_VOICE_TYPE_MIDI) {\n\t}\n\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_trident_alloc_voice);\n\nvoid snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voice *voice)\n{\n\tunsigned long flags;\n\tvoid (*private_free)(struct snd_trident_voice *);\n\n\tif (voice == NULL || !voice->use)\n\t\treturn;\n\tsnd_trident_clear_voices(trident, voice->number, voice->number);\n\tspin_lock_irqsave(&trident->voice_alloc, flags);\n\tprivate_free = voice->private_free;\n\tvoice->private_free = NULL;\n\tvoice->private_data = NULL;\n\tif (voice->pcm)\n\t\tsnd_trident_free_pcm_channel(trident, voice->number);\n\tif (voice->synth)\n\t\tsnd_trident_free_synth_channel(trident, voice->number);\n\tvoice->use = voice->pcm = voice->synth = voice->midi = 0;\n\tvoice->capture = voice->spdif = 0;\n\tvoice->sample_ops = NULL;\n\tvoice->substream = NULL;\n\tvoice->extra = NULL;\n\tspin_unlock_irqrestore(&trident->voice_alloc, flags);\n\tif (private_free)\n\t\tprivate_free(voice);\n}\n\nEXPORT_SYMBOL(snd_trident_free_voice);\n\nstatic void snd_trident_clear_voices(struct snd_trident * trident, unsigned short v_min, unsigned short v_max)\n{\n\tunsigned int i, val, mask[2] = { 0, 0 };\n\n\tif (snd_BUG_ON(v_min > 63 || v_max > 63))\n\t\treturn;\n\tfor (i = v_min; i <= v_max; i++)\n\t\tmask[i >> 5] |= 1 << (i & 0x1f);\n\tif (mask[0]) {\n\t\toutl(mask[0], TRID_REG(trident, T4D_STOP_A));\n\t\tval = inl(TRID_REG(trident, T4D_AINTEN_A));\n\t\toutl(val & ~mask[0], TRID_REG(trident, T4D_AINTEN_A));\n\t}\n\tif (mask[1]) {\n\t\toutl(mask[1], TRID_REG(trident, T4D_STOP_B));\n\t\tval = inl(TRID_REG(trident, T4D_AINTEN_B));\n\t\toutl(val & ~mask[1], TRID_REG(trident, T4D_AINTEN_B));\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_trident_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_trident *trident = card->private_data;\n\n\ttrident->in_suspend = 1;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(trident->ac97);\n\tsnd_ac97_suspend(trident->ac97_sec);\n\treturn 0;\n}\n\nstatic int snd_trident_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_trident *trident = card->private_data;\n\n\tswitch (trident->device) {\n\tcase TRIDENT_DEVICE_ID_DX:\n\t\tsnd_trident_4d_dx_init(trident);\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_NX:\n\t\tsnd_trident_4d_nx_init(trident);\n\t\tbreak;\n\tcase TRIDENT_DEVICE_ID_SI7018:\n\t\tsnd_trident_sis_init(trident);\n\t\tbreak;\n\t}\n\n\tsnd_ac97_resume(trident->ac97);\n\tsnd_ac97_resume(trident->ac97_sec);\n\n\t \n\toutl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\n\n\tsnd_trident_enable_eso(trident);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\ttrident->in_suspend = 0;\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(snd_trident_pm, snd_trident_suspend, snd_trident_resume);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}