{
  "module_name": "ymfpci.c",
  "hash_id": "1f6d2995f67036bb093244ca2bc076e95ee1fad179a05318a9bd7d8db0504413",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ymfpci/ymfpci.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include \"ymfpci.h\"\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Yamaha DS-1 PCI\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic long fm_port[SNDRV_CARDS];\nstatic long mpu_port[SNDRV_CARDS];\n#ifdef SUPPORT_JOYSTICK\nstatic long joystick_port[SNDRV_CARDS];\n#endif\nstatic bool rear_switch[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the Yamaha DS-1 PCI soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the Yamaha DS-1 PCI soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Yamaha DS-1 soundcard.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 Port.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM OPL-3 Port.\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_hw_array(joystick_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(joystick_port, \"Joystick port address\");\n#endif\nmodule_param_array(rear_switch, bool, NULL, 0444);\nMODULE_PARM_DESC(rear_switch, \"Enable shared rear/line-in switch\");\n\nstatic const struct pci_device_id snd_ymfpci_ids[] = {\n\t{ PCI_VDEVICE(YAMAHA, 0x0004), 0, },    \n\t{ PCI_VDEVICE(YAMAHA, 0x000d), 0, },    \n\t{ PCI_VDEVICE(YAMAHA, 0x000a), 0, },    \n\t{ PCI_VDEVICE(YAMAHA, 0x000c), 0, },    \n\t{ PCI_VDEVICE(YAMAHA, 0x0010), 0, },    \n\t{ PCI_VDEVICE(YAMAHA, 0x0012), 0, },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_ymfpci_ids);\n\n#ifdef SUPPORT_JOYSTICK\nstatic int snd_ymfpci_create_gameport(struct snd_ymfpci *chip, int dev,\n\t\t\t\t      int legacy_ctrl, int legacy_ctrl2)\n{\n\tstruct gameport *gp;\n\tstruct resource *r = NULL;\n\tint io_port = joystick_port[dev];\n\n\tif (!io_port)\n\t\treturn -ENODEV;\n\n\tif (chip->pci->device >= 0x0010) {  \n\n\t\tif (io_port == 1) {\n\t\t\t \n\t\t\tio_port = pci_resource_start(chip->pci, 2);\n\t\t\tif (!io_port)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tif (io_port == 1) {\n\t\t\t \n\t\t\tfor (io_port = 0x201; io_port <= 0x205; io_port++) {\n\t\t\t\tif (io_port == 0x203)\n\t\t\t\t\tcontinue;\n\t\t\t\tr = request_region(io_port, 1, \"YMFPCI gameport\");\n\t\t\t\tif (r)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"no gameport ports available\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t\tswitch (io_port) {\n\t\tcase 0x201: legacy_ctrl2 |= 0 << 6; break;\n\t\tcase 0x202: legacy_ctrl2 |= 1 << 6; break;\n\t\tcase 0x204: legacy_ctrl2 |= 2 << 6; break;\n\t\tcase 0x205: legacy_ctrl2 |= 3 << 6; break;\n\t\tdefault:\n\t\t\tif (io_port > 0)\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"The %s does not support arbitrary IO ports for the game port (requested 0x%x)\\n\",\n\t\t\t\t\tchip->card->shortname, (unsigned int)io_port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = devm_request_region(&chip->pci->dev, io_port, 1,\n\t\t\t\t\t\"YMFPCI gameport\");\n\t\tif (!r) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"joystick port %#x is in use.\\n\", io_port);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tgameport_set_name(gp, \"Yamaha YMF Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->io = io_port;\n\n\tif (chip->pci->device >= 0x0010)  \n\t\tpci_write_config_word(chip->pci, PCIR_DSXG_JOYBASE, io_port);\n\n\tpci_write_config_word(chip->pci, PCIR_DSXG_LEGACY, legacy_ctrl | YMFPCI_LEGACY_JPEN);\n\tpci_write_config_word(chip->pci, PCIR_DSXG_ELEGACY, legacy_ctrl2);\n\n\tgameport_register_port(chip->gameport);\n\n\treturn 0;\n}\n\nvoid snd_ymfpci_free_gameport(struct snd_ymfpci *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_ymfpci_create_gameport(struct snd_ymfpci *chip, int dev, int l, int l2) { return -ENOSYS; }\nvoid snd_ymfpci_free_gameport(struct snd_ymfpci *chip) { }\n#endif  \n\nstatic int __snd_card_ymfpci_probe(struct pci_dev *pci,\n\t\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct resource *fm_res = NULL;\n\tstruct resource *mpu_res = NULL;\n\tstruct snd_ymfpci *chip;\n\tstruct snd_opl3 *opl3;\n\tconst char *str, *model;\n\tint err;\n\tu16 legacy_ctrl, legacy_ctrl2, old_legacy_ctrl;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tswitch (pci_id->device) {\n\tcase 0x0004: str = \"YMF724\";  model = \"DS-1\"; break;\n\tcase 0x000d: str = \"YMF724F\"; model = \"DS-1\"; break;\n\tcase 0x000a: str = \"YMF740\";  model = \"DS-1L\"; break;\n\tcase 0x000c: str = \"YMF740C\"; model = \"DS-1L\"; break;\n\tcase 0x0010: str = \"YMF744\";  model = \"DS-1S\"; break;\n\tcase 0x0012: str = \"YMF754\";  model = \"DS-1E\"; break;\n\tdefault: model = str = \"???\"; break;\n\t}\n\n\tstrcpy(card->driver, str);\n\tsprintf(card->shortname, \"Yamaha %s (%s)\", model, str);\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname,\n\t\tchip->reg_area_phys,\n\t\tchip->irq);\n\n\tlegacy_ctrl = 0;\n\tlegacy_ctrl2 = 0x0800;\t \n\n\tif (pci_id->device >= 0x0010) {  \n\t\tif (fm_port[dev] == 1) {\n\t\t\t \n\t\t\tfm_port[dev] = pci_resource_start(pci, 1);\n\t\t}\n\t\tif (fm_port[dev] > 0)\n\t\t\tfm_res = devm_request_region(&pci->dev, fm_port[dev],\n\t\t\t\t\t\t     4, \"YMFPCI OPL3\");\n\t\tif (fm_res) {\n\t\t\tlegacy_ctrl |= YMFPCI_LEGACY_FMEN;\n\t\t\tpci_write_config_word(pci, PCIR_DSXG_FMBASE, fm_port[dev]);\n\t\t}\n\t\tif (mpu_port[dev] == 1) {\n\t\t\t \n\t\t\tmpu_port[dev] = pci_resource_start(pci, 1) + 0x20;\n\t\t}\n\t\tif (mpu_port[dev] > 0)\n\t\t\tmpu_res = devm_request_region(&pci->dev, mpu_port[dev],\n\t\t\t\t\t\t      2, \"YMFPCI MPU401\");\n\t\tif (mpu_res) {\n\t\t\tlegacy_ctrl |= YMFPCI_LEGACY_MEN;\n\t\t\tpci_write_config_word(pci, PCIR_DSXG_MPU401BASE, mpu_port[dev]);\n\t\t}\n\t} else {\n\t\tswitch (fm_port[dev]) {\n\t\tcase 0x388: legacy_ctrl2 |= 0; break;\n\t\tcase 0x398: legacy_ctrl2 |= 1; break;\n\t\tcase 0x3a0: legacy_ctrl2 |= 2; break;\n\t\tcase 0x3a8: legacy_ctrl2 |= 3; break;\n\t\tdefault:\n\t\t\tif (fm_port[dev] > 0)\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"The %s does not support arbitrary IO ports for FM (requested 0x%x)\\n\",\n\t\t\t\t\tcard->shortname, (unsigned int)fm_port[dev]);\n\t\t\tfm_port[dev] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (fm_port[dev] > 0)\n\t\t\tfm_res = devm_request_region(&pci->dev, fm_port[dev],\n\t\t\t\t\t\t     4, \"YMFPCI OPL3\");\n\t\tif (fm_res) {\n\t\t\tlegacy_ctrl |= YMFPCI_LEGACY_FMEN;\n\t\t} else {\n\t\t\tlegacy_ctrl2 &= ~YMFPCI_LEGACY2_FMIO;\n\t\t\tfm_port[dev] = 0;\n\t\t}\n\t\tswitch (mpu_port[dev]) {\n\t\tcase 0x330: legacy_ctrl2 |= 0 << 4; break;\n\t\tcase 0x300: legacy_ctrl2 |= 1 << 4; break;\n\t\tcase 0x332: legacy_ctrl2 |= 2 << 4; break;\n\t\tcase 0x334: legacy_ctrl2 |= 3 << 4; break;\n\t\tdefault:\n\t\t\tif (mpu_port[dev] > 0)\n\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\"The %s does not support arbitrary IO ports for MPU-401 (requested 0x%x)\\n\",\n\t\t\t\t\tcard->shortname, (unsigned int)mpu_port[dev]);\n\t\t\tmpu_port[dev] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (mpu_port[dev] > 0)\n\t\t\tmpu_res = devm_request_region(&pci->dev, mpu_port[dev],\n\t\t\t\t\t\t      2, \"YMFPCI MPU401\");\n\t\tif (mpu_res) {\n\t\t\tlegacy_ctrl |= YMFPCI_LEGACY_MEN;\n\t\t} else {\n\t\t\tlegacy_ctrl2 &= ~YMFPCI_LEGACY2_MPUIO;\n\t\t\tmpu_port[dev] = 0;\n\t\t}\n\t}\n\tif (mpu_res) {\n\t\tlegacy_ctrl |= YMFPCI_LEGACY_MIEN;\n\t\tlegacy_ctrl2 |= YMFPCI_LEGACY2_IMOD;\n\t}\n\tpci_read_config_word(pci, PCIR_DSXG_LEGACY, &old_legacy_ctrl);\n\tpci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\n\tpci_write_config_word(pci, PCIR_DSXG_ELEGACY, legacy_ctrl2);\n\terr = snd_ymfpci_create(card, pci, old_legacy_ctrl);\n\tif (err  < 0)\n\t\treturn err;\n\n\terr = snd_ymfpci_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ymfpci_pcm_spdif(chip, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ymfpci_mixer(chip, rear_switch[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->ac97->ext_id & AC97_EI_SDAC) {\n\t\terr = snd_ymfpci_pcm_4ch(chip, 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_ymfpci_pcm2(chip, 3);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_ymfpci_timer(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mpu_res) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_YMFPCI,\n\t\t\t\t\t  mpu_port[dev],\n\t\t\t\t\t  MPU401_INFO_INTEGRATED |\n\t\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t\t  -1, &chip->rawmidi);\n\t\tif (err < 0) {\n\t\t\tdev_warn(card->dev,\n\t\t\t\t \"cannot initialize MPU401 at 0x%lx, skipping...\\n\",\n\t\t\t\t mpu_port[dev]);\n\t\t\tlegacy_ctrl &= ~YMFPCI_LEGACY_MIEN;  \n\t\t\tpci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\n\t\t}\n\t}\n\tif (fm_res) {\n\t\terr = snd_opl3_create(card,\n\t\t\t\t      fm_port[dev],\n\t\t\t\t      fm_port[dev] + 2,\n\t\t\t\t      OPL3_HW_OPL3, 1, &opl3);\n\t\tif (err < 0) {\n\t\t\tdev_warn(card->dev,\n\t\t\t\t \"cannot initialize FM OPL3 at 0x%lx, skipping...\\n\",\n\t\t\t\t fm_port[dev]);\n\t\t\tlegacy_ctrl &= ~YMFPCI_LEGACY_FMEN;\n\t\t\tpci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\n\t\t} else {\n\t\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(card->dev, \"cannot create opl3 hwdep\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_ymfpci_create_gameport(chip, dev, legacy_ctrl, legacy_ctrl2);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_card_ymfpci_probe(struct pci_dev *pci,\n\t\t\t\t const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_card_ymfpci_probe(pci, pci_id));\n}\n\nstatic struct pci_driver ymfpci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_ymfpci_ids,\n\t.probe = snd_card_ymfpci_probe,\n\t.driver = {\n\t\t.pm = pm_sleep_ptr(&snd_ymfpci_pm),\n\t},\n};\n\nmodule_pci_driver(ymfpci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}