{
  "module_name": "ymfpci_main.c",
  "hash_id": "541a8cfc5b76dbe89c5b70cc9c823036e5eafc713b3d480d779e198a54ec71c1",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ymfpci/ymfpci_main.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n#include \"ymfpci.h\"\n#include <sound/asoundef.h>\n#include <sound/mpu401.h>\n\n#include <asm/byteorder.h>\n\n \n\nstatic void snd_ymfpci_irq_wait(struct snd_ymfpci *chip);\n\nstatic inline void snd_ymfpci_writeb(struct snd_ymfpci *chip, u32 offset, u8 val)\n{\n\twriteb(val, chip->reg_area_virt + offset);\n}\n\nstatic inline u16 snd_ymfpci_readw(struct snd_ymfpci *chip, u32 offset)\n{\n\treturn readw(chip->reg_area_virt + offset);\n}\n\nstatic inline void snd_ymfpci_writew(struct snd_ymfpci *chip, u32 offset, u16 val)\n{\n\twritew(val, chip->reg_area_virt + offset);\n}\n\nstatic inline u32 snd_ymfpci_readl(struct snd_ymfpci *chip, u32 offset)\n{\n\treturn readl(chip->reg_area_virt + offset);\n}\n\nstatic inline void snd_ymfpci_writel(struct snd_ymfpci *chip, u32 offset, u32 val)\n{\n\twritel(val, chip->reg_area_virt + offset);\n}\n\nstatic int snd_ymfpci_codec_ready(struct snd_ymfpci *chip, int secondary)\n{\n\tunsigned long end_time;\n\tu32 reg = secondary ? YDSXGR_SECSTATUSADR : YDSXGR_PRISTATUSADR;\n\t\n\tend_time = jiffies + msecs_to_jiffies(750);\n\tdo {\n\t\tif ((snd_ymfpci_readw(chip, reg) & 0x8000) == 0)\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\tdev_err(chip->card->dev,\n\t\t\"codec_ready: codec %i is not ready [0x%x]\\n\",\n\t\tsecondary, snd_ymfpci_readw(chip, reg));\n\treturn -EBUSY;\n}\n\nstatic void snd_ymfpci_codec_write(struct snd_ac97 *ac97, u16 reg, u16 val)\n{\n\tstruct snd_ymfpci *chip = ac97->private_data;\n\tu32 cmd;\n\t\n\tsnd_ymfpci_codec_ready(chip, 0);\n\tcmd = ((YDSXG_AC97WRITECMD | reg) << 16) | val;\n\tsnd_ymfpci_writel(chip, YDSXGR_AC97CMDDATA, cmd);\n}\n\nstatic u16 snd_ymfpci_codec_read(struct snd_ac97 *ac97, u16 reg)\n{\n\tstruct snd_ymfpci *chip = ac97->private_data;\n\n\tif (snd_ymfpci_codec_ready(chip, 0))\n\t\treturn ~0;\n\tsnd_ymfpci_writew(chip, YDSXGR_AC97CMDADR, YDSXG_AC97READCMD | reg);\n\tif (snd_ymfpci_codec_ready(chip, 0))\n\t\treturn ~0;\n\tif (chip->device_id == PCI_DEVICE_ID_YAMAHA_744 && chip->rev < 2) {\n\t\tint i;\n\t\tfor (i = 0; i < 600; i++)\n\t\t\tsnd_ymfpci_readw(chip, YDSXGR_PRISTATUSDATA);\n\t}\n\treturn snd_ymfpci_readw(chip, YDSXGR_PRISTATUSDATA);\n}\n\n \n\nstatic u32 snd_ymfpci_calc_delta(u32 rate)\n{\n\tswitch (rate) {\n\tcase 8000:\treturn 0x02aaab00;\n\tcase 11025:\treturn 0x03accd00;\n\tcase 16000:\treturn 0x05555500;\n\tcase 22050:\treturn 0x07599a00;\n\tcase 32000:\treturn 0x0aaaab00;\n\tcase 44100:\treturn 0x0eb33300;\n\tdefault:\treturn ((rate << 16) / 375) << 5;\n\t}\n}\n\nstatic const u32 def_rate[8] = {\n\t100, 2000, 8000, 11025, 16000, 22050, 32000, 48000\n};\n\nstatic u32 snd_ymfpci_calc_lpfK(u32 rate)\n{\n\tu32 i;\n\tstatic const u32 val[8] = {\n\t\t0x00570000, 0x06AA0000, 0x18B20000, 0x20930000,\n\t\t0x2B9A0000, 0x35A10000, 0x3EAA0000, 0x40000000\n\t};\n\t\n\tif (rate == 44100)\n\t\treturn 0x40000000;\t \n\tfor (i = 0; i < 8; i++)\n\t\tif (rate <= def_rate[i])\n\t\t\treturn val[i];\n\treturn val[0];\n}\n\nstatic u32 snd_ymfpci_calc_lpfQ(u32 rate)\n{\n\tu32 i;\n\tstatic const u32 val[8] = {\n\t\t0x35280000, 0x34A70000, 0x32020000, 0x31770000,\n\t\t0x31390000, 0x31C90000, 0x33D00000, 0x40000000\n\t};\n\t\n\tif (rate == 44100)\n\t\treturn 0x370A0000;\n\tfor (i = 0; i < 8; i++)\n\t\tif (rate <= def_rate[i])\n\t\t\treturn val[i];\n\treturn val[0];\n}\n\n \n\nstatic void snd_ymfpci_hw_start(struct snd_ymfpci *chip)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->start_count++ > 0)\n\t\tgoto __end;\n\tsnd_ymfpci_writel(chip, YDSXGR_MODE,\n\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MODE) | 3);\n\tchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;\n      __end:\n      \tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_ymfpci_hw_stop(struct snd_ymfpci *chip)\n{\n\tunsigned long flags;\n\tlong timeout = 1000;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (--chip->start_count > 0)\n\t\tgoto __end;\n\tsnd_ymfpci_writel(chip, YDSXGR_MODE,\n\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MODE) & ~3);\n\twhile (timeout-- > 0) {\n\t\tif ((snd_ymfpci_readl(chip, YDSXGR_STATUS) & 2) == 0)\n\t\t\tbreak;\n\t}\n\tif (atomic_read(&chip->interrupt_sleep_count)) {\n\t\tatomic_set(&chip->interrupt_sleep_count, 0);\n\t\twake_up(&chip->interrupt_sleep);\n\t}\n      __end:\n      \tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\n \n\nstatic int voice_alloc(struct snd_ymfpci *chip,\n\t\t       enum snd_ymfpci_voice_type type, int pair,\n\t\t       struct snd_ymfpci_voice **rvoice)\n{\n\tstruct snd_ymfpci_voice *voice, *voice2;\n\tint idx;\n\t\n\t*rvoice = NULL;\n\tfor (idx = 0; idx < YDSXG_PLAYBACK_VOICES; idx += pair ? 2 : 1) {\n\t\tvoice = &chip->voices[idx];\n\t\tvoice2 = pair ? &chip->voices[idx+1] : NULL;\n\t\tif (voice->use || (voice2 && voice2->use))\n\t\t\tcontinue;\n\t\tvoice->use = 1;\n\t\tif (voice2)\n\t\t\tvoice2->use = 1;\n\t\tswitch (type) {\n\t\tcase YMFPCI_PCM:\n\t\t\tvoice->pcm = 1;\n\t\t\tif (voice2)\n\t\t\t\tvoice2->pcm = 1;\n\t\t\tbreak;\n\t\tcase YMFPCI_SYNTH:\n\t\t\tvoice->synth = 1;\n\t\t\tbreak;\n\t\tcase YMFPCI_MIDI:\n\t\t\tvoice->midi = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsnd_ymfpci_hw_start(chip);\n\t\tif (voice2)\n\t\t\tsnd_ymfpci_hw_start(chip);\n\t\t*rvoice = voice;\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\n\nstatic int snd_ymfpci_voice_alloc(struct snd_ymfpci *chip,\n\t\t\t\t  enum snd_ymfpci_voice_type type, int pair,\n\t\t\t\t  struct snd_ymfpci_voice **rvoice)\n{\n\tunsigned long flags;\n\tint result;\n\t\n\tif (snd_BUG_ON(!rvoice))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(pair && type != YMFPCI_PCM))\n\t\treturn -EINVAL;\n\t\n\tspin_lock_irqsave(&chip->voice_lock, flags);\n\tfor (;;) {\n\t\tresult = voice_alloc(chip, type, pair, rvoice);\n\t\tif (result == 0 || type != YMFPCI_PCM)\n\t\t\tbreak;\n\t\t \n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&chip->voice_lock, flags);\t\n\treturn result;\t\t\n}\n\nstatic int snd_ymfpci_voice_free(struct snd_ymfpci *chip, struct snd_ymfpci_voice *pvoice)\n{\n\tunsigned long flags;\n\t\n\tif (snd_BUG_ON(!pvoice))\n\t\treturn -EINVAL;\n\tsnd_ymfpci_hw_stop(chip);\n\tspin_lock_irqsave(&chip->voice_lock, flags);\n\tif (pvoice->number == chip->src441_used) {\n\t\tchip->src441_used = -1;\n\t\tpvoice->ypcm->use_441_slot = 0;\n\t}\n\tpvoice->use = pvoice->pcm = pvoice->synth = pvoice->midi = 0;\n\tpvoice->ypcm = NULL;\n\tpvoice->interrupt = NULL;\n\tspin_unlock_irqrestore(&chip->voice_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic void snd_ymfpci_pcm_interrupt(struct snd_ymfpci *chip, struct snd_ymfpci_voice *voice)\n{\n\tstruct snd_ymfpci_pcm *ypcm;\n\tu32 pos, delta;\n\t\n\typcm = voice->ypcm;\n\tif (!ypcm)\n\t\treturn;\n\tif (ypcm->substream == NULL)\n\t\treturn;\n\tspin_lock(&chip->reg_lock);\n\tif (ypcm->running) {\n\t\tpos = le32_to_cpu(voice->bank[chip->active_bank].start);\n\t\tif (pos < ypcm->last_pos)\n\t\t\tdelta = pos + (ypcm->buffer_size - ypcm->last_pos);\n\t\telse\n\t\t\tdelta = pos - ypcm->last_pos;\n\t\typcm->period_pos += delta;\n\t\typcm->last_pos = pos;\n\t\tif (ypcm->period_pos >= ypcm->period_size) {\n\t\t\t \n\t\t\typcm->period_pos %= ypcm->period_size;\n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(ypcm->substream);\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t}\n\n\t\tif (unlikely(ypcm->update_pcm_vol)) {\n\t\t\tunsigned int subs = ypcm->substream->number;\n\t\t\tunsigned int next_bank = 1 - chip->active_bank;\n\t\t\tstruct snd_ymfpci_playback_bank *bank;\n\t\t\t__le32 volume;\n\t\t\t\n\t\t\tbank = &voice->bank[next_bank];\n\t\t\tvolume = cpu_to_le32(chip->pcm_mixer[subs].left << 15);\n\t\t\tbank->left_gain_end = volume;\n\t\t\tif (ypcm->output_rear)\n\t\t\t\tbank->eff2_gain_end = volume;\n\t\t\tif (ypcm->voices[1])\n\t\t\t\tbank = &ypcm->voices[1]->bank[next_bank];\n\t\t\tvolume = cpu_to_le32(chip->pcm_mixer[subs].right << 15);\n\t\t\tbank->right_gain_end = volume;\n\t\t\tif (ypcm->output_rear)\n\t\t\t\tbank->eff3_gain_end = volume;\n\t\t\typcm->update_pcm_vol--;\n\t\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n}\n\nstatic void snd_ymfpci_pcm_capture_interrupt(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\tstruct snd_ymfpci *chip = ypcm->chip;\n\tu32 pos, delta;\n\t\n\tspin_lock(&chip->reg_lock);\n\tif (ypcm->running) {\n\t\tpos = le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;\n\t\tif (pos < ypcm->last_pos)\n\t\t\tdelta = pos + (ypcm->buffer_size - ypcm->last_pos);\n\t\telse\n\t\t\tdelta = pos - ypcm->last_pos;\n\t\typcm->period_pos += delta;\n\t\typcm->last_pos = pos;\n\t\tif (ypcm->period_pos >= ypcm->period_size) {\n\t\t\typcm->period_pos %= ypcm->period_size;\n\t\t\t \n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n}\n\nstatic int snd_ymfpci_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\n\tstruct snd_kcontrol *kctl = NULL;\n\tint result = 0;\n\n\tspin_lock(&chip->reg_lock);\n\tif (ypcm->voices[0] == NULL) {\n\t\tresult = -EINVAL;\n\t\tgoto __unlock;\n\t}\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->ctrl_playback[ypcm->voices[0]->number + 1] = cpu_to_le32(ypcm->voices[0]->bank_addr);\n\t\tif (ypcm->voices[1] != NULL && !ypcm->use_441_slot)\n\t\t\tchip->ctrl_playback[ypcm->voices[1]->number + 1] = cpu_to_le32(ypcm->voices[1]->bank_addr);\n\t\typcm->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (substream->pcm == chip->pcm && !ypcm->use_441_slot) {\n\t\t\tkctl = chip->pcm_mixer[substream->number].ctl;\n\t\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t}\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tchip->ctrl_playback[ypcm->voices[0]->number + 1] = 0;\n\t\tif (ypcm->voices[1] != NULL && !ypcm->use_441_slot)\n\t\t\tchip->ctrl_playback[ypcm->voices[1]->number + 1] = 0;\n\t\typcm->running = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n      __unlock:\n\tspin_unlock(&chip->reg_lock);\n\tif (kctl)\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\n\treturn result;\n}\nstatic int snd_ymfpci_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\n\tint result = 0;\n\tu32 tmp;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\ttmp = snd_ymfpci_readl(chip, YDSXGR_MAPOFREC) | (1 << ypcm->capture_bank_number);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, tmp);\n\t\typcm->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\ttmp = snd_ymfpci_readl(chip, YDSXGR_MAPOFREC) & ~(1 << ypcm->capture_bank_number);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, tmp);\n\t\typcm->running = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn result;\n}\n\nstatic int snd_ymfpci_pcm_voice_alloc(struct snd_ymfpci_pcm *ypcm, int voices)\n{\n\tint err;\n\n\tif (ypcm->voices[1] != NULL && voices < 2) {\n\t\tsnd_ymfpci_voice_free(ypcm->chip, ypcm->voices[1]);\n\t\typcm->voices[1] = NULL;\n\t}\n\tif (voices == 1 && ypcm->voices[0] != NULL)\n\t\treturn 0;\t\t \n\tif (voices == 2 && ypcm->voices[0] != NULL && ypcm->voices[1] != NULL)\n\t\treturn 0;\t\t \n\tif (voices > 1) {\n\t\tif (ypcm->voices[0] != NULL && ypcm->voices[1] == NULL) {\n\t\t\tsnd_ymfpci_voice_free(ypcm->chip, ypcm->voices[0]);\n\t\t\typcm->voices[0] = NULL;\n\t\t}\t\t\n\t}\n\terr = snd_ymfpci_voice_alloc(ypcm->chip, YMFPCI_PCM, voices > 1, &ypcm->voices[0]);\n\tif (err < 0)\n\t\treturn err;\n\typcm->voices[0]->ypcm = ypcm;\n\typcm->voices[0]->interrupt = snd_ymfpci_pcm_interrupt;\n\tif (voices > 1) {\n\t\typcm->voices[1] = &ypcm->chip->voices[ypcm->voices[0]->number + 1];\n\t\typcm->voices[1]->ypcm = ypcm;\n\t}\n\treturn 0;\n}\n\nstatic void snd_ymfpci_pcm_init_voice(struct snd_ymfpci_pcm *ypcm, unsigned int voiceidx,\n\t\t\t\t      struct snd_pcm_runtime *runtime,\n\t\t\t\t      int has_pcm_volume)\n{\n\tstruct snd_ymfpci_voice *voice = ypcm->voices[voiceidx];\n\tu32 format;\n\tu32 delta = snd_ymfpci_calc_delta(runtime->rate);\n\tu32 lpfQ = snd_ymfpci_calc_lpfQ(runtime->rate);\n\tu32 lpfK = snd_ymfpci_calc_lpfK(runtime->rate);\n\tstruct snd_ymfpci_playback_bank *bank;\n\tunsigned int nbank;\n\t__le32 vol_left, vol_right;\n\tu8 use_left, use_right;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!voice))\n\t\treturn;\n\tif (runtime->channels == 1) {\n\t\tuse_left = 1;\n\t\tuse_right = 1;\n\t} else {\n\t\tuse_left = (voiceidx & 1) == 0;\n\t\tuse_right = !use_left;\n\t}\n\tif (has_pcm_volume) {\n\t\tvol_left = cpu_to_le32(ypcm->chip->pcm_mixer\n\t\t\t\t       [ypcm->substream->number].left << 15);\n\t\tvol_right = cpu_to_le32(ypcm->chip->pcm_mixer\n\t\t\t\t\t[ypcm->substream->number].right << 15);\n\t} else {\n\t\tvol_left = cpu_to_le32(0x40000000);\n\t\tvol_right = cpu_to_le32(0x40000000);\n\t}\n\tspin_lock_irqsave(&ypcm->chip->voice_lock, flags);\n\tformat = runtime->channels == 2 ? 0x00010000 : 0;\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tformat |= 0x80000000;\n\telse if (ypcm->chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&\n\t\t runtime->rate == 44100 && runtime->channels == 2 &&\n\t\t voiceidx == 0 && (ypcm->chip->src441_used == -1 ||\n\t\t\t\t   ypcm->chip->src441_used == voice->number)) {\n\t\typcm->chip->src441_used = voice->number;\n\t\typcm->use_441_slot = 1;\n\t\tformat |= 0x10000000;\n\t}\n\tif (ypcm->chip->src441_used == voice->number &&\n\t    (format & 0x10000000) == 0) {\n\t\typcm->chip->src441_used = -1;\n\t\typcm->use_441_slot = 0;\n\t}\n\tif (runtime->channels == 2 && (voiceidx & 1) != 0)\n\t\tformat |= 1;\n\tspin_unlock_irqrestore(&ypcm->chip->voice_lock, flags);\n\tfor (nbank = 0; nbank < 2; nbank++) {\n\t\tbank = &voice->bank[nbank];\n\t\tmemset(bank, 0, sizeof(*bank));\n\t\tbank->format = cpu_to_le32(format);\n\t\tbank->base = cpu_to_le32(runtime->dma_addr);\n\t\tbank->loop_end = cpu_to_le32(ypcm->buffer_size);\n\t\tbank->lpfQ = cpu_to_le32(lpfQ);\n\t\tbank->delta =\n\t\tbank->delta_end = cpu_to_le32(delta);\n\t\tbank->lpfK =\n\t\tbank->lpfK_end = cpu_to_le32(lpfK);\n\t\tbank->eg_gain =\n\t\tbank->eg_gain_end = cpu_to_le32(0x40000000);\n\n\t\tif (ypcm->output_front) {\n\t\t\tif (use_left) {\n\t\t\t\tbank->left_gain =\n\t\t\t\tbank->left_gain_end = vol_left;\n\t\t\t}\n\t\t\tif (use_right) {\n\t\t\t\tbank->right_gain =\n\t\t\t\tbank->right_gain_end = vol_right;\n\t\t\t}\n\t\t}\n\t\tif (ypcm->output_rear) {\n\t\t        if (!ypcm->swap_rear) {\n        \t\t\tif (use_left) {\n        \t\t\t\tbank->eff2_gain =\n        \t\t\t\tbank->eff2_gain_end = vol_left;\n        \t\t\t}\n        \t\t\tif (use_right) {\n        \t\t\t\tbank->eff3_gain =\n        \t\t\t\tbank->eff3_gain_end = vol_right;\n        \t\t\t}\n\t\t        } else {\n        \t\t\t \n        \t\t\tif (use_left) {\n        \t\t\t\tbank->eff3_gain =\n        \t\t\t\tbank->eff3_gain_end = vol_left;\n        \t\t\t}\n        \t\t\tif (use_right) {\n        \t\t\t\tbank->eff2_gain =\n        \t\t\t\tbank->eff2_gain_end = vol_right;\n        \t\t\t}\n        \t\t}\n                }\n\t}\n}\n\nstatic int snd_ymfpci_ac3_init(struct snd_ymfpci *chip)\n{\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t4096, &chip->ac3_tmp_base) < 0)\n\t\treturn -ENOMEM;\n\n\tchip->bank_effect[3][0]->base =\n\tchip->bank_effect[3][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr);\n\tchip->bank_effect[3][0]->loop_end =\n\tchip->bank_effect[3][1]->loop_end = cpu_to_le32(1024);\n\tchip->bank_effect[4][0]->base =\n\tchip->bank_effect[4][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr + 2048);\n\tchip->bank_effect[4][0]->loop_end =\n\tchip->bank_effect[4][1]->loop_end = cpu_to_le32(1024);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT,\n\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MAPOFEFFECT) | 3 << 3);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_ac3_done(struct snd_ymfpci *chip)\n{\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT,\n\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MAPOFEFFECT) & ~(3 << 3));\n\tspin_unlock_irq(&chip->reg_lock);\n\t \n\tif (chip->ac3_tmp_base.area) {\n\t\tsnd_dma_free_pages(&chip->ac3_tmp_base);\n\t\tchip->ac3_tmp_base.area = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\tint err;\n\n\terr = snd_ymfpci_pcm_voice_alloc(ypcm, params_channels(hw_params));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\t\n\tif (runtime->private_data == NULL)\n\t\treturn 0;\n\typcm = runtime->private_data;\n\n\t \n\tsnd_ymfpci_irq_wait(chip);\n\tif (ypcm->voices[1]) {\n\t\tsnd_ymfpci_voice_free(chip, ypcm->voices[1]);\n\t\typcm->voices[1] = NULL;\n\t}\n\tif (ypcm->voices[0]) {\n\t\tsnd_ymfpci_voice_free(chip, ypcm->voices[0]);\n\t\typcm->voices[0] = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int nvoice;\n\n\typcm->period_size = runtime->period_size;\n\typcm->buffer_size = runtime->buffer_size;\n\typcm->period_pos = 0;\n\typcm->last_pos = 0;\n\tfor (nvoice = 0; nvoice < runtime->channels; nvoice++)\n\t\tsnd_ymfpci_pcm_init_voice(ypcm, nvoice, runtime,\n\t\t\t\t\t  substream->pcm == chip->pcm);\n\n\tif (substream->pcm == chip->pcm && !ypcm->use_441_slot) {\n\t\tkctl = chip->pcm_mixer[substream->number].ctl;\n\t\tkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\n\t}\n\treturn 0;\n}\n\nstatic int snd_ymfpci_capture_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\n\t \n\tsnd_ymfpci_irq_wait(chip);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\tstruct snd_ymfpci_capture_bank * bank;\n\tint nbank;\n\tu32 rate, format;\n\n\typcm->period_size = runtime->period_size;\n\typcm->buffer_size = runtime->buffer_size;\n\typcm->period_pos = 0;\n\typcm->last_pos = 0;\n\typcm->shift = 0;\n\trate = ((48000 * 4096) / runtime->rate) - 1;\n\tformat = 0;\n\tif (runtime->channels == 2) {\n\t\tformat |= 2;\n\t\typcm->shift++;\n\t}\n\tif (snd_pcm_format_width(runtime->format) == 8)\n\t\tformat |= 1;\n\telse\n\t\typcm->shift++;\n\tswitch (ypcm->capture_bank_number) {\n\tcase 0:\n\t\tsnd_ymfpci_writel(chip, YDSXGR_RECFORMAT, format);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_RECSLOTSR, rate);\n\t\tbreak;\n\tcase 1:\n\t\tsnd_ymfpci_writel(chip, YDSXGR_ADCFORMAT, format);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_ADCSLOTSR, rate);\n\t\tbreak;\n\t}\n\tfor (nbank = 0; nbank < 2; nbank++) {\n\t\tbank = chip->bank_capture[ypcm->capture_bank_number][nbank];\n\t\tbank->base = cpu_to_le32(runtime->dma_addr);\n\t\tbank->loop_end = cpu_to_le32(ypcm->buffer_size << ypcm->shift);\n\t\tbank->start = 0;\n\t\tbank->num_of_loops = 0;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_ymfpci_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\tstruct snd_ymfpci_voice *voice = ypcm->voices[0];\n\n\tif (!(ypcm->running && voice))\n\t\treturn 0;\n\treturn le32_to_cpu(voice->bank[chip->active_bank].start);\n}\n\nstatic snd_pcm_uframes_t snd_ymfpci_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\n\tif (!ypcm->running)\n\t\treturn 0;\n\treturn le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;\n}\n\nstatic void snd_ymfpci_irq_wait(struct snd_ymfpci *chip)\n{\n\twait_queue_entry_t wait;\n\tint loops = 4;\n\n\twhile (loops-- > 0) {\n\t\tif ((snd_ymfpci_readl(chip, YDSXGR_MODE) & 3) == 0)\n\t\t \tcontinue;\n\t\tinit_waitqueue_entry(&wait, current);\n\t\tadd_wait_queue(&chip->interrupt_sleep, &wait);\n\t\tatomic_inc(&chip->interrupt_sleep_count);\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(50));\n\t\tremove_wait_queue(&chip->interrupt_sleep, &wait);\n\t}\n}\n\nstatic irqreturn_t snd_ymfpci_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_ymfpci *chip = dev_id;\n\tu32 status, nvoice, mode;\n\tstruct snd_ymfpci_voice *voice;\n\n\tstatus = snd_ymfpci_readl(chip, YDSXGR_STATUS);\n\tif (status & 0x80000000) {\n\t\tchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;\n\t\tspin_lock(&chip->voice_lock);\n\t\tfor (nvoice = 0; nvoice < YDSXG_PLAYBACK_VOICES; nvoice++) {\n\t\t\tvoice = &chip->voices[nvoice];\n\t\t\tif (voice->interrupt)\n\t\t\t\tvoice->interrupt(chip, voice);\n\t\t}\n\t\tfor (nvoice = 0; nvoice < YDSXG_CAPTURE_VOICES; nvoice++) {\n\t\t\tif (chip->capture_substream[nvoice])\n\t\t\t\tsnd_ymfpci_pcm_capture_interrupt(chip->capture_substream[nvoice]);\n\t\t}\n#if 0\n\t\tfor (nvoice = 0; nvoice < YDSXG_EFFECT_VOICES; nvoice++) {\n\t\t\tif (chip->effect_substream[nvoice])\n\t\t\t\tsnd_ymfpci_pcm_effect_interrupt(chip->effect_substream[nvoice]);\n\t\t}\n#endif\n\t\tspin_unlock(&chip->voice_lock);\n\t\tspin_lock(&chip->reg_lock);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_STATUS, 0x80000000);\n\t\tmode = snd_ymfpci_readl(chip, YDSXGR_MODE) | 2;\n\t\tsnd_ymfpci_writel(chip, YDSXGR_MODE, mode);\n\t\tspin_unlock(&chip->reg_lock);\n\n\t\tif (atomic_read(&chip->interrupt_sleep_count)) {\n\t\t\tatomic_set(&chip->interrupt_sleep_count, 0);\n\t\t\twake_up(&chip->interrupt_sleep);\n\t\t}\n\t}\n\n\tstatus = snd_ymfpci_readw(chip, YDSXGR_INTFLAG);\n\tif (status & 1) {\n\t\tif (chip->timer)\n\t\t\tsnd_timer_interrupt(chip->timer, chip->timer_ticks);\n\t}\n\tsnd_ymfpci_writew(chip, YDSXGR_INTFLAG, status);\n\n\tif (chip->rawmidi)\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rawmidi->private_data);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware snd_ymfpci_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | \n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t256 * 1024,  \n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t256 * 1024,  \n\t.periods_min =\t\t3,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ymfpci_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t256 * 1024,  \n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t256 * 1024,  \n\t.periods_min =\t\t3,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic void snd_ymfpci_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic int snd_ymfpci_playback_open_1(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\tint err;\n\n\truntime->hw = snd_ymfpci_playback;\n\t \n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   5334, UINT_MAX);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_noresample(runtime, 48000);\n\tif (err < 0)\n\t\treturn err;\n\n\typcm = kzalloc(sizeof(*ypcm), GFP_KERNEL);\n\tif (ypcm == NULL)\n\t\treturn -ENOMEM;\n\typcm->chip = chip;\n\typcm->type = PLAYBACK_VOICE;\n\typcm->substream = substream;\n\truntime->private_data = ypcm;\n\truntime->private_free = snd_ymfpci_pcm_free_substream;\n\treturn 0;\n}\n\n \nstatic void ymfpci_open_extension(struct snd_ymfpci *chip)\n{\n\tif (! chip->rear_opened) {\n\t\tif (! chip->spdif_opened)  \n\t\t\tsnd_ymfpci_writel(chip, YDSXGR_MODE,\n\t\t\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MODE) | (1 << 30));\n\t\t \n\t\tsnd_ymfpci_writew(chip, YDSXGR_SECCONFIG,\n\t\t\t\t  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) | 0x0010);\n\t}\n}\n\n \nstatic void ymfpci_close_extension(struct snd_ymfpci *chip)\n{\n\tif (! chip->rear_opened) {\n\t\tif (! chip->spdif_opened)\n\t\t\tsnd_ymfpci_writel(chip, YDSXGR_MODE,\n\t\t\t\t\t  snd_ymfpci_readl(chip, YDSXGR_MODE) & ~(1 << 30));\n\t\tsnd_ymfpci_writew(chip, YDSXGR_SECCONFIG,\n\t\t\t\t  (snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) & ~0x0010);\n\t}\n}\n\nstatic int snd_ymfpci_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\tint err;\n\t\n\terr = snd_ymfpci_playback_open_1(substream);\n\tif (err < 0)\n\t\treturn err;\n\typcm = runtime->private_data;\n\typcm->output_front = 1;\n\typcm->output_rear = chip->mode_dup4ch ? 1 : 0;\n\typcm->swap_rear = 0;\n\tspin_lock_irq(&chip->reg_lock);\n\tif (ypcm->output_rear) {\n\t\tymfpci_open_extension(chip);\n\t\tchip->rear_opened++;\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\tint err;\n\t\n\terr = snd_ymfpci_playback_open_1(substream);\n\tif (err < 0)\n\t\treturn err;\n\typcm = runtime->private_data;\n\typcm->output_front = 0;\n\typcm->output_rear = 1;\n\typcm->swap_rear = 1;\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,\n\t\t\t  snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) | 2);\n\tymfpci_open_extension(chip);\n\tchip->spdif_pcm_bits = chip->spdif_bits;\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);\n\tchip->spdif_opened++;\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tchip->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_4ch_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\tint err;\n\t\n\terr = snd_ymfpci_playback_open_1(substream);\n\tif (err < 0)\n\t\treturn err;\n\typcm = runtime->private_data;\n\typcm->output_front = 0;\n\typcm->output_rear = 1;\n\typcm->swap_rear = 0;\n\tspin_lock_irq(&chip->reg_lock);\n\tymfpci_open_extension(chip);\n\tchip->rear_opened++;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_capture_open(struct snd_pcm_substream *substream,\n\t\t\t\t   u32 capture_bank_number)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm;\n\tint err;\n\n\truntime->hw = snd_ymfpci_capture;\n\t \n\terr = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\t\t\t\t   5334, UINT_MAX);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_noresample(runtime, 48000);\n\tif (err < 0)\n\t\treturn err;\n\n\typcm = kzalloc(sizeof(*ypcm), GFP_KERNEL);\n\tif (ypcm == NULL)\n\t\treturn -ENOMEM;\n\typcm->chip = chip;\n\typcm->type = capture_bank_number + CAPTURE_REC;\n\typcm->substream = substream;\t\n\typcm->capture_bank_number = capture_bank_number;\n\tchip->capture_substream[capture_bank_number] = substream;\n\truntime->private_data = ypcm;\n\truntime->private_free = snd_ymfpci_pcm_free_substream;\n\tsnd_ymfpci_hw_start(chip);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_capture_rec_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_ymfpci_capture_open(substream, 0);\n}\n\nstatic int snd_ymfpci_capture_ac97_open(struct snd_pcm_substream *substream)\n{\n\treturn snd_ymfpci_capture_open(substream, 1);\n}\n\nstatic int snd_ymfpci_playback_close_1(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int snd_ymfpci_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tif (ypcm->output_rear && chip->rear_opened > 0) {\n\t\tchip->rear_opened--;\n\t\tymfpci_close_extension(chip);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn snd_ymfpci_playback_close_1(substream);\n}\n\nstatic int snd_ymfpci_playback_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->spdif_opened = 0;\n\tymfpci_close_extension(chip);\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,\n\t\t\t  snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & ~2);\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\n\tspin_unlock_irq(&chip->reg_lock);\n\tchip->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);\n\treturn snd_ymfpci_playback_close_1(substream);\n}\n\nstatic int snd_ymfpci_playback_4ch_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tif (chip->rear_opened > 0) {\n\t\tchip->rear_opened--;\n\t\tymfpci_close_extension(chip);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn snd_ymfpci_playback_close_1(substream);\n}\n\nstatic int snd_ymfpci_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\n\n\tif (ypcm != NULL) {\n\t\tchip->capture_substream[ypcm->capture_bank_number] = NULL;\n\t\tsnd_ymfpci_hw_stop(chip);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ymfpci_playback_ops = {\n\t.open =\t\t\tsnd_ymfpci_playback_open,\n\t.close =\t\tsnd_ymfpci_playback_close,\n\t.hw_params =\t\tsnd_ymfpci_playback_hw_params,\n\t.hw_free =\t\tsnd_ymfpci_playback_hw_free,\n\t.prepare =\t\tsnd_ymfpci_playback_prepare,\n\t.trigger =\t\tsnd_ymfpci_playback_trigger,\n\t.pointer =\t\tsnd_ymfpci_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ymfpci_capture_rec_ops = {\n\t.open =\t\t\tsnd_ymfpci_capture_rec_open,\n\t.close =\t\tsnd_ymfpci_capture_close,\n\t.hw_free =\t\tsnd_ymfpci_capture_hw_free,\n\t.prepare =\t\tsnd_ymfpci_capture_prepare,\n\t.trigger =\t\tsnd_ymfpci_capture_trigger,\n\t.pointer =\t\tsnd_ymfpci_capture_pointer,\n};\n\nint snd_ymfpci_pcm(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"YMFPCI\", device, 32, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ymfpci_capture_rec_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"YMFPCI\");\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 256*1024);\n\n\treturn snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_std_chmaps, 2, 0, NULL);\n}\n\nstatic const struct snd_pcm_ops snd_ymfpci_capture_ac97_ops = {\n\t.open =\t\t\tsnd_ymfpci_capture_ac97_open,\n\t.close =\t\tsnd_ymfpci_capture_close,\n\t.hw_free =\t\tsnd_ymfpci_capture_hw_free,\n\t.prepare =\t\tsnd_ymfpci_capture_prepare,\n\t.trigger =\t\tsnd_ymfpci_capture_trigger,\n\t.pointer =\t\tsnd_ymfpci_capture_pointer,\n};\n\nint snd_ymfpci_pcm2(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"YMFPCI - PCM2\", device, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ymfpci_capture_ac97_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tsprintf(pcm->name, \"YMFPCI - %s\",\n\t\tchip->device_id == PCI_DEVICE_ID_YAMAHA_754 ? \"Direct Recording\" : \"AC'97\");\n\tchip->pcm2 = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 256*1024);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ymfpci_playback_spdif_ops = {\n\t.open =\t\t\tsnd_ymfpci_playback_spdif_open,\n\t.close =\t\tsnd_ymfpci_playback_spdif_close,\n\t.hw_params =\t\tsnd_ymfpci_playback_hw_params,\n\t.hw_free =\t\tsnd_ymfpci_playback_hw_free,\n\t.prepare =\t\tsnd_ymfpci_playback_prepare,\n\t.trigger =\t\tsnd_ymfpci_playback_trigger,\n\t.pointer =\t\tsnd_ymfpci_playback_pointer,\n};\n\nint snd_ymfpci_pcm_spdif(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"YMFPCI - IEC958\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_spdif_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"YMFPCI - IEC958\");\n\tchip->pcm_spdif = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 256*1024);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ymfpci_playback_4ch_ops = {\n\t.open =\t\t\tsnd_ymfpci_playback_4ch_open,\n\t.close =\t\tsnd_ymfpci_playback_4ch_close,\n\t.hw_params =\t\tsnd_ymfpci_playback_hw_params,\n\t.hw_free =\t\tsnd_ymfpci_playback_hw_free,\n\t.prepare =\t\tsnd_ymfpci_playback_prepare,\n\t.trigger =\t\tsnd_ymfpci_playback_trigger,\n\t.pointer =\t\tsnd_ymfpci_playback_pointer,\n};\n\nstatic const struct snd_pcm_chmap_elem surround_map[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nint snd_ymfpci_pcm_4ch(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"YMFPCI - Rear\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_4ch_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"YMFPCI - Rear PCM\");\n\tchip->pcm_4ch = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 256*1024);\n\n\treturn snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     surround_map, 2, 0, NULL);\n}\n\nstatic int snd_ymfpci_spdif_default_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tucontrol->value.iec958.status[0] = (chip->spdif_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (chip->spdif_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ((ucontrol->value.iec958.status[0] & 0x3e) << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8);\n\tspin_lock_irq(&chip->reg_lock);\n\tchange = chip->spdif_bits != val;\n\tchip->spdif_bits = val;\n\tif ((snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & 1) && chip->pcm_spdif == NULL)\n\t\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_spdif_default =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_ymfpci_spdif_default_info,\n\t.get =\t\tsnd_ymfpci_spdif_default_get,\n\t.put =\t\tsnd_ymfpci_spdif_default_put\n};\n\nstatic int snd_ymfpci_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tucontrol->value.iec958.status[0] = 0x3e;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_spdif_mask =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tsnd_ymfpci_spdif_mask_info,\n\t.get =\t\tsnd_ymfpci_spdif_mask_get,\n};\n\nstatic int snd_ymfpci_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tucontrol->value.iec958.status[0] = (chip->spdif_pcm_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (chip->spdif_pcm_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_spdif_stream_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ((ucontrol->value.iec958.status[0] & 0x3e) << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8);\n\tspin_lock_irq(&chip->reg_lock);\n\tchange = chip->spdif_pcm_bits != val;\n\tchip->spdif_pcm_bits = val;\n\tif ((snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & 2))\n\t\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_spdif_stream =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_ymfpci_spdif_stream_info,\n\t.get =\t\tsnd_ymfpci_spdif_stream_get,\n\t.put =\t\tsnd_ymfpci_spdif_stream_put\n};\n\nstatic int snd_ymfpci_drec_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const texts[3] = {\"AC'97\", \"IEC958\", \"ZV Port\"};\n\n\treturn snd_ctl_enum_info(info, 1, 3, texts);\n}\n\nstatic int snd_ymfpci_drec_source_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *value)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tu16 reg;\n\n\tspin_lock_irq(&chip->reg_lock);\n\treg = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\n\tspin_unlock_irq(&chip->reg_lock);\n\tif (!(reg & 0x100))\n\t\tvalue->value.enumerated.item[0] = 0;\n\telse\n\t\tvalue->value.enumerated.item[0] = 1 + ((reg & 0x200) != 0);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_drec_source_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *value)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tu16 reg, old_reg;\n\n\tspin_lock_irq(&chip->reg_lock);\n\told_reg = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\n\tif (value->value.enumerated.item[0] == 0)\n\t\treg = old_reg & ~0x100;\n\telse\n\t\treg = (old_reg & ~0x300) | 0x100 | ((value->value.enumerated.item[0] == 2) << 9);\n\tsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, reg);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn reg != old_reg;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_drec_source = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Direct Recording Source\",\n\t.info =\t\tsnd_ymfpci_drec_source_info,\n\t.get =\t\tsnd_ymfpci_drec_source_get,\n\t.put =\t\tsnd_ymfpci_drec_source_put\n};\n\n \n\n#define YMFPCI_SINGLE(xname, xindex, reg, shift) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_ymfpci_info_single, \\\n  .get = snd_ymfpci_get_single, .put = snd_ymfpci_put_single, \\\n  .private_value = ((reg) | ((shift) << 16)) }\n\n#define snd_ymfpci_info_single\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ymfpci_get_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xffff;\n\tunsigned int shift = (kcontrol->private_value >> 16) & 0xff;\n\tunsigned int mask = 1;\n\t\n\tswitch (reg) {\n\tcase YDSXGR_SPDIFOUTCTRL: break;\n\tcase YDSXGR_SPDIFINCTRL: break;\n\tdefault: return -EINVAL;\n\t}\n\tucontrol->value.integer.value[0] =\n\t\t(snd_ymfpci_readl(chip, reg) >> shift) & mask;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_put_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xffff;\n\tunsigned int shift = (kcontrol->private_value >> 16) & 0xff;\n \tunsigned int mask = 1;\n\tint change;\n\tunsigned int val, oval;\n\t\n\tswitch (reg) {\n\tcase YDSXGR_SPDIFOUTCTRL: break;\n\tcase YDSXGR_SPDIFINCTRL: break;\n\tdefault: return -EINVAL;\n\t}\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tval <<= shift;\n\tspin_lock_irq(&chip->reg_lock);\n\toval = snd_ymfpci_readl(chip, reg);\n\tval = (oval & ~(mask << shift)) | val;\n\tchange = val != oval;\n\tsnd_ymfpci_writel(chip, reg, val);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_LINEAR(db_scale_native, TLV_DB_GAIN_MUTE, 0);\n\n#define YMFPCI_DOUBLE(xname, xindex, reg) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .info = snd_ymfpci_info_double, \\\n  .get = snd_ymfpci_get_double, .put = snd_ymfpci_put_double, \\\n  .private_value = reg, \\\n  .tlv = { .p = db_scale_native } }\n\nstatic int snd_ymfpci_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int reg = kcontrol->private_value;\n\n\tif (reg < 0x80 || reg >= 0xc0)\n\t\treturn -EINVAL;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 16383;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = kcontrol->private_value;\n\tunsigned int shift_left = 0, shift_right = 16, mask = 16383;\n\tunsigned int val;\n\t\n\tif (reg < 0x80 || reg >= 0xc0)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&chip->reg_lock);\n\tval = snd_ymfpci_readl(chip, reg);\n\tspin_unlock_irq(&chip->reg_lock);\n\tucontrol->value.integer.value[0] = (val >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (val >> shift_right) & mask;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = kcontrol->private_value;\n\tunsigned int shift_left = 0, shift_right = 16, mask = 16383;\n\tint change;\n\tunsigned int val1, val2, oval;\n\t\n\tif (reg < 0x80 || reg >= 0xc0)\n\t\treturn -EINVAL;\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irq(&chip->reg_lock);\n\toval = snd_ymfpci_readl(chip, reg);\n\tval1 = (oval & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\n\tchange = val1 != oval;\n\tsnd_ymfpci_writel(chip, reg, val1);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic int snd_ymfpci_put_nativedacvol(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = YDSXGR_NATIVEDACOUTVOL;\n\tunsigned int reg2 = YDSXGR_BUF441OUTVOL;\n\tint change;\n\tunsigned int value, oval;\n\t\n\tvalue = ucontrol->value.integer.value[0] & 0x3fff;\n\tvalue |= (ucontrol->value.integer.value[1] & 0x3fff) << 16;\n\tspin_lock_irq(&chip->reg_lock);\n\toval = snd_ymfpci_readl(chip, reg);\n\tchange = value != oval;\n\tsnd_ymfpci_writel(chip, reg, value);\n\tsnd_ymfpci_writel(chip, reg2, value);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\n \n#define snd_ymfpci_info_dup4ch\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ymfpci_get_dup4ch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = chip->mode_dup4ch;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_put_dup4ch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tchange = (ucontrol->value.integer.value[0] != chip->mode_dup4ch);\n\tif (change)\n\t\tchip->mode_dup4ch = !!ucontrol->value.integer.value[0];\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_dup4ch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"4ch Duplication\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_ymfpci_info_dup4ch,\n\t.get = snd_ymfpci_get_dup4ch,\n\t.put = snd_ymfpci_put_dup4ch,\n};\n\nstatic const struct snd_kcontrol_new snd_ymfpci_controls[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Wave Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_ymfpci_info_double,\n\t.get = snd_ymfpci_get_double,\n\t.put = snd_ymfpci_put_nativedacvol,\n\t.private_value = YDSXGR_NATIVEDACOUTVOL,\n\t.tlv = { .p = db_scale_native },\n},\nYMFPCI_DOUBLE(\"Wave Capture Volume\", 0, YDSXGR_NATIVEDACLOOPVOL),\nYMFPCI_DOUBLE(\"Digital Capture Volume\", 0, YDSXGR_NATIVEDACINVOL),\nYMFPCI_DOUBLE(\"Digital Capture Volume\", 1, YDSXGR_NATIVEADCINVOL),\nYMFPCI_DOUBLE(\"ADC Playback Volume\", 0, YDSXGR_PRIADCOUTVOL),\nYMFPCI_DOUBLE(\"ADC Capture Volume\", 0, YDSXGR_PRIADCLOOPVOL),\nYMFPCI_DOUBLE(\"ADC Playback Volume\", 1, YDSXGR_SECADCOUTVOL),\nYMFPCI_DOUBLE(\"ADC Capture Volume\", 1, YDSXGR_SECADCLOOPVOL),\nYMFPCI_DOUBLE(\"FM Legacy Playback Volume\", 0, YDSXGR_LEGACYOUTVOL),\nYMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958(\"AC97 \", PLAYBACK,VOLUME), 0, YDSXGR_ZVOUTVOL),\nYMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958(\"\", CAPTURE,VOLUME), 0, YDSXGR_ZVLOOPVOL),\nYMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958(\"AC97 \",PLAYBACK,VOLUME), 1, YDSXGR_SPDIFOUTVOL),\nYMFPCI_DOUBLE(SNDRV_CTL_NAME_IEC958(\"\",CAPTURE,VOLUME), 1, YDSXGR_SPDIFLOOPVOL),\nYMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,SWITCH), 0, YDSXGR_SPDIFOUTCTRL, 0),\nYMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958(\"\",CAPTURE,SWITCH), 0, YDSXGR_SPDIFINCTRL, 0),\nYMFPCI_SINGLE(SNDRV_CTL_NAME_IEC958(\"Loop\",NONE,NONE), 0, YDSXGR_SPDIFINCTRL, 4),\n};\n\n\n \n\nstatic int snd_ymfpci_get_gpio_out(struct snd_ymfpci *chip, int pin)\n{\n\tu16 reg, mode;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\treg = snd_ymfpci_readw(chip, YDSXGR_GPIOFUNCENABLE);\n\treg &= ~(1 << (pin + 8));\n\treg |= (1 << pin);\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg);\n\t \n\tmode = snd_ymfpci_readw(chip, YDSXGR_GPIOTYPECONFIG);\n\tmode &= ~(3 << (pin * 2));\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOTYPECONFIG, mode);\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg | (1 << (pin + 8)));\n\tmode = snd_ymfpci_readw(chip, YDSXGR_GPIOINSTATUS);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn (mode >> pin) & 1;\n}\n\nstatic int snd_ymfpci_set_gpio_out(struct snd_ymfpci *chip, int pin, int enable)\n{\n\tu16 reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\treg = snd_ymfpci_readw(chip, YDSXGR_GPIOFUNCENABLE);\n\treg &= ~(1 << pin);\n\treg &= ~(1 << (pin + 8));\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg);\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOOUTCTRL, enable << pin);\n\tsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg | (1 << (pin + 8)));\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn 0;\n}\n\n#define snd_ymfpci_gpio_sw_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ymfpci_gpio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tint pin = (int)kcontrol->private_value;\n\tucontrol->value.integer.value[0] = snd_ymfpci_get_gpio_out(chip, pin);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_gpio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tint pin = (int)kcontrol->private_value;\n\n\tif (snd_ymfpci_get_gpio_out(chip, pin) != ucontrol->value.integer.value[0]) {\n\t\tsnd_ymfpci_set_gpio_out(chip, pin, !!ucontrol->value.integer.value[0]);\n\t\tucontrol->value.integer.value[0] = snd_ymfpci_get_gpio_out(chip, pin);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_rear_shared = {\n\t.name = \"Shared Rear/Line-In Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_ymfpci_gpio_sw_info,\n\t.get = snd_ymfpci_gpio_sw_get,\n\t.put = snd_ymfpci_gpio_sw_put,\n\t.private_value = 2,\n};\n\n \n\nstatic int snd_ymfpci_pcm_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x8000;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_pcm_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int subs = kcontrol->id.subdevice;\n\n\tucontrol->value.integer.value[0] = chip->pcm_mixer[subs].left;\n\tucontrol->value.integer.value[1] = chip->pcm_mixer[subs].right;\n\treturn 0;\n}\n\nstatic int snd_ymfpci_pcm_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int subs = kcontrol->id.subdevice;\n\tstruct snd_pcm_substream *substream;\n\tunsigned long flags;\n\n\tif (ucontrol->value.integer.value[0] != chip->pcm_mixer[subs].left ||\n\t    ucontrol->value.integer.value[1] != chip->pcm_mixer[subs].right) {\n\t\tchip->pcm_mixer[subs].left = ucontrol->value.integer.value[0];\n\t\tchip->pcm_mixer[subs].right = ucontrol->value.integer.value[1];\n\t\tif (chip->pcm_mixer[subs].left > 0x8000)\n\t\t\tchip->pcm_mixer[subs].left = 0x8000;\n\t\tif (chip->pcm_mixer[subs].right > 0x8000)\n\t\t\tchip->pcm_mixer[subs].right = 0x8000;\n\n\t\tsubstream = (struct snd_pcm_substream *)kcontrol->private_value;\n\t\tspin_lock_irqsave(&chip->voice_lock, flags);\n\t\tif (substream->runtime && substream->runtime->private_data) {\n\t\t\tstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\n\t\t\tif (!ypcm->use_441_slot)\n\t\t\t\typcm->update_pcm_vol = 2;\n\t\t}\n\t\tspin_unlock_irqrestore(&chip->voice_lock, flags);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ymfpci_pcm_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"PCM Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.info = snd_ymfpci_pcm_vol_info,\n\t.get = snd_ymfpci_pcm_vol_get,\n\t.put = snd_ymfpci_pcm_vol_put,\n};\n\n\n \n\nstatic void snd_ymfpci_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct snd_ymfpci *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_ymfpci_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct snd_ymfpci *chip = ac97->private_data;\n\tchip->ac97 = NULL;\n}\n\nint snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch)\n{\n\tstruct snd_ac97_template ac97;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_pcm_substream *substream;\n\tunsigned int idx;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_ymfpci_codec_write,\n\t\t.read = snd_ymfpci_codec_read,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;\n\tchip->ac97_bus->no_vra = 1;  \n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_ymfpci_mixer_free_ac97;\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS,\n\t\t\t     AC97_EA_VRA|AC97_EA_VRM, 0);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_ymfpci_controls); idx++) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->ac97->ext_id & AC97_EI_SDAC) {\n\t\tkctl = snd_ctl_new1(&snd_ymfpci_dup4ch, chip);\n\t\terr = snd_ctl_add(chip->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (snd_BUG_ON(!chip->pcm_spdif))\n\t\treturn -ENXIO;\n\tkctl = snd_ctl_new1(&snd_ymfpci_spdif_default, chip);\n\tkctl->id.device = chip->pcm_spdif->device;\n\terr = snd_ctl_add(chip->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_ymfpci_spdif_mask, chip);\n\tkctl->id.device = chip->pcm_spdif->device;\n\terr = snd_ctl_add(chip->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_ymfpci_spdif_stream, chip);\n\tkctl->id.device = chip->pcm_spdif->device;\n\terr = snd_ctl_add(chip->card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tchip->spdif_pcm_ctl = kctl;\n\n\t \n\tif (chip->device_id == PCI_DEVICE_ID_YAMAHA_754) {\n\t\tkctl = snd_ctl_new1(&snd_ymfpci_drec_source, chip);\n\t\terr = snd_ctl_add(chip->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (rear_switch) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_rear_shared, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tsubstream = chip->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\tfor (idx = 0; idx < 32; ++idx) {\n\t\tkctl = snd_ctl_new1(&snd_ymfpci_pcm_volume, chip);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.device = chip->pcm->device;\n\t\tkctl->id.subdevice = idx;\n\t\tkctl->private_value = (unsigned long)substream;\n\t\terr = snd_ctl_add(chip->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->pcm_mixer[idx].left = 0x8000;\n\t\tchip->pcm_mixer[idx].right = 0x8000;\n\t\tchip->pcm_mixer[idx].ctl = kctl;\n\t\tsubstream = substream->next;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int snd_ymfpci_timer_start(struct snd_timer *timer)\n{\n\tstruct snd_ymfpci *chip;\n\tunsigned long flags;\n\tunsigned int count;\n\n\tchip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (timer->sticks > 1) {\n\t\tchip->timer_ticks = timer->sticks;\n\t\tcount = timer->sticks - 1;\n\t} else {\n\t\t \n\t\tchip->timer_ticks = 2;\n\t\tcount = 2 - 1;\n\t}\n\tsnd_ymfpci_writew(chip, YDSXGR_TIMERCOUNT, count);\n\tsnd_ymfpci_writeb(chip, YDSXGR_TIMERCTRL, 0x03);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_timer_stop(struct snd_timer *timer)\n{\n\tstruct snd_ymfpci *chip;\n\tunsigned long flags;\n\n\tchip = snd_timer_chip(timer);\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_ymfpci_writeb(chip, YDSXGR_TIMERCTRL, 0x00);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_timer_precise_resolution(struct snd_timer *timer,\n\t\t\t\t\t       unsigned long *num, unsigned long *den)\n{\n\t*num = 1;\n\t*den = 96000;\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_ymfpci_timer_hw = {\n\t.flags = SNDRV_TIMER_HW_AUTO,\n\t.resolution = 10417,  \n\t.ticks = 0x10000,\n\t.start = snd_ymfpci_timer_start,\n\t.stop = snd_ymfpci_timer_stop,\n\t.precise_resolution = snd_ymfpci_timer_precise_resolution,\n};\n\nint snd_ymfpci_timer(struct snd_ymfpci *chip, int device)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = chip->card->number;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\terr = snd_timer_new(chip->card, \"YMFPCI\", &tid, &timer);\n\tif (err >= 0) {\n\t\tstrcpy(timer->name, \"YMFPCI timer\");\n\t\ttimer->private_data = chip;\n\t\ttimer->hw = snd_ymfpci_timer_hw;\n\t}\n\tchip->timer = timer;\n\treturn err;\n}\n\n\n \n\nstatic void snd_ymfpci_proc_read(struct snd_info_entry *entry, \n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_ymfpci *chip = entry->private_data;\n\tint i;\n\t\n\tsnd_iprintf(buffer, \"YMFPCI\\n\\n\");\n\tfor (i = 0; i <= YDSXGR_WORKBASE; i += 4)\n\t\tsnd_iprintf(buffer, \"%04x: %04x\\n\", i, snd_ymfpci_readl(chip, i));\n}\n\nstatic int snd_ymfpci_proc_init(struct snd_card *card, struct snd_ymfpci *chip)\n{\n\treturn snd_card_ro_proc_new(card, \"ymfpci\", chip, snd_ymfpci_proc_read);\n}\n\n \n\nstatic void snd_ymfpci_aclink_reset(struct pci_dev * pci)\n{\n\tu8 cmd;\n\n\tpci_read_config_byte(pci, PCIR_DSXG_CTRL, &cmd);\n#if 0  \n\tif (cmd & 0x03) {\n#endif\n\t\tpci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd & 0xfc);\n\t\tpci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd | 0x03);\n\t\tpci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd & 0xfc);\n\t\tpci_write_config_word(pci, PCIR_DSXG_PWRCTRL1, 0);\n\t\tpci_write_config_word(pci, PCIR_DSXG_PWRCTRL2, 0);\n#if 0\n\t}\n#endif\n}\n\nstatic void snd_ymfpci_enable_dsp(struct snd_ymfpci *chip)\n{\n\tsnd_ymfpci_writel(chip, YDSXGR_CONFIG, 0x00000001);\n}\n\nstatic void snd_ymfpci_disable_dsp(struct snd_ymfpci *chip)\n{\n\tu32 val;\n\tint timeout = 1000;\n\n\tval = snd_ymfpci_readl(chip, YDSXGR_CONFIG);\n\tif (val)\n\t\tsnd_ymfpci_writel(chip, YDSXGR_CONFIG, 0x00000000);\n\twhile (timeout-- > 0) {\n\t\tval = snd_ymfpci_readl(chip, YDSXGR_STATUS);\n\t\tif ((val & 0x00000002) == 0)\n\t\t\tbreak;\n\t}\n}\n\nstatic int snd_ymfpci_request_firmware(struct snd_ymfpci *chip)\n{\n\tint err, is_1e;\n\tconst char *name;\n\n\terr = request_firmware(&chip->dsp_microcode, \"yamaha/ds1_dsp.fw\",\n\t\t\t       &chip->pci->dev);\n\tif (err >= 0) {\n\t\tif (chip->dsp_microcode->size != YDSXG_DSPLENGTH) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"DSP microcode has wrong size\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\tis_1e = chip->device_id == PCI_DEVICE_ID_YAMAHA_724F ||\n\t\tchip->device_id == PCI_DEVICE_ID_YAMAHA_740C ||\n\t\tchip->device_id == PCI_DEVICE_ID_YAMAHA_744 ||\n\t\tchip->device_id == PCI_DEVICE_ID_YAMAHA_754;\n\tname = is_1e ? \"yamaha/ds1e_ctrl.fw\" : \"yamaha/ds1_ctrl.fw\";\n\terr = request_firmware(&chip->controller_microcode, name,\n\t\t\t       &chip->pci->dev);\n\tif (err >= 0) {\n\t\tif (chip->controller_microcode->size != YDSXG_CTRLLENGTH) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"controller microcode has wrong size\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"yamaha/ds1_dsp.fw\");\nMODULE_FIRMWARE(\"yamaha/ds1_ctrl.fw\");\nMODULE_FIRMWARE(\"yamaha/ds1e_ctrl.fw\");\n\nstatic void snd_ymfpci_download_image(struct snd_ymfpci *chip)\n{\n\tint i;\n\tu16 ctrl;\n\tconst __le32 *inst;\n\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0x00000000);\n\tsnd_ymfpci_disable_dsp(chip);\n\tsnd_ymfpci_writel(chip, YDSXGR_MODE, 0x00010000);\n\tsnd_ymfpci_writel(chip, YDSXGR_MODE, 0x00000000);\n\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, 0x00000000);\n\tsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT, 0x00000000);\n\tsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, 0x00000000);\n\tsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, 0x00000000);\n\tsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, 0x00000000);\n\tctrl = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\n\tsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);\n\n\t \n\tinst = (const __le32 *)chip->dsp_microcode->data;\n\tfor (i = 0; i < YDSXG_DSPLENGTH / 4; i++)\n\t\tsnd_ymfpci_writel(chip, YDSXGR_DSPINSTRAM + (i << 2),\n\t\t\t\t  le32_to_cpu(inst[i]));\n\n\t \n\tinst = (const __le32 *)chip->controller_microcode->data;\n\tfor (i = 0; i < YDSXG_CTRLLENGTH / 4; i++)\n\t\tsnd_ymfpci_writel(chip, YDSXGR_CTRLINSTRAM + (i << 2),\n\t\t\t\t  le32_to_cpu(inst[i]));\n\n\tsnd_ymfpci_enable_dsp(chip);\n}\n\nstatic int snd_ymfpci_memalloc(struct snd_ymfpci *chip)\n{\n\tlong size, playback_ctrl_size;\n\tint voice, bank, reg;\n\tu8 *ptr;\n\tdma_addr_t ptr_addr;\n\n\tplayback_ctrl_size = 4 + 4 * YDSXG_PLAYBACK_VOICES;\n\tchip->bank_size_playback = snd_ymfpci_readl(chip, YDSXGR_PLAYCTRLSIZE) << 2;\n\tchip->bank_size_capture = snd_ymfpci_readl(chip, YDSXGR_RECCTRLSIZE) << 2;\n\tchip->bank_size_effect = snd_ymfpci_readl(chip, YDSXGR_EFFCTRLSIZE) << 2;\n\tchip->work_size = YDSXG_DEFAULT_WORK_SIZE;\n\t\n\tsize = ALIGN(playback_ctrl_size, 0x100) +\n\t       ALIGN(chip->bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES, 0x100) +\n\t       ALIGN(chip->bank_size_capture * 2 * YDSXG_CAPTURE_VOICES, 0x100) +\n\t       ALIGN(chip->bank_size_effect * 2 * YDSXG_EFFECT_VOICES, 0x100) +\n\t       chip->work_size;\n\t \n\tchip->work_ptr = snd_devm_alloc_pages(&chip->pci->dev,\n\t\t\t\t\t      SNDRV_DMA_TYPE_DEV, size);\n\tif (!chip->work_ptr)\n\t\treturn -ENOMEM;\n\tptr = chip->work_ptr->area;\n\tptr_addr = chip->work_ptr->addr;\n\tmemset(ptr, 0, size);\t \n\n\tchip->bank_base_playback = ptr;\n\tchip->bank_base_playback_addr = ptr_addr;\n\tchip->ctrl_playback = (__le32 *)ptr;\n\tchip->ctrl_playback[0] = cpu_to_le32(YDSXG_PLAYBACK_VOICES);\n\tptr += ALIGN(playback_ctrl_size, 0x100);\n\tptr_addr += ALIGN(playback_ctrl_size, 0x100);\n\tfor (voice = 0; voice < YDSXG_PLAYBACK_VOICES; voice++) {\n\t\tchip->voices[voice].number = voice;\n\t\tchip->voices[voice].bank = (struct snd_ymfpci_playback_bank *)ptr;\n\t\tchip->voices[voice].bank_addr = ptr_addr;\n\t\tfor (bank = 0; bank < 2; bank++) {\n\t\t\tchip->bank_playback[voice][bank] = (struct snd_ymfpci_playback_bank *)ptr;\n\t\t\tptr += chip->bank_size_playback;\n\t\t\tptr_addr += chip->bank_size_playback;\n\t\t}\n\t}\n\tptr = (char *)ALIGN((unsigned long)ptr, 0x100);\n\tptr_addr = ALIGN(ptr_addr, 0x100);\n\tchip->bank_base_capture = ptr;\n\tchip->bank_base_capture_addr = ptr_addr;\n\tfor (voice = 0; voice < YDSXG_CAPTURE_VOICES; voice++)\n\t\tfor (bank = 0; bank < 2; bank++) {\n\t\t\tchip->bank_capture[voice][bank] = (struct snd_ymfpci_capture_bank *)ptr;\n\t\t\tptr += chip->bank_size_capture;\n\t\t\tptr_addr += chip->bank_size_capture;\n\t\t}\n\tptr = (char *)ALIGN((unsigned long)ptr, 0x100);\n\tptr_addr = ALIGN(ptr_addr, 0x100);\n\tchip->bank_base_effect = ptr;\n\tchip->bank_base_effect_addr = ptr_addr;\n\tfor (voice = 0; voice < YDSXG_EFFECT_VOICES; voice++)\n\t\tfor (bank = 0; bank < 2; bank++) {\n\t\t\tchip->bank_effect[voice][bank] = (struct snd_ymfpci_effect_bank *)ptr;\n\t\t\tptr += chip->bank_size_effect;\n\t\t\tptr_addr += chip->bank_size_effect;\n\t\t}\n\tptr = (char *)ALIGN((unsigned long)ptr, 0x100);\n\tptr_addr = ALIGN(ptr_addr, 0x100);\n\tchip->work_base = ptr;\n\tchip->work_base_addr = ptr_addr;\n\t\n\tsnd_BUG_ON(ptr + PAGE_ALIGN(chip->work_size) !=\n\t\t   chip->work_ptr->area + chip->work_ptr->bytes);\n\n\tsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, chip->bank_base_playback_addr);\n\tsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, chip->bank_base_capture_addr);\n\tsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, chip->bank_base_effect_addr);\n\tsnd_ymfpci_writel(chip, YDSXGR_WORKBASE, chip->work_base_addr);\n\tsnd_ymfpci_writel(chip, YDSXGR_WORKSIZE, chip->work_size >> 2);\n\n\t \n\tchip->spdif_bits = chip->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF & 0xffff;\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL, 0);\n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\n\n\t \n\tsnd_ymfpci_writew(chip, YDSXGR_SPDIFINCTRL, 0);\n\n\t \n\tfor (reg = 0x80; reg < 0xc0; reg += 4)\n\t\tsnd_ymfpci_writel(chip, reg, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_ZVOUTVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_SPDIFOUTVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEADCINVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACINVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_PRIADCLOOPVOL, 0x3fff3fff);\n\tsnd_ymfpci_writel(chip, YDSXGR_LEGACYOUTVOL, 0x3fff3fff);\n\t\n\treturn 0;\n}\n\nstatic void snd_ymfpci_free(struct snd_card *card)\n{\n\tstruct snd_ymfpci *chip = card->private_data;\n\tu16 ctrl;\n\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_LEGACYOUTVOL, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_STATUS, ~0);\n\tsnd_ymfpci_disable_dsp(chip);\n\tsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_WORKBASE, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_WORKSIZE, 0);\n\tctrl = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\n\tsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);\n\n\tsnd_ymfpci_ac3_done(chip);\n\n\tsnd_ymfpci_free_gameport(chip);\n\t\n\tpci_write_config_word(chip->pci, PCIR_DSXG_LEGACY, chip->old_legacy_ctrl);\n\t\n\trelease_firmware(chip->dsp_microcode);\n\trelease_firmware(chip->controller_microcode);\n}\n\nstatic int snd_ymfpci_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ymfpci *chip = card->private_data;\n\tunsigned int i, legacy_reg_count = DSXG_PCI_NUM_SAVED_LEGACY_REGS;\n\n\tif (chip->pci->device >= 0x0010)  \n\t\tlegacy_reg_count = DSXG_PCI_NUM_SAVED_REGS;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\n\tfor (i = 0; i < YDSXGR_NUM_SAVED_REGS; i++)\n\t\tchip->saved_regs[i] = snd_ymfpci_readl(chip, saved_regs_index[i]);\n\n\tchip->saved_ydsxgr_mode = snd_ymfpci_readl(chip, YDSXGR_MODE);\n\n\tfor (i = 0; i < legacy_reg_count; i++)\n\t\tpci_read_config_word(chip->pci, pci_saved_regs_index[i],\n\t\t\t\t      chip->saved_dsxg_pci_regs + i);\n\n\tsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);\n\tsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0);\n\tsnd_ymfpci_disable_dsp(chip);\n\treturn 0;\n}\n\nstatic int snd_ymfpci_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ymfpci *chip = card->private_data;\n\tunsigned int i, legacy_reg_count = DSXG_PCI_NUM_SAVED_LEGACY_REGS;\n\n\tif (chip->pci->device >= 0x0010)  \n\t\tlegacy_reg_count = DSXG_PCI_NUM_SAVED_REGS;\n\n\tsnd_ymfpci_aclink_reset(pci);\n\tsnd_ymfpci_codec_ready(chip, 0);\n\tsnd_ymfpci_download_image(chip);\n\tudelay(100);\n\n\tfor (i = 0; i < YDSXGR_NUM_SAVED_REGS; i++)\n\t\tsnd_ymfpci_writel(chip, saved_regs_index[i], chip->saved_regs[i]);\n\n\tsnd_ac97_resume(chip->ac97);\n\n\tfor (i = 0; i < legacy_reg_count; i++)\n\t\tpci_write_config_word(chip->pci, pci_saved_regs_index[i],\n\t\t\t\t      chip->saved_dsxg_pci_regs[i]);\n\n\t \n\tif (chip->start_count > 0) {\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\tsnd_ymfpci_writel(chip, YDSXGR_MODE, chip->saved_ydsxgr_mode);\n\t\tchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT);\n\t\tspin_unlock_irq(&chip->reg_lock);\n\t}\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nDEFINE_SIMPLE_DEV_PM_OPS(snd_ymfpci_pm, snd_ymfpci_suspend, snd_ymfpci_resume);\n\nint snd_ymfpci_create(struct snd_card *card,\n\t\t      struct pci_dev *pci,\n\t\t      u16 old_legacy_ctrl)\n{\n\tstruct snd_ymfpci *chip = card->private_data;\n\tint err;\n\t\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->old_legacy_ctrl = old_legacy_ctrl;\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->voice_lock);\n\tinit_waitqueue_head(&chip->interrupt_sleep);\n\tatomic_set(&chip->interrupt_sleep_count, 0);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->device_id = pci->device;\n\tchip->rev = pci->revision;\n\n\terr = pci_request_regions(pci, \"YMFPCI\");\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->reg_area_phys = pci_resource_start(pci, 0);\n\tchip->reg_area_virt = devm_ioremap(&pci->dev, chip->reg_area_phys, 0x8000);\n\tif (!chip->reg_area_virt) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"unable to grab memory region 0x%lx-0x%lx\\n\",\n\t\t\tchip->reg_area_phys, chip->reg_area_phys + 0x8000 - 1);\n\t\treturn -EBUSY;\n\t}\n\tpci_set_master(pci);\n\tchip->src441_used = -1;\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_ymfpci_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, chip)) {\n\t\tdev_err(chip->card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_ymfpci_free;\n\n\tsnd_ymfpci_aclink_reset(pci);\n\tif (snd_ymfpci_codec_ready(chip, 0) < 0)\n\t\treturn -EIO;\n\n\terr = snd_ymfpci_request_firmware(chip);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"firmware request failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\tsnd_ymfpci_download_image(chip);\n\n\tudelay(100);  \n\n\tif (snd_ymfpci_memalloc(chip) < 0)\n\t\treturn -EIO;\n\n\terr = snd_ymfpci_ac3_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_ymfpci_proc_init(card, chip);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}