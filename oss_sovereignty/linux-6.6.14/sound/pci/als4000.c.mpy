{
  "module_name": "als4000.c",
  "hash_id": "5f0e2fde1d373b6c147b9eb61ef9602bcc5413547d4a91f14fe163f94fb25e8d",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/als4000.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/sb.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Bart Hartgers <bart@etpmod.phys.tue.nl>, Andreas Mohr\");\nMODULE_DESCRIPTION(\"Avance Logic ALS4000\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n#ifdef SUPPORT_JOYSTICK\nstatic int joystick_port[SNDRV_CARDS];\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ALS4000 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ALS4000 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ALS4000 soundcard.\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_hw_array(joystick_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(joystick_port, \"Joystick port address for ALS4000 soundcard. (0 = disabled)\");\n#endif\n\nstruct snd_card_als4000 {\n\t \n\tunsigned long iobase;\n\tstruct pci_dev *pci;\n\tstruct snd_sb *chip;\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n};\n\nstatic const struct pci_device_id snd_als4000_ids[] = {\n\t{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_als4000_ids);\n\nenum als4k_iobase_t {\n\t \n\tALS4K_IOD_00_AC97_ACCESS = 0x00,\n\tALS4K_IOW_04_AC97_READ = 0x04,\n\tALS4K_IOB_06_AC97_STATUS = 0x06,\n\tALS4K_IOB_07_IRQSTATUS = 0x07,\n\tALS4K_IOD_08_GCR_DATA = 0x08,\n\tALS4K_IOB_0C_GCR_INDEX = 0x0c,\n\tALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU = 0x0e,\n\tALS4K_IOB_10_ADLIB_ADDR0 = 0x10,\n\tALS4K_IOB_11_ADLIB_ADDR1 = 0x11,\n\tALS4K_IOB_12_ADLIB_ADDR2 = 0x12,\n\tALS4K_IOB_13_ADLIB_ADDR3 = 0x13,\n\tALS4K_IOB_14_MIXER_INDEX = 0x14,\n\tALS4K_IOB_15_MIXER_DATA = 0x15,\n\tALS4K_IOB_16_ESP_RESET = 0x16,\n\tALS4K_IOB_16_ACK_FOR_CR1E = 0x16,  \n\tALS4K_IOB_18_OPL_ADDR0 = 0x18,\n\tALS4K_IOB_19_OPL_ADDR1 = 0x19,\n\tALS4K_IOB_1A_ESP_RD_DATA = 0x1a,\n\tALS4K_IOB_1C_ESP_CMD_DATA = 0x1c,\n\tALS4K_IOB_1C_ESP_WR_STATUS = 0x1c,  \n\tALS4K_IOB_1E_ESP_RD_STATUS8 = 0x1e,\n\tALS4K_IOB_1F_ESP_RD_STATUS16 = 0x1f,\n\tALS4K_IOB_20_ESP_GAMEPORT_200 = 0x20,\n\tALS4K_IOB_21_ESP_GAMEPORT_201 = 0x21,\n\tALS4K_IOB_30_MIDI_DATA = 0x30,\n\tALS4K_IOB_31_MIDI_STATUS = 0x31,\n\tALS4K_IOB_31_MIDI_COMMAND = 0x31,  \n};\n\nenum als4k_iobase_0e_t {\n\tALS4K_IOB_0E_MPU_IRQ = 0x10,\n\tALS4K_IOB_0E_CR1E_IRQ = 0x40,\n\tALS4K_IOB_0E_SB_DMA_IRQ = 0x80,\n};\n\nenum als4k_gcr_t {  \n\tALS4K_GCR8C_MISC_CTRL = 0x8c,\n\tALS4K_GCR90_TEST_MODE_REG = 0x90,\n\tALS4K_GCR91_DMA0_ADDR = 0x91,\n\tALS4K_GCR92_DMA0_MODE_COUNT = 0x92,\n\tALS4K_GCR93_DMA1_ADDR = 0x93,\n\tALS4K_GCR94_DMA1_MODE_COUNT = 0x94,\n\tALS4K_GCR95_DMA3_ADDR = 0x95,\n\tALS4K_GCR96_DMA3_MODE_COUNT = 0x96,\n\tALS4K_GCR99_DMA_EMULATION_CTRL = 0x99,\n\tALS4K_GCRA0_FIFO1_CURRENT_ADDR = 0xa0,\n\tALS4K_GCRA1_FIFO1_STATUS_BYTECOUNT = 0xa1,\n\tALS4K_GCRA2_FIFO2_PCIADDR = 0xa2,\n\tALS4K_GCRA3_FIFO2_COUNT = 0xa3,\n\tALS4K_GCRA4_FIFO2_CURRENT_ADDR = 0xa4,\n\tALS4K_GCRA5_FIFO1_STATUS_BYTECOUNT = 0xa5,\n\tALS4K_GCRA6_PM_CTRL = 0xa6,\n\tALS4K_GCRA7_PCI_ACCESS_STORAGE = 0xa7,\n\tALS4K_GCRA8_LEGACY_CFG1 = 0xa8,\n\tALS4K_GCRA9_LEGACY_CFG2 = 0xa9,\n\tALS4K_GCRFF_DUMMY_SCRATCH = 0xff,\n};\n\nenum als4k_gcr8c_t {\n\tALS4K_GCR8C_IRQ_MASK_CTRL_ENABLE = 0x8000,\n\tALS4K_GCR8C_CHIP_REV_MASK = 0xf0000\n};\n\nstatic inline void snd_als4k_iobase_writeb(unsigned long iobase,\n\t\t\t\t\t\tenum als4k_iobase_t reg,\n\t\t\t\t\t\tu8 val)\n{\n\toutb(val, iobase + reg);\n}\n\nstatic inline void snd_als4k_iobase_writel(unsigned long iobase,\n\t\t\t\t\t\tenum als4k_iobase_t reg,\n\t\t\t\t\t\tu32 val)\n{\n\toutl(val, iobase + reg);\n}\n\nstatic inline u8 snd_als4k_iobase_readb(unsigned long iobase,\n\t\t\t\t\t\tenum als4k_iobase_t reg)\n{\n\treturn inb(iobase + reg);\n}\n\nstatic inline u32 snd_als4k_iobase_readl(unsigned long iobase,\n\t\t\t\t\t\tenum als4k_iobase_t reg)\n{\n\treturn inl(iobase + reg);\n}\n\nstatic inline void snd_als4k_gcr_write_addr(unsigned long iobase,\n\t\t\t\t\t\t enum als4k_gcr_t reg,\n\t\t\t\t\t\t u32 val)\n{\n\tsnd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);\n\tsnd_als4k_iobase_writel(iobase, ALS4K_IOD_08_GCR_DATA, val);\n}\n\nstatic inline void snd_als4k_gcr_write(struct snd_sb *sb,\n\t\t\t\t\t enum als4k_gcr_t reg,\n\t\t\t\t\t u32 val)\n{\n\tsnd_als4k_gcr_write_addr(sb->alt_port, reg, val);\n}\t\n\nstatic inline u32 snd_als4k_gcr_read_addr(unsigned long iobase,\n\t\t\t\t\t\t enum als4k_gcr_t reg)\n{\n\t \n\tsnd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);\n\treturn snd_als4k_iobase_readl(iobase, ALS4K_IOD_08_GCR_DATA);\n}\n\nstatic inline u32 snd_als4k_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)\n{\n\treturn snd_als4k_gcr_read_addr(sb->alt_port, reg);\n}\n\nenum als4k_cr_t {  \n\tALS4K_CR0_SB_CONFIG = 0x00,\n\tALS4K_CR2_MISC_CONTROL = 0x02,\n\tALS4K_CR3_CONFIGURATION = 0x03,\n\tALS4K_CR17_FIFO_STATUS = 0x17,\n\tALS4K_CR18_ESP_MAJOR_VERSION = 0x18,\n\tALS4K_CR19_ESP_MINOR_VERSION = 0x19,\n\tALS4K_CR1A_MPU401_UART_MODE_CONTROL = 0x1a,\n\tALS4K_CR1C_FIFO2_BLOCK_LENGTH_LO = 0x1c,\n\tALS4K_CR1D_FIFO2_BLOCK_LENGTH_HI = 0x1d,\n\tALS4K_CR1E_FIFO2_CONTROL = 0x1e,  \n\tALS4K_CR3A_MISC_CONTROL = 0x3a,\n\tALS4K_CR3B_CRC32_BYTE0 = 0x3b,  \n\tALS4K_CR3C_CRC32_BYTE1 = 0x3c,\n\tALS4K_CR3D_CRC32_BYTE2 = 0x3d,\n\tALS4K_CR3E_CRC32_BYTE3 = 0x3e,\n};\n\nenum als4k_cr0_t {\n\tALS4K_CR0_DMA_CONTIN_MODE_CTRL = 0x02,  \n\tALS4K_CR0_DMA_90H_MODE_CTRL = 0x04,  \n\tALS4K_CR0_MX80_81_REG_WRITE_ENABLE = 0x80,\n};\n\nstatic inline void snd_als4_cr_write(struct snd_sb *chip,\n\t\t\t\t\tenum als4k_cr_t reg,\n\t\t\t\t\tu8 data)\n{\n\t \n\tsnd_sbmixer_write(chip, reg | 0xc0, data);\n}\n\nstatic inline u8 snd_als4_cr_read(struct snd_sb *chip,\n\t\t\t\t\tenum als4k_cr_t reg)\n{\n\t \n\treturn snd_sbmixer_read(chip, reg | 0xc0);\n}\n\n\n\nstatic void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)\n{\n\tif (!(chip->mode & SB_RATE_LOCK)) {\n\t\tsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);\n\t\tsnd_sbdsp_command(chip, rate>>8);\n\t\tsnd_sbdsp_command(chip, rate);\n\t}\n}\n\nstatic inline void snd_als4000_set_capture_dma(struct snd_sb *chip,\n\t\t\t\t\t       dma_addr_t addr, unsigned size)\n{\n\t \n\tsnd_als4k_gcr_write(chip, ALS4K_GCRA2_FIFO2_PCIADDR, addr);\n\tsnd_als4k_gcr_write(chip, ALS4K_GCRA3_FIFO2_COUNT, (size-1));\n}\n\nstatic inline void snd_als4000_set_playback_dma(struct snd_sb *chip,\n\t\t\t\t\t\tdma_addr_t addr,\n\t\t\t\t\t\tunsigned size)\n{\n\t \n\tsnd_als4k_gcr_write(chip, ALS4K_GCR91_DMA0_ADDR, addr);\n\tsnd_als4k_gcr_write(chip, ALS4K_GCR92_DMA0_MODE_COUNT,\n\t\t\t\t\t\t\t(size-1)|0x180000);\n}\n\n#define ALS4000_FORMAT_SIGNED\t(1<<0)\n#define ALS4000_FORMAT_16BIT\t(1<<1)\n#define ALS4000_FORMAT_STEREO\t(1<<2)\n\nstatic int snd_als4000_get_format(struct snd_pcm_runtime *runtime)\n{\n\tint result;\n\n\tresult = 0;\n\tif (snd_pcm_format_signed(runtime->format))\n\t\tresult |= ALS4000_FORMAT_SIGNED;\n\tif (snd_pcm_format_physical_width(runtime->format) == 16)\n\t\tresult |= ALS4000_FORMAT_16BIT;\n\tif (runtime->channels > 1)\n\t\tresult |= ALS4000_FORMAT_STEREO;\n\treturn result;\n}\n\n \nstatic const struct {\n\tunsigned char dsp_cmd, dma_on, dma_off, format;\n} playback_cmd_vals[]={\n \n{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_UNS_MONO },\n \t\n{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_SIGN_MONO },\n \n{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_UNS_MONO },\n \n{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_SIGN_MONO },\n \n{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_UNS_STEREO },\n \t\n{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_SIGN_STEREO },\n \n{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_UNS_STEREO },\n \n{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_SIGN_STEREO },\n};\n#define playback_cmd(chip) (playback_cmd_vals[(chip)->playback_format])\n\n \nenum { CMD_WIDTH8=0x04, CMD_SIGNED=0x10, CMD_MONO=0x80, CMD_STEREO=0xA0 };\nstatic const unsigned char capture_cmd_vals[]=\n{\nCMD_WIDTH8|CMD_MONO,\t\t\t \nCMD_WIDTH8|CMD_SIGNED|CMD_MONO,\t\t \t\nCMD_MONO,\t\t\t\t \nCMD_SIGNED|CMD_MONO,\t\t\t \nCMD_WIDTH8|CMD_STEREO,\t\t\t \nCMD_WIDTH8|CMD_SIGNED|CMD_STEREO,\t \t\nCMD_STEREO,\t\t\t\t \nCMD_SIGNED|CMD_STEREO,\t\t\t \n};\t\n#define capture_cmd(chip) (capture_cmd_vals[(chip)->capture_format])\n\nstatic int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long size;\n\tunsigned count;\n\n\tchip->capture_format = snd_als4000_get_format(runtime);\n\t\t\n\tsize = snd_pcm_lib_buffer_bytes(substream);\n\tcount = snd_pcm_lib_period_bytes(substream);\n\t\n\tif (chip->capture_format & ALS4000_FORMAT_16BIT)\n\t\tcount >>= 1;\n\tcount--;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_als4000_set_rate(chip, runtime->rate);\n\tsnd_als4000_set_capture_dma(chip, runtime->dma_addr, size);\n\tspin_unlock_irq(&chip->reg_lock);\n\tspin_lock_irq(&chip->mixer_lock);\n\tsnd_als4_cr_write(chip, ALS4K_CR1C_FIFO2_BLOCK_LENGTH_LO, count & 0xff);\n\tsnd_als4_cr_write(chip, ALS4K_CR1D_FIFO2_BLOCK_LENGTH_HI, count >> 8);\n\tspin_unlock_irq(&chip->mixer_lock);\n\treturn 0;\n}\n\nstatic int snd_als4000_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long size;\n\tunsigned count;\n\n\tchip->playback_format = snd_als4000_get_format(runtime);\n\t\n\tsize = snd_pcm_lib_buffer_bytes(substream);\n\tcount = snd_pcm_lib_period_bytes(substream);\n\t\n\tif (chip->playback_format & ALS4000_FORMAT_16BIT)\n\t\tcount >>= 1;\n\tcount--;\n\t\n\t \n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_als4000_set_rate(chip, runtime->rate);\n\tsnd_als4000_set_playback_dma(chip, runtime->dma_addr, size);\n\t\n\t \n\t \n\tsnd_sbdsp_command(chip, playback_cmd(chip).dsp_cmd);\n\tsnd_sbdsp_command(chip, playback_cmd(chip).format);\n\tsnd_sbdsp_command(chip, count & 0xff);\n\tsnd_sbdsp_command(chip, count >> 8);\n\tsnd_sbdsp_command(chip, playback_cmd(chip).dma_off);\t\n\tspin_unlock_irq(&chip->reg_lock);\n\t\n\treturn 0;\n}\n\nstatic int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\t\n\t \n\tspin_lock(&chip->mixer_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->mode |= SB_RATE_LOCK_CAPTURE;\n\t\tsnd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,\n\t\t\t\t\t\t\t capture_cmd(chip));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tchip->mode &= ~SB_RATE_LOCK_CAPTURE;\n\t\tsnd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,\n\t\t\t\t\t\t\t capture_cmd(chip));\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->mixer_lock);\n\treturn result;\n}\n\nstatic int snd_als4000_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->mode |= SB_RATE_LOCK_PLAYBACK;\n\t\tsnd_sbdsp_command(chip, playback_cmd(chip).dma_on);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tsnd_sbdsp_command(chip, playback_cmd(chip).dma_off);\n\t\tchip->mode &= ~SB_RATE_LOCK_PLAYBACK;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t snd_als4000_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned int result;\n\n\tspin_lock(&chip->reg_lock);\t\n\tresult = snd_als4k_gcr_read(chip, ALS4K_GCRA4_FIFO2_CURRENT_ADDR);\n\tspin_unlock(&chip->reg_lock);\n\tresult &= 0xffff;\n\treturn bytes_to_frames( substream->runtime, result );\n}\n\nstatic snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tunsigned result;\n\n\tspin_lock(&chip->reg_lock);\t\n\tresult = snd_als4k_gcr_read(chip, ALS4K_GCRA0_FIFO1_CURRENT_ADDR);\n\tspin_unlock(&chip->reg_lock);\n\tresult &= 0xffff;\n\treturn bytes_to_frames( substream->runtime, result );\n}\n\n \nstatic irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_sb *chip = dev_id;\n\tunsigned pci_irqstatus;\n\tunsigned sb_irqstatus;\n\n\t \n\tpci_irqstatus = snd_als4k_iobase_readb(chip->alt_port,\n\t\t\t\t ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU);\n\tif ((pci_irqstatus & ALS4K_IOB_0E_SB_DMA_IRQ)\n\t && (chip->playback_substream))  \n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\tif ((pci_irqstatus & ALS4K_IOB_0E_CR1E_IRQ)\n\t && (chip->capture_substream))  \n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\tif ((pci_irqstatus & ALS4K_IOB_0E_MPU_IRQ)\n\t && (chip->rmidi))  \n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\t \n\tsnd_als4k_iobase_writeb(chip->alt_port,\n\t\t\t ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU, pci_irqstatus);\n\t\n\tspin_lock(&chip->mixer_lock);\n\t \n\tsb_irqstatus = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);\n\tspin_unlock(&chip->mixer_lock);\n\t\n\tif (sb_irqstatus & SB_IRQTYPE_8BIT)\n\t\tsnd_sb_ack_8bit(chip);\n\tif (sb_irqstatus & SB_IRQTYPE_16BIT)\n\t\tsnd_sb_ack_16bit(chip);\n\tif (sb_irqstatus & SB_IRQTYPE_MPUIN)\n\t\tinb(chip->mpu_port);\n\tif (sb_irqstatus & ALS4K_IRQTYPE_CR1E_DMA)\n\t\tsnd_als4k_iobase_readb(chip->alt_port,\n\t\t\t\t\tALS4K_IOB_16_ACK_FOR_CR1E);\n\n\t \n\n\t \n\treturn IRQ_RETVAL(\n\t     (pci_irqstatus & (ALS4K_IOB_0E_SB_DMA_IRQ|ALS4K_IOB_0E_CR1E_IRQ|\n\t\t\t\tALS4K_IOB_0E_MPU_IRQ))\n\t  || (sb_irqstatus & (SB_IRQTYPE_8BIT|SB_IRQTYPE_16BIT|\n\t\t\t\tSB_IRQTYPE_MPUIN|ALS4K_IRQTYPE_CR1E_DMA))\n\t);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_als4000_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE,\t \n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0\n};\n\nstatic const struct snd_pcm_hardware snd_als4000_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE,\t \n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t65536,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0\n};\n\n \n\nstatic int snd_als4000_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tchip->playback_substream = substream;\n\truntime->hw = snd_als4000_playback;\n\treturn 0;\n}\n\nstatic int snd_als4000_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_als4000_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tchip->capture_substream = substream;\n\truntime->hw = snd_als4000_capture;\n\treturn 0;\n}\n\nstatic int snd_als4000_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sb *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_ops snd_als4000_playback_ops = {\n\t.open =\t\tsnd_als4000_playback_open,\n\t.close =\tsnd_als4000_playback_close,\n\t.prepare =\tsnd_als4000_playback_prepare,\n\t.trigger =\tsnd_als4000_playback_trigger,\n\t.pointer =\tsnd_als4000_playback_pointer\n};\n\nstatic const struct snd_pcm_ops snd_als4000_capture_ops = {\n\t.open =\t\tsnd_als4000_capture_open,\n\t.close =\tsnd_als4000_capture_close,\n\t.prepare =\tsnd_als4000_capture_prepare,\n\t.trigger =\tsnd_als4000_capture_trigger,\n\t.pointer =\tsnd_als4000_capture_pointer\n};\n\nstatic int snd_als4000_pcm(struct snd_sb *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"ALS4000 DSP\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_als4000_capture_ops);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 64*1024);\n\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n\n \n\nstatic void snd_als4000_set_addr(unsigned long iobase,\n\t\t\t\t\tunsigned int sb_io,\n\t\t\t\t\tunsigned int mpu_io,\n\t\t\t\t\tunsigned int opl_io,\n\t\t\t\t\tunsigned int game_io)\n{\n\tu32 cfg1 = 0;\n\tu32 cfg2 = 0;\n\n\tif (mpu_io > 0)\n\t\tcfg2 |= (mpu_io | 1) << 16;\n\tif (sb_io > 0)\n\t\tcfg2 |= (sb_io | 1);\n\tif (game_io > 0)\n\t\tcfg1 |= (game_io | 1) << 16;\n\tif (opl_io > 0)\n\t\tcfg1 |= (opl_io | 1);\n\tsnd_als4k_gcr_write_addr(iobase, ALS4K_GCRA8_LEGACY_CFG1, cfg1);\n\tsnd_als4k_gcr_write_addr(iobase, ALS4K_GCRA9_LEGACY_CFG2, cfg2);\n}\n\nstatic void snd_als4000_configure(struct snd_sb *chip)\n{\n\tu8 tmp;\n\tint i;\n\n\t \n\tspin_lock_irq(&chip->mixer_lock);\n\ttmp = snd_als4_cr_read(chip, ALS4K_CR0_SB_CONFIG);\n\tsnd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,\n\t\t\t\ttmp|ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);\n\t \n\tsnd_sbmixer_write(chip, SB_DSP4_DMASETUP, SB_DMASETUP_DMA0);\n\tsnd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,\n\t\t\t\t tmp & ~ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);\n\tspin_unlock_irq(&chip->mixer_lock);\n\t\n\tspin_lock_irq(&chip->reg_lock);\n\t \n\tsnd_als4k_gcr_write(chip, ALS4K_GCR8C_MISC_CTRL,\n\t\t\t\t\tALS4K_GCR8C_IRQ_MASK_CTRL_ENABLE);\n\n\t \n\tfor (i = ALS4K_GCR91_DMA0_ADDR; i <= ALS4K_GCR96_DMA3_MODE_COUNT; ++i)\n\t\tsnd_als4k_gcr_write(chip, i, 0);\n\t \n\tsnd_als4k_gcr_write(chip, ALS4K_GCR99_DMA_EMULATION_CTRL,\n\t\t(snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL) & ~0x07) | 0x04);\n\tspin_unlock_irq(&chip->reg_lock);\n}\n\n#ifdef SUPPORT_JOYSTICK\nstatic int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)\n{\n\tstruct gameport *gp;\n\tstruct resource *r;\n\tint io_port;\n\n\tif (joystick_port[dev] == 0)\n\t\treturn -ENODEV;\n\n\tif (joystick_port[dev] == 1) {  \n\t\tfor (io_port = 0x200; io_port <= 0x218; io_port += 8) {\n\t\t\tr = devm_request_region(&acard->pci->dev, io_port, 8,\n\t\t\t\t\t\t\"ALS4000 gameport\");\n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tio_port = joystick_port[dev];\n\t\tr = devm_request_region(&acard->pci->dev, io_port, 8,\n\t\t\t\t\t\"ALS4000 gameport\");\n\t}\n\n\tif (!r) {\n\t\tdev_warn(&acard->pci->dev, \"cannot reserve joystick ports\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tacard->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(&acard->pci->dev, \"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"ALS4000 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(acard->pci));\n\tgameport_set_dev_parent(gp, &acard->pci->dev);\n\tgp->io = io_port;\n\n\t \n\tsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);\n\n\tgameport_register_port(acard->gameport);\n\n\treturn 0;\n}\n\nstatic void snd_als4000_free_gameport(struct snd_card_als4000 *acard)\n{\n\tif (acard->gameport) {\n\t\tgameport_unregister_port(acard->gameport);\n\t\tacard->gameport = NULL;\n\n\t\t \n\t\tsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);\n\t}\n}\n#else\nstatic inline int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev) { return -ENOSYS; }\nstatic inline void snd_als4000_free_gameport(struct snd_card_als4000 *acard) { }\n#endif\n\nstatic void snd_card_als4000_free( struct snd_card *card )\n{\n\tstruct snd_card_als4000 *acard = card->private_data;\n\n\t \n\tsnd_als4k_gcr_write_addr(acard->iobase, ALS4K_GCR8C_MISC_CTRL, 0);\n\t \n\tsnd_als4000_free_gameport(acard);\n}\n\nstatic int __snd_card_als4000_probe(struct pci_dev *pci,\n\t\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_card_als4000 *acard;\n\tunsigned long iobase;\n\tstruct snd_sb *chip;\n\tstruct snd_opl3 *opl3;\n\tunsigned short word;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(24))) {\n\t\tdev_err(&pci->dev, \"architecture does not support 24bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\terr = pci_request_regions(pci, \"ALS4000\");\n\tif (err < 0)\n\t\treturn err;\n\tiobase = pci_resource_start(pci, 0);\n\n\tpci_read_config_word(pci, PCI_COMMAND, &word);\n\tpci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);\n\tpci_set_master(pci);\n\t\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*acard)  ,\n\t\t\t\t&card);\n\tif (err < 0)\n\t\treturn err;\n\n\tacard = card->private_data;\n\tacard->pci = pci;\n\tacard->iobase = iobase;\n\tcard->private_free = snd_card_als4000_free;\n\n\t \n\tsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);\n\n\terr = snd_sbdsp_create(card,\n\t\t\t       iobase + ALS4K_IOB_10_ADLIB_ADDR0,\n\t\t\t       pci->irq,\n\t\t \n\t\t\t       snd_als4000_interrupt,\n\t\t\t       -1,\n\t\t\t       -1,\n\t\t\t       SB_HW_ALS4000,\n\t\t\t       &chip);\n\tif (err < 0)\n\t\treturn err;\n\tacard->chip = chip;\n\n\tchip->pci = pci;\n\tchip->alt_port = iobase;\n\n\tsnd_als4000_configure(chip);\n\n\tstrcpy(card->driver, \"ALS4000\");\n\tstrcpy(card->shortname, \"Avance Logic ALS4000\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, chip->alt_port, chip->irq);\n\n\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_ALS4000,\n\t\t\t\t  iobase + ALS4K_IOB_30_MIDI_DATA,\n\t\t\t\t  MPU401_INFO_INTEGRATED |\n\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t  -1, &chip->rmidi);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, \"no MPU-401 device at 0x%lx?\\n\",\n\t\t\t\tiobase + ALS4K_IOB_30_MIDI_DATA);\n\t\treturn err;\n\t}\n\t \n\n\terr = snd_als4000_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_sbmixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_opl3_create(card,\n\t\t\t\tiobase + ALS4K_IOB_10_ADLIB_ADDR0,\n\t\t\t\tiobase + ALS4K_IOB_12_ADLIB_ADDR2,\n\t\t\t    OPL3_HW_AUTO, 1, &opl3) < 0) {\n\t\tdev_err(&pci->dev, \"no OPL device at 0x%lx-0x%lx?\\n\",\n\t\t\t   iobase + ALS4K_IOB_10_ADLIB_ADDR0,\n\t\t\t   iobase + ALS4K_IOB_12_ADLIB_ADDR2);\n\t} else {\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tsnd_als4000_create_gameport(acard, dev);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_card_als4000_probe(struct pci_dev *pci,\n\t\t\t\t  const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_card_als4000_probe(pci, pci_id));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_als4000_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_card_als4000 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\t\n\tsnd_sbmixer_suspend(chip);\n\treturn 0;\n}\n\nstatic int snd_als4000_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_card_als4000 *acard = card->private_data;\n\tstruct snd_sb *chip = acard->chip;\n\n\tsnd_als4000_configure(chip);\n\tsnd_sbdsp_reset(chip);\n\tsnd_sbmixer_resume(chip);\n\n#ifdef SUPPORT_JOYSTICK\n\tif (acard->gameport)\n\t\tsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);\n#endif\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_als4000_pm, snd_als4000_suspend, snd_als4000_resume);\n#define SND_ALS4000_PM_OPS\t&snd_als4000_pm\n#else\n#define SND_ALS4000_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver als4000_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_als4000_ids,\n\t.probe = snd_card_als4000_probe,\n\t.driver = {\n\t\t.pm = SND_ALS4000_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(als4000_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}