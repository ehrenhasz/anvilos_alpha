{
  "module_name": "au88x0.c",
  "hash_id": "d4792a6253e7c5afd117571817e735efec10e029bb12c8b5a9490cf0bec3cf49",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0.c",
  "human_readable_source": "\n \n\n#include \"au88x0.h\"\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <sound/initval.h>\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nstatic int pcifix[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 255 };\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\nmodule_param_array(pcifix, int, NULL, 0444);\nMODULE_PARM_DESC(pcifix, \"Enable VIA-workaround for \" CARD_NAME \" soundcard.\");\n\nMODULE_DESCRIPTION(\"Aureal vortex\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, snd_vortex_ids);\n\nstatic void vortex_fix_latency(struct pci_dev *vortex)\n{\n\tint rc;\n\trc = pci_write_config_byte(vortex, 0x40, 0xff);\n\tif (!rc) {\n\t\tdev_info(&vortex->dev, \"vortex latency is 0xff\\n\");\n\t} else {\n\t\tdev_warn(&vortex->dev,\n\t\t\t \"could not set vortex latency: pci error 0x%x\\n\", rc);\n\t}\n}\n\nstatic void vortex_fix_agp_bridge(struct pci_dev *via)\n{\n\tint rc;\n\tu8 value;\n\n\t \n\n\trc = pci_read_config_byte(via, 0x42, &value);\n\tif (!rc) {\n\t\tif (!(value & 0x10))\n\t\t\trc = pci_write_config_byte(via, 0x42, value | 0x10);\n\t}\n\tif (!rc) {\n\t\tdev_info(&via->dev, \"bridge config is 0x%x\\n\", value | 0x10);\n\t} else {\n\t\tdev_warn(&via->dev,\n\t\t\t \"could not set vortex latency: pci error 0x%x\\n\", rc);\n\t}\n}\n\nstatic void snd_vortex_workaround(struct pci_dev *vortex, int fix)\n{\n\tstruct pci_dev *via = NULL;\n\n\t \n\tif (fix == 255) {\n\t\t \n\t\tvia = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\tPCI_DEVICE_ID_VIA_8365_1, NULL);\n\t\t \n\t\tif (via == NULL) {\n\t\t\tvia = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\tPCI_DEVICE_ID_VIA_82C598_1, NULL);\n\t\t\t \n\t\t\tif (via == NULL)\n\t\t\t\tvia = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\tPCI_DEVICE_ID_AMD_FE_GATE_7007, NULL);\n\t\t}\n\t\tif (via) {\n\t\t\tdev_info(&vortex->dev,\n\t\t\t\t \"Activating latency workaround...\\n\");\n\t\t\tvortex_fix_latency(vortex);\n\t\t\tvortex_fix_agp_bridge(via);\n\t\t}\n\t} else {\n\t\tif (fix & 0x1)\n\t\t\tvortex_fix_latency(vortex);\n\t\tif (fix & 0x2)\n\t\t\tvia = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\t\t     PCI_DEVICE_ID_VIA_8365_1, NULL);\n\t\telse if (fix & 0x4)\n\t\t\tvia = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\t\t     PCI_DEVICE_ID_VIA_82C598_1, NULL);\n\t\telse if (fix & 0x8)\n\t\t\tvia = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\t     PCI_DEVICE_ID_AMD_FE_GATE_7007, NULL);\n\t\tif (via)\n\t\t\tvortex_fix_agp_bridge(via);\n\t}\n\tpci_dev_put(via);\n}\n\n\n\nstatic void snd_vortex_free(struct snd_card *card)\n{\n\tvortex_t *vortex = card->private_data;\n\n\tvortex_gameport_unregister(vortex);\n\tvortex_core_shutdown(vortex);\n}\n\n\n\nstatic int\nsnd_vortex_create(struct snd_card *card, struct pci_dev *pci)\n{\n\tvortex_t *chip = card->private_data;\n\tint err;\n\n\t\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(card->dev, \"error to set DMA mask\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->card = card;\n\n\t\n\tchip->pci_dev = pci;\n\tchip->vendor = pci->vendor;\n\tchip->device = pci->device;\n\tchip->card = card;\n\tchip->irq = -1;\n\n\t\n\t\n\t\n\terr = pcim_iomap_regions(pci, 1 << 0, CARD_NAME_SHORT);\n\tif (err)\n\t\treturn err;\n\n\tchip->io = pci_resource_start(pci, 0);\n\tchip->mmio = pcim_iomap_table(pci)[0];\n\n\t \n\terr = vortex_core_init(chip);\n\tif (err) {\n\t\tdev_err(card->dev, \"hw core init failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_request_irq(&pci->dev, pci->irq, vortex_interrupt,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (err) {\n\t\tdev_err(card->dev, \"cannot grab irq\\n\");\n\t\treturn err;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_vortex_free;\n\n\tpci_set_master(pci);\n\t\n\treturn 0;\n}\n\n\nstatic int\n__snd_vortex_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tvortex_t *chip;\n\tint err;\n\n\t\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\t\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\t\n\terr = snd_vortex_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_vortex_workaround(pci, pcifix[dev]);\n\n\t\n\tstrcpy(card->driver, CARD_NAME_SHORT);\n\tsprintf(card->shortname, \"Aureal Vortex %s\", CARD_NAME_SHORT);\n\tsprintf(card->longname, \"%s at 0x%lx irq %i\",\n\t\tcard->shortname, chip->io, chip->irq);\n\n\t\n\terr = snd_vortex_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\terr = snd_vortex_new_pcm(chip, VORTEX_PCM_ADB, NR_PCM);\n\tif (err < 0)\n\t\treturn err;\n#ifndef CHIP_AU8820\n\t\n\terr = snd_vortex_new_pcm(chip, VORTEX_PCM_SPDIF, 1);\n\tif (err < 0)\n\t\treturn err;\n\t\n\terr = snd_vortex_new_pcm(chip, VORTEX_PCM_A3D, NR_A3D);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\t \n#ifndef CHIP_AU8810\n\t\n\terr = snd_vortex_new_pcm(chip, VORTEX_PCM_WT, NR_WT);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\terr = snd_vortex_midi(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tvortex_gameport_register(chip);\n\n#if 0\n\tif (snd_seq_device_new(card, 1, SNDRV_SEQ_DEV_ID_VORTEX_SYNTH,\n\t\t\t       sizeof(snd_vortex_synth_arg_t), &wave) < 0\n\t    || wave == NULL) {\n\t\tdev_err(card->dev, \"Can't initialize Aureal wavetable synth\\n\");\n\t} else {\n\t\tsnd_vortex_synth_arg_t *arg;\n\n\t\targ = SNDRV_SEQ_DEVICE_ARGPTR(wave);\n\t\tstrcpy(wave->name, \"Aureal Synth\");\n\t\targ->hwptr = vortex;\n\t\targ->index = 1;\n\t\targ->seq_ports = seq_ports[dev];\n\t\targ->max_voices = max_synth_voices[dev];\n\t}\n#endif\n\n\t\n\terr = pci_read_config_word(pci, PCI_DEVICE_ID, &chip->device);\n\tif (err < 0)\n\t\treturn err;\n\terr = pci_read_config_word(pci, PCI_VENDOR_ID, &chip->vendor);\n\tif (err < 0)\n\t\treturn err;\n\tchip->rev = pci->revision;\n#ifdef CHIP_AU8830\n\tif ((chip->rev) != 0xfe && (chip->rev) != 0xfa) {\n\t\tdev_alert(card->dev,\n\t\t\t  \"The revision (%x) of your card has not been seen before.\\n\",\n\t\t       chip->rev);\n\t\tdev_alert(card->dev,\n\t\t\t  \"Please email the results of 'lspci -vv' to openvortex-dev@nongnu.org.\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\t\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\tvortex_connect_default(chip, 1);\n\tvortex_enable_int(chip);\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_vortex_probe(pci, pci_id));\n}\n\n\nstatic struct pci_driver vortex_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_vortex_ids,\n\t.probe = snd_vortex_probe,\n};\n\nmodule_pci_driver(vortex_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}