{
  "module_name": "au88x0_pcm.c",
  "hash_id": "78498c272ab456d2785afb0f28fea909b47f22ea2cd8be46845ab778e8506320",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0_pcm.c",
  "human_readable_source": "\n \n \n \n#include <sound/asoundef.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"au88x0.h\"\n\n#define VORTEX_PCM_TYPE(x) (x->name[40])\n\n \nstatic const struct snd_pcm_hardware snd_vortex_playback_hw_adb = {\n\t.info =\n\t    (SNDRV_PCM_INFO_MMAP |  \n\t     SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_INTERLEAVED |\n\t     SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\n\t    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U8 |\n\t    SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min = 5000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 0x10000,\n\t.period_bytes_min = 0x20,\n\t.period_bytes_max = 0x1000,\n\t.periods_min = 2,\n\t.periods_max = 1024,\n};\n\n#ifndef CHIP_AU8820\nstatic const struct snd_pcm_hardware snd_vortex_playback_hw_a3d = {\n\t.info =\n\t    (SNDRV_PCM_INFO_MMAP |  \n\t     SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_INTERLEAVED |\n\t     SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\n\t    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U8 |\n\t    SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min = 5000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 1,\n\t.buffer_bytes_max = 0x10000,\n\t.period_bytes_min = 0x100,\n\t.period_bytes_max = 0x1000,\n\t.periods_min = 2,\n\t.periods_max = 64,\n};\n#endif\nstatic const struct snd_pcm_hardware snd_vortex_playback_hw_spdif = {\n\t.info =\n\t    (SNDRV_PCM_INFO_MMAP |  \n\t     SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_INTERLEAVED |\n\t     SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\n\t    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U8 |\n\t    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE | SNDRV_PCM_FMTBIT_MU_LAW |\n\t    SNDRV_PCM_FMTBIT_A_LAW,\n\t.rates =\n\t    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min = 32000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 0x10000,\n\t.period_bytes_min = 0x100,\n\t.period_bytes_max = 0x1000,\n\t.periods_min = 2,\n\t.periods_max = 64,\n};\n\n#ifndef CHIP_AU8810\nstatic const struct snd_pcm_hardware snd_vortex_playback_hw_wt = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_CONTINUOUS,\t\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 0x10000,\n\t.period_bytes_min = 0x0400,\n\t.period_bytes_max = 0x1000,\n\t.periods_min = 2,\n\t.periods_max = 64,\n};\n#endif\n#ifdef CHIP_AU8830\nstatic const unsigned int au8830_channels[3] = {\n\t1, 2, 4,\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_au8830_channels = {\n\t.count = ARRAY_SIZE(au8830_channels),\n\t.list = au8830_channels,\n\t.mask = 0,\n};\n#endif\n\nstatic void vortex_notify_pcm_vol_change(struct snd_card *card,\n\t\t\tstruct snd_kcontrol *kctl, int activate)\n{\n\tif (activate)\n\t\tkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\telse\n\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t\tSNDRV_CTL_EVENT_MASK_INFO, &(kctl->id));\n}\n\n \nstatic int snd_vortex_pcm_open(struct snd_pcm_substream *substream)\n{\n\tvortex_t *vortex = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\t\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 64);\n\n\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\n#ifndef CHIP_AU8820\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_A3D) {\n\t\t\truntime->hw = snd_vortex_playback_hw_a3d;\n\t\t}\n#endif\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_SPDIF) {\n\t\t\truntime->hw = snd_vortex_playback_hw_spdif;\n\t\t\tswitch (vortex->spdif_sr) {\n\t\t\tcase 32000:\n\t\t\t\truntime->hw.rates = SNDRV_PCM_RATE_32000;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\t\truntime->hw.rates = SNDRV_PCM_RATE_44100;\n\t\t\t\tbreak;\n\t\t\tcase 48000:\n\t\t\t\truntime->hw.rates = SNDRV_PCM_RATE_48000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB\n\t\t    || VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_I2S)\n\t\t\truntime->hw = snd_vortex_playback_hw_adb;\n#ifdef CHIP_AU8830\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t\t\tVORTEX_IS_QUAD(vortex) &&\n\t\t\tVORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\n\t\t\truntime->hw.channels_max = 4;\n\t\t\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t&hw_constraints_au8830_channels);\n\t\t}\n#endif\n\t\tsubstream->runtime->private_data = NULL;\n\t}\n#ifndef CHIP_AU8810\n\telse {\n\t\truntime->hw = snd_vortex_playback_hw_wt;\n\t\tsubstream->runtime->private_data = NULL;\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic int snd_vortex_pcm_close(struct snd_pcm_substream *substream)\n{\n\t\n\tstream_t *stream = (stream_t *) substream->runtime->private_data;\n\n\t\n\tif (stream != NULL) {\n\t\tstream->substream = NULL;\n\t\tstream->nr_ch = 0;\n\t}\n\tsubstream->runtime->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic int\nsnd_vortex_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tvortex_t *chip = snd_pcm_substream_chip(substream);\n\tstream_t *stream = (stream_t *) (substream->runtime->private_data);\n\n\t \n\tspin_lock_irq(&chip->lock);\n\t\n\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\n\t\tint dma, type = VORTEX_PCM_TYPE(substream->pcm);\n\t\t \n\t\tif (stream != NULL)\n\t\t\tvortex_adb_allocroute(chip, stream->dma,\n\t\t\t\t\t      stream->nr_ch, stream->dir,\n\t\t\t\t\t      stream->type,\n\t\t\t\t\t      substream->number);\n\t\t \n\t\tdma =\n\t\t    vortex_adb_allocroute(chip, -1,\n\t\t\t\t\t  params_channels(hw_params),\n\t\t\t\t\t  substream->stream, type,\n\t\t\t\t\t  substream->number);\n\t\tif (dma < 0) {\n\t\t\tspin_unlock_irq(&chip->lock);\n\t\t\treturn dma;\n\t\t}\n\t\tstream = substream->runtime->private_data = &chip->dma_adb[dma];\n\t\tstream->substream = substream;\n\t\t \n\t\tvortex_adbdma_setbuffers(chip, dma,\n\t\t\t\t\t params_period_bytes(hw_params),\n\t\t\t\t\t params_periods(hw_params));\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\n\t\t\tchip->pcm_vol[substream->number].active = 1;\n\t\t\tvortex_notify_pcm_vol_change(chip->card,\n\t\t\t\tchip->pcm_vol[substream->number].kctl, 1);\n\t\t}\n\t}\n#ifndef CHIP_AU8810\n\telse {\n\t\t \n\t\tvortex_wt_allocroute(chip, substream->number,\n\t\t\t\t     params_channels(hw_params));\n\t\tstream = substream->runtime->private_data =\n\t\t    &chip->dma_wt[substream->number];\n\t\tstream->dma = substream->number;\n\t\tstream->substream = substream;\n\t\tvortex_wtdma_setbuffers(chip, substream->number,\n\t\t\t\t\tparams_period_bytes(hw_params),\n\t\t\t\t\tparams_periods(hw_params));\n\t}\n#endif\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n \nstatic int snd_vortex_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tvortex_t *chip = snd_pcm_substream_chip(substream);\n\tstream_t *stream = (stream_t *) (substream->runtime->private_data);\n\n\tspin_lock_irq(&chip->lock);\n\t\n\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\n\t\tif (stream != NULL) {\n\t\t\tif (VORTEX_PCM_TYPE(substream->pcm) == VORTEX_PCM_ADB) {\n\t\t\t\tchip->pcm_vol[substream->number].active = 0;\n\t\t\t\tvortex_notify_pcm_vol_change(chip->card,\n\t\t\t\t\tchip->pcm_vol[substream->number].kctl,\n\t\t\t\t\t0);\n\t\t\t}\n\t\t\tvortex_adb_allocroute(chip, stream->dma,\n\t\t\t\t\t      stream->nr_ch, stream->dir,\n\t\t\t\t\t      stream->type,\n\t\t\t\t\t      substream->number);\n\t\t}\n\t}\n#ifndef CHIP_AU8810\n\telse {\n\t\tif (stream != NULL)\n\t\t\tvortex_wt_allocroute(chip, stream->dma, 0);\n\t}\n#endif\n\tsubstream->runtime->private_data = NULL;\n\tspin_unlock_irq(&chip->lock);\n\n\treturn 0;\n}\n\n \nstatic int snd_vortex_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tvortex_t *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstream_t *stream = (stream_t *) substream->runtime->private_data;\n\tint dma = stream->dma, fmt, dir;\n\n\t\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = 1;\n\telse\n\t\tdir = 0;\n\tfmt = vortex_alsafmt_aspfmt(runtime->format, chip);\n\tspin_lock_irq(&chip->lock);\n\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\n\t\tvortex_adbdma_setmode(chip, dma, 1, dir, fmt,\n\t\t\t\truntime->channels == 1 ? 0 : 1, 0);\n\t\tvortex_adbdma_setstartbuffer(chip, dma, 0);\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_SPDIF)\n\t\t\tvortex_adb_setsrc(chip, dma, runtime->rate, dir);\n\t}\n#ifndef CHIP_AU8810\n\telse {\n\t\tvortex_wtdma_setmode(chip, dma, 1, fmt, 0, 0);\n\t\t\n\t\tvortex_wtdma_setstartbuffer(chip, dma, 0);\n\t}\n#endif\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n \nstatic int snd_vortex_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tvortex_t *chip = snd_pcm_substream_chip(substream);\n\tstream_t *stream = (stream_t *) substream->runtime->private_data;\n\tint dma = stream->dma;\n\n\tspin_lock(&chip->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\n\t\t\n\t\tstream->fifo_enabled = 1;\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT) {\n\t\t\tvortex_adbdma_resetup(chip, dma);\n\t\t\tvortex_adbdma_startfifo(chip, dma);\n\t\t}\n#ifndef CHIP_AU8810\n\t\telse {\n\t\t\tdev_info(chip->card->dev, \"wt start %d\\n\", dma);\n\t\t\tvortex_wtdma_startfifo(chip, dma);\n\t\t}\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t\n\t\t\n\t\tstream->fifo_enabled = 0;\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\n\t\t\tvortex_adbdma_stopfifo(chip, dma);\n#ifndef CHIP_AU8810\n\t\telse {\n\t\t\tdev_info(chip->card->dev, \"wt stop %d\\n\", dma);\n\t\t\tvortex_wtdma_stopfifo(chip, dma);\n\t\t}\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\n\t\t\tvortex_adbdma_pausefifo(chip, dma);\n#ifndef CHIP_AU8810\n\t\telse\n\t\t\tvortex_wtdma_pausefifo(chip, dma);\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\n\t\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\n\t\t\tvortex_adbdma_resumefifo(chip, dma);\n#ifndef CHIP_AU8810\n\t\telse\n\t\t\tvortex_wtdma_resumefifo(chip, dma);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&chip->lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock(&chip->lock);\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t snd_vortex_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tvortex_t *chip = snd_pcm_substream_chip(substream);\n\tstream_t *stream = (stream_t *) substream->runtime->private_data;\n\tint dma = stream->dma;\n\tsnd_pcm_uframes_t current_ptr = 0;\n\n\tspin_lock(&chip->lock);\n\tif (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)\n\t\tcurrent_ptr = vortex_adbdma_getlinearpos(chip, dma);\n#ifndef CHIP_AU8810\n\telse\n\t\tcurrent_ptr = vortex_wtdma_getlinearpos(chip, dma);\n#endif\n\t\n\tspin_unlock(&chip->lock);\n\tcurrent_ptr = bytes_to_frames(substream->runtime, current_ptr);\n\tif (current_ptr >= substream->runtime->buffer_size)\n\t\tcurrent_ptr = 0;\n\treturn current_ptr;\n}\n\n \nstatic const struct snd_pcm_ops snd_vortex_playback_ops = {\n\t.open = snd_vortex_pcm_open,\n\t.close = snd_vortex_pcm_close,\n\t.hw_params = snd_vortex_pcm_hw_params,\n\t.hw_free = snd_vortex_pcm_hw_free,\n\t.prepare = snd_vortex_pcm_prepare,\n\t.trigger = snd_vortex_pcm_trigger,\n\t.pointer = snd_vortex_pcm_pointer,\n};\n\n \n\nstatic const char * const vortex_pcm_prettyname[VORTEX_PCM_LAST] = {\n\tCARD_NAME \" ADB\",\n\tCARD_NAME \" SPDIF\",\n\tCARD_NAME \" A3D\",\n\tCARD_NAME \" WT\",\n\tCARD_NAME \" I2S\",\n};\nstatic const char * const vortex_pcm_name[VORTEX_PCM_LAST] = {\n\t\"adb\",\n\t\"spdif\",\n\t\"a3d\",\n\t\"wt\",\n\t\"i2s\",\n};\n\n \n\nstatic int snd_vortex_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_vortex_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\n\treturn 0;\n}\n\nstatic int snd_vortex_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.iec958.status[0] = 0x00;\n\tucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL|IEC958_AES1_CON_DIGDIGCONV_ID;\n\tucontrol->value.iec958.status[2] = 0x00;\n\tswitch (vortex->spdif_sr) {\n\tcase 32000: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_32000; break;\n\tcase 44100: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_44100; break;\n\tcase 48000: ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000; break;\n\t}\n\treturn 0;\n}\n\nstatic int snd_vortex_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint spdif_sr = 48000;\n\tswitch (ucontrol->value.iec958.status[3] & IEC958_AES3_CON_FS) {\n\tcase IEC958_AES3_CON_FS_32000: spdif_sr = 32000; break;\n\tcase IEC958_AES3_CON_FS_44100: spdif_sr = 44100; break;\n\tcase IEC958_AES3_CON_FS_48000: spdif_sr = 48000; break;\n\t}\n\tif (spdif_sr == vortex->spdif_sr)\n\t\treturn 0;\n\tvortex->spdif_sr = spdif_sr;\n\tvortex_spdif_init(vortex, vortex->spdif_sr, 1);\n\treturn 1;\n}\n\n \nstatic const struct snd_kcontrol_new snd_vortex_mixer_spdif[] = {\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t\t.info =\t\tsnd_vortex_spdif_info,\n\t\t.get =\t\tsnd_vortex_spdif_get,\n\t\t.put =\t\tsnd_vortex_spdif_put,\n\t},\n\t{\n\t\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t\t.info =\t\tsnd_vortex_spdif_info,\n\t\t.get =\t\tsnd_vortex_spdif_mask_get\n\t},\n};\n\n \n\nstatic int snd_vortex_pcm_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\n\tuinfo->value.integer.min = -128;\n\tuinfo->value.integer.max = 32;\n\treturn 0;\n}\n\nstatic int snd_vortex_pcm_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint i;\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint subdev = kcontrol->id.subdevice;\n\tstruct pcm_vol *p = &vortex->pcm_vol[subdev];\n\tint max_chn = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\n\tfor (i = 0; i < max_chn; i++)\n\t\tucontrol->value.integer.value[i] = p->vol[i];\n\treturn 0;\n}\n\nstatic int snd_vortex_pcm_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint i;\n\tint changed = 0;\n\tint mixin;\n\tunsigned char vol;\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint subdev = kcontrol->id.subdevice;\n\tstruct pcm_vol *p = &vortex->pcm_vol[subdev];\n\tint max_chn = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\n\tfor (i = 0; i < max_chn; i++) {\n\t\tif (p->vol[i] != ucontrol->value.integer.value[i]) {\n\t\t\tp->vol[i] = ucontrol->value.integer.value[i];\n\t\t\tif (p->active) {\n\t\t\t\tswitch (vortex->dma_adb[p->dma].nr_ch) {\n\t\t\t\tcase 1:\n\t\t\t\t\tmixin = p->mixin[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tdefault:\n\t\t\t\t\tmixin = p->mixin[(i < 2) ? i : (i - 2)];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tmixin = p->mixin[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvol = p->vol[i];\n\t\t\t\tvortex_mix_setinputvolumebyte(vortex,\n\t\t\t\t\tvortex->mixplayb[i], mixin, vol);\n\t\t\t}\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_MINMAX(vortex_pcm_vol_db_scale, -9600, 2400);\n\nstatic const struct snd_kcontrol_new snd_vortex_pcm_vol = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"PCM Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.info = snd_vortex_pcm_vol_info,\n\t.get = snd_vortex_pcm_vol_get,\n\t.put = snd_vortex_pcm_vol_put,\n\t.tlv = { .p = vortex_pcm_vol_db_scale },\n};\n\n \nstatic int snd_vortex_new_pcm(vortex_t *chip, int idx, int nr)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_kcontrol *kctl;\n\tint i;\n\tint err, nr_capt;\n\n\tif (!chip || idx < 0 || idx >= VORTEX_PCM_LAST)\n\t\treturn -ENODEV;\n\n\t \n\tif (idx == VORTEX_PCM_ADB)\n\t\tnr_capt = nr;\n\telse\n\t\tnr_capt = 0;\n\terr = snd_pcm_new(chip->card, vortex_pcm_prettyname[idx], idx, nr,\n\t\t\t  nr_capt, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnprintf(pcm->name, sizeof(pcm->name),\n\t\t\"%s %s\", CARD_NAME_SHORT, vortex_pcm_name[idx]);\n\tchip->pcm[idx] = pcm;\n\t\n\tVORTEX_PCM_TYPE(pcm) = idx;\n\tpcm->private_data = chip;\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_vortex_playback_ops);\n\tif (idx == VORTEX_PCM_ADB)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_vortex_playback_ops);\n\t\n\t \n\t\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci_dev->dev, 0x10000, 0x10000);\n\n\tswitch (VORTEX_PCM_TYPE(pcm)) {\n\tcase VORTEX_PCM_ADB:\n\t\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t     snd_pcm_std_chmaps,\n\t\t\t\t\t     VORTEX_IS_QUAD(chip) ? 4 : 2,\n\t\t\t\t\t     0, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t     snd_pcm_std_chmaps, 2, 0, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n#ifdef CHIP_AU8830\n\tcase VORTEX_PCM_A3D:\n\t\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t     snd_pcm_std_chmaps, 1, 0, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n#endif\n\t}\n\n\tif (VORTEX_PCM_TYPE(pcm) == VORTEX_PCM_SPDIF) {\n\t\tfor (i = 0; i < ARRAY_SIZE(snd_vortex_mixer_spdif); i++) {\n\t\t\tkctl = snd_ctl_new1(&snd_vortex_mixer_spdif[i], chip);\n\t\t\tif (!kctl)\n\t\t\t\treturn -ENOMEM;\n\t\t\terr = snd_ctl_add(chip->card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (VORTEX_PCM_TYPE(pcm) == VORTEX_PCM_ADB) {\n\t\tfor (i = 0; i < NR_PCM; i++) {\n\t\t\tchip->pcm_vol[i].active = 0;\n\t\t\tchip->pcm_vol[i].dma = -1;\n\t\t\tkctl = snd_ctl_new1(&snd_vortex_pcm_vol, chip);\n\t\t\tif (!kctl)\n\t\t\t\treturn -ENOMEM;\n\t\t\tchip->pcm_vol[i].kctl = kctl;\n\t\t\tkctl->id.device = 0;\n\t\t\tkctl->id.subdevice = i;\n\t\t\terr = snd_ctl_add(chip->card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}