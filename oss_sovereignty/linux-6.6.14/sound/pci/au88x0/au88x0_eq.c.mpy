{
  "module_name": "au88x0_eq.c",
  "hash_id": "57935f3ed1a8db898fef8705c006693e699f4252307129efb87623be28ea4f2e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0_eq.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"au88x0.h\"\n#include \"au88x0_eq.h\"\n#include \"au88x0_eqdata.c\"\n\n#define VORTEX_EQ_BASE\t 0x2b000\n#define VORTEX_EQ_DEST   (VORTEX_EQ_BASE + 0x410)\n#define VORTEX_EQ_SOURCE (VORTEX_EQ_BASE + 0x430)\n#define VORTEX_EQ_CTRL   (VORTEX_EQ_BASE + 0x440)\n\n#define VORTEX_BAND_COEFF_SIZE 0x30\n\n \nstatic void vortex_EqHw_SetTimeConsts(vortex_t * vortex, u16 gain, u16 level)\n{\n\thwwrite(vortex->mmio, 0x2b3c4, gain);\n\thwwrite(vortex->mmio, 0x2b3c8, level);\n}\n\nstatic inline u16 sign_invert(u16 a)\n{\n\t \n\tif (a == (u16)-32768)\n\t\treturn 32767;\n\telse\n\t\treturn -a;\n}\n\nstatic void vortex_EqHw_SetLeftCoefs(vortex_t *vortex, const u16 coefs[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i = 0, n  ;\n\n\tfor (n = 0; n < eqhw->this04; n++) {\n\t\thwwrite(vortex->mmio, 0x2b000 + n * 0x30, coefs[i + 0]);\n\t\thwwrite(vortex->mmio, 0x2b004 + n * 0x30, coefs[i + 1]);\n\n\t\tif (eqhw->this08 == 0) {\n\t\t\thwwrite(vortex->mmio, 0x2b008 + n * 0x30, coefs[i + 2]);\n\t\t\thwwrite(vortex->mmio, 0x2b00c + n * 0x30, coefs[i + 3]);\n\t\t\thwwrite(vortex->mmio, 0x2b010 + n * 0x30, coefs[i + 4]);\n\t\t} else {\n\t\t\thwwrite(vortex->mmio, 0x2b008 + n * 0x30, sign_invert(coefs[2 + i]));\n\t\t\thwwrite(vortex->mmio, 0x2b00c + n * 0x30, sign_invert(coefs[3 + i]));\n\t\t        hwwrite(vortex->mmio, 0x2b010 + n * 0x30, sign_invert(coefs[4 + i]));\n\t\t}\n\t\ti += 5;\n\t}\n}\n\nstatic void vortex_EqHw_SetRightCoefs(vortex_t *vortex, const u16 coefs[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i = 0, n  ;\n\n\tfor (n = 0; n < eqhw->this04; n++) {\n\t\thwwrite(vortex->mmio, 0x2b1e0 + n * 0x30, coefs[0 + i]);\n\t\thwwrite(vortex->mmio, 0x2b1e4 + n * 0x30, coefs[1 + i]);\n\n\t\tif (eqhw->this08 == 0) {\n\t\t\thwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, coefs[2 + i]);\n\t\t\thwwrite(vortex->mmio, 0x2b1ec + n * 0x30, coefs[3 + i]);\n\t\t\thwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, coefs[4 + i]);\n\t\t} else {\n\t\t\thwwrite(vortex->mmio, 0x2b1e8 + n * 0x30, sign_invert(coefs[2 + i]));\n\t\t\thwwrite(vortex->mmio, 0x2b1ec + n * 0x30, sign_invert(coefs[3 + i]));\n\t\t\thwwrite(vortex->mmio, 0x2b1f0 + n * 0x30, sign_invert(coefs[4 + i]));\n\t\t}\n\t\ti += 5;\n\t}\n\n}\n\nstatic void vortex_EqHw_SetLeftStates(vortex_t *vortex, const u16 a[], const u16 b[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i = 0, ebx;\n\n\thwwrite(vortex->mmio, 0x2b3fc, a[0]);\n\thwwrite(vortex->mmio, 0x2b400, a[1]);\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b014 + (i * 0xc), b[i]);\n\t\thwwrite(vortex->mmio, 0x2b018 + (i * 0xc), b[1 + i]);\n\t\thwwrite(vortex->mmio, 0x2b01c + (i * 0xc), b[2 + i]);\n\t\thwwrite(vortex->mmio, 0x2b020 + (i * 0xc), b[3 + i]);\n\t\ti += 4;\n\t}\n}\n\nstatic void vortex_EqHw_SetRightStates(vortex_t *vortex, const u16 a[], const u16 b[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i = 0, ebx;\n\n\thwwrite(vortex->mmio, 0x2b404, a[0]);\n\thwwrite(vortex->mmio, 0x2b408, a[1]);\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b1f4 + (i * 0xc), b[i]);\n\t\thwwrite(vortex->mmio, 0x2b1f8 + (i * 0xc), b[1 + i]);\n\t\thwwrite(vortex->mmio, 0x2b1fc + (i * 0xc), b[2 + i]);\n\t\thwwrite(vortex->mmio, 0x2b200 + (i * 0xc), b[3 + i]);\n\t\ti += 4;\n\t}\n}\n\n#if 0\nstatic void vortex_EqHw_GetTimeConsts(vortex_t * vortex, u16 * a, u16 * b)\n{\n\t*a = hwread(vortex->mmio, 0x2b3c4);\n\t*b = hwread(vortex->mmio, 0x2b3c8);\n}\n\nstatic void vortex_EqHw_GetLeftCoefs(vortex_t * vortex, u16 a[])\n{\n\n}\n\nstatic void vortex_EqHw_GetRightCoefs(vortex_t * vortex, u16 a[])\n{\n\n}\n\nstatic void vortex_EqHw_GetLeftStates(vortex_t * vortex, u16 * a, u16 b[])\n{\n\n}\n\nstatic void vortex_EqHw_GetRightStates(vortex_t * vortex, u16 * a, u16 b[])\n{\n\n}\n\n#endif\n \nstatic void vortex_EqHw_SetBypassGain(vortex_t * vortex, u16 a, u16 b)\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tif (eqhw->this08 == 0) {\n\t\thwwrite(vortex->mmio, 0x2b3d4, a);\n\t\thwwrite(vortex->mmio, 0x2b3ec, b);\n\t} else {\n\t\thwwrite(vortex->mmio, 0x2b3d4, sign_invert(a));\n\t\thwwrite(vortex->mmio, 0x2b3ec, sign_invert(b));\n\t}\n}\n\nstatic void vortex_EqHw_SetA3DBypassGain(vortex_t * vortex, u16 a, u16 b)\n{\n\n\thwwrite(vortex->mmio, 0x2b3e0, a);\n\thwwrite(vortex->mmio, 0x2b3f8, b);\n}\n\n#if 0\nstatic void vortex_EqHw_SetCurrBypassGain(vortex_t * vortex, u16 a, u16 b)\n{\n\n\thwwrite(vortex->mmio, 0x2b3d0, a);\n\thwwrite(vortex->mmio, 0x2b3e8, b);\n}\n\nstatic void vortex_EqHw_SetCurrA3DBypassGain(vortex_t * vortex, u16 a, u16 b)\n{\n\n\thwwrite(vortex->mmio, 0x2b3dc, a);\n\thwwrite(vortex->mmio, 0x2b3f4, b);\n}\n\n#endif\nstatic void\nvortex_EqHw_SetLeftGainsSingleTarget(vortex_t * vortex, u16 index, u16 b)\n{\n\thwwrite(vortex->mmio, 0x2b02c + (index * 0x30), b);\n}\n\nstatic void\nvortex_EqHw_SetRightGainsSingleTarget(vortex_t * vortex, u16 index, u16 b)\n{\n\thwwrite(vortex->mmio, 0x2b20c + (index * 0x30), b);\n}\n\nstatic void vortex_EqHw_SetLeftGainsTarget(vortex_t *vortex, const u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx;\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b02c + ebx * 0x30, a[ebx]);\n\t}\n}\n\nstatic void vortex_EqHw_SetRightGainsTarget(vortex_t *vortex, const u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx;\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b20c + ebx * 0x30, a[ebx]);\n\t}\n}\n\nstatic void vortex_EqHw_SetLeftGainsCurrent(vortex_t *vortex, const u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx;\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b028 + ebx * 0x30, a[ebx]);\n\t}\n}\n\nstatic void vortex_EqHw_SetRightGainsCurrent(vortex_t *vortex, const u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx;\n\n\tfor (ebx = 0; ebx < eqhw->this04; ebx++) {\n\t\thwwrite(vortex->mmio, 0x2b208 + ebx * 0x30, a[ebx]);\n\t}\n}\n\n#if 0\nstatic void vortex_EqHw_GetLeftGainsTarget(vortex_t * vortex, u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx = 0;\n\n\tif (eqhw->this04 < 0)\n\t\treturn;\n\n\tdo {\n\t\ta[ebx] = hwread(vortex->mmio, 0x2b02c + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n}\n\nstatic void vortex_EqHw_GetRightGainsTarget(vortex_t * vortex, u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx = 0;\n\n\tif (eqhw->this04 < 0)\n\t\treturn;\n\n\tdo {\n\t\ta[ebx] = hwread(vortex->mmio, 0x2b20c + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n}\n\nstatic void vortex_EqHw_GetLeftGainsCurrent(vortex_t * vortex, u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx = 0;\n\n\tif (eqhw->this04 < 0)\n\t\treturn;\n\n\tdo {\n\t\ta[ebx] = hwread(vortex->mmio, 0x2b028 + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n}\n\nstatic void vortex_EqHw_GetRightGainsCurrent(vortex_t * vortex, u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx = 0;\n\n\tif (eqhw->this04 < 0)\n\t\treturn;\n\n\tdo {\n\t\ta[ebx] = hwread(vortex->mmio, 0x2b208 + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n}\n\n#endif\n \nstatic void vortex_EqHw_SetLevels(vortex_t *vortex, const u16 peaks[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i;\n\n\t \n\tfor (i = 0; i < eqhw->this04; i++) {\n\t\thwwrite(vortex->mmio, 0x2b024 + i * VORTEX_BAND_COEFF_SIZE, peaks[i]);\n\t}\n\n\thwwrite(vortex->mmio, 0x2b3cc, peaks[eqhw->this04]);\n\thwwrite(vortex->mmio, 0x2b3d8, peaks[eqhw->this04 + 1]);\n\n\t \n\tfor (i = 0; i < eqhw->this04; i++) {\n\t\thwwrite(vortex->mmio, 0x2b204 + i * VORTEX_BAND_COEFF_SIZE,\n\t\t\tpeaks[i + (eqhw->this04 + 2)]);\n\t}\n\n\thwwrite(vortex->mmio, 0x2b3e4, peaks[2 + (eqhw->this04 * 2)]);\n\thwwrite(vortex->mmio, 0x2b3f0, peaks[3 + (eqhw->this04 * 2)]);\n}\n\n#if 0\nstatic void vortex_EqHw_GetLevels(vortex_t * vortex, u16 a[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint ebx;\n\n\tif (eqhw->this04 < 0)\n\t\treturn;\n\n\tebx = 0;\n\tdo {\n\t\ta[ebx] = hwread(vortex->mmio, 0x2b024 + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n\n\ta[eqhw->this04] = hwread(vortex->mmio, 0x2b3cc);\n\ta[eqhw->this04 + 1] = hwread(vortex->mmio, 0x2b3d8);\n\n\tebx = 0;\n\tdo {\n\t\ta[ebx + (eqhw->this04 + 2)] =\n\t\t    hwread(vortex->mmio, 0x2b204 + ebx * 0x30);\n\t\tebx++;\n\t}\n\twhile (ebx < eqhw->this04);\n\n\ta[2 + (eqhw->this04 * 2)] = hwread(vortex->mmio, 0x2b3e4);\n\ta[3 + (eqhw->this04 * 2)] = hwread(vortex->mmio, 0x2b3f0);\n}\n\n#endif\n \nstatic void vortex_EqHw_SetControlReg(vortex_t * vortex, u32 reg)\n{\n\thwwrite(vortex->mmio, 0x2b440, reg);\n}\n\nstatic void vortex_EqHw_SetSampleRate(vortex_t * vortex, u32 sr)\n{\n\thwwrite(vortex->mmio, 0x2b440, ((sr & 0x1f) << 3) | 0xb800);\n}\n\n#if 0\nstatic void vortex_EqHw_GetControlReg(vortex_t * vortex, u32 *reg)\n{\n\t*reg = hwread(vortex->mmio, 0x2b440);\n}\n\nstatic void vortex_EqHw_GetSampleRate(vortex_t * vortex, u32 *sr)\n{\n\t*sr = (hwread(vortex->mmio, 0x2b440) >> 3) & 0x1f;\n}\n\n#endif\nstatic void vortex_EqHw_Enable(vortex_t * vortex)\n{\n\thwwrite(vortex->mmio, VORTEX_EQ_CTRL, 0xf001);\n}\n\nstatic void vortex_EqHw_Disable(vortex_t * vortex)\n{\n\thwwrite(vortex->mmio, VORTEX_EQ_CTRL, 0xf000);\n}\n\n \nstatic void vortex_EqHw_ZeroIO(vortex_t * vortex)\n{\n\tint i;\n\tfor (i = 0; i < 0x8; i++)\n\t\thwwrite(vortex->mmio, VORTEX_EQ_DEST + (i << 2), 0x0);\n\tfor (i = 0; i < 0x4; i++)\n\t\thwwrite(vortex->mmio, VORTEX_EQ_SOURCE + (i << 2), 0x0);\n}\n\nstatic void vortex_EqHw_ZeroA3DIO(vortex_t * vortex)\n{\n\tint i;\n\tfor (i = 0; i < 0x4; i++)\n\t\thwwrite(vortex->mmio, VORTEX_EQ_DEST + (i << 2), 0x0);\n}\n\nstatic void vortex_EqHw_ZeroState(vortex_t * vortex)\n{\n\n\tvortex_EqHw_SetControlReg(vortex, 0);\n\tvortex_EqHw_ZeroIO(vortex);\n\thwwrite(vortex->mmio, 0x2b3c0, 0);\n\n\tvortex_EqHw_SetTimeConsts(vortex, 0, 0);\n\n\tvortex_EqHw_SetLeftCoefs(vortex, asEqCoefsZeros);\n\tvortex_EqHw_SetRightCoefs(vortex, asEqCoefsZeros);\n\n\tvortex_EqHw_SetLeftGainsCurrent(vortex, eq_gains_zero);\n\tvortex_EqHw_SetRightGainsCurrent(vortex, eq_gains_zero);\n\tvortex_EqHw_SetLeftGainsTarget(vortex, eq_gains_zero);\n\tvortex_EqHw_SetRightGainsTarget(vortex, eq_gains_zero);\n\n\tvortex_EqHw_SetBypassGain(vortex, 0, 0);\n\t\n\tvortex_EqHw_SetA3DBypassGain(vortex, 0, 0);\n\t\n\tvortex_EqHw_SetLeftStates(vortex, eq_states_zero, asEqOutStateZeros);\n\tvortex_EqHw_SetRightStates(vortex, eq_states_zero, asEqOutStateZeros);\n\tvortex_EqHw_SetLevels(vortex, (u16 *) eq_levels);\n}\n\n \nstatic void vortex_EqHw_ProgramPipe(vortex_t * vortex)\n{\n\tvortex_EqHw_SetTimeConsts(vortex, 0, 0);\n\n\tvortex_EqHw_SetLeftCoefs(vortex, asEqCoefsPipes);\n\tvortex_EqHw_SetRightCoefs(vortex, asEqCoefsPipes);\n\n\tvortex_EqHw_SetLeftGainsCurrent(vortex, eq_gains_current);\n\tvortex_EqHw_SetRightGainsCurrent(vortex, eq_gains_current);\n\tvortex_EqHw_SetLeftGainsTarget(vortex, eq_gains_current);\n\tvortex_EqHw_SetRightGainsTarget(vortex, eq_gains_current);\n}\n\n \nstatic void\nvortex_EqHw_Program10Band(vortex_t * vortex, auxxEqCoeffSet_t * coefset)\n{\n\n\tvortex_EqHw_SetTimeConsts(vortex, 0xc, 0x7fe0);\n\n\tvortex_EqHw_SetLeftCoefs(vortex, coefset->LeftCoefs);\n\tvortex_EqHw_SetRightCoefs(vortex, coefset->RightCoefs);\n\n\tvortex_EqHw_SetLeftGainsCurrent(vortex, coefset->LeftGains);\n\n\tvortex_EqHw_SetRightGainsTarget(vortex, coefset->RightGains);\n\tvortex_EqHw_SetLeftGainsTarget(vortex, coefset->LeftGains);\n\n\tvortex_EqHw_SetRightGainsCurrent(vortex, coefset->RightGains);\n}\n\n \nstatic void vortex_EqHw_GetTenBandLevels(vortex_t * vortex, u16 peaks[])\n{\n\teqhw_t *eqhw = &(vortex->eq.this04);\n\tint i;\n\n\tif (eqhw->this04 <= 0)\n\t\treturn;\n\n\tfor (i = 0; i < eqhw->this04; i++)\n\t\tpeaks[i] = hwread(vortex->mmio, 0x2B024 + i * 0x30);\n\tfor (i = 0; i < eqhw->this04; i++)\n\t\tpeaks[i + eqhw->this04] =\n\t\t    hwread(vortex->mmio, 0x2B204 + i * 0x30);\n}\n\n \n\nstatic int vortex_Eqlzr_GetLeftGain(vortex_t * vortex, u16 index, u16 * gain)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tif (eq->this28) {\n\t\t*gain = eq->this130[index];\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void vortex_Eqlzr_SetLeftGain(vortex_t * vortex, u16 index, u16 gain)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tif (eq->this28 == 0)\n\t\treturn;\n\n\teq->this130[index] = gain;\n\tif (eq->this54)\n\t\treturn;\n\n\tvortex_EqHw_SetLeftGainsSingleTarget(vortex, index, gain);\n}\n\nstatic int vortex_Eqlzr_GetRightGain(vortex_t * vortex, u16 index, u16 * gain)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tif (eq->this28) {\n\t\t*gain = eq->this130[index + eq->this10];\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void vortex_Eqlzr_SetRightGain(vortex_t * vortex, u16 index, u16 gain)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tif (eq->this28 == 0)\n\t\treturn;\n\n\teq->this130[index + eq->this10] = gain;\n\tif (eq->this54)\n\t\treturn;\n\n\tvortex_EqHw_SetRightGainsSingleTarget(vortex, index, gain);\n}\n\n#if 0\nstatic int\nvortex_Eqlzr_GetAllBands(vortex_t * vortex, u16 * gains, s32 *cnt)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\tint si = 0;\n\n\tif (eq->this10 == 0)\n\t\treturn 1;\n\n\t{\n\t\tif (vortex_Eqlzr_GetLeftGain(vortex, si, &gains[si]))\n\t\t\treturn 1;\n\t\tif (vortex_Eqlzr_GetRightGain\n\t\t    (vortex, si, &gains[si + eq->this10]))\n\t\t\treturn 1;\n\t\tsi++;\n\t}\n\twhile (eq->this10 > si) ;\n\t*cnt = si * 2;\n\treturn 0;\n}\n#endif\nstatic int vortex_Eqlzr_SetAllBandsFromActiveCoeffSet(vortex_t * vortex)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tvortex_EqHw_SetLeftGainsTarget(vortex, eq->this130);\n\tvortex_EqHw_SetRightGainsTarget(vortex, &(eq->this130[eq->this10]));\n\n\treturn 0;\n}\n\nstatic int\nvortex_Eqlzr_SetAllBands(vortex_t *vortex, const u16 gains[], s32 count)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\tint i;\n\n\tif (((eq->this10) * 2 != count) || (eq->this28 == 0))\n\t\treturn 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\teq->this130[i] = gains[i];\n\t}\n\t\n\tif (eq->this54)\n\t\treturn 0;\n\treturn vortex_Eqlzr_SetAllBandsFromActiveCoeffSet(vortex);\n}\n\nstatic void\nvortex_Eqlzr_SetA3dBypassGain(vortex_t * vortex, u32 a, u32 b)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\tu32 eax, ebx;\n\n\teq->this58 = a;\n\teq->this5c = b;\n\tif (eq->this54)\n\t\teax = eq->this0e;\n\telse\n\t\teax = eq->this0a;\n\tebx = (eax * eq->this58) >> 0x10;\n\teax = (eax * eq->this5c) >> 0x10;\n\tvortex_EqHw_SetA3DBypassGain(vortex, ebx, eax);\n}\n\nstatic void vortex_Eqlzr_ProgramA3dBypassGain(vortex_t * vortex)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\tu32 eax, ebx;\n\n\tif (eq->this54)\n\t\teax = eq->this0e;\n\telse\n\t\teax = eq->this0a;\n\tebx = (eax * eq->this58) >> 0x10;\n\teax = (eax * eq->this5c) >> 0x10;\n\tvortex_EqHw_SetA3DBypassGain(vortex, ebx, eax);\n}\n\nstatic void vortex_Eqlzr_ShutDownA3d(vortex_t * vortex)\n{\n\tif (vortex != NULL)\n\t\tvortex_EqHw_ZeroA3DIO(vortex);\n}\n\nstatic void vortex_Eqlzr_SetBypass(vortex_t * vortex, u32 bp)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\t\n\tif ((eq->this28) && (bp == 0)) {\n\t\t \n\t\tvortex_Eqlzr_SetAllBandsFromActiveCoeffSet(vortex);\n\t\tvortex_EqHw_SetBypassGain(vortex, eq->this08, eq->this08);\n\t} else {\n\t\t \n\t\tvortex_EqHw_SetLeftGainsTarget(vortex, eq->this14_array);\n\t\tvortex_EqHw_SetRightGainsTarget(vortex, eq->this14_array);\n\t\tvortex_EqHw_SetBypassGain(vortex, eq->this0c, eq->this0c);\n\t}\n\tvortex_Eqlzr_ProgramA3dBypassGain(vortex);\n}\n\nstatic void vortex_Eqlzr_ReadAndSetActiveCoefSet(vortex_t * vortex)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\t \n\tmemcpy(&(eq->coefset), &asEqCoefsNormal, sizeof(auxxEqCoeffSet_t));\n\t \n\tvortex_Eqlzr_SetAllBands(vortex, eq_gains_normal, eq->this10 * 2);\n}\n\nstatic int vortex_Eqlzr_GetAllPeaks(vortex_t * vortex, u16 * peaks, int *count)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\tif (eq->this10 == 0)\n\t\treturn 1;\n\t*count = eq->this10 * 2;\n\tvortex_EqHw_GetTenBandLevels(vortex, peaks);\n\treturn 0;\n}\n\n#if 0\nstatic auxxEqCoeffSet_t *vortex_Eqlzr_GetActiveCoefSet(vortex_t * vortex)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\treturn (&(eq->coefset));\n}\n#endif\nstatic void vortex_Eqlzr_init(vortex_t * vortex)\n{\n\teqlzr_t *eq = &(vortex->eq);\n\n\t \n\t\n\teq->this08 = 0;\t\t \n\teq->this0a = 0x5999;\n\teq->this0c = 0x5999;\t \n\teq->this0e = 0x5999;\n\n\teq->this10 = 0xa;\t \n\teq->this04.this04 = eq->this10;\n\teq->this28 = 0x1;\t \n\teq->this54 = 0x0;\t \n\teq->this58 = 0xffff;\n\teq->this5c = 0xffff;\n\n\t \n\tmemset(eq->this14_array, 0, sizeof(eq->this14_array));\n\n\t \n\tvortex_EqHw_ZeroState(vortex);\n\tvortex_EqHw_SetSampleRate(vortex, 0x11);\n\tvortex_Eqlzr_ReadAndSetActiveCoefSet(vortex);\n\n\tvortex_EqHw_Program10Band(vortex, &(eq->coefset));\n\tvortex_Eqlzr_SetBypass(vortex, eq->this54);\n\tvortex_Eqlzr_SetA3dBypassGain(vortex, 0, 0);\n\tvortex_EqHw_Enable(vortex);\n}\n\nstatic void vortex_Eqlzr_shutdown(vortex_t * vortex)\n{\n\tvortex_Eqlzr_ShutDownA3d(vortex);\n\tvortex_EqHw_ProgramPipe(vortex);\n\tvortex_EqHw_Disable(vortex);\n}\n\n \n\n \n#define snd_vortex_eqtoggle_info\tsnd_ctl_boolean_mono_info\n\nstatic int\nsnd_vortex_eqtoggle_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\teqlzr_t *eq = &(vortex->eq);\n\t\n\n\tucontrol->value.integer.value[0] = eq->this54 ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_eqtoggle_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\teqlzr_t *eq = &(vortex->eq);\n\t\n\n\teq->this54 = ucontrol->value.integer.value[0] ? 0 : 1;\n\tvortex_Eqlzr_SetBypass(vortex, eq->this54);\n\n\treturn 1;\t\t \n}\n\nstatic const struct snd_kcontrol_new vortex_eqtoggle_kcontrol = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"EQ Enable\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info = snd_vortex_eqtoggle_info,\n\t.get = snd_vortex_eqtoggle_get,\n\t.put = snd_vortex_eqtoggle_put\n};\n\nstatic int\nsnd_vortex_eq_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0x0000;\n\tuinfo->value.integer.max = 0x7fff;\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_eq_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint i = kcontrol->private_value;\n\tu16 gainL = 0, gainR = 0;\n\n\tvortex_Eqlzr_GetLeftGain(vortex, i, &gainL);\n\tvortex_Eqlzr_GetRightGain(vortex, i, &gainR);\n\tucontrol->value.integer.value[0] = gainL;\n\tucontrol->value.integer.value[1] = gainR;\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_eq_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint changed = 0, i = kcontrol->private_value;\n\tu16 gainL = 0, gainR = 0;\n\n\tvortex_Eqlzr_GetLeftGain(vortex, i, &gainL);\n\tvortex_Eqlzr_GetRightGain(vortex, i, &gainR);\n\n\tif (gainL != ucontrol->value.integer.value[0]) {\n\t\tvortex_Eqlzr_SetLeftGain(vortex, i,\n\t\t\t\t\t ucontrol->value.integer.value[0]);\n\t\tchanged = 1;\n\t}\n\tif (gainR != ucontrol->value.integer.value[1]) {\n\t\tvortex_Eqlzr_SetRightGain(vortex, i,\n\t\t\t\t\t  ucontrol->value.integer.value[1]);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new vortex_eq_kcontrol = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"                        .\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info = snd_vortex_eq_info,\n\t.get = snd_vortex_eq_get,\n\t.put = snd_vortex_eq_put\n};\n\nstatic int\nsnd_vortex_peaks_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 20;\n\tuinfo->value.integer.min = 0x0000;\n\tuinfo->value.integer.max = 0x7fff;\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_peaks_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tvortex_t *vortex = snd_kcontrol_chip(kcontrol);\n\tint i, count = 0;\n\tu16 peaks[20];\n\n\tvortex_Eqlzr_GetAllPeaks(vortex, peaks, &count);\n\tif (count != 20) {\n\t\tdev_err(vortex->card->dev,\n\t\t\t\"peak count error 20 != %d\\n\", count);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < 20; i++)\n\t\tucontrol->value.integer.value[i] = peaks[i];\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vortex_levels_kcontrol = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"EQ Peaks\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info = snd_vortex_peaks_info,\n\t.get = snd_vortex_peaks_get,\n};\n\n \nstatic const char * const EqBandLabels[10] = {\n\t\"EQ0 31Hz\\0\",\n\t\"EQ1 63Hz\\0\",\n\t\"EQ2 125Hz\\0\",\n\t\"EQ3 250Hz\\0\",\n\t\"EQ4 500Hz\\0\",\n\t\"EQ5 1KHz\\0\",\n\t\"EQ6 2KHz\\0\",\n\t\"EQ7 4KHz\\0\",\n\t\"EQ8 8KHz\\0\",\n\t\"EQ9 16KHz\\0\",\n};\n\n \nstatic int vortex_eq_init(vortex_t *vortex)\n{\n\tstruct snd_kcontrol *kcontrol;\n\tint err, i;\n\n\tvortex_Eqlzr_init(vortex);\n\n\tkcontrol = snd_ctl_new1(&vortex_eqtoggle_kcontrol, vortex);\n\tif (!kcontrol)\n\t\treturn -ENOMEM;\n\tkcontrol->private_value = 0;\n\terr = snd_ctl_add(vortex->card, kcontrol);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tkcontrol = snd_ctl_new1(&vortex_eq_kcontrol, vortex);\n\t\tif (!kcontrol)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(kcontrol->id.name, sizeof(kcontrol->id.name),\n\t\t\t\"%s Playback Volume\", EqBandLabels[i]);\n\t\tkcontrol->private_value = i;\n\t\terr = snd_ctl_add(vortex->card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t\n\t}\n\t \n\tkcontrol = snd_ctl_new1(&vortex_levels_kcontrol, vortex);\n\tif (!kcontrol)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(vortex->card, kcontrol);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int vortex_eq_free(vortex_t * vortex)\n{\n\t \n\tvortex_Eqlzr_shutdown(vortex);\n\treturn 0;\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}