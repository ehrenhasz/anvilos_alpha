{
  "module_name": "au88x0_a3d.c",
  "hash_id": "0c30df6f57e21e975e88d6511f835aebf8751627d9650ce7642efa9ea77ecd8f",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0_a3d.c",
  "human_readable_source": "\n \n\n \n\n#include \"au88x0_a3d.h\"\n#include \"au88x0_a3ddata.c\"\n#include \"au88x0_xtalk.h\"\n#include \"au88x0.h\"\n\nstatic void\na3dsrc_SetTimeConsts(a3dsrc_t * a, short HrtfTrack, short ItdTrack,\n\t\t     short GTrack, short CTrack)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_HrtfTrackTC), HrtfTrack);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_ITDTrackTC), ItdTrack);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_GainTrackTC), GTrack);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_CoeffTrackTC), CTrack);\n}\n\n#if 0\nstatic void\na3dsrc_GetTimeConsts(a3dsrc_t * a, short *HrtfTrack, short *ItdTrack,\n\t\t     short *GTrack, short *CTrack)\n{\n\t\n}\n\n#endif\n \n\nstatic void\na3dsrc_SetAtmosTarget(a3dsrc_t * a, short aa, short b, short c, short d,\n\t\t      short e)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_A21Target),\n\t\t(e << 0x10) | d);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_B10Target),\n\t\t(b << 0x10) | aa);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_B2Target), c);\n}\n\nstatic void\na3dsrc_SetAtmosCurrent(a3dsrc_t * a, short aa, short b, short c, short d,\n\t\t       short e)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_A12Current),\n\t\t(e << 0x10) | d);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_B01Current),\n\t\t(b << 0x10) | aa);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_B2Current), c);\n}\n\nstatic void\na3dsrc_SetAtmosState(a3dsrc_t * a, short x1, short x2, short y1, short y2)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, a3d_addrA(a->slice, a->source, A3D_A_x1), x1);\n\thwwrite(vortex->mmio, a3d_addrA(a->slice, a->source, A3D_A_x2), x2);\n\thwwrite(vortex->mmio, a3d_addrA(a->slice, a->source, A3D_A_y1), y1);\n\thwwrite(vortex->mmio, a3d_addrA(a->slice, a->source, A3D_A_y2), y2);\n}\n\n#if 0\nstatic void\na3dsrc_GetAtmosTarget(a3dsrc_t * a, short *aa, short *b, short *c,\n\t\t      short *d, short *e)\n{\n}\nstatic void\na3dsrc_GetAtmosCurrent(a3dsrc_t * a, short *bb01, short *ab01, short *b2,\n\t\t       short *aa12, short *ba12)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*aa12 =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_A12Current));\n\t*ba12 =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_A12Current));\n\t*ab01 =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_B01Current));\n\t*bb01 =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_B01Current));\n\t*b2 =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_B2Current));\n}\n\nstatic void\na3dsrc_GetAtmosState(a3dsrc_t * a, short *x1, short *x2, short *y1, short *y2)\n{\n\n}\n\n#endif\n \n\nstatic void\na3dsrc_SetHrtfTarget(a3dsrc_t * a, a3d_Hrtf_t const aa, a3d_Hrtf_t const b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\ta3d_addrB(a->slice, a->source,\n\t\t\t\t  A3D_B_HrtfTarget) + (i << 2),\n\t\t\t(b[i] << 0x10) | aa[i]);\n}\n\nstatic void\na3dsrc_SetHrtfCurrent(a3dsrc_t * a, a3d_Hrtf_t const aa, a3d_Hrtf_t const b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\ta3d_addrB(a->slice, a->source,\n\t\t\t\t  A3D_B_HrtfCurrent) + (i << 2),\n\t\t\t(b[i] << 0x10) | aa[i]);\n}\n\nstatic void\na3dsrc_SetHrtfState(a3dsrc_t * a, a3d_Hrtf_t const aa, a3d_Hrtf_t const b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\ta3d_addrB(a->slice, a->source,\n\t\t\t\t  A3D_B_HrtfDelayLine) + (i << 2),\n\t\t\t(b[i] << 0x10) | aa[i]);\n}\n\nstatic void a3dsrc_SetHrtfOutput(a3dsrc_t * a, short left, short right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_HrtfOutL), left);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrA(a->slice, a->source, A3D_A_HrtfOutR), right);\n}\n\n#if 0\nstatic void a3dsrc_GetHrtfTarget(a3dsrc_t * a, a3d_Hrtf_t aa, a3d_Hrtf_t b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\taa[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrA(a->slice, a->source,\n\t\t\t\t     A3D_A_HrtfTarget + (i << 2)));\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\tb[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrB(a->slice, a->source,\n\t\t\t\t     A3D_B_HrtfTarget + (i << 2)));\n}\n\nstatic void a3dsrc_GetHrtfCurrent(a3dsrc_t * a, a3d_Hrtf_t aa, a3d_Hrtf_t b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\taa[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrA(a->slice, a->source,\n\t\t\t\t     A3D_A_HrtfCurrent + (i << 2)));\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\tb[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrB(a->slice, a->source,\n\t\t\t\t     A3D_B_HrtfCurrent + (i << 2)));\n}\n\nstatic void a3dsrc_GetHrtfState(a3dsrc_t * a, a3d_Hrtf_t aa, a3d_Hrtf_t b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\t\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\taa[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrA(a->slice, a->source,\n\t\t\t\t     A3D_A_HrtfDelayLine + (i << 2)));\n\tfor (i = 0; i < HRTF_SZ; i++)\n\t\tb[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrB(a->slice, a->source,\n\t\t\t\t     A3D_B_HrtfDelayLine + (i << 2)));\n}\n\nstatic void a3dsrc_GetHrtfOutput(a3dsrc_t * a, short *left, short *right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*left =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_HrtfOutL));\n\t*right =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_HrtfOutR));\n}\n\n#endif\n\n \nstatic void a3dsrc_SetItdTarget(a3dsrc_t * a, short litd, short ritd)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\n\tif (litd < 0)\n\t\tlitd = 0;\n\tif (litd > 0x57FF)\n\t\tlitd = 0x57FF;\n\tif (ritd < 0)\n\t\tritd = 0;\n\tif (ritd > 0x57FF)\n\t\tritd = 0x57FF;\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_ITDTarget),\n\t\t(ritd << 0x10) | litd);\n\t\n}\n\nstatic void a3dsrc_SetItdCurrent(a3dsrc_t * a, short litd, short ritd)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\n\tif (litd < 0)\n\t\tlitd = 0;\n\tif (litd > 0x57FF)\n\t\tlitd = 0x57FF;\n\tif (ritd < 0)\n\t\tritd = 0;\n\tif (ritd > 0x57FF)\n\t\tritd = 0x57FF;\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_ITDCurrent),\n\t\t(ritd << 0x10) | litd);\n\t\n}\n\nstatic void a3dsrc_SetItdDline(a3dsrc_t * a, a3d_ItdDline_t const dline)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\t \n\tfor (i = 0; i < DLINE_SZ; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\ta3d_addrA(a->slice, a->source,\n\t\t\t\t  A3D_A_ITDDelayLine) + (i << 2), dline[i]);\n}\n\n#if 0\nstatic void a3dsrc_GetItdTarget(a3dsrc_t * a, short *litd, short *ritd)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*ritd =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_ITDTarget));\n\t*litd =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_ITDTarget));\n}\n\nstatic void a3dsrc_GetItdCurrent(a3dsrc_t * a, short *litd, short *ritd)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\n\t*ritd =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_ITDCurrent));\n\t*litd =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_ITDCurrent));\n}\n\nstatic void a3dsrc_GetItdDline(a3dsrc_t * a, a3d_ItdDline_t dline)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < DLINE_SZ; i++)\n\t\tdline[i] =\n\t\t    hwread(vortex->mmio,\n\t\t\t   a3d_addrA(a->slice, a->source,\n\t\t\t\t     A3D_A_ITDDelayLine + (i << 2)));\n}\n\n#endif\n \n\nstatic void a3dsrc_SetGainTarget(a3dsrc_t * a, short left, short right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_GainTarget),\n\t\t(right << 0x10) | left);\n}\n\nstatic void a3dsrc_SetGainCurrent(a3dsrc_t * a, short left, short right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrB(a->slice, a->source, A3D_B_GainCurrent),\n\t\t(right << 0x10) | left);\n}\n\n#if 0\nstatic void a3dsrc_GetGainTarget(a3dsrc_t * a, short *left, short *right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*right =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_GainTarget));\n\t*left =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_GainTarget));\n}\n\nstatic void a3dsrc_GetGainCurrent(a3dsrc_t * a, short *left, short *right)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*right =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrA(a->slice, a->source, A3D_A_GainCurrent));\n\t*left =\n\t    hwread(vortex->mmio,\n\t\t   a3d_addrB(a->slice, a->source, A3D_B_GainCurrent));\n}\n\n \nstatic void CA3dIO_WriteReg(a3dsrc_t * a, unsigned long addr, short aa, short b)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, addr, (aa << 0x10) | b);\n}\n\n#endif\n \n\nstatic void a3dsrc_SetA3DSampleRate(a3dsrc_t * a, int sr)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint esp0 = 0;\n\n\tesp0 = (((esp0 & 0x7fffffff) | 0xB8000000) & 0x7) | ((sr & 0x1f) << 3);\n\thwwrite(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd), esp0);\n\t\n}\n\nstatic void a3dsrc_EnableA3D(a3dsrc_t * a)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd),\n\t\t0xF0000001);\n\t\n}\n\nstatic void a3dsrc_DisableA3D(a3dsrc_t * a)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd),\n\t\t0xF0000000);\n}\n\nstatic void a3dsrc_SetA3DControlReg(a3dsrc_t * a, unsigned long ctrl)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd), ctrl);\n}\n\nstatic void a3dsrc_SetA3DPointerReg(a3dsrc_t * a, unsigned long ptr)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\thwwrite(vortex->mmio, A3D_SLICE_Pointers + ((a->slice) << 0xd), ptr);\n}\n\n#if 0\nstatic void a3dsrc_GetA3DSampleRate(a3dsrc_t * a, int *sr)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*sr = ((hwread(vortex->mmio, A3D_SLICE_Control + (a->slice << 0xd))\n\t\t>> 3) & 0x1f);\n\t\n}\n\nstatic void a3dsrc_GetA3DControlReg(a3dsrc_t * a, unsigned long *ctrl)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*ctrl = hwread(vortex->mmio, A3D_SLICE_Control + ((a->slice) << 0xd));\n}\n\nstatic void a3dsrc_GetA3DPointerReg(a3dsrc_t * a, unsigned long *ptr)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\t*ptr = hwread(vortex->mmio, A3D_SLICE_Pointers + ((a->slice) << 0xd));\n}\n\n#endif\nstatic void a3dsrc_ZeroSliceIO(a3dsrc_t * a)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\tA3D_SLICE_VDBDest +\n\t\t\t((((a->slice) << 0xb) + i) << 2), 0);\n\tfor (i = 0; i < 4; i++)\n\t\thwwrite(vortex->mmio,\n\t\t\tA3D_SLICE_VDBSource +\n\t\t\t((((a->slice) << 0xb) + i) << 2), 0);\n}\n\n \nstatic void a3dsrc_ZeroState(a3dsrc_t * a)\n{\n\t \n\ta3dsrc_SetAtmosState(a, 0, 0, 0, 0);\n\ta3dsrc_SetHrtfState(a, A3dHrirZeros, A3dHrirZeros);\n\ta3dsrc_SetItdDline(a, A3dItdDlineZeros);\n\ta3dsrc_SetHrtfOutput(a, 0, 0);\n\ta3dsrc_SetTimeConsts(a, 0, 0, 0, 0);\n\n\ta3dsrc_SetAtmosCurrent(a, 0, 0, 0, 0, 0);\n\ta3dsrc_SetAtmosTarget(a, 0, 0, 0, 0, 0);\n\ta3dsrc_SetItdCurrent(a, 0, 0);\n\ta3dsrc_SetItdTarget(a, 0, 0);\n\ta3dsrc_SetGainCurrent(a, 0, 0);\n\ta3dsrc_SetGainTarget(a, 0, 0);\n\n\ta3dsrc_SetHrtfCurrent(a, A3dHrirZeros, A3dHrirZeros);\n\ta3dsrc_SetHrtfTarget(a, A3dHrirZeros, A3dHrirZeros);\n}\n\n \nstatic void a3dsrc_ZeroStateA3D(a3dsrc_t *a, vortex_t *v)\n{\n\tint i, var, var2;\n\n\tif ((a->vortex) == NULL) {\n\t\tdev_err(v->card->dev,\n\t\t\t\"ZeroStateA3D: ERROR: a->vortex is NULL\\n\");\n\t\treturn;\n\t}\n\n\ta3dsrc_SetA3DControlReg(a, 0);\n\ta3dsrc_SetA3DPointerReg(a, 0);\n\n\tvar = a->slice;\n\tvar2 = a->source;\n\tfor (i = 0; i < 4; i++) {\n\t\ta->slice = i;\n\t\ta3dsrc_ZeroSliceIO(a);\n\t\t\n\t}\n\ta->source = var2;\n\ta->slice = var;\n}\n\n \nstatic void a3dsrc_ProgramPipe(a3dsrc_t * a)\n{\n\ta3dsrc_SetTimeConsts(a, 0, 0, 0, 0);\n\ta3dsrc_SetAtmosCurrent(a, 0, 0x4000, 0, 0, 0);\n\ta3dsrc_SetAtmosTarget(a, 0x4000, 0, 0, 0, 0);\n\ta3dsrc_SetItdCurrent(a, 0, 0);\n\ta3dsrc_SetItdTarget(a, 0, 0);\n\ta3dsrc_SetGainCurrent(a, 0x7fff, 0x7fff);\n\ta3dsrc_SetGainTarget(a, 0x7fff, 0x7fff);\n\n\t \n\n\t \n\ta3dsrc_SetHrtfCurrent(a, A3dHrirImpulse, A3dHrirImpulse);\n\ta3dsrc_SetHrtfTarget(a, A3dHrirImpulse, A3dHrirImpulse);\n\n\t \n\t\n\t\n}\n\n \n#if 0\nstatic void a3dsrc_ClearVDBData(a3dsrc_t * a, unsigned long aa)\n{\n\tvortex_t *vortex = (vortex_t *) (a->vortex);\n\n\t\n\thwwrite(vortex->mmio,\n\t\ta3d_addrS(a->slice, A3D_SLICE_VDBDest) + (a->source << 2), 0);\n\thwwrite(vortex->mmio,\n\t\ta3d_addrS(a->slice,\n\t\t\t  A3D_SLICE_VDBDest + 4) + (a->source << 2), 0);\n\t \n}\n#endif\n\n \n\nstatic void vortex_A3dSourceHw_Initialize(vortex_t * v, int source, int slice)\n{\n\ta3dsrc_t *a3dsrc = &(v->a3d[source + (slice * 4)]);\n\t\n\n\ta3dsrc->vortex = (void *)v;\n\ta3dsrc->source = source;\t \n\ta3dsrc->slice = slice;\t \n\ta3dsrc_ZeroState(a3dsrc);\n\t \n\ta3dsrc_SetA3DSampleRate(a3dsrc, 0x11);\n}\n\nstatic int Vort3DRend_Initialize(vortex_t * v, unsigned short mode)\n{\n\tv->xt_mode = mode;\t \n\n\tvortex_XtalkHw_init(v);\n\tvortex_XtalkHw_SetGainsAllChan(v);\n\tswitch (v->xt_mode) {\n\tcase XT_SPEAKER0:\n\t\tvortex_XtalkHw_ProgramXtalkNarrow(v);\n\t\tbreak;\n\tcase XT_SPEAKER1:\n\t\tvortex_XtalkHw_ProgramXtalkWide(v);\n\t\tbreak;\n\tdefault:\n\tcase XT_HEADPHONE:\n\t\tvortex_XtalkHw_ProgramPipe(v);\n\t\tbreak;\n\tcase XT_DIAMOND:\n\t\tvortex_XtalkHw_ProgramDiamondXtalk(v);\n\t\tbreak;\n\t}\n\tvortex_XtalkHw_SetSampleRate(v, 0x11);\n\tvortex_XtalkHw_Enable(v);\n\treturn 0;\n}\n\n \n\nstatic int vortex_a3d_register_controls(vortex_t * vortex);\nstatic void vortex_a3d_unregister_controls(vortex_t * vortex);\n \nstatic void vortex_Vort3D_enable(vortex_t *v)\n{\n\tint i;\n\n\tVort3DRend_Initialize(v, XT_HEADPHONE);\n\tfor (i = 0; i < NR_A3D; i++) {\n\t\tvortex_A3dSourceHw_Initialize(v, i % 4, i >> 2);\n\t\ta3dsrc_ZeroStateA3D(&v->a3d[0], v);\n\t}\n\t \n\tvortex_a3d_register_controls(v);\n}\n\nstatic void vortex_Vort3D_disable(vortex_t * v)\n{\n\tvortex_XtalkHw_Disable(v);\n\tvortex_a3d_unregister_controls(v);\n}\n\n \nstatic void vortex_Vort3D_connect(vortex_t * v, int en)\n{\n\tint i;\n\t\n\n#ifdef CHIP_AU8810\n\treturn;\n#endif\n\t\n#if 1\n\t \n\tv->mixxtlk[0] =\n\t    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);\n\tif (v->mixxtlk[0] < 0) {\n\t\tdev_warn(v->card->dev,\n\t\t\t \"vortex_Vort3D: ERROR: not enough free mixer resources.\\n\");\n\t\treturn;\n\t}\n\tv->mixxtlk[1] =\n\t    vortex_adb_checkinout(v, v->fixed_res, en, VORTEX_RESOURCE_MIXIN);\n\tif (v->mixxtlk[1] < 0) {\n\t\tdev_warn(v->card->dev,\n\t\t\t \"vortex_Vort3D: ERROR: not enough free mixer resources.\\n\");\n\t\treturn;\n\t}\n#endif\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\t\n\t\tvortex_route(v, en, 0x11, ADB_A3DOUT(i * 2), ADB_XTALKIN(i));\n\t\tvortex_route(v, en, 0x11, ADB_A3DOUT(i * 2) + 1, ADB_XTALKIN(5 + i));\n\t}\n#if 0\n\tvortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_EQIN(2));\n\tvortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_EQIN(3));\n#else\n\t \n\tvortex_route(v, en, 0x11, ADB_XTALKOUT(0), ADB_MIXIN(v->mixxtlk[0]));\n\tvortex_route(v, en, 0x11, ADB_XTALKOUT(1), ADB_MIXIN(v->mixxtlk[1]));\n\tvortex_connection_mixin_mix(v, en, v->mixxtlk[0], v->mixplayb[0], 0);\n\tvortex_connection_mixin_mix(v, en, v->mixxtlk[1], v->mixplayb[1], 0);\n\tvortex_mix_setinputvolumebyte(v, v->mixplayb[0], v->mixxtlk[0],\n\t\t\t\t      en ? MIX_DEFIGAIN : VOL_MIN);\n\tvortex_mix_setinputvolumebyte(v, v->mixplayb[1], v->mixxtlk[1],\n\t\t\t\t      en ? MIX_DEFIGAIN : VOL_MIN);\n\tif (VORTEX_IS_QUAD(v)) {\n\t\tvortex_connection_mixin_mix(v, en, v->mixxtlk[0],\n\t\t\t\t\t    v->mixplayb[2], 0);\n\t\tvortex_connection_mixin_mix(v, en, v->mixxtlk[1],\n\t\t\t\t\t    v->mixplayb[3], 0);\n\t\tvortex_mix_setinputvolumebyte(v, v->mixplayb[2],\n\t\t\t\t\t      v->mixxtlk[0],\n\t\t\t\t\t      en ? MIX_DEFIGAIN : VOL_MIN);\n\t\tvortex_mix_setinputvolumebyte(v, v->mixplayb[3],\n\t\t\t\t\t      v->mixxtlk[1],\n\t\t\t\t\t      en ? MIX_DEFIGAIN : VOL_MIN);\n\t}\n#endif\n}\n\n \nstatic void vortex_Vort3D_InitializeSource(a3dsrc_t *a, int en, vortex_t *v)\n{\n\tif (a->vortex == NULL) {\n\t\tdev_warn(v->card->dev,\n\t\t\t \"Vort3D_InitializeSource: A3D source not initialized\\n\");\n\t\treturn;\n\t}\n\tif (en) {\n\t\ta3dsrc_ProgramPipe(a);\n\t\ta3dsrc_SetA3DSampleRate(a, 0x11);\n\t\ta3dsrc_SetTimeConsts(a, HrtfTCDefault,\n\t\t\t\t     ItdTCDefault, GainTCDefault,\n\t\t\t\t     CoefTCDefault);\n\t\t \n\t\t\n\t\t\n\t\ta3dsrc_EnableA3D(a);\n\t} else {\n\t\ta3dsrc_DisableA3D(a);\n\t\ta3dsrc_ZeroState(a);\n\t}\n}\n\n \n\nstatic void vortex_a3d_coord2hrtf(a3d_Hrtf_t hrtf, int *coord)\n{\n\t \n\n}\nstatic void vortex_a3d_coord2itd(a3d_Itd_t itd, int *coord)\n{\n\t \n\n}\nstatic void vortex_a3d_coord2ild(a3d_LRGains_t ild, int left, int right)\n{\n\t \n\n}\nstatic void vortex_a3d_translate_filter(a3d_atmos_t filter, int *params)\n{\n\t \n\n}\n\n \n\nstatic int\nsnd_vortex_a3d_hrtf_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 6;\n\tuinfo->value.integer.min = 0x00000000;\n\tuinfo->value.integer.max = 0xffffffff;\n\treturn 0;\n}\nstatic int\nsnd_vortex_a3d_itd_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0x00000000;\n\tuinfo->value.integer.max = 0xffffffff;\n\treturn 0;\n}\nstatic int\nsnd_vortex_a3d_ild_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0x00000000;\n\tuinfo->value.integer.max = 0xffffffff;\n\treturn 0;\n}\nstatic int\nsnd_vortex_a3d_filter_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 4;\n\tuinfo->value.integer.min = 0x00000000;\n\tuinfo->value.integer.max = 0xffffffff;\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_a3d_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\t\n\t \n\n\treturn 0;\n}\n\nstatic int\nsnd_vortex_a3d_hrtf_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\ta3dsrc_t *a = kcontrol->private_data;\n\tint i;\n\tint coord[6];\n\tfor (i = 0; i < 6; i++)\n\t\tcoord[i] = ucontrol->value.integer.value[i];\n\t \n\tvortex_a3d_coord2hrtf(a->hrtf[0], coord);\n\tvortex_a3d_coord2hrtf(a->hrtf[1], coord);\n\ta3dsrc_SetHrtfTarget(a, a->hrtf[0], a->hrtf[1]);\n\ta3dsrc_SetHrtfCurrent(a, a->hrtf[0], a->hrtf[1]);\n\treturn 1;\n}\n\nstatic int\nsnd_vortex_a3d_itd_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\ta3dsrc_t *a = kcontrol->private_data;\n\tint coord[6];\n\tint i;\n\tfor (i = 0; i < 6; i++)\n\t\tcoord[i] = ucontrol->value.integer.value[i];\n\t \n\tvortex_a3d_coord2itd(a->hrtf[0], coord);\n\tvortex_a3d_coord2itd(a->hrtf[1], coord);\n\t \n\ta3dsrc_SetItdTarget(a, a->itd[0], a->itd[1]);\n\ta3dsrc_SetItdCurrent(a, a->itd[0], a->itd[1]);\n\ta3dsrc_SetItdDline(a, a->dline);\n\treturn 1;\n}\n\nstatic int\nsnd_vortex_a3d_ild_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\ta3dsrc_t *a = kcontrol->private_data;\n\tint l, r;\n\t \n\tl = ucontrol->value.integer.value[0];\n\tr = ucontrol->value.integer.value[1];\n\tvortex_a3d_coord2ild(a->ild, l, r);\n\t \n\ta3dsrc_SetGainTarget(a, l, r);\n\ta3dsrc_SetGainCurrent(a, l, r);\n\treturn 1;\n}\n\nstatic int\nsnd_vortex_a3d_filter_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\ta3dsrc_t *a = kcontrol->private_data;\n\tint i;\n\tint params[6];\n\tfor (i = 0; i < 6; i++)\n\t\tparams[i] = ucontrol->value.integer.value[i];\n\t \n\tvortex_a3d_translate_filter(a->filter, params);\n\t \n\ta3dsrc_SetAtmosTarget(a, a->filter[0],\n\t\t\t      a->filter[1], a->filter[2],\n\t\t\t      a->filter[3], a->filter[4]);\n\ta3dsrc_SetAtmosCurrent(a, a->filter[0],\n\t\t\t       a->filter[1], a->filter[2],\n\t\t\t       a->filter[3], a->filter[4]);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new vortex_a3d_kcontrol = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"Playback PCM advanced processing\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_vortex_a3d_hrtf_info,\n\t.get = snd_vortex_a3d_get,\n\t.put = snd_vortex_a3d_hrtf_put,\n};\n\n \nstatic int vortex_a3d_register_controls(vortex_t *vortex)\n{\n\tstruct snd_kcontrol *kcontrol;\n\tint err, i;\n\t \n\tfor (i = 0; i < NR_A3D; i++) {\n\t\tkcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);\n\t\tif (!kcontrol)\n\t\t\treturn -ENOMEM;\n\t\tkcontrol->id.numid = CTRLID_HRTF;\n\t\tkcontrol->info = snd_vortex_a3d_hrtf_info;\n\t\tkcontrol->put = snd_vortex_a3d_hrtf_put;\n\t\terr = snd_ctl_add(vortex->card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tfor (i = 0; i < NR_A3D; i++) {\n\t\tkcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);\n\t\tif (!kcontrol)\n\t\t\treturn -ENOMEM;\n\t\tkcontrol->id.numid = CTRLID_ITD;\n\t\tkcontrol->info = snd_vortex_a3d_itd_info;\n\t\tkcontrol->put = snd_vortex_a3d_itd_put;\n\t\terr = snd_ctl_add(vortex->card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tfor (i = 0; i < NR_A3D; i++) {\n\t\tkcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);\n\t\tif (!kcontrol)\n\t\t\treturn -ENOMEM;\n\t\tkcontrol->id.numid = CTRLID_GAINS;\n\t\tkcontrol->info = snd_vortex_a3d_ild_info;\n\t\tkcontrol->put = snd_vortex_a3d_ild_put;\n\t\terr = snd_ctl_add(vortex->card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tfor (i = 0; i < NR_A3D; i++) {\n\t\tkcontrol = snd_ctl_new1(&vortex_a3d_kcontrol, &vortex->a3d[i]);\n\t\tif (!kcontrol)\n\t\t\treturn -ENOMEM;\n\t\tkcontrol->id.numid = CTRLID_FILTER;\n\t\tkcontrol->info = snd_vortex_a3d_filter_info;\n\t\tkcontrol->put = snd_vortex_a3d_filter_put;\n\t\terr = snd_ctl_add(vortex->card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void vortex_a3d_unregister_controls(vortex_t * vortex)\n{\n\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}