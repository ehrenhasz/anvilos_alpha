{
  "module_name": "au88x0_core.c",
  "hash_id": "6c8f7fc3f24f195f0af8d5bfd5e705ec1ec20b5c3fb89f08b48dd1cd557d3e88",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0_core.c",
  "human_readable_source": "\n \n\n \n\n#include \"au88x0.h\"\n#include \"au88x0_a3d.h\"\n#include <linux/delay.h>\n\n \n\n\nstatic int mchannels[NR_MIXIN];\nstatic int rampchs[NR_MIXIN];\n\nstatic void vortex_mixer_en_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_MIXER_SR,\n\t\thwread(vortex->mmio, VORTEX_MIXER_SR) | (0x1 << channel));\n}\nstatic void vortex_mixer_dis_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_MIXER_SR,\n\t\thwread(vortex->mmio, VORTEX_MIXER_SR) & ~(0x1 << channel));\n}\n\n#if 0\nstatic void\nvortex_mix_muteinputgain(vortex_t * vortex, unsigned char mix,\n\t\t\t unsigned char channel)\n{\n\thwwrite(vortex->mmio, VORTEX_MIX_INVOL_A + ((mix << 5) + channel),\n\t\t0x80);\n\thwwrite(vortex->mmio, VORTEX_MIX_INVOL_B + ((mix << 5) + channel),\n\t\t0x80);\n}\n\nstatic int vortex_mix_getvolume(vortex_t * vortex, unsigned char mix)\n{\n\tint a;\n\ta = hwread(vortex->mmio, VORTEX_MIX_VOL_A + (mix << 2)) & 0xff;\n\t\n\treturn (a);\n}\n\nstatic int\nvortex_mix_getinputvolume(vortex_t * vortex, unsigned char mix,\n\t\t\t  int channel, int *vol)\n{\n\tint a;\n\tif (!(mchannels[mix] & (1 << channel)))\n\t\treturn 0;\n\ta = hwread(vortex->mmio,\n\t\t   VORTEX_MIX_INVOL_A + (((mix << 5) + channel) << 2));\n\t \n\t*vol = a;\n\treturn (0);\n}\n\nstatic unsigned int vortex_mix_boost6db(unsigned char vol)\n{\n\treturn (vol + 8);\t \n}\n\nstatic void vortex_mix_rampvolume(vortex_t * vortex, int mix)\n{\n\tint ch;\n\tchar a;\n\t\n\tfor (ch = 0; ch < 0x20; ch++) {\n\t\tif (((1 << ch) & rampchs[mix]) == 0)\n\t\t\tcontinue;\n\t\ta = hwread(vortex->mmio,\n\t\t\t   VORTEX_MIX_INVOL_B + (((mix << 5) + ch) << 2));\n\t\tif (a > -126) {\n\t\t\ta -= 2;\n\t\t\thwwrite(vortex->mmio,\n\t\t\t\tVORTEX_MIX_INVOL_A +\n\t\t\t\t(((mix << 5) + ch) << 2), a);\n\t\t\thwwrite(vortex->mmio,\n\t\t\t\tVORTEX_MIX_INVOL_B +\n\t\t\t\t(((mix << 5) + ch) << 2), a);\n\t\t} else\n\t\t\tvortex_mix_killinput(vortex, mix, ch);\n\t}\n}\n\nstatic int\nvortex_mix_getenablebit(vortex_t * vortex, unsigned char mix, int mixin)\n{\n\tint addr, temp;\n\tif (mixin >= 0)\n\t\taddr = mixin;\n\telse\n\t\taddr = mixin + 3;\n\taddr = ((mix << 3) + (addr >> 2)) << 2;\n\ttemp = hwread(vortex->mmio, VORTEX_MIX_ENIN + addr);\n\treturn ((temp >> (mixin & 3)) & 1);\n}\n#endif\nstatic void\nvortex_mix_setvolumebyte(vortex_t * vortex, unsigned char mix,\n\t\t\t unsigned char vol)\n{\n\tint temp;\n\thwwrite(vortex->mmio, VORTEX_MIX_VOL_A + (mix << 2), vol);\n\tif (1) {\t\t \n\t\ttemp = hwread(vortex->mmio, VORTEX_MIX_VOL_B + (mix << 2));\n\t\tif ((temp != 0x80) || (vol == 0x80))\n\t\t\treturn;\n\t}\n\thwwrite(vortex->mmio, VORTEX_MIX_VOL_B + (mix << 2), vol);\n}\n\nstatic void\nvortex_mix_setinputvolumebyte(vortex_t * vortex, unsigned char mix,\n\t\t\t      int mixin, unsigned char vol)\n{\n\tint temp;\n\n\thwwrite(vortex->mmio,\n\t\tVORTEX_MIX_INVOL_A + (((mix << 5) + mixin) << 2), vol);\n\tif (1) {\t\t \n\t\ttemp =\n\t\t    hwread(vortex->mmio,\n\t\t\t   VORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2));\n\t\tif ((temp != 0x80) || (vol == 0x80))\n\t\t\treturn;\n\t}\n\thwwrite(vortex->mmio,\n\t\tVORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2), vol);\n}\n\nstatic void\nvortex_mix_setenablebit(vortex_t * vortex, unsigned char mix, int mixin, int en)\n{\n\tint temp, addr;\n\n\tif (mixin < 0)\n\t\taddr = (mixin + 3);\n\telse\n\t\taddr = mixin;\n\taddr = ((mix << 3) + (addr >> 2)) << 2;\n\ttemp = hwread(vortex->mmio, VORTEX_MIX_ENIN + addr);\n\tif (en)\n\t\ttemp |= (1 << (mixin & 3));\n\telse\n\t\ttemp &= ~(1 << (mixin & 3));\n\t \n\thwwrite(vortex->mmio,\n\t\tVORTEX_MIX_INVOL_B + (((mix << 5) + mixin) << 2), 0x80);\n\t \n\thwwrite(vortex->mmio, VORTEX_MIX_SMP + (mixin << 2), 0x0);\n\thwwrite(vortex->mmio, VORTEX_MIX_SMP + 4 + (mixin << 2), 0x0);\n\t \n\thwwrite(vortex->mmio, VORTEX_MIX_ENIN + addr, temp);\n}\n\nstatic void\nvortex_mix_killinput(vortex_t * vortex, unsigned char mix, int mixin)\n{\n\trampchs[mix] &= ~(1 << mixin);\n\tvortex_mix_setinputvolumebyte(vortex, mix, mixin, 0x80);\n\tmchannels[mix] &= ~(1 << mixin);\n\tvortex_mix_setenablebit(vortex, mix, mixin, 0);\n}\n\nstatic void\nvortex_mix_enableinput(vortex_t * vortex, unsigned char mix, int mixin)\n{\n\tvortex_mix_killinput(vortex, mix, mixin);\n\tif ((mchannels[mix] & (1 << mixin)) == 0) {\n\t\tvortex_mix_setinputvolumebyte(vortex, mix, mixin, 0x80);\t \n\t\tmchannels[mix] |= (1 << mixin);\n\t}\n\tvortex_mix_setenablebit(vortex, mix, mixin, 1);\n}\n\nstatic void\nvortex_mix_disableinput(vortex_t * vortex, unsigned char mix, int channel,\n\t\t\tint ramp)\n{\n\tif (ramp) {\n\t\trampchs[mix] |= (1 << channel);\n\t\t\n\t\t\n\t\tvortex_mix_killinput(vortex, mix, channel);\n\t} else\n\t\tvortex_mix_killinput(vortex, mix, channel);\n}\n\nstatic int\nvortex_mixer_addWTD(vortex_t * vortex, unsigned char mix, unsigned char ch)\n{\n\tint temp, lifeboat = 0, prev;\n\n\ttemp = hwread(vortex->mmio, VORTEX_MIXER_SR);\n\tif ((temp & (1 << ch)) == 0) {\n\t\thwwrite(vortex->mmio, VORTEX_MIXER_CHNBASE + (ch << 2), mix);\n\t\tvortex_mixer_en_sr(vortex, ch);\n\t\treturn 1;\n\t}\n\tprev = VORTEX_MIXER_CHNBASE + (ch << 2);\n\ttemp = hwread(vortex->mmio, prev);\n\twhile (temp & 0x10) {\n\t\tprev = VORTEX_MIXER_RTBASE + ((temp & 0xf) << 2);\n\t\ttemp = hwread(vortex->mmio, prev);\n\t\t\n\t\tif ((++lifeboat) > 0xf) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_mixer_addWTD: lifeboat overflow\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\thwwrite(vortex->mmio, VORTEX_MIXER_RTBASE + ((temp & 0xf) << 2), mix);\n\thwwrite(vortex->mmio, prev, (temp & 0xf) | 0x10);\n\treturn 1;\n}\n\nstatic int\nvortex_mixer_delWTD(vortex_t * vortex, unsigned char mix, unsigned char ch)\n{\n\tint esp14 = -1, esp18, eax, ebx, edx, ebp, esi = 0;\n\t\n\n\teax = hwread(vortex->mmio, VORTEX_MIXER_SR);\n\tif (((1 << ch) & eax) == 0) {\n\t\tdev_err(vortex->card->dev, \"mix ALARM %x\\n\", eax);\n\t\treturn 0;\n\t}\n\tebp = VORTEX_MIXER_CHNBASE + (ch << 2);\n\tesp18 = hwread(vortex->mmio, ebp);\n\tif (esp18 & 0x10) {\n\t\tebx = (esp18 & 0xf);\n\t\tif (mix == ebx) {\n\t\t\tebx = VORTEX_MIXER_RTBASE + (mix << 2);\n\t\t\tedx = hwread(vortex->mmio, ebx);\n\t\t\t\n\t\t\thwwrite(vortex->mmio, ebp, edx);\n\t\t\thwwrite(vortex->mmio, ebx, 0);\n\t\t} else {\n\t\t\t\n\t\t\tedx =\n\t\t\t    hwread(vortex->mmio,\n\t\t\t\t   VORTEX_MIXER_RTBASE + (ebx << 2));\n\t\t\t\n\t\t\twhile ((edx & 0xf) != mix) {\n\t\t\t\tif ((esi) > 0xf) {\n\t\t\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\t\t\"mixdelWTD: error lifeboat overflow\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tesp14 = ebx;\n\t\t\t\tebx = edx & 0xf;\n\t\t\t\tebp = ebx << 2;\n\t\t\t\tedx =\n\t\t\t\t    hwread(vortex->mmio,\n\t\t\t\t\t   VORTEX_MIXER_RTBASE + ebp);\n\t\t\t\t\n\t\t\t\tesi++;\n\t\t\t}\n\t\t\t\n\t\t\tebp = ebx << 2;\n\t\t\tif (edx & 0x10) {\t \n\t\t\t\tebx = VORTEX_MIXER_RTBASE + ((edx & 0xf) << 2);\n\t\t\t\tedx = hwread(vortex->mmio, ebx);\n\t\t\t\t\n\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\tVORTEX_MIXER_RTBASE + ebp, edx);\n\t\t\t\thwwrite(vortex->mmio, ebx, 0);\n\t\t\t\t\n\t\t\t} else {\t \n\t\t\t\t\n\t\t\t\tif (esp14 == -1)\n\t\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\t\tVORTEX_MIXER_CHNBASE +\n\t\t\t\t\t\t(ch << 2), esp18 & 0xef);\n\t\t\t\telse {\n\t\t\t\t\tebx = (0xffffffe0 & edx) | (0xf & ebx);\n\t\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\t\tVORTEX_MIXER_RTBASE +\n\t\t\t\t\t\t(esp14 << 2), ebx);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\tVORTEX_MIXER_RTBASE + ebp, 0);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\n\t\t\n\t\tvortex_mixer_dis_sr(vortex, ch);\n\t\thwwrite(vortex->mmio, ebp, 0);\n\t}\n\treturn 1;\n}\n\nstatic void vortex_mixer_init(vortex_t * vortex)\n{\n\tu32 addr;\n\tint x;\n\n\t\n\tmemset(mchannels, 0, NR_MIXOUT * sizeof(int));\n\tmemset(rampchs, 0, NR_MIXOUT * sizeof(int));\n\n\taddr = VORTEX_MIX_SMP + 0x17c;\n\tfor (x = 0x5f; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_ENIN + 0x1fc;\n\tfor (x = 0x7f; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_SMP + 0x17c;\n\tfor (x = 0x5f; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_INVOL_A + 0x7fc;\n\tfor (x = 0x1ff; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0x80);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_VOL_A + 0x3c;\n\tfor (x = 0xf; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0x80);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_INVOL_B + 0x7fc;\n\tfor (x = 0x1ff; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0x80);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIX_VOL_B + 0x3c;\n\tfor (x = 0xf; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0x80);\n\t\taddr -= 4;\n\t}\n\taddr = VORTEX_MIXER_RTBASE + (MIXER_RTBASE_SIZE - 1) * 4;\n\tfor (x = (MIXER_RTBASE_SIZE - 1); x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0x0);\n\t\taddr -= 4;\n\t}\n\thwwrite(vortex->mmio, VORTEX_MIXER_SR, 0);\n\n\t \n\t \n\t \n}\n\n \n\nstatic void vortex_src_en_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,\n\t\thwread(vortex->mmio, VORTEX_SRCBLOCK_SR) | (0x1 << channel));\n}\n\nstatic void vortex_src_dis_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,\n\t\thwread(vortex->mmio, VORTEX_SRCBLOCK_SR) & ~(0x1 << channel));\n}\n\nstatic void vortex_src_flushbuffers(vortex_t * vortex, unsigned char src)\n{\n\tint i;\n\n\tfor (i = 0x1f; i >= 0; i--)\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_SRC_DATA0 + (src << 7) + (i << 2), 0);\n\thwwrite(vortex->mmio, VORTEX_SRC_DATA + (src << 3), 0);\n\thwwrite(vortex->mmio, VORTEX_SRC_DATA + (src << 3) + 4, 0);\n}\n\nstatic void vortex_src_cleardrift(vortex_t * vortex, unsigned char src)\n{\n\thwwrite(vortex->mmio, VORTEX_SRC_DRIFT0 + (src << 2), 0);\n\thwwrite(vortex->mmio, VORTEX_SRC_DRIFT1 + (src << 2), 0);\n\thwwrite(vortex->mmio, VORTEX_SRC_DRIFT2 + (src << 2), 1);\n}\n\nstatic void\nvortex_src_set_throttlesource(vortex_t * vortex, unsigned char src, int en)\n{\n\tint temp;\n\n\ttemp = hwread(vortex->mmio, VORTEX_SRC_SOURCE);\n\tif (en)\n\t\ttemp |= 1 << src;\n\telse\n\t\ttemp &= ~(1 << src);\n\thwwrite(vortex->mmio, VORTEX_SRC_SOURCE, temp);\n}\n\nstatic int\nvortex_src_persist_convratio(vortex_t * vortex, unsigned char src, int ratio)\n{\n\tint temp, lifeboat = 0;\n\n\tdo {\n\t\thwwrite(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2), ratio);\n\t\ttemp = hwread(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2));\n\t\tif ((++lifeboat) > 0x9) {\n\t\t\tdev_err(vortex->card->dev, \"Src cvr fail\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (temp != ratio);\n\treturn temp;\n}\n\n#if 0\nstatic void vortex_src_slowlock(vortex_t * vortex, unsigned char src)\n{\n\tint temp;\n\n\thwwrite(vortex->mmio, VORTEX_SRC_DRIFT2 + (src << 2), 1);\n\thwwrite(vortex->mmio, VORTEX_SRC_DRIFT0 + (src << 2), 0);\n\ttemp = hwread(vortex->mmio, VORTEX_SRC_U0 + (src << 2));\n\tif (temp & 0x200)\n\t\thwwrite(vortex->mmio, VORTEX_SRC_U0 + (src << 2),\n\t\t\ttemp & ~0x200L);\n}\n\nstatic void\nvortex_src_change_convratio(vortex_t * vortex, unsigned char src, int ratio)\n{\n\tint temp, a;\n\n\tif ((ratio & 0x10000) && (ratio != 0x10000)) {\n\t\tif (ratio & 0x3fff)\n\t\t\ta = (0x11 - ((ratio >> 0xe) & 0x3)) - 1;\n\t\telse\n\t\t\ta = (0x11 - ((ratio >> 0xe) & 0x3)) - 2;\n\t} else\n\t\ta = 0xc;\n\ttemp = hwread(vortex->mmio, VORTEX_SRC_U0 + (src << 2));\n\tif (((temp >> 4) & 0xf) != a)\n\t\thwwrite(vortex->mmio, VORTEX_SRC_U0 + (src << 2),\n\t\t\t(temp & 0xf) | ((a & 0xf) << 4));\n\n\tvortex_src_persist_convratio(vortex, src, ratio);\n}\n\nstatic int\nvortex_src_checkratio(vortex_t * vortex, unsigned char src,\n\t\t      unsigned int desired_ratio)\n{\n\tint hw_ratio, lifeboat = 0;\n\n\thw_ratio = hwread(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2));\n\n\twhile (hw_ratio != desired_ratio) {\n\t\thwwrite(vortex->mmio, VORTEX_SRC_CONVRATIO + (src << 2), desired_ratio);\n\n\t\tif ((lifeboat++) > 15) {\n\t\t\tpr_err( \"Vortex: could not set src-%d from %d to %d\\n\",\n\t\t\t       src, hw_ratio, desired_ratio);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hw_ratio;\n}\n\n#endif\n \nstatic void vortex_src_setupchannel(vortex_t * card, unsigned char src,\n\t\t\tunsigned int cr, unsigned int b, int sweep, int d,\n\t\t\tint dirplay, int sl, unsigned int tr, int thsource)\n{\n\t\n\t\n\t\n\t\n\t\n\t\n\n\tint esi, ebp = 0, esp10;\n\n\tvortex_src_flushbuffers(card, src);\n\n\tif (sweep) {\n\t\tif ((tr & 0x10000) && (tr != 0x10000)) {\n\t\t\ttr = 0;\n\t\t\tesi = 0x7;\n\t\t} else {\n\t\t\tif ((((short)tr) < 0) && (tr != 0x8000)) {\n\t\t\t\ttr = 0;\n\t\t\t\tesi = 0x8;\n\t\t\t} else {\n\t\t\t\ttr = 1;\n\t\t\t\tesi = 0xc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((cr & 0x10000) && (cr != 0x10000)) {\n\t\t\ttr = 0;\t \n\t\t\tesi = 0x11 - ((cr >> 0xe) & 7);\n\t\t\tif (cr & 0x3fff)\n\t\t\t\tesi -= 1;\n\t\t\telse\n\t\t\t\tesi -= 2;\n\t\t} else {\n\t\t\ttr = 1;\n\t\t\tesi = 0xc;\n\t\t}\n\t}\n\tvortex_src_cleardrift(card, src);\n\tvortex_src_set_throttlesource(card, src, thsource);\n\n\tif ((dirplay == 0) && (sweep == 0)) {\n\t\tif (tr)\n\t\t\tesp10 = 0xf;\n\t\telse\n\t\t\tesp10 = 0xc;\n\t\tebp = 0;\n\t} else {\n\t\tif (tr)\n\t\t\tebp = 0xf;\n\t\telse\n\t\t\tebp = 0xc;\n\t\tesp10 = 0;\n\t}\n\thwwrite(card->mmio, VORTEX_SRC_U0 + (src << 2),\n\t\t(sl << 0x9) | (sweep << 0x8) | ((esi & 0xf) << 4) | d);\n\t \n\tvortex_src_persist_convratio(card, src, cr);\n\thwwrite(card->mmio, VORTEX_SRC_U1 + (src << 2), b & 0xffff);\n\t \n\thwwrite(card->mmio, VORTEX_SRC_U2 + (src << 2),\n\t\t(tr << 0x11) | (dirplay << 0x10) | (ebp << 0x8) | esp10);\n\t \n\t\n}\n\nstatic void vortex_srcblock_init(vortex_t * vortex)\n{\n\tu32 addr;\n\tint x;\n\thwwrite(vortex->mmio, VORTEX_SRC_SOURCESIZE, 0x1ff);\n\t \n\t\n\t\n\taddr = VORTEX_SRC_RTBASE + 0x3c;\n\tfor (x = 0xf; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0);\n\t\taddr -= 4;\n\t}\n\t\n\t\n\taddr = VORTEX_SRC_CHNBASE + 0x54;\n\tfor (x = 0x15; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, 0);\n\t\taddr -= 4;\n\t}\n}\n\nstatic int\nvortex_src_addWTD(vortex_t * vortex, unsigned char src, unsigned char ch)\n{\n\tint temp, lifeboat = 0, prev;\n\t\n\n\ttemp = hwread(vortex->mmio, VORTEX_SRCBLOCK_SR);\n\tif ((temp & (1 << ch)) == 0) {\n\t\thwwrite(vortex->mmio, VORTEX_SRC_CHNBASE + (ch << 2), src);\n\t\tvortex_src_en_sr(vortex, ch);\n\t\treturn 1;\n\t}\n\tprev = VORTEX_SRC_CHNBASE + (ch << 2);\t \n\ttemp = hwread(vortex->mmio, prev);\n\t\n\twhile (temp & 0x10) {\n\t\tprev = VORTEX_SRC_RTBASE + ((temp & 0xf) << 2);\t \n\t\t\n\t\ttemp = hwread(vortex->mmio, prev);\n\t\t\n\t\tif ((++lifeboat) > 0xf) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_src_addWTD: lifeboat overflow\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\thwwrite(vortex->mmio, VORTEX_SRC_RTBASE + ((temp & 0xf) << 2), src);\n\t\n\thwwrite(vortex->mmio, prev, (temp & 0xf) | 0x10);\n\treturn 1;\n}\n\nstatic int\nvortex_src_delWTD(vortex_t * vortex, unsigned char src, unsigned char ch)\n{\n\tint esp14 = -1, esp18, eax, ebx, edx, ebp, esi = 0;\n\t\n\n\teax = hwread(vortex->mmio, VORTEX_SRCBLOCK_SR);\n\tif (((1 << ch) & eax) == 0) {\n\t\tdev_err(vortex->card->dev, \"src alarm\\n\");\n\t\treturn 0;\n\t}\n\tebp = VORTEX_SRC_CHNBASE + (ch << 2);\n\tesp18 = hwread(vortex->mmio, ebp);\n\tif (esp18 & 0x10) {\n\t\tebx = (esp18 & 0xf);\n\t\tif (src == ebx) {\n\t\t\tebx = VORTEX_SRC_RTBASE + (src << 2);\n\t\t\tedx = hwread(vortex->mmio, ebx);\n\t\t\t\n\t\t\thwwrite(vortex->mmio, ebp, edx);\n\t\t\thwwrite(vortex->mmio, ebx, 0);\n\t\t} else {\n\t\t\t\n\t\t\tedx =\n\t\t\t    hwread(vortex->mmio,\n\t\t\t\t   VORTEX_SRC_RTBASE + (ebx << 2));\n\t\t\t\n\t\t\twhile ((edx & 0xf) != src) {\n\t\t\t\tif ((esi) > 0xf) {\n\t\t\t\t\tdev_warn(vortex->card->dev,\n\t\t\t\t\t\t \"srcdelWTD: error, lifeboat overflow\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tesp14 = ebx;\n\t\t\t\tebx = edx & 0xf;\n\t\t\t\tebp = ebx << 2;\n\t\t\t\tedx =\n\t\t\t\t    hwread(vortex->mmio,\n\t\t\t\t\t   VORTEX_SRC_RTBASE + ebp);\n\t\t\t\t\n\t\t\t\tesi++;\n\t\t\t}\n\t\t\t\n\t\t\tebp = ebx << 2;\n\t\t\tif (edx & 0x10) {\t \n\t\t\t\tebx = VORTEX_SRC_RTBASE + ((edx & 0xf) << 2);\n\t\t\t\tedx = hwread(vortex->mmio, ebx);\n\t\t\t\t\n\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\tVORTEX_SRC_RTBASE + ebp, edx);\n\t\t\t\thwwrite(vortex->mmio, ebx, 0);\n\t\t\t\t\n\t\t\t} else {\t \n\t\t\t\t\n\t\t\t\tif (esp14 == -1)\n\t\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\t\tVORTEX_SRC_CHNBASE +\n\t\t\t\t\t\t(ch << 2), esp18 & 0xef);\n\t\t\t\telse {\n\t\t\t\t\tebx = (0xffffffe0 & edx) | (0xf & ebx);\n\t\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\t\tVORTEX_SRC_RTBASE +\n\t\t\t\t\t\t(esp14 << 2), ebx);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\thwwrite(vortex->mmio,\n\t\t\t\t\tVORTEX_SRC_RTBASE + ebp, 0);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\n\t\tvortex_src_dis_sr(vortex, ch);\n\t\thwwrite(vortex->mmio, ebp, 0);\n\t}\n\treturn 1;\n}\n\n   \n\nstatic void\nvortex_fifo_clearadbdata(vortex_t * vortex, int fifo, int x)\n{\n\tfor (x--; x >= 0; x--)\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_FIFO_ADBDATA +\n\t\t\t(((fifo << FIFO_SIZE_BITS) + x) << 2), 0);\n}\n\n#if 0\nstatic void vortex_fifo_adbinitialize(vortex_t * vortex, int fifo, int j)\n{\n\tvortex_fifo_clearadbdata(vortex, fifo, FIFO_SIZE);\n#ifdef CHIP_AU8820\n\thwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2),\n\t\t(FIFO_U1 | ((j & FIFO_MASK) << 0xb)));\n#else\n\thwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2),\n\t\t(FIFO_U1 | ((j & FIFO_MASK) << 0xc)));\n#endif\n}\n#endif\nstatic void vortex_fifo_setadbvalid(vortex_t * vortex, int fifo, int en)\n{\n\thwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2),\n\t\t(hwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2)) &\n\t\t 0xffffffef) | ((1 & en) << 4) | FIFO_U1);\n}\n\nstatic void\nvortex_fifo_setadbctrl(vortex_t * vortex, int fifo, int stereo, int priority,\n\t\t       int empty, int valid, int f)\n{\n\tint temp, lifeboat = 0;\n\t\n\tint this_4 = 0x2;\n\t \n\tdo {\n\t\ttemp = hwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2));\n\t\tif (lifeboat++ > 0xbb8) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_fifo_setadbctrl fail\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (temp & FIFO_RDONLY);\n\n\t\n\t\n\tif (valid) {\n\t\tif ((temp & FIFO_VALID) == 0) {\n\t\t\t\n\t\t\tvortex_fifo_clearadbdata(vortex, fifo, FIFO_SIZE);\t\n#ifdef CHIP_AU8820\n\t\t\ttemp = (this_4 & 0x1f) << 0xb;\n#else\n\t\t\ttemp = (this_4 & 0x3f) << 0xc;\n#endif\n\t\t\ttemp = (temp & 0xfffffffd) | ((stereo & 1) << 1);\n\t\t\ttemp = (temp & 0xfffffff3) | ((priority & 3) << 2);\n\t\t\ttemp = (temp & 0xffffffef) | ((valid & 1) << 4);\n\t\t\ttemp |= FIFO_U1;\n\t\t\ttemp = (temp & 0xffffffdf) | ((empty & 1) << 5);\n#ifdef CHIP_AU8820\n\t\t\ttemp = (temp & 0xfffbffff) | ((f & 1) << 0x12);\n#endif\n#ifdef CHIP_AU8830\n\t\t\ttemp = (temp & 0xf7ffffff) | ((f & 1) << 0x1b);\n\t\t\ttemp = (temp & 0xefffffff) | ((f & 1) << 0x1c);\n#endif\n#ifdef CHIP_AU8810\n\t\t\ttemp = (temp & 0xfeffffff) | ((f & 1) << 0x18);\n\t\t\ttemp = (temp & 0xfdffffff) | ((f & 1) << 0x19);\n#endif\n\t\t}\n\t} else {\n\t\tif (temp & FIFO_VALID) {\n#ifdef CHIP_AU8820\n\t\t\ttemp = ((f & 1) << 0x12) | (temp & 0xfffbffef);\n#endif\n#ifdef CHIP_AU8830\n\t\t\ttemp =\n\t\t\t    ((f & 1) << 0x1b) | (temp & 0xe7ffffef) | FIFO_BITS;\n#endif\n#ifdef CHIP_AU8810\n\t\t\ttemp =\n\t\t\t    ((f & 1) << 0x18) | (temp & 0xfcffffef) | FIFO_BITS;\n#endif\n\t\t} else\n\t\t\t \n\t\t\tvortex_fifo_clearadbdata(vortex, fifo, FIFO_SIZE);\n\t}\n\thwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2), temp);\n\thwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2));\n}\n\n#ifndef CHIP_AU8810\nstatic void vortex_fifo_clearwtdata(vortex_t * vortex, int fifo, int x)\n{\n\tif (x < 1)\n\t\treturn;\n\tfor (x--; x >= 0; x--)\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_FIFO_WTDATA +\n\t\t\t(((fifo << FIFO_SIZE_BITS) + x) << 2), 0);\n}\n\nstatic void vortex_fifo_wtinitialize(vortex_t * vortex, int fifo, int j)\n{\n\tvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\n#ifdef CHIP_AU8820\n\thwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\n\t\t(FIFO_U1 | ((j & FIFO_MASK) << 0xb)));\n#else\n\thwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\n\t\t(FIFO_U1 | ((j & FIFO_MASK) << 0xc)));\n#endif\n}\n\nstatic void vortex_fifo_setwtvalid(vortex_t * vortex, int fifo, int en)\n{\n\thwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),\n\t\t(hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2)) &\n\t\t 0xffffffef) | ((en & 1) << 4) | FIFO_U1);\n}\n\nstatic void\nvortex_fifo_setwtctrl(vortex_t * vortex, int fifo, int ctrl, int priority,\n\t\t      int empty, int valid, int f)\n{\n\tint temp = 0, lifeboat = 0;\n\tint this_4 = 2;\n\n\tdo {\n\t\ttemp = hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));\n\t\tif (lifeboat++ > 0xbb8) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_fifo_setwtctrl fail\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (temp & FIFO_RDONLY);\n\n\tif (valid) {\n\t\tif ((temp & FIFO_VALID) == 0) {\n\t\t\tvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\t\n#ifdef CHIP_AU8820\n\t\t\ttemp = (this_4 & 0x1f) << 0xb;\n#else\n\t\t\ttemp = (this_4 & 0x3f) << 0xc;\n#endif\n\t\t\ttemp = (temp & 0xfffffffd) | ((ctrl & 1) << 1);\n\t\t\ttemp = (temp & 0xfffffff3) | ((priority & 3) << 2);\n\t\t\ttemp = (temp & 0xffffffef) | ((valid & 1) << 4);\n\t\t\ttemp |= FIFO_U1;\n\t\t\ttemp = (temp & 0xffffffdf) | ((empty & 1) << 5);\n#ifdef CHIP_AU8820\n\t\t\ttemp = (temp & 0xfffbffff) | ((f & 1) << 0x12);\n#endif\n#ifdef CHIP_AU8830\n\t\t\ttemp = (temp & 0xf7ffffff) | ((f & 1) << 0x1b);\n\t\t\ttemp = (temp & 0xefffffff) | ((f & 1) << 0x1c);\n#endif\n#ifdef CHIP_AU8810\n\t\t\ttemp = (temp & 0xfeffffff) | ((f & 1) << 0x18);\n\t\t\ttemp = (temp & 0xfdffffff) | ((f & 1) << 0x19);\n#endif\n\t\t}\n\t} else {\n\t\tif (temp & FIFO_VALID) {\n#ifdef CHIP_AU8820\n\t\t\ttemp = ((f & 1) << 0x12) | (temp & 0xfffbffef);\n#endif\n#ifdef CHIP_AU8830\n\t\t\ttemp =\n\t\t\t    ((f & 1) << 0x1b) | (temp & 0xe7ffffef) | FIFO_BITS;\n#endif\n#ifdef CHIP_AU8810\n\t\t\ttemp =\n\t\t\t    ((f & 1) << 0x18) | (temp & 0xfcffffef) | FIFO_BITS;\n#endif\n\t\t} else\n\t\t\t \n\t\t\tvortex_fifo_clearwtdata(vortex, fifo, FIFO_SIZE);\n\t}\n\thwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2), temp);\n\thwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2));\n\n \n\n\t \n}\n\n#endif\nstatic void vortex_fifo_init(vortex_t * vortex)\n{\n\tint x;\n\tu32 addr;\n\n\t \n\taddr = VORTEX_FIFO_ADBCTRL + ((NR_ADB - 1) * 4);\n\tfor (x = NR_ADB - 1; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, (FIFO_U0 | FIFO_U1));\n\t\tif (hwread(vortex->mmio, addr) != (FIFO_U0 | FIFO_U1))\n\t\t\tdev_err(vortex->card->dev, \"bad adb fifo reset!\\n\");\n\t\tvortex_fifo_clearadbdata(vortex, x, FIFO_SIZE);\n\t\taddr -= 4;\n\t}\n\n#ifndef CHIP_AU8810\n\t \n\taddr = VORTEX_FIFO_WTCTRL + ((NR_WT - 1) * 4);\n\tfor (x = NR_WT - 1; x >= 0; x--) {\n\t\thwwrite(vortex->mmio, addr, FIFO_U0);\n\t\tif (hwread(vortex->mmio, addr) != FIFO_U0)\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"bad wt fifo reset (0x%08x, 0x%08x)!\\n\",\n\t\t\t\taddr, hwread(vortex->mmio, addr));\n\t\tvortex_fifo_clearwtdata(vortex, x, FIFO_SIZE);\n\t\taddr -= 4;\n\t}\n#endif\n\t \n#ifdef CHIP_AU8820\n\thwwrite(vortex->mmio, 0xf8c0, 0xd03);\t\n#else\n#ifdef CHIP_AU8830\n\thwwrite(vortex->mmio, 0x17000, 0x61);\t \n\thwwrite(vortex->mmio, 0x17004, 0x61);\t \n#endif\n\thwwrite(vortex->mmio, 0x17008, 0x61);\t \n#endif\n}\n\n \n\nstatic void vortex_adbdma_init(vortex_t * vortex)\n{\n}\n\nstatic void vortex_adbdma_setfirstbuffer(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\thwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\n\t\tdma->dma_ctrl);\n}\n\nstatic void vortex_adbdma_setstartbuffer(vortex_t * vortex, int adbdma, int sb)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\t\n\thwwrite(vortex->mmio, VORTEX_ADBDMA_START + (adbdma << 2),\n\t\tsb << ((0xf - (adbdma & 0xf)) * 2));\n\tdma->period_real = dma->period_virt = sb;\n}\n\nstatic void\nvortex_adbdma_setbuffers(vortex_t * vortex, int adbdma,\n\t\t\t int psize, int count)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tdma->period_bytes = psize;\n\tdma->nr_periods = count;\n\n\tdma->cfg0 = 0;\n\tdma->cfg1 = 0;\n\tswitch (count) {\n\t\t \n\tdefault:\n\tcase 4:\n\t\tdma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | (psize - 1);\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0xc,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize * 3));\n\t\tfallthrough;\n\t\t \n\tcase 3:\n\t\tdma->cfg0 |= 0x12000000;\n\t\tdma->cfg1 |= 0x80000000 | 0x40000000 | ((psize - 1) << 0xc);\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0x8,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize * 2));\n\t\tfallthrough;\n\t\t \n\tcase 2:\n\t\tdma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | (psize - 1);\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADBDMA_BUFBASE + (adbdma << 4) + 0x4,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize));\n\t\tfallthrough;\n\t\t \n\tcase 1:\n\t\tdma->cfg0 |= 0x80000000 | 0x40000000 | ((psize - 1) << 0xc);\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADBDMA_BUFBASE + (adbdma << 4),\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, 0));\n\t\tbreak;\n\t}\n\t \n\thwwrite(vortex->mmio, VORTEX_ADBDMA_BUFCFG0 + (adbdma << 3), dma->cfg0);\n\thwwrite(vortex->mmio, VORTEX_ADBDMA_BUFCFG1 + (adbdma << 3), dma->cfg1);\n\n\tvortex_adbdma_setfirstbuffer(vortex, adbdma);\n\tvortex_adbdma_setstartbuffer(vortex, adbdma, 0);\n}\n\nstatic void\nvortex_adbdma_setmode(vortex_t * vortex, int adbdma, int ie, int dir,\n\t\t      int fmt, int stereo, u32 offset)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tdma->dma_unknown = stereo;\n\tdma->dma_ctrl =\n\t    ((offset & OFFSET_MASK) | (dma->dma_ctrl & ~OFFSET_MASK));\n\t \n\tdma->dma_ctrl =\n\t    (dma->dma_ctrl & ~IE_MASK) | ((ie << IE_SHIFT) & IE_MASK);\n\n\tdma->dma_ctrl =\n\t    (dma->dma_ctrl & ~DIR_MASK) | ((dir << DIR_SHIFT) & DIR_MASK);\n\tdma->dma_ctrl =\n\t    (dma->dma_ctrl & ~FMT_MASK) | ((fmt << FMT_SHIFT) & FMT_MASK);\n\n\thwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\n\t\tdma->dma_ctrl);\n\thwread(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2));\n}\n\nstatic int vortex_adbdma_bufshift(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\tint page, p, pp, delta, i;\n\n\tpage =\n\t    (hwread(vortex->mmio, VORTEX_ADBDMA_STAT + (adbdma << 2)) &\n\t     ADB_SUBBUF_MASK) >> ADB_SUBBUF_SHIFT;\n\tif (dma->nr_periods >= 4)\n\t\tdelta = (page - dma->period_real) & 3;\n\telse {\n\t\tdelta = (page - dma->period_real);\n\t\tif (delta < 0)\n\t\t\tdelta += dma->nr_periods;\n\t}\n\tif (delta == 0)\n\t\treturn 0;\n\n\t \n\tif (dma->nr_periods > 4) {\n\t\tfor (i = 0; i < delta; i++) {\n\t\t\t \n\t\t\tp = dma->period_virt + i + 4;\n\t\t\tif (p >= dma->nr_periods)\n\t\t\t\tp -= dma->nr_periods;\n\t\t\t \n\t\t\tpp = dma->period_real + i;\n\t\t\tif (pp >= 4)\n\t\t\t\tpp -= 4;\n\t\t\t\n\t\t\thwwrite(vortex->mmio,\n\t\t\t\tVORTEX_ADBDMA_BUFBASE + (((adbdma << 2) + pp) << 2),\n\t\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream,\n\t\t\t\tdma->period_bytes * p));\n\t\t\t \n\t\t\thwread(vortex->mmio, VORTEX_ADBDMA_BUFBASE +\n\t\t\t       (((adbdma << 2) + pp) << 2));\n\t\t}\n\t}\n\tdma->period_virt += delta;\n\tdma->period_real = page;\n\tif (dma->period_virt >= dma->nr_periods)\n\t\tdma->period_virt -= dma->nr_periods;\n\tif (delta != 1)\n\t\tdev_info(vortex->card->dev,\n\t\t\t \"%d virt=%d, real=%d, delta=%d\\n\",\n\t\t\t adbdma, dma->period_virt, dma->period_real, delta);\n\n\treturn delta;\n}\n\n\nstatic void vortex_adbdma_resetup(vortex_t *vortex, int adbdma) {\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\tint p, pp, i;\n\n\t \n\tfor (i=0 ; i < 4 && i < dma->nr_periods; i++) {\n\t\t \n\t\tp = dma->period_virt + i;\n\t\tif (p >= dma->nr_periods)\n\t\t\tp -= dma->nr_periods;\n\t\t \n\t\tpp = dma->period_real + i;\n\t\tif (dma->nr_periods < 4) {\n\t\t\tif (pp >= dma->nr_periods)\n\t\t\t\tpp -= dma->nr_periods;\n\t\t}\n\t\telse {\n\t\t\tif (pp >= 4)\n\t\t\t\tpp -= 4;\n\t\t}\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADBDMA_BUFBASE + (((adbdma << 2) + pp) << 2),\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream,\n\t\t\t\t\t       dma->period_bytes * p));\n\t\t \n\t\thwread(vortex->mmio, VORTEX_ADBDMA_BUFBASE + (((adbdma << 2)+pp) << 2));\n\t}\n}\n\nstatic inline int vortex_adbdma_getlinearpos(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\tint temp, page, delta;\n\n\ttemp = hwread(vortex->mmio, VORTEX_ADBDMA_STAT + (adbdma << 2));\n\tpage = (temp & ADB_SUBBUF_MASK) >> ADB_SUBBUF_SHIFT;\n\tif (dma->nr_periods >= 4)\n\t\tdelta = (page - dma->period_real) & 3;\n\telse {\n\t\tdelta = (page - dma->period_real);\n\t\tif (delta < 0)\n\t\t\tdelta += dma->nr_periods;\n\t}\n\treturn (dma->period_virt + delta) * dma->period_bytes\n\t\t+ (temp & (dma->period_bytes - 1));\n}\n\nstatic void vortex_adbdma_startfifo(vortex_t * vortex, int adbdma)\n{\n\tint this_8 = 0   , this_4 = 0   ;\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tswitch (dma->fifo_status) {\n\tcase FIFO_START:\n\t\tvortex_fifo_setadbvalid(vortex, adbdma,\n\t\t\t\t\tdma->fifo_enabled ? 1 : 0);\n\t\tbreak;\n\tcase FIFO_STOP:\n\t\tthis_8 = 1;\n\t\thwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8,\n\t\t\t\t       dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\tcase FIFO_PAUSE:\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8,\n\t\t\t\t       dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_START;\n}\n\nstatic void vortex_adbdma_resumefifo(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tint this_8 = 1, this_4 = 0;\n\tswitch (dma->fifo_status) {\n\tcase FIFO_STOP:\n\t\thwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8,\n\t\t\t\t       dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\tcase FIFO_PAUSE:\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8,\n\t\t\t\t       dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_START;\n}\n\nstatic void vortex_adbdma_pausefifo(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tint this_8 = 0, this_4 = 0;\n\tswitch (dma->fifo_status) {\n\tcase FIFO_START:\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8, 0, 0);\n\t\tbreak;\n\tcase FIFO_STOP:\n\t\thwwrite(vortex->mmio, VORTEX_ADBDMA_CTRL + (adbdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8, 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_PAUSE;\n}\n\nstatic void vortex_adbdma_stopfifo(vortex_t * vortex, int adbdma)\n{\n\tstream_t *dma = &vortex->dma_adb[adbdma];\n\n\tint this_4 = 0, this_8 = 0;\n\tif (dma->fifo_status == FIFO_START)\n\t\tvortex_fifo_setadbctrl(vortex, adbdma, dma->dma_unknown,\n\t\t\t\t       this_4, this_8, 0, 0);\n\telse if (dma->fifo_status == FIFO_STOP)\n\t\treturn;\n\tdma->fifo_status = FIFO_STOP;\n\tdma->fifo_enabled = 0;\n}\n\n \n\n#ifndef CHIP_AU8810\nstatic void vortex_wtdma_setfirstbuffer(vortex_t * vortex, int wtdma)\n{\n\t\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\thwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2), dma->dma_ctrl);\n}\n\nstatic void vortex_wtdma_setstartbuffer(vortex_t * vortex, int wtdma, int sb)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\t\n\thwwrite(vortex->mmio, VORTEX_WTDMA_START + (wtdma << 2),\n\t\tsb << ((0xf - (wtdma & 0xf)) * 2));\n\tdma->period_real = dma->period_virt = sb;\n}\n\nstatic void\nvortex_wtdma_setbuffers(vortex_t * vortex, int wtdma,\n\t\t\tint psize, int count)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\tdma->period_bytes = psize;\n\tdma->nr_periods = count;\n\n\tdma->cfg0 = 0;\n\tdma->cfg1 = 0;\n\tswitch (count) {\n\t\t \n\tdefault:\n\tcase 4:\n\t\tdma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | (psize-1);\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0xc,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize * 3));\n\t\tfallthrough;\n\t\t \n\tcase 3:\n\t\tdma->cfg0 |= 0x12000000;\n\t\tdma->cfg1 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4)  + 0x8,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize * 2));\n\t\tfallthrough;\n\t\t \n\tcase 2:\n\t\tdma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | (psize-1);\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0x4,\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, psize));\n\t\tfallthrough;\n\t\t \n\tcase 1:\n\t\tdma->cfg0 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),\n\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream, 0));\n\t\tbreak;\n\t}\n\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFCFG0 + (wtdma << 3), dma->cfg0);\n\thwwrite(vortex->mmio, VORTEX_WTDMA_BUFCFG1 + (wtdma << 3), dma->cfg1);\n\n\tvortex_wtdma_setfirstbuffer(vortex, wtdma);\n\tvortex_wtdma_setstartbuffer(vortex, wtdma, 0);\n}\n\nstatic void\nvortex_wtdma_setmode(vortex_t * vortex, int wtdma, int ie, int fmt, int d,\n\t\t       u32 offset)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\t\n\tdma->dma_unknown = d;\n\tdma->dma_ctrl = 0;\n\tdma->dma_ctrl =\n\t    ((offset & OFFSET_MASK) | (dma->dma_ctrl & ~OFFSET_MASK));\n\t \n\tdma->dma_ctrl =\n\t    (dma->dma_ctrl & ~IE_MASK) | ((ie << IE_SHIFT) & IE_MASK);\n\t \n\tdma->dma_ctrl |= (1 << DIR_SHIFT);\n\t \n\tdma->dma_ctrl =\n\t    (dma->dma_ctrl & FMT_MASK) | ((fmt << FMT_SHIFT) & FMT_MASK);\n\t \n\thwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2), dma->dma_ctrl);\n}\n\nstatic int vortex_wtdma_bufshift(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\tint page, p, pp, delta, i;\n\n\tpage =\n\t    (hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2))\n\t     >> WT_SUBBUF_SHIFT) & WT_SUBBUF_MASK;\n\tif (dma->nr_periods >= 4)\n\t\tdelta = (page - dma->period_real) & 3;\n\telse {\n\t\tdelta = (page - dma->period_real);\n\t\tif (delta < 0)\n\t\t\tdelta += dma->nr_periods;\n\t}\n\tif (delta == 0)\n\t\treturn 0;\n\n\t \n\tif (dma->nr_periods > 4) {\n\t\tfor (i = 0; i < delta; i++) {\n\t\t\t \n\t\t\tp = dma->period_virt + i + 4;\n\t\t\tif (p >= dma->nr_periods)\n\t\t\t\tp -= dma->nr_periods;\n\t\t\t \n\t\t\tpp = dma->period_real + i;\n\t\t\tif (pp >= 4)\n\t\t\t\tpp -= 4;\n\t\t\thwwrite(vortex->mmio,\n\t\t\t\tVORTEX_WTDMA_BUFBASE +\n\t\t\t\t(((wtdma << 2) + pp) << 2),\n\t\t\t\tsnd_pcm_sgbuf_get_addr(dma->substream,\n\t\t\t\t\t\t       dma->period_bytes * p));\n\t\t\t \n\t\t\thwread(vortex->mmio, VORTEX_WTDMA_BUFBASE +\n\t\t\t       (((wtdma << 2) + pp) << 2));\n\t\t}\n\t}\n\tdma->period_virt += delta;\n\tif (dma->period_virt >= dma->nr_periods)\n\t\tdma->period_virt -= dma->nr_periods;\n\tdma->period_real = page;\n\n\tif (delta != 1)\n\t\tdev_warn(vortex->card->dev, \"wt virt = %d, delta = %d\\n\",\n\t\t\t dma->period_virt, delta);\n\n\treturn delta;\n}\n\n#if 0\nstatic void\nvortex_wtdma_getposition(vortex_t * vortex, int wtdma, int *subbuf, int *pos)\n{\n\tint temp;\n\ttemp = hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2));\n\t*subbuf = (temp >> WT_SUBBUF_SHIFT) & WT_SUBBUF_MASK;\n\t*pos = temp & POS_MASK;\n}\n\nstatic int vortex_wtdma_getcursubuffer(vortex_t * vortex, int wtdma)\n{\n\treturn ((hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2)) >>\n\t\t POS_SHIFT) & POS_MASK);\n}\n#endif\nstatic inline int vortex_wtdma_getlinearpos(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\tint temp;\n\n\ttemp = hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2));\n\ttemp = (dma->period_virt * dma->period_bytes) + (temp & (dma->period_bytes - 1));\n\treturn temp;\n}\n\nstatic void vortex_wtdma_startfifo(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\tint this_8 = 0, this_4 = 0;\n\n\tswitch (dma->fifo_status) {\n\tcase FIFO_START:\n\t\tvortex_fifo_setwtvalid(vortex, wtdma,\n\t\t\t\t       dma->fifo_enabled ? 1 : 0);\n\t\tbreak;\n\tcase FIFO_STOP:\n\t\tthis_8 = 1;\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8,\n\t\t\t\t      dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\tcase FIFO_PAUSE:\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8,\n\t\t\t\t      dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_START;\n}\n\nstatic void vortex_wtdma_resumefifo(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\tint this_8 = 0, this_4 = 0;\n\tswitch (dma->fifo_status) {\n\tcase FIFO_STOP:\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8,\n\t\t\t\t      dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\tcase FIFO_PAUSE:\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8,\n\t\t\t\t      dma->fifo_enabled ? 1 : 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_START;\n}\n\nstatic void vortex_wtdma_pausefifo(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\tint this_8 = 0, this_4 = 0;\n\tswitch (dma->fifo_status) {\n\tcase FIFO_START:\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8, 0, 0);\n\t\tbreak;\n\tcase FIFO_STOP:\n\t\thwwrite(vortex->mmio, VORTEX_WTDMA_CTRL + (wtdma << 2),\n\t\t\tdma->dma_ctrl);\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8, 0, 0);\n\t\tbreak;\n\t}\n\tdma->fifo_status = FIFO_PAUSE;\n}\n\nstatic void vortex_wtdma_stopfifo(vortex_t * vortex, int wtdma)\n{\n\tstream_t *dma = &vortex->dma_wt[wtdma];\n\n\tint this_4 = 0, this_8 = 0;\n\tif (dma->fifo_status == FIFO_START)\n\t\tvortex_fifo_setwtctrl(vortex, wtdma, dma->dma_unknown,\n\t\t\t\t      this_4, this_8, 0, 0);\n\telse if (dma->fifo_status == FIFO_STOP)\n\t\treturn;\n\tdma->fifo_status = FIFO_STOP;\n\tdma->fifo_enabled = 0;\n}\n\n#endif\n \n\ntypedef int ADBRamLink;\nstatic void vortex_adb_init(vortex_t * vortex)\n{\n\tint i;\n\t \n\thwwrite(vortex->mmio, VORTEX_ADB_SR, 0);\n\tfor (i = 0; i < VORTEX_ADB_RTBASE_COUNT; i++)\n\t\thwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (i << 2),\n\t\t\thwread(vortex->mmio,\n\t\t\t       VORTEX_ADB_RTBASE + (i << 2)) | ROUTE_MASK);\n\tfor (i = 0; i < VORTEX_ADB_CHNBASE_COUNT; i++) {\n\t\thwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (i << 2),\n\t\t\thwread(vortex->mmio,\n\t\t\t       VORTEX_ADB_CHNBASE + (i << 2)) | ROUTE_MASK);\n\t}\n}\n\nstatic void vortex_adb_en_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_ADB_SR,\n\t\thwread(vortex->mmio, VORTEX_ADB_SR) | (0x1 << channel));\n}\n\nstatic void vortex_adb_dis_sr(vortex_t * vortex, int channel)\n{\n\thwwrite(vortex->mmio, VORTEX_ADB_SR,\n\t\thwread(vortex->mmio, VORTEX_ADB_SR) & ~(0x1 << channel));\n}\n\nstatic void\nvortex_adb_addroutes(vortex_t * vortex, unsigned char channel,\n\t\t     ADBRamLink * route, int rnum)\n{\n\tint temp, prev, lifeboat = 0;\n\n\tif ((rnum <= 0) || (route == NULL))\n\t\treturn;\n\t \n\trnum--;\n\thwwrite(vortex->mmio,\n\t\tVORTEX_ADB_RTBASE + ((route[rnum] & ADB_MASK) << 2),\n\t\tROUTE_MASK);\n\twhile (rnum > 0) {\n\t\thwwrite(vortex->mmio,\n\t\t\tVORTEX_ADB_RTBASE +\n\t\t\t((route[rnum - 1] & ADB_MASK) << 2), route[rnum]);\n\t\trnum--;\n\t}\n\t \n\ttemp =\n\t    hwread(vortex->mmio,\n\t\t   VORTEX_ADB_CHNBASE + (channel << 2)) & ADB_MASK;\n\tif (temp == ADB_MASK) {\n\t\t \n\t\thwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (channel << 2),\n\t\t\troute[0]);\n\t\tvortex_adb_en_sr(vortex, channel);\n\t\treturn;\n\t}\n\t \n\tdo {\n\t\tprev = temp;\n\t\ttemp =\n\t\t    hwread(vortex->mmio,\n\t\t\t   VORTEX_ADB_RTBASE + (temp << 2)) & ADB_MASK;\n\t\tif ((lifeboat++) > ADB_MASK) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_adb_addroutes: unending route! 0x%x\\n\",\n\t\t\t\t*route);\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (temp != ADB_MASK);\n\thwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (prev << 2), route[0]);\n}\n\nstatic void\nvortex_adb_delroutes(vortex_t * vortex, unsigned char channel,\n\t\t     ADBRamLink route0, ADBRamLink route1)\n{\n\tint temp, lifeboat = 0, prev;\n\n\t \n\ttemp =\n\t    hwread(vortex->mmio,\n\t\t   VORTEX_ADB_CHNBASE + (channel << 2)) & ADB_MASK;\n\tif (temp == (route0 & ADB_MASK)) {\n\t\ttemp =\n\t\t    hwread(vortex->mmio,\n\t\t\t   VORTEX_ADB_RTBASE + ((route1 & ADB_MASK) << 2));\n\t\tif ((temp & ADB_MASK) == ADB_MASK)\n\t\t\tvortex_adb_dis_sr(vortex, channel);\n\t\thwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (channel << 2),\n\t\t\ttemp);\n\t\treturn;\n\t}\n\tdo {\n\t\tprev = temp;\n\t\ttemp =\n\t\t    hwread(vortex->mmio,\n\t\t\t   VORTEX_ADB_RTBASE + (prev << 2)) & ADB_MASK;\n\t\tif (((lifeboat++) > ADB_MASK) || (temp == ADB_MASK)) {\n\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\"vortex_adb_delroutes: route not found! 0x%x\\n\",\n\t\t\t\troute0);\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (temp != (route0 & ADB_MASK));\n\ttemp = hwread(vortex->mmio, VORTEX_ADB_RTBASE + (temp << 2));\n\tif ((temp & ADB_MASK) == route1)\n\t\ttemp = hwread(vortex->mmio, VORTEX_ADB_RTBASE + (temp << 2));\n\t \n\thwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (prev << 2), temp);\n}\n\nstatic void\nvortex_route(vortex_t * vortex, int en, unsigned char channel,\n\t     unsigned char source, unsigned char dest)\n{\n\tADBRamLink route;\n\n\troute = ((source & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\n\tif (en) {\n\t\tvortex_adb_addroutes(vortex, channel, &route, 1);\n\t\tif ((source < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source >= OFFSET_SRCOUT))\n\t\t\tvortex_src_addWTD(vortex, (source - OFFSET_SRCOUT),\n\t\t\t\t\t  channel);\n\t\telse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t && (source >= OFFSET_MIXOUT))\n\t\t\tvortex_mixer_addWTD(vortex,\n\t\t\t\t\t    (source - OFFSET_MIXOUT), channel);\n\t} else {\n\t\tvortex_adb_delroutes(vortex, channel, route, route);\n\t\tif ((source < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source >= OFFSET_SRCOUT))\n\t\t\tvortex_src_delWTD(vortex, (source - OFFSET_SRCOUT),\n\t\t\t\t\t  channel);\n\t\telse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t && (source >= OFFSET_MIXOUT))\n\t\t\tvortex_mixer_delWTD(vortex,\n\t\t\t\t\t    (source - OFFSET_MIXOUT), channel);\n\t}\n}\n\n#if 0\nstatic void\nvortex_routes(vortex_t * vortex, int en, unsigned char channel,\n\t      unsigned char source, unsigned char dest0, unsigned char dest1)\n{\n\tADBRamLink route[2];\n\n\troute[0] = ((source & ADB_MASK) << ADB_SHIFT) | (dest0 & ADB_MASK);\n\troute[1] = ((source & ADB_MASK) << ADB_SHIFT) | (dest1 & ADB_MASK);\n\n\tif (en) {\n\t\tvortex_adb_addroutes(vortex, channel, route, 2);\n\t\tif ((source < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source >= (OFFSET_SRCOUT)))\n\t\t\tvortex_src_addWTD(vortex, (source - OFFSET_SRCOUT),\n\t\t\t\t\t  channel);\n\t\telse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t && (source >= (OFFSET_MIXOUT)))\n\t\t\tvortex_mixer_addWTD(vortex,\n\t\t\t\t\t    (source - OFFSET_MIXOUT), channel);\n\t} else {\n\t\tvortex_adb_delroutes(vortex, channel, route[0], route[1]);\n\t\tif ((source < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source >= (OFFSET_SRCOUT)))\n\t\t\tvortex_src_delWTD(vortex, (source - OFFSET_SRCOUT),\n\t\t\t\t\t  channel);\n\t\telse if ((source < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t && (source >= (OFFSET_MIXOUT)))\n\t\t\tvortex_mixer_delWTD(vortex,\n\t\t\t\t\t    (source - OFFSET_MIXOUT), channel);\n\t}\n}\n\n#endif\n \nstatic void\nvortex_routeLRT(vortex_t * vortex, int en, unsigned char ch,\n\t\tunsigned char source0, unsigned char source1,\n\t\tunsigned char dest)\n{\n\tADBRamLink route[2];\n\n\troute[0] = ((source0 & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\n\troute[1] = ((source1 & ADB_MASK) << ADB_SHIFT) | (dest & ADB_MASK);\n\n\tif (dest < 0x10)\n\t\troute[1] = (route[1] & ~ADB_MASK) | (dest + 0x20);\t \n\n\tif (en) {\n\t\tvortex_adb_addroutes(vortex, ch, route, 2);\n\t\tif ((source0 < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source0 >= OFFSET_SRCOUT)) {\n\t\t\tvortex_src_addWTD(vortex,\n\t\t\t\t\t  (source0 - OFFSET_SRCOUT), ch);\n\t\t\tvortex_src_addWTD(vortex,\n\t\t\t\t\t  (source1 - OFFSET_SRCOUT), ch);\n\t\t} else if ((source0 < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t   && (source0 >= OFFSET_MIXOUT)) {\n\t\t\tvortex_mixer_addWTD(vortex,\n\t\t\t\t\t    (source0 - OFFSET_MIXOUT), ch);\n\t\t\tvortex_mixer_addWTD(vortex,\n\t\t\t\t\t    (source1 - OFFSET_MIXOUT), ch);\n\t\t}\n\t} else {\n\t\tvortex_adb_delroutes(vortex, ch, route[0], route[1]);\n\t\tif ((source0 < (OFFSET_SRCOUT + NR_SRC))\n\t\t    && (source0 >= OFFSET_SRCOUT)) {\n\t\t\tvortex_src_delWTD(vortex,\n\t\t\t\t\t  (source0 - OFFSET_SRCOUT), ch);\n\t\t\tvortex_src_delWTD(vortex,\n\t\t\t\t\t  (source1 - OFFSET_SRCOUT), ch);\n\t\t} else if ((source0 < (OFFSET_MIXOUT + NR_MIXOUT))\n\t\t\t   && (source0 >= OFFSET_MIXOUT)) {\n\t\t\tvortex_mixer_delWTD(vortex,\n\t\t\t\t\t    (source0 - OFFSET_MIXOUT), ch);\n\t\t\tvortex_mixer_delWTD(vortex,\n\t\t\t\t\t    (source1 - OFFSET_MIXOUT), ch);\n\t\t}\n\t}\n}\n\n \n\n\nstatic void\nvortex_connection_adbdma_src(vortex_t * vortex, int en, unsigned char ch,\n\t\t\t     unsigned char adbdma, unsigned char src)\n{\n\tvortex_route(vortex, en, ch, ADB_DMA(adbdma), ADB_SRCIN(src));\n}\n\n\nstatic void\nvortex_connection_src_mixin(vortex_t * vortex, int en,\n\t\t\t    unsigned char channel, unsigned char src,\n\t\t\t    unsigned char mixin)\n{\n\tvortex_route(vortex, en, channel, ADB_SRCOUT(src), ADB_MIXIN(mixin));\n}\n\n\nstatic void\nvortex_connection_mixin_mix(vortex_t * vortex, int en, unsigned char mixin,\n\t\t\t    unsigned char mix, int a)\n{\n\tif (en) {\n\t\tvortex_mix_enableinput(vortex, mix, mixin);\n\t\tvortex_mix_setinputvolumebyte(vortex, mix, mixin, MIX_DEFIGAIN);\t\n\t} else\n\t\tvortex_mix_disableinput(vortex, mix, mixin, a);\n}\n\n\nstatic void\nvortex_connection_adb_mixin(vortex_t * vortex, int en,\n\t\t\t    unsigned char channel, unsigned char source,\n\t\t\t    unsigned char mixin)\n{\n\tvortex_route(vortex, en, channel, source, ADB_MIXIN(mixin));\n}\n\nstatic void\nvortex_connection_src_adbdma(vortex_t * vortex, int en, unsigned char ch,\n\t\t\t     unsigned char src, unsigned char adbdma)\n{\n\tvortex_route(vortex, en, ch, ADB_SRCOUT(src), ADB_DMA(adbdma));\n}\n\nstatic void\nvortex_connection_src_src_adbdma(vortex_t * vortex, int en,\n\t\t\t\t unsigned char ch, unsigned char src0,\n\t\t\t\t unsigned char src1, unsigned char adbdma)\n{\n\n\tvortex_routeLRT(vortex, en, ch, ADB_SRCOUT(src0), ADB_SRCOUT(src1),\n\t\t\tADB_DMA(adbdma));\n}\n\n\nstatic void\nvortex_connection_mix_adb(vortex_t * vortex, int en, unsigned char ch,\n\t\t\t  unsigned char mix, unsigned char dest)\n{\n\tvortex_route(vortex, en, ch, ADB_MIXOUT(mix), dest);\n\tvortex_mix_setvolumebyte(vortex, mix, MIX_DEFOGAIN);\t\n}\n\n\nstatic void\nvortex_connection_mix_src(vortex_t * vortex, int en, unsigned char ch,\n\t\t\t  unsigned char mix, unsigned char src)\n{\n\tvortex_route(vortex, en, ch, ADB_MIXOUT(mix), ADB_SRCIN(src));\n\tvortex_mix_setvolumebyte(vortex, mix, MIX_DEFOGAIN);\t\n}\n\n#if 0\nstatic void\nvortex_connection_adbdma_src_src(vortex_t * vortex, int en,\n\t\t\t\t unsigned char channel,\n\t\t\t\t unsigned char adbdma, unsigned char src0,\n\t\t\t\t unsigned char src1)\n{\n\tvortex_routes(vortex, en, channel, ADB_DMA(adbdma),\n\t\t      ADB_SRCIN(src0), ADB_SRCIN(src1));\n}\n\n\nstatic void\nvortex_connection_mix_mix_adbdma(vortex_t * vortex, int en,\n\t\t\t\t unsigned char ch, unsigned char mix0,\n\t\t\t\t unsigned char mix1, unsigned char adbdma)\n{\n\n\tADBRamLink routes[2];\n\troutes[0] =\n\t    (((mix0 +\n\t       OFFSET_MIXOUT) & ADB_MASK) << ADB_SHIFT) | (adbdma & ADB_MASK);\n\troutes[1] =\n\t    (((mix1 + OFFSET_MIXOUT) & ADB_MASK) << ADB_SHIFT) | ((adbdma +\n\t\t\t\t\t\t\t\t   0x20) &\n\t\t\t\t\t\t\t\t  ADB_MASK);\n\tif (en) {\n\t\tvortex_adb_addroutes(vortex, ch, routes, 0x2);\n\t\tvortex_mixer_addWTD(vortex, mix0, ch);\n\t\tvortex_mixer_addWTD(vortex, mix1, ch);\n\t} else {\n\t\tvortex_adb_delroutes(vortex, ch, routes[0], routes[1]);\n\t\tvortex_mixer_delWTD(vortex, mix0, ch);\n\t\tvortex_mixer_delWTD(vortex, mix1, ch);\n\t}\n}\n#endif\n\n \n\nstatic void\nvortex_connect_codecplay(vortex_t * vortex, int en, unsigned char mixers[])\n{\n#ifdef CHIP_AU8820\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_CODECOUT(0));\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_CODECOUT(1));\n#else\n#if 1\n\t\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_EQIN(0));\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_EQIN(1));\n\t \n\tvortex_mix_setvolumebyte(vortex, mixers[0], 0);\n\tvortex_mix_setvolumebyte(vortex, mixers[1], 0);\n\tvortex_route(vortex, en, 0x11, ADB_EQOUT(0), ADB_CODECOUT(0));\n\tvortex_route(vortex, en, 0x11, ADB_EQOUT(1), ADB_CODECOUT(1));\n\n\t \n\tif (VORTEX_IS_QUAD(vortex)) {\n\t\t \n\t\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[2],\n\t\t\t\t\t  ADB_CODECOUT(0 + 4));\n\t\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[3],\n\t\t\t\t\t  ADB_CODECOUT(1 + 4));\n\t\t \n\t}\n#else\n\t\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_CODECOUT(0));\n\tvortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_CODECOUT(1));\n#endif\n#endif\n}\n\nstatic void\nvortex_connect_codecrec(vortex_t * vortex, int en, unsigned char mixin0,\n\t\t\tunsigned char mixin1)\n{\n\t \n\tvortex_connection_adb_mixin(vortex, en, 0x11, ADB_CODECIN(0), mixin0);\n\tvortex_connection_adb_mixin(vortex, en, 0x11, ADB_CODECIN(1), mixin1);\n}\n\n\n\n \nstatic const int resnum[VORTEX_RESOURCE_LAST] =\n    { NR_ADB, NR_SRC, NR_MIXIN, NR_MIXOUT, NR_A3D };\n \nstatic int\nvortex_adb_checkinout(vortex_t * vortex, int resmap[], int out, int restype)\n{\n\tint i, qty = resnum[restype], resinuse = 0;\n\n\tif (out) {\n\t\t \n\t\tfor (i = 0; i < NR_ADB; i++) {\n\t\t\tresinuse |= vortex->dma_adb[i].resources[restype];\n\t\t}\n\t\tresinuse |= vortex->fixed_res[restype];\n\t\t \n\t\tfor (i = 0; i < qty; i++) {\n\t\t\tif ((resinuse & (1 << i)) == 0) {\n\t\t\t\tif (resmap != NULL)\n\t\t\t\t\tresmap[restype] |= (1 << i);\n\t\t\t\telse\n\t\t\t\t\tvortex->dma_adb[i].resources[restype] |= (1 << i);\n\t\t\t\t \n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (resmap == NULL)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tfor (i = 0; i < qty; i++) {\n\t\t\tif (resmap[restype] & (1 << i)) {\n\t\t\t\tresmap[restype] &= ~(1 << i);\n\t\t\t\t \n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tdev_err(vortex->card->dev,\n\t\t\"FATAL: ResManager: resource type %d exhausted.\\n\",\n\t\trestype);\n\treturn -ENOMEM;\n}\n\n \n\nstatic void vortex_connect_default(vortex_t * vortex, int en)\n{\n\t\n\tvortex->mixplayb[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\tvortex->mixplayb[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\tif (VORTEX_IS_QUAD(vortex)) {\n\t\tvortex->mixplayb[2] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\t\tvortex->mixplayb[3] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\t}\n\tvortex_connect_codecplay(vortex, en, vortex->mixplayb);\n\n\tvortex->mixcapt[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXIN);\n\tvortex->mixcapt[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXIN);\n\tvortex_connect_codecrec(vortex, en, MIX_CAPT(0), MIX_CAPT(1));\n\n\t\n#ifndef CHIP_AU8820\n\tvortex->mixspdif[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\tvortex->mixspdif[1] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,\n\t\t\t\t  VORTEX_RESOURCE_MIXOUT);\n\tvortex_connection_mix_adb(vortex, en, 0x14, vortex->mixspdif[0],\n\t\t\t\t  ADB_SPDIFOUT(0));\n\tvortex_connection_mix_adb(vortex, en, 0x14, vortex->mixspdif[1],\n\t\t\t\t  ADB_SPDIFOUT(1));\n#endif\n\t\n#ifndef CHIP_AU8810\n\tvortex_wt_connect(vortex, en);\n#endif\n\t\n#ifndef CHIP_AU8820\n\tvortex_Vort3D_connect(vortex, en);\n#endif\n\t\n\n\t\n\n\t\n\t\n}\n\n \nstatic int\nvortex_adb_allocroute(vortex_t *vortex, int dma, int nr_ch, int dir,\n\t\t\tint type, int subdev)\n{\n\tstream_t *stream;\n\tint i, en;\n\tstruct pcm_vol *p;\n\t\n\tif (dma >= 0) {\n\t\ten = 0;\n\t\tvortex_adb_checkinout(vortex,\n\t\t\t\t      vortex->dma_adb[dma].resources, en,\n\t\t\t\t      VORTEX_RESOURCE_DMA);\n\t} else {\n\t\ten = 1;\n\t\tdma = vortex_adb_checkinout(vortex, NULL, en,\n\t\t\t\t\t    VORTEX_RESOURCE_DMA);\n\t\tif (dma < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\tstream = &vortex->dma_adb[dma];\n\tstream->dma = dma;\n\tstream->dir = dir;\n\tstream->type = type;\n\n\t \n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tint src[4], mix[4], ch_top;\n#ifndef CHIP_AU8820\n\t\tint a3d = 0;\n#endif\n\t\t \n\t\tif (stream->type != VORTEX_PCM_SPDIF) {\n\t\t\tfor (i = 0; i < nr_ch; i++) {\n\t\t\t\tsrc[i] = vortex_adb_checkinout(vortex,\n\t\t\t\t\t\t\t       stream->resources, en,\n\t\t\t\t\t\t\t       VORTEX_RESOURCE_SRC);\n\t\t\t\tif (src[i] < 0) {\n\t\t\t\t\tmemset(stream->resources, 0,\n\t\t\t\t\t       sizeof(stream->resources));\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tif (stream->type != VORTEX_PCM_A3D) {\n\t\t\t\t\tmix[i] = vortex_adb_checkinout(vortex,\n\t\t\t\t\t\t\t\t       stream->resources,\n\t\t\t\t\t\t\t\t       en,\n\t\t\t\t\t\t\t\t       VORTEX_RESOURCE_MIXIN);\n\t\t\t\t\tif (mix[i] < 0) {\n\t\t\t\t\t\tmemset(stream->resources,\n\t\t\t\t\t\t       0,\n\t\t\t\t\t\t       sizeof(stream->resources));\n\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#ifndef CHIP_AU8820\n\t\tif (stream->type == VORTEX_PCM_A3D) {\n\t\t\ta3d = vortex_adb_checkinout(vortex,\n\t\t\t\t\t\t    stream->resources, en,\n\t\t\t\t\t\t    VORTEX_RESOURCE_A3D);\n\t\t\tif (a3d < 0) {\n\t\t\t\tmemset(stream->resources, 0,\n\t\t\t\t       sizeof(stream->resources));\n\t\t\t\tdev_err(vortex->card->dev,\n\t\t\t\t\t\"out of A3D sources. Sorry\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t \n\t\t\tvortex_Vort3D_InitializeSource(&vortex->a3d[a3d], en,\n\t\t\t\t\t\t       vortex);\n\t\t}\n\t\t \n\t\tif ((stream->type == VORTEX_PCM_SPDIF) && (en)) {\n\t\t\tvortex_route(vortex, 0, 0x14,\n\t\t\t\t     ADB_MIXOUT(vortex->mixspdif[0]),\n\t\t\t\t     ADB_SPDIFOUT(0));\n\t\t\tvortex_route(vortex, 0, 0x14,\n\t\t\t\t     ADB_MIXOUT(vortex->mixspdif[1]),\n\t\t\t\t     ADB_SPDIFOUT(1));\n\t\t}\n#endif\n\t\t \n\t\tfor (i = 0; i < nr_ch; i++) {\n\t\t\tif (stream->type == VORTEX_PCM_ADB) {\n\t\t\t\tvortex_connection_adbdma_src(vortex, en,\n\t\t\t\t\t\t\t     src[nr_ch - 1],\n\t\t\t\t\t\t\t     dma,\n\t\t\t\t\t\t\t     src[i]);\n\t\t\t\tvortex_connection_src_mixin(vortex, en,\n\t\t\t\t\t\t\t    0x11, src[i],\n\t\t\t\t\t\t\t    mix[i]);\n\t\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t\t    mix[i],\n\t\t\t\t\t\t\t    MIX_PLAYB(i), 0);\n#ifndef CHIP_AU8820\n\t\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t\t    mix[i],\n\t\t\t\t\t\t\t    MIX_SPDIF(i % 2), 0);\n\t\t\t\tvortex_mix_setinputvolumebyte(vortex,\n\t\t\t\t\t\t\t      MIX_SPDIF(i % 2),\n\t\t\t\t\t\t\t      mix[i],\n\t\t\t\t\t\t\t      MIX_DEFIGAIN);\n#endif\n\t\t\t}\n#ifndef CHIP_AU8820\n\t\t\tif (stream->type == VORTEX_PCM_A3D) {\n\t\t\t\tvortex_connection_adbdma_src(vortex, en,\n\t\t\t\t\t\t\t     src[nr_ch - 1], \n\t\t\t\t\t\t\t\t dma,\n\t\t\t\t\t\t\t     src[i]);\n\t\t\t\tvortex_route(vortex, en, 0x11, ADB_SRCOUT(src[i]), ADB_A3DIN(a3d));\n\t\t\t\t \n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tif (stream->type == VORTEX_PCM_SPDIF)\n\t\t\t\tvortex_route(vortex, en, 0x14,\n\t\t\t\t\t     ADB_DMA(stream->dma),\n\t\t\t\t\t     ADB_SPDIFOUT(i));\n#endif\n\t\t}\n\t\tif (stream->type != VORTEX_PCM_SPDIF && stream->type != VORTEX_PCM_A3D) {\n\t\t\tch_top = (VORTEX_IS_QUAD(vortex) ? 4 : 2);\n\t\t\tfor (i = nr_ch; i < ch_top; i++) {\n\t\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t\t    mix[i % nr_ch],\n\t\t\t\t\t\t\t    MIX_PLAYB(i), 0);\n#ifndef CHIP_AU8820\n\t\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t\t    mix[i % nr_ch],\n\t\t\t\t\t\t\t    MIX_SPDIF(i % 2),\n\t\t\t\t\t\t\t\t0);\n\t\t\t\tvortex_mix_setinputvolumebyte(vortex,\n\t\t\t\t\t\t\t      MIX_SPDIF(i % 2),\n\t\t\t\t\t\t\t      mix[i % nr_ch],\n\t\t\t\t\t\t\t      MIX_DEFIGAIN);\n#endif\n\t\t\t}\n\t\t\tif (stream->type == VORTEX_PCM_ADB && en) {\n\t\t\t\tp = &vortex->pcm_vol[subdev];\n\t\t\t\tp->dma = dma;\n\t\t\t\tfor (i = 0; i < nr_ch; i++)\n\t\t\t\t\tp->mixin[i] = mix[i];\n\t\t\t\tfor (i = 0; i < ch_top; i++)\n\t\t\t\t\tp->vol[i] = 0;\n\t\t\t}\n\t\t}\n#ifndef CHIP_AU8820\n\t\telse {\n\t\t\tif (nr_ch == 1 && stream->type == VORTEX_PCM_SPDIF)\n\t\t\t\tvortex_route(vortex, en, 0x14,\n\t\t\t\t\t     ADB_DMA(stream->dma),\n\t\t\t\t\t     ADB_SPDIFOUT(1));\n\t\t}\n\t\t \n\t\tif ((stream->type == VORTEX_PCM_SPDIF) && (!en)) {\n\t\t\tvortex_route(vortex, 1, 0x14,\n\t\t\t\t     ADB_MIXOUT(vortex->mixspdif[0]),\n\t\t\t\t     ADB_SPDIFOUT(0));\n\t\t\tvortex_route(vortex, 1, 0x14,\n\t\t\t\t     ADB_MIXOUT(vortex->mixspdif[1]),\n\t\t\t\t     ADB_SPDIFOUT(1));\n\t\t}\n#endif\n\t \n\t} else {\n\t\tint src[2], mix[2];\n\n\t\tif (nr_ch < 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfor (i = 0; i < nr_ch; i++) {\n\t\t\tmix[i] = vortex_adb_checkinout(vortex,\n\t\t\t\t\t\t       stream->resources, en,\n\t\t\t\t\t\t       VORTEX_RESOURCE_MIXOUT);\n\t\t\tif (mix[i] < 0) {\n\t\t\t\tmemset(stream->resources, 0,\n\t\t\t\t       sizeof(stream->resources));\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tsrc[i] = vortex_adb_checkinout(vortex,\n\t\t\t\t\t\t       stream->resources, en,\n\t\t\t\t\t\t       VORTEX_RESOURCE_SRC);\n\t\t\tif (src[i] < 0) {\n\t\t\t\tmemset(stream->resources, 0,\n\t\t\t\t       sizeof(stream->resources));\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tvortex_connection_mixin_mix(vortex, en, MIX_CAPT(0), mix[0], 0);\n\t\tvortex_connection_mix_src(vortex, en, 0x11, mix[0], src[0]);\n\t\tif (nr_ch == 1) {\n\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t    MIX_CAPT(1), mix[0], 0);\n\t\t\tvortex_connection_src_adbdma(vortex, en,\n\t\t\t\t\t\t     src[0],\n\t\t\t\t\t\t     src[0], dma);\n\t\t} else {\n\t\t\tvortex_connection_mixin_mix(vortex, en,\n\t\t\t\t\t\t    MIX_CAPT(1), mix[1], 0);\n\t\t\tvortex_connection_mix_src(vortex, en, 0x11, mix[1],\n\t\t\t\t\t\t  src[1]);\n\t\t\tvortex_connection_src_src_adbdma(vortex, en,\n\t\t\t\t\t\t\t src[1], src[0],\n\t\t\t\t\t\t\t src[1], dma);\n\t\t}\n\t}\n\tvortex->dma_adb[dma].nr_ch = nr_ch;\n\n#if 0\n\t \n\tif (nr_ch < 4) {\n\t\t \n\t\tsnd_ac97_write_cache(vortex->codec,\n\t\t\t\t     AC97_SIGMATEL_DAC2INVERT,\n\t\t\t\t     snd_ac97_read(vortex->codec,\n\t\t\t\t\t\t   AC97_SIGMATEL_DAC2INVERT)\n\t\t\t\t     | 4);\n\t} else {\n\t\t \n\t\tsnd_ac97_write_cache(vortex->codec,\n\t\t\t\t     AC97_SIGMATEL_DAC2INVERT,\n\t\t\t\t     snd_ac97_read(vortex->codec,\n\t\t\t\t\t\t   AC97_SIGMATEL_DAC2INVERT)\n\t\t\t\t     & ~((u32)\n\t\t\t\t\t 4));\n\t}\n#endif\n\treturn dma;\n}\n\n \nstatic void\nvortex_adb_setsrc(vortex_t * vortex, int adbdma, unsigned int rate, int dir)\n{\n\tstream_t *stream = &(vortex->dma_adb[adbdma]);\n\tint i, cvrt;\n\n\t \n\tif (dir)\n\t\tcvrt = SRC_RATIO(rate, 48000);\n\telse\n\t\tcvrt = SRC_RATIO(48000, rate);\n\n\t \n\tfor (i = 0; i < NR_SRC; i++) {\n\t\tif (stream->resources[VORTEX_RESOURCE_SRC] & (1 << i))\n\t\t\tvortex_src_setupchannel(vortex, i, cvrt, 0, 0, i, dir, 1, cvrt, dir);\n\t}\n}\n\n\n\nstatic void vortex_settimer(vortex_t * vortex, int period)\n{\n\t\n\thwwrite(vortex->mmio, VORTEX_IRQ_STAT, period);\n}\n\n#if 0\nstatic void vortex_enable_timer_int(vortex_t * card)\n{\n\thwwrite(card->mmio, VORTEX_IRQ_CTRL,\n\t\thwread(card->mmio, VORTEX_IRQ_CTRL) | IRQ_TIMER | 0x60);\n}\n\nstatic void vortex_disable_timer_int(vortex_t * card)\n{\n\thwwrite(card->mmio, VORTEX_IRQ_CTRL,\n\t\thwread(card->mmio, VORTEX_IRQ_CTRL) & ~IRQ_TIMER);\n}\n\n#endif\nstatic void vortex_enable_int(vortex_t * card)\n{\n\t\n\thwwrite(card->mmio, VORTEX_CTRL,\n\t\thwread(card->mmio, VORTEX_CTRL) | CTRL_IRQ_ENABLE);\n\thwwrite(card->mmio, VORTEX_IRQ_CTRL,\n\t\t(hwread(card->mmio, VORTEX_IRQ_CTRL) & 0xffffefc0) | 0x24);\n}\n\nstatic void vortex_disable_int(vortex_t * card)\n{\n\thwwrite(card->mmio, VORTEX_CTRL,\n\t\thwread(card->mmio, VORTEX_CTRL) & ~CTRL_IRQ_ENABLE);\n}\n\nstatic irqreturn_t vortex_interrupt(int irq, void *dev_id)\n{\n\tvortex_t *vortex = dev_id;\n\tint i, handled;\n\tu32 source;\n\n\t\n\tif (!(hwread(vortex->mmio, VORTEX_STAT) & 0x1))\n\t\treturn IRQ_NONE;\n\n\t\n\tif (!(hwread(vortex->mmio, VORTEX_CTRL) & CTRL_IRQ_ENABLE))\n\t\treturn IRQ_NONE;\n\n\tsource = hwread(vortex->mmio, VORTEX_IRQ_SOURCE);\n\t\n\thwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, source);\n\thwread(vortex->mmio, VORTEX_IRQ_SOURCE);\n\t\n\tif (source == 0) {\n\t\tdev_err(vortex->card->dev, \"missing irq source\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\thandled = 0;\n\t\n\tif (unlikely(source & IRQ_ERR_MASK)) {\n\t\tif (source & IRQ_FATAL) {\n\t\t\tdev_err(vortex->card->dev, \"IRQ fatal error\\n\");\n\t\t}\n\t\tif (source & IRQ_PARITY) {\n\t\t\tdev_err(vortex->card->dev, \"IRQ parity error\\n\");\n\t\t}\n\t\tif (source & IRQ_REG) {\n\t\t\tdev_err(vortex->card->dev, \"IRQ reg error\\n\");\n\t\t}\n\t\tif (source & IRQ_FIFO) {\n\t\t\tdev_err(vortex->card->dev, \"IRQ fifo error\\n\");\n\t\t}\n\t\tif (source & IRQ_DMA) {\n\t\t\tdev_err(vortex->card->dev, \"IRQ dma error\\n\");\n\t\t}\n\t\thandled = 1;\n\t}\n\tif (source & IRQ_PCMOUT) {\n\t\t \n\t\tspin_lock(&vortex->lock);\n\t\tfor (i = 0; i < NR_ADB; i++) {\n\t\t\tif (vortex->dma_adb[i].fifo_status == FIFO_START) {\n\t\t\t\tif (!vortex_adbdma_bufshift(vortex, i))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&vortex->lock);\n\t\t\t\tsnd_pcm_period_elapsed(vortex->dma_adb[i].\n\t\t\t\t\t\t       substream);\n\t\t\t\tspin_lock(&vortex->lock);\n\t\t\t}\n\t\t}\n#ifndef CHIP_AU8810\n\t\tfor (i = 0; i < NR_WT; i++) {\n\t\t\tif (vortex->dma_wt[i].fifo_status == FIFO_START) {\n\t\t\t\t \n\t\t\t\tvortex_wtdma_bufshift(vortex, i);\n\t\t\t\tspin_unlock(&vortex->lock);\n\t\t\t\tsnd_pcm_period_elapsed(vortex->dma_wt[i].\n\t\t\t\t\t\t       substream);\n\t\t\t\tspin_lock(&vortex->lock);\n\t\t\t}\n\t\t}\n#endif\n\t\tspin_unlock(&vortex->lock);\n\t\thandled = 1;\n\t}\n\t\n\tif (source & IRQ_TIMER) {\n\t\thwread(vortex->mmio, VORTEX_IRQ_STAT);\n\t\thandled = 1;\n\t}\n\tif ((source & IRQ_MIDI) && vortex->rmidi) {\n\t\tsnd_mpu401_uart_interrupt(vortex->irq,\n\t\t\t\t\t  vortex->rmidi->private_data);\n\t\thandled = 1;\n\t}\n\n\tif (!handled) {\n\t\tdev_err(vortex->card->dev, \"unknown irq source %x\\n\", source);\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\n#define POLL_COUNT 1000\nstatic void vortex_codec_init(vortex_t * vortex)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\t \n\t\thwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), -i);\n\t\tmsleep(2);\n\t}\n\tif (0) {\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x8068);\n\t\tmsleep(1);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);\n\t\tmsleep(1);\n\t} else {\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);\n\t\tmsleep(2);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);\n\t\tmsleep(2);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80e8);\n\t\tmsleep(2);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x80a8);\n\t\tmsleep(2);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00a8);\n\t\tmsleep(2);\n\t\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0x00e8);\n\t}\n\tfor (i = 0; i < 32; i++) {\n\t\thwwrite(vortex->mmio, (VORTEX_CODEC_CHN + (i << 2)), -i);\n\t\tmsleep(5);\n\t}\n\thwwrite(vortex->mmio, VORTEX_CODEC_CTRL, 0xe8);\n\tmsleep(1);\n\t \n\thwwrite(vortex->mmio, VORTEX_CODEC_EN,\n\t\thwread(vortex->mmio, VORTEX_CODEC_EN) | EN_CODEC);\n}\n\nstatic void\nvortex_codec_write(struct snd_ac97 * codec, unsigned short addr, unsigned short data)\n{\n\n\tvortex_t *card = (vortex_t *) codec->private_data;\n\tunsigned int lifeboat = 0;\n\n\t \n\twhile (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {\n\t\tudelay(100);\n\t\tif (lifeboat++ > POLL_COUNT) {\n\t\t\tdev_err(card->card->dev, \"ac97 codec stuck busy\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\thwwrite(card->mmio, VORTEX_CODEC_IO,\n\t\t((addr << VORTEX_CODEC_ADDSHIFT) & VORTEX_CODEC_ADDMASK) |\n\t\t((data << VORTEX_CODEC_DATSHIFT) & VORTEX_CODEC_DATMASK) |\n\t\tVORTEX_CODEC_WRITE |\n\t\t(codec->num << VORTEX_CODEC_ID_SHIFT) );\n\n\t \n\thwread(card->mmio, VORTEX_CODEC_IO);\n}\n\nstatic unsigned short vortex_codec_read(struct snd_ac97 * codec, unsigned short addr)\n{\n\n\tvortex_t *card = (vortex_t *) codec->private_data;\n\tu32 read_addr, data;\n\tunsigned lifeboat = 0;\n\n\t \n\twhile (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {\n\t\tudelay(100);\n\t\tif (lifeboat++ > POLL_COUNT) {\n\t\t\tdev_err(card->card->dev, \"ac97 codec stuck busy\\n\");\n\t\t\treturn 0xffff;\n\t\t}\n\t}\n\t \n\tread_addr = ((addr << VORTEX_CODEC_ADDSHIFT) & VORTEX_CODEC_ADDMASK) |\n\t\t(codec->num << VORTEX_CODEC_ID_SHIFT) ;\n\thwwrite(card->mmio, VORTEX_CODEC_IO, read_addr);\n\n\t \n\tdo {\n\t\tudelay(100);\n\t\tdata = hwread(card->mmio, VORTEX_CODEC_IO);\n\t\tif (lifeboat++ > POLL_COUNT) {\n\t\t\tdev_err(card->card->dev,\n\t\t\t\t\"ac97 address never arrived\\n\");\n\t\t\treturn 0xffff;\n\t\t}\n\t} while ((data & VORTEX_CODEC_ADDMASK) !=\n\t\t (addr << VORTEX_CODEC_ADDSHIFT));\n\n\t \n\treturn (u16) (data & VORTEX_CODEC_DATMASK);\n}\n\n \n\nstatic void vortex_spdif_init(vortex_t * vortex, int spdif_sr, int spdif_mode)\n{\n\tint i, this_38 = 0, this_04 = 0, this_08 = 0, this_0c = 0;\n\n\t \n\thwwrite(vortex->mmio, VORTEX_SPDIF_FLAGS,\n\t\thwread(vortex->mmio, VORTEX_SPDIF_FLAGS) & 0xfff3fffd);\n\t\n\tfor (i = 0; i < 11; i++)\n\t\thwwrite(vortex->mmio, VORTEX_SPDIF_CFG1 + (i << 2), 0);\n\t\n\thwwrite(vortex->mmio, VORTEX_CODEC_EN,\n\t\thwread(vortex->mmio, VORTEX_CODEC_EN) | EN_SPDIF);\n\n\t \n\tif (this_04 && this_08) {\n\t\tint edi;\n\n\t\ti = (((0x5DC00000 / spdif_sr) + 1) >> 1);\n\t\tif (i > 0x800) {\n\t\t\tif (i < 0x1ffff)\n\t\t\t\tedi = (i >> 1);\n\t\t\telse\n\t\t\t\tedi = 0x1ffff;\n\t\t} else {\n\t\t\tedi = 0x800;\n\t\t}\n\t\t \n\t\tvortex_src_setupchannel(vortex, this_04, edi, 0, 1,\n\t\t\t\t\tthis_0c, 1, 0, edi, 1);\n\t\tvortex_src_setupchannel(vortex, this_08, edi, 0, 1,\n\t\t\t\t\tthis_0c, 1, 0, edi, 1);\n\t}\n\n\ti = spdif_sr;\n\tspdif_sr |= 0x8c;\n\tswitch (i) {\n\tcase 32000:\n\t\tthis_38 &= 0xFFFFFFFE;\n\t\tthis_38 &= 0xFFFFFFFD;\n\t\tthis_38 &= 0xF3FFFFFF;\n\t\tthis_38 |= 0x03000000;\t \n\t\tthis_38 &= 0xFFFFFF3F;\n\t\tspdif_sr &= 0xFFFFFFFD;\n\t\tspdif_sr |= 1;\n\t\tbreak;\n\tcase 44100:\n\t\tthis_38 &= 0xFFFFFFFE;\n\t\tthis_38 &= 0xFFFFFFFD;\n\t\tthis_38 &= 0xF0FFFFFF;\n\t\tthis_38 |= 0x03000000;\n\t\tthis_38 &= 0xFFFFFF3F;\n\t\tspdif_sr &= 0xFFFFFFFC;\n\t\tbreak;\n\tcase 48000:\n\t\tif (spdif_mode == 1) {\n\t\t\tthis_38 &= 0xFFFFFFFE;\n\t\t\tthis_38 &= 0xFFFFFFFD;\n\t\t\tthis_38 &= 0xF2FFFFFF;\n\t\t\tthis_38 |= 0x02000000;\t \n\t\t\tthis_38 &= 0xFFFFFF3F;\n\t\t} else {\n\t\t\t \n\t\t\tthis_38 |= 0x00000003;\n\t\t\tthis_38 &= 0xFFFFFFBF;\n\t\t\tthis_38 |= 0x80;\n\t\t}\n\t\tspdif_sr |= 2;\n\t\tspdif_sr &= 0xFFFFFFFE;\n\t\tbreak;\n\n\t}\n\t \n\thwwrite(vortex->mmio, VORTEX_SPDIF_CFG0, this_38 & 0xffff);\n\thwwrite(vortex->mmio, VORTEX_SPDIF_CFG1, this_38 >> 0x10);\n\thwwrite(vortex->mmio, VORTEX_SPDIF_SMPRATE, spdif_sr);\n}\n\n \n\nstatic int vortex_core_init(vortex_t *vortex)\n{\n\n\tdev_info(vortex->card->dev, \"init started\\n\");\n\t \n\thwwrite(vortex->mmio, VORTEX_CTRL, 0xffffffff);\n\tmsleep(5);\n\thwwrite(vortex->mmio, VORTEX_CTRL,\n\t\thwread(vortex->mmio, VORTEX_CTRL) & 0xffdfffff);\n\tmsleep(5);\n\t \n\thwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffffffff);\n\thwread(vortex->mmio, VORTEX_IRQ_STAT);\n\n\tvortex_codec_init(vortex);\n\n#ifdef CHIP_AU8830\n\thwwrite(vortex->mmio, VORTEX_CTRL,\n\t\thwread(vortex->mmio, VORTEX_CTRL) | 0x1000000);\n#endif\n\n\t \n\tvortex_adbdma_init(vortex);\n\thwwrite(vortex->mmio, VORTEX_ENGINE_CTRL, 0x0);\t\n\tvortex_adb_init(vortex);\n\t \n\tvortex_fifo_init(vortex);\n\tvortex_mixer_init(vortex);\n\tvortex_srcblock_init(vortex);\n#ifndef CHIP_AU8820\n\tvortex_eq_init(vortex);\n\tvortex_spdif_init(vortex, 48000, 1);\n\tvortex_Vort3D_enable(vortex);\n#endif\n#ifndef CHIP_AU8810\n\tvortex_wt_init(vortex);\n#endif\n\t\n\t\n\n\tvortex_settimer(vortex, 0x90);\n\t\n\t\n\t\n\t\n\t\n\t\n\n\tdev_info(vortex->card->dev, \"init.... done.\\n\");\n\tspin_lock_init(&vortex->lock);\n\n\treturn 0;\n}\n\nstatic int vortex_core_shutdown(vortex_t * vortex)\n{\n\n\tdev_info(vortex->card->dev, \"shutdown started\\n\");\n#ifndef CHIP_AU8820\n\tvortex_eq_free(vortex);\n\tvortex_Vort3D_disable(vortex);\n#endif\n\t\n\tvortex_disable_int(vortex);\n\tvortex_connect_default(vortex, 0);\n\t \n\tvortex_fifo_init(vortex);\n\t \n\tvortex_adb_init(vortex);\n\n\t \n\t\n\t\n\n\thwwrite(vortex->mmio, VORTEX_IRQ_CTRL, 0);\n\thwwrite(vortex->mmio, VORTEX_CTRL, 0);\n\tmsleep(5);\n\thwwrite(vortex->mmio, VORTEX_IRQ_SOURCE, 0xffff);\n\n\tdev_info(vortex->card->dev, \"shutdown.... done.\\n\");\n\treturn 0;\n}\n\n \n\nstatic int vortex_alsafmt_aspfmt(snd_pcm_format_t alsafmt, vortex_t *v)\n{\n\tint fmt;\n\n\tswitch (alsafmt) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tfmt = 0x1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tfmt = 0x2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tfmt = 0x3;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_SPECIAL:\n\t\tfmt = 0x4;\t \n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\n\t\tfmt = 0x5;\t \n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tfmt = 0x8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tfmt = 0x9;\t \n\t\tbreak;\n\tdefault:\n\t\tfmt = 0x8;\n\t\tdev_err(v->card->dev,\n\t\t\t\"format unsupported %d\\n\", alsafmt);\n\t\tbreak;\n\t}\n\treturn fmt;\n}\n\n \n#if 0\ntypedef enum {\n\tASPFMTLINEAR16 = 0,\t \n\tASPFMTLINEAR8,\t\t \n\tASPFMTULAW,\t\t \n\tASPFMTALAW,\t\t \n\tASPFMTSPORT,\t\t \n\tASPFMTSPDIF,\t\t \n} ASPENCODING;\n\nstatic int\nvortex_translateformat(vortex_t * vortex, char bits, char nch, int encod)\n{\n\tint a, this_194;\n\n\tif ((bits != 8) && (bits != 16))\n\t\treturn -1;\n\n\tswitch (encod) {\n\tcase 0:\n\t\tif (bits == 0x10)\n\t\t\ta = 8;\t\n\t\tbreak;\n\tcase 1:\n\t\tif (bits == 8)\n\t\t\ta = 1;\t\n\t\tbreak;\n\tcase 2:\n\t\ta = 2;\t\t\n\t\tbreak;\n\tcase 3:\n\t\ta = 3;\t\t\n\t\tbreak;\n\t}\n\tswitch (nch) {\n\tcase 1:\n\t\tthis_194 = 0;\n\t\tbreak;\n\tcase 2:\n\t\tthis_194 = 1;\n\t\tbreak;\n\tcase 4:\n\t\tthis_194 = 1;\n\t\tbreak;\n\tcase 6:\n\t\tthis_194 = 1;\n\t\tbreak;\n\t}\n\treturn (a);\n}\n\nstatic void vortex_cdmacore_setformat(vortex_t * vortex, int bits, int nch)\n{\n\tshort int d, this_148;\n\n\td = ((bits >> 3) * nch);\n\tthis_148 = 0xbb80 / d;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}