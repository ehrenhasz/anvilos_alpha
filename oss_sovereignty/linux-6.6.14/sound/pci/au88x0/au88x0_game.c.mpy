{
  "module_name": "au88x0_game.c",
  "hash_id": "f7fe7c5c33919820c761a168d19023df8959e3ad93968b1de3f046676b3f2a66",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/au88x0/au88x0_game.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include \"au88x0.h\"\n#include <linux/gameport.h>\n#include <linux/export.h>\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n\n#define VORTEX_GAME_DWAIT\t20\t \n\nstatic unsigned char vortex_game_read(struct gameport *gameport)\n{\n\tvortex_t *vortex = gameport_get_port_data(gameport);\n\treturn hwread(vortex->mmio, VORTEX_GAME_LEGACY);\n}\n\nstatic void vortex_game_trigger(struct gameport *gameport)\n{\n\tvortex_t *vortex = gameport_get_port_data(gameport);\n\thwwrite(vortex->mmio, VORTEX_GAME_LEGACY, 0xff);\n}\n\nstatic int\nvortex_game_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tvortex_t *vortex = gameport_get_port_data(gameport);\n\tint i;\n\n\t*buttons = (~hwread(vortex->mmio, VORTEX_GAME_LEGACY) >> 4) & 0xf;\n\n\tfor (i = 0; i < 4; i++) {\n\t\taxes[i] =\n\t\t    hwread(vortex->mmio, VORTEX_GAME_AXIS + (i * AXIS_SIZE));\n\t\tif (axes[i] == AXIS_RANGE)\n\t\t\taxes[i] = -1;\n\t}\n\treturn 0;\n}\n\nstatic int vortex_game_open(struct gameport *gameport, int mode)\n{\n\tvortex_t *vortex = gameport_get_port_data(gameport);\n\n\tswitch (mode) {\n\tcase GAMEPORT_MODE_COOKED:\n\t\thwwrite(vortex->mmio, VORTEX_CTRL2,\n\t\t\thwread(vortex->mmio,\n\t\t\t       VORTEX_CTRL2) | CTRL2_GAME_ADCMODE);\n\t\tmsleep(VORTEX_GAME_DWAIT);\n\t\treturn 0;\n\tcase GAMEPORT_MODE_RAW:\n\t\thwwrite(vortex->mmio, VORTEX_CTRL2,\n\t\t\thwread(vortex->mmio,\n\t\t\t       VORTEX_CTRL2) & ~CTRL2_GAME_ADCMODE);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vortex_gameport_register(vortex_t *vortex)\n{\n\tstruct gameport *gp;\n\n\tvortex->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(vortex->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"AU88x0 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(vortex->pci_dev));\n\tgameport_set_dev_parent(gp, &vortex->pci_dev->dev);\n\n\tgp->read = vortex_game_read;\n\tgp->trigger = vortex_game_trigger;\n\tgp->cooked_read = vortex_game_cooked_read;\n\tgp->open = vortex_game_open;\n\n\tgameport_set_port_data(gp, vortex);\n\tgp->fuzz = 64;\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic void vortex_gameport_unregister(vortex_t * vortex)\n{\n\tif (vortex->gameport) {\n\t\tgameport_unregister_port(vortex->gameport);\n\t\tvortex->gameport = NULL;\n\t}\n}\n\n#else\nstatic inline int vortex_gameport_register(vortex_t * vortex) { return -ENOSYS; }\nstatic inline void vortex_gameport_unregister(vortex_t * vortex) { }\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}