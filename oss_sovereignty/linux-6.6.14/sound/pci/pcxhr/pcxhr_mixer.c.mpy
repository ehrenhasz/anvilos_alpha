{
  "module_name": "pcxhr_mixer.c",
  "hash_id": "4583044313b3f1cfe7975062dc853e3c4ab0ac0d0cfd6404e36ddba3c3515554",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/pcxhr/pcxhr_mixer.c",
  "human_readable_source": "\n#define __NO_VERSION__\n \n\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include \"pcxhr.h\"\n#include \"pcxhr_hwdep.h\"\n#include \"pcxhr_core.h\"\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/asoundef.h>\n#include \"pcxhr_mixer.h\"\n#include \"pcxhr_mix22.h\"\n\n#define PCXHR_LINE_CAPTURE_LEVEL_MIN   0\t \n#define PCXHR_LINE_CAPTURE_LEVEL_MAX   255\t \n#define PCXHR_LINE_CAPTURE_ZERO_LEVEL  224\t \n\n#define PCXHR_LINE_PLAYBACK_LEVEL_MIN  0\t \n#define PCXHR_LINE_PLAYBACK_LEVEL_MAX  128\t \n#define PCXHR_LINE_PLAYBACK_ZERO_LEVEL 104\t \n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_analog_capture, -11200, 50, 1550);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_analog_playback, -10400, 100, 2400);\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_a_hr222_capture, -11150, 50, 1600);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_a_hr222_playback, -2550, 50, 2400);\n\nstatic int pcxhr_update_analog_audio_level(struct snd_pcxhr *chip,\n\t\t\t\t\t   int is_capture, int channel)\n{\n\tint err, vol;\n\tstruct pcxhr_rmh rmh;\n\n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\tif (is_capture) {\n\t\trmh.cmd[0] |= IO_NUM_REG_IN_ANA_LEVEL;\n\t\trmh.cmd[2] = chip->analog_capture_volume[channel];\n\t} else {\n\t\trmh.cmd[0] |= IO_NUM_REG_OUT_ANA_LEVEL;\n\t\tif (chip->analog_playback_active[channel])\n\t\t\tvol = chip->analog_playback_volume[channel];\n\t\telse\n\t\t\tvol = PCXHR_LINE_PLAYBACK_LEVEL_MIN;\n\t\t \n\t\trmh.cmd[2] = PCXHR_LINE_PLAYBACK_LEVEL_MAX - vol;\n\t}\n\trmh.cmd[1]  = 1 << ((2 * chip->chip_idx) + channel);\t \n\trmh.cmd_len = 3;\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err < 0) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error update_analog_audio_level card(%d)\"\n\t\t\t   \" is_capture(%d) err(%x)\\n\",\n\t\t\t   chip->chip_idx, is_capture, err);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int pcxhr_analog_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tif (kcontrol->private_value == 0) {\t \n\t    if (chip->mgr->is_hr_stereo) {\n\t\tuinfo->value.integer.min =\n\t\t\tHR222_LINE_PLAYBACK_LEVEL_MIN;\t \n\t\tuinfo->value.integer.max =\n\t\t\tHR222_LINE_PLAYBACK_LEVEL_MAX;\t \n\t    } else {\n\t\tuinfo->value.integer.min =\n\t\t\tPCXHR_LINE_PLAYBACK_LEVEL_MIN;\t \n\t\tuinfo->value.integer.max =\n\t\t\tPCXHR_LINE_PLAYBACK_LEVEL_MAX;\t \n\t    }\n\t} else {\t\t\t\t \n\t    if (chip->mgr->is_hr_stereo) {\n\t\tuinfo->value.integer.min =\n\t\t\tHR222_LINE_CAPTURE_LEVEL_MIN;\t \n\t\tuinfo->value.integer.max =\n\t\t\tHR222_LINE_CAPTURE_LEVEL_MAX;\t \n\t    } else {\n\t\tuinfo->value.integer.min =\n\t\t\tPCXHR_LINE_CAPTURE_LEVEL_MIN;\t \n\t\tuinfo->value.integer.max =\n\t\t\tPCXHR_LINE_CAPTURE_LEVEL_MAX;\t \n\t    }\n\t}\n\treturn 0;\n}\n\nstatic int pcxhr_analog_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (kcontrol->private_value == 0) {\t \n\t  ucontrol->value.integer.value[0] = chip->analog_playback_volume[0];\n\t  ucontrol->value.integer.value[1] = chip->analog_playback_volume[1];\n\t} else {\t\t\t\t \n\t  ucontrol->value.integer.value[0] = chip->analog_capture_volume[0];\n\t  ucontrol->value.integer.value[1] = chip->analog_capture_volume[1];\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_analog_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint is_capture, i;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tis_capture = (kcontrol->private_value != 0);\n\tfor (i = 0; i < 2; i++) {\n\t\tint  new_volume = ucontrol->value.integer.value[i];\n\t\tint *stored_volume = is_capture ?\n\t\t\t&chip->analog_capture_volume[i] :\n\t\t\t&chip->analog_playback_volume[i];\n\t\tif (is_capture) {\n\t\t\tif (chip->mgr->is_hr_stereo) {\n\t\t\t\tif (new_volume < HR222_LINE_CAPTURE_LEVEL_MIN ||\n\t\t\t\t    new_volume > HR222_LINE_CAPTURE_LEVEL_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (new_volume < PCXHR_LINE_CAPTURE_LEVEL_MIN ||\n\t\t\t\t    new_volume > PCXHR_LINE_CAPTURE_LEVEL_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (chip->mgr->is_hr_stereo) {\n\t\t\t\tif (new_volume < HR222_LINE_PLAYBACK_LEVEL_MIN ||\n\t\t\t\t    new_volume > HR222_LINE_PLAYBACK_LEVEL_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (new_volume < PCXHR_LINE_PLAYBACK_LEVEL_MIN ||\n\t\t\t\t    new_volume > PCXHR_LINE_PLAYBACK_LEVEL_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*stored_volume != new_volume) {\n\t\t\t*stored_volume = new_volume;\n\t\t\tchanged = 1;\n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\thr222_update_analog_audio_level(chip,\n\t\t\t\t\t\t\t\tis_capture, i);\n\t\t\telse\n\t\t\t\tpcxhr_update_analog_audio_level(chip,\n\t\t\t\t\t\t\t\tis_capture, i);\n\t\t}\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_analog_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t \n\t.info =\t\tpcxhr_analog_vol_info,\n\t.get =\t\tpcxhr_analog_vol_get,\n\t.put =\t\tpcxhr_analog_vol_put,\n\t \n};\n\n \n\n#define pcxhr_sw_info\t\tsnd_ctl_boolean_stereo_info\n\nstatic int pcxhr_audio_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->analog_playback_active[0];\n\tucontrol->value.integer.value[1] = chip->analog_playback_active[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_audio_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint i, changed = 0;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor(i = 0; i < 2; i++) {\n\t\tif (chip->analog_playback_active[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->analog_playback_active[i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t\t \n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\thr222_update_analog_audio_level(chip, 0, i);\n\t\t\telse\n\t\t\t\tpcxhr_update_analog_audio_level(chip, 0, i);\n\t\t}\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_output_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Master Playback Switch\",\n\t.info =\t\tpcxhr_sw_info,\t\t \n\t.get =\t\tpcxhr_audio_sw_get,\n\t.put =\t\tpcxhr_audio_sw_put\n};\n\n\n#define PCXHR_DIGITAL_LEVEL_MIN\t\t0x000\t \n#define PCXHR_DIGITAL_LEVEL_MAX\t\t0x1ff\t \n#define PCXHR_DIGITAL_ZERO_LEVEL\t0x1b7\t \n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_digital, -10975, 25, 1800);\n\n#define MORE_THAN_ONE_STREAM_LEVEL\t0x000001\n#define VALID_STREAM_PAN_LEVEL_MASK\t0x800000\n#define VALID_STREAM_LEVEL_MASK\t\t0x400000\n#define VALID_STREAM_LEVEL_1_MASK\t0x200000\n#define VALID_STREAM_LEVEL_2_MASK\t0x100000\n\nstatic int pcxhr_update_playback_stream_level(struct snd_pcxhr* chip, int idx)\n{\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\tstruct pcxhr_pipe *pipe = &chip->playback_pipe;\n\tint left, right;\n\n\tif (chip->digital_playback_active[idx][0])\n\t\tleft = chip->digital_playback_volume[idx][0];\n\telse\n\t\tleft = PCXHR_DIGITAL_LEVEL_MIN;\n\tif (chip->digital_playback_active[idx][1])\n\t\tright = chip->digital_playback_volume[idx][1];\n\telse\n\t\tright = PCXHR_DIGITAL_LEVEL_MIN;\n\n\tpcxhr_init_rmh(&rmh, CMD_STREAM_OUT_LEVEL_ADJUST);\n\t \n\tpcxhr_set_pipe_cmd_params(&rmh, 0, pipe->first_audio, 0, 1<<idx);\n\t \n\trmh.cmd[0] |= MORE_THAN_ONE_STREAM_LEVEL;\n\trmh.cmd[2]  = VALID_STREAM_PAN_LEVEL_MASK | VALID_STREAM_LEVEL_1_MASK;\n\trmh.cmd[2] |= (left << 10);\n\trmh.cmd[3]  = VALID_STREAM_PAN_LEVEL_MASK | VALID_STREAM_LEVEL_2_MASK;\n\trmh.cmd[3] |= right;\n\trmh.cmd_len = 4;\n\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err < 0) {\n\t\tdev_dbg(chip->card->dev, \"error update_playback_stream_level \"\n\t\t\t   \"card(%d) err(%x)\\n\", chip->chip_idx, err);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#define AUDIO_IO_HAS_MUTE_LEVEL\t\t0x400000\n#define AUDIO_IO_HAS_MUTE_MONITOR_1\t0x200000\n#define VALID_AUDIO_IO_DIGITAL_LEVEL\t0x000001\n#define VALID_AUDIO_IO_MONITOR_LEVEL\t0x000002\n#define VALID_AUDIO_IO_MUTE_LEVEL\t0x000004\n#define VALID_AUDIO_IO_MUTE_MONITOR_1\t0x000008\n\nstatic int pcxhr_update_audio_pipe_level(struct snd_pcxhr *chip,\n\t\t\t\t\t int capture, int channel)\n{\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\tstruct pcxhr_pipe *pipe;\n\n\tif (capture)\n\t\tpipe = &chip->capture_pipe[0];\n\telse\n\t\tpipe = &chip->playback_pipe;\n\n\tpcxhr_init_rmh(&rmh, CMD_AUDIO_LEVEL_ADJUST);\n\t \n\tpcxhr_set_pipe_cmd_params(&rmh, capture, 0, 0,\n\t\t\t\t  1 << (channel + pipe->first_audio));\n\t \n\tif (capture) {\n\t\trmh.cmd[0] |= VALID_AUDIO_IO_DIGITAL_LEVEL;\n\t\t \n\t\trmh.cmd[2] = chip->digital_capture_volume[channel];\n\t} else {\n\t\trmh.cmd[0] |=\tVALID_AUDIO_IO_MONITOR_LEVEL |\n\t\t\t\tVALID_AUDIO_IO_MUTE_MONITOR_1;\n\t\t \n\t\trmh.cmd[2] = chip->monitoring_volume[channel] << 10;\n\t\tif (chip->monitoring_active[channel] == 0)\n\t\t\trmh.cmd[2] |= AUDIO_IO_HAS_MUTE_MONITOR_1;\n\t}\n\trmh.cmd_len = 3;\n\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err < 0) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"error update_audio_level(%d) err=%x\\n\",\n\t\t\t   chip->chip_idx, err);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int pcxhr_digital_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = PCXHR_DIGITAL_LEVEL_MIN;    \n\tuinfo->value.integer.max = PCXHR_DIGITAL_LEVEL_MAX;    \n\treturn 0;\n}\n\n\nstatic int pcxhr_pcm_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\t \n\tint *stored_volume;\n\tint is_capture = kcontrol->private_value;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (is_capture)\t\t \n\t\tstored_volume = chip->digital_capture_volume;\n\telse\t\t\t \n\t\tstored_volume = chip->digital_playback_volume[idx];\n\tucontrol->value.integer.value[0] = stored_volume[0];\n\tucontrol->value.integer.value[1] = stored_volume[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_pcm_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\t \n\tint changed = 0;\n\tint is_capture = kcontrol->private_value;\n\tint *stored_volume;\n\tint i;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (is_capture)\t\t \n\t\tstored_volume = chip->digital_capture_volume;\n\telse\t\t\t \n\t\tstored_volume = chip->digital_playback_volume[idx];\n\tfor (i = 0; i < 2; i++) {\n\t\tint vol = ucontrol->value.integer.value[i];\n\t\tif (vol < PCXHR_DIGITAL_LEVEL_MIN ||\n\t\t    vol > PCXHR_DIGITAL_LEVEL_MAX)\n\t\t\tcontinue;\n\t\tif (stored_volume[i] != vol) {\n\t\t\tstored_volume[i] = vol;\n\t\t\tchanged = 1;\n\t\t\tif (is_capture)\t \n\t\t\t\tpcxhr_update_audio_pipe_level(chip, 1, i);\n\t\t}\n\t}\n\tif (!is_capture && changed)\t \n\t\tpcxhr_update_playback_stream_level(chip, idx);\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_pcxhr_pcm_vol =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t \n\t \n\t.info =\t\tpcxhr_digital_vol_info,\t\t \n\t.get =\t\tpcxhr_pcm_vol_get,\n\t.put =\t\tpcxhr_pcm_vol_put,\n\t.tlv = { .p = db_scale_digital },\n};\n\n\nstatic int pcxhr_pcm_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];\n\tucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_pcm_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);  \n\tint i, j;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tj = idx;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->digital_playback_active[j][i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->digital_playback_active[j][i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tpcxhr_update_playback_stream_level(chip, idx);\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_pcm_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"PCM Playback Switch\",\n\t.count =\tPCXHR_PLAYBACK_STREAMS,\n\t.info =\t\tpcxhr_sw_info,\t\t \n\t.get =\t\tpcxhr_pcm_sw_get,\n\t.put =\t\tpcxhr_pcm_sw_put\n};\n\n\n \n\nstatic int pcxhr_monitor_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->monitoring_volume[0];\n\tucontrol->value.integer.value[1] = chip->monitoring_volume[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_monitor_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint i;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->monitoring_volume[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->monitoring_volume[i] =\n\t\t\t\tucontrol->value.integer.value[i];\n\t\t\tif (chip->monitoring_active[i])\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tpcxhr_update_audio_pipe_level(chip, 0, i);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_monitor_vol = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =         \"Monitoring Playback Volume\",\n\t.info =\t\tpcxhr_digital_vol_info,\t\t \n\t.get =\t\tpcxhr_monitor_vol_get,\n\t.put =\t\tpcxhr_monitor_vol_put,\n\t.tlv = { .p = db_scale_digital },\n};\n\n \n\nstatic int pcxhr_monitor_sw_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->monitoring_active[0];\n\tucontrol->value.integer.value[1] = chip->monitoring_active[1];\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int pcxhr_monitor_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tint i;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->monitoring_active[i] !=\n\t\t    ucontrol->value.integer.value[i]) {\n\t\t\tchip->monitoring_active[i] =\n\t\t\t\t!!ucontrol->value.integer.value[i];\n\t\t\tchanged |= (1<<i);  \n\t\t}\n\t}\n\tif (changed & 0x01)\n\t\t \n\t\tpcxhr_update_audio_pipe_level(chip, 0, 0);\n\tif (changed & 0x02)\n\t\t \n\t\tpcxhr_update_audio_pipe_level(chip, 0, 1);\n\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn (changed != 0);\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_monitor_sw = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Monitoring Playback Switch\",\n\t.info =         pcxhr_sw_info,\t\t \n\t.get =          pcxhr_monitor_sw_get,\n\t.put =          pcxhr_monitor_sw_put\n};\n\n\n\n \n#define PCXHR_SOURCE_AUDIO01_UER\t0x000100\n#define PCXHR_SOURCE_AUDIO01_SYNC\t0x000200\n#define PCXHR_SOURCE_AUDIO23_UER\t0x000400\n#define PCXHR_SOURCE_AUDIO45_UER\t0x001000\n#define PCXHR_SOURCE_AUDIO67_UER\t0x040000\n\nstatic int pcxhr_set_audio_source(struct snd_pcxhr* chip)\n{\n\tstruct pcxhr_rmh rmh;\n\tunsigned int mask, reg;\n\tunsigned int codec;\n\tint err, changed;\n\n\tswitch (chip->chip_idx) {\n\tcase 0 : mask = PCXHR_SOURCE_AUDIO01_UER; codec = CS8420_01_CS; break;\n\tcase 1 : mask = PCXHR_SOURCE_AUDIO23_UER; codec = CS8420_23_CS; break;\n\tcase 2 : mask = PCXHR_SOURCE_AUDIO45_UER; codec = CS8420_45_CS; break;\n\tcase 3 : mask = PCXHR_SOURCE_AUDIO67_UER; codec = CS8420_67_CS; break;\n\tdefault: return -EINVAL;\n\t}\n\tif (chip->audio_capture_source != 0) {\n\t\treg = mask;\t \n\t} else {\n\t\treg = 0;\t \n\t}\n\t \n\tpcxhr_write_io_num_reg_cont(chip->mgr, mask, reg, &changed);\n\t \n\tif (changed) {\n\t\tpcxhr_init_rmh(&rmh, CMD_RESYNC_AUDIO_INPUTS);\n\t\trmh.cmd[0] |= (1 << chip->chip_idx);\n\t\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (chip->mgr->board_aes_in_192k) {\n\t\tint i;\n\t\tunsigned int src_config = 0xC0;\n\t\t \n\t\tfor (i = 0; (i < 4) && (i < chip->mgr->capture_chips); i++) {\n\t\t\tif (chip->mgr->chip[i]->audio_capture_source == 2)\n\t\t\t\tsrc_config |= (1 << (3 - i));\n\t\t}\n\t\t \n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\t\trmh.cmd_len = 2;\n\t\trmh.cmd[0] |= IO_NUM_REG_CONFIG_SRC;\n\t\trmh.cmd[1] = src_config;\n\t\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\t} else {\n\t\tint use_src = 0;\n\t\tif (chip->audio_capture_source == 2)\n\t\t\tuse_src = 1;\n\t\t \n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\t\trmh.cmd_len = 3;\n\t\trmh.cmd[0] |= IO_NUM_UER_CHIP_REG;\n\t\trmh.cmd[1] = codec;\n\t\trmh.cmd[2] = ((CS8420_DATA_FLOW_CTL & CHIP_SIG_AND_MAP_SPI) |\n\t\t\t      (use_src ? 0x41 : 0x54));\n\t\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t\trmh.cmd[2] = ((CS8420_CLOCK_SRC_CTL & CHIP_SIG_AND_MAP_SPI) |\n\t\t\t      (use_src ? 0x41 : 0x49));\n\t\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\t}\n\treturn err;\n}\n\nstatic int pcxhr_audio_src_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *texts[5] = {\n\t\t\"Line\", \"Digital\", \"Digi+SRC\", \"Mic\", \"Line+Mic\"\n\t};\n\tint i;\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\n\ti = 2;\t\t\t \n\tif (chip->mgr->board_has_aes1) {\n\t\ti = 3;\t\t \n\t\tif (chip->mgr->board_has_mic)\n\t\t\ti = 5;\t \n\t}\n\treturn snd_ctl_enum_info(uinfo, 1, i, texts);\n}\n\nstatic int pcxhr_audio_src_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = chip->audio_capture_source;\n\treturn 0;\n}\n\nstatic int pcxhr_audio_src_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint ret = 0;\n\tint i = 2;\t\t \n\tif (chip->mgr->board_has_aes1) {\n\t\ti = 3;\t\t \n\t\tif (chip->mgr->board_has_mic)\n\t\t\ti = 5;\t \n\t}\n\tif (ucontrol->value.enumerated.item[0] >= i)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (chip->audio_capture_source != ucontrol->value.enumerated.item[0]) {\n\t\tchip->audio_capture_source = ucontrol->value.enumerated.item[0];\n\t\tif (chip->mgr->is_hr_stereo)\n\t\t\thr222_set_audio_source(chip);\n\t\telse\n\t\t\tpcxhr_set_audio_source(chip);\n\t\tret = 1;\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_audio_src = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Capture Source\",\n\t.info =\t\tpcxhr_audio_src_info,\n\t.get =\t\tpcxhr_audio_src_get,\n\t.put =\t\tpcxhr_audio_src_put,\n};\n\n\n \n\nstatic int pcxhr_clock_type_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *textsPCXHR[7] = {\n\t\t\"Internal\", \"WordClock\", \"AES Sync\",\n\t\t\"AES 1\", \"AES 2\", \"AES 3\", \"AES 4\"\n\t};\n\tstatic const char *textsHR22[3] = {\n\t\t\"Internal\", \"AES Sync\", \"AES 1\"\n\t};\n\tconst char **texts;\n\tstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\n\tint clock_items = 2;\t \n\tif (mgr->board_has_aes1) {\n\t\tclock_items += mgr->capture_chips;\t \n\t\tif (!mgr->is_hr_stereo)\n\t\t\tclock_items += 1;\t\t \n\t}\n\tif (mgr->is_hr_stereo) {\n\t\ttexts = textsHR22;\n\t\tsnd_BUG_ON(clock_items > (HR22_CLOCK_TYPE_MAX+1));\n\t} else {\n\t\ttexts = textsPCXHR;\n\t\tsnd_BUG_ON(clock_items > (PCXHR_CLOCK_TYPE_MAX+1));\n\t}\n\treturn snd_ctl_enum_info(uinfo, 1, clock_items, texts);\n}\n\nstatic int pcxhr_clock_type_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = mgr->use_clock_type;\n\treturn 0;\n}\n\nstatic int pcxhr_clock_type_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\n\tint rate, ret = 0;\n\tunsigned int clock_items = 2;  \n\tif (mgr->board_has_aes1) {\n\t\tclock_items += mgr->capture_chips;\t \n\t\tif (!mgr->is_hr_stereo)\n\t\t\tclock_items += 1;\t\t \n\t}\n\tif (ucontrol->value.enumerated.item[0] >= clock_items)\n\t\treturn -EINVAL;\n\tmutex_lock(&mgr->mixer_mutex);\n\tif (mgr->use_clock_type != ucontrol->value.enumerated.item[0]) {\n\t\tmutex_lock(&mgr->setup_mutex);\n\t\tmgr->use_clock_type = ucontrol->value.enumerated.item[0];\n\t\trate = 0;\n\t\tif (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {\n\t\t\tpcxhr_get_external_clock(mgr, mgr->use_clock_type,\n\t\t\t\t\t\t &rate);\n\t\t} else {\n\t\t\trate = mgr->sample_rate;\n\t\t\tif (!rate)\n\t\t\t\trate = 48000;\n\t\t}\n\t\tif (rate) {\n\t\t\tpcxhr_set_clock(mgr, rate);\n\t\t\tif (mgr->sample_rate)\n\t\t\t\tmgr->sample_rate = rate;\n\t\t}\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\tret = 1;  \n\t}\n\tmutex_unlock(&mgr->mixer_mutex);\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_clock_type = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Clock Mode\",\n\t.info =\t\tpcxhr_clock_type_info,\n\t.get =\t\tpcxhr_clock_type_get,\n\t.put =\t\tpcxhr_clock_type_put,\n};\n\n \nstatic int pcxhr_clock_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 3 + mgr->capture_chips;\n\tuinfo->value.integer.min = 0;\t\t \n\tuinfo->value.integer.max = 192000;\t \n\treturn 0;\n}\n\nstatic int pcxhr_clock_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\n\tint i, err, rate;\n\n\tmutex_lock(&mgr->mixer_mutex);\n\tfor(i = 0; i < 3 + mgr->capture_chips; i++) {\n\t\tif (i == PCXHR_CLOCK_TYPE_INTERNAL)\n\t\t\trate = mgr->sample_rate_real;\n\t\telse {\n\t\t\terr = pcxhr_get_external_clock(mgr, i, &rate);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tucontrol->value.integer.value[i] = rate;\n\t}\n\tmutex_unlock(&mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_clock_rate = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_CARD,\n\t.name =\t\t\"Clock Rates\",\n\t.info =\t\tpcxhr_clock_rate_info,\n\t.get =\t\tpcxhr_clock_rate_get,\n};\n\n \nstatic int pcxhr_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int pcxhr_iec958_capture_byte(struct snd_pcxhr *chip,\n\t\t\t\t     int aes_idx, unsigned char *aes_bits)\n{\n\tint i, err;\n\tunsigned char temp;\n\tstruct pcxhr_rmh rmh;\n\n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\n\trmh.cmd[0] |= IO_NUM_UER_CHIP_REG;\n\tswitch (chip->chip_idx) {\n\t   \n\tcase 0:\trmh.cmd[1] = CS8420_01_CS; break;\n\tcase 1:\trmh.cmd[1] = CS8420_23_CS; break;\n\tcase 2:\trmh.cmd[1] = CS8420_45_CS; break;\n\tcase 3:\trmh.cmd[1] = CS8420_67_CS; break;\n\tdefault: return -EINVAL;\n\t}\n\tif (chip->mgr->board_aes_in_192k) {\n\t\tswitch (aes_idx) {\n\t\tcase 0:\trmh.cmd[2] = CS8416_CSB0; break;\n\t\tcase 1:\trmh.cmd[2] = CS8416_CSB1; break;\n\t\tcase 2:\trmh.cmd[2] = CS8416_CSB2; break;\n\t\tcase 3:\trmh.cmd[2] = CS8416_CSB3; break;\n\t\tcase 4:\trmh.cmd[2] = CS8416_CSB4; break;\n\t\tdefault: return -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (aes_idx) {\n\t\t   \n\t\tcase 0:\trmh.cmd[2] = CS8420_CSB0; break;\n\t\tcase 1:\trmh.cmd[2] = CS8420_CSB1; break;\n\t\tcase 2:\trmh.cmd[2] = CS8420_CSB2; break;\n\t\tcase 3:\trmh.cmd[2] = CS8420_CSB3; break;\n\t\tcase 4:\trmh.cmd[2] = CS8420_CSB4; break;\n\t\tdefault: return -EINVAL;\n\t\t}\n\t}\n\t \n\trmh.cmd[1] &= 0x0fffff;\n\t \n\trmh.cmd[2] &= CHIP_SIG_AND_MAP_SPI;\n\trmh.cmd_len = 3;\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->mgr->board_aes_in_192k) {\n\t\ttemp = (unsigned char)rmh.stat[1];\n\t} else {\n\t\ttemp = 0;\n\t\t \n\t\tfor (i = 0; i < 8; i++) {\n\t\t\ttemp <<= 1;\n\t\t\tif (rmh.stat[1] & (1 << i))\n\t\t\t\ttemp |= 1;\n\t\t}\n\t}\n\tdev_dbg(chip->card->dev, \"read iec958 AES %d byte %d = 0x%x\\n\",\n\t\t    chip->chip_idx, aes_idx, temp);\n\t*aes_bits = temp;\n\treturn 0;\n}\n\nstatic int pcxhr_iec958_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char aes_bits;\n\tint i, err;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor(i = 0; i < 5; i++) {\n\t\tif (kcontrol->private_value == 0)\t \n\t\t\taes_bits = chip->aes_bits[i];\n\t\telse {\t\t\t\t \n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\terr = hr222_iec958_capture_byte(chip, i,\n\t\t\t\t\t\t\t\t&aes_bits);\n\t\t\telse\n\t\t\t\terr = pcxhr_iec958_capture_byte(chip, i,\n\t\t\t\t\t\t\t\t&aes_bits);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tucontrol->value.iec958.status[i] = aes_bits;\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n        return 0;\n}\n\nstatic int pcxhr_iec958_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint i;\n\tfor (i = 0; i < 5; i++)\n\t\tucontrol->value.iec958.status[i] = 0xff;\n        return 0;\n}\n\nstatic int pcxhr_iec958_update_byte(struct snd_pcxhr *chip,\n\t\t\t\t    int aes_idx, unsigned char aes_bits)\n{\n\tint i, err, cmd;\n\tunsigned char new_bits = aes_bits;\n\tunsigned char old_bits = chip->aes_bits[aes_idx];\n\tstruct pcxhr_rmh rmh;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((old_bits & 0x01) != (new_bits & 0x01)) {\n\t\t\tcmd = chip->chip_idx & 0x03;       \n\t\t\tif (chip->chip_idx > 3)\n\t\t\t\t \n\t\t\t\tcmd |= 1 << 22;\n\t\t\tcmd |= ((aes_idx << 3) + i) << 2;  \n\t\t\tcmd |= (new_bits & 0x01) << 23;    \n\t\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\t\t\trmh.cmd[0] |= IO_NUM_REG_CUER;\n\t\t\trmh.cmd[1] = cmd;\n\t\t\trmh.cmd_len = 2;\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"write iec958 AES %d byte %d bit %d (cmd %x)\\n\",\n\t\t\t\t    chip->chip_idx, aes_idx, i, cmd);\n\t\t\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\told_bits >>= 1;\n\t\tnew_bits >>= 1;\n\t}\n\tchip->aes_bits[aes_idx] = aes_bits;\n\treturn 0;\n}\n\nstatic int pcxhr_iec958_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint i, changed = 0;\n\n\t \n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tfor (i = 0; i < 5; i++) {\n\t\tif (ucontrol->value.iec958.status[i] != chip->aes_bits[i]) {\n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\thr222_iec958_update_byte(chip, i,\n\t\t\t\t\tucontrol->value.iec958.status[i]);\n\t\t\telse\n\t\t\t\tpcxhr_iec958_update_byte(chip, i,\n\t\t\t\t\tucontrol->value.iec958.status[i]);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcxhr_control_playback_iec958_mask = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.info =\t\tpcxhr_iec958_info,\n\t.get =\t\tpcxhr_iec958_mask_get\n};\nstatic const struct snd_kcontrol_new pcxhr_control_playback_iec958 = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =         pcxhr_iec958_info,\n\t.get =          pcxhr_iec958_get,\n\t.put =          pcxhr_iec958_put,\n\t.private_value = 0  \n};\n\nstatic const struct snd_kcontrol_new pcxhr_control_capture_iec958_mask = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",CAPTURE,MASK),\n\t.info =\t\tpcxhr_iec958_info,\n\t.get =\t\tpcxhr_iec958_mask_get\n};\nstatic const struct snd_kcontrol_new pcxhr_control_capture_iec958 = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",CAPTURE,DEFAULT),\n\t.info =         pcxhr_iec958_info,\n\t.get =          pcxhr_iec958_get,\n\t.private_value = 1  \n};\n\nstatic void pcxhr_init_audio_levels(struct snd_pcxhr *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->nb_streams_play) {\n\t\t\tint j;\n\t\t\t \n\t\t\tfor (j = 0; j < PCXHR_PLAYBACK_STREAMS; j++) {\n\t\t\t\tchip->digital_playback_active[j][i] = 1;\n\t\t\t\tchip->digital_playback_volume[j][i] =\n\t\t\t\t\tPCXHR_DIGITAL_ZERO_LEVEL;\n\t\t\t}\n\t\t\t \n\t\t\tchip->aes_bits[0] = (IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t     IEC958_AES0_PRO_FS_48000);\n#ifdef CONFIG_SND_DEBUG\n\t\t\t \n\t\t\tchip->analog_playback_active[i] = 1;\n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\tchip->analog_playback_volume[i] =\n\t\t\t\t\tHR222_LINE_PLAYBACK_ZERO_LEVEL;\n\t\t\telse {\n\t\t\t\tchip->analog_playback_volume[i] =\n\t\t\t\t\tPCXHR_LINE_PLAYBACK_ZERO_LEVEL;\n\t\t\t\tpcxhr_update_analog_audio_level(chip, 0, i);\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\thr222_update_analog_audio_level(chip, 0, i);\n\t\t}\n\t\tif (chip->nb_streams_capt) {\n\t\t\t \n\t\t\tchip->digital_capture_volume[i] =\n\t\t\t\tPCXHR_DIGITAL_ZERO_LEVEL;\n\t\t\tchip->analog_capture_active = 1;\n#ifdef CONFIG_SND_DEBUG\n\t\t\t \n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\tchip->analog_capture_volume[i] =\n\t\t\t\t\tHR222_LINE_CAPTURE_ZERO_LEVEL;\n\t\t\telse {\n\t\t\t\tchip->analog_capture_volume[i] =\n\t\t\t\t\tPCXHR_LINE_CAPTURE_ZERO_LEVEL;\n\t\t\t\tpcxhr_update_analog_audio_level(chip, 1, i);\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tif (chip->mgr->is_hr_stereo)\n\t\t\t\thr222_update_analog_audio_level(chip, 1, i);\n\t\t}\n\t}\n\n\treturn;\n}\n\n\nint pcxhr_create_mixer(struct pcxhr_mgr *mgr)\n{\n\tstruct snd_pcxhr *chip;\n\tint err, i;\n\n\tmutex_init(&mgr->mixer_mutex);  \n\n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tstruct snd_kcontrol_new temp;\n\t\tchip = mgr->chip[i];\n\n\t\tif (chip->nb_streams_play) {\n\t\t\t \n\t\t\ttemp = pcxhr_control_analog_level;\n\t\t\ttemp.name = \"Master Playback Volume\";\n\t\t\ttemp.private_value = 0;  \n\t\t\tif (mgr->is_hr_stereo)\n\t\t\t\ttemp.tlv.p = db_scale_a_hr222_playback;\n\t\t\telse\n\t\t\t\ttemp.tlv.p = db_scale_analog_playback;\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t\t  snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_output_switch,\n\t\t\t\t\t     chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\ttemp = snd_pcxhr_pcm_vol;\n\t\t\ttemp.name = \"PCM Playback Volume\";\n\t\t\ttemp.count = PCXHR_PLAYBACK_STREAMS;\n\t\t\ttemp.private_value = 0;  \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t\t  snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_pcm_switch, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_playback_iec958_mask,\n\t\t\t\t\t     chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_playback_iec958,\n\t\t\t\t\t     chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (chip->nb_streams_capt) {\n\t\t\t \n\t\t\ttemp = pcxhr_control_analog_level;\n\t\t\ttemp.name = \"Line Capture Volume\";\n\t\t\ttemp.private_value = 1;  \n\t\t\tif (mgr->is_hr_stereo)\n\t\t\t\ttemp.tlv.p = db_scale_a_hr222_capture;\n\t\t\telse\n\t\t\t\ttemp.tlv.p = db_scale_analog_capture;\n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t\t  snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\ttemp = snd_pcxhr_pcm_vol;\n\t\t\ttemp.name = \"PCM Capture Volume\";\n\t\t\ttemp.count = 1;\n\t\t\ttemp.private_value = 1;  \n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t\t  snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_audio_src, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_capture_iec958_mask,\n\t\t\t\t\t     chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_capture_iec958,\n\t\t\t\t\t     chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tif (mgr->is_hr_stereo) {\n\t\t\t\terr = hr222_add_mic_controls(chip);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (chip->nb_streams_capt > 0 && chip->nb_streams_play > 0) {\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_monitor_vol, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_monitor_sw, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_clock_type, mgr));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\t \n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&pcxhr_control_clock_rate, mgr));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tpcxhr_init_audio_levels(chip);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}