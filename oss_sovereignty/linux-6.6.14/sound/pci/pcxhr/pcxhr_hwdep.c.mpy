{
  "module_name": "pcxhr_hwdep.c",
  "hash_id": "796457647f6fe6b062df0eb85d227a733bdaaffbf6a96aa76b7200c9064045aa",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/pcxhr/pcxhr_hwdep.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/hwdep.h>\n#include \"pcxhr.h\"\n#include \"pcxhr_mixer.h\"\n#include \"pcxhr_hwdep.h\"\n#include \"pcxhr_core.h\"\n#include \"pcxhr_mix22.h\"\n\n\nstatic int pcxhr_sub_init(struct pcxhr_mgr *mgr);\n \nstatic int pcxhr_init_board(struct pcxhr_mgr *mgr)\n{\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\tint card_streams;\n\n\t \n\tif (mgr->mono_capture)\n\t\tcard_streams = mgr->capture_chips * 2;\n\telse\n\t\tcard_streams = mgr->capture_chips;\n\tcard_streams += mgr->playback_chips * PCXHR_PLAYBACK_STREAMS;\n\n\t \n\tpcxhr_enable_dsp(mgr);\n\n\tpcxhr_init_rmh(&rmh, CMD_SUPPORTED);\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\t \n\tif ((rmh.stat[0] & MASK_FIRST_FIELD) < mgr->playback_chips * 2)\n\t\treturn -EINVAL;\n\t \n\tif (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) <\n\t    mgr->capture_chips * 2)\n\t\treturn -EINVAL;\n\t \n\tif ((rmh.stat[1] & 0x5F) < card_streams)\n\t\treturn -EINVAL;\n\t \n\tif (((rmh.stat[1] >> 7) & 0x5F) < PCXHR_PLAYBACK_STREAMS)\n\t\treturn -EINVAL;\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"supported formats : playback=%x capture=%x\\n\",\n\t\t    rmh.stat[2], rmh.stat[3]);\n\n\tpcxhr_init_rmh(&rmh, CMD_VERSION);\n\t \n\trmh.cmd[0] |= mgr->firmware_num;\n\t \n\trmh.cmd[1] = (1<<23) + mgr->granularity;\n\trmh.cmd_len = 2;\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"PCXHR DSP version is %d.%d.%d\\n\", (rmh.stat[0]>>16)&0xff,\n\t\t    (rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);\n\tmgr->dsp_version = rmh.stat[0];\n\n\tif (mgr->is_hr_stereo)\n\t\terr = hr222_sub_init(mgr);\n\telse\n\t\terr = pcxhr_sub_init(mgr);\n\treturn err;\n}\n\nstatic int pcxhr_sub_init(struct pcxhr_mgr *mgr)\n{\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\n\t \n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\n\trmh.cmd[0] |= IO_NUM_REG_STATUS;\n\trmh.cmd[1]  = REG_STATUS_OPTIONS;\n\trmh.cmd_len = 2;\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\n\tif ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) ==\n\t    REG_STATUS_OPT_ANALOG_BOARD)\n\t\tmgr->board_has_analog = 1;\t \n\n\t \n\terr = pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,\n\t\t\t\t\t  REG_CONT_UNMUTE_INPUTS, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\n\trmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\n\tif (DSP_EXT_CMD_SET(mgr)) {\n\t\trmh.cmd[1]  = 1;\t \n\t\trmh.cmd_len = 2;\n\t}\n\terr = pcxhr_send_msg(mgr, &rmh);\n\treturn err;\n}\n\nvoid pcxhr_reset_board(struct pcxhr_mgr *mgr)\n{\n\tstruct pcxhr_rmh rmh;\n\n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\n\t\t \n\t    if (!mgr->is_hr_stereo) {\n\t\t \n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\t\trmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\n\t\tpcxhr_send_msg(mgr, &rmh);\n\t\t \n\t\tpcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,\n\t\t\t\t\t    0, NULL);\n\t    }\n\t\t \n\t}\n\t \n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_EPRM_INDEX))\n\t\tpcxhr_reset_dsp(mgr);\n\t \n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_XLX_COM_INDEX)) {\n\t\tpcxhr_reset_xilinx_com(mgr);\n\t\tmgr->dsp_loaded = 1;\n\t}\n\treturn;\n}\n\n\n \nstatic int pcxhr_dsp_allocate_pipe(struct pcxhr_mgr *mgr,\n\t\t\t\t   struct pcxhr_pipe *pipe,\n\t\t\t\t   int is_capture, int pin)\n{\n\tint stream_count, audio_count;\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\n\tif (is_capture) {\n\t\tstream_count = 1;\n\t\tif (mgr->mono_capture)\n\t\t\taudio_count = 1;\n\t\telse\n\t\t\taudio_count = 2;\n\t} else {\n\t\tstream_count = PCXHR_PLAYBACK_STREAMS;\n\t\taudio_count = 2;\t \n\t}\n\tdev_dbg(&mgr->pci->dev, \"snd_add_ref_pipe pin(%d) pcm%c0\\n\",\n\t\t    pin, is_capture ? 'c' : 'p');\n\tpipe->is_capture = is_capture;\n\tpipe->first_audio = pin;\n\t \n\tpcxhr_init_rmh(&rmh, CMD_RES_PIPE);\n\tpcxhr_set_pipe_cmd_params(&rmh, is_capture, pin,\n\t\t\t\t  audio_count, stream_count);\n\trmh.cmd[1] |= 0x020000;  \n\tif (DSP_EXT_CMD_SET(mgr)) {\n\t\t \n\t  rmh.cmd[rmh.cmd_len++] = (audio_count == 1) ? 0x01 : 0x03;\n\t}\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err < 0) {\n\t\tdev_err(&mgr->pci->dev, \"error pipe allocation \"\n\t\t\t   \"(CMD_RES_PIPE) err=%x!\\n\", err);\n\t\treturn err;\n\t}\n\tpipe->status = PCXHR_PIPE_DEFINED;\n\n\treturn 0;\n}\n\n \n#if 0\nstatic int pcxhr_dsp_free_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe)\n{\n\tstruct pcxhr_rmh rmh;\n\tint capture_mask = 0;\n\tint playback_mask = 0;\n\tint err = 0;\n\n\tif (pipe->is_capture)\n\t\tcapture_mask  = (1 << pipe->first_audio);\n\telse\n\t\tplayback_mask = (1 << pipe->first_audio);\n\n\t \n\terr = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 0);\n\tif (err < 0)\n\t\tdev_err(&mgr->pci->dev, \"error stopping pipe!\\n\");\n\t \n\tpcxhr_init_rmh(&rmh, CMD_FREE_PIPE);\n\tpcxhr_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->first_audio,\n\t\t\t\t  0, 0);\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err < 0)\n\t\tdev_err(&mgr->pci->dev, \"error pipe release \"\n\t\t\t   \"(CMD_FREE_PIPE) err(%x)\\n\", err);\n\tpipe->status = PCXHR_PIPE_UNDEFINED;\n\treturn err;\n}\n#endif\n\n\nstatic int pcxhr_config_pipes(struct pcxhr_mgr *mgr)\n{\n\tint err, i, j;\n\tstruct snd_pcxhr *chip;\n\tstruct pcxhr_pipe *pipe;\n\n\t \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tchip = mgr->chip[i];\n\t\tif (chip->nb_streams_play) {\n\t\t\tpipe = &chip->playback_pipe;\n\t\t\terr = pcxhr_dsp_allocate_pipe( mgr, pipe, 0, i*2);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tfor(j = 0; j < chip->nb_streams_play; j++)\n\t\t\t\tchip->playback_stream[j].pipe = pipe;\n\t\t}\n\t\tfor (j = 0; j < chip->nb_streams_capt; j++) {\n\t\t\tpipe = &chip->capture_pipe[j];\n\t\t\terr = pcxhr_dsp_allocate_pipe(mgr, pipe, 1, i*2 + j);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tchip->capture_stream[j].pipe = pipe;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pcxhr_start_pipes(struct pcxhr_mgr *mgr)\n{\n\tint i, j;\n\tstruct snd_pcxhr *chip;\n\tint playback_mask = 0;\n\tint capture_mask = 0;\n\n\t \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tchip = mgr->chip[i];\n\t\tif (chip->nb_streams_play)\n\t\t\tplayback_mask |= 1 << chip->playback_pipe.first_audio;\n\t\tfor (j = 0; j < chip->nb_streams_capt; j++)\n\t\t\tcapture_mask |= 1 << chip->capture_pipe[j].first_audio;\n\t}\n\treturn pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);\n}\n\n\nstatic int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,\n\t\t\t  const struct firmware *dsp)\n{\n\tint err, card_index;\n\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"loading dsp [%d] size = %zd\\n\", index, dsp->size);\n\n\tswitch (index) {\n\tcase PCXHR_FIRMWARE_XLX_INT_INDEX:\n\t\tpcxhr_reset_xilinx_com(mgr);\n\t\treturn pcxhr_load_xilinx_binary(mgr, dsp, 0);\n\n\tcase PCXHR_FIRMWARE_XLX_COM_INDEX:\n\t\tpcxhr_reset_xilinx_com(mgr);\n\t\treturn pcxhr_load_xilinx_binary(mgr, dsp, 1);\n\n\tcase PCXHR_FIRMWARE_DSP_EPRM_INDEX:\n\t\tpcxhr_reset_dsp(mgr);\n\t\treturn pcxhr_load_eeprom_binary(mgr, dsp);\n\n\tcase PCXHR_FIRMWARE_DSP_BOOT_INDEX:\n\t\treturn pcxhr_load_boot_binary(mgr, dsp);\n\n\tcase PCXHR_FIRMWARE_DSP_MAIN_INDEX:\n\t\terr = pcxhr_load_dsp_binary(mgr, dsp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\t \n\tdefault:\n\t\tdev_err(&mgr->pci->dev, \"wrong file index\\n\");\n\t\treturn -EFAULT;\n\t}  \n\n\t \n\terr = pcxhr_init_board(mgr);\n        if (err < 0) {\n\t\tdev_err(&mgr->pci->dev, \"pcxhr could not be set up\\n\");\n\t\treturn err;\n\t}\n\terr = pcxhr_config_pipes(mgr);\n        if (err < 0) {\n\t\tdev_err(&mgr->pci->dev, \"pcxhr pipes could not be set up\\n\");\n\t\treturn err;\n\t}\n       \t \n        for (card_index = 0; card_index < mgr->num_cards; card_index++) {\n\t\tstruct snd_pcxhr *chip = mgr->chip[card_index];\n\n\t\terr = pcxhr_create_pcm(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (card_index == 0) {\n\t\t\terr = pcxhr_create_mixer(chip->mgr);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = snd_card_register(chip->card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = pcxhr_start_pipes(mgr);\n        if (err < 0) {\n\t\tdev_err(&mgr->pci->dev, \"pcxhr pipes could not be started\\n\");\n\t\treturn err;\n\t}\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"pcxhr firmware downloaded and successfully set up\\n\");\n\n\treturn 0;\n}\n\n \nint pcxhr_setup_firmware(struct pcxhr_mgr *mgr)\n{\n\tstatic const char * const fw_files[][5] = {\n\t[0] = { \"xlxint.dat\", \"xlxc882hr.dat\",\n\t\t\"dspe882.e56\", \"dspb882hr.b56\", \"dspd882.d56\" },\n\t[1] = { \"xlxint.dat\", \"xlxc882e.dat\",\n\t\t\"dspe882.e56\", \"dspb882e.b56\", \"dspd882.d56\" },\n\t[2] = { \"xlxint.dat\", \"xlxc1222hr.dat\",\n\t\t\"dspe882.e56\", \"dspb1222hr.b56\", \"dspd1222.d56\" },\n\t[3] = { \"xlxint.dat\", \"xlxc1222e.dat\",\n\t\t\"dspe882.e56\", \"dspb1222e.b56\", \"dspd1222.d56\" },\n\t[4] = { NULL, \"xlxc222.dat\",\n\t\t\"dspe924.e56\", \"dspb924.b56\", \"dspd222.d56\" },\n\t[5] = { NULL, \"xlxc924.dat\",\n\t\t\"dspe924.e56\", \"dspb924.b56\", \"dspd222.d56\" },\n\t};\n\tchar path[32];\n\n\tconst struct firmware *fw_entry;\n\tint i, err;\n\tint fw_set = mgr->fw_file_set;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (!fw_files[fw_set][i])\n\t\t\tcontinue;\n\t\tsprintf(path, \"pcxhr/%s\", fw_files[fw_set][i]);\n\t\tif (request_firmware(&fw_entry, path, &mgr->pci->dev)) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"pcxhr: can't load firmware %s\\n\",\n\t\t\t\t   path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t \n\t\terr = pcxhr_dsp_load(mgr, i, fw_entry);\n\t\trelease_firmware(fw_entry);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmgr->dsp_loaded |= 1 << i;\n\t}\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"pcxhr/xlxint.dat\");\nMODULE_FIRMWARE(\"pcxhr/xlxc882hr.dat\");\nMODULE_FIRMWARE(\"pcxhr/xlxc882e.dat\");\nMODULE_FIRMWARE(\"pcxhr/dspe882.e56\");\nMODULE_FIRMWARE(\"pcxhr/dspb882hr.b56\");\nMODULE_FIRMWARE(\"pcxhr/dspb882e.b56\");\nMODULE_FIRMWARE(\"pcxhr/dspd882.d56\");\n\nMODULE_FIRMWARE(\"pcxhr/xlxc1222hr.dat\");\nMODULE_FIRMWARE(\"pcxhr/xlxc1222e.dat\");\nMODULE_FIRMWARE(\"pcxhr/dspb1222hr.b56\");\nMODULE_FIRMWARE(\"pcxhr/dspb1222e.b56\");\nMODULE_FIRMWARE(\"pcxhr/dspd1222.d56\");\n\nMODULE_FIRMWARE(\"pcxhr/xlxc222.dat\");\nMODULE_FIRMWARE(\"pcxhr/xlxc924.dat\");\nMODULE_FIRMWARE(\"pcxhr/dspe924.e56\");\nMODULE_FIRMWARE(\"pcxhr/dspb924.b56\");\nMODULE_FIRMWARE(\"pcxhr/dspd222.d56\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}