{
  "module_name": "pcxhr_mix22.c",
  "hash_id": "50b66edf94da8dd1a801f90470c12a6a29d76364fdf3fe755b5b39d5ff465283",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/pcxhr/pcxhr_mix22.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/asoundef.h>\n#include \"pcxhr.h\"\n#include \"pcxhr_core.h\"\n#include \"pcxhr_mix22.h\"\n\n\n \n#define PCXHR_DSP_RESET\t\t0x20\n#define PCXHR_XLX_CFG\t\t0x24\n#define PCXHR_XLX_RUER\t\t0x28\n#define PCXHR_XLX_DATA\t\t0x2C\n#define PCXHR_XLX_STATUS\t0x30\n#define PCXHR_XLX_LOFREQ\t0x34\n#define PCXHR_XLX_HIFREQ\t0x38\n#define PCXHR_XLX_CSUER\t\t0x3C\n#define PCXHR_XLX_SELMIC\t0x40\n\n#define PCXHR_DSP 2\n\n \n#define PCXHR_INPB(mgr, x)\tinb((mgr)->port[PCXHR_DSP] + (x))\n#define PCXHR_OUTPB(mgr, x, data) outb((data), (mgr)->port[PCXHR_DSP] + (x))\n\n\n \n#define PCXHR_DSP_RESET_DSP\t0x01\n#define PCXHR_DSP_RESET_MUTE\t0x02\n#define PCXHR_DSP_RESET_CODEC\t0x08\n#define PCXHR_DSP_RESET_SMPTE\t0x10\n#define PCXHR_DSP_RESET_GPO_OFFSET\t5\n#define PCXHR_DSP_RESET_GPO_MASK\t0x60\n\n \n#define PCXHR_CFG_SYNCDSP_MASK\t\t0x80\n#define PCXHR_CFG_DEPENDENCY_MASK\t0x60\n#define PCXHR_CFG_INDEPENDANT_SEL\t0x00\n#define PCXHR_CFG_MASTER_SEL\t\t0x40\n#define PCXHR_CFG_SLAVE_SEL\t\t0x20\n#define PCXHR_CFG_DATA_UER1_SEL_MASK\t0x10\t \n#define PCXHR_CFG_DATAIN_SEL_MASK\t0x08\t \n#define PCXHR_CFG_SRC_MASK\t\t0x04\t \n#define PCXHR_CFG_CLOCK_UER1_SEL_MASK\t0x02\t \n#define PCXHR_CFG_CLOCKIN_SEL_MASK\t0x01\t \n\n \n#define PCXHR_DATA_CODEC\t0x80\n#define AKM_POWER_CONTROL_CMD\t0xA007\n#define AKM_RESET_ON_CMD\t0xA100\n#define AKM_RESET_OFF_CMD\t0xA103\n#define AKM_CLOCK_INF_55K_CMD\t0xA240\n#define AKM_CLOCK_SUP_55K_CMD\t0xA24D\n#define AKM_MUTE_CMD\t\t0xA38D\n#define AKM_UNMUTE_CMD\t\t0xA30D\n#define AKM_LEFT_LEVEL_CMD\t0xA600\n#define AKM_RIGHT_LEVEL_CMD\t0xA700\n\n \n#define PCXHR_STAT_SRC_LOCK\t\t0x01\n#define PCXHR_STAT_LEVEL_IN\t\t0x02\n#define PCXHR_STAT_GPI_OFFSET\t\t2\n#define PCXHR_STAT_GPI_MASK\t\t0x0C\n#define PCXHR_STAT_MIC_CAPS\t\t0x10\n \n#define PCXHR_STAT_FREQ_SYNC_MASK\t0x01\n#define PCXHR_STAT_FREQ_UER1_MASK\t0x02\n#define PCXHR_STAT_FREQ_SAVE_MASK\t0x80\n\n \n#define PCXHR_SUER1_BIT_U_READ_MASK\t0x80\n#define PCXHR_SUER1_BIT_C_READ_MASK\t0x40\n#define PCXHR_SUER1_DATA_PRESENT_MASK\t0x20\n#define PCXHR_SUER1_CLOCK_PRESENT_MASK\t0x10\n#define PCXHR_SUER_BIT_U_READ_MASK\t0x08\n#define PCXHR_SUER_BIT_C_READ_MASK\t0x04\n#define PCXHR_SUER_DATA_PRESENT_MASK\t0x02\n#define PCXHR_SUER_CLOCK_PRESENT_MASK\t0x01\n\n#define PCXHR_SUER_BIT_U_WRITE_MASK\t0x02\n#define PCXHR_SUER_BIT_C_WRITE_MASK\t0x01\n\n \n#define PCXHR_SELMIC_PREAMPLI_OFFSET\t2\n#define PCXHR_SELMIC_PREAMPLI_MASK\t0x0C\n#define PCXHR_SELMIC_PHANTOM_ALIM\t0x80\n\n\nstatic const unsigned char g_hr222_p_level[] = {\n    0x00,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x01,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x02,    \n    0x03,    \n    0x03,    \n    0x03,    \n    0x03,    \n    0x03,    \n    0x03,    \n    0x04,    \n    0x04,    \n    0x04,    \n    0x04,    \n    0x05,    \n    0x05,    \n    0x05,    \n    0x05,    \n    0x06,    \n    0x06,    \n    0x06,    \n    0x07,    \n    0x07,    \n    0x08,    \n    0x08,    \n    0x09,    \n    0x09,    \n    0x0a,    \n    0x0a,    \n    0x0b,    \n    0x0b,    \n    0x0c,    \n    0x0d,    \n    0x0e,    \n    0x0e,    \n    0x0f,    \n    0x10,    \n    0x11,    \n    0x12,    \n    0x13,    \n    0x14,    \n    0x15,    \n    0x17,    \n    0x18,    \n    0x1a,    \n    0x1b,    \n    0x1d,    \n    0x1e,    \n    0x20,    \n    0x22,    \n    0x24,    \n    0x26,    \n    0x28,    \n    0x2b,    \n    0x2d,    \n    0x30,    \n    0x33,    \n    0x36,    \n    0x39,    \n    0x3c,    \n    0x40,    \n    0x44,    \n    0x48,    \n    0x4c,    \n    0x51,    \n    0x55,    \n    0x5a,    \n    0x60,    \n    0x66,    \n    0x6c,    \n    0x72,    \n    0x79,    \n    0x80,    \n    0x87,    \n    0x8f,    \n    0x98,    \n    0xa1,    \n    0xaa,    \n    0xb5,    \n    0xbf,    \n    0xcb,    \n    0xd7,    \n    0xe3,    \n    0xf1,    \n    0xff,    \n};\n\n\nstatic void hr222_config_akm(struct pcxhr_mgr *mgr, unsigned short data)\n{\n\tunsigned short mask = 0x8000;\n\t \n\tPCXHR_INPB(mgr, PCXHR_XLX_HIFREQ);\n\n\twhile (mask) {\n\t\tPCXHR_OUTPB(mgr, PCXHR_XLX_DATA,\n\t\t\t    data & mask ? PCXHR_DATA_CODEC : 0);\n\t\tmask >>= 1;\n\t}\n\t \n\tPCXHR_INPB(mgr, PCXHR_XLX_RUER);\n}\n\n\nstatic int hr222_set_hw_playback_level(struct pcxhr_mgr *mgr,\n\t\t\t\t       int idx, int level)\n{\n\tunsigned short cmd;\n\tif (idx > 1 ||\n\t    level < 0 ||\n\t    level >= ARRAY_SIZE(g_hr222_p_level))\n\t\treturn -EINVAL;\n\n\tif (idx == 0)\n\t\tcmd = AKM_LEFT_LEVEL_CMD;\n\telse\n\t\tcmd = AKM_RIGHT_LEVEL_CMD;\n\n\t \n\tcmd += g_hr222_p_level[level];\n\n\thr222_config_akm(mgr, cmd);\n\treturn 0;\n}\n\n\nstatic int hr222_set_hw_capture_level(struct pcxhr_mgr *mgr,\n\t\t\t\t      int level_l, int level_r, int level_mic)\n{\n\t \n\tunsigned int data;\n\tint i;\n\n\tif (!mgr->capture_chips)\n\t\treturn -EINVAL;\t \n\n\tdata  = ((level_mic & 0xff) << 24);\t \n\tdata |= ((level_mic & 0xff) << 16);\t \n\tdata |= ((level_r & 0xff) << 8);\t \n\tdata |= (level_l & 0xff);\t\t \n\n\tPCXHR_INPB(mgr, PCXHR_XLX_DATA);\t \n\t \n\tfor (i = 0; i < 32; i++, data <<= 1) {\n\t\tPCXHR_OUTPB(mgr, PCXHR_XLX_DATA,\n\t\t\t    (data & 0x80000000) ? PCXHR_DATA_CODEC : 0);\n\t}\n\tPCXHR_INPB(mgr, PCXHR_XLX_RUER);\t \n\treturn 0;\n}\n\nstatic void hr222_micro_boost(struct pcxhr_mgr *mgr, int level);\n\nint hr222_sub_init(struct pcxhr_mgr *mgr)\n{\n\tunsigned char reg;\n\n\tmgr->board_has_analog = 1;\t \n\tmgr->xlx_cfg = PCXHR_CFG_SYNCDSP_MASK;\n\n\treg = PCXHR_INPB(mgr, PCXHR_XLX_STATUS);\n\tif (reg & PCXHR_STAT_MIC_CAPS)\n\t\tmgr->board_has_mic = 1;\t \n\tdev_dbg(&mgr->pci->dev,\n\t\t\"MIC input available = %d\\n\", mgr->board_has_mic);\n\n\t \n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET,\n\t\t    PCXHR_DSP_RESET_DSP);\n\tmsleep(5);\n\tmgr->dsp_reset = PCXHR_DSP_RESET_DSP  |\n\t\t\t PCXHR_DSP_RESET_MUTE |\n\t\t\t PCXHR_DSP_RESET_CODEC;\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, mgr->dsp_reset);\n\t \n\tmsleep(5);\n\n\t \n\thr222_config_akm(mgr, AKM_POWER_CONTROL_CMD);\n\thr222_config_akm(mgr, AKM_CLOCK_INF_55K_CMD);\n\thr222_config_akm(mgr, AKM_UNMUTE_CMD);\n\thr222_config_akm(mgr, AKM_RESET_OFF_CMD);\n\n\t \n\thr222_micro_boost(mgr, 0);\n\n\treturn 0;\n}\n\n\n \n \nstatic int hr222_pll_freq_register(unsigned int freq,\n\t\t\t\t   unsigned int *pllreg,\n\t\t\t\t   unsigned int *realfreq)\n{\n\tunsigned int reg;\n\n\tif (freq < 6900 || freq > 219000)\n\t\treturn -EINVAL;\n\treg = (28224000 * 2) / freq;\n\treg = (reg - 1) / 2;\n\tif (reg < 0x100)\n\t\t*pllreg = reg + 0xC00;\n\telse if (reg < 0x200)\n\t\t*pllreg = reg + 0x800;\n\telse if (reg < 0x400)\n\t\t*pllreg = reg & 0x1ff;\n\telse if (reg < 0x800) {\n\t\t*pllreg = ((reg >> 1) & 0x1ff) + 0x200;\n\t\treg &= ~1;\n\t} else {\n\t\t*pllreg = ((reg >> 2) & 0x1ff) + 0x400;\n\t\treg &= ~3;\n\t}\n\tif (realfreq)\n\t\t*realfreq = (28224000 / (reg + 1));\n\treturn 0;\n}\n\nint hr222_sub_set_clock(struct pcxhr_mgr *mgr,\n\t\t\tunsigned int rate,\n\t\t\tint *changed)\n{\n\tunsigned int speed, pllreg = 0;\n\tint err;\n\tunsigned realfreq = rate;\n\n\tswitch (mgr->use_clock_type) {\n\tcase HR22_CLOCK_TYPE_INTERNAL:\n\t\terr = hr222_pll_freq_register(rate, &pllreg, &realfreq);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmgr->xlx_cfg &= ~(PCXHR_CFG_CLOCKIN_SEL_MASK |\n\t\t\t\t  PCXHR_CFG_CLOCK_UER1_SEL_MASK);\n\t\tbreak;\n\tcase HR22_CLOCK_TYPE_AES_SYNC:\n\t\tmgr->xlx_cfg |= PCXHR_CFG_CLOCKIN_SEL_MASK;\n\t\tmgr->xlx_cfg &= ~PCXHR_CFG_CLOCK_UER1_SEL_MASK;\n\t\tbreak;\n\tcase HR22_CLOCK_TYPE_AES_1:\n\t\tif (!mgr->board_has_aes1)\n\t\t\treturn -EINVAL;\n\n\t\tmgr->xlx_cfg |= (PCXHR_CFG_CLOCKIN_SEL_MASK |\n\t\t\t\t PCXHR_CFG_CLOCK_UER1_SEL_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\thr222_config_akm(mgr, AKM_MUTE_CMD);\n\n\tif (mgr->use_clock_type == HR22_CLOCK_TYPE_INTERNAL) {\n\t\tPCXHR_OUTPB(mgr, PCXHR_XLX_HIFREQ, pllreg >> 8);\n\t\tPCXHR_OUTPB(mgr, PCXHR_XLX_LOFREQ, pllreg & 0xff);\n\t}\n\n\t \n\tPCXHR_OUTPB(mgr, PCXHR_XLX_CFG, mgr->xlx_cfg);\n\n\t \n\tspeed = rate < 55000 ? 0 : 1;\n\tif (mgr->codec_speed != speed) {\n\t\tmgr->codec_speed = speed;\n\t\tif (speed == 0)\n\t\t\thr222_config_akm(mgr, AKM_CLOCK_INF_55K_CMD);\n\t\telse\n\t\t\thr222_config_akm(mgr, AKM_CLOCK_SUP_55K_CMD);\n\t}\n\n\tmgr->sample_rate_real = realfreq;\n\tmgr->cur_clock_type = mgr->use_clock_type;\n\n\tif (changed)\n\t\t*changed = 1;\n\n\thr222_config_akm(mgr, AKM_UNMUTE_CMD);\n\n\tdev_dbg(&mgr->pci->dev, \"set_clock to %dHz (realfreq=%d pllreg=%x)\\n\",\n\t\t    rate, realfreq, pllreg);\n\treturn 0;\n}\n\nint hr222_get_external_clock(struct pcxhr_mgr *mgr,\n\t\t\t     enum pcxhr_clock_type clock_type,\n\t\t\t     int *sample_rate)\n{\n\tint rate, calc_rate = 0;\n\tunsigned int ticks;\n\tunsigned char mask, reg;\n\n\tif (clock_type == HR22_CLOCK_TYPE_AES_SYNC) {\n\n\t\tmask = (PCXHR_SUER_CLOCK_PRESENT_MASK |\n\t\t\tPCXHR_SUER_DATA_PRESENT_MASK);\n\t\treg = PCXHR_STAT_FREQ_SYNC_MASK;\n\n\t} else if (clock_type == HR22_CLOCK_TYPE_AES_1 && mgr->board_has_aes1) {\n\n\t\tmask = (PCXHR_SUER1_CLOCK_PRESENT_MASK |\n\t\t\tPCXHR_SUER1_DATA_PRESENT_MASK);\n\t\treg = PCXHR_STAT_FREQ_UER1_MASK;\n\n\t} else {\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"get_external_clock : type %d not supported\\n\",\n\t\t\t    clock_type);\n\t\treturn -EINVAL;  \n\t}\n\n\tif ((PCXHR_INPB(mgr, PCXHR_XLX_CSUER) & mask) != mask) {\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"get_external_clock(%d) = 0 Hz\\n\", clock_type);\n\t\t*sample_rate = 0;\n\t\treturn 0;  \n\t}\n\n\tPCXHR_OUTPB(mgr, PCXHR_XLX_STATUS, reg);  \n\n\t \n\treg |= PCXHR_STAT_FREQ_SAVE_MASK;\n\n\tif (mgr->last_reg_stat != reg) {\n\t\tudelay(500);\t \n\t\tmgr->last_reg_stat = reg;\n\t}\n\n\tPCXHR_OUTPB(mgr, PCXHR_XLX_STATUS, reg);  \n\n\t \n\tticks = (unsigned int)PCXHR_INPB(mgr, PCXHR_XLX_CFG);\n\tticks = (ticks & 0x03) << 8;\n\tticks |= (unsigned int)PCXHR_INPB(mgr, PCXHR_DSP_RESET);\n\n\tif (ticks != 0)\n\t\tcalc_rate = 28224000 / ticks;\n\t \n\tif (calc_rate > 184200)\n\t\trate = 192000;\n\telse if (calc_rate > 152200)\n\t\trate = 176400;\n\telse if (calc_rate > 112000)\n\t\trate = 128000;\n\telse if (calc_rate > 92100)\n\t\trate = 96000;\n\telse if (calc_rate > 76100)\n\t\trate = 88200;\n\telse if (calc_rate > 56000)\n\t\trate = 64000;\n\telse if (calc_rate > 46050)\n\t\trate = 48000;\n\telse if (calc_rate > 38050)\n\t\trate = 44100;\n\telse if (calc_rate > 28000)\n\t\trate = 32000;\n\telse if (calc_rate > 23025)\n\t\trate = 24000;\n\telse if (calc_rate > 19025)\n\t\trate = 22050;\n\telse if (calc_rate > 14000)\n\t\trate = 16000;\n\telse if (calc_rate > 11512)\n\t\trate = 12000;\n\telse if (calc_rate > 9512)\n\t\trate = 11025;\n\telse if (calc_rate > 7000)\n\t\trate = 8000;\n\telse\n\t\trate = 0;\n\n\tdev_dbg(&mgr->pci->dev, \"External clock is at %d Hz (measured %d Hz)\\n\",\n\t\t    rate, calc_rate);\n\t*sample_rate = rate;\n\treturn 0;\n}\n\n\nint hr222_read_gpio(struct pcxhr_mgr *mgr, int is_gpi, int *value)\n{\n\tif (is_gpi) {\n\t\tunsigned char reg = PCXHR_INPB(mgr, PCXHR_XLX_STATUS);\n\t\t*value = (int)(reg & PCXHR_STAT_GPI_MASK) >>\n\t\t\t      PCXHR_STAT_GPI_OFFSET;\n\t} else {\n\t\t*value = (int)(mgr->dsp_reset & PCXHR_DSP_RESET_GPO_MASK) >>\n\t\t\t PCXHR_DSP_RESET_GPO_OFFSET;\n\t}\n\treturn 0;\n}\n\n\nint hr222_write_gpo(struct pcxhr_mgr *mgr, int value)\n{\n\tunsigned char reg = mgr->dsp_reset & ~PCXHR_DSP_RESET_GPO_MASK;\n\n\treg |= (unsigned char)(value << PCXHR_DSP_RESET_GPO_OFFSET) &\n\t       PCXHR_DSP_RESET_GPO_MASK;\n\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, reg);\n\tmgr->dsp_reset = reg;\n\treturn 0;\n}\n\nint hr222_manage_timecode(struct pcxhr_mgr *mgr, int enable)\n{\n\tif (enable)\n\t\tmgr->dsp_reset |= PCXHR_DSP_RESET_SMPTE;\n\telse\n\t\tmgr->dsp_reset &= ~PCXHR_DSP_RESET_SMPTE;\n\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, mgr->dsp_reset);\n\treturn 0;\n}\n\nint hr222_update_analog_audio_level(struct snd_pcxhr *chip,\n\t\t\t\t    int is_capture, int channel)\n{\n\tdev_dbg(chip->card->dev,\n\t\t\"hr222_update_analog_audio_level(%s chan=%d)\\n\",\n\t\t    is_capture ? \"capture\" : \"playback\", channel);\n\tif (is_capture) {\n\t\tint level_l, level_r, level_mic;\n\t\t \n\t\tif (chip->analog_capture_active) {\n\t\t\tlevel_l = chip->analog_capture_volume[0];\n\t\t\tlevel_r = chip->analog_capture_volume[1];\n\t\t} else {\n\t\t\tlevel_l = HR222_LINE_CAPTURE_LEVEL_MIN;\n\t\t\tlevel_r = HR222_LINE_CAPTURE_LEVEL_MIN;\n\t\t}\n\t\tif (chip->mic_active)\n\t\t\tlevel_mic = chip->mic_volume;\n\t\telse\n\t\t\tlevel_mic = HR222_MICRO_CAPTURE_LEVEL_MIN;\n\t\treturn hr222_set_hw_capture_level(chip->mgr,\n\t\t\t\t\t\t level_l, level_r, level_mic);\n\t} else {\n\t\tint vol;\n\t\tif (chip->analog_playback_active[channel])\n\t\t\tvol = chip->analog_playback_volume[channel];\n\t\telse\n\t\t\tvol = HR222_LINE_PLAYBACK_LEVEL_MIN;\n\t\treturn hr222_set_hw_playback_level(chip->mgr, channel, vol);\n\t}\n}\n\n\n \n#define SOURCE_LINE\t0\n#define SOURCE_DIGITAL\t1\n#define SOURCE_DIGISRC\t2\n#define SOURCE_MIC\t3\n#define SOURCE_LINEMIC\t4\n\nint hr222_set_audio_source(struct snd_pcxhr *chip)\n{\n\tint digital = 0;\n\t \n\tchip->mgr->xlx_cfg &= ~(PCXHR_CFG_SRC_MASK |\n\t\t\t\tPCXHR_CFG_DATAIN_SEL_MASK |\n\t\t\t\tPCXHR_CFG_DATA_UER1_SEL_MASK);\n\n\tif (chip->audio_capture_source == SOURCE_DIGISRC) {\n\t\tchip->mgr->xlx_cfg |= PCXHR_CFG_SRC_MASK;\n\t\tdigital = 1;\n\t} else {\n\t\tif (chip->audio_capture_source == SOURCE_DIGITAL)\n\t\t\tdigital = 1;\n\t}\n\tif (digital) {\n\t\tchip->mgr->xlx_cfg |=  PCXHR_CFG_DATAIN_SEL_MASK;\n\t\tif (chip->mgr->board_has_aes1) {\n\t\t\t \n\t\t\tchip->mgr->xlx_cfg |= PCXHR_CFG_DATA_UER1_SEL_MASK;\n\t\t}\n\t\t \n\t\t \n\t} else {\n\t\tint update_lvl = 0;\n\t\tchip->analog_capture_active = 0;\n\t\tchip->mic_active = 0;\n\t\tif (chip->audio_capture_source == SOURCE_LINE ||\n\t\t    chip->audio_capture_source == SOURCE_LINEMIC) {\n\t\t\tif (chip->analog_capture_active == 0)\n\t\t\t\tupdate_lvl = 1;\n\t\t\tchip->analog_capture_active = 1;\n\t\t}\n\t\tif (chip->audio_capture_source == SOURCE_MIC ||\n\t\t    chip->audio_capture_source == SOURCE_LINEMIC) {\n\t\t\tif (chip->mic_active == 0)\n\t\t\t\tupdate_lvl = 1;\n\t\t\tchip->mic_active = 1;\n\t\t}\n\t\tif (update_lvl) {\n\t\t\t \n\t\t\thr222_update_analog_audio_level(chip, 1, 0);\n\t\t}\n\t}\n\t \n\tPCXHR_OUTPB(chip->mgr, PCXHR_XLX_CFG, chip->mgr->xlx_cfg);\n\treturn 0;\n}\n\n\nint hr222_iec958_capture_byte(struct snd_pcxhr *chip,\n\t\t\t     int aes_idx, unsigned char *aes_bits)\n{\n\tunsigned char idx = (unsigned char)(aes_idx * 8);\n\tunsigned char temp = 0;\n\tunsigned char mask = chip->mgr->board_has_aes1 ?\n\t\tPCXHR_SUER1_BIT_C_READ_MASK : PCXHR_SUER_BIT_C_READ_MASK;\n\tint i;\n\tfor (i = 0; i < 8; i++) {\n\t\tPCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx++);  \n\t\ttemp <<= 1;\n\t\tif (PCXHR_INPB(chip->mgr, PCXHR_XLX_CSUER) & mask)\n\t\t\ttemp |= 1;\n\t}\n\tdev_dbg(chip->card->dev, \"read iec958 AES %d byte %d = 0x%x\\n\",\n\t\t    chip->chip_idx, aes_idx, temp);\n\t*aes_bits = temp;\n\treturn 0;\n}\n\n\nint hr222_iec958_update_byte(struct snd_pcxhr *chip,\n\t\t\t     int aes_idx, unsigned char aes_bits)\n{\n\tint i;\n\tunsigned char new_bits = aes_bits;\n\tunsigned char old_bits = chip->aes_bits[aes_idx];\n\tunsigned char idx = (unsigned char)(aes_idx * 8);\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((old_bits & 0x01) != (new_bits & 0x01)) {\n\t\t\t \n\t\t\tPCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx);\n\t\t\t \n\t\t\tPCXHR_OUTPB(chip->mgr, PCXHR_XLX_CSUER, new_bits&0x01 ?\n\t\t\t\t    PCXHR_SUER_BIT_C_WRITE_MASK : 0);\n\t\t}\n\t\tidx++;\n\t\told_bits >>= 1;\n\t\tnew_bits >>= 1;\n\t}\n\tchip->aes_bits[aes_idx] = aes_bits;\n\treturn 0;\n}\n\nstatic void hr222_micro_boost(struct pcxhr_mgr *mgr, int level)\n{\n\tunsigned char boost_mask;\n\tboost_mask = (unsigned char) (level << PCXHR_SELMIC_PREAMPLI_OFFSET);\n\tif (boost_mask & (~PCXHR_SELMIC_PREAMPLI_MASK))\n\t\treturn;  \n\n\tmgr->xlx_selmic &= ~PCXHR_SELMIC_PREAMPLI_MASK;\n\tmgr->xlx_selmic |= boost_mask;\n\n\tPCXHR_OUTPB(mgr, PCXHR_XLX_SELMIC, mgr->xlx_selmic);\n\n\tdev_dbg(&mgr->pci->dev, \"hr222_micro_boost : set %x\\n\", boost_mask);\n}\n\nstatic void hr222_phantom_power(struct pcxhr_mgr *mgr, int power)\n{\n\tif (power)\n\t\tmgr->xlx_selmic |= PCXHR_SELMIC_PHANTOM_ALIM;\n\telse\n\t\tmgr->xlx_selmic &= ~PCXHR_SELMIC_PHANTOM_ALIM;\n\n\tPCXHR_OUTPB(mgr, PCXHR_XLX_SELMIC, mgr->xlx_selmic);\n\n\tdev_dbg(&mgr->pci->dev, \"hr222_phantom_power : set %d\\n\", power);\n}\n\n\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_mic_hr222, -9850, 50, 650);\n\nstatic int hr222_mic_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = HR222_MICRO_CAPTURE_LEVEL_MIN;  \n\t \n\tuinfo->value.integer.max = HR222_MICRO_CAPTURE_LEVEL_MAX;  \n\treturn 0;\n}\n\nstatic int hr222_mic_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->mic_volume;\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int hr222_mic_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (chip->mic_volume != ucontrol->value.integer.value[0]) {\n\t\tchanged = 1;\n\t\tchip->mic_volume = ucontrol->value.integer.value[0];\n\t\thr222_update_analog_audio_level(chip, 1, 0);\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new hr222_control_mic_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"Mic Capture Volume\",\n\t.info =\t\thr222_mic_vol_info,\n\t.get =\t\thr222_mic_vol_get,\n\t.put =\t\thr222_mic_vol_put,\n\t.tlv = { .p = db_scale_mic_hr222 },\n};\n\n\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_micboost_hr222, 0, 1800, 5400);\n\nstatic int hr222_mic_boost_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\t \n\tuinfo->value.integer.max = 3;\t \n\treturn 0;\n}\n\nstatic int hr222_mic_boost_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->mic_boost;\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int hr222_mic_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tif (chip->mic_boost != ucontrol->value.integer.value[0]) {\n\t\tchanged = 1;\n\t\tchip->mic_boost = ucontrol->value.integer.value[0];\n\t\thr222_micro_boost(chip->mgr, chip->mic_boost);\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new hr222_control_mic_boost = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"MicBoost Capture Volume\",\n\t.info =\t\thr222_mic_boost_info,\n\t.get =\t\thr222_mic_boost_get,\n\t.put =\t\thr222_mic_boost_put,\n\t.tlv = { .p = db_scale_micboost_hr222 },\n};\n\n\n \n#define hr222_phantom_power_info\tsnd_ctl_boolean_mono_info\n\nstatic int hr222_phantom_power_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->phantom_power;\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn 0;\n}\n\nstatic int hr222_phantom_power_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\n\tint power, changed = 0;\n\n\tmutex_lock(&chip->mgr->mixer_mutex);\n\tpower = !!ucontrol->value.integer.value[0];\n\tif (chip->phantom_power != power) {\n\t\thr222_phantom_power(chip->mgr, power);\n\t\tchip->phantom_power = power;\n\t\tchanged = 1;\n\t}\n\tmutex_unlock(&chip->mgr->mixer_mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new hr222_phantom_power_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Phantom Power Switch\",\n\t.info = hr222_phantom_power_info,\n\t.get = hr222_phantom_power_get,\n\t.put = hr222_phantom_power_put,\n};\n\n\nint hr222_add_mic_controls(struct snd_pcxhr *chip)\n{\n\tint err;\n\tif (!chip->mgr->board_has_mic)\n\t\treturn 0;\n\n\t \n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_level,\n\t\t\t\t\t\t   chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_boost,\n\t\t\t\t\t\t   chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_phantom_power_switch,\n\t\t\t\t\t\t   chip));\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}