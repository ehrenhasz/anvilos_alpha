{
  "module_name": "pcxhr.c",
  "hash_id": "9bb6f13a0c6fe618edf33456974b362a9acb9349d26cb262ad338d73673694f2",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/pcxhr/pcxhr.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"pcxhr.h\"\n#include \"pcxhr_mixer.h\"\n#include \"pcxhr_hwdep.h\"\n#include \"pcxhr_core.h\"\n#include \"pcxhr_mix22.h\"\n\n#define DRIVER_NAME \"pcxhr\"\n\nMODULE_AUTHOR(\"Markus Bollinger <bollinger@digigram.com>, \"\n\t      \"Marc Titinger <titinger@digigram.com>\");\nMODULE_DESCRIPTION(\"Digigram \" DRIVER_NAME \" \" PCXHR_DRIVER_VERSION_STRING);\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; \nstatic bool mono[SNDRV_CARDS];\t\t\t\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Digigram \" DRIVER_NAME \" soundcard\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Digigram \" DRIVER_NAME \" soundcard\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Digigram \" DRIVER_NAME \" soundcard\");\nmodule_param_array(mono, bool, NULL, 0444);\nMODULE_PARM_DESC(mono, \"Mono capture mode (default is stereo)\");\n\nenum {\n\tPCI_ID_VX882HR,\n\tPCI_ID_PCX882HR,\n\tPCI_ID_VX881HR,\n\tPCI_ID_PCX881HR,\n\tPCI_ID_VX882E,\n\tPCI_ID_PCX882E,\n\tPCI_ID_VX881E,\n\tPCI_ID_PCX881E,\n\tPCI_ID_VX1222HR,\n\tPCI_ID_PCX1222HR,\n\tPCI_ID_VX1221HR,\n\tPCI_ID_PCX1221HR,\n\tPCI_ID_VX1222E,\n\tPCI_ID_PCX1222E,\n\tPCI_ID_VX1221E,\n\tPCI_ID_PCX1221E,\n\tPCI_ID_VX222HR,\n\tPCI_ID_VX222E,\n\tPCI_ID_PCX22HR,\n\tPCI_ID_PCX22E,\n\tPCI_ID_VX222HRMIC,\n\tPCI_ID_VX222E_MIC,\n\tPCI_ID_PCX924HR,\n\tPCI_ID_PCX924E,\n\tPCI_ID_PCX924HRMIC,\n\tPCI_ID_PCX924E_MIC,\n\tPCI_ID_VX442HR,\n\tPCI_ID_PCX442HR,\n\tPCI_ID_VX442E,\n\tPCI_ID_PCX442E,\n\tPCI_ID_VX822HR,\n\tPCI_ID_PCX822HR,\n\tPCI_ID_VX822E,\n\tPCI_ID_PCX822E,\n\tPCI_ID_LAST\n};\n\nstatic const struct pci_device_id pcxhr_ids[] = {\n\t{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb301, 0, 0, PCI_ID_PCX881HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb021, 0, 0, PCI_ID_VX882E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb121, 0, 0, PCI_ID_PCX882E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb221, 0, 0, PCI_ID_VX881E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb321, 0, 0, PCI_ID_PCX881E, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb401, 0, 0, PCI_ID_VX1222HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb501, 0, 0, PCI_ID_PCX1222HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb601, 0, 0, PCI_ID_VX1221HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xb701, 0, 0, PCI_ID_PCX1221HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb421, 0, 0, PCI_ID_VX1222E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb521, 0, 0, PCI_ID_PCX1222E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb621, 0, 0, PCI_ID_VX1221E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xb721, 0, 0, PCI_ID_PCX1221E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xba01, 0, 0, PCI_ID_VX222HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xba21, 0, 0, PCI_ID_VX222E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbd01, 0, 0, PCI_ID_PCX22HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbd21, 0, 0, PCI_ID_PCX22E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbc01, 0, 0, PCI_ID_VX222HRMIC, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbc21, 0, 0, PCI_ID_VX222E_MIC, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbb01, 0, 0, PCI_ID_PCX924HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbb21, 0, 0, PCI_ID_PCX924E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbf01, 0, 0, PCI_ID_PCX924HRMIC, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xbf21, 0, 0, PCI_ID_PCX924E_MIC, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xd001, 0, 0, PCI_ID_VX442HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xd101, 0, 0, PCI_ID_PCX442HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xd021, 0, 0, PCI_ID_VX442E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xd121, 0, 0, PCI_ID_PCX442E, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xd201, 0, 0, PCI_ID_VX822HR, },\n\t{ 0x10b5, 0x9656, 0x1369, 0xd301, 0, 0, PCI_ID_PCX822HR, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xd221, 0, 0, PCI_ID_VX822E, },\n\t{ 0x10b5, 0x9056, 0x1369, 0xd321, 0, 0, PCI_ID_PCX822E, },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, pcxhr_ids);\n\nstruct board_parameters {\n\tchar* board_name;\n\tshort playback_chips;\n\tshort capture_chips;\n\tshort fw_file_set;\n\tshort firmware_num;\n};\nstatic const struct board_parameters pcxhr_board_params[] = {\n[PCI_ID_VX882HR] =      { \"VX882HR\",      4, 4, 0, 41 },\n[PCI_ID_PCX882HR] =     { \"PCX882HR\",     4, 4, 0, 41 },\n[PCI_ID_VX881HR] =      { \"VX881HR\",      4, 4, 0, 41 },\n[PCI_ID_PCX881HR] =     { \"PCX881HR\",     4, 4, 0, 41 },\n[PCI_ID_VX882E] =       { \"VX882e\",       4, 4, 1, 41 },\n[PCI_ID_PCX882E] =      { \"PCX882e\",      4, 4, 1, 41 },\n[PCI_ID_VX881E] =       { \"VX881e\",       4, 4, 1, 41 },\n[PCI_ID_PCX881E] =      { \"PCX881e\",      4, 4, 1, 41 },\n[PCI_ID_VX1222HR] =     { \"VX1222HR\",     6, 1, 2, 42 },\n[PCI_ID_PCX1222HR] =    { \"PCX1222HR\",    6, 1, 2, 42 },\n[PCI_ID_VX1221HR] =     { \"VX1221HR\",     6, 1, 2, 42 },\n[PCI_ID_PCX1221HR] =    { \"PCX1221HR\",    6, 1, 2, 42 },\n[PCI_ID_VX1222E] =      { \"VX1222e\",      6, 1, 3, 42 },\n[PCI_ID_PCX1222E] =     { \"PCX1222e\",     6, 1, 3, 42 },\n[PCI_ID_VX1221E] =      { \"VX1221e\",      6, 1, 3, 42 },\n[PCI_ID_PCX1221E] =     { \"PCX1221e\",     6, 1, 3, 42 },\n[PCI_ID_VX222HR] =      { \"VX222HR\",      1, 1, 4, 44 },\n[PCI_ID_VX222E] =       { \"VX222e\",       1, 1, 4, 44 },\n[PCI_ID_PCX22HR] =      { \"PCX22HR\",      1, 0, 4, 44 },\n[PCI_ID_PCX22E] =       { \"PCX22e\",       1, 0, 4, 44 },\n[PCI_ID_VX222HRMIC] =   { \"VX222HR-Mic\",  1, 1, 5, 44 },\n[PCI_ID_VX222E_MIC] =   { \"VX222e-Mic\",   1, 1, 5, 44 },\n[PCI_ID_PCX924HR] =     { \"PCX924HR\",     1, 1, 5, 44 },\n[PCI_ID_PCX924E] =      { \"PCX924e\",      1, 1, 5, 44 },\n[PCI_ID_PCX924HRMIC] =  { \"PCX924HR-Mic\", 1, 1, 5, 44 },\n[PCI_ID_PCX924E_MIC] =  { \"PCX924e-Mic\",  1, 1, 5, 44 },\n[PCI_ID_VX442HR] =      { \"VX442HR\",      2, 2, 0, 41 },\n[PCI_ID_PCX442HR] =     { \"PCX442HR\",     2, 2, 0, 41 },\n[PCI_ID_VX442E] =       { \"VX442e\",       2, 2, 1, 41 },\n[PCI_ID_PCX442E] =      { \"PCX442e\",      2, 2, 1, 41 },\n[PCI_ID_VX822HR] =      { \"VX822HR\",      4, 1, 2, 42 },\n[PCI_ID_PCX822HR] =     { \"PCX822HR\",     4, 1, 2, 42 },\n[PCI_ID_VX822E] =       { \"VX822e\",       4, 1, 3, 42 },\n[PCI_ID_PCX822E] =      { \"PCX822e\",      4, 1, 3, 42 },\n};\n\n \n \n#define PCXHR_BOARD_HAS_AES1(x) (x->fw_file_set != 4)\n \n#define PCXHR_BOARD_AESIN_NO_192K(x) ((x->capture_chips == 0) || \\\n\t\t\t\t      (x->fw_file_set == 0)   || \\\n\t\t\t\t      (x->fw_file_set == 2))\n\nstatic int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,\n\t\t\t\t   unsigned int* realfreq)\n{\n\tunsigned int reg;\n\n\tif (freq < 6900 || freq > 110000)\n\t\treturn -EINVAL;\n\treg = (28224000 * 2) / freq;\n\treg = (reg - 1) / 2;\n\tif (reg < 0x200)\n\t\t*pllreg = reg + 0x800;\n\telse if (reg < 0x400)\n\t\t*pllreg = reg & 0x1ff;\n\telse if (reg < 0x800) {\n\t\t*pllreg = ((reg >> 1) & 0x1ff) + 0x200;\n\t\treg &= ~1;\n\t} else {\n\t\t*pllreg = ((reg >> 2) & 0x1ff) + 0x400;\n\t\treg &= ~3;\n\t}\n\tif (realfreq)\n\t\t*realfreq = (28224000 / (reg + 1));\n\treturn 0;\n}\n\n\n#define PCXHR_FREQ_REG_MASK\t\t0x1f\n#define PCXHR_FREQ_QUARTZ_48000\t\t0x00\n#define PCXHR_FREQ_QUARTZ_24000\t\t0x01\n#define PCXHR_FREQ_QUARTZ_12000\t\t0x09\n#define PCXHR_FREQ_QUARTZ_32000\t\t0x08\n#define PCXHR_FREQ_QUARTZ_16000\t\t0x04\n#define PCXHR_FREQ_QUARTZ_8000\t\t0x0c\n#define PCXHR_FREQ_QUARTZ_44100\t\t0x02\n#define PCXHR_FREQ_QUARTZ_22050\t\t0x0a\n#define PCXHR_FREQ_QUARTZ_11025\t\t0x06\n#define PCXHR_FREQ_PLL\t\t\t0x05\n#define PCXHR_FREQ_QUARTZ_192000\t0x10\n#define PCXHR_FREQ_QUARTZ_96000\t\t0x18\n#define PCXHR_FREQ_QUARTZ_176400\t0x14\n#define PCXHR_FREQ_QUARTZ_88200\t\t0x1c\n#define PCXHR_FREQ_QUARTZ_128000\t0x12\n#define PCXHR_FREQ_QUARTZ_64000\t\t0x1a\n\n#define PCXHR_FREQ_WORD_CLOCK\t\t0x0f\n#define PCXHR_FREQ_SYNC_AES\t\t0x0e\n#define PCXHR_FREQ_AES_1\t\t0x07\n#define PCXHR_FREQ_AES_2\t\t0x0b\n#define PCXHR_FREQ_AES_3\t\t0x03\n#define PCXHR_FREQ_AES_4\t\t0x0d\n\nstatic int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,\n\t\t\t       unsigned int *reg, unsigned int *freq)\n{\n\tunsigned int val, realfreq, pllreg;\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\n\trealfreq = rate;\n\tswitch (mgr->use_clock_type) {\n\tcase PCXHR_CLOCK_TYPE_INTERNAL :\t \n\t\tswitch (rate) {\n\t\tcase 48000 :\tval = PCXHR_FREQ_QUARTZ_48000;\tbreak;\n\t\tcase 24000 :\tval = PCXHR_FREQ_QUARTZ_24000;\tbreak;\n\t\tcase 12000 :\tval = PCXHR_FREQ_QUARTZ_12000;\tbreak;\n\t\tcase 32000 :\tval = PCXHR_FREQ_QUARTZ_32000;\tbreak;\n\t\tcase 16000 :\tval = PCXHR_FREQ_QUARTZ_16000;\tbreak;\n\t\tcase 8000 :\tval = PCXHR_FREQ_QUARTZ_8000;\tbreak;\n\t\tcase 44100 :\tval = PCXHR_FREQ_QUARTZ_44100;\tbreak;\n\t\tcase 22050 :\tval = PCXHR_FREQ_QUARTZ_22050;\tbreak;\n\t\tcase 11025 :\tval = PCXHR_FREQ_QUARTZ_11025;\tbreak;\n\t\tcase 192000 :\tval = PCXHR_FREQ_QUARTZ_192000;\tbreak;\n\t\tcase 96000 :\tval = PCXHR_FREQ_QUARTZ_96000;\tbreak;\n\t\tcase 176400 :\tval = PCXHR_FREQ_QUARTZ_176400;\tbreak;\n\t\tcase 88200 :\tval = PCXHR_FREQ_QUARTZ_88200;\tbreak;\n\t\tcase 128000 :\tval = PCXHR_FREQ_QUARTZ_128000;\tbreak;\n\t\tcase 64000 :\tval = PCXHR_FREQ_QUARTZ_64000;\tbreak;\n\t\tdefault :\n\t\t\tval = PCXHR_FREQ_PLL;\n\t\t\t \n\t\t\terr = pcxhr_pll_freq_register(rate, &pllreg, &realfreq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\t\t\trmh.cmd[0] |= IO_NUM_REG_GENCLK;\n\t\t\trmh.cmd[1]  = pllreg & MASK_DSP_WORD;\n\t\t\trmh.cmd[2]  = pllreg >> 24;\n\t\t\trmh.cmd_len = 3;\n\t\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t   \"error CMD_ACCESS_IO_WRITE \"\n\t\t\t\t\t   \"for PLL register : %x!\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_WORD_CLOCK:\n\t\tval = PCXHR_FREQ_WORD_CLOCK;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_SYNC:\n\t\tval = PCXHR_FREQ_SYNC_AES;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_1:\n\t\tval = PCXHR_FREQ_AES_1;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_2:\n\t\tval = PCXHR_FREQ_AES_2;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_3:\n\t\tval = PCXHR_FREQ_AES_3;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_4:\n\t\tval = PCXHR_FREQ_AES_4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*reg = val;\n\t*freq = realfreq;\n\treturn 0;\n}\n\n\nstatic int pcxhr_sub_set_clock(struct pcxhr_mgr *mgr,\n\t\t\t       unsigned int rate,\n\t\t\t       int *changed)\n{\n\tunsigned int val, realfreq, speed;\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\n\terr = pcxhr_get_clock_reg(mgr, rate, &val, &realfreq);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (rate < 55000)\n\t\tspeed = 0;\t \n\telse if (rate < 100000)\n\t\tspeed = 1;\t \n\telse\n\t\tspeed = 2;\t \n\tif (mgr->codec_speed != speed) {\n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);  \n\t\trmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\n\t\tif (DSP_EXT_CMD_SET(mgr)) {\n\t\t\trmh.cmd[1]  = 1;\n\t\t\trmh.cmd_len = 2;\n\t\t}\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);  \n\t\trmh.cmd[0] |= IO_NUM_SPEED_RATIO;\n\t\trmh.cmd[1] = speed;\n\t\trmh.cmd_len = 2;\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\tdev_dbg(&mgr->pci->dev, \"clock register : set %x\\n\", val);\n\terr = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK,\n\t\t\t\t\t  val, changed);\n\tif (err)\n\t\treturn err;\n\n\tmgr->sample_rate_real = realfreq;\n\tmgr->cur_clock_type = mgr->use_clock_type;\n\n\t \n\tif (mgr->codec_speed != speed) {\n\t\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);  \n\t\trmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;\n\t\tif (DSP_EXT_CMD_SET(mgr)) {\n\t\t\trmh.cmd[1]  = 1;\n\t\t\trmh.cmd_len = 2;\n\t\t}\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmgr->codec_speed = speed;\t \n\t}\n\n\tdev_dbg(&mgr->pci->dev, \"%s to %dHz (realfreq=%d)\\n\", __func__,\n\t\t    rate, realfreq);\n\treturn 0;\n}\n\n#define PCXHR_MODIFY_CLOCK_S_BIT\t0x04\n\n#define PCXHR_IRQ_TIMER_FREQ\t\t92000\n#define PCXHR_IRQ_TIMER_PERIOD\t\t48\n\nint pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err, changed;\n\n\tif (rate == 0)\n\t\treturn 0;  \n\n\tif (mgr->is_hr_stereo)\n\t\terr = hr222_sub_set_clock(mgr, rate, &changed);\n\telse\n\t\terr = pcxhr_sub_set_clock(mgr, rate, &changed);\n\n\tif (err)\n\t\treturn err;\n\n\tif (changed) {\n\t\tpcxhr_init_rmh(&rmh, CMD_MODIFY_CLOCK);\n\t\trmh.cmd[0] |= PCXHR_MODIFY_CLOCK_S_BIT;  \n\t\tif (rate < PCXHR_IRQ_TIMER_FREQ)\n\t\t\trmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD;\n\t\telse\n\t\t\trmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD * 2;\n\t\trmh.cmd[2] = rate;\n\t\trmh.cmd_len = 3;\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\nstatic int pcxhr_sub_get_external_clock(struct pcxhr_mgr *mgr,\n\t\t\t\t\tenum pcxhr_clock_type clock_type,\n\t\t\t\t\tint *sample_rate)\n{\n\tstruct pcxhr_rmh rmh;\n\tunsigned char reg;\n\tint err, rate;\n\n\tswitch (clock_type) {\n\tcase PCXHR_CLOCK_TYPE_WORD_CLOCK:\n\t\treg = REG_STATUS_WORD_CLOCK;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_SYNC:\n\t\treg = REG_STATUS_AES_SYNC;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_1:\n\t\treg = REG_STATUS_AES_1;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_2:\n\t\treg = REG_STATUS_AES_2;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_3:\n\t\treg = REG_STATUS_AES_3;\n\t\tbreak;\n\tcase PCXHR_CLOCK_TYPE_AES_4:\n\t\treg = REG_STATUS_AES_4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\n\trmh.cmd_len = 2;\n\trmh.cmd[0] |= IO_NUM_REG_STATUS;\n\tif (mgr->last_reg_stat != reg) {\n\t\trmh.cmd[1]  = reg;\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tudelay(100);\t \n\t\tmgr->last_reg_stat = reg;\n\t}\n\trmh.cmd[1]  = REG_STATUS_CURRENT;\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn err;\n\tswitch (rmh.stat[1] & 0x0f) {\n\tcase REG_STATUS_SYNC_32000 :\trate = 32000; break;\n\tcase REG_STATUS_SYNC_44100 :\trate = 44100; break;\n\tcase REG_STATUS_SYNC_48000 :\trate = 48000; break;\n\tcase REG_STATUS_SYNC_64000 :\trate = 64000; break;\n\tcase REG_STATUS_SYNC_88200 :\trate = 88200; break;\n\tcase REG_STATUS_SYNC_96000 :\trate = 96000; break;\n\tcase REG_STATUS_SYNC_128000 :\trate = 128000; break;\n\tcase REG_STATUS_SYNC_176400 :\trate = 176400; break;\n\tcase REG_STATUS_SYNC_192000 :\trate = 192000; break;\n\tdefault: rate = 0;\n\t}\n\tdev_dbg(&mgr->pci->dev, \"External clock is at %d Hz\\n\", rate);\n\t*sample_rate = rate;\n\treturn 0;\n}\n\n\nint pcxhr_get_external_clock(struct pcxhr_mgr *mgr,\n\t\t\t     enum pcxhr_clock_type clock_type,\n\t\t\t     int *sample_rate)\n{\n\tif (mgr->is_hr_stereo)\n\t\treturn hr222_get_external_clock(mgr, clock_type,\n\t\t\t\t\t\tsample_rate);\n\telse\n\t\treturn pcxhr_sub_get_external_clock(mgr, clock_type,\n\t\t\t\t\t\t    sample_rate);\n}\n\n \nstatic int pcxhr_set_stream_state(struct snd_pcxhr *chip,\n\t\t\t\t  struct pcxhr_stream *stream)\n{\n\tint err;\n\tstruct pcxhr_rmh rmh;\n\tint stream_mask, start;\n\n\tif (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN)\n\t\tstart = 1;\n\telse {\n\t\tif (stream->status != PCXHR_STREAM_STATUS_SCHEDULE_STOP) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"%s CANNOT be stopped\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = 0;\n\t}\n\tif (!stream->substream)\n\t\treturn -EINVAL;\n\n\tstream->timer_abs_periods = 0;\n\tstream->timer_period_frag = 0;\t \n\tstream->timer_buf_periods = 0;\n\tstream->timer_is_synced = 0;\n\n\tstream_mask =\n\t  stream->pipe->is_capture ? 1 : 1<<stream->substream->number;\n\n\tpcxhr_init_rmh(&rmh, start ? CMD_START_STREAM : CMD_STOP_STREAM);\n\tpcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,\n\t\t\t\t  stream->pipe->first_audio, 0, stream_mask);\n\n\tchip = snd_pcm_substream_chip(stream->substream);\n\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"ERROR %s err=%x;\\n\", __func__, err);\n\tstream->status =\n\t  start ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;\n\treturn err;\n}\n\n#define HEADER_FMT_BASE_LIN\t\t0xfed00000\n#define HEADER_FMT_BASE_FLOAT\t\t0xfad00000\n#define HEADER_FMT_INTEL\t\t0x00008000\n#define HEADER_FMT_24BITS\t\t0x00004000\n#define HEADER_FMT_16BITS\t\t0x00002000\n#define HEADER_FMT_UPTO11\t\t0x00000200\n#define HEADER_FMT_UPTO32\t\t0x00000100\n#define HEADER_FMT_MONO\t\t\t0x00000080\n\nstatic int pcxhr_set_format(struct pcxhr_stream *stream)\n{\n\tint err, is_capture, sample_rate, stream_num;\n\tstruct snd_pcxhr *chip;\n\tstruct pcxhr_rmh rmh;\n\tunsigned int header;\n\n\tchip = snd_pcm_substream_chip(stream->substream);\n\tswitch (stream->format) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\theader = HEADER_FMT_BASE_LIN;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\theader = HEADER_FMT_BASE_LIN |\n\t\t\t HEADER_FMT_16BITS | HEADER_FMT_INTEL;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\theader = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\theader = HEADER_FMT_BASE_LIN |\n\t\t\t HEADER_FMT_24BITS | HEADER_FMT_INTEL;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3BE:\n\t\theader = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_FLOAT_LE:\n\t\theader = HEADER_FMT_BASE_FLOAT | HEADER_FMT_INTEL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"error %s() : unknown format\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsample_rate = chip->mgr->sample_rate;\n\tif (sample_rate <= 32000 && sample_rate !=0) {\n\t\tif (sample_rate <= 11025)\n\t\t\theader |= HEADER_FMT_UPTO11;\n\t\telse\n\t\t\theader |= HEADER_FMT_UPTO32;\n\t}\n\tif (stream->channels == 1)\n\t\theader |= HEADER_FMT_MONO;\n\n\tis_capture = stream->pipe->is_capture;\n\tstream_num = is_capture ? 0 : stream->substream->number;\n\n\tpcxhr_init_rmh(&rmh, is_capture ?\n\t\t       CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);\n\tpcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,\n\t\t\t\t  stream_num, 0);\n\tif (is_capture) {\n\t\t \n\t\t \n\t\tif (DSP_EXT_CMD_SET(chip->mgr))\n\t\t\trmh.cmd[0] |= 1<<10;\n\t\telse\n\t\t\trmh.cmd[0] |= 1<<12;\n\t}\n\trmh.cmd[1] = 0;\n\trmh.cmd_len = 2;\n\tif (DSP_EXT_CMD_SET(chip->mgr)) {\n\t\t \n\t\trmh.cmd[1] = stream->channels;\n\t\tif (!is_capture) {\n\t\t\t \n\t\t\trmh.cmd[2] = (stream->channels == 1) ? 0x01 : 0x03;\n\t\t\trmh.cmd_len = 3;\n\t\t}\n\t}\n\trmh.cmd[rmh.cmd_len++] = header >> 8;\n\trmh.cmd[rmh.cmd_len++] = (header & 0xff) << 16;\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"ERROR %s err=%x;\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int pcxhr_update_r_buffer(struct pcxhr_stream *stream)\n{\n\tint err, is_capture, stream_num;\n\tstruct pcxhr_rmh rmh;\n\tstruct snd_pcm_substream *subs = stream->substream;\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\n\tis_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);\n\tstream_num = is_capture ? 0 : subs->number;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"%s(pcm%c%d) : addr(%p) bytes(%zx) subs(%d)\\n\", __func__,\n\t\tis_capture ? 'c' : 'p',\n\t\tchip->chip_idx, (void *)(long)subs->runtime->dma_addr,\n\t\tsubs->runtime->dma_bytes, subs->number);\n\n\tpcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);\n\tpcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,\n\t\t\t\t  stream_num, 0);\n\n\t \n\tsnd_BUG_ON(subs->runtime->dma_bytes >= 0x200000);\n\t \n\trmh.cmd[1] = subs->runtime->dma_bytes * 8;\n\t \n\trmh.cmd[2] = subs->runtime->dma_addr >> 24;\n\t \n\trmh.cmd[2] |= 1<<19;\n\t \n\trmh.cmd[3] = subs->runtime->dma_addr & MASK_DSP_WORD;\n\trmh.cmd_len = 4;\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err)\n\t\tdev_err(chip->card->dev,\n\t\t\t   \"ERROR CMD_UPDATE_R_BUFFERS err=%x;\\n\", err);\n\treturn err;\n}\n\n\n#if 0\nstatic int pcxhr_pipe_sample_count(struct pcxhr_stream *stream,\n\t\t\t\t   snd_pcm_uframes_t *sample_count)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\tpcxhr_t *chip = snd_pcm_substream_chip(stream->substream);\n\tpcxhr_init_rmh(&rmh, CMD_PIPE_SAMPLE_COUNT);\n\tpcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture, 0, 0,\n\t\t\t\t  1<<stream->pipe->first_audio);\n\terr = pcxhr_send_msg(chip->mgr, &rmh);\n\tif (err == 0) {\n\t\t*sample_count = ((snd_pcm_uframes_t)rmh.stat[0]) << 24;\n\t\t*sample_count += (snd_pcm_uframes_t)rmh.stat[1];\n\t}\n\tdev_dbg(chip->card->dev, \"PIPE_SAMPLE_COUNT = %lx\\n\", *sample_count);\n\treturn err;\n}\n#endif\n\nstatic inline int pcxhr_stream_scheduled_get_pipe(struct pcxhr_stream *stream,\n\t\t\t\t\t\t  struct pcxhr_pipe **pipe)\n{\n\tif (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN) {\n\t\t*pipe = stream->pipe;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)\n{\n\tint i, j, err;\n\tstruct pcxhr_pipe *pipe;\n\tstruct snd_pcxhr *chip;\n\tint capture_mask = 0;\n\tint playback_mask = 0;\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tktime_t start_time, stop_time, diff_time;\n\n\tstart_time = ktime_get();\n#endif\n\tmutex_lock(&mgr->setup_mutex);\n\n\t \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tchip = mgr->chip[i];\n\t\tfor (j = 0; j < chip->nb_streams_capt; j++) {\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(&chip->capture_stream[j], &pipe))\n\t\t\t\tcapture_mask |= (1 << pipe->first_audio);\n\t\t}\n\t\tfor (j = 0; j < chip->nb_streams_play; j++) {\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {\n\t\t\t\tplayback_mask |= (1 << pipe->first_audio);\n\t\t\t\tbreak;\t \n\t\t\t}\n\t\t}\n\t}\n\tif (capture_mask == 0 && playback_mask == 0) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\tdev_err(&mgr->pci->dev, \"%s : no pipes\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdev_dbg(&mgr->pci->dev, \"%s : playback_mask=%x capture_mask=%x\\n\",\n\t\t    __func__, playback_mask, capture_mask);\n\n\t \n\terr = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);\n\tif (err) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\tdev_err(&mgr->pci->dev, \"%s : \"\n\t\t\t   \"error stop pipes (P%x C%x)\\n\",\n\t\t\t   __func__, playback_mask, capture_mask);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tstruct pcxhr_stream *stream;\n\t\tchip = mgr->chip[i];\n\t\tfor (j = 0; j < chip->nb_streams_capt; j++) {\n\t\t\tstream = &chip->capture_stream[j];\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {\n\t\t\t\terr = pcxhr_set_format(stream);\n\t\t\t\terr = pcxhr_update_r_buffer(stream);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < chip->nb_streams_play; j++) {\n\t\t\tstream = &chip->playback_stream[j];\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {\n\t\t\t\terr = pcxhr_set_format(stream);\n\t\t\t\terr = pcxhr_update_r_buffer(stream);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tstruct pcxhr_stream *stream;\n\t\tchip = mgr->chip[i];\n\t\tfor (j = 0; j < chip->nb_streams_capt; j++) {\n\t\t\tstream = &chip->capture_stream[j];\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(stream, &pipe))\n\t\t\t\terr = pcxhr_set_stream_state(chip, stream);\n\t\t}\n\t\tfor (j = 0; j < chip->nb_streams_play; j++) {\n\t\t\tstream = &chip->playback_stream[j];\n\t\t\tif (pcxhr_stream_scheduled_get_pipe(stream, &pipe))\n\t\t\t\terr = pcxhr_set_stream_state(chip, stream);\n\t\t}\n\t}\n\n\t \n\terr = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);\n\tif (err) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\tdev_err(&mgr->pci->dev, \"%s : \"\n\t\t\t   \"error start pipes (P%x C%x)\\n\",\n\t\t\t   __func__, playback_mask, capture_mask);\n\t\treturn;\n\t}\n\n\t \n\tmutex_lock(&mgr->lock);\n\tfor ( i =0; i < mgr->num_cards; i++) {\n\t\tstruct pcxhr_stream *stream;\n\t\tchip = mgr->chip[i];\n\t\tfor(j = 0; j < chip->nb_streams_capt; j++) {\n\t\t\tstream = &chip->capture_stream[j];\n\t\t\tif(stream->status == PCXHR_STREAM_STATUS_STARTED)\n\t\t\t\tstream->status = PCXHR_STREAM_STATUS_RUNNING;\n\t\t}\n\t\tfor (j = 0; j < chip->nb_streams_play; j++) {\n\t\t\tstream = &chip->playback_stream[j];\n\t\t\tif (stream->status == PCXHR_STREAM_STATUS_STARTED) {\n\t\t\t\t \n\t\t\t\tstream->timer_period_frag += mgr->granularity;\n\t\t\t\tstream->status = PCXHR_STREAM_STATUS_RUNNING;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mgr->lock);\n\n\tmutex_unlock(&mgr->setup_mutex);\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tstop_time = ktime_get();\n\tdiff_time = ktime_sub(stop_time, start_time);\n\tdev_dbg(&mgr->pci->dev, \"***TRIGGER START*** TIME = %ld (err = %x)\\n\",\n\t\t    (long)(ktime_to_ns(diff_time)), err);\n#endif\n}\n\n\n \nstatic int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct pcxhr_stream *stream;\n\tstruct snd_pcm_substream *s;\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdev_dbg(chip->card->dev, \"SNDRV_PCM_TRIGGER_START\\n\");\n\t\tif (snd_pcm_stream_linked(subs)) {\n\t\t\tsnd_pcm_group_for_each_entry(s, subs) {\n\t\t\t\tif (snd_pcm_substream_chip(s) != chip)\n\t\t\t\t\tcontinue;\n\t\t\t\tstream = s->runtime->private_data;\n\t\t\t\tstream->status =\n\t\t\t\t\tPCXHR_STREAM_STATUS_SCHEDULE_RUN;\n\t\t\t\tsnd_pcm_trigger_done(s, subs);\n\t\t\t}\n\t\t\tpcxhr_start_linked_stream(chip->mgr);\n\t\t} else {\n\t\t\tstream = subs->runtime->private_data;\n\t\t\tdev_dbg(chip->card->dev, \"Only one Substream %c %d\\n\",\n\t\t\t\t    stream->pipe->is_capture ? 'C' : 'P',\n\t\t\t\t    stream->pipe->first_audio);\n\t\t\tif (pcxhr_set_format(stream))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (pcxhr_update_r_buffer(stream))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tstream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;\n\t\t\tif (pcxhr_set_stream_state(chip, stream))\n\t\t\t\treturn -EINVAL;\n\t\t\tstream->status = PCXHR_STREAM_STATUS_RUNNING;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(chip->card->dev, \"SNDRV_PCM_TRIGGER_STOP\\n\");\n\t\tsnd_pcm_group_for_each_entry(s, subs) {\n\t\t\tstream = s->runtime->private_data;\n\t\t\tstream->status = PCXHR_STREAM_STATUS_SCHEDULE_STOP;\n\t\t\tif (pcxhr_set_stream_state(chip, stream))\n\t\t\t\treturn -EINVAL;\n\t\t\tsnd_pcm_trigger_done(s, subs);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic int pcxhr_hardware_timer(struct pcxhr_mgr *mgr, int start)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\n\tpcxhr_init_rmh(&rmh, CMD_SET_TIMER_INTERRUPT);\n\tif (start) {\n\t\t \n\t\tmgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;\n\t\trmh.cmd[0] |= mgr->granularity;\n\t}\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err < 0)\n\t\tdev_err(&mgr->pci->dev, \"error %s err(%x)\\n\", __func__,\n\t\t\t   err);\n\treturn err;\n}\n\n \nstatic int pcxhr_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tint err = 0;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"%s : period_size(%lx) periods(%x) buffer_size(%lx)\\n\", __func__,\n\t\t    subs->runtime->period_size, subs->runtime->periods,\n\t\t    subs->runtime->buffer_size);\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\tdo {\n\t\t \n\t\t \n\t\tif (mgr->sample_rate != subs->runtime->rate) {\n\t\t\terr = pcxhr_set_clock(mgr, subs->runtime->rate);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (mgr->sample_rate == 0)\n\t\t\t\t \n\t\t\t\terr = pcxhr_hardware_timer(mgr, 1);\n\t\t\tmgr->sample_rate = subs->runtime->rate;\n\t\t}\n\t} while(0);\t \n\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn err;\n}\n\n\n \nstatic int pcxhr_hw_params(struct snd_pcm_substream *subs,\n\t\t\t   struct snd_pcm_hw_params *hw)\n{\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tstruct pcxhr_stream *stream = subs->runtime->private_data;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\t \n\tstream->channels = params_channels(hw);\n\t \n\tstream->format = params_format(hw);\n\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_hardware pcxhr_caps =\n{\n\t.info             = (SNDRV_PCM_INFO_MMAP |\n\t\t\t     SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t     SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t     SNDRV_PCM_INFO_SYNC_START),\n\t.formats\t  = (SNDRV_PCM_FMTBIT_U8 |\n\t\t\t     SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t     SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t     SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t     SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t\t     SNDRV_PCM_FMTBIT_FLOAT_LE),\n\t.rates            = (SNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t     SNDRV_PCM_RATE_8000_192000),\n\t.rate_min         = 8000,\n\t.rate_max         = 192000,\n\t.channels_min     = 1,\n\t.channels_max     = 2,\n\t.buffer_bytes_max = (32*1024),\n\t \n\t.period_bytes_min = (2*PCXHR_GRANULARITY),\n\t.period_bytes_max = (16*1024),\n\t.periods_min      = 2,\n\t.periods_max      = (32*1024/PCXHR_GRANULARITY),\n};\n\n\nstatic int pcxhr_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcxhr       *chip = snd_pcm_substream_chip(subs);\n\tstruct pcxhr_mgr       *mgr = chip->mgr;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct pcxhr_stream    *stream;\n\tint err;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\t \n\truntime->hw = pcxhr_caps;\n\n\tif( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {\n\t\tdev_dbg(chip->card->dev, \"%s playback chip%d subs%d\\n\",\n\t\t\t    __func__, chip->chip_idx, subs->number);\n\t\tstream = &chip->playback_stream[subs->number];\n\t} else {\n\t\tdev_dbg(chip->card->dev, \"%s capture chip%d subs%d\\n\",\n\t\t\t    __func__, chip->chip_idx, subs->number);\n\t\tif (mgr->mono_capture)\n\t\t\truntime->hw.channels_max = 1;\n\t\telse\n\t\t\truntime->hw.channels_min = 2;\n\t\tstream = &chip->capture_stream[subs->number];\n\t}\n\tif (stream->status != PCXHR_STREAM_STATUS_FREE){\n\t\t \n\t\tdev_err(chip->card->dev, \"%s chip%d subs%d in use\\n\",\n\t\t\t   __func__, chip->chip_idx, subs->number);\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (mgr->is_hr_stereo)\n\t\truntime->hw.formats &= ~SNDRV_PCM_FMTBIT_FLOAT_LE;\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0) {\n\t\tmutex_unlock(&mgr->setup_mutex);\n\t\treturn err;\n\t}\n\n\t \n\tif (mgr->sample_rate)\n\t\truntime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;\n\telse {\n\t\tif (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {\n\t\t\tint external_rate;\n\t\t\tif (pcxhr_get_external_clock(mgr, mgr->use_clock_type,\n\t\t\t\t\t\t     &external_rate) ||\n\t\t\t    external_rate == 0) {\n\t\t\t\t \n\t\t\t\tmutex_unlock(&mgr->setup_mutex);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\truntime->hw.rate_min = external_rate;\n\t\t\truntime->hw.rate_max = external_rate;\n\t\t}\n\t}\n\n\tstream->status      = PCXHR_STREAM_STATUS_OPEN;\n\tstream->substream   = subs;\n\tstream->channels    = 0;  \n\n\truntime->private_data = stream;\n\n\t \n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);\n\tsnd_pcm_set_sync(subs);\n\n\tmgr->ref_count_rate++;\n\n\tmutex_unlock(&mgr->setup_mutex);\n\treturn 0;\n}\n\n\nstatic int pcxhr_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tstruct pcxhr_stream *stream = subs->runtime->private_data;\n\n\tmutex_lock(&mgr->setup_mutex);\n\n\tdev_dbg(chip->card->dev, \"%s chip%d subs%d\\n\", __func__,\n\t\t    chip->chip_idx, subs->number);\n\n\t \n\tif (--mgr->ref_count_rate == 0) {\n\t\tmgr->sample_rate = 0;\t \n\t\tpcxhr_hardware_timer(mgr, 0);\t \n\t}\n\n\tstream->status    = PCXHR_STREAM_STATUS_FREE;\n\tstream->substream = NULL;\n\n\tmutex_unlock(&mgr->setup_mutex);\n\n\treturn 0;\n}\n\n\nstatic snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)\n{\n\tu_int32_t timer_period_frag;\n\tint timer_buf_periods;\n\tstruct snd_pcxhr *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct pcxhr_stream *stream  = runtime->private_data;\n\n\tmutex_lock(&chip->mgr->lock);\n\n\t \n\ttimer_period_frag = stream->timer_period_frag;\n\ttimer_buf_periods = stream->timer_buf_periods;\n\n\tmutex_unlock(&chip->mgr->lock);\n\n\treturn (snd_pcm_uframes_t)((timer_buf_periods * runtime->period_size) +\n\t\t\t\t   timer_period_frag);\n}\n\n\nstatic const struct snd_pcm_ops pcxhr_ops = {\n\t.open      = pcxhr_open,\n\t.close     = pcxhr_close,\n\t.prepare   = pcxhr_prepare,\n\t.hw_params = pcxhr_hw_params,\n\t.trigger   = pcxhr_trigger,\n\t.pointer   = pcxhr_stream_pointer,\n};\n\n \nint pcxhr_create_pcm(struct snd_pcxhr *chip)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\tchar name[32];\n\n\tsnprintf(name, sizeof(name), \"pcxhr %d\", chip->chip_idx);\n\terr = snd_pcm_new(chip->card, name, 0,\n\t\t\t  chip->nb_streams_play,\n\t\t\t  chip->nb_streams_capt, &pcm);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"cannot create pcm %s\\n\", name);\n\t\treturn err;\n\t}\n\tpcm->private_data = chip;\n\n\tif (chip->nb_streams_play)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcxhr_ops);\n\tif (chip->nb_streams_capt)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcxhr_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->nonatomic = true;\n\tstrcpy(pcm->name, name);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->mgr->pci->dev,\n\t\t\t\t       32*1024, 32*1024);\n\tchip->pcm = pcm;\n\treturn 0;\n}\n\nstatic int pcxhr_chip_free(struct snd_pcxhr *chip)\n{\n\tkfree(chip);\n\treturn 0;\n}\n\nstatic int pcxhr_chip_dev_free(struct snd_device *device)\n{\n\tstruct snd_pcxhr *chip = device->device_data;\n\treturn pcxhr_chip_free(chip);\n}\n\n\n \nstatic int pcxhr_create(struct pcxhr_mgr *mgr,\n\t\t\tstruct snd_card *card, int idx)\n{\n\tint err;\n\tstruct snd_pcxhr *chip;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = pcxhr_chip_dev_free,\n\t};\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->card = card;\n\tchip->chip_idx = idx;\n\tchip->mgr = mgr;\n\tcard->sync_irq = mgr->irq;\n\n\tif (idx < mgr->playback_chips)\n\t\t \n\t\tchip->nb_streams_play = PCXHR_PLAYBACK_STREAMS;\n\n\tif (idx < mgr->capture_chips) {\n\t\tif (mgr->mono_capture)\n\t\t\tchip->nb_streams_capt = 2;\t \n\t\telse\n\t\t\tchip->nb_streams_capt = 1;\t \n\t}\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tpcxhr_chip_free(chip);\n\t\treturn err;\n\t}\n\n\tmgr->chip[idx] = chip;\n\n\treturn 0;\n}\n\n \nstatic void pcxhr_proc_info(struct snd_info_entry *entry,\n\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcxhr *chip = entry->private_data;\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\n\tsnd_iprintf(buffer, \"\\n%s\\n\", mgr->name);\n\n\t \n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\n\t\tstruct pcxhr_rmh rmh;\n\t\tshort ver_maj = (mgr->dsp_version >> 16) & 0xff;\n\t\tshort ver_min = (mgr->dsp_version >> 8) & 0xff;\n\t\tshort ver_build = mgr->dsp_version & 0xff;\n\t\tsnd_iprintf(buffer, \"module version %s\\n\",\n\t\t\t    PCXHR_DRIVER_VERSION_STRING);\n\t\tsnd_iprintf(buffer, \"dsp version %d.%d.%d\\n\",\n\t\t\t    ver_maj, ver_min, ver_build);\n\t\tif (mgr->board_has_analog)\n\t\t\tsnd_iprintf(buffer, \"analog io available\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"digital only board\\n\");\n\n\t\t \n\t\tpcxhr_init_rmh(&rmh, CMD_GET_DSP_RESOURCES);\n\t\tif( ! pcxhr_send_msg(mgr, &rmh) ) {\n\t\t\tint cur = rmh.stat[0];\n\t\t\tint ref = rmh.stat[1];\n\t\t\tif (ref > 0) {\n\t\t\t\tif (mgr->sample_rate_real != 0 &&\n\t\t\t\t    mgr->sample_rate_real != 48000) {\n\t\t\t\t\tref = (ref * 48000) /\n\t\t\t\t\t  mgr->sample_rate_real;\n\t\t\t\t\tif (mgr->sample_rate_real >=\n\t\t\t\t\t    PCXHR_IRQ_TIMER_FREQ)\n\t\t\t\t\t\tref *= 2;\n\t\t\t\t}\n\t\t\t\tcur = 100 - (100 * cur) / ref;\n\t\t\t\tsnd_iprintf(buffer, \"cpu load    %d%%\\n\", cur);\n\t\t\t\tsnd_iprintf(buffer, \"buffer pool %d/%d\\n\",\n\t\t\t\t\t    rmh.stat[2], rmh.stat[3]);\n\t\t\t}\n\t\t}\n\t\tsnd_iprintf(buffer, \"dma granularity : %d\\n\",\n\t\t\t    mgr->granularity);\n\t\tsnd_iprintf(buffer, \"dsp time errors : %d\\n\",\n\t\t\t    mgr->dsp_time_err);\n\t\tsnd_iprintf(buffer, \"dsp async pipe xrun errors : %d\\n\",\n\t\t\t    mgr->async_err_pipe_xrun);\n\t\tsnd_iprintf(buffer, \"dsp async stream xrun errors : %d\\n\",\n\t\t\t    mgr->async_err_stream_xrun);\n\t\tsnd_iprintf(buffer, \"dsp async last other error : %x\\n\",\n\t\t\t    mgr->async_err_other_last);\n\t\t \n\t\trmh.cmd[0] = 0x4200 + PCXHR_SIZE_MAX_STATUS;\n\t\trmh.cmd_len = 1;\n\t\trmh.stat_len = PCXHR_SIZE_MAX_STATUS;\n\t\trmh.dsp_stat = 0;\n\t\trmh.cmd_idx = CMD_LAST_INDEX;\n\t\tif( ! pcxhr_send_msg(mgr, &rmh) ) {\n\t\t\tint i;\n\t\t\tif (rmh.stat_len > 8)\n\t\t\t\trmh.stat_len = 8;\n\t\t\tfor (i = 0; i < rmh.stat_len; i++)\n\t\t\t\tsnd_iprintf(buffer, \"debug[%02d] = %06x\\n\",\n\t\t\t\t\t    i,  rmh.stat[i]);\n\t\t}\n\t} else\n\t\tsnd_iprintf(buffer, \"no firmware loaded\\n\");\n\tsnd_iprintf(buffer, \"\\n\");\n}\nstatic void pcxhr_proc_sync(struct snd_info_entry *entry,\n\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcxhr *chip = entry->private_data;\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tstatic const char *textsHR22[3] = {\n\t\t\"Internal\", \"AES Sync\", \"AES 1\"\n\t};\n\tstatic const char *textsPCXHR[7] = {\n\t\t\"Internal\", \"Word\", \"AES Sync\",\n\t\t\"AES 1\", \"AES 2\", \"AES 3\", \"AES 4\"\n\t};\n\tconst char **texts;\n\tint max_clock;\n\tif (mgr->is_hr_stereo) {\n\t\ttexts = textsHR22;\n\t\tmax_clock = HR22_CLOCK_TYPE_MAX;\n\t} else {\n\t\ttexts = textsPCXHR;\n\t\tmax_clock = PCXHR_CLOCK_TYPE_MAX;\n\t}\n\n\tsnd_iprintf(buffer, \"\\n%s\\n\", mgr->name);\n\tsnd_iprintf(buffer, \"Current Sample Clock\\t: %s\\n\",\n\t\t    texts[mgr->cur_clock_type]);\n\tsnd_iprintf(buffer, \"Current Sample Rate\\t= %d\\n\",\n\t\t    mgr->sample_rate_real);\n\t \n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\n\t\tint i, err, sample_rate;\n\t\tfor (i = 1; i <= max_clock; i++) {\n\t\t\terr = pcxhr_get_external_clock(mgr, i, &sample_rate);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tsnd_iprintf(buffer, \"%s Clock\\t\\t= %d\\n\",\n\t\t\t\t    texts[i], sample_rate);\n\t\t}\n\t} else\n\t\tsnd_iprintf(buffer, \"no firmware loaded\\n\");\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void pcxhr_proc_gpio_read(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcxhr *chip = entry->private_data;\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\t \n\tif (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {\n\t\t \n\t\tint value = 0;\n\t\thr222_read_gpio(mgr, 1, &value);\t \n\t\tsnd_iprintf(buffer, \"GPI: 0x%x\\n\", value);\n\t\thr222_read_gpio(mgr, 0, &value);\t \n\t\tsnd_iprintf(buffer, \"GPO: 0x%x\\n\", value);\n\t} else\n\t\tsnd_iprintf(buffer, \"no firmware loaded\\n\");\n\tsnd_iprintf(buffer, \"\\n\");\n}\nstatic void pcxhr_proc_gpo_write(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcxhr *chip = entry->private_data;\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tchar line[64];\n\tint value;\n\t \n\tif (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)))\n\t\treturn;\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"GPO: 0x%x\", &value) != 1)\n\t\t\tcontinue;\n\t\thr222_write_gpo(mgr, value);\t \n\t}\n}\n\n \n#define TIME_CODE_VALID_MASK\t0x00800000\n#define TIME_CODE_NEW_MASK\t0x00400000\n#define TIME_CODE_BACK_MASK\t0x00200000\n#define TIME_CODE_WAIT_MASK\t0x00100000\n\n \n#define MANAGE_SIGNAL_TIME_CODE\t0x01\n#define MANAGE_SIGNAL_MIDI\t0x02\n\n \nstatic void pcxhr_proc_ltc(struct snd_info_entry *entry,\n\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct snd_pcxhr *chip = entry->private_data;\n\tstruct pcxhr_mgr *mgr = chip->mgr;\n\tstruct pcxhr_rmh rmh;\n\tunsigned int ltcHrs, ltcMin, ltcSec, ltcFrm;\n\tint err;\n\t \n\tif (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))) {\n\t\tsnd_iprintf(buffer, \"no firmware loaded\\n\");\n\t\treturn;\n\t}\n\tif (!mgr->capture_ltc) {\n\t\tpcxhr_init_rmh(&rmh, CMD_MANAGE_SIGNAL);\n\t\trmh.cmd[0] |= MANAGE_SIGNAL_TIME_CODE;\n\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\tif (err) {\n\t\t\tsnd_iprintf(buffer, \"ltc not activated (%d)\\n\", err);\n\t\t\treturn;\n\t\t}\n\t\tif (mgr->is_hr_stereo)\n\t\t\thr222_manage_timecode(mgr, 1);\n\t\telse\n\t\t\tpcxhr_write_io_num_reg_cont(mgr, REG_CONT_VALSMPTE,\n\t\t\t\t\t\t    REG_CONT_VALSMPTE, NULL);\n\t\tmgr->capture_ltc = 1;\n\t}\n\tpcxhr_init_rmh(&rmh, CMD_GET_TIME_CODE);\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err) {\n\t\tsnd_iprintf(buffer, \"ltc read error (err=%d)\\n\", err);\n\t\treturn ;\n\t}\n\tltcHrs = 10*((rmh.stat[0] >> 8) & 0x3) + (rmh.stat[0] & 0xf);\n\tltcMin = 10*((rmh.stat[1] >> 16) & 0x7) + ((rmh.stat[1] >> 8) & 0xf);\n\tltcSec = 10*(rmh.stat[1] & 0x7) + ((rmh.stat[2] >> 16) & 0xf);\n\tltcFrm = 10*((rmh.stat[2] >> 8) & 0x3) + (rmh.stat[2] & 0xf);\n\n\tsnd_iprintf(buffer, \"timecode: %02u:%02u:%02u-%02u\\n\",\n\t\t\t    ltcHrs, ltcMin, ltcSec, ltcFrm);\n\tsnd_iprintf(buffer, \"raw: 0x%04x%06x%06x\\n\", rmh.stat[0] & 0x00ffff,\n\t\t\t    rmh.stat[1] & 0xffffff, rmh.stat[2] & 0xffffff);\n\t \n\tif (!(rmh.stat[0] & TIME_CODE_VALID_MASK)) {\n\t\tsnd_iprintf(buffer, \"warning: linear timecode not valid\\n\");\n\t}\n}\n\nstatic void pcxhr_proc_init(struct snd_pcxhr *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"info\", chip, pcxhr_proc_info);\n\tsnd_card_ro_proc_new(chip->card, \"sync\", chip, pcxhr_proc_sync);\n\t \n\tif (chip->mgr->is_hr_stereo)\n\t\tsnd_card_rw_proc_new(chip->card, \"gpio\", chip,\n\t\t\t\t     pcxhr_proc_gpio_read,\n\t\t\t\t     pcxhr_proc_gpo_write);\n\tsnd_card_ro_proc_new(chip->card, \"ltc\", chip, pcxhr_proc_ltc);\n}\n \n\n \nstatic int pcxhr_free(struct pcxhr_mgr *mgr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\tif (mgr->chip[i])\n\t\t\tsnd_card_free(mgr->chip[i]->card);\n\t}\n\n\t \n\tif(mgr->dsp_loaded) {\n\t\tpcxhr_reset_board(mgr);\n\t\tdev_dbg(&mgr->pci->dev, \"reset pcxhr !\\n\");\n\t}\n\n\t \n\tif (mgr->irq >= 0)\n\t\tfree_irq(mgr->irq, mgr);\n\n\tpci_release_regions(mgr->pci);\n\n\t \n\tif (mgr->hostport.area) {\n\t\tsnd_dma_free_pages(&mgr->hostport);\n\t\tmgr->hostport.area = NULL;\n\t}\n\n\tkfree(mgr->prmh);\n\n\tpci_disable_device(mgr->pci);\n\tkfree(mgr);\n\treturn 0;\n}\n\n \nstatic int pcxhr_probe(struct pci_dev *pci,\n\t\t       const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct pcxhr_mgr *mgr;\n\tunsigned int i;\n\tint err;\n\tsize_t size;\n\tchar *card_name;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (! enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = pci_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_master(pci);\n\n\t \n\tif (dma_set_mask(&pci->dev, DMA_BIT_MASK(32)) < 0) {\n\t\tdev_err(&pci->dev,\n\t\t\t\"architecture does not support 32bit PCI busmaster DMA\\n\");\n\t\tpci_disable_device(pci);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\n\tif (! mgr) {\n\t\tpci_disable_device(pci);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (snd_BUG_ON(pci_id->driver_data >= PCI_ID_LAST)) {\n\t\tkfree(mgr);\n\t\tpci_disable_device(pci);\n\t\treturn -ENODEV;\n\t}\n\tcard_name =\n\t\tpcxhr_board_params[pci_id->driver_data].board_name;\n\tmgr->playback_chips =\n\t\tpcxhr_board_params[pci_id->driver_data].playback_chips;\n\tmgr->capture_chips  =\n\t\tpcxhr_board_params[pci_id->driver_data].capture_chips;\n\tmgr->fw_file_set =\n\t\tpcxhr_board_params[pci_id->driver_data].fw_file_set;\n\tmgr->firmware_num  =\n\t\tpcxhr_board_params[pci_id->driver_data].firmware_num;\n\tmgr->mono_capture = mono[dev];\n\tmgr->is_hr_stereo = (mgr->playback_chips == 1);\n\tmgr->board_has_aes1 = PCXHR_BOARD_HAS_AES1(mgr);\n\tmgr->board_aes_in_192k = !PCXHR_BOARD_AESIN_NO_192K(mgr);\n\n\tif (mgr->is_hr_stereo)\n\t\tmgr->granularity = PCXHR_GRANULARITY_HR22;\n\telse\n\t\tmgr->granularity = PCXHR_GRANULARITY;\n\n\t \n\terr = pci_request_regions(pci, card_name);\n\tif (err < 0) {\n\t\tkfree(mgr);\n\t\tpci_disable_device(pci);\n\t\treturn err;\n\t}\n\tfor (i = 0; i < 3; i++)\n\t\tmgr->port[i] = pci_resource_start(pci, i);\n\n\tmgr->pci = pci;\n\tmgr->irq = -1;\n\n\tif (request_threaded_irq(pci->irq, pcxhr_interrupt,\n\t\t\t\t pcxhr_threaded_irq, IRQF_SHARED,\n\t\t\t\t KBUILD_MODNAME, mgr)) {\n\t\tdev_err(&pci->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\tpcxhr_free(mgr);\n\t\treturn -EBUSY;\n\t}\n\tmgr->irq = pci->irq;\n\n\tsnprintf(mgr->name, sizeof(mgr->name),\n\t\t \"Digigram at 0x%lx & 0x%lx, 0x%lx irq %i\",\n\t\t mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);\n\n\t \n\tmutex_init(&mgr->lock);\n\tmutex_init(&mgr->msg_lock);\n\n\t \n\tmutex_init(&mgr->setup_mutex);\n\n\tmgr->prmh = kmalloc(sizeof(*mgr->prmh) +\n\t\t\t    sizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS -\n\t\t\t\t\t   PCXHR_SIZE_MAX_STATUS),\n\t\t\t    GFP_KERNEL);\n\tif (! mgr->prmh) {\n\t\tpcxhr_free(mgr);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i=0; i < PCXHR_MAX_CARDS; i++) {\n\t\tstruct snd_card *card;\n\t\tchar tmpid[16];\n\t\tint idx;\n\n\t\tif (i >= max(mgr->playback_chips, mgr->capture_chips))\n\t\t\tbreak;\n\t\tmgr->num_cards++;\n\n\t\tif (index[dev] < 0)\n\t\t\tidx = index[dev];\n\t\telse\n\t\t\tidx = index[dev] + i;\n\n\t\tsnprintf(tmpid, sizeof(tmpid), \"%s-%d\",\n\t\t\t id[dev] ? id[dev] : card_name, i);\n\t\terr = snd_card_new(&pci->dev, idx, tmpid, THIS_MODULE,\n\t\t\t\t   0, &card);\n\n\t\tif (err < 0) {\n\t\t\tdev_err(&pci->dev, \"cannot allocate the card %d\\n\", i);\n\t\t\tpcxhr_free(mgr);\n\t\t\treturn err;\n\t\t}\n\n\t\tstrcpy(card->driver, DRIVER_NAME);\n\t\tsnprintf(card->shortname, sizeof(card->shortname),\n\t\t\t \"Digigram [PCM #%d]\", i);\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t \"%s [PCM #%d]\", mgr->name, i);\n\n\t\terr = pcxhr_create(mgr, card, i);\n\t\tif (err < 0) {\n\t\t\tsnd_card_free(card);\n\t\t\tpcxhr_free(mgr);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\t \n\t\t\tpcxhr_proc_init(mgr->chip[i]);\n\n\t\terr = snd_card_register(card);\n\t\tif (err < 0) {\n\t\t\tpcxhr_free(mgr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tsize = PAGE_ALIGN(sizeof(struct pcxhr_hostport));\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\tsize, &mgr->hostport) < 0) {\n\t\tpcxhr_free(mgr);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tmemset(mgr->hostport.area, 0, size);\n\n\t \n\terr = pcxhr_setup_firmware(mgr);\n\tif (err < 0) {\n\t\tpcxhr_free(mgr);\n\t\treturn err;\n\t}\n\n\tpci_set_drvdata(pci, mgr);\n\tdev++;\n\treturn 0;\n}\n\nstatic void pcxhr_remove(struct pci_dev *pci)\n{\n\tpcxhr_free(pci_get_drvdata(pci));\n}\n\nstatic struct pci_driver pcxhr_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = pcxhr_ids,\n\t.probe = pcxhr_probe,\n\t.remove = pcxhr_remove,\n};\n\nmodule_pci_driver(pcxhr_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}