{
  "module_name": "pcxhr_core.c",
  "hash_id": "e6530713f34f3738dbca928726c917408bd1144b501d9e36157dd9da30a0ac40",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/pcxhr/pcxhr_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include \"pcxhr.h\"\n#include \"pcxhr_mixer.h\"\n#include \"pcxhr_hwdep.h\"\n#include \"pcxhr_core.h\"\n\n\n \n#define PCXHR_PLX_OFFSET_MIN\t0x40\n#define PCXHR_PLX_MBOX0\t\t0x40\n#define PCXHR_PLX_MBOX1\t\t0x44\n#define PCXHR_PLX_MBOX2\t\t0x48\n#define PCXHR_PLX_MBOX3\t\t0x4C\n#define PCXHR_PLX_MBOX4\t\t0x50\n#define PCXHR_PLX_MBOX5\t\t0x54\n#define PCXHR_PLX_MBOX6\t\t0x58\n#define PCXHR_PLX_MBOX7\t\t0x5C\n#define PCXHR_PLX_L2PCIDB\t0x64\n#define PCXHR_PLX_IRQCS\t\t0x68\n#define PCXHR_PLX_CHIPSC\t0x6C\n\n \n#define PCXHR_DSP_ICR\t\t0x00\n#define PCXHR_DSP_CVR\t\t0x04\n#define PCXHR_DSP_ISR\t\t0x08\n#define PCXHR_DSP_IVR\t\t0x0C\n#define PCXHR_DSP_RXH\t\t0x14\n#define PCXHR_DSP_TXH\t\t0x14\n#define PCXHR_DSP_RXM\t\t0x18\n#define PCXHR_DSP_TXM\t\t0x18\n#define PCXHR_DSP_RXL\t\t0x1C\n#define PCXHR_DSP_TXL\t\t0x1C\n#define PCXHR_DSP_RESET\t\t0x20\n#define PCXHR_DSP_OFFSET_MAX\t0x20\n\n \n#define PCXHR_PLX 1\n#define PCXHR_DSP 2\n\n#if (PCXHR_DSP_OFFSET_MAX > PCXHR_PLX_OFFSET_MIN)\n#error  PCXHR_REG_TO_PORT(x)\n#else\n#define PCXHR_REG_TO_PORT(x)\t((x)>PCXHR_DSP_OFFSET_MAX ? PCXHR_PLX : PCXHR_DSP)\n#endif\n#define PCXHR_INPB(mgr,x)\tinb((mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))\n#define PCXHR_INPL(mgr,x)\tinl((mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))\n#define PCXHR_OUTPB(mgr,x,data)\toutb((data), (mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))\n#define PCXHR_OUTPL(mgr,x,data)\toutl((data), (mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))\n \n\n \n#define PCXHR_MBOX0_HF5\t\t\t(1 << 0)\n#define PCXHR_MBOX0_HF4\t\t\t(1 << 1)\n#define PCXHR_MBOX0_BOOT_HERE\t\t(1 << 23)\n \n#define PCXHR_IRQCS_ENABLE_PCIIRQ\t(1 << 8)\n#define PCXHR_IRQCS_ENABLE_PCIDB\t(1 << 9)\n#define PCXHR_IRQCS_ACTIVE_PCIDB\t(1 << 13)\n \n#define PCXHR_CHIPSC_INIT_VALUE\t\t0x100D767E\n#define PCXHR_CHIPSC_RESET_XILINX\t(1 << 16)\n#define PCXHR_CHIPSC_GPI_USERI\t\t(1 << 17)\n#define PCXHR_CHIPSC_DATA_CLK\t\t(1 << 24)\n#define PCXHR_CHIPSC_DATA_IN\t\t(1 << 26)\n\n \n#define PCXHR_ICR_HI08_RREQ\t\t0x01\n#define PCXHR_ICR_HI08_TREQ\t\t0x02\n#define PCXHR_ICR_HI08_HDRQ\t\t0x04\n#define PCXHR_ICR_HI08_HF0\t\t0x08\n#define PCXHR_ICR_HI08_HF1\t\t0x10\n#define PCXHR_ICR_HI08_HLEND\t\t0x20\n#define PCXHR_ICR_HI08_INIT\t\t0x80\n \n#define PCXHR_CVR_HI08_HC\t\t0x80\n \n#define PCXHR_ISR_HI08_RXDF\t\t0x01\n#define PCXHR_ISR_HI08_TXDE\t\t0x02\n#define PCXHR_ISR_HI08_TRDY\t\t0x04\n#define PCXHR_ISR_HI08_ERR\t\t0x08\n#define PCXHR_ISR_HI08_CHK\t\t0x10\n#define PCXHR_ISR_HI08_HREQ\t\t0x80\n\n\n \n#define PCXHR_WAIT_DEFAULT\t\t2\n#define PCXHR_WAIT_IT\t\t\t25\n#define PCXHR_WAIT_IT_EXTRA\t\t65\n\n \nstatic int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,\n\t\t\t       unsigned char mask, unsigned char bit, int time,\n\t\t\t       unsigned char* read)\n{\n\tint i = 0;\n\tunsigned long end_time = jiffies + (time * HZ + 999) / 1000;\n\tdo {\n\t\t*read = PCXHR_INPB(mgr, reg);\n\t\tif ((*read & mask) == bit) {\n\t\t\tif (i > 100)\n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"ATTENTION! check_reg(%x) loopcount=%d\\n\",\n\t\t\t\t\t    reg, i);\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(&mgr->pci->dev,\n\t\t   \"pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=%x\\n\",\n\t\t   reg, mask, *read);\n\treturn -EIO;\n}\n\n \n#define PCXHR_TIMEOUT_DSP\t\t200\n\n\n#define PCXHR_MASK_EXTRA_INFO\t\t0x0000FE\n#define PCXHR_MASK_IT_HF0\t\t0x000100\n#define PCXHR_MASK_IT_HF1\t\t0x000200\n#define PCXHR_MASK_IT_NO_HF0_HF1\t0x000400\n#define PCXHR_MASK_IT_MANAGE_HF5\t0x000800\n#define PCXHR_MASK_IT_WAIT\t\t0x010000\n#define PCXHR_MASK_IT_WAIT_EXTRA\t0x020000\n\n#define PCXHR_IT_SEND_BYTE_XILINX\t(0x0000003C | PCXHR_MASK_IT_HF0)\n#define PCXHR_IT_TEST_XILINX\t\t(0x0000003C | PCXHR_MASK_IT_HF1 | \\\n\t\t\t\t\t PCXHR_MASK_IT_MANAGE_HF5)\n#define PCXHR_IT_DOWNLOAD_BOOT\t\t(0x0000000C | PCXHR_MASK_IT_HF1 | \\\n\t\t\t\t\t PCXHR_MASK_IT_MANAGE_HF5 | \\\n\t\t\t\t\t PCXHR_MASK_IT_WAIT)\n#define PCXHR_IT_RESET_BOARD_FUNC\t(0x0000000C | PCXHR_MASK_IT_HF0 | \\\n\t\t\t\t\t PCXHR_MASK_IT_MANAGE_HF5 | \\\n\t\t\t\t\t PCXHR_MASK_IT_WAIT_EXTRA)\n#define PCXHR_IT_DOWNLOAD_DSP\t\t(0x0000000C | \\\n\t\t\t\t\t PCXHR_MASK_IT_MANAGE_HF5 | \\\n\t\t\t\t\t PCXHR_MASK_IT_WAIT)\n#define PCXHR_IT_DEBUG\t\t\t(0x0000005A | PCXHR_MASK_IT_NO_HF0_HF1)\n#define PCXHR_IT_RESET_SEMAPHORE\t(0x0000005C | PCXHR_MASK_IT_NO_HF0_HF1)\n#define PCXHR_IT_MESSAGE\t\t(0x00000074 | PCXHR_MASK_IT_NO_HF0_HF1)\n#define PCXHR_IT_RESET_CHK\t\t(0x00000076 | PCXHR_MASK_IT_NO_HF0_HF1)\n#define PCXHR_IT_UPDATE_RBUFFER\t\t(0x00000078 | PCXHR_MASK_IT_NO_HF0_HF1)\n\nstatic int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr,\n\t\t\t     unsigned int itdsp, int atomic)\n{\n\tint err;\n\tunsigned char reg;\n\n\tif (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {\n\t\t \n\t\tPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,\n\t\t\t    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) &\n\t\t\t    ~PCXHR_MBOX0_HF5);\n\t}\n\tif ((itdsp & PCXHR_MASK_IT_NO_HF0_HF1) == 0) {\n\t\treg = (PCXHR_ICR_HI08_RREQ |\n\t\t       PCXHR_ICR_HI08_TREQ |\n\t\t       PCXHR_ICR_HI08_HDRQ);\n\t\tif (itdsp & PCXHR_MASK_IT_HF0)\n\t\t\treg |= PCXHR_ICR_HI08_HF0;\n\t\tif (itdsp & PCXHR_MASK_IT_HF1)\n\t\t\treg |= PCXHR_ICR_HI08_HF1;\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\n\t}\n\treg = (unsigned char)(((itdsp & PCXHR_MASK_EXTRA_INFO) >> 1) |\n\t\t\t      PCXHR_CVR_HI08_HC);\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_CVR, reg);\n\tif (itdsp & PCXHR_MASK_IT_WAIT) {\n\t\tif (atomic)\n\t\t\tmdelay(PCXHR_WAIT_IT);\n\t\telse\n\t\t\tmsleep(PCXHR_WAIT_IT);\n\t}\n\tif (itdsp & PCXHR_MASK_IT_WAIT_EXTRA) {\n\t\tif (atomic)\n\t\t\tmdelay(PCXHR_WAIT_IT_EXTRA);\n\t\telse\n\t\t\tmsleep(PCXHR_WAIT_IT);\n\t}\n\t \n\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_CVR,  PCXHR_CVR_HI08_HC, 0,\n\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\tif (err) {\n\t\tdev_err(&mgr->pci->dev, \"pcxhr_send_it_dsp : TIMEOUT CVR\\n\");\n\t\treturn err;\n\t}\n\tif (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {\n\t\t \n\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0,\n\t\t\t\t\t  PCXHR_MBOX0_HF5,\n\t\t\t\t\t  PCXHR_MBOX0_HF5,\n\t\t\t\t\t  PCXHR_TIMEOUT_DSP,\n\t\t\t\t\t  &reg);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t   \"pcxhr_send_it_dsp : TIMEOUT HF5\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;  \n}\n\nvoid pcxhr_reset_xilinx_com(struct pcxhr_mgr *mgr)\n{\n\t \n\tPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC,\n\t\t    PCXHR_CHIPSC_INIT_VALUE & ~PCXHR_CHIPSC_RESET_XILINX);\n}\n\nstatic void pcxhr_enable_irq(struct pcxhr_mgr *mgr, int enable)\n{\n\tunsigned int reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);\n\t \n\tif (enable)\n\t\treg |=  (PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);\n\telse\n\t\treg &= ~(PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);\n\tPCXHR_OUTPL(mgr, PCXHR_PLX_IRQCS, reg);\n}\n\nvoid pcxhr_reset_dsp(struct pcxhr_mgr *mgr)\n{\n\t \n\tpcxhr_enable_irq(mgr, 0);\n\n\t \n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 0);\n\tmsleep( PCXHR_WAIT_DEFAULT );  \n\tPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 3);\n\tmsleep( PCXHR_WAIT_DEFAULT );  \n\n\t \n\tPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0, 0);\n}\n\nvoid pcxhr_enable_dsp(struct pcxhr_mgr *mgr)\n{\n\t \n\tpcxhr_enable_irq(mgr, 1);\n}\n\n \nint pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr,\n\t\t\t     const struct firmware *xilinx, int second)\n{\n\tunsigned int i;\n\tunsigned int chipsc;\n\tunsigned char data;\n\tunsigned char mask;\n\tconst unsigned char *image;\n\n\t \n\tchipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);\n\t \n\t \n\tif(second) {\n\t\tif ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {\n\t\t\tdev_err(&mgr->pci->dev, \"error loading first xilinx\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tchipsc |= PCXHR_CHIPSC_RESET_XILINX;\n\t\tPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\n\t\tmsleep( PCXHR_WAIT_DEFAULT );  \n\t}\n\timage = xilinx->data;\n\tfor (i = 0; i < xilinx->size; i++, image++) {\n\t\tdata = *image;\n\t\tmask = 0x80;\n\t\twhile (mask) {\n\t\t\tchipsc &= ~(PCXHR_CHIPSC_DATA_CLK |\n\t\t\t\t    PCXHR_CHIPSC_DATA_IN);\n\t\t\tif (data & mask)\n\t\t\t\tchipsc |= PCXHR_CHIPSC_DATA_IN;\n\t\t\tPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\n\t\t\tchipsc |= PCXHR_CHIPSC_DATA_CLK;\n\t\t\tPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\n\t\t\tmask >>= 1;\n\t\t}\n\t\t \n\t\tcond_resched();\n\t}\n\tchipsc &= ~(PCXHR_CHIPSC_DATA_CLK | PCXHR_CHIPSC_DATA_IN);\n\tPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\n\t \n\tmsleep( PCXHR_WAIT_DEFAULT );\n\treturn 0;\n}\n\n \nstatic int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)\n{\n\tint err;\n\tunsigned int i;\n\tunsigned int len;\n\tconst unsigned char *data;\n\tunsigned char dummy;\n\t \n\tif (dsp->size <= 0)\n\t\treturn -EINVAL;\n\tif (dsp->size % 3)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!dsp->data))\n\t\treturn -EINVAL;\n\t \n\tfor (i = 0; i < dsp->size; i += 3) {\n\t\tdata = dsp->data + i;\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tlen = (unsigned int)((data[0]<<16) +\n\t\t\t\t\t     (data[1]<<8) +\n\t\t\t\t\t     data[2]);\n\t\t\tif (len && (dsp->size != (len + 2) * 3))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t  PCXHR_TIMEOUT_DSP, &dummy);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t   \"dsp loading error at position %d\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, data[0]);\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, data[1]);\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, data[2]);\n\n\t\t \n\t\tcond_resched();\n\t}\n\t \n\tmsleep(PCXHR_WAIT_DEFAULT);\n\treturn 0;\n}\n\n \nint pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr,\n\t\t\t     const struct firmware *eeprom)\n{\n\tint err;\n\tunsigned char reg;\n\n\t \n\treg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;\n\tif (PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & PCXHR_MBOX0_BOOT_HERE) {\n\t\t \n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg | PCXHR_ICR_HI08_INIT);\n\t\tmsleep(PCXHR_WAIT_DEFAULT);\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\n\t\tmsleep(PCXHR_WAIT_DEFAULT);\n\t\tdev_dbg(&mgr->pci->dev, \"no need to load eeprom boot\\n\");\n\t\treturn 0;\n\t}\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\n\n\terr = pcxhr_download_dsp(mgr, eeprom);\n\tif (err)\n\t\treturn err;\n\t \n\treturn pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\n\t\t\t\t   PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\n}\n\n \nint pcxhr_load_boot_binary(struct pcxhr_mgr *mgr, const struct firmware *boot)\n{\n\tint err;\n\tunsigned int physaddr = mgr->hostport.addr;\n\tunsigned char dummy;\n\n\t \n\tif (snd_BUG_ON(physaddr & 0xff))\n\t\treturn -EINVAL;\n\tPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX1, (physaddr >> 8));\n\n\terr = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_BOOT, 0);\n\tif (err)\n\t\treturn err;\n\t \n\tPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,\n\t\t    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & ~PCXHR_MBOX0_HF5);\n\n\terr = pcxhr_download_dsp(mgr, boot);\n\tif (err)\n\t\treturn err;\n\t \n\treturn pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0, PCXHR_MBOX0_HF5,\n\t\t\t\t   PCXHR_MBOX0_HF5, PCXHR_TIMEOUT_DSP, &dummy);\n}\n\n \nint pcxhr_load_dsp_binary(struct pcxhr_mgr *mgr, const struct firmware *dsp)\n{\n\tint err;\n\tunsigned char dummy;\n\terr = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_BOARD_FUNC, 0);\n\tif (err)\n\t\treturn err;\n\terr = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_DSP, 0);\n\tif (err)\n\t\treturn err;\n\terr = pcxhr_download_dsp(mgr, dsp);\n\tif (err)\n\t\treturn err;\n\t \n\treturn pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t   PCXHR_ISR_HI08_CHK,\n\t\t\t\t   PCXHR_ISR_HI08_CHK,\n\t\t\t\t   PCXHR_TIMEOUT_DSP, &dummy);\n}\n\n\nstruct pcxhr_cmd_info {\n\tu32 opcode;\t\t \n\tu16 st_length;\t\t \n\tu16 st_type;\t\t \n};\n\n \nenum {\n\tRMH_SSIZE_FIXED = 0,\t \n\tRMH_SSIZE_ARG = 1,\t \n\tRMH_SSIZE_MASK = 2,\t \n};\n\n \nstatic const struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {\n[CMD_VERSION] =\t\t\t\t{ 0x010000, 1, RMH_SSIZE_FIXED },\n[CMD_SUPPORTED] =\t\t\t{ 0x020000, 4, RMH_SSIZE_FIXED },\n[CMD_TEST_IT] =\t\t\t\t{ 0x040000, 1, RMH_SSIZE_FIXED },\n[CMD_SEND_IRQA] =\t\t\t{ 0x070001, 0, RMH_SSIZE_FIXED },\n[CMD_ACCESS_IO_WRITE] =\t\t\t{ 0x090000, 1, RMH_SSIZE_ARG },\n[CMD_ACCESS_IO_READ] =\t\t\t{ 0x094000, 1, RMH_SSIZE_ARG },\n[CMD_ASYNC] =\t\t\t\t{ 0x0a0000, 1, RMH_SSIZE_ARG },\n[CMD_MODIFY_CLOCK] =\t\t\t{ 0x0d0000, 0, RMH_SSIZE_FIXED },\n[CMD_RESYNC_AUDIO_INPUTS] =\t\t{ 0x0e0000, 0, RMH_SSIZE_FIXED },\n[CMD_GET_DSP_RESOURCES] =\t\t{ 0x100000, 4, RMH_SSIZE_FIXED },\n[CMD_SET_TIMER_INTERRUPT] =\t\t{ 0x110000, 0, RMH_SSIZE_FIXED },\n[CMD_RES_PIPE] =\t\t\t{ 0x400000, 0, RMH_SSIZE_FIXED },\n[CMD_FREE_PIPE] =\t\t\t{ 0x410000, 0, RMH_SSIZE_FIXED },\n[CMD_CONF_PIPE] =\t\t\t{ 0x422101, 0, RMH_SSIZE_FIXED },\n[CMD_STOP_PIPE] =\t\t\t{ 0x470004, 0, RMH_SSIZE_FIXED },\n[CMD_PIPE_SAMPLE_COUNT] =\t\t{ 0x49a000, 2, RMH_SSIZE_FIXED },\n[CMD_CAN_START_PIPE] =\t\t\t{ 0x4b0000, 1, RMH_SSIZE_FIXED },\n[CMD_START_STREAM] =\t\t\t{ 0x802000, 0, RMH_SSIZE_FIXED },\n[CMD_STREAM_OUT_LEVEL_ADJUST] =\t\t{ 0x822000, 0, RMH_SSIZE_FIXED },\n[CMD_STOP_STREAM] =\t\t\t{ 0x832000, 0, RMH_SSIZE_FIXED },\n[CMD_UPDATE_R_BUFFERS] =\t\t{ 0x840000, 0, RMH_SSIZE_FIXED },\n[CMD_FORMAT_STREAM_OUT] =\t\t{ 0x860000, 0, RMH_SSIZE_FIXED },\n[CMD_FORMAT_STREAM_IN] =\t\t{ 0x870000, 0, RMH_SSIZE_FIXED },\n[CMD_STREAM_SAMPLE_COUNT] =\t\t{ 0x902000, 2, RMH_SSIZE_FIXED },\n[CMD_AUDIO_LEVEL_ADJUST] =\t\t{ 0xc22000, 0, RMH_SSIZE_FIXED },\n[CMD_GET_TIME_CODE] =\t\t\t{ 0x060000, 5, RMH_SSIZE_FIXED },\n[CMD_MANAGE_SIGNAL] =\t\t\t{ 0x0f0000, 0, RMH_SSIZE_FIXED },\n};\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\nstatic const char * const cmd_names[] = {\n[CMD_VERSION] =\t\t\t\t\"CMD_VERSION\",\n[CMD_SUPPORTED] =\t\t\t\"CMD_SUPPORTED\",\n[CMD_TEST_IT] =\t\t\t\t\"CMD_TEST_IT\",\n[CMD_SEND_IRQA] =\t\t\t\"CMD_SEND_IRQA\",\n[CMD_ACCESS_IO_WRITE] =\t\t\t\"CMD_ACCESS_IO_WRITE\",\n[CMD_ACCESS_IO_READ] =\t\t\t\"CMD_ACCESS_IO_READ\",\n[CMD_ASYNC] =\t\t\t\t\"CMD_ASYNC\",\n[CMD_MODIFY_CLOCK] =\t\t\t\"CMD_MODIFY_CLOCK\",\n[CMD_RESYNC_AUDIO_INPUTS] =\t\t\"CMD_RESYNC_AUDIO_INPUTS\",\n[CMD_GET_DSP_RESOURCES] =\t\t\"CMD_GET_DSP_RESOURCES\",\n[CMD_SET_TIMER_INTERRUPT] =\t\t\"CMD_SET_TIMER_INTERRUPT\",\n[CMD_RES_PIPE] =\t\t\t\"CMD_RES_PIPE\",\n[CMD_FREE_PIPE] =\t\t\t\"CMD_FREE_PIPE\",\n[CMD_CONF_PIPE] =\t\t\t\"CMD_CONF_PIPE\",\n[CMD_STOP_PIPE] =\t\t\t\"CMD_STOP_PIPE\",\n[CMD_PIPE_SAMPLE_COUNT] =\t\t\"CMD_PIPE_SAMPLE_COUNT\",\n[CMD_CAN_START_PIPE] =\t\t\t\"CMD_CAN_START_PIPE\",\n[CMD_START_STREAM] =\t\t\t\"CMD_START_STREAM\",\n[CMD_STREAM_OUT_LEVEL_ADJUST] =\t\t\"CMD_STREAM_OUT_LEVEL_ADJUST\",\n[CMD_STOP_STREAM] =\t\t\t\"CMD_STOP_STREAM\",\n[CMD_UPDATE_R_BUFFERS] =\t\t\"CMD_UPDATE_R_BUFFERS\",\n[CMD_FORMAT_STREAM_OUT] =\t\t\"CMD_FORMAT_STREAM_OUT\",\n[CMD_FORMAT_STREAM_IN] =\t\t\"CMD_FORMAT_STREAM_IN\",\n[CMD_STREAM_SAMPLE_COUNT] =\t\t\"CMD_STREAM_SAMPLE_COUNT\",\n[CMD_AUDIO_LEVEL_ADJUST] =\t\t\"CMD_AUDIO_LEVEL_ADJUST\",\n[CMD_GET_TIME_CODE] =\t\t\t\"CMD_GET_TIME_CODE\",\n[CMD_MANAGE_SIGNAL] =\t\t\t\"CMD_MANAGE_SIGNAL\",\n};\n#endif\n\n\nstatic int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\n{\n\tint err;\n\tint i;\n\tu32 data;\n\tu32 size_mask;\n\tunsigned char reg;\n\tint max_stat_len;\n\n\tif (rmh->stat_len < PCXHR_SIZE_MAX_STATUS)\n\t\tmax_stat_len = PCXHR_SIZE_MAX_STATUS;\n\telse\tmax_stat_len = rmh->stat_len;\n\n\tfor (i = 0; i < rmh->stat_len; i++) {\n\t\t \n\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t\t  PCXHR_ISR_HI08_RXDF,\n\t\t\t\t\t  PCXHR_ISR_HI08_RXDF,\n\t\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"ERROR RMH stat: ISR:RXDF=1 (ISR = %x; i=%d )\\n\",\n\t\t\t\treg, i);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tdata  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;\n\t\tdata |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;\n\t\tdata |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);\n\n\t\t \n\t\tif (!i) {\n\t\t\tif (rmh->dsp_stat != RMH_SSIZE_FIXED) {\n\t\t\t\tif (rmh->dsp_stat == RMH_SSIZE_ARG) {\n\t\t\t\t\trmh->stat_len = (data & 0x0000ff) + 1;\n\t\t\t\t\tdata &= 0xffff00;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\trmh->stat_len = 1;\n\t\t\t\t\tsize_mask = data;\n\t\t\t\t\twhile (size_mask) {\n\t\t\t\t\t\tif (size_mask & 1)\n\t\t\t\t\t\t\trmh->stat_len++;\n\t\t\t\t\t\tsize_mask >>= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\t\tif (rmh->cmd_idx < CMD_LAST_INDEX)\n\t\t\tdev_dbg(&mgr->pci->dev, \"    stat[%d]=%x\\n\", i, data);\n#endif\n\t\tif (i < max_stat_len)\n\t\t\trmh->stat[i] = data;\n\t}\n\tif (rmh->stat_len > max_stat_len) {\n\t\tdev_dbg(&mgr->pci->dev, \"PCXHR : rmh->stat_len=%x too big\\n\",\n\t\t\t    rmh->stat_len);\n\t\trmh->stat_len = max_stat_len;\n\t}\n\treturn 0;\n}\n\nstatic int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\n{\n\tint err;\n\tint i;\n\tu32 data;\n\tunsigned char reg;\n\n\tif (snd_BUG_ON(rmh->cmd_len >= PCXHR_SIZE_MAX_CMD))\n\t\treturn -EINVAL;\n\terr = pcxhr_send_it_dsp(mgr, PCXHR_IT_MESSAGE, 1);\n\tif (err) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t\"pcxhr_send_message : ED_DSP_CRASHED\\n\");\n\t\treturn err;\n\t}\n\t \n\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\n\t\t\t\t  PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\n\tif (err)\n\t\treturn err;\n\t \n\terr = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_CHK, 1);\n\tif (err)\n\t\treturn err;\n\t \n\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK, 0,\n\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\tif (err)\n\t\treturn err;\n\n\tdata = rmh->cmd[0];\n\n\tif (rmh->cmd_len > 1)\n\t\tdata |= 0x008000;\t \n\telse\n\t\tdata &= 0xff7fff;\t \n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tif (rmh->cmd_idx < CMD_LAST_INDEX)\n\t\tdev_dbg(&mgr->pci->dev, \"MSG cmd[0]=%x (%s)\\n\",\n\t\t\t    data, cmd_names[rmh->cmd_idx]);\n#endif\n\n\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,\n\t\t\t\t  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &reg);\n\tif (err)\n\t\treturn err;\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\n\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\n\n\tif (rmh->cmd_len > 1) {\n\t\t \n\t\tdata = rmh->cmd_len - 1;\n\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\t\tif (err)\n\t\t\treturn err;\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\n\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\n\n\t\tfor (i=1; i < rmh->cmd_len; i++) {\n\t\t\t \n\t\t\tdata = rmh->cmd[i];\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\t\t\tif (rmh->cmd_idx < CMD_LAST_INDEX)\n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"    cmd[%d]=%x\\n\", i, data);\n#endif\n\t\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t\t  PCXHR_ISR_HI08_TRDY,\n\t\t\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\n\t\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\n\t\t\tPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\n\t\t}\n\t}\n\t \n\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\n\t\t\t\t  PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\n\tif (err)\n\t\treturn err;\n\t \n\tif (reg & PCXHR_ISR_HI08_ERR) {\n\t\t \n\t\terr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\n\t\t\t\t\t  PCXHR_ISR_HI08_RXDF,\n\t\t\t\t\t  PCXHR_ISR_HI08_RXDF,\n\t\t\t\t\t  PCXHR_TIMEOUT_DSP, &reg);\n\t\tif (err) {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\"ERROR RMH: ISR:RXDF=1 (ISR = %x)\\n\", reg);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tdata  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;\n\t\tdata |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;\n\t\tdata |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);\n\t\tdev_err(&mgr->pci->dev, \"ERROR RMH(%d): 0x%x\\n\",\n\t\t\t   rmh->cmd_idx, data);\n\t\terr = -EINVAL;\n\t} else {\n\t\t \n\t\terr = pcxhr_read_rmh_status(mgr, rmh);\n\t}\n\t \n\tif (pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_SEMAPHORE, 1) < 0)\n\t\treturn -EIO;\n\treturn err;\n}\n\n\n \nvoid pcxhr_init_rmh(struct pcxhr_rmh *rmh, int cmd)\n{\n\tif (snd_BUG_ON(cmd >= CMD_LAST_INDEX))\n\t\treturn;\n\trmh->cmd[0] = pcxhr_dsp_cmds[cmd].opcode;\n\trmh->cmd_len = 1;\n\trmh->stat_len = pcxhr_dsp_cmds[cmd].st_length;\n\trmh->dsp_stat = pcxhr_dsp_cmds[cmd].st_type;\n\trmh->cmd_idx = cmd;\n}\n\n\nvoid pcxhr_set_pipe_cmd_params(struct pcxhr_rmh *rmh, int capture,\n\t\t\t       unsigned int param1, unsigned int param2,\n\t\t\t       unsigned int param3)\n{\n\tsnd_BUG_ON(param1 > MASK_FIRST_FIELD);\n\tif (capture)\n\t\trmh->cmd[0] |= 0x800;\t\t \n\tif (param1)\n\t\trmh->cmd[0] |= (param1 << FIELD_SIZE);\n\tif (param2) {\n\t\tsnd_BUG_ON(param2 > MASK_FIRST_FIELD);\n\t\trmh->cmd[0] |= param2;\n\t}\n\tif(param3) {\n\t\tsnd_BUG_ON(param3 > MASK_DSP_WORD);\n\t\trmh->cmd[1] = param3;\n\t\trmh->cmd_len = 2;\n\t}\n}\n\n \nint pcxhr_send_msg(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\n{\n\tint err;\n\n\tmutex_lock(&mgr->msg_lock);\n\terr = pcxhr_send_msg_nolock(mgr, rmh);\n\tmutex_unlock(&mgr->msg_lock);\n\treturn err;\n}\n\nstatic inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)\n{\n\tint start_mask = PCXHR_INPL(mgr, PCXHR_PLX_MBOX2);\n\t \n\tstart_mask &= 0xffffff;\n\tdev_dbg(&mgr->pci->dev, \"CMD_PIPE_STATE MBOX2=0x%06x\\n\", start_mask);\n\treturn start_mask;\n}\n\n#define PCXHR_PIPE_STATE_CAPTURE_OFFSET\t\t12\n#define MAX_WAIT_FOR_DSP\t\t\t20\n\nstatic int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr,\n\t\t\t\t    int audio_mask, int *retry)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\tint audio = 0;\n\n\t*retry = 0;\n\twhile (audio_mask) {\n\t\tif (audio_mask & 1) {\n\t\t\tpcxhr_init_rmh(&rmh, CMD_CAN_START_PIPE);\n\t\t\tif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {\n\t\t\t\t \n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 1, audio -\n\t\t\t\t\t\tPCXHR_PIPE_STATE_CAPTURE_OFFSET,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t   \"error pipe start \"\n\t\t\t\t\t   \"(CMD_CAN_START_PIPE) err=%x!\\n\",\n\t\t\t\t\t   err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tif (rmh.stat[0] == 0)\n\t\t\t\t*retry |= (1<<audio);\n\t\t}\n\t\taudio_mask>>=1;\n\t\taudio++;\n\t}\n\treturn 0;\n}\n\nstatic int pcxhr_stop_pipes(struct pcxhr_mgr *mgr, int audio_mask)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\tint audio = 0;\n\n\twhile (audio_mask) {\n\t\tif (audio_mask & 1) {\n\t\t\tpcxhr_init_rmh(&rmh, CMD_STOP_PIPE);\n\t\t\tif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {\n\t\t\t\t \n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 1, audio -\n\t\t\t\t\t\tPCXHR_PIPE_STATE_CAPTURE_OFFSET,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t   \"error pipe stop \"\n\t\t\t\t\t   \"(CMD_STOP_PIPE) err=%x!\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\taudio_mask>>=1;\n\t\taudio++;\n\t}\n\treturn 0;\n}\n\nstatic int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\tint audio = 0;\n\n\twhile (audio_mask) {\n\t\tif (audio_mask & 1) {\n\t\t\tpcxhr_init_rmh(&rmh, CMD_CONF_PIPE);\n\t\t\tif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET)\n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 0, 0, 0,\n\t\t\t\t\t\t\t  1 << audio);\n\t\t\telse\n\t\t\t\tpcxhr_set_pipe_cmd_params(&rmh, 1, 0, 0,\n\t\t\t\t\t\t\t  1 << (audio - PCXHR_PIPE_STATE_CAPTURE_OFFSET));\n\t\t\terr = pcxhr_send_msg(mgr, &rmh);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t\t   \"error pipe start \"\n\t\t\t\t\t   \"(CMD_CONF_PIPE) err=%x!\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\taudio_mask>>=1;\n\t\taudio++;\n\t}\n\t \n\tpcxhr_init_rmh(&rmh, CMD_SEND_IRQA);\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err) {\n\t\tdev_err(&mgr->pci->dev,\n\t\t\t   \"error pipe start (CMD_SEND_IRQA) err=%x!\\n\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\n\nint pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,\n\t\t\t int capture_mask, int start)\n{\n\tint state, i, err;\n\tint audio_mask;\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tktime_t start_time, stop_time, diff_time;\n\n\tstart_time = ktime_get();\n#endif\n\taudio_mask = (playback_mask |\n\t\t      (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));\n\t \n\tstate = pcxhr_pipes_running(mgr);\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"pcxhr_set_pipe_state %s (mask %x current %x)\\n\",\n\t\t    start ? \"START\" : \"STOP\", audio_mask, state);\n\tif (start) {\n\t\t \n\t\taudio_mask &= ~state;\n\t\tstate = audio_mask;\n\t\tfor (i = 0; i < MAX_WAIT_FOR_DSP; i++) {\n\t\t\terr = pcxhr_prepair_pipe_start(mgr, state, &state);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (state == 0)\n\t\t\t\tbreak;\t \n\t\t\tmdelay(1);\t \n\t\t}\n\t} else {\n\t\taudio_mask &= state;\t \n\t}\n\tif (audio_mask == 0)\n\t\treturn 0;\n\n\terr = pcxhr_toggle_pipes(mgr, audio_mask);\n\tif (err)\n\t\treturn err;\n\n\ti = 0;\n\twhile (1) {\n\t\tstate = pcxhr_pipes_running(mgr);\n\t\t \n\t\tif ((state & audio_mask) == (start ? audio_mask : 0))\n\t\t\tbreak;\n\t\tif (++i >= MAX_WAIT_FOR_DSP * 100) {\n\t\t\tdev_err(&mgr->pci->dev, \"error pipe start/stop\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tudelay(10);\t\t\t \n\t}\n\tif (!start) {\n\t\terr = pcxhr_stop_pipes(mgr, audio_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tstop_time = ktime_get();\n\tdiff_time = ktime_sub(stop_time, start_time);\n\tdev_dbg(&mgr->pci->dev, \"***SET PIPE STATE*** TIME = %ld (err = %x)\\n\",\n\t\t\t(long)(ktime_to_ns(diff_time)), err);\n#endif\n\treturn 0;\n}\n\nint pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,\n\t\t\t\tunsigned int value, int *changed)\n{\n\tstruct pcxhr_rmh rmh;\n\tint err;\n\n\tmutex_lock(&mgr->msg_lock);\n\tif ((mgr->io_num_reg_cont & mask) == value) {\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"IO_NUM_REG_CONT mask %x already is set to %x\\n\",\n\t\t\t    mask, value);\n\t\tif (changed)\n\t\t\t*changed = 0;\n\t\tmutex_unlock(&mgr->msg_lock);\n\t\treturn 0;\t \n\t}\n\tpcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\n\trmh.cmd[0] |= IO_NUM_REG_CONT;\n\trmh.cmd[1]  = mask;\n\trmh.cmd[2]  = value;\n\trmh.cmd_len = 3;\n\terr = pcxhr_send_msg_nolock(mgr, &rmh);\n\tif (err == 0) {\n\t\tmgr->io_num_reg_cont &= ~mask;\n\t\tmgr->io_num_reg_cont |= value;\n\t\tif (changed)\n\t\t\t*changed = 1;\n\t}\n\tmutex_unlock(&mgr->msg_lock);\n\treturn err;\n}\n\n#define PCXHR_IRQ_TIMER\t\t0x000300\n#define PCXHR_IRQ_FREQ_CHANGE\t0x000800\n#define PCXHR_IRQ_TIME_CODE\t0x001000\n#define PCXHR_IRQ_NOTIFY\t0x002000\n#define PCXHR_IRQ_ASYNC\t\t0x008000\n#define PCXHR_IRQ_MASK\t\t0x00bb00\n#define PCXHR_FATAL_DSP_ERR\t0xff0000\n\nenum pcxhr_async_err_src {\n\tPCXHR_ERR_PIPE,\n\tPCXHR_ERR_STREAM,\n\tPCXHR_ERR_AUDIO\n};\n\nstatic int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,\n\t\t\t\t  enum pcxhr_async_err_src err_src, int pipe,\n\t\t\t\t  int is_capture)\n{\n\tstatic const char * const err_src_name[] = {\n\t\t[PCXHR_ERR_PIPE]\t= \"Pipe\",\n\t\t[PCXHR_ERR_STREAM]\t= \"Stream\",\n\t\t[PCXHR_ERR_AUDIO]\t= \"Audio\"\n\t};\n\n\tif (err & 0xfff)\n\t\terr &= 0xfff;\n\telse\n\t\terr = ((err >> 12) & 0xfff);\n\tif (!err)\n\t\treturn 0;\n\tdev_dbg(&mgr->pci->dev, \"CMD_ASYNC : Error %s %s Pipe %d err=%x\\n\",\n\t\t    err_src_name[err_src],\n\t\t    is_capture ? \"Record\" : \"Play\", pipe, err);\n\tif (err == 0xe01)\n\t\tmgr->async_err_stream_xrun++;\n\telse if (err == 0xe10)\n\t\tmgr->async_err_pipe_xrun++;\n\telse\n\t\tmgr->async_err_other_last = (int)err;\n\treturn 1;\n}\n\n\nstatic void pcxhr_msg_thread(struct pcxhr_mgr *mgr)\n{\n\tstruct pcxhr_rmh *prmh = mgr->prmh;\n\tint err;\n\tint i, j;\n\n\tif (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"PCXHR_IRQ_FREQ_CHANGE event occurred\\n\");\n\tif (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"PCXHR_IRQ_TIME_CODE event occurred\\n\");\n\tif (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"PCXHR_IRQ_NOTIFY event occurred\\n\");\n\tif (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {\n\t\t \n\t\tpcxhr_init_rmh(prmh, CMD_TEST_IT);\n\t\terr = pcxhr_send_msg(mgr, prmh);\n\t\tdev_dbg(&mgr->pci->dev, \"CMD_TEST_IT : err=%x, stat=%x\\n\",\n\t\t\t    err, prmh->stat[0]);\n\t}\n\tif (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {\n\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\"PCXHR_IRQ_ASYNC event occurred\\n\");\n\n\t\tpcxhr_init_rmh(prmh, CMD_ASYNC);\n\t\tprmh->cmd[0] |= 1;\t \n\t\t \n\t\tprmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;\n\t\terr = pcxhr_send_msg(mgr, prmh);\n\t\tif (err)\n\t\t\tdev_err(&mgr->pci->dev, \"ERROR pcxhr_msg_thread=%x;\\n\",\n\t\t\t\t   err);\n\t\ti = 1;\n\t\twhile (i < prmh->stat_len) {\n\t\t\tint nb_audio = ((prmh->stat[i] >> FIELD_SIZE) &\n\t\t\t\t\tMASK_FIRST_FIELD);\n\t\t\tint nb_stream = ((prmh->stat[i] >> (2*FIELD_SIZE)) &\n\t\t\t\t\t MASK_FIRST_FIELD);\n\t\t\tint pipe = prmh->stat[i] & MASK_FIRST_FIELD;\n\t\t\tint is_capture = prmh->stat[i] & 0x400000;\n\t\t\tu32 err2;\n\n\t\t\tif (prmh->stat[i] & 0x800000) {\t \n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"TASKLET : End%sPipe %d\\n\",\n\t\t\t\t\t    is_capture ? \"Record\" : \"Play\",\n\t\t\t\t\t    pipe);\n\t\t\t}\n\t\t\ti++;\n\t\t\terr2 = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];\n\t\t\tif (err2)\n\t\t\t\tpcxhr_handle_async_err(mgr, err2,\n\t\t\t\t\t\t       PCXHR_ERR_PIPE,\n\t\t\t\t\t\t       pipe, is_capture);\n\t\t\ti += 2;\n\t\t\tfor (j = 0; j < nb_stream; j++) {\n\t\t\t\terr2 = prmh->stat[i] ?\n\t\t\t\t\tprmh->stat[i] : prmh->stat[i+1];\n\t\t\t\tif (err2)\n\t\t\t\t\tpcxhr_handle_async_err(mgr, err2,\n\t\t\t\t\t\t\t       PCXHR_ERR_STREAM,\n\t\t\t\t\t\t\t       pipe,\n\t\t\t\t\t\t\t       is_capture);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tfor (j = 0; j < nb_audio; j++) {\n\t\t\t\terr2 = prmh->stat[i] ?\n\t\t\t\t\tprmh->stat[i] : prmh->stat[i+1];\n\t\t\t\tif (err2)\n\t\t\t\t\tpcxhr_handle_async_err(mgr, err2,\n\t\t\t\t\t\t\t       PCXHR_ERR_AUDIO,\n\t\t\t\t\t\t\t       pipe,\n\t\t\t\t\t\t\t       is_capture);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,\n\t\t\t\t\t    struct pcxhr_stream *stream)\n{\n\tu_int64_t hw_sample_count;\n\tstruct pcxhr_rmh rmh;\n\tint err, stream_mask;\n\n\tstream_mask = stream->pipe->is_capture ? 1 : 1<<stream->substream->number;\n\n\t \n\tpcxhr_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);\n\tpcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,\n\t\t\t\t  stream->pipe->first_audio, 0, stream_mask);\n\t \t \n\n\terr = pcxhr_send_msg(mgr, &rmh);\n\tif (err)\n\t\treturn 0;\n\n\thw_sample_count = ((u_int64_t)rmh.stat[0]) << 24;\n\thw_sample_count += (u_int64_t)rmh.stat[1];\n\n\tdev_dbg(&mgr->pci->dev,\n\t\t\"stream %c%d : abs samples real(%llu) timer(%llu)\\n\",\n\t\t    stream->pipe->is_capture ? 'C' : 'P',\n\t\t    stream->substream->number,\n\t\t    hw_sample_count,\n\t\t    stream->timer_abs_periods + stream->timer_period_frag +\n\t\t\t\t\t\tmgr->granularity);\n\treturn hw_sample_count;\n}\n\nstatic void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,\n\t\t\t\t   struct pcxhr_stream *stream,\n\t\t\t\t   int samples_to_add)\n{\n\tif (stream->substream &&\n\t    (stream->status == PCXHR_STREAM_STATUS_RUNNING)) {\n\t\tu_int64_t new_sample_count;\n\t\tint elapsed = 0;\n\t\tint hardware_read = 0;\n\t\tstruct snd_pcm_runtime *runtime = stream->substream->runtime;\n\n\t\tif (samples_to_add < 0) {\n\t\t\tstream->timer_is_synced = 0;\n\t\t\t \n\t\t\tsamples_to_add = mgr->granularity;\n\t\t}\n\n\t\tif (!stream->timer_is_synced) {\n\t\t\tif ((stream->timer_abs_periods != 0) ||\n\t\t\t    ((stream->timer_period_frag + samples_to_add) >=\n\t\t\t    runtime->period_size)) {\n\t\t\t\tnew_sample_count =\n\t\t\t\t  pcxhr_stream_read_position(mgr, stream);\n\t\t\t\thardware_read = 1;\n\t\t\t\tif (new_sample_count >= mgr->granularity) {\n\t\t\t\t\t \n\t\t\t\t\tnew_sample_count -= mgr->granularity;\n\t\t\t\t\tstream->timer_is_synced = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!hardware_read) {\n\t\t\t \n\t\t\tnew_sample_count = stream->timer_abs_periods +\n\t\t\t\tstream->timer_period_frag + samples_to_add;\n\t\t}\n\t\twhile (1) {\n\t\t\tu_int64_t new_elapse_pos = stream->timer_abs_periods +\n\t\t\t\truntime->period_size;\n\t\t\tif (new_elapse_pos > new_sample_count)\n\t\t\t\tbreak;\n\t\t\telapsed = 1;\n\t\t\tstream->timer_buf_periods++;\n\t\t\tif (stream->timer_buf_periods >= runtime->periods)\n\t\t\t\tstream->timer_buf_periods = 0;\n\t\t\tstream->timer_abs_periods = new_elapse_pos;\n\t\t}\n\t\tif (new_sample_count >= stream->timer_abs_periods) {\n\t\t\tstream->timer_period_frag =\n\t\t\t\t(u_int32_t)(new_sample_count -\n\t\t\t\t\t    stream->timer_abs_periods);\n\t\t} else {\n\t\t\tdev_err(&mgr->pci->dev,\n\t\t\t\t   \"ERROR new_sample_count too small ??? %ld\\n\",\n\t\t\t\t   (long unsigned int)new_sample_count);\n\t\t}\n\n\t\tif (elapsed) {\n\t\t\tmutex_unlock(&mgr->lock);\n\t\t\tsnd_pcm_period_elapsed(stream->substream);\n\t\t\tmutex_lock(&mgr->lock);\n\t\t}\n\t}\n}\n\nirqreturn_t pcxhr_interrupt(int irq, void *dev_id)\n{\n\tstruct pcxhr_mgr *mgr = dev_id;\n\tunsigned int reg;\n\tbool wake_thread = false;\n\n\treg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);\n\tif (! (reg & PCXHR_IRQCS_ACTIVE_PCIDB)) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\treg = PCXHR_INPL(mgr, PCXHR_PLX_L2PCIDB);\n\tPCXHR_OUTPL(mgr, PCXHR_PLX_L2PCIDB, reg);\n\n\t \n\tif (reg & PCXHR_IRQ_TIMER) {\n\t\tint timer_toggle = reg & PCXHR_IRQ_TIMER;\n\t\tif (timer_toggle == mgr->timer_toggle) {\n\t\t\tdev_dbg(&mgr->pci->dev, \"ERROR TIMER TOGGLE\\n\");\n\t\t\tmgr->dsp_time_err++;\n\t\t}\n\n\t\tmgr->timer_toggle = timer_toggle;\n\t\tmgr->src_it_dsp = reg;\n\t\twake_thread = true;\n\t}\n\n\t \n\tif (reg & PCXHR_IRQ_MASK) {\n\t\tif (reg & PCXHR_IRQ_ASYNC) {\n\t\t\t \n\t\t\t \n\t\t\tmgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;\n\t\t}\n\t\tmgr->src_it_dsp = reg;\n\t\twake_thread = true;\n\t}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\tif (reg & PCXHR_FATAL_DSP_ERR)\n\t\tdev_dbg(&mgr->pci->dev, \"FATAL DSP ERROR : %x\\n\", reg);\n#endif\n\n\treturn wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}\n\nirqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)\n{\n\tstruct pcxhr_mgr *mgr = dev_id;\n\tint i, j;\n\tstruct snd_pcxhr *chip;\n\n\tmutex_lock(&mgr->lock);\n\tif (mgr->src_it_dsp & PCXHR_IRQ_TIMER) {\n\t\t \n\t\tint dsp_time_new =\n\t\t\tPCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;\n\t\tint dsp_time_diff = dsp_time_new - mgr->dsp_time_last;\n\n\t\tif ((dsp_time_diff < 0) &&\n\t\t    (mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID)) {\n\t\t\t \n\t\t\tint tmp_diff = dsp_time_diff + PCXHR_DSP_TIME_MASK + 1;\n\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\"WARNING DSP timestamp old(%d) new(%d)\",\n\t\t\t\t    mgr->dsp_time_last, dsp_time_new);\n\t\t\tif (tmp_diff > 0 && tmp_diff <= (2*mgr->granularity)) {\n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"-> timestamp wraparound OK: \"\n\t\t\t\t\t    \"diff=%d\\n\", tmp_diff);\n\t\t\t\tdsp_time_diff = tmp_diff;\n\t\t\t} else {\n\t\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\t\"-> resynchronize all streams\\n\");\n\t\t\t\tmgr->dsp_time_err++;\n\t\t\t}\n\t\t}\n#ifdef CONFIG_SND_DEBUG_VERBOSE\n\t\tif (dsp_time_diff == 0)\n\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\"ERROR DSP TIME NO DIFF time(%d)\\n\",\n\t\t\t\t    dsp_time_new);\n\t\telse if (dsp_time_diff >= (2*mgr->granularity))\n\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\"ERROR DSP TIME TOO BIG old(%d) add(%d)\\n\",\n\t\t\t\t    mgr->dsp_time_last,\n\t\t\t\t    dsp_time_new - mgr->dsp_time_last);\n\t\telse if (dsp_time_diff % mgr->granularity)\n\t\t\tdev_dbg(&mgr->pci->dev,\n\t\t\t\t\"ERROR DSP TIME increased by %d\\n\",\n\t\t\t\t    dsp_time_diff);\n#endif\n\t\tmgr->dsp_time_last = dsp_time_new;\n\n\t\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\t\tchip = mgr->chip[i];\n\t\t\tfor (j = 0; j < chip->nb_streams_capt; j++)\n\t\t\t\tpcxhr_update_timer_pos(mgr,\n\t\t\t\t\t\t&chip->capture_stream[j],\n\t\t\t\t\t\tdsp_time_diff);\n\t\t}\n\t\tfor (i = 0; i < mgr->num_cards; i++) {\n\t\t\tchip = mgr->chip[i];\n\t\t\tfor (j = 0; j < chip->nb_streams_play; j++)\n\t\t\t\tpcxhr_update_timer_pos(mgr,\n\t\t\t\t\t\t&chip->playback_stream[j],\n\t\t\t\t\t\tdsp_time_diff);\n\t\t}\n\t}\n\n\tpcxhr_msg_thread(mgr);\n\tmutex_unlock(&mgr->lock);\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}