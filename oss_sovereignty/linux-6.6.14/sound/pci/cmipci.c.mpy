{
  "module_name": "cmipci.c",
  "hash_id": "47e120385be0679069e6335b443a03e098818ae4bde6f88074b698e7f1366f0c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cmipci.c",
  "human_readable_source": "\n \n \n \n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/sb.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"C-Media CMI8x38 PCI\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};\nstatic long fm_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};\nstatic bool soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};\n#ifdef SUPPORT_JOYSTICK\nstatic int joystick_port[SNDRV_CARDS];\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for C-Media PCI soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for C-Media PCI soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable C-Media PCI soundcard.\");\nmodule_param_hw_array(mpu_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port.\");\nmodule_param_hw_array(fm_port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(fm_port, \"FM port.\");\nmodule_param_array(soft_ac3, bool, NULL, 0444);\nMODULE_PARM_DESC(soft_ac3, \"Software-conversion of raw SPDIF packets (model 033 only).\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_hw_array(joystick_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(joystick_port, \"Joystick port address.\");\n#endif\n\n \n\n#define CM_REG_FUNCTRL0\t\t0x00\n#define CM_RST_CH1\t\t0x00080000\n#define CM_RST_CH0\t\t0x00040000\n#define CM_CHEN1\t\t0x00020000\t \n#define CM_CHEN0\t\t0x00010000\t \n#define CM_PAUSE1\t\t0x00000008\t \n#define CM_PAUSE0\t\t0x00000004\t \n#define CM_CHADC1\t\t0x00000002\t \n#define CM_CHADC0\t\t0x00000001\t \n\n#define CM_REG_FUNCTRL1\t\t0x04\n#define CM_DSFC_MASK\t\t0x0000E000\t \n#define CM_DSFC_SHIFT\t\t13\n#define CM_ASFC_MASK\t\t0x00001C00\t \n#define CM_ASFC_SHIFT\t\t10\n#define CM_SPDF_1\t\t0x00000200\t \n#define CM_SPDF_0\t\t0x00000100\t \n#define CM_SPDFLOOP\t\t0x00000080\t \n#define CM_SPDO2DAC\t\t0x00000040\t \n#define CM_INTRM\t\t0x00000020\t \n#define CM_BREQ\t\t\t0x00000010\t \n#define CM_VOICE_EN\t\t0x00000008\t \n#define CM_UART_EN\t\t0x00000004\t \n#define CM_JYSTK_EN\t\t0x00000002\t \n#define CM_ZVPORT\t\t0x00000001\t \n\n#define CM_REG_CHFORMAT\t\t0x08\n\n#define CM_CHB3D5C\t\t0x80000000\t \n#define CM_FMOFFSET2\t\t0x40000000\t \n#define CM_CHB3D\t\t0x20000000\t \n\n#define CM_CHIP_MASK1\t\t0x1f000000\n#define CM_CHIP_037\t\t0x01000000\n#define CM_SETLAT48\t\t0x00800000\t \n#define CM_EDGEIRQ\t\t0x00400000\t \n#define CM_SPD24SEL39\t\t0x00200000\t \n#define CM_AC3EN1\t\t0x00100000\t \n#define CM_SPDIF_SELECT1\t0x00080000\t \n#define CM_SPD24SEL\t\t0x00020000\t \n   \n\n#define CM_ADCBITLEN_MASK\t0x0000C000\t\n#define CM_ADCBITLEN_16\t\t0x00000000\n#define CM_ADCBITLEN_15\t\t0x00004000\n#define CM_ADCBITLEN_14\t\t0x00008000\n#define CM_ADCBITLEN_13\t\t0x0000C000\n\n#define CM_ADCDACLEN_MASK\t0x00003000\t \n#define CM_ADCDACLEN_060\t0x00000000\n#define CM_ADCDACLEN_066\t0x00001000\n#define CM_ADCDACLEN_130\t0x00002000\n#define CM_ADCDACLEN_280\t0x00003000\n\n#define CM_ADCDLEN_MASK\t\t0x00003000\t \n#define CM_ADCDLEN_ORIGINAL\t0x00000000\n#define CM_ADCDLEN_EXTRA\t0x00001000\n#define CM_ADCDLEN_24K\t\t0x00002000\n#define CM_ADCDLEN_WEIGHT\t0x00003000\n\n#define CM_CH1_SRATE_176K\t0x00000800\n#define CM_CH1_SRATE_96K\t0x00000800\t \n#define CM_CH1_SRATE_88K\t0x00000400\n#define CM_CH0_SRATE_176K\t0x00000200\n#define CM_CH0_SRATE_96K\t0x00000200\t \n#define CM_CH0_SRATE_88K\t0x00000100\n#define CM_CH0_SRATE_128K\t0x00000300\n#define CM_CH0_SRATE_MASK\t0x00000300\n\n#define CM_SPDIF_INVERSE2\t0x00000080\t \n#define CM_DBLSPDS\t\t0x00000040\t \n#define CM_POLVALID\t\t0x00000020\t \n#define CM_SPDLOCKED\t\t0x00000010\n\n#define CM_CH1FMT_MASK\t\t0x0000000C\t \n#define CM_CH1FMT_SHIFT\t\t2\n#define CM_CH0FMT_MASK\t\t0x00000003\t \n#define CM_CH0FMT_SHIFT\t\t0\n\n#define CM_REG_INT_HLDCLR\t0x0C\n#define CM_CHIP_MASK2\t\t0xff000000\n#define CM_CHIP_8768\t\t0x20000000\n#define CM_CHIP_055\t\t0x08000000\n#define CM_CHIP_039\t\t0x04000000\n#define CM_CHIP_039_6CH\t\t0x01000000\n#define CM_UNKNOWN_INT_EN\t0x00080000\t \n#define CM_TDMA_INT_EN\t\t0x00040000\n#define CM_CH1_INT_EN\t\t0x00020000\n#define CM_CH0_INT_EN\t\t0x00010000\n\n#define CM_REG_INT_STATUS\t0x10\n#define CM_INTR\t\t\t0x80000000\n#define CM_VCO\t\t\t0x08000000\t \n#define CM_MCBINT\t\t0x04000000\t \n#define CM_UARTINT\t\t0x00010000\n#define CM_LTDMAINT\t\t0x00008000\n#define CM_HTDMAINT\t\t0x00004000\n#define CM_XDO46\t\t0x00000080\t \n#define CM_LHBTOG\t\t0x00000040\t \n#define CM_LEG_HDMA\t\t0x00000020\t \n#define CM_LEG_STEREO\t\t0x00000010\t \n#define CM_CH1BUSY\t\t0x00000008\n#define CM_CH0BUSY\t\t0x00000004\n#define CM_CHINT1\t\t0x00000002\n#define CM_CHINT0\t\t0x00000001\n\n#define CM_REG_LEGACY_CTRL\t0x14\n#define CM_NXCHG\t\t0x80000000\t \n#define CM_VMPU_MASK\t\t0x60000000\t \n#define CM_VMPU_330\t\t0x00000000\n#define CM_VMPU_320\t\t0x20000000\n#define CM_VMPU_310\t\t0x40000000\n#define CM_VMPU_300\t\t0x60000000\n#define CM_ENWR8237\t\t0x10000000\t \n#define CM_VSBSEL_MASK\t\t0x0C000000\t \n#define CM_VSBSEL_220\t\t0x00000000\n#define CM_VSBSEL_240\t\t0x04000000\n#define CM_VSBSEL_260\t\t0x08000000\n#define CM_VSBSEL_280\t\t0x0C000000\n#define CM_FMSEL_MASK\t\t0x03000000\t \n#define CM_FMSEL_388\t\t0x00000000\n#define CM_FMSEL_3C8\t\t0x01000000\n#define CM_FMSEL_3E0\t\t0x02000000\n#define CM_FMSEL_3E8\t\t0x03000000\n#define CM_ENSPDOUT\t\t0x00800000\t \n#define CM_SPDCOPYRHT\t\t0x00400000\t \n#define CM_DAC2SPDO\t\t0x00200000\t \n#define CM_INVIDWEN\t\t0x00100000\t \n#define CM_SETRETRY\t\t0x00100000\t \n#define CM_C_EEACCESS\t\t0x00080000\t \n#define CM_C_EECS\t\t0x00040000\n#define CM_C_EEDI46\t\t0x00020000\n#define CM_C_EECK46\t\t0x00010000\n#define CM_CHB3D6C\t\t0x00008000\t \n#define CM_CENTR2LIN\t\t0x00004000\t \n#define CM_BASE2LIN\t\t0x00002000\t \n#define CM_EXBASEN\t\t0x00001000\t \n\n#define CM_REG_MISC_CTRL\t0x18\n#define CM_PWD\t\t\t0x80000000\t \n#define CM_RESET\t\t0x40000000\n#define CM_SFIL_MASK\t\t0x30000000\t \n#define CM_VMGAIN\t\t0x10000000\t \n#define CM_TXVX\t\t\t0x08000000\t \n#define CM_N4SPK3D\t\t0x04000000\t \n#define CM_SPDO5V\t\t0x02000000\t \n#define CM_SPDIF48K\t\t0x01000000\t \n#define CM_SPATUS48K\t\t0x01000000\t \n#define CM_ENDBDAC\t\t0x00800000\t \n#define CM_XCHGDAC\t\t0x00400000\t \n#define CM_SPD32SEL\t\t0x00200000\t \n#define CM_SPDFLOOPI\t\t0x00100000\t \n#define CM_FM_EN\t\t0x00080000\t \n#define CM_AC3EN2\t\t0x00040000\t \n#define CM_ENWRASID\t\t0x00010000\t \n#define CM_VIDWPDSB\t\t0x00010000\t \n#define CM_SPDF_AC97\t\t0x00008000\t \n#define CM_MASK_EN\t\t0x00004000\t \n#define CM_ENWRMSID\t\t0x00002000\t \n#define CM_VIDWPPRT\t\t0x00002000\t \n#define CM_SFILENB\t\t0x00001000\t \n#define CM_MMODE_MASK\t\t0x00000E00\t \n#define CM_SPDIF_SELECT2\t0x00000100\t \n#define CM_ENCENTER\t\t0x00000080\n#define CM_FLINKON\t\t0x00000040\t \n#define CM_MUTECH1\t\t0x00000040\t \n#define CM_FLINKOFF\t\t0x00000020\t \n#define CM_MIDSMP\t\t0x00000010\t \n#define CM_UPDDMA_MASK\t\t0x0000000C\t \n#define CM_UPDDMA_2048\t\t0x00000000\n#define CM_UPDDMA_1024\t\t0x00000004\n#define CM_UPDDMA_512\t\t0x00000008\n#define CM_UPDDMA_256\t\t0x0000000C\t\t\n#define CM_TWAIT_MASK\t\t0x00000003\t \n#define CM_TWAIT1\t\t0x00000002\t \n#define CM_TWAIT0\t\t0x00000001\t \n\n#define CM_REG_TDMA_POSITION\t0x1C\n#define CM_TDMA_CNT_MASK\t0xFFFF0000\t \n#define CM_TDMA_ADR_MASK\t0x0000FFFF\t \n\n\t \n#define CM_REG_MIXER0\t\t0x20\n#define CM_REG_SBVR\t\t0x20\t\t \n#define CM_REG_DEV\t\t0x20\t\t \n\n#define CM_REG_MIXER21\t\t0x21\n#define CM_UNKNOWN_21_MASK\t0x78\t\t \n#define CM_X_ADPCM\t\t0x04\t\t \n#define CM_PROINV\t\t0x02\t\t \n#define CM_X_SB16\t\t0x01\t\t \n\n#define CM_REG_SB16_DATA\t0x22\n#define CM_REG_SB16_ADDR\t0x23\n\n#define CM_REFFREQ_XIN\t\t(315*1000*1000)/22\t \n#define CM_ADCMULT_XIN\t\t512\t\t\t \n#define CM_TOLERANCE_RATE\t0.001\t\t\t \n#define CM_MAXIMUM_RATE\t\t80000000\t\t \n\n#define CM_REG_MIXER1\t\t0x24\n#define CM_FMMUTE\t\t0x80\t \n#define CM_FMMUTE_SHIFT\t\t7\n#define CM_WSMUTE\t\t0x40\t \n#define CM_WSMUTE_SHIFT\t\t6\n#define CM_REAR2LIN\t\t0x20\t \n#define CM_REAR2LIN_SHIFT\t5\n#define CM_REAR2FRONT\t\t0x10\t \n#define CM_REAR2FRONT_SHIFT\t4\n#define CM_WAVEINL\t\t0x08\t \n#define CM_WAVEINL_SHIFT\t3\n#define CM_WAVEINR\t\t0x04\t \n#define CM_WAVEINR_SHIFT\t2\n#define CM_X3DEN\t\t0x02\t \n#define CM_X3DEN_SHIFT\t\t1\n#define CM_CDPLAY\t\t0x01\t \n#define CM_CDPLAY_SHIFT\t\t0\n\n#define CM_REG_MIXER2\t\t0x25\n#define CM_RAUXREN\t\t0x80\t \n#define CM_RAUXREN_SHIFT\t7\n#define CM_RAUXLEN\t\t0x40\t \n#define CM_RAUXLEN_SHIFT\t6\n#define CM_VAUXRM\t\t0x20\t \n#define CM_VAUXRM_SHIFT\t\t5\n#define CM_VAUXLM\t\t0x10\t \n#define CM_VAUXLM_SHIFT\t\t4\n#define CM_VADMIC_MASK\t\t0x0e\t \n#define CM_VADMIC_SHIFT\t\t1\n#define CM_MICGAINZ\t\t0x01\t \n#define CM_MICGAINZ_SHIFT\t0\n\n#define CM_REG_AUX_VOL\t\t0x26\n#define CM_VAUXL_MASK\t\t0xf0\n#define CM_VAUXR_MASK\t\t0x0f\n\n#define CM_REG_MISC\t\t0x27\n#define CM_UNKNOWN_27_MASK\t0xd8\t \n#define CM_XGPO1\t\t0x20\n \n#define CM_MIC_CENTER_LFE\t0x04\t \n#define CM_SPDIF_INVERSE\t0x04\t \n#define CM_SPDVALID\t\t0x02\t \n#define CM_DMAUTO\t\t0x01\t \n\n#define CM_REG_AC97\t\t0x28\t \n \n#define CM_REG_EXTERN_CODEC\tCM_REG_AC97\n\n \n#define CM_REG_MPU_PCI\t\t0x40\n\n \n#define CM_REG_FM_PCI\t\t0x50\n\n \n#define CM_REG_EXTENT_IND\t0xf0\n#define CM_VPHONE_MASK\t\t0xe0\t \n#define CM_VPHONE_SHIFT\t\t5\n#define CM_VPHOM\t\t0x10\t \n#define CM_VSPKM\t\t0x08\t \n#define CM_RLOOPREN\t\t0x04     \n#define CM_RLOOPLEN\t\t0x02\t \n#define CM_VADMIC3\t\t0x01\t \n\n \n#define CM_REG_PLL\t\t0xf8\n\n \n#define CM_REG_CH0_FRAME1\t0x80\t \n#define CM_REG_CH0_FRAME2\t0x84\t \n#define CM_REG_CH1_FRAME1\t0x88\t \n#define CM_REG_CH1_FRAME2\t0x8C\t \n\n#define CM_REG_EXT_MISC\t\t0x90\n#define CM_ADC48K44K\t\t0x10000000\t \n#define CM_CHB3D8C\t\t0x00200000\t \n#define CM_SPD32FMT\t\t0x00100000\t \n#define CM_ADC2SPDIF\t\t0x00080000\t \n#define CM_SHAREADC\t\t0x00040000\t \n#define CM_REALTCMP\t\t0x00020000\t \n#define CM_INVLRCK\t\t0x00010000\t \n#define CM_UNKNOWN_90_MASK\t0x0000FFFF\t \n\n \n#define CM_EXTENT_CODEC\t  0x100\n#define CM_EXTENT_MIDI\t  0x2\n#define CM_EXTENT_SYNTH\t  0x4\n\n\n \n#define CM_CH_PLAY\t0\n#define CM_CH_CAPT\t1\n\n \n#define CM_OPEN_NONE\t0\n#define CM_OPEN_CH_MASK\t0x01\n#define CM_OPEN_DAC\t0x10\n#define CM_OPEN_ADC\t0x20\n#define CM_OPEN_SPDIF\t0x40\n#define CM_OPEN_MCHAN\t0x80\n#define CM_OPEN_PLAYBACK\t(CM_CH_PLAY | CM_OPEN_DAC)\n#define CM_OPEN_PLAYBACK2\t(CM_CH_CAPT | CM_OPEN_DAC)\n#define CM_OPEN_PLAYBACK_MULTI\t(CM_CH_PLAY | CM_OPEN_DAC | CM_OPEN_MCHAN)\n#define CM_OPEN_CAPTURE\t\t(CM_CH_CAPT | CM_OPEN_ADC)\n#define CM_OPEN_SPDIF_PLAYBACK\t(CM_CH_PLAY | CM_OPEN_DAC | CM_OPEN_SPDIF)\n#define CM_OPEN_SPDIF_CAPTURE\t(CM_CH_CAPT | CM_OPEN_ADC | CM_OPEN_SPDIF)\n\n\n#if CM_CH_PLAY == 1\n#define CM_PLAYBACK_SRATE_176K\tCM_CH1_SRATE_176K\n#define CM_PLAYBACK_SPDF\tCM_SPDF_1\n#define CM_CAPTURE_SPDF\t\tCM_SPDF_0\n#else\n#define CM_PLAYBACK_SRATE_176K CM_CH0_SRATE_176K\n#define CM_PLAYBACK_SPDF\tCM_SPDF_0\n#define CM_CAPTURE_SPDF\t\tCM_SPDF_1\n#endif\n\n\n \n\nstruct cmipci_pcm {\n\tstruct snd_pcm_substream *substream;\n\tu8 running;\t\t \n\tu8 fmt;\t\t\t \n\tu8 is_dac;\n\tu8 needs_silencing;\n\tunsigned int dma_size;\t \n\tunsigned int shift;\n\tunsigned int ch;\t \n\tunsigned int offset;\t \n};\n\n \nstruct cmipci_mixer_auto_switches {\n\tconst char *name;\t \n\tint toggle_on;\t\t \n};\nstatic const struct cmipci_mixer_auto_switches cm_saved_mixer[] = {\n\t{\"PCM Playback Switch\", 0},\n\t{\"IEC958 Output Switch\", 1},\n\t{\"IEC958 Mix Analog\", 0},\n\t\n\t{\"IEC958 Loop\", 0},\n};\n#define CM_SAVED_MIXERS\t\tARRAY_SIZE(cm_saved_mixer)\n\nstruct cmipci {\n\tstruct snd_card *card;\n\n\tstruct pci_dev *pci;\n\tunsigned int device;\t \n\tint irq;\n\n\tunsigned long iobase;\n\tunsigned int ctrl;\t \n\n\tstruct snd_pcm *pcm;\t\t \n\tstruct snd_pcm *pcm2;\t \n\tstruct snd_pcm *pcm_spdif;\t \n\n\tint chip_version;\n\tint max_channels;\n\tunsigned int can_ac3_sw: 1;\n\tunsigned int can_ac3_hw: 1;\n\tunsigned int can_multi_ch: 1;\n\tunsigned int can_96k: 1;\t \n\tunsigned int do_soft_ac3: 1;\n\n\tunsigned int spdif_playback_avail: 1;\t \n\tunsigned int spdif_playback_enabled: 1;\t \n\tint spdif_counter;\t \n\n\tunsigned int dig_status;\n\tunsigned int dig_pcm_status;\n\n\tstruct snd_pcm_hardware *hw_info[3];  \n\n\tint opened[2];\t \n\tstruct mutex open_mutex;\n\n\tunsigned int mixer_insensitive: 1;\n\tstruct snd_kcontrol *mixer_res_ctl[CM_SAVED_MIXERS];\n\tint mixer_res_status[CM_SAVED_MIXERS];\n\n\tstruct cmipci_pcm channel[2];\t \n\n\t \n\tstruct snd_rawmidi *rmidi;\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n\n\tspinlock_t reg_lock;\n\n#ifdef CONFIG_PM_SLEEP\n\tunsigned int saved_regs[0x20];\n\tunsigned char saved_mixers[0x20];\n#endif\n};\n\n\n \nstatic inline void snd_cmipci_write(struct cmipci *cm, unsigned int cmd, unsigned int data)\n{\n\toutl(data, cm->iobase + cmd);\n}\n\nstatic inline unsigned int snd_cmipci_read(struct cmipci *cm, unsigned int cmd)\n{\n\treturn inl(cm->iobase + cmd);\n}\n\n \nstatic inline void snd_cmipci_write_w(struct cmipci *cm, unsigned int cmd, unsigned short data)\n{\n\toutw(data, cm->iobase + cmd);\n}\n\nstatic inline unsigned short snd_cmipci_read_w(struct cmipci *cm, unsigned int cmd)\n{\n\treturn inw(cm->iobase + cmd);\n}\n\n \nstatic inline void snd_cmipci_write_b(struct cmipci *cm, unsigned int cmd, unsigned char data)\n{\n\toutb(data, cm->iobase + cmd);\n}\n\nstatic inline unsigned char snd_cmipci_read_b(struct cmipci *cm, unsigned int cmd)\n{\n\treturn inb(cm->iobase + cmd);\n}\n\n \nstatic int snd_cmipci_set_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)\n{\n\tunsigned int val, oval;\n\tval = oval = inl(cm->iobase + cmd);\n\tval |= flag;\n\tif (val == oval)\n\t\treturn 0;\n\toutl(val, cm->iobase + cmd);\n\treturn 1;\n}\n\nstatic int snd_cmipci_clear_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)\n{\n\tunsigned int val, oval;\n\tval = oval = inl(cm->iobase + cmd);\n\tval &= ~flag;\n\tif (val == oval)\n\t\treturn 0;\n\toutl(val, cm->iobase + cmd);\n\treturn 1;\n}\n\n \nstatic int snd_cmipci_set_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)\n{\n\tunsigned char val, oval;\n\tval = oval = inb(cm->iobase + cmd);\n\tval |= flag;\n\tif (val == oval)\n\t\treturn 0;\n\toutb(val, cm->iobase + cmd);\n\treturn 1;\n}\n\nstatic int snd_cmipci_clear_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)\n{\n\tunsigned char val, oval;\n\tval = oval = inb(cm->iobase + cmd);\n\tval &= ~flag;\n\tif (val == oval)\n\t\treturn 0;\n\toutb(val, cm->iobase + cmd);\n\treturn 1;\n}\n\n\n \n\n \n\nstatic const unsigned int rates[] = { 5512, 11025, 22050, 44100, 8000, 16000, 32000, 48000 };\n\nstatic unsigned int snd_cmipci_rate_freq(unsigned int rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rates); i++) {\n\t\tif (rates[i] == rate)\n\t\t\treturn i;\n\t}\n\tsnd_BUG();\n\treturn 0;\n}\n\n#ifdef USE_VAR48KRATE\n \nstatic int snd_cmipci_pll_rmn(unsigned int rate, unsigned int adcmult, int *r, int *m, int *n)\n{\n\tunsigned int delta, tolerance;\n\tint xm, xn, xr;\n\n\tfor (*r = 0; rate < CM_MAXIMUM_RATE/adcmult; *r += (1<<5))\n\t\trate <<= 1;\n\t*n = -1;\n\tif (*r > 0xff)\n\t\tgoto out;\n\ttolerance = rate*CM_TOLERANCE_RATE;\n\n\tfor (xn = (1+2); xn < (0x1f+2); xn++) {\n\t\tfor (xm = (1+2); xm < (0xff+2); xm++) {\n\t\t\txr = ((CM_REFFREQ_XIN/adcmult) * xm) / xn;\n\n\t\t\tif (xr < rate)\n\t\t\t\tdelta = rate - xr;\n\t\t\telse\n\t\t\t\tdelta = xr - rate;\n\n\t\t\t \n\t\t\tif (delta < tolerance) {\n\t\t\t\ttolerance = delta;\n\t\t\t\t*m = xm - 2;\n\t\t\t\t*n = xn - 2;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn (*n > -1);\n}\n\n \nstatic void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned int slot)\n{\n\tunsigned int reg = CM_REG_PLL + slot;\n\t \n\n\t \n\n\t \n\tsnd_cmipci_write_b(cm, reg, rate>>8);\n\tsnd_cmipci_write_b(cm, reg, rate&0xff);\n\n\t \n}\n#endif  \n\nstatic int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tif (params_channels(hw_params) > 2) {\n\t\tmutex_lock(&cm->open_mutex);\n\t\tif (cm->opened[CM_CH_PLAY]) {\n\t\t\tmutex_unlock(&cm->open_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tcm->opened[CM_CH_PLAY] = CM_OPEN_PLAYBACK_MULTI;\n\t\tmutex_unlock(&cm->open_mutex);\n\t}\n\treturn 0;\n}\n\nstatic void snd_cmipci_ch_reset(struct cmipci *cm, int ch)\n{\n\tint reset = CM_RST_CH0 << (cm->channel[ch].ch);\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);\n\tudelay(10);\n}\n\n\n \n\nstatic const unsigned int hw_channels[] = {1, 2, 4, 6, 8};\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels_4 = {\n\t.count = 3,\n\t.list = hw_channels,\n\t.mask = 0,\n};\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels_6 = {\n\t.count = 4,\n\t.list = hw_channels,\n\t.mask = 0,\n};\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {\n\t.count = 5,\n\t.list = hw_channels,\n\t.mask = 0,\n};\n\nstatic int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int channels)\n{\n\tif (channels > 2) {\n\t\tif (!cm->can_multi_ch || !rec->ch)\n\t\t\treturn -EINVAL;\n\t\tif (rec->fmt != 0x03)  \n\t\t\treturn -EINVAL;\n\t}\n\n\tif (cm->can_multi_ch) {\n\t\tspin_lock_irq(&cm->reg_lock);\n\t\tif (channels > 2) {\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\n\t\t} else {\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\n\t\t}\n\t\tif (channels == 8)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);\n\t\tif (channels == 6) {\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);\n\t\t} else {\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);\n\t\t}\n\t\tif (channels == 4)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);\n\t\tspin_unlock_irq(&cm->reg_lock);\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tunsigned int reg, freq, freq_ext, val;\n\tunsigned int period_size;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\trec->fmt = 0;\n\trec->shift = 0;\n\tif (snd_pcm_format_width(runtime->format) >= 16) {\n\t\trec->fmt |= 0x02;\n\t\tif (snd_pcm_format_width(runtime->format) > 16)\n\t\t\trec->shift++;  \n\t}\n\tif (runtime->channels > 1)\n\t\trec->fmt |= 0x01;\n\tif (rec->is_dac && set_dac_channels(cm, rec, runtime->channels) < 0) {\n\t\tdev_dbg(cm->card->dev, \"cannot set dac channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trec->offset = runtime->dma_addr;\n\t \n\trec->dma_size = runtime->buffer_size << rec->shift;\n\tperiod_size = runtime->period_size << rec->shift;\n\tif (runtime->channels > 2) {\n\t\t \n\t\trec->dma_size = (rec->dma_size * runtime->channels) / 2;\n\t\tperiod_size = (period_size * runtime->channels) / 2;\n\t}\n\n\tspin_lock_irq(&cm->reg_lock);\n\n\t \n\treg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;\n\tsnd_cmipci_write(cm, reg, rec->offset);\n\t \n\treg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\n\tsnd_cmipci_write_w(cm, reg, rec->dma_size - 1);\n\tsnd_cmipci_write_w(cm, reg + 2, period_size - 1);\n\n\t \n\tval = rec->ch ? CM_CHADC1 : CM_CHADC0;\n\tif (rec->is_dac)\n\t\tcm->ctrl &= ~val;\n\telse\n\t\tcm->ctrl |= val;\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\n\t \n\n\t \n\tfreq = 0;\n\tfreq_ext = 0;\n\tif (runtime->rate > 48000)\n\t\tswitch (runtime->rate) {\n\t\tcase 88200:  freq_ext = CM_CH0_SRATE_88K; break;\n\t\tcase 96000:  freq_ext = CM_CH0_SRATE_96K; break;\n\t\tcase 128000: freq_ext = CM_CH0_SRATE_128K; break;\n\t\tdefault:     snd_BUG(); break;\n\t\t}\n\telse\n\t\tfreq = snd_cmipci_rate_freq(runtime->rate);\n\tval = snd_cmipci_read(cm, CM_REG_FUNCTRL1);\n\tif (rec->ch) {\n\t\tval &= ~CM_DSFC_MASK;\n\t\tval |= (freq << CM_DSFC_SHIFT) & CM_DSFC_MASK;\n\t} else {\n\t\tval &= ~CM_ASFC_MASK;\n\t\tval |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;\n\t}\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL1, val);\n\tdev_dbg(cm->card->dev, \"functrl1 = %08x\\n\", val);\n\n\t \n\tval = snd_cmipci_read(cm, CM_REG_CHFORMAT);\n\tif (rec->ch) {\n\t\tval &= ~CM_CH1FMT_MASK;\n\t\tval |= rec->fmt << CM_CH1FMT_SHIFT;\n\t} else {\n\t\tval &= ~CM_CH0FMT_MASK;\n\t\tval |= rec->fmt << CM_CH0FMT_SHIFT;\n\t}\n\tif (cm->can_96k) {\n\t\tval &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));\n\t\tval |= freq_ext << (rec->ch * 2);\n\t}\n\tsnd_cmipci_write(cm, CM_REG_CHFORMAT, val);\n\tdev_dbg(cm->card->dev, \"chformat = %08x\\n\", val);\n\n\tif (!rec->is_dac && cm->chip_version) {\n\t\tif (runtime->rate > 44100)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);\n\t}\n\n\trec->running = 0;\n\tspin_unlock_irq(&cm->reg_lock);\n\n\treturn 0;\n}\n\n \nstatic int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,\n\t\t\t\t  int cmd)\n{\n\tunsigned int inthld, chen, reset, pause;\n\tint result = 0;\n\n\tinthld = CM_CH0_INT_EN << rec->ch;\n\tchen = CM_CHEN0 << rec->ch;\n\treset = CM_RST_CH0 << rec->ch;\n\tpause = CM_PAUSE0 << rec->ch;\n\n\tspin_lock(&cm->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\trec->running = 1;\n\t\t \n\t\tsnd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, inthld);\n\t\tcm->ctrl |= chen;\n\t\t \n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\n\t\tdev_dbg(cm->card->dev, \"functrl0 = %08x\\n\", cm->ctrl);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trec->running = 0;\n\t\t \n\t\tsnd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, inthld);\n\t\t \n\t\tcm->ctrl &= ~chen;\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);\n\t\trec->needs_silencing = rec->is_dac;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tcm->ctrl |= pause;\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tcm->ctrl &= ~pause;\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&cm->reg_lock);\n\treturn result;\n}\n\n \nstatic snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm, struct cmipci_pcm *rec,\n\t\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tsize_t ptr;\n\tunsigned int reg, rem, tries;\n\n\tif (!rec->running)\n\t\treturn 0;\n#if 1  \n\treg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\n\tfor (tries = 0; tries < 3; tries++) {\n\t\trem = snd_cmipci_read_w(cm, reg);\n\t\tif (rem < rec->dma_size)\n\t\t\tgoto ok;\n\t} \n\tdev_err(cm->card->dev, \"invalid PCM pointer: %#x\\n\", rem);\n\treturn SNDRV_PCM_POS_XRUN;\nok:\n\tptr = (rec->dma_size - (rem + 1)) >> rec->shift;\n#else\n\treg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;\n\tptr = snd_cmipci_read(cm, reg) - rec->offset;\n\tptr = bytes_to_frames(substream->runtime, ptr);\n#endif\n\tif (substream->runtime->channels > 2)\n\t\tptr = (ptr * 2) / substream->runtime->channels;\n\treturn ptr;\n}\n\n \n\nstatic int snd_cmipci_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\treturn snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], cmd);\n}\n\nstatic snd_pcm_uframes_t snd_cmipci_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\treturn snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_PLAY], substream);\n}\n\n\n\n \n\nstatic int snd_cmipci_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\treturn snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], cmd);\n}\n\nstatic snd_pcm_uframes_t snd_cmipci_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\treturn snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_CAPT], substream);\n}\n\n\n \n\nstatic int snd_cmipci_spdif_default_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cmipci_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\n\tint i;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tfor (i = 0; i < 4; i++)\n\t\tucontrol->value.iec958.status[i] = (chip->dig_status >> (i * 8)) & 0xff;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\n\tint i, change;\n\tunsigned int val;\n\n\tval = 0;\n\tspin_lock_irq(&chip->reg_lock);\n\tfor (i = 0; i < 4; i++)\n\t\tval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\n\tchange = val != chip->dig_status;\n\tchip->dig_status = val;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_cmipci_spdif_default =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_cmipci_spdif_default_info,\n\t.get =\t\tsnd_cmipci_spdif_default_get,\n\t.put =\t\tsnd_cmipci_spdif_default_put\n};\n\nstatic int snd_cmipci_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_cmipci_spdif_mask =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tsnd_cmipci_spdif_mask_info,\n\t.get =\t\tsnd_cmipci_spdif_mask_get,\n};\n\nstatic int snd_cmipci_spdif_stream_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cmipci_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\n\tint i;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tfor (i = 0; i < 4; i++)\n\t\tucontrol->value.iec958.status[i] = (chip->dig_pcm_status >> (i * 8)) & 0xff;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\n\tint i, change;\n\tunsigned int val;\n\n\tval = 0;\n\tspin_lock_irq(&chip->reg_lock);\n\tfor (i = 0; i < 4; i++)\n\t\tval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\n\tchange = val != chip->dig_pcm_status;\n\tchip->dig_pcm_status = val;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_cmipci_spdif_stream =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_cmipci_spdif_stream_info,\n\t.get =\t\tsnd_cmipci_spdif_stream_get,\n\t.put =\t\tsnd_cmipci_spdif_stream_put\n};\n\n \n\n \nstatic int save_mixer_state(struct cmipci *cm)\n{\n\tif (! cm->mixer_insensitive) {\n\t\tstruct snd_ctl_elem_value *val;\n\t\tunsigned int i;\n\n\t\tval = kmalloc(sizeof(*val), GFP_KERNEL);\n\t\tif (!val)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < CM_SAVED_MIXERS; i++) {\n\t\t\tstruct snd_kcontrol *ctl = cm->mixer_res_ctl[i];\n\t\t\tif (ctl) {\n\t\t\t\tint event;\n\t\t\t\tmemset(val, 0, sizeof(*val));\n\t\t\t\tctl->get(ctl, val);\n\t\t\t\tcm->mixer_res_status[i] = val->value.integer.value[0];\n\t\t\t\tval->value.integer.value[0] = cm_saved_mixer[i].toggle_on;\n\t\t\t\tevent = SNDRV_CTL_EVENT_MASK_INFO;\n\t\t\t\tif (cm->mixer_res_status[i] != val->value.integer.value[0]) {\n\t\t\t\t\tctl->put(ctl, val);  \n\t\t\t\t\tevent |= SNDRV_CTL_EVENT_MASK_VALUE;\n\t\t\t\t}\n\t\t\t\tctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tsnd_ctl_notify(cm->card, event, &ctl->id);\n\t\t\t}\n\t\t}\n\t\tkfree(val);\n\t\tcm->mixer_insensitive = 1;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void restore_mixer_state(struct cmipci *cm)\n{\n\tif (cm->mixer_insensitive) {\n\t\tstruct snd_ctl_elem_value *val;\n\t\tunsigned int i;\n\n\t\tval = kmalloc(sizeof(*val), GFP_KERNEL);\n\t\tif (!val)\n\t\t\treturn;\n\t\tcm->mixer_insensitive = 0;  \n\t\tfor (i = 0; i < CM_SAVED_MIXERS; i++) {\n\t\t\tstruct snd_kcontrol *ctl = cm->mixer_res_ctl[i];\n\t\t\tif (ctl) {\n\t\t\t\tint event;\n\n\t\t\t\tmemset(val, 0, sizeof(*val));\n\t\t\t\tctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\t\tctl->get(ctl, val);\n\t\t\t\tevent = SNDRV_CTL_EVENT_MASK_INFO;\n\t\t\t\tif (val->value.integer.value[0] != cm->mixer_res_status[i]) {\n\t\t\t\t\tval->value.integer.value[0] = cm->mixer_res_status[i];\n\t\t\t\t\tctl->put(ctl, val);\n\t\t\t\t\tevent |= SNDRV_CTL_EVENT_MASK_VALUE;\n\t\t\t\t}\n\t\t\t\tsnd_ctl_notify(cm->card, event, &ctl->id);\n\t\t\t}\n\t\t}\n\t\tkfree(val);\n\t}\n}\n\n \nstatic void setup_ac3(struct cmipci *cm, struct snd_pcm_substream *subs, int do_ac3, int rate)\n{\n\tif (do_ac3) {\n\t\t \n\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);\n\t\t \n\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);\n\t\n\t\tif (cm->can_ac3_hw) {\n\t\t\t \n\t\t\t \n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\t\t} else {  \n\t\t\t \n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\t\t\t \n\t\t\tif (cm->chip_version == 33) {\n\t\t\t\tif (rate >= 48000) {\n\t\t\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\n\t\t\t\t} else {\n\t\t\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);\n\n\t\tif (cm->can_ac3_hw) {\n\t\t\t \n\t\t\tif (snd_pcm_format_width(subs->runtime->format) > 16) {\n\t\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\t\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\n\t\t\t} else {\n\t\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\t\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\n\t\t\t}\n\t\t} else {\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\n\t\t}\n\t}\n}\n\nstatic int setup_spdif_playback(struct cmipci *cm, struct snd_pcm_substream *subs, int up, int do_ac3)\n{\n\tint rate, err;\n\n\trate = subs->runtime->rate;\n\n\tif (up && do_ac3) {\n\t\terr = save_mixer_state(cm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tspin_lock_irq(&cm->reg_lock);\n\tcm->spdif_playback_avail = up;\n\tif (up) {\n\t\t \n\t\t \n\t\t \n\t\tif (cm->spdif_playback_enabled)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\n\t\tsetup_ac3(cm, subs, do_ac3, rate);\n\n\t\tif (rate == 48000 || rate == 96000)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);\n\t\tif (rate > 48000)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\n\t\tsetup_ac3(cm, subs, 0, 0);\n\t}\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\n\n \n\n \nstatic int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tint rate = substream->runtime->rate;\n\tint err, do_spdif, do_ac3 = 0;\n\n\tdo_spdif = (rate >= 44100 && rate <= 96000 &&\n\t\t    substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE &&\n\t\t    substream->runtime->channels == 2);\n\tif (do_spdif && cm->can_ac3_hw) \n\t\tdo_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;\n\terr = setup_spdif_playback(cm, substream, do_spdif, do_ac3);\n\tif (err < 0)\n\t\treturn err;\n\treturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);\n}\n\n \nstatic int snd_cmipci_playback_spdif_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tint err, do_ac3;\n\n\tif (cm->can_ac3_hw) \n\t\tdo_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;\n\telse\n\t\tdo_ac3 = 1;  \n\terr = setup_spdif_playback(cm, substream, 1, do_ac3);\n\tif (err < 0)\n\t\treturn err;\n\treturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);\n}\n\n \nstatic void snd_cmipci_silence_hack(struct cmipci *cm, struct cmipci_pcm *rec)\n{\n\tstruct snd_pcm_runtime *runtime = rec->substream->runtime;\n\tunsigned int reg, val;\n\n\tif (rec->needs_silencing && runtime && runtime->dma_area) {\n\t\t \n\t\tmemset(runtime->dma_area, 0, PAGE_SIZE);\n\t\treg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\n\t\tval = ((PAGE_SIZE / 4) - 1) | (((PAGE_SIZE / 4) / 2 - 1) << 16);\n\t\tsnd_cmipci_write(cm, reg, val);\n\t\n\t\t \n\t\tif (runtime->channels > 2)\n\t\t\tset_dac_channels(cm, rec, 2);\n\t\tspin_lock_irq(&cm->reg_lock);\n\t\tval = snd_cmipci_read(cm, CM_REG_FUNCTRL1);\n\t\tval &= ~(CM_ASFC_MASK << (rec->ch * 3));\n\t\tval |= (4 << CM_ASFC_SHIFT) << (rec->ch * 3);\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL1, val);\n\t\tval = snd_cmipci_read(cm, CM_REG_CHFORMAT);\n\t\tval &= ~(CM_CH0FMT_MASK << (rec->ch * 2));\n\t\tval |= (3 << CM_CH0FMT_SHIFT) << (rec->ch * 2);\n\t\tif (cm->can_96k)\n\t\t\tval &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));\n\t\tsnd_cmipci_write(cm, CM_REG_CHFORMAT, val);\n\t\n\t\t \n\t\tcm->ctrl |= CM_CHEN0 << rec->ch;\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\n\t\tspin_unlock_irq(&cm->reg_lock);\n\n\t\tmsleep(1);\n\n\t\t \n\t\tspin_lock_irq(&cm->reg_lock);\n\t\tcm->ctrl &= ~(CM_CHEN0 << rec->ch);\n\t\tval = CM_RST_CH0 << rec->ch;\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | val);\n\t\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~val);\n\t\tspin_unlock_irq(&cm->reg_lock);\n\n\t\trec->needs_silencing = 0;\n\t}\n}\n\nstatic int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tsetup_spdif_playback(cm, substream, 0, 0);\n\trestore_mixer_state(cm);\n\tsnd_cmipci_silence_hack(cm, &cm->channel[0]);\n\treturn 0;\n}\n\nstatic int snd_cmipci_playback2_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tsnd_cmipci_silence_hack(cm, &cm->channel[1]);\n\treturn 0;\n}\n\n \nstatic int snd_cmipci_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\treturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);\n}\n\n \nstatic int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&cm->reg_lock);\n\tsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);\n\tif (cm->can_96k) {\n\t\tif (substream->runtime->rate > 48000)\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\n\t\telse\n\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\n\t}\n\tif (snd_pcm_format_width(substream->runtime->format) > 16)\n\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\telse\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\n\tspin_unlock_irq(&cm->reg_lock);\n\n\treturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);\n}\n\nstatic int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(subs);\n\n\tspin_lock_irq(&cm->reg_lock);\n\tsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);\n\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\n\tspin_unlock_irq(&cm->reg_lock);\n\n\treturn 0;\n}\n\n\n \nstatic irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id)\n{\n\tstruct cmipci *cm = dev_id;\n\tunsigned int status, mask = 0;\n\t\n\t \n\tstatus = snd_cmipci_read(cm, CM_REG_INT_STATUS);\n\tif (!(status & CM_INTR))\n\t\treturn IRQ_NONE;\n\n\t \n\tspin_lock(&cm->reg_lock);\n\tif (status & CM_CHINT0)\n\t\tmask |= CM_CH0_INT_EN;\n\tif (status & CM_CHINT1)\n\t\tmask |= CM_CH1_INT_EN;\n\tsnd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, mask);\n\tsnd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, mask);\n\tspin_unlock(&cm->reg_lock);\n\n\tif (cm->rmidi && (status & CM_UARTINT))\n\t\tsnd_mpu401_uart_interrupt(irq, cm->rmidi->private_data);\n\n\tif (cm->pcm) {\n\t\tif ((status & CM_CHINT0) && cm->channel[0].running)\n\t\t\tsnd_pcm_period_elapsed(cm->channel[0].substream);\n\t\tif ((status & CM_CHINT1) && cm->channel[1].running)\n\t\t\tsnd_pcm_period_elapsed(cm->channel[1].substream);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic const struct snd_pcm_hardware snd_cmipci_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5512,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_cmipci_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5512,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_cmipci_playback2 =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5512,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_cmipci_playback_spdif =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_cmipci_capture_spdif =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t        SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const unsigned int rate_constraints[] = { 5512, 8000, 11025, 16000, 22050,\n\t\t\t32000, 44100, 48000, 88200, 96000, 128000 };\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t\t.count = ARRAY_SIZE(rate_constraints),\n\t\t.list = rate_constraints,\n\t\t.mask = 0,\n};\n\n \nstatic int open_device_check(struct cmipci *cm, int mode, struct snd_pcm_substream *subs)\n{\n\tint ch = mode & CM_OPEN_CH_MASK;\n\n\t \n\tmutex_lock(&cm->open_mutex);\n\tif (cm->opened[ch]) {\n\t\tmutex_unlock(&cm->open_mutex);\n\t\treturn -EBUSY;\n\t}\n\tcm->opened[ch] = mode;\n\tcm->channel[ch].substream = subs;\n\tif (! (mode & CM_OPEN_DAC)) {\n\t\t \n\t\tcm->channel[ch].is_dac = 0;\n\t\tspin_lock_irq(&cm->reg_lock);\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);\n\t\tspin_unlock_irq(&cm->reg_lock);\n\t}\n\tmutex_unlock(&cm->open_mutex);\n\treturn 0;\n}\n\nstatic void close_device_check(struct cmipci *cm, int mode)\n{\n\tint ch = mode & CM_OPEN_CH_MASK;\n\n\tmutex_lock(&cm->open_mutex);\n\tif (cm->opened[ch] == mode) {\n\t\tif (cm->channel[ch].substream) {\n\t\t\tsnd_cmipci_ch_reset(cm, ch);\n\t\t\tcm->channel[ch].running = 0;\n\t\t\tcm->channel[ch].substream = NULL;\n\t\t}\n\t\tcm->opened[ch] = 0;\n\t\tif (! cm->channel[ch].is_dac) {\n\t\t\t \n\t\t\tcm->channel[ch].is_dac = 1;\n\t\t\tspin_lock_irq(&cm->reg_lock);\n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);\n\t\t\tspin_unlock_irq(&cm->reg_lock);\n\t\t}\n\t}\n\tmutex_unlock(&cm->open_mutex);\n}\n\n \n\nstatic int snd_cmipci_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\terr = open_device_check(cm, CM_OPEN_PLAYBACK, substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime->hw = snd_cmipci_playback;\n\tif (cm->chip_version == 68) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_88200 |\n\t\t\t\t     SNDRV_PCM_RATE_96000;\n\t\truntime->hw.rate_max = 96000;\n\t} else if (cm->chip_version == 55) {\n\t\terr = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\n\t\truntime->hw.rate_max = 128000;\n\t}\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\n\tcm->dig_pcm_status = cm->dig_status;\n\treturn 0;\n}\n\nstatic int snd_cmipci_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\terr = open_device_check(cm, CM_OPEN_CAPTURE, substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime->hw = snd_cmipci_capture;\n\tif (cm->chip_version == 68) {\t\n\t\truntime->hw.rate_min = 41000;\n\t\truntime->hw.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000;\n\t} else if (cm->chip_version == 55) {\n\t\terr = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\n\t\truntime->hw.rate_max = 128000;\n\t}\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\n\treturn 0;\n}\n\nstatic int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n\terr = open_device_check(cm, CM_OPEN_PLAYBACK2, substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime->hw = snd_cmipci_playback2;\n\tmutex_lock(&cm->open_mutex);\n\tif (! cm->opened[CM_CH_PLAY]) {\n\t\tif (cm->can_multi_ch) {\n\t\t\truntime->hw.channels_max = cm->max_channels;\n\t\t\tif (cm->max_channels == 4)\n\t\t\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_4);\n\t\t\telse if (cm->max_channels == 6)\n\t\t\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_6);\n\t\t\telse if (cm->max_channels == 8)\n\t\t\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_8);\n\t\t}\n\t}\n\tmutex_unlock(&cm->open_mutex);\n\tif (cm->chip_version == 68) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_88200 |\n\t\t\t\t     SNDRV_PCM_RATE_96000;\n\t\truntime->hw.rate_max = 96000;\n\t} else if (cm->chip_version == 55) {\n\t\terr = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\n\t\truntime->hw.rate_max = 128000;\n\t}\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\n\treturn 0;\n}\n\nstatic int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n\terr = open_device_check(cm, CM_OPEN_SPDIF_PLAYBACK, substream);\n\tif (err < 0)\n\t\treturn err;\n\tif (cm->can_ac3_hw) {\n\t\truntime->hw = snd_cmipci_playback_spdif;\n\t\tif (cm->chip_version >= 37) {\n\t\t\truntime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\t\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\t\t}\n\t\tif (cm->can_96k) {\n\t\t\truntime->hw.rates |= SNDRV_PCM_RATE_88200 |\n\t\t\t\t\t     SNDRV_PCM_RATE_96000;\n\t\t\truntime->hw.rate_max = 96000;\n\t\t}\n\t} else {\n\t\truntime->hw = snd_cmipci_playback_iec958_subframe;\n\t}\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);\n\tcm->dig_pcm_status = cm->dig_status;\n\treturn 0;\n}\n\nstatic int snd_cmipci_capture_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n\terr = open_device_check(cm, CM_OPEN_SPDIF_CAPTURE, substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime->hw = snd_cmipci_capture_spdif;\n\tif (cm->can_96k && !(cm->chip_version == 68)) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_88200 |\n\t\t\t\t     SNDRV_PCM_RATE_96000;\n\t\truntime->hw.rate_max = 96000;\n\t}\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);\n\treturn 0;\n}\n\n\n \n\nstatic int snd_cmipci_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tclose_device_check(cm, CM_OPEN_PLAYBACK);\n\treturn 0;\n}\n\nstatic int snd_cmipci_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tclose_device_check(cm, CM_OPEN_CAPTURE);\n\treturn 0;\n}\n\nstatic int snd_cmipci_playback2_close(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tclose_device_check(cm, CM_OPEN_PLAYBACK2);\n\tclose_device_check(cm, CM_OPEN_PLAYBACK_MULTI);\n\treturn 0;\n}\n\nstatic int snd_cmipci_playback_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tclose_device_check(cm, CM_OPEN_SPDIF_PLAYBACK);\n\treturn 0;\n}\n\nstatic int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct cmipci *cm = snd_pcm_substream_chip(substream);\n\tclose_device_check(cm, CM_OPEN_SPDIF_CAPTURE);\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_pcm_ops snd_cmipci_playback_ops = {\n\t.open =\t\tsnd_cmipci_playback_open,\n\t.close =\tsnd_cmipci_playback_close,\n\t.hw_free =\tsnd_cmipci_playback_hw_free,\n\t.prepare =\tsnd_cmipci_playback_prepare,\n\t.trigger =\tsnd_cmipci_playback_trigger,\n\t.pointer =\tsnd_cmipci_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cmipci_capture_ops = {\n\t.open =\t\tsnd_cmipci_capture_open,\n\t.close =\tsnd_cmipci_capture_close,\n\t.prepare =\tsnd_cmipci_capture_prepare,\n\t.trigger =\tsnd_cmipci_capture_trigger,\n\t.pointer =\tsnd_cmipci_capture_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cmipci_playback2_ops = {\n\t.open =\t\tsnd_cmipci_playback2_open,\n\t.close =\tsnd_cmipci_playback2_close,\n\t.hw_params =\tsnd_cmipci_playback2_hw_params,\n\t.hw_free =\tsnd_cmipci_playback2_hw_free,\n\t.prepare =\tsnd_cmipci_capture_prepare,\t \n\t.trigger =\tsnd_cmipci_capture_trigger,\t \n\t.pointer =\tsnd_cmipci_capture_pointer,\t \n};\n\nstatic const struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {\n\t.open =\t\tsnd_cmipci_playback_spdif_open,\n\t.close =\tsnd_cmipci_playback_spdif_close,\n\t.hw_free =\tsnd_cmipci_playback_hw_free,\n\t.prepare =\tsnd_cmipci_playback_spdif_prepare,\t \n\t.trigger =\tsnd_cmipci_playback_trigger,\n\t.pointer =\tsnd_cmipci_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {\n\t.open =\t\tsnd_cmipci_capture_spdif_open,\n\t.close =\tsnd_cmipci_capture_spdif_close,\n\t.hw_free =\tsnd_cmipci_capture_spdif_hw_free,\n\t.prepare =\tsnd_cmipci_capture_spdif_prepare,\n\t.trigger =\tsnd_cmipci_capture_trigger,\n\t.pointer =\tsnd_cmipci_capture_pointer,\n};\n\n\n \n\nstatic int snd_cmipci_pcm_new(struct cmipci *cm, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_ops);\n\n\tpcm->private_data = cm;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"C-Media PCI DAC/ADC\");\n\tcm->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &cm->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\nstatic int snd_cmipci_pcm2_new(struct cmipci *cm, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback2_ops);\n\n\tpcm->private_data = cm;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"C-Media PCI 2nd DAC\");\n\tcm->pcm2 = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &cm->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\nstatic int snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_spdif_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_spdif_ops);\n\n\tpcm->private_data = cm;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"C-Media PCI IEC958\");\n\tcm->pcm_spdif = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &cm->pci->dev, 64*1024, 128*1024);\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps, cm->max_channels, 0,\n\t\t\t\t     NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic void snd_cmipci_mixer_write(struct cmipci *s, unsigned char idx, unsigned char data)\n{\n\toutb(idx, s->iobase + CM_REG_SB16_ADDR);\n\toutb(data, s->iobase + CM_REG_SB16_DATA);\n}\n\nstatic unsigned char snd_cmipci_mixer_read(struct cmipci *s, unsigned char idx)\n{\n\tunsigned char v;\n\n\toutb(idx, s->iobase + CM_REG_SB16_ADDR);\n\tv = inb(s->iobase + CM_REG_SB16_DATA);\n\treturn v;\n}\n\n \nstruct cmipci_sb_reg {\n\tunsigned int left_reg, right_reg;\n\tunsigned int left_shift, right_shift;\n\tunsigned int mask;\n\tunsigned int invert: 1;\n\tunsigned int stereo: 1;\n};\n\n#define COMPOSE_SB_REG(lreg,rreg,lshift,rshift,mask,invert,stereo) \\\n ((lreg) | ((rreg) << 8) | (lshift << 16) | (rshift << 19) | (mask << 24) | (invert << 22) | (stereo << 23))\n\n#define CMIPCI_DOUBLE(xname, left_reg, right_reg, left_shift, right_shift, mask, invert, stereo) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_volume, \\\n  .get = snd_cmipci_get_volume, .put = snd_cmipci_put_volume, \\\n  .private_value = COMPOSE_SB_REG(left_reg, right_reg, left_shift, right_shift, mask, invert, stereo), \\\n}\n\n#define CMIPCI_SB_VOL_STEREO(xname,reg,shift,mask) CMIPCI_DOUBLE(xname, reg, reg+1, shift, shift, mask, 0, 1)\n#define CMIPCI_SB_VOL_MONO(xname,reg,shift,mask) CMIPCI_DOUBLE(xname, reg, reg, shift, shift, mask, 0, 0)\n#define CMIPCI_SB_SW_STEREO(xname,lshift,rshift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, lshift, rshift, 1, 0, 1)\n#define CMIPCI_SB_SW_MONO(xname,shift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, shift, shift, 1, 0, 0)\n\nstatic void cmipci_sb_reg_decode(struct cmipci_sb_reg *r, unsigned long val)\n{\n\tr->left_reg = val & 0xff;\n\tr->right_reg = (val >> 8) & 0xff;\n\tr->left_shift = (val >> 16) & 0x07;\n\tr->right_shift = (val >> 19) & 0x07;\n\tr->invert = (val >> 22) & 1;\n\tr->stereo = (val >> 23) & 1;\n\tr->mask = (val >> 24) & 0xff;\n}\n\nstatic int snd_cmipci_info_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct cmipci_sb_reg reg;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tuinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = reg.stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = reg.mask;\n\treturn 0;\n}\n \nstatic int snd_cmipci_get_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tint val;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tspin_lock_irq(&cm->reg_lock);\n\tval = (snd_cmipci_mixer_read(cm, reg.left_reg) >> reg.left_shift) & reg.mask;\n\tif (reg.invert)\n\t\tval = reg.mask - val;\n\tucontrol->value.integer.value[0] = val;\n\tif (reg.stereo) {\n\t\tval = (snd_cmipci_mixer_read(cm, reg.right_reg) >> reg.right_shift) & reg.mask;\n\t\tif (reg.invert)\n\t\t\tval = reg.mask - val;\n\t\tucontrol->value.integer.value[1] = val;\n\t}\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_put_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tint change;\n\tint left, right, oleft, oright;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tleft = ucontrol->value.integer.value[0] & reg.mask;\n\tif (reg.invert)\n\t\tleft = reg.mask - left;\n\tleft <<= reg.left_shift;\n\tif (reg.stereo) {\n\t\tright = ucontrol->value.integer.value[1] & reg.mask;\n\t\tif (reg.invert)\n\t\t\tright = reg.mask - right;\n\t\tright <<= reg.right_shift;\n\t} else\n\t\tright = 0;\n\tspin_lock_irq(&cm->reg_lock);\n\toleft = snd_cmipci_mixer_read(cm, reg.left_reg);\n\tleft |= oleft & ~(reg.mask << reg.left_shift);\n\tchange = left != oleft;\n\tif (reg.stereo) {\n\t\tif (reg.left_reg != reg.right_reg) {\n\t\t\tsnd_cmipci_mixer_write(cm, reg.left_reg, left);\n\t\t\toright = snd_cmipci_mixer_read(cm, reg.right_reg);\n\t\t} else\n\t\t\toright = left;\n\t\tright |= oright & ~(reg.mask << reg.right_shift);\n\t\tchange |= right != oright;\n\t\tsnd_cmipci_mixer_write(cm, reg.right_reg, right);\n\t} else\n\t\tsnd_cmipci_mixer_write(cm, reg.left_reg, left);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn change;\n}\n\n \n#define CMIPCI_SB_INPUT_SW(xname, left_shift, right_shift) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_input_sw, \\\n  .get = snd_cmipci_get_input_sw, .put = snd_cmipci_put_input_sw, \\\n  .private_value = COMPOSE_SB_REG(SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, left_shift, right_shift, 1, 0, 1), \\\n}\n\nstatic int snd_cmipci_info_input_sw(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n \nstatic int snd_cmipci_get_input_sw(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tint val1, val2;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tspin_lock_irq(&cm->reg_lock);\n\tval1 = snd_cmipci_mixer_read(cm, reg.left_reg);\n\tval2 = snd_cmipci_mixer_read(cm, reg.right_reg);\n\tspin_unlock_irq(&cm->reg_lock);\n\tucontrol->value.integer.value[0] = (val1 >> reg.left_shift) & 1;\n\tucontrol->value.integer.value[1] = (val2 >> reg.left_shift) & 1;\n\tucontrol->value.integer.value[2] = (val1 >> reg.right_shift) & 1;\n\tucontrol->value.integer.value[3] = (val2 >> reg.right_shift) & 1;\n\treturn 0;\n}\n\nstatic int snd_cmipci_put_input_sw(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tint change;\n\tint val1, val2, oval1, oval2;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tspin_lock_irq(&cm->reg_lock);\n\toval1 = snd_cmipci_mixer_read(cm, reg.left_reg);\n\toval2 = snd_cmipci_mixer_read(cm, reg.right_reg);\n\tval1 = oval1 & ~((1 << reg.left_shift) | (1 << reg.right_shift));\n\tval2 = oval2 & ~((1 << reg.left_shift) | (1 << reg.right_shift));\n\tval1 |= (ucontrol->value.integer.value[0] & 1) << reg.left_shift;\n\tval2 |= (ucontrol->value.integer.value[1] & 1) << reg.left_shift;\n\tval1 |= (ucontrol->value.integer.value[2] & 1) << reg.right_shift;\n\tval2 |= (ucontrol->value.integer.value[3] & 1) << reg.right_shift;\n\tchange = val1 != oval1 || val2 != oval2;\n\tsnd_cmipci_mixer_write(cm, reg.left_reg, val1);\n\tsnd_cmipci_mixer_write(cm, reg.right_reg, val2);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn change;\n}\n\n \n\n#define CMIPCI_MIXER_SW_STEREO(xname, reg, lshift, rshift, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_native_mixer, \\\n  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \\\n  .private_value = COMPOSE_SB_REG(reg, reg, lshift, rshift, 1, invert, 1), \\\n}\n\n#define CMIPCI_MIXER_SW_MONO(xname, reg, shift, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_native_mixer, \\\n  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \\\n  .private_value = COMPOSE_SB_REG(reg, reg, shift, shift, 1, invert, 0), \\\n}\n\n#define CMIPCI_MIXER_VOL_STEREO(xname, reg, lshift, rshift, mask) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_native_mixer, \\\n  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \\\n  .private_value = COMPOSE_SB_REG(reg, reg, lshift, rshift, mask, 0, 1), \\\n}\n\n#define CMIPCI_MIXER_VOL_MONO(xname, reg, shift, mask) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n  .info = snd_cmipci_info_native_mixer, \\\n  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \\\n  .private_value = COMPOSE_SB_REG(reg, reg, shift, shift, mask, 0, 0), \\\n}\n\nstatic int snd_cmipci_info_native_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct cmipci_sb_reg reg;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tuinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = reg.stereo + 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = reg.mask;\n\treturn 0;\n\n}\n\nstatic int snd_cmipci_get_native_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tunsigned char oreg, val;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tspin_lock_irq(&cm->reg_lock);\n\toreg = inb(cm->iobase + reg.left_reg);\n\tval = (oreg >> reg.left_shift) & reg.mask;\n\tif (reg.invert)\n\t\tval = reg.mask - val;\n\tucontrol->value.integer.value[0] = val;\n\tif (reg.stereo) {\n\t\tval = (oreg >> reg.right_shift) & reg.mask;\n\t\tif (reg.invert)\n\t\t\tval = reg.mask - val;\n\t\tucontrol->value.integer.value[1] = val;\n\t}\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_put_native_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstruct cmipci_sb_reg reg;\n\tunsigned char oreg, nreg, val;\n\n\tcmipci_sb_reg_decode(&reg, kcontrol->private_value);\n\tspin_lock_irq(&cm->reg_lock);\n\toreg = inb(cm->iobase + reg.left_reg);\n\tval = ucontrol->value.integer.value[0] & reg.mask;\n\tif (reg.invert)\n\t\tval = reg.mask - val;\n\tnreg = oreg & ~(reg.mask << reg.left_shift);\n\tnreg |= (val << reg.left_shift);\n\tif (reg.stereo) {\n\t\tval = ucontrol->value.integer.value[1] & reg.mask;\n\t\tif (reg.invert)\n\t\t\tval = reg.mask - val;\n\t\tnreg &= ~(reg.mask << reg.right_shift);\n\t\tnreg |= (val << reg.right_shift);\n\t}\n\toutb(nreg, cm->iobase + reg.left_reg);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn (nreg != oreg);\n}\n\n \nstatic int snd_cmipci_get_native_mixer_sensitive(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\t\n\treturn snd_cmipci_get_native_mixer(kcontrol, ucontrol);\n}\n\nstatic int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tif (cm->mixer_insensitive) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn snd_cmipci_put_native_mixer(kcontrol, ucontrol);\n}\n\n\nstatic const struct snd_kcontrol_new snd_cmipci_mixers[] = {\n\tCMIPCI_SB_VOL_STEREO(\"Master Playback Volume\", SB_DSP4_MASTER_DEV, 3, 31),\n\tCMIPCI_MIXER_SW_MONO(\"3D Control - Switch\", CM_REG_MIXER1, CM_X3DEN_SHIFT, 0),\n\tCMIPCI_SB_VOL_STEREO(\"PCM Playback Volume\", SB_DSP4_PCM_DEV, 3, 31),\n\t\n\t{  \n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Switch\",\n\t\t.info = snd_cmipci_info_native_mixer,\n\t\t.get = snd_cmipci_get_native_mixer_sensitive,\n\t\t.put = snd_cmipci_put_native_mixer_sensitive,\n\t\t.private_value = COMPOSE_SB_REG(CM_REG_MIXER1, CM_REG_MIXER1, CM_WSMUTE_SHIFT, CM_WSMUTE_SHIFT, 1, 1, 0),\n\t},\n\tCMIPCI_MIXER_SW_STEREO(\"PCM Capture Switch\", CM_REG_MIXER1, CM_WAVEINL_SHIFT, CM_WAVEINR_SHIFT, 0),\n\tCMIPCI_SB_VOL_STEREO(\"Synth Playback Volume\", SB_DSP4_SYNTH_DEV, 3, 31),\n\tCMIPCI_MIXER_SW_MONO(\"Synth Playback Switch\", CM_REG_MIXER1, CM_FMMUTE_SHIFT, 1),\n\tCMIPCI_SB_INPUT_SW(\"Synth Capture Route\", 6, 5),\n\tCMIPCI_SB_VOL_STEREO(\"CD Playback Volume\", SB_DSP4_CD_DEV, 3, 31),\n\tCMIPCI_SB_SW_STEREO(\"CD Playback Switch\", 2, 1),\n\tCMIPCI_SB_INPUT_SW(\"CD Capture Route\", 2, 1),\n\tCMIPCI_SB_VOL_STEREO(\"Line Playback Volume\", SB_DSP4_LINE_DEV, 3, 31),\n\tCMIPCI_SB_SW_STEREO(\"Line Playback Switch\", 4, 3),\n\tCMIPCI_SB_INPUT_SW(\"Line Capture Route\", 4, 3),\n\tCMIPCI_SB_VOL_MONO(\"Mic Playback Volume\", SB_DSP4_MIC_DEV, 3, 31),\n\tCMIPCI_SB_SW_MONO(\"Mic Playback Switch\", 0),\n\tCMIPCI_DOUBLE(\"Mic Capture Switch\", SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 0, 0, 1, 0, 0),\n\tCMIPCI_SB_VOL_MONO(\"Beep Playback Volume\", SB_DSP4_SPEAKER_DEV, 6, 3),\n\tCMIPCI_MIXER_VOL_STEREO(\"Aux Playback Volume\", CM_REG_AUX_VOL, 4, 0, 15),\n\tCMIPCI_MIXER_SW_STEREO(\"Aux Playback Switch\", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 0),\n\tCMIPCI_MIXER_SW_STEREO(\"Aux Capture Switch\", CM_REG_MIXER2, CM_RAUXLEN_SHIFT, CM_RAUXREN_SHIFT, 0),\n\tCMIPCI_MIXER_SW_MONO(\"Mic Boost Playback Switch\", CM_REG_MIXER2, CM_MICGAINZ_SHIFT, 1),\n\tCMIPCI_MIXER_VOL_MONO(\"Mic Capture Volume\", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),\n\tCMIPCI_SB_VOL_MONO(\"Phone Playback Volume\", CM_REG_EXTENT_IND, 5, 7),\n\tCMIPCI_DOUBLE(\"Phone Playback Switch\", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 4, 4, 1, 0, 0),\n\tCMIPCI_DOUBLE(\"Beep Playback Switch\", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),\n\tCMIPCI_DOUBLE(\"Mic Boost Capture Switch\", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 0, 0, 1, 0, 0),\n};\n\n \n\nstruct cmipci_switch_args {\n\tint reg;\t\t \n\tunsigned int mask;\t \n\tunsigned int mask_on;\t \n\tunsigned int is_byte: 1;\t\t \n\tunsigned int ac3_sensitive: 1;\t \n};\n\n#define snd_cmipci_uswitch_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int _snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t   struct cmipci_switch_args *args)\n{\n\tunsigned int val;\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&cm->reg_lock);\n\tif (args->ac3_sensitive && cm->mixer_insensitive) {\n\t\tucontrol->value.integer.value[0] = 0;\n\t\tspin_unlock_irq(&cm->reg_lock);\n\t\treturn 0;\n\t}\n\tif (args->is_byte)\n\t\tval = inb(cm->iobase + args->reg);\n\telse\n\t\tval = snd_cmipci_read(cm, args->reg);\n\tucontrol->value.integer.value[0] = ((val & args->mask) == args->mask_on) ? 1 : 0;\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci_switch_args *args;\n\targs = (struct cmipci_switch_args *)kcontrol->private_value;\n\tif (snd_BUG_ON(!args))\n\t\treturn -EINVAL;\n\treturn _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);\n}\n\nstatic int _snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t   struct cmipci_switch_args *args)\n{\n\tunsigned int val;\n\tint change;\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&cm->reg_lock);\n\tif (args->ac3_sensitive && cm->mixer_insensitive) {\n\t\t \n\t\tspin_unlock_irq(&cm->reg_lock);\n\t\treturn 0;\n\t}\n\tif (args->is_byte)\n\t\tval = inb(cm->iobase + args->reg);\n\telse\n\t\tval = snd_cmipci_read(cm, args->reg);\n\tchange = (val & args->mask) != (ucontrol->value.integer.value[0] ? \n\t\t\targs->mask_on : (args->mask & ~args->mask_on));\n\tif (change) {\n\t\tval &= ~args->mask;\n\t\tif (ucontrol->value.integer.value[0])\n\t\t\tval |= args->mask_on;\n\t\telse\n\t\t\tval |= (args->mask & ~args->mask_on);\n\t\tif (args->is_byte)\n\t\t\toutb((unsigned char)val, cm->iobase + args->reg);\n\t\telse\n\t\t\tsnd_cmipci_write(cm, args->reg, val);\n\t}\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn change;\n}\n\nstatic int snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci_switch_args *args;\n\targs = (struct cmipci_switch_args *)kcontrol->private_value;\n\tif (snd_BUG_ON(!args))\n\t\treturn -EINVAL;\n\treturn _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);\n}\n\n#define DEFINE_SWITCH_ARG(sname, xreg, xmask, xmask_on, xis_byte, xac3) \\\nstatic struct cmipci_switch_args cmipci_switch_arg_##sname = { \\\n  .reg = xreg, \\\n  .mask = xmask, \\\n  .mask_on = xmask_on, \\\n  .is_byte = xis_byte, \\\n  .ac3_sensitive = xac3, \\\n}\n\t\n#define DEFINE_BIT_SWITCH_ARG(sname, xreg, xmask, xis_byte, xac3) \\\n\tDEFINE_SWITCH_ARG(sname, xreg, xmask, xmask, xis_byte, xac3)\n\n#if 0  \nDEFINE_BIT_SWITCH_ARG(spdif_in, CM_REG_FUNCTRL1, CM_SPDF_1, 0, 0);\nDEFINE_BIT_SWITCH_ARG(spdif_out, CM_REG_FUNCTRL1, CM_SPDF_0, 0, 0);\n#endif\nDEFINE_BIT_SWITCH_ARG(spdif_in_sel1, CM_REG_CHFORMAT, CM_SPDIF_SELECT1, 0, 0);\nDEFINE_BIT_SWITCH_ARG(spdif_in_sel2, CM_REG_MISC_CTRL, CM_SPDIF_SELECT2, 0, 0);\nDEFINE_BIT_SWITCH_ARG(spdif_enable, CM_REG_LEGACY_CTRL, CM_ENSPDOUT, 0, 0);\nDEFINE_BIT_SWITCH_ARG(spdo2dac, CM_REG_FUNCTRL1, CM_SPDO2DAC, 0, 1);\nDEFINE_BIT_SWITCH_ARG(spdi_valid, CM_REG_MISC, CM_SPDVALID, 1, 0);\nDEFINE_BIT_SWITCH_ARG(spdif_copyright, CM_REG_LEGACY_CTRL, CM_SPDCOPYRHT, 0, 0);\nDEFINE_BIT_SWITCH_ARG(spdif_dac_out, CM_REG_LEGACY_CTRL, CM_DAC2SPDO, 0, 1);\nDEFINE_SWITCH_ARG(spdo_5v, CM_REG_MISC_CTRL, CM_SPDO5V, 0, 0, 0);  \n\nDEFINE_BIT_SWITCH_ARG(spdif_loop, CM_REG_FUNCTRL1, CM_SPDFLOOP, 0, 1);\nDEFINE_BIT_SWITCH_ARG(spdi_monitor, CM_REG_MIXER1, CM_CDPLAY, 1, 0);\n \nDEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_MISC, CM_SPDIF_INVERSE, 1, 0);\nDEFINE_BIT_SWITCH_ARG(spdi_phase2, CM_REG_CHFORMAT, CM_SPDIF_INVERSE2, 0, 0);\n#if CM_CH_PLAY == 1\nDEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, 0, 0, 0);  \n#else\nDEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, CM_XCHGDAC, 0, 0);\n#endif\nDEFINE_BIT_SWITCH_ARG(fourch, CM_REG_MISC_CTRL, CM_N4SPK3D, 0, 0);\n\n\n\nDEFINE_SWITCH_ARG(modem, CM_REG_MISC_CTRL, CM_FLINKON|CM_FLINKOFF, CM_FLINKON, 0, 0);\n\n#define DEFINE_SWITCH(sname, stype, sarg) \\\n{ .name = sname, \\\n  .iface = stype, \\\n  .info = snd_cmipci_uswitch_info, \\\n  .get = snd_cmipci_uswitch_get, \\\n  .put = snd_cmipci_uswitch_put, \\\n  .private_value = (unsigned long)&cmipci_switch_arg_##sarg,\\\n}\n\n#define DEFINE_CARD_SWITCH(sname, sarg) DEFINE_SWITCH(sname, SNDRV_CTL_ELEM_IFACE_CARD, sarg)\n#define DEFINE_MIXER_SWITCH(sname, sarg) DEFINE_SWITCH(sname, SNDRV_CTL_ELEM_IFACE_MIXER, sarg)\n\n\n \nstatic int snd_cmipci_spdout_enable_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint changed;\n\tchanged = _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);\n\tchanged |= _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);\n\treturn changed;\n}\n\nstatic int snd_cmipci_spdout_enable_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\n\tint changed;\n\tchanged = _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);\n\tchanged |= _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);\n\tif (changed) {\n\t\tif (ucontrol->value.integer.value[0]) {\n\t\t\tif (chip->spdif_playback_avail)\n\t\t\t\tsnd_cmipci_set_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\n\t\t} else {\n\t\t\tif (chip->spdif_playback_avail)\n\t\t\t\tsnd_cmipci_clear_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\n\t\t}\n\t}\n\tchip->spdif_playback_enabled = ucontrol->value.integer.value[0];\n\treturn changed;\n}\n\n\nstatic int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tstatic const char *const texts[3] = {\n\t\t\"Line-In\", \"Rear Output\", \"Bass Output\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t cm->chip_version >= 39 ? 3 : 2, texts);\n}\n\nstatic inline unsigned int get_line_in_mode(struct cmipci *cm)\n{\n\tunsigned int val;\n\tif (cm->chip_version >= 39) {\n\t\tval = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL);\n\t\tif (val & (CM_CENTR2LIN | CM_BASE2LIN))\n\t\t\treturn 2;\n\t}\n\tval = snd_cmipci_read_b(cm, CM_REG_MIXER1);\n\tif (val & CM_REAR2LIN)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int snd_cmipci_line_in_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&cm->reg_lock);\n\tucontrol->value.enumerated.item[0] = get_line_in_mode(cm);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\n\tspin_lock_irq(&cm->reg_lock);\n\tif (ucontrol->value.enumerated.item[0] == 2)\n\t\tchange = snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);\n\telse\n\t\tchange = snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);\n\tif (ucontrol->value.enumerated.item[0] == 1)\n\t\tchange |= snd_cmipci_set_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);\n\telse\n\t\tchange |= snd_cmipci_clear_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn change;\n}\n\nstatic int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[2] = { \"Mic-In\", \"Center/LFE Output\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_cmipci_mic_in_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\t \n\tspin_lock_irq(&cm->reg_lock);\n\tucontrol->value.enumerated.item[0] = \n\t\t(snd_cmipci_read_b(cm, CM_REG_MISC) & CM_SPDIF_INVERSE) ? 1 : 0;\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\n\tspin_lock_irq(&cm->reg_lock);\n\tif (ucontrol->value.enumerated.item[0])\n\t\tchange = snd_cmipci_set_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);\n\telse\n\t\tchange = snd_cmipci_clear_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);\n\tspin_unlock_irq(&cm->reg_lock);\n\treturn change;\n}\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_mixer_switches[] = {\n\tDEFINE_MIXER_SWITCH(\"Four Channel Mode\", fourch),\n\t{\n\t\t.name = \"Line-In Mode\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = snd_cmipci_line_in_mode_info,\n\t\t.get = snd_cmipci_line_in_mode_get,\n\t\t.put = snd_cmipci_line_in_mode_put,\n\t},\n};\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_nomulti_switch =\nDEFINE_MIXER_SWITCH(\"Exchange DAC\", exchange_dac);\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] = {\n#if 0  \n\tDEFINE_MIXER_SWITCH(\"IEC958 In Record\", spdif_in),\n\tDEFINE_MIXER_SWITCH(\"IEC958 Out\", spdif_out),\n\tDEFINE_MIXER_SWITCH(\"IEC958 Out To DAC\", spdo2dac),\n#endif\n\t\n\t{ .name = \"IEC958 Output Switch\",\n\t  .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t  .info = snd_cmipci_uswitch_info,\n\t  .get = snd_cmipci_spdout_enable_get,\n\t  .put = snd_cmipci_spdout_enable_put,\n\t},\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Valid\", spdi_valid),\n\tDEFINE_MIXER_SWITCH(\"IEC958 Copyright\", spdif_copyright),\n\tDEFINE_MIXER_SWITCH(\"IEC958 5V\", spdo_5v),\n\n\tDEFINE_MIXER_SWITCH(\"IEC958 Loop\", spdif_loop),\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Monitor\", spdi_monitor),\n};\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] = {\n\tDEFINE_MIXER_SWITCH(\"IEC958 Mix Analog\", spdif_dac_out),\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Phase Inverse\", spdi_phase),\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Select\", spdif_in_sel1),\n};\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] = {\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Select\", spdif_in_sel2),\n\tDEFINE_MIXER_SWITCH(\"IEC958 In Phase Inverse\", spdi_phase2),\n\t{\n\t\t.name = \"Mic-In Mode\",\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.info = snd_cmipci_mic_in_mode_info,\n\t\t.get = snd_cmipci_mic_in_mode_get,\n\t\t.put = snd_cmipci_mic_in_mode_put,\n\t}\n};\n\n \nstatic const struct snd_kcontrol_new snd_cmipci_modem_switch =\nDEFINE_CARD_SWITCH(\"Modem\", modem);\n\n\nstatic int snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)\n{\n\tstruct snd_card *card;\n\tconst struct snd_kcontrol_new *sw;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!cm || !cm->card))\n\t\treturn -EINVAL;\n\n\tcard = cm->card;\n\n\tstrcpy(card->mixername, \"CMedia PCI\");\n\n\tspin_lock_irq(&cm->reg_lock);\n\tsnd_cmipci_mixer_write(cm, 0x00, 0x00);\t\t \n\tspin_unlock_irq(&cm->reg_lock);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixers); idx++) {\n\t\tif (cm->chip_version == 68) {\t\n\t\t\tif (!strcmp(snd_cmipci_mixers[idx].name,\n\t\t\t\t\"PCM Playback Volume\"))\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cmipci_mixers[idx], cm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tsw = snd_cmipci_mixer_switches;\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixer_switches); idx++, sw++) {\n\t\terr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (! cm->can_multi_ch) {\n\t\terr = snd_ctl_add(cm->card, snd_ctl_new1(&snd_cmipci_nomulti_switch, cm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (cm->device == PCI_DEVICE_ID_CMEDIA_CM8738 ||\n\t    cm->device == PCI_DEVICE_ID_CMEDIA_CM8738B) {\n\t\tsw = snd_cmipci_8738_mixer_switches;\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_8738_mixer_switches); idx++, sw++) {\n\t\t\terr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (cm->can_ac3_hw) {\n\t\t\tkctl = snd_ctl_new1(&snd_cmipci_spdif_default, cm);\n\t\t\tkctl->id.device = pcm_spdif_device;\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tkctl = snd_ctl_new1(&snd_cmipci_spdif_mask, cm);\n\t\t\tkctl->id.device = pcm_spdif_device;\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tkctl = snd_ctl_new1(&snd_cmipci_spdif_stream, cm);\n\t\t\tkctl->id.device = pcm_spdif_device;\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (cm->chip_version <= 37) {\n\t\t\tsw = snd_cmipci_old_mixer_switches;\n\t\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_old_mixer_switches); idx++, sw++) {\n\t\t\t\terr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\tif (cm->chip_version >= 39) {\n\t\tsw = snd_cmipci_extra_mixer_switches;\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_extra_mixer_switches); idx++, sw++) {\n\t\t\terr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\t \n\tif (cm->chip_version < 39) {\n\t\terr = snd_ctl_add(cm->card,\n\t\t\t\t  snd_ctl_new1(&snd_cmipci_modem_switch, cm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (idx = 0; idx < CM_SAVED_MIXERS; idx++) {\n\t\tstruct snd_kcontrol *ctl;\n\t\tctl = snd_ctl_find_id_mixer(cm->card, cm_saved_mixer[idx].name);\n\t\tif (ctl)\n\t\t\tcm->mixer_res_ctl[idx] = ctl;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic void snd_cmipci_proc_read(struct snd_info_entry *entry, \n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct cmipci *cm = entry->private_data;\n\tint i, v;\n\t\n\tsnd_iprintf(buffer, \"%s\\n\", cm->card->longname);\n\tfor (i = 0; i < 0x94; i++) {\n\t\tif (i == 0x28)\n\t\t\ti = 0x90;\n\t\tv = inb(cm->iobase + i);\n\t\tif (i % 4 == 0)\n\t\t\tsnd_iprintf(buffer, \"\\n%02x:\", i);\n\t\tsnd_iprintf(buffer, \" %02x\", v);\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void snd_cmipci_proc_init(struct cmipci *cm)\n{\n\tsnd_card_ro_proc_new(cm->card, \"cmipci\", cm, snd_cmipci_proc_read);\n}\n\nstatic const struct pci_device_id snd_cmipci_ids[] = {\n\t{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A), 0},\n\t{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B), 0},\n\t{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738), 0},\n\t{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B), 0},\n\t{PCI_VDEVICE(AL, PCI_DEVICE_ID_CMEDIA_CM8738), 0},\n\t{0,},\n};\n\n\n \nstatic void query_chip(struct cmipci *cm)\n{\n\tunsigned int detect;\n\n\t \n\tdetect = snd_cmipci_read(cm, CM_REG_INT_HLDCLR) & CM_CHIP_MASK2;\n\tif (! detect) {\n\t\t \n\t\tdetect = snd_cmipci_read(cm, CM_REG_CHFORMAT) & CM_CHIP_MASK1;\n\t\tswitch (detect) {\n\t\tcase 0:\n\t\t\tcm->chip_version = 33;\n\t\t\tif (cm->do_soft_ac3)\n\t\t\t\tcm->can_ac3_sw = 1;\n\t\t\telse\n\t\t\t\tcm->can_ac3_hw = 1;\n\t\t\tbreak;\n\t\tcase CM_CHIP_037:\n\t\t\tcm->chip_version = 37;\n\t\t\tcm->can_ac3_hw = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcm->chip_version = 39;\n\t\t\tcm->can_ac3_hw = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcm->max_channels = 2;\n\t} else {\n\t\tif (detect & CM_CHIP_039) {\n\t\t\tcm->chip_version = 39;\n\t\t\tif (detect & CM_CHIP_039_6CH)  \n\t\t\t\tcm->max_channels = 6;\n\t\t\telse\n\t\t\t\tcm->max_channels = 4;\n\t\t} else if (detect & CM_CHIP_8768) {\n\t\t\tcm->chip_version = 68;\n\t\t\tcm->max_channels = 8;\n\t\t\tcm->can_96k = 1;\n\t\t} else {\n\t\t\tcm->chip_version = 55;\n\t\t\tcm->max_channels = 6;\n\t\t\tcm->can_96k = 1;\n\t\t}\n\t\tcm->can_ac3_hw = 1;\n\t\tcm->can_multi_ch = 1;\n\t}\n}\n\n#ifdef SUPPORT_JOYSTICK\nstatic int snd_cmipci_create_gameport(struct cmipci *cm, int dev)\n{\n\tstatic const int ports[] = { 0x201, 0x200, 0 };  \n\tstruct gameport *gp;\n\tstruct resource *r = NULL;\n\tint i, io_port = 0;\n\n\tif (joystick_port[dev] == 0)\n\t\treturn -ENODEV;\n\n\tif (joystick_port[dev] == 1) {  \n\t\tfor (i = 0; ports[i]; i++) {\n\t\t\tio_port = ports[i];\n\t\t\tr = devm_request_region(&cm->pci->dev, io_port, 1,\n\t\t\t\t\t\t\"CMIPCI gameport\");\n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tio_port = joystick_port[dev];\n\t\tr = devm_request_region(&cm->pci->dev, io_port, 1,\n\t\t\t\t\t\"CMIPCI gameport\");\n\t}\n\n\tif (!r) {\n\t\tdev_warn(cm->card->dev, \"cannot reserve joystick ports\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcm->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(cm->card->dev, \"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tgameport_set_name(gp, \"C-Media Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(cm->pci));\n\tgameport_set_dev_parent(gp, &cm->pci->dev);\n\tgp->io = io_port;\n\n\tsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\n\n\tgameport_register_port(cm->gameport);\n\n\treturn 0;\n}\n\nstatic void snd_cmipci_free_gameport(struct cmipci *cm)\n{\n\tif (cm->gameport) {\n\t\tgameport_unregister_port(cm->gameport);\n\t\tcm->gameport = NULL;\n\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\n\t}\n}\n#else\nstatic inline int snd_cmipci_create_gameport(struct cmipci *cm, int dev) { return -ENOSYS; }\nstatic inline void snd_cmipci_free_gameport(struct cmipci *cm) { }\n#endif\n\nstatic void snd_cmipci_free(struct snd_card *card)\n{\n\tstruct cmipci *cm = card->private_data;\n\n\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\n\tsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT);\n\tsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);   \n\tsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\n\tsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, 0);  \n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);\n\n\t \n\tsnd_cmipci_mixer_write(cm, 0, 0);\n\n\tsnd_cmipci_free_gameport(cm);\n}\n\nstatic int snd_cmipci_create_fm(struct cmipci *cm, long fm_port)\n{\n\tlong iosynth;\n\tunsigned int val;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\tif (!fm_port)\n\t\tgoto disable_fm;\n\n\tif (cm->chip_version >= 39) {\n\t\t \n\t\tiosynth = cm->iobase + CM_REG_FM_PCI;\n\t\terr = snd_opl3_create(cm->card, iosynth, iosynth + 2,\n\t\t\t\t      OPL3_HW_OPL3, 1, &opl3);\n\t} else {\n\t\terr = -EIO;\n\t}\n\tif (err < 0) {\n\t\t \n\t\tval = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;\n\t\tiosynth = fm_port;\n\t\tswitch (iosynth) {\n\t\tcase 0x3E8: val |= CM_FMSEL_3E8; break;\n\t\tcase 0x3E0: val |= CM_FMSEL_3E0; break;\n\t\tcase 0x3C8: val |= CM_FMSEL_3C8; break;\n\t\tcase 0x388: val |= CM_FMSEL_388; break;\n\t\tdefault:\n\t\t\tgoto disable_fm;\n\t\t}\n\t\tsnd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);\n\t\t \n\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\n\n\t\tif (snd_opl3_create(cm->card, iosynth, iosynth + 2,\n\t\t\t\t    OPL3_HW_OPL3, 0, &opl3) < 0) {\n\t\t\tdev_err(cm->card->dev,\n\t\t\t\t\"no OPL device at %#lx, skipping...\\n\",\n\t\t\t\tiosynth);\n\t\t\tgoto disable_fm;\n\t\t}\n\t}\n\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\tif (err < 0) {\n\t\tdev_err(cm->card->dev, \"cannot create OPL3 hwdep\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n\n disable_fm:\n\tsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_FMSEL_MASK);\n\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\n\treturn 0;\n}\n\nstatic int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,\n\t\t\t     int dev)\n{\n\tstruct cmipci *cm = card->private_data;\n\tint err;\n\tunsigned int val;\n\tlong iomidi = 0;\n\tint integrated_midi = 0;\n\tchar modelstr[16];\n\tint pcm_index, pcm_spdif_index;\n\tstatic const struct pci_device_id intel_82437vx[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },\n\t\t{ },\n\t};\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&cm->reg_lock);\n\tmutex_init(&cm->open_mutex);\n\tcm->device = pci->device;\n\tcm->card = card;\n\tcm->pci = pci;\n\tcm->irq = -1;\n\tcm->channel[0].ch = 0;\n\tcm->channel[1].ch = 1;\n\tcm->channel[0].is_dac = cm->channel[1].is_dac = 1;  \n\n\terr = pci_request_regions(pci, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\tcm->iobase = pci_resource_start(pci, 0);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_cmipci_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, cm)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tcm->irq = pci->irq;\n\tcard->sync_irq = cm->irq;\n\tcard->private_free = snd_cmipci_free;\n\n\tpci_set_master(cm->pci);\n\n\t \n\n\tcm->chip_version = 0;\n\tcm->max_channels = 2;\n\tcm->do_soft_ac3 = soft_ac3[dev];\n\n\tif (pci->device != PCI_DEVICE_ID_CMEDIA_CM8338A &&\n\t    pci->device != PCI_DEVICE_ID_CMEDIA_CM8338B)\n\t\tquery_chip(cm);\n\t \n\tif (cm->can_multi_ch)\n\t\tsprintf(cm->card->driver + strlen(cm->card->driver),\n\t\t\t\"-MC%d\", cm->max_channels);\n\telse if (cm->can_ac3_sw)\n\t\tstrcpy(cm->card->driver + strlen(cm->card->driver), \"-SWIEC\");\n\n\tcm->dig_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\tcm->dig_pcm_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\n#if CM_CH_PLAY == 1\n\tcm->ctrl = CM_CHADC0;\t \n#else\n\tcm->ctrl = CM_CHADC1;\t \n#endif\n\n\t \n\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_RESET);\n\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_RESET);\n\tsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\t \n\tsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\n\tsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL0, 0);\t \n\tsnd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);\n\n\tsnd_cmipci_write(cm, CM_REG_CHFORMAT, 0);\n\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC|CM_N4SPK3D);\n#if CM_CH_PLAY == 1\n\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\n#else\n\tsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\n#endif\n\tif (cm->chip_version) {\n\t\tsnd_cmipci_write_b(cm, CM_REG_EXT_MISC, 0x20);  \n\t\tsnd_cmipci_write_b(cm, CM_REG_EXT_MISC + 1, 0x09);  \n\t}\n\t \n\tsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_BREQ);\n\n\t \n\tswitch (pci->device) {\n\tcase PCI_DEVICE_ID_CMEDIA_CM8738:\n\tcase PCI_DEVICE_ID_CMEDIA_CM8738B:\n\t\tif (!pci_dev_present(intel_82437vx)) \n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_TXVX);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cm->chip_version < 68) {\n\t\tval = pci->device < 0x110 ? 8338 : 8738;\n\t} else {\n\t\tswitch (snd_cmipci_read_b(cm, CM_REG_INT_HLDCLR + 3) & 0x03) {\n\t\tcase 0:\n\t\t\tval = 8769;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = 8762;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch ((pci->subsystem_vendor << 16) |\n\t\t\t\tpci->subsystem_device) {\n\t\t\tcase 0x13f69761:\n\t\t\tcase 0x584d3741:\n\t\t\tcase 0x584d3751:\n\t\t\tcase 0x584d3761:\n\t\t\tcase 0x584d3771:\n\t\t\tcase 0x72848384:\n\t\t\t\tval = 8770;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tval = 8768;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsprintf(card->shortname, \"C-Media CMI%d\", val);\n\tif (cm->chip_version < 68)\n\t\tscnprintf(modelstr, sizeof(modelstr),\n\t\t\t  \" (model %d)\", cm->chip_version);\n\telse\n\t\tmodelstr[0] = '\\0';\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s%s at %#lx, irq %i\",\n\t\t  card->shortname, modelstr, cm->iobase, cm->irq);\n\n\tif (cm->chip_version >= 39) {\n\t\tval = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);\n\t\tif (val != 0x00 && val != 0xff) {\n\t\t\tif (mpu_port[dev])\n\t\t\t\tiomidi = cm->iobase + CM_REG_MPU_PCI;\n\t\t\tintegrated_midi = 1;\n\t\t}\n\t}\n\tif (!integrated_midi) {\n\t\tval = 0;\n\t\tiomidi = mpu_port[dev];\n\t\tswitch (iomidi) {\n\t\tcase 0x320: val = CM_VMPU_320; break;\n\t\tcase 0x310: val = CM_VMPU_310; break;\n\t\tcase 0x300: val = CM_VMPU_300; break;\n\t\tcase 0x330: val = CM_VMPU_330; break;\n\t\tdefault:\n\t\t\t    iomidi = 0; break;\n\t\t}\n\t\tif (iomidi > 0) {\n\t\t\tsnd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);\n\t\t\t \n\t\t\tsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);\n\t\t\tif (inb(iomidi + 1) == 0xff) {\n\t\t\t\tdev_err(cm->card->dev,\n\t\t\t\t\t\"cannot enable MPU-401 port at %#lx\\n\",\n\t\t\t\t\tiomidi);\n\t\t\t\tsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1,\n\t\t\t\t\t\t     CM_UART_EN);\n\t\t\t\tiomidi = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cm->chip_version < 68) {\n\t\terr = snd_cmipci_create_fm(cm, fm_port[dev]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tsnd_cmipci_mixer_write(cm, 0, 0);\n\n\tsnd_cmipci_proc_init(cm);\n\n\t \n\tpcm_index = pcm_spdif_index = 0;\n\terr = snd_cmipci_pcm_new(cm, pcm_index);\n\tif (err < 0)\n\t\treturn err;\n\tpcm_index++;\n\terr = snd_cmipci_pcm2_new(cm, pcm_index);\n\tif (err < 0)\n\t\treturn err;\n\tpcm_index++;\n\tif (cm->can_ac3_hw || cm->can_ac3_sw) {\n\t\tpcm_spdif_index = pcm_index;\n\t\terr = snd_cmipci_pcm_spdif_new(cm, pcm_index);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = snd_cmipci_mixer_new(cm, pcm_spdif_index);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (iomidi > 0) {\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,\n\t\t\t\t\t  iomidi,\n\t\t\t\t\t  (integrated_midi ?\n\t\t\t\t\t   MPU401_INFO_INTEGRATED : 0) |\n\t\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t\t  -1, &cm->rmidi);\n\t\tif (err < 0)\n\t\t\tdev_err(cm->card->dev,\n\t\t\t\t\"no UART401 device at 0x%lx\\n\", iomidi);\n\t}\n\n#ifdef USE_VAR48KRATE\n\tfor (val = 0; val < ARRAY_SIZE(rates); val++)\n\t\tsnd_cmipci_set_pll(cm, rates[val], val);\n\n\t \n\tsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K|CM_SPDF_AC97);\n#endif  \n\n\tif (snd_cmipci_create_gameport(cm, dev) < 0)\n\t\tsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\n\n\treturn 0;\n}\n\n \n\nMODULE_DEVICE_TABLE(pci, snd_cmipci_ids);\n\nstatic int snd_cmipci_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (! enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct cmipci), &card);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tswitch (pci->device) {\n\tcase PCI_DEVICE_ID_CMEDIA_CM8738:\n\tcase PCI_DEVICE_ID_CMEDIA_CM8738B:\n\t\tstrcpy(card->driver, \"CMI8738\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_CMEDIA_CM8338A:\n\tcase PCI_DEVICE_ID_CMEDIA_CM8338B:\n\t\tstrcpy(card->driver, \"CMI8338\");\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(card->driver, \"CMIPCI\");\n\t\tbreak;\n\t}\n\n\terr = snd_cmipci_create(card, pci, dev);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic const unsigned char saved_regs[] = {\n\tCM_REG_FUNCTRL1, CM_REG_CHFORMAT, CM_REG_LEGACY_CTRL, CM_REG_MISC_CTRL,\n\tCM_REG_MIXER0, CM_REG_MIXER1, CM_REG_MIXER2, CM_REG_AUX_VOL, CM_REG_PLL,\n\tCM_REG_CH0_FRAME1, CM_REG_CH0_FRAME2,\n\tCM_REG_CH1_FRAME1, CM_REG_CH1_FRAME2, CM_REG_EXT_MISC,\n\tCM_REG_INT_STATUS, CM_REG_INT_HLDCLR, CM_REG_FUNCTRL0,\n};\n\nstatic const unsigned char saved_mixers[] = {\n\tSB_DSP4_MASTER_DEV, SB_DSP4_MASTER_DEV + 1,\n\tSB_DSP4_PCM_DEV, SB_DSP4_PCM_DEV + 1,\n\tSB_DSP4_SYNTH_DEV, SB_DSP4_SYNTH_DEV + 1,\n\tSB_DSP4_CD_DEV, SB_DSP4_CD_DEV + 1,\n\tSB_DSP4_LINE_DEV, SB_DSP4_LINE_DEV + 1,\n\tSB_DSP4_MIC_DEV, SB_DSP4_SPEAKER_DEV,\n\tCM_REG_EXTENT_IND, SB_DSP4_OUTPUT_SW,\n\tSB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT,\n};\n\nstatic int snd_cmipci_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct cmipci *cm = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\t\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tcm->saved_regs[i] = snd_cmipci_read(cm, saved_regs[i]);\n\tfor (i = 0; i < ARRAY_SIZE(saved_mixers); i++)\n\t\tcm->saved_mixers[i] = snd_cmipci_mixer_read(cm, saved_mixers[i]);\n\n\t \n\tsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\n\treturn 0;\n}\n\nstatic int snd_cmipci_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct cmipci *cm = card->private_data;\n\tint i;\n\n\t \n\tsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\n\tsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\n\tsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\n\tsnd_cmipci_mixer_write(cm, 0, 0);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tsnd_cmipci_write(cm, saved_regs[i], cm->saved_regs[i]);\n\tfor (i = 0; i < ARRAY_SIZE(saved_mixers); i++)\n\t\tsnd_cmipci_mixer_write(cm, saved_mixers[i], cm->saved_mixers[i]);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_cmipci_pm, snd_cmipci_suspend, snd_cmipci_resume);\n#define SND_CMIPCI_PM_OPS\t&snd_cmipci_pm\n#else\n#define SND_CMIPCI_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver cmipci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_cmipci_ids,\n\t.probe = snd_cmipci_probe,\n\t.driver = {\n\t\t.pm = SND_CMIPCI_PM_OPS,\n\t},\n};\n\t\nmodule_pci_driver(cmipci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}