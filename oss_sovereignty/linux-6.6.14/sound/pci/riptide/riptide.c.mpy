{
  "module_name": "riptide.c",
  "hash_id": "fbf44c34a8e89852a9a8aae70526aaea2f20b38baeb89a730282e9985a1ba651",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/riptide/riptide.c",
  "human_readable_source": "\n \n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/gameport.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/ac97_codec.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nMODULE_AUTHOR(\"Peter Gruber <nokos@gmx.net>\");\nMODULE_DESCRIPTION(\"riptide\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"riptide.hex\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\n\n#ifdef SUPPORT_JOYSTICK\nstatic int joystick_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x200 };\n#endif\nstatic int mpu_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x330 };\nstatic int opl3_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x388 };\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Riptide soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Riptide soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Riptide soundcard.\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param_hw_array(joystick_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(joystick_port, \"Joystick port # for Riptide soundcard.\");\n#endif\nmodule_param_hw_array(mpu_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU401 port # for Riptide driver.\");\nmodule_param_hw_array(opl3_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(opl3_port, \"OPL3 port # for Riptide driver.\");\n\n \n\n#define MPU401_HW_RIPTIDE MPU401_HW_MPU401\n#define OPL3_HW_RIPTIDE   OPL3_HW_OPL3\n\n#define PCI_EXT_CapId       0x40\n#define PCI_EXT_NextCapPrt  0x41\n#define PCI_EXT_PWMC        0x42\n#define PCI_EXT_PWSCR       0x44\n#define PCI_EXT_Data00      0x46\n#define PCI_EXT_PMSCR_BSE   0x47\n#define PCI_EXT_SB_Base     0x48\n#define PCI_EXT_FM_Base     0x4a\n#define PCI_EXT_MPU_Base    0x4C\n#define PCI_EXT_Game_Base   0x4E\n#define PCI_EXT_Legacy_Mask 0x50\n#define PCI_EXT_AsicRev     0x52\n#define PCI_EXT_Reserved3   0x53\n\n#define LEGACY_ENABLE_ALL      0x8000\t \n#define LEGACY_ENABLE_SB       0x4000\n#define LEGACY_ENABLE_FM       0x2000\n#define LEGACY_ENABLE_MPU_INT  0x1000\n#define LEGACY_ENABLE_MPU      0x0800\n#define LEGACY_ENABLE_GAMEPORT 0x0400\n\n#define MAX_WRITE_RETRY  10\t \n#define MAX_ERROR_COUNT  10\n#define CMDIF_TIMEOUT    50000\n#define RESET_TRIES      5\n\n#define READ_PORT_ULONG(p)     inl((unsigned long)&(p))\n#define WRITE_PORT_ULONG(p,x)  outl(x,(unsigned long)&(p))\n\n#define READ_AUDIO_CONTROL(p)     READ_PORT_ULONG(p->audio_control)\n#define WRITE_AUDIO_CONTROL(p,x)  WRITE_PORT_ULONG(p->audio_control,x)\n#define UMASK_AUDIO_CONTROL(p,x)  WRITE_PORT_ULONG(p->audio_control,READ_PORT_ULONG(p->audio_control)|x)\n#define MASK_AUDIO_CONTROL(p,x)   WRITE_PORT_ULONG(p->audio_control,READ_PORT_ULONG(p->audio_control)&x)\n#define READ_AUDIO_STATUS(p)      READ_PORT_ULONG(p->audio_status)\n\n#define SET_GRESET(p)     UMASK_AUDIO_CONTROL(p,0x0001)\t \n#define UNSET_GRESET(p)   MASK_AUDIO_CONTROL(p,~0x0001)\n#define SET_AIE(p)        UMASK_AUDIO_CONTROL(p,0x0004)\t \n#define UNSET_AIE(p)      MASK_AUDIO_CONTROL(p,~0x0004)\n#define SET_AIACK(p)      UMASK_AUDIO_CONTROL(p,0x0008)\t \n#define UNSET_AIACKT(p)   MASKAUDIO_CONTROL(p,~0x0008)\n#define SET_ECMDAE(p)     UMASK_AUDIO_CONTROL(p,0x0010)\n#define UNSET_ECMDAE(p)   MASK_AUDIO_CONTROL(p,~0x0010)\n#define SET_ECMDBE(p)     UMASK_AUDIO_CONTROL(p,0x0020)\n#define UNSET_ECMDBE(p)   MASK_AUDIO_CONTROL(p,~0x0020)\n#define SET_EDATAF(p)     UMASK_AUDIO_CONTROL(p,0x0040)\n#define UNSET_EDATAF(p)   MASK_AUDIO_CONTROL(p,~0x0040)\n#define SET_EDATBF(p)     UMASK_AUDIO_CONTROL(p,0x0080)\n#define UNSET_EDATBF(p)   MASK_AUDIO_CONTROL(p,~0x0080)\n#define SET_ESBIRQON(p)   UMASK_AUDIO_CONTROL(p,0x0100)\n#define UNSET_ESBIRQON(p) MASK_AUDIO_CONTROL(p,~0x0100)\n#define SET_EMPUIRQ(p)    UMASK_AUDIO_CONTROL(p,0x0200)\n#define UNSET_EMPUIRQ(p)  MASK_AUDIO_CONTROL(p,~0x0200)\n#define IS_CMDE(a)        (READ_PORT_ULONG(a->stat)&0x1)\t \n#define IS_DATF(a)        (READ_PORT_ULONG(a->stat)&0x2)\t \n#define IS_READY(p)       (READ_AUDIO_STATUS(p)&0x0001)\n#define IS_DLREADY(p)     (READ_AUDIO_STATUS(p)&0x0002)\n#define IS_DLERR(p)       (READ_AUDIO_STATUS(p)&0x0004)\n#define IS_GERR(p)        (READ_AUDIO_STATUS(p)&0x0008)\t \n#define IS_CMDAEIRQ(p)    (READ_AUDIO_STATUS(p)&0x0010)\n#define IS_CMDBEIRQ(p)    (READ_AUDIO_STATUS(p)&0x0020)\n#define IS_DATAFIRQ(p)    (READ_AUDIO_STATUS(p)&0x0040)\n#define IS_DATBFIRQ(p)    (READ_AUDIO_STATUS(p)&0x0080)\n#define IS_EOBIRQ(p)      (READ_AUDIO_STATUS(p)&0x0100)\t \n#define IS_EOSIRQ(p)      (READ_AUDIO_STATUS(p)&0x0200)\n#define IS_EOCIRQ(p)      (READ_AUDIO_STATUS(p)&0x0400)\n#define IS_UNSLIRQ(p)     (READ_AUDIO_STATUS(p)&0x0800)\n#define IS_SBIRQ(p)       (READ_AUDIO_STATUS(p)&0x1000)\n#define IS_MPUIRQ(p)      (READ_AUDIO_STATUS(p)&0x2000)\n\n#define RESP 0x00000001\t\t \n#define PARM 0x00000002\n#define CMDA 0x00000004\n#define CMDB 0x00000008\n#define NILL 0x00000000\n\n#define LONG0(a)   ((u32)a)\t \n#define BYTE0(a)   (LONG0(a)&0xff)\n#define BYTE1(a)   (BYTE0(a)<<8)\n#define BYTE2(a)   (BYTE0(a)<<16)\n#define BYTE3(a)   (BYTE0(a)<<24)\n#define WORD0(a)   (LONG0(a)&0xffff)\n#define WORD1(a)   (WORD0(a)<<8)\n#define WORD2(a)   (WORD0(a)<<16)\n#define TRINIB0(a) (LONG0(a)&0xffffff)\n#define TRINIB1(a) (TRINIB0(a)<<8)\n\n#define RET(a)     ((union cmdret *)(a))\n\n#define SEND_GETV(p,b)             sendcmd(p,RESP,GETV,0,RET(b))\t \n#define SEND_GETC(p,b,c)           sendcmd(p,PARM|RESP,GETC,c,RET(b))\n#define SEND_GUNS(p,b)             sendcmd(p,RESP,GUNS,0,RET(b))\n#define SEND_SCID(p,b)             sendcmd(p,RESP,SCID,0,RET(b))\n#define SEND_RMEM(p,b,c,d)         sendcmd(p,PARM|RESP,RMEM|BYTE1(b),LONG0(c),RET(d))\t \n#define SEND_SMEM(p,b,c)           sendcmd(p,PARM,SMEM|BYTE1(b),LONG0(c),RET(0))\t \n#define SEND_WMEM(p,b,c)           sendcmd(p,PARM,WMEM|BYTE1(b),LONG0(c),RET(0))\t \n#define SEND_SDTM(p,b,c)           sendcmd(p,PARM|RESP,SDTM|TRINIB1(b),0,RET(c))\t \n#define SEND_GOTO(p,b)             sendcmd(p,PARM,GOTO,LONG0(b),RET(0))\t \n#define SEND_SETDPLL(p)\t           sendcmd(p,0,ARM_SETDPLL,0,RET(0))\n#define SEND_SSTR(p,b,c)           sendcmd(p,PARM,SSTR|BYTE3(b),LONG0(c),RET(0))\t \n#define SEND_PSTR(p,b)             sendcmd(p,PARM,PSTR,BYTE3(b),RET(0))\t \n#define SEND_KSTR(p,b)             sendcmd(p,PARM,KSTR,BYTE3(b),RET(0))\t \n#define SEND_KDMA(p)               sendcmd(p,0,KDMA,0,RET(0))\t \n#define SEND_GPOS(p,b,c,d)         sendcmd(p,PARM|RESP,GPOS,BYTE3(c)|BYTE2(b),RET(d))\t \n#define SEND_SETF(p,b,c,d,e,f,g)   sendcmd(p,PARM,SETF|WORD1(b)|BYTE3(c),d|BYTE1(e)|BYTE2(f)|BYTE3(g),RET(0))\t \n#define SEND_GSTS(p,b,c,d)         sendcmd(p,PARM|RESP,GSTS,BYTE3(c)|BYTE2(b),RET(d))\n#define SEND_NGPOS(p,b,c,d)        sendcmd(p,PARM|RESP,NGPOS,BYTE3(c)|BYTE2(b),RET(d))\n#define SEND_PSEL(p,b,c)           sendcmd(p,PARM,PSEL,BYTE2(b)|BYTE3(c),RET(0))\t \n#define SEND_PCLR(p,b,c)           sendcmd(p,PARM,PCLR,BYTE2(b)|BYTE3(c),RET(0))\t \n#define SEND_PLST(p,b)             sendcmd(p,PARM,PLST,BYTE3(b),RET(0))\n#define SEND_RSSV(p,b,c,d)         sendcmd(p,PARM|RESP,RSSV,BYTE2(b)|BYTE3(c),RET(d))\n#define SEND_LSEL(p,b,c,d,e,f,g,h) sendcmd(p,PARM,LSEL|BYTE1(b)|BYTE2(c)|BYTE3(d),BYTE0(e)|BYTE1(f)|BYTE2(g)|BYTE3(h),RET(0))\t \n#define SEND_SSRC(p,b,c,d,e)       sendcmd(p,PARM,SSRC|BYTE1(b)|WORD2(c),WORD0(d)|WORD2(e),RET(0))\t \n#define SEND_SLST(p,b)             sendcmd(p,PARM,SLST,BYTE3(b),RET(0))\n#define SEND_RSRC(p,b,c)           sendcmd(p,RESP,RSRC|BYTE1(b),0,RET(c))\t \n#define SEND_SSRB(p,b,c)           sendcmd(p,PARM,SSRB|BYTE1(b),WORD2(c),RET(0))\n#define SEND_SDGV(p,b,c,d,e)       sendcmd(p,PARM,SDGV|BYTE2(b)|BYTE3(c),WORD0(d)|WORD2(e),RET(0))\t \n#define SEND_RDGV(p,b,c,d)         sendcmd(p,PARM|RESP,RDGV|BYTE2(b)|BYTE3(c),0,RET(d))\t \n#define SEND_DLST(p,b)             sendcmd(p,PARM,DLST,BYTE3(b),RET(0))\n#define SEND_SACR(p,b,c)           sendcmd(p,PARM,SACR,WORD0(b)|WORD2(c),RET(0))\t \n#define SEND_RACR(p,b,c)           sendcmd(p,PARM|RESP,RACR,WORD2(b),RET(c))\t \n#define SEND_ALST(p,b)             sendcmd(p,PARM,ALST,BYTE3(b),RET(0))\n#define SEND_TXAC(p,b,c,d,e,f)     sendcmd(p,PARM,TXAC|BYTE1(b)|WORD2(c),WORD0(d)|BYTE2(e)|BYTE3(f),RET(0))\n#define SEND_RXAC(p,b,c,d)         sendcmd(p,PARM|RESP,RXAC,BYTE2(b)|BYTE3(c),RET(d))\n#define SEND_SI2S(p,b)             sendcmd(p,PARM,SI2S,WORD2(b),RET(0))\n\n#define EOB_STATUS         0x80000000\t \n#define EOS_STATUS         0x40000000\t \n#define EOC_STATUS         0x20000000\t \n#define ERR_STATUS         0x10000000\n#define EMPTY_STATUS       0x08000000\n\n#define IEOB_ENABLE        0x1\t \n#define IEOS_ENABLE        0x2\n#define IEOC_ENABLE        0x4\n#define RDONCE             0x8\n#define DESC_MAX_MASK      0xff\n\n#define ST_PLAY  0x1\t\t \n#define ST_STOP  0x2\n#define ST_PAUSE 0x4\n\n#define I2S_INTDEC     3\t \n#define I2S_MERGER     0\n#define I2S_SPLITTER   0\n#define I2S_MIXER      7\n#define I2S_RATE       44100\n\n#define MODEM_INTDEC   4\t \n#define MODEM_MERGER   3\n#define MODEM_SPLITTER 0\n#define MODEM_MIXER    11\n\n#define FM_INTDEC      3\t \n#define FM_MERGER      0\n#define FM_SPLITTER    0\n#define FM_MIXER       9\n\n#define SPLIT_PATH  0x80\t \n\nenum FIRMWARE {\n\tDATA_REC = 0, EXT_END_OF_FILE, EXT_SEG_ADDR_REC, EXT_GOTO_CMD_REC,\n\tEXT_LIN_ADDR_REC,\n};\n\nenum CMDS {\n\tGETV = 0x00, GETC, GUNS, SCID, RMEM =\n\t    0x10, SMEM, WMEM, SDTM, GOTO, SSTR =\n\t    0x20, PSTR, KSTR, KDMA, GPOS, SETF, GSTS, NGPOS, PSEL =\n\t    0x30, PCLR, PLST, RSSV, LSEL, SSRC = 0x40, SLST, RSRC, SSRB, SDGV =\n\t    0x50, RDGV, DLST, SACR = 0x60, RACR, ALST, TXAC, RXAC, SI2S =\n\t    0x70, ARM_SETDPLL = 0x72,\n};\n\nenum E1SOURCE {\n\tARM2LBUS_FIFO0 = 0, ARM2LBUS_FIFO1, ARM2LBUS_FIFO2, ARM2LBUS_FIFO3,\n\tARM2LBUS_FIFO4, ARM2LBUS_FIFO5, ARM2LBUS_FIFO6, ARM2LBUS_FIFO7,\n\tARM2LBUS_FIFO8, ARM2LBUS_FIFO9, ARM2LBUS_FIFO10, ARM2LBUS_FIFO11,\n\tARM2LBUS_FIFO12, ARM2LBUS_FIFO13, ARM2LBUS_FIFO14, ARM2LBUS_FIFO15,\n\tINTER0_OUT, INTER1_OUT, INTER2_OUT, INTER3_OUT, INTER4_OUT,\n\tINTERM0_OUT, INTERM1_OUT, INTERM2_OUT, INTERM3_OUT, INTERM4_OUT,\n\tINTERM5_OUT, INTERM6_OUT, DECIMM0_OUT, DECIMM1_OUT, DECIMM2_OUT,\n\tDECIMM3_OUT, DECIM0_OUT, SR3_4_OUT, OPL3_SAMPLE, ASRC0, ASRC1,\n\tACLNK2PADC, ACLNK2MODEM0RX, ACLNK2MIC, ACLNK2MODEM1RX, ACLNK2HNDMIC,\n\tDIGITAL_MIXER_OUT0, GAINFUNC0_OUT, GAINFUNC1_OUT, GAINFUNC2_OUT,\n\tGAINFUNC3_OUT, GAINFUNC4_OUT, SOFTMODEMTX, SPLITTER0_OUTL,\n\tSPLITTER0_OUTR, SPLITTER1_OUTL, SPLITTER1_OUTR, SPLITTER2_OUTL,\n\tSPLITTER2_OUTR, SPLITTER3_OUTL, SPLITTER3_OUTR, MERGER0_OUT,\n\tMERGER1_OUT, MERGER2_OUT, MERGER3_OUT, ARM2LBUS_FIFO_DIRECT, NO_OUT\n};\n\nenum E2SINK {\n\tLBUS2ARM_FIFO0 = 0, LBUS2ARM_FIFO1, LBUS2ARM_FIFO2, LBUS2ARM_FIFO3,\n\tLBUS2ARM_FIFO4, LBUS2ARM_FIFO5, LBUS2ARM_FIFO6, LBUS2ARM_FIFO7,\n\tINTER0_IN, INTER1_IN, INTER2_IN, INTER3_IN, INTER4_IN, INTERM0_IN,\n\tINTERM1_IN, INTERM2_IN, INTERM3_IN, INTERM4_IN, INTERM5_IN, INTERM6_IN,\n\tDECIMM0_IN, DECIMM1_IN, DECIMM2_IN, DECIMM3_IN, DECIM0_IN, SR3_4_IN,\n\tPDAC2ACLNK, MODEM0TX2ACLNK, MODEM1TX2ACLNK, HNDSPK2ACLNK,\n\tDIGITAL_MIXER_IN0, DIGITAL_MIXER_IN1, DIGITAL_MIXER_IN2,\n\tDIGITAL_MIXER_IN3, DIGITAL_MIXER_IN4, DIGITAL_MIXER_IN5,\n\tDIGITAL_MIXER_IN6, DIGITAL_MIXER_IN7, DIGITAL_MIXER_IN8,\n\tDIGITAL_MIXER_IN9, DIGITAL_MIXER_IN10, DIGITAL_MIXER_IN11,\n\tGAINFUNC0_IN, GAINFUNC1_IN, GAINFUNC2_IN, GAINFUNC3_IN, GAINFUNC4_IN,\n\tSOFTMODEMRX, SPLITTER0_IN, SPLITTER1_IN, SPLITTER2_IN, SPLITTER3_IN,\n\tMERGER0_INL, MERGER0_INR, MERGER1_INL, MERGER1_INR, MERGER2_INL,\n\tMERGER2_INR, MERGER3_INL, MERGER3_INR, E2SINK_MAX\n};\n\nenum LBUS_SINK {\n\tLS_SRC_INTERPOLATOR = 0, LS_SRC_INTERPOLATORM, LS_SRC_DECIMATOR,\n\tLS_SRC_DECIMATORM, LS_MIXER_IN, LS_MIXER_GAIN_FUNCTION,\n\tLS_SRC_SPLITTER, LS_SRC_MERGER, LS_NONE1, LS_NONE2,\n};\n\nenum RT_CHANNEL_IDS {\n\tM0TX = 0, M1TX, TAMTX, HSSPKR, PDAC, DSNDTX0, DSNDTX1, DSNDTX2,\n\tDSNDTX3, DSNDTX4, DSNDTX5, DSNDTX6, DSNDTX7, WVSTRTX, COP3DTX, SPARE,\n\tM0RX, HSMIC, M1RX, CLEANRX, MICADC, PADC, COPRX1, COPRX2,\n\tCHANNEL_ID_COUNTER\n};\n\nenum { SB_CMD = 0, MODEM_CMD, I2S_CMD0, I2S_CMD1, FM_CMD, MAX_CMD };\n\nstruct lbuspath {\n\tconst unsigned char *noconv;\n\tconst unsigned char *stereo;\n\tconst unsigned char *mono;\n};\n\nstruct cmdport {\n\tu32 data1;\t\t \n\tu32 data2;\t\t \n\tu32 stat;\t\t \n\tu32 pad[5];\n};\n\nstruct riptideport {\n\tu32 audio_control;\t \n\tu32 audio_status;\n\tu32 pad[2];\n\tstruct cmdport port[2];\t \n};\n\nstruct cmdif {\n\tstruct riptideport *hwport;\n\tspinlock_t lock;\n\tunsigned int cmdcnt;\t \n\tunsigned int cmdtime;\n\tunsigned int cmdtimemax;\n\tunsigned int cmdtimemin;\n\tunsigned int errcnt;\n\tint is_reset;\n};\n\nstruct riptide_firmware {\n\tu16 ASIC;\n\tu16 CODEC;\n\tu16 AUXDSP;\n\tu16 PROG;\n};\n\nunion cmdret {\n\tu8 retbytes[8];\n\tu16 retwords[4];\n\tu32 retlongs[2];\n};\n\nunion firmware_version {\n\tunion cmdret ret;\n\tstruct riptide_firmware firmware;\n};\n\n#define get_pcmhwdev(substream) (struct pcmhw *)(substream->runtime->private_data)\n\n#define PLAYBACK_SUBSTREAMS 3\nstruct snd_riptide {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\tconst struct firmware *fw_entry;\n\n\tstruct cmdif *cif;\n\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm *pcm_i2s;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_opl3 *opl3;\n\tstruct snd_ac97 *ac97;\n\tstruct snd_ac97_bus *ac97_bus;\n\n\tstruct snd_pcm_substream *playback_substream[PLAYBACK_SUBSTREAMS];\n\tstruct snd_pcm_substream *capture_substream;\n\n\tint openstreams;\n\n\tint irq;\n\tunsigned long port;\n\tunsigned short mpuaddr;\n\tunsigned short opladdr;\n#ifdef SUPPORT_JOYSTICK\n\tunsigned short gameaddr;\n#endif\n\tstruct resource *res_port;\n\n\tunsigned short device_id;\n\n\tunion firmware_version firmware;\n\n\tspinlock_t lock;\n\tstruct snd_info_entry *proc_entry;\n\n\tunsigned long received_irqs;\n\tunsigned long handled_irqs;\n#ifdef CONFIG_PM_SLEEP\n\tint in_suspend;\n#endif\n};\n\nstruct sgd {\t\t\t \n\t__le32 dwNextLink;\n\t__le32 dwSegPtrPhys;\n\t__le32 dwSegLen;\n\t__le32 dwStat_Ctl;\n};\n\nstruct pcmhw {\t\t\t \n\tstruct lbuspath paths;\n\tconst unsigned char *lbuspath;\n\tunsigned char source;\n\tunsigned char intdec[2];\n\tunsigned char mixer;\n\tunsigned char id;\n\tunsigned char state;\n\tunsigned int rate;\n\tunsigned int channels;\n\tsnd_pcm_format_t format;\n\tstruct snd_dma_buffer sgdlist;\n\tstruct sgd *sgdbuf;\n\tunsigned int size;\n\tunsigned int pages;\n\tunsigned int oldpos;\n\tunsigned int pointer;\n};\n\n#define CMDRET_ZERO (union cmdret){{(u32)0, (u32) 0}}\n\nstatic int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,\n\t\t   union cmdret *ret);\nstatic int getsourcesink(struct cmdif *cif, unsigned char source,\n\t\t\t unsigned char sink, unsigned char *a,\n\t\t\t unsigned char *b);\nstatic int snd_riptide_initialize(struct snd_riptide *chip);\nstatic int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);\n\n \n\nstatic const struct pci_device_id snd_riptide_ids[] = {\n\t{ PCI_DEVICE(0x127a, 0x4310) },\n\t{ PCI_DEVICE(0x127a, 0x4320) },\n\t{ PCI_DEVICE(0x127a, 0x4330) },\n\t{ PCI_DEVICE(0x127a, 0x4340) },\n\t{0,},\n};\n\n#ifdef SUPPORT_JOYSTICK\nstatic const struct pci_device_id snd_riptide_joystick_ids[] = {\n\t{ PCI_DEVICE(0x127a, 0x4312) },\n\t{ PCI_DEVICE(0x127a, 0x4322) },\n\t{ PCI_DEVICE(0x127a, 0x4332) },\n\t{ PCI_DEVICE(0x127a, 0x4342) },\n\t{0,},\n};\n#endif\n\nMODULE_DEVICE_TABLE(pci, snd_riptide_ids);\n\n \n\nstatic const unsigned char lbusin2out[E2SINK_MAX + 1][2] = {\n\t{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,\n\t\t\t\t\t\t\t\t     LS_NONE2},\n\t{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,\n\t\t\t\t\t\t\t\t     LS_NONE2},\n\t{INTER0_OUT, LS_SRC_INTERPOLATOR}, {INTER1_OUT, LS_SRC_INTERPOLATOR},\n\t{INTER2_OUT, LS_SRC_INTERPOLATOR}, {INTER3_OUT, LS_SRC_INTERPOLATOR},\n\t{INTER4_OUT, LS_SRC_INTERPOLATOR}, {INTERM0_OUT, LS_SRC_INTERPOLATORM},\n\t{INTERM1_OUT, LS_SRC_INTERPOLATORM}, {INTERM2_OUT,\n\t\t\t\t\t      LS_SRC_INTERPOLATORM},\n\t{INTERM3_OUT, LS_SRC_INTERPOLATORM}, {INTERM4_OUT,\n\t\t\t\t\t      LS_SRC_INTERPOLATORM},\n\t{INTERM5_OUT, LS_SRC_INTERPOLATORM}, {INTERM6_OUT,\n\t\t\t\t\t      LS_SRC_INTERPOLATORM},\n\t{DECIMM0_OUT, LS_SRC_DECIMATORM}, {DECIMM1_OUT, LS_SRC_DECIMATORM},\n\t{DECIMM2_OUT, LS_SRC_DECIMATORM}, {DECIMM3_OUT, LS_SRC_DECIMATORM},\n\t{DECIM0_OUT, LS_SRC_DECIMATOR}, {SR3_4_OUT, LS_NONE1}, {NO_OUT,\n\t\t\t\t\t\t\t\tLS_NONE2},\n\t{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},\n\t{GAINFUNC0_OUT, LS_MIXER_GAIN_FUNCTION}, {GAINFUNC1_OUT,\n\t\t\t\t\t\t  LS_MIXER_GAIN_FUNCTION},\n\t{GAINFUNC2_OUT, LS_MIXER_GAIN_FUNCTION}, {GAINFUNC3_OUT,\n\t\t\t\t\t\t  LS_MIXER_GAIN_FUNCTION},\n\t{GAINFUNC4_OUT, LS_MIXER_GAIN_FUNCTION}, {SOFTMODEMTX, LS_NONE1},\n\t{SPLITTER0_OUTL, LS_SRC_SPLITTER}, {SPLITTER1_OUTL, LS_SRC_SPLITTER},\n\t{SPLITTER2_OUTL, LS_SRC_SPLITTER}, {SPLITTER3_OUTL, LS_SRC_SPLITTER},\n\t{MERGER0_OUT, LS_SRC_MERGER}, {MERGER0_OUT, LS_SRC_MERGER},\n\t{MERGER1_OUT, LS_SRC_MERGER},\n\t{MERGER1_OUT, LS_SRC_MERGER}, {MERGER2_OUT, LS_SRC_MERGER},\n\t{MERGER2_OUT, LS_SRC_MERGER},\n\t{MERGER3_OUT, LS_SRC_MERGER}, {MERGER3_OUT, LS_SRC_MERGER}, {NO_OUT,\n\t\t\t\t\t\t\t\t     LS_NONE2},\n};\n\nstatic const unsigned char lbus_play_opl3[] = {\n\tDIGITAL_MIXER_IN0 + FM_MIXER, 0xff\n};\nstatic const unsigned char lbus_play_modem[] = {\n\tDIGITAL_MIXER_IN0 + MODEM_MIXER, 0xff\n};\nstatic const unsigned char lbus_play_i2s[] = {\n\tINTER0_IN + I2S_INTDEC, DIGITAL_MIXER_IN0 + I2S_MIXER, 0xff\n};\nstatic const unsigned char lbus_play_out[] = {\n\tPDAC2ACLNK, 0xff\n};\nstatic const unsigned char lbus_play_outhp[] = {\n\tHNDSPK2ACLNK, 0xff\n};\nstatic const unsigned char lbus_play_noconv1[] = {\n\tDIGITAL_MIXER_IN0, 0xff\n};\nstatic const unsigned char lbus_play_stereo1[] = {\n\tINTER0_IN, DIGITAL_MIXER_IN0, 0xff\n};\nstatic const unsigned char lbus_play_mono1[] = {\n\tINTERM0_IN, DIGITAL_MIXER_IN0, 0xff\n};\nstatic const unsigned char lbus_play_noconv2[] = {\n\tDIGITAL_MIXER_IN1, 0xff\n};\nstatic const unsigned char lbus_play_stereo2[] = {\n\tINTER1_IN, DIGITAL_MIXER_IN1, 0xff\n};\nstatic const unsigned char lbus_play_mono2[] = {\n\tINTERM1_IN, DIGITAL_MIXER_IN1, 0xff\n};\nstatic const unsigned char lbus_play_noconv3[] = {\n\tDIGITAL_MIXER_IN2, 0xff\n};\nstatic const unsigned char lbus_play_stereo3[] = {\n\tINTER2_IN, DIGITAL_MIXER_IN2, 0xff\n};\nstatic const unsigned char lbus_play_mono3[] = {\n\tINTERM2_IN, DIGITAL_MIXER_IN2, 0xff\n};\nstatic const unsigned char lbus_rec_noconv1[] = {\n\tLBUS2ARM_FIFO5, 0xff\n};\nstatic const unsigned char lbus_rec_stereo1[] = {\n\tDECIM0_IN, LBUS2ARM_FIFO5, 0xff\n};\nstatic const unsigned char lbus_rec_mono1[] = {\n\tDECIMM3_IN, LBUS2ARM_FIFO5, 0xff\n};\n\nstatic const unsigned char play_ids[] = { 4, 1, 2, };\nstatic const unsigned char play_sources[] = {\n\tARM2LBUS_FIFO4, ARM2LBUS_FIFO1, ARM2LBUS_FIFO2,\n};\nstatic const struct lbuspath lbus_play_paths[] = {\n\t{\n\t .noconv = lbus_play_noconv1,\n\t .stereo = lbus_play_stereo1,\n\t .mono = lbus_play_mono1,\n\t },\n\t{\n\t .noconv = lbus_play_noconv2,\n\t .stereo = lbus_play_stereo2,\n\t .mono = lbus_play_mono2,\n\t },\n\t{\n\t .noconv = lbus_play_noconv3,\n\t .stereo = lbus_play_stereo3,\n\t .mono = lbus_play_mono3,\n\t },\n};\nstatic const struct lbuspath lbus_rec_path = {\n\t.noconv = lbus_rec_noconv1,\n\t.stereo = lbus_rec_stereo1,\n\t.mono = lbus_rec_mono1,\n};\n\n#define FIRMWARE_VERSIONS 1\nstatic union firmware_version firmware_versions[] = {\n\t{\n\t\t.firmware = {\n\t\t\t.ASIC = 3,\n\t\t\t.CODEC = 2,\n\t\t\t.AUXDSP = 3,\n\t\t\t.PROG = 773,\n\t\t},\n\t},\n};\n\nstatic u32 atoh(const unsigned char *in, unsigned int len)\n{\n\tu32 sum = 0;\n\tunsigned int mult = 1;\n\tunsigned char c;\n\n\twhile (len) {\n\t\tint value;\n\n\t\tc = in[len - 1];\n\t\tvalue = hex_to_bin(c);\n\t\tif (value >= 0)\n\t\t\tsum += mult * value;\n\t\tmult *= 16;\n\t\t--len;\n\t}\n\treturn sum;\n}\n\nstatic int senddata(struct cmdif *cif, const unsigned char *in, u32 offset)\n{\n\tu32 addr;\n\tu32 data;\n\tu32 i;\n\tconst unsigned char *p;\n\n\ti = atoh(&in[1], 2);\n\taddr = offset + atoh(&in[3], 4);\n\tif (SEND_SMEM(cif, 0, addr) != 0)\n\t\treturn -EACCES;\n\tp = in + 9;\n\twhile (i) {\n\t\tdata = atoh(p, 8);\n\t\tif (SEND_WMEM(cif, 2,\n\t\t\t      ((data & 0x0f0f0f0f) << 4) | ((data & 0xf0f0f0f0)\n\t\t\t\t\t\t\t    >> 4)))\n\t\t\treturn -EACCES;\n\t\ti -= 4;\n\t\tp += 8;\n\t}\n\treturn 0;\n}\n\nstatic int loadfirmware(struct cmdif *cif, const unsigned char *img,\n\t\t\tunsigned int size)\n{\n\tconst unsigned char *in;\n\tu32 laddr, saddr, t, val;\n\tint err = 0;\n\n\tladdr = saddr = 0;\n\twhile (size > 0 && err == 0) {\n\t\tin = img;\n\t\tif (in[0] == ':') {\n\t\t\tt = atoh(&in[7], 2);\n\t\t\tswitch (t) {\n\t\t\tcase DATA_REC:\n\t\t\t\terr = senddata(cif, in, laddr + saddr);\n\t\t\t\tbreak;\n\t\t\tcase EXT_SEG_ADDR_REC:\n\t\t\t\tsaddr = atoh(&in[9], 4) << 4;\n\t\t\t\tbreak;\n\t\t\tcase EXT_LIN_ADDR_REC:\n\t\t\t\tladdr = atoh(&in[9], 4) << 16;\n\t\t\t\tbreak;\n\t\t\tcase EXT_GOTO_CMD_REC:\n\t\t\t\tval = atoh(&in[9], 8);\n\t\t\t\tif (SEND_GOTO(cif, val) != 0)\n\t\t\t\t\terr = -EACCES;\n\t\t\t\tbreak;\n\t\t\tcase EXT_END_OF_FILE:\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (size > 0) {\n\t\t\t\tsize--;\n\t\t\t\tif (*img++ == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsnd_printdd(\"load firmware return %d\\n\", err);\n\treturn err;\n}\n\nstatic void\nalloclbuspath(struct cmdif *cif, unsigned char source,\n\t      const unsigned char *path, unsigned char *mixer, unsigned char *s)\n{\n\twhile (*path != 0xff) {\n\t\tunsigned char sink, type;\n\n\t\tsink = *path & (~SPLIT_PATH);\n\t\tif (sink != E2SINK_MAX) {\n\t\t\tsnd_printdd(\"alloc path 0x%x->0x%x\\n\", source, sink);\n\t\t\tSEND_PSEL(cif, source, sink);\n\t\t\tsource = lbusin2out[sink][0];\n\t\t\ttype = lbusin2out[sink][1];\n\t\t\tif (type == LS_MIXER_IN) {\n\t\t\t\tif (mixer)\n\t\t\t\t\t*mixer = sink - DIGITAL_MIXER_IN0;\n\t\t\t}\n\t\t\tif (type == LS_SRC_DECIMATORM ||\n\t\t\t    type == LS_SRC_DECIMATOR ||\n\t\t\t    type == LS_SRC_INTERPOLATORM ||\n\t\t\t    type == LS_SRC_INTERPOLATOR) {\n\t\t\t\tif (s) {\n\t\t\t\t\tif (s[0] != 0xff)\n\t\t\t\t\t\ts[1] = sink;\n\t\t\t\t\telse\n\t\t\t\t\t\ts[0] = sink;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (*path++ & SPLIT_PATH) {\n\t\t\tconst unsigned char *npath = path;\n\n\t\t\twhile (*npath != 0xff)\n\t\t\t\tnpath++;\n\t\t\talloclbuspath(cif, source + 1, ++npath, mixer, s);\n\t\t}\n\t}\n}\n\nstatic void\nfreelbuspath(struct cmdif *cif, unsigned char source, const unsigned char *path)\n{\n\twhile (*path != 0xff) {\n\t\tunsigned char sink;\n\n\t\tsink = *path & (~SPLIT_PATH);\n\t\tif (sink != E2SINK_MAX) {\n\t\t\tsnd_printdd(\"free path 0x%x->0x%x\\n\", source, sink);\n\t\t\tSEND_PCLR(cif, source, sink);\n\t\t\tsource = lbusin2out[sink][0];\n\t\t}\n\t\tif (*path++ & SPLIT_PATH) {\n\t\t\tconst unsigned char *npath = path;\n\n\t\t\twhile (*npath != 0xff)\n\t\t\t\tnpath++;\n\t\t\tfreelbuspath(cif, source + 1, ++npath);\n\t\t}\n\t}\n}\n\nstatic int writearm(struct cmdif *cif, u32 addr, u32 data, u32 mask)\n{\n\tunion cmdret rptr = CMDRET_ZERO;\n\tunsigned int i = MAX_WRITE_RETRY;\n\tint flag = 1;\n\n\tSEND_RMEM(cif, 0x02, addr, &rptr);\n\trptr.retlongs[0] &= (~mask);\n\n\twhile (--i) {\n\t\tSEND_SMEM(cif, 0x01, addr);\n\t\tSEND_WMEM(cif, 0x02, (rptr.retlongs[0] | data));\n\t\tSEND_RMEM(cif, 0x02, addr, &rptr);\n\t\tif ((rptr.retlongs[0] & data) == data) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t} else\n\t\t\trptr.retlongs[0] &= ~mask;\n\t}\n\tsnd_printdd(\"send arm 0x%x 0x%x 0x%x return %d\\n\", addr, data, mask,\n\t\t    flag);\n\treturn flag;\n}\n\nstatic int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,\n\t\t   union cmdret *ret)\n{\n\tint i, j;\n\tint err;\n\tunsigned int time = 0;\n\tunsigned long irqflags;\n\tstruct riptideport *hwport;\n\tstruct cmdport *cmdport = NULL;\n\n\tif (snd_BUG_ON(!cif))\n\t\treturn -EINVAL;\n\n\thwport = cif->hwport;\n\tif (cif->errcnt > MAX_ERROR_COUNT) {\n\t\tif (cif->is_reset) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"Riptide: Too many failed cmds, reinitializing\\n\");\n\t\t\tif (riptide_reset(cif, NULL) == 0) {\n\t\t\t\tcif->errcnt = 0;\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tsnd_printk(KERN_ERR \"Riptide: Initialization failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ret) {\n\t\tret->retlongs[0] = 0;\n\t\tret->retlongs[1] = 0;\n\t}\n\ti = 0;\n\tspin_lock_irqsave(&cif->lock, irqflags);\n\twhile (i++ < CMDIF_TIMEOUT && !IS_READY(cif->hwport))\n\t\tudelay(10);\n\tif (i > CMDIF_TIMEOUT) {\n\t\terr = -EBUSY;\n\t\tgoto errout;\n\t}\n\n\terr = 0;\n\tfor (j = 0, time = 0; time < CMDIF_TIMEOUT; j++, time += 2) {\n\t\tcmdport = &(hwport->port[j % 2]);\n\t\tif (IS_DATF(cmdport)) {\t \n\t\t\tREAD_PORT_ULONG(cmdport->data1);\n\t\t\tREAD_PORT_ULONG(cmdport->data2);\n\t\t}\n\t\tif (IS_CMDE(cmdport)) {\n\t\t\tif (flags & PARM)\t \n\t\t\t\tWRITE_PORT_ULONG(cmdport->data2, parm);\n\t\t\tWRITE_PORT_ULONG(cmdport->data1, cmd);\t \n\t\t\tif ((flags & RESP) && ret) {\n\t\t\t\twhile (!IS_DATF(cmdport) &&\n\t\t\t\t       time < CMDIF_TIMEOUT) {\n\t\t\t\t\tudelay(10);\n\t\t\t\t\ttime++;\n\t\t\t\t}\n\t\t\t\tif (time < CMDIF_TIMEOUT) {\t \n\t\t\t\t\tret->retlongs[0] =\n\t\t\t\t\t    READ_PORT_ULONG(cmdport->data1);\n\t\t\t\t\tret->retlongs[1] =\n\t\t\t\t\t    READ_PORT_ULONG(cmdport->data2);\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOSYS;\n\t\t\t\t\tgoto errout;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tudelay(20);\n\t}\n\tif (time == CMDIF_TIMEOUT) {\n\t\terr = -ENODATA;\n\t\tgoto errout;\n\t}\n\tspin_unlock_irqrestore(&cif->lock, irqflags);\n\n\tcif->cmdcnt++;\t\t \n\tcif->cmdtime += time;\n\tif (time > cif->cmdtimemax)\n\t\tcif->cmdtimemax = time;\n\tif (time < cif->cmdtimemin)\n\t\tcif->cmdtimemin = time;\n\tif ((cif->cmdcnt) % 1000 == 0)\n\t\tsnd_printdd\n\t\t    (\"send cmd %d time: %d mintime: %d maxtime %d err: %d\\n\",\n\t\t     cif->cmdcnt, cif->cmdtime, cif->cmdtimemin,\n\t\t     cif->cmdtimemax, cif->errcnt);\n\treturn 0;\n\n      errout:\n\tcif->errcnt++;\n\tspin_unlock_irqrestore(&cif->lock, irqflags);\n\tsnd_printdd\n\t    (\"send cmd %d hw: 0x%x flag: 0x%x cmd: 0x%x parm: 0x%x ret: 0x%x 0x%x CMDE: %d DATF: %d failed %d\\n\",\n\t     cif->cmdcnt, (int)((void *)&(cmdport->stat) - (void *)hwport),\n\t     flags, cmd, parm, ret ? ret->retlongs[0] : 0,\n\t     ret ? ret->retlongs[1] : 0, IS_CMDE(cmdport), IS_DATF(cmdport),\n\t     err);\n\treturn err;\n}\n\nstatic int\nsetmixer(struct cmdif *cif, short num, unsigned short rval, unsigned short lval)\n{\n\tunion cmdret rptr = CMDRET_ZERO;\n\tint i = 0;\n\n\tsnd_printdd(\"sent mixer %d: 0x%x 0x%x\\n\", num, rval, lval);\n\tdo {\n\t\tSEND_SDGV(cif, num, num, rval, lval);\n\t\tSEND_RDGV(cif, num, num, &rptr);\n\t\tif (rptr.retwords[0] == lval && rptr.retwords[1] == rval)\n\t\t\treturn 0;\n\t} while (i++ < MAX_WRITE_RETRY);\n\tsnd_printdd(\"sent mixer failed\\n\");\n\treturn -EIO;\n}\n\nstatic int getpaths(struct cmdif *cif, unsigned char *o)\n{\n\tunsigned char src[E2SINK_MAX];\n\tunsigned char sink[E2SINK_MAX];\n\tint i, j = 0;\n\n\tfor (i = 0; i < E2SINK_MAX; i++) {\n\t\tgetsourcesink(cif, i, i, &src[i], &sink[i]);\n\t\tif (sink[i] < E2SINK_MAX) {\n\t\t\to[j++] = sink[i];\n\t\t\to[j++] = i;\n\t\t}\n\t}\n\treturn j;\n}\n\nstatic int\ngetsourcesink(struct cmdif *cif, unsigned char source, unsigned char sink,\n\t      unsigned char *a, unsigned char *b)\n{\n\tunion cmdret rptr = CMDRET_ZERO;\n\n\tif (SEND_RSSV(cif, source, sink, &rptr) &&\n\t    SEND_RSSV(cif, source, sink, &rptr))\n\t\treturn -EIO;\n\t*a = rptr.retbytes[0];\n\t*b = rptr.retbytes[1];\n\tsnd_printdd(\"getsourcesink 0x%x 0x%x\\n\", *a, *b);\n\treturn 0;\n}\n\nstatic int\ngetsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int *rate)\n{\n\tunsigned char *s;\n\tunsigned int p[2] = { 0, 0 };\n\tint i;\n\tunion cmdret rptr = CMDRET_ZERO;\n\n\ts = intdec;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (*s != 0xff) {\n\t\t\tif (SEND_RSRC(cif, *s, &rptr) &&\n\t\t\t    SEND_RSRC(cif, *s, &rptr))\n\t\t\t\treturn -EIO;\n\t\t\tp[i] += rptr.retwords[1];\n\t\t\tp[i] *= rptr.retwords[2];\n\t\t\tp[i] += rptr.retwords[3];\n\t\t\tp[i] /= 65536;\n\t\t}\n\t\ts++;\n\t}\n\tif (p[0]) {\n\t\tif (p[1] != p[0])\n\t\t\tsnd_printdd(\"rates differ %d %d\\n\", p[0], p[1]);\n\t\t*rate = (unsigned int)p[0];\n\t} else\n\t\t*rate = (unsigned int)p[1];\n\tsnd_printdd(\"getsampleformat %d %d %d\\n\", intdec[0], intdec[1], *rate);\n\treturn 0;\n}\n\nstatic int\nsetsampleformat(struct cmdif *cif,\n\t\tunsigned char mixer, unsigned char id,\n\t\tunsigned char channels, snd_pcm_format_t format)\n{\n\tunsigned char w, ch, sig, order;\n\n\tsnd_printdd\n\t    (\"setsampleformat mixer: %d id: %d channels: %d format: %d\\n\",\n\t     mixer, id, channels, format);\n\tch = channels == 1;\n\tw = snd_pcm_format_width(format) == 8;\n\tsig = snd_pcm_format_unsigned(format) != 0;\n\torder = snd_pcm_format_big_endian(format) != 0;\n\n\tif (SEND_SETF(cif, mixer, w, ch, order, sig, id) &&\n\t    SEND_SETF(cif, mixer, w, ch, order, sig, id)) {\n\t\tsnd_printdd(\"setsampleformat failed\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int\nsetsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int rate)\n{\n\tu32 D, M, N;\n\tunion cmdret rptr = CMDRET_ZERO;\n\tint i;\n\n\tsnd_printdd(\"setsamplerate intdec: %d,%d rate: %d\\n\", intdec[0],\n\t\t    intdec[1], rate);\n\tD = 48000;\n\tM = ((rate == 48000) ? 47999 : rate) * 65536;\n\tN = M % D;\n\tM /= D;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (*intdec != 0xff) {\n\t\t\tdo {\n\t\t\t\tSEND_SSRC(cif, *intdec, D, M, N);\n\t\t\t\tSEND_RSRC(cif, *intdec, &rptr);\n\t\t\t} while (rptr.retwords[1] != D &&\n\t\t\t\t rptr.retwords[2] != M &&\n\t\t\t\t rptr.retwords[3] != N &&\n\t\t\t\t i++ < MAX_WRITE_RETRY);\n\t\t\tif (i > MAX_WRITE_RETRY) {\n\t\t\t\tsnd_printdd(\"sent samplerate %d: %d failed\\n\",\n\t\t\t\t\t    *intdec, rate);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tintdec++;\n\t}\n\treturn 0;\n}\n\nstatic int\ngetmixer(struct cmdif *cif, short num, unsigned short *rval,\n\t unsigned short *lval)\n{\n\tunion cmdret rptr = CMDRET_ZERO;\n\n\tif (SEND_RDGV(cif, num, num, &rptr) && SEND_RDGV(cif, num, num, &rptr))\n\t\treturn -EIO;\n\t*rval = rptr.retwords[0];\n\t*lval = rptr.retwords[1];\n\tsnd_printdd(\"got mixer %d: 0x%x 0x%x\\n\", num, *rval, *lval);\n\treturn 0;\n}\n\nstatic irqreturn_t riptide_handleirq(int irq, void *dev_id)\n{\n\tstruct snd_riptide *chip = dev_id;\n\tstruct cmdif *cif = chip->cif;\n\tstruct snd_pcm_substream *substream[PLAYBACK_SUBSTREAMS + 1];\n\tstruct snd_pcm_runtime *runtime;\n\tstruct pcmhw *data = NULL;\n\tunsigned int pos, period_bytes;\n\tstruct sgd *c;\n\tint i, j;\n\tunsigned int flag;\n\n\tif (!cif)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0; i < PLAYBACK_SUBSTREAMS; i++)\n\t\tsubstream[i] = chip->playback_substream[i];\n\tsubstream[i] = chip->capture_substream;\n\tfor (i = 0; i < PLAYBACK_SUBSTREAMS + 1; i++) {\n\t\tif (!substream[i])\n\t\t\tcontinue;\n\t\truntime = substream[i]->runtime;\n\t\tif (!runtime)\n\t\t\tcontinue;\n\t\tdata = runtime->private_data;\n\t\tif (!data)\n\t\t\tcontinue;\n\t\tif (data->state != ST_STOP) {\n\t\t\tpos = 0;\n\t\t\tfor (j = 0; j < data->pages; j++) {\n\t\t\t\tc = &data->sgdbuf[j];\n\t\t\t\tflag = le32_to_cpu(c->dwStat_Ctl);\n\t\t\t\tif (flag & EOB_STATUS)\n\t\t\t\t\tpos += le32_to_cpu(c->dwSegLen);\n\t\t\t\tif (flag & EOC_STATUS)\n\t\t\t\t\tpos += le32_to_cpu(c->dwSegLen);\n\t\t\t\tif ((flag & EOS_STATUS)\n\t\t\t\t    && (data->state == ST_PLAY)) {\n\t\t\t\t\tdata->state = ST_STOP;\n\t\t\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t\t\t   \"Riptide: DMA stopped unexpectedly\\n\");\n\t\t\t\t}\n\t\t\t\tc->dwStat_Ctl =\n\t\t\t\t    cpu_to_le32(flag &\n\t\t\t\t\t\t~(EOS_STATUS | EOB_STATUS |\n\t\t\t\t\t\t  EOC_STATUS));\n\t\t\t}\n\t\t\tdata->pointer += pos;\n\t\t\tpos += data->oldpos;\n\t\t\tif (data->state != ST_STOP) {\n\t\t\t\tperiod_bytes =\n\t\t\t\t    frames_to_bytes(runtime,\n\t\t\t\t\t\t    runtime->period_size);\n\t\t\t\tsnd_printdd\n\t\t\t\t    (\"interrupt 0x%x after 0x%lx of 0x%lx frames in period\\n\",\n\t\t\t\t     READ_AUDIO_STATUS(cif->hwport),\n\t\t\t\t     bytes_to_frames(runtime, pos),\n\t\t\t\t     runtime->period_size);\n\t\t\t\tj = 0;\n\t\t\t\tif (pos >= period_bytes) {\n\t\t\t\t\tj++;\n\t\t\t\t\twhile (pos >= period_bytes)\n\t\t\t\t\t\tpos -= period_bytes;\n\t\t\t\t}\n\t\t\t\tdata->oldpos = pos;\n\t\t\t\tif (j > 0)\n\t\t\t\t\tsnd_pcm_period_elapsed(substream[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int riptide_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_riptide *chip = card->private_data;\n\n\tchip->in_suspend = 1;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\treturn 0;\n}\n\nstatic int riptide_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_riptide *chip = card->private_data;\n\n\tsnd_riptide_initialize(chip);\n\tsnd_ac97_resume(chip->ac97);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\tchip->in_suspend = 0;\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(riptide_pm, riptide_suspend, riptide_resume);\n#define RIPTIDE_PM_OPS\t&riptide_pm\n#else\n#define RIPTIDE_PM_OPS\tNULL\n#endif  \n\nstatic int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)\n{\n\tunion firmware_version firmware = { .ret = CMDRET_ZERO };\n\tint i, timeout, err;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tWRITE_PORT_ULONG(cif->hwport->port[i].data1, 0);\n\t\tWRITE_PORT_ULONG(cif->hwport->port[i].data2, 0);\n\t}\n\tSET_GRESET(cif->hwport);\n\tudelay(100);\n\tUNSET_GRESET(cif->hwport);\n\tudelay(100);\n\n\tfor (timeout = 100000; --timeout; udelay(10)) {\n\t\tif (IS_READY(cif->hwport) && !IS_GERR(cif->hwport))\n\t\t\tbreak;\n\t}\n\tif (!timeout) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"Riptide: device not ready, audio status: 0x%x \"\n\t\t\t   \"ready: %d gerr: %d\\n\",\n\t\t\t   READ_AUDIO_STATUS(cif->hwport),\n\t\t\t   IS_READY(cif->hwport), IS_GERR(cif->hwport));\n\t\treturn -EIO;\n\t} else {\n\t\tsnd_printdd\n\t\t\t(\"Riptide: audio status: 0x%x ready: %d gerr: %d\\n\",\n\t\t\t READ_AUDIO_STATUS(cif->hwport),\n\t\t\t IS_READY(cif->hwport), IS_GERR(cif->hwport));\n\t}\n\n\tSEND_GETV(cif, &firmware.ret);\n\tsnd_printdd(\"Firmware version: ASIC: %d CODEC %d AUXDSP %d PROG %d\\n\",\n\t\t    firmware.firmware.ASIC, firmware.firmware.CODEC,\n\t\t    firmware.firmware.AUXDSP, firmware.firmware.PROG);\n\n\tif (!chip)\n\t\treturn 1;\n\n\tfor (i = 0; i < FIRMWARE_VERSIONS; i++) {\n\t\tif (!memcmp(&firmware_versions[i], &firmware, sizeof(firmware)))\n\t\t\treturn 1;  \n\n\t}\n\n\tsnd_printdd(\"Writing Firmware\\n\");\n\tif (!chip->fw_entry) {\n\t\terr = request_firmware(&chip->fw_entry, \"riptide.hex\",\n\t\t\t\t       &chip->pci->dev);\n\t\tif (err) {\n\t\t\tsnd_printk(KERN_ERR\n\t\t\t\t   \"Riptide: Firmware not available %d\\n\", err);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\terr = loadfirmware(cif, chip->fw_entry->data, chip->fw_entry->size);\n\tif (err) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"Riptide: Could not load firmware %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tchip->firmware = firmware;\n\n\treturn 1;  \n}\n\nstatic int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)\n{\n\tunion cmdret rptr = CMDRET_ZERO;\n\tint err, tries;\n\n\tif (!cif)\n\t\treturn -EINVAL;\n\n\tcif->cmdcnt = 0;\n\tcif->cmdtime = 0;\n\tcif->cmdtimemax = 0;\n\tcif->cmdtimemin = 0xffffffff;\n\tcif->errcnt = 0;\n\tcif->is_reset = 0;\n\n\ttries = RESET_TRIES;\n\tdo {\n\t\terr = try_to_load_firmware(cif, chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} while (!err && --tries);\n\n\tSEND_SACR(cif, 0, AC97_RESET);\n\tSEND_RACR(cif, AC97_RESET, &rptr);\n\tsnd_printdd(\"AC97: 0x%x 0x%x\\n\", rptr.retlongs[0], rptr.retlongs[1]);\n\n\tSEND_PLST(cif, 0);\n\tSEND_SLST(cif, 0);\n\tSEND_DLST(cif, 0);\n\tSEND_ALST(cif, 0);\n\tSEND_KDMA(cif);\n\n\twritearm(cif, 0x301F8, 1, 1);\n\twritearm(cif, 0x301F4, 1, 1);\n\n\tSEND_LSEL(cif, MODEM_CMD, 0, 0, MODEM_INTDEC, MODEM_MERGER,\n\t\t  MODEM_SPLITTER, MODEM_MIXER);\n\tsetmixer(cif, MODEM_MIXER, 0x7fff, 0x7fff);\n\talloclbuspath(cif, ARM2LBUS_FIFO13, lbus_play_modem, NULL, NULL);\n\n\tSEND_LSEL(cif, FM_CMD, 0, 0, FM_INTDEC, FM_MERGER, FM_SPLITTER,\n\t\t  FM_MIXER);\n\tsetmixer(cif, FM_MIXER, 0x7fff, 0x7fff);\n\twritearm(cif, 0x30648 + FM_MIXER * 4, 0x01, 0x00000005);\n\twritearm(cif, 0x301A8, 0x02, 0x00000002);\n\twritearm(cif, 0x30264, 0x08, 0xffffffff);\n\talloclbuspath(cif, OPL3_SAMPLE, lbus_play_opl3, NULL, NULL);\n\n\tSEND_SSRC(cif, I2S_INTDEC, 48000,\n\t\t  ((u32) I2S_RATE * 65536) / 48000,\n\t\t  ((u32) I2S_RATE * 65536) % 48000);\n\tSEND_LSEL(cif, I2S_CMD0, 0, 0, I2S_INTDEC, I2S_MERGER, I2S_SPLITTER,\n\t\t  I2S_MIXER);\n\tSEND_SI2S(cif, 1);\n\talloclbuspath(cif, ARM2LBUS_FIFO0, lbus_play_i2s, NULL, NULL);\n\talloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_out, NULL, NULL);\n\talloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_outhp, NULL, NULL);\n\n\tSET_AIACK(cif->hwport);\n\tSET_AIE(cif->hwport);\n\tSET_AIACK(cif->hwport);\n\tcif->is_reset = 1;\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_riptide_playback = {\n\t.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\n\t    SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8\n\t    | SNDRV_PCM_FMTBIT_U16_LE,\n\t.rates = SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 5500,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = (64 * 1024),\n\t.period_bytes_min = PAGE_SIZE >> 1,\n\t.period_bytes_max = PAGE_SIZE << 8,\n\t.periods_min = 2,\n\t.periods_max = 64,\n\t.fifo_size = 0,\n};\nstatic const struct snd_pcm_hardware snd_riptide_capture = {\n\t.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\n\t    SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8\n\t    | SNDRV_PCM_FMTBIT_U16_LE,\n\t.rates = SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 5500,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = (64 * 1024),\n\t.period_bytes_min = PAGE_SIZE >> 1,\n\t.period_bytes_max = PAGE_SIZE << 3,\n\t.periods_min = 2,\n\t.periods_max = 64,\n\t.fifo_size = 0,\n};\n\nstatic snd_pcm_uframes_t snd_riptide_pointer(struct snd_pcm_substream\n\t\t\t\t\t     *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tstruct cmdif *cif = chip->cif;\n\tunion cmdret rptr = CMDRET_ZERO;\n\tsnd_pcm_uframes_t ret;\n\n\tSEND_GPOS(cif, 0, data->id, &rptr);\n\tif (data->size && runtime->period_size) {\n\t\tsnd_printdd\n\t\t    (\"pointer stream %d position 0x%x(0x%x in buffer) bytes 0x%lx(0x%lx in period) frames\\n\",\n\t\t     data->id, rptr.retlongs[1], rptr.retlongs[1] % data->size,\n\t\t     bytes_to_frames(runtime, rptr.retlongs[1]),\n\t\t     bytes_to_frames(runtime,\n\t\t\t\t     rptr.retlongs[1]) % runtime->period_size);\n\t\tif (rptr.retlongs[1] > data->pointer)\n\t\t\tret =\n\t\t\t    bytes_to_frames(runtime,\n\t\t\t\t\t    rptr.retlongs[1] % data->size);\n\t\telse\n\t\t\tret =\n\t\t\t    bytes_to_frames(runtime,\n\t\t\t\t\t    data->pointer % data->size);\n\t} else {\n\t\tsnd_printdd(\"stream not started or strange parms (%d %ld)\\n\",\n\t\t\t    data->size, runtime->period_size);\n\t\tret = bytes_to_frames(runtime, 0);\n\t}\n\treturn ret;\n}\n\nstatic int snd_riptide_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tint i, j;\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tstruct cmdif *cif = chip->cif;\n\tunion cmdret rptr = CMDRET_ZERO;\n\n\tspin_lock(&chip->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (!(data->state & ST_PLAY)) {\n\t\t\tSEND_SSTR(cif, data->id, data->sgdlist.addr);\n\t\t\tSET_AIE(cif->hwport);\n\t\t\tdata->state = ST_PLAY;\n\t\t\tif (data->mixer != 0xff)\n\t\t\t\tsetmixer(cif, data->mixer, 0x7fff, 0x7fff);\n\t\t\tchip->openstreams++;\n\t\t\tdata->oldpos = 0;\n\t\t\tdata->pointer = 0;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (data->mixer != 0xff)\n\t\t\tsetmixer(cif, data->mixer, 0, 0);\n\t\tsetmixer(cif, data->mixer, 0, 0);\n\t\tSEND_KSTR(cif, data->id);\n\t\tdata->state = ST_STOP;\n\t\tchip->openstreams--;\n\t\tj = 0;\n\t\tdo {\n\t\t\ti = rptr.retlongs[1];\n\t\t\tSEND_GPOS(cif, 0, data->id, &rptr);\n\t\t\tudelay(1);\n\t\t} while (i != rptr.retlongs[1] && j++ < MAX_WRITE_RETRY);\n\t\tif (j > MAX_WRITE_RETRY)\n\t\t\tsnd_printk(KERN_ERR \"Riptide: Could not stop stream!\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (!(data->state & ST_PAUSE)) {\n\t\t\tSEND_PSTR(cif, data->id);\n\t\t\tdata->state |= ST_PAUSE;\n\t\t\tchip->openstreams--;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (data->state & ST_PAUSE) {\n\t\t\tSEND_SSTR(cif, data->id, data->sgdlist.addr);\n\t\t\tdata->state &= ~ST_PAUSE;\n\t\t\tchip->openstreams++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&chip->lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock(&chip->lock);\n\treturn 0;\n}\n\nstatic int snd_riptide_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tstruct cmdif *cif = chip->cif;\n\tconst unsigned char *lbuspath = NULL;\n\tunsigned int rate, channels;\n\tint err = 0;\n\tsnd_pcm_format_t format;\n\n\tif (snd_BUG_ON(!cif || !data))\n\t\treturn -EINVAL;\n\n\tsnd_printdd(\"prepare id %d ch: %d f:0x%x r:%d\\n\", data->id,\n\t\t    runtime->channels, runtime->format, runtime->rate);\n\n\tspin_lock_irq(&chip->lock);\n\tchannels = runtime->channels;\n\tformat = runtime->format;\n\trate = runtime->rate;\n\tswitch (channels) {\n\tcase 1:\n\t\tif (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)\n\t\t\tlbuspath = data->paths.noconv;\n\t\telse\n\t\t\tlbuspath = data->paths.mono;\n\t\tbreak;\n\tcase 2:\n\t\tif (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)\n\t\t\tlbuspath = data->paths.noconv;\n\t\telse\n\t\t\tlbuspath = data->paths.stereo;\n\t\tbreak;\n\t}\n\tsnd_printdd(\"use sgdlist at 0x%p\\n\",\n\t\t    data->sgdlist.area);\n\tif (data->sgdlist.area) {\n\t\tunsigned int i, j, size, pages, f, pt, period;\n\t\tstruct sgd *c, *p = NULL;\n\n\t\tsize = frames_to_bytes(runtime, runtime->buffer_size);\n\t\tperiod = frames_to_bytes(runtime, runtime->period_size);\n\t\tf = PAGE_SIZE;\n\t\twhile ((size + (f >> 1) - 1) <= (f << 7) && (f << 1) > period)\n\t\t\tf = f >> 1;\n\t\tpages = DIV_ROUND_UP(size, f);\n\t\tdata->size = size;\n\t\tdata->pages = pages;\n\t\tsnd_printdd\n\t\t    (\"create sgd size: 0x%x pages %d of size 0x%x for period 0x%x\\n\",\n\t\t     size, pages, f, period);\n\t\tpt = 0;\n\t\tj = 0;\n\t\tfor (i = 0; i < pages; i++) {\n\t\t\tunsigned int ofs, addr;\n\t\t\tc = &data->sgdbuf[i];\n\t\t\tif (p)\n\t\t\t\tp->dwNextLink = cpu_to_le32(data->sgdlist.addr +\n\t\t\t\t\t\t\t    (i *\n\t\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t\t    sgd)));\n\t\t\tc->dwNextLink = cpu_to_le32(data->sgdlist.addr);\n\t\t\tofs = j << PAGE_SHIFT;\n\t\t\taddr = snd_pcm_sgbuf_get_addr(substream, ofs) + pt;\n\t\t\tc->dwSegPtrPhys = cpu_to_le32(addr);\n\t\t\tpt = (pt + f) % PAGE_SIZE;\n\t\t\tif (pt == 0)\n\t\t\t\tj++;\n\t\t\tc->dwSegLen = cpu_to_le32(f);\n\t\t\tc->dwStat_Ctl =\n\t\t\t    cpu_to_le32(IEOB_ENABLE | IEOS_ENABLE |\n\t\t\t\t\tIEOC_ENABLE);\n\t\t\tp = c;\n\t\t\tsize -= f;\n\t\t}\n\t\tdata->sgdbuf[i].dwSegLen = cpu_to_le32(size);\n\t}\n\tif (lbuspath && lbuspath != data->lbuspath) {\n\t\tif (data->lbuspath)\n\t\t\tfreelbuspath(cif, data->source, data->lbuspath);\n\t\talloclbuspath(cif, data->source, lbuspath,\n\t\t\t      &data->mixer, data->intdec);\n\t\tdata->lbuspath = lbuspath;\n\t\tdata->rate = 0;\n\t}\n\tif (data->rate != rate || data->format != format ||\n\t    data->channels != channels) {\n\t\tdata->rate = rate;\n\t\tdata->format = format;\n\t\tdata->channels = channels;\n\t\tif (setsampleformat\n\t\t    (cif, data->mixer, data->id, channels, format)\n\t\t    || setsamplerate(cif, data->intdec, rate))\n\t\t\terr = -EIO;\n\t}\n\tspin_unlock_irq(&chip->lock);\n\treturn err;\n}\n\nstatic int\nsnd_riptide_hw_params(struct snd_pcm_substream *substream,\n\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tstruct snd_dma_buffer *sgdlist = &data->sgdlist;\n\tint err;\n\n\tsnd_printdd(\"hw params id %d (sgdlist: 0x%p 0x%lx %d)\\n\", data->id,\n\t\t    sgdlist->area, (unsigned long)sgdlist->addr,\n\t\t    (int)sgdlist->bytes);\n\tif (sgdlist->area)\n\t\tsnd_dma_free_pages(sgdlist);\n\terr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t  sizeof(struct sgd) * (DESC_MAX_MASK + 1),\n\t\t\t\t  sgdlist);\n\tif (err < 0) {\n\t\tsnd_printk(KERN_ERR \"Riptide: failed to alloc %d dma bytes\\n\",\n\t\t\t   (int)sizeof(struct sgd) * (DESC_MAX_MASK + 1));\n\t\treturn err;\n\t}\n\tdata->sgdbuf = (struct sgd *)sgdlist->area;\n\treturn 0;\n}\n\nstatic int snd_riptide_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tstruct cmdif *cif = chip->cif;\n\n\tif (cif && data) {\n\t\tif (data->lbuspath)\n\t\t\tfreelbuspath(cif, data->source, data->lbuspath);\n\t\tdata->lbuspath = NULL;\n\t\tdata->source = 0xff;\n\t\tdata->intdec[0] = 0xff;\n\t\tdata->intdec[1] = 0xff;\n\n\t\tif (data->sgdlist.area) {\n\t\t\tsnd_dma_free_pages(&data->sgdlist);\n\t\t\tdata->sgdlist.area = NULL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_riptide_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmhw *data;\n\tint sub_num = substream->number;\n\n\tchip->playback_substream[sub_num] = substream;\n\truntime->hw = snd_riptide_playback;\n\n\tdata = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->paths = lbus_play_paths[sub_num];\n\tdata->id = play_ids[sub_num];\n\tdata->source = play_sources[sub_num];\n\tdata->intdec[0] = 0xff;\n\tdata->intdec[1] = 0xff;\n\tdata->state = ST_STOP;\n\truntime->private_data = data;\n\treturn snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIODS);\n}\n\nstatic int snd_riptide_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmhw *data;\n\n\tchip->capture_substream = substream;\n\truntime->hw = snd_riptide_capture;\n\n\tdata = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->paths = lbus_rec_path;\n\tdata->id = PADC;\n\tdata->source = ACLNK2PADC;\n\tdata->intdec[0] = 0xff;\n\tdata->intdec[1] = 0xff;\n\tdata->state = ST_STOP;\n\truntime->private_data = data;\n\treturn snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIODS);\n}\n\nstatic int snd_riptide_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\tint sub_num = substream->number;\n\n\tsubstream->runtime->private_data = NULL;\n\tchip->playback_substream[sub_num] = NULL;\n\tkfree(data);\n\treturn 0;\n}\n\nstatic int snd_riptide_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\n\tstruct pcmhw *data = get_pcmhwdev(substream);\n\n\tsubstream->runtime->private_data = NULL;\n\tchip->capture_substream = NULL;\n\tkfree(data);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_riptide_playback_ops = {\n\t.open = snd_riptide_playback_open,\n\t.close = snd_riptide_playback_close,\n\t.hw_params = snd_riptide_hw_params,\n\t.hw_free = snd_riptide_hw_free,\n\t.prepare = snd_riptide_prepare,\n\t.trigger = snd_riptide_trigger,\n\t.pointer = snd_riptide_pointer,\n};\nstatic const struct snd_pcm_ops snd_riptide_capture_ops = {\n\t.open = snd_riptide_capture_open,\n\t.close = snd_riptide_capture_close,\n\t.hw_params = snd_riptide_hw_params,\n\t.hw_free = snd_riptide_hw_free,\n\t.prepare = snd_riptide_prepare,\n\t.trigger = snd_riptide_trigger,\n\t.pointer = snd_riptide_pointer,\n};\n\nstatic int snd_riptide_pcm(struct snd_riptide *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"RIPTIDE\", device, PLAYBACK_SUBSTREAMS, 1,\n\t\t\t  &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_riptide_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_riptide_capture_ops);\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"RIPTIDE\");\n\tchip->pcm = pcm;\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev, 64 * 1024, 128 * 1024);\n\treturn 0;\n}\n\nstatic irqreturn_t\nsnd_riptide_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_riptide *chip = dev_id;\n\tstruct cmdif *cif = chip->cif;\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tif (cif) {\n\t\tchip->received_irqs++;\n\t\tif (IS_EOBIRQ(cif->hwport) || IS_EOSIRQ(cif->hwport) ||\n\t\t    IS_EOCIRQ(cif->hwport)) {\n\t\t\tchip->handled_irqs++;\n\t\t\tret = IRQ_WAKE_THREAD;\n\t\t}\n\t\tif (chip->rmidi && IS_MPUIRQ(cif->hwport)) {\n\t\t\tchip->handled_irqs++;\n\t\t\tsnd_mpu401_uart_interrupt(irq,\n\t\t\t\t\t\t  chip->rmidi->private_data);\n\t\t}\n\t\tSET_AIACK(cif->hwport);\n\t}\n\treturn ret;\n}\n\nstatic void\nsnd_riptide_codec_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\tunsigned short val)\n{\n\tstruct snd_riptide *chip = ac97->private_data;\n\tstruct cmdif *cif = chip->cif;\n\tunion cmdret rptr = CMDRET_ZERO;\n\tint i = 0;\n\n\tif (snd_BUG_ON(!cif))\n\t\treturn;\n\n\tsnd_printdd(\"Write AC97 reg 0x%x 0x%x\\n\", reg, val);\n\tdo {\n\t\tSEND_SACR(cif, val, reg);\n\t\tSEND_RACR(cif, reg, &rptr);\n\t} while (rptr.retwords[1] != val && i++ < MAX_WRITE_RETRY);\n\tif (i > MAX_WRITE_RETRY)\n\t\tsnd_printdd(\"Write AC97 reg failed\\n\");\n}\n\nstatic unsigned short snd_riptide_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t     unsigned short reg)\n{\n\tstruct snd_riptide *chip = ac97->private_data;\n\tstruct cmdif *cif = chip->cif;\n\tunion cmdret rptr = CMDRET_ZERO;\n\n\tif (snd_BUG_ON(!cif))\n\t\treturn 0;\n\n\tif (SEND_RACR(cif, reg, &rptr) != 0)\n\t\tSEND_RACR(cif, reg, &rptr);\n\tsnd_printdd(\"Read AC97 reg 0x%x got 0x%x\\n\", reg, rptr.retwords[1]);\n\treturn rptr.retwords[1];\n}\n\nstatic int snd_riptide_initialize(struct snd_riptide *chip)\n{\n\tstruct cmdif *cif;\n\tunsigned int device_id;\n\tint err;\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn -EINVAL;\n\n\tcif = chip->cif;\n\tif (!cif) {\n\t\tcif = kzalloc(sizeof(struct cmdif), GFP_KERNEL);\n\t\tif (!cif)\n\t\t\treturn -ENOMEM;\n\t\tcif->hwport = (struct riptideport *)chip->port;\n\t\tspin_lock_init(&cif->lock);\n\t\tchip->cif = cif;\n\t}\n\tcif->is_reset = 0;\n\terr = riptide_reset(cif, chip);\n\tif (err)\n\t\treturn err;\n\tdevice_id = chip->device_id;\n\tswitch (device_id) {\n\tcase 0x4310:\n\tcase 0x4320:\n\tcase 0x4330:\n\t\tsnd_printdd(\"Modem enable?\\n\");\n\t\tSEND_SETDPLL(cif);\n\t\tbreak;\n\t}\n\tsnd_printdd(\"Enabling MPU IRQs\\n\");\n\tif (chip->rmidi)\n\t\tSET_EMPUIRQ(cif->hwport);\n\treturn err;\n}\n\nstatic void snd_riptide_free(struct snd_card *card)\n{\n\tstruct snd_riptide *chip = card->private_data;\n\tstruct cmdif *cif;\n\n\tcif = chip->cif;\n\tif (cif) {\n\t\tSET_GRESET(cif->hwport);\n\t\tudelay(100);\n\t\tUNSET_GRESET(cif->hwport);\n\t\tkfree(chip->cif);\n\t}\n\trelease_firmware(chip->fw_entry);\n}\n\nstatic int\nsnd_riptide_create(struct snd_card *card, struct pci_dev *pci)\n{\n\tstruct snd_riptide *chip = card->private_data;\n\tstruct riptideport *hwport;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->openstreams = 0;\n\tchip->port = pci_resource_start(pci, 0);\n\tchip->received_irqs = 0;\n\tchip->handled_irqs = 0;\n\tchip->cif = NULL;\n\tcard->private_free = snd_riptide_free;\n\n\terr = pci_request_regions(pci, \"RIPTIDE\");\n\tif (err < 0)\n\t\treturn err;\n\thwport = (struct riptideport *)chip->port;\n\tUNSET_AIE(hwport);\n\n\tif (devm_request_threaded_irq(&pci->dev, pci->irq,\n\t\t\t\t      snd_riptide_interrupt,\n\t\t\t\t      riptide_handleirq, IRQF_SHARED,\n\t\t\t\t      KBUILD_MODNAME, chip)) {\n\t\tsnd_printk(KERN_ERR \"Riptide: unable to grab IRQ %d\\n\",\n\t\t\t   pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tchip->device_id = pci->device;\n\tpci_set_master(pci);\n\terr = snd_riptide_initialize(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void\nsnd_riptide_proc_read(struct snd_info_entry *entry,\n\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_riptide *chip = entry->private_data;\n\tstruct pcmhw *data;\n\tint i;\n\tstruct cmdif *cif = NULL;\n\tunsigned char p[256];\n\tunsigned short rval = 0, lval = 0;\n\tunsigned int rate;\n\n\tif (!chip)\n\t\treturn;\n\n\tsnd_iprintf(buffer, \"%s\\n\\n\", chip->card->longname);\n\tsnd_iprintf(buffer, \"Device ID: 0x%x\\nReceived IRQs: (%ld)%ld\\nPorts:\",\n\t\t    chip->device_id, chip->handled_irqs, chip->received_irqs);\n\tfor (i = 0; i < 64; i += 4)\n\t\tsnd_iprintf(buffer, \"%c%02x: %08x\",\n\t\t\t    (i % 16) ? ' ' : '\\n', i, inl(chip->port + i));\n\tcif = chip->cif;\n\tif (cif) {\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"\\nVersion: ASIC: %d CODEC: %d AUXDSP: %d PROG: %d\",\n\t\t\t    chip->firmware.firmware.ASIC,\n\t\t\t    chip->firmware.firmware.CODEC,\n\t\t\t    chip->firmware.firmware.AUXDSP,\n\t\t\t    chip->firmware.firmware.PROG);\n\t\tsnd_iprintf(buffer, \"\\nDigital mixer:\");\n\t\tfor (i = 0; i < 12; i++) {\n\t\t\tgetmixer(cif, i, &rval, &lval);\n\t\t\tsnd_iprintf(buffer, \"\\n %d: %d %d\", i, rval, lval);\n\t\t}\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"\\nARM Commands num: %d failed: %d time: %d max: %d min: %d\",\n\t\t\t    cif->cmdcnt, cif->errcnt,\n\t\t\t    cif->cmdtime, cif->cmdtimemax, cif->cmdtimemin);\n\t}\n\tsnd_iprintf(buffer, \"\\nOpen streams %d:\\n\", chip->openstreams);\n\tfor (i = 0; i < PLAYBACK_SUBSTREAMS; i++) {\n\t\tif (!chip->playback_substream[i] ||\n\t\t    !chip->playback_substream[i]->runtime)\n\t\t\tcontinue;\n\t\tdata = chip->playback_substream[i]->runtime->private_data;\n\t\tif (data) {\n\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"stream: %d mixer: %d source: %d (%d,%d)\\n\",\n\t\t\t\t    data->id, data->mixer, data->source,\n\t\t\t\t    data->intdec[0], data->intdec[1]);\n\t\t\tif (!(getsamplerate(cif, data->intdec, &rate)))\n\t\t\t\tsnd_iprintf(buffer, \"rate: %d\\n\", rate);\n\t\t}\n\t}\n\tif (chip->capture_substream && chip->capture_substream->runtime) {\n\t\tdata = chip->capture_substream->runtime->private_data;\n\t\tif (data) {\n\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"stream: %d mixer: %d source: %d (%d,%d)\\n\",\n\t\t\t\t    data->id, data->mixer,\n\t\t\t\t    data->source, data->intdec[0], data->intdec[1]);\n\t\t\tif (!(getsamplerate(cif, data->intdec, &rate)))\n\t\t\t\tsnd_iprintf(buffer, \"rate: %d\\n\", rate);\n\t\t}\n\t}\n\tsnd_iprintf(buffer, \"Paths:\\n\");\n\ti = getpaths(cif, p);\n\twhile (i >= 2) {\n\t\ti -= 2;\n\t\tsnd_iprintf(buffer, \"%x->%x \", p[i], p[i + 1]);\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void snd_riptide_proc_init(struct snd_riptide *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"riptide\", chip,\n\t\t\t     snd_riptide_proc_read);\n}\n\nstatic int snd_riptide_mixer(struct snd_riptide *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err = 0;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_riptide_codec_write,\n\t\t.read = snd_riptide_codec_read,\n\t};\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.scaps = AC97_SCAP_SKIP_MODEM;\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->ac97_bus = pbus;\n\tac97.pci = chip->pci;\n\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\treturn err;\n}\n\n#ifdef SUPPORT_JOYSTICK\n\nstatic int\nsnd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstatic int dev;\n\tstruct gameport *gameport;\n\tint ret;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tif (!enable[dev]) {\n\t\tret = -ENOENT;\n\t\tgoto inc_dev;\n\t}\n\n\tif (!joystick_port[dev]) {\n\t\tret = 0;\n\t\tgoto inc_dev;\n\t}\n\n\tgameport = gameport_allocate_port();\n\tif (!gameport) {\n\t\tret = -ENOMEM;\n\t\tgoto inc_dev;\n\t}\n\tif (!request_region(joystick_port[dev], 8, \"Riptide gameport\")) {\n\t\tsnd_printk(KERN_WARNING\n\t\t\t   \"Riptide: cannot grab gameport 0x%x\\n\",\n\t\t\t   joystick_port[dev]);\n\t\tgameport_free_port(gameport);\n\t\tret = -EBUSY;\n\t\tgoto inc_dev;\n\t}\n\n\tgameport->io = joystick_port[dev];\n\tgameport_register_port(gameport);\n\tpci_set_drvdata(pci, gameport);\n\n\tret = 0;\ninc_dev:\n\tdev++;\n\treturn ret;\n}\n\nstatic void snd_riptide_joystick_remove(struct pci_dev *pci)\n{\n\tstruct gameport *gameport = pci_get_drvdata(pci);\n\tif (gameport) {\n\t\trelease_region(gameport->io, 8);\n\t\tgameport_unregister_port(gameport);\n\t}\n}\n#endif\n\nstatic int\n__snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_riptide *chip;\n\tunsigned short val;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\terr = snd_riptide_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_riptide_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_riptide_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = LEGACY_ENABLE_ALL;\n\tif (opl3_port[dev])\n\t\tval |= LEGACY_ENABLE_FM;\n#ifdef SUPPORT_JOYSTICK\n\tif (joystick_port[dev])\n\t\tval |= LEGACY_ENABLE_GAMEPORT;\n#endif\n\tif (mpu_port[dev])\n\t\tval |= LEGACY_ENABLE_MPU_INT | LEGACY_ENABLE_MPU;\n\tval |= (chip->irq << 4) & 0xf0;\n\tpci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, val);\n\tif (mpu_port[dev]) {\n\t\tval = mpu_port[dev];\n\t\tpci_write_config_word(chip->pci, PCI_EXT_MPU_Base, val);\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,\n\t\t\t\t\t  val, MPU401_INFO_IRQ_HOOK, -1,\n\t\t\t\t\t  &chip->rmidi);\n\t\tif (err < 0)\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"Riptide: Can't Allocate MPU at 0x%x\\n\",\n\t\t\t\t   val);\n\t\telse\n\t\t\tchip->mpuaddr = val;\n\t}\n\tif (opl3_port[dev]) {\n\t\tval = opl3_port[dev];\n\t\tpci_write_config_word(chip->pci, PCI_EXT_FM_Base, val);\n\t\terr = snd_opl3_create(card, val, val + 2,\n\t\t\t\t      OPL3_HW_RIPTIDE, 0, &chip->opl3);\n\t\tif (err < 0)\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"Riptide: Can't Allocate OPL3 at 0x%x\\n\",\n\t\t\t\t   val);\n\t\telse {\n\t\t\tchip->opladdr = val;\n\t\t\terr = snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL);\n\t\t\tif (err < 0)\n\t\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t\t   \"Riptide: Can't Allocate OPL3-HWDEP\\n\");\n\t\t}\n\t}\n#ifdef SUPPORT_JOYSTICK\n\tif (joystick_port[dev]) {\n\t\tval = joystick_port[dev];\n\t\tpci_write_config_word(chip->pci, PCI_EXT_Game_Base, val);\n\t\tchip->gameaddr = val;\n\t}\n#endif\n\n\tstrcpy(card->driver, \"RIPTIDE\");\n\tstrcpy(card->shortname, \"Riptide\");\n#ifdef SUPPORT_JOYSTICK\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x gameport 0x%x\",\n\t\t  card->shortname, chip->port, chip->irq, chip->mpuaddr,\n\t\t  chip->opladdr, chip->gameaddr);\n#else\n\tscnprintf(card->longname, sizeof(card->longname),\n\t\t  \"%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x\",\n\t\t  card->shortname, chip->port, chip->irq, chip->mpuaddr,\n\t\t  chip->opladdr);\n#endif\n\tsnd_riptide_proc_init(chip);\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int\nsnd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_card_riptide_probe(pci, pci_id));\n}\n\nstatic struct pci_driver driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_riptide_ids,\n\t.probe = snd_card_riptide_probe,\n\t.driver = {\n\t\t.pm = RIPTIDE_PM_OPS,\n\t},\n};\n\n#ifdef SUPPORT_JOYSTICK\nstatic struct pci_driver joystick_driver = {\n\t.name = KBUILD_MODNAME \"-joystick\",\n\t.id_table = snd_riptide_joystick_ids,\n\t.probe = snd_riptide_joystick_probe,\n\t.remove = snd_riptide_joystick_remove,\n};\n#endif\n\nstatic int __init alsa_card_riptide_init(void)\n{\n\tint err;\n\terr = pci_register_driver(&driver);\n\tif (err < 0)\n\t\treturn err;\n#if defined(SUPPORT_JOYSTICK)\n\terr = pci_register_driver(&joystick_driver);\n\t \n\tif (err < 0)\n\t\tpci_unregister_driver(&driver);\n#endif\n\treturn err;\n}\n\nstatic void __exit alsa_card_riptide_exit(void)\n{\n\tpci_unregister_driver(&driver);\n#if defined(SUPPORT_JOYSTICK)\n\tpci_unregister_driver(&joystick_driver);\n#endif\n}\n\nmodule_init(alsa_card_riptide_init);\nmodule_exit(alsa_card_riptide_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}