{
  "module_name": "ca0106_mixer.c",
  "hash_id": "76534d91349f925e84eae09ec442fa2c7753e2881499ff30246c65ccbc9938ce",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ca0106/ca0106_mixer.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n#include <linux/io.h>\n\n#include \"ca0106.h\"\n\nstatic void ca0106_spdif_enable(struct snd_ca0106 *emu)\n{\n\tunsigned int val;\n\n\tif (emu->spdif_enable) {\n\t\t \n\t\tsnd_ca0106_ptr_write(emu, SPDIF_SELECT1, 0, 0xf);\n\t\tsnd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x0b000000);\n\t\tval = snd_ca0106_ptr_read(emu, CAPTURE_CONTROL, 0) & ~0x1000;\n\t\tsnd_ca0106_ptr_write(emu, CAPTURE_CONTROL, 0, val);\n\t\tval = inl(emu->port + CA0106_GPIO) & ~0x101;\n\t\toutl(val, emu->port + CA0106_GPIO);\n\n\t} else {\n\t\t \n\t\tsnd_ca0106_ptr_write(emu, SPDIF_SELECT1, 0, 0xf);\n\t\tsnd_ca0106_ptr_write(emu, SPDIF_SELECT2, 0, 0x000f0000);\n\t\tval = snd_ca0106_ptr_read(emu, CAPTURE_CONTROL, 0) | 0x1000;\n\t\tsnd_ca0106_ptr_write(emu, CAPTURE_CONTROL, 0, val);\n\t\tval = inl(emu->port + CA0106_GPIO) | 0x101;\n\t\toutl(val, emu->port + CA0106_GPIO);\n\t}\n}\n\nstatic void ca0106_set_capture_source(struct snd_ca0106 *emu)\n{\n\tunsigned int val = emu->capture_source;\n\tunsigned int source, mask;\n\tsource = (val << 28) | (val << 24) | (val << 20) | (val << 16);\n\tmask = snd_ca0106_ptr_read(emu, CAPTURE_SOURCE, 0) & 0xffff;\n\tsnd_ca0106_ptr_write(emu, CAPTURE_SOURCE, 0, source | mask);\n}\n\nstatic void ca0106_set_i2c_capture_source(struct snd_ca0106 *emu,\n\t\t\t\t\t  unsigned int val, int force)\n{\n\tunsigned int ngain, ogain;\n\tu32 source;\n\n\tsnd_ca0106_i2c_write(emu, ADC_MUX, 0);  \n\tngain = emu->i2c_capture_volume[val][0];  \n\togain = emu->i2c_capture_volume[emu->i2c_capture_source][0];  \n\tif (force || ngain != ogain)\n\t\tsnd_ca0106_i2c_write(emu, ADC_ATTEN_ADCL, ngain & 0xff);\n\tngain = emu->i2c_capture_volume[val][1];  \n\togain = emu->i2c_capture_volume[emu->i2c_capture_source][1];  \n\tif (force || ngain != ogain)\n\t\tsnd_ca0106_i2c_write(emu, ADC_ATTEN_ADCR, ngain & 0xff);\n\tsource = 1 << val;\n\tsnd_ca0106_i2c_write(emu, ADC_MUX, source);  \n\temu->i2c_capture_source = val;\n}\n\nstatic void ca0106_set_capture_mic_line_in(struct snd_ca0106 *emu)\n{\n\tu32 tmp;\n\n\tif (emu->capture_mic_line_in) {\n\t\t   \n\t\ttmp = inl(emu->port + CA0106_GPIO) & ~0x400;\n\t\ttmp = tmp | 0x400;\n\t\toutl(tmp, emu->port + CA0106_GPIO);\n\t\t \n\t} else {\n\t\t   \n\t\ttmp = inl(emu->port + CA0106_GPIO) & ~0x400;\n\t\toutl(tmp, emu->port + CA0106_GPIO);\n\t\t \n\t}\n}\n\nstatic void ca0106_set_spdif_bits(struct snd_ca0106 *emu, int idx)\n{\n\tsnd_ca0106_ptr_write(emu, SPCS0 + idx, 0, emu->spdif_str_bits[idx]);\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(snd_ca0106_db_scale1, -5175, 25, 1);\nstatic const DECLARE_TLV_DB_SCALE(snd_ca0106_db_scale2, -10350, 50, 1);\n\n#define snd_ca0106_shared_spdif_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ca0106_shared_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = emu->spdif_enable;\n\treturn 0;\n}\n\nstatic int snd_ca0106_shared_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tval = !!ucontrol->value.integer.value[0];\n\tchange = (emu->spdif_enable != val);\n\tif (change) {\n\t\temu->spdif_enable = val;\n\t\tca0106_spdif_enable(emu);\n\t}\n        return change;\n}\n\nstatic int snd_ca0106_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[6] = {\n\t\t\"IEC958 out\", \"i2s mixer out\", \"IEC958 in\", \"i2s in\", \"AC97 in\", \"SRC out\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 6, texts);\n}\n\nstatic int snd_ca0106_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->capture_source;\n\treturn 0;\n}\n\nstatic int snd_ca0106_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tval = ucontrol->value.enumerated.item[0] ;\n\tif (val >= 6)\n\t\treturn -EINVAL;\n\tchange = (emu->capture_source != val);\n\tif (change) {\n\t\temu->capture_source = val;\n\t\tca0106_set_capture_source(emu);\n\t}\n        return change;\n}\n\nstatic int snd_ca0106_i2c_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"Phone\", \"Mic\", \"Line in\", \"Aux\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\n\nstatic int snd_ca0106_i2c_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->i2c_capture_source;\n\treturn 0;\n}\n\nstatic int snd_ca0106_i2c_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int source_id;\n\tint change = 0;\n\t \n\tsource_id = ucontrol->value.enumerated.item[0] ;\n\tif (source_id >= 4)\n\t\treturn -EINVAL;\n\tchange = (emu->i2c_capture_source != source_id);\n\tif (change) {\n\t\tca0106_set_i2c_capture_source(emu, source_id, 0);\n\t}\n        return change;\n}\n\nstatic int snd_ca0106_capture_line_in_side_out_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"Side out\", \"Line in\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_ca0106_capture_mic_line_in_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = { \"Line in\", \"Mic in\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_ca0106_capture_mic_line_in_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->capture_mic_line_in;\n\treturn 0;\n}\n\nstatic int snd_ca0106_capture_mic_line_in_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tval = ucontrol->value.enumerated.item[0] ;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\tchange = (emu->capture_mic_line_in != val);\n\tif (change) {\n\t\temu->capture_mic_line_in = val;\n\t\tca0106_set_capture_mic_line_in(emu);\n\t}\n        return change;\n}\n\nstatic const struct snd_kcontrol_new snd_ca0106_capture_mic_line_in =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Shared Mic/Line in Capture Switch\",\n\t.info =\t\tsnd_ca0106_capture_mic_line_in_info,\n\t.get =\t\tsnd_ca0106_capture_mic_line_in_get,\n\t.put =\t\tsnd_ca0106_capture_mic_line_in_put\n};\n\nstatic const struct snd_kcontrol_new snd_ca0106_capture_line_in_side_out =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Shared Line in/Side out Capture Switch\",\n\t.info =\t\tsnd_ca0106_capture_line_in_side_out_info,\n\t.get =\t\tsnd_ca0106_capture_mic_line_in_get,\n\t.put =\t\tsnd_ca0106_capture_mic_line_in_put\n};\n\n\nstatic int snd_ca0106_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic void decode_spdif_bits(unsigned char *status, unsigned int bits)\n{\n\tstatus[0] = (bits >> 0) & 0xff;\n\tstatus[1] = (bits >> 8) & 0xff;\n\tstatus[2] = (bits >> 16) & 0xff;\n\tstatus[3] = (bits >> 24) & 0xff;\n}\n\nstatic int snd_ca0106_spdif_get_default(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\n\tdecode_spdif_bits(ucontrol->value.iec958.status,\n\t\t\t  emu->spdif_bits[idx]);\n        return 0;\n}\n\nstatic int snd_ca0106_spdif_get_stream(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\n\tdecode_spdif_bits(ucontrol->value.iec958.status,\n\t\t\t  emu->spdif_str_bits[idx]);\n        return 0;\n}\n\nstatic int snd_ca0106_spdif_get_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n        return 0;\n}\n\nstatic unsigned int encode_spdif_bits(unsigned char *status)\n{\n\treturn ((unsigned int)status[0] << 0) |\n\t\t((unsigned int)status[1] << 8) |\n\t\t((unsigned int)status[2] << 16) |\n\t\t((unsigned int)status[3] << 24);\n}\n\nstatic int snd_ca0106_spdif_put_default(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val;\n\n\tval = encode_spdif_bits(ucontrol->value.iec958.status);\n\tif (val != emu->spdif_bits[idx]) {\n\t\temu->spdif_bits[idx] = val;\n\t\t \n\t\temu->spdif_str_bits[idx] = val;\n\t\tca0106_set_spdif_bits(emu, idx);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ca0106_spdif_put_stream(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tunsigned int val;\n\n\tval = encode_spdif_bits(ucontrol->value.iec958.status);\n\tif (val != emu->spdif_str_bits[idx]) {\n\t\temu->spdif_str_bits[idx] = val;\n\t\tca0106_set_spdif_bits(emu, idx);\n\t\treturn 1;\n\t}\n        return 0;\n}\n\nstatic int snd_ca0106_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n        uinfo->count = 2;\n        uinfo->value.integer.min = 0;\n        uinfo->value.integer.max = 255;\n        return 0;\n}\n\nstatic int snd_ca0106_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n        unsigned int value;\n\tint channel_id, reg;\n\n\tchannel_id = (kcontrol->private_value >> 8) & 0xff;\n\treg = kcontrol->private_value & 0xff;\n\n        value = snd_ca0106_ptr_read(emu, reg, channel_id);\n        ucontrol->value.integer.value[0] = 0xff - ((value >> 24) & 0xff);  \n        ucontrol->value.integer.value[1] = 0xff - ((value >> 16) & 0xff);  \n        return 0;\n}\n\nstatic int snd_ca0106_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n        unsigned int oval, nval;\n\tint channel_id, reg;\n\n\tchannel_id = (kcontrol->private_value >> 8) & 0xff;\n\treg = kcontrol->private_value & 0xff;\n\n\toval = snd_ca0106_ptr_read(emu, reg, channel_id);\n\tnval = ((0xff - ucontrol->value.integer.value[0]) << 24) |\n\t\t((0xff - ucontrol->value.integer.value[1]) << 16);\n        nval |= ((0xff - ucontrol->value.integer.value[0]) << 8) |\n\t\t((0xff - ucontrol->value.integer.value[1]) );\n\tif (oval == nval)\n\t\treturn 0;\n\tsnd_ca0106_ptr_write(emu, reg, channel_id, nval);\n\treturn 1;\n}\n\nstatic int snd_ca0106_i2c_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n        uinfo->count = 2;\n        uinfo->value.integer.min = 0;\n        uinfo->value.integer.max = 255;\n        return 0;\n}\n\nstatic int snd_ca0106_i2c_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tint source_id;\n\n\tsource_id = kcontrol->private_value;\n\n        ucontrol->value.integer.value[0] = emu->i2c_capture_volume[source_id][0];\n        ucontrol->value.integer.value[1] = emu->i2c_capture_volume[source_id][1];\n        return 0;\n}\n\nstatic int snd_ca0106_i2c_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n        unsigned int ogain;\n        unsigned int ngain;\n\tint source_id;\n\tint change = 0;\n\n\tsource_id = kcontrol->private_value;\n\togain = emu->i2c_capture_volume[source_id][0];  \n\tngain = ucontrol->value.integer.value[0];\n\tif (ngain > 0xff)\n\t\treturn -EINVAL;\n\tif (ogain != ngain) {\n\t\tif (emu->i2c_capture_source == source_id)\n\t\t\tsnd_ca0106_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff) );\n\t\temu->i2c_capture_volume[source_id][0] = ucontrol->value.integer.value[0];\n\t\tchange = 1;\n\t}\n\togain = emu->i2c_capture_volume[source_id][1];  \n\tngain = ucontrol->value.integer.value[1];\n\tif (ngain > 0xff)\n\t\treturn -EINVAL;\n\tif (ogain != ngain) {\n\t\tif (emu->i2c_capture_source == source_id)\n\t\t\tsnd_ca0106_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));\n\t\temu->i2c_capture_volume[source_id][1] = ucontrol->value.integer.value[1];\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n\n#define spi_mute_info\tsnd_ctl_boolean_mono_info\n\nstatic int spi_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = kcontrol->private_value >> SPI_REG_SHIFT;\n\tunsigned int bit = kcontrol->private_value & SPI_REG_MASK;\n\n\tucontrol->value.integer.value[0] = !(emu->spi_dac_reg[reg] & bit);\n\treturn 0;\n}\n\nstatic int spi_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ca0106 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg = kcontrol->private_value >> SPI_REG_SHIFT;\n\tunsigned int bit = kcontrol->private_value & SPI_REG_MASK;\n\tint ret;\n\n\tret = emu->spi_dac_reg[reg] & bit;\n\tif (ucontrol->value.integer.value[0]) {\n\t\tif (!ret)\t \n\t\t\treturn 0;\n\t\temu->spi_dac_reg[reg] &= ~bit;\n\t} else {\n\t\tif (ret)\t \n\t\t\treturn 0;\n\t\temu->spi_dac_reg[reg] |= bit;\n\t}\n\n\tret = snd_ca0106_spi_write(emu, emu->spi_dac_reg[reg]);\n\treturn ret ? -EINVAL : 1;\n}\n\n#define CA_VOLUME(xname,chid,reg) \\\n{\t\t\t\t\t\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\t\t\\\n\t          SNDRV_CTL_ELEM_ACCESS_TLV_READ,\t\t\\\n\t.info =\t snd_ca0106_volume_info,\t\t\t\\\n\t.get =   snd_ca0106_volume_get,\t\t\t\t\\\n\t.put =   snd_ca0106_volume_put,\t\t\t\t\\\n\t.tlv = { .p = snd_ca0106_db_scale1 },\t\t\t\\\n\t.private_value = ((chid) << 8) | (reg)\t\t\t\\\n}\n\nstatic const struct snd_kcontrol_new snd_ca0106_volume_ctls[] = {\n\tCA_VOLUME(\"Analog Front Playback Volume\",\n\t\t  CONTROL_FRONT_CHANNEL, PLAYBACK_VOLUME2),\n        CA_VOLUME(\"Analog Rear Playback Volume\",\n\t\t  CONTROL_REAR_CHANNEL, PLAYBACK_VOLUME2),\n\tCA_VOLUME(\"Analog Center/LFE Playback Volume\",\n\t\t  CONTROL_CENTER_LFE_CHANNEL, PLAYBACK_VOLUME2),\n        CA_VOLUME(\"Analog Side Playback Volume\",\n\t\t  CONTROL_UNKNOWN_CHANNEL, PLAYBACK_VOLUME2),\n\n        CA_VOLUME(\"IEC958 Front Playback Volume\",\n\t\t  CONTROL_FRONT_CHANNEL, PLAYBACK_VOLUME1),\n\tCA_VOLUME(\"IEC958 Rear Playback Volume\",\n\t\t  CONTROL_REAR_CHANNEL, PLAYBACK_VOLUME1),\n\tCA_VOLUME(\"IEC958 Center/LFE Playback Volume\",\n\t\t  CONTROL_CENTER_LFE_CHANNEL, PLAYBACK_VOLUME1),\n\tCA_VOLUME(\"IEC958 Unknown Playback Volume\",\n\t\t  CONTROL_UNKNOWN_CHANNEL, PLAYBACK_VOLUME1),\n\n        CA_VOLUME(\"CAPTURE feedback Playback Volume\",\n\t\t  1, CAPTURE_CONTROL),\n\n\t{\n\t\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t\t.count =\t4,\n\t\t.info =         snd_ca0106_spdif_info,\n\t\t.get =          snd_ca0106_spdif_get_mask\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"IEC958 Playback Switch\",\n\t\t.info =\t\tsnd_ca0106_shared_spdif_info,\n\t\t.get =\t\tsnd_ca0106_shared_spdif_get,\n\t\t.put =\t\tsnd_ca0106_shared_spdif_put\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"Digital Source Capture Enum\",\n\t\t.info =\t\tsnd_ca0106_capture_source_info,\n\t\t.get =\t\tsnd_ca0106_capture_source_get,\n\t\t.put =\t\tsnd_ca0106_capture_source_put\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"Analog Source Capture Enum\",\n\t\t.info =\t\tsnd_ca0106_i2c_capture_source_info,\n\t\t.get =\t\tsnd_ca0106_i2c_capture_source_get,\n\t\t.put =\t\tsnd_ca0106_i2c_capture_source_put\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t\t.count =\t4,\n\t\t.info =         snd_ca0106_spdif_info,\n\t\t.get =          snd_ca0106_spdif_get_default,\n\t\t.put =          snd_ca0106_spdif_put_default\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t\t.count =\t4,\n\t\t.info =         snd_ca0106_spdif_info,\n\t\t.get =          snd_ca0106_spdif_get_stream,\n\t\t.put =          snd_ca0106_spdif_put_stream\n\t},\n};\n\n#define I2C_VOLUME(xname,chid) \\\n{\t\t\t\t\t\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\t\t\\\n\t          SNDRV_CTL_ELEM_ACCESS_TLV_READ,\t\t\\\n\t.info =  snd_ca0106_i2c_volume_info,\t\t\t\\\n\t.get =   snd_ca0106_i2c_volume_get,\t\t\t\\\n\t.put =   snd_ca0106_i2c_volume_put,\t\t\t\\\n\t.tlv = { .p = snd_ca0106_db_scale2 },\t\t\t\\\n\t.private_value = chid\t\t\t\t\t\\\n}\n\nstatic const struct snd_kcontrol_new snd_ca0106_volume_i2c_adc_ctls[] = {\n        I2C_VOLUME(\"Phone Capture Volume\", 0),\n        I2C_VOLUME(\"Mic Capture Volume\", 1),\n        I2C_VOLUME(\"Line in Capture Volume\", 2),\n        I2C_VOLUME(\"Aux Capture Volume\", 3),\n};\n\nstatic const int spi_dmute_reg[] = {\n\tSPI_DMUTE0_REG,\n\tSPI_DMUTE1_REG,\n\tSPI_DMUTE2_REG,\n\t0,\n\tSPI_DMUTE4_REG,\n};\nstatic const int spi_dmute_bit[] = {\n\tSPI_DMUTE0_BIT,\n\tSPI_DMUTE1_BIT,\n\tSPI_DMUTE2_BIT,\n\t0,\n\tSPI_DMUTE4_BIT,\n};\n\nstatic struct snd_kcontrol_new\nsnd_ca0106_volume_spi_dac_ctl(const struct snd_ca0106_details *details,\n\t\t\t      int channel_id)\n{\n\tstruct snd_kcontrol_new spi_switch = {0};\n\tint reg, bit;\n\tint dac_id;\n\n\tspi_switch.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tspi_switch.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tspi_switch.info = spi_mute_info;\n\tspi_switch.get = spi_mute_get;\n\tspi_switch.put = spi_mute_put;\n\n\tswitch (channel_id) {\n\tcase PCM_FRONT_CHANNEL:\n\t\tspi_switch.name = \"Analog Front Playback Switch\";\n\t\tdac_id = (details->spi_dac & 0xf000) >> (4 * 3);\n\t\tbreak;\n\tcase PCM_REAR_CHANNEL:\n\t\tspi_switch.name = \"Analog Rear Playback Switch\";\n\t\tdac_id = (details->spi_dac & 0x0f00) >> (4 * 2);\n\t\tbreak;\n\tcase PCM_CENTER_LFE_CHANNEL:\n\t\tspi_switch.name = \"Analog Center/LFE Playback Switch\";\n\t\tdac_id = (details->spi_dac & 0x00f0) >> (4 * 1);\n\t\tbreak;\n\tcase PCM_UNKNOWN_CHANNEL:\n\t\tspi_switch.name = \"Analog Side Playback Switch\";\n\t\tdac_id = (details->spi_dac & 0x000f) >> (4 * 0);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tspi_switch.name = NULL;\n\t\tdac_id = 0;\n\t}\n\treg = spi_dmute_reg[dac_id];\n\tbit = spi_dmute_bit[dac_id];\n\n\tspi_switch.private_value = (reg << SPI_REG_SHIFT) | bit;\n\n\treturn spi_switch;\n}\n\nstatic int remove_ctl(struct snd_card *card, const char *name)\n{\n\tstruct snd_ctl_elem_id id;\n\tmemset(&id, 0, sizeof(id));\n\tstrcpy(id.name, name);\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\treturn snd_ctl_remove_id(card, &id);\n}\n\nstatic int rename_ctl(struct snd_card *card, const char *src, const char *dst)\n{\n\tstruct snd_kcontrol *kctl = snd_ctl_find_id_mixer(card, src);\n\tif (kctl) {\n\t\tsnd_ctl_rename(card, kctl, dst);\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n#define ADD_CTLS(emu, ctls)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint i, _err;\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(ctls); i++) {\t\t\\\n\t\t\t_err = snd_ctl_add(card, snd_ctl_new1(&ctls[i], emu)); \\\n\t\t\tif (_err < 0)\t\t\t\t\t\\\n\t\t\t\treturn _err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic\nDECLARE_TLV_DB_SCALE(snd_ca0106_master_db_scale, -6375, 25, 1);\n\nstatic const char * const follower_vols[] = {\n\t\"Analog Front Playback Volume\",\n        \"Analog Rear Playback Volume\",\n\t\"Analog Center/LFE Playback Volume\",\n        \"Analog Side Playback Volume\",\n        \"IEC958 Front Playback Volume\",\n\t\"IEC958 Rear Playback Volume\",\n\t\"IEC958 Center/LFE Playback Volume\",\n\t\"IEC958 Unknown Playback Volume\",\n        \"CAPTURE feedback Playback Volume\",\n\tNULL\n};\n\nstatic const char * const follower_sws[] = {\n\t\"Analog Front Playback Switch\",\n\t\"Analog Rear Playback Switch\",\n\t\"Analog Center/LFE Playback Switch\",\n\t\"Analog Side Playback Switch\",\n\t\"IEC958 Playback Switch\",\n\tNULL\n};\n\nint snd_ca0106_mixer(struct snd_ca0106 *emu)\n{\n\tint err;\n        struct snd_card *card = emu->card;\n\tconst char * const *c;\n\tstruct snd_kcontrol *vmaster;\n\tstatic const char * const ca0106_remove_ctls[] = {\n\t\t\"Master Mono Playback Switch\",\n\t\t\"Master Mono Playback Volume\",\n\t\t\"3D Control - Switch\",\n\t\t\"3D Control Sigmatel - Depth\",\n\t\t\"PCM Playback Switch\",\n\t\t\"PCM Playback Volume\",\n\t\t\"CD Playback Switch\",\n\t\t\"CD Playback Volume\",\n\t\t\"Phone Playback Switch\",\n\t\t\"Phone Playback Volume\",\n\t\t\"Video Playback Switch\",\n\t\t\"Video Playback Volume\",\n\t\t\"Beep Playback Switch\",\n\t\t\"Beep Playback Volume\",\n\t\t\"Mono Output Select\",\n\t\t\"Capture Source\",\n\t\t\"Capture Switch\",\n\t\t\"Capture Volume\",\n\t\t\"External Amplifier\",\n\t\t\"Sigmatel 4-Speaker Stereo Playback Switch\",\n\t\t\"Surround Phase Inversion Playback Switch\",\n\t\tNULL\n\t};\n\tstatic const char * const ca0106_rename_ctls[] = {\n\t\t\"Master Playback Switch\", \"Capture Switch\",\n\t\t\"Master Playback Volume\", \"Capture Volume\",\n\t\t\"Line Playback Switch\", \"AC97 Line Capture Switch\",\n\t\t\"Line Playback Volume\", \"AC97 Line Capture Volume\",\n\t\t\"Aux Playback Switch\", \"AC97 Aux Capture Switch\",\n\t\t\"Aux Playback Volume\", \"AC97 Aux Capture Volume\",\n\t\t\"Mic Playback Switch\", \"AC97 Mic Capture Switch\",\n\t\t\"Mic Playback Volume\", \"AC97 Mic Capture Volume\",\n\t\t\"Mic Select\", \"AC97 Mic Select\",\n\t\t\"Mic Boost (+20dB)\", \"AC97 Mic Boost (+20dB)\",\n\t\tNULL\n\t};\n#if 1\n\tfor (c = ca0106_remove_ctls; *c; c++)\n\t\tremove_ctl(card, *c);\n\tfor (c = ca0106_rename_ctls; *c; c += 2)\n\t\trename_ctl(card, c[0], c[1]);\n#endif\n\n\tADD_CTLS(emu, snd_ca0106_volume_ctls);\n\tif (emu->details->i2c_adc == 1) {\n\t\tADD_CTLS(emu, snd_ca0106_volume_i2c_adc_ctls);\n\t\tif (emu->details->gpio_type == 1)\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ca0106_capture_mic_line_in, emu));\n\t\telse   \n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ca0106_capture_line_in_side_out, emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (emu->details->spi_dac) {\n\t\tint i;\n\t\tfor (i = 0;; i++) {\n\t\t\tstruct snd_kcontrol_new ctl;\n\t\t\tctl = snd_ca0106_volume_spi_dac_ctl(emu->details, i);\n\t\t\tif (!ctl.name)\n\t\t\t\tbreak;\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&ctl, emu));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tvmaster = snd_ctl_make_virtual_master(\"Master Playback Volume\",\n\t\t\t\t\t      snd_ca0106_master_db_scale);\n\tif (!vmaster)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(card, vmaster);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add_followers(card, vmaster, follower_vols);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (emu->details->spi_dac) {\n\t\tvmaster = snd_ctl_make_virtual_master(\"Master Playback Switch\",\n\t\t\t\t\t\t      NULL);\n\t\tif (!vmaster)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(card, vmaster);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add_followers(card, vmaster, follower_sws);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tstrcpy(card->mixername, \"CA0106\");\n        return 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstruct ca0106_vol_tbl {\n\tunsigned int channel_id;\n\tunsigned int reg;\n};\n\nstatic const struct ca0106_vol_tbl saved_volumes[NUM_SAVED_VOLUMES] = {\n\t{ CONTROL_FRONT_CHANNEL, PLAYBACK_VOLUME2 },\n\t{ CONTROL_REAR_CHANNEL, PLAYBACK_VOLUME2 },\n\t{ CONTROL_CENTER_LFE_CHANNEL, PLAYBACK_VOLUME2 },\n\t{ CONTROL_UNKNOWN_CHANNEL, PLAYBACK_VOLUME2 },\n\t{ CONTROL_FRONT_CHANNEL, PLAYBACK_VOLUME1 },\n\t{ CONTROL_REAR_CHANNEL, PLAYBACK_VOLUME1 },\n\t{ CONTROL_CENTER_LFE_CHANNEL, PLAYBACK_VOLUME1 },\n\t{ CONTROL_UNKNOWN_CHANNEL, PLAYBACK_VOLUME1 },\n\t{ 1, CAPTURE_CONTROL },\n};\n\nvoid snd_ca0106_mixer_suspend(struct snd_ca0106 *chip)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_SAVED_VOLUMES; i++)\n\t\tchip->saved_vol[i] =\n\t\t\tsnd_ca0106_ptr_read(chip, saved_volumes[i].reg,\n\t\t\t\t\t    saved_volumes[i].channel_id);\n}\n\nvoid snd_ca0106_mixer_resume(struct snd_ca0106  *chip)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_SAVED_VOLUMES; i++)\n\t\tsnd_ca0106_ptr_write(chip, saved_volumes[i].reg,\n\t\t\t\t     saved_volumes[i].channel_id,\n\t\t\t\t     chip->saved_vol[i]);\n\n\tca0106_spdif_enable(chip);\n\tca0106_set_capture_source(chip);\n\tca0106_set_i2c_capture_source(chip, chip->i2c_capture_source, 1);\n\tfor (i = 0; i < 4; i++)\n\t\tca0106_set_spdif_bits(chip, i);\n\tif (chip->details->i2c_adc)\n\t\tca0106_set_capture_mic_line_in(chip);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}