{
  "module_name": "ca0106_main.c",
  "hash_id": "fd9f1a35ba54e5c3e7ca419db2b857c76b4e2488dc5a2f53761662412496ef8b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ca0106/ca0106_main.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n\nMODULE_AUTHOR(\"James Courtier-Dutton <James@superbug.demon.co.uk>\");\nMODULE_DESCRIPTION(\"CA0106\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nstatic uint subsystem[SNDRV_CARDS];  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the CA0106 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the CA0106 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable the CA0106 soundcard.\");\nmodule_param_array(subsystem, uint, NULL, 0444);\nMODULE_PARM_DESC(subsystem, \"Force card subsystem model.\");\n\n#include \"ca0106.h\"\n\nstatic const struct snd_ca0106_details ca0106_chip_details[] = {\n\t  \n\t  \n\t  \n\t { .serial = 0x10131102,\n\t   .name   = \"X-Fi Extreme Audio [SBxxxx]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1 } ,\n\t  \n\t  \n\t  \n\t  \n\t { .serial = 0x10121102,\n\t   .name   = \"X-Fi Extreme Audio [SB0790]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1 } ,\n\t  \n\t  \n\t { .serial = 0x10021102,\n\t   .name   = \"AudigyLS [SB0310]\",\n\t   .ac97   = 1 } , \n\t  \n\t { .serial = 0x10051102,\n\t   .name   = \"AudigyLS [SB0310b]\",\n\t   .ac97   = 1 } ,\n\t  \n\t { .serial = 0x10061102,\n\t   .name   = \"Live! 7.1 24bit [SB0410]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1 } ,\n\t  \n\t { .serial = 0x10071102,\n\t   .name   = \"Live! 7.1 24bit [SB0413]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1 } ,\n\t  \n\t  \n\t { .serial = 0x100a1102,\n\t   .name   = \"Audigy SE [SB0570]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1,\n\t   .spi_dac = 0x4021 } ,\n\t  \n\t  \n\t { .serial = 0x10111102,\n\t   .name   = \"Audigy SE OEM [SB0570a]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1,\n\t   .spi_dac = 0x4021 } ,\n\t \n\t{ .serial = 0x10041102,\n\t  .name   = \"Sound Blaster 5.1vx [SB1070]\",\n\t  .gpio_type = 1,\n\t  .i2c_adc = 0,\n\t  .spi_dac = 0x0124\n\t } ,\n\t  \n\t  \n\t { .serial = 0x10091462,\n\t   .name   = \"MSI K8N Diamond MB [SB0438]\",\n\t   .gpio_type = 2,\n\t   .i2c_adc = 1 } ,\n\t  \n\t { .serial = 0x10091102,\n\t   .name   = \"MSI K8N Diamond MB\",\n\t   .gpio_type = 2,\n\t   .i2c_adc = 1,\n\t   .spi_dac = 0x4021 } ,\n\t \n\t \n\t{ .serial = 0x1458a006,\n\t  .name = \"Giga-byte GA-G1975X\",\n\t  .gpio_type = 1,\n\t  .i2c_adc = 1 },\n\t  \n\t { .serial = 0x30381297,\n\t   .name   = \"Shuttle XPC SD31P [SD31P]\",\n\t   .gpio_type = 1,\n\t   .i2c_adc = 1 } ,\n\t \n\t{ .serial = 0x30411297,\n\t  .name = \"Shuttle XPC SD11G5 [SD11G5]\",\n\t  .gpio_type = 1,\n\t  .i2c_adc = 1 } ,\n\t { .serial = 0,\n\t   .name   = \"AudigyLS [Unknown]\" }\n};\n\n \nstatic const struct snd_pcm_hardware snd_ca0106_playback_hw = {\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP | \n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_SYNC_START,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\t(SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |\n\t\t\t\t SNDRV_PCM_RATE_192000),\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,  \n\t.channels_max =\t\t2,  \n\t.buffer_bytes_max =\t((65536 - 64) * 8),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(65536 - 64),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t8,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ca0106_capture_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | \n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n#if 0  \n\t.rates =\t\t(SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\n\t\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000),\n\t.rate_min =\t\t44100,\n#else\n\t.rates =\t\t(SNDRV_PCM_RATE_48000 |\n\t\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000),\n\t.rate_min =\t\t48000,\n#endif  \n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t65536 - 128,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t32768 - 64,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nunsigned int snd_ca0106_ptr_read(struct snd_ca0106 * emu, \n\t\t\t\t\t  unsigned int reg, \n\t\t\t\t\t  unsigned int chn)\n{\n\tunsigned long flags;\n\tunsigned int regptr, val;\n  \n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + CA0106_PTR);\n\tval = inl(emu->port + CA0106_DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nvoid snd_ca0106_ptr_write(struct snd_ca0106 *emu, \n\t\t\t\t   unsigned int reg, \n\t\t\t\t   unsigned int chn, \n\t\t\t\t   unsigned int data)\n{\n\tunsigned int regptr;\n\tunsigned long flags;\n\n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + CA0106_PTR);\n\toutl(data, emu->port + CA0106_DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nint snd_ca0106_spi_write(struct snd_ca0106 * emu,\n\t\t\t\t   unsigned int data)\n{\n\tunsigned int reset, set;\n\tunsigned int reg, tmp;\n\tint n, result;\n\treg = SPI;\n\tif (data > 0xffff)  \n\t\treturn 1;\n\ttmp = snd_ca0106_ptr_read(emu, reg, 0);\n\treset = (tmp & ~0x3ffff) | 0x20000;  \n\tset = reset | 0x10000;  \n\tsnd_ca0106_ptr_write(emu, reg, 0, reset | data);\n\ttmp = snd_ca0106_ptr_read(emu, reg, 0);  \n\tsnd_ca0106_ptr_write(emu, reg, 0, set | data);\n\tresult = 1;\n\t \n\tfor (n = 0; n < 100; n++) {\n\t\tudelay(10);\n\t\ttmp = snd_ca0106_ptr_read(emu, reg, 0);\n\t\tif (!(tmp & 0x10000)) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result)  \n\t\treturn 1;\n\tsnd_ca0106_ptr_write(emu, reg, 0, reset | data);\n\ttmp = snd_ca0106_ptr_read(emu, reg, 0);  \n\treturn 0;\n}\n\n \nint snd_ca0106_i2c_write(struct snd_ca0106 *emu,\n\t\t\t\tu32 reg,\n\t\t\t\tu32 value)\n{\n\tu32 tmp;\n\tint timeout = 0;\n\tint status;\n\tint retry;\n\tif ((reg > 0x7f) || (value > 0x1ff)) {\n\t\tdev_err(emu->card->dev, \"i2c_write: invalid values.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = reg << 25 | value << 16;\n\t \n\t \n\t \n\n\t \n\tsnd_ca0106_ptr_write(emu, I2C_D1, 0, tmp);\n\n\tfor (retry = 0; retry < 10; retry++) {\n\t\t \n\t\t\n\t\t\n\t\ttmp = 0;\n\t\ttmp = tmp | (I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD);\n\t\tsnd_ca0106_ptr_write(emu, I2C_A, 0, tmp);\n\n\t\t \n\t\twhile (1) {\n\t\t\tstatus = snd_ca0106_ptr_read(emu, I2C_A, 0);\n\t\t\t \n\t\t\ttimeout++;\n\t\t\tif ((status & I2C_A_ADC_START) == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (timeout > 1000)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif ((status & I2C_A_ADC_ABORT) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (retry == 10) {\n\t\tdev_err(emu->card->dev, \"Writing to ADC failed!\\n\");\n\t\treturn -EINVAL;\n\t}\n    \n    \treturn 0;\n}\n\n\nstatic void snd_ca0106_intr_enable(struct snd_ca0106 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int intr_enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tintr_enable = inl(emu->port + CA0106_INTE) | intrenb;\n\toutl(intr_enable, emu->port + CA0106_INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_ca0106_intr_disable(struct snd_ca0106 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int intr_enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tintr_enable = inl(emu->port + CA0106_INTE) & ~intrenb;\n\toutl(intr_enable, emu->port + CA0106_INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\n\nstatic void snd_ca0106_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic const int spi_dacd_reg[] = {\n\tSPI_DACD0_REG,\n\tSPI_DACD1_REG,\n\tSPI_DACD2_REG,\n\t0,\n\tSPI_DACD4_REG,\n};\nstatic const int spi_dacd_bit[] = {\n\tSPI_DACD0_BIT,\n\tSPI_DACD1_BIT,\n\tSPI_DACD2_BIT,\n\t0,\n\tSPI_DACD4_BIT,\n};\n\nstatic void restore_spdif_bits(struct snd_ca0106 *chip, int idx)\n{\n\tif (chip->spdif_str_bits[idx] != chip->spdif_bits[idx]) {\n\t\tchip->spdif_str_bits[idx] = chip->spdif_bits[idx];\n\t\tsnd_ca0106_ptr_write(chip, SPCS0 + idx, 0,\n\t\t\t\t     chip->spdif_str_bits[idx]);\n\t}\n}\n\nstatic int snd_ca0106_channel_dac(struct snd_ca0106 *chip,\n\t\t\t\t  const struct snd_ca0106_details *details,\n\t\t\t\t  int channel_id)\n{\n\tswitch (channel_id) {\n\tcase PCM_FRONT_CHANNEL:\n\t\treturn (details->spi_dac & 0xf000) >> (4 * 3);\n\tcase PCM_REAR_CHANNEL:\n\t\treturn (details->spi_dac & 0x0f00) >> (4 * 2);\n\tcase PCM_CENTER_LFE_CHANNEL:\n\t\treturn (details->spi_dac & 0x00f0) >> (4 * 1);\n\tcase PCM_UNKNOWN_CHANNEL:\n\t\treturn (details->spi_dac & 0x000f) >> (4 * 0);\n\tdefault:\n\t\tdev_dbg(chip->card->dev, \"ca0106: unknown channel_id %d\\n\",\n\t\t\t   channel_id);\n\t}\n\treturn 0;\n}\n\nstatic int snd_ca0106_pcm_power_dac(struct snd_ca0106 *chip, int channel_id,\n\t\t\t\t    int power)\n{\n\tif (chip->details->spi_dac) {\n\t\tconst int dac = snd_ca0106_channel_dac(chip, chip->details,\n\t\t\t\t\t\t       channel_id);\n\t\tconst int reg = spi_dacd_reg[dac];\n\t\tconst int bit = spi_dacd_bit[dac];\n\n\t\tif (power)\n\t\t\t \n\t\t\tchip->spi_dac_reg[reg] &= ~bit;\n\t\telse\n\t\t\t \n\t\t\tchip->spi_dac_reg[reg] |= bit;\n\t\tif (snd_ca0106_spi_write(chip, chip->spi_dac_reg[reg]) != 0)\n\t\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_ca0106_pcm_open_playback_channel(struct snd_pcm_substream *substream,\n\t\t\t\t\t\tint channel_id)\n{\n\tstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\n        struct snd_ca0106_channel *channel = &(chip->playback_channels[channel_id]);\n\tstruct snd_ca0106_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = chip;\n\tepcm->substream = substream;\n        epcm->channel_id=channel_id;\n  \n\truntime->private_data = epcm;\n\truntime->private_free = snd_ca0106_pcm_free_substream;\n  \n\truntime->hw = snd_ca0106_playback_hw;\n\n        channel->emu = chip;\n        channel->number = channel_id;\n\n\tchannel->use = 1;\n\t \n        \n\tchannel->epcm = epcm;\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n                return err;\n\terr = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\tif (err < 0)\n                return err;\n\tsnd_pcm_set_sync(substream);\n\n\t \n\tif (channel_id != PCM_FRONT_CHANNEL) {\n\t\terr = snd_ca0106_pcm_power_dac(chip, channel_id, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\trestore_spdif_bits(chip, channel_id);\n\n\treturn 0;\n}\n\n \nstatic int snd_ca0106_pcm_close_playback(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_ca0106_pcm *epcm = runtime->private_data;\n\tchip->playback_channels[epcm->channel_id].use = 0;\n\n\trestore_spdif_bits(chip, epcm->channel_id);\n\n\t \n\tif (epcm->channel_id != PCM_FRONT_CHANNEL) {\n\t\tint err;\n\t\terr = snd_ca0106_pcm_power_dac(chip, epcm->channel_id, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int snd_ca0106_pcm_open_playback_front(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);\n}\n\nstatic int snd_ca0106_pcm_open_playback_center_lfe(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_playback_channel(substream, PCM_CENTER_LFE_CHANNEL);\n}\n\nstatic int snd_ca0106_pcm_open_playback_unknown(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_playback_channel(substream, PCM_UNKNOWN_CHANNEL);\n}\n\nstatic int snd_ca0106_pcm_open_playback_rear(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_playback_channel(substream, PCM_REAR_CHANNEL);\n}\n\n \nstatic int snd_ca0106_pcm_open_capture_channel(struct snd_pcm_substream *substream,\n\t\t\t\t\t       int channel_id)\n{\n\tstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\n        struct snd_ca0106_channel *channel = &(chip->capture_channels[channel_id]);\n\tstruct snd_ca0106_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (!epcm)\n\t\treturn -ENOMEM;\n\n\tepcm->emu = chip;\n\tepcm->substream = substream;\n        epcm->channel_id=channel_id;\n  \n\truntime->private_data = epcm;\n\truntime->private_free = snd_ca0106_pcm_free_substream;\n  \n\truntime->hw = snd_ca0106_capture_hw;\n\n        channel->emu = chip;\n        channel->number = channel_id;\n\n\tchannel->use = 1;\n\t \n        \n        channel->epcm = epcm;\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n                return err;\n\t\n\terr = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\tif (err < 0)\n                return err;\n\treturn 0;\n}\n\n \nstatic int snd_ca0106_pcm_close_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n        struct snd_ca0106_pcm *epcm = runtime->private_data;\n\tchip->capture_channels[epcm->channel_id].use = 0;\n\t \n\treturn 0;\n}\n\nstatic int snd_ca0106_pcm_open_0_capture(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_capture_channel(substream, 0);\n}\n\nstatic int snd_ca0106_pcm_open_1_capture(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_capture_channel(substream, 1);\n}\n\nstatic int snd_ca0106_pcm_open_2_capture(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_capture_channel(substream, 2);\n}\n\nstatic int snd_ca0106_pcm_open_3_capture(struct snd_pcm_substream *substream)\n{\n\treturn snd_ca0106_pcm_open_capture_channel(substream, 3);\n}\n\n \nstatic int snd_ca0106_pcm_prepare_playback(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ca0106_pcm *epcm = runtime->private_data;\n\tint channel = epcm->channel_id;\n\tu32 *table_base = (u32 *)(emu->buffer->area+(8*16*channel));\n\tu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\n\tu32 hcfg_mask = HCFG_PLAYBACK_S32_LE;\n\tu32 hcfg_set = 0x00000000;\n\tu32 hcfg;\n\tu32 reg40_mask = 0x30000 << (channel<<1);\n\tu32 reg40_set = 0;\n\tu32 reg40;\n\t \n\tu32 reg71_mask = 0x03030000 ;  \n\tu32 reg71_set = 0;\n\tu32 reg71;\n\tint i;\n\t\n#if 0  \n\tdev_dbg(emu->card->dev,\n\t\t   \"prepare:channel_number=%d, rate=%d, format=0x%x, \"\n\t\t   \"channels=%d, buffer_size=%ld, period_size=%ld, \"\n\t\t   \"periods=%u, frames_to_bytes=%d\\n\",\n\t\t   channel, runtime->rate, runtime->format,\n\t\t   runtime->channels, runtime->buffer_size,\n\t\t   runtime->period_size, runtime->periods,\n\t\t   frames_to_bytes(runtime, 1));\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, table_base=%p\\n\",\n\t\t   runtime->dma_addr, runtime->dma_area, table_base);\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\\n\",\n\t\t   emu->buffer->addr, emu->buffer->area, emu->buffer->bytes);\n#endif  \n\t \n\t \n\t \n\tswitch (runtime->rate) {\n\tcase 44100:\n\t\treg40_set = 0x10000 << (channel<<1);\n\t\treg71_set = 0x01010000; \n\t\tbreak;\n        case 48000:\n\t\treg40_set = 0;\n\t\treg71_set = 0; \n\t\tbreak;\n\tcase 96000:\n\t\treg40_set = 0x20000 << (channel<<1);\n\t\treg71_set = 0x02020000; \n\t\tbreak;\n\tcase 192000:\n\t\treg40_set = 0x30000 << (channel<<1);\n\t\treg71_set = 0x03030000; \n\t\tbreak;\n\tdefault:\n\t\treg40_set = 0;\n\t\treg71_set = 0; \n\t\tbreak;\n\t}\n\t \n\t \n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\thcfg_set = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\thcfg_set = HCFG_PLAYBACK_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\thcfg_set = 0;\n\t\tbreak;\n\t}\n\thcfg = inl(emu->port + CA0106_HCFG) ;\n\thcfg = (hcfg & ~hcfg_mask) | hcfg_set;\n\toutl(hcfg, emu->port + CA0106_HCFG);\n\treg40 = snd_ca0106_ptr_read(emu, 0x40, 0);\n\treg40 = (reg40 & ~reg40_mask) | reg40_set;\n\tsnd_ca0106_ptr_write(emu, 0x40, 0, reg40);\n\treg71 = snd_ca0106_ptr_read(emu, 0x71, 0);\n\treg71 = (reg71 & ~reg71_mask) | reg71_set;\n\tsnd_ca0106_ptr_write(emu, 0x71, 0, reg71);\n\n\t \n        for(i=0; i < runtime->periods; i++) {\n\t\ttable_base[i*2] = runtime->dma_addr + (i * period_size_bytes);\n\t\ttable_base[i*2+1] = period_size_bytes << 16;\n\t}\n \n\tsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_ADDR, channel, emu->buffer->addr+(8*16*channel));\n\tsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_SIZE, channel, (runtime->periods - 1) << 19);\n\tsnd_ca0106_ptr_write(emu, PLAYBACK_LIST_PTR, channel, 0);\n\tsnd_ca0106_ptr_write(emu, PLAYBACK_DMA_ADDR, channel, runtime->dma_addr);\n\tsnd_ca0106_ptr_write(emu, PLAYBACK_PERIOD_SIZE, channel, frames_to_bytes(runtime, runtime->period_size)<<16); \n\t \n\tsnd_ca0106_ptr_write(emu, PLAYBACK_PERIOD_SIZE, channel, 0); \n\tsnd_ca0106_ptr_write(emu, PLAYBACK_POINTER, channel, 0);\n\tsnd_ca0106_ptr_write(emu, 0x07, channel, 0x0);\n\tsnd_ca0106_ptr_write(emu, 0x08, channel, 0);\n        snd_ca0106_ptr_write(emu, PLAYBACK_MUTE, 0x0, 0x0);  \n#if 0\n\tsnd_ca0106_ptr_write(emu, SPCS0, 0,\n\t\t\t       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\t\t       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\t\t       SPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t\t       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT );\n#endif\n\n\treturn 0;\n}\n\n \nstatic int snd_ca0106_pcm_prepare_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ca0106_pcm *epcm = runtime->private_data;\n\tint channel = epcm->channel_id;\n\tu32 hcfg_mask = HCFG_CAPTURE_S32_LE;\n\tu32 hcfg_set = 0x00000000;\n\tu32 hcfg;\n\tu32 over_sampling=0x2;\n\tu32 reg71_mask = 0x0000c000 ;  \n\tu32 reg71_set = 0;\n\tu32 reg71;\n\t\n#if 0  \n\tdev_dbg(emu->card->dev,\n\t\t   \"prepare:channel_number=%d, rate=%d, format=0x%x, \"\n\t\t   \"channels=%d, buffer_size=%ld, period_size=%ld, \"\n\t\t   \"periods=%u, frames_to_bytes=%d\\n\",\n\t\t   channel, runtime->rate, runtime->format,\n\t\t   runtime->channels, runtime->buffer_size,\n\t\t   runtime->period_size, runtime->periods,\n\t\t   frames_to_bytes(runtime, 1));\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, table_base=%p\\n\",\n\t\t   runtime->dma_addr, runtime->dma_area, table_base);\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\\n\",\n\t\t   emu->buffer->addr, emu->buffer->area, emu->buffer->bytes);\n#endif  \n\t \n\tswitch (runtime->rate) {\n\tcase 44100:\n\t\treg71_set = 0x00004000;\n\t\tbreak;\n        case 48000:\n\t\treg71_set = 0; \n\t\tbreak;\n\tcase 96000:\n\t\treg71_set = 0x00008000;\n\t\tover_sampling=0xa;\n\t\tbreak;\n\tcase 192000:\n\t\treg71_set = 0x0000c000; \n\t\tover_sampling=0xa;\n\t\tbreak;\n\tdefault:\n\t\treg71_set = 0; \n\t\tbreak;\n\t}\n\t \n\t \n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\thcfg_set = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\thcfg_set = HCFG_CAPTURE_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\thcfg_set = 0;\n\t\tbreak;\n\t}\n\thcfg = inl(emu->port + CA0106_HCFG) ;\n\thcfg = (hcfg & ~hcfg_mask) | hcfg_set;\n\toutl(hcfg, emu->port + CA0106_HCFG);\n\treg71 = snd_ca0106_ptr_read(emu, 0x71, 0);\n\treg71 = (reg71 & ~reg71_mask) | reg71_set;\n\tsnd_ca0106_ptr_write(emu, 0x71, 0, reg71);\n        if (emu->details->i2c_adc == 1) {  \n\t        snd_ca0106_i2c_write(emu, ADC_MASTER, over_sampling);  \n\t}\n\n\n\t \n\tsnd_ca0106_ptr_write(emu, 0x13, channel, 0);\n\tsnd_ca0106_ptr_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);\n\tsnd_ca0106_ptr_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size)<<16); \n\tsnd_ca0106_ptr_write(emu, CAPTURE_POINTER, channel, 0);\n\n\treturn 0;\n}\n\n \nstatic int snd_ca0106_pcm_trigger_playback(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_ca0106_pcm *epcm;\n\tint channel;\n\tint result = 0;\n        struct snd_pcm_substream *s;\n\tu32 basic = 0;\n\tu32 extended = 0;\n\tu32 bits;\n\tint running = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\trunning = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tdefault:\n\t\trunning = 0;\n\t\tbreak;\n\t}\n        snd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) != emu ||\n\t\t    s->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tcontinue;\n\t\truntime = s->runtime;\n\t\tepcm = runtime->private_data;\n\t\tchannel = epcm->channel_id;\n\t\t \n\t\tepcm->running = running;\n\t\tbasic |= (0x1 << channel);\n\t\textended |= (0x10 << channel);\n                snd_pcm_trigger_done(s, substream);\n        }\n\t \n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tbits = snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0);\n\t\tbits |= extended;\n\t\tsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, bits);\n\t\tbits = snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0);\n\t\tbits |= basic;\n\t\tsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, bits);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tbits = snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0);\n\t\tbits &= ~basic;\n\t\tsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, bits);\n\t\tbits = snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0);\n\t\tbits &= ~extended;\n\t\tsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, bits);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic int snd_ca0106_pcm_trigger_capture(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ca0106_pcm *epcm = runtime->private_data;\n\tint channel = epcm->channel_id;\n\tint result = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));\n\t\tsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0)|(0x100<<channel));\n\t\tepcm->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_ca0106_ptr_write(emu, BASIC_INTERRUPT, 0, snd_ca0106_ptr_read(emu, BASIC_INTERRUPT, 0) & ~(0x100<<channel));\n\t\tsnd_ca0106_ptr_write(emu, EXTENDED_INT_MASK, 0, snd_ca0106_ptr_read(emu, EXTENDED_INT_MASK, 0) & ~(0x110000<<channel));\n\t\tepcm->running = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_ca0106_pcm_pointer_playback(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ca0106_pcm *epcm = runtime->private_data;\n\tunsigned int ptr, prev_ptr;\n\tint channel = epcm->channel_id;\n\tint timeout = 10;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\n\tprev_ptr = -1;\n\tdo {\n\t\tptr = snd_ca0106_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\n\t\tptr = (ptr >> 3) * runtime->period_size;\n\t\tptr += bytes_to_frames(runtime,\n\t\t\tsnd_ca0106_ptr_read(emu, PLAYBACK_POINTER, channel));\n\t\tif (ptr >= runtime->buffer_size)\n\t\t\tptr -= runtime->buffer_size;\n\t\tif (prev_ptr == ptr)\n\t\t\treturn ptr;\n\t\tprev_ptr = ptr;\n\t} while (--timeout);\n\tdev_warn(emu->card->dev, \"ca0106: unstable DMA pointer!\\n\");\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_ca0106_pcm_pointer_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_ca0106 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_ca0106_pcm *epcm = runtime->private_data;\n\tsnd_pcm_uframes_t ptr, ptr1, ptr2 = 0;\n\tint channel = epcm->channel_id;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\n\tptr1 = snd_ca0106_ptr_read(emu, CAPTURE_POINTER, channel);\n\tptr2 = bytes_to_frames(runtime, ptr1);\n\tptr=ptr2;\n        if (ptr >= runtime->buffer_size)\n\t\tptr -= runtime->buffer_size;\n\t \n\treturn ptr;\n}\n\n \nstatic const struct snd_pcm_ops snd_ca0106_playback_front_ops = {\n\t.open =        snd_ca0106_pcm_open_playback_front,\n\t.close =       snd_ca0106_pcm_close_playback,\n\t.prepare =     snd_ca0106_pcm_prepare_playback,\n\t.trigger =     snd_ca0106_pcm_trigger_playback,\n\t.pointer =     snd_ca0106_pcm_pointer_playback,\n};\n\nstatic const struct snd_pcm_ops snd_ca0106_capture_0_ops = {\n\t.open =        snd_ca0106_pcm_open_0_capture,\n\t.close =       snd_ca0106_pcm_close_capture,\n\t.prepare =     snd_ca0106_pcm_prepare_capture,\n\t.trigger =     snd_ca0106_pcm_trigger_capture,\n\t.pointer =     snd_ca0106_pcm_pointer_capture,\n};\n\nstatic const struct snd_pcm_ops snd_ca0106_capture_1_ops = {\n\t.open =        snd_ca0106_pcm_open_1_capture,\n\t.close =       snd_ca0106_pcm_close_capture,\n\t.prepare =     snd_ca0106_pcm_prepare_capture,\n\t.trigger =     snd_ca0106_pcm_trigger_capture,\n\t.pointer =     snd_ca0106_pcm_pointer_capture,\n};\n\nstatic const struct snd_pcm_ops snd_ca0106_capture_2_ops = {\n\t.open =        snd_ca0106_pcm_open_2_capture,\n\t.close =       snd_ca0106_pcm_close_capture,\n\t.prepare =     snd_ca0106_pcm_prepare_capture,\n\t.trigger =     snd_ca0106_pcm_trigger_capture,\n\t.pointer =     snd_ca0106_pcm_pointer_capture,\n};\n\nstatic const struct snd_pcm_ops snd_ca0106_capture_3_ops = {\n\t.open =        snd_ca0106_pcm_open_3_capture,\n\t.close =       snd_ca0106_pcm_close_capture,\n\t.prepare =     snd_ca0106_pcm_prepare_capture,\n\t.trigger =     snd_ca0106_pcm_trigger_capture,\n\t.pointer =     snd_ca0106_pcm_pointer_capture,\n};\n\nstatic const struct snd_pcm_ops snd_ca0106_playback_center_lfe_ops = {\n        .open =         snd_ca0106_pcm_open_playback_center_lfe,\n        .close =        snd_ca0106_pcm_close_playback,\n        .prepare =      snd_ca0106_pcm_prepare_playback,     \n        .trigger =      snd_ca0106_pcm_trigger_playback,  \n        .pointer =      snd_ca0106_pcm_pointer_playback, \n};\n\nstatic const struct snd_pcm_ops snd_ca0106_playback_unknown_ops = {\n        .open =         snd_ca0106_pcm_open_playback_unknown,\n        .close =        snd_ca0106_pcm_close_playback,\n        .prepare =      snd_ca0106_pcm_prepare_playback,     \n        .trigger =      snd_ca0106_pcm_trigger_playback,  \n        .pointer =      snd_ca0106_pcm_pointer_playback, \n};\n\nstatic const struct snd_pcm_ops snd_ca0106_playback_rear_ops = {\n        .open =         snd_ca0106_pcm_open_playback_rear,\n        .close =        snd_ca0106_pcm_close_playback,\n        .prepare =      snd_ca0106_pcm_prepare_playback,     \n        .trigger =      snd_ca0106_pcm_trigger_playback,  \n        .pointer =      snd_ca0106_pcm_pointer_playback, \n};\n\n\nstatic unsigned short snd_ca0106_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t     unsigned short reg)\n{\n\tstruct snd_ca0106 *emu = ac97->private_data;\n\tunsigned long flags;\n\tunsigned short val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + CA0106_AC97ADDRESS);\n\tval = inw(emu->port + CA0106_AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nstatic void snd_ca0106_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t    unsigned short reg, unsigned short val)\n{\n\tstruct snd_ca0106 *emu = ac97->private_data;\n\tunsigned long flags;\n  \n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + CA0106_AC97ADDRESS);\n\toutw(val, emu->port + CA0106_AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic int snd_ca0106_ac97(struct snd_ca0106 *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_ca0106_ac97_write,\n\t\t.read = snd_ca0106_ac97_read,\n\t};\n  \n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\tpbus->no_vra = 1;  \n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.scaps = AC97_SCAP_NO_SPDIF;\n\treturn snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n}\n\nstatic void ca0106_stop_chip(struct snd_ca0106 *chip);\n\nstatic void snd_ca0106_free(struct snd_card *card)\n{\n\tstruct snd_ca0106 *chip = card->private_data;\n\n\tca0106_stop_chip(chip);\n}\n\nstatic irqreturn_t snd_ca0106_interrupt(int irq, void *dev_id)\n{\n\tunsigned int status;\n\n\tstruct snd_ca0106 *chip = dev_id;\n\tint i;\n\tint mask;\n        unsigned int stat76;\n\tstruct snd_ca0106_channel *pchannel;\n\n\tstatus = inl(chip->port + CA0106_IPR);\n\tif (! status)\n\t\treturn IRQ_NONE;\n\n        stat76 = snd_ca0106_ptr_read(chip, EXTENDED_INT, 0);\n\t \n        mask = 0x11;  \n\tfor(i = 0; i < 4; i++) {\n\t\tpchannel = &(chip->playback_channels[i]);\n\t\tif (stat76 & mask) {\n \n\t\t\tif(pchannel->use) {\n\t\t\t\tsnd_pcm_period_elapsed(pchannel->epcm->substream);\n\t\t\t\t \n                        }\n\t\t}\n\t\t \n\t\tmask <<= 1;\n\t}\n        mask = 0x110000;  \n\tfor(i = 0; i < 4; i++) {\n\t\tpchannel = &(chip->capture_channels[i]);\n\t\tif (stat76 & mask) {\n \n\t\t\tif(pchannel->use) {\n\t\t\t\tsnd_pcm_period_elapsed(pchannel->epcm->substream);\n\t\t\t\t \n                        }\n\t\t}\n\t\t \n\t\tmask <<= 1;\n\t}\n\n        snd_ca0106_ptr_write(chip, EXTENDED_INT, 0, stat76);\n\n\tif (chip->midi.dev_id &&\n\t    (status & (chip->midi.ipr_tx|chip->midi.ipr_rx))) {\n\t\tif (chip->midi.interrupt)\n\t\t\tchip->midi.interrupt(&chip->midi, status);\n\t\telse\n\t\t\tchip->midi.interrupt_disable(&chip->midi, chip->midi.tx_enable | chip->midi.rx_enable);\n\t}\n\n\t\n\toutl(status, chip->port + CA0106_IPR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_chmap_elem surround_map[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nstatic const struct snd_pcm_chmap_elem clfe_map[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ }\n};\n\nstatic const struct snd_pcm_chmap_elem side_map[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\n\nstatic int snd_ca0106_pcm(struct snd_ca0106 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tconst struct snd_pcm_chmap_elem *map = NULL;\n\tint err;\n  \n\terr = snd_pcm_new(emu->card, \"ca0106\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n  \n\tpcm->private_data = emu;\n\n\tswitch (device) {\n\tcase 0:\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_front_ops);\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_0_ops);\n\t  map = snd_pcm_std_chmaps;\n          break;\n\tcase 1:\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_rear_ops);\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_1_ops);\n\t  map = surround_map;\n          break;\n\tcase 2:\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_center_lfe_ops);\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_2_ops);\n\t  map = clfe_map;\n          break;\n\tcase 3:\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ca0106_playback_unknown_ops);\n\t  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ca0106_capture_3_ops);\n\t  map = side_map;\n          break;\n        }\n\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CA0106\");\n\n\tfor(substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; \n\t    substream; \n\t    substream = substream->next) {\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &emu->pci->dev,\n\t\t\t\t\t   64*1024, 64*1024);\n\t}\n\n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; \n\t      substream; \n\t      substream = substream->next) {\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &emu->pci->dev,\n\t\t\t\t\t   64*1024, 64*1024);\n\t}\n  \n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK, map, 2,\n\t\t\t\t     1 << 2, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\temu->pcm[device] = pcm;\n  \n\treturn 0;\n}\n\n#define SPI_REG(reg, value)\t(((reg) << SPI_REG_SHIFT) | (value))\nstatic const unsigned int spi_dac_init[] = {\n\tSPI_REG(SPI_LDA1_REG,\tSPI_DA_BIT_0dB),  \n\tSPI_REG(SPI_RDA1_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_PL_REG,\tSPI_PL_BIT_L_L | SPI_PL_BIT_R_R | SPI_IZD_BIT),\n\tSPI_REG(SPI_FMT_REG,\tSPI_FMT_BIT_I2S | SPI_IWL_BIT_24),\n\tSPI_REG(SPI_LDA2_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_RDA2_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_LDA3_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_RDA3_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_MASTDA_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(9,\t\t0x00),\n\tSPI_REG(SPI_MS_REG,\tSPI_DACD0_BIT | SPI_DACD1_BIT | SPI_DACD2_BIT),\n\tSPI_REG(12,\t\t0x00),\n\tSPI_REG(SPI_LDA4_REG,\tSPI_DA_BIT_0dB),\n\tSPI_REG(SPI_RDA4_REG,\tSPI_DA_BIT_0dB | SPI_DA_BIT_UPDATE),\n\tSPI_REG(SPI_DACD4_REG,\tSPI_DACD4_BIT),\n};\n\nstatic const unsigned int i2c_adc_init[][2] = {\n\t{ 0x17, 0x00 },  \n\t{ 0x07, 0x00 },  \n\t{ 0x0b, 0x22 },   \n\t{ 0x0c, 0x22 },   \n\t{ 0x0d, 0x08 },   \n\t{ 0x0e, 0xcf },   \n\t{ 0x0f, 0xcf },   \n\t{ 0x10, 0x7b },   \n\t{ 0x11, 0x00 },   \n\t{ 0x12, 0x32 },   \n\t{ 0x13, 0x00 },   \n\t{ 0x14, 0xa6 },   \n\t{ 0x15, ADC_MUX_LINEIN },   \n};\n\nstatic void ca0106_init_chip(struct snd_ca0106 *chip, int resume)\n{\n\tint ch;\n\tunsigned int def_bits;\n\n\toutl(0, chip->port + CA0106_INTE);\n\n\t \n\tdef_bits =\n\t\tSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\tSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\tSPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT;\n\tif (!resume) {\n\t\tchip->spdif_str_bits[0] = chip->spdif_bits[0] = def_bits;\n\t\tchip->spdif_str_bits[1] = chip->spdif_bits[1] = def_bits;\n\t\tchip->spdif_str_bits[2] = chip->spdif_bits[2] = def_bits;\n\t\tchip->spdif_str_bits[3] = chip->spdif_bits[3] = def_bits;\n\t}\n\t \n\tsnd_ca0106_ptr_write(chip, SPCS1, 0, chip->spdif_str_bits[1]);\n\tsnd_ca0106_ptr_write(chip, SPCS0, 0, chip->spdif_str_bits[0]);\n\tsnd_ca0106_ptr_write(chip, SPCS2, 0, chip->spdif_str_bits[2]);\n\tsnd_ca0106_ptr_write(chip, SPCS3, 0, chip->spdif_str_bits[3]);\n\n        snd_ca0106_ptr_write(chip, PLAYBACK_MUTE, 0, 0x00fc0000);\n        snd_ca0106_ptr_write(chip, CAPTURE_MUTE, 0, 0x00fc0000);\n\n         \n        outb(AC97_REC_GAIN, chip->port + CA0106_AC97ADDRESS);\n        outw(0x8000, chip->port + CA0106_AC97DATA);\n#if 0  \n\tsnd_ca0106_ptr_write(chip, SPCS0, 0, 0x2108006);\n\tsnd_ca0106_ptr_write(chip, 0x42, 0, 0x2108006);\n\tsnd_ca0106_ptr_write(chip, 0x43, 0, 0x2108006);\n\tsnd_ca0106_ptr_write(chip, 0x44, 0, 0x2108006);\n#endif\n\n\t \n\t \n\n\t \n\tsnd_ca0106_ptr_write(chip, SPDIF_SELECT1, 0, 0xf);\n\t \n\tsnd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000f0000);\n\n\tchip->spdif_enable = 0;  \n\t   \n\t   \n\n\t \n\tsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 0, 0x40c81000);\n\t \n\tsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 1, 0xffffffff);\n\t \n\tsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 2, 0x30300000);\n\t \n\tsnd_ca0106_ptr_write(chip, CAPTURE_CONTROL, 3, 0x00700000);\n\n\tsnd_ca0106_ptr_write(chip, PLAYBACK_ROUTING1, 0, 0x32765410);\n\tsnd_ca0106_ptr_write(chip, PLAYBACK_ROUTING2, 0, 0x76767676);\n\tsnd_ca0106_ptr_write(chip, CAPTURE_ROUTING1, 0, 0x32765410);\n\tsnd_ca0106_ptr_write(chip, CAPTURE_ROUTING2, 0, 0x76767676);\n\n\tfor (ch = 0; ch < 4; ch++) {\n\t\t \n\t\tsnd_ca0106_ptr_write(chip, CAPTURE_VOLUME1, ch, 0x30303030);\n\t\tsnd_ca0106_ptr_write(chip, CAPTURE_VOLUME2, ch, 0x30303030);\n#if 0  \n\t\tsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0x40404040);\n\t\tsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0x40404040);\n\t\tsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0xffffffff);\n\t\tsnd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0xffffffff);\n#endif\n\t}\n\tif (chip->details->i2c_adc == 1) {\n\t         \n\t        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);\n\t\t \n\t\tif (!resume)\n\t\t\tchip->capture_source = 3;\n\t} else if (chip->details->ac97 == 1) {\n\t         \n\t        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x444400e4);\n\t\t \n\t\tif (!resume)\n\t\t\tchip->capture_source = 4;\n\t} else {\n\t         \n\t        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);\n\t\t \n\t\tif (!resume)\n\t\t\tchip->capture_source = 3;\n\t}\n\n\tif (chip->details->gpio_type == 2) {\n\t\t \n\t\t \n\t\toutl(0x0, chip->port + CA0106_GPIO);\n\t\t   \n\t\toutl(0x005f5301, chip->port + CA0106_GPIO);  \n\t} else if (chip->details->gpio_type == 1) {\n\t\t \n\t\t \n\t\toutl(0x0, chip->port + CA0106_GPIO);\n\t\t   \n\t\toutl(0x005f5301, chip->port + CA0106_GPIO);  \n\t} else {\n\t\toutl(0x0, chip->port + CA0106_GPIO);\n\t\toutl(0x005f03a3, chip->port + CA0106_GPIO);  \n\t\t   \n\t}\n\tsnd_ca0106_intr_enable(chip, 0x105);  \n\n\t \n\t \n\t \n\t \n\t \n\toutl(HCFG_AC97 | HCFG_AUDIOENABLE, chip->port + CA0106_HCFG);\n\n\tif (chip->details->i2c_adc == 1) {\n\t\t \n\t\tint size, n;\n\n\t\tsize = ARRAY_SIZE(i2c_adc_init);\n\t\t \n\t\tfor (n = 0; n < size; n++)\n\t\t\tsnd_ca0106_i2c_write(chip, i2c_adc_init[n][0],\n\t\t\t\t\t     i2c_adc_init[n][1]);\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tchip->i2c_capture_volume[n][0] = 0xcf;\n\t\t\tchip->i2c_capture_volume[n][1] = 0xcf;\n\t\t}\n\t\tchip->i2c_capture_source = 2;  \n\t\t \n\t\t \n\t}\n\n\tif (chip->details->spi_dac) {\n\t\t \n\t\tint size, n;\n\n\t\tsize = ARRAY_SIZE(spi_dac_init);\n\t\tfor (n = 0; n < size; n++) {\n\t\t\tint reg = spi_dac_init[n] >> SPI_REG_SHIFT;\n\n\t\t\tsnd_ca0106_spi_write(chip, spi_dac_init[n]);\n\t\t\tif (reg < ARRAY_SIZE(chip->spi_dac_reg))\n\t\t\t\tchip->spi_dac_reg[reg] = spi_dac_init[n];\n\t\t}\n\n\t\t \n\t\tsnd_ca0106_pcm_power_dac(chip, PCM_FRONT_CHANNEL, 1);\n\t}\n}\n\nstatic void ca0106_stop_chip(struct snd_ca0106 *chip)\n{\n\t \n\tsnd_ca0106_ptr_write(chip, BASIC_INTERRUPT, 0, 0);\n\toutl(0, chip->port + CA0106_INTE);\n\tsnd_ca0106_ptr_write(chip, EXTENDED_INT_MASK, 0, 0);\n\tudelay(1000);\n\t \n\t \n\toutl(0, chip->port + CA0106_HCFG);\n\t \n}\n\nstatic int snd_ca0106_create(int dev, struct snd_card *card,\n\t\t\t     struct pci_dev *pci)\n{\n\tstruct snd_ca0106 *chip = card->private_data;\n\tconst struct snd_ca0106_details *c;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(card->dev, \"error to set 32bit mask DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\tspin_lock_init(&chip->emu_lock);\n\n\terr = pci_request_regions(pci, \"snd_ca0106\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->port = pci_resource_start(pci, 0);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_ca0106_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"cannot grab irq\\n\");\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\t \n\tchip->buffer = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV, 1024);\n\tif (!chip->buffer)\n\t\treturn -ENOMEM;\n\n\tpci_set_master(pci);\n\t \n\tpci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);\n\tdev_info(card->dev, \"Model %04x Rev %08x Serial %08x\\n\",\n\t       chip->model, pci->revision, chip->serial);\n\tstrcpy(card->driver, \"CA0106\");\n\tstrcpy(card->shortname, \"CA0106\");\n\n\tfor (c = ca0106_chip_details; c->serial; c++) {\n\t\tif (subsystem[dev]) {\n\t\t\tif (c->serial == subsystem[dev])\n\t\t\t\tbreak;\n\t\t} else if (c->serial == chip->serial)\n\t\t\tbreak;\n\t}\n\tchip->details = c;\n\tif (subsystem[dev]) {\n\t\tdev_info(card->dev, \"Sound card name=%s, \"\n\t\t       \"subsystem=0x%x. Forced to subsystem=0x%x\\n\",\n\t\t       c->name, chip->serial, subsystem[dev]);\n\t}\n\n\tsprintf(card->longname, \"%s at 0x%lx irq %i\",\n\t\tc->name, chip->port, chip->irq);\n\n\tca0106_init_chip(chip, 0);\n\treturn 0;\n}\n\n\nstatic void ca0106_midi_interrupt_enable(struct snd_ca_midi *midi, int intr)\n{\n\tsnd_ca0106_intr_enable((struct snd_ca0106 *)(midi->dev_id), intr);\n}\n\nstatic void ca0106_midi_interrupt_disable(struct snd_ca_midi *midi, int intr)\n{\n\tsnd_ca0106_intr_disable((struct snd_ca0106 *)(midi->dev_id), intr);\n}\n\nstatic unsigned char ca0106_midi_read(struct snd_ca_midi *midi, int idx)\n{\n\treturn (unsigned char)snd_ca0106_ptr_read((struct snd_ca0106 *)(midi->dev_id),\n\t\t\t\t\t\t  midi->port + idx, 0);\n}\n\nstatic void ca0106_midi_write(struct snd_ca_midi *midi, int data, int idx)\n{\n\tsnd_ca0106_ptr_write((struct snd_ca0106 *)(midi->dev_id), midi->port + idx, 0, data);\n}\n\nstatic struct snd_card *ca0106_dev_id_card(void *dev_id)\n{\n\treturn ((struct snd_ca0106 *)dev_id)->card;\n}\n\nstatic int ca0106_dev_id_port(void *dev_id)\n{\n\treturn ((struct snd_ca0106 *)dev_id)->port;\n}\n\nstatic int snd_ca0106_midi(struct snd_ca0106 *chip, unsigned int channel)\n{\n\tstruct snd_ca_midi *midi;\n\tchar *name;\n\tint err;\n\n\tif (channel == CA0106_MIDI_CHAN_B) {\n\t\tname = \"CA0106 MPU-401 (UART) B\";\n\t\tmidi =  &chip->midi2;\n\t\tmidi->tx_enable = INTE_MIDI_TX_B;\n\t\tmidi->rx_enable = INTE_MIDI_RX_B;\n\t\tmidi->ipr_tx = IPR_MIDI_TX_B;\n\t\tmidi->ipr_rx = IPR_MIDI_RX_B;\n\t\tmidi->port = MIDI_UART_B_DATA;\n\t} else {\n\t\tname = \"CA0106 MPU-401 (UART)\";\n\t\tmidi =  &chip->midi;\n\t\tmidi->tx_enable = INTE_MIDI_TX_A;\n\t\tmidi->rx_enable = INTE_MIDI_TX_B;\n\t\tmidi->ipr_tx = IPR_MIDI_TX_A;\n\t\tmidi->ipr_rx = IPR_MIDI_RX_A;\n\t\tmidi->port = MIDI_UART_A_DATA;\n\t}\n\n\tmidi->reset = CA0106_MPU401_RESET;\n\tmidi->enter_uart = CA0106_MPU401_ENTER_UART;\n\tmidi->ack = CA0106_MPU401_ACK;\n\n\tmidi->input_avail = CA0106_MIDI_INPUT_AVAIL;\n\tmidi->output_ready = CA0106_MIDI_OUTPUT_READY;\n\n\tmidi->channel = channel;\n\n\tmidi->interrupt_enable = ca0106_midi_interrupt_enable;\n\tmidi->interrupt_disable = ca0106_midi_interrupt_disable;\n\n\tmidi->read = ca0106_midi_read;\n\tmidi->write = ca0106_midi_write;\n\n\tmidi->get_dev_id_card = ca0106_dev_id_card;\n\tmidi->get_dev_id_port = ca0106_dev_id_port;\n\n\tmidi->dev_id = chip;\n\t\n\terr = ca_midi_init(chip, midi, 0, name);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\nstatic int __snd_ca0106_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_ca0106 *chip;\n\tint i, err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_ca0106_create(dev, card, pci);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = snd_ca0106_free;\n\n\tfor (i = 0; i < 4; i++) {\n\t\terr = snd_ca0106_pcm(chip, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (chip->details->ac97 == 1) {\n\t\t \n\t\terr = snd_ca0106_ac97(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_ca0106_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(card->dev, \"probe for MIDI channel A ...\");\n\terr = snd_ca0106_midi(chip, CA0106_MIDI_CHAN_A);\n\tif (err < 0)\n\t\treturn err;\n\tdev_dbg(card->dev, \" done.\\n\");\n\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_ca0106_proc_init(chip);\n#endif\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_ca0106_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_ca0106_probe(pci, pci_id));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_ca0106_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ca0106 *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tif (chip->details->ac97)\n\t\tsnd_ac97_suspend(chip->ac97);\n\tsnd_ca0106_mixer_suspend(chip);\n\n\tca0106_stop_chip(chip);\n\treturn 0;\n}\n\nstatic int snd_ca0106_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_ca0106 *chip = card->private_data;\n\tint i;\n\n\tca0106_init_chip(chip, 1);\n\n\tif (chip->details->ac97)\n\t\tsnd_ac97_resume(chip->ac97);\n\tsnd_ca0106_mixer_resume(chip);\n\tif (chip->details->spi_dac) {\n\t\tfor (i = 0; i < ARRAY_SIZE(chip->spi_dac_reg); i++)\n\t\t\tsnd_ca0106_spi_write(chip, chip->spi_dac_reg[i]);\n\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_ca0106_pm, snd_ca0106_suspend, snd_ca0106_resume);\n#define SND_CA0106_PM_OPS\t&snd_ca0106_pm\n#else\n#define SND_CA0106_PM_OPS\tNULL\n#endif\n\n\nstatic const struct pci_device_id snd_ca0106_ids[] = {\n\t{ PCI_VDEVICE(CREATIVE, 0x0007), 0 },\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, snd_ca0106_ids);\n\n\nstatic struct pci_driver ca0106_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_ca0106_ids,\n\t.probe = snd_ca0106_probe,\n\t.driver = {\n\t\t.pm = SND_CA0106_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(ca0106_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}