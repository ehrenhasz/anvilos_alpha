{
  "module_name": "fm801.c",
  "hash_id": "66a3131ba2e60b97ab828abe1a12792c11ef10ecdb43fcad41ad29f951c41a1b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/fm801.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n#include <sound/ac97_codec.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n#include <media/drv-intf/tea575x.h>\n#endif\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"ForteMedia FM801\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n \nstatic int tea575x_tuner[SNDRV_CARDS];\nstatic int radio_nr[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the FM801 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the FM801 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable FM801 soundcard.\");\nmodule_param_array(tea575x_tuner, int, NULL, 0444);\nMODULE_PARM_DESC(tea575x_tuner, \"TEA575x tuner access method (0 = auto, 1 = SF256-PCS, 2=SF256-PCP, 3=SF64-PCR, 8=disable, +16=tuner-only).\");\nmodule_param_array(radio_nr, int, NULL, 0444);\nMODULE_PARM_DESC(radio_nr, \"Radio device numbers\");\n\n\n#define TUNER_DISABLED\t\t(1<<3)\n#define TUNER_ONLY\t\t(1<<4)\n#define TUNER_TYPE_MASK\t\t(~TUNER_ONLY & 0xFFFF)\n\n \n\n#define fm801_writew(chip,reg,value)\toutw((value), chip->port + FM801_##reg)\n#define fm801_readw(chip,reg)\t\tinw(chip->port + FM801_##reg)\n\n#define fm801_writel(chip,reg,value)\toutl((value), chip->port + FM801_##reg)\n\n#define FM801_PCM_VOL\t\t0x00\t \n#define FM801_FM_VOL\t\t0x02\t \n#define FM801_I2S_VOL\t\t0x04\t \n#define FM801_REC_SRC\t\t0x06\t \n#define FM801_PLY_CTRL\t\t0x08\t \n#define FM801_PLY_COUNT\t\t0x0a\t \n#define FM801_PLY_BUF1\t\t0x0c\t \n#define FM801_PLY_BUF2\t\t0x10\t \n#define FM801_CAP_CTRL\t\t0x14\t \n#define FM801_CAP_COUNT\t\t0x16\t \n#define FM801_CAP_BUF1\t\t0x18\t \n#define FM801_CAP_BUF2\t\t0x1c\t \n#define FM801_CODEC_CTRL\t0x22\t \n#define FM801_I2S_MODE\t\t0x24\t \n#define FM801_VOLUME\t\t0x26\t \n#define FM801_I2C_CTRL\t\t0x29\t \n#define FM801_AC97_CMD\t\t0x2a\t \n#define FM801_AC97_DATA\t\t0x2c\t \n#define FM801_MPU401_DATA\t0x30\t \n#define FM801_MPU401_CMD\t0x31\t \n#define FM801_GPIO_CTRL\t\t0x52\t \n#define FM801_GEN_CTRL\t\t0x54\t \n#define FM801_IRQ_MASK\t\t0x56\t \n#define FM801_IRQ_STATUS\t0x5a\t \n#define FM801_OPL3_BANK0\t0x68\t \n#define FM801_OPL3_DATA0\t0x69\t \n#define FM801_OPL3_BANK1\t0x6a\t \n#define FM801_OPL3_DATA1\t0x6b\t \n#define FM801_POWERDOWN\t\t0x70\t \n\n \n#define FM801_AC97_READ\t\t(1<<7)\t \n#define FM801_AC97_VALID\t(1<<8)\t \n#define FM801_AC97_BUSY\t\t(1<<9)\t \n#define FM801_AC97_ADDR_SHIFT\t10\t \n\n \n#define FM801_BUF1_LAST\t\t(1<<1)\n#define FM801_BUF2_LAST\t\t(1<<2)\n#define FM801_START\t\t(1<<5)\n#define FM801_PAUSE\t\t(1<<6)\n#define FM801_IMMED_STOP\t(1<<7)\n#define FM801_RATE_SHIFT\t8\n#define FM801_RATE_MASK\t\t(15 << FM801_RATE_SHIFT)\n#define FM801_CHANNELS_4\t(1<<12)\t \n#define FM801_CHANNELS_6\t(2<<12)\t \n#define FM801_CHANNELS_6MS\t(3<<12)\t \n#define FM801_CHANNELS_MASK\t(3<<12)\n#define FM801_16BIT\t\t(1<<14)\n#define FM801_STEREO\t\t(1<<15)\n\n \n#define FM801_IRQ_PLAYBACK\t(1<<8)\n#define FM801_IRQ_CAPTURE\t(1<<9)\n#define FM801_IRQ_VOLUME\t(1<<14)\n#define FM801_IRQ_MPU\t\t(1<<15)\n\n \n#define FM801_GPIO_GP0\t\t(1<<0)\t \n#define FM801_GPIO_GP1\t\t(1<<1)\n#define FM801_GPIO_GP2\t\t(1<<2)\n#define FM801_GPIO_GP3\t\t(1<<3)\n#define FM801_GPIO_GP(x)\t(1<<(0+(x)))\n#define FM801_GPIO_GD0\t\t(1<<8)\t \n#define FM801_GPIO_GD1\t\t(1<<9)\n#define FM801_GPIO_GD2\t\t(1<<10)\n#define FM801_GPIO_GD3\t\t(1<<11)\n#define FM801_GPIO_GD(x)\t(1<<(8+(x)))\n#define FM801_GPIO_GS0\t\t(1<<12)\t \n#define FM801_GPIO_GS1\t\t(1<<13)\t \n#define FM801_GPIO_GS2\t\t(1<<14)\t \n#define FM801_GPIO_GS3\t\t(1<<15)\n#define FM801_GPIO_GS(x)\t(1<<(12+(x)))\n\t\n \nstruct fm801 {\n\tstruct device *dev;\n\tint irq;\n\n\tunsigned long port;\n\tunsigned int multichannel: 1,\n\t\t     secondary: 1;\n\tunsigned char secondary_addr;\n\tunsigned int tea575x_tuner;\n\n\tunsigned short ply_ctrl;\n\tunsigned short cap_ctrl;\n\n\tunsigned long ply_buffer;\n\tunsigned int ply_buf;\n\tunsigned int ply_count;\n\tunsigned int ply_size;\n\tunsigned int ply_pos;\n\n\tunsigned long cap_buffer;\n\tunsigned int cap_buf;\n\tunsigned int cap_count;\n\tunsigned int cap_size;\n\tunsigned int cap_pos;\n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\tstruct snd_ac97 *ac97_sec;\n\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_pcm_substream *playback_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\tunsigned int p_dma_size;\n\tunsigned int c_dma_size;\n\n\tspinlock_t reg_lock;\n\tstruct snd_info_entry *proc_entry;\n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n\tstruct v4l2_device v4l2_dev;\n\tstruct snd_tea575x tea;\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n\tu16 saved_regs[0x20];\n#endif\n};\n\n \n\nstatic inline void fm801_iowrite16(struct fm801 *chip, unsigned short offset, u16 value)\n{\n\toutw(value, chip->port + offset);\n}\n\nstatic inline u16 fm801_ioread16(struct fm801 *chip, unsigned short offset)\n{\n\treturn inw(chip->port + offset);\n}\n\nstatic const struct pci_device_id snd_fm801_ids[] = {\n\t{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },    \n\t{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_fm801_ids);\n\n \n\nstatic bool fm801_ac97_is_ready(struct fm801 *chip, unsigned int iterations)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < iterations; idx++) {\n\t\tif (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\treturn false;\n}\n\nstatic bool fm801_ac97_is_valid(struct fm801 *chip, unsigned int iterations)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < iterations; idx++) {\n\t\tif (fm801_readw(chip, AC97_CMD) & FM801_AC97_VALID)\n\t\t\treturn true;\n\t\tudelay(10);\n\t}\n\treturn false;\n}\n\nstatic int snd_fm801_update_bits(struct fm801 *chip, unsigned short reg,\n\t\t\t\t unsigned short mask, unsigned short value)\n{\n\tint change;\n\tunsigned long flags;\n\tunsigned short old, new;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\told = fm801_ioread16(chip, reg);\n\tnew = (old & ~mask) | value;\n\tchange = old != new;\n\tif (change)\n\t\tfm801_iowrite16(chip, reg, new);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn change;\n}\n\nstatic void snd_fm801_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t  unsigned short reg,\n\t\t\t\t  unsigned short val)\n{\n\tstruct fm801 *chip = ac97->private_data;\n\n\t \n\tif (!fm801_ac97_is_ready(chip, 100)) {\n\t\tdev_err(chip->card->dev, \"AC'97 interface is busy (1)\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfm801_writew(chip, AC97_DATA, val);\n\tfm801_writew(chip, AC97_CMD, reg | (ac97->addr << FM801_AC97_ADDR_SHIFT));\n\t \n\tif (!fm801_ac97_is_ready(chip, 1000))\n\t\tdev_err(chip->card->dev, \"AC'97 interface #%d is busy (2)\\n\",\n\t\tac97->num);\n}\n\nstatic unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct fm801 *chip = ac97->private_data;\n\n\t \n\tif (!fm801_ac97_is_ready(chip, 100)) {\n\t\tdev_err(chip->card->dev, \"AC'97 interface is busy (1)\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfm801_writew(chip, AC97_CMD,\n\t\t     reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ);\n\tif (!fm801_ac97_is_ready(chip, 100)) {\n\t\tdev_err(chip->card->dev, \"AC'97 interface #%d is busy (2)\\n\",\n\t\t\tac97->num);\n\t\treturn 0;\n\t}\n\n\tif (!fm801_ac97_is_valid(chip, 1000)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"AC'97 interface #%d is not valid (2)\\n\", ac97->num);\n\t\treturn 0;\n\t}\n\n\treturn fm801_readw(chip, AC97_DATA);\n}\n\nstatic const unsigned int rates[] = {\n  5500,  8000,  9600, 11025,\n  16000, 19200, 22050, 32000,\n  38400, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t.count = ARRAY_SIZE(rates),\n\t.list = rates,\n\t.mask = 0,\n};\n\nstatic const unsigned int channels[] = {\n  2, 4, 6\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels = {\n\t.count = ARRAY_SIZE(channels),\n\t.list = channels,\n\t.mask = 0,\n};\n\n \n\nstatic unsigned short snd_fm801_rate_bits(unsigned int rate)\n{\n\tunsigned int idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(rates); idx++)\n\t\tif (rates[idx] == rate)\n\t\t\treturn idx;\n\tsnd_BUG();\n\treturn ARRAY_SIZE(rates) - 1;\n}\n\n \n\nstatic int snd_fm801_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tchip->ply_ctrl &= ~(FM801_BUF1_LAST |\n\t\t\t\t     FM801_BUF2_LAST |\n\t\t\t\t     FM801_PAUSE);\n\t\tchip->ply_ctrl |= FM801_START |\n\t\t\t\t   FM801_IMMED_STOP;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tchip->ply_ctrl &= ~(FM801_START | FM801_PAUSE);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tchip->ply_ctrl |= FM801_PAUSE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->ply_ctrl &= ~FM801_PAUSE;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\tfm801_writew(chip, PLY_CTRL, chip->ply_ctrl);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tchip->cap_ctrl &= ~(FM801_BUF1_LAST |\n\t\t\t\t     FM801_BUF2_LAST |\n\t\t\t\t     FM801_PAUSE);\n\t\tchip->cap_ctrl |= FM801_START |\n\t\t\t\t   FM801_IMMED_STOP;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tchip->cap_ctrl &= ~(FM801_START | FM801_PAUSE);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tchip->cap_ctrl |= FM801_PAUSE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tchip->cap_ctrl &= ~FM801_PAUSE;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\tfm801_writew(chip, CAP_CTRL, chip->cap_ctrl);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_fm801_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tchip->ply_size = snd_pcm_lib_buffer_bytes(substream);\n\tchip->ply_count = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->ply_ctrl &= ~(FM801_START | FM801_16BIT |\n\t\t\t     FM801_STEREO | FM801_RATE_MASK |\n\t\t\t     FM801_CHANNELS_MASK);\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tchip->ply_ctrl |= FM801_16BIT;\n\tif (runtime->channels > 1) {\n\t\tchip->ply_ctrl |= FM801_STEREO;\n\t\tif (runtime->channels == 4)\n\t\t\tchip->ply_ctrl |= FM801_CHANNELS_4;\n\t\telse if (runtime->channels == 6)\n\t\t\tchip->ply_ctrl |= FM801_CHANNELS_6;\n\t}\n\tchip->ply_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;\n\tchip->ply_buf = 0;\n\tfm801_writew(chip, PLY_CTRL, chip->ply_ctrl);\n\tfm801_writew(chip, PLY_COUNT, chip->ply_count - 1);\n\tchip->ply_buffer = runtime->dma_addr;\n\tchip->ply_pos = 0;\n\tfm801_writel(chip, PLY_BUF1, chip->ply_buffer);\n\tfm801_writel(chip, PLY_BUF2,\n\t\t     chip->ply_buffer + (chip->ply_count % chip->ply_size));\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_fm801_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tchip->cap_size = snd_pcm_lib_buffer_bytes(substream);\n\tchip->cap_count = snd_pcm_lib_period_bytes(substream);\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->cap_ctrl &= ~(FM801_START | FM801_16BIT |\n\t\t\t     FM801_STEREO | FM801_RATE_MASK);\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tchip->cap_ctrl |= FM801_16BIT;\n\tif (runtime->channels > 1)\n\t\tchip->cap_ctrl |= FM801_STEREO;\n\tchip->cap_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;\n\tchip->cap_buf = 0;\n\tfm801_writew(chip, CAP_CTRL, chip->cap_ctrl);\n\tfm801_writew(chip, CAP_COUNT, chip->cap_count - 1);\n\tchip->cap_buffer = runtime->dma_addr;\n\tchip->cap_pos = 0;\n\tfm801_writel(chip, CAP_BUF1, chip->cap_buffer);\n\tfm801_writel(chip, CAP_BUF2,\n\t\t     chip->cap_buffer + (chip->cap_count % chip->cap_size));\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_fm801_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(chip->ply_ctrl & FM801_START))\n\t\treturn 0;\n\tspin_lock(&chip->reg_lock);\n\tptr = chip->ply_pos + (chip->ply_count - 1) - fm801_readw(chip, PLY_COUNT);\n\tif (fm801_readw(chip, IRQ_STATUS) & FM801_IRQ_PLAYBACK) {\n\t\tptr += chip->ply_count;\n\t\tptr %= chip->ply_size;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_fm801_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(chip->cap_ctrl & FM801_START))\n\t\treturn 0;\n\tspin_lock(&chip->reg_lock);\n\tptr = chip->cap_pos + (chip->cap_count - 1) - fm801_readw(chip, CAP_COUNT);\n\tif (fm801_readw(chip, IRQ_STATUS) & FM801_IRQ_CAPTURE) {\n\t\tptr += chip->cap_count;\n\t\tptr %= chip->cap_size;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)\n{\n\tstruct fm801 *chip = dev_id;\n\tunsigned short status;\n\tunsigned int tmp;\n\n\tstatus = fm801_readw(chip, IRQ_STATUS);\n\tstatus &= FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU|FM801_IRQ_VOLUME;\n\tif (! status)\n\t\treturn IRQ_NONE;\n\t \n\tfm801_writew(chip, IRQ_STATUS, status);\n\tif (chip->pcm && (status & FM801_IRQ_PLAYBACK) && chip->playback_substream) {\n\t\tspin_lock(&chip->reg_lock);\n\t\tchip->ply_buf++;\n\t\tchip->ply_pos += chip->ply_count;\n\t\tchip->ply_pos %= chip->ply_size;\n\t\ttmp = chip->ply_pos + chip->ply_count;\n\t\ttmp %= chip->ply_size;\n\t\tif (chip->ply_buf & 1)\n\t\t\tfm801_writel(chip, PLY_BUF1, chip->ply_buffer + tmp);\n\t\telse\n\t\t\tfm801_writel(chip, PLY_BUF2, chip->ply_buffer + tmp);\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t}\n\tif (chip->pcm && (status & FM801_IRQ_CAPTURE) && chip->capture_substream) {\n\t\tspin_lock(&chip->reg_lock);\n\t\tchip->cap_buf++;\n\t\tchip->cap_pos += chip->cap_count;\n\t\tchip->cap_pos %= chip->cap_size;\n\t\ttmp = chip->cap_pos + chip->cap_count;\n\t\ttmp %= chip->cap_size;\n\t\tif (chip->cap_buf & 1)\n\t\t\tfm801_writel(chip, CAP_BUF1, chip->cap_buffer + tmp);\n\t\telse\n\t\t\tfm801_writel(chip, CAP_BUF2, chip->cap_buffer + tmp);\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t}\n\tif (chip->rmidi && (status & FM801_IRQ_MPU))\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\tif (status & FM801_IRQ_VOLUME) {\n\t\t \n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware snd_fm801_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5500,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_fm801_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5500,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_fm801_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tchip->playback_substream = substream;\n\truntime->hw = snd_fm801_playback;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &hw_constraints_rates);\n\tif (chip->multichannel) {\n\t\truntime->hw.channels_max = 6;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   &hw_constraints_channels);\n\t}\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_fm801_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tchip->capture_substream = substream;\n\truntime->hw = snd_fm801_capture;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &hw_constraints_rates);\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int snd_fm801_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_fm801_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct fm801 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_fm801_playback_ops = {\n\t.open =\t\tsnd_fm801_playback_open,\n\t.close =\tsnd_fm801_playback_close,\n\t.prepare =\tsnd_fm801_playback_prepare,\n\t.trigger =\tsnd_fm801_playback_trigger,\n\t.pointer =\tsnd_fm801_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_fm801_capture_ops = {\n\t.open =\t\tsnd_fm801_capture_open,\n\t.close =\tsnd_fm801_capture_close,\n\t.prepare =\tsnd_fm801_capture_prepare,\n\t.trigger =\tsnd_fm801_capture_trigger,\n\t.pointer =\tsnd_fm801_capture_pointer,\n};\n\nstatic int snd_fm801_pcm(struct fm801 *chip, int device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(chip->dev);\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"FM801\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_fm801_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_fm801_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"FM801\");\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &pdev->dev,\n\t\t\t\t       chip->multichannel ? 128*1024 : 64*1024, 128*1024);\n\n\treturn snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps,\n\t\t\t\t     chip->multichannel ? 6 : 2, 0,\n\t\t\t\t     NULL);\n}\n\n \n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n\n \nstruct snd_fm801_tea575x_gpio {\n\tu8 data, clk, wren, most;\n\tchar *name;\n};\n\nstatic const struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {\n\t{ .data = 1, .clk = 3, .wren = 2, .most = 0, .name = \"SF256-PCS\" },\n\t{ .data = 1, .clk = 0, .wren = 2, .most = 3, .name = \"SF256-PCP\" },\n\t{ .data = 2, .clk = 0, .wren = 1, .most = 3, .name = \"SF64-PCR\" },\n};\n\n#define get_tea575x_gpio(chip) \\\n\t(&snd_fm801_tea575x_gpios[((chip)->tea575x_tuner & TUNER_TYPE_MASK) - 1])\n\nstatic void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)\n{\n\tstruct fm801 *chip = tea->private_data;\n\tunsigned short reg = fm801_readw(chip, GPIO_CTRL);\n\tstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\n\treg &= ~(FM801_GPIO_GP(gpio.data) |\n\t\t FM801_GPIO_GP(gpio.clk) |\n\t\t FM801_GPIO_GP(gpio.wren));\n\n\treg |= (pins & TEA575X_DATA) ? FM801_GPIO_GP(gpio.data) : 0;\n\treg |= (pins & TEA575X_CLK)  ? FM801_GPIO_GP(gpio.clk) : 0;\n\t \n\treg |= (pins & TEA575X_WREN) ? 0 : FM801_GPIO_GP(gpio.wren);\n\n\tfm801_writew(chip, GPIO_CTRL, reg);\n}\n\nstatic u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)\n{\n\tstruct fm801 *chip = tea->private_data;\n\tunsigned short reg = fm801_readw(chip, GPIO_CTRL);\n\tstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\tu8 ret;\n\n\tret = 0;\n\tif (reg & FM801_GPIO_GP(gpio.data))\n\t\tret |= TEA575X_DATA;\n\tif (reg & FM801_GPIO_GP(gpio.most))\n\t\tret |= TEA575X_MOST;\n\treturn ret;\n}\n\nstatic void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output)\n{\n\tstruct fm801 *chip = tea->private_data;\n\tunsigned short reg = fm801_readw(chip, GPIO_CTRL);\n\tstruct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);\n\n\t \n\treg |= FM801_GPIO_GS(gpio.data) |\n\t       FM801_GPIO_GS(gpio.wren) |\n\t       FM801_GPIO_GS(gpio.clk) |\n\t       FM801_GPIO_GS(gpio.most);\n\tif (output) {\n\t\t \n\t\t \n\t\treg &= ~(FM801_GPIO_GD(gpio.data) |\n\t\t\t FM801_GPIO_GD(gpio.wren) |\n\t\t\t FM801_GPIO_GD(gpio.clk) |\n\t\t\t FM801_GPIO_GP(gpio.data) |\n\t\t\t FM801_GPIO_GP(gpio.clk) |\n\t\t\t FM801_GPIO_GP(gpio.wren));\n\t} else {\n\t\t \n\t\treg |= FM801_GPIO_GD(gpio.data) |\n\t\t       FM801_GPIO_GD(gpio.most) |\n\t\t       FM801_GPIO_GP(gpio.data) |\n\t\t       FM801_GPIO_GP(gpio.most) |\n\t\t       FM801_GPIO_GP(gpio.wren);\n\t\t \n\t\t \n\t\treg &= ~(FM801_GPIO_GD(gpio.wren) |\n\t\t\t FM801_GPIO_GD(gpio.clk) |\n\t\t\t FM801_GPIO_GP(gpio.clk));\n\t}\n\n\tfm801_writew(chip, GPIO_CTRL, reg);\n}\n\nstatic const struct snd_tea575x_ops snd_fm801_tea_ops = {\n\t.set_pins = snd_fm801_tea575x_set_pins,\n\t.get_pins = snd_fm801_tea575x_get_pins,\n\t.set_direction = snd_fm801_tea575x_set_direction,\n};\n#endif\n\n \n\n#define FM801_SINGLE(xname, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_single, \\\n  .get = snd_fm801_get_single, .put = snd_fm801_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_fm801_info_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_fm801_get_single(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tlong *value = ucontrol->value.integer.value;\n\n\tvalue[0] = (fm801_ioread16(chip, reg) >> shift) & mask;\n\tif (invert)\n\t\tvalue[0] = mask - value[0];\n\treturn 0;\n}\n\nstatic int snd_fm801_put_single(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned short val;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\treturn snd_fm801_update_bits(chip, reg, mask << shift, val << shift);\n}\n\n#define FM801_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_double, \\\n  .get = snd_fm801_get_double, .put = snd_fm801_put_double, \\\n  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }\n#define FM801_DOUBLE_TLV(xname, reg, shift_left, shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .info = snd_fm801_info_double, \\\n  .get = snd_fm801_get_double, .put = snd_fm801_put_double, \\\n  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = (xtlv) } }\n\nstatic int snd_fm801_info_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_fm801_get_double(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n        int reg = kcontrol->private_value & 0xff;\n\tint shift_left = (kcontrol->private_value >> 8) & 0x0f;\n\tint shift_right = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tlong *value = ucontrol->value.integer.value;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tvalue[0] = (fm801_ioread16(chip, reg) >> shift_left) & mask;\n\tvalue[1] = (fm801_ioread16(chip, reg) >> shift_right) & mask;\n\tspin_unlock_irq(&chip->reg_lock);\n\tif (invert) {\n\t\tvalue[0] = mask - value[0];\n\t\tvalue[1] = mask - value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_fm801_put_double(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift_left = (kcontrol->private_value >> 8) & 0x0f;\n\tint shift_right = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned short val1, val2;\n \n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\treturn snd_fm801_update_bits(chip, reg,\n\t\t\t\t     (mask << shift_left) | (mask << shift_right),\n\t\t\t\t     (val1 << shift_left ) | (val2 << shift_right));\n}\n\nstatic int snd_fm801_info_mux(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[5] = {\n\t\t\"AC97 Primary\", \"FM\", \"I2S\", \"PCM\", \"AC97 Secondary\"\n\t};\n \n\treturn snd_ctl_enum_info(uinfo, 1, 5, texts);\n}\n\nstatic int snd_fm801_get_mux(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n        unsigned short val;\n \n\tval = fm801_readw(chip, REC_SRC) & 7;\n\tif (val > 4)\n\t\tval = 4;\n        ucontrol->value.enumerated.item[0] = val;\n        return 0;\n}\n\nstatic int snd_fm801_put_mux(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct fm801 *chip = snd_kcontrol_chip(kcontrol);\n        unsigned short val;\n \n\tval = ucontrol->value.enumerated.item[0];\n\tif (val > 4)\n                return -EINVAL;\n\treturn snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);\n\n#define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)\n\nstatic const struct snd_kcontrol_new snd_fm801_controls[] = {\nFM801_DOUBLE_TLV(\"Wave Playback Volume\", FM801_PCM_VOL, 0, 8, 31, 1,\n\t\t db_scale_dsp),\nFM801_SINGLE(\"Wave Playback Switch\", FM801_PCM_VOL, 15, 1, 1),\nFM801_DOUBLE_TLV(\"I2S Playback Volume\", FM801_I2S_VOL, 0, 8, 31, 1,\n\t\t db_scale_dsp),\nFM801_SINGLE(\"I2S Playback Switch\", FM801_I2S_VOL, 15, 1, 1),\nFM801_DOUBLE_TLV(\"FM Playback Volume\", FM801_FM_VOL, 0, 8, 31, 1,\n\t\t db_scale_dsp),\nFM801_SINGLE(\"FM Playback Switch\", FM801_FM_VOL, 15, 1, 1),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Digital Capture Source\",\n\t.info = snd_fm801_info_mux,\n\t.get = snd_fm801_get_mux,\n\t.put = snd_fm801_put_mux,\n}\n};\n\n#define FM801_CONTROLS_MULTI ARRAY_SIZE(snd_fm801_controls_multi)\n\nstatic const struct snd_kcontrol_new snd_fm801_controls_multi[] = {\nFM801_SINGLE(\"AC97 2ch->4ch Copy Switch\", FM801_CODEC_CTRL, 7, 1, 0),\nFM801_SINGLE(\"AC97 18-bit Switch\", FM801_CODEC_CTRL, 10, 1, 0),\nFM801_SINGLE(SNDRV_CTL_NAME_IEC958(\"\",CAPTURE,SWITCH), FM801_I2S_MODE, 8, 1, 0),\nFM801_SINGLE(SNDRV_CTL_NAME_IEC958(\"Raw Data \",PLAYBACK,SWITCH), FM801_I2S_MODE, 9, 1, 0),\nFM801_SINGLE(SNDRV_CTL_NAME_IEC958(\"Raw Data \",CAPTURE,SWITCH), FM801_I2S_MODE, 10, 1, 0),\nFM801_SINGLE(SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,SWITCH), FM801_GEN_CTRL, 2, 1, 0),\n};\n\nstatic int snd_fm801_mixer(struct fm801 *chip)\n{\n\tstruct snd_ac97_template ac97;\n\tunsigned int i;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_fm801_codec_write,\n\t\t.read = snd_fm801_codec_read,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\tif (chip->secondary) {\n\t\tac97.num = 1;\n\t\tac97.addr = chip->secondary_addr;\n\t\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_sec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < FM801_CONTROLS; i++) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t\tsnd_ctl_new1(&snd_fm801_controls[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->multichannel) {\n\t\tfor (i = 0; i < FM801_CONTROLS_MULTI; i++) {\n\t\t\terr = snd_ctl_add(chip->card,\n\t\t\t\tsnd_ctl_new1(&snd_fm801_controls_multi[i], chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int wait_for_codec(struct fm801 *chip, unsigned int codec_id,\n\t\t\t  unsigned short reg, unsigned long waits)\n{\n\tunsigned long timeout = jiffies + waits;\n\n\tfm801_writew(chip, AC97_CMD,\n\t\t     reg | (codec_id << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ);\n\tudelay(5);\n\tdo {\n\t\tif ((fm801_readw(chip, AC97_CMD) &\n\t\t     (FM801_AC97_VALID | FM801_AC97_BUSY)) == FM801_AC97_VALID)\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after(timeout, jiffies));\n\treturn -EIO;\n}\n\nstatic int reset_codec(struct fm801 *chip)\n{\n\t \n\tfm801_writew(chip, CODEC_CTRL, (1 << 5) | (1 << 6));\n\tfm801_readw(chip, CODEC_CTRL);  \n\tudelay(100);\n\tfm801_writew(chip, CODEC_CTRL, 0);\n\n\treturn wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750));\n}\n\nstatic void snd_fm801_chip_multichannel_init(struct fm801 *chip)\n{\n\tunsigned short cmdw;\n\n\tif (chip->multichannel) {\n\t\tif (chip->secondary_addr) {\n\t\t\twait_for_codec(chip, chip->secondary_addr,\n\t\t\t\t       AC97_VENDOR_ID1, msecs_to_jiffies(50));\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tint i;\n\t\t\tfor (i = 3; i > 0; i--) {\n\t\t\t\tif (!wait_for_codec(chip, i, AC97_VENDOR_ID1,\n\t\t\t\t\t\t     msecs_to_jiffies(50))) {\n\t\t\t\t\tcmdw = fm801_readw(chip, AC97_DATA);\n\t\t\t\t\tif (cmdw != 0xffff && cmdw != 0) {\n\t\t\t\t\t\tchip->secondary = 1;\n\t\t\t\t\t\tchip->secondary_addr = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t \n\t\twait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));\n\t}\n}\n\nstatic void snd_fm801_chip_init(struct fm801 *chip)\n{\n\tunsigned short cmdw;\n\n\t \n\tfm801_writew(chip, PCM_VOL, 0x0808);\n\tfm801_writew(chip, FM_VOL, 0x9f1f);\n\tfm801_writew(chip, I2S_VOL, 0x8808);\n\n\t \n\tfm801_writew(chip, I2S_MODE, 0x0003);\n\n\t \n\tcmdw = fm801_readw(chip, IRQ_MASK);\n\tif (chip->irq < 0)\n\t\tcmdw |= 0x00c3;\t\t \n\telse\n\t\tcmdw &= ~0x0083;\t \n\tfm801_writew(chip, IRQ_MASK, cmdw);\n\n\t \n\tfm801_writew(chip, IRQ_STATUS,\n\t\t     FM801_IRQ_PLAYBACK | FM801_IRQ_CAPTURE | FM801_IRQ_MPU);\n}\n\nstatic void snd_fm801_free(struct snd_card *card)\n{\n\tstruct fm801 *chip = card->private_data;\n\tunsigned short cmdw;\n\n\t \n\tcmdw = fm801_readw(chip, IRQ_MASK);\n\tcmdw |= 0x00c3;\n\tfm801_writew(chip, IRQ_MASK, cmdw);\n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n\tif (!(chip->tea575x_tuner & TUNER_DISABLED)) {\n\t\tsnd_tea575x_exit(&chip->tea);\n\t\tv4l2_device_unregister(&chip->v4l2_dev);\n\t}\n#endif\n}\n\nstatic int snd_fm801_create(struct snd_card *card,\n\t\t\t    struct pci_dev *pci,\n\t\t\t    int tea575x_tuner,\n\t\t\t    int radio_nr)\n{\n\tstruct fm801 *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tspin_lock_init(&chip->reg_lock);\n\tchip->card = card;\n\tchip->dev = &pci->dev;\n\tchip->irq = -1;\n\tchip->tea575x_tuner = tea575x_tuner;\n\terr = pci_request_regions(pci, \"FM801\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->port = pci_resource_start(pci, 0);\n\n\tif (pci->revision >= 0xb1)\t \n\t\tchip->multichannel = 1;\n\n\tif (!(chip->tea575x_tuner & TUNER_ONLY)) {\n\t\tif (reset_codec(chip) < 0) {\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"Primary AC'97 codec not found, assume SF64-PCR (tuner-only)\\n\");\n\t\t\tchip->tea575x_tuner = 3 | TUNER_ONLY;\n\t\t} else {\n\t\t\tsnd_fm801_chip_multichannel_init(chip);\n\t\t}\n\t}\n\n\tif ((chip->tea575x_tuner & TUNER_ONLY) == 0) {\n\t\tif (devm_request_irq(&pci->dev, pci->irq, snd_fm801_interrupt,\n\t\t\t\tIRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tchip->irq = pci->irq;\n\t\tcard->sync_irq = chip->irq;\n\t\tpci_set_master(pci);\n\t}\n\n\tcard->private_free = snd_fm801_free;\n\tsnd_fm801_chip_init(chip);\n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n\terr = v4l2_device_register(&pci->dev, &chip->v4l2_dev);\n\tif (err < 0)\n\t\treturn err;\n\tchip->tea.v4l2_dev = &chip->v4l2_dev;\n\tchip->tea.radio_nr = radio_nr;\n\tchip->tea.private_data = chip;\n\tchip->tea.ops = &snd_fm801_tea_ops;\n\tsprintf(chip->tea.bus_info, \"PCI:%s\", pci_name(pci));\n\tif ((chip->tea575x_tuner & TUNER_TYPE_MASK) > 0 &&\n\t    (chip->tea575x_tuner & TUNER_TYPE_MASK) < 4) {\n\t\tif (snd_tea575x_init(&chip->tea, THIS_MODULE)) {\n\t\t\tdev_err(card->dev, \"TEA575x radio not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if ((chip->tea575x_tuner & TUNER_TYPE_MASK) == 0) {\n\t\tunsigned int tuner_only = chip->tea575x_tuner & TUNER_ONLY;\n\n\t\t \n\t\tfor (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {\n\t\t\tchip->tea575x_tuner = tea575x_tuner;\n\t\t\tif (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {\n\t\t\t\tdev_info(card->dev,\n\t\t\t\t\t \"detected TEA575x radio type %s\\n\",\n\t\t\t\t\t   get_tea575x_gpio(chip)->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tea575x_tuner == 4) {\n\t\t\tdev_err(card->dev, \"TEA575x radio not found\\n\");\n\t\t\tchip->tea575x_tuner = TUNER_DISABLED;\n\t\t}\n\n\t\tchip->tea575x_tuner |= tuner_only;\n\t}\n\tif (!(chip->tea575x_tuner & TUNER_DISABLED)) {\n\t\tstrscpy(chip->tea.card, get_tea575x_gpio(chip)->name,\n\t\t\tsizeof(chip->tea.card));\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __snd_card_fm801_probe(struct pci_dev *pci,\n\t\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct fm801 *chip;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n        if (dev >= SNDRV_CARDS)\n                return -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\terr = snd_fm801_create(card, pci, tea575x_tuner[dev], radio_nr[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"FM801\");\n\tstrcpy(card->shortname, \"ForteMedia FM801-\");\n\tstrcat(card->shortname, chip->multichannel ? \"AU\" : \"AS\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %i\",\n\t\tcard->shortname, chip->port, chip->irq);\n\n\tif (chip->tea575x_tuner & TUNER_ONLY)\n\t\tgoto __fm801_tuner_only;\n\n\terr = snd_fm801_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_fm801_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,\n\t\t\t\t  chip->port + FM801_MPU401_DATA,\n\t\t\t\t  MPU401_INFO_INTEGRATED |\n\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t  -1, &chip->rmidi);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3_create(card, chip->port + FM801_OPL3_BANK0,\n\t\t\t      chip->port + FM801_OPL3_BANK1,\n\t\t\t      OPL3_HW_OPL3_FM801, 1, &opl3);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n      __fm801_tuner_only:\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_card_fm801_probe(struct pci_dev *pci,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_card_fm801_probe(pci, pci_id));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic const unsigned char saved_regs[] = {\n\tFM801_PCM_VOL, FM801_I2S_VOL, FM801_FM_VOL, FM801_REC_SRC,\n\tFM801_PLY_CTRL, FM801_PLY_COUNT, FM801_PLY_BUF1, FM801_PLY_BUF2,\n\tFM801_CAP_CTRL, FM801_CAP_COUNT, FM801_CAP_BUF1, FM801_CAP_BUF2,\n\tFM801_CODEC_CTRL, FM801_I2S_MODE, FM801_VOLUME, FM801_GEN_CTRL,\n};\n\nstatic int snd_fm801_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct fm801 *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tchip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);\n\n\tif (chip->tea575x_tuner & TUNER_ONLY) {\n\t\t \n\t} else {\n\t\tsnd_ac97_suspend(chip->ac97);\n\t\tsnd_ac97_suspend(chip->ac97_sec);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_fm801_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct fm801 *chip = card->private_data;\n\tint i;\n\n\tif (chip->tea575x_tuner & TUNER_ONLY) {\n\t\tsnd_fm801_chip_init(chip);\n\t} else {\n\t\treset_codec(chip);\n\t\tsnd_fm801_chip_multichannel_init(chip);\n\t\tsnd_fm801_chip_init(chip);\n\t\tsnd_ac97_resume(chip->ac97);\n\t\tsnd_ac97_resume(chip->ac97_sec);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tfm801_iowrite16(chip, saved_regs[i], chip->saved_regs[i]);\n\n#ifdef CONFIG_SND_FM801_TEA575X_BOOL\n\tif (!(chip->tea575x_tuner & TUNER_DISABLED))\n\t\tsnd_tea575x_set_freq(&chip->tea);\n#endif\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_fm801_pm, snd_fm801_suspend, snd_fm801_resume);\n#define SND_FM801_PM_OPS\t&snd_fm801_pm\n#else\n#define SND_FM801_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver fm801_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_fm801_ids,\n\t.probe = snd_card_fm801_probe,\n\t.driver = {\n\t\t.pm = SND_FM801_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(fm801_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}