{
  "module_name": "emuproc.c",
  "hash_id": "f999bb6cab29af631eb1e294810f1695c7ae4b81f2b49028649c7cd2b50bb249",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emuproc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n#include \"p16v.h\"\n\nstatic void snd_emu10k1_proc_spdif_status(struct snd_emu10k1 * emu,\n\t\t\t\t\t  struct snd_info_buffer *buffer,\n\t\t\t\t\t  char *title,\n\t\t\t\t\t  int status_reg,\n\t\t\t\t\t  int rate_reg)\n{\n\tstatic const char * const clkaccy[4] = { \"1000ppm\", \"50ppm\", \"variable\", \"unknown\" };\n\tstatic const int samplerate[16] = { 44100, 1, 48000, 32000, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n\tstatic const char * const channel[16] = { \"unspec\", \"left\", \"right\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\" };\n\tstatic const char * const emphasis[8] = { \"none\", \"50/15 usec 2 channel\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\" };\n\tunsigned int status, rate = 0;\n\t\n\tstatus = snd_emu10k1_ptr_read(emu, status_reg, 0);\n\n\tsnd_iprintf(buffer, \"\\n%s\\n\", title);\n\n\tif (status != 0xffffffff) {\n\t\tsnd_iprintf(buffer, \"Professional Mode     : %s\\n\", (status & SPCS_PROFESSIONAL) ? \"yes\" : \"no\");\n\t\tsnd_iprintf(buffer, \"Not Audio Data        : %s\\n\", (status & SPCS_NOTAUDIODATA) ? \"yes\" : \"no\");\n\t\tsnd_iprintf(buffer, \"Copyright             : %s\\n\", (status & SPCS_COPYRIGHT) ? \"yes\" : \"no\");\n\t\tsnd_iprintf(buffer, \"Emphasis              : %s\\n\", emphasis[(status & SPCS_EMPHASISMASK) >> 3]);\n\t\tsnd_iprintf(buffer, \"Mode                  : %i\\n\", (status & SPCS_MODEMASK) >> 6);\n\t\tsnd_iprintf(buffer, \"Category Code         : 0x%x\\n\", (status & SPCS_CATEGORYCODEMASK) >> 8);\n\t\tsnd_iprintf(buffer, \"Generation Status     : %s\\n\", status & SPCS_GENERATIONSTATUS ? \"original\" : \"copy\");\n\t\tsnd_iprintf(buffer, \"Source Mask           : %i\\n\", (status & SPCS_SOURCENUMMASK) >> 16);\n\t\tsnd_iprintf(buffer, \"Channel Number        : %s\\n\", channel[(status & SPCS_CHANNELNUMMASK) >> 20]);\n\t\tsnd_iprintf(buffer, \"Sample Rate           : %iHz\\n\", samplerate[(status & SPCS_SAMPLERATEMASK) >> 24]);\n\t\tsnd_iprintf(buffer, \"Clock Accuracy        : %s\\n\", clkaccy[(status & SPCS_CLKACCYMASK) >> 28]);\n\n\t\tif (rate_reg > 0) {\n\t\t\trate = snd_emu10k1_ptr_read(emu, rate_reg, 0);\n\t\t\tsnd_iprintf(buffer, \"S/PDIF Valid          : %s\\n\", rate & SRCS_SPDIFVALID ? \"on\" : \"off\");\n\t\t\tsnd_iprintf(buffer, \"S/PDIF Locked         : %s\\n\", rate & SRCS_SPDIFLOCKED ? \"on\" : \"off\");\n\t\t\tsnd_iprintf(buffer, \"Rate Locked           : %s\\n\", rate & SRCS_RATELOCKED ? \"on\" : \"off\");\n\t\t\t \n\t\t\tsnd_iprintf(buffer, \"Estimated Sample Rate : %d\\n\", ((rate & 0xFFFFF ) * 375) >> 11); \n\t\t}\n\t} else {\n\t\tsnd_iprintf(buffer, \"No signal detected.\\n\");\n\t}\n\n}\n\nstatic void snd_emu10k1_proc_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tconst char * const *inputs = emu->audigy ?\n\t\tsnd_emu10k1_audigy_ins : snd_emu10k1_sblive_ins;\n\tconst char * const *outputs = emu->audigy ?\n\t\tsnd_emu10k1_audigy_outs : snd_emu10k1_sblive_outs;\n\tunsigned short extin_mask = emu->audigy ? ~0 : emu->fx8010.extin_mask;\n\tunsigned short extout_mask = emu->audigy ? ~0 : emu->fx8010.extout_mask;\n\tunsigned int val, val1, ptrx, psst, dsl, snda;\n\tint nefx = emu->audigy ? 32 : 16;\n\tint idx;\n\t\n\tsnd_iprintf(buffer, \"EMU10K1\\n\\n\");\n\tsnd_iprintf(buffer, \"Card                  : %s\\n\",\n\t\t    emu->card_capabilities->emu_model ? \"E-MU D.A.S.\" :\n\t\t    emu->card_capabilities->ecard ? \"E-MU A.P.S.\" :\n\t\t    emu->audigy ? \"SB Audigy\" : \"SB Live!\");\n\tsnd_iprintf(buffer, \"Internal TRAM (words) : 0x%x\\n\", emu->fx8010.itram_size);\n\tsnd_iprintf(buffer, \"External TRAM (words) : 0x%x\\n\", (int)emu->fx8010.etram_pages.bytes / 2);\n\n\tsnd_iprintf(buffer, \"\\nEffect Send Routing & Amounts:\\n\");\n\tfor (idx = 0; idx < NUM_G; idx++) {\n\t\tptrx = snd_emu10k1_ptr_read(emu, PTRX, idx);\n\t\tpsst = snd_emu10k1_ptr_read(emu, PSST, idx);\n\t\tdsl = snd_emu10k1_ptr_read(emu, DSL, idx);\n\t\tif (emu->audigy) {\n\t\t\tval = snd_emu10k1_ptr_read(emu, A_FXRT1, idx);\n\t\t\tval1 = snd_emu10k1_ptr_read(emu, A_FXRT2, idx);\n\t\t\tsnda = snd_emu10k1_ptr_read(emu, A_SENDAMOUNTS, idx);\n\t\t\tsnd_iprintf(buffer, \"Ch%-2i: A=%2i:%02x, B=%2i:%02x, C=%2i:%02x, D=%2i:%02x, \",\n\t\t\t\tidx,\n\t\t\t\tval & 0x3f, REG_VAL_GET(PTRX_FXSENDAMOUNT_A, ptrx),\n\t\t\t\t(val >> 8) & 0x3f, REG_VAL_GET(PTRX_FXSENDAMOUNT_B, ptrx),\n\t\t\t\t(val >> 16) & 0x3f, REG_VAL_GET(PSST_FXSENDAMOUNT_C, psst),\n\t\t\t\t(val >> 24) & 0x3f, REG_VAL_GET(DSL_FXSENDAMOUNT_D, dsl));\n\t\t\tsnd_iprintf(buffer, \"E=%2i:%02x, F=%2i:%02x, G=%2i:%02x, H=%2i:%02x\\n\",\n\t\t\t\tval1 & 0x3f, (snda >> 24) & 0xff,\n\t\t\t\t(val1 >> 8) & 0x3f, (snda >> 16) & 0xff,\n\t\t\t\t(val1 >> 16) & 0x3f, (snda >> 8) & 0xff,\n\t\t\t\t(val1 >> 24) & 0x3f, snda & 0xff);\n\t\t} else {\n\t\t\tval = snd_emu10k1_ptr_read(emu, FXRT, idx);\n\t\t\tsnd_iprintf(buffer, \"Ch%-2i: A=%2i:%02x, B=%2i:%02x, C=%2i:%02x, D=%2i:%02x\\n\",\n\t\t\t\tidx,\n\t\t\t\t(val >> 16) & 0x0f, REG_VAL_GET(PTRX_FXSENDAMOUNT_A, ptrx),\n\t\t\t\t(val >> 20) & 0x0f, REG_VAL_GET(PTRX_FXSENDAMOUNT_B, ptrx),\n\t\t\t\t(val >> 24) & 0x0f, REG_VAL_GET(PSST_FXSENDAMOUNT_C, psst),\n\t\t\t\t(val >> 28) & 0x0f, REG_VAL_GET(DSL_FXSENDAMOUNT_D, dsl));\n\t\t}\n\t}\n\tsnd_iprintf(buffer, \"\\nEffect Send Targets:\\n\");\n\t\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tconst char *c = snd_emu10k1_fxbus[idx];\n\t\tif (c)\n\t\t\tsnd_iprintf(buffer, \"  Channel %02i [%s]\\n\", idx, c);\n\t}\n\tif (!emu->card_capabilities->emu_model) {\n\t\tsnd_iprintf(buffer, \"\\nOutput Channels:\\n\");\n\t\tfor (idx = 0; idx < 32; idx++)\n\t\t\tif (outputs[idx] && (extout_mask & (1 << idx)))\n\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [%s]\\n\", idx, outputs[idx]);\n\t\tsnd_iprintf(buffer, \"\\nInput Channels:\\n\");\n\t\tfor (idx = 0; idx < 16; idx++)\n\t\t\tif (inputs[idx] && (extin_mask & (1 << idx)))\n\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [%s]\\n\", idx, inputs[idx]);\n\t\tsnd_iprintf(buffer, \"\\nMultichannel Capture Sources:\\n\");\n\t\tfor (idx = 0; idx < nefx; idx++)\n\t\t\tif (emu->efx_voices_mask[0] & (1 << idx))\n\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [Output: %s]\\n\",\n\t\t\t\t\t    idx, outputs[idx] ? outputs[idx] : \"???\");\n\t\tif (emu->audigy) {\n\t\t\tfor (idx = 0; idx < 32; idx++)\n\t\t\t\tif (emu->efx_voices_mask[1] & (1 << idx))\n\t\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [Input: %s]\\n\",\n\t\t\t\t\t\t    idx + 32, inputs[idx] ? inputs[idx] : \"???\");\n\t\t} else {\n\t\t\tfor (idx = 0; idx < 16; idx++) {\n\t\t\t\tif (emu->efx_voices_mask[0] & ((1 << 16) << idx)) {\n\t\t\t\t\tif (emu->card_capabilities->sblive51) {\n\t\t\t\t\t\ts8 c = snd_emu10k1_sblive51_fxbus2_map[idx];\n\t\t\t\t\t\tif (c == -1)\n\t\t\t\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [Output: %s]\\n\",\n\t\t\t\t\t\t\t\t    idx + 16, outputs[idx + 16]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [Input: %s]\\n\",\n\t\t\t\t\t\t\t\t    idx + 16, inputs[c]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnd_iprintf(buffer, \"  Channel %02i [Input: %s]\\n\",\n\t\t\t\t\t\t\t    idx + 16, inputs[idx] ? inputs[idx] : \"???\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tu32 value;\n\tu32 value2;\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t\n\t\t\n\t\t\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_IRQ_STATUS, &value);\n\t\tsnd_iprintf(buffer, \"Lock status 1: %#x\\n\", value & 0x10);\n\n\t\t\n\t\t\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_LOCK_STS_LO, &value);\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_LOCK_STS_HI, &value2);\n\t\tsnd_iprintf(buffer, \"Lock status 2: %#x %#x\\n\", value, value2);\n\n\t\tsnd_iprintf(buffer, \"S/PDIF rate: %dHz\\n\",\n\t\t\t    snd_emu1010_get_raw_rate(emu, EMU_HANA_WCLOCK_HANA_SPDIF_IN));\n\t\tif (emu->card_capabilities->emu_model != EMU_MODEL_EMU0404) {\n\t\t\tsnd_iprintf(buffer, \"ADAT rate: %dHz\\n\",\n\t\t\t\t    snd_emu1010_get_raw_rate(emu, EMU_HANA_WCLOCK_HANA_ADAT_IN));\n\t\t\tsnd_iprintf(buffer, \"Dock rate: %dHz\\n\",\n\t\t\t\t    snd_emu1010_get_raw_rate(emu, EMU_HANA_WCLOCK_2ND_HANA));\n\t\t}\n\t\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU0404 ||\n\t\t    emu->card_capabilities->emu_model == EMU_MODEL_EMU1010)\n\t\t\tsnd_iprintf(buffer, \"BNC rate: %dHz\\n\",\n\t\t\t\t    snd_emu1010_get_raw_rate(emu, EMU_HANA_WCLOCK_SYNC_BNC));\n\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_SPDIF_MODE, &value);\n\t\tif (value & EMU_HANA_SPDIF_MODE_RX_INVALID)\n\t\t\tsnd_iprintf(buffer, \"\\nS/PDIF input invalid\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"\\nS/PDIF mode: %s%s\\n\",\n\t\t\t\t    value & EMU_HANA_SPDIF_MODE_RX_PRO ? \"professional\" : \"consumer\",\n\t\t\t\t    value & EMU_HANA_SPDIF_MODE_RX_NOCOPY ? \", no copy\" : \"\");\n\t} else {\n\t\tsnd_emu10k1_proc_spdif_status(emu, buffer, \"CD-ROM S/PDIF In\", CDCS, CDSRCS);\n\t\tsnd_emu10k1_proc_spdif_status(emu, buffer, \"Optical or Coax S/PDIF In\", GPSCS, GPSRCS);\n\t}\n#if 0\n\tval = snd_emu10k1_ptr_read(emu, ZVSRCS, 0);\n\tsnd_iprintf(buffer, \"\\nZoomed Video\\n\");\n\tsnd_iprintf(buffer, \"Rate Locked           : %s\\n\", val & SRCS_RATELOCKED ? \"on\" : \"off\");\n\tsnd_iprintf(buffer, \"Estimated Sample Rate : 0x%x\\n\", val & SRCS_ESTSAMPLERATE);\n#endif\n}\n\nstatic void snd_emu10k1_proc_rates_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstatic const int samplerate[8] = { 44100, 48000, 96000, 192000, 4, 5, 6, 7 };\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tunsigned int val, tmp, n;\n\tval = snd_emu10k1_ptr20_read(emu, CAPTURE_RATE_STATUS, 0);\n\tfor (n = 0; n < 4; n++) {\n\t\ttmp = val >> (16 + (n*4));\n\t\tif (tmp & 0x8) snd_iprintf(buffer, \"Channel %d: Rate=%d\\n\", n, samplerate[tmp & 0x7]);\n\t\telse snd_iprintf(buffer, \"Channel %d: No input\\n\", n);\n\t}\n}\n\nstruct emu10k1_reg_entry {\n\tunsigned short base, size;\n\tconst char *name;\n};\n\nstatic const struct emu10k1_reg_entry sblive_reg_entries[] = {\n\t{    0, 0x10, \"FXBUS\" },\n\t{ 0x10, 0x10, \"EXTIN\" },\n\t{ 0x20, 0x10, \"EXTOUT\" },\n\t{ 0x30, 0x10, \"FXBUS2\" },\n\t{ 0x40, 0x20, NULL },  \n\t{ 0x100, 0x100, \"GPR\" },\n\t{ 0x200, 0x80, \"ITRAM_DATA\" },\n\t{ 0x280, 0x20, \"ETRAM_DATA\" },\n\t{ 0x300, 0x80, \"ITRAM_ADDR\" },\n\t{ 0x380, 0x20, \"ETRAM_ADDR\" },\n\t{ 0x400, 0, NULL }\n};\n\nstatic const struct emu10k1_reg_entry audigy_reg_entries[] = {\n\t{    0, 0x40, \"FXBUS\" },\n\t{ 0x40, 0x10, \"EXTIN\" },\n\t{ 0x50, 0x10, \"P16VIN\" },\n\t{ 0x60, 0x20, \"EXTOUT\" },\n\t{ 0x80, 0x20, \"FXBUS2\" },\n\t{ 0xa0, 0x10, \"EMU32OUTH\" },\n\t{ 0xb0, 0x10, \"EMU32OUTL\" },\n\t{ 0xc0, 0x20, NULL },  \n\t\n\t\n\t\n\t{ 0x160, 0x20, \"A3_EMU32IN\" },\n\t{ 0x1e0, 0x20, \"A3_EMU32OUT\" },\n\t{ 0x200, 0xc0, \"ITRAM_DATA\" },\n\t{ 0x2c0, 0x40, \"ETRAM_DATA\" },\n\t{ 0x300, 0xc0, \"ITRAM_ADDR\" },\n\t{ 0x3c0, 0x40, \"ETRAM_ADDR\" },\n\t{ 0x400, 0x200, \"GPR\" },\n\t{ 0x600, 0, NULL }\n};\n\nstatic const char * const emu10k1_const_entries[] = {\n\t\"C_00000000\",\n\t\"C_00000001\",\n\t\"C_00000002\",\n\t\"C_00000003\",\n\t\"C_00000004\",\n\t\"C_00000008\",\n\t\"C_00000010\",\n\t\"C_00000020\",\n\t\"C_00000100\",\n\t\"C_00010000\",\n\t\"C_00000800\",\n\t\"C_10000000\",\n\t\"C_20000000\",\n\t\"C_40000000\",\n\t\"C_80000000\",\n\t\"C_7fffffff\",\n\t\"C_ffffffff\",\n\t\"C_fffffffe\",\n\t\"C_c0000000\",\n\t\"C_4f1bbcdc\",\n\t\"C_5a7ef9db\",\n\t\"C_00100000\",\n\t\"GPR_ACCU\",\n\t\"GPR_COND\",\n\t\"GPR_NOISE0\",\n\t\"GPR_NOISE1\",\n\t\"GPR_IRQ\",\n\t\"GPR_DBAC\",\n\t\"GPR_DBACE\",\n\t\"???\",\n};\n\nstatic int disasm_emu10k1_reg(char *buffer,\n\t\t\t      const struct emu10k1_reg_entry *entries,\n\t\t\t      unsigned reg, const char *pfx)\n{\n\tfor (int i = 0; ; i++) {\n\t\tunsigned base = entries[i].base;\n\t\tunsigned size = entries[i].size;\n\t\tif (!size)\n\t\t\treturn sprintf(buffer, \"%s0x%03x\", pfx, reg);\n\t\tif (reg >= base && reg < base + size) {\n\t\t\tconst char *name = entries[i].name;\n\t\t\treg -= base;\n\t\t\tif (name)\n\t\t\t\treturn sprintf(buffer, \"%s%s(%u)\", pfx, name, reg);\n\t\t\treturn sprintf(buffer, \"%s%s\", pfx, emu10k1_const_entries[reg]);\n\t\t}\n\t}\n}\n\nstatic int disasm_sblive_reg(char *buffer, unsigned reg, const char *pfx)\n{\n\treturn disasm_emu10k1_reg(buffer, sblive_reg_entries, reg, pfx);\n}\n\nstatic int disasm_audigy_reg(char *buffer, unsigned reg, const char *pfx)\n{\n\treturn disasm_emu10k1_reg(buffer, audigy_reg_entries, reg, pfx);\n}\n\nstatic void snd_emu10k1_proc_acode_read(struct snd_info_entry *entry,\n\t\t\t\t        struct snd_info_buffer *buffer)\n{\n\tu32 pc;\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tstatic const char * const insns[16] = {\n\t\t\"MAC0\", \"MAC1\", \"MAC2\", \"MAC3\", \"MACINT0\", \"MACINT1\", \"ACC3\", \"MACMV\",\n\t\t\"ANDXOR\", \"TSTNEG\", \"LIMITGE\", \"LIMITLT\", \"LOG\", \"EXP\", \"INTERP\", \"SKIP\",\n\t};\n\tstatic const char spaces[] = \"                              \";\n\tconst int nspaces = sizeof(spaces) - 1;\n\n\tsnd_iprintf(buffer, \"FX8010 Instruction List '%s'\\n\", emu->fx8010.name);\n\tsnd_iprintf(buffer, \"  Code dump      :\\n\");\n\tfor (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {\n\t\tu32 low, high;\n\t\tint len;\n\t\tchar buf[100];\n\t\tchar *bufp = buf;\n\t\t\t\n\t\tlow = snd_emu10k1_efx_read(emu, pc * 2);\n\t\thigh = snd_emu10k1_efx_read(emu, pc * 2 + 1);\n\t\tif (emu->audigy) {\n\t\t\tbufp += sprintf(bufp, \"    %-7s  \", insns[(high >> 24) & 0x0f]);\n\t\t\tbufp += disasm_audigy_reg(bufp, (high >> 12) & 0x7ff, \"\");\n\t\t\tbufp += disasm_audigy_reg(bufp, (high >> 0) & 0x7ff, \", \");\n\t\t\tbufp += disasm_audigy_reg(bufp, (low >> 12) & 0x7ff, \", \");\n\t\t\tbufp += disasm_audigy_reg(bufp, (low >> 0) & 0x7ff, \", \");\n\t\t} else {\n\t\t\tbufp += sprintf(bufp, \"    %-7s  \", insns[(high >> 20) & 0x0f]);\n\t\t\tbufp += disasm_sblive_reg(bufp, (high >> 10) & 0x3ff, \"\");\n\t\t\tbufp += disasm_sblive_reg(bufp, (high >> 0) & 0x3ff, \", \");\n\t\t\tbufp += disasm_sblive_reg(bufp, (low >> 10) & 0x3ff, \", \");\n\t\t\tbufp += disasm_sblive_reg(bufp, (low >> 0) & 0x3ff, \", \");\n\t\t}\n\t\tlen = (int)(ptrdiff_t)(bufp - buf);\n\t\tsnd_iprintf(buffer, \"%s %s /* 0x%04x: 0x%08x%08x */\\n\",\n\t\t\t    buf, &spaces[nspaces - clamp(65 - len, 0, nspaces)],\n\t\t\t    pc, high, low);\n\t}\n}\n\n#define TOTAL_SIZE_GPR\t\t(0x100*4)\n#define A_TOTAL_SIZE_GPR\t(0x200*4)\n#define TOTAL_SIZE_TANKMEM_DATA\t(0xa0*4)\n#define TOTAL_SIZE_TANKMEM_ADDR (0xa0*4)\n#define A_TOTAL_SIZE_TANKMEM_DATA (0x100*4)\n#define A_TOTAL_SIZE_TANKMEM_ADDR (0x100*4)\n#define TOTAL_SIZE_CODE\t\t(0x200*8)\n#define A_TOTAL_SIZE_CODE\t(0x400*8)\n\nstatic ssize_t snd_emu10k1_fx8010_read(struct snd_info_entry *entry,\n\t\t\t\t       void *file_private_data,\n\t\t\t\t       struct file *file, char __user *buf,\n\t\t\t\t       size_t count, loff_t pos)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tunsigned int offset;\n\tint tram_addr = 0;\n\tunsigned int *tmp;\n\tlong res;\n\tunsigned int idx;\n\t\n\tif (!strcmp(entry->name, \"fx8010_tram_addr\")) {\n\t\toffset = TANKMEMADDRREGBASE;\n\t\ttram_addr = 1;\n\t} else if (!strcmp(entry->name, \"fx8010_tram_data\")) {\n\t\toffset = TANKMEMDATAREGBASE;\n\t} else if (!strcmp(entry->name, \"fx8010_code\")) {\n\t\toffset = emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\n\t} else {\n\t\toffset = emu->audigy ? A_FXGPREGBASE : FXGPREGBASE;\n\t}\n\n\ttmp = kmalloc(count + 8, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\tfor (idx = 0; idx < ((pos & 3) + count + 3) >> 2; idx++) {\n\t\tunsigned int val;\n\t\tval = snd_emu10k1_ptr_read(emu, offset + idx + (pos >> 2), 0);\n\t\tif (tram_addr && emu->audigy) {\n\t\t\tval >>= 11;\n\t\t\tval |= snd_emu10k1_ptr_read(emu, 0x100 + idx + (pos >> 2), 0) << 20;\n\t\t}\n\t\ttmp[idx] = val;\n\t}\n\tif (copy_to_user(buf, ((char *)tmp) + (pos & 3), count))\n\t\tres = -EFAULT;\n\telse\n\t\tres = count;\n\tkfree(tmp);\n\treturn res;\n}\n\nstatic void snd_emu10k1_proc_voices_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tstruct snd_emu10k1_voice *voice;\n\tint idx;\n\tstatic const char * const types[] = {\n\t\t\"Unused\", \"EFX\", \"EFX IRQ\", \"PCM\", \"PCM IRQ\", \"Synth\"\n\t};\n\tstatic_assert(ARRAY_SIZE(types) == EMU10K1_NUM_TYPES);\n\n\tsnd_iprintf(buffer, \"ch\\tdirty\\tlast\\tuse\\n\");\n\tfor (idx = 0; idx < NUM_G; idx++) {\n\t\tvoice = &emu->voices[idx];\n\t\tsnd_iprintf(buffer, \"%i\\t%u\\t%u\\t%s\\n\",\n\t\t\tidx,\n\t\t\tvoice->dirty,\n\t\t\tvoice->last,\n\t\t\ttypes[voice->use]);\n\t}\n}\n\n#ifdef CONFIG_SND_DEBUG\n\nstatic void snd_emu_proc_emu1010_link_read(struct snd_emu10k1 *emu,\n\t\t\t\t\t   struct snd_info_buffer *buffer,\n\t\t\t\t\t   u32 dst)\n{\n\tu32 src = snd_emu1010_fpga_link_dst_src_read(emu, dst);\n\tsnd_iprintf(buffer, \"%04x: %04x\\n\", dst, src);\n}\n\nstatic void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tu32 value;\n\tint i;\n\tsnd_iprintf(buffer, \"EMU1010 Registers:\\n\\n\");\n\n\tfor(i = 0; i < 0x40; i+=1) {\n\t\tsnd_emu1010_fpga_read(emu, i, &value);\n\t\tsnd_iprintf(buffer, \"%02x: %02x\\n\", i, value);\n\t}\n\n\tsnd_iprintf(buffer, \"\\nEMU1010 Routes:\\n\\n\");\n\n\tfor (i = 0; i < 16; i++)  \n\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, i);\n\tif (emu->card_capabilities->emu_model != EMU_MODEL_EMU0404)\n\t\tfor (i = 0; i < 32; i++)  \n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x100 + i);\n\tif (emu->card_capabilities->emu_model != EMU_MODEL_EMU1616)\n\t\tfor (i = 0; i < 8; i++)  \n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x200 + i);\n\tfor (i = 0; i < 8; i++)  \n\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x300 + i);\n\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1616) {\n\t\tfor (i = 0; i < 16; i++)  \n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x400 + i);\n\t} else if (emu->card_capabilities->emu_model != EMU_MODEL_EMU0404) {\n\t\tfor (i = 0; i < 8; i++)  \n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x400 + i);\n\t\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1010B) {\n\t\t\tfor (i = 0; i < 16; i++)  \n\t\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x500 + i);\n\t\t} else {\n\t\t\t\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x500);\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x501);\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x600);\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x601);\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x700);\n\t\t\tsnd_emu_proc_emu1010_link_read(emu, buffer, 0x701);\n\t\t}\n\t}\n}\n\nstatic void snd_emu_proc_io_reg_read(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tunsigned long value;\n\tint i;\n\tsnd_iprintf(buffer, \"IO Registers:\\n\\n\");\n\tfor(i = 0; i < 0x40; i+=4) {\n\t\tvalue = inl(emu->port + i);\n\t\tsnd_iprintf(buffer, \"%02X: %08lX\\n\", i, value);\n\t}\n}\n\nstatic void snd_emu_proc_io_reg_write(struct snd_info_entry *entry,\n                                      struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tchar line[64];\n\tu32 reg, val;\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%x %x\", &reg, &val) != 2)\n\t\t\tcontinue;\n\t\tif (reg < 0x40 && val <= 0xffffffff) {\n\t\t\toutl(val, emu->port + (reg & 0xfffffffc));\n\t\t}\n\t}\n}\n\nstatic unsigned int snd_ptr_read(struct snd_emu10k1 * emu,\n\t\t\t\t unsigned int iobase,\n\t\t\t\t unsigned int reg,\n\t\t\t\t unsigned int chn)\n{\n\tunsigned int regptr, val;\n\n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irq(&emu->emu_lock);\n\toutl(regptr, emu->port + iobase + PTR);\n\tval = inl(emu->port + iobase + DATA);\n\tspin_unlock_irq(&emu->emu_lock);\n\treturn val;\n}\n\nstatic void snd_ptr_write(struct snd_emu10k1 *emu,\n\t\t\t  unsigned int iobase,\n\t\t\t  unsigned int reg,\n\t\t\t  unsigned int chn,\n\t\t\t  unsigned int data)\n{\n\tunsigned int regptr;\n\n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irq(&emu->emu_lock);\n\toutl(regptr, emu->port + iobase + PTR);\n\toutl(data, emu->port + iobase + DATA);\n\tspin_unlock_irq(&emu->emu_lock);\n}\n\n\nstatic void snd_emu_proc_ptr_reg_read(struct snd_info_entry *entry,\n\t\t\t\t      struct snd_info_buffer *buffer, int iobase, int offset, int length, int voices)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tunsigned long value;\n\tint i,j;\n\tif (offset+length > 0xa0) {\n\t\tsnd_iprintf(buffer, \"Input values out of range\\n\");\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, \"Registers 0x%x\\n\", iobase);\n\tfor(i = offset; i < offset+length; i++) {\n\t\tsnd_iprintf(buffer, \"%02X: \",i);\n\t\tfor (j = 0; j < voices; j++) {\n\t\t\tvalue = snd_ptr_read(emu, iobase, i, j);\n\t\t\tsnd_iprintf(buffer, \"%08lX \", value);\n\t\t}\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n}\n\nstatic void snd_emu_proc_ptr_reg_write(struct snd_info_entry *entry,\n\t\t\t\t       struct snd_info_buffer *buffer,\n\t\t\t\t       int iobase, int length, int voices)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tchar line[64];\n\tunsigned int reg, channel_id , val;\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%x %x %x\", &reg, &channel_id, &val) != 3)\n\t\t\tcontinue;\n\t\tif (reg < length && channel_id < voices)\n\t\t\tsnd_ptr_write(emu, iobase, reg, channel_id, val);\n\t}\n}\n\nstatic void snd_emu_proc_ptr_reg_write00(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tsnd_emu_proc_ptr_reg_write(entry, buffer, 0, 0x80, 64);\n}\n\nstatic void snd_emu_proc_ptr_reg_write20(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_emu10k1 *emu = entry->private_data;\n\tsnd_emu_proc_ptr_reg_write(entry, buffer, 0x20,\n\t\t\t\t   emu->card_capabilities->ca0108_chip ? 0xa0 : 0x80, 4);\n}\n\t\n\nstatic void snd_emu_proc_ptr_reg_read00a(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tsnd_emu_proc_ptr_reg_read(entry, buffer, 0, 0, 0x40, 64);\n}\n\nstatic void snd_emu_proc_ptr_reg_read00b(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tsnd_emu_proc_ptr_reg_read(entry, buffer, 0, 0x40, 0x40, 64);\n}\n\nstatic void snd_emu_proc_ptr_reg_read20a(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0, 0x40, 4);\n}\n\nstatic void snd_emu_proc_ptr_reg_read20b(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x40, 0x40, 4);\n}\n\nstatic void snd_emu_proc_ptr_reg_read20c(struct snd_info_entry *entry,\n\t\t\t\t\t struct snd_info_buffer * buffer)\n{\n\tsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x80, 0x20, 4);\n}\n#endif\n\nstatic const struct snd_info_entry_ops snd_emu10k1_proc_ops_fx8010 = {\n\t.read = snd_emu10k1_fx8010_read,\n};\n\nint snd_emu10k1_proc_init(struct snd_emu10k1 *emu)\n{\n\tstruct snd_info_entry *entry;\n#ifdef CONFIG_SND_DEBUG\n\tif (emu->card_capabilities->emu_model) {\n\t\tsnd_card_ro_proc_new(emu->card, \"emu1010_regs\",\n\t\t\t\t     emu, snd_emu_proc_emu1010_reg_read);\n\t}\n\tsnd_card_rw_proc_new(emu->card, \"io_regs\", emu,\n\t\t\t     snd_emu_proc_io_reg_read,\n\t\t\t     snd_emu_proc_io_reg_write);\n\tsnd_card_rw_proc_new(emu->card, \"ptr_regs00a\", emu,\n\t\t\t     snd_emu_proc_ptr_reg_read00a,\n\t\t\t     snd_emu_proc_ptr_reg_write00);\n\tsnd_card_rw_proc_new(emu->card, \"ptr_regs00b\", emu,\n\t\t\t     snd_emu_proc_ptr_reg_read00b,\n\t\t\t     snd_emu_proc_ptr_reg_write00);\n\tif (!emu->card_capabilities->emu_model &&\n\t    (emu->card_capabilities->ca0151_chip || emu->card_capabilities->ca0108_chip)) {\n\t\tsnd_card_rw_proc_new(emu->card, \"ptr_regs20a\", emu,\n\t\t\t\t     snd_emu_proc_ptr_reg_read20a,\n\t\t\t\t     snd_emu_proc_ptr_reg_write20);\n\t\tsnd_card_rw_proc_new(emu->card, \"ptr_regs20b\", emu,\n\t\t\t\t     snd_emu_proc_ptr_reg_read20b,\n\t\t\t\t     snd_emu_proc_ptr_reg_write20);\n\t\tif (emu->card_capabilities->ca0108_chip)\n\t\t\tsnd_card_rw_proc_new(emu->card, \"ptr_regs20c\", emu,\n\t\t\t\t\t     snd_emu_proc_ptr_reg_read20c,\n\t\t\t\t\t     snd_emu_proc_ptr_reg_write20);\n\t}\n#endif\n\t\n\tsnd_card_ro_proc_new(emu->card, \"emu10k1\", emu, snd_emu10k1_proc_read);\n\n\tif (emu->card_capabilities->emu10k2_chip)\n\t\tsnd_card_ro_proc_new(emu->card, \"spdif-in\", emu,\n\t\t\t\t     snd_emu10k1_proc_spdif_read);\n\tif (emu->card_capabilities->ca0151_chip)\n\t\tsnd_card_ro_proc_new(emu->card, \"capture-rates\", emu,\n\t\t\t\t     snd_emu10k1_proc_rates_read);\n\n\tsnd_card_ro_proc_new(emu->card, \"voices\", emu,\n\t\t\t     snd_emu10k1_proc_voices_read);\n\n\tif (! snd_card_proc_new(emu->card, \"fx8010_gpr\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = emu;\n\t\tentry->mode = S_IFREG | 0444  ;\n\t\tentry->size = emu->audigy ? A_TOTAL_SIZE_GPR : TOTAL_SIZE_GPR;\n\t\tentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\n\t}\n\tif (! snd_card_proc_new(emu->card, \"fx8010_tram_data\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = emu;\n\t\tentry->mode = S_IFREG | 0444  ;\n\t\tentry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_DATA : TOTAL_SIZE_TANKMEM_DATA ;\n\t\tentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\n\t}\n\tif (! snd_card_proc_new(emu->card, \"fx8010_tram_addr\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = emu;\n\t\tentry->mode = S_IFREG | 0444  ;\n\t\tentry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_ADDR : TOTAL_SIZE_TANKMEM_ADDR ;\n\t\tentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\n\t}\n\tif (! snd_card_proc_new(emu->card, \"fx8010_code\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = emu;\n\t\tentry->mode = S_IFREG | 0444  ;\n\t\tentry->size = emu->audigy ? A_TOTAL_SIZE_CODE : TOTAL_SIZE_CODE;\n\t\tentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\n\t}\n\tsnd_card_ro_proc_new(emu->card, \"fx8010_acode\", emu,\n\t\t\t     snd_emu10k1_proc_acode_read);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}