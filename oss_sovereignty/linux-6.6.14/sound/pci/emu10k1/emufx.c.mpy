{
  "module_name": "emufx.c",
  "hash_id": "11f3c6bd5cd559caa82d189194ef56bc8fcb2f971cf4b467d37e81e78859313c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emufx.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/capability.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/moduleparam.h>\n#include <linux/nospec.h>\n\n#include <sound/core.h>\n#include <sound/tlv.h>\n#include <sound/emu10k1.h>\n\n#if 0\t\t \n#define EMU10K1_CAPTURE_DIGITAL_OUT\n#endif\n#if 0\t\t \n#define EMU10K1_SET_AC3_IEC958\n#endif\n#if 0\t\t \n#define EMU10K1_CENTER_LFE_FROM_FRONT\n#endif\n\nstatic bool high_res_gpr_volume;\nmodule_param(high_res_gpr_volume, bool, 0444);\nMODULE_PARM_DESC(high_res_gpr_volume, \"GPR mixer controls use 31-bit range.\");\n\n  \n\n\n\nconst char * const snd_emu10k1_fxbus[32] = {\n\t  \"PCM Left\",\n\t  \"PCM Right\",\n\t  \"PCM Rear Left\",\n\t  \"PCM Rear Right\",\n\t  \"MIDI Left\",\n\t  \"MIDI Right\",\n\t  \"PCM Center\",\n\t  \"PCM LFE\",\n\t  \"PCM Front Left\",\n\t  \"PCM Front Right\",\n\t  NULL,\n\t  NULL,\n\t  \"MIDI Reverb\",\n\t  \"MIDI Chorus\",\n\t  \"PCM Side Left\",\n\t  \"PCM Side Right\",\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  \"Passthrough Left\",\n\t  \"Passthrough Right\",\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL\n};\n\n\nconst char * const snd_emu10k1_sblive_ins[16] = {\n\t  \"AC97 Left\",\n\t  \"AC97 Right\",\n\t  \"TTL IEC958 Left\",\n\t  \"TTL IEC958 Right\",\n\t  \"Zoom Video Left\",\n\t  \"Zoom Video Right\",\n\t  \"Optical IEC958 Left\",\n\t  \"Optical IEC958 Right\",\n\t  \"Line/Mic 1 Left\",\n\t  \"Line/Mic 1 Right\",\n\t  \"Coaxial IEC958 Left\",\n\t  \"Coaxial IEC958 Right\",\n\t  \"Line/Mic 2 Left\",\n\t  \"Line/Mic 2 Right\",\n\t  NULL,\n\t  NULL\n};\n\n\nconst char * const snd_emu10k1_audigy_ins[16] = {\n\t  \"AC97 Left\",\n\t  \"AC97 Right\",\n\t  \"Audigy CD Left\",\n\t  \"Audigy CD Right\",\n\t  \"Optical IEC958 Left\",\n\t  \"Optical IEC958 Right\",\n\t  NULL,\n\t  NULL,\n\t  \"Line/Mic 2 Left\",\n\t  \"Line/Mic 2 Right\",\n\t  \"SPDIF Left\",\n\t  \"SPDIF Right\",\n\t  \"Aux2 Left\",\n\t  \"Aux2 Right\",\n\t  NULL,\n\t  NULL\n};\n\n\nconst char * const snd_emu10k1_sblive_outs[32] = {\n\t  \"AC97 Left\",\n\t  \"AC97 Right\",\n\t  \"Optical IEC958 Left\",\n\t  \"Optical IEC958 Right\",\n\t  \"Center\",\n\t  \"LFE\",\n\t  \"Headphone Left\",\n\t  \"Headphone Right\",\n\t  \"Surround Left\",\n\t  \"Surround Right\",\n\t  \"PCM Capture Left\",\n\t  \"PCM Capture Right\",\n\t  \"MIC Capture\",\n\t  \"AC97 Surround Left\",\n\t  \"AC97 Surround Right\",\n\t  NULL,\n\t\n\t  NULL,\n\t  \"Analog Center\",\n\t  \"Analog LFE\",\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n};\n\n\nconst char * const snd_emu10k1_audigy_outs[32] = {\n\t  \"Digital Front Left\",\n\t  \"Digital Front Right\",\n\t  \"Digital Center\",\n\t  \"Digital LEF\",\n\t  \"Headphone Left\",\n\t  \"Headphone Right\",\n\t  \"Digital Rear Left\",\n\t  \"Digital Rear Right\",\n\t  \"Front Left\",\n\t  \"Front Right\",\n\t  \"Center\",\n\t  \"LFE\",\n\t  NULL,\n\t  NULL,\n\t  \"Rear Left\",\n\t  \"Rear Right\",\n\t  \"AC97 Front Left\",\n\t  \"AC97 Front Right\",\n\t  \"ADC Capture Left\",\n\t  \"ADC Capture Right\",\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  NULL,\n};\n\n\n\n\n\n\n\n\n\nconst s8 snd_emu10k1_sblive51_fxbus2_map[16] = {\n\t2, -1, -1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1\n};\n\nstatic const u32 bass_table[41][5] = {\n\t{ 0x3e4f844f, 0x84ed4cc3, 0x3cc69927, 0x7b03553a, 0xc4da8486 },\n\t{ 0x3e69a17a, 0x84c280fb, 0x3cd77cd4, 0x7b2f2a6f, 0xc4b08d1d },\n\t{ 0x3e82ff42, 0x849991d5, 0x3ce7466b, 0x7b5917c6, 0xc48863ee },\n\t{ 0x3e9bab3c, 0x847267f0, 0x3cf5ffe8, 0x7b813560, 0xc461f22c },\n\t{ 0x3eb3b275, 0x844ced29, 0x3d03b295, 0x7ba79a1c, 0xc43d223b },\n\t{ 0x3ecb2174, 0x84290c8b, 0x3d106714, 0x7bcc5ba3, 0xc419dfa5 },\n\t{ 0x3ee2044b, 0x8406b244, 0x3d1c2561, 0x7bef8e77, 0xc3f8170f },\n\t{ 0x3ef86698, 0x83e5cb96, 0x3d26f4d8, 0x7c114600, 0xc3d7b625 },\n\t{ 0x3f0e5390, 0x83c646c9, 0x3d30dc39, 0x7c319498, 0xc3b8ab97 },\n\t{ 0x3f23d60b, 0x83a81321, 0x3d39e1af, 0x7c508b9c, 0xc39ae704 },\n\t{ 0x3f38f884, 0x838b20d2, 0x3d420ad2, 0x7c6e3b75, 0xc37e58f1 },\n\t{ 0x3f4dc52c, 0x836f60ef, 0x3d495cab, 0x7c8ab3a6, 0xc362f2be },\n\t{ 0x3f6245e8, 0x8354c565, 0x3d4fdbb8, 0x7ca602d6, 0xc348a69b },\n\t{ 0x3f76845f, 0x833b40ec, 0x3d558bf0, 0x7cc036df, 0xc32f677c },\n\t{ 0x3f8a8a03, 0x8322c6fb, 0x3d5a70c4, 0x7cd95cd7, 0xc317290b },\n\t{ 0x3f9e6014, 0x830b4bc3, 0x3d5e8d25, 0x7cf1811a, 0xc2ffdfa5 },\n\t{ 0x3fb20fae, 0x82f4c420, 0x3d61e37f, 0x7d08af56, 0xc2e9804a },\n\t{ 0x3fc5a1cc, 0x82df2592, 0x3d6475c3, 0x7d1ef294, 0xc2d40096 },\n\t{ 0x3fd91f55, 0x82ca6632, 0x3d664564, 0x7d345541, 0xc2bf56b9 },\n\t{ 0x3fec9120, 0x82b67cac, 0x3d675356, 0x7d48e138, 0xc2ab796e },\n\t{ 0x40000000, 0x82a36037, 0x3d67a012, 0x7d5c9fc9, 0xc2985fee },\n\t{ 0x401374c7, 0x8291088a, 0x3d672b93, 0x7d6f99c3, 0xc28601f2 },\n\t{ 0x4026f857, 0x827f6dd7, 0x3d65f559, 0x7d81d77c, 0xc27457a3 },\n\t{ 0x403a939f, 0x826e88c5, 0x3d63fc63, 0x7d9360d4, 0xc2635996 },\n\t{ 0x404e4faf, 0x825e5266, 0x3d613f32, 0x7da43d42, 0xc25300c6 },\n\t{ 0x406235ba, 0x824ec434, 0x3d5dbbc3, 0x7db473d7, 0xc243468e },\n\t{ 0x40764f1f, 0x823fd80c, 0x3d596f8f, 0x7dc40b44, 0xc23424a2 },\n\t{ 0x408aa576, 0x82318824, 0x3d545787, 0x7dd309e2, 0xc2259509 },\n\t{ 0x409f4296, 0x8223cf0b, 0x3d4e7012, 0x7de175b5, 0xc2179218 },\n\t{ 0x40b430a0, 0x8216a7a1, 0x3d47b505, 0x7def5475, 0xc20a1670 },\n\t{ 0x40c97a0a, 0x820a0d12, 0x3d4021a1, 0x7dfcab8d, 0xc1fd1cf5 },\n\t{ 0x40df29a6, 0x81fdfad6, 0x3d37b08d, 0x7e098028, 0xc1f0a0ca },\n\t{ 0x40f54ab1, 0x81f26ca9, 0x3d2e5bd1, 0x7e15d72b, 0xc1e49d52 },\n\t{ 0x410be8da, 0x81e75e89, 0x3d241cce, 0x7e21b544, 0xc1d90e24 },\n\t{ 0x41231051, 0x81dcccb3, 0x3d18ec37, 0x7e2d1ee6, 0xc1cdef10 },\n\t{ 0x413acdd0, 0x81d2b39e, 0x3d0cc20a, 0x7e38184e, 0xc1c33c13 },\n\t{ 0x41532ea7, 0x81c90ffb, 0x3cff9585, 0x7e42a58b, 0xc1b8f15a },\n\t{ 0x416c40cd, 0x81bfdeb2, 0x3cf15d21, 0x7e4cca7c, 0xc1af0b3f },\n\t{ 0x418612ea, 0x81b71cdc, 0x3ce20e85, 0x7e568ad3, 0xc1a58640 },\n\t{ 0x41a0b465, 0x81aec7c5, 0x3cd19e7c, 0x7e5fea1e, 0xc19c5f03 },\n\t{ 0x41bc3573, 0x81a6dcea, 0x3cc000e9, 0x7e68ebc2, 0xc1939250 }\n};\n\nstatic const u32 treble_table[41][5] = {\n\t{ 0x0125cba9, 0xfed5debd, 0x00599b6c, 0x0d2506da, 0xfa85b354 },\n\t{ 0x0142f67e, 0xfeb03163, 0x0066cd0f, 0x0d14c69d, 0xfa914473 },\n\t{ 0x016328bd, 0xfe860158, 0x0075b7f2, 0x0d03eb27, 0xfa9d32d2 },\n\t{ 0x0186b438, 0xfe56c982, 0x00869234, 0x0cf27048, 0xfaa97fca },\n\t{ 0x01adf358, 0xfe21f5fe, 0x00999842, 0x0ce051c2, 0xfab62ca5 },\n\t{ 0x01d949fa, 0xfde6e287, 0x00af0d8d, 0x0ccd8b4a, 0xfac33aa7 },\n\t{ 0x02092669, 0xfda4d8bf, 0x00c73d4c, 0x0cba1884, 0xfad0ab07 },\n\t{ 0x023e0268, 0xfd5b0e4a, 0x00e27b54, 0x0ca5f509, 0xfade7ef2 },\n\t{ 0x0278645c, 0xfd08a2b0, 0x01012509, 0x0c911c63, 0xfaecb788 },\n\t{ 0x02b8e091, 0xfcac9d1a, 0x0123a262, 0x0c7b8a14, 0xfafb55df },\n\t{ 0x03001a9a, 0xfc45e9ce, 0x014a6709, 0x0c65398f, 0xfb0a5aff },\n\t{ 0x034ec6d7, 0xfbd3576b, 0x0175f397, 0x0c4e2643, 0xfb19c7e4 },\n\t{ 0x03a5ac15, 0xfb5393ee, 0x01a6d6ed, 0x0c364b94, 0xfb299d7c },\n\t{ 0x0405a562, 0xfac52968, 0x01ddafae, 0x0c1da4e2, 0xfb39dca5 },\n\t{ 0x046fa3fe, 0xfa267a66, 0x021b2ddd, 0x0c042d8d, 0xfb4a8631 },\n\t{ 0x04e4b17f, 0xf975be0f, 0x0260149f, 0x0be9e0f2, 0xfb5b9ae0 },\n\t{ 0x0565f220, 0xf8b0fbe5, 0x02ad3c29, 0x0bceba73, 0xfb6d1b60 },\n\t{ 0x05f4a745, 0xf7d60722, 0x030393d4, 0x0bb2b578, 0xfb7f084d },\n\t{ 0x06923236, 0xf6e279bd, 0x03642465, 0x0b95cd75, 0xfb916233 },\n\t{ 0x07401713, 0xf5d3aef9, 0x03d01283, 0x0b77fded, 0xfba42984 },\n\t{ 0x08000000, 0xf4a6bd88, 0x0448a161, 0x0b594278, 0xfbb75e9f },\n\t{ 0x08d3c097, 0xf3587131, 0x04cf35a4, 0x0b3996c9, 0xfbcb01cb },\n\t{ 0x09bd59a2, 0xf1e543f9, 0x05655880, 0x0b18f6b2, 0xfbdf1333 },\n\t{ 0x0abefd0f, 0xf04956ca, 0x060cbb12, 0x0af75e2c, 0xfbf392e8 },\n\t{ 0x0bdb123e, 0xee806984, 0x06c739fe, 0x0ad4c962, 0xfc0880dd },\n\t{ 0x0d143a94, 0xec85d287, 0x0796e150, 0x0ab134b0, 0xfc1ddce5 },\n\t{ 0x0e6d5664, 0xea547598, 0x087df0a0, 0x0a8c9cb6, 0xfc33a6ad },\n\t{ 0x0fe98a2a, 0xe7e6ba35, 0x097edf83, 0x0a66fe5b, 0xfc49ddc2 },\n\t{ 0x118c4421, 0xe536813a, 0x0a9c6248, 0x0a4056d7, 0xfc608185 },\n\t{ 0x1359422e, 0xe23d19eb, 0x0bd96efb, 0x0a18a3bf, 0xfc77912c },\n\t{ 0x1554982b, 0xdef33645, 0x0d3942bd, 0x09efe312, 0xfc8f0bc1 },\n\t{ 0x1782b68a, 0xdb50deb1, 0x0ebf676d, 0x09c6133f, 0xfca6f019 },\n\t{ 0x19e8715d, 0xd74d64fd, 0x106fb999, 0x099b3337, 0xfcbf3cd6 },\n\t{ 0x1c8b07b8, 0xd2df56ab, 0x124e6ec8, 0x096f4274, 0xfcd7f060 },\n\t{ 0x1f702b6d, 0xcdfc6e92, 0x14601c10, 0x0942410b, 0xfcf108e5 },\n\t{ 0x229e0933, 0xc89985cd, 0x16a9bcfa, 0x09142fb5, 0xfd0a8451 },\n\t{ 0x261b5118, 0xc2aa8409, 0x1930bab6, 0x08e50fdc, 0xfd24604d },\n\t{ 0x29ef3f5d, 0xbc224f28, 0x1bfaf396, 0x08b4e3aa, 0xfd3e9a3b },\n\t{ 0x2e21a59b, 0xb4f2ba46, 0x1f0ec2d6, 0x0883ae15, 0xfd592f33 },\n\t{ 0x32baf44b, 0xad0c7429, 0x227308a3, 0x085172eb, 0xfd741bfd },\n\t{ 0x37c4448b, 0xa45ef51d, 0x262f3267, 0x081e36dc, 0xfd8f5d14 }\n};\n\n \nstatic const u32 db_table[101] = {\n\t0x00000000, 0x01571f82, 0x01674b41, 0x01783a1b, 0x0189f540,\n\t0x019c8651, 0x01aff763, 0x01c45306, 0x01d9a446, 0x01eff6b8,\n\t0x0207567a, 0x021fd03d, 0x0239714c, 0x02544792, 0x027061a1,\n\t0x028dcebb, 0x02ac9edc, 0x02cce2bf, 0x02eeabe8, 0x03120cb0,\n\t0x0337184e, 0x035de2df, 0x03868173, 0x03b10a18, 0x03dd93e9,\n\t0x040c3713, 0x043d0cea, 0x04702ff3, 0x04a5bbf2, 0x04ddcdfb,\n\t0x0518847f, 0x0555ff62, 0x05966005, 0x05d9c95d, 0x06206005,\n\t0x066a4a52, 0x06b7b067, 0x0708bc4c, 0x075d9a01, 0x07b6779d,\n\t0x08138561, 0x0874f5d5, 0x08dafde1, 0x0945d4ed, 0x09b5b4fd,\n\t0x0a2adad1, 0x0aa58605, 0x0b25f936, 0x0bac7a24, 0x0c3951d8,\n\t0x0ccccccc, 0x0d673b17, 0x0e08f093, 0x0eb24510, 0x0f639481,\n\t0x101d3f2d, 0x10dfa9e6, 0x11ab3e3f, 0x12806ac3, 0x135fa333,\n\t0x144960c5, 0x153e2266, 0x163e6cfe, 0x174acbb7, 0x1863d04d,\n\t0x198a1357, 0x1abe349f, 0x1c00db77, 0x1d52b712, 0x1eb47ee6,\n\t0x2026f30f, 0x21aadcb6, 0x23410e7e, 0x24ea64f9, 0x26a7c71d,\n\t0x287a26c4, 0x2a62812c, 0x2c61df84, 0x2e795779, 0x30aa0bcf,\n\t0x32f52cfe, 0x355bf9d8, 0x37dfc033, 0x3a81dda4, 0x3d43c038,\n\t0x4026e73c, 0x432ce40f, 0x46575af8, 0x49a8040f, 0x4d20ac2a,\n\t0x50c335d3, 0x54919a57, 0x588dead1, 0x5cba514a, 0x611911ea,\n\t0x65ac8c2f, 0x6a773c39, 0x6f7bbc23, 0x74bcc56c, 0x7a3d3272,\n\t0x7fffffff,\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(snd_emu10k1_db_scale1, -4000, 40, 1);\nstatic const DECLARE_TLV_DB_LINEAR(snd_emu10k1_db_linear, TLV_DB_GAIN_MUTE, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(snd_emu10k1_bass_treble_db_scale, -1200, 60, 0);\n\nstatic const u32 onoff_table[2] = {\n\t0x00000000, 0x00000001\n};\n\n \n\nstatic int snd_emu10k1_gpr_ctl_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1_fx8010_ctl *ctl =\n\t\t(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\n\n\tif (ctl->min == 0 && ctl->max == 1)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = ctl->vcount;\n\tuinfo->value.integer.min = ctl->min;\n\tuinfo->value.integer.max = ctl->max;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_gpr_ctl_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1_fx8010_ctl *ctl =\n\t\t(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\n\tunsigned int i;\n\t\n\tfor (i = 0; i < ctl->vcount; i++)\n\t\tucontrol->value.integer.value[i] = ctl->value[i];\n\treturn 0;\n}\n\nstatic int snd_emu10k1_gpr_ctl_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_fx8010_ctl *ctl =\n\t\t(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\n\tint nval, val;\n\tunsigned int i, j;\n\tint change = 0;\n\t\n\tfor (i = 0; i < ctl->vcount; i++) {\n\t\tnval = ucontrol->value.integer.value[i];\n\t\tif (nval < ctl->min)\n\t\t\tnval = ctl->min;\n\t\tif (nval > ctl->max)\n\t\t\tnval = ctl->max;\n\t\tif (nval != ctl->value[i])\n\t\t\tchange = 1;\n\t\tval = ctl->value[i] = nval;\n\t\tswitch (ctl->translation) {\n\t\tcase EMU10K1_GPR_TRANSLATION_NONE:\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, val);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_NEGATE:\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, ~val);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_TABLE100:\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, db_table[val]);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_NEG_TABLE100:\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0,\n\t\t\t\t\t      val == 100 ? 0x80000000 : -(int)db_table[val]);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_BASS:\n\t\t\tif ((ctl->count % 5) != 0 || (ctl->count / 5) != ctl->vcount) {\n\t\t\t\tchange = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tfor (j = 0; j < 5; j++)\n\t\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[j * ctl->vcount + i], 0, bass_table[val][j]);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_TREBLE:\n\t\t\tif ((ctl->count % 5) != 0 || (ctl->count / 5) != ctl->vcount) {\n\t\t\t\tchange = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tfor (j = 0; j < 5; j++)\n\t\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[j * ctl->vcount + i], 0, treble_table[val][j]);\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_ONOFF:\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, onoff_table[val]);\n\t\t\tbreak;\n\t\t}\n\t}\n      __error:\n\treturn change;\n}\n\n \n\nstatic void snd_emu10k1_fx8010_interrupt(struct snd_emu10k1 *emu)\n{\n\tstruct snd_emu10k1_fx8010_irq *irq, *nirq;\n\n\tirq = emu->fx8010.irq_handlers;\n\twhile (irq) {\n\t\tnirq = irq->next;\t \n\t\tif (snd_emu10k1_ptr_read(emu, emu->gpr_base + irq->gpr_running, 0) & 0xffff0000) {\n\t\t\tif (irq->handler)\n\t\t\t\tirq->handler(emu, irq->private_data);\n\t\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + irq->gpr_running, 0, 1);\n\t\t}\n\t\tirq = nirq;\n\t}\n}\n\nint snd_emu10k1_fx8010_register_irq_handler(struct snd_emu10k1 *emu,\n\t\t\t\t\t    snd_fx8010_irq_handler_t *handler,\n\t\t\t\t\t    unsigned char gpr_running,\n\t\t\t\t\t    void *private_data,\n\t\t\t\t\t    struct snd_emu10k1_fx8010_irq *irq)\n{\n\tunsigned long flags;\n\t\n\tirq->handler = handler;\n\tirq->gpr_running = gpr_running;\n\tirq->private_data = private_data;\n\tirq->next = NULL;\n\tspin_lock_irqsave(&emu->fx8010.irq_lock, flags);\n\tif (emu->fx8010.irq_handlers == NULL) {\n\t\temu->fx8010.irq_handlers = irq;\n\t\temu->dsp_interrupt = snd_emu10k1_fx8010_interrupt;\n\t\tsnd_emu10k1_intr_enable(emu, INTE_FXDSPENABLE);\n\t} else {\n\t\tirq->next = emu->fx8010.irq_handlers;\n\t\temu->fx8010.irq_handlers = irq;\n\t}\n\tspin_unlock_irqrestore(&emu->fx8010.irq_lock, flags);\n\treturn 0;\n}\n\nint snd_emu10k1_fx8010_unregister_irq_handler(struct snd_emu10k1 *emu,\n\t\t\t\t\t      struct snd_emu10k1_fx8010_irq *irq)\n{\n\tstruct snd_emu10k1_fx8010_irq *tmp;\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&emu->fx8010.irq_lock, flags);\n\ttmp = emu->fx8010.irq_handlers;\n\tif (tmp == irq) {\n\t\temu->fx8010.irq_handlers = tmp->next;\n\t\tif (emu->fx8010.irq_handlers == NULL) {\n\t\t\tsnd_emu10k1_intr_disable(emu, INTE_FXDSPENABLE);\n\t\t\temu->dsp_interrupt = NULL;\n\t\t}\n\t} else {\n\t\twhile (tmp && tmp->next != irq)\n\t\t\ttmp = tmp->next;\n\t\tif (tmp)\n\t\t\ttmp->next = tmp->next->next;\n\t}\n\tspin_unlock_irqrestore(&emu->fx8010.irq_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic void snd_emu10k1_write_op(struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t unsigned int *ptr,\n\t\t\t\t u32 op, u32 r, u32 a, u32 x, u32 y)\n{\n\tu_int32_t *code;\n\tif (snd_BUG_ON(*ptr >= 512))\n\t\treturn;\n\tcode = icode->code + (*ptr) * 2;\n\tset_bit(*ptr, icode->code_valid);\n\tcode[0] = ((x & 0x3ff) << 10) | (y & 0x3ff);\n\tcode[1] = ((op & 0x0f) << 20) | ((r & 0x3ff) << 10) | (a & 0x3ff);\n\t(*ptr)++;\n}\n\n#define OP(icode, ptr, op, r, a, x, y) \\\n\tsnd_emu10k1_write_op(icode, ptr, op, r, a, x, y)\n\nstatic void snd_emu10k1_audigy_write_op(struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t\tunsigned int *ptr,\n\t\t\t\t\tu32 op, u32 r, u32 a, u32 x, u32 y)\n{\n\tu_int32_t *code;\n\tif (snd_BUG_ON(*ptr >= 1024))\n\t\treturn;\n\tcode = icode->code + (*ptr) * 2;\n\tset_bit(*ptr, icode->code_valid);\n\tcode[0] = ((x & 0x7ff) << 12) | (y & 0x7ff);\n\tcode[1] = ((op & 0x0f) << 24) | ((r & 0x7ff) << 12) | (a & 0x7ff);\n\t(*ptr)++;\n}\n\n#define A_OP(icode, ptr, op, r, a, x, y) \\\n\tsnd_emu10k1_audigy_write_op(icode, ptr, op, r, a, x, y)\n\nstatic void snd_emu10k1_efx_write(struct snd_emu10k1 *emu, unsigned int pc, unsigned int data)\n{\n\tpc += emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\n\tsnd_emu10k1_ptr_write(emu, pc, 0, data);\n}\n\nunsigned int snd_emu10k1_efx_read(struct snd_emu10k1 *emu, unsigned int pc)\n{\n\tpc += emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\n\treturn snd_emu10k1_ptr_read(emu, pc, 0);\n}\n\nstatic int snd_emu10k1_gpr_poke(struct snd_emu10k1 *emu,\n\t\t\t\tstruct snd_emu10k1_fx8010_code *icode,\n\t\t\t\tbool in_kernel)\n{\n\tint gpr;\n\tu32 val;\n\n\tfor (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {\n\t\tif (!test_bit(gpr, icode->gpr_valid))\n\t\t\tcontinue;\n\t\tif (in_kernel)\n\t\t\tval = icode->gpr_map[gpr];\n\t\telse if (get_user(val, (__user u32 *)&icode->gpr_map[gpr]))\n\t\t\treturn -EFAULT;\n\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + gpr, 0, val);\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_gpr_peek(struct snd_emu10k1 *emu,\n\t\t\t\tstruct snd_emu10k1_fx8010_code *icode)\n{\n\tint gpr;\n\tu32 val;\n\n\tfor (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {\n\t\tset_bit(gpr, icode->gpr_valid);\n\t\tval = snd_emu10k1_ptr_read(emu, emu->gpr_base + gpr, 0);\n\t\tif (put_user(val, (__user u32 *)&icode->gpr_map[gpr]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_tram_poke(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t bool in_kernel)\n{\n\tint tram;\n\tu32 addr, val;\n\n\tfor (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {\n\t\tif (!test_bit(tram, icode->tram_valid))\n\t\t\tcontinue;\n\t\tif (in_kernel) {\n\t\t\tval = icode->tram_data_map[tram];\n\t\t\taddr = icode->tram_addr_map[tram];\n\t\t} else {\n\t\t\tif (get_user(val, (__user __u32 *)&icode->tram_data_map[tram]) ||\n\t\t\t    get_user(addr, (__user __u32 *)&icode->tram_addr_map[tram]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tsnd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + tram, 0, val);\n\t\tif (!emu->audigy) {\n\t\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr);\n\t\t} else {\n\t\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr << 12);\n\t\t\tsnd_emu10k1_ptr_write(emu, A_TANKMEMCTLREGBASE + tram, 0, addr >> 20);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_tram_peek(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_code *icode)\n{\n\tint tram;\n\tu32 val, addr;\n\n\tmemset(icode->tram_valid, 0, sizeof(icode->tram_valid));\n\tfor (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {\n\t\tset_bit(tram, icode->tram_valid);\n\t\tval = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + tram, 0);\n\t\tif (!emu->audigy) {\n\t\t\taddr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);\n\t\t} else {\n\t\t\taddr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0) >> 12;\n\t\t\taddr |= snd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + tram, 0) << 20;\n\t\t}\n\t\tif (put_user(val, (__user u32 *)&icode->tram_data_map[tram]) ||\n\t\t    put_user(addr, (__user u32 *)&icode->tram_addr_map[tram]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_code_poke(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t bool in_kernel)\n{\n\tu32 pc, lo, hi;\n\n\tfor (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {\n\t\tif (!test_bit(pc / 2, icode->code_valid))\n\t\t\tcontinue;\n\t\tif (in_kernel) {\n\t\t\tlo = icode->code[pc + 0];\n\t\t\thi = icode->code[pc + 1];\n\t\t} else {\n\t\t\tif (get_user(lo, (__user u32 *)&icode->code[pc + 0]) ||\n\t\t\t    get_user(hi, (__user u32 *)&icode->code[pc + 1]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tsnd_emu10k1_efx_write(emu, pc + 0, lo);\n\t\tsnd_emu10k1_efx_write(emu, pc + 1, hi);\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_code_peek(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_code *icode)\n{\n\tu32 pc;\n\n\tmemset(icode->code_valid, 0, sizeof(icode->code_valid));\n\tfor (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {\n\t\tset_bit(pc / 2, icode->code_valid);\n\t\tif (put_user(snd_emu10k1_efx_read(emu, pc + 0),\n\t\t\t     (__user u32 *)&icode->code[pc + 0]))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(snd_emu10k1_efx_read(emu, pc + 1),\n\t\t\t     (__user u32 *)&icode->code[pc + 1]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic struct snd_emu10k1_fx8010_ctl *\nsnd_emu10k1_look_for_ctl(struct snd_emu10k1 *emu,\n\t\t\t struct emu10k1_ctl_elem_id *_id)\n{\n\tstruct snd_ctl_elem_id *id = (struct snd_ctl_elem_id *)_id;\n\tstruct snd_emu10k1_fx8010_ctl *ctl;\n\tstruct snd_kcontrol *kcontrol;\n\n\tlist_for_each_entry(ctl, &emu->fx8010.gpr_ctl, list) {\n\t\tkcontrol = ctl->kcontrol;\n\t\tif (kcontrol->id.iface == id->iface &&\n\t\t    kcontrol->id.index == id->index &&\n\t\t    !strcmp(kcontrol->id.name, id->name))\n\t\t\treturn ctl;\n\t}\n\treturn NULL;\n}\n\n#define MAX_TLV_SIZE\t256\n\nstatic unsigned int *copy_tlv(const unsigned int __user *_tlv, bool in_kernel)\n{\n\tunsigned int data[2];\n\tunsigned int *tlv;\n\n\tif (!_tlv)\n\t\treturn NULL;\n\tif (in_kernel)\n\t\tmemcpy(data, (__force void *)_tlv, sizeof(data));\n\telse if (copy_from_user(data, _tlv, sizeof(data)))\n\t\treturn NULL;\n\tif (data[1] >= MAX_TLV_SIZE)\n\t\treturn NULL;\n\ttlv = kmalloc(data[1] + sizeof(data), GFP_KERNEL);\n\tif (!tlv)\n\t\treturn NULL;\n\tmemcpy(tlv, data, sizeof(data));\n\tif (in_kernel) {\n\t\tmemcpy(tlv + 2, (__force void *)(_tlv + 2),  data[1]);\n\t} else if (copy_from_user(tlv + 2, _tlv + 2, data[1])) {\n\t\tkfree(tlv);\n\t\treturn NULL;\n\t}\n\treturn tlv;\n}\n\nstatic int copy_gctl(struct snd_emu10k1 *emu,\n\t\t     struct snd_emu10k1_fx8010_control_gpr *dst,\n\t\t     struct snd_emu10k1_fx8010_control_gpr *src,\n\t\t     int idx, bool in_kernel)\n{\n\tstruct snd_emu10k1_fx8010_control_gpr __user *_src;\n\tstruct snd_emu10k1_fx8010_control_old_gpr *octl;\n\tstruct snd_emu10k1_fx8010_control_old_gpr __user *_octl;\n\n\t_src = (struct snd_emu10k1_fx8010_control_gpr __user *)src;\n\tif (emu->support_tlv) {\n\t\tif (in_kernel)\n\t\t\t*dst = src[idx];\n\t\telse if (copy_from_user(dst, &_src[idx], sizeof(*src)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\toctl = (struct snd_emu10k1_fx8010_control_old_gpr *)src;\n\t_octl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)octl;\n\tif (in_kernel)\n\t\tmemcpy(dst, &octl[idx], sizeof(*octl));\n\telse if (copy_from_user(dst, &_octl[idx], sizeof(*octl)))\n\t\treturn -EFAULT;\n\tdst->tlv = NULL;\n\treturn 0;\n}\n\nstatic int copy_gctl_to_user(struct snd_emu10k1 *emu,\n\t\t     struct snd_emu10k1_fx8010_control_gpr *dst,\n\t\t     struct snd_emu10k1_fx8010_control_gpr *src,\n\t\t     int idx)\n{\n\tstruct snd_emu10k1_fx8010_control_gpr __user *_dst;\n\tstruct snd_emu10k1_fx8010_control_old_gpr __user *octl;\n\n\t_dst = (struct snd_emu10k1_fx8010_control_gpr __user *)dst;\n\tif (emu->support_tlv)\n\t\treturn copy_to_user(&_dst[idx], src, sizeof(*src));\n\t\n\toctl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)dst;\n\treturn copy_to_user(&octl[idx], src, sizeof(*octl));\n}\n\nstatic int copy_ctl_elem_id(const struct emu10k1_ctl_elem_id *list, int i,\n\t\t\t    struct emu10k1_ctl_elem_id *ret, bool in_kernel)\n{\n\tstruct emu10k1_ctl_elem_id __user *_id =\n\t\t(struct emu10k1_ctl_elem_id __user *)&list[i];\n\n\tif (in_kernel)\n\t\t*ret = list[i];\n\telse if (copy_from_user(ret, _id, sizeof(*ret)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_verify_controls(struct snd_emu10k1 *emu,\n\t\t\t\t       struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t       bool in_kernel)\n{\n\tunsigned int i;\n\tstruct emu10k1_ctl_elem_id id;\n\tstruct snd_emu10k1_fx8010_control_gpr *gctl;\n\tstruct snd_ctl_elem_id *gctl_id;\n\tint err;\n\t\n\tfor (i = 0; i < icode->gpr_del_control_count; i++) {\n\t\terr = copy_ctl_elem_id(icode->gpr_del_controls, i, &id,\n\t\t\t\t       in_kernel);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (snd_emu10k1_look_for_ctl(emu, &id) == NULL)\n\t\t\treturn -ENOENT;\n\t}\n\tgctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\n\tif (! gctl)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < icode->gpr_add_control_count; i++) {\n\t\tif (copy_gctl(emu, gctl, icode->gpr_add_controls, i,\n\t\t\t      in_kernel)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __error;\n\t\t}\n\t\tif (snd_emu10k1_look_for_ctl(emu, &gctl->id))\n\t\t\tcontinue;\n\t\tgctl_id = (struct snd_ctl_elem_id *)&gctl->id;\n\t\tif (snd_ctl_find_id(emu->card, gctl_id)) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto __error;\n\t\t}\n\t\tif (gctl_id->iface != SNDRV_CTL_ELEM_IFACE_MIXER &&\n\t\t    gctl_id->iface != SNDRV_CTL_ELEM_IFACE_PCM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto __error;\n\t\t}\n\t\tswitch (gctl->translation) {\n\t\tcase EMU10K1_GPR_TRANSLATION_NONE:\n\t\tcase EMU10K1_GPR_TRANSLATION_NEGATE:\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_TABLE100:\n\t\tcase EMU10K1_GPR_TRANSLATION_NEG_TABLE100:\n\t\t\tif (gctl->min != 0 || gctl->max != 100) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_BASS:\n\t\tcase EMU10K1_GPR_TRANSLATION_TREBLE:\n\t\t\tif (gctl->min != 0 || gctl->max != 40) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EMU10K1_GPR_TRANSLATION_ONOFF:\n\t\t\tif (gctl->min != 0 || gctl->max != 1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tfor (i = 0; i < icode->gpr_list_control_count; i++) {\n\t     \t \n\t\tif (copy_gctl(emu, gctl, icode->gpr_list_controls, i,\n\t\t\t      in_kernel)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __error;\n\t\t}\n\t}\n __error:\n\tkfree(gctl);\n\treturn err;\n}\n\nstatic void snd_emu10k1_ctl_private_free(struct snd_kcontrol *kctl)\n{\n\tstruct snd_emu10k1_fx8010_ctl *ctl;\n\t\n\tctl = (struct snd_emu10k1_fx8010_ctl *) kctl->private_value;\n\tkctl->private_value = 0;\n\tlist_del(&ctl->list);\n\tkfree(ctl);\n\tkfree(kctl->tlv.p);\n}\n\nstatic int snd_emu10k1_add_controls(struct snd_emu10k1 *emu,\n\t\t\t\t    struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t    bool in_kernel)\n{\n\tunsigned int i, j;\n\tstruct snd_emu10k1_fx8010_control_gpr *gctl;\n\tstruct snd_ctl_elem_id *gctl_id;\n\tstruct snd_emu10k1_fx8010_ctl *ctl, *nctl;\n\tstruct snd_kcontrol_new knew;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_value *val;\n\tint err = 0;\n\n\tval = kmalloc(sizeof(*val), GFP_KERNEL);\n\tgctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\n\tnctl = kmalloc(sizeof(*nctl), GFP_KERNEL);\n\tif (!val || !gctl || !nctl) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\n\tfor (i = 0; i < icode->gpr_add_control_count; i++) {\n\t\tif (copy_gctl(emu, gctl, icode->gpr_add_controls, i,\n\t\t\t      in_kernel)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __error;\n\t\t}\n\t\tgctl_id = (struct snd_ctl_elem_id *)&gctl->id;\n\t\tif (gctl_id->iface != SNDRV_CTL_ELEM_IFACE_MIXER &&\n\t\t    gctl_id->iface != SNDRV_CTL_ELEM_IFACE_PCM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto __error;\n\t\t}\n\t\tif (!*gctl_id->name) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto __error;\n\t\t}\n\t\tctl = snd_emu10k1_look_for_ctl(emu, &gctl->id);\n\t\tmemset(&knew, 0, sizeof(knew));\n\t\tknew.iface = gctl_id->iface;\n\t\tknew.name = gctl_id->name;\n\t\tknew.index = gctl_id->index;\n\t\tknew.device = gctl_id->device;\n\t\tknew.subdevice = gctl_id->subdevice;\n\t\tknew.info = snd_emu10k1_gpr_ctl_info;\n\t\tknew.tlv.p = copy_tlv((const unsigned int __user *)gctl->tlv, in_kernel);\n\t\tif (knew.tlv.p)\n\t\t\tknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\tknew.get = snd_emu10k1_gpr_ctl_get;\n\t\tknew.put = snd_emu10k1_gpr_ctl_put;\n\t\tmemset(nctl, 0, sizeof(*nctl));\n\t\tnctl->vcount = gctl->vcount;\n\t\tnctl->count = gctl->count;\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tnctl->gpr[j] = gctl->gpr[j];\n\t\t\tnctl->value[j] = ~gctl->value[j];\t \n\t\t\tval->value.integer.value[j] = gctl->value[j];\n\t\t}\n\t\tnctl->min = gctl->min;\n\t\tnctl->max = gctl->max;\n\t\tnctl->translation = gctl->translation;\n\t\tif (ctl == NULL) {\n\t\t\tctl = kmalloc(sizeof(*ctl), GFP_KERNEL);\n\t\t\tif (ctl == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tkfree(knew.tlv.p);\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tknew.private_value = (unsigned long)ctl;\n\t\t\t*ctl = *nctl;\n\t\t\tkctl = snd_ctl_new1(&knew, emu);\n\t\t\terr = snd_ctl_add(emu->card, kctl);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(ctl);\n\t\t\t\tkfree(knew.tlv.p);\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tkctl->private_free = snd_emu10k1_ctl_private_free;\n\t\t\tctl->kcontrol = kctl;\n\t\t\tlist_add_tail(&ctl->list, &emu->fx8010.gpr_ctl);\n\t\t} else {\n\t\t\t \n\t\t\tnctl->list = ctl->list;\n\t\t\tnctl->kcontrol = ctl->kcontrol;\n\t\t\t*ctl = *nctl;\n\t\t\tsnd_ctl_notify(emu->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t                          SNDRV_CTL_EVENT_MASK_INFO, &ctl->kcontrol->id);\n\t\t}\n\t\tsnd_emu10k1_gpr_ctl_put(ctl->kcontrol, val);\n\t}\n      __error:\n\tkfree(nctl);\n\tkfree(gctl);\n\tkfree(val);\n\treturn err;\n}\n\nstatic int snd_emu10k1_del_controls(struct snd_emu10k1 *emu,\n\t\t\t\t    struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t    bool in_kernel)\n{\n\tunsigned int i;\n\tstruct emu10k1_ctl_elem_id id;\n\tstruct snd_emu10k1_fx8010_ctl *ctl;\n\tstruct snd_card *card = emu->card;\n\tint err;\n\t\n\tfor (i = 0; i < icode->gpr_del_control_count; i++) {\n\t\terr = copy_ctl_elem_id(icode->gpr_del_controls, i, &id,\n\t\t\t\t       in_kernel);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tctl = snd_emu10k1_look_for_ctl(emu, &id);\n\t\tif (ctl)\n\t\t\tsnd_ctl_remove(card, ctl->kcontrol);\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_list_controls(struct snd_emu10k1 *emu,\n\t\t\t\t     struct snd_emu10k1_fx8010_code *icode)\n{\n\tunsigned int i = 0, j;\n\tunsigned int total = 0;\n\tstruct snd_emu10k1_fx8010_control_gpr *gctl;\n\tstruct snd_emu10k1_fx8010_ctl *ctl;\n\tstruct snd_ctl_elem_id *id;\n\n\tgctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\n\tif (! gctl)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(ctl, &emu->fx8010.gpr_ctl, list) {\n\t\ttotal++;\n\t\tif (icode->gpr_list_controls &&\n\t\t    i < icode->gpr_list_control_count) {\n\t\t\tmemset(gctl, 0, sizeof(*gctl));\n\t\t\tid = &ctl->kcontrol->id;\n\t\t\tgctl->id.iface = (__force int)id->iface;\n\t\t\tstrscpy(gctl->id.name, id->name, sizeof(gctl->id.name));\n\t\t\tgctl->id.index = id->index;\n\t\t\tgctl->id.device = id->device;\n\t\t\tgctl->id.subdevice = id->subdevice;\n\t\t\tgctl->vcount = ctl->vcount;\n\t\t\tgctl->count = ctl->count;\n\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\tgctl->gpr[j] = ctl->gpr[j];\n\t\t\t\tgctl->value[j] = ctl->value[j];\n\t\t\t}\n\t\t\tgctl->min = ctl->min;\n\t\t\tgctl->max = ctl->max;\n\t\t\tgctl->translation = ctl->translation;\n\t\t\tif (copy_gctl_to_user(emu, icode->gpr_list_controls,\n\t\t\t\t\t      gctl, i)) {\n\t\t\t\tkfree(gctl);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\ticode->gpr_list_control_total = total;\n\tkfree(gctl);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_icode_poke(struct snd_emu10k1 *emu,\n\t\t\t\t  struct snd_emu10k1_fx8010_code *icode,\n\t\t\t\t  bool in_kernel)\n{\n\tint err = 0;\n\n\tmutex_lock(&emu->fx8010.lock);\n\terr = snd_emu10k1_verify_controls(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\tstrscpy(emu->fx8010.name, icode->name, sizeof(emu->fx8010.name));\n\t \n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_SINGLE_STEP);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_SINGLE_STEP);\n\t \n\terr = snd_emu10k1_del_controls(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\terr = snd_emu10k1_gpr_poke(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\terr = snd_emu10k1_tram_poke(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\terr = snd_emu10k1_code_poke(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\terr = snd_emu10k1_add_controls(emu, icode, in_kernel);\n\tif (err < 0)\n\t\tgoto __error;\n\t \n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\n      __error:\n\tmutex_unlock(&emu->fx8010.lock);\n\treturn err;\n}\n\nstatic int snd_emu10k1_icode_peek(struct snd_emu10k1 *emu,\n\t\t\t\t  struct snd_emu10k1_fx8010_code *icode)\n{\n\tint err;\n\n\tmutex_lock(&emu->fx8010.lock);\n\tstrscpy(icode->name, emu->fx8010.name, sizeof(icode->name));\n\t \n\terr = snd_emu10k1_gpr_peek(emu, icode);\n\tif (err >= 0)\n\t\terr = snd_emu10k1_tram_peek(emu, icode);\n\tif (err >= 0)\n\t\terr = snd_emu10k1_code_peek(emu, icode);\n\tif (err >= 0)\n\t\terr = snd_emu10k1_list_controls(emu, icode);\n\tmutex_unlock(&emu->fx8010.lock);\n\treturn err;\n}\n\nstatic int snd_emu10k1_ipcm_poke(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_pcm_rec *ipcm)\n{\n\tunsigned int i;\n\tint err = 0;\n\tstruct snd_emu10k1_fx8010_pcm *pcm;\n\n\tif (ipcm->substream >= EMU10K1_FX8010_PCM_COUNT)\n\t\treturn -EINVAL;\n\tipcm->substream = array_index_nospec(ipcm->substream,\n\t\t\t\t\t     EMU10K1_FX8010_PCM_COUNT);\n\tif (ipcm->channels > 32)\n\t\treturn -EINVAL;\n\tpcm = &emu->fx8010.pcm[ipcm->substream];\n\tmutex_lock(&emu->fx8010.lock);\n\tspin_lock_irq(&emu->reg_lock);\n\tif (pcm->opened) {\n\t\terr = -EBUSY;\n\t\tgoto __error;\n\t}\n\tif (ipcm->channels == 0) {\t \n\t\tpcm->valid = 0;\n\t} else {\n\t\t \n\t\tif (ipcm->channels != 2) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto __error;\n\t\t}\n\t\tpcm->valid = 1;\n\t\tpcm->opened = 0;\n\t\tpcm->channels = ipcm->channels;\n\t\tpcm->tram_start = ipcm->tram_start;\n\t\tpcm->buffer_size = ipcm->buffer_size;\n\t\tpcm->gpr_size = ipcm->gpr_size;\n\t\tpcm->gpr_count = ipcm->gpr_count;\n\t\tpcm->gpr_tmpcount = ipcm->gpr_tmpcount;\n\t\tpcm->gpr_ptr = ipcm->gpr_ptr;\n\t\tpcm->gpr_trigger = ipcm->gpr_trigger;\n\t\tpcm->gpr_running = ipcm->gpr_running;\n\t\tfor (i = 0; i < pcm->channels; i++)\n\t\t\tpcm->etram[i] = ipcm->etram[i];\n\t}\n      __error:\n\tspin_unlock_irq(&emu->reg_lock);\n\tmutex_unlock(&emu->fx8010.lock);\n\treturn err;\n}\n\nstatic int snd_emu10k1_ipcm_peek(struct snd_emu10k1 *emu,\n\t\t\t\t struct snd_emu10k1_fx8010_pcm_rec *ipcm)\n{\n\tunsigned int i;\n\tint err = 0;\n\tstruct snd_emu10k1_fx8010_pcm *pcm;\n\n\tif (ipcm->substream >= EMU10K1_FX8010_PCM_COUNT)\n\t\treturn -EINVAL;\n\tipcm->substream = array_index_nospec(ipcm->substream,\n\t\t\t\t\t     EMU10K1_FX8010_PCM_COUNT);\n\tpcm = &emu->fx8010.pcm[ipcm->substream];\n\tmutex_lock(&emu->fx8010.lock);\n\tspin_lock_irq(&emu->reg_lock);\n\tipcm->channels = pcm->channels;\n\tipcm->tram_start = pcm->tram_start;\n\tipcm->buffer_size = pcm->buffer_size;\n\tipcm->gpr_size = pcm->gpr_size;\n\tipcm->gpr_ptr = pcm->gpr_ptr;\n\tipcm->gpr_count = pcm->gpr_count;\n\tipcm->gpr_tmpcount = pcm->gpr_tmpcount;\n\tipcm->gpr_trigger = pcm->gpr_trigger;\n\tipcm->gpr_running = pcm->gpr_running;\n\tfor (i = 0; i < pcm->channels; i++)\n\t\tipcm->etram[i] = pcm->etram[i];\n\tipcm->res1 = ipcm->res2 = 0;\n\tipcm->pad = 0;\n\tspin_unlock_irq(&emu->reg_lock);\n\tmutex_unlock(&emu->fx8010.lock);\n\treturn err;\n}\n\n#define SND_EMU10K1_GPR_CONTROLS\t44\n#define SND_EMU10K1_INPUTS\t\t12\n#define SND_EMU10K1_PLAYBACK_CHANNELS\t8\n#define SND_EMU10K1_CAPTURE_CHANNELS\t4\n\n#define HR_VAL(v) ((v) * 0x80000000LL / 100 - 1)\n\nstatic void\nsnd_emu10k1_init_mono_control2(struct snd_emu10k1_fx8010_control_gpr *ctl,\n\t\t\t       const char *name, int gpr, int defval, int defval_hr)\n{\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, name);\n\tctl->vcount = ctl->count = 1;\n\tif (high_res_gpr_volume) {\n\t\tctl->min = -1;\n\t\tctl->max = 0x7fffffff;\n\t\tctl->tlv = snd_emu10k1_db_linear;\n\t\tctl->translation = EMU10K1_GPR_TRANSLATION_NEGATE;\n\t\tdefval = defval_hr;\n\t} else {\n\t\tctl->min = 0;\n\t\tctl->max = 100;\n\t\tctl->tlv = snd_emu10k1_db_scale1;\n\t\tctl->translation = EMU10K1_GPR_TRANSLATION_NEG_TABLE100;\n\t}\n\tctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\n}\n#define snd_emu10k1_init_mono_control(ctl, name, gpr, defval) \\\n\tsnd_emu10k1_init_mono_control2(ctl, name, gpr, defval, HR_VAL(defval))\n\nstatic void\nsnd_emu10k1_init_stereo_control2(struct snd_emu10k1_fx8010_control_gpr *ctl,\n\t\t\t\t const char *name, int gpr, int defval, int defval_hr)\n{\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, name);\n\tctl->vcount = ctl->count = 2;\n\tif (high_res_gpr_volume) {\n\t\tctl->min = -1;\n\t\tctl->max = 0x7fffffff;\n\t\tctl->tlv = snd_emu10k1_db_linear;\n\t\tctl->translation = EMU10K1_GPR_TRANSLATION_NEGATE;\n\t\tdefval = defval_hr;\n\t} else {\n\t\tctl->min = 0;\n\t\tctl->max = 100;\n\t\tctl->tlv = snd_emu10k1_db_scale1;\n\t\tctl->translation = EMU10K1_GPR_TRANSLATION_NEG_TABLE100;\n\t}\n\tctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\n\tctl->gpr[1] = gpr + 1; ctl->value[1] = defval;\n}\n#define snd_emu10k1_init_stereo_control(ctl, name, gpr, defval) \\\n\tsnd_emu10k1_init_stereo_control2(ctl, name, gpr, defval, HR_VAL(defval))\n\nstatic void\nsnd_emu10k1_init_mono_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\n\t\t\t\t    const char *name, int gpr, int defval)\n{\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, name);\n\tctl->vcount = ctl->count = 1;\n\tctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\n\tctl->min = 0;\n\tctl->max = 1;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_ONOFF;\n}\n\nstatic void\nsnd_emu10k1_init_stereo_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\n\t\t\t\t      const char *name, int gpr, int defval)\n{\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, name);\n\tctl->vcount = ctl->count = 2;\n\tctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\n\tctl->gpr[1] = gpr + 1; ctl->value[1] = defval;\n\tctl->min = 0;\n\tctl->max = 1;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_ONOFF;\n}\n\n \nstatic void snd_emu10k1_audigy_dsp_convert_32_to_2x16(\n\t\t\t\tstruct snd_emu10k1_fx8010_code *icode,\n\t\t\t\tu32 *ptr, int tmp, int bit_shifter16,\n\t\t\t\tint reg_in, int reg_out)\n{\n\t\n\t\n\t\n\tA_OP(icode, ptr, iACC3, reg_out + 1, reg_in, A_C_00000000, A_C_00000000);\n\t\n\t\n\tA_OP(icode, ptr, iMACINT1, A_GPR(tmp), A_C_00000000, reg_in, A_GPR(bit_shifter16));\n\t\n\t\n\t\n\tA_OP(icode, ptr, iMAC3, reg_out, A_GPR(tmp), A_GPR(tmp), A_C_80000000);\n}\n\n#define ENUM_GPR(name, size) name, name ## _dummy = name + (size) - 1\n\n \n\nstatic int _snd_emu10k1_audigy_init_efx(struct snd_emu10k1 *emu)\n{\n\tint err, z, nctl;\n\tenum {\n\t\tENUM_GPR(playback, SND_EMU10K1_PLAYBACK_CHANNELS),\n\t\tENUM_GPR(stereo_mix, 2),\n\t\tENUM_GPR(capture, 2),\n\t\tENUM_GPR(bit_shifter16, 1),\n\t\t\n\t\t\n\t\t\n\t\tENUM_GPR(bass_gpr, 2 * 5),  \n\t\tENUM_GPR(treble_gpr, 2 * 5),\n\t\tENUM_GPR(bass_tmp, SND_EMU10K1_PLAYBACK_CHANNELS * 4),  \n\t\tENUM_GPR(treble_tmp, SND_EMU10K1_PLAYBACK_CHANNELS * 4),\n\t\tENUM_GPR(tmp, 3),\n\t\tnum_static_gprs\n\t};\n\tint gpr = num_static_gprs;\n\tu32 ptr, ptr_skip;\n\tstruct snd_emu10k1_fx8010_code *icode = NULL;\n\tstruct snd_emu10k1_fx8010_control_gpr *controls = NULL, *ctl;\n\tu32 *gpr_map;\n\n\terr = -ENOMEM;\n\ticode = kzalloc(sizeof(*icode), GFP_KERNEL);\n\tif (!icode)\n\t\treturn err;\n\n\ticode->gpr_map = kcalloc(512 + 256 + 256 + 2 * 1024,\n\t\t\t\t sizeof(u_int32_t), GFP_KERNEL);\n\tif (!icode->gpr_map)\n\t\tgoto __err_gpr;\n\tcontrols = kcalloc(SND_EMU10K1_GPR_CONTROLS,\n\t\t\t   sizeof(*controls), GFP_KERNEL);\n\tif (!controls)\n\t\tgoto __err_ctrls;\n\n\tgpr_map = icode->gpr_map;\n\n\ticode->tram_data_map = icode->gpr_map + 512;\n\ticode->tram_addr_map = icode->tram_data_map + 256;\n\ticode->code = icode->tram_addr_map + 256;\n\n\t \n\tmemset(icode->gpr_valid, 0xff, 512 / 8);\n\t\t\n\t \n\tmemset(icode->tram_valid, 0xff, 256 / 8);\n\n\tstrcpy(icode->name, \"Audigy DSP code for ALSA\");\n\tptr = 0;\n\tnctl = 0;\n\tgpr_map[bit_shifter16] = 0x00008000;\n\n#if 1\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_FRONT));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_FRONT));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"PCM Front Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+2), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_REAR));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+3), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_REAR));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"PCM Surround Playback Volume\", gpr, 100);\n\tgpr += 2;\n\t\n\t \n\tif (emu->card_capabilities->spk71) {\n\t\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+6), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_SIDE));\n\t\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+7), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_SIDE));\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"PCM Side Playback Volume\", gpr, 100);\n\t\tgpr += 2;\n\t}\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+4), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_CENTER));\n\tsnd_emu10k1_init_mono_control(&controls[nctl++], \"PCM Center Playback Volume\", gpr, 100);\n\tgpr++;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+5), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LFE));\n\tsnd_emu10k1_init_mono_control(&controls[nctl++], \"PCM LFE Playback Volume\", gpr, 100);\n\tgpr++;\n\t\n\t \n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(stereo_mix), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(stereo_mix+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Wave Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(stereo_mix+0), A_GPR(stereo_mix+0), A_GPR(gpr), A_FXBUS(FXBUS_MIDI_LEFT));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(stereo_mix+1), A_GPR(stereo_mix+1), A_GPR(gpr+1), A_FXBUS(FXBUS_MIDI_RIGHT));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Synth Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+0), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"PCM Capture Volume\", gpr, 0);\n\tgpr += 2;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+0), A_GPR(capture+0), A_GPR(gpr), A_FXBUS(FXBUS_MIDI_LEFT));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+1), A_FXBUS(FXBUS_MIDI_RIGHT));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Synth Capture Volume\", gpr, 0);\n\tgpr += 2;\n\n\t\n\t\n\t{ static_assert(stereo_mix == playback + SND_EMU10K1_PLAYBACK_CHANNELS); }\n\tfor (z = 0; z < SND_EMU10K1_PLAYBACK_CHANNELS + 2; z++)\n\t\tA_OP(icode, &ptr, iACC3, A_GPR(playback + z), A_GPR(playback + z), A_GPR(playback + z), A_C_00000000);\n\n\t \n#define A_ADD_VOLUME_IN(var,vol,input) \\\n\tA_OP(icode, &ptr, iMAC1, A_GPR(var), A_GPR(var), A_GPR(vol), A_EXTIN(input))\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t \n\t\t\n\t\tif (emu->card_capabilities->ca0108_chip) {\n\t\t\t\n\t\t\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+0), A_GPR(capture+0), A3_EMU32IN(0x0), A_GPR(gpr));\n\t\t\t\n\t\t\t\n\t\t\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+2), A_GPR(gpr+1));\n\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(gpr+2), A3_EMU32IN(0x1), A_C_00000000, A_C_00000000);\n\t\t} else {\n\t\t\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+0), A_GPR(capture+0), A_P16VIN(0x0), A_GPR(gpr));\n\t\t\t\n\t\t\t\n\t\t\tA_OP(icode, &ptr, iMAC1, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+2), A_GPR(gpr+1));\n\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(gpr+2), A_P16VIN(0x1), A_C_00000000, A_C_00000000);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"EMU Capture Volume\", gpr, 0);\n\t\tgpr_map[gpr + 2] = 0x00000000;\n\t\tgpr += 3;\n\t} else {\n\t\tif (emu->card_capabilities->ac97_chip) {\n\t\t\t \n\t\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_AC97_L);\n\t\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_AC97_R);\n\t\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"AMic Playback Volume\", gpr, 0);\n\t\t\tgpr += 2;\n\t\t\t \n\t\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_AC97_L);\n\t\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_AC97_R);\n\t\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Mic Capture Volume\", gpr, 0);\n\t\t\tgpr += 2;\n\n\t\t\t \n\t\t\tA_OP(icode, &ptr, iINTERP, A_EXTOUT(A_EXTOUT_MIC_CAP), A_EXTIN(A_EXTIN_AC97_L), A_C_40000000, A_EXTIN(A_EXTIN_AC97_R));\n\t\t}\n\n\t\t \n\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_SPDIF_CD_L);\n\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_SPDIF_CD_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Audigy CD Playback Volume\" : \"CD Playback Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\t\t \n\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_SPDIF_CD_L);\n\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_SPDIF_CD_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Audigy CD Capture Volume\" : \"CD Capture Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\n\t\t \n\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_OPT_SPDIF_L);\n\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_OPT_SPDIF_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], SNDRV_CTL_NAME_IEC958(\"Optical \",PLAYBACK,VOLUME), gpr, 0);\n\t\tgpr += 2;\n\t\t \n\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_OPT_SPDIF_L);\n\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_OPT_SPDIF_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], SNDRV_CTL_NAME_IEC958(\"Optical \",CAPTURE,VOLUME), gpr, 0);\n\t\tgpr += 2;\n\n\t\t \n\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_LINE2_L);\n\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_LINE2_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Line2 Playback Volume\" : \"Line Playback Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\t\t \n\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_LINE2_L);\n\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_LINE2_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Line2 Capture Volume\" : \"Line Capture Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\n\t\t \n\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_ADC_L);\n\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_ADC_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Analog Mix Playback Volume\", gpr, 0);\n\t\tgpr += 2;\n\t\t \n\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_ADC_L);\n\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_ADC_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Analog Mix Capture Volume\", gpr, 0);\n\t\tgpr += 2;\n\n\t\t \n\t\tA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_AUX2_L);\n\t\tA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_AUX2_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Aux2 Playback Volume\" : \"Aux Playback Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\t\t \n\t\tA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_AUX2_L);\n\t\tA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_AUX2_R);\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++],\n\t\t\t\t\t\temu->card_capabilities->ac97_chip ? \"Aux2 Capture Volume\" : \"Aux Capture Volume\",\n\t\t\t\t\t\tgpr, 0);\n\t\tgpr += 2;\n\t}\n\t\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback), A_GPR(playback), A_GPR(gpr), A_GPR(stereo_mix));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+1), A_GPR(playback+1), A_GPR(gpr+1), A_GPR(stereo_mix+1));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Front Playback Volume\", gpr, 100);\n\tgpr += 2;\n\t\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+2), A_GPR(playback+2), A_GPR(gpr), A_GPR(stereo_mix));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+3), A_GPR(playback+3), A_GPR(gpr+1), A_GPR(stereo_mix+1));\n\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Surround Playback Volume\", gpr, 0);\n\tgpr += 2;\n\n\t \n\t \n\tA_OP(icode, &ptr, iINTERP, A_GPR(tmp), A_GPR(stereo_mix), A_C_40000000, A_GPR(stereo_mix+1));\n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+4), A_GPR(playback+4), A_GPR(gpr), A_GPR(tmp));\n\tsnd_emu10k1_init_mono_control(&controls[nctl++], \"Center Playback Volume\", gpr, 0);\n\tgpr++;\n\n\t \n\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+5), A_GPR(playback+5), A_GPR(gpr), A_GPR(tmp));\n\tsnd_emu10k1_init_mono_control(&controls[nctl++], \"LFE Playback Volume\", gpr, 0);\n\tgpr++;\n\t\n\tif (emu->card_capabilities->spk71) {\n\t\t \n\t\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+6), A_GPR(playback+6), A_GPR(gpr), A_GPR(stereo_mix));\n\t\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+7), A_GPR(playback+7), A_GPR(gpr+1), A_GPR(stereo_mix+1));\n\t\tsnd_emu10k1_init_stereo_control(&controls[nctl++], \"Side Playback Volume\", gpr, 0);\n\t\tgpr += 2;\n\t}\n\n\t \n#define A_PUT_OUTPUT(out,src) A_OP(icode, &ptr, iACC3, A_EXTOUT(out), A_C_00000000, A_C_00000000, A_GPR(src))\n#define A_PUT_STEREO_OUTPUT(out1,out2,src) \\\n\t{A_PUT_OUTPUT(out1,src); A_PUT_OUTPUT(out2,src+1);}\n\n#define _A_SWITCH(icode, ptr, dst, src, sw) \\\n\tA_OP((icode), ptr, iMACINT0, dst, A_C_00000000, src, sw);\n#define A_SWITCH(icode, ptr, dst, src, sw) \\\n\t\t_A_SWITCH(icode, ptr, A_GPR(dst), A_GPR(src), A_GPR(sw))\n#define _A_SWITCH_NEG(icode, ptr, dst, src) \\\n\tA_OP((icode), ptr, iANDXOR, dst, src, A_C_00000001, A_C_00000001);\n#define A_SWITCH_NEG(icode, ptr, dst, src) \\\n\t\t_A_SWITCH_NEG(icode, ptr, A_GPR(dst), A_GPR(src))\n\n\n\t \n\tctl = &controls[nctl + 0];\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, \"Tone Control - Bass\");\n\tctl->vcount = 2;\n\tctl->count = 10;\n\tctl->min = 0;\n\tctl->max = 40;\n\tctl->value[0] = ctl->value[1] = 20;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_BASS;\n\tctl = &controls[nctl + 1];\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, \"Tone Control - Treble\");\n\tctl->vcount = 2;\n\tctl->count = 10;\n\tctl->min = 0;\n\tctl->max = 40;\n\tctl->value[0] = ctl->value[1] = 20;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_TREBLE;\n\tfor (z = 0; z < 5; z++) {\n\t\tint j;\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tcontrols[nctl + 0].gpr[z * 2 + j] = bass_gpr + z * 2 + j;\n\t\t\tcontrols[nctl + 1].gpr[z * 2 + j] = treble_gpr + z * 2 + j;\n\t\t}\n\t}\n\tnctl += 2;\n\n\tA_OP(icode, &ptr, iACC3, A_C_00000000, A_GPR(gpr), A_C_00000000, A_C_00000000);\n\tsnd_emu10k1_init_mono_onoff_control(controls + nctl++, \"Tone Control - Switch\", gpr, 0);\n\tgpr++;\n\tA_OP(icode, &ptr, iSKIP, A_GPR_COND, A_GPR_COND, A_CC_REG_ZERO, A_GPR(gpr));\n\tptr_skip = ptr;\n\tfor (z = 0; z < 4; z++) {\t\t \n\t\tint j, k, l, d;\n\t\tfor (j = 0; j < 2; j++) {\t \n\t\t\tk = bass_tmp + (z * 8) + (j * 4);\n\t\t\tl = treble_tmp + (z * 8) + (j * 4);\n\t\t\td = playback + z * 2 + j;\n\n\t\t\tA_OP(icode, &ptr, iMAC0, A_C_00000000, A_C_00000000, A_GPR(d), A_GPR(bass_gpr + 0 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(k+1), A_GPR(k), A_GPR(k+1), A_GPR(bass_gpr + 4 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(k), A_GPR(d), A_GPR(k), A_GPR(bass_gpr + 2 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(k+3), A_GPR(k+2), A_GPR(k+3), A_GPR(bass_gpr + 8 + j));\n\t\t\tA_OP(icode, &ptr, iMAC0, A_GPR(k+2), A_GPR_ACCU, A_GPR(k+2), A_GPR(bass_gpr + 6 + j));\n\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(k+2), A_GPR(k+2), A_GPR(k+2), A_C_00000000);\n\n\t\t\tA_OP(icode, &ptr, iMAC0, A_C_00000000, A_C_00000000, A_GPR(k+2), A_GPR(treble_gpr + 0 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(l+1), A_GPR(l), A_GPR(l+1), A_GPR(treble_gpr + 4 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(l), A_GPR(k+2), A_GPR(l), A_GPR(treble_gpr + 2 + j));\n\t\t\tA_OP(icode, &ptr, iMACMV, A_GPR(l+3), A_GPR(l+2), A_GPR(l+3), A_GPR(treble_gpr + 8 + j));\n\t\t\tA_OP(icode, &ptr, iMAC0, A_GPR(l+2), A_GPR_ACCU, A_GPR(l+2), A_GPR(treble_gpr + 6 + j));\n\t\t\tA_OP(icode, &ptr, iMACINT0, A_GPR(l+2), A_C_00000000, A_GPR(l+2), A_C_00000010);\n\n\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(d), A_GPR(l+2), A_C_00000000, A_C_00000000);\n\n\t\t\tif (z == 2)\t \n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgpr_map[gpr++] = ptr - ptr_skip;\n\n\t \n\tfor (z = 0; z < 8; z++)\n\t\tA_OP(icode, &ptr, iMAC1, A_GPR(playback+z), A_C_00000000, A_GPR(gpr), A_GPR(playback+z));\n\tsnd_emu10k1_init_mono_control(&controls[nctl++], \"Wave Master Playback Volume\", gpr, 0);\n\tgpr++;\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t \n\t\tdev_info(emu->card->dev, \"EMU outputs on\\n\");\n\t\tfor (z = 0; z < 8; z++) {\n\t\t\tif (emu->card_capabilities->ca0108_chip) {\n\t\t\t\tA_OP(icode, &ptr, iACC3, A3_EMU32OUT(z), A_GPR(playback + z), A_C_00000000, A_C_00000000);\n\t\t\t} else {\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_EMU32OUTL(z), A_GPR(playback + z), A_C_00000000, A_C_00000000);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tA_PUT_STEREO_OUTPUT(A_EXTOUT_AFRONT_L, A_EXTOUT_AFRONT_R, playback);\n\t\tA_PUT_STEREO_OUTPUT(A_EXTOUT_AREAR_L, A_EXTOUT_AREAR_R, playback+2);\n\t\tA_PUT_OUTPUT(A_EXTOUT_ACENTER, playback+4);\n\t\tA_PUT_OUTPUT(A_EXTOUT_ALFE, playback+5);\n\t\tif (emu->card_capabilities->spk71)\n\t\t\tA_PUT_STEREO_OUTPUT(A_EXTOUT_ASIDE_L, A_EXTOUT_ASIDE_R, playback+6);\n\n\t\t \n\t\tA_PUT_STEREO_OUTPUT(A_EXTOUT_HEADPHONE_L, A_EXTOUT_HEADPHONE_R, playback);\n\n\t\t \n\t\tgpr_map[gpr++] = 0;\n\t\tgpr_map[gpr++] = 0x1008;\n\t\tgpr_map[gpr++] = 0xffff0000;\n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tA_OP(icode, &ptr, iMAC0, A_GPR(tmp + 2), A_FXBUS(FXBUS_PT_LEFT + z), A_C_00000000, A_C_00000000);\n\t\t\tA_OP(icode, &ptr, iSKIP, A_GPR_COND, A_GPR_COND, A_GPR(gpr - 2), A_C_00000001);\n\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(tmp + 2), A_C_00000000, A_C_00010000, A_GPR(tmp + 2));\n\t\t\tA_OP(icode, &ptr, iANDXOR, A_GPR(tmp + 2), A_GPR(tmp + 2), A_GPR(gpr - 1), A_C_00000000);\n\t\t\tA_SWITCH(icode, &ptr, tmp + 0, tmp + 2, gpr + z);\n\t\t\tA_SWITCH_NEG(icode, &ptr, tmp + 1, gpr + z);\n\t\t\tA_SWITCH(icode, &ptr, tmp + 1, playback + z, tmp + 1);\n\t\t\tif ((z==1) && (emu->card_capabilities->spdif_bug)) {\n\t\t\t\t \n\t\t\t\tdev_info(emu->card->dev,\n\t\t\t\t\t \"Installing spdif_bug patch: %s\\n\",\n\t\t\t\t\t emu->card_capabilities->name);\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_EXTOUT(A_EXTOUT_FRONT_L + z), A_GPR(gpr - 3), A_C_00000000, A_C_00000000);\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(gpr - 3), A_GPR(tmp + 0), A_GPR(tmp + 1), A_C_00000000);\n\t\t\t} else {\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_EXTOUT(A_EXTOUT_FRONT_L + z), A_GPR(tmp + 0), A_GPR(tmp + 1), A_C_00000000);\n\t\t\t}\n\t\t}\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + nctl++, SNDRV_CTL_NAME_IEC958(\"Optical Raw \",PLAYBACK,SWITCH), gpr, 0);\n\t\tgpr += 2;\n\n\t\tA_PUT_STEREO_OUTPUT(A_EXTOUT_REAR_L, A_EXTOUT_REAR_R, playback+2);\n\t\tA_PUT_OUTPUT(A_EXTOUT_CENTER, playback+4);\n\t\tA_PUT_OUTPUT(A_EXTOUT_LFE, playback+5);\n\t}\n\n\t \n#ifdef EMU10K1_CAPTURE_DIGITAL_OUT\n\tA_PUT_STEREO_OUTPUT(A_EXTOUT_ADC_CAP_L, A_EXTOUT_ADC_CAP_R, playback);\n#else\n\tA_PUT_OUTPUT(A_EXTOUT_ADC_CAP_L, capture);\n\tA_PUT_OUTPUT(A_EXTOUT_ADC_CAP_R, capture+1);\n#endif\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t \n\t\tif (emu->card_capabilities->ca0108_chip) {\n\t\t\tdev_info(emu->card->dev, \"EMU2 inputs on\\n\");\n\t\t\t \n\n\t\t\tsnd_emu10k1_audigy_dsp_convert_32_to_2x16(\n\t\t\t\ticode, &ptr, tmp, bit_shifter16, A3_EMU32IN(0), A_FXBUS2(0));\n\t\t\t \n\t\t\t \n\t\t\tfor (z = 1; z < 0x10; z++) {\n\t\t\t\tsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, \n\t\t\t\t\t\t\t\t\tbit_shifter16,\n\t\t\t\t\t\t\t\t\tA_GPR(gpr),\n\t\t\t\t\t\t\t\t\tA_FXBUS2(z*2) );\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(gpr), A3_EMU32IN(z), A_C_00000000, A_C_00000000);\n\t\t\t\tgpr_map[gpr++] = 0x00000000;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(emu->card->dev, \"EMU inputs on\\n\");\n\t\t\t \n\n\t\t\t \n\t\t\tsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_P16VIN(0x0), A_FXBUS2(0) );\n\t\t\t \n\t\t\tfor (z = 1; z < 0x10; z++) {\n\t\t\t\tsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr), A_FXBUS2(z * 2) );\n\t\t\t\tA_OP(icode, &ptr, iACC3, A_GPR(gpr), A_P16VIN(z), A_C_00000000, A_C_00000000);\n\t\t\t\tgpr_map[gpr++] = 0x00000000;\n\t\t\t}\n\t\t}\n\n#if 0\n\t\tfor (z = 4; z < 8; z++) {\n\t\t\tA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);\n\t\t}\n\t\tfor (z = 0xc; z < 0x10; z++) {\n\t\t\tA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);\n\t\t}\n#endif\n\t} else {\n\t\t \n\t\t \n\t\tfor (z = 0; z < 16; z++) {\n\t\t\tA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_EXTIN(z));\n\t\t}\n\t}\n\t\n#endif  \n\t \n\n\tif (gpr > 512) {\n\t\tsnd_BUG();\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\n\t \n\twhile (ptr < 0x400)\n\t\tA_OP(icode, &ptr, 0x0f, 0xc0, 0xc0, 0xcf, 0xc0);\n\n\ticode->gpr_add_control_count = nctl;\n\ticode->gpr_add_controls = controls;\n\temu->support_tlv = 1;  \n\terr = snd_emu10k1_icode_poke(emu, icode, true);\n\temu->support_tlv = 0;  \n\n__err:\n\tkfree(controls);\n__err_ctrls:\n\tkfree(icode->gpr_map);\n__err_gpr:\n\tkfree(icode);\n\treturn err;\n}\n\n\n \n\n \nstatic void _volume(struct snd_emu10k1_fx8010_code *icode, u32 *ptr, u32 dst, u32 src, u32 vol)\n{\n\tOP(icode, ptr, iMAC1, dst, C_00000000, src, vol);\n}\nstatic void _volume_add(struct snd_emu10k1_fx8010_code *icode, u32 *ptr, u32 dst, u32 src, u32 vol)\n{\n\tOP(icode, ptr, iMAC1, dst, dst, src, vol);\n}\n\n#define VOLUME(icode, ptr, dst, src, vol) \\\n\t\t_volume(icode, ptr, GPR(dst), GPR(src), GPR(vol))\n#define VOLUME_IN(icode, ptr, dst, src, vol) \\\n\t\t_volume(icode, ptr, GPR(dst), EXTIN(src), GPR(vol))\n#define VOLUME_ADD(icode, ptr, dst, src, vol) \\\n\t\t_volume_add(icode, ptr, GPR(dst), GPR(src), GPR(vol))\n#define VOLUME_ADDIN(icode, ptr, dst, src, vol) \\\n\t\t_volume_add(icode, ptr, GPR(dst), EXTIN(src), GPR(vol))\n#define VOLUME_OUT(icode, ptr, dst, src, vol) \\\n\t\t_volume(icode, ptr, EXTOUT(dst), GPR(src), GPR(vol))\n#define _SWITCH(icode, ptr, dst, src, sw) \\\n\tOP((icode), ptr, iMACINT0, dst, C_00000000, src, sw);\n#define SWITCH(icode, ptr, dst, src, sw) \\\n\t\t_SWITCH(icode, ptr, GPR(dst), GPR(src), GPR(sw))\n#define SWITCH_IN(icode, ptr, dst, src, sw) \\\n\t\t_SWITCH(icode, ptr, GPR(dst), EXTIN(src), GPR(sw))\n#define _SWITCH_NEG(icode, ptr, dst, src) \\\n\tOP((icode), ptr, iANDXOR, dst, src, C_00000001, C_00000001);\n#define SWITCH_NEG(icode, ptr, dst, src) \\\n\t\t_SWITCH_NEG(icode, ptr, GPR(dst), GPR(src))\n\n\nstatic int _snd_emu10k1_init_efx(struct snd_emu10k1 *emu)\n{\n\tint err, i, z, gpr, tmp, playback, capture;\n\tu32 ptr, ptr_skip;\n\tstruct snd_emu10k1_fx8010_code *icode;\n\tstruct snd_emu10k1_fx8010_pcm_rec *ipcm = NULL;\n\tstruct snd_emu10k1_fx8010_control_gpr *controls = NULL, *ctl;\n\tu32 *gpr_map;\n\n\terr = -ENOMEM;\n\ticode = kzalloc(sizeof(*icode), GFP_KERNEL);\n\tif (!icode)\n\t\treturn err;\n\n\ticode->gpr_map = kcalloc(256 + 160 + 160 + 2 * 512,\n\t\t\t\t sizeof(u_int32_t), GFP_KERNEL);\n\tif (!icode->gpr_map)\n\t\tgoto __err_gpr;\n\n\tcontrols = kcalloc(SND_EMU10K1_GPR_CONTROLS,\n\t\t\t   sizeof(struct snd_emu10k1_fx8010_control_gpr),\n\t\t\t   GFP_KERNEL);\n\tif (!controls)\n\t\tgoto __err_ctrls;\n\n\tipcm = kzalloc(sizeof(*ipcm), GFP_KERNEL);\n\tif (!ipcm)\n\t\tgoto __err_ipcm;\n\n\tgpr_map = icode->gpr_map;\n\n\ticode->tram_data_map = icode->gpr_map + 256;\n\ticode->tram_addr_map = icode->tram_data_map + 160;\n\ticode->code = icode->tram_addr_map + 160;\n\t\n\t \n\tmemset(icode->gpr_valid, 0xff, 256 / 8);\n\n\t \n\tmemset(icode->tram_valid, 0xff, 160 / 8);\n\n\tstrcpy(icode->name, \"SB Live! FX8010 code for ALSA v1.2 by Jaroslav Kysela\");\n\tptr = 0; i = 0;\n\t \n\tplayback = SND_EMU10K1_INPUTS;\n\t \n\tcapture = playback + SND_EMU10K1_PLAYBACK_CHANNELS;\n\tgpr = capture + SND_EMU10K1_CAPTURE_CHANNELS;\n\ttmp = 0x88;\t \n\t \n\n\t \n\tOP(icode, &ptr, iMACINT0, GPR(0), C_00000000, FXBUS(FXBUS_PCM_LEFT), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(1), C_00000000, FXBUS(FXBUS_PCM_RIGHT), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(2), C_00000000, FXBUS(FXBUS_MIDI_LEFT), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(3), C_00000000, FXBUS(FXBUS_MIDI_RIGHT), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(4), C_00000000, FXBUS(FXBUS_PCM_LEFT_REAR), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(5), C_00000000, FXBUS(FXBUS_PCM_RIGHT_REAR), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(6), C_00000000, FXBUS(FXBUS_PCM_CENTER), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(7), C_00000000, FXBUS(FXBUS_PCM_LFE), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(8), C_00000000, C_00000000, C_00000000);\t \n\tOP(icode, &ptr, iMACINT0, GPR(9), C_00000000, C_00000000, C_00000000);\t \n\tOP(icode, &ptr, iMACINT0, GPR(10), C_00000000, FXBUS(FXBUS_PCM_LEFT_FRONT), C_00000008);\n\tOP(icode, &ptr, iMACINT0, GPR(11), C_00000000, FXBUS(FXBUS_PCM_RIGHT_FRONT), C_00000008);\n\n\t \n\tipcm->substream = 0;\n\tipcm->channels = 2;\n\tipcm->tram_start = 0;\n\tipcm->buffer_size = (64 * 1024) / 2;\n\tipcm->gpr_size = gpr++;\n\tipcm->gpr_ptr = gpr++;\n\tipcm->gpr_count = gpr++;\n\tipcm->gpr_tmpcount = gpr++;\n\tipcm->gpr_trigger = gpr++;\n\tipcm->gpr_running = gpr++;\n\tipcm->etram[0] = 0;\n\tipcm->etram[1] = 1;\n\n\tgpr_map[gpr + 0] = 0xfffff000;\n\tgpr_map[gpr + 1] = 0xffff0000;\n\tgpr_map[gpr + 2] = 0x70000000;\n\tgpr_map[gpr + 3] = 0x00000007;\n\tgpr_map[gpr + 4] = 0x001f << 11;\n\tgpr_map[gpr + 5] = 0x001c << 11;\n\tgpr_map[gpr + 6] = (0x22  - 0x01) - 1;\t \n\tgpr_map[gpr + 7] = (0x22  - 0x06) - 1;\t \n\tgpr_map[gpr + 8] = 0x2000000 + (2<<11);\n\tgpr_map[gpr + 9] = 0x4000000 + (2<<11);\n\tgpr_map[gpr + 10] = 1<<11;\n\tgpr_map[gpr + 11] = (0x24 - 0x0a) - 1;\t \n\tgpr_map[gpr + 12] = 0;\n\n\t \n\t  OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_trigger), C_00000000, C_00000000);\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_ZERO, GPR(gpr + 6));\n\t \n\t  OP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_running), C_00000000, C_00000000);\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000004);\n\t \n\t  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), GPR_DBAC, GPR(gpr + 4), C_00000000);\n\t  OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(gpr + 5));\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 7));\n\t  OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000010, C_00000001, C_00000000);\n\n\t  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000000, C_00000001);\n\t  OP(icode, &ptr, iACC3, GPR(gpr + 12), GPR(gpr + 12), C_ffffffff, C_00000000);\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 11));\n\t  OP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000001, C_00000000, C_00000000);\n\n\t  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[0]), GPR(gpr + 0), C_00000000);\n\t  OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);\n\t  OP(icode, &ptr, iANDXOR, GPR(8), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));\n\t  OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);\n\t  OP(icode, &ptr, iANDXOR, GPR(8), GPR(8), GPR(gpr + 1), GPR(gpr + 2));\n\n\t  OP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[1]), GPR(gpr + 0), C_00000000);\n\t  OP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);\n\t  OP(icode, &ptr, iANDXOR, GPR(9), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));\n\t  OP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);\n\t  OP(icode, &ptr, iANDXOR, GPR(9), GPR(9), GPR(gpr + 1), GPR(gpr + 2));\n\n\t  OP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(ipcm->gpr_ptr), C_00000001, C_00000000);\n\t  OP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(ipcm->gpr_size));\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_MINUS, C_00000001);\n\t  OP(icode, &ptr, iACC3, GPR(tmp + 0), C_00000000, C_00000000, C_00000000);\n\t  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_ptr), GPR(tmp + 0), C_00000000, C_00000000);\n\t\n\t  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_tmpcount), C_ffffffff, C_00000000);\n\t  OP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);\n\t  OP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_count), C_00000000, C_00000000);\n\t  OP(icode, &ptr, iACC3, GPR_IRQ, C_80000000, C_00000000, C_00000000);\n\t  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000001, C_00010000);\n\n\t  OP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00010000, C_00000001);\n\t  OP(icode, &ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000002);\n\n\t  OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[0]), GPR(gpr + 8), GPR_DBAC, C_ffffffff);\n\t  OP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[1]), GPR(gpr + 9), GPR_DBAC, C_ffffffff);\n\n\t \n\tgpr += 13;\n\n\t \n\tfor (z = 0; z < 2; z++)\n\t\tVOLUME(icode, &ptr, playback + z, z, gpr + z);\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Wave Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tfor (z = 0; z < 2; z++)\n\t\tVOLUME(icode, &ptr, playback + 2 + z, z, gpr + z);\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Wave Surround Playback Volume\", gpr, 0);\n\tgpr += 2;\n\t\n\t \n\tOP(icode, &ptr, iACC3, GPR(tmp + 0), FXBUS(FXBUS_PCM_LEFT), FXBUS(FXBUS_PCM_RIGHT), C_00000000);\n\tOP(icode, &ptr, iMACINT0, GPR(tmp + 0), C_00000000, GPR(tmp + 0), C_00000004);\n\tVOLUME(icode, &ptr, playback + 4, tmp + 0, gpr);\n\tsnd_emu10k1_init_mono_control(controls + i++, \"Wave Center Playback Volume\", gpr++, 0);\n\tVOLUME(icode, &ptr, playback + 5, tmp + 0, gpr);\n\tsnd_emu10k1_init_mono_control(controls + i++, \"Wave LFE Playback Volume\", gpr++, 0);\n\n\t \n\tfor (z = 0; z < 2; z++) {\n\t\tSWITCH(icode, &ptr, tmp + 0, z, gpr + 2 + z);\n\t\tVOLUME(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t}\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Wave Capture Volume\", gpr, 0);\n\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Wave Capture Switch\", gpr + 2, 0);\n\tgpr += 4;\n\n\t \n\tfor (z = 0; z < 2; z++)\n\t\tVOLUME_ADD(icode, &ptr, playback + z, 2 + z, gpr + z);\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Synth Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tfor (z = 0; z < 2; z++) {\n\t\tSWITCH(icode, &ptr, tmp + 0, 2 + z, gpr + 2 + z);\n\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t}\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Synth Capture Volume\", gpr, 0);\n\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Synth Capture Switch\", gpr + 2, 0);\n\tgpr += 4;\n\n\t \n\tfor (z = 0; z < 2; z++)\n\t\tVOLUME_ADD(icode, &ptr, playback + 2 + z, 4 + z, gpr + z);\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Surround Digital Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tfor (z = 0; z < 2; z++) {\n\t\tSWITCH(icode, &ptr, tmp + 0, 4 + z, gpr + 2 + z);\n\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t}\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Surround Capture Volume\", gpr, 0);\n\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Surround Capture Switch\", gpr + 2, 0);\n\tgpr += 4;\n\n\t \n\tVOLUME_ADD(icode, &ptr, playback + 4, 6, gpr);\n\tsnd_emu10k1_init_mono_control(controls + i++, \"Center Digital Playback Volume\", gpr++, 100);\n\n\t \n\tVOLUME_ADD(icode, &ptr, playback + 5, 7, gpr);\n\tsnd_emu10k1_init_mono_control(controls + i++, \"LFE Digital Playback Volume\", gpr++, 100);\n\n\t \n\tfor (z = 0; z < 2; z++)\n\t\tVOLUME_ADD(icode, &ptr, playback + z, 10 + z, gpr + z);\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Front Playback Volume\", gpr, 100);\n\tgpr += 2;\n\n\t \n\tfor (z = 0; z < 2; z++) {\n\t\tSWITCH(icode, &ptr, tmp + 0, 10 + z, gpr + 2);\n\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t}\n\tsnd_emu10k1_init_stereo_control(controls + i++, \"Front Capture Volume\", gpr, 0);\n\tsnd_emu10k1_init_mono_onoff_control(controls + i++, \"Front Capture Switch\", gpr + 2, 0);\n\tgpr += 3;\n\n\t \n\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_AC97_L)|(1<<EXTIN_AC97_R))) {\n\t\t \n\t\tVOLUME_ADDIN(icode, &ptr, playback + 0, EXTIN_AC97_L, gpr); gpr++;\n\t\tVOLUME_ADDIN(icode, &ptr, playback + 1, EXTIN_AC97_R, gpr); gpr++;\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"AC97 Playback Volume\", gpr-2, 0);\n\t\t \n\t\tVOLUME_ADDIN(icode, &ptr, capture + 0, EXTIN_AC97_L, gpr); gpr++;\n\t\tVOLUME_ADDIN(icode, &ptr, capture + 1, EXTIN_AC97_R, gpr); gpr++;\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"AC97 Capture Volume\", gpr-2, 100);\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_SPDIF_CD_L)|(1<<EXTIN_SPDIF_CD_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_SPDIF_CD_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"TTL \",PLAYBACK,VOLUME), gpr, 0);\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_SPDIF_CD_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"TTL \",CAPTURE,VOLUME), gpr, 0);\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"TTL \",CAPTURE,SWITCH), gpr + 2, 0);\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_ZOOM_L)|(1<<EXTIN_ZOOM_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_ZOOM_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Zoom Video Playback Volume\", gpr, 0);\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_ZOOM_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Zoom Video Capture Volume\", gpr, 0);\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Zoom Video Capture Switch\", gpr + 2, 0);\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_TOSLINK_L)|(1<<EXTIN_TOSLINK_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_TOSLINK_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"LiveDrive \",PLAYBACK,VOLUME), gpr, 0);\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_TOSLINK_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"LiveDrive \",CAPTURE,VOLUME), gpr, 0);\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"LiveDrive \",CAPTURE,SWITCH), gpr + 2, 0);\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_LINE1_L)|(1<<EXTIN_LINE1_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_LINE1_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Line LiveDrive Playback Volume\", gpr, 0);\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_LINE1_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Line LiveDrive Capture Volume\", gpr, 0);\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Line LiveDrive Capture Switch\", gpr + 2, 0);\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_COAX_SPDIF_L)|(1<<EXTIN_COAX_SPDIF_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_COAX_SPDIF_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"Coaxial \",PLAYBACK,VOLUME), gpr, 0);\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_COAX_SPDIF_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"Coaxial \",CAPTURE,VOLUME), gpr, 0);\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"Coaxial \",CAPTURE,SWITCH), gpr + 2, 0);\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extin_mask & ((1<<EXTIN_LINE2_L)|(1<<EXTIN_LINE2_R))) {\n\t\t \n\t\tfor (z = 0; z < 2; z++)\n\t\t\tVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_LINE2_L + z, gpr + z);\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Line2 LiveDrive Playback Volume\", gpr, 0);\n\t\tcontrols[i-1].id.index = 1;\n\t\tgpr += 2;\n\t\n\t\t \n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_LINE2_L + z, gpr + 2 + z);\n\t\t\tVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\n\t\t}\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Line2 LiveDrive Capture Volume\", gpr, 0);\n\t\tcontrols[i-1].id.index = 1;\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, \"Line2 LiveDrive Capture Switch\", gpr + 2, 0);\n\t\tcontrols[i-1].id.index = 1;\n\t\tgpr += 4;\n\t}\n\n\t \n\tctl = &controls[i + 0];\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, \"Tone Control - Bass\");\n\tctl->vcount = 2;\n\tctl->count = 10;\n\tctl->min = 0;\n\tctl->max = 40;\n\tctl->value[0] = ctl->value[1] = 20;\n\tctl->tlv = snd_emu10k1_bass_treble_db_scale;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_BASS;\n\tctl = &controls[i + 1];\n\tctl->id.iface = (__force int)SNDRV_CTL_ELEM_IFACE_MIXER;\n\tstrcpy(ctl->id.name, \"Tone Control - Treble\");\n\tctl->vcount = 2;\n\tctl->count = 10;\n\tctl->min = 0;\n\tctl->max = 40;\n\tctl->value[0] = ctl->value[1] = 20;\n\tctl->tlv = snd_emu10k1_bass_treble_db_scale;\n\tctl->translation = EMU10K1_GPR_TRANSLATION_TREBLE;\n\n#define BASS_GPR\t0x8c\n#define TREBLE_GPR\t0x96\n\n\tfor (z = 0; z < 5; z++) {\n\t\tint j;\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tcontrols[i + 0].gpr[z * 2 + j] = BASS_GPR + z * 2 + j;\n\t\t\tcontrols[i + 1].gpr[z * 2 + j] = TREBLE_GPR + z * 2 + j;\n\t\t}\n\t}\n\ti += 2;\n\n\tOP(icode, &ptr, iACC3, C_00000000, GPR(gpr), C_00000000, C_00000000);\n\tsnd_emu10k1_init_mono_onoff_control(controls + i++, \"Tone Control - Switch\", gpr, 0);\n\tgpr++;\n\tOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_ZERO, GPR(gpr));\n\tptr_skip = ptr;\n\tfor (z = 0; z < 3; z++) {\t\t \n\t\tint j, k, l, d;\n\t\tfor (j = 0; j < 2; j++) {\t \n\t\t\tk = 0xa0 + (z * 8) + (j * 4);\n\t\t\tl = 0xd0 + (z * 8) + (j * 4);\n\t\t\td = playback + z * 2 + j;\n\n\t\t\tOP(icode, &ptr, iMAC0, C_00000000, C_00000000, GPR(d), GPR(BASS_GPR + 0 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(k+1), GPR(k), GPR(k+1), GPR(BASS_GPR + 4 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(k), GPR(d), GPR(k), GPR(BASS_GPR + 2 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(k+3), GPR(k+2), GPR(k+3), GPR(BASS_GPR + 8 + j));\n\t\t\tOP(icode, &ptr, iMAC0, GPR(k+2), GPR_ACCU, GPR(k+2), GPR(BASS_GPR + 6 + j));\n\t\t\tOP(icode, &ptr, iACC3, GPR(k+2), GPR(k+2), GPR(k+2), C_00000000);\n\n\t\t\tOP(icode, &ptr, iMAC0, C_00000000, C_00000000, GPR(k+2), GPR(TREBLE_GPR + 0 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(l+1), GPR(l), GPR(l+1), GPR(TREBLE_GPR + 4 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(l), GPR(k+2), GPR(l), GPR(TREBLE_GPR + 2 + j));\n\t\t\tOP(icode, &ptr, iMACMV, GPR(l+3), GPR(l+2), GPR(l+3), GPR(TREBLE_GPR + 8 + j));\n\t\t\tOP(icode, &ptr, iMAC0, GPR(l+2), GPR_ACCU, GPR(l+2), GPR(TREBLE_GPR + 6 + j));\n\t\t\tOP(icode, &ptr, iMACINT0, GPR(l+2), C_00000000, GPR(l+2), C_00000010);\n\n\t\t\tOP(icode, &ptr, iACC3, GPR(d), GPR(l+2), C_00000000, C_00000000);\n\n\t\t\tif (z == 2)\t \n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgpr_map[gpr++] = ptr - ptr_skip;\n\n#undef BASS_GPR\n#undef TREBLE_GPR\n\n\t \n\tif (emu->fx8010.extout_mask & ((1<<EXTOUT_AC97_L)|(1<<EXTOUT_AC97_R))) {\n\t\t \n\n\t\tfor (z = 0; z < 2; z++)\n\t\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_L + z), GPR(playback + z), C_00000000, C_00000000);\n\t}\n\n\tif (emu->fx8010.extout_mask & ((1<<EXTOUT_TOSLINK_L)|(1<<EXTOUT_TOSLINK_R))) {\n\t\t \n\n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH(icode, &ptr, tmp + 0, 8 + z, gpr + z);\n\t\t\tSWITCH_NEG(icode, &ptr, tmp + 1, gpr + z);\n\t\t\tSWITCH(icode, &ptr, tmp + 1, playback + z, tmp + 1);\n\t\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_TOSLINK_L + z), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\n#ifdef EMU10K1_CAPTURE_DIGITAL_OUT\n\t \t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ADC_CAP_L + z), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\n#endif\n\t\t}\n\n\t\tsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958(\"Optical Raw \",PLAYBACK,SWITCH), gpr, 0);\n\t\tgpr += 2;\n\t}\n\n\tif (emu->fx8010.extout_mask & ((1<<EXTOUT_HEADPHONE_L)|(1<<EXTOUT_HEADPHONE_R))) {\n\t\t \n\n\t\tfor (z = 0; z < 2; z++) {\n\t\t\tSWITCH(icode, &ptr, tmp + 0, playback + 4 + z, gpr + 2 + z);\n\t\t\tSWITCH_NEG(icode, &ptr, tmp + 1, gpr + 2 + z);\n\t\t\tSWITCH(icode, &ptr, tmp + 1, playback + z, tmp + 1);\n\t\t\tOP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\n\t\t\tVOLUME_OUT(icode, &ptr, EXTOUT_HEADPHONE_L + z, tmp + 0, gpr + z);\n\t\t}\n\n\t\tsnd_emu10k1_init_stereo_control(controls + i++, \"Headphone Playback Volume\", gpr + 0, 0);\n\t\tcontrols[i-1].id.index = 1;\t \n\t\tsnd_emu10k1_init_mono_onoff_control(controls + i++, \"Headphone Center Playback Switch\", gpr + 2, 0);\n\t\tcontrols[i-1].id.index = 1;\n\t\tsnd_emu10k1_init_mono_onoff_control(controls + i++, \"Headphone LFE Playback Switch\", gpr + 3, 0);\n\t\tcontrols[i-1].id.index = 1;\n\n\t\tgpr += 4;\n\t}\n\t\n\tif (emu->fx8010.extout_mask & ((1<<EXTOUT_REAR_L)|(1<<EXTOUT_REAR_R)))\n\t\tfor (z = 0; z < 2; z++)\n\t\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_REAR_L + z), GPR(playback + 2 + z), C_00000000, C_00000000);\n\n\tif (emu->fx8010.extout_mask & ((1<<EXTOUT_AC97_REAR_L)|(1<<EXTOUT_AC97_REAR_R)))\n\t\tfor (z = 0; z < 2; z++)\n\t\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_REAR_L + z), GPR(playback + 2 + z), C_00000000, C_00000000);\n\n\tif (emu->fx8010.extout_mask & (1<<EXTOUT_AC97_CENTER)) {\n#ifndef EMU10K1_CENTER_LFE_FROM_FRONT\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_CENTER), GPR(playback + 4), C_00000000, C_00000000);\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ACENTER), GPR(playback + 4), C_00000000, C_00000000);\n#else\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_CENTER), GPR(playback + 0), C_00000000, C_00000000);\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ACENTER), GPR(playback + 0), C_00000000, C_00000000);\n#endif\n\t}\n\n\tif (emu->fx8010.extout_mask & (1<<EXTOUT_AC97_LFE)) {\n#ifndef EMU10K1_CENTER_LFE_FROM_FRONT\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_LFE), GPR(playback + 5), C_00000000, C_00000000);\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ALFE), GPR(playback + 5), C_00000000, C_00000000);\n#else\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_LFE), GPR(playback + 1), C_00000000, C_00000000);\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ALFE), GPR(playback + 1), C_00000000, C_00000000);\n#endif\n\t}\n\t\n#ifndef EMU10K1_CAPTURE_DIGITAL_OUT\n\tfor (z = 0; z < 2; z++)\n \t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ADC_CAP_L + z), GPR(capture + z), C_00000000, C_00000000);\n#endif\n\t\n\tif (emu->fx8010.extout_mask & (1<<EXTOUT_MIC_CAP))\n\t\tOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_MIC_CAP), GPR(capture + 2), C_00000000, C_00000000);\n\n\t \n\tif (emu->card_capabilities->sblive51) {\n\t\tfor (z = 0; z < 16; z++) {\n\t\t\ts8 c = snd_emu10k1_sblive51_fxbus2_map[z];\n\t\t\tif (c != -1)\n\t\t\t\tOP(icode, &ptr, iACC3, FXBUS2(z), C_00000000, C_00000000, EXTIN(c));\n\t\t}\n\t} else {\n\t\tfor (z = 0; z < 16; z++)\n\t\t\tOP(icode, &ptr, iACC3, FXBUS2(z), C_00000000, C_00000000, EXTIN(z));\n\t}\n\t    \n\n\tif (gpr > tmp) {\n\t\tsnd_BUG();\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\tif (i > SND_EMU10K1_GPR_CONTROLS) {\n\t\tsnd_BUG();\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\t\n\t \n\twhile (ptr < 0x200)\n\t\tOP(icode, &ptr, iACC3, C_00000000, C_00000000, C_00000000, C_00000000);\n\n\terr = snd_emu10k1_fx8010_tram_setup(emu, ipcm->buffer_size);\n\tif (err < 0)\n\t\tgoto __err;\n\ticode->gpr_add_control_count = i;\n\ticode->gpr_add_controls = controls;\n\temu->support_tlv = 1;  \n\terr = snd_emu10k1_icode_poke(emu, icode, true);\n\temu->support_tlv = 0;  \n\tif (err >= 0)\n\t\terr = snd_emu10k1_ipcm_poke(emu, ipcm);\n__err:\n\tkfree(ipcm);\n__err_ipcm:\n\tkfree(controls);\n__err_ctrls:\n\tkfree(icode->gpr_map);\n__err_gpr:\n\tkfree(icode);\n\treturn err;\n}\n\nint snd_emu10k1_init_efx(struct snd_emu10k1 *emu)\n{\n\tspin_lock_init(&emu->fx8010.irq_lock);\n\tINIT_LIST_HEAD(&emu->fx8010.gpr_ctl);\n\tif (emu->audigy)\n\t\treturn _snd_emu10k1_audigy_init_efx(emu);\n\telse\n\t\treturn _snd_emu10k1_init_efx(emu);\n}\n\nvoid snd_emu10k1_free_efx(struct snd_emu10k1 *emu)\n{\n\t \n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg = A_DBG_SINGLE_STEP);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg = EMU10K1_DBG_SINGLE_STEP);\n}\n\n#if 0  \nint snd_emu10k1_fx8010_tone_control_activate(struct snd_emu10k1 *emu, int output)\n{\n\tif (output < 0 || output >= 6)\n\t\treturn -EINVAL;\n\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + 0x94 + output, 0, 1);\n\treturn 0;\n}\n\nint snd_emu10k1_fx8010_tone_control_deactivate(struct snd_emu10k1 *emu, int output)\n{\n\tif (output < 0 || output >= 6)\n\t\treturn -EINVAL;\n\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + 0x94 + output, 0, 0);\n\treturn 0;\n}\n#endif\n\nint snd_emu10k1_fx8010_tram_setup(struct snd_emu10k1 *emu, u32 size)\n{\n\tu8 size_reg = 0;\n\n\t \n\tif (size != 0) {\n\t\tsize = (size - 1) >> 13;\n\n\t\twhile (size) {\n\t\t\tsize >>= 1;\n\t\t\tsize_reg++;\n\t\t}\n\t\tsize = 0x2000 << size_reg;\n\t}\n\tif ((emu->fx8010.etram_pages.bytes / 2) == size)\n\t\treturn 0;\n\tspin_lock_irq(&emu->emu_lock);\n\toutl(HCFG_LOCKTANKCACHE_MASK | inl(emu->port + HCFG), emu->port + HCFG);\n\tspin_unlock_irq(&emu->emu_lock);\n\tsnd_emu10k1_ptr_write(emu, TCB, 0, 0);\n\tsnd_emu10k1_ptr_write(emu, TCBS, 0, TCBS_BUFFSIZE_16K);\n\tif (emu->fx8010.etram_pages.area != NULL) {\n\t\tsnd_dma_free_pages(&emu->fx8010.etram_pages);\n\t\temu->fx8010.etram_pages.area = NULL;\n\t\temu->fx8010.etram_pages.bytes = 0;\n\t}\n\n\tif (size > 0) {\n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &emu->pci->dev,\n\t\t\t\t\tsize * 2, &emu->fx8010.etram_pages) < 0)\n\t\t\treturn -ENOMEM;\n\t\tmemset(emu->fx8010.etram_pages.area, 0, size * 2);\n\t\tsnd_emu10k1_ptr_write(emu, TCB, 0, emu->fx8010.etram_pages.addr);\n\t\tsnd_emu10k1_ptr_write(emu, TCBS, 0, size_reg);\n\t\tspin_lock_irq(&emu->emu_lock);\n\t\toutl(inl(emu->port + HCFG) & ~HCFG_LOCKTANKCACHE_MASK, emu->port + HCFG);\n\t\tspin_unlock_irq(&emu->emu_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_emu10k1_fx8010_open(struct snd_hwdep * hw, struct file *file)\n{\n\treturn 0;\n}\n\nstatic void copy_string(char *dst, const char *src, const char *null, int idx)\n{\n\tif (src == NULL)\n\t\tsprintf(dst, \"%s %02X\", null, idx);\n\telse\n\t\tstrcpy(dst, src);\n}\n\nstatic void snd_emu10k1_fx8010_info(struct snd_emu10k1 *emu,\n\t\t\t\t   struct snd_emu10k1_fx8010_info *info)\n{\n\tconst char * const *fxbus, * const *extin, * const *extout;\n\tunsigned short extin_mask, extout_mask;\n\tint res;\n\n\tinfo->internal_tram_size = emu->fx8010.itram_size;\n\tinfo->external_tram_size = emu->fx8010.etram_pages.bytes / 2;\n\tfxbus = snd_emu10k1_fxbus;\n\textin = emu->audigy ? snd_emu10k1_audigy_ins : snd_emu10k1_sblive_ins;\n\textout = emu->audigy ? snd_emu10k1_audigy_outs : snd_emu10k1_sblive_outs;\n\textin_mask = emu->audigy ? ~0 : emu->fx8010.extin_mask;\n\textout_mask = emu->audigy ? ~0 : emu->fx8010.extout_mask;\n\tfor (res = 0; res < 16; res++, fxbus++, extin++, extout++) {\n\t\tcopy_string(info->fxbus_names[res], *fxbus, \"FXBUS\", res);\n\t\tcopy_string(info->extin_names[res], extin_mask & (1 << res) ? *extin : NULL, \"Unused\", res);\n\t\tcopy_string(info->extout_names[res], extout_mask & (1 << res) ? *extout : NULL, \"Unused\", res);\n\t}\n\tfor (res = 16; res < 32; res++, extout++)\n\t\tcopy_string(info->extout_names[res], extout_mask & (1 << res) ? *extout : NULL, \"Unused\", res);\n\tinfo->gpr_controls = emu->fx8010.gpr_count;\n}\n\nstatic int snd_emu10k1_fx8010_ioctl(struct snd_hwdep * hw, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_emu10k1 *emu = hw->private_data;\n\tstruct snd_emu10k1_fx8010_info *info;\n\tstruct snd_emu10k1_fx8010_code *icode;\n\tstruct snd_emu10k1_fx8010_pcm_rec *ipcm;\n\tunsigned int addr;\n\tvoid __user *argp = (void __user *)arg;\n\tint res;\n\t\n\tswitch (cmd) {\n\tcase SNDRV_EMU10K1_IOCTL_PVERSION:\n\t\temu->support_tlv = 1;\n\t\treturn put_user(SNDRV_EMU10K1_VERSION, (int __user *)argp);\n\tcase SNDRV_EMU10K1_IOCTL_INFO:\n\t\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tsnd_emu10k1_fx8010_info(emu, info);\n\t\tif (copy_to_user(argp, info, sizeof(*info))) {\n\t\t\tkfree(info);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(info);\n\t\treturn 0;\n\tcase SNDRV_EMU10K1_IOCTL_CODE_POKE:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\ticode = memdup_user(argp, sizeof(*icode));\n\t\tif (IS_ERR(icode))\n\t\t\treturn PTR_ERR(icode);\n\t\tres = snd_emu10k1_icode_poke(emu, icode, false);\n\t\tkfree(icode);\n\t\treturn res;\n\tcase SNDRV_EMU10K1_IOCTL_CODE_PEEK:\n\t\ticode = memdup_user(argp, sizeof(*icode));\n\t\tif (IS_ERR(icode))\n\t\t\treturn PTR_ERR(icode);\n\t\tres = snd_emu10k1_icode_peek(emu, icode);\n\t\tif (res == 0 && copy_to_user(argp, icode, sizeof(*icode))) {\n\t\t\tkfree(icode);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(icode);\n\t\treturn res;\n\tcase SNDRV_EMU10K1_IOCTL_PCM_POKE:\n\t\tipcm = memdup_user(argp, sizeof(*ipcm));\n\t\tif (IS_ERR(ipcm))\n\t\t\treturn PTR_ERR(ipcm);\n\t\tres = snd_emu10k1_ipcm_poke(emu, ipcm);\n\t\tkfree(ipcm);\n\t\treturn res;\n\tcase SNDRV_EMU10K1_IOCTL_PCM_PEEK:\n\t\tipcm = memdup_user(argp, sizeof(*ipcm));\n\t\tif (IS_ERR(ipcm))\n\t\t\treturn PTR_ERR(ipcm);\n\t\tres = snd_emu10k1_ipcm_peek(emu, ipcm);\n\t\tif (res == 0 && copy_to_user(argp, ipcm, sizeof(*ipcm))) {\n\t\t\tkfree(ipcm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(ipcm);\n\t\treturn res;\n\tcase SNDRV_EMU10K1_IOCTL_TRAM_SETUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(addr, (unsigned int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tmutex_lock(&emu->fx8010.lock);\n\t\tres = snd_emu10k1_fx8010_tram_setup(emu, addr);\n\t\tmutex_unlock(&emu->fx8010.lock);\n\t\treturn res;\n\tcase SNDRV_EMU10K1_IOCTL_STOP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (emu->audigy)\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg |= A_DBG_SINGLE_STEP);\n\t\telse\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg |= EMU10K1_DBG_SINGLE_STEP);\n\t\treturn 0;\n\tcase SNDRV_EMU10K1_IOCTL_CONTINUE:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (emu->audigy)\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg = 0);\n\t\telse\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg = 0);\n\t\treturn 0;\n\tcase SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (emu->audigy)\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_ZC);\n\t\telse\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_ZC);\n\t\tudelay(10);\n\t\tif (emu->audigy)\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\n\t\telse\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\n\t\treturn 0;\n\tcase SNDRV_EMU10K1_IOCTL_SINGLE_STEP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(addr, (unsigned int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tif (emu->audigy) {\n\t\t\tif (addr > A_DBG_STEP_ADDR)\n\t\t\t\treturn -EINVAL;\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg |= A_DBG_SINGLE_STEP);\n\t\t\tudelay(10);\n\t\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_STEP | addr);\n\t\t} else {\n\t\t\tif (addr > EMU10K1_DBG_SINGLE_STEP_ADDR)\n\t\t\t\treturn -EINVAL;\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg |= EMU10K1_DBG_SINGLE_STEP);\n\t\t\tudelay(10);\n\t\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_STEP | addr);\n\t\t}\n\t\treturn 0;\n\tcase SNDRV_EMU10K1_IOCTL_DBG_READ:\n\t\tif (emu->audigy)\n\t\t\taddr = snd_emu10k1_ptr_read(emu, A_DBG, 0);\n\t\telse\n\t\t\taddr = snd_emu10k1_ptr_read(emu, DBG, 0);\n\t\tif (put_user(addr, (unsigned int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -ENOTTY;\n}\n\nstatic int snd_emu10k1_fx8010_release(struct snd_hwdep * hw, struct file *file)\n{\n\treturn 0;\n}\n\nint snd_emu10k1_fx8010_new(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_hwdep *hw;\n\tint err;\n\t\n\terr = snd_hwdep_new(emu->card, \"FX8010\", device, &hw);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(hw->name, \"EMU10K1 (FX8010)\");\n\thw->iface = SNDRV_HWDEP_IFACE_EMU10K1;\n\thw->ops.open = snd_emu10k1_fx8010_open;\n\thw->ops.ioctl = snd_emu10k1_fx8010_ioctl;\n\thw->ops.release = snd_emu10k1_fx8010_release;\n\thw->private_data = emu;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nint snd_emu10k1_efx_alloc_pm_buffer(struct snd_emu10k1 *emu)\n{\n\tint len;\n\n\tlen = emu->audigy ? 0x200 : 0x100;\n\temu->saved_gpr = kmalloc_array(len, 4, GFP_KERNEL);\n\tif (! emu->saved_gpr)\n\t\treturn -ENOMEM;\n\tlen = emu->audigy ? 0x100 : 0xa0;\n\temu->tram_val_saved = kmalloc_array(len, 4, GFP_KERNEL);\n\temu->tram_addr_saved = kmalloc_array(len, 4, GFP_KERNEL);\n\tif (! emu->tram_val_saved || ! emu->tram_addr_saved)\n\t\treturn -ENOMEM;\n\tlen = emu->audigy ? 2 * 1024 : 2 * 512;\n\temu->saved_icode = vmalloc(array_size(len, 4));\n\tif (! emu->saved_icode)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid snd_emu10k1_efx_free_pm_buffer(struct snd_emu10k1 *emu)\n{\n\tkfree(emu->saved_gpr);\n\tkfree(emu->tram_val_saved);\n\tkfree(emu->tram_addr_saved);\n\tvfree(emu->saved_icode);\n}\n\n \nvoid snd_emu10k1_efx_suspend(struct snd_emu10k1 *emu)\n{\n\tint i, len;\n\n\tlen = emu->audigy ? 0x200 : 0x100;\n\tfor (i = 0; i < len; i++)\n\t\temu->saved_gpr[i] = snd_emu10k1_ptr_read(emu, emu->gpr_base + i, 0);\n\n\tlen = emu->audigy ? 0x100 : 0xa0;\n\tfor (i = 0; i < len; i++) {\n\t\temu->tram_val_saved[i] = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + i, 0);\n\t\temu->tram_addr_saved[i] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + i, 0);\n\t\tif (emu->audigy) {\n\t\t\temu->tram_addr_saved[i] >>= 12;\n\t\t\temu->tram_addr_saved[i] |=\n\t\t\t\tsnd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + i, 0) << 20;\n\t\t}\n\t}\n\n\tlen = emu->audigy ? 2 * 1024 : 2 * 512;\n\tfor (i = 0; i < len; i++)\n\t\temu->saved_icode[i] = snd_emu10k1_efx_read(emu, i);\n}\n\nvoid snd_emu10k1_efx_resume(struct snd_emu10k1 *emu)\n{\n\tint i, len;\n\n\t \n\tif (emu->fx8010.etram_pages.bytes > 0) {\n\t\tunsigned size, size_reg = 0;\n\t\tsize = emu->fx8010.etram_pages.bytes / 2;\n\t\tsize = (size - 1) >> 13;\n\t\twhile (size) {\n\t\t\tsize >>= 1;\n\t\t\tsize_reg++;\n\t\t}\n\t\toutl(HCFG_LOCKTANKCACHE_MASK | inl(emu->port + HCFG), emu->port + HCFG);\n\t\tsnd_emu10k1_ptr_write(emu, TCB, 0, emu->fx8010.etram_pages.addr);\n\t\tsnd_emu10k1_ptr_write(emu, TCBS, 0, size_reg);\n\t\toutl(inl(emu->port + HCFG) & ~HCFG_LOCKTANKCACHE_MASK, emu->port + HCFG);\n\t}\n\n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_SINGLE_STEP);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_SINGLE_STEP);\n\n\tlen = emu->audigy ? 0x200 : 0x100;\n\tfor (i = 0; i < len; i++)\n\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + i, 0, emu->saved_gpr[i]);\n\n\tlen = emu->audigy ? 0x100 : 0xa0;\n\tfor (i = 0; i < len; i++) {\n\t\tsnd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + i, 0,\n\t\t\t\t      emu->tram_val_saved[i]);\n\t\tif (! emu->audigy)\n\t\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\n\t\t\t\t\t      emu->tram_addr_saved[i]);\n\t\telse {\n\t\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\n\t\t\t\t\t      emu->tram_addr_saved[i] << 12);\n\t\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\n\t\t\t\t\t      emu->tram_addr_saved[i] >> 20);\n\t\t}\n\t}\n\n\tlen = emu->audigy ? 2 * 1024 : 2 * 512;\n\tfor (i = 0; i < len; i++)\n\t\tsnd_emu10k1_efx_write(emu, i, emu->saved_icode[i]);\n\n\t \n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}