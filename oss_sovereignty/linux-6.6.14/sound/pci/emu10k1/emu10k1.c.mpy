{
  "module_name": "emu10k1.c",
  "hash_id": "50f41ac8ad06aeb32065569c2e54586c2defe0a780cc7d699948d8602f9a842a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emu10k1.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"EMU10K1\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n#define ENABLE_SYNTH\n#include <sound/emu10k1_synth.h>\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic int extin[SNDRV_CARDS];\nstatic int extout[SNDRV_CARDS];\nstatic int seq_ports[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4};\nstatic int max_synth_voices[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 64};\nstatic int max_buffer_size[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 128};\nstatic bool enable_ir[SNDRV_CARDS];\nstatic uint subsystem[SNDRV_CARDS];  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the EMU10K1 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the EMU10K1 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable the EMU10K1 soundcard.\");\nmodule_param_array(extin, int, NULL, 0444);\nMODULE_PARM_DESC(extin, \"Available external inputs for FX8010. Zero=default.\");\nmodule_param_array(extout, int, NULL, 0444);\nMODULE_PARM_DESC(extout, \"Available external outputs for FX8010. Zero=default.\");\nmodule_param_array(seq_ports, int, NULL, 0444);\nMODULE_PARM_DESC(seq_ports, \"Allocated sequencer ports for internal synthesizer.\");\nmodule_param_array(max_synth_voices, int, NULL, 0444);\nMODULE_PARM_DESC(max_synth_voices, \"Maximum number of voices for WaveTable.\");\nmodule_param_array(max_buffer_size, int, NULL, 0444);\nMODULE_PARM_DESC(max_buffer_size, \"Maximum sample buffer size in MB.\");\nmodule_param_array(enable_ir, bool, NULL, 0444);\nMODULE_PARM_DESC(enable_ir, \"Enable IR.\");\nmodule_param_array(subsystem, uint, NULL, 0444);\nMODULE_PARM_DESC(subsystem, \"Force card subsystem model.\");\n \nstatic const struct pci_device_id snd_emu10k1_ids[] = {\n\t{ PCI_VDEVICE(CREATIVE, 0x0002), 0 },\t \n\t{ PCI_VDEVICE(CREATIVE, 0x0004), 1 },\t \n\t{ PCI_VDEVICE(CREATIVE, 0x0008), 1 },\t \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_emu10k1_ids);\n\nstatic int snd_card_emu10k1_probe(struct pci_dev *pci,\n\t\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_emu10k1 *emu;\n#ifdef ENABLE_SYNTH\n\tstruct snd_seq_device *wave = NULL;\n#endif\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n        \treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*emu), &card);\n\tif (err < 0)\n\t\treturn err;\n\temu = card->private_data;\n\n\tif (max_buffer_size[dev] < 32)\n\t\tmax_buffer_size[dev] = 32;\n\telse if (max_buffer_size[dev] > 1024)\n\t\tmax_buffer_size[dev] = 1024;\n\terr = snd_emu10k1_create(card, pci, extin[dev], extout[dev],\n\t\t\t\t (long)max_buffer_size[dev] * 1024 * 1024,\n\t\t\t\t enable_ir[dev], subsystem[dev]);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_emu10k1_pcm(emu, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (emu->card_capabilities->ac97_chip) {\n\t\terr = snd_emu10k1_pcm_mic(emu, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_emu10k1_pcm_efx(emu, 2);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (emu->card_capabilities->ca0151_chip) {  \t\n\t\temu->p16v_buffer =\n\t\t\tsnd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV, 1024);\n\t\tif (!emu->p16v_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terr = snd_emu10k1_mixer(emu, 0, 3);\n\tif (err < 0)\n\t\treturn err;\n\t\n\terr = snd_emu10k1_timer(emu, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_emu10k1_pcm_multi(emu, 3);\n\tif (err < 0)\n\t\treturn err;\n\tif (emu->card_capabilities->ca0151_chip) {  \n\t\terr = snd_p16v_pcm(emu, 4);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (emu->audigy) {\n\t\terr = snd_emu10k1_audigy_midi(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = snd_emu10k1_midi(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_emu10k1_fx8010_new(emu, 0);\n\tif (err < 0)\n\t\treturn err;\n#ifdef ENABLE_SYNTH\n\tif (snd_seq_device_new(card, 1, SNDRV_SEQ_DEV_ID_EMU10K1_SYNTH,\n\t\t\t       sizeof(struct snd_emu10k1_synth_arg), &wave) < 0 ||\n\t    wave == NULL) {\n\t\tdev_warn(emu->card->dev,\n\t\t\t \"can't initialize Emu10k1 wavetable synth\\n\");\n\t} else {\n\t\tstruct snd_emu10k1_synth_arg *arg;\n\t\targ = SNDRV_SEQ_DEVICE_ARGPTR(wave);\n\t\tstrcpy(wave->name, \"Emu-10k1 Synth\");\n\t\targ->hwptr = emu;\n\t\targ->index = 1;\n\t\targ->seq_ports = seq_ports[dev];\n\t\targ->max_voices = max_synth_voices[dev];\n\t}\n#endif\n \n\tstrscpy(card->driver, emu->card_capabilities->driver,\n\t\tsizeof(card->driver));\n\tstrscpy(card->shortname, emu->card_capabilities->name,\n\t\tsizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s (rev.%d, serial:0x%x) at 0x%lx, irq %i\",\n\t\t card->shortname, emu->revision, emu->serial, emu->port, emu->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_emu10k1_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_emu10k1 *emu = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\temu->suspend = 1;\n\n\tcancel_work_sync(&emu->emu1010.firmware_work);\n\tcancel_work_sync(&emu->emu1010.clock_work);\n\n\tsnd_ac97_suspend(emu->ac97);\n\n\tsnd_emu10k1_efx_suspend(emu);\n\tsnd_emu10k1_suspend_regs(emu);\n\tif (emu->card_capabilities->ca0151_chip)\n\t\tsnd_p16v_suspend(emu);\n\n\tsnd_emu10k1_done(emu);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_emu10k1 *emu = card->private_data;\n\n\tsnd_emu10k1_resume_init(emu);\n\tsnd_emu10k1_efx_resume(emu);\n\tsnd_ac97_resume(emu->ac97);\n\tsnd_emu10k1_resume_regs(emu);\n\n\tif (emu->card_capabilities->ca0151_chip)\n\t\tsnd_p16v_resume(emu);\n\n\temu->suspend = 0;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_emu10k1_pm, snd_emu10k1_suspend, snd_emu10k1_resume);\n#define SND_EMU10K1_PM_OPS\t&snd_emu10k1_pm\n#else\n#define SND_EMU10K1_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver emu10k1_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_emu10k1_ids,\n\t.probe = snd_card_emu10k1_probe,\n\t.driver = {\n\t\t.pm = SND_EMU10K1_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(emu10k1_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}