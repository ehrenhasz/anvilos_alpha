{
  "module_name": "emupcm.c",
  "hash_id": "c78d8b2c3f00797b20d8f1924a775fbb8ea4093604d64c57c8a154848d4ccf3b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emupcm.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n\nstatic void snd_emu10k1_pcm_interrupt(struct snd_emu10k1 *emu,\n\t\t\t\t      struct snd_emu10k1_voice *voice)\n{\n\tstruct snd_emu10k1_pcm *epcm;\n\n\tepcm = voice->epcm;\n\tif (!epcm)\n\t\treturn;\n\tif (epcm->substream == NULL)\n\t\treturn;\n#if 0\n\tdev_dbg(emu->card->dev,\n\t\t\"IRQ: position = 0x%x, period = 0x%x, size = 0x%x\\n\",\n\t\t\tepcm->substream->runtime->hw->pointer(emu, epcm->substream),\n\t\t\tsnd_pcm_lib_period_bytes(epcm->substream),\n\t\t\tsnd_pcm_lib_buffer_bytes(epcm->substream));\n#endif\n\tsnd_pcm_period_elapsed(epcm->substream);\n}\n\nstatic void snd_emu10k1_pcm_ac97adc_interrupt(struct snd_emu10k1 *emu,\n\t\t\t\t\t      unsigned int status)\n{\n#if 0\n\tif (status & IPR_ADCBUFHALFFULL) {\n\t\tif (emu->pcm_capture_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\n\t\t\treturn;\n\t}\n#endif\n\tsnd_pcm_period_elapsed(emu->pcm_capture_substream);\n}\n\nstatic void snd_emu10k1_pcm_ac97mic_interrupt(struct snd_emu10k1 *emu,\n\t\t\t\t\t      unsigned int status)\n{\n#if 0\n\tif (status & IPR_MICBUFHALFFULL) {\n\t\tif (emu->pcm_capture_mic_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\n\t\t\treturn;\n\t}\n#endif\n\tsnd_pcm_period_elapsed(emu->pcm_capture_mic_substream);\n}\n\nstatic void snd_emu10k1_pcm_efx_interrupt(struct snd_emu10k1 *emu,\n\t\t\t\t\t  unsigned int status)\n{\n#if 0\n\tif (status & IPR_EFXBUFHALFFULL) {\n\t\tif (emu->pcm_capture_efx_substream->runtime->mode == SNDRV_PCM_MODE_FRAME)\n\t\t\treturn;\n\t}\n#endif\n\tsnd_pcm_period_elapsed(emu->pcm_capture_efx_substream);\n}\t \n\nstatic void snd_emu10k1_pcm_free_voices(struct snd_emu10k1_pcm *epcm)\n{\n\tfor (unsigned i = 0; i < ARRAY_SIZE(epcm->voices); i++) {\n\t\tif (epcm->voices[i]) {\n\t\t\tsnd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);\n\t\t\tepcm->voices[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int snd_emu10k1_pcm_channel_alloc(struct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t int type, int count, int channels)\n{\n\tint err;\n\n\tsnd_emu10k1_pcm_free_voices(epcm);\n\n\terr = snd_emu10k1_voice_alloc(epcm->emu,\n\t\t\t\t      type, count, channels,\n\t\t\t\t      epcm, &epcm->voices[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (epcm->extra == NULL) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\terr = snd_emu10k1_voice_alloc(epcm->emu,\n\t\t\t\t\t      type + 1, 1, 1,\n\t\t\t\t\t      epcm, &epcm->extra);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tsnd_emu10k1_pcm_free_voices(epcm);\n\t\t\treturn err;\n\t\t}\n\t\tepcm->extra->interrupt = snd_emu10k1_pcm_interrupt;\n\t}\n\n\treturn 0;\n}\n\n\nstatic const unsigned int efx_capture_channels[] = {\n\t1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_efx_capture_channels = {\n\t.count = ARRAY_SIZE(efx_capture_channels),\n\t.list = efx_capture_channels,\n\t.mask = 0\n};\n\nstatic const unsigned int capture_buffer_sizes[31] = {\n\t384,\t448,\t512,\t640,\n\t384*2,\t448*2,\t512*2,\t640*2,\n\t384*4,\t448*4,\t512*4,\t640*4,\n\t384*8,\t448*8,\t512*8,\t640*8,\n\t384*16,\t448*16,\t512*16,\t640*16,\n\t384*32,\t448*32,\t512*32,\t640*32,\n\t384*64,\t448*64,\t512*64,\t640*64,\n\t384*128,448*128,512*128\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_capture_buffer_sizes = {\n\t.count = 31,\n\t.list = capture_buffer_sizes,\n\t.mask = 0\n};\n\nstatic const unsigned int capture_rates[8] = {\n\t8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_capture_rates = {\n\t.count = 8,\n\t.list = capture_rates,\n\t.mask = 0\n};\n\nstatic unsigned int snd_emu10k1_capture_rate_reg(unsigned int rate)\n{\n\tswitch (rate) {\n\tcase 8000:\treturn ADCCR_SAMPLERATE_8;\n\tcase 11025:\treturn ADCCR_SAMPLERATE_11;\n\tcase 16000:\treturn ADCCR_SAMPLERATE_16;\n\tcase 22050:\treturn ADCCR_SAMPLERATE_22;\n\tcase 24000:\treturn ADCCR_SAMPLERATE_24;\n\tcase 32000:\treturn ADCCR_SAMPLERATE_32;\n\tcase 44100:\treturn ADCCR_SAMPLERATE_44;\n\tcase 48000:\treturn ADCCR_SAMPLERATE_48;\n\tdefault:\n\t\t\tsnd_BUG();\n\t\t\treturn ADCCR_SAMPLERATE_8;\n\t}\n}\n\nstatic const unsigned int audigy_capture_rates[9] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_audigy_capture_rates = {\n\t.count = 9,\n\t.list = audigy_capture_rates,\n\t.mask = 0\n};\n\nstatic unsigned int snd_emu10k1_audigy_capture_rate_reg(unsigned int rate)\n{\n\tswitch (rate) {\n\tcase 8000:\treturn A_ADCCR_SAMPLERATE_8;\n\tcase 11025:\treturn A_ADCCR_SAMPLERATE_11;\n\tcase 12000:\treturn A_ADCCR_SAMPLERATE_12;\n\tcase 16000:\treturn ADCCR_SAMPLERATE_16;\n\tcase 22050:\treturn ADCCR_SAMPLERATE_22;\n\tcase 24000:\treturn ADCCR_SAMPLERATE_24;\n\tcase 32000:\treturn ADCCR_SAMPLERATE_32;\n\tcase 44100:\treturn ADCCR_SAMPLERATE_44;\n\tcase 48000:\treturn ADCCR_SAMPLERATE_48;\n\tdefault:\n\t\t\tsnd_BUG();\n\t\t\treturn A_ADCCR_SAMPLERATE_8;\n\t}\n}\n\nstatic void snd_emu10k1_constrain_capture_rates(struct snd_emu10k1 *emu,\n\t\t\t\t\t\tstruct snd_pcm_runtime *runtime)\n{\n\tif (emu->card_capabilities->emu_model &&\n\t    emu->emu1010.word_clock == 44100) {\n\t\t\n\t\truntime->hw.rates = SNDRV_PCM_RATE_11025 | \\\n\t\t\t\t    SNDRV_PCM_RATE_22050 | \\\n\t\t\t\t    SNDRV_PCM_RATE_44100;\n\t\truntime->hw.rate_min = 11025;\n\t\truntime->hw.rate_max = 44100;\n\t\treturn;\n\t}\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   emu->audigy ? &hw_constraints_audigy_capture_rates :\n\t\t\t\t\t\t &hw_constraints_capture_rates);\n}\n\nstatic void snd_emu1010_constrain_efx_rate(struct snd_emu10k1 *emu,\n\t\t\t\t\t   struct snd_pcm_runtime *runtime)\n{\n\tint rate;\n\n\trate = emu->emu1010.word_clock;\n\truntime->hw.rate_min = runtime->hw.rate_max = rate;\n\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n}\n\nstatic unsigned int emu10k1_calc_pitch_target(unsigned int rate)\n{\n\tunsigned int pitch_target;\n\n\tpitch_target = (rate << 8) / 375;\n\tpitch_target = (pitch_target >> 1) + (pitch_target & 1);\n\treturn pitch_target;\n}\n\n#define PITCH_48000 0x00004000\n#define PITCH_96000 0x00008000\n#define PITCH_85000 0x00007155\n#define PITCH_80726 0x00006ba2\n#define PITCH_67882 0x00005a82\n#define PITCH_57081 0x00004c1c\n\nstatic unsigned int emu10k1_select_interprom(unsigned int pitch_target)\n{\n\tif (pitch_target == PITCH_48000)\n\t\treturn CCCA_INTERPROM_0;\n\telse if (pitch_target < PITCH_48000)\n\t\treturn CCCA_INTERPROM_1;\n\telse if (pitch_target >= PITCH_96000)\n\t\treturn CCCA_INTERPROM_0;\n\telse if (pitch_target >= PITCH_85000)\n\t\treturn CCCA_INTERPROM_6;\n\telse if (pitch_target >= PITCH_80726)\n\t\treturn CCCA_INTERPROM_5;\n\telse if (pitch_target >= PITCH_67882)\n\t\treturn CCCA_INTERPROM_4;\n\telse if (pitch_target >= PITCH_57081)\n\t\treturn CCCA_INTERPROM_3;\n\telse  \n\t\treturn CCCA_INTERPROM_2;\n}\n\nstatic u16 emu10k1_send_target_from_amount(u8 amount)\n{\n\tstatic const u8 shifts[8] = { 4, 4, 5, 6, 7, 8, 9, 10 };\n\tstatic const u16 offsets[8] = { 0, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000 };\n\tu8 exp;\n\n\tif (amount == 0xff)\n\t\treturn 0xffff;\n\texp = amount >> 5;\n\treturn ((amount & 0x1f) << shifts[exp]) + offsets[exp];\n}\n\nstatic void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,\n\t\t\t\t       struct snd_emu10k1_voice *evoice,\n\t\t\t\t       bool w_16, bool stereo,\n\t\t\t\t       unsigned int start_addr,\n\t\t\t\t       unsigned int end_addr,\n\t\t\t\t       const unsigned char *send_routing,\n\t\t\t\t       const unsigned char *send_amount)\n{\n\tunsigned int silent_page;\n\tint voice;\n\n\tvoice = evoice->number;\n\n\tsilent_page = ((unsigned int)emu->silent_page.addr << emu->address_mode) |\n\t\t      (emu->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);\n\tsnd_emu10k1_ptr_write_multiple(emu, voice,\n\t\t\n\t\tCPF, stereo ? CPF_STEREO_MASK : 0,\n\t\t\n\t\tPTRX, (send_amount[0] << 8) | send_amount[1],\n\t\t\n\t\tDSL, end_addr | (send_amount[3] << 24),\n\t\tPSST, start_addr | (send_amount[2] << 24),\n\t\tCCCA, emu10k1_select_interprom(evoice->epcm->pitch_target) |\n\t\t      (w_16 ? 0 : CCCA_8BITSELECT),\n\t\t\n\t\tZ1, 0,\n\t\tZ2, 0,\n\t\t\n\t\tMAPA, silent_page,\n\t\tMAPB, silent_page,\n\t\t\n\t\tVTFT, VTFT_FILTERTARGET_MASK,\n\t\tCVCF, CVCF_CURRENTFILTER_MASK,\n\t\tREGLIST_END);\n\t\n\tif (emu->audigy) {\n\t\tsnd_emu10k1_ptr_write_multiple(emu, voice,\n\t\t\tA_FXRT1, snd_emu10k1_compose_audigy_fxrt1(send_routing),\n\t\t\tA_FXRT2, snd_emu10k1_compose_audigy_fxrt2(send_routing),\n\t\t\tA_SENDAMOUNTS, snd_emu10k1_compose_audigy_sendamounts(send_amount),\n\t\t\tREGLIST_END);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tu32 aml = emu10k1_send_target_from_amount(send_amount[2 * i]);\n\t\t\tu32 amh = emu10k1_send_target_from_amount(send_amount[2 * i + 1]);\n\t\t\tsnd_emu10k1_ptr_write(emu, A_CSBA + i, voice, (amh << 16) | aml);\n\t\t}\n\t} else {\n\t\tsnd_emu10k1_ptr_write(emu, FXRT, voice,\n\t\t\t\t      snd_emu10k1_compose_send_routing(send_routing));\n\t}\n\n\temu->voices[voice].dirty = 1;\n}\n\nstatic void snd_emu10k1_pcm_init_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\tstruct snd_emu10k1_voice *evoice,\n\t\t\t\t\tbool w_16, bool stereo,\n\t\t\t\t\tunsigned int start_addr,\n\t\t\t\t\tunsigned int end_addr,\n\t\t\t\t\tstruct snd_emu10k1_pcm_mixer *mix)\n{\n\tspin_lock_irq(&emu->reg_lock);\n\tsnd_emu10k1_pcm_init_voice(emu, evoice, w_16, stereo,\n\t\t\t\t   start_addr, end_addr,\n\t\t\t\t   &mix->send_routing[stereo][0],\n\t\t\t\t   &mix->send_volume[stereo][0]);\n\tif (stereo)\n\t\tsnd_emu10k1_pcm_init_voice(emu, evoice + 1, w_16, true,\n\t\t\t\t\t   start_addr, end_addr,\n\t\t\t\t\t   &mix->send_routing[2][0],\n\t\t\t\t\t   &mix->send_volume[2][0]);\n\tspin_unlock_irq(&emu->reg_lock);\n}\n\nstatic void snd_emu10k1_pcm_init_extra_voice(struct snd_emu10k1 *emu,\n\t\t\t\t\t     struct snd_emu10k1_voice *evoice,\n\t\t\t\t\t     bool w_16,\n\t\t\t\t\t     unsigned int start_addr,\n\t\t\t\t\t     unsigned int end_addr)\n{\n\tstatic const unsigned char send_routing[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n\tstatic const unsigned char send_amount[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tsnd_emu10k1_pcm_init_voice(emu, evoice, w_16, false,\n\t\t\t\t   start_addr, end_addr,\n\t\t\t\t   send_routing, send_amount);\n}\n\nstatic int snd_emu10k1_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tsize_t alloc_size;\n\tint type, channels, count;\n\tint err;\n\n\tif (epcm->type == PLAYBACK_EMUVOICE) {\n\t\ttype = EMU10K1_PCM;\n\t\tchannels = 1;\n\t\tcount = params_channels(hw_params);\n\t} else {\n\t\ttype = EMU10K1_EFX;\n\t\tchannels = params_channels(hw_params);\n\t\tcount = 1;\n\t}\n\terr = snd_emu10k1_pcm_channel_alloc(epcm, type, count, channels);\n\tif (err < 0)\n\t\treturn err;\n\n\talloc_size = params_buffer_bytes(hw_params);\n\tif (emu->iommu_workaround)\n\t\talloc_size += EMUPAGESIZE;\n\terr = snd_pcm_lib_malloc_pages(substream, alloc_size);\n\tif (err < 0)\n\t\treturn err;\n\tif (emu->iommu_workaround && runtime->dma_bytes >= EMUPAGESIZE)\n\t\truntime->dma_bytes -= EMUPAGESIZE;\n\tif (err > 0) {\t \n\t\tint mapped;\n\t\tif (epcm->memblk != NULL)\n\t\t\tsnd_emu10k1_free_pages(emu, epcm->memblk);\n\t\tepcm->memblk = snd_emu10k1_alloc_pages(emu, substream);\n\t\tepcm->start_addr = 0;\n\t\tif (! epcm->memblk)\n\t\t\treturn -ENOMEM;\n\t\tmapped = ((struct snd_emu10k1_memblk *)epcm->memblk)->mapped_page;\n\t\tif (mapped < 0)\n\t\t\treturn -ENOMEM;\n\t\tepcm->start_addr = mapped << PAGE_SHIFT;\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm;\n\n\tif (runtime->private_data == NULL)\n\t\treturn 0;\n\tepcm = runtime->private_data;\n\tif (epcm->extra) {\n\t\tsnd_emu10k1_voice_free(epcm->emu, epcm->extra);\n\t\tepcm->extra = NULL;\n\t}\n\tsnd_emu10k1_pcm_free_voices(epcm);\n\tif (epcm->memblk) {\n\t\tsnd_emu10k1_free_pages(emu, epcm->memblk);\n\t\tepcm->memblk = NULL;\n\t\tepcm->start_addr = 0;\n\t}\n\tsnd_pcm_lib_free_pages(substream);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tbool w_16 = snd_pcm_format_width(runtime->format) == 16;\n\tbool stereo = runtime->channels == 2;\n\tunsigned int start_addr, end_addr;\n\tunsigned int rate;\n\n\trate = runtime->rate;\n\tif (emu->card_capabilities->emu_model &&\n\t    emu->emu1010.word_clock == 44100)\n\t\trate = rate * 480 / 441;\n\tepcm->pitch_target = emu10k1_calc_pitch_target(rate);\n\n\tstart_addr = epcm->start_addr >> w_16;\n\tend_addr = start_addr + runtime->period_size;\n\tsnd_emu10k1_pcm_init_extra_voice(emu, epcm->extra, w_16,\n\t\t\t\t\t start_addr, end_addr);\n\tstart_addr >>= stereo;\n\tepcm->ccca_start_addr = start_addr;\n\tend_addr = start_addr + runtime->buffer_size;\n\tsnd_emu10k1_pcm_init_voices(emu, epcm->voices[0], w_16, stereo,\n\t\t\t\t    start_addr, end_addr,\n\t\t\t\t    &emu->pcm_mixer[substream->number]);\n\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tunsigned int start_addr;\n\tunsigned int extra_size, channel_size;\n\tunsigned int i;\n\n\tepcm->pitch_target = PITCH_48000;\n\n\tstart_addr = epcm->start_addr >> 1;  \n\n\textra_size = runtime->period_size;\n\tchannel_size = runtime->buffer_size;\n\n\tsnd_emu10k1_pcm_init_extra_voice(emu, epcm->extra, true,\n\t\t\t\t\t start_addr, start_addr + extra_size);\n\n\tepcm->ccca_start_addr = start_addr;\n\tfor (i = 0; i < runtime->channels; i++) {\n\t\tsnd_emu10k1_pcm_init_voices(emu, epcm->voices[i], true, false,\n\t\t\t\t\t    start_addr, start_addr + channel_size,\n\t\t\t\t\t    &emu->efx_pcm_mixer[i]);\n\t\tstart_addr += channel_size;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_emu10k1_efx_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\tNUM_EFX_PLAYBACK,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_emu10k1_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tint idx;\n\n\t \n\tsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, 0);\n\tswitch (epcm->type) {\n\tcase CAPTURE_AC97ADC:\n\t\tsnd_emu10k1_ptr_write(emu, ADCCR, 0, 0);\n\t\tbreak;\n\tcase CAPTURE_EFX:\n\t\tif (emu->card_capabilities->emu_model) {\n\t\t\t\n\t\t\t\n\t\t\tepcm->capture_cr_val = 0;\n\t\t\tepcm->capture_cr_val2 = 0xffffffff >> (32 - runtime->channels * 2);\n\t\t}\n\t\tif (emu->audigy) {\n\t\t\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\t\t\tA_FXWC1, 0,\n\t\t\t\tA_FXWC2, 0,\n\t\t\t\tREGLIST_END);\n\t\t} else\n\t\t\tsnd_emu10k1_ptr_write(emu, FXWC, 0, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\t\n\tsnd_emu10k1_ptr_write(emu, epcm->capture_ba_reg, 0, runtime->dma_addr);\n\tepcm->capture_bufsize = snd_pcm_lib_buffer_bytes(substream);\n\tepcm->capture_bs_val = 0;\n\tfor (idx = 0; idx < 31; idx++) {\n\t\tif (capture_buffer_sizes[idx] == epcm->capture_bufsize) {\n\t\t\tepcm->capture_bs_val = idx + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (epcm->capture_bs_val == 0) {\n\t\tsnd_BUG();\n\t\tepcm->capture_bs_val++;\n\t}\n\tif (epcm->type == CAPTURE_AC97ADC) {\n\t\tunsigned rate = runtime->rate;\n\t\tif (!(runtime->hw.rates & SNDRV_PCM_RATE_48000))\n\t\t\trate = rate * 480 / 441;\n\n\t\tepcm->capture_cr_val = emu->audigy ? A_ADCCR_LCHANENABLE : ADCCR_LCHANENABLE;\n\t\tif (runtime->channels > 1)\n\t\t\tepcm->capture_cr_val |= emu->audigy ? A_ADCCR_RCHANENABLE : ADCCR_RCHANENABLE;\n\t\tepcm->capture_cr_val |= emu->audigy ?\n\t\t\tsnd_emu10k1_audigy_capture_rate_reg(rate) :\n\t\t\tsnd_emu10k1_capture_rate_reg(rate);\n\t}\n\treturn 0;\n}\n\nstatic void snd_emu10k1_playback_fill_cache(struct snd_emu10k1 *emu,\n\t\t\t\t\t    unsigned voice,\n\t\t\t\t\t    u32 sample, bool stereo)\n{\n\tu32 ccr;\n\n\t\n\t\n\n\t\n\t\n\t\n\tfor (int i = 0; i < 3; i++)\n\t\tsnd_emu10k1_ptr_write(emu, CD0 + i, voice, sample);\n\n\t\n\tccr = (64 - 3) << REG_SHIFT(CCR_CACHEINVALIDSIZE);\n\tif (stereo) {\n\t\t\n\t\tsnd_emu10k1_ptr_write(emu, CCR, voice + 1, ccr);\n\t}\n\tsnd_emu10k1_ptr_write(emu, CCR, voice, ccr);\n}\n\nstatic void snd_emu10k1_playback_prepare_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t\tstruct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t\tbool w_16, bool stereo,\n\t\t\t\t\t\tint channels)\n{\n\tstruct snd_pcm_substream *substream = epcm->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned eloop_start = epcm->start_addr >> w_16;\n\tunsigned loop_start = eloop_start >> stereo;\n\tunsigned eloop_size = runtime->period_size;\n\tunsigned loop_size = runtime->buffer_size;\n\tu32 sample = w_16 ? 0 : 0x80808080;\n\n\t\n\t\n\t\n\t\n\tloop_start += (epcm->resume_pos + 64 - 3) % loop_size;\n\tfor (int i = 0; i < channels; i++) {\n\t\tunsigned voice = epcm->voices[i]->number;\n\t\tsnd_emu10k1_ptr_write(emu, CCCA_CURRADDR, voice, loop_start);\n\t\tloop_start += loop_size;\n\t\tsnd_emu10k1_playback_fill_cache(emu, voice, sample, stereo);\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\teloop_start += (epcm->resume_pos + eloop_size - 3) % eloop_size;\n\tsnd_emu10k1_ptr_write(emu, CCCA_CURRADDR, epcm->extra->number, eloop_start);\n\n\t\n\t\n}\n\nstatic void snd_emu10k1_playback_commit_volume(struct snd_emu10k1 *emu,\n\t\t\t\t\t       struct snd_emu10k1_voice *evoice,\n\t\t\t\t\t       unsigned int vattn)\n{\n\tsnd_emu10k1_ptr_write_multiple(emu, evoice->number,\n\t\tVTFT, vattn | VTFT_FILTERTARGET_MASK,\n\t\tCVCF, vattn | CVCF_CURRENTFILTER_MASK,\n\t\tREGLIST_END);\n}\n\nstatic void snd_emu10k1_playback_unmute_voice(struct snd_emu10k1 *emu,\n\t\t\t\t\t      struct snd_emu10k1_voice *evoice,\n\t\t\t\t\t      bool stereo, bool master,\n\t\t\t\t\t      struct snd_emu10k1_pcm_mixer *mix)\n{\n\tunsigned int vattn;\n\tunsigned int tmp;\n\n\ttmp = stereo ? (master ? 1 : 2) : 0;\n\tvattn = mix->attn[tmp] << 16;\n\tsnd_emu10k1_playback_commit_volume(emu, evoice, vattn);\n}\t\n\nstatic void snd_emu10k1_playback_unmute_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t       struct snd_emu10k1_voice *evoice,\n\t\t\t\t\t       bool stereo,\n\t\t\t\t\t       struct snd_emu10k1_pcm_mixer *mix)\n{\n\tsnd_emu10k1_playback_unmute_voice(emu, evoice, stereo, true, mix);\n\tif (stereo)\n\t\tsnd_emu10k1_playback_unmute_voice(emu, evoice + 1, true, false, mix);\n}\n\nstatic void snd_emu10k1_playback_mute_voice(struct snd_emu10k1 *emu,\n\t\t\t\t\t    struct snd_emu10k1_voice *evoice)\n{\n\tsnd_emu10k1_playback_commit_volume(emu, evoice, 0);\n}\n\nstatic void snd_emu10k1_playback_mute_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t     struct snd_emu10k1_voice *evoice,\n\t\t\t\t\t     bool stereo)\n{\n\tsnd_emu10k1_playback_mute_voice(emu, evoice);\n\tif (stereo)\n\t\tsnd_emu10k1_playback_mute_voice(emu, evoice + 1);\n}\n\nstatic void snd_emu10k1_playback_commit_pitch(struct snd_emu10k1 *emu,\n\t\t\t\t\t      u32 voice, u32 pitch_target)\n{\n\tu32 ptrx = snd_emu10k1_ptr_read(emu, PTRX, voice);\n\tu32 cpf = snd_emu10k1_ptr_read(emu, CPF, voice);\n\tsnd_emu10k1_ptr_write_multiple(emu, voice,\n\t\tPTRX, (ptrx & ~PTRX_PITCHTARGET_MASK) | pitch_target,\n\t\tCPF, (cpf & ~(CPF_CURRENTPITCH_MASK | CPF_FRACADDRESS_MASK)) | pitch_target,\n\t\tREGLIST_END);\n}\n\nstatic void snd_emu10k1_playback_trigger_voice(struct snd_emu10k1 *emu,\n\t\t\t\t\t       struct snd_emu10k1_voice *evoice)\n{\n\tunsigned int voice;\n\n\tvoice = evoice->number;\n\tsnd_emu10k1_playback_commit_pitch(emu, voice, evoice->epcm->pitch_target << 16);\n}\n\nstatic void snd_emu10k1_playback_stop_voice(struct snd_emu10k1 *emu,\n\t\t\t\t\t    struct snd_emu10k1_voice *evoice)\n{\n\tunsigned int voice;\n\n\tvoice = evoice->number;\n\tsnd_emu10k1_playback_commit_pitch(emu, voice, 0);\n}\n\nstatic void snd_emu10k1_playback_set_running(struct snd_emu10k1 *emu,\n\t\t\t\t\t     struct snd_emu10k1_pcm *epcm)\n{\n\tepcm->running = 1;\n\tsnd_emu10k1_voice_intr_enable(emu, epcm->extra->number);\n}\n\nstatic void snd_emu10k1_playback_set_stopped(struct snd_emu10k1 *emu,\n\t\t\t\t\t      struct snd_emu10k1_pcm *epcm)\n{\n\tsnd_emu10k1_voice_intr_disable(emu, epcm->extra->number);\n\tepcm->running = 0;\n}\n\nstatic int snd_emu10k1_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t        int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tstruct snd_emu10k1_pcm_mixer *mix;\n\tbool w_16 = snd_pcm_format_width(runtime->format) == 16;\n\tbool stereo = runtime->channels == 2;\n\tint result = 0;\n\n\t \n\tspin_lock(&emu->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_emu10k1_playback_prepare_voices(emu, epcm, w_16, stereo, 1);\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tmix = &emu->pcm_mixer[substream->number];\n\t\tsnd_emu10k1_playback_unmute_voices(emu, epcm->voices[0], stereo, mix);\n\t\tsnd_emu10k1_playback_set_running(emu, epcm);\n\t\tsnd_emu10k1_playback_trigger_voice(emu, epcm->voices[0]);\n\t\tsnd_emu10k1_playback_trigger_voice(emu, epcm->extra);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tsnd_emu10k1_playback_stop_voice(emu, epcm->voices[0]);\n\t\tsnd_emu10k1_playback_stop_voice(emu, epcm->extra);\n\t\tsnd_emu10k1_playback_set_stopped(emu, epcm);\n\t\tsnd_emu10k1_playback_mute_voices(emu, epcm->voices[0], stereo);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&emu->reg_lock);\n\treturn result;\n}\n\nstatic int snd_emu10k1_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tint result = 0;\n\n\tspin_lock(&emu->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t \n\t\toutl(epcm->capture_ipr, emu->port + IPR);\n\t\tsnd_emu10k1_intr_enable(emu, epcm->capture_inte);\n\t\t \n\t\tswitch (epcm->type) {\n\t\tcase CAPTURE_AC97ADC:\n\t\t\tsnd_emu10k1_ptr_write(emu, ADCCR, 0, epcm->capture_cr_val);\n\t\t\tbreak;\n\t\tcase CAPTURE_EFX:\n\t\t\tif (emu->audigy) {\n\t\t\t\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\t\t\t\tA_FXWC1, epcm->capture_cr_val,\n\t\t\t\t\tA_FXWC2, epcm->capture_cr_val2,\n\t\t\t\t\tREGLIST_END);\n\t\t\t\tdev_dbg(emu->card->dev,\n\t\t\t\t\t\"cr_val=0x%x, cr_val2=0x%x\\n\",\n\t\t\t\t\tepcm->capture_cr_val,\n\t\t\t\t\tepcm->capture_cr_val2);\n\t\t\t} else\n\t\t\t\tsnd_emu10k1_ptr_write(emu, FXWC, 0, epcm->capture_cr_val);\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tbreak;\n\t\t}\n\t\tsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, epcm->capture_bs_val);\n\t\tepcm->running = 1;\n\t\tepcm->first_ptr = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tepcm->running = 0;\n\t\tsnd_emu10k1_intr_disable(emu, epcm->capture_inte);\n\t\toutl(epcm->capture_ipr, emu->port + IPR);\n\t\tsnd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0, 0);\n\t\tswitch (epcm->type) {\n\t\tcase CAPTURE_AC97ADC:\n\t\t\tsnd_emu10k1_ptr_write(emu, ADCCR, 0, 0);\n\t\t\tbreak;\n\t\tcase CAPTURE_EFX:\n\t\t\tif (emu->audigy) {\n\t\t\t\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\t\t\t\tA_FXWC1, 0,\n\t\t\t\t\tA_FXWC2, 0,\n\t\t\t\t\tREGLIST_END);\n\t\t\t} else\n\t\t\t\tsnd_emu10k1_ptr_write(emu, FXWC, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\tspin_unlock(&emu->reg_lock);\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t snd_emu10k1_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tint ptr;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\n\tptr = snd_emu10k1_ptr_read(emu, CCCA, epcm->voices[0]->number) & 0x00ffffff;\n\tptr -= epcm->ccca_start_addr;\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tptr -= 64 - 3;\n\tif (ptr < 0)\n\t\tptr += runtime->buffer_size;\n\n\t \n\treturn ptr;\n}\n\nstatic u64 snd_emu10k1_efx_playback_voice_mask(struct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t       int channels)\n{\n\tu64 mask = 0;\n\n\tfor (int i = 0; i < channels; i++) {\n\t\tint voice = epcm->voices[i]->number;\n\t\tmask |= 1ULL << voice;\n\t}\n\treturn mask;\n}\n\nstatic void snd_emu10k1_efx_playback_freeze_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t\t   struct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t\t   int channels)\n{\n\tfor (int i = 0; i < channels; i++) {\n\t\tint voice = epcm->voices[i]->number;\n\t\tsnd_emu10k1_ptr_write(emu, CPF_STOP, voice, 1);\n\t\tsnd_emu10k1_playback_commit_pitch(emu, voice, PITCH_48000 << 16);\n\t}\n}\n\nstatic void snd_emu10k1_efx_playback_unmute_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t\t   struct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t\t   int channels)\n{\n\tfor (int i = 0; i < channels; i++)\n\t\tsnd_emu10k1_playback_unmute_voice(emu, epcm->voices[i], false, true,\n\t\t\t\t\t\t  &emu->efx_pcm_mixer[i]);\n}\n\nstatic void snd_emu10k1_efx_playback_stop_voices(struct snd_emu10k1 *emu,\n\t\t\t\t\t\t struct snd_emu10k1_pcm *epcm,\n\t\t\t\t\t\t int channels)\n{\n\tfor (int i = 0; i < channels; i++)\n\t\tsnd_emu10k1_playback_stop_voice(emu, epcm->voices[i]);\n\tsnd_emu10k1_playback_set_stopped(emu, epcm);\n\n\tfor (int i = 0; i < channels; i++)\n\t\tsnd_emu10k1_playback_mute_voice(emu, epcm->voices[i]);\n}\n\nstatic int snd_emu10k1_efx_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t        int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tu64 mask;\n\tint result = 0;\n\n\tspin_lock(&emu->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tmask = snd_emu10k1_efx_playback_voice_mask(\n\t\t\t\tepcm, runtime->channels);\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\n\t\t\t\n\t\t\tsnd_emu10k1_voice_set_loop_stop_multiple(emu, mask);\n\t\t\tsnd_emu10k1_efx_playback_freeze_voices(\n\t\t\t\t\temu, epcm, runtime->channels);\n\t\t\tsnd_emu10k1_playback_prepare_voices(\n\t\t\t\t\temu, epcm, true, false, runtime->channels);\n\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tsnd_emu10k1_efx_playback_unmute_voices(emu, epcm, runtime->channels);\n\n\t\t\tsnd_emu10k1_playback_set_running(emu, epcm);\n\t\t\tresult = snd_emu10k1_voice_clear_loop_stop_multiple_atomic(emu, mask);\n\t\t\tif (result == 0) {\n\t\t\t\t\n\t\t\t\tsnd_emu10k1_playback_trigger_voice(emu, epcm->extra);\n\t\t\t\tgoto leave;\n\t\t\t}\n\n\t\t\tsnd_emu10k1_efx_playback_stop_voices(\n\t\t\t\t\temu, epcm, runtime->channels);\n\n\t\t\tif (result != -EAGAIN)\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\tsnd_emu10k1_voice_clear_loop_stop_multiple(emu, mask);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tsnd_emu10k1_playback_stop_voice(emu, epcm->extra);\n\t\tsnd_emu10k1_efx_playback_stop_voices(\n\t\t\t\temu, epcm, runtime->channels);\n\n\t\tepcm->resume_pos = snd_emu10k1_playback_pointer(substream);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\nleave:\n\tspin_unlock(&emu->reg_lock);\n\treturn result;\n}\n\n\nstatic snd_pcm_uframes_t snd_emu10k1_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm = runtime->private_data;\n\tunsigned int ptr;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\tif (epcm->first_ptr) {\n\t\tudelay(50);\t \n\t\tepcm->first_ptr = 0;\n\t}\n\tptr = snd_emu10k1_ptr_read(emu, epcm->capture_idx_reg, 0) & 0x0000ffff;\n\treturn bytes_to_frames(runtime, ptr);\n}\n\n \n\nstatic const struct snd_pcm_hardware snd_emu10k1_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_96000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic const struct snd_pcm_hardware snd_emu10k1_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(64*1024),\n\t.period_bytes_min =\t384,\n\t.period_bytes_max =\t(64*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_emu10k1_capture_efx =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t16,\n\t.buffer_bytes_max =\t(64*1024),\n\t.period_bytes_min =\t384,\n\t.period_bytes_max =\t(64*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\n \n\nstatic void snd_emu10k1_pcm_mixer_notify1(struct snd_emu10k1 *emu, struct snd_kcontrol *kctl, int idx, int activate)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (! kctl)\n\t\treturn;\n\tif (activate)\n\t\tkctl->vd[idx].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\telse\n\t\tkctl->vd[idx].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(emu->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t       snd_ctl_build_ioff(&id, kctl, idx));\n}\n\nstatic void snd_emu10k1_pcm_mixer_notify(struct snd_emu10k1 *emu, int idx, int activate)\n{\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_routing, idx, activate);\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_volume, idx, activate);\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_attn, idx, activate);\n}\n\nstatic void snd_emu10k1_pcm_efx_mixer_notify(struct snd_emu10k1 *emu, int idx, int activate)\n{\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_routing, idx, activate);\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_volume, idx, activate);\n\tsnd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_attn, idx, activate);\n}\n\nstatic void snd_emu10k1_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic int snd_emu10k1_efx_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm_mixer *mix;\n\tint i;\n\n\tfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\n\t\tmix = &emu->efx_pcm_mixer[i];\n\t\tmix->epcm = NULL;\n\t\tsnd_emu10k1_pcm_efx_mixer_notify(emu, i, 0);\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_playback_set_constraints(struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\t\n\t\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\t\n\t\n\terr = snd_pcm_hw_constraint_minmax(\n\t\t\truntime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 128, UINT_MAX);\n\treturn err;\n}\n\nstatic int snd_emu10k1_efx_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm *epcm;\n\tstruct snd_emu10k1_pcm_mixer *mix;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint i, j, err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = emu;\n\tepcm->type = PLAYBACK_EFX;\n\tepcm->substream = substream;\n\t\n\truntime->private_data = epcm;\n\truntime->private_free = snd_emu10k1_pcm_free_substream;\n\truntime->hw = snd_emu10k1_efx_playback;\n\tif (emu->card_capabilities->emu_model)\n\t\tsnd_emu1010_constrain_efx_rate(emu, runtime);\n\terr = snd_emu10k1_playback_set_constraints(runtime);\n\tif (err < 0) {\n\t\tkfree(epcm);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < NUM_EFX_PLAYBACK; i++) {\n\t\tmix = &emu->efx_pcm_mixer[i];\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tmix->send_routing[0][j] = i + j;\n\t\tmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\n\t\tmix->send_volume[0][0] = 255;\n\t\tmix->attn[0] = 0x8000;\n\t\tmix->epcm = epcm;\n\t\tsnd_emu10k1_pcm_efx_mixer_notify(emu, i, 1);\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm *epcm;\n\tstruct snd_emu10k1_pcm_mixer *mix;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint i, err, sample_rate;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = emu;\n\tepcm->type = PLAYBACK_EMUVOICE;\n\tepcm->substream = substream;\n\truntime->private_data = epcm;\n\truntime->private_free = snd_emu10k1_pcm_free_substream;\n\truntime->hw = snd_emu10k1_playback;\n\terr = snd_emu10k1_playback_set_constraints(runtime);\n\tif (err < 0) {\n\t\tkfree(epcm);\n\t\treturn err;\n\t}\n\tif (emu->card_capabilities->emu_model)\n\t\tsample_rate = emu->emu1010.word_clock;\n\telse\n\t\tsample_rate = 48000;\n\terr = snd_pcm_hw_rule_noresample(runtime, sample_rate);\n\tif (err < 0) {\n\t\tkfree(epcm);\n\t\treturn err;\n\t}\n\tmix = &emu->pcm_mixer[substream->number];\n\tfor (i = 0; i < 8; i++)\n\t\tmix->send_routing[0][i] = mix->send_routing[1][i] = mix->send_routing[2][i] = i;\n\tmemset(&mix->send_volume, 0, sizeof(mix->send_volume));\n\tmix->send_volume[0][0] = mix->send_volume[0][1] =\n\tmix->send_volume[1][0] = mix->send_volume[2][1] = 255;\n\tmix->attn[0] = mix->attn[1] = mix->attn[2] = 0x8000;\n\tmix->epcm = epcm;\n\tsnd_emu10k1_pcm_mixer_notify(emu, substream->number, 1);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm_mixer *mix = &emu->pcm_mixer[substream->number];\n\n\tmix->epcm = NULL;\n\tsnd_emu10k1_pcm_mixer_notify(emu, substream->number, 0);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_pcm *epcm;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = emu;\n\tepcm->type = CAPTURE_AC97ADC;\n\tepcm->substream = substream;\n\tepcm->capture_ipr = IPR_ADCBUFFULL|IPR_ADCBUFHALFFULL;\n\tepcm->capture_inte = INTE_ADCBUFENABLE;\n\tepcm->capture_ba_reg = ADCBA;\n\tepcm->capture_bs_reg = ADCBS;\n\tepcm->capture_idx_reg = emu->audigy ? A_ADCIDX : ADCIDX;\n\truntime->private_data = epcm;\n\truntime->private_free = snd_emu10k1_pcm_free_substream;\n\truntime->hw = snd_emu10k1_capture;\n\tsnd_emu10k1_constrain_capture_rates(emu, runtime);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   &hw_constraints_capture_buffer_sizes);\n\temu->capture_interrupt = snd_emu10k1_pcm_ac97adc_interrupt;\n\temu->pcm_capture_substream = substream;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\n\temu->capture_interrupt = NULL;\n\temu->pcm_capture_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_mic_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = emu;\n\tepcm->type = CAPTURE_AC97MIC;\n\tepcm->substream = substream;\n\tepcm->capture_ipr = IPR_MICBUFFULL|IPR_MICBUFHALFFULL;\n\tepcm->capture_inte = INTE_MICBUFENABLE;\n\tepcm->capture_ba_reg = MICBA;\n\tepcm->capture_bs_reg = MICBS;\n\tepcm->capture_idx_reg = emu->audigy ? A_MICIDX : MICIDX;\n\tsubstream->runtime->private_data = epcm;\n\tsubstream->runtime->private_free = snd_emu10k1_pcm_free_substream;\n\truntime->hw = snd_emu10k1_capture;\n\truntime->hw.rates = SNDRV_PCM_RATE_8000;\n\truntime->hw.rate_min = runtime->hw.rate_max = 8000;\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   &hw_constraints_capture_buffer_sizes);\n\temu->capture_mic_interrupt = snd_emu10k1_pcm_ac97mic_interrupt;\n\temu->pcm_capture_mic_substream = substream;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_mic_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\n\temu->capture_mic_interrupt = NULL;\n\temu->pcm_capture_mic_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_efx_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint nefx = emu->audigy ? 64 : 32;\n\tint idx, err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = emu;\n\tepcm->type = CAPTURE_EFX;\n\tepcm->substream = substream;\n\tepcm->capture_ipr = IPR_EFXBUFFULL|IPR_EFXBUFHALFFULL;\n\tepcm->capture_inte = INTE_EFXBUFENABLE;\n\tepcm->capture_ba_reg = FXBA;\n\tepcm->capture_bs_reg = FXBS;\n\tepcm->capture_idx_reg = FXIDX;\n\tsubstream->runtime->private_data = epcm;\n\tsubstream->runtime->private_free = snd_emu10k1_pcm_free_substream;\n\truntime->hw = snd_emu10k1_capture_efx;\n\tif (emu->card_capabilities->emu_model) {\n\t\tsnd_emu1010_constrain_efx_rate(emu, runtime);\n\t\t \n#if 0\n\t\t \n\t\truntime->hw.channels_min = runtime->hw.channels_max = 4;\n#endif\n#if 0\n\t\t \n\t\truntime->hw.channels_min = runtime->hw.channels_max = 2;\n#endif\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;\n\t} else {\n\t\tspin_lock_irq(&emu->reg_lock);\n\t\truntime->hw.channels_min = runtime->hw.channels_max = 0;\n\t\tfor (idx = 0; idx < nefx; idx++) {\n\t\t\tif (emu->efx_voices_mask[idx/32] & (1 << (idx%32))) {\n\t\t\t\truntime->hw.channels_min++;\n\t\t\t\truntime->hw.channels_max++;\n\t\t\t}\n\t\t}\n\t\tepcm->capture_cr_val = emu->efx_voices_mask[0];\n\t\tepcm->capture_cr_val2 = emu->efx_voices_mask[1];\n\t\tspin_unlock_irq(&emu->reg_lock);\n\t}\n\terr = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t &hw_constraints_efx_capture_channels);\n\tif (err < 0) {\n\t\tkfree(epcm);\n\t\treturn err;\n\t}\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t   &hw_constraints_capture_buffer_sizes);\n\temu->capture_efx_interrupt = snd_emu10k1_pcm_efx_interrupt;\n\temu->pcm_capture_efx_substream = substream;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_capture_efx_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\n\temu->capture_efx_interrupt = NULL;\n\temu->pcm_capture_efx_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_emu10k1_playback_ops = {\n\t.open =\t\t\tsnd_emu10k1_playback_open,\n\t.close =\t\tsnd_emu10k1_playback_close,\n\t.hw_params =\t\tsnd_emu10k1_playback_hw_params,\n\t.hw_free =\t\tsnd_emu10k1_playback_hw_free,\n\t.prepare =\t\tsnd_emu10k1_playback_prepare,\n\t.trigger =\t\tsnd_emu10k1_playback_trigger,\n\t.pointer =\t\tsnd_emu10k1_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_emu10k1_capture_ops = {\n\t.open =\t\t\tsnd_emu10k1_capture_open,\n\t.close =\t\tsnd_emu10k1_capture_close,\n\t.prepare =\t\tsnd_emu10k1_capture_prepare,\n\t.trigger =\t\tsnd_emu10k1_capture_trigger,\n\t.pointer =\t\tsnd_emu10k1_capture_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_emu10k1_efx_playback_ops = {\n\t.open =\t\t\tsnd_emu10k1_efx_playback_open,\n\t.close =\t\tsnd_emu10k1_efx_playback_close,\n\t.hw_params =\t\tsnd_emu10k1_playback_hw_params,\n\t.hw_free =\t\tsnd_emu10k1_playback_hw_free,\n\t.prepare =\t\tsnd_emu10k1_efx_playback_prepare,\n\t.trigger =\t\tsnd_emu10k1_efx_playback_trigger,\n\t.pointer =\t\tsnd_emu10k1_playback_pointer,\n};\n\nint snd_emu10k1_pcm(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\n\terr = snd_pcm_new(emu->card, \"emu10k1\", device, 32, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = emu;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tstrcpy(pcm->name, \"ADC Capture/Standard PCM Playback\");\n\temu->pcm = pcm;\n\n\t \n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\n\t\tsnd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t      &emu->pci->dev,\n\t\t\t\t\t      64*1024, 64*1024);\n\n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; substream; substream = substream->next)\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &emu->pci->dev, 64*1024, 64*1024);\n\n\treturn 0;\n}\n\nint snd_emu10k1_pcm_multi(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tint err;\n\n\terr = snd_pcm_new(emu->card, \"emu10k1\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = emu;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_efx_playback_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tstrcpy(pcm->name, \"Multichannel Playback\");\n\temu->pcm_multi = pcm;\n\n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\n\t\tsnd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t      &emu->pci->dev,\n\t\t\t\t\t      64*1024, 64*1024);\n\n\treturn 0;\n}\n\n\nstatic const struct snd_pcm_ops snd_emu10k1_capture_mic_ops = {\n\t.open =\t\t\tsnd_emu10k1_capture_mic_open,\n\t.close =\t\tsnd_emu10k1_capture_mic_close,\n\t.prepare =\t\tsnd_emu10k1_capture_prepare,\n\t.trigger =\t\tsnd_emu10k1_capture_trigger,\n\t.pointer =\t\tsnd_emu10k1_capture_pointer,\n};\n\nint snd_emu10k1_pcm_mic(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(emu->card, \"emu10k1 mic\", device, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = emu;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_mic_ops);\n\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"Mic Capture\");\n\temu->pcm_mic = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &emu->pci->dev,\n\t\t\t\t       64*1024, 64*1024);\n\n\treturn 0;\n}\n\nstatic int snd_emu10k1_pcm_efx_voices_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint nefx = emu->audigy ? 64 : 32;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = nefx;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_pcm_efx_voices_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint nefx = emu->audigy ? 64 : 32;\n\tint idx;\n\t\n\tfor (idx = 0; idx < nefx; idx++)\n\t\tucontrol->value.integer.value[idx] = (emu->efx_voices_mask[idx / 32] & (1 << (idx % 32))) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_pcm_efx_voices_mask_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int nval[2], bits;\n\tint nefx = emu->audigy ? 64 : 32;\n\tint change, idx;\n\t\n\tnval[0] = nval[1] = 0;\n\tfor (idx = 0, bits = 0; idx < nefx; idx++)\n\t\tif (ucontrol->value.integer.value[idx]) {\n\t\t\tnval[idx / 32] |= 1 << (idx % 32);\n\t\t\tbits++;\n\t\t}\n\n\tif (bits == 9 || bits == 11 || bits == 13 || bits == 15 || bits > 16)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tchange = (nval[0] != emu->efx_voices_mask[0]) ||\n\t\t(nval[1] != emu->efx_voices_mask[1]);\n\temu->efx_voices_mask[0] = nval[0];\n\temu->efx_voices_mask[1] = nval[1];\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_pcm_efx_voices_mask = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"Captured FX8010 Outputs\",\n\t.info = snd_emu10k1_pcm_efx_voices_mask_info,\n\t.get = snd_emu10k1_pcm_efx_voices_mask_get,\n\t.put = snd_emu10k1_pcm_efx_voices_mask_put\n};\n\nstatic const struct snd_pcm_ops snd_emu10k1_capture_efx_ops = {\n\t.open =\t\t\tsnd_emu10k1_capture_efx_open,\n\t.close =\t\tsnd_emu10k1_capture_efx_close,\n\t.prepare =\t\tsnd_emu10k1_capture_prepare,\n\t.trigger =\t\tsnd_emu10k1_capture_trigger,\n\t.pointer =\t\tsnd_emu10k1_capture_pointer,\n};\n\n\n \n\n#define INITIAL_TRAM_SHIFT     14\n#define INITIAL_TRAM_POS(size) ((((size) / 2) - INITIAL_TRAM_SHIFT) - 1)\n\nstatic void snd_emu10k1_fx8010_playback_irq(struct snd_emu10k1 *emu, void *private_data)\n{\n\tstruct snd_pcm_substream *substream = private_data;\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic void snd_emu10k1_fx8010_playback_tram_poke1(unsigned short *dst_left,\n\t\t\t\t\t\t   unsigned short *dst_right,\n\t\t\t\t\t\t   unsigned short *src,\n\t\t\t\t\t\t   unsigned int count,\n\t\t\t\t\t\t   unsigned int tram_shift)\n{\n\t \n\tif ((tram_shift & 1) == 0) {\n\t\twhile (count--) {\n\t\t\t*dst_left-- = *src++;\n\t\t\t*dst_right-- = *src++;\n\t\t}\n\t} else {\n\t\twhile (count--) {\n\t\t\t*dst_right-- = *src++;\n\t\t\t*dst_left-- = *src++;\n\t\t}\n\t}\n}\n\nstatic void fx8010_pb_trans_copy(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\tunsigned int tram_size = pcm->buffer_size;\n\tunsigned short *src = (unsigned short *)(substream->runtime->dma_area + rec->sw_data);\n\tunsigned int frames = bytes >> 2, count;\n\tunsigned int tram_pos = pcm->tram_pos;\n\tunsigned int tram_shift = pcm->tram_shift;\n\n\twhile (frames > tram_pos) {\n\t\tcount = tram_pos + 1;\n\t\tsnd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + tram_pos,\n\t\t\t\t\t\t       (unsigned short *)emu->fx8010.etram_pages.area + tram_pos + tram_size / 2,\n\t\t\t\t\t\t       src, count, tram_shift);\n\t\tsrc += count * 2;\n\t\tframes -= count;\n\t\ttram_pos = (tram_size / 2) - 1;\n\t\ttram_shift++;\n\t}\n\tsnd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + tram_pos,\n\t\t\t\t\t       (unsigned short *)emu->fx8010.etram_pages.area + tram_pos + tram_size / 2,\n\t\t\t\t\t       src, frames, tram_shift);\n\ttram_pos -= frames;\n\tpcm->tram_pos = tram_pos;\n\tpcm->tram_shift = tram_shift;\n}\n\nstatic int snd_emu10k1_fx8010_playback_transfer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\n\treturn snd_pcm_indirect_playback_transfer(substream, &pcm->pcm_rec,\n\t\t\t\t\t\t  fx8010_pb_trans_copy);\n}\n\nstatic int snd_emu10k1_fx8010_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\tunsigned int i;\n\n\tfor (i = 0; i < pcm->channels; i++)\n\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + 0x80 + pcm->etram[i], 0, 0);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_fx8010_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\tunsigned int i;\n\t\n\t \n\tmemset(&pcm->pcm_rec, 0, sizeof(pcm->pcm_rec));\n\tpcm->pcm_rec.hw_buffer_size = pcm->buffer_size * 2;  \n\tpcm->pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tpcm->tram_pos = INITIAL_TRAM_POS(pcm->buffer_size);\n\tpcm->tram_shift = 0;\n\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\temu->gpr_base + pcm->gpr_running, 0,\t \n\t\temu->gpr_base + pcm->gpr_trigger, 0,\t \n\t\temu->gpr_base + pcm->gpr_size, runtime->buffer_size,\n\t\temu->gpr_base + pcm->gpr_ptr, 0,\t \n\t\temu->gpr_base + pcm->gpr_count, runtime->period_size,\n\t\temu->gpr_base + pcm->gpr_tmpcount, runtime->period_size,\n\t\tREGLIST_END);\n\tfor (i = 0; i < pcm->channels; i++)\n\t\tsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + 0x80 + pcm->etram[i], 0, (TANKMEMADDRREG_READ|TANKMEMADDRREG_ALIGN) + i * (runtime->buffer_size / pcm->channels));\n\treturn 0;\n}\n\nstatic int snd_emu10k1_fx8010_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\tint result = 0;\n\n\tspin_lock(&emu->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n#ifdef EMU10K1_SET_AC3_IEC958\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tunsigned int bits;\n\t\t\tbits = SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\t\t       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC | SPCS_GENERATIONSTATUS |\n\t\t\t       0x00001200 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT | SPCS_NOTAUDIODATA;\n\t\t\tsnd_emu10k1_ptr_write(emu, SPCS0 + i, 0, bits);\n\t\t}\n\t}\n#endif\n\t\tresult = snd_emu10k1_fx8010_register_irq_handler(emu, snd_emu10k1_fx8010_playback_irq, pcm->gpr_running, substream, &pcm->irq);\n\t\tif (result < 0)\n\t\t\tgoto __err;\n\t\tsnd_emu10k1_fx8010_playback_transfer(substream);\t \n\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_trigger, 0, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tsnd_emu10k1_fx8010_unregister_irq_handler(emu, &pcm->irq);\n\t\tsnd_emu10k1_ptr_write(emu, emu->gpr_base + pcm->gpr_trigger, 0, 0);\n\t\tpcm->tram_pos = INITIAL_TRAM_POS(pcm->buffer_size);\n\t\tpcm->tram_shift = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n      __err:\n\tspin_unlock(&emu->reg_lock);\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t snd_emu10k1_fx8010_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\tsize_t ptr;  \n\n\tif (!snd_emu10k1_ptr_read(emu, emu->gpr_base + pcm->gpr_trigger, 0))\n\t\treturn 0;\n\tptr = snd_emu10k1_ptr_read(emu, emu->gpr_base + pcm->gpr_ptr, 0) << 2;\n\treturn snd_pcm_indirect_playback_pointer(substream, &pcm->pcm_rec, ptr);\n}\n\nstatic const struct snd_pcm_hardware snd_emu10k1_fx8010_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t   SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t1,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t1024,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_emu10k1_fx8010_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\n\truntime->hw = snd_emu10k1_fx8010_playback;\n\truntime->hw.channels_min = runtime->hw.channels_max = pcm->channels;\n\truntime->hw.period_bytes_max = (pcm->buffer_size * 2) / 2;\n\tspin_lock_irq(&emu->reg_lock);\n\tif (pcm->valid == 0) {\n\t\tspin_unlock_irq(&emu->reg_lock);\n\t\treturn -ENODEV;\n\t}\n\tpcm->opened = 1;\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_emu10k1_fx8010_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];\n\n\tspin_lock_irq(&emu->reg_lock);\n\tpcm->opened = 0;\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_emu10k1_fx8010_playback_ops = {\n\t.open =\t\t\tsnd_emu10k1_fx8010_playback_open,\n\t.close =\t\tsnd_emu10k1_fx8010_playback_close,\n\t.hw_free =\t\tsnd_emu10k1_fx8010_playback_hw_free,\n\t.prepare =\t\tsnd_emu10k1_fx8010_playback_prepare,\n\t.trigger =\t\tsnd_emu10k1_fx8010_playback_trigger,\n\t.pointer =\t\tsnd_emu10k1_fx8010_playback_pointer,\n\t.ack =\t\t\tsnd_emu10k1_fx8010_playback_transfer,\n};\n\nint snd_emu10k1_pcm_efx(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\n\terr = snd_pcm_new(emu->card, \"emu10k1 efx\", device, emu->audigy ? 0 : 8, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = emu;\n\n\tif (!emu->audigy)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1_fx8010_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1_capture_efx_ops);\n\n\tpcm->info_flags = 0;\n\tif (emu->audigy)\n\t\tstrcpy(pcm->name, \"Multichannel Capture\");\n\telse\n\t\tstrcpy(pcm->name, \"Multichannel Capture/PT Playback\");\n\temu->pcm_efx = pcm;\n\n\tif (!emu->card_capabilities->emu_model) {\n\t\t\n\t\t\n\t\t\n\t\tif (emu->audigy) {\n\t\t\temu->efx_voices_mask[0] = 0;\n\t\t\temu->efx_voices_mask[1] = 0xffff;\n\t\t} else {\n\t\t\temu->efx_voices_mask[0] = 0xffff0000;\n\t\t\temu->efx_voices_mask[1] = 0;\n\t\t}\n\t\tkctl = snd_ctl_new1(&snd_emu10k1_pcm_efx_voices_mask, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tkctl->id.device = device;\n\t\terr = snd_ctl_add(emu->card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\t\n\t\t\n\t\t\n\t}\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &emu->pci->dev,\n\t\t\t\t       64*1024, 64*1024);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}