{
  "module_name": "emu10k1x.c",
  "hash_id": "71b844917b2da6327cf57b9a98eb7438df935d806b53c4902fc544556302b438",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emu10k1x.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n#include <sound/rawmidi.h>\n\nMODULE_AUTHOR(\"Francisco Moraes <fmoraes@nc.rr.com>\");\nMODULE_DESCRIPTION(\"EMU10K1X\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the EMU10K1X soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the EMU10K1X soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable the EMU10K1X soundcard.\");\n\n\n\n \n \n \n\n#define PTR\t\t\t0x00\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\n#define DATA\t\t\t0x04\t\t \n\n#define IPR\t\t\t0x08\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n#define IPR_MIDITRANSBUFEMPTY   0x00000001\t \n#define IPR_MIDIRECVBUFEMPTY    0x00000002\t \n#define IPR_CH_0_LOOP           0x00000800       \n#define IPR_CH_0_HALF_LOOP      0x00000100       \n#define IPR_CAP_0_LOOP          0x00080000       \n#define IPR_CAP_0_HALF_LOOP     0x00010000       \n\n#define INTE\t\t\t0x0c\t\t \n#define INTE_MIDITXENABLE       0x00000001\t \n#define INTE_MIDIRXENABLE       0x00000002\t \n#define INTE_CH_0_LOOP          0x00000800       \n#define INTE_CH_0_HALF_LOOP     0x00000100       \n#define INTE_CAP_0_LOOP         0x00080000       \n#define INTE_CAP_0_HALF_LOOP    0x00010000       \n\n#define HCFG\t\t\t0x14\t\t \n\n#define HCFG_LOCKSOUNDCACHE\t0x00000008\t \n\t\t\t\t\t\t \n#define HCFG_AUDIOENABLE\t0x00000001\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n#define GPIO\t\t\t0x18\t\t \n\n\n#define AC97DATA\t\t0x1c\t\t \n\n#define AC97ADDRESS\t\t0x1e\t\t \n\n \n \n \n#define PLAYBACK_LIST_ADDR\t0x00\t\t \n\t\t\t\t\t\t \n#define PLAYBACK_LIST_SIZE\t0x01\t\t \n#define PLAYBACK_LIST_PTR\t0x02\t\t \n#define PLAYBACK_DMA_ADDR\t0x04\t\t \n#define PLAYBACK_PERIOD_SIZE\t0x05\t\t \n#define PLAYBACK_POINTER\t0x06\t\t \n#define PLAYBACK_UNKNOWN1       0x07\n#define PLAYBACK_UNKNOWN2       0x08\n\n \n#define CAPTURE_DMA_ADDR\t0x10\t\t \n#define CAPTURE_BUFFER_SIZE\t0x11\t\t \n#define CAPTURE_POINTER\t\t0x12\t\t \n#define CAPTURE_UNKNOWN         0x13\n\n \n\n#define TRIGGER_CHANNEL         0x40             \n#define TRIGGER_CHANNEL_0       0x00000001       \n#define TRIGGER_CHANNEL_1       0x00000002       \n#define TRIGGER_CHANNEL_2       0x00000004       \n#define TRIGGER_CAPTURE         0x00000100       \n\n#define ROUTING                 0x41             \n#define ROUTING_FRONT_LEFT      0x00000001\n#define ROUTING_FRONT_RIGHT     0x00000002\n#define ROUTING_REAR_LEFT       0x00000004\n#define ROUTING_REAR_RIGHT      0x00000008\n#define ROUTING_CENTER_LFE      0x00010000\n\n#define SPCS0\t\t\t0x42\t\t \n\n#define SPCS1\t\t\t0x43\t\t \n\n#define SPCS2\t\t\t0x44\t\t \n\n#define SPCS_CLKACCYMASK\t0x30000000\t \n#define SPCS_CLKACCY_1000PPM\t0x00000000\t \n#define SPCS_CLKACCY_50PPM\t0x10000000\t \n#define SPCS_CLKACCY_VARIABLE\t0x20000000\t \n#define SPCS_SAMPLERATEMASK\t0x0f000000\t \n#define SPCS_SAMPLERATE_44\t0x00000000\t \n#define SPCS_SAMPLERATE_48\t0x02000000\t \n#define SPCS_SAMPLERATE_32\t0x03000000\t \n#define SPCS_CHANNELNUMMASK\t0x00f00000\t \n#define SPCS_CHANNELNUM_UNSPEC\t0x00000000\t \n#define SPCS_CHANNELNUM_LEFT\t0x00100000\t \n#define SPCS_CHANNELNUM_RIGHT\t0x00200000\t \n#define SPCS_SOURCENUMMASK\t0x000f0000\t \n#define SPCS_SOURCENUM_UNSPEC\t0x00000000\t \n#define SPCS_GENERATIONSTATUS\t0x00008000\t \n#define SPCS_CATEGORYCODEMASK\t0x00007f00\t \n#define SPCS_MODEMASK\t\t0x000000c0\t \n#define SPCS_EMPHASISMASK\t0x00000038\t \n#define SPCS_EMPHASIS_NONE\t0x00000000\t \n#define SPCS_EMPHASIS_50_15\t0x00000008\t \n#define SPCS_COPYRIGHT\t\t0x00000004\t \n#define SPCS_NOTAUDIODATA\t0x00000002\t \n#define SPCS_PROFESSIONAL\t0x00000001\t \n\n#define SPDIF_SELECT\t\t0x45\t\t \n\n \n#define MUDATA\t\t0x47\n#define MUCMD\t\t0x48\n#define MUSTAT\t\tMUCMD\n\n \n\n \n\nstruct emu10k1x_voice {\n\tstruct emu10k1x *emu;\n\tint number;\n\tint use;\n  \n\tstruct emu10k1x_pcm *epcm;\n};\n\nstruct emu10k1x_pcm {\n\tstruct emu10k1x *emu;\n\tstruct snd_pcm_substream *substream;\n\tstruct emu10k1x_voice *voice;\n\tunsigned short running;\n};\n\nstruct emu10k1x_midi {\n\tstruct emu10k1x *emu;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *substream_input;\n\tstruct snd_rawmidi_substream *substream_output;\n\tunsigned int midi_mode;\n\tspinlock_t input_lock;\n\tspinlock_t output_lock;\n\tspinlock_t open_lock;\n\tint tx_enable, rx_enable;\n\tint port;\n\tint ipr_tx, ipr_rx;\n\tvoid (*interrupt)(struct emu10k1x *emu, unsigned int status);\n};\n\n\nstruct emu10k1x {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\n\tunsigned long port;\n\tint irq;\n\n\tunsigned char revision;\t\t \n\tunsigned int serial;             \n\tunsigned short model;\t\t \n\n\tspinlock_t emu_lock;\n\tspinlock_t voice_lock;\n\n\tstruct snd_ac97 *ac97;\n\tstruct snd_pcm *pcm;\n\n\tstruct emu10k1x_voice voices[3];\n\tstruct emu10k1x_voice capture_voice;\n\tu32 spdif_bits[3]; \n\n\tstruct snd_dma_buffer *dma_buffer;\n\n\tstruct emu10k1x_midi midi;\n};\n\n \nstatic const struct snd_pcm_hardware snd_emu10k1x_playback_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | \n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(32*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(16*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t8,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_emu10k1x_capture_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | \n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(32*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(16*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nstatic unsigned int snd_emu10k1x_ptr_read(struct emu10k1x * emu, \n\t\t\t\t\t  unsigned int reg, \n\t\t\t\t\t  unsigned int chn)\n{\n\tunsigned long flags;\n\tunsigned int regptr, val;\n  \n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + PTR);\n\tval = inl(emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nstatic void snd_emu10k1x_ptr_write(struct emu10k1x *emu, \n\t\t\t\t   unsigned int reg, \n\t\t\t\t   unsigned int chn, \n\t\t\t\t   unsigned int data)\n{\n\tunsigned int regptr;\n\tunsigned long flags;\n\n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + PTR);\n\toutl(data, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_emu10k1x_intr_enable(struct emu10k1x *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int intr_enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tintr_enable = inl(emu->port + INTE) | intrenb;\n\toutl(intr_enable, emu->port + INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_emu10k1x_intr_disable(struct emu10k1x *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int intr_enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tintr_enable = inl(emu->port + INTE) & ~intrenb;\n\toutl(intr_enable, emu->port + INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_emu10k1x_gpio_write(struct emu10k1x *emu, unsigned int value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(value, emu->port + GPIO);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_emu10k1x_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic void snd_emu10k1x_pcm_interrupt(struct emu10k1x *emu, struct emu10k1x_voice *voice)\n{\n\tstruct emu10k1x_pcm *epcm;\n\n\tepcm = voice->epcm;\n\tif (!epcm)\n\t\treturn;\n\tif (epcm->substream == NULL)\n\t\treturn;\n#if 0\n\tdev_info(emu->card->dev,\n\t\t \"IRQ: position = 0x%x, period = 0x%x, size = 0x%x\\n\",\n\t\t   epcm->substream->ops->pointer(epcm->substream),\n\t\t   snd_pcm_lib_period_bytes(epcm->substream),\n\t\t   snd_pcm_lib_buffer_bytes(epcm->substream));\n#endif\n\tsnd_pcm_period_elapsed(epcm->substream);\n}\n\n \nstatic int snd_emu10k1x_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *chip = snd_pcm_substream_chip(substream);\n\tstruct emu10k1x_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\tif (err < 0)\n                return err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\tepcm->emu = chip;\n\tepcm->substream = substream;\n  \n\truntime->private_data = epcm;\n\truntime->private_free = snd_emu10k1x_pcm_free_substream;\n  \n\truntime->hw = snd_emu10k1x_playback_hw;\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_playback_close(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\n\tif (! epcm->voice) {\n\t\tepcm->voice = &epcm->emu->voices[substream->pcm->device];\n\t\tepcm->voice->use = 1;\n\t\tepcm->voice->epcm = epcm;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm;\n\n\tif (runtime->private_data == NULL)\n\t\treturn 0;\n\t\n\tepcm = runtime->private_data;\n\n\tif (epcm->voice) {\n\t\tepcm->voice->use = 0;\n\t\tepcm->voice->epcm = NULL;\n\t\tepcm->voice = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\tint voice = epcm->voice->number;\n\tu32 *table_base = (u32 *)(emu->dma_buffer->area+1024*voice);\n\tu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\n\tint i;\n\t\n\tfor(i = 0; i < runtime->periods; i++) {\n\t\t*table_base++=runtime->dma_addr+(i*period_size_bytes);\n\t\t*table_base++=period_size_bytes<<16;\n\t}\n\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_ADDR, voice, emu->dma_buffer->addr+1024*voice);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_SIZE, voice, (runtime->periods - 1) << 19);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_PTR, voice, 0);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_POINTER, voice, 0);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN1, voice, 0);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN2, voice, 0);\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_DMA_ADDR, voice, runtime->dma_addr);\n\n\tsnd_emu10k1x_ptr_write(emu, PLAYBACK_PERIOD_SIZE, voice, frames_to_bytes(runtime, runtime->period_size)<<16);\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\tint channel = epcm->voice->number;\n\tint result = 0;\n\n\t \n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif(runtime->periods == 2)\n\t\t\tsnd_emu10k1x_intr_enable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);\n\t\telse\n\t\t\tsnd_emu10k1x_intr_enable(emu, INTE_CH_0_LOOP << channel);\n\t\tepcm->running = 1;\n\t\tsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|(TRIGGER_CHANNEL_0<<channel));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tepcm->running = 0;\n\t\tsnd_emu10k1x_intr_disable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);\n\t\tsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CHANNEL_0<<channel));\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_emu10k1x_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\tint channel = epcm->voice->number;\n\tsnd_pcm_uframes_t ptr = 0, ptr1 = 0, ptr2= 0,ptr3 = 0,ptr4 = 0;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\n\tptr3 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\n\tptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);\n\tptr4 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\n\n\tif(ptr4 == 0 && ptr1 == frames_to_bytes(runtime, runtime->buffer_size))\n\t\treturn 0;\n\t\n\tif (ptr3 != ptr4) \n\t\tptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);\n\tptr2 = bytes_to_frames(runtime, ptr1);\n\tptr2 += (ptr4 >> 3) * runtime->period_size;\n\tptr = ptr2;\n\n\tif (ptr >= runtime->buffer_size)\n\t\tptr -= runtime->buffer_size;\n\n\treturn ptr;\n}\n\n \nstatic const struct snd_pcm_ops snd_emu10k1x_playback_ops = {\n\t.open =        snd_emu10k1x_playback_open,\n\t.close =       snd_emu10k1x_playback_close,\n\t.hw_params =   snd_emu10k1x_pcm_hw_params,\n\t.hw_free =     snd_emu10k1x_pcm_hw_free,\n\t.prepare =     snd_emu10k1x_pcm_prepare,\n\t.trigger =     snd_emu10k1x_pcm_trigger,\n\t.pointer =     snd_emu10k1x_pcm_pointer,\n};\n\n \nstatic int snd_emu10k1x_pcm_open_capture(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *chip = snd_pcm_substream_chip(substream);\n\tstruct emu10k1x_pcm *epcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\tif (err < 0)\n\t\treturn err;\n\n\tepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\n\tif (epcm == NULL)\n\t\treturn -ENOMEM;\n\n\tepcm->emu = chip;\n\tepcm->substream = substream;\n\n\truntime->private_data = epcm;\n\truntime->private_free = snd_emu10k1x_pcm_free_substream;\n\n\truntime->hw = snd_emu10k1x_capture_hw;\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_close_capture(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_hw_params_capture(struct snd_pcm_substream *substream,\n\t\t\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\n\tif (! epcm->voice) {\n\t\tif (epcm->emu->capture_voice.use)\n\t\t\treturn -EBUSY;\n\t\tepcm->voice = &epcm->emu->capture_voice;\n\t\tepcm->voice->epcm = epcm;\n\t\tepcm->voice->use = 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_hw_free_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tstruct emu10k1x_pcm *epcm;\n\n\tif (runtime->private_data == NULL)\n\t\treturn 0;\n\tepcm = runtime->private_data;\n\n\tif (epcm->voice) {\n\t\tepcm->voice->use = 0;\n\t\tepcm->voice->epcm = NULL;\n\t\tepcm->voice = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_prepare_capture(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_emu10k1x_ptr_write(emu, CAPTURE_DMA_ADDR, 0, runtime->dma_addr);\n\tsnd_emu10k1x_ptr_write(emu, CAPTURE_BUFFER_SIZE, 0, frames_to_bytes(runtime, runtime->buffer_size)<<16); \n\tsnd_emu10k1x_ptr_write(emu, CAPTURE_POINTER, 0, 0);\n\tsnd_emu10k1x_ptr_write(emu, CAPTURE_UNKNOWN, 0, 0);\n\n\treturn 0;\n}\n\n \nstatic int snd_emu10k1x_pcm_trigger_capture(struct snd_pcm_substream *substream,\n\t\t\t\t\t    int cmd)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\tint result = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_emu10k1x_intr_enable(emu, INTE_CAP_0_LOOP | \n\t\t\t\t\t INTE_CAP_0_HALF_LOOP);\n\t\tsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|TRIGGER_CAPTURE);\n\t\tepcm->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tepcm->running = 0;\n\t\tsnd_emu10k1x_intr_disable(emu, INTE_CAP_0_LOOP | \n\t\t\t\t\t  INTE_CAP_0_HALF_LOOP);\n\t\tsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CAPTURE));\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_emu10k1x_pcm_pointer_capture(struct snd_pcm_substream *substream)\n{\n\tstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct emu10k1x_pcm *epcm = runtime->private_data;\n\tsnd_pcm_uframes_t ptr;\n\n\tif (!epcm->running)\n\t\treturn 0;\n\n\tptr = bytes_to_frames(runtime, snd_emu10k1x_ptr_read(emu, CAPTURE_POINTER, 0));\n\tif (ptr >= runtime->buffer_size)\n\t\tptr -= runtime->buffer_size;\n\n\treturn ptr;\n}\n\nstatic const struct snd_pcm_ops snd_emu10k1x_capture_ops = {\n\t.open =        snd_emu10k1x_pcm_open_capture,\n\t.close =       snd_emu10k1x_pcm_close_capture,\n\t.hw_params =   snd_emu10k1x_pcm_hw_params_capture,\n\t.hw_free =     snd_emu10k1x_pcm_hw_free_capture,\n\t.prepare =     snd_emu10k1x_pcm_prepare_capture,\n\t.trigger =     snd_emu10k1x_pcm_trigger_capture,\n\t.pointer =     snd_emu10k1x_pcm_pointer_capture,\n};\n\nstatic unsigned short snd_emu10k1x_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t     unsigned short reg)\n{\n\tstruct emu10k1x *emu = ac97->private_data;\n\tunsigned long flags;\n\tunsigned short val;\n  \n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + AC97ADDRESS);\n\tval = inw(emu->port + AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nstatic void snd_emu10k1x_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t    unsigned short reg, unsigned short val)\n{\n\tstruct emu10k1x *emu = ac97->private_data;\n\tunsigned long flags;\n  \n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + AC97ADDRESS);\n\toutw(val, emu->port + AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic int snd_emu10k1x_ac97(struct emu10k1x *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_emu10k1x_ac97_write,\n\t\t.read = snd_emu10k1x_ac97_read,\n\t};\n  \n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\tpbus->no_vra = 1;  \n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.scaps = AC97_SCAP_NO_SPDIF;\n\treturn snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n}\n\nstatic void snd_emu10k1x_free(struct snd_card *card)\n{\n\tstruct emu10k1x *chip = card->private_data;\n\n\tsnd_emu10k1x_ptr_write(chip, TRIGGER_CHANNEL, 0, 0);\n\t\n\toutl(0, chip->port + INTE);\n\t\n\toutl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG);\n}\n\nstatic irqreturn_t snd_emu10k1x_interrupt(int irq, void *dev_id)\n{\n\tunsigned int status;\n\n\tstruct emu10k1x *chip = dev_id;\n\tstruct emu10k1x_voice *pvoice = chip->voices;\n\tint i;\n\tint mask;\n\n\tstatus = inl(chip->port + IPR);\n\n\tif (! status)\n\t\treturn IRQ_NONE;\n\n\t\n\tif (status & (IPR_CAP_0_LOOP | IPR_CAP_0_HALF_LOOP)) {\n\t\tstruct emu10k1x_voice *cap_voice = &chip->capture_voice;\n\t\tif (cap_voice->use)\n\t\t\tsnd_emu10k1x_pcm_interrupt(chip, cap_voice);\n\t\telse\n\t\t\tsnd_emu10k1x_intr_disable(chip, \n\t\t\t\t\t\t  INTE_CAP_0_LOOP |\n\t\t\t\t\t\t  INTE_CAP_0_HALF_LOOP);\n\t}\n\t\t\n\tmask = IPR_CH_0_LOOP|IPR_CH_0_HALF_LOOP;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (status & mask) {\n\t\t\tif (pvoice->use)\n\t\t\t\tsnd_emu10k1x_pcm_interrupt(chip, pvoice);\n\t\t\telse \n\t\t\t\tsnd_emu10k1x_intr_disable(chip, mask);\n\t\t}\n\t\tpvoice++;\n\t\tmask <<= 1;\n\t}\n\t\t\n\tif (status & (IPR_MIDITRANSBUFEMPTY|IPR_MIDIRECVBUFEMPTY)) {\n\t\tif (chip->midi.interrupt)\n\t\t\tchip->midi.interrupt(chip, status);\n\t\telse\n\t\t\tsnd_emu10k1x_intr_disable(chip, INTE_MIDITXENABLE|INTE_MIDIRXENABLE);\n\t}\n\t\t\n\t\n\toutl(status, chip->port + IPR);\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_chmap_elem surround_map[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nstatic const struct snd_pcm_chmap_elem clfe_map[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ }\n};\n\nstatic int snd_emu10k1x_pcm(struct emu10k1x *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tconst struct snd_pcm_chmap_elem *map = NULL;\n\tint err;\n\tint capture = 0;\n  \n\tif (device == 0)\n\t\tcapture = 1;\n\t\n\terr = snd_pcm_new(emu->card, \"emu10k1x\", device, 1, capture, &pcm);\n\tif (err < 0)\n\t\treturn err;\n  \n\tpcm->private_data = emu;\n\t\n\tswitch(device) {\n\tcase 0:\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1x_capture_ops);\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);\n\t\tbreak;\n\t}\n\n\tpcm->info_flags = 0;\n\tswitch(device) {\n\tcase 0:\n\t\tstrcpy(pcm->name, \"EMU10K1X Front\");\n\t\tmap = snd_pcm_std_chmaps;\n\t\tbreak;\n\tcase 1:\n\t\tstrcpy(pcm->name, \"EMU10K1X Rear\");\n\t\tmap = surround_map;\n\t\tbreak;\n\tcase 2:\n\t\tstrcpy(pcm->name, \"EMU10K1X Center/LFE\");\n\t\tmap = clfe_map;\n\t\tbreak;\n\t}\n\temu->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &emu->pci->dev, 32*1024, 32*1024);\n  \n\treturn snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK, map, 2,\n\t\t\t\t     1 << 2, NULL);\n}\n\nstatic int snd_emu10k1x_create(struct snd_card *card,\n\t\t\t       struct pci_dev *pci)\n{\n\tstruct emu10k1x *chip = card->private_data;\n\tint err;\n\tint ch;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(28)) < 0) {\n\t\tdev_err(card->dev, \"error to set 28bit mask DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\tspin_lock_init(&chip->emu_lock);\n\tspin_lock_init(&chip->voice_lock);\n  \n\terr = pci_request_regions(pci, \"EMU10K1X\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->port = pci_resource_start(pci, 0);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_emu10k1x_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"cannot grab irq %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_emu10k1x_free;\n  \n\tchip->dma_buffer = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t4 * 1024);\n\tif (!chip->dma_buffer)\n\t\treturn -ENOMEM;\n\n\tpci_set_master(pci);\n\t \n\tchip->revision = pci->revision;\n\tpci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);\n\tdev_info(card->dev, \"Model %04x Rev %08x Serial %08x\\n\", chip->model,\n\t\t   chip->revision, chip->serial);\n\n\toutl(0, chip->port + INTE);\t\n\n\tfor(ch = 0; ch < 3; ch++) {\n\t\tchip->voices[ch].emu = chip;\n\t\tchip->voices[ch].number = ch;\n\t}\n\n\t \n\tsnd_emu10k1x_ptr_write(chip, SPCS0, 0,\n\t\t\t       chip->spdif_bits[0] = \n\t\t\t       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\t\t       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\t\t       SPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t\t       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\n\tsnd_emu10k1x_ptr_write(chip, SPCS1, 0,\n\t\t\t       chip->spdif_bits[1] = \n\t\t\t       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\t\t       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\t\t       SPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t\t       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\n\tsnd_emu10k1x_ptr_write(chip, SPCS2, 0,\n\t\t\t       chip->spdif_bits[2] = \n\t\t\t       SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\t\t       SPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\t\t       SPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t\t       0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\n\n\tsnd_emu10k1x_ptr_write(chip, SPDIF_SELECT, 0, 0x700); \n\tsnd_emu10k1x_ptr_write(chip, ROUTING, 0, 0x1003F); \n\tsnd_emu10k1x_gpio_write(chip, 0x1080); \n\n\toutl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG);\n\n\treturn 0;\n}\n\nstatic void snd_emu10k1x_proc_reg_read(struct snd_info_entry *entry, \n\t\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct emu10k1x *emu = entry->private_data;\n\tunsigned long value,value1,value2;\n\tunsigned long flags;\n\tint i;\n\n\tsnd_iprintf(buffer, \"Registers:\\n\\n\");\n\tfor(i = 0; i < 0x20; i+=4) {\n\t\tspin_lock_irqsave(&emu->emu_lock, flags);\n\t\tvalue = inl(emu->port + i);\n\t\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\t\tsnd_iprintf(buffer, \"Register %02X: %08lX\\n\", i, value);\n\t}\n\tsnd_iprintf(buffer, \"\\nRegisters\\n\\n\");\n\tfor(i = 0; i <= 0x48; i++) {\n\t\tvalue = snd_emu10k1x_ptr_read(emu, i, 0);\n\t\tif(i < 0x10 || (i >= 0x20 && i < 0x40)) {\n\t\t\tvalue1 = snd_emu10k1x_ptr_read(emu, i, 1);\n\t\t\tvalue2 = snd_emu10k1x_ptr_read(emu, i, 2);\n\t\t\tsnd_iprintf(buffer, \"%02X: %08lX %08lX %08lX\\n\", i, value, value1, value2);\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"%02X: %08lX\\n\", i, value);\n\t\t}\n\t}\n}\n\nstatic void snd_emu10k1x_proc_reg_write(struct snd_info_entry *entry, \n\t\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct emu10k1x *emu = entry->private_data;\n\tchar line[64];\n\tunsigned int reg, channel_id , val;\n\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%x %x %x\", &reg, &channel_id, &val) != 3)\n\t\t\tcontinue;\n\n\t\tif (reg < 0x49 && channel_id <= 2)\n\t\t\tsnd_emu10k1x_ptr_write(emu, reg, channel_id, val);\n\t}\n}\n\nstatic int snd_emu10k1x_proc_init(struct emu10k1x *emu)\n{\n\tsnd_card_rw_proc_new(emu->card, \"emu10k1x_regs\", emu,\n\t\t\t     snd_emu10k1x_proc_reg_read,\n\t\t\t     snd_emu10k1x_proc_reg_write);\n\treturn 0;\n}\n\n#define snd_emu10k1x_shared_spdif_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_emu10k1x_shared_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = (snd_emu10k1x_ptr_read(emu, SPDIF_SELECT, 0) == 0x700) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_shared_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\n\tval = ucontrol->value.integer.value[0] ;\n\n\tif (val) {\n\t\t\n\t\tsnd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x000);\n\t\tsnd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x700);\n\t\tsnd_emu10k1x_gpio_write(emu, 0x1000);\n\t} else {\n\t\t\n\t\tsnd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x700);\n\t\tsnd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x1003F);\n\t\tsnd_emu10k1x_gpio_write(emu, 0x1080);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1x_shared_spdif =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Analog/Digital Output Jack\",\n\t.info =\t\tsnd_emu10k1x_shared_spdif_info,\n\t.get =\t\tsnd_emu10k1x_shared_spdif_get,\n\t.put =\t\tsnd_emu10k1x_shared_spdif_put\n};\n\nstatic int snd_emu10k1x_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\n\tucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_spdif_get_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tint change;\n\tunsigned int val;\n\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t\t(ucontrol->value.iec958.status[1] << 8) |\n\t\t(ucontrol->value.iec958.status[2] << 16) |\n\t\t(ucontrol->value.iec958.status[3] << 24);\n\tchange = val != emu->spdif_bits[idx];\n\tif (change) {\n\t\tsnd_emu10k1x_ptr_write(emu, SPCS0 + idx, 0, val);\n\t\temu->spdif_bits[idx] = val;\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1x_spdif_mask_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.count =\t3,\n\t.info =         snd_emu10k1x_spdif_info,\n\t.get =          snd_emu10k1x_spdif_get_mask\n};\n\nstatic const struct snd_kcontrol_new snd_emu10k1x_spdif_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.count =\t3,\n\t.info =         snd_emu10k1x_spdif_info,\n\t.get =          snd_emu10k1x_spdif_get,\n\t.put =          snd_emu10k1x_spdif_put\n};\n\nstatic int snd_emu10k1x_mixer(struct emu10k1x *emu)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = emu->card;\n\n\tkctl = snd_ctl_new1(&snd_emu10k1x_spdif_mask_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_emu10k1x_shared_spdif, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\tkctl = snd_ctl_new1(&snd_emu10k1x_spdif_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#define EMU10K1X_MIDI_MODE_INPUT\t(1<<0)\n#define EMU10K1X_MIDI_MODE_OUTPUT\t(1<<1)\n\nstatic inline unsigned char mpu401_read(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int idx)\n{\n\treturn (unsigned char)snd_emu10k1x_ptr_read(emu, mpu->port + idx, 0);\n}\n\nstatic inline void mpu401_write(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int data, int idx)\n{\n\tsnd_emu10k1x_ptr_write(emu, mpu->port + idx, 0, data);\n}\n\n#define mpu401_write_data(emu, mpu, data)\tmpu401_write(emu, mpu, data, 0)\n#define mpu401_write_cmd(emu, mpu, data)\tmpu401_write(emu, mpu, data, 1)\n#define mpu401_read_data(emu, mpu)\t\tmpu401_read(emu, mpu, 0)\n#define mpu401_read_stat(emu, mpu)\t\tmpu401_read(emu, mpu, 1)\n\n#define mpu401_input_avail(emu,mpu)\t(!(mpu401_read_stat(emu,mpu) & 0x80))\n#define mpu401_output_ready(emu,mpu)\t(!(mpu401_read_stat(emu,mpu) & 0x40))\n\n#define MPU401_RESET\t\t0xff\n#define MPU401_ENTER_UART\t0x3f\n#define MPU401_ACK\t\t0xfe\n\nstatic void mpu401_clear_rx(struct emu10k1x *emu, struct emu10k1x_midi *mpu)\n{\n\tint timeout = 100000;\n\tfor (; timeout > 0 && mpu401_input_avail(emu, mpu); timeout--)\n\t\tmpu401_read_data(emu, mpu);\n#ifdef CONFIG_SND_DEBUG\n\tif (timeout <= 0)\n\t\tdev_err(emu->card->dev,\n\t\t\t\"cmd: clear rx timeout (status = 0x%x)\\n\",\n\t\t\tmpu401_read_stat(emu, mpu));\n#endif\n}\n\n \n\nstatic void do_emu10k1x_midi_interrupt(struct emu10k1x *emu,\n\t\t\t\t       struct emu10k1x_midi *midi, unsigned int status)\n{\n\tunsigned char byte;\n\n\tif (midi->rmidi == NULL) {\n\t\tsnd_emu10k1x_intr_disable(emu, midi->tx_enable | midi->rx_enable);\n\t\treturn;\n\t}\n\n\tspin_lock(&midi->input_lock);\n\tif ((status & midi->ipr_rx) && mpu401_input_avail(emu, midi)) {\n\t\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\n\t\t\tmpu401_clear_rx(emu, midi);\n\t\t} else {\n\t\t\tbyte = mpu401_read_data(emu, midi);\n\t\t\tif (midi->substream_input)\n\t\t\t\tsnd_rawmidi_receive(midi->substream_input, &byte, 1);\n\t\t}\n\t}\n\tspin_unlock(&midi->input_lock);\n\n\tspin_lock(&midi->output_lock);\n\tif ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {\n\t\tif (midi->substream_output &&\n\t\t    snd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {\n\t\t\tmpu401_write_data(emu, midi, byte);\n\t\t} else {\n\t\t\tsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\n\t\t}\n\t}\n\tspin_unlock(&midi->output_lock);\n}\n\nstatic void snd_emu10k1x_midi_interrupt(struct emu10k1x *emu, unsigned int status)\n{\n\tdo_emu10k1x_midi_interrupt(emu, &emu->midi, status);\n}\n\nstatic int snd_emu10k1x_midi_cmd(struct emu10k1x * emu,\n\t\t\t\t  struct emu10k1x_midi *midi, unsigned char cmd, int ack)\n{\n\tunsigned long flags;\n\tint timeout, ok;\n\n\tspin_lock_irqsave(&midi->input_lock, flags);\n\tmpu401_write_data(emu, midi, 0x00);\n\t \n\n\tmpu401_write_cmd(emu, midi, cmd);\n\tif (ack) {\n\t\tok = 0;\n\t\ttimeout = 10000;\n\t\twhile (!ok && timeout-- > 0) {\n\t\t\tif (mpu401_input_avail(emu, midi)) {\n\t\t\t\tif (mpu401_read_data(emu, midi) == MPU401_ACK)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t\tif (!ok && mpu401_read_data(emu, midi) == MPU401_ACK)\n\t\t\tok = 1;\n\t} else {\n\t\tok = 1;\n\t}\n\tspin_unlock_irqrestore(&midi->input_lock, flags);\n\tif (!ok) {\n\t\tdev_err(emu->card->dev,\n\t\t\t\"midi_cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)!!!\\n\",\n\t\t\t   cmd, emu->port,\n\t\t\t   mpu401_read_stat(emu, midi),\n\t\t\t   mpu401_read_data(emu, midi));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\tunsigned long flags;\n\t\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irqsave(&midi->open_lock, flags);\n\tmidi->midi_mode |= EMU10K1X_MIDI_MODE_INPUT;\n\tmidi->substream_input = substream;\n\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t\tif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1))\n\t\t\tgoto error_out;\n\t\tif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\n\t\t\tgoto error_out;\n\t} else {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t}\n\treturn 0;\n\nerror_out:\n\treturn -EIO;\n}\n\nstatic int snd_emu10k1x_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\tunsigned long flags;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irqsave(&midi->open_lock, flags);\n\tmidi->midi_mode |= EMU10K1X_MIDI_MODE_OUTPUT;\n\tmidi->substream_output = substream;\n\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t\tif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1))\n\t\t\tgoto error_out;\n\t\tif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\n\t\t\tgoto error_out;\n\t} else {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t}\n\treturn 0;\n\nerror_out:\n\treturn -EIO;\n}\n\nstatic int snd_emu10k1x_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\tunsigned long flags;\n\tint err = 0;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irqsave(&midi->open_lock, flags);\n\tsnd_emu10k1x_intr_disable(emu, midi->rx_enable);\n\tmidi->midi_mode &= ~EMU10K1X_MIDI_MODE_INPUT;\n\tmidi->substream_input = NULL;\n\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t\terr = snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);\n\t} else {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t}\n\treturn err;\n}\n\nstatic int snd_emu10k1x_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\tunsigned long flags;\n\tint err = 0;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irqsave(&midi->open_lock, flags);\n\tsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\n\tmidi->midi_mode &= ~EMU10K1X_MIDI_MODE_OUTPUT;\n\tmidi->substream_output = NULL;\n\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t\terr = snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);\n\t} else {\n\t\tspin_unlock_irqrestore(&midi->open_lock, flags);\n\t}\n\treturn err;\n}\n\nstatic void snd_emu10k1x_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn;\n\n\tif (up)\n\t\tsnd_emu10k1x_intr_enable(emu, midi->rx_enable);\n\telse\n\t\tsnd_emu10k1x_intr_disable(emu, midi->rx_enable);\n}\n\nstatic void snd_emu10k1x_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct emu10k1x *emu;\n\tstruct emu10k1x_midi *midi = substream->rmidi->private_data;\n\tunsigned long flags;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn;\n\n\tif (up) {\n\t\tint max = 4;\n\t\tunsigned char byte;\n\t\n\t\t \n\t\tspin_lock_irqsave(&midi->output_lock, flags);\n\t\twhile (max > 0) {\n\t\t\tif (mpu401_output_ready(emu, midi)) {\n\t\t\t\tif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT) ||\n\t\t\t\t    snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\t \n\t\t\t\t\tspin_unlock_irqrestore(&midi->output_lock, flags);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmpu401_write_data(emu, midi, byte);\n\t\t\t\tmax--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&midi->output_lock, flags);\n\t\tsnd_emu10k1x_intr_enable(emu, midi->tx_enable);\n\t} else {\n\t\tsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\n\t}\n}\n\n \n\nstatic const struct snd_rawmidi_ops snd_emu10k1x_midi_output =\n{\n\t.open =\t\tsnd_emu10k1x_midi_output_open,\n\t.close =\tsnd_emu10k1x_midi_output_close,\n\t.trigger =\tsnd_emu10k1x_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_emu10k1x_midi_input =\n{\n\t.open =\t\tsnd_emu10k1x_midi_input_open,\n\t.close =\tsnd_emu10k1x_midi_input_close,\n\t.trigger =\tsnd_emu10k1x_midi_input_trigger,\n};\n\nstatic void snd_emu10k1x_midi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct emu10k1x_midi *midi = rmidi->private_data;\n\tmidi->interrupt = NULL;\n\tmidi->rmidi = NULL;\n}\n\nstatic int emu10k1x_midi_init(struct emu10k1x *emu,\n\t\t\t      struct emu10k1x_midi *midi, int device,\n\t\t\t      char *name)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(emu->card, name, device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tmidi->emu = emu;\n\tspin_lock_init(&midi->open_lock);\n\tspin_lock_init(&midi->input_lock);\n\tspin_lock_init(&midi->output_lock);\n\tstrcpy(rmidi->name, name);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_emu10k1x_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_emu10k1x_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\n\t                     SNDRV_RAWMIDI_INFO_INPUT |\n\t                     SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = midi;\n\trmidi->private_free = snd_emu10k1x_midi_free;\n\tmidi->rmidi = rmidi;\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_midi(struct emu10k1x *emu)\n{\n\tstruct emu10k1x_midi *midi = &emu->midi;\n\tint err;\n\n\terr = emu10k1x_midi_init(emu, midi, 0, \"EMU10K1X MPU-401 (UART)\");\n\tif (err < 0)\n\t\treturn err;\n\n\tmidi->tx_enable = INTE_MIDITXENABLE;\n\tmidi->rx_enable = INTE_MIDIRXENABLE;\n\tmidi->port = MUDATA;\n\tmidi->ipr_tx = IPR_MIDITRANSBUFEMPTY;\n\tmidi->ipr_rx = IPR_MIDIRECVBUFEMPTY;\n\tmidi->interrupt = snd_emu10k1x_midi_interrupt;\n\treturn 0;\n}\n\nstatic int __snd_emu10k1x_probe(struct pci_dev *pci,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct emu10k1x *chip;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_emu10k1x_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_emu10k1x_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_emu10k1x_pcm(chip, 1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_emu10k1x_pcm(chip, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_emu10k1x_ac97(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_emu10k1x_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\terr = snd_emu10k1x_midi(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_emu10k1x_proc_init(chip);\n\n\tstrcpy(card->driver, \"EMU10K1X\");\n\tstrcpy(card->shortname, \"Dell Sound Blaster Live!\");\n\tsprintf(card->longname, \"%s at 0x%lx irq %i\",\n\t\tcard->shortname, chip->port, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_emu10k1x_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_emu10k1x_probe(pci, pci_id));\n}\n\n\nstatic const struct pci_device_id snd_emu10k1x_ids[] = {\n\t{ PCI_VDEVICE(CREATIVE, 0x0006), 0 },\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, snd_emu10k1x_ids);\n\n\nstatic struct pci_driver emu10k1x_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_emu10k1x_ids,\n\t.probe = snd_emu10k1x_probe,\n};\n\nmodule_pci_driver(emu10k1x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}