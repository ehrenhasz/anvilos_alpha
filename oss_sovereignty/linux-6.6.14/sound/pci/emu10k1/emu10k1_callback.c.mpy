{
  "module_name": "emu10k1_callback.c",
  "hash_id": "98e9cb52b3eb7b35092c7aab46d74013ba8ece87ee2935890411ea8417a2a362",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emu10k1_callback.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include \"emu10k1_synth_local.h\"\n#include <sound/asoundef.h>\n\n \nenum {\n\tV_FREE=0, V_OFF, V_RELEASED, V_PLAYING, V_END\n};\n\n \nstruct best_voice {\n\tunsigned int time;\n\tint voice;\n};\n\n \nstatic void lookup_voices(struct snd_emux *emux, struct snd_emu10k1 *hw,\n\t\t\t  struct best_voice *best, int active_only);\nstatic struct snd_emux_voice *get_voice(struct snd_emux *emux,\n\t\t\t\t\tstruct snd_emux_port *port);\nstatic int start_voice(struct snd_emux_voice *vp);\nstatic void trigger_voice(struct snd_emux_voice *vp);\nstatic void release_voice(struct snd_emux_voice *vp);\nstatic void update_voice(struct snd_emux_voice *vp, int update);\nstatic void terminate_voice(struct snd_emux_voice *vp);\nstatic void free_voice(struct snd_emux_voice *vp);\nstatic u32 make_fmmod(struct snd_emux_voice *vp);\nstatic u32 make_fm2frq2(struct snd_emux_voice *vp);\nstatic int get_pitch_shift(struct snd_emux *emu);\n\n \n#define LIMITVALUE(x, a, b) do { if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b); } while (0)\n#define LIMITMAX(x, a) do {if ((x) > (a)) (x) = (a); } while (0)\n\n\n \nstatic const struct snd_emux_operators emu10k1_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.get_voice =\tget_voice,\n\t.prepare =\tstart_voice,\n\t.trigger =\ttrigger_voice,\n\t.release =\trelease_voice,\n\t.update =\tupdate_voice,\n\t.terminate =\tterminate_voice,\n\t.free_voice =\tfree_voice,\n\t.sample_new =\tsnd_emu10k1_sample_new,\n\t.sample_free =\tsnd_emu10k1_sample_free,\n\t.get_pitch_shift = get_pitch_shift,\n};\n\nvoid\nsnd_emu10k1_ops_setup(struct snd_emux *emux)\n{\n\temux->ops = emu10k1_ops;\n}\n\n\n \nint\nsnd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)\n{\n\tstruct snd_emux *emu;\n\tstruct snd_emux_voice *vp;\n\tstruct best_voice best[V_END];\n\tint i;\n\n\temu = hw->synth;\n\n\tlookup_voices(emu, hw, best, 1);  \n\tfor (i = 0; i < V_END; i++) {\n\t\tif (best[i].voice >= 0) {\n\t\t\tint ch;\n\t\t\tvp = &emu->voices[best[i].voice];\n\t\t\tch = vp->ch;\n\t\t\tif (ch < 0) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvp->emu->num_voices--;\n\t\t\tvp->ch = -1;\n\t\t\tvp->state = SNDRV_EMUX_ST_OFF;\n\t\t\treturn ch;\n\t\t}\n\t}\n\n\t \n\treturn -ENOMEM;\n}\n\n\n \nstatic void\nrelease_voice(struct snd_emux_voice *vp)\n{\n\tstruct snd_emu10k1 *hw;\n\t\n\thw = vp->hw;\n\tsnd_emu10k1_ptr_write_multiple(hw, vp->ch,\n\t\tDCYSUSM, (unsigned char)vp->reg.parm.modrelease | DCYSUSM_PHASE1_MASK,\n\t\tDCYSUSV, (unsigned char)vp->reg.parm.volrelease | DCYSUSV_PHASE1_MASK | DCYSUSV_CHANNELENABLE_MASK,\n\t\tREGLIST_END);\n}\n\n\n \nstatic void\nterminate_voice(struct snd_emux_voice *vp)\n{\n\tstruct snd_emu10k1 *hw;\n\t\n\tif (snd_BUG_ON(!vp))\n\t\treturn;\n\thw = vp->hw;\n\tsnd_emu10k1_ptr_write_multiple(hw, vp->ch,\n\t\tDCYSUSV, 0,\n\t\tVTFT, VTFT_FILTERTARGET_MASK,\n\t\tCVCF, CVCF_CURRENTFILTER_MASK,\n\t\tPTRX, 0,\n\t\tCPF, 0,\n\t\tREGLIST_END);\n\tif (vp->block) {\n\t\tstruct snd_emu10k1_memblk *emem;\n\t\temem = (struct snd_emu10k1_memblk *)vp->block;\n\t\tif (emem->map_locked > 0)\n\t\t\temem->map_locked--;\n\t}\n}\n\n \nstatic void\nfree_voice(struct snd_emux_voice *vp)\n{\n\tstruct snd_emu10k1 *hw;\n\t\n\thw = vp->hw;\n\t \n\t \n\t \n\t \n\tif (hw && (vp->ch >= 0)) {\n\t\tsnd_emu10k1_voice_free(hw, &hw->voices[vp->ch]);\n\t\tvp->emu->num_voices--;\n\t\tvp->ch = -1;\n\t}\n}\n\n\n \nstatic void\nupdate_voice(struct snd_emux_voice *vp, int update)\n{\n\tstruct snd_emu10k1 *hw;\n\t\n\thw = vp->hw;\n\tif (update & SNDRV_EMUX_UPDATE_VOLUME)\n\t\tsnd_emu10k1_ptr_write(hw, IFATN_ATTENUATION, vp->ch, vp->avol);\n\tif (update & SNDRV_EMUX_UPDATE_PITCH)\n\t\tsnd_emu10k1_ptr_write(hw, IP, vp->ch, vp->apitch);\n\tif (update & SNDRV_EMUX_UPDATE_PAN) {\n\t\tsnd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_A, vp->ch, vp->apan);\n\t\tsnd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_B, vp->ch, vp->aaux);\n\t}\n\tif (update & SNDRV_EMUX_UPDATE_FMMOD)\n\t\tsnd_emu10k1_ptr_write(hw, FMMOD, vp->ch, make_fmmod(vp));\n\tif (update & SNDRV_EMUX_UPDATE_TREMFREQ)\n\t\tsnd_emu10k1_ptr_write(hw, TREMFRQ, vp->ch, vp->reg.parm.tremfrq);\n\tif (update & SNDRV_EMUX_UPDATE_FM2FRQ2)\n\t\tsnd_emu10k1_ptr_write(hw, FM2FRQ2, vp->ch, make_fm2frq2(vp));\n\tif (update & SNDRV_EMUX_UPDATE_Q)\n\t\tsnd_emu10k1_ptr_write(hw, CCCA_RESONANCE, vp->ch, vp->reg.parm.filterQ);\n}\n\n\n \n \nstatic void\nlookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,\n\t      struct best_voice *best, int active_only)\n{\n\tstruct snd_emux_voice *vp;\n\tstruct best_voice *bp;\n\tint  i;\n\n\tfor (i = 0; i < V_END; i++) {\n\t\tbest[i].time = (unsigned int)-1;  \n\t\tbest[i].voice = -1;\n\t}\n\n\t \n\tfor (i = 0; i < emu->max_voices; i++) {\n\t\tint state, val;\n\n\t\tvp = &emu->voices[i];\n\t\tstate = vp->state;\n\t\tif (state == SNDRV_EMUX_ST_OFF) {\n\t\t\tif (vp->ch < 0) {\n\t\t\t\tif (active_only)\n\t\t\t\t\tcontinue;\n\t\t\t\tbp = best + V_FREE;\n\t\t\t} else\n\t\t\t\tbp = best + V_OFF;\n\t\t}\n\t\telse if (state == SNDRV_EMUX_ST_RELEASED ||\n\t\t\t state == SNDRV_EMUX_ST_PENDING) {\n\t\t\tbp = best + V_RELEASED;\n#if 1\n\t\t\tval = snd_emu10k1_ptr_read(hw, CVCF_CURRENTVOL, vp->ch);\n\t\t\tif (! val)\n\t\t\t\tbp = best + V_OFF;\n#endif\n\t\t}\n\t\telse if (state == SNDRV_EMUX_ST_STANDBY)\n\t\t\tcontinue;\n\t\telse if (state & SNDRV_EMUX_ST_ON)\n\t\t\tbp = best + V_PLAYING;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bp != best + V_OFF && bp != best + V_FREE &&\n\t\t    (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {\n\t\t\tval = snd_emu10k1_ptr_read(hw, CCCA_CURRADDR, vp->ch) - 64;\n\t\t\tif (val >= vp->reg.loopstart)\n\t\t\t\tbp = best + V_OFF;\n\t\t}\n\n\t\tif (vp->time < bp->time) {\n\t\t\tbp->time = vp->time;\n\t\t\tbp->voice = i;\n\t\t}\n\t}\n}\n\n \nstatic struct snd_emux_voice *\nget_voice(struct snd_emux *emu, struct snd_emux_port *port)\n{\n\tstruct snd_emu10k1 *hw;\n\tstruct snd_emux_voice *vp;\n\tstruct best_voice best[V_END];\n\tint i;\n\n\thw = emu->hw;\n\n\tlookup_voices(emu, hw, best, 0);\n\tfor (i = 0; i < V_END; i++) {\n\t\tif (best[i].voice >= 0) {\n\t\t\tvp = &emu->voices[best[i].voice];\n\t\t\tif (vp->ch < 0) {\n\t\t\t\t \n\t\t\t\tstruct snd_emu10k1_voice *hwvoice;\n\t\t\t\tif (snd_emu10k1_voice_alloc(hw, EMU10K1_SYNTH, 1, 1, NULL, &hwvoice) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvp->ch = hwvoice->number;\n\t\t\t\temu->num_voices++;\n\t\t\t}\n\t\t\treturn vp;\n\t\t}\n\t}\n\n\t \n\treturn NULL;\n}\n\n \nstatic int\nstart_voice(struct snd_emux_voice *vp)\n{\n\tunsigned int temp;\n\tint ch;\n\tu32 psst, dsl, map, ccca, vtarget;\n\tunsigned int addr, mapped_offset;\n\tstruct snd_midi_channel *chan;\n\tstruct snd_emu10k1 *hw;\n\tstruct snd_emu10k1_memblk *emem;\n\t\n\thw = vp->hw;\n\tch = vp->ch;\n\tif (snd_BUG_ON(ch < 0))\n\t\treturn -EINVAL;\n\tchan = vp->chan;\n\n\temem = (struct snd_emu10k1_memblk *)vp->block;\n\tif (emem == NULL)\n\t\treturn -EINVAL;\n\temem->map_locked++;\n\tif (snd_emu10k1_memblk_map(hw, emem) < 0) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\tmapped_offset = snd_emu10k1_memblk_offset(emem) >> 1;\n\tvp->reg.start += mapped_offset;\n\tvp->reg.end += mapped_offset;\n\tvp->reg.loopstart += mapped_offset;\n\tvp->reg.loopend += mapped_offset;\n\n\t \n\t \n\tif (hw->audigy) {\n\t\ttemp = FXBUS_MIDI_LEFT | (FXBUS_MIDI_RIGHT << 8) | \n\t\t\t(FXBUS_MIDI_REVERB << 16) | (FXBUS_MIDI_CHORUS << 24);\n\t\tsnd_emu10k1_ptr_write(hw, A_FXRT1, ch, temp);\n\t} else {\n\t\ttemp = (FXBUS_MIDI_LEFT << 16) | (FXBUS_MIDI_RIGHT << 20) | \n\t\t\t(FXBUS_MIDI_REVERB << 24) | (FXBUS_MIDI_CHORUS << 28);\n\t\tsnd_emu10k1_ptr_write(hw, FXRT, ch, temp);\n\t}\n\n\ttemp = vp->reg.parm.reverb;\n\ttemp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;\n\tLIMITMAX(temp, 255);\n\taddr = vp->reg.loopstart;\n\tpsst = (temp << 24) | addr;\n\n\taddr = vp->reg.loopend;\n\ttemp = vp->reg.parm.chorus;\n\ttemp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;\n\tLIMITMAX(temp, 255);\n\tdsl = (temp << 24) | addr;\n\n\tmap = (hw->silent_page.addr << hw->address_mode) | (hw->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);\n\n\taddr = vp->reg.start + 64;\n\ttemp = vp->reg.parm.filterQ;\n\tccca = (temp << 28) | addr;\n\tif (vp->apitch < 0xe400)\n\t\tccca |= CCCA_INTERPROM_0;\n\telse {\n\t\tunsigned int shift = (vp->apitch - 0xe000) >> 10;\n\t\tccca |= shift << 25;\n\t}\n\tif (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_8BITS)\n\t\tccca |= CCCA_8BITSELECT;\n\n\tvtarget = (unsigned int)vp->vtarget << 16;\n\n\tsnd_emu10k1_ptr_write_multiple(hw, ch,\n\t\t \n\t\tDCYSUSV, 0,\n\t\tVTFT, VTFT_FILTERTARGET_MASK,\n\t\tCVCF, CVCF_CURRENTFILTER_MASK,\n\t\tPTRX, 0,\n\t\tCPF, 0,\n\n\t\t \n\t\tIP, vp->apitch,\n\n\t\t \n\t\tENVVAL, vp->reg.parm.moddelay,\n\t\tATKHLDM, vp->reg.parm.modatkhld,\n\t\tDCYSUSM, vp->reg.parm.moddcysus,\n\t\tENVVOL, vp->reg.parm.voldelay,\n\t\tATKHLDV, vp->reg.parm.volatkhld,\n\t\t \n\n\t\t \n\t\tIFATN, (unsigned int)vp->acutoff << 8 | (unsigned char)vp->avol,\n\n\t\t \n\t\tPEFE, vp->reg.parm.pefe,\n\n\t\t \n\t\tLFOVAL1, vp->reg.parm.lfo1delay,\n\t\tLFOVAL2, vp->reg.parm.lfo2delay,\n\n\t\t \n\t\tFMMOD, make_fmmod(vp),\n\t\t \n\t\tTREMFRQ, vp->reg.parm.tremfrq,\n\t\t \n\t\tFM2FRQ2, make_fm2frq2(vp),\n\n\t\t \n\t\tPSST, psst,\n\n\t\t \n\t\tDSL, dsl,\n\n\t\t \n\t\tZ1, 0,\n\t\tZ2, 0,\n\n\t\t \n\t\tMAPA, map,\n\t\tMAPB, map,\n\n\t\t \n\t\tCCCA, ccca,\n\n\t\t \n\t\tCCR, REG_VAL_PUT(CCR_CACHEINVALIDSIZE, 64),\n\n\t\t \n\t\tVTFT, vtarget | vp->ftarget,\n\t\tCVCF, vtarget | CVCF_CURRENTFILTER_MASK,\n\n\t\tREGLIST_END);\n\n\thw->voices[ch].dirty = 1;\n\treturn 0;\n}\n\n \nstatic void\ntrigger_voice(struct snd_emux_voice *vp)\n{\n\tunsigned int ptarget;\n\tstruct snd_emu10k1 *hw;\n\tstruct snd_emu10k1_memblk *emem;\n\t\n\thw = vp->hw;\n\n\temem = (struct snd_emu10k1_memblk *)vp->block;\n\tif (! emem || emem->mapped_page < 0)\n\t\treturn;  \n\n#if 0\n\tptarget = (unsigned int)vp->ptarget << 16;\n#else\n\tptarget = IP_TO_CP(vp->apitch);\n#endif\n\tsnd_emu10k1_ptr_write_multiple(hw, vp->ch,\n\t\t \n\t\tPTRX, ptarget | (vp->apan << 8) | vp->aaux,\n\n\t\t \n\t\tCPF, ptarget,\n\n\t\t \n\t\tDCYSUSV, vp->reg.parm.voldcysus | DCYSUSV_CHANNELENABLE_MASK,\n\n\t\tREGLIST_END);\n}\n\n#define MOD_SENSE 18\n\n \nstatic u32\nmake_fmmod(struct snd_emux_voice *vp)\n{\n\tshort pitch;\n\tunsigned char cutoff;\n\tint modulation;\n\n\tpitch = (char)(vp->reg.parm.fmmod>>8);\n\tcutoff = (vp->reg.parm.fmmod & 0xff);\n\tmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\n\tpitch += (MOD_SENSE * modulation) / 1200;\n\tLIMITVALUE(pitch, -128, 127);\n\treturn ((unsigned char)pitch << 8) | cutoff;\n}\n\n \nstatic u32\nmake_fm2frq2(struct snd_emux_voice *vp)\n{\n\tshort pitch;\n\tunsigned char freq;\n\tint modulation;\n\n\tpitch = (char)(vp->reg.parm.fm2frq2>>8);\n\tfreq = vp->reg.parm.fm2frq2 & 0xff;\n\tmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\n\tpitch += (MOD_SENSE * modulation) / 1200;\n\tLIMITVALUE(pitch, -128, 127);\n\treturn ((unsigned char)pitch << 8) | freq;\n}\n\nstatic int get_pitch_shift(struct snd_emux *emu)\n{\n\tstruct snd_emu10k1 *hw = emu->hw;\n\n\treturn (hw->card_capabilities->emu_model &&\n\t\t\thw->emu1010.word_clock == 44100) ? 0 : -501;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}