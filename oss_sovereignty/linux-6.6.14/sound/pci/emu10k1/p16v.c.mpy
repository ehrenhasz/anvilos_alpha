{
  "module_name": "p16v.c",
  "hash_id": "1df6d200579e78d4453c29d170ec8506a4997ed368bab6e8fee1d91a4d723571",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/p16v.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/moduleparam.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n#include <sound/emu10k1.h>\n#include \"p16v.h\"\n\n#define SET_CHANNEL 0   \n#define PCM_FRONT_CHANNEL 0\n#define PCM_REAR_CHANNEL 1\n#define PCM_CENTER_LFE_CHANNEL 2\n#define PCM_SIDE_CHANNEL 3\n#define CONTROL_FRONT_CHANNEL 0\n#define CONTROL_REAR_CHANNEL 3\n#define CONTROL_CENTER_LFE_CHANNEL 1\n#define CONTROL_SIDE_CHANNEL 2\n\n \n\n  \nstatic const struct snd_pcm_hardware snd_p16v_playback_hw = {\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP | \n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\tSNDRV_PCM_INFO_RESUME |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_SYNC_START,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,  \n\t.rates =\t\tSNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100, \n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t8, \n\t.channels_max =\t\t8,\n\t.buffer_bytes_max =\t((65536 - 64) * 8),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(65536 - 64),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t8,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_p16v_capture_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100, \n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(65536 - 64),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(65536 - 128) >> 1,   \n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\n \nstatic int snd_p16v_pcm_open_playback_channel(struct snd_pcm_substream *substream, int channel_id)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n  \n\truntime->hw = snd_p16v_playback_hw;\n\n#if 0  \n\tdev_dbg(emu->card->dev,\n\t\t   \"p16v: open channel_id=%d, channel=%p, use=0x%x\\n\",\n\t\t   channel_id, channel, channel->use);\n\tdev_dbg(emu->card->dev, \"open:channel_id=%d, chip=%p, channel=%p\\n\",\n\t       channel_id, chip, channel);\n#endif  \n\t \n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n                return err;\n\n\truntime->sync.id32[0] = substream->pcm->card->number;\n\truntime->sync.id32[1] = 'P';\n\truntime->sync.id32[2] = 16;\n\truntime->sync.id32[3] = 'V';\n\n\treturn 0;\n}\n\n \nstatic int snd_p16v_pcm_open_capture_channel(struct snd_pcm_substream *substream, int channel_id)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\t \n  \n\truntime->hw = snd_p16v_capture_hw;\n\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n \nstatic int snd_p16v_pcm_close_playback(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\n \nstatic int snd_p16v_pcm_close_capture(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int snd_p16v_pcm_open_playback_front(struct snd_pcm_substream *substream)\n{\n\treturn snd_p16v_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);\n}\n\nstatic int snd_p16v_pcm_open_capture(struct snd_pcm_substream *substream)\n{\n\t\n\treturn snd_p16v_pcm_open_capture_channel(substream, 0);\n}\n\n \nstatic int snd_p16v_pcm_prepare_playback(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint channel = substream->pcm->device - emu->p16v_device_offset;\n\tu32 *table_base = (u32 *)(emu->p16v_buffer->area+(8*16*channel));\n\tu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\n\tint i;\n\tu32 tmp;\n\t\n#if 0  \n\tdev_dbg(emu->card->dev,\n\t\t\"prepare:channel_number=%d, rate=%d, \"\n\t\t   \"format=0x%x, channels=%d, buffer_size=%ld, \"\n\t\t   \"period_size=%ld, periods=%u, frames_to_bytes=%d\\n\",\n\t\t   channel, runtime->rate, runtime->format, runtime->channels,\n\t\t   runtime->buffer_size, runtime->period_size,\n\t\t   runtime->periods, frames_to_bytes(runtime, 1));\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, table_base=%p\\n\",\n\t\t   runtime->dma_addr, runtime->dma_area, table_base);\n\tdev_dbg(emu->card->dev,\n\t\t\"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\\n\",\n\t\t   emu->p16v_buffer->addr, emu->p16v_buffer->area,\n\t\t   emu->p16v_buffer->bytes);\n#endif  \n\ttmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, channel);\n\ttmp &= ~(A_SPDIF_RATE_MASK | A_EHC_SRC48_MASK);\n        switch (runtime->rate) {\n\tcase 44100:\n\t  snd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel,\n\t\t\t\ttmp | A_SPDIF_44100 | A_EHC_SRC48_44);\n\t  break;\n\tcase 96000:\n\t  snd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel,\n\t\t\t\ttmp | A_SPDIF_96000 | A_EHC_SRC48_96);\n\t  break;\n\tcase 192000:\n\t  snd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel,\n\t\t\t\ttmp | A_SPDIF_192000 | A_EHC_SRC48_192);\n\t  break;\n\tcase 48000:\n\tdefault:\n\t  snd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel,\n\t\t\t\ttmp | A_SPDIF_48000 | A_EHC_SRC48_BYPASS);\n\t  break;\n\t}\n\t \n\tfor(i = 0; i < runtime->periods; i++) {\n\t\ttable_base[i*2]=runtime->dma_addr+(i*period_size_bytes);\n\t\ttable_base[(i*2)+1]=period_size_bytes<<16;\n\t}\n \n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_ADDR, channel, emu->p16v_buffer->addr+(8*16*channel));\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_SIZE, channel, (runtime->periods - 1) << 19);\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_PTR, channel, 0);\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_DMA_ADDR, channel, runtime->dma_addr);\n\t\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_PERIOD_SIZE, channel, 0); \n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_POINTER, channel, 0);\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_FIFO_END_ADDRESS, channel, 0);\n\tsnd_emu10k1_ptr20_write(emu, PLAYBACK_FIFO_POINTER, channel, 0);\n\n\treturn 0;\n}\n\n \nstatic int snd_p16v_pcm_prepare_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint channel = substream->pcm->device - emu->p16v_device_offset;\n\n\t \n        switch (runtime->rate) {\n\tcase 44100:\n\t  snd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, channel, A_I2S_CAPTURE_44100);\n\t  break;\n\tcase 96000:\n\t  snd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, channel, A_I2S_CAPTURE_96000);\n\t  break;\n\tcase 192000:\n\t  snd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, channel, A_I2S_CAPTURE_192000);\n\t  break;\n\tcase 48000:\n\tdefault:\n\t  snd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, channel, A_I2S_CAPTURE_48000);\n\t  break;\n\t}\n\t \n\tsnd_emu10k1_ptr20_write(emu, CAPTURE_FIFO_POINTER, channel, 0);\n\tsnd_emu10k1_ptr20_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);\n\tsnd_emu10k1_ptr20_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size) << 16); \n\tsnd_emu10k1_ptr20_write(emu, CAPTURE_POINTER, channel, 0);\n\t\n\t\n\n\treturn 0;\n}\n\nstatic void snd_p16v_intr_enable(struct snd_emu10k1 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tenable = inl(emu->port + INTE2) | intrenb;\n\toutl(enable, emu->port + INTE2);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_p16v_intr_disable(struct snd_emu10k1 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int disable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tdisable = inl(emu->port + INTE2) & (~intrenb);\n\toutl(disable, emu->port + INTE2);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_p16v_interrupt(struct snd_emu10k1 *emu)\n{\n\tunsigned int status;\n\n\twhile ((status = inl(emu->port + IPR2)) != 0) {\n\t\tu32 mask = INTE2_PLAYBACK_CH_0_LOOP;   \n\n\t\t \n\t\tif (status & mask) {\n\t\t\tstruct snd_pcm_substream *substream =\n\t\t\t\t\temu->pcm_p16v->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\t\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t\t\tif (runtime && runtime->private_data) {\n\t\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\t} else {\n\t\t\t\tdev_err(emu->card->dev,\n\t\t\t\t\t\"p16v: status: 0x%08x, mask=0x%08x\\n\",\n\t\t\t\t\tstatus, mask);\n\t\t\t}\n\t\t}\n\t\tif (status & 0x110000) {\n\t\t\tstruct snd_pcm_substream *substream =\n\t\t\t\t\temu->pcm_p16v->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\t\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\t\t\t \n\t\t\tif (runtime && runtime->private_data) {\n\t\t\t\t \n\t\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\t}\n\t\t}\n\t\toutl(status, emu->port + IPR2);  \n\t}\n}\n\n \nstatic int snd_p16v_pcm_trigger_playback(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime;\n\tint channel;\n\tint result = 0;\n        struct snd_pcm_substream *s;\n\tu32 basic = 0;\n\tu32 inte = 0;\n\tint running = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\trunning=1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tdefault:\n\t\trunning = 0;\n\t\tbreak;\n\t}\n        snd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) != emu ||\n\t\t    s->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tcontinue;\n\t\truntime = s->runtime;\n\t\tchannel = substream->pcm->device-emu->p16v_device_offset;\n\t\t \n\t\truntime->private_data = (void *)(ptrdiff_t)running;\n\t\tbasic |= (0x1<<channel);\n\t\tinte |= (INTE2_PLAYBACK_CH_0_LOOP<<channel);\n                snd_pcm_trigger_done(s, substream);\n        }\n\t \n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_p16v_intr_enable(emu, inte);\n\t\tsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0)| (basic));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & ~(basic));\n\t\tsnd_p16v_intr_disable(emu, inte);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic int snd_p16v_pcm_trigger_capture(struct snd_pcm_substream *substream,\n                                   int cmd)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint channel = 0;\n\tint result = 0;\n\tu32 inte = INTE2_CAPTURE_CH_0_LOOP | INTE2_CAPTURE_CH_0_HALF_LOOP;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_p16v_intr_enable(emu, inte);\n\t\tsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0)|(0x100<<channel));\n\t\truntime->private_data = (void *)1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & ~(0x100<<channel));\n\t\tsnd_p16v_intr_disable(emu, inte);\n\t\t\n\t\truntime->private_data = NULL;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_p16v_pcm_pointer_playback(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t ptr, ptr1, ptr2,ptr3,ptr4 = 0;\n\tint channel = substream->pcm->device - emu->p16v_device_offset;\n\n\tif (!runtime->private_data)\n\t\treturn 0;\n\n\tptr3 = snd_emu10k1_ptr20_read(emu, PLAYBACK_LIST_PTR, channel);\n\tptr1 = snd_emu10k1_ptr20_read(emu, PLAYBACK_POINTER, channel);\n\tptr4 = snd_emu10k1_ptr20_read(emu, PLAYBACK_LIST_PTR, channel);\n\tif (ptr3 != ptr4) ptr1 = snd_emu10k1_ptr20_read(emu, PLAYBACK_POINTER, channel);\n\tptr2 = bytes_to_frames(runtime, ptr1);\n\tptr2+= (ptr4 >> 3) * runtime->period_size;\n\tptr=ptr2;\n        if (ptr >= runtime->buffer_size)\n\t\tptr -= runtime->buffer_size;\n\n\treturn ptr;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_p16v_pcm_pointer_capture(struct snd_pcm_substream *substream)\n{\n\tstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t ptr, ptr1, ptr2 = 0;\n\tint channel = 0;\n\n\tif (!runtime->private_data)\n\t\treturn 0;\n\n\tptr1 = snd_emu10k1_ptr20_read(emu, CAPTURE_POINTER, channel);\n\tptr2 = bytes_to_frames(runtime, ptr1);\n\tptr=ptr2;\n\tif (ptr >= runtime->buffer_size) {\n\t\tptr -= runtime->buffer_size;\n\t\tdev_warn(emu->card->dev, \"buffer capture limited!\\n\");\n\t}\n\t \n\treturn ptr;\n}\n\n \nstatic const struct snd_pcm_ops snd_p16v_playback_front_ops = {\n\t.open =        snd_p16v_pcm_open_playback_front,\n\t.close =       snd_p16v_pcm_close_playback,\n\t.prepare =     snd_p16v_pcm_prepare_playback,\n\t.trigger =     snd_p16v_pcm_trigger_playback,\n\t.pointer =     snd_p16v_pcm_pointer_playback,\n};\n\nstatic const struct snd_pcm_ops snd_p16v_capture_ops = {\n\t.open =        snd_p16v_pcm_open_capture,\n\t.close =       snd_p16v_pcm_close_capture,\n\t.prepare =     snd_p16v_pcm_prepare_capture,\n\t.trigger =     snd_p16v_pcm_trigger_capture,\n\t.pointer =     snd_p16v_pcm_pointer_capture,\n};\n\nint snd_p16v_pcm(struct snd_emu10k1 *emu, int device)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *substream;\n\tint err;\n        int capture=1;\n  \n\t \n\temu->p16v_device_offset = device;\n\n\terr = snd_pcm_new(emu->card, \"p16v\", device, 1, capture, &pcm);\n\tif (err < 0)\n\t\treturn err;\n  \n\tpcm->private_data = emu;\n\t\n\t\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_p16v_playback_front_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_p16v_capture_ops);\n\n\tpcm->info_flags = 0;\n\tpcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\n\tstrcpy(pcm->name, \"p16v\");\n\temu->pcm_p16v = pcm;\n\temu->p16v_interrupt = snd_p16v_interrupt;\n\n\tfor(substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; \n\t    substream; \n\t    substream = substream->next) {\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &emu->pci->dev,\n\t\t\t\t\t   (65536 - 64) * 8,\n\t\t\t\t\t   (65536 - 64) * 8);\n\t\t \n\t}\n\n\tfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; \n\t      substream; \n\t      substream = substream->next) {\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t   &emu->pci->dev,\n\t\t\t\t\t   65536 - 64, 65536 - 64);\n\t\t \n\t}\n  \n\treturn 0;\n}\n\nstatic int snd_p16v_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n        uinfo->count = 2;\n        uinfo->value.integer.min = 0;\n        uinfo->value.integer.max = 255;\n        return 0;\n}\n\nstatic int snd_p16v_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint high_low = (kcontrol->private_value >> 8) & 0xff;\n\tint reg = kcontrol->private_value & 0xff;\n\tu32 value;\n\n\tvalue = snd_emu10k1_ptr20_read(emu, reg, high_low);\n\tif (high_low) {\n\t\tucontrol->value.integer.value[0] = 0xff - ((value >> 24) & 0xff);  \n\t\tucontrol->value.integer.value[1] = 0xff - ((value >> 16) & 0xff);  \n\t} else {\n\t\tucontrol->value.integer.value[0] = 0xff - ((value >> 8) & 0xff);  \n\t\tucontrol->value.integer.value[1] = 0xff - ((value >> 0) & 0xff);  \n\t}\n\treturn 0;\n}\n\nstatic int snd_p16v_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n        struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint high_low = (kcontrol->private_value >> 8) & 0xff;\n\tint reg = kcontrol->private_value & 0xff;\n        u32 value, oval;\n\n\toval = value = snd_emu10k1_ptr20_read(emu, reg, 0);\n\tif (high_low == 1) {\n\t\tvalue &= 0xffff;\n\t\tvalue |= ((0xff - ucontrol->value.integer.value[0]) << 24) |\n\t\t\t((0xff - ucontrol->value.integer.value[1]) << 16);\n\t} else {\n\t\tvalue &= 0xffff0000;\n\t\tvalue |= ((0xff - ucontrol->value.integer.value[0]) << 8) |\n\t\t\t((0xff - ucontrol->value.integer.value[1]) );\n\t}\n\tif (value != oval) {\n\t\tsnd_emu10k1_ptr20_write(emu, reg, 0, value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_p16v_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[8] = {\n\t\t\"SPDIF\", \"I2S\", \"SRC48\", \"SRCMulti_SPDIF\", \"SRCMulti_I2S\",\n\t\t\"CDIF\", \"FX\", \"AC97\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 8, texts);\n}\n\nstatic int snd_p16v_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->p16v_capture_source;\n\treturn 0;\n}\n\nstatic int snd_p16v_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\tu32 mask;\n\tu32 source;\n\n\tval = ucontrol->value.enumerated.item[0] ;\n\tif (val > 7)\n\t\treturn -EINVAL;\n\tchange = (emu->p16v_capture_source != val);\n\tif (change) {\n\t\temu->p16v_capture_source = val;\n\t\tsource = (val << 28) | (val << 24) | (val << 20) | (val << 16);\n\t\tmask = snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & 0xffff;\n\t\tsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, source | mask);\n\t}\n        return change;\n}\n\nstatic int snd_p16v_capture_channel_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = { \"0\", \"1\", \"2\", \"3\", };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\n\nstatic int snd_p16v_capture_channel_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->p16v_capture_channel;\n\treturn 0;\n}\n\nstatic int snd_p16v_capture_channel_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\tu32 tmp;\n\n\tval = ucontrol->value.enumerated.item[0] ;\n\tif (val > 3)\n\t\treturn -EINVAL;\n\tchange = (emu->p16v_capture_channel != val);\n\tif (change) {\n\t\temu->p16v_capture_channel = val;\n\t\ttmp = snd_emu10k1_ptr20_read(emu, CAPTURE_P16V_SOURCE, 0) & 0xfffc;\n\t\tsnd_emu10k1_ptr20_write(emu, CAPTURE_P16V_SOURCE, 0, tmp | val);\n\t}\n        return change;\n}\nstatic const DECLARE_TLV_DB_SCALE(snd_p16v_db_scale1, -5175, 25, 1);\n\n#define P16V_VOL(xname,xreg,xhl) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |             \\\n                  SNDRV_CTL_ELEM_ACCESS_TLV_READ,               \\\n\t.info = snd_p16v_volume_info, \\\n\t.get = snd_p16v_volume_get, \\\n\t.put = snd_p16v_volume_put, \\\n\t.tlv = { .p = snd_p16v_db_scale1 },\t\\\n\t.private_value = ((xreg) | ((xhl) << 8)) \\\n}\n\nstatic const struct snd_kcontrol_new p16v_mixer_controls[] = {\n\tP16V_VOL(\"HD Analog Front Playback Volume\", PLAYBACK_VOLUME_MIXER9, 0),\n\tP16V_VOL(\"HD Analog Rear Playback Volume\", PLAYBACK_VOLUME_MIXER10, 1),\n\tP16V_VOL(\"HD Analog Center/LFE Playback Volume\", PLAYBACK_VOLUME_MIXER9, 1),\n\tP16V_VOL(\"HD Analog Side Playback Volume\", PLAYBACK_VOLUME_MIXER10, 0),\n\tP16V_VOL(\"HD SPDIF Front Playback Volume\", PLAYBACK_VOLUME_MIXER7, 0),\n\tP16V_VOL(\"HD SPDIF Rear Playback Volume\", PLAYBACK_VOLUME_MIXER8, 1),\n\tP16V_VOL(\"HD SPDIF Center/LFE Playback Volume\", PLAYBACK_VOLUME_MIXER7, 1),\n\tP16V_VOL(\"HD SPDIF Side Playback Volume\", PLAYBACK_VOLUME_MIXER8, 0),\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"HD source Capture\",\n\t\t.info =\t\tsnd_p16v_capture_source_info,\n\t\t.get =\t\tsnd_p16v_capture_source_get,\n\t\t.put =\t\tsnd_p16v_capture_source_put\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"HD channel Capture\",\n\t\t.info =\t\tsnd_p16v_capture_channel_info,\n\t\t.get =\t\tsnd_p16v_capture_channel_get,\n\t\t.put =\t\tsnd_p16v_capture_channel_put\n\t},\n};\n\n\nint snd_p16v_mixer(struct snd_emu10k1 *emu)\n{\n\tint i, err;\n        struct snd_card *card = emu->card;\n\n\tfor (i = 0; i < ARRAY_SIZE(p16v_mixer_controls); i++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&p16v_mixer_controls[i], emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n        return 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\n#define NUM_CHS\t1\t \n\nint snd_p16v_alloc_pm_buffer(struct snd_emu10k1 *emu)\n{\n\temu->p16v_saved = vmalloc(array_size(NUM_CHS * 4, 0x80));\n\tif (! emu->p16v_saved)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid snd_p16v_free_pm_buffer(struct snd_emu10k1 *emu)\n{\n\tvfree(emu->p16v_saved);\n}\n\nvoid snd_p16v_suspend(struct snd_emu10k1 *emu)\n{\n\tint i, ch;\n\tunsigned int *val;\n\n\tval = emu->p16v_saved;\n\tfor (ch = 0; ch < NUM_CHS; ch++)\n\t\tfor (i = 0; i < 0x80; i++, val++)\n\t\t\t*val = snd_emu10k1_ptr20_read(emu, i, ch);\n}\n\nvoid snd_p16v_resume(struct snd_emu10k1 *emu)\n{\n\tint i, ch;\n\tunsigned int *val;\n\n\tval = emu->p16v_saved;\n\tfor (ch = 0; ch < NUM_CHS; ch++)\n\t\tfor (i = 0; i < 0x80; i++, val++)\n\t\t\tsnd_emu10k1_ptr20_write(emu, i, ch, *val);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}