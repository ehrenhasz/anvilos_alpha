{
  "module_name": "emumixer.c",
  "hash_id": "c15a26a820ad49874fa1aaba35187af20916557709e364ba6df1678702a95523",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emumixer.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n#include <linux/delay.h>\n#include <sound/tlv.h>\n\n#include \"p17v.h\"\n\n#define AC97_ID_STAC9758\t0x83847658\n\nstatic const DECLARE_TLV_DB_SCALE(snd_audigy_db_scale2, -10350, 50, 1);  \n\n\nstatic int add_ctls(struct snd_emu10k1 *emu, const struct snd_kcontrol_new *tpl,\n\t\t    const char * const *ctls, unsigned nctls)\n{\n\tstruct snd_kcontrol_new kctl = *tpl;\n\tint err;\n\n\tfor (unsigned i = 0; i < nctls; i++) {\n\t\tkctl.name = ctls[i];\n\t\tkctl.private_value = i;\n\t\terr = snd_ctl_add(emu->card, snd_ctl_new1(&kctl, emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\nstatic int snd_emu10k1_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_spdif_get(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\n\t \n\tif (idx >= 3)\n\t\treturn -EINVAL;\n\tucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_spdif_get_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\n#define PAIR_PS(base, one, two, sfx) base \" \" one sfx, base \" \" two sfx\n#define LR_PS(base, sfx) PAIR_PS(base, \"Left\", \"Right\", sfx)\n\n#define ADAT_PS(pfx, sfx) \\\n\tpfx \"ADAT 0\" sfx, pfx \"ADAT 1\" sfx, pfx \"ADAT 2\" sfx, pfx \"ADAT 3\" sfx, \\\n\tpfx \"ADAT 4\" sfx, pfx \"ADAT 5\" sfx, pfx \"ADAT 6\" sfx, pfx \"ADAT 7\" sfx\n\n#define PAIR_REGS(base, one, two) \\\n\tbase ## one ## 1, \\\n\tbase ## two ## 1\n\n#define LR_REGS(base) PAIR_REGS(base, _LEFT, _RIGHT)\n\n#define ADAT_REGS(base) \\\n\tbase+0, base+1, base+2, base+3, base+4, base+5, base+6, base+7\n\n \n\n#define DSP_TEXTS \\\n\t\"DSP 0\", \"DSP 1\", \"DSP 2\", \"DSP 3\", \"DSP 4\", \"DSP 5\", \"DSP 6\", \"DSP 7\", \\\n\t\"DSP 8\", \"DSP 9\", \"DSP 10\", \"DSP 11\", \"DSP 12\", \"DSP 13\", \"DSP 14\", \"DSP 15\", \\\n\t\"DSP 16\", \"DSP 17\", \"DSP 18\", \"DSP 19\", \"DSP 20\", \"DSP 21\", \"DSP 22\", \"DSP 23\", \\\n\t\"DSP 24\", \"DSP 25\", \"DSP 26\", \"DSP 27\", \"DSP 28\", \"DSP 29\", \"DSP 30\", \"DSP 31\"\n\n#define PAIR_TEXTS(base, one, two) PAIR_PS(base, one, two, \"\")\n#define LR_TEXTS(base) LR_PS(base, \"\")\n#define ADAT_TEXTS(pfx) ADAT_PS(pfx, \"\")\n\n#define EMU32_SRC_REGS \\\n\tEMU_SRC_ALICE_EMU32A, \\\n\tEMU_SRC_ALICE_EMU32A+1, \\\n\tEMU_SRC_ALICE_EMU32A+2, \\\n\tEMU_SRC_ALICE_EMU32A+3, \\\n\tEMU_SRC_ALICE_EMU32A+4, \\\n\tEMU_SRC_ALICE_EMU32A+5, \\\n\tEMU_SRC_ALICE_EMU32A+6, \\\n\tEMU_SRC_ALICE_EMU32A+7, \\\n\tEMU_SRC_ALICE_EMU32A+8, \\\n\tEMU_SRC_ALICE_EMU32A+9, \\\n\tEMU_SRC_ALICE_EMU32A+0xa, \\\n\tEMU_SRC_ALICE_EMU32A+0xb, \\\n\tEMU_SRC_ALICE_EMU32A+0xc, \\\n\tEMU_SRC_ALICE_EMU32A+0xd, \\\n\tEMU_SRC_ALICE_EMU32A+0xe, \\\n\tEMU_SRC_ALICE_EMU32A+0xf, \\\n\tEMU_SRC_ALICE_EMU32B, \\\n\tEMU_SRC_ALICE_EMU32B+1, \\\n\tEMU_SRC_ALICE_EMU32B+2, \\\n\tEMU_SRC_ALICE_EMU32B+3, \\\n\tEMU_SRC_ALICE_EMU32B+4, \\\n\tEMU_SRC_ALICE_EMU32B+5, \\\n\tEMU_SRC_ALICE_EMU32B+6, \\\n\tEMU_SRC_ALICE_EMU32B+7, \\\n\tEMU_SRC_ALICE_EMU32B+8, \\\n\tEMU_SRC_ALICE_EMU32B+9, \\\n\tEMU_SRC_ALICE_EMU32B+0xa, \\\n\tEMU_SRC_ALICE_EMU32B+0xb, \\\n\tEMU_SRC_ALICE_EMU32B+0xc, \\\n\tEMU_SRC_ALICE_EMU32B+0xd, \\\n\tEMU_SRC_ALICE_EMU32B+0xe, \\\n\tEMU_SRC_ALICE_EMU32B+0xf\n\n \n\n#define EMU1010_COMMON_TEXTS \\\n\t\"Silence\", \\\n\tPAIR_TEXTS(\"Dock Mic\", \"A\", \"B\"), \\\n\tLR_TEXTS(\"Dock ADC1\"), \\\n\tLR_TEXTS(\"Dock ADC2\"), \\\n\tLR_TEXTS(\"Dock ADC3\"), \\\n\tLR_TEXTS(\"0202 ADC\"), \\\n\tLR_TEXTS(\"1010 SPDIF\"), \\\n\tADAT_TEXTS(\"1010 \")\n\nstatic const char * const emu1010_src_texts[] = {\n\tEMU1010_COMMON_TEXTS,\n\tDSP_TEXTS,\n};\n\nstatic const unsigned short emu1010_src_regs[] = {\n\tEMU_SRC_SILENCE,\n\tPAIR_REGS(EMU_SRC_DOCK_MIC, _A, _B),\n\tLR_REGS(EMU_SRC_DOCK_ADC1),\n\tLR_REGS(EMU_SRC_DOCK_ADC2),\n\tLR_REGS(EMU_SRC_DOCK_ADC3),\n\tLR_REGS(EMU_SRC_HAMOA_ADC),\n\tLR_REGS(EMU_SRC_HANA_SPDIF),\n\tADAT_REGS(EMU_SRC_HANA_ADAT),\n\tEMU32_SRC_REGS,\n};\nstatic_assert(ARRAY_SIZE(emu1010_src_regs) == ARRAY_SIZE(emu1010_src_texts));\n\n \n\n#define EMU1010b_COMMON_TEXTS \\\n\t\"Silence\", \\\n\tPAIR_TEXTS(\"Dock Mic\", \"A\", \"B\"), \\\n\tLR_TEXTS(\"Dock ADC1\"), \\\n\tLR_TEXTS(\"Dock ADC2\"), \\\n\tLR_TEXTS(\"0202 ADC\"), \\\n\tLR_TEXTS(\"Dock SPDIF\"), \\\n\tLR_TEXTS(\"1010 SPDIF\"), \\\n\tADAT_TEXTS(\"Dock \"), \\\n\tADAT_TEXTS(\"1010 \")\n\nstatic const char * const emu1010b_src_texts[] = {\n\tEMU1010b_COMMON_TEXTS,\n\tDSP_TEXTS,\n};\n\nstatic const unsigned short emu1010b_src_regs[] = {\n\tEMU_SRC_SILENCE,\n\tPAIR_REGS(EMU_SRC_DOCK_MIC, _A, _B),\n\tLR_REGS(EMU_SRC_DOCK_ADC1),\n\tLR_REGS(EMU_SRC_DOCK_ADC2),\n\tLR_REGS(EMU_SRC_HAMOA_ADC),\n\tLR_REGS(EMU_SRC_MDOCK_SPDIF),\n\tLR_REGS(EMU_SRC_HANA_SPDIF),\n\tADAT_REGS(EMU_SRC_MDOCK_ADAT),\n\tADAT_REGS(EMU_SRC_HANA_ADAT),\n\tEMU32_SRC_REGS,\n};\nstatic_assert(ARRAY_SIZE(emu1010b_src_regs) == ARRAY_SIZE(emu1010b_src_texts));\n\n \n\n#define EMU1616_COMMON_TEXTS \\\n\t\"Silence\", \\\n\tPAIR_TEXTS(\"Mic\", \"A\", \"B\"), \\\n\tLR_TEXTS(\"ADC1\"), \\\n\tLR_TEXTS(\"ADC2\"), \\\n\tLR_TEXTS(\"SPDIF\"), \\\n\tADAT_TEXTS(\"\")\n\nstatic const char * const emu1616_src_texts[] = {\n\tEMU1616_COMMON_TEXTS,\n\tDSP_TEXTS,\n};\n\nstatic const unsigned short emu1616_src_regs[] = {\n\tEMU_SRC_SILENCE,\n\tPAIR_REGS(EMU_SRC_DOCK_MIC, _A, _B),\n\tLR_REGS(EMU_SRC_DOCK_ADC1),\n\tLR_REGS(EMU_SRC_DOCK_ADC2),\n\tLR_REGS(EMU_SRC_MDOCK_SPDIF),\n\tADAT_REGS(EMU_SRC_MDOCK_ADAT),\n\tEMU32_SRC_REGS,\n};\nstatic_assert(ARRAY_SIZE(emu1616_src_regs) == ARRAY_SIZE(emu1616_src_texts));\n\n \n\n#define EMU0404_COMMON_TEXTS \\\n\t\"Silence\", \\\n\tLR_TEXTS(\"ADC\"), \\\n\tLR_TEXTS(\"SPDIF\")\n\nstatic const char * const emu0404_src_texts[] = {\n\tEMU0404_COMMON_TEXTS,\n\tDSP_TEXTS,\n};\n\nstatic const unsigned short emu0404_src_regs[] = {\n\tEMU_SRC_SILENCE,\n\tLR_REGS(EMU_SRC_HAMOA_ADC),\n\tLR_REGS(EMU_SRC_HANA_SPDIF),\n\tEMU32_SRC_REGS,\n};\nstatic_assert(ARRAY_SIZE(emu0404_src_regs) == ARRAY_SIZE(emu0404_src_texts));\n\n \n\n#define LR_CTLS(base) LR_PS(base, \" Playback Enum\")\n#define ADAT_CTLS(pfx) ADAT_PS(pfx, \" Playback Enum\")\n\n \n\nstatic const char * const emu1010_output_texts[] = {\n\tLR_CTLS(\"Dock DAC1\"),\n\tLR_CTLS(\"Dock DAC2\"),\n\tLR_CTLS(\"Dock DAC3\"),\n\tLR_CTLS(\"Dock DAC4\"),\n\tLR_CTLS(\"Dock Phones\"),\n\tLR_CTLS(\"Dock SPDIF\"),\n\tLR_CTLS(\"0202 DAC\"),\n\tLR_CTLS(\"1010 SPDIF\"),\n\tADAT_CTLS(\"1010 \"),\n};\nstatic_assert(ARRAY_SIZE(emu1010_output_texts) <= NUM_OUTPUT_DESTS);\n\nstatic const unsigned short emu1010_output_dst[] = {\n\tLR_REGS(EMU_DST_DOCK_DAC1),\n\tLR_REGS(EMU_DST_DOCK_DAC2),\n\tLR_REGS(EMU_DST_DOCK_DAC3),\n\tLR_REGS(EMU_DST_DOCK_DAC4),\n\tLR_REGS(EMU_DST_DOCK_PHONES),\n\tLR_REGS(EMU_DST_DOCK_SPDIF),\n\tLR_REGS(EMU_DST_HAMOA_DAC),\n\tLR_REGS(EMU_DST_HANA_SPDIF),\n\tADAT_REGS(EMU_DST_HANA_ADAT),\n};\nstatic_assert(ARRAY_SIZE(emu1010_output_dst) == ARRAY_SIZE(emu1010_output_texts));\n\nstatic const unsigned short emu1010_output_dflt[] = {\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5,\n\tEMU_SRC_ALICE_EMU32A+6, EMU_SRC_ALICE_EMU32A+7,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1, EMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5, EMU_SRC_ALICE_EMU32A+6, EMU_SRC_ALICE_EMU32A+7,\n};\nstatic_assert(ARRAY_SIZE(emu1010_output_dflt) == ARRAY_SIZE(emu1010_output_dst));\n\n \n\nstatic const char * const snd_emu1010b_output_texts[] = {\n\tLR_CTLS(\"Dock DAC1\"),\n\tLR_CTLS(\"Dock DAC2\"),\n\tLR_CTLS(\"Dock DAC3\"),\n\tLR_CTLS(\"Dock SPDIF\"),\n\tADAT_CTLS(\"Dock \"),\n\tLR_CTLS(\"0202 DAC\"),\n\tLR_CTLS(\"1010 SPDIF\"),\n\tADAT_CTLS(\"1010 \"),\n};\nstatic_assert(ARRAY_SIZE(snd_emu1010b_output_texts) <= NUM_OUTPUT_DESTS);\n\nstatic const unsigned short emu1010b_output_dst[] = {\n\tLR_REGS(EMU_DST_DOCK_DAC1),\n\tLR_REGS(EMU_DST_DOCK_DAC2),\n\tLR_REGS(EMU_DST_DOCK_DAC3),\n\tLR_REGS(EMU_DST_MDOCK_SPDIF),\n\tADAT_REGS(EMU_DST_MDOCK_ADAT),\n\tLR_REGS(EMU_DST_HAMOA_DAC),\n\tLR_REGS(EMU_DST_HANA_SPDIF),\n\tADAT_REGS(EMU_DST_HANA_ADAT),\n};\nstatic_assert(ARRAY_SIZE(emu1010b_output_dst) == ARRAY_SIZE(snd_emu1010b_output_texts));\n\nstatic const unsigned short emu1010b_output_dflt[] = {\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1, EMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5, EMU_SRC_ALICE_EMU32A+6, EMU_SRC_ALICE_EMU32A+7,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1, EMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5, EMU_SRC_ALICE_EMU32A+6, EMU_SRC_ALICE_EMU32A+7,\n};\n\n \n\nstatic const char * const snd_emu1616_output_texts[] = {\n\tLR_CTLS(\"Dock DAC1\"),\n\tLR_CTLS(\"Dock DAC2\"),\n\tLR_CTLS(\"Dock DAC3\"),\n\tLR_CTLS(\"Dock SPDIF\"),\n\tADAT_CTLS(\"Dock \"),\n\tLR_CTLS(\"Mana DAC\"),\n};\nstatic_assert(ARRAY_SIZE(snd_emu1616_output_texts) <= NUM_OUTPUT_DESTS);\n\nstatic const unsigned short emu1616_output_dst[] = {\n\tLR_REGS(EMU_DST_DOCK_DAC1),\n\tLR_REGS(EMU_DST_DOCK_DAC2),\n\tLR_REGS(EMU_DST_DOCK_DAC3),\n\tLR_REGS(EMU_DST_MDOCK_SPDIF),\n\tADAT_REGS(EMU_DST_MDOCK_ADAT),\n\tEMU_DST_MANA_DAC_LEFT, EMU_DST_MANA_DAC_RIGHT,\n};\nstatic_assert(ARRAY_SIZE(emu1616_output_dst) == ARRAY_SIZE(snd_emu1616_output_texts));\n\nstatic const unsigned short emu1616_output_dflt[] = {\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1, EMU_SRC_ALICE_EMU32A+2, EMU_SRC_ALICE_EMU32A+3,\n\tEMU_SRC_ALICE_EMU32A+4, EMU_SRC_ALICE_EMU32A+5, EMU_SRC_ALICE_EMU32A+6, EMU_SRC_ALICE_EMU32A+7,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n};\nstatic_assert(ARRAY_SIZE(emu1616_output_dflt) == ARRAY_SIZE(emu1616_output_dst));\n\n \n\nstatic const char * const snd_emu0404_output_texts[] = {\n\tLR_CTLS(\"DAC\"),\n\tLR_CTLS(\"SPDIF\"),\n};\nstatic_assert(ARRAY_SIZE(snd_emu0404_output_texts) <= NUM_OUTPUT_DESTS);\n\nstatic const unsigned short emu0404_output_dst[] = {\n\tLR_REGS(EMU_DST_HAMOA_DAC),\n\tLR_REGS(EMU_DST_HANA_SPDIF),\n};\nstatic_assert(ARRAY_SIZE(emu0404_output_dst) == ARRAY_SIZE(snd_emu0404_output_texts));\n\nstatic const unsigned short emu0404_output_dflt[] = {\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n\tEMU_SRC_ALICE_EMU32A+0, EMU_SRC_ALICE_EMU32A+1,\n};\nstatic_assert(ARRAY_SIZE(emu0404_output_dflt) == ARRAY_SIZE(emu0404_output_dst));\n\n \n\nstatic const char * const emu1010_input_texts[] = {\n\t\"DSP 0 Capture Enum\",\n\t\"DSP 1 Capture Enum\",\n\t\"DSP 2 Capture Enum\",\n\t\"DSP 3 Capture Enum\",\n\t\"DSP 4 Capture Enum\",\n\t\"DSP 5 Capture Enum\",\n\t\"DSP 6 Capture Enum\",\n\t\"DSP 7 Capture Enum\",\n\t\"DSP 8 Capture Enum\",\n\t\"DSP 9 Capture Enum\",\n\t\"DSP A Capture Enum\",\n\t\"DSP B Capture Enum\",\n\t\"DSP C Capture Enum\",\n\t\"DSP D Capture Enum\",\n\t\"DSP E Capture Enum\",\n\t\"DSP F Capture Enum\",\n\t \n\t\"DSP 10 Capture Enum\",\n\t\"DSP 11 Capture Enum\",\n\t\"DSP 12 Capture Enum\",\n\t\"DSP 13 Capture Enum\",\n\t\"DSP 14 Capture Enum\",\n\t\"DSP 15 Capture Enum\",\n};\nstatic_assert(ARRAY_SIZE(emu1010_input_texts) <= NUM_INPUT_DESTS);\n\nstatic const unsigned short emu1010_input_dst[] = {\n\tEMU_DST_ALICE2_EMU32_0,\n\tEMU_DST_ALICE2_EMU32_1,\n\tEMU_DST_ALICE2_EMU32_2,\n\tEMU_DST_ALICE2_EMU32_3,\n\tEMU_DST_ALICE2_EMU32_4,\n\tEMU_DST_ALICE2_EMU32_5,\n\tEMU_DST_ALICE2_EMU32_6,\n\tEMU_DST_ALICE2_EMU32_7,\n\tEMU_DST_ALICE2_EMU32_8,\n\tEMU_DST_ALICE2_EMU32_9,\n\tEMU_DST_ALICE2_EMU32_A,\n\tEMU_DST_ALICE2_EMU32_B,\n\tEMU_DST_ALICE2_EMU32_C,\n\tEMU_DST_ALICE2_EMU32_D,\n\tEMU_DST_ALICE2_EMU32_E,\n\tEMU_DST_ALICE2_EMU32_F,\n\t \n\tEMU_DST_ALICE_I2S0_LEFT,\n\tEMU_DST_ALICE_I2S0_RIGHT,\n\tEMU_DST_ALICE_I2S1_LEFT,\n\tEMU_DST_ALICE_I2S1_RIGHT,\n\tEMU_DST_ALICE_I2S2_LEFT,\n\tEMU_DST_ALICE_I2S2_RIGHT,\n};\nstatic_assert(ARRAY_SIZE(emu1010_input_dst) == ARRAY_SIZE(emu1010_input_texts));\n\nstatic const unsigned short emu1010_input_dflt[] = {\n\tEMU_SRC_DOCK_MIC_A1,\n\tEMU_SRC_DOCK_MIC_B1,\n\tEMU_SRC_HAMOA_ADC_LEFT1,\n\tEMU_SRC_HAMOA_ADC_RIGHT1,\n\tEMU_SRC_DOCK_ADC1_LEFT1,\n\tEMU_SRC_DOCK_ADC1_RIGHT1,\n\tEMU_SRC_DOCK_ADC2_LEFT1,\n\tEMU_SRC_DOCK_ADC2_RIGHT1,\n\t \n\tEMU_SRC_DOCK_MIC_A1,\n\tEMU_SRC_DOCK_MIC_B1,\n\tEMU_SRC_HAMOA_ADC_LEFT1,\n\tEMU_SRC_HAMOA_ADC_RIGHT1,\n\tEMU_SRC_DOCK_ADC1_LEFT1,\n\tEMU_SRC_DOCK_ADC1_RIGHT1,\n\tEMU_SRC_DOCK_ADC2_LEFT1,\n\tEMU_SRC_DOCK_ADC2_RIGHT1,\n\n\tEMU_SRC_DOCK_ADC1_LEFT1,\n\tEMU_SRC_DOCK_ADC1_RIGHT1,\n\tEMU_SRC_DOCK_ADC2_LEFT1,\n\tEMU_SRC_DOCK_ADC2_RIGHT1,\n\tEMU_SRC_DOCK_ADC3_LEFT1,\n\tEMU_SRC_DOCK_ADC3_RIGHT1,\n};\nstatic_assert(ARRAY_SIZE(emu1010_input_dflt) == ARRAY_SIZE(emu1010_input_dst));\n\nstatic const unsigned short emu0404_input_dflt[] = {\n\tEMU_SRC_HAMOA_ADC_LEFT1,\n\tEMU_SRC_HAMOA_ADC_RIGHT1,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_HANA_SPDIF_LEFT1,\n\tEMU_SRC_HANA_SPDIF_RIGHT1,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n\tEMU_SRC_SILENCE,\n};\n\nstruct snd_emu1010_routing_info {\n\tconst char * const *src_texts;\n\tconst char * const *out_texts;\n\tconst unsigned short *src_regs;\n\tconst unsigned short *out_regs;\n\tconst unsigned short *in_regs;\n\tconst unsigned short *out_dflts;\n\tconst unsigned short *in_dflts;\n\tunsigned n_srcs;\n\tunsigned n_outs;\n\tunsigned n_ins;\n};\n\nstatic const struct snd_emu1010_routing_info emu1010_routing_info[] = {\n\t{\n\t\t \n\t\t.src_regs = emu1010_src_regs,\n\t\t.src_texts = emu1010_src_texts,\n\t\t.n_srcs = ARRAY_SIZE(emu1010_src_texts),\n\n\t\t.out_dflts = emu1010_output_dflt,\n\t\t.out_regs = emu1010_output_dst,\n\t\t.out_texts = emu1010_output_texts,\n\t\t.n_outs = ARRAY_SIZE(emu1010_output_dst),\n\n\t\t.in_dflts = emu1010_input_dflt,\n\t\t.in_regs = emu1010_input_dst,\n\t\t.n_ins = ARRAY_SIZE(emu1010_input_dst),\n\t},\n\t{\n\t\t \n\t\t.src_regs = emu1010b_src_regs,\n\t\t.src_texts = emu1010b_src_texts,\n\t\t.n_srcs = ARRAY_SIZE(emu1010b_src_texts),\n\n\t\t.out_dflts = emu1010b_output_dflt,\n\t\t.out_regs = emu1010b_output_dst,\n\t\t.out_texts = snd_emu1010b_output_texts,\n\t\t.n_outs = ARRAY_SIZE(emu1010b_output_dst),\n\n\t\t.in_dflts = emu1010_input_dflt,\n\t\t.in_regs = emu1010_input_dst,\n\t\t.n_ins = ARRAY_SIZE(emu1010_input_dst) - 6,\n\t},\n\t{\n\t\t \n\t\t.src_regs = emu1616_src_regs,\n\t\t.src_texts = emu1616_src_texts,\n\t\t.n_srcs = ARRAY_SIZE(emu1616_src_texts),\n\n\t\t.out_dflts = emu1616_output_dflt,\n\t\t.out_regs = emu1616_output_dst,\n\t\t.out_texts = snd_emu1616_output_texts,\n\t\t.n_outs = ARRAY_SIZE(emu1616_output_dst),\n\n\t\t.in_dflts = emu1010_input_dflt,\n\t\t.in_regs = emu1010_input_dst,\n\t\t.n_ins = ARRAY_SIZE(emu1010_input_dst) - 6,\n\t},\n\t{\n\t\t \n\t\t.src_regs = emu0404_src_regs,\n\t\t.src_texts = emu0404_src_texts,\n\t\t.n_srcs = ARRAY_SIZE(emu0404_src_texts),\n\n\t\t.out_dflts = emu0404_output_dflt,\n\t\t.out_regs = emu0404_output_dst,\n\t\t.out_texts = snd_emu0404_output_texts,\n\t\t.n_outs = ARRAY_SIZE(emu0404_output_dflt),\n\n\t\t.in_dflts = emu0404_input_dflt,\n\t\t.in_regs = emu1010_input_dst,\n\t\t.n_ins = ARRAY_SIZE(emu1010_input_dst) - 6,\n\t},\n};\n\nstatic unsigned emu1010_idx(struct snd_emu10k1 *emu)\n{\n\treturn emu->card_capabilities->emu_model - 1;\n}\n\nstatic void snd_emu1010_output_source_apply(struct snd_emu10k1 *emu,\n\t\t\t\t\t    int channel, int src)\n{\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\n\tsnd_emu1010_fpga_link_dst_src_write(emu,\n\t\temu_ri->out_regs[channel], emu_ri->src_regs[src]);\n}\n\nstatic void snd_emu1010_input_source_apply(struct snd_emu10k1 *emu,\n\t\t\t\t\t   int channel, int src)\n{\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\n\tsnd_emu1010_fpga_link_dst_src_write(emu,\n\t\temu_ri->in_regs[channel], emu_ri->src_regs[src]);\n}\n\nstatic void snd_emu1010_apply_sources(struct snd_emu10k1 *emu)\n{\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\n\tfor (unsigned i = 0; i < emu_ri->n_outs; i++)\n\t\tsnd_emu1010_output_source_apply(\n\t\t\temu, i, emu->emu1010.output_source[i]);\n\tfor (unsigned i = 0; i < emu_ri->n_ins; i++)\n\t\tsnd_emu1010_input_source_apply(\n\t\t\temu, i, emu->emu1010.input_source[i]);\n}\n\nstatic u8 emu1010_map_source(const struct snd_emu1010_routing_info *emu_ri,\n\t\t\t     unsigned val)\n{\n\tfor (unsigned i = 0; i < emu_ri->n_srcs; i++)\n\t\tif (val == emu_ri->src_regs[i])\n\t\t\treturn i;\n\treturn 0;\n}\n\nstatic int snd_emu1010_input_output_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\n\treturn snd_ctl_enum_info(uinfo, 1, emu_ri->n_srcs, emu_ri->src_texts);\n}\n\nstatic int snd_emu1010_output_source_get(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\tunsigned channel = kcontrol->private_value;\n\n\tif (channel >= emu_ri->n_outs)\n\t\treturn -EINVAL;\n\tucontrol->value.enumerated.item[0] = emu->emu1010.output_source[channel];\n\treturn 0;\n}\n\nstatic int snd_emu1010_output_source_put(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\tunsigned val = ucontrol->value.enumerated.item[0];\n\tunsigned channel = kcontrol->private_value;\n\tint change;\n\n\tif (val >= emu_ri->n_srcs)\n\t\treturn -EINVAL;\n\tif (channel >= emu_ri->n_outs)\n\t\treturn -EINVAL;\n\tchange = (emu->emu1010.output_source[channel] != val);\n\tif (change) {\n\t\temu->emu1010.output_source[channel] = val;\n\t\tsnd_emu1010_output_source_apply(emu, channel, val);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new emu1010_output_source_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_emu1010_input_output_source_info,\n\t.get = snd_emu1010_output_source_get,\n\t.put = snd_emu1010_output_source_put\n};\n\nstatic int snd_emu1010_input_source_get(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\tunsigned channel = kcontrol->private_value;\n\n\tif (channel >= emu_ri->n_ins)\n\t\treturn -EINVAL;\n\tucontrol->value.enumerated.item[0] = emu->emu1010.input_source[channel];\n\treturn 0;\n}\n\nstatic int snd_emu1010_input_source_put(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\tunsigned val = ucontrol->value.enumerated.item[0];\n\tunsigned channel = kcontrol->private_value;\n\tint change;\n\n\tif (val >= emu_ri->n_srcs)\n\t\treturn -EINVAL;\n\tif (channel >= emu_ri->n_ins)\n\t\treturn -EINVAL;\n\tchange = (emu->emu1010.input_source[channel] != val);\n\tif (change) {\n\t\temu->emu1010.input_source[channel] = val;\n\t\tsnd_emu1010_input_source_apply(emu, channel, val);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new emu1010_input_source_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_emu1010_input_output_source_info,\n\t.get = snd_emu1010_input_source_get,\n\t.put = snd_emu1010_input_source_put\n};\n\nstatic int add_emu1010_source_mixers(struct snd_emu10k1 *emu)\n{\n\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t&emu1010_routing_info[emu1010_idx(emu)];\n\tint err;\n\n\terr = add_ctls(emu, &emu1010_output_source_ctl,\n\t\t       emu_ri->out_texts, emu_ri->n_outs);\n\tif (err < 0)\n\t\treturn err;\n\terr = add_ctls(emu, &emu1010_input_source_ctl,\n\t\t       emu1010_input_texts, emu_ri->n_ins);\n\treturn err;\n}\n\n\nstatic const char * const snd_emu1010_adc_pads[] = {\n\t\"ADC1 14dB PAD 0202 Capture Switch\",\n\t\"ADC1 14dB PAD Audio Dock Capture Switch\",\n\t\"ADC2 14dB PAD Audio Dock Capture Switch\",\n\t\"ADC3 14dB PAD Audio Dock Capture Switch\",\n};\n\nstatic const unsigned short snd_emu1010_adc_pad_regs[] = {\n\tEMU_HANA_0202_ADC_PAD1,\n\tEMU_HANA_DOCK_ADC_PAD1,\n\tEMU_HANA_DOCK_ADC_PAD2,\n\tEMU_HANA_DOCK_ADC_PAD3,\n};\n\n#define snd_emu1010_adc_pads_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_emu1010_adc_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask = snd_emu1010_adc_pad_regs[kcontrol->private_value];\n\n\tucontrol->value.integer.value[0] = (emu->emu1010.adc_pads & mask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_emu1010_adc_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask = snd_emu1010_adc_pad_regs[kcontrol->private_value];\n\tunsigned int val, cache;\n\tint change;\n\n\tval = ucontrol->value.integer.value[0];\n\tcache = emu->emu1010.adc_pads;\n\tif (val == 1) \n\t\tcache = cache | mask;\n\telse\n\t\tcache = cache & ~mask;\n\tchange = (cache != emu->emu1010.adc_pads);\n\tif (change) {\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_ADC_PADS, cache );\n\t        emu->emu1010.adc_pads = cache;\n\t}\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new emu1010_adc_pads_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_emu1010_adc_pads_info,\n\t.get = snd_emu1010_adc_pads_get,\n\t.put = snd_emu1010_adc_pads_put\n};\n\n\nstatic const char * const snd_emu1010_dac_pads[] = {\n\t\"DAC1 0202 14dB PAD Playback Switch\",\n\t\"DAC1 Audio Dock 14dB PAD Playback Switch\",\n\t\"DAC2 Audio Dock 14dB PAD Playback Switch\",\n\t\"DAC3 Audio Dock 14dB PAD Playback Switch\",\n\t\"DAC4 Audio Dock 14dB PAD Playback Switch\",\n};\n\nstatic const unsigned short snd_emu1010_dac_regs[] = {\n\tEMU_HANA_0202_DAC_PAD1,\n\tEMU_HANA_DOCK_DAC_PAD1,\n\tEMU_HANA_DOCK_DAC_PAD2,\n\tEMU_HANA_DOCK_DAC_PAD3,\n\tEMU_HANA_DOCK_DAC_PAD4,\n};\n\n#define snd_emu1010_dac_pads_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_emu1010_dac_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask = snd_emu1010_dac_regs[kcontrol->private_value];\n\n\tucontrol->value.integer.value[0] = (emu->emu1010.dac_pads & mask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_emu1010_dac_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask = snd_emu1010_dac_regs[kcontrol->private_value];\n\tunsigned int val, cache;\n\tint change;\n\n\tval = ucontrol->value.integer.value[0];\n\tcache = emu->emu1010.dac_pads;\n\tif (val == 1) \n\t\tcache = cache | mask;\n\telse\n\t\tcache = cache & ~mask;\n\tchange = (cache != emu->emu1010.dac_pads);\n\tif (change) {\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DAC_PADS, cache );\n\t        emu->emu1010.dac_pads = cache;\n\t}\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new emu1010_dac_pads_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_emu1010_dac_pads_info,\n\t.get = snd_emu1010_dac_pads_get,\n\t.put = snd_emu1010_dac_pads_put\n};\n\n\nstruct snd_emu1010_pads_info {\n\tconst char * const *adc_ctls, * const *dac_ctls;\n\tunsigned n_adc_ctls, n_dac_ctls;\n};\n\nstatic const struct snd_emu1010_pads_info emu1010_pads_info[] = {\n\t{\n\t\t \n\t\t.adc_ctls = snd_emu1010_adc_pads,\n\t\t.n_adc_ctls = ARRAY_SIZE(snd_emu1010_adc_pads),\n\t\t.dac_ctls = snd_emu1010_dac_pads,\n\t\t.n_dac_ctls = ARRAY_SIZE(snd_emu1010_dac_pads),\n\t},\n\t{\n\t\t \n\t\t.adc_ctls = snd_emu1010_adc_pads,\n\t\t.n_adc_ctls = ARRAY_SIZE(snd_emu1010_adc_pads) - 1,\n\t\t.dac_ctls = snd_emu1010_dac_pads,\n\t\t.n_dac_ctls = ARRAY_SIZE(snd_emu1010_dac_pads) - 1,\n\t},\n\t{\n\t\t \n\t\t.adc_ctls = snd_emu1010_adc_pads + 1,\n\t\t.n_adc_ctls = ARRAY_SIZE(snd_emu1010_adc_pads) - 2,\n\t\t.dac_ctls = snd_emu1010_dac_pads + 1,\n\t\t.n_dac_ctls = ARRAY_SIZE(snd_emu1010_dac_pads) - 2,\n\t},\n\t{\n\t\t \n\t\t.adc_ctls = NULL,\n\t\t.n_adc_ctls = 0,\n\t\t.dac_ctls = NULL,\n\t\t.n_dac_ctls = 0,\n\t},\n};\n\nstatic const char * const emu1010_clock_texts[] = {\n\t\"44100\", \"48000\", \"SPDIF\", \"ADAT\", \"Dock\", \"BNC\"\n};\n\nstatic const u8 emu1010_clock_vals[] = {\n\tEMU_HANA_WCLOCK_INT_44_1K,\n\tEMU_HANA_WCLOCK_INT_48K,\n\tEMU_HANA_WCLOCK_HANA_SPDIF_IN,\n\tEMU_HANA_WCLOCK_HANA_ADAT_IN,\n\tEMU_HANA_WCLOCK_2ND_HANA,\n\tEMU_HANA_WCLOCK_SYNC_BNC,\n};\n\nstatic const char * const emu0404_clock_texts[] = {\n\t\"44100\", \"48000\", \"SPDIF\", \"BNC\"\n};\n\nstatic const u8 emu0404_clock_vals[] = {\n\tEMU_HANA_WCLOCK_INT_44_1K,\n\tEMU_HANA_WCLOCK_INT_48K,\n\tEMU_HANA_WCLOCK_HANA_SPDIF_IN,\n\tEMU_HANA_WCLOCK_SYNC_BNC,\n};\n\nstruct snd_emu1010_clock_info {\n\tconst char * const *texts;\n\tconst u8 *vals;\n\tunsigned num;\n};\n\nstatic const struct snd_emu1010_clock_info emu1010_clock_info[] = {\n\t{\n\t\t \n\t\t.texts = emu1010_clock_texts,\n\t\t.vals = emu1010_clock_vals,\n\t\t.num = ARRAY_SIZE(emu1010_clock_vals),\n\t},\n\t{\n\t\t \n\t\t.texts = emu1010_clock_texts,\n\t\t.vals = emu1010_clock_vals,\n\t\t.num = ARRAY_SIZE(emu1010_clock_vals) - 1,\n\t},\n\t{\n\t\t \n\t\t.texts = emu1010_clock_texts,\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t\n\t\t\n\t\t\n\t\t.vals = emu1010_clock_vals,\n\t\t.num = ARRAY_SIZE(emu1010_clock_vals),\n\t},\n\t{\n\t\t\n\t\t.texts = emu0404_clock_texts,\n\t\t.vals = emu0404_clock_vals,\n\t\t.num = ARRAY_SIZE(emu0404_clock_vals),\n\t},\n};\n\nstatic int snd_emu1010_clock_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_clock_info *emu_ci =\n\t\t&emu1010_clock_info[emu1010_idx(emu)];\n\t\t\n\treturn snd_ctl_enum_info(uinfo, 1, emu_ci->num, emu_ci->texts);\n}\n\nstatic int snd_emu1010_clock_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->emu1010.clock_source;\n\treturn 0;\n}\n\nstatic int snd_emu1010_clock_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_emu1010_clock_info *emu_ci =\n\t\t&emu1010_clock_info[emu1010_idx(emu)];\n\tunsigned int val;\n\tint change = 0;\n\n\tval = ucontrol->value.enumerated.item[0] ;\n\tif (val >= emu_ci->num)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&emu->reg_lock);\n\tchange = (emu->emu1010.clock_source != val);\n\tif (change) {\n\t\temu->emu1010.clock_source = val;\n\t\temu->emu1010.wclock = emu_ci->vals[val];\n\t\tsnd_emu1010_update_clock(emu);\n\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE);\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, emu->emu1010.wclock);\n\t\tspin_unlock_irq(&emu->reg_lock);\n\n\t\tmsleep(10);  \n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE);\n\t} else {\n\t\tspin_unlock_irq(&emu->reg_lock);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu1010_clock_source =\n{\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Clock Source\",\n\t.count = 1,\n\t.info = snd_emu1010_clock_source_info,\n\t.get = snd_emu1010_clock_source_get,\n\t.put = snd_emu1010_clock_source_put\n};\n\nstatic int snd_emu1010_clock_fallback_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\n\t\t\"44100\", \"48000\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_emu1010_clock_fallback_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->emu1010.clock_fallback;\n\treturn 0;\n}\n\nstatic int snd_emu1010_clock_fallback_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val = ucontrol->value.enumerated.item[0];\n\tint change;\n\n\tif (val >= 2)\n\t\treturn -EINVAL;\n\tchange = (emu->emu1010.clock_fallback != val);\n\tif (change) {\n\t\temu->emu1010.clock_fallback = val;\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, 1 - val);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu1010_clock_fallback =\n{\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Clock Fallback\",\n\t.count = 1,\n\t.info = snd_emu1010_clock_fallback_info,\n\t.get = snd_emu1010_clock_fallback_get,\n\t.put = snd_emu1010_clock_fallback_put\n};\n\nstatic int snd_emu1010_optical_out_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\n\t\t\"SPDIF\", \"ADAT\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_emu1010_optical_out_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->emu1010.optical_out;\n\treturn 0;\n}\n\nstatic int snd_emu1010_optical_out_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tu32 tmp;\n\tint change = 0;\n\n\tval = ucontrol->value.enumerated.item[0];\n\t \n\tif (val >= 2)\n\t\treturn -EINVAL;\n\tchange = (emu->emu1010.optical_out != val);\n\tif (change) {\n\t\temu->emu1010.optical_out = val;\n\t\ttmp = (emu->emu1010.optical_in ? EMU_HANA_OPTICAL_IN_ADAT : EMU_HANA_OPTICAL_IN_SPDIF) |\n\t\t\t(emu->emu1010.optical_out ? EMU_HANA_OPTICAL_OUT_ADAT : EMU_HANA_OPTICAL_OUT_SPDIF);\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, tmp);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu1010_optical_out = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Optical Output Mode\",\n\t.count =\t1,\n\t.info =         snd_emu1010_optical_out_info,\n\t.get =          snd_emu1010_optical_out_get,\n\t.put =          snd_emu1010_optical_out_put\n};\n\nstatic int snd_emu1010_optical_in_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\n\t\t\"SPDIF\", \"ADAT\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_emu1010_optical_in_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->emu1010.optical_in;\n\treturn 0;\n}\n\nstatic int snd_emu1010_optical_in_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tu32 tmp;\n\tint change = 0;\n\n\tval = ucontrol->value.enumerated.item[0];\n\t \n\tif (val >= 2)\n\t\treturn -EINVAL;\n\tchange = (emu->emu1010.optical_in != val);\n\tif (change) {\n\t\temu->emu1010.optical_in = val;\n\t\ttmp = (emu->emu1010.optical_in ? EMU_HANA_OPTICAL_IN_ADAT : EMU_HANA_OPTICAL_IN_SPDIF) |\n\t\t\t(emu->emu1010.optical_out ? EMU_HANA_OPTICAL_OUT_ADAT : EMU_HANA_OPTICAL_OUT_SPDIF);\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, tmp);\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu1010_optical_in = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Optical Input Mode\",\n\t.count =\t1,\n\t.info =         snd_emu1010_optical_in_info,\n\t.get =          snd_emu1010_optical_in_get,\n\t.put =          snd_emu1010_optical_in_put\n};\n\nstatic int snd_audigy_i2c_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n#if 0\n\tstatic const char * const texts[4] = {\n\t\t\"Unknown1\", \"Unknown2\", \"Mic\", \"Line\"\n\t};\n#endif\n\tstatic const char * const texts[2] = {\n\t\t\"Mic\", \"Line\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_audigy_i2c_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = emu->i2c_capture_source;\n\treturn 0;\n}\n\nstatic int snd_audigy_i2c_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int source_id;\n\tunsigned int ngain, ogain;\n\tu16 gpio;\n\tint change = 0;\n\tu32 source;\n\t \n\tsource_id = ucontrol->value.enumerated.item[0];\n\t \n\t \n\tif (source_id >= 2)\n\t\treturn -EINVAL;\n\tchange = (emu->i2c_capture_source != source_id);\n\tif (change) {\n\t\tsnd_emu10k1_i2c_write(emu, ADC_MUX, 0);  \n\t\tspin_lock_irq(&emu->emu_lock);\n\t\tgpio = inw(emu->port + A_IOCFG);\n\t\tif (source_id==0)\n\t\t\toutw(gpio | 0x4, emu->port + A_IOCFG);\n\t\telse\n\t\t\toutw(gpio & ~0x4, emu->port + A_IOCFG);\n\t\tspin_unlock_irq(&emu->emu_lock);\n\n\t\tngain = emu->i2c_capture_volume[source_id][0];  \n\t\togain = emu->i2c_capture_volume[emu->i2c_capture_source][0];  \n\t\tif (ngain != ogain)\n\t\t\tsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff));\n\t\tngain = emu->i2c_capture_volume[source_id][1];  \n\t\togain = emu->i2c_capture_volume[emu->i2c_capture_source][1];  \n\t\tif (ngain != ogain)\n\t\t\tsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));\n\n\t\tsource = 1 << (source_id + 2);\n\t\tsnd_emu10k1_i2c_write(emu, ADC_MUX, source);  \n\t\temu->i2c_capture_source = source_id;\n\t}\n        return change;\n}\n\nstatic const struct snd_kcontrol_new snd_audigy_i2c_capture_source =\n{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"Capture Source\",\n\t\t.info =\t\tsnd_audigy_i2c_capture_source_info,\n\t\t.get =\t\tsnd_audigy_i2c_capture_source_get,\n\t\t.put =\t\tsnd_audigy_i2c_capture_source_put\n};\n\nstatic int snd_audigy_i2c_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_audigy_i2c_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int source_id;\n\n\tsource_id = kcontrol->private_value;\n\t \n         \n\tif (source_id >= 2)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = emu->i2c_capture_volume[source_id][0];\n\tucontrol->value.integer.value[1] = emu->i2c_capture_volume[source_id][1];\n\treturn 0;\n}\n\nstatic int snd_audigy_i2c_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int ogain;\n\tunsigned int ngain0, ngain1;\n\tunsigned int source_id;\n\tint change = 0;\n\n\tsource_id = kcontrol->private_value;\n\t \n         \n\tif (source_id >= 2)\n\t\treturn -EINVAL;\n\tngain0 = ucontrol->value.integer.value[0];\n\tngain1 = ucontrol->value.integer.value[1];\n\tif (ngain0 > 0xff)\n\t\treturn -EINVAL;\n\tif (ngain1 > 0xff)\n\t\treturn -EINVAL;\n\togain = emu->i2c_capture_volume[source_id][0];  \n\tif (ogain != ngain0) {\n\t\tif (emu->i2c_capture_source == source_id)\n\t\t\tsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ngain0);\n\t\temu->i2c_capture_volume[source_id][0] = ngain0;\n\t\tchange = 1;\n\t}\n\togain = emu->i2c_capture_volume[source_id][1];  \n\tif (ogain != ngain1) {\n\t\tif (emu->i2c_capture_source == source_id)\n\t\t\tsnd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ngain1);\n\t\temu->i2c_capture_volume[source_id][1] = ngain1;\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new i2c_volume_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t          SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_audigy_i2c_volume_info,\n\t.get = snd_audigy_i2c_volume_get,\n\t.put = snd_audigy_i2c_volume_put,\n\t.tlv = { .p = snd_audigy_db_scale2 }\n};\n\nstatic const char * const snd_audigy_i2c_volume_ctls[] = {\n\t\"Mic Capture Volume\",\n\t\"Line Capture Volume\",\n};\n\n#if 0\nstatic int snd_audigy_spdif_output_rate_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"44100\", \"48000\", \"96000\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_audigy_spdif_output_rate_get(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int tmp;\n\n\ttmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, 0);\n\tswitch (tmp & A_SPDIF_RATE_MASK) {\n\tcase A_SPDIF_44100:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\tcase A_SPDIF_48000:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase A_SPDIF_96000:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_audigy_spdif_output_rate_put(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int reg, val, tmp;\n\n\tswitch(ucontrol->value.enumerated.item[0]) {\n\tcase 0:\n\t\tval = A_SPDIF_44100;\n\t\tbreak;\n\tcase 1:\n\t\tval = A_SPDIF_48000;\n\t\tbreak;\n\tcase 2:\n\t\tval = A_SPDIF_96000;\n\t\tbreak;\n\tdefault:\n\t\tval = A_SPDIF_48000;\n\t\tbreak;\n\t}\n\n\t\n\tspin_lock_irq(&emu->reg_lock);\n\treg = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, 0);\n\ttmp = reg & ~A_SPDIF_RATE_MASK;\n\ttmp |= val;\n\tchange = (tmp != reg);\n\tif (change)\n\t\tsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, 0, tmp);\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_audigy_spdif_output_rate =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Audigy SPDIF Output Sample Rate\",\n\t.count =\t1,\n\t.info =         snd_audigy_spdif_output_rate_info,\n\t.get =          snd_audigy_spdif_output_rate_get,\n\t.put =          snd_audigy_spdif_output_rate_put\n};\n#endif\n\nstatic int snd_emu10k1_spdif_put(struct snd_kcontrol *kcontrol,\n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tint change;\n\tunsigned int val;\n\n\t \n\tif (idx >= 3)\n\t\treturn -EINVAL;\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8) |\n\t      (ucontrol->value.iec958.status[2] << 16) |\n\t      (ucontrol->value.iec958.status[3] << 24);\n\tchange = val != emu->spdif_bits[idx];\n\tif (change) {\n\t\tsnd_emu10k1_ptr_write(emu, SPCS0 + idx, 0, val);\n\t\temu->spdif_bits[idx] = val;\n\t}\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_spdif_mask_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.count =\t3,\n\t.info =         snd_emu10k1_spdif_info,\n\t.get =          snd_emu10k1_spdif_get_mask\n};\n\nstatic const struct snd_kcontrol_new snd_emu10k1_spdif_control =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.count =\t3,\n\t.info =         snd_emu10k1_spdif_info,\n\t.get =          snd_emu10k1_spdif_get,\n\t.put =          snd_emu10k1_spdif_put\n};\n\n\nstatic void update_emu10k1_fxrt(struct snd_emu10k1 *emu, int voice, unsigned char *route)\n{\n\tif (emu->audigy) {\n\t\tsnd_emu10k1_ptr_write_multiple(emu, voice,\n\t\t\tA_FXRT1, snd_emu10k1_compose_audigy_fxrt1(route),\n\t\t\tA_FXRT2, snd_emu10k1_compose_audigy_fxrt2(route),\n\t\t\tREGLIST_END);\n\t} else {\n\t\tsnd_emu10k1_ptr_write(emu, FXRT, voice,\n\t\t\t\t      snd_emu10k1_compose_send_routing(route));\n\t}\n}\n\nstatic void update_emu10k1_send_volume(struct snd_emu10k1 *emu, int voice, unsigned char *volume)\n{\n\tsnd_emu10k1_ptr_write(emu, PTRX_FXSENDAMOUNT_A, voice, volume[0]);\n\tsnd_emu10k1_ptr_write(emu, PTRX_FXSENDAMOUNT_B, voice, volume[1]);\n\tsnd_emu10k1_ptr_write(emu, PSST_FXSENDAMOUNT_C, voice, volume[2]);\n\tsnd_emu10k1_ptr_write(emu, DSL_FXSENDAMOUNT_D, voice, volume[3]);\n\tif (emu->audigy) {\n\t\tsnd_emu10k1_ptr_write(emu, A_SENDAMOUNTS, voice,\n\t\t\t\t      snd_emu10k1_compose_audigy_sendamounts(volume));\n\t}\n}\n\n \n\nstatic int snd_emu10k1_send_routing_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = emu->audigy ? 3*8 : 3*4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = emu->audigy ? 0x3f : 0x0f;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_send_routing_get(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint voice, idx;\n\tint num_efx = emu->audigy ? 8 : 4;\n\tint mask = emu->audigy ? 0x3f : 0x0f;\n\n\tfor (voice = 0; voice < 3; voice++)\n\t\tfor (idx = 0; idx < num_efx; idx++)\n\t\t\tucontrol->value.integer.value[(voice * num_efx) + idx] = \n\t\t\t\tmix->send_routing[voice][idx] & mask;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_send_routing_put(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint change = 0, voice, idx, val;\n\tint num_efx = emu->audigy ? 8 : 4;\n\tint mask = emu->audigy ? 0x3f : 0x0f;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tfor (voice = 0; voice < 3; voice++)\n\t\tfor (idx = 0; idx < num_efx; idx++) {\n\t\t\tval = ucontrol->value.integer.value[(voice * num_efx) + idx] & mask;\n\t\t\tif (mix->send_routing[voice][idx] != val) {\n\t\t\t\tmix->send_routing[voice][idx] = val;\n\t\t\t\tchange = 1;\n\t\t\t}\n\t\t}\t\n\tif (change && mix->epcm && mix->epcm->voices[0]) {\n\t\tif (!mix->epcm->voices[0]->last) {\n\t\t\tupdate_emu10k1_fxrt(emu, mix->epcm->voices[0]->number,\n\t\t\t\t\t    &mix->send_routing[1][0]);\n\t\t\tupdate_emu10k1_fxrt(emu, mix->epcm->voices[0]->number + 1,\n\t\t\t\t\t    &mix->send_routing[2][0]);\n\t\t} else {\n\t\t\tupdate_emu10k1_fxrt(emu, mix->epcm->voices[0]->number,\n\t\t\t\t\t    &mix->send_routing[0][0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_send_routing_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"EMU10K1 PCM Send Routing\",\n\t.count =\t32,\n\t.info =         snd_emu10k1_send_routing_info,\n\t.get =          snd_emu10k1_send_routing_get,\n\t.put =          snd_emu10k1_send_routing_put\n};\n\nstatic int snd_emu10k1_send_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = emu->audigy ? 3*8 : 3*4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_send_volume_get(struct snd_kcontrol *kcontrol,\n                                       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint idx;\n\tint num_efx = emu->audigy ? 8 : 4;\n\n\tfor (idx = 0; idx < 3*num_efx; idx++)\n\t\tucontrol->value.integer.value[idx] = mix->send_volume[idx/num_efx][idx%num_efx];\n\treturn 0;\n}\n\nstatic int snd_emu10k1_send_volume_put(struct snd_kcontrol *kcontrol,\n                                       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint change = 0, idx, val;\n\tint num_efx = emu->audigy ? 8 : 4;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tfor (idx = 0; idx < 3*num_efx; idx++) {\n\t\tval = ucontrol->value.integer.value[idx] & 255;\n\t\tif (mix->send_volume[idx/num_efx][idx%num_efx] != val) {\n\t\t\tmix->send_volume[idx/num_efx][idx%num_efx] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tif (change && mix->epcm && mix->epcm->voices[0]) {\n\t\tif (!mix->epcm->voices[0]->last) {\n\t\t\tupdate_emu10k1_send_volume(emu, mix->epcm->voices[0]->number,\n\t\t\t\t\t\t   &mix->send_volume[1][0]);\n\t\t\tupdate_emu10k1_send_volume(emu, mix->epcm->voices[0]->number + 1,\n\t\t\t\t\t\t   &mix->send_volume[2][0]);\n\t\t} else {\n\t\t\tupdate_emu10k1_send_volume(emu, mix->epcm->voices[0]->number,\n\t\t\t\t\t\t   &mix->send_volume[0][0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_send_volume_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"EMU10K1 PCM Send Volume\",\n\t.count =\t32,\n\t.info =         snd_emu10k1_send_volume_info,\n\t.get =          snd_emu10k1_send_volume_get,\n\t.put =          snd_emu10k1_send_volume_put\n};\n\nstatic int snd_emu10k1_attn_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 3;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x1fffd;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_attn_get(struct snd_kcontrol *kcontrol,\n                                struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint idx;\n\n\tfor (idx = 0; idx < 3; idx++)\n\t\tucontrol->value.integer.value[idx] = mix->attn[idx] * 0xffffU / 0x8000U;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_attn_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint change = 0, idx, val;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tfor (idx = 0; idx < 3; idx++) {\n\t\tunsigned uval = ucontrol->value.integer.value[idx] & 0x1ffff;\n\t\tval = uval * 0x8000U / 0xffffU;\n\t\tif (mix->attn[idx] != val) {\n\t\t\tmix->attn[idx] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tif (change && mix->epcm && mix->epcm->voices[0]) {\n\t\tif (!mix->epcm->voices[0]->last) {\n\t\t\tsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[0]->number, mix->attn[1]);\n\t\t\tsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[0]->number + 1, mix->attn[2]);\n\t\t} else {\n\t\t\tsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[0]->number, mix->attn[0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_attn_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"EMU10K1 PCM Volume\",\n\t.count =\t32,\n\t.info =         snd_emu10k1_attn_info,\n\t.get =          snd_emu10k1_attn_get,\n\t.put =          snd_emu10k1_attn_put\n};\n\n \n\nstatic int snd_emu10k1_efx_send_routing_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = emu->audigy ? 8 : 4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = emu->audigy ? 0x3f : 0x0f;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_send_routing_get(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint idx;\n\tint num_efx = emu->audigy ? 8 : 4;\n\tint mask = emu->audigy ? 0x3f : 0x0f;\n\n\tfor (idx = 0; idx < num_efx; idx++)\n\t\tucontrol->value.integer.value[idx] = \n\t\t\tmix->send_routing[0][idx] & mask;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_send_routing_put(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\n\tint change = 0, idx, val;\n\tint num_efx = emu->audigy ? 8 : 4;\n\tint mask = emu->audigy ? 0x3f : 0x0f;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tfor (idx = 0; idx < num_efx; idx++) {\n\t\tval = ucontrol->value.integer.value[idx] & mask;\n\t\tif (mix->send_routing[0][idx] != val) {\n\t\t\tmix->send_routing[0][idx] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\t\n\n\tif (change && mix->epcm) {\n\t\tif (mix->epcm->voices[ch]) {\n\t\t\tupdate_emu10k1_fxrt(emu, mix->epcm->voices[ch]->number,\n\t\t\t\t\t&mix->send_routing[0][0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_efx_send_routing_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"Multichannel PCM Send Routing\",\n\t.count =\t16,\n\t.info =         snd_emu10k1_efx_send_routing_info,\n\t.get =          snd_emu10k1_efx_send_routing_get,\n\t.put =          snd_emu10k1_efx_send_routing_put\n};\n\nstatic int snd_emu10k1_efx_send_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = emu->audigy ? 8 : 4;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_send_volume_get(struct snd_kcontrol *kcontrol,\n                                       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\tint idx;\n\tint num_efx = emu->audigy ? 8 : 4;\n\n\tfor (idx = 0; idx < num_efx; idx++)\n\t\tucontrol->value.integer.value[idx] = mix->send_volume[0][idx];\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_send_volume_put(struct snd_kcontrol *kcontrol,\n                                       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\n\tint change = 0, idx, val;\n\tint num_efx = emu->audigy ? 8 : 4;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tfor (idx = 0; idx < num_efx; idx++) {\n\t\tval = ucontrol->value.integer.value[idx] & 255;\n\t\tif (mix->send_volume[0][idx] != val) {\n\t\t\tmix->send_volume[0][idx] = val;\n\t\t\tchange = 1;\n\t\t}\n\t}\n\tif (change && mix->epcm) {\n\t\tif (mix->epcm->voices[ch]) {\n\t\t\tupdate_emu10k1_send_volume(emu, mix->epcm->voices[ch]->number,\n\t\t\t\t\t\t   &mix->send_volume[0][0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\n\nstatic const struct snd_kcontrol_new snd_emu10k1_efx_send_volume_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"Multichannel PCM Send Volume\",\n\t.count =\t16,\n\t.info =         snd_emu10k1_efx_send_volume_info,\n\t.get =          snd_emu10k1_efx_send_volume_get,\n\t.put =          snd_emu10k1_efx_send_volume_put\n};\n\nstatic int snd_emu10k1_efx_attn_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x1fffd;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_attn_get(struct snd_kcontrol *kcontrol,\n                                struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tstruct snd_emu10k1_pcm_mixer *mix =\n\t\t&emu->efx_pcm_mixer[snd_ctl_get_ioffidx(kcontrol, &ucontrol->id)];\n\n\tucontrol->value.integer.value[0] = mix->attn[0] * 0xffffU / 0x8000U;\n\treturn 0;\n}\n\nstatic int snd_emu10k1_efx_attn_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tint ch = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_emu10k1_pcm_mixer *mix = &emu->efx_pcm_mixer[ch];\n\tint change = 0, val;\n\tunsigned uval;\n\n\tspin_lock_irq(&emu->reg_lock);\n\tuval = ucontrol->value.integer.value[0] & 0x1ffff;\n\tval = uval * 0x8000U / 0xffffU;\n\tif (mix->attn[0] != val) {\n\t\tmix->attn[0] = val;\n\t\tchange = 1;\n\t}\n\tif (change && mix->epcm) {\n\t\tif (mix->epcm->voices[ch]) {\n\t\t\tsnd_emu10k1_ptr_write(emu, VTFT_VOLUMETARGET, mix->epcm->voices[ch]->number, mix->attn[0]);\n\t\t}\n\t}\n\tspin_unlock_irq(&emu->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_efx_attn_control =\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"Multichannel PCM Volume\",\n\t.count =\t16,\n\t.info =         snd_emu10k1_efx_attn_info,\n\t.get =          snd_emu10k1_efx_attn_get,\n\t.put =          snd_emu10k1_efx_attn_put\n};\n\n#define snd_emu10k1_shared_spdif_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_emu10k1_shared_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\n\tif (emu->audigy)\n\t\tucontrol->value.integer.value[0] = inw(emu->port + A_IOCFG) & A_IOCFG_GPOUT0 ? 1 : 0;\n\telse\n\t\tucontrol->value.integer.value[0] = inl(emu->port + HCFG) & HCFG_GPOUT0 ? 1 : 0;\n\tif (emu->card_capabilities->invert_shared_spdif)\n\t\tucontrol->value.integer.value[0] =\n\t\t\t!ucontrol->value.integer.value[0];\n\t\t\n\treturn 0;\n}\n\nstatic int snd_emu10k1_shared_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int reg, val, sw;\n\tint change = 0;\n\n\tsw = ucontrol->value.integer.value[0];\n\tif (emu->card_capabilities->invert_shared_spdif)\n\t\tsw = !sw;\n\tspin_lock_irq(&emu->emu_lock);\n\tif ( emu->card_capabilities->i2c_adc) {\n\t\t \n\t} else if (emu->audigy) {\n\t\treg = inw(emu->port + A_IOCFG);\n\t\tval = sw ? A_IOCFG_GPOUT0 : 0;\n\t\tchange = (reg & A_IOCFG_GPOUT0) != val;\n\t\tif (change) {\n\t\t\treg &= ~A_IOCFG_GPOUT0;\n\t\t\treg |= val;\n\t\t\toutw(reg | val, emu->port + A_IOCFG);\n\t\t}\n\t}\n\treg = inl(emu->port + HCFG);\n\tval = sw ? HCFG_GPOUT0 : 0;\n\tchange |= (reg & HCFG_GPOUT0) != val;\n\tif (change) {\n\t\treg &= ~HCFG_GPOUT0;\n\t\treg |= val;\n\t\toutl(reg | val, emu->port + HCFG);\n\t}\n\tspin_unlock_irq(&emu->emu_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_emu10k1_shared_spdif =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"SB Live Analog/Digital Output Jack\",\n\t.info =\t\tsnd_emu10k1_shared_spdif_info,\n\t.get =\t\tsnd_emu10k1_shared_spdif_get,\n\t.put =\t\tsnd_emu10k1_shared_spdif_put\n};\n\nstatic const struct snd_kcontrol_new snd_audigy_shared_spdif =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Audigy Analog/Digital Output Jack\",\n\t.info =\t\tsnd_emu10k1_shared_spdif_info,\n\t.get =\t\tsnd_emu10k1_shared_spdif_get,\n\t.put =\t\tsnd_emu10k1_shared_spdif_put\n};\n\n \n\n#define snd_audigy_capture_boost_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_audigy_capture_boost_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\n\t \n\tval = snd_ac97_read(emu->ac97, AC97_REC_GAIN);\n\tucontrol->value.integer.value[0] = !!val;\n\treturn 0;\n}\n\nstatic int snd_audigy_capture_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval = 0x0f0f;\n\telse\n\t\tval = 0;\n\treturn snd_ac97_update(emu->ac97, AC97_REC_GAIN, val);\n}\n\nstatic const struct snd_kcontrol_new snd_audigy_capture_boost =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Mic Extra Boost\",\n\t.info =\t\tsnd_audigy_capture_boost_info,\n\t.get =\t\tsnd_audigy_capture_boost_get,\n\t.put =\t\tsnd_audigy_capture_boost_put\n};\n\n\n \nstatic void snd_emu10k1_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct snd_emu10k1 *emu = ac97->private_data;\n\temu->ac97 = NULL;\n}\n\n \nstatic int remove_ctl(struct snd_card *card, const char *name)\n{\n\tstruct snd_ctl_elem_id id;\n\tmemset(&id, 0, sizeof(id));\n\tstrcpy(id.name, name);\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\treturn snd_ctl_remove_id(card, &id);\n}\n\nstatic int rename_ctl(struct snd_card *card, const char *src, const char *dst)\n{\n\tstruct snd_kcontrol *kctl = snd_ctl_find_id_mixer(card, src);\n\tif (kctl) {\n\t\tsnd_ctl_rename(card, kctl, dst);\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\nint snd_emu10k1_mixer(struct snd_emu10k1 *emu,\n\t\t      int pcm_device, int multi_device)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_card *card = emu->card;\n\tconst char * const *c;\n\tstatic const char * const emu10k1_remove_ctls[] = {\n\t\t \n\t\t\"Master Mono Playback Switch\",\n\t\t\"Master Mono Playback Volume\",\n\t\t\"PCM Out Path & Mute\",\n\t\t\"Mono Output Select\",\n\t\t\"Surround Playback Switch\",\n\t\t\"Surround Playback Volume\",\n\t\t\"Center Playback Switch\",\n\t\t\"Center Playback Volume\",\n\t\t\"LFE Playback Switch\",\n\t\t\"LFE Playback Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const emu10k1_rename_ctls[] = {\n\t\t\"Surround Digital Playback Volume\", \"Surround Playback Volume\",\n\t\t\"Center Digital Playback Volume\", \"Center Playback Volume\",\n\t\t\"LFE Digital Playback Volume\", \"LFE Playback Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_remove_ctls[] = {\n\t\t \n\t\t \n\t\t\"PCM Playback Switch\",\n\t\t\"PCM Playback Volume\",\n\t\t\"Master Playback Switch\",\n\t\t\"Master Playback Volume\",\n\t\t\"PCM Out Path & Mute\",\n\t\t\"Mono Output Select\",\n\t\t \n\t\t\"Capture Source\",\n\t\t\"Capture Switch\",\n\t\t\"Capture Volume\",\n\t\t\"Mic Select\",\n\t\t\"Headphone Playback Switch\",\n\t\t\"Headphone Playback Volume\",\n\t\t\"3D Control - Center\",\n\t\t\"3D Control - Depth\",\n\t\t\"3D Control - Switch\",\n\t\t\"Video Playback Switch\",\n\t\t\"Video Playback Volume\",\n\t\t\"Mic Playback Switch\",\n\t\t\"Mic Playback Volume\",\n\t\t\"External Amplifier\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_rename_ctls[] = {\n\t\t \n\t\t\"Wave Playback Volume\", \"PCM Playback Volume\",\n\t\t \n\t\t\"Wave Master Playback Volume\", \"Master Playback Volume\",\n\t\t\"AMic Playback Volume\", \"Mic Playback Volume\",\n\t\t\"Master Mono Playback Switch\", \"Phone Output Playback Switch\",\n\t\t\"Master Mono Playback Volume\", \"Phone Output Playback Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_rename_ctls_i2c_adc[] = {\n\t\t\n\t\t\"Line Capture Volume\", \"Analog Mix Capture Volume\",\n\t\t\"Wave Playback Volume\", \"OLD PCM Playback Volume\",\n\t\t\"Wave Master Playback Volume\", \"Master Playback Volume\",\n\t\t\"AMic Playback Volume\", \"Old Mic Playback Volume\",\n\t\t\"CD Capture Volume\", \"IEC958 Optical Capture Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_remove_ctls_i2c_adc[] = {\n\t\t \n\t\t\"Mic Capture Volume\",\n\t\t\"Analog Mix Capture Volume\",\n\t\t\"Aux Capture Volume\",\n\t\t\"IEC958 Optical Capture Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_remove_ctls_1361t_adc[] = {\n\t\t \n\t\t\"PCM Playback Switch\",\n\t\t\"PCM Playback Volume\",\n\t\t\"Capture Source\",\n\t\t\"Capture Switch\",\n\t\t\"Capture Volume\",\n\t\t\"Mic Capture Volume\",\n\t\t\"Headphone Playback Switch\",\n\t\t\"Headphone Playback Volume\",\n\t\t\"3D Control - Center\",\n\t\t\"3D Control - Depth\",\n\t\t\"3D Control - Switch\",\n\t\t\"Line2 Playback Volume\",\n\t\t\"Line2 Capture Volume\",\n\t\tNULL\n\t};\n\tstatic const char * const audigy_rename_ctls_1361t_adc[] = {\n\t\t\"Master Playback Switch\", \"Master Capture Switch\",\n\t\t\"Master Playback Volume\", \"Master Capture Volume\",\n\t\t\"Wave Master Playback Volume\", \"Master Playback Volume\",\n\t\t\"Beep Playback Switch\", \"Beep Capture Switch\",\n\t\t\"Beep Playback Volume\", \"Beep Capture Volume\",\n\t\t\"Phone Playback Switch\", \"Phone Capture Switch\",\n\t\t\"Phone Playback Volume\", \"Phone Capture Volume\",\n\t\t\"Mic Playback Switch\", \"Mic Capture Switch\",\n\t\t\"Mic Playback Volume\", \"Mic Capture Volume\",\n\t\t\"Line Playback Switch\", \"Line Capture Switch\",\n\t\t\"Line Playback Volume\", \"Line Capture Volume\",\n\t\t\"CD Playback Switch\", \"CD Capture Switch\",\n\t\t\"CD Playback Volume\", \"CD Capture Volume\",\n\t\t\"Aux Playback Switch\", \"Aux Capture Switch\",\n\t\t\"Aux Playback Volume\", \"Aux Capture Volume\",\n\t\t\"Video Playback Switch\", \"Video Capture Switch\",\n\t\t\"Video Playback Volume\", \"Video Capture Volume\",\n\t\t\"Master Mono Playback Switch\", \"Phone Output Playback Switch\",\n\t\t\"Master Mono Playback Volume\", \"Phone Output Playback Volume\",\n\t\tNULL\n\t};\n\n\tif (emu->card_capabilities->ac97_chip) {\n\t\tstruct snd_ac97_bus *pbus;\n\t\tstruct snd_ac97_template ac97;\n\t\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t\t.write = snd_emu10k1_ac97_write,\n\t\t\t.read = snd_emu10k1_ac97_read,\n\t\t};\n\n\t\terr = snd_ac97_bus(emu->card, 0, &ops, NULL, &pbus);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpbus->no_vra = 1;  \n\t\t\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = emu;\n\t\tac97.private_free = snd_emu10k1_mixer_free_ac97;\n\t\tac97.scaps = AC97_SCAP_NO_SPDIF;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &emu->ac97);\n\t\tif (err < 0) {\n\t\t\tif (emu->card_capabilities->ac97_chip == 1)\n\t\t\t\treturn err;\n\t\t\tdev_info(emu->card->dev,\n\t\t\t\t \"AC97 is optional on this board\\n\");\n\t\t\tdev_info(emu->card->dev,\n\t\t\t\t \"Proceeding without ac97 mixers...\\n\");\n\t\t\tsnd_device_free(emu->card, pbus);\n\t\t\tgoto no_ac97;  \n\t\t}\n\t\tif (emu->audigy) {\n\t\t\t \n\t\t\tsnd_ac97_write_cache(emu->ac97, AC97_MASTER, 0x0000);\n\t\t\t \n\t\t\tsnd_ac97_write_cache(emu->ac97, AC97_REC_SEL, 0x0000);\n\t\t\t \n\t\t\tsnd_ac97_update_bits(emu->ac97, AC97_GENERAL_PURPOSE,\n\t\t\t\t0x0200, 0x0200);\n\t\t\tif (emu->card_capabilities->adc_1361t)\n\t\t\t\tc = audigy_remove_ctls_1361t_adc;\n\t\t\telse \n\t\t\t\tc = audigy_remove_ctls;\n\t\t} else {\n\t\t\t \n\t\t\tif (emu->ac97->id == AC97_ID_STAC9758) {\n\t\t\t\temu->rear_ac97 = 1;\n\t\t\t\tsnd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_CNTR|AC97SLOT_LFE|AC97SLOT_REAR_LEFT|AC97SLOT_REAR_RIGHT);\n\t\t\t\tsnd_ac97_write_cache(emu->ac97, AC97_HEADPHONE, 0x0202);\n\t\t\t\tremove_ctl(card,\"Front Playback Volume\");\n\t\t\t\tremove_ctl(card,\"Front Playback Switch\");\n\t\t\t}\n\t\t\t \n\t\t\tsnd_ac97_write_cache(emu->ac97, AC97_SURROUND_MASTER, 0x0202);\n\t\t\tsnd_ac97_write_cache(emu->ac97, AC97_CENTER_LFE_MASTER, 0x0202);\n\t\t\tc = emu10k1_remove_ctls;\n\t\t}\n\t\tfor (; *c; c++)\n\t\t\tremove_ctl(card, *c);\n\t} else if (emu->card_capabilities->i2c_adc) {\n\t\tc = audigy_remove_ctls_i2c_adc;\n\t\tfor (; *c; c++)\n\t\t\tremove_ctl(card, *c);\n\t} else {\n\tno_ac97:\n\t\tif (emu->card_capabilities->ecard)\n\t\t\tstrcpy(emu->card->mixername, \"EMU APS\");\n\t\telse if (emu->audigy)\n\t\t\tstrcpy(emu->card->mixername, \"SB Audigy\");\n\t\telse\n\t\t\tstrcpy(emu->card->mixername, \"Emu10k1\");\n\t}\n\n\tif (emu->audigy)\n\t\tif (emu->card_capabilities->adc_1361t)\n\t\t\tc = audigy_rename_ctls_1361t_adc;\n\t\telse if (emu->card_capabilities->i2c_adc)\n\t\t\tc = audigy_rename_ctls_i2c_adc;\n\t\telse\n\t\t\tc = audigy_rename_ctls;\n\telse\n\t\tc = emu10k1_rename_ctls;\n\tfor (; *c; c += 2)\n\t\trename_ctl(card, c[0], c[1]);\n\n\tif (emu->card_capabilities->subsystem == 0x80401102) {  \n\t\tremove_ctl(card, \"Center Playback Volume\");\n\t\tremove_ctl(card, \"LFE Playback Volume\");\n\t\tremove_ctl(card, \"Wave Center Playback Volume\");\n\t\tremove_ctl(card, \"Wave LFE Playback Volume\");\n\t}\n\tif (emu->card_capabilities->subsystem == 0x20071102) {   \n\t\trename_ctl(card, \"Line2 Capture Volume\", \"Line1/Mic Capture Volume\");\n\t\trename_ctl(card, \"Analog Mix Capture Volume\", \"Line2 Capture Volume\");\n\t\trename_ctl(card, \"Aux2 Capture Volume\", \"Line3 Capture Volume\");\n\t\trename_ctl(card, \"Mic Capture Volume\", \"Unknown1 Capture Volume\");\n\t}\n\tkctl = emu->ctl_send_routing = snd_ctl_new1(&snd_emu10k1_send_routing_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = pcm_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\tkctl = emu->ctl_send_volume = snd_ctl_new1(&snd_emu10k1_send_volume_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = pcm_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\tkctl = emu->ctl_attn = snd_ctl_new1(&snd_emu10k1_attn_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = pcm_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\n\tkctl = emu->ctl_efx_send_routing = snd_ctl_new1(&snd_emu10k1_efx_send_routing_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = multi_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\t\n\tkctl = emu->ctl_efx_send_volume = snd_ctl_new1(&snd_emu10k1_efx_send_volume_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = multi_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\t\n\tkctl = emu->ctl_efx_attn = snd_ctl_new1(&snd_emu10k1_efx_attn_control, emu);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tkctl->id.device = multi_device;\n\terr = snd_ctl_add(card, kctl);\n\tif (err)\n\t\treturn err;\n\n\tif (!emu->card_capabilities->ecard && !emu->card_capabilities->emu_model) {\n\t\t \n\t\tkctl = snd_ctl_new1(&snd_emu10k1_spdif_mask_control, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tif (!emu->audigy)\n\t\t\tkctl->id.device = emu->pcm_efx->device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err)\n\t\t\treturn err;\n\t\tkctl = snd_ctl_new1(&snd_emu10k1_spdif_control, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\tif (!emu->audigy)\n\t\t\tkctl->id.device = emu->pcm_efx->device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t;   \n\t} else if (emu->audigy) {\n\t\tkctl = snd_ctl_new1(&snd_audigy_shared_spdif, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err)\n\t\t\treturn err;\n#if 0\n\t\tkctl = snd_ctl_new1(&snd_audigy_spdif_output_rate, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err)\n\t\t\treturn err;\n#endif\n\t} else if (! emu->card_capabilities->ecard) {\n\t\t \n\t\tkctl = snd_ctl_new1(&snd_emu10k1_shared_spdif, emu);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (emu->card_capabilities->ca0151_chip) {  \n\t\terr = snd_p16v_mixer(emu);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (emu->card_capabilities->emu_model) {\n\t\tunsigned i, emu_idx = emu1010_idx(emu);\n\t\tconst struct snd_emu1010_routing_info *emu_ri =\n\t\t\t&emu1010_routing_info[emu_idx];\n\t\tconst struct snd_emu1010_pads_info *emu_pi = &emu1010_pads_info[emu_idx];\n\n\t\tfor (i = 0; i < emu_ri->n_ins; i++)\n\t\t\temu->emu1010.input_source[i] =\n\t\t\t\temu1010_map_source(emu_ri, emu_ri->in_dflts[i]);\n\t\tfor (i = 0; i < emu_ri->n_outs; i++)\n\t\t\temu->emu1010.output_source[i] =\n\t\t\t\temu1010_map_source(emu_ri, emu_ri->out_dflts[i]);\n\t\tsnd_emu1010_apply_sources(emu);\n\n\t\tkctl = emu->ctl_clock_source = snd_ctl_new1(&snd_emu1010_clock_source, emu);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card,\n\t\t\tsnd_ctl_new1(&snd_emu1010_clock_fallback, emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_ctls(emu, &emu1010_adc_pads_ctl,\n\t\t\t       emu_pi->adc_ctls, emu_pi->n_adc_ctls);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = add_ctls(emu, &emu1010_dac_pads_ctl,\n\t\t\t       emu_pi->dac_ctls, emu_pi->n_dac_ctls);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!emu->card_capabilities->no_adat) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_emu1010_optical_out, emu));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&snd_emu1010_optical_in, emu));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = add_emu1010_source_mixers(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif ( emu->card_capabilities->i2c_adc) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_i2c_capture_source, emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = add_ctls(emu, &i2c_volume_ctl,\n\t\t\t       snd_audigy_i2c_volume_ctls,\n\t\t\t       ARRAY_SIZE(snd_audigy_i2c_volume_ctls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t\t\n\tif (emu->card_capabilities->ac97_chip && emu->audigy) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_capture_boost,\n\t\t\t\t\t\t     emu));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}