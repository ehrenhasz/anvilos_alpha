{
  "module_name": "voice.c",
  "hash_id": "b2f8d209ddbdfed5895da6377abf9906aeb96f207e7b0d7a8b9a4ed129f17f2c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/voice.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n\n \n\nstatic int voice_alloc(struct snd_emu10k1 *emu, int type, int number,\n\t\t       struct snd_emu10k1_pcm *epcm, struct snd_emu10k1_voice **rvoice)\n{\n\tstruct snd_emu10k1_voice *voice;\n\tint i, j, k, skip;\n\n\tfor (i = emu->next_free_voice, j = 0; j < NUM_G; i = (i + skip) % NUM_G, j += skip) {\n\t\t \n\n\t\t \n\t\tif ((number > 1) && (i % 2)) {\n\t\t\tskip = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (k = 0; k < number; k++) {\n\t\t\tvoice = &emu->voices[i + k];\n\t\t\tif (voice->use) {\n\t\t\t\tskip = k + 1;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tfor (k = 0; k < number; k++) {\n\t\t\tvoice = &emu->voices[i + k];\n\t\t\tvoice->use = type;\n\t\t\tvoice->epcm = epcm;\n\t\t\t \n\t\t}\n\t\tvoice->last = 1;\n\n\t\t*rvoice = &emu->voices[i];\n\t\temu->next_free_voice = (i + number) % NUM_G;\n\t\treturn 0;\n\n\tnext: ;\n\t}\n\treturn -ENOMEM;  \n}\n\nstatic void voice_free(struct snd_emu10k1 *emu,\n\t\t       struct snd_emu10k1_voice *pvoice)\n{\n\tif (pvoice->dirty)\n\t\tsnd_emu10k1_voice_init(emu, pvoice->number);\n\tpvoice->interrupt = NULL;\n\tpvoice->use = pvoice->dirty = pvoice->last = 0;\n\tpvoice->epcm = NULL;\n}\n\nint snd_emu10k1_voice_alloc(struct snd_emu10k1 *emu, int type, int count, int channels,\n\t\t\t    struct snd_emu10k1_pcm *epcm, struct snd_emu10k1_voice **rvoice)\n{\n\tunsigned long flags;\n\tint result;\n\n\tif (snd_BUG_ON(!rvoice))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!count))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!channels))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tfor (int got = 0; got < channels; ) {\n\t\tresult = voice_alloc(emu, type, count, epcm, &rvoice[got]);\n\t\tif (result == 0) {\n\t\t\tgot++;\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (type != EMU10K1_SYNTH && emu->get_synth_voice) {\n\t\t\t \n\t\t\tresult = emu->get_synth_voice(emu);\n\t\t\tif (result >= 0) {\n\t\t\t\tvoice_free(emu, &emu->voices[result]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < got; i++) {\n\t\t\tfor (int j = 0; j < count; j++)\n\t\t\t\tvoice_free(emu, rvoice[i] + j);\n\t\t\trvoice[i] = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n\n\treturn result;\n}\n\nEXPORT_SYMBOL(snd_emu10k1_voice_alloc);\n\nint snd_emu10k1_voice_free(struct snd_emu10k1 *emu,\n\t\t\t   struct snd_emu10k1_voice *pvoice)\n{\n\tunsigned long flags;\n\tint last;\n\n\tif (snd_BUG_ON(!pvoice))\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&emu->voice_lock, flags);\n\tdo {\n\t\tlast = pvoice->last;\n\t\tvoice_free(emu, pvoice++);\n\t} while (!last);\n\tspin_unlock_irqrestore(&emu->voice_lock, flags);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_emu10k1_voice_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}