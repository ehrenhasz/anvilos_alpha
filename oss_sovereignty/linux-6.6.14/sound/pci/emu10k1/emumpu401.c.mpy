{
  "module_name": "emumpu401.c",
  "hash_id": "0356cae6c0fd9b4843f5e55f6bd33556c0bd7efd3f48e70947708ffd4fd90727",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emumpu401.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n\n#define EMU10K1_MIDI_MODE_INPUT\t\t(1<<0)\n#define EMU10K1_MIDI_MODE_OUTPUT\t(1<<1)\n\nstatic inline unsigned char mpu401_read(struct snd_emu10k1 *emu,\n\t\t\t\t\tstruct snd_emu10k1_midi *mpu, int idx)\n{\n\tif (emu->audigy)\n\t\treturn (unsigned char)snd_emu10k1_ptr_read(emu, mpu->port + idx, 0);\n\telse\n\t\treturn inb(emu->port + mpu->port + idx);\n}\n\nstatic inline void mpu401_write(struct snd_emu10k1 *emu,\n\t\t\t\tstruct snd_emu10k1_midi *mpu, int data, int idx)\n{\n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, mpu->port + idx, 0, data);\n\telse\n\t\toutb(data, emu->port + mpu->port + idx);\n}\n\n#define mpu401_write_data(emu, mpu, data)\tmpu401_write(emu, mpu, data, 0)\n#define mpu401_write_cmd(emu, mpu, data)\tmpu401_write(emu, mpu, data, 1)\n#define mpu401_read_data(emu, mpu)\t\tmpu401_read(emu, mpu, 0)\n#define mpu401_read_stat(emu, mpu)\t\tmpu401_read(emu, mpu, 1)\n\n#define mpu401_input_avail(emu,mpu)\t(!(mpu401_read_stat(emu,mpu) & 0x80))\n#define mpu401_output_ready(emu,mpu)\t(!(mpu401_read_stat(emu,mpu) & 0x40))\n\n#define MPU401_RESET\t\t0xff\n#define MPU401_ENTER_UART\t0x3f\n#define MPU401_ACK\t\t0xfe\n\nstatic void mpu401_clear_rx(struct snd_emu10k1 *emu, struct snd_emu10k1_midi *mpu)\n{\n\tint timeout = 100000;\n\tfor (; timeout > 0 && mpu401_input_avail(emu, mpu); timeout--)\n\t\tmpu401_read_data(emu, mpu);\n#ifdef CONFIG_SND_DEBUG\n\tif (timeout <= 0)\n\t\tdev_err(emu->card->dev,\n\t\t\t\"cmd: clear rx timeout (status = 0x%x)\\n\",\n\t\t\tmpu401_read_stat(emu, mpu));\n#endif\n}\n\n \n\nstatic void do_emu10k1_midi_interrupt(struct snd_emu10k1 *emu, struct snd_emu10k1_midi *midi, unsigned int status)\n{\n\tunsigned char byte;\n\n\tif (midi->rmidi == NULL) {\n\t\tsnd_emu10k1_intr_disable(emu, midi->tx_enable | midi->rx_enable);\n\t\treturn;\n\t}\n\n\tspin_lock(&midi->input_lock);\n\tif ((status & midi->ipr_rx) && mpu401_input_avail(emu, midi)) {\n\t\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_INPUT)) {\n\t\t\tmpu401_clear_rx(emu, midi);\n\t\t} else {\n\t\t\tbyte = mpu401_read_data(emu, midi);\n\t\t\tif (midi->substream_input)\n\t\t\t\tsnd_rawmidi_receive(midi->substream_input, &byte, 1);\n\t\t}\n\t}\n\tspin_unlock(&midi->input_lock);\n\n\tspin_lock(&midi->output_lock);\n\tif ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {\n\t\tif (midi->substream_output &&\n\t\t    snd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {\n\t\t\tmpu401_write_data(emu, midi, byte);\n\t\t} else {\n\t\t\tsnd_emu10k1_intr_disable(emu, midi->tx_enable);\n\t\t}\n\t}\n\tspin_unlock(&midi->output_lock);\n}\n\nstatic void snd_emu10k1_midi_interrupt(struct snd_emu10k1 *emu, unsigned int status)\n{\n\tdo_emu10k1_midi_interrupt(emu, &emu->midi, status);\n}\n\nstatic void snd_emu10k1_midi_interrupt2(struct snd_emu10k1 *emu, unsigned int status)\n{\n\tdo_emu10k1_midi_interrupt(emu, &emu->midi2, status);\n}\n\nstatic int snd_emu10k1_midi_cmd(struct snd_emu10k1 * emu, struct snd_emu10k1_midi *midi, unsigned char cmd, int ack)\n{\n\tint timeout, ok;\n\n\tspin_lock_irq(&midi->input_lock);\n\tmpu401_write_data(emu, midi, 0x00);\n\t \n\n\tmpu401_write_cmd(emu, midi, cmd);\n\tif (ack) {\n\t\tok = 0;\n\t\ttimeout = 10000;\n\t\twhile (!ok && timeout-- > 0) {\n\t\t\tif (mpu401_input_avail(emu, midi)) {\n\t\t\t\tif (mpu401_read_data(emu, midi) == MPU401_ACK)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t\tif (!ok && mpu401_read_data(emu, midi) == MPU401_ACK)\n\t\t\tok = 1;\n\t} else {\n\t\tok = 1;\n\t}\n\tspin_unlock_irq(&midi->input_lock);\n\tif (!ok) {\n\t\tdev_err(emu->card->dev,\n\t\t\t\"midi_cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)!!!\\n\",\n\t\t\t   cmd, emu->port,\n\t\t\t   mpu401_read_stat(emu, midi),\n\t\t\t   mpu401_read_data(emu, midi));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_emu10k1_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irq(&midi->open_lock);\n\tmidi->midi_mode |= EMU10K1_MIDI_MODE_INPUT;\n\tmidi->substream_input = substream;\n\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_OUTPUT)) {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t\tif (snd_emu10k1_midi_cmd(emu, midi, MPU401_RESET, 1))\n\t\t\tgoto error_out;\n\t\tif (snd_emu10k1_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\n\t\t\tgoto error_out;\n\t} else {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t}\n\treturn 0;\n\nerror_out:\n\treturn -EIO;\n}\n\nstatic int snd_emu10k1_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irq(&midi->open_lock);\n\tmidi->midi_mode |= EMU10K1_MIDI_MODE_OUTPUT;\n\tmidi->substream_output = substream;\n\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_INPUT)) {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t\tif (snd_emu10k1_midi_cmd(emu, midi, MPU401_RESET, 1))\n\t\t\tgoto error_out;\n\t\tif (snd_emu10k1_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\n\t\t\tgoto error_out;\n\t} else {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t}\n\treturn 0;\n\nerror_out:\n\treturn -EIO;\n}\n\nstatic int snd_emu10k1_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\tint err = 0;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irq(&midi->open_lock);\n\tsnd_emu10k1_intr_disable(emu, midi->rx_enable);\n\tmidi->midi_mode &= ~EMU10K1_MIDI_MODE_INPUT;\n\tmidi->substream_input = NULL;\n\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_OUTPUT)) {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t\terr = snd_emu10k1_midi_cmd(emu, midi, MPU401_RESET, 0);\n\t} else {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t}\n\treturn err;\n}\n\nstatic int snd_emu10k1_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\tint err = 0;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn -ENXIO;\n\tspin_lock_irq(&midi->open_lock);\n\tsnd_emu10k1_intr_disable(emu, midi->tx_enable);\n\tmidi->midi_mode &= ~EMU10K1_MIDI_MODE_OUTPUT;\n\tmidi->substream_output = NULL;\n\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_INPUT)) {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t\terr = snd_emu10k1_midi_cmd(emu, midi, MPU401_RESET, 0);\n\t} else {\n\t\tspin_unlock_irq(&midi->open_lock);\n\t}\n\treturn err;\n}\n\nstatic void snd_emu10k1_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn;\n\n\tif (up)\n\t\tsnd_emu10k1_intr_enable(emu, midi->rx_enable);\n\telse\n\t\tsnd_emu10k1_intr_disable(emu, midi->rx_enable);\n}\n\nstatic void snd_emu10k1_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_emu10k1_midi *midi = (struct snd_emu10k1_midi *)substream->rmidi->private_data;\n\n\temu = midi->emu;\n\tif (snd_BUG_ON(!emu))\n\t\treturn;\n\n\tif (up) {\n\t\tint max = 4;\n\t\tunsigned char byte;\n\t\n\t\t \n\t\tspin_lock_irq(&midi->output_lock);\n\t\twhile (max > 0) {\n\t\t\tif (mpu401_output_ready(emu, midi)) {\n\t\t\t\tif (!(midi->midi_mode & EMU10K1_MIDI_MODE_OUTPUT) ||\n\t\t\t\t    snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\t \n\t\t\t\t\tspin_unlock_irq(&midi->output_lock);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmpu401_write_data(emu, midi, byte);\n\t\t\t\tmax--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&midi->output_lock);\n\t\tsnd_emu10k1_intr_enable(emu, midi->tx_enable);\n\t} else {\n\t\tsnd_emu10k1_intr_disable(emu, midi->tx_enable);\n\t}\n}\n\n \n\nstatic const struct snd_rawmidi_ops snd_emu10k1_midi_output =\n{\n\t.open =\t\tsnd_emu10k1_midi_output_open,\n\t.close =\tsnd_emu10k1_midi_output_close,\n\t.trigger =\tsnd_emu10k1_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_emu10k1_midi_input =\n{\n\t.open =\t\tsnd_emu10k1_midi_input_open,\n\t.close =\tsnd_emu10k1_midi_input_close,\n\t.trigger =\tsnd_emu10k1_midi_input_trigger,\n};\n\nstatic void snd_emu10k1_midi_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_emu10k1_midi *midi = rmidi->private_data;\n\tmidi->interrupt = NULL;\n\tmidi->rmidi = NULL;\n}\n\nstatic int emu10k1_midi_init(struct snd_emu10k1 *emu, struct snd_emu10k1_midi *midi, int device, char *name)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(emu->card, name, device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tmidi->emu = emu;\n\tspin_lock_init(&midi->open_lock);\n\tspin_lock_init(&midi->input_lock);\n\tspin_lock_init(&midi->output_lock);\n\tstrcpy(rmidi->name, name);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_emu10k1_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_emu10k1_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\n\t                     SNDRV_RAWMIDI_INFO_INPUT |\n\t                     SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = midi;\n\trmidi->private_free = snd_emu10k1_midi_free;\n\tmidi->rmidi = rmidi;\n\treturn 0;\n}\n\nint snd_emu10k1_midi(struct snd_emu10k1 *emu)\n{\n\tstruct snd_emu10k1_midi *midi = &emu->midi;\n\tint err;\n\n\terr = emu10k1_midi_init(emu, midi, 0, \"EMU10K1 MPU-401 (UART)\");\n\tif (err < 0)\n\t\treturn err;\n\n\tmidi->tx_enable = INTE_MIDITXENABLE;\n\tmidi->rx_enable = INTE_MIDIRXENABLE;\n\tmidi->port = MUDATA;\n\tmidi->ipr_tx = IPR_MIDITRANSBUFEMPTY;\n\tmidi->ipr_rx = IPR_MIDIRECVBUFEMPTY;\n\tmidi->interrupt = snd_emu10k1_midi_interrupt;\n\treturn 0;\n}\n\nint snd_emu10k1_audigy_midi(struct snd_emu10k1 *emu)\n{\n\tstruct snd_emu10k1_midi *midi;\n\tint err;\n\n\tmidi = &emu->midi;\n\terr = emu10k1_midi_init(emu, midi, 0, \"Audigy MPU-401 (UART)\");\n\tif (err < 0)\n\t\treturn err;\n\n\tmidi->tx_enable = INTE_MIDITXENABLE;\n\tmidi->rx_enable = INTE_MIDIRXENABLE;\n\tmidi->port = A_MUDATA1;\n\tmidi->ipr_tx = IPR_MIDITRANSBUFEMPTY;\n\tmidi->ipr_rx = IPR_MIDIRECVBUFEMPTY;\n\tmidi->interrupt = snd_emu10k1_midi_interrupt;\n\n\tmidi = &emu->midi2;\n\terr = emu10k1_midi_init(emu, midi, 1, \"Audigy MPU-401 #2\");\n\tif (err < 0)\n\t\treturn err;\n\n\tmidi->tx_enable = INTE_A_MIDITXENABLE2;\n\tmidi->rx_enable = INTE_A_MIDIRXENABLE2;\n\tmidi->port = A_MUDATA2;\n\tmidi->ipr_tx = IPR_A_MIDITRANSBUFEMPTY2;\n\tmidi->ipr_rx = IPR_A_MIDIRECVBUFEMPTY2;\n\tmidi->interrupt = snd_emu10k1_midi_interrupt2;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}