{
  "module_name": "emu10k1_main.c",
  "hash_id": "accb2ed7a8a1a2fc076039e04187c36e863da1b9285fbf6e1a26963a69730fbc",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emu10k1_main.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mutex.h>\n\n\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n#include <linux/firmware.h>\n#include \"p16v.h\"\n#include \"tina2.h\"\n#include \"p17v.h\"\n\n\n#define HANA_FILENAME \"emu/hana.fw\"\n#define DOCK_FILENAME \"emu/audio_dock.fw\"\n#define EMU1010B_FILENAME \"emu/emu1010b.fw\"\n#define MICRO_DOCK_FILENAME \"emu/micro_dock.fw\"\n#define EMU0404_FILENAME \"emu/emu0404.fw\"\n#define EMU1010_NOTEBOOK_FILENAME \"emu/emu1010_notebook.fw\"\n\nMODULE_FIRMWARE(HANA_FILENAME);\nMODULE_FIRMWARE(DOCK_FILENAME);\nMODULE_FIRMWARE(EMU1010B_FILENAME);\nMODULE_FIRMWARE(MICRO_DOCK_FILENAME);\nMODULE_FIRMWARE(EMU0404_FILENAME);\nMODULE_FIRMWARE(EMU1010_NOTEBOOK_FILENAME);\n\n\n \n\nvoid snd_emu10k1_voice_init(struct snd_emu10k1 *emu, int ch)\n{\n\tsnd_emu10k1_ptr_write_multiple(emu, ch,\n\t\tDCYSUSV, 0,\n\t\tVTFT, VTFT_FILTERTARGET_MASK,\n\t\tCVCF, CVCF_CURRENTFILTER_MASK,\n\t\tPTRX, 0,\n\t\tCPF, 0,\n\t\tCCR, 0,\n\n\t\tPSST, 0,\n\t\tDSL, 0x10,\n\t\tCCCA, 0,\n\t\tZ1, 0,\n\t\tZ2, 0,\n\t\tFXRT, 0x32100000,\n\n\t\t\n\t\tDCYSUSM, 0,\n\t\tATKHLDV, 0,\n\t\tATKHLDM, 0,\n\t\tIP, 0,\n\t\tIFATN, IFATN_FILTERCUTOFF_MASK | IFATN_ATTENUATION_MASK,\n\t\tPEFE, 0,\n\t\tFMMOD, 0,\n\t\tTREMFRQ, 24,\t \n\t\tFM2FRQ2, 24,\t \n\t\tLFOVAL2, 0,\n\t\tLFOVAL1, 0,\n\t\tENVVOL, 0,\n\t\tENVVAL, 0,\n\n\t\tREGLIST_END);\n\n\t \n\tif (emu->audigy) {\n\t\tsnd_emu10k1_ptr_write_multiple(emu, ch,\n\t\t\tA_CSBA, 0,\n\t\t\tA_CSDC, 0,\n\t\t\tA_CSFE, 0,\n\t\t\tA_CSHG, 0,\n\t\t\tA_FXRT1, 0x03020100,\n\t\t\tA_FXRT2, 0x07060504,\n\t\t\tA_SENDAMOUNTS, 0,\n\t\t\tREGLIST_END);\n\t}\n}\n\nstatic const unsigned int spi_dac_init[] = {\n\t\t0x00ff,\n\t\t0x02ff,\n\t\t0x0400,\n\t\t0x0520,\n\t\t0x0600,\n\t\t0x08ff,\n\t\t0x0aff,\n\t\t0x0cff,\n\t\t0x0eff,\n\t\t0x10ff,\n\t\t0x1200,\n\t\t0x1400,\n\t\t0x1480,\n\t\t0x1800,\n\t\t0x1aff,\n\t\t0x1cff,\n\t\t0x1e00,\n\t\t0x0530,\n\t\t0x0602,\n\t\t0x0622,\n\t\t0x1400,\n};\n\nstatic const unsigned int i2c_adc_init[][2] = {\n\t{ 0x17, 0x00 },  \n\t{ 0x07, 0x00 },  \n\t{ 0x0b, 0x22 },   \n\t{ 0x0c, 0x22 },   \n\t{ 0x0d, 0x08 },   \n\t{ 0x0e, 0xcf },   \n\t{ 0x0f, 0xcf },   \n\t{ 0x10, 0x7b },   \n\t{ 0x11, 0x00 },   \n\t{ 0x12, 0x32 },   \n\t{ 0x13, 0x00 },   \n\t{ 0x14, 0xa6 },   \n\t{ 0x15, ADC_MUX_2 },   \n};\n\nstatic int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir)\n{\n\tunsigned int silent_page;\n\tint ch;\n\tu32 tmp;\n\n\t \n\toutl(HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK |\n\t\tHCFG_MUTEBUTTONENABLE, emu->port + HCFG);\n\n\toutl(0, emu->port + INTE);\n\n\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\t \n\t\tMICBS, ADCBS_BUFSIZE_NONE,\n\t\tMICBA, 0,\n\t\tFXBS, ADCBS_BUFSIZE_NONE,\n\t\tFXBA, 0,\n\t\tADCBS, ADCBS_BUFSIZE_NONE,\n\t\tADCBA, 0,\n\n\t\t \n\t\tCLIEL, 0,\n\t\tCLIEH, 0,\n\n\t\t \n\t\tSOLEL, 0,\n\t\tSOLEH, 0,\n\n\t\tREGLIST_END);\n\n\tif (emu->audigy) {\n\t\t \n\t\tsnd_emu10k1_ptr_write(emu, SPBYPASS, 0, SPBYPASS_FORMAT);\n\t\t \n\t\tsnd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_REAR_RIGHT |\n\t\t\t\t      AC97SLOT_REAR_LEFT);\n\t}\n\n\t \n\tfor (ch = 0; ch < NUM_G; ch++)\n\t\tsnd_emu10k1_voice_init(emu, ch);\n\n\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\tSPCS0, emu->spdif_bits[0],\n\t\tSPCS1, emu->spdif_bits[1],\n\t\tSPCS2, emu->spdif_bits[2],\n\t\tREGLIST_END);\n\n\tif (emu->card_capabilities->emu_model) {\n\t} else if (emu->card_capabilities->ca0151_chip) {  \n\t\t \n\t\t \n\t\tsnd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, 0, A_I2S_CAPTURE_96000);\n\n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, SRCSel, 0, 0x14);\n\t\t \n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, SRCMULTI_ENABLE, 0, 0xFFFFFFFF);\n\n\t\t \n\t\toutl(0x0201, emu->port + HCFG2);\n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, CAPTURE_P16V_SOURCE, 0, 0x78e4);\n\t} else if (emu->card_capabilities->ca0108_chip) {  \n\t\t \n\t\tdev_info(emu->card->dev, \"Audigy2 value: Special config.\\n\");\n\t\t \n\t\tsnd_emu10k1_ptr_write(emu, A_I2S_CAPTURE_RATE, 0, A_I2S_CAPTURE_96000);\n\n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, P17V_SRCSel, 0, 0x14);\n\n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, P17V_MIXER_I2S_ENABLE, 0, 0xFF000000);\n\n\t\t \n\t\t \n\t\tsnd_emu10k1_ptr20_write(emu, P17V_MIXER_SPDIF_ENABLE, 0, 0xFF000000);\n\n\t\ttmp = inw(emu->port + A_IOCFG) & ~0x8;  \n\t\toutw(tmp, emu->port + A_IOCFG);\n\t}\n\tif (emu->card_capabilities->spi_dac) {  \n\t\tint size, n;\n\n\t\tsize = ARRAY_SIZE(spi_dac_init);\n\t\tfor (n = 0; n < size; n++)\n\t\t\tsnd_emu10k1_spi_write(emu, spi_dac_init[n]);\n\n\t\tsnd_emu10k1_ptr20_write(emu, 0x60, 0, 0x10);\n\t\t \n\t\toutw(0x76, emu->port + A_IOCFG);  \n\t}\n\tif (emu->card_capabilities->i2c_adc) {  \n\t\tint size, n;\n\n\t\tsnd_emu10k1_ptr20_write(emu, P17V_I2S_SRC_SEL, 0, 0x2020205f);\n\t\ttmp = inw(emu->port + A_IOCFG);\n\t\toutw(tmp | 0x4, emu->port + A_IOCFG);   \n\t\ttmp = inw(emu->port + A_IOCFG);\n\t\tsize = ARRAY_SIZE(i2c_adc_init);\n\t\tfor (n = 0; n < size; n++)\n\t\t\tsnd_emu10k1_i2c_write(emu, i2c_adc_init[n][0], i2c_adc_init[n][1]);\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\temu->i2c_capture_volume[n][0] = 0xcf;\n\t\t\temu->i2c_capture_volume[n][1] = 0xcf;\n\t\t}\n\t}\n\n\n\tsnd_emu10k1_ptr_write(emu, PTB, 0, emu->ptb_pages.addr);\n\tsnd_emu10k1_ptr_write(emu, TCB, 0, 0);\t \n\tsnd_emu10k1_ptr_write(emu, TCBS, 0, TCBS_BUFFSIZE_256K);\t \n\n\tsilent_page = (emu->silent_page.addr << emu->address_mode) | (emu->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);\n\tfor (ch = 0; ch < NUM_G; ch++) {\n\t\tsnd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);\n\t\tsnd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);\n\t}\n\n\tif (emu->card_capabilities->emu_model) {\n\t\toutl(HCFG_AUTOMUTE_ASYNC |\n\t\t\tHCFG_EMU32_SLAVE |\n\t\t\tHCFG_AUDIOENABLE, emu->port + HCFG);\n\t \n\t} else if (emu->audigy) {\n\t\tif (emu->revision == 4)  \n\t\t\toutl(HCFG_AUDIOENABLE |\n\t\t\t     HCFG_AC3ENABLE_CDSPDIF |\n\t\t\t     HCFG_AC3ENABLE_GPSPDIF |\n\t\t\t     HCFG_AUTOMUTE | HCFG_JOYENABLE, emu->port + HCFG);\n\t\telse\n\t\t\toutl(HCFG_AUTOMUTE | HCFG_JOYENABLE, emu->port + HCFG);\n\t \n\t} else if (emu->model == 0x20 ||\n\t    emu->model == 0xc400 ||\n\t    (emu->model == 0x21 && emu->revision < 6))\n\t\toutl(HCFG_LOCKTANKCACHE_MASK | HCFG_AUTOMUTE, emu->port + HCFG);\n\telse\n\t\t \n\t\toutl(HCFG_LOCKTANKCACHE_MASK | HCFG_AUTOMUTE | HCFG_JOYENABLE, emu->port + HCFG);\n\n\tif (enable_ir) {\t \n\t\tif (emu->card_capabilities->emu_model) {\n\t\t\t;   \n\t\t} else if (emu->card_capabilities->i2c_adc) {\n\t\t\t;   \n\t\t} else if (emu->audigy) {\n\t\t\tu16 reg = inw(emu->port + A_IOCFG);\n\t\t\toutw(reg | A_IOCFG_GPOUT2, emu->port + A_IOCFG);\n\t\t\tudelay(500);\n\t\t\toutw(reg | A_IOCFG_GPOUT1 | A_IOCFG_GPOUT2, emu->port + A_IOCFG);\n\t\t\tudelay(100);\n\t\t\toutw(reg, emu->port + A_IOCFG);\n\t\t} else {\n\t\t\tunsigned int reg = inl(emu->port + HCFG);\n\t\t\toutl(reg | HCFG_GPOUT2, emu->port + HCFG);\n\t\t\tudelay(500);\n\t\t\toutl(reg | HCFG_GPOUT1 | HCFG_GPOUT2, emu->port + HCFG);\n\t\t\tudelay(100);\n\t\t\toutl(reg, emu->port + HCFG);\n\t\t}\n\t}\n\n\tif (emu->card_capabilities->emu_model) {\n\t\t;   \n\t} else if (emu->card_capabilities->i2c_adc) {\n\t\t;   \n\t} else if (emu->audigy) {\t \n\t\tu16 reg = inw(emu->port + A_IOCFG);\n\t\toutw(reg | A_IOCFG_GPOUT0, emu->port + A_IOCFG);\n\t}\n\n\tif (emu->address_mode == 0) {\n\t\t \n\t\toutl(inl(emu->port + HCFG) | HCFG_EXPANDED_MEM, emu->port + HCFG);\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_emu10k1_audio_enable(struct snd_emu10k1 *emu)\n{\n\t \n\toutl(inl(emu->port + HCFG) | HCFG_AUDIOENABLE, emu->port + HCFG);\n\n\t \n\tif (emu->card_capabilities->emu_model) {\n\t\t;   \n\t} else if (emu->card_capabilities->i2c_adc) {\n\t\t;   \n\t} else if (emu->audigy) {\n\t\toutw(inw(emu->port + A_IOCFG) & ~0x44, emu->port + A_IOCFG);\n\n\t\tif (emu->card_capabilities->ca0151_chip) {  \n\t\t\t \n\t\t\toutw(inw(emu->port + A_IOCFG) | 0x0040, emu->port + A_IOCFG);\n\t\t} else if (emu->card_capabilities->ca0108_chip) {  \n\t\t\t \n\t\t\toutw(inw(emu->port + A_IOCFG) | 0x0060, emu->port + A_IOCFG);\n\t\t} else {\n\t\t\t \n\t\t\toutw(inw(emu->port + A_IOCFG) | 0x0080, emu->port + A_IOCFG);\n\t\t}\n\t}\n\n#if 0\n\t{\n\tunsigned int tmp;\n\t \n\t \n\temu->tos_link = 0;\n\ttmp = inl(emu->port + HCFG);\n\tif (tmp & (HCFG_GPINPUT0 | HCFG_GPINPUT1)) {\n\t\toutl(tmp|0x800, emu->port + HCFG);\n\t\tudelay(50);\n\t\tif (tmp != (inl(emu->port + HCFG) & ~0x800)) {\n\t\t\temu->tos_link = 1;\n\t\t\toutl(tmp, emu->port + HCFG);\n\t\t}\n\t}\n\t}\n#endif\n\n\tif (emu->card_capabilities->emu_model)\n\t\tsnd_emu10k1_intr_enable(emu, INTE_PCIERRORENABLE | INTE_A_GPIOENABLE);\n\telse\n\t\tsnd_emu10k1_intr_enable(emu, INTE_PCIERRORENABLE);\n}\n\nint snd_emu10k1_done(struct snd_emu10k1 *emu)\n{\n\tint ch;\n\n\toutl(0, emu->port + INTE);\n\n\t \n\tfor (ch = 0; ch < NUM_G; ch++) {\n\t\tsnd_emu10k1_ptr_write_multiple(emu, ch,\n\t\t\tDCYSUSV, 0,\n\t\t\tVTFT, 0,\n\t\t\tCVCF, 0,\n\t\t\tPTRX, 0,\n\t\t\tCPF, 0,\n\t\t\tREGLIST_END);\n\t}\n\n\t\n\tif (emu->audigy)\n\t\tsnd_emu10k1_ptr_write(emu, A_DBG, 0, A_DBG_SINGLE_STEP);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, DBG, 0, EMU10K1_DBG_SINGLE_STEP);\n\n\tsnd_emu10k1_ptr_write_multiple(emu, 0,\n\t\t \n\t\tMICBS, 0,\n\t\tMICBA, 0,\n\t\tFXBS, 0,\n\t\tFXBA, 0,\n\t\tFXWC, 0,\n\t\tADCBS, ADCBS_BUFSIZE_NONE,\n\t\tADCBA, 0,\n\t\tTCBS, TCBS_BUFFSIZE_16K,\n\t\tTCB, 0,\n\n\t\t \n\t\tCLIEL, 0,\n\t\tCLIEH, 0,\n\t\tSOLEL, 0,\n\t\tSOLEH, 0,\n\n\t\tPTB, 0,\n\n\t\tREGLIST_END);\n\n\t \n\toutl(HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK | HCFG_MUTEBUTTONENABLE, emu->port + HCFG);\n\n\treturn 0;\n}\n\n \n\n \n#define HOOKN_BIT\t\t(1L << 12)\n#define HANDN_BIT\t\t(1L << 11)\n#define PULSEN_BIT\t\t(1L << 10)\n\n#define EC_GDI1\t\t\t(1 << 13)\n#define EC_GDI0\t\t\t(1 << 14)\n\n#define EC_NUM_CONTROL_BITS\t20\n\n#define EC_AC3_DATA_SELN\t0x0001L\n#define EC_EE_DATA_SEL\t\t0x0002L\n#define EC_EE_CNTRL_SELN\t0x0004L\n#define EC_EECLK\t\t0x0008L\n#define EC_EECS\t\t\t0x0010L\n#define EC_EESDO\t\t0x0020L\n#define EC_TRIM_CSN\t\t0x0040L\n#define EC_TRIM_SCLK\t\t0x0080L\n#define EC_TRIM_SDATA\t\t0x0100L\n#define EC_TRIM_MUTEN\t\t0x0200L\n#define EC_ADCCAL\t\t0x0400L\n#define EC_ADCRSTN\t\t0x0800L\n#define EC_DACCAL\t\t0x1000L\n#define EC_DACMUTEN\t\t0x2000L\n#define EC_LEDN\t\t\t0x4000L\n\n#define EC_SPDIF0_SEL_SHIFT\t15\n#define EC_SPDIF1_SEL_SHIFT\t17\n#define EC_SPDIF0_SEL_MASK\t(0x3L << EC_SPDIF0_SEL_SHIFT)\n#define EC_SPDIF1_SEL_MASK\t(0x7L << EC_SPDIF1_SEL_SHIFT)\n#define EC_SPDIF0_SELECT(_x)\t(((_x) << EC_SPDIF0_SEL_SHIFT) & EC_SPDIF0_SEL_MASK)\n#define EC_SPDIF1_SELECT(_x)\t(((_x) << EC_SPDIF1_SEL_SHIFT) & EC_SPDIF1_SEL_MASK)\n#define EC_CURRENT_PROM_VERSION 0x01\t \n\n#define EC_EEPROM_SIZE\t\t0x40\t \n\n \n#define EC_PROM_VERSION_ADDR\t0x20\t \n#define EC_BOARDREV0_ADDR\t0x21\t \n#define EC_BOARDREV1_ADDR\t0x22\t \n\n#define EC_LAST_PROMFILE_ADDR\t0x2f\n\n#define EC_SERIALNUM_ADDR\t0x30\t \n#define EC_CHECKSUM_ADDR\t0x3f\t \n\n\n \n#define EC_RAW_RUN_MODE\t\t(EC_DACMUTEN | EC_ADCRSTN | EC_TRIM_MUTEN | \\\n\t\t\t\t EC_TRIM_CSN)\n\n\n#define EC_DEFAULT_ADC_GAIN\t0xC4C4\n#define EC_DEFAULT_SPDIF0_SEL\t0x0\n#define EC_DEFAULT_SPDIF1_SEL\t0x4\n\n \n\nstatic void snd_emu10k1_ecard_write(struct snd_emu10k1 *emu, unsigned int value)\n{\n\tunsigned short count;\n\tunsigned int data;\n\tunsigned long hc_port;\n\tunsigned int hc_value;\n\n\thc_port = emu->port + HCFG;\n\thc_value = inl(hc_port) & ~(HOOKN_BIT | HANDN_BIT | PULSEN_BIT);\n\toutl(hc_value, hc_port);\n\n\tfor (count = 0; count < EC_NUM_CONTROL_BITS; count++) {\n\n\t\t \n\t\tdata = ((value & 0x1) ? PULSEN_BIT : 0);\n\t\tvalue >>= 1;\n\n\t\toutl(hc_value | data, hc_port);\n\n\t\t \n\t\toutl(hc_value | data | HANDN_BIT, hc_port);\n\t\toutl(hc_value | data, hc_port);\n\t}\n\n\t \n\toutl(hc_value | HOOKN_BIT, hc_port);\n\toutl(hc_value, hc_port);\n}\n\n \n\nstatic void snd_emu10k1_ecard_setadcgain(struct snd_emu10k1 *emu,\n\t\t\t\t\t unsigned short gain)\n{\n\tunsigned int bit;\n\n\t \n\tsnd_emu10k1_ecard_write(emu, emu->ecard_ctrl & ~EC_TRIM_CSN);\n\n\t \n\tsnd_emu10k1_ecard_write(emu, emu->ecard_ctrl & ~EC_TRIM_CSN);\n\n\tfor (bit = (1 << 15); bit; bit >>= 1) {\n\t\tunsigned int value;\n\n\t\tvalue = emu->ecard_ctrl & ~(EC_TRIM_CSN | EC_TRIM_SDATA);\n\n\t\tif (gain & bit)\n\t\t\tvalue |= EC_TRIM_SDATA;\n\n\t\t \n\t\tsnd_emu10k1_ecard_write(emu, value);\n\t\tsnd_emu10k1_ecard_write(emu, value | EC_TRIM_SCLK);\n\t\tsnd_emu10k1_ecard_write(emu, value);\n\t}\n\n\tsnd_emu10k1_ecard_write(emu, emu->ecard_ctrl);\n}\n\nstatic int snd_emu10k1_ecard_init(struct snd_emu10k1 *emu)\n{\n\tunsigned int hc_value;\n\n\t \n\temu->ecard_ctrl = EC_RAW_RUN_MODE |\n\t\t\t  EC_SPDIF0_SELECT(EC_DEFAULT_SPDIF0_SEL) |\n\t\t\t  EC_SPDIF1_SELECT(EC_DEFAULT_SPDIF1_SEL);\n\n\t \n\thc_value = inl(emu->port + HCFG);\n\toutl(hc_value | HCFG_AUDIOENABLE | HCFG_CODECFORMAT_I2S, emu->port + HCFG);\n\tinl(emu->port + HCFG);\n\n\t \n\tsnd_emu10k1_ecard_write(emu, EC_ADCCAL | EC_LEDN | EC_TRIM_CSN);\n\n\t \n\tsnd_emu10k1_ecard_write(emu, EC_DACCAL | EC_LEDN | EC_TRIM_CSN);\n\n\t \n\tsnd_emu10k1_wait(emu, 48000);\n\n\t \n\tsnd_emu10k1_ecard_write(emu, EC_ADCCAL | EC_LEDN | EC_TRIM_CSN);\n\n\t \n\tsnd_emu10k1_ecard_write(emu, emu->ecard_ctrl);\n\n\t \n\tsnd_emu10k1_ecard_setadcgain(emu, EC_DEFAULT_ADC_GAIN);\n\n\treturn 0;\n}\n\nstatic int snd_emu10k1_cardbus_init(struct snd_emu10k1 *emu)\n{\n\tunsigned long special_port;\n\t__always_unused unsigned int value;\n\n\t \n\tspecial_port = emu->port + 0x38;\n\tvalue = inl(special_port);\n\toutl(0x00d00000, special_port);\n\tvalue = inl(special_port);\n\toutl(0x00d00001, special_port);\n\tvalue = inl(special_port);\n\toutl(0x00d0005f, special_port);\n\tvalue = inl(special_port);\n\toutl(0x00d0007f, special_port);\n\tvalue = inl(special_port);\n\toutl(0x0090007f, special_port);\n\tvalue = inl(special_port);\n\n\tsnd_emu10k1_ptr20_write(emu, TINA2_VOLUME, 0, 0xfefefefe);  \n\t \n\tmsleep(200);\n\treturn 0;\n}\n\nstatic int snd_emu1010_load_firmware_entry(struct snd_emu10k1 *emu,\n\t\t\t\t     const struct firmware *fw_entry)\n{\n\tint n, i;\n\tu16 reg;\n\tu8 value;\n\t__always_unused u16 write_post;\n\n\tif (!fw_entry)\n\t\treturn -EIO;\n\n\t \n\t \n\t \n\tspin_lock_irq(&emu->emu_lock);\n\toutw(0x00, emu->port + A_GPIO);  \n\twrite_post = inw(emu->port + A_GPIO);\n\tudelay(100);\n\toutw(0x80, emu->port + A_GPIO);  \n\twrite_post = inw(emu->port + A_GPIO);\n\tudelay(100);  \n\tfor (n = 0; n < fw_entry->size; n++) {\n\t\tvalue = fw_entry->data[n];\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\treg = 0x80;\n\t\t\tif (value & 0x1)\n\t\t\t\treg = reg | 0x20;\n\t\t\tvalue = value >> 1;\n\t\t\toutw(reg, emu->port + A_GPIO);\n\t\t\twrite_post = inw(emu->port + A_GPIO);\n\t\t\toutw(reg | 0x40, emu->port + A_GPIO);\n\t\t\twrite_post = inw(emu->port + A_GPIO);\n\t\t}\n\t}\n\t \n\toutw(0x10, emu->port + A_GPIO);\n\twrite_post = inw(emu->port + A_GPIO);\n\tspin_unlock_irq(&emu->emu_lock);\n\n\treturn 0;\n}\n\n \nstatic const char * const firmware_names[5][2] = {\n\t[EMU_MODEL_EMU1010] = {\n\t\tHANA_FILENAME, DOCK_FILENAME\n\t},\n\t[EMU_MODEL_EMU1010B] = {\n\t\tEMU1010B_FILENAME, MICRO_DOCK_FILENAME\n\t},\n\t[EMU_MODEL_EMU1616] = {\n\t\tEMU1010_NOTEBOOK_FILENAME, MICRO_DOCK_FILENAME\n\t},\n\t[EMU_MODEL_EMU0404] = {\n\t\tEMU0404_FILENAME, NULL\n\t},\n};\n\nstatic int snd_emu1010_load_firmware(struct snd_emu10k1 *emu, int dock,\n\t\t\t\t     const struct firmware **fw)\n{\n\tconst char *filename;\n\tint err;\n\n\tif (!*fw) {\n\t\tfilename = firmware_names[emu->card_capabilities->emu_model][dock];\n\t\tif (!filename)\n\t\t\treturn 0;\n\t\terr = request_firmware(fw, filename, &emu->pci->dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn snd_emu1010_load_firmware_entry(emu, *fw);\n}\n\nstatic void emu1010_firmware_work(struct work_struct *work)\n{\n\tstruct snd_emu10k1 *emu;\n\tu32 tmp, tmp2, reg;\n\tint err;\n\n\temu = container_of(work, struct snd_emu10k1,\n\t\t\t   emu1010.firmware_work);\n\tif (emu->card->shutdown)\n\t\treturn;\n#ifdef CONFIG_PM_SLEEP\n\tif (emu->suspend)\n\t\treturn;\n#endif\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg);  \n\tif (reg & EMU_HANA_OPTION_DOCK_OFFLINE) {\n\t\t \n\t\t \n\t\tdev_info(emu->card->dev,\n\t\t\t \"emu1010: Loading Audio Dock Firmware\\n\");\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_FPGA_CONFIG,\n\t\t\t\t       EMU_HANA_FPGA_CONFIG_AUDIODOCK);\n\t\terr = snd_emu1010_load_firmware(emu, 1, &emu->dock_fw);\n\t\tif (err < 0)\n\t\t\treturn;\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_FPGA_CONFIG, 0);\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_ID, &tmp);\n\t\tdev_info(emu->card->dev,\n\t\t\t \"emu1010: EMU_HANA+DOCK_ID = 0x%x\\n\", tmp);\n\t\tif ((tmp & 0x1f) != 0x15) {\n\t\t\t \n\t\t\tdev_info(emu->card->dev,\n\t\t\t\t \"emu1010: Loading Audio Dock Firmware file failed, reg = 0x%x\\n\",\n\t\t\t\t tmp);\n\t\t\treturn;\n\t\t}\n\t\tdev_info(emu->card->dev,\n\t\t\t \"emu1010: Audio Dock Firmware loaded\\n\");\n\t\tsnd_emu1010_fpga_read(emu, EMU_DOCK_MAJOR_REV, &tmp);\n\t\tsnd_emu1010_fpga_read(emu, EMU_DOCK_MINOR_REV, &tmp2);\n\t\tdev_info(emu->card->dev, \"Audio Dock ver: %u.%u\\n\", tmp, tmp2);\n\t\t \n\t\t \n\t\tmsleep(10);\n\t\t \n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE);\n\t}\n}\n\nstatic void emu1010_clock_work(struct work_struct *work)\n{\n\tstruct snd_emu10k1 *emu;\n\tstruct snd_ctl_elem_id id;\n\n\temu = container_of(work, struct snd_emu10k1,\n\t\t\t   emu1010.clock_work);\n\tif (emu->card->shutdown)\n\t\treturn;\n#ifdef CONFIG_PM_SLEEP\n\tif (emu->suspend)\n\t\treturn;\n#endif\n\n\tspin_lock_irq(&emu->reg_lock);\n\t\n\temu->emu1010.clock_source = emu->emu1010.clock_fallback;\n\temu->emu1010.wclock = 1 - emu->emu1010.clock_source;\n\tsnd_emu1010_update_clock(emu);\n\tspin_unlock_irq(&emu->reg_lock);\n\tsnd_ctl_build_ioff(&id, emu->ctl_clock_source, 0);\n\tsnd_ctl_notify(emu->card, SNDRV_CTL_EVENT_MASK_VALUE, &id);\n}\n\nstatic void emu1010_interrupt(struct snd_emu10k1 *emu)\n{\n\tu32 sts;\n\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_IRQ_STATUS, &sts);\n\tif (sts & EMU_HANA_IRQ_DOCK_LOST) {\n\t\t \n\t\tdev_info(emu->card->dev, \"emu1010: Audio Dock detached\\n\");\n\t\t \n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE);\n\t} else if (sts & EMU_HANA_IRQ_DOCK) {\n\t\tschedule_work(&emu->emu1010.firmware_work);\n\t}\n\tif (sts & EMU_HANA_IRQ_WCLK_CHANGED)\n\t\tschedule_work(&emu->emu1010.clock_work);\n}\n\n \nstatic int snd_emu10k1_emu1010_init(struct snd_emu10k1 *emu)\n{\n\tu32 tmp, tmp2, reg;\n\tint err;\n\n\tdev_info(emu->card->dev, \"emu1010: Special config.\\n\");\n\n\t \n\toutl(HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK, emu->port + HCFG);\n\n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, 0);\n\n\t \n\tsnd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg);\n\tdev_dbg(emu->card->dev, \"reg1 = 0x%x\\n\", reg);\n\tif ((reg & 0x3f) == 0x15) {\n\t\t \n\t\t \n\n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_FPGA_CONFIG, EMU_HANA_FPGA_CONFIG_HANA);\n\t}\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg);\n\tdev_dbg(emu->card->dev, \"reg2 = 0x%x\\n\", reg);\n\tif ((reg & 0x3f) == 0x15) {\n\t\t \n\t\tdev_info(emu->card->dev,\n\t\t\t \"emu1010: FPGA failed to return to programming mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_info(emu->card->dev, \"emu1010: EMU_HANA_ID = 0x%x\\n\", reg);\n\n\terr = snd_emu1010_load_firmware(emu, 0, &emu->firmware);\n\tif (err < 0) {\n\t\tdev_info(emu->card->dev, \"emu1010: Loading Firmware failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tsnd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg);\n\tif ((reg & 0x3f) != 0x15) {\n\t\t \n\t\tdev_info(emu->card->dev,\n\t\t\t \"emu1010: Loading Hana Firmware file failed, reg = 0x%x\\n\",\n\t\t\t reg);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(emu->card->dev, \"emu1010: Hana Firmware loaded\\n\");\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_MAJOR_REV, &tmp);\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_MINOR_REV, &tmp2);\n\tdev_info(emu->card->dev, \"emu1010: Hana version: %u.%u\\n\", tmp, tmp2);\n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, EMU_HANA_DOCK_PWR_ON);\n\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg);\n\tdev_info(emu->card->dev, \"emu1010: Card options = 0x%x\\n\", reg);\n\tif (reg & EMU_HANA_OPTION_DOCK_OFFLINE)\n\t\tschedule_work(&emu->emu1010.firmware_work);\n\tif (emu->card_capabilities->no_adat) {\n\t\temu->emu1010.optical_in = 0;  \n\t\temu->emu1010.optical_out = 0;  \n\t} else {\n\t\t \n\t\temu->emu1010.optical_in = 1;  \n\t\temu->emu1010.optical_out = 1;  \n\t}\n\ttmp = (emu->emu1010.optical_in ? EMU_HANA_OPTICAL_IN_ADAT : EMU_HANA_OPTICAL_IN_SPDIF) |\n\t\t(emu->emu1010.optical_out ? EMU_HANA_OPTICAL_OUT_ADAT : EMU_HANA_OPTICAL_OUT_SPDIF);\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, tmp);\n\t \n\temu->emu1010.adc_pads = 0x00;\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_ADC_PADS, emu->emu1010.adc_pads);\n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_MISC, EMU_HANA_DOCK_PHONES_192_DAC4);\n\t \n\temu->emu1010.dac_pads = EMU_HANA_DOCK_DAC_PAD1 | EMU_HANA_DOCK_DAC_PAD2 |\n\t\t\t\tEMU_HANA_DOCK_DAC_PAD3 | EMU_HANA_DOCK_DAC_PAD4;\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DAC_PADS, emu->emu1010.dac_pads);\n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_SPDIF_MODE, EMU_HANA_SPDIF_MODE_RX_INVALID);\n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_MIDI_IN, EMU_HANA_MIDI_INA_FROM_HAMOA | EMU_HANA_MIDI_INB_FROM_DOCK2);\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_MIDI_OUT, EMU_HANA_MIDI_OUT_DOCK2 | EMU_HANA_MIDI_OUT_SYNC2);\n\n\temu->gpio_interrupt = emu1010_interrupt;\n\t\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_IRQ_ENABLE,\n\t\t\t       EMU_HANA_IRQ_DOCK | EMU_HANA_IRQ_DOCK_LOST | EMU_HANA_IRQ_WCLK_CHANGED);\n\tsnd_emu1010_fpga_read(emu, EMU_HANA_IRQ_STATUS, &reg);  \n\n\temu->emu1010.clock_source = 1;   \n\temu->emu1010.clock_fallback = 1;   \n\t \n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_48K);\n\t \n\temu->emu1010.wclock = EMU_HANA_WCLOCK_INT_48K;\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K);\n\t \n\tsnd_emu1010_update_clock(emu);\n\n\t\n\t\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE);\n\n\treturn 0;\n}\n \n\n#ifdef CONFIG_PM_SLEEP\nstatic int alloc_pm_buffer(struct snd_emu10k1 *emu);\nstatic void free_pm_buffer(struct snd_emu10k1 *emu);\n#endif\n\nstatic void snd_emu10k1_free(struct snd_card *card)\n{\n\tstruct snd_emu10k1 *emu = card->private_data;\n\n\tif (emu->port) {\t \n\t\tsnd_emu10k1_fx8010_tram_setup(emu, 0);\n\t\tsnd_emu10k1_done(emu);\n\t\tsnd_emu10k1_free_efx(emu);\n\t}\n\tif (emu->card_capabilities->emu_model == EMU_MODEL_EMU1010) {\n\t\t \n\t\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, 0);\n\t}\n\tcancel_work_sync(&emu->emu1010.firmware_work);\n\tcancel_work_sync(&emu->emu1010.clock_work);\n\trelease_firmware(emu->firmware);\n\trelease_firmware(emu->dock_fw);\n\tsnd_util_memhdr_free(emu->memhdr);\n\tif (emu->silent_page.area)\n\t\tsnd_dma_free_pages(&emu->silent_page);\n\tif (emu->ptb_pages.area)\n\t\tsnd_dma_free_pages(&emu->ptb_pages);\n\tvfree(emu->page_ptr_table);\n\tvfree(emu->page_addr_table);\n#ifdef CONFIG_PM_SLEEP\n\tfree_pm_buffer(emu);\n#endif\n}\n\nstatic const struct snd_emu_chip_details emu_chip_details[] = {\n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x10241102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 5/Rx [SB1550]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk71 = 1,\n\t .adc_1361t = 1,   \n\t .ac97_chip = 1},\n\t \n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x10211102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 4 [SB0610]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk71 = 1,\n\t .adc_1361t = 1,   \n\t .ac97_chip = 1} ,\n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x10011102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 Value [SB0400]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk71 = 1,\n\t .ac97_chip = 1} ,\n\t \n\t \n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,\n\t .driver = \"Audigy2\", .name = \"Audigy 2 ZS Notebook [SB0530]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .ca_cardbus_chip = 1,\n\t .spi_dac = 1,\n\t .i2c_adc = 1,\n\t .spk71 = 1} ,\n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x42011102,\n\t .driver = \"Audigy2\", .name = \"E-MU 02 CardBus [MAEM8950]\",\n\t .id = \"EMU1010\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .ca_cardbus_chip = 1,\n\t .spk71 = 1 ,\n\t .emu_model = EMU_MODEL_EMU1616},\n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x40041102,\n\t .driver = \"Audigy2\", .name = \"E-MU 1010b PCI [MAEM8960]\",\n\t .id = \"EMU1010\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk71 = 1,\n\t .emu_model = EMU_MODEL_EMU1010B},  \n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x40071102,\n\t .driver = \"Audigy2\", .name = \"E-MU 1010 PCIe [MAEM8986]\",\n\t .id = \"EMU1010\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk71 = 1,\n\t .emu_model = EMU_MODEL_EMU1010B},  \n\t \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x40011102,\n\t .driver = \"Audigy2\", .name = \"E-MU 1010 [MAEM8810]\",\n\t .id = \"EMU1010\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .spk71 = 1,\n\t .emu_model = EMU_MODEL_EMU1010},  \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x40021102,\n\t .driver = \"Audigy2\", .name = \"E-MU 0404b PCI [MAEM8852]\",\n\t .id = \"EMU0404\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk20 = 1,\n\t .no_adat = 1,\n\t .emu_model = EMU_MODEL_EMU0404},  \n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x40021102,\n\t .driver = \"Audigy2\", .name = \"E-MU 0404 [MAEM8850]\",\n\t .id = \"EMU0404\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .spk20 = 1,\n\t .no_adat = 1,\n\t .emu_model = EMU_MODEL_EMU0404},  \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x40051102,\n\t .driver = \"Audigy2\", .name = \"E-MU 0404 PCIe [MAEM8984]\",\n\t .id = \"EMU0404\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .spk20 = 1,\n\t .no_adat = 1,\n\t .emu_model = EMU_MODEL_EMU0404},  \n\t{.vendor = 0x1102, .device = 0x0008,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 Value [Unknown]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0108_chip = 1,\n\t .ac97_chip = 1} ,\n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20071102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 4 PRO [SB0380]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .ac97_chip = 1} ,\n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20061102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 [SB0350b]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .ac97_chip = 1} ,\n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20051102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 ZS [SB0350a]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20021102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 ZS [SB0350]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20011102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 ZS [SB0360]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .ac97_chip = 1} ,\n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10071102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 [SB0240]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .adc_1361t = 1,   \n\t .ac97_chip = 1} ,\n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,\n\t .driver = \"Audigy2\", .name = \"Audigy 2 Platinum EX [SB0280]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1} ,\n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10031102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 ZS [SB0353]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .ac97_chip = 1} ,\n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10021102,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 Platinum [SB0240P]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spk71 = 1,\n\t .spdif_bug = 1,\n\t .invert_shared_spdif = 1,\t \n\t .adc_1361t = 1,   \n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .revision = 0x04,\n\t .driver = \"Audigy2\", .name = \"SB Audigy 2 [Unknown]\",\n\t .id = \"Audigy2\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ca0151_chip = 1,\n\t .spdif_bug = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x00531102,\n\t .driver = \"Audigy\", .name = \"SB Audigy 1 [SB0092]\",\n\t .id = \"Audigy\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x00521102,\n\t .driver = \"Audigy\", .name = \"SB Audigy 1 ES [SB0160]\",\n\t .id = \"Audigy\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .spdif_bug = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x00511102,\n\t .driver = \"Audigy\", .name = \"SB Audigy 1 [SB0090]\",\n\t .id = \"Audigy\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0004,\n\t .driver = \"Audigy\", .name = \"Audigy 1 [Unknown]\",\n\t .id = \"Audigy\",\n\t .emu10k2_chip = 1,\n\t .ca0102_chip = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x100a1102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! 5.1 [SB0220]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x806b1102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! [SB0105]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x806a1102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [SB0103]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80691102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [SB0101]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80661102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! 5.1 Dell OEM [SB0228]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t \n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80651102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! 5.1 [SB0220]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80641102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! 5.1\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t \n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80611102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! 5.1 [SB0060]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 2,  \n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80511102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4850]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t \n\t \n\t \n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80401102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Platinum [CT4760P]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80321102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4871]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80311102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4831]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80281102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4870]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t \n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80271102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4832]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80261102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4830]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80231102,\n\t .driver = \"EMU10K1\", .name = \"SB PCI512 [CT4790]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x80221102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4780]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x40011102,\n\t .driver = \"EMU10K1\", .name = \"E-MU APS [PC545]\",\n\t .id = \"APS\",\n\t .emu10k1_chip = 1,\n\t .ecard = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x00211102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! [CT4620]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002, .subsystem = 0x00201102,\n\t .driver = \"EMU10K1\", .name = \"SB Live! Value [CT4670]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{.vendor = 0x1102, .device = 0x0002,\n\t .driver = \"EMU10K1\", .name = \"SB Live! [Unknown]\",\n\t .id = \"Live\",\n\t .emu10k1_chip = 1,\n\t .ac97_chip = 1,\n\t .sblive51 = 1} ,\n\t{ }  \n};\n\n \nstatic void snd_emu10k1_detect_iommu(struct snd_emu10k1 *emu)\n{\n\tstruct iommu_domain *domain;\n\n\temu->iommu_workaround = false;\n\n\tdomain = iommu_get_domain_for_dev(emu->card->dev);\n\tif (!domain || domain->type == IOMMU_DOMAIN_IDENTITY)\n\t\treturn;\n\n\tdev_notice(emu->card->dev,\n\t\t   \"non-passthrough IOMMU detected, widening DMA allocations\");\n\temu->iommu_workaround = true;\n}\n\nint snd_emu10k1_create(struct snd_card *card,\n\t\t       struct pci_dev *pci,\n\t\t       unsigned short extin_mask,\n\t\t       unsigned short extout_mask,\n\t\t       long max_cache_bytes,\n\t\t       int enable_ir,\n\t\t       uint subsystem)\n{\n\tstruct snd_emu10k1 *emu = card->private_data;\n\tint idx, err;\n\tint is_audigy;\n\tsize_t page_table_size;\n\t__le32 *pgtbl;\n\tunsigned int silent_page;\n\tconst struct snd_emu_chip_details *c;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard->private_free = snd_emu10k1_free;\n\temu->card = card;\n\tspin_lock_init(&emu->reg_lock);\n\tspin_lock_init(&emu->emu_lock);\n\tspin_lock_init(&emu->spi_lock);\n\tspin_lock_init(&emu->i2c_lock);\n\tspin_lock_init(&emu->voice_lock);\n\tspin_lock_init(&emu->synth_lock);\n\tspin_lock_init(&emu->memblk_lock);\n\tmutex_init(&emu->fx8010.lock);\n\tINIT_LIST_HEAD(&emu->mapped_link_head);\n\tINIT_LIST_HEAD(&emu->mapped_order_link_head);\n\temu->pci = pci;\n\temu->irq = -1;\n\temu->synth = NULL;\n\temu->get_synth_voice = NULL;\n\tINIT_WORK(&emu->emu1010.firmware_work, emu1010_firmware_work);\n\tINIT_WORK(&emu->emu1010.clock_work, emu1010_clock_work);\n\t \n\temu->revision = pci->revision;\n\tpci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &emu->serial);\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_ID, &emu->model);\n\tdev_dbg(card->dev,\n\t\t\"vendor = 0x%x, device = 0x%x, subsystem_vendor_id = 0x%x, subsystem_id = 0x%x\\n\",\n\t\tpci->vendor, pci->device, emu->serial, emu->model);\n\n\tfor (c = emu_chip_details; c->vendor; c++) {\n\t\tif (c->vendor == pci->vendor && c->device == pci->device) {\n\t\t\tif (subsystem) {\n\t\t\t\tif (c->subsystem && (c->subsystem == subsystem))\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (c->subsystem && (c->subsystem != emu->serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (c->revision && c->revision != emu->revision)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (c->vendor == 0) {\n\t\tdev_err(card->dev, \"emu10k1: Card not recognised\\n\");\n\t\treturn -ENOENT;\n\t}\n\temu->card_capabilities = c;\n\tif (c->subsystem && !subsystem)\n\t\tdev_dbg(card->dev, \"Sound card name = %s\\n\", c->name);\n\telse if (subsystem)\n\t\tdev_dbg(card->dev, \"Sound card name = %s, \"\n\t\t\t\"vendor = 0x%x, device = 0x%x, subsystem = 0x%x. \"\n\t\t\t\"Forced to subsystem = 0x%x\\n\",\tc->name,\n\t\t\tpci->vendor, pci->device, emu->serial, c->subsystem);\n\telse\n\t\tdev_dbg(card->dev, \"Sound card name = %s, \"\n\t\t\t\"vendor = 0x%x, device = 0x%x, subsystem = 0x%x.\\n\",\n\t\t\tc->name, pci->vendor, pci->device,\n\t\t\temu->serial);\n\n\tif (!*card->id && c->id)\n\t\tstrscpy(card->id, c->id, sizeof(card->id));\n\n\tis_audigy = emu->audigy = c->emu10k2_chip;\n\n\tsnd_emu10k1_detect_iommu(emu);\n\n\t \n\temu->address_mode = is_audigy ? 0 : 1;\n\t \n\temu->dma_mask = emu->address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;\n\tif (dma_set_mask_and_coherent(&pci->dev, emu->dma_mask) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support PCI busmaster DMA with mask 0x%lx\\n\",\n\t\t\temu->dma_mask);\n\t\treturn -ENXIO;\n\t}\n\tif (is_audigy)\n\t\temu->gpr_base = A_FXGPREGBASE;\n\telse\n\t\temu->gpr_base = FXGPREGBASE;\n\n\terr = pci_request_regions(pci, \"EMU10K1\");\n\tif (err < 0)\n\t\treturn err;\n\temu->port = pci_resource_start(pci, 0);\n\n\temu->max_cache_pages = max_cache_bytes >> PAGE_SHIFT;\n\n\tpage_table_size = sizeof(u32) * (emu->address_mode ? MAXPAGES1 :\n\t\t\t\t\t MAXPAGES0);\n\tif (snd_emu10k1_alloc_pages_maybe_wider(emu, page_table_size,\n\t\t\t\t\t\t&emu->ptb_pages) < 0)\n\t\treturn -ENOMEM;\n\tdev_dbg(card->dev, \"page table address range is %.8lx:%.8lx\\n\",\n\t\t(unsigned long)emu->ptb_pages.addr,\n\t\t(unsigned long)(emu->ptb_pages.addr + emu->ptb_pages.bytes));\n\n\temu->page_ptr_table = vmalloc(array_size(sizeof(void *),\n\t\t\t\t\t\t emu->max_cache_pages));\n\temu->page_addr_table = vmalloc(array_size(sizeof(unsigned long),\n\t\t\t\t\t\t  emu->max_cache_pages));\n\tif (!emu->page_ptr_table || !emu->page_addr_table)\n\t\treturn -ENOMEM;\n\n\tif (snd_emu10k1_alloc_pages_maybe_wider(emu, EMUPAGESIZE,\n\t\t\t\t\t\t&emu->silent_page) < 0)\n\t\treturn -ENOMEM;\n\tdev_dbg(card->dev, \"silent page range is %.8lx:%.8lx\\n\",\n\t\t(unsigned long)emu->silent_page.addr,\n\t\t(unsigned long)(emu->silent_page.addr +\n\t\t\t\temu->silent_page.bytes));\n\n\temu->memhdr = snd_util_memhdr_new(emu->max_cache_pages * PAGE_SIZE);\n\tif (!emu->memhdr)\n\t\treturn -ENOMEM;\n\temu->memhdr->block_extra_size = sizeof(struct snd_emu10k1_memblk) -\n\t\tsizeof(struct snd_util_memblk);\n\n\tpci_set_master(pci);\n\n\t \n\t \n\tif (extin_mask == 0)\n\t\textin_mask = 0x3fcf;   \n\tif (extout_mask == 0)\n\t\textout_mask = 0x7fff;   \n\temu->fx8010.extin_mask = extin_mask;\n\temu->fx8010.extout_mask = extout_mask;\n\temu->enable_ir = enable_ir;\n\n\tif (emu->card_capabilities->ca_cardbus_chip) {\n\t\terr = snd_emu10k1_cardbus_init(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (emu->card_capabilities->ecard) {\n\t\terr = snd_emu10k1_ecard_init(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (emu->card_capabilities->emu_model) {\n\t\terr = snd_emu10k1_emu1010_init(emu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tsnd_emu10k1_ptr_write(emu, AC97SLOT, 0,\n\t\t\t\t\tAC97SLOT_CNTR|AC97SLOT_LFE);\n\t}\n\n\t \n\temu->fx8010.itram_size = (16 * 1024)/2;\n\temu->fx8010.etram_pages.area = NULL;\n\temu->fx8010.etram_pages.bytes = 0;\n\n\t \n\tif (devm_request_irq(&pci->dev, pci->irq, snd_emu10k1_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, emu))\n\t\treturn -EBUSY;\n\temu->irq = pci->irq;\n\tcard->sync_irq = emu->irq;\n\n\t \n\temu->spdif_bits[0] = emu->spdif_bits[1] =\n\t\temu->spdif_bits[2] = SPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\n\t\tSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\n\t\tSPCS_GENERATIONSTATUS | 0x00001200 |\n\t\t0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT;\n\n\t \n\tmemset(emu->silent_page.area, 0, emu->silent_page.bytes);\n\tsilent_page = emu->silent_page.addr << emu->address_mode;\n\tpgtbl = (__le32 *)emu->ptb_pages.area;\n\tfor (idx = 0; idx < (emu->address_mode ? MAXPAGES1 : MAXPAGES0); idx++)\n\t\tpgtbl[idx] = cpu_to_le32(silent_page | idx);\n\n\t \n\tfor (idx = 0; idx < NUM_G; idx++)\n\t\temu->voices[idx].number = idx;\n\n\terr = snd_emu10k1_init(emu, enable_ir);\n\tif (err < 0)\n\t\treturn err;\n#ifdef CONFIG_PM_SLEEP\n\terr = alloc_pm_buffer(emu);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\t \n\terr = snd_emu10k1_init_efx(emu);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_emu10k1_audio_enable(emu);\n\n#ifdef CONFIG_SND_PROC_FS\n\tsnd_emu10k1_proc_init(emu);\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic const unsigned char saved_regs[] = {\n\tCPF, PTRX, CVCF, VTFT, Z1, Z2, PSST, DSL, CCCA, CCR, CLP,\n\tFXRT, MAPA, MAPB, ENVVOL, ATKHLDV, DCYSUSV, LFOVAL1, ENVVAL,\n\tATKHLDM, DCYSUSM, LFOVAL2, IP, IFATN, PEFE, FMMOD, TREMFRQ, FM2FRQ2,\n\tTEMPENV, ADCCR, FXWC, MICBA, ADCBA, FXBA,\n\tMICBS, ADCBS, FXBS, CDCS, GPSCS, SPCS0, SPCS1, SPCS2,\n\tSPBYPASS, AC97SLOT, CDSRCS, GPSRCS, ZVSRCS, MICIDX, ADCIDX, FXIDX,\n\t0xff  \n};\nstatic const unsigned char saved_regs_audigy[] = {\n\tA_ADCIDX, A_MICIDX, A_FXWC1, A_FXWC2, A_EHC,\n\tA_FXRT2, A_SENDAMOUNTS, A_FXRT1,\n\t0xff  \n};\n\nstatic int alloc_pm_buffer(struct snd_emu10k1 *emu)\n{\n\tint size;\n\n\tsize = ARRAY_SIZE(saved_regs);\n\tif (emu->audigy)\n\t\tsize += ARRAY_SIZE(saved_regs_audigy);\n\temu->saved_ptr = vmalloc(array3_size(4, NUM_G, size));\n\tif (!emu->saved_ptr)\n\t\treturn -ENOMEM;\n\tif (snd_emu10k1_efx_alloc_pm_buffer(emu) < 0)\n\t\treturn -ENOMEM;\n\tif (emu->card_capabilities->ca0151_chip &&\n\t    snd_p16v_alloc_pm_buffer(emu) < 0)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void free_pm_buffer(struct snd_emu10k1 *emu)\n{\n\tvfree(emu->saved_ptr);\n\tsnd_emu10k1_efx_free_pm_buffer(emu);\n\tif (emu->card_capabilities->ca0151_chip)\n\t\tsnd_p16v_free_pm_buffer(emu);\n}\n\nvoid snd_emu10k1_suspend_regs(struct snd_emu10k1 *emu)\n{\n\tint i;\n\tconst unsigned char *reg;\n\tunsigned int *val;\n\n\tval = emu->saved_ptr;\n\tfor (reg = saved_regs; *reg != 0xff; reg++)\n\t\tfor (i = 0; i < NUM_G; i++, val++)\n\t\t\t*val = snd_emu10k1_ptr_read(emu, *reg, i);\n\tif (emu->audigy) {\n\t\tfor (reg = saved_regs_audigy; *reg != 0xff; reg++)\n\t\t\tfor (i = 0; i < NUM_G; i++, val++)\n\t\t\t\t*val = snd_emu10k1_ptr_read(emu, *reg, i);\n\t}\n\tif (emu->audigy)\n\t\temu->saved_a_iocfg = inw(emu->port + A_IOCFG);\n\temu->saved_hcfg = inl(emu->port + HCFG);\n}\n\nvoid snd_emu10k1_resume_init(struct snd_emu10k1 *emu)\n{\n\tif (emu->card_capabilities->ca_cardbus_chip)\n\t\tsnd_emu10k1_cardbus_init(emu);\n\tif (emu->card_capabilities->ecard)\n\t\tsnd_emu10k1_ecard_init(emu);\n\telse if (emu->card_capabilities->emu_model)\n\t\tsnd_emu10k1_emu1010_init(emu);\n\telse\n\t\tsnd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_CNTR|AC97SLOT_LFE);\n\tsnd_emu10k1_init(emu, emu->enable_ir);\n}\n\nvoid snd_emu10k1_resume_regs(struct snd_emu10k1 *emu)\n{\n\tint i;\n\tconst unsigned char *reg;\n\tunsigned int *val;\n\n\tsnd_emu10k1_audio_enable(emu);\n\n\t \n\tif (emu->audigy)\n\t\toutw(emu->saved_a_iocfg, emu->port + A_IOCFG);\n\toutl(emu->saved_hcfg, emu->port + HCFG);\n\n\tval = emu->saved_ptr;\n\tfor (reg = saved_regs; *reg != 0xff; reg++)\n\t\tfor (i = 0; i < NUM_G; i++, val++)\n\t\t\tsnd_emu10k1_ptr_write(emu, *reg, i, *val);\n\tif (emu->audigy) {\n\t\tfor (reg = saved_regs_audigy; *reg != 0xff; reg++)\n\t\t\tfor (i = 0; i < NUM_G; i++, val++)\n\t\t\t\tsnd_emu10k1_ptr_write(emu, *reg, i, *val);\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}