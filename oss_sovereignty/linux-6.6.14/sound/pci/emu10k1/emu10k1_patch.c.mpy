{
  "module_name": "emu10k1_patch.c",
  "hash_id": "05f5ebe30f4ce5e7e84417ce3ae7bec9ac571279d365d302ccc5f642812e838c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/emu10k1_patch.c",
  "human_readable_source": "\n \n \n\n#include \"emu10k1_synth_local.h\"\n\n \n#define BLANK_LOOP_START\t4\n#define BLANK_LOOP_END\t\t8\n#define BLANK_LOOP_SIZE\t\t12\n#define BLANK_HEAD_SIZE\t\t32\n\n \nint\nsnd_emu10k1_sample_new(struct snd_emux *rec, struct snd_sf_sample *sp,\n\t\t       struct snd_util_memhdr *hdr,\n\t\t       const void __user *data, long count)\n{\n\tint offset;\n\tint truesize, size, blocksize;\n\t__maybe_unused int loopsize;\n\tint loopend, sampleend;\n\tunsigned int start_addr;\n\tstruct snd_emu10k1 *emu;\n\n\temu = rec->hw;\n\tif (snd_BUG_ON(!sp || !hdr))\n\t\treturn -EINVAL;\n\n\tif (sp->v.size == 0) {\n\t\tdev_dbg(emu->card->dev,\n\t\t\t\"emu: rom font for sample %d\\n\", sp->v.sample);\n\t\treturn 0;\n\t}\n\n\t \n\tsp->v.end -= sp->v.start;\n\tsp->v.loopstart -= sp->v.start;\n\tsp->v.loopend -= sp->v.start;\n\tsp->v.start = 0;\n\n\t \n\tsampleend = sp->v.end;\n\tif (sampleend > sp->v.size)\n\t\tsampleend = sp->v.size;\n\tloopend = sp->v.loopend;\n\tif (loopend > sampleend)\n\t\tloopend = sampleend;\n\n\t \n\tif (sp->v.loopstart >= sp->v.loopend)\n\t\tswap(sp->v.loopstart, sp->v.loopend);\n\n\t \n\ttruesize = sp->v.size + BLANK_HEAD_SIZE;\n\tloopsize = 0;\n#if 0  \n\tif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP))\n\t\tloopsize = sp->v.loopend - sp->v.loopstart;\n\ttruesize += loopsize;\n#endif\n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK)\n\t\ttruesize += BLANK_LOOP_SIZE;\n\n\t \n\tblocksize = truesize;\n\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\n\t\tblocksize *= 2;\n\tsp->block = snd_emu10k1_synth_alloc(emu, blocksize);\n\tif (sp->block == NULL) {\n\t\tdev_dbg(emu->card->dev,\n\t\t\t\"synth malloc failed (size=%d)\\n\", blocksize);\n\t\t \n\t\treturn -ENOSPC;\n\t}\n\t \n\tsp->v.truesize = blocksize;\n\n\t \n\toffset = 0;\n\tsize = BLANK_HEAD_SIZE;\n\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\n\t\tsize *= 2;\n\tif (offset + size > blocksize)\n\t\treturn -EINVAL;\n\tsnd_emu10k1_synth_bzero(emu, sp->block, offset, size);\n\toffset += size;\n\n\t \n\tsize = loopend;\n\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\n\t\tsize *= 2;\n\tif (offset + size > blocksize)\n\t\treturn -EINVAL;\n\tif (snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, data, size)) {\n\t\tsnd_emu10k1_synth_free(emu, sp->block);\n\t\tsp->block = NULL;\n\t\treturn -EFAULT;\n\t}\n\toffset += size;\n\tdata += size;\n\n#if 0  \n\t \n\tif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP)) {\n\t\t \n\t\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS)) {\n\t\t\tint woffset;\n\t\t\tunsigned short *wblock = (unsigned short*)block;\n\t\t\twoffset = offset / 2;\n\t\t\tif (offset + loopsize * 2 > blocksize)\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < loopsize; i++)\n\t\t\t\twblock[woffset + i] = wblock[woffset - i -1];\n\t\t\toffset += loopsize * 2;\n\t\t} else {\n\t\t\tif (offset + loopsize > blocksize)\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < loopsize; i++)\n\t\t\t\tblock[offset + i] = block[offset - i -1];\n\t\t\toffset += loopsize;\n\t\t}\n\n\t\t \n\t\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_BIDIR_LOOP) {\n\t\t\tsp->v.loopend += loopsize;\n\t\t} else {\n\t\t\tsp->v.loopstart += loopsize;\n\t\t\tsp->v.loopend += loopsize;\n\t\t}\n\t\t \n\t\tsp->v.end += loopsize;\n\t}\n#endif\n\n\t \n\tsize = sp->v.size - loopend;\n\tif (size < 0)\n\t\treturn -EINVAL;\n\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\n\t\tsize *= 2;\n\tif (snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, data, size)) {\n\t\tsnd_emu10k1_synth_free(emu, sp->block);\n\t\tsp->block = NULL;\n\t\treturn -EFAULT;\n\t}\n\toffset += size;\n\n\t \n\tif (offset < blocksize)\n\t\tsnd_emu10k1_synth_bzero(emu, sp->block, offset, blocksize - offset);\n\n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK) {\n\t\t \n\t\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT) {\n\t\t\tsp->v.loopstart = sp->v.end + BLANK_LOOP_START;\n\t\t\tsp->v.loopend = sp->v.end + BLANK_LOOP_END;\n\t\t}\n\t}\n\n#if 0  \n\tif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_UNSIGNED) {\n\t\t \n\t\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS)) {\n\t\t\tunsigned short *wblock = (unsigned short*)block;\n\t\t\tfor (i = 0; i < truesize; i++)\n\t\t\t\twblock[i] ^= 0x8000;\n\t\t} else {\n\t\t\tfor (i = 0; i < truesize; i++)\n\t\t\t\tblock[i] ^= 0x80;\n\t\t}\n\t}\n#endif\n\n\t \n\tstart_addr = BLANK_HEAD_SIZE * 2;\n\tif (! (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS))\n\t\tstart_addr >>= 1;\n\tsp->v.start += start_addr;\n\tsp->v.end += start_addr;\n\tsp->v.loopstart += start_addr;\n\tsp->v.loopend += start_addr;\n\n\treturn 0;\n}\n\n \nint\nsnd_emu10k1_sample_free(struct snd_emux *rec, struct snd_sf_sample *sp,\n\t\t\tstruct snd_util_memhdr *hdr)\n{\n\tstruct snd_emu10k1 *emu;\n\n\temu = rec->hw;\n\tif (snd_BUG_ON(!sp || !hdr))\n\t\treturn -EINVAL;\n\n\tif (sp->block) {\n\t\tsnd_emu10k1_synth_free(emu, sp->block);\n\t\tsp->block = NULL;\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}