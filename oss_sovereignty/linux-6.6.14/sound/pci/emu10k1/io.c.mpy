{
  "module_name": "io.c",
  "hash_id": "25177fceda7d24a6a0df19e191442820891bb02b1a8126cce7689933bce29a7e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/emu10k1/io.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/emu10k1.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include \"p17v.h\"\n\nstatic inline bool check_ptr_reg(struct snd_emu10k1 *emu, unsigned int reg)\n{\n\tif (snd_BUG_ON(!emu))\n\t\treturn false;\n\tif (snd_BUG_ON(reg & (emu->audigy ? (0xffff0000 & ~A_PTR_ADDRESS_MASK)\n\t\t\t\t\t  : (0xffff0000 & ~PTR_ADDRESS_MASK))))\n\t\treturn false;\n\tif (snd_BUG_ON(reg & 0x0000ffff & ~PTR_CHANNELNUM_MASK))\n\t\treturn false;\n\treturn true;\n}\n\nunsigned int snd_emu10k1_ptr_read(struct snd_emu10k1 * emu, unsigned int reg, unsigned int chn)\n{\n\tunsigned long flags;\n\tunsigned int regptr, val;\n\tunsigned int mask;\n\n\tregptr = (reg << 16) | chn;\n\tif (!check_ptr_reg(emu, regptr))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + PTR);\n\tval = inl(emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\n\tif (reg & 0xff000000) {\n\t\tunsigned char size, offset;\n\t\t\n\t\tsize = (reg >> 24) & 0x3f;\n\t\toffset = (reg >> 16) & 0x1f;\n\t\tmask = (1 << size) - 1;\n\t\t\n\t\treturn (val >> offset) & mask;\n\t} else {\n\t\treturn val;\n\t}\n}\n\nEXPORT_SYMBOL(snd_emu10k1_ptr_read);\n\nvoid snd_emu10k1_ptr_write(struct snd_emu10k1 *emu, unsigned int reg, unsigned int chn, unsigned int data)\n{\n\tunsigned int regptr;\n\tunsigned long flags;\n\tunsigned int mask;\n\n\tregptr = (reg << 16) | chn;\n\tif (!check_ptr_reg(emu, regptr))\n\t\treturn;\n\n\tif (reg & 0xff000000) {\n\t\tunsigned char size, offset;\n\n\t\tsize = (reg >> 24) & 0x3f;\n\t\toffset = (reg >> 16) & 0x1f;\n\t\tmask = (1 << size) - 1;\n\t\tif (snd_BUG_ON(data & ~mask))\n\t\t\treturn;\n\t\tmask <<= offset;\n\t\tdata <<= offset;\n\n\t\tspin_lock_irqsave(&emu->emu_lock, flags);\n\t\toutl(regptr, emu->port + PTR);\n\t\tdata |= inl(emu->port + DATA) & ~mask;\n\t} else {\n\t\tspin_lock_irqsave(&emu->emu_lock, flags);\n\t\toutl(regptr, emu->port + PTR);\n\t}\n\toutl(data, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_emu10k1_ptr_write);\n\nvoid snd_emu10k1_ptr_write_multiple(struct snd_emu10k1 *emu, unsigned int chn, ...)\n{\n\tva_list va;\n\tu32 addr_mask;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!emu))\n\t\treturn;\n\tif (snd_BUG_ON(chn & ~PTR_CHANNELNUM_MASK))\n\t\treturn;\n\taddr_mask = ~((emu->audigy ? A_PTR_ADDRESS_MASK : PTR_ADDRESS_MASK) >> 16);\n\n\tva_start(va, chn);\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tfor (;;) {\n\t\tu32 data;\n\t\tu32 reg = va_arg(va, u32);\n\t\tif (reg == REGLIST_END)\n\t\t\tbreak;\n\t\tdata = va_arg(va, u32);\n\t\tif (snd_BUG_ON(reg & addr_mask))  \n\t\t\tcontinue;\n\t\toutl((reg << 16) | chn, emu->port + PTR);\n\t\toutl(data, emu->port + DATA);\n\t}\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\tva_end(va);\n}\n\nEXPORT_SYMBOL(snd_emu10k1_ptr_write_multiple);\n\nunsigned int snd_emu10k1_ptr20_read(struct snd_emu10k1 * emu, \n\t\t\t\t\t  unsigned int reg, \n\t\t\t\t\t  unsigned int chn)\n{\n\tunsigned long flags;\n\tunsigned int regptr, val;\n  \n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + PTR2);\n\tval = inl(emu->port + DATA2);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nvoid snd_emu10k1_ptr20_write(struct snd_emu10k1 *emu, \n\t\t\t\t   unsigned int reg, \n\t\t\t\t   unsigned int chn, \n\t\t\t\t   unsigned int data)\n{\n\tunsigned int regptr;\n\tunsigned long flags;\n\n\tregptr = (reg << 16) | chn;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(regptr, emu->port + PTR2);\n\toutl(data, emu->port + DATA2);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nint snd_emu10k1_spi_write(struct snd_emu10k1 * emu,\n\t\t\t\t   unsigned int data)\n{\n\tunsigned int reset, set;\n\tunsigned int reg, tmp;\n\tint n, result;\n\tint err = 0;\n\n\t \n\tspin_lock(&emu->spi_lock);\n\tif (emu->card_capabilities->ca0108_chip)\n\t\treg = P17V_SPI;\n\telse {\n\t\t \n\t\terr = 1;\n\t\tgoto spi_write_exit;\n\t}\n\tif (data > 0xffff) {\n\t\t \n\t\terr = 1;\n\t\tgoto spi_write_exit;\n\t}\n\n\ttmp = snd_emu10k1_ptr20_read(emu, reg, 0);\n\treset = (tmp & ~0x3ffff) | 0x20000;  \n\tset = reset | 0x10000;  \n\tsnd_emu10k1_ptr20_write(emu, reg, 0, reset | data);\n\ttmp = snd_emu10k1_ptr20_read(emu, reg, 0);  \n\tsnd_emu10k1_ptr20_write(emu, reg, 0, set | data);\n\tresult = 1;\n\t \n\tfor (n = 0; n < 100; n++) {\n\t\tudelay(10);\n\t\ttmp = snd_emu10k1_ptr20_read(emu, reg, 0);\n\t\tif (!(tmp & 0x10000)) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result) {\n\t\t \n\t\terr = 1;\n\t\tgoto spi_write_exit;\n\t}\n\tsnd_emu10k1_ptr20_write(emu, reg, 0, reset | data);\n\ttmp = snd_emu10k1_ptr20_read(emu, reg, 0);  \n\terr = 0;\nspi_write_exit:\n\tspin_unlock(&emu->spi_lock);\n\treturn err;\n}\n\n \nint snd_emu10k1_i2c_write(struct snd_emu10k1 *emu,\n\t\t\t\tu32 reg,\n\t\t\t\tu32 value)\n{\n\tu32 tmp;\n\tint timeout = 0;\n\tint status;\n\tint retry;\n\tint err = 0;\n\n\tif ((reg > 0x7f) || (value > 0x1ff)) {\n\t\tdev_err(emu->card->dev, \"i2c_write: invalid values.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock(&emu->i2c_lock);\n\n\ttmp = reg << 25 | value << 16;\n\n\t \n\tsnd_emu10k1_ptr20_write(emu, P17V_I2C_1, 0, tmp);\n\ttmp = snd_emu10k1_ptr20_read(emu, P17V_I2C_1, 0);  \n\n\tfor (retry = 0; retry < 10; retry++) {\n\t\t \n\t\ttmp = 0;\n\t\ttmp = tmp | (I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD);\n\t\tsnd_emu10k1_ptr20_write(emu, P17V_I2C_ADDR, 0, tmp);\n\n\t\t \n\t\twhile (1) {\n\t\t\tmdelay(1);\n\t\t\tstatus = snd_emu10k1_ptr20_read(emu, P17V_I2C_ADDR, 0);\n\t\t\ttimeout++;\n\t\t\tif ((status & I2C_A_ADC_START) == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (timeout > 1000) {\n\t\t\t\tdev_warn(emu->card->dev,\n\t\t\t\t\t   \"emu10k1:I2C:timeout status=0x%x\\n\",\n\t\t\t\t\t   status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ((status & I2C_A_ADC_ABORT) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (retry == 10) {\n\t\tdev_err(emu->card->dev, \"Writing to ADC failed!\\n\");\n\t\tdev_err(emu->card->dev, \"status=0x%x, reg=%d, value=%d\\n\",\n\t\t\tstatus, reg, value);\n\t\t \n\t\terr = -EINVAL;\n\t}\n    \n\tspin_unlock(&emu->i2c_lock);\n\treturn err;\n}\n\nstatic void snd_emu1010_fpga_write_locked(struct snd_emu10k1 *emu, u32 reg, u32 value)\n{\n\tif (snd_BUG_ON(reg > 0x3f))\n\t\treturn;\n\treg += 0x40;  \n\tif (snd_BUG_ON(value > 0x3f))  \n\t\treturn;\n\toutw(reg, emu->port + A_GPIO);\n\tudelay(10);\n\toutw(reg | 0x80, emu->port + A_GPIO);   \n\tudelay(10);\n\toutw(value, emu->port + A_GPIO);\n\tudelay(10);\n\toutw(value | 0x80 , emu->port + A_GPIO);   \n}\n\nvoid snd_emu1010_fpga_write(struct snd_emu10k1 *emu, u32 reg, u32 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tsnd_emu1010_fpga_write_locked(emu, reg, value);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nstatic void snd_emu1010_fpga_read_locked(struct snd_emu10k1 *emu, u32 reg, u32 *value)\n{\n\t\n\t\n\t\n\t\n\tu32 mask = emu->card_capabilities->ca0108_chip ? 0x1f : 0x7f;\n\tif (snd_BUG_ON(reg > 0x3f))\n\t\treturn;\n\treg += 0x40;  \n\toutw(reg, emu->port + A_GPIO);\n\tudelay(10);\n\toutw(reg | 0x80, emu->port + A_GPIO);   \n\tudelay(10);\n\t*value = ((inw(emu->port + A_GPIO) >> 8) & mask);\n}\n\nvoid snd_emu1010_fpga_read(struct snd_emu10k1 *emu, u32 reg, u32 *value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tsnd_emu1010_fpga_read_locked(emu, reg, value);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\n \nvoid snd_emu1010_fpga_link_dst_src_write(struct snd_emu10k1 *emu, u32 dst, u32 src)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(dst & ~0x71f))\n\t\treturn;\n\tif (snd_BUG_ON(src & ~0x71f))\n\t\treturn;\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_DESTHI, dst >> 8);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_DESTLO, dst & 0x1f);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_SRCHI, src >> 8);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_SRCLO, src & 0x1f);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nu32 snd_emu1010_fpga_link_dst_src_read(struct snd_emu10k1 *emu, u32 dst)\n{\n\tunsigned long flags;\n\tu32 hi, lo;\n\n\tif (snd_BUG_ON(dst & ~0x71f))\n\t\treturn 0;\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_DESTHI, dst >> 8);\n\tsnd_emu1010_fpga_write_locked(emu, EMU_HANA_DESTLO, dst & 0x1f);\n\tsnd_emu1010_fpga_read_locked(emu, EMU_HANA_SRCHI, &hi);\n\tsnd_emu1010_fpga_read_locked(emu, EMU_HANA_SRCLO, &lo);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn (hi << 8) | lo;\n}\n\nint snd_emu1010_get_raw_rate(struct snd_emu10k1 *emu, u8 src)\n{\n\tu32 reg_lo, reg_hi, value, value2;\n\n\tswitch (src) {\n\tcase EMU_HANA_WCLOCK_HANA_SPDIF_IN:\n\t\tsnd_emu1010_fpga_read(emu, EMU_HANA_SPDIF_MODE, &value);\n\t\tif (value & EMU_HANA_SPDIF_MODE_RX_INVALID)\n\t\t\treturn 0;\n\t\treg_lo = EMU_HANA_WC_SPDIF_LO;\n\t\treg_hi = EMU_HANA_WC_SPDIF_HI;\n\t\tbreak;\n\tcase EMU_HANA_WCLOCK_HANA_ADAT_IN:\n\t\treg_lo = EMU_HANA_WC_ADAT_LO;\n\t\treg_hi = EMU_HANA_WC_ADAT_HI;\n\t\tbreak;\n\tcase EMU_HANA_WCLOCK_SYNC_BNC:\n\t\treg_lo = EMU_HANA_WC_BNC_LO;\n\t\treg_hi = EMU_HANA_WC_BNC_HI;\n\t\tbreak;\n\tcase EMU_HANA_WCLOCK_2ND_HANA:\n\t\treg_lo = EMU_HANA2_WC_SPDIF_LO;\n\t\treg_hi = EMU_HANA2_WC_SPDIF_HI;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tsnd_emu1010_fpga_read(emu, reg_hi, &value);\n\tsnd_emu1010_fpga_read(emu, reg_lo, &value2);\n\t\n\treturn 0x1770000 / 4 / (((value << 5) | value2) + 1);\n}\n\nvoid snd_emu1010_update_clock(struct snd_emu10k1 *emu)\n{\n\tint clock;\n\tu32 leds;\n\n\tswitch (emu->emu1010.wclock) {\n\tcase EMU_HANA_WCLOCK_INT_44_1K | EMU_HANA_WCLOCK_1X:\n\t\tclock = 44100;\n\t\tleds = EMU_HANA_DOCK_LEDS_2_44K;\n\t\tbreak;\n\tcase EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_1X:\n\t\tclock = 48000;\n\t\tleds = EMU_HANA_DOCK_LEDS_2_48K;\n\t\tbreak;\n\tdefault:\n\t\tclock = snd_emu1010_get_raw_rate(\n\t\t\t\temu, emu->emu1010.wclock & EMU_HANA_WCLOCK_SRC_MASK);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (clock < 46000) {\n\t\t\tclock = 44100;\n\t\t\tleds = EMU_HANA_DOCK_LEDS_2_EXT | EMU_HANA_DOCK_LEDS_2_44K;\n\t\t} else {\n\t\t\tclock = 48000;\n\t\t\tleds = EMU_HANA_DOCK_LEDS_2_EXT | EMU_HANA_DOCK_LEDS_2_48K;\n\t\t}\n\t\tbreak;\n\t}\n\temu->emu1010.word_clock = clock;\n\n\t\n\t\n\tleds |= EMU_HANA_DOCK_LEDS_2_LOCK;\n\n\tsnd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2, leds);\n}\n\nvoid snd_emu10k1_intr_enable(struct snd_emu10k1 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tenable = inl(emu->port + INTE) | intrenb;\n\toutl(enable, emu->port + INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_intr_disable(struct snd_emu10k1 *emu, unsigned int intrenb)\n{\n\tunsigned long flags;\n\tunsigned int enable;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tenable = inl(emu->port + INTE) & ~intrenb;\n\toutl(enable, emu->port + INTE);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_intr_enable(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(CLIEH << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval |= 1 << (voicenum - 32);\n\t} else {\n\t\toutl(CLIEL << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval |= 1 << voicenum;\n\t}\n\toutl(val, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_intr_disable(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(CLIEH << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval &= ~(1 << (voicenum - 32));\n\t} else {\n\t\toutl(CLIEL << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval &= ~(1 << voicenum);\n\t}\n\toutl(val, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_intr_ack(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(CLIPH << 16, emu->port + PTR);\n\t\tvoicenum = 1 << (voicenum - 32);\n\t} else {\n\t\toutl(CLIPL << 16, emu->port + PTR);\n\t\tvoicenum = 1 << voicenum;\n\t}\n\toutl(voicenum, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_half_loop_intr_enable(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(HLIEH << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval |= 1 << (voicenum - 32);\n\t} else {\n\t\toutl(HLIEL << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval |= 1 << voicenum;\n\t}\n\toutl(val, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_half_loop_intr_disable(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(HLIEH << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval &= ~(1 << (voicenum - 32));\n\t} else {\n\t\toutl(HLIEL << 16, emu->port + PTR);\n\t\tval = inl(emu->port + DATA);\n\t\tval &= ~(1 << voicenum);\n\t}\n\toutl(val, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_half_loop_intr_ack(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(HLIPH << 16, emu->port + PTR);\n\t\tvoicenum = 1 << (voicenum - 32);\n\t} else {\n\t\toutl(HLIPL << 16, emu->port + PTR);\n\t\tvoicenum = 1 << voicenum;\n\t}\n\toutl(voicenum, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\n#if 0\nvoid snd_emu10k1_voice_set_loop_stop(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int sol;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(SOLEH << 16, emu->port + PTR);\n\t\tsol = inl(emu->port + DATA);\n\t\tsol |= 1 << (voicenum - 32);\n\t} else {\n\t\toutl(SOLEL << 16, emu->port + PTR);\n\t\tsol = inl(emu->port + DATA);\n\t\tsol |= 1 << voicenum;\n\t}\n\toutl(sol, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_clear_loop_stop(struct snd_emu10k1 *emu, unsigned int voicenum)\n{\n\tunsigned long flags;\n\tunsigned int sol;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\tif (voicenum >= 32) {\n\t\toutl(SOLEH << 16, emu->port + PTR);\n\t\tsol = inl(emu->port + DATA);\n\t\tsol &= ~(1 << (voicenum - 32));\n\t} else {\n\t\toutl(SOLEL << 16, emu->port + PTR);\n\t\tsol = inl(emu->port + DATA);\n\t\tsol &= ~(1 << voicenum);\n\t}\n\toutl(sol, emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n#endif\n\nvoid snd_emu10k1_voice_set_loop_stop_multiple(struct snd_emu10k1 *emu, u64 voices)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(SOLEL << 16, emu->port + PTR);\n\toutl(inl(emu->port + DATA) | (u32)voices, emu->port + DATA);\n\toutl(SOLEH << 16, emu->port + PTR);\n\toutl(inl(emu->port + DATA) | (u32)(voices >> 32), emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nvoid snd_emu10k1_voice_clear_loop_stop_multiple(struct snd_emu10k1 *emu, u64 voices)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutl(SOLEL << 16, emu->port + PTR);\n\toutl(inl(emu->port + DATA) & (u32)~voices, emu->port + DATA);\n\toutl(SOLEH << 16, emu->port + PTR);\n\toutl(inl(emu->port + DATA) & (u32)(~voices >> 32), emu->port + DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n\nint snd_emu10k1_voice_clear_loop_stop_multiple_atomic(struct snd_emu10k1 *emu, u64 voices)\n{\n\tunsigned long flags;\n\tu32 soll, solh;\n\tint ret = -EIO;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\n\toutl(SOLEL << 16, emu->port + PTR);\n\tsoll = inl(emu->port + DATA);\n\toutl(SOLEH << 16, emu->port + PTR);\n\tsolh = inl(emu->port + DATA);\n\n\tsoll &= (u32)~voices;\n\tsolh &= (u32)(~voices >> 32);\n\n\tfor (int tries = 0; tries < 1000; tries++) {\n\t\tconst u32 quart = 1U << (REG_SIZE(WC_CURRENTCHANNEL) - 2);\n\t\t\n\t\tu32 wc = inl(emu->port + WC);\n\t\tu32 cc = REG_VAL_GET(WC_CURRENTCHANNEL, wc);\n\t\tif (cc >= quart * 2 && cc < quart * 3) {\n\t\t\t\n\t\t\toutl(SOLEL << 16, emu->port + PTR);\n\t\t\toutl(soll, emu->port + DATA);\n\t\t\t\n\t\t\tfor (; tries < 1000; tries++) {\n\t\t\t\tcc = REG_VAL_GET(WC_CURRENTCHANNEL, inl(emu->port + WC));\n\t\t\t\tif (cc < quart)\n\t\t\t\t\tgoto good;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tgood:\n\t\t\t\n\t\t\toutl(SOLEH << 16, emu->port + PTR);\n\t\t\toutl(solh, emu->port + DATA);\n\t\t\t\n\t\t\tif (REG_VAL_GET(WC_SAMPLECOUNTER, inl(emu->port + WC)) ==\n\t\t\t    ((REG_VAL_GET(WC_SAMPLECOUNTER, wc) + 1) & REG_MASK0(WC_SAMPLECOUNTER))) {\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\t\tudelay(1);\n\t\tspin_lock_irqsave(&emu->emu_lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn ret;\n}\n\nvoid snd_emu10k1_wait(struct snd_emu10k1 *emu, unsigned int wait)\n{\n\tvolatile unsigned count;\n\tunsigned int newtime = 0, curtime;\n\n\tcurtime = inl(emu->port + WC) >> 6;\n\twhile (wait-- > 0) {\n\t\tcount = 0;\n\t\twhile (count++ < 16384) {\n\t\t\tnewtime = inl(emu->port + WC) >> 6;\n\t\t\tif (newtime != curtime)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 16384)\n\t\t\tbreak;\n\t\tcurtime = newtime;\n\t}\n}\n\nunsigned short snd_emu10k1_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct snd_emu10k1 *emu = ac97->private_data;\n\tunsigned long flags;\n\tunsigned short val;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + AC97ADDRESS);\n\tval = inw(emu->port + AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n\treturn val;\n}\n\nvoid snd_emu10k1_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short data)\n{\n\tstruct snd_emu10k1 *emu = ac97->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&emu->emu_lock, flags);\n\toutb(reg, emu->port + AC97ADDRESS);\n\toutw(data, emu->port + AC97DATA);\n\tspin_unlock_irqrestore(&emu->emu_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}