{
  "module_name": "lola_pcm.c",
  "hash_id": "4bdb5130f2ddee3d0f2bb98b01bb724b7569a65c9bdec31f8efdad1f59d9541d",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lola/lola_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"lola.h\"\n\n#define LOLA_MAX_BDL_ENTRIES\t8\n#define LOLA_MAX_BUF_SIZE\t(1024*1024*1024)\n#define LOLA_BDL_ENTRY_SIZE\t(16 * 16)\n\nstatic struct lola_pcm *lola_get_pcm(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\treturn &chip->pcm[substream->stream];\n}\n\nstatic struct lola_stream *lola_get_stream(struct snd_pcm_substream *substream)\n{\n\tstruct lola_pcm *pcm = lola_get_pcm(substream);\n\tunsigned int idx = substream->number;\n\treturn &pcm->streams[idx];\n}\n\nstatic unsigned int lola_get_lrc(struct lola *chip)\n{\n\treturn lola_readl(chip, BAR1, LRC);\n}\n\nstatic unsigned int lola_get_tstamp(struct lola *chip, bool quick_no_sync)\n{\n\tunsigned int tstamp = lola_get_lrc(chip) >> 8;\n\tif (chip->granularity) {\n\t\tunsigned int wait_banks = quick_no_sync ? 0 : 8;\n\t\ttstamp += (wait_banks + 1) * chip->granularity - 1;\n\t\ttstamp -= tstamp % chip->granularity;\n\t}\n\treturn tstamp << 8;\n}\n\n \nstatic void lola_stream_clear_pending_irq(struct lola *chip,\n\t\t\t\t\t  struct lola_stream *str)\n{\n\tunsigned int val = lola_dsd_read(chip, str->dsd, STS);\n\tval &= LOLA_DSD_STS_DESE | LOLA_DSD_STS_BCIS;\n\tif (val)\n\t\tlola_dsd_write(chip, str->dsd, STS, val);\n}\n\nstatic void lola_stream_start(struct lola *chip, struct lola_stream *str,\n\t\t\t      unsigned int tstamp)\n{\n\tlola_stream_clear_pending_irq(chip, str);\n\tlola_dsd_write(chip, str->dsd, CTL,\n\t\t       LOLA_DSD_CTL_SRUN |\n\t\t       LOLA_DSD_CTL_IOCE |\n\t\t       LOLA_DSD_CTL_DEIE |\n\t\t       LOLA_DSD_CTL_VLRCV |\n\t\t       tstamp);\n}\n\nstatic void lola_stream_stop(struct lola *chip, struct lola_stream *str,\n\t\t\t     unsigned int tstamp)\n{\n\tlola_dsd_write(chip, str->dsd, CTL,\n\t\t       LOLA_DSD_CTL_IOCE |\n\t\t       LOLA_DSD_CTL_DEIE |\n\t\t       LOLA_DSD_CTL_VLRCV |\n\t\t       tstamp);\n\tlola_stream_clear_pending_irq(chip, str);\n}\n\nstatic void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)\n{\n\tunsigned long end_time = jiffies + msecs_to_jiffies(200);\n\twhile (time_before(jiffies, end_time)) {\n\t\tunsigned int val;\n\t\tval = lola_dsd_read(chip, str->dsd, CTL);\n\t\tif (!(val & LOLA_DSD_CTL_SRST))\n\t\t\treturn;\n\t\tmsleep(1);\n\t}\n\tdev_warn(chip->card->dev, \"SRST not clear (stream %d)\\n\", str->dsd);\n}\n\nstatic int lola_stream_wait_for_fifo(struct lola *chip,\n\t\t\t\t     struct lola_stream *str,\n\t\t\t\t     bool ready)\n{\n\tunsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;\n\tunsigned long end_time = jiffies + msecs_to_jiffies(200);\n\twhile (time_before(jiffies, end_time)) {\n\t\tunsigned int reg = lola_dsd_read(chip, str->dsd, STS);\n\t\tif ((reg & LOLA_DSD_STS_FIFORDY) == val)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\tdev_warn(chip->card->dev, \"FIFO not ready (stream %d)\\n\", str->dsd);\n\treturn -EIO;\n}\n\n \nstatic int lola_sync_wait_for_fifo(struct lola *chip,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   bool ready)\n{\n\tunsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;\n\tunsigned long end_time = jiffies + msecs_to_jiffies(200);\n\tstruct snd_pcm_substream *s;\n\tint pending = 0;\n\n\twhile (time_before(jiffies, end_time)) {\n\t\tpending = 0;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tstruct lola_stream *str;\n\t\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\t\tcontinue;\n\t\t\tstr = lola_get_stream(s);\n\t\t\tif (str->prepared && str->paused) {\n\t\t\t\tunsigned int reg;\n\t\t\t\treg = lola_dsd_read(chip, str->dsd, STS);\n\t\t\t\tif ((reg & LOLA_DSD_STS_FIFORDY) != val) {\n\t\t\t\t\tpending = str->dsd + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ready)\n\t\t\t\t\tstr->paused = 0;\n\t\t\t}\n\t\t}\n\t\tif (!pending)\n\t\t\treturn 0;\n\t\tmsleep(1);\n\t}\n\tdev_warn(chip->card->dev, \"FIFO not ready (pending %d)\\n\", pending - 1);\n\treturn -EIO;\n}\n\n \nstatic void lola_sync_pause(struct lola *chip,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_substream *s;\n\n\tlola_sync_wait_for_fifo(chip, substream, false);\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tstruct lola_stream *str;\n\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\tcontinue;\n\t\tstr = lola_get_stream(s);\n\t\tif (str->paused && str->prepared)\n\t\t\tlola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRUN |\n\t\t\t\t       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);\n\t}\n\tlola_sync_wait_for_fifo(chip, substream, true);\n}\n\nstatic void lola_stream_reset(struct lola *chip, struct lola_stream *str)\n{\n\tif (str->prepared) {\n\t\tif (str->paused)\n\t\t\tlola_sync_pause(chip, str->substream);\n\t\tstr->prepared = 0;\n\t\tlola_dsd_write(chip, str->dsd, CTL,\n\t\t\t       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);\n\t\tlola_stream_wait_for_fifo(chip, str, false);\n\t\tlola_stream_clear_pending_irq(chip, str);\n\t\tlola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);\n\t\tlola_dsd_write(chip, str->dsd, LVI, 0);\n\t\tlola_dsd_write(chip, str->dsd, BDPU, 0);\n\t\tlola_dsd_write(chip, str->dsd, BDPL, 0);\n\t\twait_for_srst_clear(chip, str);\n\t}\n}\n\nstatic const struct snd_pcm_hardware lola_pcm_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_FLOAT_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_8000_192000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\tLOLA_MAX_BUF_SIZE,\n\t.period_bytes_min =\t128,\n\t.period_bytes_max =\tLOLA_MAX_BUF_SIZE / 2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tLOLA_MAX_BDL_ENTRIES,\n\t.fifo_size =\t\t0,\n};\n\nstatic int lola_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_pcm *pcm = lola_get_pcm(substream);\n\tstruct lola_stream *str = lola_get_stream(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tmutex_lock(&chip->open_mutex);\n\tif (str->opened) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn -EBUSY;\n\t}\n\tstr->substream = substream;\n\tstr->master = NULL;\n\tstr->opened = 1;\n\truntime->hw = lola_pcm_hw;\n\truntime->hw.channels_max = pcm->num_streams - str->index;\n\tif (chip->sample_rate) {\n\t\t \n\t\truntime->hw.rate_min = chip->sample_rate;\n\t\truntime->hw.rate_max = chip->sample_rate;\n\t} else {\n\t\truntime->hw.rate_min = chip->sample_rate_min;\n\t\truntime->hw.rate_max = chip->sample_rate_max;\n\t}\n\tchip->ref_count_rate++;\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\t \n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t   chip->granularity);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t   chip->granularity);\n\tmutex_unlock(&chip->open_mutex);\n\treturn 0;\n}\n\nstatic void lola_cleanup_slave_streams(struct lola_pcm *pcm,\n\t\t\t\t       struct lola_stream *str)\n{\n\tint i;\n\tfor (i = str->index + 1; i < pcm->num_streams; i++) {\n\t\tstruct lola_stream *s = &pcm->streams[i];\n\t\tif (s->master != str)\n\t\t\tbreak;\n\t\ts->master = NULL;\n\t\ts->opened = 0;\n\t}\n}\n\nstatic int lola_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_stream *str = lola_get_stream(substream);\n\n\tmutex_lock(&chip->open_mutex);\n\tif (str->substream == substream) {\n\t\tstr->substream = NULL;\n\t\tstr->opened = 0;\n\t}\n\tif (--chip->ref_count_rate == 0) {\n\t\t \n\t\tchip->sample_rate = 0;\n\t}\n\tmutex_unlock(&chip->open_mutex);\n\treturn 0;\n}\n\nstatic int lola_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct lola_stream *str = lola_get_stream(substream);\n\n\tstr->bufsize = 0;\n\tstr->period_bytes = 0;\n\tstr->format_verb = 0;\n\treturn 0;\n}\n\nstatic int lola_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_pcm *pcm = lola_get_pcm(substream);\n\tstruct lola_stream *str = lola_get_stream(substream);\n\n\tmutex_lock(&chip->open_mutex);\n\tlola_stream_reset(chip, str);\n\tlola_cleanup_slave_streams(pcm, str);\n\tmutex_unlock(&chip->open_mutex);\n\treturn 0;\n}\n\n \nstatic int setup_bdle(struct snd_pcm_substream *substream,\n\t\t      struct lola_stream *str, __le32 **bdlp,\n\t\t      int ofs, int size)\n{\n\t__le32 *bdl = *bdlp;\n\n\twhile (size > 0) {\n\t\tdma_addr_t addr;\n\t\tint chunk;\n\n\t\tif (str->frags >= LOLA_MAX_BDL_ENTRIES)\n\t\t\treturn -EINVAL;\n\n\t\taddr = snd_pcm_sgbuf_get_addr(substream, ofs);\n\t\t \n\t\tbdl[0] = cpu_to_le32((u32)addr);\n\t\tbdl[1] = cpu_to_le32(upper_32_bits(addr));\n\t\t \n\t\tchunk = snd_pcm_sgbuf_get_chunk_size(substream, ofs, size);\n\t\tbdl[2] = cpu_to_le32(chunk);\n\t\t \n\t\tsize -= chunk;\n\t\tbdl[3] = size ? 0 : cpu_to_le32(0x01);\n\t\tbdl += 4;\n\t\tstr->frags++;\n\t\tofs += chunk;\n\t}\n\t*bdlp = bdl;\n\treturn ofs;\n}\n\n \nstatic int lola_setup_periods(struct lola *chip, struct lola_pcm *pcm,\n\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t      struct lola_stream *str)\n{\n\t__le32 *bdl;\n\tint i, ofs, periods, period_bytes;\n\n\tperiod_bytes = str->period_bytes;\n\tperiods = str->bufsize / period_bytes;\n\n\t \n\tbdl = (__le32 *)(pcm->bdl->area + LOLA_BDL_ENTRY_SIZE * str->index);\n\tofs = 0;\n\tstr->frags = 0;\n\tfor (i = 0; i < periods; i++) {\n\t\tofs = setup_bdle(substream, str, &bdl, ofs, period_bytes);\n\t\tif (ofs < 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\n error:\n\tdev_err(chip->card->dev, \"Too many BDL entries: buffer=%d, period=%d\\n\",\n\t\t   str->bufsize, period_bytes);\n\treturn -EINVAL;\n}\n\nstatic unsigned int lola_get_format_verb(struct snd_pcm_substream *substream)\n{\n\tunsigned int verb;\n\n\tswitch (substream->runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tverb = 0x00000000;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tverb = 0x00000200;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tverb = 0x00000300;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_FLOAT_LE:\n\t\tverb = 0x00001300;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tverb |= substream->runtime->channels;\n\treturn verb;\n}\n\nstatic int lola_set_stream_config(struct lola *chip,\n\t\t\t\t  struct lola_stream *str,\n\t\t\t\t  int channels)\n{\n\tint i, err;\n\tunsigned int verb, val;\n\n\t \n\terr = lola_codec_read(chip, str->nid, LOLA_VERB_SET_STREAM_FORMAT,\n\t\t\t      str->format_verb, 0, &val, NULL);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Cannot set stream format 0x%x\\n\",\n\t\t       str->format_verb);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tverb = (str->index << 6) | i;\n\t\terr = lola_codec_read(chip, str[i].nid,\n\t\t\t\t      LOLA_VERB_SET_CHANNEL_STREAMID, 0, verb,\n\t\t\t\t      &val, NULL);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Cannot set stream channel %d\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int lola_setup_controller(struct lola *chip, struct lola_pcm *pcm,\n\t\t\t\t struct lola_stream *str)\n{\n\tdma_addr_t bdl;\n\n\tif (str->prepared)\n\t\treturn -EINVAL;\n\n\t \n\tbdl = pcm->bdl->addr + LOLA_BDL_ENTRY_SIZE * str->index;\n\tlola_dsd_write(chip, str->dsd, BDPL, (u32)bdl);\n\tlola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(bdl));\n\t \n\tlola_dsd_write(chip, str->dsd, LVI, str->frags - 1);\n\tlola_stream_clear_pending_irq(chip, str);\n\n \tlola_dsd_write(chip, str->dsd, CTL,\n\t\t       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE | LOLA_DSD_CTL_SRUN);\n\n\tstr->prepared = 1;\n\n\treturn lola_stream_wait_for_fifo(chip, str, true);\n}\n\nstatic int lola_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_pcm *pcm = lola_get_pcm(substream);\n\tstruct lola_stream *str = lola_get_stream(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int bufsize, period_bytes, format_verb;\n\tint i, err;\n\n\tmutex_lock(&chip->open_mutex);\n\tlola_stream_reset(chip, str);\n\tlola_cleanup_slave_streams(pcm, str);\n\tif (str->index + runtime->channels > pcm->num_streams) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 1; i < runtime->channels; i++) {\n\t\tstr[i].master = str;\n\t\tstr[i].opened = 1;\n\t}\n\tmutex_unlock(&chip->open_mutex);\n\n\tbufsize = snd_pcm_lib_buffer_bytes(substream);\n\tperiod_bytes = snd_pcm_lib_period_bytes(substream);\n\tformat_verb = lola_get_format_verb(substream);\n\n\tstr->bufsize = bufsize;\n\tstr->period_bytes = period_bytes;\n\tstr->format_verb = format_verb;\n\n\terr = lola_setup_periods(chip, pcm, substream, str);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_set_sample_rate(chip, runtime->rate);\n\tif (err < 0)\n\t\treturn err;\n\tchip->sample_rate = runtime->rate;\t \n\n\terr = lola_set_stream_config(chip, str, runtime->channels);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_setup_controller(chip, pcm, str);\n\tif (err < 0) {\n\t\tlola_stream_reset(chip, str);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_stream *str;\n\tstruct snd_pcm_substream *s;\n\tunsigned int start;\n\tunsigned int tstamp;\n\tbool sync_streams;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tstart = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstart = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsync_streams = (start && snd_pcm_stream_linked(substream));\n\ttstamp = lola_get_tstamp(chip, !sync_streams);\n\tspin_lock(&chip->reg_lock);\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s->pcm->card != substream->pcm->card)\n\t\t\tcontinue;\n\t\tstr = lola_get_stream(s);\n\t\tif (start)\n\t\t\tlola_stream_start(chip, str, tstamp);\n\t\telse\n\t\t\tlola_stream_stop(chip, str, tstamp);\n\t\tstr->running = start;\n\t\tstr->paused = !start;\n\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t lola_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct lola *chip = snd_pcm_substream_chip(substream);\n\tstruct lola_stream *str = lola_get_stream(substream);\n\tunsigned int pos = lola_dsd_read(chip, str->dsd, LPIB);\n\n\tif (pos >= str->bufsize)\n\t\tpos = 0;\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nvoid lola_pcm_update(struct lola *chip, struct lola_pcm *pcm, unsigned int bits)\n{\n\tint i;\n\tu8 num_streams = min_t(u8, pcm->num_streams, ARRAY_SIZE(pcm->streams));\n\n\tfor (i = 0; bits && i < num_streams; i++) {\n\t\tif (bits & (1 << i)) {\n\t\t\tstruct lola_stream *str = &pcm->streams[i];\n\t\t\tif (str->substream && str->running)\n\t\t\t\tsnd_pcm_period_elapsed(str->substream);\n\t\t\tbits &= ~(1 << i);\n\t\t}\n\t}\n}\n\nstatic const struct snd_pcm_ops lola_pcm_ops = {\n\t.open = lola_pcm_open,\n\t.close = lola_pcm_close,\n\t.hw_params = lola_pcm_hw_params,\n\t.hw_free = lola_pcm_hw_free,\n\t.prepare = lola_pcm_prepare,\n\t.trigger = lola_pcm_trigger,\n\t.pointer = lola_pcm_pointer,\n};\n\nint lola_create_pcm(struct lola *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint i, err;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tchip->pcm[i].bdl =\n\t\t\tsnd_devm_alloc_pages(&chip->pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t     PAGE_SIZE);\n\t\tif (!chip->pcm[i].bdl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terr = snd_pcm_new(chip->card, \"Digigram Lola\", 0,\n\t\t\t  chip->pcm[SNDRV_PCM_STREAM_PLAYBACK].num_streams,\n\t\t\t  chip->pcm[SNDRV_PCM_STREAM_CAPTURE].num_streams,\n\t\t\t  &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tstrscpy(pcm->name, \"Digigram Lola\", sizeof(pcm->name));\n\tpcm->private_data = chip;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chip->pcm[i].num_streams)\n\t\t\tsnd_pcm_set_ops(pcm, i, &lola_pcm_ops);\n\t}\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       1024 * 64, 32 * 1024 * 1024);\n\treturn 0;\n}\n\n \n\nstatic int lola_init_stream(struct lola *chip, struct lola_stream *str,\n\t\t\t    int idx, int nid, int dir)\n{\n\tunsigned int val;\n\tint err;\n\n\tstr->nid = nid;\n\tstr->index = idx;\n\tstr->dsd = idx;\n\tif (dir == PLAY)\n\t\tstr->dsd += MAX_STREAM_IN_COUNT;\n\terr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read wcaps for 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\tif (dir == PLAY) {\n\t\t \n\t\tif ((val & 0x00f00dff) != 0x00000010) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Invalid wcaps 0x%x for 0x%x\\n\",\n\t\t\t       val, nid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((val & 0x00f00cff) != 0x00100010) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Invalid wcaps 0x%x for 0x%x\\n\",\n\t\t\t       val, nid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif ((val & 0x00001200) == 0x00001200)\n\t\t\tchip->input_src_caps_mask |= (1 << idx);\n\t}\n\n\terr = lola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read FORMATS 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\tval &= 3;\n\tif (val == 3)\n\t\tstr->can_float = true;\n\tif (!(val & 1)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Invalid formats 0x%x for 0x%x\", val, nid);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint lola_init_pcm(struct lola *chip, int dir, int *nidp)\n{\n\tstruct lola_pcm *pcm = &chip->pcm[dir];\n\tint i, nid, err;\n\n\tnid = *nidp;\n\tfor (i = 0; i < pcm->num_streams; i++, nid++) {\n\t\terr = lola_init_stream(chip, &pcm->streams[i], i, nid, dir);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t*nidp = nid;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}