{
  "module_name": "lola_proc.c",
  "hash_id": "bdbad2cdce689a8fc26afea28ec4ddf670a851dbfe290f605d98f4e324b4a641",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lola/lola_proc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include \"lola.h\"\n\nstatic void print_audio_widget(struct snd_info_buffer *buffer,\n\t\t\t       struct lola *chip, int nid, const char *name)\n{\n\tunsigned int val;\n\n\tlola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tsnd_iprintf(buffer, \"Node 0x%02x %s wcaps 0x%x\\n\", nid, name, val);\n\tlola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);\n\tsnd_iprintf(buffer, \"  Formats: 0x%x\\n\", val);\n}\n\nstatic void print_pin_widget(struct snd_info_buffer *buffer,\n\t\t\t     struct lola *chip, int nid, unsigned int ampcap,\n\t\t\t     const char *name)\n{\n\tunsigned int val;\n\n\tlola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tsnd_iprintf(buffer, \"Node 0x%02x %s wcaps 0x%x\\n\", nid, name, val);\n\tif (val == 0x00400200)\n\t\treturn;\n\tlola_read_param(chip, nid, ampcap, &val);\n\tsnd_iprintf(buffer, \"  Amp-Caps: 0x%x\\n\", val);\n\tsnd_iprintf(buffer, \"    mute=%d, step-size=%d, steps=%d, ofs=%d\\n\",\n\t\t    LOLA_AMP_MUTE_CAPABLE(val),\n\t\t    LOLA_AMP_STEP_SIZE(val),\n\t\t    LOLA_AMP_NUM_STEPS(val),\n\t\t    LOLA_AMP_OFFSET(val));\n\tlola_codec_read(chip, nid, LOLA_VERB_GET_MAX_LEVEL, 0, 0, &val, NULL);\n\tsnd_iprintf(buffer, \"  Max-level: 0x%x\\n\", val);\n}\n\nstatic void print_clock_widget(struct snd_info_buffer *buffer,\n\t\t\t       struct lola *chip, int nid)\n{\n\tint i, j, num_clocks;\n\tunsigned int val;\n\n\tlola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tsnd_iprintf(buffer, \"Node 0x%02x [Clock] wcaps 0x%x\\n\", nid, val);\n\tnum_clocks = val & 0xff;\n\tfor (i = 0; i < num_clocks; i += 4) {\n\t\tunsigned int res_ex;\n\t\tunsigned short items[4];\n\t\tconst char *name;\n\n\t\tlola_codec_read(chip, nid, LOLA_VERB_GET_CLOCK_LIST,\n\t\t\t\ti, 0, &val, &res_ex);\n\t\titems[0] = val & 0xfff;\n\t\titems[1] = (val >> 16) & 0xfff;\n\t\titems[2] = res_ex & 0xfff;\n\t\titems[3] = (res_ex >> 16) & 0xfff;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tunsigned char type = items[j] >> 8;\n\t\t\tunsigned int freq = items[j] & 0xff;\n\t\t\tif (i + j >= num_clocks)\n\t\t\t\tbreak;\n\t\t\tif (type == LOLA_CLOCK_TYPE_INTERNAL) {\n\t\t\t\tname = \"Internal\";\n\t\t\t\tfreq = lola_sample_rate_convert(freq);\n\t\t\t} else if (type == LOLA_CLOCK_TYPE_VIDEO) {\n\t\t\t\tname = \"Video\";\n\t\t\t\tfreq = lola_sample_rate_convert(freq);\n\t\t\t} else {\n\t\t\t\tname = \"Other\";\n\t\t\t}\n\t\t\tsnd_iprintf(buffer, \"  Clock %d: Type %d:%s, freq=%d\\n\",\n\t\t\t\t    i + j, type, name, freq);\n\t\t}\n\t}\n}\n\nstatic void print_mixer_widget(struct snd_info_buffer *buffer,\n\t\t\t       struct lola *chip, int nid)\n{\n\tunsigned int val;\n\n\tlola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tsnd_iprintf(buffer, \"Node 0x%02x [Mixer] wcaps 0x%x\\n\", nid, val);\n}\n\nstatic void lola_proc_codec_read(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct lola *chip = entry->private_data;\n\tunsigned int val;\n\tint i, nid;\n\n\tlola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);\n\tsnd_iprintf(buffer, \"Vendor: 0x%08x\\n\", val);\n\tlola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);\n\tsnd_iprintf(buffer, \"Function Type: %d\\n\", val);\n\tlola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);\n\tsnd_iprintf(buffer, \"Specific-Caps: 0x%08x\\n\", val);\n\tsnd_iprintf(buffer, \"  Pins-In %d, Pins-Out %d\\n\",\n\t\t    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);\n\tnid = 2;\n\tfor (i = 0; i < chip->pcm[CAPT].num_streams; i++, nid++)\n\t\tprint_audio_widget(buffer, chip, nid, \"[Audio-In]\");\n\tfor (i = 0; i < chip->pcm[PLAY].num_streams; i++, nid++)\n\t\tprint_audio_widget(buffer, chip, nid, \"[Audio-Out]\");\n\tfor (i = 0; i < chip->pin[CAPT].num_pins; i++, nid++)\n\t\tprint_pin_widget(buffer, chip, nid, LOLA_PAR_AMP_IN_CAP,\n\t\t\t\t \"[Pin-In]\");\n\tfor (i = 0; i < chip->pin[PLAY].num_pins; i++, nid++)\n\t\tprint_pin_widget(buffer, chip, nid, LOLA_PAR_AMP_OUT_CAP,\n\t\t\t\t \"[Pin-Out]\");\n\tif (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {\n\t\tprint_clock_widget(buffer, chip, nid);\n\t\tnid++;\n\t}\n\tif (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {\n\t\tprint_mixer_widget(buffer, chip, nid);\n\t\tnid++;\n\t}\n}\n\n \nstatic void lola_proc_codec_rw_write(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct lola *chip = entry->private_data;\n\tchar line[64];\n\tunsigned int id, verb, data, extdata;\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tif (sscanf(line, \"%u %u %u %u\", &id, &verb, &data, &extdata) != 4)\n\t\t\tcontinue;\n\t\tlola_codec_read(chip, id, verb, data, extdata,\n\t\t\t\t&chip->debug_res,\n\t\t\t\t&chip->debug_res_ex);\n\t}\n}\n\nstatic void lola_proc_codec_rw_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct lola *chip = entry->private_data;\n\tsnd_iprintf(buffer, \"0x%x 0x%x\\n\", chip->debug_res, chip->debug_res_ex);\n}\n\n \nstatic void lola_proc_regs_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct lola *chip = entry->private_data;\n\tint i;\n\n\tfor (i = 0; i < 0x40; i += 4) {\n\t\tsnd_iprintf(buffer, \"BAR0 %02x: %08x\\n\", i,\n\t\t\t    readl(chip->bar[BAR0].remap_addr + i));\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n\tfor (i = 0; i < 0x30; i += 4) {\n\t\tsnd_iprintf(buffer, \"BAR1 %02x: %08x\\n\", i,\n\t\t\t    readl(chip->bar[BAR1].remap_addr + i));\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n\tfor (i = 0x80; i < 0xa0; i += 4) {\n\t\tsnd_iprintf(buffer, \"BAR1 %02x: %08x\\n\", i,\n\t\t\t    readl(chip->bar[BAR1].remap_addr + i));\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tsnd_iprintf(buffer, \"DSD %02x STS  %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, STS));\n\t\tsnd_iprintf(buffer, \"DSD %02x LPIB %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, LPIB));\n\t\tsnd_iprintf(buffer, \"DSD %02x CTL  %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, CTL));\n\t\tsnd_iprintf(buffer, \"DSD %02x LVIL %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, LVI));\n\t\tsnd_iprintf(buffer, \"DSD %02x BDPL %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, BDPL));\n\t\tsnd_iprintf(buffer, \"DSD %02x BDPU %08x\\n\", i,\n\t\t\t    lola_dsd_read(chip, i, BDPU));\n\t}\n}\n\nvoid lola_proc_debug_new(struct lola *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"codec\", chip, lola_proc_codec_read);\n\tsnd_card_rw_proc_new(chip->card, \"codec_rw\", chip,\n\t\t\t     lola_proc_codec_rw_read,\n\t\t\t     lola_proc_codec_rw_write);\n\tsnd_card_ro_proc_new(chip->card, \"regs\", chip, lola_proc_regs_read);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}