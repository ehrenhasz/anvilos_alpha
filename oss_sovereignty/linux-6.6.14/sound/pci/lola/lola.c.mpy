{
  "module_name": "lola.c",
  "hash_id": "67c363f04fe179f01312108086bed52748a4674fbbe0a043f68b06b0f276a103",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lola/lola.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include \"lola.h\"\n\n \nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Digigram Lola driver.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Digigram Lola driver.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Digigram Lola driver.\");\n\n \n\n \nstatic int granularity[SNDRV_CARDS] = {\n\t[0 ... (SNDRV_CARDS - 1)] = LOLA_GRANULARITY_MAX\n};\n\n \nstatic int sample_rate_min[SNDRV_CARDS] = {\n\t[0 ... (SNDRV_CARDS - 1) ] = 16000\n};\n\nmodule_param_array(granularity, int, NULL, 0444);\nMODULE_PARM_DESC(granularity, \"Granularity value\");\nmodule_param_array(sample_rate_min, int, NULL, 0444);\nMODULE_PARM_DESC(sample_rate_min, \"Minimal sample rate\");\n\n \n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Digigram Lola driver\");\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\n\n#ifdef CONFIG_SND_DEBUG_VERBOSE\nstatic int debug;\nmodule_param(debug, int, 0644);\n#define verbose_debug(fmt, args...)\t\t\t\\\n\tdo { if (debug > 1) pr_debug(SFX fmt, ##args); } while (0)\n#else\n#define verbose_debug(fmt, args...)\n#endif\n\n \n\nstatic int corb_send_verb(struct lola *chip, unsigned int nid,\n\t\t\t  unsigned int verb, unsigned int data,\n\t\t\t  unsigned int extdata)\n{\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tchip->last_cmd_nid = nid;\n\tchip->last_verb = verb;\n\tchip->last_data = data;\n\tchip->last_extdata = extdata;\n\tdata |= (nid << 20) | (verb << 8);\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (chip->rirb.cmds < LOLA_CORB_ENTRIES - 1) {\n\t\tunsigned int wp = chip->corb.wp + 1;\n\t\twp %= LOLA_CORB_ENTRIES;\n\t\tchip->corb.wp = wp;\n\t\tchip->corb.buf[wp * 2] = cpu_to_le32(data);\n\t\tchip->corb.buf[wp * 2 + 1] = cpu_to_le32(extdata);\n\t\tlola_writew(chip, BAR0, CORBWP, wp);\n\t\tchip->rirb.cmds++;\n\t\tsmp_wmb();\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn ret;\n}\n\nstatic void lola_queue_unsol_event(struct lola *chip, unsigned int res,\n\t\t\t\t   unsigned int res_ex)\n{\n\tlola_update_ext_clock_freq(chip, res);\n}\n\n \nstatic void lola_update_rirb(struct lola *chip)\n{\n\tunsigned int rp, wp;\n\tu32 res, res_ex;\n\n\twp = lola_readw(chip, BAR0, RIRBWP);\n\tif (wp == chip->rirb.wp)\n\t\treturn;\n\tchip->rirb.wp = wp;\n\n\twhile (chip->rirb.rp != wp) {\n\t\tchip->rirb.rp++;\n\t\tchip->rirb.rp %= LOLA_CORB_ENTRIES;\n\n\t\trp = chip->rirb.rp << 1;  \n\t\tres_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);\n\t\tres = le32_to_cpu(chip->rirb.buf[rp]);\n\t\tif (res_ex & LOLA_RIRB_EX_UNSOL_EV)\n\t\t\tlola_queue_unsol_event(chip, res, res_ex);\n\t\telse if (chip->rirb.cmds) {\n\t\t\tchip->res = res;\n\t\t\tchip->res_ex = res_ex;\n\t\t\tsmp_wmb();\n\t\t\tchip->rirb.cmds--;\n\t\t}\n\t}\n}\n\nstatic int rirb_get_response(struct lola *chip, unsigned int *val,\n\t\t\t     unsigned int *extval)\n{\n\tunsigned long timeout;\n\n again:\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\tfor (;;) {\n\t\tif (chip->polling_mode) {\n\t\t\tspin_lock_irq(&chip->reg_lock);\n\t\t\tlola_update_rirb(chip);\n\t\t\tspin_unlock_irq(&chip->reg_lock);\n\t\t}\n\t\tif (!chip->rirb.cmds) {\n\t\t\t*val = chip->res;\n\t\t\tif (extval)\n\t\t\t\t*extval = chip->res_ex;\n\t\t\tverbose_debug(\"get_response: %x, %x\\n\",\n\t\t\t\t      chip->res, chip->res_ex);\n\t\t\tif (chip->res_ex & LOLA_RIRB_EX_ERROR) {\n\t\t\t\tdev_warn(chip->card->dev, \"RIRB ERROR: \"\n\t\t\t\t       \"NID=%x, verb=%x, data=%x, ext=%x\\n\",\n\t\t\t\t       chip->last_cmd_nid,\n\t\t\t\t       chip->last_verb, chip->last_data,\n\t\t\t\t       chip->last_extdata);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tudelay(20);\n\t\tcond_resched();\n\t}\n\tdev_warn(chip->card->dev, \"RIRB response error\\n\");\n\tif (!chip->polling_mode) {\n\t\tdev_warn(chip->card->dev, \"switching to polling mode\\n\");\n\t\tchip->polling_mode = 1;\n\t\tgoto again;\n\t}\n\treturn -EIO;\n}\n\n \nint lola_codec_write(struct lola *chip, unsigned int nid, unsigned int verb,\n\t\t     unsigned int data, unsigned int extdata)\n{\n\tverbose_debug(\"codec_write NID=%x, verb=%x, data=%x, ext=%x\\n\",\n\t\t      nid, verb, data, extdata);\n\treturn corb_send_verb(chip, nid, verb, data, extdata);\n}\n\n \nint lola_codec_read(struct lola *chip, unsigned int nid, unsigned int verb,\n\t\t    unsigned int data, unsigned int extdata,\n\t\t    unsigned int *val, unsigned int *extval)\n{\n\tint err;\n\n\tverbose_debug(\"codec_read NID=%x, verb=%x, data=%x, ext=%x\\n\",\n\t\t      nid, verb, data, extdata);\n\terr = corb_send_verb(chip, nid, verb, data, extdata);\n\tif (err < 0)\n\t\treturn err;\n\terr = rirb_get_response(chip, val, extval);\n\treturn err;\n}\n\n \nint lola_codec_flush(struct lola *chip)\n{\n\tunsigned int tmp;\n\treturn rirb_get_response(chip, &tmp, NULL);\n}\n\n \nstatic irqreturn_t lola_interrupt(int irq, void *dev_id)\n{\n\tstruct lola *chip = dev_id;\n\tunsigned int notify_ins, notify_outs, error_ins, error_outs;\n\tint handled = 0;\n\tint i;\n\n\tnotify_ins = notify_outs = error_ins = error_outs = 0;\n\tspin_lock(&chip->reg_lock);\n\tfor (;;) {\n\t\tunsigned int status, in_sts, out_sts;\n\t\tunsigned int reg;\n\n\t\tstatus = lola_readl(chip, BAR1, DINTSTS);\n\t\tif (!status || status == -1)\n\t\t\tbreak;\n\n\t\tin_sts = lola_readl(chip, BAR1, DIINTSTS);\n\t\tout_sts = lola_readl(chip, BAR1, DOINTSTS);\n\n\t\t \n\t\tfor (i = 0; in_sts && i < chip->pcm[CAPT].num_streams; i++) {\n\t\t\tif (!(in_sts & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tin_sts &= ~(1 << i);\n\t\t\treg = lola_dsd_read(chip, i, STS);\n\t\t\tif (reg & LOLA_DSD_STS_DESE)  \n\t\t\t\terror_ins |= (1 << i);\n\t\t\tif (reg & LOLA_DSD_STS_BCIS)  \n\t\t\t\tnotify_ins |= (1 << i);\n\t\t\t \n\t\t\tlola_dsd_write(chip, i, STS, reg);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; out_sts && i < chip->pcm[PLAY].num_streams; i++) {\n\t\t\tif (!(out_sts & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tout_sts &= ~(1 << i);\n\t\t\treg = lola_dsd_read(chip, i + MAX_STREAM_IN_COUNT, STS);\n\t\t\tif (reg & LOLA_DSD_STS_DESE)  \n\t\t\t\terror_outs |= (1 << i);\n\t\t\tif (reg & LOLA_DSD_STS_BCIS)  \n\t\t\t\tnotify_outs |= (1 << i);\n\t\t\tlola_dsd_write(chip, i + MAX_STREAM_IN_COUNT, STS, reg);\n\t\t}\n\n\t\tif (status & LOLA_DINT_CTRL) {\n\t\t\tunsigned char rbsts;  \n\t\t\trbsts = lola_readb(chip, BAR0, RIRBSTS);\n\t\t\trbsts &= LOLA_RIRB_INT_MASK;\n\t\t\tif (rbsts)\n\t\t\t\tlola_writeb(chip, BAR0, RIRBSTS, rbsts);\n\t\t\trbsts = lola_readb(chip, BAR0, CORBSTS);\n\t\t\trbsts &= LOLA_CORB_INT_MASK;\n\t\t\tif (rbsts)\n\t\t\t\tlola_writeb(chip, BAR0, CORBSTS, rbsts);\n\n\t\t\tlola_update_rirb(chip);\n\t\t}\n\n\t\tif (status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)) {\n\t\t\t \n\t\t\tlola_writel(chip, BAR1, DINTSTS,\n\t\t\t\t    (status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)));\n\t\t}\n\t\thandled = 1;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\n\tlola_pcm_update(chip, &chip->pcm[CAPT], notify_ins);\n\tlola_pcm_update(chip, &chip->pcm[PLAY], notify_outs);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic int reset_controller(struct lola *chip)\n{\n\tunsigned int gctl = lola_readl(chip, BAR0, GCTL);\n\tunsigned long end_time;\n\n\tif (gctl) {\n\t\t \n\t\tlola_writel(chip, BAR1, BOARD_MODE, 0);\n\t\treturn 0;\n\t}\n\n\tchip->cold_reset = 1;\n\tlola_writel(chip, BAR0, GCTL, LOLA_GCTL_RESET);\n\tend_time = jiffies + msecs_to_jiffies(200);\n\tdo {\n\t\tmsleep(1);\n\t\tgctl = lola_readl(chip, BAR0, GCTL);\n\t\tif (gctl)\n\t\t\tbreak;\n\t} while (time_before(jiffies, end_time));\n\tif (!gctl) {\n\t\tdev_err(chip->card->dev, \"cannot reset controller\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void lola_irq_enable(struct lola *chip)\n{\n\tunsigned int val;\n\n\t \n\tval = (1 << chip->pcm[PLAY].num_streams) - 1;\n\tlola_writel(chip, BAR1, DOINTCTL, val);\n\tval = (1 << chip->pcm[CAPT].num_streams) - 1;\n\tlola_writel(chip, BAR1, DIINTCTL, val);\n\n\t \n\tval = LOLA_DINT_GLOBAL | LOLA_DINT_CTRL | LOLA_DINT_FIFOERR |\n\t\tLOLA_DINT_MUERR;\n\tlola_writel(chip, BAR1, DINTCTL, val);\n}\n\nstatic void lola_irq_disable(struct lola *chip)\n{\n\tlola_writel(chip, BAR1, DINTCTL, 0);\n\tlola_writel(chip, BAR1, DIINTCTL, 0);\n\tlola_writel(chip, BAR1, DOINTCTL, 0);\n}\n\nstatic int setup_corb_rirb(struct lola *chip)\n{\n\tunsigned char tmp;\n\tunsigned long end_time;\n\n\tchip->rb = snd_devm_alloc_pages(&chip->pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\tPAGE_SIZE);\n\tif (!chip->rb)\n\t\treturn -ENOMEM;\n\n\tchip->corb.addr = chip->rb->addr;\n\tchip->corb.buf = (__le32 *)chip->rb->area;\n\tchip->rirb.addr = chip->rb->addr + 2048;\n\tchip->rirb.buf = (__le32 *)(chip->rb->area + 2048);\n\n\t \n\tlola_writeb(chip, BAR0, RIRBCTL, 0);\n\tlola_writeb(chip, BAR0, CORBCTL, 0);\n\n\tend_time = jiffies + msecs_to_jiffies(200);\n\tdo {\n\t\tif (!lola_readb(chip, BAR0, RIRBCTL) &&\n\t\t    !lola_readb(chip, BAR0, CORBCTL))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t} while (time_before(jiffies, end_time));\n\n\t \n\tlola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);\n\tlola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));\n\t \n\tlola_writeb(chip, BAR0, CORBSIZE, 0x02);\n\t \n\tlola_writew(chip, BAR0, CORBWP, 0);\n\t \n\tlola_writew(chip, BAR0, CORBRP, LOLA_RBRWP_CLR);\n\t \n\tlola_writeb(chip, BAR0, CORBCTL, LOLA_RBCTL_DMA_EN);\n\t \n\ttmp = lola_readb(chip, BAR0, CORBSTS) & LOLA_CORB_INT_MASK;\n\tif (tmp)\n\t\tlola_writeb(chip, BAR0, CORBSTS, tmp);\n\tchip->corb.wp = 0;\n\n\t \n\tlola_writel(chip, BAR0, RIRBLBASE, (u32)chip->rirb.addr);\n\tlola_writel(chip, BAR0, RIRBUBASE, upper_32_bits(chip->rirb.addr));\n\t \n\tlola_writeb(chip, BAR0, RIRBSIZE, 0x02);\n\t \n\tlola_writew(chip, BAR0, RIRBWP, LOLA_RBRWP_CLR);\n\t \n\tlola_writew(chip, BAR0, RINTCNT, 1);\n\t \n\tlola_writeb(chip, BAR0, RIRBCTL, LOLA_RBCTL_DMA_EN | LOLA_RBCTL_IRQ_EN);\n\t \n\ttmp =  lola_readb(chip, BAR0, RIRBSTS) & LOLA_RIRB_INT_MASK;\n\tif (tmp)\n\t\tlola_writeb(chip, BAR0, RIRBSTS, tmp);\n\tchip->rirb.rp = chip->rirb.cmds = 0;\n\n\treturn 0;\n}\n\nstatic void stop_corb_rirb(struct lola *chip)\n{\n\t \n\tlola_writeb(chip, BAR0, RIRBCTL, 0);\n\tlola_writeb(chip, BAR0, CORBCTL, 0);\n}\n\nstatic void lola_reset_setups(struct lola *chip)\n{\n\t \n\tlola_set_granularity(chip, chip->granularity, true);\n\t \n\tlola_set_clock_index(chip, chip->clock.cur_index);\n\t \n\tlola_enable_clock_events(chip);\n\t \n\tlola_setup_all_analog_gains(chip, CAPT, false);  \n\t \n\tlola_set_src_config(chip, chip->input_src_mask, false);\n\t \n\tlola_setup_all_analog_gains(chip, PLAY, false);  \n}\n\nstatic int lola_parse_tree(struct lola *chip)\n{\n\tunsigned int val;\n\tint nid, err;\n\n\terr = lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read VENDOR_ID\\n\");\n\t\treturn err;\n\t}\n\tval >>= 16;\n\tif (val != 0x1369) {\n\t\tdev_err(chip->card->dev, \"Unknown codec vendor 0x%x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\terr = lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read FUNCTION_TYPE\\n\");\n\t\treturn err;\n\t}\n\tif (val != 1) {\n\t\tdev_err(chip->card->dev, \"Unknown function type %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\terr = lola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read SPECCAPS\\n\");\n\t\treturn err;\n\t}\n\tchip->lola_caps = val;\n\tchip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);\n\tchip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);\n\tdev_dbg(chip->card->dev, \"speccaps=0x%x, pins in=%d, out=%d\\n\",\n\t\t    chip->lola_caps,\n\t\t    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);\n\n\tif (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||\n\t    chip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {\n\t\tdev_err(chip->card->dev, \"Invalid Lola-spec caps 0x%x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tnid = 0x02;\n\terr = lola_init_pcm(chip, CAPT, &nid);\n\tif (err < 0)\n\t\treturn err;\n\terr = lola_init_pcm(chip, PLAY, &nid);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_init_pins(chip, CAPT, &nid);\n\tif (err < 0)\n\t\treturn err;\n\terr = lola_init_pins(chip, PLAY, &nid);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {\n\t\terr = lola_init_clock_widget(chip, nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnid++;\n\t}\n\tif (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {\n\t\terr = lola_init_mixer_widget(chip, nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnid++;\n\t}\n\n\t \n\terr = lola_enable_clock_events(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!chip->cold_reset) {\n\t\tlola_reset_setups(chip);\n\t\tchip->cold_reset = 1;\n\t} else {\n\t\t \n\t\tif (chip->granularity != LOLA_GRANULARITY_MIN)\n\t\t\tlola_set_granularity(chip, chip->granularity, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void lola_stop_hw(struct lola *chip)\n{\n\tstop_corb_rirb(chip);\n\tlola_irq_disable(chip);\n}\n\nstatic void lola_free(struct snd_card *card)\n{\n\tstruct lola *chip = card->private_data;\n\n\tif (chip->initialized)\n\t\tlola_stop_hw(chip);\n\tlola_free_mixer(chip);\n}\n\nstatic int lola_create(struct snd_card *card, struct pci_dev *pci, int dev)\n{\n\tstruct lola *chip = card->private_data;\n\tint err;\n\tunsigned int dever;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tcard->private_free = lola_free;\n\n\tchip->granularity = granularity[dev];\n\tswitch (chip->granularity) {\n\tcase 8:\n\t\tchip->sample_rate_max = 48000;\n\t\tbreak;\n\tcase 16:\n\t\tchip->sample_rate_max = 96000;\n\t\tbreak;\n\tcase 32:\n\t\tchip->sample_rate_max = 192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(chip->card->dev,\n\t\t\t   \"Invalid granularity %d, reset to %d\\n\",\n\t\t\t   chip->granularity, LOLA_GRANULARITY_MAX);\n\t\tchip->granularity = LOLA_GRANULARITY_MAX;\n\t\tchip->sample_rate_max = 192000;\n\t\tbreak;\n\t}\n\tchip->sample_rate_min = sample_rate_min[dev];\n\tif (chip->sample_rate_min > chip->sample_rate_max) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t   \"Invalid sample_rate_min %d, reset to 16000\\n\",\n\t\t\t   chip->sample_rate_min);\n\t\tchip->sample_rate_min = 16000;\n\t}\n\n\terr = pcim_iomap_regions(pci, (1 << 0) | (1 << 2), DRVNAME);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->bar[0].addr = pci_resource_start(pci, 0);\n\tchip->bar[0].remap_addr = pcim_iomap_table(pci)[0];\n\tchip->bar[1].addr = pci_resource_start(pci, 2);\n\tchip->bar[1].remap_addr = pcim_iomap_table(pci)[2];\n\n\tpci_set_master(pci);\n\n\terr = reset_controller(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (devm_request_irq(&pci->dev, pci->irq, lola_interrupt, IRQF_SHARED,\n\t\t\t     KBUILD_MODNAME, chip)) {\n\t\tdev_err(chip->card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\tdever = lola_readl(chip, BAR1, DEVER);\n\tchip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;\n\tchip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;\n\tchip->version = (dever >> 24) & 0xff;\n\tdev_dbg(chip->card->dev, \"streams in=%d, out=%d, version=0x%x\\n\",\n\t\t    chip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,\n\t\t    chip->version);\n\n\t \n\tif (chip->pcm[CAPT].num_streams > MAX_STREAM_IN_COUNT ||\n\t    chip->pcm[PLAY].num_streams > MAX_STREAM_OUT_COUNT ||\n\t    (!chip->pcm[CAPT].num_streams &&\n\t     !chip->pcm[PLAY].num_streams)) {\n\t\tdev_err(chip->card->dev, \"invalid DEVER = %x\\n\", dever);\n\t\treturn -EINVAL;\n\t}\n\n\terr = setup_corb_rirb(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"Lola\");\n\tstrscpy(card->shortname, \"Digigram Lola\", sizeof(card->shortname));\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at 0x%lx irq %i\",\n\t\t card->shortname, chip->bar[0].addr, chip->irq);\n\tstrcpy(card->mixername, card->shortname);\n\n\tlola_irq_enable(chip);\n\n\tchip->initialized = 1;\n\treturn 0;\n}\n\nstatic int __lola_probe(struct pci_dev *pci,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct lola *chip;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0) {\n\t\tdev_err(&pci->dev, \"Error creating card!\\n\");\n\t\treturn err;\n\t}\n\tchip = card->private_data;\n\n\terr = lola_create(card, pci, dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_parse_tree(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_create_pcm(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = lola_create_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tlola_proc_debug_new(chip);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int lola_probe(struct pci_dev *pci,\n\t\t      const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __lola_probe(pci, pci_id));\n}\n\n \nstatic const struct pci_device_id lola_ids[] = {\n\t{ PCI_VDEVICE(DIGIGRAM, 0x0001) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, lola_ids);\n\n \nstatic struct pci_driver lola_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = lola_ids,\n\t.probe = lola_probe,\n};\n\nmodule_pci_driver(lola_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}