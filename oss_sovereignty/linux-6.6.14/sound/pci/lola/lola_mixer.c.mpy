{
  "module_name": "lola_mixer.c",
  "hash_id": "c5dfca47432ff8ac8bb4215b5151145b50c3621fa6ea3ebf0e4e620bec562745",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lola/lola_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n#include \"lola.h\"\n\nstatic int lola_init_pin(struct lola *chip, struct lola_pin *pin,\n\t\t\t int dir, int nid)\n{\n\tunsigned int val;\n\tint err;\n\n\tpin->nid = nid;\n\terr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read wcaps for 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\tval &= 0x00f00fff;  \n\tif (val == 0x00400200)     \n\t\tpin->is_analog = false;\n\telse if (val == 0x0040000a && dir == CAPT)  \n\t\tpin->is_analog = true;\n\telse if (val == 0x0040000c && dir == PLAY)  \n\t\tpin->is_analog = true;\n\telse {\n\t\tdev_err(chip->card->dev, \"Invalid wcaps 0x%x for 0x%x\\n\", val, nid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!pin->is_analog)\n\t\treturn 0;\n\n\tif (dir == PLAY)\n\t\terr = lola_read_param(chip, nid, LOLA_PAR_AMP_OUT_CAP, &val);\n\telse\n\t\terr = lola_read_param(chip, nid, LOLA_PAR_AMP_IN_CAP, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read AMP-caps for 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\n\tpin->amp_mute = LOLA_AMP_MUTE_CAPABLE(val);\n\tpin->amp_step_size = LOLA_AMP_STEP_SIZE(val);\n\tpin->amp_num_steps = LOLA_AMP_NUM_STEPS(val);\n\tif (pin->amp_num_steps) {\n\t\t \n\t\tpin->amp_num_steps++;\n\t\tpin->amp_step_size++;\n\t}\n\tpin->amp_offset = LOLA_AMP_OFFSET(val);\n\n\terr = lola_codec_read(chip, nid, LOLA_VERB_GET_MAX_LEVEL, 0, 0, &val,\n\t\t\t      NULL);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't get MAX_LEVEL 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\tpin->max_level = val & 0x3ff;    \n\n\tpin->config_default_reg = 0;\n\tpin->fixed_gain_list_len = 0;\n\tpin->cur_gain_step = 0;\n\n\treturn 0;\n}\n\nint lola_init_pins(struct lola *chip, int dir, int *nidp)\n{\n\tint i, err, nid;\n\tnid = *nidp;\n\tfor (i = 0; i < chip->pin[dir].num_pins; i++, nid++) {\n\t\terr = lola_init_pin(chip, &chip->pin[dir].pins[i], dir, nid);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (chip->pin[dir].pins[i].is_analog)\n\t\t\tchip->pin[dir].num_analog_pins++;\n\t}\n\t*nidp = nid;\n\treturn 0;\n}\n\nvoid lola_free_mixer(struct lola *chip)\n{\n\tvfree(chip->mixer.array_saved);\n}\n\nint lola_init_mixer_widget(struct lola *chip, int nid)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read wcaps for 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\n\tif ((val & 0xfff00000) != 0x02f00000) {  \n\t\tdev_dbg(chip->card->dev, \"No valid mixer widget\\n\");\n\t\treturn 0;\n\t}\n\n\tchip->mixer.nid = nid;\n\tchip->mixer.caps = val;\n\tchip->mixer.array = (struct lola_mixer_array __iomem *)\n\t\t(chip->bar[BAR1].remap_addr + LOLA_BAR1_SOURCE_GAIN_ENABLE);\n\n\t \n\tchip->mixer.array_saved = vmalloc(sizeof(struct lola_mixer_array));\n\tif (!chip->mixer.array_saved)\n\t\treturn -ENOMEM;\n\n\t \n\tchip->mixer.src_stream_outs = chip->pcm[PLAY].num_streams;\n\tchip->mixer.src_phys_ins = chip->pin[CAPT].num_pins;\n\n\t \n\tchip->mixer.dest_stream_ins = chip->pcm[CAPT].num_streams;\n\tchip->mixer.dest_phys_outs = chip->pin[PLAY].num_pins;\n\n\t \n\tchip->mixer.src_stream_out_ofs = chip->mixer.src_phys_ins +\n\t\tLOLA_MIXER_SRC_INPUT_PLAY_SEPARATION(val);\n\tchip->mixer.dest_phys_out_ofs = chip->mixer.dest_stream_ins +\n\t\tLOLA_MIXER_DEST_REC_OUTPUT_SEPARATION(val);\n\n\t \n\t \n\tif (chip->mixer.src_stream_out_ofs > MAX_AUDIO_INOUT_COUNT ||\n\t    chip->mixer.dest_phys_out_ofs > MAX_STREAM_IN_COUNT) {\n\t\tdev_err(chip->card->dev, \"Invalid mixer widget size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->mixer.src_mask = ((1U << chip->mixer.src_phys_ins) - 1) |\n\t\t(((1U << chip->mixer.src_stream_outs) - 1)\n\t\t << chip->mixer.src_stream_out_ofs);\n\tchip->mixer.dest_mask = ((1U << chip->mixer.dest_stream_ins) - 1) |\n\t\t(((1U << chip->mixer.dest_phys_outs) - 1)\n\t\t << chip->mixer.dest_phys_out_ofs);\n\n\tdev_dbg(chip->card->dev, \"Mixer src_mask=%x, dest_mask=%x\\n\",\n\t\t    chip->mixer.src_mask, chip->mixer.dest_mask);\n\n\treturn 0;\n}\n\nstatic int lola_mixer_set_src_gain(struct lola *chip, unsigned int id,\n\t\t\t\t   unsigned short gain, bool on)\n{\n\tunsigned int oldval, val;\n\n\tif (!(chip->mixer.src_mask & (1 << id)))\n\t\treturn -EINVAL;\n\toldval = val = readl(&chip->mixer.array->src_gain_enable);\n\tif (on)\n\t\tval |= (1 << id);\n\telse\n\t\tval &= ~(1 << id);\n\t \n\tif ((val == oldval) &&\n\t    (gain == readw(&chip->mixer.array->src_gain[id])))\n\t\treturn 0;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"lola_mixer_set_src_gain (id=%d, gain=%d) enable=%x\\n\",\n\t\t\tid, gain, val);\n\twritew(gain, &chip->mixer.array->src_gain[id]);\n\twritel(val, &chip->mixer.array->src_gain_enable);\n\tlola_codec_flush(chip);\n\t \n\treturn lola_codec_write(chip, chip->mixer.nid,\n\t\t\t\tLOLA_VERB_SET_SOURCE_GAIN, id, 0);\n}\n\n#if 0  \nstatic int lola_mixer_set_src_gains(struct lola *chip, unsigned int mask,\n\t\t\t\t    unsigned short *gains)\n{\n\tint i;\n\n\tif ((chip->mixer.src_mask & mask) != mask)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < LOLA_MIXER_DIM; i++) {\n\t\tif (mask & (1 << i)) {\n\t\t\twritew(*gains, &chip->mixer.array->src_gain[i]);\n\t\t\tgains++;\n\t\t}\n\t}\n\twritel(mask, &chip->mixer.array->src_gain_enable);\n\tlola_codec_flush(chip);\n\tif (chip->mixer.caps & LOLA_PEAK_METER_CAN_AGC_MASK) {\n\t\t \n\t\treturn lola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\tLOLA_VERB_SET_SOURCE_GAIN, 0x80, 0);\n\t}\n\t \n\tfor (i = 0; i < LOLA_MIXER_DIM; i++) {\n\t\tif (mask & (1 << i)) {\n\t\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\t LOLA_VERB_SET_SOURCE_GAIN, i, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n#endif  \n\nstatic int lola_mixer_set_mapping_gain(struct lola *chip,\n\t\t\t\t       unsigned int src, unsigned int dest,\n\t\t\t\t       unsigned short gain, bool on)\n{\n\tunsigned int val;\n\n\tif (!(chip->mixer.src_mask & (1 << src)) ||\n\t    !(chip->mixer.dest_mask & (1 << dest)))\n\t\treturn -EINVAL;\n\tif (on)\n\t\twritew(gain, &chip->mixer.array->dest_mix_gain[dest][src]);\n\tval = readl(&chip->mixer.array->dest_mix_gain_enable[dest]);\n\tif (on)\n\t\tval |= (1 << src);\n\telse\n\t\tval &= ~(1 << src);\n\twritel(val, &chip->mixer.array->dest_mix_gain_enable[dest]);\n\tlola_codec_flush(chip);\n\treturn lola_codec_write(chip, chip->mixer.nid, LOLA_VERB_SET_MIX_GAIN,\n\t\t\t\tsrc, dest);\n}\n\n#if 0  \nstatic int lola_mixer_set_dest_gains(struct lola *chip, unsigned int id,\n\t\t\t\t     unsigned int mask, unsigned short *gains)\n{\n\tint i;\n\n\tif (!(chip->mixer.dest_mask & (1 << id)) ||\n\t    (chip->mixer.src_mask & mask) != mask)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < LOLA_MIXER_DIM; i++) {\n\t\tif (mask & (1 << i)) {\n\t\t\twritew(*gains, &chip->mixer.array->dest_mix_gain[id][i]);\n\t\t\tgains++;\n\t\t}\n\t}\n\twritel(mask, &chip->mixer.array->dest_mix_gain_enable[id]);\n\tlola_codec_flush(chip);\n\t \n\treturn lola_codec_write(chip, chip->mixer.nid,\n\t\t\t\tLOLA_VERB_SET_DESTINATION_GAIN, id, 0);\n}\n#endif  \n\n \n\nstatic int set_analog_volume(struct lola *chip, int dir,\n\t\t\t     unsigned int idx, unsigned int val,\n\t\t\t     bool external_call);\n\nint lola_setup_all_analog_gains(struct lola *chip, int dir, bool mute)\n{\n\tstruct lola_pin *pin;\n\tint idx, max_idx;\n\n\tpin = chip->pin[dir].pins;\n\tmax_idx = chip->pin[dir].num_pins;\n\tfor (idx = 0; idx < max_idx; idx++) {\n\t\tif (pin[idx].is_analog) {\n\t\t\tunsigned int val = mute ? 0 : pin[idx].cur_gain_step;\n\t\t\t \n\t\t\tset_analog_volume(chip, dir, idx, val, false);\n\t\t}\n\t}\n\treturn lola_codec_flush(chip);\n}\n\nvoid lola_save_mixer(struct lola *chip)\n{\n\t \n\tif (chip->mixer.array_saved) {\n\t\t \n\t\tmemcpy_fromio(chip->mixer.array_saved, chip->mixer.array,\n\t\t\t      sizeof(*chip->mixer.array));\n\t}\n\tlola_setup_all_analog_gains(chip, PLAY, true);  \n}\n\nvoid lola_restore_mixer(struct lola *chip)\n{\n\tint i;\n\n\t \n\tif (chip->mixer.array_saved) {\n\t\t \n\t\tmemcpy_toio(chip->mixer.array, chip->mixer.array_saved,\n\t\t\t    sizeof(*chip->mixer.array));\n\t\t \n\t\tfor (i = 0; i < chip->mixer.src_phys_ins; i++)\n\t\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\t LOLA_VERB_SET_SOURCE_GAIN,\n\t\t\t\t\t i, 0);\n\t\tfor (i = 0; i < chip->mixer.src_stream_outs; i++)\n\t\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\t LOLA_VERB_SET_SOURCE_GAIN,\n\t\t\t\t\t chip->mixer.src_stream_out_ofs + i, 0);\n\t\tfor (i = 0; i < chip->mixer.dest_stream_ins; i++)\n\t\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\t LOLA_VERB_SET_DESTINATION_GAIN,\n\t\t\t\t\t i, 0);\n\t\tfor (i = 0; i < chip->mixer.dest_phys_outs; i++)\n\t\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t\t LOLA_VERB_SET_DESTINATION_GAIN,\n\t\t\t\t\t chip->mixer.dest_phys_out_ofs + i, 0);\n\t\tlola_codec_flush(chip);\n\t}\n}\n\n \n\nstatic int set_analog_volume(struct lola *chip, int dir,\n\t\t\t     unsigned int idx, unsigned int val,\n\t\t\t     bool external_call)\n{\n\tstruct lola_pin *pin;\n\tint err;\n\n\tif (idx >= chip->pin[dir].num_pins)\n\t\treturn -EINVAL;\n\tpin = &chip->pin[dir].pins[idx];\n\tif (!pin->is_analog || pin->amp_num_steps <= val)\n\t\treturn -EINVAL;\n\tif (external_call && pin->cur_gain_step == val)\n\t\treturn 0;\n\tif (external_call)\n\t\tlola_codec_flush(chip);\n\tdev_dbg(chip->card->dev,\n\t\t\"set_analog_volume (dir=%d idx=%d, volume=%d)\\n\",\n\t\t\tdir, idx, val);\n\terr = lola_codec_write(chip, pin->nid,\n\t\t\t       LOLA_VERB_SET_AMP_GAIN_MUTE, val, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (external_call)\n\t\tpin->cur_gain_step = val;\n\treturn 0;\n}\n\nint lola_set_src_config(struct lola *chip, unsigned int src_mask, bool update)\n{\n\tint ret = 0;\n\tint success = 0;\n\tint n, err;\n\n\t \n\tif ((chip->input_src_caps_mask & src_mask) != src_mask)\n\t\treturn -EINVAL;\n\t \n\tfor (n = 0; n < chip->pin[CAPT].num_pins; n += 2) {\n\t\tunsigned int mask = 3U << n;  \n\t\tunsigned int new_src, src_state;\n\t\tif (!(chip->input_src_caps_mask & mask))\n\t\t\tcontinue;\n\t\t \n\t\tnew_src = (src_mask & mask) != 0;\n\t\tif (update) {\n\t\t\tsrc_state = (chip->input_src_mask & mask) != 0;\n\t\t\tif (src_state == new_src)\n\t\t\t\tcontinue;    \n\t\t}\n\t\terr = lola_codec_write(chip, chip->pcm[CAPT].streams[n].nid,\n\t\t\t\t       LOLA_VERB_SET_SRC, new_src, 0);\n\t\tif (!err)\n\t\t\tsuccess++;\n\t\telse\n\t\t\tret = err;\n\t}\n\tif (success)\n\t\tret = lola_codec_flush(chip);\n\tif (!ret)\n\t\tchip->input_src_mask = src_mask;\n\treturn ret;\n}\n\n \nstatic int init_mixer_values(struct lola *chip)\n{\n\tint i;\n\n\t \n\tlola_set_src_config(chip, (1 << chip->pin[CAPT].num_pins) - 1, false);\n\n\t \n\tmemset_io(chip->mixer.array, 0, sizeof(*chip->mixer.array));\n\t \n\tfor (i = 0; i < chip->mixer.dest_stream_ins; i++)\n\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t LOLA_VERB_SET_DESTINATION_GAIN,\n\t\t\t\t i, 0);\n\t \n\tfor (i = 0; i < chip->mixer.dest_phys_outs; i++)\n\t\tlola_codec_write(chip, chip->mixer.nid,\n\t\t\t\t LOLA_VERB_SET_DESTINATION_GAIN,\n\t\t\t\t chip->mixer.dest_phys_out_ofs + i, 0);\n\n\t \n\tfor (i = 0; i < chip->mixer.src_phys_ins; i++)\n\t\tlola_mixer_set_src_gain(chip, i, 336, true);  \n\n\t \n\tfor (i = 0; i < chip->mixer.src_stream_outs; i++)\n\t\tlola_mixer_set_src_gain(chip,\n\t\t\t\t\ti + chip->mixer.src_stream_out_ofs,\n\t\t\t\t\t336, true);  \n\t \n\tfor (i = 0; i < chip->mixer.dest_stream_ins; i++) {\n\t\tint src = i % chip->mixer.src_phys_ins;\n\t\tlola_mixer_set_mapping_gain(chip, src, i, 336, true);\n\t}\n\t \n\tfor (i = 0; i < chip->mixer.src_stream_outs; i++) {\n\t\tint src = chip->mixer.src_stream_out_ofs + i;\n\t\tint dst = chip->mixer.dest_phys_out_ofs +\n\t\t\ti % chip->mixer.dest_phys_outs;\n\t\tlola_mixer_set_mapping_gain(chip, src, dst, 336, true);\n\t}\n\treturn 0;\n}\n\n \nstatic int lola_analog_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint dir = kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = chip->pin[dir].num_pins;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = chip->pin[dir].pins[0].amp_num_steps;\n\treturn 0;\n}\n\nstatic int lola_analog_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint dir = kcontrol->private_value;\n\tint i;\n\n\tfor (i = 0; i < chip->pin[dir].num_pins; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\tchip->pin[dir].pins[i].cur_gain_step;\n\treturn 0;\n}\n\nstatic int lola_analog_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint dir = kcontrol->private_value;\n\tint i, err;\n\n\tfor (i = 0; i < chip->pin[dir].num_pins; i++) {\n\t\terr = set_analog_volume(chip, dir, i,\n\t\t\t\t\tucontrol->value.integer.value[i],\n\t\t\t\t\ttrue);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int lola_analog_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t       unsigned int size, unsigned int __user *tlv)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint dir = kcontrol->private_value;\n\tunsigned int val1, val2;\n\tstruct lola_pin *pin;\n\n\tif (size < 4 * sizeof(unsigned int))\n\t\treturn -ENOMEM;\n\tpin = &chip->pin[dir].pins[0];\n\n\tval2 = pin->amp_step_size * 25;\n\tval1 = -1 * (int)pin->amp_offset * (int)val2;\n#ifdef TLV_DB_SCALE_MUTE\n\tval2 |= TLV_DB_SCALE_MUTE;\n#endif\n\tif (put_user(SNDRV_CTL_TLVT_DB_SCALE, tlv))\n\t\treturn -EFAULT;\n\tif (put_user(2 * sizeof(unsigned int), tlv + 1))\n\t\treturn -EFAULT;\n\tif (put_user(val1, tlv + 2))\n\t\treturn -EFAULT;\n\tif (put_user(val2, tlv + 3))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new lola_analog_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK),\n\t.info = lola_analog_vol_info,\n\t.get = lola_analog_vol_get,\n\t.put = lola_analog_vol_put,\n\t.tlv.c = lola_analog_vol_tlv,\n};\n\nstatic int create_analog_mixer(struct lola *chip, int dir, char *name)\n{\n\tif (!chip->pin[dir].num_pins)\n\t\treturn 0;\n\t \n\tif (chip->pin[dir].num_pins != chip->pin[dir].num_analog_pins)\n\t\treturn 0;\n\tlola_analog_mixer.name = name;\n\tlola_analog_mixer.private_value = dir;\n\treturn snd_ctl_add(chip->card,\n\t\t\t   snd_ctl_new1(&lola_analog_mixer, chip));\n}\n\n \nstatic int lola_input_src_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = chip->pin[CAPT].num_pins;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int lola_input_src_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint i;\n\n\tfor (i = 0; i < chip->pin[CAPT].num_pins; i++)\n\t\tucontrol->value.integer.value[i] =\n\t\t\t!!(chip->input_src_mask & (1 << i));\n\treturn 0;\n}\n\nstatic int lola_input_src_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tint i;\n\tunsigned int mask;\n\n\tmask = 0;\n\tfor (i = 0; i < chip->pin[CAPT].num_pins; i++)\n\t\tif (ucontrol->value.integer.value[i])\n\t\t\tmask |= 1 << i;\n\treturn lola_set_src_config(chip, mask, true);\n}\n\nstatic const struct snd_kcontrol_new lola_input_src_mixer = {\n\t.name = \"Digital SRC Capture Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = lola_input_src_info,\n\t.get = lola_input_src_get,\n\t.put = lola_input_src_put,\n};\n\n \nstatic int create_input_src_mixer(struct lola *chip)\n{\n\tif (!chip->input_src_caps_mask)\n\t\treturn 0;\n\n\treturn snd_ctl_add(chip->card,\n\t\t\t   snd_ctl_new1(&lola_input_src_mixer, chip));\n}\n\n \nstatic int lola_src_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int count = (kcontrol->private_value >> 8) & 0xff;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = count;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 409;\n\treturn 0;\n}\n\nstatic int lola_src_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int ofs = kcontrol->private_value & 0xff;\n\tunsigned int count = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned int mask, i;\n\n\tmask = readl(&chip->mixer.array->src_gain_enable);\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned int idx = ofs + i;\n\t\tunsigned short val;\n\t\tif (!(chip->mixer.src_mask & (1 << idx)))\n\t\t\treturn -EINVAL;\n\t\tif (mask & (1 << idx))\n\t\t\tval = readw(&chip->mixer.array->src_gain[idx]) + 1;\n\t\telse\n\t\t\tval = 0;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\treturn 0;\n}\n\nstatic int lola_src_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int ofs = kcontrol->private_value & 0xff;\n\tunsigned int count = (kcontrol->private_value >> 8) & 0xff;\n\tint i, err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned int idx = ofs + i;\n\t\tunsigned short val = ucontrol->value.integer.value[i];\n\t\tif (val)\n\t\t\tval--;\n\t\terr = lola_mixer_set_src_gain(chip, idx, val, !!val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(lola_src_gain_tlv, -8425, 25, 1);\n\nstatic struct snd_kcontrol_new lola_src_gain_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.info = lola_src_gain_info,\n\t.get = lola_src_gain_get,\n\t.put = lola_src_gain_put,\n\t.tlv.p = lola_src_gain_tlv,\n};\n\nstatic int create_src_gain_mixer(struct lola *chip,\n\t\t\t\t int num, int ofs, char *name)\n{\n\tlola_src_gain_mixer.name = name;\n\tlola_src_gain_mixer.private_value = ofs + (num << 8);\n\treturn snd_ctl_add(chip->card,\n\t\t\t   snd_ctl_new1(&lola_src_gain_mixer, chip));\n}\n\n#if 0  \n \nstatic int lola_dest_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tunsigned int src_num = (kcontrol->private_value >> 8) & 0xff;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = src_num;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 433;\n\treturn 0;\n}\n\nstatic int lola_dest_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int src_ofs = kcontrol->private_value & 0xff;\n\tunsigned int src_num = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned int dst_ofs = (kcontrol->private_value >> 16) & 0xff;\n\tunsigned int dst, mask, i;\n\n\tdst = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + dst_ofs;\n\tmask = readl(&chip->mixer.array->dest_mix_gain_enable[dst]);\n\tfor (i = 0; i < src_num; i++) {\n\t\tunsigned int src = src_ofs + i;\n\t\tunsigned short val;\n\t\tif (!(chip->mixer.src_mask & (1 << src)))\n\t\t\treturn -EINVAL;\n\t\tif (mask & (1 << dst))\n\t\t\tval = readw(&chip->mixer.array->dest_mix_gain[dst][src]) + 1;\n\t\telse\n\t\t\tval = 0;\n\t\tucontrol->value.integer.value[i] = val;\n\t}\n\treturn 0;\n}\n\nstatic int lola_dest_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct lola *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int src_ofs = kcontrol->private_value & 0xff;\n\tunsigned int src_num = (kcontrol->private_value >> 8) & 0xff;\n\tunsigned int dst_ofs = (kcontrol->private_value >> 16) & 0xff;\n\tunsigned int dst, mask;\n\tunsigned short gains[MAX_STREAM_COUNT];\n\tint i, num;\n\n\tmask = 0;\n\tnum = 0;\n\tfor (i = 0; i < src_num; i++) {\n\t\tunsigned short val = ucontrol->value.integer.value[i];\n\t\tif (val) {\n\t\t\tgains[num++] = val - 1;\n\t\t\tmask |= 1 << i;\n\t\t}\n\t}\n\tmask <<= src_ofs;\n\tdst = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id) + dst_ofs;\n\treturn lola_mixer_set_dest_gains(chip, dst, mask, gains);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(lola_dest_gain_tlv, -8425, 25, 1);\n\nstatic struct snd_kcontrol_new lola_dest_gain_mixer = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.info = lola_dest_gain_info,\n\t.get = lola_dest_gain_get,\n\t.put = lola_dest_gain_put,\n\t.tlv.p = lola_dest_gain_tlv,\n};\n\nstatic int create_dest_gain_mixer(struct lola *chip,\n\t\t\t\t  int src_num, int src_ofs,\n\t\t\t\t  int num, int ofs, char *name)\n{\n\tlola_dest_gain_mixer.count = num;\n\tlola_dest_gain_mixer.name = name;\n\tlola_dest_gain_mixer.private_value =\n\t\tsrc_ofs + (src_num << 8) + (ofs << 16) + (num << 24);\n\treturn snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&lola_dest_gain_mixer, chip));\n}\n#endif  \n\n \nint lola_create_mixer(struct lola *chip)\n{\n\tint err;\n\n\terr = create_analog_mixer(chip, PLAY, \"Analog Playback Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_analog_mixer(chip, CAPT, \"Analog Capture Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_input_src_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = create_src_gain_mixer(chip, chip->mixer.src_phys_ins, 0,\n\t\t\t\t    \"Digital Capture Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_src_gain_mixer(chip, chip->mixer.src_stream_outs,\n\t\t\t\t    chip->mixer.src_stream_out_ofs,\n\t\t\t\t    \"Digital Playback Volume\");\n\tif (err < 0)\n\t\treturn err;\n#if 0\n \n\terr = create_dest_gain_mixer(chip,\n\t\t\t\t     chip->mixer.src_phys_ins, 0,\n\t\t\t\t     chip->mixer.dest_stream_ins, 0,\n\t\t\t\t     \"Line Capture Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_dest_gain_mixer(chip,\n\t\t\t\t     chip->mixer.src_stream_outs,\n\t\t\t\t     chip->mixer.src_stream_out_ofs,\n\t\t\t\t     chip->mixer.dest_stream_ins, 0,\n\t\t\t\t     \"Stream-Loopback Capture Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_dest_gain_mixer(chip,\n\t\t\t\t     chip->mixer.src_phys_ins, 0,\n\t\t\t\t     chip->mixer.dest_phys_outs,\n\t\t\t\t     chip->mixer.dest_phys_out_ofs,\n\t\t\t\t     \"Line-Loopback Playback Volume\");\n\tif (err < 0)\n\t\treturn err;\n\terr = create_dest_gain_mixer(chip,\n\t\t\t\t     chip->mixer.src_stream_outs,\n\t\t\t\t     chip->mixer.src_stream_out_ofs,\n\t\t\t\t     chip->mixer.dest_phys_outs,\n\t\t\t\t     chip->mixer.dest_phys_out_ofs,\n\t\t\t\t     \"Stream Playback Volume\");\n\tif (err < 0)\n\t\treturn err;\n#endif  \n\treturn init_mixer_values(chip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}