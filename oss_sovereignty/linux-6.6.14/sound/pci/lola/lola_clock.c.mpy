{
  "module_name": "lola_clock.c",
  "hash_id": "88ea996a1fd80fbca90d589ba08848d8eda5e7fb293052507a680e50bbf7cd62",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/lola/lola_clock.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include \"lola.h\"\n\nunsigned int lola_sample_rate_convert(unsigned int coded)\n{\n\tunsigned int freq;\n\n\t \n\tswitch (coded & 0x3) {\n\tcase 0:     freq = 48000; break;\n\tcase 1:     freq = 44100; break;\n\tcase 2:     freq = 32000; break;\n\tdefault:    return 0;    \n\t}\n\n\t \n\tswitch (coded & 0x1c) {\n\tcase (0 << 2):    break;\n\tcase (4 << 2):    break;\n\tcase (1 << 2):    freq *= 2; break;\n\tcase (2 << 2):    freq *= 4; break;\n\tcase (5 << 2):    freq /= 2; break;\n\tcase (6 << 2):    freq /= 4; break;\n\tdefault:        return 0;    \n\t}\n\n\t \n\tswitch (coded & 0x60) {\n\tcase (0 << 5):    break;\n\tcase (1 << 5):    freq = (freq * 999) / 1000; break;\n\tcase (2 << 5):    freq = (freq * 1001) / 1000; break;\n\tdefault:        return 0;    \n\t}\n\treturn freq;\n}\n\n \n\n#define LOLA_MAXFREQ_AT_GRANULARITY_MIN         48000\n#define LOLA_MAXFREQ_AT_GRANULARITY_BELOW_MAX   96000\n\nstatic bool check_gran_clock_compatibility(struct lola *chip,\n\t\t\t\t\t   unsigned int val,\n\t\t\t\t\t   unsigned int freq)\n{\n\tif (!chip->granularity)\n\t\treturn true;\n\n\tif (val < LOLA_GRANULARITY_MIN || val > LOLA_GRANULARITY_MAX ||\n\t    (val % LOLA_GRANULARITY_STEP) != 0)\n\t\treturn false;\n\n\tif (val == LOLA_GRANULARITY_MIN) {\n\t\tif (freq > LOLA_MAXFREQ_AT_GRANULARITY_MIN)\n\t\t\treturn false;\n\t} else if (val < LOLA_GRANULARITY_MAX) {\n\t\tif (freq > LOLA_MAXFREQ_AT_GRANULARITY_BELOW_MAX)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint lola_set_granularity(struct lola *chip, unsigned int val, bool force)\n{\n\tint err;\n\n\tif (!force) {\n\t\tif (val == chip->granularity)\n\t\t\treturn 0;\n#if 0\n\t\t \n\t\tif (chip->audio_in_alloc_mask || chip->audio_out_alloc_mask)\n\t\t\treturn -EBUSY;\n#endif\n\t\tif (!check_gran_clock_compatibility(chip, val,\n\t\t\t\t\t\t    chip->clock.cur_freq))\n\t\t\treturn -EINVAL;\n\t}\n\n\tchip->granularity = val;\n\tval /= LOLA_GRANULARITY_STEP;\n\n\t \n\terr = lola_codec_write(chip, 1, LOLA_VERB_SET_GRANULARITY_STEPS,\n\t\t\t       val, 0);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tusleep_range(400 * val, 20000);\n\treturn lola_codec_flush(chip);\n}\n\n \n\nint lola_init_clock_widget(struct lola *chip, int nid)\n{\n\tunsigned int val;\n\tint i, j, nitems, nb_verbs, idx, idx_list;\n\tint err;\n\n\terr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"Can't read wcaps for 0x%x\\n\", nid);\n\t\treturn err;\n\t}\n\n\tif ((val & 0xfff00000) != 0x01f00000) {  \n\t\tdev_dbg(chip->card->dev, \"No valid clock widget\\n\");\n\t\treturn 0;\n\t}\n\n\tchip->clock.nid = nid;\n\tchip->clock.items = val & 0xff;\n\tdev_dbg(chip->card->dev, \"clock_list nid=%x, entries=%d\\n\", nid,\n\t\t    chip->clock.items);\n\tif (chip->clock.items > MAX_SAMPLE_CLOCK_COUNT) {\n\t\tdev_err(chip->card->dev, \"CLOCK_LIST too big: %d\\n\",\n\t\t       chip->clock.items);\n\t\treturn -EINVAL;\n\t}\n\n\tnitems = chip->clock.items;\n\tnb_verbs = DIV_ROUND_UP(nitems, 4);\n\tidx = 0;\n\tidx_list = 0;\n\tfor (i = 0; i < nb_verbs; i++) {\n\t\tunsigned int res_ex;\n\t\tunsigned short items[4];\n\n\t\terr = lola_codec_read(chip, nid, LOLA_VERB_GET_CLOCK_LIST,\n\t\t\t\t      idx, 0, &val, &res_ex);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"Can't read CLOCK_LIST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\titems[0] = val & 0xfff;\n\t\titems[1] = (val >> 16) & 0xfff;\n\t\titems[2] = res_ex & 0xfff;\n\t\titems[3] = (res_ex >> 16) & 0xfff;\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tunsigned char type = items[j] >> 8;\n\t\t\tunsigned int freq = items[j] & 0xff;\n\t\t\tint format = LOLA_CLOCK_FORMAT_NONE;\n\t\t\tbool add_clock = true;\n\t\t\tif (type == LOLA_CLOCK_TYPE_INTERNAL) {\n\t\t\t\tfreq = lola_sample_rate_convert(freq);\n\t\t\t\tif (freq < chip->sample_rate_min)\n\t\t\t\t\tadd_clock = false;\n\t\t\t\telse if (freq == 48000) {\n\t\t\t\t\tchip->clock.cur_index = idx_list;\n\t\t\t\t\tchip->clock.cur_freq = 48000;\n\t\t\t\t\tchip->clock.cur_valid = true;\n\t\t\t\t}\n\t\t\t} else if (type == LOLA_CLOCK_TYPE_VIDEO) {\n\t\t\t\tfreq = lola_sample_rate_convert(freq);\n\t\t\t\tif (freq < chip->sample_rate_min)\n\t\t\t\t\tadd_clock = false;\n\t\t\t\t \n\t\t\t\tif (items[j] & 0x80)\n\t\t\t\t\tformat = LOLA_CLOCK_FORMAT_NTSC;\n\t\t\t\telse\n\t\t\t\t\tformat = LOLA_CLOCK_FORMAT_PAL;\n\t\t\t}\n\t\t\tif (add_clock) {\n\t\t\t\tstruct lola_sample_clock *sc;\n\t\t\t\tsc = &chip->clock.sample_clock[idx_list];\n\t\t\t\tsc->type = type;\n\t\t\t\tsc->format = format;\n\t\t\t\tsc->freq = freq;\n\t\t\t\t \n\t\t\t\tchip->clock.idx_lookup[idx_list] = idx;\n\t\t\t\tidx_list++;\n\t\t\t} else {\n\t\t\t\tchip->clock.items--;\n\t\t\t}\n\t\t\tif (++idx >= nitems)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint lola_enable_clock_events(struct lola *chip)\n{\n\tunsigned int res;\n\tint err;\n\n\terr = lola_codec_read(chip, chip->clock.nid,\n\t\t\t      LOLA_VERB_SET_UNSOLICITED_ENABLE,\n\t\t\t      LOLA_UNSOLICITED_ENABLE | LOLA_UNSOLICITED_TAG,\n\t\t\t      0, &res, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (res) {\n\t\tdev_warn(chip->card->dev, \"error in enable_clock_events %d\\n\",\n\t\t       res);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint lola_set_clock_index(struct lola *chip, unsigned int idx)\n{\n\tunsigned int res;\n\tint err;\n\n\terr = lola_codec_read(chip, chip->clock.nid,\n\t\t\t      LOLA_VERB_SET_CLOCK_SELECT,\n\t\t\t      chip->clock.idx_lookup[idx],\n\t\t\t      0, &res, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (res) {\n\t\tdev_warn(chip->card->dev, \"error in set_clock %d\\n\", res);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nbool lola_update_ext_clock_freq(struct lola *chip, unsigned int val)\n{\n\tunsigned int tag;\n\n\t \n\tif (!val)\n\t\treturn false;\n\ttag = (val >> LOLA_UNSOL_RESP_TAG_OFFSET) & LOLA_UNSOLICITED_TAG_MASK;\n\tif (tag != LOLA_UNSOLICITED_TAG)\n\t\treturn false;\n\n\t \n\tif (chip->clock.sample_clock[chip->clock.cur_index].type !=\n\t    LOLA_CLOCK_TYPE_INTERNAL) {\n\t\tchip->clock.cur_freq = lola_sample_rate_convert(val & 0x7f);\n\t\tchip->clock.cur_valid = (val & 0x100) != 0;\n\t}\n\treturn true;\n}\n\nint lola_set_clock(struct lola *chip, int idx)\n{\n\tint freq = 0;\n\tbool valid = false;\n\n\tif (idx == chip->clock.cur_index) {\n\t\t \n\t\tfreq = chip->clock.cur_freq;\n\t\tvalid = chip->clock.cur_valid;\n\t} else if (chip->clock.sample_clock[idx].type ==\n\t\t   LOLA_CLOCK_TYPE_INTERNAL) {\n\t\t \n\t\tfreq = chip->clock.sample_clock[idx].freq;\n\t\tvalid = true;\n\t}\n\n\tif (!freq || !valid)\n\t\treturn -EINVAL;\n\n\tif (!check_gran_clock_compatibility(chip, chip->granularity, freq))\n\t\treturn -EINVAL;\n\n\tif (idx != chip->clock.cur_index) {\n\t\tint err = lola_set_clock_index(chip, idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\tchip->clock.cur_index = idx;\n\t\tchip->clock.cur_freq = freq;\n\t\tchip->clock.cur_valid = true;\n\t}\n\treturn 0;\n}\n\nint lola_set_sample_rate(struct lola *chip, int rate)\n{\n\tint i;\n\n\tif (chip->clock.cur_freq == rate && chip->clock.cur_valid)\n\t\treturn 0;\n\t \n\tfor (i = 0; i < chip->clock.items; i++) {\n\t\tif (chip->clock.sample_clock[i].type == LOLA_CLOCK_TYPE_INTERNAL &&\n\t\t    chip->clock.sample_clock[i].freq == rate)\n\t\t\tbreak;\n\t}\n\tif (i >= chip->clock.items)\n\t\treturn -EINVAL;\n\treturn lola_set_clock(chip, i);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}