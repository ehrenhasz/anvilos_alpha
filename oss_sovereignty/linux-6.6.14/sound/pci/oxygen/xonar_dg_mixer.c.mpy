{
  "module_name": "xonar_dg_mixer.c",
  "hash_id": "9b3b9ca6b7bab775452ff2a67d42df053f7c9b9baab09e320b9b8ba02c7334f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/xonar_dg_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n#include \"oxygen.h\"\n#include \"xonar_dg.h\"\n#include \"cs4245.h\"\n\n \n\nstatic int output_select_apply(struct oxygen *chip)\n{\n\tstruct dg *data = chip->model_data;\n\n\tdata->cs4245_shadow[CS4245_SIGNAL_SEL] &= ~CS4245_A_OUT_SEL_MASK;\n\tif (data->output_sel == PLAYBACK_DST_HP) {\n\t\t \n\t\toxygen_set_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\n\t} else if (data->output_sel == PLAYBACK_DST_HP_FP) {\n\t\t \n\t\toxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\n\t\tdata->cs4245_shadow[CS4245_SIGNAL_SEL] |= CS4245_A_OUT_SEL_DAC;\n\t} else {\n\t\t \n\t\toxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\n\t}\n\treturn cs4245_write_spi(chip, CS4245_SIGNAL_SEL);\n}\n\nstatic int output_select_info(struct snd_kcontrol *ctl,\n\t\t\t      struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[3] = {\n\t\t\"Stereo Headphones\",\n\t\t\"Stereo Headphones FP\",\n\t\t\"Multichannel\",\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 3, names);\n}\n\nstatic int output_select_get(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.enumerated.item[0] = data->output_sel;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int output_select_put(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tunsigned int new = value->value.enumerated.item[0];\n\tint changed = 0;\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\tif (data->output_sel != new) {\n\t\tdata->output_sel = new;\n\t\tret = output_select_apply(chip);\n\t\tchanged = ret >= 0 ? 1 : ret;\n\t\toxygen_update_dac_routing(chip);\n\t}\n\tmutex_unlock(&chip->mutex);\n\n\treturn changed;\n}\n\n \n\nstatic int hp_stereo_volume_info(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 255;\n\treturn 0;\n}\n\nstatic int hp_stereo_volume_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *val)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tunsigned int tmp;\n\n\tmutex_lock(&chip->mutex);\n\ttmp = (~data->cs4245_shadow[CS4245_DAC_A_CTRL]) & 255;\n\tval->value.integer.value[0] = tmp;\n\ttmp = (~data->cs4245_shadow[CS4245_DAC_B_CTRL]) & 255;\n\tval->value.integer.value[1] = tmp;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int hp_stereo_volume_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *val)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tint ret;\n\tint changed = 0;\n\tlong new1 = val->value.integer.value[0];\n\tlong new2 = val->value.integer.value[1];\n\n\tif ((new1 > 255) || (new1 < 0) || (new2 > 255) || (new2 < 0))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tif ((data->cs4245_shadow[CS4245_DAC_A_CTRL] != ~new1) ||\n\t    (data->cs4245_shadow[CS4245_DAC_B_CTRL] != ~new2)) {\n\t\tdata->cs4245_shadow[CS4245_DAC_A_CTRL] = ~new1;\n\t\tdata->cs4245_shadow[CS4245_DAC_B_CTRL] = ~new2;\n\t\tret = cs4245_write_spi(chip, CS4245_DAC_A_CTRL);\n\t\tif (ret >= 0)\n\t\t\tret = cs4245_write_spi(chip, CS4245_DAC_B_CTRL);\n\t\tchanged = ret >= 0 ? 1 : ret;\n\t}\n\tmutex_unlock(&chip->mutex);\n\n\treturn changed;\n}\n\n \n\nstatic int hp_mute_get(struct snd_kcontrol *ctl,\n\t\t\tstruct snd_ctl_elem_value *val)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tval->value.integer.value[0] =\n\t\t!(data->cs4245_shadow[CS4245_DAC_CTRL_1] & CS4245_MUTE_DAC);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int hp_mute_put(struct snd_kcontrol *ctl,\n\t\t\tstruct snd_ctl_elem_value *val)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tint ret;\n\tint changed;\n\n\tif (val->value.integer.value[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mutex);\n\tdata->cs4245_shadow[CS4245_DAC_CTRL_1] &= ~CS4245_MUTE_DAC;\n\tdata->cs4245_shadow[CS4245_DAC_CTRL_1] |=\n\t\t(~val->value.integer.value[0] << 2) & CS4245_MUTE_DAC;\n\tret = cs4245_write_spi(chip, CS4245_DAC_CTRL_1);\n\tchanged = ret >= 0 ? 1 : ret;\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n\nstatic int input_volume_apply(struct oxygen *chip, char left, char right)\n{\n\tstruct dg *data = chip->model_data;\n\tint ret;\n\n\tdata->cs4245_shadow[CS4245_PGA_A_CTRL] = left;\n\tdata->cs4245_shadow[CS4245_PGA_B_CTRL] = right;\n\tret = cs4245_write_spi(chip, CS4245_PGA_A_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn cs4245_write_spi(chip, CS4245_PGA_B_CTRL);\n}\n\nstatic int input_vol_info(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 2 * -12;\n\tinfo->value.integer.max = 2 * 12;\n\treturn 0;\n}\n\nstatic int input_vol_get(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tunsigned int idx = ctl->private_value;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.integer.value[0] = data->input_vol[idx][0];\n\tvalue->value.integer.value[1] = data->input_vol[idx][1];\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int input_vol_put(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tunsigned int idx = ctl->private_value;\n\tint changed = 0;\n\tint ret = 0;\n\n\tif (value->value.integer.value[0] < 2 * -12 ||\n\t    value->value.integer.value[0] > 2 * 12 ||\n\t    value->value.integer.value[1] < 2 * -12 ||\n\t    value->value.integer.value[1] > 2 * 12)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mutex);\n\tchanged = data->input_vol[idx][0] != value->value.integer.value[0] ||\n\t\t  data->input_vol[idx][1] != value->value.integer.value[1];\n\tif (changed) {\n\t\tdata->input_vol[idx][0] = value->value.integer.value[0];\n\t\tdata->input_vol[idx][1] = value->value.integer.value[1];\n\t\tif (idx == data->input_sel) {\n\t\t\tret = input_volume_apply(chip,\n\t\t\t\tdata->input_vol[idx][0],\n\t\t\t\tdata->input_vol[idx][1]);\n\t\t}\n\t\tchanged = ret >= 0 ? 1 : ret;\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n\nstatic int input_source_apply(struct oxygen *chip)\n{\n\tstruct dg *data = chip->model_data;\n\n\tdata->cs4245_shadow[CS4245_ANALOG_IN] &= ~CS4245_SEL_MASK;\n\tif (data->input_sel == CAPTURE_SRC_FP_MIC)\n\t\tdata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_2;\n\telse if (data->input_sel == CAPTURE_SRC_LINE)\n\t\tdata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_4;\n\telse if (data->input_sel != CAPTURE_SRC_MIC)\n\t\tdata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_1;\n\treturn cs4245_write_spi(chip, CS4245_ANALOG_IN);\n}\n\nstatic int input_sel_info(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[4] = {\n\t\t\"Mic\", \"Front Mic\", \"Line\", \"Aux\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 4, names);\n}\n\nstatic int input_sel_get(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.enumerated.item[0] = data->input_sel;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int input_sel_put(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tint changed;\n\tint ret;\n\n\tif (value->value.enumerated.item[0] > 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tchanged = value->value.enumerated.item[0] != data->input_sel;\n\tif (changed) {\n\t\tdata->input_sel = value->value.enumerated.item[0];\n\n\t\tret = input_source_apply(chip);\n\t\tif (ret >= 0)\n\t\t\tret = input_volume_apply(chip,\n\t\t\t\tdata->input_vol[data->input_sel][0],\n\t\t\t\tdata->input_vol[data->input_sel][1]);\n\t\tchanged = ret >= 0 ? 1 : ret;\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n \n\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = { \"Active\", \"Frozen\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t!!(data->cs4245_shadow[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);\n\treturn 0;\n}\n\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct dg *data = chip->model_data;\n\tu8 reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;\n\tif (value->value.enumerated.item[0])\n\t\treg |= CS4245_HPF_FREEZE;\n\tchanged = reg != data->cs4245_shadow[CS4245_ADC_CTRL];\n\tif (changed) {\n\t\tdata->cs4245_shadow[CS4245_ADC_CTRL] = reg;\n\t\tcs4245_write_spi(chip, CS4245_ADC_CTRL);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n#define INPUT_VOLUME(xname, index) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n\t.info = input_vol_info, \\\n\t.get = input_vol_get, \\\n\t.put = input_vol_put, \\\n\t.tlv = { .p = pga_db_scale }, \\\n\t.private_value = index, \\\n}\nstatic const DECLARE_TLV_DB_MINMAX(hp_db_scale, -12550, 0);\nstatic const DECLARE_TLV_DB_MINMAX(pga_db_scale, -1200, 1200);\nstatic const struct snd_kcontrol_new dg_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Output Playback Enum\",\n\t\t.info = output_select_info,\n\t\t.get = output_select_get,\n\t\t.put = output_select_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphone Playback Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = hp_stereo_volume_info,\n\t\t.get = hp_stereo_volume_get,\n\t\t.put = hp_stereo_volume_put,\n\t\t.tlv = { .p = hp_db_scale, },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphone Playback Switch\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = hp_mute_get,\n\t\t.put = hp_mute_put,\n\t},\n\tINPUT_VOLUME(\"Mic Capture Volume\", CAPTURE_SRC_MIC),\n\tINPUT_VOLUME(\"Front Mic Capture Volume\", CAPTURE_SRC_FP_MIC),\n\tINPUT_VOLUME(\"Line Capture Volume\", CAPTURE_SRC_LINE),\n\tINPUT_VOLUME(\"Aux Capture Volume\", CAPTURE_SRC_AUX),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Capture Source\",\n\t\t.info = input_sel_info,\n\t\t.get = input_sel_get,\n\t\t.put = input_sel_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC High-pass Filter Capture Enum\",\n\t\t.info = hpf_info,\n\t\t.get = hpf_get,\n\t\t.put = hpf_put,\n\t},\n};\n\nstatic int dg_control_filter(struct snd_kcontrol_new *template)\n{\n\tif (!strncmp(template->name, \"Master Playback \", 16))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int dg_mixer_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\tint err;\n\n\toutput_select_apply(chip);\n\tinput_source_apply(chip);\n\toxygen_update_dac_routing(chip);\n\n\tfor (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t  snd_ctl_new1(&dg_controls[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nconst struct oxygen_model model_xonar_dg = {\n\t.longname = \"C-Media Oxygen HD Audio\",\n\t.chip = \"CMI8786\",\n\t.init = dg_init,\n\t.control_filter = dg_control_filter,\n\t.mixer_init = dg_mixer_init,\n\t.cleanup = dg_cleanup,\n\t.suspend = dg_suspend,\n\t.resume = dg_resume,\n\t.set_dac_params = set_cs4245_dac_params,\n\t.set_adc_params = set_cs4245_adc_params,\n\t.adjust_dac_routing = adjust_dg_dac_routing,\n\t.dump_registers = dump_cs4245_registers,\n\t.model_data_size = sizeof(struct dg),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_1 |\n\t\t\t CAPTURE_1_FROM_SPDIF,\n\t.dac_channels_pcm = 6,\n\t.dac_channels_mixer = 0,\n\t.function_flags = OXYGEN_FUNCTION_SPI,\n\t.dac_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}