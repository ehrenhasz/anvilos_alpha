{
  "module_name": "oxygen_pcm.c",
  "hash_id": "4c8a97c605bfeb17041fd6bf3e51db18badfb5ef0e97b59d8d4d0ef050b7b371",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/oxygen_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"oxygen.h\"\n\n \n#define BUFFER_BYTES_MAX\t\t((1 << 16) * 4)\n \n#define BUFFER_BYTES_MAX_MULTICH\t((1 << 24) * 4)\n\n#define FIFO_BYTES\t\t\t256\n#define FIFO_BYTES_MULTICH\t\t1024\n\n#define PERIOD_BYTES_MIN\t\t64\n\n#define DEFAULT_BUFFER_BYTES\t\t(BUFFER_BYTES_MAX / 2)\n#define DEFAULT_BUFFER_BYTES_MULTICH\t(1024 * 1024)\n\nstatic const struct snd_pcm_hardware oxygen_stereo_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_SYNC_START |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t SNDRV_PCM_RATE_44100 |\n\t\t SNDRV_PCM_RATE_48000 |\n\t\t SNDRV_PCM_RATE_64000 |\n\t\t SNDRV_PCM_RATE_88200 |\n\t\t SNDRV_PCM_RATE_96000 |\n\t\t SNDRV_PCM_RATE_176400 |\n\t\t SNDRV_PCM_RATE_192000,\n\t.rate_min = 32000,\n\t.rate_max = 192000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = BUFFER_BYTES_MAX,\n\t.periods_min = 1,\n\t.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,\n\t.fifo_size = FIFO_BYTES,\n};\nstatic const struct snd_pcm_hardware oxygen_multichannel_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_SYNC_START |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t SNDRV_PCM_RATE_44100 |\n\t\t SNDRV_PCM_RATE_48000 |\n\t\t SNDRV_PCM_RATE_64000 |\n\t\t SNDRV_PCM_RATE_88200 |\n\t\t SNDRV_PCM_RATE_96000 |\n\t\t SNDRV_PCM_RATE_176400 |\n\t\t SNDRV_PCM_RATE_192000,\n\t.rate_min = 32000,\n\t.rate_max = 192000,\n\t.channels_min = 2,\n\t.channels_max = 8,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX_MULTICH,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = BUFFER_BYTES_MAX_MULTICH,\n\t.periods_min = 1,\n\t.periods_max = BUFFER_BYTES_MAX_MULTICH / PERIOD_BYTES_MIN,\n\t.fifo_size = FIFO_BYTES_MULTICH,\n};\nstatic const struct snd_pcm_hardware oxygen_ac97_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_SYNC_START |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = BUFFER_BYTES_MAX,\n\t.periods_min = 1,\n\t.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,\n\t.fifo_size = FIFO_BYTES,\n};\n\nstatic const struct snd_pcm_hardware *const oxygen_hardware[PCM_COUNT] = {\n\t[PCM_A] = &oxygen_stereo_hardware,\n\t[PCM_B] = &oxygen_stereo_hardware,\n\t[PCM_C] = &oxygen_stereo_hardware,\n\t[PCM_SPDIF] = &oxygen_stereo_hardware,\n\t[PCM_MULTICH] = &oxygen_multichannel_hardware,\n\t[PCM_AC97] = &oxygen_ac97_hardware,\n};\n\nstatic inline unsigned int\noxygen_substream_channel(struct snd_pcm_substream *substream)\n{\n\treturn (unsigned int)(uintptr_t)substream->runtime->private_data;\n}\n\nstatic int oxygen_open(struct snd_pcm_substream *substream,\n\t\t       unsigned int channel)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->private_data = (void *)(uintptr_t)channel;\n\tif (channel == PCM_B && chip->has_ac97_1 &&\n\t    (chip->model.device_config & CAPTURE_2_FROM_AC97_1))\n\t\truntime->hw = oxygen_ac97_hardware;\n\telse\n\t\truntime->hw = *oxygen_hardware[channel];\n\tswitch (channel) {\n\tcase PCM_C:\n\t\tif (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {\n\t\t\truntime->hw.rates &= ~(SNDRV_PCM_RATE_32000 |\n\t\t\t\t\t       SNDRV_PCM_RATE_64000);\n\t\t\truntime->hw.rate_min = 44100;\n\t\t}\n\t\tfallthrough;\n\tcase PCM_A:\n\tcase PCM_B:\n\t\truntime->hw.fifo_size = 0;\n\t\tbreak;\n\tcase PCM_MULTICH:\n\t\truntime->hw.channels_max = chip->model.dac_channels_pcm;\n\t\tbreak;\n\t}\n\tif (chip->model.pcm_hardware_filter)\n\t\tchip->model.pcm_hardware_filter(channel, &runtime->hw);\n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\n\tif (err < 0)\n\t\treturn err;\n\tif (runtime->hw.formats & SNDRV_PCM_FMTBIT_S32_LE) {\n\t\terr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (runtime->hw.channels_max > 2) {\n\t\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t\t SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t\t 2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tsnd_pcm_set_sync(substream);\n\tchip->streams[channel] = substream;\n\n\tmutex_lock(&chip->mutex);\n\tchip->pcm_active |= 1 << channel;\n\tif (channel == PCM_SPDIF) {\n\t\tchip->spdif_pcm_bits = chip->spdif_bits;\n\t\tchip->controls[CONTROL_SPDIF_PCM]->vd[0].access &=\n\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &chip->controls[CONTROL_SPDIF_PCM]->id);\n\t}\n\tmutex_unlock(&chip->mutex);\n\n\treturn 0;\n}\n\nstatic int oxygen_rec_a_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_A);\n}\n\nstatic int oxygen_rec_b_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_B);\n}\n\nstatic int oxygen_rec_c_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_C);\n}\n\nstatic int oxygen_spdif_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_SPDIF);\n}\n\nstatic int oxygen_multich_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_MULTICH);\n}\n\nstatic int oxygen_ac97_open(struct snd_pcm_substream *substream)\n{\n\treturn oxygen_open(substream, PCM_AC97);\n}\n\nstatic int oxygen_close(struct snd_pcm_substream *substream)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tunsigned int channel = oxygen_substream_channel(substream);\n\n\tmutex_lock(&chip->mutex);\n\tchip->pcm_active &= ~(1 << channel);\n\tif (channel == PCM_SPDIF) {\n\t\tchip->controls[CONTROL_SPDIF_PCM]->vd[0].access |=\n\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &chip->controls[CONTROL_SPDIF_PCM]->id);\n\t}\n\tif (channel == PCM_SPDIF || channel == PCM_MULTICH)\n\t\toxygen_update_spdif_source(chip);\n\tmutex_unlock(&chip->mutex);\n\n\tchip->streams[channel] = NULL;\n\treturn 0;\n}\n\nstatic unsigned int oxygen_format(struct snd_pcm_hw_params *hw_params)\n{\n\tif (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)\n\t\treturn OXYGEN_FORMAT_24;\n\telse\n\t\treturn OXYGEN_FORMAT_16;\n}\n\nstatic unsigned int oxygen_rate(struct snd_pcm_hw_params *hw_params)\n{\n\tswitch (params_rate(hw_params)) {\n\tcase 32000:\n\t\treturn OXYGEN_RATE_32000;\n\tcase 44100:\n\t\treturn OXYGEN_RATE_44100;\n\tdefault:  \n\t\treturn OXYGEN_RATE_48000;\n\tcase 64000:\n\t\treturn OXYGEN_RATE_64000;\n\tcase 88200:\n\t\treturn OXYGEN_RATE_88200;\n\tcase 96000:\n\t\treturn OXYGEN_RATE_96000;\n\tcase 176400:\n\t\treturn OXYGEN_RATE_176400;\n\tcase 192000:\n\t\treturn OXYGEN_RATE_192000;\n\t}\n}\n\nstatic unsigned int oxygen_i2s_bits(struct snd_pcm_hw_params *hw_params)\n{\n\tif (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)\n\t\treturn OXYGEN_I2S_BITS_24;\n\telse\n\t\treturn OXYGEN_I2S_BITS_16;\n}\n\nstatic unsigned int oxygen_play_channels(struct snd_pcm_hw_params *hw_params)\n{\n\tswitch (params_channels(hw_params)) {\n\tdefault:  \n\t\treturn OXYGEN_PLAY_CHANNELS_2;\n\tcase 4:\n\t\treturn OXYGEN_PLAY_CHANNELS_4;\n\tcase 6:\n\t\treturn OXYGEN_PLAY_CHANNELS_6;\n\tcase 8:\n\t\treturn OXYGEN_PLAY_CHANNELS_8;\n\t}\n}\n\nstatic const unsigned int channel_base_registers[PCM_COUNT] = {\n\t[PCM_A] = OXYGEN_DMA_A_ADDRESS,\n\t[PCM_B] = OXYGEN_DMA_B_ADDRESS,\n\t[PCM_C] = OXYGEN_DMA_C_ADDRESS,\n\t[PCM_SPDIF] = OXYGEN_DMA_SPDIF_ADDRESS,\n\t[PCM_MULTICH] = OXYGEN_DMA_MULTICH_ADDRESS,\n\t[PCM_AC97] = OXYGEN_DMA_AC97_ADDRESS,\n};\n\nstatic int oxygen_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tunsigned int channel = oxygen_substream_channel(substream);\n\n\toxygen_write32(chip, channel_base_registers[channel],\n\t\t       (u32)substream->runtime->dma_addr);\n\tif (channel == PCM_MULTICH) {\n\t\toxygen_write32(chip, OXYGEN_DMA_MULTICH_COUNT,\n\t\t\t       params_buffer_bytes(hw_params) / 4 - 1);\n\t\toxygen_write32(chip, OXYGEN_DMA_MULTICH_TCOUNT,\n\t\t\t       params_period_bytes(hw_params) / 4 - 1);\n\t} else {\n\t\toxygen_write16(chip, channel_base_registers[channel] + 4,\n\t\t\t       params_buffer_bytes(hw_params) / 4 - 1);\n\t\toxygen_write16(chip, channel_base_registers[channel] + 6,\n\t\t\t       params_period_bytes(hw_params) / 4 - 1);\n\t}\n\treturn 0;\n}\n\nstatic u16 get_mclk(struct oxygen *chip, unsigned int channel,\n\t\t    struct snd_pcm_hw_params *params)\n{\n\tunsigned int mclks, shift;\n\n\tif (channel == PCM_MULTICH)\n\t\tmclks = chip->model.dac_mclks;\n\telse\n\t\tmclks = chip->model.adc_mclks;\n\n\tif (params_rate(params) <= 48000)\n\t\tshift = 0;\n\telse if (params_rate(params) <= 96000)\n\t\tshift = 2;\n\telse\n\t\tshift = 4;\n\n\treturn OXYGEN_I2S_MCLK(mclks >> shift);\n}\n\nstatic int oxygen_rec_a_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\terr = oxygen_hw_params(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\n\t\t\t     oxygen_format(hw_params) << OXYGEN_REC_FORMAT_A_SHIFT,\n\t\t\t     OXYGEN_REC_FORMAT_A_MASK);\n\toxygen_write16_masked(chip, OXYGEN_I2S_A_FORMAT,\n\t\t\t      oxygen_rate(hw_params) |\n\t\t\t      chip->model.adc_i2s_format |\n\t\t\t      get_mclk(chip, PCM_A, hw_params) |\n\t\t\t      oxygen_i2s_bits(hw_params),\n\t\t\t      OXYGEN_I2S_RATE_MASK |\n\t\t\t      OXYGEN_I2S_FORMAT_MASK |\n\t\t\t      OXYGEN_I2S_MCLK_MASK |\n\t\t\t      OXYGEN_I2S_BITS_MASK);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tmutex_lock(&chip->mutex);\n\tchip->model.set_adc_params(chip, hw_params);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int oxygen_rec_b_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tint is_ac97;\n\tint err;\n\n\terr = oxygen_hw_params(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tis_ac97 = chip->has_ac97_1 &&\n\t\t(chip->model.device_config & CAPTURE_2_FROM_AC97_1);\n\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\n\t\t\t     oxygen_format(hw_params) << OXYGEN_REC_FORMAT_B_SHIFT,\n\t\t\t     OXYGEN_REC_FORMAT_B_MASK);\n\tif (!is_ac97)\n\t\toxygen_write16_masked(chip, OXYGEN_I2S_B_FORMAT,\n\t\t\t\t      oxygen_rate(hw_params) |\n\t\t\t\t      chip->model.adc_i2s_format |\n\t\t\t\t      get_mclk(chip, PCM_B, hw_params) |\n\t\t\t\t      oxygen_i2s_bits(hw_params),\n\t\t\t\t      OXYGEN_I2S_RATE_MASK |\n\t\t\t\t      OXYGEN_I2S_FORMAT_MASK |\n\t\t\t\t      OXYGEN_I2S_MCLK_MASK |\n\t\t\t\t      OXYGEN_I2S_BITS_MASK);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tif (!is_ac97) {\n\t\tmutex_lock(&chip->mutex);\n\t\tchip->model.set_adc_params(chip, hw_params);\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\treturn 0;\n}\n\nstatic int oxygen_rec_c_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tbool is_spdif;\n\tint err;\n\n\terr = oxygen_hw_params(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tis_spdif = chip->model.device_config & CAPTURE_1_FROM_SPDIF;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\n\t\t\t     oxygen_format(hw_params) << OXYGEN_REC_FORMAT_C_SHIFT,\n\t\t\t     OXYGEN_REC_FORMAT_C_MASK);\n\tif (!is_spdif)\n\t\toxygen_write16_masked(chip, OXYGEN_I2S_C_FORMAT,\n\t\t\t\t      oxygen_rate(hw_params) |\n\t\t\t\t      chip->model.adc_i2s_format |\n\t\t\t\t      get_mclk(chip, PCM_B, hw_params) |\n\t\t\t\t      oxygen_i2s_bits(hw_params),\n\t\t\t\t      OXYGEN_I2S_RATE_MASK |\n\t\t\t\t      OXYGEN_I2S_FORMAT_MASK |\n\t\t\t\t      OXYGEN_I2S_MCLK_MASK |\n\t\t\t\t      OXYGEN_I2S_BITS_MASK);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tif (!is_spdif) {\n\t\tmutex_lock(&chip->mutex);\n\t\tchip->model.set_adc_params(chip, hw_params);\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\treturn 0;\n}\n\nstatic int oxygen_spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\terr = oxygen_hw_params(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&chip->mutex);\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t    OXYGEN_SPDIF_OUT_ENABLE);\n\toxygen_write8_masked(chip, OXYGEN_PLAY_FORMAT,\n\t\t\t     oxygen_format(hw_params) << OXYGEN_SPDIF_FORMAT_SHIFT,\n\t\t\t     OXYGEN_SPDIF_FORMAT_MASK);\n\toxygen_write32_masked(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t      oxygen_rate(hw_params) << OXYGEN_SPDIF_OUT_RATE_SHIFT,\n\t\t\t      OXYGEN_SPDIF_OUT_RATE_MASK);\n\toxygen_update_spdif_source(chip);\n\tspin_unlock_irq(&chip->reg_lock);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int oxygen_multich_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\terr = oxygen_hw_params(substream, hw_params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmutex_lock(&chip->mutex);\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_write8_masked(chip, OXYGEN_PLAY_CHANNELS,\n\t\t\t     oxygen_play_channels(hw_params),\n\t\t\t     OXYGEN_PLAY_CHANNELS_MASK);\n\toxygen_write8_masked(chip, OXYGEN_PLAY_FORMAT,\n\t\t\t     oxygen_format(hw_params) << OXYGEN_MULTICH_FORMAT_SHIFT,\n\t\t\t     OXYGEN_MULTICH_FORMAT_MASK);\n\toxygen_write16_masked(chip, OXYGEN_I2S_MULTICH_FORMAT,\n\t\t\t      oxygen_rate(hw_params) |\n\t\t\t      chip->model.dac_i2s_format |\n\t\t\t      get_mclk(chip, PCM_MULTICH, hw_params) |\n\t\t\t      oxygen_i2s_bits(hw_params),\n\t\t\t      OXYGEN_I2S_RATE_MASK |\n\t\t\t      OXYGEN_I2S_FORMAT_MASK |\n\t\t\t      OXYGEN_I2S_MCLK_MASK |\n\t\t\t      OXYGEN_I2S_BITS_MASK);\n\toxygen_update_spdif_source(chip);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tchip->model.set_dac_params(chip, hw_params);\n\toxygen_update_dac_routing(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int oxygen_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tunsigned int channel = oxygen_substream_channel(substream);\n\tunsigned int channel_mask = 1 << channel;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->interrupt_mask &= ~channel_mask;\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\n\n\toxygen_set_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\n\toxygen_clear_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn 0;\n}\n\nstatic int oxygen_spdif_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t    OXYGEN_SPDIF_OUT_ENABLE);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn oxygen_hw_free(substream);\n}\n\nstatic int oxygen_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tunsigned int channel = oxygen_substream_channel(substream);\n\tunsigned int channel_mask = 1 << channel;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toxygen_set_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\n\toxygen_clear_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\n\n\tif (substream->runtime->no_period_wakeup)\n\t\tchip->interrupt_mask &= ~channel_mask;\n\telse\n\t\tchip->interrupt_mask |= channel_mask;\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int oxygen_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tunsigned int mask = 0;\n\tint pausing;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tpausing = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tpausing = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) == chip) {\n\t\t\tmask |= 1 << oxygen_substream_channel(s);\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t}\n\t}\n\n\tspin_lock(&chip->reg_lock);\n\tif (!pausing) {\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\tchip->pcm_running |= mask;\n\t\telse\n\t\t\tchip->pcm_running &= ~mask;\n\t\toxygen_write8(chip, OXYGEN_DMA_STATUS, chip->pcm_running);\n\t} else {\n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\n\t\t\toxygen_set_bits8(chip, OXYGEN_DMA_PAUSE, mask);\n\t\telse\n\t\t\toxygen_clear_bits8(chip, OXYGEN_DMA_PAUSE, mask);\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t oxygen_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct oxygen *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int channel = oxygen_substream_channel(substream);\n\tu32 curr_addr;\n\n\t \n\tcurr_addr = oxygen_read32(chip, channel_base_registers[channel]);\n\treturn bytes_to_frames(runtime, curr_addr - (u32)runtime->dma_addr);\n}\n\nstatic const struct snd_pcm_ops oxygen_rec_a_ops = {\n\t.open      = oxygen_rec_a_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_rec_a_hw_params,\n\t.hw_free   = oxygen_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nstatic const struct snd_pcm_ops oxygen_rec_b_ops = {\n\t.open      = oxygen_rec_b_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_rec_b_hw_params,\n\t.hw_free   = oxygen_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nstatic const struct snd_pcm_ops oxygen_rec_c_ops = {\n\t.open      = oxygen_rec_c_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_rec_c_hw_params,\n\t.hw_free   = oxygen_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nstatic const struct snd_pcm_ops oxygen_spdif_ops = {\n\t.open      = oxygen_spdif_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_spdif_hw_params,\n\t.hw_free   = oxygen_spdif_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nstatic const struct snd_pcm_ops oxygen_multich_ops = {\n\t.open      = oxygen_multich_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_multich_hw_params,\n\t.hw_free   = oxygen_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nstatic const struct snd_pcm_ops oxygen_ac97_ops = {\n\t.open      = oxygen_ac97_open,\n\t.close     = oxygen_close,\n\t.hw_params = oxygen_hw_params,\n\t.hw_free   = oxygen_hw_free,\n\t.prepare   = oxygen_prepare,\n\t.trigger   = oxygen_trigger,\n\t.pointer   = oxygen_pointer,\n};\n\nint oxygen_pcm_init(struct oxygen *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint outs, ins;\n\tint err;\n\n\touts = !!(chip->model.device_config & PLAYBACK_0_TO_I2S);\n\tins = !!(chip->model.device_config & (CAPTURE_0_FROM_I2S_1 |\n\t\t\t\t\t      CAPTURE_0_FROM_I2S_2));\n\tif (outs | ins) {\n\t\terr = snd_pcm_new(chip->card, \"Multichannel\",\n\t\t\t\t  0, outs, ins, &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (outs)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t&oxygen_multich_ops);\n\t\tif (chip->model.device_config & CAPTURE_0_FROM_I2S_1)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&oxygen_rec_a_ops);\n\t\telse if (chip->model.device_config & CAPTURE_0_FROM_I2S_2)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&oxygen_rec_b_ops);\n\t\tpcm->private_data = chip;\n\t\tstrcpy(pcm->name, \"Multichannel\");\n\t\tif (outs)\n\t\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\n\t\t\t\t\t\t   SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t   &chip->pci->dev,\n\t\t\t\t\t\t   DEFAULT_BUFFER_BYTES_MULTICH,\n\t\t\t\t\t\t   BUFFER_BYTES_MAX_MULTICH);\n\t\tif (ins)\n\t\t\tsnd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\n\t\t\t\t\t\t   SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t\t   &chip->pci->dev,\n\t\t\t\t\t\t   DEFAULT_BUFFER_BYTES,\n\t\t\t\t\t\t   BUFFER_BYTES_MAX);\n\t}\n\n\touts = !!(chip->model.device_config & PLAYBACK_1_TO_SPDIF);\n\tins = !!(chip->model.device_config & CAPTURE_1_FROM_SPDIF);\n\tif (outs | ins) {\n\t\terr = snd_pcm_new(chip->card, \"Digital\", 1, outs, ins, &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (outs)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t&oxygen_spdif_ops);\n\t\tif (ins)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&oxygen_rec_c_ops);\n\t\tpcm->private_data = chip;\n\t\tstrcpy(pcm->name, \"Digital\");\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       &chip->pci->dev,\n\t\t\t\t\t       DEFAULT_BUFFER_BYTES,\n\t\t\t\t\t       BUFFER_BYTES_MAX);\n\t}\n\n\tif (chip->has_ac97_1) {\n\t\touts = !!(chip->model.device_config & PLAYBACK_2_TO_AC97_1);\n\t\tins = !!(chip->model.device_config & CAPTURE_2_FROM_AC97_1);\n\t} else {\n\t\touts = 0;\n\t\tins = !!(chip->model.device_config & CAPTURE_2_FROM_I2S_2);\n\t}\n\tif (outs | ins) {\n\t\terr = snd_pcm_new(chip->card, outs ? \"AC97\" : \"Analog2\",\n\t\t\t\t  2, outs, ins, &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (outs) {\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t&oxygen_ac97_ops);\n\t\t\toxygen_write8_masked(chip, OXYGEN_REC_ROUTING,\n\t\t\t\t\t     OXYGEN_REC_B_ROUTE_AC97_1,\n\t\t\t\t\t     OXYGEN_REC_B_ROUTE_MASK);\n\t\t}\n\t\tif (ins)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t&oxygen_rec_b_ops);\n\t\tpcm->private_data = chip;\n\t\tstrcpy(pcm->name, outs ? \"Front Panel\" : \"Analog 2\");\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       &chip->pci->dev,\n\t\t\t\t\t       DEFAULT_BUFFER_BYTES,\n\t\t\t\t\t       BUFFER_BYTES_MAX);\n\t}\n\n\tins = !!(chip->model.device_config & CAPTURE_3_FROM_I2S_3);\n\tif (ins) {\n\t\terr = snd_pcm_new(chip->card, \"Analog3\", 3, 0, ins, &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&oxygen_rec_c_ops);\n\t\toxygen_write8_masked(chip, OXYGEN_REC_ROUTING,\n\t\t\t\t     OXYGEN_REC_C_ROUTE_I2S_ADC_3,\n\t\t\t\t     OXYGEN_REC_C_ROUTE_MASK);\n\t\tpcm->private_data = chip;\n\t\tstrcpy(pcm->name, \"Analog 3\");\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t       &chip->pci->dev,\n\t\t\t\t\t       DEFAULT_BUFFER_BYTES,\n\t\t\t\t\t       BUFFER_BYTES_MAX);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}