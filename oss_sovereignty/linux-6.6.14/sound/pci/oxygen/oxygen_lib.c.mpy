{
  "module_name": "oxygen_lib.c",
  "hash_id": "0976d20430b8c62e04629f78bec7b0d533e5568043b71d48f439294d7fc8902e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/oxygen_lib.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/ac97_codec.h>\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/mpu401.h>\n#include <sound/pcm.h>\n#include \"oxygen.h\"\n#include \"cm9780.h\"\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"C-Media CMI8788 helper library\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DRIVER \"oxygen\"\n\nstatic inline int oxygen_uart_input_ready(struct oxygen *chip)\n{\n\treturn !(oxygen_read8(chip, OXYGEN_MPU401 + 1) & MPU401_RX_EMPTY);\n}\n\nstatic void oxygen_read_uart(struct oxygen *chip)\n{\n\tif (unlikely(!oxygen_uart_input_ready(chip))) {\n\t\t \n\t\toxygen_read8(chip, OXYGEN_MPU401);\n\t\treturn;\n\t}\n\tdo {\n\t\tu8 data = oxygen_read8(chip, OXYGEN_MPU401);\n\t\tif (data == MPU401_ACK)\n\t\t\tcontinue;\n\t\tif (chip->uart_input_count >= ARRAY_SIZE(chip->uart_input))\n\t\t\tchip->uart_input_count = 0;\n\t\tchip->uart_input[chip->uart_input_count++] = data;\n\t} while (oxygen_uart_input_ready(chip));\n\tif (chip->model.uart_input)\n\t\tchip->model.uart_input(chip);\n}\n\nstatic irqreturn_t oxygen_interrupt(int dummy, void *dev_id)\n{\n\tstruct oxygen *chip = dev_id;\n\tunsigned int status, clear, elapsed_streams, i;\n\n\tstatus = oxygen_read16(chip, OXYGEN_INTERRUPT_STATUS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&chip->reg_lock);\n\n\tclear = status & (OXYGEN_CHANNEL_A |\n\t\t\t  OXYGEN_CHANNEL_B |\n\t\t\t  OXYGEN_CHANNEL_C |\n\t\t\t  OXYGEN_CHANNEL_SPDIF |\n\t\t\t  OXYGEN_CHANNEL_MULTICH |\n\t\t\t  OXYGEN_CHANNEL_AC97 |\n\t\t\t  OXYGEN_INT_SPDIF_IN_DETECT |\n\t\t\t  OXYGEN_INT_GPIO |\n\t\t\t  OXYGEN_INT_AC97);\n\tif (clear) {\n\t\tif (clear & OXYGEN_INT_SPDIF_IN_DETECT)\n\t\t\tchip->interrupt_mask &= ~OXYGEN_INT_SPDIF_IN_DETECT;\n\t\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\n\t\t\t       chip->interrupt_mask & ~clear);\n\t\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\n\t\t\t       chip->interrupt_mask);\n\t}\n\n\telapsed_streams = status & chip->pcm_running;\n\n\tspin_unlock(&chip->reg_lock);\n\n\tfor (i = 0; i < PCM_COUNT; ++i)\n\t\tif ((elapsed_streams & (1 << i)) && chip->streams[i])\n\t\t\tsnd_pcm_period_elapsed(chip->streams[i]);\n\n\tif (status & OXYGEN_INT_SPDIF_IN_DETECT) {\n\t\tspin_lock(&chip->reg_lock);\n\t\ti = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\n\t\tif (i & (OXYGEN_SPDIF_SENSE_INT | OXYGEN_SPDIF_LOCK_INT |\n\t\t\t OXYGEN_SPDIF_RATE_INT)) {\n\t\t\t \n\t\t\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL, i);\n\t\t\tschedule_work(&chip->spdif_input_bits_work);\n\t\t}\n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\n\tif (status & OXYGEN_INT_GPIO)\n\t\tschedule_work(&chip->gpio_work);\n\n\tif (status & OXYGEN_INT_MIDI) {\n\t\tif (chip->midi)\n\t\t\tsnd_mpu401_uart_interrupt(0, chip->midi->private_data);\n\t\telse\n\t\t\toxygen_read_uart(chip);\n\t}\n\n\tif (status & OXYGEN_INT_AC97)\n\t\twake_up(&chip->ac97_waitqueue);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void oxygen_spdif_input_bits_changed(struct work_struct *work)\n{\n\tstruct oxygen *chip = container_of(work, struct oxygen,\n\t\t\t\t\t   spdif_input_bits_work);\n\tu32 reg;\n\n\t \n\tmsleep(1);\n\tspin_lock_irq(&chip->reg_lock);\n\treg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\n\tif ((reg & (OXYGEN_SPDIF_SENSE_STATUS |\n\t\t    OXYGEN_SPDIF_LOCK_STATUS))\n\t    == OXYGEN_SPDIF_SENSE_STATUS) {\n\t\t \n\t\treg ^= OXYGEN_SPDIF_IN_CLOCK_MASK;\n\t\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL, reg);\n\t\tspin_unlock_irq(&chip->reg_lock);\n\t\tmsleep(1);\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\treg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\n\t\tif ((reg & (OXYGEN_SPDIF_SENSE_STATUS |\n\t\t\t    OXYGEN_SPDIF_LOCK_STATUS))\n\t\t    == OXYGEN_SPDIF_SENSE_STATUS) {\n\t\t\t \n\t\t\tif ((reg & OXYGEN_SPDIF_IN_CLOCK_MASK)\n\t\t\t    == OXYGEN_SPDIF_IN_CLOCK_192) {\n\t\t\t\t \n\t\t\t\treg &= ~OXYGEN_SPDIF_IN_CLOCK_MASK;\n\t\t\t\treg |= OXYGEN_SPDIF_IN_CLOCK_96;\n\t\t\t\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL, reg);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tif (chip->controls[CONTROL_SPDIF_INPUT_BITS]) {\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\tchip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;\n\t\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\n\t\t\t       chip->interrupt_mask);\n\t\tspin_unlock_irq(&chip->reg_lock);\n\n\t\t \n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->controls[CONTROL_SPDIF_INPUT_BITS]->id);\n\t}\n}\n\nstatic void oxygen_gpio_changed(struct work_struct *work)\n{\n\tstruct oxygen *chip = container_of(work, struct oxygen, gpio_work);\n\n\tif (chip->model.gpio_changed)\n\t\tchip->model.gpio_changed(chip);\n}\n\nstatic void oxygen_proc_read(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct oxygen *chip = entry->private_data;\n\tint i, j;\n\n\tswitch (oxygen_read8(chip, OXYGEN_REVISION) & OXYGEN_PACKAGE_ID_MASK) {\n\tcase OXYGEN_PACKAGE_ID_8786: i = '6'; break;\n\tcase OXYGEN_PACKAGE_ID_8787: i = '7'; break;\n\tcase OXYGEN_PACKAGE_ID_8788: i = '8'; break;\n\tdefault:                     i = '?'; break;\n\t}\n\tsnd_iprintf(buffer, \"CMI878%c:\\n\", i);\n\tfor (i = 0; i < OXYGEN_IO_SIZE; i += 0x10) {\n\t\tsnd_iprintf(buffer, \"%02x:\", i);\n\t\tfor (j = 0; j < 0x10; ++j)\n\t\t\tsnd_iprintf(buffer, \" %02x\", oxygen_read8(chip, i + j));\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\tif (mutex_lock_interruptible(&chip->mutex) < 0)\n\t\treturn;\n\tif (chip->has_ac97_0) {\n\t\tsnd_iprintf(buffer, \"\\nAC97:\\n\");\n\t\tfor (i = 0; i < 0x80; i += 0x10) {\n\t\t\tsnd_iprintf(buffer, \"%02x:\", i);\n\t\t\tfor (j = 0; j < 0x10; j += 2)\n\t\t\t\tsnd_iprintf(buffer, \" %04x\",\n\t\t\t\t\t    oxygen_read_ac97(chip, 0, i + j));\n\t\t\tsnd_iprintf(buffer, \"\\n\");\n\t\t}\n\t}\n\tif (chip->has_ac97_1) {\n\t\tsnd_iprintf(buffer, \"\\nAC97 2:\\n\");\n\t\tfor (i = 0; i < 0x80; i += 0x10) {\n\t\t\tsnd_iprintf(buffer, \"%02x:\", i);\n\t\t\tfor (j = 0; j < 0x10; j += 2)\n\t\t\t\tsnd_iprintf(buffer, \" %04x\",\n\t\t\t\t\t    oxygen_read_ac97(chip, 1, i + j));\n\t\t\tsnd_iprintf(buffer, \"\\n\");\n\t\t}\n\t}\n\tmutex_unlock(&chip->mutex);\n\tif (chip->model.dump_registers)\n\t\tchip->model.dump_registers(chip, buffer);\n}\n\nstatic void oxygen_proc_init(struct oxygen *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"oxygen\", chip, oxygen_proc_read);\n}\n\nstatic const struct pci_device_id *\noxygen_search_pci_id(struct oxygen *chip, const struct pci_device_id ids[])\n{\n\tu16 subdevice;\n\n\t \n\toxygen_clear_bits8(chip, OXYGEN_FUNCTION,\n\t\t\t   OXYGEN_FUNCTION_ENABLE_SPI_4_5);\n\t \n\tsubdevice = oxygen_read_eeprom(chip, 2);\n\t \n\tif (subdevice == 0xffff && oxygen_read_eeprom(chip, 1) == 0xffff)\n\t\tsubdevice = 0x8788;\n\t \n\tfor (; ids->vendor; ++ids)\n\t\tif (ids->subdevice == subdevice &&\n\t\t    ids->driver_data != BROKEN_EEPROM_DRIVER_DATA)\n\t\t\treturn ids;\n\treturn NULL;\n}\n\nstatic void oxygen_restore_eeprom(struct oxygen *chip,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\tu16 eeprom_id;\n\n\teeprom_id = oxygen_read_eeprom(chip, 0);\n\tif (eeprom_id != OXYGEN_EEPROM_ID &&\n\t    (eeprom_id != 0xffff || id->subdevice != 0x8788)) {\n\t\t \n\t\toxygen_write_eeprom(chip, 1, id->subvendor);\n\t\toxygen_write_eeprom(chip, 0, OXYGEN_EEPROM_ID);\n\n\t\toxygen_set_bits8(chip, OXYGEN_MISC,\n\t\t\t\t OXYGEN_MISC_WRITE_PCI_SUBID);\n\t\tpci_write_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID,\n\t\t\t\t      id->subvendor);\n\t\tpci_write_config_word(chip->pci, PCI_SUBSYSTEM_ID,\n\t\t\t\t      id->subdevice);\n\t\toxygen_clear_bits8(chip, OXYGEN_MISC,\n\t\t\t\t   OXYGEN_MISC_WRITE_PCI_SUBID);\n\n\t\tdev_info(chip->card->dev, \"EEPROM ID restored\\n\");\n\t}\n}\n\nstatic void configure_pcie_bridge(struct pci_dev *pci)\n{\n\tenum { PEX811X, PI7C9X110, XIO2001 };\n\tstatic const struct pci_device_id bridge_ids[] = {\n\t\t{ PCI_VDEVICE(PLX, 0x8111), .driver_data = PEX811X },\n\t\t{ PCI_VDEVICE(PLX, 0x8112), .driver_data = PEX811X },\n\t\t{ PCI_DEVICE(0x12d8, 0xe110), .driver_data = PI7C9X110 },\n\t\t{ PCI_VDEVICE(TI, 0x8240), .driver_data = XIO2001 },\n\t\t{ }\n\t};\n\tstruct pci_dev *bridge;\n\tconst struct pci_device_id *id;\n\tu32 tmp;\n\n\tif (!pci->bus || !pci->bus->self)\n\t\treturn;\n\tbridge = pci->bus->self;\n\n\tid = pci_match_id(bridge_ids, bridge);\n\tif (!id)\n\t\treturn;\n\n\tswitch (id->driver_data) {\n\tcase PEX811X:\t \n\t\tpci_read_config_dword(bridge, 0x48, &tmp);\n\t\ttmp |= 1;\t \n\t\ttmp |= 1 << 11;\t \n\t\tpci_write_config_dword(bridge, 0x48, tmp);\n\n\t\tpci_write_config_dword(bridge, 0x84, 0x0c);\n\t\tpci_read_config_dword(bridge, 0x88, &tmp);\n\t\ttmp &= ~(7 << 27);\n\t\ttmp |= 2 << 27;\t \n\t\tpci_write_config_dword(bridge, 0x88, tmp);\n\t\tbreak;\n\n\tcase PI7C9X110:\t \n\t\tpci_read_config_dword(bridge, 0x40, &tmp);\n\t\ttmp |= 1;\t \n\t\tpci_write_config_dword(bridge, 0x40, tmp);\n\t\tbreak;\n\n\tcase XIO2001:  \n\t\tpci_read_config_dword(bridge, 0xe8, &tmp);\n\t\ttmp &= ~0xf;\t \n\t\ttmp &= ~(0xf << 8);\n\t\ttmp |= 1 << 8;\t \n\t\tpci_write_config_dword(bridge, 0xe8, tmp);\n\t\tbreak;\n\t}\n}\n\nstatic void oxygen_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\n\tchip->dac_routing = 1;\n\tfor (i = 0; i < 8; ++i)\n\t\tchip->dac_volume[i] = chip->model.dac_volume_min;\n\tchip->dac_mute = 1;\n\tchip->spdif_playback_enable = 0;\n\tchip->spdif_bits = OXYGEN_SPDIF_C | OXYGEN_SPDIF_ORIGINAL |\n\t\t(IEC958_AES1_CON_PCM_CODER << OXYGEN_SPDIF_CATEGORY_SHIFT);\n\tchip->spdif_pcm_bits = chip->spdif_bits;\n\n\tif (!(oxygen_read8(chip, OXYGEN_REVISION) & OXYGEN_REVISION_2))\n\t\toxygen_set_bits8(chip, OXYGEN_MISC,\n\t\t\t\t OXYGEN_MISC_PCI_MEM_W_1_CLOCK);\n\n\ti = oxygen_read16(chip, OXYGEN_AC97_CONTROL);\n\tchip->has_ac97_0 = (i & OXYGEN_AC97_CODEC_0) != 0;\n\tchip->has_ac97_1 = (i & OXYGEN_AC97_CODEC_1) != 0;\n\n\toxygen_write8_masked(chip, OXYGEN_FUNCTION,\n\t\t\t     OXYGEN_FUNCTION_RESET_CODEC |\n\t\t\t     chip->model.function_flags,\n\t\t\t     OXYGEN_FUNCTION_RESET_CODEC |\n\t\t\t     OXYGEN_FUNCTION_2WIRE_SPI_MASK |\n\t\t\t     OXYGEN_FUNCTION_ENABLE_SPI_4_5);\n\toxygen_write8(chip, OXYGEN_DMA_STATUS, 0);\n\toxygen_write8(chip, OXYGEN_DMA_PAUSE, 0);\n\toxygen_write8(chip, OXYGEN_PLAY_CHANNELS,\n\t\t      OXYGEN_PLAY_CHANNELS_2 |\n\t\t      OXYGEN_DMA_A_BURST_8 |\n\t\t      OXYGEN_DMA_MULTICH_BURST_8);\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\n\toxygen_write8_masked(chip, OXYGEN_MISC,\n\t\t\t     chip->model.misc_flags,\n\t\t\t     OXYGEN_MISC_WRITE_PCI_SUBID |\n\t\t\t     OXYGEN_MISC_REC_C_FROM_SPDIF |\n\t\t\t     OXYGEN_MISC_REC_B_FROM_AC97 |\n\t\t\t     OXYGEN_MISC_REC_A_FROM_MULTICH |\n\t\t\t     OXYGEN_MISC_MIDI);\n\toxygen_write8(chip, OXYGEN_REC_FORMAT,\n\t\t      (OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_A_SHIFT) |\n\t\t      (OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_B_SHIFT) |\n\t\t      (OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_C_SHIFT));\n\toxygen_write8(chip, OXYGEN_PLAY_FORMAT,\n\t\t      (OXYGEN_FORMAT_16 << OXYGEN_SPDIF_FORMAT_SHIFT) |\n\t\t      (OXYGEN_FORMAT_16 << OXYGEN_MULTICH_FORMAT_SHIFT));\n\toxygen_write8(chip, OXYGEN_REC_CHANNELS, OXYGEN_REC_CHANNELS_2_2_2);\n\toxygen_write16(chip, OXYGEN_I2S_MULTICH_FORMAT,\n\t\t       OXYGEN_RATE_48000 |\n\t\t       chip->model.dac_i2s_format |\n\t\t       OXYGEN_I2S_MCLK(chip->model.dac_mclks) |\n\t\t       OXYGEN_I2S_BITS_16 |\n\t\t       OXYGEN_I2S_MASTER |\n\t\t       OXYGEN_I2S_BCLK_64);\n\tif (chip->model.device_config & CAPTURE_0_FROM_I2S_1)\n\t\toxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\n\t\t\t       OXYGEN_RATE_48000 |\n\t\t\t       chip->model.adc_i2s_format |\n\t\t\t       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |\n\t\t\t       OXYGEN_I2S_BITS_16 |\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_BCLK_64);\n\telse\n\t\toxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_MUTE_MCLK);\n\tif (chip->model.device_config & (CAPTURE_0_FROM_I2S_2 |\n\t\t\t\t\t CAPTURE_2_FROM_I2S_2))\n\t\toxygen_write16(chip, OXYGEN_I2S_B_FORMAT,\n\t\t\t       OXYGEN_RATE_48000 |\n\t\t\t       chip->model.adc_i2s_format |\n\t\t\t       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |\n\t\t\t       OXYGEN_I2S_BITS_16 |\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_BCLK_64);\n\telse\n\t\toxygen_write16(chip, OXYGEN_I2S_B_FORMAT,\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_MUTE_MCLK);\n\tif (chip->model.device_config & CAPTURE_3_FROM_I2S_3)\n\t\toxygen_write16(chip, OXYGEN_I2S_C_FORMAT,\n\t\t\t       OXYGEN_RATE_48000 |\n\t\t\t       chip->model.adc_i2s_format |\n\t\t\t       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |\n\t\t\t       OXYGEN_I2S_BITS_16 |\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_BCLK_64);\n\telse\n\t\toxygen_write16(chip, OXYGEN_I2S_C_FORMAT,\n\t\t\t       OXYGEN_I2S_MASTER |\n\t\t\t       OXYGEN_I2S_MUTE_MCLK);\n\toxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t    OXYGEN_SPDIF_OUT_ENABLE |\n\t\t\t    OXYGEN_SPDIF_LOOPBACK);\n\tif (chip->model.device_config & CAPTURE_1_FROM_SPDIF)\n\t\toxygen_write32_masked(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t\t      OXYGEN_SPDIF_SENSE_MASK |\n\t\t\t\t      OXYGEN_SPDIF_LOCK_MASK |\n\t\t\t\t      OXYGEN_SPDIF_RATE_MASK |\n\t\t\t\t      OXYGEN_SPDIF_LOCK_PAR |\n\t\t\t\t      OXYGEN_SPDIF_IN_CLOCK_96,\n\t\t\t\t      OXYGEN_SPDIF_SENSE_MASK |\n\t\t\t\t      OXYGEN_SPDIF_LOCK_MASK |\n\t\t\t\t      OXYGEN_SPDIF_RATE_MASK |\n\t\t\t\t      OXYGEN_SPDIF_SENSE_PAR |\n\t\t\t\t      OXYGEN_SPDIF_LOCK_PAR |\n\t\t\t\t      OXYGEN_SPDIF_IN_CLOCK_MASK);\n\telse\n\t\toxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t\t    OXYGEN_SPDIF_SENSE_MASK |\n\t\t\t\t    OXYGEN_SPDIF_LOCK_MASK |\n\t\t\t\t    OXYGEN_SPDIF_RATE_MASK);\n\toxygen_write32(chip, OXYGEN_SPDIF_OUTPUT_BITS, chip->spdif_bits);\n\toxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\n\t\t       OXYGEN_2WIRE_LENGTH_8 |\n\t\t       OXYGEN_2WIRE_INTERRUPT_MASK |\n\t\t       OXYGEN_2WIRE_SPEED_STANDARD);\n\toxygen_clear_bits8(chip, OXYGEN_MPU401_CONTROL, OXYGEN_MPU401_LOOPBACK);\n\toxygen_write8(chip, OXYGEN_GPI_INTERRUPT_MASK, 0);\n\toxygen_write16(chip, OXYGEN_GPIO_INTERRUPT_MASK, 0);\n\toxygen_write16(chip, OXYGEN_PLAY_ROUTING,\n\t\t       OXYGEN_PLAY_MULTICH_I2S_DAC |\n\t\t       OXYGEN_PLAY_SPDIF_SPDIF |\n\t\t       (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t       (1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t       (2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t       (3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT));\n\toxygen_write8(chip, OXYGEN_REC_ROUTING,\n\t\t      OXYGEN_REC_A_ROUTE_I2S_ADC_1 |\n\t\t      OXYGEN_REC_B_ROUTE_I2S_ADC_2 |\n\t\t      OXYGEN_REC_C_ROUTE_SPDIF);\n\toxygen_write8(chip, OXYGEN_ADC_MONITOR, 0);\n\toxygen_write8(chip, OXYGEN_A_MONITOR_ROUTING,\n\t\t      (0 << OXYGEN_A_MONITOR_ROUTE_0_SHIFT) |\n\t\t      (1 << OXYGEN_A_MONITOR_ROUTE_1_SHIFT) |\n\t\t      (2 << OXYGEN_A_MONITOR_ROUTE_2_SHIFT) |\n\t\t      (3 << OXYGEN_A_MONITOR_ROUTE_3_SHIFT));\n\n\tif (chip->has_ac97_0 | chip->has_ac97_1)\n\t\toxygen_write8(chip, OXYGEN_AC97_INTERRUPT_MASK,\n\t\t\t      OXYGEN_AC97_INT_READ_DONE |\n\t\t\t      OXYGEN_AC97_INT_WRITE_DONE);\n\telse\n\t\toxygen_write8(chip, OXYGEN_AC97_INTERRUPT_MASK, 0);\n\toxygen_write32(chip, OXYGEN_AC97_OUT_CONFIG, 0);\n\toxygen_write32(chip, OXYGEN_AC97_IN_CONFIG, 0);\n\tif (!(chip->has_ac97_0 | chip->has_ac97_1))\n\t\toxygen_set_bits16(chip, OXYGEN_AC97_CONTROL,\n\t\t\t\t  OXYGEN_AC97_CLOCK_DISABLE);\n\tif (!chip->has_ac97_0) {\n\t\toxygen_set_bits16(chip, OXYGEN_AC97_CONTROL,\n\t\t\t\t  OXYGEN_AC97_NO_CODEC_0);\n\t} else {\n\t\toxygen_write_ac97(chip, 0, AC97_RESET, 0);\n\t\tmsleep(1);\n\t\toxygen_ac97_set_bits(chip, 0, CM9780_GPIO_SETUP,\n\t\t\t\t     CM9780_GPIO0IO | CM9780_GPIO1IO);\n\t\toxygen_ac97_set_bits(chip, 0, CM9780_MIXER,\n\t\t\t\t     CM9780_BSTSEL | CM9780_STRO_MIC |\n\t\t\t\t     CM9780_MIX2FR | CM9780_PCBSW);\n\t\toxygen_ac97_set_bits(chip, 0, CM9780_JACK,\n\t\t\t\t     CM9780_RSOE | CM9780_CBOE |\n\t\t\t\t     CM9780_SSOE | CM9780_FROE |\n\t\t\t\t     CM9780_MIC2MIC | CM9780_LI2LI);\n\t\toxygen_write_ac97(chip, 0, AC97_MASTER, 0x0000);\n\t\toxygen_write_ac97(chip, 0, AC97_PC_BEEP, 0x8000);\n\t\toxygen_write_ac97(chip, 0, AC97_MIC, 0x8808);\n\t\toxygen_write_ac97(chip, 0, AC97_LINE, 0x0808);\n\t\toxygen_write_ac97(chip, 0, AC97_CD, 0x8808);\n\t\toxygen_write_ac97(chip, 0, AC97_VIDEO, 0x8808);\n\t\toxygen_write_ac97(chip, 0, AC97_AUX, 0x8808);\n\t\toxygen_write_ac97(chip, 0, AC97_REC_GAIN, 0x8000);\n\t\toxygen_write_ac97(chip, 0, AC97_CENTER_LFE_MASTER, 0x8080);\n\t\toxygen_write_ac97(chip, 0, AC97_SURROUND_MASTER, 0x8080);\n\t\toxygen_ac97_clear_bits(chip, 0, CM9780_GPIO_STATUS,\n\t\t\t\t       CM9780_GPO0);\n\t\t \n\t\toxygen_ac97_set_bits(chip, 0, AC97_POWERDOWN,\n\t\t\t\t     AC97_PD_PR0 | AC97_PD_PR1);\n\t\toxygen_ac97_set_bits(chip, 0, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_PRI | AC97_EA_PRJ | AC97_EA_PRK);\n\t}\n\tif (chip->has_ac97_1) {\n\t\toxygen_set_bits32(chip, OXYGEN_AC97_OUT_CONFIG,\n\t\t\t\t  OXYGEN_AC97_CODEC1_SLOT3 |\n\t\t\t\t  OXYGEN_AC97_CODEC1_SLOT4);\n\t\toxygen_write_ac97(chip, 1, AC97_RESET, 0);\n\t\tmsleep(1);\n\t\toxygen_write_ac97(chip, 1, AC97_MASTER, 0x0000);\n\t\toxygen_write_ac97(chip, 1, AC97_HEADPHONE, 0x8000);\n\t\toxygen_write_ac97(chip, 1, AC97_PC_BEEP, 0x8000);\n\t\toxygen_write_ac97(chip, 1, AC97_MIC, 0x8808);\n\t\toxygen_write_ac97(chip, 1, AC97_LINE, 0x8808);\n\t\toxygen_write_ac97(chip, 1, AC97_CD, 0x8808);\n\t\toxygen_write_ac97(chip, 1, AC97_VIDEO, 0x8808);\n\t\toxygen_write_ac97(chip, 1, AC97_AUX, 0x8808);\n\t\toxygen_write_ac97(chip, 1, AC97_PCM, 0x0808);\n\t\toxygen_write_ac97(chip, 1, AC97_REC_SEL, 0x0000);\n\t\toxygen_write_ac97(chip, 1, AC97_REC_GAIN, 0x0000);\n\t\toxygen_ac97_set_bits(chip, 1, 0x6a, 0x0040);\n\t}\n}\n\nstatic void oxygen_shutdown(struct oxygen *chip)\n{\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->interrupt_mask = 0;\n\tchip->pcm_running = 0;\n\toxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\n\tspin_unlock_irq(&chip->reg_lock);\n}\n\nstatic void oxygen_card_free(struct snd_card *card)\n{\n\tstruct oxygen *chip = card->private_data;\n\n\toxygen_shutdown(chip);\n\tflush_work(&chip->spdif_input_bits_work);\n\tflush_work(&chip->gpio_work);\n\tchip->model.cleanup(chip);\n\tmutex_destroy(&chip->mutex);\n}\n\nstatic int __oxygen_pci_probe(struct pci_dev *pci, int index, char *id,\n\t\t     struct module *owner,\n\t\t     const struct pci_device_id *ids,\n\t\t     int (*get_model)(struct oxygen *chip,\n\t\t\t\t      const struct pci_device_id *id\n\t\t\t\t     )\n\t\t    )\n{\n\tstruct snd_card *card;\n\tstruct oxygen *chip;\n\tconst struct pci_device_id *pci_id;\n\tint err;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, owner,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip = card->private_data;\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tspin_lock_init(&chip->reg_lock);\n\tmutex_init(&chip->mutex);\n\tINIT_WORK(&chip->spdif_input_bits_work,\n\t\t  oxygen_spdif_input_bits_changed);\n\tINIT_WORK(&chip->gpio_work, oxygen_gpio_changed);\n\tinit_waitqueue_head(&chip->ac97_waitqueue);\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_request_regions(pci, DRIVER);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"cannot reserve PCI resources\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(pci_resource_flags(pci, 0) & IORESOURCE_IO) ||\n\t    pci_resource_len(pci, 0) < OXYGEN_IO_SIZE) {\n\t\tdev_err(card->dev, \"invalid PCI I/O range\\n\");\n\t\treturn -ENXIO;\n\t}\n\tchip->addr = pci_resource_start(pci, 0);\n\n\tpci_id = oxygen_search_pci_id(chip, ids);\n\tif (!pci_id)\n\t\treturn -ENODEV;\n\n\toxygen_restore_eeprom(chip, pci_id);\n\terr = get_model(chip, pci_id);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->model.model_data_size) {\n\t\tchip->model_data = devm_kzalloc(&pci->dev,\n\t\t\t\t\t\tchip->model.model_data_size,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!chip->model_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpci_set_master(pci);\n\tcard->private_free = oxygen_card_free;\n\n\tconfigure_pcie_bridge(pci);\n\toxygen_init(chip);\n\tchip->model.init(chip);\n\n\terr = devm_request_irq(&pci->dev, pci->irq, oxygen_interrupt,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"cannot grab interrupt %d\\n\", pci->irq);\n\t\treturn err;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\tstrcpy(card->driver, chip->model.chip);\n\tstrcpy(card->shortname, chip->model.shortname);\n\tsprintf(card->longname, \"%s at %#lx, irq %i\",\n\t\tchip->model.longname, chip->addr, chip->irq);\n\tstrcpy(card->mixername, chip->model.chip);\n\tsnd_component_add(card, chip->model.chip);\n\n\terr = oxygen_pcm_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = oxygen_mixer_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->model.device_config & (MIDI_OUTPUT | MIDI_INPUT)) {\n\t\tunsigned int info_flags =\n\t\t\t\tMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK;\n\t\tif (chip->model.device_config & MIDI_OUTPUT)\n\t\t\tinfo_flags |= MPU401_INFO_OUTPUT;\n\t\tif (chip->model.device_config & MIDI_INPUT)\n\t\t\tinfo_flags |= MPU401_INFO_INPUT;\n\t\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,\n\t\t\t\t\t  chip->addr + OXYGEN_MPU401,\n\t\t\t\t\t  info_flags, -1, &chip->midi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\toxygen_proc_init(chip);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tif (chip->model.device_config & CAPTURE_1_FROM_SPDIF)\n\t\tchip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;\n\tif (chip->has_ac97_0 | chip->has_ac97_1)\n\t\tchip->interrupt_mask |= OXYGEN_INT_AC97;\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nint oxygen_pci_probe(struct pci_dev *pci, int index, char *id,\n\t\t     struct module *owner,\n\t\t     const struct pci_device_id *ids,\n\t\t     int (*get_model)(struct oxygen *chip,\n\t\t\t\t      const struct pci_device_id *id))\n{\n\treturn snd_card_free_on_error(&pci->dev,\n\t\t\t\t      __oxygen_pci_probe(pci, index, id, owner, ids, get_model));\n}\nEXPORT_SYMBOL(oxygen_pci_probe);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int oxygen_pci_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct oxygen *chip = card->private_data;\n\tunsigned int saved_interrupt_mask;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\tif (chip->model.suspend)\n\t\tchip->model.suspend(chip);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tsaved_interrupt_mask = chip->interrupt_mask;\n\tchip->interrupt_mask = 0;\n\toxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tflush_work(&chip->spdif_input_bits_work);\n\tflush_work(&chip->gpio_work);\n\tchip->interrupt_mask = saved_interrupt_mask;\n\treturn 0;\n}\n\nstatic const u32 registers_to_restore[OXYGEN_IO_SIZE / 32] = {\n\t0xffffffff, 0x00ff077f, 0x00011d08, 0x007f00ff,\n\t0x00300000, 0x00000fe4, 0x0ff7001f, 0x00000000\n};\nstatic const u32 ac97_registers_to_restore[2][0x40 / 32] = {\n\t{ 0x18284fa2, 0x03060000 },\n\t{ 0x00007fa6, 0x00200000 }\n};\n\nstatic inline int is_bit_set(const u32 *bitmap, unsigned int bit)\n{\n\treturn bitmap[bit / 32] & (1 << (bit & 31));\n}\n\nstatic void oxygen_restore_ac97(struct oxygen *chip, unsigned int codec)\n{\n\tunsigned int i;\n\n\toxygen_write_ac97(chip, codec, AC97_RESET, 0);\n\tmsleep(1);\n\tfor (i = 1; i < 0x40; ++i)\n\t\tif (is_bit_set(ac97_registers_to_restore[codec], i))\n\t\t\toxygen_write_ac97(chip, codec, i * 2,\n\t\t\t\t\t  chip->saved_ac97_registers[codec][i]);\n}\n\nstatic int oxygen_pci_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct oxygen *chip = card->private_data;\n\tunsigned int i;\n\n\toxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\n\tfor (i = 0; i < OXYGEN_IO_SIZE; ++i)\n\t\tif (is_bit_set(registers_to_restore, i))\n\t\t\toxygen_write8(chip, i, chip->saved_registers._8[i]);\n\tif (chip->has_ac97_0)\n\t\toxygen_restore_ac97(chip, 0);\n\tif (chip->has_ac97_1)\n\t\toxygen_restore_ac97(chip, 1);\n\n\tif (chip->model.resume)\n\t\tchip->model.resume(chip);\n\n\toxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(oxygen_pci_pm, oxygen_pci_suspend, oxygen_pci_resume);\nEXPORT_SYMBOL(oxygen_pci_pm);\n#endif  \n\nvoid oxygen_pci_shutdown(struct pci_dev *pci)\n{\n\tstruct snd_card *card = pci_get_drvdata(pci);\n\tstruct oxygen *chip = card->private_data;\n\n\toxygen_shutdown(chip);\n\tchip->model.cleanup(chip);\n}\nEXPORT_SYMBOL(oxygen_pci_shutdown);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}