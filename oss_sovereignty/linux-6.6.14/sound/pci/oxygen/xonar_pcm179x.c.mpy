{
  "module_name": "xonar_pcm179x.c",
  "hash_id": "1e3ec63da19a8d5dcdd688b517e4f6d00ee6e3014fcbba6af2c5c13e71e124ba",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/xonar_pcm179x.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <sound/ac97_codec.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"xonar.h\"\n#include \"cm9780.h\"\n#include \"pcm1796.h\"\n#include \"cs2000.h\"\n\n\n#define GPIO_D2X_EXT_POWER\t0x0020\n#define GPIO_D2_ALT\t\t0x0080\n#define GPIO_D2_OUTPUT_ENABLE\t0x0100\n\n#define GPI_EXT_POWER\t\t0x01\n#define GPIO_INPUT_ROUTE\t0x0100\n\n#define GPIO_HDAV_OUTPUT_ENABLE\t0x0001\n#define GPIO_HDAV_MAGIC\t\t0x00c0\n\n#define GPIO_DB_MASK\t\t0x0030\n#define GPIO_DB_H6\t\t0x0000\n\n#define GPIO_ST_OUTPUT_ENABLE\t0x0001\n#define GPIO_ST_HP_REAR\t\t0x0002\n#define GPIO_ST_MAGIC\t\t0x0040\n#define GPIO_ST_HP\t\t0x0080\n\n#define GPIO_XENSE_OUTPUT_ENABLE\t(0x0001 | 0x0010 | 0x0020)\n#define GPIO_XENSE_SPEAKERS\t\t0x0080\n\n#define I2C_DEVICE_PCM1796(i)\t(0x98 + ((i) << 1))\t \n#define I2C_DEVICE_CS2000\t0x9c\t\t\t \n\n#define PCM1796_REG_BASE\t16\n\n\nstruct xonar_pcm179x {\n\tstruct xonar_generic generic;\n\tunsigned int dacs;\n\tu8 pcm1796_regs[4][5];\n\tunsigned int current_rate;\n\tbool h6;\n\tbool hp_active;\n\ts8 hp_gain_offset;\n\tbool has_cs2000;\n\tu8 cs2000_regs[0x1f];\n\tbool broken_i2c;\n};\n\nstruct xonar_hdav {\n\tstruct xonar_pcm179x pcm179x;\n\tstruct xonar_hdmi hdmi;\n};\n\n\nstatic inline void pcm1796_write_spi(struct oxygen *chip, unsigned int codec,\n\t\t\t\t     u8 reg, u8 value)\n{\n\t \n\tstatic const u8 codec_map[4] = {\n\t\t0, 1, 2, 4\n\t};\n\toxygen_write_spi(chip, OXYGEN_SPI_TRIGGER  |\n\t\t\t OXYGEN_SPI_DATA_LENGTH_2 |\n\t\t\t OXYGEN_SPI_CLOCK_160 |\n\t\t\t (codec_map[codec] << OXYGEN_SPI_CODEC_SHIFT) |\n\t\t\t OXYGEN_SPI_CEN_LATCH_CLOCK_HI,\n\t\t\t (reg << 8) | value);\n}\n\nstatic inline void pcm1796_write_i2c(struct oxygen *chip, unsigned int codec,\n\t\t\t\t     u8 reg, u8 value)\n{\n\toxygen_write_i2c(chip, I2C_DEVICE_PCM1796(codec), reg, value);\n}\n\nstatic void pcm1796_write(struct oxygen *chip, unsigned int codec,\n\t\t\t  u8 reg, u8 value)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tif ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==\n\t    OXYGEN_FUNCTION_SPI)\n\t\tpcm1796_write_spi(chip, codec, reg, value);\n\telse\n\t\tpcm1796_write_i2c(chip, codec, reg, value);\n\tif ((unsigned int)(reg - PCM1796_REG_BASE)\n\t    < ARRAY_SIZE(data->pcm1796_regs[codec]))\n\t\tdata->pcm1796_regs[codec][reg - PCM1796_REG_BASE] = value;\n}\n\nstatic void pcm1796_write_cached(struct oxygen *chip, unsigned int codec,\n\t\t\t\t u8 reg, u8 value)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tif (value != data->pcm1796_regs[codec][reg - PCM1796_REG_BASE])\n\t\tpcm1796_write(chip, codec, reg, value);\n}\n\nstatic void cs2000_write(struct oxygen *chip, u8 reg, u8 value)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\toxygen_write_i2c(chip, I2C_DEVICE_CS2000, reg, value);\n\tdata->cs2000_regs[reg] = value;\n}\n\nstatic void cs2000_write_cached(struct oxygen *chip, u8 reg, u8 value)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tif (value != data->cs2000_regs[reg])\n\t\tcs2000_write(chip, reg, value);\n}\n\nstatic void pcm1796_registers_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\ts8 gain_offset;\n\n\tmsleep(1);\n\tgain_offset = data->hp_active ? data->hp_gain_offset : 0;\n\tfor (i = 0; i < data->dacs; ++i) {\n\t\t \n\t\tpcm1796_write(chip, i, 18,\n\t\t\t      data->pcm1796_regs[0][18 - PCM1796_REG_BASE]);\n\t\tpcm1796_write(chip, i, 16, chip->dac_volume[i * 2]\n\t\t\t      + gain_offset);\n\t\tpcm1796_write(chip, i, 17, chip->dac_volume[i * 2 + 1]\n\t\t\t      + gain_offset);\n\t\tpcm1796_write(chip, i, 19,\n\t\t\t      data->pcm1796_regs[0][19 - PCM1796_REG_BASE]);\n\t\tpcm1796_write(chip, i, 20,\n\t\t\t      data->pcm1796_regs[0][20 - PCM1796_REG_BASE]);\n\t\tpcm1796_write(chip, i, 21, 0);\n\t\tgain_offset = 0;\n\t}\n}\n\nstatic void pcm1796_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->pcm1796_regs[0][18 - PCM1796_REG_BASE] =\n\t\tPCM1796_FMT_24_I2S | PCM1796_ATLD;\n\tif (!data->broken_i2c)\n\t\tdata->pcm1796_regs[0][18 - PCM1796_REG_BASE] |= PCM1796_MUTE;\n\tdata->pcm1796_regs[0][19 - PCM1796_REG_BASE] =\n\t\tPCM1796_FLT_SHARP | PCM1796_ATS_1;\n\tdata->pcm1796_regs[0][20 - PCM1796_REG_BASE] =\n\t\tdata->h6 ? PCM1796_OS_64 : PCM1796_OS_128;\n\tpcm1796_registers_init(chip);\n\tdata->current_rate = 48000;\n}\n\nstatic void xonar_d2_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->generic.anti_pop_delay = 300;\n\tdata->generic.output_enable_bit = GPIO_D2_OUTPUT_ENABLE;\n\tdata->dacs = 4;\n\n\tpcm1796_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_D2_ALT);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_D2_ALT);\n\n\toxygen_ac97_set_bits(chip, 0, CM9780_JACK, CM9780_FMIC2MIC);\n\n\txonar_init_cs53x1(chip);\n\txonar_enable_output(chip);\n\n\tsnd_component_add(chip->card, \"PCM1796\");\n\tsnd_component_add(chip->card, \"CS5381\");\n}\n\nstatic void xonar_d2x_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->generic.ext_power_reg = OXYGEN_GPIO_DATA;\n\tdata->generic.ext_power_int_reg = OXYGEN_GPIO_INTERRUPT_MASK;\n\tdata->generic.ext_power_bit = GPIO_D2X_EXT_POWER;\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_D2X_EXT_POWER);\n\txonar_init_ext_power(chip);\n\txonar_d2_init(chip);\n}\n\nstatic void xonar_hdav_init(struct oxygen *chip)\n{\n\tstruct xonar_hdav *data = chip->model_data;\n\n\toxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\n\t\t       OXYGEN_2WIRE_LENGTH_8 |\n\t\t       OXYGEN_2WIRE_INTERRUPT_MASK |\n\t\t       OXYGEN_2WIRE_SPEED_STANDARD);\n\n\tdata->pcm179x.generic.anti_pop_delay = 100;\n\tdata->pcm179x.generic.output_enable_bit = GPIO_HDAV_OUTPUT_ENABLE;\n\tdata->pcm179x.generic.ext_power_reg = OXYGEN_GPI_DATA;\n\tdata->pcm179x.generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\n\tdata->pcm179x.generic.ext_power_bit = GPI_EXT_POWER;\n\tdata->pcm179x.dacs = chip->model.dac_channels_mixer / 2;\n\tdata->pcm179x.h6 = chip->model.dac_channels_mixer > 2;\n\n\tpcm1796_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t  GPIO_HDAV_MAGIC | GPIO_INPUT_ROUTE);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_INPUT_ROUTE);\n\n\txonar_init_cs53x1(chip);\n\txonar_init_ext_power(chip);\n\txonar_hdmi_init(chip, &data->hdmi);\n\txonar_enable_output(chip);\n\n\tsnd_component_add(chip->card, \"PCM1796\");\n\tsnd_component_add(chip->card, \"CS5381\");\n}\n\nstatic void xonar_st_init_i2c(struct oxygen *chip)\n{\n\toxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\n\t\t       OXYGEN_2WIRE_LENGTH_8 |\n\t\t       OXYGEN_2WIRE_INTERRUPT_MASK |\n\t\t       OXYGEN_2WIRE_SPEED_STANDARD);\n}\n\nstatic void xonar_st_init_common(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->generic.output_enable_bit = GPIO_ST_OUTPUT_ENABLE;\n\tdata->dacs = chip->model.dac_channels_mixer / 2;\n\tdata->h6 = chip->model.dac_channels_mixer > 2;\n\tdata->hp_gain_offset = 2*-18;\n\n\tpcm1796_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t  GPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\n\t\t\t  GPIO_ST_MAGIC | GPIO_ST_HP);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,\n\t\t\t    GPIO_INPUT_ROUTE | GPIO_ST_HP_REAR | GPIO_ST_HP);\n\n\txonar_init_cs53x1(chip);\n\txonar_enable_output(chip);\n\n\tsnd_component_add(chip->card, \"PCM1792A\");\n\tsnd_component_add(chip->card, \"CS5381\");\n}\n\nstatic void cs2000_registers_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tcs2000_write(chip, CS2000_GLOBAL_CFG, CS2000_FREEZE);\n\tcs2000_write(chip, CS2000_DEV_CTRL, 0);\n\tcs2000_write(chip, CS2000_DEV_CFG_1,\n\t\t     CS2000_R_MOD_SEL_1 |\n\t\t     (0 << CS2000_R_SEL_SHIFT) |\n\t\t     CS2000_AUX_OUT_SRC_REF_CLK |\n\t\t     CS2000_EN_DEV_CFG_1);\n\tcs2000_write(chip, CS2000_DEV_CFG_2,\n\t\t     (0 << CS2000_LOCK_CLK_SHIFT) |\n\t\t     CS2000_FRAC_N_SRC_STATIC);\n\tcs2000_write(chip, CS2000_RATIO_0 + 0, 0x00);  \n\tcs2000_write(chip, CS2000_RATIO_0 + 1, 0x10);\n\tcs2000_write(chip, CS2000_RATIO_0 + 2, 0x00);\n\tcs2000_write(chip, CS2000_RATIO_0 + 3, 0x00);\n\tcs2000_write(chip, CS2000_FUN_CFG_1,\n\t\t     data->cs2000_regs[CS2000_FUN_CFG_1]);\n\tcs2000_write(chip, CS2000_FUN_CFG_2, 0);\n\tcs2000_write(chip, CS2000_GLOBAL_CFG, CS2000_EN_DEV_CFG_2);\n\tmsleep(3);  \n}\n\nstatic void xonar_st_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->generic.anti_pop_delay = 100;\n\tdata->h6 = chip->model.dac_channels_mixer > 2;\n\tdata->has_cs2000 = true;\n\tdata->cs2000_regs[CS2000_FUN_CFG_1] = CS2000_REF_CLK_DIV_1;\n\tdata->broken_i2c = true;\n\n\toxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\n\t\t       OXYGEN_RATE_48000 |\n\t\t       OXYGEN_I2S_FORMAT_I2S |\n\t\t       OXYGEN_I2S_MCLK(data->h6 ? MCLK_256 : MCLK_512) |\n\t\t       OXYGEN_I2S_BITS_16 |\n\t\t       OXYGEN_I2S_MASTER |\n\t\t       OXYGEN_I2S_BCLK_64);\n\n\txonar_st_init_i2c(chip);\n\tcs2000_registers_init(chip);\n\txonar_st_init_common(chip);\n\n\tsnd_component_add(chip->card, \"CS2000\");\n}\n\nstatic void xonar_stx_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\txonar_st_init_i2c(chip);\n\tdata->generic.anti_pop_delay = 800;\n\tdata->generic.ext_power_reg = OXYGEN_GPI_DATA;\n\tdata->generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\n\tdata->generic.ext_power_bit = GPI_EXT_POWER;\n\txonar_init_ext_power(chip);\n\txonar_st_init_common(chip);\n}\n\nstatic void xonar_xense_init(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tdata->generic.ext_power_reg = OXYGEN_GPI_DATA;\n\tdata->generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\n\tdata->generic.ext_power_bit = GPI_EXT_POWER;\n\txonar_init_ext_power(chip);\n\n\tdata->generic.anti_pop_delay = 100;\n\tdata->has_cs2000 = true;\n\tdata->cs2000_regs[CS2000_FUN_CFG_1] = CS2000_REF_CLK_DIV_1;\n\n\toxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\n\t\tOXYGEN_RATE_48000 |\n\t\tOXYGEN_I2S_FORMAT_I2S |\n\t\tOXYGEN_I2S_MCLK(MCLK_512) |\n\t\tOXYGEN_I2S_BITS_16 |\n\t\tOXYGEN_I2S_MASTER |\n\t\tOXYGEN_I2S_BCLK_64);\n\n\txonar_st_init_i2c(chip);\n\tcs2000_registers_init(chip);\n\n\tdata->generic.output_enable_bit = GPIO_XENSE_OUTPUT_ENABLE;\n\tdata->dacs = 1;\n\tdata->hp_gain_offset = 2*-18;\n\n\tpcm1796_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\tGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\n\t\tGPIO_ST_MAGIC | GPIO_XENSE_SPEAKERS);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,\n\t\tGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\n\t\tGPIO_XENSE_SPEAKERS);\n\n\txonar_init_cs53x1(chip);\n\txonar_enable_output(chip);\n\n\tsnd_component_add(chip->card, \"PCM1796\");\n\tsnd_component_add(chip->card, \"CS5381\");\n\tsnd_component_add(chip->card, \"CS2000\");\n}\n\nstatic void xonar_d2_cleanup(struct oxygen *chip)\n{\n\txonar_disable_output(chip);\n}\n\nstatic void xonar_hdav_cleanup(struct oxygen *chip)\n{\n\txonar_hdmi_cleanup(chip);\n\txonar_disable_output(chip);\n\tmsleep(2);\n}\n\nstatic void xonar_st_cleanup(struct oxygen *chip)\n{\n\txonar_disable_output(chip);\n}\n\nstatic void xonar_d2_suspend(struct oxygen *chip)\n{\n\txonar_d2_cleanup(chip);\n}\n\nstatic void xonar_hdav_suspend(struct oxygen *chip)\n{\n\txonar_hdav_cleanup(chip);\n}\n\nstatic void xonar_st_suspend(struct oxygen *chip)\n{\n\txonar_st_cleanup(chip);\n}\n\nstatic void xonar_d2_resume(struct oxygen *chip)\n{\n\tpcm1796_registers_init(chip);\n\txonar_enable_output(chip);\n}\n\nstatic void xonar_hdav_resume(struct oxygen *chip)\n{\n\tstruct xonar_hdav *data = chip->model_data;\n\n\tpcm1796_registers_init(chip);\n\txonar_hdmi_resume(chip, &data->hdmi);\n\txonar_enable_output(chip);\n}\n\nstatic void xonar_stx_resume(struct oxygen *chip)\n{\n\tpcm1796_registers_init(chip);\n\txonar_enable_output(chip);\n}\n\nstatic void xonar_st_resume(struct oxygen *chip)\n{\n\tcs2000_registers_init(chip);\n\txonar_stx_resume(chip);\n}\n\nstatic void update_pcm1796_oversampling(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\tu8 reg;\n\n\tif (data->current_rate <= 48000 && !data->h6)\n\t\treg = PCM1796_OS_128;\n\telse\n\t\treg = PCM1796_OS_64;\n\tfor (i = 0; i < data->dacs; ++i)\n\t\tpcm1796_write_cached(chip, i, 20, reg);\n}\n\nstatic void update_pcm1796_deemph(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\tu8 reg;\n\n\treg = data->pcm1796_regs[0][18 - PCM1796_REG_BASE] & ~PCM1796_DMF_MASK;\n\tif (data->current_rate == 48000)\n\t\treg |= PCM1796_DMF_48;\n\telse if (data->current_rate == 44100)\n\t\treg |= PCM1796_DMF_441;\n\telse if (data->current_rate == 32000)\n\t\treg |= PCM1796_DMF_32;\n\tfor (i = 0; i < data->dacs; ++i)\n\t\tpcm1796_write_cached(chip, i, 18, reg);\n}\n\nstatic void set_pcm1796_params(struct oxygen *chip,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tmsleep(1);\n\tdata->current_rate = params_rate(params);\n\tupdate_pcm1796_oversampling(chip);\n\tupdate_pcm1796_deemph(chip);\n}\n\nstatic void update_pcm1796_volume(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\ts8 gain_offset;\n\n\tgain_offset = data->hp_active ? data->hp_gain_offset : 0;\n\tfor (i = 0; i < data->dacs; ++i) {\n\t\tpcm1796_write_cached(chip, i, 16, chip->dac_volume[i * 2]\n\t\t\t\t     + gain_offset);\n\t\tpcm1796_write_cached(chip, i, 17, chip->dac_volume[i * 2 + 1]\n\t\t\t\t     + gain_offset);\n\t\tgain_offset = 0;\n\t}\n}\n\nstatic void update_pcm1796_mute(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\tu8 value;\n\n\tvalue = data->pcm1796_regs[0][18 - PCM1796_REG_BASE];\n\tif (chip->dac_mute)\n\t\tvalue |= PCM1796_MUTE;\n\telse\n\t\tvalue &= ~PCM1796_MUTE;\n\tfor (i = 0; i < data->dacs; ++i)\n\t\tpcm1796_write_cached(chip, i, 18, value);\n}\n\nstatic void update_cs2000_rate(struct oxygen *chip, unsigned int rate)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tu8 rate_mclk, reg;\n\n\tswitch (rate) {\n\tcase 32000:\n\tcase 64000:\n\t\trate_mclk = OXYGEN_RATE_32000;\n\t\tbreak;\n\tcase 44100:\n\tcase 88200:\n\tcase 176400:\n\t\trate_mclk = OXYGEN_RATE_44100;\n\t\tbreak;\n\tdefault:\n\tcase 48000:\n\tcase 96000:\n\tcase 192000:\n\t\trate_mclk = OXYGEN_RATE_48000;\n\t\tbreak;\n\t}\n\n\tif (rate <= 96000 && (rate > 48000 || data->h6)) {\n\t\trate_mclk |= OXYGEN_I2S_MCLK(MCLK_256);\n\t\treg = CS2000_REF_CLK_DIV_1;\n\t} else {\n\t\trate_mclk |= OXYGEN_I2S_MCLK(MCLK_512);\n\t\treg = CS2000_REF_CLK_DIV_2;\n\t}\n\n\toxygen_write16_masked(chip, OXYGEN_I2S_A_FORMAT, rate_mclk,\n\t\t\t      OXYGEN_I2S_RATE_MASK | OXYGEN_I2S_MCLK_MASK);\n\tcs2000_write_cached(chip, CS2000_FUN_CFG_1, reg);\n\tmsleep(3);  \n}\n\nstatic void set_st_params(struct oxygen *chip,\n\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tupdate_cs2000_rate(chip, params_rate(params));\n\tset_pcm1796_params(chip, params);\n}\n\nstatic void set_hdav_params(struct oxygen *chip,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct xonar_hdav *data = chip->model_data;\n\n\tset_pcm1796_params(chip, params);\n\txonar_set_hdmi_params(chip, &data->hdmi, params);\n}\n\nstatic const struct snd_kcontrol_new alt_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Analog Loopback Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = xonar_gpio_bit_switch_get,\n\t.put = xonar_gpio_bit_switch_put,\n\t.private_value = GPIO_D2_ALT,\n};\n\nstatic int rolloff_info(struct snd_kcontrol *ctl,\n\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = {\n\t\t\"Sharp Roll-off\", \"Slow Roll-off\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int rolloff_get(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t(data->pcm1796_regs[0][19 - PCM1796_REG_BASE] &\n\t\t PCM1796_FLT_MASK) != PCM1796_FLT_SHARP;\n\treturn 0;\n}\n\nstatic int rolloff_put(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\tint changed;\n\tu8 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->pcm1796_regs[0][19 - PCM1796_REG_BASE];\n\treg &= ~PCM1796_FLT_MASK;\n\tif (!value->value.enumerated.item[0])\n\t\treg |= PCM1796_FLT_SHARP;\n\telse\n\t\treg |= PCM1796_FLT_SLOW;\n\tchanged = reg != data->pcm1796_regs[0][19 - PCM1796_REG_BASE];\n\tif (changed) {\n\t\tfor (i = 0; i < data->dacs; ++i)\n\t\t\tpcm1796_write(chip, i, 19, reg);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new rolloff_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DAC Filter Playback Enum\",\n\t.info = rolloff_info,\n\t.get = rolloff_get,\n\t.put = rolloff_put,\n};\n\nstatic int deemph_get(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tvalue->value.integer.value[0] =\n\t\t!!(data->pcm1796_regs[0][18 - PCM1796_REG_BASE] & PCM1796_DME);\n\treturn 0;\n}\n\nstatic int deemph_put(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\tint changed;\n\tu8 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->pcm1796_regs[0][18 - PCM1796_REG_BASE];\n\tif (!value->value.integer.value[0])\n\t\treg &= ~PCM1796_DME;\n\telse\n\t\treg |= PCM1796_DME;\n\tchanged = reg != data->pcm1796_regs[0][18 - PCM1796_REG_BASE];\n\tif (changed) {\n\t\tfor (i = 0; i < data->dacs; ++i)\n\t\t\tpcm1796_write(chip, i, 18, reg);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new deemph_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"De-emphasis Playback Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = deemph_get,\n\t.put = deemph_put,\n};\n\nstatic const struct snd_kcontrol_new hdav_hdmi_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"HDMI Playback Switch\",\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = xonar_gpio_bit_switch_get,\n\t.put = xonar_gpio_bit_switch_put,\n\t.private_value = GPIO_HDAV_OUTPUT_ENABLE | XONAR_GPIO_BIT_INVERT,\n};\n\nstatic int st_output_switch_info(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[3] = {\n\t\t\"Speakers\", \"Headphones\", \"FP Headphones\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 3, names);\n}\n\nstatic int st_output_switch_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 gpio;\n\n\tgpio = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tif (!(gpio & GPIO_ST_HP))\n\t\tvalue->value.enumerated.item[0] = 0;\n\telse if (gpio & GPIO_ST_HP_REAR)\n\t\tvalue->value.enumerated.item[0] = 1;\n\telse\n\t\tvalue->value.enumerated.item[0] = 2;\n\treturn 0;\n}\n\n\nstatic int st_output_switch_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tu16 gpio_old, gpio;\n\n\tmutex_lock(&chip->mutex);\n\tgpio_old = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tgpio = gpio_old;\n\tswitch (value->value.enumerated.item[0]) {\n\tcase 0:\n\t\tgpio &= ~(GPIO_ST_HP | GPIO_ST_HP_REAR);\n\t\tbreak;\n\tcase 1:\n\t\tgpio |= GPIO_ST_HP | GPIO_ST_HP_REAR;\n\t\tbreak;\n\tcase 2:\n\t\tgpio = (gpio | GPIO_ST_HP) & ~GPIO_ST_HP_REAR;\n\t\tbreak;\n\t}\n\toxygen_write16(chip, OXYGEN_GPIO_DATA, gpio);\n\tdata->hp_active = gpio & GPIO_ST_HP;\n\tupdate_pcm1796_volume(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn gpio != gpio_old;\n}\n\nstatic int st_hp_volume_offset_info(struct snd_kcontrol *ctl,\n\t\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[4] = {\n\t\t\"< 32 ohms\", \"32-64 ohms\", \"64-300 ohms\", \"300-600 ohms\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 4, names);\n}\n\nstatic int st_hp_volume_offset_get(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tif (data->hp_gain_offset < 2*-12)\n\t\tvalue->value.enumerated.item[0] = 0;\n\telse if (data->hp_gain_offset < 2*-6)\n\t\tvalue->value.enumerated.item[0] = 1;\n\telse if (data->hp_gain_offset < 0)\n\t\tvalue->value.enumerated.item[0] = 2;\n\telse\n\t\tvalue->value.enumerated.item[0] = 3;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\n\nstatic int st_hp_volume_offset_put(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstatic const s8 offsets[] = { 2*-18, 2*-12, 2*-6, 0 };\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\ts8 offset;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 3)\n\t\treturn -EINVAL;\n\toffset = offsets[value->value.enumerated.item[0]];\n\tmutex_lock(&chip->mutex);\n\tchanged = offset != data->hp_gain_offset;\n\tif (changed) {\n\t\tdata->hp_gain_offset = offset;\n\t\tupdate_pcm1796_volume(chip);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new st_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Output\",\n\t\t.info = st_output_switch_info,\n\t\t.get = st_output_switch_get,\n\t\t.put = st_output_switch_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphones Impedance Playback Enum\",\n\t\t.info = st_hp_volume_offset_info,\n\t\t.get = st_hp_volume_offset_get,\n\t\t.put = st_hp_volume_offset_put,\n\t},\n};\n\nstatic int xense_output_switch_get(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 gpio;\n\n\tgpio = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tif (gpio & GPIO_XENSE_SPEAKERS)\n\t\tvalue->value.enumerated.item[0] = 0;\n\telse if (!(gpio & GPIO_XENSE_SPEAKERS) && (gpio & GPIO_ST_HP_REAR))\n\t\tvalue->value.enumerated.item[0] = 1;\n\telse\n\t\tvalue->value.enumerated.item[0] = 2;\n\treturn 0;\n}\n\nstatic int xense_output_switch_put(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tu16 gpio_old, gpio;\n\n\tmutex_lock(&chip->mutex);\n\tgpio_old = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tgpio = gpio_old;\n\tswitch (value->value.enumerated.item[0]) {\n\tcase 0:\n\t\tgpio |= GPIO_XENSE_SPEAKERS | GPIO_ST_HP_REAR;\n\t\tbreak;\n\tcase 1:\n\t\tgpio = (gpio | GPIO_ST_HP_REAR) & ~GPIO_XENSE_SPEAKERS;\n\t\tbreak;\n\tcase 2:\n\t\tgpio &= ~(GPIO_XENSE_SPEAKERS | GPIO_ST_HP_REAR);\n\t\tbreak;\n\t}\n\toxygen_write16(chip, OXYGEN_GPIO_DATA, gpio);\n\tdata->hp_active = !(gpio & GPIO_XENSE_SPEAKERS);\n\tupdate_pcm1796_volume(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn gpio != gpio_old;\n}\n\nstatic const struct snd_kcontrol_new xense_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Analog Output\",\n\t\t.info = st_output_switch_info,\n\t\t.get = xense_output_switch_get,\n\t\t.put = xense_output_switch_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphones Impedance Playback Enum\",\n\t\t.info = st_hp_volume_offset_info,\n\t\t.get = st_hp_volume_offset_get,\n\t\t.put = st_hp_volume_offset_put,\n\t},\n};\n\nstatic void xonar_line_mic_ac97_switch(struct oxygen *chip,\n\t\t\t\t       unsigned int reg, unsigned int mute)\n{\n\tif (reg == AC97_LINE) {\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\toxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\n\t\t\t\t      mute ? GPIO_INPUT_ROUTE : 0,\n\t\t\t\t      GPIO_INPUT_ROUTE);\n\t\tspin_unlock_irq(&chip->reg_lock);\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(pcm1796_db_scale, -6000, 50, 0);\n\nstatic int xonar_d2_control_filter(struct snd_kcontrol_new *template)\n{\n\tif (!strncmp(template->name, \"CD Capture \", 11))\n\t\t \n\t\ttemplate->private_value ^= AC97_CD ^ AC97_VIDEO;\n\treturn 0;\n}\n\nstatic int xonar_st_h6_control_filter(struct snd_kcontrol_new *template)\n{\n\tif (!strncmp(template->name, \"Master Playback \", 16))\n\t\t \n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int add_pcm1796_controls(struct oxygen *chip)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tint err;\n\n\tif (!data->broken_i2c) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t  snd_ctl_new1(&rolloff_control, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t  snd_ctl_new1(&deemph_control, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int xonar_d2_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&alt_switch, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = add_pcm1796_controls(chip);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int xonar_hdav_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&hdav_hdmi_control, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = add_pcm1796_controls(chip);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int xonar_st_mixer_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(st_controls); ++i) {\n\t\terr = snd_ctl_add(chip->card,\n\t\t\t\t  snd_ctl_new1(&st_controls[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = add_pcm1796_controls(chip);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int xonar_xense_mixer_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(xense_controls); ++i) {\n\t\terr = snd_ctl_add(chip->card,\n\t\tsnd_ctl_new1(&xense_controls[i], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = add_pcm1796_controls(chip);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void dump_pcm1796_registers(struct oxygen *chip,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int dac, i;\n\n\tfor (dac = 0; dac < data->dacs; ++dac) {\n\t\tsnd_iprintf(buffer, \"\\nPCM1796 %u:\", dac + 1);\n\t\tfor (i = 0; i < 5; ++i)\n\t\t\tsnd_iprintf(buffer, \" %02x\",\n\t\t\t\t    data->pcm1796_regs[dac][i]);\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void dump_cs2000_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct xonar_pcm179x *data = chip->model_data;\n\tunsigned int i;\n\n\tif (data->has_cs2000) {\n\t\tsnd_iprintf(buffer, \"\\nCS2000:\\n00:   \");\n\t\tfor (i = 1; i < 0x10; ++i)\n\t\t\tsnd_iprintf(buffer, \" %02x\", data->cs2000_regs[i]);\n\t\tsnd_iprintf(buffer, \"\\n10:\");\n\t\tfor (i = 0x10; i < 0x1f; ++i)\n\t\t\tsnd_iprintf(buffer, \" %02x\", data->cs2000_regs[i]);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n}\n\nstatic void dump_st_registers(struct oxygen *chip,\n\t\t\t      struct snd_info_buffer *buffer)\n{\n\tdump_pcm1796_registers(chip, buffer);\n\tdump_cs2000_registers(chip, buffer);\n}\n\nstatic const struct oxygen_model model_xonar_d2 = {\n\t.longname = \"Asus Virtuoso 200\",\n\t.chip = \"AV200\",\n\t.init = xonar_d2_init,\n\t.control_filter = xonar_d2_control_filter,\n\t.mixer_init = xonar_d2_mixer_init,\n\t.cleanup = xonar_d2_cleanup,\n\t.suspend = xonar_d2_suspend,\n\t.resume = xonar_d2_resume,\n\t.set_dac_params = set_pcm1796_params,\n\t.set_adc_params = xonar_set_cs53x1_params,\n\t.update_dac_volume = update_pcm1796_volume,\n\t.update_dac_mute = update_pcm1796_mute,\n\t.dump_registers = dump_pcm1796_registers,\n\t.dac_tlv = pcm1796_db_scale,\n\t.model_data_size = sizeof(struct xonar_pcm179x),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_2 |\n\t\t\t CAPTURE_1_FROM_SPDIF |\n\t\t\t MIDI_OUTPUT |\n\t\t\t MIDI_INPUT |\n\t\t\t AC97_CD_INPUT,\n\t.dac_channels_pcm = 8,\n\t.dac_channels_mixer = 8,\n\t.dac_volume_min = 255 - 2*60,\n\t.dac_volume_max = 255,\n\t.misc_flags = OXYGEN_MISC_MIDI,\n\t.function_flags = OXYGEN_FUNCTION_SPI |\n\t\t\t  OXYGEN_FUNCTION_ENABLE_SPI_4_5,\n\t.dac_mclks = OXYGEN_MCLKS(512, 128, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_I2S,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nstatic const struct oxygen_model model_xonar_hdav = {\n\t.longname = \"Asus Virtuoso 200\",\n\t.chip = \"AV200\",\n\t.init = xonar_hdav_init,\n\t.mixer_init = xonar_hdav_mixer_init,\n\t.cleanup = xonar_hdav_cleanup,\n\t.suspend = xonar_hdav_suspend,\n\t.resume = xonar_hdav_resume,\n\t.pcm_hardware_filter = xonar_hdmi_pcm_hardware_filter,\n\t.set_dac_params = set_hdav_params,\n\t.set_adc_params = xonar_set_cs53x1_params,\n\t.update_dac_volume = update_pcm1796_volume,\n\t.update_dac_mute = update_pcm1796_mute,\n\t.uart_input = xonar_hdmi_uart_input,\n\t.ac97_switch = xonar_line_mic_ac97_switch,\n\t.dump_registers = dump_pcm1796_registers,\n\t.dac_tlv = pcm1796_db_scale,\n\t.model_data_size = sizeof(struct xonar_hdav),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_2 |\n\t\t\t CAPTURE_1_FROM_SPDIF,\n\t.dac_channels_pcm = 8,\n\t.dac_channels_mixer = 2,\n\t.dac_volume_min = 255 - 2*60,\n\t.dac_volume_max = 255,\n\t.misc_flags = OXYGEN_MISC_MIDI,\n\t.function_flags = OXYGEN_FUNCTION_2WIRE,\n\t.dac_mclks = OXYGEN_MCLKS(512, 128, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_I2S,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nstatic const struct oxygen_model model_xonar_st = {\n\t.longname = \"Asus Virtuoso 100\",\n\t.chip = \"AV200\",\n\t.init = xonar_st_init,\n\t.mixer_init = xonar_st_mixer_init,\n\t.cleanup = xonar_st_cleanup,\n\t.suspend = xonar_st_suspend,\n\t.resume = xonar_st_resume,\n\t.set_dac_params = set_st_params,\n\t.set_adc_params = xonar_set_cs53x1_params,\n\t.update_dac_volume = update_pcm1796_volume,\n\t.update_dac_mute = update_pcm1796_mute,\n\t.ac97_switch = xonar_line_mic_ac97_switch,\n\t.dump_registers = dump_st_registers,\n\t.dac_tlv = pcm1796_db_scale,\n\t.model_data_size = sizeof(struct xonar_pcm179x),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_2 |\n\t\t\t CAPTURE_1_FROM_SPDIF |\n\t\t\t AC97_FMIC_SWITCH,\n\t.dac_channels_pcm = 2,\n\t.dac_channels_mixer = 2,\n\t.dac_volume_min = 255 - 2*60,\n\t.dac_volume_max = 255,\n\t.function_flags = OXYGEN_FUNCTION_2WIRE,\n\t.dac_mclks = OXYGEN_MCLKS(512, 128, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_I2S,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nint get_xonar_pcm179x_model(struct oxygen *chip,\n\t\t\t    const struct pci_device_id *id)\n{\n\tswitch (id->subdevice) {\n\tcase 0x8269:\n\t\tchip->model = model_xonar_d2;\n\t\tchip->model.shortname = \"Xonar D2\";\n\t\tbreak;\n\tcase 0x82b7:\n\t\tchip->model = model_xonar_d2;\n\t\tchip->model.shortname = \"Xonar D2X\";\n\t\tchip->model.init = xonar_d2x_init;\n\t\tbreak;\n\tcase 0x8314:\n\t\tchip->model = model_xonar_hdav;\n\t\toxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\n\t\tswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\n\t\tdefault:\n\t\t\tchip->model.shortname = \"Xonar HDAV1.3\";\n\t\t\tbreak;\n\t\tcase GPIO_DB_H6:\n\t\t\tchip->model.shortname = \"Xonar HDAV1.3+H6\";\n\t\t\tchip->model.dac_channels_mixer = 8;\n\t\t\tchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x835d:\n\t\tchip->model = model_xonar_st;\n\t\toxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\n\t\tswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\n\t\tdefault:\n\t\t\tchip->model.shortname = \"Xonar ST\";\n\t\t\tbreak;\n\t\tcase GPIO_DB_H6:\n\t\t\tchip->model.shortname = \"Xonar ST+H6\";\n\t\t\tchip->model.control_filter = xonar_st_h6_control_filter;\n\t\t\tchip->model.dac_channels_pcm = 8;\n\t\t\tchip->model.dac_channels_mixer = 8;\n\t\t\tchip->model.dac_volume_min = 255;\n\t\t\tchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x835c:\n\t\tchip->model = model_xonar_st;\n\t\tchip->model.shortname = \"Xonar STX\";\n\t\tchip->model.init = xonar_stx_init;\n\t\tchip->model.resume = xonar_stx_resume;\n\t\tchip->model.set_dac_params = set_pcm1796_params;\n\t\tbreak;\n\tcase 0x85f4:\n\t\tchip->model = model_xonar_st;\n\t\toxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\n\t\tswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\n\t\tdefault:\n\t\t\tchip->model.shortname = \"Xonar STX II\";\n\t\t\tbreak;\n\t\tcase GPIO_DB_H6:\n\t\t\tchip->model.shortname = \"Xonar STX II+H6\";\n\t\t\tchip->model.dac_channels_pcm = 8;\n\t\t\tchip->model.dac_channels_mixer = 8;\n\t\t\tchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\n\t\t\tbreak;\n\t\t}\n\t\tchip->model.init = xonar_stx_init;\n\t\tchip->model.resume = xonar_stx_resume;\n\t\tchip->model.set_dac_params = set_pcm1796_params;\n\t\tbreak;\n\tcase 0x8428:\n\t\tchip->model = model_xonar_st;\n\t\tchip->model.shortname = \"Xonar Xense\";\n\t\tchip->model.chip = \"AV100\";\n\t\tchip->model.init = xonar_xense_init;\n\t\tchip->model.mixer_init = xonar_xense_mixer_init;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}