{
  "module_name": "oxygen.c",
  "hash_id": "758a30ca7b071f3939934a803ea8364e2011d37bd2407659987bb15add6f6492",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/oxygen.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <sound/ac97_codec.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"oxygen.h\"\n#include \"xonar_dg.h\"\n#include \"ak4396.h\"\n#include \"wm8785.h\"\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"C-Media CMI8788 driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"card index\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"enable card\");\n\nenum {\n\tMODEL_CMEDIA_REF,\n\tMODEL_MERIDIAN,\n\tMODEL_MERIDIAN_2G,\n\tMODEL_CLARO,\n\tMODEL_CLARO_HALO,\n\tMODEL_FANTASIA,\n\tMODEL_SERENADE,\n\tMODEL_2CH_OUTPUT,\n\tMODEL_HG2PCI,\n\tMODEL_XONAR_DG,\n\tMODEL_XONAR_DGX,\n};\n\nstatic const struct pci_device_id oxygen_ids[] = {\n\t \n\t{ OXYGEN_PCI_SUBID(0x10b0, 0x0216), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x10b0, 0x0217), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x10b0, 0x0218), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x10b0, 0x0219), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x13f6, 0x0001), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x13f6, 0x0010), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x13f6, 0x8788), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x147a, 0xa017), .driver_data = MODEL_CMEDIA_REF },\n\t{ OXYGEN_PCI_SUBID(0x1a58, 0x0910), .driver_data = MODEL_CMEDIA_REF },\n\t \n\t{ OXYGEN_PCI_SUBID(0x1043, 0x8467), .driver_data = MODEL_XONAR_DG },\n\t \n\t{ OXYGEN_PCI_SUBID(0x1043, 0x8521), .driver_data = MODEL_XONAR_DGX },\n\t \n\t{ OXYGEN_PCI_SUBID(0x13f6, 0x8782), .driver_data = MODEL_2CH_OUTPUT },\n\t \n\t{ OXYGEN_PCI_SUBID(0x13f6, 0xffff), .driver_data = MODEL_HG2PCI },\n\t \n\t{ OXYGEN_PCI_SUBID(0x14c3, 0x1710), .driver_data = MODEL_FANTASIA },\n\t \n\t{ OXYGEN_PCI_SUBID(0x14c3, 0x1711), .driver_data = MODEL_SERENADE },\n\t \n\t{ OXYGEN_PCI_SUBID(0x415a, 0x5431), .driver_data = MODEL_MERIDIAN },\n\t \n\t{ OXYGEN_PCI_SUBID(0x5431, 0x017a), .driver_data = MODEL_MERIDIAN_2G },\n\t \n\t{ OXYGEN_PCI_SUBID(0x7284, 0x9761), .driver_data = MODEL_CLARO },\n\t \n\t{ OXYGEN_PCI_SUBID(0x7284, 0x9781), .driver_data = MODEL_CLARO_HALO },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, oxygen_ids);\n\n\n#define GPIO_AK5385_DFS_MASK\t0x0003\n#define GPIO_AK5385_DFS_NORMAL\t0x0000\n#define GPIO_AK5385_DFS_DOUBLE\t0x0001\n#define GPIO_AK5385_DFS_QUAD\t0x0002\n\n#define GPIO_MERIDIAN_DIG_MASK\t0x0050\n#define GPIO_MERIDIAN_DIG_EXT\t0x0010\n#define GPIO_MERIDIAN_DIG_BOARD\t0x0040\n\n#define GPIO_CLARO_DIG_COAX\t0x0040\n#define GPIO_CLARO_HP\t\t0x0100\n\nstruct generic_data {\n\tunsigned int dacs;\n\tu8 ak4396_regs[4][5];\n\tu16 wm8785_regs[3];\n};\n\nstatic void ak4396_write(struct oxygen *chip, unsigned int codec,\n\t\t\t u8 reg, u8 value)\n{\n\t \n\tstatic const u8 codec_spi_map[4] = {\n\t\t0, 1, 2, 4\n\t};\n\tstruct generic_data *data = chip->model_data;\n\n\toxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\n\t\t\t OXYGEN_SPI_DATA_LENGTH_2 |\n\t\t\t OXYGEN_SPI_CLOCK_160 |\n\t\t\t (codec_spi_map[codec] << OXYGEN_SPI_CODEC_SHIFT) |\n\t\t\t OXYGEN_SPI_CEN_LATCH_CLOCK_HI,\n\t\t\t AK4396_WRITE | (reg << 8) | value);\n\tdata->ak4396_regs[codec][reg] = value;\n}\n\nstatic void ak4396_write_cached(struct oxygen *chip, unsigned int codec,\n\t\t\t\tu8 reg, u8 value)\n{\n\tstruct generic_data *data = chip->model_data;\n\n\tif (value != data->ak4396_regs[codec][reg])\n\t\tak4396_write(chip, codec, reg, value);\n}\n\nstatic void wm8785_write(struct oxygen *chip, u8 reg, unsigned int value)\n{\n\tstruct generic_data *data = chip->model_data;\n\n\toxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\n\t\t\t OXYGEN_SPI_DATA_LENGTH_2 |\n\t\t\t OXYGEN_SPI_CLOCK_160 |\n\t\t\t (3 << OXYGEN_SPI_CODEC_SHIFT) |\n\t\t\t OXYGEN_SPI_CEN_LATCH_CLOCK_LO,\n\t\t\t (reg << 9) | value);\n\tif (reg < ARRAY_SIZE(data->wm8785_regs))\n\t\tdata->wm8785_regs[reg] = value;\n}\n\nstatic void ak4396_registers_init(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\n\tfor (i = 0; i < data->dacs; ++i) {\n\t\tak4396_write(chip, i, AK4396_CONTROL_1,\n\t\t\t     AK4396_DIF_24_MSB | AK4396_RSTN);\n\t\tak4396_write(chip, i, AK4396_CONTROL_2,\n\t\t\t     data->ak4396_regs[0][AK4396_CONTROL_2]);\n\t\tak4396_write(chip, i, AK4396_CONTROL_3,\n\t\t\t     AK4396_PCM);\n\t\tak4396_write(chip, i, AK4396_LCH_ATT,\n\t\t\t     chip->dac_volume[i * 2]);\n\t\tak4396_write(chip, i, AK4396_RCH_ATT,\n\t\t\t     chip->dac_volume[i * 2 + 1]);\n\t}\n}\n\nstatic void ak4396_init(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\n\tdata->dacs = chip->model.dac_channels_pcm / 2;\n\tdata->ak4396_regs[0][AK4396_CONTROL_2] =\n\t\tAK4396_SMUTE | AK4396_DEM_OFF | AK4396_DFS_NORMAL;\n\tak4396_registers_init(chip);\n\tsnd_component_add(chip->card, \"AK4396\");\n}\n\nstatic void ak5385_init(struct oxygen *chip)\n{\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_AK5385_DFS_MASK);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_AK5385_DFS_MASK);\n\tsnd_component_add(chip->card, \"AK5385\");\n}\n\nstatic void wm8785_registers_init(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\n\twm8785_write(chip, WM8785_R7, 0);\n\twm8785_write(chip, WM8785_R0, data->wm8785_regs[0]);\n\twm8785_write(chip, WM8785_R2, data->wm8785_regs[2]);\n}\n\nstatic void wm8785_init(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\n\tdata->wm8785_regs[0] =\n\t\tWM8785_MCR_SLAVE | WM8785_OSR_SINGLE | WM8785_FORMAT_LJUST;\n\tdata->wm8785_regs[2] = WM8785_HPFR | WM8785_HPFL;\n\twm8785_registers_init(chip);\n\tsnd_component_add(chip->card, \"WM8785\");\n}\n\nstatic void generic_init(struct oxygen *chip)\n{\n\tak4396_init(chip);\n\twm8785_init(chip);\n}\n\nstatic void meridian_init(struct oxygen *chip)\n{\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t  GPIO_MERIDIAN_DIG_MASK);\n\toxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\n\t\t\t      GPIO_MERIDIAN_DIG_BOARD, GPIO_MERIDIAN_DIG_MASK);\n\tak4396_init(chip);\n\tak5385_init(chip);\n}\n\nstatic void claro_enable_hp(struct oxygen *chip)\n{\n\tmsleep(300);\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_HP);\n\toxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_HP);\n}\n\nstatic void claro_init(struct oxygen *chip)\n{\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_DIG_COAX);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_DIG_COAX);\n\tak4396_init(chip);\n\twm8785_init(chip);\n\tclaro_enable_hp(chip);\n}\n\nstatic void claro_halo_init(struct oxygen *chip)\n{\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_DIG_COAX);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_DIG_COAX);\n\tak4396_init(chip);\n\tak5385_init(chip);\n\tclaro_enable_hp(chip);\n}\n\nstatic void fantasia_init(struct oxygen *chip)\n{\n\tak4396_init(chip);\n\tsnd_component_add(chip->card, \"CS5340\");\n}\n\nstatic void stereo_output_init(struct oxygen *chip)\n{\n\tak4396_init(chip);\n}\n\nstatic void generic_cleanup(struct oxygen *chip)\n{\n}\n\nstatic void claro_disable_hp(struct oxygen *chip)\n{\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_HP);\n}\n\nstatic void claro_cleanup(struct oxygen *chip)\n{\n\tclaro_disable_hp(chip);\n}\n\nstatic void claro_suspend(struct oxygen *chip)\n{\n\tclaro_disable_hp(chip);\n}\n\nstatic void generic_resume(struct oxygen *chip)\n{\n\tak4396_registers_init(chip);\n\twm8785_registers_init(chip);\n}\n\nstatic void meridian_resume(struct oxygen *chip)\n{\n\tak4396_registers_init(chip);\n}\n\nstatic void claro_resume(struct oxygen *chip)\n{\n\tak4396_registers_init(chip);\n\tclaro_enable_hp(chip);\n}\n\nstatic void stereo_resume(struct oxygen *chip)\n{\n\tak4396_registers_init(chip);\n}\n\nstatic void set_ak4396_params(struct oxygen *chip,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\tu8 value;\n\n\tvalue = data->ak4396_regs[0][AK4396_CONTROL_2] & ~AK4396_DFS_MASK;\n\tif (params_rate(params) <= 54000)\n\t\tvalue |= AK4396_DFS_NORMAL;\n\telse if (params_rate(params) <= 108000)\n\t\tvalue |= AK4396_DFS_DOUBLE;\n\telse\n\t\tvalue |= AK4396_DFS_QUAD;\n\n\tmsleep(1);  \n\n\tif (value != data->ak4396_regs[0][AK4396_CONTROL_2]) {\n\t\tfor (i = 0; i < data->dacs; ++i) {\n\t\t\tak4396_write(chip, i, AK4396_CONTROL_1,\n\t\t\t\t     AK4396_DIF_24_MSB);\n\t\t\tak4396_write(chip, i, AK4396_CONTROL_2, value);\n\t\t\tak4396_write(chip, i, AK4396_CONTROL_1,\n\t\t\t\t     AK4396_DIF_24_MSB | AK4396_RSTN);\n\t\t}\n\t}\n}\n\nstatic void update_ak4396_volume(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\n\tfor (i = 0; i < data->dacs; ++i) {\n\t\tak4396_write_cached(chip, i, AK4396_LCH_ATT,\n\t\t\t\t    chip->dac_volume[i * 2]);\n\t\tak4396_write_cached(chip, i, AK4396_RCH_ATT,\n\t\t\t\t    chip->dac_volume[i * 2 + 1]);\n\t}\n}\n\nstatic void update_ak4396_mute(struct oxygen *chip)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\tu8 value;\n\n\tvalue = data->ak4396_regs[0][AK4396_CONTROL_2] & ~AK4396_SMUTE;\n\tif (chip->dac_mute)\n\t\tvalue |= AK4396_SMUTE;\n\tfor (i = 0; i < data->dacs; ++i)\n\t\tak4396_write_cached(chip, i, AK4396_CONTROL_2, value);\n}\n\nstatic void set_wm8785_params(struct oxygen *chip,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int value;\n\n\tvalue = WM8785_MCR_SLAVE | WM8785_FORMAT_LJUST;\n\tif (params_rate(params) <= 48000)\n\t\tvalue |= WM8785_OSR_SINGLE;\n\telse if (params_rate(params) <= 96000)\n\t\tvalue |= WM8785_OSR_DOUBLE;\n\telse\n\t\tvalue |= WM8785_OSR_QUAD;\n\tif (value != data->wm8785_regs[0]) {\n\t\twm8785_write(chip, WM8785_R7, 0);\n\t\twm8785_write(chip, WM8785_R0, value);\n\t\twm8785_write(chip, WM8785_R2, data->wm8785_regs[2]);\n\t}\n}\n\nstatic void set_ak5385_params(struct oxygen *chip,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tunsigned int value;\n\n\tif (params_rate(params) <= 54000)\n\t\tvalue = GPIO_AK5385_DFS_NORMAL;\n\telse if (params_rate(params) <= 108000)\n\t\tvalue = GPIO_AK5385_DFS_DOUBLE;\n\telse\n\t\tvalue = GPIO_AK5385_DFS_QUAD;\n\toxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\n\t\t\t      value, GPIO_AK5385_DFS_MASK);\n}\n\nstatic void set_no_params(struct oxygen *chip, struct snd_pcm_hw_params *params)\n{\n}\n\nstatic int rolloff_info(struct snd_kcontrol *ctl,\n\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = {\n\t\t\"Sharp Roll-off\", \"Slow Roll-off\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int rolloff_get(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct generic_data *data = chip->model_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t(data->ak4396_regs[0][AK4396_CONTROL_2] & AK4396_SLOW) != 0;\n\treturn 0;\n}\n\nstatic int rolloff_put(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\tint changed;\n\tu8 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->ak4396_regs[0][AK4396_CONTROL_2];\n\tif (value->value.enumerated.item[0])\n\t\treg |= AK4396_SLOW;\n\telse\n\t\treg &= ~AK4396_SLOW;\n\tchanged = reg != data->ak4396_regs[0][AK4396_CONTROL_2];\n\tif (changed) {\n\t\tfor (i = 0; i < data->dacs; ++i)\n\t\t\tak4396_write(chip, i, AK4396_CONTROL_2, reg);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new rolloff_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DAC Filter Playback Enum\",\n\t.info = rolloff_info,\n\t.get = rolloff_get,\n\t.put = rolloff_put,\n};\n\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = {\n\t\t\"None\", \"High-pass Filter\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct generic_data *data = chip->model_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t(data->wm8785_regs[WM8785_R2] & WM8785_HPFR) != 0;\n\treturn 0;\n}\n\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->wm8785_regs[WM8785_R2] & ~(WM8785_HPFR | WM8785_HPFL);\n\tif (value->value.enumerated.item[0])\n\t\treg |= WM8785_HPFR | WM8785_HPFL;\n\tchanged = reg != data->wm8785_regs[WM8785_R2];\n\tif (changed)\n\t\twm8785_write(chip, WM8785_R2, reg);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new hpf_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"ADC Filter Capture Enum\",\n\t.info = hpf_info,\n\t.get = hpf_get,\n\t.put = hpf_put,\n};\n\nstatic int meridian_dig_source_info(struct snd_kcontrol *ctl,\n\t\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = { \"On-board\", \"Extension\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int claro_dig_source_info(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = { \"Optical\", \"Coaxial\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int meridian_dig_source_get(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t!!(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\n\t\t   GPIO_MERIDIAN_DIG_EXT);\n\treturn 0;\n}\n\nstatic int claro_dig_source_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t!!(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\n\t\t   GPIO_CLARO_DIG_COAX);\n\treturn 0;\n}\n\nstatic int meridian_dig_source_put(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 old_reg, new_reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\told_reg = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tnew_reg = old_reg & ~GPIO_MERIDIAN_DIG_MASK;\n\tif (value->value.enumerated.item[0] == 0)\n\t\tnew_reg |= GPIO_MERIDIAN_DIG_BOARD;\n\telse\n\t\tnew_reg |= GPIO_MERIDIAN_DIG_EXT;\n\tchanged = new_reg != old_reg;\n\tif (changed)\n\t\toxygen_write16(chip, OXYGEN_GPIO_DATA, new_reg);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int claro_dig_source_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 old_reg, new_reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\told_reg = oxygen_read16(chip, OXYGEN_GPIO_DATA);\n\tnew_reg = old_reg & ~GPIO_CLARO_DIG_COAX;\n\tif (value->value.enumerated.item[0])\n\t\tnew_reg |= GPIO_CLARO_DIG_COAX;\n\tchanged = new_reg != old_reg;\n\tif (changed)\n\t\toxygen_write16(chip, OXYGEN_GPIO_DATA, new_reg);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new meridian_dig_source_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"IEC958 Source Capture Enum\",\n\t.info = meridian_dig_source_info,\n\t.get = meridian_dig_source_get,\n\t.put = meridian_dig_source_put,\n};\n\nstatic const struct snd_kcontrol_new claro_dig_source_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"IEC958 Source Capture Enum\",\n\t.info = claro_dig_source_info,\n\t.get = claro_dig_source_get,\n\t.put = claro_dig_source_put,\n};\n\nstatic int generic_mixer_init(struct oxygen *chip)\n{\n\treturn snd_ctl_add(chip->card, snd_ctl_new1(&rolloff_control, chip));\n}\n\nstatic int generic_wm8785_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = generic_mixer_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&hpf_control, chip));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int meridian_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = generic_mixer_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&meridian_dig_source_control, chip));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int claro_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = generic_wm8785_mixer_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&claro_dig_source_control, chip));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int claro_halo_mixer_init(struct oxygen *chip)\n{\n\tint err;\n\n\terr = generic_mixer_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&claro_dig_source_control, chip));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void dump_ak4396_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int dac, i;\n\n\tfor (dac = 0; dac < data->dacs; ++dac) {\n\t\tsnd_iprintf(buffer, \"\\nAK4396 %u:\", dac + 1);\n\t\tfor (i = 0; i < 5; ++i)\n\t\t\tsnd_iprintf(buffer, \" %02x\", data->ak4396_regs[dac][i]);\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void dump_wm8785_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct generic_data *data = chip->model_data;\n\tunsigned int i;\n\n\tsnd_iprintf(buffer, \"\\nWM8785:\");\n\tfor (i = 0; i < 3; ++i)\n\t\tsnd_iprintf(buffer, \" %03x\", data->wm8785_regs[i]);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void dump_oxygen_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tdump_ak4396_registers(chip, buffer);\n\tdump_wm8785_registers(chip, buffer);\n}\n\nstatic const DECLARE_TLV_DB_LINEAR(ak4396_db_scale, TLV_DB_GAIN_MUTE, 0);\n\nstatic const struct oxygen_model model_generic = {\n\t.shortname = \"C-Media CMI8788\",\n\t.longname = \"C-Media Oxygen HD Audio\",\n\t.chip = \"CMI8788\",\n\t.init = generic_init,\n\t.mixer_init = generic_wm8785_mixer_init,\n\t.cleanup = generic_cleanup,\n\t.resume = generic_resume,\n\t.set_dac_params = set_ak4396_params,\n\t.set_adc_params = set_wm8785_params,\n\t.update_dac_volume = update_ak4396_volume,\n\t.update_dac_mute = update_ak4396_mute,\n\t.dump_registers = dump_oxygen_registers,\n\t.dac_tlv = ak4396_db_scale,\n\t.model_data_size = sizeof(struct generic_data),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t PLAYBACK_2_TO_AC97_1 |\n\t\t\t CAPTURE_0_FROM_I2S_1 |\n\t\t\t CAPTURE_1_FROM_SPDIF |\n\t\t\t CAPTURE_2_FROM_AC97_1 |\n\t\t\t AC97_CD_INPUT,\n\t.dac_channels_pcm = 8,\n\t.dac_channels_mixer = 8,\n\t.dac_volume_min = 0,\n\t.dac_volume_max = 255,\n\t.function_flags = OXYGEN_FUNCTION_SPI |\n\t\t\t  OXYGEN_FUNCTION_ENABLE_SPI_4_5,\n\t.dac_mclks = OXYGEN_MCLKS(256, 128, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 256, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nstatic int get_oxygen_model(struct oxygen *chip,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstatic const char *const names[] = {\n\t\t[MODEL_MERIDIAN]\t= \"AuzenTech X-Meridian\",\n\t\t[MODEL_MERIDIAN_2G]\t= \"AuzenTech X-Meridian 2G\",\n\t\t[MODEL_CLARO]\t\t= \"HT-Omega Claro\",\n\t\t[MODEL_CLARO_HALO]\t= \"HT-Omega Claro halo\",\n\t\t[MODEL_FANTASIA]\t= \"TempoTec HiFier Fantasia\",\n\t\t[MODEL_SERENADE]\t= \"TempoTec HiFier Serenade\",\n\t\t[MODEL_HG2PCI]\t\t= \"CMI8787-HG2PCI\",\n\t\t[MODEL_XONAR_DG]        = \"Xonar DG\",\n\t\t[MODEL_XONAR_DGX]       = \"Xonar DGX\",\n\t};\n\n\tchip->model = model_generic;\n\tswitch (id->driver_data) {\n\tcase MODEL_MERIDIAN:\n\tcase MODEL_MERIDIAN_2G:\n\t\tchip->model.init = meridian_init;\n\t\tchip->model.mixer_init = meridian_mixer_init;\n\t\tchip->model.resume = meridian_resume;\n\t\tchip->model.set_adc_params = set_ak5385_params;\n\t\tchip->model.dump_registers = dump_ak4396_registers;\n\t\tchip->model.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t\t\t    PLAYBACK_1_TO_SPDIF |\n\t\t\t\t\t    CAPTURE_0_FROM_I2S_2 |\n\t\t\t\t\t    CAPTURE_1_FROM_SPDIF;\n\t\tif (id->driver_data == MODEL_MERIDIAN)\n\t\t\tchip->model.device_config |= AC97_CD_INPUT;\n\t\tbreak;\n\tcase MODEL_CLARO:\n\t\tchip->model.init = claro_init;\n\t\tchip->model.mixer_init = claro_mixer_init;\n\t\tchip->model.cleanup = claro_cleanup;\n\t\tchip->model.suspend = claro_suspend;\n\t\tchip->model.resume = claro_resume;\n\t\tbreak;\n\tcase MODEL_CLARO_HALO:\n\t\tchip->model.init = claro_halo_init;\n\t\tchip->model.mixer_init = claro_halo_mixer_init;\n\t\tchip->model.cleanup = claro_cleanup;\n\t\tchip->model.suspend = claro_suspend;\n\t\tchip->model.resume = claro_resume;\n\t\tchip->model.set_adc_params = set_ak5385_params;\n\t\tchip->model.dump_registers = dump_ak4396_registers;\n\t\tchip->model.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t\t\t    PLAYBACK_1_TO_SPDIF |\n\t\t\t\t\t    CAPTURE_0_FROM_I2S_2 |\n\t\t\t\t\t    CAPTURE_1_FROM_SPDIF;\n\t\tbreak;\n\tcase MODEL_FANTASIA:\n\tcase MODEL_SERENADE:\n\tcase MODEL_2CH_OUTPUT:\n\tcase MODEL_HG2PCI:\n\t\tchip->model.shortname = \"C-Media CMI8787\";\n\t\tchip->model.chip = \"CMI8787\";\n\t\tif (id->driver_data == MODEL_FANTASIA)\n\t\t\tchip->model.init = fantasia_init;\n\t\telse\n\t\t\tchip->model.init = stereo_output_init;\n\t\tchip->model.resume = stereo_resume;\n\t\tchip->model.mixer_init = generic_mixer_init;\n\t\tchip->model.set_adc_params = set_no_params;\n\t\tchip->model.dump_registers = dump_ak4396_registers;\n\t\tchip->model.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t\t\t    PLAYBACK_1_TO_SPDIF;\n\t\tif (id->driver_data == MODEL_FANTASIA) {\n\t\t\tchip->model.device_config |= CAPTURE_0_FROM_I2S_1;\n\t\t\tchip->model.adc_mclks = OXYGEN_MCLKS(256, 128, 128);\n\t\t}\n\t\tchip->model.dac_channels_pcm = 2;\n\t\tchip->model.dac_channels_mixer = 2;\n\t\tbreak;\n\tcase MODEL_XONAR_DG:\n\tcase MODEL_XONAR_DGX:\n\t\tchip->model = model_xonar_dg;\n\t\tbreak;\n\t}\n\tif (id->driver_data == MODEL_MERIDIAN ||\n\t    id->driver_data == MODEL_MERIDIAN_2G ||\n\t    id->driver_data == MODEL_CLARO_HALO) {\n\t\tchip->model.misc_flags = OXYGEN_MISC_MIDI;\n\t\tchip->model.device_config |= MIDI_OUTPUT | MIDI_INPUT;\n\t}\n\tif (id->driver_data < ARRAY_SIZE(names) && names[id->driver_data])\n\t\tchip->model.shortname = names[id->driver_data];\n\treturn 0;\n}\n\nstatic int generic_oxygen_probe(struct pci_dev *pci,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\t++dev;\n\t\treturn -ENOENT;\n\t}\n\terr = oxygen_pci_probe(pci, index[dev], id[dev], THIS_MODULE,\n\t\t\t       oxygen_ids, get_oxygen_model);\n\tif (err >= 0)\n\t\t++dev;\n\treturn err;\n}\n\nstatic struct pci_driver oxygen_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = oxygen_ids,\n\t.probe = generic_oxygen_probe,\n#ifdef CONFIG_PM_SLEEP\n\t.driver = {\n\t\t.pm = &oxygen_pci_pm,\n\t},\n#endif\n};\n\nmodule_pci_driver(oxygen_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}