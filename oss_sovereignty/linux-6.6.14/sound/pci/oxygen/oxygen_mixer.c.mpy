{
  "module_name": "oxygen_mixer.c",
  "hash_id": "2829be56c6de686a998a7a74a3087bbd5070ff76e61b419275389b2e845f3ed6",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/oxygen_mixer.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <sound/ac97_codec.h>\n#include <sound/asoundef.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"oxygen.h\"\n#include \"cm9780.h\"\n\nstatic int dac_volume_info(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_info *info)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = chip->model.dac_channels_mixer;\n\tinfo->value.integer.min = chip->model.dac_volume_min;\n\tinfo->value.integer.max = chip->model.dac_volume_max;\n\treturn 0;\n}\n\nstatic int dac_volume_get(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int i;\n\n\tmutex_lock(&chip->mutex);\n\tfor (i = 0; i < chip->model.dac_channels_mixer; ++i)\n\t\tvalue->value.integer.value[i] = chip->dac_volume[i];\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int dac_volume_put(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int i;\n\tint changed;\n\n\tchanged = 0;\n\tmutex_lock(&chip->mutex);\n\tfor (i = 0; i < chip->model.dac_channels_mixer; ++i)\n\t\tif (value->value.integer.value[i] != chip->dac_volume[i]) {\n\t\t\tchip->dac_volume[i] = value->value.integer.value[i];\n\t\t\tchanged = 1;\n\t\t}\n\tif (changed)\n\t\tchip->model.update_dac_volume(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int dac_mute_get(struct snd_kcontrol *ctl,\n\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.integer.value[0] = !chip->dac_mute;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int dac_mute_put(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\tchanged = (!value->value.integer.value[0]) != chip->dac_mute;\n\tif (changed) {\n\t\tchip->dac_mute = !value->value.integer.value[0];\n\t\tchip->model.update_dac_mute(chip);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic unsigned int upmix_item_count(struct oxygen *chip)\n{\n\tif (chip->model.dac_channels_pcm < 8)\n\t\treturn 2;\n\telse if (chip->model.update_center_lfe_mix)\n\t\treturn 5;\n\telse\n\t\treturn 3;\n}\n\nstatic int upmix_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[5] = {\n\t\t\"Front\",\n\t\t\"Front+Surround\",\n\t\t\"Front+Surround+Back\",\n\t\t\"Front+Surround+Center/LFE\",\n\t\t\"Front+Surround+Center/LFE+Back\",\n\t};\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int count = upmix_item_count(chip);\n\n\treturn snd_ctl_enum_info(info, 1, count, names);\n}\n\nstatic int upmix_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.enumerated.item[0] = chip->dac_routing;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nvoid oxygen_update_dac_routing(struct oxygen *chip)\n{\n\t \n\tstatic const unsigned int reg_values[5] = {\n\t\t \n\t\t(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t(1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\n\t\t \n\t\t(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\n\t\t \n\t\t(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\n\t\t \n\t\t(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\n\t\t \n\t\t(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t(0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\n\t};\n\tu8 channels;\n\tunsigned int reg_value;\n\n\tchannels = oxygen_read8(chip, OXYGEN_PLAY_CHANNELS) &\n\t\tOXYGEN_PLAY_CHANNELS_MASK;\n\tif (channels == OXYGEN_PLAY_CHANNELS_2)\n\t\treg_value = reg_values[chip->dac_routing];\n\telse if (channels == OXYGEN_PLAY_CHANNELS_8)\n\t\t \n\t\treg_value = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t\t    (3 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t\t    (2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t\t    (1 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);\n\telse\n\t\treg_value = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\n\t\t\t    (1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\n\t\t\t    (2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\n\t\t\t    (3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);\n\tif (chip->model.adjust_dac_routing)\n\t\treg_value = chip->model.adjust_dac_routing(chip, reg_value);\n\toxygen_write16_masked(chip, OXYGEN_PLAY_ROUTING, reg_value,\n\t\t\t      OXYGEN_PLAY_DAC0_SOURCE_MASK |\n\t\t\t      OXYGEN_PLAY_DAC1_SOURCE_MASK |\n\t\t\t      OXYGEN_PLAY_DAC2_SOURCE_MASK |\n\t\t\t      OXYGEN_PLAY_DAC3_SOURCE_MASK);\n\tif (chip->model.update_center_lfe_mix)\n\t\tchip->model.update_center_lfe_mix(chip, chip->dac_routing > 2);\n}\nEXPORT_SYMBOL(oxygen_update_dac_routing);\n\nstatic int upmix_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int count = upmix_item_count(chip);\n\tint changed;\n\n\tif (value->value.enumerated.item[0] >= count)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mutex);\n\tchanged = value->value.enumerated.item[0] != chip->dac_routing;\n\tif (changed) {\n\t\tchip->dac_routing = value->value.enumerated.item[0];\n\t\toxygen_update_dac_routing(chip);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int spdif_switch_get(struct snd_kcontrol *ctl,\n\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.integer.value[0] = chip->spdif_playback_enable;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic unsigned int oxygen_spdif_rate(unsigned int oxygen_rate)\n{\n\tswitch (oxygen_rate) {\n\tcase OXYGEN_RATE_32000:\n\t\treturn IEC958_AES3_CON_FS_32000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_44100:\n\t\treturn IEC958_AES3_CON_FS_44100 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tdefault:  \n\t\treturn IEC958_AES3_CON_FS_48000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_64000:\n\t\treturn 0xb << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_88200:\n\t\treturn IEC958_AES3_CON_FS_88200 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_96000:\n\t\treturn IEC958_AES3_CON_FS_96000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_176400:\n\t\treturn IEC958_AES3_CON_FS_176400 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\tcase OXYGEN_RATE_192000:\n\t\treturn IEC958_AES3_CON_FS_192000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\n\t}\n}\n\nvoid oxygen_update_spdif_source(struct oxygen *chip)\n{\n\tu32 old_control, new_control;\n\tu16 old_routing, new_routing;\n\tunsigned int oxygen_rate;\n\n\told_control = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\n\told_routing = oxygen_read16(chip, OXYGEN_PLAY_ROUTING);\n\tif (chip->pcm_active & (1 << PCM_SPDIF)) {\n\t\tnew_control = old_control | OXYGEN_SPDIF_OUT_ENABLE;\n\t\tnew_routing = (old_routing & ~OXYGEN_PLAY_SPDIF_MASK)\n\t\t\t| OXYGEN_PLAY_SPDIF_SPDIF;\n\t\toxygen_rate = (old_control >> OXYGEN_SPDIF_OUT_RATE_SHIFT)\n\t\t\t& OXYGEN_I2S_RATE_MASK;\n\t\t \n\t} else if ((chip->pcm_active & (1 << PCM_MULTICH)) &&\n\t\t   chip->spdif_playback_enable) {\n\t\tnew_routing = (old_routing & ~OXYGEN_PLAY_SPDIF_MASK)\n\t\t\t| OXYGEN_PLAY_SPDIF_MULTICH_01;\n\t\toxygen_rate = oxygen_read16(chip, OXYGEN_I2S_MULTICH_FORMAT)\n\t\t\t& OXYGEN_I2S_RATE_MASK;\n\t\tnew_control = (old_control & ~OXYGEN_SPDIF_OUT_RATE_MASK) |\n\t\t\t(oxygen_rate << OXYGEN_SPDIF_OUT_RATE_SHIFT) |\n\t\t\tOXYGEN_SPDIF_OUT_ENABLE;\n\t} else {\n\t\tnew_control = old_control & ~OXYGEN_SPDIF_OUT_ENABLE;\n\t\tnew_routing = old_routing;\n\t\toxygen_rate = OXYGEN_RATE_44100;\n\t}\n\tif (old_routing != new_routing) {\n\t\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL,\n\t\t\t       new_control & ~OXYGEN_SPDIF_OUT_ENABLE);\n\t\toxygen_write16(chip, OXYGEN_PLAY_ROUTING, new_routing);\n\t}\n\tif (new_control & OXYGEN_SPDIF_OUT_ENABLE)\n\t\toxygen_write32(chip, OXYGEN_SPDIF_OUTPUT_BITS,\n\t\t\t       oxygen_spdif_rate(oxygen_rate) |\n\t\t\t       ((chip->pcm_active & (1 << PCM_SPDIF)) ?\n\t\t\t\tchip->spdif_pcm_bits : chip->spdif_bits));\n\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL, new_control);\n}\n\nstatic int spdif_switch_put(struct snd_kcontrol *ctl,\n\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\tchanged = value->value.integer.value[0] != chip->spdif_playback_enable;\n\tif (changed) {\n\t\tchip->spdif_playback_enable = !!value->value.integer.value[0];\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\toxygen_update_spdif_source(chip);\n\t\tspin_unlock_irq(&chip->reg_lock);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int spdif_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tinfo->count = 1;\n\treturn 0;\n}\n\nstatic void oxygen_to_iec958(u32 bits, struct snd_ctl_elem_value *value)\n{\n\tvalue->value.iec958.status[0] =\n\t\tbits & (OXYGEN_SPDIF_NONAUDIO | OXYGEN_SPDIF_C |\n\t\t\tOXYGEN_SPDIF_PREEMPHASIS);\n\tvalue->value.iec958.status[1] =  \n\t\tbits >> OXYGEN_SPDIF_CATEGORY_SHIFT;\n}\n\nstatic u32 iec958_to_oxygen(struct snd_ctl_elem_value *value)\n{\n\tu32 bits;\n\n\tbits = value->value.iec958.status[0] &\n\t\t(OXYGEN_SPDIF_NONAUDIO | OXYGEN_SPDIF_C |\n\t\t OXYGEN_SPDIF_PREEMPHASIS);\n\tbits |= value->value.iec958.status[1] << OXYGEN_SPDIF_CATEGORY_SHIFT;\n\tif (bits & OXYGEN_SPDIF_NONAUDIO)\n\t\tbits |= OXYGEN_SPDIF_V;\n\treturn bits;\n}\n\nstatic inline void write_spdif_bits(struct oxygen *chip, u32 bits)\n{\n\toxygen_write32_masked(chip, OXYGEN_SPDIF_OUTPUT_BITS, bits,\n\t\t\t      OXYGEN_SPDIF_NONAUDIO |\n\t\t\t      OXYGEN_SPDIF_C |\n\t\t\t      OXYGEN_SPDIF_PREEMPHASIS |\n\t\t\t      OXYGEN_SPDIF_CATEGORY_MASK |\n\t\t\t      OXYGEN_SPDIF_ORIGINAL |\n\t\t\t      OXYGEN_SPDIF_V);\n}\n\nstatic int spdif_default_get(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\toxygen_to_iec958(chip->spdif_bits, value);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int spdif_default_put(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu32 new_bits;\n\tint changed;\n\n\tnew_bits = iec958_to_oxygen(value);\n\tmutex_lock(&chip->mutex);\n\tchanged = new_bits != chip->spdif_bits;\n\tif (changed) {\n\t\tchip->spdif_bits = new_bits;\n\t\tif (!(chip->pcm_active & (1 << PCM_SPDIF)))\n\t\t\twrite_spdif_bits(chip, new_bits);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int spdif_mask_get(struct snd_kcontrol *ctl,\n\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tvalue->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\n\t\tIEC958_AES0_CON_NOT_COPYRIGHT | IEC958_AES0_CON_EMPHASIS;\n\tvalue->value.iec958.status[1] =\n\t\tIEC958_AES1_CON_CATEGORY | IEC958_AES1_CON_ORIGINAL;\n\treturn 0;\n}\n\nstatic int spdif_pcm_get(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\toxygen_to_iec958(chip->spdif_pcm_bits, value);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int spdif_pcm_put(struct snd_kcontrol *ctl,\n\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu32 new_bits;\n\tint changed;\n\n\tnew_bits = iec958_to_oxygen(value);\n\tmutex_lock(&chip->mutex);\n\tchanged = new_bits != chip->spdif_pcm_bits;\n\tif (changed) {\n\t\tchip->spdif_pcm_bits = new_bits;\n\t\tif (chip->pcm_active & (1 << PCM_SPDIF))\n\t\t\twrite_spdif_bits(chip, new_bits);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int spdif_input_mask_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tvalue->value.iec958.status[0] = 0xff;\n\tvalue->value.iec958.status[1] = 0xff;\n\tvalue->value.iec958.status[2] = 0xff;\n\tvalue->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int spdif_input_default_get(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu32 bits;\n\n\tbits = oxygen_read32(chip, OXYGEN_SPDIF_INPUT_BITS);\n\tvalue->value.iec958.status[0] = bits;\n\tvalue->value.iec958.status[1] = bits >> 8;\n\tvalue->value.iec958.status[2] = bits >> 16;\n\tvalue->value.iec958.status[3] = bits >> 24;\n\treturn 0;\n}\n\nstatic int spdif_bit_switch_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu32 bit = ctl->private_value;\n\n\tvalue->value.integer.value[0] =\n\t\t!!(oxygen_read32(chip, OXYGEN_SPDIF_CONTROL) & bit);\n\treturn 0;\n}\n\nstatic int spdif_bit_switch_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu32 bit = ctl->private_value;\n\tu32 oldreg, newreg;\n\tint changed;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toldreg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\n\tif (value->value.integer.value[0])\n\t\tnewreg = oldreg | bit;\n\telse\n\t\tnewreg = oldreg & ~bit;\n\tchanged = newreg != oldreg;\n\tif (changed)\n\t\toxygen_write32(chip, OXYGEN_SPDIF_CONTROL, newreg);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn changed;\n}\n\nstatic int monitor_volume_info(struct snd_kcontrol *ctl,\n\t\t\t       struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 1;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int monitor_get(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu8 bit = ctl->private_value;\n\tint invert = ctl->private_value & (1 << 8);\n\n\tvalue->value.integer.value[0] =\n\t\t!!invert ^ !!(oxygen_read8(chip, OXYGEN_ADC_MONITOR) & bit);\n\treturn 0;\n}\n\nstatic int monitor_put(struct snd_kcontrol *ctl,\n\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu8 bit = ctl->private_value;\n\tint invert = ctl->private_value & (1 << 8);\n\tu8 oldreg, newreg;\n\tint changed;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toldreg = oxygen_read8(chip, OXYGEN_ADC_MONITOR);\n\tif ((!!value->value.integer.value[0] ^ !!invert) != 0)\n\t\tnewreg = oldreg | bit;\n\telse\n\t\tnewreg = oldreg & ~bit;\n\tchanged = newreg != oldreg;\n\tif (changed)\n\t\toxygen_write8(chip, OXYGEN_ADC_MONITOR, newreg);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn changed;\n}\n\nstatic int ac97_switch_get(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int codec = (ctl->private_value >> 24) & 1;\n\tunsigned int index = ctl->private_value & 0xff;\n\tunsigned int bitnr = (ctl->private_value >> 8) & 0xff;\n\tint invert = ctl->private_value & (1 << 16);\n\tu16 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = oxygen_read_ac97(chip, codec, index);\n\tmutex_unlock(&chip->mutex);\n\tif (!(reg & (1 << bitnr)) ^ !invert)\n\t\tvalue->value.integer.value[0] = 1;\n\telse\n\t\tvalue->value.integer.value[0] = 0;\n\treturn 0;\n}\n\nstatic void mute_ac97_ctl(struct oxygen *chip, unsigned int control)\n{\n\tunsigned int priv_idx;\n\tu16 value;\n\n\tif (!chip->controls[control])\n\t\treturn;\n\tpriv_idx = chip->controls[control]->private_value & 0xff;\n\tvalue = oxygen_read_ac97(chip, 0, priv_idx);\n\tif (!(value & 0x8000)) {\n\t\toxygen_write_ac97(chip, 0, priv_idx, value | 0x8000);\n\t\tif (chip->model.ac97_switch)\n\t\t\tchip->model.ac97_switch(chip, priv_idx, 0x8000);\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->controls[control]->id);\n\t}\n}\n\nstatic int ac97_switch_put(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int codec = (ctl->private_value >> 24) & 1;\n\tunsigned int index = ctl->private_value & 0xff;\n\tunsigned int bitnr = (ctl->private_value >> 8) & 0xff;\n\tint invert = ctl->private_value & (1 << 16);\n\tu16 oldreg, newreg;\n\tint change;\n\n\tmutex_lock(&chip->mutex);\n\toldreg = oxygen_read_ac97(chip, codec, index);\n\tnewreg = oldreg;\n\tif (!value->value.integer.value[0] ^ !invert)\n\t\tnewreg |= 1 << bitnr;\n\telse\n\t\tnewreg &= ~(1 << bitnr);\n\tchange = newreg != oldreg;\n\tif (change) {\n\t\toxygen_write_ac97(chip, codec, index, newreg);\n\t\tif (codec == 0 && chip->model.ac97_switch)\n\t\t\tchip->model.ac97_switch(chip, index, newreg & 0x8000);\n\t\tif (index == AC97_LINE) {\n\t\t\toxygen_write_ac97_masked(chip, 0, CM9780_GPIO_STATUS,\n\t\t\t\t\t\t newreg & 0x8000 ?\n\t\t\t\t\t\t CM9780_GPO0 : 0, CM9780_GPO0);\n\t\t\tif (!(newreg & 0x8000)) {\n\t\t\t\tmute_ac97_ctl(chip, CONTROL_MIC_CAPTURE_SWITCH);\n\t\t\t\tmute_ac97_ctl(chip, CONTROL_CD_CAPTURE_SWITCH);\n\t\t\t\tmute_ac97_ctl(chip, CONTROL_AUX_CAPTURE_SWITCH);\n\t\t\t}\n\t\t} else if ((index == AC97_MIC || index == AC97_CD ||\n\t\t\t    index == AC97_VIDEO || index == AC97_AUX) &&\n\t\t\t   bitnr == 15 && !(newreg & 0x8000)) {\n\t\t\tmute_ac97_ctl(chip, CONTROL_LINE_CAPTURE_SWITCH);\n\t\t\toxygen_write_ac97_masked(chip, 0, CM9780_GPIO_STATUS,\n\t\t\t\t\t\t CM9780_GPO0, CM9780_GPO0);\n\t\t}\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn change;\n}\n\nstatic int ac97_volume_info(struct snd_kcontrol *ctl,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tint stereo = (ctl->private_value >> 16) & 1;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = stereo ? 2 : 1;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 0x1f;\n\treturn 0;\n}\n\nstatic int ac97_volume_get(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int codec = (ctl->private_value >> 24) & 1;\n\tint stereo = (ctl->private_value >> 16) & 1;\n\tunsigned int index = ctl->private_value & 0xff;\n\tu16 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = oxygen_read_ac97(chip, codec, index);\n\tmutex_unlock(&chip->mutex);\n\tif (!stereo) {\n\t\tvalue->value.integer.value[0] = 31 - (reg & 0x1f);\n\t} else {\n\t\tvalue->value.integer.value[0] = 31 - ((reg >> 8) & 0x1f);\n\t\tvalue->value.integer.value[1] = 31 - (reg & 0x1f);\n\t}\n\treturn 0;\n}\n\nstatic int ac97_volume_put(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int codec = (ctl->private_value >> 24) & 1;\n\tint stereo = (ctl->private_value >> 16) & 1;\n\tunsigned int index = ctl->private_value & 0xff;\n\tu16 oldreg, newreg;\n\tint change;\n\n\tmutex_lock(&chip->mutex);\n\toldreg = oxygen_read_ac97(chip, codec, index);\n\tif (!stereo) {\n\t\tnewreg = oldreg & ~0x1f;\n\t\tnewreg |= 31 - (value->value.integer.value[0] & 0x1f);\n\t} else {\n\t\tnewreg = oldreg & ~0x1f1f;\n\t\tnewreg |= (31 - (value->value.integer.value[0] & 0x1f)) << 8;\n\t\tnewreg |= 31 - (value->value.integer.value[1] & 0x1f);\n\t}\n\tchange = newreg != oldreg;\n\tif (change)\n\t\toxygen_write_ac97(chip, codec, index, newreg);\n\tmutex_unlock(&chip->mutex);\n\treturn change;\n}\n\nstatic int mic_fmic_source_info(struct snd_kcontrol *ctl,\n\t\t\t   struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"Mic Jack\", \"Front Panel\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int mic_fmic_source_get(struct snd_kcontrol *ctl,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.enumerated.item[0] =\n\t\t!!(oxygen_read_ac97(chip, 0, CM9780_JACK) & CM9780_FMIC2MIC);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int mic_fmic_source_put(struct snd_kcontrol *ctl,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 oldreg, newreg;\n\tint change;\n\n\tmutex_lock(&chip->mutex);\n\toldreg = oxygen_read_ac97(chip, 0, CM9780_JACK);\n\tif (value->value.enumerated.item[0])\n\t\tnewreg = oldreg | CM9780_FMIC2MIC;\n\telse\n\t\tnewreg = oldreg & ~CM9780_FMIC2MIC;\n\tchange = newreg != oldreg;\n\tif (change)\n\t\toxygen_write_ac97(chip, 0, CM9780_JACK, newreg);\n\tmutex_unlock(&chip->mutex);\n\treturn change;\n}\n\nstatic int ac97_fp_rec_volume_info(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 7;\n\treturn 0;\n}\n\nstatic int ac97_fp_rec_volume_get(struct snd_kcontrol *ctl,\n\t\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 reg;\n\n\tmutex_lock(&chip->mutex);\n\treg = oxygen_read_ac97(chip, 1, AC97_REC_GAIN);\n\tmutex_unlock(&chip->mutex);\n\tvalue->value.integer.value[0] = reg & 7;\n\tvalue->value.integer.value[1] = (reg >> 8) & 7;\n\treturn 0;\n}\n\nstatic int ac97_fp_rec_volume_put(struct snd_kcontrol *ctl,\n\t\t\t\t  struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu16 oldreg, newreg;\n\tint change;\n\n\tmutex_lock(&chip->mutex);\n\toldreg = oxygen_read_ac97(chip, 1, AC97_REC_GAIN);\n\tnewreg = oldreg & ~0x0707;\n\tnewreg = newreg | (value->value.integer.value[0] & 7);\n\tnewreg = newreg | ((value->value.integer.value[1] & 7) << 8);\n\tchange = newreg != oldreg;\n\tif (change)\n\t\toxygen_write_ac97(chip, 1, AC97_REC_GAIN, newreg);\n\tmutex_unlock(&chip->mutex);\n\treturn change;\n}\n\n#define AC97_SWITCH(xname, codec, index, bitnr, invert) { \\\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t\t.name = xname, \\\n\t\t.info = snd_ctl_boolean_mono_info, \\\n\t\t.get = ac97_switch_get, \\\n\t\t.put = ac97_switch_put, \\\n\t\t.private_value = ((codec) << 24) | ((invert) << 16) | \\\n\t\t\t\t ((bitnr) << 8) | (index), \\\n\t}\n#define AC97_VOLUME(xname, codec, index, stereo) { \\\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t\t.name = xname, \\\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n\t\t.info = ac97_volume_info, \\\n\t\t.get = ac97_volume_get, \\\n\t\t.put = ac97_volume_put, \\\n\t\t.tlv = { .p = ac97_db_scale, }, \\\n\t\t.private_value = ((codec) << 24) | ((stereo) << 16) | (index), \\\n\t}\n\nstatic DECLARE_TLV_DB_SCALE(monitor_db_scale, -600, 600, 0);\nstatic DECLARE_TLV_DB_SCALE(ac97_db_scale, -3450, 150, 0);\nstatic DECLARE_TLV_DB_SCALE(ac97_rec_db_scale, 0, 150, 0);\n\nstatic const struct snd_kcontrol_new controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = dac_volume_info,\n\t\t.get = dac_volume_get,\n\t\t.put = dac_volume_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Master Playback Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = dac_mute_get,\n\t\t.put = dac_mute_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Stereo Upmixing\",\n\t\t.info = upmix_info,\n\t\t.get = upmix_get,\n\t\t.put = upmix_put,\n\t},\n};\n\nstatic const struct snd_kcontrol_new spdif_output_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, SWITCH),\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = spdif_switch_get,\n\t\t.put = spdif_switch_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.device = 1,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = spdif_info,\n\t\t.get = spdif_default_get,\n\t\t.put = spdif_default_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.device = 1,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = spdif_info,\n\t\t.get = spdif_mask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.device = 1,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PCM_STREAM),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t\t.info = spdif_info,\n\t\t.get = spdif_pcm_get,\n\t\t.put = spdif_pcm_put,\n\t},\n};\n\nstatic const struct snd_kcontrol_new spdif_input_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.device = 1,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, MASK),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = spdif_info,\n\t\t.get = spdif_input_mask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.device = 1,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = spdif_info,\n\t\t.get = spdif_input_default_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"Loopback \", NONE, SWITCH),\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = spdif_bit_switch_get,\n\t\t.put = spdif_bit_switch_put,\n\t\t.private_value = OXYGEN_SPDIF_LOOPBACK,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"Validity Check \",CAPTURE,SWITCH),\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = spdif_bit_switch_get,\n\t\t.put = spdif_bit_switch_put,\n\t\t.private_value = OXYGEN_SPDIF_SPDVALID,\n\t},\n};\n\nstatic const struct {\n\tunsigned int pcm_dev;\n\tstruct snd_kcontrol_new controls[2];\n} monitor_controls[] = {\n\t{\n\t\t.pcm_dev = CAPTURE_0_FROM_I2S_1,\n\t\t.controls = {\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Switch\",\n\t\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_A,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Volume\",\n\t\t\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t\t\t.info = monitor_volume_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_A_HALF_VOL\n\t\t\t\t\t\t| (1 << 8),\n\t\t\t\t.tlv = { .p = monitor_db_scale, },\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.pcm_dev = CAPTURE_0_FROM_I2S_2,\n\t\t.controls = {\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Switch\",\n\t\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_B,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Volume\",\n\t\t\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t\t\t.info = monitor_volume_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_B_HALF_VOL\n\t\t\t\t\t\t| (1 << 8),\n\t\t\t\t.tlv = { .p = monitor_db_scale, },\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.pcm_dev = CAPTURE_2_FROM_I2S_2,\n\t\t.controls = {\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Switch\",\n\t\t\t\t.index = 1,\n\t\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_B,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Volume\",\n\t\t\t\t.index = 1,\n\t\t\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t\t\t.info = monitor_volume_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_B_HALF_VOL\n\t\t\t\t\t\t| (1 << 8),\n\t\t\t\t.tlv = { .p = monitor_db_scale, },\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.pcm_dev = CAPTURE_3_FROM_I2S_3,\n\t\t.controls = {\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Switch\",\n\t\t\t\t.index = 2,\n\t\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_C,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Analog Input Monitor Playback Volume\",\n\t\t\t\t.index = 2,\n\t\t\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t\t\t.info = monitor_volume_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_C_HALF_VOL\n\t\t\t\t\t\t| (1 << 8),\n\t\t\t\t.tlv = { .p = monitor_db_scale, },\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t.pcm_dev = CAPTURE_1_FROM_SPDIF,\n\t\t.controls = {\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Digital Input Monitor Playback Switch\",\n\t\t\t\t.info = snd_ctl_boolean_mono_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_C,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t\t\t.name = \"Digital Input Monitor Playback Volume\",\n\t\t\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t\t\t.info = monitor_volume_info,\n\t\t\t\t.get = monitor_get,\n\t\t\t\t.put = monitor_put,\n\t\t\t\t.private_value = OXYGEN_ADC_MONITOR_C_HALF_VOL\n\t\t\t\t\t\t| (1 << 8),\n\t\t\t\t.tlv = { .p = monitor_db_scale, },\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic const struct snd_kcontrol_new ac97_controls[] = {\n\tAC97_VOLUME(\"Mic Capture Volume\", 0, AC97_MIC, 0),\n\tAC97_SWITCH(\"Mic Capture Switch\", 0, AC97_MIC, 15, 1),\n\tAC97_SWITCH(\"Mic Boost (+20dB)\", 0, AC97_MIC, 6, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Source Capture Enum\",\n\t\t.info = mic_fmic_source_info,\n\t\t.get = mic_fmic_source_get,\n\t\t.put = mic_fmic_source_put,\n\t},\n\tAC97_SWITCH(\"Line Capture Switch\", 0, AC97_LINE, 15, 1),\n\tAC97_VOLUME(\"CD Capture Volume\", 0, AC97_CD, 1),\n\tAC97_SWITCH(\"CD Capture Switch\", 0, AC97_CD, 15, 1),\n\tAC97_VOLUME(\"Aux Capture Volume\", 0, AC97_AUX, 1),\n\tAC97_SWITCH(\"Aux Capture Switch\", 0, AC97_AUX, 15, 1),\n};\n\nstatic const struct snd_kcontrol_new ac97_fp_controls[] = {\n\tAC97_VOLUME(\"Front Panel Playback Volume\", 1, AC97_HEADPHONE, 1),\n\tAC97_SWITCH(\"Front Panel Playback Switch\", 1, AC97_HEADPHONE, 15, 1),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Front Panel Capture Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t\t.info = ac97_fp_rec_volume_info,\n\t\t.get = ac97_fp_rec_volume_get,\n\t\t.put = ac97_fp_rec_volume_put,\n\t\t.tlv = { .p = ac97_rec_db_scale, },\n\t},\n\tAC97_SWITCH(\"Front Panel Capture Switch\", 1, AC97_REC_GAIN, 15, 1),\n};\n\nstatic void oxygen_any_ctl_free(struct snd_kcontrol *ctl)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(chip->controls); ++i)\n\t\tchip->controls[i] = NULL;\n}\n\nstatic int add_controls(struct oxygen *chip,\n\t\t\tconst struct snd_kcontrol_new controls[],\n\t\t\tunsigned int count)\n{\n\tstatic const char *const known_ctl_names[CONTROL_COUNT] = {\n\t\t[CONTROL_SPDIF_PCM] =\n\t\t\tSNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PCM_STREAM),\n\t\t[CONTROL_SPDIF_INPUT_BITS] =\n\t\t\tSNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t[CONTROL_MIC_CAPTURE_SWITCH] = \"Mic Capture Switch\",\n\t\t[CONTROL_LINE_CAPTURE_SWITCH] = \"Line Capture Switch\",\n\t\t[CONTROL_CD_CAPTURE_SWITCH] = \"CD Capture Switch\",\n\t\t[CONTROL_AUX_CAPTURE_SWITCH] = \"Aux Capture Switch\",\n\t};\n\tunsigned int i;\n\tstruct snd_kcontrol_new template;\n\tstruct snd_kcontrol *ctl;\n\tint j, err;\n\n\tfor (i = 0; i < count; ++i) {\n\t\ttemplate = controls[i];\n\t\tif (chip->model.control_filter) {\n\t\t\terr = chip->model.control_filter(&template);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(template.name, \"Stereo Upmixing\") &&\n\t\t    chip->model.dac_channels_pcm == 2)\n\t\t\tcontinue;\n\t\tif (!strcmp(template.name, \"Mic Source Capture Enum\") &&\n\t\t    !(chip->model.device_config & AC97_FMIC_SWITCH))\n\t\t\tcontinue;\n\t\tif (!strncmp(template.name, \"CD Capture \", 11) &&\n\t\t    !(chip->model.device_config & AC97_CD_INPUT))\n\t\t\tcontinue;\n\t\tif (!strcmp(template.name, \"Master Playback Volume\") &&\n\t\t    chip->model.dac_tlv) {\n\t\t\ttemplate.tlv.p = chip->model.dac_tlv;\n\t\t\ttemplate.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\t}\n\t\tctl = snd_ctl_new1(&template, chip);\n\t\tif (!ctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(chip->card, ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tj = match_string(known_ctl_names, CONTROL_COUNT, ctl->id.name);\n\t\tif (j >= 0) {\n\t\t\tchip->controls[j] = ctl;\n\t\t\tctl->private_free = oxygen_any_ctl_free;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint oxygen_mixer_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = add_controls(chip, controls, ARRAY_SIZE(controls));\n\tif (err < 0)\n\t\treturn err;\n\tif (chip->model.device_config & PLAYBACK_1_TO_SPDIF) {\n\t\terr = add_controls(chip, spdif_output_controls,\n\t\t\t\t   ARRAY_SIZE(spdif_output_controls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {\n\t\terr = add_controls(chip, spdif_input_controls,\n\t\t\t\t   ARRAY_SIZE(spdif_input_controls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(monitor_controls); ++i) {\n\t\tif (!(chip->model.device_config & monitor_controls[i].pcm_dev))\n\t\t\tcontinue;\n\t\terr = add_controls(chip, monitor_controls[i].controls,\n\t\t\t\t   ARRAY_SIZE(monitor_controls[i].controls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->has_ac97_0) {\n\t\terr = add_controls(chip, ac97_controls,\n\t\t\t\t   ARRAY_SIZE(ac97_controls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->has_ac97_1) {\n\t\terr = add_controls(chip, ac97_fp_controls,\n\t\t\t\t   ARRAY_SIZE(ac97_fp_controls));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn chip->model.mixer_init ? chip->model.mixer_init(chip) : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}