{
  "module_name": "xonar_wm87x6.c",
  "hash_id": "015167b0f83f924513478453419e7a3a15c9177b4893185f926e51685184923a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/oxygen/xonar_wm87x6.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"xonar.h\"\n#include \"wm8776.h\"\n#include \"wm8766.h\"\n\n#define GPIO_DS_HP_DETECT\t0x0010\n#define GPIO_DS_INPUT_ROUTE\t0x0040\n#define GPIO_DS_OUTPUT_FRONTLR\t0x0080\n#define GPIO_DS_OUTPUT_ENABLE\t0x0100\n\n#define GPIO_SLIM_HDMI_DISABLE\t0x0001\n#define GPIO_SLIM_OUTPUT_ENABLE\t0x0002\n#define GPIO_SLIM_FIRMWARE_CLK\t0x0040\n#define GPIO_SLIM_FIRMWARE_DATA\t0x0080\n\n#define I2C_DEVICE_WM8776\t0x34\t \n\n#define LC_CONTROL_LIMITER\t0x40000000\n#define LC_CONTROL_ALC\t\t0x20000000\n\nstruct xonar_wm87x6 {\n\tstruct xonar_generic generic;\n\tu16 wm8776_regs[0x17];\n\tu16 wm8766_regs[0x10];\n\tstruct snd_kcontrol *line_adcmux_control;\n\tstruct snd_kcontrol *mic_adcmux_control;\n\tstruct snd_kcontrol *lc_controls[13];\n\tstruct snd_jack *hp_jack;\n\tstruct xonar_hdmi hdmi;\n};\n\nstatic void wm8776_write_spi(struct oxygen *chip,\n\t\t\t     unsigned int reg, unsigned int value)\n{\n\toxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\n\t\t\t OXYGEN_SPI_DATA_LENGTH_2 |\n\t\t\t OXYGEN_SPI_CLOCK_160 |\n\t\t\t (1 << OXYGEN_SPI_CODEC_SHIFT) |\n\t\t\t OXYGEN_SPI_CEN_LATCH_CLOCK_LO,\n\t\t\t (reg << 9) | value);\n}\n\nstatic void wm8776_write_i2c(struct oxygen *chip,\n\t\t\t     unsigned int reg, unsigned int value)\n{\n\toxygen_write_i2c(chip, I2C_DEVICE_WM8776,\n\t\t\t (reg << 1) | (value >> 8), value);\n}\n\nstatic void wm8776_write(struct oxygen *chip,\n\t\t\t unsigned int reg, unsigned int value)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tif ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==\n\t    OXYGEN_FUNCTION_SPI)\n\t\twm8776_write_spi(chip, reg, value);\n\telse\n\t\twm8776_write_i2c(chip, reg, value);\n\tif (reg < ARRAY_SIZE(data->wm8776_regs)) {\n\t\t \n\t\tif (reg <= WM8776_DACMASTER)\n\t\t\tvalue &= ~WM8776_UPDATE;\n\t\tdata->wm8776_regs[reg] = value;\n\t}\n}\n\nstatic void wm8776_write_cached(struct oxygen *chip,\n\t\t\t\tunsigned int reg, unsigned int value)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tif (reg >= ARRAY_SIZE(data->wm8776_regs) ||\n\t    value != data->wm8776_regs[reg])\n\t\twm8776_write(chip, reg, value);\n}\n\nstatic void wm8766_write(struct oxygen *chip,\n\t\t\t unsigned int reg, unsigned int value)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\toxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\n\t\t\t OXYGEN_SPI_DATA_LENGTH_2 |\n\t\t\t OXYGEN_SPI_CLOCK_160 |\n\t\t\t (0 << OXYGEN_SPI_CODEC_SHIFT) |\n\t\t\t OXYGEN_SPI_CEN_LATCH_CLOCK_LO,\n\t\t\t (reg << 9) | value);\n\tif (reg < ARRAY_SIZE(data->wm8766_regs)) {\n\t\t \n\t\tif (reg <= WM8766_RDA1 ||\n\t\t    (reg >= WM8766_LDA2 && reg <= WM8766_MASTDA))\n\t\t\tvalue &= ~WM8766_UPDATE;\n\t\tdata->wm8766_regs[reg] = value;\n\t}\n}\n\nstatic void wm8766_write_cached(struct oxygen *chip,\n\t\t\t\tunsigned int reg, unsigned int value)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tif (reg >= ARRAY_SIZE(data->wm8766_regs) ||\n\t    value != data->wm8766_regs[reg])\n\t\twm8766_write(chip, reg, value);\n}\n\nstatic void wm8776_registers_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\twm8776_write(chip, WM8776_RESET, 0);\n\twm8776_write(chip, WM8776_PHASESWAP, WM8776_PH_MASK);\n\twm8776_write(chip, WM8776_DACCTRL1, WM8776_DZCEN |\n\t\t     WM8776_PL_LEFT_LEFT | WM8776_PL_RIGHT_RIGHT);\n\twm8776_write(chip, WM8776_DACMUTE, chip->dac_mute ? WM8776_DMUTE : 0);\n\twm8776_write(chip, WM8776_DACIFCTRL,\n\t\t     WM8776_DACFMT_LJUST | WM8776_DACWL_24);\n\twm8776_write(chip, WM8776_ADCIFCTRL,\n\t\t     data->wm8776_regs[WM8776_ADCIFCTRL]);\n\twm8776_write(chip, WM8776_MSTRCTRL, data->wm8776_regs[WM8776_MSTRCTRL]);\n\twm8776_write(chip, WM8776_PWRDOWN, data->wm8776_regs[WM8776_PWRDOWN]);\n\twm8776_write(chip, WM8776_HPLVOL, data->wm8776_regs[WM8776_HPLVOL]);\n\twm8776_write(chip, WM8776_HPRVOL, data->wm8776_regs[WM8776_HPRVOL] |\n\t\t     WM8776_UPDATE);\n\twm8776_write(chip, WM8776_ADCLVOL, data->wm8776_regs[WM8776_ADCLVOL]);\n\twm8776_write(chip, WM8776_ADCRVOL, data->wm8776_regs[WM8776_ADCRVOL]);\n\twm8776_write(chip, WM8776_ADCMUX, data->wm8776_regs[WM8776_ADCMUX]);\n\twm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0]);\n\twm8776_write(chip, WM8776_DACRVOL, chip->dac_volume[1] | WM8776_UPDATE);\n}\n\nstatic void wm8766_registers_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\twm8766_write(chip, WM8766_RESET, 0);\n\twm8766_write(chip, WM8766_DAC_CTRL, data->wm8766_regs[WM8766_DAC_CTRL]);\n\twm8766_write(chip, WM8766_INT_CTRL, WM8766_FMT_LJUST | WM8766_IWL_24);\n\twm8766_write(chip, WM8766_DAC_CTRL2,\n\t\t     WM8766_ZCD | (chip->dac_mute ? WM8766_DMUTE_MASK : 0));\n\twm8766_write(chip, WM8766_LDA1, chip->dac_volume[2]);\n\twm8766_write(chip, WM8766_RDA1, chip->dac_volume[3]);\n\twm8766_write(chip, WM8766_LDA2, chip->dac_volume[4]);\n\twm8766_write(chip, WM8766_RDA2, chip->dac_volume[5]);\n\twm8766_write(chip, WM8766_LDA3, chip->dac_volume[6]);\n\twm8766_write(chip, WM8766_RDA3, chip->dac_volume[7] | WM8766_UPDATE);\n}\n\nstatic void wm8776_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tdata->wm8776_regs[WM8776_HPLVOL] = (0x79 - 60) | WM8776_HPZCEN;\n\tdata->wm8776_regs[WM8776_HPRVOL] = (0x79 - 60) | WM8776_HPZCEN;\n\tdata->wm8776_regs[WM8776_ADCIFCTRL] =\n\t\tWM8776_ADCFMT_LJUST | WM8776_ADCWL_24 | WM8776_ADCMCLK;\n\tdata->wm8776_regs[WM8776_MSTRCTRL] =\n\t\tWM8776_ADCRATE_256 | WM8776_DACRATE_256;\n\tdata->wm8776_regs[WM8776_PWRDOWN] = WM8776_HPPD;\n\tdata->wm8776_regs[WM8776_ADCLVOL] = 0xa5 | WM8776_ZCA;\n\tdata->wm8776_regs[WM8776_ADCRVOL] = 0xa5 | WM8776_ZCA;\n\tdata->wm8776_regs[WM8776_ADCMUX] = 0x001;\n\twm8776_registers_init(chip);\n}\n\nstatic void wm8766_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tdata->wm8766_regs[WM8766_DAC_CTRL] =\n\t\tWM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;\n\twm8766_registers_init(chip);\n}\n\nstatic void xonar_ds_handle_hp_jack(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tbool hp_plugged;\n\tunsigned int reg;\n\n\tmutex_lock(&chip->mutex);\n\n\thp_plugged = !(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\n\t\t       GPIO_DS_HP_DETECT);\n\n\toxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\n\t\t\t      hp_plugged ? 0 : GPIO_DS_OUTPUT_FRONTLR,\n\t\t\t      GPIO_DS_OUTPUT_FRONTLR);\n\n\treg = data->wm8766_regs[WM8766_DAC_CTRL] & ~WM8766_MUTEALL;\n\tif (hp_plugged)\n\t\treg |= WM8766_MUTEALL;\n\twm8766_write_cached(chip, WM8766_DAC_CTRL, reg);\n\n\tsnd_jack_report(data->hp_jack, hp_plugged ? SND_JACK_HEADPHONE : 0);\n\n\tmutex_unlock(&chip->mutex);\n}\n\nstatic void xonar_ds_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tdata->generic.anti_pop_delay = 300;\n\tdata->generic.output_enable_bit = GPIO_DS_OUTPUT_ENABLE;\n\n\twm8776_init(chip);\n\twm8766_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t  GPIO_DS_INPUT_ROUTE | GPIO_DS_OUTPUT_FRONTLR);\n\toxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t    GPIO_DS_HP_DETECT);\n\toxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_DS_INPUT_ROUTE);\n\toxygen_set_bits16(chip, OXYGEN_GPIO_INTERRUPT_MASK, GPIO_DS_HP_DETECT);\n\tchip->interrupt_mask |= OXYGEN_INT_GPIO;\n\n\txonar_enable_output(chip);\n\n\tsnd_jack_new(chip->card, \"Headphone\",\n\t\t     SND_JACK_HEADPHONE, &data->hp_jack, false, false);\n\txonar_ds_handle_hp_jack(chip);\n\n\tsnd_component_add(chip->card, \"WM8776\");\n\tsnd_component_add(chip->card, \"WM8766\");\n}\n\nstatic void xonar_hdav_slim_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tdata->generic.anti_pop_delay = 300;\n\tdata->generic.output_enable_bit = GPIO_SLIM_OUTPUT_ENABLE;\n\n\twm8776_init(chip);\n\n\toxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\n\t\t\t  GPIO_SLIM_HDMI_DISABLE |\n\t\t\t  GPIO_SLIM_FIRMWARE_CLK |\n\t\t\t  GPIO_SLIM_FIRMWARE_DATA);\n\n\txonar_hdmi_init(chip, &data->hdmi);\n\txonar_enable_output(chip);\n\n\tsnd_component_add(chip->card, \"WM8776\");\n}\n\nstatic void xonar_ds_cleanup(struct oxygen *chip)\n{\n\txonar_disable_output(chip);\n\twm8776_write(chip, WM8776_RESET, 0);\n}\n\nstatic void xonar_hdav_slim_cleanup(struct oxygen *chip)\n{\n\txonar_hdmi_cleanup(chip);\n\txonar_disable_output(chip);\n\twm8776_write(chip, WM8776_RESET, 0);\n\tmsleep(2);\n}\n\nstatic void xonar_ds_suspend(struct oxygen *chip)\n{\n\txonar_ds_cleanup(chip);\n}\n\nstatic void xonar_hdav_slim_suspend(struct oxygen *chip)\n{\n\txonar_hdav_slim_cleanup(chip);\n}\n\nstatic void xonar_ds_resume(struct oxygen *chip)\n{\n\twm8776_registers_init(chip);\n\twm8766_registers_init(chip);\n\txonar_enable_output(chip);\n\txonar_ds_handle_hp_jack(chip);\n}\n\nstatic void xonar_hdav_slim_resume(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\twm8776_registers_init(chip);\n\txonar_hdmi_resume(chip, &data->hdmi);\n\txonar_enable_output(chip);\n}\n\nstatic void wm8776_adc_hardware_filter(unsigned int channel,\n\t\t\t\t       struct snd_pcm_hardware *hardware)\n{\n\tif (channel == PCM_A) {\n\t\thardware->rates = SNDRV_PCM_RATE_32000 |\n\t\t\t\t  SNDRV_PCM_RATE_44100 |\n\t\t\t\t  SNDRV_PCM_RATE_48000 |\n\t\t\t\t  SNDRV_PCM_RATE_64000 |\n\t\t\t\t  SNDRV_PCM_RATE_88200 |\n\t\t\t\t  SNDRV_PCM_RATE_96000;\n\t\thardware->rate_max = 96000;\n\t}\n}\n\nstatic void xonar_hdav_slim_hardware_filter(unsigned int channel,\n\t\t\t\t\t    struct snd_pcm_hardware *hardware)\n{\n\twm8776_adc_hardware_filter(channel, hardware);\n\txonar_hdmi_pcm_hardware_filter(channel, hardware);\n}\n\nstatic void set_wm87x6_dac_params(struct oxygen *chip,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n}\n\nstatic void set_wm8776_adc_params(struct oxygen *chip,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tu16 reg;\n\n\treg = WM8776_ADCRATE_256 | WM8776_DACRATE_256;\n\tif (params_rate(params) > 48000)\n\t\treg |= WM8776_ADCOSR;\n\twm8776_write_cached(chip, WM8776_MSTRCTRL, reg);\n}\n\nstatic void set_hdav_slim_dac_params(struct oxygen *chip,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\txonar_set_hdmi_params(chip, &data->hdmi, params);\n}\n\nstatic void update_wm8776_volume(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tu8 to_change;\n\n\tif (chip->dac_volume[0] == chip->dac_volume[1]) {\n\t\tif (chip->dac_volume[0] != data->wm8776_regs[WM8776_DACLVOL] ||\n\t\t    chip->dac_volume[1] != data->wm8776_regs[WM8776_DACRVOL]) {\n\t\t\twm8776_write(chip, WM8776_DACMASTER,\n\t\t\t\t     chip->dac_volume[0] | WM8776_UPDATE);\n\t\t\tdata->wm8776_regs[WM8776_DACLVOL] = chip->dac_volume[0];\n\t\t\tdata->wm8776_regs[WM8776_DACRVOL] = chip->dac_volume[0];\n\t\t}\n\t} else {\n\t\tto_change = (chip->dac_volume[0] !=\n\t\t\t     data->wm8776_regs[WM8776_DACLVOL]) << 0;\n\t\tto_change |= (chip->dac_volume[1] !=\n\t\t\t      data->wm8776_regs[WM8776_DACLVOL]) << 1;\n\t\tif (to_change & 1)\n\t\t\twm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0] |\n\t\t\t\t     ((to_change & 2) ? 0 : WM8776_UPDATE));\n\t\tif (to_change & 2)\n\t\t\twm8776_write(chip, WM8776_DACRVOL,\n\t\t\t\t     chip->dac_volume[1] | WM8776_UPDATE);\n\t}\n}\n\nstatic void update_wm87x6_volume(struct oxygen *chip)\n{\n\tstatic const u8 wm8766_regs[6] = {\n\t\tWM8766_LDA1, WM8766_RDA1,\n\t\tWM8766_LDA2, WM8766_RDA2,\n\t\tWM8766_LDA3, WM8766_RDA3,\n\t};\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int i;\n\tu8 to_change;\n\n\tupdate_wm8776_volume(chip);\n\tif (chip->dac_volume[2] == chip->dac_volume[3] &&\n\t    chip->dac_volume[2] == chip->dac_volume[4] &&\n\t    chip->dac_volume[2] == chip->dac_volume[5] &&\n\t    chip->dac_volume[2] == chip->dac_volume[6] &&\n\t    chip->dac_volume[2] == chip->dac_volume[7]) {\n\t\tto_change = 0;\n\t\tfor (i = 0; i < 6; ++i)\n\t\t\tif (chip->dac_volume[2] !=\n\t\t\t    data->wm8766_regs[wm8766_regs[i]])\n\t\t\t\tto_change = 1;\n\t\tif (to_change) {\n\t\t\twm8766_write(chip, WM8766_MASTDA,\n\t\t\t\t     chip->dac_volume[2] | WM8766_UPDATE);\n\t\t\tfor (i = 0; i < 6; ++i)\n\t\t\t\tdata->wm8766_regs[wm8766_regs[i]] =\n\t\t\t\t\tchip->dac_volume[2];\n\t\t}\n\t} else {\n\t\tto_change = 0;\n\t\tfor (i = 0; i < 6; ++i)\n\t\t\tto_change |= (chip->dac_volume[2 + i] !=\n\t\t\t\t      data->wm8766_regs[wm8766_regs[i]]) << i;\n\t\tfor (i = 0; i < 6; ++i)\n\t\t\tif (to_change & (1 << i))\n\t\t\t\twm8766_write(chip, wm8766_regs[i],\n\t\t\t\t\t     chip->dac_volume[2 + i] |\n\t\t\t\t\t     ((to_change & (0x3e << i))\n\t\t\t\t\t      ? 0 : WM8766_UPDATE));\n\t}\n}\n\nstatic void update_wm8776_mute(struct oxygen *chip)\n{\n\twm8776_write_cached(chip, WM8776_DACMUTE,\n\t\t\t    chip->dac_mute ? WM8776_DMUTE : 0);\n}\n\nstatic void update_wm87x6_mute(struct oxygen *chip)\n{\n\tupdate_wm8776_mute(chip);\n\twm8766_write_cached(chip, WM8766_DAC_CTRL2, WM8766_ZCD |\n\t\t\t    (chip->dac_mute ? WM8766_DMUTE_MASK : 0));\n}\n\nstatic void update_wm8766_center_lfe_mix(struct oxygen *chip, bool mixed)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int reg;\n\n\t \n\treg = data->wm8766_regs[WM8766_DAC_CTRL] &\n\t\t~(WM8766_PL_LEFT_MASK | WM8766_PL_RIGHT_MASK);\n\tif (mixed)\n\t\treg |= WM8766_PL_LEFT_LRMIX | WM8766_PL_RIGHT_LRMIX;\n\telse\n\t\treg |= WM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;\n\twm8766_write_cached(chip, WM8766_DAC_CTRL, reg);\n}\n\nstatic void xonar_ds_gpio_changed(struct oxygen *chip)\n{\n\txonar_ds_handle_hp_jack(chip);\n}\n\nstatic int wm8776_bit_switch_get(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tu16 bit = ctl->private_value & 0xffff;\n\tunsigned int reg_index = (ctl->private_value >> 16) & 0xff;\n\tbool invert = (ctl->private_value >> 24) & 1;\n\n\tvalue->value.integer.value[0] =\n\t\t((data->wm8776_regs[reg_index] & bit) != 0) ^ invert;\n\treturn 0;\n}\n\nstatic int wm8776_bit_switch_put(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tu16 bit = ctl->private_value & 0xffff;\n\tu16 reg_value;\n\tunsigned int reg_index = (ctl->private_value >> 16) & 0xff;\n\tbool invert = (ctl->private_value >> 24) & 1;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\treg_value = data->wm8776_regs[reg_index] & ~bit;\n\tif (value->value.integer.value[0] ^ invert)\n\t\treg_value |= bit;\n\tchanged = reg_value != data->wm8776_regs[reg_index];\n\tif (changed)\n\t\twm8776_write(chip, reg_index, reg_value);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int wm8776_field_enum_info(struct snd_kcontrol *ctl,\n\t\t\t\t  struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const hld[16] = {\n\t\t\"0 ms\", \"2.67 ms\", \"5.33 ms\", \"10.6 ms\",\n\t\t\"21.3 ms\", \"42.7 ms\", \"85.3 ms\", \"171 ms\",\n\t\t\"341 ms\", \"683 ms\", \"1.37 s\", \"2.73 s\",\n\t\t\"5.46 s\", \"10.9 s\", \"21.8 s\", \"43.7 s\",\n\t};\n\tstatic const char *const atk_lim[11] = {\n\t\t\"0.25 ms\", \"0.5 ms\", \"1 ms\", \"2 ms\",\n\t\t\"4 ms\", \"8 ms\", \"16 ms\", \"32 ms\",\n\t\t\"64 ms\", \"128 ms\", \"256 ms\",\n\t};\n\tstatic const char *const atk_alc[11] = {\n\t\t\"8.40 ms\", \"16.8 ms\", \"33.6 ms\", \"67.2 ms\",\n\t\t\"134 ms\", \"269 ms\", \"538 ms\", \"1.08 s\",\n\t\t\"2.15 s\", \"4.3 s\", \"8.6 s\",\n\t};\n\tstatic const char *const dcy_lim[11] = {\n\t\t\"1.2 ms\", \"2.4 ms\", \"4.8 ms\", \"9.6 ms\",\n\t\t\"19.2 ms\", \"38.4 ms\", \"76.8 ms\", \"154 ms\",\n\t\t\"307 ms\", \"614 ms\", \"1.23 s\",\n\t};\n\tstatic const char *const dcy_alc[11] = {\n\t\t\"33.5 ms\", \"67.0 ms\", \"134 ms\", \"268 ms\",\n\t\t\"536 ms\", \"1.07 s\", \"2.14 s\", \"4.29 s\",\n\t\t\"8.58 s\", \"17.2 s\", \"34.3 s\",\n\t};\n\tstatic const char *const tranwin[8] = {\n\t\t\"0 us\", \"62.5 us\", \"125 us\", \"250 us\",\n\t\t\"500 us\", \"1 ms\", \"2 ms\", \"4 ms\",\n\t};\n\tu8 max;\n\tconst char *const *names;\n\n\tmax = (ctl->private_value >> 12) & 0xf;\n\tswitch ((ctl->private_value >> 24) & 0x1f) {\n\tcase WM8776_ALCCTRL2:\n\t\tnames = hld;\n\t\tbreak;\n\tcase WM8776_ALCCTRL3:\n\t\tif (((ctl->private_value >> 20) & 0xf) == 0) {\n\t\t\tif (ctl->private_value & LC_CONTROL_LIMITER)\n\t\t\t\tnames = atk_lim;\n\t\t\telse\n\t\t\t\tnames = atk_alc;\n\t\t} else {\n\t\t\tif (ctl->private_value & LC_CONTROL_LIMITER)\n\t\t\t\tnames = dcy_lim;\n\t\t\telse\n\t\t\t\tnames = dcy_alc;\n\t\t}\n\t\tbreak;\n\tcase WM8776_LIMITER:\n\t\tnames = tranwin;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\treturn snd_ctl_enum_info(info, 1, max + 1, names);\n}\n\nstatic int wm8776_field_volume_info(struct snd_kcontrol *ctl,\n\t\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 1;\n\tinfo->value.integer.min = (ctl->private_value >> 8) & 0xf;\n\tinfo->value.integer.max = (ctl->private_value >> 12) & 0xf;\n\treturn 0;\n}\n\nstatic void wm8776_field_set_from_ctl(struct snd_kcontrol *ctl)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int value, reg_index, mode;\n\tu8 min, max, shift;\n\tu16 mask, reg_value;\n\tbool invert;\n\n\tif ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==\n\t    WM8776_LCSEL_LIMITER)\n\t\tmode = LC_CONTROL_LIMITER;\n\telse\n\t\tmode = LC_CONTROL_ALC;\n\tif (!(ctl->private_value & mode))\n\t\treturn;\n\n\tvalue = ctl->private_value & 0xf;\n\tmin = (ctl->private_value >> 8) & 0xf;\n\tmax = (ctl->private_value >> 12) & 0xf;\n\tmask = (ctl->private_value >> 16) & 0xf;\n\tshift = (ctl->private_value >> 20) & 0xf;\n\treg_index = (ctl->private_value >> 24) & 0x1f;\n\tinvert = (ctl->private_value >> 29) & 0x1;\n\n\tif (invert)\n\t\tvalue = max - (value - min);\n\treg_value = data->wm8776_regs[reg_index];\n\treg_value &= ~(mask << shift);\n\treg_value |= value << shift;\n\twm8776_write_cached(chip, reg_index, reg_value);\n}\n\nstatic int wm8776_field_set(struct snd_kcontrol *ctl, unsigned int value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tu8 min, max;\n\tint changed;\n\n\tmin = (ctl->private_value >> 8) & 0xf;\n\tmax = (ctl->private_value >> 12) & 0xf;\n\tif (value < min || value > max)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mutex);\n\tchanged = value != (ctl->private_value & 0xf);\n\tif (changed) {\n\t\tctl->private_value = (ctl->private_value & ~0xf) | value;\n\t\twm8776_field_set_from_ctl(ctl);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int wm8776_field_enum_get(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_value *value)\n{\n\tvalue->value.enumerated.item[0] = ctl->private_value & 0xf;\n\treturn 0;\n}\n\nstatic int wm8776_field_volume_get(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tvalue->value.integer.value[0] = ctl->private_value & 0xf;\n\treturn 0;\n}\n\nstatic int wm8776_field_enum_put(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_value *value)\n{\n\treturn wm8776_field_set(ctl, value->value.enumerated.item[0]);\n}\n\nstatic int wm8776_field_volume_put(struct snd_kcontrol *ctl,\n\t\t\t\t   struct snd_ctl_elem_value *value)\n{\n\treturn wm8776_field_set(ctl, value->value.integer.value[0]);\n}\n\nstatic int wm8776_hp_vol_info(struct snd_kcontrol *ctl,\n\t\t\t      struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0x79 - 60;\n\tinfo->value.integer.max = 0x7f;\n\treturn 0;\n}\n\nstatic int wm8776_hp_vol_get(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.integer.value[0] =\n\t\tdata->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK;\n\tvalue->value.integer.value[1] =\n\t\tdata->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int wm8776_hp_vol_put(struct snd_kcontrol *ctl,\n\t\t\t     struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tu8 to_update;\n\n\tmutex_lock(&chip->mutex);\n\tto_update = (value->value.integer.value[0] !=\n\t\t     (data->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK))\n\t\t<< 0;\n\tto_update |= (value->value.integer.value[1] !=\n\t\t      (data->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK))\n\t\t<< 1;\n\tif (value->value.integer.value[0] == value->value.integer.value[1]) {\n\t\tif (to_update) {\n\t\t\twm8776_write(chip, WM8776_HPMASTER,\n\t\t\t\t     value->value.integer.value[0] |\n\t\t\t\t     WM8776_HPZCEN | WM8776_UPDATE);\n\t\t\tdata->wm8776_regs[WM8776_HPLVOL] =\n\t\t\t\tvalue->value.integer.value[0] | WM8776_HPZCEN;\n\t\t\tdata->wm8776_regs[WM8776_HPRVOL] =\n\t\t\t\tvalue->value.integer.value[0] | WM8776_HPZCEN;\n\t\t}\n\t} else {\n\t\tif (to_update & 1)\n\t\t\twm8776_write(chip, WM8776_HPLVOL,\n\t\t\t\t     value->value.integer.value[0] |\n\t\t\t\t     WM8776_HPZCEN |\n\t\t\t\t     ((to_update & 2) ? 0 : WM8776_UPDATE));\n\t\tif (to_update & 2)\n\t\t\twm8776_write(chip, WM8776_HPRVOL,\n\t\t\t\t     value->value.integer.value[1] |\n\t\t\t\t     WM8776_HPZCEN | WM8776_UPDATE);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn to_update != 0;\n}\n\nstatic int wm8776_input_mux_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int mux_bit = ctl->private_value;\n\n\tvalue->value.integer.value[0] =\n\t\t!!(data->wm8776_regs[WM8776_ADCMUX] & mux_bit);\n\treturn 0;\n}\n\nstatic int wm8776_input_mux_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tstruct snd_kcontrol *other_ctl;\n\tunsigned int mux_bit = ctl->private_value;\n\tu16 reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->wm8776_regs[WM8776_ADCMUX];\n\tif (value->value.integer.value[0]) {\n\t\treg |= mux_bit;\n\t\t \n\t\tmux_bit ^= 3;\n\t\tif (reg & mux_bit) {\n\t\t\treg &= ~mux_bit;\n\t\t\tif (mux_bit == 1)\n\t\t\t\tother_ctl = data->line_adcmux_control;\n\t\t\telse\n\t\t\t\tother_ctl = data->mic_adcmux_control;\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &other_ctl->id);\n\t\t}\n\t} else\n\t\treg &= ~mux_bit;\n\tchanged = reg != data->wm8776_regs[WM8776_ADCMUX];\n\tif (changed) {\n\t\toxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\n\t\t\t\t      reg & 1 ? GPIO_DS_INPUT_ROUTE : 0,\n\t\t\t\t      GPIO_DS_INPUT_ROUTE);\n\t\twm8776_write(chip, WM8776_ADCMUX, reg);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int wm8776_input_vol_info(struct snd_kcontrol *ctl,\n\t\t\t\t struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 2;\n\tinfo->value.integer.min = 0xa5;\n\tinfo->value.integer.max = 0xff;\n\treturn 0;\n}\n\nstatic int wm8776_input_vol_get(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tmutex_lock(&chip->mutex);\n\tvalue->value.integer.value[0] =\n\t\tdata->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK;\n\tvalue->value.integer.value[1] =\n\t\tdata->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK;\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int wm8776_input_vol_put(struct snd_kcontrol *ctl,\n\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tint changed = 0;\n\n\tmutex_lock(&chip->mutex);\n\tchanged = (value->value.integer.value[0] !=\n\t\t   (data->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK)) ||\n\t\t  (value->value.integer.value[1] !=\n\t\t   (data->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK));\n\twm8776_write_cached(chip, WM8776_ADCLVOL,\n\t\t\t    value->value.integer.value[0] | WM8776_ZCA);\n\twm8776_write_cached(chip, WM8776_ADCRVOL,\n\t\t\t    value->value.integer.value[1] | WM8776_ZCA);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int wm8776_level_control_info(struct snd_kcontrol *ctl,\n\t\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[3] = {\n\t\t\"None\", \"Peak Limiter\", \"Automatic Level Control\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 3, names);\n}\n\nstatic int wm8776_level_control_get(struct snd_kcontrol *ctl,\n\t\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tif (!(data->wm8776_regs[WM8776_ALCCTRL2] & WM8776_LCEN))\n\t\tvalue->value.enumerated.item[0] = 0;\n\telse if ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==\n\t\t WM8776_LCSEL_LIMITER)\n\t\tvalue->value.enumerated.item[0] = 1;\n\telse\n\t\tvalue->value.enumerated.item[0] = 2;\n\treturn 0;\n}\n\nstatic void activate_control(struct oxygen *chip,\n\t\t\t     struct snd_kcontrol *ctl, unsigned int mode)\n{\n\tunsigned int access;\n\n\tif (ctl->private_value & mode)\n\t\taccess = 0;\n\telse\n\t\taccess = SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tif ((ctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) != access) {\n\t\tctl->vd[0].access ^= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\n\t}\n}\n\nstatic int wm8776_level_control_put(struct snd_kcontrol *ctl,\n\t\t\t\t    struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int mode = 0, i;\n\tu16 ctrl1, ctrl2;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] >= 3)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mutex);\n\tchanged = value->value.enumerated.item[0] != ctl->private_value;\n\tif (changed) {\n\t\tctl->private_value = value->value.enumerated.item[0];\n\t\tctrl1 = data->wm8776_regs[WM8776_ALCCTRL1];\n\t\tctrl2 = data->wm8776_regs[WM8776_ALCCTRL2];\n\t\tswitch (value->value.enumerated.item[0]) {\n\t\tdefault:\n\t\t\twm8776_write_cached(chip, WM8776_ALCCTRL2,\n\t\t\t\t\t    ctrl2 & ~WM8776_LCEN);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\twm8776_write_cached(chip, WM8776_ALCCTRL1,\n\t\t\t\t\t    (ctrl1 & ~WM8776_LCSEL_MASK) |\n\t\t\t\t\t    WM8776_LCSEL_LIMITER);\n\t\t\twm8776_write_cached(chip, WM8776_ALCCTRL2,\n\t\t\t\t\t    ctrl2 | WM8776_LCEN);\n\t\t\tmode = LC_CONTROL_LIMITER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\twm8776_write_cached(chip, WM8776_ALCCTRL1,\n\t\t\t\t\t    (ctrl1 & ~WM8776_LCSEL_MASK) |\n\t\t\t\t\t    WM8776_LCSEL_ALC_STEREO);\n\t\t\twm8776_write_cached(chip, WM8776_ALCCTRL2,\n\t\t\t\t\t    ctrl2 | WM8776_LCEN);\n\t\t\tmode = LC_CONTROL_ALC;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(data->lc_controls); ++i)\n\t\t\tactivate_control(chip, data->lc_controls[i], mode);\n\t}\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[2] = {\n\t\t\"None\", \"High-pass Filter\"\n\t};\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\n\tvalue->value.enumerated.item[0] =\n\t\t!(data->wm8776_regs[WM8776_ADCIFCTRL] & WM8776_ADCHPD);\n\treturn 0;\n}\n\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\n{\n\tstruct oxygen *chip = ctl->private_data;\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int reg;\n\tint changed;\n\n\tmutex_lock(&chip->mutex);\n\treg = data->wm8776_regs[WM8776_ADCIFCTRL] & ~WM8776_ADCHPD;\n\tif (!value->value.enumerated.item[0])\n\t\treg |= WM8776_ADCHPD;\n\tchanged = reg != data->wm8776_regs[WM8776_ADCIFCTRL];\n\tif (changed)\n\t\twm8776_write(chip, WM8776_ADCIFCTRL, reg);\n\tmutex_unlock(&chip->mutex);\n\treturn changed;\n}\n\n#define WM8776_BIT_SWITCH(xname, reg, bit, invert, flags) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.info = snd_ctl_boolean_mono_info, \\\n\t.get = wm8776_bit_switch_get, \\\n\t.put = wm8776_bit_switch_put, \\\n\t.private_value = ((reg) << 16) | (bit) | ((invert) << 24) | (flags), \\\n}\n#define _WM8776_FIELD_CTL(xname, reg, shift, initval, min, max, mask, flags) \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = (initval) | ((min) << 8) | ((max) << 12) | \\\n\t((mask) << 16) | ((shift) << 20) | ((reg) << 24) | (flags)\n#define WM8776_FIELD_CTL_ENUM(xname, reg, shift, init, min, max, mask, flags) {\\\n\t_WM8776_FIELD_CTL(xname \" Capture Enum\", \\\n\t\t\t  reg, shift, init, min, max, mask, flags), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_INACTIVE, \\\n\t.info = wm8776_field_enum_info, \\\n\t.get = wm8776_field_enum_get, \\\n\t.put = wm8776_field_enum_put, \\\n}\n#define WM8776_FIELD_CTL_VOLUME(a, b, c, d, e, f, g, h, tlv_p) { \\\n\t_WM8776_FIELD_CTL(a \" Capture Volume\", b, c, d, e, f, g, h), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_INACTIVE | \\\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n\t.info = wm8776_field_volume_info, \\\n\t.get = wm8776_field_volume_get, \\\n\t.put = wm8776_field_volume_put, \\\n\t.tlv = { .p = tlv_p }, \\\n}\n\nstatic const DECLARE_TLV_DB_SCALE(wm87x6_dac_db_scale, -6000, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_adc_db_scale, -2100, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_hp_db_scale, -6000, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_lct_db_scale, -1600, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxgain_db_scale, 0, 400, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_ngth_db_scale, -7800, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxatten_lim_db_scale, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(wm8776_maxatten_alc_db_scale, -2100, 400, 0);\n\nstatic const struct snd_kcontrol_new ds_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphone Playback Volume\",\n\t\t.info = wm8776_hp_vol_info,\n\t\t.get = wm8776_hp_vol_get,\n\t\t.put = wm8776_hp_vol_put,\n\t\t.tlv = { .p = wm8776_hp_db_scale },\n\t},\n\tWM8776_BIT_SWITCH(\"Headphone Playback Switch\",\n\t\t\t  WM8776_PWRDOWN, WM8776_HPPD, 1, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input Capture Volume\",\n\t\t.info = wm8776_input_vol_info,\n\t\t.get = wm8776_input_vol_get,\n\t\t.put = wm8776_input_vol_put,\n\t\t.tlv = { .p = wm8776_adc_db_scale },\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Line Capture Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = wm8776_input_mux_get,\n\t\t.put = wm8776_input_mux_put,\n\t\t.private_value = 1 << 0,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Mic Capture Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = wm8776_input_mux_get,\n\t\t.put = wm8776_input_mux_put,\n\t\t.private_value = 1 << 1,\n\t},\n\tWM8776_BIT_SWITCH(\"Front Mic Capture Switch\",\n\t\t\t  WM8776_ADCMUX, 1 << 2, 0, 0),\n\tWM8776_BIT_SWITCH(\"Aux Capture Switch\",\n\t\t\t  WM8776_ADCMUX, 1 << 3, 0, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC Filter Capture Enum\",\n\t\t.info = hpf_info,\n\t\t.get = hpf_get,\n\t\t.put = hpf_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Level Control Capture Enum\",\n\t\t.info = wm8776_level_control_info,\n\t\t.get = wm8776_level_control_get,\n\t\t.put = wm8776_level_control_put,\n\t\t.private_value = 0,\n\t},\n};\nstatic const struct snd_kcontrol_new hdav_slim_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"HDMI Playback Switch\",\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = xonar_gpio_bit_switch_get,\n\t\t.put = xonar_gpio_bit_switch_put,\n\t\t.private_value = GPIO_SLIM_HDMI_DISABLE | XONAR_GPIO_BIT_INVERT,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Headphone Playback Volume\",\n\t\t.info = wm8776_hp_vol_info,\n\t\t.get = wm8776_hp_vol_get,\n\t\t.put = wm8776_hp_vol_put,\n\t\t.tlv = { .p = wm8776_hp_db_scale },\n\t},\n\tWM8776_BIT_SWITCH(\"Headphone Playback Switch\",\n\t\t\t  WM8776_PWRDOWN, WM8776_HPPD, 1, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input Capture Volume\",\n\t\t.info = wm8776_input_vol_info,\n\t\t.get = wm8776_input_vol_get,\n\t\t.put = wm8776_input_vol_put,\n\t\t.tlv = { .p = wm8776_adc_db_scale },\n\t},\n\tWM8776_BIT_SWITCH(\"Mic Capture Switch\",\n\t\t\t  WM8776_ADCMUX, 1 << 0, 0, 0),\n\tWM8776_BIT_SWITCH(\"Aux Capture Switch\",\n\t\t\t  WM8776_ADCMUX, 1 << 1, 0, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"ADC Filter Capture Enum\",\n\t\t.info = hpf_info,\n\t\t.get = hpf_get,\n\t\t.put = hpf_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Level Control Capture Enum\",\n\t\t.info = wm8776_level_control_info,\n\t\t.get = wm8776_level_control_get,\n\t\t.put = wm8776_level_control_put,\n\t\t.private_value = 0,\n\t},\n};\nstatic const struct snd_kcontrol_new lc_controls[] = {\n\tWM8776_FIELD_CTL_VOLUME(\"Limiter Threshold\",\n\t\t\t\tWM8776_ALCCTRL1, 0, 11, 0, 15, 0xf,\n\t\t\t\tLC_CONTROL_LIMITER, wm8776_lct_db_scale),\n\tWM8776_FIELD_CTL_ENUM(\"Limiter Attack Time\",\n\t\t\t      WM8776_ALCCTRL3, 0, 2, 0, 10, 0xf,\n\t\t\t      LC_CONTROL_LIMITER),\n\tWM8776_FIELD_CTL_ENUM(\"Limiter Decay Time\",\n\t\t\t      WM8776_ALCCTRL3, 4, 3, 0, 10, 0xf,\n\t\t\t      LC_CONTROL_LIMITER),\n\tWM8776_FIELD_CTL_ENUM(\"Limiter Transient Window\",\n\t\t\t      WM8776_LIMITER, 4, 2, 0, 7, 0x7,\n\t\t\t      LC_CONTROL_LIMITER),\n\tWM8776_FIELD_CTL_VOLUME(\"Limiter Maximum Attenuation\",\n\t\t\t\tWM8776_LIMITER, 0, 6, 3, 12, 0xf,\n\t\t\t\tLC_CONTROL_LIMITER,\n\t\t\t\twm8776_maxatten_lim_db_scale),\n\tWM8776_FIELD_CTL_VOLUME(\"ALC Target Level\",\n\t\t\t\tWM8776_ALCCTRL1, 0, 11, 0, 15, 0xf,\n\t\t\t\tLC_CONTROL_ALC, wm8776_lct_db_scale),\n\tWM8776_FIELD_CTL_ENUM(\"ALC Attack Time\",\n\t\t\t      WM8776_ALCCTRL3, 0, 2, 0, 10, 0xf,\n\t\t\t      LC_CONTROL_ALC),\n\tWM8776_FIELD_CTL_ENUM(\"ALC Decay Time\",\n\t\t\t      WM8776_ALCCTRL3, 4, 3, 0, 10, 0xf,\n\t\t\t      LC_CONTROL_ALC),\n\tWM8776_FIELD_CTL_VOLUME(\"ALC Maximum Gain\",\n\t\t\t\tWM8776_ALCCTRL1, 4, 7, 1, 7, 0x7,\n\t\t\t\tLC_CONTROL_ALC, wm8776_maxgain_db_scale),\n\tWM8776_FIELD_CTL_VOLUME(\"ALC Maximum Attenuation\",\n\t\t\t\tWM8776_LIMITER, 0, 10, 10, 15, 0xf,\n\t\t\t\tLC_CONTROL_ALC, wm8776_maxatten_alc_db_scale),\n\tWM8776_FIELD_CTL_ENUM(\"ALC Hold Time\",\n\t\t\t      WM8776_ALCCTRL2, 0, 0, 0, 15, 0xf,\n\t\t\t      LC_CONTROL_ALC),\n\tWM8776_BIT_SWITCH(\"Noise Gate Capture Switch\",\n\t\t\t  WM8776_NOISEGATE, WM8776_NGAT, 0,\n\t\t\t  LC_CONTROL_ALC),\n\tWM8776_FIELD_CTL_VOLUME(\"Noise Gate Threshold\",\n\t\t\t\tWM8776_NOISEGATE, 2, 0, 0, 7, 0x7,\n\t\t\t\tLC_CONTROL_ALC, wm8776_ngth_db_scale),\n};\n\nstatic int add_lc_controls(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int i;\n\tstruct snd_kcontrol *ctl;\n\tint err;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));\n\tfor (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {\n\t\tctl = snd_ctl_new1(&lc_controls[i], chip);\n\t\tif (!ctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(chip->card, ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata->lc_controls[i] = ctl;\n\t}\n\treturn 0;\n}\n\nstatic int xonar_ds_mixer_init(struct oxygen *chip)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int i;\n\tstruct snd_kcontrol *ctl;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ds_controls); ++i) {\n\t\tctl = snd_ctl_new1(&ds_controls[i], chip);\n\t\tif (!ctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(chip->card, ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!strcmp(ctl->id.name, \"Line Capture Switch\"))\n\t\t\tdata->line_adcmux_control = ctl;\n\t\telse if (!strcmp(ctl->id.name, \"Mic Capture Switch\"))\n\t\t\tdata->mic_adcmux_control = ctl;\n\t}\n\tif (!data->line_adcmux_control || !data->mic_adcmux_control)\n\t\treturn -ENXIO;\n\n\treturn add_lc_controls(chip);\n}\n\nstatic int xonar_hdav_slim_mixer_init(struct oxygen *chip)\n{\n\tunsigned int i;\n\tstruct snd_kcontrol *ctl;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdav_slim_controls); ++i) {\n\t\tctl = snd_ctl_new1(&hdav_slim_controls[i], chip);\n\t\tif (!ctl)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(chip->card, ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn add_lc_controls(chip);\n}\n\nstatic void dump_wm8776_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int i;\n\n\tsnd_iprintf(buffer, \"\\nWM8776:\\n00:\");\n\tfor (i = 0; i < 0x10; ++i)\n\t\tsnd_iprintf(buffer, \" %03x\", data->wm8776_regs[i]);\n\tsnd_iprintf(buffer, \"\\n10:\");\n\tfor (i = 0x10; i < 0x17; ++i)\n\t\tsnd_iprintf(buffer, \" %03x\", data->wm8776_regs[i]);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void dump_wm87x6_registers(struct oxygen *chip,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct xonar_wm87x6 *data = chip->model_data;\n\tunsigned int i;\n\n\tdump_wm8776_registers(chip, buffer);\n\tsnd_iprintf(buffer, \"\\nWM8766:\\n00:\");\n\tfor (i = 0; i < 0x10; ++i)\n\t\tsnd_iprintf(buffer, \" %03x\", data->wm8766_regs[i]);\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic const struct oxygen_model model_xonar_ds = {\n\t.longname = \"Asus Virtuoso 66\",\n\t.chip = \"AV200\",\n\t.init = xonar_ds_init,\n\t.mixer_init = xonar_ds_mixer_init,\n\t.cleanup = xonar_ds_cleanup,\n\t.suspend = xonar_ds_suspend,\n\t.resume = xonar_ds_resume,\n\t.pcm_hardware_filter = wm8776_adc_hardware_filter,\n\t.set_dac_params = set_wm87x6_dac_params,\n\t.set_adc_params = set_wm8776_adc_params,\n\t.update_dac_volume = update_wm87x6_volume,\n\t.update_dac_mute = update_wm87x6_mute,\n\t.update_center_lfe_mix = update_wm8766_center_lfe_mix,\n\t.gpio_changed = xonar_ds_gpio_changed,\n\t.dump_registers = dump_wm87x6_registers,\n\t.dac_tlv = wm87x6_dac_db_scale,\n\t.model_data_size = sizeof(struct xonar_wm87x6),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_1 |\n\t\t\t CAPTURE_1_FROM_SPDIF,\n\t.dac_channels_pcm = 8,\n\t.dac_channels_mixer = 8,\n\t.dac_volume_min = 255 - 2*60,\n\t.dac_volume_max = 255,\n\t.function_flags = OXYGEN_FUNCTION_SPI,\n\t.dac_mclks = OXYGEN_MCLKS(256, 256, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 256, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nstatic const struct oxygen_model model_xonar_hdav_slim = {\n\t.shortname = \"Xonar HDAV1.3 Slim\",\n\t.longname = \"Asus Virtuoso 200\",\n\t.chip = \"AV200\",\n\t.init = xonar_hdav_slim_init,\n\t.mixer_init = xonar_hdav_slim_mixer_init,\n\t.cleanup = xonar_hdav_slim_cleanup,\n\t.suspend = xonar_hdav_slim_suspend,\n\t.resume = xonar_hdav_slim_resume,\n\t.pcm_hardware_filter = xonar_hdav_slim_hardware_filter,\n\t.set_dac_params = set_hdav_slim_dac_params,\n\t.set_adc_params = set_wm8776_adc_params,\n\t.update_dac_volume = update_wm8776_volume,\n\t.update_dac_mute = update_wm8776_mute,\n\t.uart_input = xonar_hdmi_uart_input,\n\t.dump_registers = dump_wm8776_registers,\n\t.dac_tlv = wm87x6_dac_db_scale,\n\t.model_data_size = sizeof(struct xonar_wm87x6),\n\t.device_config = PLAYBACK_0_TO_I2S |\n\t\t\t PLAYBACK_1_TO_SPDIF |\n\t\t\t CAPTURE_0_FROM_I2S_1 |\n\t\t\t CAPTURE_1_FROM_SPDIF,\n\t.dac_channels_pcm = 8,\n\t.dac_channels_mixer = 2,\n\t.dac_volume_min = 255 - 2*60,\n\t.dac_volume_max = 255,\n\t.function_flags = OXYGEN_FUNCTION_2WIRE,\n\t.dac_mclks = OXYGEN_MCLKS(256, 256, 128),\n\t.adc_mclks = OXYGEN_MCLKS(256, 256, 128),\n\t.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n\t.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,\n};\n\nint get_xonar_wm87x6_model(struct oxygen *chip,\n\t\t\t   const struct pci_device_id *id)\n{\n\tswitch (id->subdevice) {\n\tcase 0x838e:\n\t\tchip->model = model_xonar_ds;\n\t\tchip->model.shortname = \"Xonar DS\";\n\t\tbreak;\n\tcase 0x8522:\n\t\tchip->model = model_xonar_ds;\n\t\tchip->model.shortname = \"Xonar DSX\";\n\t\tbreak;\n\tcase 0x835e:\n\t\tchip->model = model_xonar_hdav_slim;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}