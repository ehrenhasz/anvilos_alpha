{
  "module_name": "vx222.c",
  "hash_id": "53407e791bb828e338bd16ccedddd2cd1c33a42a255522bb51d68012271bbcb2",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/vx222/vx222.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include \"vx222.h\"\n\n#define CARD_NAME \"VX222\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"Digigram VX222 V2/Mic\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic bool mic[SNDRV_CARDS];  \nstatic int ibl[SNDRV_CARDS];  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Digigram \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Digigram \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Digigram \" CARD_NAME \" soundcard.\");\nmodule_param_array(mic, bool, NULL, 0444);\nMODULE_PARM_DESC(mic, \"Enable Microphone.\");\nmodule_param_array(ibl, int, NULL, 0444);\nMODULE_PARM_DESC(ibl, \"Capture IBL size.\");\n\n \n\nenum {\n\tVX_PCI_VX222_OLD,\n\tVX_PCI_VX222_NEW\n};\n\nstatic const struct pci_device_id snd_vx222_ids[] = {\n\t{ 0x10b5, 0x9050, 0x1369, PCI_ANY_ID, 0, 0, VX_PCI_VX222_OLD, },    \n\t{ 0x10b5, 0x9030, 0x1369, PCI_ANY_ID, 0, 0, VX_PCI_VX222_NEW, },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_vx222_ids);\n\n\n \n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_old_vol, -11350, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_akm, -7350, 50, 0);\n\nstatic const struct snd_vx_hardware vx222_old_hw = {\n\n\t.name = \"VX222/Old\",\n\t.type = VX_TYPE_BOARD,\n\t \n\t.num_codecs = 1,\n\t.num_ins = 1,\n\t.num_outs = 1,\n\t.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,\n\t.output_level_db_scale = db_scale_old_vol,\n};\n\nstatic const struct snd_vx_hardware vx222_v2_hw = {\n\n\t.name = \"VX222/v2\",\n\t.type = VX_TYPE_V2,\n\t \n\t.num_codecs = 1,\n\t.num_ins = 1,\n\t.num_outs = 1,\n\t.output_level_max = VX2_AKM_LEVEL_MAX,\n\t.output_level_db_scale = db_scale_akm,\n};\n\nstatic const struct snd_vx_hardware vx222_mic_hw = {\n\n\t.name = \"VX222/Mic\",\n\t.type = VX_TYPE_MIC,\n\t \n\t.num_codecs = 1,\n\t.num_ins = 1,\n\t.num_outs = 1,\n\t.output_level_max = VX2_AKM_LEVEL_MAX,\n\t.output_level_db_scale = db_scale_akm,\n};\n\n\n \nstatic int snd_vx222_create(struct snd_card *card, struct pci_dev *pci,\n\t\t\t    const struct snd_vx_hardware *hw,\n\t\t\t    struct snd_vx222 **rchip)\n{\n\tstruct vx_core *chip;\n\tstruct snd_vx222 *vx;\n\tint i, err;\n\tconst struct snd_vx_ops *vx_ops;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_master(pci);\n\n\tvx_ops = hw->type == VX_TYPE_BOARD ? &vx222_old_ops : &vx222_ops;\n\tchip = snd_vx_create(card, hw, vx_ops,\n\t\t\t     sizeof(struct snd_vx222) - sizeof(struct vx_core));\n\tif (!chip)\n\t\treturn -ENOMEM;\n\tvx = to_vx222(chip);\n\tvx->pci = pci;\n\n\terr = pci_request_regions(pci, CARD_NAME);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < 2; i++)\n\t\tvx->port[i] = pci_resource_start(pci, i + 1);\n\n\tif (devm_request_threaded_irq(&pci->dev, pci->irq, snd_vx_irq_handler,\n\t\t\t\t      snd_vx_threaded_irq_handler, IRQF_SHARED,\n\t\t\t\t      KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\t*rchip = vx;\n\n\treturn 0;\n}\n\n\nstatic int snd_vx222_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tconst struct snd_vx_hardware *hw;\n\tstruct snd_vx222 *vx;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\t0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch ((int)pci_id->driver_data) {\n\tcase VX_PCI_VX222_OLD:\n\t\thw = &vx222_old_hw;\n\t\tbreak;\n\tcase VX_PCI_VX222_NEW:\n\tdefault:\n\t\tif (mic[dev])\n\t\t\thw = &vx222_mic_hw;\n\t\telse\n\t\t\thw = &vx222_v2_hw;\n\t\tbreak;\n\t}\n\terr = snd_vx222_create(card, pci, hw, &vx);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_data = vx;\n\tvx->core.ibl.size = ibl[dev];\n\n\tsprintf(card->longname, \"%s at 0x%lx & 0x%lx, irq %i\",\n\t\tcard->shortname, vx->port[0], vx->port[1], vx->core.irq);\n\tdev_dbg(card->dev, \"%s at 0x%lx & 0x%lx, irq %i\\n\",\n\t\t    card->shortname, vx->port[0], vx->port[1], vx->core.irq);\n\n#ifdef SND_VX_FW_LOADER\n\tvx->core.dev = &pci->dev;\n#endif\n\n\terr = snd_vx_setup_firmware(&vx->core);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_vx222_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_vx222 *vx = card->private_data;\n\n\treturn snd_vx_suspend(&vx->core);\n}\n\nstatic int snd_vx222_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_vx222 *vx = card->private_data;\n\n\treturn snd_vx_resume(&vx->core);\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_vx222_pm, snd_vx222_suspend, snd_vx222_resume);\n#define SND_VX222_PM_OPS\t&snd_vx222_pm\n#else\n#define SND_VX222_PM_OPS\tNULL\n#endif\n\nstatic struct pci_driver vx222_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_vx222_ids,\n\t.probe = snd_vx222_probe,\n\t.driver = {\n\t\t.pm = SND_VX222_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(vx222_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}