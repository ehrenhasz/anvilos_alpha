{
  "module_name": "vx222_ops.c",
  "hash_id": "524108820c68ed1e9bb358102f452857a98f9c9c98dcd7f249566a5eb3c4eec0",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/vx222/vx222_ops.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include \"vx222.h\"\n\n\nstatic const int vx2_reg_offset[VX_REG_MAX] = {\n\t[VX_ICR]    = 0x00,\n\t[VX_CVR]    = 0x04,\n\t[VX_ISR]    = 0x08,\n\t[VX_IVR]    = 0x0c,\n\t[VX_RXH]    = 0x14,\n\t[VX_RXM]    = 0x18,\n\t[VX_RXL]    = 0x1c,\n\t[VX_DMA]    = 0x10,\n\t[VX_CDSP]   = 0x20,\n\t[VX_CFG]    = 0x24,\n\t[VX_RUER]   = 0x28,\n\t[VX_DATA]   = 0x2c,\n\t[VX_STATUS] = 0x30,\n\t[VX_LOFREQ] = 0x34,\n\t[VX_HIFREQ] = 0x38,\n\t[VX_CSUER]  = 0x3c,\n\t[VX_SELMIC] = 0x40,\n\t[VX_COMPOT] = 0x44, \n\t[VX_SCOMPR] = 0x48, \n\t[VX_GLIMIT] = 0x4c, \n\t[VX_INTCSR] = 0x4c, \n\t[VX_CNTRL]  = 0x50,\t\t\n\t[VX_GPIOC]  = 0x54,\t\t\n};\n\nstatic const int vx2_reg_index[VX_REG_MAX] = {\n\t[VX_ICR]\t= 1,\n\t[VX_CVR]\t= 1,\n\t[VX_ISR]\t= 1,\n\t[VX_IVR]\t= 1,\n\t[VX_RXH]\t= 1,\n\t[VX_RXM]\t= 1,\n\t[VX_RXL]\t= 1,\n\t[VX_DMA]\t= 1,\n\t[VX_CDSP]\t= 1,\n\t[VX_CFG]\t= 1,\n\t[VX_RUER]\t= 1,\n\t[VX_DATA]\t= 1,\n\t[VX_STATUS]\t= 1,\n\t[VX_LOFREQ]\t= 1,\n\t[VX_HIFREQ]\t= 1,\n\t[VX_CSUER]\t= 1,\n\t[VX_SELMIC]\t= 1,\n\t[VX_COMPOT]\t= 1,\n\t[VX_SCOMPR]\t= 1,\n\t[VX_GLIMIT]\t= 1,\n\t[VX_INTCSR]\t= 0,\t \n\t[VX_CNTRL]\t= 0,\t \n\t[VX_GPIOC]\t= 0,\t \n};\n\nstatic inline unsigned long vx2_reg_addr(struct vx_core *_chip, int reg)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\treturn chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];\n}\n\n \nstatic unsigned char vx2_inb(struct vx_core *chip, int offset)\n{\n\treturn inb(vx2_reg_addr(chip, offset));\n}\n\n \nstatic void vx2_outb(struct vx_core *chip, int offset, unsigned char val)\n{\n\toutb(val, vx2_reg_addr(chip, offset));\n\t \n}\n\n \nstatic unsigned int vx2_inl(struct vx_core *chip, int offset)\n{\n\treturn inl(vx2_reg_addr(chip, offset));\n}\n\n \nstatic void vx2_outl(struct vx_core *chip, int offset, unsigned int val)\n{\n\t \n\toutl(val, vx2_reg_addr(chip, offset));\n}\n\n \n#undef vx_inb\n#define vx_inb(chip,reg)\tvx2_inb((struct vx_core*)(chip), VX_##reg)\n#undef vx_outb\n#define vx_outb(chip,reg,val)\tvx2_outb((struct vx_core*)(chip), VX_##reg, val)\n#undef vx_inl\n#define vx_inl(chip,reg)\tvx2_inl((struct vx_core*)(chip), VX_##reg)\n#undef vx_outl\n#define vx_outl(chip,reg,val)\tvx2_outl((struct vx_core*)(chip), VX_##reg, val)\n\n\n \n\n#define XX_DSP_RESET_WAIT_TIME\t\t2\t \n\nstatic void vx2_reset_dsp(struct vx_core *_chip)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\t \n\tvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);\n\n\tmdelay(XX_DSP_RESET_WAIT_TIME);\n\n\tchip->regCDSP |= VX_CDSP_DSP_RESET_MASK;\n\t \n\tvx_outl(chip, CDSP, chip->regCDSP);\n}\n\n\nstatic int vx2_test_xilinx(struct vx_core *_chip)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tunsigned int data;\n\n\tdev_dbg(_chip->card->dev, \"testing xilinx...\\n\");\n\t \n\n\t \n\tvx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST0_MASK);\n\tvx_inl(chip, ISR);\n\tdata = vx_inl(chip, STATUS);\n\tif ((data & VX_STATUS_VAL_TEST0_MASK) == VX_STATUS_VAL_TEST0_MASK) {\n\t\tdev_dbg(_chip->card->dev, \"bad!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST0_MASK);\n\tvx_inl(chip, ISR);\n\tdata = vx_inl(chip, STATUS);\n\tif (! (data & VX_STATUS_VAL_TEST0_MASK)) {\n\t\tdev_dbg(_chip->card->dev, \"bad! #2\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (_chip->type == VX_TYPE_BOARD) {\n\t\t \n\t\t \n\t\tvx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST1_MASK);\n\t\tvx_inl(chip, ISR);\n\t\tdata = vx_inl(chip, STATUS);\n\t\tif ((data & VX_STATUS_VAL_TEST1_MASK) == VX_STATUS_VAL_TEST1_MASK) {\n\t\t\tdev_dbg(_chip->card->dev, \"bad! #3\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST1_MASK);\n\t\tvx_inl(chip, ISR);\n\t\tdata = vx_inl(chip, STATUS);\n\t\tif (! (data & VX_STATUS_VAL_TEST1_MASK)) {\n\t\t\tdev_dbg(_chip->card->dev, \"bad! #4\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tdev_dbg(_chip->card->dev, \"ok, xilinx fine.\\n\");\n\treturn 0;\n}\n\n\n \nstatic void vx2_setup_pseudo_dma(struct vx_core *chip, int do_write)\n{\n\t \n\tvx_outl(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);\n\n\t \n\tvx_outl(chip, RESET_DMA, 0);\n}\n\n \nstatic inline void vx2_release_pseudo_dma(struct vx_core *chip)\n{\n\t \n\tvx_outl(chip, ICR, 0);\n}\n\n\n\n \nstatic void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,\n\t\t\t  struct vx_pipe *pipe, int count)\n{\n\tunsigned long port = vx2_reg_addr(chip, VX_DMA);\n\tint offset = pipe->hw_ptr;\n\tu32 *addr = (u32 *)(runtime->dma_area + offset);\n\n\tif (snd_BUG_ON(count % 4))\n\t\treturn;\n\n\tvx2_setup_pseudo_dma(chip, 1);\n\n\t \n\tif (offset + count >= pipe->buffer_bytes) {\n\t\tint length = pipe->buffer_bytes - offset;\n\t\tcount -= length;\n\t\tlength >>= 2;  \n\t\t \n\t\tfor (; length > 0; length--) {\n\t\t\toutl(*addr, port);\n\t\t\taddr++;\n\t\t}\n\t\taddr = (u32 *)runtime->dma_area;\n\t\tpipe->hw_ptr = 0;\n\t}\n\tpipe->hw_ptr += count;\n\tcount >>= 2;  \n\t \n\tfor (; count > 0; count--) {\n\t\toutl(*addr, port);\n\t\taddr++;\n\t}\n\n\tvx2_release_pseudo_dma(chip);\n}\n\n\n \nstatic void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,\n\t\t\t struct vx_pipe *pipe, int count)\n{\n\tint offset = pipe->hw_ptr;\n\tu32 *addr = (u32 *)(runtime->dma_area + offset);\n\tunsigned long port = vx2_reg_addr(chip, VX_DMA);\n\n\tif (snd_BUG_ON(count % 4))\n\t\treturn;\n\n\tvx2_setup_pseudo_dma(chip, 0);\n\t \n\tif (offset + count >= pipe->buffer_bytes) {\n\t\tint length = pipe->buffer_bytes - offset;\n\t\tcount -= length;\n\t\tlength >>= 2;  \n\t\t \n\t\tfor (; length > 0; length--)\n\t\t\t*addr++ = inl(port);\n\t\taddr = (u32 *)runtime->dma_area;\n\t\tpipe->hw_ptr = 0;\n\t}\n\tpipe->hw_ptr += count;\n\tcount >>= 2;  \n\t \n\tfor (; count > 0; count--)\n\t\t*addr++ = inl(port);\n\n\tvx2_release_pseudo_dma(chip);\n}\n\n#define VX_XILINX_RESET_MASK        0x40000000\n#define VX_USERBIT0_MASK            0x00000004\n#define VX_USERBIT1_MASK            0x00000020\n#define VX_CNTRL_REGISTER_VALUE     0x00172012\n\n \nstatic int put_xilinx_data(struct vx_core *chip, unsigned int port, unsigned int counts, unsigned char data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < counts; i++) {\n\t\tunsigned int val;\n\n\t\t \n\t\tval = VX_CNTRL_REGISTER_VALUE & ~VX_USERBIT0_MASK;\n\t\tvx2_outl(chip, port, val);\n\t\tvx2_inl(chip, port);\n\t\tudelay(1);\n\n\t\tif (data & (1 << i))\n\t\t\tval |= VX_USERBIT1_MASK;\n\t\telse\n\t\t\tval &= ~VX_USERBIT1_MASK;\n\t\tvx2_outl(chip, port, val);\n\t\tvx2_inl(chip, port);\n\n\t\t \n\t\tval |= VX_USERBIT0_MASK;\n\t\tvx2_outl(chip, port, val);\n\t\tvx2_inl(chip, port);\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\n \nstatic int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *xilinx)\n{\n\tunsigned int i;\n\tunsigned int port;\n\tconst unsigned char *image;\n\n\t \n\tvx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);\n\tvx_inl(chip, CNTRL);\n\tmsleep(10);\n\tvx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE);\n\tvx_inl(chip, CNTRL);\n\tmsleep(10);\n\n\tif (chip->type == VX_TYPE_BOARD)\n\t\tport = VX_CNTRL;\n\telse\n\t\tport = VX_GPIOC;  \n\n\timage = xilinx->data;\n\tfor (i = 0; i < xilinx->size; i++, image++) {\n\t\tif (put_xilinx_data(chip, port, 8, *image) < 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tcond_resched();\n\t}\n\tput_xilinx_data(chip, port, 4, 0xff);  \n\n\tmsleep(200);\n\n\t \n\tif (chip->type != VX_TYPE_BOARD) {\n\t\t \n\t\ti = vx_inl(chip, GPIOC);\n\t\tif (i & 0x0100)\n\t\t\treturn 0;\n\t\tdev_err(chip->card->dev,\n\t\t\t\"xilinx test failed after load, GPIOC=0x%x\\n\", i);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\t\n \nstatic int vx2_load_dsp(struct vx_core *vx, int index, const struct firmware *dsp)\n{\n\tint err;\n\n\tswitch (index) {\n\tcase 1:\n\t\t \n\t\terr = vx2_load_xilinx_binary(vx, dsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = vx2_test_xilinx(vx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\treturn 0;\n\tcase 2:\n\t\t \n\t\treturn snd_vx_dsp_boot(vx, dsp);\n\tcase 3:\n\t\t \n\t\treturn snd_vx_dsp_load(vx, dsp);\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \nstatic int vx2_test_and_ack(struct vx_core *chip)\n{\n\t \n\tif (! (chip->chip_status & VX_STAT_XILINX_LOADED))\n\t\treturn -ENXIO;\n\n\tif (! (vx_inl(chip, STATUS) & VX_STATUS_MEMIRQ_MASK))\n\t\treturn -EIO;\n\t\n\t \n\t \n\tvx_outl(chip, STATUS, 0);\n\t \n\tvx_inl(chip, STATUS);\n\t \n\tvx_outl(chip, STATUS, VX_STATUS_MEMIRQ_MASK);\n\t \n\tvx_inl(chip, STATUS);\n\t \n\tvx_outl(chip, STATUS, 0);\n\n\treturn 0;\n}\n\n\n \nstatic void vx2_validate_irq(struct vx_core *_chip, int enable)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\t \n\tif (enable) {\n\t\t \n\t\tvx_outl(chip, INTCSR, VX_INTCSR_VALUE|VX_PCI_INTERRUPT_MASK);\n\t\tchip->regCDSP |= VX_CDSP_VALID_IRQ_MASK;\n\t} else {\n\t\t \n\t\tvx_outl(chip, INTCSR, VX_INTCSR_VALUE&~VX_PCI_INTERRUPT_MASK);\n\t\tchip->regCDSP &= ~VX_CDSP_VALID_IRQ_MASK;\n\t}\n\tvx_outl(chip, CDSP, chip->regCDSP);\n}\n\n\n \nstatic void vx2_write_codec_reg(struct vx_core *chip, unsigned int data)\n{\n\tunsigned int i;\n\n\tvx_inl(chip, HIFREQ);\n\n\t \n\tfor (i = 0; i < 24; i++, data <<= 1)\n\t\tvx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\n\t \n\tvx_inl(chip, RUER);\n}\n\n\n#define AKM_CODEC_POWER_CONTROL_CMD 0xA007\n#define AKM_CODEC_RESET_ON_CMD      0xA100\n#define AKM_CODEC_RESET_OFF_CMD     0xA103\n#define AKM_CODEC_CLOCK_FORMAT_CMD  0xA240\n#define AKM_CODEC_MUTE_CMD          0xA38D\n#define AKM_CODEC_UNMUTE_CMD        0xA30D\n#define AKM_CODEC_LEFT_LEVEL_CMD    0xA400\n#define AKM_CODEC_RIGHT_LEVEL_CMD   0xA500\n\nstatic const u8 vx2_akm_gains_lut[VX2_AKM_LEVEL_MAX+1] = {\n    0x7f,        \n    0x7d,        \n    0x7c,        \n    0x7a,        \n    0x79,        \n    0x77,        \n    0x76,        \n    0x75,        \n    0x73,        \n    0x72,        \n    0x71,        \n    0x70,        \n    0x6f,        \n    0x6d,        \n    0x6c,        \n    0x6a,        \n    0x69,        \n    0x67,        \n    0x66,        \n    0x65,        \n    0x64,        \n    0x62,        \n    0x61,        \n    0x60,        \n    0x5f,        \n    0x5e,        \n    0x5c,        \n    0x5b,        \n    0x59,        \n    0x58,        \n    0x56,        \n    0x55,        \n    0x54,        \n    0x53,        \n    0x52,        \n    0x51,        \n    0x50,        \n    0x4e,        \n    0x4d,        \n    0x4b,        \n    0x4a,        \n    0x48,        \n    0x47,        \n    0x46,        \n    0x44,        \n    0x43,        \n    0x42,        \n    0x41,        \n    0x40,        \n    0x3f,        \n    0x3e,        \n    0x3c,        \n    0x3b,        \n    0x39,        \n    0x38,        \n    0x37,        \n    0x36,        \n    0x34,        \n    0x33,        \n    0x32,        \n    0x31,        \n    0x31,        \n    0x30,        \n    0x2e,        \n    0x2d,        \n    0x2b,        \n    0x2a,        \n    0x29,        \n    0x28,        \n    0x27,        \n    0x25,        \n    0x24,        \n    0x24,        \n    0x23,        \n    0x22,        \n    0x21,        \n    0x20,        \n    0x1f,        \n    0x1e,        \n    0x1d,        \n    0x1c,        \n    0x1b,        \n    0x1a,        \n    0x19,        \n    0x18,        \n    0x17,        \n    0x16,        \n    0x15,        \n    0x14,        \n    0x14,        \n    0x13,        \n    0x12,        \n    0x12,        \n    0x11,        \n    0x11,        \n    0x10,        \n    0x10,        \n    0x0f,        \n    0x0e,        \n    0x0d,        \n    0x0d,        \n    0x0c,        \n    0x0b,        \n    0x0b,        \n    0x0a,        \n    0x0a,        \n    0x09,        \n    0x09,        \n    0x08,        \n    0x08,        \n    0x07,        \n    0x07,        \n    0x06,        \n    0x06,        \n    0x06,        \n    0x05,        \n    0x05,        \n    0x05,        \n    0x05,        \n    0x04,        \n    0x04,        \n    0x04,        \n    0x04,        \n    0x03,        \n    0x03,        \n    0x03,        \n    0x03,        \n    0x03,        \n    0x03,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x02,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x01,        \n    0x00};       \n\n \nstatic void vx2_write_akm(struct vx_core *chip, int reg, unsigned int data)\n{\n\tunsigned int val;\n\n\tif (reg == XX_CODEC_DAC_CONTROL_REGISTER) {\n\t\tvx2_write_codec_reg(chip, data ? AKM_CODEC_MUTE_CMD : AKM_CODEC_UNMUTE_CMD);\n\t\treturn;\n\t}\n\n\t \n\tif (snd_BUG_ON(data >= sizeof(vx2_akm_gains_lut)))\n\t\treturn;\n\n\tswitch (reg) {\n\tcase XX_CODEC_LEVEL_LEFT_REGISTER:\n\t\tval = AKM_CODEC_LEFT_LEVEL_CMD;\n\t\tbreak;\n\tcase XX_CODEC_LEVEL_RIGHT_REGISTER:\n\t\tval = AKM_CODEC_RIGHT_LEVEL_CMD;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn;\n\t}\n\tval |= vx2_akm_gains_lut[data];\n\n\tvx2_write_codec_reg(chip, val);\n}\n\n\n \nstatic void vx2_old_write_codec_bit(struct vx_core *chip, int codec, unsigned int data)\n{\n\tint i;\n\n\t \n\tvx_inl(chip, HIFREQ);\n\n\tfor (i = 0; i < 24; i++, data <<= 1)\n\t\tvx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\n\n\t \n\tvx_inl(chip, RUER);\n}\n\n\n \nstatic void vx2_reset_codec(struct vx_core *_chip)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\t \n\tvx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);\n\tvx_inl(chip, CDSP);\n\tmsleep(10);\n\t \n\tchip->regCDSP |= VX_CDSP_CODEC_RESET_MASK;\n\tvx_outl(chip, CDSP, chip->regCDSP);\n\tvx_inl(chip, CDSP);\n\tif (_chip->type == VX_TYPE_BOARD) {\n\t\tmsleep(1);\n\t\treturn;\n\t}\n\n\tmsleep(5);   \n\n\tvx2_write_codec_reg(_chip, AKM_CODEC_POWER_CONTROL_CMD);  \n\t\n\tvx2_write_codec_reg(_chip, AKM_CODEC_CLOCK_FORMAT_CMD);  \n\tvx2_write_codec_reg(_chip, AKM_CODEC_MUTE_CMD);  \n\tvx2_write_codec_reg(_chip, AKM_CODEC_RESET_OFF_CMD);  \n\n\tif (_chip->type == VX_TYPE_MIC) {\n\t\t \n\t\tchip->regSELMIC =  MICRO_SELECT_INPUT_NORM |\n\t\t\tMICRO_SELECT_PREAMPLI_G_0 |\n\t\t\tMICRO_SELECT_NOISE_T_52DB;\n\n\t\t \n\t\tchip->regSELMIC &= ~MICRO_SELECT_PHANTOM_ALIM;\n\n\t\tvx_outl(_chip, SELMIC, chip->regSELMIC);\n\t}\n}\n\n\n \nstatic void vx2_change_audio_source(struct vx_core *_chip, int src)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\tswitch (src) {\n\tcase VX_AUDIO_SRC_DIGITAL:\n\t\tchip->regCFG |= VX_CFG_DATAIN_SEL_MASK;\n\t\tbreak;\n\tdefault:\n\t\tchip->regCFG &= ~VX_CFG_DATAIN_SEL_MASK;\n\t\tbreak;\n\t}\n\tvx_outl(chip, CFG, chip->regCFG);\n}\n\n\n \nstatic void vx2_set_clock_source(struct vx_core *_chip, int source)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\tif (source == INTERNAL_QUARTZ)\n\t\tchip->regCFG &= ~VX_CFG_CLOCKIN_SEL_MASK;\n\telse\n\t\tchip->regCFG |= VX_CFG_CLOCKIN_SEL_MASK;\n\tvx_outl(chip, CFG, chip->regCFG);\n}\n\n \nstatic void vx2_reset_board(struct vx_core *_chip, int cold_reset)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\n\t \n\tchip->regCDSP = VX_CDSP_CODEC_RESET_MASK | VX_CDSP_DSP_RESET_MASK ;\n\tchip->regCFG = 0;\n}\n\n\n\n \n\n \n#define V2_MICRO_LEVEL_RANGE        (318 - 255)\n\nstatic void vx2_set_input_level(struct snd_vx222 *chip)\n{\n\tint i, miclevel, preamp;\n\tunsigned int data;\n\n\tmiclevel = chip->mic_level;\n\tmiclevel += V2_MICRO_LEVEL_RANGE;  \n\tpreamp = 0;\n        while (miclevel > 210) {  \n\t\tpreamp++;\t \n\t\tmiclevel -= (18 * 2);    \n        }\n\tif (snd_BUG_ON(preamp >= 4))\n\t\treturn;\n\n\t \n\tchip->regSELMIC &= ~MICRO_SELECT_PREAMPLI_MASK;\n\tchip->regSELMIC |= (preamp << MICRO_SELECT_PREAMPLI_OFFSET) & MICRO_SELECT_PREAMPLI_MASK;\n\tvx_outl(chip, SELMIC, chip->regSELMIC);\n\n\tdata = (unsigned int)miclevel << 16 |\n\t\t(unsigned int)chip->input_level[1] << 8 |\n\t\t(unsigned int)chip->input_level[0];\n\tvx_inl(chip, DATA);  \n\n\t \n\tfor (i = 0; i < 32; i++, data <<= 1)\n\t\tvx_outl(chip, DATA, ((data & 0x80000000) ? VX_DATA_CODEC_MASK : 0));\n\n\tvx_inl(chip, RUER);  \n}\n\n\n#define MIC_LEVEL_MAX\t0xff\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_mic, -6450, 50, 0);\n\n \n\n \nstatic int vx_input_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = MIC_LEVEL_MAX;\n\treturn 0;\n}\n\nstatic int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tmutex_lock(&_chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->input_level[0];\n\tucontrol->value.integer.value[1] = chip->input_level[1];\n\tmutex_unlock(&_chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tif (ucontrol->value.integer.value[0] < 0 ||\n\t    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)\n\t\treturn -EINVAL;\n\tif (ucontrol->value.integer.value[1] < 0 ||\n\t    ucontrol->value.integer.value[1] > MIC_LEVEL_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&_chip->mixer_mutex);\n\tif (chip->input_level[0] != ucontrol->value.integer.value[0] ||\n\t    chip->input_level[1] != ucontrol->value.integer.value[1]) {\n\t\tchip->input_level[0] = ucontrol->value.integer.value[0];\n\t\tchip->input_level[1] = ucontrol->value.integer.value[1];\n\t\tvx2_set_input_level(chip);\n\t\tmutex_unlock(&_chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&_chip->mixer_mutex);\n\treturn 0;\n}\n\n \nstatic int vx_mic_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = MIC_LEVEL_MAX;\n\treturn 0;\n}\n\nstatic int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tucontrol->value.integer.value[0] = chip->mic_level;\n\treturn 0;\n}\n\nstatic int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tif (ucontrol->value.integer.value[0] < 0 ||\n\t    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&_chip->mixer_mutex);\n\tif (chip->mic_level != ucontrol->value.integer.value[0]) {\n\t\tchip->mic_level = ucontrol->value.integer.value[0];\n\t\tvx2_set_input_level(chip);\n\t\tmutex_unlock(&_chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&_chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_input_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"Capture Volume\",\n\t.info =\t\tvx_input_level_info,\n\t.get =\t\tvx_input_level_get,\n\t.put =\t\tvx_input_level_put,\n\t.tlv = { .p = db_scale_mic },\n};\n\nstatic const struct snd_kcontrol_new vx_control_mic_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"Mic Capture Volume\",\n\t.info =\t\tvx_mic_level_info,\n\t.get =\t\tvx_mic_level_get,\n\t.put =\t\tvx_mic_level_put,\n\t.tlv = { .p = db_scale_mic },\n};\n\n \n\nstatic int vx2_add_mic_controls(struct vx_core *_chip)\n{\n\tstruct snd_vx222 *chip = to_vx222(_chip);\n\tint err;\n\n\tif (_chip->type != VX_TYPE_MIC)\n\t\treturn 0;\n\n\t \n\tchip->input_level[0] = chip->input_level[1] = 0;\n\tchip->mic_level = 0;\n\tvx2_set_input_level(chip);\n\n\t \n\terr = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_input_level, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n \nconst struct snd_vx_ops vx222_ops = {\n\t.in8 = vx2_inb,\n\t.in32 = vx2_inl,\n\t.out8 = vx2_outb,\n\t.out32 = vx2_outl,\n\t.test_and_ack = vx2_test_and_ack,\n\t.validate_irq = vx2_validate_irq,\n\t.akm_write = vx2_write_akm,\n\t.reset_codec = vx2_reset_codec,\n\t.change_audio_source = vx2_change_audio_source,\n\t.set_clock_source = vx2_set_clock_source,\n\t.load_dsp = vx2_load_dsp,\n\t.reset_dsp = vx2_reset_dsp,\n\t.reset_board = vx2_reset_board,\n\t.dma_write = vx2_dma_write,\n\t.dma_read = vx2_dma_read,\n\t.add_controls = vx2_add_mic_controls,\n};\n\n \nconst struct snd_vx_ops vx222_old_ops = {\n\t.in8 = vx2_inb,\n\t.in32 = vx2_inl,\n\t.out8 = vx2_outb,\n\t.out32 = vx2_outl,\n\t.test_and_ack = vx2_test_and_ack,\n\t.validate_irq = vx2_validate_irq,\n\t.write_codec = vx2_old_write_codec_bit,\n\t.reset_codec = vx2_reset_codec,\n\t.change_audio_source = vx2_change_audio_source,\n\t.set_clock_source = vx2_set_clock_source,\n\t.load_dsp = vx2_load_dsp,\n\t.reset_dsp = vx2_reset_dsp,\n\t.reset_board = vx2_reset_board,\n\t.dma_write = vx2_dma_write,\n\t.dma_read = vx2_dma_read,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}