{
  "module_name": "es1938.c",
  "hash_id": "3dabcac563a51ed98c89d2e98865b6e5358910d7435770ca2f6de78cb74469c3",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/es1938.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/opl3.h>\n#include <sound/mpu401.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\nMODULE_AUTHOR(\"Jaromir Koutek <miri@punknet.cz>\");\nMODULE_DESCRIPTION(\"ESS Solo-1\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ESS Solo-1 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ESS Solo-1 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ESS Solo-1 soundcard.\");\n\n#define SLIO_REG(chip, x) ((chip)->io_port + ESSIO_REG_##x)\n\n#define SLDM_REG(chip, x) ((chip)->ddma_port + ESSDM_REG_##x)\n\n#define SLSB_REG(chip, x) ((chip)->sb_port + ESSSB_REG_##x)\n\n#define SL_PCI_LEGACYCONTROL\t\t0x40\n#define SL_PCI_CONFIG\t\t\t0x50\n#define SL_PCI_DDMACONTROL\t\t0x60\n\n#define ESSIO_REG_AUDIO2DMAADDR\t\t0\n#define ESSIO_REG_AUDIO2DMACOUNT\t4\n#define ESSIO_REG_AUDIO2MODE\t\t6\n#define ESSIO_REG_IRQCONTROL\t\t7\n\n#define ESSDM_REG_DMAADDR\t\t0x00\n#define ESSDM_REG_DMACOUNT\t\t0x04\n#define ESSDM_REG_DMACOMMAND\t\t0x08\n#define ESSDM_REG_DMASTATUS\t\t0x08\n#define ESSDM_REG_DMAMODE\t\t0x0b\n#define ESSDM_REG_DMACLEAR\t\t0x0d\n#define ESSDM_REG_DMAMASK\t\t0x0f\n\n#define ESSSB_REG_FMLOWADDR\t\t0x00\n#define ESSSB_REG_FMHIGHADDR\t\t0x02\n#define ESSSB_REG_MIXERADDR\t\t0x04\n#define ESSSB_REG_MIXERDATA\t\t0x05\n\n#define ESSSB_IREG_AUDIO1\t\t0x14\n#define ESSSB_IREG_MICMIX\t\t0x1a\n#define ESSSB_IREG_RECSRC\t\t0x1c\n#define ESSSB_IREG_MASTER\t\t0x32\n#define ESSSB_IREG_FM\t\t\t0x36\n#define ESSSB_IREG_AUXACD\t\t0x38\n#define ESSSB_IREG_AUXB\t\t\t0x3a\n#define ESSSB_IREG_PCSPEAKER\t\t0x3c\n#define ESSSB_IREG_LINE\t\t\t0x3e\n#define ESSSB_IREG_SPATCONTROL\t\t0x50\n#define ESSSB_IREG_SPATLEVEL\t\t0x52\n#define ESSSB_IREG_MASTER_LEFT\t\t0x60\n#define ESSSB_IREG_MASTER_RIGHT\t\t0x62\n#define ESSSB_IREG_MPU401CONTROL\t0x64\n#define ESSSB_IREG_MICMIXRECORD\t\t0x68\n#define ESSSB_IREG_AUDIO2RECORD\t\t0x69\n#define ESSSB_IREG_AUXACDRECORD\t\t0x6a\n#define ESSSB_IREG_FMRECORD\t\t0x6b\n#define ESSSB_IREG_AUXBRECORD\t\t0x6c\n#define ESSSB_IREG_MONO\t\t\t0x6d\n#define ESSSB_IREG_LINERECORD\t\t0x6e\n#define ESSSB_IREG_MONORECORD\t\t0x6f\n#define ESSSB_IREG_AUDIO2SAMPLE\t\t0x70\n#define ESSSB_IREG_AUDIO2MODE\t\t0x71\n#define ESSSB_IREG_AUDIO2FILTER\t\t0x72\n#define ESSSB_IREG_AUDIO2TCOUNTL\t0x74\n#define ESSSB_IREG_AUDIO2TCOUNTH\t0x76\n#define ESSSB_IREG_AUDIO2CONTROL1\t0x78\n#define ESSSB_IREG_AUDIO2CONTROL2\t0x7a\n#define ESSSB_IREG_AUDIO2\t\t0x7c\n\n#define ESSSB_REG_RESET\t\t\t0x06\n\n#define ESSSB_REG_READDATA\t\t0x0a\n#define ESSSB_REG_WRITEDATA\t\t0x0c\n#define ESSSB_REG_READSTATUS\t\t0x0c\n\n#define ESSSB_REG_STATUS\t\t0x0e\n\n#define ESS_CMD_EXTSAMPLERATE\t\t0xa1\n#define ESS_CMD_FILTERDIV\t\t0xa2\n#define ESS_CMD_DMACNTRELOADL\t\t0xa4\n#define ESS_CMD_DMACNTRELOADH\t\t0xa5\n#define ESS_CMD_ANALOGCONTROL\t\t0xa8\n#define ESS_CMD_IRQCONTROL\t\t0xb1\n#define ESS_CMD_DRQCONTROL\t\t0xb2\n#define ESS_CMD_RECLEVEL\t\t0xb4\n#define ESS_CMD_SETFORMAT\t\t0xb6\n#define ESS_CMD_SETFORMAT2\t\t0xb7\n#define ESS_CMD_DMACONTROL\t\t0xb8\n#define ESS_CMD_DMATYPE\t\t\t0xb9\n#define ESS_CMD_OFFSETLEFT\t\t0xba\t\n#define ESS_CMD_OFFSETRIGHT\t\t0xbb\n#define ESS_CMD_READREG\t\t\t0xc0\n#define ESS_CMD_ENABLEEXT\t\t0xc6\n#define ESS_CMD_PAUSEDMA\t\t0xd0\n#define ESS_CMD_ENABLEAUDIO1\t\t0xd1\n#define ESS_CMD_STOPAUDIO1\t\t0xd3\n#define ESS_CMD_AUDIO1STATUS\t\t0xd8\n#define ESS_CMD_CONTDMA\t\t\t0xd4\n#define ESS_CMD_TESTIRQ\t\t\t0xf2\n\n#define ESS_RECSRC_MIC\t\t0\n#define ESS_RECSRC_AUXACD\t2\n#define ESS_RECSRC_AUXB\t\t5\n#define ESS_RECSRC_LINE\t\t6\n#define ESS_RECSRC_NONE\t\t7\n\n#define DAC1 0x01\n#define ADC1 0x02\n#define DAC2 0x04\n\n \n\n#define SAVED_REG_SIZE\t32  \n\nstruct es1938 {\n\tint irq;\n\n\tunsigned long io_port;\n\tunsigned long sb_port;\n\tunsigned long vc_port;\n\tunsigned long mpu_port;\n\tunsigned long game_port;\n\tunsigned long ddma_port;\n\n\tunsigned char irqmask;\n\tunsigned char revision;\n\n\tstruct snd_kcontrol *hw_volume;\n\tstruct snd_kcontrol *hw_switch;\n\tstruct snd_kcontrol *master_volume;\n\tstruct snd_kcontrol *master_switch;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *capture_substream;\n\tstruct snd_pcm_substream *playback1_substream;\n\tstruct snd_pcm_substream *playback2_substream;\n\tstruct snd_rawmidi *rmidi;\n\n\tunsigned int dma1_size;\n\tunsigned int dma2_size;\n\tunsigned int dma1_start;\n\tunsigned int dma2_start;\n\tunsigned int dma1_shift;\n\tunsigned int dma2_shift;\n\tunsigned int last_capture_dmaaddr;\n\tunsigned int active;\n\n\tspinlock_t reg_lock;\n\tspinlock_t mixer_lock;\n        struct snd_info_entry *proc_entry;\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n#ifdef CONFIG_PM_SLEEP\n\tunsigned char saved_regs[SAVED_REG_SIZE];\n#endif\n};\n\nstatic irqreturn_t snd_es1938_interrupt(int irq, void *dev_id);\n\nstatic const struct pci_device_id snd_es1938_ids[] = {\n\t{ PCI_VDEVICE(ESS, 0x1969), 0, },    \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_es1938_ids);\n\n#define RESET_LOOP_TIMEOUT\t0x10000\n#define WRITE_LOOP_TIMEOUT\t0x10000\n#define GET_LOOP_TIMEOUT\t0x01000\n\n \nstatic void snd_es1938_mixer_write(struct es1938 *chip, unsigned char reg, unsigned char val)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\toutb(reg, SLSB_REG(chip, MIXERADDR));\n\toutb(val, SLSB_REG(chip, MIXERDATA));\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\tdev_dbg(chip->card->dev, \"Mixer reg %02x set to %02x\\n\", reg, val);\n}\n\n \nstatic int snd_es1938_mixer_read(struct es1938 *chip, unsigned char reg)\n{\n\tint data;\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\toutb(reg, SLSB_REG(chip, MIXERADDR));\n\tdata = inb(SLSB_REG(chip, MIXERDATA));\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\tdev_dbg(chip->card->dev, \"Mixer reg %02x now is %02x\\n\", reg, data);\n\treturn data;\n}\n\n \nstatic int snd_es1938_mixer_bits(struct es1938 *chip, unsigned char reg,\n\t\t\t\t unsigned char mask, unsigned char val)\n{\n\tunsigned long flags;\n\tunsigned char old, new, oval;\n\tspin_lock_irqsave(&chip->mixer_lock, flags);\n\toutb(reg, SLSB_REG(chip, MIXERADDR));\n\told = inb(SLSB_REG(chip, MIXERDATA));\n\toval = old & mask;\n\tif (val != oval) {\n\t\tnew = (old & ~mask) | (val & mask);\n\t\toutb(new, SLSB_REG(chip, MIXERDATA));\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"Mixer reg %02x was %02x, set to %02x\\n\",\n\t\t\t   reg, old, new);\n\t}\n\tspin_unlock_irqrestore(&chip->mixer_lock, flags);\n\treturn oval;\n}\n\n \nstatic void snd_es1938_write_cmd(struct es1938 *chip, unsigned char cmd)\n{\n\tint i;\n\tunsigned char v;\n\tfor (i = 0; i < WRITE_LOOP_TIMEOUT; i++) {\n\t\tv = inb(SLSB_REG(chip, READSTATUS));\n\t\tif (!(v & 0x80)) {\n\t\t\toutb(cmd, SLSB_REG(chip, WRITEDATA));\n\t\t\treturn;\n\t\t}\n\t}\n\tdev_err(chip->card->dev,\n\t\t\"snd_es1938_write_cmd timeout (0x02%x/0x02%x)\\n\", cmd, v);\n}\n\n \nstatic int snd_es1938_get_byte(struct es1938 *chip)\n{\n\tint i;\n\tunsigned char v;\n\tfor (i = GET_LOOP_TIMEOUT; i; i--) {\n\t\tv = inb(SLSB_REG(chip, STATUS));\n\t\tif (v & 0x80)\n\t\t\treturn inb(SLSB_REG(chip, READDATA));\n\t}\n\tdev_err(chip->card->dev, \"get_byte timeout: status 0x02%x\\n\", v);\n\treturn -ENODEV;\n}\n\n \nstatic void snd_es1938_write(struct es1938 *chip, unsigned char reg, unsigned char val)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1938_write_cmd(chip, reg);\n\tsnd_es1938_write_cmd(chip, val);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tdev_dbg(chip->card->dev, \"Reg %02x set to %02x\\n\", reg, val);\n}\n\n \nstatic unsigned char snd_es1938_read(struct es1938 *chip, unsigned char reg)\n{\n\tunsigned char val;\n\tunsigned long flags;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1938_write_cmd(chip, ESS_CMD_READREG);\n\tsnd_es1938_write_cmd(chip, reg);\n\tval = snd_es1938_get_byte(chip);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\tdev_dbg(chip->card->dev, \"Reg %02x now is %02x\\n\", reg, val);\n\treturn val;\n}\n\n \nstatic int snd_es1938_bits(struct es1938 *chip, unsigned char reg, unsigned char mask,\n\t\t\t   unsigned char val)\n{\n\tunsigned long flags;\n\tunsigned char old, new, oval;\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_es1938_write_cmd(chip, ESS_CMD_READREG);\n\tsnd_es1938_write_cmd(chip, reg);\n\told = snd_es1938_get_byte(chip);\n\toval = old & mask;\n\tif (val != oval) {\n\t\tsnd_es1938_write_cmd(chip, reg);\n\t\tnew = (old & ~mask) | (val & mask);\n\t\tsnd_es1938_write_cmd(chip, new);\n\t\tdev_dbg(chip->card->dev, \"Reg %02x was %02x, set to %02x\\n\",\n\t\t\t   reg, old, new);\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn oval;\n}\n\n \nstatic void snd_es1938_reset(struct es1938 *chip)\n{\n\tint i;\n\n\toutb(3, SLSB_REG(chip, RESET));\n\tinb(SLSB_REG(chip, RESET));\n\toutb(0, SLSB_REG(chip, RESET));\n\tfor (i = 0; i < RESET_LOOP_TIMEOUT; i++) {\n\t\tif (inb(SLSB_REG(chip, STATUS)) & 0x80) {\n\t\t\tif (inb(SLSB_REG(chip, READDATA)) == 0xaa)\n\t\t\t\tgoto __next;\n\t\t}\n\t}\n\tdev_err(chip->card->dev, \"ESS Solo-1 reset failed\\n\");\n\n     __next:\n\tsnd_es1938_write_cmd(chip, ESS_CMD_ENABLEEXT);\n\n\t \n\tsnd_es1938_write(chip, ESS_CMD_DMATYPE, 2);\n\n\t                                                       \n\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2MODE, 0x32);\n\t \n\tsnd_es1938_bits(chip, ESS_CMD_IRQCONTROL, 0xf0, 0x50);\n\tsnd_es1938_bits(chip, ESS_CMD_DRQCONTROL, 0xf0, 0x50);\n\tsnd_es1938_write_cmd(chip, ESS_CMD_ENABLEAUDIO1);\n\t \n\tsnd_es1938_mixer_write(chip, 0x54, 0x8f);\n\tsnd_es1938_mixer_write(chip, 0x56, 0x95);\n\tsnd_es1938_mixer_write(chip, 0x58, 0x94);\n\tsnd_es1938_mixer_write(chip, 0x5a, 0x80);\n}\n\n \nstatic void snd_es1938_reset_fifo(struct es1938 *chip)\n{\n\toutb(2, SLSB_REG(chip, RESET));\n\toutb(0, SLSB_REG(chip, RESET));\n}\n\nstatic const struct snd_ratnum clocks[2] = {\n\t{\n\t\t.num = 793800,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t},\n\t{\n\t\t.num = 768000,\n\t\t.den_min = 1,\n\t\t.den_max = 128,\n\t\t.den_step = 1,\n\t}\n};\n\nstatic const struct snd_pcm_hw_constraint_ratnums hw_constraints_clocks = {\n\t.nrats = 2,\n\t.rats = clocks,\n};\n\n\nstatic void snd_es1938_rate_set(struct es1938 *chip, \n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tint mode)\n{\n\tunsigned int bits, div0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tif (runtime->rate_num == clocks[0].num)\n\t\tbits = 128 - runtime->rate_den;\n\telse\n\t\tbits = 256 - runtime->rate_den;\n\n\t \n\tdiv0 = 256 - 7160000*20/(8*82*runtime->rate);\n\t\t\n\tif (mode == DAC2) {\n\t\tsnd_es1938_mixer_write(chip, 0x70, bits);\n\t\tsnd_es1938_mixer_write(chip, 0x72, div0);\n\t} else {\n\t\tsnd_es1938_write(chip, 0xA1, bits);\n\t\tsnd_es1938_write(chip, 0xA2, div0);\n\t}\n}\n\n \n\nstatic void snd_es1938_playback1_setdma(struct es1938 *chip)\n{\n\toutb(0x00, SLIO_REG(chip, AUDIO2MODE));\n\toutl(chip->dma2_start, SLIO_REG(chip, AUDIO2DMAADDR));\n\toutw(0, SLIO_REG(chip, AUDIO2DMACOUNT));\n\toutw(chip->dma2_size, SLIO_REG(chip, AUDIO2DMACOUNT));\n}\n\nstatic void snd_es1938_playback2_setdma(struct es1938 *chip)\n{\n\t \n\toutb(0xc4, SLDM_REG(chip, DMACOMMAND));\n\t \n\toutb(0, SLDM_REG(chip, DMACLEAR));\n\t \n\toutb(1, SLDM_REG(chip, DMAMASK));\n\toutb(0x18, SLDM_REG(chip, DMAMODE));\n\toutl(chip->dma1_start, SLDM_REG(chip, DMAADDR));\n\toutw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));\n\t \n\toutb(0, SLDM_REG(chip, DMAMASK));\n}\n\nstatic void snd_es1938_capture_setdma(struct es1938 *chip)\n{\n\t \n\toutb(0xc4, SLDM_REG(chip, DMACOMMAND));\n\t \n\toutb(0, SLDM_REG(chip, DMACLEAR));\n\t \n\toutb(1, SLDM_REG(chip, DMAMASK));\n\toutb(0x14, SLDM_REG(chip, DMAMODE));\n\toutl(chip->dma1_start, SLDM_REG(chip, DMAADDR));\n\tchip->last_capture_dmaaddr = chip->dma1_start;\n\toutw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));\n\t \n\toutb(0, SLDM_REG(chip, DMAMASK));\n}\n\n \n\nstatic int snd_es1938_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tint val;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tval = 0x0f;\n\t\tchip->active |= ADC1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval = 0x00;\n\t\tchip->active &= ~ADC1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_es1938_write(chip, ESS_CMD_DMACONTROL, val);\n\treturn 0;\n}\n\nstatic int snd_es1938_playback1_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t \n                snd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0x92);\n                udelay(10);\n\t\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0x93);\n                 \n\t\toutb(0x0a, SLIO_REG(chip, AUDIO2MODE));\n\t\tchip->active |= DAC2;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\toutb(0, SLIO_REG(chip, AUDIO2MODE));\n\t\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0);\n\t\tchip->active &= ~DAC2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int snd_es1938_playback2_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tint val;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tval = 5;\n\t\tchip->active |= DAC1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval = 0;\n\t\tchip->active &= ~DAC1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_es1938_write(chip, ESS_CMD_DMACONTROL, val);\n\treturn 0;\n}\n\nstatic int snd_es1938_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tswitch (substream->number) {\n\tcase 0:\n\t\treturn snd_es1938_playback1_trigger(substream, cmd);\n\tcase 1:\n\t\treturn snd_es1938_playback2_trigger(substream, cmd);\n\t}\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\n \nstatic int snd_es1938_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint u, is8, mono;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tchip->dma1_size = size;\n\tchip->dma1_start = runtime->dma_addr;\n\n\tmono = (runtime->channels > 1) ? 0 : 1;\n\tis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\n\tu = snd_pcm_format_unsigned(runtime->format);\n\n\tchip->dma1_shift = 2 - mono - is8;\n\n\tsnd_es1938_reset_fifo(chip);\n\t\n\t \n\tsnd_es1938_bits(chip, ESS_CMD_ANALOGCONTROL, 0x03, (mono ? 2 : 1));\n\n\t \n        snd_es1938_rate_set(chip, substream, ADC1);\n\n\tcount = 0x10000 - count;\n\tsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADL, count & 0xff);\n\tsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADH, count >> 8);\n\n\t \n\tsnd_es1938_write(chip, ESS_CMD_SETFORMAT2, u ? 0x51 : 0x71);\n\tsnd_es1938_write(chip, ESS_CMD_SETFORMAT2, 0x90 | \n\t\t       (u ? 0x00 : 0x20) | \n\t\t       (is8 ? 0x00 : 0x04) | \n\t\t       (mono ? 0x40 : 0x08));\n\n\t \n\n\t \n\tsnd_es1938_capture_setdma(chip);\n\n\treturn 0;\n}\n\n\n \nstatic int snd_es1938_playback1_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint u, is8, mono;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tchip->dma2_size = size;\n\tchip->dma2_start = runtime->dma_addr;\n\n\tmono = (runtime->channels > 1) ? 0 : 1;\n\tis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\n\tu = snd_pcm_format_unsigned(runtime->format);\n\n\tchip->dma2_shift = 2 - mono - is8;\n\n        snd_es1938_reset_fifo(chip);\n\n\t \n        snd_es1938_rate_set(chip, substream, DAC2);\n\n\tcount >>= 1;\n\tcount = 0x10000 - count;\n\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2TCOUNTL, count & 0xff);\n\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2TCOUNTH, count >> 8);\n\n\t \n\tsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL2, 0x40 | (u ? 0 : 4) |\n\t\t\t       (mono ? 0 : 2) | (is8 ? 0 : 1));\n\n\t \n\tsnd_es1938_playback1_setdma(chip);\n\t\n\treturn 0;\n}\n\nstatic int snd_es1938_playback2_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint u, is8, mono;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tchip->dma1_size = size;\n\tchip->dma1_start = runtime->dma_addr;\n\n\tmono = (runtime->channels > 1) ? 0 : 1;\n\tis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\n\tu = snd_pcm_format_unsigned(runtime->format);\n\n\tchip->dma1_shift = 2 - mono - is8;\n\n\tcount = 0x10000 - count;\n \n\t \n\tsnd_es1938_reset_fifo(chip);\n\t\n\tsnd_es1938_bits(chip, ESS_CMD_ANALOGCONTROL, 0x03, (mono ? 2 : 1));\n\n\t \n        snd_es1938_rate_set(chip, substream, DAC1);\n\tsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADL, count & 0xff);\n\tsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADH, count >> 8);\n\n\t \n        snd_es1938_write(chip, ESS_CMD_SETFORMAT, u ? 0x80 : 0x00);\n        snd_es1938_write(chip, ESS_CMD_SETFORMAT, u ? 0x51 : 0x71);\n        snd_es1938_write(chip, ESS_CMD_SETFORMAT2, \n\t\t\t 0x90 | (mono ? 0x40 : 0x08) |\n\t\t\t (is8 ? 0x00 : 0x04) | (u ? 0x00 : 0x20));\n\n\t \n\tsnd_es1938_playback2_setdma(chip);\n\t\n\treturn 0;\n}\n\nstatic int snd_es1938_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tswitch (substream->number) {\n\tcase 0:\n\t\treturn snd_es1938_playback1_prepare(substream);\n\tcase 1:\n\t\treturn snd_es1938_playback2_prepare(substream);\n\t}\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\n \nstatic snd_pcm_uframes_t snd_es1938_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n#if 0\n\tsize_t old, new;\n\t \n\told = inw(SLDM_REG(chip, DMACOUNT));\n\twhile ((new = inw(SLDM_REG(chip, DMACOUNT))) != old)\n\t\told = new;\n\tptr = chip->dma1_size - 1 - new;\n#else\n\tsize_t count;\n\tunsigned int diff;\n\n\tptr = inl(SLDM_REG(chip, DMAADDR));\n\tcount = inw(SLDM_REG(chip, DMACOUNT));\n\tdiff = chip->dma1_start + chip->dma1_size - ptr - count;\n\n\tif (diff > 3 || ptr < chip->dma1_start\n\t      || ptr >= chip->dma1_start+chip->dma1_size)\n\t  ptr = chip->last_capture_dmaaddr;             \n\telse\n\t  chip->last_capture_dmaaddr = ptr;             \n\n\tptr -= chip->dma1_start;\n#endif\n\treturn ptr >> chip->dma1_shift;\n}\n\nstatic snd_pcm_uframes_t snd_es1938_playback1_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n#if 1\n\tptr = chip->dma2_size - inw(SLIO_REG(chip, AUDIO2DMACOUNT));\n#else\n\tptr = inl(SLIO_REG(chip, AUDIO2DMAADDR)) - chip->dma2_start;\n#endif\n\treturn ptr >> chip->dma2_shift;\n}\n\nstatic snd_pcm_uframes_t snd_es1938_playback2_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tsize_t old, new;\n#if 1\n\t \n\told = inw(SLDM_REG(chip, DMACOUNT));\n\twhile ((new = inw(SLDM_REG(chip, DMACOUNT))) != old)\n\t\told = new;\n\tptr = chip->dma1_size - 1 - new;\n#else\n\tptr = inl(SLDM_REG(chip, DMAADDR)) - chip->dma1_start;\n#endif\n\treturn ptr >> chip->dma1_shift;\n}\n\nstatic snd_pcm_uframes_t snd_es1938_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tswitch (substream->number) {\n\tcase 0:\n\t\treturn snd_es1938_playback1_pointer(substream);\n\tcase 1:\n\t\treturn snd_es1938_playback2_pointer(substream);\n\t}\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\nstatic int snd_es1938_capture_copy(struct snd_pcm_substream *substream,\n\t\t\t\t   int channel, unsigned long pos,\n\t\t\t\t   struct iov_iter *dst, unsigned long count)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\n\tif (snd_BUG_ON(pos + count > chip->dma1_size))\n\t\treturn -EINVAL;\n\tif (pos + count < chip->dma1_size) {\n\t\tif (copy_to_iter(runtime->dma_area + pos + 1, count, dst) != count)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_iter(runtime->dma_area + pos + 1, count - 1, dst) != count - 1)\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_iter(runtime->dma_area, 1, dst) != 1)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct snd_pcm_hardware snd_es1938_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t6000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n        .buffer_bytes_max =\t0x8000,        \n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t0x8000,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t256,\n};\n\n \nstatic const struct snd_pcm_hardware snd_es1938_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t6000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n        .buffer_bytes_max =\t0x8000,        \n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t0x8000,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t256,\n};\n\nstatic int snd_es1938_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (chip->playback2_substream)\n\t\treturn -EAGAIN;\n\tchip->capture_substream = substream;\n\truntime->hw = snd_es1938_capture;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clocks);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, 0xff00);\n\treturn 0;\n}\n\nstatic int snd_es1938_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tswitch (substream->number) {\n\tcase 0:\n\t\tchip->playback1_substream = substream;\n\t\tbreak;\n\tcase 1:\n\t\tif (chip->capture_substream)\n\t\t\treturn -EAGAIN;\n\t\tchip->playback2_substream = substream;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\truntime->hw = snd_es1938_playback;\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &hw_constraints_clocks);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, 0xff00);\n\treturn 0;\n}\n\nstatic int snd_es1938_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capture_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_es1938_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct es1938 *chip = snd_pcm_substream_chip(substream);\n\n\tswitch (substream->number) {\n\tcase 0:\n\t\tchip->playback1_substream = NULL;\n\t\tbreak;\n\tcase 1:\n\t\tchip->playback2_substream = NULL;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_es1938_playback_ops = {\n\t.open =\t\tsnd_es1938_playback_open,\n\t.close =\tsnd_es1938_playback_close,\n\t.prepare =\tsnd_es1938_playback_prepare,\n\t.trigger =\tsnd_es1938_playback_trigger,\n\t.pointer =\tsnd_es1938_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_es1938_capture_ops = {\n\t.open =\t\tsnd_es1938_capture_open,\n\t.close =\tsnd_es1938_capture_close,\n\t.prepare =\tsnd_es1938_capture_prepare,\n\t.trigger =\tsnd_es1938_capture_trigger,\n\t.pointer =\tsnd_es1938_capture_pointer,\n\t.copy =\t\tsnd_es1938_capture_copy,\n};\n\nstatic int snd_es1938_new_pcm(struct es1938 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"es-1938-1946\", device, 2, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1938_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1938_capture_ops);\n\t\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"ESS Solo-1\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 64*1024);\n\n\tchip->pcm = pcm;\n\treturn 0;\n}\n\n \n\nstatic int snd_es1938_info_mux(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[8] = {\n\t\t\"Mic\", \"Mic Master\", \"CD\", \"AOUT\",\n\t\t\"Mic1\", \"Mix\", \"Line\", \"Master\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 8, texts);\n}\n\nstatic int snd_es1938_get_mux(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = snd_es1938_mixer_read(chip, 0x1c) & 0x07;\n\treturn 0;\n}\n\nstatic int snd_es1938_put_mux(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char val = ucontrol->value.enumerated.item[0];\n\t\n\tif (val > 7)\n\t\treturn -EINVAL;\n\treturn snd_es1938_mixer_bits(chip, 0x1c, 0x07, val) != val;\n}\n\n#define snd_es1938_info_spatializer_enable\tsnd_ctl_boolean_mono_info\n\nstatic int snd_es1938_get_spatializer_enable(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char val = snd_es1938_mixer_read(chip, 0x50);\n\tucontrol->value.integer.value[0] = !!(val & 8);\n\treturn 0;\n}\n\nstatic int snd_es1938_put_spatializer_enable(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned char oval, nval;\n\tint change;\n\tnval = ucontrol->value.integer.value[0] ? 0x0c : 0x04;\n\toval = snd_es1938_mixer_read(chip, 0x50) & 0x0c;\n\tchange = nval != oval;\n\tif (change) {\n\t\tsnd_es1938_mixer_write(chip, 0x50, nval & ~0x04);\n\t\tsnd_es1938_mixer_write(chip, 0x50, nval);\n\t}\n\treturn change;\n}\n\nstatic int snd_es1938_info_hw_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 63;\n\treturn 0;\n}\n\nstatic int snd_es1938_get_hw_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = snd_es1938_mixer_read(chip, 0x61) & 0x3f;\n\tucontrol->value.integer.value[1] = snd_es1938_mixer_read(chip, 0x63) & 0x3f;\n\treturn 0;\n}\n\n#define snd_es1938_info_hw_switch\t\tsnd_ctl_boolean_stereo_info\n\nstatic int snd_es1938_get_hw_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = !(snd_es1938_mixer_read(chip, 0x61) & 0x40);\n\tucontrol->value.integer.value[1] = !(snd_es1938_mixer_read(chip, 0x63) & 0x40);\n\treturn 0;\n}\n\nstatic void snd_es1938_hwv_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tchip->master_volume = NULL;\n\tchip->master_switch = NULL;\n\tchip->hw_volume = NULL;\n\tchip->hw_switch = NULL;\n}\n\nstatic int snd_es1938_reg_bits(struct es1938 *chip, unsigned char reg,\n\t\t\t       unsigned char mask, unsigned char val)\n{\n\tif (reg < 0xa0)\n\t\treturn snd_es1938_mixer_bits(chip, reg, mask, val);\n\telse\n\t\treturn snd_es1938_bits(chip, reg, mask, val);\n}\n\nstatic int snd_es1938_reg_read(struct es1938 *chip, unsigned char reg)\n{\n\tif (reg < 0xa0)\n\t\treturn snd_es1938_mixer_read(chip, reg);\n\telse\n\t\treturn snd_es1938_read(chip, reg);\n}\n\n#define ES1938_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv)    \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\\\n  .name = xname, .index = xindex, \\\n  .info = snd_es1938_info_single, \\\n  .get = snd_es1938_get_single, .put = snd_es1938_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \\\n  .tlv = { .p = xtlv } }\n#define ES1938_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es1938_info_single, \\\n  .get = snd_es1938_get_single, .put = snd_es1938_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_es1938_info_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es1938_get_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint val;\n\t\n\tval = snd_es1938_reg_read(chip, reg);\n\tucontrol->value.integer.value[0] = (val >> shift) & mask;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_es1938_put_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tunsigned char val;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tmask <<= shift;\n\tval <<= shift;\n\treturn snd_es1938_reg_bits(chip, reg, mask, val) != val;\n}\n\n#define ES1938_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert, xtlv) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\\\n  .name = xname, .index = xindex, \\\n  .info = snd_es1938_info_double, \\\n  .get = snd_es1938_get_double, .put = snd_es1938_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22), \\\n  .tlv = { .p = xtlv } }\n#define ES1938_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_es1938_info_double, \\\n  .get = snd_es1938_get_double, .put = snd_es1938_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\nstatic int snd_es1938_info_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_es1938_get_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tunsigned char left, right;\n\t\n\tleft = snd_es1938_reg_read(chip, left_reg);\n\tif (left_reg != right_reg)\n\t\tright = snd_es1938_reg_read(chip, right_reg);\n\telse\n\t\tright = left;\n\tucontrol->value.integer.value[0] = (left >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (right >> shift_right) & mask;\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_es1938_put_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned char val1, val2, mask1, mask2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tmask1 = mask << shift_left;\n\tmask2 = mask << shift_right;\n\tif (left_reg != right_reg) {\n\t\tchange = 0;\n\t\tif (snd_es1938_reg_bits(chip, left_reg, mask1, val1) != val1)\n\t\t\tchange = 1;\n\t\tif (snd_es1938_reg_bits(chip, right_reg, mask2, val2) != val2)\n\t\t\tchange = 1;\n\t} else {\n\t\tchange = (snd_es1938_reg_bits(chip, left_reg, mask1 | mask2, \n\t\t\t\t\t      val1 | val2) != (val1 | val2));\n\t}\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_RANGE(db_scale_master,\n\t0, 54, TLV_DB_SCALE_ITEM(-3600, 50, 1),\n\t54, 63, TLV_DB_SCALE_ITEM(-900, 100, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(db_scale_audio1,\n\t0, 8, TLV_DB_SCALE_ITEM(-3300, 300, 1),\n\t8, 15, TLV_DB_SCALE_ITEM(-900, 150, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(db_scale_audio2,\n\t0, 8, TLV_DB_SCALE_ITEM(-3450, 300, 1),\n\t8, 15, TLV_DB_SCALE_ITEM(-1050, 150, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(db_scale_mic,\n\t0, 8, TLV_DB_SCALE_ITEM(-2400, 300, 1),\n\t8, 15, TLV_DB_SCALE_ITEM(0, 150, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(db_scale_line,\n\t0, 8, TLV_DB_SCALE_ITEM(-3150, 300, 1),\n\t8, 15, TLV_DB_SCALE_ITEM(-750, 150, 0),\n);\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_capture, 0, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_es1938_controls[] = {\nES1938_DOUBLE_TLV(\"Master Playback Volume\", 0, 0x60, 0x62, 0, 0, 63, 0,\n\t\t  db_scale_master),\nES1938_DOUBLE(\"Master Playback Switch\", 0, 0x60, 0x62, 6, 6, 1, 1),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Hardware Master Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = snd_es1938_info_hw_volume,\n\t.get = snd_es1938_get_hw_volume,\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name = \"Hardware Master Playback Switch\",\n\t.info = snd_es1938_info_hw_switch,\n\t.get = snd_es1938_get_hw_switch,\n\t.tlv = { .p = db_scale_master },\n},\nES1938_SINGLE(\"Hardware Volume Split\", 0, 0x64, 7, 1, 0),\nES1938_DOUBLE_TLV(\"Line Playback Volume\", 0, 0x3e, 0x3e, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE(\"CD Playback Volume\", 0, 0x38, 0x38, 4, 0, 15, 0),\nES1938_DOUBLE_TLV(\"FM Playback Volume\", 0, 0x36, 0x36, 4, 0, 15, 0,\n\t\t  db_scale_mic),\nES1938_DOUBLE_TLV(\"Mono Playback Volume\", 0, 0x6d, 0x6d, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"Mic Playback Volume\", 0, 0x1a, 0x1a, 4, 0, 15, 0,\n\t\t  db_scale_mic),\nES1938_DOUBLE_TLV(\"Aux Playback Volume\", 0, 0x3a, 0x3a, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"Capture Volume\", 0, 0xb4, 0xb4, 4, 0, 15, 0,\n\t\t  db_scale_capture),\nES1938_SINGLE(\"Beep Volume\", 0, 0x3c, 0, 7, 0),\nES1938_SINGLE(\"Record Monitor\", 0, 0xa8, 3, 1, 0),\nES1938_SINGLE(\"Capture Switch\", 0, 0x1c, 4, 1, 1),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_es1938_info_mux,\n\t.get = snd_es1938_get_mux,\n\t.put = snd_es1938_put_mux,\n},\nES1938_DOUBLE_TLV(\"Mono Input Playback Volume\", 0, 0x6d, 0x6d, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"PCM Capture Volume\", 0, 0x69, 0x69, 4, 0, 15, 0,\n\t\t  db_scale_audio2),\nES1938_DOUBLE_TLV(\"Mic Capture Volume\", 0, 0x68, 0x68, 4, 0, 15, 0,\n\t\t  db_scale_mic),\nES1938_DOUBLE_TLV(\"Line Capture Volume\", 0, 0x6e, 0x6e, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"FM Capture Volume\", 0, 0x6b, 0x6b, 4, 0, 15, 0,\n\t\t  db_scale_mic),\nES1938_DOUBLE_TLV(\"Mono Capture Volume\", 0, 0x6f, 0x6f, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"CD Capture Volume\", 0, 0x6a, 0x6a, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"Aux Capture Volume\", 0, 0x6c, 0x6c, 4, 0, 15, 0,\n\t\t  db_scale_line),\nES1938_DOUBLE_TLV(\"PCM Playback Volume\", 0, 0x7c, 0x7c, 4, 0, 15, 0,\n\t\t  db_scale_audio2),\nES1938_DOUBLE_TLV(\"PCM Playback Volume\", 1, 0x14, 0x14, 4, 0, 15, 0,\n\t\t  db_scale_audio1),\nES1938_SINGLE(\"3D Control - Level\", 0, 0x52, 0, 63, 0),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"3D Control - Switch\",\n\t.info = snd_es1938_info_spatializer_enable,\n\t.get = snd_es1938_get_spatializer_enable,\n\t.put = snd_es1938_put_spatializer_enable,\n},\nES1938_SINGLE(\"Mic Boost (+26dB)\", 0, 0x7d, 3, 1, 0)\n};\n\n\n \n \n\n \nstatic void snd_es1938_chip_init(struct es1938 *chip)\n{\n\t \n\tsnd_es1938_reset(chip);\n\n\t \n\n\t \n\tpci_set_master(chip->pci);\n\n\t \n\tpci_write_config_word(chip->pci, SL_PCI_LEGACYCONTROL, 0x805f);\n\n\t \n\tpci_write_config_word(chip->pci, SL_PCI_DDMACONTROL, chip->ddma_port | 1);\n\n\t \n\tpci_write_config_dword(chip->pci, SL_PCI_CONFIG, 0);\n\n\t \n\toutb(0xf0, SLIO_REG(chip, IRQCONTROL));\n\n\t \n\toutb(0, SLDM_REG(chip, DMACLEAR));\n}\n\n#ifdef CONFIG_PM_SLEEP\n \n\nstatic const unsigned char saved_regs[SAVED_REG_SIZE+1] = {\n\t0x14, 0x1a, 0x1c, 0x3a, 0x3c, 0x3e, 0x36, 0x38,\n\t0x50, 0x52, 0x60, 0x61, 0x62, 0x63, 0x64, 0x68,\n\t0x69, 0x6a, 0x6b, 0x6d, 0x6e, 0x6f, 0x7c, 0x7d,\n\t0xa8, 0xb4,\n};\n\n\nstatic int es1938_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct es1938 *chip = card->private_data;\n\tconst unsigned char *s;\n\tunsigned char *d;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\t \n\tfor (s = saved_regs, d = chip->saved_regs; *s; s++, d++)\n\t\t*d = snd_es1938_reg_read(chip, *s);\n\n\toutb(0x00, SLIO_REG(chip, IRQCONTROL));  \n\tif (chip->irq >= 0) {\n\t\tfree_irq(chip->irq, chip);\n\t\tchip->irq = -1;\n\t\tcard->sync_irq = -1;\n\t}\n\treturn 0;\n}\n\nstatic int es1938_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct es1938 *chip = card->private_data;\n\tconst unsigned char *s;\n\tunsigned char *d;\n\n\tif (request_irq(pci->irq, snd_es1938_interrupt,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(dev, \"unable to grab IRQ %d, disabling device\\n\",\n\t\t\tpci->irq);\n\t\tsnd_card_disconnect(card);\n\t\treturn -EIO;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tsnd_es1938_chip_init(chip);\n\n\t \n\tfor (s = saved_regs, d = chip->saved_regs; *s; s++, d++) {\n\t\tif (*s < 0xa0)\n\t\t\tsnd_es1938_mixer_write(chip, *s, *d);\n\t\telse\n\t\t\tsnd_es1938_write(chip, *s, *d);\n\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(es1938_pm, es1938_suspend, es1938_resume);\n#define ES1938_PM_OPS\t&es1938_pm\n#else\n#define ES1938_PM_OPS\tNULL\n#endif  \n\n#ifdef SUPPORT_JOYSTICK\nstatic int snd_es1938_create_gameport(struct es1938 *chip)\n{\n\tstruct gameport *gp;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"ES1938\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->io = chip->game_port;\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic void snd_es1938_free_gameport(struct es1938 *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_es1938_create_gameport(struct es1938 *chip) { return -ENOSYS; }\nstatic inline void snd_es1938_free_gameport(struct es1938 *chip) { }\n#endif  \n\nstatic void snd_es1938_free(struct snd_card *card)\n{\n\tstruct es1938 *chip = card->private_data;\n\n\t \n\toutb(0x00, SLIO_REG(chip, IRQCONTROL));\n\tif (chip->rmidi)\n\t\tsnd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0);\n\n\tsnd_es1938_free_gameport(chip);\n\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, chip);\n}\n\nstatic int snd_es1938_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci)\n{\n\tstruct es1938 *chip = card->private_data;\n\tint err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n         \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(24))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 24bit PCI busmaster DMA\\n\");\n                return -ENXIO;\n        }\n\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->mixer_lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\terr = pci_request_regions(pci, \"ESS Solo-1\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->io_port = pci_resource_start(pci, 0);\n\tchip->sb_port = pci_resource_start(pci, 1);\n\tchip->vc_port = pci_resource_start(pci, 2);\n\tchip->mpu_port = pci_resource_start(pci, 3);\n\tchip->game_port = pci_resource_start(pci, 4);\n\t \n\tif (request_irq(pci->irq, snd_es1938_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_es1938_free;\n\tdev_dbg(card->dev,\n\t\t\"create: io: 0x%lx, sb: 0x%lx, vc: 0x%lx, mpu: 0x%lx, game: 0x%lx\\n\",\n\t\t   chip->io_port, chip->sb_port, chip->vc_port, chip->mpu_port, chip->game_port);\n\n\tchip->ddma_port = chip->vc_port + 0x00;\t\t \n\n\tsnd_es1938_chip_init(chip);\n\treturn 0;\n}\n\n \nstatic irqreturn_t snd_es1938_interrupt(int irq, void *dev_id)\n{\n\tstruct es1938 *chip = dev_id;\n\tunsigned char status;\n\t__always_unused unsigned char audiostatus;\n\tint handled = 0;\n\n\tstatus = inb(SLIO_REG(chip, IRQCONTROL));\n#if 0\n\tdev_dbg(chip->card->dev,\n\t\t\"Es1938debug - interrupt status: =0x%x\\n\", status);\n#endif\n\t\n\t \n\tif (status & 0x10) {\n#if 0\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 1 interrupt\\n\");\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 1 DMAC DMA count: %u\\n\",\n\t\t       inw(SLDM_REG(chip, DMACOUNT)));\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 1 DMAC DMA base: %u\\n\",\n\t\t       inl(SLDM_REG(chip, DMAADDR)));\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 1 DMAC DMA status: 0x%x\\n\",\n\t\t       inl(SLDM_REG(chip, DMASTATUS)));\n#endif\n\t\t \n\t\thandled = 1;\n\t\taudiostatus = inb(SLSB_REG(chip, STATUS));\n\t\tif (chip->active & ADC1)\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\telse if (chip->active & DAC1)\n\t\t\tsnd_pcm_period_elapsed(chip->playback2_substream);\n\t}\n\t\n\t \n\tif (status & 0x20) {\n#if 0\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 2 interrupt\\n\");\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 2 DMAC DMA count: %u\\n\",\n\t\t       inw(SLIO_REG(chip, AUDIO2DMACOUNT)));\n\t\tdev_dbg(chip->card->dev,\n\t\t       \"Es1938debug - AUDIO channel 2 DMAC DMA base: %u\\n\",\n\t\t       inl(SLIO_REG(chip, AUDIO2DMAADDR)));\n\n#endif\n\t\t \n\t\thandled = 1;\n\t\tsnd_es1938_mixer_bits(chip, ESSSB_IREG_AUDIO2CONTROL2, 0x80, 0);\n\t\tif (chip->active & DAC2)\n\t\t\tsnd_pcm_period_elapsed(chip->playback1_substream);\n\t}\n\n\t \n\tif (status & 0x40) {\n\t\tint split = snd_es1938_mixer_read(chip, 0x64) & 0x80;\n\t\thandled = 1;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_switch->id);\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_volume->id);\n\t\tif (!split) {\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->master_switch->id);\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->master_volume->id);\n\t\t}\n\t\t \n\t\tsnd_es1938_mixer_write(chip, 0x66, 0x00);\n\t}\n\n\t \n\tif (status & 0x80) {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (chip->rmidi) {\n\t\t\thandled = 1;\n\t\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n#define ES1938_DMA_SIZE 64\n\nstatic int snd_es1938_mixer(struct es1938 *chip)\n{\n\tstruct snd_card *card;\n\tunsigned int idx;\n\tint err;\n\n\tcard = chip->card;\n\n\tstrcpy(card->mixername, \"ESS Solo-1\");\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_es1938_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(&snd_es1938_controls[idx], chip);\n\t\tswitch (idx) {\n\t\t\tcase 0:\n\t\t\t\tchip->master_volume = kctl;\n\t\t\t\tkctl->private_free = snd_es1938_hwv_free;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tchip->master_switch = kctl;\n\t\t\t\tkctl->private_free = snd_es1938_hwv_free;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tchip->hw_volume = kctl;\n\t\t\t\tkctl->private_free = snd_es1938_hwv_free;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tchip->hw_switch = kctl;\n\t\t\t\tkctl->private_free = snd_es1938_hwv_free;\n\t\t\t\tbreak;\n\t\t\t}\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n       \n\nstatic int __snd_es1938_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct es1938 *chip;\n\tstruct snd_opl3 *opl3;\n\tint idx, err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tfor (idx = 0; idx < 5; idx++)\n\t\tif (pci_resource_start(pci, idx) == 0 ||\n\t\t    !(pci_resource_flags(pci, idx) & IORESOURCE_IO))\n\t\t\treturn -ENODEV;\n\n\terr = snd_es1938_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"ES1938\");\n\tstrcpy(card->shortname, \"ESS ES1938 (Solo-1)\");\n\tsprintf(card->longname, \"%s rev %i, irq %i\",\n\t\tcard->shortname,\n\t\tchip->revision,\n\t\tchip->irq);\n\n\terr = snd_es1938_new_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_es1938_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\tif (snd_opl3_create(card,\n\t\t\t    SLSB_REG(chip, FMLOWADDR),\n\t\t\t    SLSB_REG(chip, FMHIGHADDR),\n\t\t\t    OPL3_HW_OPL3, 1, &opl3) < 0) {\n\t\tdev_err(card->dev, \"OPL3 not detected at 0x%lx\\n\",\n\t\t\t   SLSB_REG(chip, FMLOWADDR));\n\t} else {\n\t\terr = snd_opl3_timer_new(opl3, 0, 1);\n\t\tif (err < 0)\n\t                return err;\n\t\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\t\tif (err < 0)\n\t                return err;\n\t}\n\tif (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\n\t\t\t\tchip->mpu_port,\n\t\t\t\tMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\n\t\t\t\t-1, &chip->rmidi) < 0) {\n\t\tdev_err(card->dev, \"unable to initialize MPU-401\\n\");\n\t} else {\n\t\t\n\t\t\n\t\tsnd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0x40);\n\t}\n\n\tsnd_es1938_create_gameport(chip);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_es1938_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_es1938_probe(pci, pci_id));\n}\n\nstatic struct pci_driver es1938_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_es1938_ids,\n\t.probe = snd_es1938_probe,\n\t.driver = {\n\t\t.pm = ES1938_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(es1938_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}