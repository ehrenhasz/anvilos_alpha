{
  "module_name": "via82xx.c",
  "hash_id": "00de2bf289668e74c25129acb281b4bb32fe9fe72657453c018a78ba776734c2",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/via82xx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n#include <sound/ac97_codec.h>\n#include <sound/mpu401.h>\n#include <sound/initval.h>\n\n#if 0\n#define POINTER_DEBUG\n#endif\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"VIA VT82xx audio\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic long mpu_port;\n#ifdef SUPPORT_JOYSTICK\nstatic bool joystick;\n#endif\nstatic int ac97_clock = 48000;\nstatic char *ac97_quirk;\nstatic int dxs_support;\nstatic int dxs_init_volume = 31;\nstatic int nodelay;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for VIA 82xx bridge.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for VIA 82xx bridge.\");\nmodule_param_hw(mpu_port, long, ioport, 0444);\nMODULE_PARM_DESC(mpu_port, \"MPU-401 port. (VT82C686x only)\");\n#ifdef SUPPORT_JOYSTICK\nmodule_param(joystick, bool, 0444);\nMODULE_PARM_DESC(joystick, \"Enable joystick. (VT82C686x only)\");\n#endif\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (default 48000Hz).\");\nmodule_param(ac97_quirk, charp, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 workaround for strange hardware.\");\nmodule_param(dxs_support, int, 0444);\nMODULE_PARM_DESC(dxs_support, \"Support for DXS channels (0 = auto, 1 = enable, 2 = disable, 3 = 48k only, 4 = no VRA, 5 = enable any sample rate)\");\nmodule_param(dxs_init_volume, int, 0644);\nMODULE_PARM_DESC(dxs_init_volume, \"initial DXS volume (0-31)\");\nmodule_param(nodelay, int, 0444);\nMODULE_PARM_DESC(nodelay, \"Disable 500ms init delay\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n\n \n#define VIA_REV_686_A\t\t0x10\n#define VIA_REV_686_B\t\t0x11\n#define VIA_REV_686_C\t\t0x12\n#define VIA_REV_686_D\t\t0x13\n#define VIA_REV_686_E\t\t0x14\n#define VIA_REV_686_H\t\t0x20\n\n \n#define VIA_REV_PRE_8233\t0x10\t \n#define VIA_REV_8233C\t\t0x20\t \n#define VIA_REV_8233\t\t0x30\t \n#define VIA_REV_8233A\t\t0x40\t \n#define VIA_REV_8235\t\t0x50\t \n#define VIA_REV_8237\t\t0x60\n#define VIA_REV_8251\t\t0x70\n\n \n\n#define VIAREG(via, x) ((via)->port + VIA_REG_##x)\n#define VIADEV_REG(viadev, x) ((viadev)->port + VIA_REG_##x)\n\n \n#define VIA_REG_OFFSET_STATUS\t\t0x00\t \n#define   VIA_REG_STAT_ACTIVE\t\t0x80\t \n#define   VIA8233_SHADOW_STAT_ACTIVE\t0x08\t \n#define   VIA_REG_STAT_PAUSED\t\t0x40\t \n#define   VIA_REG_STAT_TRIGGER_QUEUED\t0x08\t \n#define   VIA_REG_STAT_STOPPED\t\t0x04\t \n#define   VIA_REG_STAT_EOL\t\t0x02\t \n#define   VIA_REG_STAT_FLAG\t\t0x01\t \n#define VIA_REG_OFFSET_CONTROL\t\t0x01\t \n#define   VIA_REG_CTRL_START\t\t0x80\t \n#define   VIA_REG_CTRL_TERMINATE\t0x40\t \n#define   VIA_REG_CTRL_AUTOSTART\t0x20\n#define   VIA_REG_CTRL_PAUSE\t\t0x08\t \n#define   VIA_REG_CTRL_INT_STOP\t\t0x04\t\t\n#define   VIA_REG_CTRL_INT_EOL\t\t0x02\n#define   VIA_REG_CTRL_INT_FLAG\t\t0x01\n#define   VIA_REG_CTRL_RESET\t\t0x01\t \n#define   VIA_REG_CTRL_INT (VIA_REG_CTRL_INT_FLAG | VIA_REG_CTRL_INT_EOL | VIA_REG_CTRL_AUTOSTART)\n#define VIA_REG_OFFSET_TYPE\t\t0x02\t \n#define   VIA_REG_TYPE_AUTOSTART\t0x80\t \n#define   VIA_REG_TYPE_16BIT\t\t0x20\t \n#define   VIA_REG_TYPE_STEREO\t\t0x10\t \n#define   VIA_REG_TYPE_INT_LLINE\t0x00\n#define   VIA_REG_TYPE_INT_LSAMPLE\t0x04\n#define   VIA_REG_TYPE_INT_LESSONE\t0x08\n#define   VIA_REG_TYPE_INT_MASK\t\t0x0c\n#define   VIA_REG_TYPE_INT_EOL\t\t0x02\n#define   VIA_REG_TYPE_INT_FLAG\t\t0x01\n#define VIA_REG_OFFSET_TABLE_PTR\t0x04\t \n#define VIA_REG_OFFSET_CURR_PTR\t\t0x04\t \n#define VIA_REG_OFFSET_STOP_IDX\t\t0x08\t \n#define   VIA8233_REG_TYPE_16BIT\t0x00200000\t \n#define   VIA8233_REG_TYPE_STEREO\t0x00100000\t \n#define VIA_REG_OFFSET_CURR_COUNT\t0x0c\t \n#define VIA_REG_OFFSET_CURR_INDEX\t0x0f\t \n\n#define DEFINE_VIA_REGSET(name,val) \\\nenum {\\\n\tVIA_REG_##name##_STATUS\t\t= (val),\\\n\tVIA_REG_##name##_CONTROL\t= (val) + 0x01,\\\n\tVIA_REG_##name##_TYPE\t\t= (val) + 0x02,\\\n\tVIA_REG_##name##_TABLE_PTR\t= (val) + 0x04,\\\n\tVIA_REG_##name##_CURR_PTR\t= (val) + 0x04,\\\n\tVIA_REG_##name##_STOP_IDX\t= (val) + 0x08,\\\n\tVIA_REG_##name##_CURR_COUNT\t= (val) + 0x0c,\\\n}\n\n \nDEFINE_VIA_REGSET(PLAYBACK, 0x00);\nDEFINE_VIA_REGSET(CAPTURE, 0x10);\nDEFINE_VIA_REGSET(FM, 0x20);\n\n \n#define VIA_REG_AC97\t\t\t0x80\t \n#define   VIA_REG_AC97_CODEC_ID_MASK\t(3<<30)\n#define   VIA_REG_AC97_CODEC_ID_SHIFT\t30\n#define   VIA_REG_AC97_CODEC_ID_PRIMARY\t0x00\n#define   VIA_REG_AC97_CODEC_ID_SECONDARY 0x01\n#define   VIA_REG_AC97_SECONDARY_VALID\t(1<<27)\n#define   VIA_REG_AC97_PRIMARY_VALID\t(1<<25)\n#define   VIA_REG_AC97_BUSY\t\t(1<<24)\n#define   VIA_REG_AC97_READ\t\t(1<<23)\n#define   VIA_REG_AC97_CMD_SHIFT\t16\n#define   VIA_REG_AC97_CMD_MASK\t\t0x7e\n#define   VIA_REG_AC97_DATA_SHIFT\t0\n#define   VIA_REG_AC97_DATA_MASK\t0xffff\n\n#define VIA_REG_SGD_SHADOW\t\t0x84\t \n \n#define   VIA_REG_SGD_STAT_PB_FLAG\t(1<<0)\n#define   VIA_REG_SGD_STAT_CP_FLAG\t(1<<1)\n#define   VIA_REG_SGD_STAT_FM_FLAG\t(1<<2)\n#define   VIA_REG_SGD_STAT_PB_EOL\t(1<<4)\n#define   VIA_REG_SGD_STAT_CP_EOL\t(1<<5)\n#define   VIA_REG_SGD_STAT_FM_EOL\t(1<<6)\n#define   VIA_REG_SGD_STAT_PB_STOP\t(1<<8)\n#define   VIA_REG_SGD_STAT_CP_STOP\t(1<<9)\n#define   VIA_REG_SGD_STAT_FM_STOP\t(1<<10)\n#define   VIA_REG_SGD_STAT_PB_ACTIVE\t(1<<12)\n#define   VIA_REG_SGD_STAT_CP_ACTIVE\t(1<<13)\n#define   VIA_REG_SGD_STAT_FM_ACTIVE\t(1<<14)\n \n#define   VIA8233_REG_SGD_STAT_FLAG\t(1<<0)\n#define   VIA8233_REG_SGD_STAT_EOL\t(1<<1)\n#define   VIA8233_REG_SGD_STAT_STOP\t(1<<2)\n#define   VIA8233_REG_SGD_STAT_ACTIVE\t(1<<3)\n#define VIA8233_INTR_MASK(chan) ((VIA8233_REG_SGD_STAT_FLAG|VIA8233_REG_SGD_STAT_EOL) << ((chan) * 4))\n#define   VIA8233_REG_SGD_CHAN_SDX\t0\n#define   VIA8233_REG_SGD_CHAN_MULTI\t4\n#define   VIA8233_REG_SGD_CHAN_REC\t6\n#define   VIA8233_REG_SGD_CHAN_REC1\t7\n\n#define VIA_REG_GPI_STATUS\t\t0x88\n#define VIA_REG_GPI_INTR\t\t0x8c\n\n \nDEFINE_VIA_REGSET(MULTPLAY, 0x40);\nDEFINE_VIA_REGSET(CAPTURE_8233, 0x60);\n\n \n#define VIA_REG_OFS_PLAYBACK_VOLUME_L\t0x02\t \n#define VIA_REG_OFS_PLAYBACK_VOLUME_R\t0x03\t \n#define VIA_REG_OFS_MULTPLAY_FORMAT\t0x02\t \n#define   VIA_REG_MULTPLAY_FMT_8BIT\t0x00\n#define   VIA_REG_MULTPLAY_FMT_16BIT\t0x80\n#define   VIA_REG_MULTPLAY_FMT_CH_MASK\t0x70\t \n#define VIA_REG_OFS_CAPTURE_FIFO\t0x02\t \n#define   VIA_REG_CAPTURE_FIFO_ENABLE\t0x40\n\n#define VIA_DXS_MAX_VOLUME\t\t31\t \n\n#define VIA_REG_CAPTURE_CHANNEL\t\t0x63\t \n#define   VIA_REG_CAPTURE_CHANNEL_MIC\t0x4\n#define   VIA_REG_CAPTURE_CHANNEL_LINE\t0\n#define   VIA_REG_CAPTURE_SELECT_CODEC\t0x03\t \n\n#define VIA_TBL_BIT_FLAG\t0x40000000\n#define VIA_TBL_BIT_EOL\t\t0x80000000\n\n \n#define VIA_ACLINK_STAT\t\t0x40\n#define  VIA_ACLINK_C11_READY\t0x20\n#define  VIA_ACLINK_C10_READY\t0x10\n#define  VIA_ACLINK_C01_READY\t0x04  \n#define  VIA_ACLINK_LOWPOWER\t0x02  \n#define  VIA_ACLINK_C00_READY\t0x01  \n#define VIA_ACLINK_CTRL\t\t0x41\n#define  VIA_ACLINK_CTRL_ENABLE\t0x80  \n#define  VIA_ACLINK_CTRL_RESET\t0x40  \n#define  VIA_ACLINK_CTRL_SYNC\t0x20  \n#define  VIA_ACLINK_CTRL_SDO\t0x10  \n#define  VIA_ACLINK_CTRL_VRA\t0x08  \n#define  VIA_ACLINK_CTRL_PCM\t0x04  \n#define  VIA_ACLINK_CTRL_FM\t0x02  \n#define  VIA_ACLINK_CTRL_SB\t0x01  \n#define  VIA_ACLINK_CTRL_INIT\t(VIA_ACLINK_CTRL_ENABLE|\\\n\t\t\t\t VIA_ACLINK_CTRL_RESET|\\\n\t\t\t\t VIA_ACLINK_CTRL_PCM|\\\n\t\t\t\t VIA_ACLINK_CTRL_VRA)\n#define VIA_FUNC_ENABLE\t\t0x42\n#define  VIA_FUNC_MIDI_PNP\t0x80  \n#define  VIA_FUNC_MIDI_IRQMASK\t0x40  \n#define  VIA_FUNC_RX2C_WRITE\t0x20\n#define  VIA_FUNC_SB_FIFO_EMPTY\t0x10\n#define  VIA_FUNC_ENABLE_GAME\t0x08\n#define  VIA_FUNC_ENABLE_FM\t0x04\n#define  VIA_FUNC_ENABLE_MIDI\t0x02\n#define  VIA_FUNC_ENABLE_SB\t0x01\n#define VIA_PNP_CONTROL\t\t0x43\n#define VIA_FM_NMI_CTRL\t\t0x48\n#define VIA8233_VOLCHG_CTRL\t0x48\n#define VIA8233_SPDIF_CTRL\t0x49\n#define  VIA8233_SPDIF_DX3\t0x08\n#define  VIA8233_SPDIF_SLOT_MASK\t0x03\n#define  VIA8233_SPDIF_SLOT_1011\t0x00\n#define  VIA8233_SPDIF_SLOT_34\t\t0x01\n#define  VIA8233_SPDIF_SLOT_78\t\t0x02\n#define  VIA8233_SPDIF_SLOT_69\t\t0x03\n\n \n\n#define VIA_DXS_AUTO\t0\n#define VIA_DXS_ENABLE\t1\n#define VIA_DXS_DISABLE\t2\n#define VIA_DXS_48K\t3\n#define VIA_DXS_NO_VRA\t4\n#define VIA_DXS_SRC\t5\n\n\n \n\nstruct snd_via_sg_table {\n\tunsigned int offset;\n\tunsigned int size;\n} ;\n\n#define VIA_TABLE_SIZE\t255\n#define VIA_MAX_BUFSIZE\t(1<<24)\n\nstruct viadev {\n\tunsigned int reg_offset;\n\tunsigned long port;\n\tint direction;\t \n        struct snd_pcm_substream *substream;\n\tint running;\n\tunsigned int tbl_entries;  \n\tstruct snd_dma_buffer table;\n\tstruct snd_via_sg_table *idx_table;\n\t \n\tunsigned int lastpos;\n\tunsigned int fragsize;\n\tunsigned int bufsize;\n\tunsigned int bufsize2;\n\tint hwptr_done;\t\t \n\tint in_interrupt;\n\tint shadow_shift;\n};\n\n\nenum { TYPE_CARD_VIA686 = 1, TYPE_CARD_VIA8233 };\nenum { TYPE_VIA686, TYPE_VIA8233, TYPE_VIA8233A };\n\n#define VIA_MAX_DEVS\t7\t \n\nstruct via_rate_lock {\n\tspinlock_t lock;\n\tint rate;\n\tint used;\n};\n\nstruct via82xx {\n\tint irq;\n\n\tunsigned long port;\n\tstruct resource *mpu_res;\n\tint chip_type;\n\tunsigned char revision;\n\n\tunsigned char old_legacy;\n\tunsigned char old_legacy_cfg;\n#ifdef CONFIG_PM_SLEEP\n\tunsigned char legacy_saved;\n\tunsigned char legacy_cfg_saved;\n\tunsigned char spdif_ctrl_saved;\n\tunsigned char capture_src_saved[2];\n\tunsigned int mpu_port_saved;\n#endif\n\n\tunsigned char playback_volume[4][2];  \n\tunsigned char playback_volume_c[2];  \n\n\tunsigned int intr_mask;  \n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\n\tunsigned int num_devs;\n\tunsigned int playback_devno, multi_devno, capture_devno;\n\tstruct viadev devs[VIA_MAX_DEVS];\n\tstruct via_rate_lock rates[2];  \n\tunsigned int dxs_fixed: 1;\t \n\tunsigned int no_vra: 1;\t\t \n\tunsigned int dxs_src: 1;\t \n\tunsigned int spdif_on: 1;\t \n\n\tstruct snd_pcm *pcms[2];\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_kcontrol *dxs_controls[4];\n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\tunsigned int ac97_clock;\n\tunsigned int ac97_secondary;\t \n\n\tspinlock_t reg_lock;\n\tstruct snd_info_entry *proc_entry;\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n};\n\nstatic const struct pci_device_id snd_via82xx_ids[] = {\n\t \n\t{ PCI_VDEVICE(VIA, PCI_DEVICE_ID_VIA_82C686_5), TYPE_CARD_VIA686, },\t \n\t \n\t{ PCI_VDEVICE(VIA, PCI_DEVICE_ID_VIA_8233_5), TYPE_CARD_VIA8233, },\t \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_via82xx_ids);\n\n \n\n \nstatic int build_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\n\t\t\t   struct pci_dev *pci,\n\t\t\t   unsigned int periods, unsigned int fragsize)\n{\n\tunsigned int i, idx, ofs, rest;\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\t__le32 *pgtbl;\n\n\tif (dev->table.area == NULL) {\n\t\t \n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t\tPAGE_ALIGN(VIA_TABLE_SIZE * 2 * 8),\n\t\t\t\t\t&dev->table) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (! dev->idx_table) {\n\t\tdev->idx_table = kmalloc_array(VIA_TABLE_SIZE,\n\t\t\t\t\t       sizeof(*dev->idx_table),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (! dev->idx_table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tidx = 0;\n\tofs = 0;\n\tpgtbl = (__le32 *)dev->table.area;\n\tfor (i = 0; i < periods; i++) {\n\t\trest = fragsize;\n\t\t \n\t\tdo {\n\t\t\tunsigned int r;\n\t\t\tunsigned int flag;\n\t\t\tunsigned int addr;\n\n\t\t\tif (idx >= VIA_TABLE_SIZE) {\n\t\t\t\tdev_err(&pci->dev, \"too much table size!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\taddr = snd_pcm_sgbuf_get_addr(substream, ofs);\n\t\t\tpgtbl[idx << 1] = cpu_to_le32(addr);\n\t\t\tr = snd_pcm_sgbuf_get_chunk_size(substream, ofs, rest);\n\t\t\trest -= r;\n\t\t\tif (! rest) {\n\t\t\t\tif (i == periods - 1)\n\t\t\t\t\tflag = VIA_TBL_BIT_EOL;  \n\t\t\t\telse\n\t\t\t\t\tflag = VIA_TBL_BIT_FLAG;  \n\t\t\t} else\n\t\t\t\tflag = 0;  \n\t\t\t \n\t\t\tpgtbl[(idx<<1) + 1] = cpu_to_le32(r | flag);\n\t\t\tdev->idx_table[idx].offset = ofs;\n\t\t\tdev->idx_table[idx].size = r;\n\t\t\tofs += r;\n\t\t\tidx++;\n\t\t} while (rest > 0);\n\t}\n\tdev->tbl_entries = idx;\n\tdev->bufsize = periods * fragsize;\n\tdev->bufsize2 = dev->bufsize / 2;\n\tdev->fragsize = fragsize;\n\treturn 0;\n}\n\n\nstatic int clean_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\n\t\t\t   struct pci_dev *pci)\n{\n\tif (dev->table.area) {\n\t\tsnd_dma_free_pages(&dev->table);\n\t\tdev->table.area = NULL;\n\t}\n\tkfree(dev->idx_table);\n\tdev->idx_table = NULL;\n\treturn 0;\n}\n\n \n\nstatic inline unsigned int snd_via82xx_codec_xread(struct via82xx *chip)\n{\n\treturn inl(VIAREG(chip, AC97));\n}\n \nstatic inline void snd_via82xx_codec_xwrite(struct via82xx *chip, unsigned int val)\n{\n\toutl(val, VIAREG(chip, AC97));\n}\n \nstatic int snd_via82xx_codec_ready(struct via82xx *chip, int secondary)\n{\n\tunsigned int timeout = 1000;\t \n\tunsigned int val;\n\t\n\twhile (timeout-- > 0) {\n\t\tudelay(1);\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tif (!(val & VIA_REG_AC97_BUSY))\n\t\t\treturn val & 0xffff;\n\t}\n\tdev_err(chip->card->dev, \"codec_ready: codec %i is not ready [0x%x]\\n\",\n\t\t   secondary, snd_via82xx_codec_xread(chip));\n\treturn -EIO;\n}\n \nstatic int snd_via82xx_codec_valid(struct via82xx *chip, int secondary)\n{\n\tunsigned int timeout = 1000;\t \n\tunsigned int val, val1;\n\tunsigned int stat = !secondary ? VIA_REG_AC97_PRIMARY_VALID :\n\t\t\t\t\t VIA_REG_AC97_SECONDARY_VALID;\n\t\n\twhile (timeout-- > 0) {\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tval1 = val & (VIA_REG_AC97_BUSY | stat);\n\t\tif (val1 == stat)\n\t\t\treturn val & 0xffff;\n\t\tudelay(1);\n\t}\n\treturn -EIO;\n}\n \nstatic void snd_via82xx_codec_wait(struct snd_ac97 *ac97)\n{\n\tstruct via82xx *chip = ac97->private_data;\n\t__always_unused int err;\n\terr = snd_via82xx_codec_ready(chip, ac97->num);\n\t \n\tif (!nodelay)\n\t\tmsleep(500);\n}\n\nstatic void snd_via82xx_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t    unsigned short reg,\n\t\t\t\t    unsigned short val)\n{\n\tstruct via82xx *chip = ac97->private_data;\n\tunsigned int xval;\n\n\txval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;\n\txval <<= VIA_REG_AC97_CODEC_ID_SHIFT;\n\txval |= reg << VIA_REG_AC97_CMD_SHIFT;\n\txval |= val << VIA_REG_AC97_DATA_SHIFT;\n\tsnd_via82xx_codec_xwrite(chip, xval);\n\tsnd_via82xx_codec_ready(chip, ac97->num);\n}\n\nstatic unsigned short snd_via82xx_codec_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct via82xx *chip = ac97->private_data;\n\tunsigned int xval, val = 0xffff;\n\tint again = 0;\n\n\txval = ac97->num << VIA_REG_AC97_CODEC_ID_SHIFT;\n\txval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;\n\txval |= VIA_REG_AC97_READ;\n\txval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;\n      \twhile (1) {\n      \t\tif (again++ > 3) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_read: codec %i is not valid [0x%x]\\n\",\n\t\t\t\t   ac97->num, snd_via82xx_codec_xread(chip));\n\t\t      \treturn 0xffff;\n\t\t}\n\t\tsnd_via82xx_codec_xwrite(chip, xval);\n\t\tudelay (20);\n\t\tif (snd_via82xx_codec_valid(chip, ac97->num) >= 0) {\n\t\t\tudelay(25);\n\t\t\tval = snd_via82xx_codec_xread(chip);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn val & 0xffff;\n}\n\nstatic void snd_via82xx_channel_reset(struct via82xx *chip, struct viadev *viadev)\n{\n\toutb(VIA_REG_CTRL_PAUSE | VIA_REG_CTRL_TERMINATE | VIA_REG_CTRL_RESET,\n\t     VIADEV_REG(viadev, OFFSET_CONTROL));\n\tinb(VIADEV_REG(viadev, OFFSET_CONTROL));\n\tudelay(50);\n\t \n\toutb(0x00, VIADEV_REG(viadev, OFFSET_CONTROL));\n\t \n\toutb(0x03, VIADEV_REG(viadev, OFFSET_STATUS));\n\toutb(0x00, VIADEV_REG(viadev, OFFSET_TYPE));  \n\t\n\tviadev->lastpos = 0;\n\tviadev->hwptr_done = 0;\n}\n\n\n \nstatic irqreturn_t snd_via686_interrupt(int irq, void *dev_id)\n{\n\tstruct via82xx *chip = dev_id;\n\tunsigned int status;\n\tunsigned int i;\n\n\tstatus = inl(VIAREG(chip, SGD_SHADOW));\n\tif (! (status & chip->intr_mask)) {\n\t\tif (chip->rmidi)\n\t\t\t \n\t\t\treturn snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tspin_lock(&chip->reg_lock);\n\tfor (i = 0; i < chip->num_devs; i++) {\n\t\tstruct viadev *viadev = &chip->devs[i];\n\t\tunsigned char c_status = inb(VIADEV_REG(viadev, OFFSET_STATUS));\n\t\tif (! (c_status & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG|VIA_REG_STAT_STOPPED)))\n\t\t\tcontinue;\n\t\tif (viadev->substream && viadev->running) {\n\t\t\t \n\t\t\tif (c_status & VIA_REG_STAT_EOL)\n\t\t\t\tviadev->hwptr_done = 0;\n\t\t\telse\n\t\t\t\tviadev->hwptr_done += viadev->fragsize;\n\t\t\tviadev->in_interrupt = c_status;\n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(viadev->substream);\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t\tviadev->in_interrupt = 0;\n\t\t}\n\t\toutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));  \n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t snd_via8233_interrupt(int irq, void *dev_id)\n{\n\tstruct via82xx *chip = dev_id;\n\tunsigned int status;\n\tunsigned int i;\n\tint irqreturn = 0;\n\n\t \n\tspin_lock(&chip->reg_lock);\n\tstatus = inl(VIAREG(chip, SGD_SHADOW));\n\n\tfor (i = 0; i < chip->num_devs; i++) {\n\t\tstruct viadev *viadev = &chip->devs[i];\n\t\tstruct snd_pcm_substream *substream;\n\t\tunsigned char c_status, shadow_status;\n\n\t\tshadow_status = (status >> viadev->shadow_shift) &\n\t\t\t(VIA8233_SHADOW_STAT_ACTIVE|VIA_REG_STAT_EOL|\n\t\t\t VIA_REG_STAT_FLAG);\n\t\tc_status = shadow_status & (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG);\n\t\tif (!c_status)\n\t\t\tcontinue;\n\n\t\tsubstream = viadev->substream;\n\t\tif (substream && viadev->running) {\n\t\t\t \n\t\t\tif (c_status & VIA_REG_STAT_EOL)\n\t\t\t\tviadev->hwptr_done = 0;\n\t\t\telse\n\t\t\t\tviadev->hwptr_done += viadev->fragsize;\n\t\t\tviadev->in_interrupt = c_status;\n\t\t\tif (shadow_status & VIA8233_SHADOW_STAT_ACTIVE)\n\t\t\t\tviadev->in_interrupt |= VIA_REG_STAT_ACTIVE;\n\t\t\tspin_unlock(&chip->reg_lock);\n\n\t\t\tsnd_pcm_period_elapsed(substream);\n\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t\tviadev->in_interrupt = 0;\n\t\t}\n\t\toutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));  \n\t\tirqreturn = 1;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_RETVAL(irqreturn);\n}\n\n \n\n \nstatic int snd_via82xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned char val;\n\n\tif (chip->chip_type != TYPE_VIA686)\n\t\tval = VIA_REG_CTRL_INT;\n\telse\n\t\tval = 0;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tval |= VIA_REG_CTRL_START;\n\t\tviadev->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval = VIA_REG_CTRL_TERMINATE;\n\t\tviadev->running = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval |= VIA_REG_CTRL_PAUSE;\n\t\tviadev->running = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tviadev->running = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\toutb(val, VIADEV_REG(viadev, OFFSET_CONTROL));\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP)\n\t\tsnd_via82xx_channel_reset(chip, viadev);\n\treturn 0;\n}\n\n\n \n\n \n\n#define check_invalid_pos(viadev,pos) \\\n\t((pos) < viadev->lastpos && ((pos) >= viadev->bufsize2 ||\\\n\t\t\t\t     viadev->lastpos < viadev->bufsize2))\n\nstatic inline unsigned int calc_linear_pos(struct via82xx *chip,\n\t\t\t\t\t   struct viadev *viadev,\n\t\t\t\t\t   unsigned int idx,\n\t\t\t\t\t   unsigned int count)\n{\n\tunsigned int size, base, res;\n\n\tsize = viadev->idx_table[idx].size;\n\tbase = viadev->idx_table[idx].offset;\n\tres = base + size - count;\n\tif (res >= viadev->bufsize)\n\t\tres -= viadev->bufsize;\n\n\t \n\tif (size < count) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"invalid via82xx_cur_ptr (size = %d, count = %d)\\n\",\n\t\t\t   (int)size, (int)count);\n\t\tres = viadev->lastpos;\n\t} else {\n\t\tif (! count) {\n\t\t\t \n\t\t\tint delta = res - viadev->lastpos;\n\t\t\tif (delta < 0)\n\t\t\t\tdelta += viadev->bufsize;\n\t\t\tif ((unsigned int)delta > viadev->fragsize)\n\t\t\t\tres = base;\n\t\t}\n\t\tif (check_invalid_pos(viadev, res)) {\n#ifdef POINTER_DEBUG\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\\n\",\n\t\t\t\tidx, viadev->tbl_entries,\n\t\t\t       viadev->lastpos, viadev->bufsize2,\n\t\t\t       viadev->idx_table[idx].offset,\n\t\t\t       viadev->idx_table[idx].size, count);\n#endif\n\t\t\t \n\t\t\tres = base + size;\n\t\t\tif (check_invalid_pos(viadev, res)) {\n\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\"invalid via82xx_cur_ptr (2), using last valid pointer\\n\");\n\t\t\t\tres = viadev->lastpos;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n \nstatic snd_pcm_uframes_t snd_via686_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned int idx, ptr, count, res;\n\n\tif (snd_BUG_ON(!viadev->tbl_entries))\n\t\treturn 0;\n\tif (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))\n\t\treturn 0;\n\n\tspin_lock(&chip->reg_lock);\n\tcount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT)) & 0xffffff;\n\t \n\tptr = inl(VIADEV_REG(viadev, OFFSET_CURR_PTR));\n\tif (ptr <= (unsigned int)viadev->table.addr)\n\t\tidx = 0;\n\telse  \n\t\tidx = ((ptr - (unsigned int)viadev->table.addr) / 8 - 1) % viadev->tbl_entries;\n\tres = calc_linear_pos(chip, viadev, idx, count);\n\tviadev->lastpos = res;  \n\tspin_unlock(&chip->reg_lock);\n\n\treturn bytes_to_frames(substream->runtime, res);\n}\n\n \nstatic snd_pcm_uframes_t snd_via8233_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned int idx, count, res;\n\tint status;\n\t\n\tif (snd_BUG_ON(!viadev->tbl_entries))\n\t\treturn 0;\n\n\tspin_lock(&chip->reg_lock);\n\tcount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT));\n\tstatus = viadev->in_interrupt;\n\tif (!status)\n\t\tstatus = inb(VIADEV_REG(viadev, OFFSET_STATUS));\n\n\t \n\tif (chip->revision == VIA_REV_8251 && (status & VIA_REG_STAT_EOL))\n\t\tsnd_via82xx_pcm_trigger(substream, SNDRV_PCM_TRIGGER_START);\n\n\tif (!(status & VIA_REG_STAT_ACTIVE)) {\n\t\tres = 0;\n\t\tgoto unlock;\n\t}\n\tif (count & 0xffffff) {\n\t\tidx = count >> 24;\n\t\tif (idx >= viadev->tbl_entries) {\n#ifdef POINTER_DEBUG\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"fail: invalid idx = %i/%i\\n\", idx,\n\t\t\t       viadev->tbl_entries);\n#endif\n\t\t\tres = viadev->lastpos;\n\t\t} else {\n\t\t\tcount &= 0xffffff;\n\t\t\tres = calc_linear_pos(chip, viadev, idx, count);\n\t\t}\n\t} else {\n\t\tres = viadev->hwptr_done;\n\t\tif (!viadev->in_interrupt) {\n\t\t\tif (status & VIA_REG_STAT_EOL) {\n\t\t\t\tres = 0;\n\t\t\t} else\n\t\t\t\tif (status & VIA_REG_STAT_FLAG) {\n\t\t\t\t\tres += viadev->fragsize;\n\t\t\t\t}\n\t\t}\n\t}\t\t\t    \nunlock:\n\tviadev->lastpos = res;\n\tspin_unlock(&chip->reg_lock);\n\n\treturn bytes_to_frames(substream->runtime, res);\n}\n\n\n \nstatic int snd_via82xx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\n\treturn build_via_table(viadev, substream, chip->pci,\n\t\t\t       params_periods(hw_params),\n\t\t\t       params_period_bytes(hw_params));\n}\n\n \nstatic int snd_via82xx_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\n\tclean_via_table(viadev, substream, chip->pci);\n\treturn 0;\n}\n\n\n \nstatic void snd_via82xx_set_table_ptr(struct via82xx *chip, struct viadev *viadev)\n{\n\tsnd_via82xx_codec_ready(chip, 0);\n\toutl((u32)viadev->table.addr, VIADEV_REG(viadev, OFFSET_TABLE_PTR));\n\tudelay(20);\n\tsnd_via82xx_codec_ready(chip, 0);\n}\n\n \nstatic void via686_setup_format(struct via82xx *chip, struct viadev *viadev,\n\t\t\t\tstruct snd_pcm_runtime *runtime)\n{\n\tsnd_via82xx_channel_reset(chip, viadev);\n\t \n\tsnd_via82xx_set_table_ptr(chip, viadev);\n\toutb(VIA_REG_TYPE_AUTOSTART |\n\t     (runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA_REG_TYPE_16BIT : 0) |\n\t     (runtime->channels > 1 ? VIA_REG_TYPE_STEREO : 0) |\n\t     ((viadev->reg_offset & 0x10) == 0 ? VIA_REG_TYPE_INT_LSAMPLE : 0) |\n\t     VIA_REG_TYPE_INT_EOL |\n\t     VIA_REG_TYPE_INT_FLAG, VIADEV_REG(viadev, OFFSET_TYPE));\n}\n\nstatic int snd_via686_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);\n\tsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\n\tvia686_setup_format(chip, viadev, runtime);\n\treturn 0;\n}\n\nstatic int snd_via686_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\n\tvia686_setup_format(chip, viadev, runtime);\n\treturn 0;\n}\n\n \nstatic int via_lock_rate(struct via_rate_lock *rec, int rate)\n{\n\tint changed = 0;\n\n\tspin_lock_irq(&rec->lock);\n\tif (rec->rate != rate) {\n\t\tif (rec->rate && rec->used > 1)  \n\t\t\tchanged = -EINVAL;\n\t\telse {\n\t\t\trec->rate = rate;\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tspin_unlock_irq(&rec->lock);\n\treturn changed;\n}\n\n \nstatic int snd_via8233_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint ac97_rate = chip->dxs_src ? 48000 : runtime->rate;\n\tint rate_changed;\n\tu32 rbits;\n\n\trate_changed = via_lock_rate(&chip->rates[0], ac97_rate);\n\tif (rate_changed < 0)\n\t\treturn rate_changed;\n\tif (rate_changed)\n\t\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,\n\t\t\t\t  chip->no_vra ? 48000 : runtime->rate);\n\tif (chip->spdif_on && viadev->reg_offset == 0x30)\n\t\tsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\n\n\tif (runtime->rate == 48000)\n\t\trbits = 0xfffff;\n\telse\n\t\trbits = (0x100000 / 48000) * runtime->rate +\n\t\t\t((0x100000 % 48000) * runtime->rate) / 48000;\n\tsnd_BUG_ON(rbits & ~0xfffff);\n\tsnd_via82xx_channel_reset(chip, viadev);\n\tsnd_via82xx_set_table_ptr(chip, viadev);\n\toutb(chip->playback_volume[viadev->reg_offset / 0x10][0],\n\t     VIADEV_REG(viadev, OFS_PLAYBACK_VOLUME_L));\n\toutb(chip->playback_volume[viadev->reg_offset / 0x10][1],\n\t     VIADEV_REG(viadev, OFS_PLAYBACK_VOLUME_R));\n\toutl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA8233_REG_TYPE_16BIT : 0) |  \n\t     (runtime->channels > 1 ? VIA8233_REG_TYPE_STEREO : 0) |  \n\t     rbits |  \n\t     0xff000000,     \n\t     VIADEV_REG(viadev, OFFSET_STOP_IDX));\n\tudelay(20);\n\tsnd_via82xx_codec_ready(chip, 0);\n\treturn 0;\n}\n\n \nstatic int snd_via8233_multi_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int slots;\n\tint fmt;\n\n\tif (via_lock_rate(&chip->rates[0], runtime->rate) < 0)\n\t\treturn -EINVAL;\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_SURR_DAC_RATE, runtime->rate);\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_LFE_DAC_RATE, runtime->rate);\n\tsnd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);\n\tsnd_via82xx_channel_reset(chip, viadev);\n\tsnd_via82xx_set_table_ptr(chip, viadev);\n\n\tfmt = (runtime->format == SNDRV_PCM_FORMAT_S16_LE) ?\n\t\tVIA_REG_MULTPLAY_FMT_16BIT : VIA_REG_MULTPLAY_FMT_8BIT;\n\tfmt |= runtime->channels << 4;\n\toutb(fmt, VIADEV_REG(viadev, OFS_MULTPLAY_FORMAT));\n#if 0\n\tif (chip->revision == VIA_REV_8233A)\n\t\tslots = 0;\n\telse\n#endif\n\t{\n\t\t \n\t\t \n\t\tswitch (runtime->channels) {\n\t\tcase 1: slots = (1<<0) | (1<<4); break;\n\t\tcase 2: slots = (1<<0) | (2<<4); break;\n\t\tcase 3: slots = (1<<0) | (2<<4) | (5<<8); break;\n\t\tcase 4: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12); break;\n\t\tcase 5: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12) | (5<<16); break;\n\t\tcase 6: slots = (1<<0) | (2<<4) | (3<<8) | (4<<12) | (5<<16) | (6<<20); break;\n\t\tdefault: slots = 0; break;\n\t\t}\n\t}\n\t \n\toutl(0xff000000 | slots, VIADEV_REG(viadev, OFFSET_STOP_IDX));\n\tudelay(20);\n\tsnd_via82xx_codec_ready(chip, 0);\n\treturn 0;\n}\n\n \nstatic int snd_via8233_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (via_lock_rate(&chip->rates[1], runtime->rate) < 0)\n\t\treturn -EINVAL;\n\tsnd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\n\tsnd_via82xx_channel_reset(chip, viadev);\n\tsnd_via82xx_set_table_ptr(chip, viadev);\n\toutb(VIA_REG_CAPTURE_FIFO_ENABLE, VIADEV_REG(viadev, OFS_CAPTURE_FIFO));\n\toutl((runtime->format == SNDRV_PCM_FORMAT_S16_LE ? VIA8233_REG_TYPE_16BIT : 0) |\n\t     (runtime->channels > 1 ? VIA8233_REG_TYPE_STEREO : 0) |\n\t     0xff000000,     \n\t     VIADEV_REG(viadev, OFFSET_STOP_IDX));\n\tudelay(20);\n\tsnd_via82xx_codec_ready(chip, 0);\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_hardware snd_via82xx_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\tVIA_MAX_BUFSIZE,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\tVIA_MAX_BUFSIZE / 2,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tVIA_TABLE_SIZE / 2,\n\t.fifo_size =\t\t0,\n};\n\n\n \nstatic int snd_via82xx_pcm_open(struct via82xx *chip, struct viadev *viadev,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tstruct via_rate_lock *ratep;\n\tbool use_src = false;\n\n\truntime->hw = snd_via82xx_hw;\n\t\n\t \n\tratep = &chip->rates[viadev->direction];\n\tspin_lock_irq(&ratep->lock);\n\tratep->used++;\n\tif (chip->spdif_on && viadev->reg_offset == 0x30) {\n\t\t \n\t\truntime->hw.rates = chip->ac97->rates[AC97_RATES_SPDIF];\n\t\tsnd_pcm_limit_hw_rates(runtime);\n\t} else if (chip->dxs_fixed && viadev->reg_offset < 0x40) {\n\t\t \n\t\truntime->hw.rates = SNDRV_PCM_RATE_48000;\n\t\truntime->hw.rate_min = runtime->hw.rate_max = 48000;\n\t} else if (chip->dxs_src && viadev->reg_offset < 0x40) {\n\t\t \n\t\truntime->hw.rates = (SNDRV_PCM_RATE_CONTINUOUS |\n\t\t\t\t     SNDRV_PCM_RATE_8000_48000);\n\t\truntime->hw.rate_min = 8000;\n\t\truntime->hw.rate_max = 48000;\n\t\tuse_src = true;\n\t} else if (! ratep->rate) {\n\t\tint idx = viadev->direction ? AC97_RATES_ADC : AC97_RATES_FRONT_DAC;\n\t\truntime->hw.rates = chip->ac97->rates[idx];\n\t\tsnd_pcm_limit_hw_rates(runtime);\n\t} else {\n\t\t \n\t\truntime->hw.rates = SNDRV_PCM_RATE_KNOT;\n\t\truntime->hw.rate_max = runtime->hw.rate_min = ratep->rate;\n\t}\n\tspin_unlock_irq(&ratep->lock);\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (use_src) {\n\t\terr = snd_pcm_hw_rule_noresample(runtime, 48000);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\truntime->private_data = viadev;\n\tviadev->substream = substream;\n\n\treturn 0;\n}\n\n\n \nstatic int snd_via686_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];\n\tint err;\n\n\terr = snd_via82xx_pcm_open(chip, viadev, substream);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n \nstatic int snd_via8233_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev;\n\tunsigned int stream;\n\tint err;\n\n\tviadev = &chip->devs[chip->playback_devno + substream->number];\n\terr = snd_via82xx_pcm_open(chip, viadev, substream);\n\tif (err < 0)\n\t\treturn err;\n\tstream = viadev->reg_offset / 0x10;\n\tif (chip->dxs_controls[stream]) {\n\t\tchip->playback_volume[stream][0] =\n\t\t\t\tVIA_DXS_MAX_VOLUME - (dxs_init_volume & 31);\n\t\tchip->playback_volume[stream][1] =\n\t\t\t\tVIA_DXS_MAX_VOLUME - (dxs_init_volume & 31);\n\t\tchip->dxs_controls[stream]->vd[0].access &=\n\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &chip->dxs_controls[stream]->id);\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_via8233_multi_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = &chip->devs[chip->multi_devno];\n\tint err;\n\t \n\tstatic const unsigned int channels[] = {\n\t\t1, 2, 4, 6\n\t};\n\tstatic const struct snd_pcm_hw_constraint_list hw_constraints_channels = {\n\t\t.count = ARRAY_SIZE(channels),\n\t\t.list = channels,\n\t\t.mask = 0,\n\t};\n\n\terr = snd_via82xx_pcm_open(chip, viadev, substream);\n\tif (err < 0)\n\t\treturn err;\n\tsubstream->runtime->hw.channels_max = 6;\n\tif (chip->revision == VIA_REV_8233A)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   &hw_constraints_channels);\n\treturn 0;\n}\n\n \nstatic int snd_via82xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];\n\n\treturn snd_via82xx_pcm_open(chip, viadev, substream);\n}\n\n \nstatic int snd_via82xx_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tstruct via_rate_lock *ratep;\n\n\t \n\tratep = &chip->rates[viadev->direction];\n\tspin_lock_irq(&ratep->lock);\n\tratep->used--;\n\tif (! ratep->used)\n\t\tratep->rate = 0;\n\tspin_unlock_irq(&ratep->lock);\n\tif (! ratep->rate) {\n\t\tif (! viadev->direction) {\n\t\t\tsnd_ac97_update_power(chip->ac97,\n\t\t\t\t\t      AC97_PCM_FRONT_DAC_RATE, 0);\n\t\t\tsnd_ac97_update_power(chip->ac97,\n\t\t\t\t\t      AC97_PCM_SURR_DAC_RATE, 0);\n\t\t\tsnd_ac97_update_power(chip->ac97,\n\t\t\t\t\t      AC97_PCM_LFE_DAC_RATE, 0);\n\t\t} else\n\t\t\tsnd_ac97_update_power(chip->ac97,\n\t\t\t\t\t      AC97_PCM_LR_ADC_RATE, 0);\n\t}\n\tviadev->substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_via8233_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned int stream;\n\n\tstream = viadev->reg_offset / 0x10;\n\tif (chip->dxs_controls[stream]) {\n\t\tchip->dxs_controls[stream]->vd[0].access |=\n\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &chip->dxs_controls[stream]->id);\n\t}\n\treturn snd_via82xx_pcm_close(substream);\n}\n\n\n \nstatic const struct snd_pcm_ops snd_via686_playback_ops = {\n\t.open =\t\tsnd_via686_playback_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via686_playback_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via686_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_via686_capture_ops = {\n\t.open =\t\tsnd_via82xx_capture_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via686_capture_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via686_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_via8233_playback_ops = {\n\t.open =\t\tsnd_via8233_playback_open,\n\t.close =\tsnd_via8233_playback_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via8233_playback_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via8233_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_via8233_multi_ops = {\n\t.open =\t\tsnd_via8233_multi_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via8233_multi_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via8233_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_via8233_capture_ops = {\n\t.open =\t\tsnd_via82xx_capture_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via8233_capture_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via8233_pcm_pointer,\n};\n\n\nstatic void init_viadev(struct via82xx *chip, int idx, unsigned int reg_offset,\n\t\t\tint shadow_pos, int direction)\n{\n\tchip->devs[idx].reg_offset = reg_offset;\n\tchip->devs[idx].shadow_shift = shadow_pos * 4;\n\tchip->devs[idx].direction = direction;\n\tchip->devs[idx].port = chip->port + reg_offset;\n}\n\n \nstatic int snd_via8233_pcm_new(struct via82xx *chip)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_chmap *chmap;\n\tint i, err;\n\n\tchip->playback_devno = 0;\t \n\tchip->multi_devno = 4;\t\t \n\tchip->capture_devno = 5;\t \n\tchip->num_devs = 7;\n\tchip->intr_mask = 0x33033333;  \n\n\t \n\terr = snd_pcm_new(chip->card, chip->card->shortname, 0, 4, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[0] = pcm;\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tinit_viadev(chip, i, 0x10 * i, i, 0);\n\t \n\tinit_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64*1024, VIA_MAX_BUFSIZE);\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_std_chmaps, 2, 0,\n\t\t\t\t     &chmap);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_multi_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[1] = pcm;\n\t \n\tinit_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);\n\t \n\tinit_viadev(chip, chip->capture_devno + 1, VIA_REG_CAPTURE_8233_STATUS + 0x10, 7, 1);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64*1024, VIA_MAX_BUFSIZE);\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps, 6, 0,\n\t\t\t\t     &chmap);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\n\n\treturn 0;\n}\n\n \nstatic int snd_via8233a_pcm_new(struct via82xx *chip)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_chmap *chmap;\n\tint err;\n\n\tchip->multi_devno = 0;\n\tchip->playback_devno = 1;\n\tchip->capture_devno = 2;\n\tchip->num_devs = 3;\n\tchip->intr_mask = 0x03033000;  \n\n\t \n\terr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_multi_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via8233_capture_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[0] = pcm;\n\t \n\tinit_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);\n\t \n\tinit_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64*1024, VIA_MAX_BUFSIZE);\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps, 6, 0,\n\t\t\t\t     &chmap);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\n\n\t \n\tif (! ac97_can_spdif(chip->ac97))\n\t\treturn 0;\n\n\t \n\terr = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via8233_playback_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[1] = pcm;\n\t \n\tinit_viadev(chip, chip->playback_devno, 0x30, 3, 0);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64*1024, VIA_MAX_BUFSIZE);\n\treturn 0;\n}\n\n \nstatic int snd_via686_pcm_new(struct via82xx *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tchip->playback_devno = 0;\n\tchip->capture_devno = 1;\n\tchip->num_devs = 2;\n\tchip->intr_mask = 0x77;  \n\n\terr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via686_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via686_capture_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[0] = pcm;\n\tinit_viadev(chip, 0, VIA_REG_PLAYBACK_STATUS, 0, 0);\n\tinit_viadev(chip, 1, VIA_REG_CAPTURE_STATUS, 0, 1);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       64*1024, VIA_MAX_BUFSIZE);\n\treturn 0;\n}\n\n\n \n\nstatic int snd_via8233_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\t \n\tstatic const char * const texts[2] = {\n\t\t\"Input1\", \"Input2\"\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_via8233_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);\n\tucontrol->value.enumerated.item[0] = inb(port) & VIA_REG_CAPTURE_CHANNEL_MIC ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_via8233_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);\n\tu8 val, oval;\n\n\tspin_lock_irq(&chip->reg_lock);\n\toval = inb(port);\n\tval = oval & ~VIA_REG_CAPTURE_CHANNEL_MIC;\n\tif (ucontrol->value.enumerated.item[0])\n\t\tval |= VIA_REG_CAPTURE_CHANNEL_MIC;\n\tif (val != oval)\n\t\toutb(val, port);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn val != oval;\n}\n\nstatic struct snd_kcontrol_new snd_via8233_capture_source = {\n\t.name = \"Input Source Select\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_via8233_capture_source_info,\n\t.get = snd_via8233_capture_source_get,\n\t.put = snd_via8233_capture_source_put,\n};\n\n#define snd_via8233_dxs3_spdif_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_via8233_dxs3_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\n\tpci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);\n\tucontrol->value.integer.value[0] = (val & VIA8233_SPDIF_DX3) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int snd_via8233_dxs3_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tu8 val, oval;\n\n\tpci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &oval);\n\tval = oval & ~VIA8233_SPDIF_DX3;\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= VIA8233_SPDIF_DX3;\n\t \n\tchip->spdif_on = ucontrol->value.integer.value[0] ? 1 : 0;\n\tif (val != oval) {\n\t\tpci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_via8233_dxs3_spdif_control = {\n\t.name = SNDRV_CTL_NAME_IEC958(\"Output \",NONE,SWITCH),\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_via8233_dxs3_spdif_info,\n\t.get = snd_via8233_dxs3_spdif_get,\n\t.put = snd_via8233_dxs3_spdif_put,\n};\n\nstatic int snd_via8233_dxs_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = VIA_DXS_MAX_VOLUME;\n\treturn 0;\n}\n\nstatic int snd_via8233_dxs_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = kcontrol->id.subdevice;\n\n\tucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][0];\n\tucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][1];\n\treturn 0;\n}\n\nstatic int snd_via8233_pcmdxs_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[0];\n\tucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[1];\n\treturn 0;\n}\n\nstatic int snd_via8233_dxs_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = kcontrol->id.subdevice;\n\tunsigned long port = chip->port + 0x10 * idx;\n\tunsigned char val;\n\tint i, change = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tval = ucontrol->value.integer.value[i];\n\t\tif (val > VIA_DXS_MAX_VOLUME)\n\t\t\tval = VIA_DXS_MAX_VOLUME;\n\t\tval = VIA_DXS_MAX_VOLUME - val;\n\t\tchange |= val != chip->playback_volume[idx][i];\n\t\tif (change) {\n\t\t\tchip->playback_volume[idx][i] = val;\n\t\t\toutb(val, port + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\n\t\t}\n\t}\n\treturn change;\n}\n\nstatic int snd_via8233_pcmdxs_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct via82xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx;\n\tunsigned char val;\n\tint i, change = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tval = ucontrol->value.integer.value[i];\n\t\tif (val > VIA_DXS_MAX_VOLUME)\n\t\t\tval = VIA_DXS_MAX_VOLUME;\n\t\tval = VIA_DXS_MAX_VOLUME - val;\n\t\tif (val != chip->playback_volume_c[i]) {\n\t\t\tchange = 1;\n\t\t\tchip->playback_volume_c[i] = val;\n\t\t\tfor (idx = 0; idx < 4; idx++) {\n\t\t\t\tunsigned long port = chip->port + 0x10 * idx;\n\t\t\t\tchip->playback_volume[idx][i] = val;\n\t\t\t\toutb(val, port + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\n\t\t\t}\n\t\t}\n\t}\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_dxs, -4650, 150, 1);\n\nstatic const struct snd_kcontrol_new snd_via8233_pcmdxs_volume_control = {\n\t.name = \"PCM Playback Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t   SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.info = snd_via8233_dxs_volume_info,\n\t.get = snd_via8233_pcmdxs_volume_get,\n\t.put = snd_via8233_pcmdxs_volume_put,\n\t.tlv = { .p = db_scale_dxs }\n};\n\nstatic const struct snd_kcontrol_new snd_via8233_dxs_volume_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.device = 0,\n\t \n\t.name = \"PCM Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t  SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.info = snd_via8233_dxs_volume_info,\n\t.get = snd_via8233_dxs_volume_get,\n\t.put = snd_via8233_dxs_volume_put,\n\t.tlv = { .p = db_scale_dxs }\n};\n\n \n\nstatic void snd_via82xx_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct via82xx *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_via82xx_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct via82xx *chip = ac97->private_data;\n\tchip->ac97 = NULL;\n}\n\nstatic const struct ac97_quirk ac97_quirks[] = {\n\t{\n\t\t.subvendor = 0x1106,\n\t\t.subdevice = 0x4161,\n\t\t.codec_id = 0x56494161,  \n\t\t.name = \"Soltek SL-75DRV5\",\n\t\t.type = AC97_TUNE_NONE\n\t},\n\t{\t \n\t\t.subvendor = 0x1106,\n\t\t.subdevice = 0x4161,\n\t\t.name = \"ASRock K7VT2\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x110a,\n\t\t.subdevice = 0x0079,\n\t\t.name = \"Fujitsu Siemens D1289\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1019,\n\t\t.subdevice = 0x0a81,\n\t\t.name = \"ECS K7VTA3\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1019,\n\t\t.subdevice = 0x0a85,\n\t\t.name = \"ECS L7VMM2\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1019,\n\t\t.subdevice = 0x1841,\n\t\t.name = \"ECS K7VTA3\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{\n\t\t.subvendor = 0x1849,\n\t\t.subdevice = 0x3059,\n\t\t.name = \"ASRock K7VM2\",\n\t\t.type = AC97_TUNE_HP_ONLY\t \n\t},\n\t{\n\t\t.subvendor = 0x14cd,\n\t\t.subdevice = 0x7002,\n\t\t.name = \"Unknown\",\n\t\t.type = AC97_TUNE_ALC_JACK\n\t},\n\t{\n\t\t.subvendor = 0x1071,\n\t\t.subdevice = 0x8590,\n\t\t.name = \"Mitac Mobo\",\n\t\t.type = AC97_TUNE_ALC_JACK\n\t},\n\t{\n\t\t.subvendor = 0x161f,\n\t\t.subdevice = 0x202b,\n\t\t.name = \"Arima Notebook\",\n\t\t.type = AC97_TUNE_HP_ONLY,\n\t},\n\t{\n\t\t.subvendor = 0x161f,\n\t\t.subdevice = 0x2032,\n\t\t.name = \"Targa Traveller 811\",\n\t\t.type = AC97_TUNE_HP_ONLY,\n\t},\n\t{\n\t\t.subvendor = 0x161f,\n\t\t.subdevice = 0x2032,\n\t\t.name = \"m680x\",\n\t\t.type = AC97_TUNE_HP_ONLY,  \n\t},\n\t{\n\t\t.subvendor = 0x1297,\n\t\t.subdevice = 0xa232,\n\t\t.name = \"Shuttle AK32VN\",\n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n\t{ }  \n};\n\nstatic int snd_via82xx_mixer_new(struct via82xx *chip, const char *quirk_override)\n{\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_via82xx_codec_write,\n\t\t.read = snd_via82xx_codec_read,\n\t\t.wait = snd_via82xx_codec_wait,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;\n\tchip->ac97_bus->clock = chip->ac97_clock;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_via82xx_mixer_free_ac97;\n\tac97.pci = chip->pci;\n\tac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);\n\n\tif (chip->chip_type != TYPE_VIA686) {\n\t\t \n\t\tsnd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);\n\t}\n\n\treturn 0;\n}\n\n#ifdef SUPPORT_JOYSTICK\n#define JOYSTICK_ADDR\t0x200\nstatic int snd_via686_create_gameport(struct via82xx *chip, unsigned char *legacy)\n{\n\tstruct gameport *gp;\n\n\tif (!joystick)\n\t\treturn -ENODEV;\n\n\tif (!devm_request_region(chip->card->dev, JOYSTICK_ADDR, 8,\n\t\t\t\t \"VIA686 gameport\")) {\n\t\tdev_warn(chip->card->dev, \"cannot reserve joystick port %#x\\n\",\n\t\t       JOYSTICK_ADDR);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"VIA686 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->io = JOYSTICK_ADDR;\n\n\t \n\t*legacy |= VIA_FUNC_ENABLE_GAME;\n\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, *legacy);\n\n\tgameport_register_port(chip->gameport);\n\n\treturn 0;\n}\n\nstatic void snd_via686_free_gameport(struct via82xx *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_via686_create_gameport(struct via82xx *chip, unsigned char *legacy)\n{\n\treturn -ENOSYS;\n}\nstatic inline void snd_via686_free_gameport(struct via82xx *chip) { }\n#endif\n\n\n \n\nstatic int snd_via8233_init_misc(struct via82xx *chip)\n{\n\tint i, err, caps;\n\tunsigned char val;\n\n\tcaps = chip->chip_type == TYPE_VIA8233A ? 1 : 2;\n\tfor (i = 0; i < caps; i++) {\n\t\tsnd_via8233_capture_source.index = i;\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_capture_source, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (ac97_can_spdif(chip->ac97)) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_dxs3_spdif_control, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (chip->chip_type != TYPE_VIA8233A) {\n\t\t \n\t\tif (!snd_ctl_find_id_mixer(chip->card, \"PCM Playback Volume\")) {\n\t\t\tdev_info(chip->card->dev,\n\t\t\t\t \"Using DXS as PCM Playback\\n\");\n\t\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_pcmdxs_volume_control, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\telse  \n\t\t{\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tstruct snd_kcontrol *kctl;\n\n\t\t\t\tkctl = snd_ctl_new1(\n\t\t\t\t\t&snd_via8233_dxs_volume_control, chip);\n\t\t\t\tif (!kctl)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tkctl->id.subdevice = i;\n\t\t\t\terr = snd_ctl_add(chip->card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tchip->dxs_controls[i] = kctl;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tpci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);\n\tval = (val & ~VIA8233_SPDIF_SLOT_MASK) | VIA8233_SPDIF_SLOT_1011;\n\tval &= ~VIA8233_SPDIF_DX3;  \n\tpci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);\n\n\treturn 0;\n}\n\nstatic int snd_via686_init_misc(struct via82xx *chip)\n{\n\tunsigned char legacy, legacy_cfg;\n\tint rev_h = 0;\n\n\tlegacy = chip->old_legacy;\n\tlegacy_cfg = chip->old_legacy_cfg;\n\tlegacy |= VIA_FUNC_MIDI_IRQMASK;\t \n\tlegacy &= ~VIA_FUNC_ENABLE_GAME;\t \n\tif (chip->revision >= VIA_REV_686_H) {\n\t\trev_h = 1;\n\t\tif (mpu_port >= 0x200) {\t \n\t\t\tmpu_port &= 0xfffc;\n\t\t\tpci_write_config_dword(chip->pci, 0x18, mpu_port | 0x01);\n#ifdef CONFIG_PM_SLEEP\n\t\t\tchip->mpu_port_saved = mpu_port;\n#endif\n\t\t} else {\n\t\t\tmpu_port = pci_resource_start(chip->pci, 2);\n\t\t}\n\t} else {\n\t\tswitch (mpu_port) {\t \n\t\tcase 0x300:\n\t\tcase 0x310:\n\t\tcase 0x320:\n\t\tcase 0x330:\n\t\t\tlegacy_cfg &= ~(3 << 2);\n\t\t\tlegacy_cfg |= (mpu_port & 0x0030) >> 2;\n\t\t\tbreak;\n\t\tdefault:\t\t\t \n\t\t\tif (legacy & VIA_FUNC_ENABLE_MIDI)\n\t\t\t\tmpu_port = 0x300 + ((legacy_cfg & 0x000c) << 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mpu_port >= 0x200)\n\t\tchip->mpu_res = devm_request_region(&chip->pci->dev, mpu_port,\n\t\t\t\t\t\t    2, \"VIA82xx MPU401\");\n\tif (chip->mpu_res) {\n\t\tif (rev_h)\n\t\t\tlegacy |= VIA_FUNC_MIDI_PNP;\t \n\t\tlegacy |= VIA_FUNC_ENABLE_MIDI;\n\t} else {\n\t\tif (rev_h)\n\t\t\tlegacy &= ~VIA_FUNC_MIDI_PNP;\t \n\t\tlegacy &= ~VIA_FUNC_ENABLE_MIDI;\n\t\tmpu_port = 0;\n\t}\n\n\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);\n\tpci_write_config_byte(chip->pci, VIA_PNP_CONTROL, legacy_cfg);\n\tif (chip->mpu_res) {\n\t\tif (snd_mpu401_uart_new(chip->card, 0, MPU401_HW_VIA686A,\n\t\t\t\t\tmpu_port, MPU401_INFO_INTEGRATED |\n\t\t\t\t\tMPU401_INFO_IRQ_HOOK, -1,\n\t\t\t\t\t&chip->rmidi) < 0) {\n\t\t\tdev_warn(chip->card->dev,\n\t\t\t\t \"unable to initialize MPU-401 at 0x%lx, skipping\\n\",\n\t\t\t\t mpu_port);\n\t\t\tlegacy &= ~VIA_FUNC_ENABLE_MIDI;\n\t\t} else {\n\t\t\tlegacy &= ~VIA_FUNC_MIDI_IRQMASK;\t \n\t\t}\n\t\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);\n\t}\n\n\tsnd_via686_create_gameport(chip, &legacy);\n\n#ifdef CONFIG_PM_SLEEP\n\tchip->legacy_saved = legacy;\n\tchip->legacy_cfg_saved = legacy_cfg;\n#endif\n\n\treturn 0;\n}\n\n\n \nstatic void snd_via82xx_proc_read(struct snd_info_entry *entry,\n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct via82xx *chip = entry->private_data;\n\tint i;\n\t\n\tsnd_iprintf(buffer, \"%s\\n\\n\", chip->card->longname);\n\tfor (i = 0; i < 0xa0; i += 4) {\n\t\tsnd_iprintf(buffer, \"%02x: %08x\\n\", i, inl(chip->port + i));\n\t}\n}\n\nstatic void snd_via82xx_proc_init(struct via82xx *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"via82xx\", chip,\n\t\t\t     snd_via82xx_proc_read);\n}\n\n \n\nstatic int snd_via82xx_chip_init(struct via82xx *chip)\n{\n\tunsigned int val;\n\tunsigned long end_time;\n\tunsigned char pval;\n\n#if 0  \n\tif (chip->chip_type == TYPE_VIA686)\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, 0);\n#endif\n\tpci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\n\tif (! (pval & VIA_ACLINK_C00_READY)) {  \n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\n\t\t\t\t      VIA_ACLINK_CTRL_ENABLE |\n\t\t\t\t      VIA_ACLINK_CTRL_RESET |\n\t\t\t\t      VIA_ACLINK_CTRL_SYNC);\n\t\tudelay(100);\n#if 1  \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);\n\t\tudelay(100);\n#else\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\n\t\t\t\t      VIA_ACLINK_CTRL_RESET|VIA_ACLINK_CTRL_SYNC);\n\t\tudelay(2);\n#endif\n\t\t \n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\n\t\tudelay(100);\n\t}\n\t\n\t \n\tpci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);\n\tif ((pval & VIA_ACLINK_CTRL_INIT) != VIA_ACLINK_CTRL_INIT) {\n\t\t \n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\n\t\tudelay(100);\n\t}\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(750);\n\tdo {\n\t\tpci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\n\t\tif (pval & VIA_ACLINK_C00_READY)  \n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\n\tval = snd_via82xx_codec_xread(chip);\n\tif (val & VIA_REG_AC97_BUSY)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"AC'97 codec is not ready [0x%x]\\n\", val);\n\n#if 0  \n\tsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\n\t\t\t\t VIA_REG_AC97_SECONDARY_VALID |\n\t\t\t\t (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\n\tend_time = jiffies + msecs_to_jiffies(750);\n\tsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\n\t\t\t\t VIA_REG_AC97_SECONDARY_VALID |\n\t\t\t\t (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\n\tdo {\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tif (val & VIA_REG_AC97_SECONDARY_VALID) {\n\t\t\tchip->ac97_secondary = 1;\n\t\t\tgoto __ac97_ok2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\t \n\n      __ac97_ok2:\n#endif\n\n\tif (chip->chip_type == TYPE_VIA686) {\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);\n\t\t \n\t\toutl(0, VIAREG(chip, GPI_INTR));\n\t}\n\n\tif (chip->chip_type != TYPE_VIA686) {\n\t\t \n\t\tstruct pci_dev *pci;\n\t\tpci = pci_get_device(0x1106, 0x3068, NULL);  \n\t\tif (pci) {\n\t\t\tunsigned char data;\n\t\t\tpci_read_config_byte(pci, 0x44, &data);\n\t\t\tpci_write_config_byte(pci, 0x44, data | 0x40);\n\t\t\tpci_dev_put(pci);\n\t\t}\n\t}\n\n\tif (chip->chip_type != TYPE_VIA8233A) {\n\t\tint i, idx;\n\t\tfor (idx = 0; idx < 4; idx++) {\n\t\t\tunsigned long port = chip->port + 0x10 * idx;\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tchip->playback_volume[idx][i]=chip->playback_volume_c[i];\n\t\t\t\toutb(chip->playback_volume_c[i],\n\t\t\t\t     port + VIA_REG_OFS_PLAYBACK_VOLUME_L + i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int snd_via82xx_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct via82xx *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\tsnd_ac97_suspend(chip->ac97);\n\n\t \n\tif (chip->chip_type != TYPE_VIA686) {\n\t\tpci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &chip->spdif_ctrl_saved);\n\t\tchip->capture_src_saved[0] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL);\n\t\tchip->capture_src_saved[1] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_via82xx_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct via82xx *chip = card->private_data;\n\tint i;\n\n\tsnd_via82xx_chip_init(chip);\n\n\tif (chip->chip_type == TYPE_VIA686) {\n\t\tif (chip->mpu_port_saved)\n\t\t\tpci_write_config_dword(chip->pci, 0x18, chip->mpu_port_saved | 0x01);\n\t\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->legacy_saved);\n\t\tpci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->legacy_cfg_saved);\n\t} else {\n\t\tpci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, chip->spdif_ctrl_saved);\n\t\toutb(chip->capture_src_saved[0], chip->port + VIA_REG_CAPTURE_CHANNEL);\n\t\toutb(chip->capture_src_saved[1], chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);\n\t}\n\n\tsnd_ac97_resume(chip->ac97);\n\n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_via82xx_pm, snd_via82xx_suspend, snd_via82xx_resume);\n#define SND_VIA82XX_PM_OPS\t&snd_via82xx_pm\n#else\n#define SND_VIA82XX_PM_OPS\tNULL\n#endif  \n\nstatic void snd_via82xx_free(struct snd_card *card)\n{\n\tstruct via82xx *chip = card->private_data;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\n\tif (chip->chip_type == TYPE_VIA686) {\n\t\tsnd_via686_free_gameport(chip);\n\t\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->old_legacy);\n\t\tpci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->old_legacy_cfg);\n\t}\n}\n\nstatic int snd_via82xx_create(struct snd_card *card,\n\t\t\t      struct pci_dev *pci,\n\t\t\t      int chip_type,\n\t\t\t      int revision,\n\t\t\t      unsigned int ac97_clock)\n{\n\tstruct via82xx *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->chip_type = chip_type;\n\tchip->revision = revision;\n\n\tspin_lock_init(&chip->reg_lock);\n\tspin_lock_init(&chip->rates[0].lock);\n\tspin_lock_init(&chip->rates[1].lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\tpci_read_config_byte(pci, VIA_FUNC_ENABLE, &chip->old_legacy);\n\tpci_read_config_byte(pci, VIA_PNP_CONTROL, &chip->old_legacy_cfg);\n\tpci_write_config_byte(chip->pci, VIA_FUNC_ENABLE,\n\t\t\t      chip->old_legacy & ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM));\n\n\terr = pci_request_regions(pci, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\tchip->port = pci_resource_start(pci, 0);\n\tif (devm_request_irq(&pci->dev, pci->irq,\n\t\t\t     chip_type == TYPE_VIA8233 ?\n\t\t\t     snd_via8233_interrupt : snd_via686_interrupt,\n\t\t\t     IRQF_SHARED,\n\t\t\t     KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_via82xx_free;\n\tif (ac97_clock >= 8000 && ac97_clock <= 48000)\n\t\tchip->ac97_clock = ac97_clock;\n\n\terr = snd_via82xx_chip_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpci_set_master(pci);\n\treturn 0;\n}\n\nstruct via823x_info {\n\tint revision;\n\tchar *name;\n\tint type;\n};\nstatic const struct via823x_info via823x_cards[] = {\n\t{ VIA_REV_PRE_8233, \"VIA 8233-Pre\", TYPE_VIA8233 },\n\t{ VIA_REV_8233C, \"VIA 8233C\", TYPE_VIA8233 },\n\t{ VIA_REV_8233, \"VIA 8233\", TYPE_VIA8233 },\n\t{ VIA_REV_8233A, \"VIA 8233A\", TYPE_VIA8233A },\n\t{ VIA_REV_8235, \"VIA 8235\", TYPE_VIA8233 },\n\t{ VIA_REV_8237, \"VIA 8237\", TYPE_VIA8233 },\n\t{ VIA_REV_8251, \"VIA 8251\", TYPE_VIA8233 },\n};\n\n \n\nstatic const struct snd_pci_quirk dxs_allowlist[] = {\n\tSND_PCI_QUIRK(0x1005, 0x4710, \"Avance Logic Mobo\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1019, 0x0996, \"ESC Mobo\", VIA_DXS_48K),\n\tSND_PCI_QUIRK(0x1019, 0x0a81, \"ECS K7VTA3 v8.0\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x1019, 0x0a85, \"ECS L7VMM2\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK_VENDOR(0x1019, \"ESC K8\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1019, 0xaa01, \"ESC K8T890-A\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1025, 0x0033, \"Acer Inspire 1353LM\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x1025, 0x0046, \"Acer Aspire 1524 WLMi\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK_VENDOR(0x1043, \"ASUS A7/A8\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK_VENDOR(0x1071, \"Diverse Notebook\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x10cf, 0x118e, \"FSC Laptop\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK_VENDOR(0x1106, \"ASRock\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1297, 0xa231, \"Shuttle AK31v2\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1297, 0xa232, \"Shuttle\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1297, 0xc160, \"Shuttle Sk41G\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1458, 0xa002, \"Gigabyte GA-7VAXP\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1462, 0x3800, \"MSI KT266\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1462, 0x7120, \"MSI KT4V\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1462, 0x7142, \"MSI K8MM-V\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK_VENDOR(0x1462, \"MSI Mobo\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x147b, 0x1401, \"ABIT KD7(-RAID)\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x147b, 0x1411, \"ABIT VA-20\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x147b, 0x1413, \"ABIT KV8 Pro\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x147b, 0x1415, \"ABIT AV8\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x14ff, 0x0403, \"Twinhead mobo\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x14ff, 0x0408, \"Twinhead laptop\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1558, 0x4701, \"Clevo D470\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1584, 0x8120, \"Diverse Laptop\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1584, 0x8123, \"Targa/Uniwill\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x161f, 0x202b, \"Amira Notebook\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x161f, 0x2032, \"m680x machines\", VIA_DXS_48K),\n\tSND_PCI_QUIRK(0x1631, 0xe004, \"PB EasyNote 3174\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK(0x1695, 0x3005, \"EPoX EP-8K9A\", VIA_DXS_ENABLE),\n\tSND_PCI_QUIRK_VENDOR(0x1695, \"EPoX mobo\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK_VENDOR(0x16f3, \"Jetway K8\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK_VENDOR(0x1734, \"FSC Laptop\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1849, 0x3059, \"ASRock K7VM2\", VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK_VENDOR(0x1849, \"ASRock mobo\", VIA_DXS_SRC),\n\tSND_PCI_QUIRK(0x1919, 0x200a, \"Soltek SL-K8\",  VIA_DXS_NO_VRA),\n\tSND_PCI_QUIRK(0x4005, 0x4710, \"MSI K7T266\", VIA_DXS_SRC),\n\t{ }  \n};\n\nstatic int check_dxs_list(struct pci_dev *pci, int revision)\n{\n\tconst struct snd_pci_quirk *w;\n\n\tw = snd_pci_quirk_lookup(pci, dxs_allowlist);\n\tif (w) {\n\t\tdev_dbg(&pci->dev, \"DXS allow list for %s found\\n\",\n\t\t\t    snd_pci_quirk_name(w));\n\t\treturn w->value;\n\t}\n\n\t \n\tif (revision >= VIA_REV_8235)\n\t\treturn VIA_DXS_SRC;\n\n\t \n\tdev_info(&pci->dev, \"Assuming DXS channels with 48k fixed sample rate.\\n\");\n\tdev_info(&pci->dev, \"         Please try dxs_support=5 option\\n\");\n\tdev_info(&pci->dev, \"         and report if it works on your machine.\\n\");\n\tdev_info(&pci->dev, \"         For more details, read ALSA-Configuration.txt.\\n\");\n\treturn VIA_DXS_48K;\n};\n\nstatic int __snd_via82xx_probe(struct pci_dev *pci,\n\t\t\t       const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct via82xx *chip;\n\tint chip_type = 0, card_type;\n\tunsigned int i;\n\tint err;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tcard_type = pci_id->driver_data;\n\tswitch (card_type) {\n\tcase TYPE_CARD_VIA686:\n\t\tstrcpy(card->driver, \"VIA686A\");\n\t\tsprintf(card->shortname, \"VIA 82C686A/B rev%x\", pci->revision);\n\t\tchip_type = TYPE_VIA686;\n\t\tbreak;\n\tcase TYPE_CARD_VIA8233:\n\t\tchip_type = TYPE_VIA8233;\n\t\tsprintf(card->shortname, \"VIA 823x rev%x\", pci->revision);\n\t\tfor (i = 0; i < ARRAY_SIZE(via823x_cards); i++) {\n\t\t\tif (pci->revision == via823x_cards[i].revision) {\n\t\t\t\tchip_type = via823x_cards[i].type;\n\t\t\t\tstrcpy(card->shortname, via823x_cards[i].name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (chip_type != TYPE_VIA8233A) {\n\t\t\tif (dxs_support == VIA_DXS_AUTO)\n\t\t\t\tdxs_support = check_dxs_list(pci, pci->revision);\n\t\t\t \n\t\t\tif (dxs_support == VIA_DXS_DISABLE)\n\t\t\t\tchip_type = TYPE_VIA8233A;\n\t\t\telse\n\t\t\t\tchip_type = TYPE_VIA8233;\n\t\t}\n\t\tif (chip_type == TYPE_VIA8233A)\n\t\t\tstrcpy(card->driver, \"VIA8233A\");\n\t\telse if (pci->revision >= VIA_REV_8237)\n\t\t\tstrcpy(card->driver, \"VIA8237\");  \n\t\telse\n\t\t\tstrcpy(card->driver, \"VIA8233\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(card->dev, \"invalid card type %d\\n\", card_type);\n\t\treturn -EINVAL;\n\t}\n\t\t\n\terr = snd_via82xx_create(card, pci, chip_type, pci->revision,\n\t\t\t\t ac97_clock);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_via82xx_mixer_new(chip, ac97_quirk);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip_type == TYPE_VIA686) {\n\t\terr = snd_via686_pcm_new(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_via686_init_misc(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tif (chip_type == TYPE_VIA8233A) {\n\t\t\terr = snd_via8233a_pcm_new(chip);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\t \n\t\t} else {\n\t\t\terr = snd_via8233_pcm_new(chip);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (dxs_support == VIA_DXS_48K)\n\t\t\t\tchip->dxs_fixed = 1;\n\t\t\telse if (dxs_support == VIA_DXS_NO_VRA)\n\t\t\t\tchip->no_vra = 1;\n\t\t\telse if (dxs_support == VIA_DXS_SRC) {\n\t\t\t\tchip->no_vra = 1;\n\t\t\t\tchip->dxs_src = 1;\n\t\t\t}\n\t\t}\n\t\terr = snd_via8233_init_misc(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s with %s at %#lx, irq %d\", card->shortname,\n\t\t snd_ac97_get_short_name(chip->ac97), chip->port, chip->irq);\n\n\tsnd_via82xx_proc_init(chip);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_via82xx_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_via82xx_probe(pci, pci_id));\n}\n\nstatic struct pci_driver via82xx_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_via82xx_ids,\n\t.probe = snd_via82xx_probe,\n\t.driver = {\n\t\t.pm = SND_VIA82XX_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(via82xx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}