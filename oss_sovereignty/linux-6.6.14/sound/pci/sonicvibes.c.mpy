{
  "module_name": "sonicvibes.c",
  "hash_id": "189bb45892c8b4c690461823e2dfb9825bf9f2cd7109c35a5df965dcadf50d31",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/sonicvibes.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/mpu401.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"S3 SonicVibes PCI\");\nMODULE_LICENSE(\"GPL\");\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK 1\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic bool reverb[SNDRV_CARDS];\nstatic bool mge[SNDRV_CARDS];\nstatic unsigned int dmaio = 0x7a00;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for S3 SonicVibes soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for S3 SonicVibes soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable S3 SonicVibes soundcard.\");\nmodule_param_array(reverb, bool, NULL, 0444);\nMODULE_PARM_DESC(reverb, \"Enable reverb (SRAM is present) for S3 SonicVibes soundcard.\");\nmodule_param_array(mge, bool, NULL, 0444);\nMODULE_PARM_DESC(mge, \"MIC Gain Enable for S3 SonicVibes soundcard.\");\nmodule_param_hw(dmaio, uint, ioport, 0444);\nMODULE_PARM_DESC(dmaio, \"DDMA i/o base address for S3 SonicVibes soundcard.\");\n\n \n\n#define SV_REG(sonic, x) ((sonic)->enh_port + SV_REG_##x)\n\n#define SV_REG_CONTROL\t0x00\t \n#define   SV_ENHANCED\t  0x01\t \n#define   SV_TEST\t  0x02\t \n#define   SV_REVERB\t  0x04\t \n#define   SV_WAVETABLE\t  0x08\t \n#define   SV_INTA\t  0x20\t \n#define   SV_RESET\t  0x80\t \n#define SV_REG_IRQMASK\t0x01\t \n#define   SV_DMAA_MASK\t  0x01\t \n#define   SV_DMAC_MASK\t  0x04\t \n#define   SV_SPEC_MASK\t  0x08\t \n#define   SV_UD_MASK\t  0x40\t \n#define   SV_MIDI_MASK\t  0x80\t \n#define SV_REG_STATUS\t0x02\t \n#define   SV_DMAA_IRQ\t  0x01\t \n#define   SV_DMAC_IRQ\t  0x04\t \n#define   SV_SPEC_IRQ\t  0x08\t \n#define   SV_UD_IRQ\t  0x40\t \n#define   SV_MIDI_IRQ\t  0x80\t \n#define SV_REG_INDEX\t0x04\t \n#define   SV_MCE          0x40\t \n#define   SV_TRD\t  0x80\t \n#define SV_REG_DATA\t0x05\t \n\n \n\n#define SV_IREG_LEFT_ADC\t0x00\t \n#define SV_IREG_RIGHT_ADC\t0x01\t \n#define SV_IREG_LEFT_AUX1\t0x02\t \n#define SV_IREG_RIGHT_AUX1\t0x03\t \n#define SV_IREG_LEFT_CD\t\t0x04\t \n#define SV_IREG_RIGHT_CD\t0x05\t \n#define SV_IREG_LEFT_LINE\t0x06\t \n#define SV_IREG_RIGHT_LINE\t0x07\t \n#define SV_IREG_MIC\t\t0x08\t \n#define SV_IREG_GAME_PORT\t0x09\t \n#define SV_IREG_LEFT_SYNTH\t0x0a\t \n#define SV_IREG_RIGHT_SYNTH\t0x0b\t \n#define SV_IREG_LEFT_AUX2\t0x0c\t \n#define SV_IREG_RIGHT_AUX2\t0x0d\t \n#define SV_IREG_LEFT_ANALOG\t0x0e\t \n#define SV_IREG_RIGHT_ANALOG\t0x0f\t \n#define SV_IREG_LEFT_PCM\t0x10\t \n#define SV_IREG_RIGHT_PCM\t0x11\t \n#define SV_IREG_DMA_DATA_FMT\t0x12\t \n#define SV_IREG_PC_ENABLE\t0x13\t \n#define SV_IREG_UD_BUTTON\t0x14\t \n#define SV_IREG_REVISION\t0x15\t \n#define SV_IREG_ADC_OUTPUT_CTRL\t0x16\t \n#define SV_IREG_DMA_A_UPPER\t0x18\t \n#define SV_IREG_DMA_A_LOWER\t0x19\t \n#define SV_IREG_DMA_C_UPPER\t0x1c\t \n#define SV_IREG_DMA_C_LOWER\t0x1d\t \n#define SV_IREG_PCM_RATE_LOW\t0x1e\t \n#define SV_IREG_PCM_RATE_HIGH\t0x1f\t \n#define SV_IREG_SYNTH_RATE_LOW\t0x20\t \n#define SV_IREG_SYNTH_RATE_HIGH 0x21\t \n#define SV_IREG_ADC_CLOCK\t0x22\t \n#define SV_IREG_ADC_ALT_RATE\t0x23\t \n#define SV_IREG_ADC_PLL_M\t0x24\t \n#define SV_IREG_ADC_PLL_N\t0x25\t \n#define SV_IREG_SYNTH_PLL_M\t0x26\t \n#define SV_IREG_SYNTH_PLL_N\t0x27\t \n#define SV_IREG_MPU401\t\t0x2a\t \n#define SV_IREG_DRIVE_CTRL\t0x2b\t \n#define SV_IREG_SRS_SPACE\t0x2c\t \n#define SV_IREG_SRS_CENTER\t0x2d\t \n#define SV_IREG_WAVE_SOURCE\t0x2e\t \n#define SV_IREG_ANALOG_POWER\t0x30\t \n#define SV_IREG_DIGITAL_POWER\t0x31\t \n\n#define SV_IREG_ADC_PLL\t\tSV_IREG_ADC_PLL_M\n#define SV_IREG_SYNTH_PLL\tSV_IREG_SYNTH_PLL_M\n\n \n\n#define SV_DMA_ADDR0\t\t0x00\n#define SV_DMA_ADDR1\t\t0x01\n#define SV_DMA_ADDR2\t\t0x02\n#define SV_DMA_ADDR3\t\t0x03\n#define SV_DMA_COUNT0\t\t0x04\n#define SV_DMA_COUNT1\t\t0x05\n#define SV_DMA_COUNT2\t\t0x06\n#define SV_DMA_MODE\t\t0x0b\n#define SV_DMA_RESET\t\t0x0d\n#define SV_DMA_MASK\t\t0x0f\n\n \n\n#define SV_RECSRC_RESERVED\t(0x00<<5)\n#define SV_RECSRC_CD\t\t(0x01<<5)\n#define SV_RECSRC_DAC\t\t(0x02<<5)\n#define SV_RECSRC_AUX2\t\t(0x03<<5)\n#define SV_RECSRC_LINE\t\t(0x04<<5)\n#define SV_RECSRC_AUX1\t\t(0x05<<5)\n#define SV_RECSRC_MIC\t\t(0x06<<5)\n#define SV_RECSRC_OUT\t\t(0x07<<5)\n\n \n\n#define SV_FULLRATE\t\t48000\n#define SV_REFFREQUENCY\t\t24576000\n#define SV_ADCMULT\t\t512\n\n#define SV_MODE_PLAY\t\t1\n#define SV_MODE_CAPTURE\t\t2\n\n \n\nstruct sonicvibes {\n\tunsigned long dma1size;\n\tunsigned long dma2size;\n\tint irq;\n\n\tunsigned long sb_port;\n\tunsigned long enh_port;\n\tunsigned long synth_port;\n\tunsigned long midi_port;\n\tunsigned long game_port;\n\tunsigned int dmaa_port;\n\tstruct resource *res_dmaa;\n\tunsigned int dmac_port;\n\tstruct resource *res_dmac;\n\n\tunsigned char enable;\n\tunsigned char irqmask;\n\tunsigned char revision;\n\tunsigned char format;\n\tunsigned char srs_space;\n\tunsigned char srs_center;\n\tunsigned char mpu_switch;\n\tunsigned char wave_source;\n\n\tunsigned int mode;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *playback_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_hwdep *fmsynth;\t \n\n\tspinlock_t reg_lock;\n\n\tunsigned int p_dma_size;\n\tunsigned int c_dma_size;\n\n\tstruct snd_kcontrol *master_mute;\n\tstruct snd_kcontrol *master_volume;\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n};\n\nstatic const struct pci_device_id snd_sonic_ids[] = {\n\t{ PCI_VDEVICE(S3, 0xca00), 0, },\n        { 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_sonic_ids);\n\nstatic const struct snd_ratden sonicvibes_adc_clock = {\n\t.num_min = 4000 * 65536,\n\t.num_max = 48000UL * 65536,\n\t.num_step = 1,\n\t.den = 65536,\n};\nstatic const struct snd_pcm_hw_constraint_ratdens snd_sonicvibes_hw_constraints_adc_clock = {\n\t.nrats = 1,\n\t.rats = &sonicvibes_adc_clock,\n};\n\n \n\nstatic inline void snd_sonicvibes_setdmaa(struct sonicvibes * sonic,\n\t\t\t\t\t  unsigned int addr,\n\t\t\t\t\t  unsigned int count)\n{\n\tcount--;\n\toutl(addr, sonic->dmaa_port + SV_DMA_ADDR0);\n\toutl(count, sonic->dmaa_port + SV_DMA_COUNT0);\n\toutb(0x18, sonic->dmaa_port + SV_DMA_MODE);\n#if 0\n\tdev_dbg(sonic->card->dev, \"program dmaa: addr = 0x%x, paddr = 0x%x\\n\",\n\t       addr, inl(sonic->dmaa_port + SV_DMA_ADDR0));\n#endif\n}\n\nstatic inline void snd_sonicvibes_setdmac(struct sonicvibes * sonic,\n\t\t\t\t\t  unsigned int addr,\n\t\t\t\t\t  unsigned int count)\n{\n\t \n\tcount >>= 1;\n\tcount--;\n\toutl(addr, sonic->dmac_port + SV_DMA_ADDR0);\n\toutl(count, sonic->dmac_port + SV_DMA_COUNT0);\n\toutb(0x14, sonic->dmac_port + SV_DMA_MODE);\n#if 0\n\tdev_dbg(sonic->card->dev, \"program dmac: addr = 0x%x, paddr = 0x%x\\n\",\n\t       addr, inl(sonic->dmac_port + SV_DMA_ADDR0));\n#endif\n}\n\nstatic inline unsigned int snd_sonicvibes_getdmaa(struct sonicvibes * sonic)\n{\n\treturn (inl(sonic->dmaa_port + SV_DMA_COUNT0) & 0xffffff) + 1;\n}\n\nstatic inline unsigned int snd_sonicvibes_getdmac(struct sonicvibes * sonic)\n{\n\t \n\treturn ((inl(sonic->dmac_port + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;\n}\n\nstatic void snd_sonicvibes_out1(struct sonicvibes * sonic,\n\t\t\t\tunsigned char reg,\n\t\t\t\tunsigned char value)\n{\n\toutb(reg, SV_REG(sonic, INDEX));\n\tudelay(10);\n\toutb(value, SV_REG(sonic, DATA));\n\tudelay(10);\n}\n\nstatic void snd_sonicvibes_out(struct sonicvibes * sonic,\n\t\t\t       unsigned char reg,\n\t\t\t       unsigned char value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\toutb(reg, SV_REG(sonic, INDEX));\n\tudelay(10);\n\toutb(value, SV_REG(sonic, DATA));\n\tudelay(10);\n\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n}\n\nstatic unsigned char snd_sonicvibes_in1(struct sonicvibes * sonic, unsigned char reg)\n{\n\tunsigned char value;\n\n\toutb(reg, SV_REG(sonic, INDEX));\n\tudelay(10);\n\tvalue = inb(SV_REG(sonic, DATA));\n\tudelay(10);\n\treturn value;\n}\n\nstatic unsigned char snd_sonicvibes_in(struct sonicvibes * sonic, unsigned char reg)\n{\n\tunsigned long flags;\n\tunsigned char value;\n\n\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\toutb(reg, SV_REG(sonic, INDEX));\n\tudelay(10);\n\tvalue = inb(SV_REG(sonic, DATA));\n\tudelay(10);\n\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n\treturn value;\n}\n\n#if 0\nstatic void snd_sonicvibes_debug(struct sonicvibes * sonic)\n{\n\tdev_dbg(sonic->card->dev,\n\t\t\"SV REGS:          INDEX = 0x%02x                   STATUS = 0x%02x\\n\",\n\t\tinb(SV_REG(sonic, INDEX)), inb(SV_REG(sonic, STATUS)));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x00: left input      = 0x%02x    0x20: synth rate low  = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x00), snd_sonicvibes_in(sonic, 0x20));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x01: right input     = 0x%02x    0x21: synth rate high = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x01), snd_sonicvibes_in(sonic, 0x21));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x02: left AUX1       = 0x%02x    0x22: ADC clock       = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x02), snd_sonicvibes_in(sonic, 0x22));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x03: right AUX1      = 0x%02x    0x23: ADC alt rate    = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x03), snd_sonicvibes_in(sonic, 0x23));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x04: left CD         = 0x%02x    0x24: ADC pll M       = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x04), snd_sonicvibes_in(sonic, 0x24));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x05: right CD        = 0x%02x    0x25: ADC pll N       = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x05), snd_sonicvibes_in(sonic, 0x25));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x06: left line       = 0x%02x    0x26: Synth pll M     = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x06), snd_sonicvibes_in(sonic, 0x26));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x07: right line      = 0x%02x    0x27: Synth pll N     = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x07), snd_sonicvibes_in(sonic, 0x27));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x08: MIC             = 0x%02x    0x28: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x08), snd_sonicvibes_in(sonic, 0x28));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x09: Game port       = 0x%02x    0x29: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x09), snd_sonicvibes_in(sonic, 0x29));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0a: left synth      = 0x%02x    0x2a: MPU401          = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0a), snd_sonicvibes_in(sonic, 0x2a));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0b: right synth     = 0x%02x    0x2b: drive ctrl      = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0b), snd_sonicvibes_in(sonic, 0x2b));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0c: left AUX2       = 0x%02x    0x2c: SRS space       = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0c), snd_sonicvibes_in(sonic, 0x2c));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0d: right AUX2      = 0x%02x    0x2d: SRS center      = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0d), snd_sonicvibes_in(sonic, 0x2d));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0e: left analog     = 0x%02x    0x2e: wave source     = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0e), snd_sonicvibes_in(sonic, 0x2e));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x0f: right analog    = 0x%02x    0x2f: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x0f), snd_sonicvibes_in(sonic, 0x2f));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x10: left PCM        = 0x%02x    0x30: analog power    = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x10), snd_sonicvibes_in(sonic, 0x30));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x11: right PCM       = 0x%02x    0x31: analog power    = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x11), snd_sonicvibes_in(sonic, 0x31));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x12: DMA data format = 0x%02x    0x32: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x12), snd_sonicvibes_in(sonic, 0x32));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x13: P/C enable      = 0x%02x    0x33: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x13), snd_sonicvibes_in(sonic, 0x33));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x14: U/D button      = 0x%02x    0x34: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x14), snd_sonicvibes_in(sonic, 0x34));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x15: revision        = 0x%02x    0x35: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x15), snd_sonicvibes_in(sonic, 0x35));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x16: ADC output ctrl = 0x%02x    0x36: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x16), snd_sonicvibes_in(sonic, 0x36));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x17: ---             = 0x%02x    0x37: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x17), snd_sonicvibes_in(sonic, 0x37));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x18: DMA A upper cnt = 0x%02x    0x38: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x18), snd_sonicvibes_in(sonic, 0x38));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x19: DMA A lower cnt = 0x%02x    0x39: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x19), snd_sonicvibes_in(sonic, 0x39));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1a: ---             = 0x%02x    0x3a: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1a), snd_sonicvibes_in(sonic, 0x3a));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1b: ---             = 0x%02x    0x3b: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1b), snd_sonicvibes_in(sonic, 0x3b));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1c: DMA C upper cnt = 0x%02x    0x3c: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1c), snd_sonicvibes_in(sonic, 0x3c));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1d: DMA C upper cnt = 0x%02x    0x3d: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1d), snd_sonicvibes_in(sonic, 0x3d));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1e: PCM rate low    = 0x%02x    0x3e: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1e), snd_sonicvibes_in(sonic, 0x3e));\n\tdev_dbg(sonic->card->dev,\n\t\t\"  0x1f: PCM rate high   = 0x%02x    0x3f: ---             = 0x%02x\\n\",\n\t\tsnd_sonicvibes_in(sonic, 0x1f), snd_sonicvibes_in(sonic, 0x3f));\n}\n\n#endif\n\nstatic void snd_sonicvibes_setfmt(struct sonicvibes * sonic,\n                                  unsigned char mask,\n                                  unsigned char value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\toutb(SV_MCE | SV_IREG_DMA_DATA_FMT, SV_REG(sonic, INDEX));\n\tif (mask) {\n\t\tsonic->format = inb(SV_REG(sonic, DATA));\n\t\tudelay(10);\n\t}\n\tsonic->format = (sonic->format & mask) | value;\n\toutb(sonic->format, SV_REG(sonic, DATA));\n\tudelay(10);\n\toutb(0, SV_REG(sonic, INDEX));\n\tudelay(10);\n\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n}\n\nstatic void snd_sonicvibes_pll(unsigned int rate,\n\t\t\t       unsigned int *res_r,\n\t\t\t       unsigned int *res_m,\n\t\t\t       unsigned int *res_n)\n{\n\tunsigned int r, m = 0, n = 0;\n\tunsigned int xm, xn, xr, xd, metric = ~0U;\n\n\tif (rate < 625000 / SV_ADCMULT)\n\t\trate = 625000 / SV_ADCMULT;\n\tif (rate > 150000000 / SV_ADCMULT)\n\t\trate = 150000000 / SV_ADCMULT;\n\t \n\tfor (r = 0; rate < 75000000 / SV_ADCMULT; r += 0x20, rate <<= 1);\n\tfor (xn = 3; xn < 33; xn++)\t \n\t\tfor (xm = 3; xm < 257; xm++) {\n\t\t\txr = ((SV_REFFREQUENCY / SV_ADCMULT) * xm) / xn;\n\t\t\tif (xr >= rate)\n\t\t\t\txd = xr - rate;\n\t\t\telse\n\t\t\t\txd = rate - xr;\n\t\t\tif (xd < metric) {\n\t\t\t\tmetric = xd;\n\t\t\t\tm = xm - 2;\n\t\t\t\tn = xn - 2;\n\t\t\t}\n\t\t}\n\t*res_r = r;\n\t*res_m = m;\n\t*res_n = n;\n#if 0\n\tdev_dbg(sonic->card->dev,\n\t\t\"metric = %i, xm = %i, xn = %i\\n\", metric, xm, xn);\n\tdev_dbg(sonic->card->dev,\n\t\t\"pll: m = 0x%x, r = 0x%x, n = 0x%x\\n\", reg, m, r, n);\n#endif\n}\n\nstatic void snd_sonicvibes_setpll(struct sonicvibes * sonic,\n                                  unsigned char reg,\n                                  unsigned int rate)\n{\n\tunsigned long flags;\n\tunsigned int r, m, n;\n\n\tsnd_sonicvibes_pll(rate, &r, &m, &n);\n\tif (sonic != NULL) {\n\t\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\t\tsnd_sonicvibes_out1(sonic, reg, m);\n\t\tsnd_sonicvibes_out1(sonic, reg + 1, r | n);\n\t\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n\t}\n}\n\nstatic void snd_sonicvibes_set_adc_rate(struct sonicvibes * sonic, unsigned int rate)\n{\n\tunsigned long flags;\n\tunsigned int div;\n\tunsigned char clock;\n\n\tdiv = 48000 / rate;\n\tif (div > 8)\n\t\tdiv = 8;\n\tif ((48000 / div) == rate) {\t \n\t\tclock = 0x10;\n\t} else {\t\t\t \n\t\tclock = 0x00;\n\t\tsnd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, rate);\n\t}\n\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_ADC_ALT_RATE, (div - 1) << 4);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_ADC_CLOCK, clock);\n\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n}\n\nstatic int snd_sonicvibes_hw_constraint_dac_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t\t struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int rate, div, r, m, n;\n\n\tif (hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min == \n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max) {\n\t\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min;\n\t\tdiv = 48000 / rate;\n\t\tif (div > 8)\n\t\t\tdiv = 8;\n\t\tif ((48000 / div) == rate) {\n\t\t\tparams->rate_num = rate;\n\t\t\tparams->rate_den = 1;\n\t\t} else {\n\t\t\tsnd_sonicvibes_pll(rate, &r, &m, &n);\n\t\t\tsnd_BUG_ON(SV_REFFREQUENCY % 16);\n\t\t\tsnd_BUG_ON(SV_ADCMULT % 512);\n\t\t\tparams->rate_num = (SV_REFFREQUENCY/16) * (n+2) * r;\n\t\t\tparams->rate_den = (SV_ADCMULT/512) * (m+2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void snd_sonicvibes_set_dac_rate(struct sonicvibes * sonic, unsigned int rate)\n{\n\tunsigned int div;\n\tunsigned long flags;\n\n\tdiv = DIV_ROUND_CLOSEST(rate * 65536, SV_FULLRATE);\n\tif (div > 65535)\n\t\tdiv = 65535;\n\tspin_lock_irqsave(&sonic->reg_lock, flags);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_HIGH, div >> 8);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_LOW, div);\n\tspin_unlock_irqrestore(&sonic->reg_lock, flags);\n}\n\nstatic int snd_sonicvibes_trigger(struct sonicvibes * sonic, int what, int cmd)\n{\n\tint result = 0;\n\n\tspin_lock(&sonic->reg_lock);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tif (!(sonic->enable & what)) {\n\t\t\tsonic->enable |= what;\n\t\t\tsnd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);\n\t\t}\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tif (sonic->enable & what) {\n\t\t\tsonic->enable &= ~what;\n\t\t\tsnd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);\n\t\t}\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\tspin_unlock(&sonic->reg_lock);\n\treturn result;\n}\n\nstatic irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id)\n{\n\tstruct sonicvibes *sonic = dev_id;\n\tunsigned char status;\n\n\tstatus = inb(SV_REG(sonic, STATUS));\n\tif (!(status & (SV_DMAA_IRQ | SV_DMAC_IRQ | SV_MIDI_IRQ)))\n\t\treturn IRQ_NONE;\n\tif (status == 0xff) {\t \n\t\toutb(sonic->irqmask = ~0, SV_REG(sonic, IRQMASK));\n\t\tdev_err(sonic->card->dev,\n\t\t\t\"IRQ failure - interrupts disabled!!\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\tif (sonic->pcm) {\n\t\tif (status & SV_DMAA_IRQ)\n\t\t\tsnd_pcm_period_elapsed(sonic->playback_substream);\n\t\tif (status & SV_DMAC_IRQ)\n\t\t\tsnd_pcm_period_elapsed(sonic->capture_substream);\n\t}\n\tif (sonic->rmidi) {\n\t\tif (status & SV_MIDI_IRQ)\n\t\t\tsnd_mpu401_uart_interrupt(irq, sonic->rmidi->private_data);\n\t}\n\tif (status & SV_UD_IRQ) {\n\t\tunsigned char udreg;\n\t\tint vol, oleft, oright, mleft, mright;\n\n\t\tspin_lock(&sonic->reg_lock);\n\t\tudreg = snd_sonicvibes_in1(sonic, SV_IREG_UD_BUTTON);\n\t\tvol = udreg & 0x3f;\n\t\tif (!(udreg & 0x40))\n\t\t\tvol = -vol;\n\t\toleft = mleft = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ANALOG);\n\t\toright = mright = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ANALOG);\n\t\toleft &= 0x1f;\n\t\toright &= 0x1f;\n\t\toleft += vol;\n\t\tif (oleft < 0)\n\t\t\toleft = 0;\n\t\tif (oleft > 0x1f)\n\t\t\toleft = 0x1f;\n\t\toright += vol;\n\t\tif (oright < 0)\n\t\t\toright = 0;\n\t\tif (oright > 0x1f)\n\t\t\toright = 0x1f;\n\t\tif (udreg & 0x80) {\n\t\t\tmleft ^= 0x80;\n\t\t\tmright ^= 0x80;\n\t\t}\n\t\toleft |= mleft & 0x80;\n\t\toright |= mright & 0x80;\n\t\tsnd_sonicvibes_out1(sonic, SV_IREG_LEFT_ANALOG, oleft);\n\t\tsnd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ANALOG, oright);\n\t\tspin_unlock(&sonic->reg_lock);\n\t\tsnd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_mute->id);\n\t\tsnd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_volume->id);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int snd_sonicvibes_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t   int cmd)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\treturn snd_sonicvibes_trigger(sonic, 1, cmd);\n}\n\nstatic int snd_sonicvibes_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t  int cmd)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\treturn snd_sonicvibes_trigger(sonic, 2, cmd);\n}\n\nstatic int snd_sonicvibes_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned char fmt = 0;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tsonic->p_dma_size = size;\n\tcount--;\n\tif (runtime->channels > 1)\n\t\tfmt |= 1;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tfmt |= 2;\n\tsnd_sonicvibes_setfmt(sonic, ~3, fmt);\n\tsnd_sonicvibes_set_dac_rate(sonic, runtime->rate);\n\tspin_lock_irq(&sonic->reg_lock);\n\tsnd_sonicvibes_setdmaa(sonic, runtime->dma_addr, size);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_DMA_A_UPPER, count >> 8);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_DMA_A_LOWER, count);\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned char fmt = 0;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned int count = snd_pcm_lib_period_bytes(substream);\n\n\tsonic->c_dma_size = size;\n\tcount >>= 1;\n\tcount--;\n\tif (runtime->channels > 1)\n\t\tfmt |= 0x10;\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tfmt |= 0x20;\n\tsnd_sonicvibes_setfmt(sonic, ~0x30, fmt);\n\tsnd_sonicvibes_set_adc_rate(sonic, runtime->rate);\n\tspin_lock_irq(&sonic->reg_lock);\n\tsnd_sonicvibes_setdmac(sonic, runtime->dma_addr, size);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_DMA_C_UPPER, count >> 8);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_DMA_C_LOWER, count);\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_sonicvibes_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(sonic->enable & 1))\n\t\treturn 0;\n\tptr = sonic->p_dma_size - snd_sonicvibes_getdmaa(sonic);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_sonicvibes_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tif (!(sonic->enable & 2))\n\t\treturn 0;\n\tptr = sonic->c_dma_size - snd_sonicvibes_getdmac(sonic);\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic const struct snd_pcm_hardware snd_sonicvibes_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_sonicvibes_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_sonicvibes_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsonic->mode |= SV_MODE_PLAY;\n\tsonic->playback_substream = substream;\n\truntime->hw = snd_sonicvibes_playback;\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, snd_sonicvibes_hw_constraint_dac_rate, NULL, SNDRV_PCM_HW_PARAM_RATE, -1);\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsonic->mode |= SV_MODE_CAPTURE;\n\tsonic->capture_substream = substream;\n\truntime->hw = snd_sonicvibes_capture;\n\tsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_sonicvibes_hw_constraints_adc_clock);\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\n\tsonic->playback_substream = NULL;\n\tsonic->mode &= ~SV_MODE_PLAY;\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\n\n\tsonic->capture_substream = NULL;\n\tsonic->mode &= ~SV_MODE_CAPTURE;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_sonicvibes_playback_ops = {\n\t.open =\t\tsnd_sonicvibes_playback_open,\n\t.close =\tsnd_sonicvibes_playback_close,\n\t.prepare =\tsnd_sonicvibes_playback_prepare,\n\t.trigger =\tsnd_sonicvibes_playback_trigger,\n\t.pointer =\tsnd_sonicvibes_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_sonicvibes_capture_ops = {\n\t.open =\t\tsnd_sonicvibes_capture_open,\n\t.close =\tsnd_sonicvibes_capture_close,\n\t.prepare =\tsnd_sonicvibes_capture_prepare,\n\t.trigger =\tsnd_sonicvibes_capture_trigger,\n\t.pointer =\tsnd_sonicvibes_capture_pointer,\n};\n\nstatic int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(sonic->card, \"s3_86c617\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tif (snd_BUG_ON(!pcm))\n\t\treturn -EINVAL;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sonicvibes_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sonicvibes_capture_ops);\n\n\tpcm->private_data = sonic;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"S3 SonicVibes\");\n\tsonic->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &sonic->pci->dev, 64*1024, 128*1024);\n\n\treturn 0;\n}\n\n \n\n#define SONICVIBES_MUX(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_sonicvibes_info_mux, \\\n  .get = snd_sonicvibes_get_mux, .put = snd_sonicvibes_put_mux }\n\nstatic int snd_sonicvibes_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[7] = {\n\t\t\"CD\", \"PCM\", \"Aux1\", \"Line\", \"Aux0\", \"Mic\", \"Mix\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 2, 7, texts);\n}\n\nstatic int snd_sonicvibes_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&sonic->reg_lock);\n\tucontrol->value.enumerated.item[0] = ((snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC) & SV_RECSRC_OUT) >> 5) - 1;\n\tucontrol->value.enumerated.item[1] = ((snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC) & SV_RECSRC_OUT) >> 5) - 1;\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tunsigned short left, right, oval1, oval2;\n\tint change;\n\t\n\tif (ucontrol->value.enumerated.item[0] >= 7 ||\n\t    ucontrol->value.enumerated.item[1] >= 7)\n\t\treturn -EINVAL;\n\tleft = (ucontrol->value.enumerated.item[0] + 1) << 5;\n\tright = (ucontrol->value.enumerated.item[1] + 1) << 5;\n\tspin_lock_irq(&sonic->reg_lock);\n\toval1 = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC);\n\toval2 = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC);\n\tleft = (oval1 & ~SV_RECSRC_OUT) | left;\n\tright = (oval2 & ~SV_RECSRC_OUT) | right;\n\tchange = left != oval1 || right != oval2;\n\tsnd_sonicvibes_out1(sonic, SV_IREG_LEFT_ADC, left);\n\tsnd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ADC, right);\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn change;\n}\n\n#define SONICVIBES_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_sonicvibes_info_single, \\\n  .get = snd_sonicvibes_get_single, .put = snd_sonicvibes_put_single, \\\n  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }\n\nstatic int snd_sonicvibes_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\t\n\tspin_lock_irq(&sonic->reg_lock);\n\tucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, reg)>> shift) & mask;\n\tspin_unlock_irq(&sonic->reg_lock);\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val, oval;\n\t\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\tspin_lock_irq(&sonic->reg_lock);\n\toval = snd_sonicvibes_in1(sonic, reg);\n\tval = (oval & ~(mask << shift)) | val;\n\tchange = val != oval;\n\tsnd_sonicvibes_out1(sonic, reg, val);\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn change;\n}\n\n#define SONICVIBES_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_sonicvibes_info_double, \\\n  .get = snd_sonicvibes_get_double, .put = snd_sonicvibes_put_double, \\\n  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }\n\nstatic int snd_sonicvibes_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\t\n\tspin_lock_irq(&sonic->reg_lock);\n\tucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, left_reg) >> shift_left) & mask;\n\tucontrol->value.integer.value[1] = (snd_sonicvibes_in1(sonic, right_reg) >> shift_right) & mask;\n\tspin_unlock_irq(&sonic->reg_lock);\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\treturn 0;\n}\n\nstatic int snd_sonicvibes_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2, oval1, oval2;\n\t\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\tspin_lock_irq(&sonic->reg_lock);\n\toval1 = snd_sonicvibes_in1(sonic, left_reg);\n\toval2 = snd_sonicvibes_in1(sonic, right_reg);\n\tval1 = (oval1 & ~(mask << shift_left)) | val1;\n\tval2 = (oval2 & ~(mask << shift_right)) | val2;\n\tchange = val1 != oval1 || val2 != oval2;\n\tsnd_sonicvibes_out1(sonic, left_reg, val1);\n\tsnd_sonicvibes_out1(sonic, right_reg, val2);\n\tspin_unlock_irq(&sonic->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_sonicvibes_controls[] = {\nSONICVIBES_DOUBLE(\"Capture Volume\", 0, SV_IREG_LEFT_ADC, SV_IREG_RIGHT_ADC, 0, 0, 15, 0),\nSONICVIBES_DOUBLE(\"Aux Playback Switch\", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"Aux Playback Volume\", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 0, 0, 31, 1),\nSONICVIBES_DOUBLE(\"CD Playback Switch\", 0, SV_IREG_LEFT_CD, SV_IREG_RIGHT_CD, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"CD Playback Volume\", 0, SV_IREG_LEFT_CD, SV_IREG_RIGHT_CD, 0, 0, 31, 1),\nSONICVIBES_DOUBLE(\"Line Playback Switch\", 0, SV_IREG_LEFT_LINE, SV_IREG_RIGHT_LINE, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"Line Playback Volume\", 0, SV_IREG_LEFT_LINE, SV_IREG_RIGHT_LINE, 0, 0, 31, 1),\nSONICVIBES_SINGLE(\"Mic Playback Switch\", 0, SV_IREG_MIC, 7, 1, 1),\nSONICVIBES_SINGLE(\"Mic Playback Volume\", 0, SV_IREG_MIC, 0, 15, 1),\nSONICVIBES_SINGLE(\"Mic Boost\", 0, SV_IREG_LEFT_ADC, 4, 1, 0),\nSONICVIBES_DOUBLE(\"Synth Playback Switch\", 0, SV_IREG_LEFT_SYNTH, SV_IREG_RIGHT_SYNTH, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"Synth Playback Volume\", 0, SV_IREG_LEFT_SYNTH, SV_IREG_RIGHT_SYNTH, 0, 0, 31, 1),\nSONICVIBES_DOUBLE(\"Aux Playback Switch\", 1, SV_IREG_LEFT_AUX2, SV_IREG_RIGHT_AUX2, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"Aux Playback Volume\", 1, SV_IREG_LEFT_AUX2, SV_IREG_RIGHT_AUX2, 0, 0, 31, 1),\nSONICVIBES_DOUBLE(\"Master Playback Switch\", 0, SV_IREG_LEFT_ANALOG, SV_IREG_RIGHT_ANALOG, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"Master Playback Volume\", 0, SV_IREG_LEFT_ANALOG, SV_IREG_RIGHT_ANALOG, 0, 0, 31, 1),\nSONICVIBES_DOUBLE(\"PCM Playback Switch\", 0, SV_IREG_LEFT_PCM, SV_IREG_RIGHT_PCM, 7, 7, 1, 1),\nSONICVIBES_DOUBLE(\"PCM Playback Volume\", 0, SV_IREG_LEFT_PCM, SV_IREG_RIGHT_PCM, 0, 0, 63, 1),\nSONICVIBES_SINGLE(\"Loopback Capture Switch\", 0, SV_IREG_ADC_OUTPUT_CTRL, 0, 1, 0),\nSONICVIBES_SINGLE(\"Loopback Capture Volume\", 0, SV_IREG_ADC_OUTPUT_CTRL, 2, 63, 1),\nSONICVIBES_MUX(\"Capture Source\", 0)\n};\n\nstatic void snd_sonicvibes_master_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\n\tsonic->master_mute = NULL;\n\tsonic->master_volume = NULL;\n}\n\nstatic int snd_sonicvibes_mixer(struct sonicvibes *sonic)\n{\n\tstruct snd_card *card;\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tint err;\n\n\tif (snd_BUG_ON(!sonic || !sonic->card))\n\t\treturn -EINVAL;\n\tcard = sonic->card;\n\tstrcpy(card->mixername, \"S3 SonicVibes\");\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_sonicvibes_controls[idx], sonic);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tswitch (idx) {\n\t\tcase 0:\n\t\tcase 1: kctl->private_free = snd_sonicvibes_master_free; break;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void snd_sonicvibes_proc_read(struct snd_info_entry *entry, \n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct sonicvibes *sonic = entry->private_data;\n\tunsigned char tmp;\n\n\ttmp = sonic->srs_space & 0x0f;\n\tsnd_iprintf(buffer, \"SRS 3D           : %s\\n\",\n\t\t    sonic->srs_space & 0x80 ? \"off\" : \"on\");\n\tsnd_iprintf(buffer, \"SRS Space        : %s\\n\",\n\t\t    tmp == 0x00 ? \"100%\" :\n\t\t    tmp == 0x01 ? \"75%\" :\n\t\t    tmp == 0x02 ? \"50%\" :\n\t\t    tmp == 0x03 ? \"25%\" : \"0%\");\n\ttmp = sonic->srs_center & 0x0f;\n\tsnd_iprintf(buffer, \"SRS Center       : %s\\n\",\n\t\t    tmp == 0x00 ? \"100%\" :\n\t\t    tmp == 0x01 ? \"75%\" :\n\t\t    tmp == 0x02 ? \"50%\" :\n\t\t    tmp == 0x03 ? \"25%\" : \"0%\");\n\ttmp = sonic->wave_source & 0x03;\n\tsnd_iprintf(buffer, \"WaveTable Source : %s\\n\",\n\t\t    tmp == 0x00 ? \"on-board ROM\" :\n\t\t    tmp == 0x01 ? \"PCI bus\" : \"on-board ROM + PCI bus\");\n\ttmp = sonic->mpu_switch;\n\tsnd_iprintf(buffer, \"Onboard synth    : %s\\n\", tmp & 0x01 ? \"on\" : \"off\");\n\tsnd_iprintf(buffer, \"Ext. Rx to synth : %s\\n\", tmp & 0x02 ? \"on\" : \"off\");\n\tsnd_iprintf(buffer, \"MIDI to ext. Tx  : %s\\n\", tmp & 0x04 ? \"on\" : \"off\");\n}\n\nstatic void snd_sonicvibes_proc_init(struct sonicvibes *sonic)\n{\n\tsnd_card_ro_proc_new(sonic->card, \"sonicvibes\", sonic,\n\t\t\t     snd_sonicvibes_proc_read);\n}\n\n \n\n#ifdef SUPPORT_JOYSTICK\nstatic const struct snd_kcontrol_new snd_sonicvibes_game_control =\nSONICVIBES_SINGLE(\"Joystick Speed\", 0, SV_IREG_GAME_PORT, 1, 15, 0);\n\nstatic int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)\n{\n\tstruct gameport *gp;\n\tint err;\n\n\tsonic->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(sonic->card->dev,\n\t\t\t\"sonicvibes: cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"SonicVibes Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(sonic->pci));\n\tgameport_set_dev_parent(gp, &sonic->pci->dev);\n\tgp->io = sonic->game_port;\n\n\tgameport_register_port(gp);\n\n\terr = snd_ctl_add(sonic->card,\n\t\tsnd_ctl_new1(&snd_sonicvibes_game_control, sonic));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void snd_sonicvibes_free_gameport(struct sonicvibes *sonic)\n{\n\tif (sonic->gameport) {\n\t\tgameport_unregister_port(sonic->gameport);\n\t\tsonic->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_sonicvibes_create_gameport(struct sonicvibes *sonic) { return -ENOSYS; }\nstatic inline void snd_sonicvibes_free_gameport(struct sonicvibes *sonic) { }\n#endif\n\nstatic void snd_sonicvibes_free(struct snd_card *card)\n{\n\tstruct sonicvibes *sonic = card->private_data;\n\n\tsnd_sonicvibes_free_gameport(sonic);\n\tpci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);\n\tpci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);\n}\n\nstatic int snd_sonicvibes_create(struct snd_card *card,\n\t\t\t\t struct pci_dev *pci,\n\t\t\t\t int reverb,\n\t\t\t\t int mge)\n{\n\tstruct sonicvibes *sonic = card->private_data;\n\tunsigned int dmaa, dmac;\n\tint err;\n\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(24))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 24bit PCI busmaster DMA\\n\");\n                return -ENXIO;\n        }\n\n\tspin_lock_init(&sonic->reg_lock);\n\tsonic->card = card;\n\tsonic->pci = pci;\n\tsonic->irq = -1;\n\n\terr = pci_request_regions(pci, \"S3 SonicVibes\");\n\tif (err < 0)\n\t\treturn err;\n\n\tsonic->sb_port = pci_resource_start(pci, 0);\n\tsonic->enh_port = pci_resource_start(pci, 1);\n\tsonic->synth_port = pci_resource_start(pci, 2);\n\tsonic->midi_port = pci_resource_start(pci, 3);\n\tsonic->game_port = pci_resource_start(pci, 4);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_sonicvibes_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, sonic)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tsonic->irq = pci->irq;\n\tcard->sync_irq = sonic->irq;\n\tcard->private_free = snd_sonicvibes_free;\n\n\tpci_read_config_dword(pci, 0x40, &dmaa);\n\tpci_read_config_dword(pci, 0x48, &dmac);\n\tdmaio &= ~0x0f;\n\tdmaa &= ~0x0f;\n\tdmac &= ~0x0f;\n\tif (!dmaa) {\n\t\tdmaa = dmaio;\n\t\tdmaio += 0x10;\n\t\tdev_info(card->dev,\n\t\t\t \"BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\\n\",\n\t\t\t dmaa);\n\t}\n\tif (!dmac) {\n\t\tdmac = dmaio;\n\t\tdmaio += 0x10;\n\t\tdev_info(card->dev,\n\t\t\t \"BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\\n\",\n\t\t\t dmac);\n\t}\n\tpci_write_config_dword(pci, 0x40, dmaa);\n\tpci_write_config_dword(pci, 0x48, dmac);\n\n\tsonic->res_dmaa = devm_request_region(&pci->dev, dmaa, 0x10,\n\t\t\t\t\t      \"S3 SonicVibes DDMA-A\");\n\tif (!sonic->res_dmaa) {\n\t\tdev_err(card->dev,\n\t\t\t\"unable to grab DDMA-A port at 0x%x-0x%x\\n\",\n\t\t\tdmaa, dmaa + 0x10 - 1);\n\t\treturn -EBUSY;\n\t}\n\tsonic->res_dmac = devm_request_region(&pci->dev, dmac, 0x10,\n\t\t\t\t\t      \"S3 SonicVibes DDMA-C\");\n\tif (!sonic->res_dmac) {\n\t\tdev_err(card->dev,\n\t\t\t\"unable to grab DDMA-C port at 0x%x-0x%x\\n\",\n\t\t\tdmac, dmac + 0x10 - 1);\n\t\treturn -EBUSY;\n\t}\n\n\tpci_read_config_dword(pci, 0x40, &sonic->dmaa_port);\n\tpci_read_config_dword(pci, 0x48, &sonic->dmac_port);\n\tsonic->dmaa_port &= ~0x0f;\n\tsonic->dmac_port &= ~0x0f;\n\tpci_write_config_dword(pci, 0x40, sonic->dmaa_port | 9);\t \n\tpci_write_config_dword(pci, 0x48, sonic->dmac_port | 9);\t \n\t \n\toutb(SV_RESET, SV_REG(sonic, CONTROL));\t\t \n\tudelay(100);\n\toutb(0, SV_REG(sonic, CONTROL));\t \n\tudelay(100);\n\toutb(SV_ENHANCED | SV_INTA | (reverb ? SV_REVERB : 0), SV_REG(sonic, CONTROL));\n\tinb(SV_REG(sonic, STATUS));\t \n#if 1\n\tsnd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0);\t \n#else\n\tsnd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0x40);\t \n#endif\n\tsnd_sonicvibes_out(sonic, SV_IREG_PC_ENABLE, sonic->enable = 0);\t \n\toutb(sonic->irqmask = ~(SV_DMAA_MASK | SV_DMAC_MASK | SV_UD_MASK), SV_REG(sonic, IRQMASK));\n\tinb(SV_REG(sonic, STATUS));\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_ADC_CLOCK, 0);\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_ANALOG_POWER, 0);\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_DIGITAL_POWER, 0);\t \n\tsnd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, 8000);\n\tsnd_sonicvibes_out(sonic, SV_IREG_SRS_SPACE, sonic->srs_space = 0x80);\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_SRS_CENTER, sonic->srs_center = 0x00); \n\tsnd_sonicvibes_out(sonic, SV_IREG_MPU401, sonic->mpu_switch = 0x05);\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_WAVE_SOURCE, sonic->wave_source = 0x00);\t \n\tsnd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_LOW, (8000 * 65536 / SV_FULLRATE) & 0xff);\n\tsnd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_HIGH, ((8000 * 65536 / SV_FULLRATE) >> 8) & 0xff);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_ADC, mge ? 0xd0 : 0xc0);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_ADC, 0xc0);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX1, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX1, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_CD, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_CD, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_LINE, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_LINE, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_MIC, 0x8f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_SYNTH, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_SYNTH, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX2, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX2, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_ANALOG, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_ANALOG, 0x9f);\n\tsnd_sonicvibes_out(sonic, SV_IREG_LEFT_PCM, 0xbf);\n\tsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_PCM, 0xbf);\n\tsnd_sonicvibes_out(sonic, SV_IREG_ADC_OUTPUT_CTRL, 0xfc);\n#if 0\n\tsnd_sonicvibes_debug(sonic);\n#endif\n\tsonic->revision = snd_sonicvibes_in(sonic, SV_IREG_REVISION);\n\n\tsnd_sonicvibes_proc_init(sonic);\n\treturn 0;\n}\n\n \n\nstatic const struct snd_kcontrol_new snd_sonicvibes_midi_controls[] = {\nSONICVIBES_SINGLE(\"SonicVibes Wave Source RAM\", 0, SV_IREG_WAVE_SOURCE, 0, 1, 0),\nSONICVIBES_SINGLE(\"SonicVibes Wave Source RAM+ROM\", 0, SV_IREG_WAVE_SOURCE, 1, 1, 0),\nSONICVIBES_SINGLE(\"SonicVibes Onboard Synth\", 0, SV_IREG_MPU401, 0, 1, 0),\nSONICVIBES_SINGLE(\"SonicVibes External Rx to Synth\", 0, SV_IREG_MPU401, 1, 1, 0),\nSONICVIBES_SINGLE(\"SonicVibes External Tx\", 0, SV_IREG_MPU401, 2, 1, 0)\n};\n\nstatic int snd_sonicvibes_midi_input_open(struct snd_mpu401 * mpu)\n{\n\tstruct sonicvibes *sonic = mpu->private_data;\n\toutb(sonic->irqmask &= ~SV_MIDI_MASK, SV_REG(sonic, IRQMASK));\n\treturn 0;\n}\n\nstatic void snd_sonicvibes_midi_input_close(struct snd_mpu401 * mpu)\n{\n\tstruct sonicvibes *sonic = mpu->private_data;\n\toutb(sonic->irqmask |= SV_MIDI_MASK, SV_REG(sonic, IRQMASK));\n}\n\nstatic int snd_sonicvibes_midi(struct sonicvibes *sonic,\n\t\t\t       struct snd_rawmidi *rmidi)\n{\n\tstruct snd_mpu401 * mpu = rmidi->private_data;\n\tstruct snd_card *card = sonic->card;\n\tunsigned int idx;\n\tint err;\n\n\tmpu->private_data = sonic;\n\tmpu->open_input = snd_sonicvibes_midi_input_open;\n\tmpu->close_input = snd_sonicvibes_midi_input_close;\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_midi_controls); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_sonicvibes_midi_controls[idx], sonic));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int __snd_sonic_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct sonicvibes *sonic;\n\tstruct snd_rawmidi *midi_uart;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n \n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*sonic), &card);\n\tif (err < 0)\n\t\treturn err;\n\tsonic = card->private_data;\n\terr = snd_sonicvibes_create(card, pci,\n\t\t\t\t    reverb[dev] ? 1 : 0,\n\t\t\t\t    mge[dev] ? 1 : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"SonicVibes\");\n\tstrcpy(card->shortname, \"S3 SonicVibes\");\n\tsprintf(card->longname, \"%s rev %i at 0x%llx, irq %i\",\n\t\tcard->shortname,\n\t\tsonic->revision,\n\t\t(unsigned long long)pci_resource_start(pci, 1),\n\t\tsonic->irq);\n\n\terr = snd_sonicvibes_pcm(sonic, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_sonicvibes_mixer(sonic);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_SONICVIBES,\n\t\t\t\t  sonic->midi_port,\n\t\t\t\t  MPU401_INFO_INTEGRATED |\n\t\t\t\t  MPU401_INFO_IRQ_HOOK,\n\t\t\t\t  -1, &midi_uart);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_sonicvibes_midi(sonic, midi_uart);\n\terr = snd_opl3_create(card, sonic->synth_port,\n\t\t\t      sonic->synth_port + 2,\n\t\t\t      OPL3_HW_OPL3_SV, 1, &opl3);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_sonicvibes_create_gameport(sonic);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_sonic_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_sonic_probe(pci, pci_id));\n}\n\nstatic struct pci_driver sonicvibes_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_sonic_ids,\n\t.probe = snd_sonic_probe,\n};\n\nmodule_pci_driver(sonicvibes_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}