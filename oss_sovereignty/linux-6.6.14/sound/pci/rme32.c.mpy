{
  "module_name": "rme32.c",
  "hash_id": "1887169ff1bd806fd17017394eaa83e0092c3b89ada6631b34ab3d22501d4a54",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/rme32.c",
  "human_readable_source": "\n \n\n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm-indirect.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic bool fullduplex[SNDRV_CARDS];  \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for RME Digi32 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for RME Digi32 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable RME Digi32 soundcard.\");\nmodule_param_array(fullduplex, bool, NULL, 0444);\nMODULE_PARM_DESC(fullduplex, \"Support full-duplex mode.\");\nMODULE_AUTHOR(\"Martin Langer <martin-langer@gmx.de>, Pilo Chambert <pilo.c@wanadoo.fr>\");\nMODULE_DESCRIPTION(\"RME Digi32, Digi32/8, Digi32 PRO\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define RME32_SPDIF_NCHANNELS 2\n\n \n#define RME32_BUFFER_SIZE 0x20000\n\n \n#define RME32_IO_SIZE 0x30000\n\n \n#define RME32_IO_DATA_BUFFER        0x0\n#define RME32_IO_CONTROL_REGISTER   0x20000\n#define RME32_IO_GET_POS            0x20000\n#define RME32_IO_CONFIRM_ACTION_IRQ 0x20004\n#define RME32_IO_RESET_POS          0x20100\n\n \n#define RME32_WCR_START     (1 << 0)     \n#define RME32_WCR_MONO      (1 << 1)     \n#define RME32_WCR_MODE24    (1 << 2)     \n#define RME32_WCR_SEL       (1 << 3)     \n#define RME32_WCR_FREQ_0    (1 << 4)     \n#define RME32_WCR_FREQ_1    (1 << 5)\n#define RME32_WCR_INP_0     (1 << 6)     \n#define RME32_WCR_INP_1     (1 << 7)\n#define RME32_WCR_RESET     (1 << 8)     \n#define RME32_WCR_MUTE      (1 << 9)     \n#define RME32_WCR_PRO       (1 << 10)    \n#define RME32_WCR_DS_BM     (1 << 11)\t \n#define RME32_WCR_ADAT      (1 << 12)\t \n#define RME32_WCR_AUTOSYNC  (1 << 13)    \n#define RME32_WCR_PD        (1 << 14)\t \n#define RME32_WCR_EMP       (1 << 15)\t \n\n#define RME32_WCR_BITPOS_FREQ_0 4\n#define RME32_WCR_BITPOS_FREQ_1 5\n#define RME32_WCR_BITPOS_INP_0 6\n#define RME32_WCR_BITPOS_INP_1 7\n\n \n#define RME32_RCR_AUDIO_ADDR_MASK 0x1ffff\n#define RME32_RCR_LOCK      (1 << 23)    \n#define RME32_RCR_ERF       (1 << 26)    \n#define RME32_RCR_FREQ_0    (1 << 27)    \n#define RME32_RCR_FREQ_1    (1 << 28)\n#define RME32_RCR_FREQ_2    (1 << 29)\n#define RME32_RCR_KMODE     (1 << 30)    \n#define RME32_RCR_IRQ       (1 << 31)    \n\n#define RME32_RCR_BITPOS_F0 27\n#define RME32_RCR_BITPOS_F1 28\n#define RME32_RCR_BITPOS_F2 29\n\n \n#define RME32_INPUT_OPTICAL 0\n#define RME32_INPUT_COAXIAL 1\n#define RME32_INPUT_INTERNAL 2\n#define RME32_INPUT_XLR 3\n\n \n#define RME32_CLOCKMODE_SLAVE 0\n#define RME32_CLOCKMODE_MASTER_32 1\n#define RME32_CLOCKMODE_MASTER_44 2\n#define RME32_CLOCKMODE_MASTER_48 3\n\n \n#define RME32_BLOCK_SIZE 8192\n\n \n#define RME32_MID_BUFFER_SIZE (1024*1024)\n\n \n#define RME32_32_REVISION 192\n#define RME32_328_REVISION_OLD 100\n#define RME32_328_REVISION_NEW 101\n#define RME32_PRO_REVISION_WITH_8412 192\n#define RME32_PRO_REVISION_WITH_8414 150\n\n\nstruct rme32 {\n\tspinlock_t lock;\n\tint irq;\n\tunsigned long port;\n\tvoid __iomem *iobase;\n\n\tu32 wcreg;\t\t \n\tu32 wcreg_spdif;\t \n\tu32 wcreg_spdif_stream;\t \n\tu32 rcreg;\t\t \n\n\tu8 rev;\t\t\t \n\n\tstruct snd_pcm_substream *playback_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\n\tint playback_frlog;\t \n\tint capture_frlog;\n\n\tsize_t playback_periodsize;\t \n\tsize_t capture_periodsize;\t \n\n\tunsigned int fullduplex_mode;\n\tint running;\n\n\tstruct snd_pcm_indirect playback_pcm;\n\tstruct snd_pcm_indirect capture_pcm;\n\n\tstruct snd_card *card;\n\tstruct snd_pcm *spdif_pcm;\n\tstruct snd_pcm *adat_pcm;\n\tstruct pci_dev *pci;\n\tstruct snd_kcontrol *spdif_ctl;\n};\n\nstatic const struct pci_device_id snd_rme32_ids[] = {\n\t{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32), 0,},\n\t{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8), 0,},\n\t{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO), 0,},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_rme32_ids);\n\n#define RME32_ISWORKING(rme32) ((rme32)->wcreg & RME32_WCR_START)\n#define RME32_PRO_WITH_8414(rme32) ((rme32)->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO && (rme32)->rev == RME32_PRO_REVISION_WITH_8414)\n\nstatic int snd_rme32_playback_prepare(struct snd_pcm_substream *substream);\n\nstatic int snd_rme32_capture_prepare(struct snd_pcm_substream *substream);\n\nstatic int snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd);\n\nstatic void snd_rme32_proc_init(struct rme32 * rme32);\n\nstatic int snd_rme32_create_switches(struct snd_card *card, struct rme32 * rme32);\n\nstatic inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)\n{\n\treturn (readl(rme32->iobase + RME32_IO_GET_POS)\n\t\t& RME32_RCR_AUDIO_ADDR_MASK);\n}\n\n \nstatic int snd_rme32_playback_silence(struct snd_pcm_substream *substream,\n\t\t\t\t      int channel, unsigned long pos,\n\t\t\t\t      unsigned long count)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\tmemset_io(rme32->iobase + RME32_IO_DATA_BUFFER + pos, 0, count);\n\treturn 0;\n}\n\n \nstatic int snd_rme32_playback_copy(struct snd_pcm_substream *substream,\n\t\t\t\t   int channel, unsigned long pos,\n\t\t\t\t   struct iov_iter *src, unsigned long count)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\treturn copy_from_iter_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,\n\t\t\t\t   src, count);\n}\n\n \nstatic int snd_rme32_capture_copy(struct snd_pcm_substream *substream,\n\t\t\t\t  int channel, unsigned long pos,\n\t\t\t\t  struct iov_iter *dst, unsigned long count)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\treturn copy_to_iter_fromio(dst,\n\t\t\t\t   rme32->iobase + RME32_IO_DATA_BUFFER + pos,\n\t\t\t\t   count);\n}\n\n \nstatic const struct snd_pcm_hardware snd_rme32_spdif_info = {\n\t.info =\t\t(SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t SNDRV_PCM_INFO_INTERLEAVED | \n\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =\t(SNDRV_PCM_FMTBIT_S16_LE | \n\t\t\t SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =\t(SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 | \n\t\t\t SNDRV_PCM_RATE_48000),\n\t.rate_min =\t32000,\n\t.rate_max =\t48000,\n\t.channels_min =\t2,\n\t.channels_max =\t2,\n\t.buffer_bytes_max = RME32_BUFFER_SIZE,\n\t.period_bytes_min = RME32_BLOCK_SIZE,\n\t.period_bytes_max = RME32_BLOCK_SIZE,\n\t.periods_min =\tRME32_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.periods_max =\tRME32_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.fifo_size =\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme32_adat_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats=            SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =             (SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000),\n\t.rate_min =          44100,\n\t.rate_max =          48000,\n\t.channels_min =      8,\n\t.channels_max =\t     8,\n\t.buffer_bytes_max =  RME32_BUFFER_SIZE,\n\t.period_bytes_min =  RME32_BLOCK_SIZE,\n\t.period_bytes_max =  RME32_BLOCK_SIZE,\n\t.periods_min =\t    RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.periods_max =\t    RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.fifo_size =\t    0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme32_spdif_fd_info = {\n\t.info =\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t SNDRV_PCM_INFO_INTERLEAVED | \n\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =\t(SNDRV_PCM_FMTBIT_S16_LE | \n\t\t\t SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =\t(SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 | \n\t\t\t SNDRV_PCM_RATE_48000),\n\t.rate_min =\t32000,\n\t.rate_max =\t48000,\n\t.channels_min =\t2,\n\t.channels_max =\t2,\n\t.buffer_bytes_max = RME32_MID_BUFFER_SIZE,\n\t.period_bytes_min = RME32_BLOCK_SIZE,\n\t.period_bytes_max = RME32_BLOCK_SIZE,\n\t.periods_min =\t2,\n\t.periods_max =\tRME32_MID_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.fifo_size =\t0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme32_adat_fd_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats=            SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =             (SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000),\n\t.rate_min =          44100,\n\t.rate_max =          48000,\n\t.channels_min =      8,\n\t.channels_max =\t     8,\n\t.buffer_bytes_max =  RME32_MID_BUFFER_SIZE,\n\t.period_bytes_min =  RME32_BLOCK_SIZE,\n\t.period_bytes_max =  RME32_BLOCK_SIZE,\n\t.periods_min =\t    2,\n\t.periods_max =\t    RME32_MID_BUFFER_SIZE / RME32_BLOCK_SIZE,\n\t.fifo_size =\t    0,\n};\n\nstatic void snd_rme32_reset_dac(struct rme32 *rme32)\n{\n        writel(rme32->wcreg | RME32_WCR_PD,\n               rme32->iobase + RME32_IO_CONTROL_REGISTER);\n        writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n}\n\nstatic int snd_rme32_playback_getrate(struct rme32 * rme32)\n{\n\tint rate;\n\n\trate = ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +\n\t       (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);\n\tswitch (rate) {\n\tcase 1:\n\t\trate = 32000;\n\t\tbreak;\n\tcase 2:\n\t\trate = 44100;\n\t\tbreak;\n\tcase 3:\n\t\trate = 48000;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn (rme32->wcreg & RME32_WCR_DS_BM) ? rate << 1 : rate;\n}\n\nstatic int snd_rme32_capture_getrate(struct rme32 * rme32, int *is_adat)\n{\n\tint n;\n\n\t*is_adat = 0;\n\tif (rme32->rcreg & RME32_RCR_LOCK) { \n                 \n                *is_adat = 1;\n\t}\n\tif (rme32->rcreg & RME32_RCR_ERF) {\n\t\treturn -1;\n\t}\n\n         \n\tn = ((rme32->rcreg >> RME32_RCR_BITPOS_F0) & 1) +\n\t\t(((rme32->rcreg >> RME32_RCR_BITPOS_F1) & 1) << 1) +\n\t\t(((rme32->rcreg >> RME32_RCR_BITPOS_F2) & 1) << 2);\n\n\tif (RME32_PRO_WITH_8414(rme32))\n\t\tswitch (n) {\t \n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\treturn -1;\n\t\tcase 3:\n\t\t\treturn 96000;\n\t\tcase 4:\n\t\t\treturn 88200;\n\t\tcase 5:\n\t\t\treturn 48000;\n\t\tcase 6:\n\t\t\treturn 44100;\n\t\tcase 7:\n\t\t\treturn 32000;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t} \n\telse\n\t\tswitch (n) {\t \n\t\tcase 0:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\treturn 48000;\n\t\tcase 2:\n\t\t\treturn 44100;\n\t\tcase 3:\n\t\t\treturn 32000;\n\t\tcase 4:\n\t\t\treturn 48000;\n\t\tcase 5:\n\t\t\treturn 44100;\n\t\tcase 6:\n\t\t\treturn 44056;\n\t\tcase 7:\n\t\t\treturn 32000;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\treturn -1;\n}\n\nstatic int snd_rme32_playback_setrate(struct rme32 * rme32, int rate)\n{\n        int ds;\n\n        ds = rme32->wcreg & RME32_WCR_DS_BM;\n\tswitch (rate) {\n\tcase 32000:\n\t\trme32->wcreg &= ~RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & \n\t\t\t~RME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase 44100:\n\t\trme32->wcreg &= ~RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & \n\t\t\t~RME32_WCR_FREQ_0;\n\t\tbreak;\n\tcase 48000:\n\t\trme32->wcreg &= ~RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | \n\t\t\tRME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase 64000:\n\t\tif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\n\t\t\treturn -EINVAL;\n\t\trme32->wcreg |= RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & \n\t\t\t~RME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase 88200:\n\t\tif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\n\t\t\treturn -EINVAL;\n\t\trme32->wcreg |= RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & \n\t\t\t~RME32_WCR_FREQ_0;\n\t\tbreak;\n\tcase 96000:\n\t\tif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\n\t\t\treturn -EINVAL;\n\t\trme32->wcreg |= RME32_WCR_DS_BM;\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | \n\t\t\tRME32_WCR_FREQ_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n        if ((!ds && rme32->wcreg & RME32_WCR_DS_BM) ||\n            (ds && !(rme32->wcreg & RME32_WCR_DS_BM)))\n        {\n                 \n                snd_rme32_reset_dac(rme32);\n        } else {\n                writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme32_setclockmode(struct rme32 * rme32, int mode)\n{\n\tswitch (mode) {\n\tcase RME32_CLOCKMODE_SLAVE:\n\t\t \n\t\trme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) & \n\t\t\t~RME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase RME32_CLOCKMODE_MASTER_32:\n\t\t \n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & \n\t\t\t~RME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase RME32_CLOCKMODE_MASTER_44:\n\t\t \n\t\trme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) | \n\t\t\tRME32_WCR_FREQ_1;\n\t\tbreak;\n\tcase RME32_CLOCKMODE_MASTER_48:\n\t\t \n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | \n\t\t\tRME32_WCR_FREQ_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int snd_rme32_getclockmode(struct rme32 * rme32)\n{\n\treturn ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +\n\t    (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);\n}\n\nstatic int snd_rme32_setinputtype(struct rme32 * rme32, int type)\n{\n\tswitch (type) {\n\tcase RME32_INPUT_OPTICAL:\n\t\trme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) & \n\t\t\t~RME32_WCR_INP_1;\n\t\tbreak;\n\tcase RME32_INPUT_COAXIAL:\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) & \n\t\t\t~RME32_WCR_INP_1;\n\t\tbreak;\n\tcase RME32_INPUT_INTERNAL:\n\t\trme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) | \n\t\t\tRME32_WCR_INP_1;\n\t\tbreak;\n\tcase RME32_INPUT_XLR:\n\t\trme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) | \n\t\t\tRME32_WCR_INP_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int snd_rme32_getinputtype(struct rme32 * rme32)\n{\n\treturn ((rme32->wcreg >> RME32_WCR_BITPOS_INP_0) & 1) +\n\t    (((rme32->wcreg >> RME32_WCR_BITPOS_INP_1) & 1) << 1);\n}\n\nstatic void\nsnd_rme32_setframelog(struct rme32 * rme32, int n_channels, int is_playback)\n{\n\tint frlog;\n\n\tif (n_channels == 2) {\n\t\tfrlog = 1;\n\t} else {\n\t\t \n\t\tfrlog = 3;\n\t}\n\tif (is_playback) {\n\t\tfrlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;\n\t\trme32->playback_frlog = frlog;\n\t} else {\n\t\tfrlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;\n\t\trme32->capture_frlog = frlog;\n\t}\n}\n\nstatic int snd_rme32_setformat(struct rme32 *rme32, snd_pcm_format_t format)\n{\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trme32->wcreg &= ~RME32_WCR_MODE24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\trme32->wcreg |= RME32_WCR_MODE24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tint err, rate, dummy;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (!rme32->fullduplex_mode) {\n\t\truntime->dma_area = (void __force *)(rme32->iobase +\n\t\t\t\t\t\t     RME32_IO_DATA_BUFFER);\n\t\truntime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;\n\t\truntime->dma_bytes = RME32_BUFFER_SIZE;\n\t}\n\n\tspin_lock_irq(&rme32->lock);\n\trate = 0;\n\tif (rme32->rcreg & RME32_RCR_KMODE)\n\t\trate = snd_rme32_capture_getrate(rme32, &dummy);\n\tif (rate > 0) {\n\t\t \n\t\tif ((int)params_rate(params) != rate) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\terr = snd_rme32_playback_setrate(rme32, params_rate(params));\n\t\tif (err < 0) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = snd_rme32_setformat(rme32, params_format(params));\n\tif (err < 0) {\n\t\tspin_unlock_irq(&rme32->lock);\n\t\treturn err;\n\t}\n\n\tsnd_rme32_setframelog(rme32, params_channels(params), 1);\n\tif (rme32->capture_periodsize != 0) {\n\t\tif (params_period_size(params) << rme32->playback_frlog != rme32->capture_periodsize) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\trme32->playback_periodsize = params_period_size(params) << rme32->playback_frlog;\n\t \n\tif ((rme32->wcreg & RME32_WCR_ADAT) == 0) {\n\t\trme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);\n\t\trme32->wcreg |= rme32->wcreg_spdif_stream;\n\t\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\t}\n\tspin_unlock_irq(&rme32->lock);\n\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tint err, isadat, rate;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (!rme32->fullduplex_mode) {\n\t\truntime->dma_area = (void __force *)rme32->iobase +\n\t\t\t\t\tRME32_IO_DATA_BUFFER;\n\t\truntime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;\n\t\truntime->dma_bytes = RME32_BUFFER_SIZE;\n\t}\n\n\tspin_lock_irq(&rme32->lock);\n\t \n\trme32->wcreg |= RME32_WCR_AUTOSYNC;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\n\terr = snd_rme32_setformat(rme32, params_format(params));\n\tif (err < 0) {\n\t\tspin_unlock_irq(&rme32->lock);\n\t\treturn err;\n\t}\n\terr = snd_rme32_playback_setrate(rme32, params_rate(params));\n\tif (err < 0) {\n\t\tspin_unlock_irq(&rme32->lock);\n\t\treturn err;\n\t}\n\trate = snd_rme32_capture_getrate(rme32, &isadat);\n\tif (rate > 0) {\n                if ((int)params_rate(params) != rate) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n                        return -EIO;                    \n                }\n                if ((isadat && runtime->hw.channels_min == 2) ||\n                    (!isadat && runtime->hw.channels_min == 8)) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n                        return -EIO;\n                }\n\t}\n\t \n\trme32->wcreg &= ~RME32_WCR_AUTOSYNC;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\n\tsnd_rme32_setframelog(rme32, params_channels(params), 0);\n\tif (rme32->playback_periodsize != 0) {\n\t\tif (params_period_size(params) << rme32->capture_frlog !=\n\t\t    rme32->playback_periodsize) {\n\t\t\tspin_unlock_irq(&rme32->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\trme32->capture_periodsize =\n\t    params_period_size(params) << rme32->capture_frlog;\n\tspin_unlock_irq(&rme32->lock);\n\n\treturn 0;\n}\n\nstatic void snd_rme32_pcm_start(struct rme32 * rme32, int from_pause)\n{\n\tif (!from_pause) {\n\t\twritel(0, rme32->iobase + RME32_IO_RESET_POS);\n\t}\n\n\trme32->wcreg |= RME32_WCR_START;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n}\n\nstatic void snd_rme32_pcm_stop(struct rme32 * rme32, int to_pause)\n{\n\t \n\trme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tif (rme32->rcreg & RME32_RCR_IRQ) {\n\t\twritel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);\n\t}\n\trme32->wcreg &= ~RME32_WCR_START;\n\tif (rme32->wcreg & RME32_WCR_SEL)\n\t\trme32->wcreg |= RME32_WCR_MUTE;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tif (! to_pause)\n\t\twritel(0, rme32->iobase + RME32_IO_RESET_POS);\n}\n\nstatic irqreturn_t snd_rme32_interrupt(int irq, void *dev_id)\n{\n\tstruct rme32 *rme32 = (struct rme32 *) dev_id;\n\n\trme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tif (!(rme32->rcreg & RME32_RCR_IRQ)) {\n\t\treturn IRQ_NONE;\n\t} else {\n\t\tif (rme32->capture_substream) {\n\t\t\tsnd_pcm_period_elapsed(rme32->capture_substream);\n\t\t}\n\t\tif (rme32->playback_substream) {\n\t\t\tsnd_pcm_period_elapsed(rme32->playback_substream);\n\t\t}\n\t\twritel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const unsigned int period_bytes[] = { RME32_BLOCK_SIZE };\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {\n\t.count = ARRAY_SIZE(period_bytes),\n\t.list = period_bytes,\n\t.mask = 0\n};\n\nstatic void snd_rme32_set_buffer_constraint(struct rme32 *rme32, struct snd_pcm_runtime *runtime)\n{\n\tif (! rme32->fullduplex_mode) {\n\t\tsnd_pcm_hw_constraint_single(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t     RME32_BUFFER_SIZE);\n\t\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t   &hw_constraints_period_bytes);\n\t}\n}\n\nstatic int snd_rme32_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n\tint rate, dummy;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_set_sync(substream);\n\n\tspin_lock_irq(&rme32->lock);\n\tif (rme32->playback_substream != NULL) {\n\t\tspin_unlock_irq(&rme32->lock);\n\t\treturn -EBUSY;\n\t}\n\trme32->wcreg &= ~RME32_WCR_ADAT;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\trme32->playback_substream = substream;\n\tspin_unlock_irq(&rme32->lock);\n\n\tif (rme32->fullduplex_mode)\n\t\truntime->hw = snd_rme32_spdif_fd_info;\n\telse\n\t\truntime->hw = snd_rme32_spdif_info;\n\tif (rme32->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;\n\t\truntime->hw.rate_max = 96000;\n\t}\n\trate = 0;\n\tif (rme32->rcreg & RME32_RCR_KMODE)\n\t\trate = snd_rme32_capture_getrate(rme32, &dummy);\n\tif (rate > 0) {\n\t\t \n\t\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n\t\truntime->hw.rate_min = rate;\n\t\truntime->hw.rate_max = rate;\n\t}       \n\n\tsnd_rme32_set_buffer_constraint(rme32, runtime);\n\n\trme32->wcreg_spdif_stream = rme32->wcreg_spdif;\n\trme32->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &rme32->spdif_ctl->id);\n\treturn 0;\n}\n\nstatic int snd_rme32_capture_spdif_open(struct snd_pcm_substream *substream)\n{\n\tint isadat, rate;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_set_sync(substream);\n\n\tspin_lock_irq(&rme32->lock);\n        if (rme32->capture_substream != NULL) {\n\t\tspin_unlock_irq(&rme32->lock);\n                return -EBUSY;\n        }\n\trme32->capture_substream = substream;\n\tspin_unlock_irq(&rme32->lock);\n\n\tif (rme32->fullduplex_mode)\n\t\truntime->hw = snd_rme32_spdif_fd_info;\n\telse\n\t\truntime->hw = snd_rme32_spdif_info;\n\tif (RME32_PRO_WITH_8414(rme32)) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;\n\t\truntime->hw.rate_max = 96000;\n\t}\n\trate = snd_rme32_capture_getrate(rme32, &isadat);\n\tif (rate > 0) {\n\t\tif (isadat) {\n\t\t\treturn -EIO;\n\t\t}\n\t\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n\t\truntime->hw.rate_min = rate;\n\t\truntime->hw.rate_max = rate;\n\t}\n\n\tsnd_rme32_set_buffer_constraint(rme32, runtime);\n\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_playback_adat_open(struct snd_pcm_substream *substream)\n{\n\tint rate, dummy;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\tsnd_pcm_set_sync(substream);\n\n\tspin_lock_irq(&rme32->lock);\t\n        if (rme32->playback_substream != NULL) {\n\t\tspin_unlock_irq(&rme32->lock);\n                return -EBUSY;\n        }\n\trme32->wcreg |= RME32_WCR_ADAT;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\trme32->playback_substream = substream;\n\tspin_unlock_irq(&rme32->lock);\n\t\n\tif (rme32->fullduplex_mode)\n\t\truntime->hw = snd_rme32_adat_fd_info;\n\telse\n\t\truntime->hw = snd_rme32_adat_info;\n\trate = 0;\n\tif (rme32->rcreg & RME32_RCR_KMODE)\n\t\trate = snd_rme32_capture_getrate(rme32, &dummy);\n\tif (rate > 0) {\n                 \n                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n                runtime->hw.rate_min = rate;\n                runtime->hw.rate_max = rate;\n\t}        \n\n\tsnd_rme32_set_buffer_constraint(rme32, runtime);\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_capture_adat_open(struct snd_pcm_substream *substream)\n{\n\tint isadat, rate;\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (rme32->fullduplex_mode)\n\t\truntime->hw = snd_rme32_adat_fd_info;\n\telse\n\t\truntime->hw = snd_rme32_adat_info;\n\trate = snd_rme32_capture_getrate(rme32, &isadat);\n\tif (rate > 0) {\n\t\tif (!isadat) {\n\t\t\treturn -EIO;\n\t\t}\n                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n                runtime->hw.rate_min = rate;\n                runtime->hw.rate_max = rate;\n        }\n\n\tsnd_pcm_set_sync(substream);\n        \n\tspin_lock_irq(&rme32->lock);\t\n\tif (rme32->capture_substream != NULL) {\n\t\tspin_unlock_irq(&rme32->lock);\n\t\treturn -EBUSY;\n        }\n\trme32->capture_substream = substream;\n\tspin_unlock_irq(&rme32->lock);\n\n\tsnd_rme32_set_buffer_constraint(rme32, runtime);\n\treturn 0;\n}\n\nstatic int snd_rme32_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tint spdif = 0;\n\n\tspin_lock_irq(&rme32->lock);\n\trme32->playback_substream = NULL;\n\trme32->playback_periodsize = 0;\n\tspdif = (rme32->wcreg & RME32_WCR_ADAT) == 0;\n\tspin_unlock_irq(&rme32->lock);\n\tif (spdif) {\n\t\trme32->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &rme32->spdif_ctl->id);\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme32_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&rme32->lock);\n\trme32->capture_substream = NULL;\n\trme32->capture_periodsize = 0;\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\n\nstatic int snd_rme32_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&rme32->lock);\n\tif (rme32->fullduplex_mode) {\n\t\tmemset(&rme32->playback_pcm, 0, sizeof(rme32->playback_pcm));\n\t\trme32->playback_pcm.hw_buffer_size = RME32_BUFFER_SIZE;\n\t\trme32->playback_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\t} else {\n\t\twritel(0, rme32->iobase + RME32_IO_RESET_POS);\n\t}\n\tif (rme32->wcreg & RME32_WCR_SEL)\n\t\trme32->wcreg &= ~RME32_WCR_MUTE;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\n\nstatic int snd_rme32_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&rme32->lock);\n\tif (rme32->fullduplex_mode) {\n\t\tmemset(&rme32->capture_pcm, 0, sizeof(rme32->capture_pcm));\n\t\trme32->capture_pcm.hw_buffer_size = RME32_BUFFER_SIZE;\n\t\trme32->capture_pcm.hw_queue_size = RME32_BUFFER_SIZE / 2;\n\t\trme32->capture_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\t} else {\n\t\twritel(0, rme32->iobase + RME32_IO_RESET_POS);\n\t}\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\n\tspin_lock(&rme32->lock);\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (s != rme32->playback_substream &&\n\t\t    s != rme32->capture_substream)\n\t\t\tcontinue;\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\trme32->running |= (1 << s->stream);\n\t\t\tif (rme32->fullduplex_mode) {\n\t\t\t\t \n\t\t\t\tif (s == rme32->playback_substream) {\n\t\t\t\t\trme32->playback_pcm.hw_io =\n\t\t\t\t\trme32->playback_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);\n\t\t\t\t} else {\n\t\t\t\t\trme32->capture_pcm.hw_io =\n\t\t\t\t\trme32->capture_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t\trme32->running &= ~(1 << s->stream);\n\t\t\tbreak;\n\t\t}\n\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\t\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (rme32->running && ! RME32_ISWORKING(rme32))\n\t\t\tsnd_rme32_pcm_start(rme32, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (! rme32->running && RME32_ISWORKING(rme32))\n\t\t\tsnd_rme32_pcm_stop(rme32, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (rme32->running && RME32_ISWORKING(rme32))\n\t\t\tsnd_rme32_pcm_stop(rme32, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (rme32->running && ! RME32_ISWORKING(rme32))\n\t\t\tsnd_rme32_pcm_start(rme32, 1);\n\t\tbreak;\n\t}\n\tspin_unlock(&rme32->lock);\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_rme32_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\treturn snd_rme32_pcm_byteptr(rme32) >> rme32->playback_frlog;\n}\n\nstatic snd_pcm_uframes_t\nsnd_rme32_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\treturn snd_rme32_pcm_byteptr(rme32) >> rme32->capture_frlog;\n}\n\n\n \nstatic void snd_rme32_pb_trans_copy(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tmemcpy_toio(rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,\n\t\t    substream->runtime->dma_area + rec->sw_data, bytes);\n}\n\nstatic int snd_rme32_playback_fd_ack(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_indirect *rec, *cprec;\n\n\trec = &rme32->playback_pcm;\n\tcprec = &rme32->capture_pcm;\n\tspin_lock(&rme32->lock);\n\trec->hw_queue_size = RME32_BUFFER_SIZE;\n\tif (rme32->running & (1 << SNDRV_PCM_STREAM_CAPTURE))\n\t\trec->hw_queue_size -= cprec->hw_ready;\n\tspin_unlock(&rme32->lock);\n\treturn snd_pcm_indirect_playback_transfer(substream, rec,\n\t\t\t\t\t\t  snd_rme32_pb_trans_copy);\n}\n\nstatic void snd_rme32_cp_trans_copy(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\tmemcpy_fromio(substream->runtime->dma_area + rec->sw_data,\n\t\t      rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,\n\t\t      bytes);\n}\n\nstatic int snd_rme32_capture_fd_ack(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\treturn snd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,\n\t\t\t\t\t\t snd_rme32_cp_trans_copy);\n}\n\nstatic snd_pcm_uframes_t\nsnd_rme32_playback_fd_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\treturn snd_pcm_indirect_playback_pointer(substream, &rme32->playback_pcm,\n\t\t\t\t\t\t snd_rme32_pcm_byteptr(rme32));\n}\n\nstatic snd_pcm_uframes_t\nsnd_rme32_capture_fd_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\n\treturn snd_pcm_indirect_capture_pointer(substream, &rme32->capture_pcm,\n\t\t\t\t\t\tsnd_rme32_pcm_byteptr(rme32));\n}\n\n \nstatic const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {\n\t.open =\t\tsnd_rme32_playback_spdif_open,\n\t.close =\tsnd_rme32_playback_close,\n\t.hw_params =\tsnd_rme32_playback_hw_params,\n\t.prepare =\tsnd_rme32_playback_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_playback_pointer,\n\t.copy =\t\tsnd_rme32_playback_copy,\n\t.fill_silence =\tsnd_rme32_playback_silence,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {\n\t.open =\t\tsnd_rme32_capture_spdif_open,\n\t.close =\tsnd_rme32_capture_close,\n\t.hw_params =\tsnd_rme32_capture_hw_params,\n\t.prepare =\tsnd_rme32_capture_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_capture_pointer,\n\t.copy =\t\tsnd_rme32_capture_copy,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_playback_adat_ops = {\n\t.open =\t\tsnd_rme32_playback_adat_open,\n\t.close =\tsnd_rme32_playback_close,\n\t.hw_params =\tsnd_rme32_playback_hw_params,\n\t.prepare =\tsnd_rme32_playback_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_playback_pointer,\n\t.copy =\t\tsnd_rme32_playback_copy,\n\t.fill_silence =\tsnd_rme32_playback_silence,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_capture_adat_ops = {\n\t.open =\t\tsnd_rme32_capture_adat_open,\n\t.close =\tsnd_rme32_capture_close,\n\t.hw_params =\tsnd_rme32_capture_hw_params,\n\t.prepare =\tsnd_rme32_capture_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_capture_pointer,\n\t.copy =\t\tsnd_rme32_capture_copy,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\n \nstatic const struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {\n\t.open =\t\tsnd_rme32_playback_spdif_open,\n\t.close =\tsnd_rme32_playback_close,\n\t.hw_params =\tsnd_rme32_playback_hw_params,\n\t.prepare =\tsnd_rme32_playback_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_playback_fd_pointer,\n\t.ack =\t\tsnd_rme32_playback_fd_ack,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {\n\t.open =\t\tsnd_rme32_capture_spdif_open,\n\t.close =\tsnd_rme32_capture_close,\n\t.hw_params =\tsnd_rme32_capture_hw_params,\n\t.prepare =\tsnd_rme32_capture_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_capture_fd_pointer,\n\t.ack =\t\tsnd_rme32_capture_fd_ack,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {\n\t.open =\t\tsnd_rme32_playback_adat_open,\n\t.close =\tsnd_rme32_playback_close,\n\t.hw_params =\tsnd_rme32_playback_hw_params,\n\t.prepare =\tsnd_rme32_playback_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_playback_fd_pointer,\n\t.ack =\t\tsnd_rme32_playback_fd_ack,\n};\n\nstatic const struct snd_pcm_ops snd_rme32_capture_adat_fd_ops = {\n\t.open =\t\tsnd_rme32_capture_adat_open,\n\t.close =\tsnd_rme32_capture_close,\n\t.hw_params =\tsnd_rme32_capture_hw_params,\n\t.prepare =\tsnd_rme32_capture_prepare,\n\t.trigger =\tsnd_rme32_pcm_trigger,\n\t.pointer =\tsnd_rme32_capture_fd_pointer,\n\t.ack =\t\tsnd_rme32_capture_fd_ack,\n};\n\nstatic void snd_rme32_free(struct rme32 *rme32)\n{\n\tif (rme32->irq >= 0)\n\t\tsnd_rme32_pcm_stop(rme32, 0);\n}\n\nstatic void snd_rme32_free_spdif_pcm(struct snd_pcm *pcm)\n{\n\tstruct rme32 *rme32 = (struct rme32 *) pcm->private_data;\n\trme32->spdif_pcm = NULL;\n}\n\nstatic void\nsnd_rme32_free_adat_pcm(struct snd_pcm *pcm)\n{\n\tstruct rme32 *rme32 = (struct rme32 *) pcm->private_data;\n\trme32->adat_pcm = NULL;\n}\n\nstatic int snd_rme32_create(struct rme32 *rme32)\n{\n\tstruct pci_dev *pci = rme32->pci;\n\tint err;\n\n\trme32->irq = -1;\n\tspin_lock_init(&rme32->lock);\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_request_regions(pci, \"RME32\");\n\tif (err < 0)\n\t\treturn err;\n\trme32->port = pci_resource_start(rme32->pci, 0);\n\n\trme32->iobase = devm_ioremap(&pci->dev, rme32->port, RME32_IO_SIZE);\n\tif (!rme32->iobase) {\n\t\tdev_err(rme32->card->dev,\n\t\t\t\"unable to remap memory region 0x%lx-0x%lx\\n\",\n\t\t\trme32->port, rme32->port + RME32_IO_SIZE - 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_rme32_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, rme32)) {\n\t\tdev_err(rme32->card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\trme32->irq = pci->irq;\n\trme32->card->sync_irq = rme32->irq;\n\n\t \n\tpci_read_config_byte(pci, 8, &rme32->rev);\n\n\t \n\terr = snd_pcm_new(rme32->card, \"Digi32 IEC958\", 0, 1, 1, &rme32->spdif_pcm);\n\tif (err < 0)\n\t\treturn err;\n\trme32->spdif_pcm->private_data = rme32;\n\trme32->spdif_pcm->private_free = snd_rme32_free_spdif_pcm;\n\tstrcpy(rme32->spdif_pcm->name, \"Digi32 IEC958\");\n\tif (rme32->fullduplex_mode) {\n\t\tsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_rme32_playback_spdif_fd_ops);\n\t\tsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_rme32_capture_spdif_fd_ops);\n\t\tsnd_pcm_set_managed_buffer_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t\t       NULL, 0, RME32_MID_BUFFER_SIZE);\n\t\trme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\t} else {\n\t\tsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_rme32_playback_spdif_ops);\n\t\tsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_rme32_capture_spdif_ops);\n\t\trme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\t}\n\n\t \n\tif ((pci->device == PCI_DEVICE_ID_RME_DIGI32) ||\n\t    (pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO)) {\n\t\t \n\t\trme32->adat_pcm = NULL;\n\t}\n\telse {\n\t\terr = snd_pcm_new(rme32->card, \"Digi32 ADAT\", 1,\n\t\t\t\t  1, 1, &rme32->adat_pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\trme32->adat_pcm->private_data = rme32;\n\t\trme32->adat_pcm->private_free = snd_rme32_free_adat_pcm;\n\t\tstrcpy(rme32->adat_pcm->name, \"Digi32 ADAT\");\n\t\tif (rme32->fullduplex_mode) {\n\t\t\tsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, \n\t\t\t\t\t&snd_rme32_playback_adat_fd_ops);\n\t\t\tsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, \n\t\t\t\t\t&snd_rme32_capture_adat_fd_ops);\n\t\t\tsnd_pcm_set_managed_buffer_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t       0, RME32_MID_BUFFER_SIZE);\n\t\t\trme32->adat_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\t\t} else {\n\t\t\tsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, \n\t\t\t\t\t&snd_rme32_playback_adat_ops);\n\t\t\tsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, \n\t\t\t\t\t&snd_rme32_capture_adat_ops);\n\t\t\trme32->adat_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\t\t}\n\t}\n\n\n\trme32->playback_periodsize = 0;\n\trme32->capture_periodsize = 0;\n\n\t \n\tsnd_rme32_pcm_stop(rme32, 0);\n\n         \n        snd_rme32_reset_dac(rme32);\n\n\t \n\twritel(0, rme32->iobase + RME32_IO_RESET_POS);\n\n\t \n\trme32->wcreg = RME32_WCR_SEL |\t  \n\t\tRME32_WCR_INP_0 |  \n\t\tRME32_WCR_MUTE;\t  \n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\n\n\t \n\terr = snd_rme32_create_switches(rme32->card, rme32);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnd_rme32_proc_init(rme32);\n\n\trme32->capture_substream = NULL;\n\trme32->playback_substream = NULL;\n\n\treturn 0;\n}\n\n \n\nstatic void\nsnd_rme32_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)\n{\n\tint n;\n\tstruct rme32 *rme32 = (struct rme32 *) entry->private_data;\n\n\trme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\n\tsnd_iprintf(buffer, rme32->card->longname);\n\tsnd_iprintf(buffer, \" (index #%d)\\n\", rme32->card->number + 1);\n\n\tsnd_iprintf(buffer, \"\\nGeneral settings\\n\");\n\tif (rme32->fullduplex_mode)\n\t\tsnd_iprintf(buffer, \"  Full-duplex mode\\n\");\n\telse\n\t\tsnd_iprintf(buffer, \"  Half-duplex mode\\n\");\n\tif (RME32_PRO_WITH_8414(rme32)) {\n\t\tsnd_iprintf(buffer, \"  receiver: CS8414\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  receiver: CS8412\\n\");\n\t}\n\tif (rme32->wcreg & RME32_WCR_MODE24) {\n\t\tsnd_iprintf(buffer, \"  format: 24 bit\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  format: 16 bit\");\n\t}\n\tif (rme32->wcreg & RME32_WCR_MONO) {\n\t\tsnd_iprintf(buffer, \", Mono\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \", Stereo\\n\");\n\t}\n\n\tsnd_iprintf(buffer, \"\\nInput settings\\n\");\n\tswitch (snd_rme32_getinputtype(rme32)) {\n\tcase RME32_INPUT_OPTICAL:\n\t\tsnd_iprintf(buffer, \"  input: optical\");\n\t\tbreak;\n\tcase RME32_INPUT_COAXIAL:\n\t\tsnd_iprintf(buffer, \"  input: coaxial\");\n\t\tbreak;\n\tcase RME32_INPUT_INTERNAL:\n\t\tsnd_iprintf(buffer, \"  input: internal\");\n\t\tbreak;\n\tcase RME32_INPUT_XLR:\n\t\tsnd_iprintf(buffer, \"  input: XLR\");\n\t\tbreak;\n\t}\n\tif (snd_rme32_capture_getrate(rme32, &n) < 0) {\n\t\tsnd_iprintf(buffer, \"\\n  sample rate: no valid signal\\n\");\n\t} else {\n\t\tif (n) {\n\t\t\tsnd_iprintf(buffer, \" (8 channels)\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \" (2 channels)\\n\");\n\t\t}\n\t\tsnd_iprintf(buffer, \"  sample rate: %d Hz\\n\",\n\t\t\t    snd_rme32_capture_getrate(rme32, &n));\n\t}\n\n\tsnd_iprintf(buffer, \"\\nOutput settings\\n\");\n\tif (rme32->wcreg & RME32_WCR_SEL) {\n\t\tsnd_iprintf(buffer, \"  output signal: normal playback\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  output signal: same as input\");\n\t}\n\tif (rme32->wcreg & RME32_WCR_MUTE) {\n\t\tsnd_iprintf(buffer, \" (muted)\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n\t \n\tif (!\n\t    ((!(rme32->wcreg & RME32_WCR_FREQ_0))\n\t     && (!(rme32->wcreg & RME32_WCR_FREQ_1)))) {\n\t\tsnd_iprintf(buffer, \"  sample rate: %d Hz\\n\",\n\t\t\t    snd_rme32_playback_getrate(rme32));\n\t}\n\tif (rme32->rcreg & RME32_RCR_KMODE) {\n\t\tsnd_iprintf(buffer, \"  sample clock source: AutoSync\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  sample clock source: Internal\\n\");\n\t}\n\tif (rme32->wcreg & RME32_WCR_PRO) {\n\t\tsnd_iprintf(buffer, \"  format: AES/EBU (professional)\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  format: IEC958 (consumer)\\n\");\n\t}\n\tif (rme32->wcreg & RME32_WCR_EMP) {\n\t\tsnd_iprintf(buffer, \"  emphasis: on\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  emphasis: off\\n\");\n\t}\n}\n\nstatic void snd_rme32_proc_init(struct rme32 *rme32)\n{\n\tsnd_card_ro_proc_new(rme32->card, \"rme32\", rme32, snd_rme32_proc_read);\n}\n\n \n\n#define snd_rme32_info_loopback_control\t\tsnd_ctl_boolean_mono_info\n\nstatic int\nsnd_rme32_get_loopback_control(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&rme32->lock);\n\tucontrol->value.integer.value[0] =\n\t    rme32->wcreg & RME32_WCR_SEL ? 0 : 1;\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme32_put_loopback_control(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ucontrol->value.integer.value[0] ? 0 : RME32_WCR_SEL;\n\tspin_lock_irq(&rme32->lock);\n\tval = (rme32->wcreg & ~RME32_WCR_SEL) | val;\n\tchange = val != rme32->wcreg;\n\tif (ucontrol->value.integer.value[0])\n\t\tval &= ~RME32_WCR_MUTE;\n\telse\n\t\tval |= RME32_WCR_MUTE;\n\trme32->wcreg = val;\n\twritel(val, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tspin_unlock_irq(&rme32->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme32_info_inputtype_control(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tstatic const char * const texts[4] = {\n\t\t\"Optical\", \"Coaxial\", \"Internal\", \"XLR\"\n\t};\n\tint num_items;\n\n\tswitch (rme32->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI32:\n\tcase PCI_DEVICE_ID_RME_DIGI32_8:\n\t\tnum_items = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI32_PRO:\n\t\tnum_items = 4;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\treturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\n}\nstatic int\nsnd_rme32_get_inputtype_control(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tunsigned int items = 3;\n\n\tspin_lock_irq(&rme32->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme32_getinputtype(rme32);\n\n\tswitch (rme32->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI32:\n\tcase PCI_DEVICE_ID_RME_DIGI32_8:\n\t\titems = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI32_PRO:\n\t\titems = 4;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\tif (ucontrol->value.enumerated.item[0] >= items) {\n\t\tucontrol->value.enumerated.item[0] = items - 1;\n\t}\n\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme32_put_inputtype_control(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change, items = 3;\n\n\tswitch (rme32->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI32:\n\tcase PCI_DEVICE_ID_RME_DIGI32_8:\n\t\titems = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI32_PRO:\n\t\titems = 4;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\tval = ucontrol->value.enumerated.item[0] % items;\n\n\tspin_lock_irq(&rme32->lock);\n\tchange = val != (unsigned int)snd_rme32_getinputtype(rme32);\n\tsnd_rme32_setinputtype(rme32, val);\n\tspin_unlock_irq(&rme32->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme32_info_clockmode_control(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = { \"AutoSync\",\n\t\t\t\t  \"Internal 32.0kHz\", \n\t\t\t\t  \"Internal 44.1kHz\", \n\t\t\t\t  \"Internal 48.0kHz\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\nstatic int\nsnd_rme32_get_clockmode_control(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&rme32->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme32_getclockmode(rme32);\n\tspin_unlock_irq(&rme32->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme32_put_clockmode_control(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ucontrol->value.enumerated.item[0] % 3;\n\tspin_lock_irq(&rme32->lock);\n\tchange = val != (unsigned int)snd_rme32_getclockmode(rme32);\n\tsnd_rme32_setclockmode(rme32, val);\n\tspin_unlock_irq(&rme32->lock);\n\treturn change;\n}\n\nstatic u32 snd_rme32_convert_from_aes(struct snd_aes_iec958 * aes)\n{\n\tu32 val = 0;\n\tval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME32_WCR_PRO : 0;\n\tif (val & RME32_WCR_PRO)\n\t\tval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME32_WCR_EMP : 0;\n\telse\n\t\tval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME32_WCR_EMP : 0;\n\treturn val;\n}\n\nstatic void snd_rme32_convert_to_aes(struct snd_aes_iec958 * aes, u32 val)\n{\n\taes->status[0] = ((val & RME32_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0);\n\tif (val & RME32_WCR_PRO)\n\t\taes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\n\telse\n\t\taes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\n}\n\nstatic int snd_rme32_control_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme32_control_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\n\tsnd_rme32_convert_to_aes(&ucontrol->value.iec958,\n\t\t\t\t rme32->wcreg_spdif);\n\treturn 0;\n}\n\nstatic int snd_rme32_control_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\n\tval = snd_rme32_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme32->lock);\n\tchange = val != rme32->wcreg_spdif;\n\trme32->wcreg_spdif = val;\n\tspin_unlock_irq(&rme32->lock);\n\treturn change;\n}\n\nstatic int snd_rme32_control_spdif_stream_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme32_control_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value *\n\t\t\t\t\t      ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\n\tsnd_rme32_convert_to_aes(&ucontrol->value.iec958,\n\t\t\t\t rme32->wcreg_spdif_stream);\n\treturn 0;\n}\n\nstatic int snd_rme32_control_spdif_stream_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value *\n\t\t\t\t\t      ucontrol)\n{\n\tstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\n\tval = snd_rme32_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme32->lock);\n\tchange = val != rme32->wcreg_spdif_stream;\n\trme32->wcreg_spdif_stream = val;\n\trme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);\n\trme32->wcreg |= val;\n\twritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\n\tspin_unlock_irq(&rme32->lock);\n\treturn change;\n}\n\nstatic int snd_rme32_control_spdif_mask_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme32_control_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *\n\t\t\t\t\t    ucontrol)\n{\n\tucontrol->value.iec958.status[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_rme32_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\tSNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info =\tsnd_rme32_control_spdif_info,\n\t\t.get =\tsnd_rme32_control_spdif_get,\n\t\t.put =\tsnd_rme32_control_spdif_put\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\tSNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PCM_STREAM),\n\t\t.info =\tsnd_rme32_control_spdif_stream_info,\n\t\t.get =\tsnd_rme32_control_spdif_stream_get,\n\t\t.put =\tsnd_rme32_control_spdif_stream_put\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\tSNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.info =\tsnd_rme32_control_spdif_mask_info,\n\t\t.get =\tsnd_rme32_control_spdif_mask_get,\n\t\t.private_value = IEC958_AES0_PROFESSIONAL | IEC958_AES0_CON_EMPHASIS\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\tSNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, PRO_MASK),\n\t\t.info =\tsnd_rme32_control_spdif_mask_info,\n\t\t.get =\tsnd_rme32_control_spdif_mask_get,\n\t\t.private_value = IEC958_AES0_PROFESSIONAL | IEC958_AES0_PRO_EMPHASIS\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\"Input Connector\",\n\t\t.info =\tsnd_rme32_info_inputtype_control,\n\t\t.get =\tsnd_rme32_get_inputtype_control,\n\t\t.put =\tsnd_rme32_put_inputtype_control\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\"Loopback Input\",\n\t\t.info =\tsnd_rme32_info_loopback_control,\n\t\t.get =\tsnd_rme32_get_loopback_control,\n\t\t.put =\tsnd_rme32_put_loopback_control\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\"Sample Clock Source\",\n\t\t.info =\tsnd_rme32_info_clockmode_control,\n\t\t.get =\tsnd_rme32_get_clockmode_control,\n\t\t.put =\tsnd_rme32_put_clockmode_control\n\t}\n};\n\nstatic int snd_rme32_create_switches(struct snd_card *card, struct rme32 * rme32)\n{\n\tint idx, err;\n\tstruct snd_kcontrol *kctl;\n\n\tfor (idx = 0; idx < (int)ARRAY_SIZE(snd_rme32_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_rme32_controls[idx], rme32);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (idx == 1)\t \n\t\t\trme32->spdif_ctl = kctl;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void snd_rme32_card_free(struct snd_card *card)\n{\n\tsnd_rme32_free(card->private_data);\n}\n\nstatic int\n__snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct rme32 *rme32;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS) {\n\t\treturn -ENODEV;\n\t}\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*rme32), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = snd_rme32_card_free;\n\trme32 = (struct rme32 *) card->private_data;\n\trme32->card = card;\n\trme32->pci = pci;\n        if (fullduplex[dev])\n\t\trme32->fullduplex_mode = 1;\n\terr = snd_rme32_create(rme32);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"Digi32\");\n\tswitch (rme32->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI32:\n\t\tstrcpy(card->shortname, \"RME Digi32\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI32_8:\n\t\tstrcpy(card->shortname, \"RME Digi32/8\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI32_PRO:\n\t\tstrcpy(card->shortname, \"RME Digi32 PRO\");\n\t\tbreak;\n\t}\n\tsprintf(card->longname, \"%s (Rev. %d) at 0x%lx, irq %d\",\n\t\tcard->shortname, rme32->rev, rme32->port, rme32->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int\nsnd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_rme32_probe(pci, pci_id));\n}\n\nstatic struct pci_driver rme32_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.id_table =\tsnd_rme32_ids,\n\t.probe =\tsnd_rme32_probe,\n};\n\nmodule_pci_driver(rme32_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}