{
  "module_name": "maestro3.c",
  "hash_id": "e6caba7f3132b9766202c39aed6cb3e8948dd0c856d8bbf85df8b95efd2e5ea8",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/maestro3.c",
  "human_readable_source": "\n \n \n#define CARD_NAME \"ESS Maestro3/Allegro/Canyon3D-2\"\n#define DRIVER_NAME \"Maestro3\"\n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/input.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/mpu401.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include <asm/byteorder.h>\n\nMODULE_AUTHOR(\"Zach Brown <zab@zabbo.net>, Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ESS Maestro3 PCI\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"ess/maestro3_assp_kernel.fw\");\nMODULE_FIRMWARE(\"ess/maestro3_assp_minisrc.fw\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;  \nstatic bool external_amp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\nstatic int amp_gpio[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable this soundcard.\");\nmodule_param_array(external_amp, bool, NULL, 0444);\nMODULE_PARM_DESC(external_amp, \"Enable external amp for \" CARD_NAME \" soundcard.\");\nmodule_param_array(amp_gpio, int, NULL, 0444);\nMODULE_PARM_DESC(amp_gpio, \"GPIO pin number for external amp. (default = -1)\");\n\n#define MAX_PLAYBACKS\t2\n#define MAX_CAPTURES\t1\n#define NR_DSPS\t\t(MAX_PLAYBACKS + MAX_CAPTURES)\n\n\n \n\n \n#define PCI_LEGACY_AUDIO_CTRL   0x40\n#define SOUND_BLASTER_ENABLE    0x00000001\n#define FM_SYNTHESIS_ENABLE     0x00000002\n#define GAME_PORT_ENABLE        0x00000004\n#define MPU401_IO_ENABLE        0x00000008\n#define MPU401_IRQ_ENABLE       0x00000010\n#define ALIAS_10BIT_IO          0x00000020\n#define SB_DMA_MASK             0x000000C0\n#define SB_DMA_0                0x00000040\n#define SB_DMA_1                0x00000040\n#define SB_DMA_R                0x00000080\n#define SB_DMA_3                0x000000C0\n#define SB_IRQ_MASK             0x00000700\n#define SB_IRQ_5                0x00000000\n#define SB_IRQ_7                0x00000100\n#define SB_IRQ_9                0x00000200\n#define SB_IRQ_10               0x00000300\n#define MIDI_IRQ_MASK           0x00003800\n#define SERIAL_IRQ_ENABLE       0x00004000\n#define DISABLE_LEGACY          0x00008000\n\n#define PCI_ALLEGRO_CONFIG      0x50\n#define SB_ADDR_240             0x00000004\n#define MPU_ADDR_MASK           0x00000018\n#define MPU_ADDR_330            0x00000000\n#define MPU_ADDR_300            0x00000008\n#define MPU_ADDR_320            0x00000010\n#define MPU_ADDR_340            0x00000018\n#define USE_PCI_TIMING          0x00000040\n#define POSTED_WRITE_ENABLE     0x00000080\n#define DMA_POLICY_MASK         0x00000700\n#define DMA_DDMA                0x00000000\n#define DMA_TDMA                0x00000100\n#define DMA_PCPCI               0x00000200\n#define DMA_WBDMA16             0x00000400\n#define DMA_WBDMA4              0x00000500\n#define DMA_WBDMA2              0x00000600\n#define DMA_WBDMA1              0x00000700\n#define DMA_SAFE_GUARD          0x00000800\n#define HI_PERF_GP_ENABLE       0x00001000\n#define PIC_SNOOP_MODE_0        0x00002000\n#define PIC_SNOOP_MODE_1        0x00004000\n#define SOUNDBLASTER_IRQ_MASK   0x00008000\n#define RING_IN_ENABLE          0x00010000\n#define SPDIF_TEST_MODE         0x00020000\n#define CLK_MULT_MODE_SELECT_2  0x00040000\n#define EEPROM_WRITE_ENABLE     0x00080000\n#define CODEC_DIR_IN            0x00100000\n#define HV_BUTTON_FROM_GD       0x00200000\n#define REDUCED_DEBOUNCE        0x00400000\n#define HV_CTRL_ENABLE          0x00800000\n#define SPDIF_ENABLE            0x01000000\n#define CLK_DIV_SELECT          0x06000000\n#define CLK_DIV_BY_48           0x00000000\n#define CLK_DIV_BY_49           0x02000000\n#define CLK_DIV_BY_50           0x04000000\n#define CLK_DIV_RESERVED        0x06000000\n#define PM_CTRL_ENABLE          0x08000000\n#define CLK_MULT_MODE_SELECT    0x30000000\n#define CLK_MULT_MODE_SHIFT     28\n#define CLK_MULT_MODE_0         0x00000000\n#define CLK_MULT_MODE_1         0x10000000\n#define CLK_MULT_MODE_2         0x20000000\n#define CLK_MULT_MODE_3         0x30000000\n#define INT_CLK_SELECT          0x40000000\n#define INT_CLK_MULT_RESET      0x80000000\n\n \n#define INT_CLK_SRC_NOT_PCI     0x00100000\n#define INT_CLK_MULT_ENABLE     0x80000000\n\n#define PCI_ACPI_CONTROL        0x54\n#define PCI_ACPI_D0             0x00000000\n#define PCI_ACPI_D1             0xB4F70000\n#define PCI_ACPI_D2             0xB4F7B4F7\n\n#define PCI_USER_CONFIG         0x58\n#define EXT_PCI_MASTER_ENABLE   0x00000001\n#define SPDIF_OUT_SELECT        0x00000002\n#define TEST_PIN_DIR_CTRL       0x00000004\n#define AC97_CODEC_TEST         0x00000020\n#define TRI_STATE_BUFFER        0x00000080\n#define IN_CLK_12MHZ_SELECT     0x00000100\n#define MULTI_FUNC_DISABLE      0x00000200\n#define EXT_MASTER_PAIR_SEL     0x00000400\n#define PCI_MASTER_SUPPORT      0x00000800\n#define STOP_CLOCK_ENABLE       0x00001000\n#define EAPD_DRIVE_ENABLE       0x00002000\n#define REQ_TRI_STATE_ENABLE    0x00004000\n#define REQ_LOW_ENABLE          0x00008000\n#define MIDI_1_ENABLE           0x00010000\n#define MIDI_2_ENABLE           0x00020000\n#define SB_AUDIO_SYNC           0x00040000\n#define HV_CTRL_TEST            0x00100000\n#define SOUNDBLASTER_TEST       0x00400000\n\n#define PCI_USER_CONFIG_C       0x5C\n\n#define PCI_DDMA_CTRL           0x60\n#define DDMA_ENABLE             0x00000001\n\n\n \n#define HOST_INT_CTRL           0x18\n#define SB_INT_ENABLE           0x0001\n#define MPU401_INT_ENABLE       0x0002\n#define ASSP_INT_ENABLE         0x0010\n#define RING_INT_ENABLE         0x0020\n#define HV_INT_ENABLE           0x0040\n#define CLKRUN_GEN_ENABLE       0x0100\n#define HV_CTRL_TO_PME          0x0400\n#define SOFTWARE_RESET_ENABLE   0x8000\n\n \n#define REGB_ENABLE_RESET               0x01\n#define REGB_STOP_CLOCK                 0x10\n\n#define HOST_INT_STATUS         0x1A\n#define SB_INT_PENDING          0x01\n#define MPU401_INT_PENDING      0x02\n#define ASSP_INT_PENDING        0x10\n#define RING_INT_PENDING        0x20\n#define HV_INT_PENDING          0x40\n\n#define HARDWARE_VOL_CTRL       0x1B\n#define SHADOW_MIX_REG_VOICE    0x1C\n#define HW_VOL_COUNTER_VOICE    0x1D\n#define SHADOW_MIX_REG_MASTER   0x1E\n#define HW_VOL_COUNTER_MASTER   0x1F\n\n#define CODEC_COMMAND           0x30\n#define CODEC_READ_B            0x80\n\n#define CODEC_STATUS            0x30\n#define CODEC_BUSY_B            0x01\n\n#define CODEC_DATA              0x32\n\n#define RING_BUS_CTRL_A         0x36\n#define RAC_PME_ENABLE          0x0100\n#define RAC_SDFS_ENABLE         0x0200\n#define LAC_PME_ENABLE          0x0400\n#define LAC_SDFS_ENABLE         0x0800\n#define SERIAL_AC_LINK_ENABLE   0x1000\n#define IO_SRAM_ENABLE          0x2000\n#define IIS_INPUT_ENABLE        0x8000\n\n#define RING_BUS_CTRL_B         0x38\n#define SECOND_CODEC_ID_MASK    0x0003\n#define SPDIF_FUNC_ENABLE       0x0010\n#define SECOND_AC_ENABLE        0x0020\n#define SB_MODULE_INTF_ENABLE   0x0040\n#define SSPE_ENABLE             0x0040\n#define M3I_DOCK_ENABLE         0x0080\n\n#define SDO_OUT_DEST_CTRL       0x3A\n#define COMMAND_ADDR_OUT        0x0003\n#define PCM_LR_OUT_LOCAL        0x0000\n#define PCM_LR_OUT_REMOTE       0x0004\n#define PCM_LR_OUT_MUTE         0x0008\n#define PCM_LR_OUT_BOTH         0x000C\n#define LINE1_DAC_OUT_LOCAL     0x0000\n#define LINE1_DAC_OUT_REMOTE    0x0010\n#define LINE1_DAC_OUT_MUTE      0x0020\n#define LINE1_DAC_OUT_BOTH      0x0030\n#define PCM_CLS_OUT_LOCAL       0x0000\n#define PCM_CLS_OUT_REMOTE      0x0040\n#define PCM_CLS_OUT_MUTE        0x0080\n#define PCM_CLS_OUT_BOTH        0x00C0\n#define PCM_RLF_OUT_LOCAL       0x0000\n#define PCM_RLF_OUT_REMOTE      0x0100\n#define PCM_RLF_OUT_MUTE        0x0200\n#define PCM_RLF_OUT_BOTH        0x0300\n#define LINE2_DAC_OUT_LOCAL     0x0000\n#define LINE2_DAC_OUT_REMOTE    0x0400\n#define LINE2_DAC_OUT_MUTE      0x0800\n#define LINE2_DAC_OUT_BOTH      0x0C00\n#define HANDSET_OUT_LOCAL       0x0000\n#define HANDSET_OUT_REMOTE      0x1000\n#define HANDSET_OUT_MUTE        0x2000\n#define HANDSET_OUT_BOTH        0x3000\n#define IO_CTRL_OUT_LOCAL       0x0000\n#define IO_CTRL_OUT_REMOTE      0x4000\n#define IO_CTRL_OUT_MUTE        0x8000\n#define IO_CTRL_OUT_BOTH        0xC000\n\n#define SDO_IN_DEST_CTRL        0x3C\n#define STATUS_ADDR_IN          0x0003\n#define PCM_LR_IN_LOCAL         0x0000\n#define PCM_LR_IN_REMOTE        0x0004\n#define PCM_LR_RESERVED         0x0008\n#define PCM_LR_IN_BOTH          0x000C\n#define LINE1_ADC_IN_LOCAL      0x0000\n#define LINE1_ADC_IN_REMOTE     0x0010\n#define LINE1_ADC_IN_MUTE       0x0020\n#define MIC_ADC_IN_LOCAL        0x0000\n#define MIC_ADC_IN_REMOTE       0x0040\n#define MIC_ADC_IN_MUTE         0x0080\n#define LINE2_DAC_IN_LOCAL      0x0000\n#define LINE2_DAC_IN_REMOTE     0x0400\n#define LINE2_DAC_IN_MUTE       0x0800\n#define HANDSET_IN_LOCAL        0x0000\n#define HANDSET_IN_REMOTE       0x1000\n#define HANDSET_IN_MUTE         0x2000\n#define IO_STATUS_IN_LOCAL      0x0000\n#define IO_STATUS_IN_REMOTE     0x4000\n\n#define SPDIF_IN_CTRL           0x3E\n#define SPDIF_IN_ENABLE         0x0001\n\n#define GPIO_DATA               0x60\n#define GPIO_DATA_MASK          0x0FFF\n#define GPIO_HV_STATUS          0x3000\n#define GPIO_PME_STATUS         0x4000\n\n#define GPIO_MASK               0x64\n#define GPIO_DIRECTION          0x68\n#define GPO_PRIMARY_AC97        0x0001\n#define GPI_LINEOUT_SENSE       0x0004\n#define GPO_SECONDARY_AC97      0x0008\n#define GPI_VOL_DOWN            0x0010\n#define GPI_VOL_UP              0x0020\n#define GPI_IIS_CLK             0x0040\n#define GPI_IIS_LRCLK           0x0080\n#define GPI_IIS_DATA            0x0100\n#define GPI_DOCKING_STATUS      0x0100\n#define GPI_HEADPHONE_SENSE     0x0200\n#define GPO_EXT_AMP_SHUTDOWN    0x1000\n\n#define GPO_EXT_AMP_M3\t\t1\t \n#define GPO_EXT_AMP_ALLEGRO\t8\t \n\n \n#define GPO_M3_EXT_AMP_SHUTDN   0x0002\n\n#define ASSP_INDEX_PORT         0x80\n#define ASSP_MEMORY_PORT        0x82\n#define ASSP_DATA_PORT          0x84\n\n#define MPU401_DATA_PORT        0x98\n#define MPU401_STATUS_PORT      0x99\n\n#define CLK_MULT_DATA_PORT      0x9C\n\n#define ASSP_CONTROL_A          0xA2\n#define ASSP_0_WS_ENABLE        0x01\n#define ASSP_CTRL_A_RESERVED1   0x02\n#define ASSP_CTRL_A_RESERVED2   0x04\n#define ASSP_CLK_49MHZ_SELECT   0x08\n#define FAST_PLU_ENABLE         0x10\n#define ASSP_CTRL_A_RESERVED3   0x20\n#define DSP_CLK_36MHZ_SELECT    0x40\n\n#define ASSP_CONTROL_B          0xA4\n#define RESET_ASSP              0x00\n#define RUN_ASSP                0x01\n#define ENABLE_ASSP_CLOCK       0x00\n#define STOP_ASSP_CLOCK         0x10\n#define RESET_TOGGLE            0x40\n\n#define ASSP_CONTROL_C          0xA6\n#define ASSP_HOST_INT_ENABLE    0x01\n#define FM_ADDR_REMAP_DISABLE   0x02\n#define HOST_WRITE_PORT_ENABLE  0x08\n\n#define ASSP_HOST_INT_STATUS    0xAC\n#define DSP2HOST_REQ_PIORECORD  0x01\n#define DSP2HOST_REQ_I2SRATE    0x02\n#define DSP2HOST_REQ_TIMER      0x04\n\n \n#define DSP_PORT_TIMER_COUNT    0x06\n\n#define DSP_PORT_MEMORY_INDEX   0x80\n\n#define DSP_PORT_MEMORY_TYPE    0x82\n#define MEMTYPE_INTERNAL_CODE   0x0002\n#define MEMTYPE_INTERNAL_DATA   0x0003\n#define MEMTYPE_MASK            0x0003\n\n#define DSP_PORT_MEMORY_DATA    0x84\n\n#define DSP_PORT_CONTROL_REG_A  0xA2\n#define DSP_PORT_CONTROL_REG_B  0xA4\n#define DSP_PORT_CONTROL_REG_C  0xA6\n\n#define REV_A_CODE_MEMORY_BEGIN         0x0000\n#define REV_A_CODE_MEMORY_END           0x0FFF\n#define REV_A_CODE_MEMORY_UNIT_LENGTH   0x0040\n#define REV_A_CODE_MEMORY_LENGTH        (REV_A_CODE_MEMORY_END - REV_A_CODE_MEMORY_BEGIN + 1)\n\n#define REV_B_CODE_MEMORY_BEGIN         0x0000\n#define REV_B_CODE_MEMORY_END           0x0BFF\n#define REV_B_CODE_MEMORY_UNIT_LENGTH   0x0040\n#define REV_B_CODE_MEMORY_LENGTH        (REV_B_CODE_MEMORY_END - REV_B_CODE_MEMORY_BEGIN + 1)\n\n#define REV_A_DATA_MEMORY_BEGIN         0x1000\n#define REV_A_DATA_MEMORY_END           0x2FFF\n#define REV_A_DATA_MEMORY_UNIT_LENGTH   0x0080\n#define REV_A_DATA_MEMORY_LENGTH        (REV_A_DATA_MEMORY_END - REV_A_DATA_MEMORY_BEGIN + 1)\n\n#define REV_B_DATA_MEMORY_BEGIN         0x1000\n#define REV_B_DATA_MEMORY_END           0x2BFF\n#define REV_B_DATA_MEMORY_UNIT_LENGTH   0x0080\n#define REV_B_DATA_MEMORY_LENGTH        (REV_B_DATA_MEMORY_END - REV_B_DATA_MEMORY_BEGIN + 1)\n\n\n#define NUM_UNITS_KERNEL_CODE          16\n#define NUM_UNITS_KERNEL_DATA           2\n\n#define NUM_UNITS_KERNEL_CODE_WITH_HSP 16\n#define NUM_UNITS_KERNEL_DATA_WITH_HSP  5\n\n \n\n#define DP_SHIFT_COUNT                  7\n\n#define KDATA_BASE_ADDR                 0x1000\n#define KDATA_BASE_ADDR2                0x1080\n\n#define KDATA_TASK0                     (KDATA_BASE_ADDR + 0x0000)\n#define KDATA_TASK1                     (KDATA_BASE_ADDR + 0x0001)\n#define KDATA_TASK2                     (KDATA_BASE_ADDR + 0x0002)\n#define KDATA_TASK3                     (KDATA_BASE_ADDR + 0x0003)\n#define KDATA_TASK4                     (KDATA_BASE_ADDR + 0x0004)\n#define KDATA_TASK5                     (KDATA_BASE_ADDR + 0x0005)\n#define KDATA_TASK6                     (KDATA_BASE_ADDR + 0x0006)\n#define KDATA_TASK7                     (KDATA_BASE_ADDR + 0x0007)\n#define KDATA_TASK_ENDMARK              (KDATA_BASE_ADDR + 0x0008)\n\n#define KDATA_CURRENT_TASK              (KDATA_BASE_ADDR + 0x0009)\n#define KDATA_TASK_SWITCH               (KDATA_BASE_ADDR + 0x000A)\n\n#define KDATA_INSTANCE0_POS3D           (KDATA_BASE_ADDR + 0x000B)\n#define KDATA_INSTANCE1_POS3D           (KDATA_BASE_ADDR + 0x000C)\n#define KDATA_INSTANCE2_POS3D           (KDATA_BASE_ADDR + 0x000D)\n#define KDATA_INSTANCE3_POS3D           (KDATA_BASE_ADDR + 0x000E)\n#define KDATA_INSTANCE4_POS3D           (KDATA_BASE_ADDR + 0x000F)\n#define KDATA_INSTANCE5_POS3D           (KDATA_BASE_ADDR + 0x0010)\n#define KDATA_INSTANCE6_POS3D           (KDATA_BASE_ADDR + 0x0011)\n#define KDATA_INSTANCE7_POS3D           (KDATA_BASE_ADDR + 0x0012)\n#define KDATA_INSTANCE8_POS3D           (KDATA_BASE_ADDR + 0x0013)\n#define KDATA_INSTANCE_POS3D_ENDMARK    (KDATA_BASE_ADDR + 0x0014)\n\n#define KDATA_INSTANCE0_SPKVIRT         (KDATA_BASE_ADDR + 0x0015)\n#define KDATA_INSTANCE_SPKVIRT_ENDMARK  (KDATA_BASE_ADDR + 0x0016)\n\n#define KDATA_INSTANCE0_SPDIF           (KDATA_BASE_ADDR + 0x0017)\n#define KDATA_INSTANCE_SPDIF_ENDMARK    (KDATA_BASE_ADDR + 0x0018)\n\n#define KDATA_INSTANCE0_MODEM           (KDATA_BASE_ADDR + 0x0019)\n#define KDATA_INSTANCE_MODEM_ENDMARK    (KDATA_BASE_ADDR + 0x001A)\n\n#define KDATA_INSTANCE0_SRC             (KDATA_BASE_ADDR + 0x001B)\n#define KDATA_INSTANCE1_SRC             (KDATA_BASE_ADDR + 0x001C)\n#define KDATA_INSTANCE_SRC_ENDMARK      (KDATA_BASE_ADDR + 0x001D)\n\n#define KDATA_INSTANCE0_MINISRC         (KDATA_BASE_ADDR + 0x001E)\n#define KDATA_INSTANCE1_MINISRC         (KDATA_BASE_ADDR + 0x001F)\n#define KDATA_INSTANCE2_MINISRC         (KDATA_BASE_ADDR + 0x0020)\n#define KDATA_INSTANCE3_MINISRC         (KDATA_BASE_ADDR + 0x0021)\n#define KDATA_INSTANCE_MINISRC_ENDMARK  (KDATA_BASE_ADDR + 0x0022)\n\n#define KDATA_INSTANCE0_CPYTHRU         (KDATA_BASE_ADDR + 0x0023)\n#define KDATA_INSTANCE1_CPYTHRU         (KDATA_BASE_ADDR + 0x0024)\n#define KDATA_INSTANCE_CPYTHRU_ENDMARK  (KDATA_BASE_ADDR + 0x0025)\n\n#define KDATA_CURRENT_DMA               (KDATA_BASE_ADDR + 0x0026)\n#define KDATA_DMA_SWITCH                (KDATA_BASE_ADDR + 0x0027)\n#define KDATA_DMA_ACTIVE                (KDATA_BASE_ADDR + 0x0028)\n\n#define KDATA_DMA_XFER0                 (KDATA_BASE_ADDR + 0x0029)\n#define KDATA_DMA_XFER1                 (KDATA_BASE_ADDR + 0x002A)\n#define KDATA_DMA_XFER2                 (KDATA_BASE_ADDR + 0x002B)\n#define KDATA_DMA_XFER3                 (KDATA_BASE_ADDR + 0x002C)\n#define KDATA_DMA_XFER4                 (KDATA_BASE_ADDR + 0x002D)\n#define KDATA_DMA_XFER5                 (KDATA_BASE_ADDR + 0x002E)\n#define KDATA_DMA_XFER6                 (KDATA_BASE_ADDR + 0x002F)\n#define KDATA_DMA_XFER7                 (KDATA_BASE_ADDR + 0x0030)\n#define KDATA_DMA_XFER8                 (KDATA_BASE_ADDR + 0x0031)\n#define KDATA_DMA_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0032)\n\n#define KDATA_I2S_SAMPLE_COUNT          (KDATA_BASE_ADDR + 0x0033)\n#define KDATA_I2S_INT_METER             (KDATA_BASE_ADDR + 0x0034)\n#define KDATA_I2S_ACTIVE                (KDATA_BASE_ADDR + 0x0035)\n\n#define KDATA_TIMER_COUNT_RELOAD        (KDATA_BASE_ADDR + 0x0036)\n#define KDATA_TIMER_COUNT_CURRENT       (KDATA_BASE_ADDR + 0x0037)\n\n#define KDATA_HALT_SYNCH_CLIENT         (KDATA_BASE_ADDR + 0x0038)\n#define KDATA_HALT_SYNCH_DMA            (KDATA_BASE_ADDR + 0x0039)\n#define KDATA_HALT_ACKNOWLEDGE          (KDATA_BASE_ADDR + 0x003A)\n\n#define KDATA_ADC1_XFER0                (KDATA_BASE_ADDR + 0x003B)\n#define KDATA_ADC1_XFER_ENDMARK         (KDATA_BASE_ADDR + 0x003C)\n#define KDATA_ADC1_LEFT_VOLUME\t\t\t(KDATA_BASE_ADDR + 0x003D)\n#define KDATA_ADC1_RIGHT_VOLUME  \t\t(KDATA_BASE_ADDR + 0x003E)\n#define KDATA_ADC1_LEFT_SUR_VOL\t\t\t(KDATA_BASE_ADDR + 0x003F)\n#define KDATA_ADC1_RIGHT_SUR_VOL\t\t(KDATA_BASE_ADDR + 0x0040)\n\n#define KDATA_ADC2_XFER0                (KDATA_BASE_ADDR + 0x0041)\n#define KDATA_ADC2_XFER_ENDMARK         (KDATA_BASE_ADDR + 0x0042)\n#define KDATA_ADC2_LEFT_VOLUME\t\t\t(KDATA_BASE_ADDR + 0x0043)\n#define KDATA_ADC2_RIGHT_VOLUME\t\t\t(KDATA_BASE_ADDR + 0x0044)\n#define KDATA_ADC2_LEFT_SUR_VOL\t\t\t(KDATA_BASE_ADDR + 0x0045)\n#define KDATA_ADC2_RIGHT_SUR_VOL\t\t(KDATA_BASE_ADDR + 0x0046)\n\n#define KDATA_CD_XFER0\t\t\t\t\t(KDATA_BASE_ADDR + 0x0047)\t\t\t\t\t\n#define KDATA_CD_XFER_ENDMARK\t\t\t(KDATA_BASE_ADDR + 0x0048)\n#define KDATA_CD_LEFT_VOLUME\t\t\t(KDATA_BASE_ADDR + 0x0049)\n#define KDATA_CD_RIGHT_VOLUME\t\t\t(KDATA_BASE_ADDR + 0x004A)\n#define KDATA_CD_LEFT_SUR_VOL\t\t\t(KDATA_BASE_ADDR + 0x004B)\n#define KDATA_CD_RIGHT_SUR_VOL\t\t\t(KDATA_BASE_ADDR + 0x004C)\n\n#define KDATA_MIC_XFER0\t\t\t\t\t(KDATA_BASE_ADDR + 0x004D)\n#define KDATA_MIC_XFER_ENDMARK\t\t\t(KDATA_BASE_ADDR + 0x004E)\n#define KDATA_MIC_VOLUME\t\t\t\t(KDATA_BASE_ADDR + 0x004F)\n#define KDATA_MIC_SUR_VOL\t\t\t\t(KDATA_BASE_ADDR + 0x0050)\n\n#define KDATA_I2S_XFER0                 (KDATA_BASE_ADDR + 0x0051)\n#define KDATA_I2S_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0052)\n\n#define KDATA_CHI_XFER0                 (KDATA_BASE_ADDR + 0x0053)\n#define KDATA_CHI_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0054)\n\n#define KDATA_SPDIF_XFER                (KDATA_BASE_ADDR + 0x0055)\n#define KDATA_SPDIF_CURRENT_FRAME       (KDATA_BASE_ADDR + 0x0056)\n#define KDATA_SPDIF_FRAME0              (KDATA_BASE_ADDR + 0x0057)\n#define KDATA_SPDIF_FRAME1              (KDATA_BASE_ADDR + 0x0058)\n#define KDATA_SPDIF_FRAME2              (KDATA_BASE_ADDR + 0x0059)\n\n#define KDATA_SPDIF_REQUEST             (KDATA_BASE_ADDR + 0x005A)\n#define KDATA_SPDIF_TEMP                (KDATA_BASE_ADDR + 0x005B)\n\n#define KDATA_SPDIFIN_XFER0             (KDATA_BASE_ADDR + 0x005C)\n#define KDATA_SPDIFIN_XFER_ENDMARK      (KDATA_BASE_ADDR + 0x005D)\n#define KDATA_SPDIFIN_INT_METER         (KDATA_BASE_ADDR + 0x005E)\n\n#define KDATA_DSP_RESET_COUNT           (KDATA_BASE_ADDR + 0x005F)\n#define KDATA_DEBUG_OUTPUT              (KDATA_BASE_ADDR + 0x0060)\n\n#define KDATA_KERNEL_ISR_LIST           (KDATA_BASE_ADDR + 0x0061)\n\n#define KDATA_KERNEL_ISR_CBSR1          (KDATA_BASE_ADDR + 0x0062)\n#define KDATA_KERNEL_ISR_CBER1          (KDATA_BASE_ADDR + 0x0063)\n#define KDATA_KERNEL_ISR_CBCR           (KDATA_BASE_ADDR + 0x0064)\n#define KDATA_KERNEL_ISR_AR0            (KDATA_BASE_ADDR + 0x0065)\n#define KDATA_KERNEL_ISR_AR1            (KDATA_BASE_ADDR + 0x0066)\n#define KDATA_KERNEL_ISR_AR2            (KDATA_BASE_ADDR + 0x0067)\n#define KDATA_KERNEL_ISR_AR3            (KDATA_BASE_ADDR + 0x0068)\n#define KDATA_KERNEL_ISR_AR4            (KDATA_BASE_ADDR + 0x0069)\n#define KDATA_KERNEL_ISR_AR5            (KDATA_BASE_ADDR + 0x006A)\n#define KDATA_KERNEL_ISR_BRCR           (KDATA_BASE_ADDR + 0x006B)\n#define KDATA_KERNEL_ISR_PASR           (KDATA_BASE_ADDR + 0x006C)\n#define KDATA_KERNEL_ISR_PAER           (KDATA_BASE_ADDR + 0x006D)\n\n#define KDATA_CLIENT_SCRATCH0           (KDATA_BASE_ADDR + 0x006E)\n#define KDATA_CLIENT_SCRATCH1           (KDATA_BASE_ADDR + 0x006F)\n#define KDATA_KERNEL_SCRATCH            (KDATA_BASE_ADDR + 0x0070)\n#define KDATA_KERNEL_ISR_SCRATCH        (KDATA_BASE_ADDR + 0x0071)\n\n#define KDATA_OUEUE_LEFT                (KDATA_BASE_ADDR + 0x0072)\n#define KDATA_QUEUE_RIGHT               (KDATA_BASE_ADDR + 0x0073)\n\n#define KDATA_ADC1_REQUEST              (KDATA_BASE_ADDR + 0x0074)\n#define KDATA_ADC2_REQUEST              (KDATA_BASE_ADDR + 0x0075)\n#define KDATA_CD_REQUEST\t\t\t\t(KDATA_BASE_ADDR + 0x0076)\n#define KDATA_MIC_REQUEST\t\t\t\t(KDATA_BASE_ADDR + 0x0077)\n\n#define KDATA_ADC1_MIXER_REQUEST        (KDATA_BASE_ADDR + 0x0078)\n#define KDATA_ADC2_MIXER_REQUEST        (KDATA_BASE_ADDR + 0x0079)\n#define KDATA_CD_MIXER_REQUEST\t\t\t(KDATA_BASE_ADDR + 0x007A)\n#define KDATA_MIC_MIXER_REQUEST\t\t\t(KDATA_BASE_ADDR + 0x007B)\n#define KDATA_MIC_SYNC_COUNTER\t\t\t(KDATA_BASE_ADDR + 0x007C)\n\n \n\n#define KDATA_MIXER_WORD0               (KDATA_BASE_ADDR2 + 0x0000)\n#define KDATA_MIXER_WORD1               (KDATA_BASE_ADDR2 + 0x0001)\n#define KDATA_MIXER_WORD2               (KDATA_BASE_ADDR2 + 0x0002)\n#define KDATA_MIXER_WORD3               (KDATA_BASE_ADDR2 + 0x0003)\n#define KDATA_MIXER_WORD4               (KDATA_BASE_ADDR2 + 0x0004)\n#define KDATA_MIXER_WORD5               (KDATA_BASE_ADDR2 + 0x0005)\n#define KDATA_MIXER_WORD6               (KDATA_BASE_ADDR2 + 0x0006)\n#define KDATA_MIXER_WORD7               (KDATA_BASE_ADDR2 + 0x0007)\n#define KDATA_MIXER_WORD8               (KDATA_BASE_ADDR2 + 0x0008)\n#define KDATA_MIXER_WORD9               (KDATA_BASE_ADDR2 + 0x0009)\n#define KDATA_MIXER_WORDA               (KDATA_BASE_ADDR2 + 0x000A)\n#define KDATA_MIXER_WORDB               (KDATA_BASE_ADDR2 + 0x000B)\n#define KDATA_MIXER_WORDC               (KDATA_BASE_ADDR2 + 0x000C)\n#define KDATA_MIXER_WORDD               (KDATA_BASE_ADDR2 + 0x000D)\n#define KDATA_MIXER_WORDE               (KDATA_BASE_ADDR2 + 0x000E)\n#define KDATA_MIXER_WORDF               (KDATA_BASE_ADDR2 + 0x000F)\n\n#define KDATA_MIXER_XFER0               (KDATA_BASE_ADDR2 + 0x0010)\n#define KDATA_MIXER_XFER1               (KDATA_BASE_ADDR2 + 0x0011)\n#define KDATA_MIXER_XFER2               (KDATA_BASE_ADDR2 + 0x0012)\n#define KDATA_MIXER_XFER3               (KDATA_BASE_ADDR2 + 0x0013)\n#define KDATA_MIXER_XFER4               (KDATA_BASE_ADDR2 + 0x0014)\n#define KDATA_MIXER_XFER5               (KDATA_BASE_ADDR2 + 0x0015)\n#define KDATA_MIXER_XFER6               (KDATA_BASE_ADDR2 + 0x0016)\n#define KDATA_MIXER_XFER7               (KDATA_BASE_ADDR2 + 0x0017)\n#define KDATA_MIXER_XFER8               (KDATA_BASE_ADDR2 + 0x0018)\n#define KDATA_MIXER_XFER9               (KDATA_BASE_ADDR2 + 0x0019)\n#define KDATA_MIXER_XFER_ENDMARK        (KDATA_BASE_ADDR2 + 0x001A)\n\n#define KDATA_MIXER_TASK_NUMBER         (KDATA_BASE_ADDR2 + 0x001B)\n#define KDATA_CURRENT_MIXER             (KDATA_BASE_ADDR2 + 0x001C)\n#define KDATA_MIXER_ACTIVE              (KDATA_BASE_ADDR2 + 0x001D)\n#define KDATA_MIXER_BANK_STATUS         (KDATA_BASE_ADDR2 + 0x001E)\n#define KDATA_DAC_LEFT_VOLUME\t        (KDATA_BASE_ADDR2 + 0x001F)\n#define KDATA_DAC_RIGHT_VOLUME          (KDATA_BASE_ADDR2 + 0x0020)\n\n#define MAX_INSTANCE_MINISRC            (KDATA_INSTANCE_MINISRC_ENDMARK - KDATA_INSTANCE0_MINISRC)\n#define MAX_VIRTUAL_DMA_CHANNELS        (KDATA_DMA_XFER_ENDMARK - KDATA_DMA_XFER0)\n#define MAX_VIRTUAL_MIXER_CHANNELS      (KDATA_MIXER_XFER_ENDMARK - KDATA_MIXER_XFER0)\n#define MAX_VIRTUAL_ADC1_CHANNELS       (KDATA_ADC1_XFER_ENDMARK - KDATA_ADC1_XFER0)\n\n \n#define CDATA_INSTANCE_READY            0x00\n\n#define CDATA_HOST_SRC_ADDRL            0x01\n#define CDATA_HOST_SRC_ADDRH            0x02\n#define CDATA_HOST_SRC_END_PLUS_1L      0x03\n#define CDATA_HOST_SRC_END_PLUS_1H      0x04\n#define CDATA_HOST_SRC_CURRENTL         0x05\n#define CDATA_HOST_SRC_CURRENTH         0x06\n\n#define CDATA_IN_BUF_CONNECT            0x07\n#define CDATA_OUT_BUF_CONNECT           0x08\n\n#define CDATA_IN_BUF_BEGIN              0x09\n#define CDATA_IN_BUF_END_PLUS_1         0x0A\n#define CDATA_IN_BUF_HEAD               0x0B\n#define CDATA_IN_BUF_TAIL               0x0C\n#define CDATA_OUT_BUF_BEGIN             0x0D\n#define CDATA_OUT_BUF_END_PLUS_1        0x0E\n#define CDATA_OUT_BUF_HEAD              0x0F\n#define CDATA_OUT_BUF_TAIL              0x10\n\n#define CDATA_DMA_CONTROL               0x11\n#define CDATA_RESERVED                  0x12\n\n#define CDATA_FREQUENCY                 0x13\n#define CDATA_LEFT_VOLUME               0x14\n#define CDATA_RIGHT_VOLUME              0x15\n#define CDATA_LEFT_SUR_VOL              0x16\n#define CDATA_RIGHT_SUR_VOL             0x17\n\n#define CDATA_HEADER_LEN                0x18\n\n#define SRC3_DIRECTION_OFFSET           CDATA_HEADER_LEN\n#define SRC3_MODE_OFFSET                (CDATA_HEADER_LEN + 1)\n#define SRC3_WORD_LENGTH_OFFSET         (CDATA_HEADER_LEN + 2)\n#define SRC3_PARAMETER_OFFSET           (CDATA_HEADER_LEN + 3)\n#define SRC3_COEFF_ADDR_OFFSET          (CDATA_HEADER_LEN + 8)\n#define SRC3_FILTAP_ADDR_OFFSET         (CDATA_HEADER_LEN + 10)\n#define SRC3_TEMP_INBUF_ADDR_OFFSET     (CDATA_HEADER_LEN + 16)\n#define SRC3_TEMP_OUTBUF_ADDR_OFFSET    (CDATA_HEADER_LEN + 17)\n\n#define MINISRC_IN_BUFFER_SIZE   ( 0x50 * 2 )\n#define MINISRC_OUT_BUFFER_SIZE  ( 0x50 * 2 * 2)\n#define MINISRC_TMP_BUFFER_SIZE  ( 112 + ( MINISRC_BIQUAD_STAGE * 3 + 4 ) * 2 * 2 )\n#define MINISRC_BIQUAD_STAGE    2\n#define MINISRC_COEF_LOC          0x175\n\n#define DMACONTROL_BLOCK_MASK           0x000F\n#define  DMAC_BLOCK0_SELECTOR           0x0000\n#define  DMAC_BLOCK1_SELECTOR           0x0001\n#define  DMAC_BLOCK2_SELECTOR           0x0002\n#define  DMAC_BLOCK3_SELECTOR           0x0003\n#define  DMAC_BLOCK4_SELECTOR           0x0004\n#define  DMAC_BLOCK5_SELECTOR           0x0005\n#define  DMAC_BLOCK6_SELECTOR           0x0006\n#define  DMAC_BLOCK7_SELECTOR           0x0007\n#define  DMAC_BLOCK8_SELECTOR           0x0008\n#define  DMAC_BLOCK9_SELECTOR           0x0009\n#define  DMAC_BLOCKA_SELECTOR           0x000A\n#define  DMAC_BLOCKB_SELECTOR           0x000B\n#define  DMAC_BLOCKC_SELECTOR           0x000C\n#define  DMAC_BLOCKD_SELECTOR           0x000D\n#define  DMAC_BLOCKE_SELECTOR           0x000E\n#define  DMAC_BLOCKF_SELECTOR           0x000F\n#define DMACONTROL_PAGE_MASK            0x00F0\n#define  DMAC_PAGE0_SELECTOR            0x0030\n#define  DMAC_PAGE1_SELECTOR            0x0020\n#define  DMAC_PAGE2_SELECTOR            0x0010\n#define  DMAC_PAGE3_SELECTOR            0x0000\n#define DMACONTROL_AUTOREPEAT           0x1000\n#define DMACONTROL_STOPPED              0x2000\n#define DMACONTROL_DIRECTION            0x0100\n\n \n#define ARB_VOLUME ( 0x6800 )\n\n \n\nstruct m3_list {\n\tint curlen;\n\tint mem_addr;\n\tint max;\n};\n\nstruct m3_dma {\n\n\tint number;\n\tstruct snd_pcm_substream *substream;\n\n\tstruct assp_instance {\n\t\tunsigned short code, data;\n\t} inst;\n\n\tint running;\n\tint opened;\n\n\tunsigned long buffer_addr;\n\tint dma_size;\n\tint period_size;\n\tunsigned int hwptr;\n\tint count;\n\n\tint index[3];\n\tstruct m3_list *index_list[3];\n\n        int in_lists;\n\t\n\tstruct list_head list;\n\n};\n    \nstruct snd_m3 {\n\t\n\tstruct snd_card *card;\n\n\tunsigned long iobase;\n\n\tint irq;\n\tunsigned int allegro_flag : 1;\n\n\tstruct snd_ac97 *ac97;\n\n\tstruct snd_pcm *pcm;\n\n\tstruct pci_dev *pci;\n\n\tint dacs_active;\n\tint timer_users;\n\n\tstruct m3_list  msrc_list;\n\tstruct m3_list  mixer_list;\n\tstruct m3_list  adc1_list;\n\tstruct m3_list  dma_list;\n\n\t \n\tu8 reset_state;\n\n\tint external_amp;\n\tint amp_gpio;\t \n\tunsigned int hv_config;\t\t \n\tunsigned irda_workaround :1;\t \n\tunsigned is_omnibook :1;\t \n\n\t \n\tstruct snd_rawmidi *rmidi;\n\n\t \n\tint num_substreams;\n\tstruct m3_dma *substreams;\n\n\tspinlock_t reg_lock;\n\n#ifdef CONFIG_SND_MAESTRO3_INPUT\n\tstruct input_dev *input_dev;\n\tchar phys[64];\t\t\t \n#else\n\tstruct snd_kcontrol *master_switch;\n\tstruct snd_kcontrol *master_volume;\n#endif\n\tstruct work_struct hwvol_work;\n\n\tunsigned int in_suspend;\n\n#ifdef CONFIG_PM_SLEEP\n\tu16 *suspend_mem;\n#endif\n\n\tconst struct firmware *assp_kernel_image;\n\tconst struct firmware *assp_minisrc_image;\n};\n\n \nstatic const struct pci_device_id snd_m3_ids[] = {\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_ALLEGRO_1, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_ALLEGRO, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_CANYON3D_2LE, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_CANYON3D_2, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_MAESTRO3, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_MAESTRO3_1, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_MAESTRO3_HW, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_MAESTRO3_2, PCI_ANY_ID, PCI_ANY_ID,\n\t PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0},\n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, snd_m3_ids);\n\nstatic const struct snd_pci_quirk m3_amp_quirk_list[] = {\n\tSND_PCI_QUIRK(0x0E11, 0x0094, \"Compaq Evo N600c\", 0x0c),\n\tSND_PCI_QUIRK(0x10f7, 0x833e, \"Panasonic CF-28\", 0x0d),\n\tSND_PCI_QUIRK(0x10f7, 0x833d, \"Panasonic CF-72\", 0x0d),\n\tSND_PCI_QUIRK(0x1033, 0x80f1, \"NEC LM800J/7\", 0x03),\n\tSND_PCI_QUIRK(0x1509, 0x1740, \"LEGEND ZhaoYang 3100CF\", 0x03),\n\t{ }  \n};\n\nstatic const struct snd_pci_quirk m3_irda_quirk_list[] = {\n\tSND_PCI_QUIRK(0x1028, 0x00b0, \"Dell Inspiron 4000\", 1),\n\tSND_PCI_QUIRK(0x1028, 0x00a4, \"Dell Inspiron 8000\", 1),\n\tSND_PCI_QUIRK(0x1028, 0x00e6, \"Dell Inspiron 8100\", 1),\n\t{ }  \n};\n\n \nstatic const struct snd_pci_quirk m3_hv_quirk_list[] = {\n\t \n\tSND_PCI_QUIRK(0x0E11, 0x002E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x0E11, 0x0094, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x0E11, 0xB112, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x0E11, 0xB114, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x103C, 0x0012, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x103C, 0x0018, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x103C, 0x001C, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x103C, 0x001D, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x103C, 0x001E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x107B, 0x3350, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x10F7, 0x8338, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x10F7, 0x833C, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x10F7, 0x833D, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x10F7, 0x833E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x10F7, 0x833F, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x13BD, 0x1018, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x13BD, 0x1019, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x13BD, 0x101A, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x14FF, 0x0F03, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x14FF, 0x0F04, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x14FF, 0x0F05, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x156D, 0xB400, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x156D, 0xB795, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x156D, 0xB797, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x156D, 0xC700, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),\n\tSND_PCI_QUIRK(0x1033, 0x80F1, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x103C, 0x001A, NULL,  \n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x107B, 0x340A, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x107B, 0x3450, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x109F, 0x3134, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x109F, 0x3161, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0x3280, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0x3281, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0xC002, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0xC003, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x1509, 0x1740, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x1610, 0x0010, NULL,\n\t\t      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x1042, 0x1042, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x107B, 0x9500, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x14FF, 0x0F06, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x1558, 0x8586, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x161F, 0x2011, NULL, HV_CTRL_ENABLE),\n\t \n\tSND_PCI_QUIRK(0x103C, 0x000E, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x103C, 0x0010, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x103C, 0x0011, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x103C, 0x001B, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x104D, 0x80A6, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x104D, 0x80AA, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x107B, 0x5300, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x110A, 0x1998, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x13BD, 0x1015, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x13BD, 0x101C, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x13BD, 0x1802, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x1599, 0x0715, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x5643, 0x5643, NULL, HV_CTRL_ENABLE),\n\tSND_PCI_QUIRK(0x144D, 0x3260, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0x3261, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0xC000, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),\n\tSND_PCI_QUIRK(0x144D, 0xC001, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),\n\t{ }  \n};\n\n \nstatic const struct snd_pci_quirk m3_omnibook_quirk_list[] = {\n\tSND_PCI_QUIRK_ID(0x103c, 0x0010),  \n\tSND_PCI_QUIRK_ID(0x103c, 0x0011),  \n\t{ }  \n};\n\n \n\nstatic inline void snd_m3_outw(struct snd_m3 *chip, u16 value, unsigned long reg)\n{\n\toutw(value, chip->iobase + reg);\n}\n\nstatic inline u16 snd_m3_inw(struct snd_m3 *chip, unsigned long reg)\n{\n\treturn inw(chip->iobase + reg);\n}\n\nstatic inline void snd_m3_outb(struct snd_m3 *chip, u8 value, unsigned long reg)\n{\n\toutb(value, chip->iobase + reg);\n}\n\nstatic inline u8 snd_m3_inb(struct snd_m3 *chip, unsigned long reg)\n{\n\treturn inb(chip->iobase + reg);\n}\n\n \nstatic u16 snd_m3_assp_read(struct snd_m3 *chip, u16 region, u16 index)\n{\n\tsnd_m3_outw(chip, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);\n\tsnd_m3_outw(chip, index, DSP_PORT_MEMORY_INDEX);\n\treturn snd_m3_inw(chip, DSP_PORT_MEMORY_DATA);\n}\n\nstatic void snd_m3_assp_write(struct snd_m3 *chip, u16 region, u16 index, u16 data)\n{\n\tsnd_m3_outw(chip, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);\n\tsnd_m3_outw(chip, index, DSP_PORT_MEMORY_INDEX);\n\tsnd_m3_outw(chip, data, DSP_PORT_MEMORY_DATA);\n}\n\nstatic void snd_m3_assp_halt(struct snd_m3 *chip)\n{\n\tchip->reset_state = snd_m3_inb(chip, DSP_PORT_CONTROL_REG_B) & ~REGB_STOP_CLOCK;\n\tmsleep(10);\n\tsnd_m3_outb(chip, chip->reset_state & ~REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);\n}\n\nstatic void snd_m3_assp_continue(struct snd_m3 *chip)\n{\n\tsnd_m3_outb(chip, chip->reset_state | REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);\n}\n\n\n \n\nstatic int snd_m3_add_list(struct snd_m3 *chip, struct m3_list *list, u16 val)\n{\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  list->mem_addr + list->curlen,\n\t\t\t  val);\n\treturn list->curlen++;\n}\n\nstatic void snd_m3_remove_list(struct snd_m3 *chip, struct m3_list *list, int index)\n{\n\tu16  val;\n\tint lastindex = list->curlen - 1;\n\n\tif (index != lastindex) {\n\t\tval = snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t       list->mem_addr + lastindex);\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  list->mem_addr + index,\n\t\t\t\t  val);\n\t}\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  list->mem_addr + lastindex,\n\t\t\t  0);\n\n\tlist->curlen--;\n}\n\nstatic void snd_m3_inc_timer_users(struct snd_m3 *chip)\n{\n\tchip->timer_users++;\n\tif (chip->timer_users != 1) \n\t\treturn;\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_TIMER_COUNT_RELOAD,\n\t\t\t  240);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_TIMER_COUNT_CURRENT,\n\t\t\t  240);\n\n\tsnd_m3_outw(chip,\n\t\t    snd_m3_inw(chip, HOST_INT_CTRL) | CLKRUN_GEN_ENABLE,\n\t\t    HOST_INT_CTRL);\n}\n\nstatic void snd_m3_dec_timer_users(struct snd_m3 *chip)\n{\n\tchip->timer_users--;\n\tif (chip->timer_users > 0)  \n\t\treturn;\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_TIMER_COUNT_RELOAD,\n\t\t\t  0);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_TIMER_COUNT_CURRENT,\n\t\t\t  0);\n\n\tsnd_m3_outw(chip,\n\t\t    snd_m3_inw(chip, HOST_INT_CTRL) & ~CLKRUN_GEN_ENABLE,\n\t\t    HOST_INT_CTRL);\n}\n\n \n\n \nstatic int snd_m3_pcm_start(struct snd_m3 *chip, struct m3_dma *s,\n\t\t\t    struct snd_pcm_substream *subs)\n{\n\tif (! s || ! subs)\n\t\treturn -EINVAL;\n\n\tsnd_m3_inc_timer_users(chip);\n\tswitch (subs->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tchip->dacs_active++;\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  s->inst.data + CDATA_INSTANCE_READY, 1);\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  KDATA_MIXER_TASK_NUMBER,\n\t\t\t\t  chip->dacs_active);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  KDATA_ADC1_REQUEST, 1);\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  s->inst.data + CDATA_INSTANCE_READY, 1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_m3_pcm_stop(struct snd_m3 *chip, struct m3_dma *s,\n\t\t\t   struct snd_pcm_substream *subs)\n{\n\tif (! s || ! subs)\n\t\treturn -EINVAL;\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_INSTANCE_READY, 0);\n\tsnd_m3_dec_timer_users(chip);\n\tswitch (subs->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tchip->dacs_active--;\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  KDATA_MIXER_TASK_NUMBER, \n\t\t\t\t  chip->dacs_active);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  KDATA_ADC1_REQUEST, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nsnd_m3_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\tstruct m3_dma *s = subs->runtime->private_data;\n\tint err = -EINVAL;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn -ENXIO;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (s->running)\n\t\t\terr = -EBUSY;\n\t\telse {\n\t\t\ts->running = 1;\n\t\t\terr = snd_m3_pcm_start(chip, s, subs);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (! s->running)\n\t\t\terr = 0;  \n\t\telse {\n\t\t\ts->running = 0;\n\t\t\terr = snd_m3_pcm_stop(chip, s, subs);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn err;\n}\n\n \nstatic void \nsnd_m3_pcm_setup1(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\n{\n\tint dsp_in_size, dsp_out_size, dsp_in_buffer, dsp_out_buffer;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\tif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdsp_in_size = MINISRC_IN_BUFFER_SIZE - (0x20 * 2);\n\t\tdsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x20 * 2);\n\t} else {\n\t\tdsp_in_size = MINISRC_IN_BUFFER_SIZE - (0x10 * 2);\n\t\tdsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x10 * 2);\n\t}\n\tdsp_in_buffer = s->inst.data + (MINISRC_TMP_BUFFER_SIZE / 2);\n\tdsp_out_buffer = dsp_in_buffer + (dsp_in_size / 2) + 1;\n\n\ts->dma_size = frames_to_bytes(runtime, runtime->buffer_size);\n\ts->period_size = frames_to_bytes(runtime, runtime->period_size);\n\ts->hwptr = 0;\n\ts->count = 0;\n\n#define LO(x) ((x) & 0xffff)\n#define HI(x) LO((x) >> 16)\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_ADDRL,\n\t\t\t  LO(s->buffer_addr));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_ADDRH,\n\t\t\t  HI(s->buffer_addr));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_END_PLUS_1L,\n\t\t\t  LO(s->buffer_addr + s->dma_size));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_END_PLUS_1H,\n\t\t\t  HI(s->buffer_addr + s->dma_size));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_CURRENTL,\n\t\t\t  LO(s->buffer_addr));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_HOST_SRC_CURRENTH,\n\t\t\t  HI(s->buffer_addr));\n#undef LO\n#undef HI\n\n\t \n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_IN_BUF_BEGIN,\n\t\t\t  dsp_in_buffer);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_IN_BUF_END_PLUS_1,\n\t\t\t  dsp_in_buffer + (dsp_in_size / 2));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_IN_BUF_HEAD,\n\t\t\t  dsp_in_buffer);\n    \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_IN_BUF_TAIL,\n\t\t\t  dsp_in_buffer);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_OUT_BUF_BEGIN,\n\t\t\t  dsp_out_buffer);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_OUT_BUF_END_PLUS_1,\n\t\t\t  dsp_out_buffer + (dsp_out_size / 2));\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_OUT_BUF_HEAD,\n\t\t\t  dsp_out_buffer);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_OUT_BUF_TAIL,\n\t\t\t  dsp_out_buffer);\n}\n\nstatic void snd_m3_pcm_setup2(struct snd_m3 *chip, struct m3_dma *s,\n\t\t\t      struct snd_pcm_runtime *runtime)\n{\n\tu32 freq;\n\n\t \n\tif (! s->in_lists) {\n\t\ts->index[0] = snd_m3_add_list(chip, s->index_list[0],\n\t\t\t\t\t      s->inst.data >> DP_SHIFT_COUNT);\n\t\ts->index[1] = snd_m3_add_list(chip, s->index_list[1],\n\t\t\t\t\t      s->inst.data >> DP_SHIFT_COUNT);\n\t\ts->index[2] = snd_m3_add_list(chip, s->index_list[2],\n\t\t\t\t\t      s->inst.data >> DP_SHIFT_COUNT);\n\t\ts->in_lists = 1;\n\t}\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 1, \n\t\t\t  runtime->channels == 2 ? 0 : 1);\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 2, \n\t\t\t  snd_pcm_format_width(runtime->format) == 16 ? 0 : 1);\n\n\t \n\tfreq = DIV_ROUND_CLOSEST(runtime->rate << 15, 48000);\n\tif (freq) \n\t\tfreq--;\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_FREQUENCY,\n\t\t\t  freq);\n}\n\n\nstatic const struct play_vals {\n\tu16 addr, val;\n} pv[] = {\n\t{CDATA_LEFT_VOLUME, ARB_VOLUME},\n\t{CDATA_RIGHT_VOLUME, ARB_VOLUME},\n\t{SRC3_DIRECTION_OFFSET, 0} ,\n\t \n\t{SRC3_DIRECTION_OFFSET + 3, 0x0000},  \n\t{SRC3_DIRECTION_OFFSET + 4, 0},  \n\t{SRC3_DIRECTION_OFFSET + 5, 0},  \n\t{SRC3_DIRECTION_OFFSET + 6, 0},  \n\t{SRC3_DIRECTION_OFFSET + 7, 0},  \n\t{SRC3_DIRECTION_OFFSET + 8, 0},  \n\t{SRC3_DIRECTION_OFFSET + 9, 0},  \n\t{SRC3_DIRECTION_OFFSET + 10, 0x8000},  \n\t{SRC3_DIRECTION_OFFSET + 11, 0xFF00},  \n\t{SRC3_DIRECTION_OFFSET + 13, 0},  \n\t{SRC3_DIRECTION_OFFSET + 14, 0},  \n\t{SRC3_DIRECTION_OFFSET + 15, 0},  \n\t{SRC3_DIRECTION_OFFSET + 16, 8},  \n\t{SRC3_DIRECTION_OFFSET + 17, 50*2},  \n\t{SRC3_DIRECTION_OFFSET + 18, MINISRC_BIQUAD_STAGE - 1},  \n\t{SRC3_DIRECTION_OFFSET + 20, 0},  \n\t{SRC3_DIRECTION_OFFSET + 21, 0}  \n};\n\n\n \nstatic void\nsnd_m3_playback_setup(struct snd_m3 *chip, struct m3_dma *s,\n\t\t      struct snd_pcm_substream *subs)\n{\n\tunsigned int i;\n\n\t \n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 12,\n\t\t\t  s->inst.data + 40 + 8);\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 19,\n\t\t\t  s->inst.code + MINISRC_COEF_LOC);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 22,\n\t\t\t  subs->runtime->rate > 45000 ? 0xff : 0);\n    \n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_DMA_CONTROL,\n\t\t\t  DMACONTROL_AUTOREPEAT + DMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pv); i++) \n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  s->inst.data + pv[i].addr, pv[i].val);\n}\n\n \nstatic const struct rec_vals {\n\tu16 addr, val;\n} rv[] = {\n\t{CDATA_LEFT_VOLUME, ARB_VOLUME},\n\t{CDATA_RIGHT_VOLUME, ARB_VOLUME},\n\t{SRC3_DIRECTION_OFFSET, 1} ,\n\t \n\t{SRC3_DIRECTION_OFFSET + 3, 0x0000},  \n\t{SRC3_DIRECTION_OFFSET + 4, 0},  \n\t{SRC3_DIRECTION_OFFSET + 5, 0},  \n\t{SRC3_DIRECTION_OFFSET + 6, 0},  \n\t{SRC3_DIRECTION_OFFSET + 7, 0},  \n\t{SRC3_DIRECTION_OFFSET + 8, 0},  \n\t{SRC3_DIRECTION_OFFSET + 9, 0},  \n\t{SRC3_DIRECTION_OFFSET + 10, 0x8000},  \n\t{SRC3_DIRECTION_OFFSET + 11, 0xFF00},  \n\t{SRC3_DIRECTION_OFFSET + 13, 0},  \n\t{SRC3_DIRECTION_OFFSET + 14, 0},  \n\t{SRC3_DIRECTION_OFFSET + 15, 0},  \n\t{SRC3_DIRECTION_OFFSET + 16, 50}, \n\t{SRC3_DIRECTION_OFFSET + 17, 8},  \n\t{SRC3_DIRECTION_OFFSET + 18, 0},  \n\t{SRC3_DIRECTION_OFFSET + 19, 0},  \n\t{SRC3_DIRECTION_OFFSET + 20, 0},  \n\t{SRC3_DIRECTION_OFFSET + 21, 0},  \n\t{SRC3_DIRECTION_OFFSET + 22, 0xff}  \n};\n\nstatic void\nsnd_m3_capture_setup(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\n{\n\tunsigned int i;\n\n\t \n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + SRC3_DIRECTION_OFFSET + 12,\n\t\t\t  s->inst.data + 40 + 8);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  s->inst.data + CDATA_DMA_CONTROL,\n\t\t\t  DMACONTROL_DIRECTION + DMACONTROL_AUTOREPEAT + \n\t\t\t  DMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rv); i++) \n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  s->inst.data + rv[i].addr, rv[i].val);\n}\n\nstatic int snd_m3_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct m3_dma *s = substream->runtime->private_data;\n\n\t \n\ts->buffer_addr = substream->runtime->dma_addr;\n\tif (s->buffer_addr & 0x3) {\n\t\tdev_err(substream->pcm->card->dev, \"oh my, not aligned\\n\");\n\t\ts->buffer_addr = s->buffer_addr & ~0x3;\n\t}\n\treturn 0;\n}\n\nstatic int snd_m3_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct m3_dma *s;\n\t\n\tif (substream->runtime->private_data == NULL)\n\t\treturn 0;\n\ts = substream->runtime->private_data;\n\ts->buffer_addr = 0;\n\treturn 0;\n}\n\nstatic int\nsnd_m3_pcm_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct m3_dma *s = runtime->private_data;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn -ENXIO;\n\n\tif (runtime->format != SNDRV_PCM_FORMAT_U8 &&\n\t    runtime->format != SNDRV_PCM_FORMAT_S16_LE)\n\t\treturn -EINVAL;\n\tif (runtime->rate > 48000 ||\n\t    runtime->rate < 8000)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&chip->reg_lock);\n\n\tsnd_m3_pcm_setup1(chip, s, subs);\n\n\tif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_m3_playback_setup(chip, s, subs);\n\telse\n\t\tsnd_m3_capture_setup(chip, s, subs);\n\n\tsnd_m3_pcm_setup2(chip, s, runtime);\n\n\tspin_unlock_irq(&chip->reg_lock);\n\n\treturn 0;\n}\n\n \nstatic unsigned int\nsnd_m3_get_pointer(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\n{\n\tu16 hi = 0, lo = 0;\n\tint retry = 10;\n\tu32 addr;\n\n\t \n\twhile (retry--) {\n\t\thi =  snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t       s->inst.data + CDATA_HOST_SRC_CURRENTH);\n\n\t\tlo = snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t      s->inst.data + CDATA_HOST_SRC_CURRENTL);\n\n\t\tif (hi == snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t\t   s->inst.data + CDATA_HOST_SRC_CURRENTH))\n\t\t\tbreak;\n\t}\n\taddr = lo | ((u32)hi<<16);\n\treturn (unsigned int)(addr - s->buffer_addr);\n}\n\nstatic snd_pcm_uframes_t\nsnd_m3_pcm_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\tunsigned int ptr;\n\tstruct m3_dma *s = subs->runtime->private_data;\n\n\tif (snd_BUG_ON(!s))\n\t\treturn 0;\n\n\tspin_lock(&chip->reg_lock);\n\tptr = snd_m3_get_pointer(chip, s, subs);\n\tspin_unlock(&chip->reg_lock);\n\treturn bytes_to_frames(subs->runtime, ptr);\n}\n\n\n \n \nstatic void snd_m3_update_ptr(struct snd_m3 *chip, struct m3_dma *s)\n{\n\tstruct snd_pcm_substream *subs = s->substream;\n\tunsigned int hwptr;\n\tint diff;\n\n\tif (! s->running)\n\t\treturn;\n\n\thwptr = snd_m3_get_pointer(chip, s, subs);\n\n\t \n\tif (hwptr >= s->dma_size)\n\t\thwptr %= s->dma_size;\n\n\tdiff = s->dma_size + hwptr - s->hwptr;\n\tif (diff >= s->dma_size)\n\t\tdiff %= s->dma_size;\n\n\ts->hwptr = hwptr;\n\ts->count += diff;\n\n\tif (s->count >= (signed)s->period_size) {\n\n\t\tif (s->count < 2 * (signed)s->period_size)\n\t\t\ts->count -= (signed)s->period_size;\n\t\telse\n\t\t\ts->count %= s->period_size;\n\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(subs);\n\t\tspin_lock(&chip->reg_lock);\n\t}\n}\n\n \nstatic void snd_m3_update_hw_volume(struct work_struct *work)\n{\n\tstruct snd_m3 *chip = container_of(work, struct snd_m3, hwvol_work);\n\tint x, val;\n\n\t \n\tx = inb(chip->iobase + SHADOW_MIX_REG_VOICE) & 0xee;\n\n\t \n\toutb(0x88, chip->iobase + SHADOW_MIX_REG_VOICE);\n\toutb(0x88, chip->iobase + HW_VOL_COUNTER_VOICE);\n\toutb(0x88, chip->iobase + SHADOW_MIX_REG_MASTER);\n\toutb(0x88, chip->iobase + HW_VOL_COUNTER_MASTER);\n\n\t \n\tif (chip->in_suspend)\n\t\treturn;\n\n#ifndef CONFIG_SND_MAESTRO3_INPUT\n\tif (!chip->master_switch || !chip->master_volume)\n\t\treturn;\n\n\tval = snd_ac97_read(chip->ac97, AC97_MASTER);\n\tswitch (x) {\n\tcase 0x88:\n\t\t \n\t\tval ^= 0x8000;\n\t\tbreak;\n\tcase 0xaa:\n\t\t \n\t\tif ((val & 0x7f) > 0)\n\t\t\tval--;\n\t\tif ((val & 0x7f00) > 0)\n\t\t\tval -= 0x0100;\n\t\tbreak;\n\tcase 0x66:\n\t\t \n\t\tif ((val & 0x7f) < 0x1f)\n\t\t\tval++;\n\t\tif ((val & 0x7f00) < 0x1f00)\n\t\t\tval += 0x0100;\n\t\tbreak;\n\t}\n\tif (snd_ac97_update(chip->ac97, AC97_MASTER, val))\n\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &chip->master_switch->id);\n#else\n\tif (!chip->input_dev)\n\t\treturn;\n\n\tval = 0;\n\tswitch (x) {\n\tcase 0x88:\n\t\t \n\t\tval = KEY_MUTE;\n\t\tbreak;\n\tcase 0xaa:\n\t\t \n\t\tval = KEY_VOLUMEUP;\n\t\tbreak;\n\tcase 0x66:\n\t\t \n\t\tval = KEY_VOLUMEDOWN;\n\t\tbreak;\n\t}\n\n\tif (val) {\n\t\tinput_report_key(chip->input_dev, val, 1);\n\t\tinput_sync(chip->input_dev);\n\t\tinput_report_key(chip->input_dev, val, 0);\n\t\tinput_sync(chip->input_dev);\n\t}\n#endif\n}\n\nstatic irqreturn_t snd_m3_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_m3 *chip = dev_id;\n\tu8 status;\n\tint i;\n\n\tstatus = inb(chip->iobase + HOST_INT_STATUS);\n\n\tif (status == 0xff)\n\t\treturn IRQ_NONE;\n\n\tif (status & HV_INT_PENDING)\n\t\tschedule_work(&chip->hwvol_work);\n\n\t \n\tif (status & ASSP_INT_PENDING) {\n\t\tu8 ctl = inb(chip->iobase + ASSP_CONTROL_B);\n\t\tif (!(ctl & STOP_ASSP_CLOCK)) {\n\t\t\tctl = inb(chip->iobase + ASSP_HOST_INT_STATUS);\n\t\t\tif (ctl & DSP2HOST_REQ_TIMER) {\n\t\t\t\toutb(DSP2HOST_REQ_TIMER, chip->iobase + ASSP_HOST_INT_STATUS);\n\t\t\t\t \n\t\t\t\tspin_lock(&chip->reg_lock);\n\t\t\t\tfor (i = 0; i < chip->num_substreams; i++) {\n\t\t\t\t\tstruct m3_dma *s = &chip->substreams[i];\n\t\t\t\t\tif (s->running)\n\t\t\t\t\t\tsnd_m3_update_ptr(chip, s);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\t}\n\t\t}\n\t}\n\n#if 0  \n\tif ((status & MPU401_INT_PENDING) && chip->rmidi)\n\t\tsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);\n#endif\n\n\t \n\toutb(status, chip->iobase + HOST_INT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic const struct snd_pcm_hardware snd_m3_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(512*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(512*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n};\n\nstatic const struct snd_pcm_hardware snd_m3_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(512*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(512*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n};\n\n\n \n\nstatic int\nsnd_m3_substream_open(struct snd_m3 *chip, struct snd_pcm_substream *subs)\n{\n\tint i;\n\tstruct m3_dma *s;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tfor (i = 0; i < chip->num_substreams; i++) {\n\t\ts = &chip->substreams[i];\n\t\tif (! s->opened)\n\t\t\tgoto __found;\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn -ENOMEM;\n__found:\n\ts->opened = 1;\n\ts->running = 0;\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tsubs->runtime->private_data = s;\n\ts->substream = subs;\n\n\t \n\tif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\ts->index_list[0] = &chip->mixer_list;\n\t} else\n\t\ts->index_list[0] = &chip->adc1_list;\n\ts->index_list[1] = &chip->msrc_list;\n\ts->index_list[2] = &chip->dma_list;\n\n\treturn 0;\n}\n\nstatic void\nsnd_m3_substream_close(struct snd_m3 *chip, struct snd_pcm_substream *subs)\n{\n\tstruct m3_dma *s = subs->runtime->private_data;\n\n\tif (s == NULL)\n\t\treturn;  \n\n\tspin_lock_irq(&chip->reg_lock);\n\tif (s->substream && s->running)\n\t\tsnd_m3_pcm_stop(chip, s, s->substream);  \n\tif (s->in_lists) {\n\t\tsnd_m3_remove_list(chip, s->index_list[0], s->index[0]);\n\t\tsnd_m3_remove_list(chip, s->index_list[1], s->index[1]);\n\t\tsnd_m3_remove_list(chip, s->index_list[2], s->index[2]);\n\t\ts->in_lists = 0;\n\t}\n\ts->running = 0;\n\ts->opened = 0;\n\tspin_unlock_irq(&chip->reg_lock);\n}\n\nstatic int\nsnd_m3_playback_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tint err;\n\n\terr = snd_m3_substream_open(chip, subs);\n\tif (err < 0)\n\t\treturn err;\n\n\truntime->hw = snd_m3_playback;\n\n\treturn 0;\n}\n\nstatic int\nsnd_m3_playback_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\n\tsnd_m3_substream_close(chip, subs);\n\treturn 0;\n}\n\nstatic int\nsnd_m3_capture_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tint err;\n\n\terr = snd_m3_substream_open(chip, subs);\n\tif (err < 0)\n\t\treturn err;\n\n\truntime->hw = snd_m3_capture;\n\n\treturn 0;\n}\n\nstatic int\nsnd_m3_capture_close(struct snd_pcm_substream *subs)\n{\n\tstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\n\n\tsnd_m3_substream_close(chip, subs);\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_ops snd_m3_playback_ops = {\n\t.open =\t\tsnd_m3_playback_open,\n\t.close =\tsnd_m3_playback_close,\n\t.hw_params =\tsnd_m3_pcm_hw_params,\n\t.hw_free =\tsnd_m3_pcm_hw_free,\n\t.prepare =\tsnd_m3_pcm_prepare,\n\t.trigger =\tsnd_m3_pcm_trigger,\n\t.pointer =\tsnd_m3_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_m3_capture_ops = {\n\t.open =\t\tsnd_m3_capture_open,\n\t.close =\tsnd_m3_capture_close,\n\t.hw_params =\tsnd_m3_pcm_hw_params,\n\t.hw_free =\tsnd_m3_pcm_hw_free,\n\t.prepare =\tsnd_m3_pcm_prepare,\n\t.trigger =\tsnd_m3_pcm_trigger,\n\t.pointer =\tsnd_m3_pcm_pointer,\n};\n\nstatic int\nsnd_m3_pcm(struct snd_m3 * chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, chip->card->driver, device,\n\t\t\t  MAX_PLAYBACKS, MAX_CAPTURES, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_m3_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_m3_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, chip->card->driver);\n\tchip->pcm = pcm;\n\t\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 64*1024);\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int snd_m3_ac97_wait(struct snd_m3 *chip)\n{\n\tint i = 10000;\n\n\tdo {\n\t\tif (! (snd_m3_inb(chip, 0x30) & 1))\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (i-- > 0);\n\n\tdev_err(chip->card->dev, \"ac97 serial bus busy\\n\");\n\treturn 1;\n}\n\nstatic unsigned short\nsnd_m3_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct snd_m3 *chip = ac97->private_data;\n\tunsigned short data = 0xffff;\n\n\tif (snd_m3_ac97_wait(chip))\n\t\tgoto fail;\n\tsnd_m3_outb(chip, 0x80 | (reg & 0x7f), CODEC_COMMAND);\n\tif (snd_m3_ac97_wait(chip))\n\t\tgoto fail;\n\tdata = snd_m3_inw(chip, CODEC_DATA);\nfail:\n\treturn data;\n}\n\nstatic void\nsnd_m3_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\n{\n\tstruct snd_m3 *chip = ac97->private_data;\n\n\tif (snd_m3_ac97_wait(chip))\n\t\treturn;\n\tsnd_m3_outw(chip, val, CODEC_DATA);\n\tsnd_m3_outb(chip, reg & 0x7f, CODEC_COMMAND);\n\t \n\tif (ac97->id == 0x45838308 && reg == AC97_MASTER) {\n\t\tsnd_m3_ac97_wait(chip);\n\t\tsnd_m3_outw(chip, val, CODEC_DATA);\n\t\tsnd_m3_outb(chip, reg & 0x7f, CODEC_COMMAND);\n\t}\n}\n\n\nstatic void snd_m3_remote_codec_config(struct snd_m3 *chip, int isremote)\n{\n\tint io = chip->iobase;\n\tu16 tmp;\n\n\tisremote = isremote ? 1 : 0;\n\n\ttmp = inw(io + RING_BUS_CTRL_B) & ~SECOND_CODEC_ID_MASK;\n\t \n\tif (chip->pci->subsystem_vendor == 0x1028 &&\n\t    chip->pci->subsystem_device == 0x00e5)\n\t\ttmp |= M3I_DOCK_ENABLE;\n\toutw(tmp | isremote, io + RING_BUS_CTRL_B);\n\toutw((inw(io + SDO_OUT_DEST_CTRL) & ~COMMAND_ADDR_OUT) | isremote,\n\t     io + SDO_OUT_DEST_CTRL);\n\toutw((inw(io + SDO_IN_DEST_CTRL) & ~STATUS_ADDR_IN) | isremote,\n\t     io + SDO_IN_DEST_CTRL);\n}\n\n \nstatic int snd_m3_try_read_vendor(struct snd_m3 *chip)\n{\n\tu16 ret;\n\n\tif (snd_m3_ac97_wait(chip))\n\t\treturn 1;\n\n\tsnd_m3_outb(chip, 0x80 | (AC97_VENDOR_ID1 & 0x7f), 0x30);\n\n\tif (snd_m3_ac97_wait(chip))\n\t\treturn 1;\n\n\tret = snd_m3_inw(chip, 0x32);\n\n\treturn (ret == 0) || (ret == 0xffff);\n}\n\nstatic void snd_m3_ac97_reset(struct snd_m3 *chip)\n{\n\tu16 dir;\n\tint delay1 = 0, delay2 = 0, i;\n\tint io = chip->iobase;\n\n\tif (chip->allegro_flag) {\n\t\t \n\t\tdelay1 = 50;\n\t\tdelay2 = 800;\n\t} else {\n\t\t \n\t\tdelay1 = 20;\n\t\tdelay2 = 500;\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\tdir = inw(io + GPIO_DIRECTION);\n\t\tif (!chip->irda_workaround)\n\t\t\tdir |= 0x10;  \n\n\t\tsnd_m3_remote_codec_config(chip, 0);\n\n\t\toutw(IO_SRAM_ENABLE, io + RING_BUS_CTRL_A);\n\t\tudelay(20);\n\n\t\toutw(dir & ~GPO_PRIMARY_AC97 , io + GPIO_DIRECTION);\n\t\toutw(~GPO_PRIMARY_AC97 , io + GPIO_MASK);\n\t\toutw(0, io + GPIO_DATA);\n\t\toutw(dir | GPO_PRIMARY_AC97, io + GPIO_DIRECTION);\n\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(delay1));\n\n\t\toutw(GPO_PRIMARY_AC97, io + GPIO_DATA);\n\t\tudelay(5);\n\t\t \n\t\toutw(IO_SRAM_ENABLE | SERIAL_AC_LINK_ENABLE, io + RING_BUS_CTRL_A);\n\t\toutw(~0, io + GPIO_MASK);\n\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(delay2));\n\n\t\tif (! snd_m3_try_read_vendor(chip))\n\t\t\tbreak;\n\n\t\tdelay1 += 10;\n\t\tdelay2 += 100;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"retrying codec reset with delays of %d and %d ms\\n\",\n\t\t\t   delay1, delay2);\n\t}\n\n#if 0\n\t \n\ttmp = inw(io + RING_BUS_CTRL_A);\n\toutw(RAC_SDFS_ENABLE|LAC_SDFS_ENABLE, io + RING_BUS_CTRL_A);\n\tmsleep(20);\n\toutw(tmp, io + RING_BUS_CTRL_A);\n\tmsleep(50);\n#endif\n}\n\nstatic int snd_m3_mixer(struct snd_m3 *chip)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_m3_ac97_write,\n\t\t.read = snd_m3_ac97_read,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnd_ac97_write(chip->ac97, AC97_PCM, 0x8000 | (15 << 8) | 15);\n\tschedule_timeout_uninterruptible(msecs_to_jiffies(100));\n\tsnd_ac97_write(chip->ac97, AC97_PCM, 0);\n\n#ifndef CONFIG_SND_MAESTRO3_INPUT\n\tchip->master_switch = snd_ctl_find_id_mixer(chip->card,\n\t\t\t\t\t\t    \"Master Playback Switch\");\n\tchip->master_volume = snd_ctl_find_id_mixer(chip->card,\n\t\t\t\t\t\t    \"Master Playback Volume\");\n#endif\n\n\treturn 0;\n}\n\n\n \n\n#define MINISRC_LPF_LEN 10\nstatic const u16 minisrc_lpf[MINISRC_LPF_LEN] = {\n\t0X0743, 0X1104, 0X0A4C, 0XF88D, 0X242C,\n\t0X1023, 0X1AA9, 0X0B60, 0XEFDD, 0X186F\n};\n\nstatic void snd_m3_assp_init(struct snd_m3 *chip)\n{\n\tunsigned int i;\n\tconst __le16 *data;\n\n\t \n\tfor (i = 0; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA, \n\t\t\t\t  KDATA_BASE_ADDR + i, 0);\n\n\t \n\tfor (i = 0; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  KDATA_BASE_ADDR2 + i, 0);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_CURRENT_DMA,\n\t\t\t  KDATA_DMA_XFER0);\n\n\t \n\tdata = (const __le16 *)chip->assp_kernel_image->data;\n\tfor (i = 0 ; i * 2 < chip->assp_kernel_image->size; i++) {\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, \n\t\t\t\t  REV_B_CODE_MEMORY_BEGIN + i,\n\t\t\t\t  le16_to_cpu(data[i]));\n\t}\n\n\t \n\tdata = (const __le16 *)chip->assp_minisrc_image->data;\n\tfor (i = 0; i * 2 < chip->assp_minisrc_image->size; i++) {\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, \n\t\t\t\t  0x400 + i, le16_to_cpu(data[i]));\n\t}\n\n\t \n\tfor (i = 0; i < MINISRC_LPF_LEN ; i++) {\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\n\t\t\t\t  0x400 + MINISRC_COEF_LOC + i,\n\t\t\t\t  minisrc_lpf[i]);\n\t}\n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\n\t\t\t  0x400 + MINISRC_COEF_LOC + MINISRC_LPF_LEN,\n\t\t\t  0x8000);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA, \n\t\t\t  KDATA_TASK0,\n\t\t\t  0x400);\n\n\t \n\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_MIXER_TASK_NUMBER,0);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_DAC_LEFT_VOLUME, ARB_VOLUME);\n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t  KDATA_DAC_RIGHT_VOLUME, ARB_VOLUME);\n\n\tchip->mixer_list.curlen = 0;\n\tchip->mixer_list.mem_addr = KDATA_MIXER_XFER0;\n\tchip->mixer_list.max = MAX_VIRTUAL_MIXER_CHANNELS;\n\tchip->adc1_list.curlen = 0;\n\tchip->adc1_list.mem_addr = KDATA_ADC1_XFER0;\n\tchip->adc1_list.max = MAX_VIRTUAL_ADC1_CHANNELS;\n\tchip->dma_list.curlen = 0;\n\tchip->dma_list.mem_addr = KDATA_DMA_XFER0;\n\tchip->dma_list.max = MAX_VIRTUAL_DMA_CHANNELS;\n\tchip->msrc_list.curlen = 0;\n\tchip->msrc_list.mem_addr = KDATA_INSTANCE0_MINISRC;\n\tchip->msrc_list.max = MAX_INSTANCE_MINISRC;\n}\n\n\nstatic int snd_m3_assp_client_init(struct snd_m3 *chip, struct m3_dma *s, int index)\n{\n\tint data_bytes = 2 * ( MINISRC_TMP_BUFFER_SIZE / 2 + \n\t\t\t       MINISRC_IN_BUFFER_SIZE / 2 +\n\t\t\t       1 + MINISRC_OUT_BUFFER_SIZE / 2 + 1 );\n\tint address, i;\n\n\t \n\n\t \n\tdata_bytes = ALIGN(data_bytes, 256);\n\taddress = 0x1100 + ((data_bytes/2) * index);\n\n\tif ((address + (data_bytes/2)) >= 0x1c00) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"no memory for %d bytes at ind %d (addr 0x%x)\\n\",\n\t\t\t   data_bytes, index, address);\n\t\treturn -ENOMEM;\n\t}\n\n\ts->number = index;\n\ts->inst.code = 0x400;\n\ts->inst.data = address;\n\n\tfor (i = data_bytes / 2; i > 0; address++, i--) {\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\n\t\t\t\t  address, 0);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void\nsnd_m3_amp_enable(struct snd_m3 *chip, int enable)\n{\n\tint io = chip->iobase;\n\tu16 gpo, polarity;\n\n\tif (! chip->external_amp)\n\t\treturn;\n\n\tpolarity = enable ? 0 : 1;\n\tpolarity = polarity << chip->amp_gpio;\n\tgpo = 1 << chip->amp_gpio;\n\n\toutw(~gpo, io + GPIO_MASK);\n\n\toutw(inw(io + GPIO_DIRECTION) | gpo,\n\t     io + GPIO_DIRECTION);\n\n\toutw((GPO_SECONDARY_AC97 | GPO_PRIMARY_AC97 | polarity),\n\t     io + GPIO_DATA);\n\n\toutw(0xffff, io + GPIO_MASK);\n}\n\nstatic void\nsnd_m3_hv_init(struct snd_m3 *chip)\n{\n\tunsigned long io = chip->iobase;\n\tu16 val = GPI_VOL_DOWN | GPI_VOL_UP;\n\n\tif (!chip->is_omnibook)\n\t\treturn;\n\n\t \n\toutw(0xffff, io + GPIO_MASK);\n\toutw(0x0000, io + GPIO_DATA);\n\n\toutw(~val, io + GPIO_MASK);\n\toutw(inw(io + GPIO_DIRECTION) & ~val, io + GPIO_DIRECTION);\n\toutw(val, io + GPIO_MASK);\n\n\toutw(0xffff, io + GPIO_MASK);\n}\n\nstatic int\nsnd_m3_chip_init(struct snd_m3 *chip)\n{\n\tstruct pci_dev *pcidev = chip->pci;\n\tunsigned long io = chip->iobase;\n\tu32 n;\n\tu16 w;\n\tu8 t;  \n\n\tpci_read_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, &w);\n\tw &= ~(SOUND_BLASTER_ENABLE|FM_SYNTHESIS_ENABLE|\n\t       MPU401_IO_ENABLE|MPU401_IRQ_ENABLE|ALIAS_10BIT_IO|\n\t       DISABLE_LEGACY);\n\tpci_write_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, w);\n\n\tpci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);\n\tn &= ~(HV_CTRL_ENABLE | REDUCED_DEBOUNCE | HV_BUTTON_FROM_GD);\n\tn |= chip->hv_config;\n\t \n\tn |= REDUCED_DEBOUNCE;\n\tn |= PM_CTRL_ENABLE | CLK_DIV_BY_49 | USE_PCI_TIMING;\n\tpci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);\n\n\toutb(RESET_ASSP, chip->iobase + ASSP_CONTROL_B);\n\tpci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);\n\tn &= ~INT_CLK_SELECT;\n\tif (!chip->allegro_flag) {\n\t\tn &= ~INT_CLK_MULT_ENABLE; \n\t\tn |= INT_CLK_SRC_NOT_PCI;\n\t}\n\tn &=  ~( CLK_MULT_MODE_SELECT | CLK_MULT_MODE_SELECT_2 );\n\tpci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);\n\n\tif (chip->allegro_flag) {\n\t\tpci_read_config_dword(pcidev, PCI_USER_CONFIG, &n);\n\t\tn |= IN_CLK_12MHZ_SELECT;\n\t\tpci_write_config_dword(pcidev, PCI_USER_CONFIG, n);\n\t}\n\n\tt = inb(chip->iobase + ASSP_CONTROL_A);\n\tt &= ~( DSP_CLK_36MHZ_SELECT  | ASSP_CLK_49MHZ_SELECT);\n\tt |= ASSP_CLK_49MHZ_SELECT;\n\tt |= ASSP_0_WS_ENABLE; \n\toutb(t, chip->iobase + ASSP_CONTROL_A);\n\n\tsnd_m3_assp_init(chip);  \n\toutb(RUN_ASSP, chip->iobase + ASSP_CONTROL_B); \n\n\toutb(0x00, io + HARDWARE_VOL_CTRL);\n\toutb(0x88, io + SHADOW_MIX_REG_VOICE);\n\toutb(0x88, io + HW_VOL_COUNTER_VOICE);\n\toutb(0x88, io + SHADOW_MIX_REG_MASTER);\n\toutb(0x88, io + HW_VOL_COUNTER_MASTER);\n\n\treturn 0;\n} \n\nstatic void\nsnd_m3_enable_ints(struct snd_m3 *chip)\n{\n\tunsigned long io = chip->iobase;\n\tunsigned short val;\n\n\t \n\tval = ASSP_INT_ENABLE  ;\n\tif (chip->hv_config & HV_CTRL_ENABLE)\n\t\tval |= HV_INT_ENABLE;\n\toutb(val, chip->iobase + HOST_INT_STATUS);\n\toutw(val, io + HOST_INT_CTRL);\n\toutb(inb(io + ASSP_CONTROL_C) | ASSP_HOST_INT_ENABLE,\n\t     io + ASSP_CONTROL_C);\n}\n\n\n \n\nstatic void snd_m3_free(struct snd_card *card)\n{\n\tstruct snd_m3 *chip = card->private_data;\n\tstruct m3_dma *s;\n\tint i;\n\n\tcancel_work_sync(&chip->hwvol_work);\n\n\tif (chip->substreams) {\n\t\tspin_lock_irq(&chip->reg_lock);\n\t\tfor (i = 0; i < chip->num_substreams; i++) {\n\t\t\ts = &chip->substreams[i];\n\t\t\t \n\t\t\tif (s->substream && s->running)\n\t\t\t\tsnd_m3_pcm_stop(chip, s, s->substream);\n\t\t}\n\t\tspin_unlock_irq(&chip->reg_lock);\n\t}\n\tif (chip->iobase) {\n\t\toutw(0, chip->iobase + HOST_INT_CTRL);  \n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\tvfree(chip->suspend_mem);\n#endif\n\trelease_firmware(chip->assp_kernel_image);\n\trelease_firmware(chip->assp_minisrc_image);\n}\n\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic int m3_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_m3 *chip = card->private_data;\n\tint i, dsp_index;\n\n\tif (chip->suspend_mem == NULL)\n\t\treturn 0;\n\n\tchip->in_suspend = 1;\n\tcancel_work_sync(&chip->hwvol_work);\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\n\tmsleep(10);  \n\n\tsnd_m3_assp_halt(chip);\n\n\t \n\tdsp_index = 0;\n\tfor (i = REV_B_CODE_MEMORY_BEGIN; i <= REV_B_CODE_MEMORY_END; i++)\n\t\tchip->suspend_mem[dsp_index++] =\n\t\t\tsnd_m3_assp_read(chip, MEMTYPE_INTERNAL_CODE, i);\n\tfor (i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)\n\t\tchip->suspend_mem[dsp_index++] =\n\t\t\tsnd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA, i);\n\treturn 0;\n}\n\nstatic int m3_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_m3 *chip = card->private_data;\n\tint i, dsp_index;\n\n\tif (chip->suspend_mem == NULL)\n\t\treturn 0;\n\n\t \n\tsnd_m3_outw(chip, 0, 0x54);\n\tsnd_m3_outw(chip, 0, 0x56);\n\n\tsnd_m3_chip_init(chip);\n\tsnd_m3_assp_halt(chip);\n\tsnd_m3_ac97_reset(chip);\n\n\t \n\tdsp_index = 0;\n\tfor (i = REV_B_CODE_MEMORY_BEGIN; i <= REV_B_CODE_MEMORY_END; i++)\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, i, \n\t\t\t\t  chip->suspend_mem[dsp_index++]);\n\tfor (i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)\n\t\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA, i, \n\t\t\t\t  chip->suspend_mem[dsp_index++]);\n\n\t \n\tsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA, \n\t\t\t  KDATA_DMA_ACTIVE, 0);\n\n         \n\tsnd_ac97_resume(chip->ac97);\n\n\tsnd_m3_assp_continue(chip);\n\tsnd_m3_enable_ints(chip);\n\tsnd_m3_amp_enable(chip, 1);\n\n\tsnd_m3_hv_init(chip);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\tchip->in_suspend = 0;\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(m3_pm, m3_suspend, m3_resume);\n#define M3_PM_OPS\t&m3_pm\n#else\n#define M3_PM_OPS\tNULL\n#endif  \n\n#ifdef CONFIG_SND_MAESTRO3_INPUT\nstatic int snd_m3_input_register(struct snd_m3 *chip)\n{\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tinput_dev = devm_input_allocate_device(&chip->pci->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(chip->phys, sizeof(chip->phys), \"pci-%s/input0\",\n\t\t pci_name(chip->pci));\n\n\tinput_dev->name = chip->card->driver;\n\tinput_dev->phys = chip->phys;\n\tinput_dev->id.bustype = BUS_PCI;\n\tinput_dev->id.vendor  = chip->pci->vendor;\n\tinput_dev->id.product = chip->pci->device;\n\tinput_dev->dev.parent = &chip->pci->dev;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(KEY_MUTE, input_dev->keybit);\n\t__set_bit(KEY_VOLUMEDOWN, input_dev->keybit);\n\t__set_bit(KEY_VOLUMEUP, input_dev->keybit);\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\tchip->input_dev = input_dev;\n\treturn 0;\n}\n#endif  \n\n \n\nstatic int\nsnd_m3_create(struct snd_card *card, struct pci_dev *pci,\n\t      int enable_amp,\n\t      int amp_gpio)\n{\n\tstruct snd_m3 *chip = card->private_data;\n\tint i, err;\n\tconst struct snd_pci_quirk *quirk;\n\n\tif (pcim_enable_device(pci))\n\t\treturn -EIO;\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(28))) {\n\t\tdev_err(card->dev,\n\t\t\t\"architecture does not support 28bit PCI busmaster DMA\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_init(&chip->reg_lock);\n\n\tswitch (pci->device) {\n\tcase PCI_DEVICE_ID_ESS_ALLEGRO:\n\tcase PCI_DEVICE_ID_ESS_ALLEGRO_1:\n\tcase PCI_DEVICE_ID_ESS_CANYON3D_2LE:\n\tcase PCI_DEVICE_ID_ESS_CANYON3D_2:\n\t\tchip->allegro_flag = 1;\n\t\tbreak;\n\t}\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tINIT_WORK(&chip->hwvol_work, snd_m3_update_hw_volume);\n\tcard->private_free = snd_m3_free;\n\n\tchip->external_amp = enable_amp;\n\tif (amp_gpio >= 0 && amp_gpio <= 0x0f)\n\t\tchip->amp_gpio = amp_gpio;\n\telse {\n\t\tquirk = snd_pci_quirk_lookup(pci, m3_amp_quirk_list);\n\t\tif (quirk) {\n\t\t\tdev_info(card->dev, \"set amp-gpio for '%s'\\n\",\n\t\t\t\t snd_pci_quirk_name(quirk));\n\t\t\tchip->amp_gpio = quirk->value;\n\t\t} else if (chip->allegro_flag)\n\t\t\tchip->amp_gpio = GPO_EXT_AMP_ALLEGRO;\n\t\telse  \n\t\t\tchip->amp_gpio = GPO_EXT_AMP_M3;\n\t}\n\n\tquirk = snd_pci_quirk_lookup(pci, m3_irda_quirk_list);\n\tif (quirk) {\n\t\tdev_info(card->dev, \"enabled irda workaround for '%s'\\n\",\n\t\t\t snd_pci_quirk_name(quirk));\n\t\tchip->irda_workaround = 1;\n\t}\n\tquirk = snd_pci_quirk_lookup(pci, m3_hv_quirk_list);\n\tif (quirk)\n\t\tchip->hv_config = quirk->value;\n\tif (snd_pci_quirk_lookup(pci, m3_omnibook_quirk_list))\n\t\tchip->is_omnibook = 1;\n\n\tchip->num_substreams = NR_DSPS;\n\tchip->substreams = devm_kcalloc(&pci->dev, chip->num_substreams,\n\t\t\t\t\tsizeof(struct m3_dma), GFP_KERNEL);\n\tif (!chip->substreams)\n\t\treturn -ENOMEM;\n\n\terr = request_firmware(&chip->assp_kernel_image,\n\t\t\t       \"ess/maestro3_assp_kernel.fw\", &pci->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = request_firmware(&chip->assp_minisrc_image,\n\t\t\t       \"ess/maestro3_assp_minisrc.fw\", &pci->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_request_regions(pci, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->iobase = pci_resource_start(pci, 0);\n\t\n\t \n\tpci_set_master(pci);\n\n\tsnd_m3_chip_init(chip);\n\tsnd_m3_assp_halt(chip);\n\n\tsnd_m3_ac97_reset(chip);\n\n\tsnd_m3_amp_enable(chip, 1);\n\n\tsnd_m3_hv_init(chip);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_m3_interrupt, IRQF_SHARED,\n\t\t\t     KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -ENOMEM;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n#ifdef CONFIG_PM_SLEEP\n\tchip->suspend_mem =\n\t\tvmalloc(array_size(sizeof(u16),\n\t\t\t\t   REV_B_CODE_MEMORY_LENGTH +\n\t\t\t\t\tREV_B_DATA_MEMORY_LENGTH));\n\tif (chip->suspend_mem == NULL)\n\t\tdev_warn(card->dev, \"can't allocate apm buffer\\n\");\n#endif\n\n\terr = snd_m3_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < chip->num_substreams; i++) {\n\t\tstruct m3_dma *s = &chip->substreams[i];\n\t\terr = snd_m3_assp_client_init(chip, s, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = snd_m3_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CONFIG_SND_MAESTRO3_INPUT\n\tif (chip->hv_config & HV_CTRL_ENABLE) {\n\t\terr = snd_m3_input_register(chip);\n\t\tif (err)\n\t\t\tdev_warn(card->dev,\n\t\t\t\t \"Input device registration failed with error %i\",\n\t\t\t\t err);\n\t}\n#endif\n\n\tsnd_m3_enable_ints(chip);\n\tsnd_m3_assp_continue(chip);\n\n\treturn 0; \n}\n\n \nstatic int\n__snd_m3_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_m3 *chip;\n\tint err;\n\n\t \n\tif (((pci->class >> 8) & 0xffff) != PCI_CLASS_MULTIMEDIA_AUDIO)\n\t\treturn -ENODEV;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tswitch (pci->device) {\n\tcase PCI_DEVICE_ID_ESS_ALLEGRO:\n\tcase PCI_DEVICE_ID_ESS_ALLEGRO_1:\n\t\tstrcpy(card->driver, \"Allegro\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_ESS_CANYON3D_2LE:\n\tcase PCI_DEVICE_ID_ESS_CANYON3D_2:\n\t\tstrcpy(card->driver, \"Canyon3D-2\");\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(card->driver, \"Maestro3\");\n\t\tbreak;\n\t}\n\n\terr = snd_m3_create(card, pci, external_amp[dev], amp_gpio[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(card->shortname, \"ESS %s PCI\", card->driver);\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\",\n\t\tcard->shortname, chip->iobase, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n#if 0  \n\t \n\terr = snd_mpu401_uart_new(chip->card, 0, MPU401_HW_MPU401,\n\t\t\t\t  chip->iobase + MPU401_DATA_PORT,\n\t\t\t\t  MPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\n\t\t\t\t  -1, &chip->rmidi);\n\tif (err < 0)\n\t\tdev_warn(card->dev, \"no MIDI support.\\n\");\n#endif\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int\nsnd_m3_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_m3_probe(pci, pci_id));\n}\n\nstatic struct pci_driver m3_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_m3_ids,\n\t.probe = snd_m3_probe,\n\t.driver = {\n\t\t.pm = M3_PM_OPS,\n\t},\n};\n\t\nmodule_pci_driver(m3_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}