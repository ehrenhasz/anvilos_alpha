{
  "module_name": "hpicmn.c",
  "hash_id": "12049f9c6d6116333f116378debfcb9f0d1934fc01ae620e43939d10864386c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpicmn.c",
  "human_readable_source": "\n \n#define SOURCEFILE_NAME \"hpicmn.c\"\n\n#include \"hpi_internal.h\"\n#include \"hpidebug.h\"\n#include \"hpimsginit.h\"\n\n#include \"hpicmn.h\"\n\nstruct hpi_adapters_list {\n\tstruct hpios_spinlock list_lock;\n\tstruct hpi_adapter_obj adapter[HPI_MAX_ADAPTERS];\n\tu16 gw_num_adapters;\n};\n\nstatic struct hpi_adapters_list adapters;\n\n \nu16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tif (phr->type != HPI_TYPE_RESPONSE) {\n\t\tHPI_DEBUG_LOG(ERROR, \"header type %d invalid\\n\", phr->type);\n\t\treturn HPI_ERROR_INVALID_RESPONSE;\n\t}\n\n\tif (phr->object != phm->object) {\n\t\tHPI_DEBUG_LOG(ERROR, \"header object %d invalid\\n\",\n\t\t\tphr->object);\n\t\treturn HPI_ERROR_INVALID_RESPONSE;\n\t}\n\n\tif (phr->function != phm->function) {\n\t\tHPI_DEBUG_LOG(ERROR, \"header function %d invalid\\n\",\n\t\t\tphr->function);\n\t\treturn HPI_ERROR_INVALID_RESPONSE;\n\t}\n\n\treturn 0;\n}\n\nu16 hpi_add_adapter(struct hpi_adapter_obj *pao)\n{\n\tu16 retval = 0;\n\t \n\n\thpios_alistlock_lock(&adapters);\n\n\tif (pao->index >= HPI_MAX_ADAPTERS) {\n\t\tretval = HPI_ERROR_BAD_ADAPTER_NUMBER;\n\t\tgoto unlock;\n\t}\n\n\tif (adapters.adapter[pao->index].type) {\n\t\tint a;\n\t\tfor (a = HPI_MAX_ADAPTERS - 1; a >= 0; a--) {\n\t\t\tif (!adapters.adapter[a].type) {\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"ASI%X duplicate index %d moved to %d\\n\",\n\t\t\t\t\tpao->type, pao->index, a);\n\t\t\t\tpao->index = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (a < 0) {\n\t\t\tretval = HPI_ERROR_DUPLICATE_ADAPTER_NUMBER;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tadapters.adapter[pao->index] = *pao;\n\thpios_dsplock_init(&adapters.adapter[pao->index]);\n\tadapters.gw_num_adapters++;\n\nunlock:\n\thpios_alistlock_unlock(&adapters);\n\treturn retval;\n}\n\nvoid hpi_delete_adapter(struct hpi_adapter_obj *pao)\n{\n\tif (!pao->type) {\n\t\tHPI_DEBUG_LOG(ERROR, \"removing null adapter?\\n\");\n\t\treturn;\n\t}\n\n\thpios_alistlock_lock(&adapters);\n\tif (adapters.adapter[pao->index].type)\n\t\tadapters.gw_num_adapters--;\n\tmemset(&adapters.adapter[pao->index], 0, sizeof(adapters.adapter[0]));\n\thpios_alistlock_unlock(&adapters);\n}\n\n \nstruct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)\n{\n\tstruct hpi_adapter_obj *pao = NULL;\n\n\tif (adapter_index >= HPI_MAX_ADAPTERS) {\n\t\tHPI_DEBUG_LOG(VERBOSE, \"find_adapter invalid index %d\\n\",\n\t\t\tadapter_index);\n\t\treturn NULL;\n\t}\n\n\tpao = &adapters.adapter[adapter_index];\n\tif (pao->type != 0) {\n\t\t \n\t\treturn pao;\n\t} else {\n\t\t \n\t\treturn NULL;\n\t}\n}\n\n \nstatic void wipe_adapter_list(void)\n{\n\tmemset(&adapters, 0, sizeof(adapters));\n}\n\nstatic void subsys_get_adapter(struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\tint count = phm->obj_index;\n\tu16 index = 0;\n\n\t \n\tfor (index = 0; index < HPI_MAX_ADAPTERS; index++) {\n\t\tif (adapters.adapter[index].type) {\n\t\t\tif (!count)\n\t\t\t\tbreak;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\tif (index < HPI_MAX_ADAPTERS) {\n\t\tphr->u.s.adapter_index = adapters.adapter[index].index;\n\t\tphr->u.s.adapter_type = adapters.adapter[index].type;\n\t} else {\n\t\tphr->u.s.adapter_index = 0;\n\t\tphr->u.s.adapter_type = 0;\n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\t}\n}\n\nstatic unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)\n{\n\tunsigned int i;\n\tint cached = 0;\n\tif (!pC)\n\t\treturn 0;\n\n\tif (pC->init)\n\t\treturn pC->init;\n\n\tif (!pC->p_cache)\n\t\treturn 0;\n\n\tif (pC->control_count && pC->cache_size_in_bytes) {\n\t\tchar *p_master_cache;\n\t\tunsigned int byte_count = 0;\n\n\t\tp_master_cache = (char *)pC->p_cache;\n\t\tHPI_DEBUG_LOG(DEBUG, \"check %d controls\\n\",\n\t\t\tpC->control_count);\n\t\tfor (i = 0; i < pC->control_count; i++) {\n\t\t\tstruct hpi_control_cache_info *info =\n\t\t\t\t(struct hpi_control_cache_info *)\n\t\t\t\t&p_master_cache[byte_count];\n\t\t\tu16 control_index = info->control_index;\n\n\t\t\tif (control_index >= pC->control_count) {\n\t\t\t\tHPI_DEBUG_LOG(INFO,\n\t\t\t\t\t\"adap %d control index %d out of range, cache not ready?\\n\",\n\t\t\t\t\tpC->adap_idx, control_index);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!info->size_in32bit_words) {\n\t\t\t\tif (!i) {\n\t\t\t\t\tHPI_DEBUG_LOG(INFO,\n\t\t\t\t\t\t\"adap %d cache not ready?\\n\",\n\t\t\t\t\t\tpC->adap_idx);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\"adap %d zero size cache entry %d\\n\",\n\t\t\t\t\tpC->adap_idx, i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (info->control_type) {\n\t\t\t\tpC->p_info[control_index] = info;\n\t\t\t\tcached++;\n\t\t\t} else {\t \n\t\t\t\tpC->p_info[control_index] = NULL;\n\t\t\t}\n\n\t\t\tbyte_count += info->size_in32bit_words * 4;\n\n\t\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\t\"cached %d, pinfo %p index %d type %d size %d\\n\",\n\t\t\t\tcached, pC->p_info[info->control_index],\n\t\t\t\tinfo->control_index, info->control_type,\n\t\t\t\tinfo->size_in32bit_words);\n\n\t\t\t \n\t\t\tif (byte_count >= pC->cache_size_in_bytes)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (info->control_index == pC->control_count - 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (byte_count != pC->cache_size_in_bytes)\n\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\"adap %d bytecount %d != cache size %d\\n\",\n\t\t\t\tpC->adap_idx, byte_count,\n\t\t\t\tpC->cache_size_in_bytes);\n\t\telse\n\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\"adap %d cache good, bytecount == cache size = %d\\n\",\n\t\t\t\tpC->adap_idx, byte_count);\n\n\t\tpC->init = (u16)cached;\n\t}\n\treturn pC->init;\n}\n\n \nstatic short find_control(u16 control_index,\n\tstruct hpi_control_cache *p_cache, struct hpi_control_cache_info **pI)\n{\n\tif (!control_cache_alloc_check(p_cache)) {\n\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\"control_cache_alloc_check() failed %d\\n\",\n\t\t\tcontrol_index);\n\t\treturn 0;\n\t}\n\n\t*pI = p_cache->p_info[control_index];\n\tif (!*pI) {\n\t\tHPI_DEBUG_LOG(VERBOSE, \"Uncached Control %d\\n\",\n\t\t\tcontrol_index);\n\t\treturn 0;\n\t} else {\n\t\tHPI_DEBUG_LOG(VERBOSE, \"find_control() type %d\\n\",\n\t\t\t(*pI)->control_type);\n\t}\n\treturn 1;\n}\n\n \n#define HPICMN_PAD_OFS_AND_SIZE(m)  {\\\n\toffsetof(struct hpi_control_cache_pad, m), \\\n\tsizeof(((struct hpi_control_cache_pad *)(NULL))->m) }\n\nstruct pad_ofs_size {\n\tunsigned int offset;\n\tunsigned int field_size;\n};\n\nstatic const struct pad_ofs_size pad_desc[] = {\n\tHPICMN_PAD_OFS_AND_SIZE(c_channel),\t \n\tHPICMN_PAD_OFS_AND_SIZE(c_artist),\t \n\tHPICMN_PAD_OFS_AND_SIZE(c_title),\t \n\tHPICMN_PAD_OFS_AND_SIZE(c_comment),\t \n};\n\n \nshort hpi_check_control_cache_single(struct hpi_control_cache_single *pC,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tsize_t response_size;\n\tshort found = 1;\n\n\t \n\tresponse_size =\n\t\tsizeof(struct hpi_response_header) +\n\t\tsizeof(struct hpi_control_res);\n\n\tswitch (pC->u.i.control_type) {\n\n\tcase HPI_CONTROL_METER:\n\t\tif (phm->u.c.attribute == HPI_METER_PEAK) {\n\t\t\tphr->u.c.an_log_value[0] = pC->u.meter.an_log_peak[0];\n\t\t\tphr->u.c.an_log_value[1] = pC->u.meter.an_log_peak[1];\n\t\t} else if (phm->u.c.attribute == HPI_METER_RMS) {\n\t\t\tif (pC->u.meter.an_logRMS[0] ==\n\t\t\t\tHPI_CACHE_INVALID_SHORT) {\n\t\t\t\tphr->error =\n\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t\tphr->u.c.an_log_value[0] = HPI_METER_MINIMUM;\n\t\t\t\tphr->u.c.an_log_value[1] = HPI_METER_MINIMUM;\n\t\t\t} else {\n\t\t\t\tphr->u.c.an_log_value[0] =\n\t\t\t\t\tpC->u.meter.an_logRMS[0];\n\t\t\t\tphr->u.c.an_log_value[1] =\n\t\t\t\t\tpC->u.meter.an_logRMS[1];\n\t\t\t}\n\t\t} else\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_VOLUME:\n\t\tif (phm->u.c.attribute == HPI_VOLUME_GAIN) {\n\t\t\tphr->u.c.an_log_value[0] = pC->u.vol.an_log[0];\n\t\t\tphr->u.c.an_log_value[1] = pC->u.vol.an_log[1];\n\t\t} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {\n\t\t\tif (pC->u.vol.flags & HPI_VOLUME_FLAG_HAS_MUTE) {\n\t\t\t\tif (pC->u.vol.flags & HPI_VOLUME_FLAG_MUTED)\n\t\t\t\t\tphr->u.c.param1 =\n\t\t\t\t\t\tHPI_BITMASK_ALL_CHANNELS;\n\t\t\t\telse\n\t\t\t\t\tphr->u.c.param1 = 0;\n\t\t\t} else {\n\t\t\t\tphr->error =\n\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t\tphr->u.c.param1 = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfound = 0;\n\t\t}\n\t\tbreak;\n\tcase HPI_CONTROL_MULTIPLEXER:\n\t\tif (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {\n\t\t\tphr->u.c.param1 = pC->u.mux.source_node_type;\n\t\t\tphr->u.c.param2 = pC->u.mux.source_node_index;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t}\n\t\tbreak;\n\tcase HPI_CONTROL_CHANNEL_MODE:\n\t\tif (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)\n\t\t\tphr->u.c.param1 = pC->u.mode.mode;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_LEVEL:\n\t\tif (phm->u.c.attribute == HPI_LEVEL_GAIN) {\n\t\t\tphr->u.c.an_log_value[0] = pC->u.level.an_log[0];\n\t\t\tphr->u.c.an_log_value[1] = pC->u.level.an_log[1];\n\t\t} else\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_TUNER:\n\t\tif (phm->u.c.attribute == HPI_TUNER_FREQ)\n\t\t\tphr->u.c.param1 = pC->u.tuner.freq_ink_hz;\n\t\telse if (phm->u.c.attribute == HPI_TUNER_BAND)\n\t\t\tphr->u.c.param1 = pC->u.tuner.band;\n\t\telse if (phm->u.c.attribute == HPI_TUNER_LEVEL_AVG)\n\t\t\tif (pC->u.tuner.s_level_avg ==\n\t\t\t\tHPI_CACHE_INVALID_SHORT) {\n\t\t\t\tphr->u.cu.tuner.s_level = 0;\n\t\t\t\tphr->error =\n\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t} else\n\t\t\t\tphr->u.cu.tuner.s_level =\n\t\t\t\t\tpC->u.tuner.s_level_avg;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_AESEBU_RECEIVER:\n\t\tif (phm->u.c.attribute == HPI_AESEBURX_ERRORSTATUS)\n\t\t\tphr->u.c.param1 = pC->u.aes3rx.error_status;\n\t\telse if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)\n\t\t\tphr->u.c.param1 = pC->u.aes3rx.format;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_AESEBU_TRANSMITTER:\n\t\tif (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)\n\t\t\tphr->u.c.param1 = pC->u.aes3tx.format;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_TONEDETECTOR:\n\t\tif (phm->u.c.attribute == HPI_TONEDETECTOR_STATE)\n\t\t\tphr->u.c.param1 = pC->u.tone.state;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_SILENCEDETECTOR:\n\t\tif (phm->u.c.attribute == HPI_SILENCEDETECTOR_STATE) {\n\t\t\tphr->u.c.param1 = pC->u.silence.state;\n\t\t} else\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_MICROPHONE:\n\t\tif (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)\n\t\t\tphr->u.c.param1 = pC->u.microphone.phantom_state;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_SAMPLECLOCK:\n\t\tif (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)\n\t\t\tphr->u.c.param1 = pC->u.clk.source;\n\t\telse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX) {\n\t\t\tif (pC->u.clk.source_index ==\n\t\t\t\tHPI_CACHE_INVALID_UINT16) {\n\t\t\t\tphr->u.c.param1 = 0;\n\t\t\t\tphr->error =\n\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t} else\n\t\t\t\tphr->u.c.param1 = pC->u.clk.source_index;\n\t\t} else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)\n\t\t\tphr->u.c.param1 = pC->u.clk.sample_rate;\n\t\telse\n\t\t\tfound = 0;\n\t\tbreak;\n\tcase HPI_CONTROL_PAD:{\n\t\t\tstruct hpi_control_cache_pad *p_pad;\n\t\t\tp_pad = (struct hpi_control_cache_pad *)pC;\n\n\t\t\tif (!(p_pad->field_valid_flags & (1 <<\n\t\t\t\t\t\tHPI_CTL_ATTR_INDEX(phm->u.c.\n\t\t\t\t\t\t\tattribute)))) {\n\t\t\t\tphr->error =\n\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (phm->u.c.attribute == HPI_PAD_PROGRAM_ID)\n\t\t\t\tphr->u.c.param1 = p_pad->pI;\n\t\t\telse if (phm->u.c.attribute == HPI_PAD_PROGRAM_TYPE)\n\t\t\t\tphr->u.c.param1 = p_pad->pTY;\n\t\t\telse {\n\t\t\t\tunsigned int index =\n\t\t\t\t\tHPI_CTL_ATTR_INDEX(phm->u.c.\n\t\t\t\t\tattribute) - 1;\n\t\t\t\tunsigned int offset = phm->u.c.param1;\n\t\t\t\tunsigned int pad_string_len, field_size;\n\t\t\t\tchar *pad_string;\n\t\t\t\tunsigned int tocopy;\n\n\t\t\t\tif (index > ARRAY_SIZE(pad_desc) - 1) {\n\t\t\t\t\tphr->error =\n\t\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_ATTRIBUTE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpad_string =\n\t\t\t\t\t((char *)p_pad) +\n\t\t\t\t\tpad_desc[index].offset;\n\t\t\t\tfield_size = pad_desc[index].field_size;\n\t\t\t\t \n\t\t\t\tpad_string[field_size - 1] = 0;\n\n\t\t\t\tpad_string_len = strlen(pad_string) + 1;\n\n\t\t\t\tif (offset > pad_string_len) {\n\t\t\t\t\tphr->error =\n\t\t\t\t\t\tHPI_ERROR_INVALID_CONTROL_VALUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttocopy = pad_string_len - offset;\n\t\t\t\tif (tocopy > sizeof(phr->u.cu.chars8.sz_data))\n\t\t\t\t\ttocopy = sizeof(phr->u.cu.chars8.\n\t\t\t\t\t\tsz_data);\n\n\t\t\t\tmemcpy(phr->u.cu.chars8.sz_data,\n\t\t\t\t\t&pad_string[offset], tocopy);\n\n\t\t\t\tphr->u.cu.chars8.remaining_chars =\n\t\t\t\t\tpad_string_len - offset - tocopy;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfound = 0;\n\t\tbreak;\n\t}\n\n\tHPI_DEBUG_LOG(VERBOSE, \"%s Adap %d, Ctl %d, Type %d, Attr %d\\n\",\n\t\tfound ? \"Cached\" : \"Uncached\", phm->adapter_index,\n\t\tpC->u.i.control_index, pC->u.i.control_type,\n\t\tphm->u.c.attribute);\n\n\tif (found) {\n\t\tphr->size = (u16)response_size;\n\t\tphr->type = HPI_TYPE_RESPONSE;\n\t\tphr->object = phm->object;\n\t\tphr->function = phm->function;\n\t}\n\n\treturn found;\n}\n\nshort hpi_check_control_cache(struct hpi_control_cache *p_cache,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_control_cache_info *pI;\n\n\tif (!find_control(phm->obj_index, p_cache, &pI)) {\n\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\"HPICMN find_control() failed for adap %d\\n\",\n\t\t\tphm->adapter_index);\n\t\treturn 0;\n\t}\n\n\tphr->error = 0;\n\tphr->specific_error = 0;\n\tphr->version = 0;\n\n\treturn hpi_check_control_cache_single((struct hpi_control_cache_single\n\t\t\t*)pI, phm, phr);\n}\n\n \nvoid hpi_cmn_control_cache_sync_to_msg_single(struct hpi_control_cache_single\n\t*pC, struct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (pC->u.i.control_type) {\n\tcase HPI_CONTROL_VOLUME:\n\t\tif (phm->u.c.attribute == HPI_VOLUME_GAIN) {\n\t\t\tpC->u.vol.an_log[0] = phr->u.c.an_log_value[0];\n\t\t\tpC->u.vol.an_log[1] = phr->u.c.an_log_value[1];\n\t\t} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {\n\t\t\tif (phm->u.c.param1)\n\t\t\t\tpC->u.vol.flags |= HPI_VOLUME_FLAG_MUTED;\n\t\t\telse\n\t\t\t\tpC->u.vol.flags &= ~HPI_VOLUME_FLAG_MUTED;\n\t\t}\n\t\tbreak;\n\tcase HPI_CONTROL_MULTIPLEXER:\n\t\t \n\t\tif (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {\n\t\t\tpC->u.mux.source_node_type = (u16)phm->u.c.param1;\n\t\t\tpC->u.mux.source_node_index = (u16)phm->u.c.param2;\n\t\t}\n\t\tbreak;\n\tcase HPI_CONTROL_CHANNEL_MODE:\n\t\t \n\t\tif (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)\n\t\t\tpC->u.mode.mode = (u16)phm->u.c.param1;\n\t\tbreak;\n\tcase HPI_CONTROL_LEVEL:\n\t\tif (phm->u.c.attribute == HPI_LEVEL_GAIN) {\n\t\t\tpC->u.vol.an_log[0] = phr->u.c.an_log_value[0];\n\t\t\tpC->u.vol.an_log[1] = phr->u.c.an_log_value[1];\n\t\t}\n\t\tbreak;\n\tcase HPI_CONTROL_MICROPHONE:\n\t\tif (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)\n\t\t\tpC->u.microphone.phantom_state = (u16)phm->u.c.param1;\n\t\tbreak;\n\tcase HPI_CONTROL_AESEBU_TRANSMITTER:\n\t\tif (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)\n\t\t\tpC->u.aes3tx.format = phm->u.c.param1;\n\t\tbreak;\n\tcase HPI_CONTROL_AESEBU_RECEIVER:\n\t\tif (phm->u.c.attribute == HPI_AESEBURX_FORMAT)\n\t\t\tpC->u.aes3rx.format = phm->u.c.param1;\n\t\tbreak;\n\tcase HPI_CONTROL_SAMPLECLOCK:\n\t\tif (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)\n\t\t\tpC->u.clk.source = (u16)phm->u.c.param1;\n\t\telse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX)\n\t\t\tpC->u.clk.source_index = (u16)phm->u.c.param1;\n\t\telse if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)\n\t\t\tpC->u.clk.sample_rate = phm->u.c.param1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_control_cache_single *pC;\n\tstruct hpi_control_cache_info *pI;\n\n\tif (phr->error)\n\t\treturn;\n\n\tif (!find_control(phm->obj_index, p_cache, &pI)) {\n\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\"HPICMN find_control() failed for adap %d\\n\",\n\t\t\tphm->adapter_index);\n\t\treturn;\n\t}\n\n\t \n\tpC = (struct hpi_control_cache_single *)pI;\n\n\thpi_cmn_control_cache_sync_to_msg_single(pC, phm, phr);\n}\n\n \nstruct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,\n\tconst u32 size_in_bytes, u8 *p_dsp_control_buffer)\n{\n\tstruct hpi_control_cache *p_cache =\n\t\tkmalloc(sizeof(*p_cache), GFP_KERNEL);\n\tif (!p_cache)\n\t\treturn NULL;\n\n\tp_cache->p_info =\n\t\tkcalloc(control_count, sizeof(*p_cache->p_info), GFP_KERNEL);\n\tif (!p_cache->p_info) {\n\t\tkfree(p_cache);\n\t\treturn NULL;\n\t}\n\n\tp_cache->cache_size_in_bytes = size_in_bytes;\n\tp_cache->control_count = control_count;\n\tp_cache->p_cache = p_dsp_control_buffer;\n\tp_cache->init = 0;\n\treturn p_cache;\n}\n\nvoid hpi_free_control_cache(struct hpi_control_cache *p_cache)\n{\n\tif (p_cache) {\n\t\tkfree(p_cache->p_info);\n\t\tkfree(p_cache);\n\t}\n}\n\nstatic void subsys_message(struct hpi_message *phm, struct hpi_response *phr)\n{\n\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function, 0);\n\n\tswitch (phm->function) {\n\tcase HPI_SUBSYS_OPEN:\n\tcase HPI_SUBSYS_CLOSE:\n\tcase HPI_SUBSYS_DRIVER_UNLOAD:\n\t\tbreak;\n\tcase HPI_SUBSYS_DRIVER_LOAD:\n\t\twipe_adapter_list();\n\t\thpios_alistlock_init(&adapters);\n\t\tbreak;\n\tcase HPI_SUBSYS_GET_ADAPTER:\n\t\tsubsys_get_adapter(phm, phr);\n\t\tbreak;\n\tcase HPI_SUBSYS_GET_NUM_ADAPTERS:\n\t\tphr->u.s.num_adapters = adapters.gw_num_adapters;\n\t\tbreak;\n\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tbreak;\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\t}\n}\n\nvoid HPI_COMMON(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->type) {\n\tcase HPI_TYPE_REQUEST:\n\t\tswitch (phm->object) {\n\t\tcase HPI_OBJ_SUBSYSTEM:\n\t\t\tsubsys_message(phm, phr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_TYPE;\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}