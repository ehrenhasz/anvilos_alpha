{
  "module_name": "hpioctl.c",
  "hash_id": "df27bb592bf4a6b86cab1686c9934cd1de4b891a745a7a98218decfb5f006d9c",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpioctl.c",
  "human_readable_source": "\n \n#define SOURCEFILE_NAME \"hpioctl.c\"\n\n#include \"hpi_internal.h\"\n#include \"hpi_version.h\"\n#include \"hpimsginit.h\"\n#include \"hpidebug.h\"\n#include \"hpimsgx.h\"\n#include \"hpioctl.h\"\n#include \"hpicmn.h\"\n\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/moduleparam.h>\n#include <linux/uaccess.h>\n#include <linux/pci.h>\n#include <linux/stringify.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nospec.h>\n\n#ifdef MODULE_FIRMWARE\nMODULE_FIRMWARE(\"asihpi/dsp5000.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp6200.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp6205.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp6400.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp6600.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp8700.bin\");\nMODULE_FIRMWARE(\"asihpi/dsp8900.bin\");\n#endif\n\nstatic int prealloc_stream_buf;\nmodule_param(prealloc_stream_buf, int, 0444);\nMODULE_PARM_DESC(prealloc_stream_buf,\n\t\"Preallocate size for per-adapter stream buffer\");\n\n \nmodule_param(hpi_debug_level, int, 0644);\nMODULE_PARM_DESC(hpi_debug_level, \"debug verbosity 0..5\");\n\n \nstatic struct hpi_adapter adapters[HPI_MAX_ADAPTERS];\n\n \nstatic void hpi_send_recv_f(struct hpi_message *phm, struct hpi_response *phr,\n\tstruct file *file)\n{\n\tif ((phm->adapter_index >= HPI_MAX_ADAPTERS)\n\t\t&& (phm->object != HPI_OBJ_SUBSYSTEM))\n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\telse\n\t\thpi_send_recv_ex(phm, phr, file);\n}\n\n \nvoid hpi_send_recv(struct hpi_message *phm, struct hpi_response *phr)\n{\n\thpi_send_recv_f(phm, phr, HOWNER_KERNEL);\n}\n\nEXPORT_SYMBOL(hpi_send_recv);\n \n\nint asihpi_hpi_release(struct file *file)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n \n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_CLOSE);\n\thpi_send_recv_ex(&hm, &hr, file);\n\treturn 0;\n}\n\nlong asihpi_hpi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hpi_ioctl_linux __user *phpi_ioctl_data;\n\tvoid __user *puhm;\n\tvoid __user *puhr;\n\tunion hpi_message_buffer_v1 *hm;\n\tunion hpi_response_buffer_v1 *hr;\n\tu16 msg_size;\n\tu16 res_max_size;\n\tu32 uncopied_bytes;\n\tint err = 0;\n\n\tif (cmd != HPI_IOCTL_LINUX)\n\t\treturn -EINVAL;\n\n\thm = kmalloc(sizeof(*hm), GFP_KERNEL);\n\thr = kzalloc(sizeof(*hr), GFP_KERNEL);\n\tif (!hm || !hr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphpi_ioctl_data = (struct hpi_ioctl_linux __user *)arg;\n\n\t \n\tif (get_user(puhm, &phpi_ioctl_data->phm)\n\t\t|| get_user(puhr, &phpi_ioctl_data->phr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (get_user(msg_size, (u16 __user *)puhm)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (msg_size > sizeof(*hm))\n\t\tmsg_size = sizeof(*hm);\n\n\t \n\n\tuncopied_bytes = copy_from_user(hm, puhm, msg_size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t \n\thm->h.size = msg_size;\n\n\tif (get_user(res_max_size, (u16 __user *)puhr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\tif (res_max_size < sizeof(struct hpi_response_header)) {\n\t\tHPI_DEBUG_LOG(WARNING, \"small res size %d\\n\", res_max_size);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tres_max_size = min_t(size_t, res_max_size, sizeof(*hr));\n\n\tswitch (hm->h.function) {\n\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\tcase HPI_ADAPTER_DELETE:\n\t\t \n\t\thr->h.size = sizeof(hr->h);\n\t\thr->h.error = HPI_ERROR_INVALID_OPERATION;\n\t\thr->h.function = hm->h.function;\n\t\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\t\tif (uncopied_bytes)\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\thr->h.size = res_max_size;\n\tif (hm->h.object == HPI_OBJ_SUBSYSTEM) {\n\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\t} else {\n\t\tu16 __user *ptr = NULL;\n\t\tu32 size = 0;\n\t\t \n\t\tint wrflag = -1;\n\t\tstruct hpi_adapter *pa = NULL;\n\n\t\tif (hm->h.adapter_index < ARRAY_SIZE(adapters))\n\t\t\tpa = &adapters[array_index_nospec(hm->h.adapter_index,\n\t\t\t\t\t\t\t  ARRAY_SIZE(adapters))];\n\n\t\tif (!pa || !pa->adapter || !pa->adapter->type) {\n\t\t\thpi_init_response(&hr->r0, hm->h.object,\n\t\t\t\thm->h.function, HPI_ERROR_BAD_ADAPTER_NUMBER);\n\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(puhr, hr, sizeof(hr->h));\n\t\t\tif (uncopied_bytes)\n\t\t\t\terr = -EFAULT;\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&pa->mutex)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tswitch (hm->h.function) {\n\t\tcase HPI_OSTREAM_WRITE:\n\t\tcase HPI_ISTREAM_READ:{\n\t\t\t\t \n\t\t\t\tptr = (u16 __user *)hm->m0.u.d.u.data.pb_data;\n\t\t\t\tsize = hm->m0.u.d.u.data.data_size;\n\n\t\t\t\t \n\t\t\t\tif (pa->buffer_size < size) {\n\t\t\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\t\t\"Realloc adapter %d stream \"\n\t\t\t\t\t\t\"buffer from %zd to %d\\n\",\n\t\t\t\t\t\thm->h.adapter_index,\n\t\t\t\t\t\tpa->buffer_size, size);\n\t\t\t\t\tif (pa->p_buffer) {\n\t\t\t\t\t\tpa->buffer_size = 0;\n\t\t\t\t\t\tvfree(pa->p_buffer);\n\t\t\t\t\t}\n\t\t\t\t\tpa->p_buffer = vmalloc(size);\n\t\t\t\t\tif (pa->p_buffer)\n\t\t\t\t\t\tpa->buffer_size = size;\n\t\t\t\t\telse {\n\t\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\t\"HPI could not allocate \"\n\t\t\t\t\t\t\t\"stream buffer size %d\\n\",\n\t\t\t\t\t\t\tsize);\n\n\t\t\t\t\t\tmutex_unlock(&pa->mutex);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thm->m0.u.d.u.data.pb_data = pa->p_buffer;\n\t\t\t\tif (hm->h.function == HPI_ISTREAM_READ)\n\t\t\t\t\t \n\t\t\t\t\twrflag = 1;\n\t\t\t\telse\n\t\t\t\t\twrflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size && (wrflag == 0)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_from_user(pa->p_buffer, ptr, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \"\n\t\t\t\t\t\"bytes from user\\n\", uncopied_bytes,\n\t\t\t\t\tsize);\n\t\t}\n\n\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\n\t\tif (size && (wrflag == 1)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(ptr, pa->p_buffer, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \" \"bytes to user\\n\",\n\t\t\t\t\tuncopied_bytes, size);\n\t\t}\n\n\t\tmutex_unlock(&pa->mutex);\n\t}\n\n\t \n\t \n\n\tif (!hr->h.size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response zero size\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hr->h.size > res_max_size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response too big %d %d\\n\", hr->h.size,\n\t\t\tres_max_size);\n\t\thr->h.error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\t\thr->h.specific_error = hr->h.size;\n\t\thr->h.size = sizeof(hr->h);\n\t}\n\n\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(hm);\n\tkfree(hr);\n\treturn err;\n}\n\nstatic int asihpi_irq_count;\n\nstatic irqreturn_t asihpi_isr(int irq, void *dev_id)\n{\n\tstruct hpi_adapter *a = dev_id;\n\tint handled;\n\n\tif (!a->adapter->irq_query_and_clear) {\n\t\tpr_err(\"asihpi_isr ASI%04X:%d no handler\\n\", a->adapter->type,\n\t\t\ta->adapter->index);\n\t\treturn IRQ_NONE;\n\t}\n\n\thandled = a->adapter->irq_query_and_clear(a->adapter, 0);\n\n\tif (!handled)\n\t\treturn IRQ_NONE;\n\n\tasihpi_irq_count++;\n\t \n\n\tif (a->interrupt_callback)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t asihpi_isr_thread(int irq, void *dev_id)\n{\n\tstruct hpi_adapter *a = dev_id;\n\n\tif (a->interrupt_callback)\n\t\ta->interrupt_callback(a);\n\treturn IRQ_HANDLED;\n}\n\nint asihpi_adapter_probe(struct pci_dev *pci_dev,\n\t\t\t const struct pci_device_id *pci_id)\n{\n\tint idx, nm, low_latency_mode = 0, irq_supported = 0;\n\tint adapter_index;\n\tunsigned int memlen;\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tstruct hpi_adapter adapter;\n\tstruct hpi_pci pci = { 0 };\n\n\tmemset(&adapter, 0, sizeof(adapter));\n\n\tdev_printk(KERN_DEBUG, &pci_dev->dev,\n\t\t\"probe %04x:%04x,%04x:%04x,%04x\\n\", pci_dev->vendor,\n\t\tpci_dev->device, pci_dev->subsystem_vendor,\n\t\tpci_dev->subsystem_device, pci_dev->devfn);\n\n\tif (pcim_enable_device(pci_dev) < 0) {\n\t\tdev_err(&pci_dev->dev,\n\t\t\t\"pci_enable_device failed, disabling device\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpci_set_master(pci_dev);\t \n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_CREATE_ADAPTER);\n\thpi_init_response(&hr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CREATE_ADAPTER,\n\t\tHPI_ERROR_PROCESSING_MESSAGE);\n\n\thm.adapter_index = HPI_ADAPTER_INDEX_INVALID;\n\n\tnm = HPI_MAX_ADAPTER_MEM_SPACES;\n\n\tfor (idx = 0; idx < nm; idx++) {\n\t\tHPI_DEBUG_LOG(INFO, \"resource %d %pR\\n\", idx,\n\t\t\t&pci_dev->resource[idx]);\n\n\t\tif (pci_resource_flags(pci_dev, idx) & IORESOURCE_MEM) {\n\t\t\tmemlen = pci_resource_len(pci_dev, idx);\n\t\t\tpci.ap_mem_base[idx] =\n\t\t\t\tioremap(pci_resource_start(pci_dev, idx),\n\t\t\t\tmemlen);\n\t\t\tif (!pci.ap_mem_base[idx]) {\n\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\"ioremap failed, aborting\\n\");\n\t\t\t\t \n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tpci.pci_dev = pci_dev;\n\thm.u.s.resource.bus_type = HPI_BUS_PCI;\n\thm.u.s.resource.r.pci = &pci;\n\n\t \n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\tif (hr.error)\n\t\tgoto err;\n\n\tadapter_index = hr.u.s.adapter_index;\n\tadapter.adapter = hpi_find_adapter(adapter_index);\n\n\tif (prealloc_stream_buf) {\n\t\tadapter.p_buffer = vmalloc(prealloc_stream_buf);\n\t\tif (!adapter.p_buffer) {\n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"HPI could not allocate \"\n\t\t\t\t\"kernel buffer size %d\\n\",\n\t\t\t\tprealloc_stream_buf);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_OPEN);\n\thm.adapter_index = adapter.adapter->index;\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\n\tif (hr.error) {\n\t\tHPI_DEBUG_LOG(ERROR, \"HPI_ADAPTER_OPEN failed, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_MODE);\n\thm.adapter_index = adapter.adapter->index;\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\n\tif (!hr.error\n\t\t&& hr.u.ax.mode.adapter_mode == HPI_ADAPTER_MODE_LOW_LATENCY)\n\t\tlow_latency_mode = 1;\n\telse\n\t\tdev_info(&pci_dev->dev,\n\t\t\t\"Adapter at index %d is not in low latency mode\\n\",\n\t\t\tadapter.adapter->index);\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_PROPERTY);\n\thm.adapter_index = adapter.adapter->index;\n\thm.u.ax.property_set.property = HPI_ADAPTER_PROPERTY_SUPPORTS_IRQ;\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\tif (hr.error || !hr.u.ax.property_get.parameter1) {\n\t\tdev_info(&pci_dev->dev,\n\t\t\t\"IRQs not supported by adapter at index %d\\n\",\n\t\t\tadapter.adapter->index);\n\t} else {\n\t\tirq_supported = 1;\n\t}\n\n\t \n\tadapters[adapter_index] = adapter;\n\tmutex_init(&adapters[adapter_index].mutex);\n\tpci_set_drvdata(pci_dev, &adapters[adapter_index]);\n\n\tif (low_latency_mode && irq_supported) {\n\t\tif (!adapter.adapter->irq_query_and_clear) {\n\t\t\tdev_err(&pci_dev->dev,\n\t\t\t\t\"no IRQ handler for adapter %d, aborting\\n\",\n\t\t\t\tadapter.adapter->index);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\t\tHPI_ADAPTER_SET_PROPERTY);\n\t\thm.adapter_index = adapter.adapter->index;\n\t\thm.u.ax.property_set.property = HPI_ADAPTER_PROPERTY_IRQ_RATE;\n\t\thm.u.ax.property_set.parameter1 = 0;\n\t\thm.u.ax.property_set.parameter2 = 0;\n\t\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\t\tif (hr.error) {\n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"HPI_ADAPTER_GET_MODE failed, aborting\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (request_threaded_irq(pci_dev->irq, asihpi_isr,\n\t\t\t\t\t asihpi_isr_thread, IRQF_SHARED,\n\t\t\t\t\t \"asihpi\", &adapters[adapter_index])) {\n\t\t\tdev_err(&pci_dev->dev, \"request_irq(%d) failed\\n\",\n\t\t\t\tpci_dev->irq);\n\t\t\tgoto err;\n\t\t}\n\n\t\tadapters[adapter_index].interrupt_mode = 1;\n\n\t\tdev_info(&pci_dev->dev, \"using irq %d\\n\", pci_dev->irq);\n\t\tadapters[adapter_index].irq = pci_dev->irq;\n\t} else {\n\t\tdev_info(&pci_dev->dev, \"using polled mode\\n\");\n\t}\n\n\tdev_info(&pci_dev->dev, \"probe succeeded for ASI%04X HPI index %d\\n\",\n\t\t adapter.adapter->type, adapter_index);\n\n\treturn 0;\n\nerr:\n\twhile (--idx >= 0) {\n\t\tif (pci.ap_mem_base[idx]) {\n\t\t\tiounmap(pci.ap_mem_base[idx]);\n\t\t\tpci.ap_mem_base[idx] = NULL;\n\t\t}\n\t}\n\n\tif (adapter.p_buffer) {\n\t\tadapter.buffer_size = 0;\n\t\tvfree(adapter.p_buffer);\n\t}\n\n\tHPI_DEBUG_LOG(ERROR, \"adapter_probe failed\\n\");\n\treturn -ENODEV;\n}\n\nvoid asihpi_adapter_remove(struct pci_dev *pci_dev)\n{\n\tint idx;\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tstruct hpi_adapter *pa;\n\tstruct hpi_pci pci;\n\n\tpa = pci_get_drvdata(pci_dev);\n\tpci = pa->adapter->pci;\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_SET_PROPERTY);\n\thm.adapter_index = pa->adapter->index;\n\thm.u.ax.property_set.property = HPI_ADAPTER_PROPERTY_IRQ_RATE;\n\thm.u.ax.property_set.parameter1 = 0;\n\thm.u.ax.property_set.parameter2 = 0;\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_DELETE);\n\thm.adapter_index = pa->adapter->index;\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n\n\t \n\tfor (idx = 0; idx < HPI_MAX_ADAPTER_MEM_SPACES; ++idx)\n\t\tiounmap(pci.ap_mem_base[idx]);\n\n\tif (pa->irq)\n\t\tfree_irq(pa->irq, pa);\n\n\tvfree(pa->p_buffer);\n\n\tif (1)\n\t\tdev_info(&pci_dev->dev,\n\t\t\t \"remove %04x:%04x,%04x:%04x,%04x, HPI index %d\\n\",\n\t\t\t pci_dev->vendor, pci_dev->device,\n\t\t\t pci_dev->subsystem_vendor, pci_dev->subsystem_device,\n\t\t\t pci_dev->devfn, pa->adapter->index);\n\n\tmemset(pa, 0, sizeof(*pa));\n}\n\nvoid __init asihpi_init(void)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\tmemset(adapters, 0, sizeof(adapters));\n\n\tprintk(KERN_INFO \"ASIHPI driver \" HPI_VER_STRING \"\\n\");\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_DRIVER_LOAD);\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n}\n\nvoid asihpi_exit(void)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_DRIVER_UNLOAD);\n\thpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}