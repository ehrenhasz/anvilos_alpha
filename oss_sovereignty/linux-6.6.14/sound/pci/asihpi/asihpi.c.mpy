{
  "module_name": "asihpi.c",
  "hash_id": "2381ab75e996679edc12c925001f477e1f9fe3a93aa5d2301f103c159e05f9ad",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/asihpi.c",
  "human_readable_source": "\n \n\n#include \"hpi_internal.h\"\n#include \"hpi_version.h\"\n#include \"hpimsginit.h\"\n#include \"hpioctl.h\"\n#include \"hpicmn.h\"\n\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/hwdep.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"AudioScience inc. <support@audioscience.com>\");\nMODULE_DESCRIPTION(\"AudioScience ALSA ASI5xxx ASI6xxx ASI87xx ASI89xx \"\n\t\t\tHPI_VER_STRING);\n\n#if defined CONFIG_SND_DEBUG_VERBOSE\n \n#define snd_printddd(format, args...) \\\n\t__snd_printk(3, __FILE__, __LINE__, format, ##args)\n#else\n#define snd_printddd(format, args...) do { } while (0)\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\nstatic bool enable_hpi_hwdep = 1;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"ALSA index value for AudioScience soundcard.\");\n\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ALSA ID string for AudioScience soundcard.\");\n\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"ALSA enable AudioScience soundcard.\");\n\nmodule_param(enable_hpi_hwdep, bool, 0644);\nMODULE_PARM_DESC(enable_hpi_hwdep,\n\t\t\"ALSA enable HPI hwdep for AudioScience soundcard \");\n\n \n#ifdef KERNEL_ALSA_BUILD\nstatic char *build_info = \"Built using headers from kernel source\";\nmodule_param(build_info, charp, 0444);\nMODULE_PARM_DESC(build_info, \"Built using headers from kernel source\");\n#else\nstatic char *build_info = \"Built within ALSA source\";\nmodule_param(build_info, charp, 0444);\nMODULE_PARM_DESC(build_info, \"Built within ALSA source\");\n#endif\n\n \nstatic const int mixer_dump;\n\n#define DEFAULT_SAMPLERATE 44100\nstatic int adapter_fs = DEFAULT_SAMPLERATE;\n\n \n#define PERIODS_MIN 2\n#define PERIOD_BYTES_MIN  2048\n#define BUFFER_BYTES_MAX (512 * 1024)\n\n#define MAX_CLOCKSOURCES (HPI_SAMPLECLOCK_SOURCE_LAST + 1 + 7)\n\nstruct clk_source {\n\tint source;\n\tint index;\n\tconst char *name;\n};\n\nstruct clk_cache {\n\tint count;\n\tint has_local;\n\tstruct clk_source s[MAX_CLOCKSOURCES];\n};\n\n \nstruct snd_card_asihpi {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\tstruct hpi_adapter *hpi;\n\n\t \n\tstruct snd_card_asihpi_pcm *llmode_streampriv;\n\tvoid (*pcm_start)(struct snd_pcm_substream *substream);\n\tvoid (*pcm_stop)(struct snd_pcm_substream *substream);\n\n\tu32 h_mixer;\n\tstruct clk_cache cc;\n\n\tu16 can_dma;\n\tu16 support_grouping;\n\tu16 support_mrx;\n\tu16 update_interval_frames;\n\tu16 in_max_chans;\n\tu16 out_max_chans;\n\tu16 in_min_chans;\n\tu16 out_min_chans;\n};\n\n \nstruct snd_card_asihpi_pcm {\n\tstruct timer_list timer;\n\tunsigned int respawn_timer;\n\tunsigned int hpi_buffer_attached;\n\tunsigned int buffer_bytes;\n\tunsigned int period_bytes;\n\tunsigned int bytes_per_sec;\n\tunsigned int pcm_buf_host_rw_ofs;  \n\tunsigned int pcm_buf_dma_ofs;\t \n\tunsigned int pcm_buf_elapsed_dma_ofs;\t \n\tunsigned int drained_count;\n\tstruct snd_pcm_substream *substream;\n\tu32 h_stream;\n\tstruct hpi_format format;\n};\n\n \n\n \n\nstatic u16 hpi_stream_host_buffer_attach(\n\tu32 h_stream,    \n\tu32 size_in_bytes,  \n\tu32 pci_address\n)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tunsigned int obj = hpi_handle_object(h_stream);\n\n\tif (!h_stream)\n\t\treturn HPI_ERROR_INVALID_OBJ;\n\thpi_init_message_response(&hm, &hr, obj,\n\t\t\tobj == HPI_OBJ_OSTREAM ?\n\t\t\t\tHPI_OSTREAM_HOSTBUFFER_ALLOC :\n\t\t\t\tHPI_ISTREAM_HOSTBUFFER_ALLOC);\n\n\thpi_handle_to_indexes(h_stream, &hm.adapter_index,\n\t\t\t\t&hm.obj_index);\n\n\thm.u.d.u.buffer.buffer_size = size_in_bytes;\n\thm.u.d.u.buffer.pci_address = pci_address;\n\thm.u.d.u.buffer.command = HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nstatic u16 hpi_stream_host_buffer_detach(u32  h_stream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tunsigned int obj = hpi_handle_object(h_stream);\n\n\tif (!h_stream)\n\t\treturn HPI_ERROR_INVALID_OBJ;\n\n\thpi_init_message_response(&hm, &hr,  obj,\n\t\t\tobj == HPI_OBJ_OSTREAM ?\n\t\t\t\tHPI_OSTREAM_HOSTBUFFER_FREE :\n\t\t\t\tHPI_ISTREAM_HOSTBUFFER_FREE);\n\n\thpi_handle_to_indexes(h_stream, &hm.adapter_index,\n\t\t\t\t&hm.obj_index);\n\thm.u.d.u.buffer.command = HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nstatic inline u16 hpi_stream_start(u32 h_stream)\n{\n\tif (hpi_handle_object(h_stream) ==  HPI_OBJ_OSTREAM)\n\t\treturn hpi_outstream_start(h_stream);\n\telse\n\t\treturn hpi_instream_start(h_stream);\n}\n\nstatic inline u16 hpi_stream_stop(u32 h_stream)\n{\n\tif (hpi_handle_object(h_stream) ==  HPI_OBJ_OSTREAM)\n\t\treturn hpi_outstream_stop(h_stream);\n\telse\n\t\treturn hpi_instream_stop(h_stream);\n}\n\nstatic inline u16 hpi_stream_get_info_ex(\n    u32 h_stream,\n    u16        *pw_state,\n    u32        *pbuffer_size,\n    u32        *pdata_in_buffer,\n    u32        *psample_count,\n    u32        *pauxiliary_data\n)\n{\n\tu16 e;\n\tif (hpi_handle_object(h_stream)  ==  HPI_OBJ_OSTREAM)\n\t\te = hpi_outstream_get_info_ex(h_stream, pw_state,\n\t\t\t\t\tpbuffer_size, pdata_in_buffer,\n\t\t\t\t\tpsample_count, pauxiliary_data);\n\telse\n\t\te = hpi_instream_get_info_ex(h_stream, pw_state,\n\t\t\t\t\tpbuffer_size, pdata_in_buffer,\n\t\t\t\t\tpsample_count, pauxiliary_data);\n\treturn e;\n}\n\nstatic inline u16 hpi_stream_group_add(\n\t\t\t\t\tu32 h_master,\n\t\t\t\t\tu32 h_stream)\n{\n\tif (hpi_handle_object(h_master) ==  HPI_OBJ_OSTREAM)\n\t\treturn hpi_outstream_group_add(h_master, h_stream);\n\telse\n\t\treturn hpi_instream_group_add(h_master, h_stream);\n}\n\nstatic inline u16 hpi_stream_group_reset(u32 h_stream)\n{\n\tif (hpi_handle_object(h_stream) ==  HPI_OBJ_OSTREAM)\n\t\treturn hpi_outstream_group_reset(h_stream);\n\telse\n\t\treturn hpi_instream_group_reset(h_stream);\n}\n\nstatic u16 handle_error(u16 err, int line, char *filename)\n{\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t\t\"in file %s, line %d: HPI error %d\\n\",\n\t\t\tfilename, line, err);\n\treturn err;\n}\n\n#define hpi_handle_error(x)  handle_error(x, __LINE__, __FILE__)\n\n \n\nstatic void print_hwparams(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *p)\n{\n\tchar name[16];\n\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\tsnd_printdd(\"%s HWPARAMS\\n\", name);\n\tsnd_printdd(\" samplerate=%dHz channels=%d format=%d subformat=%d\\n\",\n\t\tparams_rate(p), params_channels(p),\n\t\tparams_format(p), params_subformat(p));\n\tsnd_printdd(\" buffer=%dB period=%dB period_size=%dB periods=%d\\n\",\n\t\tparams_buffer_bytes(p), params_period_bytes(p),\n\t\tparams_period_size(p), params_periods(p));\n\tsnd_printdd(\" buffer_size=%d access=%d data_rate=%dB/s\\n\",\n\t\tparams_buffer_size(p), params_access(p),\n\t\tparams_rate(p) * params_channels(p) *\n\t\tsnd_pcm_format_width(params_format(p)) / 8);\n}\n\n#define INVALID_FORMAT\t(__force snd_pcm_format_t)(-1)\n\nstatic const snd_pcm_format_t hpi_to_alsa_formats[] = {\n\tINVALID_FORMAT,\t\t \n\tSNDRV_PCM_FORMAT_U8,\t \n\tSNDRV_PCM_FORMAT_S16,\t \n\tINVALID_FORMAT,\t\t \n\tSNDRV_PCM_FORMAT_MPEG,\t \n\tSNDRV_PCM_FORMAT_MPEG,\t \n\tINVALID_FORMAT,\t\t \n\tINVALID_FORMAT,\t\t \n\tSNDRV_PCM_FORMAT_S16_BE, \n\tINVALID_FORMAT,\t\t \n\tINVALID_FORMAT,\t\t \n\tSNDRV_PCM_FORMAT_S32,\t \n\tINVALID_FORMAT,\t\t \n\tINVALID_FORMAT,\t\t \n\tSNDRV_PCM_FORMAT_FLOAT,\t \n#if 1\n\t \n\tINVALID_FORMAT\n#else\n\t   \n#endif\n};\n\n\nstatic int snd_card_asihpi_format_alsa2hpi(snd_pcm_format_t alsa_format,\n\t\t\t\t\t   u16 *hpi_format)\n{\n\tu16 format;\n\n\tfor (format = HPI_FORMAT_PCM8_UNSIGNED;\n\t     format <= HPI_FORMAT_PCM24_SIGNED; format++) {\n\t\tif (hpi_to_alsa_formats[format] == alsa_format) {\n\t\t\t*hpi_format = format;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsnd_printd(KERN_WARNING \"failed match for alsa format %d\\n\",\n\t\t   alsa_format);\n\t*hpi_format = 0;\n\treturn -EINVAL;\n}\n\nstatic void snd_card_asihpi_pcm_samplerates(struct snd_card_asihpi *asihpi,\n\t\t\t\t\t struct snd_pcm_hardware *pcmhw)\n{\n\tu16 err;\n\tu32 h_control;\n\tu32 sample_rate;\n\tint idx;\n\tunsigned int rate_min = 200000;\n\tunsigned int rate_max = 0;\n\tunsigned int rates = 0;\n\n\tif (asihpi->support_mrx) {\n\t\trates |= SNDRV_PCM_RATE_CONTINUOUS;\n\t\trates |= SNDRV_PCM_RATE_8000_96000;\n\t\trate_min = 8000;\n\t\trate_max = 100000;\n\t} else {\n\t\t \n\t\terr = hpi_mixer_get_control(asihpi->h_mixer,\n\t\t\t\t\t  HPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\n\t\t\t\t\t  HPI_CONTROL_SAMPLECLOCK, &h_control);\n\t\tif (err) {\n\t\t\tdev_err(&asihpi->pci->dev,\n\t\t\t\t\"No local sampleclock, err %d\\n\", err);\n\t\t}\n\n\t\tfor (idx = -1; idx < 100; idx++) {\n\t\t\tif (idx == -1) {\n\t\t\t\tif (hpi_sample_clock_get_sample_rate(h_control,\n\t\t\t\t\t\t\t\t&sample_rate))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (hpi_sample_clock_query_local_rate(h_control,\n\t\t\t\t\t\t\tidx, &sample_rate)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trate_min = min(rate_min, sample_rate);\n\t\t\trate_max = max(rate_max, sample_rate);\n\n\t\t\tswitch (sample_rate) {\n\t\t\tcase 5512:\n\t\t\t\trates |= SNDRV_PCM_RATE_5512;\n\t\t\t\tbreak;\n\t\t\tcase 8000:\n\t\t\t\trates |= SNDRV_PCM_RATE_8000;\n\t\t\t\tbreak;\n\t\t\tcase 11025:\n\t\t\t\trates |= SNDRV_PCM_RATE_11025;\n\t\t\t\tbreak;\n\t\t\tcase 16000:\n\t\t\t\trates |= SNDRV_PCM_RATE_16000;\n\t\t\t\tbreak;\n\t\t\tcase 22050:\n\t\t\t\trates |= SNDRV_PCM_RATE_22050;\n\t\t\t\tbreak;\n\t\t\tcase 32000:\n\t\t\t\trates |= SNDRV_PCM_RATE_32000;\n\t\t\t\tbreak;\n\t\t\tcase 44100:\n\t\t\t\trates |= SNDRV_PCM_RATE_44100;\n\t\t\t\tbreak;\n\t\t\tcase 48000:\n\t\t\t\trates |= SNDRV_PCM_RATE_48000;\n\t\t\t\tbreak;\n\t\t\tcase 64000:\n\t\t\t\trates |= SNDRV_PCM_RATE_64000;\n\t\t\t\tbreak;\n\t\t\tcase 88200:\n\t\t\t\trates |= SNDRV_PCM_RATE_88200;\n\t\t\t\tbreak;\n\t\t\tcase 96000:\n\t\t\t\trates |= SNDRV_PCM_RATE_96000;\n\t\t\t\tbreak;\n\t\t\tcase 176400:\n\t\t\t\trates |= SNDRV_PCM_RATE_176400;\n\t\t\t\tbreak;\n\t\t\tcase 192000:\n\t\t\t\trates |= SNDRV_PCM_RATE_192000;\n\t\t\t\tbreak;\n\t\t\tdefault:  \n\t\t\t\trates |= SNDRV_PCM_RATE_KNOT;\n\t\t\t}\n\t\t}\n\t}\n\n\tpcmhw->rates = rates;\n\tpcmhw->rate_min = rate_min;\n\tpcmhw->rate_max = rate_max;\n}\n\nstatic int snd_card_asihpi_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tint err;\n\tu16 format;\n\tint width;\n\tunsigned int bytes_per_sec;\n\n\tprint_hwparams(substream, params);\n\terr = snd_card_asihpi_format_alsa2hpi(params_format(params), &format);\n\tif (err)\n\t\treturn err;\n\n\thpi_handle_error(hpi_format_create(&dpcm->format,\n\t\t\tparams_channels(params),\n\t\t\tformat, params_rate(params), 0, 0));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tif (hpi_instream_reset(dpcm->h_stream) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (hpi_instream_set_format(\n\t\t\tdpcm->h_stream, &dpcm->format) != 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdpcm->hpi_buffer_attached = 0;\n\tif (card->can_dma) {\n\t\terr = hpi_stream_host_buffer_attach(dpcm->h_stream,\n\t\t\tparams_buffer_bytes(params),  runtime->dma_addr);\n\t\tif (err == 0) {\n\t\t\tsnd_printdd(\n\t\t\t\t\"stream_host_buffer_attach success %u %lu\\n\",\n\t\t\t\tparams_buffer_bytes(params),\n\t\t\t\t(unsigned long)runtime->dma_addr);\n\t\t} else {\n\t\t\tsnd_printd(\"stream_host_buffer_attach error %d\\n\",\n\t\t\t\t\terr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = hpi_stream_get_info_ex(dpcm->h_stream, NULL,\n\t\t\t\t&dpcm->hpi_buffer_attached, NULL, NULL, NULL);\n\t}\n\tbytes_per_sec = params_rate(params) * params_channels(params);\n\twidth = snd_pcm_format_width(params_format(params));\n\tbytes_per_sec *= width;\n\tbytes_per_sec /= 8;\n\tif (width < 0 || bytes_per_sec == 0)\n\t\treturn -EINVAL;\n\n\tdpcm->bytes_per_sec = bytes_per_sec;\n\tdpcm->buffer_bytes = params_buffer_bytes(params);\n\tdpcm->period_bytes = params_period_bytes(params);\n\n\treturn 0;\n}\n\nstatic int\nsnd_card_asihpi_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tif (dpcm->hpi_buffer_attached)\n\t\thpi_stream_host_buffer_detach(dpcm->h_stream);\n\n\treturn 0;\n}\n\nstatic void snd_card_asihpi_runtime_free(struct snd_pcm_runtime *runtime)\n{\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tkfree(dpcm);\n}\n\nstatic void snd_card_asihpi_pcm_timer_start(struct snd_pcm_substream *\n\t\t\t\t\t    substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tint expiry;\n\n\texpiry = HZ / 200;\n\n\texpiry = max(expiry, 1);  \n\tmod_timer(&dpcm->timer, jiffies + expiry);\n\tdpcm->respawn_timer = 1;\n}\n\nstatic void snd_card_asihpi_pcm_timer_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\n\tdpcm->respawn_timer = 0;\n\tdel_timer(&dpcm->timer);\n}\n\nstatic void snd_card_asihpi_pcm_int_start(struct snd_pcm_substream *substream)\n{\n\tstruct snd_card_asihpi_pcm *dpcm;\n\tstruct snd_card_asihpi *card;\n\n\tdpcm = (struct snd_card_asihpi_pcm *)substream->runtime->private_data;\n\tcard = snd_pcm_substream_chip(substream);\n\n\tWARN_ON(in_interrupt());\n\tcard->llmode_streampriv = dpcm;\n\n\thpi_handle_error(hpi_adapter_set_property(card->hpi->adapter->index,\n\t\tHPI_ADAPTER_PROPERTY_IRQ_RATE,\n\t\tcard->update_interval_frames, 0));\n}\n\nstatic void snd_card_asihpi_pcm_int_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_card_asihpi *card;\n\n\tcard = snd_pcm_substream_chip(substream);\n\n\thpi_handle_error(hpi_adapter_set_property(card->hpi->adapter->index,\n\t\tHPI_ADAPTER_PROPERTY_IRQ_RATE, 0, 0));\n\n\tcard->llmode_streampriv = NULL;\n}\n\nstatic int snd_card_asihpi_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\t   int cmd)\n{\n\tstruct snd_card_asihpi_pcm *dpcm = substream->runtime->private_data;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tu16 e;\n\tchar name[16];\n\n\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_printdd(\"%s trigger start\\n\", name);\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tstruct snd_pcm_runtime *runtime = s->runtime;\n\t\t\tstruct snd_card_asihpi_pcm *ds = runtime->private_data;\n\n\t\t\tif (snd_pcm_substream_chip(s) != card)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (substream->stream != s->stream)\n\t\t\t\tcontinue;\n\n\t\t\tds->drained_count = 0;\n\t\t\tif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t\t \n\t\t\t\tunsigned int preload = ds->period_bytes * 1;\n\t\t\t\tsnd_printddd(\"%d preload %d\\n\", s->number, preload);\n\t\t\t\thpi_handle_error(hpi_outstream_write_buf(\n\t\t\t\t\t\tds->h_stream,\n\t\t\t\t\t\t&runtime->dma_area[0],\n\t\t\t\t\t\tpreload,\n\t\t\t\t\t\t&ds->format));\n\t\t\t\tds->pcm_buf_host_rw_ofs = preload;\n\t\t\t}\n\n\t\t\tif (card->support_grouping) {\n\t\t\t\tsnd_printdd(\"%d group\\n\", s->number);\n\t\t\t\te = hpi_stream_group_add(\n\t\t\t\t\tdpcm->h_stream,\n\t\t\t\t\tds->h_stream);\n\t\t\t\tif (!e) {\n\t\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t\t} else {\n\t\t\t\t\thpi_handle_error(e);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tcard->pcm_start(substream);\n\t\tif ((substream->stream == SNDRV_PCM_STREAM_CAPTURE) ||\n\t\t\t!card->can_dma)\n\t\t\thpi_handle_error(hpi_stream_start(dpcm->h_stream));\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_printdd(\"%s trigger stop\\n\", name);\n\t\tcard->pcm_stop(substream);\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (snd_pcm_substream_chip(s) != card)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (substream->stream != s->stream)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\t__snd_pcm_set_state(s->runtime, SNDRV_PCM_STATE_SETUP);\n\n\t\t\tif (card->support_grouping) {\n\t\t\t\tsnd_printdd(\"%d group\\n\", s->number);\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\thpi_handle_error(hpi_stream_stop(dpcm->h_stream));\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\thpi_handle_error(\n\t\t\t\thpi_outstream_reset(dpcm->h_stream));\n\n\t\tif (card->support_grouping)\n\t\t\thpi_handle_error(hpi_stream_group_reset(dpcm->h_stream));\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tsnd_printdd(\"%s trigger pause release\\n\", name);\n\t\tcard->pcm_start(substream);\n\t\thpi_handle_error(hpi_stream_start(dpcm->h_stream));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tsnd_printdd(\"%s trigger pause push\\n\", name);\n\t\tcard->pcm_stop(substream);\n\t\thpi_handle_error(hpi_stream_stop(dpcm->h_stream));\n\t\tbreak;\n\tdefault:\n\t\tsnd_printd(KERN_ERR \"\\tINVALID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n \n\n \nstatic inline unsigned int modulo_min(unsigned int a, unsigned int b,\n\t\t\t\t\tunsigned long int modulus)\n{\n\tunsigned int result;\n\tif (((a-b) % modulus) < (modulus/2))\n\t\tresult = b;\n\telse\n\t\tresult = a;\n\n\treturn result;\n}\n\n \nstatic void snd_card_asihpi_timer_function(struct timer_list *t)\n{\n\tstruct snd_card_asihpi_pcm *dpcm = from_timer(dpcm, t, timer);\n\tstruct snd_pcm_substream *substream = dpcm->substream;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_pcm_substream *s;\n\tunsigned int newdata = 0;\n\tunsigned int pcm_buf_dma_ofs, min_buf_pos = 0;\n\tunsigned int remdata, xfercount, next_jiffies;\n\tint first = 1;\n\tu16 state;\n\tu32 buffer_size, bytes_avail, samples_played, on_card_bytes;\n\tchar name[16];\n\n\n\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\n\t \n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tstruct snd_card_asihpi_pcm *ds = s->runtime->private_data;\n\t\truntime = s->runtime;\n\n\t\tif (snd_pcm_substream_chip(s) != card)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (substream->stream != s->stream)\n\t\t\tcontinue;\n\n\t\thpi_handle_error(hpi_stream_get_info_ex(\n\t\t\t\t\tds->h_stream, &state,\n\t\t\t\t\t&buffer_size, &bytes_avail,\n\t\t\t\t\t&samples_played, &on_card_bytes));\n\n\t\t \n\t\truntime->delay = on_card_bytes;\n\n\t\tif (!card->can_dma)\n\t\t\ton_card_bytes = bytes_avail;\n\n\t\tif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tpcm_buf_dma_ofs = ds->pcm_buf_host_rw_ofs - bytes_avail;\n\t\t\tif (state == HPI_STATE_STOPPED) {\n\t\t\t\tif (bytes_avail == 0) {\n\t\t\t\t\thpi_handle_error(hpi_stream_start(ds->h_stream));\n\t\t\t\t\tsnd_printdd(\"P%d start\\n\", s->number);\n\t\t\t\t\tds->drained_count = 0;\n\t\t\t\t}\n\t\t\t} else if (state == HPI_STATE_DRAINED) {\n\t\t\t\tsnd_printd(KERN_WARNING \"P%d drained\\n\",\n\t\t\t\t\t\ts->number);\n\t\t\t\tds->drained_count++;\n\t\t\t\tif (ds->drained_count > 20) {\n\t\t\t\t\tsnd_pcm_stop_xrun(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tds->drained_count = 0;\n\t\t\t}\n\t\t} else\n\t\t\tpcm_buf_dma_ofs = bytes_avail + ds->pcm_buf_host_rw_ofs;\n\n\t\tif (first) {\n\t\t\t \n\t\t\tmin_buf_pos = pcm_buf_dma_ofs;\n\t\t\tnewdata = (pcm_buf_dma_ofs - ds->pcm_buf_elapsed_dma_ofs) % ds->buffer_bytes;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tmin_buf_pos =\n\t\t\t\tmodulo_min(min_buf_pos, pcm_buf_dma_ofs, UINT_MAX+1L);\n\t\t\tnewdata = min(\n\t\t\t\t(pcm_buf_dma_ofs - ds->pcm_buf_elapsed_dma_ofs) % ds->buffer_bytes,\n\t\t\t\tnewdata);\n\t\t}\n\n\t\tsnd_printddd(\n\t\t\t\"timer1, %s, %d, S=%d, elap=%d, rw=%d, dsp=%d, left=%d, aux=%d, space=%d, hw_ptr=%ld, appl_ptr=%ld\\n\",\n\t\t\tname, s->number, state,\n\t\t\tds->pcm_buf_elapsed_dma_ofs,\n\t\t\tds->pcm_buf_host_rw_ofs,\n\t\t\tpcm_buf_dma_ofs,\n\t\t\t(int)bytes_avail,\n\n\t\t\t(int)on_card_bytes,\n\t\t\tbuffer_size-bytes_avail,\n\t\t\t(unsigned long)frames_to_bytes(runtime,\n\t\t\t\t\t\truntime->status->hw_ptr),\n\t\t\t(unsigned long)frames_to_bytes(runtime,\n\t\t\t\t\t\truntime->control->appl_ptr)\n\t\t);\n\t}\n\tpcm_buf_dma_ofs = min_buf_pos;\n\n\tremdata = newdata % dpcm->period_bytes;\n\txfercount = newdata - remdata;  \n\t \n\tif (xfercount && (on_card_bytes  > dpcm->period_bytes))\n\t\tnext_jiffies = ((on_card_bytes - dpcm->period_bytes) * HZ / dpcm->bytes_per_sec);\n\telse\n\t\tnext_jiffies = ((dpcm->period_bytes - remdata) * HZ / dpcm->bytes_per_sec);\n\n\tnext_jiffies = max(next_jiffies, 1U);\n\tdpcm->timer.expires = jiffies + next_jiffies;\n\tsnd_printddd(\"timer2, jif=%d, buf_pos=%d, newdata=%d, xfer=%d\\n\",\n\t\t\tnext_jiffies, pcm_buf_dma_ofs, newdata, xfercount);\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tstruct snd_card_asihpi_pcm *ds = s->runtime->private_data;\n\n\t\t \n\t\tif (substream->stream != s->stream)\n\t\t\tcontinue;\n\n\t\t \n\t\tds->pcm_buf_dma_ofs = pcm_buf_dma_ofs;\n\n\t\tif (xfercount &&\n\t\t\t \n\t\t\t((on_card_bytes <= ds->period_bytes) ||\n\t\t\t(s->stream == SNDRV_PCM_STREAM_CAPTURE)))\n\n\t\t{\n\n\t\t\tunsigned int buf_ofs = ds->pcm_buf_host_rw_ofs % ds->buffer_bytes;\n\t\t\tunsigned int xfer1, xfer2;\n\t\t\tchar *pd = &s->runtime->dma_area[buf_ofs];\n\n\t\t\tif (card->can_dma) {  \n\t\t\t\txfer1 = xfercount;\n\t\t\t\txfer2 = 0;\n\t\t\t} else {\n\t\t\t\txfer1 = min(xfercount, ds->buffer_bytes - buf_ofs);\n\t\t\t\txfer2 = xfercount - xfer1;\n\t\t\t}\n\n\t\t\tif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t\tsnd_printddd(\"write1, P=%d, xfer=%d, buf_ofs=%d\\n\",\n\t\t\t\t\ts->number, xfer1, buf_ofs);\n\t\t\t\thpi_handle_error(\n\t\t\t\t\thpi_outstream_write_buf(\n\t\t\t\t\t\tds->h_stream, pd, xfer1,\n\t\t\t\t\t\t&ds->format));\n\n\t\t\t\tif (xfer2) {\n\t\t\t\t\tpd = s->runtime->dma_area;\n\n\t\t\t\t\tsnd_printddd(\"write2, P=%d, xfer=%d, buf_ofs=%d\\n\",\n\t\t\t\t\t\t\ts->number,\n\t\t\t\t\t\t\txfercount - xfer1, buf_ofs);\n\t\t\t\t\thpi_handle_error(\n\t\t\t\t\t\thpi_outstream_write_buf(\n\t\t\t\t\t\t\tds->h_stream, pd,\n\t\t\t\t\t\t\txfercount - xfer1,\n\t\t\t\t\t\t\t&ds->format));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsnd_printddd(\"read1, C=%d, xfer=%d\\n\",\n\t\t\t\t\ts->number, xfer1);\n\t\t\t\thpi_handle_error(\n\t\t\t\t\thpi_instream_read_buf(\n\t\t\t\t\t\tds->h_stream,\n\t\t\t\t\t\tpd, xfer1));\n\t\t\t\tif (xfer2) {\n\t\t\t\t\tpd = s->runtime->dma_area;\n\t\t\t\t\tsnd_printddd(\"read2, C=%d, xfer=%d\\n\",\n\t\t\t\t\t\ts->number, xfer2);\n\t\t\t\t\thpi_handle_error(\n\t\t\t\t\t\thpi_instream_read_buf(\n\t\t\t\t\t\t\tds->h_stream,\n\t\t\t\t\t\t\tpd, xfer2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tds->pcm_buf_host_rw_ofs += xfercount;\n\t\t\tds->pcm_buf_elapsed_dma_ofs += xfercount;\n\t\t\tsnd_pcm_period_elapsed(s);\n\t\t}\n\t}\n\n\tif (!card->hpi->interrupt_mode && dpcm->respawn_timer)\n\t\tadd_timer(&dpcm->timer);\n}\n\nstatic void snd_card_asihpi_isr(struct hpi_adapter *a)\n{\n\tstruct snd_card_asihpi *asihpi;\n\n\tWARN_ON(!a || !a->snd_card || !a->snd_card->private_data);\n\tasihpi = (struct snd_card_asihpi *)a->snd_card->private_data;\n\tif (asihpi->llmode_streampriv)\n\t\tsnd_card_asihpi_timer_function(\n\t\t\t&asihpi->llmode_streampriv->timer);\n}\n\n \nstatic int snd_card_asihpi_playback_prepare(struct snd_pcm_substream *\n\t\t\t\t\t    substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\n\tsnd_printdd(\"P%d prepare\\n\", substream->number);\n\n\thpi_handle_error(hpi_outstream_reset(dpcm->h_stream));\n\tdpcm->pcm_buf_host_rw_ofs = 0;\n\tdpcm->pcm_buf_dma_ofs = 0;\n\tdpcm->pcm_buf_elapsed_dma_ofs = 0;\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nsnd_card_asihpi_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tsnd_pcm_uframes_t ptr;\n\tchar name[16];\n\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\n\tptr = bytes_to_frames(runtime, dpcm->pcm_buf_dma_ofs  % dpcm->buffer_bytes);\n\tsnd_printddd(\"%s, pointer=%ld\\n\", name, (unsigned long)ptr);\n\treturn ptr;\n}\n\nstatic u64 snd_card_asihpi_playback_formats(struct snd_card_asihpi *asihpi,\n\t\t\t\t\t\tu32 h_stream)\n{\n\tstruct hpi_format hpi_format;\n\tu16 format;\n\tu16 err;\n\tu32 h_control;\n\tu32 sample_rate = 48000;\n\tu64 formats = 0;\n\n\t \n\terr = hpi_mixer_get_control(asihpi->h_mixer,\n\t\t\t\t  HPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\n\t\t\t\t  HPI_CONTROL_SAMPLECLOCK, &h_control);\n\n\tif (!err)\n\t\terr = hpi_sample_clock_get_sample_rate(h_control,\n\t\t\t\t&sample_rate);\n\n\tfor (format = HPI_FORMAT_PCM8_UNSIGNED;\n\t     format <= HPI_FORMAT_PCM24_SIGNED; format++) {\n\t\terr = hpi_format_create(&hpi_format, asihpi->out_max_chans,\n\t\t\t\t\tformat, sample_rate, 128000, 0);\n\t\tif (!err)\n\t\t\terr = hpi_outstream_query_format(h_stream, &hpi_format);\n\t\tif (!err && (hpi_to_alsa_formats[format] != INVALID_FORMAT))\n\t\t\tformats |= pcm_format_to_bits(hpi_to_alsa_formats[format]);\n\t}\n\treturn formats;\n}\n\nstatic int snd_card_asihpi_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_hardware snd_card_asihpi_playback;\n\tint err;\n\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (dpcm == NULL)\n\t\treturn -ENOMEM;\n\n\terr = hpi_outstream_open(card->hpi->adapter->index,\n\t\t\t      substream->number, &dpcm->h_stream);\n\thpi_handle_error(err);\n\tif (err)\n\t\tkfree(dpcm);\n\tif (err == HPI_ERROR_OBJ_ALREADY_OPEN)\n\t\treturn -EBUSY;\n\tif (err)\n\t\treturn -EIO;\n\n\t \n\n\ttimer_setup(&dpcm->timer, snd_card_asihpi_timer_function, 0);\n\tdpcm->substream = substream;\n\truntime->private_data = dpcm;\n\truntime->private_free = snd_card_asihpi_runtime_free;\n\n\tmemset(&snd_card_asihpi_playback, 0, sizeof(snd_card_asihpi_playback));\n\tif (!card->hpi->interrupt_mode) {\n\t\tsnd_card_asihpi_playback.buffer_bytes_max = BUFFER_BYTES_MAX;\n\t\tsnd_card_asihpi_playback.period_bytes_min = PERIOD_BYTES_MIN;\n\t\tsnd_card_asihpi_playback.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\n\t\tsnd_card_asihpi_playback.periods_min = PERIODS_MIN;\n\t\tsnd_card_asihpi_playback.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN;\n\t} else {\n\t\tsize_t pbmin = card->update_interval_frames *\n\t\t\tcard->out_max_chans;\n\t\tsnd_card_asihpi_playback.buffer_bytes_max = BUFFER_BYTES_MAX;\n\t\tsnd_card_asihpi_playback.period_bytes_min = pbmin;\n\t\tsnd_card_asihpi_playback.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\n\t\tsnd_card_asihpi_playback.periods_min = PERIODS_MIN;\n\t\tsnd_card_asihpi_playback.periods_max = BUFFER_BYTES_MAX / pbmin;\n\t}\n\n\t \n\tsnd_card_asihpi_playback.channels_max = card->out_max_chans;\n\tsnd_card_asihpi_playback.channels_min = card->out_min_chans;\n\tsnd_card_asihpi_playback.formats =\n\t\t\tsnd_card_asihpi_playback_formats(card, dpcm->h_stream);\n\n\tsnd_card_asihpi_pcm_samplerates(card,  &snd_card_asihpi_playback);\n\n\tsnd_card_asihpi_playback.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_DOUBLE |\n\t\t\t\t\tSNDRV_PCM_INFO_BATCH |\n\t\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID;\n\n\tif (card->support_grouping) {\n\t\tsnd_card_asihpi_playback.info |= SNDRV_PCM_INFO_SYNC_START;\n\t\tsnd_pcm_set_sync(substream);\n\t}\n\n\t \n\truntime->hw = snd_card_asihpi_playback;\n\n\tif (card->can_dma)\n\t\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\tcard->update_interval_frames);\n\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\tcard->update_interval_frames, UINT_MAX);\n\n\tsnd_printdd(\"playback open\\n\");\n\n\treturn 0;\n}\n\nstatic int snd_card_asihpi_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\n\thpi_handle_error(hpi_outstream_close(dpcm->h_stream));\n\tsnd_printdd(\"playback close\\n\");\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_card_asihpi_playback_mmap_ops = {\n\t.open = snd_card_asihpi_playback_open,\n\t.close = snd_card_asihpi_playback_close,\n\t.hw_params = snd_card_asihpi_pcm_hw_params,\n\t.hw_free = snd_card_asihpi_hw_free,\n\t.prepare = snd_card_asihpi_playback_prepare,\n\t.trigger = snd_card_asihpi_trigger,\n\t.pointer = snd_card_asihpi_playback_pointer,\n};\n\n \nstatic snd_pcm_uframes_t\nsnd_card_asihpi_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\tchar name[16];\n\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\n\tsnd_printddd(\"%s, pointer=%d\\n\", name, dpcm->pcm_buf_dma_ofs);\n\t \n\treturn bytes_to_frames(runtime, dpcm->pcm_buf_dma_ofs % dpcm->buffer_bytes);\n}\n\nstatic int snd_card_asihpi_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\n\n\thpi_handle_error(hpi_instream_reset(dpcm->h_stream));\n\tdpcm->pcm_buf_host_rw_ofs = 0;\n\tdpcm->pcm_buf_dma_ofs = 0;\n\tdpcm->pcm_buf_elapsed_dma_ofs = 0;\n\n\tsnd_printdd(\"Capture Prepare %d\\n\", substream->number);\n\treturn 0;\n}\n\nstatic u64 snd_card_asihpi_capture_formats(struct snd_card_asihpi *asihpi,\n\t\t\t\t\tu32 h_stream)\n{\n\tstruct hpi_format hpi_format;\n\tu16 format;\n\tu16 err;\n\tu32 h_control;\n\tu32 sample_rate = 48000;\n\tu64 formats = 0;\n\n\t \n\terr = hpi_mixer_get_control(asihpi->h_mixer,\n\t\t\t\t  HPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\n\t\t\t\t  HPI_CONTROL_SAMPLECLOCK, &h_control);\n\n\tif (!err)\n\t\terr = hpi_sample_clock_get_sample_rate(h_control,\n\t\t\t&sample_rate);\n\n\tfor (format = HPI_FORMAT_PCM8_UNSIGNED;\n\t\tformat <= HPI_FORMAT_PCM24_SIGNED; format++) {\n\n\t\terr = hpi_format_create(&hpi_format, asihpi->in_max_chans,\n\t\t\t\t\tformat, sample_rate, 128000, 0);\n\t\tif (!err)\n\t\t\terr = hpi_instream_query_format(h_stream, &hpi_format);\n\t\tif (!err && (hpi_to_alsa_formats[format] != INVALID_FORMAT))\n\t\t\tformats |= pcm_format_to_bits(hpi_to_alsa_formats[format]);\n\t}\n\treturn formats;\n}\n\nstatic int snd_card_asihpi_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\n\tstruct snd_card_asihpi_pcm *dpcm;\n\tstruct snd_pcm_hardware snd_card_asihpi_capture;\n\tint err;\n\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (dpcm == NULL)\n\t\treturn -ENOMEM;\n\n\tsnd_printdd(\"capture open adapter %d stream %d\\n\",\n\t\t\tcard->hpi->adapter->index, substream->number);\n\n\terr = hpi_handle_error(\n\t    hpi_instream_open(card->hpi->adapter->index,\n\t\t\t     substream->number, &dpcm->h_stream));\n\tif (err)\n\t\tkfree(dpcm);\n\tif (err == HPI_ERROR_OBJ_ALREADY_OPEN)\n\t\treturn -EBUSY;\n\tif (err)\n\t\treturn -EIO;\n\n\ttimer_setup(&dpcm->timer, snd_card_asihpi_timer_function, 0);\n\tdpcm->substream = substream;\n\truntime->private_data = dpcm;\n\truntime->private_free = snd_card_asihpi_runtime_free;\n\n\tmemset(&snd_card_asihpi_capture, 0, sizeof(snd_card_asihpi_capture));\n\tif (!card->hpi->interrupt_mode) {\n\t\tsnd_card_asihpi_capture.buffer_bytes_max = BUFFER_BYTES_MAX;\n\t\tsnd_card_asihpi_capture.period_bytes_min = PERIOD_BYTES_MIN;\n\t\tsnd_card_asihpi_capture.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\n\t\tsnd_card_asihpi_capture.periods_min = PERIODS_MIN;\n\t\tsnd_card_asihpi_capture.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN;\n\t} else {\n\t\tsize_t pbmin = card->update_interval_frames *\n\t\t\tcard->out_max_chans;\n\t\tsnd_card_asihpi_capture.buffer_bytes_max = BUFFER_BYTES_MAX;\n\t\tsnd_card_asihpi_capture.period_bytes_min = pbmin;\n\t\tsnd_card_asihpi_capture.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\n\t\tsnd_card_asihpi_capture.periods_min = PERIODS_MIN;\n\t\tsnd_card_asihpi_capture.periods_max = BUFFER_BYTES_MAX / pbmin;\n\t}\n\t \n\tsnd_card_asihpi_capture.channels_max = card->in_max_chans;\n\tsnd_card_asihpi_capture.channels_min = card->in_min_chans;\n\tsnd_card_asihpi_capture.formats =\n\t\tsnd_card_asihpi_capture_formats(card, dpcm->h_stream);\n\tsnd_card_asihpi_pcm_samplerates(card,  &snd_card_asihpi_capture);\n\tsnd_card_asihpi_capture.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID;\n\n\tif (card->support_grouping)\n\t\tsnd_card_asihpi_capture.info |= SNDRV_PCM_INFO_SYNC_START;\n\n\truntime->hw = snd_card_asihpi_capture;\n\n\tif (card->can_dma)\n\t\terr = snd_pcm_hw_constraint_pow2(runtime, 0,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\tcard->update_interval_frames);\n\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\tcard->update_interval_frames, UINT_MAX);\n\n\tsnd_pcm_set_sync(substream);\n\n\treturn 0;\n}\n\nstatic int snd_card_asihpi_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_card_asihpi_pcm *dpcm = substream->runtime->private_data;\n\n\thpi_handle_error(hpi_instream_close(dpcm->h_stream));\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_card_asihpi_capture_mmap_ops = {\n\t.open = snd_card_asihpi_capture_open,\n\t.close = snd_card_asihpi_capture_close,\n\t.hw_params = snd_card_asihpi_pcm_hw_params,\n\t.hw_free = snd_card_asihpi_hw_free,\n\t.prepare = snd_card_asihpi_capture_prepare,\n\t.trigger = snd_card_asihpi_trigger,\n\t.pointer = snd_card_asihpi_capture_pointer,\n};\n\nstatic int snd_card_asihpi_pcm_new(struct snd_card_asihpi *asihpi, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\tu16 num_instreams, num_outstreams, x16;\n\tu32 x32;\n\n\terr = hpi_adapter_get_info(asihpi->hpi->adapter->index,\n\t\t\t&num_outstreams, &num_instreams,\n\t\t\t&x16, &x32, &x16);\n\n\terr = snd_pcm_new(asihpi->card, \"Asihpi PCM\", device,\n\t\t\tnum_outstreams,\tnum_instreams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_card_asihpi_playback_mmap_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_card_asihpi_capture_mmap_ops);\n\n\tpcm->private_data = asihpi;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"Asihpi PCM\");\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &asihpi->pci->dev,\n\t\t\t\t       64*1024, BUFFER_BYTES_MAX);\n\n\treturn 0;\n}\n\n \nstruct hpi_control {\n\tu32 h_control;\n\tu16 control_type;\n\tu16 src_node_type;\n\tu16 src_node_index;\n\tu16 dst_node_type;\n\tu16 dst_node_index;\n\tu16 band;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];  \n};\n\nstatic const char * const asihpi_tuner_band_names[] = {\n\t\"invalid\",\n\t\"AM\",\n\t\"FM mono\",\n\t\"TV NTSC-M\",\n\t\"FM stereo\",\n\t\"AUX\",\n\t\"TV PAL BG\",\n\t\"TV PAL I\",\n\t\"TV PAL DK\",\n\t\"TV SECAM\",\n\t\"TV DAB\",\n};\n \ncompile_time_assert(\n\t(ARRAY_SIZE(asihpi_tuner_band_names) ==\n\t\t(HPI_TUNER_BAND_LAST+1)),\n\tassert_tuner_band_names_size);\n\nstatic const char * const asihpi_src_names[] = {\n\t\"no source\",\n\t\"PCM\",\n\t\"Line\",\n\t\"Digital\",\n\t\"Tuner\",\n\t\"RF\",\n\t\"Clock\",\n\t\"Bitstream\",\n\t\"Mic\",\n\t\"Net\",\n\t\"Analog\",\n\t\"Adapter\",\n\t\"RTP\",\n\t\"Internal\",\n\t\"AVB\",\n\t\"BLU-Link\"\n};\n \ncompile_time_assert(\n\t(ARRAY_SIZE(asihpi_src_names) ==\n\t\t(HPI_SOURCENODE_LAST_INDEX-HPI_SOURCENODE_NONE+1)),\n\tassert_src_names_size);\n\nstatic const char * const asihpi_dst_names[] = {\n\t\"no destination\",\n\t\"PCM\",\n\t\"Line\",\n\t\"Digital\",\n\t\"RF\",\n\t\"Speaker\",\n\t\"Net\",\n\t\"Analog\",\n\t\"RTP\",\n\t\"AVB\",\n\t\"Internal\",\n\t\"BLU-Link\"\n};\n \ncompile_time_assert(\n\t(ARRAY_SIZE(asihpi_dst_names) ==\n\t\t(HPI_DESTNODE_LAST_INDEX-HPI_DESTNODE_NONE+1)),\n\tassert_dst_names_size);\n\nstatic inline int ctl_add(struct snd_card *card, struct snd_kcontrol_new *ctl,\n\t\t\t\tstruct snd_card_asihpi *asihpi)\n{\n\tint err;\n\n\terr = snd_ctl_add(card, snd_ctl_new1(ctl, asihpi));\n\tif (err < 0)\n\t\treturn err;\n\telse if (mixer_dump)\n\t\tdev_info(&asihpi->pci->dev, \"added %s(%d)\\n\", ctl->name, ctl->index);\n\n\treturn 0;\n}\n\n \nstatic void asihpi_ctl_init(struct snd_kcontrol_new *snd_control,\n\t\t\t\tstruct hpi_control *hpi_ctl,\n\t\t\t\tchar *name)\n{\n\tchar *dir;\n\tmemset(snd_control, 0, sizeof(*snd_control));\n\tsnd_control->name = hpi_ctl->name;\n\tsnd_control->private_value = hpi_ctl->h_control;\n\tsnd_control->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tsnd_control->index = 0;\n\n\tif (hpi_ctl->src_node_type + HPI_SOURCENODE_NONE == HPI_SOURCENODE_CLOCK_SOURCE)\n\t\tdir = \"\";  \n\telse if (hpi_ctl->dst_node_type + HPI_DESTNODE_NONE == HPI_DESTNODE_ISTREAM)\n\t\tdir = \"Capture \";   \n\telse if ((hpi_ctl->src_node_type + HPI_SOURCENODE_NONE != HPI_SOURCENODE_OSTREAM) &&\n\t\t(!hpi_ctl->dst_node_type))\n\t\tdir = \"Capture \";  \n\telse if (hpi_ctl->src_node_type &&\n\t\t(hpi_ctl->src_node_type + HPI_SOURCENODE_NONE != HPI_SOURCENODE_OSTREAM) &&\n\t\t(hpi_ctl->dst_node_type))\n\t\tdir = \"Monitor Playback \";  \n\telse\n\t\tdir = \"Playback \";  \n\n\tif (hpi_ctl->src_node_type && hpi_ctl->dst_node_type)\n\t\tsprintf(hpi_ctl->name, \"%s %d %s %d %s%s\",\n\t\t\tasihpi_src_names[hpi_ctl->src_node_type],\n\t\t\thpi_ctl->src_node_index,\n\t\t\tasihpi_dst_names[hpi_ctl->dst_node_type],\n\t\t\thpi_ctl->dst_node_index,\n\t\t\tdir, name);\n\telse if (hpi_ctl->dst_node_type) {\n\t\tsprintf(hpi_ctl->name, \"%s %d %s%s\",\n\t\tasihpi_dst_names[hpi_ctl->dst_node_type],\n\t\thpi_ctl->dst_node_index,\n\t\tdir, name);\n\t} else {\n\t\tsprintf(hpi_ctl->name, \"%s %d %s%s\",\n\t\tasihpi_src_names[hpi_ctl->src_node_type],\n\t\thpi_ctl->src_node_index,\n\t\tdir, name);\n\t}\n\t \n}\n\n \n#define VOL_STEP_mB 1\nstatic int snd_asihpi_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 count;\n\tu16 err;\n\t \n\tshort min_gain_mB;\n\tshort max_gain_mB;\n\tshort step_gain_mB;\n\n\terr = hpi_volume_query_range(h_control,\n\t\t\t&min_gain_mB, &max_gain_mB, &step_gain_mB);\n\tif (err) {\n\t\tmax_gain_mB = 0;\n\t\tmin_gain_mB = -10000;\n\t\tstep_gain_mB = VOL_STEP_mB;\n\t}\n\n\terr = hpi_meter_query_channels(h_control, &count);\n\tif (err)\n\t\tcount = HPI_MAX_CHANNELS;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = count;\n\tuinfo->value.integer.min = min_gain_mB / VOL_STEP_mB;\n\tuinfo->value.integer.max = max_gain_mB / VOL_STEP_mB;\n\tuinfo->value.integer.step = step_gain_mB / VOL_STEP_mB;\n\treturn 0;\n}\n\nstatic int snd_asihpi_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tshort an_gain_mB[HPI_MAX_CHANNELS];\n\n\thpi_handle_error(hpi_volume_get_gain(h_control, an_gain_mB));\n\tucontrol->value.integer.value[0] = an_gain_mB[0] / VOL_STEP_mB;\n\tucontrol->value.integer.value[1] = an_gain_mB[1] / VOL_STEP_mB;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tshort an_gain_mB[HPI_MAX_CHANNELS];\n\n\tan_gain_mB[0] =\n\t    (ucontrol->value.integer.value[0]) * VOL_STEP_mB;\n\tan_gain_mB[1] =\n\t    (ucontrol->value.integer.value[1]) * VOL_STEP_mB;\n\t \n\thpi_handle_error(hpi_volume_set_gain(h_control, an_gain_mB));\n\treturn 1;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_100, -10000, VOL_STEP_mB, 0);\n\n#define snd_asihpi_volume_mute_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_asihpi_volume_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 mute;\n\n\thpi_handle_error(hpi_volume_get_mute(h_control, &mute));\n\tucontrol->value.integer.value[0] = mute ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_volume_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\t \n\tint mute =  ucontrol->value.integer.value[0] ? 0 : HPI_BITMASK_ALL_CHANNELS;\n\thpi_handle_error(hpi_volume_set_mute(h_control, mute));\n\treturn 1;\n}\n\nstatic int snd_asihpi_volume_add(struct snd_card_asihpi *asihpi,\n\t\t\t\t struct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\tint err;\n\tu32 mute;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Volume\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\tsnd_control.info = snd_asihpi_volume_info;\n\tsnd_control.get = snd_asihpi_volume_get;\n\tsnd_control.put = snd_asihpi_volume_put;\n\tsnd_control.tlv.p = db_scale_100;\n\n\terr = ctl_add(card, &snd_control, asihpi);\n\tif (err)\n\t\treturn err;\n\n\tif (hpi_volume_get_mute(hpi_ctl->h_control, &mute) == 0) {\n\t\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Switch\");\n\t\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t\tsnd_control.info = snd_asihpi_volume_mute_info;\n\t\tsnd_control.get = snd_asihpi_volume_mute_get;\n\t\tsnd_control.put = snd_asihpi_volume_mute_put;\n\t\terr = ctl_add(card, &snd_control, asihpi);\n\t}\n\treturn err;\n}\n\n \nstatic int snd_asihpi_level_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 err;\n\tshort min_gain_mB;\n\tshort max_gain_mB;\n\tshort step_gain_mB;\n\n\terr =\n\t    hpi_level_query_range(h_control, &min_gain_mB,\n\t\t\t       &max_gain_mB, &step_gain_mB);\n\tif (err) {\n\t\tmax_gain_mB = 2400;\n\t\tmin_gain_mB = -1000;\n\t\tstep_gain_mB = 100;\n\t}\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = min_gain_mB / HPI_UNITS_PER_dB;\n\tuinfo->value.integer.max = max_gain_mB / HPI_UNITS_PER_dB;\n\tuinfo->value.integer.step = step_gain_mB / HPI_UNITS_PER_dB;\n\treturn 0;\n}\n\nstatic int snd_asihpi_level_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tshort an_gain_mB[HPI_MAX_CHANNELS];\n\n\thpi_handle_error(hpi_level_get_gain(h_control, an_gain_mB));\n\tucontrol->value.integer.value[0] =\n\t    an_gain_mB[0] / HPI_UNITS_PER_dB;\n\tucontrol->value.integer.value[1] =\n\t    an_gain_mB[1] / HPI_UNITS_PER_dB;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_level_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tu32 h_control = kcontrol->private_value;\n\tshort an_gain_mB[HPI_MAX_CHANNELS];\n\n\tan_gain_mB[0] =\n\t    (ucontrol->value.integer.value[0]) * HPI_UNITS_PER_dB;\n\tan_gain_mB[1] =\n\t    (ucontrol->value.integer.value[1]) * HPI_UNITS_PER_dB;\n\t \n\tchange = 1;\n\thpi_handle_error(hpi_level_set_gain(h_control, an_gain_mB));\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_level, -1000, 100, 0);\n\nstatic int snd_asihpi_level_add(struct snd_card_asihpi *asihpi,\n\t\t\t\tstruct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\t \n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Level\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\tsnd_control.info = snd_asihpi_level_info;\n\tsnd_control.get = snd_asihpi_level_get;\n\tsnd_control.put = snd_asihpi_level_put;\n\tsnd_control.tlv.p = db_scale_level;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\n \n\n \nstatic const char * const asihpi_aesebu_format_names[] = {\n\t\"N/A\", \"S/PDIF\", \"AES/EBU\" };\n\nstatic int snd_asihpi_aesebu_format_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 3, asihpi_aesebu_format_names);\n}\n\nstatic int snd_asihpi_aesebu_format_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol,\n\t\t\tu16 (*func)(u32, u16 *))\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 source, err;\n\n\terr = func(h_control, &source);\n\n\t \n\tucontrol->value.enumerated.item[0] = 0;\n\t \n\tif (err)\n\t\treturn 0;\n\tif (source == HPI_AESEBU_FORMAT_SPDIF)\n\t\tucontrol->value.enumerated.item[0] = 1;\n\tif (source == HPI_AESEBU_FORMAT_AESEBU)\n\t\tucontrol->value.enumerated.item[0] = 2;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_aesebu_format_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol,\n\t\t\t u16 (*func)(u32, u16))\n{\n\tu32 h_control = kcontrol->private_value;\n\n\t \n\tu16 source = HPI_AESEBU_FORMAT_SPDIF;\n\n\tif (ucontrol->value.enumerated.item[0] == 1)\n\t\tsource = HPI_AESEBU_FORMAT_SPDIF;\n\tif (ucontrol->value.enumerated.item[0] == 2)\n\t\tsource = HPI_AESEBU_FORMAT_AESEBU;\n\n\tif (func(h_control, source) != 0)\n\t\treturn -EINVAL;\n\n\treturn 1;\n}\n\nstatic int snd_asihpi_aesebu_rx_format_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol) {\n\treturn snd_asihpi_aesebu_format_get(kcontrol, ucontrol,\n\t\t\t\t\thpi_aesebu_receiver_get_format);\n}\n\nstatic int snd_asihpi_aesebu_rx_format_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol) {\n\treturn snd_asihpi_aesebu_format_put(kcontrol, ucontrol,\n\t\t\t\t\thpi_aesebu_receiver_set_format);\n}\n\nstatic int snd_asihpi_aesebu_rxstatus_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0X1F;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_aesebu_rxstatus_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol) {\n\n\tu32 h_control = kcontrol->private_value;\n\tu16 status;\n\n\thpi_handle_error(hpi_aesebu_receiver_get_error_status(\n\t\t\t\t\t h_control, &status));\n\tucontrol->value.integer.value[0] = status;\n\treturn 0;\n}\n\nstatic int snd_asihpi_aesebu_rx_add(struct snd_card_asihpi *asihpi,\n\t\t\t\t    struct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Format\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tsnd_control.info = snd_asihpi_aesebu_format_info;\n\tsnd_control.get = snd_asihpi_aesebu_rx_format_get;\n\tsnd_control.put = snd_asihpi_aesebu_rx_format_put;\n\n\n\tif (ctl_add(card, &snd_control, asihpi) < 0)\n\t\treturn -EINVAL;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Status\");\n\tsnd_control.access =\n\t    SNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\n\tsnd_control.info = snd_asihpi_aesebu_rxstatus_info;\n\tsnd_control.get = snd_asihpi_aesebu_rxstatus_get;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\nstatic int snd_asihpi_aesebu_tx_format_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol) {\n\treturn snd_asihpi_aesebu_format_get(kcontrol, ucontrol,\n\t\t\t\t\thpi_aesebu_transmitter_get_format);\n}\n\nstatic int snd_asihpi_aesebu_tx_format_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol) {\n\treturn snd_asihpi_aesebu_format_put(kcontrol, ucontrol,\n\t\t\t\t\thpi_aesebu_transmitter_set_format);\n}\n\n\nstatic int snd_asihpi_aesebu_tx_add(struct snd_card_asihpi *asihpi,\n\t\t\t\t    struct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Format\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tsnd_control.info = snd_asihpi_aesebu_format_info;\n\tsnd_control.get = snd_asihpi_aesebu_tx_format_get;\n\tsnd_control.put = snd_asihpi_aesebu_tx_format_put;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\n \n\n \n\nstatic int snd_asihpi_tuner_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 err;\n\tshort idx;\n\tu16 gain_range[3];\n\n\tfor (idx = 0; idx < 3; idx++) {\n\t\terr = hpi_tuner_query_gain(h_control,\n\t\t\t\t\t  idx, &gain_range[idx]);\n\t\tif (err != 0)\n\t\t\treturn err;\n\t}\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = ((int)gain_range[0]) / HPI_UNITS_PER_dB;\n\tuinfo->value.integer.max = ((int)gain_range[1]) / HPI_UNITS_PER_dB;\n\tuinfo->value.integer.step = ((int) gain_range[2]) / HPI_UNITS_PER_dB;\n\treturn 0;\n}\n\nstatic int snd_asihpi_tuner_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tu32 h_control = kcontrol->private_value;\n\tshort gain;\n\n\thpi_handle_error(hpi_tuner_get_gain(h_control, &gain));\n\tucontrol->value.integer.value[0] = gain / HPI_UNITS_PER_dB;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_tuner_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tu32 h_control = kcontrol->private_value;\n\tshort gain;\n\n\tgain = (ucontrol->value.integer.value[0]) * HPI_UNITS_PER_dB;\n\thpi_handle_error(hpi_tuner_set_gain(h_control, gain));\n\n\treturn 1;\n}\n\n \n\nstatic int asihpi_tuner_band_query(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tu16 *band_list, u32 len) {\n\tu32 h_control = kcontrol->private_value;\n\tu16 err = 0;\n\tu32 i;\n\n\tfor (i = 0; i < len; i++) {\n\t\terr = hpi_tuner_query_band(\n\t\t\t\th_control, i, &band_list[i]);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\n\tif (err && (err != HPI_ERROR_INVALID_OBJ_INDEX))\n\t\treturn -EIO;\n\n\treturn i;\n}\n\nstatic int snd_asihpi_tuner_band_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tu16 tuner_bands[HPI_TUNER_BAND_LAST];\n\tint num_bands = 0;\n\n\tnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\n\t\t\t\tHPI_TUNER_BAND_LAST);\n\n\tif (num_bands < 0)\n\t\treturn num_bands;\n\n\treturn snd_ctl_enum_info(uinfo, 1, num_bands, asihpi_tuner_band_names);\n}\n\nstatic int snd_asihpi_tuner_band_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\t \n\tu16 band, idx;\n\tu16 tuner_bands[HPI_TUNER_BAND_LAST];\n\t__always_unused u32 num_bands;\n\n\tnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\n\t\t\t\tHPI_TUNER_BAND_LAST);\n\n\thpi_handle_error(hpi_tuner_get_band(h_control, &band));\n\n\tucontrol->value.enumerated.item[0] = -1;\n\tfor (idx = 0; idx < HPI_TUNER_BAND_LAST; idx++)\n\t\tif (tuner_bands[idx] == band) {\n\t\t\tucontrol->value.enumerated.item[0] = idx;\n\t\t\tbreak;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_tuner_band_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tu32 h_control = kcontrol->private_value;\n\tunsigned int idx;\n\tu16 band;\n\tu16 tuner_bands[HPI_TUNER_BAND_LAST];\n\t__always_unused u32 num_bands;\n\n\tnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\n\t\t\tHPI_TUNER_BAND_LAST);\n\n\tidx = ucontrol->value.enumerated.item[0];\n\tif (idx >= ARRAY_SIZE(tuner_bands))\n\t\tidx = ARRAY_SIZE(tuner_bands) - 1;\n\tband = tuner_bands[idx];\n\thpi_handle_error(hpi_tuner_set_band(h_control, band));\n\n\treturn 1;\n}\n\n \n\nstatic int snd_asihpi_tuner_freq_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 err;\n\tu16 tuner_bands[HPI_TUNER_BAND_LAST];\n\tu16 num_bands = 0, band_iter, idx;\n\tu32 freq_range[3], temp_freq_range[3];\n\n\tnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\n\t\t\tHPI_TUNER_BAND_LAST);\n\n\tfreq_range[0] = INT_MAX;\n\tfreq_range[1] = 0;\n\tfreq_range[2] = INT_MAX;\n\n\tfor (band_iter = 0; band_iter < num_bands; band_iter++) {\n\t\tfor (idx = 0; idx < 3; idx++) {\n\t\t\terr = hpi_tuner_query_frequency(h_control,\n\t\t\t\tidx, tuner_bands[band_iter],\n\t\t\t\t&temp_freq_range[idx]);\n\t\t\tif (err != 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (temp_freq_range[2] <= 0)\n\t\t\tcontinue;\n\n\t\tif (temp_freq_range[0] < freq_range[0])\n\t\t\tfreq_range[0] = temp_freq_range[0];\n\t\tif (temp_freq_range[1] > freq_range[1])\n\t\t\tfreq_range[1] = temp_freq_range[1];\n\t\tif (temp_freq_range[2] < freq_range[2])\n\t\t\tfreq_range[2] = temp_freq_range[2];\n\t}\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = ((int)freq_range[0]);\n\tuinfo->value.integer.max = ((int)freq_range[1]);\n\tuinfo->value.integer.step = ((int)freq_range[2]);\n\treturn 0;\n}\n\nstatic int snd_asihpi_tuner_freq_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 freq;\n\n\thpi_handle_error(hpi_tuner_get_frequency(h_control, &freq));\n\tucontrol->value.integer.value[0] = freq;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_tuner_freq_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 freq;\n\n\tfreq = ucontrol->value.integer.value[0];\n\thpi_handle_error(hpi_tuner_set_frequency(h_control, freq));\n\n\treturn 1;\n}\n\n \nstatic int snd_asihpi_tuner_add(struct snd_card_asihpi *asihpi,\n\t\t\t\tstruct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tsnd_control.private_value = hpi_ctl->h_control;\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\n\tif (!hpi_tuner_get_gain(hpi_ctl->h_control, NULL)) {\n\t\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Gain\");\n\t\tsnd_control.info = snd_asihpi_tuner_gain_info;\n\t\tsnd_control.get = snd_asihpi_tuner_gain_get;\n\t\tsnd_control.put = snd_asihpi_tuner_gain_put;\n\n\t\tif (ctl_add(card, &snd_control, asihpi) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Band\");\n\tsnd_control.info = snd_asihpi_tuner_band_info;\n\tsnd_control.get = snd_asihpi_tuner_band_get;\n\tsnd_control.put = snd_asihpi_tuner_band_put;\n\n\tif (ctl_add(card, &snd_control, asihpi) < 0)\n\t\treturn -EINVAL;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Freq\");\n\tsnd_control.info = snd_asihpi_tuner_freq_info;\n\tsnd_control.get = snd_asihpi_tuner_freq_get;\n\tsnd_control.put = snd_asihpi_tuner_freq_put;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\n \nstatic int snd_asihpi_meter_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 count;\n\tu16 err;\n\terr = hpi_meter_query_channels(h_control, &count);\n\tif (err)\n\t\tcount = HPI_MAX_CHANNELS;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = count;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x7FFFFFFF;\n\treturn 0;\n}\n\n \nstatic const int log2lin[] = {\n\t0x7FFFFFFF,  \n\t679093956,\n\t214748365,\n\t 67909396,\n\t 21474837,\n\t  6790940,\n\t  2147484,  \n\t   679094,\n\t   214748,  \n\t    67909,\n\t    21475,  \n\t     6791,\n\t     2147,\n\t      679,\n\t      214,\n\t       68,\n\t       21,\n\t\t7,\n\t\t2\n};\n\nstatic int snd_asihpi_meter_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tshort an_gain_mB[HPI_MAX_CHANNELS], i;\n\tu16 err;\n\n\terr = hpi_meter_get_peak(h_control, an_gain_mB);\n\n\tfor (i = 0; i < HPI_MAX_CHANNELS; i++) {\n\t\tif (err) {\n\t\t\tucontrol->value.integer.value[i] = 0;\n\t\t} else if (an_gain_mB[i] >= 0) {\n\t\t\tucontrol->value.integer.value[i] =\n\t\t\t\tan_gain_mB[i] << 16;\n\t\t} else {\n\t\t\t \n\t\t\tucontrol->value.integer.value[i] =\n\t\t\t\t\tlog2lin[an_gain_mB[i] / -1000];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_asihpi_meter_add(struct snd_card_asihpi *asihpi,\n\t\t\t\tstruct hpi_control *hpi_ctl, int subidx)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Meter\");\n\tsnd_control.access =\n\t    SNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\n\tsnd_control.info = snd_asihpi_meter_info;\n\tsnd_control.get = snd_asihpi_meter_get;\n\n\tsnd_control.index = subidx;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\n \nstatic int snd_card_asihpi_mux_count_sources(struct snd_kcontrol *snd_control)\n{\n\tu32 h_control = snd_control->private_value;\n\tstruct hpi_control hpi_ctl;\n\tint s, err;\n\tfor (s = 0; s < 32; s++) {\n\t\terr = hpi_multiplexer_query_source(h_control, s,\n\t\t\t\t\t\t  &hpi_ctl.\n\t\t\t\t\t\t  src_node_type,\n\t\t\t\t\t\t  &hpi_ctl.\n\t\t\t\t\t\t  src_node_index);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic int snd_asihpi_mux_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tu16 src_node_type, src_node_index;\n\tu32 h_control = kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items =\n\t    snd_card_asihpi_mux_count_sources(kcontrol);\n\n\tif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\n\t\tuinfo->value.enumerated.item =\n\t\t    uinfo->value.enumerated.items - 1;\n\n\thpi_multiplexer_query_source(h_control,\n\t\t\t\t     uinfo->value.enumerated.item,\n\t\t\t\t     &src_node_type, &src_node_index);\n\n\tsprintf(uinfo->value.enumerated.name, \"%s %d\",\n\t\tasihpi_src_names[src_node_type - HPI_SOURCENODE_NONE],\n\t\tsrc_node_index);\n\treturn 0;\n}\n\nstatic int snd_asihpi_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 source_type, source_index;\n\tu16 src_node_type, src_node_index;\n\tint s;\n\n\thpi_handle_error(hpi_multiplexer_get_source(h_control,\n\t\t\t\t&source_type, &source_index));\n\t \n\tfor (s = 0; s < 256; s++) {\n\t\tif (hpi_multiplexer_query_source(h_control, s,\n\t\t\t\t\t    &src_node_type, &src_node_index))\n\t\t\tbreak;\n\n\t\tif ((source_type == src_node_type)\n\t\t    && (source_index == src_node_index)) {\n\t\t\tucontrol->value.enumerated.item[0] = s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsnd_printd(KERN_WARNING\n\t\t\"Control %x failed to match mux source %hu %hu\\n\",\n\t\th_control, source_type, source_index);\n\tucontrol->value.enumerated.item[0] = 0;\n\treturn 0;\n}\n\nstatic int snd_asihpi_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tu32 h_control = kcontrol->private_value;\n\tu16 source_type, source_index;\n\tu16 e;\n\n\tchange = 1;\n\n\te = hpi_multiplexer_query_source(h_control,\n\t\t\t\t    ucontrol->value.enumerated.item[0],\n\t\t\t\t    &source_type, &source_index);\n\tif (!e)\n\t\thpi_handle_error(\n\t\t\thpi_multiplexer_set_source(h_control,\n\t\t\t\t\t\tsource_type, source_index));\n\treturn change;\n}\n\n\nstatic int  snd_asihpi_mux_add(struct snd_card_asihpi *asihpi,\n\t\t\t       struct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Route\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tsnd_control.info = snd_asihpi_mux_info;\n\tsnd_control.get = snd_asihpi_mux_get;\n\tsnd_control.put = snd_asihpi_mux_put;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n\n}\n\n \nstatic int snd_asihpi_cmode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const mode_names[HPI_CHANNEL_MODE_LAST + 1] = {\n\t\t\"invalid\",\n\t\t\"Normal\", \"Swap\",\n\t\t\"From Left\", \"From Right\",\n\t\t\"To Left\", \"To Right\"\n\t};\n\n\tu32 h_control = kcontrol->private_value;\n\tu16 mode;\n\tint i;\n\tconst char *mapped_names[6];\n\tint valid_modes = 0;\n\n\t \n\tfor (i = 0; i < HPI_CHANNEL_MODE_LAST; i++)\n\t\tif (!hpi_channel_mode_query_mode(\n\t\t\th_control, i, &mode)) {\n\t\t\tmapped_names[valid_modes] = mode_names[mode];\n\t\t\tvalid_modes++;\n\t\t\t}\n\n\tif (!valid_modes)\n\t\treturn -EINVAL;\n\n\treturn snd_ctl_enum_info(uinfo, 1, valid_modes, mapped_names);\n}\n\nstatic int snd_asihpi_cmode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu16 mode;\n\n\tif (hpi_channel_mode_get(h_control, &mode))\n\t\tmode = 1;\n\n\tucontrol->value.enumerated.item[0] = mode - 1;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_cmode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tu32 h_control = kcontrol->private_value;\n\n\tchange = 1;\n\n\thpi_handle_error(hpi_channel_mode_set(h_control,\n\t\t\t   ucontrol->value.enumerated.item[0] + 1));\n\treturn change;\n}\n\n\nstatic int snd_asihpi_cmode_add(struct snd_card_asihpi *asihpi,\n\t\t\t\tstruct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card = asihpi->card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Mode\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tsnd_control.info = snd_asihpi_cmode_info;\n\tsnd_control.get = snd_asihpi_cmode_get;\n\tsnd_control.put = snd_asihpi_cmode_put;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n\n \nstatic const char * const sampleclock_sources[] = {\n\t\"N/A\", \"Local PLL\", \"Digital Sync\", \"Word External\", \"Word Header\",\n\t\"SMPTE\", \"Digital1\", \"Auto\", \"Network\", \"Invalid\",\n\t\"Prev Module\", \"BLU-Link\",\n\t\"Digital2\", \"Digital3\", \"Digital4\", \"Digital5\",\n\t\"Digital6\", \"Digital7\", \"Digital8\"};\n\n\t \n\tcompile_time_assert(\n\t\t(ARRAY_SIZE(sampleclock_sources) == MAX_CLOCKSOURCES),\n\t\tassert_sampleclock_sources_size);\n\nstatic int snd_asihpi_clksrc_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_card_asihpi *asihpi =\n\t\t\t(struct snd_card_asihpi *)(kcontrol->private_data);\n\tstruct clk_cache *clkcache = &asihpi->cc;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\tuinfo->value.enumerated.items = clkcache->count;\n\n\tif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\n\t\tuinfo->value.enumerated.item =\n\t\t\t\tuinfo->value.enumerated.items - 1;\n\n\tstrcpy(uinfo->value.enumerated.name,\n\t       clkcache->s[uinfo->value.enumerated.item].name);\n\treturn 0;\n}\n\nstatic int snd_asihpi_clksrc_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_card_asihpi *asihpi =\n\t\t\t(struct snd_card_asihpi *)(kcontrol->private_data);\n\tstruct clk_cache *clkcache = &asihpi->cc;\n\tu32 h_control = kcontrol->private_value;\n\tu16 source, srcindex = 0;\n\tint i;\n\n\tucontrol->value.enumerated.item[0] = 0;\n\tif (hpi_sample_clock_get_source(h_control, &source))\n\t\tsource = 0;\n\n\tif (source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\n\t\tif (hpi_sample_clock_get_source_index(h_control, &srcindex))\n\t\t\tsrcindex = 0;\n\n\tfor (i = 0; i < clkcache->count; i++)\n\t\tif ((clkcache->s[i].source == source) &&\n\t\t\t(clkcache->s[i].index == srcindex))\n\t\t\tbreak;\n\n\tucontrol->value.enumerated.item[0] = i;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_clksrc_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_card_asihpi *asihpi =\n\t\t\t(struct snd_card_asihpi *)(kcontrol->private_data);\n\tstruct clk_cache *clkcache = &asihpi->cc;\n\tunsigned int item;\n\tint change;\n\tu32 h_control = kcontrol->private_value;\n\n\tchange = 1;\n\titem = ucontrol->value.enumerated.item[0];\n\tif (item >= clkcache->count)\n\t\titem = clkcache->count-1;\n\n\thpi_handle_error(hpi_sample_clock_set_source(\n\t\t\t\th_control, clkcache->s[item].source));\n\n\tif (clkcache->s[item].source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\n\t\thpi_handle_error(hpi_sample_clock_set_source_index(\n\t\t\t\th_control, clkcache->s[item].index));\n\treturn change;\n}\n\n \n \nstatic int snd_asihpi_clklocal_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 8000;\n\tuinfo->value.integer.max = 192000;\n\tuinfo->value.integer.step = 100;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_clklocal_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 rate;\n\tu16 e;\n\n\te = hpi_sample_clock_get_local_rate(h_control, &rate);\n\tif (!e)\n\t\tucontrol->value.integer.value[0] = rate;\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\treturn 0;\n}\n\nstatic int snd_asihpi_clklocal_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tu32 h_control = kcontrol->private_value;\n\n\t \n\tchange = 1;\n\thpi_handle_error(hpi_sample_clock_set_local_rate(h_control,\n\t\t\t\t      ucontrol->value.integer.value[0]));\n\treturn change;\n}\n\nstatic int snd_asihpi_clkrate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 8000;\n\tuinfo->value.integer.max = 192000;\n\tuinfo->value.integer.step = 100;\n\n\treturn 0;\n}\n\nstatic int snd_asihpi_clkrate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 h_control = kcontrol->private_value;\n\tu32 rate;\n\tu16 e;\n\n\te = hpi_sample_clock_get_sample_rate(h_control, &rate);\n\tif (!e)\n\t\tucontrol->value.integer.value[0] = rate;\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\treturn 0;\n}\n\nstatic int snd_asihpi_sampleclock_add(struct snd_card_asihpi *asihpi,\n\t\t\t\t      struct hpi_control *hpi_ctl)\n{\n\tstruct snd_card *card;\n\tstruct snd_kcontrol_new snd_control;\n\n\tstruct clk_cache *clkcache;\n\tu32 hSC =  hpi_ctl->h_control;\n\tint has_aes_in = 0;\n\tint i, j;\n\tu16 source;\n\n\tif (snd_BUG_ON(!asihpi))\n\t\treturn -EINVAL;\n\tcard = asihpi->card;\n\tclkcache = &asihpi->cc;\n\tsnd_control.private_value = hpi_ctl->h_control;\n\n\tclkcache->has_local = 0;\n\n\tfor (i = 0; i <= HPI_SAMPLECLOCK_SOURCE_LAST; i++) {\n\t\tif  (hpi_sample_clock_query_source(hSC,\n\t\t\t\ti, &source))\n\t\t\tbreak;\n\t\tclkcache->s[i].source = source;\n\t\tclkcache->s[i].index = 0;\n\t\tclkcache->s[i].name = sampleclock_sources[source];\n\t\tif (source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\n\t\t\thas_aes_in = 1;\n\t\tif (source == HPI_SAMPLECLOCK_SOURCE_LOCAL)\n\t\t\tclkcache->has_local = 1;\n\t}\n\tif (has_aes_in)\n\t\t \n\t\tfor (j = 1; j < 8; j++) {\n\t\t\tif (hpi_sample_clock_query_source_index(hSC,\n\t\t\t\tj, HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT,\n\t\t\t\t&source))\n\t\t\t\tbreak;\n\t\t\tclkcache->s[i].source =\n\t\t\t\tHPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT;\n\t\t\tclkcache->s[i].index = j;\n\t\t\tclkcache->s[i].name = sampleclock_sources[\n\t\t\t\t\tj+HPI_SAMPLECLOCK_SOURCE_LAST];\n\t\t\ti++;\n\t\t}\n\tclkcache->count = i;\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Source\");\n\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE ;\n\tsnd_control.info = snd_asihpi_clksrc_info;\n\tsnd_control.get = snd_asihpi_clksrc_get;\n\tsnd_control.put = snd_asihpi_clksrc_put;\n\tif (ctl_add(card, &snd_control, asihpi) < 0)\n\t\treturn -EINVAL;\n\n\n\tif (clkcache->has_local) {\n\t\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Localrate\");\n\t\tsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE ;\n\t\tsnd_control.info = snd_asihpi_clklocal_info;\n\t\tsnd_control.get = snd_asihpi_clklocal_get;\n\t\tsnd_control.put = snd_asihpi_clklocal_put;\n\n\n\t\tif (ctl_add(card, &snd_control, asihpi) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tasihpi_ctl_init(&snd_control, hpi_ctl, \"Rate\");\n\tsnd_control.access =\n\t    SNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\n\tsnd_control.info = snd_asihpi_clkrate_info;\n\tsnd_control.get = snd_asihpi_clkrate_get;\n\n\treturn ctl_add(card, &snd_control, asihpi);\n}\n \n\nstatic int snd_card_asihpi_mixer_new(struct snd_card_asihpi *asihpi)\n{\n\tstruct snd_card *card;\n\tunsigned int idx = 0;\n\tunsigned int subindex = 0;\n\tint err;\n\tstruct hpi_control hpi_ctl, prev_ctl;\n\n\tif (snd_BUG_ON(!asihpi))\n\t\treturn -EINVAL;\n\tcard = asihpi->card;\n\tstrcpy(card->mixername, \"Asihpi Mixer\");\n\n\terr =\n\t    hpi_mixer_open(asihpi->hpi->adapter->index,\n\t\t\t  &asihpi->h_mixer);\n\thpi_handle_error(err);\n\tif (err)\n\t\treturn -err;\n\n\tmemset(&prev_ctl, 0, sizeof(prev_ctl));\n\tprev_ctl.control_type = -1;\n\n\tfor (idx = 0; idx < 2000; idx++) {\n\t\terr = hpi_mixer_get_control_by_index(\n\t\t\t\tasihpi->h_mixer,\n\t\t\t\tidx,\n\t\t\t\t&hpi_ctl.src_node_type,\n\t\t\t\t&hpi_ctl.src_node_index,\n\t\t\t\t&hpi_ctl.dst_node_type,\n\t\t\t\t&hpi_ctl.dst_node_index,\n\t\t\t\t&hpi_ctl.control_type,\n\t\t\t\t&hpi_ctl.h_control);\n\t\tif (err) {\n\t\t\tif (err == HPI_ERROR_CONTROL_DISABLED) {\n\t\t\t\tif (mixer_dump)\n\t\t\t\t\tdev_info(&asihpi->pci->dev,\n\t\t\t\t\t\t   \"Disabled HPI Control(%d)\\n\",\n\t\t\t\t\t\t   idx);\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\thpi_ctl.src_node_type -= HPI_SOURCENODE_NONE;\n\t\thpi_ctl.dst_node_type -= HPI_DESTNODE_NONE;\n\n\t\t \n\t\tif ((hpi_ctl.control_type == prev_ctl.control_type) &&\n\t\t    (hpi_ctl.src_node_type == prev_ctl.src_node_type) &&\n\t\t    (hpi_ctl.src_node_index == prev_ctl.src_node_index) &&\n\t\t    (hpi_ctl.dst_node_type == prev_ctl.dst_node_type) &&\n\t\t    (hpi_ctl.dst_node_index == prev_ctl.dst_node_index))\n\t\t\tsubindex++;\n\t\telse\n\t\t\tsubindex = 0;\n\n\t\tprev_ctl = hpi_ctl;\n\n\t\tswitch (hpi_ctl.control_type) {\n\t\tcase HPI_CONTROL_VOLUME:\n\t\t\terr = snd_asihpi_volume_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_LEVEL:\n\t\t\terr = snd_asihpi_level_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_MULTIPLEXER:\n\t\t\terr = snd_asihpi_mux_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_CHANNEL_MODE:\n\t\t\terr = snd_asihpi_cmode_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_METER:\n\t\t\terr = snd_asihpi_meter_add(asihpi, &hpi_ctl, subindex);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_SAMPLECLOCK:\n\t\t\terr = snd_asihpi_sampleclock_add(\n\t\t\t\t\t\tasihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_CONNECTION:\t \n\t\t\tcontinue;\n\t\tcase HPI_CONTROL_TUNER:\n\t\t\terr = snd_asihpi_tuner_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_AESEBU_TRANSMITTER:\n\t\t\terr = snd_asihpi_aesebu_tx_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_AESEBU_RECEIVER:\n\t\t\terr = snd_asihpi_aesebu_rx_add(asihpi, &hpi_ctl);\n\t\t\tbreak;\n\t\tcase HPI_CONTROL_VOX:\n\t\tcase HPI_CONTROL_BITSTREAM:\n\t\tcase HPI_CONTROL_MICROPHONE:\n\t\tcase HPI_CONTROL_PARAMETRIC_EQ:\n\t\tcase HPI_CONTROL_COMPANDER:\n\t\tdefault:\n\t\t\tif (mixer_dump)\n\t\t\t\tdev_info(&asihpi->pci->dev,\n\t\t\t\t\t\"Untranslated HPI Control (%d) %d %d %d %d %d\\n\",\n\t\t\t\t\tidx,\n\t\t\t\t\thpi_ctl.control_type,\n\t\t\t\t\thpi_ctl.src_node_type,\n\t\t\t\t\thpi_ctl.src_node_index,\n\t\t\t\t\thpi_ctl.dst_node_type,\n\t\t\t\t\thpi_ctl.dst_node_index);\n\t\t\tcontinue;\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (HPI_ERROR_INVALID_OBJ_INDEX != err)\n\t\thpi_handle_error(err);\n\n\tdev_info(&asihpi->pci->dev, \"%d mixer controls found\\n\", idx);\n\n\treturn 0;\n}\n\n \n\nstatic void\nsnd_asihpi_proc_read(struct snd_info_entry *entry,\n\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_card_asihpi *asihpi = entry->private_data;\n\tu32 h_control;\n\tu32 rate = 0;\n\tu16 source = 0;\n\n\tu16 num_outstreams;\n\tu16 num_instreams;\n\tu16 version;\n\tu32 serial_number;\n\tu16 type;\n\n\tint err;\n\n\tsnd_iprintf(buffer, \"ASIHPI driver proc file\\n\");\n\n\thpi_handle_error(hpi_adapter_get_info(asihpi->hpi->adapter->index,\n\t\t\t&num_outstreams, &num_instreams,\n\t\t\t&version, &serial_number, &type));\n\n\tsnd_iprintf(buffer,\n\t\t\t\"Adapter type ASI%4X\\nHardware Index %d\\n\"\n\t\t\t\"%d outstreams\\n%d instreams\\n\",\n\t\t\ttype, asihpi->hpi->adapter->index,\n\t\t\tnum_outstreams, num_instreams);\n\n\tsnd_iprintf(buffer,\n\t\t\"Serial#%d\\nHardware version %c%d\\nDSP code version %03d\\n\",\n\t\tserial_number, ((version >> 3) & 0xf) + 'A', version & 0x7,\n\t\t((version >> 13) * 100) + ((version >> 7) & 0x3f));\n\n\terr = hpi_mixer_get_control(asihpi->h_mixer,\n\t\t\t\t  HPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\n\t\t\t\t  HPI_CONTROL_SAMPLECLOCK, &h_control);\n\n\tif (!err) {\n\t\terr = hpi_sample_clock_get_sample_rate(h_control, &rate);\n\t\terr += hpi_sample_clock_get_source(h_control, &source);\n\n\t\tif (!err)\n\t\t\tsnd_iprintf(buffer, \"Sample Clock %dHz, source %s\\n\",\n\t\t\trate, sampleclock_sources[source]);\n\t}\n}\n\nstatic void snd_asihpi_proc_init(struct snd_card_asihpi *asihpi)\n{\n\tsnd_card_ro_proc_new(asihpi->card, \"info\", asihpi,\n\t\t\t     snd_asihpi_proc_read);\n}\n\n \n\nstatic int snd_asihpi_hpi_open(struct snd_hwdep *hw, struct file *file)\n{\n\tif (enable_hpi_hwdep)\n\t\treturn 0;\n\telse\n\t\treturn -ENODEV;\n\n}\n\nstatic int snd_asihpi_hpi_release(struct snd_hwdep *hw, struct file *file)\n{\n\tif (enable_hpi_hwdep)\n\t\treturn asihpi_hpi_release(file);\n\telse\n\t\treturn -ENODEV;\n}\n\nstatic int snd_asihpi_hpi_ioctl(struct snd_hwdep *hw, struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tif (enable_hpi_hwdep)\n\t\treturn asihpi_hpi_ioctl(file, cmd, arg);\n\telse\n\t\treturn -ENODEV;\n}\n\n\n \nstatic int snd_asihpi_hpi_new(struct snd_card_asihpi *asihpi, int device)\n{\n\tstruct snd_hwdep *hw;\n\tint err;\n\n\terr = snd_hwdep_new(asihpi->card, \"HPI\", device, &hw);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(hw->name, \"asihpi (HPI)\");\n\thw->iface = SNDRV_HWDEP_IFACE_LAST;\n\thw->ops.open = snd_asihpi_hpi_open;\n\thw->ops.ioctl = snd_asihpi_hpi_ioctl;\n\thw->ops.release = snd_asihpi_hpi_release;\n\thw->private_data = asihpi;\n\treturn 0;\n}\n\n \nstatic int snd_asihpi_probe(struct pci_dev *pci_dev,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tint err;\n\tstruct hpi_adapter *hpi;\n\tstruct snd_card *card;\n\tstruct snd_card_asihpi *asihpi;\n\n\tu32 h_control;\n\tu32 h_stream;\n\tu32 adapter_index;\n\n\tstatic int dev;\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\t \n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\terr = asihpi_adapter_probe(pci_dev, pci_id);\n\tif (err < 0)\n\t\treturn err;\n\n\thpi = pci_get_drvdata(pci_dev);\n\tadapter_index = hpi->adapter->index;\n\t \n\terr = snd_card_new(&pci_dev->dev, adapter_index, id[adapter_index],\n\t\t\t   THIS_MODULE, sizeof(struct snd_card_asihpi), &card);\n\tif (err < 0) {\n\t\t \n\t\terr = snd_card_new(&pci_dev->dev, index[dev], id[dev],\n\t\t\t\t   THIS_MODULE, sizeof(struct snd_card_asihpi),\n\t\t\t\t   &card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdev_warn(&pci_dev->dev, \"Adapter index %d->ALSA index %d\\n\",\n\t\t\tadapter_index, card->number);\n\t}\n\n\tasihpi = card->private_data;\n\tasihpi->card = card;\n\tasihpi->pci = pci_dev;\n\tasihpi->hpi = hpi;\n\thpi->snd_card = card;\n\n\terr = hpi_adapter_get_property(adapter_index,\n\t\tHPI_ADAPTER_PROPERTY_CAPS1,\n\t\tNULL, &asihpi->support_grouping);\n\tif (err)\n\t\tasihpi->support_grouping = 0;\n\n\terr = hpi_adapter_get_property(adapter_index,\n\t\tHPI_ADAPTER_PROPERTY_CAPS2,\n\t\t&asihpi->support_mrx, NULL);\n\tif (err)\n\t\tasihpi->support_mrx = 0;\n\n\terr = hpi_adapter_get_property(adapter_index,\n\t\tHPI_ADAPTER_PROPERTY_INTERVAL,\n\t\tNULL, &asihpi->update_interval_frames);\n\tif (err)\n\t\tasihpi->update_interval_frames = 512;\n\n\tif (hpi->interrupt_mode) {\n\t\tasihpi->pcm_start = snd_card_asihpi_pcm_int_start;\n\t\tasihpi->pcm_stop = snd_card_asihpi_pcm_int_stop;\n\t\thpi->interrupt_callback = snd_card_asihpi_isr;\n\t} else {\n\t\tasihpi->pcm_start = snd_card_asihpi_pcm_timer_start;\n\t\tasihpi->pcm_stop = snd_card_asihpi_pcm_timer_stop;\n\t}\n\n\thpi_handle_error(hpi_instream_open(adapter_index,\n\t\t\t     0, &h_stream));\n\n\terr = hpi_instream_host_buffer_free(h_stream);\n\tasihpi->can_dma = (!err);\n\n\thpi_handle_error(hpi_instream_close(h_stream));\n\n\tif (!asihpi->can_dma)\n\t\tasihpi->update_interval_frames *= 2;\n\n\terr = hpi_adapter_get_property(adapter_index,\n\t\tHPI_ADAPTER_PROPERTY_CURCHANNELS,\n\t\t&asihpi->in_max_chans, &asihpi->out_max_chans);\n\tif (err) {\n\t\tasihpi->in_max_chans = 2;\n\t\tasihpi->out_max_chans = 2;\n\t}\n\n\tif (asihpi->out_max_chans > 2) {  \n\t\tasihpi->out_min_chans = asihpi->out_max_chans;\n\t\tasihpi->in_min_chans = asihpi->in_max_chans;\n\t\tasihpi->support_grouping = 0;\n\t} else {\n\t\tasihpi->out_min_chans = 1;\n\t\tasihpi->in_min_chans = 1;\n\t}\n\n\tdev_info(&pci_dev->dev, \"Has dma:%d, grouping:%d, mrx:%d, uif:%d\\n\",\n\t\t\tasihpi->can_dma,\n\t\t\tasihpi->support_grouping,\n\t\t\tasihpi->support_mrx,\n\t\t\tasihpi->update_interval_frames\n\t      );\n\n\terr = snd_card_asihpi_pcm_new(asihpi, 0);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev, \"pcm_new failed\\n\");\n\t\tgoto __nodev;\n\t}\n\terr = snd_card_asihpi_mixer_new(asihpi);\n\tif (err < 0) {\n\t\tdev_err(&pci_dev->dev, \"mixer_new failed\\n\");\n\t\tgoto __nodev;\n\t}\n\n\terr = hpi_mixer_get_control(asihpi->h_mixer,\n\t\t\t\t  HPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\n\t\t\t\t  HPI_CONTROL_SAMPLECLOCK, &h_control);\n\n\tif (!err)\n\t\terr = hpi_sample_clock_set_local_rate(\n\t\t\th_control, adapter_fs);\n\n\tsnd_asihpi_proc_init(asihpi);\n\n\t \n\tsnd_asihpi_hpi_new(asihpi, 0);\n\n\tstrcpy(card->driver, \"ASIHPI\");\n\n\tsprintf(card->shortname, \"AudioScience ASI%4X\",\n\t\t\tasihpi->hpi->adapter->type);\n\tsprintf(card->longname, \"%s %i\",\n\t\t\tcard->shortname, adapter_index);\n\terr = snd_card_register(card);\n\n\tif (!err) {\n\t\tdev++;\n\t\treturn 0;\n\t}\n__nodev:\n\tsnd_card_free(card);\n\tdev_err(&pci_dev->dev, \"snd_asihpi_probe error %d\\n\", err);\n\treturn err;\n\n}\n\nstatic void snd_asihpi_remove(struct pci_dev *pci_dev)\n{\n\tstruct hpi_adapter *hpi = pci_get_drvdata(pci_dev);\n\n\t \n\tif (hpi->interrupt_mode) {\n\t\thpi->interrupt_callback = NULL;\n\t\thpi_handle_error(hpi_adapter_set_property(hpi->adapter->index,\n\t\t\tHPI_ADAPTER_PROPERTY_IRQ_RATE, 0, 0));\n\t}\n\n\tsnd_card_free(hpi->snd_card);\n\thpi->snd_card = NULL;\n\tasihpi_adapter_remove(pci_dev);\n}\n\nstatic const struct pci_device_id asihpi_pci_tbl[] = {\n\t{HPI_PCI_VENDOR_ID_TI, HPI_PCI_DEV_ID_DSP6205,\n\t\tHPI_PCI_VENDOR_ID_AUDIOSCIENCE, PCI_ANY_ID, 0, 0,\n\t\t(kernel_ulong_t)HPI_6205},\n\t{HPI_PCI_VENDOR_ID_TI, HPI_PCI_DEV_ID_PCI2040,\n\t\tHPI_PCI_VENDOR_ID_AUDIOSCIENCE, PCI_ANY_ID, 0, 0,\n\t\t(kernel_ulong_t)HPI_6000},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, asihpi_pci_tbl);\n\nstatic struct pci_driver driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = asihpi_pci_tbl,\n\t.probe = snd_asihpi_probe,\n\t.remove = snd_asihpi_remove,\n};\n\nstatic int __init snd_asihpi_init(void)\n{\n\tasihpi_init();\n\treturn pci_register_driver(&driver);\n}\n\nstatic void __exit snd_asihpi_exit(void)\n{\n\n\tpci_unregister_driver(&driver);\n\tasihpi_exit();\n}\n\nmodule_init(snd_asihpi_init)\nmodule_exit(snd_asihpi_exit)\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}