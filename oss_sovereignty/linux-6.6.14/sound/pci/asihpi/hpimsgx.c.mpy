{
  "module_name": "hpimsgx.c",
  "hash_id": "15ab369566a4416870b9acfe6c3255627553a5efe732a4ccd63c07fb62718405",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpimsgx.c",
  "human_readable_source": "\n \n#define SOURCEFILE_NAME \"hpimsgx.c\"\n#include \"hpi_internal.h\"\n#include \"hpi_version.h\"\n#include \"hpimsginit.h\"\n#include \"hpicmn.h\"\n#include \"hpimsgx.h\"\n#include \"hpidebug.h\"\n\nstatic const struct pci_device_id asihpi_pci_tbl[] = {\n#include \"hpipcida.h\"\n};\n\nstatic struct hpios_spinlock msgx_lock;\n\nstatic hpi_handler_func *hpi_entry_points[HPI_MAX_ADAPTERS];\nstatic int logging_enabled = 1;\n\nstatic hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci\n\t*pci_info)\n{\n\n\tint i;\n\n\tfor (i = 0; asihpi_pci_tbl[i].vendor != 0; i++) {\n\t\tif (asihpi_pci_tbl[i].vendor != PCI_ANY_ID\n\t\t\t&& asihpi_pci_tbl[i].vendor !=\n\t\t\tpci_info->pci_dev->vendor)\n\t\t\tcontinue;\n\t\tif (asihpi_pci_tbl[i].device != PCI_ANY_ID\n\t\t\t&& asihpi_pci_tbl[i].device !=\n\t\t\tpci_info->pci_dev->device)\n\t\t\tcontinue;\n\t\tif (asihpi_pci_tbl[i].subvendor != PCI_ANY_ID\n\t\t\t&& asihpi_pci_tbl[i].subvendor !=\n\t\t\tpci_info->pci_dev->subsystem_vendor)\n\t\t\tcontinue;\n\t\tif (asihpi_pci_tbl[i].subdevice != PCI_ANY_ID\n\t\t\t&& asihpi_pci_tbl[i].subdevice !=\n\t\t\tpci_info->pci_dev->subsystem_device)\n\t\t\tcontinue;\n\n\t\t \n\t\treturn (hpi_handler_func *) asihpi_pci_tbl[i].driver_data;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void hw_entry_point(struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\tif ((phm->adapter_index < HPI_MAX_ADAPTERS)\n\t\t&& hpi_entry_points[phm->adapter_index])\n\t\thpi_entry_points[phm->adapter_index] (phm, phr);\n\telse\n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_PROCESSING_MESSAGE);\n}\n\nstatic void adapter_open(struct hpi_message *phm, struct hpi_response *phr);\nstatic void adapter_close(struct hpi_message *phm, struct hpi_response *phr);\n\nstatic void mixer_open(struct hpi_message *phm, struct hpi_response *phr);\nstatic void mixer_close(struct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_open(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner);\nstatic void outstream_close(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner);\nstatic void instream_open(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner);\nstatic void instream_close(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner);\n\nstatic void HPIMSGX__reset(u16 adapter_index);\n\nstatic u16 HPIMSGX__init(struct hpi_message *phm, struct hpi_response *phr);\nstatic void HPIMSGX__cleanup(u16 adapter_index, void *h_owner);\n\n#ifndef DISABLE_PRAGMA_PACK1\n#pragma pack(push, 1)\n#endif\n\nstruct hpi_adapter_response {\n\tstruct hpi_response_header h;\n\tstruct hpi_adapter_res a;\n};\n\nstruct hpi_mixer_response {\n\tstruct hpi_response_header h;\n\tstruct hpi_mixer_res m;\n};\n\nstruct hpi_stream_response {\n\tstruct hpi_response_header h;\n\tstruct hpi_stream_res d;\n};\n\nstruct adapter_info {\n\tu16 type;\n\tu16 num_instreams;\n\tu16 num_outstreams;\n};\n\nstruct asi_open_state {\n\tint open_flag;\n\tvoid *h_owner;\n};\n\n#ifndef DISABLE_PRAGMA_PACK1\n#pragma pack(pop)\n#endif\n\n \nstatic struct hpi_adapter_response rESP_HPI_ADAPTER_OPEN[HPI_MAX_ADAPTERS];\n\nstatic struct hpi_stream_response\n\trESP_HPI_OSTREAM_OPEN[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];\n\nstatic struct hpi_stream_response\n\trESP_HPI_ISTREAM_OPEN[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];\n\nstatic struct hpi_mixer_response rESP_HPI_MIXER_OPEN[HPI_MAX_ADAPTERS];\n\nstatic struct adapter_info aDAPTER_INFO[HPI_MAX_ADAPTERS];\n\n \nstatic struct asi_open_state\n\toutstream_user_open[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];\n\nstatic struct asi_open_state\n\tinstream_user_open[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];\n\nstatic void subsys_message(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\tif (phm->adapter_index != HPI_ADAPTER_INDEX_INVALID)\n\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\"suspicious adapter index %d in subsys message 0x%x.\\n\",\n\t\t\tphm->adapter_index, phm->function);\n\n\tswitch (phm->function) {\n\tcase HPI_SUBSYS_GET_VERSION:\n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\n\t\t\tHPI_SUBSYS_GET_VERSION, 0);\n\t\tphr->u.s.version = HPI_VER >> 8;\t \n\t\tphr->u.s.data = HPI_VER;\t \n\t\tbreak;\n\tcase HPI_SUBSYS_OPEN:\n\t\t \n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_OPEN, 0);\n\t\tbreak;\n\tcase HPI_SUBSYS_CLOSE:\n\t\t \n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CLOSE,\n\t\t\t0);\n\t\tHPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);\n\t\tbreak;\n\tcase HPI_SUBSYS_DRIVER_LOAD:\n\t\t \n\t\thpios_msgxlock_init(&msgx_lock);\n\t\tmemset(&hpi_entry_points, 0, sizeof(hpi_entry_points));\n\t\t \n\t\tHPIMSGX__reset(HPIMSGX_ALLADAPTERS);\n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\n\t\t\tHPI_SUBSYS_DRIVER_LOAD, 0);\n\t\t \n\t\tHPI_COMMON(phm, phr);\n\t\tbreak;\n\tcase HPI_SUBSYS_DRIVER_UNLOAD:\n\t\tHPI_COMMON(phm, phr);\n\t\tHPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);\n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\n\t\t\tHPI_SUBSYS_DRIVER_UNLOAD, 0);\n\t\treturn;\n\n\tcase HPI_SUBSYS_GET_NUM_ADAPTERS:\n\tcase HPI_SUBSYS_GET_ADAPTER:\n\t\tHPI_COMMON(phm, phr);\n\t\tbreak;\n\n\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tHPIMSGX__init(phm, phr);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\thpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function,\n\t\t\tHPI_ERROR_INVALID_FUNC);\n\t\tbreak;\n\t}\n}\n\nstatic void adapter_message(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\tswitch (phm->function) {\n\tcase HPI_ADAPTER_OPEN:\n\t\tadapter_open(phm, phr);\n\t\tbreak;\n\tcase HPI_ADAPTER_CLOSE:\n\t\tadapter_close(phm, phr);\n\t\tbreak;\n\tcase HPI_ADAPTER_DELETE:\n\t\tHPIMSGX__cleanup(phm->adapter_index, h_owner);\n\t\t{\n\t\t\tstruct hpi_message hm;\n\t\t\tstruct hpi_response hr;\n\t\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\t\t\tHPI_ADAPTER_CLOSE);\n\t\t\thm.adapter_index = phm->adapter_index;\n\t\t\thw_entry_point(&hm, &hr);\n\t\t}\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\n\tdefault:\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void mixer_message(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_MIXER_OPEN:\n\t\tmixer_open(phm, phr);\n\t\tbreak;\n\tcase HPI_MIXER_CLOSE:\n\t\tmixer_close(phm, phr);\n\t\tbreak;\n\tdefault:\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void outstream_message(struct hpi_message *phm,\n\tstruct hpi_response *phr, void *h_owner)\n{\n\tif (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_outstreams) {\n\t\thpi_init_response(phr, HPI_OBJ_OSTREAM, phm->function,\n\t\t\tHPI_ERROR_INVALID_OBJ_INDEX);\n\t\treturn;\n\t}\n\n\tswitch (phm->function) {\n\tcase HPI_OSTREAM_OPEN:\n\t\toutstream_open(phm, phr, h_owner);\n\t\tbreak;\n\tcase HPI_OSTREAM_CLOSE:\n\t\toutstream_close(phm, phr, h_owner);\n\t\tbreak;\n\tdefault:\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void instream_message(struct hpi_message *phm,\n\tstruct hpi_response *phr, void *h_owner)\n{\n\tif (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_instreams) {\n\t\thpi_init_response(phr, HPI_OBJ_ISTREAM, phm->function,\n\t\t\tHPI_ERROR_INVALID_OBJ_INDEX);\n\t\treturn;\n\t}\n\n\tswitch (phm->function) {\n\tcase HPI_ISTREAM_OPEN:\n\t\tinstream_open(phm, phr, h_owner);\n\t\tbreak;\n\tcase HPI_ISTREAM_CLOSE:\n\t\tinstream_close(phm, phr, h_owner);\n\t\tbreak;\n\tdefault:\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\t}\n}\n\n \nvoid hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\n\tif (logging_enabled)\n\t\tHPI_DEBUG_MESSAGE(DEBUG, phm);\n\n\tif (phm->type != HPI_TYPE_REQUEST) {\n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_INVALID_TYPE);\n\t\treturn;\n\t}\n\n\tif (phm->adapter_index >= HPI_MAX_ADAPTERS\n\t\t&& phm->adapter_index != HPIMSGX_ALLADAPTERS) {\n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_BAD_ADAPTER_NUMBER);\n\t\treturn;\n\t}\n\n\tswitch (phm->object) {\n\tcase HPI_OBJ_SUBSYSTEM:\n\t\tsubsys_message(phm, phr, h_owner);\n\t\tbreak;\n\n\tcase HPI_OBJ_ADAPTER:\n\t\tadapter_message(phm, phr, h_owner);\n\t\tbreak;\n\n\tcase HPI_OBJ_MIXER:\n\t\tmixer_message(phm, phr);\n\t\tbreak;\n\n\tcase HPI_OBJ_OSTREAM:\n\t\toutstream_message(phm, phr, h_owner);\n\t\tbreak;\n\n\tcase HPI_OBJ_ISTREAM:\n\t\tinstream_message(phm, phr, h_owner);\n\t\tbreak;\n\n\tdefault:\n\t\thw_entry_point(phm, phr);\n\t\tbreak;\n\t}\n\n\tif (logging_enabled)\n\t\tHPI_DEBUG_RESPONSE(phr);\n\n\tif (phr->error >= HPI_ERROR_DSP_COMMUNICATION) {\n\t\thpi_debug_level_set(HPI_DEBUG_LEVEL_ERROR);\n\t\tlogging_enabled = 0;\n\t}\n}\n\nstatic void adapter_open(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tHPI_DEBUG_LOG(VERBOSE, \"adapter_open\\n\");\n\tmemcpy(phr, &rESP_HPI_ADAPTER_OPEN[phm->adapter_index],\n\t\tsizeof(rESP_HPI_ADAPTER_OPEN[0]));\n}\n\nstatic void adapter_close(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tHPI_DEBUG_LOG(VERBOSE, \"adapter_close\\n\");\n\thpi_init_response(phr, HPI_OBJ_ADAPTER, HPI_ADAPTER_CLOSE, 0);\n}\n\nstatic void mixer_open(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tmemcpy(phr, &rESP_HPI_MIXER_OPEN[phm->adapter_index],\n\t\tsizeof(rESP_HPI_MIXER_OPEN[0]));\n}\n\nstatic void mixer_close(struct hpi_message *phm, struct hpi_response *phr)\n{\n\thpi_init_response(phr, HPI_OBJ_MIXER, HPI_MIXER_CLOSE, 0);\n}\n\nstatic void instream_open(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_OPEN, 0);\n\n\thpios_msgxlock_lock(&msgx_lock);\n\n\tif (instream_user_open[phm->adapter_index][phm->obj_index].open_flag)\n\t\tphr->error = HPI_ERROR_OBJ_ALREADY_OPEN;\n\telse if (rESP_HPI_ISTREAM_OPEN[phm->adapter_index]\n\t\t[phm->obj_index].h.error)\n\t\tmemcpy(phr,\n\t\t\t&rESP_HPI_ISTREAM_OPEN[phm->adapter_index][phm->\n\t\t\t\tobj_index],\n\t\t\tsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\n\telse {\n\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].open_flag = 1;\n\t\thpios_msgxlock_unlock(&msgx_lock);\n\n\t\t \n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_RESET);\n\t\thm.adapter_index = phm->adapter_index;\n\t\thm.obj_index = phm->obj_index;\n\t\thw_entry_point(&hm, &hr);\n\n\t\thpios_msgxlock_lock(&msgx_lock);\n\t\tif (hr.error) {\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 0;\n\t\t\tphr->error = hr.error;\n\t\t} else {\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 1;\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = h_owner;\n\t\t\tmemcpy(phr,\n\t\t\t\t&rESP_HPI_ISTREAM_OPEN[phm->adapter_index]\n\t\t\t\t[phm->obj_index],\n\t\t\t\tsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\n\t\t}\n\t}\n\thpios_msgxlock_unlock(&msgx_lock);\n}\n\nstatic void instream_close(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_CLOSE, 0);\n\n\thpios_msgxlock_lock(&msgx_lock);\n\tif (h_owner ==\n\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].h_owner) {\n\t\t \n\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].h_owner = NULL;\n\t\thpios_msgxlock_unlock(&msgx_lock);\n\t\t \n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_RESET);\n\t\thm.adapter_index = phm->adapter_index;\n\t\thm.obj_index = phm->obj_index;\n\t\thw_entry_point(&hm, &hr);\n\t\thpios_msgxlock_lock(&msgx_lock);\n\t\tif (hr.error) {\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = h_owner;\n\t\t\tphr->error = hr.error;\n\t\t} else {\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 0;\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = NULL;\n\t\t}\n\t} else {\n\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\"%p trying to close %d instream %d owned by %p\\n\",\n\t\t\th_owner, phm->adapter_index, phm->obj_index,\n\t\t\tinstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner);\n\t\tphr->error = HPI_ERROR_OBJ_NOT_OPEN;\n\t}\n\thpios_msgxlock_unlock(&msgx_lock);\n}\n\nstatic void outstream_open(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_OPEN, 0);\n\n\thpios_msgxlock_lock(&msgx_lock);\n\n\tif (outstream_user_open[phm->adapter_index][phm->obj_index].open_flag)\n\t\tphr->error = HPI_ERROR_OBJ_ALREADY_OPEN;\n\telse if (rESP_HPI_OSTREAM_OPEN[phm->adapter_index]\n\t\t[phm->obj_index].h.error)\n\t\tmemcpy(phr,\n\t\t\t&rESP_HPI_OSTREAM_OPEN[phm->adapter_index][phm->\n\t\t\t\tobj_index],\n\t\t\tsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\n\telse {\n\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].open_flag = 1;\n\t\thpios_msgxlock_unlock(&msgx_lock);\n\n\t\t \n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_RESET);\n\t\thm.adapter_index = phm->adapter_index;\n\t\thm.obj_index = phm->obj_index;\n\t\thw_entry_point(&hm, &hr);\n\n\t\thpios_msgxlock_lock(&msgx_lock);\n\t\tif (hr.error) {\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 0;\n\t\t\tphr->error = hr.error;\n\t\t} else {\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 1;\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = h_owner;\n\t\t\tmemcpy(phr,\n\t\t\t\t&rESP_HPI_OSTREAM_OPEN[phm->adapter_index]\n\t\t\t\t[phm->obj_index],\n\t\t\t\tsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\n\t\t}\n\t}\n\thpios_msgxlock_unlock(&msgx_lock);\n}\n\nstatic void outstream_close(struct hpi_message *phm, struct hpi_response *phr,\n\tvoid *h_owner)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_CLOSE, 0);\n\n\thpios_msgxlock_lock(&msgx_lock);\n\n\tif (h_owner ==\n\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].h_owner) {\n\t\t \n\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\tobj_index].h_owner = NULL;\n\t\thpios_msgxlock_unlock(&msgx_lock);\n\t\t \n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_RESET);\n\t\thm.adapter_index = phm->adapter_index;\n\t\thm.obj_index = phm->obj_index;\n\t\thw_entry_point(&hm, &hr);\n\t\thpios_msgxlock_lock(&msgx_lock);\n\t\tif (hr.error) {\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = h_owner;\n\t\t\tphr->error = hr.error;\n\t\t} else {\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].open_flag = 0;\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner = NULL;\n\t\t}\n\t} else {\n\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\"%p trying to close %d outstream %d owned by %p\\n\",\n\t\t\th_owner, phm->adapter_index, phm->obj_index,\n\t\t\toutstream_user_open[phm->adapter_index][phm->\n\t\t\t\tobj_index].h_owner);\n\t\tphr->error = HPI_ERROR_OBJ_NOT_OPEN;\n\t}\n\thpios_msgxlock_unlock(&msgx_lock);\n}\n\nstatic u16 adapter_prepare(u16 adapter)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\t \n\tu16 i;\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_OPEN);\n\thm.adapter_index = adapter;\n\thw_entry_point(&hm, &hr);\n\tmemcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,\n\t\tsizeof(rESP_HPI_ADAPTER_OPEN[0]));\n\tif (hr.error)\n\t\treturn hr.error;\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_INFO);\n\thm.adapter_index = adapter;\n\thw_entry_point(&hm, &hr);\n\tif (hr.error)\n\t\treturn hr.error;\n\n\taDAPTER_INFO[adapter].num_outstreams = hr.u.ax.info.num_outstreams;\n\taDAPTER_INFO[adapter].num_instreams = hr.u.ax.info.num_instreams;\n\taDAPTER_INFO[adapter].type = hr.u.ax.info.adapter_type;\n\n\t \n\tfor (i = 0; i < aDAPTER_INFO[adapter].num_outstreams; i++) {\n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_OPEN);\n\t\thm.adapter_index = adapter;\n\t\thm.obj_index = i;\n\t\thw_entry_point(&hm, &hr);\n\t\tmemcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i], &hr,\n\t\t\tsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\n\t\toutstream_user_open[adapter][i].open_flag = 0;\n\t\toutstream_user_open[adapter][i].h_owner = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < aDAPTER_INFO[adapter].num_instreams; i++) {\n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_OPEN);\n\t\thm.adapter_index = adapter;\n\t\thm.obj_index = i;\n\t\thw_entry_point(&hm, &hr);\n\t\tmemcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i], &hr,\n\t\t\tsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\n\t\tinstream_user_open[adapter][i].open_flag = 0;\n\t\tinstream_user_open[adapter][i].h_owner = NULL;\n\t}\n\n\t \n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN);\n\thm.adapter_index = adapter;\n\thw_entry_point(&hm, &hr);\n\tmemcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,\n\t\tsizeof(rESP_HPI_MIXER_OPEN[0]));\n\n\treturn 0;\n}\n\nstatic void HPIMSGX__reset(u16 adapter_index)\n{\n\tint i;\n\tu16 adapter;\n\tstruct hpi_response hr;\n\n\tif (adapter_index == HPIMSGX_ALLADAPTERS) {\n\t\tfor (adapter = 0; adapter < HPI_MAX_ADAPTERS; adapter++) {\n\n\t\t\thpi_init_response(&hr, HPI_OBJ_ADAPTER,\n\t\t\t\tHPI_ADAPTER_OPEN, HPI_ERROR_BAD_ADAPTER);\n\t\t\tmemcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,\n\t\t\t\tsizeof(rESP_HPI_ADAPTER_OPEN[adapter]));\n\n\t\t\thpi_init_response(&hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN,\n\t\t\t\tHPI_ERROR_INVALID_OBJ);\n\t\t\tmemcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,\n\t\t\t\tsizeof(rESP_HPI_MIXER_OPEN[adapter]));\n\n\t\t\tfor (i = 0; i < HPI_MAX_STREAMS; i++) {\n\t\t\t\thpi_init_response(&hr, HPI_OBJ_OSTREAM,\n\t\t\t\t\tHPI_OSTREAM_OPEN,\n\t\t\t\t\tHPI_ERROR_INVALID_OBJ);\n\t\t\t\tmemcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i],\n\t\t\t\t\t&hr,\n\t\t\t\t\tsizeof(rESP_HPI_OSTREAM_OPEN[adapter]\n\t\t\t\t\t\t[i]));\n\t\t\t\thpi_init_response(&hr, HPI_OBJ_ISTREAM,\n\t\t\t\t\tHPI_ISTREAM_OPEN,\n\t\t\t\t\tHPI_ERROR_INVALID_OBJ);\n\t\t\t\tmemcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i],\n\t\t\t\t\t&hr,\n\t\t\t\t\tsizeof(rESP_HPI_ISTREAM_OPEN[adapter]\n\t\t\t\t\t\t[i]));\n\t\t\t}\n\t\t}\n\t} else if (adapter_index < HPI_MAX_ADAPTERS) {\n\t\trESP_HPI_ADAPTER_OPEN[adapter_index].h.error =\n\t\t\tHPI_ERROR_BAD_ADAPTER;\n\t\trESP_HPI_MIXER_OPEN[adapter_index].h.error =\n\t\t\tHPI_ERROR_INVALID_OBJ;\n\t\tfor (i = 0; i < HPI_MAX_STREAMS; i++) {\n\t\t\trESP_HPI_OSTREAM_OPEN[adapter_index][i].h.error =\n\t\t\t\tHPI_ERROR_INVALID_OBJ;\n\t\t\trESP_HPI_ISTREAM_OPEN[adapter_index][i].h.error =\n\t\t\t\tHPI_ERROR_INVALID_OBJ;\n\t\t}\n\t}\n}\n\nstatic u16 HPIMSGX__init(struct hpi_message *phm,\n\t \n\t \n\tstruct hpi_response *phr\n\t \n\t)\n{\n\thpi_handler_func *entry_point_func;\n\tstruct hpi_response hr;\n\n\t \n\thpi_init_response(&hr, phm->object, phm->function,\n\t\tHPI_ERROR_INVALID_OBJ);\n\n\tentry_point_func =\n\t\thpi_lookup_entry_point_function(phm->u.s.resource.r.pci);\n\n\tif (entry_point_func) {\n\t\tHPI_DEBUG_MESSAGE(DEBUG, phm);\n\t\tentry_point_func(phm, &hr);\n\t} else {\n\t\tphr->error = HPI_ERROR_PROCESSING_MESSAGE;\n\t\treturn phr->error;\n\t}\n\tif (hr.error == 0) {\n\t\t \n\t\thpi_entry_points[hr.u.s.adapter_index] = entry_point_func;\n\t\t \n\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\"HPI_SUBSYS_CREATE_ADAPTER successful,\"\n\t\t\t\" preparing adapter\\n\");\n\t\tadapter_prepare(hr.u.s.adapter_index);\n\t}\n\tmemcpy(phr, &hr, hr.size);\n\treturn phr->error;\n}\n\nstatic void HPIMSGX__cleanup(u16 adapter_index, void *h_owner)\n{\n\tint i, adapter, adapter_limit;\n\n\tif (!h_owner)\n\t\treturn;\n\n\tif (adapter_index == HPIMSGX_ALLADAPTERS) {\n\t\tadapter = 0;\n\t\tadapter_limit = HPI_MAX_ADAPTERS;\n\t} else {\n\t\tadapter = adapter_index;\n\t\tadapter_limit = adapter + 1;\n\t}\n\n\tfor (; adapter < adapter_limit; adapter++) {\n\t\t \n\t\tfor (i = 0; i < HPI_MAX_STREAMS; i++) {\n\t\t\tif (h_owner ==\n\t\t\t\toutstream_user_open[adapter][i].h_owner) {\n\t\t\t\tstruct hpi_message hm;\n\t\t\t\tstruct hpi_response hr;\n\n\t\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\t\"Close adapter %d ostream %d\\n\",\n\t\t\t\t\tadapter, i);\n\n\t\t\t\thpi_init_message_response(&hm, &hr,\n\t\t\t\t\tHPI_OBJ_OSTREAM, HPI_OSTREAM_RESET);\n\t\t\t\thm.adapter_index = (u16)adapter;\n\t\t\t\thm.obj_index = (u16)i;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\thm.function = HPI_OSTREAM_HOSTBUFFER_FREE;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\thm.function = HPI_OSTREAM_GROUP_RESET;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\toutstream_user_open[adapter][i].open_flag = 0;\n\t\t\t\toutstream_user_open[adapter][i].h_owner =\n\t\t\t\t\tNULL;\n\t\t\t}\n\t\t\tif (h_owner == instream_user_open[adapter][i].h_owner) {\n\t\t\t\tstruct hpi_message hm;\n\t\t\t\tstruct hpi_response hr;\n\n\t\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\t\"Close adapter %d istream %d\\n\",\n\t\t\t\t\tadapter, i);\n\n\t\t\t\thpi_init_message_response(&hm, &hr,\n\t\t\t\t\tHPI_OBJ_ISTREAM, HPI_ISTREAM_RESET);\n\t\t\t\thm.adapter_index = (u16)adapter;\n\t\t\t\thm.obj_index = (u16)i;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\thm.function = HPI_ISTREAM_HOSTBUFFER_FREE;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\thm.function = HPI_ISTREAM_GROUP_RESET;\n\t\t\t\thw_entry_point(&hm, &hr);\n\n\t\t\t\tinstream_user_open[adapter][i].open_flag = 0;\n\t\t\t\tinstream_user_open[adapter][i].h_owner = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}