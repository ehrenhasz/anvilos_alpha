{
  "module_name": "hpios.h",
  "hash_id": "981eb6fe5fee73fee3ebfa910138c7cd65964b66d8c6ed4672271dad1f1125f8",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpios.h",
  "human_readable_source": " \n \n#ifndef _HPIOS_H_\n#define _HPIOS_H_\n\n#undef HPI_OS_LINUX_KERNEL\n#define HPI_OS_LINUX_KERNEL\n\n#define HPI_OS_DEFINED\n#define HPI_BUILD_KERNEL_MODE\n\n#include <linux/io.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n\n#define HPI_NO_OS_FILE_OPS\n\n \nstruct consistent_dma_area {\n\tstruct device *pdev;\n\t \n\tsize_t size;\n\tvoid *vaddr;\n\tdma_addr_t dma_handle;\n};\n\nstatic inline u16 hpios_locked_mem_get_phys_addr(struct consistent_dma_area\n\t*locked_mem_handle, u32 *p_physical_addr)\n{\n\t*p_physical_addr = locked_mem_handle->dma_handle;\n\treturn 0;\n}\n\nstatic inline u16 hpios_locked_mem_get_virt_addr(struct consistent_dma_area\n\t*locked_mem_handle, void **pp_virtual_addr)\n{\n\t*pp_virtual_addr = locked_mem_handle->vaddr;\n\treturn 0;\n}\n\nstatic inline u16 hpios_locked_mem_valid(struct consistent_dma_area\n\t*locked_mem_handle)\n{\n\treturn locked_mem_handle->size != 0;\n}\n\nstruct hpi_ioctl_linux {\n\tvoid __user *phm;\n\tvoid __user *phr;\n};\n\n \n#define HPI_IOCTL_LINUX _IOWR('H', 0xFC, struct hpi_ioctl_linux)\n\n#define HPI_DEBUG_FLAG_ERROR   KERN_ERR\n#define HPI_DEBUG_FLAG_WARNING KERN_WARNING\n#define HPI_DEBUG_FLAG_NOTICE  KERN_NOTICE\n#define HPI_DEBUG_FLAG_INFO    KERN_INFO\n#define HPI_DEBUG_FLAG_DEBUG   KERN_DEBUG\n#define HPI_DEBUG_FLAG_VERBOSE KERN_DEBUG\t \n\n#include <linux/spinlock.h>\n\n#define HPI_LOCKING\n\nstruct hpios_spinlock {\n\tspinlock_t lock;\t \n\tint lock_context;\n};\n\n \n#define IN_LOCK_BH 1\n#define IN_LOCK_IRQ 0\nstatic inline void cond_lock(struct hpios_spinlock *l)\n{\n\tif (irqs_disabled()) {\n\t\t \n\t\tspin_lock(&((l)->lock));\n\t\tl->lock_context = IN_LOCK_IRQ;\n\t} else {\n\t\tspin_lock_bh(&((l)->lock));\n\t\tl->lock_context = IN_LOCK_BH;\n\t}\n}\n\nstatic inline void cond_unlock(struct hpios_spinlock *l)\n{\n\tif (l->lock_context == IN_LOCK_BH)\n\t\tspin_unlock_bh(&((l)->lock));\n\telse\n\t\tspin_unlock(&((l)->lock));\n}\n\n#define hpios_msgxlock_init(obj)      spin_lock_init(&(obj)->lock)\n#define hpios_msgxlock_lock(obj)   cond_lock(obj)\n#define hpios_msgxlock_unlock(obj) cond_unlock(obj)\n\n#define hpios_dsplock_init(obj)       spin_lock_init(&(obj)->dsp_lock.lock)\n#define hpios_dsplock_lock(obj)    cond_lock(&(obj)->dsp_lock)\n#define hpios_dsplock_unlock(obj)  cond_unlock(&(obj)->dsp_lock)\n\n#ifdef CONFIG_SND_DEBUG\n#define HPI_BUILD_DEBUG\n#endif\n\n#define HPI_ALIST_LOCKING\n#define hpios_alistlock_init(obj)    spin_lock_init(&((obj)->list_lock.lock))\n#define hpios_alistlock_lock(obj) spin_lock(&((obj)->list_lock.lock))\n#define hpios_alistlock_unlock(obj) spin_unlock(&((obj)->list_lock.lock))\n\nstruct snd_card;\n\n \nstruct hpi_adapter {\n\tstruct hpi_adapter_obj *adapter;\n\tstruct snd_card *snd_card;\n\n\tint irq;\n\tint interrupt_mode;\n\tvoid (*interrupt_callback) (struct hpi_adapter *);\n\n\t \n\tstruct mutex mutex;\n\tchar *p_buffer;\n\tsize_t buffer_size;\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}