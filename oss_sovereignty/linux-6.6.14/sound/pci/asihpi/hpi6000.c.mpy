{
  "module_name": "hpi6000.c",
  "hash_id": "32825018545e184bcb394097a35561f107aaada6955c9d779cb6b5a379769a61",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpi6000.c",
  "human_readable_source": "\n \n#define SOURCEFILE_NAME \"hpi6000.c\"\n\n#include \"hpi_internal.h\"\n#include \"hpimsginit.h\"\n#include \"hpidebug.h\"\n#include \"hpi6000.h\"\n#include \"hpidspcd.h\"\n#include \"hpicmn.h\"\n\n#define HPI_HIF_BASE (0x00000200)\t \n#define HPI_HIF_ADDR(member) \\\n\t(HPI_HIF_BASE + offsetof(struct hpi_hif_6000, member))\n#define HPI_HIF_ERROR_MASK      0x4000\n\n \n#define HPI6000_ERROR_BASE 900\t \n\n \n#define HPI6000_ERROR_MSG_RESP_IDLE_TIMEOUT             901\n#define HPI6000_ERROR_RESP_GET_LEN                      902\n#define HPI6000_ERROR_MSG_RESP_GET_RESP_ACK             903\n#define HPI6000_ERROR_MSG_GET_ADR                       904\n#define HPI6000_ERROR_RESP_GET_ADR                      905\n#define HPI6000_ERROR_MSG_RESP_BLOCKWRITE32             906\n#define HPI6000_ERROR_MSG_RESP_BLOCKREAD32              907\n\n#define HPI6000_ERROR_CONTROL_CACHE_PARAMS              909\n\n#define HPI6000_ERROR_SEND_DATA_IDLE_TIMEOUT            911\n#define HPI6000_ERROR_SEND_DATA_ACK                     912\n#define HPI6000_ERROR_SEND_DATA_ADR                     913\n#define HPI6000_ERROR_SEND_DATA_TIMEOUT                 914\n#define HPI6000_ERROR_SEND_DATA_CMD                     915\n#define HPI6000_ERROR_SEND_DATA_WRITE                   916\n#define HPI6000_ERROR_SEND_DATA_IDLECMD                 917\n\n#define HPI6000_ERROR_GET_DATA_IDLE_TIMEOUT             921\n#define HPI6000_ERROR_GET_DATA_ACK                      922\n#define HPI6000_ERROR_GET_DATA_CMD                      923\n#define HPI6000_ERROR_GET_DATA_READ                     924\n#define HPI6000_ERROR_GET_DATA_IDLECMD                  925\n\n#define HPI6000_ERROR_CONTROL_CACHE_ADDRLEN             951\n#define HPI6000_ERROR_CONTROL_CACHE_READ                952\n#define HPI6000_ERROR_CONTROL_CACHE_FLUSH               953\n\n#define HPI6000_ERROR_MSG_RESP_GETRESPCMD               961\n#define HPI6000_ERROR_MSG_RESP_IDLECMD                  962\n\n \n#define HPI6000_ERROR_UNHANDLED_SUBSYS_ID               930\n\n \n#define HPI6000_ERROR_INIT_PCI2040                      931\n \n#define HPI6000_ERROR_INIT_DSPHPI                       932\n \n#define HPI6000_ERROR_INIT_DSPINTMEM                    933\n \n#define HPI6000_ERROR_INIT_SDRAM1                       934\n \n#define HPI6000_ERROR_INIT_SDRAM2                       935\n\n#define HPI6000_ERROR_INIT_VERIFY                       938\n\n#define HPI6000_ERROR_INIT_NOACK                        939\n\n#define HPI6000_ERROR_INIT_PLDTEST1                     941\n#define HPI6000_ERROR_INIT_PLDTEST2                     942\n\n \n\n#define HIDE_PCI_ASSERTS\n#define PROFILE_DSP2\n\n \n \n \n \n\n#define INTERRUPT_EVENT_SET     0\n#define INTERRUPT_EVENT_CLEAR   1\n#define INTERRUPT_MASK_SET      2\n#define INTERRUPT_MASK_CLEAR    3\n#define HPI_ERROR_REPORT        4\n#define HPI_RESET               5\n#define HPI_DATA_WIDTH          6\n\n#define MAX_DSPS 2\n \n#define DSP_SPACING             0x800\n\n#define CONTROL                 0x0000\n#define ADDRESS                 0x0200\n#define DATA_AUTOINC            0x0400\n#define DATA                    0x0600\n\n#define TIMEOUT 500000\n\nstruct dsp_obj {\n\t__iomem u32 *prHPI_control;\n\t__iomem u32 *prHPI_address;\n\t__iomem u32 *prHPI_data;\n\t__iomem u32 *prHPI_data_auto_inc;\n\tchar c_dsp_rev;\t\t \n\tu32 control_cache_address_on_dsp;\n\tu32 control_cache_length_on_dsp;\n\tstruct hpi_adapter_obj *pa_parent_adapter;\n};\n\nstruct hpi_hw_obj {\n\t__iomem u32 *dw2040_HPICSR;\n\t__iomem u32 *dw2040_HPIDSP;\n\n\tu16 num_dsp;\n\tstruct dsp_obj ado[MAX_DSPS];\n\n\tu32 message_buffer_address_on_dsp;\n\tu32 response_buffer_address_on_dsp;\n\tu32 pCI2040HPI_error_count;\n\n\tstruct hpi_control_cache_single control_cache[HPI_NMIXER_CONTROLS];\n\tstruct hpi_control_cache *p_cache;\n};\n\nstatic u16 hpi6000_dsp_block_write32(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 hpi_address, u32 *source, u32 count);\nstatic u16 hpi6000_dsp_block_read32(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 hpi_address, u32 *dest, u32 count);\n\nstatic short hpi6000_adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code);\nstatic short hpi6000_check_PCI2040_error_flag(struct hpi_adapter_obj *pao,\n\tu16 read_or_write);\n#define H6READ 1\n#define H6WRITE 0\n\nstatic short hpi6000_update_control_cache(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm);\nstatic short hpi6000_message_response_sequence(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, struct hpi_message *phm, struct hpi_response *phr);\n\nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\n\tstruct hpi_response *phr);\n\nstatic short hpi6000_wait_dsp_ack(struct hpi_adapter_obj *pao, u16 dsp_index,\n\tu32 ack_value);\n\nstatic short hpi6000_send_host_command(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 host_cmd);\n\nstatic void hpi6000_send_dsp_interrupt(struct dsp_obj *pdo);\n\nstatic short hpi6000_send_data(struct hpi_adapter_obj *pao, u16 dsp_index,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic short hpi6000_get_data(struct hpi_adapter_obj *pao, u16 dsp_index,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void hpi_write_word(struct dsp_obj *pdo, u32 address, u32 data);\n\nstatic u32 hpi_read_word(struct dsp_obj *pdo, u32 address);\n\nstatic void hpi_write_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\n\tu32 length);\n\nstatic void hpi_read_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\n\tu32 length);\n\nstatic void subsys_create_adapter(struct hpi_message *phm,\n\tstruct hpi_response *phr);\n\nstatic void adapter_delete(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void adapter_get_asserts(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic short create_adapter_obj(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code);\n\nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao);\n\n \n\nstatic u16 gw_pci_read_asserts;\t \nstatic u16 gw_pci_write_asserts;\t \n\nstatic void subsys_message(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tsubsys_create_adapter(phm, phr);\n\t\tbreak;\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\t}\n}\n\nstatic void control_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\n\tswitch (phm->function) {\n\tcase HPI_CONTROL_GET_STATE:\n\t\tif (pao->has_control_cache) {\n\t\t\tu16 err;\n\t\t\terr = hpi6000_update_control_cache(pao, phm);\n\n\t\t\tif (err) {\n\t\t\t\tif (err >= HPI_ERROR_BACKEND_BASE) {\n\t\t\t\t\tphr->error =\n\t\t\t\t\t\tHPI_ERROR_CONTROL_CACHING;\n\t\t\t\t\tphr->specific_error = err;\n\t\t\t\t} else {\n\t\t\t\t\tphr->error = err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (hpi_check_control_cache(phw->p_cache, phm, phr))\n\t\t\t\tbreak;\n\t\t}\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_CONTROL_SET_STATE:\n\t\thw_message(pao, phm, phr);\n\t\thpi_cmn_control_cache_sync_to_msg(phw->p_cache, phm, phr);\n\t\tbreak;\n\n\tcase HPI_CONTROL_GET_INFO:\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void adapter_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_ADAPTER_GET_ASSERT:\n\t\tadapter_get_asserts(pao, phm, phr);\n\t\tbreak;\n\n\tcase HPI_ADAPTER_DELETE:\n\t\tadapter_delete(pao, phm, phr);\n\t\tbreak;\n\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void outstream_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_OSTREAM_HOSTBUFFER_ALLOC:\n\tcase HPI_OSTREAM_HOSTBUFFER_FREE:\n\t\t \n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n}\n\nstatic void instream_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\n\tswitch (phm->function) {\n\tcase HPI_ISTREAM_HOSTBUFFER_ALLOC:\n\tcase HPI_ISTREAM_HOSTBUFFER_FREE:\n\t\t \n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n}\n\n \n \nvoid HPI_6000(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_adapter_obj *pao = NULL;\n\n\tif (phm->object != HPI_OBJ_SUBSYSTEM) {\n\t\tpao = hpi_find_adapter(phm->adapter_index);\n\t\tif (!pao) {\n\t\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\t\tHPI_ERROR_BAD_ADAPTER_NUMBER);\n\t\t\tHPI_DEBUG_LOG(DEBUG, \"invalid adapter index: %d \\n\",\n\t\t\t\tphm->adapter_index);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (pao->dsp_crashed >= 10) {\n\t\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\t\tHPI_ERROR_DSP_HARDWARE);\n\t\t\tHPI_DEBUG_LOG(DEBUG, \"adapter %d dsp crashed\\n\",\n\t\t\t\tphm->adapter_index);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tif (phm->function != HPI_SUBSYS_CREATE_ADAPTER)\n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_PROCESSING_MESSAGE);\n\n\tswitch (phm->type) {\n\tcase HPI_TYPE_REQUEST:\n\t\tswitch (phm->object) {\n\t\tcase HPI_OBJ_SUBSYSTEM:\n\t\t\tsubsys_message(phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_ADAPTER:\n\t\t\tphr->size =\n\t\t\t\tsizeof(struct hpi_response_header) +\n\t\t\t\tsizeof(struct hpi_adapter_res);\n\t\t\tadapter_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_CONTROL:\n\t\t\tcontrol_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_OSTREAM:\n\t\t\toutstream_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_ISTREAM:\n\t\t\tinstream_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\thw_message(pao, phm, phr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_TYPE;\n\t\tbreak;\n\t}\n}\n\n \n \n\n \nstatic void subsys_create_adapter(struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\t \n\tstruct hpi_adapter_obj ao;\n\tstruct hpi_adapter_obj *pao;\n\tu32 os_error_code;\n\tu16 err = 0;\n\tu32 dsp_index = 0;\n\n\tHPI_DEBUG_LOG(VERBOSE, \"subsys_create_adapter\\n\");\n\n\tmemset(&ao, 0, sizeof(ao));\n\n\tao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);\n\tif (!ao.priv) {\n\t\tHPI_DEBUG_LOG(ERROR, \"can't get mem for adapter object\\n\");\n\t\tphr->error = HPI_ERROR_MEMORY_ALLOC;\n\t\treturn;\n\t}\n\n\t \n\tao.pci = *phm->u.s.resource.r.pci;\n\n\terr = create_adapter_obj(&ao, &os_error_code);\n\tif (err) {\n\t\tdelete_adapter_obj(&ao);\n\t\tif (err >= HPI_ERROR_BACKEND_BASE) {\n\t\t\tphr->error = HPI_ERROR_DSP_BOOTLOAD;\n\t\t\tphr->specific_error = err;\n\t\t} else {\n\t\t\tphr->error = err;\n\t\t}\n\n\t\tphr->u.s.data = os_error_code;\n\t\treturn;\n\t}\n\t \n\tpao = hpi_find_adapter(ao.index);\n\tif (!pao) {\n\t\t \n\t\tHPI_DEBUG_LOG(ERROR, \"lost adapter after boot\\n\");\n\t\tphr->error = HPI_ERROR_BAD_ADAPTER;\n\t\treturn;\n\t}\n\n\tfor (dsp_index = 0; dsp_index < MAX_DSPS; dsp_index++) {\n\t\tstruct hpi_hw_obj *phw = pao->priv;\n\t\tphw->ado[dsp_index].pa_parent_adapter = pao;\n\t}\n\n\tphr->u.s.adapter_type = ao.type;\n\tphr->u.s.adapter_index = ao.index;\n\tphr->error = 0;\n}\n\nstatic void adapter_delete(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tdelete_adapter_obj(pao);\n\thpi_delete_adapter(pao);\n\tphr->error = 0;\n}\n\n \nstatic short create_adapter_obj(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code)\n{\n\tshort boot_error = 0;\n\tu32 dsp_index = 0;\n\tu32 control_cache_size = 0;\n\tu32 control_cache_count = 0;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\n\t \n\t \n\t \n\tphw->dw2040_HPICSR = pao->pci.ap_mem_base[0];\n\tphw->dw2040_HPIDSP = pao->pci.ap_mem_base[1];\n\tHPI_DEBUG_LOG(VERBOSE, \"csr %p, dsp %p\\n\", phw->dw2040_HPICSR,\n\t\tphw->dw2040_HPIDSP);\n\n\t \n\tfor (dsp_index = 0; dsp_index < MAX_DSPS; dsp_index++) {\n\t\tphw->ado[dsp_index].prHPI_control =\n\t\t\tphw->dw2040_HPIDSP + (CONTROL +\n\t\t\tDSP_SPACING * dsp_index);\n\n\t\tphw->ado[dsp_index].prHPI_address =\n\t\t\tphw->dw2040_HPIDSP + (ADDRESS +\n\t\t\tDSP_SPACING * dsp_index);\n\t\tphw->ado[dsp_index].prHPI_data =\n\t\t\tphw->dw2040_HPIDSP + (DATA + DSP_SPACING * dsp_index);\n\n\t\tphw->ado[dsp_index].prHPI_data_auto_inc =\n\t\t\tphw->dw2040_HPIDSP + (DATA_AUTOINC +\n\t\t\tDSP_SPACING * dsp_index);\n\n\t\tHPI_DEBUG_LOG(VERBOSE, \"ctl %p, adr %p, dat %p, dat++ %p\\n\",\n\t\t\tphw->ado[dsp_index].prHPI_control,\n\t\t\tphw->ado[dsp_index].prHPI_address,\n\t\t\tphw->ado[dsp_index].prHPI_data,\n\t\t\tphw->ado[dsp_index].prHPI_data_auto_inc);\n\n\t\tphw->ado[dsp_index].pa_parent_adapter = pao;\n\t}\n\n\tphw->pCI2040HPI_error_count = 0;\n\tpao->has_control_cache = 0;\n\n\t \n\t \n\t \n\tphw->num_dsp = 1;\n\n\tboot_error = hpi6000_adapter_boot_load_dsp(pao, pos_error_code);\n\tif (boot_error)\n\t\treturn boot_error;\n\n\tHPI_DEBUG_LOG(INFO, \"bootload DSP OK\\n\");\n\n\tphw->message_buffer_address_on_dsp = 0L;\n\tphw->response_buffer_address_on_dsp = 0L;\n\n\t \n\t \n\t{\n\t\tstruct hpi_message hm;\n\t\tstruct hpi_response hr0;\t \n\t\tstruct hpi_response hr1;\t \n\t\tu16 error = 0;\n\n\t\tHPI_DEBUG_LOG(VERBOSE, \"send ADAPTER_GET_INFO\\n\");\n\t\tmemset(&hm, 0, sizeof(hm));\n\t\thm.type = HPI_TYPE_REQUEST;\n\t\thm.size = sizeof(struct hpi_message);\n\t\thm.object = HPI_OBJ_ADAPTER;\n\t\thm.function = HPI_ADAPTER_GET_INFO;\n\t\thm.adapter_index = 0;\n\t\tmemset(&hr0, 0, sizeof(hr0));\n\t\tmemset(&hr1, 0, sizeof(hr1));\n\t\thr0.size = sizeof(hr0);\n\t\thr1.size = sizeof(hr1);\n\n\t\terror = hpi6000_message_response_sequence(pao, 0, &hm, &hr0);\n\t\tif (hr0.error) {\n\t\t\tHPI_DEBUG_LOG(DEBUG, \"message error %d\\n\", hr0.error);\n\t\t\treturn hr0.error;\n\t\t}\n\t\tif (phw->num_dsp == 2) {\n\t\t\terror = hpi6000_message_response_sequence(pao, 1, &hm,\n\t\t\t\t&hr1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tpao->type = hr0.u.ax.info.adapter_type;\n\t\tpao->index = hr0.u.ax.info.adapter_index;\n\t}\n\n\tmemset(&phw->control_cache[0], 0,\n\t\tsizeof(struct hpi_control_cache_single) *\n\t\tHPI_NMIXER_CONTROLS);\n\t \n\tcontrol_cache_size =\n\t\thpi_read_word(&phw->ado[0],\n\t\tHPI_HIF_ADDR(control_cache_size_in_bytes));\n\tif (control_cache_size) {\n\t\tcontrol_cache_count =\n\t\t\thpi_read_word(&phw->ado[0],\n\t\t\tHPI_HIF_ADDR(control_cache_count));\n\n\t\tphw->p_cache =\n\t\t\thpi_alloc_control_cache(control_cache_count,\n\t\t\tcontrol_cache_size, (unsigned char *)\n\t\t\t&phw->control_cache[0]\n\t\t\t);\n\t\tif (phw->p_cache)\n\t\t\tpao->has_control_cache = 1;\n\t}\n\n\tHPI_DEBUG_LOG(DEBUG, \"get adapter info ASI%04X index %d\\n\", pao->type,\n\t\tpao->index);\n\n\tif (phw->p_cache)\n\t\tphw->p_cache->adap_idx = pao->index;\n\n\treturn hpi_add_adapter(pao);\n}\n\nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\n\tif (pao->has_control_cache)\n\t\thpi_free_control_cache(phw->p_cache);\n\n\t \n\tiowrite32(0x0003000F, phw->dw2040_HPICSR + HPI_RESET);\n\n\tkfree(phw);\n}\n\n \n \n\nstatic void adapter_get_asserts(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n#ifndef HIDE_PCI_ASSERTS\n\t \n\tif ((gw_pci_read_asserts > 0) || (gw_pci_write_asserts > 0)) {\n\t\tphr->u.ax.assert.p1 =\n\t\t\tgw_pci_read_asserts * 100 + gw_pci_write_asserts;\n\t\tphr->u.ax.assert.p2 = 0;\n\t\tphr->u.ax.assert.count = 1;\t \n\t\tphr->u.ax.assert.dsp_index = -1;\t \n\t\tstrcpy(phr->u.ax.assert.sz_message, \"PCI2040 error\");\n\t\tphr->u.ax.assert.dsp_msg_addr = 0;\n\t\tgw_pci_read_asserts = 0;\n\t\tgw_pci_write_asserts = 0;\n\t\tphr->error = 0;\n\t} else\n#endif\n\t\thw_message(pao, phm, phr);\t \n\n\treturn;\n}\n\n \n \n\nstatic short hpi6000_adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tshort error;\n\tu32 timeout;\n\tu32 read = 0;\n\tu32 i = 0;\n\tu32 data = 0;\n\tu32 j = 0;\n\tu32 test_addr = 0x80000000;\n\tu32 test_data = 0x00000001;\n\tu32 dw2040_reset = 0;\n\tu32 dsp_index = 0;\n\tu32 endian = 0;\n\tu32 adapter_info = 0;\n\tu32 delay = 0;\n\n\tstruct dsp_code dsp_code;\n\tu16 boot_load_family = 0;\n\n\t \n\n\tswitch (pao->pci.pci_dev->subsystem_device) {\n\tcase 0x5100:\n\tcase 0x5110:\t \n\tcase 0x5200:\t \n\tcase 0x6100:\n\tcase 0x6200:\n\t\tboot_load_family = HPI_ADAPTER_FAMILY_ASI(0x6200);\n\t\tbreak;\n\tdefault:\n\t\treturn HPI6000_ERROR_UNHANDLED_SUBSYS_ID;\n\t}\n\n\t \n\tendian = 0;\n\tdw2040_reset = 0x0003000F;\n\tiowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\n\n\t \n\thpios_delay_micro_seconds(1000);\n\tdelay = ioread32(phw->dw2040_HPICSR + HPI_RESET);\n\n\tif (delay != dw2040_reset) {\n\t\tHPI_DEBUG_LOG(ERROR, \"INIT_PCI2040 %x %x\\n\", dw2040_reset,\n\t\t\tdelay);\n\t\treturn HPI6000_ERROR_INIT_PCI2040;\n\t}\n\n\t \n\tiowrite32(0x00000003, phw->dw2040_HPICSR + HPI_DATA_WIDTH);\n\t \n\tiowrite32(0x60000000, phw->dw2040_HPICSR + INTERRUPT_MASK_SET);\n\n\t \n\tdw2040_reset = dw2040_reset & (~(endian << 3));\n\tiowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\n\n\tphw->ado[0].c_dsp_rev = 'B';\t \n\tphw->ado[1].c_dsp_rev = 'B';\t \n\n\t \n\tdw2040_reset = dw2040_reset & (~0x00000001);\t \n\tiowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\n\tdw2040_reset = dw2040_reset & (~0x00000002);\t \n\tiowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\n\n\t \n\tdw2040_reset = dw2040_reset & (~0x00000008);\n\tiowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\n\t \n\thpios_delay_micro_seconds(100);\n\n\t \n\tfor (dsp_index = 0; dsp_index < phw->num_dsp; dsp_index++) {\n\t\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\n\t\t \n\t\t \n\t\tiowrite32(0x00010001, pdo->prHPI_control);\n\n\t\t \n\t\ttest_data = 0x00000001;\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tiowrite32(test_data, pdo->prHPI_address);\n\t\t\tdata = ioread32(pdo->prHPI_address);\n\t\t\tif (data != test_data) {\n\t\t\t\tHPI_DEBUG_LOG(ERROR, \"INIT_DSPHPI %x %x %x\\n\",\n\t\t\t\t\ttest_data, data, dsp_index);\n\t\t\t\treturn HPI6000_ERROR_INIT_DSPHPI;\n\t\t\t}\n\t\t\ttest_data = test_data << 1;\n\t\t}\n\n \n \n \n\t\t{\n\t\t\t \n\t\t\t \n\t\t\thpi_write_word(pdo, 0x01B7C100, 0x0000);\n\t\t\thpios_delay_micro_seconds(100);\n\n\t\t\t \n\t\t\t \n\t\t\thpi_write_word(pdo, 0x01B7C120, 0x8002);\n\t\t\thpios_delay_micro_seconds(100);\n\n\t\t\t \n\t\t\thpi_write_word(pdo, 0x01B7C11C, 0x8001);\n\t\t\thpios_delay_micro_seconds(100);\n\n\t\t\t \n\t\t\thpi_write_word(pdo, 0x01B7C118, 0x8000);\n\n\t\t\t \n\t\t\thpios_delay_micro_seconds(2000);\n\n\t\t\t \n\t\t\thpi_write_word(pdo, 0x01B7C100, 0x0001);\n\t\t\t \n\t\t\thpios_delay_micro_seconds(2000);\n\t\t}\n\n\t\t \n\t\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\ttest_addr = 0x00000000;\n\t\t\ttest_data = 0x00000001;\n\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\thpi_write_word(pdo, test_addr + i, test_data);\n\t\t\t\tdata = hpi_read_word(pdo, test_addr + i);\n\t\t\t\tif (data != test_data) {\n\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\"DSP mem %x %x %x %x\\n\",\n\t\t\t\t\t\ttest_addr + i, test_data,\n\t\t\t\t\t\tdata, dsp_index);\n\n\t\t\t\t\treturn HPI6000_ERROR_INIT_DSPINTMEM;\n\t\t\t\t}\n\t\t\t\ttest_data = test_data << 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\thpi_write_word(pdo, 0x01800000, 0x34A8);\n\n\t\t \n\t\thpi_write_word(pdo, 0x01800008, 0x00000030);\n\n\t\t \n\n\t\t \n\t\thpi_write_word(pdo, 0x01800020, 0x001BDF29);\n\n\t\t \n\t\t \n\t\thpi_write_word(pdo, 0x01800018, 0x47117000);\n\n\t\t \n\t\thpi_write_word(pdo, 0x0180001C, 0x00000410);\n\n\t\t \n\t\t{\n\t\t\tu32 cE1 =\n\t\t\t\t(1L << 28) | (3L << 22) | (1L << 20) | (1L <<\n\t\t\t\t16) | (2L << 14) | (3L << 8) | (2L << 4) | 1L;\n\t\t\thpi_write_word(pdo, 0x01800004, cE1);\n\t\t}\n\n\t\t \n\t\thpios_delay_micro_seconds(1000);\n\n\t\t \n\t\t{\n\t\t\ttest_addr = 0x80000000;\n\t\t\ttest_data = 0x00000001;\n\t\t\t \n\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\thpi_write_word(pdo, test_addr, test_data);\n\t\t\t\tdata = hpi_read_word(pdo, test_addr);\n\t\t\t\tif (data != test_data) {\n\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\"DSP dram %x %x %x %x\\n\",\n\t\t\t\t\t\ttest_addr, test_data, data,\n\t\t\t\t\t\tdsp_index);\n\n\t\t\t\t\treturn HPI6000_ERROR_INIT_SDRAM1;\n\t\t\t\t}\n\t\t\t\ttest_data = test_data << 1;\n\t\t\t}\n\t\t\t \n#define DRAM_SIZE_WORDS 0x200000\t \n#define DRAM_INC 1024\n\t\t\ttest_addr = 0x80000000;\n\t\t\ttest_data = 0x0;\n\t\t\tfor (i = 0; i < DRAM_SIZE_WORDS; i = i + DRAM_INC) {\n\t\t\t\thpi_write_word(pdo, test_addr + i, test_data);\n\t\t\t\ttest_data++;\n\t\t\t}\n\t\t\ttest_addr = 0x80000000;\n\t\t\ttest_data = 0x0;\n\t\t\tfor (i = 0; i < DRAM_SIZE_WORDS; i = i + DRAM_INC) {\n\t\t\t\tdata = hpi_read_word(pdo, test_addr + i);\n\t\t\t\tif (data != test_data) {\n\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\"DSP dram %x %x %x %x\\n\",\n\t\t\t\t\t\ttest_addr + i, test_data,\n\t\t\t\t\t\tdata, dsp_index);\n\t\t\t\t\treturn HPI6000_ERROR_INIT_SDRAM2;\n\t\t\t\t}\n\t\t\t\ttest_data++;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\terror = hpi_dsp_code_open(boot_load_family, pao->pci.pci_dev,\n\t\t\t&dsp_code, pos_error_code);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\twhile (1) {\n\t\t\tu32 length;\n\t\t\tu32 address;\n\t\t\tu32 type;\n\t\t\tu32 *pcode;\n\n\t\t\terror = hpi_dsp_code_read_word(&dsp_code, &length);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (length == 0xFFFFFFFF)\n\t\t\t\tbreak;\t \n\n\t\t\terror = hpi_dsp_code_read_word(&dsp_code, &address);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = hpi_dsp_code_read_word(&dsp_code, &type);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = hpi_dsp_code_read_block(length, &dsp_code,\n\t\t\t\t&pcode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = hpi6000_dsp_block_write32(pao, (u16)dsp_index,\n\t\t\t\taddress, pcode, length);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (error) {\n\t\t\thpi_dsp_code_close(&dsp_code);\n\t\t\treturn error;\n\t\t}\n\t\t \n\t\t \n\t\thpi_dsp_code_rewind(&dsp_code);\n\t\twhile (1) {\n\t\t\tu32 length;\n\t\t\tu32 address;\n\t\t\tu32 type;\n\t\t\tu32 *pcode;\n\n\t\t\thpi_dsp_code_read_word(&dsp_code, &length);\n\t\t\tif (length == 0xFFFFFFFF)\n\t\t\t\tbreak;\t \n\n\t\t\thpi_dsp_code_read_word(&dsp_code, &address);\n\t\t\thpi_dsp_code_read_word(&dsp_code, &type);\n\t\t\thpi_dsp_code_read_block(length, &dsp_code, &pcode);\n\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tdata = hpi_read_word(pdo, address);\n\t\t\t\tif (data != *pcode) {\n\t\t\t\t\terror = HPI6000_ERROR_INIT_VERIFY;\n\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\"DSP verify %x %x %x %x\\n\",\n\t\t\t\t\t\taddress, *pcode, data,\n\t\t\t\t\t\tdsp_index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpcode++;\n\t\t\t\taddress += 4;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\thpi_dsp_code_close(&dsp_code);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\t{\n\t\t\tu32 address = HPI_HIF_ADDR(host_cmd);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\thpi_write_word(pdo, address, 0);\n\t\t\t\taddress += 4;\n\t\t\t}\n\t\t}\n\t\t \n\t\t \n\t\thpi_write_word(pdo, HPI_HIF_ADDR(dsp_number), dsp_index);\n\n\t\t \n\t\t \n\t\tif (dsp_index > 0)\n\t\t\thpi_write_word(pdo, HPI_HIF_ADDR(adapter_info),\n\t\t\t\tadapter_info);\n\n\t\t \n\t\tiowrite32(0x00030003, pdo->prHPI_control);\n\t\thpios_delay_micro_seconds(10000);\n\n\t\t \n\t\ttimeout = 2000000;\n\t\twhile (timeout) {\n\t\t\tdo {\n\t\t\t\tread = hpi_read_word(pdo,\n\t\t\t\t\tHPI_HIF_ADDR(host_cmd));\n\t\t\t} while (--timeout\n\t\t\t\t&& hpi6000_check_PCI2040_error_flag(pao,\n\t\t\t\t\tH6READ));\n\n\t\t\tif (read)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\telse\n\t\t\t\thpios_delay_micro_seconds(10000);\n\t\t}\n\t\tif (timeout == 0)\n\t\t\treturn HPI6000_ERROR_INIT_NOACK;\n\n\t\t \n\t\t \n\t\tif (dsp_index == 0) {\n\t\t\t \n\t\t\tu32 mask = 0;\n\n\t\t\tadapter_info =\n\t\t\t\thpi_read_word(pdo,\n\t\t\t\tHPI_HIF_ADDR(adapter_info));\n\t\t\tif (HPI_ADAPTER_FAMILY_ASI\n\t\t\t\t(HPI_HIF_ADAPTER_INFO_EXTRACT_ADAPTER\n\t\t\t\t\t(adapter_info)) ==\n\t\t\t\tHPI_ADAPTER_FAMILY_ASI(0x6200))\n\t\t\t\t \n\t\t\t\tphw->num_dsp = 2;\n\n\t\t\t \n\t\t\t \n#define PLD_BASE_ADDRESS 0x90000000L\t \n\n\t\t\tswitch (boot_load_family) {\n\t\t\tcase HPI_ADAPTER_FAMILY_ASI(0x6200):\n\t\t\t\t \n\t\t\t\tmask = 0xFFFFFF00L;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (HPI_ADAPTER_FAMILY_ASI(pao->pci.pci_dev->\n\t\t\t\t\t\tsubsystem_device) ==\n\t\t\t\t\tHPI_ADAPTER_FAMILY_ASI(0x5100))\n\t\t\t\t\tmask = 0x00000000L;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (HPI_ADAPTER_FAMILY_ASI(pao->pci.pci_dev->\n\t\t\t\t\t\tsubsystem_device) ==\n\t\t\t\t\tHPI_ADAPTER_FAMILY_ASI(0x5200))\n\t\t\t\t\tmask = 0x00000000L;\n\t\t\t\tbreak;\n\t\t\tcase HPI_ADAPTER_FAMILY_ASI(0x8800):\n\t\t\t\t \n\t\t\t\tmask = 0xFFFF0000L;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttest_data = 0xAAAAAA00L & mask;\n\t\t\t \n\t\t\thpi_write_word(pdo, PLD_BASE_ADDRESS + 4L, test_data);\n\t\t\tread = hpi_read_word(pdo,\n\t\t\t\tPLD_BASE_ADDRESS + 4L) & mask;\n\t\t\tif (read != test_data) {\n\t\t\t\tHPI_DEBUG_LOG(ERROR, \"PLD %x %x\\n\", test_data,\n\t\t\t\t\tread);\n\t\t\t\treturn HPI6000_ERROR_INIT_PLDTEST1;\n\t\t\t}\n\t\t\ttest_data = 0x55555500L & mask;\n\t\t\thpi_write_word(pdo, PLD_BASE_ADDRESS + 4L, test_data);\n\t\t\tread = hpi_read_word(pdo,\n\t\t\t\tPLD_BASE_ADDRESS + 4L) & mask;\n\t\t\tif (read != test_data) {\n\t\t\t\tHPI_DEBUG_LOG(ERROR, \"PLD %x %x\\n\", test_data,\n\t\t\t\t\tread);\n\t\t\t\treturn HPI6000_ERROR_INIT_PLDTEST2;\n\t\t\t}\n\t\t}\n\t}\t \n\treturn 0;\n}\n\n#define PCI_TIMEOUT 100\n\nstatic int hpi_set_address(struct dsp_obj *pdo, u32 address)\n{\n\tu32 timeout = PCI_TIMEOUT;\n\n\tdo {\n\t\tiowrite32(address, pdo->prHPI_address);\n\t} while (hpi6000_check_PCI2040_error_flag(pdo->pa_parent_adapter,\n\t\t\tH6WRITE)\n\t\t&& --timeout);\n\n\tif (timeout)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic void hpi_write_word(struct dsp_obj *pdo, u32 address, u32 data)\n{\n\tif (hpi_set_address(pdo, address))\n\t\treturn;\n\tiowrite32(data, pdo->prHPI_data);\n}\n\n \nstatic u32 hpi_read_word(struct dsp_obj *pdo, u32 address)\n{\n\tu32 data = 0;\n\n\tif (hpi_set_address(pdo, address))\n\t\treturn 0;\t \n\n\t \n\tdata = ioread32(pdo->prHPI_data);\n\treturn data;\n}\n\n \nstatic void hpi_write_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\n\tu32 length)\n{\n\tu16 length16 = length - 1;\n\n\tif (length == 0)\n\t\treturn;\n\n\tif (hpi_set_address(pdo, address))\n\t\treturn;\n\n\tiowrite32_rep(pdo->prHPI_data_auto_inc, pdata, length16);\n\n\t \n\t \n\tiowrite32(*(pdata + length - 1), pdo->prHPI_data);\n}\n\n \nstatic void hpi_read_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\n\tu32 length)\n{\n\tu16 length16 = length - 1;\n\n\tif (length == 0)\n\t\treturn;\n\n\tif (hpi_set_address(pdo, address))\n\t\treturn;\n\n\tioread32_rep(pdo->prHPI_data_auto_inc, pdata, length16);\n\n\t \n\t \n\t*(pdata + length - 1) = ioread32(pdo->prHPI_data);\n}\n\nstatic u16 hpi6000_dsp_block_write32(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 hpi_address, u32 *source, u32 count)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 time_out = PCI_TIMEOUT;\n\tint c6711_burst_size = 128;\n\tu32 local_hpi_address = hpi_address;\n\tint local_count = count;\n\tint xfer_size;\n\tu32 *pdata = source;\n\n\twhile (local_count) {\n\t\tif (local_count > c6711_burst_size)\n\t\t\txfer_size = c6711_burst_size;\n\t\telse\n\t\t\txfer_size = local_count;\n\n\t\ttime_out = PCI_TIMEOUT;\n\t\tdo {\n\t\t\thpi_write_block(pdo, local_hpi_address, pdata,\n\t\t\t\txfer_size);\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE)\n\t\t\t&& --time_out);\n\n\t\tif (!time_out)\n\t\t\tbreak;\n\t\tpdata += xfer_size;\n\t\tlocal_hpi_address += sizeof(u32) * xfer_size;\n\t\tlocal_count -= xfer_size;\n\t}\n\n\tif (time_out)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic u16 hpi6000_dsp_block_read32(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 hpi_address, u32 *dest, u32 count)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 time_out = PCI_TIMEOUT;\n\tint c6711_burst_size = 16;\n\tu32 local_hpi_address = hpi_address;\n\tint local_count = count;\n\tint xfer_size;\n\tu32 *pdata = dest;\n\n\twhile (local_count) {\n\t\tif (local_count > c6711_burst_size)\n\t\t\txfer_size = c6711_burst_size;\n\t\telse\n\t\t\txfer_size = local_count;\n\n\t\ttime_out = PCI_TIMEOUT;\n\t\tdo {\n\t\t\thpi_read_block(pdo, local_hpi_address, pdata,\n\t\t\t\txfer_size);\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\n\t\t\t&& --time_out);\n\t\tif (!time_out)\n\t\t\tbreak;\n\n\t\tpdata += xfer_size;\n\t\tlocal_hpi_address += sizeof(u32) * xfer_size;\n\t\tlocal_count -= xfer_size;\n\t}\n\n\tif (time_out)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic short hpi6000_message_response_sequence(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, struct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 timeout;\n\tu16 ack;\n\tu32 address;\n\tu32 length;\n\tu32 *p_data;\n\tu16 error = 0;\n\n\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\n\tif (ack & HPI_HIF_ERROR_MASK) {\n\t\tpao->dsp_crashed++;\n\t\treturn HPI6000_ERROR_MSG_RESP_IDLE_TIMEOUT;\n\t}\n\tpao->dsp_crashed = 0;\n\n\t \n\tif (phw->message_buffer_address_on_dsp == 0) {\n\t\ttimeout = TIMEOUT;\n\t\tdo {\n\t\t\taddress =\n\t\t\t\thpi_read_word(pdo,\n\t\t\t\tHPI_HIF_ADDR(message_buffer_address));\n\t\t\tphw->message_buffer_address_on_dsp = address;\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\n\t\t\t&& --timeout);\n\t\tif (!timeout)\n\t\t\treturn HPI6000_ERROR_MSG_GET_ADR;\n\t} else\n\t\taddress = phw->message_buffer_address_on_dsp;\n\n\tlength = phm->size;\n\n\t \n\tp_data = (u32 *)phm;\n\tif (hpi6000_dsp_block_write32(pao, dsp_index, address, p_data,\n\t\t\t(u16)length / 4))\n\t\treturn HPI6000_ERROR_MSG_RESP_BLOCKWRITE32;\n\n\tif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_GET_RESP))\n\t\treturn HPI6000_ERROR_MSG_RESP_GETRESPCMD;\n\thpi6000_send_dsp_interrupt(pdo);\n\n\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_GET_RESP);\n\tif (ack & HPI_HIF_ERROR_MASK)\n\t\treturn HPI6000_ERROR_MSG_RESP_GET_RESP_ACK;\n\n\t \n\tif (phw->response_buffer_address_on_dsp == 0) {\n\t\ttimeout = TIMEOUT;\n\t\tdo {\n\t\t\taddress =\n\t\t\t\thpi_read_word(pdo,\n\t\t\t\tHPI_HIF_ADDR(response_buffer_address));\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\n\t\t\t&& --timeout);\n\t\tphw->response_buffer_address_on_dsp = address;\n\n\t\tif (!timeout)\n\t\t\treturn HPI6000_ERROR_RESP_GET_ADR;\n\t} else\n\t\taddress = phw->response_buffer_address_on_dsp;\n\n\t \n\ttimeout = TIMEOUT;\n\tdo {\n\t\tlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\n\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ) && --timeout);\n\tif (!timeout)\n\t\treturn HPI6000_ERROR_RESP_GET_LEN;\n\n\tif (length > phr->size)\n\t\treturn HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\n\t \n\tp_data = (u32 *)phr;\n\tif (hpi6000_dsp_block_read32(pao, dsp_index, address, p_data,\n\t\t\t(u16)length / 4))\n\t\treturn HPI6000_ERROR_MSG_RESP_BLOCKREAD32;\n\n\t \n\tif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\n\t\treturn HPI6000_ERROR_MSG_RESP_IDLECMD;\n\thpi6000_send_dsp_interrupt(pdo);\n\n\terror = hpi_validate_response(phm, phr);\n\treturn error;\n}\n\n \n\n#define MSG_ADDRESS (HPI_HIF_BASE+0x18)\n#define MSG_LENGTH 11\n#define RESP_ADDRESS (HPI_HIF_BASE+0x44)\n#define RESP_LENGTH 16\n#define QUEUE_START  (HPI_HIF_BASE+0x88)\n#define QUEUE_SIZE 0x8000\n\nstatic short hpi6000_send_data_check_adr(u32 address, u32 length_in_dwords)\n{\n \n\twhile ((data_sent < (phm->u.d.u.data.data_size & ~3L))\n\t\t&& --time_out) {\n\t\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\n\t\tif (ack & HPI_HIF_ERROR_MASK)\n\t\t\treturn HPI6000_ERROR_SEND_DATA_IDLE_TIMEOUT;\n\n\t\tif (hpi6000_send_host_command(pao, dsp_index,\n\t\t\t\tHPI_HIF_SEND_DATA))\n\t\t\treturn HPI6000_ERROR_SEND_DATA_CMD;\n\n\t\thpi6000_send_dsp_interrupt(pdo);\n\n\t\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_SEND_DATA);\n\n\t\tif (ack & HPI_HIF_ERROR_MASK)\n\t\t\treturn HPI6000_ERROR_SEND_DATA_ACK;\n\n\t\tdo {\n\t\t\t \n\t\t\taddress = hpi_read_word(pdo, HPI_HIF_ADDR(address));\n\t\t\t \n\t\t\tlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ));\n\n\t\tif (!hpi6000_send_data_check_adr(address, length))\n\t\t\treturn HPI6000_ERROR_SEND_DATA_ADR;\n\n\t\t \n\n\t\t{\n\t\t\tu32 len = length;\n\t\t\tu32 blk_len = 512;\n\t\t\twhile (len) {\n\t\t\t\tif (len < blk_len)\n\t\t\t\t\tblk_len = len;\n\t\t\t\tif (hpi6000_dsp_block_write32(pao, dsp_index,\n\t\t\t\t\t\taddress, p_data, blk_len))\n\t\t\t\t\treturn HPI6000_ERROR_SEND_DATA_WRITE;\n\t\t\t\taddress += blk_len * 4;\n\t\t\t\tp_data += blk_len;\n\t\t\t\tlen -= blk_len;\n\t\t\t}\n\t\t}\n\n\t\tif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\n\t\t\treturn HPI6000_ERROR_SEND_DATA_IDLECMD;\n\n\t\thpi6000_send_dsp_interrupt(pdo);\n\n\t\tdata_sent += length * 4;\n\t}\n\tif (!time_out)\n\t\treturn HPI6000_ERROR_SEND_DATA_TIMEOUT;\n\treturn 0;\n}\n\nstatic short hpi6000_get_data(struct hpi_adapter_obj *pao, u16 dsp_index,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 data_got = 0;\n\tu16 ack;\n\tu32 length, address;\n\tu32 *p_data = (u32 *)phm->u.d.u.data.pb_data;\n\n\t(void)phr;\t \n\n\t \n\twhile (data_got < (phm->u.d.u.data.data_size & ~3L)) {\n\t\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\n\t\tif (ack & HPI_HIF_ERROR_MASK)\n\t\t\treturn HPI6000_ERROR_GET_DATA_IDLE_TIMEOUT;\n\n\t\tif (hpi6000_send_host_command(pao, dsp_index,\n\t\t\t\tHPI_HIF_GET_DATA))\n\t\t\treturn HPI6000_ERROR_GET_DATA_CMD;\n\t\thpi6000_send_dsp_interrupt(pdo);\n\n\t\tack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_GET_DATA);\n\n\t\tif (ack & HPI_HIF_ERROR_MASK)\n\t\t\treturn HPI6000_ERROR_GET_DATA_ACK;\n\n\t\t \n\t\tdo {\n\t\t\taddress = hpi_read_word(pdo, HPI_HIF_ADDR(address));\n\t\t\tlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ));\n\n\t\t \n\t\t{\n\t\t\tu32 len = length;\n\t\t\tu32 blk_len = 512;\n\t\t\twhile (len) {\n\t\t\t\tif (len < blk_len)\n\t\t\t\t\tblk_len = len;\n\t\t\t\tif (hpi6000_dsp_block_read32(pao, dsp_index,\n\t\t\t\t\t\taddress, p_data, blk_len))\n\t\t\t\t\treturn HPI6000_ERROR_GET_DATA_READ;\n\t\t\t\taddress += blk_len * 4;\n\t\t\t\tp_data += blk_len;\n\t\t\t\tlen -= blk_len;\n\t\t\t}\n\t\t}\n\n\t\tif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\n\t\t\treturn HPI6000_ERROR_GET_DATA_IDLECMD;\n\t\thpi6000_send_dsp_interrupt(pdo);\n\n\t\tdata_got += length * 4;\n\t}\n\treturn 0;\n}\n\nstatic void hpi6000_send_dsp_interrupt(struct dsp_obj *pdo)\n{\n\tiowrite32(0x00030003, pdo->prHPI_control);\t \n}\n\nstatic short hpi6000_send_host_command(struct hpi_adapter_obj *pao,\n\tu16 dsp_index, u32 host_cmd)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 timeout = TIMEOUT;\n\n\t \n\tdo {\n\t\thpi_write_word(pdo, HPI_HIF_ADDR(host_cmd), host_cmd);\n\t\t \n\t\thpi_set_address(pdo, HPI_HIF_ADDR(host_cmd));\n\t} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE) && --timeout);\n\n\t \n\tiowrite32(0x00040004, pdo->prHPI_control);\n\n\tif (timeout)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nstatic short hpi6000_check_PCI2040_error_flag(struct hpi_adapter_obj *pao,\n\tu16 read_or_write)\n{\n\tu32 hPI_error;\n\n\tstruct hpi_hw_obj *phw = pao->priv;\n\n\t \n\thPI_error = ioread32(phw->dw2040_HPICSR + HPI_ERROR_REPORT);\n\tif (hPI_error) {\n\t\t \n\t\tiowrite32(0L, phw->dw2040_HPICSR + HPI_ERROR_REPORT);\n\t\tphw->pCI2040HPI_error_count++;\n\t\tif (read_or_write == 1)\n\t\t\tgw_pci_read_asserts++;\t    \n\t\telse\n\t\t\tgw_pci_write_asserts++;\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic short hpi6000_wait_dsp_ack(struct hpi_adapter_obj *pao, u16 dsp_index,\n\tu32 ack_value)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 ack = 0L;\n\tu32 timeout;\n\tu32 hPIC = 0L;\n\n\t \n\ttimeout = TIMEOUT;\n\twhile (--timeout) {\n\t\thPIC = ioread32(pdo->prHPI_control);\n\t\tif (hPIC & 0x04)\t \n\t\t\tbreak;\n\t}\n\tif (timeout == 0)\n\t\treturn HPI_HIF_ERROR_MASK;\n\n\t \n\ttimeout = TIMEOUT;\n\twhile (--timeout) {\n\t\t \n\t\tack = hpi_read_word(pdo, HPI_HIF_ADDR(dsp_ack));\n\t\tif (ack == ack_value)\n\t\t\tbreak;\n\t\tif ((ack & HPI_HIF_ERROR_MASK)\n\t\t\t&& !hpi6000_check_PCI2040_error_flag(pao, H6READ))\n\t\t\tbreak;\n\t\t \n\t\t \n\t}\n\tif (ack & HPI_HIF_ERROR_MASK)\n\t\t \n\t\tack = HPI_HIF_ERROR_MASK;\n\n\tif (timeout == 0)\n\t\tack = HPI_HIF_ERROR_MASK;\n\treturn (short)ack;\n}\n\nstatic short hpi6000_update_control_cache(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm)\n{\n\tconst u16 dsp_index = 0;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_obj *pdo = &phw->ado[dsp_index];\n\tu32 timeout;\n\tu32 cache_dirty_flag;\n\tu16 err;\n\n\thpios_dsplock_lock(pao);\n\n\ttimeout = TIMEOUT;\n\tdo {\n\t\tcache_dirty_flag =\n\t\t\thpi_read_word((struct dsp_obj *)pdo,\n\t\t\tHPI_HIF_ADDR(control_cache_is_dirty));\n\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ) && --timeout);\n\tif (!timeout) {\n\t\terr = HPI6000_ERROR_CONTROL_CACHE_PARAMS;\n\t\tgoto unlock;\n\t}\n\n\tif (cache_dirty_flag) {\n\t\t \n\t\tu32 address;\n\t\tu32 length;\n\n\t\ttimeout = TIMEOUT;\n\t\tif (pdo->control_cache_address_on_dsp == 0) {\n\t\t\tdo {\n\t\t\t\taddress =\n\t\t\t\t\thpi_read_word((struct dsp_obj *)pdo,\n\t\t\t\t\tHPI_HIF_ADDR(control_cache_address));\n\n\t\t\t\tlength = hpi_read_word((struct dsp_obj *)pdo,\n\t\t\t\t\tHPI_HIF_ADDR\n\t\t\t\t\t(control_cache_size_in_bytes));\n\t\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\n\t\t\t\t&& --timeout);\n\t\t\tif (!timeout) {\n\t\t\t\terr = HPI6000_ERROR_CONTROL_CACHE_ADDRLEN;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tpdo->control_cache_address_on_dsp = address;\n\t\t\tpdo->control_cache_length_on_dsp = length;\n\t\t} else {\n\t\t\taddress = pdo->control_cache_address_on_dsp;\n\t\t\tlength = pdo->control_cache_length_on_dsp;\n\t\t}\n\n\t\tif (hpi6000_dsp_block_read32(pao, dsp_index, address,\n\t\t\t\t(u32 *)&phw->control_cache[0],\n\t\t\t\tlength / sizeof(u32))) {\n\t\t\terr = HPI6000_ERROR_CONTROL_CACHE_READ;\n\t\t\tgoto unlock;\n\t\t}\n\t\tdo {\n\t\t\thpi_write_word((struct dsp_obj *)pdo,\n\t\t\t\tHPI_HIF_ADDR(control_cache_is_dirty), 0);\n\t\t\t \n\t\t\thpi_set_address(pdo, HPI_HIF_ADDR(host_cmd));\n\t\t} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE)\n\t\t\t&& --timeout);\n\t\tif (!timeout) {\n\t\t\terr = HPI6000_ERROR_CONTROL_CACHE_FLUSH;\n\t\t\tgoto unlock;\n\t\t}\n\n\t}\n\terr = 0;\n\nunlock:\n\thpios_dsplock_unlock(pao);\n\treturn err;\n}\n\n \nstatic u16 get_dsp_index(struct hpi_adapter_obj *pao, struct hpi_message *phm)\n{\n\tu16 ret = 0;\n\tswitch (phm->object) {\n\tcase HPI_OBJ_ISTREAM:\n\t\tif (phm->obj_index < 2)\n\t\t\tret = 1;\n\t\tbreak;\n\tcase HPI_OBJ_PROFILE:\n\t\tret = phm->obj_index;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\tu16 error = 0;\n\tu16 dsp_index = 0;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu16 num_dsp = phw->num_dsp;\n\n\tif (num_dsp < 2)\n\t\tdsp_index = 0;\n\telse {\n\t\tdsp_index = get_dsp_index(pao, phm);\n\n\t\t \n\t\tif ((phm->function == HPI_ISTREAM_GROUP_ADD)\n\t\t\t|| (phm->function == HPI_OSTREAM_GROUP_ADD)) {\n\t\t\tstruct hpi_message hm;\n\t\t\tu16 add_index;\n\t\t\thm.obj_index = phm->u.d.u.stream.stream_index;\n\t\t\thm.object = phm->u.d.u.stream.object_type;\n\t\t\tadd_index = get_dsp_index(pao, &hm);\n\t\t\tif (add_index != dsp_index) {\n\t\t\t\tphr->error = HPI_ERROR_NO_INTERDSP_GROUPS;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\thpios_dsplock_lock(pao);\n\terror = hpi6000_message_response_sequence(pao, dsp_index, phm, phr);\n\n\tif (error)\t \n\t\tgoto err;\n\n\tif (phr->error)\t \n\t\tgoto out;\n\n\tswitch (phm->function) {\n\tcase HPI_OSTREAM_WRITE:\n\tcase HPI_ISTREAM_ANC_WRITE:\n\t\terror = hpi6000_send_data(pao, dsp_index, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_READ:\n\tcase HPI_OSTREAM_ANC_READ:\n\t\terror = hpi6000_get_data(pao, dsp_index, phm, phr);\n\t\tbreak;\n\tcase HPI_ADAPTER_GET_ASSERT:\n\t\tphr->u.ax.assert.dsp_index = 0;\t \n\t\tif (num_dsp == 2) {\n\t\t\tif (!phr->u.ax.assert.count) {\n\t\t\t\t \n\t\t\t\terror = hpi6000_message_response_sequence(pao,\n\t\t\t\t\t1, phm, phr);\n\t\t\t\tphr->u.ax.assert.dsp_index = 1;\n\t\t\t}\n\t\t}\n\t}\n\nerr:\n\tif (error) {\n\t\tif (error >= HPI_ERROR_BACKEND_BASE) {\n\t\t\tphr->error = HPI_ERROR_DSP_COMMUNICATION;\n\t\t\tphr->specific_error = error;\n\t\t} else {\n\t\t\tphr->error = error;\n\t\t}\n\n\t\t \n\t\tphr->size = sizeof(struct hpi_response_header);\n\t}\nout:\n\thpios_dsplock_unlock(pao);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}