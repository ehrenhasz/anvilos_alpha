{
  "module_name": "hpi6205.c",
  "hash_id": "3bd1477049fbd08a0915c72e09f368fa829f2c1cabc3b04d9bb2047d322ca591",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpi6205.c",
  "human_readable_source": "\n \n#define SOURCEFILE_NAME \"hpi6205.c\"\n\n#include \"hpi_internal.h\"\n#include \"hpimsginit.h\"\n#include \"hpidebug.h\"\n#include \"hpi6205.h\"\n#include \"hpidspcd.h\"\n#include \"hpicmn.h\"\n\n \n \n#define HPI6205_ERROR_BASE 1000\t \n\n \n#define HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT     1015\n#define HPI6205_ERROR_MSG_RESP_TIMEOUT          1016\n\n \n#define HPI6205_ERROR_6205_NO_IRQ       1002\n#define HPI6205_ERROR_6205_INIT_FAILED  1003\n#define HPI6205_ERROR_6205_REG          1006\n#define HPI6205_ERROR_6205_DSPPAGE      1007\n#define HPI6205_ERROR_C6713_HPIC        1009\n#define HPI6205_ERROR_C6713_HPIA        1010\n#define HPI6205_ERROR_C6713_PLL         1011\n#define HPI6205_ERROR_DSP_INTMEM        1012\n#define HPI6205_ERROR_DSP_EXTMEM        1013\n#define HPI6205_ERROR_DSP_PLD           1014\n#define HPI6205_ERROR_6205_EEPROM       1017\n#define HPI6205_ERROR_DSP_EMIF1         1018\n#define HPI6205_ERROR_DSP_EMIF2         1019\n#define HPI6205_ERROR_DSP_EMIF3         1020\n#define HPI6205_ERROR_DSP_EMIF4         1021\n\n \n \n \n#define C6205_HSR_INTSRC        0x01\n#define C6205_HSR_INTAVAL       0x02\n#define C6205_HSR_INTAM         0x04\n#define C6205_HSR_CFGERR        0x08\n#define C6205_HSR_EEREAD        0x10\n \n#define C6205_HDCR_WARMRESET    0x01\n#define C6205_HDCR_DSPINT       0x02\n#define C6205_HDCR_PCIBOOT      0x04\n \n \n#define C6205_DSPP_MAP1         0x400\n\n \n#define C6205_BAR1_PCI_IO_OFFSET (0x027FFF0L)\n#define C6205_BAR1_HSR  (C6205_BAR1_PCI_IO_OFFSET)\n#define C6205_BAR1_HDCR (C6205_BAR1_PCI_IO_OFFSET+4)\n#define C6205_BAR1_DSPP (C6205_BAR1_PCI_IO_OFFSET+8)\n\n \n#define C6205_BAR0_TIMER1_CTL (0x01980000L)\n\n \n#define HPICL_ADDR      0x01400000L\n#define HPICH_ADDR      0x01400004L\n#define HPIAL_ADDR      0x01410000L\n#define HPIAH_ADDR      0x01410004L\n#define HPIDIL_ADDR     0x01420000L\n#define HPIDIH_ADDR     0x01420004L\n#define HPIDL_ADDR      0x01430000L\n#define HPIDH_ADDR      0x01430004L\n\n#define C6713_EMIF_GCTL         0x01800000\n#define C6713_EMIF_CE1          0x01800004\n#define C6713_EMIF_CE0          0x01800008\n#define C6713_EMIF_CE2          0x01800010\n#define C6713_EMIF_CE3          0x01800014\n#define C6713_EMIF_SDRAMCTL     0x01800018\n#define C6713_EMIF_SDRAMTIMING  0x0180001C\n#define C6713_EMIF_SDRAMEXT     0x01800020\n\nstruct hpi_hw_obj {\n\t \n\t__iomem u32 *prHSR;\n\t__iomem u32 *prHDCR;\n\t__iomem u32 *prDSPP;\n\n\tu32 dsp_page;\n\n\tstruct consistent_dma_area h_locked_mem;\n\tstruct bus_master_interface *p_interface_buffer;\n\n\tu16 flag_outstream_just_reset[HPI_MAX_STREAMS];\n\t \n\tstruct consistent_dma_area instream_host_buffers[HPI_MAX_STREAMS];\n\tstruct consistent_dma_area outstream_host_buffers[HPI_MAX_STREAMS];\n\t \n\tu32 instream_host_buffer_size[HPI_MAX_STREAMS];\n\tu32 outstream_host_buffer_size[HPI_MAX_STREAMS];\n\n\tstruct consistent_dma_area h_control_cache;\n\tstruct hpi_control_cache *p_cache;\n};\n\n \n \n\n#define check_before_bbm_copy(status, p_bbm_data, l_first_write, l_second_write)\n\nstatic int wait_dsp_ack(struct hpi_hw_obj *phw, int state, int timeout_us);\n\nstatic void send_dsp_command(struct hpi_hw_obj *phw, int cmd);\n\nstatic u16 adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code);\n\nstatic u16 message_response_sequence(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\n\tstruct hpi_response *phr);\n\n#define HPI6205_TIMEOUT 1000000\n\nstatic void subsys_create_adapter(struct hpi_message *phm,\n\tstruct hpi_response *phr);\nstatic void adapter_delete(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic u16 create_adapter_obj(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code);\n\nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao);\n\nstatic int adapter_irq_query_and_clear(struct hpi_adapter_obj *pao,\n\tu32 message);\n\nstatic void outstream_host_buffer_allocate(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_host_buffer_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_host_buffer_free(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\nstatic void outstream_write(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_start(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_open(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void outstream_reset(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_host_buffer_allocate(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_host_buffer_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_host_buffer_free(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_read(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic void instream_start(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr);\n\nstatic u32 boot_loader_read_mem32(struct hpi_adapter_obj *pao, int dsp_index,\n\tu32 address);\n\nstatic void boot_loader_write_mem32(struct hpi_adapter_obj *pao,\n\tint dsp_index, u32 address, u32 data);\n\nstatic u16 boot_loader_config_emif(struct hpi_adapter_obj *pao,\n\tint dsp_index);\n\nstatic u16 boot_loader_test_memory(struct hpi_adapter_obj *pao, int dsp_index,\n\tu32 address, u32 length);\n\nstatic u16 boot_loader_test_internal_memory(struct hpi_adapter_obj *pao,\n\tint dsp_index);\n\nstatic u16 boot_loader_test_external_memory(struct hpi_adapter_obj *pao,\n\tint dsp_index);\n\nstatic u16 boot_loader_test_pld(struct hpi_adapter_obj *pao, int dsp_index);\n\n \n\nstatic void subsys_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tsubsys_create_adapter(phm, phr);\n\t\tbreak;\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\t}\n}\n\nstatic void control_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu16 pending_cache_error = 0;\n\n\tswitch (phm->function) {\n\tcase HPI_CONTROL_GET_STATE:\n\t\tif (pao->has_control_cache) {\n\t\t\trmb();\t \n\t\t\tif (hpi_check_control_cache(phw->p_cache, phm, phr)) {\n\t\t\t\tbreak;\n\t\t\t} else if (phm->u.c.attribute == HPI_METER_PEAK) {\n\t\t\t\tpending_cache_error =\n\t\t\t\t\tHPI_ERROR_CONTROL_CACHING;\n\t\t\t}\n\t\t}\n\t\thw_message(pao, phm, phr);\n\t\tif (pending_cache_error && !phr->error)\n\t\t\tphr->error = pending_cache_error;\n\t\tbreak;\n\tcase HPI_CONTROL_GET_INFO:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_CONTROL_SET_STATE:\n\t\thw_message(pao, phm, phr);\n\t\tif (pao->has_control_cache)\n\t\t\thpi_cmn_control_cache_sync_to_msg(phw->p_cache, phm,\n\t\t\t\tphr);\n\t\tbreak;\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_FUNC;\n\t\tbreak;\n\t}\n}\n\nstatic void adapter_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tswitch (phm->function) {\n\tcase HPI_ADAPTER_DELETE:\n\t\tadapter_delete(pao, phm, phr);\n\t\tbreak;\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void outstream_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\n\tif (phm->obj_index >= HPI_MAX_STREAMS) {\n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\"Message referencing invalid stream %d \"\n\t\t\t\"on adapter index %d\\n\", phm->obj_index,\n\t\t\tphm->adapter_index);\n\t\treturn;\n\t}\n\n\tswitch (phm->function) {\n\tcase HPI_OSTREAM_WRITE:\n\t\toutstream_write(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_GET_INFO:\n\t\toutstream_get_info(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_HOSTBUFFER_ALLOC:\n\t\toutstream_host_buffer_allocate(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_HOSTBUFFER_GET_INFO:\n\t\toutstream_host_buffer_get_info(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_HOSTBUFFER_FREE:\n\t\toutstream_host_buffer_free(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_START:\n\t\toutstream_start(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_OPEN:\n\t\toutstream_open(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_OSTREAM_RESET:\n\t\toutstream_reset(pao, phm, phr);\n\t\tbreak;\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\t}\n}\n\nstatic void instream_message(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\n\tif (phm->obj_index >= HPI_MAX_STREAMS) {\n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\"Message referencing invalid stream %d \"\n\t\t\t\"on adapter index %d\\n\", phm->obj_index,\n\t\t\tphm->adapter_index);\n\t\treturn;\n\t}\n\n\tswitch (phm->function) {\n\tcase HPI_ISTREAM_READ:\n\t\tinstream_read(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_GET_INFO:\n\t\tinstream_get_info(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_HOSTBUFFER_ALLOC:\n\t\tinstream_host_buffer_allocate(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_HOSTBUFFER_GET_INFO:\n\t\tinstream_host_buffer_get_info(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_HOSTBUFFER_FREE:\n\t\tinstream_host_buffer_free(pao, phm, phr);\n\t\tbreak;\n\tcase HPI_ISTREAM_START:\n\t\tinstream_start(pao, phm, phr);\n\t\tbreak;\n\tdefault:\n\t\thw_message(pao, phm, phr);\n\t\tbreak;\n\t}\n}\n\n \n \nstatic\nvoid _HPI_6205(struct hpi_adapter_obj *pao, struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\tif (pao && (pao->dsp_crashed >= 10)\n\t\t&& (phm->function != HPI_ADAPTER_DEBUG_READ)) {\n\t\t \n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_DSP_HARDWARE);\n\t\tHPI_DEBUG_LOG(WARNING, \" %d,%d dsp crashed.\\n\", phm->object,\n\t\t\tphm->function);\n\t\treturn;\n\t}\n\n\t \n\tif (phm->function != HPI_SUBSYS_CREATE_ADAPTER)\n\t\tphr->error = HPI_ERROR_PROCESSING_MESSAGE;\n\n\tHPI_DEBUG_LOG(VERBOSE, \"start of switch\\n\");\n\tswitch (phm->type) {\n\tcase HPI_TYPE_REQUEST:\n\t\tswitch (phm->object) {\n\t\tcase HPI_OBJ_SUBSYSTEM:\n\t\t\tsubsys_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_ADAPTER:\n\t\t\tadapter_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_CONTROL:\n\t\t\tcontrol_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_OSTREAM:\n\t\t\toutstream_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tcase HPI_OBJ_ISTREAM:\n\t\t\tinstream_message(pao, phm, phr);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\thw_message(pao, phm, phr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tphr->error = HPI_ERROR_INVALID_TYPE;\n\t\tbreak;\n\t}\n}\n\nvoid HPI_6205(struct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_adapter_obj *pao = NULL;\n\n\tif (phm->object != HPI_OBJ_SUBSYSTEM) {\n\t\t \n\t\tpao = hpi_find_adapter(phm->adapter_index);\n\t} else {\n\t\t \n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\t\treturn;\n\t}\n\n\tif (pao)\n\t\t_HPI_6205(pao, phm, phr);\n\telse\n\t\thpi_init_response(phr, phm->object, phm->function,\n\t\t\tHPI_ERROR_BAD_ADAPTER_NUMBER);\n}\n\n \n \n\n \nstatic void subsys_create_adapter(struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\t \n\tstruct hpi_adapter_obj ao;\n\tu32 os_error_code;\n\tu16 err;\n\n\tHPI_DEBUG_LOG(DEBUG, \" subsys_create_adapter\\n\");\n\n\tmemset(&ao, 0, sizeof(ao));\n\n\tao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);\n\tif (!ao.priv) {\n\t\tHPI_DEBUG_LOG(ERROR, \"can't get mem for adapter object\\n\");\n\t\tphr->error = HPI_ERROR_MEMORY_ALLOC;\n\t\treturn;\n\t}\n\n\tao.pci = *phm->u.s.resource.r.pci;\n\terr = create_adapter_obj(&ao, &os_error_code);\n\tif (err) {\n\t\tdelete_adapter_obj(&ao);\n\t\tif (err >= HPI_ERROR_BACKEND_BASE) {\n\t\t\tphr->error = HPI_ERROR_DSP_BOOTLOAD;\n\t\t\tphr->specific_error = err;\n\t\t} else {\n\t\t\tphr->error = err;\n\t\t}\n\t\tphr->u.s.data = os_error_code;\n\t\treturn;\n\t}\n\n\tphr->u.s.adapter_type = ao.type;\n\tphr->u.s.adapter_index = ao.index;\n\tphr->error = 0;\n}\n\n \nstatic void adapter_delete(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw;\n\n\tif (!pao) {\n\t\tphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\n\t\treturn;\n\t}\n\tphw = pao->priv;\n\t \n\t \n\tboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 0);\n\t \n\tiowrite32(C6205_HDCR_WARMRESET, phw->prHDCR);\n\n\tdelete_adapter_obj(pao);\n\thpi_delete_adapter(pao);\n\tphr->error = 0;\n}\n\n \nstatic u16 create_adapter_obj(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface;\n\tu32 phys_addr;\n\tint i;\n\tu16 err;\n\n\t \n\tpao->dsp_crashed = 0;\n\n\tfor (i = 0; i < HPI_MAX_STREAMS; i++)\n\t\tphw->flag_outstream_just_reset[i] = 1;\n\n\t \n\tphw->prHSR =\n\t\tpao->pci.ap_mem_base[1] +\n\t\tC6205_BAR1_HSR / sizeof(*pao->pci.ap_mem_base[1]);\n\tphw->prHDCR =\n\t\tpao->pci.ap_mem_base[1] +\n\t\tC6205_BAR1_HDCR / sizeof(*pao->pci.ap_mem_base[1]);\n\tphw->prDSPP =\n\t\tpao->pci.ap_mem_base[1] +\n\t\tC6205_BAR1_DSPP / sizeof(*pao->pci.ap_mem_base[1]);\n\n\tpao->has_control_cache = 0;\n\n\tif (hpios_locked_mem_alloc(&phw->h_locked_mem,\n\t\t\tsizeof(struct bus_master_interface),\n\t\t\tpao->pci.pci_dev))\n\t\tphw->p_interface_buffer = NULL;\n\telse if (hpios_locked_mem_get_virt_addr(&phw->h_locked_mem,\n\t\t\t(void *)&phw->p_interface_buffer))\n\t\tphw->p_interface_buffer = NULL;\n\n\tHPI_DEBUG_LOG(DEBUG, \"interface buffer address %p\\n\",\n\t\tphw->p_interface_buffer);\n\n\tif (phw->p_interface_buffer) {\n\t\tmemset((void *)phw->p_interface_buffer, 0,\n\t\t\tsizeof(struct bus_master_interface));\n\t\tphw->p_interface_buffer->dsp_ack = H620_HIF_UNKNOWN;\n\t}\n\n\terr = adapter_boot_load_dsp(pao, pos_error_code);\n\tif (err) {\n\t\tHPI_DEBUG_LOG(ERROR, \"DSP code load failed\\n\");\n\t\t \n\t\t \n\t\treturn err;\n\t}\n\tHPI_DEBUG_LOG(INFO, \"load DSP code OK\\n\");\n\n\t \n\tif (!phw->p_interface_buffer)\n\t\treturn HPI_ERROR_MEMORY_ALLOC;\n\n\tinterface = phw->p_interface_buffer;\n\n\t \n\tif (!wait_dsp_ack(phw, H620_HIF_RESET, HPI6205_TIMEOUT * 10)) {\n\t\tHPI_DEBUG_LOG(ERROR, \"timed out waiting reset state \\n\");\n\t\treturn HPI6205_ERROR_6205_INIT_FAILED;\n\t}\n\t \n\tif (interface->control_cache.number_of_controls) {\n\t\tu8 *p_control_cache_virtual;\n\n\t\terr = hpios_locked_mem_alloc(&phw->h_control_cache,\n\t\t\tinterface->control_cache.size_in_bytes,\n\t\t\tpao->pci.pci_dev);\n\t\tif (!err)\n\t\t\terr = hpios_locked_mem_get_virt_addr(&phw->\n\t\t\t\th_control_cache,\n\t\t\t\t(void *)&p_control_cache_virtual);\n\t\tif (!err) {\n\t\t\tmemset(p_control_cache_virtual, 0,\n\t\t\t\tinterface->control_cache.size_in_bytes);\n\n\t\t\tphw->p_cache =\n\t\t\t\thpi_alloc_control_cache(interface->\n\t\t\t\tcontrol_cache.number_of_controls,\n\t\t\t\tinterface->control_cache.size_in_bytes,\n\t\t\t\tp_control_cache_virtual);\n\n\t\t\tif (!phw->p_cache)\n\t\t\t\terr = HPI_ERROR_MEMORY_ALLOC;\n\t\t}\n\t\tif (!err) {\n\t\t\terr = hpios_locked_mem_get_phys_addr(&phw->\n\t\t\t\th_control_cache, &phys_addr);\n\t\t\tinterface->control_cache.physical_address32 =\n\t\t\t\tphys_addr;\n\t\t}\n\n\t\tif (!err)\n\t\t\tpao->has_control_cache = 1;\n\t\telse {\n\t\t\tif (hpios_locked_mem_valid(&phw->h_control_cache))\n\t\t\t\thpios_locked_mem_free(&phw->h_control_cache);\n\t\t\tpao->has_control_cache = 0;\n\t\t}\n\t}\n\tsend_dsp_command(phw, H620_HIF_IDLE);\n\n\t{\n\t\tstruct hpi_message hm;\n\t\tstruct hpi_response hr;\n\n\t\tHPI_DEBUG_LOG(VERBOSE, \"init ADAPTER_GET_INFO\\n\");\n\t\tmemset(&hm, 0, sizeof(hm));\n\t\t \n\t\thm.type = HPI_TYPE_REQUEST;\n\t\thm.size = sizeof(hm);\n\t\thm.object = HPI_OBJ_ADAPTER;\n\t\thm.function = HPI_ADAPTER_GET_INFO;\n\n\t\tmemset(&hr, 0, sizeof(hr));\n\t\thr.size = sizeof(hr);\n\n\t\terr = message_response_sequence(pao, &hm, &hr);\n\t\tif (err) {\n\t\t\tHPI_DEBUG_LOG(ERROR, \"message transport error %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t\tif (hr.error)\n\t\t\treturn hr.error;\n\n\t\tpao->type = hr.u.ax.info.adapter_type;\n\t\tpao->index = hr.u.ax.info.adapter_index;\n\n\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\"got adapter info type %x index %d serial %d\\n\",\n\t\t\thr.u.ax.info.adapter_type, hr.u.ax.info.adapter_index,\n\t\t\thr.u.ax.info.serial_number);\n\t}\n\n\tif (phw->p_cache)\n\t\tphw->p_cache->adap_idx = pao->index;\n\n\tHPI_DEBUG_LOG(INFO, \"bootload DSP OK\\n\");\n\n\tpao->irq_query_and_clear = adapter_irq_query_and_clear;\n\tpao->instream_host_buffer_status =\n\t\tphw->p_interface_buffer->instream_host_buffer_status;\n\tpao->outstream_host_buffer_status =\n\t\tphw->p_interface_buffer->outstream_host_buffer_status;\n\n\treturn hpi_add_adapter(pao);\n}\n\n \nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tint i;\n\n\tif (hpios_locked_mem_valid(&phw->h_control_cache)) {\n\t\thpios_locked_mem_free(&phw->h_control_cache);\n\t\thpi_free_control_cache(phw->p_cache);\n\t}\n\n\tif (hpios_locked_mem_valid(&phw->h_locked_mem)) {\n\t\thpios_locked_mem_free(&phw->h_locked_mem);\n\t\tphw->p_interface_buffer = NULL;\n\t}\n\n\tfor (i = 0; i < HPI_MAX_STREAMS; i++)\n\t\tif (hpios_locked_mem_valid(&phw->instream_host_buffers[i])) {\n\t\t\thpios_locked_mem_free(&phw->instream_host_buffers[i]);\n\t\t\t \n\t\t\tphw->instream_host_buffer_size[i] = 0;\n\t\t}\n\n\tfor (i = 0; i < HPI_MAX_STREAMS; i++)\n\t\tif (hpios_locked_mem_valid(&phw->outstream_host_buffers[i])) {\n\t\t\thpios_locked_mem_free(&phw->outstream_host_buffers\n\t\t\t\t[i]);\n\t\t\tphw->outstream_host_buffer_size[i] = 0;\n\t\t}\n\tkfree(phw);\n}\n\n \n \nstatic int adapter_irq_query_and_clear(struct hpi_adapter_obj *pao,\n\tu32 message)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu32 hsr = 0;\n\n\thsr = ioread32(phw->prHSR);\n\tif (hsr & C6205_HSR_INTSRC) {\n\t\t \n\t\tiowrite32(C6205_HSR_INTSRC, phw->prHSR);\n\t\treturn HPI_IRQ_MIXER;\n\t}\n\n\treturn HPI_IRQ_NONE;\n}\n\n \n \n\n \nstatic void outstream_host_buffer_allocate(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tu16 err = 0;\n\tu32 command = phm->u.d.u.buffer.command;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\n\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t|| command == HPI_BUFFER_CMD_INTERNAL_ALLOC) {\n\t\t \n\t\tphm->u.d.u.buffer.buffer_size =\n\t\t\troundup_pow_of_two(phm->u.d.u.buffer.buffer_size);\n\t\t \n\t\tphr->u.d.u.stream_info.data_available =\n\t\t\tphw->outstream_host_buffer_size[phm->obj_index];\n\t\tphr->u.d.u.stream_info.buffer_size =\n\t\t\tphm->u.d.u.buffer.buffer_size;\n\n\t\tif (phw->outstream_host_buffer_size[phm->obj_index] ==\n\t\t\tphm->u.d.u.buffer.buffer_size) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\n\t\t\t\t\tobj_index]))\n\t\t\thpios_locked_mem_free(&phw->outstream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\n\t\terr = hpios_locked_mem_alloc(&phw->outstream_host_buffers\n\t\t\t[phm->obj_index], phm->u.d.u.buffer.buffer_size,\n\t\t\tpao->pci.pci_dev);\n\n\t\tif (err) {\n\t\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\t\tphw->outstream_host_buffer_size[phm->obj_index] = 0;\n\t\t\treturn;\n\t\t}\n\n\t\terr = hpios_locked_mem_get_phys_addr\n\t\t\t(&phw->outstream_host_buffers[phm->obj_index],\n\t\t\t&phm->u.d.u.buffer.pci_address);\n\t\t \n\t\tphr->u.d.u.stream_info.auxiliary_data_available =\n\t\t\tphm->u.d.u.buffer.pci_address;\n\n\t\tif (err) {\n\t\t\thpios_locked_mem_free(&phw->outstream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\t\t\tphw->outstream_host_buffer_size[phm->obj_index] = 0;\n\t\t\tphr->error = HPI_ERROR_MEMORY_ALLOC;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t|| command == HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER) {\n\t\t \n\t\tstruct hpi_hostbuffer_status *status;\n\n\t\tif (phm->u.d.u.buffer.buffer_size & (phm->u.d.u.buffer.\n\t\t\t\tbuffer_size - 1)) {\n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"Buffer size must be 2^N not %d\\n\",\n\t\t\t\tphm->u.d.u.buffer.buffer_size);\n\t\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\t\treturn;\n\t\t}\n\t\tphw->outstream_host_buffer_size[phm->obj_index] =\n\t\t\tphm->u.d.u.buffer.buffer_size;\n\t\tstatus = &interface->outstream_host_buffer_status[phm->\n\t\t\tobj_index];\n\t\tstatus->samples_processed = 0;\n\t\tstatus->stream_state = HPI_STATE_STOPPED;\n\t\tstatus->dsp_index = 0;\n\t\tstatus->host_index = status->dsp_index;\n\t\tstatus->size_in_bytes = phm->u.d.u.buffer.buffer_size;\n\t\tstatus->auxiliary_data_available = 0;\n\n\t\thw_message(pao, phm, phr);\n\n\t\tif (phr->error\n\t\t\t&& hpios_locked_mem_valid(&phw->\n\t\t\t\toutstream_host_buffers[phm->obj_index])) {\n\t\t\thpios_locked_mem_free(&phw->outstream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\t\t\tphw->outstream_host_buffer_size[phm->obj_index] = 0;\n\t\t}\n\t}\n}\n\nstatic void outstream_host_buffer_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\tu8 *p_bbm_data;\n\n\tif (hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\n\t\t\t\tobj_index])) {\n\t\tif (hpios_locked_mem_get_virt_addr(&phw->\n\t\t\t\toutstream_host_buffers[phm->obj_index],\n\t\t\t\t(void *)&p_bbm_data)) {\n\t\t\tphr->error = HPI_ERROR_INVALID_OPERATION;\n\t\t\treturn;\n\t\t}\n\t\tstatus = &interface->outstream_host_buffer_status[phm->\n\t\t\tobj_index];\n\t\thpi_init_response(phr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_HOSTBUFFER_GET_INFO, 0);\n\t\tphr->u.d.u.hostbuffer_info.p_buffer = p_bbm_data;\n\t\tphr->u.d.u.hostbuffer_info.p_status = status;\n\t} else {\n\t\thpi_init_response(phr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_HOSTBUFFER_GET_INFO,\n\t\t\tHPI_ERROR_INVALID_OPERATION);\n\t}\n}\n\nstatic void outstream_host_buffer_free(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu32 command = phm->u.d.u.buffer.command;\n\n\tif (phw->outstream_host_buffer_size[phm->obj_index]) {\n\t\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t\t|| command == HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER) {\n\t\t\tphw->outstream_host_buffer_size[phm->obj_index] = 0;\n\t\t\thw_message(pao, phm, phr);\n\t\t\t \n\t\t}\n\t\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t\t|| command == HPI_BUFFER_CMD_INTERNAL_FREE)\n\t\t\thpios_locked_mem_free(&phw->outstream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\t}\n\t \n\telse\n\t\thpi_init_response(phr, HPI_OBJ_OSTREAM,\n\t\t\tHPI_OSTREAM_HOSTBUFFER_FREE, 0);\n\n}\n\nstatic u32 outstream_get_space_available(struct hpi_hostbuffer_status *status)\n{\n\treturn status->size_in_bytes - (status->host_index -\n\t\tstatus->dsp_index);\n}\n\nstatic void outstream_write(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\tu32 space_available;\n\n\tif (!phw->outstream_host_buffer_size[phm->obj_index]) {\n\t\t \n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\tstatus = &interface->outstream_host_buffer_status[phm->obj_index];\n\n\tspace_available = outstream_get_space_available(status);\n\tif (space_available < phm->u.d.u.data.data_size) {\n\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\treturn;\n\t}\n\n\t \n\tif (phm->u.d.u.data.pb_data\n\t\t&& hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\n\t\t\t\tobj_index])) {\n\t\tu8 *p_bbm_data;\n\t\tu32 l_first_write;\n\t\tu8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;\n\n\t\tif (hpios_locked_mem_get_virt_addr(&phw->\n\t\t\t\toutstream_host_buffers[phm->obj_index],\n\t\t\t\t(void *)&p_bbm_data)) {\n\t\t\tphr->error = HPI_ERROR_INVALID_OPERATION;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tl_first_write =\n\t\t\tmin(phm->u.d.u.data.data_size,\n\t\t\tstatus->size_in_bytes -\n\t\t\t(status->host_index & (status->size_in_bytes - 1)));\n\n\t\tmemcpy(p_bbm_data +\n\t\t\t(status->host_index & (status->size_in_bytes - 1)),\n\t\t\tp_app_data, l_first_write);\n\t\t \n\t\tmemcpy(p_bbm_data, p_app_data + l_first_write,\n\t\t\tphm->u.d.u.data.data_size - l_first_write);\n\t}\n\n\t \n\tif (phw->flag_outstream_just_reset[phm->obj_index]) {\n\t\t \n\t\tu16 function = phm->function;\n\t\tphw->flag_outstream_just_reset[phm->obj_index] = 0;\n\t\tphm->function = HPI_OSTREAM_SET_FORMAT;\n\t\thw_message(pao, phm, phr);\t \n\t\tphm->function = function;\n\t\tif (phr->error)\n\t\t\treturn;\n\t}\n\n\tstatus->host_index += phm->u.d.u.data.data_size;\n}\n\nstatic void outstream_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\n\tif (!phw->outstream_host_buffer_size[phm->obj_index]) {\n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\n\tstatus = &interface->outstream_host_buffer_status[phm->obj_index];\n\n\tphr->u.d.u.stream_info.state = (u16)status->stream_state;\n\tphr->u.d.u.stream_info.samples_transferred =\n\t\tstatus->samples_processed;\n\tphr->u.d.u.stream_info.buffer_size = status->size_in_bytes;\n\tphr->u.d.u.stream_info.data_available =\n\t\tstatus->size_in_bytes - outstream_get_space_available(status);\n\tphr->u.d.u.stream_info.auxiliary_data_available =\n\t\tstatus->auxiliary_data_available;\n}\n\nstatic void outstream_start(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\thw_message(pao, phm, phr);\n}\n\nstatic void outstream_reset(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tphw->flag_outstream_just_reset[phm->obj_index] = 1;\n\thw_message(pao, phm, phr);\n}\n\nstatic void outstream_open(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\toutstream_reset(pao, phm, phr);\n}\n\n \n \n\nstatic void instream_host_buffer_allocate(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tu16 err = 0;\n\tu32 command = phm->u.d.u.buffer.command;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\n\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t|| command == HPI_BUFFER_CMD_INTERNAL_ALLOC) {\n\n\t\tphm->u.d.u.buffer.buffer_size =\n\t\t\troundup_pow_of_two(phm->u.d.u.buffer.buffer_size);\n\t\tphr->u.d.u.stream_info.data_available =\n\t\t\tphw->instream_host_buffer_size[phm->obj_index];\n\t\tphr->u.d.u.stream_info.buffer_size =\n\t\t\tphm->u.d.u.buffer.buffer_size;\n\n\t\tif (phw->instream_host_buffer_size[phm->obj_index] ==\n\t\t\tphm->u.d.u.buffer.buffer_size) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\n\t\t\t\t\tobj_index]))\n\t\t\thpios_locked_mem_free(&phw->instream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\n\t\terr = hpios_locked_mem_alloc(&phw->instream_host_buffers[phm->\n\t\t\t\tobj_index], phm->u.d.u.buffer.buffer_size,\n\t\t\tpao->pci.pci_dev);\n\n\t\tif (err) {\n\t\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\t\tphw->instream_host_buffer_size[phm->obj_index] = 0;\n\t\t\treturn;\n\t\t}\n\n\t\terr = hpios_locked_mem_get_phys_addr\n\t\t\t(&phw->instream_host_buffers[phm->obj_index],\n\t\t\t&phm->u.d.u.buffer.pci_address);\n\t\t \n\t\tphr->u.d.u.stream_info.auxiliary_data_available =\n\t\t\tphm->u.d.u.buffer.pci_address;\n\t\tif (err) {\n\t\t\thpios_locked_mem_free(&phw->instream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\t\t\tphw->instream_host_buffer_size[phm->obj_index] = 0;\n\t\t\tphr->error = HPI_ERROR_MEMORY_ALLOC;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t|| command == HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER) {\n\t\tstruct hpi_hostbuffer_status *status;\n\n\t\tif (phm->u.d.u.buffer.buffer_size & (phm->u.d.u.buffer.\n\t\t\t\tbuffer_size - 1)) {\n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"Buffer size must be 2^N not %d\\n\",\n\t\t\t\tphm->u.d.u.buffer.buffer_size);\n\t\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\t\treturn;\n\t\t}\n\n\t\tphw->instream_host_buffer_size[phm->obj_index] =\n\t\t\tphm->u.d.u.buffer.buffer_size;\n\t\tstatus = &interface->instream_host_buffer_status[phm->\n\t\t\tobj_index];\n\t\tstatus->samples_processed = 0;\n\t\tstatus->stream_state = HPI_STATE_STOPPED;\n\t\tstatus->dsp_index = 0;\n\t\tstatus->host_index = status->dsp_index;\n\t\tstatus->size_in_bytes = phm->u.d.u.buffer.buffer_size;\n\t\tstatus->auxiliary_data_available = 0;\n\n\t\thw_message(pao, phm, phr);\n\n\t\tif (phr->error\n\t\t\t&& hpios_locked_mem_valid(&phw->\n\t\t\t\tinstream_host_buffers[phm->obj_index])) {\n\t\t\thpios_locked_mem_free(&phw->instream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\t\t\tphw->instream_host_buffer_size[phm->obj_index] = 0;\n\t\t}\n\t}\n}\n\nstatic void instream_host_buffer_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\tu8 *p_bbm_data;\n\n\tif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\n\t\t\t\tobj_index])) {\n\t\tif (hpios_locked_mem_get_virt_addr(&phw->\n\t\t\t\tinstream_host_buffers[phm->obj_index],\n\t\t\t\t(void *)&p_bbm_data)) {\n\t\t\tphr->error = HPI_ERROR_INVALID_OPERATION;\n\t\t\treturn;\n\t\t}\n\t\tstatus = &interface->instream_host_buffer_status[phm->\n\t\t\tobj_index];\n\t\thpi_init_response(phr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_HOSTBUFFER_GET_INFO, 0);\n\t\tphr->u.d.u.hostbuffer_info.p_buffer = p_bbm_data;\n\t\tphr->u.d.u.hostbuffer_info.p_status = status;\n\t} else {\n\t\thpi_init_response(phr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_HOSTBUFFER_GET_INFO,\n\t\t\tHPI_ERROR_INVALID_OPERATION);\n\t}\n}\n\nstatic void instream_host_buffer_free(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu32 command = phm->u.d.u.buffer.command;\n\n\tif (phw->instream_host_buffer_size[phm->obj_index]) {\n\t\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t\t|| command == HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER) {\n\t\t\tphw->instream_host_buffer_size[phm->obj_index] = 0;\n\t\t\thw_message(pao, phm, phr);\n\t\t}\n\n\t\tif (command == HPI_BUFFER_CMD_EXTERNAL\n\t\t\t|| command == HPI_BUFFER_CMD_INTERNAL_FREE)\n\t\t\thpios_locked_mem_free(&phw->instream_host_buffers\n\t\t\t\t[phm->obj_index]);\n\n\t} else {\n\t\t \n\t\thpi_init_response(phr, HPI_OBJ_ISTREAM,\n\t\t\tHPI_ISTREAM_HOSTBUFFER_FREE, 0);\n\n\t}\n\n}\n\nstatic void instream_start(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\thw_message(pao, phm, phr);\n}\n\nstatic u32 instream_get_bytes_available(struct hpi_hostbuffer_status *status)\n{\n\treturn status->dsp_index - status->host_index;\n}\n\nstatic void instream_read(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\tu32 data_available;\n\tu8 *p_bbm_data;\n\tu32 l_first_read;\n\tu8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;\n\n\tif (!phw->instream_host_buffer_size[phm->obj_index]) {\n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\n\tstatus = &interface->instream_host_buffer_status[phm->obj_index];\n\tdata_available = instream_get_bytes_available(status);\n\tif (data_available < phm->u.d.u.data.data_size) {\n\t\tphr->error = HPI_ERROR_INVALID_DATASIZE;\n\t\treturn;\n\t}\n\n\tif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\n\t\t\t\tobj_index])) {\n\t\tif (hpios_locked_mem_get_virt_addr(&phw->\n\t\t\t\tinstream_host_buffers[phm->obj_index],\n\t\t\t\t(void *)&p_bbm_data)) {\n\t\t\tphr->error = HPI_ERROR_INVALID_OPERATION;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tl_first_read =\n\t\t\tmin(phm->u.d.u.data.data_size,\n\t\t\tstatus->size_in_bytes -\n\t\t\t(status->host_index & (status->size_in_bytes - 1)));\n\n\t\tmemcpy(p_app_data,\n\t\t\tp_bbm_data +\n\t\t\t(status->host_index & (status->size_in_bytes - 1)),\n\t\t\tl_first_read);\n\t\t \n\t\tmemcpy(p_app_data + l_first_read, p_bbm_data,\n\t\t\tphm->u.d.u.data.data_size - l_first_read);\n\t}\n\tstatus->host_index += phm->u.d.u.data.data_size;\n}\n\nstatic void instream_get_info(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tstruct hpi_hostbuffer_status *status;\n\tif (!phw->instream_host_buffer_size[phm->obj_index]) {\n\t\thw_message(pao, phm, phr);\n\t\treturn;\n\t}\n\n\tstatus = &interface->instream_host_buffer_status[phm->obj_index];\n\n\thpi_init_response(phr, phm->object, phm->function, 0);\n\n\tphr->u.d.u.stream_info.state = (u16)status->stream_state;\n\tphr->u.d.u.stream_info.samples_transferred =\n\t\tstatus->samples_processed;\n\tphr->u.d.u.stream_info.buffer_size = status->size_in_bytes;\n\tphr->u.d.u.stream_info.data_available =\n\t\tinstream_get_bytes_available(status);\n\tphr->u.d.u.stream_info.auxiliary_data_available =\n\t\tstatus->auxiliary_data_available;\n}\n\n \n \n#define HPI6205_MAX_FILES_TO_LOAD 2\n\nstatic u16 adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\n\tu32 *pos_error_code)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct dsp_code dsp_code;\n\tu16 boot_code_id[HPI6205_MAX_FILES_TO_LOAD];\n\tu32 temp;\n\tint dsp = 0, i = 0;\n\tu16 err = 0;\n\n\tboot_code_id[0] = HPI_ADAPTER_ASI(0x6205);\n\n\tboot_code_id[1] = pao->pci.pci_dev->subsystem_device;\n\tboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(boot_code_id[1]);\n\n\t \n\tswitch (boot_code_id[1]) {\n\tcase HPI_ADAPTER_FAMILY_ASI(0x5000):\n\t\tboot_code_id[0] = boot_code_id[1];\n\t\tboot_code_id[1] = 0;\n\t\tbreak;\n\tcase HPI_ADAPTER_FAMILY_ASI(0x5300):\n\tcase HPI_ADAPTER_FAMILY_ASI(0x5400):\n\tcase HPI_ADAPTER_FAMILY_ASI(0x6300):\n\t\tboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6400);\n\t\tbreak;\n\tcase HPI_ADAPTER_FAMILY_ASI(0x5500):\n\tcase HPI_ADAPTER_FAMILY_ASI(0x5600):\n\tcase HPI_ADAPTER_FAMILY_ASI(0x6500):\n\t\tboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6600);\n\t\tbreak;\n\tcase HPI_ADAPTER_FAMILY_ASI(0x8800):\n\t\tboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x8900);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ttemp = C6205_HDCR_WARMRESET;\n\tiowrite32(temp, phw->prHDCR);\n\thpios_delay_micro_seconds(1000);\n\n\t \n\ttemp = ioread32(phw->prHSR);\n\tif ((temp & (C6205_HSR_CFGERR | C6205_HSR_EEREAD)) !=\n\t\tC6205_HSR_EEREAD)\n\t\treturn HPI6205_ERROR_6205_EEPROM;\n\ttemp |= 0x04;\n\t \n\tiowrite32(temp, phw->prHSR);\n\n\t \n\ttemp = ioread32(phw->prHDCR);\n\tif (!(temp & C6205_HDCR_PCIBOOT))\n\t\treturn HPI6205_ERROR_6205_REG;\n\n\t \n\t \n\ttemp = 3;\n\tiowrite32(temp, phw->prDSPP);\n\tif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\n\t\treturn HPI6205_ERROR_6205_DSPPAGE;\n\ttemp = 2;\n\tiowrite32(temp, phw->prDSPP);\n\tif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\n\t\treturn HPI6205_ERROR_6205_DSPPAGE;\n\ttemp = 1;\n\tiowrite32(temp, phw->prDSPP);\n\tif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\n\t\treturn HPI6205_ERROR_6205_DSPPAGE;\n\t \n\ttemp = 0;\n\tiowrite32(temp, phw->prDSPP);\n\tif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\n\t\treturn HPI6205_ERROR_6205_DSPPAGE;\n\tphw->dsp_page = 0;\n\n\t \n\tif (boot_code_id[1] != 0) {\n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, 0, 0x018C0024, 0x00002202);\n\t\thpios_delay_micro_seconds(100);\n\t\t \n\t\tboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 0);\n\t\t \n\t\tif (0 != (boot_loader_read_mem32(pao, 0,\n\t\t\t\t\t(C6205_BAR0_TIMER1_CTL)) & ~8))\n\t\t\treturn HPI6205_ERROR_6205_REG;\n\t\thpios_delay_micro_seconds(100);\n\n\t\t \n\t\tboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 4);\n\t\tif (4 != (boot_loader_read_mem32(pao, 0,\n\t\t\t\t\t(C6205_BAR0_TIMER1_CTL)) & ~8))\n\t\t\treturn HPI6205_ERROR_6205_REG;\n\t\thpios_delay_micro_seconds(100);\n\t}\n\n\tfor (dsp = 0; dsp < HPI6205_MAX_FILES_TO_LOAD; dsp++) {\n\t\t \n\t\tif (boot_code_id[dsp] == 0)\n\t\t\tcontinue;\n\n\t\terr = boot_loader_config_emif(pao, dsp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = boot_loader_test_internal_memory(pao, dsp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = boot_loader_test_external_memory(pao, dsp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = boot_loader_test_pld(pao, dsp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = hpi_dsp_code_open(boot_code_id[dsp], pao->pci.pci_dev,\n\t\t\t&dsp_code, pos_error_code);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\twhile (1) {\n\t\t\tu32 length;\n\t\t\tu32 address;\n\t\t\tu32 type;\n\t\t\tu32 *pcode;\n\n\t\t\terr = hpi_dsp_code_read_word(&dsp_code, &length);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (length == 0xFFFFFFFF)\n\t\t\t\tbreak;\t \n\n\t\t\terr = hpi_dsp_code_read_word(&dsp_code, &address);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = hpi_dsp_code_read_word(&dsp_code, &type);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = hpi_dsp_code_read_block(length, &dsp_code,\n\t\t\t\t&pcode);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tfor (i = 0; i < (int)length; i++) {\n\t\t\t\tboot_loader_write_mem32(pao, dsp, address,\n\t\t\t\t\t*pcode);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (i % 4 == 0)\n\t\t\t\t\tboot_loader_read_mem32(pao, dsp,\n\t\t\t\t\t\taddress);\n\t\t\t\tpcode++;\n\t\t\t\taddress += 4;\n\t\t\t}\n\n\t\t}\n\t\tif (err) {\n\t\t\thpi_dsp_code_close(&dsp_code);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\thpi_dsp_code_rewind(&dsp_code);\n\t\twhile (1) {\n\t\t\tu32 length = 0;\n\t\t\tu32 address = 0;\n\t\t\tu32 type = 0;\n\t\t\tu32 *pcode = NULL;\n\t\t\tu32 data = 0;\n\n\t\t\thpi_dsp_code_read_word(&dsp_code, &length);\n\t\t\tif (length == 0xFFFFFFFF)\n\t\t\t\tbreak;\t \n\n\t\t\thpi_dsp_code_read_word(&dsp_code, &address);\n\t\t\thpi_dsp_code_read_word(&dsp_code, &type);\n\t\t\thpi_dsp_code_read_block(length, &dsp_code, &pcode);\n\n\t\t\tfor (i = 0; i < (int)length; i++) {\n\t\t\t\tdata = boot_loader_read_mem32(pao, dsp,\n\t\t\t\t\taddress);\n\t\t\t\tif (data != *pcode) {\n\t\t\t\t\terr = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpcode++;\n\t\t\t\taddress += 4;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\thpi_dsp_code_close(&dsp_code);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (phw->p_interface_buffer) {\n\t\t \n\t\tu32 physicalPC_iaddress;\n\t\tstruct bus_master_interface *interface =\n\t\t\tphw->p_interface_buffer;\n\t\tu32 host_mailbox_address_on_dsp;\n\t\tu32 physicalPC_iaddress_verify = 0;\n\t\tint time_out = 10;\n\t\t \n\t\t \n\t\tinterface->dsp_ack = H620_HIF_UNKNOWN;\n\t\twmb();\t \n\n\t\terr = hpios_locked_mem_get_phys_addr(&phw->h_locked_mem,\n\t\t\t&physicalPC_iaddress);\n\n\t\t \n\t\thost_mailbox_address_on_dsp = 0x80000000;\n\t\twhile ((physicalPC_iaddress != physicalPC_iaddress_verify)\n\t\t\t&& time_out--) {\n\t\t\tboot_loader_write_mem32(pao, 0,\n\t\t\t\thost_mailbox_address_on_dsp,\n\t\t\t\tphysicalPC_iaddress);\n\t\t\tphysicalPC_iaddress_verify =\n\t\t\t\tboot_loader_read_mem32(pao, 0,\n\t\t\t\thost_mailbox_address_on_dsp);\n\t\t}\n\t}\n\tHPI_DEBUG_LOG(DEBUG, \"starting DS_ps running\\n\");\n\t \n\ttemp = ioread32(phw->prHSR);\n\ttemp &= ~(u32)C6205_HSR_INTAM;\n\tiowrite32(temp, phw->prHSR);\n\n\t \n\ttemp = ioread32(phw->prHDCR);\n\ttemp |= (u32)C6205_HDCR_DSPINT;\n\tiowrite32(temp, phw->prHDCR);\n\n\t \n\thpios_delay_micro_seconds(10000);\n\treturn err;\n\n}\n\n \n \n\nstatic u32 boot_loader_read_mem32(struct hpi_adapter_obj *pao, int dsp_index,\n\tu32 address)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu32 data = 0;\n\t__iomem u32 *p_data;\n\n\tif (dsp_index == 0) {\n\t\t \n\t\tif ((address >= 0x01800000) & (address < 0x02000000)) {\n\t\t\t \n\t\t\tp_data = pao->pci.ap_mem_base[1] +\n\t\t\t\t(address & 0x007fffff) /\n\t\t\t\tsizeof(*pao->pci.ap_mem_base[1]);\n\t\t\t \n\t\t} else {\n\t\t\tu32 dw4M_page = address >> 22L;\n\t\t\tif (dw4M_page != phw->dsp_page) {\n\t\t\t\tphw->dsp_page = dw4M_page;\n\t\t\t\t \n\t\t\t\tiowrite32(phw->dsp_page, phw->prDSPP);\n\t\t\t\t \n\t\t\t}\n\t\t\taddress &= 0x3fffff;\t \n\t\t\t \n\t\t\tp_data = pao->pci.ap_mem_base[0] +\n\t\t\t\taddress / sizeof(u32);\n\t\t}\n\t\tdata = ioread32(p_data);\n\t} else if (dsp_index == 1) {\n\t\t \n\t\tu32 lsb;\n\t\tboot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);\n\t\tboot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);\n\t\tlsb = boot_loader_read_mem32(pao, 0, HPIDL_ADDR);\n\t\tdata = boot_loader_read_mem32(pao, 0, HPIDH_ADDR);\n\t\tdata = (data << 16) | (lsb & 0xFFFF);\n\t}\n\treturn data;\n}\n\nstatic void boot_loader_write_mem32(struct hpi_adapter_obj *pao,\n\tint dsp_index, u32 address, u32 data)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\t__iomem u32 *p_data;\n\t \n\n\tif (dsp_index == 0) {\n\t\t \n\t\tif ((address >= 0x01800000) & (address < 0x02000000)) {\n\t\t\t \n\t\t\t \n\t\t\tp_data = pao->pci.ap_mem_base[1] +\n\t\t\t\t(address & 0x007fffff) /\n\t\t\t\tsizeof(*pao->pci.ap_mem_base[1]);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tu32 dw4M_page = address >> 22L;\n\t\t\tif (dw4M_page != phw->dsp_page) {\n\t\t\t\tphw->dsp_page = dw4M_page;\n\t\t\t\t \n\t\t\t\tiowrite32(phw->dsp_page, phw->prDSPP);\n\t\t\t\t \n\t\t\t}\n\t\t\taddress &= 0x3fffff;\t \n\t\t\tp_data = pao->pci.ap_mem_base[0] +\n\t\t\t\taddress / sizeof(u32);\n\t\t}\n\t\tiowrite32(data, p_data);\n\t} else if (dsp_index == 1) {\n\t\t \n\t\tboot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);\n\t\tboot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);\n\n\t\t \n\t\tboot_loader_read_mem32(pao, 0, 0);\n\n\t\tboot_loader_write_mem32(pao, 0, HPIDL_ADDR, data);\n\t\tboot_loader_write_mem32(pao, 0, HPIDH_ADDR, data >> 16);\n\n\t\t \n\t\tboot_loader_read_mem32(pao, 0, 0);\n\t}\n}\n\nstatic u16 boot_loader_config_emif(struct hpi_adapter_obj *pao, int dsp_index)\n{\n\tif (dsp_index == 0) {\n\t\tu32 setting;\n\n\t\t \n\n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800000, 0x3779);\n#define WS_OFS 28\n#define WST_OFS 22\n#define WH_OFS 20\n#define RS_OFS 16\n#define RST_OFS 8\n#define MTYPE_OFS 4\n#define RH_OFS 0\n\n\t\t \n\t\tsetting = 0x00000030;\n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800008, setting);\n\t\tif (setting != boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x01800008))\n\t\t\treturn HPI6205_ERROR_DSP_EMIF1;\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tsetting =\n\t\t\t(1L << WS_OFS) | (63L << WST_OFS) | (1L << WH_OFS) |\n\t\t\t(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |\n\t\t\t(2L << MTYPE_OFS);\n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800004, setting);\n\t\tif (setting != boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x01800004))\n\t\t\treturn HPI6205_ERROR_DSP_EMIF2;\n\n\t\t \n\t\t \n\t\t \n\t\tsetting =\n\t\t\t(1L << WS_OFS) | (28L << WST_OFS) | (1L << WH_OFS) |\n\t\t\t(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |\n\t\t\t(2L << MTYPE_OFS);\n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800010, setting);\n\t\tif (setting != boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x01800010))\n\t\t\treturn HPI6205_ERROR_DSP_EMIF3;\n\n\t\t \n\t\t \n\t\tsetting =\n\t\t\t(1L << WS_OFS) | (10L << WST_OFS) | (1L << WH_OFS) |\n\t\t\t(1L << RS_OFS) | (10L << RST_OFS) | (1L << RH_OFS) |\n\t\t\t(2L << MTYPE_OFS);\n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800014, setting);\n\t\tif (setting != boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x01800014))\n\t\t\treturn HPI6205_ERROR_DSP_EMIF4;\n\n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01800018,\n\t\t\t0x07117000);\n\n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x0180001C,\n\t\t\t0x00000410);\n\n\t} else if (dsp_index == 1) {\n\t\t \n\t\tu32 write_data = 0, read_data = 0, i = 0;\n\n\t\t \n\t\twrite_data = 1;\n\t\tboot_loader_write_mem32(pao, 0, HPICL_ADDR, write_data);\n\t\tboot_loader_write_mem32(pao, 0, HPICH_ADDR, write_data);\n\t\t \n\t\tread_data =\n\t\t\t0xFFF7 & boot_loader_read_mem32(pao, 0, HPICL_ADDR);\n\t\tif (write_data != read_data) {\n\t\t\tHPI_DEBUG_LOG(ERROR, \"HPICL %x %x\\n\", write_data,\n\t\t\t\tread_data);\n\t\t\treturn HPI6205_ERROR_C6713_HPIC;\n\t\t}\n\t\t \n\t\twrite_data = 1;\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tboot_loader_write_mem32(pao, 0, HPIAL_ADDR,\n\t\t\t\twrite_data);\n\t\t\tboot_loader_write_mem32(pao, 0, HPIAH_ADDR,\n\t\t\t\t(write_data >> 16));\n\t\t\tread_data =\n\t\t\t\t0xFFFF & boot_loader_read_mem32(pao, 0,\n\t\t\t\tHPIAL_ADDR);\n\t\t\tread_data =\n\t\t\t\tread_data | ((0xFFFF &\n\t\t\t\t\tboot_loader_read_mem32(pao, 0,\n\t\t\t\t\t\tHPIAH_ADDR))\n\t\t\t\t<< 16);\n\t\t\tif (read_data != write_data) {\n\t\t\t\tHPI_DEBUG_LOG(ERROR, \"HPIA %x %x\\n\",\n\t\t\t\t\twrite_data, read_data);\n\t\t\t\treturn HPI6205_ERROR_C6713_HPIA;\n\t\t\t}\n\t\t\twrite_data = write_data << 1;\n\t\t}\n\n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0000);\n\t\thpios_delay_micro_seconds(1000);\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01B7C120, 0x8002);\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01B7C11C, 0x8001);\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01B7C118, 0x8000);\n\t\thpios_delay_micro_seconds(1000);\n\t\t \n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A0A);\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0001);\n\t\thpios_delay_micro_seconds(1000);\n\t\t \n\t\tboot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A02);\n\n\t\t \n\t\t \n\t\tboot_loader_write_mem32(pao, 0, 0x01800004,\t \n\t\t\t(1L << WS_OFS) | (8L << WST_OFS) | (1L << WH_OFS) |\n\t\t\t(1L << RS_OFS) | (12L << RST_OFS) | (1L << RH_OFS) |\n\t\t\t(2L << MTYPE_OFS));\n\n\t\thpios_delay_micro_seconds(1000);\n\n\t\t \n\t\t \n\t\tif ((boot_loader_read_mem32(pao, dsp_index, 0x01B7C100) & 0xF)\n\t\t\t!= 0x0001) {\n\t\t\treturn HPI6205_ERROR_C6713_PLL;\n\t\t}\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_GCTL,\n\t\t\t0x000034A8);\n\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_CE0,\n\t\t\t0x00000030);\n\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMEXT,\n\t\t\t0x001BDF29);\n\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMCTL,\n\t\t\t0x47116000);\n\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index,\n\t\t\tC6713_EMIF_SDRAMTIMING, 0x00000410);\n\n\t\thpios_delay_micro_seconds(1000);\n\t} else if (dsp_index == 2) {\n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic u16 boot_loader_test_memory(struct hpi_adapter_obj *pao, int dsp_index,\n\tu32 start_address, u32 length)\n{\n\tu32 i = 0, j = 0;\n\tu32 test_addr = 0;\n\tu32 test_data = 0, data = 0;\n\n\tlength = 1000;\n\n\t \n\t \n\t \n\ti = 0;\n\t{\n\t\ttest_addr = start_address + i * 4;\n\t\ttest_data = 0x00000001;\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tboot_loader_write_mem32(pao, dsp_index, test_addr,\n\t\t\t\ttest_data);\n\t\t\tdata = boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\ttest_addr);\n\t\t\tif (data != test_data) {\n\t\t\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\t\t\"Memtest error details  \"\n\t\t\t\t\t\"%08x %08x %08x %i\\n\", test_addr,\n\t\t\t\t\ttest_data, data, dsp_index);\n\t\t\t\treturn 1;\t \n\t\t\t}\n\t\t\ttest_data = test_data << 1;\n\t\t}\t \n\t}\t \n\n\t \n\t \n\t \n\tfor (i = 0; i < 100; i++) {\n\t\ttest_addr = start_address + i * 4;\n\t\ttest_data = 0xA5A55A5A;\n\t\tboot_loader_write_mem32(pao, dsp_index, test_addr, test_data);\n\t\tboot_loader_write_mem32(pao, dsp_index, test_addr + 4, 0);\n\t\tdata = boot_loader_read_mem32(pao, dsp_index, test_addr);\n\t\tif (data != test_data) {\n\t\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\t\"Memtest error details  \"\n\t\t\t\t\"%08x %08x %08x %i\\n\", test_addr, test_data,\n\t\t\t\tdata, dsp_index);\n\t\t\treturn 1;\t \n\t\t}\n\t\t \n\t\tboot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);\n\t}\n\n\t \n\tfor (i = 0; i < length; i++) {\n\t\ttest_addr = start_address + i * 4;\n\t\tboot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);\n\t}\n\treturn 0;\n}\n\nstatic u16 boot_loader_test_internal_memory(struct hpi_adapter_obj *pao,\n\tint dsp_index)\n{\n\tint err = 0;\n\tif (dsp_index == 0) {\n\t\t \n\t\t \n\t\terr = boot_loader_test_memory(pao, dsp_index, 0x00000000,\n\t\t\t0x10000);\n\t\tif (!err)\n\t\t\t \n\t\t\terr = boot_loader_test_memory(pao, dsp_index,\n\t\t\t\t0x80000000, 0x10000);\n\t} else if (dsp_index == 1) {\n\t\t \n\t\t \n\t\terr = boot_loader_test_memory(pao, dsp_index, 0x00000000,\n\t\t\t0x30000);\n\t\tif (!err)\n\t\t\t \n\t\t\terr = boot_loader_test_memory(pao, dsp_index,\n\t\t\t\t0x00030000, 0x10000);\n\t}\n\n\tif (err)\n\t\treturn HPI6205_ERROR_DSP_INTMEM;\n\telse\n\t\treturn 0;\n}\n\nstatic u16 boot_loader_test_external_memory(struct hpi_adapter_obj *pao,\n\tint dsp_index)\n{\n\tu32 dRAM_start_address = 0;\n\tu32 dRAM_size = 0;\n\n\tif (dsp_index == 0) {\n\t\t \n\t\tif (pao->pci.pci_dev->subsystem_device == 0x5000) {\n\t\t\t \n\t\t\tdRAM_start_address = 0x00400000;\n\t\t\tdRAM_size = 0x200000;\n\t\t\t \n\t\t} else\n\t\t\treturn 0;\n\t} else if (dsp_index == 1) {\n\t\t \n\t\tdRAM_start_address = 0x80000000;\n\t\tdRAM_size = 0x200000;\n\t\t \n\t}\n\n\tif (boot_loader_test_memory(pao, dsp_index, dRAM_start_address,\n\t\t\tdRAM_size))\n\t\treturn HPI6205_ERROR_DSP_EXTMEM;\n\treturn 0;\n}\n\nstatic u16 boot_loader_test_pld(struct hpi_adapter_obj *pao, int dsp_index)\n{\n\tu32 data = 0;\n\tif (dsp_index == 0) {\n\t\t \n\t\tif (pao->pci.pci_dev->subsystem_device == 0x5000) {\n\t\t\t \n\t\t\tdata = boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x03000008);\n\t\t\tif ((data & 0xF) != 0x5)\n\t\t\t\treturn HPI6205_ERROR_DSP_PLD;\n\t\t\tdata = boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x0300000C);\n\t\t\tif ((data & 0xF) != 0xA)\n\t\t\t\treturn HPI6205_ERROR_DSP_PLD;\n\t\t}\n\t} else if (dsp_index == 1) {\n\t\t \n\t\tif (pao->pci.pci_dev->subsystem_device == 0x8700) {\n\t\t\t \n\t\t\tdata = boot_loader_read_mem32(pao, dsp_index,\n\t\t\t\t0x90000010);\n\t\t\tif ((data & 0xFF) != 0xAA)\n\t\t\t\treturn HPI6205_ERROR_DSP_PLD;\n\t\t\t \n\t\t\tboot_loader_write_mem32(pao, dsp_index, 0x90000000,\n\t\t\t\t0x02);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic short hpi6205_transfer_data(struct hpi_adapter_obj *pao, u8 *p_data,\n\tu32 data_size, int operation)\n{\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tu32 data_transferred = 0;\n\tu16 err = 0;\n\tu32 temp2;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\n\tif (!p_data)\n\t\treturn HPI_ERROR_INVALID_DATA_POINTER;\n\n\tdata_size &= ~3L;\t \n\n\t \n\tif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT))\n\t\treturn HPI_ERROR_DSP_HARDWARE;\n\n\twhile (data_transferred < data_size) {\n\t\tu32 this_copy = data_size - data_transferred;\n\n\t\tif (this_copy > HPI6205_SIZEOF_DATA)\n\t\t\tthis_copy = HPI6205_SIZEOF_DATA;\n\n\t\tif (operation == H620_HIF_SEND_DATA)\n\t\t\tmemcpy((void *)&interface->u.b_data[0],\n\t\t\t\t&p_data[data_transferred], this_copy);\n\n\t\tinterface->transfer_size_in_bytes = this_copy;\n\n\t\t \n\t\tinterface->dsp_ack = H620_HIF_IDLE;\n\t\tsend_dsp_command(phw, operation);\n\n\t\ttemp2 = wait_dsp_ack(phw, operation, HPI6205_TIMEOUT);\n\t\tHPI_DEBUG_LOG(DEBUG, \"spun %d times for data xfer of %d\\n\",\n\t\t\tHPI6205_TIMEOUT - temp2, this_copy);\n\n\t\tif (!temp2) {\n\t\t\t \n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"Timed out waiting for \" \"state %d got %d\\n\",\n\t\t\t\toperation, interface->dsp_ack);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (operation == H620_HIF_GET_DATA)\n\t\t\tmemcpy(&p_data[data_transferred],\n\t\t\t\t(void *)&interface->u.b_data[0], this_copy);\n\n\t\tdata_transferred += this_copy;\n\t}\n\tif (interface->dsp_ack != operation)\n\t\tHPI_DEBUG_LOG(DEBUG, \"interface->dsp_ack=%d, expected %d\\n\",\n\t\t\tinterface->dsp_ack, operation);\n\t \n\n\tsend_dsp_command(phw, H620_HIF_IDLE);\n\n\treturn err;\n}\n\n \nstatic int wait_dsp_ack(struct hpi_hw_obj *phw, int state, int timeout_us)\n{\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tint t = timeout_us / 4;\n\n\trmb();\t \n\twhile ((interface->dsp_ack != state) && --t) {\n\t\thpios_delay_micro_seconds(4);\n\t\trmb();\t \n\t}\n\n\t \n\treturn t * 4;\n}\n\n \nstatic void send_dsp_command(struct hpi_hw_obj *phw, int cmd)\n{\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tu32 r;\n\n\tinterface->host_cmd = cmd;\n\twmb();\t \n\t \n\tr = ioread32(phw->prHDCR);\n\tr |= (u32)C6205_HDCR_DSPINT;\n\tiowrite32(r, phw->prHDCR);\n\tr &= ~(u32)C6205_HDCR_DSPINT;\n\tiowrite32(r, phw->prHDCR);\n}\n\nstatic unsigned int message_count;\n\nstatic u16 message_response_sequence(struct hpi_adapter_obj *pao,\n\tstruct hpi_message *phm, struct hpi_response *phr)\n{\n\tu32 time_out, time_out2;\n\tstruct hpi_hw_obj *phw = pao->priv;\n\tstruct bus_master_interface *interface = phw->p_interface_buffer;\n\tu16 err = 0;\n\n\tmessage_count++;\n\tif (phm->size > sizeof(interface->u.message_buffer)) {\n\t\tphr->error = HPI_ERROR_MESSAGE_BUFFER_TOO_SMALL;\n\t\tphr->specific_error = sizeof(interface->u.message_buffer);\n\t\tphr->size = sizeof(struct hpi_response_header);\n\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\"message len %d too big for buffer %zd \\n\", phm->size,\n\t\t\tsizeof(interface->u.message_buffer));\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {\n\t\tHPI_DEBUG_LOG(DEBUG, \"timeout waiting for idle\\n\");\n\t\treturn HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;\n\t}\n\n\tmemcpy(&interface->u.message_buffer, phm, phm->size);\n\t \n\tsend_dsp_command(phw, H620_HIF_GET_RESP);\n\n\ttime_out2 = wait_dsp_ack(phw, H620_HIF_GET_RESP, HPI6205_TIMEOUT);\n\n\tif (!time_out2) {\n\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\"(%u) Timed out waiting for \" \"GET_RESP state [%x]\\n\",\n\t\t\tmessage_count, interface->dsp_ack);\n\t} else {\n\t\tHPI_DEBUG_LOG(VERBOSE,\n\t\t\t\"(%u) transition to GET_RESP after %u\\n\",\n\t\t\tmessage_count, HPI6205_TIMEOUT - time_out2);\n\t}\n\t \n\ttime_out = HPI6205_TIMEOUT;\n\n\t \n\tif (time_out) {\n\t\tif (interface->u.response_buffer.response.size <= phr->size)\n\t\t\tmemcpy(phr, &interface->u.response_buffer,\n\t\t\t\tinterface->u.response_buffer.response.size);\n\t\telse {\n\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\"response len %d too big for buffer %d\\n\",\n\t\t\t\tinterface->u.response_buffer.response.size,\n\t\t\t\tphr->size);\n\t\t\tmemcpy(phr, &interface->u.response_buffer,\n\t\t\t\tsizeof(struct hpi_response_header));\n\t\t\tphr->error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\t\t\tphr->specific_error =\n\t\t\t\tinterface->u.response_buffer.response.size;\n\t\t\tphr->size = sizeof(struct hpi_response_header);\n\t\t}\n\t}\n\t \n\tsend_dsp_command(phw, H620_HIF_IDLE);\n\n\tif (!time_out || !time_out2) {\n\t\tHPI_DEBUG_LOG(DEBUG, \"something timed out!\\n\");\n\t\treturn HPI6205_ERROR_MSG_RESP_TIMEOUT;\n\t}\n\t \n\t \n\tif (phm->function == HPI_ADAPTER_CLOSE) {\n\t\tif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {\n\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\"Timeout waiting for idle \"\n\t\t\t\t\"(on adapter_close)\\n\");\n\t\t\treturn HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;\n\t\t}\n\t}\n\terr = hpi_validate_response(phm, phr);\n\treturn err;\n}\n\nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\n\tstruct hpi_response *phr)\n{\n\n\tu16 err = 0;\n\n\thpios_dsplock_lock(pao);\n\n\terr = message_response_sequence(pao, phm, phr);\n\n\t \n\tif (err) {\n\t\t \n\t\tif (err >= HPI_ERROR_BACKEND_BASE) {\n\t\t\tphr->error = HPI_ERROR_DSP_COMMUNICATION;\n\t\t\tphr->specific_error = err;\n\t\t} else {\n\t\t\tphr->error = err;\n\t\t}\n\n\t\tpao->dsp_crashed++;\n\n\t\t \n\t\tphr->size = sizeof(struct hpi_response_header);\n\t\tgoto err;\n\t} else\n\t\tpao->dsp_crashed = 0;\n\n\tif (phr->error != 0)\t \n\t\tgoto err;\n\n\tswitch (phm->function) {\n\tcase HPI_OSTREAM_WRITE:\n\tcase HPI_ISTREAM_ANC_WRITE:\n\t\terr = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,\n\t\t\tphm->u.d.u.data.data_size, H620_HIF_SEND_DATA);\n\t\tbreak;\n\n\tcase HPI_ISTREAM_READ:\n\tcase HPI_OSTREAM_ANC_READ:\n\t\terr = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,\n\t\t\tphm->u.d.u.data.data_size, H620_HIF_GET_DATA);\n\t\tbreak;\n\n\t}\n\tphr->error = err;\n\nerr:\n\thpios_dsplock_unlock(pao);\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}