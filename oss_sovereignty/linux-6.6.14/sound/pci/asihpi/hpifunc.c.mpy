{
  "module_name": "hpifunc.c",
  "hash_id": "f65c5ce771481a572f7b329d7e3bdc3ffa5d07bcc364437c98255f117fb4413b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/asihpi/hpifunc.c",
  "human_readable_source": "\n\n#include \"hpi_internal.h\"\n#include \"hpimsginit.h\"\n\n#include \"hpidebug.h\"\n\nstruct hpi_handle {\n\tunsigned int obj_index:12;\n\tunsigned int obj_type:4;\n\tunsigned int adapter_index:14;\n\tunsigned int spare:1;\n\tunsigned int read_only:1;\n};\n\nunion handle_word {\n\tstruct hpi_handle h;\n\tu32 w;\n};\n\nu32 hpi_indexes_to_handle(const char c_object, const u16 adapter_index,\n\tconst u16 object_index)\n{\n\tunion handle_word handle;\n\n\thandle.h.adapter_index = adapter_index;\n\thandle.h.spare = 0;\n\thandle.h.read_only = 0;\n\thandle.h.obj_type = c_object;\n\thandle.h.obj_index = object_index;\n\treturn handle.w;\n}\n\nstatic u16 hpi_handle_indexes(const u32 h, u16 *p1, u16 *p2)\n{\n\tunion handle_word uhandle;\n\tif (!h)\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tuhandle.w = h;\n\n\t*p1 = (u16)uhandle.h.adapter_index;\n\tif (p2)\n\t\t*p2 = (u16)uhandle.h.obj_index;\n\n\treturn 0;\n}\n\nvoid hpi_handle_to_indexes(const u32 handle, u16 *pw_adapter_index,\n\tu16 *pw_object_index)\n{\n\thpi_handle_indexes(handle, pw_adapter_index, pw_object_index);\n}\n\nchar hpi_handle_object(const u32 handle)\n{\n\tunion handle_word uhandle;\n\tuhandle.w = handle;\n\treturn (char)uhandle.h.obj_type;\n}\n\nvoid hpi_format_to_msg(struct hpi_msg_format *pMF,\n\tconst struct hpi_format *pF)\n{\n\tpMF->sample_rate = pF->sample_rate;\n\tpMF->bit_rate = pF->bit_rate;\n\tpMF->attributes = pF->attributes;\n\tpMF->channels = pF->channels;\n\tpMF->format = pF->format;\n}\n\nstatic void hpi_msg_to_format(struct hpi_format *pF,\n\tstruct hpi_msg_format *pMF)\n{\n\tpF->sample_rate = pMF->sample_rate;\n\tpF->bit_rate = pMF->bit_rate;\n\tpF->attributes = pMF->attributes;\n\tpF->channels = pMF->channels;\n\tpF->format = pMF->format;\n\tpF->mode_legacy = 0;\n\tpF->unused = 0;\n}\n\nvoid hpi_stream_response_to_legacy(struct hpi_stream_res *pSR)\n{\n\tpSR->u.legacy_stream_info.auxiliary_data_available =\n\t\tpSR->u.stream_info.auxiliary_data_available;\n\tpSR->u.legacy_stream_info.state = pSR->u.stream_info.state;\n}\n\nstatic inline void hpi_send_recvV1(struct hpi_message_header *m,\n\tstruct hpi_response_header *r)\n{\n\thpi_send_recv((struct hpi_message *)m, (struct hpi_response *)r);\n}\n\nu16 hpi_subsys_get_version_ex(u32 *pversion_ex)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_GET_VERSION);\n\thpi_send_recv(&hm, &hr);\n\t*pversion_ex = hr.u.s.data;\n\treturn hr.error;\n}\n\nu16 hpi_subsys_get_num_adapters(int *pn_num_adapters)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_GET_NUM_ADAPTERS);\n\thpi_send_recv(&hm, &hr);\n\t*pn_num_adapters = (int)hr.u.s.num_adapters;\n\treturn hr.error;\n}\n\nu16 hpi_subsys_get_adapter(int iterator, u32 *padapter_index,\n\tu16 *pw_adapter_type)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\n\t\tHPI_SUBSYS_GET_ADAPTER);\n\thm.obj_index = (u16)iterator;\n\thpi_send_recv(&hm, &hr);\n\t*padapter_index = (int)hr.u.s.adapter_index;\n\t*pw_adapter_type = hr.u.s.adapter_type;\n\n\treturn hr.error;\n}\n\nu16 hpi_adapter_open(u16 adapter_index)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_OPEN);\n\thm.adapter_index = adapter_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n\n}\n\nu16 hpi_adapter_close(u16 adapter_index)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_CLOSE);\n\thm.adapter_index = adapter_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_adapter_set_mode(u16 adapter_index, u32 adapter_mode)\n{\n\treturn hpi_adapter_set_mode_ex(adapter_index, adapter_mode,\n\t\tHPI_ADAPTER_MODE_SET);\n}\n\nu16 hpi_adapter_set_mode_ex(u16 adapter_index, u32 adapter_mode,\n\tu16 query_or_set)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_SET_MODE);\n\thm.adapter_index = adapter_index;\n\thm.u.ax.mode.adapter_mode = adapter_mode;\n\thm.u.ax.mode.query_or_set = query_or_set;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_adapter_get_mode(u16 adapter_index, u32 *padapter_mode)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_MODE);\n\thm.adapter_index = adapter_index;\n\thpi_send_recv(&hm, &hr);\n\tif (padapter_mode)\n\t\t*padapter_mode = hr.u.ax.mode.adapter_mode;\n\treturn hr.error;\n}\n\nu16 hpi_adapter_get_info(u16 adapter_index, u16 *pw_num_outstreams,\n\tu16 *pw_num_instreams, u16 *pw_version, u32 *pserial_number,\n\tu16 *pw_adapter_type)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_INFO);\n\thm.adapter_index = adapter_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\t*pw_adapter_type = hr.u.ax.info.adapter_type;\n\t*pw_num_outstreams = hr.u.ax.info.num_outstreams;\n\t*pw_num_instreams = hr.u.ax.info.num_instreams;\n\t*pw_version = hr.u.ax.info.version;\n\t*pserial_number = hr.u.ax.info.serial_number;\n\treturn hr.error;\n}\n\nu16 hpi_adapter_get_module_by_index(u16 adapter_index, u16 module_index,\n\tu16 *pw_num_outputs, u16 *pw_num_inputs, u16 *pw_version,\n\tu32 *pserial_number, u16 *pw_module_type, u32 *ph_module)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_MODULE_INFO);\n\thm.adapter_index = adapter_index;\n\thm.u.ax.module_info.index = module_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\t*pw_module_type = hr.u.ax.info.adapter_type;\n\t*pw_num_outputs = hr.u.ax.info.num_outstreams;\n\t*pw_num_inputs = hr.u.ax.info.num_instreams;\n\t*pw_version = hr.u.ax.info.version;\n\t*pserial_number = hr.u.ax.info.serial_number;\n\t*ph_module = 0;\n\n\treturn hr.error;\n}\n\nu16 hpi_adapter_set_property(u16 adapter_index, u16 property, u16 parameter1,\n\tu16 parameter2)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_SET_PROPERTY);\n\thm.adapter_index = adapter_index;\n\thm.u.ax.property_set.property = property;\n\thm.u.ax.property_set.parameter1 = parameter1;\n\thm.u.ax.property_set.parameter2 = parameter2;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_adapter_get_property(u16 adapter_index, u16 property,\n\tu16 *pw_parameter1, u16 *pw_parameter2)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\n\t\tHPI_ADAPTER_GET_PROPERTY);\n\thm.adapter_index = adapter_index;\n\thm.u.ax.property_set.property = property;\n\n\thpi_send_recv(&hm, &hr);\n\tif (!hr.error) {\n\t\tif (pw_parameter1)\n\t\t\t*pw_parameter1 = hr.u.ax.property_get.parameter1;\n\t\tif (pw_parameter2)\n\t\t\t*pw_parameter2 = hr.u.ax.property_get.parameter2;\n\t}\n\n\treturn hr.error;\n}\n\nu16 hpi_adapter_enumerate_property(u16 adapter_index, u16 index,\n\tu16 what_to_enumerate, u16 property_index, u32 *psetting)\n{\n\treturn 0;\n}\n\nu16 hpi_format_create(struct hpi_format *p_format, u16 channels, u16 format,\n\tu32 sample_rate, u32 bit_rate, u32 attributes)\n{\n\tu16 err = 0;\n\tstruct hpi_msg_format fmt;\n\n\tswitch (channels) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\terr = HPI_ERROR_INVALID_CHANNELS;\n\t\treturn err;\n\t}\n\tfmt.channels = channels;\n\n\tswitch (format) {\n\tcase HPI_FORMAT_PCM16_SIGNED:\n\tcase HPI_FORMAT_PCM24_SIGNED:\n\tcase HPI_FORMAT_PCM32_SIGNED:\n\tcase HPI_FORMAT_PCM32_FLOAT:\n\tcase HPI_FORMAT_PCM16_BIGENDIAN:\n\tcase HPI_FORMAT_PCM8_UNSIGNED:\n\tcase HPI_FORMAT_MPEG_L1:\n\tcase HPI_FORMAT_MPEG_L2:\n\tcase HPI_FORMAT_MPEG_L3:\n\tcase HPI_FORMAT_DOLBY_AC2:\n\tcase HPI_FORMAT_AA_TAGIT1_HITS:\n\tcase HPI_FORMAT_AA_TAGIT1_INSERTS:\n\tcase HPI_FORMAT_RAW_BITSTREAM:\n\tcase HPI_FORMAT_AA_TAGIT1_HITS_EX1:\n\tcase HPI_FORMAT_OEM1:\n\tcase HPI_FORMAT_OEM2:\n\t\tbreak;\n\tdefault:\n\t\terr = HPI_ERROR_INVALID_FORMAT;\n\t\treturn err;\n\t}\n\tfmt.format = format;\n\n\tif (sample_rate < 8000L) {\n\t\terr = HPI_ERROR_INCOMPATIBLE_SAMPLERATE;\n\t\tsample_rate = 8000L;\n\t}\n\tif (sample_rate > 200000L) {\n\t\terr = HPI_ERROR_INCOMPATIBLE_SAMPLERATE;\n\t\tsample_rate = 200000L;\n\t}\n\tfmt.sample_rate = sample_rate;\n\n\tswitch (format) {\n\tcase HPI_FORMAT_MPEG_L1:\n\tcase HPI_FORMAT_MPEG_L2:\n\tcase HPI_FORMAT_MPEG_L3:\n\t\tfmt.bit_rate = bit_rate;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM16_SIGNED:\n\tcase HPI_FORMAT_PCM16_BIGENDIAN:\n\t\tfmt.bit_rate = channels * sample_rate * 2;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM32_SIGNED:\n\tcase HPI_FORMAT_PCM32_FLOAT:\n\t\tfmt.bit_rate = channels * sample_rate * 4;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM8_UNSIGNED:\n\t\tfmt.bit_rate = channels * sample_rate;\n\t\tbreak;\n\tdefault:\n\t\tfmt.bit_rate = 0;\n\t}\n\n\tswitch (format) {\n\tcase HPI_FORMAT_MPEG_L2:\n\t\tif ((channels == 1)\n\t\t\t&& (attributes != HPI_MPEG_MODE_DEFAULT)) {\n\t\t\tattributes = HPI_MPEG_MODE_DEFAULT;\n\t\t\terr = HPI_ERROR_INVALID_FORMAT;\n\t\t} else if (attributes > HPI_MPEG_MODE_DUALCHANNEL) {\n\t\t\tattributes = HPI_MPEG_MODE_DEFAULT;\n\t\t\terr = HPI_ERROR_INVALID_FORMAT;\n\t\t}\n\t\tfmt.attributes = attributes;\n\t\tbreak;\n\tdefault:\n\t\tfmt.attributes = attributes;\n\t}\n\n\thpi_msg_to_format(p_format, &fmt);\n\treturn err;\n}\n\nu16 hpi_stream_estimate_buffer_size(struct hpi_format *p_format,\n\tu32 host_polling_rate_in_milli_seconds, u32 *recommended_buffer_size)\n{\n\n\tu32 bytes_per_second;\n\tu32 size;\n\tu16 channels;\n\tstruct hpi_format *pF = p_format;\n\n\tchannels = pF->channels;\n\n\tswitch (pF->format) {\n\tcase HPI_FORMAT_PCM16_BIGENDIAN:\n\tcase HPI_FORMAT_PCM16_SIGNED:\n\t\tbytes_per_second = pF->sample_rate * 2L * channels;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM24_SIGNED:\n\t\tbytes_per_second = pF->sample_rate * 3L * channels;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM32_SIGNED:\n\tcase HPI_FORMAT_PCM32_FLOAT:\n\t\tbytes_per_second = pF->sample_rate * 4L * channels;\n\t\tbreak;\n\tcase HPI_FORMAT_PCM8_UNSIGNED:\n\t\tbytes_per_second = pF->sample_rate * 1L * channels;\n\t\tbreak;\n\tcase HPI_FORMAT_MPEG_L1:\n\tcase HPI_FORMAT_MPEG_L2:\n\tcase HPI_FORMAT_MPEG_L3:\n\t\tbytes_per_second = pF->bit_rate / 8L;\n\t\tbreak;\n\tcase HPI_FORMAT_DOLBY_AC2:\n\n\t\tbytes_per_second = 256000L / 8L;\n\t\tbreak;\n\tdefault:\n\t\treturn HPI_ERROR_INVALID_FORMAT;\n\t}\n\tsize = (bytes_per_second * host_polling_rate_in_milli_seconds * 2) /\n\t\t1000L;\n\n\t*recommended_buffer_size =\n\t\troundup_pow_of_two(((size + 4095L) & ~4095L));\n\treturn 0;\n}\n\nu16 hpi_outstream_open(u16 adapter_index, u16 outstream_index,\n\tu32 *ph_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_OPEN);\n\thm.adapter_index = adapter_index;\n\thm.obj_index = outstream_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0)\n\t\t*ph_outstream =\n\t\t\thpi_indexes_to_handle(HPI_OBJ_OSTREAM, adapter_index,\n\t\t\toutstream_index);\n\telse\n\t\t*ph_outstream = 0;\n\treturn hr.error;\n}\n\nu16 hpi_outstream_close(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_HOSTBUFFER_FREE);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_GROUP_RESET);\n\thpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index);\n\thpi_send_recv(&hm, &hr);\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_CLOSE);\n\thpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index);\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_get_info_ex(u32 h_outstream, u16 *pw_state,\n\tu32 *pbuffer_size, u32 *pdata_to_play, u32 *psamples_played,\n\tu32 *pauxiliary_data_to_play)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_GET_INFO);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (pw_state)\n\t\t*pw_state = hr.u.d.u.stream_info.state;\n\tif (pbuffer_size)\n\t\t*pbuffer_size = hr.u.d.u.stream_info.buffer_size;\n\tif (pdata_to_play)\n\t\t*pdata_to_play = hr.u.d.u.stream_info.data_available;\n\tif (psamples_played)\n\t\t*psamples_played = hr.u.d.u.stream_info.samples_transferred;\n\tif (pauxiliary_data_to_play)\n\t\t*pauxiliary_data_to_play =\n\t\t\thr.u.d.u.stream_info.auxiliary_data_available;\n\treturn hr.error;\n}\n\nu16 hpi_outstream_write_buf(u32 h_outstream, const u8 *pb_data,\n\tu32 bytes_to_write, const struct hpi_format *p_format)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_WRITE);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.pb_data = (u8 *)pb_data;\n\thm.u.d.u.data.data_size = bytes_to_write;\n\n\thpi_format_to_msg(&hm.u.d.u.data.format, p_format);\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_start(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_START);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_wait_start(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_WAIT_START);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_stop(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_STOP);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_sinegen(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_SINEGEN);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_reset(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_RESET);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_query_format(u32 h_outstream, struct hpi_format *p_format)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_QUERY_FORMAT);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_format_to_msg(&hm.u.d.u.data.format, p_format);\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_set_format(u32 h_outstream, struct hpi_format *p_format)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_SET_FORMAT);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_format_to_msg(&hm.u.d.u.data.format, p_format);\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_set_velocity(u32 h_outstream, short velocity)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_SET_VELOCITY);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.velocity = velocity;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_set_punch_in_out(u32 h_outstream, u32 punch_in_sample,\n\tu32 punch_out_sample)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_SET_PUNCHINOUT);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thm.u.d.u.pio.punch_in_sample = punch_in_sample;\n\thm.u.d.u.pio.punch_out_sample = punch_out_sample;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_ancillary_reset(u32 h_outstream, u16 mode)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_ANC_RESET);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.format.channels = mode;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_outstream_ancillary_get_info(u32 h_outstream, u32 *pframes_available)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_ANC_GET_INFO);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\tif (hr.error == 0) {\n\t\tif (pframes_available)\n\t\t\t*pframes_available =\n\t\t\t\thr.u.d.u.stream_info.data_available /\n\t\t\t\tsizeof(struct hpi_anc_frame);\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_outstream_ancillary_read(u32 h_outstream,\n\tstruct hpi_anc_frame *p_anc_frame_buffer,\n\tu32 anc_frame_buffer_size_in_bytes,\n\tu32 number_of_ancillary_frames_to_read)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_ANC_READ);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.pb_data = (u8 *)p_anc_frame_buffer;\n\thm.u.d.u.data.data_size =\n\t\tnumber_of_ancillary_frames_to_read *\n\t\tsizeof(struct hpi_anc_frame);\n\tif (hm.u.d.u.data.data_size <= anc_frame_buffer_size_in_bytes)\n\t\thpi_send_recv(&hm, &hr);\n\telse\n\t\thr.error = HPI_ERROR_INVALID_DATASIZE;\n\treturn hr.error;\n}\n\nu16 hpi_outstream_set_time_scale(u32 h_outstream, u32 time_scale)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_SET_TIMESCALE);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thm.u.d.u.time_scale = time_scale;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_host_buffer_allocate(u32 h_outstream, u32 size_in_bytes)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_HOSTBUFFER_ALLOC);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.data_size = size_in_bytes;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_outstream_host_buffer_get_info(u32 h_outstream, u8 **pp_buffer,\n\tstruct hpi_hostbuffer_status **pp_status)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_HOSTBUFFER_GET_INFO);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0) {\n\t\tif (pp_buffer)\n\t\t\t*pp_buffer = hr.u.d.u.hostbuffer_info.p_buffer;\n\t\tif (pp_status)\n\t\t\t*pp_status = hr.u.d.u.hostbuffer_info.p_status;\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_outstream_host_buffer_free(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_HOSTBUFFER_FREE);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_outstream_group_add(u32 h_outstream, u32 h_stream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tu16 adapter;\n\tchar c_obj_type;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_GROUP_ADD);\n\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tif (hpi_handle_indexes(h_stream, &adapter,\n\t\t\t&hm.u.d.u.stream.stream_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tc_obj_type = hpi_handle_object(h_stream);\n\tswitch (c_obj_type) {\n\tcase HPI_OBJ_OSTREAM:\n\tcase HPI_OBJ_ISTREAM:\n\t\thm.u.d.u.stream.object_type = c_obj_type;\n\t\tbreak;\n\tdefault:\n\t\treturn HPI_ERROR_INVALID_OBJ;\n\t}\n\tif (adapter != hm.adapter_index)\n\t\treturn HPI_ERROR_NO_INTERADAPTER_GROUPS;\n\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_outstream_group_get_map(u32 h_outstream, u32 *poutstream_map,\n\tu32 *pinstream_map)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_GROUP_GETMAP);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\n\tif (poutstream_map)\n\t\t*poutstream_map = hr.u.d.u.group_info.outstream_group_map;\n\tif (pinstream_map)\n\t\t*pinstream_map = hr.u.d.u.group_info.instream_group_map;\n\n\treturn hr.error;\n}\n\nu16 hpi_outstream_group_reset(u32 h_outstream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\n\t\tHPI_OSTREAM_GROUP_RESET);\n\tif (hpi_handle_indexes(h_outstream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_instream_open(u16 adapter_index, u16 instream_index, u32 *ph_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_OPEN);\n\thm.adapter_index = adapter_index;\n\thm.obj_index = instream_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0)\n\t\t*ph_instream =\n\t\t\thpi_indexes_to_handle(HPI_OBJ_ISTREAM, adapter_index,\n\t\t\tinstream_index);\n\telse\n\t\t*ph_instream = 0;\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_close(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_HOSTBUFFER_FREE);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_GROUP_RESET);\n\thpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index);\n\thpi_send_recv(&hm, &hr);\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_CLOSE);\n\thpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index);\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_query_format(u32 h_instream,\n\tconst struct hpi_format *p_format)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_QUERY_FORMAT);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_format_to_msg(&hm.u.d.u.data.format, p_format);\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_set_format(u32 h_instream, const struct hpi_format *p_format)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_SET_FORMAT);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_format_to_msg(&hm.u.d.u.data.format, p_format);\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_read_buf(u32 h_instream, u8 *pb_data, u32 bytes_to_read)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_READ);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.data_size = bytes_to_read;\n\thm.u.d.u.data.pb_data = pb_data;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_start(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_START);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_wait_start(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_WAIT_START);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_stop(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_STOP);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_reset(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_RESET);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_get_info_ex(u32 h_instream, u16 *pw_state, u32 *pbuffer_size,\n\tu32 *pdata_recorded, u32 *psamples_recorded,\n\tu32 *pauxiliary_data_recorded)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_GET_INFO);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (pw_state)\n\t\t*pw_state = hr.u.d.u.stream_info.state;\n\tif (pbuffer_size)\n\t\t*pbuffer_size = hr.u.d.u.stream_info.buffer_size;\n\tif (pdata_recorded)\n\t\t*pdata_recorded = hr.u.d.u.stream_info.data_available;\n\tif (psamples_recorded)\n\t\t*psamples_recorded = hr.u.d.u.stream_info.samples_transferred;\n\tif (pauxiliary_data_recorded)\n\t\t*pauxiliary_data_recorded =\n\t\t\thr.u.d.u.stream_info.auxiliary_data_available;\n\treturn hr.error;\n}\n\nu16 hpi_instream_ancillary_reset(u32 h_instream, u16 bytes_per_frame,\n\tu16 mode, u16 alignment, u16 idle_bit)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_ANC_RESET);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.format.attributes = bytes_per_frame;\n\thm.u.d.u.data.format.format = (mode << 8) | (alignment & 0xff);\n\thm.u.d.u.data.format.channels = idle_bit;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_instream_ancillary_get_info(u32 h_instream, u32 *pframe_space)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_ANC_GET_INFO);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\tif (pframe_space)\n\t\t*pframe_space =\n\t\t\t(hr.u.d.u.stream_info.buffer_size -\n\t\t\thr.u.d.u.stream_info.data_available) /\n\t\t\tsizeof(struct hpi_anc_frame);\n\treturn hr.error;\n}\n\nu16 hpi_instream_ancillary_write(u32 h_instream,\n\tconst struct hpi_anc_frame *p_anc_frame_buffer,\n\tu32 anc_frame_buffer_size_in_bytes,\n\tu32 number_of_ancillary_frames_to_write)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_ANC_WRITE);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.pb_data = (u8 *)p_anc_frame_buffer;\n\thm.u.d.u.data.data_size =\n\t\tnumber_of_ancillary_frames_to_write *\n\t\tsizeof(struct hpi_anc_frame);\n\tif (hm.u.d.u.data.data_size <= anc_frame_buffer_size_in_bytes)\n\t\thpi_send_recv(&hm, &hr);\n\telse\n\t\thr.error = HPI_ERROR_INVALID_DATASIZE;\n\treturn hr.error;\n}\n\nu16 hpi_instream_host_buffer_allocate(u32 h_instream, u32 size_in_bytes)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_HOSTBUFFER_ALLOC);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.d.u.data.data_size = size_in_bytes;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_instream_host_buffer_get_info(u32 h_instream, u8 **pp_buffer,\n\tstruct hpi_hostbuffer_status **pp_status)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_HOSTBUFFER_GET_INFO);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0) {\n\t\tif (pp_buffer)\n\t\t\t*pp_buffer = hr.u.d.u.hostbuffer_info.p_buffer;\n\t\tif (pp_status)\n\t\t\t*pp_status = hr.u.d.u.hostbuffer_info.p_status;\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_instream_host_buffer_free(u32 h_instream)\n{\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_HOSTBUFFER_FREE);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_instream_group_add(u32 h_instream, u32 h_stream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\tu16 adapter;\n\tchar c_obj_type;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_GROUP_ADD);\n\thr.error = 0;\n\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tif (hpi_handle_indexes(h_stream, &adapter,\n\t\t\t&hm.u.d.u.stream.stream_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tc_obj_type = hpi_handle_object(h_stream);\n\n\tswitch (c_obj_type) {\n\tcase HPI_OBJ_OSTREAM:\n\tcase HPI_OBJ_ISTREAM:\n\t\thm.u.d.u.stream.object_type = c_obj_type;\n\t\tbreak;\n\tdefault:\n\t\treturn HPI_ERROR_INVALID_OBJ;\n\t}\n\n\tif (adapter != hm.adapter_index)\n\t\treturn HPI_ERROR_NO_INTERADAPTER_GROUPS;\n\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_instream_group_get_map(u32 h_instream, u32 *poutstream_map,\n\tu32 *pinstream_map)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_HOSTBUFFER_FREE);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\n\tif (poutstream_map)\n\t\t*poutstream_map = hr.u.d.u.group_info.outstream_group_map;\n\tif (pinstream_map)\n\t\t*pinstream_map = hr.u.d.u.group_info.instream_group_map;\n\n\treturn hr.error;\n}\n\nu16 hpi_instream_group_reset(u32 h_instream)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\n\t\tHPI_ISTREAM_GROUP_RESET);\n\tif (hpi_handle_indexes(h_instream, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_mixer_open(u16 adapter_index, u32 *ph_mixer)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN);\n\thm.adapter_index = adapter_index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0)\n\t\t*ph_mixer =\n\t\t\thpi_indexes_to_handle(HPI_OBJ_MIXER, adapter_index,\n\t\t\t0);\n\telse\n\t\t*ph_mixer = 0;\n\treturn hr.error;\n}\n\nu16 hpi_mixer_close(u32 h_mixer)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_CLOSE);\n\tif (hpi_handle_indexes(h_mixer, &hm.adapter_index, NULL))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_mixer_get_control(u32 h_mixer, u16 src_node_type,\n\tu16 src_node_type_index, u16 dst_node_type, u16 dst_node_type_index,\n\tu16 control_type, u32 *ph_control)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER,\n\t\tHPI_MIXER_GET_CONTROL);\n\tif (hpi_handle_indexes(h_mixer, &hm.adapter_index, NULL))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.m.node_type1 = src_node_type;\n\thm.u.m.node_index1 = src_node_type_index;\n\thm.u.m.node_type2 = dst_node_type;\n\thm.u.m.node_index2 = dst_node_type_index;\n\thm.u.m.control_type = control_type;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (hr.error == 0)\n\t\t*ph_control =\n\t\t\thpi_indexes_to_handle(HPI_OBJ_CONTROL,\n\t\t\thm.adapter_index, hr.u.m.control_index);\n\telse\n\t\t*ph_control = 0;\n\treturn hr.error;\n}\n\nu16 hpi_mixer_get_control_by_index(u32 h_mixer, u16 control_index,\n\tu16 *pw_src_node_type, u16 *pw_src_node_index, u16 *pw_dst_node_type,\n\tu16 *pw_dst_node_index, u16 *pw_control_type, u32 *ph_control)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER,\n\t\tHPI_MIXER_GET_CONTROL_BY_INDEX);\n\tif (hpi_handle_indexes(h_mixer, &hm.adapter_index, NULL))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.m.control_index = control_index;\n\thpi_send_recv(&hm, &hr);\n\n\tif (pw_src_node_type) {\n\t\t*pw_src_node_type =\n\t\t\thr.u.m.src_node_type + HPI_SOURCENODE_NONE;\n\t\t*pw_src_node_index = hr.u.m.src_node_index;\n\t\t*pw_dst_node_type = hr.u.m.dst_node_type + HPI_DESTNODE_NONE;\n\t\t*pw_dst_node_index = hr.u.m.dst_node_index;\n\t}\n\tif (pw_control_type)\n\t\t*pw_control_type = hr.u.m.control_index;\n\n\tif (ph_control) {\n\t\tif (hr.error == 0)\n\t\t\t*ph_control =\n\t\t\t\thpi_indexes_to_handle(HPI_OBJ_CONTROL,\n\t\t\t\thm.adapter_index, control_index);\n\t\telse\n\t\t\t*ph_control = 0;\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_mixer_store(u32 h_mixer, enum HPI_MIXER_STORE_COMMAND command,\n\tu16 index)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_STORE);\n\tif (hpi_handle_indexes(h_mixer, &hm.adapter_index, NULL))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.mx.store.command = command;\n\thm.u.mx.store.index = index;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nstatic\nu16 hpi_control_param_set(const u32 h_control, const u16 attrib,\n\tconst u32 param1, const u32 param2)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = attrib;\n\thm.u.c.param1 = param1;\n\thm.u.c.param2 = param2;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nstatic u16 hpi_control_log_set2(u32 h_control, u16 attrib, short sv0,\n\tshort sv1)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = attrib;\n\thm.u.c.an_log_value[0] = sv0;\n\thm.u.c.an_log_value[1] = sv1;\n\thpi_send_recv(&hm, &hr);\n\treturn hr.error;\n}\n\nstatic\nu16 hpi_control_param_get(const u32 h_control, const u16 attrib, u32 param1,\n\tu32 param2, u32 *pparam1, u32 *pparam2)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = attrib;\n\thm.u.c.param1 = param1;\n\thm.u.c.param2 = param2;\n\thpi_send_recv(&hm, &hr);\n\n\t*pparam1 = hr.u.c.param1;\n\tif (pparam2)\n\t\t*pparam2 = hr.u.c.param2;\n\n\treturn hr.error;\n}\n\n#define hpi_control_param1_get(h, a, p1) \\\n\t\thpi_control_param_get(h, a, 0, 0, p1, NULL)\n#define hpi_control_param2_get(h, a, p1, p2) \\\n\t\thpi_control_param_get(h, a, 0, 0, p1, p2)\n\nstatic u16 hpi_control_log_get2(u32 h_control, u16 attrib, short *sv0,\n\tshort *sv1)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = attrib;\n\n\thpi_send_recv(&hm, &hr);\n\t*sv0 = hr.u.c.an_log_value[0];\n\tif (sv1)\n\t\t*sv1 = hr.u.c.an_log_value[1];\n\treturn hr.error;\n}\n\nstatic\nu16 hpi_control_query(const u32 h_control, const u16 attrib, const u32 index,\n\tconst u32 param, u32 *psetting)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_INFO);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thm.u.c.attribute = attrib;\n\thm.u.c.param1 = index;\n\thm.u.c.param2 = param;\n\n\thpi_send_recv(&hm, &hr);\n\t*psetting = hr.u.c.param1;\n\n\treturn hr.error;\n}\n\nstatic u16 hpi_control_get_string(const u32 h_control, const u16 attribute,\n\tchar *psz_string, const u32 string_length)\n{\n\tunsigned int sub_string_index = 0, j = 0;\n\tchar c = 0;\n\tunsigned int n = 0;\n\tu16 err = 0;\n\n\tif ((string_length < 1) || (string_length > 256))\n\t\treturn HPI_ERROR_INVALID_CONTROL_VALUE;\n\tfor (sub_string_index = 0; sub_string_index < string_length;\n\t\tsub_string_index += 8) {\n\t\tstruct hpi_message hm;\n\t\tstruct hpi_response hr;\n\n\t\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\t\tHPI_CONTROL_GET_STATE);\n\t\tif (hpi_handle_indexes(h_control, &hm.adapter_index,\n\t\t\t\t&hm.obj_index))\n\t\t\treturn HPI_ERROR_INVALID_HANDLE;\n\t\thm.u.c.attribute = attribute;\n\t\thm.u.c.param1 = sub_string_index;\n\t\thm.u.c.param2 = 0;\n\t\thpi_send_recv(&hm, &hr);\n\n\t\tif (sub_string_index == 0\n\t\t\t&& (hr.u.cu.chars8.remaining_chars + 8) >\n\t\t\tstring_length)\n\t\t\treturn HPI_ERROR_INVALID_CONTROL_VALUE;\n\n\t\tif (hr.error) {\n\t\t\terr = hr.error;\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tc = hr.u.cu.chars8.sz_data[j];\n\t\t\tpsz_string[sub_string_index + j] = c;\n\t\t\tn++;\n\t\t\tif (n >= string_length) {\n\t\t\t\tpsz_string[string_length - 1] = 0;\n\t\t\t\terr = HPI_ERROR_INVALID_CONTROL_VALUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((hr.u.cu.chars8.remaining_chars == 0)\n\t\t\t&& ((sub_string_index + j) < string_length)\n\t\t\t&& (c != 0)) {\n\t\t\tc = 0;\n\t\t\tpsz_string[sub_string_index + j] = c;\n\t\t}\n\t\tif (c == 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nu16 hpi_aesebu_receiver_query_format(const u32 h_aes_rx, const u32 index,\n\tu16 *pw_format)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_aes_rx, HPI_AESEBURX_FORMAT, index, 0, &qr);\n\t*pw_format = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_aesebu_receiver_set_format(u32 h_control, u16 format)\n{\n\treturn hpi_control_param_set(h_control, HPI_AESEBURX_FORMAT, format,\n\t\t0);\n}\n\nu16 hpi_aesebu_receiver_get_format(u32 h_control, u16 *pw_format)\n{\n\tu16 err;\n\tu32 param;\n\n\terr = hpi_control_param1_get(h_control, HPI_AESEBURX_FORMAT, &param);\n\tif (!err && pw_format)\n\t\t*pw_format = (u16)param;\n\n\treturn err;\n}\n\nu16 hpi_aesebu_receiver_get_sample_rate(u32 h_control, u32 *psample_rate)\n{\n\treturn hpi_control_param1_get(h_control, HPI_AESEBURX_SAMPLERATE,\n\t\tpsample_rate);\n}\n\nu16 hpi_aesebu_receiver_get_user_data(u32 h_control, u16 index, u16 *pw_data)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_AESEBURX_USERDATA;\n\thm.u.c.param1 = index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (pw_data)\n\t\t*pw_data = (u16)hr.u.c.param2;\n\treturn hr.error;\n}\n\nu16 hpi_aesebu_receiver_get_channel_status(u32 h_control, u16 index,\n\tu16 *pw_data)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_AESEBURX_CHANNELSTATUS;\n\thm.u.c.param1 = index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (pw_data)\n\t\t*pw_data = (u16)hr.u.c.param2;\n\treturn hr.error;\n}\n\nu16 hpi_aesebu_receiver_get_error_status(u32 h_control, u16 *pw_error_data)\n{\n\tu32 error_data = 0;\n\tu16 err = 0;\n\n\terr = hpi_control_param1_get(h_control, HPI_AESEBURX_ERRORSTATUS,\n\t\t&error_data);\n\tif (pw_error_data)\n\t\t*pw_error_data = (u16)error_data;\n\treturn err;\n}\n\nu16 hpi_aesebu_transmitter_set_sample_rate(u32 h_control, u32 sample_rate)\n{\n\treturn hpi_control_param_set(h_control, HPI_AESEBUTX_SAMPLERATE,\n\t\tsample_rate, 0);\n}\n\nu16 hpi_aesebu_transmitter_set_user_data(u32 h_control, u16 index, u16 data)\n{\n\treturn hpi_control_param_set(h_control, HPI_AESEBUTX_USERDATA, index,\n\t\tdata);\n}\n\nu16 hpi_aesebu_transmitter_set_channel_status(u32 h_control, u16 index,\n\tu16 data)\n{\n\treturn hpi_control_param_set(h_control, HPI_AESEBUTX_CHANNELSTATUS,\n\t\tindex, data);\n}\n\nu16 hpi_aesebu_transmitter_get_channel_status(u32 h_control, u16 index,\n\tu16 *pw_data)\n{\n\treturn HPI_ERROR_INVALID_OPERATION;\n}\n\nu16 hpi_aesebu_transmitter_query_format(const u32 h_aes_tx, const u32 index,\n\tu16 *pw_format)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_aes_tx, HPI_AESEBUTX_FORMAT, index, 0, &qr);\n\t*pw_format = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_aesebu_transmitter_set_format(u32 h_control, u16 output_format)\n{\n\treturn hpi_control_param_set(h_control, HPI_AESEBUTX_FORMAT,\n\t\toutput_format, 0);\n}\n\nu16 hpi_aesebu_transmitter_get_format(u32 h_control, u16 *pw_output_format)\n{\n\tu16 err;\n\tu32 param;\n\n\terr = hpi_control_param1_get(h_control, HPI_AESEBUTX_FORMAT, &param);\n\tif (!err && pw_output_format)\n\t\t*pw_output_format = (u16)param;\n\n\treturn err;\n}\n\nu16 hpi_bitstream_set_clock_edge(u32 h_control, u16 edge_type)\n{\n\treturn hpi_control_param_set(h_control, HPI_BITSTREAM_CLOCK_EDGE,\n\t\tedge_type, 0);\n}\n\nu16 hpi_bitstream_set_data_polarity(u32 h_control, u16 polarity)\n{\n\treturn hpi_control_param_set(h_control, HPI_BITSTREAM_DATA_POLARITY,\n\t\tpolarity, 0);\n}\n\nu16 hpi_bitstream_get_activity(u32 h_control, u16 *pw_clk_activity,\n\tu16 *pw_data_activity)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_BITSTREAM_ACTIVITY;\n\thpi_send_recv(&hm, &hr);\n\tif (pw_clk_activity)\n\t\t*pw_clk_activity = (u16)hr.u.c.param1;\n\tif (pw_data_activity)\n\t\t*pw_data_activity = (u16)hr.u.c.param2;\n\treturn hr.error;\n}\n\nu16 hpi_channel_mode_query_mode(const u32 h_mode, const u32 index,\n\tu16 *pw_mode)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_mode, HPI_CHANNEL_MODE_MODE, index, 0, &qr);\n\t*pw_mode = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_channel_mode_set(u32 h_control, u16 mode)\n{\n\treturn hpi_control_param_set(h_control, HPI_CHANNEL_MODE_MODE, mode,\n\t\t0);\n}\n\nu16 hpi_channel_mode_get(u32 h_control, u16 *mode)\n{\n\tu32 mode32 = 0;\n\tu16 err = hpi_control_param1_get(h_control,\n\t\tHPI_CHANNEL_MODE_MODE, &mode32);\n\tif (mode)\n\t\t*mode = (u16)mode32;\n\treturn err;\n}\n\nu16 hpi_cobranet_hmi_write(u32 h_control, u32 hmi_address, u32 byte_count,\n\tu8 *pb_data)\n{\n\tstruct hpi_msg_cobranet_hmiwrite hm;\n\tstruct hpi_response_header hr;\n\n\thpi_init_message_responseV1(&hm.h, sizeof(hm), &hr, sizeof(hr),\n\t\tHPI_OBJ_CONTROL, HPI_CONTROL_SET_STATE);\n\n\tif (hpi_handle_indexes(h_control, &hm.h.adapter_index,\n\t\t\t&hm.h.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tif (byte_count > sizeof(hm.bytes))\n\t\treturn HPI_ERROR_MESSAGE_BUFFER_TOO_SMALL;\n\n\thm.p.attribute = HPI_COBRANET_SET;\n\thm.p.byte_count = byte_count;\n\thm.p.hmi_address = hmi_address;\n\tmemcpy(hm.bytes, pb_data, byte_count);\n\thm.h.size = (u16)(sizeof(hm.h) + sizeof(hm.p) + byte_count);\n\n\thpi_send_recvV1(&hm.h, &hr);\n\treturn hr.error;\n}\n\nu16 hpi_cobranet_hmi_read(u32 h_control, u32 hmi_address, u32 max_byte_count,\n\tu32 *pbyte_count, u8 *pb_data)\n{\n\tstruct hpi_msg_cobranet_hmiread hm;\n\tstruct hpi_res_cobranet_hmiread hr;\n\n\thpi_init_message_responseV1(&hm.h, sizeof(hm), &hr.h, sizeof(hr),\n\t\tHPI_OBJ_CONTROL, HPI_CONTROL_GET_STATE);\n\n\tif (hpi_handle_indexes(h_control, &hm.h.adapter_index,\n\t\t\t&hm.h.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tif (max_byte_count > sizeof(hr.bytes))\n\t\treturn HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\n\thm.p.attribute = HPI_COBRANET_GET;\n\thm.p.byte_count = max_byte_count;\n\thm.p.hmi_address = hmi_address;\n\n\thpi_send_recvV1(&hm.h, &hr.h);\n\n\tif (!hr.h.error && pb_data) {\n\t\tif (hr.byte_count > sizeof(hr.bytes))\n\n\t\t\treturn HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\n\t\t*pbyte_count = hr.byte_count;\n\n\t\tif (hr.byte_count < max_byte_count)\n\t\t\tmax_byte_count = *pbyte_count;\n\n\t\tmemcpy(pb_data, hr.bytes, max_byte_count);\n\t}\n\treturn hr.h.error;\n}\n\nu16 hpi_cobranet_hmi_get_status(u32 h_control, u32 *pstatus,\n\tu32 *preadable_size, u32 *pwriteable_size)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thm.u.c.attribute = HPI_COBRANET_GET_STATUS;\n\n\thpi_send_recv(&hm, &hr);\n\tif (!hr.error) {\n\t\tif (pstatus)\n\t\t\t*pstatus = hr.u.cu.cobranet.status.status;\n\t\tif (preadable_size)\n\t\t\t*preadable_size =\n\t\t\t\thr.u.cu.cobranet.status.readable_size;\n\t\tif (pwriteable_size)\n\t\t\t*pwriteable_size =\n\t\t\t\thr.u.cu.cobranet.status.writeable_size;\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_cobranet_get_ip_address(u32 h_control, u32 *pdw_ip_address)\n{\n\tu32 byte_count;\n\tu32 iP;\n\tu16 err;\n\n\terr = hpi_cobranet_hmi_read(h_control,\n\t\tHPI_COBRANET_HMI_cobra_ip_mon_currentIP, 4, &byte_count,\n\t\t(u8 *)&iP);\n\n\t*pdw_ip_address =\n\t\t((iP & 0xff000000) >> 8) | ((iP & 0x00ff0000) << 8) | ((iP &\n\t\t\t0x0000ff00) >> 8) | ((iP & 0x000000ff) << 8);\n\n\tif (err)\n\t\t*pdw_ip_address = 0;\n\n\treturn err;\n\n}\n\nu16 hpi_cobranet_set_ip_address(u32 h_control, u32 dw_ip_address)\n{\n\tu32 iP;\n\tu16 err;\n\n\tiP = ((dw_ip_address & 0xff000000) >> 8) | ((dw_ip_address &\n\t\t\t0x00ff0000) << 8) | ((dw_ip_address & 0x0000ff00) >>\n\t\t8) | ((dw_ip_address & 0x000000ff) << 8);\n\n\terr = hpi_cobranet_hmi_write(h_control,\n\t\tHPI_COBRANET_HMI_cobra_ip_mon_currentIP, 4, (u8 *)&iP);\n\n\treturn err;\n\n}\n\nu16 hpi_cobranet_get_static_ip_address(u32 h_control, u32 *pdw_ip_address)\n{\n\tu32 byte_count;\n\tu32 iP;\n\tu16 err;\n\terr = hpi_cobranet_hmi_read(h_control,\n\t\tHPI_COBRANET_HMI_cobra_ip_mon_staticIP, 4, &byte_count,\n\t\t(u8 *)&iP);\n\n\t*pdw_ip_address =\n\t\t((iP & 0xff000000) >> 8) | ((iP & 0x00ff0000) << 8) | ((iP &\n\t\t\t0x0000ff00) >> 8) | ((iP & 0x000000ff) << 8);\n\n\tif (err)\n\t\t*pdw_ip_address = 0;\n\n\treturn err;\n\n}\n\nu16 hpi_cobranet_set_static_ip_address(u32 h_control, u32 dw_ip_address)\n{\n\tu32 iP;\n\tu16 err;\n\n\tiP = ((dw_ip_address & 0xff000000) >> 8) | ((dw_ip_address &\n\t\t\t0x00ff0000) << 8) | ((dw_ip_address & 0x0000ff00) >>\n\t\t8) | ((dw_ip_address & 0x000000ff) << 8);\n\n\terr = hpi_cobranet_hmi_write(h_control,\n\t\tHPI_COBRANET_HMI_cobra_ip_mon_staticIP, 4, (u8 *)&iP);\n\n\treturn err;\n\n}\n\nu16 hpi_cobranet_get_macaddress(u32 h_control, u32 *p_mac_msbs,\n\tu32 *p_mac_lsbs)\n{\n\tu32 byte_count;\n\tu16 err;\n\tu32 mac;\n\n\terr = hpi_cobranet_hmi_read(h_control,\n\t\tHPI_COBRANET_HMI_cobra_if_phy_address, 4, &byte_count,\n\t\t(u8 *)&mac);\n\n\tif (!err) {\n\t\t*p_mac_msbs =\n\t\t\t((mac & 0xff000000) >> 8) | ((mac & 0x00ff0000) << 8)\n\t\t\t| ((mac & 0x0000ff00) >> 8) | ((mac & 0x000000ff) <<\n\t\t\t8);\n\n\t\terr = hpi_cobranet_hmi_read(h_control,\n\t\t\tHPI_COBRANET_HMI_cobra_if_phy_address + 1, 4,\n\t\t\t&byte_count, (u8 *)&mac);\n\t}\n\n\tif (!err) {\n\t\t*p_mac_lsbs =\n\t\t\t((mac & 0xff000000) >> 8) | ((mac & 0x00ff0000) << 8)\n\t\t\t| ((mac & 0x0000ff00) >> 8) | ((mac & 0x000000ff) <<\n\t\t\t8);\n\t} else {\n\t\t*p_mac_msbs = 0;\n\t\t*p_mac_lsbs = 0;\n\t}\n\n\treturn err;\n}\n\nu16 hpi_compander_set_enable(u32 h_control, u32 enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_GENERIC_ENABLE, enable,\n\t\t0);\n}\n\nu16 hpi_compander_get_enable(u32 h_control, u32 *enable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_GENERIC_ENABLE, enable);\n}\n\nu16 hpi_compander_set_makeup_gain(u32 h_control, short makeup_gain0_01dB)\n{\n\treturn hpi_control_log_set2(h_control, HPI_COMPANDER_MAKEUPGAIN,\n\t\tmakeup_gain0_01dB, 0);\n}\n\nu16 hpi_compander_get_makeup_gain(u32 h_control, short *makeup_gain0_01dB)\n{\n\treturn hpi_control_log_get2(h_control, HPI_COMPANDER_MAKEUPGAIN,\n\t\tmakeup_gain0_01dB, NULL);\n}\n\nu16 hpi_compander_set_attack_time_constant(u32 h_control, unsigned int index,\n\tu32 attack)\n{\n\treturn hpi_control_param_set(h_control, HPI_COMPANDER_ATTACK, attack,\n\t\tindex);\n}\n\nu16 hpi_compander_get_attack_time_constant(u32 h_control, unsigned int index,\n\tu32 *attack)\n{\n\treturn hpi_control_param_get(h_control, HPI_COMPANDER_ATTACK, 0,\n\t\tindex, attack, NULL);\n}\n\nu16 hpi_compander_set_decay_time_constant(u32 h_control, unsigned int index,\n\tu32 decay)\n{\n\treturn hpi_control_param_set(h_control, HPI_COMPANDER_DECAY, decay,\n\t\tindex);\n}\n\nu16 hpi_compander_get_decay_time_constant(u32 h_control, unsigned int index,\n\tu32 *decay)\n{\n\treturn hpi_control_param_get(h_control, HPI_COMPANDER_DECAY, 0, index,\n\t\tdecay, NULL);\n\n}\n\nu16 hpi_compander_set_threshold(u32 h_control, unsigned int index,\n\tshort threshold0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_COMPANDER_THRESHOLD;\n\thm.u.c.param2 = index;\n\thm.u.c.an_log_value[0] = threshold0_01dB;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_compander_get_threshold(u32 h_control, unsigned int index,\n\tshort *threshold0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_COMPANDER_THRESHOLD;\n\thm.u.c.param2 = index;\n\n\thpi_send_recv(&hm, &hr);\n\t*threshold0_01dB = hr.u.c.an_log_value[0];\n\n\treturn hr.error;\n}\n\nu16 hpi_compander_set_ratio(u32 h_control, u32 index, u32 ratio100)\n{\n\treturn hpi_control_param_set(h_control, HPI_COMPANDER_RATIO, ratio100,\n\t\tindex);\n}\n\nu16 hpi_compander_get_ratio(u32 h_control, u32 index, u32 *ratio100)\n{\n\treturn hpi_control_param_get(h_control, HPI_COMPANDER_RATIO, 0, index,\n\t\tratio100, NULL);\n}\n\nu16 hpi_level_query_range(u32 h_control, short *min_gain_01dB,\n\tshort *max_gain_01dB, short *step_gain_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_LEVEL_RANGE;\n\n\thpi_send_recv(&hm, &hr);\n\tif (hr.error) {\n\t\thr.u.c.an_log_value[0] = 0;\n\t\thr.u.c.an_log_value[1] = 0;\n\t\thr.u.c.param1 = 0;\n\t}\n\tif (min_gain_01dB)\n\t\t*min_gain_01dB = hr.u.c.an_log_value[0];\n\tif (max_gain_01dB)\n\t\t*max_gain_01dB = hr.u.c.an_log_value[1];\n\tif (step_gain_01dB)\n\t\t*step_gain_01dB = (short)hr.u.c.param1;\n\treturn hr.error;\n}\n\nu16 hpi_level_set_gain(u32 h_control, short an_gain0_01dB[HPI_MAX_CHANNELS]\n\t)\n{\n\treturn hpi_control_log_set2(h_control, HPI_LEVEL_GAIN,\n\t\tan_gain0_01dB[0], an_gain0_01dB[1]);\n}\n\nu16 hpi_level_get_gain(u32 h_control, short an_gain0_01dB[HPI_MAX_CHANNELS]\n\t)\n{\n\treturn hpi_control_log_get2(h_control, HPI_LEVEL_GAIN,\n\t\t&an_gain0_01dB[0], &an_gain0_01dB[1]);\n}\n\nu16 hpi_meter_query_channels(const u32 h_meter, u32 *p_channels)\n{\n\treturn hpi_control_query(h_meter, HPI_METER_NUM_CHANNELS, 0, 0,\n\t\tp_channels);\n}\n\nu16 hpi_meter_get_peak(u32 h_control, short an_peakdB[HPI_MAX_CHANNELS]\n\t)\n{\n\tshort i = 0;\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_METER_PEAK;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (!hr.error)\n\t\tmemcpy(an_peakdB, hr.u.c.an_log_value,\n\t\t\tsizeof(short) * HPI_MAX_CHANNELS);\n\telse\n\t\tfor (i = 0; i < HPI_MAX_CHANNELS; i++)\n\t\t\tan_peakdB[i] = HPI_METER_MINIMUM;\n\treturn hr.error;\n}\n\nu16 hpi_meter_get_rms(u32 h_control, short an_rmsdB[HPI_MAX_CHANNELS]\n\t)\n{\n\tshort i = 0;\n\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_METER_RMS;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (!hr.error)\n\t\tmemcpy(an_rmsdB, hr.u.c.an_log_value,\n\t\t\tsizeof(short) * HPI_MAX_CHANNELS);\n\telse\n\t\tfor (i = 0; i < HPI_MAX_CHANNELS; i++)\n\t\t\tan_rmsdB[i] = HPI_METER_MINIMUM;\n\n\treturn hr.error;\n}\n\nu16 hpi_meter_set_rms_ballistics(u32 h_control, u16 attack, u16 decay)\n{\n\treturn hpi_control_param_set(h_control, HPI_METER_RMS_BALLISTICS,\n\t\tattack, decay);\n}\n\nu16 hpi_meter_get_rms_ballistics(u32 h_control, u16 *pn_attack, u16 *pn_decay)\n{\n\tu32 attack;\n\tu32 decay;\n\tu16 error;\n\n\terror = hpi_control_param2_get(h_control, HPI_METER_RMS_BALLISTICS,\n\t\t&attack, &decay);\n\n\tif (pn_attack)\n\t\t*pn_attack = (unsigned short)attack;\n\tif (pn_decay)\n\t\t*pn_decay = (unsigned short)decay;\n\n\treturn error;\n}\n\nu16 hpi_meter_set_peak_ballistics(u32 h_control, u16 attack, u16 decay)\n{\n\treturn hpi_control_param_set(h_control, HPI_METER_PEAK_BALLISTICS,\n\t\tattack, decay);\n}\n\nu16 hpi_meter_get_peak_ballistics(u32 h_control, u16 *pn_attack,\n\tu16 *pn_decay)\n{\n\tu32 attack;\n\tu32 decay;\n\tu16 error;\n\n\terror = hpi_control_param2_get(h_control, HPI_METER_PEAK_BALLISTICS,\n\t\t&attack, &decay);\n\n\tif (pn_attack)\n\t\t*pn_attack = (short)attack;\n\tif (pn_decay)\n\t\t*pn_decay = (short)decay;\n\n\treturn error;\n}\n\nu16 hpi_microphone_set_phantom_power(u32 h_control, u16 on_off)\n{\n\treturn hpi_control_param_set(h_control, HPI_MICROPHONE_PHANTOM_POWER,\n\t\t(u32)on_off, 0);\n}\n\nu16 hpi_microphone_get_phantom_power(u32 h_control, u16 *pw_on_off)\n{\n\tu16 error = 0;\n\tu32 on_off = 0;\n\terror = hpi_control_param1_get(h_control,\n\t\tHPI_MICROPHONE_PHANTOM_POWER, &on_off);\n\tif (pw_on_off)\n\t\t*pw_on_off = (u16)on_off;\n\treturn error;\n}\n\nu16 hpi_multiplexer_set_source(u32 h_control, u16 source_node_type,\n\tu16 source_node_index)\n{\n\treturn hpi_control_param_set(h_control, HPI_MULTIPLEXER_SOURCE,\n\t\tsource_node_type, source_node_index);\n}\n\nu16 hpi_multiplexer_get_source(u32 h_control, u16 *source_node_type,\n\tu16 *source_node_index)\n{\n\tu32 node, index;\n\tu16 err = hpi_control_param2_get(h_control,\n\t\tHPI_MULTIPLEXER_SOURCE, &node,\n\t\t&index);\n\tif (source_node_type)\n\t\t*source_node_type = (u16)node;\n\tif (source_node_index)\n\t\t*source_node_index = (u16)index;\n\treturn err;\n}\n\nu16 hpi_multiplexer_query_source(u32 h_control, u16 index,\n\tu16 *source_node_type, u16 *source_node_index)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_MULTIPLEXER_QUERYSOURCE;\n\thm.u.c.param1 = index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (source_node_type)\n\t\t*source_node_type = (u16)hr.u.c.param1;\n\tif (source_node_index)\n\t\t*source_node_index = (u16)hr.u.c.param2;\n\treturn hr.error;\n}\n\nu16 hpi_parametric_eq_get_info(u32 h_control, u16 *pw_number_of_bands,\n\tu16 *pw_on_off)\n{\n\tu32 oB = 0;\n\tu32 oO = 0;\n\tu16 error = 0;\n\n\terror = hpi_control_param2_get(h_control, HPI_EQUALIZER_NUM_FILTERS,\n\t\t&oO, &oB);\n\tif (pw_number_of_bands)\n\t\t*pw_number_of_bands = (u16)oB;\n\tif (pw_on_off)\n\t\t*pw_on_off = (u16)oO;\n\treturn error;\n}\n\nu16 hpi_parametric_eq_set_state(u32 h_control, u16 on_off)\n{\n\treturn hpi_control_param_set(h_control, HPI_EQUALIZER_NUM_FILTERS,\n\t\ton_off, 0);\n}\n\nu16 hpi_parametric_eq_get_band(u32 h_control, u16 index, u16 *pn_type,\n\tu32 *pfrequency_hz, short *pnQ100, short *pn_gain0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_EQUALIZER_FILTER;\n\thm.u.c.param2 = index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tif (pfrequency_hz)\n\t\t*pfrequency_hz = hr.u.c.param1;\n\tif (pn_type)\n\t\t*pn_type = (u16)(hr.u.c.param2 >> 16);\n\tif (pnQ100)\n\t\t*pnQ100 = hr.u.c.an_log_value[1];\n\tif (pn_gain0_01dB)\n\t\t*pn_gain0_01dB = hr.u.c.an_log_value[0];\n\n\treturn hr.error;\n}\n\nu16 hpi_parametric_eq_set_band(u32 h_control, u16 index, u16 type,\n\tu32 frequency_hz, short q100, short gain0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\thm.u.c.param1 = frequency_hz;\n\thm.u.c.param2 = (index & 0xFFFFL) + ((u32)type << 16);\n\thm.u.c.an_log_value[0] = gain0_01dB;\n\thm.u.c.an_log_value[1] = q100;\n\thm.u.c.attribute = HPI_EQUALIZER_FILTER;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_parametric_eq_get_coeffs(u32 h_control, u16 index, short coeffs[5]\n\t)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_EQUALIZER_COEFFICIENTS;\n\thm.u.c.param2 = index;\n\n\thpi_send_recv(&hm, &hr);\n\n\tcoeffs[0] = (short)hr.u.c.an_log_value[0];\n\tcoeffs[1] = (short)hr.u.c.an_log_value[1];\n\tcoeffs[2] = (short)hr.u.c.param1;\n\tcoeffs[3] = (short)(hr.u.c.param1 >> 16);\n\tcoeffs[4] = (short)hr.u.c.param2;\n\n\treturn hr.error;\n}\n\nu16 hpi_sample_clock_query_source(const u32 h_clock, const u32 index,\n\tu16 *pw_source)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_clock, HPI_SAMPLECLOCK_SOURCE, index, 0,\n\t\t&qr);\n\t*pw_source = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_sample_clock_set_source(u32 h_control, u16 source)\n{\n\treturn hpi_control_param_set(h_control, HPI_SAMPLECLOCK_SOURCE,\n\t\tsource, 0);\n}\n\nu16 hpi_sample_clock_get_source(u32 h_control, u16 *pw_source)\n{\n\tu16 err = 0;\n\tu32 source = 0;\n\terr = hpi_control_param1_get(h_control, HPI_SAMPLECLOCK_SOURCE,\n\t\t&source);\n\tif (!err)\n\t\tif (pw_source)\n\t\t\t*pw_source = (u16)source;\n\treturn err;\n}\n\nu16 hpi_sample_clock_query_source_index(const u32 h_clock, const u32 index,\n\tconst u32 source, u16 *pw_source_index)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_clock, HPI_SAMPLECLOCK_SOURCE_INDEX, index,\n\t\tsource, &qr);\n\t*pw_source_index = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_sample_clock_set_source_index(u32 h_control, u16 source_index)\n{\n\treturn hpi_control_param_set(h_control, HPI_SAMPLECLOCK_SOURCE_INDEX,\n\t\tsource_index, 0);\n}\n\nu16 hpi_sample_clock_get_source_index(u32 h_control, u16 *pw_source_index)\n{\n\tu16 err = 0;\n\tu32 source_index = 0;\n\terr = hpi_control_param1_get(h_control, HPI_SAMPLECLOCK_SOURCE_INDEX,\n\t\t&source_index);\n\tif (!err)\n\t\tif (pw_source_index)\n\t\t\t*pw_source_index = (u16)source_index;\n\treturn err;\n}\n\nu16 hpi_sample_clock_query_local_rate(const u32 h_clock, const u32 index,\n\tu32 *prate)\n{\n\treturn hpi_control_query(h_clock, HPI_SAMPLECLOCK_LOCAL_SAMPLERATE,\n\t\t\t\t index, 0, prate);\n}\n\nu16 hpi_sample_clock_set_local_rate(u32 h_control, u32 sample_rate)\n{\n\treturn hpi_control_param_set(h_control,\n\t\tHPI_SAMPLECLOCK_LOCAL_SAMPLERATE, sample_rate, 0);\n}\n\nu16 hpi_sample_clock_get_local_rate(u32 h_control, u32 *psample_rate)\n{\n\tu16 err = 0;\n\tu32 sample_rate = 0;\n\terr = hpi_control_param1_get(h_control,\n\t\tHPI_SAMPLECLOCK_LOCAL_SAMPLERATE, &sample_rate);\n\tif (!err)\n\t\tif (psample_rate)\n\t\t\t*psample_rate = sample_rate;\n\treturn err;\n}\n\nu16 hpi_sample_clock_get_sample_rate(u32 h_control, u32 *psample_rate)\n{\n\tu16 err = 0;\n\tu32 sample_rate = 0;\n\terr = hpi_control_param1_get(h_control, HPI_SAMPLECLOCK_SAMPLERATE,\n\t\t&sample_rate);\n\tif (!err)\n\t\tif (psample_rate)\n\t\t\t*psample_rate = sample_rate;\n\treturn err;\n}\n\nu16 hpi_sample_clock_set_auto(u32 h_control, u32 enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_SAMPLECLOCK_AUTO, enable,\n\t\t0);\n}\n\nu16 hpi_sample_clock_get_auto(u32 h_control, u32 *penable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_SAMPLECLOCK_AUTO,\n\t\tpenable);\n}\n\nu16 hpi_sample_clock_set_local_rate_lock(u32 h_control, u32 lock)\n{\n\treturn hpi_control_param_set(h_control, HPI_SAMPLECLOCK_LOCAL_LOCK,\n\t\tlock, 0);\n}\n\nu16 hpi_sample_clock_get_local_rate_lock(u32 h_control, u32 *plock)\n{\n\treturn hpi_control_param1_get(h_control, HPI_SAMPLECLOCK_LOCAL_LOCK,\n\t\tplock);\n}\n\nu16 hpi_tone_detector_get_frequency(u32 h_control, u32 index, u32 *frequency)\n{\n\treturn hpi_control_param_get(h_control, HPI_TONEDETECTOR_FREQUENCY,\n\t\tindex, 0, frequency, NULL);\n}\n\nu16 hpi_tone_detector_get_state(u32 h_control, u32 *state)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TONEDETECTOR_STATE,\n\t\tstate);\n}\n\nu16 hpi_tone_detector_set_enable(u32 h_control, u32 enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_GENERIC_ENABLE, enable,\n\t\t0);\n}\n\nu16 hpi_tone_detector_get_enable(u32 h_control, u32 *enable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_GENERIC_ENABLE, enable);\n}\n\nu16 hpi_tone_detector_set_event_enable(u32 h_control, u32 event_enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_GENERIC_EVENT_ENABLE,\n\t\t(u32)event_enable, 0);\n}\n\nu16 hpi_tone_detector_get_event_enable(u32 h_control, u32 *event_enable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_GENERIC_EVENT_ENABLE,\n\t\tevent_enable);\n}\n\nu16 hpi_tone_detector_set_threshold(u32 h_control, int threshold)\n{\n\treturn hpi_control_param_set(h_control, HPI_TONEDETECTOR_THRESHOLD,\n\t\t(u32)threshold, 0);\n}\n\nu16 hpi_tone_detector_get_threshold(u32 h_control, int *threshold)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TONEDETECTOR_THRESHOLD,\n\t\t(u32 *)threshold);\n}\n\nu16 hpi_silence_detector_get_state(u32 h_control, u32 *state)\n{\n\treturn hpi_control_param1_get(h_control, HPI_SILENCEDETECTOR_STATE,\n\t\tstate);\n}\n\nu16 hpi_silence_detector_set_enable(u32 h_control, u32 enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_GENERIC_ENABLE, enable,\n\t\t0);\n}\n\nu16 hpi_silence_detector_get_enable(u32 h_control, u32 *enable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_GENERIC_ENABLE, enable);\n}\n\nu16 hpi_silence_detector_set_event_enable(u32 h_control, u32 event_enable)\n{\n\treturn hpi_control_param_set(h_control, HPI_GENERIC_EVENT_ENABLE,\n\t\tevent_enable, 0);\n}\n\nu16 hpi_silence_detector_get_event_enable(u32 h_control, u32 *event_enable)\n{\n\treturn hpi_control_param1_get(h_control, HPI_GENERIC_EVENT_ENABLE,\n\t\tevent_enable);\n}\n\nu16 hpi_silence_detector_set_delay(u32 h_control, u32 delay)\n{\n\treturn hpi_control_param_set(h_control, HPI_SILENCEDETECTOR_DELAY,\n\t\tdelay, 0);\n}\n\nu16 hpi_silence_detector_get_delay(u32 h_control, u32 *delay)\n{\n\treturn hpi_control_param1_get(h_control, HPI_SILENCEDETECTOR_DELAY,\n\t\tdelay);\n}\n\nu16 hpi_silence_detector_set_threshold(u32 h_control, int threshold)\n{\n\treturn hpi_control_param_set(h_control, HPI_SILENCEDETECTOR_THRESHOLD,\n\t\tthreshold, 0);\n}\n\nu16 hpi_silence_detector_get_threshold(u32 h_control, int *threshold)\n{\n\treturn hpi_control_param1_get(h_control,\n\t\tHPI_SILENCEDETECTOR_THRESHOLD, (u32 *)threshold);\n}\n\nu16 hpi_tuner_query_band(const u32 h_tuner, const u32 index, u16 *pw_band)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_tuner, HPI_TUNER_BAND, index, 0, &qr);\n\t*pw_band = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_tuner_set_band(u32 h_control, u16 band)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_BAND, band, 0);\n}\n\nu16 hpi_tuner_get_band(u32 h_control, u16 *pw_band)\n{\n\tu32 band = 0;\n\tu16 error = 0;\n\n\terror = hpi_control_param1_get(h_control, HPI_TUNER_BAND, &band);\n\tif (pw_band)\n\t\t*pw_band = (u16)band;\n\treturn error;\n}\n\nu16 hpi_tuner_query_frequency(const u32 h_tuner, const u32 index,\n\tconst u16 band, u32 *pfreq)\n{\n\treturn hpi_control_query(h_tuner, HPI_TUNER_FREQ, index, band, pfreq);\n}\n\nu16 hpi_tuner_set_frequency(u32 h_control, u32 freq_ink_hz)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_FREQ, freq_ink_hz,\n\t\t0);\n}\n\nu16 hpi_tuner_get_frequency(u32 h_control, u32 *pw_freq_ink_hz)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TUNER_FREQ,\n\t\tpw_freq_ink_hz);\n}\n\nu16 hpi_tuner_query_gain(const u32 h_tuner, const u32 index, u16 *pw_gain)\n{\n\tu32 qr;\n\tu16 err;\n\n\terr = hpi_control_query(h_tuner, HPI_TUNER_BAND, index, 0, &qr);\n\t*pw_gain = (u16)qr;\n\treturn err;\n}\n\nu16 hpi_tuner_set_gain(u32 h_control, short gain)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_GAIN, gain, 0);\n}\n\nu16 hpi_tuner_get_gain(u32 h_control, short *pn_gain)\n{\n\tu32 gain = 0;\n\tu16 error = 0;\n\n\terror = hpi_control_param1_get(h_control, HPI_TUNER_GAIN, &gain);\n\tif (pn_gain)\n\t\t*pn_gain = (u16)gain;\n\treturn error;\n}\n\nu16 hpi_tuner_get_rf_level(u32 h_control, short *pw_level)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.cu.attribute = HPI_TUNER_LEVEL_AVG;\n\thpi_send_recv(&hm, &hr);\n\tif (pw_level)\n\t\t*pw_level = hr.u.cu.tuner.s_level;\n\treturn hr.error;\n}\n\nu16 hpi_tuner_get_raw_rf_level(u32 h_control, short *pw_level)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.cu.attribute = HPI_TUNER_LEVEL_RAW;\n\thpi_send_recv(&hm, &hr);\n\tif (pw_level)\n\t\t*pw_level = hr.u.cu.tuner.s_level;\n\treturn hr.error;\n}\n\nu16 hpi_tuner_query_deemphasis(const u32 h_tuner, const u32 index,\n\tconst u16 band, u32 *pdeemphasis)\n{\n\treturn hpi_control_query(h_tuner, HPI_TUNER_DEEMPHASIS, index, band,\n\t\tpdeemphasis);\n}\n\nu16 hpi_tuner_set_deemphasis(u32 h_control, u32 deemphasis)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_DEEMPHASIS,\n\t\tdeemphasis, 0);\n}\n\nu16 hpi_tuner_get_deemphasis(u32 h_control, u32 *pdeemphasis)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TUNER_DEEMPHASIS,\n\t\tpdeemphasis);\n}\n\nu16 hpi_tuner_query_program(const u32 h_tuner, u32 *pbitmap_program)\n{\n\treturn hpi_control_query(h_tuner, HPI_TUNER_PROGRAM, 0, 0,\n\t\tpbitmap_program);\n}\n\nu16 hpi_tuner_set_program(u32 h_control, u32 program)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_PROGRAM, program,\n\t\t0);\n}\n\nu16 hpi_tuner_get_program(u32 h_control, u32 *pprogram)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TUNER_PROGRAM, pprogram);\n}\n\nu16 hpi_tuner_get_hd_radio_dsp_version(u32 h_control, char *psz_dsp_version,\n\tconst u32 string_size)\n{\n\treturn hpi_control_get_string(h_control,\n\t\tHPI_TUNER_HDRADIO_DSP_VERSION, psz_dsp_version, string_size);\n}\n\nu16 hpi_tuner_get_hd_radio_sdk_version(u32 h_control, char *psz_sdk_version,\n\tconst u32 string_size)\n{\n\treturn hpi_control_get_string(h_control,\n\t\tHPI_TUNER_HDRADIO_SDK_VERSION, psz_sdk_version, string_size);\n}\n\nu16 hpi_tuner_get_status(u32 h_control, u16 *pw_status_mask, u16 *pw_status)\n{\n\tu32 status = 0;\n\tu16 error = 0;\n\n\terror = hpi_control_param1_get(h_control, HPI_TUNER_STATUS, &status);\n\tif (pw_status) {\n\t\tif (!error) {\n\t\t\t*pw_status_mask = (u16)(status >> 16);\n\t\t\t*pw_status = (u16)(status & 0xFFFF);\n\t\t} else {\n\t\t\t*pw_status_mask = 0;\n\t\t\t*pw_status = 0;\n\t\t}\n\t}\n\treturn error;\n}\n\nu16 hpi_tuner_set_mode(u32 h_control, u32 mode, u32 value)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_MODE, mode, value);\n}\n\nu16 hpi_tuner_get_mode(u32 h_control, u32 mode, u32 *pn_value)\n{\n\treturn hpi_control_param_get(h_control, HPI_TUNER_MODE, mode, 0,\n\t\tpn_value, NULL);\n}\n\nu16 hpi_tuner_get_hd_radio_signal_quality(u32 h_control, u32 *pquality)\n{\n\treturn hpi_control_param1_get(h_control,\n\t\tHPI_TUNER_HDRADIO_SIGNAL_QUALITY, pquality);\n}\n\nu16 hpi_tuner_get_hd_radio_signal_blend(u32 h_control, u32 *pblend)\n{\n\treturn hpi_control_param1_get(h_control, HPI_TUNER_HDRADIO_BLEND,\n\t\tpblend);\n}\n\nu16 hpi_tuner_set_hd_radio_signal_blend(u32 h_control, const u32 blend)\n{\n\treturn hpi_control_param_set(h_control, HPI_TUNER_HDRADIO_BLEND,\n\t\tblend, 0);\n}\n\nu16 hpi_tuner_get_rds(u32 h_control, char *p_data)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_TUNER_RDS;\n\thpi_send_recv(&hm, &hr);\n\tif (p_data) {\n\t\t*(u32 *)&p_data[0] = hr.u.cu.tuner.rds.data[0];\n\t\t*(u32 *)&p_data[4] = hr.u.cu.tuner.rds.data[1];\n\t\t*(u32 *)&p_data[8] = hr.u.cu.tuner.rds.bLER;\n\t}\n\treturn hr.error;\n}\n\nu16 hpi_pad_get_channel_name(u32 h_control, char *psz_string,\n\tconst u32 data_length)\n{\n\treturn hpi_control_get_string(h_control, HPI_PAD_CHANNEL_NAME,\n\t\tpsz_string, data_length);\n}\n\nu16 hpi_pad_get_artist(u32 h_control, char *psz_string, const u32 data_length)\n{\n\treturn hpi_control_get_string(h_control, HPI_PAD_ARTIST, psz_string,\n\t\tdata_length);\n}\n\nu16 hpi_pad_get_title(u32 h_control, char *psz_string, const u32 data_length)\n{\n\treturn hpi_control_get_string(h_control, HPI_PAD_TITLE, psz_string,\n\t\tdata_length);\n}\n\nu16 hpi_pad_get_comment(u32 h_control, char *psz_string,\n\tconst u32 data_length)\n{\n\treturn hpi_control_get_string(h_control, HPI_PAD_COMMENT, psz_string,\n\t\tdata_length);\n}\n\nu16 hpi_pad_get_program_type(u32 h_control, u32 *ppTY)\n{\n\treturn hpi_control_param1_get(h_control, HPI_PAD_PROGRAM_TYPE, ppTY);\n}\n\nu16 hpi_pad_get_rdsPI(u32 h_control, u32 *ppI)\n{\n\treturn hpi_control_param1_get(h_control, HPI_PAD_PROGRAM_ID, ppI);\n}\n\nu16 hpi_volume_query_channels(const u32 h_volume, u32 *p_channels)\n{\n\treturn hpi_control_query(h_volume, HPI_VOLUME_NUM_CHANNELS, 0, 0,\n\t\tp_channels);\n}\n\nu16 hpi_volume_set_gain(u32 h_control, short an_log_gain[HPI_MAX_CHANNELS]\n\t)\n{\n\treturn hpi_control_log_set2(h_control, HPI_VOLUME_GAIN,\n\t\tan_log_gain[0], an_log_gain[1]);\n}\n\nu16 hpi_volume_get_gain(u32 h_control, short an_log_gain[HPI_MAX_CHANNELS]\n\t)\n{\n\treturn hpi_control_log_get2(h_control, HPI_VOLUME_GAIN,\n\t\t&an_log_gain[0], &an_log_gain[1]);\n}\n\nu16 hpi_volume_set_mute(u32 h_control, u32 mute)\n{\n\treturn hpi_control_param_set(h_control, HPI_VOLUME_MUTE, mute, 0);\n}\n\nu16 hpi_volume_get_mute(u32 h_control, u32 *mute)\n{\n\treturn hpi_control_param1_get(h_control, HPI_VOLUME_MUTE, mute);\n}\n\nu16 hpi_volume_query_range(u32 h_control, short *min_gain_01dB,\n\tshort *max_gain_01dB, short *step_gain_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_VOLUME_RANGE;\n\n\thpi_send_recv(&hm, &hr);\n\tif (hr.error) {\n\t\thr.u.c.an_log_value[0] = 0;\n\t\thr.u.c.an_log_value[1] = 0;\n\t\thr.u.c.param1 = 0;\n\t}\n\tif (min_gain_01dB)\n\t\t*min_gain_01dB = hr.u.c.an_log_value[0];\n\tif (max_gain_01dB)\n\t\t*max_gain_01dB = hr.u.c.an_log_value[1];\n\tif (step_gain_01dB)\n\t\t*step_gain_01dB = (short)hr.u.c.param1;\n\treturn hr.error;\n}\n\nu16 hpi_volume_auto_fade_profile(u32 h_control,\n\tshort an_stop_gain0_01dB[HPI_MAX_CHANNELS], u32 duration_ms,\n\tu16 profile)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\n\tmemcpy(hm.u.c.an_log_value, an_stop_gain0_01dB,\n\t\tsizeof(short) * HPI_MAX_CHANNELS);\n\n\thm.u.c.attribute = HPI_VOLUME_AUTOFADE;\n\thm.u.c.param1 = duration_ms;\n\thm.u.c.param2 = profile;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_volume_auto_fade(u32 h_control,\n\tshort an_stop_gain0_01dB[HPI_MAX_CHANNELS], u32 duration_ms)\n{\n\treturn hpi_volume_auto_fade_profile(h_control, an_stop_gain0_01dB,\n\t\tduration_ms, HPI_VOLUME_AUTOFADE_LOG);\n}\n\nu16 hpi_volume_query_auto_fade_profile(const u32 h_volume, const u32 i,\n\tu16 *profile)\n{\n\tu16 e;\n\tu32 u;\n\te = hpi_control_query(h_volume, HPI_VOLUME_AUTOFADE, i, 0, &u);\n\t*profile = (u16)u;\n\treturn e;\n}\n\nu16 hpi_vox_set_threshold(u32 h_control, short an_gain0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_SET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_VOX_THRESHOLD;\n\n\thm.u.c.an_log_value[0] = an_gain0_01dB;\n\n\thpi_send_recv(&hm, &hr);\n\n\treturn hr.error;\n}\n\nu16 hpi_vox_get_threshold(u32 h_control, short *an_gain0_01dB)\n{\n\tstruct hpi_message hm;\n\tstruct hpi_response hr;\n\thpi_init_message_response(&hm, &hr, HPI_OBJ_CONTROL,\n\t\tHPI_CONTROL_GET_STATE);\n\tif (hpi_handle_indexes(h_control, &hm.adapter_index, &hm.obj_index))\n\t\treturn HPI_ERROR_INVALID_HANDLE;\n\thm.u.c.attribute = HPI_VOX_THRESHOLD;\n\n\thpi_send_recv(&hm, &hr);\n\n\t*an_gain0_01dB = hr.u.c.an_log_value[0];\n\n\treturn hr.error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}