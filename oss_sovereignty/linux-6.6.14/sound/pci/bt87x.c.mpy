{
  "module_name": "bt87x.c",
  "hash_id": "4994bff912b24ade88e3573ae536d56b96088c3a44ce51235cbc3a200864acf7",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/bt87x.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"Brooktree Bt87x audio driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -2};  \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic int digital_rate[SNDRV_CARDS];\t \nstatic bool load_all;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Bt87x soundcard\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Bt87x soundcard\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Bt87x soundcard\");\nmodule_param_array(digital_rate, int, NULL, 0444);\nMODULE_PARM_DESC(digital_rate, \"Digital input rate for Bt87x soundcard\");\nmodule_param(load_all, bool, 0444);\nMODULE_PARM_DESC(load_all, \"Allow to load cards not on the allowlist\");\n\n\n \n#define REG_INT_STAT\t\t0x100\t \n#define REG_INT_MASK\t\t0x104\t \n#define REG_GPIO_DMA_CTL\t0x10c\t \n#define REG_PACKET_LEN\t\t0x110\t \n#define REG_RISC_STRT_ADD\t0x114\t \n#define REG_RISC_COUNT\t\t0x120\t \n\n \n#define INT_OFLOW\t(1 <<  3)\t \n#define INT_RISCI\t(1 << 11)\t \n#define INT_FBUS\t(1 << 12)\t \n#define INT_FTRGT\t(1 << 13)\t \n#define INT_FDSR\t(1 << 14)\t \n#define INT_PPERR\t(1 << 15)\t \n#define INT_RIPERR\t(1 << 16)\t \n#define INT_PABORT\t(1 << 17)\t \n#define INT_OCERR\t(1 << 18)\t \n#define INT_SCERR\t(1 << 19)\t \n#define INT_RISC_EN\t(1 << 27)\t \n#define INT_RISCS_SHIFT\t      28\t \n\n \n#define CTL_FIFO_ENABLE\t\t(1 <<  0)\t \n#define CTL_RISC_ENABLE\t\t(1 <<  1)\t \n#define CTL_PKTP_4\t\t(0 <<  2)\t \n#define CTL_PKTP_8\t\t(1 <<  2)\t \n#define CTL_PKTP_16\t\t(2 <<  2)\t \n#define CTL_ACAP_EN\t\t(1 <<  4)\t \n#define CTL_DA_APP\t\t(1 <<  5)\t \n#define CTL_DA_IOM_AFE\t\t(0 <<  6)\t \n#define CTL_DA_IOM_DA\t\t(1 <<  6)\t \n#define CTL_DA_SDR_SHIFT\t       8\t \n#define CTL_DA_SDR_MASK\t\t(0xf<< 8)\n#define CTL_DA_LMT\t\t(1 << 12)\t \n#define CTL_DA_ES2\t\t(1 << 13)\t \n#define CTL_DA_SBR\t\t(1 << 14)\t \n#define CTL_DA_DPM\t\t(1 << 15)\t \n#define CTL_DA_LRD_SHIFT\t      16\t \n#define CTL_DA_MLB\t\t(1 << 21)\t \n#define CTL_DA_LRI\t\t(1 << 22)\t \n#define CTL_DA_SCE\t\t(1 << 23)\t \n#define CTL_A_SEL_STV\t\t(0 << 24)\t \n#define CTL_A_SEL_SFM\t\t(1 << 24)\t \n#define CTL_A_SEL_SML\t\t(2 << 24)\t \n#define CTL_A_SEL_SMXC\t\t(3 << 24)\t \n#define CTL_A_SEL_SHIFT\t\t      24\n#define CTL_A_SEL_MASK\t\t(3 << 24)\n#define CTL_A_PWRDN\t\t(1 << 26)\t \n#define CTL_A_G2X\t\t(1 << 27)\t \n#define CTL_A_GAIN_SHIFT\t      28\t \n#define CTL_A_GAIN_MASK\t\t(0xf<<28)\n\n \n#define RISC_WRITE\t(0x1 << 28)\t \n#define RISC_WRITEC\t(0x5 << 28)\t \n#define RISC_SKIP\t(0x2 << 28)\t \n#define RISC_JUMP\t(0x7 << 28)\t \n#define RISC_SYNC\t(0x8 << 28)\t \n\n \n#define RISC_BYTES_ENABLE\t(0xf << 12)\t \n#define RISC_RESYNC\t\t(  1 << 15)\t \n#define RISC_SET_STATUS_SHIFT\t        16\t \n#define RISC_RESET_STATUS_SHIFT\t        20\t \n#define RISC_IRQ\t\t(  1 << 24)\t \n#define RISC_EOL\t\t(  1 << 26)\t \n#define RISC_SOL\t\t(  1 << 27)\t \n\n \n#define RISC_SYNC_FM1\t0x6\n#define RISC_SYNC_VRO\t0xc\n\n#define ANALOG_CLOCK 1792000\n#ifdef CONFIG_SND_BT87X_OVERCLOCK\n#define CLOCK_DIV_MIN 1\n#else\n#define CLOCK_DIV_MIN 4\n#endif\n#define CLOCK_DIV_MAX 15\n\n#define ERROR_INTERRUPTS (INT_FBUS | INT_FTRGT | INT_PPERR | \\\n\t\t\t  INT_RIPERR | INT_PABORT | INT_OCERR)\n#define MY_INTERRUPTS (INT_RISCI | ERROR_INTERRUPTS)\n\n \n#define MAX_RISC_SIZE ((1 + 255 + (PAGE_ALIGN(255 * 4092) / PAGE_SIZE - 1) + 1 + 1) * 8)\n\n \nenum snd_bt87x_boardid {\n\tSND_BT87X_BOARD_UNKNOWN,\n\tSND_BT87X_BOARD_GENERIC,\t \n\tSND_BT87X_BOARD_ANALOG,\t\t \n\tSND_BT87X_BOARD_OSPREY2x0,\n\tSND_BT87X_BOARD_OSPREY440,\n\tSND_BT87X_BOARD_AVPHONE98,\n};\n\n \nstruct snd_bt87x_board {\n\tint dig_rate;\t\t \n\tu32 digital_fmt;\t \n\tunsigned no_analog:1;\t \n\tunsigned no_digital:1;\t \n};\n\nstatic const struct snd_bt87x_board snd_bt87x_boards[] = {\n\t[SND_BT87X_BOARD_UNKNOWN] = {\n\t\t.dig_rate = 32000,  \n\t},\n\t[SND_BT87X_BOARD_GENERIC] = {\n\t\t.dig_rate = 32000,\n\t},\n\t[SND_BT87X_BOARD_ANALOG] = {\n\t\t.no_digital = 1,\n\t},\n\t[SND_BT87X_BOARD_OSPREY2x0] = {\n\t\t.dig_rate = 44100,\n\t\t.digital_fmt = CTL_DA_LRI | (1 << CTL_DA_LRD_SHIFT),\n\t},\n\t[SND_BT87X_BOARD_OSPREY440] = {\n\t\t.dig_rate = 32000,\n\t\t.digital_fmt = CTL_DA_LRI | (1 << CTL_DA_LRD_SHIFT),\n\t\t.no_analog = 1,\n\t},\n\t[SND_BT87X_BOARD_AVPHONE98] = {\n\t\t.dig_rate = 48000,\n\t},\n};\n\nstruct snd_bt87x {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\tstruct snd_bt87x_board board;\n\n\tvoid __iomem *mmio;\n\tint irq;\n\n\tspinlock_t reg_lock;\n\tunsigned long opened;\n\tstruct snd_pcm_substream *substream;\n\n\tstruct snd_dma_buffer dma_risc;\n\tunsigned int line_bytes;\n\tunsigned int lines;\n\n\tu32 reg_control;\n\tu32 interrupt_mask;\n\n\tint current_line;\n\n\tint pci_parity_errors;\n};\n\nenum { DEVICE_DIGITAL, DEVICE_ANALOG };\n\nstatic inline u32 snd_bt87x_readl(struct snd_bt87x *chip, u32 reg)\n{\n\treturn readl(chip->mmio + reg);\n}\n\nstatic inline void snd_bt87x_writel(struct snd_bt87x *chip, u32 reg, u32 value)\n{\n\twritel(value, chip->mmio + reg);\n}\n\nstatic int snd_bt87x_create_risc(struct snd_bt87x *chip, struct snd_pcm_substream *substream,\n\t\t\t       \t unsigned int periods, unsigned int period_bytes)\n{\n\tunsigned int i, offset;\n\t__le32 *risc;\n\n\tif (chip->dma_risc.area == NULL) {\n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t\tPAGE_ALIGN(MAX_RISC_SIZE), &chip->dma_risc) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\trisc = (__le32 *)chip->dma_risc.area;\n\toffset = 0;\n\t*risc++ = cpu_to_le32(RISC_SYNC | RISC_SYNC_FM1);\n\t*risc++ = cpu_to_le32(0);\n\tfor (i = 0; i < periods; ++i) {\n\t\tu32 rest;\n\n\t\trest = period_bytes;\n\t\tdo {\n\t\t\tu32 cmd, len;\n\t\t\tunsigned int addr;\n\n\t\t\tlen = PAGE_SIZE - (offset % PAGE_SIZE);\n\t\t\tif (len > rest)\n\t\t\t\tlen = rest;\n\t\t\tcmd = RISC_WRITE | len;\n\t\t\tif (rest == period_bytes) {\n\t\t\t\tu32 block = i * 16 / periods;\n\t\t\t\tcmd |= RISC_SOL;\n\t\t\t\tcmd |= block << RISC_SET_STATUS_SHIFT;\n\t\t\t\tcmd |= (~block & 0xf) << RISC_RESET_STATUS_SHIFT;\n\t\t\t}\n\t\t\tif (len == rest)\n\t\t\t\tcmd |= RISC_EOL | RISC_IRQ;\n\t\t\t*risc++ = cpu_to_le32(cmd);\n\t\t\taddr = snd_pcm_sgbuf_get_addr(substream, offset);\n\t\t\t*risc++ = cpu_to_le32(addr);\n\t\t\toffset += len;\n\t\t\trest -= len;\n\t\t} while (rest > 0);\n\t}\n\t*risc++ = cpu_to_le32(RISC_SYNC | RISC_SYNC_VRO);\n\t*risc++ = cpu_to_le32(0);\n\t*risc++ = cpu_to_le32(RISC_JUMP);\n\t*risc++ = cpu_to_le32(chip->dma_risc.addr);\n\tchip->line_bytes = period_bytes;\n\tchip->lines = periods;\n\treturn 0;\n}\n\nstatic void snd_bt87x_free_risc(struct snd_bt87x *chip)\n{\n\tif (chip->dma_risc.area) {\n\t\tsnd_dma_free_pages(&chip->dma_risc);\n\t\tchip->dma_risc.area = NULL;\n\t}\n}\n\nstatic void snd_bt87x_pci_error(struct snd_bt87x *chip, unsigned int status)\n{\n\tint pci_status = pci_status_get_and_clear_errors(chip->pci);\n\n\tif (pci_status != PCI_STATUS_DETECTED_PARITY)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Aieee - PCI error! status %#08x, PCI status %#04x\\n\",\n\t\t\t   status & ERROR_INTERRUPTS, pci_status);\n\telse {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Aieee - PCI parity error detected!\\n\");\n\t\t \n\t\tchip->pci_parity_errors++;\n\t\tif (chip->pci_parity_errors > 20) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Too many PCI parity errors observed.\\n\");\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Some device on this bus is generating bad parity.\\n\");\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"This is an error *observed by*, not *generated by*, this card.\\n\");\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"PCI parity error checking has been disabled.\\n\");\n\t\t\tchip->interrupt_mask &= ~(INT_PPERR | INT_RIPERR);\n\t\t\tsnd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t snd_bt87x_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_bt87x *chip = dev_id;\n\tunsigned int status, irq_status;\n\n\tstatus = snd_bt87x_readl(chip, REG_INT_STAT);\n\tirq_status = status & chip->interrupt_mask;\n\tif (!irq_status)\n\t\treturn IRQ_NONE;\n\tsnd_bt87x_writel(chip, REG_INT_STAT, irq_status);\n\n\tif (irq_status & ERROR_INTERRUPTS) {\n\t\tif (irq_status & (INT_FBUS | INT_FTRGT))\n\t\t\tdev_warn(chip->card->dev,\n\t\t\t\t \"FIFO overrun, status %#08x\\n\", status);\n\t\tif (irq_status & INT_OCERR)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"internal RISC error, status %#08x\\n\", status);\n\t\tif (irq_status & (INT_PPERR | INT_RIPERR | INT_PABORT))\n\t\t\tsnd_bt87x_pci_error(chip, irq_status);\n\t}\n\tif ((irq_status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {\n\t\tint current_block, irq_block;\n\n\t\t \n\t\tchip->current_line = (chip->current_line + 1) % chip->lines;\n\t\t \n\t\tcurrent_block = chip->current_line * 16 / chip->lines;\n\t\tirq_block = status >> INT_RISCS_SHIFT;\n\t\tif (current_block != irq_block)\n\t\t\tchip->current_line = DIV_ROUND_UP(irq_block * chip->lines,\n\t\t\t\t\t\t\t  16);\n\n\t\tsnd_pcm_period_elapsed(chip->substream);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware snd_bt87x_digital_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates = 0,  \n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = 255 * 4092,\n\t.period_bytes_min = 32,\n\t.period_bytes_max = 4092,\n\t.periods_min = 2,\n\t.periods_max = 255,\n};\n\nstatic const struct snd_pcm_hardware snd_bt87x_analog_hw = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BATCH,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8,\n\t.rates = SNDRV_PCM_RATE_KNOT,\n\t.rate_min = ANALOG_CLOCK / CLOCK_DIV_MAX,\n\t.rate_max = ANALOG_CLOCK / CLOCK_DIV_MIN,\n\t.channels_min = 1,\n\t.channels_max = 1,\n\t.buffer_bytes_max = 255 * 4092,\n\t.period_bytes_min = 32,\n\t.period_bytes_max = 4092,\n\t.periods_min = 2,\n\t.periods_max = 255,\n};\n\nstatic int snd_bt87x_set_digital_hw(struct snd_bt87x *chip, struct snd_pcm_runtime *runtime)\n{\n\tchip->reg_control |= CTL_DA_IOM_DA | CTL_A_PWRDN;\n\truntime->hw = snd_bt87x_digital_hw;\n\truntime->hw.rates = snd_pcm_rate_to_rate_bit(chip->board.dig_rate);\n\truntime->hw.rate_min = chip->board.dig_rate;\n\truntime->hw.rate_max = chip->board.dig_rate;\n\treturn 0;\n}\n\nstatic int snd_bt87x_set_analog_hw(struct snd_bt87x *chip, struct snd_pcm_runtime *runtime)\n{\n\tstatic const struct snd_ratnum analog_clock = {\n\t\t.num = ANALOG_CLOCK,\n\t\t.den_min = CLOCK_DIV_MIN,\n\t\t.den_max = CLOCK_DIV_MAX,\n\t\t.den_step = 1\n\t};\n\tstatic const struct snd_pcm_hw_constraint_ratnums constraint_rates = {\n\t\t.nrats = 1,\n\t\t.rats = &analog_clock\n\t};\n\n\tchip->reg_control &= ~(CTL_DA_IOM_DA | CTL_A_PWRDN);\n\truntime->hw = snd_bt87x_analog_hw;\n\treturn snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t     &constraint_rates);\n}\n\nstatic int snd_bt87x_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tif (test_and_set_bit(0, &chip->opened))\n\t\treturn -EBUSY;\n\n\tif (substream->pcm->device == DEVICE_DIGITAL)\n\t\terr = snd_bt87x_set_digital_hw(chip, runtime);\n\telse\n\t\terr = snd_bt87x_set_analog_hw(chip, runtime);\n\tif (err < 0)\n\t\tgoto _error;\n\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tchip->substream = substream;\n\treturn 0;\n\n_error:\n\tclear_bit(0, &chip->opened);\n\tsmp_mb__after_atomic();\n\treturn err;\n}\n\nstatic int snd_bt87x_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->reg_control |= CTL_A_PWRDN;\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tspin_unlock_irq(&chip->reg_lock);\n\n\tchip->substream = NULL;\n\tclear_bit(0, &chip->opened);\n\tsmp_mb__after_atomic();\n\treturn 0;\n}\n\nstatic int snd_bt87x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_bt87x_create_risc(chip, substream,\n\t\t\t\t     params_periods(hw_params),\n\t\t\t\t     params_period_bytes(hw_params));\n}\n\nstatic int snd_bt87x_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_bt87x_free_risc(chip);\n\treturn 0;\n}\n\nstatic int snd_bt87x_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint decimation;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->reg_control &= ~(CTL_DA_SDR_MASK | CTL_DA_SBR);\n\tdecimation = (ANALOG_CLOCK + runtime->rate / 4) / runtime->rate;\n\tchip->reg_control |= decimation << CTL_DA_SDR_SHIFT;\n\tif (runtime->format == SNDRV_PCM_FORMAT_S8)\n\t\tchip->reg_control |= CTL_DA_SBR;\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_bt87x_start(struct snd_bt87x *chip)\n{\n\tspin_lock(&chip->reg_lock);\n\tchip->current_line = 0;\n\tchip->reg_control |= CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN;\n\tsnd_bt87x_writel(chip, REG_RISC_STRT_ADD, chip->dma_risc.addr);\n\tsnd_bt87x_writel(chip, REG_PACKET_LEN,\n\t\t\t chip->line_bytes | (chip->lines << 16));\n\tsnd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_bt87x_stop(struct snd_bt87x *chip)\n{\n\tspin_lock(&chip->reg_lock);\n\tchip->reg_control &= ~(CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN);\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tsnd_bt87x_writel(chip, REG_INT_MASK, 0);\n\tsnd_bt87x_writel(chip, REG_INT_STAT, MY_INTERRUPTS);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_bt87x_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\treturn snd_bt87x_start(chip);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn snd_bt87x_stop(chip);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic snd_pcm_uframes_t snd_bt87x_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_bt87x *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\treturn (snd_pcm_uframes_t)bytes_to_frames(runtime, chip->current_line * chip->line_bytes);\n}\n\nstatic const struct snd_pcm_ops snd_bt87x_pcm_ops = {\n\t.open = snd_bt87x_pcm_open,\n\t.close = snd_bt87x_close,\n\t.hw_params = snd_bt87x_hw_params,\n\t.hw_free = snd_bt87x_hw_free,\n\t.prepare = snd_bt87x_prepare,\n\t.trigger = snd_bt87x_trigger,\n\t.pointer = snd_bt87x_pointer,\n};\n\nstatic int snd_bt87x_capture_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *info)\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tinfo->count = 1;\n\tinfo->value.integer.min = 0;\n\tinfo->value.integer.max = 15;\n\treturn 0;\n}\n\nstatic int snd_bt87x_capture_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\n\tvalue->value.integer.value[0] = (chip->reg_control & CTL_A_GAIN_MASK) >> CTL_A_GAIN_SHIFT;\n\treturn 0;\n}\n\nstatic int snd_bt87x_capture_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\tu32 old_control;\n\tint changed;\n\n\tspin_lock_irq(&chip->reg_lock);\n\told_control = chip->reg_control;\n\tchip->reg_control = (chip->reg_control & ~CTL_A_GAIN_MASK)\n\t\t| (value->value.integer.value[0] << CTL_A_GAIN_SHIFT);\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tchanged = old_control != chip->reg_control;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_bt87x_capture_volume = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Volume\",\n\t.info = snd_bt87x_capture_volume_info,\n\t.get = snd_bt87x_capture_volume_get,\n\t.put = snd_bt87x_capture_volume_put,\n};\n\n#define snd_bt87x_capture_boost_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_bt87x_capture_boost_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\n\tvalue->value.integer.value[0] = !! (chip->reg_control & CTL_A_G2X);\n\treturn 0;\n}\n\nstatic int snd_bt87x_capture_boost_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\tu32 old_control;\n\tint changed;\n\n\tspin_lock_irq(&chip->reg_lock);\n\told_control = chip->reg_control;\n\tchip->reg_control = (chip->reg_control & ~CTL_A_G2X)\n\t\t| (value->value.integer.value[0] ? CTL_A_G2X : 0);\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tchanged = chip->reg_control != old_control;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_bt87x_capture_boost = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Boost\",\n\t.info = snd_bt87x_capture_boost_info,\n\t.get = snd_bt87x_capture_boost_get,\n\t.put = snd_bt87x_capture_boost_put,\n};\n\nstatic int snd_bt87x_capture_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const texts[3] = {\"TV Tuner\", \"FM\", \"Mic/Line\"};\n\n\treturn snd_ctl_enum_info(info, 1, 3, texts);\n}\n\nstatic int snd_bt87x_capture_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\n\tvalue->value.enumerated.item[0] = (chip->reg_control & CTL_A_SEL_MASK) >> CTL_A_SEL_SHIFT;\n\treturn 0;\n}\n\nstatic int snd_bt87x_capture_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *value)\n{\n\tstruct snd_bt87x *chip = snd_kcontrol_chip(kcontrol);\n\tu32 old_control;\n\tint changed;\n\n\tspin_lock_irq(&chip->reg_lock);\n\told_control = chip->reg_control;\n\tchip->reg_control = (chip->reg_control & ~CTL_A_SEL_MASK)\n\t\t| (value->value.enumerated.item[0] << CTL_A_SEL_SHIFT);\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tchanged = chip->reg_control != old_control;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_bt87x_capture_source = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Capture Source\",\n\t.info = snd_bt87x_capture_source_info,\n\t.get = snd_bt87x_capture_source_get,\n\t.put = snd_bt87x_capture_source_put,\n};\n\nstatic void snd_bt87x_free(struct snd_card *card)\n{\n\tstruct snd_bt87x *chip = card->private_data;\n\n\tsnd_bt87x_stop(chip);\n}\n\nstatic int snd_bt87x_pcm(struct snd_bt87x *chip, int device, char *name)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\terr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, name);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_bt87x_pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       128 * 1024,\n\t\t\t\t       ALIGN(255 * 4092, 1024));\n\treturn 0;\n}\n\nstatic int snd_bt87x_create(struct snd_card *card,\n\t\t\t    struct pci_dev *pci)\n{\n\tstruct snd_bt87x *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tspin_lock_init(&chip->reg_lock);\n\n\terr = pcim_iomap_regions(pci, 1 << 0, \"Bt87x audio\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->mmio = pcim_iomap_table(pci)[0];\n\n\tchip->reg_control = CTL_A_PWRDN | CTL_DA_ES2 |\n\t\t\t    CTL_PKTP_16 | (15 << CTL_DA_SDR_SHIFT);\n\tchip->interrupt_mask = MY_INTERRUPTS;\n\tsnd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);\n\tsnd_bt87x_writel(chip, REG_INT_MASK, 0);\n\tsnd_bt87x_writel(chip, REG_INT_STAT, MY_INTERRUPTS);\n\n\terr = devm_request_irq(&pci->dev, pci->irq, snd_bt87x_interrupt,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"cannot grab irq %d\\n\", pci->irq);\n\t\treturn err;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_bt87x_free;\n\tpci_set_master(pci);\n\n\treturn 0;\n}\n\n#define BT_DEVICE(chip, subvend, subdev, id) \\\n\t{ .vendor = PCI_VENDOR_ID_BROOKTREE, \\\n\t  .device = chip, \\\n\t  .subvendor = subvend, .subdevice = subdev, \\\n\t  .driver_data = SND_BT87X_BOARD_ ## id }\n \n\nstatic const struct pci_device_id snd_bt87x_ids[] = {\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x0070, 0x13eb, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_879, 0x0070, 0x13eb, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x0070, 0xff01, OSPREY2x0),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x0070, 0xff07, OSPREY440),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x1002, 0x0001, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x107d, 0x6606, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x11bd, 0x0012, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x121a, 0x3000, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x144f, 0x3000, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x1461, 0x0003, AVPHONE98),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0x1554, 0x4011, GENERIC),\n\t \n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, 0xbd11, 0x1200, GENERIC),\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, snd_bt87x_ids);\n\n \nstatic struct {\n\tunsigned short subvendor, subdevice;\n} denylist[] = {\n\t{0x0071, 0x0101},  \n\t{0x11bd, 0x001c},  \n\t{0x11bd, 0x0026},  \n\t{0x1461, 0x0761},  \n\t{0x1461, 0x0771},  \n\t{0x1822, 0x0001},  \n\t{0x18ac, 0xd500},  \n\t{0x18ac, 0xdb10},  \n\t{0x18ac, 0xdb11},  \n\t{0x270f, 0xfc00},  \n\t{0x7063, 0x2000},  \n};\n\nstatic struct pci_driver driver;\n\n \nstatic int snd_bt87x_detect_card(struct pci_dev *pci)\n{\n\tint i;\n\tconst struct pci_device_id *supported;\n\n\tsupported = pci_match_id(snd_bt87x_ids, pci);\n\tif (supported && supported->driver_data > 0)\n\t\treturn supported->driver_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(denylist); ++i)\n\t\tif (denylist[i].subvendor == pci->subsystem_vendor &&\n\t\t    denylist[i].subdevice == pci->subsystem_device) {\n\t\t\tdev_dbg(&pci->dev,\n\t\t\t\t\"card %#04x-%#04x:%#04x has no audio\\n\",\n\t\t\t\t    pci->device, pci->subsystem_vendor, pci->subsystem_device);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\tdev_info(&pci->dev, \"unknown card %#04x-%#04x:%#04x\\n\",\n\t\t   pci->device, pci->subsystem_vendor, pci->subsystem_device);\n\tdev_info(&pci->dev, \"please mail id, board name, and, \"\n\t\t   \"if it works, the correct digital_rate option to \"\n\t\t   \"<alsa-devel@alsa-project.org>\\n\");\n\treturn SND_BT87X_BOARD_UNKNOWN;\n}\n\nstatic int __snd_bt87x_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_bt87x *chip;\n\tint err;\n\tenum snd_bt87x_boardid boardid;\n\n\tif (!pci_id->driver_data) {\n\t\terr = snd_bt87x_detect_card(pci);\n\t\tif (err < 0)\n\t\t\treturn -ENODEV;\n\t\tboardid = err;\n\t} else\n\t\tboardid = pci_id->driver_data;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\t++dev;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_bt87x_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemcpy(&chip->board, &snd_bt87x_boards[boardid], sizeof(chip->board));\n\n\tif (!chip->board.no_digital) {\n\t\tif (digital_rate[dev] > 0)\n\t\t\tchip->board.dig_rate = digital_rate[dev];\n\n\t\tchip->reg_control |= chip->board.digital_fmt;\n\n\t\terr = snd_bt87x_pcm(chip, DEVICE_DIGITAL, \"Bt87x Digital\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (!chip->board.no_analog) {\n\t\terr = snd_bt87x_pcm(chip, DEVICE_ANALOG, \"Bt87x Analog\");\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(\n\t\t\t\t  &snd_bt87x_capture_volume, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(\n\t\t\t\t  &snd_bt87x_capture_boost, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(\n\t\t\t\t  &snd_bt87x_capture_source, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tdev_info(card->dev, \"bt87x%d: Using board %d, %sanalog, %sdigital \"\n\t\t   \"(rate %d Hz)\\n\", dev, boardid,\n\t\t   chip->board.no_analog ? \"no \" : \"\",\n\t\t   chip->board.no_digital ? \"no \" : \"\", chip->board.dig_rate);\n\n\tstrcpy(card->driver, \"Bt87x\");\n\tsprintf(card->shortname, \"Brooktree Bt%x\", pci->device);\n\tsprintf(card->longname, \"%s at %#llx, irq %i\",\n\t\tcard->shortname, (unsigned long long)pci_resource_start(pci, 0),\n\t\tchip->irq);\n\tstrcpy(card->mixername, \"Bt87x\");\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\t++dev;\n\treturn 0;\n}\n\nstatic int snd_bt87x_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_bt87x_probe(pci, pci_id));\n}\n\n \n \nstatic const struct pci_device_id snd_bt87x_default_ids[] = {\n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_878, PCI_ANY_ID, PCI_ANY_ID, UNKNOWN),\n\tBT_DEVICE(PCI_DEVICE_ID_BROOKTREE_879, PCI_ANY_ID, PCI_ANY_ID, UNKNOWN),\n\t{ }\n};\n\nstatic struct pci_driver driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_bt87x_ids,\n\t.probe = snd_bt87x_probe,\n};\n\nstatic int __init alsa_card_bt87x_init(void)\n{\n\tif (load_all)\n\t\tdriver.id_table = snd_bt87x_default_ids;\n\treturn pci_register_driver(&driver);\n}\n\nstatic void __exit alsa_card_bt87x_exit(void)\n{\n\tpci_unregister_driver(&driver);\n}\n\nmodule_init(alsa_card_bt87x_init)\nmodule_exit(alsa_card_bt87x_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}