{
  "module_name": "rme96.c",
  "hash_id": "34626d2c03d10f6aa80af70ea9a7e1632abbacf4ccfbddf5c9cd8e0cf245c8c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/rme96.c",
  "human_readable_source": "\n       \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n\n \n\nMODULE_AUTHOR(\"Anders Torger <torger@ludd.luth.se>\");\nMODULE_DESCRIPTION(\"RME Digi96, Digi96/8, Digi96/8 PRO, Digi96/8 PST, \"\n\t\t   \"Digi96/8 PAD\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for RME Digi96 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for RME Digi96 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable RME Digi96 soundcard.\");\n\n \n\n#define RME96_SPDIF_NCHANNELS 2\n\n \n#define RME96_BUFFER_SIZE 0x10000\n\n \n#define RME96_IO_SIZE 0x60000\n\n \n#define RME96_IO_PLAY_BUFFER      0x0\n#define RME96_IO_REC_BUFFER       0x10000\n#define RME96_IO_CONTROL_REGISTER 0x20000\n#define RME96_IO_ADDITIONAL_REG   0x20004\n#define RME96_IO_CONFIRM_PLAY_IRQ 0x20008\n#define RME96_IO_CONFIRM_REC_IRQ  0x2000C\n#define RME96_IO_SET_PLAY_POS     0x40000\n#define RME96_IO_RESET_PLAY_POS   0x4FFFC\n#define RME96_IO_SET_REC_POS      0x50000\n#define RME96_IO_RESET_REC_POS    0x5FFFC\n#define RME96_IO_GET_PLAY_POS     0x20000\n#define RME96_IO_GET_REC_POS      0x30000\n\n \n#define RME96_WCR_START     (1 << 0)\n#define RME96_WCR_START_2   (1 << 1)\n#define RME96_WCR_GAIN_0    (1 << 2)\n#define RME96_WCR_GAIN_1    (1 << 3)\n#define RME96_WCR_MODE24    (1 << 4)\n#define RME96_WCR_MODE24_2  (1 << 5)\n#define RME96_WCR_BM        (1 << 6)\n#define RME96_WCR_BM_2      (1 << 7)\n#define RME96_WCR_ADAT      (1 << 8)\n#define RME96_WCR_FREQ_0    (1 << 9)\n#define RME96_WCR_FREQ_1    (1 << 10)\n#define RME96_WCR_DS        (1 << 11)\n#define RME96_WCR_PRO       (1 << 12)\n#define RME96_WCR_EMP       (1 << 13)\n#define RME96_WCR_SEL       (1 << 14)\n#define RME96_WCR_MASTER    (1 << 15)\n#define RME96_WCR_PD        (1 << 16)\n#define RME96_WCR_INP_0     (1 << 17)\n#define RME96_WCR_INP_1     (1 << 18)\n#define RME96_WCR_THRU_0    (1 << 19)\n#define RME96_WCR_THRU_1    (1 << 20)\n#define RME96_WCR_THRU_2    (1 << 21)\n#define RME96_WCR_THRU_3    (1 << 22)\n#define RME96_WCR_THRU_4    (1 << 23)\n#define RME96_WCR_THRU_5    (1 << 24)\n#define RME96_WCR_THRU_6    (1 << 25)\n#define RME96_WCR_THRU_7    (1 << 26)\n#define RME96_WCR_DOLBY     (1 << 27)\n#define RME96_WCR_MONITOR_0 (1 << 28)\n#define RME96_WCR_MONITOR_1 (1 << 29)\n#define RME96_WCR_ISEL      (1 << 30)\n#define RME96_WCR_IDIS      (1 << 31)\n\n#define RME96_WCR_BITPOS_GAIN_0 2\n#define RME96_WCR_BITPOS_GAIN_1 3\n#define RME96_WCR_BITPOS_FREQ_0 9\n#define RME96_WCR_BITPOS_FREQ_1 10\n#define RME96_WCR_BITPOS_INP_0 17\n#define RME96_WCR_BITPOS_INP_1 18\n#define RME96_WCR_BITPOS_MONITOR_0 28\n#define RME96_WCR_BITPOS_MONITOR_1 29\n\n \n#define RME96_RCR_AUDIO_ADDR_MASK 0xFFFF\n#define RME96_RCR_IRQ_2     (1 << 16)\n#define RME96_RCR_T_OUT     (1 << 17)\n#define RME96_RCR_DEV_ID_0  (1 << 21)\n#define RME96_RCR_DEV_ID_1  (1 << 22)\n#define RME96_RCR_LOCK      (1 << 23)\n#define RME96_RCR_VERF      (1 << 26)\n#define RME96_RCR_F0        (1 << 27)\n#define RME96_RCR_F1        (1 << 28)\n#define RME96_RCR_F2        (1 << 29)\n#define RME96_RCR_AUTOSYNC  (1 << 30)\n#define RME96_RCR_IRQ       (1 << 31)\n\n#define RME96_RCR_BITPOS_F0 27\n#define RME96_RCR_BITPOS_F1 28\n#define RME96_RCR_BITPOS_F2 29\n\n \n#define RME96_AR_WSEL       (1 << 0)\n#define RME96_AR_ANALOG     (1 << 1)\n#define RME96_AR_FREQPAD_0  (1 << 2)\n#define RME96_AR_FREQPAD_1  (1 << 3)\n#define RME96_AR_FREQPAD_2  (1 << 4)\n#define RME96_AR_PD2        (1 << 5)\n#define RME96_AR_DAC_EN     (1 << 6)\n#define RME96_AR_CLATCH     (1 << 7)\n#define RME96_AR_CCLK       (1 << 8)\n#define RME96_AR_CDATA      (1 << 9)\n\n#define RME96_AR_BITPOS_F0 2\n#define RME96_AR_BITPOS_F1 3\n#define RME96_AR_BITPOS_F2 4\n\n \n#define RME96_MONITOR_TRACKS_1_2 0\n#define RME96_MONITOR_TRACKS_3_4 1\n#define RME96_MONITOR_TRACKS_5_6 2\n#define RME96_MONITOR_TRACKS_7_8 3\n\n \n#define RME96_ATTENUATION_0 0\n#define RME96_ATTENUATION_6 1\n#define RME96_ATTENUATION_12 2\n#define RME96_ATTENUATION_18 3\n\n \n#define RME96_INPUT_OPTICAL 0\n#define RME96_INPUT_COAXIAL 1\n#define RME96_INPUT_INTERNAL 2\n#define RME96_INPUT_XLR 3\n#define RME96_INPUT_ANALOG 4\n\n \n#define RME96_CLOCKMODE_SLAVE 0\n#define RME96_CLOCKMODE_MASTER 1\n#define RME96_CLOCKMODE_WORDCLOCK 2\n\n \n#define RME96_SMALL_BLOCK_SIZE 2048\n#define RME96_LARGE_BLOCK_SIZE 8192\n\n \n#define RME96_AD1852_VOL_BITS 14\n#define RME96_AD1855_VOL_BITS 10\n\n \n#define RME96_TB_START_PLAYBACK 1\n#define RME96_TB_START_CAPTURE 2\n#define RME96_TB_STOP_PLAYBACK 4\n#define RME96_TB_STOP_CAPTURE 8\n#define RME96_TB_RESET_PLAYPOS 16\n#define RME96_TB_RESET_CAPTUREPOS 32\n#define RME96_TB_CLEAR_PLAYBACK_IRQ 64\n#define RME96_TB_CLEAR_CAPTURE_IRQ 128\n#define RME96_RESUME_PLAYBACK\t(RME96_TB_START_PLAYBACK)\n#define RME96_RESUME_CAPTURE\t(RME96_TB_START_CAPTURE)\n#define RME96_RESUME_BOTH\t(RME96_RESUME_PLAYBACK \\\n\t\t\t\t| RME96_RESUME_CAPTURE)\n#define RME96_START_PLAYBACK\t(RME96_TB_START_PLAYBACK \\\n\t\t\t\t| RME96_TB_RESET_PLAYPOS)\n#define RME96_START_CAPTURE\t(RME96_TB_START_CAPTURE \\\n\t\t\t\t| RME96_TB_RESET_CAPTUREPOS)\n#define RME96_START_BOTH\t(RME96_START_PLAYBACK \\\n\t\t\t\t| RME96_START_CAPTURE)\n#define RME96_STOP_PLAYBACK\t(RME96_TB_STOP_PLAYBACK \\\n\t\t\t\t| RME96_TB_CLEAR_PLAYBACK_IRQ)\n#define RME96_STOP_CAPTURE\t(RME96_TB_STOP_CAPTURE \\\n\t\t\t\t| RME96_TB_CLEAR_CAPTURE_IRQ)\n#define RME96_STOP_BOTH\t\t(RME96_STOP_PLAYBACK \\\n\t\t\t\t| RME96_STOP_CAPTURE)\n\nstruct rme96 {\n\tspinlock_t    lock;\n\tint irq;\n\tunsigned long port;\n\tvoid __iomem *iobase;\n\t\n\tu32 wcreg;     \n\tu32 wcreg_spdif;\t\t \n\tu32 wcreg_spdif_stream;\t\t \n\tu32 rcreg;     \n\tu32 areg;      \n\tu16 vol[2];  \n\n\tu8 rev;  \n\n#ifdef CONFIG_PM_SLEEP\n\tu32 playback_pointer;\n\tu32 capture_pointer;\n\tvoid *playback_suspend_buffer;\n\tvoid *capture_suspend_buffer;\n#endif\n\n\tstruct snd_pcm_substream *playback_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\n\tint playback_frlog;  \n\tint capture_frlog;\n\t\n        size_t playback_periodsize;  \n\tsize_t capture_periodsize;  \n\n\tstruct snd_card *card;\n\tstruct snd_pcm *spdif_pcm;\n\tstruct snd_pcm *adat_pcm; \n\tstruct pci_dev     *pci;\n\tstruct snd_kcontrol   *spdif_ctl;\n};\n\nstatic const struct pci_device_id snd_rme96_ids[] = {\n\t{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96), 0, },\n\t{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8), 0, },\n\t{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO), 0, },\n\t{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST), 0, },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_rme96_ids);\n\n#define RME96_ISPLAYING(rme96) ((rme96)->wcreg & RME96_WCR_START)\n#define RME96_ISRECORDING(rme96) ((rme96)->wcreg & RME96_WCR_START_2)\n#define\tRME96_HAS_ANALOG_IN(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST)\n#define\tRME96_HAS_ANALOG_OUT(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PRO || \\\n\t\t\t\t     (rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST)\n#define\tRME96_DAC_IS_1852(rme96) (RME96_HAS_ANALOG_OUT(rme96) && (rme96)->rev >= 4)\n#define\tRME96_DAC_IS_1855(rme96) (((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST && (rme96)->rev < 4) || \\\n\t\t\t          ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PRO && (rme96)->rev == 2))\n#define\tRME96_185X_MAX_OUT(rme96) ((1 << (RME96_DAC_IS_1852(rme96) ? RME96_AD1852_VOL_BITS : RME96_AD1855_VOL_BITS)) - 1)\n\nstatic int\nsnd_rme96_playback_prepare(struct snd_pcm_substream *substream);\n\nstatic int\nsnd_rme96_capture_prepare(struct snd_pcm_substream *substream);\n\nstatic int\nsnd_rme96_playback_trigger(struct snd_pcm_substream *substream, \n\t\t\t   int cmd);\n\nstatic int\nsnd_rme96_capture_trigger(struct snd_pcm_substream *substream, \n\t\t\t  int cmd);\n\nstatic snd_pcm_uframes_t\nsnd_rme96_playback_pointer(struct snd_pcm_substream *substream);\n\nstatic snd_pcm_uframes_t\nsnd_rme96_capture_pointer(struct snd_pcm_substream *substream);\n\nstatic void snd_rme96_proc_init(struct rme96 *rme96);\n\nstatic int\nsnd_rme96_create_switches(struct snd_card *card,\n\t\t\t  struct rme96 *rme96);\n\nstatic int\nsnd_rme96_getinputtype(struct rme96 *rme96);\n\nstatic inline unsigned int\nsnd_rme96_playback_ptr(struct rme96 *rme96)\n{\n\treturn (readl(rme96->iobase + RME96_IO_GET_PLAY_POS)\n\t\t& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->playback_frlog;\n}\n\nstatic inline unsigned int\nsnd_rme96_capture_ptr(struct rme96 *rme96)\n{\n\treturn (readl(rme96->iobase + RME96_IO_GET_REC_POS)\n\t\t& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;\n}\n\nstatic int\nsnd_rme96_playback_silence(struct snd_pcm_substream *substream,\n\t\t\t   int channel, unsigned long pos, unsigned long count)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\n\tmemset_io(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,\n\t\t  0, count);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_playback_copy(struct snd_pcm_substream *substream,\n\t\t\tint channel, unsigned long pos,\n\t\t\tstruct iov_iter *src, unsigned long count)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\n\treturn copy_from_iter_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,\n\t\t\t\t   src, count);\n}\n\nstatic int\nsnd_rme96_capture_copy(struct snd_pcm_substream *substream,\n\t\t       int channel, unsigned long pos,\n\t\t       struct iov_iter *dst, unsigned long count)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\n\treturn copy_to_iter_fromio(dst,\n\t\t\t\t   rme96->iobase + RME96_IO_REC_BUFFER + pos,\n\t\t\t\t   count);\n}\n\n \nstatic const struct snd_pcm_hardware snd_rme96_playback_spdif_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_RESUME |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t     (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t      SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =\t     (SNDRV_PCM_RATE_32000 |\n\t\t\t      SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000 | \n\t\t\t      SNDRV_PCM_RATE_64000 |\n\t\t\t      SNDRV_PCM_RATE_88200 | \n\t\t\t      SNDRV_PCM_RATE_96000),\n\t.rate_min =\t     32000,\n\t.rate_max =\t     96000,\n\t.channels_min =\t     2,\n\t.channels_max =\t     2,\n\t.buffer_bytes_max =  RME96_BUFFER_SIZE,\n\t.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,\n\t.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,\n\t.periods_min =\t     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,\n\t.periods_max =\t     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,\n\t.fifo_size =\t     0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme96_capture_spdif_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_RESUME |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t     (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t      SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =\t     (SNDRV_PCM_RATE_32000 |\n\t\t\t      SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000 | \n\t\t\t      SNDRV_PCM_RATE_64000 |\n\t\t\t      SNDRV_PCM_RATE_88200 | \n\t\t\t      SNDRV_PCM_RATE_96000),\n\t.rate_min =\t     32000,\n\t.rate_max =\t     96000,\n\t.channels_min =\t     2,\n\t.channels_max =\t     2,\n\t.buffer_bytes_max =  RME96_BUFFER_SIZE,\n\t.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,\n\t.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,\n\t.periods_min =\t     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,\n\t.periods_max =\t     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,\n\t.fifo_size =\t     0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme96_playback_adat_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_RESUME |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t     (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t      SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =             (SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000),\n\t.rate_min =          44100,\n\t.rate_max =          48000,\n\t.channels_min =      8,\n\t.channels_max =\t     8,\n\t.buffer_bytes_max =  RME96_BUFFER_SIZE,\n\t.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,\n\t.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,\n\t.periods_min =\t     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,\n\t.periods_max =\t     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,\n\t.fifo_size =\t     0,\n};\n\n \nstatic const struct snd_pcm_hardware snd_rme96_capture_adat_info =\n{\n\t.info =\t\t     (SNDRV_PCM_INFO_MMAP_IOMEM |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_SYNC_START |\n\t\t\t      SNDRV_PCM_INFO_RESUME |\n\t\t\t      SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t     (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t      SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates =\t     (SNDRV_PCM_RATE_44100 | \n\t\t\t      SNDRV_PCM_RATE_48000),\n\t.rate_min =          44100,\n\t.rate_max =          48000,\n\t.channels_min =      8,\n\t.channels_max =\t     8,\n\t.buffer_bytes_max =  RME96_BUFFER_SIZE,\n\t.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,\n\t.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,\n\t.periods_min =\t     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,\n\t.periods_max =\t     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,\n\t.fifo_size =         0,\n};\n\n \nstatic void\nsnd_rme96_write_SPI(struct rme96 *rme96, u16 val)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (val & 0x8000) {\n\t\t\trme96->areg |= RME96_AR_CDATA;\n\t\t} else {\n\t\t\trme96->areg &= ~RME96_AR_CDATA;\n\t\t}\n\t\trme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CLATCH);\n\t\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t\tudelay(10);\n\t\trme96->areg |= RME96_AR_CCLK;\n\t\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t\tudelay(10);\n\t\tval <<= 1;\n\t}\n\trme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CDATA);\n\trme96->areg |= RME96_AR_CLATCH;\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\tudelay(10);\n\trme96->areg &= ~RME96_AR_CLATCH;\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n}\n\nstatic void\nsnd_rme96_apply_dac_volume(struct rme96 *rme96)\n{\n\tif (RME96_DAC_IS_1852(rme96)) {\n\t\tsnd_rme96_write_SPI(rme96, (rme96->vol[0] << 2) | 0x0);\n\t\tsnd_rme96_write_SPI(rme96, (rme96->vol[1] << 2) | 0x2);\n\t} else if (RME96_DAC_IS_1855(rme96)) {\n\t\tsnd_rme96_write_SPI(rme96, (rme96->vol[0] & 0x3FF) | 0x000);\n\t\tsnd_rme96_write_SPI(rme96, (rme96->vol[1] & 0x3FF) | 0x400);\n\t}\n}\n\nstatic void\nsnd_rme96_reset_dac(struct rme96 *rme96)\n{\n\twritel(rme96->wcreg | RME96_WCR_PD,\n\t       rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n}\n\nstatic int\nsnd_rme96_getmontracks(struct rme96 *rme96)\n{\n\treturn ((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_0) & 1) +\n\t\t(((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_1) & 1) << 1);\n}\n\nstatic int\nsnd_rme96_setmontracks(struct rme96 *rme96,\n\t\t       int montracks)\n{\n\tif (montracks & 1) {\n\t\trme96->wcreg |= RME96_WCR_MONITOR_0;\n\t} else {\n\t\trme96->wcreg &= ~RME96_WCR_MONITOR_0;\n\t}\n\tif (montracks & 2) {\n\t\trme96->wcreg |= RME96_WCR_MONITOR_1;\n\t} else {\n\t\trme96->wcreg &= ~RME96_WCR_MONITOR_1;\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_getattenuation(struct rme96 *rme96)\n{\n\treturn ((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_0) & 1) +\n\t\t(((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_1) & 1) << 1);\n}\n\nstatic int\nsnd_rme96_setattenuation(struct rme96 *rme96,\n\t\t\t int attenuation)\n{\n\tswitch (attenuation) {\n\tcase 0:\n\t\trme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) &\n\t\t\t~RME96_WCR_GAIN_1;\n\t\tbreak;\n\tcase 1:\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) &\n\t\t\t~RME96_WCR_GAIN_1;\n\t\tbreak;\n\tcase 2:\n\t\trme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) |\n\t\t\tRME96_WCR_GAIN_1;\n\t\tbreak;\n\tcase 3:\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) |\n\t\t\tRME96_WCR_GAIN_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_getrate(struct rme96 *rme96,\n\t\t\t  int *is_adat)\n{\t\n\tint n, rate;\n\n\t*is_adat = 0;\n\tif (rme96->areg & RME96_AR_ANALOG) {\n\t\t \n\t\tn = ((rme96->areg >> RME96_AR_BITPOS_F0) & 1) +\n\t\t\t(((rme96->areg >> RME96_AR_BITPOS_F1) & 1) << 1);\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\trate = 32000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trate = 44100;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trate = 48000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\treturn (rme96->areg & RME96_AR_BITPOS_F2) ? rate << 1 : rate;\n\t}\n\n\trme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\tif (rme96->rcreg & RME96_RCR_LOCK) {\n\t\t \n\t\t*is_adat = 1;\n\t\tif (rme96->rcreg & RME96_RCR_T_OUT) {\n\t\t\treturn 48000;\n\t\t}\n\t\treturn 44100;\n\t}\n\n\tif (rme96->rcreg & RME96_RCR_VERF) {\n\t\treturn -1;\n\t}\n\t\n\t \n\tn = ((rme96->rcreg >> RME96_RCR_BITPOS_F0) & 1) +\n\t\t(((rme96->rcreg >> RME96_RCR_BITPOS_F1) & 1) << 1) +\n\t\t(((rme96->rcreg >> RME96_RCR_BITPOS_F2) & 1) << 2);\n\t\n\tswitch (n) {\n\tcase 0:\t\t\n\t\tif (rme96->rcreg & RME96_RCR_T_OUT) {\n\t\t\treturn 64000;\n\t\t}\n\t\treturn -1;\n\tcase 3: return 96000;\n\tcase 4: return 88200;\n\tcase 5: return 48000;\n\tcase 6: return 44100;\n\tcase 7: return 32000;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\nstatic int\nsnd_rme96_playback_getrate(struct rme96 *rme96)\n{\n\tint rate, dummy;\n\n\tif (!(rme96->wcreg & RME96_WCR_MASTER) &&\n\t    snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG) {\n\t\trate = snd_rme96_capture_getrate(rme96, &dummy);\n\t\tif (rate > 0) {\n\t\t\t \n\t\t\treturn rate;\n\t\t}\n\t}\n\n\trate = ((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_0) & 1) +\n\t\t(((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_1) & 1) << 1);\n\tswitch (rate) {\n\tcase 1:\n\t\trate = 32000;\n\t\tbreak;\n\tcase 2:\n\t\trate = 44100;\n\t\tbreak;\n\tcase 3:\n\t\trate = 48000;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn (rme96->wcreg & RME96_WCR_DS) ? rate << 1 : rate;\n}\n\nstatic int\nsnd_rme96_playback_setrate(struct rme96 *rme96,\n\t\t\t   int rate)\n{\n\tint ds;\n\n\tds = rme96->wcreg & RME96_WCR_DS;\n\tswitch (rate) {\n\tcase 32000:\n\t\trme96->wcreg &= ~RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &\n\t\t\t~RME96_WCR_FREQ_1;\n\t\tbreak;\n\tcase 44100:\n\t\trme96->wcreg &= ~RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &\n\t\t\t~RME96_WCR_FREQ_0;\n\t\tbreak;\n\tcase 48000:\n\t\trme96->wcreg &= ~RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |\n\t\t\tRME96_WCR_FREQ_1;\n\t\tbreak;\n\tcase 64000:\n\t\trme96->wcreg |= RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &\n\t\t\t~RME96_WCR_FREQ_1;\n\t\tbreak;\n\tcase 88200:\n\t\trme96->wcreg |= RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &\n\t\t\t~RME96_WCR_FREQ_0;\n\t\tbreak;\n\tcase 96000:\n\t\trme96->wcreg |= RME96_WCR_DS;\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |\n\t\t\tRME96_WCR_FREQ_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif ((!ds && rme96->wcreg & RME96_WCR_DS) ||\n\t    (ds && !(rme96->wcreg & RME96_WCR_DS)))\n\t{\n\t\t \n\t\tsnd_rme96_reset_dac(rme96);\n\t\treturn 1;  \n\t} else {\n\t\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\t\treturn 0;\n\t}\n}\n\nstatic int\nsnd_rme96_capture_analog_setrate(struct rme96 *rme96,\n\t\t\t\t int rate)\n{\n\tswitch (rate) {\n\tcase 32000:\n\t\trme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &\n\t\t\t       ~RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tcase 44100:\n\t\trme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |\n\t\t\t       RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tcase 48000:\n\t\trme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |\n\t\t\t       RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tcase 64000:\n\t\tif (rme96->rev < 4) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &\n\t\t\t       ~RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tcase 88200:\n\t\tif (rme96->rev < 4) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |\n\t\t\t       RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tcase 96000:\n\t\trme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |\n\t\t\t       RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_setclockmode(struct rme96 *rme96,\n\t\t       int mode)\n{\n\tswitch (mode) {\n\tcase RME96_CLOCKMODE_SLAVE:\n\t          \n\t\trme96->wcreg &= ~RME96_WCR_MASTER;\n\t\trme96->areg &= ~RME96_AR_WSEL;\n\t\tbreak;\n\tcase RME96_CLOCKMODE_MASTER:\n\t         \n\t\trme96->wcreg |= RME96_WCR_MASTER;\n\t\trme96->areg &= ~RME96_AR_WSEL;\n\t\tbreak;\n\tcase RME96_CLOCKMODE_WORDCLOCK:\n\t\t \n\t\trme96->wcreg |= RME96_WCR_MASTER; \n\t\trme96->areg |= RME96_AR_WSEL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_getclockmode(struct rme96 *rme96)\n{\n\tif (rme96->areg & RME96_AR_WSEL) {\n\t\treturn RME96_CLOCKMODE_WORDCLOCK;\n\t}\n\treturn (rme96->wcreg & RME96_WCR_MASTER) ? RME96_CLOCKMODE_MASTER :\n\t\tRME96_CLOCKMODE_SLAVE;\n}\n\nstatic int\nsnd_rme96_setinputtype(struct rme96 *rme96,\n\t\t       int type)\n{\n\tint n;\n\n\tswitch (type) {\n\tcase RME96_INPUT_OPTICAL:\n\t\trme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) &\n\t\t\t~RME96_WCR_INP_1;\n\t\tbreak;\n\tcase RME96_INPUT_COAXIAL:\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) &\n\t\t\t~RME96_WCR_INP_1;\n\t\tbreak;\n\tcase RME96_INPUT_INTERNAL:\n\t\trme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) |\n\t\t\tRME96_WCR_INP_1;\n\t\tbreak;\n\tcase RME96_INPUT_XLR:\n\t\tif ((rme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&\n\t\t     rme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PRO) ||\n\t\t    (rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&\n\t\t     rme96->rev > 4))\n\t\t{\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\trme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) |\n\t\t\tRME96_WCR_INP_1;\n\t\tbreak;\n\tcase RME96_INPUT_ANALOG:\n\t\tif (!RME96_HAS_ANALOG_IN(rme96)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trme96->areg |= RME96_AR_ANALOG;\n\t\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t\tif (rme96->rev < 4) {\n\t\t\t \n\t\t\tif (snd_rme96_capture_getrate(rme96, &n) == 88200) {\n\t\t\t\tsnd_rme96_capture_analog_setrate(rme96, 44100);\n\t\t\t}\n\t\t\tif (snd_rme96_capture_getrate(rme96, &n) == 64000) {\n\t\t\t\tsnd_rme96_capture_analog_setrate(rme96, 32000);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (type != RME96_INPUT_ANALOG && RME96_HAS_ANALOG_IN(rme96)) {\n\t\trme96->areg &= ~RME96_AR_ANALOG;\n\t\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_getinputtype(struct rme96 *rme96)\n{\n\tif (rme96->areg & RME96_AR_ANALOG) {\n\t\treturn RME96_INPUT_ANALOG;\n\t}\n\treturn ((rme96->wcreg >> RME96_WCR_BITPOS_INP_0) & 1) +\n\t\t(((rme96->wcreg >> RME96_WCR_BITPOS_INP_1) & 1) << 1);\n}\n\nstatic void\nsnd_rme96_setframelog(struct rme96 *rme96,\n\t\t      int n_channels,\n\t\t      int is_playback)\n{\n\tint frlog;\n\t\n\tif (n_channels == 2) {\n\t\tfrlog = 1;\n\t} else {\n\t\t \n\t\tfrlog = 3;\n\t}\n\tif (is_playback) {\n\t\tfrlog += (rme96->wcreg & RME96_WCR_MODE24) ? 2 : 1;\n\t\trme96->playback_frlog = frlog;\n\t} else {\n\t\tfrlog += (rme96->wcreg & RME96_WCR_MODE24_2) ? 2 : 1;\n\t\trme96->capture_frlog = frlog;\n\t}\n}\n\nstatic int\nsnd_rme96_playback_setformat(struct rme96 *rme96, snd_pcm_format_t format)\n{\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trme96->wcreg &= ~RME96_WCR_MODE24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\trme96->wcreg |= RME96_WCR_MODE24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_setformat(struct rme96 *rme96, snd_pcm_format_t format)\n{\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trme96->wcreg &= ~RME96_WCR_MODE24_2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\trme96->wcreg |= RME96_WCR_MODE24_2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\treturn 0;\n}\n\nstatic void\nsnd_rme96_set_period_properties(struct rme96 *rme96,\n\t\t\t\tsize_t period_bytes)\n{\n\tswitch (period_bytes) {\n\tcase RME96_LARGE_BLOCK_SIZE:\n\t\trme96->wcreg &= ~RME96_WCR_ISEL;\n\t\tbreak;\n\tcase RME96_SMALL_BLOCK_SIZE:\n\t\trme96->wcreg |= RME96_WCR_ISEL;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\trme96->wcreg &= ~RME96_WCR_IDIS;\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n}\n\nstatic int\nsnd_rme96_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err, rate, dummy;\n\tbool apply_dac_volume = false;\n\n\truntime->dma_area = (void __force *)(rme96->iobase +\n\t\t\t\t\t     RME96_IO_PLAY_BUFFER);\n\truntime->dma_addr = rme96->port + RME96_IO_PLAY_BUFFER;\n\truntime->dma_bytes = RME96_BUFFER_SIZE;\n\n\tspin_lock_irq(&rme96->lock);\n\trate = 0;\n\tif (!(rme96->wcreg & RME96_WCR_MASTER) &&\n\t    snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG)\n\t\trate = snd_rme96_capture_getrate(rme96, &dummy);\n\tif (rate > 0) {\n                 \n                if ((int)params_rate(params) != rate) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\terr = snd_rme96_playback_setrate(rme96, params_rate(params));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tapply_dac_volume = err > 0;  \n\t}\n\n\terr = snd_rme96_playback_setformat(rme96, params_format(params));\n\tif (err < 0)\n\t\tgoto error;\n\tsnd_rme96_setframelog(rme96, params_channels(params), 1);\n\tif (rme96->capture_periodsize != 0) {\n\t\tif (params_period_size(params) << rme96->playback_frlog !=\n\t\t    rme96->capture_periodsize)\n\t\t{\n\t\t\terr = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t}\n\trme96->playback_periodsize =\n\t\tparams_period_size(params) << rme96->playback_frlog;\n\tsnd_rme96_set_period_properties(rme96, rme96->playback_periodsize);\n\t \n\tif ((rme96->wcreg & RME96_WCR_ADAT) == 0) {\n\t\trme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);\n\t\twritel(rme96->wcreg |= rme96->wcreg_spdif_stream, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\t}\n\n\terr = 0;\n error:\n\tspin_unlock_irq(&rme96->lock);\n\tif (apply_dac_volume) {\n\t\tusleep_range(3000, 10000);\n\t\tsnd_rme96_apply_dac_volume(rme96);\n\t}\n\n\treturn err;\n}\n\nstatic int\nsnd_rme96_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err, isadat, rate;\n\t\n\truntime->dma_area = (void __force *)(rme96->iobase +\n\t\t\t\t\t     RME96_IO_REC_BUFFER);\n\truntime->dma_addr = rme96->port + RME96_IO_REC_BUFFER;\n\truntime->dma_bytes = RME96_BUFFER_SIZE;\n\n\tspin_lock_irq(&rme96->lock);\n\terr = snd_rme96_capture_setformat(rme96, params_format(params));\n\tif (err < 0) {\n\t\tspin_unlock_irq(&rme96->lock);\n\t\treturn err;\n\t}\n\tif (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\n\t\terr = snd_rme96_capture_analog_setrate(rme96, params_rate(params));\n\t\tif (err < 0) {\n\t\t\tspin_unlock_irq(&rme96->lock);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\trate = snd_rme96_capture_getrate(rme96, &isadat);\n\t\tif (rate > 0) {\n\t\t\tif ((int)params_rate(params) != rate) {\n\t\t\t\tspin_unlock_irq(&rme96->lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif ((isadat && runtime->hw.channels_min == 2) ||\n\t\t\t    (!isadat && runtime->hw.channels_min == 8)) {\n\t\t\t\tspin_unlock_irq(&rme96->lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n        }\n\tsnd_rme96_setframelog(rme96, params_channels(params), 0);\n\tif (rme96->playback_periodsize != 0) {\n\t\tif (params_period_size(params) << rme96->capture_frlog !=\n\t\t    rme96->playback_periodsize)\n\t\t{\n\t\t\tspin_unlock_irq(&rme96->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\trme96->capture_periodsize =\n\t\tparams_period_size(params) << rme96->capture_frlog;\n\tsnd_rme96_set_period_properties(rme96, rme96->capture_periodsize);\n\tspin_unlock_irq(&rme96->lock);\n\n\treturn 0;\n}\n\nstatic void\nsnd_rme96_trigger(struct rme96 *rme96,\n\t\t  int op)\n{\n\tif (op & RME96_TB_RESET_PLAYPOS)\n\t\twritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\n\tif (op & RME96_TB_RESET_CAPTUREPOS)\n\t\twritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\n\tif (op & RME96_TB_CLEAR_PLAYBACK_IRQ) {\n\t\trme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\t\tif (rme96->rcreg & RME96_RCR_IRQ)\n\t\t\twritel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);\n\t}\n\tif (op & RME96_TB_CLEAR_CAPTURE_IRQ) {\n\t\trme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\t\tif (rme96->rcreg & RME96_RCR_IRQ_2)\n\t\t\twritel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);\n\t}\n\tif (op & RME96_TB_START_PLAYBACK)\n\t\trme96->wcreg |= RME96_WCR_START;\n\tif (op & RME96_TB_STOP_PLAYBACK)\n\t\trme96->wcreg &= ~RME96_WCR_START;\n\tif (op & RME96_TB_START_CAPTURE)\n\t\trme96->wcreg |= RME96_WCR_START_2;\n\tif (op & RME96_TB_STOP_CAPTURE)\n\t\trme96->wcreg &= ~RME96_WCR_START_2;\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n}\n\n\n\nstatic irqreturn_t\nsnd_rme96_interrupt(int irq,\n\t\t    void *dev_id)\n{\n\tstruct rme96 *rme96 = (struct rme96 *)dev_id;\n\n\trme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\t \n\tif (!((rme96->rcreg & RME96_RCR_IRQ) ||\n\t      (rme96->rcreg & RME96_RCR_IRQ_2)))\n\t{\n\t\treturn IRQ_NONE;\n\t}\n\t\n\tif (rme96->rcreg & RME96_RCR_IRQ) {\n\t\t \n                snd_pcm_period_elapsed(rme96->playback_substream);\n\t\twritel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);\n\t}\n\tif (rme96->rcreg & RME96_RCR_IRQ_2) {\n\t\t \n\t\tsnd_pcm_period_elapsed(rme96->capture_substream);\t\t\n\t\twritel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const unsigned int period_bytes[] = { RME96_SMALL_BLOCK_SIZE, RME96_LARGE_BLOCK_SIZE };\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {\n\t.count = ARRAY_SIZE(period_bytes),\n\t.list = period_bytes,\n\t.mask = 0\n};\n\nstatic void\nrme96_set_buffer_size_constraint(struct rme96 *rme96,\n\t\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tunsigned int size;\n\n\tsnd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t     RME96_BUFFER_SIZE);\n\tsize = rme96->playback_periodsize;\n\tif (!size)\n\t\tsize = rme96->capture_periodsize;\n\tif (size)\n\t\tsnd_pcm_hw_constraint_single(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t     size);\n\telse\n\t\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t   &hw_constraints_period_bytes);\n}\n\nstatic int\nsnd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)\n{\n        int rate, dummy;\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_set_sync(substream);\n\tspin_lock_irq(&rme96->lock);\t\n\tif (rme96->playback_substream) {\n\t\tspin_unlock_irq(&rme96->lock);\n                return -EBUSY;\n        }\n\trme96->wcreg &= ~RME96_WCR_ADAT;\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\trme96->playback_substream = substream;\n\tspin_unlock_irq(&rme96->lock);\n\n\truntime->hw = snd_rme96_playback_spdif_info;\n\tif (!(rme96->wcreg & RME96_WCR_MASTER) &&\n\t    snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG) {\n\t\trate = snd_rme96_capture_getrate(rme96, &dummy);\n\t\tif (rate > 0) {\n\t\t\t \n\t\t\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n\t\t\truntime->hw.rate_min = rate;\n\t\t\truntime->hw.rate_max = rate;\n\t\t}\n\t}        \n\trme96_set_buffer_size_constraint(rme96, runtime);\n\n\trme96->wcreg_spdif_stream = rme96->wcreg_spdif;\n\trme96->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)\n{\n        int isadat, rate;\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_set_sync(substream);\n\truntime->hw = snd_rme96_capture_spdif_info;\n\tif (snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG) {\n\t\trate = snd_rme96_capture_getrate(rme96, &isadat);\n\t\tif (rate > 0) {\n\t\t\tif (isadat)\n\t\t\t\treturn -EIO;\n\t\t\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n\t\t\truntime->hw.rate_min = rate;\n\t\t\truntime->hw.rate_max = rate;\n\t\t}\n\t}\n        \n\tspin_lock_irq(&rme96->lock);\n\tif (rme96->capture_substream) {\n\t\tspin_unlock_irq(&rme96->lock);\n                return -EBUSY;\n        }\n\trme96->capture_substream = substream;\n\tspin_unlock_irq(&rme96->lock);\n\t\n\trme96_set_buffer_size_constraint(rme96, runtime);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_playback_adat_open(struct snd_pcm_substream *substream)\n{\n        int rate, dummy;\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;        \n\t\n\tsnd_pcm_set_sync(substream);\n\tspin_lock_irq(&rme96->lock);\t\n\tif (rme96->playback_substream) {\n\t\tspin_unlock_irq(&rme96->lock);\n                return -EBUSY;\n        }\n\trme96->wcreg |= RME96_WCR_ADAT;\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\trme96->playback_substream = substream;\n\tspin_unlock_irq(&rme96->lock);\n\t\n\truntime->hw = snd_rme96_playback_adat_info;\n\tif (!(rme96->wcreg & RME96_WCR_MASTER) &&\n\t    snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG) {\n\t\trate = snd_rme96_capture_getrate(rme96, &dummy);\n\t\tif (rate > 0) {\n\t\t\t \n\t\t\truntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n\t\t\truntime->hw.rate_min = rate;\n\t\t\truntime->hw.rate_max = rate;\n\t\t}\n\t}\n\n\trme96_set_buffer_size_constraint(rme96, runtime);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_adat_open(struct snd_pcm_substream *substream)\n{\n        int isadat, rate;\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_pcm_set_sync(substream);\n\truntime->hw = snd_rme96_capture_adat_info;\n        if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\n                 \n                return -EIO;\n        }\n\trate = snd_rme96_capture_getrate(rme96, &isadat);\n\tif (rate > 0) {\n                if (!isadat) {\n                        return -EIO;\n                }\n                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\n                runtime->hw.rate_min = rate;\n                runtime->hw.rate_max = rate;\n        }\n        \n\tspin_lock_irq(&rme96->lock);\t\n\tif (rme96->capture_substream) {\n\t\tspin_unlock_irq(&rme96->lock);\n                return -EBUSY;\n        }\n\trme96->capture_substream = substream;\n\tspin_unlock_irq(&rme96->lock);\n\n\trme96_set_buffer_size_constraint(rme96, runtime);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tint spdif = 0;\n\n\tspin_lock_irq(&rme96->lock);\t\n\tif (RME96_ISPLAYING(rme96)) {\n\t\tsnd_rme96_trigger(rme96, RME96_STOP_PLAYBACK);\n\t}\n\trme96->playback_substream = NULL;\n\trme96->playback_periodsize = 0;\n\tspdif = (rme96->wcreg & RME96_WCR_ADAT) == 0;\n\tspin_unlock_irq(&rme96->lock);\n\tif (spdif) {\n\t\trme96->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);\n\t}\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\t\n\tspin_lock_irq(&rme96->lock);\t\n\tif (RME96_ISRECORDING(rme96)) {\n\t\tsnd_rme96_trigger(rme96, RME96_STOP_CAPTURE);\n\t}\n\trme96->capture_substream = NULL;\n\trme96->capture_periodsize = 0;\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\t\n\tspin_lock_irq(&rme96->lock);\t\n\tif (RME96_ISPLAYING(rme96)) {\n\t\tsnd_rme96_trigger(rme96, RME96_STOP_PLAYBACK);\n\t}\n\twritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\t\n\tspin_lock_irq(&rme96->lock);\t\n\tif (RME96_ISRECORDING(rme96)) {\n\t\tsnd_rme96_trigger(rme96, RME96_STOP_CAPTURE);\n\t}\n\twritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_playback_trigger(struct snd_pcm_substream *substream, \n\t\t\t   int cmd)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tbool sync;\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) == rme96)\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\n\tsync = (rme96->playback_substream && rme96->capture_substream) &&\n\t       (rme96->playback_substream->group ==\n\t\trme96->capture_substream->group);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (!RME96_ISPLAYING(rme96)) {\n\t\t\tif (substream != rme96->playback_substream)\n\t\t\t\treturn -EBUSY;\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_START_BOTH\n\t\t\t\t\t\t : RME96_START_PLAYBACK);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (RME96_ISPLAYING(rme96)) {\n\t\t\tif (substream != rme96->playback_substream)\n\t\t\t\treturn -EBUSY;\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH\n\t\t\t\t\t\t :  RME96_STOP_PLAYBACK);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (RME96_ISPLAYING(rme96))\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH\n\t\t\t\t\t\t : RME96_STOP_PLAYBACK);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (!RME96_ISPLAYING(rme96))\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH\n\t\t\t\t\t\t : RME96_RESUME_PLAYBACK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_capture_trigger(struct snd_pcm_substream *substream, \n\t\t\t  int cmd)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *s;\n\tbool sync;\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tif (snd_pcm_substream_chip(s) == rme96)\n\t\t\tsnd_pcm_trigger_done(s, substream);\n\t}\n\n\tsync = (rme96->playback_substream && rme96->capture_substream) &&\n\t       (rme96->playback_substream->group ==\n\t\trme96->capture_substream->group);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (!RME96_ISRECORDING(rme96)) {\n\t\t\tif (substream != rme96->capture_substream)\n\t\t\t\treturn -EBUSY;\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_START_BOTH\n\t\t\t\t\t\t : RME96_START_CAPTURE);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (RME96_ISRECORDING(rme96)) {\n\t\t\tif (substream != rme96->capture_substream)\n\t\t\t\treturn -EBUSY;\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH\n\t\t\t\t\t\t : RME96_STOP_CAPTURE);\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (RME96_ISRECORDING(rme96))\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH\n\t\t\t\t\t\t : RME96_STOP_CAPTURE);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (!RME96_ISRECORDING(rme96))\n\t\t\tsnd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH\n\t\t\t\t\t\t : RME96_RESUME_CAPTURE);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nsnd_rme96_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\treturn snd_rme96_playback_ptr(rme96);\n}\n\nstatic snd_pcm_uframes_t\nsnd_rme96_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\n\treturn snd_rme96_capture_ptr(rme96);\n}\n\nstatic const struct snd_pcm_ops snd_rme96_playback_spdif_ops = {\n\t.open =\t\tsnd_rme96_playback_spdif_open,\n\t.close =\tsnd_rme96_playback_close,\n\t.hw_params =\tsnd_rme96_playback_hw_params,\n\t.prepare =\tsnd_rme96_playback_prepare,\n\t.trigger =\tsnd_rme96_playback_trigger,\n\t.pointer =\tsnd_rme96_playback_pointer,\n\t.copy =\t\tsnd_rme96_playback_copy,\n\t.fill_silence =\tsnd_rme96_playback_silence,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme96_capture_spdif_ops = {\n\t.open =\t\tsnd_rme96_capture_spdif_open,\n\t.close =\tsnd_rme96_capture_close,\n\t.hw_params =\tsnd_rme96_capture_hw_params,\n\t.prepare =\tsnd_rme96_capture_prepare,\n\t.trigger =\tsnd_rme96_capture_trigger,\n\t.pointer =\tsnd_rme96_capture_pointer,\n\t.copy =\t\tsnd_rme96_capture_copy,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme96_playback_adat_ops = {\n\t.open =\t\tsnd_rme96_playback_adat_open,\n\t.close =\tsnd_rme96_playback_close,\n\t.hw_params =\tsnd_rme96_playback_hw_params,\n\t.prepare =\tsnd_rme96_playback_prepare,\n\t.trigger =\tsnd_rme96_playback_trigger,\n\t.pointer =\tsnd_rme96_playback_pointer,\n\t.copy =\t\tsnd_rme96_playback_copy,\n\t.fill_silence =\tsnd_rme96_playback_silence,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic const struct snd_pcm_ops snd_rme96_capture_adat_ops = {\n\t.open =\t\tsnd_rme96_capture_adat_open,\n\t.close =\tsnd_rme96_capture_close,\n\t.hw_params =\tsnd_rme96_capture_hw_params,\n\t.prepare =\tsnd_rme96_capture_prepare,\n\t.trigger =\tsnd_rme96_capture_trigger,\n\t.pointer =\tsnd_rme96_capture_pointer,\n\t.copy =\t\tsnd_rme96_capture_copy,\n\t.mmap =\t\tsnd_pcm_lib_mmap_iomem,\n};\n\nstatic void\nsnd_rme96_free(struct rme96 *rme96)\n{\n\tif (rme96->irq >= 0) {\n\t\tsnd_rme96_trigger(rme96, RME96_STOP_BOTH);\n\t\trme96->areg &= ~RME96_AR_DAC_EN;\n\t\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t}\n#ifdef CONFIG_PM_SLEEP\n\tvfree(rme96->playback_suspend_buffer);\n\tvfree(rme96->capture_suspend_buffer);\n#endif\n}\n\nstatic void\nsnd_rme96_free_spdif_pcm(struct snd_pcm *pcm)\n{\n\tstruct rme96 *rme96 = pcm->private_data;\n\trme96->spdif_pcm = NULL;\n}\n\nstatic void\nsnd_rme96_free_adat_pcm(struct snd_pcm *pcm)\n{\n\tstruct rme96 *rme96 = pcm->private_data;\n\trme96->adat_pcm = NULL;\n}\n\nstatic int\nsnd_rme96_create(struct rme96 *rme96)\n{\n\tstruct pci_dev *pci = rme96->pci;\n\tint err;\n\n\trme96->irq = -1;\n\tspin_lock_init(&rme96->lock);\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_request_regions(pci, \"RME96\");\n\tif (err < 0)\n\t\treturn err;\n\trme96->port = pci_resource_start(rme96->pci, 0);\n\n\trme96->iobase = devm_ioremap(&pci->dev, rme96->port, RME96_IO_SIZE);\n\tif (!rme96->iobase) {\n\t\tdev_err(rme96->card->dev,\n\t\t\t\"unable to remap memory region 0x%lx-0x%lx\\n\",\n\t\t\trme96->port, rme96->port + RME96_IO_SIZE - 1);\n\t\treturn -EBUSY;\n\t}\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_rme96_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, rme96)) {\n\t\tdev_err(rme96->card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\trme96->irq = pci->irq;\n\trme96->card->sync_irq = rme96->irq;\n\n\t \n\tpci_read_config_byte(pci, 8, &rme96->rev);\t\n\t\n\t \n\terr = snd_pcm_new(rme96->card, \"Digi96 IEC958\", 0,\n\t\t\t  1, 1, &rme96->spdif_pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\trme96->spdif_pcm->private_data = rme96;\n\trme96->spdif_pcm->private_free = snd_rme96_free_spdif_pcm;\n\tstrcpy(rme96->spdif_pcm->name, \"Digi96 IEC958\");\n\tsnd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_spdif_ops);\n\tsnd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_spdif_ops);\n\n\trme96->spdif_pcm->info_flags = 0;\n\n\t \n\tif (pci->device == PCI_DEVICE_ID_RME_DIGI96) {\n\t\t \n\t\trme96->adat_pcm = NULL;\n\t} else {\n\t\terr = snd_pcm_new(rme96->card, \"Digi96 ADAT\", 1,\n\t\t\t\t  1, 1, &rme96->adat_pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\trme96->adat_pcm->private_data = rme96;\n\t\trme96->adat_pcm->private_free = snd_rme96_free_adat_pcm;\n\t\tstrcpy(rme96->adat_pcm->name, \"Digi96 ADAT\");\n\t\tsnd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_adat_ops);\n\t\tsnd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_adat_ops);\n\t\t\n\t\trme96->adat_pcm->info_flags = 0;\n\t}\n\n\trme96->playback_periodsize = 0;\n\trme96->capture_periodsize = 0;\n\t\n\t \n\tsnd_rme96_trigger(rme96, RME96_STOP_BOTH);\n\t\n\t \n\trme96->wcreg =\n\t\tRME96_WCR_FREQ_1 |  \n\t\tRME96_WCR_SEL |     \n\t\tRME96_WCR_MASTER |  \n\t\tRME96_WCR_INP_0;    \n\n\trme96->areg = RME96_AR_FREQPAD_1;  \n\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\t\n\t \n\twritel(rme96->areg | RME96_AR_PD2,\n\t       rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\t\n\n\t \n\tsnd_rme96_reset_dac(rme96);\n\trme96->areg |= RME96_AR_DAC_EN;\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\n\t \n\twritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\n\twritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\n\n\t \n\trme96->vol[0] = rme96->vol[1] = 0;\n\tif (RME96_HAS_ANALOG_OUT(rme96)) {\n\t\tsnd_rme96_apply_dac_volume(rme96);\n\t}\n\t\n\t \n\terr = snd_rme96_create_switches(rme96->card, rme96);\n\tif (err < 0)\n\t\treturn err;\n\n         \n\tsnd_rme96_proc_init(rme96);\n\t\n\treturn 0;\n}\n\n \n\nstatic void \nsnd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tint n;\n\tstruct rme96 *rme96 = entry->private_data;\n\t\n\trme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\n\tsnd_iprintf(buffer, rme96->card->longname);\n\tsnd_iprintf(buffer, \" (index #%d)\\n\", rme96->card->number + 1);\n\n\tsnd_iprintf(buffer, \"\\nGeneral settings\\n\");\n\tif (rme96->wcreg & RME96_WCR_IDIS) {\n\t\tsnd_iprintf(buffer, \"  period size: N/A (interrupts \"\n\t\t\t    \"disabled)\\n\");\n\t} else if (rme96->wcreg & RME96_WCR_ISEL) {\n\t\tsnd_iprintf(buffer, \"  period size: 2048 bytes\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  period size: 8192 bytes\\n\");\n\t}\t\n\tsnd_iprintf(buffer, \"\\nInput settings\\n\");\n\tswitch (snd_rme96_getinputtype(rme96)) {\n\tcase RME96_INPUT_OPTICAL:\n\t\tsnd_iprintf(buffer, \"  input: optical\");\n\t\tbreak;\n\tcase RME96_INPUT_COAXIAL:\n\t\tsnd_iprintf(buffer, \"  input: coaxial\");\n\t\tbreak;\n\tcase RME96_INPUT_INTERNAL:\n\t\tsnd_iprintf(buffer, \"  input: internal\");\n\t\tbreak;\n\tcase RME96_INPUT_XLR:\n\t\tsnd_iprintf(buffer, \"  input: XLR\");\n\t\tbreak;\n\tcase RME96_INPUT_ANALOG:\n\t\tsnd_iprintf(buffer, \"  input: analog\");\n\t\tbreak;\n\t}\n\tif (snd_rme96_capture_getrate(rme96, &n) < 0) {\n\t\tsnd_iprintf(buffer, \"\\n  sample rate: no valid signal\\n\");\n\t} else {\n\t\tif (n) {\n\t\t\tsnd_iprintf(buffer, \" (8 channels)\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \" (2 channels)\\n\");\n\t\t}\n\t\tsnd_iprintf(buffer, \"  sample rate: %d Hz\\n\",\n\t\t\t    snd_rme96_capture_getrate(rme96, &n));\n\t}\n\tif (rme96->wcreg & RME96_WCR_MODE24_2) {\n\t\tsnd_iprintf(buffer, \"  sample format: 24 bit\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  sample format: 16 bit\\n\");\n\t}\n\t\n\tsnd_iprintf(buffer, \"\\nOutput settings\\n\");\n\tif (rme96->wcreg & RME96_WCR_SEL) {\n\t\tsnd_iprintf(buffer, \"  output signal: normal playback\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  output signal: same as input\\n\");\n\t}\n\tsnd_iprintf(buffer, \"  sample rate: %d Hz\\n\",\n\t\t    snd_rme96_playback_getrate(rme96));\n\tif (rme96->wcreg & RME96_WCR_MODE24) {\n\t\tsnd_iprintf(buffer, \"  sample format: 24 bit\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  sample format: 16 bit\\n\");\n\t}\n\tif (rme96->areg & RME96_AR_WSEL) {\n\t\tsnd_iprintf(buffer, \"  sample clock source: word clock\\n\");\n\t} else if (rme96->wcreg & RME96_WCR_MASTER) {\n\t\tsnd_iprintf(buffer, \"  sample clock source: internal\\n\");\n\t} else if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\n\t\tsnd_iprintf(buffer, \"  sample clock source: autosync (internal anyway due to analog input setting)\\n\");\n\t} else if (snd_rme96_capture_getrate(rme96, &n) < 0) {\n\t\tsnd_iprintf(buffer, \"  sample clock source: autosync (internal anyway due to no valid signal)\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  sample clock source: autosync\\n\");\n\t}\n\tif (rme96->wcreg & RME96_WCR_PRO) {\n\t\tsnd_iprintf(buffer, \"  format: AES/EBU (professional)\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  format: IEC958 (consumer)\\n\");\n\t}\n\tif (rme96->wcreg & RME96_WCR_EMP) {\n\t\tsnd_iprintf(buffer, \"  emphasis: on\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  emphasis: off\\n\");\n\t}\n\tif (rme96->wcreg & RME96_WCR_DOLBY) {\n\t\tsnd_iprintf(buffer, \"  non-audio (dolby): on\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"  non-audio (dolby): off\\n\");\n\t}\n\tif (RME96_HAS_ANALOG_IN(rme96)) {\n\t\tsnd_iprintf(buffer, \"\\nAnalog output settings\\n\");\n\t\tswitch (snd_rme96_getmontracks(rme96)) {\n\t\tcase RME96_MONITOR_TRACKS_1_2:\n\t\t\tsnd_iprintf(buffer, \"  monitored ADAT tracks: 1+2\\n\");\n\t\t\tbreak;\n\t\tcase RME96_MONITOR_TRACKS_3_4:\n\t\t\tsnd_iprintf(buffer, \"  monitored ADAT tracks: 3+4\\n\");\n\t\t\tbreak;\n\t\tcase RME96_MONITOR_TRACKS_5_6:\n\t\t\tsnd_iprintf(buffer, \"  monitored ADAT tracks: 5+6\\n\");\n\t\t\tbreak;\n\t\tcase RME96_MONITOR_TRACKS_7_8:\n\t\t\tsnd_iprintf(buffer, \"  monitored ADAT tracks: 7+8\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (snd_rme96_getattenuation(rme96)) {\n\t\tcase RME96_ATTENUATION_0:\n\t\t\tsnd_iprintf(buffer, \"  attenuation: 0 dB\\n\");\n\t\t\tbreak;\n\t\tcase RME96_ATTENUATION_6:\n\t\t\tsnd_iprintf(buffer, \"  attenuation: -6 dB\\n\");\n\t\t\tbreak;\n\t\tcase RME96_ATTENUATION_12:\n\t\t\tsnd_iprintf(buffer, \"  attenuation: -12 dB\\n\");\n\t\t\tbreak;\n\t\tcase RME96_ATTENUATION_18:\n\t\t\tsnd_iprintf(buffer, \"  attenuation: -18 dB\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tsnd_iprintf(buffer, \"  volume left: %u\\n\", rme96->vol[0]);\n\t\tsnd_iprintf(buffer, \"  volume right: %u\\n\", rme96->vol[1]);\n\t}\n}\n\nstatic void snd_rme96_proc_init(struct rme96 *rme96)\n{\n\tsnd_card_ro_proc_new(rme96->card, \"rme96\", rme96, snd_rme96_proc_read);\n}\n\n \n\n#define snd_rme96_info_loopback_control\t\tsnd_ctl_boolean_mono_info\n\nstatic int\nsnd_rme96_get_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme96->lock);\n\tucontrol->value.integer.value[0] = rme96->wcreg & RME96_WCR_SEL ? 0 : 1;\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme96_put_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\t\n\tval = ucontrol->value.integer.value[0] ? 0 : RME96_WCR_SEL;\n\tspin_lock_irq(&rme96->lock);\n\tval = (rme96->wcreg & ~RME96_WCR_SEL) | val;\n\tchange = val != rme96->wcreg;\n\trme96->wcreg = val;\n\twritel(val, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme96_info_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const _texts[5] = {\n\t\t\"Optical\", \"Coaxial\", \"Internal\", \"XLR\", \"Analog\"\n\t};\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tconst char *texts[5] = {\n\t\t_texts[0], _texts[1], _texts[2], _texts[3], _texts[4]\n\t};\n\tint num_items;\n\t\n\tswitch (rme96->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI96:\n\tcase PCI_DEVICE_ID_RME_DIGI96_8:\n\t\tnum_items = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\n\t\tnum_items = 4;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\n\t\tif (rme96->rev > 4) {\n\t\t\t \n\t\t\tnum_items = 4;\n\t\t\ttexts[3] = _texts[4];  \n\t\t} else {\n\t\t\t \n\t\t\tnum_items = 5;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\treturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\n}\nstatic int\nsnd_rme96_get_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int items = 3;\n\t\n\tspin_lock_irq(&rme96->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme96_getinputtype(rme96);\n\t\n\tswitch (rme96->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI96:\n\tcase PCI_DEVICE_ID_RME_DIGI96_8:\n\t\titems = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\n\t\titems = 4;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\n\t\tif (rme96->rev > 4) {\n\t\t\t \n\t\t\tif (ucontrol->value.enumerated.item[0] == RME96_INPUT_ANALOG) {\n\t\t\t\tucontrol->value.enumerated.item[0] = RME96_INPUT_XLR;\n\t\t\t}\n\t\t\titems = 4;\n\t\t} else {\n\t\t\titems = 5;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\tif (ucontrol->value.enumerated.item[0] >= items) {\n\t\tucontrol->value.enumerated.item[0] = items - 1;\n\t}\n\t\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme96_put_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change, items = 3;\n\t\n\tswitch (rme96->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI96:\n\tcase PCI_DEVICE_ID_RME_DIGI96_8:\n\t\titems = 3;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\n\t\titems = 4;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\n\t\tif (rme96->rev > 4) {\n\t\t\titems = 4;\n\t\t} else {\n\t\t\titems = 5;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\tval = ucontrol->value.enumerated.item[0] % items;\n\t\n\t \n\tif (rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST && rme96->rev > 4) {\n\t\tif (val == RME96_INPUT_XLR) {\n\t\t\tval = RME96_INPUT_ANALOG;\n\t\t}\n\t}\n\t\n\tspin_lock_irq(&rme96->lock);\n\tchange = (int)val != snd_rme96_getinputtype(rme96);\n\tsnd_rme96_setinputtype(rme96, val);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme96_info_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = { \"AutoSync\", \"Internal\", \"Word\" };\n\t\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\nstatic int\nsnd_rme96_get_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme96->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme96_getclockmode(rme96);\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme96_put_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\t\n\tval = ucontrol->value.enumerated.item[0] % 3;\n\tspin_lock_irq(&rme96->lock);\n\tchange = (int)val != snd_rme96_getclockmode(rme96);\n\tsnd_rme96_setclockmode(rme96, val);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme96_info_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"0 dB\", \"-6 dB\", \"-12 dB\", \"-18 dB\"\n\t};\n\t\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\nstatic int\nsnd_rme96_get_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme96->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme96_getattenuation(rme96);\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme96_put_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\t\n\tval = ucontrol->value.enumerated.item[0] % 4;\n\tspin_lock_irq(&rme96->lock);\n\n\tchange = (int)val != snd_rme96_getattenuation(rme96);\n\tsnd_rme96_setattenuation(rme96, val);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int\nsnd_rme96_info_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = { \"1+2\", \"3+4\", \"5+6\", \"7+8\" };\n\t\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\nstatic int\nsnd_rme96_get_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme96->lock);\n\tucontrol->value.enumerated.item[0] = snd_rme96_getmontracks(rme96);\n\tspin_unlock_irq(&rme96->lock);\n\treturn 0;\n}\nstatic int\nsnd_rme96_put_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\t\n\tval = ucontrol->value.enumerated.item[0] % 4;\n\tspin_lock_irq(&rme96->lock);\n\tchange = (int)val != snd_rme96_getmontracks(rme96);\n\tsnd_rme96_setmontracks(rme96, val);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic u32 snd_rme96_convert_from_aes(struct snd_aes_iec958 *aes)\n{\n\tu32 val = 0;\n\tval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME96_WCR_PRO : 0;\n\tval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME96_WCR_DOLBY : 0;\n\tif (val & RME96_WCR_PRO)\n\t\tval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME96_WCR_EMP : 0;\n\telse\n\t\tval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME96_WCR_EMP : 0;\n\treturn val;\n}\n\nstatic void snd_rme96_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\n{\n\taes->status[0] = ((val & RME96_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |\n\t\t\t ((val & RME96_WCR_DOLBY) ? IEC958_AES0_NONAUDIO : 0);\n\tif (val & RME96_WCR_PRO)\n\t\taes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\n\telse\n\t\taes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\n}\n\nstatic int snd_rme96_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme96_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif);\n\treturn 0;\n}\n\nstatic int snd_rme96_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\t\n\tval = snd_rme96_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme96->lock);\n\tchange = val != rme96->wcreg_spdif;\n\trme96->wcreg_spdif = val;\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int snd_rme96_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme96_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif_stream);\n\treturn 0;\n}\n\nstatic int snd_rme96_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\t\n\tval = snd_rme96_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme96->lock);\n\tchange = val != rme96->wcreg_spdif_stream;\n\trme96->wcreg_spdif_stream = val;\n\trme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);\n\trme96->wcreg |= val;\n\twritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\n\tspin_unlock_irq(&rme96->lock);\n\treturn change;\n}\n\nstatic int snd_rme96_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme96_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = kcontrol->private_value;\n\treturn 0;\n}\n\nstatic int\nsnd_rme96_dac_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\t\n        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n        uinfo->count = 2;\n        uinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = RME96_185X_MAX_OUT(rme96);\n        return 0;\n}\n\nstatic int\nsnd_rme96_dac_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&rme96->lock);\n        u->value.integer.value[0] = rme96->vol[0];\n        u->value.integer.value[1] = rme96->vol[1];\n\tspin_unlock_irq(&rme96->lock);\n\n        return 0;\n}\n\nstatic int\nsnd_rme96_dac_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)\n{\n\tstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\n        int change = 0;\n\tunsigned int vol, maxvol;\n\n\n\tif (!RME96_HAS_ANALOG_OUT(rme96))\n\t\treturn -EINVAL;\n\tmaxvol = RME96_185X_MAX_OUT(rme96);\n\tspin_lock_irq(&rme96->lock);\n\tvol = u->value.integer.value[0];\n\tif (vol != rme96->vol[0] && vol <= maxvol) {\n\t\trme96->vol[0] = vol;\n\t\tchange = 1;\n\t}\n\tvol = u->value.integer.value[1];\n\tif (vol != rme96->vol[1] && vol <= maxvol) {\n\t\trme96->vol[1] = vol;\n\t\tchange = 1;\n\t}\n\tif (change)\n\t\tsnd_rme96_apply_dac_volume(rme96);\n\tspin_unlock_irq(&rme96->lock);\n\n        return change;\n}\n\nstatic const struct snd_kcontrol_new snd_rme96_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_rme96_control_spdif_info,\n\t.get =\t\tsnd_rme96_control_spdif_get,\n\t.put =\t\tsnd_rme96_control_spdif_put\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_rme96_control_spdif_stream_info,\n\t.get =\t\tsnd_rme96_control_spdif_stream_get,\n\t.put =\t\tsnd_rme96_control_spdif_stream_put\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tsnd_rme96_control_spdif_mask_info,\n\t.get =\t\tsnd_rme96_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n\t\t\tIEC958_AES0_PROFESSIONAL |\n\t\t\tIEC958_AES0_CON_EMPHASIS\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PRO_MASK),\n\t.info =\t\tsnd_rme96_control_spdif_mask_info,\n\t.get =\t\tsnd_rme96_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n\t\t\tIEC958_AES0_PROFESSIONAL |\n\t\t\tIEC958_AES0_PRO_EMPHASIS\n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Input Connector\",\n\t.info =         snd_rme96_info_inputtype_control, \n\t.get =          snd_rme96_get_inputtype_control,\n\t.put =          snd_rme96_put_inputtype_control \n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Loopback Input\",\n\t.info =         snd_rme96_info_loopback_control,\n\t.get =          snd_rme96_get_loopback_control,\n\t.put =          snd_rme96_put_loopback_control\n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Sample Clock Source\",\n\t.info =         snd_rme96_info_clockmode_control, \n\t.get =          snd_rme96_get_clockmode_control,\n\t.put =          snd_rme96_put_clockmode_control\n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Monitor Tracks\",\n\t.info =         snd_rme96_info_montracks_control, \n\t.get =          snd_rme96_get_montracks_control,\n\t.put =          snd_rme96_put_montracks_control\n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Attenuation\",\n\t.info =         snd_rme96_info_attenuation_control, \n\t.get =          snd_rme96_get_attenuation_control,\n\t.put =          snd_rme96_put_attenuation_control\n},\n{\n        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"DAC Playback Volume\",\n\t.info =         snd_rme96_dac_volume_info,\n\t.get =          snd_rme96_dac_volume_get,\n\t.put =          snd_rme96_dac_volume_put\n}\n};\n\nstatic int\nsnd_rme96_create_switches(struct snd_card *card,\n\t\t\t  struct rme96 *rme96)\n{\n\tint idx, err;\n\tstruct snd_kcontrol *kctl;\n\n\tfor (idx = 0; idx < 7; idx++) {\n\t\tkctl = snd_ctl_new1(&snd_rme96_controls[idx], rme96);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (idx == 1)\t \n\t\t\trme96->spdif_ctl = kctl;\n\t}\n\n\tif (RME96_HAS_ANALOG_OUT(rme96)) {\n\t\tfor (idx = 7; idx < 10; idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_rme96_controls[idx], rme96));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int rme96_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct rme96 *rme96 = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n\t \n\trme96->playback_pointer = readl(rme96->iobase + RME96_IO_GET_PLAY_POS)\n\t\t\t\t  & RME96_RCR_AUDIO_ADDR_MASK;\n\trme96->capture_pointer = readl(rme96->iobase + RME96_IO_GET_REC_POS)\n\t\t\t\t & RME96_RCR_AUDIO_ADDR_MASK;\n\n\t \n\tmemcpy_fromio(rme96->playback_suspend_buffer,\n\t\t      rme96->iobase + RME96_IO_PLAY_BUFFER, RME96_BUFFER_SIZE);\n\tmemcpy_fromio(rme96->capture_suspend_buffer,\n\t\t      rme96->iobase + RME96_IO_REC_BUFFER, RME96_BUFFER_SIZE);\n\n\t \n\trme96->areg &= ~RME96_AR_DAC_EN;\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\treturn 0;\n}\n\nstatic int rme96_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct rme96 *rme96 = card->private_data;\n\n\t \n\twritel(0, rme96->iobase + RME96_IO_SET_PLAY_POS\n\t\t  + rme96->playback_pointer);\n\twritel(0, rme96->iobase + RME96_IO_SET_REC_POS\n\t\t  + rme96->capture_pointer);\n\n\t \n\tmemcpy_toio(rme96->iobase + RME96_IO_PLAY_BUFFER,\n\t\t    rme96->playback_suspend_buffer, RME96_BUFFER_SIZE);\n\tmemcpy_toio(rme96->iobase + RME96_IO_REC_BUFFER,\n\t\t    rme96->capture_suspend_buffer, RME96_BUFFER_SIZE);\n\n\t \n\twritel(rme96->areg | RME96_AR_PD2,\n\t       rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\n\t \n\tsnd_rme96_reset_dac(rme96);\n\trme96->areg |= RME96_AR_DAC_EN;\n\twritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\n\tif (RME96_HAS_ANALOG_OUT(rme96)) {\n\t\tusleep_range(3000, 10000);\n\t\tsnd_rme96_apply_dac_volume(rme96);\n\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rme96_pm, rme96_suspend, rme96_resume);\n#define RME96_PM_OPS\t&rme96_pm\n#else\n#define RME96_PM_OPS\tNULL\n#endif  \n\nstatic void snd_rme96_card_free(struct snd_card *card)\n{\n\tsnd_rme96_free(card->private_data);\n}\n\nstatic int\n__snd_rme96_probe(struct pci_dev *pci,\n\t\t  const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct rme96 *rme96;\n\tstruct snd_card *card;\n\tint err;\n\tu8 val;\n\n\tif (dev >= SNDRV_CARDS) {\n\t\treturn -ENODEV;\n\t}\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*rme96), &card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = snd_rme96_card_free;\n\trme96 = card->private_data;\n\trme96->card = card;\n\trme96->pci = pci;\n\terr = snd_rme96_create(rme96);\n\tif (err)\n\t\treturn err;\n\t\n#ifdef CONFIG_PM_SLEEP\n\trme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);\n\tif (!rme96->playback_suspend_buffer)\n\t\treturn -ENOMEM;\n\trme96->capture_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);\n\tif (!rme96->capture_suspend_buffer)\n\t\treturn -ENOMEM;\n#endif\n\n\tstrcpy(card->driver, \"Digi96\");\n\tswitch (rme96->pci->device) {\n\tcase PCI_DEVICE_ID_RME_DIGI96:\n\t\tstrcpy(card->shortname, \"RME Digi96\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8:\n\t\tstrcpy(card->shortname, \"RME Digi96/8\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\n\t\tstrcpy(card->shortname, \"RME Digi96/8 PRO\");\n\t\tbreak;\n\tcase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\n\t\tpci_read_config_byte(rme96->pci, 8, &val);\n\t\tif (val < 5) {\n\t\t\tstrcpy(card->shortname, \"RME Digi96/8 PAD\");\n\t\t} else {\n\t\t\tstrcpy(card->shortname, \"RME Digi96/8 PST\");\n\t\t}\n\t\tbreak;\n\t}\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\", card->shortname,\n\t\trme96->port, rme96->irq);\n\terr = snd_card_register(card);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_rme96_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_rme96_probe(pci, pci_id));\n}\n\nstatic struct pci_driver rme96_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_rme96_ids,\n\t.probe = snd_rme96_probe,\n\t.driver = {\n\t\t.pm = RME96_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(rme96_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}