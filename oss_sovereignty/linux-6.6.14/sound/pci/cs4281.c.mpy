{
  "module_name": "cs4281.c",
  "hash_id": "83fd4094f279d3c4ecf70724e35b4863e1465b80e805d6e70ae9f9f70c9ba02f",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs4281.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/ac97_codec.h>\n#include <sound/tlv.h>\n#include <sound/opl3.h>\n#include <sound/initval.h>\n\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS4281\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic bool dual_codec[SNDRV_CARDS];\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for CS4281 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for CS4281 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable CS4281 soundcard.\");\nmodule_param_array(dual_codec, bool, NULL, 0444);\nMODULE_PARM_DESC(dual_codec, \"Secondary Codec ID (0 = disabled).\");\n\n \n\n#define CS4281_BA0_SIZE\t\t0x1000\n#define CS4281_BA1_SIZE\t\t0x10000\n\n \n#define BA0_HISR\t\t0x0000\t \n#define BA0_HISR_INTENA\t\t(1<<31)\t \n#define BA0_HISR_MIDI\t\t(1<<22)\t \n#define BA0_HISR_FIFOI\t\t(1<<20)\t \n#define BA0_HISR_DMAI\t\t(1<<18)\t \n#define BA0_HISR_FIFO(c)\t(1<<(12+(c)))  \n#define BA0_HISR_DMA(c)\t\t(1<<(8+(c)))   \n#define BA0_HISR_GPPI\t\t(1<<5)\t \n#define BA0_HISR_GPSI\t\t(1<<4)\t \n#define BA0_HISR_GP3I\t\t(1<<3)\t \n#define BA0_HISR_GP1I\t\t(1<<2)\t \n#define BA0_HISR_VUPI\t\t(1<<1)\t \n#define BA0_HISR_VDNI\t\t(1<<0)\t \n\n#define BA0_HICR\t\t0x0008\t \n#define BA0_HICR_CHGM\t\t(1<<1)\t \n#define BA0_HICR_IEV\t\t(1<<0)\t \n#define BA0_HICR_EOI\t\t(3<<0)\t \n\n#define BA0_HIMR\t\t0x000c\t \n\t\t\t\t\t \n\n#define BA0_IIER\t\t0x0010\t \n\n#define BA0_HDSR0\t\t0x00f0\t \n#define BA0_HDSR1\t\t0x00f4\t \n#define BA0_HDSR2\t\t0x00f8\t \n#define BA0_HDSR3\t\t0x00fc\t \n\n#define BA0_HDSR_CH1P\t\t(1<<25)\t \n#define BA0_HDSR_CH2P\t\t(1<<24)\t \n#define BA0_HDSR_DHTC\t\t(1<<17)\t \n#define BA0_HDSR_DTC\t\t(1<<16)\t \n#define BA0_HDSR_DRUN\t\t(1<<15)\t \n#define BA0_HDSR_RQ\t\t(1<<7)\t \n\n#define BA0_DCA0\t\t0x0110\t \n#define BA0_DCC0\t\t0x0114\t \n#define BA0_DBA0\t\t0x0118\t \n#define BA0_DBC0\t\t0x011c\t \n#define BA0_DCA1\t\t0x0120\t \n#define BA0_DCC1\t\t0x0124\t \n#define BA0_DBA1\t\t0x0128\t \n#define BA0_DBC1\t\t0x012c\t \n#define BA0_DCA2\t\t0x0130\t \n#define BA0_DCC2\t\t0x0134\t \n#define BA0_DBA2\t\t0x0138\t \n#define BA0_DBC2\t\t0x013c\t \n#define BA0_DCA3\t\t0x0140\t \n#define BA0_DCC3\t\t0x0144\t \n#define BA0_DBA3\t\t0x0148\t \n#define BA0_DBC3\t\t0x014c\t \n#define BA0_DMR0\t\t0x0150\t \n#define BA0_DCR0\t\t0x0154\t \n#define BA0_DMR1\t\t0x0158\t \n#define BA0_DCR1\t\t0x015c\t \n#define BA0_DMR2\t\t0x0160\t \n#define BA0_DCR2\t\t0x0164\t \n#define BA0_DMR3\t\t0x0168\t \n#define BA0_DCR3\t\t0x016c\t \n\n#define BA0_DMR_DMA\t\t(1<<29)\t \n#define BA0_DMR_POLL\t\t(1<<28)\t \n#define BA0_DMR_TBC\t\t(1<<25)\t \n#define BA0_DMR_CBC\t\t(1<<24)\t \n#define BA0_DMR_SWAPC\t\t(1<<22)\t \n#define BA0_DMR_SIZE20\t\t(1<<20)\t \n#define BA0_DMR_USIGN\t\t(1<<19)\t \n#define BA0_DMR_BEND\t\t(1<<18)\t \n#define BA0_DMR_MONO\t\t(1<<17)\t \n#define BA0_DMR_SIZE8\t\t(1<<16)\t \n#define BA0_DMR_TYPE_DEMAND\t(0<<6)\n#define BA0_DMR_TYPE_SINGLE\t(1<<6)\n#define BA0_DMR_TYPE_BLOCK\t(2<<6)\n#define BA0_DMR_TYPE_CASCADE\t(3<<6)\t \n#define BA0_DMR_DEC\t\t(1<<5)\t \n#define BA0_DMR_AUTO\t\t(1<<4)\t \n#define BA0_DMR_TR_VERIFY\t(0<<2)\t \n#define BA0_DMR_TR_WRITE\t(1<<2)\t \n#define BA0_DMR_TR_READ\t\t(2<<2)\t \n\n#define BA0_DCR_HTCIE\t\t(1<<17)\t \n#define BA0_DCR_TCIE\t\t(1<<16)\t \n#define BA0_DCR_MSK\t\t(1<<0)\t \n\n#define BA0_FCR0\t\t0x0180\t \n#define BA0_FCR1\t\t0x0184\t \n#define BA0_FCR2\t\t0x0188\t \n#define BA0_FCR3\t\t0x018c\t \n\n#define BA0_FCR_FEN\t\t(1<<31)\t \n#define BA0_FCR_DACZ\t\t(1<<30)\t \n#define BA0_FCR_PSH\t\t(1<<29)\t \n#define BA0_FCR_RS(x)\t\t(((x)&0x1f)<<24)  \n#define BA0_FCR_LS(x)\t\t(((x)&0x1f)<<16)  \n#define BA0_FCR_SZ(x)\t\t(((x)&0x7f)<<8)\t \n#define BA0_FCR_OF(x)\t\t(((x)&0x7f)<<0)\t \n\n#define BA0_FPDR0\t\t0x0190\t \n#define BA0_FPDR1\t\t0x0194\t \n#define BA0_FPDR2\t\t0x0198\t \n#define BA0_FPDR3\t\t0x019c\t \n\n#define BA0_FCHS\t\t0x020c\t \n#define BA0_FCHS_RCO(x)\t\t(1<<(7+(((x)&3)<<3)))  \n#define BA0_FCHS_LCO(x)\t\t(1<<(6+(((x)&3)<<3)))  \n#define BA0_FCHS_MRP(x)\t\t(1<<(5+(((x)&3)<<3)))  \n#define BA0_FCHS_FE(x)\t\t(1<<(4+(((x)&3)<<3)))  \n#define BA0_FCHS_FF(x)\t\t(1<<(3+(((x)&3)<<3)))  \n#define BA0_FCHS_IOR(x)\t\t(1<<(2+(((x)&3)<<3)))  \n#define BA0_FCHS_RCI(x)\t\t(1<<(1+(((x)&3)<<3)))  \n#define BA0_FCHS_LCI(x)\t\t(1<<(0+(((x)&3)<<3)))  \n\n#define BA0_FSIC0\t\t0x0210\t \n#define BA0_FSIC1\t\t0x0214\t \n#define BA0_FSIC2\t\t0x0218\t \n#define BA0_FSIC3\t\t0x021c\t \n\n#define BA0_FSIC_FIC(x)\t\t(((x)&0x7f)<<24)  \n#define BA0_FSIC_FORIE\t\t(1<<23)  \n#define BA0_FSIC_FURIE\t\t(1<<22)  \n#define BA0_FSIC_FSCIE\t\t(1<<16)\t \n#define BA0_FSIC_FSC(x)\t\t(((x)&0x7f)<<8)  \n#define BA0_FSIC_FOR\t\t(1<<7)\t \n#define BA0_FSIC_FUR\t\t(1<<6)\t \n#define BA0_FSIC_FSCR\t\t(1<<0)\t \n\n#define BA0_PMCS\t\t0x0344\t \n#define BA0_CWPR\t\t0x03e0\t \n\n#define BA0_EPPMC\t\t0x03e4\t \n#define BA0_EPPMC_FPDN\t\t(1<<14)  \n\n#define BA0_GPIOR\t\t0x03e8\t \n\n#define BA0_SPMC\t\t0x03ec\t \n#define BA0_SPMC_GIPPEN\t\t(1<<15)\t \n#define BA0_SPMC_GISPEN\t\t(1<<14)\t \n#define BA0_SPMC_EESPD\t\t(1<<9)\t \n#define BA0_SPMC_ASDI2E\t\t(1<<8)\t \n#define BA0_SPMC_ASDO\t\t(1<<7)\t \n#define BA0_SPMC_WUP2\t\t(1<<3)\t \n#define BA0_SPMC_WUP1\t\t(1<<2)\t \n#define BA0_SPMC_ASYNC\t\t(1<<1)\t \n#define BA0_SPMC_RSTN\t\t(1<<0)\t \n\n#define BA0_CFLR\t\t0x03f0\t \n#define BA0_CFLR_DEFAULT\t0x00000001  \n#define BA0_IISR\t\t0x03f4\t \n#define BA0_TMS\t\t\t0x03f8\t \n#define BA0_SSVID\t\t0x03fc\t \n\n#define BA0_CLKCR1\t\t0x0400\t \n#define BA0_CLKCR1_CLKON\t(1<<25)\t \n#define BA0_CLKCR1_DLLRDY\t(1<<24)\t \n#define BA0_CLKCR1_DLLOS\t(1<<6)\t \n#define BA0_CLKCR1_SWCE\t\t(1<<5)\t \n#define BA0_CLKCR1_DLLP\t\t(1<<4)\t \n#define BA0_CLKCR1_DLLSS\t(((x)&3)<<3)  \n\n#define BA0_FRR\t\t\t0x0410\t \n#define BA0_SLT12O\t\t0x041c\t \n\n#define BA0_SERMC\t\t0x0420\t \n#define BA0_SERMC_FCRN\t\t(1<<27)\t \n#define BA0_SERMC_ODSEN2\t(1<<25)\t \n#define BA0_SERMC_ODSEN1\t(1<<24)\t \n#define BA0_SERMC_SXLB\t\t(1<<21)\t \n#define BA0_SERMC_SLB\t\t(1<<20)\t \n#define BA0_SERMC_LOVF\t\t(1<<19)\t \n#define BA0_SERMC_TCID(x)\t(((x)&3)<<16)  \n#define BA0_SERMC_PXLB\t\t(5<<1)\t \n#define BA0_SERMC_PLB\t\t(4<<1)\t \n#define BA0_SERMC_PTC\t\t(7<<1)\t \n#define BA0_SERMC_PTC_AC97\t(1<<1)\t \n#define BA0_SERMC_MSPE\t\t(1<<0)\t \n\n#define BA0_SERC1\t\t0x0428\t \n#define BA0_SERC1_SO1F(x)\t(((x)&7)>>1)  \n#define BA0_SERC1_AC97\t\t(1<<1)\n#define BA0_SERC1_SO1EN\t\t(1<<0)\t \n\n#define BA0_SERC2\t\t0x042c\t \n#define BA0_SERC2_SI1F(x)\t(((x)&7)>>1)  \n#define BA0_SERC2_AC97\t\t(1<<1)\n#define BA0_SERC2_SI1EN\t\t(1<<0)\t \n\n#define BA0_SLT12M\t\t0x045c\t \n\n#define BA0_ACCTL\t\t0x0460\t \n#define BA0_ACCTL_TC\t\t(1<<6)\t \n#define BA0_ACCTL_CRW\t\t(1<<4)\t \n#define BA0_ACCTL_DCV\t\t(1<<3)\t \n#define BA0_ACCTL_VFRM\t\t(1<<2)\t \n#define BA0_ACCTL_ESYN\t\t(1<<1)\t \n\n#define BA0_ACSTS\t\t0x0464\t \n#define BA0_ACSTS_VSTS\t\t(1<<1)\t \n#define BA0_ACSTS_CRDY\t\t(1<<0)\t \n\n#define BA0_ACOSV\t\t0x0468\t \n#define BA0_ACOSV_SLV(x)\t(1<<((x)-3))\n\n#define BA0_ACCAD\t\t0x046c\t \n#define BA0_ACCDA\t\t0x0470\t \n\n#define BA0_ACISV\t\t0x0474\t \n#define BA0_ACISV_SLV(x)\t(1<<((x)-3))\n\n#define BA0_ACSAD\t\t0x0478\t \n#define BA0_ACSDA\t\t0x047c\t \n#define BA0_JSPT\t\t0x0480\t \n#define BA0_JSCTL\t\t0x0484\t \n#define BA0_JSC1\t\t0x0488\t \n#define BA0_JSC2\t\t0x048c\t \n#define BA0_JSIO\t\t0x04a0\n\n#define BA0_MIDCR\t\t0x0490\t \n#define BA0_MIDCR_MRST\t\t(1<<5)\t \n#define BA0_MIDCR_MLB\t\t(1<<4)\t \n#define BA0_MIDCR_TIE\t\t(1<<3)\t \n#define BA0_MIDCR_RIE\t\t(1<<2)\t \n#define BA0_MIDCR_RXE\t\t(1<<1)\t \n#define BA0_MIDCR_TXE\t\t(1<<0)\t \n\n#define BA0_MIDCMD\t\t0x0494\t \n\n#define BA0_MIDSR\t\t0x0494\t \n#define BA0_MIDSR_RDA\t\t(1<<15)\t \n#define BA0_MIDSR_TBE\t\t(1<<14)  \n#define BA0_MIDSR_RBE\t\t(1<<7)\t \n#define BA0_MIDSR_TBF\t\t(1<<6)\t \n\n#define BA0_MIDWP\t\t0x0498\t \n#define BA0_MIDRP\t\t0x049c\t \n\n#define BA0_AODSD1\t\t0x04a8\t \n#define BA0_AODSD1_NDS(x)\t(1<<((x)-3))\n\n#define BA0_AODSD2\t\t0x04ac\t \n#define BA0_AODSD2_NDS(x)\t(1<<((x)-3))\n\n#define BA0_CFGI\t\t0x04b0\t \n#define BA0_SLT12M2\t\t0x04dc\t \n#define BA0_ACSTS2\t\t0x04e4\t \n#define BA0_ACISV2\t\t0x04f4\t \n#define BA0_ACSAD2\t\t0x04f8\t \n#define BA0_ACSDA2\t\t0x04fc\t \n#define BA0_FMSR\t\t0x0730\t \n#define BA0_B0AP\t\t0x0730\t \n#define BA0_FMDP\t\t0x0734\t \n#define BA0_B1AP\t\t0x0738\t \n#define BA0_B1DP\t\t0x073c\t \n\n#define BA0_SSPM\t\t0x0740\t \n#define BA0_SSPM_MIXEN\t\t(1<<6)\t \n#define BA0_SSPM_CSRCEN\t\t(1<<5)\t \n#define BA0_SSPM_PSRCEN\t\t(1<<4)\t \n#define BA0_SSPM_JSEN\t\t(1<<3)\t \n#define BA0_SSPM_ACLEN\t\t(1<<2)\t \n#define BA0_SSPM_FMEN\t\t(1<<1)\t \n\n#define BA0_DACSR\t\t0x0744\t \n#define BA0_ADCSR\t\t0x0748\t \n\n#define BA0_SSCR\t\t0x074c\t \n#define BA0_SSCR_HVS1\t\t(1<<23)\t \n#define BA0_SSCR_MVCS\t\t(1<<19)\t \n#define BA0_SSCR_MVLD\t\t(1<<18)\t \n#define BA0_SSCR_MVAD\t\t(1<<17)\t \n#define BA0_SSCR_MVMD\t\t(1<<16)\t \n#define BA0_SSCR_XLPSRC\t\t(1<<8)\t \n#define BA0_SSCR_LPSRC\t\t(1<<7)\t \n#define BA0_SSCR_CDTX\t\t(1<<5)\t \n#define BA0_SSCR_HVC\t\t(1<<3)\t \n\n#define BA0_FMLVC\t\t0x0754\t \n#define BA0_FMRVC\t\t0x0758\t \n#define BA0_SRCSA\t\t0x075c\t \n#define BA0_PPLVC\t\t0x0760\t \n#define BA0_PPRVC\t\t0x0764\t \n#define BA0_PASR\t\t0x0768\t \n#define BA0_CASR\t\t0x076C\t \n\n \n#define SRCSLOT_LEFT_PCM_PLAYBACK\t\t0\n#define SRCSLOT_RIGHT_PCM_PLAYBACK\t\t1\n#define SRCSLOT_PHONE_LINE_1_DAC\t\t2\n#define SRCSLOT_CENTER_PCM_PLAYBACK\t\t3\n#define SRCSLOT_LEFT_SURROUND_PCM_PLAYBACK\t4\n#define SRCSLOT_RIGHT_SURROUND_PCM_PLAYBACK\t5\n#define SRCSLOT_LFE_PCM_PLAYBACK\t\t6\n#define SRCSLOT_PHONE_LINE_2_DAC\t\t7\n#define SRCSLOT_HEADSET_DAC\t\t\t8\n#define SRCSLOT_LEFT_WT\t\t\t\t29   \n#define SRCSLOT_RIGHT_WT\t\t\t30   \n\n \n#define SRCSLOT_LEFT_PCM_RECORD\t\t\t10\n#define SRCSLOT_RIGHT_PCM_RECORD\t\t11\n#define SRCSLOT_PHONE_LINE_1_ADC\t\t12\n#define SRCSLOT_MIC_ADC\t\t\t\t13\n#define SRCSLOT_PHONE_LINE_2_ADC\t\t17\n#define SRCSLOT_HEADSET_ADC\t\t\t18\n#define SRCSLOT_SECONDARY_LEFT_PCM_RECORD\t20\n#define SRCSLOT_SECONDARY_RIGHT_PCM_RECORD\t21\n#define SRCSLOT_SECONDARY_PHONE_LINE_1_ADC\t22\n#define SRCSLOT_SECONDARY_MIC_ADC\t\t23\n#define SRCSLOT_SECONDARY_PHONE_LINE_2_ADC\t27\n#define SRCSLOT_SECONDARY_HEADSET_ADC\t\t28\n\n \n#define SRCSLOT_POWER_DOWN\t\t\t31\n\n \n#define CS4281_MODE_OUTPUT\t\t(1<<0)\n#define CS4281_MODE_INPUT\t\t(1<<1)\n\n \n \n#define JSPT_CAX                                0x00000001\n#define JSPT_CAY                                0x00000002\n#define JSPT_CBX                                0x00000004\n#define JSPT_CBY                                0x00000008\n#define JSPT_BA1                                0x00000010\n#define JSPT_BA2                                0x00000020\n#define JSPT_BB1                                0x00000040\n#define JSPT_BB2                                0x00000080\n\n \n#define JSCTL_SP_MASK                           0x00000003\n#define JSCTL_SP_SLOW                           0x00000000\n#define JSCTL_SP_MEDIUM_SLOW                    0x00000001\n#define JSCTL_SP_MEDIUM_FAST                    0x00000002\n#define JSCTL_SP_FAST                           0x00000003\n#define JSCTL_ARE                               0x00000004\n\n \n#define JSC1_Y1V_MASK                           0x0000FFFF\n#define JSC1_X1V_MASK                           0xFFFF0000\n#define JSC1_Y1V_SHIFT                          0\n#define JSC1_X1V_SHIFT                          16\n#define JSC2_Y2V_MASK                           0x0000FFFF\n#define JSC2_X2V_MASK                           0xFFFF0000\n#define JSC2_Y2V_SHIFT                          0\n#define JSC2_X2V_SHIFT                          16\n\n \n#define JSIO_DAX                                0x00000001\n#define JSIO_DAY                                0x00000002\n#define JSIO_DBX                                0x00000004\n#define JSIO_DBY                                0x00000008\n#define JSIO_AXOE                               0x00000010\n#define JSIO_AYOE                               0x00000020\n#define JSIO_BXOE                               0x00000040\n#define JSIO_BYOE                               0x00000080\n\n \n\nstruct cs4281_dma {\n\tstruct snd_pcm_substream *substream;\n\tunsigned int regDBA;\t\t \n\tunsigned int regDCA;\t\t \n\tunsigned int regDBC;\t\t \n\tunsigned int regDCC;\t\t \n\tunsigned int regDMR;\t\t \n\tunsigned int regDCR;\t\t \n\tunsigned int regHDSR;\t\t \n\tunsigned int regFCR;\t\t \n\tunsigned int regFSIC;\t\t \n\tunsigned int valDMR;\t\t \n\tunsigned int valDCR;\t\t \n\tunsigned int valFCR;\t\t \n\tunsigned int fifo_offset;\t \n\tunsigned char left_slot;\t \n\tunsigned char right_slot;\t \n\tint frag;\t\t\t \n};\n\n#define SUSPEND_REGISTERS\t20\n\nstruct cs4281 {\n\tint irq;\n\n\tvoid __iomem *ba0;\t\t \n\tvoid __iomem *ba1;\t\t \n\tunsigned long ba0_addr;\n\tunsigned long ba1_addr;\n\n\tint dual_codec;\n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\tstruct snd_ac97 *ac97_secondary;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *midi_input;\n\tstruct snd_rawmidi_substream *midi_output;\n\n\tstruct cs4281_dma dma[4];\n\n\tunsigned char src_left_play_slot;\n\tunsigned char src_right_play_slot;\n\tunsigned char src_left_rec_slot;\n\tunsigned char src_right_rec_slot;\n\n\tunsigned int spurious_dhtc_irq;\n\tunsigned int spurious_dtc_irq;\n\n\tspinlock_t reg_lock;\n\tunsigned int midcr;\n\tunsigned int uartm;\n\n\tstruct gameport *gameport;\n\n#ifdef CONFIG_PM_SLEEP\n\tu32 suspend_regs[SUSPEND_REGISTERS];\n#endif\n\n};\n\nstatic irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id);\n\nstatic const struct pci_device_id snd_cs4281_ids[] = {\n\t{ PCI_VDEVICE(CIRRUS, 0x6005), 0, },\t \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_cs4281_ids);\n\n \n\n#define CS4281_FIFO_SIZE\t32\n\n \n\nstatic inline void snd_cs4281_pokeBA0(struct cs4281 *chip, unsigned long offset,\n\t\t\t\t      unsigned int val)\n{\n        writel(val, chip->ba0 + offset);\n}\n\nstatic inline unsigned int snd_cs4281_peekBA0(struct cs4281 *chip, unsigned long offset)\n{\n        return readl(chip->ba0 + offset);\n}\n\nstatic void snd_cs4281_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t  unsigned short reg, unsigned short val)\n{\n\t \n\tstruct cs4281 *chip = ac97->private_data;\n\tint count;\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCDA, val);\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_VFRM |\n\t\t\t\t            BA0_ACCTL_ESYN | (ac97->num ? BA0_ACCTL_TC : 0));\n\tfor (count = 0; count < 2000; count++) {\n\t\t \n\t\tudelay(10);\n\t\t \n\t\tif (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV)) {\n\t\t\treturn;\n\t\t}\n\t}\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 write problem, reg = 0x%x, val = 0x%x\\n\", reg, val);\n}\n\nstatic unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t   unsigned short reg)\n{\n\tstruct cs4281 *chip = ac97->private_data;\n\tint count;\n\tunsigned short result;\n\t\n\t\n\tvolatile int ac97_num = ((volatile struct snd_ac97 *)ac97)->num;\n\n\t \n\n\tsnd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);\n\n\t \n\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCDA, 0);\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_CRW |\n\t\t\t\t\t    BA0_ACCTL_VFRM | BA0_ACCTL_ESYN |\n\t\t\t   (ac97_num ? BA0_ACCTL_TC : 0));\n\n\n\t \n\tfor (count = 0; count < 500; count++) {\n\t\t \n\t\tudelay(10);\n\t\t \n\t\tif (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV))\n\t\t\tgoto __ok1;\n\t}\n\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 read problem (ACCTL_DCV), reg = 0x%x\\n\", reg);\n\tresult = 0xffff;\n\tgoto __end;\n\t\n      __ok1:\n\t \n\tfor (count = 0; count < 100; count++) {\n\t\t \n\t\tif (snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSTS2 : BA0_ACSTS) & BA0_ACSTS_VSTS)\n\t\t\tgoto __ok2;\n\t\tudelay(10);\n\t}\n\t\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 read problem (ACSTS_VSTS), reg = 0x%x\\n\", reg);\n\tresult = 0xffff;\n\tgoto __end;\n\n      __ok2:\n\t \n\tresult = snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);\n\n      __end:\n\treturn result;\n}\n\n \n\nstatic int snd_cs4281_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct cs4281_dma *dma = substream->runtime->private_data;\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdma->valDCR |= BA0_DCR_MSK;\n\t\tdma->valFCR |= BA0_FCR_FEN;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdma->valDCR &= ~BA0_DCR_MSK;\n\t\tdma->valFCR &= ~BA0_FCR_FEN;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tsnd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR & ~BA0_DMR_DMA);\n\t\tdma->valDMR |= BA0_DMR_DMA;\n\t\tdma->valDCR &= ~BA0_DCR_MSK;\n\t\tdma->valFCR |= BA0_FCR_FEN;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdma->valDMR &= ~(BA0_DMR_DMA|BA0_DMR_POLL);\n\t\tdma->valDCR |= BA0_DCR_MSK;\n\t\tdma->valFCR &= ~BA0_FCR_FEN;\n\t\t \n\t\tif (dma->regFCR != BA0_FCR0)\n\t\t\tdma->valFCR &= ~BA0_FCR_FEN;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock(&chip->reg_lock);\n\t\treturn -EINVAL;\n\t}\n\tsnd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR);\n\tsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR);\n\tsnd_cs4281_pokeBA0(chip, dma->regDCR, dma->valDCR);\n\tspin_unlock(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)\n{\n\tunsigned int val;\n\t\n\tif (real_rate)\n\t\t*real_rate = rate;\n\t \n\tswitch (rate) {\n\tcase 8000:\treturn 5;\n\tcase 11025:\treturn 4;\n\tcase 16000:\treturn 3;\n\tcase 22050:\treturn 2;\n\tcase 44100:\treturn 1;\n\tcase 48000:\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\tval = 1536000 / rate;\n\tif (real_rate)\n\t\t*real_rate = 1536000 / val;\n\treturn val;\n}\n\nstatic void snd_cs4281_mode(struct cs4281 *chip, struct cs4281_dma *dma,\n\t\t\t    struct snd_pcm_runtime *runtime,\n\t\t\t    int capture, int src)\n{\n\tint rec_mono;\n\n\tdma->valDMR = BA0_DMR_TYPE_SINGLE | BA0_DMR_AUTO |\n\t\t      (capture ? BA0_DMR_TR_WRITE : BA0_DMR_TR_READ);\n\tif (runtime->channels == 1)\n\t\tdma->valDMR |= BA0_DMR_MONO;\n\tif (snd_pcm_format_unsigned(runtime->format) > 0)\n\t\tdma->valDMR |= BA0_DMR_USIGN;\n\tif (snd_pcm_format_big_endian(runtime->format) > 0)\n\t\tdma->valDMR |= BA0_DMR_BEND;\n\tswitch (snd_pcm_format_width(runtime->format)) {\n\tcase 8: dma->valDMR |= BA0_DMR_SIZE8;\n\t\tif (runtime->channels == 1)\n\t\t\tdma->valDMR |= BA0_DMR_SWAPC;\n\t\tbreak;\n\tcase 32: dma->valDMR |= BA0_DMR_SIZE20; break;\n\t}\n\tdma->frag = 0;\t \n\tdma->valDCR = BA0_DCR_TCIE | BA0_DCR_MSK;\n\tif (runtime->buffer_size != runtime->period_size)\n\t\tdma->valDCR |= BA0_DCR_HTCIE;\n\t \n\tsnd_cs4281_pokeBA0(chip, dma->regDBA, runtime->dma_addr);\n\tsnd_cs4281_pokeBA0(chip, dma->regDBC, runtime->buffer_size - 1);\n\trec_mono = (chip->dma[1].valDMR & BA0_DMR_MONO) == BA0_DMR_MONO;\n\tsnd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |\n\t\t\t\t\t    (chip->src_right_play_slot << 8) |\n\t\t\t\t\t    (chip->src_left_rec_slot << 16) |\n\t\t\t\t\t    ((rec_mono ? 31 : chip->src_right_rec_slot) << 24));\n\tif (!src)\n\t\tgoto __skip_src;\n\tif (!capture) {\n\t\tif (dma->left_slot == chip->src_left_play_slot) {\n\t\t\tunsigned int val = snd_cs4281_rate(runtime->rate, NULL);\n\t\t\tsnd_BUG_ON(dma->right_slot != chip->src_right_play_slot);\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_DACSR, val);\n\t\t}\n\t} else {\n\t\tif (dma->left_slot == chip->src_left_rec_slot) {\n\t\t\tunsigned int val = snd_cs4281_rate(runtime->rate, NULL);\n\t\t\tsnd_BUG_ON(dma->right_slot != chip->src_right_rec_slot);\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_ADCSR, val);\n\t\t}\n\t}\n      __skip_src:\n\t \n\tif (dma->regFCR == BA0_FCR0)\n\t\tsnd_cs4281_pokeBA0(chip, dma->regFCR, snd_cs4281_peekBA0(chip, dma->regFCR) & ~BA0_FCR_FEN);\n\t \n\tdma->valFCR = BA0_FCR_LS(dma->left_slot) |\n\t\t      BA0_FCR_RS(capture && (dma->valDMR & BA0_DMR_MONO) ? 31 : dma->right_slot) |\n\t\t      BA0_FCR_SZ(CS4281_FIFO_SIZE) |\n\t\t      BA0_FCR_OF(dma->fifo_offset);\n\tsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | (capture ? BA0_FCR_PSH : 0));\n\t \n\tif (dma->regFCR == BA0_FCR0)\n\t\tsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | BA0_FCR_FEN);\n\t \n\tsnd_cs4281_pokeBA0(chip, dma->regFSIC, 0);\n}\n\nstatic int snd_cs4281_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cs4281_dma *dma = runtime->private_data;\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_cs4281_mode(chip, dma, runtime, 0, 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs4281_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cs4281_dma *dma = runtime->private_data;\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tsnd_cs4281_mode(chip, dma, runtime, 1, 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cs4281_dma *dma = runtime->private_data;\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\n\t \n\treturn runtime->buffer_size -\n\t       snd_cs4281_peekBA0(chip, dma->regDCC) - 1;\n}\n\nstatic const struct snd_pcm_hardware snd_cs4281_playback =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(512*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(512*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\tCS4281_FIFO_SIZE,\n};\n\nstatic const struct snd_pcm_hardware snd_cs4281_capture =\n{\n\t.info =\t\t\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(512*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(512*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\tCS4281_FIFO_SIZE,\n};\n\nstatic int snd_cs4281_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cs4281_dma *dma;\n\n\tdma = &chip->dma[0];\n\tdma->substream = substream;\n\tdma->left_slot = 0;\n\tdma->right_slot = 1;\n\truntime->private_data = dma;\n\truntime->hw = snd_cs4281_playback;\n\t \n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\n\treturn 0;\n}\n\nstatic int snd_cs4281_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct cs4281 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cs4281_dma *dma;\n\n\tdma = &chip->dma[1];\n\tdma->substream = substream;\n\tdma->left_slot = 10;\n\tdma->right_slot = 11;\n\truntime->private_data = dma;\n\truntime->hw = snd_cs4281_capture;\n\t \n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\n\treturn 0;\n}\n\nstatic int snd_cs4281_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct cs4281_dma *dma = substream->runtime->private_data;\n\n\tdma->substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_cs4281_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct cs4281_dma *dma = substream->runtime->private_data;\n\n\tdma->substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_cs4281_playback_ops = {\n\t.open =\t\tsnd_cs4281_playback_open,\n\t.close =\tsnd_cs4281_playback_close,\n\t.prepare =\tsnd_cs4281_playback_prepare,\n\t.trigger =\tsnd_cs4281_trigger,\n\t.pointer =\tsnd_cs4281_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs4281_capture_ops = {\n\t.open =\t\tsnd_cs4281_capture_open,\n\t.close =\tsnd_cs4281_capture_close,\n\t.prepare =\tsnd_cs4281_capture_prepare,\n\t.trigger =\tsnd_cs4281_trigger,\n\t.pointer =\tsnd_cs4281_pointer,\n};\n\nstatic int snd_cs4281_pcm(struct cs4281 *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"CS4281\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs4281_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs4281_capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS4281\");\n\tchip->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t       64*1024, 512*1024);\n\n\treturn 0;\n}\n\n \n\n#define CS_VOL_MASK\t0x1f\n\nstatic int snd_cs4281_info_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type              = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count             = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = CS_VOL_MASK;\n\treturn 0;\n}\n \nstatic int snd_cs4281_get_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs4281 *chip = snd_kcontrol_chip(kcontrol);\n\tint regL = (kcontrol->private_value >> 16) & 0xffff;\n\tint regR = kcontrol->private_value & 0xffff;\n\tint volL, volR;\n\n\tvolL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);\n\tvolR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);\n\n\tucontrol->value.integer.value[0] = volL;\n\tucontrol->value.integer.value[1] = volR;\n\treturn 0;\n}\n\nstatic int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct cs4281 *chip = snd_kcontrol_chip(kcontrol);\n\tint change = 0;\n\tint regL = (kcontrol->private_value >> 16) & 0xffff;\n\tint regR = kcontrol->private_value & 0xffff;\n\tint volL, volR;\n\n\tvolL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);\n\tvolR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);\n\n\tif (ucontrol->value.integer.value[0] != volL) {\n\t\tvolL = CS_VOL_MASK - (ucontrol->value.integer.value[0] & CS_VOL_MASK);\n\t\tsnd_cs4281_pokeBA0(chip, regL, volL);\n\t\tchange = 1;\n\t}\n\tif (ucontrol->value.integer.value[1] != volR) {\n\t\tvolR = CS_VOL_MASK - (ucontrol->value.integer.value[1] & CS_VOL_MASK);\n\t\tsnd_cs4281_pokeBA0(chip, regR, volR);\n\t\tchange = 1;\n\t}\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);\n\nstatic const struct snd_kcontrol_new snd_cs4281_fm_vol =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Synth Playback Volume\",\n\t.info = snd_cs4281_info_volume, \n\t.get = snd_cs4281_get_volume,\n\t.put = snd_cs4281_put_volume, \n\t.private_value = ((BA0_FMLVC << 16) | BA0_FMRVC),\n\t.tlv = { .p = db_scale_dsp },\n};\n\nstatic const struct snd_kcontrol_new snd_cs4281_pcm_vol =\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Stream Playback Volume\",\n\t.info = snd_cs4281_info_volume, \n\t.get = snd_cs4281_get_volume,\n\t.put = snd_cs4281_put_volume, \n\t.private_value = ((BA0_PPLVC << 16) | BA0_PPRVC),\n\t.tlv = { .p = db_scale_dsp },\n};\n\nstatic void snd_cs4281_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct cs4281 *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_cs4281_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct cs4281 *chip = ac97->private_data;\n\tif (ac97->num)\n\t\tchip->ac97_secondary = NULL;\n\telse\n\t\tchip->ac97 = NULL;\n}\n\nstatic int snd_cs4281_mixer(struct cs4281 *chip)\n{\n\tstruct snd_card *card = chip->card;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_cs4281_ac97_write,\n\t\t.read = snd_cs4281_ac97_read,\n\t};\n\n\terr = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97_bus->private_free = snd_cs4281_mixer_free_ac97_bus;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_cs4281_mixer_free_ac97;\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\tif (chip->dual_codec) {\n\t\tac97.num = 1;\n\t\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_secondary);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_fm_vol, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_pcm_vol, chip));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n\n \n\nstatic void snd_cs4281_proc_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct cs4281 *chip = entry->private_data;\n\n\tsnd_iprintf(buffer, \"Cirrus Logic CS4281\\n\\n\");\n\tsnd_iprintf(buffer, \"Spurious half IRQs   : %u\\n\", chip->spurious_dhtc_irq);\n\tsnd_iprintf(buffer, \"Spurious end IRQs    : %u\\n\", chip->spurious_dtc_irq);\n}\n\nstatic ssize_t snd_cs4281_BA0_read(struct snd_info_entry *entry,\n\t\t\t\t   void *file_private_data,\n\t\t\t\t   struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t pos)\n{\n\tstruct cs4281 *chip = entry->private_data;\n\t\n\tif (copy_to_user_fromio(buf, chip->ba0 + pos, count))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\nstatic ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,\n\t\t\t\t   void *file_private_data,\n\t\t\t\t   struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t pos)\n{\n\tstruct cs4281 *chip = entry->private_data;\n\t\n\tif (copy_to_user_fromio(buf, chip->ba1 + pos, count))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\nstatic const struct snd_info_entry_ops snd_cs4281_proc_ops_BA0 = {\n\t.read = snd_cs4281_BA0_read,\n};\n\nstatic const struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {\n\t.read = snd_cs4281_BA1_read,\n};\n\nstatic void snd_cs4281_proc_init(struct cs4281 *chip)\n{\n\tstruct snd_info_entry *entry;\n\n\tsnd_card_ro_proc_new(chip->card, \"cs4281\", chip, snd_cs4281_proc_read);\n\tif (! snd_card_proc_new(chip->card, \"cs4281_BA0\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = chip;\n\t\tentry->c.ops = &snd_cs4281_proc_ops_BA0;\n\t\tentry->size = CS4281_BA0_SIZE;\n\t}\n\tif (! snd_card_proc_new(chip->card, \"cs4281_BA1\", &entry)) {\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->private_data = chip;\n\t\tentry->c.ops = &snd_cs4281_proc_ops_BA1;\n\t\tentry->size = CS4281_BA1_SIZE;\n\t}\n}\n\n \n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n\nstatic void snd_cs4281_gameport_trigger(struct gameport *gameport)\n{\n\tstruct cs4281 *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn;\n\tsnd_cs4281_pokeBA0(chip, BA0_JSPT, 0xff);\n}\n\nstatic unsigned char snd_cs4281_gameport_read(struct gameport *gameport)\n{\n\tstruct cs4281 *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\treturn snd_cs4281_peekBA0(chip, BA0_JSPT);\n}\n\n#ifdef COOKED_MODE\nstatic int snd_cs4281_gameport_cooked_read(struct gameport *gameport,\n\t\t\t\t\t   int *axes, int *buttons)\n{\n\tstruct cs4281 *chip = gameport_get_port_data(gameport);\n\tunsigned js1, js2, jst;\n\t\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\n\tjs1 = snd_cs4281_peekBA0(chip, BA0_JSC1);\n\tjs2 = snd_cs4281_peekBA0(chip, BA0_JSC2);\n\tjst = snd_cs4281_peekBA0(chip, BA0_JSPT);\n\t\n\t*buttons = (~jst >> 4) & 0x0F; \n\t\n\taxes[0] = ((js1 & JSC1_Y1V_MASK) >> JSC1_Y1V_SHIFT) & 0xFFFF;\n\taxes[1] = ((js1 & JSC1_X1V_MASK) >> JSC1_X1V_SHIFT) & 0xFFFF;\n\taxes[2] = ((js2 & JSC2_Y2V_MASK) >> JSC2_Y2V_SHIFT) & 0xFFFF;\n\taxes[3] = ((js2 & JSC2_X2V_MASK) >> JSC2_X2V_SHIFT) & 0xFFFF;\n\n\tfor (jst = 0; jst < 4; ++jst)\n\t\tif (axes[jst] == 0xFFFF) axes[jst] = -1;\n\treturn 0;\n}\n#else\n#define snd_cs4281_gameport_cooked_read\tNULL\n#endif\n\nstatic int snd_cs4281_gameport_open(struct gameport *gameport, int mode)\n{\n\tswitch (mode) {\n#ifdef COOKED_MODE\n\tcase GAMEPORT_MODE_COOKED:\n\t\treturn 0;\n#endif\n\tcase GAMEPORT_MODE_RAW:\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_cs4281_create_gameport(struct cs4281 *chip)\n{\n\tstruct gameport *gp;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"CS4281 Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgp->open = snd_cs4281_gameport_open;\n\tgp->read = snd_cs4281_gameport_read;\n\tgp->trigger = snd_cs4281_gameport_trigger;\n\tgp->cooked_read = snd_cs4281_gameport_cooked_read;\n\tgameport_set_port_data(gp, chip);\n\n\tsnd_cs4281_pokeBA0(chip, BA0_JSIO, 0xFF); \n\tsnd_cs4281_pokeBA0(chip, BA0_JSCTL, JSCTL_SP_MEDIUM_SLOW);\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic void snd_cs4281_free_gameport(struct cs4281 *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nstatic inline int snd_cs4281_create_gameport(struct cs4281 *chip) { return -ENOSYS; }\nstatic inline void snd_cs4281_free_gameport(struct cs4281 *chip) { }\n#endif  \n\nstatic void snd_cs4281_free(struct snd_card *card)\n{\n\tstruct cs4281 *chip = card->private_data;\n\n\tsnd_cs4281_free_gameport(chip);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff);\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SSPM, 0);\n}\n\nstatic int snd_cs4281_chip_init(struct cs4281 *chip);  \n\nstatic int snd_cs4281_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci,\n\t\t\t     int dual_codec)\n{\n\tstruct cs4281 *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tspin_lock_init(&chip->reg_lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tpci_set_master(pci);\n\tif (dual_codec < 0 || dual_codec > 3) {\n\t\tdev_err(card->dev, \"invalid dual_codec option %d\\n\", dual_codec);\n\t\tdual_codec = 0;\n\t}\n\tchip->dual_codec = dual_codec;\n\n\terr = pcim_iomap_regions(pci, 0x03, \"CS4281\");  \n\tif (err < 0)\n\t\treturn err;\n\tchip->ba0_addr = pci_resource_start(pci, 0);\n\tchip->ba1_addr = pci_resource_start(pci, 1);\n\n\tchip->ba0 = pcim_iomap_table(pci)[0];\n\tchip->ba1 = pcim_iomap_table(pci)[1];\n\t\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_cs4281_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -ENOMEM;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_cs4281_free;\n\n\terr = snd_cs4281_chip_init(chip);\n\tif (err)\n\t\treturn err;\n\n\tsnd_cs4281_proc_init(chip);\n\treturn 0;\n}\n\nstatic int snd_cs4281_chip_init(struct cs4281 *chip)\n{\n\tunsigned int tmp;\n\tunsigned long end_time;\n\tint retry_count = 2;\n\n\t \n\ttmp = snd_cs4281_peekBA0(chip, BA0_EPPMC);\n\tif (tmp & BA0_EPPMC_FPDN)\n\t\tsnd_cs4281_pokeBA0(chip, BA0_EPPMC, tmp & ~BA0_EPPMC_FPDN);\n\n      __retry:\n\ttmp = snd_cs4281_peekBA0(chip, BA0_CFLR);\n\tif (tmp != BA0_CFLR_DEFAULT) {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);\n\t\ttmp = snd_cs4281_peekBA0(chip, BA0_CFLR);\n\t\tif (tmp != BA0_CFLR_DEFAULT) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"CFLR setup failed (0x%x)\\n\", tmp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \t\n\tsnd_cs4281_pokeBA0(chip, BA0_CWPR, 0x4281);\n\t\n\ttmp = snd_cs4281_peekBA0(chip, BA0_SERC1);\n\tif (tmp != (BA0_SERC1_SO1EN | BA0_SERC1_AC97)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"SERC1 AC'97 check failed (0x%x)\\n\", tmp);\n\t\treturn -EIO;\n\t}\n\ttmp = snd_cs4281_peekBA0(chip, BA0_SERC2);\n\tif (tmp != (BA0_SERC2_SI1EN | BA0_SERC2_AC97)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"SERC2 AC'97 check failed (0x%x)\\n\", tmp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SSPM, BA0_SSPM_MIXEN | BA0_SSPM_CSRCEN |\n\t\t\t\t           BA0_SSPM_PSRCEN | BA0_SSPM_JSEN |\n\t\t\t\t           BA0_SSPM_ACLEN | BA0_SSPM_FMEN);\n\n\t \n \t \n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\n\tsnd_cs4281_pokeBA0(chip, BA0_SERMC, 0);\n\n         \n\tsnd_cs4281_pokeBA0(chip, BA0_ACCTL, 0);\n\tudelay(50);\n                \n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SPMC, 0);\n\tudelay(50);\n\tsnd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN);\n\tmsleep(50);\n\n\tif (chip->dual_codec)\n\t\tsnd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN | BA0_SPMC_ASDI2E);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SERMC,\n\t\t\t   (chip->dual_codec ? BA0_SERMC_TCID(chip->dual_codec) : BA0_SERMC_TCID(1)) |\n\t\t\t   BA0_SERMC_PTC_AC97 | BA0_SERMC_MSPE);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_DLLP);\n\tmsleep(50);\n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_SWCE | BA0_CLKCR1_DLLP);\n\n\t \n\tend_time = jiffies + HZ;\n\tdo {\n\t\t \n\t\tif (snd_cs4281_peekBA0(chip, BA0_CLKCR1) & BA0_CLKCR1_DLLRDY)\n\t\t\tgoto __ok0;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\n\tdev_err(chip->card->dev, \"DLLRDY not seen\\n\");\n\treturn -EIO;\n\n      __ok0:\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_ESYN);\n\n\t \n\tend_time = jiffies + HZ;\n\tdo {\n\t\t \n\t\tif (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_CRDY)\n\t\t\tgoto __ok1;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\n\tdev_err(chip->card->dev,\n\t\t\"never read codec ready from AC'97 (0x%x)\\n\",\n\t\tsnd_cs4281_peekBA0(chip, BA0_ACSTS));\n\treturn -EIO;\n\n      __ok1:\n\tif (chip->dual_codec) {\n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tif (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)\n\t\t\t\tgoto __codec2_ok;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tdev_info(chip->card->dev,\n\t\t\t \"secondary codec doesn't respond. disable it...\\n\");\n\t\tchip->dual_codec = 0;\n\t__codec2_ok: ;\n\t}\n\n\t \n\n\tsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_VFRM | BA0_ACCTL_ESYN);\n\n\t \n\n\tend_time = jiffies + HZ;\n\tdo {\n\t\t \n                if ((snd_cs4281_peekBA0(chip, BA0_ACISV) & (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4))) == (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4)))\n                        goto __ok2;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\n\tif (--retry_count > 0)\n\t\tgoto __retry;\n\tdev_err(chip->card->dev, \"never read ISV3 and ISV4 from AC'97\\n\");\n\treturn -EIO;\n\n      __ok2:\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_ACOSV, BA0_ACOSV_SLV(3) | BA0_ACOSV_SLV(4));\n\n\t \n\tfor (tmp = 0; tmp < 4; tmp++) {\n\t\tstruct cs4281_dma *dma = &chip->dma[tmp];\n\t\tdma->regDBA = BA0_DBA0 + (tmp * 0x10);\n\t\tdma->regDCA = BA0_DCA0 + (tmp * 0x10);\n\t\tdma->regDBC = BA0_DBC0 + (tmp * 0x10);\n\t\tdma->regDCC = BA0_DCC0 + (tmp * 0x10);\n\t\tdma->regDMR = BA0_DMR0 + (tmp * 8);\n\t\tdma->regDCR = BA0_DCR0 + (tmp * 8);\n\t\tdma->regHDSR = BA0_HDSR0 + (tmp * 4);\n\t\tdma->regFCR = BA0_FCR0 + (tmp * 4);\n\t\tdma->regFSIC = BA0_FSIC0 + (tmp * 4);\n\t\tdma->fifo_offset = tmp * CS4281_FIFO_SIZE;\n\t\tsnd_cs4281_pokeBA0(chip, dma->regFCR,\n\t\t\t\t   BA0_FCR_LS(31) |\n\t\t\t\t   BA0_FCR_RS(31) |\n\t\t\t\t   BA0_FCR_SZ(CS4281_FIFO_SIZE) |\n\t\t\t\t   BA0_FCR_OF(dma->fifo_offset));\n\t}\n\n\tchip->src_left_play_slot = 0;\t \n\tchip->src_right_play_slot = 1;\t \n\tchip->src_left_rec_slot = 10;\t \n\tchip->src_right_rec_slot = 11;\t \n\n\t \n\tchip->dma[0].valFCR = BA0_FCR_FEN | BA0_FCR_LS(0) |\n\t\t              BA0_FCR_RS(1) |\n \t  \t              BA0_FCR_SZ(CS4281_FIFO_SIZE) |\n\t\t              BA0_FCR_OF(chip->dma[0].fifo_offset);\n\tsnd_cs4281_pokeBA0(chip, chip->dma[0].regFCR, chip->dma[0].valFCR);\n\tsnd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |\n\t\t\t\t\t    (chip->src_right_play_slot << 8) |\n\t\t\t\t\t    (chip->src_left_rec_slot << 16) |\n\t\t\t\t\t    (chip->src_right_rec_slot << 24));\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_PPLVC, 0);\n\tsnd_cs4281_pokeBA0(chip, BA0_PPRVC, 0);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff & ~(\n\t\t\t\t\tBA0_HISR_MIDI |\n\t\t\t\t\tBA0_HISR_DMAI |\n\t\t\t\t\tBA0_HISR_DMA(0) |\n\t\t\t\t\tBA0_HISR_DMA(1) |\n\t\t\t\t\tBA0_HISR_DMA(2) |\n\t\t\t\t\tBA0_HISR_DMA(3)));\n\n\treturn 0;\n}\n\n \n\nstatic void snd_cs4281_midi_reset(struct cs4281 *chip)\n{\n\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr | BA0_MIDCR_MRST);\n\tudelay(100);\n\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n}\n\nstatic int snd_cs4281_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n \tchip->midcr |= BA0_MIDCR_RXE;\n\tchip->midi_input = substream;\n\tif (!(chip->uartm & CS4281_MODE_OUTPUT)) {\n\t\tsnd_cs4281_midi_reset(chip);\n\t} else {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs4281_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->midcr &= ~(BA0_MIDCR_RXE | BA0_MIDCR_RIE);\n\tchip->midi_input = NULL;\n\tif (!(chip->uartm & CS4281_MODE_OUTPUT)) {\n\t\tsnd_cs4281_midi_reset(chip);\n\t} else {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tchip->uartm &= ~CS4281_MODE_INPUT;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs4281_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->uartm |= CS4281_MODE_OUTPUT;\n\tchip->midcr |= BA0_MIDCR_TXE;\n\tchip->midi_output = substream;\n\tif (!(chip->uartm & CS4281_MODE_INPUT)) {\n\t\tsnd_cs4281_midi_reset(chip);\n\t} else {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs4281_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->midcr &= ~(BA0_MIDCR_TXE | BA0_MIDCR_TIE);\n\tchip->midi_output = NULL;\n\tif (!(chip->uartm & CS4281_MODE_INPUT)) {\n\t\tsnd_cs4281_midi_reset(chip);\n\t} else {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tchip->uartm &= ~CS4281_MODE_OUTPUT;\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic void snd_cs4281_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (up) {\n\t\tif ((chip->midcr & BA0_MIDCR_RIE) == 0) {\n\t\t\tchip->midcr |= BA0_MIDCR_RIE;\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t} else {\n\t\tif (chip->midcr & BA0_MIDCR_RIE) {\n\t\t\tchip->midcr &= ~BA0_MIDCR_RIE;\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_cs4281_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct cs4281 *chip = substream->rmidi->private_data;\n\tunsigned char byte;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (up) {\n\t\tif ((chip->midcr & BA0_MIDCR_TIE) == 0) {\n\t\t\tchip->midcr |= BA0_MIDCR_TIE;\n\t\t\t \n\t\t\twhile ((chip->midcr & BA0_MIDCR_TIE) &&\n\t\t\t       (snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {\n\t\t\t\tif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\tchip->midcr &= ~BA0_MIDCR_TIE;\n\t\t\t\t} else {\n\t\t\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDWP, byte);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t} else {\n\t\tif (chip->midcr & BA0_MIDCR_TIE) {\n\t\t\tchip->midcr &= ~BA0_MIDCR_TIE;\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_cs4281_midi_output =\n{\n\t.open =\t\tsnd_cs4281_midi_output_open,\n\t.close =\tsnd_cs4281_midi_output_close,\n\t.trigger =\tsnd_cs4281_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_cs4281_midi_input =\n{\n\t.open = \tsnd_cs4281_midi_input_open,\n\t.close =\tsnd_cs4281_midi_input_close,\n\t.trigger =\tsnd_cs4281_midi_input_trigger,\n};\n\nstatic int snd_cs4281_midi(struct cs4281 *chip, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(chip->card, \"CS4281\", device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, \"CS4281\");\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_cs4281_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_cs4281_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = chip;\n\tchip->rmidi = rmidi;\n\treturn 0;\n}\n\n \n\nstatic irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id)\n{\n\tstruct cs4281 *chip = dev_id;\n\tunsigned int status, dma, val;\n\tstruct cs4281_dma *cdma;\n\n\tif (chip == NULL)\n\t\treturn IRQ_NONE;\n\tstatus = snd_cs4281_peekBA0(chip, BA0_HISR);\n\tif ((status & 0x7fffffff) == 0) {\n\t\tsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status & (BA0_HISR_DMA(0)|BA0_HISR_DMA(1)|BA0_HISR_DMA(2)|BA0_HISR_DMA(3))) {\n\t\tfor (dma = 0; dma < 4; dma++)\n\t\t\tif (status & BA0_HISR_DMA(dma)) {\n\t\t\t\tcdma = &chip->dma[dma];\n\t\t\t\tspin_lock(&chip->reg_lock);\n\t\t\t\t \n\t\t\t\tval = snd_cs4281_peekBA0(chip, cdma->regHDSR);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tcdma->frag++;\n\t\t\t\tif ((val & BA0_HDSR_DHTC) && !(cdma->frag & 1)) {\n\t\t\t\t\tcdma->frag--;\n\t\t\t\t\tchip->spurious_dhtc_irq++;\n\t\t\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((val & BA0_HDSR_DTC) && (cdma->frag & 1)) {\n\t\t\t\t\tcdma->frag--;\n\t\t\t\t\tchip->spurious_dtc_irq++;\n\t\t\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\t\tsnd_pcm_period_elapsed(cdma->substream);\n\t\t\t}\n\t}\n\n\tif ((status & BA0_HISR_MIDI) && chip->rmidi) {\n\t\tunsigned char c;\n\t\t\n\t\tspin_lock(&chip->reg_lock);\n\t\twhile ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_RBE) == 0) {\n\t\t\tc = snd_cs4281_peekBA0(chip, BA0_MIDRP);\n\t\t\tif ((chip->midcr & BA0_MIDCR_RIE) == 0)\n\t\t\t\tcontinue;\n\t\t\tsnd_rawmidi_receive(chip->midi_input, &c, 1);\n\t\t}\n\t\twhile ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {\n\t\t\tif ((chip->midcr & BA0_MIDCR_TIE) == 0)\n\t\t\t\tbreak;\n\t\t\tif (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {\n\t\t\t\tchip->midcr &= ~BA0_MIDCR_TIE;\n\t\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnd_cs4281_pokeBA0(chip, BA0_MIDWP, c);\n\t\t}\n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void snd_cs4281_opl3_command(struct snd_opl3 *opl3, unsigned short cmd,\n\t\t\t\t    unsigned char val)\n{\n\tunsigned long flags;\n\tstruct cs4281 *chip = opl3->private_data;\n\tvoid __iomem *port;\n\n\tif (cmd & OPL3_RIGHT)\n\t\tport = chip->ba0 + BA0_B1AP;  \n\telse\n\t\tport = chip->ba0 + BA0_B0AP;  \n\n\tspin_lock_irqsave(&opl3->reg_lock, flags);\n\n\twritel((unsigned int)cmd, port);\n\tudelay(10);\n\n\twritel((unsigned int)val, port + 4);\n\tudelay(30);\n\n\tspin_unlock_irqrestore(&opl3->reg_lock, flags);\n}\n\nstatic int __snd_cs4281_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct cs4281 *chip;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n        if (dev >= SNDRV_CARDS)\n                return -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_cs4281_create(card, pci, dual_codec[dev]);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_cs4281_mixer(chip);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_cs4281_pcm(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_cs4281_midi(chip, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_opl3_new(card, OPL3_HW_OPL3_CS4281, &opl3);\n\tif (err < 0)\n\t\treturn err;\n\topl3->private_data = chip;\n\topl3->command = snd_cs4281_opl3_command;\n\tsnd_opl3_init(opl3);\n\terr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_cs4281_create_gameport(chip);\n\tstrcpy(card->driver, \"CS4281\");\n\tstrcpy(card->shortname, \"Cirrus Logic CS4281\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\",\n\t\tcard->shortname,\n\t\tchip->ba0_addr,\n\t\tchip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_cs4281_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_cs4281_probe(pci, pci_id));\n}\n\n \n#ifdef CONFIG_PM_SLEEP\n\nstatic const int saved_regs[SUSPEND_REGISTERS] = {\n\tBA0_JSCTL,\n\tBA0_GPIOR,\n\tBA0_SSCR,\n\tBA0_MIDCR,\n\tBA0_SRCSA,\n\tBA0_PASR,\n\tBA0_CASR,\n\tBA0_DACSR,\n\tBA0_ADCSR,\n\tBA0_FMLVC,\n\tBA0_FMRVC,\n\tBA0_PPLVC,\n\tBA0_PPRVC,\n};\n\n#define CLKCR1_CKRA                             0x00010000L\n\nstatic int cs4281_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct cs4281 *chip = card->private_data;\n\tu32 ulCLK;\n\tunsigned int i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\tsnd_ac97_suspend(chip->ac97_secondary);\n\n\tulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\n\tulCLK |= CLKCR1_CKRA;\n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_CHGM);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tif (saved_regs[i])\n\t\t\tchip->suspend_regs[i] = snd_cs4281_peekBA0(chip, saved_regs[i]);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SERMC, 0);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SSPM, 0);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\n\n\t \n\tsnd_cs4281_pokeBA0(chip, BA0_SPMC, 0);\n\n\tulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\n\tulCLK &= ~CLKCR1_CKRA;\n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\n\treturn 0;\n}\n\nstatic int cs4281_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct cs4281 *chip = card->private_data;\n\tunsigned int i;\n\tu32 ulCLK;\n\n\tulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\n\tulCLK |= CLKCR1_CKRA;\n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\n\n\tsnd_cs4281_chip_init(chip);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tif (saved_regs[i])\n\t\t\tsnd_cs4281_pokeBA0(chip, saved_regs[i], chip->suspend_regs[i]);\n\n\tsnd_ac97_resume(chip->ac97);\n\tsnd_ac97_resume(chip->ac97_secondary);\n\n\tulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\n\tulCLK &= ~CLKCR1_CKRA;\n\tsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cs4281_pm, cs4281_suspend, cs4281_resume);\n#define CS4281_PM_OPS\t&cs4281_pm\n#else\n#define CS4281_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver cs4281_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_cs4281_ids,\n\t.probe = snd_cs4281_probe,\n\t.driver = {\n\t\t.pm = CS4281_PM_OPS,\n\t},\n};\n\t\nmodule_pci_driver(cs4281_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}