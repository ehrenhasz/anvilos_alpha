{
  "module_name": "via82xx_modem.c",
  "hash_id": "39b9c3a00ba4c39c2056f243091b8698904149a117ab45c4d1408c78194f26ad",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/via82xx_modem.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n\n#if 0\n#define POINTER_DEBUG\n#endif\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"VIA VT82xx modem\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = -2;  \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int ac97_clock = 48000;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for VIA 82xx bridge.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for VIA 82xx bridge.\");\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (default 48000Hz).\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n\n \n\n#define VIAREG(via, x) ((via)->port + VIA_REG_##x)\n#define VIADEV_REG(viadev, x) ((viadev)->port + VIA_REG_##x)\n\n \n#define VIA_REG_OFFSET_STATUS\t\t0x00\t \n#define   VIA_REG_STAT_ACTIVE\t\t0x80\t \n#define   VIA_REG_STAT_PAUSED\t\t0x40\t \n#define   VIA_REG_STAT_TRIGGER_QUEUED\t0x08\t \n#define   VIA_REG_STAT_STOPPED\t\t0x04\t \n#define   VIA_REG_STAT_EOL\t\t0x02\t \n#define   VIA_REG_STAT_FLAG\t\t0x01\t \n#define VIA_REG_OFFSET_CONTROL\t\t0x01\t \n#define   VIA_REG_CTRL_START\t\t0x80\t \n#define   VIA_REG_CTRL_TERMINATE\t0x40\t \n#define   VIA_REG_CTRL_AUTOSTART\t0x20\n#define   VIA_REG_CTRL_PAUSE\t\t0x08\t \n#define   VIA_REG_CTRL_INT_STOP\t\t0x04\t\t\n#define   VIA_REG_CTRL_INT_EOL\t\t0x02\n#define   VIA_REG_CTRL_INT_FLAG\t\t0x01\n#define   VIA_REG_CTRL_RESET\t\t0x01\t \n#define   VIA_REG_CTRL_INT (VIA_REG_CTRL_INT_FLAG | VIA_REG_CTRL_INT_EOL | VIA_REG_CTRL_AUTOSTART)\n#define VIA_REG_OFFSET_TYPE\t\t0x02\t \n#define   VIA_REG_TYPE_AUTOSTART\t0x80\t \n#define   VIA_REG_TYPE_16BIT\t\t0x20\t \n#define   VIA_REG_TYPE_STEREO\t\t0x10\t \n#define   VIA_REG_TYPE_INT_LLINE\t0x00\n#define   VIA_REG_TYPE_INT_LSAMPLE\t0x04\n#define   VIA_REG_TYPE_INT_LESSONE\t0x08\n#define   VIA_REG_TYPE_INT_MASK\t\t0x0c\n#define   VIA_REG_TYPE_INT_EOL\t\t0x02\n#define   VIA_REG_TYPE_INT_FLAG\t\t0x01\n#define VIA_REG_OFFSET_TABLE_PTR\t0x04\t \n#define VIA_REG_OFFSET_CURR_PTR\t\t0x04\t \n#define VIA_REG_OFFSET_STOP_IDX\t\t0x08\t \n#define VIA_REG_OFFSET_CURR_COUNT\t0x0c\t \n#define VIA_REG_OFFSET_CURR_INDEX\t0x0f\t \n\n#define DEFINE_VIA_REGSET(name,val) \\\nenum {\\\n\tVIA_REG_##name##_STATUS\t\t= (val),\\\n\tVIA_REG_##name##_CONTROL\t= (val) + 0x01,\\\n\tVIA_REG_##name##_TYPE\t\t= (val) + 0x02,\\\n\tVIA_REG_##name##_TABLE_PTR\t= (val) + 0x04,\\\n\tVIA_REG_##name##_CURR_PTR\t= (val) + 0x04,\\\n\tVIA_REG_##name##_STOP_IDX\t= (val) + 0x08,\\\n\tVIA_REG_##name##_CURR_COUNT\t= (val) + 0x0c,\\\n}\n\n \nDEFINE_VIA_REGSET(MO, 0x40);\nDEFINE_VIA_REGSET(MI, 0x50);\n\n \n#define VIA_REG_AC97\t\t\t0x80\t \n#define   VIA_REG_AC97_CODEC_ID_MASK\t(3<<30)\n#define   VIA_REG_AC97_CODEC_ID_SHIFT\t30\n#define   VIA_REG_AC97_CODEC_ID_PRIMARY\t0x00\n#define   VIA_REG_AC97_CODEC_ID_SECONDARY 0x01\n#define   VIA_REG_AC97_SECONDARY_VALID\t(1<<27)\n#define   VIA_REG_AC97_PRIMARY_VALID\t(1<<25)\n#define   VIA_REG_AC97_BUSY\t\t(1<<24)\n#define   VIA_REG_AC97_READ\t\t(1<<23)\n#define   VIA_REG_AC97_CMD_SHIFT\t16\n#define   VIA_REG_AC97_CMD_MASK\t\t0x7e\n#define   VIA_REG_AC97_DATA_SHIFT\t0\n#define   VIA_REG_AC97_DATA_MASK\t0xffff\n\n#define VIA_REG_SGD_SHADOW\t\t0x84\t \n#define   VIA_REG_SGD_STAT_PB_FLAG\t(1<<0)\n#define   VIA_REG_SGD_STAT_CP_FLAG\t(1<<1)\n#define   VIA_REG_SGD_STAT_FM_FLAG\t(1<<2)\n#define   VIA_REG_SGD_STAT_PB_EOL\t(1<<4)\n#define   VIA_REG_SGD_STAT_CP_EOL\t(1<<5)\n#define   VIA_REG_SGD_STAT_FM_EOL\t(1<<6)\n#define   VIA_REG_SGD_STAT_PB_STOP\t(1<<8)\n#define   VIA_REG_SGD_STAT_CP_STOP\t(1<<9)\n#define   VIA_REG_SGD_STAT_FM_STOP\t(1<<10)\n#define   VIA_REG_SGD_STAT_PB_ACTIVE\t(1<<12)\n#define   VIA_REG_SGD_STAT_CP_ACTIVE\t(1<<13)\n#define   VIA_REG_SGD_STAT_FM_ACTIVE\t(1<<14)\n#define   VIA_REG_SGD_STAT_MR_FLAG      (1<<16)\n#define   VIA_REG_SGD_STAT_MW_FLAG      (1<<17)\n#define   VIA_REG_SGD_STAT_MR_EOL       (1<<20)\n#define   VIA_REG_SGD_STAT_MW_EOL       (1<<21)\n#define   VIA_REG_SGD_STAT_MR_STOP      (1<<24)\n#define   VIA_REG_SGD_STAT_MW_STOP      (1<<25)\n#define   VIA_REG_SGD_STAT_MR_ACTIVE    (1<<28)\n#define   VIA_REG_SGD_STAT_MW_ACTIVE    (1<<29)\n\n#define VIA_REG_GPI_STATUS\t\t0x88\n#define VIA_REG_GPI_INTR\t\t0x8c\n\n#define VIA_TBL_BIT_FLAG\t0x40000000\n#define VIA_TBL_BIT_EOL\t\t0x80000000\n\n \n#define VIA_ACLINK_STAT\t\t0x40\n#define  VIA_ACLINK_C11_READY\t0x20\n#define  VIA_ACLINK_C10_READY\t0x10\n#define  VIA_ACLINK_C01_READY\t0x04  \n#define  VIA_ACLINK_LOWPOWER\t0x02  \n#define  VIA_ACLINK_C00_READY\t0x01  \n#define VIA_ACLINK_CTRL\t\t0x41\n#define  VIA_ACLINK_CTRL_ENABLE\t0x80  \n#define  VIA_ACLINK_CTRL_RESET\t0x40  \n#define  VIA_ACLINK_CTRL_SYNC\t0x20  \n#define  VIA_ACLINK_CTRL_SDO\t0x10  \n#define  VIA_ACLINK_CTRL_VRA\t0x08  \n#define  VIA_ACLINK_CTRL_PCM\t0x04  \n#define  VIA_ACLINK_CTRL_FM\t0x02  \n#define  VIA_ACLINK_CTRL_SB\t0x01  \n#define  VIA_ACLINK_CTRL_INIT\t(VIA_ACLINK_CTRL_ENABLE|\\\n\t\t\t\t VIA_ACLINK_CTRL_RESET|\\\n\t\t\t\t VIA_ACLINK_CTRL_PCM)\n#define VIA_FUNC_ENABLE\t\t0x42\n#define  VIA_FUNC_MIDI_PNP\t0x80  \n#define  VIA_FUNC_MIDI_IRQMASK\t0x40  \n#define  VIA_FUNC_RX2C_WRITE\t0x20\n#define  VIA_FUNC_SB_FIFO_EMPTY\t0x10\n#define  VIA_FUNC_ENABLE_GAME\t0x08\n#define  VIA_FUNC_ENABLE_FM\t0x04\n#define  VIA_FUNC_ENABLE_MIDI\t0x02\n#define  VIA_FUNC_ENABLE_SB\t0x01\n#define VIA_PNP_CONTROL\t\t0x43\n#define VIA_MC97_CTRL\t\t0x44\n#define  VIA_MC97_CTRL_ENABLE   0x80\n#define  VIA_MC97_CTRL_SECONDARY 0x40\n#define  VIA_MC97_CTRL_INIT     (VIA_MC97_CTRL_ENABLE|\\\n                                 VIA_MC97_CTRL_SECONDARY)\n\n\n \n\nstruct snd_via_sg_table {\n\tunsigned int offset;\n\tunsigned int size;\n} ;\n\n#define VIA_TABLE_SIZE\t255\n\nstruct viadev {\n\tunsigned int reg_offset;\n\tunsigned long port;\n\tint direction;\t \n        struct snd_pcm_substream *substream;\n\tint running;\n\tunsigned int tbl_entries;  \n\tstruct snd_dma_buffer table;\n\tstruct snd_via_sg_table *idx_table;\n\t \n\tunsigned int lastpos;\n\tunsigned int bufsize;\n\tunsigned int bufsize2;\n};\n\nenum { TYPE_CARD_VIA82XX_MODEM = 1 };\n\n#define VIA_MAX_MODEM_DEVS\t2\n\nstruct via82xx_modem {\n\tint irq;\n\n\tunsigned long port;\n\n\tunsigned int intr_mask;  \n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\n\tunsigned int num_devs;\n\tunsigned int playback_devno, capture_devno;\n\tstruct viadev devs[VIA_MAX_MODEM_DEVS];\n\n\tstruct snd_pcm *pcms[2];\n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\tunsigned int ac97_clock;\n\tunsigned int ac97_secondary;\t \n\n\tspinlock_t reg_lock;\n\tstruct snd_info_entry *proc_entry;\n};\n\nstatic const struct pci_device_id snd_via82xx_modem_ids[] = {\n\t{ PCI_VDEVICE(VIA, 0x3068), TYPE_CARD_VIA82XX_MODEM, },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_via82xx_modem_ids);\n\n \n\n \nstatic int build_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\n\t\t\t   struct pci_dev *pci,\n\t\t\t   unsigned int periods, unsigned int fragsize)\n{\n\tunsigned int i, idx, ofs, rest;\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\t__le32 *pgtbl;\n\n\tif (dev->table.area == NULL) {\n\t\t \n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t\tPAGE_ALIGN(VIA_TABLE_SIZE * 2 * 8),\n\t\t\t\t\t&dev->table) < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (! dev->idx_table) {\n\t\tdev->idx_table = kmalloc_array(VIA_TABLE_SIZE,\n\t\t\t\t\t       sizeof(*dev->idx_table),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (! dev->idx_table)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tidx = 0;\n\tofs = 0;\n\tpgtbl = (__le32 *)dev->table.area;\n\tfor (i = 0; i < periods; i++) {\n\t\trest = fragsize;\n\t\t \n\t\tdo {\n\t\t\tunsigned int r;\n\t\t\tunsigned int flag;\n\t\t\tunsigned int addr;\n\n\t\t\tif (idx >= VIA_TABLE_SIZE) {\n\t\t\t\tdev_err(&pci->dev, \"too much table size!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\taddr = snd_pcm_sgbuf_get_addr(substream, ofs);\n\t\t\tpgtbl[idx << 1] = cpu_to_le32(addr);\n\t\t\tr = PAGE_SIZE - (ofs % PAGE_SIZE);\n\t\t\tif (rest < r)\n\t\t\t\tr = rest;\n\t\t\trest -= r;\n\t\t\tif (! rest) {\n\t\t\t\tif (i == periods - 1)\n\t\t\t\t\tflag = VIA_TBL_BIT_EOL;  \n\t\t\t\telse\n\t\t\t\t\tflag = VIA_TBL_BIT_FLAG;  \n\t\t\t} else\n\t\t\t\tflag = 0;  \n\t\t\t \n\t\t\tpgtbl[(idx<<1) + 1] = cpu_to_le32(r | flag);\n\t\t\tdev->idx_table[idx].offset = ofs;\n\t\t\tdev->idx_table[idx].size = r;\n\t\t\tofs += r;\n\t\t\tidx++;\n\t\t} while (rest > 0);\n\t}\n\tdev->tbl_entries = idx;\n\tdev->bufsize = periods * fragsize;\n\tdev->bufsize2 = dev->bufsize / 2;\n\treturn 0;\n}\n\n\nstatic int clean_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\n\t\t\t   struct pci_dev *pci)\n{\n\tif (dev->table.area) {\n\t\tsnd_dma_free_pages(&dev->table);\n\t\tdev->table.area = NULL;\n\t}\n\tkfree(dev->idx_table);\n\tdev->idx_table = NULL;\n\treturn 0;\n}\n\n \n\nstatic inline unsigned int snd_via82xx_codec_xread(struct via82xx_modem *chip)\n{\n\treturn inl(VIAREG(chip, AC97));\n}\n \nstatic inline void snd_via82xx_codec_xwrite(struct via82xx_modem *chip, unsigned int val)\n{\n\toutl(val, VIAREG(chip, AC97));\n}\n \nstatic int snd_via82xx_codec_ready(struct via82xx_modem *chip, int secondary)\n{\n\tunsigned int timeout = 1000;\t \n\tunsigned int val;\n\t\n\twhile (timeout-- > 0) {\n\t\tudelay(1);\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tif (!(val & VIA_REG_AC97_BUSY))\n\t\t\treturn val & 0xffff;\n\t}\n\tdev_err(chip->card->dev, \"codec_ready: codec %i is not ready [0x%x]\\n\",\n\t\t   secondary, snd_via82xx_codec_xread(chip));\n\treturn -EIO;\n}\n \nstatic int snd_via82xx_codec_valid(struct via82xx_modem *chip, int secondary)\n{\n\tunsigned int timeout = 1000;\t \n\tunsigned int val, val1;\n\tunsigned int stat = !secondary ? VIA_REG_AC97_PRIMARY_VALID :\n\t\t\t\t\t VIA_REG_AC97_SECONDARY_VALID;\n\t\n\twhile (timeout-- > 0) {\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tval1 = val & (VIA_REG_AC97_BUSY | stat);\n\t\tif (val1 == stat)\n\t\t\treturn val & 0xffff;\n\t\tudelay(1);\n\t}\n\treturn -EIO;\n}\n \nstatic void snd_via82xx_codec_wait(struct snd_ac97 *ac97)\n{\n\tstruct via82xx_modem *chip = ac97->private_data;\n\t__always_unused int err;\n\terr = snd_via82xx_codec_ready(chip, ac97->num);\n\t \n\tmsleep(500);\n}\n\nstatic void snd_via82xx_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t    unsigned short reg,\n\t\t\t\t    unsigned short val)\n{\n\tstruct via82xx_modem *chip = ac97->private_data;\n\tunsigned int xval;\n\tif(reg == AC97_GPIO_STATUS) {\n\t\toutl(val, VIAREG(chip, GPI_STATUS));\n\t\treturn;\n\t}\t\n\txval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;\n\txval <<= VIA_REG_AC97_CODEC_ID_SHIFT;\n\txval |= reg << VIA_REG_AC97_CMD_SHIFT;\n\txval |= val << VIA_REG_AC97_DATA_SHIFT;\n\tsnd_via82xx_codec_xwrite(chip, xval);\n\tsnd_via82xx_codec_ready(chip, ac97->num);\n}\n\nstatic unsigned short snd_via82xx_codec_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tstruct via82xx_modem *chip = ac97->private_data;\n\tunsigned int xval, val = 0xffff;\n\tint again = 0;\n\n\txval = ac97->num << VIA_REG_AC97_CODEC_ID_SHIFT;\n\txval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;\n\txval |= VIA_REG_AC97_READ;\n\txval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;\n      \twhile (1) {\n      \t\tif (again++ > 3) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_read: codec %i is not valid [0x%x]\\n\",\n\t\t\t\t   ac97->num, snd_via82xx_codec_xread(chip));\n\t\t      \treturn 0xffff;\n\t\t}\n\t\tsnd_via82xx_codec_xwrite(chip, xval);\n\t\tudelay (20);\n\t\tif (snd_via82xx_codec_valid(chip, ac97->num) >= 0) {\n\t\t\tudelay(25);\n\t\t\tval = snd_via82xx_codec_xread(chip);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn val & 0xffff;\n}\n\nstatic void snd_via82xx_channel_reset(struct via82xx_modem *chip, struct viadev *viadev)\n{\n\toutb(VIA_REG_CTRL_PAUSE | VIA_REG_CTRL_TERMINATE | VIA_REG_CTRL_RESET,\n\t     VIADEV_REG(viadev, OFFSET_CONTROL));\n\tinb(VIADEV_REG(viadev, OFFSET_CONTROL));\n\tudelay(50);\n\t \n\toutb(0x00, VIADEV_REG(viadev, OFFSET_CONTROL));\n\t \n\toutb(0x03, VIADEV_REG(viadev, OFFSET_STATUS));\n\toutb(0x00, VIADEV_REG(viadev, OFFSET_TYPE));  \n\t\n\tviadev->lastpos = 0;\n}\n\n\n \n\nstatic irqreturn_t snd_via82xx_interrupt(int irq, void *dev_id)\n{\n\tstruct via82xx_modem *chip = dev_id;\n\tunsigned int status;\n\tunsigned int i;\n\n\tstatus = inl(VIAREG(chip, SGD_SHADOW));\n\tif (! (status & chip->intr_mask)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\n\t \n\tspin_lock(&chip->reg_lock);\n\tfor (i = 0; i < chip->num_devs; i++) {\n\t\tstruct viadev *viadev = &chip->devs[i];\n\t\tunsigned char c_status = inb(VIADEV_REG(viadev, OFFSET_STATUS));\n\t\tc_status &= (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG|VIA_REG_STAT_STOPPED);\n\t\tif (! c_status)\n\t\t\tcontinue;\n\t\tif (viadev->substream && viadev->running) {\n\t\t\tspin_unlock(&chip->reg_lock);\n\t\t\tsnd_pcm_period_elapsed(viadev->substream);\n\t\t\tspin_lock(&chip->reg_lock);\n\t\t}\n\t\toutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));  \n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int snd_via82xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned char val = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval |= VIA_REG_CTRL_START;\n\t\tviadev->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tval = VIA_REG_CTRL_TERMINATE;\n\t\tviadev->running = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval |= VIA_REG_CTRL_PAUSE;\n\t\tviadev->running = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tviadev->running = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\toutb(val, VIADEV_REG(viadev, OFFSET_CONTROL));\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP)\n\t\tsnd_via82xx_channel_reset(chip, viadev);\n\treturn 0;\n}\n\n \n\n \n\n#define check_invalid_pos(viadev,pos) \\\n\t((pos) < viadev->lastpos && ((pos) >= viadev->bufsize2 ||\\\n\t\t\t\t     viadev->lastpos < viadev->bufsize2))\n\nstatic inline unsigned int calc_linear_pos(struct via82xx_modem *chip,\n\t\t\t\t\t   struct viadev *viadev,\n\t\t\t\t\t   unsigned int idx,\n\t\t\t\t\t   unsigned int count)\n{\n\tunsigned int size, res;\n\n\tsize = viadev->idx_table[idx].size;\n\tres = viadev->idx_table[idx].offset + size - count;\n\n\t \n\tif (size < count) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"invalid via82xx_cur_ptr (size = %d, count = %d)\\n\",\n\t\t\t   (int)size, (int)count);\n\t\tres = viadev->lastpos;\n\t} else if (check_invalid_pos(viadev, res)) {\n#ifdef POINTER_DEBUG\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"fail: idx = %i/%i, lastpos = 0x%x, bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, count = 0x%x\\n\",\n\t\t\tidx, viadev->tbl_entries, viadev->lastpos,\n\t\t       viadev->bufsize2, viadev->idx_table[idx].offset,\n\t\t       viadev->idx_table[idx].size, count);\n#endif\n\t\tif (count && size < count) {\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"invalid via82xx_cur_ptr, using last valid pointer\\n\");\n\t\t\tres = viadev->lastpos;\n\t\t} else {\n\t\t\tif (! count)\n\t\t\t\t \n\t\t\t\tres = viadev->idx_table[idx].offset;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tres = viadev->idx_table[idx].offset + size;\n\t\t\tif (check_invalid_pos(viadev, res)) {\n\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\"invalid via82xx_cur_ptr (2), using last valid pointer\\n\");\n\t\t\t\tres = viadev->lastpos;\n\t\t\t}\n\t\t}\n\t}\n\tviadev->lastpos = res;  \n\tif (res >= viadev->bufsize)\n\t\tres -= viadev->bufsize;\n\treturn res;\n}\n\n \nstatic snd_pcm_uframes_t snd_via686_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tunsigned int idx, ptr, count, res;\n\n\tif (snd_BUG_ON(!viadev->tbl_entries))\n\t\treturn 0;\n\tif (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))\n\t\treturn 0;\n\n\tspin_lock(&chip->reg_lock);\n\tcount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT)) & 0xffffff;\n\t \n\tptr = inl(VIADEV_REG(viadev, OFFSET_CURR_PTR));\n\tif (ptr <= (unsigned int)viadev->table.addr)\n\t\tidx = 0;\n\telse  \n\t\tidx = ((ptr - (unsigned int)viadev->table.addr) / 8 - 1) %\n\t\t\tviadev->tbl_entries;\n\tres = calc_linear_pos(chip, viadev, idx, count);\n\tspin_unlock(&chip->reg_lock);\n\n\treturn bytes_to_frames(substream->runtime, res);\n}\n\n \nstatic int snd_via82xx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\tint err;\n\n\terr = build_via_table(viadev, substream, chip->pci,\n\t\t\t      params_periods(hw_params),\n\t\t\t      params_period_bytes(hw_params));\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_ac97_write(chip->ac97, AC97_LINE1_RATE, params_rate(hw_params));\n\tsnd_ac97_write(chip->ac97, AC97_LINE1_LEVEL, 0);\n\n\treturn 0;\n}\n\n \nstatic int snd_via82xx_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\n\tclean_via_table(viadev, substream, chip->pci);\n\treturn 0;\n}\n\n\n \nstatic void snd_via82xx_set_table_ptr(struct via82xx_modem *chip, struct viadev *viadev)\n{\n\tsnd_via82xx_codec_ready(chip, chip->ac97_secondary);\n\toutl((u32)viadev->table.addr, VIADEV_REG(viadev, OFFSET_TABLE_PTR));\n\tudelay(20);\n\tsnd_via82xx_codec_ready(chip, chip->ac97_secondary);\n}\n\n \nstatic int snd_via82xx_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = substream->runtime->private_data;\n\n\tsnd_via82xx_channel_reset(chip, viadev);\n\t \n\tsnd_via82xx_set_table_ptr(chip, viadev);\n\toutb(VIA_REG_TYPE_AUTOSTART|VIA_REG_TYPE_INT_EOL|VIA_REG_TYPE_INT_FLAG,\n\t     VIADEV_REG(viadev, OFFSET_TYPE));\n\treturn 0;\n}\n\n \nstatic const struct snd_pcm_hardware snd_via82xx_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  \n\t\t\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_KNOT,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t16000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t1,\n\t.buffer_bytes_max =\t128 * 1024,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t128 * 1024,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tVIA_TABLE_SIZE / 2,\n\t.fifo_size =\t\t0,\n};\n\n\n \nstatic int snd_via82xx_modem_pcm_open(struct via82xx_modem *chip, struct viadev *viadev,\n\t\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tstatic const unsigned int rates[] = { 8000,  9600, 12000, 16000 };\n\tstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n                .count = ARRAY_SIZE(rates),\n                .list = rates,\n                .mask = 0,\n        };\n\n\truntime->hw = snd_via82xx_hw;\n\t\n\terr = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t &hw_constraints_rates);\n\tif (err < 0)\n                return err;\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\truntime->private_data = viadev;\n\tviadev->substream = substream;\n\n\treturn 0;\n}\n\n\n \nstatic int snd_via82xx_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];\n\n\treturn snd_via82xx_modem_pcm_open(chip, viadev, substream);\n}\n\n \nstatic int snd_via82xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\n\tstruct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];\n\n\treturn snd_via82xx_modem_pcm_open(chip, viadev, substream);\n}\n\n \nstatic int snd_via82xx_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct viadev *viadev = substream->runtime->private_data;\n\n\tviadev->substream = NULL;\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_ops snd_via686_playback_ops = {\n\t.open =\t\tsnd_via82xx_playback_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via82xx_pcm_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via686_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_via686_capture_ops = {\n\t.open =\t\tsnd_via82xx_capture_open,\n\t.close =\tsnd_via82xx_pcm_close,\n\t.hw_params =\tsnd_via82xx_hw_params,\n\t.hw_free =\tsnd_via82xx_hw_free,\n\t.prepare =\tsnd_via82xx_pcm_prepare,\n\t.trigger =\tsnd_via82xx_pcm_trigger,\n\t.pointer =\tsnd_via686_pcm_pointer,\n};\n\n\nstatic void init_viadev(struct via82xx_modem *chip, int idx, unsigned int reg_offset,\n\t\t\tint direction)\n{\n\tchip->devs[idx].reg_offset = reg_offset;\n\tchip->devs[idx].direction = direction;\n\tchip->devs[idx].port = chip->port + reg_offset;\n}\n\n \nstatic int snd_via686_pcm_new(struct via82xx_modem *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tchip->playback_devno = 0;\n\tchip->capture_devno = 1;\n\tchip->num_devs = 2;\n\tchip->intr_mask = 0x330000;  \n\n\terr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via686_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via686_capture_ops);\n\tpcm->dev_class = SNDRV_PCM_CLASS_MODEM;\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcms[0] = pcm;\n\tinit_viadev(chip, 0, VIA_REG_MO_STATUS, 0);\n\tinit_viadev(chip, 1, VIA_REG_MI_STATUS, 1);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t       &chip->pci->dev, 64*1024, 128*1024);\n\treturn 0;\n}\n\n\n \n\n\nstatic void snd_via82xx_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct via82xx_modem *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_via82xx_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct via82xx_modem *chip = ac97->private_data;\n\tchip->ac97 = NULL;\n}\n\n\nstatic int snd_via82xx_mixer_new(struct via82xx_modem *chip)\n{\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_via82xx_codec_write,\n\t\t.read = snd_via82xx_codec_read,\n\t\t.wait = snd_via82xx_codec_wait,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\tchip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;\n\tchip->ac97_bus->clock = chip->ac97_clock;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_via82xx_mixer_free_ac97;\n\tac97.pci = chip->pci;\n\tac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;\n\tac97.num = chip->ac97_secondary;\n\n\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n \nstatic void snd_via82xx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct via82xx_modem *chip = entry->private_data;\n\tint i;\n\t\n\tsnd_iprintf(buffer, \"%s\\n\\n\", chip->card->longname);\n\tfor (i = 0; i < 0xa0; i += 4) {\n\t\tsnd_iprintf(buffer, \"%02x: %08x\\n\", i, inl(chip->port + i));\n\t}\n}\n\nstatic void snd_via82xx_proc_init(struct via82xx_modem *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"via82xx\", chip,\n\t\t\t     snd_via82xx_proc_read);\n}\n\n \n\nstatic int snd_via82xx_chip_init(struct via82xx_modem *chip)\n{\n\tunsigned int val;\n\tunsigned long end_time;\n\tunsigned char pval;\n\n\tpci_read_config_byte(chip->pci, VIA_MC97_CTRL, &pval);\n\tif((pval & VIA_MC97_CTRL_INIT) != VIA_MC97_CTRL_INIT) {\n\t\tpci_write_config_byte(chip->pci, 0x44, pval|VIA_MC97_CTRL_INIT);\n\t\tudelay(100);\n\t}\n\n\tpci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\n\tif (! (pval & VIA_ACLINK_C00_READY)) {  \n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\n\t\t\t\t      VIA_ACLINK_CTRL_ENABLE |\n\t\t\t\t      VIA_ACLINK_CTRL_RESET |\n\t\t\t\t      VIA_ACLINK_CTRL_SYNC);\n\t\tudelay(100);\n#if 1  \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);\n\t\tudelay(100);\n#else\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\n\t\t\t\t      VIA_ACLINK_CTRL_RESET|VIA_ACLINK_CTRL_SYNC);\n\t\tudelay(2);\n#endif\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\n\t\tudelay(100);\n\t}\n\t\n\tpci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);\n\tif ((pval & VIA_ACLINK_CTRL_INIT) != VIA_ACLINK_CTRL_INIT) {\n\t\t \n\t\tpci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\n\t\tudelay(100);\n\t}\n\n\t \n\tend_time = jiffies + msecs_to_jiffies(750);\n\tdo {\n\t\tpci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\n\t\tif (pval & VIA_ACLINK_C00_READY)  \n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\n\tval = snd_via82xx_codec_xread(chip);\n\tif (val & VIA_REG_AC97_BUSY)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"AC'97 codec is not ready [0x%x]\\n\", val);\n\n\tsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\n\t\t\t\t VIA_REG_AC97_SECONDARY_VALID |\n\t\t\t\t (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\n\tend_time = jiffies + msecs_to_jiffies(750);\n\tsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\n\t\t\t\t VIA_REG_AC97_SECONDARY_VALID |\n\t\t\t\t (VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\n\tdo {\n\t\tval = snd_via82xx_codec_xread(chip);\n\t\tif (val & VIA_REG_AC97_SECONDARY_VALID) {\n\t\t\tchip->ac97_secondary = 1;\n\t\t\tgoto __ac97_ok2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before(jiffies, end_time));\n\t \n\n      __ac97_ok2:\n\n\t \n\t \n\t \n\toutl(0, VIAREG(chip, GPI_INTR));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int snd_via82xx_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct via82xx_modem *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\tsnd_ac97_suspend(chip->ac97);\n\treturn 0;\n}\n\nstatic int snd_via82xx_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct via82xx_modem *chip = card->private_data;\n\tint i;\n\n\tsnd_via82xx_chip_init(chip);\n\n\tsnd_ac97_resume(chip->ac97);\n\n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_via82xx_pm, snd_via82xx_suspend, snd_via82xx_resume);\n#define SND_VIA82XX_PM_OPS\t&snd_via82xx_pm\n#else\n#define SND_VIA82XX_PM_OPS\tNULL\n#endif  \n\nstatic void snd_via82xx_free(struct snd_card *card)\n{\n\tstruct via82xx_modem *chip = card->private_data;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n}\n\nstatic int snd_via82xx_create(struct snd_card *card,\n\t\t\t      struct pci_dev *pci,\n\t\t\t      int chip_type,\n\t\t\t      int revision,\n\t\t\t      unsigned int ac97_clock)\n{\n\tstruct via82xx_modem *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\terr = pci_request_regions(pci, card->driver);\n\tif (err < 0)\n\t\treturn err;\n\tchip->port = pci_resource_start(pci, 0);\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_via82xx_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_via82xx_free;\n\tif (ac97_clock >= 8000 && ac97_clock <= 48000)\n\t\tchip->ac97_clock = ac97_clock;\n\n\terr = snd_via82xx_chip_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpci_set_master(pci);\n\treturn 0;\n}\n\n\nstatic int __snd_via82xx_probe(struct pci_dev *pci,\n\t\t\t       const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct via82xx_modem *chip;\n\tint chip_type = 0, card_type;\n\tunsigned int i;\n\tint err;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tcard_type = pci_id->driver_data;\n\tswitch (card_type) {\n\tcase TYPE_CARD_VIA82XX_MODEM:\n\t\tstrcpy(card->driver, \"VIA82XX-MODEM\");\n\t\tsprintf(card->shortname, \"VIA 82XX modem\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(card->dev, \"invalid card type %d\\n\", card_type);\n\t\treturn -EINVAL;\n\t}\n\t\t\n\terr = snd_via82xx_create(card, pci, chip_type, pci->revision,\n\t\t\t\t ac97_clock);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_via82xx_mixer_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_via686_pcm_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < chip->num_devs; i++)\n\t\tsnd_via82xx_channel_reset(chip, &chip->devs[i]);\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\",\n\t\tcard->shortname, chip->port, chip->irq);\n\n\tsnd_via82xx_proc_init(chip);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_via82xx_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_via82xx_probe(pci, pci_id));\n}\n\nstatic struct pci_driver via82xx_modem_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_via82xx_modem_ids,\n\t.probe = snd_via82xx_probe,\n\t.driver = {\n\t\t.pm = SND_VIA82XX_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(via82xx_modem_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}