{
  "module_name": "dsp_spos_scb_lib.c",
  "hash_id": "c18a7b4c3fa6b9c6671c23f28eb226cb7196da5aac959c6f7b40839cc611910e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs46xx/dsp_spos_scb_lib.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include \"cs46xx.h\"\n\n#include \"cs46xx_lib.h\"\n#include \"dsp_spos.h\"\n\nstruct proc_scb_info {\n\tstruct dsp_scb_descriptor * scb_desc;\n\tstruct snd_cs46xx *chip;\n};\n\nstatic void remove_symbol (struct snd_cs46xx * chip, struct dsp_symbol_entry * symbol)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint symbol_index = (int)(symbol - ins->symbol_table.symbols);\n\n\tif (snd_BUG_ON(ins->symbol_table.nsymbols <= 0))\n\t\treturn;\n\tif (snd_BUG_ON(symbol_index < 0 ||\n\t\t       symbol_index >= ins->symbol_table.nsymbols))\n\t\treturn;\n\n\tins->symbol_table.symbols[symbol_index].deleted = 1;\n\n\tif (symbol_index < ins->symbol_table.highest_frag_index) {\n\t\tins->symbol_table.highest_frag_index = symbol_index;\n\t}\n  \n\tif (symbol_index == ins->symbol_table.nsymbols - 1)\n\t\tins->symbol_table.nsymbols --;\n\n\tif (ins->symbol_table.highest_frag_index > ins->symbol_table.nsymbols) {\n\t\tins->symbol_table.highest_frag_index = ins->symbol_table.nsymbols;\n\t}\n\n}\n\n#ifdef CONFIG_SND_PROC_FS\nstatic void cs46xx_dsp_proc_scb_info_read (struct snd_info_entry *entry,\n\t\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct proc_scb_info * scb_info  = entry->private_data;\n\tstruct dsp_scb_descriptor * scb = scb_info->scb_desc;\n\tstruct snd_cs46xx *chip = scb_info->chip;\n\tint j,col;\n\tvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\n\n\tmutex_lock(&chip->spos_mutex);\n\tsnd_iprintf(buffer,\"%04x %s:\\n\",scb->address,scb->scb_name);\n\n\tfor (col = 0,j = 0;j < 0x10; j++,col++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\t\tsnd_iprintf(buffer,\"%08x \",readl(dst + (scb->address + j) * sizeof(u32)));\n\t}\n  \n\tsnd_iprintf(buffer,\"\\n\");\n\n\tif (scb->parent_scb_ptr != NULL) {\n\t\tsnd_iprintf(buffer,\"parent [%s:%04x] \", \n\t\t\t    scb->parent_scb_ptr->scb_name,\n\t\t\t    scb->parent_scb_ptr->address);\n\t} else snd_iprintf(buffer,\"parent [none] \");\n  \n\tsnd_iprintf(buffer,\"sub_list_ptr [%s:%04x]\\nnext_scb_ptr [%s:%04x]  task_entry [%s:%04x]\\n\",\n\t\t    scb->sub_list_ptr->scb_name,\n\t\t    scb->sub_list_ptr->address,\n\t\t    scb->next_scb_ptr->scb_name,\n\t\t    scb->next_scb_ptr->address,\n\t\t    scb->task_entry->symbol_name,\n\t\t    scb->task_entry->address);\n\n\tsnd_iprintf(buffer,\"index [%d] ref_count [%d]\\n\",scb->index,scb->ref_count);  \n\tmutex_unlock(&chip->spos_mutex);\n}\n#endif\n\nstatic void _dsp_unlink_scb (struct snd_cs46xx *chip, struct dsp_scb_descriptor * scb)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif ( scb->parent_scb_ptr ) {\n\t\t \n\t\tif (snd_BUG_ON(scb->parent_scb_ptr->sub_list_ptr != scb &&\n\t\t\t       scb->parent_scb_ptr->next_scb_ptr != scb))\n\t\t\treturn;\n  \n\t\tif (scb->parent_scb_ptr->sub_list_ptr == scb) {\n\n\t\t\tif (scb->next_scb_ptr == ins->the_null_scb) {\n\t\t\t\t \n\t\t\t\tscb->parent_scb_ptr->sub_list_ptr = scb->sub_list_ptr;\n\n\t\t\t\tif (scb->sub_list_ptr != ins->the_null_scb) {\n\t\t\t\t\tscb->sub_list_ptr->parent_scb_ptr = scb->parent_scb_ptr;\n\t\t\t\t}\n\t\t\t\tscb->sub_list_ptr = ins->the_null_scb;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tscb->parent_scb_ptr->sub_list_ptr = scb->next_scb_ptr;\n\n\t\t\t\tif (scb->next_scb_ptr != ins->the_null_scb) {\n\t\t\t\t\t \n\t\t\t\t\tscb->next_scb_ptr->parent_scb_ptr = scb->parent_scb_ptr;\n\t\t\t\t}\n\t\t\t\tscb->next_scb_ptr = ins->the_null_scb;\n\t\t\t}\n\t\t} else {\n\t\t\tscb->parent_scb_ptr->next_scb_ptr = scb->next_scb_ptr;\n\n\t\t\tif (scb->next_scb_ptr != ins->the_null_scb) {\n\t\t\t\t \n\t\t\t\tscb->next_scb_ptr->parent_scb_ptr = scb->parent_scb_ptr;\n\t\t\t}\n\t\t\tscb->next_scb_ptr = ins->the_null_scb;\n\t\t}\n\n\t\t \n\t\tcs46xx_dsp_spos_update_scb(chip,scb->parent_scb_ptr);\n\n\t\t \n\t\tcs46xx_dsp_spos_update_scb(chip,scb);\n\n\t\tscb->parent_scb_ptr = NULL;\n\t}\n}\n\nstatic void _dsp_clear_sample_buffer (struct snd_cs46xx *chip, u32 sample_buffer_addr,\n\t\t\t\t      int dword_count) \n{\n\tvoid __iomem *dst = chip->region.idx[2].remap_addr + sample_buffer_addr;\n\tint i;\n  \n\tfor (i = 0; i < dword_count ; ++i ) {\n\t\twritel(0, dst);\n\t\tdst += 4;\n\t}  \n}\n\nvoid cs46xx_dsp_remove_scb (struct snd_cs46xx *chip, struct dsp_scb_descriptor * scb)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tunsigned long flags;\n\n\t \n\tif (snd_BUG_ON(scb->index < 0 ||\n\t\t       scb->index >= ins->nscb ||\n\t\t       (ins->scbs + scb->index) != scb))\n\t\treturn;\n\n#if 0\n\t \n\tif (snd_BUG_ON(scb->sub_list_ptr != ins->the_null_scb ||\n\t\t       scb->next_scb_ptr != ins->the_null_scb))\n\t\tgoto _end;\n#endif\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);    \n\t_dsp_unlink_scb (chip,scb);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tcs46xx_dsp_proc_free_scb_desc(scb);\n\tif (snd_BUG_ON(!scb->scb_symbol))\n\t\treturn;\n\tremove_symbol (chip,scb->scb_symbol);\n\n\tins->scbs[scb->index].deleted = 1;\n#ifdef CONFIG_PM_SLEEP\n\tkfree(ins->scbs[scb->index].data);\n\tins->scbs[scb->index].data = NULL;\n#endif\n\n\tif (scb->index < ins->scb_highest_frag_index)\n\t\tins->scb_highest_frag_index = scb->index;\n\n\tif (scb->index == ins->nscb - 1) {\n\t\tins->nscb --;\n\t}\n\n\tif (ins->scb_highest_frag_index > ins->nscb) {\n\t\tins->scb_highest_frag_index = ins->nscb;\n\t}\n\n#if 0\n\t \n\tfor(i = scb->index + 1;i < ins->nscb; ++i) {\n\t\tins->scbs[i - 1].index = i - 1;\n\t}\n#endif\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\nvoid cs46xx_dsp_proc_free_scb_desc (struct dsp_scb_descriptor * scb)\n{\n\tif (scb->proc_info) {\n\t\tstruct proc_scb_info * scb_info = scb->proc_info->private_data;\n\t\tstruct snd_cs46xx *chip = scb_info->chip;\n\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"cs46xx_dsp_proc_free_scb_desc: freeing %s\\n\",\n\t\t\tscb->scb_name);\n\n\t\tsnd_info_free_entry(scb->proc_info);\n\t\tscb->proc_info = NULL;\n\n\t\tkfree (scb_info);\n\t}\n}\n\nvoid cs46xx_dsp_proc_register_scb_desc (struct snd_cs46xx *chip,\n\t\t\t\t\tstruct dsp_scb_descriptor * scb)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct snd_info_entry * entry;\n\tstruct proc_scb_info * scb_info;\n\n\t \n\tif (ins->snd_card != NULL && ins->proc_dsp_dir != NULL &&\n\t    scb->proc_info == NULL) {\n  \n\t\tentry = snd_info_create_card_entry(ins->snd_card, scb->scb_name,\n\t\t\t\t\t\t   ins->proc_dsp_dir);\n\t\tif (entry) {\n\t\t\tscb_info = kmalloc(sizeof(struct proc_scb_info), GFP_KERNEL);\n\t\t\tif (!scb_info) {\n\t\t\t\tsnd_info_free_entry(entry);\n\t\t\t\tentry = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tscb_info->chip = chip;\n\t\t\tscb_info->scb_desc = scb;\n\t\t\tsnd_info_set_text_ops(entry, scb_info,\n\t\t\t\t\t      cs46xx_dsp_proc_scb_info_read);\n\t\t}\nout:\n\t\tscb->proc_info = entry;\n\t}\n}\n#endif  \n\nstatic struct dsp_scb_descriptor * \n_dsp_create_generic_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest,\n                         struct dsp_symbol_entry * task_entry,\n                         struct dsp_scb_descriptor * parent_scb,\n                         int scb_child_type)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb;\n  \n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!ins->the_null_scb))\n\t\treturn NULL;\n\n\t \n\tscb_data[SCBsubListPtr] = \n\t\t(ins->the_null_scb->address << 0x10) | ins->the_null_scb->address;\n\n\tscb_data[SCBfuncEntryPtr] &= 0xFFFF0000;\n\tscb_data[SCBfuncEntryPtr] |= task_entry->address;\n\n\tdev_dbg(chip->card->dev, \"dsp_spos: creating SCB <%s>\\n\", name);\n\n\tscb = cs46xx_dsp_create_scb(chip,name,scb_data,dest);\n\n\n\tscb->sub_list_ptr = ins->the_null_scb;\n\tscb->next_scb_ptr = ins->the_null_scb;\n\n\tscb->parent_scb_ptr = parent_scb;\n\tscb->task_entry = task_entry;\n\n  \n\t \n\tif (scb->parent_scb_ptr) {\n#if 0\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"scb->parent_scb_ptr = %s\\n\",\n\t\t\tscb->parent_scb_ptr->scb_name);\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"scb->parent_scb_ptr->next_scb_ptr = %s\\n\",\n\t\t\tscb->parent_scb_ptr->next_scb_ptr->scb_name);\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"scb->parent_scb_ptr->sub_list_ptr = %s\\n\",\n\t\t\tscb->parent_scb_ptr->sub_list_ptr->scb_name);\n#endif\n\t\t \n\t\tif (scb_child_type == SCB_ON_PARENT_NEXT_SCB) {\n\t\t\tif (snd_BUG_ON(scb->parent_scb_ptr->next_scb_ptr !=\n\t\t\t\t       ins->the_null_scb))\n\t\t\t\treturn NULL;\n\n\t\t\tscb->parent_scb_ptr->next_scb_ptr = scb;\n\n\t\t} else if (scb_child_type == SCB_ON_PARENT_SUBLIST_SCB) {\n\t\t\tif (snd_BUG_ON(scb->parent_scb_ptr->sub_list_ptr !=\n\t\t\t\t       ins->the_null_scb))\n\t\t\t\treturn NULL;\n\n\t\t\tscb->parent_scb_ptr->sub_list_ptr = scb;\n\t\t} else {\n\t\t\tsnd_BUG();\n\t\t}\n\n\t\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\t\t \n\t\tcs46xx_dsp_spos_update_scb(chip,scb->parent_scb_ptr);\n\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t}\n\n\n\tcs46xx_dsp_proc_register_scb_desc (chip,scb);\n\n\treturn scb;\n}\n\nstatic struct dsp_scb_descriptor * \ncs46xx_dsp_create_generic_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data,\n\t\t\t       u32 dest, char * task_entry_name,\n                               struct dsp_scb_descriptor * parent_scb,\n                               int scb_child_type)\n{\n\tstruct dsp_symbol_entry * task_entry;\n\n\ttask_entry = cs46xx_dsp_lookup_symbol (chip,task_entry_name,\n\t\t\t\t\t       SYMBOL_CODE);\n  \n\tif (task_entry == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol %s not found\\n\", task_entry_name);\n\t\treturn NULL;\n\t}\n  \n\treturn _dsp_create_generic_scb (chip,name,scb_data,dest,task_entry,\n\t\t\t\t\tparent_scb,scb_child_type);\n}\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_timing_master_scb (struct snd_cs46xx *chip)\n{\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_timing_master_scb timing_master_scb = {\n\t\t{ 0,\n\t\t  0,\n\t\t  0,\n\t\t  0\n\t\t},\n\t\t{ 0,\n\t\t  0,\n\t\t  0,\n\t\t  0,\n\t\t  0\n\t\t},\n\t\t0,0,\n\t\t0,NULL_SCB_ADDR,\n\t\t0,0,              \n\t\t0,0,              \n\t\t0x0001,0x8000,    \n\t\t0x0001,0x0000,    \n\t\t0x00060000        \n\t};    \n  \n\tscb = cs46xx_dsp_create_generic_scb(chip,\"TimingMasterSCBInst\",(u32 *)&timing_master_scb,\n\t\t\t\t\t    TIMINGMASTER_SCB_ADDR,\n\t\t\t\t\t    \"TIMINGMASTER\",NULL,SCB_NO_PARENT);\n\n\treturn scb;\n}\n\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_codec_out_scb(struct snd_cs46xx * chip, char * codec_name,\n                                u16 channel_disp, u16 fifo_addr, u16 child_scb_addr,\n                                u32 dest, struct dsp_scb_descriptor * parent_scb,\n                                int scb_child_type)\n{\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_codec_output_scb codec_out_scb = {\n\t\t{ 0,\n\t\t  0,\n\t\t  0,\n\t\t  0\n\t\t},\n\t\t{\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t},\n\t\t0,0,\n\t\t0,NULL_SCB_ADDR,\n\t\t0,                       \n\t\t0,                       \n\t\tchannel_disp,fifo_addr,  \n\t\t0x0000,0x0080,           \n\t\t0,child_scb_addr         \n\t};\n  \n  \n\tscb = cs46xx_dsp_create_generic_scb(chip,codec_name,(u32 *)&codec_out_scb,\n\t\t\t\t\t    dest,\"S16_CODECOUTPUTTASK\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n  \n\treturn scb;\n}\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_codec_in_scb(struct snd_cs46xx * chip, char * codec_name,\n\t\t\t       u16 channel_disp, u16 fifo_addr, u16 sample_buffer_addr,\n\t\t\t       u32 dest, struct dsp_scb_descriptor * parent_scb,\n\t\t\t       int scb_child_type)\n{\n\n\tstruct dsp_scb_descriptor * scb;\n\tstruct dsp_codec_input_scb codec_input_scb = {\n\t\t{ 0,\n\t\t  0,\n\t\t  0,\n\t\t  0\n\t\t},\n\t\t{\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t},\n    \n#if 0   \n\t\tSyncIOSCB,NULL_SCB_ADDR\n#else\n\t\t0 , 0,\n#endif\n\t\t0,0,\n\n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,   \n\t\tsample_buffer_addr << 0x10,        \n\t\tchannel_disp,fifo_addr,            \n\t\t0x0000,0x0000,                     \n\t\t0x80008000                         \n\t};\n  \n\tscb = cs46xx_dsp_create_generic_scb(chip,codec_name,(u32 *)&codec_input_scb,\n\t\t\t\t\t    dest,\"S16_CODECINPUTTASK\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\treturn scb;\n}\n\n\nstatic struct dsp_scb_descriptor * \ncs46xx_dsp_create_pcm_reader_scb(struct snd_cs46xx * chip, char * scb_name,\n                                 u16 sample_buffer_addr, u32 dest,\n                                 int virtual_channel, u32 playback_hw_addr,\n                                 struct dsp_scb_descriptor * parent_scb,\n                                 int scb_child_type)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_generic_scb pcm_reader_scb = {\n    \n\t\t \n\t\t \n\t\t{ DMA_RQ_C1_SOURCE_ON_HOST +         \n\t\t  DMA_RQ_C1_SOURCE_MOD1024 +         \n\t\t  DMA_RQ_C1_DEST_MOD32 +             \n\t\t  DMA_RQ_C1_WRITEBACK_SRC_FLAG +     \n\t\t  DMA_RQ_C1_WRITEBACK_DEST_FLAG +    \n\t\t  15,                              \n\t\t   \n\t\t   \n\t\t  DMA_RQ_C2_AC_NONE +\n\t\t  DMA_RQ_C2_SIGNAL_SOURCE_PINGPONG +  \n\t\t   \n\t\t  virtual_channel,                    \n\t\t  playback_hw_addr,                   \n\t\t  DMA_RQ_SD_SP_SAMPLE_ADDR +          \n\t\t  sample_buffer_addr                  \n\t\t},\n\t\t \n\t\t{\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0 \n\t\t},\n\t\t \n\t\tNULL_SCB_ADDR,NULL_SCB_ADDR,\n\t\t \n\t\t0,NULL_SCB_ADDR,\n\t\t \n\t\t \n\t\tRSCONFIG_DMA_ENABLE +                  \n\t\t(19 << RSCONFIG_MAX_DMA_SIZE_SHIFT) +  \n\t\t \n\t\t((dest >> 4) << RSCONFIG_STREAM_NUM_SHIFT) +  \n\t\tRSCONFIG_SAMPLE_16STEREO +\n\t\tRSCONFIG_MODULO_32,              \n\t\t \n\t\t(sample_buffer_addr << 0x10),\n\t\t \n\t\t0, \n\t\t{\n\t\t\t \n\t\t\t0xffff,0xffff,\n\t\t\t0xffff,0xffff\n\t\t}\n\t};\n\n\tif (ins->null_algorithm == NULL) {\n\t\tins->null_algorithm =  cs46xx_dsp_lookup_symbol (chip,\"NULLALGORITHM\",\n\t\t\t\t\t\t\t\t SYMBOL_CODE);\n    \n\t\tif (ins->null_algorithm == NULL) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: symbol NULLALGORITHM not found\\n\");\n\t\t\treturn NULL;\n\t\t}    \n\t}\n\n\tscb = _dsp_create_generic_scb(chip,scb_name,(u32 *)&pcm_reader_scb,\n\t\t\t\t      dest,ins->null_algorithm,parent_scb,\n\t\t\t\t      scb_child_type);\n  \n\treturn scb;\n}\n\n#define GOF_PER_SEC 200\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_src_task_scb(struct snd_cs46xx * chip, char * scb_name,\n\t\t\t       int rate,\n                               u16 src_buffer_addr,\n                               u16 src_delay_buffer_addr, u32 dest,\n                               struct dsp_scb_descriptor * parent_scb,\n                               int scb_child_type,\n\t                       int pass_through)\n{\n\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb;\n\tunsigned int tmp1, tmp2;\n\tunsigned int phiIncr;\n\tunsigned int correctionPerGOF, correctionPerSec;\n\n\tdev_dbg(chip->card->dev, \"dsp_spos: setting %s rate to %u\\n\",\n\t\tscb_name, rate);\n\n\t \n\ttmp1 = rate << 16;\n\tphiIncr = tmp1 / 48000;\n\ttmp1 -= phiIncr * 48000;\n\ttmp1 <<= 10;\n\tphiIncr <<= 10;\n\ttmp2 = tmp1 / 48000;\n\tphiIncr += tmp2;\n\ttmp1 -= tmp2 * 48000;\n\tcorrectionPerGOF = tmp1 / GOF_PER_SEC;\n\ttmp1 -= correctionPerGOF * GOF_PER_SEC;\n\tcorrectionPerSec = tmp1;\n\n\t{\n\t\tstruct dsp_src_task_scb src_task_scb = {\n\t\t\t0x0028,0x00c8,\n\t\t\t0x5555,0x0000,\n\t\t\t0x0000,0x0000,\n\t\t\tsrc_buffer_addr,1,\n\t\t\tcorrectionPerGOF,correctionPerSec,\n\t\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,  \n\t\t\t0x0000,src_delay_buffer_addr,                  \n\t\t\t0x0,                                            \n\t\t\t0x080,(src_delay_buffer_addr + (24 * 4)),\n\t\t\t0,0,  \n\t\t\t0,0,  \n\t\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_8,\n\t\t\tsrc_buffer_addr << 0x10,\n\t\t\tphiIncr,\n\t\t\t{ \n\t\t\t\t0xffff - ins->dac_volume_right,0xffff - ins->dac_volume_left,\n\t\t\t\t0xffff - ins->dac_volume_right,0xffff - ins->dac_volume_left\n\t\t\t}\n\t\t};\n\t\t\n\t\tif (ins->s16_up == NULL) {\n\t\t\tins->s16_up =  cs46xx_dsp_lookup_symbol (chip,\"S16_UPSRC\",\n\t\t\t\t\t\t\t\t SYMBOL_CODE);\n\t\t\t\n\t\t\tif (ins->s16_up == NULL) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"dsp_spos: symbol S16_UPSRC not found\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}    \n\t\t}\n\t\t\n\t\t \n\t\t_dsp_clear_sample_buffer (chip,src_buffer_addr,8);\n\t\t_dsp_clear_sample_buffer (chip,src_delay_buffer_addr,32);\n\t\t\t\t\n\t\tif (pass_through) {\n\t\t\t \n\t\t\tsnd_BUG_ON(rate != 48000);\n\n\t\t\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&src_task_scb,\n\t\t\t\t\t\t\t    dest,\"DMAREADER\",parent_scb,\n\t\t\t\t\t\t\t    scb_child_type);\n\t\t} else {\n\t\t\tscb = _dsp_create_generic_scb(chip,scb_name,(u32 *)&src_task_scb,\n\t\t\t\t\t\t      dest,ins->s16_up,parent_scb,\n\t\t\t\t\t\t      scb_child_type);\n\t\t}\n\n\n\t}\n\n\treturn scb;\n}\n\n#if 0  \nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_filter_scb(struct snd_cs46xx * chip, char * scb_name,\n\t\t\t     u16 buffer_addr, u32 dest,\n\t\t\t     struct dsp_scb_descriptor * parent_scb,\n\t\t\t     int scb_child_type) {\n\tstruct dsp_scb_descriptor * scb;\n\t\n\tstruct dsp_filter_scb filter_scb = {\n\t\t.a0_right            = 0x41a9,\n\t\t.a0_left             = 0x41a9,\n\t\t.a1_right            = 0xb8e4,\n\t\t.a1_left             = 0xb8e4,\n\t\t.a2_right            = 0x3e55,\n\t\t.a2_left             = 0x3e55,\n\t\t\n\t\t.filter_unused3      = 0x0000,\n\t\t.filter_unused2      = 0x0000,\n\n\t\t.output_buf_ptr      = buffer_addr,\n\t\t.init                = 0x000,\n\n\t\t.prev_sample_output1 = 0x00000000,\n\t\t.prev_sample_output2 = 0x00000000,\n\n\t\t.prev_sample_input1  = 0x00000000,\n\t\t.prev_sample_input2  = 0x00000000,\n\n\t\t.next_scb_ptr        = 0x0000,\n\t\t.sub_list_ptr        = 0x0000,\n\n\t\t.entry_point         = 0x0000,\n\t\t.spb_ptr             = 0x0000,\n\n\t\t.b0_right            = 0x0e38,\n\t\t.b0_left             = 0x0e38,\n\t\t.b1_right            = 0x1c71,\n\t\t.b1_left             = 0x1c71,\n\t\t.b2_right            = 0x0e38,\n\t\t.b2_left             = 0x0e38,\n\t};\n\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&filter_scb,\n\t\t\t\t\t    dest,\"FILTERTASK\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\n \treturn scb;\n}\n#endif  \n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_mix_only_scb(struct snd_cs46xx * chip, char * scb_name,\n                               u16 mix_buffer_addr, u32 dest,\n                               struct dsp_scb_descriptor * parent_scb,\n                               int scb_child_type)\n{\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_mix_only_scb master_mix_scb = {\n\t\t  { 0,\n\t\t\t      0,\n\t\t\t     mix_buffer_addr,\n\t\t\t     0\n\t\t\t    },\n\t\t{\n\t\t\t   0,\n\t\t\t   0,\n\t\t\t   0,\n\t\t\t   0,\n\t\t\t   0x00000080\n\t\t},\n\t\t  0,0,\n\t\t  0,0,\n\t\t  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,\n\t\t  (mix_buffer_addr  + (16 * 4)) << 0x10, \n\t\t  0,\n\t\t{\n\t\t\t  0x8000,0x8000,\n\t\t\t  0x8000,0x8000\n\t\t}\n\t};\n\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&master_mix_scb,\n\t\t\t\t\t    dest,\"S16_MIX\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\treturn scb;\n}\n\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_mix_to_ostream_scb(struct snd_cs46xx * chip, char * scb_name,\n                                     u16 mix_buffer_addr, u16 writeback_spb, u32 dest,\n                                     struct dsp_scb_descriptor * parent_scb,\n                                     int scb_child_type)\n{\n\tstruct dsp_scb_descriptor * scb;\n\n\tstruct dsp_mix2_ostream_scb mix2_ostream_scb = {\n\t\t \n\t\t{ \n\t\t\tDMA_RQ_C1_SOURCE_MOD64 +\n\t\t\tDMA_RQ_C1_DEST_ON_HOST +\n\t\t\tDMA_RQ_C1_DEST_MOD1024 +\n\t\t\tDMA_RQ_C1_WRITEBACK_SRC_FLAG + \n\t\t\tDMA_RQ_C1_WRITEBACK_DEST_FLAG +\n\t\t\t15,                            \n      \n\t\t\tDMA_RQ_C2_AC_NONE +\n\t\t\tDMA_RQ_C2_SIGNAL_DEST_PINGPONG + \n      \n\t\t\tCS46XX_DSP_CAPTURE_CHANNEL,                                 \n\t\t\tDMA_RQ_SD_SP_SAMPLE_ADDR + \n\t\t\tmix_buffer_addr, \n\t\t\t0x0                   \n\t\t},\n    \n\t\t{ 0, 0, 0, 0, 0, },\n\t\t0,0,\n\t\t0,writeback_spb,\n    \n\t\tRSCONFIG_DMA_ENABLE + \n\t\t(19 << RSCONFIG_MAX_DMA_SIZE_SHIFT) + \n    \n\t\t((dest >> 4) << RSCONFIG_STREAM_NUM_SHIFT) +\n\t\tRSCONFIG_DMA_TO_HOST + \n\t\tRSCONFIG_SAMPLE_16STEREO +\n\t\tRSCONFIG_MODULO_64,    \n\t\t(mix_buffer_addr + (32 * 4)) << 0x10,\n\t\t1,0,            \n\t\t0x0001,0x0080,\n\t\t0xFFFF,0\n\t};\n\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&mix2_ostream_scb,\n\t\t\t\t\n\t    dest,\"S16_MIX_TO_OSTREAM\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n  \n\treturn scb;\n}\n\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_vari_decimate_scb(struct snd_cs46xx * chip,char * scb_name,\n                                    u16 vari_buffer_addr0,\n                                    u16 vari_buffer_addr1,\n                                    u32 dest,\n                                    struct dsp_scb_descriptor * parent_scb,\n                                    int scb_child_type)\n{\n\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_vari_decimate_scb vari_decimate_scb = {\n\t\t0x0028,0x00c8,\n\t\t0x5555,0x0000,\n\t\t0x0000,0x0000,\n\t\tvari_buffer_addr0,vari_buffer_addr1,\n    \n\t\t0x0028,0x00c8,\n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_256, \n    \n\t\t0xFF800000,   \n\t\t0,\n\t\t0x0080,vari_buffer_addr1 + (25 * 4), \n    \n\t\t0,0, \n\t\t0,0,\n\n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_8,\n\t\tvari_buffer_addr0 << 0x10,   \n\t\t0x04000000,                   \n\t\t{\n\t\t\t0x8000,0x8000, \n\t\t\t0xFFFF,0xFFFF\n\t\t}\n\t};\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&vari_decimate_scb,\n\t\t\t\t\t    dest,\"VARIDECIMATE\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n  \n\treturn scb;\n}\n\n\nstatic struct dsp_scb_descriptor * \ncs46xx_dsp_create_pcm_serial_input_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n                                       struct dsp_scb_descriptor * input_scb,\n                                       struct dsp_scb_descriptor * parent_scb,\n                                       int scb_child_type)\n{\n\n\tstruct dsp_scb_descriptor * scb;\n\n\n\tstruct dsp_pcm_serial_input_scb pcm_serial_input_scb = {\n\t\t{ 0,\n\t\t  0,\n\t\t  0,\n\t\t  0\n\t\t},\n\t\t{\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t},\n\n\t\t0,0,\n\t\t0,0,\n\n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_16,\n\t\t0,\n        0,input_scb->address,\n\t\t{\n          0x8000,0x8000,\n       \t  0x8000,0x8000\n\t\t}\n\t};\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&pcm_serial_input_scb,\n\t\t\t\t\t    dest,\"PCMSERIALINPUTTASK\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\treturn scb;\n}\n\n\nstatic struct dsp_scb_descriptor * \ncs46xx_dsp_create_asynch_fg_tx_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n                                   u16 hfg_scb_address,\n                                   u16 asynch_buffer_address,\n                                   struct dsp_scb_descriptor * parent_scb,\n                                   int scb_child_type)\n{\n\n\tstruct dsp_scb_descriptor * scb;\n\n\tstruct dsp_asynch_fg_tx_scb asynch_fg_tx_scb = {\n\t\t0xfc00,0x03ff,       \n\t\t0x0058,0x0028,       \n\t\t \n\t\t0,hfg_scb_address,   \n\t\t0,0,\t\t     \n\t\t0,                   \n\t\t0,0x2aab,            \n    \n\t\t{\n\t\t\t0,          \n\t\t\t0,\n\t\t\t0\n\t\t},\n    \n\t\t0,0,\n\t\t0,dest + AFGTxAccumPhi,\n    \n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_256,  \n\t\t(asynch_buffer_address) << 0x10,   \n    \n\t\t \n\t\t0x18000000,                      \n\t\t0x8000,0x8000,                   \n\t\t0x8000,0x8000\n\t};\n  \n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&asynch_fg_tx_scb,\n\t\t\t\t\t    dest,\"ASYNCHFGTXCODE\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\n\treturn scb;\n}\n\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_asynch_fg_rx_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n                                   u16 hfg_scb_address,\n                                   u16 asynch_buffer_address,\n                                   struct dsp_scb_descriptor * parent_scb,\n                                   int scb_child_type)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb;\n\n\tstruct dsp_asynch_fg_rx_scb asynch_fg_rx_scb = {\n\t\t0xfe00,0x01ff,       \n\t\t0x0064,0x001c,       \n\t\t                     \n\t\t0,hfg_scb_address,   \n\t\t0,0,\t\t\t\t \n\t\t{\n\t\t\t0,                 \n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t},\n      \n\t\t0,0,\n\t\t0,dest,\n    \n\t\tRSCONFIG_MODULO_128 |\n        RSCONFIG_SAMPLE_16STEREO,                          \n\t\t( (asynch_buffer_address + (16 * 4))  << 0x10),    \n    \n\t\t \n\t\t0x18000000,         \n\n\t\t \n\t\t0xffff - ins->spdif_input_volume_right,0xffff - ins->spdif_input_volume_left,\n\t\t0xffff - ins->spdif_input_volume_right,0xffff - ins->spdif_input_volume_left,\n\t};\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&asynch_fg_rx_scb,\n\t\t\t\t\t    dest,\"ASYNCHFGRXCODE\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\n\treturn scb;\n}\n\n\n#if 0  \nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_output_snoop_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n                                   u16 snoop_buffer_address,\n                                   struct dsp_scb_descriptor * snoop_scb,\n                                   struct dsp_scb_descriptor * parent_scb,\n                                   int scb_child_type)\n{\n\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_output_snoop_scb output_snoop_scb = {\n\t\t{ 0,\t \n\t\t  0,\n\t\t  0,\n\t\t  0,\n\t\t},\n\t\t{\n\t\t\t0,  \n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t},\n    \n\t\t0,0,\n\t\t0,0,\n    \n\t\tRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\n\t\tsnoop_buffer_address << 0x10,  \n\t\t0,0,\n\t\t0,\n\t\t0,snoop_scb->address\n\t};\n  \n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&output_snoop_scb,\n\t\t\t\t\t    dest,\"OUTPUTSNOOP\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\treturn scb;\n}\n#endif  \n\n\nstruct dsp_scb_descriptor * \ncs46xx_dsp_create_spio_write_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n                                 struct dsp_scb_descriptor * parent_scb,\n                                 int scb_child_type)\n{\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_spio_write_scb spio_write_scb = {\n\t\t0,0,          \n\t\t0,            \n\t\t0,            \n\t\t0,0,          \n\t\t0,            \n\t\t0,            \n\t\t0,0,          \n\t\t{ 0,0 },      \n    \n\t\t0,0,\t      \n\t\t0,0,          \n    \n\t\t{ \n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0           \n\t\t}\n\t};\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&spio_write_scb,\n\t\t\t\t\t    dest,\"SPIOWRITE\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\n\treturn scb;\n}\n\nstruct dsp_scb_descriptor *\ncs46xx_dsp_create_magic_snoop_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\n\t\t\t\t  u16 snoop_buffer_address,\n\t\t\t\t  struct dsp_scb_descriptor * snoop_scb,\n\t\t\t\t  struct dsp_scb_descriptor * parent_scb,\n\t\t\t\t  int scb_child_type)\n{\n\tstruct dsp_scb_descriptor * scb;\n  \n\tstruct dsp_magic_snoop_task magic_snoop_scb = {\n\t\t  0,  \n\t\t  0,  \n\t\t  snoop_buffer_address << 0x10,\n\t\t  0,snoop_scb->address,\n\t\t  0,  \n\t\t  0,  \n\t\t  0,  \n\t\t  0,  \n\t\t  0,  \n\t\t  0,0,  \n\t\t  0,0,  \n\t\t  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\n\t\t  snoop_buffer_address  << 0x10,\n\t\t  0,\n\t\t  { 0x8000,0x8000,\n\t            0xffff,0xffff\n\t\t}\n\t};\n\n\tscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&magic_snoop_scb,\n\t\t\t\t\t    dest,\"MAGICSNOOPTASK\",parent_scb,\n\t\t\t\t\t    scb_child_type);\n\n\treturn scb;\n}\n\nstatic struct dsp_scb_descriptor *\nfind_next_free_scb (struct snd_cs46xx * chip, struct dsp_scb_descriptor * from)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb = from;\n\n\twhile (scb->next_scb_ptr != ins->the_null_scb) {\n\t\tif (snd_BUG_ON(!scb->next_scb_ptr))\n\t\t\treturn NULL;\n\n\t\tscb = scb->next_scb_ptr;\n\t}\n\n\treturn scb;\n}\n\nstatic const u32 pcm_reader_buffer_addr[DSP_MAX_PCM_CHANNELS] = {\n\t0x0600,  \n\t0x1500,  \n\t0x1580,  \n\t0x1600,  \n\t0x1680,  \n\t0x1700,  \n\t0x1780,  \n\t0x1800,  \n\t0x1880,  \n\t0x1900,  \n\t0x1980,  \n\t0x1A00,  \n\t0x1A80,  \n\t0x1B00,  \n\t0x1B80,  \n\t0x1C00,  \n\t0x1C80,  \n\t0x1D00,  \n\t0x1D80,  \n\t0x1E00,  \n\t0x1E80,  \n\t0x1F00,  \n\t0x1F80,  \n\t0x2000,  \n\t0x2080,  \n\t0x2100,  \n\t0x2180,  \n\t0x2200,  \n\t0x2280,  \n\t0x2300,  \n\t0x2380,  \n\t0x2400,  \n};\n\nstatic const u32 src_output_buffer_addr[DSP_MAX_SRC_NR] = {\n\t0x2B80,\n\t0x2BA0,\n\t0x2BC0,\n\t0x2BE0,\n\t0x2D00,  \n\t0x2D20,  \n\t0x2D40,  \n\t0x2D60,\n\t0x2D80,\n\t0x2DA0,\n\t0x2DC0,\n\t0x2DE0,\n\t0x2E00,\n\t0x2E20\n};\n\nstatic const u32 src_delay_buffer_addr[DSP_MAX_SRC_NR] = {\n\t0x2480,\n\t0x2500,\n\t0x2580,\n\t0x2600,\n\t0x2680,\n\t0x2700,\n\t0x2780,\n\t0x2800,\n\t0x2880,\n\t0x2900,\n\t0x2980,\n\t0x2A00,\n\t0x2A80,\n\t0x2B00\n};\n\nstruct dsp_pcm_channel_descriptor *\ncs46xx_dsp_create_pcm_channel (struct snd_cs46xx * chip,\n\t\t\t       u32 sample_rate, void * private_data, \n\t\t\t       u32 hw_dma_addr,\n\t\t\t       int pcm_channel_id)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * src_scb = NULL, * pcm_scb, * mixer_scb = NULL;\n\tstruct dsp_scb_descriptor * src_parent_scb = NULL;\n\n\t \n\tchar scb_name[DSP_MAX_SCB_NAME];\n\tint i, pcm_index = -1, insert_point, src_index = -1, pass_through = 0;\n\tunsigned long flags;\n\n\tswitch (pcm_channel_id) {\n\tcase DSP_PCM_MAIN_CHANNEL:\n\t\tmixer_scb = ins->master_mix_scb;\n\t\tbreak;\n\tcase DSP_PCM_REAR_CHANNEL:\n\t\tmixer_scb = ins->rear_mix_scb;\n\t\tbreak;\n\tcase DSP_PCM_CENTER_LFE_CHANNEL:\n\t\tmixer_scb = ins->center_lfe_mix_scb;\n\t\tbreak;\n\tcase DSP_PCM_S71_CHANNEL:\n\t\t \n\t\tsnd_BUG();\n\t\tbreak;\n\tcase DSP_IEC958_CHANNEL:\n\t\tif (snd_BUG_ON(!ins->asynch_tx_scb))\n\t\t\treturn NULL;\n\t\tmixer_scb = ins->asynch_tx_scb;\n\n\t\t \n\t\tif (sample_rate == 48000) {\n\t\t\tdev_dbg(chip->card->dev, \"IEC958 pass through\\n\");\n\t\t\t \n\t\t\tpass_through = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn NULL;\n\t}\n\t \n\tif (!sample_rate) sample_rate = 44100;\n\n\t \n\tfor (i = 0; i < DSP_MAX_PCM_CHANNELS && \n\t\t     (pcm_index == -1 || src_scb == NULL); ++i) {\n\n\t\t \n\t\tif (i == CS46XX_DSP_CAPTURE_CHANNEL) continue;\n\n\t\tif (ins->pcm_channels[i].active) {\n\t\t\tif (!src_scb && \n\t\t\t    ins->pcm_channels[i].sample_rate == sample_rate &&\n\t\t\t    ins->pcm_channels[i].mixer_scb == mixer_scb) {\n\t\t\t\tsrc_scb = ins->pcm_channels[i].src_scb;\n\t\t\t\tins->pcm_channels[i].src_scb->ref_count ++;\n\t\t\t\tsrc_index = ins->pcm_channels[i].src_slot;\n\t\t\t}\n\t\t} else if (pcm_index == -1) {\n\t\t\tpcm_index = i;\n\t\t}\n\t}\n\n\tif (pcm_index == -1) {\n\t\tdev_err(chip->card->dev, \"dsp_spos: no free PCM channel\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (src_scb == NULL) {\n\t\tif (ins->nsrc_scb >= DSP_MAX_SRC_NR) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: too many SRC instances\\n!\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < DSP_MAX_SRC_NR; ++i) {\n\t\t\tif (ins->src_scb_slots[i] == 0) {\n\t\t\t\tsrc_index = i;\n\t\t\t\tins->src_scb_slots[i] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (snd_BUG_ON(src_index == -1))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (mixer_scb->sub_list_ptr == ins->the_null_scb) {\n\t\t\tsrc_parent_scb = mixer_scb;\n\t\t\tinsert_point = SCB_ON_PARENT_SUBLIST_SCB;\n\t\t} else {\n\t\t\tsrc_parent_scb = find_next_free_scb(chip,mixer_scb->sub_list_ptr);\n\t\t\tinsert_point = SCB_ON_PARENT_NEXT_SCB;\n\t\t}\n\n\t\tsnprintf (scb_name,DSP_MAX_SCB_NAME,\"SrcTask_SCB%d\",src_index);\n\t\t\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"dsp_spos: creating SRC \\\"%s\\\"\\n\", scb_name);\n\t\tsrc_scb = cs46xx_dsp_create_src_task_scb(chip,scb_name,\n\t\t\t\t\t\t\t sample_rate,\n\t\t\t\t\t\t\t src_output_buffer_addr[src_index],\n\t\t\t\t\t\t\t src_delay_buffer_addr[src_index],\n\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t 0x400 + (src_index * 0x10) ,\n\t\t\t\t\t\t\t src_parent_scb,\n\t\t\t\t\t\t\t insert_point,\n\t\t\t\t\t\t\t pass_through);\n\n\t\tif (!src_scb) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: failed to create SRCtaskSCB\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\n\t\tins->nsrc_scb ++;\n\t} \n  \n  \n\tsnprintf (scb_name,DSP_MAX_SCB_NAME,\"PCMReader_SCB%d\",pcm_index);\n\n\tdev_dbg(chip->card->dev, \"dsp_spos: creating PCM \\\"%s\\\" (%d)\\n\",\n\t\tscb_name, pcm_channel_id);\n\n\tpcm_scb = cs46xx_dsp_create_pcm_reader_scb(chip,scb_name,\n\t\t\t\t\t\t   pcm_reader_buffer_addr[pcm_index],\n\t\t\t\t\t\t    \n\t\t\t\t\t\t   (pcm_index * 0x10) + 0x200,\n\t\t\t\t\t\t   pcm_index,     \n\t\t\t\t\t\t   hw_dma_addr,   \n                           NULL,          \n                           0               \n                           );\n\n\tif (!pcm_scb) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: failed to create PCMreaderSCB\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tins->pcm_channels[pcm_index].sample_rate = sample_rate;\n\tins->pcm_channels[pcm_index].pcm_reader_scb = pcm_scb;\n\tins->pcm_channels[pcm_index].src_scb = src_scb;\n\tins->pcm_channels[pcm_index].unlinked = 1;\n\tins->pcm_channels[pcm_index].private_data = private_data;\n\tins->pcm_channels[pcm_index].src_slot = src_index;\n\tins->pcm_channels[pcm_index].active = 1;\n\tins->pcm_channels[pcm_index].pcm_slot = pcm_index;\n\tins->pcm_channels[pcm_index].mixer_scb = mixer_scb;\n\tins->npcm_channels ++;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn (ins->pcm_channels + pcm_index);\n}\n\nint cs46xx_dsp_pcm_channel_set_period (struct snd_cs46xx * chip,\n\t\t\t\t       struct dsp_pcm_channel_descriptor * pcm_channel,\n\t\t\t\t       int period_size)\n{\n\tu32 temp = snd_cs46xx_peek (chip,pcm_channel->pcm_reader_scb->address << 2);\n\ttemp &= ~DMA_RQ_C1_SOURCE_SIZE_MASK;\n\n\tswitch (period_size) {\n\tcase 2048:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD1024;\n\t\tbreak;\n\tcase 1024:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD512;\n\t\tbreak;\n\tcase 512:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD256;\n\t\tbreak;\n\tcase 256:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD128;\n\t\tbreak;\n\tcase 128:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD64;\n\t\tbreak;\n\tcase 64:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD32;\n\t\tbreak;\t\t      \n\tcase 32:\n\t\ttemp |= DMA_RQ_C1_SOURCE_MOD16;\n\t\tbreak; \n\tdefault:\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"period size (%d) not supported by HW\\n\", period_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_cs46xx_poke (chip,pcm_channel->pcm_reader_scb->address << 2,temp);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_pcm_ostream_set_period (struct snd_cs46xx * chip,\n\t\t\t\t       int period_size)\n{\n\tu32 temp = snd_cs46xx_peek (chip,WRITEBACK_SCB_ADDR << 2);\n\ttemp &= ~DMA_RQ_C1_DEST_SIZE_MASK;\n\n\tswitch (period_size) {\n\tcase 2048:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD1024;\n\t\tbreak;\n\tcase 1024:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD512;\n\t\tbreak;\n\tcase 512:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD256;\n\t\tbreak;\n\tcase 256:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD128;\n\t\tbreak;\n\tcase 128:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD64;\n\t\tbreak;\n\tcase 64:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD32;\n\t\tbreak;\t\t      \n\tcase 32:\n\t\ttemp |= DMA_RQ_C1_DEST_MOD16;\n\t\tbreak; \n\tdefault:\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"period size (%d) not supported by HW\\n\", period_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_cs46xx_poke (chip,WRITEBACK_SCB_ADDR << 2,temp);\n\n\treturn 0;\n}\n\nvoid cs46xx_dsp_destroy_pcm_channel (struct snd_cs46xx * chip,\n\t\t\t\t     struct dsp_pcm_channel_descriptor * pcm_channel)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!pcm_channel->active ||\n\t\t       ins->npcm_channels <= 0 ||\n\t\t       pcm_channel->src_scb->ref_count <= 0))\n\t\treturn;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tpcm_channel->unlinked = 1;\n\tpcm_channel->active = 0;\n\tpcm_channel->private_data = NULL;\n\tpcm_channel->src_scb->ref_count --;\n\tins->npcm_channels --;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\tcs46xx_dsp_remove_scb(chip,pcm_channel->pcm_reader_scb);\n\n\tif (!pcm_channel->src_scb->ref_count) {\n\t\tcs46xx_dsp_remove_scb(chip,pcm_channel->src_scb);\n\n\t\tif (snd_BUG_ON(pcm_channel->src_slot < 0 ||\n\t\t\t       pcm_channel->src_slot >= DSP_MAX_SRC_NR))\n\t\t\treturn;\n\n\t\tins->src_scb_slots[pcm_channel->src_slot] = 0;\n\t\tins->nsrc_scb --;\n\t}\n}\n\nint cs46xx_dsp_pcm_unlink (struct snd_cs46xx * chip,\n\t\t\t   struct dsp_pcm_channel_descriptor * pcm_channel)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!pcm_channel->active ||\n\t\t       chip->dsp_spos_instance->npcm_channels <= 0))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (pcm_channel->unlinked) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn -EIO;\n\t}\n\n\tpcm_channel->unlinked = 1;\n\n\t_dsp_unlink_scb (chip,pcm_channel->pcm_reader_scb);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_pcm_link (struct snd_cs46xx * chip,\n\t\t\t struct dsp_pcm_channel_descriptor * pcm_channel)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * parent_scb;\n\tstruct dsp_scb_descriptor * src_scb = pcm_channel->src_scb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\n\tif (pcm_channel->unlinked == 0) {\n\t\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\t\treturn -EIO;\n\t}\n\n\tparent_scb = src_scb;\n\n\tif (src_scb->sub_list_ptr != ins->the_null_scb) {\n\t\tsrc_scb->sub_list_ptr->parent_scb_ptr = pcm_channel->pcm_reader_scb;\n\t\tpcm_channel->pcm_reader_scb->next_scb_ptr = src_scb->sub_list_ptr;\n\t}\n\n\tsrc_scb->sub_list_ptr = pcm_channel->pcm_reader_scb;\n\n\tsnd_BUG_ON(pcm_channel->pcm_reader_scb->parent_scb_ptr);\n\tpcm_channel->pcm_reader_scb->parent_scb_ptr = parent_scb;\n\n\t \n\tcs46xx_dsp_spos_update_scb(chip,pcm_channel->pcm_reader_scb);\n\n\t \n\tcs46xx_dsp_spos_update_scb(chip,parent_scb);\n\n\tpcm_channel->unlinked = 0;\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\treturn 0;\n}\n\nstruct dsp_scb_descriptor *\ncs46xx_add_record_source (struct snd_cs46xx *chip, struct dsp_scb_descriptor * source,\n\t\t\t  u16 addr, char * scb_name)\n{\n  \tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * parent;\n\tstruct dsp_scb_descriptor * pcm_input;\n\tint insert_point;\n\n\tif (snd_BUG_ON(!ins->record_mixer_scb))\n\t\treturn NULL;\n\n\tif (ins->record_mixer_scb->sub_list_ptr != ins->the_null_scb) {\n\t\tparent = find_next_free_scb (chip,ins->record_mixer_scb->sub_list_ptr);\n\t\tinsert_point = SCB_ON_PARENT_NEXT_SCB;\n\t} else {\n\t\tparent = ins->record_mixer_scb;\n\t\tinsert_point = SCB_ON_PARENT_SUBLIST_SCB;\n\t}\n\n\tpcm_input = cs46xx_dsp_create_pcm_serial_input_scb(chip,scb_name,addr,\n\t\t\t\t\t\t\t   source, parent,\n\t\t\t\t\t\t\t   insert_point);\n\n\treturn pcm_input;\n}\n\nint cs46xx_src_unlink(struct snd_cs46xx *chip, struct dsp_scb_descriptor * src)\n{\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!src->parent_scb_ptr))\n\t\treturn -EINVAL;\n\n\t \n\tcs46xx_dsp_scb_set_volume (chip,src,0,0);\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\t_dsp_unlink_scb (chip,src);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\treturn 0;\n}\n\nint cs46xx_src_link(struct snd_cs46xx *chip, struct dsp_scb_descriptor * src)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * parent_scb;\n\n\tif (snd_BUG_ON(src->parent_scb_ptr))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->master_mix_scb))\n\t\treturn -EINVAL;\n\n\tif (ins->master_mix_scb->sub_list_ptr != ins->the_null_scb) {\n\t\tparent_scb = find_next_free_scb (chip,ins->master_mix_scb->sub_list_ptr);\n\t\tparent_scb->next_scb_ptr = src;\n\t} else {\n\t\tparent_scb = ins->master_mix_scb;\n\t\tparent_scb->sub_list_ptr = src;\n\t}\n\n\tsrc->parent_scb_ptr = parent_scb;\n\n\t \n\tcs46xx_dsp_spos_update_scb(chip,parent_scb);\n  \n\treturn 0;\n}\n\nint cs46xx_dsp_enable_spdif_out (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) ) {\n\t\tcs46xx_dsp_enable_spdif_hw (chip);\n\t}\n\n\t \n\tif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) {\n\t\t \n\t\tins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\n\n\t\treturn -EBUSY;\n\t}\n\n\tif (snd_BUG_ON(ins->asynch_tx_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(ins->master_mix_scb->next_scb_ptr !=\n\t\t       ins->the_null_scb))\n\t\treturn -EINVAL;\n\n\t \n\tsnd_cs46xx_poke (chip, (ins->ref_snoop_scb->address + 2) << 2,\n\t\t\t (OUTPUT_SNOOP_BUFFER + 0x10) << 0x10 );\n\t\n\t \n\tins->asynch_tx_scb = cs46xx_dsp_create_asynch_fg_tx_scb(chip,\"AsynchFGTxSCB\",ASYNCTX_SCB_ADDR,\n\t\t\t\t\t\t\t\tSPDIFO_SCB_INST,\n\t\t\t\t\t\t\t\tSPDIFO_IP_OUTPUT_BUFFER1,\n\t\t\t\t\t\t\t\tins->master_mix_scb,\n\t\t\t\t\t\t\t\tSCB_ON_PARENT_NEXT_SCB);\n\tif (!ins->asynch_tx_scb) return -ENOMEM;\n\n\tins->spdif_pcm_input_scb = cs46xx_dsp_create_pcm_serial_input_scb(chip,\"PCMSerialInput_II\",\n\t\t\t\t\t\t\t\t\t  PCMSERIALINII_SCB_ADDR,\n\t\t\t\t\t\t\t\t\t  ins->ref_snoop_scb,\n\t\t\t\t\t\t\t\t\t  ins->asynch_tx_scb,\n\t\t\t\t\t\t\t\t\t  SCB_ON_PARENT_SUBLIST_SCB);\n  \n\t\n\tif (!ins->spdif_pcm_input_scb) return -ENOMEM;\n\n\t \n\tins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\n\n\treturn 0;\n}\n\nint  cs46xx_dsp_disable_spdif_out (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\t \n\tif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) {\n\t\tins->spdif_status_out &= ~DSP_SPDIF_STATUS_OUTPUT_ENABLED;\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (snd_BUG_ON(!ins->asynch_tx_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->spdif_pcm_input_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(ins->master_mix_scb->next_scb_ptr != ins->asynch_tx_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(ins->asynch_tx_scb->parent_scb_ptr !=\n\t\t       ins->master_mix_scb))\n\t\treturn -EINVAL;\n\n\tcs46xx_dsp_remove_scb (chip,ins->spdif_pcm_input_scb);\n\tcs46xx_dsp_remove_scb (chip,ins->asynch_tx_scb);\n\n\tins->spdif_pcm_input_scb = NULL;\n\tins->asynch_tx_scb = NULL;\n\n\t \n\t_dsp_clear_sample_buffer(chip,SPDIFO_IP_OUTPUT_BUFFER1,256);\n\n\t \n\tins->spdif_status_out  &= ~DSP_SPDIF_STATUS_OUTPUT_ENABLED;\n\n\n\treturn 0;\n}\n\nint cs46xx_iec958_pre_open (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif ( ins->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED ) {\n\t\t \n\t\tcs46xx_dsp_disable_spdif_out (chip);\n\n\t\t \n\t\tins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\n\t}\n\t\n\t \n\tif ( !(ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) ) {\n\t\tcs46xx_dsp_enable_spdif_hw (chip);\n\t}\n\n\t \n\tins->asynch_tx_scb = cs46xx_dsp_create_asynch_fg_tx_scb(chip,\"AsynchFGTxSCB\",ASYNCTX_SCB_ADDR,\n\t\t\t\t\t\t\t\tSPDIFO_SCB_INST,\n\t\t\t\t\t\t\t\tSPDIFO_IP_OUTPUT_BUFFER1,\n\t\t\t\t\t\t\t\tins->master_mix_scb,\n\t\t\t\t\t\t\t\tSCB_ON_PARENT_NEXT_SCB);\n\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_stream);\n\n\tins->spdif_status_out  |= DSP_SPDIF_STATUS_PLAYBACK_OPEN;\n\n\treturn 0;\n}\n\nint cs46xx_iec958_post_close (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(!ins->asynch_tx_scb))\n\t\treturn -EINVAL;\n\n\tins->spdif_status_out  &= ~DSP_SPDIF_STATUS_PLAYBACK_OPEN;\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);\n\t\n\t \n\tif (ins->spdif_pcm_input_scb != NULL) {\n\t\tcs46xx_dsp_remove_scb (chip,ins->spdif_pcm_input_scb);\n\t\tins->spdif_pcm_input_scb = NULL;\n\t}\n\n\tcs46xx_dsp_remove_scb (chip,ins->asynch_tx_scb);\n\tins->asynch_tx_scb = NULL;\n\n\t \n\t_dsp_clear_sample_buffer(chip,SPDIFO_IP_OUTPUT_BUFFER1,256);\n\n\t \n\tif ( ins->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED ) {\n\t\tcs46xx_dsp_enable_spdif_out (chip);\n\t}\n\t\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}