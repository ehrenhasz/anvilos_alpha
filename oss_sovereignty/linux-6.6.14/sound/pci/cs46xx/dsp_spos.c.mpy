{
  "module_name": "dsp_spos.c",
  "hash_id": "8fa9a5e4f26f05d5532e8694d42bf517b07145e41bed92bcd3c15163c8b96837",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs46xx/dsp_spos.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/asoundef.h>\n#include \"cs46xx.h\"\n\n#include \"cs46xx_lib.h\"\n#include \"dsp_spos.h\"\n\nstatic int cs46xx_dsp_async_init (struct snd_cs46xx *chip,\n\t\t\t\t  struct dsp_scb_descriptor * fg_entry);\n\nstatic const enum wide_opcode wide_opcodes[] = {\n\tWIDE_FOR_BEGIN_LOOP,\n\tWIDE_FOR_BEGIN_LOOP2,\n\tWIDE_COND_GOTO_ADDR,\n\tWIDE_COND_GOTO_CALL,\n\tWIDE_TBEQ_COND_GOTO_ADDR,\n\tWIDE_TBEQ_COND_CALL_ADDR,\n\tWIDE_TBEQ_NCOND_GOTO_ADDR,\n\tWIDE_TBEQ_NCOND_CALL_ADDR,\n\tWIDE_TBEQ_COND_GOTO1_ADDR,\n\tWIDE_TBEQ_COND_CALL1_ADDR,\n\tWIDE_TBEQ_NCOND_GOTOI_ADDR,\n\tWIDE_TBEQ_NCOND_CALL1_ADDR\n};\n\nstatic int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32 size,\n\t\t\t\t       u32 overlay_begin_address)\n{\n\tunsigned int i = 0, j, nreallocated = 0;\n\tu32 hival,loval,address;\n\tu32 mop_operands,mop_type,wide_op;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(size %2))\n\t\treturn -EINVAL;\n  \n\twhile (i < size) {\n\t\tloval = data[i++];\n\t\thival = data[i++];\n\n\t\tif (ins->code.offset > 0) {\n\t\t\tmop_operands = (hival >> 6) & 0x03fff;\n\t\t\tmop_type = mop_operands >> 10;\n      \n\t\t\t \n\t\t\tif (mop_type == 0 &&\n\t\t\t    (mop_operands & WIDE_LADD_INSTR_MASK) == 0 &&\n\t\t\t    (mop_operands & WIDE_INSTR_MASK) != 0) {\n\t\t\t\twide_op = loval & 0x7f;\n\t\t\t\tfor (j = 0;j < ARRAY_SIZE(wide_opcodes); ++j) {\n\t\t\t\t\tif (wide_opcodes[j] == wide_op) {\n\t\t\t\t\t\t \n\t\t\t\t\t\taddress  = (hival & 0x00FFF) << 5;\n\t\t\t\t\t\taddress |=  loval >> 15;\n            \n\t\t\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\t\t\"handle_wideop[1]: %05x:%05x addr %04x\\n\",\n\t\t\t\t\t\t\thival, loval, address);\n            \n\t\t\t\t\t\tif ( !(address & 0x8000) ) {\n\t\t\t\t\t\t\taddress += (ins->code.offset / 2) - overlay_begin_address;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\t\t\t\"handle_wideop[1]: ROM symbol not reallocated\\n\");\n\t\t\t\t\t\t}\n            \n\t\t\t\t\t\thival &= 0xFF000;\n\t\t\t\t\t\tloval &= 0x07FFF;\n            \n\t\t\t\t\t\thival |= ( (address >> 5)  & 0x00FFF);\n\t\t\t\t\t\tloval |= ( (address << 15) & 0xF8000);\n            \n\t\t\t\t\t\taddress  = (hival & 0x00FFF) << 5;\n\t\t\t\t\t\taddress |=  loval >> 15;\n            \n\t\t\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\t\t\"handle_wideop:[2] %05x:%05x addr %04x\\n\",\n\t\t\t\t\t\t\thival, loval, address);\n\t\t\t\t\t\tnreallocated++;\n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\n\t\tins->code.data[ins->code.size++] = loval;\n\t\tins->code.data[ins->code.size++] = hival;\n\t}\n\n\tdev_dbg(chip->card->dev,\n\t\t\"dsp_spos: %d instructions reallocated\\n\", nreallocated);\n\treturn nreallocated;\n}\n\nstatic struct dsp_segment_desc * get_segment_desc (struct dsp_module_desc * module, int seg_type)\n{\n\tint i;\n\tfor (i = 0;i < module->nsegments; ++i) {\n\t\tif (module->segments[i].segment_type == seg_type) {\n\t\t\treturn (module->segments + i);\n\t\t}\n\t}\n\n\treturn NULL;\n};\n\nstatic int find_free_symbol_index (struct dsp_spos_instance * ins)\n{\n\tint index = ins->symbol_table.nsymbols,i;\n\n\tfor (i = ins->symbol_table.highest_frag_index; i < ins->symbol_table.nsymbols; ++i) {\n\t\tif (ins->symbol_table.symbols[i].deleted) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn index;\n}\n\nstatic int add_symbols (struct snd_cs46xx * chip, struct dsp_module_desc * module)\n{\n\tint i;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (module->symbol_table.nsymbols > 0) {\n\t\tif (!strcmp(module->symbol_table.symbols[0].symbol_name, \"OVERLAYBEGINADDRESS\") &&\n\t\t    module->symbol_table.symbols[0].symbol_type == SYMBOL_CONSTANT ) {\n\t\t\tmodule->overlay_begin_address = module->symbol_table.symbols[0].address;\n\t\t}\n\t}\n\n\tfor (i = 0;i < module->symbol_table.nsymbols; ++i) {\n\t\tif (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: symbol table is full\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\n\t\tif (cs46xx_dsp_lookup_symbol(chip,\n\t\t\t\t\t     module->symbol_table.symbols[i].symbol_name,\n\t\t\t\t\t     module->symbol_table.symbols[i].symbol_type) == NULL) {\n\n\t\t\tins->symbol_table.symbols[ins->symbol_table.nsymbols] = module->symbol_table.symbols[i];\n\t\t\tins->symbol_table.symbols[ins->symbol_table.nsymbols].address += ((ins->code.offset / 2) - module->overlay_begin_address);\n\t\t\tins->symbol_table.symbols[ins->symbol_table.nsymbols].module = module;\n\t\t\tins->symbol_table.symbols[ins->symbol_table.nsymbols].deleted = 0;\n\n\t\t\tif (ins->symbol_table.nsymbols > ins->symbol_table.highest_frag_index) \n\t\t\t\tins->symbol_table.highest_frag_index = ins->symbol_table.nsymbols;\n\n\t\t\tins->symbol_table.nsymbols++;\n\t\t} else {\n#if 0\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"dsp_spos: symbol <%s> duplicated, probably nothing wrong with that (Cirrus?)\\n\",\n\t\t\t\tmodule->symbol_table.symbols[i].symbol_name); */\n#endif\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct dsp_symbol_entry *\nadd_symbol (struct snd_cs46xx * chip, char * symbol_name, u32 address, int type)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_symbol_entry * symbol = NULL;\n\tint index;\n\n\tif (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {\n\t\tdev_err(chip->card->dev, \"dsp_spos: symbol table is full\\n\");\n\t\treturn NULL;\n\t}\n  \n\tif (cs46xx_dsp_lookup_symbol(chip,\n\t\t\t\t     symbol_name,\n\t\t\t\t     type) != NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol <%s> duplicated\\n\", symbol_name);\n\t\treturn NULL;\n\t}\n\n\tindex = find_free_symbol_index (ins);\n\n\tstrcpy (ins->symbol_table.symbols[index].symbol_name, symbol_name);\n\tins->symbol_table.symbols[index].address = address;\n\tins->symbol_table.symbols[index].symbol_type = type;\n\tins->symbol_table.symbols[index].module = NULL;\n\tins->symbol_table.symbols[index].deleted = 0;\n\tsymbol = (ins->symbol_table.symbols + index);\n\n\tif (index > ins->symbol_table.highest_frag_index) \n\t\tins->symbol_table.highest_frag_index = index;\n\n\tif (index == ins->symbol_table.nsymbols)\n\t\tins->symbol_table.nsymbols++;  \n\n\treturn symbol;\n}\n\nstruct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)\n{\n\tstruct dsp_spos_instance * ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);\n\n\tif (ins == NULL)\n\t\treturn NULL;\n\n\t \n\tins->symbol_table.symbols =\n\t\tvmalloc(array_size(DSP_MAX_SYMBOLS,\n\t\t\t\t   sizeof(struct dsp_symbol_entry)));\n\tins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);\n\tins->modules = kmalloc_array(DSP_MAX_MODULES,\n\t\t\t\t     sizeof(struct dsp_module_desc),\n\t\t\t\t     GFP_KERNEL);\n\tif (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {\n\t\tcs46xx_dsp_spos_destroy(chip);\n\t\tgoto error;\n\t}\n\tins->symbol_table.nsymbols = 0;\n\tins->symbol_table.highest_frag_index = 0;\n\tins->code.offset = 0;\n\tins->code.size = 0;\n\tins->nscb = 0;\n\tins->ntask = 0;\n\tins->nmodules = 0;\n\n\t \n\tins->spdif_in_sample_rate = 48000;\n\n\t \n\tins->dac_volume_right = 0x8000;\n\tins->dac_volume_left = 0x8000;\n\tins->spdif_input_volume_right = 0x8000;\n\tins->spdif_input_volume_left = 0x8000;\n\n\t \n\tins->spdif_csuv_default =\n\t\tins->spdif_csuv_stream =\n\t    ((unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF        & 0xff)) << 24) |\n\t    ((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |\n\t     (unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |\n\t   (1 << 13) | (1 << 12);\n\n\treturn ins;\n\nerror:\n\tkfree(ins->modules);\n\tkfree(ins->code.data);\n\tvfree(ins->symbol_table.symbols);\n\tkfree(ins);\n\treturn NULL;\n}\n\nvoid  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)\n{\n\tint i;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(!ins))\n\t\treturn;\n\n\tmutex_lock(&chip->spos_mutex);\n\tfor (i = 0; i < ins->nscb; ++i) {\n\t\tif (ins->scbs[i].deleted) continue;\n\n\t\tcs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );\n#ifdef CONFIG_PM_SLEEP\n\t\tkfree(ins->scbs[i].data);\n#endif\n\t}\n\n\tkfree(ins->code.data);\n\tvfree(ins->symbol_table.symbols);\n\tkfree(ins->modules);\n\tkfree(ins);\n\tmutex_unlock(&chip->spos_mutex);\n}\n\nstatic int dsp_load_parameter(struct snd_cs46xx *chip,\n\t\t\t      struct dsp_segment_desc *parameter)\n{\n\tu32 doffset, dsize;\n\n\tif (!parameter) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"dsp_spos: module got no parameter segment\\n\");\n\t\treturn 0;\n\t}\n\n\tdoffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);\n\tdsize   = parameter->size * 4;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"dsp_spos: downloading parameter data to chip (%08x-%08x)\\n\",\n\t\t    doffset,doffset + dsize);\n\tif (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: failed to download parameter data to DSP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dsp_load_sample(struct snd_cs46xx *chip,\n\t\t\t   struct dsp_segment_desc *sample)\n{\n\tu32 doffset, dsize;\n\n\tif (!sample) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"dsp_spos: module got no sample segment\\n\");\n\t\treturn 0;\n\t}\n\n\tdoffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);\n\tdsize   =  sample->size * 4;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"dsp_spos: downloading sample data to chip (%08x-%08x)\\n\",\n\t\t    doffset,doffset + dsize);\n\n\tif (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: failed to sample data to DSP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_segment_desc * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);\n\tu32 doffset, dsize;\n\tint err;\n\n\tif (ins->nmodules == DSP_MAX_MODULES - 1) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: to many modules loaded into DSP\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(chip->card->dev,\n\t\t\"dsp_spos: loading module %s into DSP\\n\", module->module_name);\n  \n\tif (ins->nmodules == 0) {\n\t\tdev_dbg(chip->card->dev, \"dsp_spos: clearing parameter area\\n\");\n\t\tsnd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);\n\t}\n  \n\terr = dsp_load_parameter(chip, get_segment_desc(module,\n\t\t\t\t\t\t\tSEGTYPE_SP_PARAMETER));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ins->nmodules == 0) {\n\t\tdev_dbg(chip->card->dev, \"dsp_spos: clearing sample area\\n\");\n\t\tsnd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);\n\t}\n\n\terr = dsp_load_sample(chip, get_segment_desc(module,\n\t\t\t\t\t\t     SEGTYPE_SP_SAMPLE));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ins->nmodules == 0) {\n\t\tdev_dbg(chip->card->dev, \"dsp_spos: clearing code area\\n\");\n\t\tsnd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);\n\t}\n\n\tif (code == NULL) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"dsp_spos: module got no code segment\\n\");\n\t} else {\n\t\tif (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: no space available in DSP\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmodule->load_address = ins->code.offset;\n\t\tmodule->overlay_begin_address = 0x000;\n\n\t\t \n\t\tif (snd_BUG_ON(!module->symbol_table.symbols))\n\t\t\treturn -ENOMEM;\n\t\tif (add_symbols(chip,module)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: failed to load symbol table\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n    \n\t\tdoffset = (code->offset * 4 + ins->code.offset * 4 + DSP_CODE_BYTE_OFFSET);\n\t\tdsize   = code->size * 4;\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"dsp_spos: downloading code to chip (%08x-%08x)\\n\",\n\t\t\t    doffset,doffset + dsize);   \n\n\t\tmodule->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);\n\n\t\tif (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"dsp_spos: failed to download code to DSP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tins->code.offset += code->size;\n\t}\n\n\t \n\tins->modules[ins->nmodules] = *module;\n\tins->nmodules++;\n\n\treturn 0;\n}\n\nstruct dsp_symbol_entry *\ncs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symbol_type)\n{\n\tint i;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\n\n\t\tif (ins->symbol_table.symbols[i].deleted)\n\t\t\tcontinue;\n\n\t\tif (!strcmp(ins->symbol_table.symbols[i].symbol_name,symbol_name) &&\n\t\t    ins->symbol_table.symbols[i].symbol_type == symbol_type) {\n\t\t\treturn (ins->symbol_table.symbols + i);\n\t\t}\n\t}\n\n#if 0\n\tdev_err(chip->card->dev, \"dsp_spos: symbol <%s> type %02x not found\\n\",\n\t\tsymbol_name,symbol_type);\n#endif\n\n\treturn NULL;\n}\n\n\n#ifdef CONFIG_SND_PROC_FS\nstatic struct dsp_symbol_entry *\ncs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)\n{\n\tint i;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\n\n\t\tif (ins->symbol_table.symbols[i].deleted)\n\t\t\tcontinue;\n\n\t\tif (ins->symbol_table.symbols[i].address == address &&\n\t\t    ins->symbol_table.symbols[i].symbol_type == symbol_type) {\n\t\t\treturn (ins->symbol_table.symbols + i);\n\t\t}\n\t}\n\n\n\treturn NULL;\n}\n\n\nstatic void cs46xx_dsp_proc_symbol_table_read (struct snd_info_entry *entry,\n\t\t\t\t\t       struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i;\n\n\tsnd_iprintf(buffer, \"SYMBOLS:\\n\");\n\tfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\n\t\tchar *module_str = \"system\";\n\n\t\tif (ins->symbol_table.symbols[i].deleted)\n\t\t\tcontinue;\n\n\t\tif (ins->symbol_table.symbols[i].module != NULL) {\n\t\t\tmodule_str = ins->symbol_table.symbols[i].module->module_name;\n\t\t}\n\n    \n\t\tsnd_iprintf(buffer, \"%04X <%02X> %s [%s]\\n\",\n\t\t\t    ins->symbol_table.symbols[i].address,\n\t\t\t    ins->symbol_table.symbols[i].symbol_type,\n\t\t\t    ins->symbol_table.symbols[i].symbol_name,\n\t\t\t    module_str);    \n\t}\n}\n\n\nstatic void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,\n\t\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i,j;\n\n\tmutex_lock(&chip->spos_mutex);\n\tsnd_iprintf(buffer, \"MODULES:\\n\");\n\tfor ( i = 0; i < ins->nmodules; ++i ) {\n\t\tsnd_iprintf(buffer, \"\\n%s:\\n\", ins->modules[i].module_name);\n\t\tsnd_iprintf(buffer, \"   %d symbols\\n\", ins->modules[i].symbol_table.nsymbols);\n\t\tsnd_iprintf(buffer, \"   %d fixups\\n\", ins->modules[i].nfixups);\n\n\t\tfor (j = 0; j < ins->modules[i].nsegments; ++ j) {\n\t\t\tstruct dsp_segment_desc * desc = (ins->modules[i].segments + j);\n\t\t\tsnd_iprintf(buffer, \"   segment %02x offset %08x size %08x\\n\",\n\t\t\t\t    desc->segment_type,desc->offset, desc->size);\n\t\t}\n\t}\n\tmutex_unlock(&chip->spos_mutex);\n}\n\nstatic void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,\n\t\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i, j, col;\n\tvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\n\n\tmutex_lock(&chip->spos_mutex);\n\tsnd_iprintf(buffer, \"TASK TREES:\\n\");\n\tfor ( i = 0; i < ins->ntask; ++i) {\n\t\tsnd_iprintf(buffer,\"\\n%04x %s:\\n\",ins->tasks[i].address,ins->tasks[i].task_name);\n\n\t\tfor (col = 0,j = 0;j < ins->tasks[i].size; j++,col++) {\n\t\t\tu32 val;\n\t\t\tif (col == 4) {\n\t\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\t\tcol = 0;\n\t\t\t}\n\t\t\tval = readl(dst + (ins->tasks[i].address + j) * sizeof(u32));\n\t\t\tsnd_iprintf(buffer,\"%08x \",val);\n\t\t}\n\t}\n\n\tsnd_iprintf(buffer,\"\\n\");  \n\tmutex_unlock(&chip->spos_mutex);\n}\n\nstatic void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,\n\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i;\n\n\tmutex_lock(&chip->spos_mutex);\n\tsnd_iprintf(buffer, \"SCB's:\\n\");\n\tfor ( i = 0; i < ins->nscb; ++i) {\n\t\tif (ins->scbs[i].deleted)\n\t\t\tcontinue;\n\t\tsnd_iprintf(buffer,\"\\n%04x %s:\\n\\n\",ins->scbs[i].address,ins->scbs[i].scb_name);\n\n\t\tif (ins->scbs[i].parent_scb_ptr != NULL) {\n\t\t\tsnd_iprintf(buffer,\"parent [%s:%04x] \", \n\t\t\t\t    ins->scbs[i].parent_scb_ptr->scb_name,\n\t\t\t\t    ins->scbs[i].parent_scb_ptr->address);\n\t\t} else snd_iprintf(buffer,\"parent [none] \");\n\n\t\tsnd_iprintf(buffer,\"sub_list_ptr [%s:%04x]\\nnext_scb_ptr [%s:%04x]  task_entry [%s:%04x]\\n\",\n\t\t\t    ins->scbs[i].sub_list_ptr->scb_name,\n\t\t\t    ins->scbs[i].sub_list_ptr->address,\n\t\t\t    ins->scbs[i].next_scb_ptr->scb_name,\n\t\t\t    ins->scbs[i].next_scb_ptr->address,\n\t\t\t    ins->scbs[i].task_entry->symbol_name,\n\t\t\t    ins->scbs[i].task_entry->address);\n\t}\n\n\tsnd_iprintf(buffer,\"\\n\");\n\tmutex_unlock(&chip->spos_mutex);\n}\n\nstatic void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry *entry,\n\t\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\t \n\tunsigned int i, col = 0;\n\tvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\n\tstruct dsp_symbol_entry * symbol; \n\n\tfor (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tsymbol = cs46xx_dsp_lookup_symbol_addr(chip, i / sizeof(u32), SYMBOL_PARAMETER);\n\t\tif (symbol) {\n\t\t\tcol = 0;\n\t\t\tsnd_iprintf (buffer,\"\\n%s:\\n\",symbol->symbol_name);\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \", i / (unsigned int)sizeof(u32));\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n}\n\nstatic void cs46xx_dsp_proc_sample_dump_read (struct snd_info_entry *entry,\n\t\t\t\t\t      struct snd_info_buffer *buffer)\n{\n\tstruct snd_cs46xx *chip = entry->private_data;\n\tint i,col = 0;\n\tvoid __iomem *dst = chip->region.idx[2].remap_addr;\n\n\tsnd_iprintf(buffer,\"PCMREADER:\\n\");\n\tfor (i = PCM_READER_BUF1;i < PCM_READER_BUF1 + 0x30; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\tsnd_iprintf(buffer,\"\\nMIX_SAMPLE_BUF1:\\n\");\n\n\tcol = 0;\n\tfor (i = MIX_SAMPLE_BUF1;i < MIX_SAMPLE_BUF1 + 0x40; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\tsnd_iprintf(buffer,\"\\nSRC_TASK_SCB1:\\n\");\n\tcol = 0;\n\tfor (i = 0x2480 ; i < 0x2480 + 0x40 ; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\t\t\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\n\tsnd_iprintf(buffer,\"\\nSPDIFO_BUFFER:\\n\");\n\tcol = 0;\n\tfor (i = SPDIFO_IP_OUTPUT_BUFFER1;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x30; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\tsnd_iprintf(buffer,\"\\n...\\n\");\n\tcol = 0;\n\n\tfor (i = SPDIFO_IP_OUTPUT_BUFFER1+0xD0;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x110; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\n\tsnd_iprintf(buffer,\"\\nOUTPUT_SNOOP:\\n\");\n\tcol = 0;\n\tfor (i = OUTPUT_SNOOP_BUFFER;i < OUTPUT_SNOOP_BUFFER + 0x40; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\n\tsnd_iprintf(buffer,\"\\nCODEC_INPUT_BUF1: \\n\");\n\tcol = 0;\n\tfor (i = CODEC_INPUT_BUF1;i < CODEC_INPUT_BUF1 + 0x40; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n#if 0\n\tsnd_iprintf(buffer,\"\\nWRITE_BACK_BUF1: \\n\");\n\tcol = 0;\n\tfor (i = WRITE_BACK_BUF1;i < WRITE_BACK_BUF1 + 0x40; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n#endif\n\n\tsnd_iprintf(buffer,\"\\nSPDIFI_IP_OUTPUT_BUFFER1: \\n\");\n\tcol = 0;\n\tfor (i = SPDIFI_IP_OUTPUT_BUFFER1;i < SPDIFI_IP_OUTPUT_BUFFER1 + 0x80; i += sizeof(u32),col ++) {\n\t\tif (col == 4) {\n\t\t\tsnd_iprintf(buffer,\"\\n\");\n\t\t\tcol = 0;\n\t\t}\n\n\t\tif (col == 0) {\n\t\t\tsnd_iprintf(buffer, \"%04X \",i);\n\t\t}\n\t\t\n\t\tsnd_iprintf(buffer,\"%08X \",readl(dst + i));\n\t}\n\tsnd_iprintf(buffer,\"\\n\");\n}\n\nint cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)\n{\n\tstruct snd_info_entry *entry;\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i;\n\n\tins->snd_card = card;\n\n\tentry = snd_info_create_card_entry(card, \"dsp\", card->proc_root);\n\tif (entry)\n\t\tentry->mode = S_IFDIR | 0555;\n\tins->proc_dsp_dir = entry;\n\n\tif (!ins->proc_dsp_dir)\n\t\treturn -ENOMEM;\n\n\tentry = snd_info_create_card_entry(card, \"spos_symbols\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_symbol_table_read);\n    \n\tentry = snd_info_create_card_entry(card, \"spos_modules\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_modules_read);\n\n\tentry = snd_info_create_card_entry(card, \"parameter\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_parameter_dump_read);\n\n\tentry = snd_info_create_card_entry(card, \"sample\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_sample_dump_read);\n\n\tentry = snd_info_create_card_entry(card, \"task_tree\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_task_tree_read);\n\n\tentry = snd_info_create_card_entry(card, \"scb_info\",\n\t\t\t\t\t   ins->proc_dsp_dir);\n\tif (entry)\n\t\tsnd_info_set_text_ops(entry, chip,\n\t\t\t\t      cs46xx_dsp_proc_scb_read);\n\n\tmutex_lock(&chip->spos_mutex);\n\t \n\tfor (i = 0; i < ins->nscb; ++i) {\n\t\tif (ins->scbs[i].deleted) continue;\n\n\t\tcs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));\n\t}\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_proc_done (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i;\n\n\tif (!ins)\n\t\treturn 0;\n\n\tmutex_lock(&chip->spos_mutex);\n\tfor (i = 0; i < ins->nscb; ++i) {\n\t\tif (ins->scbs[i].deleted) continue;\n\t\tcs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );\n\t}\n\tmutex_unlock(&chip->spos_mutex);\n\n\tsnd_info_free_entry(ins->proc_dsp_dir);\n\tins->proc_dsp_dir = NULL;\n\n\treturn 0;\n}\n#endif  \n\nstatic void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,\n\t\t\t\t   u32  dest, int size)\n{\n\tvoid __iomem *spdst = chip->region.idx[1].remap_addr + \n\t\tDSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);\n\tint i;\n\n\tfor (i = 0; i < size; ++i) {\n\t\tdev_dbg(chip->card->dev, \"addr %p, val %08x\\n\",\n\t\t\tspdst, task_data[i]);\n\t\twritel(task_data[i],spdst);\n\t\tspdst += sizeof(u32);\n\t}\n}\n\nstatic void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)\n{\n\tvoid __iomem *spdst = chip->region.idx[1].remap_addr + \n\t\tDSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);\n\tint i;\n\n\tfor (i = 0; i < 0x10; ++i) {\n\t\tdev_dbg(chip->card->dev, \"addr %p, val %08x\\n\",\n\t\t\tspdst, scb_data[i]);\n\t\twritel(scb_data[i],spdst);\n\t\tspdst += sizeof(u32);\n\t}\n}\n\nstatic int find_free_scb_index (struct dsp_spos_instance * ins)\n{\n\tint index = ins->nscb, i;\n\n\tfor (i = ins->scb_highest_frag_index; i < ins->nscb; ++i) {\n\t\tif (ins->scbs[i].deleted) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn index;\n}\n\nstatic struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * name, u32 dest)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * desc = NULL;\n\tint index;\n\n\tif (ins->nscb == DSP_MAX_SCB_DESC - 1) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: got no place for other SCB\\n\");\n\t\treturn NULL;\n\t}\n\n\tindex = find_free_scb_index (ins);\n\n\tmemset(&ins->scbs[index], 0, sizeof(ins->scbs[index]));\n\tstrcpy(ins->scbs[index].scb_name, name);\n\tins->scbs[index].address = dest;\n\tins->scbs[index].index = index;\n\tins->scbs[index].ref_count = 1;\n\n\tdesc = (ins->scbs + index);\n\tins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);\n\n\tif (index > ins->scb_highest_frag_index)\n\t\tins->scb_highest_frag_index = index;\n\n\tif (index == ins->nscb)\n\t\tins->nscb++;\n\n\treturn desc;\n}\n\nstatic struct dsp_task_descriptor *\n_map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_task_descriptor * desc = NULL;\n\n\tif (ins->ntask == DSP_MAX_TASK_DESC - 1) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: got no place for other TASK\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (name)\n\t\tstrcpy(ins->tasks[ins->ntask].task_name, name);\n\telse\n\t\tstrcpy(ins->tasks[ins->ntask].task_name, \"(NULL)\");\n\tins->tasks[ins->ntask].address = dest;\n\tins->tasks[ins->ntask].size = size;\n\n\t \n\tins->tasks[ins->ntask].index = ins->ntask;\n\tdesc = (ins->tasks + ins->ntask);\n\tins->ntask++;\n\n\tif (name)\n\t\tadd_symbol (chip,name,dest,SYMBOL_PARAMETER);\n\treturn desc;\n}\n\n#define SCB_BYTES\t(0x10 * 4)\n\nstruct dsp_scb_descriptor *\ncs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest)\n{\n\tstruct dsp_scb_descriptor * desc;\n\n#ifdef CONFIG_PM_SLEEP\n\t \n\tscb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);\n\tif (!scb_data)\n\t\treturn NULL;\n#endif\n\n\tdesc = _map_scb (chip,name,dest);\n\tif (desc) {\n\t\tdesc->data = scb_data;\n\t\t_dsp_create_scb(chip,scb_data,dest);\n\t} else {\n\t\tdev_err(chip->card->dev, \"dsp_spos: failed to map SCB\\n\");\n#ifdef CONFIG_PM_SLEEP\n\t\tkfree(scb_data);\n#endif\n\t}\n\n\treturn desc;\n}\n\n\nstatic struct dsp_task_descriptor *\ncs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_data,\n\t\t\t     u32 dest, int size)\n{\n\tstruct dsp_task_descriptor * desc;\n\n\tdesc = _map_task_tree (chip,name,dest,size);\n\tif (desc) {\n\t\tdesc->data = task_data;\n\t\t_dsp_create_task_tree(chip,task_data,dest,size);\n\t} else {\n\t\tdev_err(chip->card->dev, \"dsp_spos: failed to map TASK\\n\");\n\t}\n\n\treturn desc;\n}\n\nint cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_symbol_entry * fg_task_tree_header_code;\n\tstruct dsp_symbol_entry * task_tree_header_code;\n\tstruct dsp_symbol_entry * task_tree_thread;\n\tstruct dsp_symbol_entry * null_algorithm;\n\tstruct dsp_symbol_entry * magic_snoop_task;\n\n\tstruct dsp_scb_descriptor * timing_master_scb;\n\tstruct dsp_scb_descriptor * codec_out_scb;\n\tstruct dsp_scb_descriptor * codec_in_scb;\n\tstruct dsp_scb_descriptor * src_task_scb;\n\tstruct dsp_scb_descriptor * master_mix_scb;\n\tstruct dsp_scb_descriptor * rear_mix_scb;\n\tstruct dsp_scb_descriptor * record_mix_scb;\n\tstruct dsp_scb_descriptor * write_back_scb;\n\tstruct dsp_scb_descriptor * vari_decimate_scb;\n\tstruct dsp_scb_descriptor * rear_codec_out_scb;\n\tstruct dsp_scb_descriptor * clfe_codec_out_scb;\n\tstruct dsp_scb_descriptor * magic_snoop_scb;\n\t\n\tint fifo_addr, fifo_span, valid_slots;\n\n\tstatic const struct dsp_spos_control_block sposcb = {\n\t\t  HFG_TREE_SCB,HFG_STACK,\n\t\t  SPOSCB_ADDR,BG_TREE_SCB_ADDR,\n\t\t  DSP_SPOS_DC,0,\n\t\t  DSP_SPOS_DC,DSP_SPOS_DC,\n\t\t  0,0,\n\t\t  DSP_SPOS_UU,0,\n\t\t  FG_TASK_HEADER_ADDR,0,\n\t\t  0,0,\n\t\t  DSP_SPOS_UU,DSP_SPOS_DC,\n\t\t  0,\n\t\t  0,HFG_FIRST_EXECUTE_MODE,\n\t\t  DSP_SPOS_UU,DSP_SPOS_UU,\n\t\t  DSP_SPOS_DC_DC,\n\t\t  DSP_SPOS_DC_DC,\n\t\t  DSP_SPOS_DC_DC,\n\t\t  DSP_SPOS_DC_DC\n\t};\n\n\tcs46xx_dsp_create_task_tree(chip, \"sposCB\", (u32 *)&sposcb, SPOSCB_ADDR, 0x10);\n\n\tnull_algorithm  = cs46xx_dsp_lookup_symbol(chip, \"NULLALGORITHM\", SYMBOL_CODE);\n\tif (null_algorithm == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol NULLALGORITHM not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, \"FGTASKTREEHEADERCODE\", SYMBOL_CODE);  \n\tif (fg_task_tree_header_code == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol FGTASKTREEHEADERCODE not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttask_tree_header_code = cs46xx_dsp_lookup_symbol(chip, \"TASKTREEHEADERCODE\", SYMBOL_CODE);  \n\tif (task_tree_header_code == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol TASKTREEHEADERCODE not found\\n\");\n\t\treturn -EIO;\n\t}\n  \n\ttask_tree_thread = cs46xx_dsp_lookup_symbol(chip, \"TASKTREETHREAD\", SYMBOL_CODE);\n\tif (task_tree_thread == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol TASKTREETHREAD not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmagic_snoop_task = cs46xx_dsp_lookup_symbol(chip, \"MAGICSNOOPTASK\", SYMBOL_CODE);\n\tif (magic_snoop_task == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol MAGICSNOOPTASK not found\\n\");\n\t\treturn -EIO;\n\t}\n  \n\t{\n\t\t \n\t\tstatic struct dsp_generic_scb null_scb = {\n\t\t\t{ 0, 0, 0, 0 },\n\t\t\t{ 0, 0, 0, 0, 0 },\n\t\t\tNULL_SCB_ADDR, NULL_SCB_ADDR,\n\t\t\t0, 0, 0, 0, 0,\n\t\t\t{\n\t\t\t\t0,0,\n\t\t\t\t0,0,\n\t\t\t}\n\t\t};\n\n\t\tnull_scb.entry_point = null_algorithm->address;\n\t\tins->the_null_scb = cs46xx_dsp_create_scb(chip, \"nullSCB\", (u32 *)&null_scb, NULL_SCB_ADDR);\n\t\tins->the_null_scb->task_entry = null_algorithm;\n\t\tins->the_null_scb->sub_list_ptr = ins->the_null_scb;\n\t\tins->the_null_scb->next_scb_ptr = ins->the_null_scb;\n\t\tins->the_null_scb->parent_scb_ptr = NULL;\n\t\tcs46xx_dsp_proc_register_scb_desc (chip,ins->the_null_scb);\n\t}\n\n\t{\n\t\t \n\t\tstatic struct dsp_task_tree_control_block fg_task_tree_hdr =  {\n\t\t\t{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  0x0000,DSP_SPOS_DC,\n\t\t\t  DSP_SPOS_DC, DSP_SPOS_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC,DSP_SPOS_DC },\n    \n\t\t\t{\n\t\t\t\tBG_TREE_SCB_ADDR,TIMINGMASTER_SCB_ADDR, \n\t\t\t\t0,\n\t\t\t\tFG_TASK_HEADER_ADDR + TCBData,                  \n\t\t\t},\n\n\t\t\t{    \n\t\t\t\t4,0,\n\t\t\t\t1,0,\n\t\t\t\t2,SPOSCB_ADDR + HFGFlags,\n\t\t\t\t0,0,\n\t\t\t\tFG_TASK_HEADER_ADDR + TCBContextBlk,FG_STACK\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tDSP_SPOS_DC,0,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_UU,1,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC \n\t\t\t},                                               \n\t\t\t{ \n\t\t\t\tFG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,\n\t\t\t\t0,0\n\t\t\t}\n\t\t};\n\n\t\tfg_task_tree_hdr.links.entry_point = fg_task_tree_header_code->address;\n\t\tfg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;\n\t\tcs46xx_dsp_create_task_tree(chip,\"FGtaskTreeHdr\",(u32 *)&fg_task_tree_hdr,FG_TASK_HEADER_ADDR,0x35);\n\t}\n\n\n\t{\n\t\t \n\t\tstatic struct dsp_task_tree_control_block bg_task_tree_hdr =  {\n\t\t\t{ DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC, DSP_SPOS_DC,\n\t\t\t  DSP_SPOS_DC, DSP_SPOS_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC_DC,\n\t\t\t  DSP_SPOS_DC,DSP_SPOS_DC },\n    \n\t\t\t{\n\t\t\t\tNULL_SCB_ADDR,NULL_SCB_ADDR,   \n\t\t\t\t0,\n\t\t\t\tBG_TREE_SCB_ADDR + TCBData,\n\t\t\t},\n\n\t\t\t{    \n\t\t\t\t9999,0,\n\t\t\t\t0,1,\n\t\t\t\t0,SPOSCB_ADDR + HFGFlags,\n\t\t\t\t0,0,\n\t\t\t\tBG_TREE_SCB_ADDR + TCBContextBlk,BG_STACK\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tDSP_SPOS_DC,0,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DC,DSP_SPOS_DC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_UU,1,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC,\n\t\t\t\tDSP_SPOS_DCDC \n\t\t\t},                                               \n\t\t\t{ \n\t\t\t\tBG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,\n\t\t\t\t0,0\n\t\t\t}\n\t\t};\n\n\t\tbg_task_tree_hdr.links.entry_point = task_tree_header_code->address;\n\t\tbg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;\n\t\tcs46xx_dsp_create_task_tree(chip,\"BGtaskTreeHdr\",(u32 *)&bg_task_tree_hdr,BG_TREE_SCB_ADDR,0x35);\n\t}\n\n\t \n\ttiming_master_scb = cs46xx_dsp_create_timing_master_scb(chip);\n\n\t \n\tcodec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,\"CodecOutSCB_I\",0x0010,0x0000,\n\t\t\t\t\t\t\tMASTERMIX_SCB_ADDR,\n\t\t\t\t\t\t\tCODECOUT_SCB_ADDR,timing_master_scb,\n\t\t\t\t\t\t\tSCB_ON_PARENT_SUBLIST_SCB);\n\n\tif (!codec_out_scb) goto _fail_end;\n\t \n\tmaster_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,\"MasterMixSCB\",\n\t\t\t\t\t\t\tMIX_SAMPLE_BUF1,MASTERMIX_SCB_ADDR,\n\t\t\t\t\t\t\tcodec_out_scb,\n\t\t\t\t\t\t\tSCB_ON_PARENT_SUBLIST_SCB);\n\tins->master_mix_scb = master_mix_scb;\n\n\tif (!master_mix_scb) goto _fail_end;\n\n\t \n\tcodec_in_scb = cs46xx_dsp_create_codec_in_scb(chip,\"CodecInSCB\",0x0010,0x00A0,\n\t\t\t\t\t\t      CODEC_INPUT_BUF1,\n\t\t\t\t\t\t      CODECIN_SCB_ADDR,codec_out_scb,\n\t\t\t\t\t\t      SCB_ON_PARENT_NEXT_SCB);\n\tif (!codec_in_scb) goto _fail_end;\n\tins->codec_in_scb = codec_in_scb;\n\n\t \n\twrite_back_scb = cs46xx_dsp_create_mix_to_ostream_scb(chip,\"WriteBackSCB\",\n\t\t\t\t\t\t\t      WRITE_BACK_BUF1,WRITE_BACK_SPB,\n\t\t\t\t\t\t\t      WRITEBACK_SCB_ADDR,\n\t\t\t\t\t\t\t      timing_master_scb,\n\t\t\t\t\t\t\t      SCB_ON_PARENT_NEXT_SCB);\n\tif (!write_back_scb) goto _fail_end;\n\n\t{\n\t\tstatic struct dsp_mix2_ostream_spb mix2_ostream_spb = {\n\t\t\t0x00020000,\n\t\t\t0x0000ffff\n\t\t};\n    \n\t\tif (!cs46xx_dsp_create_task_tree(chip, NULL,\n\t\t\t\t\t\t (u32 *)&mix2_ostream_spb,\n\t\t\t\t\t\t WRITE_BACK_SPB, 2))\n\t\t\tgoto _fail_end;\n\t}\n\n\t \n\tvari_decimate_scb = cs46xx_dsp_create_vari_decimate_scb(chip,\"VariDecimateSCB\",\n\t\t\t\t\t\t\t\tVARI_DECIMATE_BUF0,\n\t\t\t\t\t\t\t\tVARI_DECIMATE_BUF1,\n\t\t\t\t\t\t\t\tVARIDECIMATE_SCB_ADDR,\n\t\t\t\t\t\t\t\twrite_back_scb,\n\t\t\t\t\t\t\t\tSCB_ON_PARENT_SUBLIST_SCB);\n\tif (!vari_decimate_scb) goto _fail_end;\n\n\t \n\trecord_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,\"RecordMixerSCB\",\n\t\t\t\t\t\t\tMIX_SAMPLE_BUF2,\n\t\t\t\t\t\t\tRECORD_MIXER_SCB_ADDR,\n\t\t\t\t\t\t\tvari_decimate_scb,\n\t\t\t\t\t\t\tSCB_ON_PARENT_SUBLIST_SCB);\n\tins->record_mixer_scb = record_mix_scb;\n\n\tif (!record_mix_scb) goto _fail_end;\n\n\tvalid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);\n\n\tif (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))\n\t\tgoto _fail_end;\n\n\tif (chip->nr_ac97_codecs == 1) {\n\t\t \n\t\tfifo_addr = 0x20;\n\t\tfifo_span = 0x60;\n\n\t\t \n\t\tvalid_slots |= ACOSV_SLV5 | ACOSV_SLV11;\n\t} else {\n\t\t \n\t\tfifo_addr = 0x40;\n\t\tfifo_span = 0x10;\n\n\t\t \n\t\tvalid_slots |= ACOSV_SLV7 | ACOSV_SLV8;\n\t}\n\t \n\trear_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,\"CodecOutSCB_Rear\",fifo_span,fifo_addr,\n\t\t\t\t\t\t\t     REAR_MIXER_SCB_ADDR,\n\t\t\t\t\t\t\t     REAR_CODECOUT_SCB_ADDR,codec_in_scb,\n\t\t\t\t\t\t\t     SCB_ON_PARENT_NEXT_SCB);\n\tif (!rear_codec_out_scb) goto _fail_end;\n\t\n\t\n\t \n\trear_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,\"RearMixerSCB\",\n\t\t\t\t\t\t      MIX_SAMPLE_BUF3,\n\t\t\t\t\t\t      REAR_MIXER_SCB_ADDR,\n\t\t\t\t\t\t      rear_codec_out_scb,\n\t\t\t\t\t\t      SCB_ON_PARENT_SUBLIST_SCB);\n\tins->rear_mix_scb = rear_mix_scb;\n\tif (!rear_mix_scb) goto _fail_end;\n\t\n\tif (chip->nr_ac97_codecs == 2) {\n\t\t \n\t\tclfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,\"CodecOutSCB_CLFE\",0x0030,0x0030,\n\t\t\t\t\t\t\t\t     CLFE_MIXER_SCB_ADDR,\n\t\t\t\t\t\t\t\t     CLFE_CODEC_SCB_ADDR,\n\t\t\t\t\t\t\t\t     rear_codec_out_scb,\n\t\t\t\t\t\t\t\t     SCB_ON_PARENT_NEXT_SCB);\n\t\tif (!clfe_codec_out_scb) goto _fail_end;\n\t\t\n\t\t\n\t\t \n\t\tins->center_lfe_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,\"CLFEMixerSCB\",\n\t\t\t\t\t\t\t\t\t MIX_SAMPLE_BUF4,\n\t\t\t\t\t\t\t\t\t CLFE_MIXER_SCB_ADDR,\n\t\t\t\t\t\t\t\t\t clfe_codec_out_scb,\n\t\t\t\t\t\t\t\t\t SCB_ON_PARENT_SUBLIST_SCB);\n\t\tif (!ins->center_lfe_mix_scb) goto _fail_end;\n\n\t\t \n\t\tvalid_slots |= ACOSV_SLV6 | ACOSV_SLV9;\n\t} else {\n\t\tclfe_codec_out_scb = rear_codec_out_scb;\n\t\tins->center_lfe_mix_scb = rear_mix_scb;\n\t}\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);\n\n\t \n\tmagic_snoop_scb = cs46xx_dsp_create_magic_snoop_scb (chip,\"MagicSnoopSCB_I\",OUTPUTSNOOP_SCB_ADDR,\n\t\t\t\t\t\t\t     OUTPUT_SNOOP_BUFFER,\n\t\t\t\t\t\t\t     codec_out_scb,\n\t\t\t\t\t\t\t     clfe_codec_out_scb,\n\t\t\t\t\t\t\t     SCB_ON_PARENT_NEXT_SCB);\n\n    \n\tif (!magic_snoop_scb) goto _fail_end;\n\tins->ref_snoop_scb = magic_snoop_scb;\n\n\t \n\tif (!cs46xx_dsp_create_spio_write_scb(chip,\"SPIOWriteSCB\",SPIOWRITE_SCB_ADDR,\n\t\t\t\t\t      magic_snoop_scb,\n\t\t\t\t\t      SCB_ON_PARENT_NEXT_SCB))\n\t\tgoto _fail_end;\n\n\t \n\tsrc_task_scb = cs46xx_dsp_create_src_task_scb(chip,\"SrcTaskSCB_SPDIFI\",\n\t\t\t\t\t\t      ins->spdif_in_sample_rate,\n\t\t\t\t\t\t      SRC_OUTPUT_BUF1,\n\t\t\t\t\t\t      SRC_DELAY_BUF1,SRCTASK_SCB_ADDR,\n\t\t\t\t\t\t      master_mix_scb,\n\t\t\t\t\t\t      SCB_ON_PARENT_SUBLIST_SCB,1);\n\n\tif (!src_task_scb) goto _fail_end;\n\tcs46xx_src_unlink(chip,src_task_scb);\n\n\t \n\tins->spdif_in_src = src_task_scb;\n\n\tcs46xx_dsp_async_init(chip,timing_master_scb);\n\treturn 0;\n\n _fail_end:\n\tdev_err(chip->card->dev, \"dsp_spos: failed to setup SCB's in DSP\\n\");\n\treturn -EINVAL;\n}\n\nstatic int cs46xx_dsp_async_init (struct snd_cs46xx *chip,\n\t\t\t\t  struct dsp_scb_descriptor * fg_entry)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_symbol_entry * s16_async_codec_input_task;\n\tstruct dsp_symbol_entry * spdifo_task;\n\tstruct dsp_symbol_entry * spdifi_task;\n\tstruct dsp_scb_descriptor * spdifi_scb_desc, * spdifo_scb_desc, * async_codec_scb_desc;\n\n\ts16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, \"S16_ASYNCCODECINPUTTASK\", SYMBOL_CODE);\n\tif (s16_async_codec_input_task == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\\n\");\n\t\treturn -EIO;\n\t}\n\tspdifo_task = cs46xx_dsp_lookup_symbol(chip, \"SPDIFOTASK\", SYMBOL_CODE);\n\tif (spdifo_task == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol SPDIFOTASK not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspdifi_task = cs46xx_dsp_lookup_symbol(chip, \"SPDIFITASK\", SYMBOL_CODE);\n\tif (spdifi_task == NULL) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: symbol SPDIFITASK not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\t{\n\t\t \n\t\tstruct dsp_spdifoscb spdifo_scb = {\n\t\t\t  DSP_SPOS_UUUU,\n\t\t\t{\n\t\t\t\t  0xb0, \n\t\t\t\t  0, \n\t\t\t\t  0, \n\t\t\t\t  0, \n\t\t\t},\n\t\t\t \n\t\t\t  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_256,\n\t\t\t  ( SPDIFO_IP_OUTPUT_BUFFER1 << 0x10 )  |  0xFFFC,\n\t\t\t  0,0, \n\t\t\t  0, \n\t\t\t  FG_TASK_HEADER_ADDR, NULL_SCB_ADDR, \n\t\t\t  spdifo_task->address,\n\t\t\tSPDIFO_SCB_INST + SPDIFOFIFOPointer,\n\t\t\t{\n\t\t\t\t  0x0040,  \n\t\t\t\t  0x20ff,  \n\t\t\t},\n\t\t\t  0x804c,0,\t\t\t\t\t\t\t   \n\t\t\t  0x0108,0x0001,\t\t\t\t\t   \n\t\t\t  DSP_SPOS_UUUU\t  \t\t\t           \n\t\t};\n\n\t\t \n\t\tstruct dsp_spdifiscb spdifi_scb = {\n\t\t\t  DSP_SPOS_UULO,DSP_SPOS_UUHI,\n\t\t\t  0,\n\t\t\t  0,\n\t\t\t  1,4000,          \n\t\t\t  DSP_SPOS_UUUU,  \n\t\t\t  0,DSP_SPOS_UUHI,  \n\t\t\t  DSP_SPOS_UUUU,   \n\t\t\t  DSP_SPOS_UU,DSP_SPOS_DC,   \n\t\t\t  DSP_SPOS_UUUU,\t \n\t\t\t  SPDIFO_SCB_INST, NULL_SCB_ADDR,\n\t\t\t  spdifi_task->address,\n\t\t\tSPDIFI_SCB_INST + SPDIFIFIFOPointer,\n\t\t\t \n\t\t\t  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_128,\n\t\t\t  (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,\n\t\t\t  0x8048,0,\n\t\t\t  0x01f0,0x0001,\n\t\t\t  DSP_SPOS_UUUU  \n\t\t};\n\n\t\t \n\t\tstruct dsp_async_codec_input_scb async_codec_input_scb = {\n\t\t\t  DSP_SPOS_UUUU,\n\t\t\t  0,\n\t\t\t  0,\n\t\t\t  1,4000,\n\t\t\t  0x0118,0x0001,\n\t\t\t  RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_64,\n\t\t\t  (ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,\n\t\t\t  DSP_SPOS_UU,0x3,\n\t\t\t  DSP_SPOS_UUUU,\n\t\t\t  SPDIFI_SCB_INST,NULL_SCB_ADDR,\n\t\t\t  s16_async_codec_input_task->address,\n\t\t\tHFG_TREE_SCB + AsyncCIOFIFOPointer,\n              \n\t\t\t  RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\n\t\t\t  (ASYNC_IP_OUTPUT_BUFFER1 << 0x10),   \n      \n#ifdef UseASER1Input\n\t\t\t \n\t\t\t  0x8042,0,\n      \n\t\t\t \n\t\t\t  0x0100,0x0001,\n      \n#endif\n      \n#ifdef UseASER2Input\n\t\t\t \n\t\t\t  0x8044,0,\n      \n\t\t\t \n\t\t\t  0x0110,0x0001,\n      \n#endif\n      \n\t\t\t \n\t\t\t  0,  \n\t\t};\n\n\t\tspdifo_scb_desc = cs46xx_dsp_create_scb(chip,\"SPDIFOSCB\",(u32 *)&spdifo_scb,SPDIFO_SCB_INST);\n\n\t\tif (snd_BUG_ON(!spdifo_scb_desc))\n\t\t\treturn -EIO;\n\t\tspdifi_scb_desc = cs46xx_dsp_create_scb(chip,\"SPDIFISCB\",(u32 *)&spdifi_scb,SPDIFI_SCB_INST);\n\t\tif (snd_BUG_ON(!spdifi_scb_desc))\n\t\t\treturn -EIO;\n\t\tasync_codec_scb_desc = cs46xx_dsp_create_scb(chip,\"AsynCodecInputSCB\",(u32 *)&async_codec_input_scb, HFG_TREE_SCB);\n\t\tif (snd_BUG_ON(!async_codec_scb_desc))\n\t\t\treturn -EIO;\n\n\t\tasync_codec_scb_desc->parent_scb_ptr = NULL;\n\t\tasync_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;\n\t\tasync_codec_scb_desc->sub_list_ptr = ins->the_null_scb;\n\t\tasync_codec_scb_desc->task_entry = s16_async_codec_input_task;\n\n\t\tspdifi_scb_desc->parent_scb_ptr = async_codec_scb_desc;\n\t\tspdifi_scb_desc->next_scb_ptr = spdifo_scb_desc;\n\t\tspdifi_scb_desc->sub_list_ptr = ins->the_null_scb;\n\t\tspdifi_scb_desc->task_entry = spdifi_task;\n\n\t\tspdifo_scb_desc->parent_scb_ptr = spdifi_scb_desc;\n\t\tspdifo_scb_desc->next_scb_ptr = fg_entry;\n\t\tspdifo_scb_desc->sub_list_ptr = ins->the_null_scb;\n\t\tspdifo_scb_desc->task_entry = spdifo_task;\n\n\t\t \n\t\tfg_entry->parent_scb_ptr = spdifo_scb_desc;\n\n\t\t \n\t\tcs46xx_dsp_proc_register_scb_desc (chip,spdifo_scb_desc);\n\t\tcs46xx_dsp_proc_register_scb_desc (chip,spdifi_scb_desc);\n\t\tcs46xx_dsp_proc_register_scb_desc (chip,async_codec_scb_desc);\n\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ASER_MASTER, 0x1 );\n\t}\n\n\treturn 0;\n}\n\nstatic void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0);\n\n\t \n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, 0x0);\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);\n\n\t \n\tins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;\n}\n\nint cs46xx_dsp_enable_spdif_hw (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\t \n\tcs46xx_dsp_disable_spdif_hw (chip);\n\tudelay(50);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, ( 0x8000 | ((SP_SPDOUT_FIFO >> 4) << 4) ));\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0x80000000);\n\n\t \n\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);\n\n\t \n\tins->spdif_status_out |= DSP_SPDIF_STATUS_HW_ENABLED;\n\n\treturn 0;\n}\n\nint cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\t \n\tchip->active_ctrl(chip, 1);\n\tchip->amplifier_ctrl(chip, 1);\n\n\tif (snd_BUG_ON(ins->asynch_rx_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->spdif_in_src))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\n\tif ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {\n\t\t \n\t\tcs46xx_poke_via_dsp (chip,SP_ASER_COUNTDOWN, 0x80000005);\n\t\t \n\n\t\t \n\t\tcs46xx_poke_via_dsp (chip,SP_SPDIN_CONTROL, 0x800003ff);\n\n\t\tins->spdif_status_out |= DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED;\n\t}\n\n\t \n\tins->asynch_rx_scb = cs46xx_dsp_create_asynch_fg_rx_scb(chip,\"AsynchFGRxSCB\",\n\t\t\t\t\t\t\t\tASYNCRX_SCB_ADDR,\n\t\t\t\t\t\t\t\tSPDIFI_SCB_INST,\n\t\t\t\t\t\t\t\tSPDIFI_IP_OUTPUT_BUFFER1,\n\t\t\t\t\t\t\t\tins->spdif_in_src,\n\t\t\t\t\t\t\t\tSCB_ON_PARENT_SUBLIST_SCB);\n\n\tspin_lock_irq(&chip->reg_lock);\n\n\t \n\t \n\n\t \n\t \n\tcs46xx_src_link(chip,ins->spdif_in_src);\n\n\t \n\tcs46xx_dsp_scb_set_volume (chip,ins->spdif_in_src,0x7fff,0x7fff);\n\n\tspin_unlock_irq(&chip->reg_lock);\n\n\t \n\t \n\n\t \n\tins->spdif_status_in = 1;\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(!ins->asynch_rx_scb))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->spdif_in_src))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\n\t \n\tcs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);\n\tins->asynch_rx_scb = NULL;\n\n\tcs46xx_src_unlink(chip,ins->spdif_in_src);\n\n\t \n\tins->spdif_status_in = 0;\n\tmutex_unlock(&chip->spos_mutex);\n\n\t \n\tchip->active_ctrl(chip, -1);\n\tchip->amplifier_ctrl(chip, -1);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(ins->pcm_input))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->ref_snoop_scb))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\tins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,\n                                                  \"PCMSerialInput_Wave\");\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(!ins->pcm_input))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\tcs46xx_dsp_remove_scb (chip,ins->pcm_input);\n\tins->pcm_input = NULL;\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(ins->adc_input))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!ins->codec_in_scb))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\tins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,\n\t\t\t\t\t\t  \"PCMSerialInput_ADC\");\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (snd_BUG_ON(!ins->adc_input))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->spos_mutex);\n\tcs46xx_dsp_remove_scb (chip,ins->adc_input);\n\tins->adc_input = NULL;\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_poke_via_dsp (struct snd_cs46xx *chip, u32 address, u32 data)\n{\n\tu32 temp;\n\tint  i;\n\n\t \n\tif (address < 0x8000 || address >= 0x9000)\n\t\treturn -EINVAL;\n        \n\t \n\ttemp = ( address << 16 ) | ( address & 0x0000FFFF);    \n\n\tsnd_cs46xx_poke(chip,( SPIOWRITE_SCB_ADDR      << 2), temp);\n\tsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 1) << 2), data);  \n\tsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 2) << 2), data);  \n    \n\t \n\tsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 6) << 2), SPIOWRITE_SCB_ADDR << 0x10);\n\n\t \n\tfor (i=0; i<25; i++) {\n\t\tudelay(125);\n\n\t\ttemp =  snd_cs46xx_peek(chip,((SPIOWRITE_SCB_ADDR + 6) << 2));\n\t\tif (temp == 0x00000000)\n\t\t\tbreak;\n\t}\n\n\tif (i == 25) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"dsp_spos: SPIOWriteTask not responding\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tstruct dsp_scb_descriptor * scb; \n\n\tmutex_lock(&chip->spos_mutex);\n\t\n\t \n\tscb = ins->master_mix_scb->sub_list_ptr;\n\twhile (scb != ins->the_null_scb) {\n\t\tcs46xx_dsp_scb_set_volume (chip,scb,left,right);\n\t\tscb = scb->next_scb_ptr;\n\t}\n\n\t \n\tscb = ins->rear_mix_scb->sub_list_ptr;\n\twhile (scb != ins->the_null_scb) {\n\t\tcs46xx_dsp_scb_set_volume (chip,scb,left,right);\n\t\tscb = scb->next_scb_ptr;\n\t}\n\n\tins->dac_volume_left = left;\n\tins->dac_volume_right = right;\n\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nint cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tmutex_lock(&chip->spos_mutex);\n\n\tif (ins->asynch_rx_scb != NULL)\n\t\tcs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,\n\t\t\t\t\t   left,right);\n\n\tins->spdif_input_volume_left = left;\n\tins->spdif_input_volume_right = right;\n\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nint cs46xx_dsp_resume(struct snd_cs46xx * chip)\n{\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint i, err;\n\n\t \n\tsnd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET,\n\t\t\t     DSP_PARAMETER_BYTE_SIZE);\n\tsnd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET,\n\t\t\t     DSP_SAMPLE_BYTE_SIZE);\n\tsnd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);\n\n\tfor (i = 0; i < ins->nmodules; i++) {\n\t\tstruct dsp_module_desc *module = &ins->modules[i];\n\t\tstruct dsp_segment_desc *seg;\n\t\tu32 doffset, dsize;\n\n\t\tseg = get_segment_desc(module, SEGTYPE_SP_PARAMETER);\n\t\terr = dsp_load_parameter(chip, seg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tseg = get_segment_desc(module, SEGTYPE_SP_SAMPLE);\n\t\terr = dsp_load_sample(chip, seg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tseg = get_segment_desc(module, SEGTYPE_SP_PROGRAM);\n\t\tif (!seg)\n\t\t\tcontinue;\n\n\t\tdoffset = seg->offset * 4 + module->load_address * 4\n\t\t\t+ DSP_CODE_BYTE_OFFSET;\n\t\tdsize   = seg->size * 4;\n\t\terr = snd_cs46xx_download(chip,\n\t\t\t\t\t  ins->code.data + module->load_address,\n\t\t\t\t\t  doffset, dsize);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ins->ntask; i++) {\n\t\tstruct dsp_task_descriptor *t = &ins->tasks[i];\n\t\t_dsp_create_task_tree(chip, t->data, t->address, t->size);\n\t}\n\n\tfor (i = 0; i < ins->nscb; i++) {\n\t\tstruct dsp_scb_descriptor *s = &ins->scbs[i];\n\t\tif (s->deleted)\n\t\t\tcontinue;\n\t\t_dsp_create_scb(chip, s->data, s->address);\n\t}\n\tfor (i = 0; i < ins->nscb; i++) {\n\t\tstruct dsp_scb_descriptor *s = &ins->scbs[i];\n\t\tif (s->deleted)\n\t\t\tcontinue;\n\t\tif (s->updated)\n\t\t\tcs46xx_dsp_spos_update_scb(chip, s);\n\t\tif (s->volume_set)\n\t\t\tcs46xx_dsp_scb_set_volume(chip, s,\n\t\t\t\t\t\t  s->volume[0], s->volume[1]);\n\t}\n\tif (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) {\n\t\tcs46xx_dsp_enable_spdif_hw(chip);\n\t\tsnd_cs46xx_poke(chip, (ins->ref_snoop_scb->address + 2) << 2,\n\t\t\t\t(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10);\n\t\tif (ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN)\n\t\t\tcs46xx_poke_via_dsp(chip, SP_SPDOUT_CSUV,\n\t\t\t\t\t    ins->spdif_csuv_stream);\n\t}\n\tif (chip->dsp_spos_instance->spdif_status_in) {\n\t\tcs46xx_poke_via_dsp(chip, SP_ASER_COUNTDOWN, 0x80000005);\n\t\tcs46xx_poke_via_dsp(chip, SP_SPDIN_CONTROL, 0x800003ff);\n\t}\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}