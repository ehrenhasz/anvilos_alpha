{
  "module_name": "cs46xx_lib.c",
  "hash_id": "2727102b89b851c2e962c97fc750cedcb5ed5a701f12e1d6e6111f3c91c20221",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs46xx/cs46xx_lib.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"cs46xx.h\"\n\n#include \"cs46xx_lib.h\"\n#include \"dsp_spos.h\"\n\nstatic void amp_voyetra(struct snd_cs46xx *chip, int change);\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nstatic const struct snd_pcm_ops snd_cs46xx_playback_rear_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_rear_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_clfe_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_clfe_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_iec958_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_iec958_ops;\n#endif\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_capture_ops;\nstatic const struct snd_pcm_ops snd_cs46xx_capture_indirect_ops;\n\nstatic unsigned short snd_cs46xx_codec_read(struct snd_cs46xx *chip,\n\t\t\t\t\t    unsigned short reg,\n\t\t\t\t\t    int codec_index)\n{\n\tint count;\n\tunsigned short result,tmp;\n\tu32 offset = 0;\n\n\tif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\n\t\t       codec_index != CS46XX_SECONDARY_CODEC_INDEX))\n\t\treturn 0xffff;\n\n\tchip->active_ctrl(chip, 1);\n\n\tif (codec_index == CS46XX_SECONDARY_CODEC_INDEX)\n\t\toffset = CS46XX_SECONDARY_CODEC_OFFSET;\n\n\t \n\n\tsnd_cs46xx_peekBA0(chip, BA0_ACSDA + offset);\n\n\ttmp = snd_cs46xx_peekBA0(chip, BA0_ACCTL);\n\tif ((tmp & ACCTL_VFRM) == 0) {\n\t\tdev_warn(chip->card->dev, \"ACCTL_VFRM not set 0x%x\\n\", tmp);\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, (tmp & (~ACCTL_ESYN)) | ACCTL_VFRM );\n\t\tmsleep(50);\n\t\ttmp = snd_cs46xx_peekBA0(chip, BA0_ACCTL + offset);\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, tmp | ACCTL_ESYN | ACCTL_VFRM );\n\n\t}\n\n\t \n\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCAD, reg);\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCDA, 0);\n\tif (codec_index == CS46XX_PRIMARY_CODEC_INDEX) {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL,  ACCTL_CRW | \n\t\t\t\t   ACCTL_VFRM | ACCTL_ESYN |\n\t\t\t\t   ACCTL_RSTN);\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_CRW |\n\t\t\t\t   ACCTL_VFRM | ACCTL_ESYN |\n\t\t\t\t   ACCTL_RSTN);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_TC |\n\t\t\t\t   ACCTL_CRW | ACCTL_VFRM | ACCTL_ESYN |\n\t\t\t\t   ACCTL_RSTN);\n\t}\n\n\t \n\tfor (count = 0; count < 1000; count++) {\n\t\t \n\t\tudelay(10);\n\t\t \n\t\tif (!(snd_cs46xx_peekBA0(chip, BA0_ACCTL) & ACCTL_DCV))\n\t\t\tgoto ok1;\n\t}\n\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 read problem (ACCTL_DCV), reg = 0x%x\\n\", reg);\n\tresult = 0xffff;\n\tgoto end;\n\t\n ok1:\n\t \n\tfor (count = 0; count < 100; count++) {\n\t\t \n\t\tif (snd_cs46xx_peekBA0(chip, BA0_ACSTS + offset) & ACSTS_VSTS)\n\t\t\tgoto ok2;\n\t\tudelay(10);\n\t}\n\t\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 read problem (ACSTS_VSTS), codec_index %d, reg = 0x%x\\n\",\n\t\tcodec_index, reg);\n\tresult = 0xffff;\n\tgoto end;\n\n ok2:\n\t \n#if 0\n\tdev_dbg(chip->card->dev,\n\t\t\"e) reg = 0x%x, val = 0x%x, BA0_ACCAD = 0x%x\\n\", reg,\n\t\t\tsnd_cs46xx_peekBA0(chip, BA0_ACSDA),\n\t\t\tsnd_cs46xx_peekBA0(chip, BA0_ACCAD));\n#endif\n\n\t \n\tresult = snd_cs46xx_peekBA0(chip, BA0_ACSDA + offset);\n end:\n\tchip->active_ctrl(chip, -1);\n\treturn result;\n}\n\nstatic unsigned short snd_cs46xx_ac97_read(struct snd_ac97 * ac97,\n\t\t\t\t\t    unsigned short reg)\n{\n\tstruct snd_cs46xx *chip = ac97->private_data;\n\tunsigned short val;\n\tint codec_index = ac97->num;\n\n\tif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\n\t\t       codec_index != CS46XX_SECONDARY_CODEC_INDEX))\n\t\treturn 0xffff;\n\n\tval = snd_cs46xx_codec_read(chip, reg, codec_index);\n\n\treturn val;\n}\n\n\nstatic void snd_cs46xx_codec_write(struct snd_cs46xx *chip,\n\t\t\t\t   unsigned short reg,\n\t\t\t\t   unsigned short val,\n\t\t\t\t   int codec_index)\n{\n\tint count;\n\n\tif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\n\t\t       codec_index != CS46XX_SECONDARY_CODEC_INDEX))\n\t\treturn;\n\n\tchip->active_ctrl(chip, 1);\n\n\t \n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCAD , reg);\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCDA , val);\n\tsnd_cs46xx_peekBA0(chip, BA0_ACCTL);\n\n\tif (codec_index == CS46XX_PRIMARY_CODEC_INDEX) {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL,   ACCTL_VFRM |\n\t\t\t\t   ACCTL_ESYN | ACCTL_RSTN);\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_VFRM |\n\t\t\t\t   ACCTL_ESYN | ACCTL_RSTN);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_TC |\n\t\t\t\t   ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\n\t}\n\n\tfor (count = 0; count < 4000; count++) {\n\t\t \n\t\tudelay(10);\n\t\t \n\t\tif (!(snd_cs46xx_peekBA0(chip, BA0_ACCTL) & ACCTL_DCV)) {\n\t\t\tgoto end;\n\t\t}\n\t}\n\tdev_err(chip->card->dev,\n\t\t\"AC'97 write problem, codec_index = %d, reg = 0x%x, val = 0x%x\\n\",\n\t\tcodec_index, reg, val);\n end:\n\tchip->active_ctrl(chip, -1);\n}\n\nstatic void snd_cs46xx_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\t   unsigned short reg,\n\t\t\t\t   unsigned short val)\n{\n\tstruct snd_cs46xx *chip = ac97->private_data;\n\tint codec_index = ac97->num;\n\n\tif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\n\t\t       codec_index != CS46XX_SECONDARY_CODEC_INDEX))\n\t\treturn;\n\n\tsnd_cs46xx_codec_write(chip, reg, val, codec_index);\n}\n\n\n \n\nint snd_cs46xx_download(struct snd_cs46xx *chip,\n\t\t\tu32 *src,\n                        unsigned long offset,\n                        unsigned long len)\n{\n\tvoid __iomem *dst;\n\tunsigned int bank = offset >> 16;\n\toffset = offset & 0xffff;\n\n\tif (snd_BUG_ON((offset & 3) || (len & 3)))\n\t\treturn -EINVAL;\n\tdst = chip->region.idx[bank+1].remap_addr + offset;\n\tlen /= sizeof(u32);\n\n\t \n\twhile (len-- > 0) {\n\t\twritel(*src++, dst);\n\t\tdst += sizeof(u32);\n\t}\n\treturn 0;\n}\n\nstatic inline void memcpy_le32(void *dst, const void *src, unsigned int len)\n{\n#ifdef __LITTLE_ENDIAN\n\tmemcpy(dst, src, len);\n#else\n\tu32 *_dst = dst;\n\tconst __le32 *_src = src;\n\tlen /= 4;\n\twhile (len-- > 0)\n\t\t*_dst++ = le32_to_cpu(*_src++);\n#endif\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\nstatic const char *module_names[CS46XX_DSP_MODULES] = {\n\t\"cwc4630\", \"cwcasync\", \"cwcsnoop\", \"cwcbinhack\", \"cwcdma\"\n};\n\nMODULE_FIRMWARE(\"cs46xx/cwc4630\");\nMODULE_FIRMWARE(\"cs46xx/cwcasync\");\nMODULE_FIRMWARE(\"cs46xx/cwcsnoop\");\nMODULE_FIRMWARE(\"cs46xx/cwcbinhack\");\nMODULE_FIRMWARE(\"cs46xx/cwcdma\");\n\nstatic void free_module_desc(struct dsp_module_desc *module)\n{\n\tif (!module)\n\t\treturn;\n\tkfree(module->module_name);\n\tkfree(module->symbol_table.symbols);\n\tif (module->segments) {\n\t\tint i;\n\t\tfor (i = 0; i < module->nsegments; i++)\n\t\t\tkfree(module->segments[i].data);\n\t\tkfree(module->segments);\n\t}\n\tkfree(module);\n}\n\n \n\nstatic int load_firmware(struct snd_cs46xx *chip,\n\t\t\t struct dsp_module_desc **module_ret,\n\t\t\t const char *fw_name)\n{\n\tint i, err;\n\tunsigned int nums, fwlen, fwsize;\n\tconst __le32 *fwdat;\n\tstruct dsp_module_desc *module = NULL;\n\tconst struct firmware *fw;\n\tchar fw_path[32];\n\n\tsprintf(fw_path, \"cs46xx/%s\", fw_name);\n\terr = request_firmware(&fw, fw_path, &chip->pci->dev);\n\tif (err < 0)\n\t\treturn err;\n\tfwsize = fw->size / 4;\n\tif (fwsize < 2) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\terr = -ENOMEM;\n\tmodule = kzalloc(sizeof(*module), GFP_KERNEL);\n\tif (!module)\n\t\tgoto error;\n\tmodule->module_name = kstrdup(fw_name, GFP_KERNEL);\n\tif (!module->module_name)\n\t\tgoto error;\n\n\tfwlen = 0;\n\tfwdat = (const __le32 *)fw->data;\n\tnums = module->symbol_table.nsymbols = le32_to_cpu(fwdat[fwlen++]);\n\tif (nums >= 40)\n\t\tgoto error_inval;\n\tmodule->symbol_table.symbols =\n\t\tkcalloc(nums, sizeof(struct dsp_symbol_entry), GFP_KERNEL);\n\tif (!module->symbol_table.symbols)\n\t\tgoto error;\n\tfor (i = 0; i < nums; i++) {\n\t\tstruct dsp_symbol_entry *entry =\n\t\t\t&module->symbol_table.symbols[i];\n\t\tif (fwlen + 2 + DSP_MAX_SYMBOL_NAME / 4 > fwsize)\n\t\t\tgoto error_inval;\n\t\tentry->address = le32_to_cpu(fwdat[fwlen++]);\n\t\tmemcpy(entry->symbol_name, &fwdat[fwlen], DSP_MAX_SYMBOL_NAME - 1);\n\t\tfwlen += DSP_MAX_SYMBOL_NAME / 4;\n\t\tentry->symbol_type = le32_to_cpu(fwdat[fwlen++]);\n\t}\n\n\tif (fwlen >= fwsize)\n\t\tgoto error_inval;\n\tnums = module->nsegments = le32_to_cpu(fwdat[fwlen++]);\n\tif (nums > 10)\n\t\tgoto error_inval;\n\tmodule->segments =\n\t\tkcalloc(nums, sizeof(struct dsp_segment_desc), GFP_KERNEL);\n\tif (!module->segments)\n\t\tgoto error;\n\tfor (i = 0; i < nums; i++) {\n\t\tstruct dsp_segment_desc *entry = &module->segments[i];\n\t\tif (fwlen + 3 > fwsize)\n\t\t\tgoto error_inval;\n\t\tentry->segment_type = le32_to_cpu(fwdat[fwlen++]);\n\t\tentry->offset = le32_to_cpu(fwdat[fwlen++]);\n\t\tentry->size = le32_to_cpu(fwdat[fwlen++]);\n\t\tif (fwlen + entry->size > fwsize)\n\t\t\tgoto error_inval;\n\t\tentry->data = kmalloc_array(entry->size, 4, GFP_KERNEL);\n\t\tif (!entry->data)\n\t\t\tgoto error;\n\t\tmemcpy_le32(entry->data, &fwdat[fwlen], entry->size * 4);\n\t\tfwlen += entry->size;\n\t}\n\n\t*module_ret = module;\n\trelease_firmware(fw);\n\treturn 0;\n\n error_inval:\n\terr = -EINVAL;\n error:\n\tfree_module_desc(module);\n\trelease_firmware(fw);\n\treturn err;\n}\n\nint snd_cs46xx_clear_BA1(struct snd_cs46xx *chip,\n                         unsigned long offset,\n                         unsigned long len) \n{\n\tvoid __iomem *dst;\n\tunsigned int bank = offset >> 16;\n\toffset = offset & 0xffff;\n\n\tif (snd_BUG_ON((offset & 3) || (len & 3)))\n\t\treturn -EINVAL;\n\tdst = chip->region.idx[bank+1].remap_addr + offset;\n\tlen /= sizeof(u32);\n\n\t \n\twhile (len-- > 0) {\n\t\twritel(0, dst);\n\t\tdst += sizeof(u32);\n\t}\n\treturn 0;\n}\n\n#else  \n\nstruct ba1_struct {\n\tstruct {\n\t\tu32 offset;\n\t\tu32 size;\n\t} memory[BA1_MEMORY_COUNT];\n\tu32 map[BA1_DWORD_SIZE];\n};\n\nMODULE_FIRMWARE(\"cs46xx/ba1\");\n\nstatic int load_firmware(struct snd_cs46xx *chip)\n{\n\tconst struct firmware *fw;\n\tint i, size, err;\n\n\terr = request_firmware(&fw, \"cs46xx/ba1\", &chip->pci->dev);\n\tif (err < 0)\n\t\treturn err;\n\tif (fw->size != sizeof(*chip->ba1)) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tchip->ba1 = vmalloc(sizeof(*chip->ba1));\n\tif (!chip->ba1) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tmemcpy_le32(chip->ba1, fw->data, sizeof(*chip->ba1));\n\n\t \n\tsize = 0;\n\tfor (i = 0; i < BA1_MEMORY_COUNT; i++)\n\t\tsize += chip->ba1->memory[i].size;\n\tif (size > BA1_DWORD_SIZE * 4)\n\t\terr = -EINVAL;\n\n error:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic __maybe_unused int snd_cs46xx_download_image(struct snd_cs46xx *chip)\n{\n\tint idx, err;\n\tunsigned int offset = 0;\n\tstruct ba1_struct *ba1 = chip->ba1;\n\n\tfor (idx = 0; idx < BA1_MEMORY_COUNT; idx++) {\n\t\terr = snd_cs46xx_download(chip,\n\t\t\t\t\t  &ba1->map[offset],\n\t\t\t\t\t  ba1->memory[idx].offset,\n\t\t\t\t\t  ba1->memory[idx].size);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\toffset += ba1->memory[idx].size >> 2;\n\t}\t\n\treturn 0;\n}\n#endif  \n\n \n\nstatic void snd_cs46xx_reset(struct snd_cs46xx *chip)\n{\n\tint idx;\n\n\t \n\tsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_RSTSP);\n\n\t \n\tsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_DRQEN);\n\n\t \n\tfor (idx = 0; idx < 8; idx++) {\n\t\tsnd_cs46xx_poke(chip, BA1_DREG, DREG_REGID_TRAP_SELECT + idx);\n\t\tsnd_cs46xx_poke(chip, BA1_TWPR, 0xFFFF);\n\t}\n\tsnd_cs46xx_poke(chip, BA1_DREG, 0);\n\n\t \n\tsnd_cs46xx_poke(chip, BA1_FRMT, 0xadf);\n}\n\nstatic int cs46xx_wait_for_fifo(struct snd_cs46xx * chip,int retry_timeout) \n{\n\tu32 i, status = 0;\n\t \n\tfor(i = 0; i < 50; i++){\n\t\tstatus = snd_cs46xx_peekBA0(chip, BA0_SERBST);\n    \n\t\tif( !(status & SERBST_WBSY) )\n\t\t\tbreak;\n\n\t\tmdelay(retry_timeout);\n\t}\n  \n\tif(status & SERBST_WBSY) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"failure waiting for FIFO command to complete\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_cs46xx_clear_serial_FIFOs(struct snd_cs46xx *chip)\n{\n\tint idx, powerdown = 0;\n\tunsigned int tmp;\n\n\t \n\ttmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1);\n\tif (!(tmp & CLKCR1_SWCE)) {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp | CLKCR1_SWCE);\n\t\tpowerdown = 1;\n\t}\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_SERBWP, 0);\n\n\t \n\tfor (idx = 0; idx < 0xFF; idx++) {\n\t\t \n\t\tif (cs46xx_wait_for_fifo(chip,1)) {\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"failed waiting for FIFO at addr (%02X)\\n\",\n\t\t\t\tidx);\n\n\t\t\tif (powerdown)\n\t\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\n          \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_SERBAD, idx);\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_SERBCM, SERBCM_WRC);\n\t}\n\t \n\tif (powerdown)\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\n}\n\nstatic void snd_cs46xx_proc_start(struct snd_cs46xx *chip)\n{\n\tint cnt;\n\n\t \n\tsnd_cs46xx_poke(chip, BA1_FRMT, 0xadf);\n\t \n\tsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_RUN | SPCR_RUNFR | SPCR_DRQEN);\n\t \n\tfor (cnt = 0; cnt < 25; cnt++) {\n\t\tudelay(50);\n\t\tif (!(snd_cs46xx_peek(chip, BA1_SPCR) & SPCR_RUNFR))\n\t\t\tbreak;\n\t}\n\n\tif (snd_cs46xx_peek(chip, BA1_SPCR) & SPCR_RUNFR)\n\t\tdev_err(chip->card->dev, \"SPCR_RUNFR never reset\\n\");\n}\n\nstatic void snd_cs46xx_proc_stop(struct snd_cs46xx *chip)\n{\n\t \n\tsnd_cs46xx_poke(chip, BA1_SPCR, 0);\n}\n\n \n\n#define GOF_PER_SEC 200\n\nstatic void snd_cs46xx_set_play_sample_rate(struct snd_cs46xx *chip, unsigned int rate)\n{\n\tunsigned long flags;\n\tunsigned int tmp1, tmp2;\n\tunsigned int phiIncr;\n\tunsigned int correctionPerGOF, correctionPerSec;\n\n\t \n\ttmp1 = rate << 16;\n\tphiIncr = tmp1 / 48000;\n\ttmp1 -= phiIncr * 48000;\n\ttmp1 <<= 10;\n\tphiIncr <<= 10;\n\ttmp2 = tmp1 / 48000;\n\tphiIncr += tmp2;\n\ttmp1 -= tmp2 * 48000;\n\tcorrectionPerGOF = tmp1 / GOF_PER_SEC;\n\ttmp1 -= correctionPerGOF * GOF_PER_SEC;\n\tcorrectionPerSec = tmp1;\n\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_cs46xx_poke(chip, BA1_PSRC,\n\t  ((correctionPerSec << 16) & 0xFFFF0000) | (correctionPerGOF & 0xFFFF));\n\tsnd_cs46xx_poke(chip, BA1_PPI, phiIncr);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_cs46xx_set_capture_sample_rate(struct snd_cs46xx *chip, unsigned int rate)\n{\n\tunsigned long flags;\n\tunsigned int phiIncr, coeffIncr, tmp1, tmp2;\n\tunsigned int correctionPerGOF, correctionPerSec, initialDelay;\n\tunsigned int frameGroupLength, cnt;\n\n\t \n\tif ((rate * 9) < 48000)\n\t\trate = 48000 / 9;\n\n\t \n\tif (rate > 48000)\n\t\trate = 48000;\n\n\t \n\n\ttmp1 = rate << 16;\n\tcoeffIncr = tmp1 / 48000;\n\ttmp1 -= coeffIncr * 48000;\n\ttmp1 <<= 7;\n\tcoeffIncr <<= 7;\n\tcoeffIncr += tmp1 / 48000;\n\tcoeffIncr ^= 0xFFFFFFFF;\n\tcoeffIncr++;\n\ttmp1 = 48000 << 16;\n\tphiIncr = tmp1 / rate;\n\ttmp1 -= phiIncr * rate;\n\ttmp1 <<= 10;\n\tphiIncr <<= 10;\n\ttmp2 = tmp1 / rate;\n\tphiIncr += tmp2;\n\ttmp1 -= tmp2 * rate;\n\tcorrectionPerGOF = tmp1 / GOF_PER_SEC;\n\ttmp1 -= correctionPerGOF * GOF_PER_SEC;\n\tcorrectionPerSec = tmp1;\n\tinitialDelay = DIV_ROUND_UP(48000 * 24, rate);\n\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_cs46xx_poke(chip, BA1_CSRC,\n\t\t((correctionPerSec << 16) & 0xFFFF0000) | (correctionPerGOF & 0xFFFF));\n\tsnd_cs46xx_poke(chip, BA1_CCI, coeffIncr);\n\tsnd_cs46xx_poke(chip, BA1_CD,\n\t\t(((BA1_VARIDEC_BUF_1 + (initialDelay << 2)) << 16) & 0xFFFF0000) | 0x80);\n\tsnd_cs46xx_poke(chip, BA1_CPI, phiIncr);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\t \n\tframeGroupLength = 1;\n\tfor (cnt = 2; cnt <= 64; cnt *= 2) {\n\t\tif (((rate / cnt) * cnt) != rate)\n\t\t\tframeGroupLength *= 2;\n\t}\n\tif (((rate / 3) * 3) != rate) {\n\t\tframeGroupLength *= 3;\n\t}\n\tfor (cnt = 5; cnt <= 125; cnt *= 5) {\n\t\tif (((rate / cnt) * cnt) != rate) \n\t\t\tframeGroupLength *= 5;\n        }\n\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tsnd_cs46xx_poke(chip, BA1_CFG1, frameGroupLength);\n\tsnd_cs46xx_poke(chip, BA1_CFG2, (0x00800000 | frameGroupLength));\n\tsnd_cs46xx_poke(chip, BA1_CCST, 0x0000FFFF);\n\tsnd_cs46xx_poke(chip, BA1_CSPB, ((65536 * rate) / 24000));\n\tsnd_cs46xx_poke(chip, (BA1_CSPB + 4), 0x0000FFFF);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\n \n\nstatic void snd_cs46xx_pb_trans_copy(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm * cpcm = runtime->private_data;\n\tmemcpy(cpcm->hw_buf.area + rec->hw_data, runtime->dma_area + rec->sw_data, bytes);\n}\n\nstatic int snd_cs46xx_playback_transfer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm * cpcm = runtime->private_data;\n\treturn snd_pcm_indirect_playback_transfer(substream, &cpcm->pcm_rec,\n\t\t\t\t\t\t  snd_cs46xx_pb_trans_copy);\n}\n\nstatic void snd_cs46xx_cp_trans_copy(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tmemcpy(runtime->dma_area + rec->sw_data,\n\t       chip->capt.hw_buf.area + rec->hw_data, bytes);\n}\n\nstatic int snd_cs46xx_capture_transfer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\treturn snd_pcm_indirect_capture_transfer(substream, &chip->capt.pcm_rec,\n\t\t\t\t\t\t snd_cs46xx_cp_trans_copy);\n}\n\nstatic snd_pcm_uframes_t snd_cs46xx_playback_direct_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\n\n\tif (snd_BUG_ON(!cpcm->pcm_channel))\n\t\treturn -ENXIO;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tptr = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 2) << 2);\n#else\n\tptr = snd_cs46xx_peek(chip, BA1_PBA);\n#endif\n\tptr -= cpcm->hw_buf.addr;\n\treturn ptr >> cpcm->shift;\n}\n\nstatic snd_pcm_uframes_t snd_cs46xx_playback_indirect_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\tstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (snd_BUG_ON(!cpcm->pcm_channel))\n\t\treturn -ENXIO;\n\tptr = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 2) << 2);\n#else\n\tptr = snd_cs46xx_peek(chip, BA1_PBA);\n#endif\n\tptr -= cpcm->hw_buf.addr;\n\treturn snd_pcm_indirect_playback_pointer(substream, &cpcm->pcm_rec, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_cs46xx_capture_direct_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;\n\treturn ptr >> chip->capt.shift;\n}\n\nstatic snd_pcm_uframes_t snd_cs46xx_capture_indirect_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tsize_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;\n\treturn snd_pcm_indirect_capture_pointer(substream, &chip->capt.pcm_rec, ptr);\n}\n\nstatic int snd_cs46xx_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\t \n\tint result = 0;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\n\tif (! cpcm->pcm_channel) {\n\t\treturn -ENXIO;\n\t}\n#endif\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\t \n\t\tsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address + \n\t\t\t\t       SCBVolumeCtrl) << 2, 0x80008000);\n\n\t\tif (cpcm->pcm_channel->unlinked)\n\t\t\tcs46xx_dsp_pcm_link(chip,cpcm->pcm_channel);\n\n\t\tif (substream->runtime->periods != CS46XX_FRAGS)\n\t\t\tsnd_cs46xx_playback_transfer(substream);\n#else\n\t\tspin_lock(&chip->reg_lock);\n\t\tif (substream->runtime->periods != CS46XX_FRAGS)\n\t\t\tsnd_cs46xx_playback_transfer(substream);\n\t\t{ unsigned int tmp;\n\t\ttmp = snd_cs46xx_peek(chip, BA1_PCTL);\n\t\ttmp &= 0x0000ffff;\n\t\tsnd_cs46xx_poke(chip, BA1_PCTL, chip->play_ctl | tmp);\n\t\t}\n\t\tspin_unlock(&chip->reg_lock);\n#endif\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\t \n\t\tsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address + \n\t\t\t\t       SCBVolumeCtrl) << 2, 0xffffffff);\n\n\t\tif (!cpcm->pcm_channel->unlinked)\n\t\t\tcs46xx_dsp_pcm_unlink(chip,cpcm->pcm_channel);\n#else\n\t\tspin_lock(&chip->reg_lock);\n\t\t{ unsigned int tmp;\n\t\ttmp = snd_cs46xx_peek(chip, BA1_PCTL);\n\t\ttmp &= 0x0000ffff;\n\t\tsnd_cs46xx_poke(chip, BA1_PCTL, tmp);\n\t\t}\n\t\tspin_unlock(&chip->reg_lock);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int snd_cs46xx_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tunsigned int tmp;\n\tint result = 0;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\ttmp = snd_cs46xx_peek(chip, BA1_CCTL);\n\t\ttmp &= 0xffff0000;\n\t\tsnd_cs46xx_poke(chip, BA1_CCTL, chip->capt.ctl | tmp);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\ttmp = snd_cs46xx_peek(chip, BA1_CCTL);\n\t\ttmp &= 0xffff0000;\n\t\tsnd_cs46xx_poke(chip, BA1_CCTL, tmp);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\n\treturn result;\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nstatic int _cs46xx_adjust_sample_rate (struct snd_cs46xx *chip, struct snd_cs46xx_pcm *cpcm,\n\t\t\t\t       int sample_rate) \n{\n\n\t \n\tif ( cpcm->pcm_channel == NULL) {\n\t\tcpcm->pcm_channel = cs46xx_dsp_create_pcm_channel (chip, sample_rate, \n\t\t\t\t\t\t\t\t   cpcm, cpcm->hw_buf.addr,cpcm->pcm_channel_id);\n\t\tif (cpcm->pcm_channel == NULL) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"failed to create virtual PCM channel\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcpcm->pcm_channel->sample_rate = sample_rate;\n\t} else\n\t \n\tif ((int)cpcm->pcm_channel->sample_rate != sample_rate) {\n\t\tint unlinked = cpcm->pcm_channel->unlinked;\n\t\tcs46xx_dsp_destroy_pcm_channel (chip,cpcm->pcm_channel);\n\n\t\tcpcm->pcm_channel = cs46xx_dsp_create_pcm_channel(chip, sample_rate, cpcm,\n\t\t\t\t\t\t\t\t  cpcm->hw_buf.addr,\n\t\t\t\t\t\t\t\t  cpcm->pcm_channel_id);\n\t\tif (!cpcm->pcm_channel) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"failed to re-create virtual PCM channel\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (!unlinked) cs46xx_dsp_pcm_link (chip,cpcm->pcm_channel);\n\t\tcpcm->pcm_channel->sample_rate = sample_rate;\n\t}\n\n\treturn 0;\n}\n#endif\n\n\nstatic int snd_cs46xx_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm *cpcm;\n\tint err;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tint sample_rate = params_rate(hw_params);\n\tint period_size = params_period_bytes(hw_params);\n#endif\n\tcpcm = runtime->private_data;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (snd_BUG_ON(!sample_rate))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&chip->spos_mutex);\n\n\tif (_cs46xx_adjust_sample_rate (chip,cpcm,sample_rate)) {\n\t\tmutex_unlock(&chip->spos_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\tsnd_BUG_ON(!cpcm->pcm_channel);\n\tif (!cpcm->pcm_channel) {\n\t\tmutex_unlock(&chip->spos_mutex);\n\t\treturn -ENXIO;\n\t}\n\n\n\tif (cs46xx_dsp_pcm_channel_set_period (chip,cpcm->pcm_channel,period_size)) {\n\t\t mutex_unlock(&chip->spos_mutex);\n\t\t return -EINVAL;\n\t }\n\n\tdev_dbg(chip->card->dev,\n\t\t\"period_size (%d), periods (%d) buffer_size(%d)\\n\",\n\t\t     period_size, params_periods(hw_params),\n\t\t     params_buffer_bytes(hw_params));\n#endif\n\n\tif (params_periods(hw_params) == CS46XX_FRAGS) {\n\t\tif (runtime->dma_area != cpcm->hw_buf.area)\n\t\t\tsnd_pcm_lib_free_pages(substream);\n\t\tsnd_pcm_set_runtime_buffer(substream, &cpcm->hw_buf);\n\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\tif (cpcm->pcm_channel_id == DSP_PCM_MAIN_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_PCM_REAR_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_rear_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_PCM_CENTER_LFE_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_clfe_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_IEC958_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_iec958_ops;\n\t\t} else {\n\t\t\tsnd_BUG();\n\t\t}\n#else\n\t\tsubstream->ops = &snd_cs46xx_playback_ops;\n#endif\n\n\t} else {\n\t\tif (runtime->dma_area == cpcm->hw_buf.area)\n\t\t\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\t\terr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\n\t\tif (err < 0) {\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\t\tmutex_unlock(&chip->spos_mutex);\n#endif\n\t\t\treturn err;\n\t\t}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\tif (cpcm->pcm_channel_id == DSP_PCM_MAIN_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_indirect_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_PCM_REAR_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_indirect_rear_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_PCM_CENTER_LFE_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_indirect_clfe_ops;\n\t\t} else if (cpcm->pcm_channel_id == DSP_IEC958_CHANNEL) {\n\t\t\tsubstream->ops = &snd_cs46xx_playback_indirect_iec958_ops;\n\t\t} else {\n\t\t\tsnd_BUG();\n\t\t}\n#else\n\t\tsubstream->ops = &snd_cs46xx_playback_indirect_ops;\n#endif\n\n\t}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tmutex_unlock(&chip->spos_mutex);\n#endif\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\t \n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm *cpcm;\n\n\tcpcm = runtime->private_data;\n\n\t \n\tif (!cpcm) return -ENXIO;\n\n\tif (runtime->dma_area != cpcm->hw_buf.area)\n\t\tsnd_pcm_lib_free_pages(substream);\n    \n\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tunsigned int tmp;\n\tunsigned int pfie;\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm *cpcm;\n\n\tcpcm = runtime->private_data;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (snd_BUG_ON(!cpcm->pcm_channel))\n\t\treturn -ENXIO;\n\n\tpfie = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 1) << 2 );\n\tpfie &= ~0x0000f03f;\n#else\n\t \n\tpfie = snd_cs46xx_peek(chip, BA1_PFIE);\n \tpfie &= ~0x0000f03f;\n#endif\n\n\tcpcm->shift = 2;\n\t \n\tif (runtime->channels == 1) {\n\t\tcpcm->shift--;\n\t\tpfie |= 0x00002000;\n\t}\n\t \n\tif (snd_pcm_format_width(runtime->format) == 8) {\n\t\tcpcm->shift--;\n\t\tpfie |= 0x00001000;\n\t}\n\t \n\tif (snd_pcm_format_unsigned(runtime->format))\n\t\tpfie |= 0x00008000;\n\n\t \n\tif (snd_pcm_format_width(runtime->format) != 8) {\n\t\t \n\t\tif (snd_pcm_format_big_endian(runtime->format))\n\t\t\tpfie |= 0x00004000;\n\t}\n\t\n\tmemset(&cpcm->pcm_rec, 0, sizeof(cpcm->pcm_rec));\n\tcpcm->pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tcpcm->pcm_rec.hw_buffer_size = runtime->period_size * CS46XX_FRAGS << cpcm->shift;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\n\ttmp = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address) << 2);\n\ttmp &= ~0x000003ff;\n\ttmp |= (4 << cpcm->shift) - 1;\n\t \n\tsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address) << 2, tmp);\n\n\t \n\tsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 1) << 2, pfie | cpcm->pcm_channel->pcm_slot);\n#else\n\tsnd_cs46xx_poke(chip, BA1_PBA, cpcm->hw_buf.addr);\n\ttmp = snd_cs46xx_peek(chip, BA1_PDTC);\n\ttmp &= ~0x000003ff;\n\ttmp |= (4 << cpcm->shift) - 1;\n\tsnd_cs46xx_poke(chip, BA1_PDTC, tmp);\n\tsnd_cs46xx_poke(chip, BA1_PFIE, pfie);\n\tsnd_cs46xx_set_play_sample_rate(chip, runtime->rate);\n#endif\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tcs46xx_dsp_pcm_ostream_set_period (chip, params_period_bytes(hw_params));\n#endif\n\tif (runtime->periods == CS46XX_FRAGS) {\n\t\tif (runtime->dma_area != chip->capt.hw_buf.area)\n\t\t\tsnd_pcm_lib_free_pages(substream);\n\t\tsnd_pcm_set_runtime_buffer(substream, &chip->capt.hw_buf);\n\t\tsubstream->ops = &snd_cs46xx_capture_ops;\n\t} else {\n\t\tif (runtime->dma_area == chip->capt.hw_buf.area)\n\t\t\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\t\terr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsubstream->ops = &snd_cs46xx_capture_indirect_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_capture_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (runtime->dma_area != chip->capt.hw_buf.area)\n\t\tsnd_pcm_lib_free_pages(substream);\n\tsnd_pcm_set_runtime_buffer(substream, NULL);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_cs46xx_poke(chip, BA1_CBA, chip->capt.hw_buf.addr);\n\tchip->capt.shift = 2;\n\tmemset(&chip->capt.pcm_rec, 0, sizeof(chip->capt.pcm_rec));\n\tchip->capt.pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tchip->capt.pcm_rec.hw_buffer_size = runtime->period_size * CS46XX_FRAGS << 2;\n\tsnd_cs46xx_set_capture_sample_rate(chip, runtime->rate);\n\n\treturn 0;\n}\n\nstatic irqreturn_t snd_cs46xx_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_cs46xx *chip = dev_id;\n\tu32 status1;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tu32 status2;\n\tint i;\n\tstruct snd_cs46xx_pcm *cpcm = NULL;\n#endif\n\n\t \n\tstatus1 = snd_cs46xx_peekBA0(chip, BA0_HISR);\n\tif ((status1 & 0x7fffffff) == 0) {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_CHGM | HICR_IEV);\n\t\treturn IRQ_NONE;\n\t}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tstatus2 = snd_cs46xx_peekBA0(chip, BA0_HSR0);\n\n\tfor (i = 0; i < DSP_MAX_PCM_CHANNELS; ++i) {\n\t\tif (i <= 15) {\n\t\t\tif ( status1 & (1 << i) ) {\n\t\t\t\tif (i == CS46XX_DSP_CAPTURE_CHANNEL) {\n\t\t\t\t\tif (chip->capt.substream)\n\t\t\t\t\t\tsnd_pcm_period_elapsed(chip->capt.substream);\n\t\t\t\t} else {\n\t\t\t\t\tif (ins->pcm_channels[i].active &&\n\t\t\t\t\t    ins->pcm_channels[i].private_data &&\n\t\t\t\t\t    !ins->pcm_channels[i].unlinked) {\n\t\t\t\t\t\tcpcm = ins->pcm_channels[i].private_data;\n\t\t\t\t\t\tsnd_pcm_period_elapsed(cpcm->substream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( status2 & (1 << (i - 16))) {\n\t\t\t\tif (ins->pcm_channels[i].active && \n\t\t\t\t    ins->pcm_channels[i].private_data &&\n\t\t\t\t    !ins->pcm_channels[i].unlinked) {\n\t\t\t\t\tcpcm = ins->pcm_channels[i].private_data;\n\t\t\t\t\tsnd_pcm_period_elapsed(cpcm->substream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#else\n\t \n\tif ((status1 & HISR_VC0) && chip->playback_pcm) {\n\t\tif (chip->playback_pcm->substream)\n\t\t\tsnd_pcm_period_elapsed(chip->playback_pcm->substream);\n\t}\n\tif ((status1 & HISR_VC1) && chip->pcm) {\n\t\tif (chip->capt.substream)\n\t\t\tsnd_pcm_period_elapsed(chip->capt.substream);\n\t}\n#endif\n\n\tif ((status1 & HISR_MIDI) && chip->rmidi) {\n\t\tunsigned char c;\n\t\t\n\t\tspin_lock(&chip->reg_lock);\n\t\twhile ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_RBE) == 0) {\n\t\t\tc = snd_cs46xx_peekBA0(chip, BA0_MIDRP);\n\t\t\tif ((chip->midcr & MIDCR_RIE) == 0)\n\t\t\t\tcontinue;\n\t\t\tsnd_rawmidi_receive(chip->midi_input, &c, 1);\n\t\t}\n\t\twhile ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_TBF) == 0) {\n\t\t\tif ((chip->midcr & MIDCR_TIE) == 0)\n\t\t\t\tbreak;\n\t\t\tif (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {\n\t\t\t\tchip->midcr &= ~MIDCR_TIE;\n\t\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDWP, c);\n\t\t}\n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_CHGM | HICR_IEV);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware snd_cs46xx_playback =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED | \n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER  \n\t\t\t\t   |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =\t\t(SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t\t SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_U16_BE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5500,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(256 * 1024),\n\t.period_bytes_min =\tCS46XX_MIN_PERIOD_SIZE,\n\t.period_bytes_max =\tCS46XX_MAX_PERIOD_SIZE,\n\t.periods_min =\t\tCS46XX_FRAGS,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_cs46xx_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER  \n\t\t\t\t   |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5500,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(256 * 1024),\n\t.period_bytes_min =\tCS46XX_MIN_PERIOD_SIZE,\n\t.period_bytes_max =\tCS46XX_MAX_PERIOD_SIZE,\n\t.periods_min =\t\tCS46XX_FRAGS,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\nstatic const unsigned int period_sizes[] = { 32, 64, 128, 256, 512, 1024, 2048 };\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {\n\t.count = ARRAY_SIZE(period_sizes),\n\t.list = period_sizes,\n\t.mask = 0\n};\n\n#endif\n\nstatic void snd_cs46xx_pcm_free_substream(struct snd_pcm_runtime *runtime)\n{\n\tkfree(runtime->private_data);\n}\n\nstatic int _cs46xx_playback_open_channel (struct snd_pcm_substream *substream,int pcm_channel_id)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_cs46xx_pcm * cpcm;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tcpcm = kzalloc(sizeof(*cpcm), GFP_KERNEL);\n\tif (cpcm == NULL)\n\t\treturn -ENOMEM;\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\tPAGE_SIZE, &cpcm->hw_buf) < 0) {\n\t\tkfree(cpcm);\n\t\treturn -ENOMEM;\n\t}\n\n\truntime->hw = snd_cs46xx_playback;\n\truntime->private_data = cpcm;\n\truntime->private_free = snd_cs46xx_pcm_free_substream;\n\n\tcpcm->substream = substream;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tmutex_lock(&chip->spos_mutex);\n\tcpcm->pcm_channel = NULL; \n\tcpcm->pcm_channel_id = pcm_channel_id;\n\n\n\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES, \n\t\t\t\t   &hw_constraints_period_sizes);\n\n\tmutex_unlock(&chip->spos_mutex);\n#else\n\tchip->playback_pcm = cpcm;  \n#endif\n\n\tif (chip->accept_valid)\n\t\tsubstream->runtime->hw.info |= SNDRV_PCM_INFO_MMAP_VALID;\n\tchip->active_ctrl(chip, 1);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_playback_open(struct snd_pcm_substream *substream)\n{\n\tdev_dbg(substream->pcm->card->dev, \"open front channel\\n\");\n\treturn _cs46xx_playback_open_channel(substream,DSP_PCM_MAIN_CHANNEL);\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nstatic int snd_cs46xx_playback_open_rear(struct snd_pcm_substream *substream)\n{\n\tdev_dbg(substream->pcm->card->dev, \"open rear channel\\n\");\n\treturn _cs46xx_playback_open_channel(substream,DSP_PCM_REAR_CHANNEL);\n}\n\nstatic int snd_cs46xx_playback_open_clfe(struct snd_pcm_substream *substream)\n{\n\tdev_dbg(substream->pcm->card->dev, \"open center - LFE channel\\n\");\n\treturn _cs46xx_playback_open_channel(substream,DSP_PCM_CENTER_LFE_CHANNEL);\n}\n\nstatic int snd_cs46xx_playback_open_iec958(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\n\tdev_dbg(chip->card->dev, \"open raw iec958 channel\\n\");\n\n\tmutex_lock(&chip->spos_mutex);\n\tcs46xx_iec958_pre_open (chip);\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn _cs46xx_playback_open_channel(substream,DSP_IEC958_CHANNEL);\n}\n\nstatic int snd_cs46xx_playback_close(struct snd_pcm_substream *substream);\n\nstatic int snd_cs46xx_playback_close_iec958(struct snd_pcm_substream *substream)\n{\n\tint err;\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n  \n\tdev_dbg(chip->card->dev, \"close raw iec958 channel\\n\");\n\n\terr = snd_cs46xx_playback_close(substream);\n\n\tmutex_lock(&chip->spos_mutex);\n\tcs46xx_iec958_post_close (chip);\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn err;\n}\n#endif\n\nstatic int snd_cs46xx_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\n\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\tPAGE_SIZE, &chip->capt.hw_buf) < 0)\n\t\treturn -ENOMEM;\n\tchip->capt.substream = substream;\n\tsubstream->runtime->hw = snd_cs46xx_capture;\n\n\tif (chip->accept_valid)\n\t\tsubstream->runtime->hw.info |= SNDRV_PCM_INFO_MMAP_VALID;\n\n\tchip->active_ctrl(chip, 1);\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES, \n\t\t\t\t   &hw_constraints_period_sizes);\n#endif\n\treturn 0;\n}\n\nstatic int snd_cs46xx_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_cs46xx_pcm * cpcm;\n\n\tcpcm = runtime->private_data;\n\n\t \n\tif (!cpcm) return -ENXIO;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tmutex_lock(&chip->spos_mutex);\n\tif (cpcm->pcm_channel) {\n\t\tcs46xx_dsp_destroy_pcm_channel(chip,cpcm->pcm_channel);\n\t\tcpcm->pcm_channel = NULL;\n\t}\n\tmutex_unlock(&chip->spos_mutex);\n#else\n\tchip->playback_pcm = NULL;\n#endif\n\n\tcpcm->substream = NULL;\n\tsnd_dma_free_pages(&cpcm->hw_buf);\n\tchip->active_ctrl(chip, -1);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\n\n\tchip->capt.substream = NULL;\n\tsnd_dma_free_pages(&chip->capt.hw_buf);\n\tchip->active_ctrl(chip, -1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nstatic const struct snd_pcm_ops snd_cs46xx_playback_rear_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_rear,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_direct_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_rear_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_rear,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_indirect_pointer,\n\t.ack =\t\t\tsnd_cs46xx_playback_transfer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_clfe_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_clfe,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_direct_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_clfe_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_clfe,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_indirect_pointer,\n\t.ack =\t\t\tsnd_cs46xx_playback_transfer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_iec958_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_iec958,\n\t.close =\t\tsnd_cs46xx_playback_close_iec958,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_direct_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_iec958_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open_iec958,\n\t.close =\t\tsnd_cs46xx_playback_close_iec958,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_indirect_pointer,\n\t.ack =\t\t\tsnd_cs46xx_playback_transfer,\n};\n\n#endif\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_direct_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_playback_indirect_ops = {\n\t.open =\t\t\tsnd_cs46xx_playback_open,\n\t.close =\t\tsnd_cs46xx_playback_close,\n\t.hw_params =\t\tsnd_cs46xx_playback_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_playback_hw_free,\n\t.prepare =\t\tsnd_cs46xx_playback_prepare,\n\t.trigger =\t\tsnd_cs46xx_playback_trigger,\n\t.pointer =\t\tsnd_cs46xx_playback_indirect_pointer,\n\t.ack =\t\t\tsnd_cs46xx_playback_transfer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_capture_ops = {\n\t.open =\t\t\tsnd_cs46xx_capture_open,\n\t.close =\t\tsnd_cs46xx_capture_close,\n\t.hw_params =\t\tsnd_cs46xx_capture_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_capture_hw_free,\n\t.prepare =\t\tsnd_cs46xx_capture_prepare,\n\t.trigger =\t\tsnd_cs46xx_capture_trigger,\n\t.pointer =\t\tsnd_cs46xx_capture_direct_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs46xx_capture_indirect_ops = {\n\t.open =\t\t\tsnd_cs46xx_capture_open,\n\t.close =\t\tsnd_cs46xx_capture_close,\n\t.hw_params =\t\tsnd_cs46xx_capture_hw_params,\n\t.hw_free =\t\tsnd_cs46xx_capture_hw_free,\n\t.prepare =\t\tsnd_cs46xx_capture_prepare,\n\t.trigger =\t\tsnd_cs46xx_capture_trigger,\n\t.pointer =\t\tsnd_cs46xx_capture_indirect_pointer,\n\t.ack =\t\t\tsnd_cs46xx_capture_transfer,\n};\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n#define MAX_PLAYBACK_CHANNELS\t(DSP_MAX_PCM_CHANNELS - 1)\n#else\n#define MAX_PLAYBACK_CHANNELS\t1\n#endif\n\nint snd_cs46xx_pcm(struct snd_cs46xx *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"CS46xx\", device, MAX_PLAYBACK_CHANNELS, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs46xx_capture_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS46xx\");\n\tchip->pcm = pcm;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t      &chip->pci->dev,\n\t\t\t\t\t      64*1024, 256*1024);\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nint snd_cs46xx_pcm_rear(struct snd_cs46xx *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"CS46xx - Rear\", device, MAX_PLAYBACK_CHANNELS, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_rear_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS46xx - Rear\");\n\tchip->pcm_rear = pcm;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t      &chip->pci->dev,\n\t\t\t\t\t      64*1024, 256*1024);\n\n\treturn 0;\n}\n\nint snd_cs46xx_pcm_center_lfe(struct snd_cs46xx *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"CS46xx - Center LFE\", device, MAX_PLAYBACK_CHANNELS, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_clfe_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS46xx - Center LFE\");\n\tchip->pcm_center_lfe = pcm;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t      &chip->pci->dev,\n\t\t\t\t\t      64*1024, 256*1024);\n\n\treturn 0;\n}\n\nint snd_cs46xx_pcm_iec958(struct snd_cs46xx *chip, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"CS46xx - IEC958\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_iec958_ops);\n\n\t \n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"CS46xx - IEC958\");\n\tchip->pcm_iec958 = pcm;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t      &chip->pci->dev,\n\t\t\t\t\t      64*1024, 256*1024);\n\n\treturn 0;\n}\n#endif\n\n \nstatic void snd_cs46xx_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct snd_cs46xx *chip = ac97->private_data;\n\n\tif (snd_BUG_ON(ac97 != chip->ac97[CS46XX_PRIMARY_CODEC_INDEX] &&\n\t\t       ac97 != chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]))\n\t\treturn;\n\n\tif (ac97 == chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]) {\n\t\tchip->ac97[CS46XX_PRIMARY_CODEC_INDEX] = NULL;\n\t\tchip->eapd_switch = NULL;\n\t}\n\telse\n\t\tchip->ac97[CS46XX_SECONDARY_CODEC_INDEX] = NULL;\n}\n\nstatic int snd_cs46xx_vol_info(struct snd_kcontrol *kcontrol, \n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x7fff;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value;\n\tunsigned int val = snd_cs46xx_peek(chip, reg);\n\tucontrol->value.integer.value[0] = 0xffff - (val >> 16);\n\tucontrol->value.integer.value[1] = 0xffff - (val & 0xffff);\n\treturn 0;\n}\n\nstatic int snd_cs46xx_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value;\n\tunsigned int val = ((0xffff - ucontrol->value.integer.value[0]) << 16 | \n\t\t\t    (0xffff - ucontrol->value.integer.value[1]));\n\tunsigned int old = snd_cs46xx_peek(chip, reg);\n\tint change = (old != val);\n\n\tif (change) {\n\t\tsnd_cs46xx_poke(chip, reg, val);\n\t}\n\n\treturn change;\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\nstatic int snd_cs46xx_vol_dac_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = chip->dsp_spos_instance->dac_volume_left;\n\tucontrol->value.integer.value[1] = chip->dsp_spos_instance->dac_volume_right;\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_vol_dac_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint change = 0;\n\n\tif (chip->dsp_spos_instance->dac_volume_right != ucontrol->value.integer.value[0] ||\n\t    chip->dsp_spos_instance->dac_volume_left != ucontrol->value.integer.value[1]) {\n\t\tcs46xx_dsp_set_dac_volume(chip,\n\t\t\t\t\t  ucontrol->value.integer.value[0],\n\t\t\t\t\t  ucontrol->value.integer.value[1]);\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n\n#if 0\nstatic int snd_cs46xx_vol_iec958_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = chip->dsp_spos_instance->spdif_input_volume_left;\n\tucontrol->value.integer.value[1] = chip->dsp_spos_instance->spdif_input_volume_right;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_vol_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint change = 0;\n\n\tif (chip->dsp_spos_instance->spdif_input_volume_left  != ucontrol->value.integer.value[0] ||\n\t    chip->dsp_spos_instance->spdif_input_volume_right!= ucontrol->value.integer.value[1]) {\n\t\tcs46xx_dsp_set_iec958_volume (chip,\n\t\t\t\t\t      ucontrol->value.integer.value[0],\n\t\t\t\t\t      ucontrol->value.integer.value[1]);\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n#endif\n\n#define snd_mixer_boolean_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_cs46xx_iec958_get(struct snd_kcontrol *kcontrol, \n                                 struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value;\n\n\tif (reg == CS46XX_MIXER_SPDIF_OUTPUT_ELEMENT)\n\t\tucontrol->value.integer.value[0] = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);\n\telse\n\t\tucontrol->value.integer.value[0] = chip->dsp_spos_instance->spdif_status_in;\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_iec958_put(struct snd_kcontrol *kcontrol, \n                                  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint change, res;\n\n\tswitch (kcontrol->private_value) {\n\tcase CS46XX_MIXER_SPDIF_OUTPUT_ELEMENT:\n\t\tmutex_lock(&chip->spos_mutex);\n\t\tchange = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);\n\t\tif (ucontrol->value.integer.value[0] && !change) \n\t\t\tcs46xx_dsp_enable_spdif_out(chip);\n\t\telse if (change && !ucontrol->value.integer.value[0])\n\t\t\tcs46xx_dsp_disable_spdif_out(chip);\n\n\t\tres = (change != (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED));\n\t\tmutex_unlock(&chip->spos_mutex);\n\t\tbreak;\n\tcase CS46XX_MIXER_SPDIF_INPUT_ELEMENT:\n\t\tchange = chip->dsp_spos_instance->spdif_status_in;\n\t\tif (ucontrol->value.integer.value[0] && !change) {\n\t\t\tcs46xx_dsp_enable_spdif_in(chip);\n\t\t\t \n\t\t}\n\t\telse if (change && !ucontrol->value.integer.value[0])\n\t\t\tcs46xx_dsp_disable_spdif_in(chip);\n\t\t\n\t\tres = (change != chip->dsp_spos_instance->spdif_status_in);\n\t\tbreak;\n\tdefault:\n\t\tres = -EINVAL;\n\t\tsnd_BUG();  \n\t}\n\n\treturn res;\n}\n\nstatic int snd_cs46xx_adc_capture_get(struct snd_kcontrol *kcontrol, \n                                      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (ins->adc_input != NULL) \n\t\tucontrol->value.integer.value[0] = 1;\n\telse \n\t\tucontrol->value.integer.value[0] = 0;\n\t\n\treturn 0;\n}\n\nstatic int snd_cs46xx_adc_capture_put(struct snd_kcontrol *kcontrol, \n                                      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint change = 0;\n\n\tif (ucontrol->value.integer.value[0] && !ins->adc_input) {\n\t\tcs46xx_dsp_enable_adc_capture(chip);\n\t\tchange = 1;\n\t} else  if (!ucontrol->value.integer.value[0] && ins->adc_input) {\n\t\tcs46xx_dsp_disable_adc_capture(chip);\n\t\tchange = 1;\n\t}\n\treturn change;\n}\n\nstatic int snd_cs46xx_pcm_capture_get(struct snd_kcontrol *kcontrol, \n                                      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tif (ins->pcm_input != NULL) \n\t\tucontrol->value.integer.value[0] = 1;\n\telse \n\t\tucontrol->value.integer.value[0] = 0;\n\n\treturn 0;\n}\n\n\nstatic int snd_cs46xx_pcm_capture_put(struct snd_kcontrol *kcontrol, \n                                      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tint change = 0;\n\n\tif (ucontrol->value.integer.value[0] && !ins->pcm_input) {\n\t\tcs46xx_dsp_enable_pcm_capture(chip);\n\t\tchange = 1;\n\t} else  if (!ucontrol->value.integer.value[0] && ins->pcm_input) {\n\t\tcs46xx_dsp_disable_pcm_capture(chip);\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n\nstatic int snd_herc_spdif_select_get(struct snd_kcontrol *kcontrol, \n                                     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\n\tint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\n\n\tif (val1 & EGPIODR_GPOE0)\n\t\tucontrol->value.integer.value[0] = 1;\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\n\treturn 0;\n}\n\n  \nstatic int snd_herc_spdif_select_put(struct snd_kcontrol *kcontrol, \n                                       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\n\tint val2 = snd_cs46xx_peekBA0(chip, BA0_EGPIOPTR);\n\n\tif (ucontrol->value.integer.value[0]) {\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, \n\t\t\t\t   EGPIODR_GPOE0 | val1);   \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, \n\t\t\t\t   EGPIOPTR_GPPT0 | val2);  \n\t} else {\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR,  val1 & ~EGPIODR_GPOE0);  \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, val2 & ~EGPIOPTR_GPPT0);  \n\t}\n\n\t \n\treturn (val1 != (int)snd_cs46xx_peekBA0(chip, BA0_EGPIODR));\n}\n\n\nstatic int snd_cs46xx_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_spdif_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tmutex_lock(&chip->spos_mutex);\n\tucontrol->value.iec958.status[0] = _wrap_all_bits((ins->spdif_csuv_default >> 24) & 0xff);\n\tucontrol->value.iec958.status[1] = _wrap_all_bits((ins->spdif_csuv_default >> 16) & 0xff);\n\tucontrol->value.iec958.status[2] = 0;\n\tucontrol->value.iec958.status[3] = _wrap_all_bits((ins->spdif_csuv_default) & 0xff);\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_spdif_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx * chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tunsigned int val;\n\tint change;\n\n\tmutex_lock(&chip->spos_mutex);\n\tval = ((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[0]) << 24) |\n\t\t((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[2]) << 16) |\n\t\t((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[3]))  |\n\t\t \n\t\t(1 << 13) | (1 << 12);\n\n\n\tchange = (unsigned int)ins->spdif_csuv_default != val;\n\tins->spdif_csuv_default = val;\n\n\tif ( !(ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) )\n\t\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV,val);\n\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn change;\n}\n\nstatic int snd_cs46xx_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0x00;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_spdif_stream_get(struct snd_kcontrol *kcontrol,\n                                         struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\n\tmutex_lock(&chip->spos_mutex);\n\tucontrol->value.iec958.status[0] = _wrap_all_bits((ins->spdif_csuv_stream >> 24) & 0xff);\n\tucontrol->value.iec958.status[1] = _wrap_all_bits((ins->spdif_csuv_stream >> 16) & 0xff);\n\tucontrol->value.iec958.status[2] = 0;\n\tucontrol->value.iec958.status[3] = _wrap_all_bits((ins->spdif_csuv_stream) & 0xff);\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn 0;\n}\n\nstatic int snd_cs46xx_spdif_stream_put(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx * chip = snd_kcontrol_chip(kcontrol);\n\tstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\n\tunsigned int val;\n\tint change;\n\n\tmutex_lock(&chip->spos_mutex);\n\tval = ((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[0]) << 24) |\n\t\t((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[1]) << 16) |\n\t\t((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[3])) |\n\t\t \n\t\t(1 << 13) | (1 << 12);\n\n\n\tchange = ins->spdif_csuv_stream != val;\n\tins->spdif_csuv_stream = val;\n\n\tif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN )\n\t\tcs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV,val);\n\n\tmutex_unlock(&chip->spos_mutex);\n\n\treturn change;\n}\n\n#endif  \n\n\nstatic const struct snd_kcontrol_new snd_cs46xx_controls[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DAC Volume\",\n\t.info = snd_cs46xx_vol_info,\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\n\t.get = snd_cs46xx_vol_get,\n\t.put = snd_cs46xx_vol_put,\n\t.private_value = BA1_PVOL,\n#else\n\t.get = snd_cs46xx_vol_dac_get,\n\t.put = snd_cs46xx_vol_dac_put,\n#endif\n},\n\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"ADC Volume\",\n\t.info = snd_cs46xx_vol_info,\n\t.get = snd_cs46xx_vol_get,\n\t.put = snd_cs46xx_vol_put,\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\n\t.private_value = BA1_CVOL,\n#else\n\t.private_value = (VARIDECIMATE_SCB_ADDR + 0xE) << 2,\n#endif\n},\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"ADC Capture Switch\",\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_cs46xx_adc_capture_get,\n\t.put = snd_cs46xx_adc_capture_put\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DAC Capture Switch\",\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_cs46xx_pcm_capture_get,\n\t.put = snd_cs46xx_pcm_capture_put\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"Output \",NONE,SWITCH),\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_cs46xx_iec958_get,\n\t.put = snd_cs46xx_iec958_put,\n\t.private_value = CS46XX_MIXER_SPDIF_OUTPUT_ELEMENT,\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"Input \",NONE,SWITCH),\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_cs46xx_iec958_get,\n\t.put = snd_cs46xx_iec958_put,\n\t.private_value = CS46XX_MIXER_SPDIF_INPUT_ELEMENT,\n},\n#if 0\n \n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = SNDRV_CTL_NAME_IEC958(\"Input \",NONE,VOLUME),\n\t.info = snd_cs46xx_vol_info,\n\t.get = snd_cs46xx_vol_iec958_get,\n\t.put = snd_cs46xx_vol_iec958_put,\n\t.private_value = (ASYNCRX_SCB_ADDR + 0xE) << 2,\n},\n#endif\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =  SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t snd_cs46xx_spdif_info,\n\t.get =\t snd_cs46xx_spdif_default_get,\n\t.put =   snd_cs46xx_spdif_default_put,\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.info =\t snd_cs46xx_spdif_info,\n        .get =\t snd_cs46xx_spdif_mask_get,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ\n},\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t snd_cs46xx_spdif_info,\n\t.get =\t snd_cs46xx_spdif_stream_get,\n\t.put =\t snd_cs46xx_spdif_stream_put\n},\n\n#endif\n};\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n \nstatic int snd_cs46xx_front_dup_get(struct snd_kcontrol *kcontrol, \n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned short val;\n\tval = snd_ac97_read(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX], AC97_CSR_ACMODE);\n\tucontrol->value.integer.value[0] = (val & 0x200) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_front_dup_put(struct snd_kcontrol *kcontrol, \n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\n\treturn snd_ac97_update_bits(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],\n\t\t\t\t    AC97_CSR_ACMODE, 0x200,\n\t\t\t\t    ucontrol->value.integer.value[0] ? 0 : 0x200);\n}\n\nstatic const struct snd_kcontrol_new snd_cs46xx_front_dup_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Duplicate Front\",\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_cs46xx_front_dup_get,\n\t.put = snd_cs46xx_front_dup_put,\n};\n#endif\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n \nstatic const struct snd_kcontrol_new snd_hercules_controls[] = {\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Optical/Coaxial SPDIF Input Switch\",\n\t.info = snd_mixer_boolean_info,\n\t.get = snd_herc_spdif_select_get,\n\t.put = snd_herc_spdif_select_put,\n},\n};\n\n\nstatic void snd_cs46xx_codec_reset (struct snd_ac97 * ac97)\n{\n\tunsigned long end_time;\n\tint err;\n\n\t \n\tsnd_ac97_write(ac97, AC97_RESET, 0);\t\n\n\t \n\tif (ac97->num == CS46XX_PRIMARY_CODEC_INDEX) {\n\t\tdev_dbg(ac97->bus->card->dev, \"CODEC1 mode %04x\\n\", 0x0);\n\t\tsnd_cs46xx_ac97_write(ac97, AC97_CSR_ACMODE, 0x0);\n\t} else if (ac97->num == CS46XX_SECONDARY_CODEC_INDEX) {\n\t\tdev_dbg(ac97->bus->card->dev, \"CODEC2 mode %04x\\n\", 0x3);\n\t\tsnd_cs46xx_ac97_write(ac97, AC97_CSR_ACMODE, 0x3);\n\t} else {\n\t\tsnd_BUG();  \n\t}\n\n\tudelay(50);\n\n\t \n\t \n\t \n\tend_time = jiffies + HZ;\n\tdo {\n\t\tunsigned short ext_mid;\n    \n\t\t \n\t\tsnd_ac97_read(ac97, AC97_RESET);\n\t\tsnd_ac97_read(ac97, AC97_VENDOR_ID1);\n\t\tsnd_ac97_read(ac97, AC97_VENDOR_ID2);\n\t\t \n\t\text_mid = snd_ac97_read(ac97, AC97_EXTENDED_MID);\n\t\tif (ext_mid != 0xffff && (ext_mid & 1) != 0)\n\t\t\treturn;\n\n\t\t \n\t\tsnd_ac97_write(ac97, AC97_REC_GAIN, 0x8a05);\n\t\terr = snd_ac97_read(ac97, AC97_REC_GAIN);\n\t\tif (err == 0x8a05)\n\t\t\treturn;\n\n\t\tmsleep(10);\n\t} while (time_after_eq(end_time, jiffies));\n\n\tdev_err(ac97->bus->card->dev,\n\t\t\"CS46xx secondary codec doesn't respond!\\n\");\n}\n#endif\n\nstatic int cs46xx_detect_codec(struct snd_cs46xx *chip, int codec)\n{\n\tint idx, err;\n\tstruct snd_ac97_template ac97;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_cs46xx_mixer_free_ac97;\n\tac97.num = codec;\n\tif (chip->amplifier_ctrl == amp_voyetra)\n\t\tac97.scaps = AC97_SCAP_INV_EAPD;\n\n\tif (codec == CS46XX_SECONDARY_CODEC_INDEX) {\n\t\tsnd_cs46xx_codec_write(chip, AC97_RESET, 0, codec);\n\t\tudelay(10);\n\t\tif (snd_cs46xx_codec_read(chip, AC97_RESET, codec) & 0x8000) {\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"secondary codec not present\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tsnd_cs46xx_codec_write(chip, AC97_MASTER, 0x8000, codec);\n\tfor (idx = 0; idx < 100; ++idx) {\n\t\tif (snd_cs46xx_codec_read(chip, AC97_MASTER, codec) == 0x8000) {\n\t\t\terr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97[codec]);\n\t\t\treturn err;\n\t\t}\n\t\tmsleep(10);\n\t}\n\tdev_dbg(chip->card->dev, \"codec %d detection timeout\\n\", codec);\n\treturn -ENXIO;\n}\n\nint snd_cs46xx_mixer(struct snd_cs46xx *chip, int spdif_device)\n{\n\tstruct snd_card *card = chip->card;\n\tint err;\n\tunsigned int idx;\n\tstatic const struct snd_ac97_bus_ops ops = {\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t\t.reset = snd_cs46xx_codec_reset,\n#endif\n\t\t.write = snd_cs46xx_ac97_write,\n\t\t.read = snd_cs46xx_ac97_read,\n\t};\n\n\t \n\tchip->nr_ac97_codecs = 0;\n\tdev_dbg(chip->card->dev, \"detecting primary codec\\n\");\n\terr = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cs46xx_detect_codec(chip, CS46XX_PRIMARY_CODEC_INDEX) < 0)\n\t\treturn -ENXIO;\n\tchip->nr_ac97_codecs = 1;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tdev_dbg(chip->card->dev, \"detecting secondary codec\\n\");\n\t \n\tif (! cs46xx_detect_codec(chip, CS46XX_SECONDARY_CODEC_INDEX))\n\t\tchip->nr_ac97_codecs = 2;\n#endif  \n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs46xx_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tkctl = snd_ctl_new1(&snd_cs46xx_controls[idx], chip);\n\t\tif (kctl && kctl->id.iface == SNDRV_CTL_ELEM_IFACE_PCM)\n\t\t\tkctl->id.device = spdif_device;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tchip->eapd_switch = snd_ctl_find_id_mixer(chip->card,\n\t\t\t\t\t\t  \"External Amplifier\");\n    \n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (chip->nr_ac97_codecs == 1) {\n\t\tunsigned int id2 = chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]->id & 0xffff;\n\t\tif ((id2 & 0xfff0) == 0x5920) {\t \n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_cs46xx_front_dup_ctl, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tsnd_ac97_write_cache(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],\n\t\t\t\t\t     AC97_CSR_ACMODE, 0x200);\n\t\t}\n\t}\n\t \n\tif (chip->mixer_init) {\n\t\tdev_dbg(chip->card->dev, \"calling chip->mixer_init(chip);\\n\");\n\t\tchip->mixer_init(chip);\n\t}\n#endif\n\n \t \n\tchip->amplifier_ctrl(chip, 1);\n    \n\treturn 0;\n}\n\n \n\nstatic void snd_cs46xx_midi_reset(struct snd_cs46xx *chip)\n{\n\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, MIDCR_MRST);\n\tudelay(100);\n\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n}\n\nstatic int snd_cs46xx_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\n\tchip->active_ctrl(chip, 1);\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->uartm |= CS46XX_MODE_INPUT;\n\tchip->midcr |= MIDCR_RXE;\n\tchip->midi_input = substream;\n\tif (!(chip->uartm & CS46XX_MODE_OUTPUT)) {\n\t\tsnd_cs46xx_midi_reset(chip);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs46xx_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->midcr &= ~(MIDCR_RXE | MIDCR_RIE);\n\tchip->midi_input = NULL;\n\tif (!(chip->uartm & CS46XX_MODE_OUTPUT)) {\n\t\tsnd_cs46xx_midi_reset(chip);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tchip->uartm &= ~CS46XX_MODE_INPUT;\n\tspin_unlock_irq(&chip->reg_lock);\n\tchip->active_ctrl(chip, -1);\n\treturn 0;\n}\n\nstatic int snd_cs46xx_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\n\tchip->active_ctrl(chip, 1);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->uartm |= CS46XX_MODE_OUTPUT;\n\tchip->midcr |= MIDCR_TXE;\n\tchip->midi_output = substream;\n\tif (!(chip->uartm & CS46XX_MODE_INPUT)) {\n\t\tsnd_cs46xx_midi_reset(chip);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_cs46xx_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tchip->midcr &= ~(MIDCR_TXE | MIDCR_TIE);\n\tchip->midi_output = NULL;\n\tif (!(chip->uartm & CS46XX_MODE_INPUT)) {\n\t\tsnd_cs46xx_midi_reset(chip);\n\t} else {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t}\n\tchip->uartm &= ~CS46XX_MODE_OUTPUT;\n\tspin_unlock_irq(&chip->reg_lock);\n\tchip->active_ctrl(chip, -1);\n\treturn 0;\n}\n\nstatic void snd_cs46xx_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (up) {\n\t\tif ((chip->midcr & MIDCR_RIE) == 0) {\n\t\t\tchip->midcr |= MIDCR_RIE;\n\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t} else {\n\t\tif (chip->midcr & MIDCR_RIE) {\n\t\t\tchip->midcr &= ~MIDCR_RIE;\n\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic void snd_cs46xx_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_cs46xx *chip = substream->rmidi->private_data;\n\tunsigned char byte;\n\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tif (up) {\n\t\tif ((chip->midcr & MIDCR_TIE) == 0) {\n\t\t\tchip->midcr |= MIDCR_TIE;\n\t\t\t \n\t\t\twhile ((chip->midcr & MIDCR_TIE) &&\n\t\t\t       (snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_TBF) == 0) {\n\t\t\t\tif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\tchip->midcr &= ~MIDCR_TIE;\n\t\t\t\t} else {\n\t\t\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDWP, byte);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t} else {\n\t\tif (chip->midcr & MIDCR_TIE) {\n\t\t\tchip->midcr &= ~MIDCR_TIE;\n\t\t\tsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_cs46xx_midi_output =\n{\n\t.open =\t\tsnd_cs46xx_midi_output_open,\n\t.close =\tsnd_cs46xx_midi_output_close,\n\t.trigger =\tsnd_cs46xx_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_cs46xx_midi_input =\n{\n\t.open =\t\tsnd_cs46xx_midi_input_open,\n\t.close =\tsnd_cs46xx_midi_input_close,\n\t.trigger =\tsnd_cs46xx_midi_input_trigger,\n};\n\nint snd_cs46xx_midi(struct snd_cs46xx *chip, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(chip->card, \"CS46XX\", device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, \"CS46XX\");\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_cs46xx_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_cs46xx_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = chip;\n\tchip->rmidi = rmidi;\n\treturn 0;\n}\n\n\n \n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n\nstatic void snd_cs46xx_gameport_trigger(struct gameport *gameport)\n{\n\tstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn;\n\tsnd_cs46xx_pokeBA0(chip, BA0_JSPT, 0xFF);   \n}\n\nstatic unsigned char snd_cs46xx_gameport_read(struct gameport *gameport)\n{\n\tstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\treturn snd_cs46xx_peekBA0(chip, BA0_JSPT);  \n}\n\nstatic int snd_cs46xx_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\n\tunsigned js1, js2, jst;\n\n\tif (snd_BUG_ON(!chip))\n\t\treturn 0;\n\n\tjs1 = snd_cs46xx_peekBA0(chip, BA0_JSC1);\n\tjs2 = snd_cs46xx_peekBA0(chip, BA0_JSC2);\n\tjst = snd_cs46xx_peekBA0(chip, BA0_JSPT);\n\t\n\t*buttons = (~jst >> 4) & 0x0F; \n\t\n\taxes[0] = ((js1 & JSC1_Y1V_MASK) >> JSC1_Y1V_SHIFT) & 0xFFFF;\n\taxes[1] = ((js1 & JSC1_X1V_MASK) >> JSC1_X1V_SHIFT) & 0xFFFF;\n\taxes[2] = ((js2 & JSC2_Y2V_MASK) >> JSC2_Y2V_SHIFT) & 0xFFFF;\n\taxes[3] = ((js2 & JSC2_X2V_MASK) >> JSC2_X2V_SHIFT) & 0xFFFF;\n\n\tfor(jst=0;jst<4;++jst)\n\t\tif(axes[jst]==0xFFFF) axes[jst] = -1;\n\treturn 0;\n}\n\nstatic int snd_cs46xx_gameport_open(struct gameport *gameport, int mode)\n{\n\tswitch (mode) {\n\tcase GAMEPORT_MODE_COOKED:\n\t\treturn 0;\n\tcase GAMEPORT_MODE_RAW:\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint snd_cs46xx_gameport(struct snd_cs46xx *chip)\n{\n\tstruct gameport *gp;\n\n\tchip->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"CS46xx Gameport\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(chip->pci));\n\tgameport_set_dev_parent(gp, &chip->pci->dev);\n\tgameport_set_port_data(gp, chip);\n\n\tgp->open = snd_cs46xx_gameport_open;\n\tgp->read = snd_cs46xx_gameport_read;\n\tgp->trigger = snd_cs46xx_gameport_trigger;\n\tgp->cooked_read = snd_cs46xx_gameport_cooked_read;\n\n\tsnd_cs46xx_pokeBA0(chip, BA0_JSIO, 0xFF);  \n\tsnd_cs46xx_pokeBA0(chip, BA0_JSCTL, JSCTL_SP_MEDIUM_SLOW);\n\n\tgameport_register_port(gp);\n\n\treturn 0;\n}\n\nstatic inline void snd_cs46xx_remove_gameport(struct snd_cs46xx *chip)\n{\n\tif (chip->gameport) {\n\t\tgameport_unregister_port(chip->gameport);\n\t\tchip->gameport = NULL;\n\t}\n}\n#else\nint snd_cs46xx_gameport(struct snd_cs46xx *chip) { return -ENOSYS; }\nstatic inline void snd_cs46xx_remove_gameport(struct snd_cs46xx *chip) { }\n#endif  \n\n#ifdef CONFIG_SND_PROC_FS\n \n\nstatic ssize_t snd_cs46xx_io_read(struct snd_info_entry *entry,\n\t\t\t\t  void *file_private_data,\n\t\t\t\t  struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t pos)\n{\n\tstruct snd_cs46xx_region *region = entry->private_data;\n\t\n\tif (copy_to_user_fromio(buf, region->remap_addr + pos, count))\n\t\treturn -EFAULT;\n\treturn count;\n}\n\nstatic const struct snd_info_entry_ops snd_cs46xx_proc_io_ops = {\n\t.read = snd_cs46xx_io_read,\n};\n\nstatic int snd_cs46xx_proc_init(struct snd_card *card, struct snd_cs46xx *chip)\n{\n\tstruct snd_info_entry *entry;\n\tint idx;\n\t\n\tfor (idx = 0; idx < 5; idx++) {\n\t\tstruct snd_cs46xx_region *region = &chip->region.idx[idx];\n\t\tif (! snd_card_proc_new(card, region->name, &entry)) {\n\t\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\t\tentry->private_data = chip;\n\t\t\tentry->c.ops = &snd_cs46xx_proc_io_ops;\n\t\t\tentry->size = region->size;\n\t\t\tentry->mode = S_IFREG | 0400;\n\t\t}\n\t}\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tcs46xx_dsp_proc_init(card, chip);\n#endif\n\treturn 0;\n}\n\nstatic int snd_cs46xx_proc_done(struct snd_cs46xx *chip)\n{\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tcs46xx_dsp_proc_done(chip);\n#endif\n\treturn 0;\n}\n#else  \n#define snd_cs46xx_proc_init(card, chip)\n#define snd_cs46xx_proc_done(chip)\n#endif\n\n \nstatic void snd_cs46xx_hw_stop(struct snd_cs46xx *chip)\n{\n\tunsigned int tmp;\n\n\ttmp = snd_cs46xx_peek(chip, BA1_PFIE);\n\ttmp &= ~0x0000f03f;\n\ttmp |=  0x00000010;\n\tsnd_cs46xx_poke(chip, BA1_PFIE, tmp);\t \n\n\ttmp = snd_cs46xx_peek(chip, BA1_CIE);\n\ttmp &= ~0x0000003f;\n\ttmp |=  0x00000011;\n\tsnd_cs46xx_poke(chip, BA1_CIE, tmp);\t \n\n\t \n\ttmp = snd_cs46xx_peek(chip, BA1_PCTL);\n\tsnd_cs46xx_poke(chip, BA1_PCTL, tmp & 0x0000ffff);\n\n\t \n\ttmp = snd_cs46xx_peek(chip, BA1_CCTL);\n\tsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\n\n\t \n\tsnd_cs46xx_reset(chip);\n\n\tsnd_cs46xx_proc_stop(chip);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, 0);\n\n\t \n\ttmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1) & ~CLKCR1_SWCE;\n\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\n}\n\n\nstatic void snd_cs46xx_free(struct snd_card *card)\n{\n\tstruct snd_cs46xx *chip = card->private_data;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tint idx;\n#endif\n\n\tif (chip->active_ctrl)\n\t\tchip->active_ctrl(chip, 1);\n\n\tsnd_cs46xx_remove_gameport(chip);\n\n\tif (chip->amplifier_ctrl)\n\t\tchip->amplifier_ctrl(chip, -chip->amplifier);  \n\t\n\tsnd_cs46xx_proc_done(chip);\n\n\tsnd_cs46xx_hw_stop(chip);\n\n\tif (chip->active_ctrl)\n\t\tchip->active_ctrl(chip, -chip->amplifier);\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (chip->dsp_spos_instance) {\n\t\tcs46xx_dsp_spos_destroy(chip);\n\t\tchip->dsp_spos_instance = NULL;\n\t}\n\tfor (idx = 0; idx < CS46XX_DSP_MODULES; idx++)\n\t\tfree_module_desc(chip->modules[idx]);\n#else\n\tvfree(chip->ba1);\n#endif\n}\n\n \nstatic int snd_cs46xx_chip_init(struct snd_cs46xx *chip)\n{\n\tint timeout;\n\n\t \n        snd_cs46xx_pokeBA0(chip, BA0_CLKCR1, 0);\n        snd_cs46xx_pokeBA0(chip, BA0_SERMC1, 0);\n\n\t         \n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_2_0 | \n\t\t\t   SERACC_TWO_CODECS);\t \n\t   \n#else\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_1_03);  \n#endif\n\n         \n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, 0);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, 0);\n#endif\n\tudelay(50);\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_RSTN);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_RSTN);\n#endif\n    \n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_ESYN | ACCTL_RSTN);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_ESYN | ACCTL_RSTN);\n#endif\n\n\t \n\tmdelay(10);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_SERMC1, SERMC1_PTC_AC97);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_PLLCC, PLLCC_LPF_1050_2780_KHZ | PLLCC_CDR_73_104_MHZ);\n\tsnd_cs46xx_pokeBA0(chip, BA0_PLLM, 0x3a);\n\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR2, CLKCR2_PDIVS_8);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, CLKCR1_PLLP);\n\n\t \n\tmsleep(100);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, CLKCR1_PLLP | CLKCR1_SWCE);\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_SERBCF, SERBCF_HBP);\n\n\t \n\tsnd_cs46xx_clear_serial_FIFOs(chip);\n\n\t \n\t \n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC1, SERC1_SO1F_AC97 | SERC1_SO1EN);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC2, SERC2_SI1F_AC97 | SERC1_SO1EN);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERMC1, SERMC1_PTC_AC97 | SERMC1_MSPE);\n\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC7, SERC7_ASDI2EN);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC3, 0);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC4, 0);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC5, 0);\n\tsnd_cs46xx_pokeBA0(chip, BA0_SERC6, 1);\n#endif\n\n\tmdelay(5);\n\n\n\t \n\ttimeout = 150;\n\twhile (timeout-- > 0) {\n\t\t \n\t\tif (snd_cs46xx_peekBA0(chip, BA0_ACSTS) & ACSTS_CRDY)\n\t\t\tgoto ok1;\n\t\tmsleep(10);\n\t}\n\n\n\tdev_err(chip->card->dev,\n\t\t\"create - never read codec ready from AC'97\\n\");\n\tdev_err(chip->card->dev,\n\t\t\"it is not probably bug, try to use CS4236 driver\\n\");\n\treturn -EIO;\n ok1:\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\t{\n\t\tint count;\n\t\tfor (count = 0; count < 150; count++) {\n\t\t\t \n\t\t\tudelay(25);\n        \n\t\t\tif (snd_cs46xx_peekBA0(chip, BA0_ACSTS2) & ACSTS_CRDY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(snd_cs46xx_peekBA0(chip, BA0_ACSTS2) & ACSTS_CRDY))\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"never read card ready from secondary AC'97\\n\");\n\t}\n#endif\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\n#endif\n\n\n\t \n\ttimeout = 150;\n\twhile (timeout-- > 0) {\n\t\t \n\t\tif ((snd_cs46xx_peekBA0(chip, BA0_ACISV) & (ACISV_ISV3 | ACISV_ISV4)) == (ACISV_ISV3 | ACISV_ISV4))\n\t\t\tgoto ok2;\n\t\tmsleep(10);\n\t}\n\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\n\tdev_err(chip->card->dev,\n\t\t\"create - never read ISV3 & ISV4 from AC'97\\n\");\n\treturn -EIO;\n#else\n\t \n\n\tdev_err(chip->card->dev, \"never read ISV3 & ISV4 from AC'97\\n\");\n\tdev_err(chip->card->dev,\n\t\t\"Try reloading the ALSA driver, if you find something\\n\");\n\tdev_err(chip->card->dev,\n\t\t\"broken or not working on your soundcard upon\\n\");\n\tdev_err(chip->card->dev,\n\t\t\"this message please report to alsa-devel@alsa-project.org\\n\");\n\n\treturn -EIO;\n#endif\n ok2:\n\n\t \n\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, ACOSV_SLV3 | ACOSV_SLV4);\n\n\n\t \n\t \n\n\t \n\t \n\t \n\n\treturn 0;\n}\n\n \n\nstatic void cs46xx_enable_stream_irqs(struct snd_cs46xx *chip)\n{\n\tunsigned int tmp;\n\n\tsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_IEV | HICR_CHGM);\n        \n\ttmp = snd_cs46xx_peek(chip, BA1_PFIE);\n\ttmp &= ~0x0000f03f;\n\tsnd_cs46xx_poke(chip, BA1_PFIE, tmp);\t \n\n\ttmp = snd_cs46xx_peek(chip, BA1_CIE);\n\ttmp &= ~0x0000003f;\n\ttmp |=  0x00000001;\n\tsnd_cs46xx_poke(chip, BA1_CIE, tmp);\t \n}\n\nint snd_cs46xx_start_dsp(struct snd_cs46xx *chip)\n{\t\n\tunsigned int tmp;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tint i;\n#endif\n\tint err;\n\n\t \n\tsnd_cs46xx_reset(chip);\n\t \n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tfor (i = 0; i < CS46XX_DSP_MODULES; i++) {\n\t\terr = load_firmware(chip, &chip->modules[i], module_names[i]);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"firmware load error [%s]\\n\",\n\t\t\t\t   module_names[i]);\n\t\t\treturn err;\n\t\t}\n\t\terr = cs46xx_dsp_load_module(chip, chip->modules[i]);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"image download error [%s]\\n\",\n\t\t\t\t   module_names[i]);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (cs46xx_dsp_scb_and_task_init(chip) < 0)\n\t\treturn -EIO;\n#else\n\terr = load_firmware(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_cs46xx_download_image(chip);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"image download error\\n\");\n\t\treturn err;\n\t}\n\n\t \n\ttmp = snd_cs46xx_peek(chip, BA1_PCTL);\n\tchip->play_ctl = tmp & 0xffff0000;\n\tsnd_cs46xx_poke(chip, BA1_PCTL, tmp & 0x0000ffff);\n#endif\n\n\t \n\ttmp = snd_cs46xx_peek(chip, BA1_CCTL);\n\tchip->capt.ctl = tmp & 0x0000ffff;\n\tsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\n\n\tmdelay(5);\n\n\tsnd_cs46xx_set_play_sample_rate(chip, 8000);\n\tsnd_cs46xx_set_capture_sample_rate(chip, 8000);\n\n\tsnd_cs46xx_proc_start(chip);\n\n\tcs46xx_enable_stream_irqs(chip);\n\t\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\n\t  \n\tsnd_cs46xx_poke(chip, BA1_PVOL, 0x80008000);\n\tsnd_cs46xx_poke(chip, BA1_CVOL, 0x80008000);\n#endif\n\n\treturn 0;\n}\n\n\n \n \nstatic void amp_none(struct snd_cs46xx *chip, int change)\n{\t\n}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\nstatic int voyetra_setup_eapd_slot(struct snd_cs46xx *chip)\n{\n\t\n\tu32 idx, valid_slots,tmp,powerdown = 0;\n\tu16 modem_power,pin_config,logic_type;\n\n\tdev_dbg(chip->card->dev, \"cs46xx_setup_eapd_slot()+\\n\");\n\n\t \n\ttmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1);\n\n\tif (!(tmp & CLKCR1_SWCE)) {\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp | CLKCR1_SWCE);\n\t\tpowerdown = 1;\n\t}\n\n\t \n\tif(chip->nr_ac97_codecs != 2) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"cs46xx_setup_eapd_slot() - no secondary codec configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmodem_power = snd_cs46xx_codec_read (chip, \n\t\t\t\t\t     AC97_EXTENDED_MSTATUS,\n\t\t\t\t\t     CS46XX_SECONDARY_CODEC_INDEX);\n\tmodem_power &=0xFEFF;\n\n\tsnd_cs46xx_codec_write(chip, \n\t\t\t       AC97_EXTENDED_MSTATUS, modem_power,\n\t\t\t       CS46XX_SECONDARY_CODEC_INDEX);\n\n\t \n\tpin_config = snd_cs46xx_codec_read (chip, \n\t\t\t\t\t    AC97_GPIO_CFG,\n\t\t\t\t\t    CS46XX_SECONDARY_CODEC_INDEX);\n\tpin_config &=0x27F;\n\n\tsnd_cs46xx_codec_write(chip, \n\t\t\t       AC97_GPIO_CFG, pin_config,\n\t\t\t       CS46XX_SECONDARY_CODEC_INDEX);\n    \n\t \n\n\tlogic_type = snd_cs46xx_codec_read(chip, AC97_GPIO_POLARITY,\n\t\t\t\t\t   CS46XX_SECONDARY_CODEC_INDEX);\n\tlogic_type &=0x27F; \n\n\tsnd_cs46xx_codec_write (chip, AC97_GPIO_POLARITY, logic_type,\n\t\t\t\tCS46XX_SECONDARY_CODEC_INDEX);\n\n\tvalid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);\n\tvalid_slots |= 0x200;\n\tsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);\n\n\tif ( cs46xx_wait_for_fifo(chip,1) ) {\n\t\tdev_dbg(chip->card->dev, \"FIFO is busy\\n\");\n\t  \n\t  return -EINVAL;\n\t}\n\n\t \n\tfor(idx = 0x90; idx <= 0x9F; idx++) {\n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_SERBWP, 0x1800);\n\n\t\t \n\t\tif ( cs46xx_wait_for_fifo(chip,200) ) {\n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"failed waiting for FIFO at addr (%02X)\\n\",\n\t\t\t\tidx);\n\n\t\t\treturn -EINVAL;\n\t\t}\n            \n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_SERBAD, idx);\n      \n\t\t \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_SERBCM, SERBCM_WRC);\n\t}\n\n\t \n\tcs46xx_wait_for_fifo(chip,200);\n\n\t \n\tif (powerdown)\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\n\n\treturn 0;\n}\n#endif\n\n \n \nstatic void amp_voyetra(struct snd_cs46xx *chip, int change)\n{\n\t \n\t   \n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tint old = chip->amplifier;\n#endif\n\tint oval, val;\n\t\n\tchip->amplifier += change;\n\toval = snd_cs46xx_codec_read(chip, AC97_POWERDOWN,\n\t\t\t\t     CS46XX_PRIMARY_CODEC_INDEX);\n\tval = oval;\n\tif (chip->amplifier) {\n\t\t \n\t\tval |= 0x8000;\n\t} else {\n\t\t \n\t\tval &= ~0x8000;\n\t}\n\tif (val != oval) {\n\t\tsnd_cs46xx_codec_write(chip, AC97_POWERDOWN, val,\n\t\t\t\t       CS46XX_PRIMARY_CODEC_INDEX);\n\t\tif (chip->eapd_switch)\n\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &chip->eapd_switch->id);\n\t}\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (chip->amplifier && !old) {\n\t\tvoyetra_setup_eapd_slot(chip);\n\t}\n#endif\n}\n\nstatic void hercules_init(struct snd_cs46xx *chip) \n{\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, EGPIODR_GPOE0);\n\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, EGPIODR_GPOE0);\n}\n\n\n  \nstatic void amp_hercules(struct snd_cs46xx *chip, int change)\n{\n\tint old = chip->amplifier;\n\tint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\n\tint val2 = snd_cs46xx_peekBA0(chip, BA0_EGPIOPTR);\n\n\tchip->amplifier += change;\n\tif (chip->amplifier && !old) {\n\t\tdev_dbg(chip->card->dev, \"Hercules amplifier ON\\n\");\n\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, \n\t\t\t\t   EGPIODR_GPOE2 | val1);      \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, \n\t\t\t\t   EGPIOPTR_GPPT2 | val2);    \n\t} else if (old && !chip->amplifier) {\n\t\tdev_dbg(chip->card->dev, \"Hercules amplifier OFF\\n\");\n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR,  val1 & ~EGPIODR_GPOE2);  \n\t\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, val2 & ~EGPIOPTR_GPPT2);  \n\t}\n}\n\nstatic void voyetra_mixer_init (struct snd_cs46xx *chip)\n{\n\tdev_dbg(chip->card->dev, \"initializing Voyetra mixer\\n\");\n\n\t \n\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, EGPIODR_GPOE0);\n\tsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, EGPIODR_GPOE0);\n}\n\nstatic void hercules_mixer_init (struct snd_cs46xx *chip)\n{\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tunsigned int idx;\n\tint err;\n\tstruct snd_card *card = chip->card;\n#endif\n\n\t \n\thercules_init(chip);\n\n\tdev_dbg(chip->card->dev, \"initializing Hercules mixer\\n\");\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tif (chip->in_suspend)\n\t\treturn;\n\n\tfor (idx = 0 ; idx < ARRAY_SIZE(snd_hercules_controls); idx++) {\n\t\tstruct snd_kcontrol *kctl;\n\n\t\tkctl = snd_ctl_new1(&snd_hercules_controls[idx], chip);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"failed to initialize Hercules mixer (%d)\\n\",\n\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}\n\n\n#if 0\n \n \nstatic void amp_voyetra_4294(struct snd_cs46xx *chip, int change)\n{\n\tchip->amplifier += change;\n\n\tif (chip->amplifier) {\n\t\t \n\t\tsnd_cs46xx_codec_write(chip, 0x4C,\n\t\t\t\t       snd_cs46xx_codec_read(chip, 0x4C) & 0xFE7F);\n\t\tsnd_cs46xx_codec_write(chip, 0x4E,\n\t\t\t\t       snd_cs46xx_codec_read(chip, 0x4E) | 0x0180);\n\t\t \n\t\tsnd_cs46xx_codec_write(chip, 0x54,\n\t\t\t\t       snd_cs46xx_codec_read(chip, 0x54) & ~0x0180);\n\t} else {\n\t\tsnd_cs46xx_codec_write(chip, 0x54,\n\t\t\t\t       snd_cs46xx_codec_read(chip, 0x54) | 0x0180);\n\t}\n}\n#endif\n\n\n \n \nstatic void clkrun_hack(struct snd_cs46xx *chip, int change)\n{\n\tu16 control, nval;\n\t\n\tif (!chip->acpi_port)\n\t\treturn;\n\n\tchip->amplifier += change;\n\t\n\t \t\n\tnval = control = inw(chip->acpi_port + 0x10);\n\n\t \n\tif (! chip->amplifier)\n\t\tnval |= 0x2000;\n\telse\n\t\tnval &= ~0x2000;\n\tif (nval != control)\n\t\toutw(nval, chip->acpi_port + 0x10);\n}\n\n\t\n \nstatic void clkrun_init(struct snd_cs46xx *chip)\n{\n\tstruct pci_dev *pdev;\n\tu8 pp;\n\n\tchip->acpi_port = 0;\n\t\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\tPCI_DEVICE_ID_INTEL_82371AB_3, NULL);\n\tif (pdev == NULL)\n\t\treturn;\t\t \n\n\t \t\t\n\tpci_read_config_byte(pdev, 0x41, &pp);\n\tchip->acpi_port = pp << 8;\n\tpci_dev_put(pdev);\n}\n\n\n \n \nstruct cs_card_type\n{\n\tu16 vendor;\n\tu16 id;\n\tchar *name;\n\tvoid (*init)(struct snd_cs46xx *);\n\tvoid (*amp)(struct snd_cs46xx *, int);\n\tvoid (*active)(struct snd_cs46xx *, int);\n\tvoid (*mixer_init)(struct snd_cs46xx *);\n};\n\nstatic struct cs_card_type cards[] = {\n\t{\n\t\t.vendor = 0x1489,\n\t\t.id = 0x7001,\n\t\t.name = \"Genius Soundmaker 128 value\",\n\t\t \n\t},\n\t{\n\t\t.vendor = 0x5053,\n\t\t.id = 0x3357,\n\t\t.name = \"Voyetra\",\n\t\t.amp = amp_voyetra,\n\t\t.mixer_init = voyetra_mixer_init,\n\t},\n\t{\n\t\t.vendor = 0x1071,\n\t\t.id = 0x6003,\n\t\t.name = \"Mitac MI6020/21\",\n\t\t.amp = amp_voyetra,\n\t},\n\t \n\t{\n\t\t.vendor = 0x14af,  \n\t\t.id = 0x0050,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0x0050,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0x0051,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0x0052,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0x0053,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0x0054,\n\t\t.name = \"Hercules Game Theatre XP\",\n\t\t.amp = amp_hercules,\n\t\t.mixer_init = hercules_mixer_init,\n\t},\n\t \n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0xa010,\n\t\t.name = \"Hercules Gamesurround Fortissimo II\",\n\t},\n\t{\n\t\t.vendor = 0x1681,\n\t\t.id = 0xa011,\n\t\t.name = \"Hercules Gamesurround Fortissimo III 7.1\",\n\t},\n\t \n\t{\n\t\t.vendor = 0x153b,\n\t\t.id = 0x112e,\n\t\t.name = \"Terratec DMX XFire 1024\",\n\t},\n\t{\n\t\t.vendor = 0x153b,\n\t\t.id = 0x1136,\n\t\t.name = \"Terratec SiXPack 5.1\",\n\t},\n\t \n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.id = 0x0132,\n\t\t.name = \"Thinkpad 570\",\n\t\t.init = clkrun_init,\n\t\t.active = clkrun_hack,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.id = 0x0153,\n\t\t.name = \"Thinkpad 600X/A20/T20\",\n\t\t.init = clkrun_init,\n\t\t.active = clkrun_hack,\n\t},\n\t{\n\t\t.vendor = PCI_VENDOR_ID_IBM,\n\t\t.id = 0x1010,\n\t\t.name = \"Thinkpad 600E (unsupported)\",\n\t},\n\t{}  \n};\n\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic const unsigned int saved_regs[] = {\n\tBA0_ACOSV,\n\t \n\tBA0_ASER_MASTER,\n\tBA1_PVOL,\n\tBA1_CVOL,\n};\n\nstatic int snd_cs46xx_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_cs46xx *chip = card->private_data;\n\tint i, amp_saved;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tchip->in_suspend = 1;\n\t \n\t \n\n\tsnd_ac97_suspend(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);\n\tsnd_ac97_suspend(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tchip->saved_regs[i] = snd_cs46xx_peekBA0(chip, saved_regs[i]);\n\n\tamp_saved = chip->amplifier;\n\t \n\tchip->amplifier_ctrl(chip, -chip->amplifier);\n\tsnd_cs46xx_hw_stop(chip);\n\t \n\tchip->active_ctrl(chip, -chip->amplifier);\n\tchip->amplifier = amp_saved;  \n\treturn 0;\n}\n\nstatic int snd_cs46xx_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_cs46xx *chip = card->private_data;\n\tint amp_saved;\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tint i;\n#endif\n\tunsigned int tmp;\n\n\tamp_saved = chip->amplifier;\n\tchip->amplifier = 0;\n\tchip->active_ctrl(chip, 1);  \n\n\tsnd_cs46xx_chip_init(chip);\n\n\tsnd_cs46xx_reset(chip);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tcs46xx_dsp_resume(chip);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\n\t\tsnd_cs46xx_pokeBA0(chip, saved_regs[i], chip->saved_regs[i]);\n#else\n\tsnd_cs46xx_download_image(chip);\n#endif\n\n#if 0\n\tsnd_cs46xx_codec_write(chip, BA0_AC97_GENERAL_PURPOSE, \n\t\t\t       chip->ac97_general_purpose);\n\tsnd_cs46xx_codec_write(chip, AC97_POWER_CONTROL, \n\t\t\t       chip->ac97_powerdown);\n\tmdelay(10);\n\tsnd_cs46xx_codec_write(chip, BA0_AC97_POWERDOWN,\n\t\t\t       chip->ac97_powerdown);\n\tmdelay(5);\n#endif\n\n\tsnd_ac97_resume(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);\n\tsnd_ac97_resume(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);\n\n\t \n\ttmp = snd_cs46xx_peek(chip, BA1_CCTL);\n\tchip->capt.ctl = tmp & 0x0000ffff;\n\tsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\n\n\tmdelay(5);\n\n\t \n\tsnd_cs46xx_set_play_sample_rate(chip, 8000);\n\tsnd_cs46xx_set_capture_sample_rate(chip, 8000);\n\tsnd_cs46xx_proc_start(chip);\n\n\tcs46xx_enable_stream_irqs(chip);\n\n\tif (amp_saved)\n\t\tchip->amplifier_ctrl(chip, 1);  \n\telse\n\t\tchip->active_ctrl(chip, -1);  \n\tchip->amplifier = amp_saved;\n\tchip->in_suspend = 0;\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(snd_cs46xx_pm, snd_cs46xx_suspend, snd_cs46xx_resume);\n#endif  \n\n\n \n\nint snd_cs46xx_create(struct snd_card *card,\n\t\t      struct pci_dev *pci,\n\t\t      int external_amp, int thinkpad)\n{\n\tstruct snd_cs46xx *chip = card->private_data;\n\tint err, idx;\n\tstruct snd_cs46xx_region *region;\n\tstruct cs_card_type *cp;\n\tu16 ss_card, ss_vendor;\n\t\n\t \n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tmutex_init(&chip->spos_mutex);\n#endif\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\terr = pci_request_regions(pci, \"CS46xx\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->ba0_addr = pci_resource_start(pci, 0);\n\tchip->ba1_addr = pci_resource_start(pci, 1);\n\tif (chip->ba0_addr == 0 || chip->ba0_addr == (unsigned long)~0 ||\n\t    chip->ba1_addr == 0 || chip->ba1_addr == (unsigned long)~0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"wrong address(es) - ba0 = 0x%lx, ba1 = 0x%lx\\n\",\n\t\t\t   chip->ba0_addr, chip->ba1_addr);\n\t    \treturn -ENOMEM;\n\t}\n\n\tregion = &chip->region.name.ba0;\n\tstrcpy(region->name, \"CS46xx_BA0\");\n\tregion->base = chip->ba0_addr;\n\tregion->size = CS46XX_BA0_SIZE;\n\n\tregion = &chip->region.name.data0;\n\tstrcpy(region->name, \"CS46xx_BA1_data0\");\n\tregion->base = chip->ba1_addr + BA1_SP_DMEM0;\n\tregion->size = CS46XX_BA1_DATA0_SIZE;\n\n\tregion = &chip->region.name.data1;\n\tstrcpy(region->name, \"CS46xx_BA1_data1\");\n\tregion->base = chip->ba1_addr + BA1_SP_DMEM1;\n\tregion->size = CS46XX_BA1_DATA1_SIZE;\n\n\tregion = &chip->region.name.pmem;\n\tstrcpy(region->name, \"CS46xx_BA1_pmem\");\n\tregion->base = chip->ba1_addr + BA1_SP_PMEM;\n\tregion->size = CS46XX_BA1_PRG_SIZE;\n\n\tregion = &chip->region.name.reg;\n\tstrcpy(region->name, \"CS46xx_BA1_reg\");\n\tregion->base = chip->ba1_addr + BA1_SP_REG;\n\tregion->size = CS46XX_BA1_REG_SIZE;\n\n\t \n\tpci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &ss_vendor);\n\tpci_read_config_word(pci, PCI_SUBSYSTEM_ID, &ss_card);\n\n\tfor (cp = &cards[0]; cp->name; cp++) {\n\t\tif (cp->vendor == ss_vendor && cp->id == ss_card) {\n\t\t\tdev_dbg(chip->card->dev, \"hack for %s enabled\\n\",\n\t\t\t\tcp->name);\n\n\t\t\tchip->amplifier_ctrl = cp->amp;\n\t\t\tchip->active_ctrl = cp->active;\n\t\t\tchip->mixer_init = cp->mixer_init;\n\n\t\t\tif (cp->init)\n\t\t\t\tcp->init(chip);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (external_amp) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"Crystal EAPD support forced on.\\n\");\n\t\tchip->amplifier_ctrl = amp_voyetra;\n\t}\n\n\tif (thinkpad) {\n\t\tdev_info(chip->card->dev,\n\t\t\t \"Activating CLKRUN hack for Thinkpad.\\n\");\n\t\tchip->active_ctrl = clkrun_hack;\n\t\tclkrun_init(chip);\n\t}\n\t\n\tif (chip->amplifier_ctrl == NULL)\n\t\tchip->amplifier_ctrl = amp_none;\n\tif (chip->active_ctrl == NULL)\n\t\tchip->active_ctrl = amp_none;\n\n\tchip->active_ctrl(chip, 1);  \n\n\tpci_set_master(pci);\n\n\tfor (idx = 0; idx < 5; idx++) {\n\t\tregion = &chip->region.idx[idx];\n\t\tregion->remap_addr = devm_ioremap(&pci->dev, region->base,\n\t\t\t\t\t\t  region->size);\n\t\tif (region->remap_addr == NULL) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"%s ioremap problem\\n\", region->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_cs46xx_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(chip->card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_cs46xx_free;\n\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\n\tchip->dsp_spos_instance = cs46xx_dsp_spos_create(chip);\n\tif (!chip->dsp_spos_instance)\n\t\treturn -ENOMEM;\n#endif\n\n\terr = snd_cs46xx_chip_init(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_cs46xx_proc_init(card, chip);\n\n#ifdef CONFIG_PM_SLEEP\n\tchip->saved_regs = devm_kmalloc_array(&pci->dev,\n\t\t\t\t\t      ARRAY_SIZE(saved_regs),\n\t\t\t\t\t      sizeof(*chip->saved_regs),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!chip->saved_regs)\n\t\treturn -ENOMEM;\n#endif\n\n\tchip->active_ctrl(chip, -1);  \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}