{
  "module_name": "ac97_codec.c",
  "hash_id": "58a52c61eccc6fd1286a57be1a42812039ab6cc3afe7407170d30ac325185467",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ac97/ac97_codec.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/tlv.h>\n#include <sound/ac97_codec.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n#include \"ac97_id.h\"\n\n#include \"ac97_patch.c\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Universal interface for Audio Codec '97\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool enable_loopback;\n\nmodule_param(enable_loopback, bool, 0444);\nMODULE_PARM_DESC(enable_loopback, \"Enable AC97 ADC/DAC Loopback Control\");\n\n#ifdef CONFIG_SND_AC97_POWER_SAVE\nstatic int power_save = CONFIG_SND_AC97_POWER_SAVE_DEFAULT;\nmodule_param(power_save, int, 0644);\nMODULE_PARM_DESC(power_save, \"Automatic power-saving timeout \"\n\t\t \"(in second, 0 = disable).\");\n#endif\n \n\nstruct ac97_codec_id {\n\tunsigned int id;\n\tunsigned int mask;\n\tconst char *name;\n\tint (*patch)(struct snd_ac97 *ac97);\n\tint (*mpatch)(struct snd_ac97 *ac97);\n\tunsigned int flags;\n};\n\nstatic const struct ac97_codec_id snd_ac97_codec_id_vendors[] = {\n{ 0x41445300, 0xffffff00, \"Analog Devices\",\tNULL,\tNULL },\n{ 0x414b4d00, 0xffffff00, \"Asahi Kasei\",\tNULL,\tNULL },\n{ 0x414c4300, 0xffffff00, \"Realtek\",\t\tNULL,\tNULL },\n{ 0x414c4700, 0xffffff00, \"Realtek\",\t\tNULL,\tNULL },\n \n{ 0x415a5400, 0xffffff00, \"Aztech Labs (emulated)\",\tNULL,\tNULL },\n{ 0x434d4900, 0xffffff00, \"C-Media Electronics\", NULL,\tNULL },\n{ 0x43525900, 0xffffff00, \"Cirrus Logic\",\tNULL,\tNULL },\n{ 0x43585400, 0xffffff00, \"Conexant\",           NULL,\tNULL },\n{ 0x44543000, 0xffffff00, \"Diamond Technology\", NULL,\tNULL },\n{ 0x454d4300, 0xffffff00, \"eMicro\",\t\tNULL,\tNULL },\n{ 0x45838300, 0xffffff00, \"ESS Technology\",\tNULL,\tNULL },\n{ 0x48525300, 0xffffff00, \"Intersil\",\t\tNULL,\tNULL },\n{ 0x49434500, 0xffffff00, \"ICEnsemble\",\t\tNULL,\tNULL },\n{ 0x49544500, 0xffffff00, \"ITE Tech.Inc\",\tNULL,\tNULL },\n{ 0x4e534300, 0xffffff00, \"National Semiconductor\", NULL, NULL },\n{ 0x50534300, 0xffffff00, \"Philips\",\t\tNULL,\tNULL },\n{ 0x53494c00, 0xffffff00, \"Silicon Laboratory\",\tNULL,\tNULL },\n{ 0x53544d00, 0xffffff00, \"STMicroelectronics\",\tNULL,\tNULL },\n{ 0x54524100, 0xffffff00, \"TriTech\",\t\tNULL,\tNULL },\n{ 0x54584e00, 0xffffff00, \"Texas Instruments\",\tNULL,\tNULL },\n{ 0x56494100, 0xffffff00, \"VIA Technologies\",   NULL,\tNULL },\n{ 0x57454300, 0xffffff00, \"Winbond\",\t\tNULL,\tNULL },\n{ 0x574d4c00, 0xffffff00, \"Wolfson\",\t\tNULL,\tNULL },\n{ 0x594d4800, 0xffffff00, \"Yamaha\",\t\tNULL,\tNULL },\n{ 0x83847600, 0xffffff00, \"SigmaTel\",\t\tNULL,\tNULL },\n{ 0,\t      0, \t  NULL,\t\t\tNULL,\tNULL }\n};\n\nstatic const struct ac97_codec_id snd_ac97_codec_ids[] = {\n{ 0x41445303, 0xffffffff, \"AD1819\",\t\tpatch_ad1819,\tNULL },\n{ 0x41445340, 0xffffffff, \"AD1881\",\t\tpatch_ad1881,\tNULL },\n{ 0x41445348, 0xffffffff, \"AD1881A\",\t\tpatch_ad1881,\tNULL },\n{ 0x41445360, 0xffffffff, \"AD1885\",\t\tpatch_ad1885,\tNULL },\n{ 0x41445361, 0xffffffff, \"AD1886\",\t\tpatch_ad1886,\tNULL },\n{ 0x41445362, 0xffffffff, \"AD1887\",\t\tpatch_ad1881,\tNULL },\n{ 0x41445363, 0xffffffff, \"AD1886A\",\t\tpatch_ad1881,\tNULL },\n{ 0x41445368, 0xffffffff, \"AD1888\",\t\tpatch_ad1888,\tNULL },\n{ 0x41445370, 0xffffffff, \"AD1980\",\t\tpatch_ad1980,\tNULL },\n{ 0x41445372, 0xffffffff, \"AD1981A\",\t\tpatch_ad1981a,\tNULL },\n{ 0x41445374, 0xffffffff, \"AD1981B\",\t\tpatch_ad1981b,\tNULL },\n{ 0x41445375, 0xffffffff, \"AD1985\",\t\tpatch_ad1985,\tNULL },\n{ 0x41445378, 0xffffffff, \"AD1986\",\t\tpatch_ad1986,\tNULL },\n{ 0x414b4d00, 0xffffffff, \"AK4540\",\t\tNULL,\t\tNULL },\n{ 0x414b4d01, 0xffffffff, \"AK4542\",\t\tNULL,\t\tNULL },\n{ 0x414b4d02, 0xffffffff, \"AK4543\",\t\tNULL,\t\tNULL },\n{ 0x414b4d06, 0xffffffff, \"AK4544A\",\t\tNULL,\t\tNULL },\n{ 0x414b4d07, 0xffffffff, \"AK4545\",\t\tNULL,\t\tNULL },\n{ 0x414c4300, 0xffffff00, \"ALC100,100P\", \tNULL,\t\tNULL },\n{ 0x414c4710, 0xfffffff0, \"ALC200,200P\",\tNULL,\t\tNULL },\n{ 0x414c4721, 0xffffffff, \"ALC650D\",\t\tNULL,\tNULL },  \n{ 0x414c4722, 0xffffffff, \"ALC650E\",\t\tNULL,\tNULL },  \n{ 0x414c4723, 0xffffffff, \"ALC650F\",\t\tNULL,\tNULL },  \n{ 0x414c4720, 0xfffffff0, \"ALC650\",\t\tpatch_alc650,\tNULL },\n{ 0x414c4730, 0xffffffff, \"ALC101\",\t\tNULL,\t\tNULL },\n{ 0x414c4740, 0xfffffff0, \"ALC202\",\t\tNULL,\t\tNULL },\n{ 0x414c4750, 0xfffffff0, \"ALC250\",\t\tNULL,\t\tNULL },\n{ 0x414c4760, 0xfffffff0, \"ALC655\",\t\tpatch_alc655,\tNULL },\n{ 0x414c4770, 0xfffffff0, \"ALC203\",\t\tpatch_alc203,\tNULL },\n{ 0x414c4781, 0xffffffff, \"ALC658D\",\t\tNULL,\tNULL },  \n{ 0x414c4780, 0xfffffff0, \"ALC658\",\t\tpatch_alc655,\tNULL },\n{ 0x414c4790, 0xfffffff0, \"ALC850\",\t\tpatch_alc850,\tNULL },\n{ 0x415a5401, 0xffffffff, \"AZF3328\",\t\tpatch_aztech_azf3328,\tNULL },\n{ 0x434d4941, 0xffffffff, \"CMI9738\",\t\tpatch_cm9738,\tNULL },\n{ 0x434d4961, 0xffffffff, \"CMI9739\",\t\tpatch_cm9739,\tNULL },\n{ 0x434d4969, 0xffffffff, \"CMI9780\",\t\tpatch_cm9780,\tNULL },\n{ 0x434d4978, 0xffffffff, \"CMI9761A\",\t\tpatch_cm9761,\tNULL },\n{ 0x434d4982, 0xffffffff, \"CMI9761B\",\t\tpatch_cm9761,\tNULL },\n{ 0x434d4983, 0xffffffff, \"CMI9761A+\",\t\tpatch_cm9761,\tNULL },\n{ 0x43525900, 0xfffffff8, \"CS4297\",\t\tNULL,\t\tNULL },\n{ 0x43525910, 0xfffffff8, \"CS4297A\",\t\tpatch_cirrus_spdif,\tNULL },\n{ 0x43525920, 0xfffffff8, \"CS4298\",\t\tpatch_cirrus_spdif,\t\tNULL },\n{ 0x43525928, 0xfffffff8, \"CS4294\",\t\tNULL,\t\tNULL },\n{ 0x43525930, 0xfffffff8, \"CS4299\",\t\tpatch_cirrus_cs4299,\tNULL },\n{ 0x43525948, 0xfffffff8, \"CS4201\",\t\tNULL,\t\tNULL },\n{ 0x43525958, 0xfffffff8, \"CS4205\",\t\tpatch_cirrus_spdif,\tNULL },\n{ 0x43525960, 0xfffffff8, \"CS4291\",\t\tNULL,\t\tNULL },\n{ 0x43525970, 0xfffffff8, \"CS4202\",\t\tNULL,\t\tNULL },\n{ 0x43585421, 0xffffffff, \"HSD11246\",\t\tNULL,\t\tNULL },\t\n{ 0x43585428, 0xfffffff8, \"Cx20468\",\t\tpatch_conexant,\tNULL }, \n{ 0x43585430, 0xffffffff, \"Cx20468-31\",\t\tpatch_conexant, NULL },\n{ 0x43585431, 0xffffffff, \"Cx20551\",           patch_cx20551,  NULL },\n{ 0x44543031, 0xfffffff0, \"DT0398\",\t\tNULL,\t\tNULL },\n{ 0x454d4328, 0xffffffff, \"EM28028\",\t\tNULL,\t\tNULL },  \n{ 0x45838308, 0xffffffff, \"ESS1988\",\t\tNULL,\t\tNULL },\n{ 0x48525300, 0xffffff00, \"HMP9701\",\t\tNULL,\t\tNULL },\n{ 0x49434501, 0xffffffff, \"ICE1230\",\t\tNULL,\t\tNULL },\n{ 0x49434511, 0xffffffff, \"ICE1232\",\t\tNULL,\t\tNULL }, \n{ 0x49434514, 0xffffffff, \"ICE1232A\",\t\tNULL,\t\tNULL },\n{ 0x49434551, 0xffffffff, \"VT1616\", \t\tpatch_vt1616,\tNULL }, \n{ 0x49434552, 0xffffffff, \"VT1616i\",\t\tpatch_vt1616,\tNULL }, \n{ 0x49544520, 0xffffffff, \"IT2226E\",\t\tNULL,\t\tNULL },\n{ 0x49544561, 0xffffffff, \"IT2646E\",\t\tpatch_it2646,\tNULL },\n{ 0x4e534300, 0xffffffff, \"LM4540,43,45,46,48\",\tNULL,\t\tNULL }, \n{ 0x4e534331, 0xffffffff, \"LM4549\",\t\tNULL,\t\tNULL },\n{ 0x4e534350, 0xffffffff, \"LM4550\",\t\tpatch_lm4550,  \tNULL }, \n{ 0x53494c20, 0xffffffe0, \"Si3036,8\",\t\tmpatch_si3036,\tmpatch_si3036, AC97_MODEM_PATCH },\n{ 0x53544d02, 0xffffffff, \"ST7597\",\t\tNULL,\t\tNULL },\n{ 0x54524102, 0xffffffff, \"TR28022\",\t\tNULL,\t\tNULL },\n{ 0x54524103, 0xffffffff, \"TR28023\",\t\tNULL,\t\tNULL },\n{ 0x54524106, 0xffffffff, \"TR28026\",\t\tNULL,\t\tNULL },\n{ 0x54524108, 0xffffffff, \"TR28028\",\t\tpatch_tritech_tr28028,\tNULL }, \n{ 0x54524123, 0xffffffff, \"TR28602\",\t\tNULL,\t\tNULL }, \n{ 0x54584e03, 0xffffffff, \"TLV320AIC27\",\tNULL,\t\tNULL },\n{ 0x54584e20, 0xffffffff, \"TLC320AD9xC\",\tNULL,\t\tNULL },\n{ 0x56494120, 0xfffffff0, \"VIA1613\",\t\tpatch_vt1613,\tNULL },\n{ 0x56494161, 0xffffffff, \"VIA1612A\",\t\tNULL,\t\tNULL }, \n{ 0x56494170, 0xffffffff, \"VIA1617A\",\t\tpatch_vt1617a,\tNULL }, \n{ 0x56494182, 0xffffffff, \"VIA1618\",\t\tpatch_vt1618,   NULL },\n{ 0x57454301, 0xffffffff, \"W83971D\",\t\tNULL,\t\tNULL },\n{ 0x574d4c00, 0xffffffff, \"WM9701,WM9701A\",\tNULL,\t\tNULL },\n{ 0x574d4C03, 0xffffffff, \"WM9703,WM9707,WM9708,WM9717\", patch_wolfson03, NULL},\n{ 0x574d4C04, 0xffffffff, \"WM9704M,WM9704Q\",\tpatch_wolfson04, NULL},\n{ 0x574d4C05, 0xffffffff, \"WM9705,WM9710\",\tpatch_wolfson05, NULL},\n{ 0x574d4C09, 0xffffffff, \"WM9709\",\t\tNULL,\t\tNULL},\n{ 0x574d4C12, 0xffffffff, \"WM9711,WM9712,WM9715\",\tpatch_wolfson11, NULL},\n{ 0x574d4c13, 0xffffffff, \"WM9713,WM9714\",\tpatch_wolfson13, NULL, AC97_DEFAULT_POWER_OFF},\n{ 0x594d4800, 0xffffffff, \"YMF743\",\t\tpatch_yamaha_ymf743,\tNULL },\n{ 0x594d4802, 0xffffffff, \"YMF752\",\t\tNULL,\t\tNULL },\n{ 0x594d4803, 0xffffffff, \"YMF753\",\t\tpatch_yamaha_ymf753,\tNULL },\n{ 0x83847600, 0xffffffff, \"STAC9700,83,84\",\tpatch_sigmatel_stac9700,\tNULL },\n{ 0x83847604, 0xffffffff, \"STAC9701,3,4,5\",\tNULL,\t\tNULL },\n{ 0x83847605, 0xffffffff, \"STAC9704\",\t\tNULL,\t\tNULL },\n{ 0x83847608, 0xffffffff, \"STAC9708,11\",\tpatch_sigmatel_stac9708,\tNULL },\n{ 0x83847609, 0xffffffff, \"STAC9721,23\",\tpatch_sigmatel_stac9721,\tNULL },\n{ 0x83847644, 0xffffffff, \"STAC9744\",\t\tpatch_sigmatel_stac9744,\tNULL },\n{ 0x83847650, 0xffffffff, \"STAC9750,51\",\tNULL,\t\tNULL },\t\n{ 0x83847652, 0xffffffff, \"STAC9752,53\",\tNULL,\t\tNULL }, \n{ 0x83847656, 0xffffffff, \"STAC9756,57\",\tpatch_sigmatel_stac9756,\tNULL },\n{ 0x83847658, 0xffffffff, \"STAC9758,59\",\tpatch_sigmatel_stac9758,\tNULL },\n{ 0x83847666, 0xffffffff, \"STAC9766,67\",\tNULL,\t\tNULL }, \n{ 0, \t      0,\t  NULL,\t\t\tNULL,\t\tNULL }\n};\n\n\nstatic void update_power_regs(struct snd_ac97 *ac97);\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n#define ac97_is_power_save_mode(ac97) \\\n\t((ac97->scaps & AC97_SCAP_POWER_SAVE) && power_save)\n#else\n#define ac97_is_power_save_mode(ac97) 0\n#endif\n\n#define ac97_err(ac97, fmt, args...)\t\\\n\tdev_err((ac97)->bus->card->dev, fmt, ##args)\n#define ac97_warn(ac97, fmt, args...)\t\\\n\tdev_warn((ac97)->bus->card->dev, fmt, ##args)\n#define ac97_dbg(ac97, fmt, args...)\t\\\n\tdev_dbg((ac97)->bus->card->dev, fmt, ##args)\n\n \n\nstatic int snd_ac97_valid_reg(struct snd_ac97 *ac97, unsigned short reg)\n{\n\t \n\tswitch (ac97->id) {\n\tcase AC97_ID_ST_AC97_ID4:\n\t\tif (reg == 0x08)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase AC97_ID_ST7597:\n\t\tif (reg == 0x22 || reg == 0x7a)\n\t\t\treturn 1;\n\t\tfallthrough;\n\tcase AC97_ID_AK4540:\n\tcase AC97_ID_AK4542:\n\t\tif (reg <= 0x1c || reg == 0x20 || reg == 0x26 || reg >= 0x7c)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AC97_ID_AD1819:\t \n\tcase AC97_ID_AD1881:\t \n\tcase AC97_ID_AD1881A:\t \n\t\tif (reg >= 0x3a && reg <= 0x6e)\t \n\t\t\treturn 0;\n\t\treturn 1;\n\tcase AC97_ID_AD1885:\t \n\tcase AC97_ID_AD1886:\t \n\tcase AC97_ID_AD1886A:\t \n\tcase AC97_ID_AD1887:\t \n\t\tif (reg == 0x5a)\n\t\t\treturn 1;\n\t\tif (reg >= 0x3c && reg <= 0x6e)\t \n\t\t\treturn 0;\n\t\treturn 1;\n\tcase AC97_ID_STAC9700:\n\tcase AC97_ID_STAC9704:\n\tcase AC97_ID_STAC9705:\n\tcase AC97_ID_STAC9708:\n\tcase AC97_ID_STAC9721:\n\tcase AC97_ID_STAC9744:\n\tcase AC97_ID_STAC9756:\n\t\tif (reg <= 0x3a || reg >= 0x5a)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nvoid snd_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\n{\n\tif (!snd_ac97_valid_reg(ac97, reg))\n\t\treturn;\n\tif ((ac97->id & 0xffffff00) == AC97_ID_ALC100) {\n\t\t \n\t\tif (reg == AC97_MASTER || reg == AC97_HEADPHONE)\n\t\t\tac97->bus->ops->write(ac97, AC97_RESET, 0);\t \n\t}\n\tac97->bus->ops->write(ac97, reg, value);\n}\n\nEXPORT_SYMBOL(snd_ac97_write);\n\n \nunsigned short snd_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tif (!snd_ac97_valid_reg(ac97, reg))\n\t\treturn 0;\n\treturn ac97->bus->ops->read(ac97, reg);\n}\n\n \nstatic inline unsigned short snd_ac97_read_cache(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tif (! test_bit(reg, ac97->reg_accessed)) {\n\t\tac97->regs[reg] = ac97->bus->ops->read(ac97, reg);\n\t\t\n\t}\n\treturn ac97->regs[reg];\n}\n\nEXPORT_SYMBOL(snd_ac97_read);\n\n \nvoid snd_ac97_write_cache(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\n{\n\tif (!snd_ac97_valid_reg(ac97, reg))\n\t\treturn;\n\tmutex_lock(&ac97->reg_mutex);\n\tac97->regs[reg] = value;\n\tac97->bus->ops->write(ac97, reg, value);\n\tset_bit(reg, ac97->reg_accessed);\n\tmutex_unlock(&ac97->reg_mutex);\n}\n\nEXPORT_SYMBOL(snd_ac97_write_cache);\n\n \nint snd_ac97_update(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\n{\n\tint change;\n\n\tif (!snd_ac97_valid_reg(ac97, reg))\n\t\treturn -EINVAL;\n\tmutex_lock(&ac97->reg_mutex);\n\tchange = ac97->regs[reg] != value;\n\tif (change) {\n\t\tac97->regs[reg] = value;\n\t\tac97->bus->ops->write(ac97, reg, value);\n\t}\n\tset_bit(reg, ac97->reg_accessed);\n\tmutex_unlock(&ac97->reg_mutex);\n\treturn change;\n}\n\nEXPORT_SYMBOL(snd_ac97_update);\n\n \nint snd_ac97_update_bits(struct snd_ac97 *ac97, unsigned short reg, unsigned short mask, unsigned short value)\n{\n\tint change;\n\n\tif (!snd_ac97_valid_reg(ac97, reg))\n\t\treturn -EINVAL;\n\tmutex_lock(&ac97->reg_mutex);\n\tchange = snd_ac97_update_bits_nolock(ac97, reg, mask, value);\n\tmutex_unlock(&ac97->reg_mutex);\n\treturn change;\n}\n\nEXPORT_SYMBOL(snd_ac97_update_bits);\n\n \nint snd_ac97_update_bits_nolock(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\tunsigned short mask, unsigned short value)\n{\n\tint change;\n\tunsigned short old, new;\n\n\told = snd_ac97_read_cache(ac97, reg);\n\tnew = (old & ~mask) | (value & mask);\n\tchange = old != new;\n\tif (change) {\n\t\tac97->regs[reg] = new;\n\t\tac97->bus->ops->write(ac97, reg, new);\n\t}\n\tset_bit(reg, ac97->reg_accessed);\n\treturn change;\n}\n\nstatic int snd_ac97_ad18xx_update_pcm_bits(struct snd_ac97 *ac97, int codec, unsigned short mask, unsigned short value)\n{\n\tint change;\n\tunsigned short old, new, cfg;\n\n\tmutex_lock(&ac97->page_mutex);\n\told = ac97->spec.ad18xx.pcmreg[codec];\n\tnew = (old & ~mask) | (value & mask);\n\tchange = old != new;\n\tif (change) {\n\t\tmutex_lock(&ac97->reg_mutex);\n\t\tcfg = snd_ac97_read_cache(ac97, AC97_AD_SERIAL_CFG);\n\t\tac97->spec.ad18xx.pcmreg[codec] = new;\n\t\t \n\t\tac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,\n\t\t\t\t (cfg & ~0x7000) |\n\t\t\t\t ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);\n\t\t \n\t\tac97->bus->ops->write(ac97, AC97_PCM, new);\n\t\t \n\t\tac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,\n\t\t\t\t cfg | 0x7000);\n\t\tmutex_unlock(&ac97->reg_mutex);\n\t}\n\tmutex_unlock(&ac97->page_mutex);\n\treturn change;\n}\n\n \n\nstatic int snd_ac97_info_enum_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\n\t\n\treturn snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,\n\t\t\t\t e->mask, e->texts);\n}\n\nstatic int snd_ac97_get_enum_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\n\tunsigned short val, bitmask;\n\t\n\tfor (bitmask = 1; bitmask < e->mask; bitmask <<= 1)\n\t\t;\n\tval = snd_ac97_read_cache(ac97, e->reg);\n\tucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);\n\tif (e->shift_l != e->shift_r)\n\t\tucontrol->value.enumerated.item[1] = (val >> e->shift_r) & (bitmask - 1);\n\n\treturn 0;\n}\n\nstatic int snd_ac97_put_enum_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\n\tunsigned short val;\n\tunsigned short mask, bitmask;\n\t\n\tfor (bitmask = 1; bitmask < e->mask; bitmask <<= 1)\n\t\t;\n\tif (ucontrol->value.enumerated.item[0] > e->mask - 1)\n\t\treturn -EINVAL;\n\tval = ucontrol->value.enumerated.item[0] << e->shift_l;\n\tmask = (bitmask - 1) << e->shift_l;\n\tif (e->shift_l != e->shift_r) {\n\t\tif (ucontrol->value.enumerated.item[1] > e->mask - 1)\n\t\t\treturn -EINVAL;\n\t\tval |= ucontrol->value.enumerated.item[1] << e->shift_r;\n\t\tmask |= (bitmask - 1) << e->shift_r;\n\t}\n\treturn snd_ac97_update_bits(ac97, e->reg, mask, val);\n}\n\n \nstatic int snd_ac97_page_save(struct snd_ac97 *ac97, int reg, struct snd_kcontrol *kcontrol)\n{\n\tint page_save = -1;\n\tif ((kcontrol->private_value & (1<<25)) &&\n\t    (ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23 &&\n\t    (reg >= 0x60 && reg < 0x70)) {\n\t\tunsigned short page = (kcontrol->private_value >> 26) & 0x0f;\n\t\tmutex_lock(&ac97->page_mutex);  \n\t\tpage_save = snd_ac97_read(ac97, AC97_INT_PAGING) & AC97_PAGE_MASK;\n\t\tsnd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page);\n\t}\n\treturn page_save;\n}\n\nstatic void snd_ac97_page_restore(struct snd_ac97 *ac97, int page_save)\n{\n\tif (page_save >= 0) {\n\t\tsnd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page_save);\n\t\tmutex_unlock(&ac97->page_mutex);  \n\t}\n}\n\n \nstatic int snd_ac97_info_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = shift == rshift ? 1 : 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_ac97_get_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0x01;\n\tint page_save;\n\n\tpage_save = snd_ac97_page_save(ac97, reg, kcontrol);\n\tucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift) & mask;\n\tif (shift != rshift)\n\t\tucontrol->value.integer.value[1] = (snd_ac97_read_cache(ac97, reg) >> rshift) & mask;\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\n\t\tif (shift != rshift)\n\t\t\tucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\n\t}\n\tsnd_ac97_page_restore(ac97, page_save);\n\treturn 0;\n}\n\nstatic int snd_ac97_put_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0x01;\n\tint err, page_save;\n\tunsigned short val, val2, val_mask;\n\t\n\tpage_save = snd_ac97_page_save(ac97, reg, kcontrol);\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval_mask = mask << shift;\n\tval = val << shift;\n\tif (shift != rshift) {\n\t\tval2 = (ucontrol->value.integer.value[1] & mask);\n\t\tif (invert)\n\t\t\tval2 = mask - val2;\n\t\tval_mask |= mask << rshift;\n\t\tval |= val2 << rshift;\n\t}\n\terr = snd_ac97_update_bits(ac97, reg, val_mask, val);\n\tsnd_ac97_page_restore(ac97, page_save);\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\t \n\tif ((val_mask & AC97_PD_EAPD) &&\n\t    (kcontrol->private_value & (1<<30))) {\n\t\tif (val & AC97_PD_EAPD)\n\t\t\tac97->power_up &= ~(1 << (reg>>1));\n\t\telse\n\t\t\tac97->power_up |= 1 << (reg>>1);\n\t\tupdate_power_regs(ac97);\n\t}\n#endif\n\treturn err;\n}\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_tone[2] = {\nAC97_SINGLE(\"Tone Control - Bass\", AC97_MASTER_TONE, 8, 15, 1),\nAC97_SINGLE(\"Tone Control - Treble\", AC97_MASTER_TONE, 0, 15, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_pc_beep[2] = {\nAC97_SINGLE(\"Beep Playback Switch\", AC97_PC_BEEP, 15, 1, 1),\nAC97_SINGLE(\"Beep Playback Volume\", AC97_PC_BEEP, 1, 15, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_mic_boost =\n\tAC97_SINGLE(\"Mic Boost (+20dB)\", AC97_MIC, 6, 1, 0);\n\n\nstatic const char* std_rec_sel[] = {\"Mic\", \"CD\", \"Video\", \"Aux\", \"Line\", \"Mix\", \"Mix Mono\", \"Phone\"};\nstatic const char* std_3d_path[] = {\"pre 3D\", \"post 3D\"};\nstatic const char* std_mix[] = {\"Mix\", \"Mic\"};\nstatic const char* std_mic[] = {\"Mic1\", \"Mic2\"};\n\nstatic const struct ac97_enum std_enum[] = {\nAC97_ENUM_DOUBLE(AC97_REC_SEL, 8, 0, 8, std_rec_sel),\nAC97_ENUM_SINGLE(AC97_GENERAL_PURPOSE, 15, 2, std_3d_path),\nAC97_ENUM_SINGLE(AC97_GENERAL_PURPOSE, 9, 2, std_mix),\nAC97_ENUM_SINGLE(AC97_GENERAL_PURPOSE, 8, 2, std_mic),\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_control_capture_src = \nAC97_ENUM(\"Capture Source\", std_enum[0]); \n\nstatic const struct snd_kcontrol_new snd_ac97_control_capture_vol =\nAC97_DOUBLE(\"Capture Volume\", AC97_REC_GAIN, 8, 0, 15, 0);\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_mic_capture[2] = {\nAC97_SINGLE(\"Mic Capture Switch\", AC97_REC_GAIN_MIC, 15, 1, 1),\nAC97_SINGLE(\"Mic Capture Volume\", AC97_REC_GAIN_MIC, 0, 15, 0)\n};\n\nenum {\n\tAC97_GENERAL_PCM_OUT = 0,\n\tAC97_GENERAL_STEREO_ENHANCEMENT,\n\tAC97_GENERAL_3D,\n\tAC97_GENERAL_LOUDNESS,\n\tAC97_GENERAL_MONO,\n\tAC97_GENERAL_MIC,\n\tAC97_GENERAL_LOOPBACK\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_general[7] = {\nAC97_ENUM(\"PCM Out Path & Mute\", std_enum[1]),\nAC97_SINGLE(\"Simulated Stereo Enhancement\", AC97_GENERAL_PURPOSE, 14, 1, 0),\nAC97_SINGLE(\"3D Control - Switch\", AC97_GENERAL_PURPOSE, 13, 1, 0),\nAC97_SINGLE(\"Loudness (bass boost)\", AC97_GENERAL_PURPOSE, 12, 1, 0),\nAC97_ENUM(\"Mono Output Select\", std_enum[2]),\nAC97_ENUM(\"Mic Select\", std_enum[3]),\nAC97_SINGLE(\"ADC/DAC Loopback\", AC97_GENERAL_PURPOSE, 7, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_3d[2] = {\nAC97_SINGLE(\"3D Control - Center\", AC97_3D_CONTROL, 8, 15, 0),\nAC97_SINGLE(\"3D Control - Depth\", AC97_3D_CONTROL, 0, 15, 0)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_center[2] = {\nAC97_SINGLE(\"Center Playback Switch\", AC97_CENTER_LFE_MASTER, 7, 1, 1),\nAC97_SINGLE(\"Center Playback Volume\", AC97_CENTER_LFE_MASTER, 0, 31, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_lfe[2] = {\nAC97_SINGLE(\"LFE Playback Switch\", AC97_CENTER_LFE_MASTER, 15, 1, 1),\nAC97_SINGLE(\"LFE Playback Volume\", AC97_CENTER_LFE_MASTER, 8, 31, 1)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_control_eapd =\nAC97_SINGLE(\"External Amplifier\", AC97_POWERDOWN, 15, 1, 1);\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_modem_switches[2] = {\nAC97_SINGLE(\"Off-hook Switch\", AC97_GPIO_STATUS, 0, 1, 0),\nAC97_SINGLE(\"Caller ID Switch\", AC97_GPIO_STATUS, 2, 1, 0)\n};\n\n \nstatic void set_inv_eapd(struct snd_ac97 *ac97, struct snd_kcontrol *kctl)\n{\n\tkctl->private_value = AC97_SINGLE_VALUE(AC97_POWERDOWN, 15, 1, 0);\n\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN, (1<<15), (1<<15));  \n\tac97->scaps |= AC97_SCAP_INV_EAPD;\n}\n\nstatic int snd_ac97_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n                        \nstatic int snd_ac97_spdif_cmask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t   IEC958_AES0_NONAUDIO |\n\t\t\t\t\t   IEC958_AES0_CON_EMPHASIS_5015 |\n\t\t\t\t\t   IEC958_AES0_CON_NOT_COPYRIGHT;\n\tucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |\n\t\t\t\t\t   IEC958_AES1_CON_ORIGINAL;\n\tucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\n\treturn 0;\n}\n                        \nstatic int snd_ac97_spdif_pmask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\n\t\t\t\t\t   IEC958_AES0_NONAUDIO |\n\t\t\t\t\t   IEC958_AES0_PRO_FS |\n\t\t\t\t\t   IEC958_AES0_PRO_EMPHASIS_5015;\n\treturn 0;\n}\n\nstatic int snd_ac97_spdif_default_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&ac97->reg_mutex);\n\tucontrol->value.iec958.status[0] = ac97->spdif_status & 0xff;\n\tucontrol->value.iec958.status[1] = (ac97->spdif_status >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (ac97->spdif_status >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (ac97->spdif_status >> 24) & 0xff;\n\tmutex_unlock(&ac97->reg_mutex);\n\treturn 0;\n}\n                        \nstatic int snd_ac97_spdif_default_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tunsigned int new = 0;\n\tunsigned short val = 0;\n\tint change;\n\n\tnew = val = ucontrol->value.iec958.status[0] & (IEC958_AES0_PROFESSIONAL|IEC958_AES0_NONAUDIO);\n\tif (ucontrol->value.iec958.status[0] & IEC958_AES0_PROFESSIONAL) {\n\t\tnew |= ucontrol->value.iec958.status[0] & (IEC958_AES0_PRO_FS|IEC958_AES0_PRO_EMPHASIS_5015);\n\t\tswitch (new & IEC958_AES0_PRO_FS) {\n\t\tcase IEC958_AES0_PRO_FS_44100: val |= 0<<12; break;\n\t\tcase IEC958_AES0_PRO_FS_48000: val |= 2<<12; break;\n\t\tcase IEC958_AES0_PRO_FS_32000: val |= 3<<12; break;\n\t\tdefault:\t\t       val |= 1<<12; break;\n\t\t}\n\t\tif ((new & IEC958_AES0_PRO_EMPHASIS) == IEC958_AES0_PRO_EMPHASIS_5015)\n\t\t\tval |= 1<<3;\n\t} else {\n\t\tnew |= ucontrol->value.iec958.status[0] & (IEC958_AES0_CON_EMPHASIS_5015|IEC958_AES0_CON_NOT_COPYRIGHT);\n\t\tnew |= ((ucontrol->value.iec958.status[1] & (IEC958_AES1_CON_CATEGORY|IEC958_AES1_CON_ORIGINAL)) << 8);\n\t\tnew |= ((ucontrol->value.iec958.status[3] & IEC958_AES3_CON_FS) << 24);\n\t\tif ((new & IEC958_AES0_CON_EMPHASIS) == IEC958_AES0_CON_EMPHASIS_5015)\n\t\t\tval |= 1<<3;\n\t\tif (!(new & IEC958_AES0_CON_NOT_COPYRIGHT))\n\t\t\tval |= 1<<2;\n\t\tval |= ((new >> 8) & 0xff) << 4;\t\n\t\tswitch ((new >> 24) & 0xff) {\n\t\tcase IEC958_AES3_CON_FS_44100: val |= 0<<12; break;\n\t\tcase IEC958_AES3_CON_FS_48000: val |= 2<<12; break;\n\t\tcase IEC958_AES3_CON_FS_32000: val |= 3<<12; break;\n\t\tdefault:\t\t       val |= 1<<12; break;\n\t\t}\n\t}\n\n\tmutex_lock(&ac97->reg_mutex);\n\tchange = ac97->spdif_status != new;\n\tac97->spdif_status = new;\n\n\tif (ac97->flags & AC97_CS_SPDIF) {\n\t\tint x = (val >> 12) & 0x03;\n\t\tswitch (x) {\n\t\tcase 0: x = 1; break;  \n\t\tcase 2: x = 0; break;  \n\t\tdefault: x = 0; break; \n\t\t}\n\t\tchange |= snd_ac97_update_bits_nolock(ac97, AC97_CSR_SPDIF, 0x3fff, ((val & 0xcfff) | (x << 12)));\n\t} else if (ac97->flags & AC97_CX_SPDIF) {\n\t\tint v;\n\t\tv = new & (IEC958_AES0_CON_EMPHASIS_5015|IEC958_AES0_CON_NOT_COPYRIGHT) ? 0 : AC97_CXR_COPYRGT;\n\t\tv |= new & IEC958_AES0_NONAUDIO ? AC97_CXR_SPDIF_AC3 : AC97_CXR_SPDIF_PCM;\n\t\tchange |= snd_ac97_update_bits_nolock(ac97, AC97_CXR_AUDIO_MISC, \n\t\t\t\t\t\t      AC97_CXR_SPDIF_MASK | AC97_CXR_COPYRGT,\n\t\t\t\t\t\t      v);\n\t} else if (ac97->id == AC97_ID_YMF743) {\n\t\tchange |= snd_ac97_update_bits_nolock(ac97,\n\t\t\t\t\t\t      AC97_YMF7X3_DIT_CTRL,\n\t\t\t\t\t\t      0xff38,\n\t\t\t\t\t\t      ((val << 4) & 0xff00) |\n\t\t\t\t\t\t      ((val << 2) & 0x0038));\n\t} else {\n\t\tunsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);\n\t\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);  \n\n\t\tchange |= snd_ac97_update_bits_nolock(ac97, AC97_SPDIF, 0x3fff, val);\n\t\tif (extst & AC97_EA_SPDIF) {\n\t\t\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);  \n                }\n\t}\n\tmutex_unlock(&ac97->reg_mutex);\n\n\treturn change;\n}\n\nstatic int snd_ac97_put_spsa(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\t\n\tunsigned short value, old, new;\n\tint change;\n\n\tvalue = (ucontrol->value.integer.value[0] & mask);\n\n\tmutex_lock(&ac97->reg_mutex);\n\tmask <<= shift;\n\tvalue <<= shift;\n\told = snd_ac97_read_cache(ac97, reg);\n\tnew = (old & ~mask) | value;\n\tchange = old != new;\n\n\tif (change) {\n\t\tunsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);\n\t\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);  \n\t\tchange = snd_ac97_update_bits_nolock(ac97, reg, mask, value);\n\t\tif (extst & AC97_EA_SPDIF)\n\t\t\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);  \n\t}\n\tmutex_unlock(&ac97->reg_mutex);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_spdif[5] = {\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t\t.info = snd_ac97_spdif_mask_info,\n\t\t.get = snd_ac97_spdif_cmask_get,\n\t},\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PRO_MASK),\n\t\t.info = snd_ac97_spdif_mask_info,\n\t\t.get = snd_ac97_spdif_pmask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t\t.info = snd_ac97_spdif_mask_info,\n\t\t.get = snd_ac97_spdif_default_get,\n\t\t.put = snd_ac97_spdif_default_put,\n\t},\n\n\tAC97_SINGLE(SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,SWITCH),AC97_EXTENDED_STATUS, 2, 1, 0),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,NONE) \"AC97-SPSA\",\n\t\t.info = snd_ac97_info_volsw,\n\t\t.get = snd_ac97_get_volsw,\n\t\t.put = snd_ac97_put_spsa,\n\t\t.private_value = AC97_SINGLE_VALUE(AC97_EXTENDED_STATUS, 4, 3, 0)\n\t},\n};\n\n#define AD18XX_PCM_BITS(xname, codec, lshift, rshift, mask) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_ad18xx_pcm_info_bits, \\\n  .get = snd_ac97_ad18xx_pcm_get_bits, .put = snd_ac97_ad18xx_pcm_put_bits, \\\n  .private_value = (codec) | ((lshift) << 8) | ((rshift) << 12) | ((mask) << 16) }\n\nstatic int snd_ac97_ad18xx_pcm_info_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint mask = (kcontrol->private_value >> 16) & 0x0f;\n\tint lshift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\n\tuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES))\n\t\tuinfo->count = 2;\n\telse\n\t\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_ac97_ad18xx_pcm_get_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->private_value & 3;\n\tint lshift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\t\n\tucontrol->value.integer.value[0] = mask - ((ac97->spec.ad18xx.pcmreg[codec] >> lshift) & mask);\n\tif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES))\n\t\tucontrol->value.integer.value[1] = mask - ((ac97->spec.ad18xx.pcmreg[codec] >> rshift) & mask);\n\treturn 0;\n}\n\nstatic int snd_ac97_ad18xx_pcm_put_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->private_value & 3;\n\tint lshift = (kcontrol->private_value >> 8) & 0x0f;\n\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tunsigned short val, valmask;\n\t\n\tval = (mask - (ucontrol->value.integer.value[0] & mask)) << lshift;\n\tvalmask = mask << lshift;\n\tif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES)) {\n\t\tval |= (mask - (ucontrol->value.integer.value[1] & mask)) << rshift;\n\t\tvalmask |= mask << rshift;\n\t}\n\treturn snd_ac97_ad18xx_update_pcm_bits(ac97, codec, valmask, val);\n}\n\n#define AD18XX_PCM_VOLUME(xname, codec) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ac97_ad18xx_pcm_info_volume, \\\n  .get = snd_ac97_ad18xx_pcm_get_volume, .put = snd_ac97_ad18xx_pcm_put_volume, \\\n  .private_value = codec }\n\nstatic int snd_ac97_ad18xx_pcm_info_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 31;\n\treturn 0;\n}\n\nstatic int snd_ac97_ad18xx_pcm_get_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->private_value & 3;\n\t\n\tmutex_lock(&ac97->page_mutex);\n\tucontrol->value.integer.value[0] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 8) & 31);\n\tucontrol->value.integer.value[1] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 0) & 31);\n\tmutex_unlock(&ac97->page_mutex);\n\treturn 0;\n}\n\nstatic int snd_ac97_ad18xx_pcm_put_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->private_value & 3;\n\tunsigned short val1, val2;\n\t\n\tval1 = 31 - (ucontrol->value.integer.value[0] & 31);\n\tval2 = 31 - (ucontrol->value.integer.value[1] & 31);\n\treturn snd_ac97_ad18xx_update_pcm_bits(ac97, codec, 0x1f1f, (val1 << 8) | val2);\n}\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_ad18xx_pcm[2] = {\nAD18XX_PCM_BITS(\"PCM Playback Switch\", 0, 15, 7, 1),\nAD18XX_PCM_VOLUME(\"PCM Playback Volume\", 0)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_ad18xx_surround[2] = {\nAD18XX_PCM_BITS(\"Surround Playback Switch\", 1, 15, 7, 1),\nAD18XX_PCM_VOLUME(\"Surround Playback Volume\", 1)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_ad18xx_center[2] = {\nAD18XX_PCM_BITS(\"Center Playback Switch\", 2, 15, 15, 1),\nAD18XX_PCM_BITS(\"Center Playback Volume\", 2, 8, 8, 31)\n};\n\nstatic const struct snd_kcontrol_new snd_ac97_controls_ad18xx_lfe[2] = {\nAD18XX_PCM_BITS(\"LFE Playback Switch\", 2, 7, 7, 1),\nAD18XX_PCM_BITS(\"LFE Playback Volume\", 2, 0, 0, 31)\n};\n\n \n\nstatic void snd_ac97_powerdown(struct snd_ac97 *ac97);\n\nstatic int snd_ac97_bus_free(struct snd_ac97_bus *bus)\n{\n\tif (bus) {\n\t\tsnd_ac97_bus_proc_done(bus);\n\t\tkfree(bus->pcms);\n\t\tif (bus->private_free)\n\t\t\tbus->private_free(bus);\n\t\tkfree(bus);\n\t}\n\treturn 0;\n}\n\nstatic int snd_ac97_bus_dev_free(struct snd_device *device)\n{\n\tstruct snd_ac97_bus *bus = device->device_data;\n\treturn snd_ac97_bus_free(bus);\n}\n\nstatic int snd_ac97_free(struct snd_ac97 *ac97)\n{\n\tif (ac97) {\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\t\tcancel_delayed_work_sync(&ac97->power_work);\n#endif\n\t\tsnd_ac97_proc_done(ac97);\n\t\tif (ac97->bus)\n\t\t\tac97->bus->codec[ac97->num] = NULL;\n\t\tif (ac97->private_free)\n\t\t\tac97->private_free(ac97);\n\t\tkfree(ac97);\n\t}\n\treturn 0;\n}\n\nstatic int snd_ac97_dev_free(struct snd_device *device)\n{\n\tstruct snd_ac97 *ac97 = device->device_data;\n\tsnd_ac97_powerdown(ac97);  \n\treturn snd_ac97_free(ac97);\n}\n\nstatic int snd_ac97_try_volume_mix(struct snd_ac97 * ac97, int reg)\n{\n\tunsigned short val, mask = AC97_MUTE_MASK_MONO;\n\n\tif (! snd_ac97_valid_reg(ac97, reg))\n\t\treturn 0;\n\n\tswitch (reg) {\n\tcase AC97_MASTER_TONE:\n\t\treturn ac97->caps & AC97_BC_BASS_TREBLE ? 1 : 0;\n\tcase AC97_HEADPHONE:\n\t\treturn ac97->caps & AC97_BC_HEADPHONE ? 1 : 0;\n\tcase AC97_REC_GAIN_MIC:\n\t\treturn ac97->caps & AC97_BC_DEDICATED_MIC ? 1 : 0;\n\tcase AC97_3D_CONTROL:\n\t\tif (ac97->caps & AC97_BC_3D_TECH_ID_MASK) {\n\t\t\tval = snd_ac97_read(ac97, reg);\n\t\t\t \n\t\t\treturn val == 0;\n\t\t}\n\t\treturn 0;\n\tcase AC97_CENTER_LFE_MASTER:\t \n\t\tif ((ac97->ext_id & AC97_EI_CDAC) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase AC97_CENTER_LFE_MASTER+1:\t \n\t\tif ((ac97->ext_id & AC97_EI_LDAC) == 0)\n\t\t\treturn 0;\n\t\treg = AC97_CENTER_LFE_MASTER;\n\t\tmask = 0x0080;\n\t\tbreak;\n\tcase AC97_SURROUND_MASTER:\n\t\tif ((ac97->ext_id & AC97_EI_SDAC) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tval = snd_ac97_read(ac97, reg);\n\tif (!(val & mask)) {\n\t\t \n\t\t \n\t\tsnd_ac97_write_cache(ac97, reg, val | mask);\n\t\tval = snd_ac97_read(ac97, reg);\n\t\tval = snd_ac97_read(ac97, reg);\n\t\tif (!(val & mask))\n\t\t\treturn 0;\t \n\t}\n\treturn 1;\t\t \n}\n\nstatic void check_volume_resolution(struct snd_ac97 *ac97, int reg, unsigned char *lo_max, unsigned char *hi_max)\n{\n\tunsigned short cbit[3] = { 0x20, 0x10, 0x01 };\n\tunsigned char max[3] = { 63, 31, 15 };\n\tint i;\n\n\t \n\tif (ac97->res_table) {\n\t\tconst struct snd_ac97_res_table *tbl;\n\t\tfor (tbl = ac97->res_table; tbl->reg; tbl++) {\n\t\t\tif (tbl->reg == reg) {\n\t\t\t\t*lo_max = tbl->bits & 0xff;\n\t\t\t\t*hi_max = (tbl->bits >> 8) & 0xff;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t*lo_max = *hi_max = 0;\n\tfor (i = 0 ; i < ARRAY_SIZE(cbit); i++) {\n\t\tunsigned short val;\n\t\tsnd_ac97_write(\n\t\t\tac97, reg,\n\t\t\tAC97_MUTE_MASK_STEREO | cbit[i] | (cbit[i] << 8)\n\t\t);\n\t\t \n\t\tval = snd_ac97_read(ac97, reg);\n\t\tval = snd_ac97_read(ac97, reg);\n\t\tif (! *lo_max && (val & 0x7f) == cbit[i])\n\t\t\t*lo_max = max[i];\n\t\tif (! *hi_max && ((val >> 8) & 0x7f) == cbit[i])\n\t\t\t*hi_max = max[i];\n\t\tif (*lo_max && *hi_max)\n\t\t\tbreak;\n\t}\n}\n\nstatic int snd_ac97_try_bit(struct snd_ac97 * ac97, int reg, int bit)\n{\n\tunsigned short mask, val, orig, res;\n\n\tmask = 1 << bit;\n\torig = snd_ac97_read(ac97, reg);\n\tval = orig ^ mask;\n\tsnd_ac97_write(ac97, reg, val);\n\tres = snd_ac97_read(ac97, reg);\n\tsnd_ac97_write_cache(ac97, reg, orig);\n\treturn res == val;\n}\n\n \nstatic void snd_ac97_change_volume_params2(struct snd_ac97 * ac97, int reg, int shift, unsigned char *max)\n{\n\tunsigned short val, val1;\n\n\t*max = 63;\n\tval = AC97_MUTE_MASK_STEREO | (0x20 << shift);\n\tsnd_ac97_write(ac97, reg, val);\n\tval1 = snd_ac97_read(ac97, reg);\n\tif (val != val1) {\n\t\t*max = 31;\n\t}\n\t \n\tsnd_ac97_write_cache(ac97, reg, AC97_MUTE_MASK_STEREO);\n}\n\nstatic inline int printable(unsigned int x)\n{\n\tx &= 0xff;\n\tif (x < ' ' || x >= 0x71) {\n\t\tif (x <= 0x89)\n\t\t\treturn x - 0x71 + 'A';\n\t\treturn '?';\n\t}\n\treturn x;\n}\n\nstatic struct snd_kcontrol *snd_ac97_cnew(const struct snd_kcontrol_new *_template,\n\t\t\t\t\t  struct snd_ac97 * ac97)\n{\n\tstruct snd_kcontrol_new template;\n\tmemcpy(&template, _template, sizeof(template));\n\ttemplate.index = ac97->num;\n\treturn snd_ctl_new1(&template, ac97);\n}\n\n \nstatic int snd_ac97_cmute_new_stereo(struct snd_card *card, char *name, int reg,\n\t\t\t\t     int check_stereo, int check_amix,\n\t\t\t\t     struct snd_ac97 *ac97)\n{\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\tunsigned short val, val1, mute_mask;\n\n\tif (! snd_ac97_valid_reg(ac97, reg))\n\t\treturn 0;\n\n\tmute_mask = AC97_MUTE_MASK_MONO;\n\tval = snd_ac97_read(ac97, reg);\n\tif (check_stereo || (ac97->flags & AC97_STEREO_MUTES)) {\n\t\t \n\t\tval1 = val | AC97_MUTE_MASK_STEREO;\n\t\tsnd_ac97_write(ac97, reg, val1);\n\t\tif (val1 == snd_ac97_read(ac97, reg))\n\t\t\tmute_mask = AC97_MUTE_MASK_STEREO;\n\t}\n\tif (mute_mask == AC97_MUTE_MASK_STEREO) {\n\t\tstruct snd_kcontrol_new tmp = AC97_DOUBLE(name, reg, 15, 7, 1, 1);\n\t\tif (check_amix)\n\t\t\ttmp.private_value |= (1 << 30);\n\t\ttmp.index = ac97->num;\n\t\tkctl = snd_ctl_new1(&tmp, ac97);\n\t} else {\n\t\tstruct snd_kcontrol_new tmp = AC97_SINGLE(name, reg, 15, 1, 1);\n\t\tif (check_amix)\n\t\t\ttmp.private_value |= (1 << 30);\n\t\ttmp.index = ac97->num;\n\t\tkctl = snd_ctl_new1(&tmp, ac97);\n\t}\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tsnd_ac97_write_cache(ac97, reg, val | mute_mask);\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);\n\nstatic const unsigned int *find_db_scale(unsigned int maxval)\n{\n\tswitch (maxval) {\n\tcase 0x0f: return db_scale_4bit;\n\tcase 0x1f: return db_scale_5bit;\n\tcase 0x3f: return db_scale_6bit;\n\t}\n\treturn NULL;\n}\n\nstatic void set_tlv_db_scale(struct snd_kcontrol *kctl, const unsigned int *tlv)\n{\n\tkctl->tlv.p = tlv;\n\tif (tlv)\n\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n}\n\n \nstatic int snd_ac97_cvol_new(struct snd_card *card, char *name, int reg, unsigned int lo_max,\n\t\t\t     unsigned int hi_max, struct snd_ac97 *ac97)\n{\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\n\tif (! snd_ac97_valid_reg(ac97, reg))\n\t\treturn 0;\n\tif (hi_max) {\n\t\t \n\t\tstruct snd_kcontrol_new tmp = AC97_DOUBLE(name, reg, 8, 0, lo_max, 1);\n\t\ttmp.index = ac97->num;\n\t\tkctl = snd_ctl_new1(&tmp, ac97);\n\t} else {\n\t\t \n\t\tstruct snd_kcontrol_new tmp = AC97_SINGLE(name, reg, 0, lo_max, 1);\n\t\ttmp.index = ac97->num;\n\t\tkctl = snd_ctl_new1(&tmp, ac97);\n\t}\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\tif (reg >= AC97_PHONE && reg <= AC97_PCM)\n\t\tset_tlv_db_scale(kctl, db_scale_5bit_12db_max);\n\telse\n\t\tset_tlv_db_scale(kctl, find_db_scale(lo_max));\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_ac97_write_cache(\n\t\tac97, reg,\n\t\t(snd_ac97_read(ac97, reg) & AC97_MUTE_MASK_STEREO)\n\t\t| lo_max | (hi_max << 8)\n\t);\n\treturn 0;\n}\n\n \nstatic int snd_ac97_cmix_new_stereo(struct snd_card *card, const char *pfx,\n\t\t\t\t    int reg, int check_stereo, int check_amix,\n\t\t\t\t    struct snd_ac97 *ac97)\n{\n\tint err;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tunsigned char lo_max, hi_max;\n\n\tif (! snd_ac97_valid_reg(ac97, reg))\n\t\treturn 0;\n\n\tif (snd_ac97_try_bit(ac97, reg, 15)) {\n\t\tsprintf(name, \"%s Switch\", pfx);\n\t\terr = snd_ac97_cmute_new_stereo(card, name, reg,\n\t\t\t\t\t\tcheck_stereo, check_amix,\n\t\t\t\t\t\tac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tcheck_volume_resolution(ac97, reg, &lo_max, &hi_max);\n\tif (lo_max) {\n\t\tsprintf(name, \"%s Volume\", pfx);\n\t\terr = snd_ac97_cvol_new(card, name, reg, lo_max, hi_max, ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n#define snd_ac97_cmix_new(card, pfx, reg, acheck, ac97) \\\n\tsnd_ac97_cmix_new_stereo(card, pfx, reg, 0, acheck, ac97)\n#define snd_ac97_cmute_new(card, name, reg, acheck, ac97) \\\n\tsnd_ac97_cmute_new_stereo(card, name, reg, 0, acheck, ac97)\n\nstatic unsigned int snd_ac97_determine_spdif_rates(struct snd_ac97 *ac97);\n\nstatic int snd_ac97_mixer_build(struct snd_ac97 * ac97)\n{\n\tstruct snd_card *card = ac97->bus->card;\n\tstruct snd_kcontrol *kctl;\n\tint err;\n\tunsigned int idx;\n\tunsigned char max;\n\n\t \n\t \n\tif (snd_ac97_try_volume_mix(ac97, AC97_MASTER)) {\n\t\tif (ac97->flags & AC97_HAS_NO_MASTER_VOL)\n\t\t\terr = snd_ac97_cmute_new(card, \"Master Playback Switch\",\n\t\t\t\t\t\t AC97_MASTER, 0, ac97);\n\t\telse\n\t\t\terr = snd_ac97_cmix_new(card, \"Master Playback\",\n\t\t\t\t\t\tAC97_MASTER, 0, ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tac97->regs[AC97_CENTER_LFE_MASTER] = AC97_MUTE_MASK_STEREO;\n\n\t \n\tif ((snd_ac97_try_volume_mix(ac97, AC97_CENTER_LFE_MASTER)) \n\t\t&& !(ac97->flags & AC97_AD_MULTI)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_center[0], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_center[1], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 0, &max);\n\t\tkctl->private_value &= ~(0xff << 16);\n\t\tkctl->private_value |= (int)max << 16;\n\t\tset_tlv_db_scale(kctl, find_db_scale(max));\n\t\tsnd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max);\n\t}\n\n\t \n\tif ((snd_ac97_try_volume_mix(ac97, AC97_CENTER_LFE_MASTER+1))\n\t\t&& !(ac97->flags & AC97_AD_MULTI)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_lfe[0], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_lfe[1], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tsnd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 8, &max);\n\t\tkctl->private_value &= ~(0xff << 16);\n\t\tkctl->private_value |= (int)max << 16;\n\t\tset_tlv_db_scale(kctl, find_db_scale(max));\n\t\tsnd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max << 8);\n\t}\n\n\t \n\tif ((snd_ac97_try_volume_mix(ac97, AC97_SURROUND_MASTER)) \n\t\t&& !(ac97->flags & AC97_AD_MULTI)) {\n\t\t \n\t\terr = snd_ac97_cmix_new_stereo(card, \"Surround Playback\",\n\t\t\t\t\t       AC97_SURROUND_MASTER, 1, 0,\n\t\t\t\t\t       ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (snd_ac97_try_volume_mix(ac97, AC97_HEADPHONE)) {\n\t\terr = snd_ac97_cmix_new(card, \"Headphone Playback\",\n\t\t\t\t\tAC97_HEADPHONE, 0, ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t\n\t \n\tif (snd_ac97_try_volume_mix(ac97, AC97_MASTER_MONO)) {\n\t\terr = snd_ac97_cmix_new(card, \"Master Mono Playback\",\n\t\t\t\t\tAC97_MASTER_MONO, 0, ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_TONE)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_MASTER_TONE)) {\n\t\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_tone[idx], ac97);\n\t\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\tif (ac97->id == AC97_ID_YMF743 ||\n\t\t\t\t    ac97->id == AC97_ID_YMF753) {\n\t\t\t\t\tkctl->private_value &= ~(0xff << 16);\n\t\t\t\t\tkctl->private_value |= 7 << 16;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnd_ac97_write_cache(ac97, AC97_MASTER_TONE, 0x0f0f);\n\t\t}\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_PC_BEEP) && \n\t\t((ac97->flags & AC97_HAS_PC_BEEP) ||\n\t    snd_ac97_try_volume_mix(ac97, AC97_PC_BEEP))) {\n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_pc_beep[idx], ac97);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_tlv_db_scale(kctl, db_scale_4bit);\n\t\tsnd_ac97_write_cache(\n\t\t\tac97,\n\t\t\tAC97_PC_BEEP,\n\t\t\t(snd_ac97_read(ac97, AC97_PC_BEEP)\n\t\t\t\t| AC97_MUTE_MASK_MONO | 0x001e)\n\t\t);\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_PHONE)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {\n\t\t\terr = snd_ac97_cmix_new(card, \"Phone Playback\",\n\t\t\t\t\t\tAC97_PHONE, 1, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_MIC)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_MIC)) {\n\t\t\terr = snd_ac97_cmix_new(card, \"Mic Playback\",\n\t\t\t\t\t\tAC97_MIC, 1, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic_boost, ac97));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (snd_ac97_try_volume_mix(ac97, AC97_LINE)) {\n\t\terr = snd_ac97_cmix_new(card, \"Line Playback\",\n\t\t\t\t\tAC97_LINE, 1, ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_CD)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_CD)) {\n\t\t\terr = snd_ac97_cmix_new(card, \"CD Playback\",\n\t\t\t\t\t\tAC97_CD, 1, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\t\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_VIDEO)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {\n\t\t\terr = snd_ac97_cmix_new(card, \"Video Playback\",\n\t\t\t\t\t\tAC97_VIDEO, 1, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_AUX)) {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_AUX)) {\n\t\t\terr = snd_ac97_cmix_new(card, \"Aux Playback\",\n\t\t\t\t\t\tAC97_AUX, 1, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (ac97->flags & AC97_AD_MULTI) {\n\t\tunsigned short init_val;\n\t\tif (ac97->flags & AC97_STEREO_MUTES)\n\t\t\tinit_val = 0x9f9f;\n\t\telse\n\t\t\tinit_val = 0x9f1f;\n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_pcm[idx], ac97);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_tlv_db_scale(kctl, db_scale_5bit);\n\t\tac97->spec.ad18xx.pcmreg[0] = init_val;\n\t\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC) {\n\t\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_surround[idx], ac97);\n\t\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tset_tlv_db_scale(kctl, db_scale_5bit);\n\t\t\tac97->spec.ad18xx.pcmreg[1] = init_val;\n\t\t}\n\t\tif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC) {\n\t\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_center[idx], ac97);\n\t\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tset_tlv_db_scale(kctl, db_scale_5bit);\n\t\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_lfe[idx], ac97);\n\t\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tset_tlv_db_scale(kctl, db_scale_5bit);\n\t\t\tac97->spec.ad18xx.pcmreg[2] = init_val;\n\t\t}\n\t\tsnd_ac97_write_cache(ac97, AC97_PCM, init_val);\n\t} else {\n\t\tif (!(ac97->flags & AC97_HAS_NO_STD_PCM)) {\n\t\t\tif (ac97->flags & AC97_HAS_NO_PCM_VOL)\n\t\t\t\terr = snd_ac97_cmute_new(card,\n\t\t\t\t\t\t\t \"PCM Playback Switch\",\n\t\t\t\t\t\t\t AC97_PCM, 0, ac97);\n\t\t\telse\n\t\t\t\terr = snd_ac97_cmix_new(card, \"PCM Playback\",\n\t\t\t\t\t\t\tAC97_PCM, 0, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (!(ac97->flags & AC97_HAS_NO_REC_GAIN)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_src, ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (snd_ac97_try_bit(ac97, AC97_REC_GAIN, 15)) {\n\t\t\terr = snd_ac97_cmute_new(card, \"Capture Switch\",\n\t\t\t\t\t\t AC97_REC_GAIN, 0, ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkctl = snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_tlv_db_scale(kctl, db_scale_rec_gain);\n\t\tsnd_ac97_write_cache(ac97, AC97_REC_SEL, 0x0000);\n\t\tsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x0000);\n\t}\n\t \n\tif (snd_ac97_try_volume_mix(ac97, AC97_REC_GAIN_MIC)) {\n\t\tfor (idx = 0; idx < 2; idx++) {\n\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_mic_capture[idx], ac97);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tset_tlv_db_scale(kctl, db_scale_rec_gain);\n\t\tsnd_ac97_write_cache(ac97, AC97_REC_GAIN_MIC, 0x0000);\n\t}\n\n\t \n\tif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 15)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_PCM_OUT], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ac97->caps & AC97_BC_SIM_STEREO) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_STEREO_ENHANCEMENT], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 13)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_3D], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ac97->caps & AC97_BC_LOUDNESS) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_LOUDNESS], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 9)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_MONO], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 8)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_MIC], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (enable_loopback && snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 7)) {\n\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_LOOPBACK], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, ~AC97_GP_DRSS_MASK, 0x0000);\n\n\t \n\tif (ac97->build_ops->build_3d) {\n\t\tac97->build_ops->build_3d(ac97);\n\t} else {\n\t\tif (snd_ac97_try_volume_mix(ac97, AC97_3D_CONTROL)) {\n\t\t\tunsigned short val;\n\t\t\tval = 0x0707;\n\t\t\tsnd_ac97_write(ac97, AC97_3D_CONTROL, val);\n\t\t\tval = snd_ac97_read(ac97, AC97_3D_CONTROL);\n\t\t\tval = val == 0x0606;\n\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_3d[0], ac97);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (val)\n\t\t\t\tkctl->private_value = AC97_3D_CONTROL | (9 << 8) | (7 << 16);\n\t\t\tkctl = snd_ac97_cnew(&snd_ac97_controls_3d[1], ac97);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (val)\n\t\t\t\tkctl->private_value = AC97_3D_CONTROL | (1 << 8) | (7 << 16);\n\t\t\tsnd_ac97_write_cache(ac97, AC97_3D_CONTROL, 0x0000);\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (ac97->subsystem_vendor == 0x1043 &&\n\t    ac97->subsystem_device == 0x810f)\n\t\tac97->ext_id |= AC97_EI_SPDIF;\n\n\tif ((ac97->ext_id & AC97_EI_SPDIF) && !(ac97->scaps & AC97_SCAP_NO_SPDIF)) {\n\t\tif (ac97->build_ops->build_spdif) {\n\t\t\terr = ac97->build_ops->build_spdif(ac97);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tfor (idx = 0; idx < 5; idx++) {\n\t\t\t\terr = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_spdif[idx], ac97));\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (ac97->build_ops->build_post_spdif) {\n\t\t\t\terr = ac97->build_ops->build_post_spdif(ac97);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tsnd_ac97_write_cache(ac97, AC97_SPDIF, 0x2a20);\n\t\t\tac97->rates[AC97_RATES_SPDIF] = snd_ac97_determine_spdif_rates(ac97);\n\t\t}\n\t\tac97->spdif_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\t}\n\t\n\t \n\tif (ac97->build_ops->build_specific) {\n\t\terr = ac97->build_ops->build_specific(ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (snd_ac97_try_bit(ac97, AC97_POWERDOWN, 15)) {\n\t\tkctl = snd_ac97_cnew(&snd_ac97_control_eapd, ac97);\n\t\tif (! kctl)\n\t\t\treturn -ENOMEM;\n\t\tif (ac97->scaps & AC97_SCAP_INV_EAPD)\n\t\t\tset_inv_eapd(ac97, kctl);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ac97_modem_build(struct snd_card *card, struct snd_ac97 * ac97)\n{\n\tint err, idx;\n\n\t \n\tsnd_ac97_write(ac97, AC97_GPIO_CFG, 0xffff & ~(AC97_GPIO_LINE1_OH));\n\tsnd_ac97_write(ac97, AC97_GPIO_POLARITY, 0xffff & ~(AC97_GPIO_LINE1_OH));\n\tsnd_ac97_write(ac97, AC97_GPIO_STICKY, 0xffff);\n\tsnd_ac97_write(ac97, AC97_GPIO_WAKEUP, 0x0);\n\tsnd_ac97_write(ac97, AC97_MISC_AFE, 0x0);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(snd_ac97_controls_modem_switches); idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ac97_controls_modem_switches[idx], ac97));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ac97->build_ops->build_specific) {\n\t\terr = ac97->build_ops->build_specific(ac97);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_ac97_test_rate(struct snd_ac97 *ac97, int reg, int shadow_reg, int rate)\n{\n\tunsigned short val;\n\tunsigned int tmp;\n\n\ttmp = ((unsigned int)rate * ac97->bus->clock) / 48000;\n\tsnd_ac97_write_cache(ac97, reg, tmp & 0xffff);\n\tif (shadow_reg)\n\t\tsnd_ac97_write_cache(ac97, shadow_reg, tmp & 0xffff);\n\tval = snd_ac97_read(ac97, reg);\n\treturn val == (tmp & 0xffff);\n}\n\nstatic void snd_ac97_determine_rates(struct snd_ac97 *ac97, int reg, int shadow_reg, unsigned int *r_result)\n{\n\tunsigned int result = 0;\n\tunsigned short saved;\n\n\tif (ac97->bus->no_vra) {\n\t\t*r_result = SNDRV_PCM_RATE_48000;\n\t\tif ((ac97->flags & AC97_DOUBLE_RATE) &&\n\t\t    reg == AC97_PCM_FRONT_DAC_RATE)\n\t\t\t*r_result |= SNDRV_PCM_RATE_96000;\n\t\treturn;\n\t}\n\n\tsaved = snd_ac97_read(ac97, reg);\n\tif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)\n\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_DRA, 0);\n\t \n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 11000))\n\t\tresult |= SNDRV_PCM_RATE_CONTINUOUS;\n\t \n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 8000))\n\t\tresult |= SNDRV_PCM_RATE_8000;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 11025))\n\t\tresult |= SNDRV_PCM_RATE_11025;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 16000))\n\t\tresult |= SNDRV_PCM_RATE_16000;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 22050))\n\t\tresult |= SNDRV_PCM_RATE_22050;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 32000))\n\t\tresult |= SNDRV_PCM_RATE_32000;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 44100))\n\t\tresult |= SNDRV_PCM_RATE_44100;\n\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 48000))\n\t\tresult |= SNDRV_PCM_RATE_48000;\n\tif ((ac97->flags & AC97_DOUBLE_RATE) &&\n\t    reg == AC97_PCM_FRONT_DAC_RATE) {\n\t\t \n\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_DRA, AC97_EA_DRA);\n\t\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 64000 / 2))\n\t\t\tresult |= SNDRV_PCM_RATE_64000;\n\t\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 88200 / 2))\n\t\t\tresult |= SNDRV_PCM_RATE_88200;\n\t\tif (snd_ac97_test_rate(ac97, reg, shadow_reg, 96000 / 2))\n\t\t\tresult |= SNDRV_PCM_RATE_96000;\n\t\t \n\t\tif (!snd_ac97_test_rate(ac97, reg, shadow_reg, 76100 / 2))\n\t\t\tresult &= ~SNDRV_PCM_RATE_CONTINUOUS;\n\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_DRA, 0);\n\t}\n\t \n\tsnd_ac97_write_cache(ac97, reg, saved);\n\tif (shadow_reg)\n\t\tsnd_ac97_write_cache(ac97, shadow_reg, saved);\n\t*r_result = result;\n}\n\n \nstatic unsigned int snd_ac97_determine_spdif_rates(struct snd_ac97 *ac97)\n{\n\tunsigned int result = 0;\n\tint i;\n\tstatic const unsigned short ctl_bits[] = {\n\t\tAC97_SC_SPSR_44K, AC97_SC_SPSR_32K, AC97_SC_SPSR_48K\n\t};\n\tstatic const unsigned int rate_bits[] = {\n\t\tSNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_32000, SNDRV_PCM_RATE_48000\n\t};\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(ctl_bits); i++) {\n\t\tsnd_ac97_update_bits(ac97, AC97_SPDIF, AC97_SC_SPSR_MASK, ctl_bits[i]);\n\t\tif ((snd_ac97_read(ac97, AC97_SPDIF) & AC97_SC_SPSR_MASK) == ctl_bits[i])\n\t\t\tresult |= rate_bits[i];\n\t}\n\treturn result;\n}\n\n \nstatic const struct ac97_codec_id *look_for_codec_id(const struct ac97_codec_id *table,\n\t\t\t\t\t\t     unsigned int id)\n{\n\tconst struct ac97_codec_id *pid;\n\n\tfor (pid = table; pid->id; pid++)\n\t\tif (pid->id == (id & pid->mask))\n\t\t\treturn pid;\n\treturn NULL;\n}\n\nvoid snd_ac97_get_name(struct snd_ac97 *ac97, unsigned int id, char *name, int modem)\n{\n\tconst struct ac97_codec_id *pid;\n\n\tsprintf(name, \"0x%x %c%c%c\", id,\n\t\tprintable(id >> 24),\n\t\tprintable(id >> 16),\n\t\tprintable(id >> 8));\n\tpid = look_for_codec_id(snd_ac97_codec_id_vendors, id);\n\tif (! pid)\n\t\treturn;\n\n\tstrcpy(name, pid->name);\n\tif (ac97 && pid->patch) {\n\t\tif ((modem && (pid->flags & AC97_MODEM_PATCH)) ||\n\t\t    (! modem && ! (pid->flags & AC97_MODEM_PATCH)))\n\t\t\tpid->patch(ac97);\n\t} \n\n\tpid = look_for_codec_id(snd_ac97_codec_ids, id);\n\tif (pid) {\n\t\tstrcat(name, \" \");\n\t\tstrcat(name, pid->name);\n\t\tif (pid->mask != 0xffffffff)\n\t\t\tsprintf(name + strlen(name), \" rev %d\", id & ~pid->mask);\n\t\tif (ac97 && pid->patch) {\n\t\t\tif ((modem && (pid->flags & AC97_MODEM_PATCH)) ||\n\t\t\t    (! modem && ! (pid->flags & AC97_MODEM_PATCH)))\n\t\t\t\tpid->patch(ac97);\n\t\t}\n\t} else\n\t\tsprintf(name + strlen(name), \" id %x\", id & 0xff);\n}\n\n \nconst char *snd_ac97_get_short_name(struct snd_ac97 *ac97)\n{\n\tconst struct ac97_codec_id *pid;\n\n\tfor (pid = snd_ac97_codec_ids; pid->id; pid++)\n\t\tif (pid->id == (ac97->id & pid->mask))\n\t\t\treturn pid->name;\n\treturn \"unknown codec\";\n}\n\nEXPORT_SYMBOL(snd_ac97_get_short_name);\n\n \nstatic int ac97_reset_wait(struct snd_ac97 *ac97, int timeout, int with_modem)\n{\n\tunsigned long end_time;\n\tunsigned short val;\n\n\tend_time = jiffies + timeout;\n\tdo {\n\t\t\n\t\t \n\t\tsnd_ac97_read(ac97, AC97_RESET);\n\t\tsnd_ac97_read(ac97, AC97_VENDOR_ID1);\n\t\tsnd_ac97_read(ac97, AC97_VENDOR_ID2);\n\t\t \n\t\tif (with_modem) {\n\t\t\tval = snd_ac97_read(ac97, AC97_EXTENDED_MID);\n\t\t\tif (val != 0xffff && (val & 1) != 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) {\n\t\t\t \n\t\t\tval = snd_ac97_read(ac97, AC97_VENDOR_ID1);\n\t\t\tif (val != 0 && val != 0xffff)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a05);\n\t\t\tif ((snd_ac97_read(ac97, AC97_REC_GAIN) & 0x7fff) == 0x0a05)\n\t\t\t\treturn 0;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\treturn -ENODEV;\n}\n\n \nint snd_ac97_bus(struct snd_card *card, int num,\n\t\t const struct snd_ac97_bus_ops *ops,\n\t\t void *private_data, struct snd_ac97_bus **rbus)\n{\n\tint err;\n\tstruct snd_ac97_bus *bus;\n\tstatic const struct snd_device_ops dev_ops = {\n\t\t.dev_free =\tsnd_ac97_bus_dev_free,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (bus == NULL)\n\t\treturn -ENOMEM;\n\tbus->card = card;\n\tbus->num = num;\n\tbus->ops = ops;\n\tbus->private_data = private_data;\n\tbus->clock = 48000;\n\tspin_lock_init(&bus->bus_lock);\n\tsnd_ac97_bus_proc_init(bus);\n\terr = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops);\n\tif (err < 0) {\n\t\tsnd_ac97_bus_free(bus);\n\t\treturn err;\n\t}\n\tif (rbus)\n\t\t*rbus = bus;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_bus);\n\n \nstatic void ac97_device_release(struct device * dev)\n{\n}\n\n \nstatic int snd_ac97_dev_register(struct snd_device *device)\n{\n\tstruct snd_ac97 *ac97 = device->device_data;\n\tint err;\n\n\tac97->dev.bus = &ac97_bus_type;\n\tac97->dev.parent = ac97->bus->card->dev;\n\tac97->dev.release = ac97_device_release;\n\tdev_set_name(&ac97->dev, \"%d-%d:%s\",\n\t\t     ac97->bus->card->number, ac97->num,\n\t\t     snd_ac97_get_short_name(ac97));\n\terr = device_register(&ac97->dev);\n\tif (err < 0) {\n\t\tac97_err(ac97, \"Can't register ac97 bus\\n\");\n\t\tput_device(&ac97->dev);\n\t\tac97->dev.bus = NULL;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_ac97_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_ac97 *ac97 = device->device_data;\n\tif (ac97->dev.bus)\n\t\tdevice_unregister(&ac97->dev);\n\treturn 0;\n}\n\n \nstatic const struct snd_ac97_build_ops null_build_ops;\n\n#ifdef CONFIG_SND_AC97_POWER_SAVE\nstatic void do_update_power(struct work_struct *work)\n{\n\tupdate_power_regs(\n\t\tcontainer_of(work, struct snd_ac97, power_work.work));\n}\n#endif\n\n \nint snd_ac97_mixer(struct snd_ac97_bus *bus, struct snd_ac97_template *template, struct snd_ac97 **rac97)\n{\n\tint err;\n\tstruct snd_ac97 *ac97;\n\tstruct snd_card *card;\n\tchar name[64];\n\tunsigned long end_time;\n\tunsigned int reg;\n\tconst struct ac97_codec_id *pid;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_ac97_dev_free,\n\t\t.dev_register =\tsnd_ac97_dev_register,\n\t\t.dev_disconnect =\tsnd_ac97_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!bus || !template || !rac97))\n\t\treturn -EINVAL;\n\t*rac97 = NULL;\n\tif (snd_BUG_ON(template->num >= 4))\n\t\treturn -EINVAL;\n\tif (bus->codec[template->num])\n\t\treturn -EBUSY;\n\n\tcard = bus->card;\n\tac97 = kzalloc(sizeof(*ac97), GFP_KERNEL);\n\tif (ac97 == NULL)\n\t\treturn -ENOMEM;\n\tac97->private_data = template->private_data;\n\tac97->private_free = template->private_free;\n\tac97->bus = bus;\n\tac97->pci = template->pci;\n\tac97->num = template->num;\n\tac97->addr = template->addr;\n\tac97->scaps = template->scaps;\n\tac97->res_table = template->res_table;\n\tbus->codec[ac97->num] = ac97;\n\tmutex_init(&ac97->reg_mutex);\n\tmutex_init(&ac97->page_mutex);\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\tINIT_DELAYED_WORK(&ac97->power_work, do_update_power);\n#endif\n\n#ifdef CONFIG_PCI\n\tif (ac97->pci) {\n\t\tpci_read_config_word(ac97->pci, PCI_SUBSYSTEM_VENDOR_ID, &ac97->subsystem_vendor);\n\t\tpci_read_config_word(ac97->pci, PCI_SUBSYSTEM_ID, &ac97->subsystem_device);\n\t}\n#endif\n\tif (bus->ops->reset) {\n\t\tbus->ops->reset(ac97);\n\t\tgoto __access_ok;\n\t}\n\n\tac97->id = snd_ac97_read(ac97, AC97_VENDOR_ID1) << 16;\n\tac97->id |= snd_ac97_read(ac97, AC97_VENDOR_ID2);\n\tif (ac97->id && ac97->id != (unsigned int)-1) {\n\t\tpid = look_for_codec_id(snd_ac97_codec_ids, ac97->id);\n\t\tif (pid && (pid->flags & AC97_DEFAULT_POWER_OFF))\n\t\t\tgoto __access_ok;\n\t}\n\n\t \n\tif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO))\n\t\tsnd_ac97_write(ac97, AC97_RESET, 0);\n\tif (!(ac97->scaps & AC97_SCAP_SKIP_MODEM))\n\t\tsnd_ac97_write(ac97, AC97_EXTENDED_MID, 0);\n\tif (bus->ops->wait)\n\t\tbus->ops->wait(ac97);\n\telse {\n\t\tudelay(50);\n\t\tif (ac97->scaps & AC97_SCAP_SKIP_AUDIO)\n\t\t\terr = ac97_reset_wait(ac97, msecs_to_jiffies(500), 1);\n\t\telse {\n\t\t\terr = ac97_reset_wait(ac97, msecs_to_jiffies(500), 0);\n\t\t\tif (err < 0)\n\t\t\t\terr = ac97_reset_wait(ac97,\n\t\t\t\t\t\t      msecs_to_jiffies(500), 1);\n\t\t}\n\t\tif (err < 0) {\n\t\t\tac97_warn(ac97, \"AC'97 %d does not respond - RESET\\n\",\n\t\t\t\t ac97->num);\n\t\t\t \n\t\t}\n\t}\n      __access_ok:\n\tac97->id = snd_ac97_read(ac97, AC97_VENDOR_ID1) << 16;\n\tac97->id |= snd_ac97_read(ac97, AC97_VENDOR_ID2);\n\tif (! (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) &&\n\t    (ac97->id == 0x00000000 || ac97->id == 0xffffffff)) {\n\t\tac97_err(ac97,\n\t\t\t \"AC'97 %d access is not valid [0x%x], removing mixer.\\n\",\n\t\t\t ac97->num, ac97->id);\n\t\tsnd_ac97_free(ac97);\n\t\treturn -EIO;\n\t}\n\tpid = look_for_codec_id(snd_ac97_codec_ids, ac97->id);\n\tif (pid)\n\t\tac97->flags |= pid->flags;\n\t\n\t \n\tif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO) && !(ac97->scaps & AC97_SCAP_AUDIO)) {\n\t\t \n\t\tsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a06);\n\t\terr = snd_ac97_read(ac97, AC97_REC_GAIN);\n\t\tif ((err & 0x7fff) == 0x0a06)\n\t\t\tac97->scaps |= AC97_SCAP_AUDIO;\n\t}\n\tif (ac97->scaps & AC97_SCAP_AUDIO) {\n\t\tac97->caps = snd_ac97_read(ac97, AC97_RESET);\n\t\tac97->ext_id = snd_ac97_read(ac97, AC97_EXTENDED_ID);\n\t\tif (ac97->ext_id == 0xffff)\t \n\t\t\tac97->ext_id = 0;\n\t}\n\n\t \n\tif (!(ac97->scaps & AC97_SCAP_SKIP_MODEM) && !(ac97->scaps & AC97_SCAP_MODEM)) {\n\t\tac97->ext_mid = snd_ac97_read(ac97, AC97_EXTENDED_MID);\n\t\tif (ac97->ext_mid == 0xffff)\t \n\t\t\tac97->ext_mid = 0;\n\t\tif (ac97->ext_mid & 1)\n\t\t\tac97->scaps |= AC97_SCAP_MODEM;\n\t}\n\n\tif (!ac97_is_audio(ac97) && !ac97_is_modem(ac97)) {\n\t\tif (!(ac97->scaps & (AC97_SCAP_SKIP_AUDIO|AC97_SCAP_SKIP_MODEM)))\n\t\t\tac97_err(ac97,\n\t\t\t\t \"AC'97 %d access error (not audio or modem codec)\\n\",\n\t\t\t\t ac97->num);\n\t\tsnd_ac97_free(ac97);\n\t\treturn -EACCES;\n\t}\n\n\tif (bus->ops->reset) \n\t\tgoto __ready_ok;\n\n\t \n\tif (ac97_is_audio(ac97)) {\n\t\t \n\t\tsnd_ac97_write_cache(ac97, AC97_POWERDOWN, 0);\n\t\tif (! (ac97->flags & AC97_DEFAULT_POWER_OFF)) {\n\t\t\tsnd_ac97_write_cache(ac97, AC97_RESET, 0);  \n\t\t\tudelay(100);\n\t\t\tsnd_ac97_write_cache(ac97, AC97_POWERDOWN, 0);\n\t\t}\n\t\t \n\t\tsnd_ac97_write_cache(ac97, AC97_GENERAL_PURPOSE, 0);\n\t\tend_time = jiffies + msecs_to_jiffies(5000);\n\t\tdo {\n\t\t\tif ((snd_ac97_read(ac97, AC97_POWERDOWN) & 0x0f) == 0x0f)\n\t\t\t\tgoto __ready_ok;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tac97_warn(ac97,\n\t\t\t  \"AC'97 %d analog subsections not ready\\n\", ac97->num);\n\t}\n\n\t \n\tif (ac97_is_modem(ac97)) {\n\t\tunsigned char tmp;\n\n\t\t \n\t\t \n\t\ttmp = AC97_MEA_GPIO;\n\t\tif (ac97->ext_mid & AC97_MEI_LINE1) {\n\t\t\tsnd_ac97_write_cache(ac97, AC97_LINE1_RATE, 8000);\n\t\t\ttmp |= AC97_MEA_ADC1 | AC97_MEA_DAC1;\n\t\t}\n\t\tif (ac97->ext_mid & AC97_MEI_LINE2) {\n\t\t\tsnd_ac97_write_cache(ac97, AC97_LINE2_RATE, 8000);\n\t\t\ttmp |= AC97_MEA_ADC2 | AC97_MEA_DAC2;\n\t\t}\n\t\tif (ac97->ext_mid & AC97_MEI_HANDSET) {\n\t\t\tsnd_ac97_write_cache(ac97, AC97_HANDSET_RATE, 8000);\n\t\t\ttmp |= AC97_MEA_HADC | AC97_MEA_HDAC;\n\t\t}\n\t\tsnd_ac97_write_cache(ac97, AC97_EXTENDED_MSTATUS, 0);\n\t\tudelay(100);\n\t\t \n\t\tsnd_ac97_write_cache(ac97, AC97_EXTENDED_MSTATUS, 0);\n\t\tend_time = jiffies + msecs_to_jiffies(100);\n\t\tdo {\n\t\t\tif ((snd_ac97_read(ac97, AC97_EXTENDED_MSTATUS) & tmp) == tmp)\n\t\t\t\tgoto __ready_ok;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tac97_warn(ac97,\n\t\t\t  \"MC'97 %d converters and GPIO not ready (0x%x)\\n\",\n\t\t\t  ac97->num,\n\t\t\t  snd_ac97_read(ac97, AC97_EXTENDED_MSTATUS));\n\t}\n\t\n      __ready_ok:\n\tif (ac97_is_audio(ac97))\n\t\tac97->addr = (ac97->ext_id & AC97_EI_ADDR_MASK) >> AC97_EI_ADDR_SHIFT;\n\telse\n\t\tac97->addr = (ac97->ext_mid & AC97_MEI_ADDR_MASK) >> AC97_MEI_ADDR_SHIFT;\n\tif (ac97->ext_id & 0x01c9) {\t \n\t\treg = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);\n\t\treg |= ac97->ext_id & 0x01c0;  \n\t\tif (! bus->no_vra)\n\t\t\treg |= ac97->ext_id & 0x0009;  \n\t\tsnd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);\n\t}\n\tif ((ac97->ext_id & AC97_EI_DRA) && bus->dra) {\n\t\t \n\t\tsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, AC97_GP_DRSS_MASK, AC97_GP_DRSS_78);\n\t\tif ((snd_ac97_read(ac97, AC97_GENERAL_PURPOSE) & AC97_GP_DRSS_MASK) == AC97_GP_DRSS_78)\n\t\t\tac97->flags |= AC97_DOUBLE_RATE;\n\t\t \n\t\tsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, AC97_GP_DRSS_MASK, 0);\n\t}\n\tif (ac97->ext_id & AC97_EI_VRA) {\t \n\t\tsnd_ac97_determine_rates(ac97, AC97_PCM_FRONT_DAC_RATE, 0, &ac97->rates[AC97_RATES_FRONT_DAC]);\n\t\tsnd_ac97_determine_rates(ac97, AC97_PCM_LR_ADC_RATE, 0, &ac97->rates[AC97_RATES_ADC]);\n\t} else {\n\t\tac97->rates[AC97_RATES_FRONT_DAC] = SNDRV_PCM_RATE_48000;\n\t\tif (ac97->flags & AC97_DOUBLE_RATE)\n\t\t\tac97->rates[AC97_RATES_FRONT_DAC] |= SNDRV_PCM_RATE_96000;\n\t\tac97->rates[AC97_RATES_ADC] = SNDRV_PCM_RATE_48000;\n\t}\n\tif (ac97->ext_id & AC97_EI_SPDIF) {\n\t\t \n\t\tac97->rates[AC97_RATES_SPDIF] = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_32000;\n\t}\n\tif (ac97->ext_id & AC97_EI_VRM) {\t \n\t\tsnd_ac97_determine_rates(ac97, AC97_PCM_MIC_ADC_RATE, 0, &ac97->rates[AC97_RATES_MIC_ADC]);\n\t} else {\n\t\tac97->rates[AC97_RATES_MIC_ADC] = SNDRV_PCM_RATE_48000;\n\t}\n\tif (ac97->ext_id & AC97_EI_SDAC) {\t \n\t\tsnd_ac97_determine_rates(ac97, AC97_PCM_SURR_DAC_RATE, AC97_PCM_FRONT_DAC_RATE, &ac97->rates[AC97_RATES_SURR_DAC]);\n\t\tac97->scaps |= AC97_SCAP_SURROUND_DAC;\n\t}\n\tif (ac97->ext_id & AC97_EI_LDAC) {\t \n\t\tsnd_ac97_determine_rates(ac97, AC97_PCM_LFE_DAC_RATE, AC97_PCM_FRONT_DAC_RATE, &ac97->rates[AC97_RATES_LFE_DAC]);\n\t\tac97->scaps |= AC97_SCAP_CENTER_LFE_DAC;\n\t}\n\t \n\tif (bus->ops->init)\n\t\tbus->ops->init(ac97);\n\tsnd_ac97_get_name(ac97, ac97->id, name, !ac97_is_audio(ac97));\n\tsnd_ac97_get_name(NULL, ac97->id, name, !ac97_is_audio(ac97));   \n\tif (! ac97->build_ops)\n\t\tac97->build_ops = &null_build_ops;\n\n\tif (ac97_is_audio(ac97)) {\n\t\tchar comp[16];\n\t\tif (card->mixername[0] == '\\0') {\n\t\t\tstrcpy(card->mixername, name);\n\t\t} else {\n\t\t\tif (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {\n\t\t\t\tstrcat(card->mixername, \",\");\n\t\t\t\tstrcat(card->mixername, name);\n\t\t\t}\n\t\t}\n\t\tsprintf(comp, \"AC97a:%08x\", ac97->id);\n\t\terr = snd_component_add(card, comp);\n\t\tif (err < 0) {\n\t\t\tsnd_ac97_free(ac97);\n\t\t\treturn err;\n\t\t}\n\t\tif (snd_ac97_mixer_build(ac97) < 0) {\n\t\t\tsnd_ac97_free(ac97);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (ac97_is_modem(ac97)) {\n\t\tchar comp[16];\n\t\tif (card->mixername[0] == '\\0') {\n\t\t\tstrcpy(card->mixername, name);\n\t\t} else {\n\t\t\tif (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {\n\t\t\t\tstrcat(card->mixername, \",\");\n\t\t\t\tstrcat(card->mixername, name);\n\t\t\t}\n\t\t}\n\t\tsprintf(comp, \"AC97m:%08x\", ac97->id);\n\t\terr = snd_component_add(card, comp);\n\t\tif (err < 0) {\n\t\t\tsnd_ac97_free(ac97);\n\t\t\treturn err;\n\t\t}\n\t\tif (snd_ac97_modem_build(card, ac97) < 0) {\n\t\t\tsnd_ac97_free(ac97);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (ac97_is_audio(ac97))\n\t\tupdate_power_regs(ac97);\n\tsnd_ac97_proc_init(ac97);\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, ac97, &ops);\n\tif (err < 0) {\n\t\tsnd_ac97_free(ac97);\n\t\treturn err;\n\t}\n\t*rac97 = ac97;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_mixer);\n\n \nstatic void snd_ac97_powerdown(struct snd_ac97 *ac97)\n{\n\tunsigned short power;\n\n\tif (ac97_is_audio(ac97)) {\n\t\t \n\t\tsnd_ac97_write(ac97, AC97_MASTER, 0x9f9f);\n\t\tsnd_ac97_write(ac97, AC97_HEADPHONE, 0x9f9f);\n\t}\n\n\t \n\tpower = ac97->regs[AC97_EXTENDED_STATUS];\n\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\n\t\tpower |= AC97_EA_PRJ;\n\tif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\n\t\tpower |= AC97_EA_PRI | AC97_EA_PRK;\n\tpower |= AC97_EA_PRL;\n\tsnd_ac97_write(ac97, AC97_EXTENDED_STATUS, power);\n\n\t \n\tif (ac97->scaps & AC97_SCAP_INV_EAPD)\n\t\tpower = ac97->regs[AC97_POWERDOWN] & ~AC97_PD_EAPD;\n\telse if (! (ac97->scaps & AC97_SCAP_EAPD_LED))\n\t\tpower = ac97->regs[AC97_POWERDOWN] | AC97_PD_EAPD;\n\tpower |= AC97_PD_PR6;\t \n\tpower |= AC97_PD_PR0 | AC97_PD_PR1;\t \n\tsnd_ac97_write(ac97, AC97_POWERDOWN, power);\n\tudelay(100);\n\tpower |= AC97_PD_PR2;\t \n\tsnd_ac97_write(ac97, AC97_POWERDOWN, power);\n\tif (ac97_is_power_save_mode(ac97)) {\n\t\tpower |= AC97_PD_PR3;\t \n\t\tsnd_ac97_write(ac97, AC97_POWERDOWN, power);\n\t\tudelay(100);\n\t\t \n\t\t \n\t\tpower |= AC97_PD_PR4 | AC97_PD_PR5;\n\t\tsnd_ac97_write(ac97, AC97_POWERDOWN, power);\n\t}\n}\n\n\nstruct ac97_power_reg {\n\tunsigned short reg;\n\tunsigned short power_reg;\n\tunsigned short mask;\n};\n\nenum { PWIDX_ADC, PWIDX_FRONT, PWIDX_CLFE, PWIDX_SURR, PWIDX_MIC, PWIDX_SIZE };\n\nstatic const struct ac97_power_reg power_regs[PWIDX_SIZE] = {\n\t[PWIDX_ADC] = { AC97_PCM_LR_ADC_RATE, AC97_POWERDOWN, AC97_PD_PR0},\n\t[PWIDX_FRONT] = { AC97_PCM_FRONT_DAC_RATE, AC97_POWERDOWN, AC97_PD_PR1},\n\t[PWIDX_CLFE] = { AC97_PCM_LFE_DAC_RATE, AC97_EXTENDED_STATUS,\n\t\t\t AC97_EA_PRI | AC97_EA_PRK},\n\t[PWIDX_SURR] = { AC97_PCM_SURR_DAC_RATE, AC97_EXTENDED_STATUS,\n\t\t\t AC97_EA_PRJ},\n\t[PWIDX_MIC] = { AC97_PCM_MIC_ADC_RATE, AC97_EXTENDED_STATUS,\n\t\t\tAC97_EA_PRL},\n};\n\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n \nint snd_ac97_update_power(struct snd_ac97 *ac97, int reg, int powerup)\n{\n\tint i;\n\n\tif (! ac97)\n\t\treturn 0;\n\n\tif (reg) {\n\t\t \n\t\tif (reg == AC97_SPDIF)\n\t\t\treg = AC97_PCM_FRONT_DAC_RATE;\n\t\tfor (i = 0; i < PWIDX_SIZE; i++) {\n\t\t\tif (power_regs[i].reg == reg) {\n\t\t\t\tif (powerup)\n\t\t\t\t\tac97->power_up |= (1 << i);\n\t\t\t\telse\n\t\t\t\t\tac97->power_up &= ~(1 << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ac97_is_power_save_mode(ac97) && !powerup)\n\t\t \n\t\tschedule_delayed_work(&ac97->power_work,\n\t\t\t\t      msecs_to_jiffies(power_save * 1000));\n\telse {\n\t\tcancel_delayed_work(&ac97->power_work);\n\t\tupdate_power_regs(ac97);\n\t}\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_update_power);\n#endif  \n\nstatic void update_power_regs(struct snd_ac97 *ac97)\n{\n\tunsigned int power_up, bits;\n\tint i;\n\n\tpower_up = (1 << PWIDX_FRONT) | (1 << PWIDX_ADC);\n\tpower_up |= (1 << PWIDX_MIC);\n\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\n\t\tpower_up |= (1 << PWIDX_SURR);\n\tif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\n\t\tpower_up |= (1 << PWIDX_CLFE);\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\tif (ac97_is_power_save_mode(ac97))\n\t\tpower_up = ac97->power_up;\n#endif\n\tif (power_up) {\n\t\tif (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2) {\n\t\t\t \n\t\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\n\t\t\t\t\t     AC97_PD_PR3, 0);\n\t\t\tmsleep(1);\n\t\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\n\t\t\t\t\t     AC97_PD_PR2, 0);\n\t\t}\n\t}\n\tfor (i = 0; i < PWIDX_SIZE; i++) {\n\t\tif (power_up & (1 << i))\n\t\t\tbits = 0;\n\t\telse\n\t\t\tbits = power_regs[i].mask;\n\t\tsnd_ac97_update_bits(ac97, power_regs[i].power_reg,\n\t\t\t\t     power_regs[i].mask, bits);\n\t}\n\tif (! power_up) {\n\t\tif (! (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2)) {\n\t\t\t \n\t\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\n\t\t\t\t\t     AC97_PD_PR2, AC97_PD_PR2);\n\t\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\n\t\t\t\t\t     AC97_PD_PR3, AC97_PD_PR3);\n\t\t}\n\t}\n}\n\n\n#ifdef CONFIG_PM\n \nvoid snd_ac97_suspend(struct snd_ac97 *ac97)\n{\n\tif (! ac97)\n\t\treturn;\n\tif (ac97->build_ops->suspend)\n\t\tac97->build_ops->suspend(ac97);\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\tcancel_delayed_work_sync(&ac97->power_work);\n#endif\n\tsnd_ac97_powerdown(ac97);\n}\n\nEXPORT_SYMBOL(snd_ac97_suspend);\n\n \nstatic void snd_ac97_restore_status(struct snd_ac97 *ac97)\n{\n\tint i;\n\n\tfor (i = 2; i < 0x7c ; i += 2) {\n\t\tif (i == AC97_POWERDOWN || i == AC97_EXTENDED_ID)\n\t\t\tcontinue;\n\t\t \n\t\tif (test_bit(i, ac97->reg_accessed)) {\n\t\t\tsnd_ac97_write(ac97, i, ac97->regs[i]);\n\t\t\tsnd_ac97_read(ac97, i);\n\t\t}\n\t}\n}\n\n \nstatic void snd_ac97_restore_iec958(struct snd_ac97 *ac97)\n{\n\tif (ac97->ext_id & AC97_EI_SPDIF) {\n\t\tif (ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_SPDIF) {\n\t\t\t \n\t\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\n\t\t\tsnd_ac97_write(ac97, AC97_EXTENDED_STATUS, ac97->regs[AC97_EXTENDED_STATUS]);\n\t\t\tif (ac97->flags & AC97_CS_SPDIF)\n\t\t\t\tsnd_ac97_write(ac97, AC97_CSR_SPDIF, ac97->regs[AC97_CSR_SPDIF]);\n\t\t\telse\n\t\t\t\tsnd_ac97_write(ac97, AC97_SPDIF, ac97->regs[AC97_SPDIF]);\n\t\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);  \n\t\t}\n\t}\n}\n\n \nvoid snd_ac97_resume(struct snd_ac97 *ac97)\n{\n\tunsigned long end_time;\n\n\tif (! ac97)\n\t\treturn;\n\n\tif (ac97->bus->ops->reset) {\n\t\tac97->bus->ops->reset(ac97);\n\t\tgoto  __reset_ready;\n\t}\n\n\tsnd_ac97_write(ac97, AC97_POWERDOWN, 0);\n\tif (! (ac97->flags & AC97_DEFAULT_POWER_OFF)) {\n\t\tif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO))\n\t\t\tsnd_ac97_write(ac97, AC97_RESET, 0);\n\t\telse if (!(ac97->scaps & AC97_SCAP_SKIP_MODEM))\n\t\t\tsnd_ac97_write(ac97, AC97_EXTENDED_MID, 0);\n\t\tudelay(100);\n\t\tsnd_ac97_write(ac97, AC97_POWERDOWN, 0);\n\t}\n\tsnd_ac97_write(ac97, AC97_GENERAL_PURPOSE, 0);\n\n\tsnd_ac97_write(ac97, AC97_POWERDOWN, ac97->regs[AC97_POWERDOWN]);\n\tif (ac97_is_audio(ac97)) {\n\t\tac97->bus->ops->write(ac97, AC97_MASTER, 0x8101);\n\t\tend_time = jiffies + msecs_to_jiffies(100);\n\t\tdo {\n\t\t\tif (snd_ac97_read(ac97, AC97_MASTER) == 0x8101)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\t \n\t\tac97->bus->ops->write(ac97, AC97_MASTER, AC97_MUTE_MASK_MONO);\n\t\tif (snd_ac97_read(ac97, AC97_MASTER) != AC97_MUTE_MASK_MONO)\n\t\t\tmsleep(250);\n\t} else {\n\t\tend_time = jiffies + msecs_to_jiffies(100);\n\t\tdo {\n\t\t\tunsigned short val = snd_ac97_read(ac97, AC97_EXTENDED_MID);\n\t\t\tif (val != 0xffff && (val & 1) != 0)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t}\n__reset_ready:\n\n\tif (ac97->bus->ops->init)\n\t\tac97->bus->ops->init(ac97);\n\n\tif (ac97->build_ops->resume)\n\t\tac97->build_ops->resume(ac97);\n\telse {\n\t\tsnd_ac97_restore_status(ac97);\n\t\tsnd_ac97_restore_iec958(ac97);\n\t}\n}\n\nEXPORT_SYMBOL(snd_ac97_resume);\n#endif\n\n\n \nstatic void set_ctl_name(char *dst, const char *src, const char *suffix)\n{\n\tconst size_t msize = SNDRV_CTL_ELEM_ID_NAME_MAXLEN;\n\n\tif (suffix) {\n\t\tif (snprintf(dst, msize, \"%s %s\", src, suffix) >= msize)\n\t\t\tpr_warn(\"ALSA: AC97 control name '%s %s' truncated to '%s'\\n\",\n\t\t\t\tsrc, suffix, dst);\n\t} else {\n\t\tif (strscpy(dst, src, msize) < 0)\n\t\t\tpr_warn(\"ALSA: AC97 control name '%s' truncated to '%s'\\n\",\n\t\t\t\tsrc, dst);\n\t}\n}\n\n \nstatic int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,\n\t\t\t       const char *suffix)\n{\n\tstruct snd_ctl_elem_id id;\n\tmemset(&id, 0, sizeof(id));\n\tset_ctl_name(id.name, name, suffix);\n\tid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\treturn snd_ctl_remove_id(ac97->bus->card, &id);\n}\n\nstatic struct snd_kcontrol *ctl_find(struct snd_ac97 *ac97, const char *name, const char *suffix)\n{\n\tstruct snd_ctl_elem_id sid;\n\tmemset(&sid, 0, sizeof(sid));\n\tset_ctl_name(sid.name, name, suffix);\n\tsid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\treturn snd_ctl_find_id(ac97->bus->card, &sid);\n}\n\n \nstatic int snd_ac97_rename_ctl(struct snd_ac97 *ac97, const char *src,\n\t\t\t       const char *dst, const char *suffix)\n{\n\tstruct snd_kcontrol *kctl = ctl_find(ac97, src, suffix);\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tif (kctl) {\n\t\tset_ctl_name(name, dst, suffix);\n\t\tsnd_ctl_rename(ac97->bus->card, kctl, name);\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n \nstatic void snd_ac97_rename_vol_ctl(struct snd_ac97 *ac97, const char *src,\n\t\t\t\t    const char *dst)\n{\n\tsnd_ac97_rename_ctl(ac97, src, dst, \"Switch\");\n\tsnd_ac97_rename_ctl(ac97, src, dst, \"Volume\");\n}\n\n \nstatic int snd_ac97_swap_ctl(struct snd_ac97 *ac97, const char *s1,\n\t\t\t     const char *s2, const char *suffix)\n{\n\tstruct snd_kcontrol *kctl1, *kctl2;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\n\tkctl1 = ctl_find(ac97, s1, suffix);\n\tkctl2 = ctl_find(ac97, s2, suffix);\n\tif (kctl1 && kctl2) {\n\t\tset_ctl_name(name, s2, suffix);\n\t\tsnd_ctl_rename(ac97->bus->card, kctl1, name);\n\n\t\tset_ctl_name(name, s1, suffix);\n\t\tsnd_ctl_rename(ac97->bus->card, kctl2, name);\n\n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n#if 1\n \nstatic int bind_hp_volsw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tint err = snd_ac97_put_volsw(kcontrol, ucontrol);\n\tif (err > 0) {\n\t\tunsigned long priv_saved = kcontrol->private_value;\n\t\tkcontrol->private_value = (kcontrol->private_value & ~0xff) | AC97_HEADPHONE;\n\t\tsnd_ac97_put_volsw(kcontrol, ucontrol);\n\t\tkcontrol->private_value = priv_saved;\n\t}\n\treturn err;\n}\n\n \nstatic int tune_hp_only(struct snd_ac97 *ac97)\n{\n\tstruct snd_kcontrol *msw = ctl_find(ac97, \"Master Playback Switch\", NULL);\n\tstruct snd_kcontrol *mvol = ctl_find(ac97, \"Master Playback Volume\", NULL);\n\tif (! msw || ! mvol)\n\t\treturn -ENOENT;\n\tmsw->put = bind_hp_volsw_put;\n\tmvol->put = bind_hp_volsw_put;\n\tsnd_ac97_remove_ctl(ac97, \"Headphone Playback\", \"Switch\");\n\tsnd_ac97_remove_ctl(ac97, \"Headphone Playback\", \"Volume\");\n\treturn 0;\n}\n\n#else\n \nstatic int tune_hp_only(struct snd_ac97 *ac97)\n{\n\tif (ctl_find(ac97, \"Headphone Playback Switch\", NULL) == NULL)\n\t\treturn -ENOENT;\n\tsnd_ac97_remove_ctl(ac97, \"Master Playback\", \"Switch\");\n\tsnd_ac97_remove_ctl(ac97, \"Master Playback\", \"Volume\");\n\tsnd_ac97_rename_vol_ctl(ac97, \"Headphone Playback\", \"Master Playback\");\n\treturn 0;\n}\n#endif\n\n \nstatic int tune_swap_hp(struct snd_ac97 *ac97)\n{\n\tif (ctl_find(ac97, \"Headphone Playback Switch\", NULL) == NULL)\n\t\treturn -ENOENT;\n\tsnd_ac97_rename_vol_ctl(ac97, \"Master Playback\", \"Line-Out Playback\");\n\tsnd_ac97_rename_vol_ctl(ac97, \"Headphone Playback\", \"Master Playback\");\n\treturn 0;\n}\n\n \nstatic int tune_swap_surround(struct snd_ac97 *ac97)\n{\n\tif (snd_ac97_swap_ctl(ac97, \"Master Playback\", \"Surround Playback\", \"Switch\") ||\n\t    snd_ac97_swap_ctl(ac97, \"Master Playback\", \"Surround Playback\", \"Volume\"))\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\n \nstatic int tune_ad_sharing(struct snd_ac97 *ac97)\n{\n\tunsigned short scfg;\n\tif ((ac97->id & 0xffffff00) != 0x41445300) {\n\t\tac97_err(ac97, \"ac97_quirk AD_SHARING is only for AD codecs\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tscfg = snd_ac97_read(ac97, AC97_AD_SERIAL_CFG);\n\tsnd_ac97_write_cache(ac97, AC97_AD_SERIAL_CFG, scfg | 0x0200);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_ac97_alc_jack_detect = \nAC97_SINGLE(\"Jack Detect\", AC97_ALC650_CLOCK, 5, 1, 0);\n\n \nstatic int tune_alc_jack(struct snd_ac97 *ac97)\n{\n\tif ((ac97->id & 0xffffff00) != 0x414c4700) {\n\t\tac97_err(ac97,\n\t\t\t \"ac97_quirk ALC_JACK is only for Realtek codecs\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsnd_ac97_update_bits(ac97, 0x7a, 0x20, 0x20);  \n\tsnd_ac97_update_bits(ac97, 0x7a, 0x01, 0x01);  \n\tif (ac97->id == AC97_ID_ALC658D)\n\t\tsnd_ac97_update_bits(ac97, 0x74, 0x0800, 0x0800);\n\treturn snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&snd_ac97_alc_jack_detect, ac97));\n}\n\n \nstatic int tune_inv_eapd(struct snd_ac97 *ac97)\n{\n\tstruct snd_kcontrol *kctl = ctl_find(ac97, \"External Amplifier\", NULL);\n\tif (! kctl)\n\t\treturn -ENOENT;\n\tset_inv_eapd(ac97, kctl);\n\treturn 0;\n}\n\nstatic int master_mute_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tint err = snd_ac97_put_volsw(kcontrol, ucontrol);\n\tif (err > 0) {\n\t\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\t\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\t\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\t\tunsigned short mask;\n\t\tif (shift != rshift)\n\t\t\tmask = AC97_MUTE_MASK_STEREO;\n\t\telse\n\t\t\tmask = AC97_MUTE_MASK_MONO;\n\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN, AC97_PD_EAPD,\n\t\t\t\t     (ac97->regs[AC97_MASTER] & mask) == mask ?\n\t\t\t\t     AC97_PD_EAPD : 0);\n\t}\n\treturn err;\n}\n\n \nstatic int tune_mute_led(struct snd_ac97 *ac97)\n{\n\tstruct snd_kcontrol *msw = ctl_find(ac97, \"Master Playback Switch\", NULL);\n\tif (! msw)\n\t\treturn -ENOENT;\n\tmsw->put = master_mute_sw_put;\n\tsnd_ac97_remove_ctl(ac97, \"External Amplifier\", NULL);\n\tsnd_ac97_update_bits(\n\t\tac97, AC97_POWERDOWN,\n\t\tAC97_PD_EAPD, AC97_PD_EAPD  \n\t);\n\tac97->scaps |= AC97_SCAP_EAPD_LED;\n\treturn 0;\n}\n\nstatic int hp_master_mute_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint err = bind_hp_volsw_put(kcontrol, ucontrol);\n\tif (err > 0) {\n\t\tstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\n\t\tint shift = (kcontrol->private_value >> 8) & 0x0f;\n\t\tint rshift = (kcontrol->private_value >> 12) & 0x0f;\n\t\tunsigned short mask;\n\t\tif (shift != rshift)\n\t\t\tmask = AC97_MUTE_MASK_STEREO;\n\t\telse\n\t\t\tmask = AC97_MUTE_MASK_MONO;\n\t\tsnd_ac97_update_bits(ac97, AC97_POWERDOWN, AC97_PD_EAPD,\n\t\t\t\t     (ac97->regs[AC97_MASTER] & mask) == mask ?\n\t\t\t\t     AC97_PD_EAPD : 0);\n\t}\n\treturn err;\n}\n\nstatic int tune_hp_mute_led(struct snd_ac97 *ac97)\n{\n\tstruct snd_kcontrol *msw = ctl_find(ac97, \"Master Playback Switch\", NULL);\n\tstruct snd_kcontrol *mvol = ctl_find(ac97, \"Master Playback Volume\", NULL);\n\tif (! msw || ! mvol)\n\t\treturn -ENOENT;\n\tmsw->put = hp_master_mute_sw_put;\n\tmvol->put = bind_hp_volsw_put;\n\tsnd_ac97_remove_ctl(ac97, \"External Amplifier\", NULL);\n\tsnd_ac97_remove_ctl(ac97, \"Headphone Playback\", \"Switch\");\n\tsnd_ac97_remove_ctl(ac97, \"Headphone Playback\", \"Volume\");\n\tsnd_ac97_update_bits(\n\t\tac97, AC97_POWERDOWN,\n\t\tAC97_PD_EAPD, AC97_PD_EAPD  \n\t);\n\treturn 0;\n}\n\nstruct quirk_table {\n\tconst char *name;\n\tint (*func)(struct snd_ac97 *);\n};\n\nstatic const struct quirk_table applicable_quirks[] = {\n\t{ \"none\", NULL },\n\t{ \"hp_only\", tune_hp_only },\n\t{ \"swap_hp\", tune_swap_hp },\n\t{ \"swap_surround\", tune_swap_surround },\n\t{ \"ad_sharing\", tune_ad_sharing },\n\t{ \"alc_jack\", tune_alc_jack },\n\t{ \"inv_eapd\", tune_inv_eapd },\n\t{ \"mute_led\", tune_mute_led },\n\t{ \"hp_mute_led\", tune_hp_mute_led },\n};\n\n \nstatic int apply_quirk(struct snd_ac97 *ac97, int type)\n{\n\tif (type <= 0)\n\t\treturn 0;\n\telse if (type >= ARRAY_SIZE(applicable_quirks))\n\t\treturn -EINVAL;\n\tif (applicable_quirks[type].func)\n\t\treturn applicable_quirks[type].func(ac97);\n\treturn 0;\n}\n\n \nstatic int apply_quirk_str(struct snd_ac97 *ac97, const char *typestr)\n{\n\tint i;\n\tconst struct quirk_table *q;\n\n\tfor (i = 0; i < ARRAY_SIZE(applicable_quirks); i++) {\n\t\tq = &applicable_quirks[i];\n\t\tif (q->name && ! strcmp(typestr, q->name))\n\t\t\treturn apply_quirk(ac97, i);\n\t}\n\t \n\tif (*typestr >= '0' && *typestr <= '9')\n\t\treturn apply_quirk(ac97, (int)simple_strtoul(typestr, NULL, 10));\n\treturn -EINVAL;\n}\n\n \n\nint snd_ac97_tune_hardware(struct snd_ac97 *ac97,\n\t\t\t   const struct ac97_quirk *quirk, const char *override)\n{\n\tint result;\n\n\t \n\tif (override && strcmp(override, \"-1\") && strcmp(override, \"default\")) {\n\t\tresult = apply_quirk_str(ac97, override);\n\t\tif (result < 0)\n\t\t\tac97_err(ac97, \"applying quirk type %s failed (%d)\\n\",\n\t\t\t\t override, result);\n\t\treturn result;\n\t}\n\n\tif (! quirk)\n\t\treturn -EINVAL;\n\n\tfor (; quirk->subvendor; quirk++) {\n\t\tif (quirk->subvendor != ac97->subsystem_vendor)\n\t\t\tcontinue;\n\t\tif ((! quirk->mask && quirk->subdevice == ac97->subsystem_device) ||\n\t\t    quirk->subdevice == (quirk->mask & ac97->subsystem_device)) {\n\t\t\tif (quirk->codec_id && quirk->codec_id != ac97->id)\n\t\t\t\tcontinue;\n\t\t\tac97_dbg(ac97, \"ac97 quirk for %s (%04x:%04x)\\n\",\n\t\t\t\t quirk->name, ac97->subsystem_vendor,\n\t\t\t\t ac97->subsystem_device);\n\t\t\tresult = apply_quirk(ac97, quirk->type);\n\t\t\tif (result < 0)\n\t\t\t\tac97_err(ac97,\n\t\t\t\t\t \"applying quirk type %d for %s failed (%d)\\n\",\n\t\t\t\t\t quirk->type, quirk->name, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_tune_hardware);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}