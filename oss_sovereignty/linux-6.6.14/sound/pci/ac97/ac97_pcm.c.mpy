{
  "module_name": "ac97_pcm.c",
  "hash_id": "fa119a2ced072c7f925e6d0e96712cf3b03555c8c41bca6bbb96afef8965e568",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ac97/ac97_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include <sound/ac97_codec.h>\n#include <sound/asoundef.h>\n#include \"ac97_id.h\"\n#include \"ac97_local.h\"\n\n \n\nstatic const unsigned char rate_reg_tables[2][4][9] = {\n{\n   \n  {\n  \t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n  },\n  {\n  \t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n  },\n  {\n  \t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n  },\n  {\n  \t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\tAC97_PCM_SURR_DAC_RATE,\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\tAC97_PCM_LFE_DAC_RATE,\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n  },\n},\n{\n   \n  {\n  \t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\tAC97_PCM_FRONT_DAC_RATE,\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n  },\n  {\n\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n  },\n  {\n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n  },\n  {\n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n\t0xff,\t\t\t\t \n  }\n}};\n\n \nstatic const unsigned char rate_cregs[9] = {\n\tAC97_PCM_LR_ADC_RATE,\t \n\tAC97_PCM_LR_ADC_RATE,\t \n\t0xff,\t\t\t \n\tAC97_PCM_MIC_ADC_RATE,\t \n\t0xff,\t\t\t \n\t0xff,\t\t\t \n\t0xff,\t\t\t \n\t0xff,\t\t\t \n\t0xff,\t\t\t \n};\n\nstatic unsigned char get_slot_reg(struct ac97_pcm *pcm, unsigned short cidx,\n\t\t\t\t  unsigned short slot, int dbl)\n{\n\tif (slot < 3)\n\t\treturn 0xff;\n\tif (slot > 11)\n\t\treturn 0xff;\n\tif (pcm->spdif)\n\t\treturn AC97_SPDIF;  \n\tif (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn rate_reg_tables[dbl][pcm->r[dbl].rate_table[cidx]][slot - 3];\n\telse\n\t\treturn rate_cregs[slot - 3];\n}\n\nstatic int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)\n{\n\tunsigned short old, bits, reg, mask;\n\tunsigned int sbits;\n\n\tif (! (ac97->ext_id & AC97_EI_SPDIF))\n\t\treturn -ENODEV;\n\n\t \n\tif (ac97->flags & AC97_CS_SPDIF) {\n\t\tswitch (rate) {\n\t\tcase 48000: bits = 0; break;\n\t\tcase 44100: bits = 1 << AC97_SC_SPSR_SHIFT; break;\n\t\tdefault:  \n\t\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treg = AC97_CSR_SPDIF;\n\t\tmask = 1 << AC97_SC_SPSR_SHIFT;\n\t} else {\n\t\tif (ac97->id == AC97_ID_CM9739 && rate != 48000) {\n\t\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (rate) {\n\t\tcase 44100: bits = AC97_SC_SPSR_44K; break;\n\t\tcase 48000: bits = AC97_SC_SPSR_48K; break;\n\t\tcase 32000: bits = AC97_SC_SPSR_32K; break;\n\t\tdefault:  \n\t\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treg = AC97_SPDIF;\n\t\tmask = AC97_SC_SPSR_MASK;\n\t}\n\n\tmutex_lock(&ac97->reg_mutex);\n\told = snd_ac97_read(ac97, reg) & mask;\n\tif (old != bits) {\n\t\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\n\t\tsnd_ac97_update_bits_nolock(ac97, reg, mask, bits);\n\t\t \n\t\tsbits = ac97->spdif_status;\n\t\tif (sbits & IEC958_AES0_PROFESSIONAL) {\n\t\t\tsbits &= ~IEC958_AES0_PRO_FS;\n\t\t\tswitch (rate) {\n\t\t\tcase 44100: sbits |= IEC958_AES0_PRO_FS_44100; break;\n\t\t\tcase 48000: sbits |= IEC958_AES0_PRO_FS_48000; break;\n\t\t\tcase 32000: sbits |= IEC958_AES0_PRO_FS_32000; break;\n\t\t\t}\n\t\t} else {\n\t\t\tsbits &= ~(IEC958_AES3_CON_FS << 24);\n\t\t\tswitch (rate) {\n\t\t\tcase 44100: sbits |= IEC958_AES3_CON_FS_44100<<24; break;\n\t\t\tcase 48000: sbits |= IEC958_AES3_CON_FS_48000<<24; break;\n\t\t\tcase 32000: sbits |= IEC958_AES3_CON_FS_32000<<24; break;\n\t\t\t}\n\t\t}\n\t\tac97->spdif_status = sbits;\n\t}\n\tsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);\n\tmutex_unlock(&ac97->reg_mutex);\n\treturn 0;\n}\n\n \nint snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)\n{\n\tint dbl;\n\tunsigned int tmp;\n\t\n\tdbl = rate > 48000;\n\tif (dbl) {\n\t\tif (!(ac97->flags & AC97_DOUBLE_RATE))\n\t\t\treturn -EINVAL;\n\t\tif (reg != AC97_PCM_FRONT_DAC_RATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsnd_ac97_update_power(ac97, reg, 1);\n\tswitch (reg) {\n\tcase AC97_PCM_MIC_ADC_RATE:\n\t\tif ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)\t \n\t\t\tif (rate != 48000)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AC97_PCM_FRONT_DAC_RATE:\n\tcase AC97_PCM_LR_ADC_RATE:\n\t\tif ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRA) == 0)\t \n\t\t\tif (rate != 48000 && rate != 96000)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AC97_PCM_SURR_DAC_RATE:\n\t\tif (! (ac97->scaps & AC97_SCAP_SURROUND_DAC))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AC97_PCM_LFE_DAC_RATE:\n\t\tif (! (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AC97_SPDIF:\n\t\t \n\t\treturn set_spdif_rate(ac97, rate);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (dbl)\n\t\trate /= 2;\n\ttmp = (rate * ac97->bus->clock) / 48000;\n\tif (tmp > 65535)\n\t\treturn -EINVAL;\n\tif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)\n\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_DRA, dbl ? AC97_EA_DRA : 0);\n\tsnd_ac97_update(ac97, reg, tmp & 0xffff);\n\tsnd_ac97_read(ac97, reg);\n\tif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE) {\n\t\t \n\t\tsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE,\n\t\t\t\t     AC97_GP_DRSS_MASK,\n\t\t\t\t     dbl ? AC97_GP_DRSS_78 : 0);\n\t\tsnd_ac97_read(ac97, AC97_GENERAL_PURPOSE);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_set_rate);\n\nstatic unsigned short get_pslots(struct snd_ac97 *ac97, unsigned char *rate_table, unsigned short *spdif_slots)\n{\n\tif (!ac97_is_audio(ac97))\n\t\treturn 0;\n\tif (ac97_is_rev22(ac97) || ac97_can_amap(ac97)) {\n\t\tunsigned short slots = 0;\n\t\tif (ac97_is_rev22(ac97)) {\n\t\t\t \n\t\t\tu16 es;\n\t\t\tes = ac97->regs[AC97_EXTENDED_ID] &= ~AC97_EI_DACS_SLOT_MASK;\n\t\t\tswitch (ac97->addr) {\n\t\t\tcase 1:\n\t\t\tcase 2: es |= (1<<AC97_EI_DACS_SLOT_SHIFT); break;\n\t\t\tcase 3: es |= (2<<AC97_EI_DACS_SLOT_SHIFT); break;\n\t\t\t}\n\t\t\tsnd_ac97_write_cache(ac97, AC97_EXTENDED_ID, es);\n\t\t}\n\t\tswitch (ac97->addr) {\n\t\tcase 0:\n\t\t\tslots |= (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\n\t\t\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\n\t\t\t\tslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\n\t\t\tif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\n\t\t\t\tslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\n\t\t\tif (ac97->ext_id & AC97_EI_SPDIF) {\n\t\t\t\tif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\n\t\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);\n\t\t\t\telse if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\n\t\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\n\t\t\t\telse\n\t\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\n\t\t\t}\n\t\t\t*rate_table = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\n\t\t\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\n\t\t\t\tslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\n\t\t\tif (ac97->ext_id & AC97_EI_SPDIF) {\n\t\t\t\tif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\n\t\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\n\t\t\t\telse\n\t\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\n\t\t\t}\n\t\t\t*rate_table = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\n\t\t\tif (ac97->ext_id & AC97_EI_SPDIF)\n\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\n\t\t\t*rate_table = 2;\n\t\t\tbreak;\n\t\t}\n\t\treturn slots;\n\t} else {\n\t\tunsigned short slots;\n\t\tslots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\n\t\tif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\n\t\t\tslots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);\n\t\tif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\n\t\t\tslots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);\n\t\tif (ac97->ext_id & AC97_EI_SPDIF) {\n\t\t\tif (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))\n\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);\n\t\t\telse if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))\n\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);\n\t\t\telse\n\t\t\t\t*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);\n\t\t}\n\t\t*rate_table = 0;\n\t\treturn slots;\n\t}\n}\n\nstatic unsigned short get_cslots(struct snd_ac97 *ac97)\n{\n\tunsigned short slots;\n\n\tif (!ac97_is_audio(ac97))\n\t\treturn 0;\n\tslots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);\n\tslots |= (1<<AC97_SLOT_MIC);\n\treturn slots;\n}\n\nstatic unsigned int get_rates(struct ac97_pcm *pcm, unsigned int cidx, unsigned short slots, int dbl)\n{\n\tint i, idx;\n\tunsigned int rates = ~0;\n\tunsigned char reg;\n\n\tfor (i = 3; i < 12; i++) {\n\t\tif (!(slots & (1 << i)))\n\t\t\tcontinue;\n\t\treg = get_slot_reg(pcm, cidx, i, dbl);\n\t\tswitch (reg) {\n\t\tcase AC97_PCM_FRONT_DAC_RATE:\tidx = AC97_RATES_FRONT_DAC; break;\n\t\tcase AC97_PCM_SURR_DAC_RATE:\tidx = AC97_RATES_SURR_DAC; break;\n\t\tcase AC97_PCM_LFE_DAC_RATE:\tidx = AC97_RATES_LFE_DAC; break;\n\t\tcase AC97_PCM_LR_ADC_RATE:\tidx = AC97_RATES_ADC; break;\n\t\tcase AC97_PCM_MIC_ADC_RATE:\tidx = AC97_RATES_MIC_ADC; break;\n\t\tdefault:\t\t\tidx = AC97_RATES_SPDIF; break;\n\t\t}\n\t\trates &= pcm->r[dbl].codec[cidx]->rates[idx];\n\t}\n\tif (!dbl)\n\t\trates &= ~(SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 |\n\t\t\t   SNDRV_PCM_RATE_96000);\n\treturn rates;\n}\n\n \nint snd_ac97_pcm_assign(struct snd_ac97_bus *bus,\n\t\t\tunsigned short pcms_count,\n\t\t\tconst struct ac97_pcm *pcms)\n{\n\tint i, j, k;\n\tconst struct ac97_pcm *pcm;\n\tstruct ac97_pcm *rpcms, *rpcm;\n\tunsigned short avail_slots[2][4];\n\tunsigned char rate_table[2][4];\n\tunsigned short tmp, slots;\n\tunsigned short spdif_slots[4];\n\tunsigned int rates;\n\tstruct snd_ac97 *codec;\n\n\trpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);\n\tif (rpcms == NULL)\n\t\treturn -ENOMEM;\n\tmemset(avail_slots, 0, sizeof(avail_slots));\n\tmemset(rate_table, 0, sizeof(rate_table));\n\tmemset(spdif_slots, 0, sizeof(spdif_slots));\n\tfor (i = 0; i < 4; i++) {\n\t\tcodec = bus->codec[i];\n\t\tif (!codec)\n\t\t\tcontinue;\n\t\tavail_slots[0][i] = get_pslots(codec, &rate_table[0][i], &spdif_slots[i]);\n\t\tavail_slots[1][i] = get_cslots(codec);\n\t\tif (!(codec->scaps & AC97_SCAP_INDEP_SDIN)) {\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (bus->codec[j])\n\t\t\t\t\tavail_slots[1][i] &= ~avail_slots[1][j];\n\t\t\t}\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < pcms_count; i++) {\n\t\tpcm = &pcms[i];\n\t\trpcm = &rpcms[i];\n\t\t \n\t\tif (pcm->copy_flag) {\n\t\t\t*rpcm = *pcm;\n\t\t\tcontinue;\n\t\t}\n\t\trpcm->stream = pcm->stream;\n\t\trpcm->exclusive = pcm->exclusive;\n\t\trpcm->spdif = pcm->spdif;\n\t\trpcm->private_value = pcm->private_value;\n\t\trpcm->bus = bus;\n\t\trpcm->rates = ~0;\n\t\tslots = pcm->r[0].slots;\n\t\tfor (j = 0; j < 4 && slots; j++) {\n\t\t\tif (!bus->codec[j])\n\t\t\t\tcontinue;\n\t\t\trates = ~0;\n\t\t\tif (pcm->spdif && pcm->stream == 0)\n\t\t\t\ttmp = spdif_slots[j];\n\t\t\telse\n\t\t\t\ttmp = avail_slots[pcm->stream][j];\n\t\t\tif (pcm->exclusive) {\n\t\t\t\t \n\t\t\t\ttmp &= slots;\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tif (rpcm->stream == rpcms[k].stream)\n\t\t\t\t\t\ttmp &= ~rpcms[k].r[0].rslots[j];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttmp &= pcm->r[0].slots;\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t\trpcm->r[0].rslots[j] = tmp;\n\t\t\t\trpcm->r[0].codec[j] = bus->codec[j];\n\t\t\t\trpcm->r[0].rate_table[j] = rate_table[pcm->stream][j];\n\t\t\t\tif (bus->no_vra)\n\t\t\t\t\trates = SNDRV_PCM_RATE_48000;\n\t\t\t\telse\n\t\t\t\t\trates = get_rates(rpcm, j, tmp, 0);\n\t\t\t\tif (pcm->exclusive)\n\t\t\t\t\tavail_slots[pcm->stream][j] &= ~tmp;\n\t\t\t}\n\t\t\tslots &= ~tmp;\n\t\t\trpcm->r[0].slots |= tmp;\n\t\t\trpcm->rates &= rates;\n\t\t}\n\t\t \n\t\tif (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t\t    bus->codec[0] && (bus->codec[0]->flags & AC97_DOUBLE_RATE) &&\n\t\t    rate_table[pcm->stream][0] == 0) {\n\t\t\ttmp = (1<<AC97_SLOT_PCM_LEFT) | (1<<AC97_SLOT_PCM_RIGHT) |\n\t\t\t      (1<<AC97_SLOT_PCM_LEFT_0) | (1<<AC97_SLOT_PCM_RIGHT_0);\n\t\t\tif ((tmp & pcm->r[1].slots) == tmp) {\n\t\t\t\trpcm->r[1].slots = tmp;\n\t\t\t\trpcm->r[1].rslots[0] = tmp;\n\t\t\t\trpcm->r[1].rate_table[0] = 0;\n\t\t\t\trpcm->r[1].codec[0] = bus->codec[0];\n\t\t\t\tif (pcm->exclusive)\n\t\t\t\t\tavail_slots[pcm->stream][0] &= ~tmp;\n\t\t\t\tif (bus->no_vra)\n\t\t\t\t\trates = SNDRV_PCM_RATE_96000;\n\t\t\t\telse\n\t\t\t\t\trates = get_rates(rpcm, 0, tmp, 1);\n\t\t\t\trpcm->rates |= rates;\n\t\t\t}\n\t\t}\n\t\tif (rpcm->rates == ~0)\n\t\t\trpcm->rates = 0;  \n\t}\n\tbus->pcms_count = pcms_count;\n\tbus->pcms = rpcms;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_pcm_assign);\n\n \nint snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,\n\t\t      enum ac97_pcm_cfg cfg, unsigned short slots)\n{\n\tstruct snd_ac97_bus *bus;\n\tint i, cidx, r, ok_flag;\n\tunsigned int reg_ok[4] = {0,0,0,0};\n\tunsigned char reg;\n\tint err = 0;\n\n\tr = rate > 48000;\n\tbus = pcm->bus;\n\tif (cfg == AC97_PCM_CFG_SPDIF) {\n\t\tfor (cidx = 0; cidx < 4; cidx++)\n\t\t\tif (bus->codec[cidx] && (bus->codec[cidx]->ext_id & AC97_EI_SPDIF)) {\n\t\t\t\terr = set_spdif_rate(bus->codec[cidx], rate);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t}\n\tspin_lock_irq(&pcm->bus->bus_lock);\n\tfor (i = 3; i < 12; i++) {\n\t\tif (!(slots & (1 << i)))\n\t\t\tcontinue;\n\t\tok_flag = 0;\n\t\tfor (cidx = 0; cidx < 4; cidx++) {\n\t\t\tif (bus->used_slots[pcm->stream][cidx] & (1 << i)) {\n\t\t\t\tspin_unlock_irq(&pcm->bus->bus_lock);\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (pcm->r[r].rslots[cidx] & (1 << i)) {\n\t\t\t\tbus->used_slots[pcm->stream][cidx] |= (1 << i);\n\t\t\t\tok_flag++;\n\t\t\t}\n\t\t}\n\t\tif (!ok_flag) {\n\t\t\tspin_unlock_irq(&pcm->bus->bus_lock);\n\t\t\tdev_err(bus->card->dev,\n\t\t\t\t\"cannot find configuration for AC97 slot %i\\n\",\n\t\t\t\ti);\n\t\t\terr = -EAGAIN;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tpcm->cur_dbl = r;\n\tspin_unlock_irq(&pcm->bus->bus_lock);\n\tfor (i = 3; i < 12; i++) {\n\t\tif (!(slots & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (cidx = 0; cidx < 4; cidx++) {\n\t\t\tif (pcm->r[r].rslots[cidx] & (1 << i)) {\n\t\t\t\treg = get_slot_reg(pcm, cidx, i, r);\n\t\t\t\tif (reg == 0xff) {\n\t\t\t\t\tdev_err(bus->card->dev,\n\t\t\t\t\t\t\"invalid AC97 slot %i?\\n\", i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (reg_ok[cidx] & (1 << (reg - AC97_PCM_FRONT_DAC_RATE)))\n\t\t\t\t\tcontinue;\n\t\t\t\tdev_dbg(bus->card->dev,\n\t\t\t\t\t\"setting ac97 reg 0x%x to rate %d\\n\",\n\t\t\t\t\treg, rate);\n\t\t\t\terr = snd_ac97_set_rate(pcm->r[r].codec[cidx], reg, rate);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tdev_err(bus->card->dev,\n\t\t\t\t\t\t\"error in snd_ac97_set_rate: cidx=%d, reg=0x%x, rate=%d, err=%d\\n\",\n\t\t\t\t\t\tcidx, reg, rate, err);\n\t\t\t\telse\n\t\t\t\t\treg_ok[cidx] |= (1 << (reg - AC97_PCM_FRONT_DAC_RATE));\n\t\t\t}\n\t\t}\n\t}\n\tpcm->aslots = slots;\n\treturn 0;\n\n error:\n\tpcm->aslots = slots;\n\tsnd_ac97_pcm_close(pcm);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ac97_pcm_open);\n\n \nint snd_ac97_pcm_close(struct ac97_pcm *pcm)\n{\n\tstruct snd_ac97_bus *bus;\n\tunsigned short slots = pcm->aslots;\n\tint i, cidx;\n\n#ifdef CONFIG_SND_AC97_POWER_SAVE\n\tint r = pcm->cur_dbl;\n\tfor (i = 3; i < 12; i++) {\n\t\tif (!(slots & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (cidx = 0; cidx < 4; cidx++) {\n\t\t\tif (pcm->r[r].rslots[cidx] & (1 << i)) {\n\t\t\t\tint reg = get_slot_reg(pcm, cidx, i, r);\n\t\t\t\tsnd_ac97_update_power(pcm->r[r].codec[cidx],\n\t\t\t\t\t\t      reg, 0);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tbus = pcm->bus;\n\tspin_lock_irq(&pcm->bus->bus_lock);\n\tfor (i = 3; i < 12; i++) {\n\t\tif (!(slots & (1 << i)))\n\t\t\tcontinue;\n\t\tfor (cidx = 0; cidx < 4; cidx++)\n\t\t\tbus->used_slots[pcm->stream][cidx] &= ~(1 << i);\n\t}\n\tpcm->aslots = 0;\n\tpcm->cur_dbl = 0;\n\tspin_unlock_irq(&pcm->bus->bus_lock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ac97_pcm_close);\n\nstatic int double_rate_hw_constraint_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tif (channels->min > 2) {\n\t\tstatic const struct snd_interval single_rates = {\n\t\t\t.min = 1,\n\t\t\t.max = 48000,\n\t\t};\n\t\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\treturn snd_interval_refine(rate, &single_rates);\n\t}\n\treturn 0;\n}\n\nstatic int double_rate_hw_constraint_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (rate->min > 48000) {\n\t\tstatic const struct snd_interval double_rate_channels = {\n\t\t\t.min = 2,\n\t\t\t.max = 2,\n\t\t};\n\t\tstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\t\treturn snd_interval_refine(channels, &double_rate_channels);\n\t}\n\treturn 0;\n}\n\n \nint snd_ac97_pcm_double_rate_rules(struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  double_rate_hw_constraint_rate, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  double_rate_hw_constraint_channels, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ac97_pcm_double_rate_rules);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}