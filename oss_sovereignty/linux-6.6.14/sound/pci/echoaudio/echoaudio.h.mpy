{
  "module_name": "echoaudio.h",
  "hash_id": "0c1f524bc71fc5b836c71d4453d0ee4009f8781c102fa59d22c0e8d7d6db2a6a",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/echoaudio.h",
  "human_readable_source": " \n\n\n#ifndef _ECHOAUDIO_H_\n#define _ECHOAUDIO_H_\n\n\n#include \"echoaudio_dsp.h\"\n\n\n\n \n\n \n#define VENDOR_ID\t\t0x1057\n#define DEVICE_ID_56301\t\t0x1801\n#define DEVICE_ID_56361\t\t0x3410\n#define SUBVENDOR_ID\t\t0xECC0\n\n\n \n#define DARLA20\t\t\t0x0010\n#define GINA20\t\t\t0x0020\n#define LAYLA20\t\t\t0x0030\n#define DARLA24\t\t\t0x0040\n#define GINA24\t\t\t0x0050\n#define LAYLA24\t\t\t0x0060\n#define MONA\t\t\t0x0070\n#define MIA\t\t\t0x0080\n#define INDIGO\t\t\t0x0090\n#define INDIGO_IO\t\t0x00a0\n#define INDIGO_DJ\t\t0x00b0\n#define DC8\t\t\t0x00c0\n#define INDIGO_IOX\t\t0x00d0\n#define INDIGO_DJX\t\t0x00e0\n#define ECHO3G\t\t\t0x0100\n\n\n \n\n \n#define ECHO_MAXAUDIOINPUTS\t32\t \n#define ECHO_MAXAUDIOOUTPUTS\t32\t \n#define ECHO_MAXAUDIOPIPES\t32\t \n#define E3G_MAX_OUTPUTS\t\t16\n#define ECHO_MAXMIDIJACKS\t1\t \n#define ECHO_MIDI_QUEUE_SZ \t512\t \n#define ECHO_MTC_QUEUE_SZ\t32\t \n\n \n#define MIDI_ACTIVITY_TIMEOUT_USEC\t200000\n\n\n \n\n \n#define ECHO_CLOCK_INTERNAL\t\t0\n#define ECHO_CLOCK_WORD\t\t\t1\n#define ECHO_CLOCK_SUPER\t\t2\n#define ECHO_CLOCK_SPDIF\t\t3\n#define ECHO_CLOCK_ADAT\t\t\t4\n#define ECHO_CLOCK_ESYNC\t\t5\n#define ECHO_CLOCK_ESYNC96\t\t6\n#define ECHO_CLOCK_MTC\t\t\t7\n#define ECHO_CLOCK_NUMBER\t\t8\n#define ECHO_CLOCKS\t\t\t0xffff\n\n \n#define ECHO_CLOCK_BIT_INTERNAL\t\t(1 << ECHO_CLOCK_INTERNAL)\n#define ECHO_CLOCK_BIT_WORD\t\t(1 << ECHO_CLOCK_WORD)\n#define ECHO_CLOCK_BIT_SUPER\t\t(1 << ECHO_CLOCK_SUPER)\n#define ECHO_CLOCK_BIT_SPDIF\t\t(1 << ECHO_CLOCK_SPDIF)\n#define ECHO_CLOCK_BIT_ADAT\t\t(1 << ECHO_CLOCK_ADAT)\n#define ECHO_CLOCK_BIT_ESYNC\t\t(1 << ECHO_CLOCK_ESYNC)\n#define ECHO_CLOCK_BIT_ESYNC96\t\t(1 << ECHO_CLOCK_ESYNC96)\n#define ECHO_CLOCK_BIT_MTC\t\t(1<<ECHO_CLOCK_MTC)\n\n\n \n\n \n#define DIGITAL_MODE_NONE\t\t\t0xFF\n#define DIGITAL_MODE_SPDIF_RCA\t\t\t0\n#define DIGITAL_MODE_SPDIF_OPTICAL\t\t1\n#define DIGITAL_MODE_ADAT\t\t\t2\n#define DIGITAL_MODE_SPDIF_CDROM\t\t3\n#define DIGITAL_MODES\t\t\t\t4\n\n \n#define ECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA\t(1 << DIGITAL_MODE_SPDIF_RCA)\n#define ECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL\t(1 << DIGITAL_MODE_SPDIF_OPTICAL)\n#define ECHOCAPS_HAS_DIGITAL_MODE_ADAT\t\t(1 << DIGITAL_MODE_ADAT)\n#define ECHOCAPS_HAS_DIGITAL_MODE_SPDIF_CDROM\t(1 << DIGITAL_MODE_SPDIF_CDROM)\n\n\n#define EXT_3GBOX_NC\t\t\t0x01\t \n#define EXT_3GBOX_NOT_SET\t\t0x02\t \n\n\n#define ECHOGAIN_MUTED\t\t(-128)\t \n#define ECHOGAIN_MINOUT\t\t(-128)\t \n#define ECHOGAIN_MAXOUT\t\t(6)\t \n#define ECHOGAIN_MININP\t\t(-50)\t \n#define ECHOGAIN_MAXINP\t\t(50)\t \n\n#define PIPE_STATE_STOPPED\t0\t \n#define PIPE_STATE_PAUSED\t1\t \n#define PIPE_STATE_STARTED\t2\t \n#define PIPE_STATE_PENDING\t3\t \n\n\n\nstruct audiopipe {\n\tvolatile __le32 *dma_counter;\t \n\tu32 last_period;                 \n\tu32 last_counter;\t\t \n\tu32 position;\t\t\t \n\tshort index;\t\t\t \n\tshort interleave;\n\tstruct snd_dma_buffer sgpage;\t \n\tstruct snd_pcm_hardware hw;\n\tstruct snd_pcm_hw_constraint_list constr;\n\tshort sglist_head;\n\tchar state;\t\t\t \n};\n\n\nstruct audioformat {\n\tu8 interleave;\t\t\t \n\tu8 bits_per_sample;\t\t \n\tchar mono_to_stereo;\t\t \n\tchar data_are_bigendian;\t \n};\n\n\nstruct echoaudio {\n\tspinlock_t lock;\n\tstruct snd_pcm_substream *substream[DSP_MAXPIPES];\n\tstruct mutex mode_mutex;\n\tu16 num_digital_modes, digital_mode_list[6];\n\tu16 num_clock_sources, clock_source_list[10];\n\tunsigned int opencount;   \n\tstruct snd_kcontrol *clock_src_ctl;\n\tstruct snd_pcm *analog_pcm, *digital_pcm;\n\tstruct snd_card *card;\n\tconst char *card_name;\n\tstruct pci_dev *pci;\n\tunsigned long dsp_registers_phys;\n\tstruct resource *iores;\n\tstruct snd_dma_buffer *commpage_dma_buf;\n\tint irq;\n#ifdef ECHOCARD_HAS_MIDI\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *midi_in, *midi_out;\n#endif\n\tstruct timer_list timer;\n\tchar tinuse;\t\t\t\t \n\tchar midi_full;\t\t\t\t \n\tchar can_set_rate;                       \n\tchar rate_set;                           \n\n\t \n\tstruct comm_page *comm_page;\t \n\tu32 pipe_alloc_mask;\t\t \n\tu32 pipe_cyclic_mask;\t\t \n\tu32 sample_rate;\t\t \n\tu8 digital_mode;\t\t \n\tu8 spdif_status;\t\t \n\tu8 clock_state;\t\t\t \n\tu8 input_clock;\t\t\t \n\tu8 output_clock;\t\t \n\tchar meters_enabled;\t\t \n\tchar asic_loaded;\t\t \n\tchar bad_board;\t\t\t \n\tchar professional_spdif;\t \n\tchar non_audio_spdif;\t\t \n\tchar digital_in_automute;\t \n\tchar has_phantom_power;\n\tchar hasnt_input_nominal_level;\t \n\tchar phantom_power;\t\t \n\tchar has_midi;\n\tchar midi_input_enabled;\n\n#ifdef ECHOCARD_ECHO3G\n\t \n\tchar px_digital_out, px_analog_in, px_digital_in, px_num;\n\tchar bx_digital_out, bx_analog_in, bx_digital_in, bx_num;\n#endif\n\n\tchar nominal_level[ECHO_MAXAUDIOPIPES];\t \n\ts8 input_gain[ECHO_MAXAUDIOINPUTS];\t \n\ts8 output_gain[ECHO_MAXAUDIOOUTPUTS];\t \n\ts8 monitor_gain[ECHO_MAXAUDIOOUTPUTS][ECHO_MAXAUDIOINPUTS];\n\t\t \n\ts8 vmixer_gain[ECHO_MAXAUDIOOUTPUTS][ECHO_MAXAUDIOOUTPUTS];\n\t\t \n\n\tu16 digital_modes;\t\t \n\tu16 input_clock_types;\t\t \n\tu16 output_clock_types;\t\t \n\tu16 device_id, subdevice_id;\n\tu16 *dsp_code;\t\t\t \n\tshort dsp_code_to_load;\t\t \n\tshort asic_code;\t\t \n\tu32 comm_page_phys;\t\t\t \n\tu32 __iomem *dsp_registers;\t\t \n\tu32 active_mask;\t\t\t \n#ifdef CONFIG_PM_SLEEP\n\tconst struct firmware *fw_cache[8];\t \n#endif\n\n#ifdef ECHOCARD_HAS_MIDI\n\tu16 mtc_state;\t\t\t\t \n\tu8 midi_buffer[MIDI_IN_BUFFER_SIZE];\n#endif\n};\n\n\nstatic int init_dsp_comm_page(struct echoaudio *chip);\nstatic int init_line_levels(struct echoaudio *chip);\nstatic int free_pipes(struct echoaudio *chip, struct audiopipe *pipe);\nstatic int load_firmware(struct echoaudio *chip);\nstatic int wait_handshake(struct echoaudio *chip);\nstatic int send_vector(struct echoaudio *chip, u32 command);\nstatic int get_firmware(const struct firmware **fw_entry,\n\t\t\tstruct echoaudio *chip, const short fw_index);\nstatic void free_firmware(const struct firmware *fw_entry,\n\t\t\t  struct echoaudio *chip);\n\n#ifdef ECHOCARD_HAS_MIDI\nstatic int enable_midi_input(struct echoaudio *chip, char enable);\nstatic void snd_echo_midi_output_trigger(\n\t\t\tstruct snd_rawmidi_substream *substream, int up);\nstatic int midi_service_irq(struct echoaudio *chip);\nstatic int snd_echo_midi_create(struct snd_card *card,\n\t\t\t\tstruct echoaudio *chip);\n#endif\n\n\nstatic inline void clear_handshake(struct echoaudio *chip)\n{\n\tchip->comm_page->handshake = 0;\n}\n\nstatic inline u32 get_dsp_register(struct echoaudio *chip, u32 index)\n{\n\treturn readl(&chip->dsp_registers[index]);\n}\n\nstatic inline void set_dsp_register(struct echoaudio *chip, u32 index,\n\t\t\t\t    u32 value)\n{\n\twritel(value, &chip->dsp_registers[index]);\n}\n\n\n \n\nstatic inline int px_digital_out(const struct echoaudio *chip)\n{\n\treturn PX_DIGITAL_OUT;\n}\n\nstatic inline int px_analog_in(const struct echoaudio *chip)\n{\n\treturn PX_ANALOG_IN;\n}\n\nstatic inline int px_digital_in(const struct echoaudio *chip)\n{\n\treturn PX_DIGITAL_IN;\n}\n\nstatic inline int px_num(const struct echoaudio *chip)\n{\n\treturn PX_NUM;\n}\n\nstatic inline int bx_digital_out(const struct echoaudio *chip)\n{\n\treturn BX_DIGITAL_OUT;\n}\n\nstatic inline int bx_analog_in(const struct echoaudio *chip)\n{\n\treturn BX_ANALOG_IN;\n}\n\nstatic inline int bx_digital_in(const struct echoaudio *chip)\n{\n\treturn BX_DIGITAL_IN;\n}\n\nstatic inline int bx_num(const struct echoaudio *chip)\n{\n\treturn BX_NUM;\n}\n\nstatic inline int num_pipes_out(const struct echoaudio *chip)\n{\n\treturn px_analog_in(chip);\n}\n\nstatic inline int num_pipes_in(const struct echoaudio *chip)\n{\n\treturn px_num(chip) - px_analog_in(chip);\n}\n\nstatic inline int num_busses_out(const struct echoaudio *chip)\n{\n\treturn bx_analog_in(chip);\n}\n\nstatic inline int num_busses_in(const struct echoaudio *chip)\n{\n\treturn bx_num(chip) - bx_analog_in(chip);\n}\n\nstatic inline int num_analog_busses_out(const struct echoaudio *chip)\n{\n\treturn bx_digital_out(chip);\n}\n\nstatic inline int num_analog_busses_in(const struct echoaudio *chip)\n{\n\treturn bx_digital_in(chip) - bx_analog_in(chip);\n}\n\nstatic inline int num_digital_busses_out(const struct echoaudio *chip)\n{\n\treturn num_busses_out(chip) - num_analog_busses_out(chip);\n}\n\nstatic inline int num_digital_busses_in(const struct echoaudio *chip)\n{\n\treturn num_busses_in(chip) - num_analog_busses_in(chip);\n}\n\n \nstatic inline int monitor_index(const struct echoaudio *chip, int out, int in)\n{\n\treturn out * num_busses_in(chip) + in;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}