{
  "module_name": "echoaudio_dsp.c",
  "hash_id": "2860ab2643a1a6a770d92552ce3496b6a22857237bffbb7a7a19d44128c849f0",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/echoaudio_dsp.c",
  "human_readable_source": " \n\n#if PAGE_SIZE < 4096\n#error PAGE_SIZE is < 4k\n#endif\n\nstatic int restore_dsp_rettings(struct echoaudio *chip);\n\n\n \nstatic int wait_handshake(struct echoaudio *chip)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < HANDSHAKE_TIMEOUT; i++) {\n\t\t \n\t\tbarrier();\n\t\tif (chip->comm_page->handshake) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tdev_err(chip->card->dev, \"wait_handshake(): Timeout waiting for DSP\\n\");\n\treturn -EBUSY;\n}\n\n\n\n \nstatic int send_vector(struct echoaudio *chip, u32 command)\n{\n\tint i;\n\n\twmb();\t \n\n\t \n\tfor (i = 0; i < VECTOR_BUSY_TIMEOUT; i++) {\n\t\tif (!(get_dsp_register(chip, CHI32_VECTOR_REG) &\n\t\t      CHI32_VECTOR_BUSY)) {\n\t\t\tset_dsp_register(chip, CHI32_VECTOR_REG, command);\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tdev_err(chip->card->dev, \"timeout on send_vector\\n\");\n\treturn -EBUSY;\n}\n\n\n\n \nstatic int write_dsp(struct echoaudio *chip, u32 data)\n{\n\tu32 status, i;\n\n\tfor (i = 0; i < 10000000; i++) {\t \n\t\tstatus = get_dsp_register(chip, CHI32_STATUS_REG);\n\t\tif ((status & CHI32_STATUS_HOST_WRITE_EMPTY) != 0) {\n\t\t\tset_dsp_register(chip, CHI32_DATA_REG, data);\n\t\t\twmb();\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t\tcond_resched();\n\t}\n\n\tchip->bad_board = true;\t\t \n\tdev_dbg(chip->card->dev, \"write_dsp: Set bad_board to true\\n\");\n\treturn -EIO;\n}\n\n\n\n \nstatic int read_dsp(struct echoaudio *chip, u32 *data)\n{\n\tu32 status, i;\n\n\tfor (i = 0; i < READ_DSP_TIMEOUT; i++) {\n\t\tstatus = get_dsp_register(chip, CHI32_STATUS_REG);\n\t\tif ((status & CHI32_STATUS_HOST_READ_FULL) != 0) {\n\t\t\t*data = get_dsp_register(chip, CHI32_DATA_REG);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t\tcond_resched();\n\t}\n\n\tchip->bad_board = true;\t\t \n\tdev_err(chip->card->dev, \"read_dsp: Set bad_board to true\\n\");\n\treturn -EIO;\n}\n\n\n\n \n\n \nstatic int read_sn(struct echoaudio *chip)\n{\n\tint i;\n\tu32 sn[6];\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (read_dsp(chip, &sn[i])) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"Failed to read serial number\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tdev_dbg(chip->card->dev,\n\t\t\"Read serial number %08x %08x %08x %08x %08x\\n\",\n\t\t sn[0], sn[1], sn[2], sn[3], sn[4]);\n\treturn 0;\n}\n\n\n\n#ifndef ECHOCARD_HAS_ASIC\n \nstatic inline int check_asic_status(struct echoaudio *chip)\n{\n\tchip->asic_loaded = true;\n\treturn 0;\n}\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_ASIC\n\n \nstatic int load_asic_generic(struct echoaudio *chip, u32 cmd, short asic)\n{\n\tconst struct firmware *fw;\n\tint err;\n\tu32 i, size;\n\tu8 *code;\n\n\terr = get_firmware(&fw, chip, asic);\n\tif (err < 0) {\n\t\tdev_warn(chip->card->dev, \"Firmware not found !\\n\");\n\t\treturn err;\n\t}\n\n\tcode = (u8 *)fw->data;\n\tsize = fw->size;\n\n\t \n\tif (write_dsp(chip, cmd) < 0)\n\t\tgoto la_error;\n\n\t \n\tif (write_dsp(chip, size) < 0)\n\t\tgoto la_error;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (write_dsp(chip, code[i]) < 0)\n\t\t\tgoto la_error;\n\t}\n\n\tfree_firmware(fw, chip);\n\treturn 0;\n\nla_error:\n\tdev_err(chip->card->dev, \"failed on write_dsp\\n\");\n\tfree_firmware(fw, chip);\n\treturn -EIO;\n}\n\n#endif  \n\n\n\n#ifdef DSP_56361\n\n \nstatic int install_resident_loader(struct echoaudio *chip)\n{\n\tu32 address;\n\tint index, words, i;\n\tu16 *code;\n\tu32 status;\n\tconst struct firmware *fw;\n\n\t \n\tif (chip->device_id != DEVICE_ID_56361)\n\t\treturn 0;\n\n\t \n\tstatus = get_dsp_register(chip, CHI32_STATUS_REG);\n\tif (status & CHI32_STATUS_REG_HF5) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"Resident loader already installed; status is 0x%x\\n\",\n\t\t\t status);\n\t\treturn 0;\n\t}\n\n\ti = get_firmware(&fw, chip, FW_361_LOADER);\n\tif (i < 0) {\n\t\tdev_warn(chip->card->dev, \"Firmware not found !\\n\");\n\t\treturn i;\n\t}\n\n\t \n\n\t \n\tset_dsp_register(chip, CHI32_CONTROL_REG,\n\t\t\t get_dsp_register(chip, CHI32_CONTROL_REG) | 0x900);\n\n\tcode = (u16 *)fw->data;\n\n\t \n\tindex = code[0];\n\n\t \n\tindex += 3;\n\n\t \n\twords = code[index++];\n\n\t \n\taddress = ((u32)code[index] << 16) + code[index + 1];\n\tindex += 2;\n\n\t \n\tif (write_dsp(chip, words)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"install_resident_loader: Failed to write word count!\\n\");\n\t\tgoto irl_error;\n\t}\n\t \n\tif (write_dsp(chip, address)) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"install_resident_loader: Failed to write DSP address!\\n\");\n\t\tgoto irl_error;\n\t}\n\t \n\tfor (i = 0; i < words; i++) {\n\t\tu32 data;\n\n\t\tdata = ((u32)code[index] << 16) + code[index + 1];\n\t\tif (write_dsp(chip, data)) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"install_resident_loader: Failed to write DSP code\\n\");\n\t\t\tgoto irl_error;\n\t\t}\n\t\tindex += 2;\n\t}\n\n\t \n\tfor (i = 0; i < 200; i++) {\t \n\t\tudelay(50);\n\t\tstatus = get_dsp_register(chip, CHI32_STATUS_REG);\n\t\tif (status & CHI32_STATUS_REG_HF5)\n\t\t\tbreak;\n\t}\n\n\tif (i == 200) {\n\t\tdev_err(chip->card->dev, \"Resident loader failed to set HF5\\n\");\n\t\tgoto irl_error;\n\t}\n\n\tdev_dbg(chip->card->dev, \"Resident loader successfully installed\\n\");\n\tfree_firmware(fw, chip);\n\treturn 0;\n\nirl_error:\n\tfree_firmware(fw, chip);\n\treturn -EIO;\n}\n\n#endif  \n\n\nstatic int load_dsp(struct echoaudio *chip, u16 *code)\n{\n\tu32 address, data;\n\tint index, words, i;\n\n\tif (chip->dsp_code == code) {\n\t\tdev_warn(chip->card->dev, \"DSP is already loaded!\\n\");\n\t\treturn 0;\n\t}\n\tchip->bad_board = true;\t\t \n\tchip->dsp_code = NULL;\t\t \n\tchip->asic_loaded = false;\t \n\n\tdev_dbg(chip->card->dev, \"load_dsp: Set bad_board to true\\n\");\n\n\t \n#ifdef DSP_56361\n\ti = install_resident_loader(chip);\n\tif (i < 0)\n\t\treturn i;\n#endif\n\n\t \n\tif (send_vector(chip, DSP_VC_RESET) < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"LoadDsp: send_vector DSP_VC_RESET failed, Critical Failure\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tudelay(10);\n\n\t \n\tfor (i = 0; i < 1000; i++) {\t \n\t\tif (get_dsp_register(chip, CHI32_STATUS_REG) &\n\t\t    CHI32_STATUS_REG_HF3)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (i == 1000) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"load_dsp: Timeout waiting for CHI32_STATUS_REG_HF3\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tset_dsp_register(chip, CHI32_CONTROL_REG,\n\t\t\t get_dsp_register(chip, CHI32_CONTROL_REG) | 0x900);\n\n\t \n\n\tindex = code[0];\n\tfor (;;) {\n\t\tint block_type, mem_type;\n\n\t\t \n\t\tindex++;\n\n\t\t \n\t\tblock_type = code[index];\n\t\tif (block_type == 4)\t \n\t\t\tbreak;\n\n\t\tindex++;\n\n\t\t \n\t\tmem_type = code[index++];\n\n\t\t \n\t\twords = code[index++];\n\t\tif (words == 0)\t\t \n\t\t\tbreak;\n\n\t\t \n\t\taddress = ((u32)code[index] << 16) + code[index + 1];\n\t\tindex += 2;\n\n\t\tif (write_dsp(chip, words) < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"load_dsp: failed to write number of DSP words\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (write_dsp(chip, address) < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"load_dsp: failed to write DSP address\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (write_dsp(chip, mem_type) < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"load_dsp: failed to write DSP memory type\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < words; i++, index+=2) {\n\t\t\tdata = ((u32)code[index] << 16) + code[index + 1];\n\t\t\tif (write_dsp(chip, data) < 0) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"load_dsp: failed to write DSP data\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (write_dsp(chip, 0) < 0) {\t \n\t\tdev_err(chip->card->dev,\n\t\t\t\"load_dsp: Failed to write final zero\\n\");\n\t\treturn -EIO;\n\t}\n\tudelay(10);\n\n\tfor (i = 0; i < 5000; i++) {\t \n\t\t \n\t\tif (get_dsp_register(chip, CHI32_STATUS_REG) &\n\t\t    CHI32_STATUS_REG_HF4) {\n\t\t\tset_dsp_register(chip, CHI32_CONTROL_REG,\n\t\t\t\t\t get_dsp_register(chip, CHI32_CONTROL_REG) & ~0x1b00);\n\n\t\t\tif (write_dsp(chip, DSP_FNC_SET_COMMPAGE_ADDR) < 0) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"load_dsp: Failed to write DSP_FNC_SET_COMMPAGE_ADDR\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (write_dsp(chip, chip->comm_page_phys) < 0) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"load_dsp: Failed to write comm page address\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (read_sn(chip) < 0) {\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"load_dsp: Failed to read serial number\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tchip->dsp_code = code;\t\t \n\t\t\tchip->bad_board = false;\t \n\t\t\treturn 0;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tdev_err(chip->card->dev,\n\t\t\"load_dsp: DSP load timed out waiting for HF4\\n\");\n\treturn -EIO;\n}\n\n\n\n \nstatic int load_firmware(struct echoaudio *chip)\n{\n\tconst struct firmware *fw;\n\tint box_type, err;\n\n\tif (snd_BUG_ON(!chip->comm_page))\n\t\treturn -EPERM;\n\n\t \n\tif (chip->dsp_code) {\n\t\tbox_type = check_asic_status(chip);\n\t\tif (box_type >= 0)\n\t\t\treturn box_type;\n\t\t \n\t\tchip->dsp_code = NULL;\n\t}\n\n\terr = get_firmware(&fw, chip, chip->dsp_code_to_load);\n\tif (err < 0)\n\t\treturn err;\n\terr = load_dsp(chip, (u16 *)fw->data);\n\tfree_firmware(fw, chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tbox_type = load_asic(chip);\n\tif (box_type < 0)\n\t\treturn box_type;\t \n\n\treturn box_type;\n}\n\n\n\n \n\n#if defined(ECHOCARD_HAS_INPUT_NOMINAL_LEVEL) || \\\n\tdefined(ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL)\n\n \nstatic int set_nominal_level(struct echoaudio *chip, u16 index, char consumer)\n{\n\tif (snd_BUG_ON(index >= num_busses_out(chip) + num_busses_in(chip)))\n\t\treturn -EINVAL;\n\n\t \n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->nominal_level[index] = consumer;\n\n\tif (consumer)\n\t\tchip->comm_page->nominal_level_mask |= cpu_to_le32(1 << index);\n\telse\n\t\tchip->comm_page->nominal_level_mask &= ~cpu_to_le32(1 << index);\n\n\treturn 0;\n}\n\n#endif  \n\n\n\n \nstatic int set_output_gain(struct echoaudio *chip, u16 channel, s8 gain)\n{\n\tif (snd_BUG_ON(channel >= num_busses_out(chip)))\n\t\treturn -EINVAL;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\t \n\tchip->output_gain[channel] = gain;\n\tchip->comm_page->line_out_level[channel] = gain;\n\treturn 0;\n}\n\n\n\n#ifdef ECHOCARD_HAS_MONITOR\n \nstatic int set_monitor_gain(struct echoaudio *chip, u16 output, u16 input,\n\t\t\t    s8 gain)\n{\n\tif (snd_BUG_ON(output >= num_busses_out(chip) ||\n\t\t    input >= num_busses_in(chip)))\n\t\treturn -EINVAL;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->monitor_gain[output][input] = gain;\n\tchip->comm_page->monitors[monitor_index(chip, output, input)] = gain;\n\treturn 0;\n}\n#endif  \n\n\n \nstatic int update_output_line_level(struct echoaudio *chip)\n{\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_OUTVOL);\n}\n\n\n\n \nstatic int update_input_line_level(struct echoaudio *chip)\n{\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_INGAIN);\n}\n\n\n\n \nstatic void set_meters_on(struct echoaudio *chip, char on)\n{\n\tif (on && !chip->meters_enabled) {\n\t\tsend_vector(chip, DSP_VC_METERS_ON);\n\t\tchip->meters_enabled = 1;\n\t} else if (!on && chip->meters_enabled) {\n\t\tsend_vector(chip, DSP_VC_METERS_OFF);\n\t\tchip->meters_enabled = 0;\n\t\tmemset((s8 *)chip->comm_page->vu_meter, ECHOGAIN_MUTED,\n\t\t       DSP_MAXPIPES);\n\t\tmemset((s8 *)chip->comm_page->peak_meter, ECHOGAIN_MUTED,\n\t\t       DSP_MAXPIPES);\n\t}\n}\n\n\n\n \nstatic void get_audio_meters(struct echoaudio *chip, long *meters)\n{\n\tunsigned int i, m, n;\n\n\tfor (i = 0 ; i < 96; i++)\n\t\tmeters[i] = 0;\n\n\tfor (m = 0, n = 0, i = 0; i < num_busses_out(chip); i++, m++) {\n\t\tmeters[n++] = chip->comm_page->vu_meter[m];\n\t\tmeters[n++] = chip->comm_page->peak_meter[m];\n\t}\n\n#ifdef ECHOCARD_ECHO3G\n\tm = E3G_MAX_OUTPUTS;\t \n#endif\n\n\tfor (n = 32, i = 0; i < num_busses_in(chip); i++, m++) {\n\t\tmeters[n++] = chip->comm_page->vu_meter[m];\n\t\tmeters[n++] = chip->comm_page->peak_meter[m];\n\t}\n#ifdef ECHOCARD_HAS_VMIXER\n\tfor (n = 64, i = 0; i < num_pipes_out(chip); i++, m++) {\n\t\tmeters[n++] = chip->comm_page->vu_meter[m];\n\t\tmeters[n++] = chip->comm_page->peak_meter[m];\n\t}\n#endif\n}\n\n\n\nstatic int restore_dsp_rettings(struct echoaudio *chip)\n{\n\tint i, o, err;\n\n\terr = check_asic_status(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tchip->comm_page->gd_clock_state = GD_CLOCK_UNDEF;\n\tchip->comm_page->gd_spdif_status = GD_SPDIF_STATUS_UNDEF;\n\tchip->comm_page->handshake = cpu_to_le32(0xffffffff);\n\n\t \n\tfor (i = 0; i < num_busses_out(chip); i++) {\n\t\terr = set_output_gain(chip, i, chip->output_gain[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#ifdef ECHOCARD_HAS_VMIXER\n\tfor (i = 0; i < num_pipes_out(chip); i++)\n\t\tfor (o = 0; o < num_busses_out(chip); o++) {\n\t\t\terr = set_vmixer_gain(chip, o, i,\n\t\t\t\t\t\tchip->vmixer_gain[o][i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\tif (update_vmixer_level(chip) < 0)\n\t\treturn -EIO;\n#endif  \n\n#ifdef ECHOCARD_HAS_MONITOR\n\tfor (o = 0; o < num_busses_out(chip); o++)\n\t\tfor (i = 0; i < num_busses_in(chip); i++) {\n\t\t\terr = set_monitor_gain(chip, o, i,\n\t\t\t\t\t\tchip->monitor_gain[o][i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n#endif  \n\n#ifdef ECHOCARD_HAS_INPUT_GAIN\n\tfor (i = 0; i < num_busses_in(chip); i++) {\n\t\terr = set_input_gain(chip, i, chip->input_gain[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif  \n\n\terr = update_output_line_level(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = update_input_line_level(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = set_sample_rate(chip, chip->sample_rate);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (chip->meters_enabled) {\n\t\terr = send_vector(chip, DSP_VC_METERS_ON);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH\n\tif (set_digital_mode(chip, chip->digital_mode) < 0)\n\t\treturn -EIO;\n#endif\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\tif (set_professional_spdif(chip, chip->professional_spdif) < 0)\n\t\treturn -EIO;\n#endif\n\n#ifdef ECHOCARD_HAS_PHANTOM_POWER\n\tif (set_phantom_power(chip, chip->phantom_power) < 0)\n\t\treturn -EIO;\n#endif\n\n#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK\n\t \n\tif (set_input_clock(chip, chip->input_clock) < 0)\n\t\treturn -EIO;\n#endif\n\n#ifdef ECHOCARD_HAS_OUTPUT_CLOCK_SWITCH\n\tif (set_output_clock(chip, chip->output_clock) < 0)\n\t\treturn -EIO;\n#endif\n\n\tif (wait_handshake(chip) < 0)\n\t\treturn -EIO;\n\tclear_handshake(chip);\n\tif (send_vector(chip, DSP_VC_UPDATE_FLAGS) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\n\n \n\n \nstatic void set_audio_format(struct echoaudio *chip, u16 pipe_index,\n\t\t\t     const struct audioformat *format)\n{\n\tu16 dsp_format;\n\n\tdsp_format = DSP_AUDIOFORM_SS_16LE;\n\n\t \n\tif (format->interleave > 2) {\n\t\tswitch (format->bits_per_sample) {\n\t\tcase 16:\n\t\t\tdsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_16LE;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tdsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_24LE;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tdsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_32LE;\n\t\t\tbreak;\n\t\t}\n\t\tdsp_format |= format->interleave;\n\t} else if (format->data_are_bigendian) {\n\t\t \n\t\tswitch (format->interleave) {\n\t\tcase 1:\n\t\t\tdsp_format = DSP_AUDIOFORM_MM_32BE;\n\t\t\tbreak;\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\n\t\tcase 2:\n\t\t\tdsp_format = DSP_AUDIOFORM_SS_32BE;\n\t\t\tbreak;\n#endif\n\t\t}\n\t} else if (format->interleave == 1 &&\n\t\t   format->bits_per_sample == 32 && !format->mono_to_stereo) {\n\t\t \n\t\tdsp_format = DSP_AUDIOFORM_MM_32LE;\n\t} else {\n\t\t \n\t\tswitch (format->bits_per_sample) {\n\t\tcase 8:\n\t\t\tif (format->interleave == 2)\n\t\t\t\tdsp_format = DSP_AUDIOFORM_SS_8;\n\t\t\telse\n\t\t\t\tdsp_format = DSP_AUDIOFORM_MS_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 16:\n\t\t\tif (format->interleave == 2)\n\t\t\t\tdsp_format = DSP_AUDIOFORM_SS_16LE;\n\t\t\telse\n\t\t\t\tdsp_format = DSP_AUDIOFORM_MS_16LE;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tif (format->interleave == 2)\n\t\t\t\tdsp_format = DSP_AUDIOFORM_SS_24LE;\n\t\t\telse\n\t\t\t\tdsp_format = DSP_AUDIOFORM_MS_24LE;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tif (format->interleave == 2)\n\t\t\t\tdsp_format = DSP_AUDIOFORM_SS_32LE;\n\t\t\telse\n\t\t\t\tdsp_format = DSP_AUDIOFORM_MS_32LE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdev_dbg(chip->card->dev,\n\t\t \"set_audio_format[%d] = %x\\n\", pipe_index, dsp_format);\n\tchip->comm_page->audio_format[pipe_index] = cpu_to_le16(dsp_format);\n}\n\n\n\n \nstatic int start_transport(struct echoaudio *chip, u32 channel_mask,\n\t\t\t   u32 cyclic_mask)\n{\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->comm_page->cmd_start |= cpu_to_le32(channel_mask);\n\n\tif (chip->comm_page->cmd_start) {\n\t\tclear_handshake(chip);\n\t\tsend_vector(chip, DSP_VC_START_TRANSFER);\n\t\tif (wait_handshake(chip))\n\t\t\treturn -EIO;\n\t\t \n\t\tchip->active_mask |= channel_mask;\n\t\tchip->comm_page->cmd_start = 0;\n\t\treturn 0;\n\t}\n\n\tdev_err(chip->card->dev, \"start_transport: No pipes to start!\\n\");\n\treturn -EINVAL;\n}\n\n\n\nstatic int pause_transport(struct echoaudio *chip, u32 channel_mask)\n{\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);\n\tchip->comm_page->cmd_reset = 0;\n\tif (chip->comm_page->cmd_stop) {\n\t\tclear_handshake(chip);\n\t\tsend_vector(chip, DSP_VC_STOP_TRANSFER);\n\t\tif (wait_handshake(chip))\n\t\t\treturn -EIO;\n\t\t \n\t\tchip->active_mask &= ~channel_mask;\n\t\tchip->comm_page->cmd_stop = 0;\n\t\tchip->comm_page->cmd_reset = 0;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(chip->card->dev, \"pause_transport: No pipes to stop!\\n\");\n\treturn 0;\n}\n\n\n\nstatic int stop_transport(struct echoaudio *chip, u32 channel_mask)\n{\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);\n\tchip->comm_page->cmd_reset |= cpu_to_le32(channel_mask);\n\tif (chip->comm_page->cmd_reset) {\n\t\tclear_handshake(chip);\n\t\tsend_vector(chip, DSP_VC_STOP_TRANSFER);\n\t\tif (wait_handshake(chip))\n\t\t\treturn -EIO;\n\t\t \n\t\tchip->active_mask &= ~channel_mask;\n\t\tchip->comm_page->cmd_stop = 0;\n\t\tchip->comm_page->cmd_reset = 0;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(chip->card->dev, \"stop_transport: No pipes to stop!\\n\");\n\treturn 0;\n}\n\n\n\nstatic inline int is_pipe_allocated(struct echoaudio *chip, u16 pipe_index)\n{\n\treturn (chip->pipe_alloc_mask & (1 << pipe_index));\n}\n\n\n\n \nstatic int rest_in_peace(struct echoaudio *chip)\n{\n\n\t \n\tstop_transport(chip, chip->active_mask);\n\n\tset_meters_on(chip, false);\n\n#ifdef ECHOCARD_HAS_MIDI\n\tenable_midi_input(chip, false);\n#endif\n\n\t \n\tif (chip->dsp_code) {\n\t\t \n\t\tchip->dsp_code = NULL;\n\t\t \n\t\treturn send_vector(chip, DSP_VC_GO_COMATOSE);\n\t}\n\treturn 0;\n}\n\n\n\n \nstatic int init_dsp_comm_page(struct echoaudio *chip)\n{\n\t \n\tif (offsetof(struct comm_page, midi_output) != 0xbe0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"init_dsp_comm_page() - Invalid struct comm_page structure\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tchip->card_name = ECHOCARD_NAME;\n\tchip->bad_board = true;\t \n\tchip->dsp_code = NULL;\t \n\tchip->asic_loaded = false;\n\tmemset(chip->comm_page, 0, sizeof(struct comm_page));\n\n\t \n\tchip->comm_page->comm_size =\n\t\tcpu_to_le32(sizeof(struct comm_page));\n\tchip->comm_page->handshake = cpu_to_le32(0xffffffff);\n\tchip->comm_page->midi_out_free_count =\n\t\tcpu_to_le32(DSP_MIDI_OUT_FIFO_SIZE);\n\tchip->comm_page->sample_rate = cpu_to_le32(44100);\n\n\t \n\tmemset(chip->comm_page->monitors, ECHOGAIN_MUTED, MONITOR_ARRAY_SIZE);\n\tmemset(chip->comm_page->vmixer, ECHOGAIN_MUTED, VMIXER_ARRAY_SIZE);\n\n\treturn 0;\n}\n\n\n\n \nstatic int init_line_levels(struct echoaudio *chip)\n{\n\tmemset(chip->output_gain, ECHOGAIN_MUTED, sizeof(chip->output_gain));\n\tmemset(chip->input_gain, ECHOGAIN_MUTED, sizeof(chip->input_gain));\n\tmemset(chip->monitor_gain, ECHOGAIN_MUTED, sizeof(chip->monitor_gain));\n\tmemset(chip->vmixer_gain, ECHOGAIN_MUTED, sizeof(chip->vmixer_gain));\n\tchip->input_clock = ECHO_CLOCK_INTERNAL;\n\tchip->output_clock = ECHO_CLOCK_WORD;\n\tchip->sample_rate = 44100;\n\treturn restore_dsp_rettings(chip);\n}\n\n\n\n \nstatic int service_irq(struct echoaudio *chip)\n{\n\tint st;\n\n\t \n\tif (get_dsp_register(chip, CHI32_STATUS_REG) & CHI32_STATUS_IRQ) {\n\t\tst = 0;\n#ifdef ECHOCARD_HAS_MIDI\n\t\t \n\t\tif (chip->comm_page->midi_input[0])\t \n\t\t\tst = midi_service_irq(chip);\t \n#endif\n\t\t \n\t\tchip->comm_page->midi_input[0] = 0;\n\t\tsend_vector(chip, DSP_VC_ACK_INT);\n\t\treturn st;\n\t}\n\treturn -1;\n}\n\n\n\n\n \n\n \nstatic int allocate_pipes(struct echoaudio *chip, struct audiopipe *pipe,\n\t\t\t  int pipe_index, int interleave)\n{\n\tint i;\n\tu32 channel_mask;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"allocate_pipes: ch=%d int=%d\\n\", pipe_index, interleave);\n\n\tif (chip->bad_board)\n\t\treturn -EIO;\n\n\tfor (channel_mask = i = 0; i < interleave; i++)\n\t\tchannel_mask |= 1 << (pipe_index + i);\n\tif (chip->pipe_alloc_mask & channel_mask) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"allocate_pipes: channel already open\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tchip->comm_page->position[pipe_index] = 0;\n\tchip->pipe_alloc_mask |= channel_mask;\n\t \n\tchip->pipe_cyclic_mask |= channel_mask;\n\tpipe->index = pipe_index;\n\tpipe->interleave = interleave;\n\tpipe->state = PIPE_STATE_STOPPED;\n\n\t \n\tpipe->dma_counter = (__le32 *)&chip->comm_page->position[pipe_index];\n\t*pipe->dma_counter = 0;\n\treturn pipe_index;\n}\n\n\n\nstatic int free_pipes(struct echoaudio *chip, struct audiopipe *pipe)\n{\n\tu32 channel_mask;\n\tint i;\n\n\tif (snd_BUG_ON(!is_pipe_allocated(chip, pipe->index)))\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(pipe->state != PIPE_STATE_STOPPED))\n\t\treturn -EINVAL;\n\n\tfor (channel_mask = i = 0; i < pipe->interleave; i++)\n\t\tchannel_mask |= 1 << (pipe->index + i);\n\n\tchip->pipe_alloc_mask &= ~channel_mask;\n\tchip->pipe_cyclic_mask &= ~channel_mask;\n\treturn 0;\n}\n\n\n\n \n\nstatic int sglist_init(struct echoaudio *chip, struct audiopipe *pipe)\n{\n\tpipe->sglist_head = 0;\n\tmemset(pipe->sgpage.area, 0, PAGE_SIZE);\n\tchip->comm_page->sglist_addr[pipe->index].addr =\n\t\tcpu_to_le32(pipe->sgpage.addr);\n\treturn 0;\n}\n\n\n\nstatic int sglist_add_mapping(struct echoaudio *chip, struct audiopipe *pipe,\n\t\t\t\tdma_addr_t address, size_t length)\n{\n\tint head = pipe->sglist_head;\n\tstruct sg_entry *list = (struct sg_entry *)pipe->sgpage.area;\n\n\tif (head < MAX_SGLIST_ENTRIES - 1) {\n\t\tlist[head].addr = cpu_to_le32(address);\n\t\tlist[head].size = cpu_to_le32(length);\n\t\tpipe->sglist_head++;\n\t} else {\n\t\tdev_err(chip->card->dev, \"SGlist: too many fragments\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n\n\nstatic inline int sglist_add_irq(struct echoaudio *chip, struct audiopipe *pipe)\n{\n\treturn sglist_add_mapping(chip, pipe, 0, 0);\n}\n\n\n\nstatic inline int sglist_wrap(struct echoaudio *chip, struct audiopipe *pipe)\n{\n\treturn sglist_add_mapping(chip, pipe, pipe->sgpage.addr, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}