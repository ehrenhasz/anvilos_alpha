{
  "module_name": "echoaudio_gml.c",
  "hash_id": "8fcfe250c3d2b6da59a4db5b0eced6f1ba7e284f2804c43358a9906cc390f1eb",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/echoaudio_gml.c",
  "human_readable_source": " \n\n\n \n\n\n \nstatic int check_asic_status(struct echoaudio *chip)\n{\n\tu32 asic_status;\n\n\tsend_vector(chip, DSP_VC_TEST_ASIC);\n\n\t \n\tif (read_dsp(chip, &asic_status) < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"check_asic_status: failed on read_dsp\\n\");\n\t\tchip->asic_loaded = false;\n\t\treturn -EIO;\n\t}\n\n\tchip->asic_loaded = (asic_status == ASIC_ALREADY_LOADED);\n\treturn chip->asic_loaded ? 0 : -EIO;\n}\n\n\n\n \nstatic int write_control_reg(struct echoaudio *chip, u32 value, char force)\n{\n\t__le32 reg_value;\n\n\t \n\tif (chip->digital_in_automute)\n\t\tvalue |= GML_DIGITAL_IN_AUTO_MUTE;\n\telse\n\t\tvalue &= ~GML_DIGITAL_IN_AUTO_MUTE;\n\n\tdev_dbg(chip->card->dev, \"write_control_reg: 0x%x\\n\", value);\n\n\t \n\treg_value = cpu_to_le32(value);\n\tif (reg_value != chip->comm_page->control_register || force) {\n\t\tif (wait_handshake(chip))\n\t\t\treturn -EIO;\n\t\tchip->comm_page->control_register = reg_value;\n\t\tclear_handshake(chip);\n\t\treturn send_vector(chip, DSP_VC_WRITE_CONTROL_REG);\n\t}\n\treturn 0;\n}\n\n\n\n \nstatic int set_input_auto_mute(struct echoaudio *chip, int automute)\n{\n\tdev_dbg(chip->card->dev, \"set_input_auto_mute %d\\n\", automute);\n\n\tchip->digital_in_automute = automute;\n\n\t \n\treturn set_input_clock(chip, chip->input_clock);\n}\n\n\n\n \nstatic int set_digital_mode(struct echoaudio *chip, u8 mode)\n{\n\tu8 previous_mode;\n\tint err, i, o;\n\n\tif (chip->bad_board)\n\t\treturn -EIO;\n\n\t \n\tif (snd_BUG_ON(chip->pipe_alloc_mask))\n\t\treturn -EAGAIN;\n\n\tif (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))\n\t\treturn -EINVAL;\n\n\tprevious_mode = chip->digital_mode;\n\terr = dsp_set_digital_mode(chip, mode);\n\n\t \n\tif (err >= 0 && previous_mode != mode &&\n\t    (previous_mode == DIGITAL_MODE_ADAT || mode == DIGITAL_MODE_ADAT)) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tfor (o = 0; o < num_busses_out(chip); o++)\n\t\t\tfor (i = 0; i < num_busses_in(chip); i++)\n\t\t\t\tset_monitor_gain(chip, o, i,\n\t\t\t\t\t\t chip->monitor_gain[o][i]);\n\n#ifdef ECHOCARD_HAS_INPUT_GAIN\n\t\tfor (i = 0; i < num_busses_in(chip); i++)\n\t\t\tset_input_gain(chip, i, chip->input_gain[i]);\n\t\tupdate_input_line_level(chip);\n#endif\n\n\t\tfor (o = 0; o < num_busses_out(chip); o++)\n\t\t\tset_output_gain(chip, o, chip->output_gain[o]);\n\t\tupdate_output_line_level(chip);\n\t\tspin_unlock_irq(&chip->lock);\n\t}\n\n\treturn err;\n}\n\n\n\n \nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\n{\n\tu32 control_reg;\n\tint err;\n\n\t \n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tcontrol_reg &= GML_SPDIF_FORMAT_CLEAR_MASK;\n\n\t \n\tcontrol_reg |= GML_SPDIF_TWO_CHANNEL | GML_SPDIF_24_BIT |\n\t\tGML_SPDIF_COPY_PERMIT;\n\tif (prof) {\n\t\t \n\t\tcontrol_reg |= GML_SPDIF_PRO_MODE;\n\n\t\tswitch (chip->sample_rate) {\n\t\tcase 32000:\n\t\t\tcontrol_reg |= GML_SPDIF_SAMPLE_RATE0 |\n\t\t\t\tGML_SPDIF_SAMPLE_RATE1;\n\t\t\tbreak;\n\t\tcase 44100:\n\t\t\tcontrol_reg |= GML_SPDIF_SAMPLE_RATE0;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tcontrol_reg |= GML_SPDIF_SAMPLE_RATE1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (chip->sample_rate) {\n\t\tcase 32000:\n\t\t\tcontrol_reg |= GML_SPDIF_SAMPLE_RATE0 |\n\t\t\t\tGML_SPDIF_SAMPLE_RATE1;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tcontrol_reg |= GML_SPDIF_SAMPLE_RATE1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = write_control_reg(chip, control_reg, false);\n\tif (err)\n\t\treturn err;\n\tchip->professional_spdif = prof;\n\tdev_dbg(chip->card->dev, \"set_professional_spdif to %s\\n\",\n\t\tprof ? \"Professional\" : \"Consumer\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}