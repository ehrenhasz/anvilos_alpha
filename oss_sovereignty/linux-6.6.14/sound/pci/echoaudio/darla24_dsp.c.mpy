{
  "module_name": "darla24_dsp.c",
  "hash_id": "9f807f52495586288237bfd3c013d2c00713cb869154e8f939868d66fd88c14b",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/darla24_dsp.c",
  "human_readable_source": " \n\n\nstatic int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\n{\n\tint err;\n\n\tif (snd_BUG_ON((subdevice_id & 0xfff0) != DARLA24))\n\t\treturn -ENODEV;\n\n\terr = init_dsp_comm_page(chip);\n\tif (err) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"init_hw: could not initialize DSP comm page\\n\");\n\t\treturn err;\n\t}\n\n\tchip->device_id = device_id;\n\tchip->subdevice_id = subdevice_id;\n\tchip->bad_board = true;\n\tchip->dsp_code_to_load = FW_DARLA24_DSP;\n\t \n\tchip->asic_loaded = true;\n\tchip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL |\n\t\tECHO_CLOCK_BIT_ESYNC;\n\n\terr = load_firmware(chip);\n\tif (err < 0)\n\t\treturn err;\n\tchip->bad_board = false;\n\n\treturn err;\n}\n\n\n\nstatic int set_mixer_defaults(struct echoaudio *chip)\n{\n\treturn init_line_levels(chip);\n}\n\n\n\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\n{\n\tu32 clocks_from_dsp, clock_bits;\n\n\t \n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tclock_bits = ECHO_CLOCK_BIT_INTERNAL;\n\n\tif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_ESYNC)\n\t\tclock_bits |= ECHO_CLOCK_BIT_ESYNC;\n\n\treturn clock_bits;\n}\n\n\n\n \nstatic int load_asic(struct echoaudio *chip)\n{\n\treturn 0;\n}\n\n\n\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\n{\n\tu8 clock;\n\n\tswitch (rate) {\n\tcase 96000:\n\t\tclock = GD24_96000;\n\t\tbreak;\n\tcase 88200:\n\t\tclock = GD24_88200;\n\t\tbreak;\n\tcase 48000:\n\t\tclock = GD24_48000;\n\t\tbreak;\n\tcase 44100:\n\t\tclock = GD24_44100;\n\t\tbreak;\n\tcase 32000:\n\t\tclock = GD24_32000;\n\t\tbreak;\n\tcase 22050:\n\t\tclock = GD24_22050;\n\t\tbreak;\n\tcase 16000:\n\t\tclock = GD24_16000;\n\t\tbreak;\n\tcase 11025:\n\t\tclock = GD24_11025;\n\t\tbreak;\n\tcase 8000:\n\t\tclock = GD24_8000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"set_sample_rate: Error, invalid sample rate %d\\n\",\n\t\t\trate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"set_sample_rate: %d clock %d\\n\", rate, clock);\n\tchip->sample_rate = rate;\n\n\t \n\tif (chip->input_clock == ECHO_CLOCK_ESYNC)\n\t\tclock = GD24_EXT_SYNC;\n\n\tchip->comm_page->sample_rate = cpu_to_le32(rate);\t \n\tchip->comm_page->gd_clock_state = clock;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_SET_GD_AUDIO_STATE);\n}\n\n\n\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\n{\n\tif (snd_BUG_ON(clock != ECHO_CLOCK_INTERNAL &&\n\t\t       clock != ECHO_CLOCK_ESYNC))\n\t\treturn -EINVAL;\n\tchip->input_clock = clock;\n\treturn set_sample_rate(chip, chip->sample_rate);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}