{
  "module_name": "midi.c",
  "hash_id": "69a23adf53c1070250ab6aabb188a0f74501e3000acafb6be6bc457f87658961",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/midi.c",
  "human_readable_source": " \n\n\n \n\n \nstatic int enable_midi_input(struct echoaudio *chip, char enable)\n{\n\tdev_dbg(chip->card->dev, \"enable_midi_input(%d)\\n\", enable);\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tif (enable) {\n\t\tchip->mtc_state = MIDI_IN_STATE_NORMAL;\n\t\tchip->comm_page->flags |=\n\t\t\tcpu_to_le32(DSP_FLAG_MIDI_INPUT);\n\t} else\n\t\tchip->comm_page->flags &=\n\t\t\t~cpu_to_le32(DSP_FLAG_MIDI_INPUT);\n\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_FLAGS);\n}\n\n\n\n \nstatic int write_midi(struct echoaudio *chip, u8 *data, int bytes)\n{\n\tif (snd_BUG_ON(bytes <= 0 || bytes >= MIDI_OUT_BUFFER_SIZE))\n\t\treturn -EINVAL;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\t \n\tif (! (get_dsp_register(chip, CHI32_STATUS_REG) & CHI32_STATUS_REG_HF4))\n\t\treturn 0;\n\n\tchip->comm_page->midi_output[0] = bytes;\n\tmemcpy(&chip->comm_page->midi_output[1], data, bytes);\n\tchip->comm_page->midi_out_free_count = 0;\n\tclear_handshake(chip);\n\tsend_vector(chip, DSP_VC_MIDI_WRITE);\n\tdev_dbg(chip->card->dev, \"write_midi: %d\\n\", bytes);\n\treturn bytes;\n}\n\n\n\n \nstatic inline int mtc_process_data(struct echoaudio *chip, short midi_byte)\n{\n\tswitch (chip->mtc_state) {\n\tcase MIDI_IN_STATE_NORMAL:\n\t\tif (midi_byte == 0xF1)\n\t\t\tchip->mtc_state = MIDI_IN_STATE_TS_HIGH;\n\t\tbreak;\n\tcase MIDI_IN_STATE_TS_HIGH:\n\t\tchip->mtc_state = MIDI_IN_STATE_TS_LOW;\n\t\treturn MIDI_IN_SKIP_DATA;\n\t\tbreak;\n\tcase MIDI_IN_STATE_TS_LOW:\n\t\tchip->mtc_state = MIDI_IN_STATE_F1_DATA;\n\t\treturn MIDI_IN_SKIP_DATA;\n\t\tbreak;\n\tcase MIDI_IN_STATE_F1_DATA:\n\t\tchip->mtc_state = MIDI_IN_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n\n \nstatic int midi_service_irq(struct echoaudio *chip)\n{\n\tshort int count, midi_byte, i, received;\n\n\t \n\tcount = le16_to_cpu(chip->comm_page->midi_input[0]);\n\n\tif (snd_BUG_ON(count >= MIDI_IN_BUFFER_SIZE))\n\t\treturn 0;\n\n\t \n\treceived = 0;\n\tfor (i = 1; i <= count; i++) {\n\t\t \n\t\tmidi_byte = le16_to_cpu(chip->comm_page->midi_input[i]);\n\n\t\t \n\t\tif (mtc_process_data(chip, midi_byte) == MIDI_IN_SKIP_DATA)\n\t\t\tcontinue;\n\n\t\tchip->midi_buffer[received++] = (u8)midi_byte;\n\t}\n\n\treturn received;\n}\n\n\n\n\n \n\nstatic int snd_echo_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tchip->midi_in = substream;\n\treturn 0;\n}\n\n\n\nstatic void snd_echo_midi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\tint up)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tif (up != chip->midi_input_enabled) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tenable_midi_input(chip, up);\n\t\tspin_unlock_irq(&chip->lock);\n\t\tchip->midi_input_enabled = up;\n\t}\n}\n\n\n\nstatic int snd_echo_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tchip->midi_in = NULL;\n\treturn 0;\n}\n\n\n\nstatic int snd_echo_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tchip->tinuse = 0;\n\tchip->midi_full = 0;\n\tchip->midi_out = substream;\n\treturn 0;\n}\n\n\n\nstatic void snd_echo_midi_output_write(struct timer_list *t)\n{\n\tstruct echoaudio *chip = from_timer(chip, t, timer);\n\tunsigned long flags;\n\tint bytes, sent, time;\n\tunsigned char buf[MIDI_OUT_BUFFER_SIZE - 1];\n\n\t \n\tsent = 0;\n\tspin_lock_irqsave(&chip->lock, flags);\n\tchip->midi_full = 0;\n\tif (!snd_rawmidi_transmit_empty(chip->midi_out)) {\n\t\tbytes = snd_rawmidi_transmit_peek(chip->midi_out, buf,\n\t\t\t\t\t\t  MIDI_OUT_BUFFER_SIZE - 1);\n\t\tdev_dbg(chip->card->dev, \"Try to send %d bytes...\\n\", bytes);\n\t\tsent = write_midi(chip, buf, bytes);\n\t\tif (sent < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"write_midi() error %d\\n\", sent);\n\t\t\t \n\t\t\tsent = 9000;\n\t\t\tchip->midi_full = 1;\n\t\t} else if (sent > 0) {\n\t\t\tdev_dbg(chip->card->dev, \"%d bytes sent\\n\", sent);\n\t\t\tsnd_rawmidi_transmit_ack(chip->midi_out, sent);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(chip->card->dev, \"Full\\n\");\n\t\t\tsent = 32;\n\t\t\tchip->midi_full = 1;\n\t\t}\n\t}\n\n\t \n\tif (!snd_rawmidi_transmit_empty(chip->midi_out) && chip->tinuse) {\n\t\t \n\t\ttime = (sent << 3) / 25 + 1;\t \n\t\tmod_timer(&chip->timer, jiffies + (time * HZ + 999) / 1000);\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"Timer armed(%d)\\n\", ((time * HZ + 999) / 1000));\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\n\n\nstatic void snd_echo_midi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t int up)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tdev_dbg(chip->card->dev, \"snd_echo_midi_output_trigger(%d)\\n\", up);\n\tspin_lock_irq(&chip->lock);\n\tif (up) {\n\t\tif (!chip->tinuse) {\n\t\t\ttimer_setup(&chip->timer, snd_echo_midi_output_write,\n\t\t\t\t    0);\n\t\t\tchip->tinuse = 1;\n\t\t}\n\t} else {\n\t\tif (chip->tinuse) {\n\t\t\tchip->tinuse = 0;\n\t\t\tspin_unlock_irq(&chip->lock);\n\t\t\tdel_timer_sync(&chip->timer);\n\t\t\tdev_dbg(chip->card->dev, \"Timer removed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irq(&chip->lock);\n\n\tif (up && !chip->midi_full)\n\t\tsnd_echo_midi_output_write(&chip->timer);\n}\n\n\n\nstatic int snd_echo_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct echoaudio *chip = substream->rmidi->private_data;\n\n\tchip->midi_out = NULL;\n\treturn 0;\n}\n\n\n\nstatic const struct snd_rawmidi_ops snd_echo_midi_input = {\n\t.open = snd_echo_midi_input_open,\n\t.close = snd_echo_midi_input_close,\n\t.trigger = snd_echo_midi_input_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_echo_midi_output = {\n\t.open = snd_echo_midi_output_open,\n\t.close = snd_echo_midi_output_close,\n\t.trigger = snd_echo_midi_output_trigger,\n};\n\n\n\n \nstatic int snd_echo_midi_create(struct snd_card *card,\n\t\t\t\tstruct echoaudio *chip)\n{\n\tint err;\n\n\terr = snd_rawmidi_new(card, card->shortname, 0, 1, 1, &chip->rmidi);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(chip->rmidi->name, card->shortname);\n\tchip->rmidi->private_data = chip;\n\n\tsnd_rawmidi_set_ops(chip->rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_echo_midi_input);\n\tsnd_rawmidi_set_ops(chip->rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_echo_midi_output);\n\n\tchip->rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\tSNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}