{
  "module_name": "echoaudio.c",
  "hash_id": "c4bea38e3bb4d93062ff7804d35bbe17474c93a56bdd7c6167c06ca14de54946",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/echoaudio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"Giuliano Pochini <pochini@shiny.it>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Echoaudio \" ECHOCARD_NAME \" soundcards driver\");\nMODULE_DEVICE_TABLE(pci, snd_echo_ids);\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" ECHOCARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" ECHOCARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" ECHOCARD_NAME \" soundcard.\");\n\nstatic const unsigned int channels_list[10] = {1, 2, 4, 6, 8, 10, 12, 14, 16, 999999};\nstatic const DECLARE_TLV_DB_SCALE(db_scale_output_gain, -12800, 100, 1);\n\n\n\nstatic int get_firmware(const struct firmware **fw_entry,\n\t\t\tstruct echoaudio *chip, const short fw_index)\n{\n\tint err;\n\tchar name[30];\n\n#ifdef CONFIG_PM_SLEEP\n\tif (chip->fw_cache[fw_index]) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"firmware requested: %s is cached\\n\",\n\t\t\tcard_fw[fw_index].data);\n\t\t*fw_entry = chip->fw_cache[fw_index];\n\t\treturn 0;\n\t}\n#endif\n\n\tdev_dbg(chip->card->dev,\n\t\t\"firmware requested: %s\\n\", card_fw[fw_index].data);\n\tsnprintf(name, sizeof(name), \"ea/%s\", card_fw[fw_index].data);\n\terr = request_firmware(fw_entry, name, &chip->pci->dev);\n\tif (err < 0)\n\t\tdev_err(chip->card->dev,\n\t\t\t\"get_firmware(): Firmware not available (%d)\\n\", err);\n#ifdef CONFIG_PM_SLEEP\n\telse\n\t\tchip->fw_cache[fw_index] = *fw_entry;\n#endif\n\treturn err;\n}\n\n\n\nstatic void free_firmware(const struct firmware *fw_entry,\n\t\t\t  struct echoaudio *chip)\n{\n#ifdef CONFIG_PM_SLEEP\n\tdev_dbg(chip->card->dev, \"firmware not released (kept in cache)\\n\");\n#else\n\trelease_firmware(fw_entry);\n#endif\n}\n\n\n\nstatic void free_firmware_cache(struct echoaudio *chip)\n{\n#ifdef CONFIG_PM_SLEEP\n\tint i;\n\n\tfor (i = 0; i < 8 ; i++)\n\t\tif (chip->fw_cache[i]) {\n\t\t\trelease_firmware(chip->fw_cache[i]);\n\t\t\tdev_dbg(chip->card->dev, \"release_firmware(%d)\\n\", i);\n\t\t}\n\n#endif\n}\n\n\n\n \n\nstatic void audiopipe_free(struct snd_pcm_runtime *runtime)\n{\n\tstruct audiopipe *pipe = runtime->private_data;\n\n\tif (pipe->sgpage.area)\n\t\tsnd_dma_free_pages(&pipe->sgpage);\n\tkfree(pipe);\n}\n\n\n\nstatic int hw_rule_capture_format_by_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask fmt;\n\n\tsnd_mask_any(&fmt);\n\n#ifndef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\n\t \n\tif (c->min == 2) {\n\t\tfmt.bits[0] &= ~SNDRV_PCM_FMTBIT_S32_BE;\n\t\treturn snd_mask_refine(f, &fmt);\n\t}\n#endif\n\t \n\tif (c->min > 2) {\n\t\tfmt.bits[0] &= ~(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S32_BE);\n\t\treturn snd_mask_refine(f, &fmt);\n\t}\n\t \n\treturn 0;\n}\n\n\n\nstatic int hw_rule_capture_channels_by_format(struct snd_pcm_hw_params *params,\n\t\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_interval ch;\n\n\tsnd_interval_any(&ch);\n\n\t \n\tif (f->bits[0] == SNDRV_PCM_FMTBIT_S32_BE) {\n\t\tch.min = 1;\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\n\t\tch.max = 2;\n#else\n\t\tch.max = 1;\n#endif\n\t\tch.integer = 1;\n\t\treturn snd_interval_refine(c, &ch);\n\t}\n\t \n\tif (f->bits[0] == SNDRV_PCM_FMTBIT_U8) {\n\t\tch.min = 1;\n\t\tch.max = 2;\n\t\tch.integer = 1;\n\t\treturn snd_interval_refine(c, &ch);\n\t}\n\t \n\treturn 0;\n}\n\n\n\nstatic int hw_rule_playback_format_by_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask fmt;\n\tu64 fmask;\n\tsnd_mask_any(&fmt);\n\n\tfmask = fmt.bits[0] + ((u64)fmt.bits[1] << 32);\n\n\t \n\tif (c->min > 2) {\n\t\tfmask &= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE;\n\t \n\t} else if (c->max == 1)\n\t\tfmask &= SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE;\n#ifndef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\n\t \n\telse if (c->min == 2 && c->max == 2)\n\t\tfmask &= ~SNDRV_PCM_FMTBIT_S32_BE;\n#endif\n\telse\n\t\treturn 0;\n\n\tfmt.bits[0] &= (u32)fmask;\n\tfmt.bits[1] &= (u32)(fmask >> 32);\n\treturn snd_mask_refine(f, &fmt);\n}\n\n\n\nstatic int hw_rule_playback_channels_by_format(struct snd_pcm_hw_params *params,\n\t\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_interval ch;\n\tu64 fmask;\n\n\tsnd_interval_any(&ch);\n\tch.integer = 1;\n\tfmask = f->bits[0] + ((u64)f->bits[1] << 32);\n\n\t \n\tif (fmask == SNDRV_PCM_FMTBIT_S32_BE) {\n\t\tch.min = 1;\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\n\t\tch.max = 2;\n#else\n\t\tch.max = 1;\n#endif\n\t \n\t} else if (fmask == SNDRV_PCM_FMTBIT_U8)\n\t\tch.min = ch.max = 2;\n\t \n\telse if (!(fmask & ~(SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t       SNDRV_PCM_FMTBIT_S24_3LE)))\n\t\tch.min = 2;\n\telse\n\t\treturn 0;\n\n\treturn snd_interval_refine(c, &ch);\n}\n\n\n\n \nstatic int hw_rule_sample_rate(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\t\t      SNDRV_PCM_HW_PARAM_RATE);\n\tstruct echoaudio *chip = rule->private;\n\tstruct snd_interval fixed;\n\tint err;\n\n\tmutex_lock(&chip->mode_mutex);\n\n\tif (chip->can_set_rate) {\n\t\terr = 0;\n\t} else {\n\t\tsnd_interval_any(&fixed);\n\t\tfixed.min = fixed.max = chip->sample_rate;\n\t\terr = snd_interval_refine(rate, &fixed);\n\t}\n\n\tmutex_unlock(&chip->mode_mutex);\n\treturn err;\n}\n\n\nstatic int pcm_open(struct snd_pcm_substream *substream,\n\t\t    signed char max_channels)\n{\n\tstruct echoaudio *chip;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct audiopipe *pipe;\n\tint err, i;\n\n\tif (max_channels <= 0)\n\t\treturn -EAGAIN;\n\n\tchip = snd_pcm_substream_chip(substream);\n\truntime = substream->runtime;\n\n\tpipe = kzalloc(sizeof(struct audiopipe), GFP_KERNEL);\n\tif (!pipe)\n\t\treturn -ENOMEM;\n\tpipe->index = -1;\t\t \n\n\t \n\tmemcpy(&pipe->hw, &pcm_hardware_skel, sizeof(struct snd_pcm_hardware));\n\tdev_dbg(chip->card->dev, \"max_channels=%d\\n\", max_channels);\n\tpipe->constr.list = channels_list;\n\tpipe->constr.mask = 0;\n\tfor (i = 0; channels_list[i] <= max_channels; i++);\n\tpipe->constr.count = i;\n\tif (pipe->hw.channels_max > max_channels)\n\t\tpipe->hw.channels_max = max_channels;\n\tif (chip->digital_mode == DIGITAL_MODE_ADAT) {\n\t\tpipe->hw.rate_max = 48000;\n\t\tpipe->hw.rates &= SNDRV_PCM_RATE_8000_48000;\n\t}\n\n\truntime->hw = pipe->hw;\n\truntime->private_data = pipe;\n\truntime->private_free = audiopipe_free;\n\tsnd_pcm_set_sync(substream);\n\n\t \n\terr = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t &pipe->constr);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  hw_rule_sample_rate, chip,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t  &chip->pci->dev,\n\t\t\t\t  PAGE_SIZE, &pipe->sgpage);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"s-g list allocation failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\n\tdev_dbg(chip->card->dev, \"pcm_open opencount=%d can_set_rate=%d, rate_set=%d\",\n\t\tchip->opencount, chip->can_set_rate, chip->rate_set);\n\n\tchip->opencount++;\n\tif (chip->opencount > 1 && chip->rate_set)\n\t\tchip->can_set_rate = 0;\n\n\treturn 0;\n}\n\n\n\nstatic int pcm_analog_in_open(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\terr = pcm_open(substream,\n\t\t       num_analog_busses_in(chip) - substream->number);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_capture_channels_by_format, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_capture_format_by_channels, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n\nstatic int pcm_analog_out_open(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tint max_channels, err;\n\n#ifdef ECHOCARD_HAS_VMIXER\n\tmax_channels = num_pipes_out(chip);\n#else\n\tmax_channels = num_analog_busses_out(chip);\n#endif\n\terr = pcm_open(substream, max_channels - substream->number);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_playback_channels_by_format,\n\t\t\t\t  NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_playback_format_by_channels,\n\t\t\t\t  NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\nstatic int pcm_digital_in_open(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tint err, max_channels;\n\n\tmax_channels = num_digital_busses_in(chip) - substream->number;\n\tmutex_lock(&chip->mode_mutex);\n\tif (chip->digital_mode == DIGITAL_MODE_ADAT)\n\t\terr = pcm_open(substream, max_channels);\n\telse\t \n\t\terr = pcm_open(substream, max_channels - ECHOCARD_HAS_ADAT);\n\n\tif (err < 0)\n\t\tgoto din_exit;\n\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_capture_channels_by_format, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (err < 0)\n\t\tgoto din_exit;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_capture_format_by_channels, NULL,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\tgoto din_exit;\n\ndin_exit:\n\tmutex_unlock(&chip->mode_mutex);\n\treturn err;\n}\n\n\n\n#ifndef ECHOCARD_HAS_VMIXER\t \n\nstatic int pcm_digital_out_open(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tint err, max_channels;\n\n\tmax_channels = num_digital_busses_out(chip) - substream->number;\n\tmutex_lock(&chip->mode_mutex);\n\tif (chip->digital_mode == DIGITAL_MODE_ADAT)\n\t\terr = pcm_open(substream, max_channels);\n\telse\t \n\t\terr = pcm_open(substream, max_channels - ECHOCARD_HAS_ADAT);\n\n\tif (err < 0)\n\t\tgoto dout_exit;\n\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_playback_channels_by_format,\n\t\t\t\t  NULL, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  -1);\n\tif (err < 0)\n\t\tgoto dout_exit;\n\terr = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_playback_format_by_channels,\n\t\t\t\t  NULL, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  -1);\n\tif (err < 0)\n\t\tgoto dout_exit;\n\ndout_exit:\n\tmutex_unlock(&chip->mode_mutex);\n\treturn err;\n}\n\n#endif  \n\n#endif  \n\n\n\nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\n\t \n\n\tmutex_lock(&chip->mode_mutex);\n\n\tdev_dbg(chip->card->dev, \"pcm_open opencount=%d can_set_rate=%d, rate_set=%d\",\n\t\tchip->opencount, chip->can_set_rate, chip->rate_set);\n\n\tchip->opencount--;\n\n\tswitch (chip->opencount) {\n\tcase 1:\n\t\tchip->can_set_rate = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tchip->rate_set = 0;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&chip->mode_mutex);\n\treturn 0;\n}\n\n\n\n \nstatic int init_engine(struct snd_pcm_substream *substream,\n\t\t       struct snd_pcm_hw_params *hw_params,\n\t\t       int pipe_index, int interleave)\n{\n\tstruct echoaudio *chip;\n\tint err, per, rest, page, edge, offs;\n\tstruct audiopipe *pipe;\n\n\tchip = snd_pcm_substream_chip(substream);\n\tpipe = (struct audiopipe *) substream->runtime->private_data;\n\n\t \n\tspin_lock_irq(&chip->lock);\n\tif (pipe->index >= 0) {\n\t\tdev_dbg(chip->card->dev, \"hwp_ie free(%d)\\n\", pipe->index);\n\t\terr = free_pipes(chip, pipe);\n\t\tsnd_BUG_ON(err);\n\t\tchip->substream[pipe->index] = NULL;\n\t}\n\n\terr = allocate_pipes(chip, pipe, pipe_index, interleave);\n\tif (err < 0) {\n\t\tspin_unlock_irq(&chip->lock);\n\t\tdev_err(chip->card->dev, \"allocate_pipes(%d) err=%d\\n\",\n\t\t\tpipe_index, err);\n\t\treturn err;\n\t}\n\tspin_unlock_irq(&chip->lock);\n\tdev_dbg(chip->card->dev, \"allocate_pipes()=%d\\n\", pipe_index);\n\n\tdev_dbg(chip->card->dev,\n\t\t\"pcm_hw_params (bufsize=%dB periods=%d persize=%dB)\\n\",\n\t\tparams_buffer_bytes(hw_params), params_periods(hw_params),\n\t\tparams_period_bytes(hw_params));\n\n\tsglist_init(chip, pipe);\n\tedge = PAGE_SIZE;\n\tfor (offs = page = per = 0; offs < params_buffer_bytes(hw_params);\n\t     per++) {\n\t\trest = params_period_bytes(hw_params);\n\t\tif (offs + rest > params_buffer_bytes(hw_params))\n\t\t\trest = params_buffer_bytes(hw_params) - offs;\n\t\twhile (rest) {\n\t\t\tdma_addr_t addr;\n\t\t\taddr = snd_pcm_sgbuf_get_addr(substream, offs);\n\t\t\tif (rest <= edge - offs) {\n\t\t\t\tsglist_add_mapping(chip, pipe, addr, rest);\n\t\t\t\tsglist_add_irq(chip, pipe);\n\t\t\t\toffs += rest;\n\t\t\t\trest = 0;\n\t\t\t} else {\n\t\t\t\tsglist_add_mapping(chip, pipe, addr,\n\t\t\t\t\t\t   edge - offs);\n\t\t\t\trest -= edge - offs;\n\t\t\t\toffs = edge;\n\t\t\t}\n\t\t\tif (offs == edge) {\n\t\t\t\tedge += PAGE_SIZE;\n\t\t\t\tpage++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsglist_wrap(chip, pipe);\n\n\t \n\tpipe->last_period = 0;\n\tpipe->last_counter = 0;\n\tpipe->position = 0;\n\tsmp_wmb();\n\tchip->substream[pipe_index] = substream;\n\tchip->rate_set = 1;\n\tspin_lock_irq(&chip->lock);\n\tset_sample_rate(chip, hw_params->rate_num / hw_params->rate_den);\n\tspin_unlock_irq(&chip->lock);\n\treturn 0;\n}\n\n\n\nstatic int pcm_analog_in_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *hw_params)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\n\treturn init_engine(substream, hw_params, px_analog_in(chip) +\n\t\t\tsubstream->number, params_channels(hw_params));\n}\n\n\n\nstatic int pcm_analog_out_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\treturn init_engine(substream, hw_params, substream->number,\n\t\t\t   params_channels(hw_params));\n}\n\n\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\nstatic int pcm_digital_in_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\n\treturn init_engine(substream, hw_params, px_digital_in(chip) +\n\t\t\tsubstream->number, params_channels(hw_params));\n}\n\n\n\n#ifndef ECHOCARD_HAS_VMIXER\t \nstatic int pcm_digital_out_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\n\treturn init_engine(substream, hw_params, px_digital_out(chip) +\n\t\t\tsubstream->number, params_channels(hw_params));\n}\n#endif  \n\n#endif  \n\n\n\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip;\n\tstruct audiopipe *pipe;\n\n\tchip = snd_pcm_substream_chip(substream);\n\tpipe = (struct audiopipe *) substream->runtime->private_data;\n\n\tspin_lock_irq(&chip->lock);\n\tif (pipe->index >= 0) {\n\t\tdev_dbg(chip->card->dev, \"pcm_hw_free(%d)\\n\", pipe->index);\n\t\tfree_pipes(chip, pipe);\n\t\tchip->substream[pipe->index] = NULL;\n\t\tpipe->index = -1;\n\t}\n\tspin_unlock_irq(&chip->lock);\n\n\treturn 0;\n}\n\n\n\nstatic int pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audioformat format;\n\tint pipe_index = ((struct audiopipe *)runtime->private_data)->index;\n\n\tdev_dbg(chip->card->dev, \"Prepare rate=%d format=%d channels=%d\\n\",\n\t\truntime->rate, runtime->format, runtime->channels);\n\tformat.interleave = runtime->channels;\n\tformat.data_are_bigendian = 0;\n\tformat.mono_to_stereo = 0;\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tformat.bits_per_sample = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tformat.bits_per_sample = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tformat.bits_per_sample = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_BE:\n\t\tformat.data_are_bigendian = 1;\n\t\tfallthrough;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tformat.bits_per_sample = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Prepare error: unsupported format %d\\n\",\n\t\t\truntime->format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_BUG_ON(pipe_index >= px_num(chip)))\n\t\treturn -EINVAL;\n\n\t \n\n\tspin_lock_irq(&chip->lock);\n\n\tif (snd_BUG_ON(!is_pipe_allocated(chip, pipe_index))) {\n\t\tspin_unlock_irq(&chip->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tset_audio_format(chip, pipe_index, &format);\n\tspin_unlock_irq(&chip->lock);\n\n\treturn 0;\n}\n\n\n\nstatic int pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct echoaudio *chip = snd_pcm_substream_chip(substream);\n\tstruct audiopipe *pipe;\n\tint i, err;\n\tu32 channelmask = 0;\n\tstruct snd_pcm_substream *s;\n\n\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\tfor (i = 0; i < DSP_MAXPIPES; i++) {\n\t\t\tif (s == chip->substream[i]) {\n\t\t\t\tchannelmask |= 1 << i;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&chip->lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor (i = 0; i < DSP_MAXPIPES; i++) {\n\t\t\tif (channelmask & (1 << i)) {\n\t\t\t\tpipe = chip->substream[i]->runtime->private_data;\n\t\t\t\tswitch (pipe->state) {\n\t\t\t\tcase PIPE_STATE_STOPPED:\n\t\t\t\t\tpipe->last_period = 0;\n\t\t\t\t\tpipe->last_counter = 0;\n\t\t\t\t\tpipe->position = 0;\n\t\t\t\t\t*pipe->dma_counter = 0;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase PIPE_STATE_PAUSED:\n\t\t\t\t\tpipe->state = PIPE_STATE_STARTED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PIPE_STATE_STARTED:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = start_transport(chip, channelmask,\n\t\t\t\t      chip->pipe_cyclic_mask);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tfor (i = 0; i < DSP_MAXPIPES; i++) {\n\t\t\tif (channelmask & (1 << i)) {\n\t\t\t\tpipe = chip->substream[i]->runtime->private_data;\n\t\t\t\tpipe->state = PIPE_STATE_STOPPED;\n\t\t\t}\n\t\t}\n\t\terr = stop_transport(chip, channelmask);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor (i = 0; i < DSP_MAXPIPES; i++) {\n\t\t\tif (channelmask & (1 << i)) {\n\t\t\t\tpipe = chip->substream[i]->runtime->private_data;\n\t\t\t\tpipe->state = PIPE_STATE_PAUSED;\n\t\t\t}\n\t\t}\n\t\terr = pause_transport(chip, channelmask);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&chip->lock);\n\treturn err;\n}\n\n\n\nstatic snd_pcm_uframes_t pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audiopipe *pipe = runtime->private_data;\n\tu32 counter, step;\n\n\t \n\n\tcounter = le32_to_cpu(*pipe->dma_counter);   \n\n\tstep = counter - pipe->last_counter;   \n\tpipe->last_counter = counter;\n\n\t \n\n\tpipe->position += step;\n\tpipe->position %= frames_to_bytes(runtime, runtime->buffer_size);  \n\n\treturn bytes_to_frames(runtime, pipe->position);\n}\n\n\n\n \nstatic const struct snd_pcm_ops analog_playback_ops = {\n\t.open = pcm_analog_out_open,\n\t.close = pcm_close,\n\t.hw_params = pcm_analog_out_hw_params,\n\t.hw_free = pcm_hw_free,\n\t.prepare = pcm_prepare,\n\t.trigger = pcm_trigger,\n\t.pointer = pcm_pointer,\n};\nstatic const struct snd_pcm_ops analog_capture_ops = {\n\t.open = pcm_analog_in_open,\n\t.close = pcm_close,\n\t.hw_params = pcm_analog_in_hw_params,\n\t.hw_free = pcm_hw_free,\n\t.prepare = pcm_prepare,\n\t.trigger = pcm_trigger,\n\t.pointer = pcm_pointer,\n};\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n#ifndef ECHOCARD_HAS_VMIXER\nstatic const struct snd_pcm_ops digital_playback_ops = {\n\t.open = pcm_digital_out_open,\n\t.close = pcm_close,\n\t.hw_params = pcm_digital_out_hw_params,\n\t.hw_free = pcm_hw_free,\n\t.prepare = pcm_prepare,\n\t.trigger = pcm_trigger,\n\t.pointer = pcm_pointer,\n};\n#endif  \nstatic const struct snd_pcm_ops digital_capture_ops = {\n\t.open = pcm_digital_in_open,\n\t.close = pcm_close,\n\t.hw_params = pcm_digital_in_hw_params,\n\t.hw_free = pcm_hw_free,\n\t.prepare = pcm_prepare,\n\t.trigger = pcm_trigger,\n\t.pointer = pcm_pointer,\n};\n#endif  \n\n\n\n \nstatic void snd_echo_preallocate_pages(struct snd_pcm *pcm, struct device *dev)\n{\n\tstruct snd_pcm_substream *ss;\n\tint stream;\n\n\tfor (stream = 0; stream < 2; stream++)\n\t\tfor (ss = pcm->streams[stream].substream; ss; ss = ss->next)\n\t\t\tsnd_pcm_set_managed_buffer(ss, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t\t   dev,\n\t\t\t\t\t\t   ss->number ? 0 : 128<<10,\n\t\t\t\t\t\t   256<<10);\n}\n\n\n\n \nstatic int snd_echo_new_pcm(struct echoaudio *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n#ifdef ECHOCARD_HAS_VMIXER\n\t \n\n\t \n\terr = snd_pcm_new(chip->card, \"PCM\", 0, num_pipes_out(chip),\n\t\t\t  num_analog_busses_in(chip), &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tchip->analog_pcm = pcm;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &analog_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &analog_capture_ops);\n\tsnd_echo_preallocate_pages(pcm, &chip->pci->dev);\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\t \n\terr = snd_pcm_new(chip->card, \"Digital PCM\", 1, 0,\n\t\t\t  num_digital_busses_in(chip), &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tchip->digital_pcm = pcm;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &digital_capture_ops);\n\tsnd_echo_preallocate_pages(pcm, &chip->pci->dev);\n#endif  \n\n#else  \n\n\t \n\n\t \n\terr = snd_pcm_new(chip->card, \"Analog PCM\", 0,\n\t\t\t  num_analog_busses_out(chip),\n\t\t\t  num_analog_busses_in(chip), &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tchip->analog_pcm = pcm;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &analog_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &analog_capture_ops);\n\tsnd_echo_preallocate_pages(pcm, &chip->pci->dev);\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\t \n\terr = snd_pcm_new(chip->card, \"Digital PCM\", 1,\n\t\t\t  num_digital_busses_out(chip),\n\t\t\t  num_digital_busses_in(chip), &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tchip->digital_pcm = pcm;\n\tstrcpy(pcm->name, chip->card->shortname);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &digital_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &digital_capture_ops);\n\tsnd_echo_preallocate_pages(pcm, &chip->pci->dev);\n#endif  \n\n#endif  \n\n\treturn 0;\n}\n\n\n\n\n \n\n#if !defined(ECHOCARD_HAS_VMIXER) || defined(ECHOCARD_HAS_LINE_OUT_GAIN)\n\n \nstatic int snd_echo_output_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = num_busses_out(chip);\n\tuinfo->value.integer.min = ECHOGAIN_MINOUT;\n\tuinfo->value.integer.max = ECHOGAIN_MAXOUT;\n\treturn 0;\n}\n\nstatic int snd_echo_output_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tfor (c = 0; c < num_busses_out(chip); c++)\n\t\tucontrol->value.integer.value[c] = chip->output_gain[c];\n\treturn 0;\n}\n\nstatic int snd_echo_output_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c, changed, gain;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&chip->lock);\n\tfor (c = 0; c < num_busses_out(chip); c++) {\n\t\tgain = ucontrol->value.integer.value[c];\n\t\t \n\t\tif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\n\t\t\tcontinue;\n\t\tif (chip->output_gain[c] != gain) {\n\t\t\tset_output_gain(chip, c, gain);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tupdate_output_line_level(chip);\n\tspin_unlock_irq(&chip->lock);\n\treturn changed;\n}\n\n#ifdef ECHOCARD_HAS_LINE_OUT_GAIN\n \nstatic const struct snd_kcontrol_new snd_echo_line_output_gain = {\n\t.name = \"Line Playback Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_output_gain_info,\n\t.get = snd_echo_output_gain_get,\n\t.put = snd_echo_output_gain_put,\n\t.tlv = {.p = db_scale_output_gain},\n};\n#else\nstatic const struct snd_kcontrol_new snd_echo_pcm_output_gain = {\n\t.name = \"PCM Playback Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_output_gain_info,\n\t.get = snd_echo_output_gain_get,\n\t.put = snd_echo_output_gain_put,\n\t.tlv = {.p = db_scale_output_gain},\n};\n#endif\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_INPUT_GAIN\n\n \nstatic int snd_echo_input_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = num_analog_busses_in(chip);\n\tuinfo->value.integer.min = ECHOGAIN_MININP;\n\tuinfo->value.integer.max = ECHOGAIN_MAXINP;\n\treturn 0;\n}\n\nstatic int snd_echo_input_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tfor (c = 0; c < num_analog_busses_in(chip); c++)\n\t\tucontrol->value.integer.value[c] = chip->input_gain[c];\n\treturn 0;\n}\n\nstatic int snd_echo_input_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c, gain, changed;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&chip->lock);\n\tfor (c = 0; c < num_analog_busses_in(chip); c++) {\n\t\tgain = ucontrol->value.integer.value[c];\n\t\t \n\t\tif (gain < ECHOGAIN_MININP || gain > ECHOGAIN_MAXINP)\n\t\t\tcontinue;\n\t\tif (chip->input_gain[c] != gain) {\n\t\t\tset_input_gain(chip, c, gain);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tupdate_input_line_level(chip);\n\tspin_unlock_irq(&chip->lock);\n\treturn changed;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_input_gain, -2500, 50, 0);\n\nstatic const struct snd_kcontrol_new snd_echo_line_input_gain = {\n\t.name = \"Line Capture Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_input_gain_info,\n\t.get = snd_echo_input_gain_get,\n\t.put = snd_echo_input_gain_put,\n\t.tlv = {.p = db_scale_input_gain},\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL\n\n \nstatic int snd_echo_output_nominal_info (struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = num_analog_busses_out(chip);\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_echo_output_nominal_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tfor (c = 0; c < num_analog_busses_out(chip); c++)\n\t\tucontrol->value.integer.value[c] = chip->nominal_level[c];\n\treturn 0;\n}\n\nstatic int snd_echo_output_nominal_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c, changed;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&chip->lock);\n\tfor (c = 0; c < num_analog_busses_out(chip); c++) {\n\t\tif (chip->nominal_level[c] != ucontrol->value.integer.value[c]) {\n\t\t\tset_nominal_level(chip, c,\n\t\t\t\t\t  ucontrol->value.integer.value[c]);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tupdate_output_line_level(chip);\n\tspin_unlock_irq(&chip->lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_output_nominal_level = {\n\t.name = \"Line Playback Switch (-10dBV)\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_echo_output_nominal_info,\n\t.get = snd_echo_output_nominal_get,\n\t.put = snd_echo_output_nominal_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_INPUT_NOMINAL_LEVEL\n\n \nstatic int snd_echo_input_nominal_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = num_analog_busses_in(chip);\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_echo_input_nominal_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tfor (c = 0; c < num_analog_busses_in(chip); c++)\n\t\tucontrol->value.integer.value[c] =\n\t\t\tchip->nominal_level[bx_analog_in(chip) + c];\n\treturn 0;\n}\n\nstatic int snd_echo_input_nominal_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint c, changed;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&chip->lock);\n\tfor (c = 0; c < num_analog_busses_in(chip); c++) {\n\t\tif (chip->nominal_level[bx_analog_in(chip) + c] !=\n\t\t    ucontrol->value.integer.value[c]) {\n\t\t\tset_nominal_level(chip, bx_analog_in(chip) + c,\n\t\t\t\t\t  ucontrol->value.integer.value[c]);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (changed)\n\t\tupdate_output_line_level(chip);\t \n\tspin_unlock_irq(&chip->lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_intput_nominal_level = {\n\t.name = \"Line Capture Switch (-10dBV)\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.info = snd_echo_input_nominal_info,\n\t.get = snd_echo_input_nominal_get,\n\t.put = snd_echo_input_nominal_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_MONITOR\n\n \nstatic int snd_echo_mixer_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = ECHOGAIN_MINOUT;\n\tuinfo->value.integer.max = ECHOGAIN_MAXOUT;\n\treturn 0;\n}\n\nstatic int snd_echo_mixer_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int out = ucontrol->id.index / num_busses_in(chip);\n\tunsigned int in = ucontrol->id.index % num_busses_in(chip);\n\n\tif (out >= ECHO_MAXAUDIOOUTPUTS || in >= ECHO_MAXAUDIOINPUTS)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = chip->monitor_gain[out][in];\n\treturn 0;\n}\n\nstatic int snd_echo_mixer_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint changed,  gain;\n\tunsigned int out, in;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tout = ucontrol->id.index / num_busses_in(chip);\n\tin = ucontrol->id.index % num_busses_in(chip);\n\tif (out >= ECHO_MAXAUDIOOUTPUTS || in >= ECHO_MAXAUDIOINPUTS)\n\t\treturn -EINVAL;\n\tgain = ucontrol->value.integer.value[0];\n\tif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\n\t\treturn -EINVAL;\n\tif (chip->monitor_gain[out][in] != gain) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tset_monitor_gain(chip, out, in, gain);\n\t\tupdate_output_line_level(chip);\n\t\tspin_unlock_irq(&chip->lock);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new snd_echo_monitor_mixer = {\n\t.name = \"Monitor Mixer Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_mixer_info,\n\t.get = snd_echo_mixer_get,\n\t.put = snd_echo_mixer_put,\n\t.tlv = {.p = db_scale_output_gain},\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_VMIXER\n\n \nstatic int snd_echo_vmixer_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = ECHOGAIN_MINOUT;\n\tuinfo->value.integer.max = ECHOGAIN_MAXOUT;\n\treturn 0;\n}\n\nstatic int snd_echo_vmixer_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] =\n\t\tchip->vmixer_gain[ucontrol->id.index / num_pipes_out(chip)]\n\t\t\t[ucontrol->id.index % num_pipes_out(chip)];\n\treturn 0;\n}\n\nstatic int snd_echo_vmixer_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint gain, changed;\n\tshort vch, out;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\tout = ucontrol->id.index / num_pipes_out(chip);\n\tvch = ucontrol->id.index % num_pipes_out(chip);\n\tgain = ucontrol->value.integer.value[0];\n\tif (gain < ECHOGAIN_MINOUT || gain > ECHOGAIN_MAXOUT)\n\t\treturn -EINVAL;\n\tif (chip->vmixer_gain[out][vch] != ucontrol->value.integer.value[0]) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tset_vmixer_gain(chip, out, vch, ucontrol->value.integer.value[0]);\n\t\tupdate_vmixer_level(chip);\n\t\tspin_unlock_irq(&chip->lock);\n\t\tchanged = 1;\n\t}\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new snd_echo_vmixer = {\n\t.name = \"VMixer Volume\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_vmixer_info,\n\t.get = snd_echo_vmixer_get,\n\t.put = snd_echo_vmixer_put,\n\t.tlv = {.p = db_scale_output_gain},\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH\n\n \nstatic int snd_echo_digital_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const names[4] = {\n\t\t\"S/PDIF Coaxial\", \"S/PDIF Optical\", \"ADAT Optical\",\n\t\t\"S/PDIF Cdrom\"\n\t};\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\treturn snd_ctl_enum_info(uinfo, 1, chip->num_digital_modes, names);\n}\n\nstatic int snd_echo_digital_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint i, mode;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tmode = chip->digital_mode;\n\tfor (i = chip->num_digital_modes - 1; i >= 0; i--)\n\t\tif (mode == chip->digital_mode_list[i]) {\n\t\t\tucontrol->value.enumerated.item[0] = i;\n\t\t\tbreak;\n\t\t}\n\treturn 0;\n}\n\nstatic int snd_echo_digital_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint changed;\n\tunsigned short emode, dmode;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\n\temode = ucontrol->value.enumerated.item[0];\n\tif (emode >= chip->num_digital_modes)\n\t\treturn -EINVAL;\n\tdmode = chip->digital_mode_list[emode];\n\n\tif (dmode != chip->digital_mode) {\n\t\t \n\t\tmutex_lock(&chip->mode_mutex);\n\n\t\t \n\t\tif (chip->opencount) {\n\t\t\tchanged = -EAGAIN;\n\t\t} else {\n\t\t\tchanged = set_digital_mode(chip, dmode);\n\t\t\t \n\t\t\tif (changed > 0 && chip->clock_src_ctl) {\n\t\t\t\tsnd_ctl_notify(chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t       &chip->clock_src_ctl->id);\n\t\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\t\"SDM() =%d\\n\", changed);\n\t\t\t}\n\t\t\tif (changed >= 0)\n\t\t\t\tchanged = 1;\t \n\t\t}\n\t\tmutex_unlock(&chip->mode_mutex);\n\t}\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_digital_mode_switch = {\n\t.name = \"Digital mode Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = snd_echo_digital_mode_info,\n\t.get = snd_echo_digital_mode_get,\n\t.put = snd_echo_digital_mode_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\n \nstatic int snd_echo_spdif_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const names[2] = {\"Consumer\", \"Professional\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, names);\n}\n\nstatic int snd_echo_spdif_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = !!chip->professional_spdif;\n\treturn 0;\n}\n\nstatic int snd_echo_spdif_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint mode;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tmode = !!ucontrol->value.enumerated.item[0];\n\tif (mode != chip->professional_spdif) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tset_professional_spdif(chip, mode);\n\t\tspin_unlock_irq(&chip->lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_spdif_mode_switch = {\n\t.name = \"S/PDIF mode Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = snd_echo_spdif_mode_info,\n\t.get = snd_echo_spdif_mode_get,\n\t.put = snd_echo_spdif_mode_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK\n\n \nstatic int snd_echo_clock_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const names[8] = {\n\t\t\"Internal\", \"Word\", \"Super\", \"S/PDIF\", \"ADAT\", \"ESync\",\n\t\t\"ESync96\", \"MTC\"\n\t};\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\treturn snd_ctl_enum_info(uinfo, 1, chip->num_clock_sources, names);\n}\n\nstatic int snd_echo_clock_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint i, clock;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tclock = chip->input_clock;\n\n\tfor (i = 0; i < chip->num_clock_sources; i++)\n\t\tif (clock == chip->clock_source_list[i])\n\t\t\tucontrol->value.enumerated.item[0] = i;\n\n\treturn 0;\n}\n\nstatic int snd_echo_clock_source_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint changed;\n\tunsigned int eclock, dclock;\n\n\tchanged = 0;\n\tchip = snd_kcontrol_chip(kcontrol);\n\teclock = ucontrol->value.enumerated.item[0];\n\tif (eclock >= chip->input_clock_types)\n\t\treturn -EINVAL;\n\tdclock = chip->clock_source_list[eclock];\n\tif (chip->input_clock != dclock) {\n\t\tmutex_lock(&chip->mode_mutex);\n\t\tspin_lock_irq(&chip->lock);\n\t\tchanged = set_input_clock(chip, dclock);\n\t\tif (!changed)\n\t\t\tchanged = 1;\t \n\t\tspin_unlock_irq(&chip->lock);\n\t\tmutex_unlock(&chip->mode_mutex);\n\t}\n\n\tif (changed < 0)\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"seticlk val%d err 0x%x\\n\", dclock, changed);\n\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_clock_source_switch = {\n\t.name = \"Sample Clock Source\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.info = snd_echo_clock_source_info,\n\t.get = snd_echo_clock_source_get,\n\t.put = snd_echo_clock_source_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_PHANTOM_POWER\n\n \n#define snd_echo_phantom_power_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_echo_phantom_power_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = chip->phantom_power;\n\treturn 0;\n}\n\nstatic int snd_echo_phantom_power_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\n\tint power, changed = 0;\n\n\tpower = !!ucontrol->value.integer.value[0];\n\tif (chip->phantom_power != power) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tchanged = set_phantom_power(chip, power);\n\t\tspin_unlock_irq(&chip->lock);\n\t\tif (changed == 0)\n\t\t\tchanged = 1;\t \n\t}\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_phantom_power_switch = {\n\t.name = \"Phantom power Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = snd_echo_phantom_power_info,\n\t.get = snd_echo_phantom_power_get,\n\t.put = snd_echo_phantom_power_put,\n};\n\n#endif  \n\n\n\n#ifdef ECHOCARD_HAS_DIGITAL_IN_AUTOMUTE\n\n \n#define snd_echo_automute_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_echo_automute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = chip->digital_in_automute;\n\treturn 0;\n}\n\nstatic int snd_echo_automute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip = snd_kcontrol_chip(kcontrol);\n\tint automute, changed = 0;\n\n\tautomute = !!ucontrol->value.integer.value[0];\n\tif (chip->digital_in_automute != automute) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tchanged = set_input_auto_mute(chip, automute);\n\t\tspin_unlock_irq(&chip->lock);\n\t\tif (changed == 0)\n\t\t\tchanged = 1;\t \n\t}\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_automute_switch = {\n\t.name = \"Digital Capture Switch (automute)\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.info = snd_echo_automute_info,\n\t.get = snd_echo_automute_get,\n\t.put = snd_echo_automute_put,\n};\n\n#endif  \n\n\n\n \n#define snd_echo_vumeters_switch_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_echo_vumeters_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&chip->lock);\n\tset_meters_on(chip, ucontrol->value.integer.value[0]);\n\tspin_unlock_irq(&chip->lock);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_vumeters_switch = {\n\t.name = \"VU-meters Switch\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_CARD,\n\t.access = SNDRV_CTL_ELEM_ACCESS_WRITE,\n\t.info = snd_echo_vumeters_switch_info,\n\t.put = snd_echo_vumeters_switch_put,\n};\n\n\n\n \nstatic int snd_echo_vumeters_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 96;\n\tuinfo->value.integer.min = ECHOGAIN_MINOUT;\n\tuinfo->value.integer.max = 0;\n\treturn 0;\n}\n\nstatic int snd_echo_vumeters_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tget_audio_meters(chip, ucontrol->value.integer.value);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_vumeters = {\n\t.name = \"VU-meters\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t  SNDRV_CTL_ELEM_ACCESS_VOLATILE |\n\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_READ,\n\t.info = snd_echo_vumeters_info,\n\t.get = snd_echo_vumeters_get,\n\t.tlv = {.p = db_scale_output_gain},\n};\n\n\n\n \nstatic int snd_echo_channels_info_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 6;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1 << ECHO_CLOCK_NUMBER;\n\treturn 0;\n}\n\nstatic int snd_echo_channels_info_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct echoaudio *chip;\n\tint detected, clocks, bit, src;\n\n\tchip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.integer.value[0] = num_busses_in(chip);\n\tucontrol->value.integer.value[1] = num_analog_busses_in(chip);\n\tucontrol->value.integer.value[2] = num_busses_out(chip);\n\tucontrol->value.integer.value[3] = num_analog_busses_out(chip);\n\tucontrol->value.integer.value[4] = num_pipes_out(chip);\n\n\t \n\tdetected = detect_input_clocks(chip);\n\tclocks = 0;\n\tsrc = chip->num_clock_sources - 1;\n\tfor (bit = ECHO_CLOCK_NUMBER - 1; bit >= 0; bit--)\n\t\tif (detected & (1 << bit))\n\t\t\tfor (; src >= 0; src--)\n\t\t\t\tif (bit == chip->clock_source_list[src]) {\n\t\t\t\t\tclocks |= 1 << src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\tucontrol->value.integer.value[5] = clocks;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new snd_echo_channels_info = {\n\t.name = \"Channels info\",\n\t.iface = SNDRV_CTL_ELEM_IFACE_HWDEP,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info = snd_echo_channels_info_info,\n\t.get = snd_echo_channels_info_get,\n};\n\n\n\n\n \n \nstatic bool period_has_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct audiopipe *pipe = runtime->private_data;\n\tu32 counter, step;\n\tsize_t period_bytes;\n\n\tif (pipe->state != PIPE_STATE_STARTED)\n\t\treturn false;\n\n\tperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\n\n\tcounter = le32_to_cpu(*pipe->dma_counter);   \n\n\tstep = counter - pipe->last_period;   \n\tstep -= step % period_bytes;   \n\n\tif (step == 0)\n\t\treturn false;   \n\n\tpipe->last_period += step;   \n\treturn true;\n}\n\nstatic irqreturn_t snd_echo_interrupt(int irq, void *dev_id)\n{\n\tstruct echoaudio *chip = dev_id;\n\tint ss, st;\n\n\tspin_lock(&chip->lock);\n\tst = service_irq(chip);\n\tif (st < 0) {\n\t\tspin_unlock(&chip->lock);\n\t\treturn IRQ_NONE;\n\t}\n\t \n\tfor (ss = 0; ss < DSP_MAXPIPES; ss++) {\n\t\tstruct snd_pcm_substream *substream;\n\n\t\tsubstream = chip->substream[ss];\n\t\tif (substream && period_has_elapsed(substream)) {\n\t\t\tspin_unlock(&chip->lock);\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t\t\tspin_lock(&chip->lock);\n\t\t}\n\t}\n\tspin_unlock(&chip->lock);\n\n#ifdef ECHOCARD_HAS_MIDI\n\tif (st > 0 && chip->midi_in) {\n\t\tsnd_rawmidi_receive(chip->midi_in, chip->midi_buffer, st);\n\t\tdev_dbg(chip->card->dev, \"rawmidi_iread=%d\\n\", st);\n\t}\n#endif\n\treturn IRQ_HANDLED;\n}\n\n\n\n\n \n\nstatic void snd_echo_free(struct snd_card *card)\n{\n\tstruct echoaudio *chip = card->private_data;\n\n\tif (chip->comm_page)\n\t\trest_in_peace(chip);\n\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, chip);\n\n\t \n\tfree_firmware_cache(chip);\n}\n\n \nstatic int snd_echo_create(struct snd_card *card,\n\t\t\t   struct pci_dev *pci)\n{\n\tstruct echoaudio *chip = card->private_data;\n\tint err;\n\tsize_t sz;\n\n\tpci_write_config_byte(pci, PCI_LATENCY_TIMER, 0xC0);\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_master(pci);\n\n\t \n\tspin_lock_init(&chip->lock);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->opencount = 0;\n\tmutex_init(&chip->mode_mutex);\n\tchip->can_set_rate = 1;\n\n\t \n\terr = pci_request_regions(pci, ECHOCARD_NAME);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->dsp_registers_phys = pci_resource_start(pci, 0);\n\tsz = pci_resource_len(pci, 0);\n\tif (sz > PAGE_SIZE)\n\t\tsz = PAGE_SIZE;\t\t \n\n\tchip->dsp_registers = devm_ioremap(&pci->dev, chip->dsp_registers_phys, sz);\n\tif (!chip->dsp_registers) {\n\t\tdev_err(chip->card->dev, \"ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (request_irq(pci->irq, snd_echo_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, chip)) {\n\t\tdev_err(chip->card->dev, \"cannot grab irq\\n\");\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tdev_dbg(card->dev, \"pci=%p irq=%d subdev=%04x Init hardware...\\n\",\n\t\tchip->pci, chip->irq, chip->pci->subsystem_device);\n\n\tcard->private_free = snd_echo_free;\n\n\t \n\tchip->commpage_dma_buf =\n\t\tsnd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t     sizeof(struct comm_page));\n\tif (!chip->commpage_dma_buf)\n\t\treturn -ENOMEM;\n\tchip->comm_page_phys = chip->commpage_dma_buf->addr;\n\tchip->comm_page = (struct comm_page *)chip->commpage_dma_buf->area;\n\n\terr = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);\n\tif (err >= 0)\n\t\terr = set_mixer_defaults(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"init_hw err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __snd_echo_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct echoaudio *chip;\n\tchar *dsp;\n\t__maybe_unused int i;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\ti = 0;\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_echo_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"Echo_\" ECHOCARD_NAME);\n\tstrcpy(card->shortname, chip->card_name);\n\n\tdsp = \"56301\";\n\tif (pci_id->device == 0x3410)\n\t\tdsp = \"56361\";\n\n\tsprintf(card->longname, \"%s rev.%d (DSP%s) at 0x%lx irq %i\",\n\t\tcard->shortname, pci_id->subdevice & 0x000f, dsp,\n\t\tchip->dsp_registers_phys, chip->irq);\n\n\terr = snd_echo_new_pcm(chip);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev, \"new pcm error %d\\n\", err);\n\t\treturn err;\n\t}\n\n#ifdef ECHOCARD_HAS_MIDI\n\tif (chip->has_midi) {\t \n\t\terr = snd_echo_midi_create(card, chip);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->card->dev, \"new midi error %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\n#ifdef ECHOCARD_HAS_VMIXER\n\tsnd_echo_vmixer.count = num_pipes_out(chip) * num_busses_out(chip);\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vmixer, chip));\n\tif (err < 0)\n\t\treturn err;\n#ifdef ECHOCARD_HAS_LINE_OUT_GAIN\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&snd_echo_line_output_gain, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n#else  \n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&snd_echo_pcm_output_gain, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif  \n\n#ifdef ECHOCARD_HAS_INPUT_GAIN\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_line_input_gain, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n#ifdef ECHOCARD_HAS_INPUT_NOMINAL_LEVEL\n\tif (!chip->hasnt_input_nominal_level) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_intput_nominal_level, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif\n\n#ifdef ECHOCARD_HAS_OUTPUT_NOMINAL_LEVEL\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_output_nominal_level, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters_switch, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters, chip));\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef ECHOCARD_HAS_MONITOR\n\tsnd_echo_monitor_mixer.count = num_busses_in(chip) * num_busses_out(chip);\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_monitor_mixer, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n#ifdef ECHOCARD_HAS_DIGITAL_IN_AUTOMUTE\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_automute_switch, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_channels_info, chip));\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH\n\t \n\tchip->num_digital_modes = 0;\n\tfor (i = 0; i < 6; i++)\n\t\tif (chip->digital_modes & (1 << i))\n\t\t\tchip->digital_mode_list[chip->num_digital_modes++] = i;\n\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_digital_mode_switch, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif  \n\n#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK\n\t \n\tchip->num_clock_sources = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tif (chip->input_clock_types & (1 << i))\n\t\t\tchip->clock_source_list[chip->num_clock_sources++] = i;\n\n\tif (chip->num_clock_sources > 1) {\n\t\tchip->clock_src_ctl = snd_ctl_new1(&snd_echo_clock_source_switch, chip);\n\t\terr = snd_ctl_add(chip->card, chip->clock_src_ctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif  \n\n#ifdef ECHOCARD_HAS_DIGITAL_IO\n\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_spdif_mode_switch, chip));\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n#ifdef ECHOCARD_HAS_PHANTOM_POWER\n\tif (chip->has_phantom_power) {\n\t\terr = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_phantom_power_switch, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tdev_info(card->dev, \"Card registered: %s\\n\", card->longname);\n\n\tpci_set_drvdata(pci, chip);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_echo_probe(struct pci_dev *pci,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_echo_probe(pci, pci_id));\n}\n\n\n#if defined(CONFIG_PM_SLEEP)\n\nstatic int snd_echo_suspend(struct device *dev)\n{\n\tstruct echoaudio *chip = dev_get_drvdata(dev);\n\n#ifdef ECHOCARD_HAS_MIDI\n\t \n\tif (chip->midi_out)\n\t\tsnd_echo_midi_output_trigger(chip->midi_out, 0);\n#endif\n\tspin_lock_irq(&chip->lock);\n\tif (wait_handshake(chip)) {\n\t\tspin_unlock_irq(&chip->lock);\n\t\treturn -EIO;\n\t}\n\tclear_handshake(chip);\n\tif (send_vector(chip, DSP_VC_GO_COMATOSE) < 0) {\n\t\tspin_unlock_irq(&chip->lock);\n\t\treturn -EIO;\n\t}\n\tspin_unlock_irq(&chip->lock);\n\n\tchip->dsp_code = NULL;\n\tfree_irq(chip->irq, chip);\n\tchip->irq = -1;\n\tchip->card->sync_irq = -1;\n\treturn 0;\n}\n\n\n\nstatic int snd_echo_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct echoaudio *chip = dev_get_drvdata(dev);\n\tstruct comm_page *commpage, *commpage_bak;\n\tu32 pipe_alloc_mask;\n\tint err;\n\n\tcommpage = chip->comm_page;\n\tcommpage_bak = kmemdup(commpage, sizeof(*commpage), GFP_KERNEL);\n\tif (commpage_bak == NULL)\n\t\treturn -ENOMEM;\n\n\terr = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);\n\tif (err < 0) {\n\t\tkfree(commpage_bak);\n\t\tdev_err(dev, \"resume init_hw err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tpipe_alloc_mask = chip->pipe_alloc_mask;\n\tchip->pipe_alloc_mask = 0;\n\terr = restore_dsp_rettings(chip);\n\tchip->pipe_alloc_mask = pipe_alloc_mask;\n\tif (err < 0) {\n\t\tkfree(commpage_bak);\n\t\treturn err;\n\t}\n\n\tmemcpy(&commpage->audio_format, &commpage_bak->audio_format,\n\t\tsizeof(commpage->audio_format));\n\tmemcpy(&commpage->sglist_addr, &commpage_bak->sglist_addr,\n\t\tsizeof(commpage->sglist_addr));\n\tmemcpy(&commpage->midi_output, &commpage_bak->midi_output,\n\t\tsizeof(commpage->midi_output));\n\tkfree(commpage_bak);\n\n\tif (request_irq(pci->irq, snd_echo_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, chip)) {\n\t\tdev_err(chip->card->dev, \"cannot grab irq\\n\");\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tchip->card->sync_irq = chip->irq;\n\tdev_dbg(dev, \"resume irq=%d\\n\", chip->irq);\n\n#ifdef ECHOCARD_HAS_MIDI\n\tif (chip->midi_input_enabled)\n\t\tenable_midi_input(chip, true);\n\tif (chip->midi_out)\n\t\tsnd_echo_midi_output_trigger(chip->midi_out, 1);\n#endif\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_echo_pm, snd_echo_suspend, snd_echo_resume);\n#define SND_ECHO_PM_OPS\t&snd_echo_pm\n#else\n#define SND_ECHO_PM_OPS\tNULL\n#endif  \n\n \n\n \nstatic struct pci_driver echo_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_echo_ids,\n\t.probe = snd_echo_probe,\n\t.driver = {\n\t\t.pm = SND_ECHO_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(echo_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}