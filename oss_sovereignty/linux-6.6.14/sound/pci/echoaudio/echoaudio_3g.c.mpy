{
  "module_name": "echoaudio_3g.c",
  "hash_id": "e0b78bf0c7a07c2e6d1a27f575168d26c140eab1f57e124b36c37069f26e5b22",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/echoaudio_3g.c",
  "human_readable_source": " \n\n\n\n \n\n\nstatic int check_asic_status(struct echoaudio *chip)\n{\n\tu32 box_status;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->comm_page->ext_box_status = cpu_to_le32(E3G_ASIC_NOT_LOADED);\n\tchip->asic_loaded = false;\n\tclear_handshake(chip);\n\tsend_vector(chip, DSP_VC_TEST_ASIC);\n\n\tif (wait_handshake(chip)) {\n\t\tchip->dsp_code = NULL;\n\t\treturn -EIO;\n\t}\n\n\tbox_status = le32_to_cpu(chip->comm_page->ext_box_status);\n\tdev_dbg(chip->card->dev, \"box_status=%x\\n\", box_status);\n\tif (box_status == E3G_ASIC_NOT_LOADED)\n\t\treturn -ENODEV;\n\n\tchip->asic_loaded = true;\n\treturn box_status & E3G_BOX_TYPE_MASK;\n}\n\n\n\nstatic inline u32 get_frq_reg(struct echoaudio *chip)\n{\n\treturn le32_to_cpu(chip->comm_page->e3g_frq_register);\n}\n\n\n\n \nstatic int write_control_reg(struct echoaudio *chip, u32 ctl, u32 frq,\n\t\t\t     char force)\n{\n\t__le32 ctl_reg, frq_reg;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tdev_dbg(chip->card->dev,\n\t\t\"WriteControlReg: Setting 0x%x, 0x%x\\n\", ctl, frq);\n\n\tctl_reg = cpu_to_le32(ctl);\n\tfrq_reg = cpu_to_le32(frq);\n\n\tif (ctl_reg != chip->comm_page->control_register ||\n\t    frq_reg != chip->comm_page->e3g_frq_register || force) {\n\t\tchip->comm_page->e3g_frq_register = frq_reg;\n\t\tchip->comm_page->control_register = ctl_reg;\n\t\tclear_handshake(chip);\n\t\treturn send_vector(chip, DSP_VC_WRITE_CONTROL_REG);\n\t}\n\n\tdev_dbg(chip->card->dev, \"WriteControlReg: not written, no change\\n\");\n\treturn 0;\n}\n\n\n\n \nstatic int set_digital_mode(struct echoaudio *chip, u8 mode)\n{\n\tu8 previous_mode;\n\tint err, i, o;\n\n\t \n\tif (snd_BUG_ON(chip->pipe_alloc_mask))\n\t\treturn -EAGAIN;\n\n\tif (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))\n\t\treturn -EINVAL;\n\n\tprevious_mode = chip->digital_mode;\n\terr = dsp_set_digital_mode(chip, mode);\n\n\t \n\tif (err >= 0 && previous_mode != mode &&\n\t    (previous_mode == DIGITAL_MODE_ADAT || mode == DIGITAL_MODE_ADAT)) {\n\t\tspin_lock_irq(&chip->lock);\n\t\tfor (o = 0; o < num_busses_out(chip); o++)\n\t\t\tfor (i = 0; i < num_busses_in(chip); i++)\n\t\t\t\tset_monitor_gain(chip, o, i,\n\t\t\t\t\t\t chip->monitor_gain[o][i]);\n\n#ifdef ECHOCARD_HAS_INPUT_GAIN\n\t\tfor (i = 0; i < num_busses_in(chip); i++)\n\t\t\tset_input_gain(chip, i, chip->input_gain[i]);\n\t\tupdate_input_line_level(chip);\n#endif\n\n\t\tfor (o = 0; o < num_busses_out(chip); o++)\n\t\t\tset_output_gain(chip, o, chip->output_gain[o]);\n\t\tupdate_output_line_level(chip);\n\t\tspin_unlock_irq(&chip->lock);\n\t}\n\n\treturn err;\n}\n\n\n\nstatic u32 set_spdif_bits(struct echoaudio *chip, u32 control_reg, u32 rate)\n{\n\tcontrol_reg &= E3G_SPDIF_FORMAT_CLEAR_MASK;\n\n\tswitch (rate) {\n\tcase 32000 :\n\t\tcontrol_reg |= E3G_SPDIF_SAMPLE_RATE0 | E3G_SPDIF_SAMPLE_RATE1;\n\t\tbreak;\n\tcase 44100 :\n\t\tif (chip->professional_spdif)\n\t\t\tcontrol_reg |= E3G_SPDIF_SAMPLE_RATE0;\n\t\tbreak;\n\tcase 48000 :\n\t\tcontrol_reg |= E3G_SPDIF_SAMPLE_RATE1;\n\t\tbreak;\n\t}\n\n\tif (chip->professional_spdif)\n\t\tcontrol_reg |= E3G_SPDIF_PRO_MODE;\n\n\tif (chip->non_audio_spdif)\n\t\tcontrol_reg |= E3G_SPDIF_NOT_AUDIO;\n\n\tcontrol_reg |= E3G_SPDIF_24_BIT | E3G_SPDIF_TWO_CHANNEL |\n\t\tE3G_SPDIF_COPY_PERMIT;\n\n\treturn control_reg;\n}\n\n\n\n \nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\n{\n\tu32 control_reg;\n\n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tchip->professional_spdif = prof;\n\tcontrol_reg = set_spdif_bits(chip, control_reg, chip->sample_rate);\n\treturn write_control_reg(chip, control_reg, get_frq_reg(chip), 0);\n}\n\n\n\n \nstatic u32 detect_input_clocks(const struct echoaudio *chip)\n{\n\tu32 clocks_from_dsp, clock_bits;\n\n\t \n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tclock_bits = ECHO_CLOCK_BIT_INTERNAL;\n\n\tif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_WORD)\n\t\tclock_bits |= ECHO_CLOCK_BIT_WORD;\n\n\tswitch(chip->digital_mode) {\n\tcase DIGITAL_MODE_SPDIF_RCA:\n\tcase DIGITAL_MODE_SPDIF_OPTICAL:\n\t\tif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_SPDIF)\n\t\t\tclock_bits |= ECHO_CLOCK_BIT_SPDIF;\n\t\tbreak;\n\tcase DIGITAL_MODE_ADAT:\n\t\tif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_ADAT)\n\t\t\tclock_bits |= ECHO_CLOCK_BIT_ADAT;\n\t\tbreak;\n\t}\n\n\treturn clock_bits;\n}\n\n\n\nstatic int load_asic(struct echoaudio *chip)\n{\n\tint box_type, err;\n\n\tif (chip->asic_loaded)\n\t\treturn 0;\n\n\t \n\tmdelay(2);\n\n\terr = load_asic_generic(chip, DSP_FNC_LOAD_3G_ASIC, FW_3G_ASIC);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->asic_code = FW_3G_ASIC;\n\n\t \n\tmsleep(1000);\n\t \n\tbox_type = check_asic_status(chip);\n\n\t \n\tif (box_type >= 0) {\n\t\terr = write_control_reg(chip, E3G_48KHZ,\n\t\t\t\t\tE3G_FREQ_REG_DEFAULT, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn box_type;\n}\n\n\n\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\n{\n\tu32 control_reg, clock, base_rate, frq_reg;\n\n\t \n\tif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t \"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\\n\");\n\t\t \n\t\tchip->comm_page->sample_rate = cpu_to_le32(rate);\n\t\tchip->sample_rate = rate;\n\t\tset_input_clock(chip, chip->input_clock);\n\t\treturn 0;\n\t}\n\n\tif (snd_BUG_ON(rate >= 50000 &&\n\t\t       chip->digital_mode == DIGITAL_MODE_ADAT))\n\t\treturn -EINVAL;\n\n\tclock = 0;\n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tcontrol_reg &= E3G_CLOCK_CLEAR_MASK;\n\n\tswitch (rate) {\n\tcase 96000:\n\t\tclock = E3G_96KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tclock = E3G_88KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tclock = E3G_48KHZ;\n\t\tbreak;\n\tcase 44100:\n\t\tclock = E3G_44KHZ;\n\t\tbreak;\n\tcase 32000:\n\t\tclock = E3G_32KHZ;\n\t\tbreak;\n\tdefault:\n\t\tclock = E3G_CONTINUOUS_CLOCK;\n\t\tif (rate > 50000)\n\t\t\tclock |= E3G_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\t}\n\n\tcontrol_reg |= clock;\n\tcontrol_reg = set_spdif_bits(chip, control_reg, rate);\n\n\tbase_rate = rate;\n\tif (base_rate > 50000)\n\t\tbase_rate /= 2;\n\tif (base_rate < 32000)\n\t\tbase_rate = 32000;\n\n\tfrq_reg = E3G_MAGIC_NUMBER / base_rate - 2;\n\tif (frq_reg > E3G_FREQ_REG_MAX)\n\t\tfrq_reg = E3G_FREQ_REG_MAX;\n\n\tchip->comm_page->sample_rate = cpu_to_le32(rate);\t \n\tchip->sample_rate = rate;\n\tdev_dbg(chip->card->dev,\n\t\t\"SetSampleRate: %d clock %x\\n\", rate, control_reg);\n\n\t \n\treturn write_control_reg(chip, control_reg, frq_reg, 0);\n}\n\n\n\n \nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\n{\n\tu32 control_reg, clocks_from_dsp;\n\n\n\t \n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\n\t\tE3G_CLOCK_CLEAR_MASK;\n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tswitch (clock) {\n\tcase ECHO_CLOCK_INTERNAL:\n\t\tchip->input_clock = ECHO_CLOCK_INTERNAL;\n\t\treturn set_sample_rate(chip, chip->sample_rate);\n\tcase ECHO_CLOCK_SPDIF:\n\t\tif (chip->digital_mode == DIGITAL_MODE_ADAT)\n\t\t\treturn -EAGAIN;\n\t\tcontrol_reg |= E3G_SPDIF_CLOCK;\n\t\tif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_SPDIF96)\n\t\t\tcontrol_reg |= E3G_DOUBLE_SPEED_MODE;\n\t\telse\n\t\t\tcontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tcase ECHO_CLOCK_ADAT:\n\t\tif (chip->digital_mode != DIGITAL_MODE_ADAT)\n\t\t\treturn -EAGAIN;\n\t\tcontrol_reg |= E3G_ADAT_CLOCK;\n\t\tcontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tcase ECHO_CLOCK_WORD:\n\t\tcontrol_reg |= E3G_WORD_CLOCK;\n\t\tif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_WORD96)\n\t\t\tcontrol_reg |= E3G_DOUBLE_SPEED_MODE;\n\t\telse\n\t\t\tcontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Input clock 0x%x not supported for Echo3G\\n\", clock);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->input_clock = clock;\n\treturn write_control_reg(chip, control_reg, get_frq_reg(chip), 1);\n}\n\n\n\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\n{\n\tu32 control_reg;\n\tint err, incompatible_clock;\n\n\t \n\tincompatible_clock = false;\n\tswitch (mode) {\n\tcase DIGITAL_MODE_SPDIF_OPTICAL:\n\tcase DIGITAL_MODE_SPDIF_RCA:\n\t\tif (chip->input_clock == ECHO_CLOCK_ADAT)\n\t\t\tincompatible_clock = true;\n\t\tbreak;\n\tcase DIGITAL_MODE_ADAT:\n\t\tif (chip->input_clock == ECHO_CLOCK_SPDIF)\n\t\t\tincompatible_clock = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Digital mode not supported: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&chip->lock);\n\n\tif (incompatible_clock) {\n\t\tchip->sample_rate = 48000;\n\t\tset_input_clock(chip, ECHO_CLOCK_INTERNAL);\n\t}\n\n\t \n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tcontrol_reg &= E3G_DIGITAL_MODE_CLEAR_MASK;\n\n\t \n\tswitch (mode) {\n\tcase DIGITAL_MODE_SPDIF_OPTICAL:\n\t\tcontrol_reg |= E3G_SPDIF_OPTICAL_MODE;\n\t\tbreak;\n\tcase DIGITAL_MODE_SPDIF_RCA:\n\t\t \n\t\tbreak;\n\tcase DIGITAL_MODE_ADAT:\n\t\tcontrol_reg |= E3G_ADAT_MODE;\n\t\tcontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\t \n\t\tbreak;\n\t}\n\n\terr = write_control_reg(chip, control_reg, get_frq_reg(chip), 1);\n\tspin_unlock_irq(&chip->lock);\n\tif (err < 0)\n\t\treturn err;\n\tchip->digital_mode = mode;\n\n\tdev_dbg(chip->card->dev, \"set_digital_mode(%d)\\n\", chip->digital_mode);\n\treturn incompatible_clock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}