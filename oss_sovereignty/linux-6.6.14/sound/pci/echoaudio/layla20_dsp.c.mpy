{
  "module_name": "layla20_dsp.c",
  "hash_id": "906aaf78e44a85bb5a8c9b62fa51b1c86d06a9dc17d918ae2fa3fc7217c9abe9",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/layla20_dsp.c",
  "human_readable_source": " \n\n\nstatic int read_dsp(struct echoaudio *chip, u32 *data);\nstatic int set_professional_spdif(struct echoaudio *chip, char prof);\nstatic int load_asic_generic(struct echoaudio *chip, u32 cmd, short asic);\nstatic int check_asic_status(struct echoaudio *chip);\nstatic int update_flags(struct echoaudio *chip);\n\n\nstatic int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\n{\n\tint err;\n\n\tif (snd_BUG_ON((subdevice_id & 0xfff0) != LAYLA20))\n\t\treturn -ENODEV;\n\n\terr = init_dsp_comm_page(chip);\n\tif (err) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"init_hw - could not initialize DSP comm page\\n\");\n\t\treturn err;\n\t}\n\n\tchip->device_id = device_id;\n\tchip->subdevice_id = subdevice_id;\n\tchip->bad_board = true;\n\tchip->has_midi = true;\n\tchip->dsp_code_to_load = FW_LAYLA20_DSP;\n\tchip->input_clock_types =\n\t\tECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\n\t\tECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_SUPER;\n\tchip->output_clock_types =\n\t\tECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_SUPER;\n\n\terr = load_firmware(chip);\n\tif (err < 0)\n\t\treturn err;\n\tchip->bad_board = false;\n\n\treturn err;\n}\n\n\n\nstatic int set_mixer_defaults(struct echoaudio *chip)\n{\n\tchip->professional_spdif = false;\n\treturn init_line_levels(chip);\n}\n\n\n\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\n{\n\tu32 clocks_from_dsp, clock_bits;\n\n\t \n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tclock_bits = ECHO_CLOCK_BIT_INTERNAL;\n\n\tif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_SPDIF)\n\t\tclock_bits |= ECHO_CLOCK_BIT_SPDIF;\n\n\tif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_WORD) {\n\t\tif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_SUPER)\n\t\t\tclock_bits |= ECHO_CLOCK_BIT_SUPER;\n\t\telse\n\t\t\tclock_bits |= ECHO_CLOCK_BIT_WORD;\n\t}\n\n\treturn clock_bits;\n}\n\n\n\n \nstatic int check_asic_status(struct echoaudio *chip)\n{\n\tu32 asic_status;\n\tint goodcnt, i;\n\n\tchip->asic_loaded = false;\n\tfor (i = goodcnt = 0; i < 5; i++) {\n\t\tsend_vector(chip, DSP_VC_TEST_ASIC);\n\n\t\t \n\t\tif (read_dsp(chip, &asic_status) < 0) {\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"check_asic_status: failed on read_dsp\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (asic_status == ASIC_ALREADY_LOADED) {\n\t\t\tif (++goodcnt == 3) {\n\t\t\t\tchip->asic_loaded = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -EIO;\n}\n\n\n\n \nstatic int load_asic(struct echoaudio *chip)\n{\n\tint err;\n\n\tif (chip->asic_loaded)\n\t\treturn 0;\n\n\terr = load_asic_generic(chip, DSP_FNC_LOAD_LAYLA_ASIC,\n\t\t\t\tFW_LAYLA20_ASIC);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn check_asic_status(chip);\n}\n\n\n\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\n{\n\tif (snd_BUG_ON(rate < 8000 || rate > 50000))\n\t\treturn -EINVAL;\n\n\t \n\tif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\n\t\tdev_warn(chip->card->dev,\n\t\t\t \"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\\n\");\n\t\tchip->comm_page->sample_rate = cpu_to_le32(rate);\n\t\tchip->sample_rate = rate;\n\t\treturn 0;\n\t}\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tdev_dbg(chip->card->dev, \"set_sample_rate(%d)\\n\", rate);\n\tchip->sample_rate = rate;\n\tchip->comm_page->sample_rate = cpu_to_le32(rate);\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_SET_LAYLA_SAMPLE_RATE);\n}\n\n\n\nstatic int set_input_clock(struct echoaudio *chip, u16 clock_source)\n{\n\tu16 clock;\n\tu32 rate;\n\n\trate = 0;\n\tswitch (clock_source) {\n\tcase ECHO_CLOCK_INTERNAL:\n\t\trate = chip->sample_rate;\n\t\tclock = LAYLA20_CLOCK_INTERNAL;\n\t\tbreak;\n\tcase ECHO_CLOCK_SPDIF:\n\t\tclock = LAYLA20_CLOCK_SPDIF;\n\t\tbreak;\n\tcase ECHO_CLOCK_WORD:\n\t\tclock = LAYLA20_CLOCK_WORD;\n\t\tbreak;\n\tcase ECHO_CLOCK_SUPER:\n\t\tclock = LAYLA20_CLOCK_SUPER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Input clock 0x%x not supported for Layla24\\n\",\n\t\t\tclock_source);\n\t\treturn -EINVAL;\n\t}\n\tchip->input_clock = clock_source;\n\n\tchip->comm_page->input_clock = cpu_to_le16(clock);\n\tclear_handshake(chip);\n\tsend_vector(chip, DSP_VC_UPDATE_CLOCKS);\n\n\tif (rate)\n\t\tset_sample_rate(chip, rate);\n\n\treturn 0;\n}\n\n\n\nstatic int set_output_clock(struct echoaudio *chip, u16 clock)\n{\n\tswitch (clock) {\n\tcase ECHO_CLOCK_SUPER:\n\t\tclock = LAYLA20_OUTPUT_CLOCK_SUPER;\n\t\tbreak;\n\tcase ECHO_CLOCK_WORD:\n\t\tclock = LAYLA20_OUTPUT_CLOCK_WORD;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev, \"set_output_clock wrong clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->comm_page->output_clock = cpu_to_le16(clock);\n\tchip->output_clock = clock;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_CLOCKS);\n}\n\n\n\n \nstatic int set_input_gain(struct echoaudio *chip, u16 input, int gain)\n{\n\tif (snd_BUG_ON(input >= num_busses_in(chip)))\n\t\treturn -EINVAL;\n\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\n\tchip->input_gain[input] = gain;\n\tgain += GL20_INPUT_GAIN_MAGIC_NUMBER;\n\tchip->comm_page->line_in_level[input] = gain;\n\treturn 0;\n}\n\n\n\n \nstatic int update_flags(struct echoaudio *chip)\n{\n\tif (wait_handshake(chip))\n\t\treturn -EIO;\n\tclear_handshake(chip);\n\treturn send_vector(chip, DSP_VC_UPDATE_FLAGS);\n}\n\n\n\nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\n{\n\tif (prof)\n\t\tchip->comm_page->flags |=\n\t\t\tcpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\n\telse\n\t\tchip->comm_page->flags &=\n\t\t\t~cpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\n\tchip->professional_spdif = prof;\n\treturn update_flags(chip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}