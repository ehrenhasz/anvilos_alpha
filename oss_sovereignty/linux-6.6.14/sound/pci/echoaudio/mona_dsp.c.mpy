{
  "module_name": "mona_dsp.c",
  "hash_id": "43933ea05d6928bac6400a1973d7160db8834c91cc44e5c198821c92a15c1e0e",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/echoaudio/mona_dsp.c",
  "human_readable_source": " \n\n\nstatic int write_control_reg(struct echoaudio *chip, u32 value, char force);\nstatic int set_input_clock(struct echoaudio *chip, u16 clock);\nstatic int set_professional_spdif(struct echoaudio *chip, char prof);\nstatic int set_digital_mode(struct echoaudio *chip, u8 mode);\nstatic int load_asic_generic(struct echoaudio *chip, u32 cmd, short asic);\nstatic int check_asic_status(struct echoaudio *chip);\n\n\nstatic int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\n{\n\tint err;\n\n\tif (snd_BUG_ON((subdevice_id & 0xfff0) != MONA))\n\t\treturn -ENODEV;\n\n\terr = init_dsp_comm_page(chip);\n\tif (err) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"init_hw - could not initialize DSP comm page\\n\");\n\t\treturn err;\n\t}\n\n\tchip->device_id = device_id;\n\tchip->subdevice_id = subdevice_id;\n\tchip->bad_board = true;\n\tchip->input_clock_types =\n\t\tECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\n\t\tECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_ADAT;\n\tchip->digital_modes =\n\t\tECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |\n\t\tECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL |\n\t\tECHOCAPS_HAS_DIGITAL_MODE_ADAT;\n\n\t \n\tif (chip->device_id == DEVICE_ID_56361)\n\t\tchip->dsp_code_to_load = FW_MONA_361_DSP;\n\telse\n\t\tchip->dsp_code_to_load = FW_MONA_301_DSP;\n\n\terr = load_firmware(chip);\n\tif (err < 0)\n\t\treturn err;\n\tchip->bad_board = false;\n\n\treturn err;\n}\n\n\n\nstatic int set_mixer_defaults(struct echoaudio *chip)\n{\n\tchip->digital_mode = DIGITAL_MODE_SPDIF_RCA;\n\tchip->professional_spdif = false;\n\tchip->digital_in_automute = true;\n\treturn init_line_levels(chip);\n}\n\n\n\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\n{\n\tu32 clocks_from_dsp, clock_bits;\n\n\t \n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tclock_bits = ECHO_CLOCK_BIT_INTERNAL;\n\n\tif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF)\n\t\tclock_bits |= ECHO_CLOCK_BIT_SPDIF;\n\n\tif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_ADAT)\n\t\tclock_bits |= ECHO_CLOCK_BIT_ADAT;\n\n\tif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD)\n\t\tclock_bits |= ECHO_CLOCK_BIT_WORD;\n\n\treturn clock_bits;\n}\n\n\n\n \nstatic int load_asic(struct echoaudio *chip)\n{\n\tu32 control_reg;\n\tint err;\n\tshort asic;\n\n\tif (chip->asic_loaded)\n\t\treturn 0;\n\n\tmdelay(10);\n\n\tif (chip->device_id == DEVICE_ID_56361)\n\t\tasic = FW_MONA_361_1_ASIC48;\n\telse\n\t\tasic = FW_MONA_301_1_ASIC48;\n\n\terr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC, asic);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->asic_code = asic;\n\tmdelay(10);\n\n\t \n\terr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_EXTERNAL_ASIC,\n\t\t\t\tFW_MONA_2_ASIC);\n\tif (err < 0)\n\t\treturn err;\n\n\tmdelay(10);\n\terr = check_asic_status(chip);\n\n\t \n\tif (!err) {\n\t\tcontrol_reg = GML_CONVERTER_ENABLE | GML_48KHZ;\n\t\terr = write_control_reg(chip, control_reg, true);\n\t}\n\n\treturn err;\n}\n\n\n\n \nstatic int switch_asic(struct echoaudio *chip, char double_speed)\n{\n\tint err;\n\tshort asic;\n\n\t \n\tif (chip->device_id == DEVICE_ID_56361) {\n\t\tif (double_speed)\n\t\t\tasic = FW_MONA_361_1_ASIC96;\n\t\telse\n\t\t\tasic = FW_MONA_361_1_ASIC48;\n\t} else {\n\t\tif (double_speed)\n\t\t\tasic = FW_MONA_301_1_ASIC96;\n\t\telse\n\t\t\tasic = FW_MONA_301_1_ASIC48;\n\t}\n\n\tif (asic != chip->asic_code) {\n\t\t \n\t\terr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC,\n\t\t\t\t\tasic);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->asic_code = asic;\n\t}\n\n\treturn 0;\n}\n\n\n\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\n{\n\tu32 control_reg, clock;\n\tshort asic;\n\tchar force_write;\n\n\t \n\tif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\\n\");\n\t\t \n\t\tchip->comm_page->sample_rate = cpu_to_le32(rate);\n\t\tchip->sample_rate = rate;\n\t\treturn 0;\n\t}\n\n\t \n\tif (rate >= 88200) {\n\t\tif (chip->digital_mode == DIGITAL_MODE_ADAT)\n\t\t\treturn -EINVAL;\n\t\tif (chip->device_id == DEVICE_ID_56361)\n\t\t\tasic = FW_MONA_361_1_ASIC96;\n\t\telse\n\t\t\tasic = FW_MONA_301_1_ASIC96;\n\t} else {\n\t\tif (chip->device_id == DEVICE_ID_56361)\n\t\t\tasic = FW_MONA_361_1_ASIC48;\n\t\telse\n\t\t\tasic = FW_MONA_301_1_ASIC48;\n\t}\n\n\tforce_write = 0;\n\tif (asic != chip->asic_code) {\n\t\tint err;\n\t\t \n\t\tspin_unlock_irq(&chip->lock);\n\t\terr = load_asic_generic(chip, DSP_FNC_LOAD_MONA_PCI_CARD_ASIC,\n\t\t\t\t\tasic);\n\t\tspin_lock_irq(&chip->lock);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tchip->asic_code = asic;\n\t\tforce_write = 1;\n\t}\n\n\t \n\tclock = 0;\n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tcontrol_reg &= GML_CLOCK_CLEAR_MASK;\n\tcontrol_reg &= GML_SPDIF_RATE_CLEAR_MASK;\n\n\tswitch (rate) {\n\tcase 96000:\n\t\tclock = GML_96KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tclock = GML_88KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tclock = GML_48KHZ | GML_SPDIF_SAMPLE_RATE1;\n\t\tbreak;\n\tcase 44100:\n\t\tclock = GML_44KHZ;\n\t\t \n\t\tif (control_reg & GML_SPDIF_PRO_MODE)\n\t\t\tclock |= GML_SPDIF_SAMPLE_RATE0;\n\t\tbreak;\n\tcase 32000:\n\t\tclock = GML_32KHZ | GML_SPDIF_SAMPLE_RATE0 |\n\t\t\tGML_SPDIF_SAMPLE_RATE1;\n\t\tbreak;\n\tcase 22050:\n\t\tclock = GML_22KHZ;\n\t\tbreak;\n\tcase 16000:\n\t\tclock = GML_16KHZ;\n\t\tbreak;\n\tcase 11025:\n\t\tclock = GML_11KHZ;\n\t\tbreak;\n\tcase 8000:\n\t\tclock = GML_8KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"set_sample_rate: %d invalid!\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tcontrol_reg |= clock;\n\n\tchip->comm_page->sample_rate = cpu_to_le32(rate);\t \n\tchip->sample_rate = rate;\n\tdev_dbg(chip->card->dev,\n\t\t\"set_sample_rate: %d clock %d\\n\", rate, clock);\n\n\treturn write_control_reg(chip, control_reg, force_write);\n}\n\n\n\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\n{\n\tu32 control_reg, clocks_from_dsp;\n\tint err;\n\n\t \n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\n\t\tGML_CLOCK_CLEAR_MASK;\n\tclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\n\n\tswitch (clock) {\n\tcase ECHO_CLOCK_INTERNAL:\n\t\tchip->input_clock = ECHO_CLOCK_INTERNAL;\n\t\treturn set_sample_rate(chip, chip->sample_rate);\n\tcase ECHO_CLOCK_SPDIF:\n\t\tif (chip->digital_mode == DIGITAL_MODE_ADAT)\n\t\t\treturn -EAGAIN;\n\t\tspin_unlock_irq(&chip->lock);\n\t\terr = switch_asic(chip, clocks_from_dsp &\n\t\t\t\t  GML_CLOCK_DETECT_BIT_SPDIF96);\n\t\tspin_lock_irq(&chip->lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcontrol_reg |= GML_SPDIF_CLOCK;\n\t\tif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF96)\n\t\t\tcontrol_reg |= GML_DOUBLE_SPEED_MODE;\n\t\telse\n\t\t\tcontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tcase ECHO_CLOCK_WORD:\n\t\tspin_unlock_irq(&chip->lock);\n\t\terr = switch_asic(chip, clocks_from_dsp &\n\t\t\t\t  GML_CLOCK_DETECT_BIT_WORD96);\n\t\tspin_lock_irq(&chip->lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcontrol_reg |= GML_WORD_CLOCK;\n\t\tif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_WORD96)\n\t\t\tcontrol_reg |= GML_DOUBLE_SPEED_MODE;\n\t\telse\n\t\t\tcontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tcase ECHO_CLOCK_ADAT:\n\t\tdev_dbg(chip->card->dev, \"Set Mona clock to ADAT\\n\");\n\t\tif (chip->digital_mode != DIGITAL_MODE_ADAT)\n\t\t\treturn -EAGAIN;\n\t\tcontrol_reg |= GML_ADAT_CLOCK;\n\t\tcontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Input clock 0x%x not supported for Mona\\n\", clock);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->input_clock = clock;\n\treturn write_control_reg(chip, control_reg, true);\n}\n\n\n\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\n{\n\tu32 control_reg;\n\tint err, incompatible_clock;\n\n\t \n\tincompatible_clock = false;\n\tswitch (mode) {\n\tcase DIGITAL_MODE_SPDIF_OPTICAL:\n\tcase DIGITAL_MODE_SPDIF_RCA:\n\t\tif (chip->input_clock == ECHO_CLOCK_ADAT)\n\t\t\tincompatible_clock = true;\n\t\tbreak;\n\tcase DIGITAL_MODE_ADAT:\n\t\tif (chip->input_clock == ECHO_CLOCK_SPDIF)\n\t\t\tincompatible_clock = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Digital mode not supported: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&chip->lock);\n\n\tif (incompatible_clock) {\t \n\t\tchip->sample_rate = 48000;\n\t\tset_input_clock(chip, ECHO_CLOCK_INTERNAL);\n\t}\n\n\t \n\tcontrol_reg = le32_to_cpu(chip->comm_page->control_register);\n\tcontrol_reg &= GML_DIGITAL_MODE_CLEAR_MASK;\n\n\t \n\tswitch (mode) {\n\tcase DIGITAL_MODE_SPDIF_OPTICAL:\n\t\tcontrol_reg |= GML_SPDIF_OPTICAL_MODE;\n\t\tbreak;\n\tcase DIGITAL_MODE_SPDIF_RCA:\n\t\t \n\t\tbreak;\n\tcase DIGITAL_MODE_ADAT:\n\t\t \n\t\tif (chip->asic_code == FW_MONA_361_1_ASIC96 ||\n\t\t    chip->asic_code == FW_MONA_301_1_ASIC96) {\n\t\t\tset_sample_rate(chip, 48000);\n\t\t}\n\t\tcontrol_reg |= GML_ADAT_MODE;\n\t\tcontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\n\t\tbreak;\n\t}\n\n\terr = write_control_reg(chip, control_reg, false);\n\tspin_unlock_irq(&chip->lock);\n\tif (err < 0)\n\t\treturn err;\n\tchip->digital_mode = mode;\n\n\tdev_dbg(chip->card->dev, \"set_digital_mode to %d\\n\", mode);\n\treturn incompatible_clock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}