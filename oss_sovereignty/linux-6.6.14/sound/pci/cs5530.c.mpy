{
  "module_name": "cs5530.c",
  "hash_id": "fcb9ea7f183364ad88f47771eb2b5541417540aad9b08a21a93fa2f4d2ae85e8",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/cs5530.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/sb.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Ash Willis\");\nMODULE_DESCRIPTION(\"CS5530 Audio\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for CS5530 Audio driver.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for CS5530 Audio driver.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable CS5530 Audio driver.\");\n\nstruct snd_cs5530 {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\tstruct snd_sb *sb;\n\tunsigned long pci_base;\n};\n\nstatic const struct pci_device_id snd_cs5530_ids[] = {\n\t{PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_AUDIO, PCI_ANY_ID,\n\t\t\t\t\t\t\tPCI_ANY_ID, 0, 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_cs5530_ids);\n\nstatic u8 snd_cs5530_mixer_read(unsigned long io, u8 reg)\n{\n\toutb(reg, io + 4);\n\tudelay(20);\n\treg = inb(io + 5);\n\tudelay(20);\n\treturn reg;\n}\n\nstatic int snd_cs5530_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci)\n{\n\tstruct snd_cs5530 *chip = card->private_data;\n\tunsigned long sb_base;\n\tu8 irq, dma8, dma16 = 0;\n\tu16 map;\n\tvoid __iomem *mem;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n \tif (err < 0)\n\t\treturn err;\n\n\tchip->card = card;\n\tchip->pci = pci;\n\n\terr = pcim_iomap_regions(pci, 1 << 0, \"CS5530\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->pci_base = pci_resource_start(pci, 0);\n\tmem = pcim_iomap_table(pci)[0];\n\tmap = readw(mem + 0x18);\n\n\t \n\n\tsb_base = 0x220 + 0x20 * (map & 3);\n\n\tif (map & (1<<2))\n\t\tdev_info(card->dev, \"XpressAudio at 0x%lx\\n\", sb_base);\n\telse {\n\t\tdev_err(card->dev, \"Could not find XpressAudio!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (map & (1<<5))\n\t\tdev_info(card->dev, \"MPU at 0x300\\n\");\n\telse if (map & (1<<6))\n\t\tdev_info(card->dev, \"MPU at 0x330\\n\");\n\n\tirq = snd_cs5530_mixer_read(sb_base, 0x80) & 0x0F;\n\tdma8 = snd_cs5530_mixer_read(sb_base, 0x81);\n\n\tif (dma8 & 0x20)\n\t\tdma16 = 5;\n\telse if (dma8 & 0x40)\n\t\tdma16 = 6;\n\telse if (dma8 & 0x80)\n\t\tdma16 = 7;\n\telse {\n\t\tdev_err(card->dev, \"No 16bit DMA enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dma8 & 0x01)\n\t\tdma8 = 0;\n\telse if (dma8 & 02)\n\t\tdma8 = 1;\n\telse if (dma8 & 0x08)\n\t\tdma8 = 3;\n\telse {\n\t\tdev_err(card->dev, \"No 8bit DMA enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (irq & 1)\n\t\tirq = 9;\n\telse if (irq & 2)\n\t\tirq = 5;\n\telse if (irq & 4)\n\t\tirq = 7;\n\telse if (irq & 8)\n\t\tirq = 10;\n\telse {\n\t\tdev_err(card->dev, \"SoundBlaster IRQ not set\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(card->dev, \"IRQ: %d DMA8: %d DMA16: %d\\n\", irq, dma8, dma16);\n\n\terr = snd_sbdsp_create(card, sb_base, irq, snd_sb16dsp_interrupt, dma8,\n\t\t\t\t\t\tdma16, SB_HW_CS5530, &chip->sb);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Could not create SoundBlaster\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_sb16dsp_pcm(chip->sb, 0);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Could not create PCM\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_sbmixer_new(chip->sb);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Could not create Mixer\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_cs5530_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_cs5530 *chip;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\terr = snd_cs5530_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"CS5530\");\n\tstrcpy(card->shortname, \"CS5530 Audio\");\n\tsprintf(card->longname, \"%s at 0x%lx\", card->shortname, chip->pci_base);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic struct pci_driver cs5530_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_cs5530_ids,\n\t.probe = snd_cs5530_probe,\n};\n\nmodule_pci_driver(cs5530_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}