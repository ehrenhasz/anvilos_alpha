{
  "module_name": "als300.c",
  "hash_id": "454497733bf21eb4580484dc1cc703460f94e559aa85ea6a520cb0892c3d1bf6",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/als300.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/ac97_codec.h>\n#include <sound/opl3.h>\n\n \n#define IRQ_DISABLE\t\t0\n#define IRQ_ENABLE\t\t1\n\n \n#define AC97_ACCESS\t\t0x00\n#define AC97_READ\t\t0x04\n#define AC97_STATUS\t\t0x06\n#define   AC97_DATA_AVAIL\t\t(1<<6)\n#define   AC97_BUSY\t\t\t(1<<7)\n#define ALS300_IRQ_STATUS\t0x07\t\t \n#define   IRQ_PLAYBACK\t\t\t(1<<3)\n#define   IRQ_CAPTURE\t\t\t(1<<2)\n#define GCR_DATA\t\t0x08\n#define GCR_INDEX\t\t0x0C\n#define ALS300P_DRAM_IRQ_STATUS\t0x0D\t\t \n#define MPU_IRQ_STATUS\t\t0x0E\t\t \n#define ALS300P_IRQ_STATUS\t0x0F\t\t \n\n \n#define PLAYBACK_START\t\t0x80\n#define PLAYBACK_END\t\t0x81\n#define PLAYBACK_CONTROL\t0x82\n#define   TRANSFER_START\t\t(1<<16)\n#define   FIFO_PAUSE\t\t\t(1<<17)\n#define RECORD_START\t\t0x83\n#define RECORD_END\t\t0x84\n#define RECORD_CONTROL\t\t0x85\n#define DRAM_WRITE_CONTROL\t0x8B\n#define   WRITE_TRANS_START\t\t(1<<16)\n#define   DRAM_MODE_2\t\t\t(1<<17)\n#define MISC_CONTROL\t\t0x8C\n#define   IRQ_SET_BIT\t\t\t(1<<15)\n#define   VMUTE_NORMAL\t\t\t(1<<20)\n#define   MMUTE_NORMAL\t\t\t(1<<21)\n#define MUS_VOC_VOL\t\t0x8E\n#define PLAYBACK_BLOCK_COUNTER\t0x9A\n#define RECORD_BLOCK_COUNTER\t0x9B\n\n#define DEBUG_PLAY_REC\t0\n\n#if DEBUG_PLAY_REC\n#define snd_als300_dbgplay(format, args...) printk(KERN_ERR format, ##args)\n#else\n#define snd_als300_dbgplay(format, args...)\n#endif\t\t\n\nenum {DEVICE_ALS300, DEVICE_ALS300_PLUS};\n\nMODULE_AUTHOR(\"Ash Willis <ashwillis@programmer.net>\");\nMODULE_DESCRIPTION(\"Avance Logic ALS300\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for ALS300 sound card.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for ALS300 sound card.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable ALS300 sound card.\");\n\nstruct snd_als300 {\n\tunsigned long port;\n\tspinlock_t reg_lock;\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_substream *playback_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\n\tstruct snd_ac97 *ac97;\n\tstruct snd_opl3 *opl3;\n\n\tstruct resource *res_port;\n\n\tint irq;\n\n\tint chip_type;  \n\n\tchar revision;\t\n};\n\nstruct snd_als300_substream_data {\n\tint period_flipflop;\n\tint control_register;\n\tint block_counter_register;\n};\n\nstatic const struct pci_device_id snd_als300_ids[] = {\n\t{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },\n\t{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_als300_ids);\n\nstatic inline u32 snd_als300_gcr_read(unsigned long port, unsigned short reg)\n{\n\toutb(reg, port+GCR_INDEX);\n\treturn inl(port+GCR_DATA);\n}\n\nstatic inline void snd_als300_gcr_write(unsigned long port,\n\t\t\t\t\t\tunsigned short reg, u32 val)\n{\n\toutb(reg, port+GCR_INDEX);\n\toutl(val, port+GCR_DATA);\n}\n\n \nstatic void snd_als300_set_irq_flag(struct snd_als300 *chip, int cmd)\n{\n\tu32 tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);\n\n\t \n\tif (((chip->revision > 5 || chip->chip_type == DEVICE_ALS300_PLUS) ^\n\t\t\t\t\t\t(cmd == IRQ_ENABLE)) == 0)\n\t\ttmp |= IRQ_SET_BIT;\n\telse\n\t\ttmp &= ~IRQ_SET_BIT;\n\tsnd_als300_gcr_write(chip->port, MISC_CONTROL, tmp);\n}\n\nstatic void snd_als300_free(struct snd_card *card)\n{\n\tstruct snd_als300 *chip = card->private_data;\n\n\tsnd_als300_set_irq_flag(chip, IRQ_DISABLE);\n}\n\nstatic irqreturn_t snd_als300_interrupt(int irq, void *dev_id)\n{\n\tu8 status;\n\tstruct snd_als300 *chip = dev_id;\n\tstruct snd_als300_substream_data *data;\n\n\tstatus = inb(chip->port+ALS300_IRQ_STATUS);\n\tif (!status)  \n\t\treturn IRQ_NONE;\n\n\t \n\toutb(status, chip->port+ALS300_IRQ_STATUS);\n\tif (status & IRQ_PLAYBACK) {\n\t\tif (chip->pcm && chip->playback_substream) {\n\t\t\tdata = chip->playback_substream->runtime->private_data;\n\t\t\tdata->period_flipflop ^= 1;\n\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t\tsnd_als300_dbgplay(\"IRQ_PLAYBACK\\n\");\n\t\t}\n\t}\n\tif (status & IRQ_CAPTURE) {\n\t\tif (chip->pcm && chip->capture_substream) {\n\t\t\tdata = chip->capture_substream->runtime->private_data;\n\t\t\tdata->period_flipflop ^= 1;\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\tsnd_als300_dbgplay(\"IRQ_CAPTURE\\n\");\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)\n{\n\tu8 general, mpu, dram;\n\tstruct snd_als300 *chip = dev_id;\n\tstruct snd_als300_substream_data *data;\n\t\n\tgeneral = inb(chip->port+ALS300P_IRQ_STATUS);\n\tmpu = inb(chip->port+MPU_IRQ_STATUS);\n\tdram = inb(chip->port+ALS300P_DRAM_IRQ_STATUS);\n\n\t \n\tif ((general == 0) && ((mpu & 0x80) == 0) && ((dram & 0x01) == 0))\n\t\treturn IRQ_NONE;\n\n\tif (general & IRQ_PLAYBACK) {\n\t\tif (chip->pcm && chip->playback_substream) {\n\t\t\toutb(IRQ_PLAYBACK, chip->port+ALS300P_IRQ_STATUS);\n\t\t\tdata = chip->playback_substream->runtime->private_data;\n\t\t\tdata->period_flipflop ^= 1;\n\t\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\t\tsnd_als300_dbgplay(\"IRQ_PLAYBACK\\n\");\n\t\t}\n\t}\n\tif (general & IRQ_CAPTURE) {\n\t\tif (chip->pcm && chip->capture_substream) {\n\t\t\toutb(IRQ_CAPTURE, chip->port+ALS300P_IRQ_STATUS);\n\t\t\tdata = chip->capture_substream->runtime->private_data;\n\t\t\tdata->period_flipflop ^= 1;\n\t\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\t\tsnd_als300_dbgplay(\"IRQ_CAPTURE\\n\");\n\t\t}\n\t}\n\t \n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned short snd_als300_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t\t\tunsigned short reg)\n{\n\tint i;\n\tstruct snd_als300 *chip = ac97->private_data;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\toutl((reg << 24) | (1 << 31), chip->port+AC97_ACCESS);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif ((inb(chip->port+AC97_STATUS) & (AC97_DATA_AVAIL)) != 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\treturn inw(chip->port+AC97_READ);\n}\n\nstatic void snd_als300_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\tunsigned short reg, unsigned short val)\n{\n\tint i;\n\tstruct snd_als300 *chip = ac97->private_data;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\toutl((reg << 24) | val, chip->port+AC97_ACCESS);\n}\n\nstatic int snd_als300_ac97(struct snd_als300 *chip)\n{\n\tstruct snd_ac97_bus *bus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_als300_ac97_write,\n\t\t.read = snd_als300_ac97_read,\n\t};\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\n\treturn snd_ac97_mixer(bus, &ac97, &chip->ac97);\n}\n\n \nstatic const struct snd_pcm_hardware snd_als300_playback_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t64 * 1024,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t32 * 1024,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n};\n\nstatic const struct snd_pcm_hardware snd_als300_capture_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t64 * 1024,\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t32 * 1024,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n};\n\nstatic int snd_als300_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_als300_substream_data *data = kzalloc(sizeof(*data),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\tchip->playback_substream = substream;\n\truntime->hw = snd_als300_playback_hw;\n\truntime->private_data = data;\n\tdata->control_register = PLAYBACK_CONTROL;\n\tdata->block_counter_register = PLAYBACK_BLOCK_COUNTER;\n\treturn 0;\n}\n\nstatic int snd_als300_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_als300_substream_data *data;\n\n\tdata = substream->runtime->private_data;\n\tkfree(data);\n\tchip->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_als300_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_als300_substream_data *data = kzalloc(sizeof(*data),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\tchip->capture_substream = substream;\n\truntime->hw = snd_als300_capture_hw;\n\truntime->private_data = data;\n\tdata->control_register = RECORD_CONTROL;\n\tdata->block_counter_register = RECORD_BLOCK_COUNTER;\n\treturn 0;\n}\n\nstatic int snd_als300_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_als300_substream_data *data;\n\n\tdata = substream->runtime->private_data;\n\tkfree(data);\n\tchip->capture_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_als300_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tu32 tmp;\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned short period_bytes = snd_pcm_lib_period_bytes(substream);\n\tunsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\t\n\tspin_lock_irq(&chip->reg_lock);\n\ttmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);\n\ttmp &= ~TRANSFER_START;\n\n\tsnd_als300_dbgplay(\"Period bytes: %d Buffer bytes %d\\n\",\n\t\t\t\t\t\tperiod_bytes, buffer_bytes);\n\t\n\t \n\ttmp &= 0xffff0000;\n\ttmp |= period_bytes - 1;\n\tsnd_als300_gcr_write(chip->port, PLAYBACK_CONTROL, tmp);\n\n\t \n\tsnd_als300_gcr_write(chip->port, PLAYBACK_START,\n\t\t\t\t\truntime->dma_addr);\n\tsnd_als300_gcr_write(chip->port, PLAYBACK_END,\n\t\t\t\t\truntime->dma_addr + buffer_bytes - 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_als300_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tu32 tmp;\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned short period_bytes = snd_pcm_lib_period_bytes(substream);\n\tunsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\ttmp = snd_als300_gcr_read(chip->port, RECORD_CONTROL);\n\ttmp &= ~TRANSFER_START;\n\n\tsnd_als300_dbgplay(\"Period bytes: %d Buffer bytes %d\\n\", period_bytes,\n\t\t\t\t\t\t\tbuffer_bytes);\n\n\t \n\ttmp &= 0xffff0000;\n\ttmp |= period_bytes - 1;\n\n\t \n\tsnd_als300_gcr_write(chip->port, RECORD_CONTROL, tmp);\n\tsnd_als300_gcr_write(chip->port, RECORD_START,\n\t\t\t\t\truntime->dma_addr);\n\tsnd_als300_gcr_write(chip->port, RECORD_END,\n\t\t\t\t\truntime->dma_addr + buffer_bytes - 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_als300_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tu32 tmp;\n\tstruct snd_als300_substream_data *data;\n\tunsigned short reg;\n\tint ret = 0;\n\n\tdata = substream->runtime->private_data;\n\treg = data->control_register;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\ttmp = snd_als300_gcr_read(chip->port, reg);\n\t\tdata->period_flipflop = 1;\n\t\tsnd_als300_gcr_write(chip->port, reg, tmp | TRANSFER_START);\n\t\tsnd_als300_dbgplay(\"TRIGGER START\\n\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\ttmp = snd_als300_gcr_read(chip->port, reg);\n\t\tsnd_als300_gcr_write(chip->port, reg, tmp & ~TRANSFER_START);\n\t\tsnd_als300_dbgplay(\"TRIGGER STOP\\n\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\ttmp = snd_als300_gcr_read(chip->port, reg);\n\t\tsnd_als300_gcr_write(chip->port, reg, tmp | FIFO_PAUSE);\n\t\tsnd_als300_dbgplay(\"TRIGGER PAUSE\\n\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\ttmp = snd_als300_gcr_read(chip->port, reg);\n\t\tsnd_als300_gcr_write(chip->port, reg, tmp & ~FIFO_PAUSE);\n\t\tsnd_als300_dbgplay(\"TRIGGER RELEASE\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsnd_als300_dbgplay(\"TRIGGER INVALID\\n\");\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)\n{\n\tu16 current_ptr;\n\tstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_als300_substream_data *data;\n\tunsigned short period_bytes;\n\n\tdata = substream->runtime->private_data;\n\tperiod_bytes = snd_pcm_lib_period_bytes(substream);\n\t\n\tspin_lock(&chip->reg_lock);\n\tcurrent_ptr = (u16) snd_als300_gcr_read(chip->port,\n\t\t\t\t\tdata->block_counter_register) + 4;\n\tspin_unlock(&chip->reg_lock);\n\tif (current_ptr > period_bytes)\n\t\tcurrent_ptr = 0;\n\telse\n\t\tcurrent_ptr = period_bytes - current_ptr;\n\n\tif (data->period_flipflop == 0)\n\t\tcurrent_ptr += period_bytes;\n\tsnd_als300_dbgplay(\"Pointer (bytes): %d\\n\", current_ptr);\n\treturn bytes_to_frames(substream->runtime, current_ptr);\n}\n\nstatic const struct snd_pcm_ops snd_als300_playback_ops = {\n\t.open =\t\tsnd_als300_playback_open,\n\t.close =\tsnd_als300_playback_close,\n\t.prepare =\tsnd_als300_playback_prepare,\n\t.trigger =\tsnd_als300_trigger,\n\t.pointer =\tsnd_als300_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_als300_capture_ops = {\n\t.open =\t\tsnd_als300_capture_open,\n\t.close =\tsnd_als300_capture_close,\n\t.prepare =\tsnd_als300_capture_prepare,\n\t.trigger =\tsnd_als300_trigger,\n\t.pointer =\tsnd_als300_pointer,\n};\n\nstatic int snd_als300_new_pcm(struct snd_als300 *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"ALS300\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"ALS300\");\n\tchip->pcm = pcm;\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_als300_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_als300_capture_ops);\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,\n\t\t\t\t       64*1024, 64*1024);\n\treturn 0;\n}\n\nstatic void snd_als300_init(struct snd_als300 *chip)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\t\n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\tchip->revision = (snd_als300_gcr_read(chip->port, MISC_CONTROL) >> 16)\n\t\t\t\t\t\t\t\t& 0x0000000F;\n\t \n\ttmp = snd_als300_gcr_read(chip->port, DRAM_WRITE_CONTROL);\n\tsnd_als300_gcr_write(chip->port, DRAM_WRITE_CONTROL,\n\t\t\t\t\t\t(tmp | DRAM_MODE_2)\n\t\t\t\t\t\t& ~WRITE_TRANS_START);\n\n\t \n\tsnd_als300_set_irq_flag(chip, IRQ_ENABLE);\n\n\t \n\ttmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);\n\tsnd_als300_gcr_write(chip->port, MISC_CONTROL,\n\t\t\ttmp | VMUTE_NORMAL | MMUTE_NORMAL);\n\n\t \n\tsnd_als300_gcr_write(chip->port, MUS_VOC_VOL, 0);\n\n\t \n\ttmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);\n\tsnd_als300_gcr_write(chip->port, PLAYBACK_CONTROL,\n\t\t\ttmp & ~TRANSFER_START);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n}\n\nstatic int snd_als300_create(struct snd_card *card,\n\t\t\t     struct pci_dev *pci, int chip_type)\n{\n\tstruct snd_als300 *chip = card->private_data;\n\tvoid *irq_handler;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(28))) {\n\t\tdev_err(card->dev, \"error setting 28bit DMA mask\\n\");\n\t\treturn -ENXIO;\n\t}\n\tpci_set_master(pci);\n\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\tchip->chip_type = chip_type;\n\tspin_lock_init(&chip->reg_lock);\n\n\terr = pci_request_regions(pci, \"ALS300\");\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->port = pci_resource_start(pci, 0);\n\n\tif (chip->chip_type == DEVICE_ALS300_PLUS)\n\t\tirq_handler = snd_als300plus_interrupt;\n\telse\n\t\tirq_handler = snd_als300_interrupt;\n\n\tif (devm_request_irq(&pci->dev, pci->irq, irq_handler, IRQF_SHARED,\n\t\t\t     KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_als300_free;\n\n\tsnd_als300_init(chip);\n\n\terr = snd_als300_ac97(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Could not create ac97\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_als300_new_pcm(chip);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"Could not create PCM\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_als300_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_als300 *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\treturn 0;\n}\n\nstatic int snd_als300_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct snd_als300 *chip = card->private_data;\n\n\tsnd_als300_init(chip);\n\tsnd_ac97_resume(chip->ac97);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_als300_pm, snd_als300_suspend, snd_als300_resume);\n#define SND_ALS300_PM_OPS\t&snd_als300_pm\n#else\n#define SND_ALS300_PM_OPS\tNULL\n#endif\n\nstatic int snd_als300_probe(struct pci_dev *pci,\n                             const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_als300 *chip;\n\tint err, chip_type;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tchip_type = pci_id->driver_data;\n\n\terr = snd_als300_create(card, pci, chip_type);\n\tif (err < 0)\n\t\tgoto error;\n\n\tstrcpy(card->driver, \"ALS300\");\n\tif (chip->chip_type == DEVICE_ALS300_PLUS)\n\t\t \n\t\tsprintf(card->shortname, \"ALS300+ (Rev. %d)\", chip->revision);\n\telse\n\t\tsprintf(card->shortname, \"ALS300 (Rev. %c)\", 'A' +\n\t\t\t\t\t\t\tchip->revision - 1);\n\tsprintf(card->longname, \"%s at 0x%lx irq %i\",\n\t\t\t\tcard->shortname, chip->port, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver als300_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_als300_ids,\n\t.probe = snd_als300_probe,\n\t.driver = {\n\t\t.pm = SND_ALS300_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(als300_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}