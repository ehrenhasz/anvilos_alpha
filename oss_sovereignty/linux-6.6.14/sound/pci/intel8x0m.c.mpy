{
  "module_name": "intel8x0m.c",
  "hash_id": "e45927925b0afc76d4209e6c6372d6feeb11592cc293c9efb9d914829ec36abb",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/intel8x0m.c",
  "human_readable_source": "\n       \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Intel 82801AA,82901AB,i810,i820,i830,i840,i845,MX440; \"\n\t\t   \"SiS 7013; NVidia MCP/2/2S/3 modems\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = -2;  \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int ac97_clock;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for Intel i8x0 modemcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for Intel i8x0 modemcard.\");\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (0 = auto-detect).\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n \nenum { DEVICE_INTEL, DEVICE_SIS, DEVICE_ALI, DEVICE_NFORCE };\n\n#define ICHREG(x) ICH_REG_##x\n\n#define DEFINE_REGSET(name,base) \\\nenum { \\\n\tICH_REG_##name##_BDBAR\t= base + 0x0,\t  \\\n\tICH_REG_##name##_CIV\t= base + 0x04,\t  \\\n\tICH_REG_##name##_LVI\t= base + 0x05,\t  \\\n\tICH_REG_##name##_SR\t= base + 0x06,\t  \\\n\tICH_REG_##name##_PICB\t= base + 0x08,\t  \\\n\tICH_REG_##name##_PIV\t= base + 0x0a,\t  \\\n\tICH_REG_##name##_CR\t= base + 0x0b,\t  \\\n}\n\n \nDEFINE_REGSET(OFF, 0);\t\t \n\n \n\n \n#define ICH_REG_LVI_MASK\t\t0x1f\n\n \n#define ICH_FIFOE\t\t\t0x10\t \n#define ICH_BCIS\t\t\t0x08\t \n#define ICH_LVBCI\t\t\t0x04\t \n#define ICH_CELV\t\t\t0x02\t \n#define ICH_DCH\t\t\t\t0x01\t \n\n \n#define ICH_REG_PIV_MASK\t\t0x1f\t \n\n \n#define ICH_IOCE\t\t\t0x10\t \n#define ICH_FEIE\t\t\t0x08\t \n#define ICH_LVBIE\t\t\t0x04\t \n#define ICH_RESETREGS\t\t\t0x02\t \n#define ICH_STARTBM\t\t\t0x01\t \n\n\n \n#define ICH_REG_GLOB_CNT\t\t0x3c\t \n#define   ICH_TRIE\t\t0x00000040\t \n#define   ICH_SRIE\t\t0x00000020\t \n#define   ICH_PRIE\t\t0x00000010\t \n#define   ICH_ACLINK\t\t0x00000008\t \n#define   ICH_AC97WARM\t\t0x00000004\t \n#define   ICH_AC97COLD\t\t0x00000002\t \n#define   ICH_GIE\t\t0x00000001\t \n#define ICH_REG_GLOB_STA\t\t0x40\t \n#define   ICH_TRI\t\t0x20000000\t \n#define   ICH_TCR\t\t0x10000000\t \n#define   ICH_BCS\t\t0x08000000\t \n#define   ICH_SPINT\t\t0x04000000\t \n#define   ICH_P2INT\t\t0x02000000\t \n#define   ICH_M2INT\t\t0x01000000\t \n#define   ICH_SAMPLE_CAP\t0x00c00000\t \n#define   ICH_MULTICHAN_CAP\t0x00300000\t \n#define   ICH_MD3\t\t0x00020000\t \n#define   ICH_AD3\t\t0x00010000\t \n#define   ICH_RCS\t\t0x00008000\t \n#define   ICH_BIT3\t\t0x00004000\t \n#define   ICH_BIT2\t\t0x00002000\t \n#define   ICH_BIT1\t\t0x00001000\t \n#define   ICH_SRI\t\t0x00000800\t \n#define   ICH_PRI\t\t0x00000400\t \n#define   ICH_SCR\t\t0x00000200\t \n#define   ICH_PCR\t\t0x00000100\t \n#define   ICH_MCINT\t\t0x00000080\t \n#define   ICH_POINT\t\t0x00000040\t \n#define   ICH_PIINT\t\t0x00000020\t \n#define   ICH_NVSPINT\t\t0x00000010\t \n#define   ICH_MOINT\t\t0x00000004\t \n#define   ICH_MIINT\t\t0x00000002\t \n#define   ICH_GSCI\t\t0x00000001\t \n#define ICH_REG_ACC_SEMA\t\t0x44\t \n#define   ICH_CAS\t\t0x01\t\t \n\n#define ICH_MAX_FRAGS\t\t32\t\t \n\n\n \n\nenum { ICHD_MDMIN, ICHD_MDMOUT, ICHD_MDMLAST = ICHD_MDMOUT };\nenum { ALID_MDMIN, ALID_MDMOUT, ALID_MDMLAST = ALID_MDMOUT };\n\n#define get_ichdev(substream) (substream->runtime->private_data)\n\nstruct ichdev {\n\tunsigned int ichd;\t\t\t \n\tunsigned long reg_offset;\t\t \n\t__le32 *bdbar;\t\t\t\t \n\tunsigned int bdbar_addr;\t\t \n\tstruct snd_pcm_substream *substream;\n\tunsigned int physbuf;\t\t\t \n        unsigned int size;\n        unsigned int fragsize;\n        unsigned int fragsize1;\n        unsigned int position;\n        int frags;\n        int lvi;\n        int lvi_frag;\n\tint civ;\n\tint ack;\n\tint ack_reload;\n\tunsigned int ack_bit;\n\tunsigned int roff_sr;\n\tunsigned int roff_picb;\n\tunsigned int int_sta_mask;\t\t \n\tunsigned int ali_slot;\t\t\t \n\tstruct snd_ac97 *ac97;\n};\n\nstruct intel8x0m {\n\tunsigned int device_type;\n\n\tint irq;\n\n\tvoid __iomem *addr;\n\tvoid __iomem *bmaddr;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\n\tint pcm_devs;\n\tstruct snd_pcm *pcm[2];\n\tstruct ichdev ichd[2];\n\n\tunsigned int in_ac97_init: 1;\n\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97;\n\n\tspinlock_t reg_lock;\n\t\n\tstruct snd_dma_buffer *bdbars;\n\tu32 bdbars_count;\n\tu32 int_sta_reg;\t\t \n\tu32 int_sta_mask;\t\t \n\tunsigned int pcm_pos_shift;\n};\n\nstatic const struct pci_device_id snd_intel8x0m_ids[] = {\n\t{ PCI_VDEVICE(INTEL, 0x2416), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2426), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2446), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x2486), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x24c6), DEVICE_INTEL },  \n\t{ PCI_VDEVICE(INTEL, 0x24d6), DEVICE_INTEL },  \n\t{ PCI_VDEVICE(INTEL, 0x266d), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x27dd), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(INTEL, 0x7196), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(AMD, 0x7446), DEVICE_INTEL },\t \n\t{ PCI_VDEVICE(SI, 0x7013), DEVICE_SIS },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x01c1), DEVICE_NFORCE },  \n\t{ PCI_VDEVICE(NVIDIA, 0x0069), DEVICE_NFORCE },  \n\t{ PCI_VDEVICE(NVIDIA, 0x0089), DEVICE_NFORCE },  \n\t{ PCI_VDEVICE(NVIDIA, 0x00d9), DEVICE_NFORCE },  \n\t{ PCI_VDEVICE(AMD, 0x746e), DEVICE_INTEL },\t \n#if 0\n\t{ PCI_VDEVICE(AL, 0x5455), DEVICE_ALI },    \n#endif\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_intel8x0m_ids);\n\n \n\nstatic inline u8 igetbyte(struct intel8x0m *chip, u32 offset)\n{\n\treturn ioread8(chip->bmaddr + offset);\n}\n\nstatic inline u16 igetword(struct intel8x0m *chip, u32 offset)\n{\n\treturn ioread16(chip->bmaddr + offset);\n}\n\nstatic inline u32 igetdword(struct intel8x0m *chip, u32 offset)\n{\n\treturn ioread32(chip->bmaddr + offset);\n}\n\nstatic inline void iputbyte(struct intel8x0m *chip, u32 offset, u8 val)\n{\n\tiowrite8(val, chip->bmaddr + offset);\n}\n\nstatic inline void iputword(struct intel8x0m *chip, u32 offset, u16 val)\n{\n\tiowrite16(val, chip->bmaddr + offset);\n}\n\nstatic inline void iputdword(struct intel8x0m *chip, u32 offset, u32 val)\n{\n\tiowrite32(val, chip->bmaddr + offset);\n}\n\n \n\nstatic inline u16 iagetword(struct intel8x0m *chip, u32 offset)\n{\n\treturn ioread16(chip->addr + offset);\n}\n\nstatic inline void iaputword(struct intel8x0m *chip, u32 offset, u16 val)\n{\n\tiowrite16(val, chip->addr + offset);\n}\n\n \n\n \n\n \nstatic unsigned int get_ich_codec_bit(struct intel8x0m *chip, unsigned int codec)\n{\n\tstatic const unsigned int codec_bit[3] = {\n\t\tICH_PCR, ICH_SCR, ICH_TCR\n\t};\n\tif (snd_BUG_ON(codec >= 3))\n\t\treturn ICH_PCR;\n\treturn codec_bit[codec];\n}\n\nstatic int snd_intel8x0m_codec_semaphore(struct intel8x0m *chip, unsigned int codec)\n{\n\tint time;\n\t\n\tif (codec > 1)\n\t\treturn -EIO;\n\tcodec = get_ich_codec_bit(chip, codec);\n\n\t \n\tif ((igetdword(chip, ICHREG(GLOB_STA)) & codec) == 0)\n\t\treturn -EIO;\n\n\t \n\ttime = 100;\n      \tdo {\n      \t\tif (!(igetbyte(chip, ICHREG(ACC_SEMA)) & ICH_CAS))\n      \t\t\treturn 0;\n\t\tudelay(10);\n\t} while (time--);\n\n\t \n\tdev_err(chip->card->dev,\n\t\t\"codec_semaphore: semaphore is not ready [0x%x][0x%x]\\n\",\n\t\t\tigetbyte(chip, ICHREG(ACC_SEMA)), igetdword(chip, ICHREG(GLOB_STA)));\n\tiagetword(chip, 0);\t \n\t \n\treturn -EBUSY;\n}\n \nstatic void snd_intel8x0m_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t      unsigned short reg,\n\t\t\t\t      unsigned short val)\n{\n\tstruct intel8x0m *chip = ac97->private_data;\n\t\n\tif (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {\n\t\tif (! chip->in_ac97_init)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_write %d: semaphore is not ready for register 0x%x\\n\",\n\t\t\t\tac97->num, reg);\n\t}\n\tiaputword(chip, reg + ac97->num * 0x80, val);\n}\n\nstatic unsigned short snd_intel8x0m_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t       unsigned short reg)\n{\n\tstruct intel8x0m *chip = ac97->private_data;\n\tunsigned short res;\n\tunsigned int tmp;\n\n\tif (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {\n\t\tif (! chip->in_ac97_init)\n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_read %d: semaphore is not ready for register 0x%x\\n\",\n\t\t\t\tac97->num, reg);\n\t\tres = 0xffff;\n\t} else {\n\t\tres = iagetword(chip, reg + ac97->num * 0x80);\n\t\ttmp = igetdword(chip, ICHREG(GLOB_STA));\n\t\tif (tmp & ICH_RCS) {\n\t\t\t \n\t\t\tiputdword(chip, ICHREG(GLOB_STA),\n\t\t\t\t  tmp & ~(ICH_SRI|ICH_PRI|ICH_TRI|ICH_GSCI));\n\t\t\tif (! chip->in_ac97_init)\n\t\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\t\"codec_read %d: read timeout for register 0x%x\\n\",\n\t\t\t\t\tac97->num, reg);\n\t\t\tres = 0xffff;\n\t\t}\n\t}\n\tif (reg == AC97_GPIO_STATUS)\n\t\tiagetword(chip, 0);  \n\treturn res;\n}\n\n\n \nstatic void snd_intel8x0m_setup_periods(struct intel8x0m *chip, struct ichdev *ichdev)\n{\n\tint idx;\n\t__le32 *bdbar = ichdev->bdbar;\n\tunsigned long port = ichdev->reg_offset;\n\n\tiputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\n\tif (ichdev->size == ichdev->fragsize) {\n\t\tichdev->ack_reload = ichdev->ack = 2;\n\t\tichdev->fragsize1 = ichdev->fragsize >> 1;\n\t\tfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 4) {\n\t\t\tbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf);\n\t\t\tbdbar[idx + 1] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize1 >> chip->pcm_pos_shift);\n\t\t\tbdbar[idx + 2] = cpu_to_le32(ichdev->physbuf + (ichdev->size >> 1));\n\t\t\tbdbar[idx + 3] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize1 >> chip->pcm_pos_shift);\n\t\t}\n\t\tichdev->frags = 2;\n\t} else {\n\t\tichdev->ack_reload = ichdev->ack = 1;\n\t\tichdev->fragsize1 = ichdev->fragsize;\n\t\tfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 2) {\n\t\t\tbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf + (((idx >> 1) * ichdev->fragsize) % ichdev->size));\n\t\t\tbdbar[idx + 1] = cpu_to_le32(0x80000000 |  \n\t\t\t\t\t\t     ichdev->fragsize >> chip->pcm_pos_shift);\n\t\t\t \n\t\t}\n\t\tichdev->frags = ichdev->size / ichdev->fragsize;\n\t}\n\tiputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi = ICH_REG_LVI_MASK);\n\tichdev->civ = 0;\n\tiputbyte(chip, port + ICH_REG_OFF_CIV, 0);\n\tichdev->lvi_frag = ICH_REG_LVI_MASK % ichdev->frags;\n\tichdev->position = 0;\n#if 0\n\tdev_dbg(chip->card->dev,\n\t\t\"lvi_frag = %i, frags = %i, period_size = 0x%x, period_size1 = 0x%x\\n\",\n\t       ichdev->lvi_frag, ichdev->frags, ichdev->fragsize,\n\t       ichdev->fragsize1);\n#endif\n\t \n\tiputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\n}\n\n \n\nstatic inline void snd_intel8x0m_update(struct intel8x0m *chip, struct ichdev *ichdev)\n{\n\tunsigned long port = ichdev->reg_offset;\n\tint civ, i, step;\n\tint ack = 0;\n\n\tciv = igetbyte(chip, port + ICH_REG_OFF_CIV);\n\tif (civ == ichdev->civ) {\n\t\t\n\t\tstep = 1;\n\t\tichdev->civ++;\n\t\tichdev->civ &= ICH_REG_LVI_MASK;\n\t} else {\n\t\tstep = civ - ichdev->civ;\n\t\tif (step < 0)\n\t\t\tstep += ICH_REG_LVI_MASK + 1;\n\t\t\n\t\t\n\t\tichdev->civ = civ;\n\t}\n\n\tichdev->position += step * ichdev->fragsize1;\n\tichdev->position %= ichdev->size;\n\tichdev->lvi += step;\n\tichdev->lvi &= ICH_REG_LVI_MASK;\n\tiputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\n\tfor (i = 0; i < step; i++) {\n\t\tichdev->lvi_frag++;\n\t\tichdev->lvi_frag %= ichdev->frags;\n\t\tichdev->bdbar[ichdev->lvi * 2] = cpu_to_le32(ichdev->physbuf +\n\t\t\t\t\t\t\t     ichdev->lvi_frag *\n\t\t\t\t\t\t\t     ichdev->fragsize1);\n#if 0\n\t\tdev_dbg(chip->card->dev,\n\t\t\t\"new: bdbar[%i] = 0x%x [0x%x], prefetch = %i, all = 0x%x, 0x%x\\n\",\n\t\t       ichdev->lvi * 2, ichdev->bdbar[ichdev->lvi * 2],\n\t\t       ichdev->bdbar[ichdev->lvi * 2 + 1], inb(ICH_REG_OFF_PIV + port),\n\t\t       inl(port + 4), inb(port + ICH_REG_OFF_CR));\n#endif\n\t\tif (--ichdev->ack == 0) {\n\t\t\tichdev->ack = ichdev->ack_reload;\n\t\t\tack = 1;\n\t\t}\n\t}\n\tif (ack && ichdev->substream) {\n\t\tspin_unlock(&chip->reg_lock);\n\t\tsnd_pcm_period_elapsed(ichdev->substream);\n\t\tspin_lock(&chip->reg_lock);\n\t}\n\tiputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\n}\n\nstatic irqreturn_t snd_intel8x0m_interrupt(int irq, void *dev_id)\n{\n\tstruct intel8x0m *chip = dev_id;\n\tstruct ichdev *ichdev;\n\tunsigned int status;\n\tunsigned int i;\n\n\tspin_lock(&chip->reg_lock);\n\tstatus = igetdword(chip, chip->int_sta_reg);\n\tif (status == 0xffffffff) {  \n\t\tspin_unlock(&chip->reg_lock);\n\t\treturn IRQ_NONE;\n\t}\n\tif ((status & chip->int_sta_mask) == 0) {\n\t\tif (status)\n\t\t\tiputdword(chip, chip->int_sta_reg, status);\n\t\tspin_unlock(&chip->reg_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tif (status & ichdev->int_sta_mask)\n\t\t\tsnd_intel8x0m_update(chip, ichdev);\n\t}\n\n\t \n\tiputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);\n\tspin_unlock(&chip->reg_lock);\n\t\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int snd_intel8x0m_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tunsigned char val = 0;\n\tunsigned long port = ichdev->reg_offset;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tval = ICH_IOCE | ICH_STARTBM;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval = ICH_IOCE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = ICH_IOCE | ICH_STARTBM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tiputbyte(chip, port + ICH_REG_OFF_CR, val);\n\tif (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\t \n\t\twhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH)) ;\n\t\t \n\t\tiputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_intel8x0m_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\tsize_t ptr1, ptr;\n\n\tptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << chip->pcm_pos_shift;\n\tif (ptr1 != 0)\n\t\tptr = ichdev->fragsize1 - ptr1;\n\telse\n\t\tptr = 0;\n\tptr += ichdev->position;\n\tif (ptr >= ichdev->size)\n\t\treturn 0;\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic int snd_intel8x0m_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct ichdev *ichdev = get_ichdev(substream);\n\n\tichdev->physbuf = runtime->dma_addr;\n\tichdev->size = snd_pcm_lib_buffer_bytes(substream);\n\tichdev->fragsize = snd_pcm_lib_period_bytes(substream);\n\tsnd_ac97_write(ichdev->ac97, AC97_LINE1_RATE, runtime->rate);\n\tsnd_ac97_write(ichdev->ac97, AC97_LINE1_LEVEL, 0);\n\tsnd_intel8x0m_setup_periods(chip, ichdev);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_intel8x0m_stream =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_KNOT,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t16000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t1,\n\t.buffer_bytes_max =\t64 * 1024,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t64 * 1024,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\n\nstatic int snd_intel8x0m_pcm_open(struct snd_pcm_substream *substream, struct ichdev *ichdev)\n{\n\tstatic const unsigned int rates[] = { 8000,  9600, 12000, 16000 };\n\tstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t\t.count = ARRAY_SIZE(rates),\n\t\t.list = rates,\n\t\t.mask = 0,\n\t};\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tichdev->substream = substream;\n\truntime->hw = snd_intel8x0m_stream;\n\terr = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t &hw_constraints_rates);\n\tif ( err < 0 )\n\t\treturn err;\n\truntime->private_data = ichdev;\n\treturn 0;\n}\n\nstatic int snd_intel8x0m_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMOUT]);\n}\n\nstatic int snd_intel8x0m_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_MDMOUT].substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_intel8x0m_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\n\treturn snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMIN]);\n}\n\nstatic int snd_intel8x0m_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\n\n\tchip->ichd[ICHD_MDMIN].substream = NULL;\n\treturn 0;\n}\n\n\nstatic const struct snd_pcm_ops snd_intel8x0m_playback_ops = {\n\t.open =\t\tsnd_intel8x0m_playback_open,\n\t.close =\tsnd_intel8x0m_playback_close,\n\t.prepare =\tsnd_intel8x0m_pcm_prepare,\n\t.trigger =\tsnd_intel8x0m_pcm_trigger,\n\t.pointer =\tsnd_intel8x0m_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_intel8x0m_capture_ops = {\n\t.open =\t\tsnd_intel8x0m_capture_open,\n\t.close =\tsnd_intel8x0m_capture_close,\n\t.prepare =\tsnd_intel8x0m_pcm_prepare,\n\t.trigger =\tsnd_intel8x0m_pcm_trigger,\n\t.pointer =\tsnd_intel8x0m_pcm_pointer,\n};\n\n\nstruct ich_pcm_table {\n\tchar *suffix;\n\tconst struct snd_pcm_ops *playback_ops;\n\tconst struct snd_pcm_ops *capture_ops;\n\tsize_t prealloc_size;\n\tsize_t prealloc_max_size;\n\tint ac97_idx;\n};\n\nstatic int snd_intel8x0m_pcm1(struct intel8x0m *chip, int device,\n\t\t\t      const struct ich_pcm_table *rec)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\tchar name[32];\n\n\tif (rec->suffix)\n\t\tsprintf(name, \"Intel ICH - %s\", rec->suffix);\n\telse\n\t\tstrcpy(name, \"Intel ICH\");\n\terr = snd_pcm_new(chip->card, name, device,\n\t\t\t  rec->playback_ops ? 1 : 0,\n\t\t\t  rec->capture_ops ? 1 : 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rec->playback_ops)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);\n\tif (rec->capture_ops)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);\n\n\tpcm->private_data = chip;\n\tpcm->info_flags = 0;\n\tpcm->dev_class = SNDRV_PCM_CLASS_MODEM;\n\tif (rec->suffix)\n\t\tsprintf(pcm->name, \"%s - %s\", chip->card->shortname, rec->suffix);\n\telse\n\t\tstrcpy(pcm->name, chip->card->shortname);\n\tchip->pcm[device] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev,\n\t\t\t\t       rec->prealloc_size,\n\t\t\t\t       rec->prealloc_max_size);\n\n\treturn 0;\n}\n\nstatic const struct ich_pcm_table intel_pcms[] = {\n\t{\n\t\t.suffix = \"Modem\",\n\t\t.playback_ops = &snd_intel8x0m_playback_ops,\n\t\t.capture_ops = &snd_intel8x0m_capture_ops,\n\t\t.prealloc_size = 32 * 1024,\n\t\t.prealloc_max_size = 64 * 1024,\n\t},\n};\n\nstatic int snd_intel8x0m_pcm(struct intel8x0m *chip)\n{\n\tint i, tblsize, device, err;\n\tconst struct ich_pcm_table *tbl, *rec;\n\n#if 1\n\ttbl = intel_pcms;\n\ttblsize = 1;\n#else\n\tswitch (chip->device_type) {\n\tcase DEVICE_NFORCE:\n\t\ttbl = nforce_pcms;\n\t\ttblsize = ARRAY_SIZE(nforce_pcms);\n\t\tbreak;\n\tcase DEVICE_ALI:\n\t\ttbl = ali_pcms;\n\t\ttblsize = ARRAY_SIZE(ali_pcms);\n\t\tbreak;\n\tdefault:\n\t\ttbl = intel_pcms;\n\t\ttblsize = 2;\n\t\tbreak;\n\t}\n#endif\n\tdevice = 0;\n\tfor (i = 0; i < tblsize; i++) {\n\t\trec = tbl + i;\n\t\tif (i > 0 && rec->ac97_idx) {\n\t\t\t \n\t\t\tif (! chip->ichd[rec->ac97_idx].ac97)\n\t\t\t\tcontinue;\n\t\t}\n\t\terr = snd_intel8x0m_pcm1(chip, device, rec);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdevice++;\n\t}\n\n\tchip->pcm_devs = device;\n\treturn 0;\n}\n\t\n\n \n\nstatic void snd_intel8x0m_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\n{\n\tstruct intel8x0m *chip = bus->private_data;\n\tchip->ac97_bus = NULL;\n}\n\nstatic void snd_intel8x0m_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct intel8x0m *chip = ac97->private_data;\n\tchip->ac97 = NULL;\n}\n\n\nstatic int snd_intel8x0m_mixer(struct intel8x0m *chip, int ac97_clock)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tstruct snd_ac97 *x97;\n\tint err;\n\tunsigned int glob_sta = 0;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_intel8x0m_codec_write,\n\t\t.read = snd_intel8x0m_codec_read,\n\t};\n\n\tchip->in_ac97_init = 1;\n\t\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = chip;\n\tac97.private_free = snd_intel8x0m_mixer_free_ac97;\n\tac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;\n\n\tglob_sta = igetdword(chip, ICHREG(GLOB_STA));\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus);\n\tif (err < 0)\n\t\tgoto __err;\n\tpbus->private_free = snd_intel8x0m_mixer_free_ac97_bus;\n\tif (ac97_clock >= 8000 && ac97_clock <= 48000)\n\t\tpbus->clock = ac97_clock;\n\tchip->ac97_bus = pbus;\n\n\tac97.pci = chip->pci;\n\tac97.num = glob_sta & ICH_SCR ? 1 : 0;\n\terr = snd_ac97_mixer(pbus, &ac97, &x97);\n\tif (err < 0) {\n\t\tdev_err(chip->card->dev,\n\t\t\t\"Unable to initialize codec #%d\\n\", ac97.num);\n\t\tif (ac97.num == 0)\n\t\t\tgoto __err;\n\t\treturn err;\n\t}\n\tchip->ac97 = x97;\n\tif(ac97_is_modem(x97) && !chip->ichd[ICHD_MDMIN].ac97) {\n\t\tchip->ichd[ICHD_MDMIN].ac97 = x97;\n\t\tchip->ichd[ICHD_MDMOUT].ac97 = x97;\n\t}\n\n\tchip->in_ac97_init = 0;\n\treturn 0;\n\n __err:\n\t \n\tif (chip->device_type != DEVICE_ALI)\n\t\tiputdword(chip, ICHREG(GLOB_CNT),\n\t\t\t  igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_AC97COLD);\n\treturn err;\n}\n\n\n \n\nstatic int snd_intel8x0m_ich_chip_init(struct intel8x0m *chip, int probing)\n{\n\tunsigned long end_time;\n\tunsigned int cnt, status, nstatus;\n\t\n\t \n\t \n\tstatus = ICH_RCS | ICH_MIINT | ICH_MOINT;\n\tcnt = igetdword(chip, ICHREG(GLOB_STA));\n\tiputdword(chip, ICHREG(GLOB_STA), cnt & status);\n\n\t \n\tcnt = igetdword(chip, ICHREG(GLOB_CNT));\n\tcnt &= ~(ICH_ACLINK);\n\t \n\tcnt |= (cnt & ICH_AC97COLD) == 0 ? ICH_AC97COLD : ICH_AC97WARM;\n\tiputdword(chip, ICHREG(GLOB_CNT), cnt);\n\tusleep_range(500, 1000);  \n\tend_time = jiffies + HZ / 4;\n\tdo {\n\t\tif ((igetdword(chip, ICHREG(GLOB_CNT)) & ICH_AC97WARM) == 0)\n\t\t\tgoto __ok;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after_eq(end_time, jiffies));\n\tdev_err(chip->card->dev, \"AC'97 warm reset still in progress? [0x%x]\\n\",\n\t\t   igetdword(chip, ICHREG(GLOB_CNT)));\n\treturn -EIO;\n\n      __ok:\n\tif (probing) {\n\t\t \n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tstatus = igetdword(chip, ICHREG(GLOB_STA)) &\n\t\t\t\t(ICH_PCR | ICH_SCR | ICH_TCR);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t\tif (! status) {\n\t\t\t \n\t\t\tdev_err(chip->card->dev,\n\t\t\t\t\"codec_ready: codec is not ready [0x%x]\\n\",\n\t\t\t\t   igetdword(chip, ICHREG(GLOB_STA)));\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tnstatus = ICH_PCR | ICH_SCR;\n\n\t\t \n\t\tend_time = jiffies + HZ / 4;\n\t\twhile (status != nstatus && time_after_eq(end_time, jiffies)) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tstatus |= igetdword(chip, ICHREG(GLOB_STA)) & nstatus;\n\t\t}\n\n\t} else {\n\t\t \n\t\tstatus = 0;\n\t\tif (chip->ac97)\n\t\t\tstatus |= get_ich_codec_bit(chip, chip->ac97->num);\n\t\t \n\t\tend_time = jiffies + HZ;\n\t\tdo {\n\t\t\tnstatus = igetdword(chip, ICHREG(GLOB_STA)) &\n\t\t\t\t(ICH_PCR | ICH_SCR | ICH_TCR);\n\t\t\tif (status == nstatus)\n\t\t\t\tbreak;\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t} while (time_after_eq(end_time, jiffies));\n\t}\n\n\tif (chip->device_type == DEVICE_SIS) {\n\t\t \n\t\tiputword(chip, 0x4c, igetword(chip, 0x4c) | 1);\n\t}\n\n      \treturn 0;\n}\n\nstatic int snd_intel8x0m_chip_init(struct intel8x0m *chip, int probing)\n{\n\tunsigned int i;\n\tint err;\n\t\n\terr = snd_intel8x0m_ich_chip_init(chip, probing);\n\tif (err < 0)\n\t\treturn err;\n\tiagetword(chip, 0);\t \n\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset, chip->ichd[i].bdbar_addr);\n\treturn 0;\n}\n\nstatic void snd_intel8x0m_free(struct snd_card *card)\n{\n\tstruct intel8x0m *chip = card->private_data;\n\tunsigned int i;\n\n\tif (chip->irq < 0)\n\t\tgoto __hw_end;\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\n\t \n\tfor (i = 0; i < chip->bdbars_count; i++)\n\t\tiputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\n __hw_end:\n\tif (chip->irq >= 0)\n\t\tfree_irq(chip->irq, chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int intel8x0m_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct intel8x0m *chip = card->private_data;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tsnd_ac97_suspend(chip->ac97);\n\tif (chip->irq >= 0) {\n\t\tfree_irq(chip->irq, chip);\n\t\tchip->irq = -1;\n\t\tcard->sync_irq = -1;\n\t}\n\treturn 0;\n}\n\nstatic int intel8x0m_resume(struct device *dev)\n{\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct intel8x0m *chip = card->private_data;\n\n\tif (request_irq(pci->irq, snd_intel8x0m_interrupt,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(dev, \"unable to grab IRQ %d, disabling device\\n\",\n\t\t\tpci->irq);\n\t\tsnd_card_disconnect(card);\n\t\treturn -EIO;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tsnd_intel8x0m_chip_init(chip, 0);\n\tsnd_ac97_resume(chip->ac97);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(intel8x0m_pm, intel8x0m_suspend, intel8x0m_resume);\n#define INTEL8X0M_PM_OPS\t&intel8x0m_pm\n#else\n#define INTEL8X0M_PM_OPS\tNULL\n#endif  \n\nstatic void snd_intel8x0m_proc_read(struct snd_info_entry * entry,\n\t\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct intel8x0m *chip = entry->private_data;\n\tunsigned int tmp;\n\n\tsnd_iprintf(buffer, \"Intel8x0m\\n\\n\");\n\tif (chip->device_type == DEVICE_ALI)\n\t\treturn;\n\ttmp = igetdword(chip, ICHREG(GLOB_STA));\n\tsnd_iprintf(buffer, \"Global control        : 0x%08x\\n\",\n\t\t    igetdword(chip, ICHREG(GLOB_CNT)));\n\tsnd_iprintf(buffer, \"Global status         : 0x%08x\\n\", tmp);\n\tsnd_iprintf(buffer, \"AC'97 codecs ready    :%s%s%s%s\\n\",\n\t\t\ttmp & ICH_PCR ? \" primary\" : \"\",\n\t\t\ttmp & ICH_SCR ? \" secondary\" : \"\",\n\t\t\ttmp & ICH_TCR ? \" tertiary\" : \"\",\n\t\t\t(tmp & (ICH_PCR | ICH_SCR | ICH_TCR)) == 0 ? \" none\" : \"\");\n}\n\nstatic void snd_intel8x0m_proc_init(struct intel8x0m *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"intel8x0m\", chip,\n\t\t\t     snd_intel8x0m_proc_read);\n}\n\nstruct ich_reg_info {\n\tunsigned int int_sta_mask;\n\tunsigned int offset;\n};\n\nstatic int snd_intel8x0m_init(struct snd_card *card,\n\t\t\t      struct pci_dev *pci,\n\t\t\t      unsigned long device_type)\n{\n\tstruct intel8x0m *chip = card->private_data;\n\tint err;\n\tunsigned int i;\n\tunsigned int int_sta_masks;\n\tstruct ichdev *ichdev;\n\tstatic const struct ich_reg_info intel_regs[2] = {\n\t\t{ ICH_MIINT, 0 },\n\t\t{ ICH_MOINT, 0x10 },\n\t};\n\tconst struct ich_reg_info *tbl;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tchip->device_type = device_type;\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\n\terr = pci_request_regions(pci, card->shortname);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (device_type == DEVICE_ALI) {\n\t\t \n\t\tchip->bmaddr = pcim_iomap(pci, 0, 0);\n\t} else {\n\t\tif (pci_resource_flags(pci, 2) & IORESOURCE_MEM)  \n\t\t\tchip->addr = pcim_iomap(pci, 2, 0);\n\t\telse\n\t\t\tchip->addr = pcim_iomap(pci, 0, 0);\n\t\tif (pci_resource_flags(pci, 3) & IORESOURCE_MEM)  \n\t\t\tchip->bmaddr = pcim_iomap(pci, 3, 0);\n\t\telse\n\t\t\tchip->bmaddr = pcim_iomap(pci, 1, 0);\n\t}\n\n\t \n\tchip->bdbars_count = 2;\n\ttbl = intel_regs;\n\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tichdev->ichd = i;\n\t\tichdev->reg_offset = tbl[i].offset;\n\t\tichdev->int_sta_mask = tbl[i].int_sta_mask;\n\t\tif (device_type == DEVICE_SIS) {\n\t\t\t \n\t\t\tichdev->roff_sr = ICH_REG_OFF_PICB;\n\t\t\tichdev->roff_picb = ICH_REG_OFF_SR;\n\t\t} else {\n\t\t\tichdev->roff_sr = ICH_REG_OFF_SR;\n\t\t\tichdev->roff_picb = ICH_REG_OFF_PICB;\n\t\t}\n\t\tif (device_type == DEVICE_ALI)\n\t\t\tichdev->ali_slot = (ichdev->reg_offset - 0x40) / 0x10;\n\t}\n\t \n\tchip->pcm_pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;\n\n\t \n\t \n\tchip->bdbars = snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    chip->bdbars_count * sizeof(u32) *\n\t\t\t\t\t    ICH_MAX_FRAGS * 2);\n\tif (!chip->bdbars)\n\t\treturn -ENOMEM;\n\n\t \n\tint_sta_masks = 0;\n\tfor (i = 0; i < chip->bdbars_count; i++) {\n\t\tichdev = &chip->ichd[i];\n\t\tichdev->bdbar = ((__le32 *)chip->bdbars->area) + (i * ICH_MAX_FRAGS * 2);\n\t\tichdev->bdbar_addr = chip->bdbars->addr + (i * sizeof(u32) * ICH_MAX_FRAGS * 2);\n\t\tint_sta_masks |= ichdev->int_sta_mask;\n\t}\n\tchip->int_sta_reg = ICH_REG_GLOB_STA;\n\tchip->int_sta_mask = int_sta_masks;\n\n\tpci_set_master(pci);\n\n\terr = snd_intel8x0m_chip_init(chip, 1);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (request_irq(pci->irq, snd_intel8x0m_interrupt, IRQF_SHARED,\n\t\t\tKBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\n\tcard->private_free = snd_intel8x0m_free;\n\n\treturn 0;\n}\n\nstatic struct shortname_table {\n\tunsigned int id;\n\tconst char *s;\n} shortnames[] = {\n\t{ PCI_DEVICE_ID_INTEL_82801AA_6, \"Intel 82801AA-ICH\" },\n\t{ PCI_DEVICE_ID_INTEL_82801AB_6, \"Intel 82901AB-ICH0\" },\n\t{ PCI_DEVICE_ID_INTEL_82801BA_6, \"Intel 82801BA-ICH2\" },\n\t{ PCI_DEVICE_ID_INTEL_440MX_6, \"Intel 440MX\" },\n\t{ PCI_DEVICE_ID_INTEL_82801CA_6, \"Intel 82801CA-ICH3\" },\n\t{ PCI_DEVICE_ID_INTEL_82801DB_6, \"Intel 82801DB-ICH4\" },\n\t{ PCI_DEVICE_ID_INTEL_82801EB_6, \"Intel ICH5\" },\n\t{ PCI_DEVICE_ID_INTEL_ICH6_17, \"Intel ICH6\" },\n\t{ PCI_DEVICE_ID_INTEL_ICH7_19, \"Intel ICH7\" },\n\t{ 0x7446, \"AMD AMD768\" },\n\t{ PCI_DEVICE_ID_SI_7013, \"SiS SI7013\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP1_MODEM, \"NVidia nForce\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP2_MODEM, \"NVidia nForce2\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP2S_MODEM, \"NVidia nForce2s\" },\n\t{ PCI_DEVICE_ID_NVIDIA_MCP3_MODEM, \"NVidia nForce3\" },\n\t{ 0x746e, \"AMD AMD8111\" },\n#if 0\n\t{ 0x5455, \"ALi M5455\" },\n#endif\n\t{ 0 },\n};\n\nstatic int __snd_intel8x0m_probe(struct pci_dev *pci,\n\t\t\t\t const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct intel8x0m *chip;\n\tint err;\n\tstruct shortname_table *name;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tstrcpy(card->driver, \"ICH-MODEM\");\n\tstrcpy(card->shortname, \"Intel ICH\");\n\tfor (name = shortnames; name->id; name++) {\n\t\tif (pci->device == name->id) {\n\t\t\tstrcpy(card->shortname, name->s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrcat(card->shortname,\" Modem\");\n\n\terr = snd_intel8x0m_init(card, pci, pci_id->driver_data);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_intel8x0m_mixer(chip, ac97_clock);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_intel8x0m_pcm(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_intel8x0m_proc_init(chip);\n\n\tsprintf(card->longname, \"%s at irq %i\",\n\t\tcard->shortname, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_intel8x0m_probe(struct pci_dev *pci,\n\t\t\t       const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_intel8x0m_probe(pci, pci_id));\n}\n\nstatic struct pci_driver intel8x0m_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_intel8x0m_ids,\n\t.probe = snd_intel8x0m_probe,\n\t.driver = {\n\t\t.pm = INTEL8X0M_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(intel8x0m_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}