{
  "module_name": "hdsp.c",
  "hash_id": "bbb020bc2d7c5f3f964cc436ae0ddde1ccfe2b5f114bece656fde8d63155a387",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/rme9652/hdsp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n#include <linux/nospec.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/asoundef.h>\n#include <sound/rawmidi.h>\n#include <sound/hwdep.h>\n#include <sound/initval.h>\n#include <sound/hdsp.h>\n\n#include <asm/byteorder.h>\n#include <asm/current.h>\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for RME Hammerfall DSP interface.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for RME Hammerfall DSP interface.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable/disable specific Hammerfall DSP soundcards.\");\nMODULE_AUTHOR(\"Paul Davis <paul@linuxaudiosystems.com>, Marcus Andersson, Thomas Charbonnel <thomas@undata.org>\");\nMODULE_DESCRIPTION(\"RME Hammerfall DSP\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"rpm_firmware.bin\");\nMODULE_FIRMWARE(\"multiface_firmware.bin\");\nMODULE_FIRMWARE(\"multiface_firmware_rev11.bin\");\nMODULE_FIRMWARE(\"digiface_firmware.bin\");\nMODULE_FIRMWARE(\"digiface_firmware_rev11.bin\");\n\n#define HDSP_MAX_CHANNELS        26\n#define HDSP_MAX_DS_CHANNELS     14\n#define HDSP_MAX_QS_CHANNELS     8\n#define DIGIFACE_SS_CHANNELS     26\n#define DIGIFACE_DS_CHANNELS     14\n#define MULTIFACE_SS_CHANNELS    18\n#define MULTIFACE_DS_CHANNELS    14\n#define H9652_SS_CHANNELS        26\n#define H9652_DS_CHANNELS        14\n \n#define H9632_SS_CHANNELS\t 12\n#define H9632_DS_CHANNELS\t 8\n#define H9632_QS_CHANNELS\t 4\n#define RPM_CHANNELS             6\n\n \n#define HDSP_resetPointer               0\n#define HDSP_freqReg\t\t\t0\n#define HDSP_outputBufferAddress\t32\n#define HDSP_inputBufferAddress\t\t36\n#define HDSP_controlRegister\t\t64\n#define HDSP_interruptConfirmation\t96\n#define HDSP_outputEnable\t  \t128\n#define HDSP_control2Reg\t\t256\n#define HDSP_midiDataOut0  \t\t352\n#define HDSP_midiDataOut1  \t\t356\n#define HDSP_fifoData  \t\t\t368\n#define HDSP_inputEnable\t \t384\n\n \n\n#define HDSP_statusRegister    0\n#define HDSP_timecode        128\n#define HDSP_status2Register 192\n#define HDSP_midiDataIn0     360\n#define HDSP_midiDataIn1     364\n#define HDSP_midiStatusOut0  384\n#define HDSP_midiStatusOut1  388\n#define HDSP_midiStatusIn0   392\n#define HDSP_midiStatusIn1   396\n#define HDSP_fifoStatus      400\n\n \n\n#define HDSP_playbackPeakLevel  4096   \n#define HDSP_inputPeakLevel     4224   \n#define HDSP_outputPeakLevel    4352   \n#define HDSP_playbackRmsLevel   4612   \n#define HDSP_inputRmsLevel      4868   \n\n\n \n#define HDSP_9652_peakBase\t7164\n#define HDSP_9652_rmsBase\t4096\n\n \n#define HDSP_9632_metersBase\t4096\n\n#define HDSP_IO_EXTENT     7168\n\n \n\n#define HDSP_TMS                0x01\n#define HDSP_TCK                0x02\n#define HDSP_TDI                0x04\n#define HDSP_JTAG               0x08\n#define HDSP_PWDN               0x10\n#define HDSP_PROGRAM\t        0x020\n#define HDSP_CONFIG_MODE_0\t0x040\n#define HDSP_CONFIG_MODE_1\t0x080\n#define HDSP_VERSION_BIT\t(0x100 | HDSP_S_LOAD)\n#define HDSP_BIGENDIAN_MODE     0x200\n#define HDSP_RD_MULTIPLE        0x400\n#define HDSP_9652_ENABLE_MIXER  0x800\n#define HDSP_S200\t\t0x800\n#define HDSP_S300\t\t(0x100 | HDSP_S200)  \n#define HDSP_CYCLIC_MODE\t0x1000\n#define HDSP_TDO                0x10000000\n\n#define HDSP_S_PROGRAM\t    (HDSP_CYCLIC_MODE|HDSP_PROGRAM|HDSP_CONFIG_MODE_0)\n#define HDSP_S_LOAD\t    (HDSP_CYCLIC_MODE|HDSP_PROGRAM|HDSP_CONFIG_MODE_1)\n\n \n\n#define HDSP_Start                (1<<0)   \n#define HDSP_Latency0             (1<<1)   \n#define HDSP_Latency1             (1<<2)   \n#define HDSP_Latency2             (1<<3)   \n#define HDSP_ClockModeMaster      (1<<4)   \n#define HDSP_AudioInterruptEnable (1<<5)   \n#define HDSP_Frequency0           (1<<6)   \n#define HDSP_Frequency1           (1<<7)   \n#define HDSP_DoubleSpeed          (1<<8)   \n#define HDSP_SPDIFProfessional    (1<<9)   \n#define HDSP_SPDIFEmphasis        (1<<10)  \n#define HDSP_SPDIFNonAudio        (1<<11)  \n#define HDSP_SPDIFOpticalOut      (1<<12)  \n#define HDSP_SyncRef2             (1<<13)\n#define HDSP_SPDIFInputSelect0    (1<<14)\n#define HDSP_SPDIFInputSelect1    (1<<15)\n#define HDSP_SyncRef0             (1<<16)\n#define HDSP_SyncRef1             (1<<17)\n#define HDSP_AnalogExtensionBoard (1<<18)  \n#define HDSP_XLRBreakoutCable     (1<<20)  \n#define HDSP_Midi0InterruptEnable (1<<22)\n#define HDSP_Midi1InterruptEnable (1<<23)\n#define HDSP_LineOut              (1<<24)\n#define HDSP_ADGain0\t\t  (1<<25)  \n#define HDSP_ADGain1\t\t  (1<<26)\n#define HDSP_DAGain0\t\t  (1<<27)\n#define HDSP_DAGain1\t\t  (1<<28)\n#define HDSP_PhoneGain0\t\t  (1<<29)\n#define HDSP_PhoneGain1\t\t  (1<<30)\n#define HDSP_QuadSpeed\t  \t  (1<<31)\n\n \n#define HDSP_RPM_Inp12            0x04A00\n#define HDSP_RPM_Inp12_Phon_6dB   0x00800   \n#define HDSP_RPM_Inp12_Phon_0dB   0x00000   \n#define HDSP_RPM_Inp12_Phon_n6dB  0x04000   \n#define HDSP_RPM_Inp12_Line_0dB   0x04200   \n#define HDSP_RPM_Inp12_Line_n6dB  0x00200   \n\n#define HDSP_RPM_Inp34            0x32000\n#define HDSP_RPM_Inp34_Phon_6dB   0x20000   \n#define HDSP_RPM_Inp34_Phon_0dB   0x00000   \n#define HDSP_RPM_Inp34_Phon_n6dB  0x02000   \n#define HDSP_RPM_Inp34_Line_0dB   0x30000   \n#define HDSP_RPM_Inp34_Line_n6dB  0x10000   \n\n#define HDSP_RPM_Bypass           0x01000\n\n#define HDSP_RPM_Disconnect       0x00001\n\n#define HDSP_ADGainMask       (HDSP_ADGain0|HDSP_ADGain1)\n#define HDSP_ADGainMinus10dBV  HDSP_ADGainMask\n#define HDSP_ADGainPlus4dBu   (HDSP_ADGain0)\n#define HDSP_ADGainLowGain     0\n\n#define HDSP_DAGainMask         (HDSP_DAGain0|HDSP_DAGain1)\n#define HDSP_DAGainHighGain      HDSP_DAGainMask\n#define HDSP_DAGainPlus4dBu     (HDSP_DAGain0)\n#define HDSP_DAGainMinus10dBV    0\n\n#define HDSP_PhoneGainMask      (HDSP_PhoneGain0|HDSP_PhoneGain1)\n#define HDSP_PhoneGain0dB        HDSP_PhoneGainMask\n#define HDSP_PhoneGainMinus6dB  (HDSP_PhoneGain0)\n#define HDSP_PhoneGainMinus12dB  0\n\n#define HDSP_LatencyMask    (HDSP_Latency0|HDSP_Latency1|HDSP_Latency2)\n#define HDSP_FrequencyMask  (HDSP_Frequency0|HDSP_Frequency1|HDSP_DoubleSpeed|HDSP_QuadSpeed)\n\n#define HDSP_SPDIFInputMask    (HDSP_SPDIFInputSelect0|HDSP_SPDIFInputSelect1)\n#define HDSP_SPDIFInputADAT1    0\n#define HDSP_SPDIFInputCoaxial (HDSP_SPDIFInputSelect0)\n#define HDSP_SPDIFInputCdrom   (HDSP_SPDIFInputSelect1)\n#define HDSP_SPDIFInputAES     (HDSP_SPDIFInputSelect0|HDSP_SPDIFInputSelect1)\n\n#define HDSP_SyncRefMask        (HDSP_SyncRef0|HDSP_SyncRef1|HDSP_SyncRef2)\n#define HDSP_SyncRef_ADAT1       0\n#define HDSP_SyncRef_ADAT2      (HDSP_SyncRef0)\n#define HDSP_SyncRef_ADAT3      (HDSP_SyncRef1)\n#define HDSP_SyncRef_SPDIF      (HDSP_SyncRef0|HDSP_SyncRef1)\n#define HDSP_SyncRef_WORD       (HDSP_SyncRef2)\n#define HDSP_SyncRef_ADAT_SYNC  (HDSP_SyncRef0|HDSP_SyncRef2)\n\n \n\n#define HDSP_CLOCK_SOURCE_AUTOSYNC           0\n#define HDSP_CLOCK_SOURCE_INTERNAL_32KHZ     1\n#define HDSP_CLOCK_SOURCE_INTERNAL_44_1KHZ   2\n#define HDSP_CLOCK_SOURCE_INTERNAL_48KHZ     3\n#define HDSP_CLOCK_SOURCE_INTERNAL_64KHZ     4\n#define HDSP_CLOCK_SOURCE_INTERNAL_88_2KHZ   5\n#define HDSP_CLOCK_SOURCE_INTERNAL_96KHZ     6\n#define HDSP_CLOCK_SOURCE_INTERNAL_128KHZ    7\n#define HDSP_CLOCK_SOURCE_INTERNAL_176_4KHZ  8\n#define HDSP_CLOCK_SOURCE_INTERNAL_192KHZ    9\n\n \n\n#define HDSP_SYNC_FROM_WORD      0\n#define HDSP_SYNC_FROM_SPDIF     1\n#define HDSP_SYNC_FROM_ADAT1     2\n#define HDSP_SYNC_FROM_ADAT_SYNC 3\n#define HDSP_SYNC_FROM_ADAT2     4\n#define HDSP_SYNC_FROM_ADAT3     5\n\n \n\n#define HDSP_SYNC_CHECK_NO_LOCK 0\n#define HDSP_SYNC_CHECK_LOCK    1\n#define HDSP_SYNC_CHECK_SYNC\t2\n\n \n\n#define HDSP_AUTOSYNC_FROM_WORD      0\n#define HDSP_AUTOSYNC_FROM_ADAT_SYNC 1\n#define HDSP_AUTOSYNC_FROM_SPDIF     2\n#define HDSP_AUTOSYNC_FROM_NONE\t     3\n#define HDSP_AUTOSYNC_FROM_ADAT1     4\n#define HDSP_AUTOSYNC_FROM_ADAT2     5\n#define HDSP_AUTOSYNC_FROM_ADAT3     6\n\n \n\n#define HDSP_SPDIFIN_OPTICAL  0\t \n#define HDSP_SPDIFIN_COAXIAL  1\t \n#define HDSP_SPDIFIN_INTERNAL 2\t \n#define HDSP_SPDIFIN_AES      3  \n\n#define HDSP_Frequency32KHz    HDSP_Frequency0\n#define HDSP_Frequency44_1KHz  HDSP_Frequency1\n#define HDSP_Frequency48KHz    (HDSP_Frequency1|HDSP_Frequency0)\n#define HDSP_Frequency64KHz    (HDSP_DoubleSpeed|HDSP_Frequency0)\n#define HDSP_Frequency88_2KHz  (HDSP_DoubleSpeed|HDSP_Frequency1)\n#define HDSP_Frequency96KHz    (HDSP_DoubleSpeed|HDSP_Frequency1|HDSP_Frequency0)\n \n#define HDSP_Frequency128KHz   (HDSP_QuadSpeed|HDSP_DoubleSpeed|HDSP_Frequency0)\n#define HDSP_Frequency176_4KHz (HDSP_QuadSpeed|HDSP_DoubleSpeed|HDSP_Frequency1)\n#define HDSP_Frequency192KHz   (HDSP_QuadSpeed|HDSP_DoubleSpeed|HDSP_Frequency1|HDSP_Frequency0)\n \n#define DDS_NUMERATOR 104857600000000ULL   \n\n#define hdsp_encode_latency(x)       (((x)<<1) & HDSP_LatencyMask)\n#define hdsp_decode_latency(x)       (((x) & HDSP_LatencyMask)>>1)\n\n#define hdsp_encode_spdif_in(x) (((x)&0x3)<<14)\n#define hdsp_decode_spdif_in(x) (((x)>>14)&0x3)\n\n \n\n#define HDSP_audioIRQPending    (1<<0)\n#define HDSP_Lock2              (1<<1)      \n#define HDSP_spdifFrequency3\tHDSP_Lock2  \n#define HDSP_Lock1              (1<<2)\n#define HDSP_Lock0              (1<<3)\n#define HDSP_SPDIFSync          (1<<4)\n#define HDSP_TimecodeLock       (1<<5)\n#define HDSP_BufferPositionMask 0x000FFC0  \n#define HDSP_Sync2              (1<<16)\n#define HDSP_Sync1              (1<<17)\n#define HDSP_Sync0              (1<<18)\n#define HDSP_DoubleSpeedStatus  (1<<19)\n#define HDSP_ConfigError        (1<<20)\n#define HDSP_DllError           (1<<21)\n#define HDSP_spdifFrequency0    (1<<22)\n#define HDSP_spdifFrequency1    (1<<23)\n#define HDSP_spdifFrequency2    (1<<24)\n#define HDSP_SPDIFErrorFlag     (1<<25)\n#define HDSP_BufferID           (1<<26)\n#define HDSP_TimecodeSync       (1<<27)\n#define HDSP_AEBO          \t(1<<28)  \n#define HDSP_AEBI\t\t(1<<29)  \n#define HDSP_midi0IRQPending    (1<<30)\n#define HDSP_midi1IRQPending    (1<<31)\n\n#define HDSP_spdifFrequencyMask    (HDSP_spdifFrequency0|HDSP_spdifFrequency1|HDSP_spdifFrequency2)\n#define HDSP_spdifFrequencyMask_9632 (HDSP_spdifFrequency0|\\\n\t\t\t\t      HDSP_spdifFrequency1|\\\n\t\t\t\t      HDSP_spdifFrequency2|\\\n\t\t\t\t      HDSP_spdifFrequency3)\n\n#define HDSP_spdifFrequency32KHz   (HDSP_spdifFrequency0)\n#define HDSP_spdifFrequency44_1KHz (HDSP_spdifFrequency1)\n#define HDSP_spdifFrequency48KHz   (HDSP_spdifFrequency0|HDSP_spdifFrequency1)\n\n#define HDSP_spdifFrequency64KHz   (HDSP_spdifFrequency2)\n#define HDSP_spdifFrequency88_2KHz (HDSP_spdifFrequency0|HDSP_spdifFrequency2)\n#define HDSP_spdifFrequency96KHz   (HDSP_spdifFrequency2|HDSP_spdifFrequency1)\n\n \n#define HDSP_spdifFrequency128KHz   (HDSP_spdifFrequency0|\\\n\t\t\t\t     HDSP_spdifFrequency1|\\\n\t\t\t\t     HDSP_spdifFrequency2)\n#define HDSP_spdifFrequency176_4KHz HDSP_spdifFrequency3\n#define HDSP_spdifFrequency192KHz   (HDSP_spdifFrequency3|HDSP_spdifFrequency0)\n\n \n\n#define HDSP_version0     (1<<0)\n#define HDSP_version1     (1<<1)\n#define HDSP_version2     (1<<2)\n#define HDSP_wc_lock      (1<<3)\n#define HDSP_wc_sync      (1<<4)\n#define HDSP_inp_freq0    (1<<5)\n#define HDSP_inp_freq1    (1<<6)\n#define HDSP_inp_freq2    (1<<7)\n#define HDSP_SelSyncRef0  (1<<8)\n#define HDSP_SelSyncRef1  (1<<9)\n#define HDSP_SelSyncRef2  (1<<10)\n\n#define HDSP_wc_valid (HDSP_wc_lock|HDSP_wc_sync)\n\n#define HDSP_systemFrequencyMask (HDSP_inp_freq0|HDSP_inp_freq1|HDSP_inp_freq2)\n#define HDSP_systemFrequency32   (HDSP_inp_freq0)\n#define HDSP_systemFrequency44_1 (HDSP_inp_freq1)\n#define HDSP_systemFrequency48   (HDSP_inp_freq0|HDSP_inp_freq1)\n#define HDSP_systemFrequency64   (HDSP_inp_freq2)\n#define HDSP_systemFrequency88_2 (HDSP_inp_freq0|HDSP_inp_freq2)\n#define HDSP_systemFrequency96   (HDSP_inp_freq1|HDSP_inp_freq2)\n \n\n#define HDSP_SelSyncRefMask        (HDSP_SelSyncRef0|HDSP_SelSyncRef1|HDSP_SelSyncRef2)\n#define HDSP_SelSyncRef_ADAT1      0\n#define HDSP_SelSyncRef_ADAT2      (HDSP_SelSyncRef0)\n#define HDSP_SelSyncRef_ADAT3      (HDSP_SelSyncRef1)\n#define HDSP_SelSyncRef_SPDIF      (HDSP_SelSyncRef0|HDSP_SelSyncRef1)\n#define HDSP_SelSyncRef_WORD       (HDSP_SelSyncRef2)\n#define HDSP_SelSyncRef_ADAT_SYNC  (HDSP_SelSyncRef0|HDSP_SelSyncRef2)\n\n \n\n#define HDSP_InitializationComplete  (1<<0)\n#define HDSP_FirmwareLoaded\t     (1<<1)\n#define HDSP_FirmwareCached\t     (1<<2)\n\n \n\n#define HDSP_LONG_WAIT\t 5000\n#define HDSP_SHORT_WAIT  30\n\n#define UNITY_GAIN                       32768\n#define MINUS_INFINITY_GAIN              0\n\n \n\n#define HDSP_CHANNEL_BUFFER_SAMPLES  (16*1024)\n#define HDSP_CHANNEL_BUFFER_BYTES    (4*HDSP_CHANNEL_BUFFER_SAMPLES)\n\n \n\n#define HDSP_DMA_AREA_BYTES ((HDSP_MAX_CHANNELS+1) * HDSP_CHANNEL_BUFFER_BYTES)\n#define HDSP_DMA_AREA_KILOBYTES (HDSP_DMA_AREA_BYTES/1024)\n\n#define HDSP_FIRMWARE_SIZE\t(24413 * 4)\n\nstruct hdsp_9632_meters {\n    u32 input_peak[16];\n    u32 playback_peak[16];\n    u32 output_peak[16];\n    u32 xxx_peak[16];\n    u32 padding[64];\n    u32 input_rms_low[16];\n    u32 playback_rms_low[16];\n    u32 output_rms_low[16];\n    u32 xxx_rms_low[16];\n    u32 input_rms_high[16];\n    u32 playback_rms_high[16];\n    u32 output_rms_high[16];\n    u32 xxx_rms_high[16];\n};\n\nstruct hdsp_midi {\n    struct hdsp             *hdsp;\n    int                      id;\n    struct snd_rawmidi           *rmidi;\n    struct snd_rawmidi_substream *input;\n    struct snd_rawmidi_substream *output;\n    signed char\t\t     istimer;  \n    struct timer_list\t     timer;\n    spinlock_t               lock;\n    int\t\t\t     pending;\n};\n\nstruct hdsp {\n\tspinlock_t            lock;\n\tstruct snd_pcm_substream *capture_substream;\n\tstruct snd_pcm_substream *playback_substream;\n        struct hdsp_midi      midi[2];\n\tstruct work_struct    midi_work;\n\tint\t\t      use_midi_work;\n\tint                   precise_ptr;\n\tu32                   control_register;\t      \n\tu32                   control2_register;      \n\tu32                   creg_spdif;\n\tu32                   creg_spdif_stream;\n\tint                   clock_source_locked;\n\tchar                 *card_name;\t  \n\tenum HDSP_IO_Type     io_type;                \n        unsigned short        firmware_rev;\n\tunsigned short\t      state;\t\t      \n\tconst struct firmware *firmware;\n\tu32                  *fw_uploaded;\n\tsize_t                period_bytes; \t      \n\tunsigned char\t      max_channels;\n\tunsigned char\t      qs_in_channels;\t      \n\tunsigned char         ds_in_channels;\n\tunsigned char         ss_in_channels;\t     \n\tunsigned char\t      qs_out_channels;\n\tunsigned char         ds_out_channels;\n\tunsigned char         ss_out_channels;\n\tu32                   io_loopback;           \n\n\t \n\tstruct snd_dma_buffer capture_dma_buf;\n\tstruct snd_dma_buffer playback_dma_buf;\n\tunsigned char        *capture_buffer;\t     \n\tunsigned char        *playback_buffer;\t     \n\n\tpid_t                 capture_pid;\n\tpid_t                 playback_pid;\n\tint                   running;\n\tint                   system_sample_rate;\n\tconst signed char    *channel_map;\n\tint                   dev;\n\tint                   irq;\n\tunsigned long         port;\n        void __iomem         *iobase;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_hwdep          *hwdep;\n\tstruct pci_dev       *pci;\n\tstruct snd_kcontrol *spdif_ctl;\n        unsigned short        mixer_matrix[HDSP_MATRIX_MIXER_SIZE];\n\tunsigned int          dds_value;  \n};\n\n \n\nstatic const signed char channel_map_df_ss[HDSP_MAX_CHANNELS] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\n\t18, 19, 20, 21, 22, 23, 24, 25\n};\n\nstatic const char channel_map_mf_ss[HDSP_MAX_CHANNELS] = {  \n\t \n\t0, 1, 2, 3, 4, 5, 6, 7,\n\t \n\t16, 17, 18, 19, 20, 21, 22, 23,\n\t \n\t24, 25,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const signed char channel_map_ds[HDSP_MAX_CHANNELS] = {\n\t \n\t1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23,\n\t \n\t24, 25,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const signed char channel_map_H9632_ss[HDSP_MAX_CHANNELS] = {\n\t \n\t0, 1, 2, 3, 4, 5, 6, 7,\n\t \n\t8, 9,\n\t \n\t10, 11,\n\t \n\t12, 13, 14, 15,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1\n};\n\nstatic const signed char channel_map_H9632_ds[HDSP_MAX_CHANNELS] = {\n\t \n\t1, 3, 5, 7,\n\t \n\t8, 9,\n\t \n\t10, 11,\n\t \n\t12, 13, 14, 15,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1\n};\n\nstatic const signed char channel_map_H9632_qs[HDSP_MAX_CHANNELS] = {\n\t \n\t \n\t8, 9,\n\t \n\t10, 11,\n\t \n\t12, 13, 14, 15,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1\n};\n\nstatic struct snd_dma_buffer *\nsnd_hammerfall_get_buffer(struct pci_dev *pci, size_t size)\n{\n\treturn snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV, size);\n}\n\nstatic const struct pci_device_id snd_hdsp_ids[] = {\n\t{\n\t\t.vendor = PCI_VENDOR_ID_XILINX,\n\t\t.device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t},  \n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, snd_hdsp_ids);\n\n \nstatic int snd_hdsp_create_alsa_devices(struct snd_card *card, struct hdsp *hdsp);\nstatic int snd_hdsp_create_pcm(struct snd_card *card, struct hdsp *hdsp);\nstatic int snd_hdsp_enable_io (struct hdsp *hdsp);\nstatic void snd_hdsp_initialize_midi_flush (struct hdsp *hdsp);\nstatic void snd_hdsp_initialize_channels (struct hdsp *hdsp);\nstatic int hdsp_fifo_wait(struct hdsp *hdsp, int count, int timeout);\nstatic int hdsp_autosync_ref(struct hdsp *hdsp);\nstatic int snd_hdsp_set_defaults(struct hdsp *hdsp);\nstatic void snd_hdsp_9652_enable_mixer (struct hdsp *hdsp);\n\nstatic int hdsp_playback_to_output_key (struct hdsp *hdsp, int in, int out)\n{\n\tswitch (hdsp->io_type) {\n\tcase Multiface:\n\tcase Digiface:\n\tcase RPM:\n\tdefault:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\treturn (64 * out) + (32 + (in));\n\t\telse\n\t\t\treturn (52 * out) + (26 + (in));\n\tcase H9632:\n\t\treturn (32 * out) + (16 + (in));\n\tcase H9652:\n\t\treturn (52 * out) + (26 + (in));\n\t}\n}\n\nstatic int hdsp_input_to_output_key (struct hdsp *hdsp, int in, int out)\n{\n\tswitch (hdsp->io_type) {\n\tcase Multiface:\n\tcase Digiface:\n\tcase RPM:\n\tdefault:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\treturn (64 * out) + in;\n\t\telse\n\t\t\treturn (52 * out) + in;\n\tcase H9632:\n\t\treturn (32 * out) + in;\n\tcase H9652:\n\t\treturn (52 * out) + in;\n\t}\n}\n\nstatic void hdsp_write(struct hdsp *hdsp, int reg, int val)\n{\n\twritel(val, hdsp->iobase + reg);\n}\n\nstatic unsigned int hdsp_read(struct hdsp *hdsp, int reg)\n{\n\treturn readl (hdsp->iobase + reg);\n}\n\nstatic int hdsp_check_for_iobox (struct hdsp *hdsp)\n{\n\tint i;\n\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return 0;\n\tfor (i = 0; i < 500; i++) {\n\t\tif (0 == (hdsp_read(hdsp, HDSP_statusRegister) &\n\t\t\t\t\tHDSP_ConfigError)) {\n\t\t\tif (i) {\n\t\t\t\tdev_dbg(hdsp->card->dev,\n\t\t\t\t\t\"IO box found after %d ms\\n\",\n\t\t\t\t\t\t(20 * i));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tmsleep(20);\n\t}\n\tdev_err(hdsp->card->dev, \"no IO box connected!\\n\");\n\thdsp->state &= ~HDSP_FirmwareLoaded;\n\treturn -EIO;\n}\n\nstatic int hdsp_wait_for_iobox(struct hdsp *hdsp, unsigned int loops,\n\t\t\t       unsigned int delay)\n{\n\tunsigned int i;\n\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\treturn 0;\n\n\tfor (i = 0; i != loops; ++i) {\n\t\tif (hdsp_read(hdsp, HDSP_statusRegister) & HDSP_ConfigError)\n\t\t\tmsleep(delay);\n\t\telse {\n\t\t\tdev_dbg(hdsp->card->dev, \"iobox found after %ums!\\n\",\n\t\t\t\t   i * delay);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_info(hdsp->card->dev, \"no IO box connected!\\n\");\n\thdsp->state &= ~HDSP_FirmwareLoaded;\n\treturn -EIO;\n}\n\nstatic int snd_hdsp_load_firmware_from_cache(struct hdsp *hdsp) {\n\n\tint i;\n\tunsigned long flags;\n\tconst u32 *cache;\n\n\tif (hdsp->fw_uploaded)\n\t\tcache = hdsp->fw_uploaded;\n\telse {\n\t\tif (!hdsp->firmware)\n\t\t\treturn -ENODEV;\n\t\tcache = (u32 *)hdsp->firmware->data;\n\t\tif (!cache)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\n\n\t\tdev_info(hdsp->card->dev, \"loading firmware\\n\");\n\n\t\thdsp_write (hdsp, HDSP_control2Reg, HDSP_S_PROGRAM);\n\t\thdsp_write (hdsp, HDSP_fifoData, 0);\n\n\t\tif (hdsp_fifo_wait (hdsp, 0, HDSP_LONG_WAIT)) {\n\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t \"timeout waiting for download preparation\\n\");\n\t\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S200);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\thdsp_write (hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\n\t\tfor (i = 0; i < HDSP_FIRMWARE_SIZE / 4; ++i) {\n\t\t\thdsp_write(hdsp, HDSP_fifoData, cache[i]);\n\t\t\tif (hdsp_fifo_wait (hdsp, 127, HDSP_LONG_WAIT)) {\n\t\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t\t \"timeout during firmware loading\\n\");\n\t\t\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S200);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\thdsp_fifo_wait(hdsp, 3, HDSP_LONG_WAIT);\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S200);\n\n\t\tssleep(3);\n#ifdef SNDRV_BIG_ENDIAN\n\t\thdsp->control2_register = HDSP_BIGENDIAN_MODE;\n#else\n\t\thdsp->control2_register = 0;\n#endif\n\t\thdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\n\t\tdev_info(hdsp->card->dev, \"finished firmware loading\\n\");\n\n\t}\n\tif (hdsp->state & HDSP_InitializationComplete) {\n\t\tdev_info(hdsp->card->dev,\n\t\t\t \"firmware loaded from cache, restoring defaults\\n\");\n\t\tspin_lock_irqsave(&hdsp->lock, flags);\n\t\tsnd_hdsp_set_defaults(hdsp);\n\t\tspin_unlock_irqrestore(&hdsp->lock, flags);\n\t}\n\n\thdsp->state |= HDSP_FirmwareLoaded;\n\n\treturn 0;\n}\n\nstatic int hdsp_get_iobox_version (struct hdsp *hdsp)\n{\n\tif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\n\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\t\thdsp_write(hdsp, HDSP_fifoData, 0);\n\n\t\tif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT) < 0) {\n\t\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S300);\n\t\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\t\t}\n\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S200 | HDSP_PROGRAM);\n\t\thdsp_write (hdsp, HDSP_fifoData, 0);\n\t\tif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT) < 0)\n\t\t\tgoto set_multi;\n\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\t\thdsp_write(hdsp, HDSP_fifoData, 0);\n\t\tif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT) == 0) {\n\t\t\thdsp->io_type = Digiface;\n\t\t\tdev_info(hdsp->card->dev, \"Digiface found\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S300);\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\t\thdsp_write(hdsp, HDSP_fifoData, 0);\n\t\tif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT) == 0)\n\t\t\tgoto set_multi;\n\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S300);\n\t\thdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\n\t\thdsp_write(hdsp, HDSP_fifoData, 0);\n\t\tif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT) < 0)\n\t\t\tgoto set_multi;\n\n\t\thdsp->io_type = RPM;\n\t\tdev_info(hdsp->card->dev, \"RPM found\\n\");\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version2)\n\t\t\thdsp->io_type = RPM;\n\t\telse if (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version1)\n\t\t\thdsp->io_type = Multiface;\n\t\telse\n\t\t\thdsp->io_type = Digiface;\n\t}\n\treturn 0;\n\nset_multi:\n\thdsp->io_type = Multiface;\n\tdev_info(hdsp->card->dev, \"Multiface found\\n\");\n\treturn 0;\n}\n\n\nstatic int hdsp_request_fw_loader(struct hdsp *hdsp);\n\nstatic int hdsp_check_for_firmware (struct hdsp *hdsp, int load_on_demand)\n{\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\treturn 0;\n\tif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\n\t\thdsp->state &= ~HDSP_FirmwareLoaded;\n\t\tif (! load_on_demand)\n\t\t\treturn -EIO;\n\t\tdev_err(hdsp->card->dev, \"firmware not present.\\n\");\n\t\t \n\t\tif (! (hdsp->state & HDSP_FirmwareCached)) {\n\t\t\tif (! hdsp_request_fw_loader(hdsp))\n\t\t\t\treturn 0;\n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t   \"No firmware loaded nor cached, please upload firmware.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (snd_hdsp_load_firmware_from_cache(hdsp) != 0) {\n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t   \"Firmware loading from cache failed, please upload manually.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int hdsp_fifo_wait(struct hdsp *hdsp, int count, int timeout)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < timeout; i++) {\n\n\t\tif ((int)(hdsp_read (hdsp, HDSP_fifoStatus) & 0xff) <= count)\n\t\t\treturn 0;\n\n\t\t \n\n\t\tudelay (100);\n\t}\n\n\tdev_warn(hdsp->card->dev,\n\t\t \"wait for FIFO status <= %d failed after %d iterations\\n\",\n\t\t    count, timeout);\n\treturn -1;\n}\n\nstatic int hdsp_read_gain (struct hdsp *hdsp, unsigned int addr)\n{\n\tif (addr >= HDSP_MATRIX_MIXER_SIZE)\n\t\treturn 0;\n\n\treturn hdsp->mixer_matrix[addr];\n}\n\nstatic int hdsp_write_gain(struct hdsp *hdsp, unsigned int addr, unsigned short data)\n{\n\tunsigned int ad;\n\n\tif (addr >= HDSP_MATRIX_MIXER_SIZE)\n\t\treturn -1;\n\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) {\n\n\t\t \n\n\t\tif (hdsp->io_type == H9632 && addr >= 512)\n\t\t\treturn 0;\n\n\t\tif (hdsp->io_type == H9652 && addr >= 1352)\n\t\t\treturn 0;\n\n\t\thdsp->mixer_matrix[addr] = data;\n\n\n\t\t \n\t\tad = addr/2;\n\n\t\thdsp_write (hdsp, 4096 + (ad*4),\n\t\t\t    (hdsp->mixer_matrix[(addr&0x7fe)+1] << 16) +\n\t\t\t    hdsp->mixer_matrix[addr&0x7fe]);\n\n\t\treturn 0;\n\n\t} else {\n\n\t\tad = (addr << 16) + data;\n\n\t\tif (hdsp_fifo_wait(hdsp, 127, HDSP_LONG_WAIT))\n\t\t\treturn -1;\n\n\t\thdsp_write (hdsp, HDSP_fifoData, ad);\n\t\thdsp->mixer_matrix[addr] = data;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_use_is_exclusive(struct hdsp *hdsp)\n{\n\tunsigned long flags;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&hdsp->lock, flags);\n\tif ((hdsp->playback_pid != hdsp->capture_pid) &&\n\t    (hdsp->playback_pid >= 0) && (hdsp->capture_pid >= 0))\n\t\tret = 0;\n\tspin_unlock_irqrestore(&hdsp->lock, flags);\n\treturn ret;\n}\n\nstatic int hdsp_spdif_sample_rate(struct hdsp *hdsp)\n{\n\tunsigned int status = hdsp_read(hdsp, HDSP_statusRegister);\n\tunsigned int rate_bits = (status & HDSP_spdifFrequencyMask);\n\n\t \n\tif (hdsp->io_type == H9632)\n\t\t rate_bits = (status & HDSP_spdifFrequencyMask_9632);\n\n\tif (status & HDSP_SPDIFErrorFlag)\n\t\treturn 0;\n\n\tswitch (rate_bits) {\n\tcase HDSP_spdifFrequency32KHz: return 32000;\n\tcase HDSP_spdifFrequency44_1KHz: return 44100;\n\tcase HDSP_spdifFrequency48KHz: return 48000;\n\tcase HDSP_spdifFrequency64KHz: return 64000;\n\tcase HDSP_spdifFrequency88_2KHz: return 88200;\n\tcase HDSP_spdifFrequency96KHz: return 96000;\n\tcase HDSP_spdifFrequency128KHz:\n\t\tif (hdsp->io_type == H9632) return 128000;\n\t\tbreak;\n\tcase HDSP_spdifFrequency176_4KHz:\n\t\tif (hdsp->io_type == H9632) return 176400;\n\t\tbreak;\n\tcase HDSP_spdifFrequency192KHz:\n\t\tif (hdsp->io_type == H9632) return 192000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_warn(hdsp->card->dev,\n\t\t \"unknown spdif frequency status; bits = 0x%x, status = 0x%x\\n\",\n\t\t rate_bits, status);\n\treturn 0;\n}\n\nstatic int hdsp_external_sample_rate(struct hdsp *hdsp)\n{\n\tunsigned int status2 = hdsp_read(hdsp, HDSP_status2Register);\n\tunsigned int rate_bits = status2 & HDSP_systemFrequencyMask;\n\n\t \n\tif (hdsp->io_type == H9632 &&\n\t    hdsp_autosync_ref(hdsp) == HDSP_AUTOSYNC_FROM_SPDIF)\n\t\t return hdsp_spdif_sample_rate(hdsp);\n\n\tswitch (rate_bits) {\n\tcase HDSP_systemFrequency32:   return 32000;\n\tcase HDSP_systemFrequency44_1: return 44100;\n\tcase HDSP_systemFrequency48:   return 48000;\n\tcase HDSP_systemFrequency64:   return 64000;\n\tcase HDSP_systemFrequency88_2: return 88200;\n\tcase HDSP_systemFrequency96:   return 96000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void hdsp_compute_period_size(struct hdsp *hdsp)\n{\n\thdsp->period_bytes = 1 << ((hdsp_decode_latency(hdsp->control_register) + 8));\n}\n\nstatic snd_pcm_uframes_t hdsp_hw_pointer(struct hdsp *hdsp)\n{\n\tint position;\n\n\tposition = hdsp_read(hdsp, HDSP_statusRegister);\n\n\tif (!hdsp->precise_ptr)\n\t\treturn (position & HDSP_BufferID) ? (hdsp->period_bytes / 4) : 0;\n\n\tposition &= HDSP_BufferPositionMask;\n\tposition /= 4;\n\tposition &= (hdsp->period_bytes/2) - 1;\n\treturn position;\n}\n\nstatic void hdsp_reset_hw_pointer(struct hdsp *hdsp)\n{\n\thdsp_write (hdsp, HDSP_resetPointer, 0);\n\tif (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)\n\t\t \n\t\thdsp_write (hdsp, HDSP_freqReg, hdsp->dds_value);\n}\n\nstatic void hdsp_start_audio(struct hdsp *s)\n{\n\ts->control_register |= (HDSP_AudioInterruptEnable | HDSP_Start);\n\thdsp_write(s, HDSP_controlRegister, s->control_register);\n}\n\nstatic void hdsp_stop_audio(struct hdsp *s)\n{\n\ts->control_register &= ~(HDSP_Start | HDSP_AudioInterruptEnable);\n\thdsp_write(s, HDSP_controlRegister, s->control_register);\n}\n\nstatic void hdsp_silence_playback(struct hdsp *hdsp)\n{\n\tmemset(hdsp->playback_buffer, 0, HDSP_DMA_AREA_BYTES);\n}\n\nstatic int hdsp_set_interrupt_interval(struct hdsp *s, unsigned int frames)\n{\n\tint n;\n\n\tspin_lock_irq(&s->lock);\n\n\tframes >>= 7;\n\tn = 0;\n\twhile (frames) {\n\t\tn++;\n\t\tframes >>= 1;\n\t}\n\n\ts->control_register &= ~HDSP_LatencyMask;\n\ts->control_register |= hdsp_encode_latency(n);\n\n\thdsp_write(s, HDSP_controlRegister, s->control_register);\n\n\thdsp_compute_period_size(s);\n\n\tspin_unlock_irq(&s->lock);\n\n\treturn 0;\n}\n\nstatic void hdsp_set_dds_value(struct hdsp *hdsp, int rate)\n{\n\tu64 n;\n\n\tif (rate >= 112000)\n\t\trate /= 4;\n\telse if (rate >= 56000)\n\t\trate /= 2;\n\n\tn = DDS_NUMERATOR;\n\tn = div_u64(n, rate);\n\t \n\tsnd_BUG_ON(n >> 32);\n\t \n\thdsp->dds_value = n;\n\thdsp_write(hdsp, HDSP_freqReg, hdsp->dds_value);\n}\n\nstatic int hdsp_set_rate(struct hdsp *hdsp, int rate, int called_internally)\n{\n\tint reject_if_open = 0;\n\tint current_rate;\n\tint rate_bits;\n\n\t \n\n\tif (!(hdsp->control_register & HDSP_ClockModeMaster)) {\n\t\tif (called_internally) {\n\t\t\t \n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\"device is not running as a clock master: cannot set sample rate.\\n\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\t \n\t\t\tint external_freq = hdsp_external_sample_rate(hdsp);\n\t\t\tint spdif_freq = hdsp_spdif_sample_rate(hdsp);\n\n\t\t\tif ((spdif_freq == external_freq*2) && (hdsp_autosync_ref(hdsp) >= HDSP_AUTOSYNC_FROM_ADAT1))\n\t\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t\t \"Detected ADAT in double speed mode\\n\");\n\t\t\telse if (hdsp->io_type == H9632 && (spdif_freq == external_freq*4) && (hdsp_autosync_ref(hdsp) >= HDSP_AUTOSYNC_FROM_ADAT1))\n\t\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t\t \"Detected ADAT in quad speed mode\\n\");\n\t\t\telse if (rate != external_freq) {\n\t\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t\t \"No AutoSync source for requested rate\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurrent_rate = hdsp->system_sample_rate;\n\n\t \n\n\tif (rate > 96000 && hdsp->io_type != H9632)\n\t\treturn -EINVAL;\n\n\tswitch (rate) {\n\tcase 32000:\n\t\tif (current_rate > 48000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency32KHz;\n\t\tbreak;\n\tcase 44100:\n\t\tif (current_rate > 48000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency44_1KHz;\n\t\tbreak;\n\tcase 48000:\n\t\tif (current_rate > 48000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency48KHz;\n\t\tbreak;\n\tcase 64000:\n\t\tif (current_rate <= 48000 || current_rate > 96000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency64KHz;\n\t\tbreak;\n\tcase 88200:\n\t\tif (current_rate <= 48000 || current_rate > 96000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency88_2KHz;\n\t\tbreak;\n\tcase 96000:\n\t\tif (current_rate <= 48000 || current_rate > 96000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency96KHz;\n\t\tbreak;\n\tcase 128000:\n\t\tif (current_rate < 128000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency128KHz;\n\t\tbreak;\n\tcase 176400:\n\t\tif (current_rate < 128000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency176_4KHz;\n\t\tbreak;\n\tcase 192000:\n\t\tif (current_rate < 128000)\n\t\t\treject_if_open = 1;\n\t\trate_bits = HDSP_Frequency192KHz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (reject_if_open && (hdsp->capture_pid >= 0 || hdsp->playback_pid >= 0)) {\n\t\tdev_warn(hdsp->card->dev,\n\t\t\t \"cannot change speed mode (capture PID = %d, playback PID = %d)\\n\",\n\t\t\t    hdsp->capture_pid,\n\t\t\t    hdsp->playback_pid);\n\t\treturn -EBUSY;\n\t}\n\n\thdsp->control_register &= ~HDSP_FrequencyMask;\n\thdsp->control_register |= rate_bits;\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\n\t \n\tif (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)\n\t\thdsp_set_dds_value(hdsp, rate);\n\n\tif (rate >= 128000) {\n\t\thdsp->channel_map = channel_map_H9632_qs;\n\t} else if (rate > 48000) {\n\t\tif (hdsp->io_type == H9632)\n\t\t\thdsp->channel_map = channel_map_H9632_ds;\n\t\telse\n\t\t\thdsp->channel_map = channel_map_ds;\n\t} else {\n\t\tswitch (hdsp->io_type) {\n\t\tcase RPM:\n\t\tcase Multiface:\n\t\t\thdsp->channel_map = channel_map_mf_ss;\n\t\t\tbreak;\n\t\tcase Digiface:\n\t\tcase H9652:\n\t\t\thdsp->channel_map = channel_map_df_ss;\n\t\t\tbreak;\n\t\tcase H9632:\n\t\t\thdsp->channel_map = channel_map_H9632_ss;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\thdsp->system_sample_rate = rate;\n\n\treturn 0;\n}\n\n \n\nstatic unsigned char snd_hdsp_midi_read_byte (struct hdsp *hdsp, int id)\n{\n\t \n\tif (id)\n\t\treturn hdsp_read(hdsp, HDSP_midiDataIn1);\n\telse\n\t\treturn hdsp_read(hdsp, HDSP_midiDataIn0);\n}\n\nstatic void snd_hdsp_midi_write_byte (struct hdsp *hdsp, int id, int val)\n{\n\t \n\tif (id)\n\t\thdsp_write(hdsp, HDSP_midiDataOut1, val);\n\telse\n\t\thdsp_write(hdsp, HDSP_midiDataOut0, val);\n}\n\nstatic int snd_hdsp_midi_input_available (struct hdsp *hdsp, int id)\n{\n\tif (id)\n\t\treturn (hdsp_read(hdsp, HDSP_midiStatusIn1) & 0xff);\n\telse\n\t\treturn (hdsp_read(hdsp, HDSP_midiStatusIn0) & 0xff);\n}\n\nstatic int snd_hdsp_midi_output_possible (struct hdsp *hdsp, int id)\n{\n\tint fifo_bytes_used;\n\n\tif (id)\n\t\tfifo_bytes_used = hdsp_read(hdsp, HDSP_midiStatusOut1) & 0xff;\n\telse\n\t\tfifo_bytes_used = hdsp_read(hdsp, HDSP_midiStatusOut0) & 0xff;\n\n\tif (fifo_bytes_used < 128)\n\t\treturn  128 - fifo_bytes_used;\n\telse\n\t\treturn 0;\n}\n\nstatic void snd_hdsp_flush_midi_input (struct hdsp *hdsp, int id)\n{\n\twhile (snd_hdsp_midi_input_available (hdsp, id))\n\t\tsnd_hdsp_midi_read_byte (hdsp, id);\n}\n\nstatic int snd_hdsp_midi_output_write (struct hdsp_midi *hmidi)\n{\n\tunsigned long flags;\n\tint n_pending;\n\tint to_write;\n\tint i;\n\tunsigned char buf[128];\n\n\t \n\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tif (hmidi->output) {\n\t\tif (!snd_rawmidi_transmit_empty (hmidi->output)) {\n\t\t\tn_pending = snd_hdsp_midi_output_possible(hmidi->hdsp, hmidi->id);\n\t\t\tif (n_pending > 0) {\n\t\t\t\tif (n_pending > (int)sizeof (buf))\n\t\t\t\t\tn_pending = sizeof (buf);\n\n\t\t\t\tto_write = snd_rawmidi_transmit(hmidi->output, buf, n_pending);\n\t\t\t\tif (to_write > 0) {\n\t\t\t\t\tfor (i = 0; i < to_write; ++i)\n\t\t\t\t\t\tsnd_hdsp_midi_write_byte (hmidi->hdsp, hmidi->id, buf[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n\treturn 0;\n}\n\nstatic int snd_hdsp_midi_input_read (struct hdsp_midi *hmidi)\n{\n\tunsigned char buf[128];  \n\tunsigned long flags;\n\tint n_pending;\n\tint i;\n\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tn_pending = snd_hdsp_midi_input_available(hmidi->hdsp, hmidi->id);\n\tif (n_pending > 0) {\n\t\tif (hmidi->input) {\n\t\t\tif (n_pending > (int)sizeof (buf))\n\t\t\t\tn_pending = sizeof (buf);\n\t\t\tfor (i = 0; i < n_pending; ++i)\n\t\t\t\tbuf[i] = snd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);\n\t\t\tif (n_pending)\n\t\t\t\tsnd_rawmidi_receive (hmidi->input, buf, n_pending);\n\t\t} else {\n\t\t\t \n\t\t\twhile (--n_pending)\n\t\t\t\tsnd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);\n\t\t}\n\t}\n\thmidi->pending = 0;\n\tif (hmidi->id)\n\t\thmidi->hdsp->control_register |= HDSP_Midi1InterruptEnable;\n\telse\n\t\thmidi->hdsp->control_register |= HDSP_Midi0InterruptEnable;\n\thdsp_write(hmidi->hdsp, HDSP_controlRegister, hmidi->hdsp->control_register);\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n\treturn snd_hdsp_midi_output_write (hmidi);\n}\n\nstatic void snd_hdsp_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct hdsp *hdsp;\n\tstruct hdsp_midi *hmidi;\n\tunsigned long flags;\n\tu32 ie;\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\thdsp = hmidi->hdsp;\n\tie = hmidi->id ? HDSP_Midi1InterruptEnable : HDSP_Midi0InterruptEnable;\n\tspin_lock_irqsave (&hdsp->lock, flags);\n\tif (up) {\n\t\tif (!(hdsp->control_register & ie)) {\n\t\t\tsnd_hdsp_flush_midi_input (hdsp, hmidi->id);\n\t\t\thdsp->control_register |= ie;\n\t\t}\n\t} else {\n\t\thdsp->control_register &= ~ie;\n\t}\n\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\tspin_unlock_irqrestore (&hdsp->lock, flags);\n}\n\nstatic void snd_hdsp_midi_output_timer(struct timer_list *t)\n{\n\tstruct hdsp_midi *hmidi = from_timer(hmidi, t, timer);\n\tunsigned long flags;\n\n\tsnd_hdsp_midi_output_write(hmidi);\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\n\t \n\n\tif (hmidi->istimer)\n\t\tmod_timer(&hmidi->timer, 1 + jiffies);\n\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n}\n\nstatic void snd_hdsp_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct hdsp_midi *hmidi;\n\tunsigned long flags;\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tif (up) {\n\t\tif (!hmidi->istimer) {\n\t\t\ttimer_setup(&hmidi->timer, snd_hdsp_midi_output_timer,\n\t\t\t\t    0);\n\t\t\tmod_timer(&hmidi->timer, 1 + jiffies);\n\t\t\thmidi->istimer++;\n\t\t}\n\t} else {\n\t\tif (hmidi->istimer && --hmidi->istimer <= 0)\n\t\t\tdel_timer (&hmidi->timer);\n\t}\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n\tif (up)\n\t\tsnd_hdsp_midi_output_write(hmidi);\n}\n\nstatic int snd_hdsp_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdsp_midi *hmidi;\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\tsnd_hdsp_flush_midi_input (hmidi->hdsp, hmidi->id);\n\thmidi->input = substream;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdsp_midi *hmidi;\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->output = substream;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdsp_midi *hmidi;\n\n\tsnd_hdsp_midi_input_trigger (substream, 0);\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->input = NULL;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdsp_midi *hmidi;\n\n\tsnd_hdsp_midi_output_trigger (substream, 0);\n\n\thmidi = (struct hdsp_midi *) substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->output = NULL;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_ops snd_hdsp_midi_output =\n{\n\t.open =\t\tsnd_hdsp_midi_output_open,\n\t.close =\tsnd_hdsp_midi_output_close,\n\t.trigger =\tsnd_hdsp_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_hdsp_midi_input =\n{\n\t.open =\t\tsnd_hdsp_midi_input_open,\n\t.close =\tsnd_hdsp_midi_input_close,\n\t.trigger =\tsnd_hdsp_midi_input_trigger,\n};\n\nstatic int snd_hdsp_create_midi (struct snd_card *card, struct hdsp *hdsp, int id)\n{\n\tchar buf[40];\n\n\thdsp->midi[id].id = id;\n\thdsp->midi[id].rmidi = NULL;\n\thdsp->midi[id].input = NULL;\n\thdsp->midi[id].output = NULL;\n\thdsp->midi[id].hdsp = hdsp;\n\thdsp->midi[id].istimer = 0;\n\thdsp->midi[id].pending = 0;\n\tspin_lock_init (&hdsp->midi[id].lock);\n\n\tsnprintf(buf, sizeof(buf), \"%s MIDI %d\", card->shortname, id + 1);\n\tif (snd_rawmidi_new (card, buf, id, 1, 1, &hdsp->midi[id].rmidi) < 0)\n\t\treturn -1;\n\n\tsprintf(hdsp->midi[id].rmidi->name, \"HDSP MIDI %d\", id+1);\n\thdsp->midi[id].rmidi->private_data = &hdsp->midi[id];\n\n\tsnd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdsp_midi_output);\n\tsnd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdsp_midi_input);\n\n\thdsp->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\tSNDRV_RAWMIDI_INFO_INPUT |\n\t\tSNDRV_RAWMIDI_INFO_DUPLEX;\n\n\treturn 0;\n}\n\n \n\nstatic u32 snd_hdsp_convert_from_aes(struct snd_aes_iec958 *aes)\n{\n\tu32 val = 0;\n\tval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? HDSP_SPDIFProfessional : 0;\n\tval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? HDSP_SPDIFNonAudio : 0;\n\tif (val & HDSP_SPDIFProfessional)\n\t\tval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;\n\telse\n\t\tval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;\n\treturn val;\n}\n\nstatic void snd_hdsp_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\n{\n\taes->status[0] = ((val & HDSP_SPDIFProfessional) ? IEC958_AES0_PROFESSIONAL : 0) |\n\t\t\t ((val & HDSP_SPDIFNonAudio) ? IEC958_AES0_NONAUDIO : 0);\n\tif (val & HDSP_SPDIFProfessional)\n\t\taes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\n\telse\n\t\taes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\n}\n\nstatic int snd_hdsp_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_hdsp_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tsnd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif);\n\treturn 0;\n}\n\nstatic int snd_hdsp_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\n\tval = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&hdsp->lock);\n\tchange = val != hdsp->creg_spdif;\n\thdsp->creg_spdif = val;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\nstatic int snd_hdsp_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_hdsp_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tsnd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif_stream);\n\treturn 0;\n}\n\nstatic int snd_hdsp_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\n\tval = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&hdsp->lock);\n\tchange = val != hdsp->creg_spdif_stream;\n\thdsp->creg_spdif_stream = val;\n\thdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\nstatic int snd_hdsp_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_hdsp_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = kcontrol->private_value;\n\treturn 0;\n}\n\n#define HDSP_SPDIF_IN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_spdif_in, \\\n  .get = snd_hdsp_get_spdif_in, \\\n  .put = snd_hdsp_put_spdif_in }\n\nstatic unsigned int hdsp_spdif_in(struct hdsp *hdsp)\n{\n\treturn hdsp_decode_spdif_in(hdsp->control_register & HDSP_SPDIFInputMask);\n}\n\nstatic int hdsp_set_spdif_input(struct hdsp *hdsp, int in)\n{\n\thdsp->control_register &= ~HDSP_SPDIFInputMask;\n\thdsp->control_register |= hdsp_encode_spdif_in(in);\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"Optical\", \"Coaxial\", \"Internal\", \"AES\"\n\t};\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\treturn snd_ctl_enum_info(uinfo, 1, (hdsp->io_type == H9632) ? 4 : 3,\n\t\t\t\t texts);\n}\n\nstatic int snd_hdsp_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_spdif_in(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0] % ((hdsp->io_type == H9632) ? 4 : 3);\n\tspin_lock_irq(&hdsp->lock);\n\tchange = val != hdsp_spdif_in(hdsp);\n\tif (change)\n\t\thdsp_set_spdif_input(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_TOGGLE_SETTING(xname, xindex) \\\n{   .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.info = snd_hdsp_info_toggle_setting, \\\n\t.get = snd_hdsp_get_toggle_setting, \\\n\t.put = snd_hdsp_put_toggle_setting \\\n}\n\nstatic int hdsp_toggle_setting(struct hdsp *hdsp, u32 regmask)\n{\n\treturn (hdsp->control_register & regmask) ? 1 : 0;\n}\n\nstatic int hdsp_set_toggle_setting(struct hdsp *hdsp, u32 regmask, int out)\n{\n\tif (out)\n\t\thdsp->control_register |= regmask;\n\telse\n\t\thdsp->control_register &= ~regmask;\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\n\treturn 0;\n}\n\n#define snd_hdsp_info_toggle_setting\t\t   snd_ctl_boolean_mono_info\n\nstatic int snd_hdsp_get_toggle_setting(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\n\tspin_lock_irq(&hdsp->lock);\n\tucontrol->value.integer.value[0] = hdsp_toggle_setting(hdsp, regmask);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_toggle_setting(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int) val != hdsp_toggle_setting(hdsp, regmask);\n\tif (change)\n\t\thdsp_set_toggle_setting(hdsp, regmask, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_SPDIF_SAMPLE_RATE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n  .info = snd_hdsp_info_spdif_sample_rate, \\\n  .get = snd_hdsp_get_spdif_sample_rate \\\n}\n\nstatic int snd_hdsp_info_spdif_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"32000\", \"44100\", \"48000\", \"64000\", \"88200\", \"96000\",\n\t\t\"None\", \"128000\", \"176400\", \"192000\"\n\t};\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\treturn snd_ctl_enum_info(uinfo, 1, (hdsp->io_type == H9632) ? 10 : 7,\n\t\t\t\t texts);\n}\n\nstatic int snd_hdsp_get_spdif_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tswitch (hdsp_spdif_sample_rate(hdsp)) {\n\tcase 32000:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\tcase 44100:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase 48000:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase 64000:\n\t\tucontrol->value.enumerated.item[0] = 3;\n\t\tbreak;\n\tcase 88200:\n\t\tucontrol->value.enumerated.item[0] = 4;\n\t\tbreak;\n\tcase 96000:\n\t\tucontrol->value.enumerated.item[0] = 5;\n\t\tbreak;\n\tcase 128000:\n\t\tucontrol->value.enumerated.item[0] = 7;\n\t\tbreak;\n\tcase 176400:\n\t\tucontrol->value.enumerated.item[0] = 8;\n\t\tbreak;\n\tcase 192000:\n\t\tucontrol->value.enumerated.item[0] = 9;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 6;\n\t}\n\treturn 0;\n}\n\n#define HDSP_SYSTEM_SAMPLE_RATE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n  .info = snd_hdsp_info_system_sample_rate, \\\n  .get = snd_hdsp_get_system_sample_rate \\\n}\n\nstatic int snd_hdsp_info_system_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_hdsp_get_system_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp->system_sample_rate;\n\treturn 0;\n}\n\n#define HDSP_AUTOSYNC_SAMPLE_RATE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n  .info = snd_hdsp_info_autosync_sample_rate, \\\n  .get = snd_hdsp_get_autosync_sample_rate \\\n}\n\nstatic int snd_hdsp_info_autosync_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tstatic const char * const texts[] = {\n\t\t\"32000\", \"44100\", \"48000\", \"64000\", \"88200\", \"96000\",\n\t\t\"None\", \"128000\", \"176400\", \"192000\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, (hdsp->io_type == H9632) ? 10 : 7,\n\t\t\t\t texts);\n}\n\nstatic int snd_hdsp_get_autosync_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tswitch (hdsp_external_sample_rate(hdsp)) {\n\tcase 32000:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\tcase 44100:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase 48000:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase 64000:\n\t\tucontrol->value.enumerated.item[0] = 3;\n\t\tbreak;\n\tcase 88200:\n\t\tucontrol->value.enumerated.item[0] = 4;\n\t\tbreak;\n\tcase 96000:\n\t\tucontrol->value.enumerated.item[0] = 5;\n\t\tbreak;\n\tcase 128000:\n\t\tucontrol->value.enumerated.item[0] = 7;\n\t\tbreak;\n\tcase 176400:\n\t\tucontrol->value.enumerated.item[0] = 8;\n\t\tbreak;\n\tcase 192000:\n\t\tucontrol->value.enumerated.item[0] = 9;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 6;\n\t}\n\treturn 0;\n}\n\n#define HDSP_SYSTEM_CLOCK_MODE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n  .info = snd_hdsp_info_system_clock_mode, \\\n  .get = snd_hdsp_get_system_clock_mode \\\n}\n\nstatic int hdsp_system_clock_mode(struct hdsp *hdsp)\n{\n\tif (hdsp->control_register & HDSP_ClockModeMaster)\n\t\treturn 0;\n\telse if (hdsp_external_sample_rate(hdsp) != hdsp->system_sample_rate)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int snd_hdsp_info_system_clock_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"Master\", \"Slave\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_hdsp_get_system_clock_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_system_clock_mode(hdsp);\n\treturn 0;\n}\n\n#define HDSP_CLOCK_SOURCE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_clock_source, \\\n  .get = snd_hdsp_get_clock_source, \\\n  .put = snd_hdsp_put_clock_source \\\n}\n\nstatic int hdsp_clock_source(struct hdsp *hdsp)\n{\n\tif (hdsp->control_register & HDSP_ClockModeMaster) {\n\t\tswitch (hdsp->system_sample_rate) {\n\t\tcase 32000:\n\t\t\treturn 1;\n\t\tcase 44100:\n\t\t\treturn 2;\n\t\tcase 48000:\n\t\t\treturn 3;\n\t\tcase 64000:\n\t\t\treturn 4;\n\t\tcase 88200:\n\t\t\treturn 5;\n\t\tcase 96000:\n\t\t\treturn 6;\n\t\tcase 128000:\n\t\t\treturn 7;\n\t\tcase 176400:\n\t\t\treturn 8;\n\t\tcase 192000:\n\t\t\treturn 9;\n\t\tdefault:\n\t\t\treturn 3;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int hdsp_set_clock_source(struct hdsp *hdsp, int mode)\n{\n\tint rate;\n\tswitch (mode) {\n\tcase HDSP_CLOCK_SOURCE_AUTOSYNC:\n\t\tif (hdsp_external_sample_rate(hdsp) != 0) {\n\t\t    if (!hdsp_set_rate(hdsp, hdsp_external_sample_rate(hdsp), 1)) {\n\t\t\thdsp->control_register &= ~HDSP_ClockModeMaster;\n\t\t\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\t\t\treturn 0;\n\t\t    }\n\t\t}\n\t\treturn -1;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_32KHZ:\n\t\trate = 32000;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_44_1KHZ:\n\t\trate = 44100;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_48KHZ:\n\t\trate = 48000;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_64KHZ:\n\t\trate = 64000;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_88_2KHZ:\n\t\trate = 88200;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_96KHZ:\n\t\trate = 96000;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_128KHZ:\n\t\trate = 128000;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_176_4KHZ:\n\t\trate = 176400;\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_192KHZ:\n\t\trate = 192000;\n\t\tbreak;\n\tdefault:\n\t\trate = 48000;\n\t}\n\thdsp->control_register |= HDSP_ClockModeMaster;\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\thdsp_set_rate(hdsp, rate, 1);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"AutoSync\", \"Internal 32.0 kHz\", \"Internal 44.1 kHz\",\n\t\t\"Internal 48.0 kHz\", \"Internal 64.0 kHz\", \"Internal 88.2 kHz\",\n\t\t\"Internal 96.0 kHz\", \"Internal 128 kHz\", \"Internal 176.4 kHz\",\n\t\t\"Internal 192.0 KHz\"\n\t};\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\treturn snd_ctl_enum_info(uinfo, 1, (hdsp->io_type == H9632) ? 10 : 7,\n\t\t\t\t texts);\n}\n\nstatic int snd_hdsp_get_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_clock_source(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0) val = 0;\n\tif (hdsp->io_type == H9632) {\n\t\tif (val > 9)\n\t\t\tval = 9;\n\t} else {\n\t\tif (val > 6)\n\t\t\tval = 6;\n\t}\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_clock_source(hdsp))\n\t\tchange = (hdsp_set_clock_source(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define snd_hdsp_info_clock_source_lock\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_hdsp_get_clock_source_lock(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdsp->clock_source_locked;\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_clock_source_lock(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\n\tchange = (int)ucontrol->value.integer.value[0] != hdsp->clock_source_locked;\n\tif (change)\n\t\thdsp->clock_source_locked = !!ucontrol->value.integer.value[0];\n\treturn change;\n}\n\n#define HDSP_DA_GAIN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_da_gain, \\\n  .get = snd_hdsp_get_da_gain, \\\n  .put = snd_hdsp_put_da_gain \\\n}\n\nstatic int hdsp_da_gain(struct hdsp *hdsp)\n{\n\tswitch (hdsp->control_register & HDSP_DAGainMask) {\n\tcase HDSP_DAGainHighGain:\n\t\treturn 0;\n\tcase HDSP_DAGainPlus4dBu:\n\t\treturn 1;\n\tcase HDSP_DAGainMinus10dBV:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int hdsp_set_da_gain(struct hdsp *hdsp, int mode)\n{\n\thdsp->control_register &= ~HDSP_DAGainMask;\n\tswitch (mode) {\n\tcase 0:\n\t\thdsp->control_register |= HDSP_DAGainHighGain;\n\t\tbreak;\n\tcase 1:\n\t\thdsp->control_register |= HDSP_DAGainPlus4dBu;\n\t\tbreak;\n\tcase 2:\n\t\thdsp->control_register |= HDSP_DAGainMinus10dBV;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\n\t}\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"Hi Gain\", \"+4 dBu\", \"-10 dbV\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_hdsp_get_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_da_gain(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0) val = 0;\n\tif (val > 2) val = 2;\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_da_gain(hdsp))\n\t\tchange = (hdsp_set_da_gain(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_AD_GAIN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_ad_gain, \\\n  .get = snd_hdsp_get_ad_gain, \\\n  .put = snd_hdsp_put_ad_gain \\\n}\n\nstatic int hdsp_ad_gain(struct hdsp *hdsp)\n{\n\tswitch (hdsp->control_register & HDSP_ADGainMask) {\n\tcase HDSP_ADGainMinus10dBV:\n\t\treturn 0;\n\tcase HDSP_ADGainPlus4dBu:\n\t\treturn 1;\n\tcase HDSP_ADGainLowGain:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int hdsp_set_ad_gain(struct hdsp *hdsp, int mode)\n{\n\thdsp->control_register &= ~HDSP_ADGainMask;\n\tswitch (mode) {\n\tcase 0:\n\t\thdsp->control_register |= HDSP_ADGainMinus10dBV;\n\t\tbreak;\n\tcase 1:\n\t\thdsp->control_register |= HDSP_ADGainPlus4dBu;\n\t\tbreak;\n\tcase 2:\n\t\thdsp->control_register |= HDSP_ADGainLowGain;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\n\t}\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"-10 dBV\", \"+4 dBu\", \"Lo Gain\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_hdsp_get_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_ad_gain(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0) val = 0;\n\tif (val > 2) val = 2;\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_ad_gain(hdsp))\n\t\tchange = (hdsp_set_ad_gain(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_PHONE_GAIN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_phone_gain, \\\n  .get = snd_hdsp_get_phone_gain, \\\n  .put = snd_hdsp_put_phone_gain \\\n}\n\nstatic int hdsp_phone_gain(struct hdsp *hdsp)\n{\n\tswitch (hdsp->control_register & HDSP_PhoneGainMask) {\n\tcase HDSP_PhoneGain0dB:\n\t\treturn 0;\n\tcase HDSP_PhoneGainMinus6dB:\n\t\treturn 1;\n\tcase HDSP_PhoneGainMinus12dB:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int hdsp_set_phone_gain(struct hdsp *hdsp, int mode)\n{\n\thdsp->control_register &= ~HDSP_PhoneGainMask;\n\tswitch (mode) {\n\tcase 0:\n\t\thdsp->control_register |= HDSP_PhoneGain0dB;\n\t\tbreak;\n\tcase 1:\n\t\thdsp->control_register |= HDSP_PhoneGainMinus6dB;\n\t\tbreak;\n\tcase 2:\n\t\thdsp->control_register |= HDSP_PhoneGainMinus12dB;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\n\t}\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"0 dB\", \"-6 dB\", \"-12 dB\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_hdsp_get_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_phone_gain(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0) val = 0;\n\tif (val > 2) val = 2;\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_phone_gain(hdsp))\n\t\tchange = (hdsp_set_phone_gain(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_PREF_SYNC_REF(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_pref_sync_ref, \\\n  .get = snd_hdsp_get_pref_sync_ref, \\\n  .put = snd_hdsp_put_pref_sync_ref \\\n}\n\nstatic int hdsp_pref_sync_ref(struct hdsp *hdsp)\n{\n\t \n\n\tswitch (hdsp->control_register & HDSP_SyncRefMask) {\n\tcase HDSP_SyncRef_ADAT1:\n\t\treturn HDSP_SYNC_FROM_ADAT1;\n\tcase HDSP_SyncRef_ADAT2:\n\t\treturn HDSP_SYNC_FROM_ADAT2;\n\tcase HDSP_SyncRef_ADAT3:\n\t\treturn HDSP_SYNC_FROM_ADAT3;\n\tcase HDSP_SyncRef_SPDIF:\n\t\treturn HDSP_SYNC_FROM_SPDIF;\n\tcase HDSP_SyncRef_WORD:\n\t\treturn HDSP_SYNC_FROM_WORD;\n\tcase HDSP_SyncRef_ADAT_SYNC:\n\t\treturn HDSP_SYNC_FROM_ADAT_SYNC;\n\tdefault:\n\t\treturn HDSP_SYNC_FROM_WORD;\n\t}\n\treturn 0;\n}\n\nstatic int hdsp_set_pref_sync_ref(struct hdsp *hdsp, int pref)\n{\n\thdsp->control_register &= ~HDSP_SyncRefMask;\n\tswitch (pref) {\n\tcase HDSP_SYNC_FROM_ADAT1:\n\t\thdsp->control_register &= ~HDSP_SyncRefMask;  \n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT2:\n\t\thdsp->control_register |= HDSP_SyncRef_ADAT2;\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT3:\n\t\thdsp->control_register |= HDSP_SyncRef_ADAT3;\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_SPDIF:\n\t\thdsp->control_register |= HDSP_SyncRef_SPDIF;\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_WORD:\n\t\thdsp->control_register |= HDSP_SyncRef_WORD;\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT_SYNC:\n\t\thdsp->control_register |= HDSP_SyncRef_ADAT_SYNC;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"Word\", \"IEC958\", \"ADAT1\", \"ADAT Sync\", \"ADAT2\", \"ADAT3\"\n\t};\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint num_items;\n\n\tswitch (hdsp->io_type) {\n\tcase Digiface:\n\tcase H9652:\n\t\tnum_items = 6;\n\t\tbreak;\n\tcase Multiface:\n\t\tnum_items = 4;\n\t\tbreak;\n\tcase H9632:\n\t\tnum_items = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\n}\n\nstatic int snd_hdsp_get_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_pref_sync_ref(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change, max;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\n\tswitch (hdsp->io_type) {\n\tcase Digiface:\n\tcase H9652:\n\t\tmax = 6;\n\t\tbreak;\n\tcase Multiface:\n\t\tmax = 4;\n\t\tbreak;\n\tcase H9632:\n\t\tmax = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tval = ucontrol->value.enumerated.item[0] % max;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int)val != hdsp_pref_sync_ref(hdsp);\n\thdsp_set_pref_sync_ref(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_AUTOSYNC_REF(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n  .info = snd_hdsp_info_autosync_ref, \\\n  .get = snd_hdsp_get_autosync_ref, \\\n}\n\nstatic int hdsp_autosync_ref(struct hdsp *hdsp)\n{\n\t \n\tunsigned int status2 = hdsp_read(hdsp, HDSP_status2Register);\n\n\tswitch (status2 & HDSP_SelSyncRefMask) {\n\tcase HDSP_SelSyncRef_WORD:\n\t\treturn HDSP_AUTOSYNC_FROM_WORD;\n\tcase HDSP_SelSyncRef_ADAT_SYNC:\n\t\treturn HDSP_AUTOSYNC_FROM_ADAT_SYNC;\n\tcase HDSP_SelSyncRef_SPDIF:\n\t\treturn HDSP_AUTOSYNC_FROM_SPDIF;\n\tcase HDSP_SelSyncRefMask:\n\t\treturn HDSP_AUTOSYNC_FROM_NONE;\n\tcase HDSP_SelSyncRef_ADAT1:\n\t\treturn HDSP_AUTOSYNC_FROM_ADAT1;\n\tcase HDSP_SelSyncRef_ADAT2:\n\t\treturn HDSP_AUTOSYNC_FROM_ADAT2;\n\tcase HDSP_SelSyncRef_ADAT3:\n\t\treturn HDSP_AUTOSYNC_FROM_ADAT3;\n\tdefault:\n\t\treturn HDSP_AUTOSYNC_FROM_WORD;\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_autosync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"Word\", \"ADAT Sync\", \"IEC958\", \"None\", \"ADAT1\", \"ADAT2\", \"ADAT3\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 7, texts);\n}\n\nstatic int snd_hdsp_get_autosync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_autosync_ref(hdsp);\n\treturn 0;\n}\n\n#define HDSP_PRECISE_POINTER(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_CARD, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_precise_pointer, \\\n  .get = snd_hdsp_get_precise_pointer, \\\n  .put = snd_hdsp_put_precise_pointer \\\n}\n\nstatic int hdsp_set_precise_pointer(struct hdsp *hdsp, int precise)\n{\n\tif (precise)\n\t\thdsp->precise_ptr = 1;\n\telse\n\t\thdsp->precise_ptr = 0;\n\treturn 0;\n}\n\n#define snd_hdsp_info_precise_pointer\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_hdsp_get_precise_pointer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdsp->lock);\n\tucontrol->value.integer.value[0] = hdsp->precise_ptr;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_precise_pointer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int)val != hdsp->precise_ptr;\n\thdsp_set_precise_pointer(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_USE_MIDI_WORK(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_CARD, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_use_midi_work, \\\n  .get = snd_hdsp_get_use_midi_work, \\\n  .put = snd_hdsp_put_use_midi_work \\\n}\n\nstatic int hdsp_set_use_midi_work(struct hdsp *hdsp, int use_work)\n{\n\tif (use_work)\n\t\thdsp->use_midi_work = 1;\n\telse\n\t\thdsp->use_midi_work = 0;\n\treturn 0;\n}\n\n#define snd_hdsp_info_use_midi_work\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_hdsp_get_use_midi_work(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdsp->lock);\n\tucontrol->value.integer.value[0] = hdsp->use_midi_work;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_use_midi_work(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int)val != hdsp->use_midi_work;\n\thdsp_set_use_midi_work(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_MIXER(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .device = 0, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_hdsp_info_mixer, \\\n  .get = snd_hdsp_get_mixer, \\\n  .put = snd_hdsp_put_mixer \\\n}\n\nstatic int snd_hdsp_info_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 3;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 65536;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int snd_hdsp_get_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint source;\n\tint destination;\n\tint addr;\n\n\tsource = ucontrol->value.integer.value[0];\n\tdestination = ucontrol->value.integer.value[1];\n\n\tif (source >= hdsp->max_channels)\n\t\taddr = hdsp_playback_to_output_key(hdsp,source-hdsp->max_channels,destination);\n\telse\n\t\taddr = hdsp_input_to_output_key(hdsp,source, destination);\n\n\tspin_lock_irq(&hdsp->lock);\n\tucontrol->value.integer.value[2] = hdsp_read_gain (hdsp, addr);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint source;\n\tint destination;\n\tint gain;\n\tint addr;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\n\tsource = ucontrol->value.integer.value[0];\n\tdestination = ucontrol->value.integer.value[1];\n\n\tif (source >= hdsp->max_channels)\n\t\taddr = hdsp_playback_to_output_key(hdsp,source-hdsp->max_channels, destination);\n\telse\n\t\taddr = hdsp_input_to_output_key(hdsp,source, destination);\n\n\tgain = ucontrol->value.integer.value[2];\n\n\tspin_lock_irq(&hdsp->lock);\n\tchange = gain != hdsp_read_gain(hdsp, addr);\n\tif (change)\n\t\thdsp_write_gain(hdsp, addr, gain);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n#define HDSP_WC_SYNC_CHECK(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_hdsp_info_sync_check, \\\n  .get = snd_hdsp_get_wc_sync_check \\\n}\n\nstatic int snd_hdsp_info_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"No Lock\", \"Lock\", \"Sync\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int hdsp_wc_sync_check(struct hdsp *hdsp)\n{\n\tint status2 = hdsp_read(hdsp, HDSP_status2Register);\n\tif (status2 & HDSP_wc_lock) {\n\t\tif (status2 & HDSP_wc_sync)\n\t\t\treturn 2;\n\t\telse\n\t\t\t return 1;\n\t} else\n\t\treturn 0;\n\treturn 0;\n}\n\nstatic int snd_hdsp_get_wc_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_wc_sync_check(hdsp);\n\treturn 0;\n}\n\n#define HDSP_SPDIF_SYNC_CHECK(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_hdsp_info_sync_check, \\\n  .get = snd_hdsp_get_spdif_sync_check \\\n}\n\nstatic int hdsp_spdif_sync_check(struct hdsp *hdsp)\n{\n\tint status = hdsp_read(hdsp, HDSP_statusRegister);\n\tif (status & HDSP_SPDIFErrorFlag)\n\t\treturn 0;\n\telse {\n\t\tif (status & HDSP_SPDIFSync)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_get_spdif_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_spdif_sync_check(hdsp);\n\treturn 0;\n}\n\n#define HDSP_ADATSYNC_SYNC_CHECK(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_hdsp_info_sync_check, \\\n  .get = snd_hdsp_get_adatsync_sync_check \\\n}\n\nstatic int hdsp_adatsync_sync_check(struct hdsp *hdsp)\n{\n\tint status = hdsp_read(hdsp, HDSP_statusRegister);\n\tif (status & HDSP_TimecodeLock) {\n\t\tif (status & HDSP_TimecodeSync)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int snd_hdsp_get_adatsync_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_adatsync_sync_check(hdsp);\n\treturn 0;\n}\n\n#define HDSP_ADAT_SYNC_CHECK \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_hdsp_info_sync_check, \\\n  .get = snd_hdsp_get_adat_sync_check \\\n}\n\nstatic int hdsp_adat_sync_check(struct hdsp *hdsp, int idx)\n{\n\tint status = hdsp_read(hdsp, HDSP_statusRegister);\n\n\tif (status & (HDSP_Lock0>>idx)) {\n\t\tif (status & (HDSP_Sync0>>idx))\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int snd_hdsp_get_adat_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tint offset;\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\toffset = ucontrol->id.index - 1;\n\tif (snd_BUG_ON(offset < 0))\n\t\treturn -EINVAL;\n\n\tswitch (hdsp->io_type) {\n\tcase Digiface:\n\tcase H9652:\n\t\tif (offset >= 3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase Multiface:\n\tcase H9632:\n\t\tif (offset >= 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tucontrol->value.enumerated.item[0] = hdsp_adat_sync_check(hdsp, offset);\n\treturn 0;\n}\n\n#define HDSP_DDS_OFFSET(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .name = xname, \\\n  .index = xindex, \\\n  .info = snd_hdsp_info_dds_offset, \\\n  .get = snd_hdsp_get_dds_offset, \\\n  .put = snd_hdsp_put_dds_offset \\\n}\n\nstatic int hdsp_dds_offset(struct hdsp *hdsp)\n{\n\tu64 n;\n\tunsigned int dds_value = hdsp->dds_value;\n\tint system_sample_rate = hdsp->system_sample_rate;\n\n\tif (!dds_value)\n\t\treturn 0;\n\n\tn = DDS_NUMERATOR;\n\t \n\tn = div_u64(n, dds_value);\n\tif (system_sample_rate >= 112000)\n\t\tn *= 4;\n\telse if (system_sample_rate >= 56000)\n\t\tn *= 2;\n\treturn ((int)n) - system_sample_rate;\n}\n\nstatic int hdsp_set_dds_offset(struct hdsp *hdsp, int offset_hz)\n{\n\tint rate = hdsp->system_sample_rate + offset_hz;\n\thdsp_set_dds_value(hdsp, rate);\n\treturn 0;\n}\n\nstatic int snd_hdsp_info_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = -5000;\n\tuinfo->value.integer.max = 5000;\n\treturn 0;\n}\n\nstatic int snd_hdsp_get_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdsp_dds_offset(hdsp);\n\treturn 0;\n}\n\nstatic int snd_hdsp_put_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0];\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_dds_offset(hdsp))\n\t\tchange = (hdsp_set_dds_offset(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_hdsp_9632_controls[] = {\nHDSP_DA_GAIN(\"DA Gain\", 0),\nHDSP_AD_GAIN(\"AD Gain\", 0),\nHDSP_PHONE_GAIN(\"Phones Gain\", 0),\nHDSP_TOGGLE_SETTING(\"XLR Breakout Cable\", HDSP_XLRBreakoutCable),\nHDSP_DDS_OFFSET(\"DDS Sample Rate Offset\", 0)\n};\n\nstatic const struct snd_kcontrol_new snd_hdsp_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_hdsp_control_spdif_info,\n\t.get =\t\tsnd_hdsp_control_spdif_get,\n\t.put =\t\tsnd_hdsp_control_spdif_put,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_hdsp_control_spdif_stream_info,\n\t.get =\t\tsnd_hdsp_control_spdif_stream_get,\n\t.put =\t\tsnd_hdsp_control_spdif_stream_put,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tsnd_hdsp_control_spdif_mask_info,\n\t.get =\t\tsnd_hdsp_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n  \t\t\t IEC958_AES0_PROFESSIONAL |\n\t\t\t IEC958_AES0_CON_EMPHASIS,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PRO_MASK),\n\t.info =\t\tsnd_hdsp_control_spdif_mask_info,\n\t.get =\t\tsnd_hdsp_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n\t\t\t IEC958_AES0_PROFESSIONAL |\n\t\t\t IEC958_AES0_PRO_EMPHASIS,\n},\nHDSP_MIXER(\"Mixer\", 0),\nHDSP_SPDIF_IN(\"IEC958 Input Connector\", 0),\nHDSP_TOGGLE_SETTING(\"IEC958 Output also on ADAT1\", HDSP_SPDIFOpticalOut),\nHDSP_TOGGLE_SETTING(\"IEC958 Professional Bit\", HDSP_SPDIFProfessional),\nHDSP_TOGGLE_SETTING(\"IEC958 Emphasis Bit\", HDSP_SPDIFEmphasis),\nHDSP_TOGGLE_SETTING(\"IEC958 Non-audio Bit\", HDSP_SPDIFNonAudio),\n \nHDSP_CLOCK_SOURCE(\"Sample Clock Source\", 0),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Sample Clock Source Locking\",\n\t.info = snd_hdsp_info_clock_source_lock,\n\t.get = snd_hdsp_get_clock_source_lock,\n\t.put = snd_hdsp_put_clock_source_lock,\n},\nHDSP_SYSTEM_CLOCK_MODE(\"System Clock Mode\", 0),\nHDSP_PREF_SYNC_REF(\"Preferred Sync Reference\", 0),\nHDSP_AUTOSYNC_REF(\"AutoSync Reference\", 0),\nHDSP_SPDIF_SAMPLE_RATE(\"SPDIF Sample Rate\", 0),\nHDSP_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n \nHDSP_AUTOSYNC_SAMPLE_RATE(\"External Rate\", 0),\nHDSP_WC_SYNC_CHECK(\"Word Clock Lock Status\", 0),\nHDSP_SPDIF_SYNC_CHECK(\"SPDIF Lock Status\", 0),\nHDSP_ADATSYNC_SYNC_CHECK(\"ADAT Sync Lock Status\", 0),\nHDSP_TOGGLE_SETTING(\"Line Out\", HDSP_LineOut),\nHDSP_PRECISE_POINTER(\"Precise Pointer\", 0),\nHDSP_USE_MIDI_WORK(\"Use Midi Tasklet\", 0),\n};\n\n\nstatic int hdsp_rpm_input12(struct hdsp *hdsp)\n{\n\tswitch (hdsp->control_register & HDSP_RPM_Inp12) {\n\tcase HDSP_RPM_Inp12_Phon_6dB:\n\t\treturn 0;\n\tcase HDSP_RPM_Inp12_Phon_n6dB:\n\t\treturn 2;\n\tcase HDSP_RPM_Inp12_Line_0dB:\n\t\treturn 3;\n\tcase HDSP_RPM_Inp12_Line_n6dB:\n\t\treturn 4;\n\t}\n\treturn 1;\n}\n\n\nstatic int snd_hdsp_get_rpm_input12(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_rpm_input12(hdsp);\n\treturn 0;\n}\n\n\nstatic int hdsp_set_rpm_input12(struct hdsp *hdsp, int mode)\n{\n\thdsp->control_register &= ~HDSP_RPM_Inp12;\n\tswitch (mode) {\n\tcase 0:\n\t\thdsp->control_register |= HDSP_RPM_Inp12_Phon_6dB;\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\thdsp->control_register |= HDSP_RPM_Inp12_Phon_n6dB;\n\t\tbreak;\n\tcase 3:\n\t\thdsp->control_register |= HDSP_RPM_Inp12_Line_0dB;\n\t\tbreak;\n\tcase 4:\n\t\thdsp->control_register |= HDSP_RPM_Inp12_Line_n6dB;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\n\nstatic int snd_hdsp_put_rpm_input12(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 4)\n\t\tval = 4;\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_rpm_input12(hdsp))\n\t\tchange = (hdsp_set_rpm_input12(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n\nstatic int snd_hdsp_info_rpm_input(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\n\t\t\"Phono +6dB\", \"Phono 0dB\", \"Phono -6dB\", \"Line 0dB\", \"Line -6dB\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 5, texts);\n}\n\n\nstatic int hdsp_rpm_input34(struct hdsp *hdsp)\n{\n\tswitch (hdsp->control_register & HDSP_RPM_Inp34) {\n\tcase HDSP_RPM_Inp34_Phon_6dB:\n\t\treturn 0;\n\tcase HDSP_RPM_Inp34_Phon_n6dB:\n\t\treturn 2;\n\tcase HDSP_RPM_Inp34_Line_0dB:\n\t\treturn 3;\n\tcase HDSP_RPM_Inp34_Line_n6dB:\n\t\treturn 4;\n\t}\n\treturn 1;\n}\n\n\nstatic int snd_hdsp_get_rpm_input34(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdsp_rpm_input34(hdsp);\n\treturn 0;\n}\n\n\nstatic int hdsp_set_rpm_input34(struct hdsp *hdsp, int mode)\n{\n\thdsp->control_register &= ~HDSP_RPM_Inp34;\n\tswitch (mode) {\n\tcase 0:\n\t\thdsp->control_register |= HDSP_RPM_Inp34_Phon_6dB;\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\thdsp->control_register |= HDSP_RPM_Inp34_Phon_n6dB;\n\t\tbreak;\n\tcase 3:\n\t\thdsp->control_register |= HDSP_RPM_Inp34_Line_0dB;\n\t\tbreak;\n\tcase 4:\n\t\thdsp->control_register |= HDSP_RPM_Inp34_Line_n6dB;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\n\nstatic int snd_hdsp_put_rpm_input34(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 4)\n\t\tval = 4;\n\tspin_lock_irq(&hdsp->lock);\n\tif (val != hdsp_rpm_input34(hdsp))\n\t\tchange = (hdsp_set_rpm_input34(hdsp, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n\n \nstatic int hdsp_rpm_bypass(struct hdsp *hdsp)\n{\n\treturn (hdsp->control_register & HDSP_RPM_Bypass) ? 1 : 0;\n}\n\n\nstatic int snd_hdsp_get_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdsp_rpm_bypass(hdsp);\n\treturn 0;\n}\n\n\nstatic int hdsp_set_rpm_bypass(struct hdsp *hdsp, int on)\n{\n\tif (on)\n\t\thdsp->control_register |= HDSP_RPM_Bypass;\n\telse\n\t\thdsp->control_register &= ~HDSP_RPM_Bypass;\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\n\nstatic int snd_hdsp_put_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int)val != hdsp_rpm_bypass(hdsp);\n\thdsp_set_rpm_bypass(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\n\nstatic int snd_hdsp_info_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"On\", \"Off\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\n\n \nstatic int hdsp_rpm_disconnect(struct hdsp *hdsp)\n{\n\treturn (hdsp->control_register & HDSP_RPM_Disconnect) ? 1 : 0;\n}\n\n\nstatic int snd_hdsp_get_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdsp_rpm_disconnect(hdsp);\n\treturn 0;\n}\n\n\nstatic int hdsp_set_rpm_disconnect(struct hdsp *hdsp, int on)\n{\n\tif (on)\n\t\thdsp->control_register |= HDSP_RPM_Disconnect;\n\telse\n\t\thdsp->control_register &= ~HDSP_RPM_Disconnect;\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\treturn 0;\n}\n\n\nstatic int snd_hdsp_put_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdsp_use_is_exclusive(hdsp))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdsp->lock);\n\tchange = (int)val != hdsp_rpm_disconnect(hdsp);\n\thdsp_set_rpm_disconnect(hdsp, val);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn change;\n}\n\nstatic int snd_hdsp_info_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = {\"On\", \"Off\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic const struct snd_kcontrol_new snd_hdsp_rpm_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"RPM Bypass\",\n\t\t.get = snd_hdsp_get_rpm_bypass,\n\t\t.put = snd_hdsp_put_rpm_bypass,\n\t\t.info = snd_hdsp_info_rpm_bypass\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"RPM Disconnect\",\n\t\t.get = snd_hdsp_get_rpm_disconnect,\n\t\t.put = snd_hdsp_put_rpm_disconnect,\n\t\t.info = snd_hdsp_info_rpm_disconnect\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input 1/2\",\n\t\t.get = snd_hdsp_get_rpm_input12,\n\t\t.put = snd_hdsp_put_rpm_input12,\n\t\t.info = snd_hdsp_info_rpm_input\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Input 3/4\",\n\t\t.get = snd_hdsp_get_rpm_input34,\n\t\t.put = snd_hdsp_put_rpm_input34,\n\t\t.info = snd_hdsp_info_rpm_input\n\t},\n\tHDSP_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSP_MIXER(\"Mixer\", 0)\n};\n\nstatic const struct snd_kcontrol_new snd_hdsp_96xx_aeb =\n\tHDSP_TOGGLE_SETTING(\"Analog Extension Board\",\n\t\t\tHDSP_AnalogExtensionBoard);\nstatic struct snd_kcontrol_new snd_hdsp_adat_sync_check = HDSP_ADAT_SYNC_CHECK;\n\n\nstatic bool hdsp_loopback_get(struct hdsp *const hdsp, const u8 channel)\n{\n\treturn hdsp->io_loopback & (1 << channel);\n}\n\nstatic int hdsp_loopback_set(struct hdsp *const hdsp, const u8 channel, const bool enable)\n{\n\tif (hdsp_loopback_get(hdsp, channel) == enable)\n\t\treturn 0;\n\n\thdsp->io_loopback ^= (1 << channel);\n\n\thdsp_write(hdsp, HDSP_inputEnable + (4 * (hdsp->max_channels + channel)), enable);\n\n\treturn 1;\n}\n\nstatic int snd_hdsp_loopback_get(struct snd_kcontrol *const kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *const ucontrol)\n{\n\tstruct hdsp *const hdsp = snd_kcontrol_chip(kcontrol);\n\tconst u8 channel = snd_ctl_get_ioff(kcontrol, &ucontrol->id);\n\n\tif (channel >= hdsp->max_channels)\n\t\treturn -ENOENT;\n\n\tucontrol->value.integer.value[0] = hdsp_loopback_get(hdsp, channel);\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_loopback_put(struct snd_kcontrol *const kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *const ucontrol)\n{\n\tstruct hdsp *const hdsp = snd_kcontrol_chip(kcontrol);\n\tconst u8 channel = snd_ctl_get_ioff(kcontrol, &ucontrol->id);\n\tconst bool enable = ucontrol->value.integer.value[0] & 1;\n\n\tif (channel >= hdsp->max_channels)\n\t\treturn -ENOENT;\n\n\treturn hdsp_loopback_set(hdsp, channel, enable);\n}\n\nstatic struct snd_kcontrol_new snd_hdsp_loopback_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_HWDEP,\n\t.name = \"Output Loopback\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_ctl_boolean_mono_info,\n\t.get = snd_hdsp_loopback_get,\n\t.put = snd_hdsp_loopback_put\n};\n\nstatic int snd_hdsp_create_controls(struct snd_card *card, struct hdsp *hdsp)\n{\n\tunsigned int idx;\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\n\tif (hdsp->io_type == RPM) {\n\t\t \n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_rpm_controls); idx++) {\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_hdsp_rpm_controls[idx], hdsp));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_hdsp_controls[idx], hdsp);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (idx == 1)\t \n\t\t\thdsp->spdif_ctl = kctl;\n\t}\n\n\t \n\tsnd_hdsp_adat_sync_check.name = \"ADAT Lock Status\";\n\tsnd_hdsp_adat_sync_check.index = 1;\n\tkctl = snd_ctl_new1(&snd_hdsp_adat_sync_check, hdsp);\n\terr = snd_ctl_add(card, kctl);\n\tif (err < 0)\n\t\treturn err;\n\tif (hdsp->io_type == Digiface || hdsp->io_type == H9652) {\n\t\tfor (idx = 1; idx < 3; ++idx) {\n\t\t\tsnd_hdsp_adat_sync_check.index = idx+1;\n\t\t\tkctl = snd_ctl_new1(&snd_hdsp_adat_sync_check, hdsp);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (hdsp->io_type == H9632) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_9632_controls); idx++) {\n\t\t\tkctl = snd_ctl_new1(&snd_hdsp_9632_controls[idx], hdsp);\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (hdsp->io_type == H9632) {\n\t\tsnd_hdsp_loopback_control.count = hdsp->max_channels;\n\t\tkctl = snd_ctl_new1(&snd_hdsp_loopback_control, hdsp);\n\t\tif (kctl == NULL)\n\t\t\treturn -ENOMEM;\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (hdsp->io_type == H9632 || hdsp->io_type == H9652) {\n\t\tkctl = snd_ctl_new1(&snd_hdsp_96xx_aeb, hdsp);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void\nsnd_hdsp_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct hdsp *hdsp = entry->private_data;\n\tunsigned int status;\n\tunsigned int status2;\n\tchar *pref_sync_ref;\n\tchar *autosync_ref;\n\tchar *system_clock_mode;\n\tchar *clock_source;\n\tint x;\n\n\tstatus = hdsp_read(hdsp, HDSP_statusRegister);\n\tstatus2 = hdsp_read(hdsp, HDSP_status2Register);\n\n\tsnd_iprintf(buffer, \"%s (Card #%d)\\n\", hdsp->card_name,\n\t\t    hdsp->card->number + 1);\n\tsnd_iprintf(buffer, \"Buffers: capture %p playback %p\\n\",\n\t\t    hdsp->capture_buffer, hdsp->playback_buffer);\n\tsnd_iprintf(buffer, \"IRQ: %d Registers bus: 0x%lx VM: 0x%lx\\n\",\n\t\t    hdsp->irq, hdsp->port, (unsigned long)hdsp->iobase);\n\tsnd_iprintf(buffer, \"Control register: 0x%x\\n\", hdsp->control_register);\n\tsnd_iprintf(buffer, \"Control2 register: 0x%x\\n\",\n\t\t    hdsp->control2_register);\n\tsnd_iprintf(buffer, \"Status register: 0x%x\\n\", status);\n\tsnd_iprintf(buffer, \"Status2 register: 0x%x\\n\", status2);\n\n\tif (hdsp_check_for_iobox(hdsp)) {\n\t\tsnd_iprintf(buffer, \"No I/O box connected.\\n\"\n\t\t\t    \"Please connect one and upload firmware.\\n\");\n\t\treturn;\n\t}\n\n\tif (hdsp_check_for_firmware(hdsp, 0)) {\n\t\tif (hdsp->state & HDSP_FirmwareCached) {\n\t\t\tif (snd_hdsp_load_firmware_from_cache(hdsp) != 0) {\n\t\t\t\tsnd_iprintf(buffer, \"Firmware loading from \"\n\t\t\t\t\t    \"cache failed, \"\n\t\t\t\t\t    \"please upload manually.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = hdsp_request_fw_loader(hdsp);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t    \"No firmware loaded nor cached, \"\n\t\t\t\t\t    \"please upload firmware.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_iprintf(buffer, \"FIFO status: %d\\n\", hdsp_read(hdsp, HDSP_fifoStatus) & 0xff);\n\tsnd_iprintf(buffer, \"MIDI1 Output status: 0x%x\\n\", hdsp_read(hdsp, HDSP_midiStatusOut0));\n\tsnd_iprintf(buffer, \"MIDI1 Input status: 0x%x\\n\", hdsp_read(hdsp, HDSP_midiStatusIn0));\n\tsnd_iprintf(buffer, \"MIDI2 Output status: 0x%x\\n\", hdsp_read(hdsp, HDSP_midiStatusOut1));\n\tsnd_iprintf(buffer, \"MIDI2 Input status: 0x%x\\n\", hdsp_read(hdsp, HDSP_midiStatusIn1));\n\tsnd_iprintf(buffer, \"Use Midi Tasklet: %s\\n\", hdsp->use_midi_work ? \"on\" : \"off\");\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tx = 1 << (6 + hdsp_decode_latency(hdsp->control_register & HDSP_LatencyMask));\n\n\tsnd_iprintf(buffer, \"Buffer Size (Latency): %d samples (2 periods of %lu bytes)\\n\", x, (unsigned long) hdsp->period_bytes);\n\tsnd_iprintf(buffer, \"Hardware pointer (frames): %ld\\n\", hdsp_hw_pointer(hdsp));\n\tsnd_iprintf(buffer, \"Precise pointer: %s\\n\", hdsp->precise_ptr ? \"on\" : \"off\");\n\tsnd_iprintf(buffer, \"Line out: %s\\n\", (hdsp->control_register & HDSP_LineOut) ? \"on\" : \"off\");\n\n\tsnd_iprintf(buffer, \"Firmware version: %d\\n\", (status2&HDSP_version0)|(status2&HDSP_version1)<<1|(status2&HDSP_version2)<<2);\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tswitch (hdsp_clock_source(hdsp)) {\n\tcase HDSP_CLOCK_SOURCE_AUTOSYNC:\n\t\tclock_source = \"AutoSync\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_32KHZ:\n\t\tclock_source = \"Internal 32 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_44_1KHZ:\n\t\tclock_source = \"Internal 44.1 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_48KHZ:\n\t\tclock_source = \"Internal 48 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_64KHZ:\n\t\tclock_source = \"Internal 64 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_88_2KHZ:\n\t\tclock_source = \"Internal 88.2 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_96KHZ:\n\t\tclock_source = \"Internal 96 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_128KHZ:\n\t\tclock_source = \"Internal 128 kHz\";\n\t\tbreak;\n\tcase HDSP_CLOCK_SOURCE_INTERNAL_176_4KHZ:\n\t\tclock_source = \"Internal 176.4 kHz\";\n\t\tbreak;\n\t\tcase HDSP_CLOCK_SOURCE_INTERNAL_192KHZ:\n\t\tclock_source = \"Internal 192 kHz\";\n\t\tbreak;\n\tdefault:\n\t\tclock_source = \"Error\";\n\t}\n\tsnd_iprintf (buffer, \"Sample Clock Source: %s\\n\", clock_source);\n\n\tif (hdsp_system_clock_mode(hdsp))\n\t\tsystem_clock_mode = \"Slave\";\n\telse\n\t\tsystem_clock_mode = \"Master\";\n\n\tswitch (hdsp_pref_sync_ref (hdsp)) {\n\tcase HDSP_SYNC_FROM_WORD:\n\t\tpref_sync_ref = \"Word Clock\";\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT_SYNC:\n\t\tpref_sync_ref = \"ADAT Sync\";\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_SPDIF:\n\t\tpref_sync_ref = \"SPDIF\";\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT1:\n\t\tpref_sync_ref = \"ADAT1\";\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT2:\n\t\tpref_sync_ref = \"ADAT2\";\n\t\tbreak;\n\tcase HDSP_SYNC_FROM_ADAT3:\n\t\tpref_sync_ref = \"ADAT3\";\n\t\tbreak;\n\tdefault:\n\t\tpref_sync_ref = \"Word Clock\";\n\t\tbreak;\n\t}\n\tsnd_iprintf (buffer, \"Preferred Sync Reference: %s\\n\", pref_sync_ref);\n\n\tswitch (hdsp_autosync_ref (hdsp)) {\n\tcase HDSP_AUTOSYNC_FROM_WORD:\n\t\tautosync_ref = \"Word Clock\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_ADAT_SYNC:\n\t\tautosync_ref = \"ADAT Sync\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_SPDIF:\n\t\tautosync_ref = \"SPDIF\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_NONE:\n\t\tautosync_ref = \"None\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_ADAT1:\n\t\tautosync_ref = \"ADAT1\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_ADAT2:\n\t\tautosync_ref = \"ADAT2\";\n\t\tbreak;\n\tcase HDSP_AUTOSYNC_FROM_ADAT3:\n\t\tautosync_ref = \"ADAT3\";\n\t\tbreak;\n\tdefault:\n\t\tautosync_ref = \"---\";\n\t\tbreak;\n\t}\n\tsnd_iprintf (buffer, \"AutoSync Reference: %s\\n\", autosync_ref);\n\n\tsnd_iprintf (buffer, \"AutoSync Frequency: %d\\n\", hdsp_external_sample_rate(hdsp));\n\n\tsnd_iprintf (buffer, \"System Clock Mode: %s\\n\", system_clock_mode);\n\n\tsnd_iprintf (buffer, \"System Clock Frequency: %d\\n\", hdsp->system_sample_rate);\n\tsnd_iprintf (buffer, \"System Clock Locked: %s\\n\", hdsp->clock_source_locked ? \"Yes\" : \"No\");\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tif (hdsp->io_type != RPM) {\n\t\tswitch (hdsp_spdif_in(hdsp)) {\n\t\tcase HDSP_SPDIFIN_OPTICAL:\n\t\t\tsnd_iprintf(buffer, \"IEC958 input: Optical\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_SPDIFIN_COAXIAL:\n\t\t\tsnd_iprintf(buffer, \"IEC958 input: Coaxial\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_SPDIFIN_INTERNAL:\n\t\t\tsnd_iprintf(buffer, \"IEC958 input: Internal\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_SPDIFIN_AES:\n\t\t\tsnd_iprintf(buffer, \"IEC958 input: AES\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"IEC958 input: ???\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (RPM == hdsp->io_type) {\n\t\tif (hdsp->control_register & HDSP_RPM_Bypass)\n\t\t\tsnd_iprintf(buffer, \"RPM Bypass: disabled\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"RPM Bypass: enabled\\n\");\n\t\tif (hdsp->control_register & HDSP_RPM_Disconnect)\n\t\t\tsnd_iprintf(buffer, \"RPM disconnected\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"RPM connected\\n\");\n\n\t\tswitch (hdsp->control_register & HDSP_RPM_Inp12) {\n\t\tcase HDSP_RPM_Inp12_Phon_6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: Phono, 6dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp12_Phon_0dB:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: Phono, 0dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp12_Phon_n6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: Phono, -6dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp12_Line_0dB:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: Line, 0dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp12_Line_n6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: Line, -6dB\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"Input 1/2: ???\\n\");\n\t\t}\n\n\t\tswitch (hdsp->control_register & HDSP_RPM_Inp34) {\n\t\tcase HDSP_RPM_Inp34_Phon_6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: Phono, 6dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp34_Phon_0dB:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: Phono, 0dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp34_Phon_n6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: Phono, -6dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp34_Line_0dB:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: Line, 0dB\\n\");\n\t\t\tbreak;\n\t\tcase HDSP_RPM_Inp34_Line_n6dB:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: Line, -6dB\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"Input 3/4: ???\\n\");\n\t\t}\n\n\t} else {\n\t\tif (hdsp->control_register & HDSP_SPDIFOpticalOut)\n\t\t\tsnd_iprintf(buffer, \"IEC958 output: Coaxial & ADAT1\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"IEC958 output: Coaxial only\\n\");\n\n\t\tif (hdsp->control_register & HDSP_SPDIFProfessional)\n\t\t\tsnd_iprintf(buffer, \"IEC958 quality: Professional\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"IEC958 quality: Consumer\\n\");\n\n\t\tif (hdsp->control_register & HDSP_SPDIFEmphasis)\n\t\t\tsnd_iprintf(buffer, \"IEC958 emphasis: on\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"IEC958 emphasis: off\\n\");\n\n\t\tif (hdsp->control_register & HDSP_SPDIFNonAudio)\n\t\t\tsnd_iprintf(buffer, \"IEC958 NonAudio: on\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"IEC958 NonAudio: off\\n\");\n\t\tx = hdsp_spdif_sample_rate(hdsp);\n\t\tif (x != 0)\n\t\t\tsnd_iprintf(buffer, \"IEC958 sample rate: %d\\n\", x);\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"IEC958 sample rate: Error flag set\\n\");\n\t}\n\tsnd_iprintf(buffer, \"\\n\");\n\n\t \n\tx = status & HDSP_Sync0;\n\tif (status & HDSP_Lock0)\n\t\tsnd_iprintf(buffer, \"ADAT1: %s\\n\", x ? \"Sync\" : \"Lock\");\n\telse\n\t\tsnd_iprintf(buffer, \"ADAT1: No Lock\\n\");\n\n\tswitch (hdsp->io_type) {\n\tcase Digiface:\n\tcase H9652:\n\t\tx = status & HDSP_Sync1;\n\t\tif (status & HDSP_Lock1)\n\t\t\tsnd_iprintf(buffer, \"ADAT2: %s\\n\", x ? \"Sync\" : \"Lock\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"ADAT2: No Lock\\n\");\n\t\tx = status & HDSP_Sync2;\n\t\tif (status & HDSP_Lock2)\n\t\t\tsnd_iprintf(buffer, \"ADAT3: %s\\n\", x ? \"Sync\" : \"Lock\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"ADAT3: No Lock\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tx = status & HDSP_SPDIFSync;\n\tif (status & HDSP_SPDIFErrorFlag)\n\t\tsnd_iprintf (buffer, \"SPDIF: No Lock\\n\");\n\telse\n\t\tsnd_iprintf (buffer, \"SPDIF: %s\\n\", x ? \"Sync\" : \"Lock\");\n\n\tx = status2 & HDSP_wc_sync;\n\tif (status2 & HDSP_wc_lock)\n\t\tsnd_iprintf (buffer, \"Word Clock: %s\\n\", x ? \"Sync\" : \"Lock\");\n\telse\n\t\tsnd_iprintf (buffer, \"Word Clock: No Lock\\n\");\n\n\tx = status & HDSP_TimecodeSync;\n\tif (status & HDSP_TimecodeLock)\n\t\tsnd_iprintf(buffer, \"ADAT Sync: %s\\n\", x ? \"Sync\" : \"Lock\");\n\telse\n\t\tsnd_iprintf(buffer, \"ADAT Sync: No Lock\\n\");\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\t \n\tif (hdsp->io_type == H9632) {\n\t\tchar *tmp;\n\n\t\tswitch (hdsp_ad_gain(hdsp)) {\n\t\tcase 0:\n\t\t\ttmp = \"-10 dBV\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttmp = \"+4 dBu\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = \"Lo Gain\";\n\t\t\tbreak;\n\t\t}\n\t\tsnd_iprintf(buffer, \"AD Gain : %s\\n\", tmp);\n\n\t\tswitch (hdsp_da_gain(hdsp)) {\n\t\tcase 0:\n\t\t\ttmp = \"Hi Gain\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttmp = \"+4 dBu\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = \"-10 dBV\";\n\t\t\tbreak;\n\t\t}\n\t\tsnd_iprintf(buffer, \"DA Gain : %s\\n\", tmp);\n\n\t\tswitch (hdsp_phone_gain(hdsp)) {\n\t\tcase 0:\n\t\t\ttmp = \"0 dB\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttmp = \"-6 dB\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttmp = \"-12 dB\";\n\t\t\tbreak;\n\t\t}\n\t\tsnd_iprintf(buffer, \"Phones Gain : %s\\n\", tmp);\n\n\t\tsnd_iprintf(buffer, \"XLR Breakout Cable : %s\\n\",\n\t\t\thdsp_toggle_setting(hdsp, HDSP_XLRBreakoutCable) ?\n\t\t\t\"yes\" : \"no\");\n\n\t\tif (hdsp->control_register & HDSP_AnalogExtensionBoard)\n\t\t\tsnd_iprintf(buffer, \"AEB : on (ADAT1 internal)\\n\");\n\t\telse\n\t\t\tsnd_iprintf(buffer, \"AEB : off (ADAT1 external)\\n\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n\n}\n\nstatic void snd_hdsp_proc_init(struct hdsp *hdsp)\n{\n\tsnd_card_ro_proc_new(hdsp->card, \"hdsp\", hdsp, snd_hdsp_proc_read);\n}\n\nstatic int snd_hdsp_initialize_memory(struct hdsp *hdsp)\n{\n\tstruct snd_dma_buffer *capture_dma, *playback_dma;\n\n\tcapture_dma = snd_hammerfall_get_buffer(hdsp->pci, HDSP_DMA_AREA_BYTES);\n\tplayback_dma = snd_hammerfall_get_buffer(hdsp->pci, HDSP_DMA_AREA_BYTES);\n\tif (!capture_dma || !playback_dma) {\n\t\tdev_err(hdsp->card->dev,\n\t\t\t\"%s: no buffers available\\n\", hdsp->card_name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\thdsp->capture_dma_buf = *capture_dma;\n\thdsp->playback_dma_buf = *playback_dma;\n\n\t \n\thdsp->capture_dma_buf.addr = ALIGN(capture_dma->addr, 0x10000ul);\n\thdsp->playback_dma_buf.addr = ALIGN(playback_dma->addr, 0x10000ul);\n\n\t \n\thdsp_write(hdsp, HDSP_inputBufferAddress, hdsp->capture_dma_buf.addr);\n\thdsp_write(hdsp, HDSP_outputBufferAddress, hdsp->playback_dma_buf.addr);\n\n\thdsp->capture_dma_buf.area += hdsp->capture_dma_buf.addr - capture_dma->addr;\n\thdsp->playback_dma_buf.area += hdsp->playback_dma_buf.addr - playback_dma->addr;\n\thdsp->capture_buffer = hdsp->capture_dma_buf.area;\n\thdsp->playback_buffer = hdsp->playback_dma_buf.area;\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_set_defaults(struct hdsp *hdsp)\n{\n\tunsigned int i;\n\n\t \n\n\t \n\n\thdsp->control_register = HDSP_ClockModeMaster |\n\t\t                 HDSP_SPDIFInputCoaxial |\n\t\t                 hdsp_encode_latency(7) |\n\t\t                 HDSP_LineOut;\n\n\n\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\n#ifdef SNDRV_BIG_ENDIAN\n\thdsp->control2_register = HDSP_BIGENDIAN_MODE;\n#else\n\thdsp->control2_register = 0;\n#endif\n\tif (hdsp->io_type == H9652)\n\t        snd_hdsp_9652_enable_mixer (hdsp);\n\telse\n\t\thdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\n\n\thdsp_reset_hw_pointer(hdsp);\n\thdsp_compute_period_size(hdsp);\n\n\t \n\n\tfor (i = 0; i < HDSP_MATRIX_MIXER_SIZE; ++i)\n\t\thdsp->mixer_matrix[i] = MINUS_INFINITY_GAIN;\n\n\tfor (i = 0; i < ((hdsp->io_type == H9652 || hdsp->io_type == H9632) ? 1352 : HDSP_MATRIX_MIXER_SIZE); ++i) {\n\t\tif (hdsp_write_gain (hdsp, i, MINUS_INFINITY_GAIN))\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tif (hdsp->io_type == H9632) {\n\t\thdsp->control_register |= (HDSP_DAGainPlus4dBu | HDSP_ADGainPlus4dBu | HDSP_PhoneGain0dB);\n\t\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\t}\n\n\t \n\n\thdsp_set_rate(hdsp, 48000, 1);\n\n\treturn 0;\n}\n\nstatic void hdsp_midi_work(struct work_struct *work)\n{\n\tstruct hdsp *hdsp = container_of(work, struct hdsp, midi_work);\n\n\tif (hdsp->midi[0].pending)\n\t\tsnd_hdsp_midi_input_read (&hdsp->midi[0]);\n\tif (hdsp->midi[1].pending)\n\t\tsnd_hdsp_midi_input_read (&hdsp->midi[1]);\n}\n\nstatic irqreturn_t snd_hdsp_interrupt(int irq, void *dev_id)\n{\n\tstruct hdsp *hdsp = (struct hdsp *) dev_id;\n\tunsigned int status;\n\tint audio;\n\tint midi0;\n\tint midi1;\n\tunsigned int midi0status;\n\tunsigned int midi1status;\n\tint schedule = 0;\n\n\tstatus = hdsp_read(hdsp, HDSP_statusRegister);\n\n\taudio = status & HDSP_audioIRQPending;\n\tmidi0 = status & HDSP_midi0IRQPending;\n\tmidi1 = status & HDSP_midi1IRQPending;\n\n\tif (!audio && !midi0 && !midi1)\n\t\treturn IRQ_NONE;\n\n\thdsp_write(hdsp, HDSP_interruptConfirmation, 0);\n\n\tmidi0status = hdsp_read (hdsp, HDSP_midiStatusIn0) & 0xff;\n\tmidi1status = hdsp_read (hdsp, HDSP_midiStatusIn1) & 0xff;\n\n\tif (!(hdsp->state & HDSP_InitializationComplete))\n\t\treturn IRQ_HANDLED;\n\n\tif (audio) {\n\t\tif (hdsp->capture_substream)\n\t\t\tsnd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n\n\t\tif (hdsp->playback_substream)\n\t\t\tsnd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\n\t}\n\n\tif (midi0 && midi0status) {\n\t\tif (hdsp->use_midi_work) {\n\t\t\t \n\t\t\thdsp->control_register &= ~HDSP_Midi0InterruptEnable;\n\t\t\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\t\t\thdsp->midi[0].pending = 1;\n\t\t\tschedule = 1;\n\t\t} else {\n\t\t\tsnd_hdsp_midi_input_read (&hdsp->midi[0]);\n\t\t}\n\t}\n\tif (hdsp->io_type != Multiface && hdsp->io_type != RPM && hdsp->io_type != H9632 && midi1 && midi1status) {\n\t\tif (hdsp->use_midi_work) {\n\t\t\t \n\t\t\thdsp->control_register &= ~HDSP_Midi1InterruptEnable;\n\t\t\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\n\t\t\thdsp->midi[1].pending = 1;\n\t\t\tschedule = 1;\n\t\t} else {\n\t\t\tsnd_hdsp_midi_input_read (&hdsp->midi[1]);\n\t\t}\n\t}\n\tif (hdsp->use_midi_work && schedule)\n\t\tqueue_work(system_highpri_wq, &hdsp->midi_work);\n\treturn IRQ_HANDLED;\n}\n\nstatic snd_pcm_uframes_t snd_hdsp_hw_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\treturn hdsp_hw_pointer(hdsp);\n}\n\nstatic signed char *hdsp_channel_buffer_location(struct hdsp *hdsp,\n\t\t\t\t\t     int stream,\n\t\t\t\t\t     int channel)\n\n{\n\tint mapped_channel;\n\n        if (snd_BUG_ON(channel < 0 || channel >= hdsp->max_channels))\n\t\treturn NULL;\n\n\tmapped_channel = hdsp->channel_map[channel];\n\tif (mapped_channel < 0)\n\t\treturn NULL;\n\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn hdsp->capture_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);\n\telse\n\t\treturn hdsp->playback_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);\n}\n\nstatic int snd_hdsp_playback_copy(struct snd_pcm_substream *substream,\n\t\t\t\t  int channel, unsigned long pos,\n\t\t\t\t  struct iov_iter *src, unsigned long count)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tif (snd_BUG_ON(pos + count > HDSP_CHANNEL_BUFFER_BYTES))\n\t\treturn -EINVAL;\n\n\tchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tif (copy_from_iter(channel_buf + pos, count, src) != count)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_hdsp_capture_copy(struct snd_pcm_substream *substream,\n\t\t\t\t int channel, unsigned long pos,\n\t\t\t\t struct iov_iter *dst, unsigned long count)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tif (snd_BUG_ON(pos + count > HDSP_CHANNEL_BUFFER_BYTES))\n\t\treturn -EINVAL;\n\n\tchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tif (copy_to_iter(channel_buf + pos, count, dst) != count)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_hdsp_hw_silence(struct snd_pcm_substream *substream,\n\t\t\t       int channel, unsigned long pos,\n\t\t\t       unsigned long count)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tmemset(channel_buf + pos, 0, count);\n\treturn 0;\n}\n\nstatic int snd_hdsp_reset(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = hdsp->capture_substream;\n\telse\n\t\tother = hdsp->playback_substream;\n\tif (hdsp->running)\n\t\truntime->status->hw_ptr = hdsp_hw_pointer(hdsp);\n\telse\n\t\truntime->status->hw_ptr = 0;\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tstruct snd_pcm_runtime *oruntime = other->runtime;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\toruntime->status->hw_ptr = runtime->status->hw_ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tint err;\n\tpid_t this_pid;\n\tpid_t other_pid;\n\n\tif (hdsp_check_for_iobox (hdsp))\n\t\treturn -EIO;\n\n\tif (hdsp_check_for_firmware(hdsp, 1))\n\t\treturn -EIO;\n\n\tspin_lock_irq(&hdsp->lock);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\thdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);\n\t\thdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= hdsp->creg_spdif_stream);\n\t\tthis_pid = hdsp->playback_pid;\n\t\tother_pid = hdsp->capture_pid;\n\t} else {\n\t\tthis_pid = hdsp->capture_pid;\n\t\tother_pid = hdsp->playback_pid;\n\t}\n\n\tif ((other_pid > 0) && (this_pid != other_pid)) {\n\n\t\t \n\n\t\tif (params_rate(params) != hdsp->system_sample_rate) {\n\t\t\tspin_unlock_irq(&hdsp->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (params_period_size(params) != hdsp->period_bytes / 4) {\n\t\t\tspin_unlock_irq(&hdsp->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\n\t\tspin_unlock_irq(&hdsp->lock);\n \t\treturn 0;\n\n\t} else {\n\t\tspin_unlock_irq(&hdsp->lock);\n\t}\n\n\t \n\n\tspin_lock_irq(&hdsp->lock);\n\tif (! hdsp->clock_source_locked) {\n\t\terr = hdsp_set_rate(hdsp, params_rate(params), 0);\n\t\tif (err < 0) {\n\t\t\tspin_unlock_irq(&hdsp->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\t\treturn err;\n\t\t}\n\t}\n\tspin_unlock_irq(&hdsp->lock);\n\n\terr = hdsp_set_interrupt_interval(hdsp, params_period_size(params));\n\tif (err < 0) {\n\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_channel_info *info)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tunsigned int channel = info->channel;\n\n\tif (snd_BUG_ON(channel >= hdsp->max_channels))\n\t\treturn -EINVAL;\n\tchannel = array_index_nospec(channel, hdsp->max_channels);\n\n\tif (hdsp->channel_map[channel] < 0)\n\t\treturn -EINVAL;\n\n\tinfo->offset = hdsp->channel_map[channel] * HDSP_CHANNEL_BUFFER_BYTES;\n\tinfo->first = 0;\n\tinfo->step = 32;\n\treturn 0;\n}\n\nstatic int snd_hdsp_ioctl(struct snd_pcm_substream *substream,\n\t\t\t     unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_hdsp_reset(substream);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_hdsp_channel_info(substream, arg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nstatic int snd_hdsp_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\tint running;\n\n\tif (hdsp_check_for_iobox (hdsp))\n\t\treturn -EIO;\n\n\tif (hdsp_check_for_firmware(hdsp, 0))  \n\t\treturn -EIO;\n\n\tspin_lock(&hdsp->lock);\n\trunning = hdsp->running;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\trunning |= 1 << substream->stream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trunning &= ~(1 << substream->stream);\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tspin_unlock(&hdsp->lock);\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = hdsp->capture_substream;\n\telse\n\t\tother = hdsp->playback_substream;\n\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\t\t\trunning |= 1 << s->stream;\n\t\t\t\telse\n\t\t\t\t\trunning &= ~(1 << s->stream);\n\t\t\t\tgoto _ok;\n\t\t\t}\n\t\t}\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t\tif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&\n\t\t\t    substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t\thdsp_silence_playback(hdsp);\n\t\t} else {\n\t\t\tif (running &&\n\t\t\t    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\thdsp_silence_playback(hdsp);\n\t\t}\n\t} else {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t\thdsp_silence_playback(hdsp);\n\t}\n _ok:\n\tsnd_pcm_trigger_done(substream, substream);\n\tif (!hdsp->running && running)\n\t\thdsp_start_audio(hdsp);\n\telse if (hdsp->running && !running)\n\t\thdsp_stop_audio(hdsp);\n\thdsp->running = running;\n\tspin_unlock(&hdsp->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\n\tif (hdsp_check_for_iobox (hdsp))\n\t\treturn -EIO;\n\n\tif (hdsp_check_for_firmware(hdsp, 1))\n\t\treturn -EIO;\n\n\tspin_lock_irq(&hdsp->lock);\n\tif (!hdsp->running)\n\t\thdsp_reset_hw_pointer(hdsp);\n\tspin_unlock_irq(&hdsp->lock);\n\treturn result;\n}\n\nstatic const struct snd_pcm_hardware snd_hdsp_playback_subinfo =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_DOUBLE),\n#ifdef SNDRV_BIG_ENDIAN\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_BE,\n#else\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n#endif\n\t.rates =\t\t(SNDRV_PCM_RATE_32000 |\n\t\t\t\t SNDRV_PCM_RATE_44100 |\n\t\t\t\t SNDRV_PCM_RATE_48000 |\n\t\t\t\t SNDRV_PCM_RATE_64000 |\n\t\t\t\t SNDRV_PCM_RATE_88200 |\n\t\t\t\t SNDRV_PCM_RATE_96000),\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t6,\n\t.channels_max =\t\tHDSP_MAX_CHANNELS,\n\t.buffer_bytes_max =\tHDSP_CHANNEL_BUFFER_BYTES * HDSP_MAX_CHANNELS,\n\t.period_bytes_min =\t(64 * 4) * 10,\n\t.period_bytes_max =\t(8192 * 4) * HDSP_MAX_CHANNELS,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0\n};\n\nstatic const struct snd_pcm_hardware snd_hdsp_capture_subinfo =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START),\n#ifdef SNDRV_BIG_ENDIAN\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_BE,\n#else\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n#endif\n\t.rates =\t\t(SNDRV_PCM_RATE_32000 |\n\t\t\t\t SNDRV_PCM_RATE_44100 |\n\t\t\t\t SNDRV_PCM_RATE_48000 |\n\t\t\t\t SNDRV_PCM_RATE_64000 |\n\t\t\t\t SNDRV_PCM_RATE_88200 |\n\t\t\t\t SNDRV_PCM_RATE_96000),\n\t.rate_min =\t\t32000,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t5,\n\t.channels_max =\t\tHDSP_MAX_CHANNELS,\n\t.buffer_bytes_max =\tHDSP_CHANNEL_BUFFER_BYTES * HDSP_MAX_CHANNELS,\n\t.period_bytes_min =\t(64 * 4) * 10,\n\t.period_bytes_max =\t(8192 * 4) * HDSP_MAX_CHANNELS,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0\n};\n\nstatic const unsigned int hdsp_period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };\n\nstatic const struct snd_pcm_hw_constraint_list hdsp_hw_constraints_period_sizes = {\n\t.count = ARRAY_SIZE(hdsp_period_sizes),\n\t.list = hdsp_period_sizes,\n\t.mask = 0\n};\n\nstatic const unsigned int hdsp_9632_sample_rates[] = { 32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000 };\n\nstatic const struct snd_pcm_hw_constraint_list hdsp_hw_constraints_9632_sample_rates = {\n\t.count = ARRAY_SIZE(hdsp_9632_sample_rates),\n\t.list = hdsp_9632_sample_rates,\n\t.mask = 0\n};\n\nstatic int snd_hdsp_hw_rule_in_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tif (hdsp->io_type == H9632) {\n\t\tunsigned int list[3];\n\t\tlist[0] = hdsp->qs_in_channels;\n\t\tlist[1] = hdsp->ds_in_channels;\n\t\tlist[2] = hdsp->ss_in_channels;\n\t\treturn snd_interval_list(c, 3, list, 0);\n\t} else {\n\t\tunsigned int list[2];\n\t\tlist[0] = hdsp->ds_in_channels;\n\t\tlist[1] = hdsp->ss_in_channels;\n\t\treturn snd_interval_list(c, 2, list, 0);\n\t}\n}\n\nstatic int snd_hdsp_hw_rule_out_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tunsigned int list[3];\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tif (hdsp->io_type == H9632) {\n\t\tlist[0] = hdsp->qs_out_channels;\n\t\tlist[1] = hdsp->ds_out_channels;\n\t\tlist[2] = hdsp->ss_out_channels;\n\t\treturn snd_interval_list(c, 3, list, 0);\n\t} else {\n\t\tlist[0] = hdsp->ds_out_channels;\n\t\tlist[1] = hdsp->ss_out_channels;\n\t}\n\treturn snd_interval_list(c, 2, list, 0);\n}\n\nstatic int snd_hdsp_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (r->min > 96000 && hdsp->io_type == H9632) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->qs_in_channels,\n\t\t\t.max = hdsp->qs_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->min > 48000 && r->max <= 96000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->ds_in_channels,\n\t\t\t.max = hdsp->ds_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->max < 64000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->ss_in_channels,\n\t\t\t.max = hdsp->ss_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_hw_rule_out_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (r->min > 96000 && hdsp->io_type == H9632) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->qs_out_channels,\n\t\t\t.max = hdsp->qs_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->min > 48000 && r->max <= 96000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->ds_out_channels,\n\t\t\t.max = hdsp->ds_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->max < 64000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdsp->ss_out_channels,\n\t\t\t.max = hdsp->ss_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_hw_rule_rate_out_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (c->min >= hdsp->ss_out_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 32000,\n\t\t\t.max = 48000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdsp->qs_out_channels && hdsp->io_type == H9632) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 128000,\n\t\t\t.max = 192000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdsp->ds_out_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 64000,\n\t\t\t.max = 96000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_hw_rule_rate_in_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdsp *hdsp = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (c->min >= hdsp->ss_in_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 32000,\n\t\t\t.max = 48000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdsp->qs_in_channels && hdsp->io_type == H9632) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 128000,\n\t\t\t.max = 192000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdsp->ds_in_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 64000,\n\t\t\t.max = 96000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (hdsp_check_for_iobox (hdsp))\n\t\treturn -EIO;\n\n\tif (hdsp_check_for_firmware(hdsp, 1))\n\t\treturn -EIO;\n\n\tspin_lock_irq(&hdsp->lock);\n\n\tsnd_pcm_set_sync(substream);\n\n        runtime->hw = snd_hdsp_playback_subinfo;\n\tsnd_pcm_set_runtime_buffer(substream, &hdsp->playback_dma_buf);\n\n\thdsp->playback_pid = current->pid;\n\thdsp->playback_substream = substream;\n\n\tspin_unlock_irq(&hdsp->lock);\n\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hdsp_hw_constraints_period_sizes);\n\tif (hdsp->clock_source_locked) {\n\t\truntime->hw.rate_min = runtime->hw.rate_max = hdsp->system_sample_rate;\n\t} else if (hdsp->io_type == H9632) {\n\t\truntime->hw.rate_max = 192000;\n\t\truntime->hw.rates = SNDRV_PCM_RATE_KNOT;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hdsp_hw_constraints_9632_sample_rates);\n\t}\n\tif (hdsp->io_type == H9632) {\n\t\truntime->hw.channels_min = hdsp->qs_out_channels;\n\t\truntime->hw.channels_max = hdsp->ss_out_channels;\n\t}\n\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_hdsp_hw_rule_out_channels, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_hdsp_hw_rule_out_channels_rate, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_RATE, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t     snd_hdsp_hw_rule_rate_out_channels, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\n\tif (RPM != hdsp->io_type) {\n\t\thdsp->creg_spdif_stream = hdsp->creg_spdif;\n\t\thdsp->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\tSNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_playback_release(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&hdsp->lock);\n\n\thdsp->playback_pid = -1;\n\thdsp->playback_substream = NULL;\n\n\tspin_unlock_irq(&hdsp->lock);\n\n\tif (RPM != hdsp->io_type) {\n\t\thdsp->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\tsnd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\tSNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);\n\t}\n\treturn 0;\n}\n\n\nstatic int snd_hdsp_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (hdsp_check_for_iobox (hdsp))\n\t\treturn -EIO;\n\n\tif (hdsp_check_for_firmware(hdsp, 1))\n\t\treturn -EIO;\n\n\tspin_lock_irq(&hdsp->lock);\n\n\tsnd_pcm_set_sync(substream);\n\n\truntime->hw = snd_hdsp_capture_subinfo;\n\tsnd_pcm_set_runtime_buffer(substream, &hdsp->capture_dma_buf);\n\n\thdsp->capture_pid = current->pid;\n\thdsp->capture_substream = substream;\n\n\tspin_unlock_irq(&hdsp->lock);\n\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hdsp_hw_constraints_period_sizes);\n\tif (hdsp->io_type == H9632) {\n\t\truntime->hw.channels_min = hdsp->qs_in_channels;\n\t\truntime->hw.channels_max = hdsp->ss_in_channels;\n\t\truntime->hw.rate_max = 192000;\n\t\truntime->hw.rates = SNDRV_PCM_RATE_KNOT;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hdsp_hw_constraints_9632_sample_rates);\n\t}\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_hdsp_hw_rule_in_channels, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_hdsp_hw_rule_in_channels_rate, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_RATE, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t     snd_hdsp_hw_rule_rate_in_channels, hdsp,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\treturn 0;\n}\n\nstatic int snd_hdsp_capture_release(struct snd_pcm_substream *substream)\n{\n\tstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&hdsp->lock);\n\n\thdsp->capture_pid = -1;\n\thdsp->capture_substream = NULL;\n\n\tspin_unlock_irq(&hdsp->lock);\n\treturn 0;\n}\n\n \nstatic inline int copy_u32_le(void __user *dest, void __iomem *src)\n{\n\tu32 val = readl(src);\n\treturn copy_to_user(dest, &val, 4);\n}\n\nstatic inline int copy_u64_le(void __user *dest, void __iomem *src_low, void __iomem *src_high)\n{\n\tu32 rms_low, rms_high;\n\tu64 rms;\n\trms_low = readl(src_low);\n\trms_high = readl(src_high);\n\trms = ((u64)rms_high << 32) | rms_low;\n\treturn copy_to_user(dest, &rms, 8);\n}\n\nstatic inline int copy_u48_le(void __user *dest, void __iomem *src_low, void __iomem *src_high)\n{\n\tu32 rms_low, rms_high;\n\tu64 rms;\n\trms_low = readl(src_low) & 0xffffff00;\n\trms_high = readl(src_high) & 0xffffff00;\n\trms = ((u64)rms_high << 32) | rms_low;\n\treturn copy_to_user(dest, &rms, 8);\n}\n\nstatic int hdsp_9652_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\n{\n\tint doublespeed = 0;\n\tint i, j, channels, ofs;\n\n\tif (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DoubleSpeedStatus)\n\t\tdoublespeed = 1;\n\tchannels = doublespeed ? 14 : 26;\n\tfor (i = 0, j = 0; i < 26; ++i) {\n\t\tif (doublespeed && (i & 4))\n\t\t\tcontinue;\n\t\tofs = HDSP_9652_peakBase - j * 4;\n\t\tif (copy_u32_le(&peak_rms->input_peaks[i], hdsp->iobase + ofs))\n\t\t\treturn -EFAULT;\n\t\tofs -= channels * 4;\n\t\tif (copy_u32_le(&peak_rms->playback_peaks[i], hdsp->iobase + ofs))\n\t\t\treturn -EFAULT;\n\t\tofs -= channels * 4;\n\t\tif (copy_u32_le(&peak_rms->output_peaks[i], hdsp->iobase + ofs))\n\t\t\treturn -EFAULT;\n\t\tofs = HDSP_9652_rmsBase + j * 8;\n\t\tif (copy_u48_le(&peak_rms->input_rms[i], hdsp->iobase + ofs,\n\t\t\t\thdsp->iobase + ofs + 4))\n\t\t\treturn -EFAULT;\n\t\tofs += channels * 8;\n\t\tif (copy_u48_le(&peak_rms->playback_rms[i], hdsp->iobase + ofs,\n\t\t\t\thdsp->iobase + ofs + 4))\n\t\t\treturn -EFAULT;\n\t\tofs += channels * 8;\n\t\tif (copy_u48_le(&peak_rms->output_rms[i], hdsp->iobase + ofs,\n\t\t\t\thdsp->iobase + ofs + 4))\n\t\t\treturn -EFAULT;\n\t\tj++;\n\t}\n\treturn 0;\n}\n\nstatic int hdsp_9632_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\n{\n\tint i, j;\n\tstruct hdsp_9632_meters __iomem *m;\n\tint doublespeed = 0;\n\n\tif (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DoubleSpeedStatus)\n\t\tdoublespeed = 1;\n\tm = (struct hdsp_9632_meters __iomem *)(hdsp->iobase+HDSP_9632_metersBase);\n\tfor (i = 0, j = 0; i < 16; ++i, ++j) {\n\t\tif (copy_u32_le(&peak_rms->input_peaks[i], &m->input_peak[j]))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u32_le(&peak_rms->playback_peaks[i], &m->playback_peak[j]))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u32_le(&peak_rms->output_peaks[i], &m->output_peak[j]))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u64_le(&peak_rms->input_rms[i], &m->input_rms_low[j],\n\t\t\t\t&m->input_rms_high[j]))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u64_le(&peak_rms->playback_rms[i], &m->playback_rms_low[j],\n\t\t\t\t&m->playback_rms_high[j]))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u64_le(&peak_rms->output_rms[i], &m->output_rms_low[j],\n\t\t\t\t&m->output_rms_high[j]))\n\t\t\treturn -EFAULT;\n\t\tif (doublespeed && i == 3) i += 4;\n\t}\n\treturn 0;\n}\n\nstatic int hdsp_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\n{\n\tint i;\n\n\tfor (i = 0; i < 26; i++) {\n\t\tif (copy_u32_le(&peak_rms->playback_peaks[i],\n\t\t\t\thdsp->iobase + HDSP_playbackPeakLevel + i * 4))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u32_le(&peak_rms->input_peaks[i],\n\t\t\t\thdsp->iobase + HDSP_inputPeakLevel + i * 4))\n\t\t\treturn -EFAULT;\n\t}\n\tfor (i = 0; i < 28; i++) {\n\t\tif (copy_u32_le(&peak_rms->output_peaks[i],\n\t\t\t\thdsp->iobase + HDSP_outputPeakLevel + i * 4))\n\t\t\treturn -EFAULT;\n\t}\n\tfor (i = 0; i < 26; ++i) {\n\t\tif (copy_u64_le(&peak_rms->playback_rms[i],\n\t\t\t\thdsp->iobase + HDSP_playbackRmsLevel + i * 8 + 4,\n\t\t\t\thdsp->iobase + HDSP_playbackRmsLevel + i * 8))\n\t\t\treturn -EFAULT;\n\t\tif (copy_u64_le(&peak_rms->input_rms[i],\n\t\t\t\thdsp->iobase + HDSP_inputRmsLevel + i * 8 + 4,\n\t\t\t\thdsp->iobase + HDSP_inputRmsLevel + i * 8))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_hwdep_ioctl(struct snd_hwdep *hw, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hdsp *hdsp = hw->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_HDSP_IOCTL_GET_PEAK_RMS: {\n\t\tstruct hdsp_peak_rms __user *peak_rms = (struct hdsp_peak_rms __user *)arg;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_FirmwareLoaded)) {\n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\"firmware needs to be uploaded to the card.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (hdsp->io_type) {\n\t\tcase H9652:\n\t\t\treturn hdsp_9652_get_peak(hdsp, peak_rms);\n\t\tcase H9632:\n\t\t\treturn hdsp_9632_get_peak(hdsp, peak_rms);\n\t\tdefault:\n\t\t\treturn hdsp_get_peak(hdsp, peak_rms);\n\t\t}\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_CONFIG_INFO: {\n\t\tstruct hdsp_config_info info;\n\t\tunsigned long flags;\n\t\tint i;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tspin_lock_irqsave(&hdsp->lock, flags);\n\t\tinfo.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);\n\t\tinfo.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);\n\t\tif (hdsp->io_type != H9632)\n\t\t    info.adatsync_sync_check = (unsigned char)hdsp_adatsync_sync_check(hdsp);\n\t\tinfo.spdif_sync_check = (unsigned char)hdsp_spdif_sync_check(hdsp);\n\t\tfor (i = 0; i < ((hdsp->io_type != Multiface && hdsp->io_type != RPM && hdsp->io_type != H9632) ? 3 : 1); ++i)\n\t\t\tinfo.adat_sync_check[i] = (unsigned char)hdsp_adat_sync_check(hdsp, i);\n\t\tinfo.spdif_in = (unsigned char)hdsp_spdif_in(hdsp);\n\t\tinfo.spdif_out = (unsigned char)hdsp_toggle_setting(hdsp,\n\t\t\t\tHDSP_SPDIFOpticalOut);\n\t\tinfo.spdif_professional = (unsigned char)\n\t\t\thdsp_toggle_setting(hdsp, HDSP_SPDIFProfessional);\n\t\tinfo.spdif_emphasis = (unsigned char)\n\t\t\thdsp_toggle_setting(hdsp, HDSP_SPDIFEmphasis);\n\t\tinfo.spdif_nonaudio = (unsigned char)\n\t\t\thdsp_toggle_setting(hdsp, HDSP_SPDIFNonAudio);\n\t\tinfo.spdif_sample_rate = hdsp_spdif_sample_rate(hdsp);\n\t\tinfo.system_sample_rate = hdsp->system_sample_rate;\n\t\tinfo.autosync_sample_rate = hdsp_external_sample_rate(hdsp);\n\t\tinfo.system_clock_mode = (unsigned char)hdsp_system_clock_mode(hdsp);\n\t\tinfo.clock_source = (unsigned char)hdsp_clock_source(hdsp);\n\t\tinfo.autosync_ref = (unsigned char)hdsp_autosync_ref(hdsp);\n\t\tinfo.line_out = (unsigned char)\n\t\t\thdsp_toggle_setting(hdsp, HDSP_LineOut);\n\t\tif (hdsp->io_type == H9632) {\n\t\t\tinfo.da_gain = (unsigned char)hdsp_da_gain(hdsp);\n\t\t\tinfo.ad_gain = (unsigned char)hdsp_ad_gain(hdsp);\n\t\t\tinfo.phone_gain = (unsigned char)hdsp_phone_gain(hdsp);\n\t\t\tinfo.xlr_breakout_cable =\n\t\t\t\t(unsigned char)hdsp_toggle_setting(hdsp,\n\t\t\t\t\tHDSP_XLRBreakoutCable);\n\n\t\t} else if (hdsp->io_type == RPM) {\n\t\t\tinfo.da_gain = (unsigned char) hdsp_rpm_input12(hdsp);\n\t\t\tinfo.ad_gain = (unsigned char) hdsp_rpm_input34(hdsp);\n\t\t}\n\t\tif (hdsp->io_type == H9632 || hdsp->io_type == H9652)\n\t\t\tinfo.analog_extension_board =\n\t\t\t\t(unsigned char)hdsp_toggle_setting(hdsp,\n\t\t\t\t\t    HDSP_AnalogExtensionBoard);\n\t\tspin_unlock_irqrestore(&hdsp->lock, flags);\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_9632_AEB: {\n\t\tstruct hdsp_9632_aeb h9632_aeb;\n\n\t\tif (hdsp->io_type != H9632) return -EINVAL;\n\t\th9632_aeb.aebi = hdsp->ss_in_channels - H9632_SS_CHANNELS;\n\t\th9632_aeb.aebo = hdsp->ss_out_channels - H9632_SS_CHANNELS;\n\t\tif (copy_to_user(argp, &h9632_aeb, sizeof(h9632_aeb)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_VERSION: {\n\t\tstruct hdsp_version hdsp_version;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\tif (hdsp->io_type == Undefined) {\n\t\t\terr = hdsp_get_iobox_version(hdsp);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tmemset(&hdsp_version, 0, sizeof(hdsp_version));\n\t\thdsp_version.io_type = hdsp->io_type;\n\t\thdsp_version.firmware_rev = hdsp->firmware_rev;\n\t\tif (copy_to_user(argp, &hdsp_version, sizeof(hdsp_version)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {\n\t\tstruct hdsp_firmware firmware;\n\t\tu32 __user *firmware_data;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\t \n\t\tif (hdsp->io_type == Undefined) return -EINVAL;\n\n\t\tif (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))\n\t\t\treturn -EBUSY;\n\n\t\tdev_info(hdsp->card->dev,\n\t\t\t \"initializing firmware upload\\n\");\n\t\tif (copy_from_user(&firmware, argp, sizeof(firmware)))\n\t\t\treturn -EFAULT;\n\t\tfirmware_data = (u32 __user *)firmware.firmware_data;\n\n\t\tif (hdsp_check_for_iobox (hdsp))\n\t\t\treturn -EIO;\n\n\t\tif (!hdsp->fw_uploaded) {\n\t\t\thdsp->fw_uploaded = vmalloc(HDSP_FIRMWARE_SIZE);\n\t\t\tif (!hdsp->fw_uploaded)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(hdsp->fw_uploaded, firmware_data,\n\t\t\t\t   HDSP_FIRMWARE_SIZE)) {\n\t\t\tvfree(hdsp->fw_uploaded);\n\t\t\thdsp->fw_uploaded = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\thdsp->state |= HDSP_FirmwareCached;\n\n\t\terr = snd_hdsp_load_firmware_from_cache(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_InitializationComplete)) {\n\t\t\terr = snd_hdsp_enable_io(hdsp);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tsnd_hdsp_initialize_channels(hdsp);\n\t\t\tsnd_hdsp_initialize_midi_flush(hdsp);\n\n\t\t\terr = snd_hdsp_create_alsa_devices(hdsp->card, hdsp);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\t\"error creating alsa devices\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_MIXER: {\n\t\tstruct hdsp_mixer __user *mixer = (struct hdsp_mixer __user *)argp;\n\t\tif (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_hdsp_playback_ops = {\n\t.open =\t\tsnd_hdsp_playback_open,\n\t.close =\tsnd_hdsp_playback_release,\n\t.ioctl =\tsnd_hdsp_ioctl,\n\t.hw_params =\tsnd_hdsp_hw_params,\n\t.prepare =\tsnd_hdsp_prepare,\n\t.trigger =\tsnd_hdsp_trigger,\n\t.pointer =\tsnd_hdsp_hw_pointer,\n\t.copy =\t\tsnd_hdsp_playback_copy,\n\t.fill_silence =\tsnd_hdsp_hw_silence,\n};\n\nstatic const struct snd_pcm_ops snd_hdsp_capture_ops = {\n\t.open =\t\tsnd_hdsp_capture_open,\n\t.close =\tsnd_hdsp_capture_release,\n\t.ioctl =\tsnd_hdsp_ioctl,\n\t.hw_params =\tsnd_hdsp_hw_params,\n\t.prepare =\tsnd_hdsp_prepare,\n\t.trigger =\tsnd_hdsp_trigger,\n\t.pointer =\tsnd_hdsp_hw_pointer,\n\t.copy =\t\tsnd_hdsp_capture_copy,\n};\n\nstatic int snd_hdsp_create_hwdep(struct snd_card *card, struct hdsp *hdsp)\n{\n\tstruct snd_hwdep *hw;\n\tint err;\n\n\terr = snd_hwdep_new(card, \"HDSP hwdep\", 0, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thdsp->hwdep = hw;\n\thw->private_data = hdsp;\n\tstrcpy(hw->name, \"HDSP hwdep interface\");\n\n\thw->ops.ioctl = snd_hdsp_hwdep_ioctl;\n\thw->ops.ioctl_compat = snd_hdsp_hwdep_ioctl;\n\n\treturn 0;\n}\n\nstatic int snd_hdsp_create_pcm(struct snd_card *card, struct hdsp *hdsp)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, hdsp->card_name, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\thdsp->pcm = pcm;\n\tpcm->private_data = hdsp;\n\tstrcpy(pcm->name, hdsp->card_name);\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_hdsp_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_hdsp_capture_ops);\n\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\n\treturn 0;\n}\n\nstatic void snd_hdsp_9652_enable_mixer (struct hdsp *hdsp)\n{\n        hdsp->control2_register |= HDSP_9652_ENABLE_MIXER;\n\thdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\n}\n\nstatic int snd_hdsp_enable_io (struct hdsp *hdsp)\n{\n\tint i;\n\n\tif (hdsp_fifo_wait (hdsp, 0, 100)) {\n\t\tdev_err(hdsp->card->dev,\n\t\t\t\"enable_io fifo_wait failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < hdsp->max_channels; ++i) {\n\t\thdsp_write (hdsp, HDSP_inputEnable + (4 * i), 1);\n\t\thdsp_write (hdsp, HDSP_outputEnable + (4 * i), 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_hdsp_initialize_channels(struct hdsp *hdsp)\n{\n\tint status, aebi_channels, aebo_channels, i;\n\n\tswitch (hdsp->io_type) {\n\tcase Digiface:\n\t\thdsp->card_name = \"RME Hammerfall DSP + Digiface\";\n\t\thdsp->ss_in_channels = hdsp->ss_out_channels = DIGIFACE_SS_CHANNELS;\n\t\thdsp->ds_in_channels = hdsp->ds_out_channels = DIGIFACE_DS_CHANNELS;\n\t\tbreak;\n\n\tcase H9652:\n\t\thdsp->card_name = \"RME Hammerfall HDSP 9652\";\n\t\thdsp->ss_in_channels = hdsp->ss_out_channels = H9652_SS_CHANNELS;\n\t\thdsp->ds_in_channels = hdsp->ds_out_channels = H9652_DS_CHANNELS;\n\t\tbreak;\n\n\tcase H9632:\n\t\tstatus = hdsp_read(hdsp, HDSP_statusRegister);\n\t\t \n\t\taebi_channels = (status & HDSP_AEBI) ? 0 : 4;\n\t\taebo_channels = (status & HDSP_AEBO) ? 0 : 4;\n\t\thdsp->card_name = \"RME Hammerfall HDSP 9632\";\n\t\thdsp->ss_in_channels = H9632_SS_CHANNELS+aebi_channels;\n\t\thdsp->ds_in_channels = H9632_DS_CHANNELS+aebi_channels;\n\t\thdsp->qs_in_channels = H9632_QS_CHANNELS+aebi_channels;\n\t\thdsp->ss_out_channels = H9632_SS_CHANNELS+aebo_channels;\n\t\thdsp->ds_out_channels = H9632_DS_CHANNELS+aebo_channels;\n\t\thdsp->qs_out_channels = H9632_QS_CHANNELS+aebo_channels;\n\t\t \n\t\thdsp->io_loopback = 0xffffffff;\n\t\tfor (i = 0; i < hdsp->max_channels; ++i)\n\t\t\thdsp_loopback_set(hdsp, i, false);\n\t\tbreak;\n\n\tcase Multiface:\n\t\thdsp->card_name = \"RME Hammerfall DSP + Multiface\";\n\t\thdsp->ss_in_channels = hdsp->ss_out_channels = MULTIFACE_SS_CHANNELS;\n\t\thdsp->ds_in_channels = hdsp->ds_out_channels = MULTIFACE_DS_CHANNELS;\n\t\tbreak;\n\n\tcase RPM:\n\t\thdsp->card_name = \"RME Hammerfall DSP + RPM\";\n\t\thdsp->ss_in_channels = RPM_CHANNELS-1;\n\t\thdsp->ss_out_channels = RPM_CHANNELS;\n\t\thdsp->ds_in_channels = RPM_CHANNELS-1;\n\t\thdsp->ds_out_channels = RPM_CHANNELS;\n\t\tbreak;\n\n\tdefault:\n \t\t \n\t\tbreak;\n\t}\n}\n\nstatic void snd_hdsp_initialize_midi_flush (struct hdsp *hdsp)\n{\n\tsnd_hdsp_flush_midi_input (hdsp, 0);\n\tsnd_hdsp_flush_midi_input (hdsp, 1);\n}\n\nstatic int snd_hdsp_create_alsa_devices(struct snd_card *card, struct hdsp *hdsp)\n{\n\tint err;\n\n\terr = snd_hdsp_create_pcm(card, hdsp);\n\tif (err < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"Error creating pcm interface\\n\");\n\t\treturn err;\n\t}\n\n\n\terr = snd_hdsp_create_midi(card, hdsp, 0);\n\tif (err < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"Error creating first midi interface\\n\");\n\t\treturn err;\n\t}\n\n\tif (hdsp->io_type == Digiface || hdsp->io_type == H9652) {\n\t\terr = snd_hdsp_create_midi(card, hdsp, 1);\n\t\tif (err < 0) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"Error creating second midi interface\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = snd_hdsp_create_controls(card, hdsp);\n\tif (err < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"Error creating ctl interface\\n\");\n\t\treturn err;\n\t}\n\n\tsnd_hdsp_proc_init(hdsp);\n\n\thdsp->system_sample_rate = -1;\n\thdsp->playback_pid = -1;\n\thdsp->capture_pid = -1;\n\thdsp->capture_substream = NULL;\n\thdsp->playback_substream = NULL;\n\n\terr = snd_hdsp_set_defaults(hdsp);\n\tif (err < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"Error setting default values\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(hdsp->state & HDSP_InitializationComplete)) {\n\t\tstrcpy(card->shortname, \"Hammerfall DSP\");\n\t\tsprintf(card->longname, \"%s at 0x%lx, irq %d\", hdsp->card_name,\n\t\t\thdsp->port, hdsp->irq);\n\n\t\terr = snd_card_register(card);\n\t\tif (err < 0) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"error registering card\\n\");\n\t\t\treturn err;\n\t\t}\n\t\thdsp->state |= HDSP_InitializationComplete;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hdsp_request_fw_loader(struct hdsp *hdsp)\n{\n\tconst char *fwfile;\n\tconst struct firmware *fw;\n\tint err;\n\n\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\treturn 0;\n\tif (hdsp->io_type == Undefined) {\n\t\terr = hdsp_get_iobox_version(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\n\t\t\treturn 0;\n\t}\n\n\t \n\tswitch (hdsp->io_type) {\n\tcase RPM:\n\t\tfwfile = \"rpm_firmware.bin\";\n\t\tbreak;\n\tcase Multiface:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\tfwfile = \"multiface_firmware.bin\";\n\t\telse\n\t\t\tfwfile = \"multiface_firmware_rev11.bin\";\n\t\tbreak;\n\tcase Digiface:\n\t\tif (hdsp->firmware_rev == 0xa)\n\t\t\tfwfile = \"digiface_firmware.bin\";\n\t\telse\n\t\t\tfwfile = \"digiface_firmware_rev11.bin\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hdsp->card->dev,\n\t\t\t\"invalid io_type %d\\n\", hdsp->io_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (request_firmware(&fw, fwfile, &hdsp->pci->dev)) {\n\t\tdev_err(hdsp->card->dev,\n\t\t\t\"cannot load firmware %s\\n\", fwfile);\n\t\treturn -ENOENT;\n\t}\n\tif (fw->size < HDSP_FIRMWARE_SIZE) {\n\t\tdev_err(hdsp->card->dev,\n\t\t\t\"too short firmware size %d (expected %d)\\n\",\n\t\t\t   (int)fw->size, HDSP_FIRMWARE_SIZE);\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\n\thdsp->firmware = fw;\n\n\thdsp->state |= HDSP_FirmwareCached;\n\n\terr = snd_hdsp_load_firmware_from_cache(hdsp);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(hdsp->state & HDSP_InitializationComplete)) {\n\t\terr = snd_hdsp_enable_io(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_hdsp_create_hwdep(hdsp->card, hdsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\"error creating hwdep device\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tsnd_hdsp_initialize_channels(hdsp);\n\t\tsnd_hdsp_initialize_midi_flush(hdsp);\n\t\terr = snd_hdsp_create_alsa_devices(hdsp->card, hdsp);\n\t\tif (err < 0) {\n\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\"error creating alsa devices\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdsp_create(struct snd_card *card,\n\t\t\t   struct hdsp *hdsp)\n{\n\tstruct pci_dev *pci = hdsp->pci;\n\tint err;\n\tint is_9652 = 0;\n\tint is_9632 = 0;\n\n\thdsp->irq = -1;\n\thdsp->state = 0;\n\thdsp->midi[0].rmidi = NULL;\n\thdsp->midi[1].rmidi = NULL;\n\thdsp->midi[0].input = NULL;\n\thdsp->midi[1].input = NULL;\n\thdsp->midi[0].output = NULL;\n\thdsp->midi[1].output = NULL;\n\thdsp->midi[0].pending = 0;\n\thdsp->midi[1].pending = 0;\n\tspin_lock_init(&hdsp->midi[0].lock);\n\tspin_lock_init(&hdsp->midi[1].lock);\n\thdsp->iobase = NULL;\n\thdsp->control_register = 0;\n\thdsp->control2_register = 0;\n\thdsp->io_type = Undefined;\n\thdsp->max_channels = 26;\n\n\thdsp->card = card;\n\n\tspin_lock_init(&hdsp->lock);\n\n\tINIT_WORK(&hdsp->midi_work, hdsp_midi_work);\n\n\tpci_read_config_word(hdsp->pci, PCI_CLASS_REVISION, &hdsp->firmware_rev);\n\thdsp->firmware_rev &= 0xff;\n\n\t \n\tpci_write_config_byte(hdsp->pci, PCI_LATENCY_TIMER, 0xFF);\n\n\tstrcpy(card->driver, \"H-DSP\");\n\tstrcpy(card->mixername, \"Xilinx FPGA\");\n\n\tif (hdsp->firmware_rev < 0xa)\n\t\treturn -ENODEV;\n\telse if (hdsp->firmware_rev < 0x64)\n\t\thdsp->card_name = \"RME Hammerfall DSP\";\n\telse if (hdsp->firmware_rev < 0x96) {\n\t\thdsp->card_name = \"RME HDSP 9652\";\n\t\tis_9652 = 1;\n\t} else {\n\t\thdsp->card_name = \"RME HDSP 9632\";\n\t\thdsp->max_channels = 16;\n\t\tis_9632 = 1;\n\t}\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_master(hdsp->pci);\n\n\terr = pci_request_regions(pci, \"hdsp\");\n\tif (err < 0)\n\t\treturn err;\n\thdsp->port = pci_resource_start(pci, 0);\n\thdsp->iobase = devm_ioremap(&pci->dev, hdsp->port, HDSP_IO_EXTENT);\n\tif (!hdsp->iobase) {\n\t\tdev_err(hdsp->card->dev, \"unable to remap region 0x%lx-0x%lx\\n\",\n\t\t\thdsp->port, hdsp->port + HDSP_IO_EXTENT - 1);\n\t\treturn -EBUSY;\n\t}\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_hdsp_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, hdsp)) {\n\t\tdev_err(hdsp->card->dev, \"unable to use IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\n\thdsp->irq = pci->irq;\n\tcard->sync_irq = hdsp->irq;\n\thdsp->precise_ptr = 0;\n\thdsp->use_midi_work = 1;\n\thdsp->dds_value = 0;\n\n\terr = snd_hdsp_initialize_memory(hdsp);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!is_9652 && !is_9632) {\n\t\t \n\t\terr = hdsp_wait_for_iobox(hdsp, 1000, 10);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\n\t\t\terr = hdsp_request_fw_loader(hdsp);\n\t\t\tif (err < 0)\n\t\t\t\t \n\t\t\t\tdev_err(hdsp->card->dev,\n\t\t\t\t\t\"couldn't get firmware from userspace. try using hdsploader\\n\");\n\t\t\telse\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t \"card initialization pending : waiting for firmware\\n\");\n\t\t\terr = snd_hdsp_create_hwdep(card, hdsp);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tdev_info(hdsp->card->dev,\n\t\t\t\t \"Firmware already present, initializing card.\\n\");\n\t\t\tif (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version2)\n\t\t\t\thdsp->io_type = RPM;\n\t\t\telse if (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version1)\n\t\t\t\thdsp->io_type = Multiface;\n\t\t\telse\n\t\t\t\thdsp->io_type = Digiface;\n\t\t}\n\t}\n\n\terr = snd_hdsp_enable_io(hdsp);\n\tif (err)\n\t\treturn err;\n\n\tif (is_9652)\n\t        hdsp->io_type = H9652;\n\n\tif (is_9632)\n\t\thdsp->io_type = H9632;\n\n\terr = snd_hdsp_create_hwdep(card, hdsp);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_hdsp_initialize_channels(hdsp);\n\tsnd_hdsp_initialize_midi_flush(hdsp);\n\n\thdsp->state |= HDSP_FirmwareLoaded;\n\n\terr = snd_hdsp_create_alsa_devices(card, hdsp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void snd_hdsp_card_free(struct snd_card *card)\n{\n\tstruct hdsp *hdsp = card->private_data;\n\n\tif (hdsp->port) {\n\t\t \n\t\tcancel_work_sync(&hdsp->midi_work);\n\t\thdsp->control_register &= ~(HDSP_Start|HDSP_AudioInterruptEnable|HDSP_Midi0InterruptEnable|HDSP_Midi1InterruptEnable);\n\t\thdsp_write (hdsp, HDSP_controlRegister, hdsp->control_register);\n\t}\n\n\trelease_firmware(hdsp->firmware);\n\tvfree(hdsp->fw_uploaded);\n}\n\nstatic int snd_hdsp_probe(struct pci_dev *pci,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct hdsp *hdsp;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct hdsp), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\thdsp = card->private_data;\n\tcard->private_free = snd_hdsp_card_free;\n\thdsp->dev = dev;\n\thdsp->pci = pci;\n\terr = snd_hdsp_create(card, hdsp);\n\tif (err)\n\t\tgoto error;\n\n\tstrcpy(card->shortname, \"Hammerfall DSP\");\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\", hdsp->card_name,\n\t\thdsp->port, hdsp->irq);\n\terr = snd_card_register(card);\n\tif (err)\n\t\tgoto error;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver hdsp_driver = {\n\t.name =     KBUILD_MODNAME,\n\t.id_table = snd_hdsp_ids,\n\t.probe =    snd_hdsp_probe,\n};\n\nmodule_pci_driver(hdsp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}