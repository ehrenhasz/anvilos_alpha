{
  "module_name": "rme9652.c",
  "hash_id": "5f6ef5d18fe3a181df600ae1a9745c8d3f08b90850e78b204f9db4a2df042295",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/rme9652/rme9652.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/nospec.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/asoundef.h>\n#include <sound/initval.h>\n\n#include <asm/current.h>\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \nstatic bool precise_ptr[SNDRV_CARDS];\t\t\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for RME Digi9652 (Hammerfall) soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for RME Digi9652 (Hammerfall) soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable/disable specific RME96{52,36} soundcards.\");\nmodule_param_array(precise_ptr, bool, NULL, 0444);\nMODULE_PARM_DESC(precise_ptr, \"Enable precise pointer (doesn't work reliably).\");\nMODULE_AUTHOR(\"Paul Davis <pbd@op.net>, Winfried Ritsch\");\nMODULE_DESCRIPTION(\"RME Digi9652/Digi9636\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define RME9652_NCHANNELS       26\n#define RME9636_NCHANNELS       18\n\n \n\n#define RME9652_SYNC_FROM_SPDIF 0\n#define RME9652_SYNC_FROM_ADAT1 1\n#define RME9652_SYNC_FROM_ADAT2 2\n#define RME9652_SYNC_FROM_ADAT3 3\n\n \n\n#define RME9652_SPDIFIN_OPTICAL 0\t \n#define RME9652_SPDIFIN_COAXIAL 1\t \n#define RME9652_SPDIFIN_INTERN  2\t \n\n \n\n#define RME9652_IRQ\t   (1<<0)\t \n#define RME9652_lock_2\t   (1<<1)\t \n#define RME9652_lock_1\t   (1<<2)\t \n#define RME9652_lock_0\t   (1<<3)\t \n#define RME9652_fs48\t   (1<<4)\t \n#define RME9652_wsel_rd\t   (1<<5)\t \n                                         \n#define RME9652_sync_2\t   (1<<16)\t \n#define RME9652_sync_1\t   (1<<17)\t \n#define RME9652_sync_0\t   (1<<18)\t \n#define RME9652_DS_rd\t   (1<<19)\t \n#define RME9652_tc_busy\t   (1<<20)\t \n#define RME9652_tc_out\t   (1<<21)\t \n#define RME9652_F_0\t   (1<<22)\t \n#define RME9652_F_1\t   (1<<23)\t \n#define RME9652_F_2\t   (1<<24)\t \n#define RME9652_ERF\t   (1<<25)\t \n#define RME9652_buffer_id  (1<<26)\t \n#define RME9652_tc_valid   (1<<27)\t \n#define RME9652_SPDIF_READ (1<<28)       \n\n#define RME9652_sync\t  (RME9652_sync_0|RME9652_sync_1|RME9652_sync_2)\n#define RME9652_lock\t  (RME9652_lock_0|RME9652_lock_1|RME9652_lock_2)\n#define RME9652_F\t  (RME9652_F_0|RME9652_F_1|RME9652_F_2)\n#define rme9652_decode_spdif_rate(x) ((x)>>22)\n\n \n\n#define RME9652_buf_pos\t  0x000FFC0\n\n  \n\n#define RME9652_REV15_buf_pos(x) ((((x)&0xE0000000)>>26)|((x)&RME9652_buf_pos))\n\n \n\n#define RME9652_IO_EXTENT     1024\n\n#define RME9652_init_buffer       0\n#define RME9652_play_buffer       32\t \n#define RME9652_rec_buffer        36\t \n#define RME9652_control_register  64\n#define RME9652_irq_clear         96\n#define RME9652_time_code         100\t \n#define RME9652_thru_base         128\t \n\n \n\n \n\n#define RME9652_status_register    0\n\n \n\n\n#define RME9652_start_bit\t   (1<<0)\t \n                                                 \n#define RME9652_Master\t\t   (1<<4)\t \n#define RME9652_IE\t\t   (1<<5)\t \n#define RME9652_freq\t\t   (1<<6)        \n#define RME9652_freq1\t\t   (1<<7)        \n#define RME9652_DS                 (1<<8)\t \n#define RME9652_PRO\t\t   (1<<9)\t \n#define RME9652_EMP\t\t   (1<<10)\t \n#define RME9652_Dolby\t\t   (1<<11)\t \n#define RME9652_opt_out\t           (1<<12)\t \n#define RME9652_wsel\t\t   (1<<13)\t \n#define RME9652_inp_0\t\t   (1<<14)\t \n#define RME9652_inp_1\t\t   (1<<15)\t \n#define RME9652_SyncPref_ADAT2\t   (1<<16)\n#define RME9652_SyncPref_ADAT3\t   (1<<17)\n#define RME9652_SPDIF_RESET        (1<<18)       \n#define RME9652_SPDIF_SELECT       (1<<19)\n#define RME9652_SPDIF_CLOCK        (1<<20)\n#define RME9652_SPDIF_WRITE        (1<<21)\n#define RME9652_ADAT1_INTERNAL     (1<<22)       \n\n \n\n#define RME9652_latency            0x0e\n#define rme9652_encode_latency(x)  (((x)&0x7)<<1)\n#define rme9652_decode_latency(x)  (((x)>>1)&0x7)\n#define rme9652_running_double_speed(s) ((s)->control_register & RME9652_DS)\n#define RME9652_inp                (RME9652_inp_0|RME9652_inp_1)\n#define rme9652_encode_spdif_in(x) (((x)&0x3)<<14)\n#define rme9652_decode_spdif_in(x) (((x)>>14)&0x3)\n\n#define RME9652_SyncPref_Mask      (RME9652_SyncPref_ADAT2|RME9652_SyncPref_ADAT3)\n#define RME9652_SyncPref_ADAT1\t   0\n#define RME9652_SyncPref_SPDIF\t   (RME9652_SyncPref_ADAT2|RME9652_SyncPref_ADAT3)\n\n \n\n#define RME9652_CHANNEL_BUFFER_SAMPLES  (16*1024)\n#define RME9652_CHANNEL_BUFFER_BYTES    (4*RME9652_CHANNEL_BUFFER_SAMPLES)\n\n \n\n#define RME9652_DMA_AREA_BYTES ((RME9652_NCHANNELS+1) * RME9652_CHANNEL_BUFFER_BYTES)\n#define RME9652_DMA_AREA_KILOBYTES (RME9652_DMA_AREA_BYTES/1024)\n\nstruct snd_rme9652 {\n\tint dev;\n\n\tspinlock_t lock;\n\tint irq;\n\tunsigned long port;\n\tvoid __iomem *iobase;\n\t\n\tint precise_ptr;\n\n\tu32 control_register;\t \n\tu32 thru_bits;\t\t \n\n\tu32 creg_spdif;\n\tu32 creg_spdif_stream;\n\n\tchar *card_name;\t\t \n\n        size_t hw_offsetmask;     \t \n\tsize_t prev_hw_offset;\t\t \n\tsize_t max_jitter;\t\t \n\tsize_t period_bytes;\t\t \n\n\tunsigned char ds_channels;\n\tunsigned char ss_channels;\t \n\n\t \n\tstruct snd_dma_buffer playback_dma_buf;\n\tstruct snd_dma_buffer capture_dma_buf;\n\n\tunsigned char *capture_buffer;\t \n\tunsigned char *playback_buffer;\t \n\n\tpid_t capture_pid;\n\tpid_t playback_pid;\n\n\tstruct snd_pcm_substream *capture_substream;\n\tstruct snd_pcm_substream *playback_substream;\n\tint running;\n\n        int passthru;                    \n        int hw_rev;                      \n\n\tint last_spdif_sample_rate;\t \n\tint last_adat_sample_rate;\t \n\n\tconst signed char *channel_map;\n\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct pci_dev *pci;\n\tstruct snd_kcontrol *spdif_ctl;\n\n};\n\n \n\nstatic const signed char channel_map_9652_ss[26] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\n\t18, 19, 20, 21, 22, 23, 24, 25\n};\n\nstatic const signed char channel_map_9636_ss[26] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, \n\t \n\t24, 25,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const signed char channel_map_9652_ds[26] = {\n\t \n\t1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23,\n\t \n\t24, 25,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const signed char channel_map_9636_ds[26] = {\n\t \n\t1, 3, 5, 7, 9, 11, 13, 15,\n\t \n\t24, 25,\n\t \n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic struct snd_dma_buffer *\nsnd_hammerfall_get_buffer(struct pci_dev *pci, size_t size)\n{\n\treturn snd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV, size);\n}\n\nstatic const struct pci_device_id snd_rme9652_ids[] = {\n\t{\n\t\t.vendor\t   = 0x10ee,\n\t\t.device\t   = 0x3fc4,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t},\t \n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, snd_rme9652_ids);\n\nstatic inline void rme9652_write(struct snd_rme9652 *rme9652, int reg, int val)\n{\n\twritel(val, rme9652->iobase + reg);\n}\n\nstatic inline unsigned int rme9652_read(struct snd_rme9652 *rme9652, int reg)\n{\n\treturn readl(rme9652->iobase + reg);\n}\n\nstatic inline int snd_rme9652_use_is_exclusive(struct snd_rme9652 *rme9652)\n{\n\tunsigned long flags;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&rme9652->lock, flags);\n\tif ((rme9652->playback_pid != rme9652->capture_pid) &&\n\t    (rme9652->playback_pid >= 0) && (rme9652->capture_pid >= 0)) {\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&rme9652->lock, flags);\n\treturn ret;\n}\n\nstatic inline int rme9652_adat_sample_rate(struct snd_rme9652 *rme9652)\n{\n\tif (rme9652_running_double_speed(rme9652)) {\n\t\treturn (rme9652_read(rme9652, RME9652_status_register) &\n\t\t\tRME9652_fs48) ? 96000 : 88200;\n\t} else {\n\t\treturn (rme9652_read(rme9652, RME9652_status_register) &\n\t\t\tRME9652_fs48) ? 48000 : 44100;\n\t}\n}\n\nstatic inline void rme9652_compute_period_size(struct snd_rme9652 *rme9652)\n{\n\tunsigned int i;\n\n\ti = rme9652->control_register & RME9652_latency;\n\trme9652->period_bytes = 1 << ((rme9652_decode_latency(i) + 8));\n\trme9652->hw_offsetmask = \n\t\t(rme9652->period_bytes * 2 - 1) & RME9652_buf_pos;\n\trme9652->max_jitter = 80;\n}\n\nstatic snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)\n{\n\tint status;\n\tunsigned int offset, frag;\n\tsnd_pcm_uframes_t period_size = rme9652->period_bytes / 4;\n\tsnd_pcm_sframes_t delta;\n\n\tstatus = rme9652_read(rme9652, RME9652_status_register);\n\tif (!rme9652->precise_ptr)\n\t\treturn (status & RME9652_buffer_id) ? period_size : 0;\n\toffset = status & RME9652_buf_pos;\n\n\t \n\n\tdelta = rme9652->prev_hw_offset - offset;\n\tdelta &= 0xffff;\n\tif (delta <= (snd_pcm_sframes_t)rme9652->max_jitter * 4)\n\t\toffset = rme9652->prev_hw_offset;\n\telse\n\t\trme9652->prev_hw_offset = offset;\n\toffset &= rme9652->hw_offsetmask;\n\toffset /= 4;\n\tfrag = status & RME9652_buffer_id;\n\n\tif (offset < period_size) {\n\t\tif (offset > rme9652->max_jitter) {\n\t\t\tif (frag)\n\t\t\t\tdev_err(rme9652->card->dev,\n\t\t\t\t\t\"Unexpected hw_pointer position (bufid == 0): status: %x offset: %d\\n\",\n\t\t\t\t\tstatus, offset);\n\t\t} else if (!frag)\n\t\t\treturn 0;\n\t\toffset -= rme9652->max_jitter;\n\t\tif ((int)offset < 0)\n\t\t\toffset += period_size * 2;\n\t} else {\n\t\tif (offset > period_size + rme9652->max_jitter) {\n\t\t\tif (!frag)\n\t\t\t\tdev_err(rme9652->card->dev,\n\t\t\t\t\t\"Unexpected hw_pointer position (bufid == 1): status: %x offset: %d\\n\",\n\t\t\t\t\tstatus, offset);\n\t\t} else if (frag)\n\t\t\treturn period_size;\n\t\toffset -= rme9652->max_jitter;\n\t}\n\n\treturn offset;\n}\n\nstatic inline void rme9652_reset_hw_pointer(struct snd_rme9652 *rme9652)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 8; i++) {\n\t\trme9652_write(rme9652, i * 4, 0);\n\t\tudelay(10);\n\t}\n\trme9652->prev_hw_offset = 0;\n}\n\nstatic inline void rme9652_start(struct snd_rme9652 *s)\n{\n\ts->control_register |= (RME9652_IE | RME9652_start_bit);\n\trme9652_write(s, RME9652_control_register, s->control_register);\n}\n\nstatic inline void rme9652_stop(struct snd_rme9652 *s)\n{\n\ts->control_register &= ~(RME9652_start_bit | RME9652_IE);\n\trme9652_write(s, RME9652_control_register, s->control_register);\n}\n\nstatic int rme9652_set_interrupt_interval(struct snd_rme9652 *s,\n\t\t\t\t\t  unsigned int frames)\n{\n\tint restart = 0;\n\tint n;\n\n\tspin_lock_irq(&s->lock);\n\n\trestart = s->running;\n\tif (restart)\n\t\trme9652_stop(s);\n\n\tframes >>= 7;\n\tn = 0;\n\twhile (frames) {\n\t\tn++;\n\t\tframes >>= 1;\n\t}\n\n\ts->control_register &= ~RME9652_latency;\n\ts->control_register |= rme9652_encode_latency(n);\n\n\trme9652_write(s, RME9652_control_register, s->control_register);\n\n\trme9652_compute_period_size(s);\n\n\tif (restart)\n\t\trme9652_start(s);\n\n\tspin_unlock_irq(&s->lock);\n\n\treturn 0;\n}\n\nstatic int rme9652_set_rate(struct snd_rme9652 *rme9652, int rate)\n{\n\tint restart;\n\tint reject_if_open = 0;\n\tint xrate;\n\n\tif (!snd_rme9652_use_is_exclusive (rme9652)) {\n\t\treturn -EBUSY;\n\t}\n\n\t \n\n\tspin_lock_irq(&rme9652->lock);\n\txrate = rme9652_adat_sample_rate(rme9652);\n\n\tswitch (rate) {\n\tcase 44100:\n\t\tif (xrate > 48000) {\n\t\t\treject_if_open = 1;\n\t\t}\n\t\trate = 0;\n\t\tbreak;\n\tcase 48000:\n\t\tif (xrate > 48000) {\n\t\t\treject_if_open = 1;\n\t\t}\n\t\trate = RME9652_freq;\n\t\tbreak;\n\tcase 88200:\n\t\tif (xrate < 48000) {\n\t\t\treject_if_open = 1;\n\t\t}\n\t\trate = RME9652_DS;\n\t\tbreak;\n\tcase 96000:\n\t\tif (xrate < 48000) {\n\t\t\treject_if_open = 1;\n\t\t}\n\t\trate = RME9652_DS | RME9652_freq;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irq(&rme9652->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reject_if_open && (rme9652->capture_pid >= 0 || rme9652->playback_pid >= 0)) {\n\t\tspin_unlock_irq(&rme9652->lock);\n\t\treturn -EBUSY;\n\t}\n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\trme9652->control_register &= ~(RME9652_freq | RME9652_DS);\n\trme9652->control_register |= rate;\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\tif (rate & RME9652_DS) {\n\t\tif (rme9652->ss_channels == RME9652_NCHANNELS) {\n\t\t\trme9652->channel_map = channel_map_9652_ds;\n\t\t} else {\n\t\t\trme9652->channel_map = channel_map_9636_ds;\n\t\t}\n\t} else {\n\t\tif (rme9652->ss_channels == RME9652_NCHANNELS) {\n\t\t\trme9652->channel_map = channel_map_9652_ss;\n\t\t} else {\n\t\t\trme9652->channel_map = channel_map_9636_ss;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic void rme9652_set_thru(struct snd_rme9652 *rme9652, int channel, int enable)\n{\n\tint i;\n\n\trme9652->passthru = 0;\n\n\tif (channel < 0) {\n\n\t\t \n\n\t\tif (enable) {\n\t\t\tfor (i = 0; i < RME9652_NCHANNELS; i++) {\n\t\t\t\trme9652->thru_bits |= (1 << i);\n\t\t\t\trme9652_write(rme9652, RME9652_thru_base + i * 4, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < RME9652_NCHANNELS; i++) {\n\t\t\t\trme9652->thru_bits &= ~(1 << i);\n\t\t\t\trme9652_write(rme9652, RME9652_thru_base + i * 4, 0);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tint mapped_channel;\n\n\t\tmapped_channel = rme9652->channel_map[channel];\n\n\t\tif (enable) {\n\t\t\trme9652->thru_bits |= (1 << mapped_channel);\n\t\t} else {\n\t\t\trme9652->thru_bits &= ~(1 << mapped_channel);\n\t\t}\n\n\t\trme9652_write(rme9652,\n\t\t\t       RME9652_thru_base + mapped_channel * 4,\n\t\t\t       enable ? 1 : 0);\t\t\t       \n\t}\n}\n\nstatic int rme9652_set_passthru(struct snd_rme9652 *rme9652, int onoff)\n{\n\tif (onoff) {\n\t\trme9652_set_thru(rme9652, -1, 1);\n\n\t\t \n\n\t\trme9652->control_register =\n\t\t\tRME9652_inp_0 | \n\t\t\trme9652_encode_latency(7) |\n\t\t\tRME9652_start_bit;\n\n\t\trme9652_reset_hw_pointer(rme9652);\n\n\t\trme9652_write(rme9652, RME9652_control_register,\n\t\t\t      rme9652->control_register);\n\t\trme9652->passthru = 1;\n\t} else {\n\t\trme9652_set_thru(rme9652, -1, 0);\n\t\trme9652_stop(rme9652);\t\t\n\t\trme9652->passthru = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void rme9652_spdif_set_bit (struct snd_rme9652 *rme9652, int mask, int onoff)\n{\n\tif (onoff) \n\t\trme9652->control_register |= mask;\n\telse \n\t\trme9652->control_register &= ~mask;\n\t\t\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n}\n\nstatic void rme9652_spdif_write_byte (struct snd_rme9652 *rme9652, const int val)\n{\n\tlong mask;\n\tlong i;\n\n\tfor (i = 0, mask = 0x80; i < 8; i++, mask >>= 1) {\n\t\tif (val & mask)\n\t\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 1);\n\t\telse \n\t\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 0);\n\n\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);\n\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);\n\t}\n}\n\nstatic int rme9652_spdif_read_byte (struct snd_rme9652 *rme9652)\n{\n\tlong mask;\n\tlong val;\n\tlong i;\n\n\tval = 0;\n\n\tfor (i = 0, mask = 0x80;  i < 8; i++, mask >>= 1) {\n\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);\n\t\tif (rme9652_read (rme9652, RME9652_status_register) & RME9652_SPDIF_READ)\n\t\t\tval |= mask;\n\t\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);\n\t}\n\n\treturn val;\n}\n\nstatic void rme9652_write_spdif_codec (struct snd_rme9652 *rme9652, const int address, const int data)\n{\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\n\trme9652_spdif_write_byte (rme9652, 0x20);\n\trme9652_spdif_write_byte (rme9652, address);\n\trme9652_spdif_write_byte (rme9652, data);\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\n}\n\n\nstatic int rme9652_spdif_read_codec (struct snd_rme9652 *rme9652, const int address)\n{\n\tint ret;\n\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\n\trme9652_spdif_write_byte (rme9652, 0x20);\n\trme9652_spdif_write_byte (rme9652, address);\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\n\n\trme9652_spdif_write_byte (rme9652, 0x21);\n\tret = rme9652_spdif_read_byte (rme9652);\n\trme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\n\n\treturn ret;\n}\n\nstatic void rme9652_initialize_spdif_receiver (struct snd_rme9652 *rme9652)\n{\n\t \n\n\trme9652->control_register |= RME9652_SPDIF_RESET;\n\n\trme9652_write_spdif_codec (rme9652, 4, 0x40);\n\trme9652_write_spdif_codec (rme9652, 17, 0x13);\n\trme9652_write_spdif_codec (rme9652, 6, 0x02);\n}\n\nstatic inline int rme9652_spdif_sample_rate(struct snd_rme9652 *s)\n{\n\tunsigned int rate_bits;\n\n\tif (rme9652_read(s, RME9652_status_register) & RME9652_ERF) {\n\t\treturn -1;\t \n\t}\n\t\n\tif (s->hw_rev == 15) {\n\n\t\tint x, y, ret;\n\t\t\n\t\tx = rme9652_spdif_read_codec (s, 30);\n\n\t\tif (x != 0) \n\t\t\ty = 48000 * 64 / x;\n\t\telse\n\t\t\ty = 0;\n\n\t\tif      (y > 30400 && y < 33600)  ret = 32000; \n\t\telse if (y > 41900 && y < 46000)  ret = 44100;\n\t\telse if (y > 46000 && y < 50400)  ret = 48000;\n\t\telse if (y > 60800 && y < 67200)  ret = 64000;\n\t\telse if (y > 83700 && y < 92000)  ret = 88200;\n\t\telse if (y > 92000 && y < 100000) ret = 96000;\n\t\telse                              ret = 0;\n\t\treturn ret;\n\t}\n\n\trate_bits = rme9652_read(s, RME9652_status_register) & RME9652_F;\n\n\tswitch (rme9652_decode_spdif_rate(rate_bits)) {\n\tcase 0x7:\n\t\treturn 32000;\n\n\tcase 0x6:\n\t\treturn 44100;\n\n\tcase 0x5:\n\t\treturn 48000;\n\n\tcase 0x4:\n\t\treturn 88200;\n\n\tcase 0x3:\n\t\treturn 96000;\n\n\tcase 0x0:\n\t\treturn 64000;\n\n\tdefault:\n\t\tdev_err(s->card->dev,\n\t\t\t\"%s: unknown S/PDIF input rate (bits = 0x%x)\\n\",\n\t\t\t   s->card_name, rate_bits);\n\t\treturn 0;\n\t}\n}\n\n \n\nstatic u32 snd_rme9652_convert_from_aes(struct snd_aes_iec958 *aes)\n{\n\tu32 val = 0;\n\tval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME9652_PRO : 0;\n\tval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME9652_Dolby : 0;\n\tif (val & RME9652_PRO)\n\t\tval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME9652_EMP : 0;\n\telse\n\t\tval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME9652_EMP : 0;\n\treturn val;\n}\n\nstatic void snd_rme9652_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\n{\n\taes->status[0] = ((val & RME9652_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |\n\t\t\t ((val & RME9652_Dolby) ? IEC958_AES0_NONAUDIO : 0);\n\tif (val & RME9652_PRO)\n\t\taes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\n\telse\n\t\taes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\n}\n\nstatic int snd_rme9652_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme9652_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif);\n\treturn 0;\n}\n\nstatic int snd_rme9652_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\t\n\tval = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme9652->lock);\n\tchange = val != rme9652->creg_spdif;\n\trme9652->creg_spdif = val;\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\nstatic int snd_rme9652_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme9652_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tsnd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif_stream);\n\treturn 0;\n}\n\nstatic int snd_rme9652_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tu32 val;\n\t\n\tval = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);\n\tspin_lock_irq(&rme9652->lock);\n\tchange = val != rme9652->creg_spdif_stream;\n\trme9652->creg_spdif_stream = val;\n\trme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\nstatic int snd_rme9652_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_rme9652_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = kcontrol->private_value;\n\treturn 0;\n}\n\n#define RME9652_ADAT1_IN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_adat1_in, \\\n  .get = snd_rme9652_get_adat1_in, \\\n  .put = snd_rme9652_put_adat1_in }\n\nstatic unsigned int rme9652_adat1_in(struct snd_rme9652 *rme9652)\n{\n\tif (rme9652->control_register & RME9652_ADAT1_INTERNAL)\n\t\treturn 1; \n\treturn 0;\n}\n\nstatic int rme9652_set_adat1_input(struct snd_rme9652 *rme9652, int internal)\n{\n\tint restart = 0;\n\n\tif (internal) {\n\t\trme9652->control_register |= RME9652_ADAT1_INTERNAL;\n\t} else {\n\t\trme9652->control_register &= ~RME9652_ADAT1_INTERNAL;\n\t}\n\n\t \n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_info_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[2] = {\"ADAT1\", \"Internal\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int snd_rme9652_get_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.enumerated.item[0] = rme9652_adat1_in(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\t\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0] % 2;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = val != rme9652_adat1_in(rme9652);\n\tif (change)\n\t\trme9652_set_adat1_input(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\n#define RME9652_SPDIF_IN(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_spdif_in, \\\n  .get = snd_rme9652_get_spdif_in, .put = snd_rme9652_put_spdif_in }\n\nstatic unsigned int rme9652_spdif_in(struct snd_rme9652 *rme9652)\n{\n\treturn rme9652_decode_spdif_in(rme9652->control_register &\n\t\t\t\t       RME9652_inp);\n}\n\nstatic int rme9652_set_spdif_input(struct snd_rme9652 *rme9652, int in)\n{\n\tint restart = 0;\n\n\trme9652->control_register &= ~RME9652_inp;\n\trme9652->control_register |= rme9652_encode_spdif_in(in);\n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\"ADAT1\", \"Coaxial\", \"Internal\"};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_rme9652_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.enumerated.item[0] = rme9652_spdif_in(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\t\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0] % 3;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = val != rme9652_spdif_in(rme9652);\n\tif (change)\n\t\trme9652_set_spdif_input(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\n#define RME9652_SPDIF_OUT(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_spdif_out, \\\n  .get = snd_rme9652_get_spdif_out, .put = snd_rme9652_put_spdif_out }\n\nstatic int rme9652_spdif_out(struct snd_rme9652 *rme9652)\n{\n\treturn (rme9652->control_register & RME9652_opt_out) ? 1 : 0;\n}\n\nstatic int rme9652_set_spdif_output(struct snd_rme9652 *rme9652, int out)\n{\n\tint restart = 0;\n\n\tif (out) {\n\t\trme9652->control_register |= RME9652_opt_out;\n\t} else {\n\t\trme9652->control_register &= ~RME9652_opt_out;\n\t}\n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\treturn 0;\n}\n\n#define snd_rme9652_info_spdif_out\tsnd_ctl_boolean_mono_info\n\nstatic int snd_rme9652_get_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.integer.value[0] = rme9652_spdif_out(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\t\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = (int)val != rme9652_spdif_out(rme9652);\n\trme9652_set_spdif_output(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\n#define RME9652_SYNC_MODE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_sync_mode, \\\n  .get = snd_rme9652_get_sync_mode, .put = snd_rme9652_put_sync_mode }\n\nstatic int rme9652_sync_mode(struct snd_rme9652 *rme9652)\n{\n\tif (rme9652->control_register & RME9652_wsel) {\n\t\treturn 2;\n\t} else if (rme9652->control_register & RME9652_Master) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int rme9652_set_sync_mode(struct snd_rme9652 *rme9652, int mode)\n{\n\tint restart = 0;\n\n\tswitch (mode) {\n\tcase 0:\n\t\trme9652->control_register &=\n\t\t    ~(RME9652_Master | RME9652_wsel);\n\t\tbreak;\n\tcase 1:\n\t\trme9652->control_register =\n\t\t    (rme9652->control_register & ~RME9652_wsel) | RME9652_Master;\n\t\tbreak;\n\tcase 2:\n\t\trme9652->control_register |=\n\t\t    (RME9652_Master | RME9652_wsel);\n\t\tbreak;\n\t}\n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_info_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"AutoSync\", \"Master\", \"Word Clock\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int snd_rme9652_get_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.enumerated.item[0] = rme9652_sync_mode(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\t\n\tval = ucontrol->value.enumerated.item[0] % 3;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = (int)val != rme9652_sync_mode(rme9652);\n\trme9652_set_sync_mode(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\n#define RME9652_SYNC_PREF(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_sync_pref, \\\n  .get = snd_rme9652_get_sync_pref, .put = snd_rme9652_put_sync_pref }\n\nstatic int rme9652_sync_pref(struct snd_rme9652 *rme9652)\n{\n\tswitch (rme9652->control_register & RME9652_SyncPref_Mask) {\n\tcase RME9652_SyncPref_ADAT1:\n\t\treturn RME9652_SYNC_FROM_ADAT1;\n\tcase RME9652_SyncPref_ADAT2:\n\t\treturn RME9652_SYNC_FROM_ADAT2;\n\tcase RME9652_SyncPref_ADAT3:\n\t\treturn RME9652_SYNC_FROM_ADAT3;\n\tcase RME9652_SyncPref_SPDIF:\n\t\treturn RME9652_SYNC_FROM_SPDIF;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int rme9652_set_sync_pref(struct snd_rme9652 *rme9652, int pref)\n{\n\tint restart;\n\n\trme9652->control_register &= ~RME9652_SyncPref_Mask;\n\tswitch (pref) {\n\tcase RME9652_SYNC_FROM_ADAT1:\n\t\trme9652->control_register |= RME9652_SyncPref_ADAT1;\n\t\tbreak;\n\tcase RME9652_SYNC_FROM_ADAT2:\n\t\trme9652->control_register |= RME9652_SyncPref_ADAT2;\n\t\tbreak;\n\tcase RME9652_SYNC_FROM_ADAT3:\n\t\trme9652->control_register |= RME9652_SyncPref_ADAT3;\n\t\tbreak;\n\tcase RME9652_SYNC_FROM_SPDIF:\n\t\trme9652->control_register |= RME9652_SyncPref_SPDIF;\n\t\tbreak;\n\t}\n\n\trestart = rme9652->running;\n\tif (restart)\n\t\trme9652_stop(rme9652);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\tif (restart)\n\t\trme9652_start(rme9652);\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_info_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"IEC958 In\", \"ADAT1 In\", \"ADAT2 In\", \"ADAT3 In\"\n\t};\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\n\treturn snd_ctl_enum_info(uinfo, 1,\n\t\t\t\t rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3,\n\t\t\t\t texts);\n}\n\nstatic int snd_rme9652_get_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.enumerated.item[0] = rme9652_sync_pref(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change, max;\n\tunsigned int val;\n\t\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\tmax = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;\n\tval = ucontrol->value.enumerated.item[0] % max;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = (int)val != rme9652_sync_pref(rme9652);\n\trme9652_set_sync_pref(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn change;\n}\n\nstatic int snd_rme9652_info_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = rme9652->ss_channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int snd_rme9652_get_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tunsigned int k;\n\tu32 thru_bits = rme9652->thru_bits;\n\n\tfor (k = 0; k < rme9652->ss_channels; ++k) {\n\t\tucontrol->value.integer.value[k] = !!(thru_bits & (1 << k));\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int chn;\n\tu32 thru_bits = 0;\n\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\n\tfor (chn = 0; chn < rme9652->ss_channels; ++chn) {\n\t\tif (ucontrol->value.integer.value[chn])\n\t\t\tthru_bits |= 1 << chn;\n\t}\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tchange = thru_bits ^ rme9652->thru_bits;\n\tif (change) {\n\t\tfor (chn = 0; chn < rme9652->ss_channels; ++chn) {\n\t\t\tif (!(change & (1 << chn)))\n\t\t\t\tcontinue;\n\t\t\trme9652_set_thru(rme9652,chn,thru_bits&(1<<chn));\n\t\t}\n\t}\n\tspin_unlock_irq(&rme9652->lock);\n\treturn !!change;\n}\n\n#define RME9652_PASSTHRU(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_rme9652_info_passthru, \\\n  .put = snd_rme9652_put_passthru, \\\n  .get = snd_rme9652_get_passthru }\n\n#define snd_rme9652_info_passthru\tsnd_ctl_boolean_mono_info\n\nstatic int snd_rme9652_get_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.integer.value[0] = rme9652->passthru;\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic int snd_rme9652_put_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\tint err = 0;\n\n\tif (!snd_rme9652_use_is_exclusive(rme9652))\n\t\treturn -EBUSY;\n\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&rme9652->lock);\n\tchange = (ucontrol->value.integer.value[0] != rme9652->passthru);\n\tif (change)\n\t\terr = rme9652_set_passthru(rme9652, val);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn err ? err : change;\n}\n\n \n\n#define RME9652_SPDIF_RATE(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_rme9652_info_spdif_rate, \\\n  .get = snd_rme9652_get_spdif_rate }\n\nstatic int snd_rme9652_info_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 96000;\n\treturn 0;\n}\n\nstatic int snd_rme9652_get_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&rme9652->lock);\n\tucontrol->value.integer.value[0] = rme9652_spdif_sample_rate(rme9652);\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\n#define RME9652_ADAT_SYNC(xname, xindex, xidx) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_rme9652_info_adat_sync, \\\n  .get = snd_rme9652_get_adat_sync, .private_value = xidx }\n\nstatic int snd_rme9652_info_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"No Lock\", \"Lock\", \"No Lock Sync\", \"Lock Sync\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 4, texts);\n}\n\nstatic int snd_rme9652_get_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\tunsigned int mask1, mask2, val;\n\t\n\tswitch (kcontrol->private_value) {\n\tcase 0: mask1 = RME9652_lock_0; mask2 = RME9652_sync_0; break;\t\n\tcase 1: mask1 = RME9652_lock_1; mask2 = RME9652_sync_1; break;\t\n\tcase 2: mask1 = RME9652_lock_2; mask2 = RME9652_sync_2; break;\t\n\tdefault: return -EINVAL;\n\t}\n\tval = rme9652_read(rme9652, RME9652_status_register);\n\tucontrol->value.enumerated.item[0] = (val & mask1) ? 1 : 0;\n\tucontrol->value.enumerated.item[0] |= (val & mask2) ? 2 : 0;\n\treturn 0;\n}\n\n#define RME9652_TC_VALID(xname, xindex) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n  .info = snd_rme9652_info_tc_valid, \\\n  .get = snd_rme9652_get_tc_valid }\n\n#define snd_rme9652_info_tc_valid\tsnd_ctl_boolean_mono_info\n\nstatic int snd_rme9652_get_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] = \n\t\t(rme9652_read(rme9652, RME9652_status_register) & RME9652_tc_valid) ? 1 : 0;\n\treturn 0;\n}\n\n#ifdef ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE\n\n \n\nstatic int snd_rme9652_get_tc_value(void *private_data,\n\t\t\t\t    snd_kswitch_t *kswitch,\n\t\t\t\t    snd_switch_t *uswitch)\n{\n\tstruct snd_rme9652 *s = (struct snd_rme9652 *) private_data;\n\tu32 value;\n\tint i;\n\n\tuswitch->type = SNDRV_SW_TYPE_DWORD;\n\n\tif ((rme9652_read(s, RME9652_status_register) &\n\t     RME9652_tc_valid) == 0) {\n\t\tuswitch->value.data32[0] = 0;\n\t\treturn 0;\n\t}\n\n\t \n\n\trme9652_write(s, RME9652_time_code, 0);\n\n\t \n\n\tfor (i = 0; i < 50; i++) {\n\t\tif (!(rme9652_read(s, i * 4) & RME9652_tc_busy))\n\t\t\tbreak;\n\t}\n\n\tif (!(rme9652_read(s, i * 4) & RME9652_tc_busy)) {\n\t\treturn -EIO;\n\t}\n\n\tvalue = 0;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tvalue >>= 1;\n\n\t\tif (rme9652_read(s, i * 4) & RME9652_tc_out)\n\t\t\tvalue |= 0x80000000;\n\t}\n\n\tif (value > 2 * 60 * 48000) {\n\t\tvalue -= 2 * 60 * 48000;\n\t} else {\n\t\tvalue = 0;\n\t}\n\n\tuswitch->value.data32[0] = value;\n\n\treturn 0;\n}\n\n#endif\t\t\t\t \n\nstatic const struct snd_kcontrol_new snd_rme9652_controls[] = {\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tsnd_rme9652_control_spdif_info,\n\t.get =\t\tsnd_rme9652_control_spdif_get,\n\t.put =\t\tsnd_rme9652_control_spdif_put,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t.info =\t\tsnd_rme9652_control_spdif_stream_info,\n\t.get =\t\tsnd_rme9652_control_spdif_stream_get,\n\t.put =\t\tsnd_rme9652_control_spdif_stream_put,\n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tsnd_rme9652_control_spdif_mask_info,\n\t.get =\t\tsnd_rme9652_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n\t\t\tIEC958_AES0_PROFESSIONAL |\n\t\t\tIEC958_AES0_CON_EMPHASIS,\t                                                                                      \n},\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PRO_MASK),\n\t.info =\t\tsnd_rme9652_control_spdif_mask_info,\n\t.get =\t\tsnd_rme9652_control_spdif_mask_get,\n\t.private_value = IEC958_AES0_NONAUDIO |\n\t\t\tIEC958_AES0_PROFESSIONAL |\n\t\t\tIEC958_AES0_PRO_EMPHASIS,\n},\nRME9652_SPDIF_IN(\"IEC958 Input Connector\", 0),\nRME9652_SPDIF_OUT(\"IEC958 Output also on ADAT1\", 0),\nRME9652_SYNC_MODE(\"Sync Mode\", 0),\nRME9652_SYNC_PREF(\"Preferred Sync Source\", 0),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Channels Thru\",\n\t.index = 0,\n\t.info = snd_rme9652_info_thru,\n\t.get = snd_rme9652_get_thru,\n\t.put = snd_rme9652_put_thru,\n},\nRME9652_SPDIF_RATE(\"IEC958 Sample Rate\", 0),\nRME9652_ADAT_SYNC(\"ADAT1 Sync Check\", 0, 0),\nRME9652_ADAT_SYNC(\"ADAT2 Sync Check\", 0, 1),\nRME9652_TC_VALID(\"Timecode Valid\", 0),\nRME9652_PASSTHRU(\"Passthru\", 0)\n};\n\nstatic const struct snd_kcontrol_new snd_rme9652_adat3_check =\nRME9652_ADAT_SYNC(\"ADAT3 Sync Check\", 0, 2);\n\nstatic const struct snd_kcontrol_new snd_rme9652_adat1_input =\nRME9652_ADAT1_IN(\"ADAT1 Input Source\", 0);\n\nstatic int snd_rme9652_create_controls(struct snd_card *card, struct snd_rme9652 *rme9652)\n{\n\tunsigned int idx;\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_rme9652_controls); idx++) {\n\t\tkctl = snd_ctl_new1(&snd_rme9652_controls[idx], rme9652);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (idx == 1)\t \n\t\t\trme9652->spdif_ctl = kctl;\n\t}\n\n\tif (rme9652->ss_channels == RME9652_NCHANNELS) {\n\t\tkctl = snd_ctl_new1(&snd_rme9652_adat3_check, rme9652);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (rme9652->hw_rev >= 15) {\n\t\tkctl = snd_ctl_new1(&snd_rme9652_adat1_input, rme9652);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void\nsnd_rme9652_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) entry->private_data;\n\tu32 thru_bits = rme9652->thru_bits;\n\tint show_auto_sync_source = 0;\n\tint i;\n\tunsigned int status;\n\tint x;\n\n\tstatus = rme9652_read(rme9652, RME9652_status_register);\n\n\tsnd_iprintf(buffer, \"%s (Card #%d)\\n\", rme9652->card_name, rme9652->card->number + 1);\n\tsnd_iprintf(buffer, \"Buffers: capture %p playback %p\\n\",\n\t\t    rme9652->capture_buffer, rme9652->playback_buffer);\n\tsnd_iprintf(buffer, \"IRQ: %d Registers bus: 0x%lx VM: 0x%lx\\n\",\n\t\t    rme9652->irq, rme9652->port, (unsigned long)rme9652->iobase);\n\tsnd_iprintf(buffer, \"Control register: %x\\n\", rme9652->control_register);\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tx = 1 << (6 + rme9652_decode_latency(rme9652->control_register & \n\t\t\t\t\t     RME9652_latency));\n\n\tsnd_iprintf(buffer, \"Latency: %d samples (2 periods of %lu bytes)\\n\", \n\t\t    x, (unsigned long) rme9652->period_bytes);\n\tsnd_iprintf(buffer, \"Hardware pointer (frames): %ld\\n\",\n\t\t    rme9652_hw_pointer(rme9652));\n\tsnd_iprintf(buffer, \"Passthru: %s\\n\",\n\t\t    rme9652->passthru ? \"yes\" : \"no\");\n\n\tif ((rme9652->control_register & (RME9652_Master | RME9652_wsel)) == 0) {\n\t\tsnd_iprintf(buffer, \"Clock mode: autosync\\n\");\n\t\tshow_auto_sync_source = 1;\n\t} else if (rme9652->control_register & RME9652_wsel) {\n\t\tif (status & RME9652_wsel_rd) {\n\t\t\tsnd_iprintf(buffer, \"Clock mode: word clock\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"Clock mode: word clock (no signal)\\n\");\n\t\t}\n\t} else {\n\t\tsnd_iprintf(buffer, \"Clock mode: master\\n\");\n\t}\n\n\tif (show_auto_sync_source) {\n\t\tswitch (rme9652->control_register & RME9652_SyncPref_Mask) {\n\t\tcase RME9652_SyncPref_ADAT1:\n\t\t\tsnd_iprintf(buffer, \"Pref. sync source: ADAT1\\n\");\n\t\t\tbreak;\n\t\tcase RME9652_SyncPref_ADAT2:\n\t\t\tsnd_iprintf(buffer, \"Pref. sync source: ADAT2\\n\");\n\t\t\tbreak;\n\t\tcase RME9652_SyncPref_ADAT3:\n\t\t\tsnd_iprintf(buffer, \"Pref. sync source: ADAT3\\n\");\n\t\t\tbreak;\n\t\tcase RME9652_SyncPref_SPDIF:\n\t\t\tsnd_iprintf(buffer, \"Pref. sync source: IEC958\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"Pref. sync source: ???\\n\");\n\t\t}\n\t}\n\n\tif (rme9652->hw_rev >= 15)\n\t\tsnd_iprintf(buffer, \"\\nADAT1 Input source: %s\\n\",\n\t\t\t    (rme9652->control_register & RME9652_ADAT1_INTERNAL) ?\n\t\t\t    \"Internal\" : \"ADAT1 optical\");\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tswitch (rme9652_decode_spdif_in(rme9652->control_register & \n\t\t\t\t\tRME9652_inp)) {\n\tcase RME9652_SPDIFIN_OPTICAL:\n\t\tsnd_iprintf(buffer, \"IEC958 input: ADAT1\\n\");\n\t\tbreak;\n\tcase RME9652_SPDIFIN_COAXIAL:\n\t\tsnd_iprintf(buffer, \"IEC958 input: Coaxial\\n\");\n\t\tbreak;\n\tcase RME9652_SPDIFIN_INTERN:\n\t\tsnd_iprintf(buffer, \"IEC958 input: Internal\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsnd_iprintf(buffer, \"IEC958 input: ???\\n\");\n\t\tbreak;\n\t}\n\n\tif (rme9652->control_register & RME9652_opt_out) {\n\t\tsnd_iprintf(buffer, \"IEC958 output: Coaxial & ADAT1\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"IEC958 output: Coaxial only\\n\");\n\t}\n\n\tif (rme9652->control_register & RME9652_PRO) {\n\t\tsnd_iprintf(buffer, \"IEC958 quality: Professional\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"IEC958 quality: Consumer\\n\");\n\t}\n\n\tif (rme9652->control_register & RME9652_EMP) {\n\t\tsnd_iprintf(buffer, \"IEC958 emphasis: on\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"IEC958 emphasis: off\\n\");\n\t}\n\n\tif (rme9652->control_register & RME9652_Dolby) {\n\t\tsnd_iprintf(buffer, \"IEC958 Dolby: on\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"IEC958 Dolby: off\\n\");\n\t}\n\n\ti = rme9652_spdif_sample_rate(rme9652);\n\n\tif (i < 0) {\n\t\tsnd_iprintf(buffer,\n\t\t\t    \"IEC958 sample rate: error flag set\\n\");\n\t} else if (i == 0) {\n\t\tsnd_iprintf(buffer, \"IEC958 sample rate: undetermined\\n\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"IEC958 sample rate: %d\\n\", i);\n\t}\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tsnd_iprintf(buffer, \"ADAT Sample rate: %dHz\\n\",\n\t\t    rme9652_adat_sample_rate(rme9652));\n\n\t \n\n\tx = status & RME9652_sync_0;\n\tif (status & RME9652_lock_0) {\n\t\tsnd_iprintf(buffer, \"ADAT1: %s\\n\", x ? \"Sync\" : \"Lock\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"ADAT1: No Lock\\n\");\n\t}\n\n\tx = status & RME9652_sync_1;\n\tif (status & RME9652_lock_1) {\n\t\tsnd_iprintf(buffer, \"ADAT2: %s\\n\", x ? \"Sync\" : \"Lock\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"ADAT2: No Lock\\n\");\n\t}\n\n\tx = status & RME9652_sync_2;\n\tif (status & RME9652_lock_2) {\n\t\tsnd_iprintf(buffer, \"ADAT3: %s\\n\", x ? \"Sync\" : \"Lock\");\n\t} else {\n\t\tsnd_iprintf(buffer, \"ADAT3: No Lock\\n\");\n\t}\n\n\tsnd_iprintf(buffer, \"\\n\");\n\n\tsnd_iprintf(buffer, \"Timecode signal: %s\\n\",\n\t\t    (status & RME9652_tc_valid) ? \"yes\" : \"no\");\n\n\t \n\n\tsnd_iprintf(buffer, \"Punch Status:\\n\\n\");\n\n\tfor (i = 0; i < rme9652->ss_channels; i++) {\n\t\tif (thru_bits & (1 << i)) {\n\t\t\tsnd_iprintf(buffer, \"%2d:  on \", i + 1);\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"%2d: off \", i + 1);\n\t\t}\n\n\t\tif (((i + 1) % 8) == 0) {\n\t\t\tsnd_iprintf(buffer, \"\\n\");\n\t\t}\n\t}\n\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void snd_rme9652_proc_init(struct snd_rme9652 *rme9652)\n{\n\tsnd_card_ro_proc_new(rme9652->card, \"rme9652\", rme9652,\n\t\t\t     snd_rme9652_proc_read);\n}\n\nstatic void snd_rme9652_card_free(struct snd_card *card)\n{\n\tstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) card->private_data;\n\n\tif (rme9652->irq >= 0)\n\t\trme9652_stop(rme9652);\n}\n\nstatic int snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)\n{\n\tstruct snd_dma_buffer *capture_dma, *playback_dma;\n\n\tcapture_dma = snd_hammerfall_get_buffer(rme9652->pci, RME9652_DMA_AREA_BYTES);\n\tplayback_dma = snd_hammerfall_get_buffer(rme9652->pci, RME9652_DMA_AREA_BYTES);\n\tif (!capture_dma || !playback_dma) {\n\t\tdev_err(rme9652->card->dev,\n\t\t\t\"%s: no buffers available\\n\", rme9652->card_name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trme9652->capture_dma_buf = *capture_dma;\n\trme9652->playback_dma_buf = *playback_dma;\n\n\t \n\trme9652->capture_dma_buf.addr = ALIGN(capture_dma->addr, 0x10000ul);\n\trme9652->playback_dma_buf.addr = ALIGN(playback_dma->addr, 0x10000ul);\n\n\t \n\trme9652_write(rme9652, RME9652_rec_buffer, rme9652->capture_dma_buf.addr);\n\trme9652_write(rme9652, RME9652_play_buffer, rme9652->playback_dma_buf.addr);\n\n\trme9652->capture_dma_buf.area += rme9652->capture_dma_buf.addr - capture_dma->addr;\n\trme9652->playback_dma_buf.area += rme9652->playback_dma_buf.addr - playback_dma->addr;\n\trme9652->capture_buffer = rme9652->capture_dma_buf.area;\n\trme9652->playback_buffer = rme9652->playback_dma_buf.area;\n\n\treturn 0;\n}\n\nstatic void snd_rme9652_set_defaults(struct snd_rme9652 *rme9652)\n{\n\tunsigned int k;\n\n\t \n\n\t \n\n\trme9652->control_register =\n\t    RME9652_inp_0 | rme9652_encode_latency(7);\n\n\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\n\n\trme9652_reset_hw_pointer(rme9652);\n\trme9652_compute_period_size(rme9652);\n\n\t \n\n\tfor (k = 0; k < RME9652_NCHANNELS; ++k)\n\t\trme9652_write(rme9652, RME9652_thru_base + k * 4, 0);\n\n\trme9652->thru_bits = 0;\n\trme9652->passthru = 0;\n\n\t \n\n\trme9652_set_rate(rme9652, 48000);\n}\n\nstatic irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) dev_id;\n\n\tif (!(rme9652_read(rme9652, RME9652_status_register) & RME9652_IRQ)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\trme9652_write(rme9652, RME9652_irq_clear, 0);\n\n\tif (rme9652->capture_substream) {\n\t\tsnd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\n\t}\n\n\tif (rme9652->playback_substream) {\n\t\tsnd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic snd_pcm_uframes_t snd_rme9652_hw_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\treturn rme9652_hw_pointer(rme9652);\n}\n\nstatic signed char *rme9652_channel_buffer_location(struct snd_rme9652 *rme9652,\n\t\t\t\t\t     int stream,\n\t\t\t\t\t     int channel)\n\n{\n\tint mapped_channel;\n\n\tif (snd_BUG_ON(channel < 0 || channel >= RME9652_NCHANNELS))\n\t\treturn NULL;\n        \n\tmapped_channel = rme9652->channel_map[channel];\n\tif (mapped_channel < 0)\n\t\treturn NULL;\n\t\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\treturn rme9652->capture_buffer +\n\t\t\t(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);\n\t} else {\n\t\treturn rme9652->playback_buffer +\n\t\t\t(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);\n\t}\n}\n\nstatic int snd_rme9652_playback_copy(struct snd_pcm_substream *substream,\n\t\t\t\t     int channel, unsigned long pos,\n\t\t\t\t     struct iov_iter *src, unsigned long count)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tif (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES))\n\t\treturn -EINVAL;\n\n\tchannel_buf = rme9652_channel_buffer_location (rme9652,\n\t\t\t\t\t\t       substream->pstr->stream,\n\t\t\t\t\t\t       channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tif (copy_from_iter(channel_buf + pos, count, src) != count)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_rme9652_capture_copy(struct snd_pcm_substream *substream,\n\t\t\t\t    int channel, unsigned long pos,\n\t\t\t\t    struct iov_iter *dst, unsigned long count)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tif (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES))\n\t\treturn -EINVAL;\n\n\tchannel_buf = rme9652_channel_buffer_location (rme9652,\n\t\t\t\t\t\t       substream->pstr->stream,\n\t\t\t\t\t\t       channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tif (copy_to_iter(channel_buf + pos, count, dst) != count)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_rme9652_hw_silence(struct snd_pcm_substream *substream,\n\t\t\t\t  int channel, unsigned long pos,\n\t\t\t\t  unsigned long count)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tsigned char *channel_buf;\n\n\tchannel_buf = rme9652_channel_buffer_location (rme9652,\n\t\t\t\t\t\t       substream->pstr->stream,\n\t\t\t\t\t\t       channel);\n\tif (snd_BUG_ON(!channel_buf))\n\t\treturn -EIO;\n\tmemset(channel_buf + pos, 0, count);\n\treturn 0;\n}\n\nstatic int snd_rme9652_reset(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = rme9652->capture_substream;\n\telse\n\t\tother = rme9652->playback_substream;\n\tif (rme9652->running)\n\t\truntime->status->hw_ptr = rme9652_hw_pointer(rme9652);\n\telse\n\t\truntime->status->hw_ptr = 0;\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tstruct snd_pcm_runtime *oruntime = other->runtime;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\toruntime->status->hw_ptr = runtime->status->hw_ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme9652_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tint err;\n\tpid_t this_pid;\n\tpid_t other_pid;\n\n\tspin_lock_irq(&rme9652->lock);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\trme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);\n\t\trme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= rme9652->creg_spdif_stream);\n\t\tthis_pid = rme9652->playback_pid;\n\t\tother_pid = rme9652->capture_pid;\n\t} else {\n\t\tthis_pid = rme9652->capture_pid;\n\t\tother_pid = rme9652->playback_pid;\n\t}\n\n\tif ((other_pid > 0) && (this_pid != other_pid)) {\n\n\t\t \n\n\t\tif ((int)params_rate(params) !=\n\t\t    rme9652_adat_sample_rate(rme9652)) {\n\t\t\tspin_unlock_irq(&rme9652->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (params_period_size(params) != rme9652->period_bytes / 4) {\n\t\t\tspin_unlock_irq(&rme9652->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\n\t\tspin_unlock_irq(&rme9652->lock);\n \t\treturn 0;\n\n\t} else {\n\t\tspin_unlock_irq(&rme9652->lock);\n\t}\n\n\t \n\n\terr = rme9652_set_rate(rme9652, params_rate(params));\n\tif (err < 0) {\n\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\n\t\treturn err;\n\t}\n\n\terr = rme9652_set_interrupt_interval(rme9652, params_period_size(params));\n\tif (err < 0) {\n\t\t_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_channel_info *info)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tint chn;\n\n\tif (snd_BUG_ON(info->channel >= RME9652_NCHANNELS))\n\t\treturn -EINVAL;\n\n\tchn = rme9652->channel_map[array_index_nospec(info->channel,\n\t\t\t\t\t\t      RME9652_NCHANNELS)];\n\tif (chn < 0)\n\t\treturn -EINVAL;\n\n\tinfo->offset = chn * RME9652_CHANNEL_BUFFER_BYTES;\n\tinfo->first = 0;\n\tinfo->step = 32;\n\treturn 0;\n}\n\nstatic int snd_rme9652_ioctl(struct snd_pcm_substream *substream,\n\t\t\t     unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t{\n\t\treturn snd_rme9652_reset(substream);\n\t}\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t{\n\t\tstruct snd_pcm_channel_info *info = arg;\n\t\treturn snd_rme9652_channel_info(substream, info);\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nstatic void rme9652_silence_playback(struct snd_rme9652 *rme9652)\n{\n\tmemset(rme9652->playback_buffer, 0, RME9652_DMA_AREA_BYTES);\n}\n\nstatic int snd_rme9652_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\tint running;\n\tspin_lock(&rme9652->lock);\n\trunning = rme9652->running;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\trunning |= 1 << substream->stream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trunning &= ~(1 << substream->stream);\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tspin_unlock(&rme9652->lock);\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = rme9652->capture_substream;\n\telse\n\t\tother = rme9652->playback_substream;\n\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\t\t\trunning |= 1 << s->stream;\n\t\t\t\telse\n\t\t\t\t\trunning &= ~(1 << s->stream);\n\t\t\t\tgoto _ok;\n\t\t\t}\n\t\t}\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t\tif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&\n\t\t\t    substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t\trme9652_silence_playback(rme9652);\n\t\t} else {\n\t\t\tif (running &&\n\t\t\t    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\trme9652_silence_playback(rme9652);\n\t\t}\n\t} else {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) \n\t\t\trme9652_silence_playback(rme9652);\n\t}\n _ok:\n\tsnd_pcm_trigger_done(substream, substream);\n\tif (!rme9652->running && running)\n\t\trme9652_start(rme9652);\n\telse if (rme9652->running && !running)\n\t\trme9652_stop(rme9652);\n\trme9652->running = running;\n\tspin_unlock(&rme9652->lock);\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rme9652->lock, flags);\n\tif (!rme9652->running)\n\t\trme9652_reset_hw_pointer(rme9652);\n\tspin_unlock_irqrestore(&rme9652->lock, flags);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_rme9652_playback_subinfo =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START |\n\t\t\t\t SNDRV_PCM_INFO_DOUBLE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\t(SNDRV_PCM_RATE_44100 | \n\t\t\t\t SNDRV_PCM_RATE_48000 | \n\t\t\t\t SNDRV_PCM_RATE_88200 | \n\t\t\t\t SNDRV_PCM_RATE_96000),\n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t10,\n\t.channels_max =\t\t26,\n\t.buffer_bytes_max =\tRME9652_CHANNEL_BUFFER_BYTES * 26,\n\t.period_bytes_min =\t(64 * 4) * 10,\n\t.period_bytes_max =\t(8192 * 4) * 26,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_rme9652_capture_subinfo =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\t(SNDRV_PCM_RATE_44100 | \n\t\t\t\t SNDRV_PCM_RATE_48000 | \n\t\t\t\t SNDRV_PCM_RATE_88200 | \n\t\t\t\t SNDRV_PCM_RATE_96000),\n\t.rate_min =\t\t44100,\n\t.rate_max =\t\t96000,\n\t.channels_min =\t\t10,\n\t.channels_max =\t\t26,\n\t.buffer_bytes_max =\tRME9652_CHANNEL_BUFFER_BYTES *26,\n\t.period_bytes_min =\t(64 * 4) * 10,\n\t.period_bytes_max =\t(8192 * 4) * 26,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\t2,\n\t.fifo_size =\t\t0,\n};\n\nstatic const unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {\n\t.count = ARRAY_SIZE(period_sizes),\n\t.list = period_sizes,\n\t.mask = 0\n};\n\nstatic int snd_rme9652_hw_rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_rme9652 *rme9652 = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tunsigned int list[2] = { rme9652->ds_channels, rme9652->ss_channels };\n\treturn snd_interval_list(c, 2, list, 0);\n}\n\nstatic int snd_rme9652_hw_rule_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_rme9652 *rme9652 = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (r->min > 48000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = rme9652->ds_channels,\n\t\t\t.max = rme9652->ds_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->max < 88200) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = rme9652->ss_channels,\n\t\t\t.max = rme9652->ss_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme9652_hw_rule_rate_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_rme9652 *rme9652 = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tif (c->min >= rme9652->ss_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 44100,\n\t\t\t.max = 48000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= rme9652->ds_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 88200,\n\t\t\t.max = 96000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t}\n\treturn 0;\n}\n\nstatic int snd_rme9652_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tspin_lock_irq(&rme9652->lock);\n\n\tsnd_pcm_set_sync(substream);\n\n        runtime->hw = snd_rme9652_playback_subinfo;\n\tsnd_pcm_set_runtime_buffer(substream, &rme9652->playback_dma_buf);\n\n\tif (rme9652->capture_substream == NULL) {\n\t\trme9652_stop(rme9652);\n\t\trme9652_set_thru(rme9652, -1, 0);\n\t}\n\n\trme9652->playback_pid = current->pid;\n\trme9652->playback_substream = substream;\n\n\tspin_unlock_irq(&rme9652->lock);\n\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_rme9652_hw_rule_channels, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_rme9652_hw_rule_channels_rate, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_RATE, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t     snd_rme9652_hw_rule_rate_channels, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\n\trme9652->creg_spdif_stream = rme9652->creg_spdif;\n\trme9652->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);\n\treturn 0;\n}\n\nstatic int snd_rme9652_playback_release(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&rme9652->lock);\n\n\trme9652->playback_pid = -1;\n\trme9652->playback_substream = NULL;\n\n\tspin_unlock_irq(&rme9652->lock);\n\n\trme9652->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\tsnd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t       SNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);\n\treturn 0;\n}\n\n\nstatic int snd_rme9652_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tspin_lock_irq(&rme9652->lock);\n\n\tsnd_pcm_set_sync(substream);\n\n\truntime->hw = snd_rme9652_capture_subinfo;\n\tsnd_pcm_set_runtime_buffer(substream, &rme9652->capture_dma_buf);\n\n\tif (rme9652->playback_substream == NULL) {\n\t\trme9652_stop(rme9652);\n\t\trme9652_set_thru(rme9652, -1, 0);\n\t}\n\n\trme9652->capture_pid = current->pid;\n\trme9652->capture_substream = substream;\n\n\tspin_unlock_irq(&rme9652->lock);\n\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_rme9652_hw_rule_channels, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t     snd_rme9652_hw_rule_channels_rate, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_RATE, -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t     snd_rme9652_hw_rule_rate_channels, rme9652,\n\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\treturn 0;\n}\n\nstatic int snd_rme9652_capture_release(struct snd_pcm_substream *substream)\n{\n\tstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&rme9652->lock);\n\n\trme9652->capture_pid = -1;\n\trme9652->capture_substream = NULL;\n\n\tspin_unlock_irq(&rme9652->lock);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_rme9652_playback_ops = {\n\t.open =\t\tsnd_rme9652_playback_open,\n\t.close =\tsnd_rme9652_playback_release,\n\t.ioctl =\tsnd_rme9652_ioctl,\n\t.hw_params =\tsnd_rme9652_hw_params,\n\t.prepare =\tsnd_rme9652_prepare,\n\t.trigger =\tsnd_rme9652_trigger,\n\t.pointer =\tsnd_rme9652_hw_pointer,\n\t.copy =\t\tsnd_rme9652_playback_copy,\n\t.fill_silence =\tsnd_rme9652_hw_silence,\n};\n\nstatic const struct snd_pcm_ops snd_rme9652_capture_ops = {\n\t.open =\t\tsnd_rme9652_capture_open,\n\t.close =\tsnd_rme9652_capture_release,\n\t.ioctl =\tsnd_rme9652_ioctl,\n\t.hw_params =\tsnd_rme9652_hw_params,\n\t.prepare =\tsnd_rme9652_prepare,\n\t.trigger =\tsnd_rme9652_trigger,\n\t.pointer =\tsnd_rme9652_hw_pointer,\n\t.copy =\t\tsnd_rme9652_capture_copy,\n};\n\nstatic int snd_rme9652_create_pcm(struct snd_card *card,\n\t\t\t\t  struct snd_rme9652 *rme9652)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, rme9652->card_name, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\trme9652->pcm = pcm;\n\tpcm->private_data = rme9652;\n\tstrcpy(pcm->name, rme9652->card_name);\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme9652_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme9652_capture_ops);\n\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_create(struct snd_card *card,\n\t\t\t      struct snd_rme9652 *rme9652,\n\t\t\t      int precise_ptr)\n{\n\tstruct pci_dev *pci = rme9652->pci;\n\tint err;\n\tint status;\n\tunsigned short rev;\n\n\trme9652->irq = -1;\n\trme9652->card = card;\n\n\tpci_read_config_word(rme9652->pci, PCI_CLASS_REVISION, &rev);\n\n\tswitch (rev & 0xff) {\n\tcase 3:\n\tcase 4:\n\tcase 8:\n\tcase 9:\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&rme9652->lock);\n\n\terr = pci_request_regions(pci, \"rme9652\");\n\tif (err < 0)\n\t\treturn err;\n\trme9652->port = pci_resource_start(pci, 0);\n\trme9652->iobase = devm_ioremap(&pci->dev, rme9652->port, RME9652_IO_EXTENT);\n\tif (rme9652->iobase == NULL) {\n\t\tdev_err(card->dev, \"unable to remap region 0x%lx-0x%lx\\n\",\n\t\t\trme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);\n\t\treturn -EBUSY;\n\t}\n\t\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_rme9652_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, rme9652)) {\n\t\tdev_err(card->dev, \"unable to request IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\trme9652->irq = pci->irq;\n\tcard->sync_irq = rme9652->irq;\n\trme9652->precise_ptr = precise_ptr;\n\n\t \n\n\tstatus = rme9652_read(rme9652, RME9652_status_register);\n\tif (rme9652_decode_spdif_rate(status&RME9652_F) == 1) {\n\t\trme9652->hw_rev = 15;\n\t} else {\n\t\trme9652->hw_rev = 11;\n\t}\n\n\t \n\n\tswitch (rev) {\n\tcase 8:  \n\t\tstrcpy(card->driver, \"RME9636\");\n\t\tif (rme9652->hw_rev == 15) {\n\t\t\trme9652->card_name = \"RME Digi9636 (Rev 1.5)\";\n\t\t} else {\n\t\t\trme9652->card_name = \"RME Digi9636\";\n\t\t}\n\t\trme9652->ss_channels = RME9636_NCHANNELS;\n\t\tbreak;\n\tcase 9:  \n\t\tstrcpy(card->driver, \"RME9636\");\n\t\trme9652->card_name = \"RME Digi9636 (Rev G)\";\n\t\trme9652->ss_channels = RME9636_NCHANNELS;\n\t\tbreak;\n\tcase 4:  \n\t\tstrcpy(card->driver, \"RME9652\");\n\t\trme9652->card_name = \"RME Digi9652 (Rev G)\";\n\t\trme9652->ss_channels = RME9652_NCHANNELS;\n\t\tbreak;\n\tcase 3:  \n\t\tstrcpy(card->driver, \"RME9652\");\n\t\tif (rme9652->hw_rev == 15) {\n\t\t\trme9652->card_name = \"RME Digi9652 (Rev 1.5)\";\n\t\t} else {\n\t\t\trme9652->card_name = \"RME Digi9652\";\n\t\t}\n\t\trme9652->ss_channels = RME9652_NCHANNELS;\n\t\tbreak;\n\t}\n\n\trme9652->ds_channels = (rme9652->ss_channels - 2) / 2 + 2;\n\n\tpci_set_master(rme9652->pci);\n\n\terr = snd_rme9652_initialize_memory(rme9652);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_rme9652_create_pcm(card, rme9652);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_rme9652_create_controls(card, rme9652);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_rme9652_proc_init(rme9652);\n\n\trme9652->last_spdif_sample_rate = -1;\n\trme9652->last_adat_sample_rate = -1;\n\trme9652->playback_pid = -1;\n\trme9652->capture_pid = -1;\n\trme9652->capture_substream = NULL;\n\trme9652->playback_substream = NULL;\n\n\tsnd_rme9652_set_defaults(rme9652);\n\n\tif (rme9652->hw_rev == 15) {\n\t\trme9652_initialize_spdif_receiver (rme9652);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_rme9652_probe(struct pci_dev *pci,\n\t\t\t     const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_rme9652 *rme9652;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_rme9652), &card);\n\n\tif (err < 0)\n\t\treturn err;\n\n\trme9652 = (struct snd_rme9652 *) card->private_data;\n\tcard->private_free = snd_rme9652_card_free;\n\trme9652->dev = dev;\n\trme9652->pci = pci;\n\terr = snd_rme9652_create(card, rme9652, precise_ptr[dev]);\n\tif (err)\n\t\tgoto error;\n\n\tstrcpy(card->shortname, rme9652->card_name);\n\n\tsprintf(card->longname, \"%s at 0x%lx, irq %d\",\n\t\tcard->shortname, rme9652->port, rme9652->irq);\n\terr = snd_card_register(card);\n\tif (err)\n\t\tgoto error;\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver rme9652_driver = {\n\t.name\t  = KBUILD_MODNAME,\n\t.id_table = snd_rme9652_ids,\n\t.probe\t  = snd_rme9652_probe,\n};\n\nmodule_pci_driver(rme9652_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}