{
  "module_name": "hdspm.c",
  "hash_id": "2a5f663107f5a5807f4cd8832b2e4d35042413c5c083d02bfdedadda916507cd",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/rme9652/hdspm.c",
  "human_readable_source": "\n \n\n \n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/math64.h>\n#include <linux/io.h>\n#include <linux/nospec.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/asoundef.h>\n#include <sound/rawmidi.h>\n#include <sound/hwdep.h>\n#include <sound/initval.h>\n\n#include <sound/hdspm.h>\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t   \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t   \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for RME HDSPM interface.\");\n\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for RME HDSPM interface.\");\n\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable/disable specific HDSPM soundcards.\");\n\n\nMODULE_AUTHOR\n(\n\t\"Winfried Ritsch <ritsch_AT_iem.at>, \"\n\t\"Paul Davis <paul@linuxaudiosystems.com>, \"\n\t\"Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, \"\n\t\"Remy Bruno <remy.bruno@trinnov.com>, \"\n\t\"Florian Faber <faberman@linuxproaudio.org>, \"\n\t\"Adrian Knoth <adi@drcomp.erfurt.thur.de>\"\n);\nMODULE_DESCRIPTION(\"RME HDSPM\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define HDSPM_WR_SETTINGS             0\n#define HDSPM_outputBufferAddress    32\n#define HDSPM_inputBufferAddress     36\n#define HDSPM_controlRegister\t     64\n#define HDSPM_interruptConfirmation  96\n#define HDSPM_control2Reg\t     256   \n#define HDSPM_freqReg                256   \n#define HDSPM_midiDataOut0\t     352   \n#define HDSPM_midiDataOut1\t     356\n#define HDSPM_eeprom_wr\t\t     384   \n\n \n#define HDSPM_outputEnableBase       512   \n#define HDSPM_inputEnableBase        768   \n\n \n#define HDSPM_pageAddressBufferOut       8192\n#define HDSPM_pageAddressBufferIn        (HDSPM_pageAddressBufferOut+64*16*4)\n\n#define HDSPM_MADI_mixerBase    32768\t \n\n#define HDSPM_MATRIX_MIXER_SIZE  8192\t \n\n \n#define HDSPM_statusRegister    0\n \n \n#define HDSPM_statusRegister2  192\n#define HDSPM_timecodeRegister 128\n\n \n#define HDSPM_RD_STATUS_0 0\n#define HDSPM_RD_STATUS_1 64\n#define HDSPM_RD_STATUS_2 128\n#define HDSPM_RD_STATUS_3 192\n\n#define HDSPM_RD_TCO           256\n#define HDSPM_RD_PLL_FREQ      512\n#define HDSPM_WR_TCO           128\n\n#define HDSPM_TCO1_TCO_lock\t\t\t0x00000001\n#define HDSPM_TCO1_WCK_Input_Range_LSB\t\t0x00000002\n#define HDSPM_TCO1_WCK_Input_Range_MSB\t\t0x00000004\n#define HDSPM_TCO1_LTC_Input_valid\t\t0x00000008\n#define HDSPM_TCO1_WCK_Input_valid\t\t0x00000010\n#define HDSPM_TCO1_Video_Input_Format_NTSC\t0x00000020\n#define HDSPM_TCO1_Video_Input_Format_PAL\t0x00000040\n\n#define HDSPM_TCO1_set_TC\t\t\t0x00000100\n#define HDSPM_TCO1_set_drop_frame_flag\t\t0x00000200\n#define HDSPM_TCO1_LTC_Format_LSB\t\t0x00000400\n#define HDSPM_TCO1_LTC_Format_MSB\t\t0x00000800\n\n#define HDSPM_TCO2_TC_run\t\t\t0x00010000\n#define HDSPM_TCO2_WCK_IO_ratio_LSB\t\t0x00020000\n#define HDSPM_TCO2_WCK_IO_ratio_MSB\t\t0x00040000\n#define HDSPM_TCO2_set_num_drop_frames_LSB\t0x00080000\n#define HDSPM_TCO2_set_num_drop_frames_MSB\t0x00100000\n#define HDSPM_TCO2_set_jam_sync\t\t\t0x00200000\n#define HDSPM_TCO2_set_flywheel\t\t\t0x00400000\n\n#define HDSPM_TCO2_set_01_4\t\t\t0x01000000\n#define HDSPM_TCO2_set_pull_down\t\t0x02000000\n#define HDSPM_TCO2_set_pull_up\t\t\t0x04000000\n#define HDSPM_TCO2_set_freq\t\t\t0x08000000\n#define HDSPM_TCO2_set_term_75R\t\t\t0x10000000\n#define HDSPM_TCO2_set_input_LSB\t\t0x20000000\n#define HDSPM_TCO2_set_input_MSB\t\t0x40000000\n#define HDSPM_TCO2_set_freq_from_app\t\t0x80000000\n\n\n#define HDSPM_midiDataOut0    352\n#define HDSPM_midiDataOut1    356\n#define HDSPM_midiDataOut2    368\n\n#define HDSPM_midiDataIn0     360\n#define HDSPM_midiDataIn1     364\n#define HDSPM_midiDataIn2     372\n#define HDSPM_midiDataIn3     376\n\n \n#define HDSPM_midiStatusOut0  384\n#define HDSPM_midiStatusOut1  388\n#define HDSPM_midiStatusOut2  400\n\n#define HDSPM_midiStatusIn0   392\n#define HDSPM_midiStatusIn1   396\n#define HDSPM_midiStatusIn2   404\n#define HDSPM_midiStatusIn3   408\n\n\n \n\n#define HDSPM_MADI_INPUT_PEAK\t\t4096\n#define HDSPM_MADI_PLAYBACK_PEAK\t4352\n#define HDSPM_MADI_OUTPUT_PEAK\t\t4608\n\n#define HDSPM_MADI_INPUT_RMS_L\t\t6144\n#define HDSPM_MADI_PLAYBACK_RMS_L\t6400\n#define HDSPM_MADI_OUTPUT_RMS_L\t\t6656\n\n#define HDSPM_MADI_INPUT_RMS_H\t\t7168\n#define HDSPM_MADI_PLAYBACK_RMS_H\t7424\n#define HDSPM_MADI_OUTPUT_RMS_H\t\t7680\n\n \n#define HDSPM_Start                (1<<0)  \n\n#define HDSPM_Latency0             (1<<1)  \n#define HDSPM_Latency1             (1<<2)  \n#define HDSPM_Latency2             (1<<3)  \n\n#define HDSPM_ClockModeMaster      (1<<4)  \n#define HDSPM_c0Master\t\t0x1     \n\n#define HDSPM_AudioInterruptEnable (1<<5)  \n\n#define HDSPM_Frequency0  (1<<6)   \n#define HDSPM_Frequency1  (1<<7)   \n#define HDSPM_DoubleSpeed (1<<8)   \n#define HDSPM_QuadSpeed   (1<<31)  \n\n#define HDSPM_Professional (1<<9)    \n#define HDSPM_TX_64ch     (1<<10)    \n#define HDSPM_Emphasis    (1<<10)    \n\n#define HDSPM_AutoInp     (1<<11)    \n#define HDSPM_Dolby       (1<<11)    \n\n#define HDSPM_InputSelect0 (1<<14)  \n#define HDSPM_InputSelect1 (1<<15)  \n\n#define HDSPM_SyncRef2     (1<<13)\n#define HDSPM_SyncRef3     (1<<25)\n\n#define HDSPM_SMUX         (1<<18)    \n#define HDSPM_clr_tms      (1<<19)  \n#define HDSPM_taxi_reset   (1<<20)    \n#define HDSPM_WCK48        (1<<20)    \n\n#define HDSPM_Midi0InterruptEnable 0x0400000\n#define HDSPM_Midi1InterruptEnable 0x0800000\n#define HDSPM_Midi2InterruptEnable 0x0200000\n#define HDSPM_Midi3InterruptEnable 0x4000000\n\n#define HDSPM_LineOut (1<<24)  \n#define HDSPe_FLOAT_FORMAT         0x2000000\n\n#define HDSPM_DS_DoubleWire (1<<26)  \n#define HDSPM_QS_DoubleWire (1<<27)  \n#define HDSPM_QS_QuadWire   (1<<28)  \n\n#define HDSPM_wclk_sel (1<<30)\n\n \n#define HDSPM_c0_Wck48\t\t\t\t0x20  \n#define HDSPM_c0_Input0\t\t\t\t0x1000\n#define HDSPM_c0_Input1\t\t\t\t0x2000\n#define HDSPM_c0_Spdif_Opt\t\t\t0x4000\n#define HDSPM_c0_Pro\t\t\t\t0x8000\n#define HDSPM_c0_clr_tms\t\t\t0x10000\n#define HDSPM_c0_AEB1\t\t\t\t0x20000\n#define HDSPM_c0_AEB2\t\t\t\t0x40000\n#define HDSPM_c0_LineOut\t\t\t0x80000\n#define HDSPM_c0_AD_GAIN0\t\t\t0x100000\n#define HDSPM_c0_AD_GAIN1\t\t\t0x200000\n#define HDSPM_c0_DA_GAIN0\t\t\t0x400000\n#define HDSPM_c0_DA_GAIN1\t\t\t0x800000\n#define HDSPM_c0_PH_GAIN0\t\t\t0x1000000\n#define HDSPM_c0_PH_GAIN1\t\t\t0x2000000\n#define HDSPM_c0_Sym6db\t\t\t\t0x4000000\n\n\n \n#define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)\n#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|\\\n\t\t\t      HDSPM_DoubleSpeed|HDSPM_QuadSpeed)\n#define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)\n#define HDSPM_InputOptical   0\n#define HDSPM_InputCoaxial   (HDSPM_InputSelect0)\n#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|\\\n\t\t\t      HDSPM_SyncRef2|HDSPM_SyncRef3)\n\n#define HDSPM_c0_SyncRef0      0x2\n#define HDSPM_c0_SyncRef1      0x4\n#define HDSPM_c0_SyncRef2      0x8\n#define HDSPM_c0_SyncRef3      0x10\n#define HDSPM_c0_SyncRefMask   (HDSPM_c0_SyncRef0 | HDSPM_c0_SyncRef1 |\\\n\t\t\t\tHDSPM_c0_SyncRef2 | HDSPM_c0_SyncRef3)\n\n#define HDSPM_SYNC_FROM_WORD    0\t \n#define HDSPM_SYNC_FROM_MADI    1\t \n#define HDSPM_SYNC_FROM_TCO     2\n#define HDSPM_SYNC_FROM_SYNC_IN 3\n\n#define HDSPM_Frequency32KHz    HDSPM_Frequency0\n#define HDSPM_Frequency44_1KHz  HDSPM_Frequency1\n#define HDSPM_Frequency48KHz   (HDSPM_Frequency1|HDSPM_Frequency0)\n#define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)\n#define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)\n#define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|\\\n\t\t\t\tHDSPM_Frequency0)\n#define HDSPM_Frequency128KHz   (HDSPM_QuadSpeed|HDSPM_Frequency0)\n#define HDSPM_Frequency176_4KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1)\n#define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|\\\n\t\t\t\t HDSPM_Frequency0)\n\n\n \n#define HDSPM_SYNC_CHECK_NO_LOCK 0\n#define HDSPM_SYNC_CHECK_LOCK    1\n#define HDSPM_SYNC_CHECK_SYNC\t 2\n\n \n#define HDSPM_AUTOSYNC_FROM_WORD      0\n#define HDSPM_AUTOSYNC_FROM_MADI      1\n#define HDSPM_AUTOSYNC_FROM_TCO       2\n#define HDSPM_AUTOSYNC_FROM_SYNC_IN   3\n#define HDSPM_AUTOSYNC_FROM_NONE      4\n\n \n#define HDSPM_OPTICAL 0\t\t \n#define HDSPM_COAXIAL 1\t\t \n\n#define hdspm_encode_latency(x)       (((x)<<1) & HDSPM_LatencyMask)\n#define hdspm_decode_latency(x)       ((((x) & HDSPM_LatencyMask)>>1))\n\n#define hdspm_encode_in(x) (((x)&0x3)<<14)\n#define hdspm_decode_in(x) (((x)>>14)&0x3)\n\n \n#define HDSPM_TMS             (1<<0)\n#define HDSPM_TCK             (1<<1)\n#define HDSPM_TDI             (1<<2)\n#define HDSPM_JTAG            (1<<3)\n#define HDSPM_PWDN            (1<<4)\n#define HDSPM_PROGRAM\t      (1<<5)\n#define HDSPM_CONFIG_MODE_0   (1<<6)\n#define HDSPM_CONFIG_MODE_1   (1<<7)\n \n#define HDSPM_BIGENDIAN_MODE  (1<<9)\n#define HDSPM_RD_MULTIPLE     (1<<10)\n\n     \n#define HDSPM_audioIRQPending    (1<<0)\t \n#define HDSPM_RX_64ch            (1<<1)\t \n#define HDSPM_AB_int             (1<<2)\t \n\n#define HDSPM_madiLock           (1<<3)\t \n#define HDSPM_madiSync          (1<<18)  \n\n#define HDSPM_tcoLockMadi    0x00000020  \n#define HDSPM_tcoSync    0x10000000  \n\n#define HDSPM_syncInLock 0x00010000  \n#define HDSPM_syncInSync 0x00020000  \n\n#define HDSPM_BufferPositionMask 0x000FFC0  \n\t\t\t \n\n\n\n#define HDSPM_DoubleSpeedStatus (1<<19)  \n\n#define HDSPM_madiFreq0         (1<<22)\t \n#define HDSPM_madiFreq1         (1<<23)\t \n#define HDSPM_madiFreq2         (1<<24)\t \n#define HDSPM_madiFreq3         (1<<25)\t \n\n#define HDSPM_BufferID          (1<<26)\t \n#define HDSPM_tco_detect         0x08000000\n#define HDSPM_tcoLockAes         0x20000000  \n\n#define HDSPM_s2_tco_detect      0x00000040\n#define HDSPM_s2_AEBO_D          0x00000080\n#define HDSPM_s2_AEBI_D          0x00000100\n\n\n#define HDSPM_midi0IRQPending    0x40000000\n#define HDSPM_midi1IRQPending    0x80000000\n#define HDSPM_midi2IRQPending    0x20000000\n#define HDSPM_midi2IRQPendingAES 0x00000020\n#define HDSPM_midi3IRQPending    0x00200000\n\n \n#define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|\\\n\t\t\t     HDSPM_madiFreq2|HDSPM_madiFreq3)\n#define HDSPM_madiFreq32    (HDSPM_madiFreq0)\n#define HDSPM_madiFreq44_1  (HDSPM_madiFreq1)\n#define HDSPM_madiFreq48    (HDSPM_madiFreq0|HDSPM_madiFreq1)\n#define HDSPM_madiFreq64    (HDSPM_madiFreq2)\n#define HDSPM_madiFreq88_2  (HDSPM_madiFreq0|HDSPM_madiFreq2)\n#define HDSPM_madiFreq96    (HDSPM_madiFreq1|HDSPM_madiFreq2)\n#define HDSPM_madiFreq128   (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2)\n#define HDSPM_madiFreq176_4 (HDSPM_madiFreq3)\n#define HDSPM_madiFreq192   (HDSPM_madiFreq3|HDSPM_madiFreq0)\n\n   \n\n#define HDSPM_version0 (1<<0)\t \n#define HDSPM_version1 (1<<1)\t \n#define HDSPM_version2 (1<<2)\n\n#define HDSPM_wcLock (1<<3)\t \n#define HDSPM_wcSync (1<<4)\t \n\n#define HDSPM_wc_freq0 (1<<5)\t \n#define HDSPM_wc_freq1 (1<<6)\t \n#define HDSPM_wc_freq2 (1<<7)\t \n#define HDSPM_wc_freq3 0x800\t \n\n#define HDSPM_SyncRef0 0x10000   \n#define HDSPM_SyncRef1 0x20000\n\n#define HDSPM_SelSyncRef0 (1<<8)\t \n#define HDSPM_SelSyncRef1 (1<<9)\t \n#define HDSPM_SelSyncRef2 (1<<10)\t \n\n#define HDSPM_wc_valid (HDSPM_wcLock|HDSPM_wcSync)\n\n#define HDSPM_wcFreqMask  (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2|\\\n\t\t\t    HDSPM_wc_freq3)\n#define HDSPM_wcFreq32    (HDSPM_wc_freq0)\n#define HDSPM_wcFreq44_1  (HDSPM_wc_freq1)\n#define HDSPM_wcFreq48    (HDSPM_wc_freq0|HDSPM_wc_freq1)\n#define HDSPM_wcFreq64    (HDSPM_wc_freq2)\n#define HDSPM_wcFreq88_2  (HDSPM_wc_freq0|HDSPM_wc_freq2)\n#define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)\n#define HDSPM_wcFreq128   (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2)\n#define HDSPM_wcFreq176_4 (HDSPM_wc_freq3)\n#define HDSPM_wcFreq192   (HDSPM_wc_freq0|HDSPM_wc_freq3)\n\n#define HDSPM_status1_F_0 0x0400000\n#define HDSPM_status1_F_1 0x0800000\n#define HDSPM_status1_F_2 0x1000000\n#define HDSPM_status1_F_3 0x2000000\n#define HDSPM_status1_freqMask (HDSPM_status1_F_0|HDSPM_status1_F_1|HDSPM_status1_F_2|HDSPM_status1_F_3)\n\n\n#define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\\\n\t\t\t\t    HDSPM_SelSyncRef2)\n#define HDSPM_SelSyncRef_WORD      0\n#define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)\n#define HDSPM_SelSyncRef_TCO       (HDSPM_SelSyncRef1)\n#define HDSPM_SelSyncRef_SyncIn    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1)\n#define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\\\n\t\t\t\t    HDSPM_SelSyncRef2)\n\n \n \n#define HDSPM_AES32_wcLock\t0x0200000\n#define HDSPM_AES32_wcSync\t0x0100000\n#define HDSPM_AES32_wcFreq_bit  22\n \n#define HDSPM_AES32_syncref_bit  16\n \n\n#define HDSPM_AES32_AUTOSYNC_FROM_WORD 0\n#define HDSPM_AES32_AUTOSYNC_FROM_AES1 1\n#define HDSPM_AES32_AUTOSYNC_FROM_AES2 2\n#define HDSPM_AES32_AUTOSYNC_FROM_AES3 3\n#define HDSPM_AES32_AUTOSYNC_FROM_AES4 4\n#define HDSPM_AES32_AUTOSYNC_FROM_AES5 5\n#define HDSPM_AES32_AUTOSYNC_FROM_AES6 6\n#define HDSPM_AES32_AUTOSYNC_FROM_AES7 7\n#define HDSPM_AES32_AUTOSYNC_FROM_AES8 8\n#define HDSPM_AES32_AUTOSYNC_FROM_TCO 9\n#define HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN 10\n#define HDSPM_AES32_AUTOSYNC_FROM_NONE 11\n\n \n \n#define HDSPM_LockAES   0x80\n#define HDSPM_LockAES1  0x80\n#define HDSPM_LockAES2  0x40\n#define HDSPM_LockAES3  0x20\n#define HDSPM_LockAES4  0x10\n#define HDSPM_LockAES5  0x8\n#define HDSPM_LockAES6  0x4\n#define HDSPM_LockAES7  0x2\n#define HDSPM_LockAES8  0x1\n \n\n \n#define UNITY_GAIN          32768\t \n#define MINUS_INFINITY_GAIN 0\n\n \n#define MADI_SS_CHANNELS       64\n#define MADI_DS_CHANNELS       32\n#define MADI_QS_CHANNELS       16\n\n#define RAYDAT_SS_CHANNELS     36\n#define RAYDAT_DS_CHANNELS     20\n#define RAYDAT_QS_CHANNELS     12\n\n#define AIO_IN_SS_CHANNELS        14\n#define AIO_IN_DS_CHANNELS        10\n#define AIO_IN_QS_CHANNELS        8\n#define AIO_OUT_SS_CHANNELS        16\n#define AIO_OUT_DS_CHANNELS        12\n#define AIO_OUT_QS_CHANNELS        10\n\n#define AES32_CHANNELS\t\t16\n\n \n#define HDSPM_CHANNEL_BUFFER_SAMPLES  (16*1024)\n#define HDSPM_CHANNEL_BUFFER_BYTES    (4*HDSPM_CHANNEL_BUFFER_SAMPLES)\n\n \n#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)\n#define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)\n\n#define HDSPM_RAYDAT_REV\t211\n#define HDSPM_AIO_REV\t\t212\n#define HDSPM_MADIFACE_REV\t213\n\n \n#define HDSPM_SPEED_SINGLE 0\n#define HDSPM_SPEED_DOUBLE 1\n#define HDSPM_SPEED_QUAD   2\n\n \nstatic const char * const hdspm_speed_names[] = { \"single\", \"double\", \"quad\" };\n\nstatic const char *const texts_autosync_aes_tco[] = { \"Word Clock\",\n\t\t\t\t\t  \"AES1\", \"AES2\", \"AES3\", \"AES4\",\n\t\t\t\t\t  \"AES5\", \"AES6\", \"AES7\", \"AES8\",\n\t\t\t\t\t  \"TCO\", \"Sync In\"\n};\nstatic const char *const texts_autosync_aes[] = { \"Word Clock\",\n\t\t\t\t      \"AES1\", \"AES2\", \"AES3\", \"AES4\",\n\t\t\t\t      \"AES5\", \"AES6\", \"AES7\", \"AES8\",\n\t\t\t\t      \"Sync In\"\n};\nstatic const char *const texts_autosync_madi_tco[] = { \"Word Clock\",\n\t\t\t\t\t   \"MADI\", \"TCO\", \"Sync In\" };\nstatic const char *const texts_autosync_madi[] = { \"Word Clock\",\n\t\t\t\t       \"MADI\", \"Sync In\" };\n\nstatic const char *const texts_autosync_raydat_tco[] = {\n\t\"Word Clock\",\n\t\"ADAT 1\", \"ADAT 2\", \"ADAT 3\", \"ADAT 4\",\n\t\"AES\", \"SPDIF\", \"TCO\", \"Sync In\"\n};\nstatic const char *const texts_autosync_raydat[] = {\n\t\"Word Clock\",\n\t\"ADAT 1\", \"ADAT 2\", \"ADAT 3\", \"ADAT 4\",\n\t\"AES\", \"SPDIF\", \"Sync In\"\n};\nstatic const char *const texts_autosync_aio_tco[] = {\n\t\"Word Clock\",\n\t\"ADAT\", \"AES\", \"SPDIF\", \"TCO\", \"Sync In\"\n};\nstatic const char *const texts_autosync_aio[] = { \"Word Clock\",\n\t\t\t\t      \"ADAT\", \"AES\", \"SPDIF\", \"Sync In\" };\n\nstatic const char *const texts_freq[] = {\n\t\"No Lock\",\n\t\"32 kHz\",\n\t\"44.1 kHz\",\n\t\"48 kHz\",\n\t\"64 kHz\",\n\t\"88.2 kHz\",\n\t\"96 kHz\",\n\t\"128 kHz\",\n\t\"176.4 kHz\",\n\t\"192 kHz\"\n};\n\nstatic const char * const texts_ports_madi[] = {\n\t\"MADI.1\", \"MADI.2\", \"MADI.3\", \"MADI.4\", \"MADI.5\", \"MADI.6\",\n\t\"MADI.7\", \"MADI.8\", \"MADI.9\", \"MADI.10\", \"MADI.11\", \"MADI.12\",\n\t\"MADI.13\", \"MADI.14\", \"MADI.15\", \"MADI.16\", \"MADI.17\", \"MADI.18\",\n\t\"MADI.19\", \"MADI.20\", \"MADI.21\", \"MADI.22\", \"MADI.23\", \"MADI.24\",\n\t\"MADI.25\", \"MADI.26\", \"MADI.27\", \"MADI.28\", \"MADI.29\", \"MADI.30\",\n\t\"MADI.31\", \"MADI.32\", \"MADI.33\", \"MADI.34\", \"MADI.35\", \"MADI.36\",\n\t\"MADI.37\", \"MADI.38\", \"MADI.39\", \"MADI.40\", \"MADI.41\", \"MADI.42\",\n\t\"MADI.43\", \"MADI.44\", \"MADI.45\", \"MADI.46\", \"MADI.47\", \"MADI.48\",\n\t\"MADI.49\", \"MADI.50\", \"MADI.51\", \"MADI.52\", \"MADI.53\", \"MADI.54\",\n\t\"MADI.55\", \"MADI.56\", \"MADI.57\", \"MADI.58\", \"MADI.59\", \"MADI.60\",\n\t\"MADI.61\", \"MADI.62\", \"MADI.63\", \"MADI.64\",\n};\n\n\nstatic const char * const texts_ports_raydat_ss[] = {\n\t\"ADAT1.1\", \"ADAT1.2\", \"ADAT1.3\", \"ADAT1.4\", \"ADAT1.5\", \"ADAT1.6\",\n\t\"ADAT1.7\", \"ADAT1.8\", \"ADAT2.1\", \"ADAT2.2\", \"ADAT2.3\", \"ADAT2.4\",\n\t\"ADAT2.5\", \"ADAT2.6\", \"ADAT2.7\", \"ADAT2.8\", \"ADAT3.1\", \"ADAT3.2\",\n\t\"ADAT3.3\", \"ADAT3.4\", \"ADAT3.5\", \"ADAT3.6\", \"ADAT3.7\", \"ADAT3.8\",\n\t\"ADAT4.1\", \"ADAT4.2\", \"ADAT4.3\", \"ADAT4.4\", \"ADAT4.5\", \"ADAT4.6\",\n\t\"ADAT4.7\", \"ADAT4.8\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\"\n};\n\nstatic const char * const texts_ports_raydat_ds[] = {\n\t\"ADAT1.1\", \"ADAT1.2\", \"ADAT1.3\", \"ADAT1.4\",\n\t\"ADAT2.1\", \"ADAT2.2\", \"ADAT2.3\", \"ADAT2.4\",\n\t\"ADAT3.1\", \"ADAT3.2\", \"ADAT3.3\", \"ADAT3.4\",\n\t\"ADAT4.1\", \"ADAT4.2\", \"ADAT4.3\", \"ADAT4.4\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\"\n};\n\nstatic const char * const texts_ports_raydat_qs[] = {\n\t\"ADAT1.1\", \"ADAT1.2\",\n\t\"ADAT2.1\", \"ADAT2.2\",\n\t\"ADAT3.1\", \"ADAT3.2\",\n\t\"ADAT4.1\", \"ADAT4.2\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\"\n};\n\n\nstatic const char * const texts_ports_aio_in_ss[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\", \"ADAT.5\", \"ADAT.6\",\n\t\"ADAT.7\", \"ADAT.8\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aio_out_ss[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\", \"ADAT.5\", \"ADAT.6\",\n\t\"ADAT.7\", \"ADAT.8\",\n\t\"Phone.L\", \"Phone.R\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aio_in_ds[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aio_out_ds[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\",\n\t\"Phone.L\", \"Phone.R\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aio_in_qs[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aio_out_qs[] = {\n\t\"Analogue.L\", \"Analogue.R\",\n\t\"AES.L\", \"AES.R\",\n\t\"SPDIF.L\", \"SPDIF.R\",\n\t\"ADAT.1\", \"ADAT.2\", \"ADAT.3\", \"ADAT.4\",\n\t\"Phone.L\", \"Phone.R\",\n\t\"AEB.1\", \"AEB.2\", \"AEB.3\", \"AEB.4\"\n};\n\nstatic const char * const texts_ports_aes32[] = {\n\t\"AES.1\", \"AES.2\", \"AES.3\", \"AES.4\", \"AES.5\", \"AES.6\", \"AES.7\",\n\t\"AES.8\", \"AES.9.\", \"AES.10\", \"AES.11\", \"AES.12\", \"AES.13\", \"AES.14\",\n\t\"AES.15\", \"AES.16\"\n};\n\n \n\nstatic const char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {\n\t0, 1, 2, 3, 4, 5, 6, 7,\n\t8, 9, 10, 11, 12, 13, 14, 15,\n\t16, 17, 18, 19, 20, 21, 22, 23,\n\t24, 25, 26, 27, 28, 29, 30, 31,\n\t32, 33, 34, 35, 36, 37, 38, 39,\n\t40, 41, 42, 43, 44, 45, 46, 47,\n\t48, 49, 50, 51, 52, 53, 54, 55,\n\t56, 57, 58, 59, 60, 61, 62, 63\n};\n\nstatic const char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {\n\t4, 5, 6, 7, 8, 9, 10, 11,\t \n\t12, 13, 14, 15, 16, 17, 18, 19,\t \n\t20, 21, 22, 23, 24, 25, 26, 27,\t \n\t28, 29, 30, 31, 32, 33, 34, 35,\t \n\t0, 1,\t\t\t \n\t2, 3,\t\t\t \n\t-1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic const char channel_map_raydat_ds[HDSPM_MAX_CHANNELS] = {\n\t4, 5, 6, 7,\t\t \n\t8, 9, 10, 11,\t\t \n\t12, 13, 14, 15,\t\t \n\t16, 17, 18, 19,\t\t \n\t0, 1,\t\t\t \n\t2, 3,\t\t\t \n\t-1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic const char channel_map_raydat_qs[HDSPM_MAX_CHANNELS] = {\n\t4, 5,\t\t\t \n\t6, 7,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t0, 1,\t\t\t \n\t2, 3,\t\t\t \n\t-1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic const char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 13, 14, 15, 16, 17, 18, 19,\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic const char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 13, 14, 15, 16, 17, 18, 19,\t \n\t6, 7,\t\t\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic const char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 14, 16, 18,\t\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 14, 16, 18,\t\t \n\t6, 7,\t\t\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 16,\t\t\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {\n\t0, 1,\t\t\t \n\t8, 9,\t\t\t \n\t10, 11,\t\t\t \n\t12, 16,\t\t\t \n\t6, 7,\t\t\t \n\t2, 3, 4, 5,\t\t \n\t-1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const char channel_map_aes32[HDSPM_MAX_CHANNELS] = {\n\t0, 1, 2, 3, 4, 5, 6, 7,\n\t8, 9, 10, 11, 12, 13, 14, 15,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstruct hdspm_midi {\n\tstruct hdspm *hdspm;\n\tint id;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *input;\n\tstruct snd_rawmidi_substream *output;\n\tchar istimer;\t\t \n\tstruct timer_list timer;\n\tspinlock_t lock;\n\tint pending;\n\tint dataIn;\n\tint statusIn;\n\tint dataOut;\n\tint statusOut;\n\tint ie;\n\tint irq;\n};\n\nstruct hdspm_tco {\n\tint input;  \n\tint framerate;  \n\tint wordclock;  \n\tint samplerate;  \n\tint pull;  \n\tint term;  \n};\n\nstruct hdspm {\n        spinlock_t lock;\n\t \n        struct snd_pcm_substream *capture_substream;\n        struct snd_pcm_substream *playback_substream;\n\n\tchar *card_name;\t      \n\tunsigned short firmware_rev;  \n\n\tuint8_t io_type;\n\n\tint monitor_outs;\t \n\n\tu32 control_register;\t \n\tu32 control2_register;\t \n\tu32 settings_register;   \n\n\tstruct hdspm_midi midi[4];\n\tstruct work_struct midi_work;\n\n\tsize_t period_bytes;\n\tunsigned char ss_in_channels;\n\tunsigned char ds_in_channels;\n\tunsigned char qs_in_channels;\n\tunsigned char ss_out_channels;\n\tunsigned char ds_out_channels;\n\tunsigned char qs_out_channels;\n\n\tunsigned char max_channels_in;\n\tunsigned char max_channels_out;\n\n\tconst signed char *channel_map_in;\n\tconst signed char *channel_map_out;\n\n\tconst signed char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;\n\tconst signed char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;\n\n\tconst char * const *port_names_in;\n\tconst char * const *port_names_out;\n\n\tconst char * const *port_names_in_ss;\n\tconst char * const *port_names_in_ds;\n\tconst char * const *port_names_in_qs;\n\tconst char * const *port_names_out_ss;\n\tconst char * const *port_names_out_ds;\n\tconst char * const *port_names_out_qs;\n\n\tunsigned char *playback_buffer;\t \n\tunsigned char *capture_buffer;\t \n\n\tpid_t capture_pid;\t \n\tpid_t playback_pid;\t \n\tint running;\t\t \n\n\tint last_external_sample_rate;\t \n\tint last_internal_sample_rate;\n\tint system_sample_rate;\n\n\tint dev;\t\t \n\tint irq;\n\tunsigned long port;\n\tvoid __iomem *iobase;\n\n\tint irq_count;\t\t \n\tint midiPorts;\n\n\tstruct snd_card *card;\t \n\tstruct snd_pcm *pcm;\t\t \n\tstruct snd_hwdep *hwdep;\t \n\tstruct pci_dev *pci;\t \n\n\t \n\t \n\tstruct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];\n\t \n\tstruct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];\n\t \n\tstruct hdspm_mixer *mixer;\n\n\tstruct hdspm_tco *tco;   \n\n\tconst char *const *texts_autosync;\n\tint texts_autosync_items;\n\n\tcycles_t last_interrupt;\n\n\tunsigned int serial;\n\n\tstruct hdspm_peak_rms peak_rms;\n};\n\n\nstatic const struct pci_device_id snd_hdspm_ids[] = {\n\t{\n\t .vendor = PCI_VENDOR_ID_XILINX,\n\t .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,\n\t .subvendor = PCI_ANY_ID,\n\t .subdevice = PCI_ANY_ID,\n\t .class = 0,\n\t .class_mask = 0,\n\t .driver_data = 0},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_hdspm_ids);\n\n \nstatic int snd_hdspm_create_alsa_devices(struct snd_card *card,\n\t\t\t\t\t struct hdspm *hdspm);\nstatic int snd_hdspm_create_pcm(struct snd_card *card,\n\t\t\t\tstruct hdspm *hdspm);\n\nstatic inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);\nstatic inline int hdspm_get_pll_freq(struct hdspm *hdspm);\nstatic int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);\nstatic int hdspm_autosync_ref(struct hdspm *hdspm);\nstatic int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out);\nstatic int snd_hdspm_set_defaults(struct hdspm *hdspm);\nstatic int hdspm_system_clock_mode(struct hdspm *hdspm);\nstatic void hdspm_set_channel_dma_addr(struct hdspm *hdspm,\n\t\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t\t       unsigned int reg, int channels);\n\nstatic int hdspm_aes_sync_check(struct hdspm *hdspm, int idx);\nstatic int hdspm_wc_sync_check(struct hdspm *hdspm);\nstatic int hdspm_tco_sync_check(struct hdspm *hdspm);\nstatic int hdspm_sync_in_sync_check(struct hdspm *hdspm);\n\nstatic int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index);\nstatic int hdspm_get_tco_sample_rate(struct hdspm *hdspm);\nstatic int hdspm_get_wc_sample_rate(struct hdspm *hdspm);\n\n\n\nstatic inline int HDSPM_bit2freq(int n)\n{\n\tstatic const int bit2freq_tab[] = {\n\t\t0, 32000, 44100, 48000, 64000, 88200,\n\t\t96000, 128000, 176400, 192000 };\n\tif (n < 1 || n > 9)\n\t\treturn 0;\n\treturn bit2freq_tab[n];\n}\n\nstatic bool hdspm_is_raydat_or_aio(struct hdspm *hdspm)\n{\n\treturn ((AIO == hdspm->io_type) || (RayDAT == hdspm->io_type));\n}\n\n\n \n\nstatic inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,\n\t\t\t       unsigned int val)\n{\n\twritel(val, hdspm->iobase + reg);\n}\n\nstatic inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)\n{\n\treturn readl(hdspm->iobase + reg);\n}\n\n \n\nstatic inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,\n\t\t\t\t     unsigned int in)\n{\n\tif (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)\n\t\treturn 0;\n\n\treturn hdspm->mixer->ch[chan].in[in];\n}\n\nstatic inline int hdspm_read_pb_gain(struct hdspm * hdspm, unsigned int chan,\n\t\t\t\t     unsigned int pb)\n{\n\tif (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)\n\t\treturn 0;\n\treturn hdspm->mixer->ch[chan].pb[pb];\n}\n\nstatic int hdspm_write_in_gain(struct hdspm *hdspm, unsigned int chan,\n\t\t\t\t      unsigned int in, unsigned short data)\n{\n\tif (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)\n\t\treturn -1;\n\n\thdspm_write(hdspm,\n\t\t    HDSPM_MADI_mixerBase +\n\t\t    ((in + 128 * chan) * sizeof(u32)),\n\t\t    (hdspm->mixer->ch[chan].in[in] = data & 0xFFFF));\n\treturn 0;\n}\n\nstatic int hdspm_write_pb_gain(struct hdspm *hdspm, unsigned int chan,\n\t\t\t\t      unsigned int pb, unsigned short data)\n{\n\tif (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)\n\t\treturn -1;\n\n\thdspm_write(hdspm,\n\t\t    HDSPM_MADI_mixerBase +\n\t\t    ((64 + pb + 128 * chan) * sizeof(u32)),\n\t\t    (hdspm->mixer->ch[chan].pb[pb] = data & 0xFFFF));\n\treturn 0;\n}\n\n\n \nstatic inline void snd_hdspm_enable_in(struct hdspm * hdspm, int i, int v)\n{\n\thdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);\n}\n\nstatic inline void snd_hdspm_enable_out(struct hdspm * hdspm, int i, int v)\n{\n\thdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);\n}\n\n \nstatic int snd_hdspm_use_is_exclusive(struct hdspm *hdspm)\n{\n\tunsigned long flags;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&hdspm->lock, flags);\n\tif ((hdspm->playback_pid != hdspm->capture_pid) &&\n\t    (hdspm->playback_pid >= 0) && (hdspm->capture_pid >= 0)) {\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&hdspm->lock, flags);\n\treturn ret;\n}\n\n \nstatic int hdspm_round_frequency(int rate)\n{\n\tif (rate < 38050)\n\t\treturn 32000;\n\tif (rate < 46008)\n\t\treturn 44100;\n\telse\n\t\treturn 48000;\n}\n\n \nstatic int hdspm_rate_multiplier(struct hdspm *hdspm, int rate)\n{\n\tif (rate <= 48000) {\n\t\tif (hdspm->control_register & HDSPM_QuadSpeed)\n\t\t\treturn rate * 4;\n\t\telse if (hdspm->control_register &\n\t\t\t\tHDSPM_DoubleSpeed)\n\t\t\treturn rate * 2;\n\t}\n\treturn rate;\n}\n\n \nstatic int hdspm_external_sample_rate(struct hdspm *hdspm)\n{\n\tunsigned int status, status2;\n\tint syncref, rate = 0, rate_bits;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\n\t\tsyncref = hdspm_autosync_ref(hdspm);\n\t\tswitch (syncref) {\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_WORD:\n\t\t \n\t\t\tif (hdspm_wc_sync_check(hdspm))\n\t\t\t\treturn HDSPM_bit2freq(hdspm_get_wc_sample_rate(hdspm));\n\t\t\tbreak;\n\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES1:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES2:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES3:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES4:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES5:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES6:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES7:\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_AES8:\n\t\t \n\t\t\tif (hdspm_aes_sync_check(hdspm, syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1))\n\t\t\t\treturn HDSPM_bit2freq(hdspm_get_aes_sample_rate(hdspm,\n\t\t\t\t\t\t\tsyncref - HDSPM_AES32_AUTOSYNC_FROM_AES1));\n\t\t\tbreak;\n\n\n\t\tcase HDSPM_AES32_AUTOSYNC_FROM_TCO:\n\t\t \n\t\t\tif (hdspm_tco_sync_check(hdspm))\n\t\t\t\treturn HDSPM_bit2freq(hdspm_get_tco_sample_rate(hdspm));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}  \n\t\tbreak;\n\n\tcase MADIface:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\n\t\tif (!(status & HDSPM_madiLock)) {\n\t\t\trate = 0;   \n\t\t} else {\n\t\t\tswitch (status & (HDSPM_status1_freqMask)) {\n\t\t\tcase HDSPM_status1_F_0*1:\n\t\t\t\trate = 32000; break;\n\t\t\tcase HDSPM_status1_F_0*2:\n\t\t\t\trate = 44100; break;\n\t\t\tcase HDSPM_status1_F_0*3:\n\t\t\t\trate = 48000; break;\n\t\t\tcase HDSPM_status1_F_0*4:\n\t\t\t\trate = 64000; break;\n\t\t\tcase HDSPM_status1_F_0*5:\n\t\t\t\trate = 88200; break;\n\t\t\tcase HDSPM_status1_F_0*6:\n\t\t\t\trate = 96000; break;\n\t\t\tcase HDSPM_status1_F_0*7:\n\t\t\t\trate = 128000; break;\n\t\t\tcase HDSPM_status1_F_0*8:\n\t\t\t\trate = 176400; break;\n\t\t\tcase HDSPM_status1_F_0*9:\n\t\t\t\trate = 192000; break;\n\t\t\tdefault:\n\t\t\t\trate = 0; break;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase MADI:\n\tcase AIO:\n\tcase RayDAT:\n\t\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\trate = 0;\n\n\t\t \n\t\tif ((status2 & HDSPM_wcLock) != 0 &&\n\t\t\t\t(status2 & HDSPM_SelSyncRef0) == 0) {\n\n\t\t\trate_bits = status2 & HDSPM_wcFreqMask;\n\n\n\t\t\tswitch (rate_bits) {\n\t\t\tcase HDSPM_wcFreq32:\n\t\t\t\trate = 32000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq44_1:\n\t\t\t\trate = 44100;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq48:\n\t\t\t\trate = 48000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq64:\n\t\t\t\trate = 64000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq88_2:\n\t\t\t\trate = 88200;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq96:\n\t\t\t\trate = 96000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq128:\n\t\t\t\trate = 128000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq176_4:\n\t\t\t\trate = 176400;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_wcFreq192:\n\t\t\t\trate = 192000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rate != 0 &&\n\t\t(status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)\n\t\t\treturn hdspm_rate_multiplier(hdspm, rate);\n\n\t\t \n\t\tif (status & HDSPM_madiLock) {\n\t\t\trate_bits = status & HDSPM_madiFreqMask;\n\n\t\t\tswitch (rate_bits) {\n\t\t\tcase HDSPM_madiFreq32:\n\t\t\t\trate = 32000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq44_1:\n\t\t\t\trate = 44100;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq48:\n\t\t\t\trate = 48000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq64:\n\t\t\t\trate = 64000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq88_2:\n\t\t\t\trate = 88200;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq96:\n\t\t\t\trate = 96000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq128:\n\t\t\t\trate = 128000;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq176_4:\n\t\t\t\trate = 176400;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_madiFreq192:\n\t\t\t\trate = 192000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}  \n\n\t\t \n\t\t{\n\t\t\tbool is_valid_input = 0;\n\t\t\tbool has_sync = 0;\n\n\t\t\tsyncref = hdspm_autosync_ref(hdspm);\n\t\t\tif (HDSPM_AUTOSYNC_FROM_TCO == syncref) {\n\t\t\t\tis_valid_input = 1;\n\t\t\t\thas_sync = (HDSPM_SYNC_CHECK_SYNC ==\n\t\t\t\t\thdspm_tco_sync_check(hdspm));\n\t\t\t} else if (HDSPM_AUTOSYNC_FROM_SYNC_IN == syncref) {\n\t\t\t\tis_valid_input = 1;\n\t\t\t\thas_sync = (HDSPM_SYNC_CHECK_SYNC ==\n\t\t\t\t\thdspm_sync_in_sync_check(hdspm));\n\t\t\t}\n\n\t\t\tif (is_valid_input && has_sync) {\n\t\t\t\trate = hdspm_round_frequency(\n\t\t\t\t\thdspm_get_pll_freq(hdspm));\n\t\t\t}\n\t\t}\n\n\t\trate = hdspm_rate_multiplier(hdspm, rate);\n\n\t\tbreak;\n\t}\n\n\treturn rate;\n}\n\n \nstatic int hdspm_get_latency(struct hdspm *hdspm)\n{\n\tint n;\n\n\tn = hdspm_decode_latency(hdspm->control_register);\n\n\t \n\tif ((7 == n) && (RayDAT == hdspm->io_type || AIO == hdspm->io_type))\n\t\tn = -1;\n\n\treturn 1 << (n + 6);\n}\n\n \nstatic inline void hdspm_compute_period_size(struct hdspm *hdspm)\n{\n\thdspm->period_bytes = 4 * hdspm_get_latency(hdspm);\n}\n\n\nstatic snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm *hdspm)\n{\n\tint position;\n\n\tposition = hdspm_read(hdspm, HDSPM_statusRegister);\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\tcase AIO:\n\t\tposition &= HDSPM_BufferPositionMask;\n\t\tposition /= 4;  \n\t\tbreak;\n\tdefault:\n\t\tposition = (position & HDSPM_BufferID) ?\n\t\t\t(hdspm->period_bytes / 4) : 0;\n\t}\n\n\treturn position;\n}\n\n\nstatic inline void hdspm_start_audio(struct hdspm * s)\n{\n\ts->control_register |= (HDSPM_AudioInterruptEnable | HDSPM_Start);\n\thdspm_write(s, HDSPM_controlRegister, s->control_register);\n}\n\nstatic inline void hdspm_stop_audio(struct hdspm * s)\n{\n\ts->control_register &= ~(HDSPM_Start | HDSPM_AudioInterruptEnable);\n\thdspm_write(s, HDSPM_controlRegister, s->control_register);\n}\n\n \nstatic void hdspm_silence_playback(struct hdspm *hdspm)\n{\n\tint i;\n\tint n = hdspm->period_bytes;\n\tvoid *buf = hdspm->playback_buffer;\n\n\tif (!buf)\n\t\treturn;\n\n\tfor (i = 0; i < HDSPM_MAX_CHANNELS; i++) {\n\t\tmemset(buf, 0, n);\n\t\tbuf += HDSPM_CHANNEL_BUFFER_BYTES;\n\t}\n}\n\nstatic int hdspm_set_interrupt_interval(struct hdspm *s, unsigned int frames)\n{\n\tint n;\n\n\tspin_lock_irq(&s->lock);\n\n\tif (32 == frames) {\n\t\t \n\t\tn = 7;\n\t} else {\n\t\tframes >>= 7;\n\t\tn = 0;\n\t\twhile (frames) {\n\t\t\tn++;\n\t\t\tframes >>= 1;\n\t\t}\n\t}\n\n\ts->control_register &= ~HDSPM_LatencyMask;\n\ts->control_register |= hdspm_encode_latency(n);\n\n\thdspm_write(s, HDSPM_controlRegister, s->control_register);\n\n\thdspm_compute_period_size(s);\n\n\tspin_unlock_irq(&s->lock);\n\n\treturn 0;\n}\n\nstatic u64 hdspm_calc_dds_value(struct hdspm *hdspm, u64 period)\n{\n\tu64 freq_const;\n\n\tif (period == 0)\n\t\treturn 0;\n\n\tswitch (hdspm->io_type) {\n\tcase MADI:\n\tcase AES32:\n\t\tfreq_const = 110069313433624ULL;\n\t\tbreak;\n\tcase RayDAT:\n\tcase AIO:\n\t\tfreq_const = 104857600000000ULL;\n\t\tbreak;\n\tcase MADIface:\n\t\tfreq_const = 131072000000000ULL;\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn 0;\n\t}\n\n\treturn div_u64(freq_const, period);\n}\n\n\nstatic void hdspm_set_dds_value(struct hdspm *hdspm, int rate)\n{\n\tu64 n;\n\n\tif (snd_BUG_ON(rate <= 0))\n\t\treturn;\n\n\tif (rate >= 112000)\n\t\trate /= 4;\n\telse if (rate >= 56000)\n\t\trate /= 2;\n\n\tswitch (hdspm->io_type) {\n\tcase MADIface:\n\t\tn = 131072000000000ULL;   \n\t\tbreak;\n\tcase MADI:\n\tcase AES32:\n\t\tn = 110069313433624ULL;   \n\t\tbreak;\n\tcase RayDAT:\n\tcase AIO:\n\t\tn = 104857600000000ULL;   \n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\treturn;\n\t}\n\n\tn = div_u64(n, rate);\n\t \n\tsnd_BUG_ON(n >> 32);\n\thdspm_write(hdspm, HDSPM_freqReg, (u32)n);\n}\n\n \nstatic int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)\n{\n\tint current_rate;\n\tint rate_bits;\n\tint not_set = 0;\n\tint current_speed, target_speed;\n\n\t \n\n\tif (!(hdspm->control_register & HDSPM_ClockModeMaster)) {\n\n\t\t \n\t\tif (called_internally) {\n\n\t\t\t \n\n\t\t\tdev_warn(hdspm->card->dev,\n\t\t\t\t \"Warning: device is not running as a clock master.\\n\");\n\t\t\tnot_set = 1;\n\t\t} else {\n\n\t\t\t \n\t\t\tint external_freq =\n\t\t\t    hdspm_external_sample_rate(hdspm);\n\n\t\t\tif (hdspm_autosync_ref(hdspm) ==\n\t\t\t    HDSPM_AUTOSYNC_FROM_NONE) {\n\n\t\t\t\tdev_warn(hdspm->card->dev,\n\t\t\t\t\t \"Detected no External Sync\\n\");\n\t\t\t\tnot_set = 1;\n\n\t\t\t} else if (rate != external_freq) {\n\n\t\t\t\tdev_warn(hdspm->card->dev,\n\t\t\t\t\t \"Warning: No AutoSync source for requested rate\\n\");\n\t\t\t\tnot_set = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurrent_rate = hdspm->system_sample_rate;\n\n\t \n\n\tif (current_rate <= 48000)\n\t\tcurrent_speed = HDSPM_SPEED_SINGLE;\n\telse if (current_rate <= 96000)\n\t\tcurrent_speed = HDSPM_SPEED_DOUBLE;\n\telse\n\t\tcurrent_speed = HDSPM_SPEED_QUAD;\n\n\tif (rate <= 48000)\n\t\ttarget_speed = HDSPM_SPEED_SINGLE;\n\telse if (rate <= 96000)\n\t\ttarget_speed = HDSPM_SPEED_DOUBLE;\n\telse\n\t\ttarget_speed = HDSPM_SPEED_QUAD;\n\n\tswitch (rate) {\n\tcase 32000:\n\t\trate_bits = HDSPM_Frequency32KHz;\n\t\tbreak;\n\tcase 44100:\n\t\trate_bits = HDSPM_Frequency44_1KHz;\n\t\tbreak;\n\tcase 48000:\n\t\trate_bits = HDSPM_Frequency48KHz;\n\t\tbreak;\n\tcase 64000:\n\t\trate_bits = HDSPM_Frequency64KHz;\n\t\tbreak;\n\tcase 88200:\n\t\trate_bits = HDSPM_Frequency88_2KHz;\n\t\tbreak;\n\tcase 96000:\n\t\trate_bits = HDSPM_Frequency96KHz;\n\t\tbreak;\n\tcase 128000:\n\t\trate_bits = HDSPM_Frequency128KHz;\n\t\tbreak;\n\tcase 176400:\n\t\trate_bits = HDSPM_Frequency176_4KHz;\n\t\tbreak;\n\tcase 192000:\n\t\trate_bits = HDSPM_Frequency192KHz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (current_speed != target_speed\n\t    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {\n\t\tdev_err(hdspm->card->dev,\n\t\t\t\"cannot change from %s speed to %s speed mode (capture PID = %d, playback PID = %d)\\n\",\n\t\t\thdspm_speed_names[current_speed],\n\t\t\thdspm_speed_names[target_speed],\n\t\t\thdspm->capture_pid, hdspm->playback_pid);\n\t\treturn -EBUSY;\n\t}\n\n\thdspm->control_register &= ~HDSPM_FrequencyMask;\n\thdspm->control_register |= rate_bits;\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\t \n\thdspm_set_dds_value(hdspm, rate);\n\n\tif (AES32 == hdspm->io_type && rate != current_rate)\n\t\thdspm_write(hdspm, HDSPM_eeprom_wr, 0);\n\n\thdspm->system_sample_rate = rate;\n\n\tif (rate <= 48000) {\n\t\thdspm->channel_map_in = hdspm->channel_map_in_ss;\n\t\thdspm->channel_map_out = hdspm->channel_map_out_ss;\n\t\thdspm->max_channels_in = hdspm->ss_in_channels;\n\t\thdspm->max_channels_out = hdspm->ss_out_channels;\n\t\thdspm->port_names_in = hdspm->port_names_in_ss;\n\t\thdspm->port_names_out = hdspm->port_names_out_ss;\n\t} else if (rate <= 96000) {\n\t\thdspm->channel_map_in = hdspm->channel_map_in_ds;\n\t\thdspm->channel_map_out = hdspm->channel_map_out_ds;\n\t\thdspm->max_channels_in = hdspm->ds_in_channels;\n\t\thdspm->max_channels_out = hdspm->ds_out_channels;\n\t\thdspm->port_names_in = hdspm->port_names_in_ds;\n\t\thdspm->port_names_out = hdspm->port_names_out_ds;\n\t} else {\n\t\thdspm->channel_map_in = hdspm->channel_map_in_qs;\n\t\thdspm->channel_map_out = hdspm->channel_map_out_qs;\n\t\thdspm->max_channels_in = hdspm->qs_in_channels;\n\t\thdspm->max_channels_out = hdspm->qs_out_channels;\n\t\thdspm->port_names_in = hdspm->port_names_in_qs;\n\t\thdspm->port_names_out = hdspm->port_names_out_qs;\n\t}\n\n\tif (not_set != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic void all_in_all_mixer(struct hdspm * hdspm, int sgain)\n{\n\tint i, j;\n\tunsigned int gain;\n\n\tif (sgain > UNITY_GAIN)\n\t\tgain = UNITY_GAIN;\n\telse if (sgain < 0)\n\t\tgain = 0;\n\telse\n\t\tgain = sgain;\n\n\tfor (i = 0; i < HDSPM_MIXER_CHANNELS; i++)\n\t\tfor (j = 0; j < HDSPM_MIXER_CHANNELS; j++) {\n\t\t\thdspm_write_in_gain(hdspm, i, j, gain);\n\t\t\thdspm_write_pb_gain(hdspm, i, j, gain);\n\t\t}\n}\n\n \n\nstatic inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm,\n\t\t\t\t\t\t      int id)\n{\n\t \n\treturn hdspm_read(hdspm, hdspm->midi[id].dataIn);\n}\n\nstatic inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id,\n\t\t\t\t\t      int val)\n{\n\t \n\treturn hdspm_write(hdspm, hdspm->midi[id].dataOut, val);\n}\n\nstatic inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)\n{\n\treturn hdspm_read(hdspm, hdspm->midi[id].statusIn) & 0xFF;\n}\n\nstatic inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)\n{\n\tint fifo_bytes_used;\n\n\tfifo_bytes_used = hdspm_read(hdspm, hdspm->midi[id].statusOut) & 0xFF;\n\n\tif (fifo_bytes_used < 128)\n\t\treturn  128 - fifo_bytes_used;\n\telse\n\t\treturn 0;\n}\n\nstatic void snd_hdspm_flush_midi_input(struct hdspm *hdspm, int id)\n{\n\twhile (snd_hdspm_midi_input_available (hdspm, id))\n\t\tsnd_hdspm_midi_read_byte (hdspm, id);\n}\n\nstatic int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)\n{\n\tunsigned long flags;\n\tint n_pending;\n\tint to_write;\n\tint i;\n\tunsigned char buf[128];\n\n\t \n\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tif (hmidi->output &&\n\t    !snd_rawmidi_transmit_empty (hmidi->output)) {\n\t\tn_pending = snd_hdspm_midi_output_possible (hmidi->hdspm,\n\t\t\t\t\t\t\t    hmidi->id);\n\t\tif (n_pending > 0) {\n\t\t\tif (n_pending > (int)sizeof (buf))\n\t\t\t\tn_pending = sizeof (buf);\n\n\t\t\tto_write = snd_rawmidi_transmit (hmidi->output, buf,\n\t\t\t\t\t\t\t n_pending);\n\t\t\tif (to_write > 0) {\n\t\t\t\tfor (i = 0; i < to_write; ++i)\n\t\t\t\t\tsnd_hdspm_midi_write_byte (hmidi->hdspm,\n\t\t\t\t\t\t\t\t   hmidi->id,\n\t\t\t\t\t\t\t\t   buf[i]);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n\treturn 0;\n}\n\nstatic int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)\n{\n\tunsigned char buf[128];  \n\tunsigned long flags;\n\tint n_pending;\n\tint i;\n\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tn_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id);\n\tif (n_pending > 0) {\n\t\tif (hmidi->input) {\n\t\t\tif (n_pending > (int)sizeof (buf))\n\t\t\t\tn_pending = sizeof (buf);\n\t\t\tfor (i = 0; i < n_pending; ++i)\n\t\t\t\tbuf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm,\n\t\t\t\t\t\t\t\t   hmidi->id);\n\t\t\tif (n_pending)\n\t\t\t\tsnd_rawmidi_receive (hmidi->input, buf,\n\t\t\t\t\t\t     n_pending);\n\t\t} else {\n\t\t\t \n\t\t\twhile (n_pending--)\n\t\t\t\tsnd_hdspm_midi_read_byte (hmidi->hdspm,\n\t\t\t\t\t\t\t  hmidi->id);\n\t\t}\n\t}\n\thmidi->pending = 0;\n\tspin_unlock_irqrestore(&hmidi->lock, flags);\n\n\tspin_lock_irqsave(&hmidi->hdspm->lock, flags);\n\thmidi->hdspm->control_register |= hmidi->ie;\n\thdspm_write(hmidi->hdspm, HDSPM_controlRegister,\n\t\t    hmidi->hdspm->control_register);\n\tspin_unlock_irqrestore(&hmidi->hdspm->lock, flags);\n\n\treturn snd_hdspm_midi_output_write (hmidi);\n}\n\nstatic void\nsnd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct hdspm *hdspm;\n\tstruct hdspm_midi *hmidi;\n\tunsigned long flags;\n\n\thmidi = substream->rmidi->private_data;\n\thdspm = hmidi->hdspm;\n\n\tspin_lock_irqsave (&hdspm->lock, flags);\n\tif (up) {\n\t\tif (!(hdspm->control_register & hmidi->ie)) {\n\t\t\tsnd_hdspm_flush_midi_input (hdspm, hmidi->id);\n\t\t\thdspm->control_register |= hmidi->ie;\n\t\t}\n\t} else {\n\t\thdspm->control_register &= ~hmidi->ie;\n\t}\n\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\tspin_unlock_irqrestore (&hdspm->lock, flags);\n}\n\nstatic void snd_hdspm_midi_output_timer(struct timer_list *t)\n{\n\tstruct hdspm_midi *hmidi = from_timer(hmidi, t, timer);\n\tunsigned long flags;\n\n\tsnd_hdspm_midi_output_write(hmidi);\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\n\t \n\n\tif (hmidi->istimer)\n\t\tmod_timer(&hmidi->timer, 1 + jiffies);\n\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n}\n\nstatic void\nsnd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct hdspm_midi *hmidi;\n\tunsigned long flags;\n\n\thmidi = substream->rmidi->private_data;\n\tspin_lock_irqsave (&hmidi->lock, flags);\n\tif (up) {\n\t\tif (!hmidi->istimer) {\n\t\t\ttimer_setup(&hmidi->timer,\n\t\t\t\t    snd_hdspm_midi_output_timer, 0);\n\t\t\tmod_timer(&hmidi->timer, 1 + jiffies);\n\t\t\thmidi->istimer++;\n\t\t}\n\t} else {\n\t\tif (hmidi->istimer && --hmidi->istimer <= 0)\n\t\t\tdel_timer (&hmidi->timer);\n\t}\n\tspin_unlock_irqrestore (&hmidi->lock, flags);\n\tif (up)\n\t\tsnd_hdspm_midi_output_write(hmidi);\n}\n\nstatic int snd_hdspm_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdspm_midi *hmidi;\n\n\thmidi = substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\tsnd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);\n\thmidi->input = substream;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdspm_midi *hmidi;\n\n\thmidi = substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->output = substream;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdspm_midi *hmidi;\n\n\tsnd_hdspm_midi_input_trigger (substream, 0);\n\n\thmidi = substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->input = NULL;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct hdspm_midi *hmidi;\n\n\tsnd_hdspm_midi_output_trigger (substream, 0);\n\n\thmidi = substream->rmidi->private_data;\n\tspin_lock_irq (&hmidi->lock);\n\thmidi->output = NULL;\n\tspin_unlock_irq (&hmidi->lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_rawmidi_ops snd_hdspm_midi_output =\n{\n\t.open =\t\tsnd_hdspm_midi_output_open,\n\t.close =\tsnd_hdspm_midi_output_close,\n\t.trigger =\tsnd_hdspm_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_hdspm_midi_input =\n{\n\t.open =\t\tsnd_hdspm_midi_input_open,\n\t.close =\tsnd_hdspm_midi_input_close,\n\t.trigger =\tsnd_hdspm_midi_input_trigger,\n};\n\nstatic int snd_hdspm_create_midi(struct snd_card *card,\n\t\t\t\t struct hdspm *hdspm, int id)\n{\n\tint err;\n\tchar buf[64];\n\n\thdspm->midi[id].id = id;\n\thdspm->midi[id].hdspm = hdspm;\n\tspin_lock_init (&hdspm->midi[id].lock);\n\n\tif (0 == id) {\n\t\tif (MADIface == hdspm->io_type) {\n\t\t\t \n\t\t\thdspm->midi[0].dataIn = HDSPM_midiDataIn2;\n\t\t\thdspm->midi[0].statusIn = HDSPM_midiStatusIn2;\n\t\t\thdspm->midi[0].dataOut = HDSPM_midiDataOut2;\n\t\t\thdspm->midi[0].statusOut = HDSPM_midiStatusOut2;\n\t\t\thdspm->midi[0].ie = HDSPM_Midi2InterruptEnable;\n\t\t\thdspm->midi[0].irq = HDSPM_midi2IRQPending;\n\t\t} else {\n\t\t\thdspm->midi[0].dataIn = HDSPM_midiDataIn0;\n\t\t\thdspm->midi[0].statusIn = HDSPM_midiStatusIn0;\n\t\t\thdspm->midi[0].dataOut = HDSPM_midiDataOut0;\n\t\t\thdspm->midi[0].statusOut = HDSPM_midiStatusOut0;\n\t\t\thdspm->midi[0].ie = HDSPM_Midi0InterruptEnable;\n\t\t\thdspm->midi[0].irq = HDSPM_midi0IRQPending;\n\t\t}\n\t} else if (1 == id) {\n\t\thdspm->midi[1].dataIn = HDSPM_midiDataIn1;\n\t\thdspm->midi[1].statusIn = HDSPM_midiStatusIn1;\n\t\thdspm->midi[1].dataOut = HDSPM_midiDataOut1;\n\t\thdspm->midi[1].statusOut = HDSPM_midiStatusOut1;\n\t\thdspm->midi[1].ie = HDSPM_Midi1InterruptEnable;\n\t\thdspm->midi[1].irq = HDSPM_midi1IRQPending;\n\t} else if ((2 == id) && (MADI == hdspm->io_type)) {\n\t\t \n\t\thdspm->midi[2].dataIn = HDSPM_midiDataIn2;\n\t\thdspm->midi[2].statusIn = HDSPM_midiStatusIn2;\n\t\thdspm->midi[2].dataOut = HDSPM_midiDataOut2;\n\t\thdspm->midi[2].statusOut = HDSPM_midiStatusOut2;\n\t\thdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;\n\t\thdspm->midi[2].irq = HDSPM_midi2IRQPending;\n\t} else if (2 == id) {\n\t\t \n\t\thdspm->midi[2].dataIn = HDSPM_midiDataIn2;\n\t\thdspm->midi[2].statusIn = HDSPM_midiStatusIn2;\n\t\thdspm->midi[2].dataOut = -1;\n\t\thdspm->midi[2].statusOut = -1;\n\t\thdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;\n\t\thdspm->midi[2].irq = HDSPM_midi2IRQPendingAES;\n\t} else if (3 == id) {\n\t\t \n\t\thdspm->midi[3].dataIn = HDSPM_midiDataIn3;\n\t\thdspm->midi[3].statusIn = HDSPM_midiStatusIn3;\n\t\thdspm->midi[3].dataOut = -1;\n\t\thdspm->midi[3].statusOut = -1;\n\t\thdspm->midi[3].ie = HDSPM_Midi3InterruptEnable;\n\t\thdspm->midi[3].irq = HDSPM_midi3IRQPending;\n\t}\n\n\tif ((id < 2) || ((2 == id) && ((MADI == hdspm->io_type) ||\n\t\t\t\t\t(MADIface == hdspm->io_type)))) {\n\t\tif ((id == 0) && (MADIface == hdspm->io_type)) {\n\t\t\tsnprintf(buf, sizeof(buf), \"%s MIDIoverMADI\",\n\t\t\t\t card->shortname);\n\t\t} else if ((id == 2) && (MADI == hdspm->io_type)) {\n\t\t\tsnprintf(buf, sizeof(buf), \"%s MIDIoverMADI\",\n\t\t\t\t card->shortname);\n\t\t} else {\n\t\t\tsnprintf(buf, sizeof(buf), \"%s MIDI %d\",\n\t\t\t\t card->shortname, id+1);\n\t\t}\n\t\terr = snd_rawmidi_new(card, buf, id, 1, 1,\n\t\t\t\t&hdspm->midi[id].rmidi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tsnprintf(hdspm->midi[id].rmidi->name,\n\t\t\t sizeof(hdspm->midi[id].rmidi->name),\n\t\t\t \"%s MIDI %d\", card->id, id+1);\n\t\thdspm->midi[id].rmidi->private_data = &hdspm->midi[id];\n\n\t\tsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\n\t\t\t\tSNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t&snd_hdspm_midi_output);\n\t\tsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\n\t\t\t\tSNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t&snd_hdspm_midi_input);\n\n\t\thdspm->midi[id].rmidi->info_flags |=\n\t\t\tSNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\tSNDRV_RAWMIDI_INFO_INPUT |\n\t\t\tSNDRV_RAWMIDI_INFO_DUPLEX;\n\t} else {\n\t\t \n\t\tsnprintf(buf, sizeof(buf), \"%s MTC %d\",\n\t\t\t card->shortname, id+1);\n\t\terr = snd_rawmidi_new(card, buf, id, 1, 1,\n\t\t\t\t&hdspm->midi[id].rmidi);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tsnprintf(hdspm->midi[id].rmidi->name,\n\t\t\t sizeof(hdspm->midi[id].rmidi->name),\n\t\t\t \"%s MTC %d\", card->id, id+1);\n\t\thdspm->midi[id].rmidi->private_data = &hdspm->midi[id];\n\n\t\tsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\n\t\t\t\tSNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t&snd_hdspm_midi_input);\n\n\t\thdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void hdspm_midi_work(struct work_struct *work)\n{\n\tstruct hdspm *hdspm = container_of(work, struct hdspm, midi_work);\n\tint i = 0;\n\n\twhile (i < hdspm->midiPorts) {\n\t\tif (hdspm->midi[i].pending)\n\t\t\tsnd_hdspm_midi_input_read(&hdspm->midi[i]);\n\n\t\ti++;\n\t}\n}\n\n\n \n\n \n\n\nstatic inline int hdspm_get_pll_freq(struct hdspm *hdspm)\n{\n\tunsigned int period, rate;\n\n\tperiod = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\n\trate = hdspm_calc_dds_value(hdspm, period);\n\n\treturn rate;\n}\n\n \nstatic int hdspm_get_system_sample_rate(struct hdspm *hdspm)\n{\n\tunsigned int rate;\n\n\trate = hdspm_get_pll_freq(hdspm);\n\n\tif (rate > 207000) {\n\t\t \n\t\tif (0 == hdspm_system_clock_mode(hdspm)) {\n\t\t\t \n\t\t\trate = hdspm->system_sample_rate;\n\t\t} else {\n\t\t\t \n\t\t\trate = hdspm_external_sample_rate(hdspm);\n\t\t\tif (!rate)\n\t\t\t\trate = hdspm->system_sample_rate;\n\t\t}\n\t}\n\n\treturn rate;\n}\n\n\n#define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_system_sample_rate, \\\n\t.put = snd_hdspm_put_system_sample_rate, \\\n\t.get = snd_hdspm_get_system_sample_rate \\\n}\n\nstatic int snd_hdspm_info_system_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 27000;\n\tuinfo->value.integer.max = 207000;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_get_system_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *\n\t\t\t\t\t    ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdspm_get_system_sample_rate(hdspm);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *\n\t\t\t\t\t    ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint rate = ucontrol->value.integer.value[0];\n\n\tif (rate < 27000 || rate > 207000)\n\t\treturn -EINVAL;\n\thdspm_set_dds_value(hdspm, ucontrol->value.integer.value[0]);\n\treturn 0;\n}\n\n\n \nstatic int hdspm_get_wc_sample_rate(struct hdspm *hdspm)\n{\n\tint status;\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\tcase AIO:\n\t\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\n\t\treturn (status >> 16) & 0xF;\n\tcase AES32:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\treturn (status >> HDSPM_AES32_wcFreq_bit) & 0xF;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\treturn 0;\n}\n\n\n \nstatic int hdspm_get_tco_sample_rate(struct hdspm *hdspm)\n{\n\tint status;\n\n\tif (hdspm->tco) {\n\t\tswitch (hdspm->io_type) {\n\t\tcase RayDAT:\n\t\tcase AIO:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\n\t\t\treturn (status >> 20) & 0xF;\n\t\tcase AES32:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\t\treturn (status >> 1) & 0xF;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)\n{\n\tint status;\n\n\tif (hdspm->tco) {\n\t\tswitch (hdspm->io_type) {\n\t\tcase RayDAT:\n\t\tcase AIO:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_2);\n\t\t\treturn (status >> 12) & 0xF;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index)\n{\n\tint timecode;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\ttimecode = hdspm_read(hdspm, HDSPM_timecodeRegister);\n\t\treturn (timecode >> (4*index)) & 0xF;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)\n{\n\tint status = hdspm_read(hdspm, HDSPM_RD_STATUS_2);\n\n\treturn (status >> (idx*4)) & 0xF;\n}\n\n#define ENUMERATED_CTL_INFO(info, texts) \\\n\tsnd_ctl_enum_info(info, 1, ARRAY_SIZE(texts), texts)\n\n\n \nstatic int hdspm_external_rate_to_enum(struct hdspm *hdspm)\n{\n\tint rate = hdspm_external_sample_rate(hdspm);\n\tint i, selected_rate = 0;\n\tfor (i = 1; i < 10; i++)\n\t\tif (HDSPM_bit2freq(i) == rate) {\n\t\t\tselected_rate = i;\n\t\t\tbreak;\n\t\t}\n\treturn selected_rate;\n}\n\n\n#define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n\t.info = snd_hdspm_info_autosync_sample_rate, \\\n\t.get = snd_hdspm_get_autosync_sample_rate \\\n}\n\n\nstatic int snd_hdspm_info_autosync_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tENUMERATED_CTL_INFO(uinfo, texts_freq);\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t      struct snd_ctl_elem_value *\n\t\t\t\t\t      ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:\n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_wc_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_tco_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_sync_in_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_s1_sample_rate(hdspm,\n\t\t\t\t\t\tkcontrol->private_value-1);\n\t\t}\n\t\tbreak;\n\n\tcase AIO:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_wc_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_tco_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_sync_in_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_s1_sample_rate(hdspm,\n\t\t\t\t\t\tkcontrol->private_value-1);\n\t\t}\n\t\tbreak;\n\n\tcase AES32:\n\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_wc_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_tco_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 10:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_sync_in_sample_rate(hdspm);\n\t\t\tbreak;\n\t\tcase 11:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_external_rate_to_enum(hdspm);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tucontrol->value.enumerated.item[0] =\n\t\t\t\thdspm_get_aes_sample_rate(hdspm,\n\t\t\t\t\t\tkcontrol->private_value -\n\t\t\t\t\t\tHDSPM_AES32_AUTOSYNC_FROM_AES1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MADI:\n\tcase MADIface:\n\t\tucontrol->value.enumerated.item[0] =\n\t\t\thdspm_external_rate_to_enum(hdspm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\n#define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_system_clock_mode, \\\n\t.get = snd_hdspm_get_system_clock_mode, \\\n\t.put = snd_hdspm_put_system_clock_mode, \\\n}\n\n\n \nstatic int hdspm_system_clock_mode(struct hdspm *hdspm)\n{\n\tswitch (hdspm->io_type) {\n\tcase AIO:\n\tcase RayDAT:\n\t\tif (hdspm->settings_register & HDSPM_c0Master)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (hdspm->control_register & HDSPM_ClockModeMaster)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n \nstatic void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)\n{\n\thdspm_set_toggle_setting(hdspm,\n\t\t\t(hdspm_is_raydat_or_aio(hdspm)) ?\n\t\t\tHDSPM_c0Master : HDSPM_ClockModeMaster,\n\t\t\t(0 == mode));\n}\n\n\nstatic int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"Master\", \"AutoSync\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_system_clock_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm_system_clock_mode(hdspm);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_system_clock_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val > 1)\n\t\tval = 1;\n\n\thdspm_set_system_clock_mode(hdspm, val);\n\n\treturn 0;\n}\n\n\n#define HDSPM_INTERNAL_CLOCK(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.info = snd_hdspm_info_clock_source, \\\n\t.get = snd_hdspm_get_clock_source, \\\n\t.put = snd_hdspm_put_clock_source \\\n}\n\n\nstatic int hdspm_clock_source(struct hdspm * hdspm)\n{\n\tswitch (hdspm->system_sample_rate) {\n\tcase 32000: return 0;\n\tcase 44100: return 1;\n\tcase 48000: return 2;\n\tcase 64000: return 3;\n\tcase 88200: return 4;\n\tcase 96000: return 5;\n\tcase 128000: return 6;\n\tcase 176400: return 7;\n\tcase 192000: return 8;\n\t}\n\n\treturn -1;\n}\n\nstatic int hdspm_set_clock_source(struct hdspm * hdspm, int mode)\n{\n\tint rate;\n\tswitch (mode) {\n\tcase 0:\n\t\trate = 32000; break;\n\tcase 1:\n\t\trate = 44100; break;\n\tcase 2:\n\t\trate = 48000; break;\n\tcase 3:\n\t\trate = 64000; break;\n\tcase 4:\n\t\trate = 88200; break;\n\tcase 5:\n\t\trate = 96000; break;\n\tcase 6:\n\t\trate = 128000; break;\n\tcase 7:\n\t\trate = 176400; break;\n\tcase 8:\n\t\trate = 192000; break;\n\tdefault:\n\t\trate = 48000;\n\t}\n\thdspm_set_rate(hdspm, rate, 1);\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_clock_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\treturn snd_ctl_enum_info(uinfo, 1, 9, texts_freq + 1);\n}\n\nstatic int snd_hdspm_get_clock_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm_clock_source(hdspm);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.enumerated.item[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 9)\n\t\tval = 9;\n\tspin_lock_irq(&hdspm->lock);\n\tif (val != hdspm_clock_source(hdspm))\n\t\tchange = (hdspm_set_clock_source(hdspm, val) == 0) ? 1 : 0;\n\telse\n\t\tchange = 0;\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n\n#define HDSPM_PREF_SYNC_REF(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_pref_sync_ref, \\\n\t.get = snd_hdspm_get_pref_sync_ref, \\\n\t.put = snd_hdspm_put_pref_sync_ref \\\n}\n\n\n \nstatic int hdspm_pref_sync_ref(struct hdspm * hdspm)\n{\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\tswitch (hdspm->control_register & HDSPM_SyncRefMask) {\n\t\tcase 0: return 0;   \n\t\tcase HDSPM_SyncRef0: return 1;  \n\t\tcase HDSPM_SyncRef1: return 2;  \n\t\tcase HDSPM_SyncRef1+HDSPM_SyncRef0: return 3;  \n\t\tcase HDSPM_SyncRef2: return 4;  \n\t\tcase HDSPM_SyncRef2+HDSPM_SyncRef0: return 5;  \n\t\tcase HDSPM_SyncRef2+HDSPM_SyncRef1: return 6;  \n\t\tcase HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0:\n\t\t\t\t\t\t    return 7;  \n\t\tcase HDSPM_SyncRef3: return 8;  \n\t\tcase HDSPM_SyncRef3+HDSPM_SyncRef0: return 9;  \n\t\t}\n\t\tbreak;\n\n\tcase MADI:\n\tcase MADIface:\n\t\tif (hdspm->tco) {\n\t\t\tswitch (hdspm->control_register & HDSPM_SyncRefMask) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase HDSPM_SyncRef0: return 1;   \n\t\t\tcase HDSPM_SyncRef1: return 2;   \n\t\t\tcase HDSPM_SyncRef1+HDSPM_SyncRef0:\n\t\t\t\t\t     return 3;   \n\t\t\t}\n\t\t} else {\n\t\t\tswitch (hdspm->control_register & HDSPM_SyncRefMask) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase HDSPM_SyncRef0: return 1;   \n\t\t\tcase HDSPM_SyncRef1+HDSPM_SyncRef0:\n\t\t\t\t\t     return 2;   \n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase RayDAT:\n\t\tif (hdspm->tco) {\n\t\t\tswitch ((hdspm->settings_register &\n\t\t\t\tHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase 3: return 1;   \n\t\t\tcase 4: return 2;   \n\t\t\tcase 5: return 3;   \n\t\t\tcase 6: return 4;   \n\t\t\tcase 1: return 5;   \n\t\t\tcase 2: return 6;   \n\t\t\tcase 9: return 7;   \n\t\t\tcase 10: return 8;  \n\t\t\t}\n\t\t} else {\n\t\t\tswitch ((hdspm->settings_register &\n\t\t\t\tHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase 3: return 1;   \n\t\t\tcase 4: return 2;   \n\t\t\tcase 5: return 3;   \n\t\t\tcase 6: return 4;   \n\t\t\tcase 1: return 5;   \n\t\t\tcase 2: return 6;   \n\t\t\tcase 10: return 7;  \n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase AIO:\n\t\tif (hdspm->tco) {\n\t\t\tswitch ((hdspm->settings_register &\n\t\t\t\tHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase 3: return 1;   \n\t\t\tcase 1: return 2;   \n\t\t\tcase 2: return 3;   \n\t\t\tcase 9: return 4;   \n\t\t\tcase 10: return 5;  \n\t\t\t}\n\t\t} else {\n\t\t\tswitch ((hdspm->settings_register &\n\t\t\t\tHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\n\t\t\tcase 0: return 0;   \n\t\t\tcase 3: return 1;   \n\t\t\tcase 1: return 2;   \n\t\t\tcase 2: return 3;   \n\t\t\tcase 10: return 4;  \n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n\n \nstatic int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)\n{\n\tint p = 0;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\thdspm->control_register &= ~HDSPM_SyncRefMask;\n\t\tswitch (pref) {\n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\thdspm->control_register |= HDSPM_SyncRef0;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\thdspm->control_register |= HDSPM_SyncRef1;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\thdspm->control_register |=\n\t\t\t\tHDSPM_SyncRef1+HDSPM_SyncRef0;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\thdspm->control_register |= HDSPM_SyncRef2;\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\thdspm->control_register |=\n\t\t\t\tHDSPM_SyncRef2+HDSPM_SyncRef0;\n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\thdspm->control_register |=\n\t\t\t\tHDSPM_SyncRef2+HDSPM_SyncRef1;\n\t\t\tbreak;\n\t\tcase 7:  \n\t\t\thdspm->control_register |=\n\t\t\t\tHDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;\n\t\t\tbreak;\n\t\tcase 8:  \n\t\t\thdspm->control_register |= HDSPM_SyncRef3;\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\thdspm->control_register |=\n\t\t\t\tHDSPM_SyncRef3+HDSPM_SyncRef0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\n\tcase MADI:\n\tcase MADIface:\n\t\thdspm->control_register &= ~HDSPM_SyncRefMask;\n\t\tif (hdspm->tco) {\n\t\t\tswitch (pref) {\n\t\t\tcase 0:  \n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\thdspm->control_register |= HDSPM_SyncRef0;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\thdspm->control_register |= HDSPM_SyncRef1;\n\t\t\t\tbreak;\n\t\t\tcase 3:  \n\t\t\t\thdspm->control_register |=\n\t\t\t\t\tHDSPM_SyncRef0+HDSPM_SyncRef1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pref) {\n\t\t\tcase 0:  \n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\thdspm->control_register |= HDSPM_SyncRef0;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\thdspm->control_register |=\n\t\t\t\t\tHDSPM_SyncRef0+HDSPM_SyncRef1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase RayDAT:\n\t\tif (hdspm->tco) {\n\t\t\tswitch (pref) {\n\t\t\tcase 0: p = 0; break;   \n\t\t\tcase 1: p = 3; break;   \n\t\t\tcase 2: p = 4; break;   \n\t\t\tcase 3: p = 5; break;   \n\t\t\tcase 4: p = 6; break;   \n\t\t\tcase 5: p = 1; break;   \n\t\t\tcase 6: p = 2; break;   \n\t\t\tcase 7: p = 9; break;   \n\t\t\tcase 8: p = 10; break;  \n\t\t\tdefault: return -1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pref) {\n\t\t\tcase 0: p = 0; break;   \n\t\t\tcase 1: p = 3; break;   \n\t\t\tcase 2: p = 4; break;   \n\t\t\tcase 3: p = 5; break;   \n\t\t\tcase 4: p = 6; break;   \n\t\t\tcase 5: p = 1; break;   \n\t\t\tcase 6: p = 2; break;   \n\t\t\tcase 7: p = 10; break;  \n\t\t\tdefault: return -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase AIO:\n\t\tif (hdspm->tco) {\n\t\t\tswitch (pref) {\n\t\t\tcase 0: p = 0; break;   \n\t\t\tcase 1: p = 3; break;   \n\t\t\tcase 2: p = 1; break;   \n\t\t\tcase 3: p = 2; break;   \n\t\t\tcase 4: p = 9; break;   \n\t\t\tcase 5: p = 10; break;  \n\t\t\tdefault: return -1;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pref) {\n\t\t\tcase 0: p = 0; break;   \n\t\t\tcase 1: p = 3; break;   \n\t\t\tcase 2: p = 1; break;   \n\t\t\tcase 3: p = 2; break;   \n\t\t\tcase 4: p = 10; break;  \n\t\t\tdefault: return -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\tcase AIO:\n\t\thdspm->settings_register &= ~HDSPM_c0_SyncRefMask;\n\t\thdspm->settings_register |= HDSPM_c0_SyncRef0 * p;\n\t\thdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\n\t\tbreak;\n\n\tcase MADI:\n\tcase MADIface:\n\tcase AES32:\n\t\thdspm_write(hdspm, HDSPM_controlRegister,\n\t\t\t\thdspm->control_register);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tsnd_ctl_enum_info(uinfo, 1, hdspm->texts_autosync_items, hdspm->texts_autosync);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_pref_sync_ref(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint psf = hdspm_pref_sync_ref(hdspm);\n\n\tif (psf >= 0) {\n\t\tucontrol->value.enumerated.item[0] = psf;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint val, change = 0;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\n\tval = ucontrol->value.enumerated.item[0];\n\n\tif (val < 0)\n\t\tval = 0;\n\telse if (val >= hdspm->texts_autosync_items)\n\t\tval = hdspm->texts_autosync_items-1;\n\n\tspin_lock_irq(&hdspm->lock);\n\tif (val != hdspm_pref_sync_ref(hdspm))\n\t\tchange = (0 == hdspm_set_pref_sync_ref(hdspm, val)) ? 1 : 0;\n\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n\n#define HDSPM_AUTOSYNC_REF(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ, \\\n\t.info = snd_hdspm_info_autosync_ref, \\\n\t.get = snd_hdspm_get_autosync_ref, \\\n}\n\nstatic int hdspm_autosync_ref(struct hdspm *hdspm)\n{\n\t \n\tif (AES32 == hdspm->io_type) {\n\n\t\tunsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\tunsigned int syncref = (status >> HDSPM_AES32_syncref_bit) & 0xF;\n\t\t \n\t\tif (syncref <= HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN) {\n\t\t\treturn syncref;\n\t\t}\n\t\treturn HDSPM_AES32_AUTOSYNC_FROM_NONE;\n\n\t} else if (MADI == hdspm->io_type) {\n\n\t\tunsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\t\tswitch (status2 & HDSPM_SelSyncRefMask) {\n\t\tcase HDSPM_SelSyncRef_WORD:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_WORD;\n\t\tcase HDSPM_SelSyncRef_MADI:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_MADI;\n\t\tcase HDSPM_SelSyncRef_TCO:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_TCO;\n\t\tcase HDSPM_SelSyncRef_SyncIn:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_SYNC_IN;\n\t\tcase HDSPM_SelSyncRef_NVALID:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_NONE;\n\t\tdefault:\n\t\t\treturn HDSPM_AUTOSYNC_FROM_NONE;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (AES32 == hdspm->io_type) {\n\t\tstatic const char *const texts[] = { \"WordClock\", \"AES1\", \"AES2\", \"AES3\",\n\t\t\t\"AES4\",\t\"AES5\", \"AES6\", \"AES7\", \"AES8\", \"TCO\", \"Sync In\", \"None\"};\n\n\t\tENUMERATED_CTL_INFO(uinfo, texts);\n\t} else if (MADI == hdspm->io_type) {\n\t\tstatic const char *const texts[] = {\"Word Clock\", \"MADI\", \"TCO\",\n\t\t\t\"Sync In\", \"None\" };\n\n\t\tENUMERATED_CTL_INFO(uinfo, texts);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm_autosync_ref(hdspm);\n\treturn 0;\n}\n\n\n\n#define HDSPM_TCO_VIDEO_INPUT_FORMAT(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_video_input_format, \\\n\t.get = snd_hdspm_get_tco_video_input_format, \\\n}\n\nstatic int snd_hdspm_info_tco_video_input_format(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = {\"No video\", \"NTSC\", \"PAL\"};\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_video_input_format(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 status;\n\tint ret = 0;\n\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tstatus = hdspm_read(hdspm, HDSPM_RD_TCO + 4);\n\tswitch (status & (HDSPM_TCO1_Video_Input_Format_NTSC |\n\t\t\tHDSPM_TCO1_Video_Input_Format_PAL)) {\n\tcase HDSPM_TCO1_Video_Input_Format_NTSC:\n\t\t \n\t\tret = 1;\n\t\tbreak;\n\tcase HDSPM_TCO1_Video_Input_Format_PAL:\n\t\t \n\t\tret = 2;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\t}\n\tucontrol->value.enumerated.item[0] = ret;\n\treturn 0;\n}\n\n\n\n#define HDSPM_TCO_LTC_FRAMES(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_ltc_frames, \\\n\t.get = snd_hdspm_get_tco_ltc_frames, \\\n}\n\nstatic int snd_hdspm_info_tco_ltc_frames(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = {\"No lock\", \"24 fps\", \"25 fps\", \"29.97 fps\",\n\t\t\t\t\"30 fps\"};\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int hdspm_tco_ltc_frames(struct hdspm *hdspm)\n{\n\tu32 status;\n\tint ret = 0;\n\n\tstatus = hdspm_read(hdspm, HDSPM_RD_TCO + 4);\n\tif (status & HDSPM_TCO1_LTC_Input_valid) {\n\t\tswitch (status & (HDSPM_TCO1_LTC_Format_LSB |\n\t\t\t\t\tHDSPM_TCO1_LTC_Format_MSB)) {\n\t\tcase 0:\n\t\t\t \n\t\t\tret = fps_24;\n\t\t\tbreak;\n\t\tcase HDSPM_TCO1_LTC_Format_LSB:\n\t\t\t \n\t\t\tret = fps_25;\n\t\t\tbreak;\n\t\tcase HDSPM_TCO1_LTC_Format_MSB:\n\t\t\t \n\t\t\tret = fps_2997;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tret = fps_30;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int snd_hdspm_get_tco_ltc_frames(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm_tco_ltc_frames(hdspm);\n\treturn 0;\n}\n\n#define HDSPM_TOGGLE_SETTING(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.info = snd_hdspm_info_toggle_setting, \\\n\t.get = snd_hdspm_get_toggle_setting, \\\n\t.put = snd_hdspm_put_toggle_setting \\\n}\n\nstatic int hdspm_toggle_setting(struct hdspm *hdspm, u32 regmask)\n{\n\tu32 reg;\n\n\tif (hdspm_is_raydat_or_aio(hdspm))\n\t\treg = hdspm->settings_register;\n\telse\n\t\treg = hdspm->control_register;\n\n\treturn (reg & regmask) ? 1 : 0;\n}\n\nstatic int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out)\n{\n\tu32 *reg;\n\tu32 target_reg;\n\n\tif (hdspm_is_raydat_or_aio(hdspm)) {\n\t\treg = &(hdspm->settings_register);\n\t\ttarget_reg = HDSPM_WR_SETTINGS;\n\t} else {\n\t\treg = &(hdspm->control_register);\n\t\ttarget_reg = HDSPM_controlRegister;\n\t}\n\n\tif (out)\n\t\t*reg |= regmask;\n\telse\n\t\t*reg &= ~regmask;\n\n\thdspm_write(hdspm, target_reg, *reg);\n\n\treturn 0;\n}\n\n#define snd_hdspm_info_toggle_setting\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_hdspm_get_toggle_setting(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.integer.value[0] = hdspm_toggle_setting(hdspm, regmask);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_toggle_setting(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdspm->lock);\n\tchange = (int) val != hdspm_toggle_setting(hdspm, regmask);\n\thdspm_set_toggle_setting(hdspm, regmask, val);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n#define HDSPM_INPUT_SELECT(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.info = snd_hdspm_info_input_select, \\\n\t.get = snd_hdspm_get_input_select, \\\n\t.put = snd_hdspm_put_input_select \\\n}\n\nstatic int hdspm_input_select(struct hdspm * hdspm)\n{\n\treturn (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;\n}\n\nstatic int hdspm_set_input_select(struct hdspm * hdspm, int out)\n{\n\tif (out)\n\t\thdspm->control_register |= HDSPM_InputSelect0;\n\telse\n\t\thdspm->control_register &= ~HDSPM_InputSelect0;\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"optical\", \"coaxial\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdspm->lock);\n\tchange = (int) val != hdspm_input_select(hdspm);\n\thdspm_set_input_select(hdspm, val);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n\n#define HDSPM_DS_WIRE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.info = snd_hdspm_info_ds_wire, \\\n\t.get = snd_hdspm_get_ds_wire, \\\n\t.put = snd_hdspm_put_ds_wire \\\n}\n\nstatic int hdspm_ds_wire(struct hdspm * hdspm)\n{\n\treturn (hdspm->control_register & HDSPM_DS_DoubleWire) ? 1 : 0;\n}\n\nstatic int hdspm_set_ds_wire(struct hdspm * hdspm, int ds)\n{\n\tif (ds)\n\t\thdspm->control_register |= HDSPM_DS_DoubleWire;\n\telse\n\t\thdspm->control_register &= ~HDSPM_DS_DoubleWire;\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"Single\", \"Double\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_ds_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.enumerated.item[0] = hdspm_ds_wire(hdspm);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tunsigned int val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0] & 1;\n\tspin_lock_irq(&hdspm->lock);\n\tchange = (int) val != hdspm_ds_wire(hdspm);\n\thdspm_set_ds_wire(hdspm, val);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n\n#define HDSPM_QS_WIRE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.info = snd_hdspm_info_qs_wire, \\\n\t.get = snd_hdspm_get_qs_wire, \\\n\t.put = snd_hdspm_put_qs_wire \\\n}\n\nstatic int hdspm_qs_wire(struct hdspm * hdspm)\n{\n\tif (hdspm->control_register & HDSPM_QS_DoubleWire)\n\t\treturn 1;\n\tif (hdspm->control_register & HDSPM_QS_QuadWire)\n\t\treturn 2;\n\treturn 0;\n}\n\nstatic int hdspm_set_qs_wire(struct hdspm * hdspm, int mode)\n{\n\thdspm->control_register &= ~(HDSPM_QS_DoubleWire | HDSPM_QS_QuadWire);\n\tswitch (mode) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\thdspm->control_register |= HDSPM_QS_DoubleWire;\n\t\tbreak;\n\tcase 2:\n\t\thdspm->control_register |= HDSPM_QS_QuadWire;\n\t\tbreak;\n\t}\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"Single\", \"Double\", \"Quad\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_qs_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.enumerated.item[0] = hdspm_qs_wire(hdspm);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 2)\n\t\tval = 2;\n\tspin_lock_irq(&hdspm->lock);\n\tchange = val != hdspm_qs_wire(hdspm);\n\thdspm_set_qs_wire(hdspm, val);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n#define HDSPM_CONTROL_TRISTATE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.info = snd_hdspm_info_tristate, \\\n\t.get = snd_hdspm_get_tristate, \\\n\t.put = snd_hdspm_put_tristate \\\n}\n\nstatic int hdspm_tristate(struct hdspm *hdspm, u32 regmask)\n{\n\tu32 reg = hdspm->settings_register & (regmask * 3);\n\treturn reg / regmask;\n}\n\nstatic int hdspm_set_tristate(struct hdspm *hdspm, int mode, u32 regmask)\n{\n\thdspm->settings_register &= ~(regmask * 3);\n\thdspm->settings_register |= (regmask * mode);\n\thdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_tristate(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tu32 regmask = kcontrol->private_value;\n\n\tstatic const char *const texts_spdif[] = { \"Optical\", \"Coaxial\", \"Internal\" };\n\tstatic const char *const texts_levels[] = { \"Hi Gain\", \"+4 dBu\", \"-10 dBV\" };\n\n\tswitch (regmask) {\n\tcase HDSPM_c0_Input0:\n\t\tENUMERATED_CTL_INFO(uinfo, texts_spdif);\n\t\tbreak;\n\tdefault:\n\t\tENUMERATED_CTL_INFO(uinfo, texts_levels);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tristate(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.enumerated.item[0] = hdspm_tristate(hdspm, regmask);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tristate(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tu32 regmask = kcontrol->private_value;\n\tint change;\n\tint val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 2)\n\t\tval = 2;\n\n\tspin_lock_irq(&hdspm->lock);\n\tchange = val != hdspm_tristate(hdspm, regmask);\n\thdspm_set_tristate(hdspm, val, regmask);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n#define HDSPM_MADI_SPEEDMODE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.info = snd_hdspm_info_madi_speedmode, \\\n\t.get = snd_hdspm_get_madi_speedmode, \\\n\t.put = snd_hdspm_put_madi_speedmode \\\n}\n\nstatic int hdspm_madi_speedmode(struct hdspm *hdspm)\n{\n\tif (hdspm->control_register & HDSPM_QuadSpeed)\n\t\treturn 2;\n\tif (hdspm->control_register & HDSPM_DoubleSpeed)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int hdspm_set_madi_speedmode(struct hdspm *hdspm, int mode)\n{\n\thdspm->control_register &= ~(HDSPM_DoubleSpeed | HDSPM_QuadSpeed);\n\tswitch (mode) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\thdspm->control_register |= HDSPM_DoubleSpeed;\n\t\tbreak;\n\tcase 2:\n\t\thdspm->control_register |= HDSPM_QuadSpeed;\n\t\tbreak;\n\t}\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_info_madi_speedmode(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"Single\", \"Double\", \"Quad\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_madi_speedmode(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.enumerated.item[0] = hdspm_madi_speedmode(hdspm);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_madi_speedmode(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint val;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\tval = ucontrol->value.integer.value[0];\n\tif (val < 0)\n\t\tval = 0;\n\tif (val > 2)\n\t\tval = 2;\n\tspin_lock_irq(&hdspm->lock);\n\tchange = val != hdspm_madi_speedmode(hdspm);\n\thdspm_set_madi_speedmode(hdspm, val);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n#define HDSPM_MIXER(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.device = 0, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_mixer, \\\n\t.get = snd_hdspm_get_mixer, \\\n\t.put = snd_hdspm_put_mixer \\\n}\n\nstatic int snd_hdspm_info_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 3;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 65535;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint source;\n\tint destination;\n\n\tsource = ucontrol->value.integer.value[0];\n\tif (source < 0)\n\t\tsource = 0;\n\telse if (source >= 2 * HDSPM_MAX_CHANNELS)\n\t\tsource = 2 * HDSPM_MAX_CHANNELS - 1;\n\n\tdestination = ucontrol->value.integer.value[1];\n\tif (destination < 0)\n\t\tdestination = 0;\n\telse if (destination >= HDSPM_MAX_CHANNELS)\n\t\tdestination = HDSPM_MAX_CHANNELS - 1;\n\n\tspin_lock_irq(&hdspm->lock);\n\tif (source >= HDSPM_MAX_CHANNELS)\n\t\tucontrol->value.integer.value[2] =\n\t\t    hdspm_read_pb_gain(hdspm, destination,\n\t\t\t\t       source - HDSPM_MAX_CHANNELS);\n\telse\n\t\tucontrol->value.integer.value[2] =\n\t\t    hdspm_read_in_gain(hdspm, destination, source);\n\n\tspin_unlock_irq(&hdspm->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint source;\n\tint destination;\n\tint gain;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\n\tsource = ucontrol->value.integer.value[0];\n\tdestination = ucontrol->value.integer.value[1];\n\n\tif (source < 0 || source >= 2 * HDSPM_MAX_CHANNELS)\n\t\treturn -1;\n\tif (destination < 0 || destination >= HDSPM_MAX_CHANNELS)\n\t\treturn -1;\n\n\tgain = ucontrol->value.integer.value[2];\n\n\tspin_lock_irq(&hdspm->lock);\n\n\tif (source >= HDSPM_MAX_CHANNELS)\n\t\tchange = gain != hdspm_read_pb_gain(hdspm, destination,\n\t\t\t\t\t\t    source -\n\t\t\t\t\t\t    HDSPM_MAX_CHANNELS);\n\telse\n\t\tchange = gain != hdspm_read_in_gain(hdspm, destination,\n\t\t\t\t\t\t    source);\n\n\tif (change) {\n\t\tif (source >= HDSPM_MAX_CHANNELS)\n\t\t\thdspm_write_pb_gain(hdspm, destination,\n\t\t\t\t\t    source - HDSPM_MAX_CHANNELS,\n\t\t\t\t\t    gain);\n\t\telse\n\t\t\thdspm_write_in_gain(hdspm, destination, source,\n\t\t\t\t\t    gain);\n\t}\n\tspin_unlock_irq(&hdspm->lock);\n\n\treturn change;\n}\n\n \n\n#define HDSPM_PLAYBACK_MIXER \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_playback_mixer, \\\n\t.get = snd_hdspm_get_playback_mixer, \\\n\t.put = snd_hdspm_put_playback_mixer \\\n}\n\nstatic int snd_hdspm_info_playback_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 64;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint channel;\n\n\tchannel = ucontrol->id.index - 1;\n\n\tif (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&hdspm->lock);\n\tucontrol->value.integer.value[0] =\n\t  (hdspm_read_pb_gain(hdspm, channel, channel)*64)/UNITY_GAIN;\n\tspin_unlock_irq(&hdspm->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint change;\n\tint channel;\n\tint gain;\n\n\tif (!snd_hdspm_use_is_exclusive(hdspm))\n\t\treturn -EBUSY;\n\n\tchannel = ucontrol->id.index - 1;\n\n\tif (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))\n\t\treturn -EINVAL;\n\n\tgain = ucontrol->value.integer.value[0]*UNITY_GAIN/64;\n\n\tspin_lock_irq(&hdspm->lock);\n\tchange =\n\t    gain != hdspm_read_pb_gain(hdspm, channel,\n\t\t\t\t       channel);\n\tif (change)\n\t\thdspm_write_pb_gain(hdspm, channel, channel,\n\t\t\t\t    gain);\n\tspin_unlock_irq(&hdspm->lock);\n\treturn change;\n}\n\n#define HDSPM_SYNC_CHECK(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_sync_check, \\\n\t.get = snd_hdspm_get_sync_check \\\n}\n\n#define HDSPM_TCO_LOCK_CHECK(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.private_value = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_tco_info_lock_check, \\\n\t.get = snd_hdspm_get_sync_check \\\n}\n\n\n\nstatic int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"No Lock\", \"Lock\", \"Sync\", \"N/A\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_tco_info_lock_check(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"No Lock\", \"Lock\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int hdspm_wc_sync_check(struct hdspm *hdspm)\n{\n\tint status, status2;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\tif (status & HDSPM_AES32_wcLock) {\n\t\t\tif (status & HDSPM_AES32_wcSync)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase MADI:\n\t\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\t\tif (status2 & HDSPM_wcLock) {\n\t\t\tif (status2 & HDSPM_wcSync)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase RayDAT:\n\tcase AIO:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\n\t\tif (status & 0x2000000)\n\t\t\treturn 2;\n\t\telse if (status & 0x1000000)\n\t\t\treturn 1;\n\t\treturn 0;\n\n\tcase MADIface:\n\t\tbreak;\n\t}\n\n\n\treturn 3;\n}\n\n\nstatic int hdspm_madi_sync_check(struct hdspm *hdspm)\n{\n\tint status = hdspm_read(hdspm, HDSPM_statusRegister);\n\tif (status & HDSPM_madiLock) {\n\t\tif (status & HDSPM_madiSync)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int hdspm_s1_sync_check(struct hdspm *hdspm, int idx)\n{\n\tint status, lock, sync;\n\n\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\n\n\tlock = (status & (0x1<<idx)) ? 1 : 0;\n\tsync = (status & (0x100<<idx)) ? 1 : 0;\n\n\tif (lock && sync)\n\t\treturn 2;\n\telse if (lock)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic int hdspm_sync_in_sync_check(struct hdspm *hdspm)\n{\n\tint status, lock = 0, sync = 0;\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\tcase AIO:\n\t\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_3);\n\t\tlock = (status & 0x400) ? 1 : 0;\n\t\tsync = (status & 0x800) ? 1 : 0;\n\t\tbreak;\n\n\tcase MADI:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\tlock = (status & HDSPM_syncInLock) ? 1 : 0;\n\t\tsync = (status & HDSPM_syncInSync) ? 1 : 0;\n\t\tbreak;\n\n\tcase AES32:\n\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister2);\n\t\tlock = (status & 0x100000) ? 1 : 0;\n\t\tsync = (status & 0x200000) ? 1 : 0;\n\t\tbreak;\n\n\tcase MADIface:\n\t\tbreak;\n\t}\n\n\tif (lock && sync)\n\t\treturn 2;\n\telse if (lock)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int hdspm_aes_sync_check(struct hdspm *hdspm, int idx)\n{\n\tint status2, lock, sync;\n\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\n\tlock = (status2 & (0x0080 >> idx)) ? 1 : 0;\n\tsync = (status2 & (0x8000 >> idx)) ? 1 : 0;\n\n\tif (sync)\n\t\treturn 2;\n\telse if (lock)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int hdspm_tco_input_check(struct hdspm *hdspm, u32 mask)\n{\n\tu32 status;\n\tstatus = hdspm_read(hdspm, HDSPM_RD_TCO + 4);\n\n\treturn (status & mask) ? 1 : 0;\n}\n\n\nstatic int hdspm_tco_sync_check(struct hdspm *hdspm)\n{\n\tint status;\n\n\tif (hdspm->tco) {\n\t\tswitch (hdspm->io_type) {\n\t\tcase MADI:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\t\tif (status & HDSPM_tcoLockMadi) {\n\t\t\t\tif (status & HDSPM_tcoSync)\n\t\t\t\t\treturn 2;\n\t\t\t\telse\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase AES32:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\t\t\tif (status & HDSPM_tcoLockAes) {\n\t\t\t\tif (status & HDSPM_tcoSync)\n\t\t\t\t\treturn 2;\n\t\t\t\telse\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase RayDAT:\n\t\tcase AIO:\n\t\t\tstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\n\n\t\t\tif (status & 0x8000000)\n\t\t\t\treturn 2;  \n\t\t\tif (status & 0x4000000)\n\t\t\t\treturn 1;  \n\t\t\treturn 0;  \n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 3;  \n}\n\n\nstatic int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\tint val = -1;\n\n\tswitch (hdspm->io_type) {\n\tcase RayDAT:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tval = hdspm_wc_sync_check(hdspm); break;\n\t\tcase 7:  \n\t\t\tval = hdspm_tco_sync_check(hdspm); break;\n\t\tcase 8:  \n\t\t\tval = hdspm_sync_in_sync_check(hdspm); break;\n\t\tdefault:\n\t\t\tval = hdspm_s1_sync_check(hdspm,\n\t\t\t\t\tkcontrol->private_value-1);\n\t\t}\n\t\tbreak;\n\n\tcase AIO:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tval = hdspm_wc_sync_check(hdspm); break;\n\t\tcase 4:  \n\t\t\tval = hdspm_tco_sync_check(hdspm); break;\n\t\tcase 5:  \n\t\t\tval = hdspm_sync_in_sync_check(hdspm); break;\n\t\tdefault:\n\t\t\tval = hdspm_s1_sync_check(hdspm,\n\t\t\t\t\tkcontrol->private_value-1);\n\t\t}\n\t\tbreak;\n\n\tcase MADI:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tval = hdspm_wc_sync_check(hdspm); break;\n\t\tcase 1:  \n\t\t\tval = hdspm_madi_sync_check(hdspm); break;\n\t\tcase 2:  \n\t\t\tval = hdspm_tco_sync_check(hdspm); break;\n\t\tcase 3:  \n\t\t\tval = hdspm_sync_in_sync_check(hdspm); break;\n\t\t}\n\t\tbreak;\n\n\tcase MADIface:\n\t\tval = hdspm_madi_sync_check(hdspm);  \n\t\tbreak;\n\n\tcase AES32:\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 0:  \n\t\t\tval = hdspm_wc_sync_check(hdspm); break;\n\t\tcase 9:  \n\t\t\tval = hdspm_tco_sync_check(hdspm); break;\n\t\tcase 10  :\n\t\t\tval = hdspm_sync_in_sync_check(hdspm); break;\n\t\tdefault:  \n\t\t\t val = hdspm_aes_sync_check(hdspm,\n\t\t\t\t\t kcontrol->private_value-1);\n\t\t}\n\t\tbreak;\n\n\t}\n\n\tif (hdspm->tco) {\n\t\tswitch (kcontrol->private_value) {\n\t\tcase 11:\n\t\t\t \n\t\t\tval = hdspm_tco_input_check(hdspm, HDSPM_TCO1_TCO_lock);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\t \n\t\t\tval = hdspm_tco_input_check(hdspm,\n\t\t\t\tHDSPM_TCO1_LTC_Input_valid);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (-1 == val)\n\t\tval = 3;\n\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\n\n\n \nstatic void hdspm_tco_write(struct hdspm *hdspm)\n{\n\tunsigned int tc[4] = { 0, 0, 0, 0};\n\n\tswitch (hdspm->tco->input) {\n\tcase 0:\n\t\ttc[2] |= HDSPM_TCO2_set_input_MSB;\n\t\tbreak;\n\tcase 1:\n\t\ttc[2] |= HDSPM_TCO2_set_input_LSB;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (hdspm->tco->framerate) {\n\tcase 1:\n\t\ttc[1] |= HDSPM_TCO1_LTC_Format_LSB;\n\t\tbreak;\n\tcase 2:\n\t\ttc[1] |= HDSPM_TCO1_LTC_Format_MSB;\n\t\tbreak;\n\tcase 3:\n\t\ttc[1] |= HDSPM_TCO1_LTC_Format_MSB +\n\t\t\tHDSPM_TCO1_set_drop_frame_flag;\n\t\tbreak;\n\tcase 4:\n\t\ttc[1] |= HDSPM_TCO1_LTC_Format_LSB +\n\t\t\tHDSPM_TCO1_LTC_Format_MSB;\n\t\tbreak;\n\tcase 5:\n\t\ttc[1] |= HDSPM_TCO1_LTC_Format_LSB +\n\t\t\tHDSPM_TCO1_LTC_Format_MSB +\n\t\t\tHDSPM_TCO1_set_drop_frame_flag;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (hdspm->tco->wordclock) {\n\tcase 1:\n\t\ttc[2] |= HDSPM_TCO2_WCK_IO_ratio_LSB;\n\t\tbreak;\n\tcase 2:\n\t\ttc[2] |= HDSPM_TCO2_WCK_IO_ratio_MSB;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (hdspm->tco->samplerate) {\n\tcase 1:\n\t\ttc[2] |= HDSPM_TCO2_set_freq;\n\t\tbreak;\n\tcase 2:\n\t\ttc[2] |= HDSPM_TCO2_set_freq_from_app;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (hdspm->tco->pull) {\n\tcase 1:\n\t\ttc[2] |= HDSPM_TCO2_set_pull_up;\n\t\tbreak;\n\tcase 2:\n\t\ttc[2] |= HDSPM_TCO2_set_pull_down;\n\t\tbreak;\n\tcase 3:\n\t\ttc[2] |= HDSPM_TCO2_set_pull_up + HDSPM_TCO2_set_01_4;\n\t\tbreak;\n\tcase 4:\n\t\ttc[2] |= HDSPM_TCO2_set_pull_down + HDSPM_TCO2_set_01_4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (1 == hdspm->tco->term) {\n\t\ttc[2] |= HDSPM_TCO2_set_term_75R;\n\t}\n\n\thdspm_write(hdspm, HDSPM_WR_TCO, tc[0]);\n\thdspm_write(hdspm, HDSPM_WR_TCO+4, tc[1]);\n\thdspm_write(hdspm, HDSPM_WR_TCO+8, tc[2]);\n\thdspm_write(hdspm, HDSPM_WR_TCO+12, tc[3]);\n}\n\n\n#define HDSPM_TCO_SAMPLE_RATE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_sample_rate, \\\n\t.get = snd_hdspm_get_tco_sample_rate, \\\n\t.put = snd_hdspm_put_tco_sample_rate \\\n}\n\nstatic int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\t \n\tstatic const char *const texts[] = { \"44.1 kHz\", \"48 kHz\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm->tco->samplerate;\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tco_sample_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->samplerate != ucontrol->value.enumerated.item[0]) {\n\t\thdspm->tco->samplerate = ucontrol->value.enumerated.item[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n#define HDSPM_TCO_PULL(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_pull, \\\n\t.get = snd_hdspm_get_tco_pull, \\\n\t.put = snd_hdspm_put_tco_pull \\\n}\n\nstatic int snd_hdspm_info_tco_pull(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"0\", \"+ 0.1 %\", \"- 0.1 %\",\n\t\t\"+ 4 %\", \"- 4 %\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_pull(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm->tco->pull;\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tco_pull(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->pull != ucontrol->value.enumerated.item[0]) {\n\t\thdspm->tco->pull = ucontrol->value.enumerated.item[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#define HDSPM_TCO_WCK_CONVERSION(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_wck_conversion, \\\n\t.get = snd_hdspm_get_tco_wck_conversion, \\\n\t.put = snd_hdspm_put_tco_wck_conversion \\\n}\n\nstatic int snd_hdspm_info_tco_wck_conversion(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"1:1\", \"44.1 -> 48\", \"48 -> 44.1\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_wck_conversion(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm->tco->wordclock;\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tco_wck_conversion(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->wordclock != ucontrol->value.enumerated.item[0]) {\n\t\thdspm->tco->wordclock = ucontrol->value.enumerated.item[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n#define HDSPM_TCO_FRAME_RATE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_frame_rate, \\\n\t.get = snd_hdspm_get_tco_frame_rate, \\\n\t.put = snd_hdspm_put_tco_frame_rate \\\n}\n\nstatic int snd_hdspm_info_tco_frame_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"24 fps\", \"25 fps\", \"29.97fps\",\n\t\t\"29.97 dfps\", \"30 fps\", \"30 dfps\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_frame_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm->tco->framerate;\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tco_frame_rate(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->framerate != ucontrol->value.enumerated.item[0]) {\n\t\thdspm->tco->framerate = ucontrol->value.enumerated.item[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n#define HDSPM_TCO_SYNC_SOURCE(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_sync_source, \\\n\t.get = snd_hdspm_get_tco_sync_source, \\\n\t.put = snd_hdspm_put_tco_sync_source \\\n}\n\nstatic int snd_hdspm_info_tco_sync_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char *const texts[] = { \"LTC\", \"Video\", \"WCK\" };\n\tENUMERATED_CTL_INFO(uinfo, texts);\n\treturn 0;\n}\n\nstatic int snd_hdspm_get_tco_sync_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = hdspm->tco->input;\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_put_tco_sync_source(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->input != ucontrol->value.enumerated.item[0]) {\n\t\thdspm->tco->input = ucontrol->value.enumerated.item[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n#define HDSPM_TCO_WORD_TERM(xname, xindex) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.index = xindex, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\\\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE, \\\n\t.info = snd_hdspm_info_tco_word_term, \\\n\t.get = snd_hdspm_get_tco_word_term, \\\n\t.put = snd_hdspm_put_tco_word_term \\\n}\n\nstatic int snd_hdspm_info_tco_word_term(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_get_tco_word_term(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = hdspm->tco->term;\n\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\n\n\tif (hdspm->tco->term != ucontrol->value.integer.value[0]) {\n\t\thdspm->tco->term = ucontrol->value.integer.value[0];\n\n\t\thdspm_tco_write(hdspm);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n\n\nstatic const struct snd_kcontrol_new snd_hdspm_controls_madi[] = {\n\tHDSPM_MIXER(\"Mixer\", 0),\n\tHDSPM_INTERNAL_CLOCK(\"Internal Clock\", 0),\n\tHDSPM_SYSTEM_CLOCK_MODE(\"System Clock Mode\", 0),\n\tHDSPM_PREF_SYNC_REF(\"Preferred Sync Reference\", 0),\n\tHDSPM_AUTOSYNC_REF(\"AutoSync Reference\", 0),\n\tHDSPM_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"External Rate\", 0),\n\tHDSPM_SYNC_CHECK(\"WC SyncCheck\", 0),\n\tHDSPM_SYNC_CHECK(\"MADI SyncCheck\", 1),\n\tHDSPM_SYNC_CHECK(\"TCO SyncCheck\", 2),\n\tHDSPM_SYNC_CHECK(\"SYNC IN SyncCheck\", 3),\n\tHDSPM_TOGGLE_SETTING(\"Line Out\", HDSPM_LineOut),\n\tHDSPM_TOGGLE_SETTING(\"TX 64 channels mode\", HDSPM_TX_64ch),\n\tHDSPM_TOGGLE_SETTING(\"Disable 96K frames\", HDSPM_SMUX),\n\tHDSPM_TOGGLE_SETTING(\"Clear Track Marker\", HDSPM_clr_tms),\n\tHDSPM_TOGGLE_SETTING(\"Safe Mode\", HDSPM_AutoInp),\n\tHDSPM_INPUT_SELECT(\"Input Select\", 0),\n\tHDSPM_MADI_SPEEDMODE(\"MADI Speed Mode\", 0)\n};\n\n\nstatic const struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {\n\tHDSPM_MIXER(\"Mixer\", 0),\n\tHDSPM_INTERNAL_CLOCK(\"Internal Clock\", 0),\n\tHDSPM_SYSTEM_CLOCK_MODE(\"System Clock Mode\", 0),\n\tHDSPM_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"External Rate\", 0),\n\tHDSPM_SYNC_CHECK(\"MADI SyncCheck\", 0),\n\tHDSPM_TOGGLE_SETTING(\"TX 64 channels mode\", HDSPM_TX_64ch),\n\tHDSPM_TOGGLE_SETTING(\"Clear Track Marker\", HDSPM_clr_tms),\n\tHDSPM_TOGGLE_SETTING(\"Safe Mode\", HDSPM_AutoInp),\n\tHDSPM_MADI_SPEEDMODE(\"MADI Speed Mode\", 0)\n};\n\nstatic const struct snd_kcontrol_new snd_hdspm_controls_aio[] = {\n\tHDSPM_MIXER(\"Mixer\", 0),\n\tHDSPM_INTERNAL_CLOCK(\"Internal Clock\", 0),\n\tHDSPM_SYSTEM_CLOCK_MODE(\"System Clock Mode\", 0),\n\tHDSPM_PREF_SYNC_REF(\"Preferred Sync Reference\", 0),\n\tHDSPM_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"External Rate\", 0),\n\tHDSPM_SYNC_CHECK(\"WC SyncCheck\", 0),\n\tHDSPM_SYNC_CHECK(\"AES SyncCheck\", 1),\n\tHDSPM_SYNC_CHECK(\"SPDIF SyncCheck\", 2),\n\tHDSPM_SYNC_CHECK(\"ADAT SyncCheck\", 3),\n\tHDSPM_SYNC_CHECK(\"TCO SyncCheck\", 4),\n\tHDSPM_SYNC_CHECK(\"SYNC IN SyncCheck\", 5),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"WC Frequency\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES Frequency\", 1),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"SPDIF Frequency\", 2),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"ADAT Frequency\", 3),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"TCO Frequency\", 4),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"SYNC IN Frequency\", 5),\n\tHDSPM_CONTROL_TRISTATE(\"S/PDIF Input\", HDSPM_c0_Input0),\n\tHDSPM_TOGGLE_SETTING(\"S/PDIF Out Optical\", HDSPM_c0_Spdif_Opt),\n\tHDSPM_TOGGLE_SETTING(\"S/PDIF Out Professional\", HDSPM_c0_Pro),\n\tHDSPM_TOGGLE_SETTING(\"ADAT internal (AEB/TEB)\", HDSPM_c0_AEB1),\n\tHDSPM_TOGGLE_SETTING(\"XLR Breakout Cable\", HDSPM_c0_Sym6db),\n\tHDSPM_TOGGLE_SETTING(\"Single Speed WordClock Out\", HDSPM_c0_Wck48),\n\tHDSPM_CONTROL_TRISTATE(\"Input Level\", HDSPM_c0_AD_GAIN0),\n\tHDSPM_CONTROL_TRISTATE(\"Output Level\", HDSPM_c0_DA_GAIN0),\n\tHDSPM_CONTROL_TRISTATE(\"Phones Level\", HDSPM_c0_PH_GAIN0)\n\n\t\t \n};\n\nstatic const struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {\n\tHDSPM_MIXER(\"Mixer\", 0),\n\tHDSPM_INTERNAL_CLOCK(\"Internal Clock\", 0),\n\tHDSPM_SYSTEM_CLOCK_MODE(\"Clock Mode\", 0),\n\tHDSPM_PREF_SYNC_REF(\"Pref Sync Ref\", 0),\n\tHDSPM_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSPM_SYNC_CHECK(\"WC SyncCheck\", 0),\n\tHDSPM_SYNC_CHECK(\"AES SyncCheck\", 1),\n\tHDSPM_SYNC_CHECK(\"SPDIF SyncCheck\", 2),\n\tHDSPM_SYNC_CHECK(\"ADAT1 SyncCheck\", 3),\n\tHDSPM_SYNC_CHECK(\"ADAT2 SyncCheck\", 4),\n\tHDSPM_SYNC_CHECK(\"ADAT3 SyncCheck\", 5),\n\tHDSPM_SYNC_CHECK(\"ADAT4 SyncCheck\", 6),\n\tHDSPM_SYNC_CHECK(\"TCO SyncCheck\", 7),\n\tHDSPM_SYNC_CHECK(\"SYNC IN SyncCheck\", 8),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"WC Frequency\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES Frequency\", 1),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"SPDIF Frequency\", 2),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"ADAT1 Frequency\", 3),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"ADAT2 Frequency\", 4),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"ADAT3 Frequency\", 5),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"ADAT4 Frequency\", 6),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"TCO Frequency\", 7),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"SYNC IN Frequency\", 8),\n\tHDSPM_TOGGLE_SETTING(\"S/PDIF Out Professional\", HDSPM_c0_Pro),\n\tHDSPM_TOGGLE_SETTING(\"Single Speed WordClock Out\", HDSPM_c0_Wck48)\n};\n\nstatic const struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {\n\tHDSPM_MIXER(\"Mixer\", 0),\n\tHDSPM_INTERNAL_CLOCK(\"Internal Clock\", 0),\n\tHDSPM_SYSTEM_CLOCK_MODE(\"System Clock Mode\", 0),\n\tHDSPM_PREF_SYNC_REF(\"Preferred Sync Reference\", 0),\n\tHDSPM_AUTOSYNC_REF(\"AutoSync Reference\", 0),\n\tHDSPM_SYSTEM_SAMPLE_RATE(\"System Sample Rate\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"External Rate\", 11),\n\tHDSPM_SYNC_CHECK(\"WC Sync Check\", 0),\n\tHDSPM_SYNC_CHECK(\"AES1 Sync Check\", 1),\n\tHDSPM_SYNC_CHECK(\"AES2 Sync Check\", 2),\n\tHDSPM_SYNC_CHECK(\"AES3 Sync Check\", 3),\n\tHDSPM_SYNC_CHECK(\"AES4 Sync Check\", 4),\n\tHDSPM_SYNC_CHECK(\"AES5 Sync Check\", 5),\n\tHDSPM_SYNC_CHECK(\"AES6 Sync Check\", 6),\n\tHDSPM_SYNC_CHECK(\"AES7 Sync Check\", 7),\n\tHDSPM_SYNC_CHECK(\"AES8 Sync Check\", 8),\n\tHDSPM_SYNC_CHECK(\"TCO Sync Check\", 9),\n\tHDSPM_SYNC_CHECK(\"SYNC IN Sync Check\", 10),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"WC Frequency\", 0),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES1 Frequency\", 1),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES2 Frequency\", 2),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES3 Frequency\", 3),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES4 Frequency\", 4),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES5 Frequency\", 5),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES6 Frequency\", 6),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES7 Frequency\", 7),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"AES8 Frequency\", 8),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"TCO Frequency\", 9),\n\tHDSPM_AUTOSYNC_SAMPLE_RATE(\"SYNC IN Frequency\", 10),\n\tHDSPM_TOGGLE_SETTING(\"Line Out\", HDSPM_LineOut),\n\tHDSPM_TOGGLE_SETTING(\"Emphasis\", HDSPM_Emphasis),\n\tHDSPM_TOGGLE_SETTING(\"Non Audio\", HDSPM_Dolby),\n\tHDSPM_TOGGLE_SETTING(\"Professional\", HDSPM_Professional),\n\tHDSPM_TOGGLE_SETTING(\"Clear Track Marker\", HDSPM_clr_tms),\n\tHDSPM_DS_WIRE(\"Double Speed Wire Mode\", 0),\n\tHDSPM_QS_WIRE(\"Quad Speed Wire Mode\", 0),\n};\n\n\n\n \nstatic const struct snd_kcontrol_new snd_hdspm_controls_tco[] = {\n\tHDSPM_TCO_SAMPLE_RATE(\"TCO Sample Rate\", 0),\n\tHDSPM_TCO_PULL(\"TCO Pull\", 0),\n\tHDSPM_TCO_WCK_CONVERSION(\"TCO WCK Conversion\", 0),\n\tHDSPM_TCO_FRAME_RATE(\"TCO Frame Rate\", 0),\n\tHDSPM_TCO_SYNC_SOURCE(\"TCO Sync Source\", 0),\n\tHDSPM_TCO_WORD_TERM(\"TCO Word Term\", 0),\n\tHDSPM_TCO_LOCK_CHECK(\"TCO Input Check\", 11),\n\tHDSPM_TCO_LOCK_CHECK(\"TCO LTC Valid\", 12),\n\tHDSPM_TCO_LTC_FRAMES(\"TCO Detected Frame Rate\", 0),\n\tHDSPM_TCO_VIDEO_INPUT_FORMAT(\"Video Input Format\", 0)\n};\n\n\nstatic struct snd_kcontrol_new snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;\n\n\nstatic int hdspm_update_simple_mixer_controls(struct hdspm * hdspm)\n{\n\tint i;\n\n\tfor (i = hdspm->ds_out_channels; i < hdspm->ss_out_channels; ++i) {\n\t\tif (hdspm->system_sample_rate > 48000) {\n\t\t\thdspm->playback_mixer_ctls[i]->vd[0].access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE;\n\t\t} else {\n\t\t\thdspm->playback_mixer_ctls[i]->vd[0].access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE;\n\t\t}\n\t\tsnd_ctl_notify(hdspm->card, SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t\tSNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t\t&hdspm->playback_mixer_ctls[i]->id);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_create_controls(struct snd_card *card,\n\t\t\t\t\tstruct hdspm *hdspm)\n{\n\tunsigned int idx, limit;\n\tint err;\n\tstruct snd_kcontrol *kctl;\n\tconst struct snd_kcontrol_new *list = NULL;\n\n\tswitch (hdspm->io_type) {\n\tcase MADI:\n\t\tlist = snd_hdspm_controls_madi;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_madi);\n\t\tbreak;\n\tcase MADIface:\n\t\tlist = snd_hdspm_controls_madiface;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_madiface);\n\t\tbreak;\n\tcase AIO:\n\t\tlist = snd_hdspm_controls_aio;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_aio);\n\t\tbreak;\n\tcase RayDAT:\n\t\tlist = snd_hdspm_controls_raydat;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_raydat);\n\t\tbreak;\n\tcase AES32:\n\t\tlist = snd_hdspm_controls_aes32;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_aes32);\n\t\tbreak;\n\t}\n\n\tif (list) {\n\t\tfor (idx = 0; idx < limit; idx++) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\tsnd_ctl_new1(&list[idx], hdspm));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\n\t \n\tsnd_hdspm_playback_mixer.name = \"Chn\";\n\tif (hdspm->system_sample_rate >= 128000) {\n\t\tlimit = hdspm->qs_out_channels;\n\t} else if (hdspm->system_sample_rate >= 64000) {\n\t\tlimit = hdspm->ds_out_channels;\n\t} else {\n\t\tlimit = hdspm->ss_out_channels;\n\t}\n\tfor (idx = 0; idx < limit; ++idx) {\n\t\tsnd_hdspm_playback_mixer.index = idx + 1;\n\t\tkctl = snd_ctl_new1(&snd_hdspm_playback_mixer, hdspm);\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\thdspm->playback_mixer_ctls[idx] = kctl;\n\t}\n\n\n\tif (hdspm->tco) {\n\t\t \n\t\tlist = snd_hdspm_controls_tco;\n\t\tlimit = ARRAY_SIZE(snd_hdspm_controls_tco);\n\t\tfor (idx = 0; idx < limit; idx++) {\n\t\t\terr = snd_ctl_add(card,\n\t\t\t\t\tsnd_ctl_new1(&list[idx], hdspm));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void\nsnd_hdspm_proc_read_tco(struct snd_info_entry *entry,\n\t\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tunsigned int status, control;\n\tint a, ltc, frames, seconds, minutes, hours;\n\tunsigned int period;\n\tu64 freq_const = 0;\n\tu32 rate;\n\n\tsnd_iprintf(buffer, \"--- TCO ---\\n\");\n\n\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\tcontrol = hdspm->control_register;\n\n\n\tif (status & HDSPM_tco_detect) {\n\t\tsnd_iprintf(buffer, \"TCO module detected.\\n\");\n\t\ta = hdspm_read(hdspm, HDSPM_RD_TCO+4);\n\t\tif (a & HDSPM_TCO1_LTC_Input_valid) {\n\t\t\tsnd_iprintf(buffer, \"  LTC valid, \");\n\t\t\tswitch (a & (HDSPM_TCO1_LTC_Format_LSB |\n\t\t\t\t\t\tHDSPM_TCO1_LTC_Format_MSB)) {\n\t\t\tcase 0:\n\t\t\t\tsnd_iprintf(buffer, \"24 fps, \");\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_TCO1_LTC_Format_LSB:\n\t\t\t\tsnd_iprintf(buffer, \"25 fps, \");\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_TCO1_LTC_Format_MSB:\n\t\t\t\tsnd_iprintf(buffer, \"29.97 fps, \");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnd_iprintf(buffer, \"30 fps, \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a & HDSPM_TCO1_set_drop_frame_flag) {\n\t\t\t\tsnd_iprintf(buffer, \"drop frame\\n\");\n\t\t\t} else {\n\t\t\t\tsnd_iprintf(buffer, \"full frame\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"  no LTC\\n\");\n\t\t}\n\t\tif (a & HDSPM_TCO1_Video_Input_Format_NTSC) {\n\t\t\tsnd_iprintf(buffer, \"  Video: NTSC\\n\");\n\t\t} else if (a & HDSPM_TCO1_Video_Input_Format_PAL) {\n\t\t\tsnd_iprintf(buffer, \"  Video: PAL\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"  No video\\n\");\n\t\t}\n\t\tif (a & HDSPM_TCO1_TCO_lock) {\n\t\t\tsnd_iprintf(buffer, \"  Sync: lock\\n\");\n\t\t} else {\n\t\t\tsnd_iprintf(buffer, \"  Sync: no lock\\n\");\n\t\t}\n\n\t\tswitch (hdspm->io_type) {\n\t\tcase MADI:\n\t\tcase AES32:\n\t\t\tfreq_const = 110069313433624ULL;\n\t\t\tbreak;\n\t\tcase RayDAT:\n\t\tcase AIO:\n\t\t\tfreq_const = 104857600000000ULL;\n\t\t\tbreak;\n\t\tcase MADIface:\n\t\t\tbreak;  \n\t\t}\n\n\t\tperiod = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\n\t\tsnd_iprintf(buffer, \"    period: %u\\n\", period);\n\n\n\t\t \n\t\trate = div_u64(freq_const, period);\n\n\t\tif (control & HDSPM_QuadSpeed) {\n\t\t\trate *= 4;\n\t\t} else if (control & HDSPM_DoubleSpeed) {\n\t\t\trate *= 2;\n\t\t}\n\n\t\tsnd_iprintf(buffer, \"  Frequency: %u Hz\\n\",\n\t\t\t\t(unsigned int) rate);\n\n\t\tltc = hdspm_read(hdspm, HDSPM_RD_TCO);\n\t\tframes = ltc & 0xF;\n\t\tltc >>= 4;\n\t\tframes += (ltc & 0x3) * 10;\n\t\tltc >>= 4;\n\t\tseconds = ltc & 0xF;\n\t\tltc >>= 4;\n\t\tseconds += (ltc & 0x7) * 10;\n\t\tltc >>= 4;\n\t\tminutes = ltc & 0xF;\n\t\tltc >>= 4;\n\t\tminutes += (ltc & 0x7) * 10;\n\t\tltc >>= 4;\n\t\thours = ltc & 0xF;\n\t\tltc >>= 4;\n\t\thours += (ltc & 0x3) * 10;\n\t\tsnd_iprintf(buffer,\n\t\t\t\"  LTC In: %02d:%02d:%02d:%02d\\n\",\n\t\t\thours, minutes, seconds, frames);\n\n\t} else {\n\t\tsnd_iprintf(buffer, \"No TCO module detected.\\n\");\n\t}\n}\n\nstatic void\nsnd_hdspm_proc_read_madi(struct snd_info_entry *entry,\n\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tunsigned int status, status2;\n\n\tchar *pref_sync_ref;\n\tchar *autosync_ref;\n\tchar *system_clock_mode;\n\tint x, x2;\n\n\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\n\tsnd_iprintf(buffer, \"%s (Card #%d) Rev.%x Status2first3bits: %x\\n\",\n\t\t\thdspm->card_name, hdspm->card->number + 1,\n\t\t\thdspm->firmware_rev,\n\t\t\t(status2 & HDSPM_version0) |\n\t\t\t(status2 & HDSPM_version1) | (status2 &\n\t\t\t\tHDSPM_version2));\n\n\tsnd_iprintf(buffer, \"HW Serial: 0x%06x%06x\\n\",\n\t\t\t(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,\n\t\t\thdspm->serial);\n\n\tsnd_iprintf(buffer, \"IRQ: %d Registers bus: 0x%lx VM: 0x%lx\\n\",\n\t\t\thdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);\n\n\tsnd_iprintf(buffer, \"--- System ---\\n\");\n\n\tsnd_iprintf(buffer,\n\t\t\"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\\n\",\n\t\tstatus & HDSPM_audioIRQPending,\n\t\t(status & HDSPM_midi0IRQPending) ? 1 : 0,\n\t\t(status & HDSPM_midi1IRQPending) ? 1 : 0,\n\t\thdspm->irq_count);\n\tsnd_iprintf(buffer,\n\t\t\"HW pointer: id = %d, rawptr = %d (%d->%d) \"\n\t\t\"estimated= %ld (bytes)\\n\",\n\t\t((status & HDSPM_BufferID) ? 1 : 0),\n\t\t(status & HDSPM_BufferPositionMask),\n\t\t(status & HDSPM_BufferPositionMask) %\n\t\t(2 * (int)hdspm->period_bytes),\n\t\t((status & HDSPM_BufferPositionMask) - 64) %\n\t\t(2 * (int)hdspm->period_bytes),\n\t\t(long) hdspm_hw_pointer(hdspm) * 4);\n\n\tsnd_iprintf(buffer,\n\t\t\"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \\n\",\n\t\thdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,\n\t\thdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,\n\t\thdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,\n\t\thdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);\n\tsnd_iprintf(buffer,\n\t\t\"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \\n\",\n\t\thdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,\n\t\thdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);\n\tsnd_iprintf(buffer,\n\t\t\"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, \"\n\t\t\"status2=0x%x\\n\",\n\t\thdspm->control_register, hdspm->control2_register,\n\t\tstatus, status2);\n\n\n\tsnd_iprintf(buffer, \"--- Settings ---\\n\");\n\n\tx = hdspm_get_latency(hdspm);\n\n\tsnd_iprintf(buffer,\n\t\t\"Size (Latency): %d samples (2 periods of %lu bytes)\\n\",\n\t\tx, (unsigned long) hdspm->period_bytes);\n\n\tsnd_iprintf(buffer, \"Line out: %s\\n\",\n\t\t(hdspm->control_register & HDSPM_LineOut) ? \"on \" : \"off\");\n\n\tsnd_iprintf(buffer,\n\t\t\"ClearTrackMarker = %s, Transmit in %s Channel Mode, \"\n\t\t\"Auto Input %s\\n\",\n\t\t(hdspm->control_register & HDSPM_clr_tms) ? \"on\" : \"off\",\n\t\t(hdspm->control_register & HDSPM_TX_64ch) ? \"64\" : \"56\",\n\t\t(hdspm->control_register & HDSPM_AutoInp) ? \"on\" : \"off\");\n\n\n\tif (!(hdspm->control_register & HDSPM_ClockModeMaster))\n\t\tsystem_clock_mode = \"AutoSync\";\n\telse\n\t\tsystem_clock_mode = \"Master\";\n\tsnd_iprintf(buffer, \"AutoSync Reference: %s\\n\", system_clock_mode);\n\n\tswitch (hdspm_pref_sync_ref(hdspm)) {\n\tcase HDSPM_SYNC_FROM_WORD:\n\t\tpref_sync_ref = \"Word Clock\";\n\t\tbreak;\n\tcase HDSPM_SYNC_FROM_MADI:\n\t\tpref_sync_ref = \"MADI Sync\";\n\t\tbreak;\n\tcase HDSPM_SYNC_FROM_TCO:\n\t\tpref_sync_ref = \"TCO\";\n\t\tbreak;\n\tcase HDSPM_SYNC_FROM_SYNC_IN:\n\t\tpref_sync_ref = \"Sync In\";\n\t\tbreak;\n\tdefault:\n\t\tpref_sync_ref = \"XXXX Clock\";\n\t\tbreak;\n\t}\n\tsnd_iprintf(buffer, \"Preferred Sync Reference: %s\\n\",\n\t\t\tpref_sync_ref);\n\n\tsnd_iprintf(buffer, \"System Clock Frequency: %d\\n\",\n\t\t\thdspm->system_sample_rate);\n\n\n\tsnd_iprintf(buffer, \"--- Status:\\n\");\n\n\tx = status & HDSPM_madiSync;\n\tx2 = status2 & HDSPM_wcSync;\n\n\tsnd_iprintf(buffer, \"Inputs MADI=%s, WordClock=%s\\n\",\n\t\t\t(status & HDSPM_madiLock) ? (x ? \"Sync\" : \"Lock\") :\n\t\t\t\"NoLock\",\n\t\t\t(status2 & HDSPM_wcLock) ? (x2 ? \"Sync\" : \"Lock\") :\n\t\t\t\"NoLock\");\n\n\tswitch (hdspm_autosync_ref(hdspm)) {\n\tcase HDSPM_AUTOSYNC_FROM_SYNC_IN:\n\t\tautosync_ref = \"Sync In\";\n\t\tbreak;\n\tcase HDSPM_AUTOSYNC_FROM_TCO:\n\t\tautosync_ref = \"TCO\";\n\t\tbreak;\n\tcase HDSPM_AUTOSYNC_FROM_WORD:\n\t\tautosync_ref = \"Word Clock\";\n\t\tbreak;\n\tcase HDSPM_AUTOSYNC_FROM_MADI:\n\t\tautosync_ref = \"MADI Sync\";\n\t\tbreak;\n\tcase HDSPM_AUTOSYNC_FROM_NONE:\n\t\tautosync_ref = \"Input not valid\";\n\t\tbreak;\n\tdefault:\n\t\tautosync_ref = \"---\";\n\t\tbreak;\n\t}\n\tsnd_iprintf(buffer,\n\t\t\"AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\\n\",\n\t\tautosync_ref, hdspm_external_sample_rate(hdspm),\n\t\t(status & HDSPM_madiFreqMask) >> 22,\n\t\t(status2 & HDSPM_wcFreqMask) >> 5);\n\n\tsnd_iprintf(buffer, \"Input: %s, Mode=%s\\n\",\n\t\t(status & HDSPM_AB_int) ? \"Coax\" : \"Optical\",\n\t\t(status & HDSPM_RX_64ch) ? \"64 channels\" :\n\t\t\"56 channels\");\n\n\t \n\tsnd_hdspm_proc_read_tco(entry, buffer);\n\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void\nsnd_hdspm_proc_read_aes32(struct snd_info_entry * entry,\n\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tunsigned int status;\n\tunsigned int status2;\n\tunsigned int timecode;\n\tunsigned int wcLock, wcSync;\n\tint pref_syncref;\n\tchar *autosync_ref;\n\tint x;\n\n\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\tstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\ttimecode = hdspm_read(hdspm, HDSPM_timecodeRegister);\n\n\tsnd_iprintf(buffer, \"%s (Card #%d) Rev.%x\\n\",\n\t\t    hdspm->card_name, hdspm->card->number + 1,\n\t\t    hdspm->firmware_rev);\n\n\tsnd_iprintf(buffer, \"IRQ: %d Registers bus: 0x%lx VM: 0x%lx\\n\",\n\t\t    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);\n\n\tsnd_iprintf(buffer, \"--- System ---\\n\");\n\n\tsnd_iprintf(buffer,\n\t\t    \"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\\n\",\n\t\t    status & HDSPM_audioIRQPending,\n\t\t    (status & HDSPM_midi0IRQPending) ? 1 : 0,\n\t\t    (status & HDSPM_midi1IRQPending) ? 1 : 0,\n\t\t    hdspm->irq_count);\n\tsnd_iprintf(buffer,\n\t\t    \"HW pointer: id = %d, rawptr = %d (%d->%d) \"\n\t\t    \"estimated= %ld (bytes)\\n\",\n\t\t    ((status & HDSPM_BufferID) ? 1 : 0),\n\t\t    (status & HDSPM_BufferPositionMask),\n\t\t    (status & HDSPM_BufferPositionMask) %\n\t\t    (2 * (int)hdspm->period_bytes),\n\t\t    ((status & HDSPM_BufferPositionMask) - 64) %\n\t\t    (2 * (int)hdspm->period_bytes),\n\t\t    (long) hdspm_hw_pointer(hdspm) * 4);\n\n\tsnd_iprintf(buffer,\n\t\t    \"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \\n\",\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);\n\tsnd_iprintf(buffer,\n\t\t    \"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \\n\",\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,\n\t\t    hdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);\n\tsnd_iprintf(buffer,\n\t\t    \"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, \"\n\t\t    \"status2=0x%x\\n\",\n\t\t    hdspm->control_register, hdspm->control2_register,\n\t\t    status, status2);\n\n\tsnd_iprintf(buffer, \"--- Settings ---\\n\");\n\n\tx = hdspm_get_latency(hdspm);\n\n\tsnd_iprintf(buffer,\n\t\t    \"Size (Latency): %d samples (2 periods of %lu bytes)\\n\",\n\t\t    x, (unsigned long) hdspm->period_bytes);\n\n\tsnd_iprintf(buffer, \"Line out: %s\\n\",\n\t\t    (hdspm->\n\t\t     control_register & HDSPM_LineOut) ? \"on \" : \"off\");\n\n\tsnd_iprintf(buffer,\n\t\t    \"ClearTrackMarker %s, Emphasis %s, Dolby %s\\n\",\n\t\t    (hdspm->\n\t\t     control_register & HDSPM_clr_tms) ? \"on\" : \"off\",\n\t\t    (hdspm->\n\t\t     control_register & HDSPM_Emphasis) ? \"on\" : \"off\",\n\t\t    (hdspm->\n\t\t     control_register & HDSPM_Dolby) ? \"on\" : \"off\");\n\n\n\tpref_syncref = hdspm_pref_sync_ref(hdspm);\n\tif (pref_syncref == 0)\n\t\tsnd_iprintf(buffer, \"Preferred Sync Reference: Word Clock\\n\");\n\telse\n\t\tsnd_iprintf(buffer, \"Preferred Sync Reference: AES%d\\n\",\n\t\t\t\tpref_syncref);\n\n\tsnd_iprintf(buffer, \"System Clock Frequency: %d\\n\",\n\t\t    hdspm->system_sample_rate);\n\n\tsnd_iprintf(buffer, \"Double speed: %s\\n\",\n\t\t\thdspm->control_register & HDSPM_DS_DoubleWire?\n\t\t\t\"Double wire\" : \"Single wire\");\n\tsnd_iprintf(buffer, \"Quad speed: %s\\n\",\n\t\t\thdspm->control_register & HDSPM_QS_DoubleWire?\n\t\t\t\"Double wire\" :\n\t\t\thdspm->control_register & HDSPM_QS_QuadWire?\n\t\t\t\"Quad wire\" : \"Single wire\");\n\n\tsnd_iprintf(buffer, \"--- Status:\\n\");\n\n\twcLock = status & HDSPM_AES32_wcLock;\n\twcSync = wcLock && (status & HDSPM_AES32_wcSync);\n\n\tsnd_iprintf(buffer, \"Word: %s  Frequency: %d\\n\",\n\t\t    (wcLock) ? (wcSync ? \"Sync   \" : \"Lock   \") : \"No Lock\",\n\t\t    HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));\n\n\tfor (x = 0; x < 8; x++) {\n\t\tsnd_iprintf(buffer, \"AES%d: %s  Frequency: %d\\n\",\n\t\t\t    x+1,\n\t\t\t    (status2 & (HDSPM_LockAES >> x)) ?\n\t\t\t    \"Sync   \" : \"No Lock\",\n\t\t\t    HDSPM_bit2freq((timecode >> (4*x)) & 0xF));\n\t}\n\n\tswitch (hdspm_autosync_ref(hdspm)) {\n\tcase HDSPM_AES32_AUTOSYNC_FROM_NONE:\n\t\tautosync_ref = \"None\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_WORD:\n\t\tautosync_ref = \"Word Clock\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES1:\n\t\tautosync_ref = \"AES1\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES2:\n\t\tautosync_ref = \"AES2\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES3:\n\t\tautosync_ref = \"AES3\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES4:\n\t\tautosync_ref = \"AES4\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES5:\n\t\tautosync_ref = \"AES5\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES6:\n\t\tautosync_ref = \"AES6\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES7:\n\t\tautosync_ref = \"AES7\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_AES8:\n\t\tautosync_ref = \"AES8\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_TCO:\n\t\tautosync_ref = \"TCO\"; break;\n\tcase HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN:\n\t\tautosync_ref = \"Sync In\"; break;\n\tdefault:\n\t\tautosync_ref = \"---\"; break;\n\t}\n\tsnd_iprintf(buffer, \"AutoSync ref = %s\\n\", autosync_ref);\n\n\t \n\tsnd_hdspm_proc_read_tco(entry, buffer);\n\n\tsnd_iprintf(buffer, \"\\n\");\n}\n\nstatic void\nsnd_hdspm_proc_read_raydat(struct snd_info_entry *entry,\n\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tunsigned int status1, status2, status3, i;\n\tunsigned int lock, sync;\n\n\tstatus1 = hdspm_read(hdspm, HDSPM_RD_STATUS_1);  \n\tstatus2 = hdspm_read(hdspm, HDSPM_RD_STATUS_2);  \n\tstatus3 = hdspm_read(hdspm, HDSPM_RD_STATUS_3);  \n\n\tsnd_iprintf(buffer, \"STATUS1: 0x%08x\\n\", status1);\n\tsnd_iprintf(buffer, \"STATUS2: 0x%08x\\n\", status2);\n\tsnd_iprintf(buffer, \"STATUS3: 0x%08x\\n\", status3);\n\n\n\tsnd_iprintf(buffer, \"\\n*** CLOCK MODE\\n\\n\");\n\n\tsnd_iprintf(buffer, \"Clock mode      : %s\\n\",\n\t\t(hdspm_system_clock_mode(hdspm) == 0) ? \"master\" : \"slave\");\n\tsnd_iprintf(buffer, \"System frequency: %d Hz\\n\",\n\t\thdspm_get_system_sample_rate(hdspm));\n\n\tsnd_iprintf(buffer, \"\\n*** INPUT STATUS\\n\\n\");\n\n\tlock = 0x1;\n\tsync = 0x100;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tsnd_iprintf(buffer, \"s1_input %d: Lock %d, Sync %d, Freq %s\\n\",\n\t\t\t\ti,\n\t\t\t\t(status1 & lock) ? 1 : 0,\n\t\t\t\t(status1 & sync) ? 1 : 0,\n\t\t\t\ttexts_freq[(status2 >> (i * 4)) & 0xF]);\n\n\t\tlock = lock<<1;\n\t\tsync = sync<<1;\n\t}\n\n\tsnd_iprintf(buffer, \"WC input: Lock %d, Sync %d, Freq %s\\n\",\n\t\t\t(status1 & 0x1000000) ? 1 : 0,\n\t\t\t(status1 & 0x2000000) ? 1 : 0,\n\t\t\ttexts_freq[(status1 >> 16) & 0xF]);\n\n\tsnd_iprintf(buffer, \"TCO input: Lock %d, Sync %d, Freq %s\\n\",\n\t\t\t(status1 & 0x4000000) ? 1 : 0,\n\t\t\t(status1 & 0x8000000) ? 1 : 0,\n\t\t\ttexts_freq[(status1 >> 20) & 0xF]);\n\n\tsnd_iprintf(buffer, \"SYNC IN: Lock %d, Sync %d, Freq %s\\n\",\n\t\t\t(status3 & 0x400) ? 1 : 0,\n\t\t\t(status3 & 0x800) ? 1 : 0,\n\t\t\ttexts_freq[(status2 >> 12) & 0xF]);\n\n}\n\n#ifdef CONFIG_SND_DEBUG\nstatic void\nsnd_hdspm_proc_read_debug(struct snd_info_entry *entry,\n\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\n\tint j,i;\n\n\tfor (i = 0; i < 256  ; i += j) {\n\t\tsnd_iprintf(buffer, \"0x%08X: \", i);\n\t\tfor (j = 0; j < 16; j += 4)\n\t\t\tsnd_iprintf(buffer, \"%08X \", hdspm_read(hdspm, i + j));\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n}\n#endif\n\n\nstatic void snd_hdspm_proc_ports_in(struct snd_info_entry *entry,\n\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tint i;\n\n\tsnd_iprintf(buffer, \"# generated by hdspm\\n\");\n\n\tfor (i = 0; i < hdspm->max_channels_in; i++) {\n\t\tsnd_iprintf(buffer, \"%d=%s\\n\", i+1, hdspm->port_names_in[i]);\n\t}\n}\n\nstatic void snd_hdspm_proc_ports_out(struct snd_info_entry *entry,\n\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct hdspm *hdspm = entry->private_data;\n\tint i;\n\n\tsnd_iprintf(buffer, \"# generated by hdspm\\n\");\n\n\tfor (i = 0; i < hdspm->max_channels_out; i++) {\n\t\tsnd_iprintf(buffer, \"%d=%s\\n\", i+1, hdspm->port_names_out[i]);\n\t}\n}\n\n\nstatic void snd_hdspm_proc_init(struct hdspm *hdspm)\n{\n\tvoid (*read)(struct snd_info_entry *, struct snd_info_buffer *) = NULL;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\tread = snd_hdspm_proc_read_aes32;\n\t\tbreak;\n\tcase MADI:\n\t\tread = snd_hdspm_proc_read_madi;\n\t\tbreak;\n\tcase MADIface:\n\t\t \n\t\tbreak;\n\tcase RayDAT:\n\t\tread = snd_hdspm_proc_read_raydat;\n\t\tbreak;\n\tcase AIO:\n\t\tbreak;\n\t}\n\n\tsnd_card_ro_proc_new(hdspm->card, \"hdspm\", hdspm, read);\n\tsnd_card_ro_proc_new(hdspm->card, \"ports.in\", hdspm,\n\t\t\t     snd_hdspm_proc_ports_in);\n\tsnd_card_ro_proc_new(hdspm->card, \"ports.out\", hdspm,\n\t\t\t     snd_hdspm_proc_ports_out);\n\n#ifdef CONFIG_SND_DEBUG\n\t \n\tsnd_card_ro_proc_new(hdspm->card, \"debug\", hdspm,\n\t\t\t     snd_hdspm_proc_read_debug);\n#endif\n}\n\n \n\nstatic int snd_hdspm_set_defaults(struct hdspm * hdspm)\n{\n\t \n\n\t \n\n\thdspm->settings_register = 0;\n\n\tswitch (hdspm->io_type) {\n\tcase MADI:\n\tcase MADIface:\n\t\thdspm->control_register =\n\t\t\t0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;\n\t\tbreak;\n\n\tcase RayDAT:\n\tcase AIO:\n\t\thdspm->settings_register = 0x1 + 0x1000;\n\t\t \n\t\thdspm->control_register =\n\t\t\t0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;\n\t\tbreak;\n\n\tcase AES32:\n\t\thdspm->control_register =\n\t\t\tHDSPM_ClockModeMaster |\t \n\t\t\thdspm_encode_latency(7) |  \n\t\t\tHDSPM_SyncRef0 |\t \n\t\t\tHDSPM_LineOut |\t \n\t\t\tHDSPM_Professional;   \n\t\tbreak;\n\t}\n\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\tif (AES32 == hdspm->io_type) {\n\t\t \n#ifdef SNDRV_BIG_ENDIAN\n\t\thdspm->control2_register = HDSPM_BIGENDIAN_MODE;\n#else\n\t\thdspm->control2_register = 0;\n#endif\n\n\t\thdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);\n\t}\n\thdspm_compute_period_size(hdspm);\n\n\t \n\n\tall_in_all_mixer(hdspm, 0 * UNITY_GAIN);\n\n\tif (hdspm_is_raydat_or_aio(hdspm))\n\t\thdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\n\n\t \n\thdspm_set_rate(hdspm, 48000, 1);\n\n\treturn 0;\n}\n\n\n \n\nstatic irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)\n{\n\tstruct hdspm *hdspm = (struct hdspm *) dev_id;\n\tunsigned int status;\n\tint i, audio, midi, schedule = 0;\n\t \n\n\tstatus = hdspm_read(hdspm, HDSPM_statusRegister);\n\n\taudio = status & HDSPM_audioIRQPending;\n\tmidi = status & (HDSPM_midi0IRQPending | HDSPM_midi1IRQPending |\n\t\t\tHDSPM_midi2IRQPending | HDSPM_midi3IRQPending);\n\n\t \n\t \n\t \n\n\tif (!audio && !midi)\n\t\treturn IRQ_NONE;\n\n\thdspm_write(hdspm, HDSPM_interruptConfirmation, 0);\n\thdspm->irq_count++;\n\n\n\tif (audio) {\n\t\tif (hdspm->capture_substream)\n\t\t\tsnd_pcm_period_elapsed(hdspm->capture_substream);\n\n\t\tif (hdspm->playback_substream)\n\t\t\tsnd_pcm_period_elapsed(hdspm->playback_substream);\n\t}\n\n\tif (midi) {\n\t\ti = 0;\n\t\twhile (i < hdspm->midiPorts) {\n\t\t\tif ((hdspm_read(hdspm,\n\t\t\t\thdspm->midi[i].statusIn) & 0xff) &&\n\t\t\t\t\t(status & hdspm->midi[i].irq)) {\n\t\t\t\t \n\t\t\t\thdspm->control_register &= ~hdspm->midi[i].ie;\n\t\t\t\thdspm_write(hdspm, HDSPM_controlRegister,\n\t\t\t\t\t\thdspm->control_register);\n\t\t\t\thdspm->midi[i].pending = 1;\n\t\t\t\tschedule = 1;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (schedule)\n\t\t\tqueue_work(system_highpri_wq, &hdspm->midi_work);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n\nstatic snd_pcm_uframes_t snd_hdspm_hw_pointer(struct snd_pcm_substream\n\t\t\t\t\t      *substream)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\treturn hdspm_hw_pointer(hdspm);\n}\n\n\nstatic int snd_hdspm_reset(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = hdspm->capture_substream;\n\telse\n\t\tother = hdspm->playback_substream;\n\n\tif (hdspm->running)\n\t\truntime->status->hw_ptr = hdspm_hw_pointer(hdspm);\n\telse\n\t\truntime->status->hw_ptr = 0;\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tstruct snd_pcm_runtime *oruntime = other->runtime;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\toruntime->status->hw_ptr =\n\t\t\t\t\truntime->status->hw_ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdspm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tint err;\n\tint i;\n\tpid_t this_pid;\n\tpid_t other_pid;\n\n\tspin_lock_irq(&hdspm->lock);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tthis_pid = hdspm->playback_pid;\n\t\tother_pid = hdspm->capture_pid;\n\t} else {\n\t\tthis_pid = hdspm->capture_pid;\n\t\tother_pid = hdspm->playback_pid;\n\t}\n\n\tif (other_pid > 0 && this_pid != other_pid) {\n\n\t\t \n\n\t\tif (params_rate(params) != hdspm->system_sample_rate) {\n\t\t\tspin_unlock_irq(&hdspm->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (params_period_size(params) != hdspm->period_bytes / 4) {\n\t\t\tspin_unlock_irq(&hdspm->lock);\n\t\t\t_snd_pcm_hw_param_setempty(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t}\n\t \n\tspin_unlock_irq(&hdspm->lock);\n\n\t \n\n\tspin_lock_irq(&hdspm->lock);\n\terr = hdspm_set_rate(hdspm, params_rate(params), 0);\n\tif (err < 0) {\n\t\tdev_info(hdspm->card->dev, \"err on hdspm_set_rate: %d\\n\", err);\n\t\tspin_unlock_irq(&hdspm->lock);\n\t\t_snd_pcm_hw_param_setempty(params,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\t\treturn err;\n\t}\n\tspin_unlock_irq(&hdspm->lock);\n\n\terr = hdspm_set_interrupt_interval(hdspm,\n\t\t\tparams_period_size(params));\n\tif (err < 0) {\n\t\tdev_info(hdspm->card->dev,\n\t\t\t \"err on hdspm_set_interrupt_interval: %d\\n\", err);\n\t\t_snd_pcm_hw_param_setempty(params,\n\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\t\treturn err;\n\t}\n\n\t \n\t \n\t \n\n\terr =\n\t\tsnd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);\n\tif (err < 0) {\n\t\tdev_info(hdspm->card->dev,\n\t\t\t \"err on snd_pcm_lib_malloc_pages: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\n\t\tfor (i = 0; i < params_channels(params); ++i) {\n\t\t\tint c = hdspm->channel_map_out[i];\n\n\t\t\tif (c < 0)\n\t\t\t\tcontinue;       \n\t\t\thdspm_set_channel_dma_addr(hdspm, substream,\n\t\t\t\t\t\t   HDSPM_pageAddressBufferOut,\n\t\t\t\t\t\t   c);\n\t\t\tsnd_hdspm_enable_out(hdspm, c, 1);\n\t\t}\n\n\t\thdspm->playback_buffer =\n\t\t\t(unsigned char *) substream->runtime->dma_area;\n\t\tdev_dbg(hdspm->card->dev,\n\t\t\t\"Allocated sample buffer for playback at %p\\n\",\n\t\t\t\thdspm->playback_buffer);\n\t} else {\n\t\tfor (i = 0; i < params_channels(params); ++i) {\n\t\t\tint c = hdspm->channel_map_in[i];\n\n\t\t\tif (c < 0)\n\t\t\t\tcontinue;\n\t\t\thdspm_set_channel_dma_addr(hdspm, substream,\n\t\t\t\t\t\t   HDSPM_pageAddressBufferIn,\n\t\t\t\t\t\t   c);\n\t\t\tsnd_hdspm_enable_in(hdspm, c, 1);\n\t\t}\n\n\t\thdspm->capture_buffer =\n\t\t\t(unsigned char *) substream->runtime->dma_area;\n\t\tdev_dbg(hdspm->card->dev,\n\t\t\t\"Allocated sample buffer for capture at %p\\n\",\n\t\t\t\thdspm->capture_buffer);\n\t}\n\n\t \n\t \n\n\n\t \n\tif (hdspm->io_type == AES32) {\n\t\treturn 0;\n\t}\n\n\n\t \n\tif (SNDRV_PCM_FORMAT_FLOAT_LE == params_format(params)) {\n\t\tif (!(hdspm->control_register & HDSPe_FLOAT_FORMAT))\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"Switching to native 32bit LE float format.\\n\");\n\n\t\thdspm->control_register |= HDSPe_FLOAT_FORMAT;\n\t} else if (SNDRV_PCM_FORMAT_S32_LE == params_format(params)) {\n\t\tif (hdspm->control_register & HDSPe_FLOAT_FORMAT)\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"Switching to native 32bit LE integer format.\\n\");\n\n\t\thdspm->control_register &= ~HDSPe_FLOAT_FORMAT;\n\t}\n\thdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_hw_free(struct snd_pcm_substream *substream)\n{\n\tint i;\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\t \n\t\tfor (i = 0; i < HDSPM_MAX_CHANNELS; ++i)\n\t\t\tsnd_hdspm_enable_out(hdspm, i, 0);\n\n\t\thdspm->playback_buffer = NULL;\n\t} else {\n\t\tfor (i = 0; i < HDSPM_MAX_CHANNELS; ++i)\n\t\t\tsnd_hdspm_enable_in(hdspm, i, 0);\n\n\t\thdspm->capture_buffer = NULL;\n\t}\n\n\tsnd_pcm_lib_free_pages(substream);\n\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_channel_info(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_channel_info *info)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tunsigned int channel = info->channel;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (snd_BUG_ON(channel >= hdspm->max_channels_out)) {\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"snd_hdspm_channel_info: output channel out of range (%d)\\n\",\n\t\t\t\t channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannel = array_index_nospec(channel, hdspm->max_channels_out);\n\t\tif (hdspm->channel_map_out[channel] < 0) {\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"snd_hdspm_channel_info: output channel %d mapped out\\n\",\n\t\t\t\t channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo->offset = hdspm->channel_map_out[channel] *\n\t\t\tHDSPM_CHANNEL_BUFFER_BYTES;\n\t} else {\n\t\tif (snd_BUG_ON(channel >= hdspm->max_channels_in)) {\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"snd_hdspm_channel_info: input channel out of range (%d)\\n\",\n\t\t\t\t channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannel = array_index_nospec(channel, hdspm->max_channels_in);\n\t\tif (hdspm->channel_map_in[channel] < 0) {\n\t\t\tdev_info(hdspm->card->dev,\n\t\t\t\t \"snd_hdspm_channel_info: input channel %d mapped out\\n\",\n\t\t\t\t channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo->offset = hdspm->channel_map_in[channel] *\n\t\t\tHDSPM_CHANNEL_BUFFER_BYTES;\n\t}\n\n\tinfo->first = 0;\n\tinfo->step = 32;\n\treturn 0;\n}\n\n\nstatic int snd_hdspm_ioctl(struct snd_pcm_substream *substream,\n\t\tunsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_hdspm_reset(substream);\n\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\t{\n\t\t\tstruct snd_pcm_channel_info *info = arg;\n\t\t\treturn snd_hdspm_channel_info(substream, info);\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nstatic int snd_hdspm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_substream *other;\n\tint running;\n\n\tspin_lock(&hdspm->lock);\n\trunning = hdspm->running;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\trunning |= 1 << substream->stream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\trunning &= ~(1 << substream->stream);\n\t\tbreak;\n\tdefault:\n\t\tsnd_BUG();\n\t\tspin_unlock(&hdspm->lock);\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tother = hdspm->capture_substream;\n\telse\n\t\tother = hdspm->playback_substream;\n\n\tif (other) {\n\t\tstruct snd_pcm_substream *s;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == other) {\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\t\t\trunning |= 1 << s->stream;\n\t\t\t\telse\n\t\t\t\t\trunning &= ~(1 << s->stream);\n\t\t\t\tgoto _ok;\n\t\t\t}\n\t\t}\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t\tif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK))\n\t\t\t\t\t&& substream->stream ==\n\t\t\t\t\tSNDRV_PCM_STREAM_CAPTURE)\n\t\t\t\thdspm_silence_playback(hdspm);\n\t\t} else {\n\t\t\tif (running &&\n\t\t\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\thdspm_silence_playback(hdspm);\n\t\t}\n\t} else {\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\thdspm_silence_playback(hdspm);\n\t}\n_ok:\n\tsnd_pcm_trigger_done(substream, substream);\n\tif (!hdspm->running && running)\n\t\thdspm_start_audio(hdspm);\n\telse if (hdspm->running && !running)\n\t\thdspm_stop_audio(hdspm);\n\thdspm->running = running;\n\tspin_unlock(&hdspm->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_prepare(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware snd_hdspm_playback_subinfo = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t SNDRV_PCM_INFO_SYNC_START | SNDRV_PCM_INFO_DOUBLE),\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates = (SNDRV_PCM_RATE_32000 |\n\t\t  SNDRV_PCM_RATE_44100 |\n\t\t  SNDRV_PCM_RATE_48000 |\n\t\t  SNDRV_PCM_RATE_64000 |\n\t\t  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\n\t\t  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000 ),\n\t.rate_min = 32000,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = HDSPM_MAX_CHANNELS,\n\t.buffer_bytes_max =\n\t    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,\n\t.period_bytes_min = (32 * 4),\n\t.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,\n\t.periods_min = 2,\n\t.periods_max = 512,\n\t.fifo_size = 0\n};\n\nstatic const struct snd_pcm_hardware snd_hdspm_capture_subinfo = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t SNDRV_PCM_INFO_SYNC_START),\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates = (SNDRV_PCM_RATE_32000 |\n\t\t  SNDRV_PCM_RATE_44100 |\n\t\t  SNDRV_PCM_RATE_48000 |\n\t\t  SNDRV_PCM_RATE_64000 |\n\t\t  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\n\t\t  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000),\n\t.rate_min = 32000,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = HDSPM_MAX_CHANNELS,\n\t.buffer_bytes_max =\n\t    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,\n\t.period_bytes_min = (32 * 4),\n\t.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,\n\t.periods_min = 2,\n\t.periods_max = 512,\n\t.fifo_size = 0\n};\n\nstatic int snd_hdspm_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\n\tif (r->min > 96000 && r->max <= 192000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->qs_in_channels,\n\t\t\t.max = hdspm->qs_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->min > 48000 && r->max <= 96000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->ds_in_channels,\n\t\t\t.max = hdspm->ds_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->max < 64000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->ss_in_channels,\n\t\t\t.max = hdspm->ss_in_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_hw_rule_out_channels_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule * rule)\n{\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\n\tif (r->min > 96000 && r->max <= 192000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->qs_out_channels,\n\t\t\t.max = hdspm->qs_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->min > 48000 && r->max <= 96000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->ds_out_channels,\n\t\t\t.max = hdspm->ds_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else if (r->max < 64000) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = hdspm->ss_out_channels,\n\t\t\t.max = hdspm->ss_out_channels,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(c, &t);\n\t} else {\n\t}\n\treturn 0;\n}\n\nstatic int snd_hdspm_hw_rule_rate_in_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule * rule)\n{\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\n\tif (c->min >= hdspm->ss_in_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 32000,\n\t\t\t.max = 48000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdspm->qs_in_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 128000,\n\t\t\t.max = 192000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdspm->ds_in_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 64000,\n\t\t\t.max = 96000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t}\n\n\treturn 0;\n}\nstatic int snd_hdspm_hw_rule_rate_out_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *r =\n\t    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\n\tif (c->min >= hdspm->ss_out_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 32000,\n\t\t\t.max = 48000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdspm->qs_out_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 128000,\n\t\t\t.max = 192000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t} else if (c->max <= hdspm->ds_out_channels) {\n\t\tstruct snd_interval t = {\n\t\t\t.min = 64000,\n\t\t\t.max = 96000,\n\t\t\t.integer = 1,\n\t\t};\n\t\treturn snd_interval_refine(r, &t);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_hw_rule_in_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int list[3];\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\n\tlist[0] = hdspm->qs_in_channels;\n\tlist[1] = hdspm->ds_in_channels;\n\tlist[2] = hdspm->ss_in_channels;\n\treturn snd_interval_list(c, 3, list, 0);\n}\n\nstatic int snd_hdspm_hw_rule_out_channels(struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int list[3];\n\tstruct hdspm *hdspm = rule->private;\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\n\tlist[0] = hdspm->qs_out_channels;\n\tlist[1] = hdspm->ds_out_channels;\n\tlist[2] = hdspm->ss_out_channels;\n\treturn snd_interval_list(c, 3, list, 0);\n}\n\n\nstatic const unsigned int hdspm_aes32_sample_rates[] = {\n\t32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000\n};\n\nstatic const struct snd_pcm_hw_constraint_list\nhdspm_hw_constraints_aes32_sample_rates = {\n\t.count = ARRAY_SIZE(hdspm_aes32_sample_rates),\n\t.list = hdspm_aes32_sample_rates,\n\t.mask = 0\n};\n\nstatic int snd_hdspm_open(struct snd_pcm_substream *substream)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tbool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tspin_lock_irq(&hdspm->lock);\n\tsnd_pcm_set_sync(substream);\n\truntime->hw = (playback) ? snd_hdspm_playback_subinfo :\n\t\tsnd_hdspm_capture_subinfo;\n\n\tif (playback) {\n\t\tif (!hdspm->capture_substream)\n\t\t\thdspm_stop_audio(hdspm);\n\n\t\thdspm->playback_pid = current->pid;\n\t\thdspm->playback_substream = substream;\n\t} else {\n\t\tif (!hdspm->playback_substream)\n\t\t\thdspm_stop_audio(hdspm);\n\n\t\thdspm->capture_pid = current->pid;\n\t\thdspm->capture_substream = substream;\n\t}\n\n\tspin_unlock_irq(&hdspm->lock);\n\n\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tsnd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\n\tswitch (hdspm->io_type) {\n\tcase AIO:\n\tcase RayDAT:\n\t\tsnd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t     32, 4096);\n\t\t \n\t\tsnd_pcm_hw_constraint_single(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t     16384);\n\t\tbreak;\n\n\tdefault:\n\t\tsnd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t     64, 8192);\n\t\tsnd_pcm_hw_constraint_single(runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_PERIODS, 2);\n\t\tbreak;\n\t}\n\n\tif (AES32 == hdspm->io_type) {\n\t\truntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\n\t\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t&hdspm_hw_constraints_aes32_sample_rates);\n\t} else {\n\t\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t(playback ?\n\t\t\t\t snd_hdspm_hw_rule_rate_out_channels :\n\t\t\t\t snd_hdspm_hw_rule_rate_in_channels), hdspm,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\t}\n\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t(playback ? snd_hdspm_hw_rule_out_channels :\n\t\t\t snd_hdspm_hw_rule_in_channels), hdspm,\n\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t(playback ? snd_hdspm_hw_rule_out_channels_rate :\n\t\t\t snd_hdspm_hw_rule_in_channels_rate), hdspm,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, -1);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_release(struct snd_pcm_substream *substream)\n{\n\tstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\n\tbool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tspin_lock_irq(&hdspm->lock);\n\n\tif (playback) {\n\t\thdspm->playback_pid = -1;\n\t\thdspm->playback_substream = NULL;\n\t} else {\n\t\thdspm->capture_pid = -1;\n\t\thdspm->capture_substream = NULL;\n\t}\n\n\tspin_unlock_irq(&hdspm->lock);\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_hwdep_dummy_op(struct snd_hwdep *hw, struct file *file)\n{\n\t \n\treturn 0;\n}\n\nstatic int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct hdspm *hdspm = hw->private_data;\n\tstruct hdspm_mixer_ioctl mixer;\n\tstruct hdspm_config info;\n\tstruct hdspm_status status;\n\tstruct hdspm_version hdspm_version;\n\tstruct hdspm_peak_rms *levels;\n\tstruct hdspm_ltc ltc;\n\tunsigned int statusregister;\n\tlong unsigned int s;\n\tint i = 0;\n\n\tswitch (cmd) {\n\n\tcase SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:\n\t\tlevels = &hdspm->peak_rms;\n\t\tfor (i = 0; i < HDSPM_MAX_CHANNELS; i++) {\n\t\t\tlevels->input_peaks[i] =\n\t\t\t\treadl(hdspm->iobase +\n\t\t\t\t\t\tHDSPM_MADI_INPUT_PEAK + i*4);\n\t\t\tlevels->playback_peaks[i] =\n\t\t\t\treadl(hdspm->iobase +\n\t\t\t\t\t\tHDSPM_MADI_PLAYBACK_PEAK + i*4);\n\t\t\tlevels->output_peaks[i] =\n\t\t\t\treadl(hdspm->iobase +\n\t\t\t\t\t\tHDSPM_MADI_OUTPUT_PEAK + i*4);\n\n\t\t\tlevels->input_rms[i] =\n\t\t\t\t((uint64_t) readl(hdspm->iobase +\n\t\t\t\t\tHDSPM_MADI_INPUT_RMS_H + i*4) << 32) |\n\t\t\t\t(uint64_t) readl(hdspm->iobase +\n\t\t\t\t\t\tHDSPM_MADI_INPUT_RMS_L + i*4);\n\t\t\tlevels->playback_rms[i] =\n\t\t\t\t((uint64_t)readl(hdspm->iobase +\n\t\t\t\t\tHDSPM_MADI_PLAYBACK_RMS_H+i*4) << 32) |\n\t\t\t\t(uint64_t)readl(hdspm->iobase +\n\t\t\t\t\tHDSPM_MADI_PLAYBACK_RMS_L + i*4);\n\t\t\tlevels->output_rms[i] =\n\t\t\t\t((uint64_t)readl(hdspm->iobase +\n\t\t\t\t\tHDSPM_MADI_OUTPUT_RMS_H + i*4) << 32) |\n\t\t\t\t(uint64_t)readl(hdspm->iobase +\n\t\t\t\t\t\tHDSPM_MADI_OUTPUT_RMS_L + i*4);\n\t\t}\n\n\t\tif (hdspm->system_sample_rate > 96000) {\n\t\t\tlevels->speed = qs;\n\t\t} else if (hdspm->system_sample_rate > 48000) {\n\t\t\tlevels->speed = ds;\n\t\t} else {\n\t\t\tlevels->speed = ss;\n\t\t}\n\t\tlevels->status2 = hdspm_read(hdspm, HDSPM_statusRegister2);\n\n\t\ts = copy_to_user(argp, levels, sizeof(*levels));\n\t\tif (0 != s) {\n\t\t\t \n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_LTC:\n\t\tltc.ltc = hdspm_read(hdspm, HDSPM_RD_TCO);\n\t\ti = hdspm_read(hdspm, HDSPM_RD_TCO + 4);\n\t\tif (i & HDSPM_TCO1_LTC_Input_valid) {\n\t\t\tswitch (i & (HDSPM_TCO1_LTC_Format_LSB |\n\t\t\t\tHDSPM_TCO1_LTC_Format_MSB)) {\n\t\t\tcase 0:\n\t\t\t\tltc.format = fps_24;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_TCO1_LTC_Format_LSB:\n\t\t\t\tltc.format = fps_25;\n\t\t\t\tbreak;\n\t\t\tcase HDSPM_TCO1_LTC_Format_MSB:\n\t\t\t\tltc.format = fps_2997;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tltc.format = fps_30;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i & HDSPM_TCO1_set_drop_frame_flag) {\n\t\t\t\tltc.frame = drop_frame;\n\t\t\t} else {\n\t\t\t\tltc.frame = full_frame;\n\t\t\t}\n\t\t} else {\n\t\t\tltc.format = format_invalid;\n\t\t\tltc.frame = frame_invalid;\n\t\t}\n\t\tif (i & HDSPM_TCO1_Video_Input_Format_NTSC) {\n\t\t\tltc.input_format = ntsc;\n\t\t} else if (i & HDSPM_TCO1_Video_Input_Format_PAL) {\n\t\t\tltc.input_format = pal;\n\t\t} else {\n\t\t\tltc.input_format = no_video;\n\t\t}\n\n\t\ts = copy_to_user(argp, &ltc, sizeof(ltc));\n\t\tif (0 != s) {\n\t\t\t \n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_CONFIG:\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tspin_lock_irq(&hdspm->lock);\n\t\tinfo.pref_sync_ref = hdspm_pref_sync_ref(hdspm);\n\t\tinfo.wordclock_sync_check = hdspm_wc_sync_check(hdspm);\n\n\t\tinfo.system_sample_rate = hdspm->system_sample_rate;\n\t\tinfo.autosync_sample_rate =\n\t\t\thdspm_external_sample_rate(hdspm);\n\t\tinfo.system_clock_mode = hdspm_system_clock_mode(hdspm);\n\t\tinfo.clock_source = hdspm_clock_source(hdspm);\n\t\tinfo.autosync_ref = hdspm_autosync_ref(hdspm);\n\t\tinfo.line_out = hdspm_toggle_setting(hdspm, HDSPM_LineOut);\n\t\tinfo.passthru = 0;\n\t\tspin_unlock_irq(&hdspm->lock);\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_STATUS:\n\t\tmemset(&status, 0, sizeof(status));\n\n\t\tstatus.card_type = hdspm->io_type;\n\n\t\tstatus.autosync_source = hdspm_autosync_ref(hdspm);\n\n\t\tstatus.card_clock = 110069313433624ULL;\n\t\tstatus.master_period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\n\n\t\tswitch (hdspm->io_type) {\n\t\tcase MADI:\n\t\tcase MADIface:\n\t\t\tstatus.card_specific.madi.sync_wc =\n\t\t\t\thdspm_wc_sync_check(hdspm);\n\t\t\tstatus.card_specific.madi.sync_madi =\n\t\t\t\thdspm_madi_sync_check(hdspm);\n\t\t\tstatus.card_specific.madi.sync_tco =\n\t\t\t\thdspm_tco_sync_check(hdspm);\n\t\t\tstatus.card_specific.madi.sync_in =\n\t\t\t\thdspm_sync_in_sync_check(hdspm);\n\n\t\t\tstatusregister =\n\t\t\t\thdspm_read(hdspm, HDSPM_statusRegister);\n\t\t\tstatus.card_specific.madi.madi_input =\n\t\t\t\t(statusregister & HDSPM_AB_int) ? 1 : 0;\n\t\t\tstatus.card_specific.madi.channel_format =\n\t\t\t\t(statusregister & HDSPM_RX_64ch) ? 1 : 0;\n\t\t\t \n\t\t\tstatus.card_specific.madi.frame_format = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(argp, &status, sizeof(status)))\n\t\t\treturn -EFAULT;\n\n\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_VERSION:\n\t\tmemset(&hdspm_version, 0, sizeof(hdspm_version));\n\n\t\thdspm_version.card_type = hdspm->io_type;\n\t\tstrscpy(hdspm_version.cardname, hdspm->card_name,\n\t\t\t\tsizeof(hdspm_version.cardname));\n\t\thdspm_version.serial = hdspm->serial;\n\t\thdspm_version.firmware_rev = hdspm->firmware_rev;\n\t\thdspm_version.addons = 0;\n\t\tif (hdspm->tco)\n\t\t\thdspm_version.addons |= HDSPM_ADDON_TCO;\n\n\t\tif (copy_to_user(argp, &hdspm_version,\n\t\t\t\t\tsizeof(hdspm_version)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_MIXER:\n\t\tif (copy_from_user(&mixer, argp, sizeof(mixer)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,\n\t\t\t\t sizeof(*mixer.mixer)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_hdspm_ops = {\n\t.open = snd_hdspm_open,\n\t.close = snd_hdspm_release,\n\t.ioctl = snd_hdspm_ioctl,\n\t.hw_params = snd_hdspm_hw_params,\n\t.hw_free = snd_hdspm_hw_free,\n\t.prepare = snd_hdspm_prepare,\n\t.trigger = snd_hdspm_trigger,\n\t.pointer = snd_hdspm_hw_pointer,\n};\n\nstatic int snd_hdspm_create_hwdep(struct snd_card *card,\n\t\t\t\t  struct hdspm *hdspm)\n{\n\tstruct snd_hwdep *hw;\n\tint err;\n\n\terr = snd_hwdep_new(card, \"HDSPM hwdep\", 0, &hw);\n\tif (err < 0)\n\t\treturn err;\n\n\thdspm->hwdep = hw;\n\thw->private_data = hdspm;\n\tstrcpy(hw->name, \"HDSPM hwdep interface\");\n\n\thw->ops.open = snd_hdspm_hwdep_dummy_op;\n\thw->ops.ioctl = snd_hdspm_hwdep_ioctl;\n\thw->ops.ioctl_compat = snd_hdspm_hwdep_ioctl;\n\thw->ops.release = snd_hdspm_hwdep_dummy_op;\n\n\treturn 0;\n}\n\n\n \nstatic int snd_hdspm_preallocate_memory(struct hdspm *hdspm)\n{\n\tstruct snd_pcm *pcm;\n\tsize_t wanted;\n\n\tpcm = hdspm->pcm;\n\n\twanted = HDSPM_DMA_AREA_BYTES;\n\n\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\n\t\t\t\t\t      &hdspm->pci->dev,\n\t\t\t\t\t      wanted, wanted);\n\tdev_dbg(hdspm->card->dev, \" Preallocated %zd Bytes\\n\", wanted);\n\treturn 0;\n}\n\n \n \nstatic void hdspm_set_channel_dma_addr(struct hdspm *hdspm,\n\t\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t\t       unsigned int reg, int channel)\n{\n\tint i;\n\n\tfor (i = channel * 16; i < channel * 16 + 16; i++)\n\t\thdspm_write(hdspm, reg + 4 * i,\n\t\t\t    snd_pcm_sgbuf_get_addr(substream, 4096 * i));\n}\n\n\n \nstatic int snd_hdspm_create_pcm(struct snd_card *card,\n\t\t\t\tstruct hdspm *hdspm)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\thdspm->pcm = pcm;\n\tpcm->private_data = hdspm;\n\tstrcpy(pcm->name, hdspm->card_name);\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_hdspm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_hdspm_ops);\n\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\n\terr = snd_hdspm_preallocate_memory(hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)\n{\n\tint i;\n\n\tfor (i = 0; i < hdspm->midiPorts; i++)\n\t\tsnd_hdspm_flush_midi_input(hdspm, i);\n}\n\nstatic int snd_hdspm_create_alsa_devices(struct snd_card *card,\n\t\t\t\t\t struct hdspm *hdspm)\n{\n\tint err, i;\n\n\tdev_dbg(card->dev, \"Create card...\\n\");\n\terr = snd_hdspm_create_pcm(card, hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\ti = 0;\n\twhile (i < hdspm->midiPorts) {\n\t\terr = snd_hdspm_create_midi(card, hdspm, i);\n\t\tif (err < 0) {\n\t\t\treturn err;\n\t\t}\n\t\ti++;\n\t}\n\n\terr = snd_hdspm_create_controls(card, hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_hdspm_create_hwdep(card, hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(card->dev, \"proc init...\\n\");\n\tsnd_hdspm_proc_init(hdspm);\n\n\thdspm->system_sample_rate = -1;\n\thdspm->last_external_sample_rate = -1;\n\thdspm->last_internal_sample_rate = -1;\n\thdspm->playback_pid = -1;\n\thdspm->capture_pid = -1;\n\thdspm->capture_substream = NULL;\n\thdspm->playback_substream = NULL;\n\n\tdev_dbg(card->dev, \"Set defaults...\\n\");\n\terr = snd_hdspm_set_defaults(hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(card->dev, \"Update mixer controls...\\n\");\n\thdspm_update_simple_mixer_controls(hdspm);\n\n\tdev_dbg(card->dev, \"Initializing complete?\\n\");\n\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"error registering card\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(card->dev, \"... yes now\\n\");\n\n\treturn 0;\n}\n\nstatic int snd_hdspm_create(struct snd_card *card,\n\t\t\t    struct hdspm *hdspm)\n{\n\n\tstruct pci_dev *pci = hdspm->pci;\n\tint err;\n\tunsigned long io_extent;\n\n\thdspm->irq = -1;\n\thdspm->card = card;\n\n\tspin_lock_init(&hdspm->lock);\n\tINIT_WORK(&hdspm->midi_work, hdspm_midi_work);\n\n\tpci_read_config_word(hdspm->pci,\n\t\t\tPCI_CLASS_REVISION, &hdspm->firmware_rev);\n\n\tstrcpy(card->mixername, \"Xilinx FPGA\");\n\tstrcpy(card->driver, \"HDSPM\");\n\n\tswitch (hdspm->firmware_rev) {\n\tcase HDSPM_RAYDAT_REV:\n\t\thdspm->io_type = RayDAT;\n\t\thdspm->card_name = \"RME RayDAT\";\n\t\thdspm->midiPorts = 2;\n\t\tbreak;\n\tcase HDSPM_AIO_REV:\n\t\thdspm->io_type = AIO;\n\t\thdspm->card_name = \"RME AIO\";\n\t\thdspm->midiPorts = 1;\n\t\tbreak;\n\tcase HDSPM_MADIFACE_REV:\n\t\thdspm->io_type = MADIface;\n\t\thdspm->card_name = \"RME MADIface\";\n\t\thdspm->midiPorts = 1;\n\t\tbreak;\n\tdefault:\n\t\tif ((hdspm->firmware_rev == 0xf0) ||\n\t\t\t((hdspm->firmware_rev >= 0xe6) &&\n\t\t\t\t\t(hdspm->firmware_rev <= 0xea))) {\n\t\t\thdspm->io_type = AES32;\n\t\t\thdspm->card_name = \"RME AES32\";\n\t\t\thdspm->midiPorts = 2;\n\t\t} else if ((hdspm->firmware_rev == 0xd2) ||\n\t\t\t((hdspm->firmware_rev >= 0xc8)  &&\n\t\t\t\t(hdspm->firmware_rev <= 0xcf))) {\n\t\t\thdspm->io_type = MADI;\n\t\t\thdspm->card_name = \"RME MADI\";\n\t\t\thdspm->midiPorts = 3;\n\t\t} else {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"unknown firmware revision %x\\n\",\n\t\t\t\thdspm->firmware_rev);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_master(hdspm->pci);\n\n\terr = pcim_iomap_regions(pci, 1 << 0, \"hdspm\");\n\tif (err < 0)\n\t\treturn err;\n\n\thdspm->port = pci_resource_start(pci, 0);\n\tio_extent = pci_resource_len(pci, 0);\n\thdspm->iobase = pcim_iomap_table(pci)[0];\n\tdev_dbg(card->dev, \"remapped region (0x%lx) 0x%lx-0x%lx\\n\",\n\t\t\t(unsigned long)hdspm->iobase, hdspm->port,\n\t\t\thdspm->port + io_extent - 1);\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_hdspm_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, hdspm)) {\n\t\tdev_err(card->dev, \"unable to use IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\n\tdev_dbg(card->dev, \"use IRQ %d\\n\", pci->irq);\n\n\thdspm->irq = pci->irq;\n\tcard->sync_irq = hdspm->irq;\n\n\tdev_dbg(card->dev, \"kmalloc Mixer memory of %zd Bytes\\n\",\n\t\tsizeof(*hdspm->mixer));\n\thdspm->mixer = devm_kzalloc(&pci->dev, sizeof(*hdspm->mixer), GFP_KERNEL);\n\tif (!hdspm->mixer)\n\t\treturn -ENOMEM;\n\n\thdspm->port_names_in = NULL;\n\thdspm->port_names_out = NULL;\n\n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\thdspm->ss_in_channels = hdspm->ss_out_channels = AES32_CHANNELS;\n\t\thdspm->ds_in_channels = hdspm->ds_out_channels = AES32_CHANNELS;\n\t\thdspm->qs_in_channels = hdspm->qs_out_channels = AES32_CHANNELS;\n\n\t\thdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\n\t\t\tchannel_map_aes32;\n\t\thdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\n\t\t\tchannel_map_aes32;\n\t\thdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\n\t\t\tchannel_map_aes32;\n\t\thdspm->port_names_in_ss = hdspm->port_names_out_ss =\n\t\t\ttexts_ports_aes32;\n\t\thdspm->port_names_in_ds = hdspm->port_names_out_ds =\n\t\t\ttexts_ports_aes32;\n\t\thdspm->port_names_in_qs = hdspm->port_names_out_qs =\n\t\t\ttexts_ports_aes32;\n\n\t\thdspm->max_channels_out = hdspm->max_channels_in =\n\t\t\tAES32_CHANNELS;\n\t\thdspm->port_names_in = hdspm->port_names_out =\n\t\t\ttexts_ports_aes32;\n\t\thdspm->channel_map_in = hdspm->channel_map_out =\n\t\t\tchannel_map_aes32;\n\n\t\tbreak;\n\n\tcase MADI:\n\tcase MADIface:\n\t\thdspm->ss_in_channels = hdspm->ss_out_channels =\n\t\t\tMADI_SS_CHANNELS;\n\t\thdspm->ds_in_channels = hdspm->ds_out_channels =\n\t\t\tMADI_DS_CHANNELS;\n\t\thdspm->qs_in_channels = hdspm->qs_out_channels =\n\t\t\tMADI_QS_CHANNELS;\n\n\t\thdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\n\t\t\tchannel_map_unity_ss;\n\t\thdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\n\t\t\tchannel_map_unity_ss;\n\t\thdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\n\t\t\tchannel_map_unity_ss;\n\n\t\thdspm->port_names_in_ss = hdspm->port_names_out_ss =\n\t\t\ttexts_ports_madi;\n\t\thdspm->port_names_in_ds = hdspm->port_names_out_ds =\n\t\t\ttexts_ports_madi;\n\t\thdspm->port_names_in_qs = hdspm->port_names_out_qs =\n\t\t\ttexts_ports_madi;\n\t\tbreak;\n\n\tcase AIO:\n\t\thdspm->ss_in_channels = AIO_IN_SS_CHANNELS;\n\t\thdspm->ds_in_channels = AIO_IN_DS_CHANNELS;\n\t\thdspm->qs_in_channels = AIO_IN_QS_CHANNELS;\n\t\thdspm->ss_out_channels = AIO_OUT_SS_CHANNELS;\n\t\thdspm->ds_out_channels = AIO_OUT_DS_CHANNELS;\n\t\thdspm->qs_out_channels = AIO_OUT_QS_CHANNELS;\n\n\t\tif (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {\n\t\t\tdev_info(card->dev, \"AEB input board found\\n\");\n\t\t\thdspm->ss_in_channels += 4;\n\t\t\thdspm->ds_in_channels += 4;\n\t\t\thdspm->qs_in_channels += 4;\n\t\t}\n\n\t\tif (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBO_D)) {\n\t\t\tdev_info(card->dev, \"AEB output board found\\n\");\n\t\t\thdspm->ss_out_channels += 4;\n\t\t\thdspm->ds_out_channels += 4;\n\t\t\thdspm->qs_out_channels += 4;\n\t\t}\n\n\t\thdspm->channel_map_out_ss = channel_map_aio_out_ss;\n\t\thdspm->channel_map_out_ds = channel_map_aio_out_ds;\n\t\thdspm->channel_map_out_qs = channel_map_aio_out_qs;\n\n\t\thdspm->channel_map_in_ss = channel_map_aio_in_ss;\n\t\thdspm->channel_map_in_ds = channel_map_aio_in_ds;\n\t\thdspm->channel_map_in_qs = channel_map_aio_in_qs;\n\n\t\thdspm->port_names_in_ss = texts_ports_aio_in_ss;\n\t\thdspm->port_names_out_ss = texts_ports_aio_out_ss;\n\t\thdspm->port_names_in_ds = texts_ports_aio_in_ds;\n\t\thdspm->port_names_out_ds = texts_ports_aio_out_ds;\n\t\thdspm->port_names_in_qs = texts_ports_aio_in_qs;\n\t\thdspm->port_names_out_qs = texts_ports_aio_out_qs;\n\n\t\tbreak;\n\n\tcase RayDAT:\n\t\thdspm->ss_in_channels = hdspm->ss_out_channels =\n\t\t\tRAYDAT_SS_CHANNELS;\n\t\thdspm->ds_in_channels = hdspm->ds_out_channels =\n\t\t\tRAYDAT_DS_CHANNELS;\n\t\thdspm->qs_in_channels = hdspm->qs_out_channels =\n\t\t\tRAYDAT_QS_CHANNELS;\n\n\t\thdspm->max_channels_in = RAYDAT_SS_CHANNELS;\n\t\thdspm->max_channels_out = RAYDAT_SS_CHANNELS;\n\n\t\thdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\n\t\t\tchannel_map_raydat_ss;\n\t\thdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\n\t\t\tchannel_map_raydat_ds;\n\t\thdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\n\t\t\tchannel_map_raydat_qs;\n\t\thdspm->channel_map_in = hdspm->channel_map_out =\n\t\t\tchannel_map_raydat_ss;\n\n\t\thdspm->port_names_in_ss = hdspm->port_names_out_ss =\n\t\t\ttexts_ports_raydat_ss;\n\t\thdspm->port_names_in_ds = hdspm->port_names_out_ds =\n\t\t\ttexts_ports_raydat_ds;\n\t\thdspm->port_names_in_qs = hdspm->port_names_out_qs =\n\t\t\ttexts_ports_raydat_qs;\n\n\n\t\tbreak;\n\n\t}\n\n\t \n\tswitch (hdspm->io_type) {\n\tcase AIO:\n\tcase RayDAT:\n\t\tif (hdspm_read(hdspm, HDSPM_statusRegister2) &\n\t\t\t\tHDSPM_s2_tco_detect) {\n\t\t\thdspm->midiPorts++;\n\t\t\thdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);\n\t\t\tif (hdspm->tco)\n\t\t\t\thdspm_tco_write(hdspm);\n\n\t\t\tdev_info(card->dev, \"AIO/RayDAT TCO module found\\n\");\n\t\t} else {\n\t\t\thdspm->tco = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase MADI:\n\tcase AES32:\n\t\tif (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {\n\t\t\thdspm->midiPorts++;\n\t\t\thdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);\n\t\t\tif (hdspm->tco)\n\t\t\t\thdspm_tco_write(hdspm);\n\n\t\t\tdev_info(card->dev, \"MADI/AES TCO module found\\n\");\n\t\t} else {\n\t\t\thdspm->tco = NULL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\thdspm->tco = NULL;\n\t}\n\n\t \n\tswitch (hdspm->io_type) {\n\tcase AES32:\n\t\tif (hdspm->tco) {\n\t\t\thdspm->texts_autosync = texts_autosync_aes_tco;\n\t\t\thdspm->texts_autosync_items =\n\t\t\t\tARRAY_SIZE(texts_autosync_aes_tco);\n\t\t} else {\n\t\t\thdspm->texts_autosync = texts_autosync_aes;\n\t\t\thdspm->texts_autosync_items =\n\t\t\t\tARRAY_SIZE(texts_autosync_aes);\n\t\t}\n\t\tbreak;\n\n\tcase MADI:\n\t\tif (hdspm->tco) {\n\t\t\thdspm->texts_autosync = texts_autosync_madi_tco;\n\t\t\thdspm->texts_autosync_items = 4;\n\t\t} else {\n\t\t\thdspm->texts_autosync = texts_autosync_madi;\n\t\t\thdspm->texts_autosync_items = 3;\n\t\t}\n\t\tbreak;\n\n\tcase MADIface:\n\n\t\tbreak;\n\n\tcase RayDAT:\n\t\tif (hdspm->tco) {\n\t\t\thdspm->texts_autosync = texts_autosync_raydat_tco;\n\t\t\thdspm->texts_autosync_items = 9;\n\t\t} else {\n\t\t\thdspm->texts_autosync = texts_autosync_raydat;\n\t\t\thdspm->texts_autosync_items = 8;\n\t\t}\n\t\tbreak;\n\n\tcase AIO:\n\t\tif (hdspm->tco) {\n\t\t\thdspm->texts_autosync = texts_autosync_aio_tco;\n\t\t\thdspm->texts_autosync_items = 6;\n\t\t} else {\n\t\t\thdspm->texts_autosync = texts_autosync_aio;\n\t\t\thdspm->texts_autosync_items = 5;\n\t\t}\n\t\tbreak;\n\n\t}\n\n\tif (hdspm->io_type != MADIface) {\n\t\thdspm->serial = (hdspm_read(hdspm,\n\t\t\t\tHDSPM_midiStatusIn0)>>8) & 0xFFFFFF;\n\t\t \n\t\tif (!id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {\n\t\t\tsnprintf(card->id, sizeof(card->id),\n\t\t\t\t \"HDSPMx%06x\", hdspm->serial);\n\t\t\tsnd_card_set_id(card, card->id);\n\t\t}\n\t}\n\n\tdev_dbg(card->dev, \"create alsa devices.\\n\");\n\terr = snd_hdspm_create_alsa_devices(card, hdspm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_hdspm_initialize_midi_flush(hdspm);\n\n\treturn 0;\n}\n\n\nstatic void snd_hdspm_card_free(struct snd_card *card)\n{\n\tstruct hdspm *hdspm = card->private_data;\n\n\tif (hdspm->port) {\n\t\tcancel_work_sync(&hdspm->midi_work);\n\n\t\t \n\t\thdspm->control_register &=\n\t\t    ~(HDSPM_Start | HDSPM_AudioInterruptEnable |\n\t\t      HDSPM_Midi0InterruptEnable | HDSPM_Midi1InterruptEnable |\n\t\t      HDSPM_Midi2InterruptEnable | HDSPM_Midi3InterruptEnable);\n\t\thdspm_write(hdspm, HDSPM_controlRegister,\n\t\t\t    hdspm->control_register);\n\t}\n}\n\n\nstatic int snd_hdspm_probe(struct pci_dev *pci,\n\t\t\t   const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct hdspm *hdspm;\n\tstruct snd_card *card;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev],\n\t\t\t\tTHIS_MODULE, sizeof(*hdspm), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\thdspm = card->private_data;\n\tcard->private_free = snd_hdspm_card_free;\n\thdspm->dev = dev;\n\thdspm->pci = pci;\n\n\terr = snd_hdspm_create(card, hdspm);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (hdspm->io_type != MADIface) {\n\t\tsnprintf(card->shortname, sizeof(card->shortname), \"%s_%x\",\n\t\t\thdspm->card_name, hdspm->serial);\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t \"%s S/N 0x%x at 0x%lx, irq %d\",\n\t\t\t hdspm->card_name, hdspm->serial,\n\t\t\t hdspm->port, hdspm->irq);\n\t} else {\n\t\tsnprintf(card->shortname, sizeof(card->shortname), \"%s\",\n\t\t\t hdspm->card_name);\n\t\tsnprintf(card->longname, sizeof(card->longname),\n\t\t\t \"%s at 0x%lx, irq %d\",\n\t\t\t hdspm->card_name, hdspm->port, hdspm->irq);\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\tpci_set_drvdata(pci, card);\n\n\tdev++;\n\treturn 0;\n\n error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct pci_driver hdspm_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_hdspm_ids,\n\t.probe = snd_hdspm_probe,\n};\n\nmodule_pci_driver(hdspm_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}