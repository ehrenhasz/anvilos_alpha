{
  "module_name": "ens1370.c",
  "hash_id": "28f250a17388c6bda4834621138cd60bc77d03682128f30e456315ae8a37b569",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/ens1370.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#ifdef CHIP1371\n#include <sound/ac97_codec.h>\n#else\n#include <sound/ak4531_codec.h>\n#endif\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n\n#ifndef CHIP1371\n#undef CHIP1370\n#define CHIP1370\n#endif\n\n#ifdef CHIP1370\n#define DRIVER_NAME \"ENS1370\"\n#define CHIP_NAME \"ES1370\"  \n#else\n#define DRIVER_NAME \"ENS1371\"\n#define CHIP_NAME \"ES1371\"\n#endif\n\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Thomas Sailer <sailer@ife.ee.ethz.ch>\");\nMODULE_LICENSE(\"GPL\");\n#ifdef CHIP1370\nMODULE_DESCRIPTION(\"Ensoniq AudioPCI ES1370\");\n#endif\n#ifdef CHIP1371\nMODULE_DESCRIPTION(\"Ensoniq/Creative AudioPCI ES1371+\");\n#endif\n\n#if IS_REACHABLE(CONFIG_GAMEPORT)\n#define SUPPORT_JOYSTICK\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n#ifdef SUPPORT_JOYSTICK\n#ifdef CHIP1371\nstatic int joystick_port[SNDRV_CARDS];\n#else\nstatic bool joystick[SNDRV_CARDS];\n#endif\n#endif\n#ifdef CHIP1371\nstatic int spdif[SNDRV_CARDS];\nstatic int lineio[SNDRV_CARDS];\n#endif\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Ensoniq AudioPCI soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Ensoniq AudioPCI soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Ensoniq AudioPCI soundcard.\");\n#ifdef SUPPORT_JOYSTICK\n#ifdef CHIP1371\nmodule_param_hw_array(joystick_port, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(joystick_port, \"Joystick port address.\");\n#else\nmodule_param_array(joystick, bool, NULL, 0444);\nMODULE_PARM_DESC(joystick, \"Enable joystick.\");\n#endif\n#endif  \n#ifdef CHIP1371\nmodule_param_array(spdif, int, NULL, 0444);\nMODULE_PARM_DESC(spdif, \"S/PDIF output (-1 = none, 0 = auto, 1 = force).\");\nmodule_param_array(lineio, int, NULL, 0444);\nMODULE_PARM_DESC(lineio, \"Line In to Rear Out (0 = auto, 1 = force).\");\n#endif\n\n \n \n#define ES1371REV_ES1373_A  0x04\n#define ES1371REV_ES1373_B  0x06\n#define ES1371REV_CT5880_A  0x07\n#define CT5880REV_CT5880_C  0x02\n#define CT5880REV_CT5880_D  0x03\t \n#define CT5880REV_CT5880_E  0x04\t \n#define ES1371REV_ES1371_B  0x09\n#define EV1938REV_EV1938_A  0x00\n#define ES1371REV_ES1373_8  0x08\n\n \n\n#define ES_REG(ensoniq, x) ((ensoniq)->port + ES_REG_##x)\n\n#define ES_REG_CONTROL\t0x00\t \n#define   ES_1370_ADC_STOP\t(1<<31)\t\t \n#define   ES_1370_XCTL1 \t(1<<30)\t\t \n#define   ES_1373_BYPASS_P1\t(1<<31)\t\t \n#define   ES_1373_BYPASS_P2\t(1<<30)\t\t \n#define   ES_1373_BYPASS_R\t(1<<29)\t\t \n#define   ES_1373_TEST_BIT\t(1<<28)\t\t \n#define   ES_1373_RECEN_B\t(1<<27)\t\t \n#define   ES_1373_SPDIF_THRU\t(1<<26)\t\t \n#define   ES_1371_JOY_ASEL(o)\t(((o)&0x03)<<24) \n#define   ES_1371_JOY_ASELM\t(0x03<<24)\t \n#define   ES_1371_JOY_ASELI(i)  (((i)>>24)&0x03)\n#define   ES_1371_GPIO_IN(i)\t(((i)>>20)&0x0f) \n#define   ES_1370_PCLKDIVO(o)\t(((o)&0x1fff)<<16) \n#define   ES_1370_PCLKDIVM\t((0x1fff)<<16)\t \n#define   ES_1370_PCLKDIVI(i)\t(((i)>>16)&0x1fff) \n#define   ES_1371_GPIO_OUT(o)\t(((o)&0x0f)<<16) \n#define   ES_1371_GPIO_OUTM     (0x0f<<16)\t \n#define   ES_MSFMTSEL\t\t(1<<15)\t\t \n#define   ES_1370_M_SBB\t\t(1<<14)\t\t \n#define   ES_1371_SYNC_RES\t(1<<14)\t\t \n#define   ES_1370_WTSRSEL(o)\t(((o)&0x03)<<12) \n#define   ES_1370_WTSRSELM\t(0x03<<12)\t \n#define   ES_1371_ADC_STOP\t(1<<13)\t\t \n#define   ES_1371_PWR_INTRM\t(1<<12)\t\t \n#define   ES_1370_DAC_SYNC\t(1<<11)\t\t \n#define   ES_1371_M_CB\t\t(1<<11)\t\t \n#define   ES_CCB_INTRM\t\t(1<<10)\t\t \n#define   ES_1370_M_CB\t\t(1<<9)\t\t \n#define   ES_1370_XCTL0\t\t(1<<8)\t\t \n#define   ES_1371_PDLEV(o)\t(((o)&0x03)<<8)\t \n#define   ES_1371_PDLEVM\t(0x03<<8)\t \n#define   ES_BREQ\t\t(1<<7)\t\t \n#define   ES_DAC1_EN\t\t(1<<6)\t\t \n#define   ES_DAC2_EN\t\t(1<<5)\t\t \n#define   ES_ADC_EN\t\t(1<<4)\t\t \n#define   ES_UART_EN\t\t(1<<3)\t\t \n#define   ES_JYSTK_EN\t\t(1<<2)\t\t \n#define   ES_1370_CDC_EN\t(1<<1)\t\t \n#define   ES_1371_XTALCKDIS\t(1<<1)\t\t \n#define   ES_1370_SERR_DISABLE\t(1<<0)\t\t \n#define   ES_1371_PCICLKDIS     (1<<0)\t\t \n#define ES_REG_STATUS\t0x04\t \n#define   ES_INTR               (1<<31)\t\t \n#define   ES_1371_ST_AC97_RST\t(1<<29)\t\t \n#define   ES_1373_REAR_BIT27\t(1<<27)\t\t \n#define   ES_1373_REAR_BIT26\t(1<<26)\n#define   ES_1373_REAR_BIT24\t(1<<24)\n#define   ES_1373_GPIO_INT_EN(o)(((o)&0x0f)<<20) \n#define   ES_1373_SPDIF_EN\t(1<<18)\t\t \n#define   ES_1373_SPDIF_TEST\t(1<<17)\t\t \n#define   ES_1371_TEST          (1<<16)\t\t \n#define   ES_1373_GPIO_INT(i)\t(((i)&0x0f)>>12) \n#define   ES_1370_CSTAT\t\t(1<<10)\t\t \n#define   ES_1370_CBUSY         (1<<9)\t\t \n#define   ES_1370_CWRIP\t\t(1<<8)\t\t \n#define   ES_1371_SYNC_ERR\t(1<<8)\t\t \n#define   ES_1371_VC(i)         (((i)>>6)&0x03)\t \n#define   ES_1370_VC(i)\t\t(((i)>>5)&0x03)\t \n#define   ES_1371_MPWR          (1<<5)\t\t \n#define   ES_MCCB\t\t(1<<4)\t\t \n#define   ES_UART\t\t(1<<3)\t\t \n#define   ES_DAC1\t\t(1<<2)\t\t \n#define   ES_DAC2\t\t(1<<1)\t\t \n#define   ES_ADC\t\t(1<<0)\t\t \n#define ES_REG_UART_DATA 0x08\t \n#define ES_REG_UART_STATUS 0x09\t \n#define   ES_RXINT\t\t(1<<7)\t\t \n#define   ES_TXINT\t\t(1<<2)\t\t \n#define   ES_TXRDY\t\t(1<<1)\t\t \n#define   ES_RXRDY\t\t(1<<0)\t\t \n#define ES_REG_UART_CONTROL 0x09\t \n#define   ES_RXINTEN\t\t(1<<7)\t\t \n#define   ES_TXINTENO(o)\t(((o)&0x03)<<5)\t \n#define   ES_TXINTENM\t\t(0x03<<5)\t \n#define   ES_TXINTENI(i)\t(((i)>>5)&0x03)\n#define   ES_CNTRL(o)\t\t(((o)&0x03)<<0)\t \n#define   ES_CNTRLM\t\t(0x03<<0)\t \n#define ES_REG_UART_RES\t0x0a\t \n#define   ES_TEST_MODE\t\t(1<<0)\t\t \n#define ES_REG_MEM_PAGE\t0x0c\t \n#define   ES_MEM_PAGEO(o)\t(((o)&0x0f)<<0)\t \n#define   ES_MEM_PAGEM\t\t(0x0f<<0)\t \n#define   ES_MEM_PAGEI(i)\t(((i)>>0)&0x0f)  \n#define ES_REG_1370_CODEC 0x10\t \n#define   ES_1370_CODEC_WRITE(a,d) ((((a)&0xff)<<8)|(((d)&0xff)<<0))\n#define ES_REG_1371_CODEC 0x14\t \n#define   ES_1371_CODEC_RDY\t   (1<<31)\t \n#define   ES_1371_CODEC_WIP\t   (1<<30)\t \n#define   EV_1938_CODEC_MAGIC\t   (1<<26)\n#define   ES_1371_CODEC_PIRD\t   (1<<23)\t \n#define   ES_1371_CODEC_WRITE(a,d) ((((a)&0x7f)<<16)|(((d)&0xffff)<<0))\n#define   ES_1371_CODEC_READS(a)   ((((a)&0x7f)<<16)|ES_1371_CODEC_PIRD)\n#define   ES_1371_CODEC_READ(i)    (((i)>>0)&0xffff)\n\n#define ES_REG_1371_SMPRATE 0x10\t \n#define   ES_1371_SRC_RAM_ADDRO(o) (((o)&0x7f)<<25) \n#define   ES_1371_SRC_RAM_ADDRM\t   (0x7f<<25)\t \n#define   ES_1371_SRC_RAM_ADDRI(i) (((i)>>25)&0x7f) \n#define   ES_1371_SRC_RAM_WE\t   (1<<24)\t \n#define   ES_1371_SRC_RAM_BUSY     (1<<23)\t \n#define   ES_1371_SRC_DISABLE      (1<<22)\t \n#define   ES_1371_DIS_P1\t   (1<<21)\t \n#define   ES_1371_DIS_P2\t   (1<<20)\t \n#define   ES_1371_DIS_R1\t   (1<<19)\t \n#define   ES_1371_SRC_RAM_DATAO(o) (((o)&0xffff)<<0) \n#define   ES_1371_SRC_RAM_DATAM\t   (0xffff<<0)\t \n#define   ES_1371_SRC_RAM_DATAI(i) (((i)>>0)&0xffff) \n\n#define ES_REG_1371_LEGACY 0x18\t \n#define   ES_1371_JFAST\t\t(1<<31)\t\t \n#define   ES_1371_HIB\t\t(1<<30)\t\t \n#define   ES_1371_VSB\t\t(1<<29)\t\t \n#define   ES_1371_VMPUO(o)\t(((o)&0x03)<<27) \n#define   ES_1371_VMPUM\t\t(0x03<<27)\t \n#define   ES_1371_VMPUI(i)\t(((i)>>27)&0x03) \n#define   ES_1371_VCDCO(o)\t(((o)&0x03)<<25) \n#define   ES_1371_VCDCM\t\t(0x03<<25)\t \n#define   ES_1371_VCDCI(i)\t(((i)>>25)&0x03) \n#define   ES_1371_FIRQ\t\t(1<<24)\t\t \n#define   ES_1371_SDMACAP\t(1<<23)\t\t \n#define   ES_1371_SPICAP\t(1<<22)\t\t \n#define   ES_1371_MDMACAP\t(1<<21)\t\t \n#define   ES_1371_MPICAP\t(1<<20)\t\t \n#define   ES_1371_ADCAP\t\t(1<<19)\t\t \n#define   ES_1371_SVCAP\t\t(1<<18)\t\t \n#define   ES_1371_CDCCAP\t(1<<17)\t\t \n#define   ES_1371_BACAP\t\t(1<<16)\t\t \n#define   ES_1371_EXI(i)\t(((i)>>8)&0x07)\t \n#define   ES_1371_AI(i)\t\t(((i)>>3)&0x1f)\t \n#define   ES_1371_WR\t\t(1<<2)\t \n#define   ES_1371_LEGINT\t(1<<0)\t \n\n#define ES_REG_CHANNEL_STATUS 0x1c  \n\n#define ES_REG_SERIAL\t0x20\t \n#define   ES_1371_DAC_TEST\t(1<<22)\t\t \n#define   ES_P2_END_INCO(o)\t(((o)&0x07)<<19) \n#define   ES_P2_END_INCM\t(0x07<<19)\t \n#define   ES_P2_END_INCI(i)\t(((i)>>16)&0x07) \n#define   ES_P2_ST_INCO(o)\t(((o)&0x07)<<16) \n#define   ES_P2_ST_INCM\t\t(0x07<<16)\t \n#define   ES_P2_ST_INCI(i)\t(((i)<<16)&0x07) \n#define   ES_R1_LOOP_SEL\t(1<<15)\t\t \n#define   ES_P2_LOOP_SEL\t(1<<14)\t\t \n#define   ES_P1_LOOP_SEL\t(1<<13)\t\t \n#define   ES_P2_PAUSE\t\t(1<<12)\t\t \n#define   ES_P1_PAUSE\t\t(1<<11)\t\t \n#define   ES_R1_INT_EN\t\t(1<<10)\t\t \n#define   ES_P2_INT_EN\t\t(1<<9)\t\t \n#define   ES_P1_INT_EN\t\t(1<<8)\t\t \n#define   ES_P1_SCT_RLD\t\t(1<<7)\t\t \n#define   ES_P2_DAC_SEN\t\t(1<<6)\t\t \n#define   ES_R1_MODEO(o)\t(((o)&0x03)<<4)\t \n#define   ES_R1_MODEM\t\t(0x03<<4)\t \n#define   ES_R1_MODEI(i)\t(((i)>>4)&0x03)\n#define   ES_P2_MODEO(o)\t(((o)&0x03)<<2)\t \n#define   ES_P2_MODEM\t\t(0x03<<2)\t \n#define   ES_P2_MODEI(i)\t(((i)>>2)&0x03)\n#define   ES_P1_MODEO(o)\t(((o)&0x03)<<0)\t \n#define   ES_P1_MODEM\t\t(0x03<<0)\t \n#define   ES_P1_MODEI(i)\t(((i)>>0)&0x03)\n\n#define ES_REG_DAC1_COUNT 0x24\t \n#define ES_REG_DAC2_COUNT 0x28\t \n#define ES_REG_ADC_COUNT  0x2c\t \n#define   ES_REG_CURR_COUNT(i)  (((i)>>16)&0xffff)\n#define   ES_REG_COUNTO(o)\t(((o)&0xffff)<<0)\n#define   ES_REG_COUNTM\t\t(0xffff<<0)\n#define   ES_REG_COUNTI(i)\t(((i)>>0)&0xffff)\n\n#define ES_REG_DAC1_FRAME 0x30\t \n#define ES_REG_DAC1_SIZE  0x34\t \n#define ES_REG_DAC2_FRAME 0x38\t \n#define ES_REG_DAC2_SIZE  0x3c\t \n#define ES_REG_ADC_FRAME  0x30\t \n#define ES_REG_ADC_SIZE\t  0x34\t \n#define   ES_REG_FCURR_COUNTO(o) (((o)&0xffff)<<16)\n#define   ES_REG_FCURR_COUNTM    (0xffff<<16)\n#define   ES_REG_FCURR_COUNTI(i) (((i)>>14)&0x3fffc)\n#define   ES_REG_FSIZEO(o)\t (((o)&0xffff)<<0)\n#define   ES_REG_FSIZEM\t\t (0xffff<<0)\n#define   ES_REG_FSIZEI(i)\t (((i)>>0)&0xffff)\n#define ES_REG_PHANTOM_FRAME 0x38  \n#define ES_REG_PHANTOM_COUNT 0x3c  \n\n#define ES_REG_UART_FIFO  0x30\t \n#define   ES_REG_UF_VALID\t (1<<8)\n#define   ES_REG_UF_BYTEO(o)\t (((o)&0xff)<<0)\n#define   ES_REG_UF_BYTEM\t (0xff<<0)\n#define   ES_REG_UF_BYTEI(i)\t (((i)>>0)&0xff)\n\n\n \n\n#define ES_PAGE_DAC\t0x0c\n#define ES_PAGE_ADC\t0x0d\n#define ES_PAGE_UART\t0x0e\n#define ES_PAGE_UART1\t0x0f\n\n \n\n#define ES_SMPREG_DAC1\t\t0x70\n#define ES_SMPREG_DAC2\t\t0x74\n#define ES_SMPREG_ADC\t\t0x78\n#define ES_SMPREG_VOL_ADC\t0x6c\n#define ES_SMPREG_VOL_DAC1\t0x7c\n#define ES_SMPREG_VOL_DAC2\t0x7e\n#define ES_SMPREG_TRUNC_N\t0x00\n#define ES_SMPREG_INT_REGS\t0x01\n#define ES_SMPREG_ACCUM_FRAC\t0x02\n#define ES_SMPREG_VFREQ_FRAC\t0x03\n\n \n\n#define ES_1370_SRCLOCK\t   1411200\n#define ES_1370_SRTODIV(x) (ES_1370_SRCLOCK/(x)-2)\n\n \n\n#define ES_MODE_PLAY1\t0x0001\n#define ES_MODE_PLAY2\t0x0002\n#define ES_MODE_CAPTURE\t0x0004\n\n#define ES_MODE_OUTPUT\t0x0001\t \n#define ES_MODE_INPUT\t0x0002\t \n\n \n\nstruct ensoniq {\n\tspinlock_t reg_lock;\n\tstruct mutex src_mutex;\n\n\tint irq;\n\n\tunsigned long playback1size;\n\tunsigned long playback2size;\n\tunsigned long capture3size;\n\n\tunsigned long port;\n\tunsigned int mode;\n\tunsigned int uartm;\t \n\n\tunsigned int ctrl;\t \n\tunsigned int sctrl;\t \n\tunsigned int cssr;\t \n\tunsigned int uartc;\t \n\tunsigned int rev;\t \n\n\tunion {\n#ifdef CHIP1371\n\t\tstruct {\n\t\t\tstruct snd_ac97 *ac97;\n\t\t} es1371;\n#else\n\t\tstruct {\n\t\t\tint pclkdiv_lock;\n\t\t\tstruct snd_ak4531 *ak4531;\n\t\t} es1370;\n#endif\n\t} u;\n\n\tstruct pci_dev *pci;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm1;\t \n\tstruct snd_pcm *pcm2;\t \n\tstruct snd_pcm_substream *playback1_substream;\n\tstruct snd_pcm_substream *playback2_substream;\n\tstruct snd_pcm_substream *capture_substream;\n\tunsigned int p1_dma_size;\n\tunsigned int p2_dma_size;\n\tunsigned int c_dma_size;\n\tunsigned int p1_period_size;\n\tunsigned int p2_period_size;\n\tunsigned int c_period_size;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *midi_input;\n\tstruct snd_rawmidi_substream *midi_output;\n\n\tunsigned int spdif;\n\tunsigned int spdif_default;\n\tunsigned int spdif_stream;\n\n#ifdef CHIP1370\n\tstruct snd_dma_buffer *dma_bug;\n#endif\n\n#ifdef SUPPORT_JOYSTICK\n\tstruct gameport *gameport;\n#endif\n};\n\nstatic irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id);\n\nstatic const struct pci_device_id snd_audiopci_ids[] = {\n#ifdef CHIP1370\n\t{ PCI_VDEVICE(ENSONIQ, 0x5000), 0, },\t \n#endif\n#ifdef CHIP1371\n\t{ PCI_VDEVICE(ENSONIQ, 0x1371), 0, },\t \n\t{ PCI_VDEVICE(ENSONIQ, 0x5880), 0, },\t \n\t{ PCI_VDEVICE(ECTIVA, 0x8938), 0, },\t \n#endif\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_audiopci_ids);\n\n \n\n#define POLL_COUNT\t0xa000\n\n#ifdef CHIP1370\nstatic const unsigned int snd_es1370_fixed_rates[] =\n\t{5512, 11025, 22050, 44100};\nstatic const struct snd_pcm_hw_constraint_list snd_es1370_hw_constraints_rates = {\n\t.count = 4, \n\t.list = snd_es1370_fixed_rates,\n\t.mask = 0,\n};\nstatic const struct snd_ratnum es1370_clock = {\n\t.num = ES_1370_SRCLOCK,\n\t.den_min = 29, \n\t.den_max = 353,\n\t.den_step = 1,\n};\nstatic const struct snd_pcm_hw_constraint_ratnums snd_es1370_hw_constraints_clock = {\n\t.nrats = 1,\n\t.rats = &es1370_clock,\n};\n#else\nstatic const struct snd_ratden es1371_dac_clock = {\n\t.num_min = 3000 * (1 << 15),\n\t.num_max = 48000 * (1 << 15),\n\t.num_step = 3000,\n\t.den = 1 << 15,\n};\nstatic const struct snd_pcm_hw_constraint_ratdens snd_es1371_hw_constraints_dac_clock = {\n\t.nrats = 1,\n\t.rats = &es1371_dac_clock,\n};\nstatic const struct snd_ratnum es1371_adc_clock = {\n\t.num = 48000 << 15,\n\t.den_min = 32768, \n\t.den_max = 393216,\n\t.den_step = 1,\n};\nstatic const struct snd_pcm_hw_constraint_ratnums snd_es1371_hw_constraints_adc_clock = {\n\t.nrats = 1,\n\t.rats = &es1371_adc_clock,\n};\n#endif\nstatic const unsigned int snd_ensoniq_sample_shift[] =\n\t{0, 1, 1, 2};\n\n \n\n#ifdef CHIP1371\n\nstatic unsigned int snd_es1371_wait_src_ready(struct ensoniq * ensoniq)\n{\n\tunsigned int t, r = 0;\n\n\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\tr = inl(ES_REG(ensoniq, 1371_SMPRATE));\n\t\tif ((r & ES_1371_SRC_RAM_BUSY) == 0)\n\t\t\treturn r;\n\t\tcond_resched();\n\t}\n\tdev_err(ensoniq->card->dev, \"wait src ready timeout 0x%lx [0x%x]\\n\",\n\t\t   ES_REG(ensoniq, 1371_SMPRATE), r);\n\treturn 0;\n}\n\nstatic unsigned int snd_es1371_src_read(struct ensoniq * ensoniq, unsigned short reg)\n{\n\tunsigned int temp, i, orig, r;\n\n\t \n\ttemp = orig = snd_es1371_wait_src_ready(ensoniq);\n\n\t \n\tr = temp & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\n\t\t    ES_1371_DIS_P2 | ES_1371_DIS_R1);\n\tr |= ES_1371_SRC_RAM_ADDRO(reg) | 0x10000;\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\n\t \n\ttemp = snd_es1371_wait_src_ready(ensoniq);\n\t\n\tif ((temp & 0x00870000) != 0x00010000) {\n\t\t \n\t\tfor (i = 0; i < POLL_COUNT; i++) {\n\t\t\ttemp = inl(ES_REG(ensoniq, 1371_SMPRATE));\n\t\t\tif ((temp & 0x00870000) == 0x00010000)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \t\n\tr = orig & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\n\t\t   ES_1371_DIS_P2 | ES_1371_DIS_R1);\n\tr |= ES_1371_SRC_RAM_ADDRO(reg);\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\t\n\treturn temp;\n}\n\nstatic void snd_es1371_src_write(struct ensoniq * ensoniq,\n\t\t\t\t unsigned short reg, unsigned short data)\n{\n\tunsigned int r;\n\n\tr = snd_es1371_wait_src_ready(ensoniq) &\n\t    (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\n\t     ES_1371_DIS_P2 | ES_1371_DIS_R1);\n\tr |= ES_1371_SRC_RAM_ADDRO(reg) | ES_1371_SRC_RAM_DATAO(data);\n\toutl(r | ES_1371_SRC_RAM_WE, ES_REG(ensoniq, 1371_SMPRATE));\n}\n\n#endif  \n\n#ifdef CHIP1370\n\nstatic void snd_es1370_codec_write(struct snd_ak4531 *ak4531,\n\t\t\t\t   unsigned short reg, unsigned short val)\n{\n\tstruct ensoniq *ensoniq = ak4531->private_data;\n\tunsigned long end_time = jiffies + HZ / 10;\n\n#if 0\n\tdev_dbg(ensoniq->card->dev,\n\t       \"CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\\n\",\n\t       reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));\n#endif\n\tdo {\n\t\tif (!(inl(ES_REG(ensoniq, STATUS)) & ES_1370_CSTAT)) {\n\t\t\toutw(ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));\n\t\t\treturn;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_after(end_time, jiffies));\n\tdev_err(ensoniq->card->dev, \"codec write timeout, status = 0x%x\\n\",\n\t\t   inl(ES_REG(ensoniq, STATUS)));\n}\n\n#endif  \n\n#ifdef CHIP1371\n\nstatic inline bool is_ev1938(struct ensoniq *ensoniq)\n{\n\treturn ensoniq->pci->device == 0x8938;\n}\n\nstatic void snd_es1371_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t   unsigned short reg, unsigned short val)\n{\n\tstruct ensoniq *ensoniq = ac97->private_data;\n\tunsigned int t, x, flag;\n\n\tflag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;\n\tmutex_lock(&ensoniq->src_mutex);\n\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\tif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {\n\t\t\t \n\t\t\tx = snd_es1371_wait_src_ready(ensoniq);\n\t\t\toutl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\n\t\t\t           ES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,\n\t\t\t     ES_REG(ensoniq, 1371_SMPRATE));\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\n\t\t\t\t    0x00000000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\n\t\t\t\t    0x00010000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutl(ES_1371_CODEC_WRITE(reg, val) | flag,\n\t\t\t     ES_REG(ensoniq, 1371_CODEC));\n\t\t\t \n\t\t\tsnd_es1371_wait_src_ready(ensoniq);\n\t\t\toutl(x, ES_REG(ensoniq, 1371_SMPRATE));\n\t\t\tmutex_unlock(&ensoniq->src_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&ensoniq->src_mutex);\n\tdev_err(ensoniq->card->dev, \"codec write timeout at 0x%lx [0x%x]\\n\",\n\t\t   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));\n}\n\nstatic unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t    unsigned short reg)\n{\n\tstruct ensoniq *ensoniq = ac97->private_data;\n\tunsigned int t, x, flag, fail = 0;\n\n\tflag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;\n      __again:\n\tmutex_lock(&ensoniq->src_mutex);\n\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\tif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {\n\t\t\t \n\t\t\tx = snd_es1371_wait_src_ready(ensoniq);\n\t\t\toutl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |\n\t\t\t           ES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,\n\t\t\t     ES_REG(ensoniq, 1371_SMPRATE));\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\n\t\t\t\t    0x00000000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tif ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==\n\t\t\t\t    0x00010000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutl(ES_1371_CODEC_READS(reg) | flag,\n\t\t\t     ES_REG(ensoniq, 1371_CODEC));\n\t\t\t \n\t\t\tsnd_es1371_wait_src_ready(ensoniq);\n\t\t\toutl(x, ES_REG(ensoniq, 1371_SMPRATE));\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tif (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP))\n\t\t\t\t\tbreak;\t\t\n\t\t\t}\n\t\t\t \n\t\t\tfor (t = 0; t < POLL_COUNT; t++) {\n\t\t\t\tx = inl(ES_REG(ensoniq, 1371_CODEC));\n\t\t\t\tif (x & ES_1371_CODEC_RDY) {\n\t\t\t\t\tif (is_ev1938(ensoniq)) {\n\t\t\t\t\t\tfor (t = 0; t < 100; t++)\n\t\t\t\t\t\t\tinl(ES_REG(ensoniq, CONTROL));\n\t\t\t\t\t\tx = inl(ES_REG(ensoniq, 1371_CODEC));\n\t\t\t\t\t}\n\t\t\t\t\tmutex_unlock(&ensoniq->src_mutex);\n\t\t\t\t\treturn ES_1371_CODEC_READ(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&ensoniq->src_mutex);\n\t\t\tif (++fail > 10) {\n\t\t\t\tdev_err(ensoniq->card->dev,\n\t\t\t\t\t\"codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\\n\",\n\t\t\t\t\t   ES_REG(ensoniq, 1371_CODEC), reg,\n\t\t\t\t\t   inl(ES_REG(ensoniq, 1371_CODEC)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto __again;\n\t\t}\n\t}\n\tmutex_unlock(&ensoniq->src_mutex);\n\tdev_err(ensoniq->card->dev, \"codec read timeout at 0x%lx [0x%x]\\n\",\n\t\t   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));\n\treturn 0;\n}\n\nstatic void snd_es1371_codec_wait(struct snd_ac97 *ac97)\n{\n\tmsleep(750);\n\tsnd_es1371_codec_read(ac97, AC97_RESET);\n\tsnd_es1371_codec_read(ac97, AC97_VENDOR_ID1);\n\tsnd_es1371_codec_read(ac97, AC97_VENDOR_ID2);\n\tmsleep(50);\n}\n\nstatic void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)\n{\n\tunsigned int n, truncm, freq;\n\n\tmutex_lock(&ensoniq->src_mutex);\n\tn = rate / 3000;\n\tif ((1 << n) & ((1 << 15) | (1 << 13) | (1 << 11) | (1 << 9)))\n\t\tn--;\n\ttruncm = (21 * n - 1) | 1;\n\tfreq = ((48000UL << 15) / rate) * n;\n\tif (rate >= 24000) {\n\t\tif (truncm > 239)\n\t\t\ttruncm = 239;\n\t\tsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,\n\t\t\t\t(((239 - truncm) >> 1) << 9) | (n << 4));\n\t} else {\n\t\tif (truncm > 119)\n\t\t\ttruncm = 119;\n\t\tsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,\n\t\t\t\t0x8000 | (((119 - truncm) >> 1) << 9) | (n << 4));\n\t}\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS,\n\t\t\t     (snd_es1371_src_read(ensoniq, ES_SMPREG_ADC +\n\t\t\t\t\t\t  ES_SMPREG_INT_REGS) & 0x00ff) |\n\t\t\t     ((freq >> 5) & 0xfc00));\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);\n\tmutex_unlock(&ensoniq->src_mutex);\n}\n\nstatic void snd_es1371_dac1_rate(struct ensoniq * ensoniq, unsigned int rate)\n{\n\tunsigned int freq, r;\n\n\tmutex_lock(&ensoniq->src_mutex);\n\tfreq = DIV_ROUND_CLOSEST(rate << 15, 3000);\n\tr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\n\t\t\t\t\t\t   ES_1371_DIS_P2 | ES_1371_DIS_R1)) |\n\t\tES_1371_DIS_P1;\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS,\n\t\t\t     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC1 +\n\t\t\t\t\t\t  ES_SMPREG_INT_REGS) & 0x00ff) |\n\t\t\t     ((freq >> 5) & 0xfc00));\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);\n\tr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\n\t\t\t\t\t\t   ES_1371_DIS_P2 | ES_1371_DIS_R1));\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\tmutex_unlock(&ensoniq->src_mutex);\n}\n\nstatic void snd_es1371_dac2_rate(struct ensoniq * ensoniq, unsigned int rate)\n{\n\tunsigned int freq, r;\n\n\tmutex_lock(&ensoniq->src_mutex);\n\tfreq = DIV_ROUND_CLOSEST(rate << 15, 3000);\n\tr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\n\t\t\t\t\t\t   ES_1371_DIS_P1 | ES_1371_DIS_R1)) |\n\t\tES_1371_DIS_P2;\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS,\n\t\t\t     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC2 +\n\t\t\t\t\t\t  ES_SMPREG_INT_REGS) & 0x00ff) |\n\t\t\t     ((freq >> 5) & 0xfc00));\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC,\n\t\t\t     freq & 0x7fff);\n\tr = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |\n\t\t\t\t\t\t   ES_1371_DIS_P1 | ES_1371_DIS_R1));\n\toutl(r, ES_REG(ensoniq, 1371_SMPRATE));\n\tmutex_unlock(&ensoniq->src_mutex);\n}\n\n#endif  \n\nstatic int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t{\n\t\tunsigned int what = 0;\n\t\tstruct snd_pcm_substream *s;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == ensoniq->playback1_substream) {\n\t\t\t\twhat |= ES_P1_PAUSE;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == ensoniq->playback2_substream) {\n\t\t\t\twhat |= ES_P2_PAUSE;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == ensoniq->capture_substream)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock(&ensoniq->reg_lock);\n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\n\t\t\tensoniq->sctrl |= what;\n\t\telse\n\t\t\tensoniq->sctrl &= ~what;\n\t\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\t\tspin_unlock(&ensoniq->reg_lock);\n\t\tbreak;\n\t}\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t{\n\t\tunsigned int what = 0;\n\t\tstruct snd_pcm_substream *s;\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == ensoniq->playback1_substream) {\n\t\t\t\twhat |= ES_DAC1_EN;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == ensoniq->playback2_substream) {\n\t\t\t\twhat |= ES_DAC2_EN;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == ensoniq->capture_substream) {\n\t\t\t\twhat |= ES_ADC_EN;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t}\n\t\t}\n\t\tspin_lock(&ensoniq->reg_lock);\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START)\n\t\t\tensoniq->ctrl |= what;\n\t\telse\n\t\t\tensoniq->ctrl &= ~what;\n\t\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\t\tspin_unlock(&ensoniq->reg_lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_ensoniq_playback1_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int mode = 0;\n\n\tensoniq->p1_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tensoniq->p1_period_size = snd_pcm_lib_period_bytes(substream);\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tmode |= 0x02;\n\tif (runtime->channels > 1)\n\t\tmode |= 0x01;\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tensoniq->ctrl &= ~ES_DAC1_EN;\n#ifdef CHIP1371\n\t \n\tif (runtime->rate == 48000)\n\t\tensoniq->ctrl |= ES_1373_BYPASS_P1;\n\telse\n\t\tensoniq->ctrl &= ~ES_1373_BYPASS_P1;\n#endif\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\n\toutl(runtime->dma_addr, ES_REG(ensoniq, DAC1_FRAME));\n\toutl((ensoniq->p1_dma_size >> 2) - 1, ES_REG(ensoniq, DAC1_SIZE));\n\tensoniq->sctrl &= ~(ES_P1_LOOP_SEL | ES_P1_PAUSE | ES_P1_SCT_RLD | ES_P1_MODEM);\n\tensoniq->sctrl |= ES_P1_INT_EN | ES_P1_MODEO(mode);\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\toutl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\n\t     ES_REG(ensoniq, DAC1_COUNT));\n#ifdef CHIP1370\n\tensoniq->ctrl &= ~ES_1370_WTSRSELM;\n\tswitch (runtime->rate) {\n\tcase 5512: ensoniq->ctrl |= ES_1370_WTSRSEL(0); break;\n\tcase 11025: ensoniq->ctrl |= ES_1370_WTSRSEL(1); break;\n\tcase 22050: ensoniq->ctrl |= ES_1370_WTSRSEL(2); break;\n\tcase 44100: ensoniq->ctrl |= ES_1370_WTSRSEL(3); break;\n\tdefault: snd_BUG();\n\t}\n#endif\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n#ifndef CHIP1370\n\tsnd_es1371_dac1_rate(ensoniq, runtime->rate);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ensoniq_playback2_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int mode = 0;\n\n\tensoniq->p2_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tensoniq->p2_period_size = snd_pcm_lib_period_bytes(substream);\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tmode |= 0x02;\n\tif (runtime->channels > 1)\n\t\tmode |= 0x01;\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tensoniq->ctrl &= ~ES_DAC2_EN;\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\n\toutl(runtime->dma_addr, ES_REG(ensoniq, DAC2_FRAME));\n\toutl((ensoniq->p2_dma_size >> 2) - 1, ES_REG(ensoniq, DAC2_SIZE));\n\tensoniq->sctrl &= ~(ES_P2_LOOP_SEL | ES_P2_PAUSE | ES_P2_DAC_SEN |\n\t\t\t    ES_P2_END_INCM | ES_P2_ST_INCM | ES_P2_MODEM);\n\tensoniq->sctrl |= ES_P2_INT_EN | ES_P2_MODEO(mode) |\n\t\t\t  ES_P2_END_INCO(mode & 2 ? 2 : 1) | ES_P2_ST_INCO(0);\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\toutl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\n\t     ES_REG(ensoniq, DAC2_COUNT));\n#ifdef CHIP1370\n\tif (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_CAPTURE)) {\n\t\tensoniq->ctrl &= ~ES_1370_PCLKDIVM;\n\t\tensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));\n\t\tensoniq->u.es1370.pclkdiv_lock |= ES_MODE_PLAY2;\n\t}\n#endif\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n#ifndef CHIP1370\n\tsnd_es1371_dac2_rate(ensoniq, runtime->rate);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ensoniq_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int mode = 0;\n\n\tensoniq->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\n\tensoniq->c_period_size = snd_pcm_lib_period_bytes(substream);\n\tif (snd_pcm_format_width(runtime->format) == 16)\n\t\tmode |= 0x02;\n\tif (runtime->channels > 1)\n\t\tmode |= 0x01;\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tensoniq->ctrl &= ~ES_ADC_EN;\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\n\toutl(runtime->dma_addr, ES_REG(ensoniq, ADC_FRAME));\n\toutl((ensoniq->c_dma_size >> 2) - 1, ES_REG(ensoniq, ADC_SIZE));\n\tensoniq->sctrl &= ~(ES_R1_LOOP_SEL | ES_R1_MODEM);\n\tensoniq->sctrl |= ES_R1_INT_EN | ES_R1_MODEO(mode);\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\toutl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1,\n\t     ES_REG(ensoniq, ADC_COUNT));\n#ifdef CHIP1370\n\tif (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_PLAY2)) {\n\t\tensoniq->ctrl &= ~ES_1370_PCLKDIVM;\n\t\tensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));\n\t\tensoniq->u.es1370.pclkdiv_lock |= ES_MODE_CAPTURE;\n\t}\n#endif\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n#ifndef CHIP1370\n\tsnd_es1371_adc_rate(ensoniq, runtime->rate);\n#endif\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_ensoniq_playback1_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tspin_lock(&ensoniq->reg_lock);\n\tif (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC1_EN) {\n\t\toutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\n\t\tptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC1_SIZE)));\n\t\tptr = bytes_to_frames(substream->runtime, ptr);\n\t} else {\n\t\tptr = 0;\n\t}\n\tspin_unlock(&ensoniq->reg_lock);\n\treturn ptr;\n}\n\nstatic snd_pcm_uframes_t snd_ensoniq_playback2_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tspin_lock(&ensoniq->reg_lock);\n\tif (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC2_EN) {\n\t\toutl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));\n\t\tptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC2_SIZE)));\n\t\tptr = bytes_to_frames(substream->runtime, ptr);\n\t} else {\n\t\tptr = 0;\n\t}\n\tspin_unlock(&ensoniq->reg_lock);\n\treturn ptr;\n}\n\nstatic snd_pcm_uframes_t snd_ensoniq_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tspin_lock(&ensoniq->reg_lock);\n\tif (inl(ES_REG(ensoniq, CONTROL)) & ES_ADC_EN) {\n\t\toutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\n\t\tptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, ADC_SIZE)));\n\t\tptr = bytes_to_frames(substream->runtime, ptr);\n\t} else {\n\t\tptr = 0;\n\t}\n\tspin_unlock(&ensoniq->reg_lock);\n\treturn ptr;\n}\n\nstatic const struct snd_pcm_hardware snd_ensoniq_playback1 =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\n#ifndef CHIP1370\n\t\t\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n#else\n\t\t\t\t(SNDRV_PCM_RATE_KNOT | \t \n\t\t\t\t SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_22050 | \n\t\t\t\t SNDRV_PCM_RATE_44100),\n#endif\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ensoniq_playback2 =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE | \n\t\t\t\t SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic const struct snd_pcm_hardware snd_ensoniq_capture =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t4000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t64,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic int snd_ensoniq_playback1_open(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tensoniq->mode |= ES_MODE_PLAY1;\n\tensoniq->playback1_substream = substream;\n\truntime->hw = snd_ensoniq_playback1;\n\tsnd_pcm_set_sync(substream);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif (ensoniq->spdif && ensoniq->playback2_substream == NULL)\n\t\tensoniq->spdif_stream = ensoniq->spdif_default;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n#ifdef CHIP1370\n\tsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &snd_es1370_hw_constraints_rates);\n#else\n\tsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_es1371_hw_constraints_dac_clock);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ensoniq_playback2_open(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tensoniq->mode |= ES_MODE_PLAY2;\n\tensoniq->playback2_substream = substream;\n\truntime->hw = snd_ensoniq_playback2;\n\tsnd_pcm_set_sync(substream);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif (ensoniq->spdif && ensoniq->playback1_substream == NULL)\n\t\tensoniq->spdif_stream = ensoniq->spdif_default;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n#ifdef CHIP1370\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_es1370_hw_constraints_clock);\n#else\n\tsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_es1371_hw_constraints_dac_clock);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ensoniq_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tensoniq->mode |= ES_MODE_CAPTURE;\n\tensoniq->capture_substream = substream;\n\truntime->hw = snd_ensoniq_capture;\n\tsnd_pcm_set_sync(substream);\n#ifdef CHIP1370\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_es1370_hw_constraints_clock);\n#else\n\tsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t      &snd_es1371_hw_constraints_adc_clock);\n#endif\n\treturn 0;\n}\n\nstatic int snd_ensoniq_playback1_close(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\n\tensoniq->playback1_substream = NULL;\n\tensoniq->mode &= ~ES_MODE_PLAY1;\n\treturn 0;\n}\n\nstatic int snd_ensoniq_playback2_close(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\n\tensoniq->playback2_substream = NULL;\n\tspin_lock_irq(&ensoniq->reg_lock);\n#ifdef CHIP1370\n\tensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_PLAY2;\n#endif\n\tensoniq->mode &= ~ES_MODE_PLAY2;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ensoniq_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct ensoniq *ensoniq = snd_pcm_substream_chip(substream);\n\n\tensoniq->capture_substream = NULL;\n\tspin_lock_irq(&ensoniq->reg_lock);\n#ifdef CHIP1370\n\tensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_CAPTURE;\n#endif\n\tensoniq->mode &= ~ES_MODE_CAPTURE;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_ensoniq_playback1_ops = {\n\t.open =\t\tsnd_ensoniq_playback1_open,\n\t.close =\tsnd_ensoniq_playback1_close,\n\t.prepare =\tsnd_ensoniq_playback1_prepare,\n\t.trigger =\tsnd_ensoniq_trigger,\n\t.pointer =\tsnd_ensoniq_playback1_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ensoniq_playback2_ops = {\n\t.open =\t\tsnd_ensoniq_playback2_open,\n\t.close =\tsnd_ensoniq_playback2_close,\n\t.prepare =\tsnd_ensoniq_playback2_prepare,\n\t.trigger =\tsnd_ensoniq_trigger,\n\t.pointer =\tsnd_ensoniq_playback2_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_ensoniq_capture_ops = {\n\t.open =\t\tsnd_ensoniq_capture_open,\n\t.close =\tsnd_ensoniq_capture_close,\n\t.prepare =\tsnd_ensoniq_capture_prepare,\n\t.trigger =\tsnd_ensoniq_trigger,\n\t.pointer =\tsnd_ensoniq_capture_pointer,\n};\n\nstatic const struct snd_pcm_chmap_elem surround_map[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ }\n};\n\nstatic int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(ensoniq->card, CHIP_NAME \"/1\", device, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CHIP1370\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);\n#else\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);\n#endif\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ensoniq_capture_ops);\n\n\tpcm->private_data = ensoniq;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, CHIP_NAME \" DAC2/ADC\");\n\tensoniq->pcm1 = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ensoniq->pci->dev, 64*1024, 128*1024);\n\n#ifdef CHIP1370\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     surround_map, 2, 0, NULL);\n#else\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_std_chmaps, 2, 0, NULL);\n#endif\n\treturn err;\n}\n\nstatic int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(ensoniq->card, CHIP_NAME \"/2\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CHIP1370\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);\n#else\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);\n#endif\n\tpcm->private_data = ensoniq;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, CHIP_NAME \" DAC1\");\n\tensoniq->pcm2 = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &ensoniq->pci->dev, 64*1024, 128*1024);\n\n#ifdef CHIP1370\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_std_chmaps, 2, 0, NULL);\n#else\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     surround_map, 2, 0, NULL);\n#endif\n\treturn err;\n}\n\n \n\n \n#ifdef CHIP1371\nstatic int snd_ens1373_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int snd_ens1373_spdif_default_get(struct snd_kcontrol *kcontrol,\n                                         struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tucontrol->value.iec958.status[0] = (ensoniq->spdif_default >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (ensoniq->spdif_default >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (ensoniq->spdif_default >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (ensoniq->spdif_default >> 24) & 0xff;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ens1373_spdif_default_put(struct snd_kcontrol *kcontrol,\n                                         struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ((u32)ucontrol->value.iec958.status[0] << 0) |\n\t      ((u32)ucontrol->value.iec958.status[1] << 8) |\n\t      ((u32)ucontrol->value.iec958.status[2] << 16) |\n\t      ((u32)ucontrol->value.iec958.status[3] << 24);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tchange = ensoniq->spdif_default != val;\n\tensoniq->spdif_default = val;\n\tif (change && ensoniq->playback1_substream == NULL &&\n\t    ensoniq->playback2_substream == NULL)\n\t\toutl(val, ES_REG(ensoniq, CHANNEL_STATUS));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn change;\n}\n\nstatic int snd_ens1373_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int snd_ens1373_spdif_stream_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tucontrol->value.iec958.status[0] = (ensoniq->spdif_stream >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (ensoniq->spdif_stream >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (ensoniq->spdif_stream >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (ensoniq->spdif_stream >> 24) & 0xff;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol,\n                                        struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change;\n\n\tval = ((u32)ucontrol->value.iec958.status[0] << 0) |\n\t      ((u32)ucontrol->value.iec958.status[1] << 8) |\n\t      ((u32)ucontrol->value.iec958.status[2] << 16) |\n\t      ((u32)ucontrol->value.iec958.status[3] << 24);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tchange = ensoniq->spdif_stream != val;\n\tensoniq->spdif_stream = val;\n\tif (change && (ensoniq->playback1_substream != NULL ||\n\t\t       ensoniq->playback2_substream != NULL))\n\t\toutl(val, ES_REG(ensoniq, CHANNEL_STATUS));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn change;\n}\n\n#define ES1371_SPDIF(xname) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_es1371_spdif_info, \\\n  .get = snd_es1371_spdif_get, .put = snd_es1371_spdif_put }\n\n#define snd_es1371_spdif_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\t\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tucontrol->value.integer.value[0] = ensoniq->ctrl & ES_1373_SPDIF_THRU ? 1 : 0;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tunsigned int nval1, nval2;\n\tint change;\n\t\n\tnval1 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_THRU : 0;\n\tnval2 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_EN : 0;\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tchange = (ensoniq->ctrl & ES_1373_SPDIF_THRU) != nval1;\n\tensoniq->ctrl &= ~ES_1373_SPDIF_THRU;\n\tensoniq->ctrl |= nval1;\n\tensoniq->cssr &= ~ES_1373_SPDIF_EN;\n\tensoniq->cssr |= nval2;\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn change;\n}\n\n\n \nstatic const struct snd_kcontrol_new snd_es1371_mixer_spdif[] = {\n\tES1371_SPDIF(SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,SWITCH)),\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t\t.info =\t\tsnd_ens1373_spdif_info,\n\t\t.get =\t\tsnd_ens1373_spdif_default_get,\n\t\t.put =\t\tsnd_ens1373_spdif_default_put,\n\t},\n\t{\n\t\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t\t.info =\t\tsnd_ens1373_spdif_info,\n\t\t.get =\t\tsnd_ens1373_spdif_mask_get\n\t},\n\t{\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,PCM_STREAM),\n\t\t.info =\t\tsnd_ens1373_spdif_info,\n\t\t.get =\t\tsnd_ens1373_spdif_stream_get,\n\t\t.put =\t\tsnd_ens1373_spdif_stream_put\n\t},\n};\n\n\n#define snd_es1373_rear_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_es1373_rear_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tint val = 0;\n\t\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif ((ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|\n\t\t\t      ES_1373_REAR_BIT24)) == ES_1373_REAR_BIT26)\n\t    \tval = 1;\n\tucontrol->value.integer.value[0] = val;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_es1373_rear_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tunsigned int nval1;\n\tint change;\n\t\n\tnval1 = ucontrol->value.integer.value[0] ?\n\t\tES_1373_REAR_BIT26 : (ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tchange = (ensoniq->cssr & (ES_1373_REAR_BIT27|\n\t\t\t\t   ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) != nval1;\n\tensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24);\n\tensoniq->cssr |= nval1;\n\toutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new snd_ens1373_rear =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"AC97 2ch->4ch Copy Switch\",\n\t.info =\t\tsnd_es1373_rear_info,\n\t.get =\t\tsnd_es1373_rear_get,\n\t.put =\t\tsnd_es1373_rear_put,\n};\n\n#define snd_es1373_line_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_es1373_line_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tint val = 0;\n\t\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif (ensoniq->ctrl & ES_1371_GPIO_OUT(4))\n\t    \tval = 1;\n\tucontrol->value.integer.value[0] = val;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_es1373_line_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tint changed;\n\tunsigned int ctrl;\n\t\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tctrl = ensoniq->ctrl;\n\tif (ucontrol->value.integer.value[0])\n\t\tensoniq->ctrl |= ES_1371_GPIO_OUT(4);\t \n\telse\n\t\tensoniq->ctrl &= ~ES_1371_GPIO_OUT(4);\n\tchanged = (ctrl != ensoniq->ctrl);\n\tif (changed)\n\t\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_ens1373_line =\n{\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Line In->Rear Out Switch\",\n\t.info =\t\tsnd_es1373_line_info,\n\t.get =\t\tsnd_es1373_line_get,\n\t.put =\t\tsnd_es1373_line_put,\n};\n\nstatic void snd_ensoniq_mixer_free_ac97(struct snd_ac97 *ac97)\n{\n\tstruct ensoniq *ensoniq = ac97->private_data;\n\tensoniq->u.es1371.ac97 = NULL;\n}\n\nstruct es1371_quirk {\n\tunsigned short vid;\t\t \n\tunsigned short did;\t\t \n\tunsigned char rev;\t\t \n};\n\nstatic int es1371_quirk_lookup(struct ensoniq *ensoniq,\n\t\t\t       const struct es1371_quirk *list)\n{\n\twhile (list->vid != (unsigned short)PCI_ANY_ID) {\n\t\tif (ensoniq->pci->vendor == list->vid &&\n\t\t    ensoniq->pci->device == list->did &&\n\t\t    ensoniq->rev == list->rev)\n\t\t\treturn 1;\n\t\tlist++;\n\t}\n\treturn 0;\n}\n\nstatic const struct es1371_quirk es1371_spdif_present[] = {\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_CT5880_A },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_ES1373_8 },\n\t{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }\n};\n\nstatic const struct snd_pci_quirk ens1373_line_quirk[] = {\n\tSND_PCI_QUIRK_ID(0x1274, 0x2000),  \n\tSND_PCI_QUIRK_ID(0x1458, 0xa000),  \n\t{ }  \n};\n\nstatic int snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,\n\t\t\t\t  int has_spdif, int has_line)\n{\n\tstruct snd_card *card = ensoniq->card;\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_es1371_codec_write,\n\t\t.read = snd_es1371_codec_read,\n\t\t.wait = snd_es1371_codec_wait,\n\t};\n\n\terr = snd_ac97_bus(card, 0, &ops, NULL, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.private_data = ensoniq;\n\tac97.private_free = snd_ensoniq_mixer_free_ac97;\n\tac97.pci = ensoniq->pci;\n\tac97.scaps = AC97_SCAP_AUDIO;\n\terr = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97);\n\tif (err < 0)\n\t\treturn err;\n\tif (has_spdif > 0 ||\n\t    (!has_spdif && es1371_quirk_lookup(ensoniq, es1371_spdif_present))) {\n\t\tstruct snd_kcontrol *kctl;\n\t\tint i, is_spdif = 0;\n\n\t\tensoniq->spdif_default = ensoniq->spdif_stream =\n\t\t\tSNDRV_PCM_DEFAULT_CON_SPDIF;\n\t\toutl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));\n\n\t\tif (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)\n\t\t\tis_spdif++;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {\n\t\t\tkctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);\n\t\t\tif (!kctl)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkctl->id.index = is_spdif;\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tif (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SDAC) {\n\t\t \n\t\tensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);\n\t\tensoniq->cssr |= ES_1373_REAR_BIT26;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_rear, ensoniq));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (has_line > 0 ||\n\t    snd_pci_quirk_lookup(ensoniq->pci, ens1373_line_quirk)) {\n\t\t err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line,\n\t\t\t\t\t\t      ensoniq));\n\t\t if (err < 0)\n\t\t\t return err;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n\n \n#ifdef CHIP1370\n#define ENSONIQ_CONTROL(xname, mask) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_CARD, .name = xname, .info = snd_ensoniq_control_info, \\\n  .get = snd_ensoniq_control_get, .put = snd_ensoniq_control_put, \\\n  .private_value = mask }\n\n#define snd_ensoniq_control_info\tsnd_ctl_boolean_mono_info\n\nstatic int snd_ensoniq_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tint mask = kcontrol->private_value;\n\t\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tucontrol->value.integer.value[0] = ensoniq->ctrl & mask ? 1 : 0;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ensoniq_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);\n\tint mask = kcontrol->private_value;\n\tunsigned int nval;\n\tint change;\n\t\n\tnval = ucontrol->value.integer.value[0] ? mask : 0;\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tchange = (ensoniq->ctrl & mask) != nval;\n\tensoniq->ctrl &= ~mask;\n\tensoniq->ctrl |= nval;\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn change;\n}\n\n \n\nstatic const struct snd_kcontrol_new snd_es1370_controls[2] = {\nENSONIQ_CONTROL(\"PCM 0 Output also on Line-In Jack\", ES_1370_XCTL0),\nENSONIQ_CONTROL(\"Mic +5V bias\", ES_1370_XCTL1)\n};\n\n#define ES1370_CONTROLS ARRAY_SIZE(snd_es1370_controls)\n\nstatic void snd_ensoniq_mixer_free_ak4531(struct snd_ak4531 *ak4531)\n{\n\tstruct ensoniq *ensoniq = ak4531->private_data;\n\tensoniq->u.es1370.ak4531 = NULL;\n}\n\nstatic int snd_ensoniq_1370_mixer(struct ensoniq *ensoniq)\n{\n\tstruct snd_card *card = ensoniq->card;\n\tstruct snd_ak4531 ak4531;\n\tunsigned int idx;\n\tint err;\n\n\t \n\toutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));\n\tinw(ES_REG(ensoniq, 1370_CODEC));\n\tudelay(100);\n\toutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));\n\tinw(ES_REG(ensoniq, 1370_CODEC));\n\tudelay(100);\n\n\tmemset(&ak4531, 0, sizeof(ak4531));\n\tak4531.write = snd_es1370_codec_write;\n\tak4531.private_data = ensoniq;\n\tak4531.private_free = snd_ensoniq_mixer_free_ak4531;\n\terr = snd_ak4531_mixer(card, &ak4531, &ensoniq->u.es1370.ak4531);\n\tif (err < 0)\n\t\treturn err;\n\tfor (idx = 0; idx < ES1370_CONTROLS; idx++) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&snd_es1370_controls[idx], ensoniq));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n#endif  \n\n#ifdef SUPPORT_JOYSTICK\n\n#ifdef CHIP1371\nstatic int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)\n{\n\tswitch (joystick_port[dev]) {\n\tcase 0:  \n\tcase 1:  \n\tcase 0x200:\n\tcase 0x208:\n\tcase 0x210:\n\tcase 0x218:\n\t\treturn joystick_port[dev];\n\n\tdefault:\n\t\tdev_err(ensoniq->card->dev,\n\t\t\t\"invalid joystick port %#x\", joystick_port[dev]);\n\t\treturn 0;\n\t}\n}\n#else\nstatic int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)\n{\n\treturn joystick[dev] ? 0x200 : 0;\n}\n#endif\n\nstatic int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)\n{\n\tstruct gameport *gp;\n\tint io_port;\n\n\tio_port = snd_ensoniq_get_joystick_port(ensoniq, dev);\n\n\tswitch (io_port) {\n\tcase 0:\n\t\treturn -ENOSYS;\n\n\tcase 1:  \n\t\tfor (io_port = 0x200; io_port <= 0x218; io_port += 8)\n\t\t\tif (request_region(io_port, 8, \"ens137x: gameport\"))\n\t\t\t\tbreak;\n\t\tif (io_port > 0x218) {\n\t\t\tdev_warn(ensoniq->card->dev,\n\t\t\t\t \"no gameport ports available\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (!request_region(io_port, 8, \"ens137x: gameport\")) {\n\t\t\tdev_warn(ensoniq->card->dev,\n\t\t\t\t \"gameport io port %#x in use\\n\",\n\t\t\t       io_port);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tbreak;\n\t}\n\n\tensoniq->gameport = gp = gameport_allocate_port();\n\tif (!gp) {\n\t\tdev_err(ensoniq->card->dev,\n\t\t\t\"cannot allocate memory for gameport\\n\");\n\t\trelease_region(io_port, 8);\n\t\treturn -ENOMEM;\n\t}\n\n\tgameport_set_name(gp, \"ES137x\");\n\tgameport_set_phys(gp, \"pci%s/gameport0\", pci_name(ensoniq->pci));\n\tgameport_set_dev_parent(gp, &ensoniq->pci->dev);\n\tgp->io = io_port;\n\n\tensoniq->ctrl |= ES_JYSTK_EN;\n#ifdef CHIP1371\n\tensoniq->ctrl &= ~ES_1371_JOY_ASELM;\n\tensoniq->ctrl |= ES_1371_JOY_ASEL((io_port - 0x200) / 8);\n#endif\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\n\tgameport_register_port(ensoniq->gameport);\n\n\treturn 0;\n}\n\nstatic void snd_ensoniq_free_gameport(struct ensoniq *ensoniq)\n{\n\tif (ensoniq->gameport) {\n\t\tint port = ensoniq->gameport->io;\n\n\t\tgameport_unregister_port(ensoniq->gameport);\n\t\tensoniq->gameport = NULL;\n\t\tensoniq->ctrl &= ~ES_JYSTK_EN;\n\t\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\t\trelease_region(port, 8);\n\t}\n}\n#else\nstatic inline int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, long port) { return -ENOSYS; }\nstatic inline void snd_ensoniq_free_gameport(struct ensoniq *ensoniq) { }\n#endif  \n\n \n\nstatic void snd_ensoniq_proc_read(struct snd_info_entry *entry, \n\t\t\t\t  struct snd_info_buffer *buffer)\n{\n\tstruct ensoniq *ensoniq = entry->private_data;\n\n\tsnd_iprintf(buffer, \"Ensoniq AudioPCI \" CHIP_NAME \"\\n\\n\");\n\tsnd_iprintf(buffer, \"Joystick enable  : %s\\n\",\n\t\t    ensoniq->ctrl & ES_JYSTK_EN ? \"on\" : \"off\");\n#ifdef CHIP1370\n\tsnd_iprintf(buffer, \"MIC +5V bias     : %s\\n\",\n\t\t    ensoniq->ctrl & ES_1370_XCTL1 ? \"on\" : \"off\");\n\tsnd_iprintf(buffer, \"Line In to AOUT  : %s\\n\",\n\t\t    ensoniq->ctrl & ES_1370_XCTL0 ? \"on\" : \"off\");\n#else\n\tsnd_iprintf(buffer, \"Joystick port    : 0x%x\\n\",\n\t\t    (ES_1371_JOY_ASELI(ensoniq->ctrl) * 8) + 0x200);\n#endif\n}\n\nstatic void snd_ensoniq_proc_init(struct ensoniq *ensoniq)\n{\n\tsnd_card_ro_proc_new(ensoniq->card, \"audiopci\", ensoniq,\n\t\t\t     snd_ensoniq_proc_read);\n}\n\n \n\nstatic void snd_ensoniq_free(struct snd_card *card)\n{\n\tstruct ensoniq *ensoniq = card->private_data;\n\n\tsnd_ensoniq_free_gameport(ensoniq);\n#ifdef CHIP1370\n\toutl(ES_1370_SERR_DISABLE, ES_REG(ensoniq, CONTROL));\t \n\toutl(0, ES_REG(ensoniq, SERIAL));\t \n#else\n\toutl(0, ES_REG(ensoniq, CONTROL));\t \n\toutl(0, ES_REG(ensoniq, SERIAL));\t \n#endif\n}\n\n#ifdef CHIP1371\nstatic const struct snd_pci_quirk es1371_amplifier_hack[] = {\n\tSND_PCI_QUIRK_ID(0x107b, 0x2150),\t \n\tSND_PCI_QUIRK_ID(0x13bd, 0x100c),\t \n\tSND_PCI_QUIRK_ID(0x1102, 0x5938),\t \n\tSND_PCI_QUIRK_ID(0x1102, 0x8938),\t \n\t{ }  \n};\n\nstatic const struct es1371_quirk es1371_ac97_reset_hack[] = {\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_CT5880_A },\n\t{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_ES1373_8 },\n\t{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }\n};\n#endif\n\nstatic void snd_ensoniq_chip_init(struct ensoniq *ensoniq)\n{\n#ifdef CHIP1371\n\tint idx;\n#endif\n\t \n#ifdef CHIP1370\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\toutl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));\n\toutl(ensoniq->dma_bug->addr, ES_REG(ensoniq, PHANTOM_FRAME));\n\toutl(0, ES_REG(ensoniq, PHANTOM_COUNT));\n#else\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\toutl(0, ES_REG(ensoniq, 1371_LEGACY));\n\tif (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack)) {\n\t    outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\n\t     \n\t    msleep(20);\n\t}\n\t \n\toutl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));\n\tinl(ES_REG(ensoniq, CONTROL));\n\tudelay(20);\n\toutl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));\n\t \n\tsnd_es1371_wait_src_ready(ensoniq);\t\n\toutl(ES_1371_SRC_DISABLE, ES_REG(ensoniq, 1371_SMPRATE));\n\tfor (idx = 0; idx < 0x80; idx++)\n\t\tsnd_es1371_src_write(ensoniq, idx, 0);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_TRUNC_N, 16 << 4);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS, 16 << 10);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_TRUNC_N, 16 << 4);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS, 16 << 10);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, 1 << 12);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, 1 << 12);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1, 1 << 12);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1 + 1, 1 << 12);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2, 1 << 12);\n\tsnd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2 + 1, 1 << 12);\n\tsnd_es1371_adc_rate(ensoniq, 22050);\n\tsnd_es1371_dac1_rate(ensoniq, 22050);\n\tsnd_es1371_dac2_rate(ensoniq, 22050);\n\t \n\tsnd_es1371_wait_src_ready(ensoniq);\n\toutl(0, ES_REG(ensoniq, 1371_SMPRATE));\n\t \n\toutl(ES_1371_CODEC_WRITE(0, 0), ES_REG(ensoniq, 1371_CODEC));\n#endif\n\toutb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));\n\toutb(0x00, ES_REG(ensoniq, UART_RES));\n\toutl(ensoniq->cssr, ES_REG(ensoniq, STATUS));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_ensoniq_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct ensoniq *ensoniq = card->private_data;\n\t\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\n#ifdef CHIP1371\t\n\tsnd_ac97_suspend(ensoniq->u.es1371.ac97);\n#else\n\t \n\toutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));\n\tinw(ES_REG(ensoniq, 1370_CODEC));\n\tudelay(100);\n\toutw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));\n\tinw(ES_REG(ensoniq, 1370_CODEC));\n\tudelay(100);\n\tsnd_ak4531_suspend(ensoniq->u.es1370.ak4531);\n#endif\t\n\treturn 0;\n}\n\nstatic int snd_ensoniq_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct ensoniq *ensoniq = card->private_data;\n\n\tsnd_ensoniq_chip_init(ensoniq);\n\n#ifdef CHIP1371\t\n\tsnd_ac97_resume(ensoniq->u.es1371.ac97);\n#else\n\tsnd_ak4531_resume(ensoniq->u.es1370.ak4531);\n#endif\t\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_ensoniq_pm, snd_ensoniq_suspend, snd_ensoniq_resume);\n#define SND_ENSONIQ_PM_OPS\t&snd_ensoniq_pm\n#else\n#define SND_ENSONIQ_PM_OPS\tNULL\n#endif  \n\nstatic int snd_ensoniq_create(struct snd_card *card,\n\t\t\t      struct pci_dev *pci)\n{\n\tstruct ensoniq *ensoniq = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\tspin_lock_init(&ensoniq->reg_lock);\n\tmutex_init(&ensoniq->src_mutex);\n\tensoniq->card = card;\n\tensoniq->pci = pci;\n\tensoniq->irq = -1;\n\terr = pci_request_regions(pci, \"Ensoniq AudioPCI\");\n\tif (err < 0)\n\t\treturn err;\n\tensoniq->port = pci_resource_start(pci, 0);\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_audiopci_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, ensoniq)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tensoniq->irq = pci->irq;\n\tcard->sync_irq = ensoniq->irq;\n#ifdef CHIP1370\n\tensoniq->dma_bug =\n\t\tsnd_devm_alloc_pages(&pci->dev, SNDRV_DMA_TYPE_DEV, 16);\n\tif (!ensoniq->dma_bug)\n\t\treturn -ENOMEM;\n#endif\n\tpci_set_master(pci);\n\tensoniq->rev = pci->revision;\n#ifdef CHIP1370\n#if 0\n\tensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |\n\t\tES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));\n#else\t \n\tensoniq->ctrl = ES_1370_CDC_EN | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));\n#endif\n\tensoniq->sctrl = 0;\n#else\n\tensoniq->ctrl = 0;\n\tensoniq->sctrl = 0;\n\tensoniq->cssr = 0;\n\tif (snd_pci_quirk_lookup(pci, es1371_amplifier_hack))\n\t\tensoniq->ctrl |= ES_1371_GPIO_OUT(1);\t \n\n\tif (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack))\n\t\tensoniq->cssr |= ES_1371_ST_AC97_RST;\n#endif\n\n\tcard->private_free = snd_ensoniq_free;\n\tsnd_ensoniq_chip_init(ensoniq);\n\n\tsnd_ensoniq_proc_init(ensoniq);\n\treturn 0;\n}\n\n \n\nstatic void snd_ensoniq_midi_interrupt(struct ensoniq * ensoniq)\n{\n\tstruct snd_rawmidi *rmidi = ensoniq->rmidi;\n\tunsigned char status, mask, byte;\n\n\tif (rmidi == NULL)\n\t\treturn;\n\t \n\tspin_lock(&ensoniq->reg_lock);\n\tmask = ensoniq->uartm & ES_MODE_INPUT ? ES_RXRDY : 0;\n\twhile (mask) {\n\t\tstatus = inb(ES_REG(ensoniq, UART_STATUS));\n\t\tif ((status & mask) == 0)\n\t\t\tbreak;\n\t\tbyte = inb(ES_REG(ensoniq, UART_DATA));\n\t\tsnd_rawmidi_receive(ensoniq->midi_input, &byte, 1);\n\t}\n\tspin_unlock(&ensoniq->reg_lock);\n\n\t \n\tspin_lock(&ensoniq->reg_lock);\n\tmask = ensoniq->uartm & ES_MODE_OUTPUT ? ES_TXRDY : 0;\n\twhile (mask) {\n\t\tstatus = inb(ES_REG(ensoniq, UART_STATUS));\n\t\tif ((status & mask) == 0)\n\t\t\tbreak;\n\t\tif (snd_rawmidi_transmit(ensoniq->midi_output, &byte, 1) != 1) {\n\t\t\tensoniq->uartc &= ~ES_TXINTENM;\n\t\t\toutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\n\t\t\tmask &= ~ES_TXRDY;\n\t\t} else {\n\t\t\toutb(byte, ES_REG(ensoniq, UART_DATA));\n\t\t}\n\t}\n\tspin_unlock(&ensoniq->reg_lock);\n}\n\nstatic int snd_ensoniq_midi_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tensoniq->uartm |= ES_MODE_INPUT;\n\tensoniq->midi_input = substream;\n\tif (!(ensoniq->uartm & ES_MODE_OUTPUT)) {\n\t\toutb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));\n\t\toutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\n\t\toutl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));\n\t}\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ensoniq_midi_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif (!(ensoniq->uartm & ES_MODE_OUTPUT)) {\n\t\toutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\n\t\toutl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));\n\t} else {\n\t\toutb(ensoniq->uartc &= ~ES_RXINTEN, ES_REG(ensoniq, UART_CONTROL));\n\t}\n\tensoniq->midi_input = NULL;\n\tensoniq->uartm &= ~ES_MODE_INPUT;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ensoniq_midi_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tensoniq->uartm |= ES_MODE_OUTPUT;\n\tensoniq->midi_output = substream;\n\tif (!(ensoniq->uartm & ES_MODE_INPUT)) {\n\t\toutb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));\n\t\toutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\n\t\toutl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));\n\t}\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic int snd_ensoniq_midi_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\n\tspin_lock_irq(&ensoniq->reg_lock);\n\tif (!(ensoniq->uartm & ES_MODE_INPUT)) {\n\t\toutb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));\n\t\toutl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));\n\t} else {\n\t\toutb(ensoniq->uartc &= ~ES_TXINTENM, ES_REG(ensoniq, UART_CONTROL));\n\t}\n\tensoniq->midi_output = NULL;\n\tensoniq->uartm &= ~ES_MODE_OUTPUT;\n\tspin_unlock_irq(&ensoniq->reg_lock);\n\treturn 0;\n}\n\nstatic void snd_ensoniq_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\tint idx;\n\n\tspin_lock_irqsave(&ensoniq->reg_lock, flags);\n\tif (up) {\n\t\tif ((ensoniq->uartc & ES_RXINTEN) == 0) {\n\t\t\t \n\t\t\tfor (idx = 0; idx < 32; idx++)\n\t\t\t\tinb(ES_REG(ensoniq, UART_DATA));\n\t\t\tensoniq->uartc |= ES_RXINTEN;\n\t\t\toutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\n\t\t}\n\t} else {\n\t\tif (ensoniq->uartc & ES_RXINTEN) {\n\t\t\tensoniq->uartc &= ~ES_RXINTEN;\n\t\t\toutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ensoniq->reg_lock, flags);\n}\n\nstatic void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct ensoniq *ensoniq = substream->rmidi->private_data;\n\tunsigned char byte;\n\n\tspin_lock_irqsave(&ensoniq->reg_lock, flags);\n\tif (up) {\n\t\tif (ES_TXINTENI(ensoniq->uartc) == 0) {\n\t\t\tensoniq->uartc |= ES_TXINTENO(1);\n\t\t\t \n\t\t\twhile (ES_TXINTENI(ensoniq->uartc) == 1 &&\n\t\t\t       (inb(ES_REG(ensoniq, UART_STATUS)) & ES_TXRDY)) {\n\t\t\t\tif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\n\t\t\t\t\tensoniq->uartc &= ~ES_TXINTENM;\n\t\t\t\t} else {\n\t\t\t\t\toutb(byte, ES_REG(ensoniq, UART_DATA));\n\t\t\t\t}\n\t\t\t}\n\t\t\toutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\n\t\t}\n\t} else {\n\t\tif (ES_TXINTENI(ensoniq->uartc) == 1) {\n\t\t\tensoniq->uartc &= ~ES_TXINTENM;\n\t\t\toutb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ensoniq->reg_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_ensoniq_midi_output =\n{\n\t.open =\t\tsnd_ensoniq_midi_output_open,\n\t.close =\tsnd_ensoniq_midi_output_close,\n\t.trigger =\tsnd_ensoniq_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_ensoniq_midi_input =\n{\n\t.open =\t\tsnd_ensoniq_midi_input_open,\n\t.close =\tsnd_ensoniq_midi_input_close,\n\t.trigger =\tsnd_ensoniq_midi_input_trigger,\n};\n\nstatic int snd_ensoniq_midi(struct ensoniq *ensoniq, int device)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(ensoniq->card, \"ES1370/1\", device, 1, 1, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, CHIP_NAME);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_ensoniq_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_ensoniq_midi_input);\n\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |\n\t\tSNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = ensoniq;\n\tensoniq->rmidi = rmidi;\n\treturn 0;\n}\n\n \n\nstatic irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id)\n{\n\tstruct ensoniq *ensoniq = dev_id;\n\tunsigned int status, sctrl;\n\n\tif (ensoniq == NULL)\n\t\treturn IRQ_NONE;\n\n\tstatus = inl(ES_REG(ensoniq, STATUS));\n\tif (!(status & ES_INTR))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&ensoniq->reg_lock);\n\tsctrl = ensoniq->sctrl;\n\tif (status & ES_DAC1)\n\t\tsctrl &= ~ES_P1_INT_EN;\n\tif (status & ES_DAC2)\n\t\tsctrl &= ~ES_P2_INT_EN;\n\tif (status & ES_ADC)\n\t\tsctrl &= ~ES_R1_INT_EN;\n\toutl(sctrl, ES_REG(ensoniq, SERIAL));\n\toutl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));\n\tspin_unlock(&ensoniq->reg_lock);\n\n\tif (status & ES_UART)\n\t\tsnd_ensoniq_midi_interrupt(ensoniq);\n\tif ((status & ES_DAC2) && ensoniq->playback2_substream)\n\t\tsnd_pcm_period_elapsed(ensoniq->playback2_substream);\n\tif ((status & ES_ADC) && ensoniq->capture_substream)\n\t\tsnd_pcm_period_elapsed(ensoniq->capture_substream);\n\tif ((status & ES_DAC1) && ensoniq->playback1_substream)\n\t\tsnd_pcm_period_elapsed(ensoniq->playback1_substream);\n\treturn IRQ_HANDLED;\n}\n\nstatic int __snd_audiopci_probe(struct pci_dev *pci,\n\t\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct ensoniq *ensoniq;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_devm_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(*ensoniq), &card);\n\tif (err < 0)\n\t\treturn err;\n\tensoniq = card->private_data;\n\n\terr = snd_ensoniq_create(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n#ifdef CHIP1370\n\terr = snd_ensoniq_1370_mixer(ensoniq);\n\tif (err < 0)\n\t\treturn err;\n#endif\n#ifdef CHIP1371\n\terr = snd_ensoniq_1371_mixer(ensoniq, spdif[dev], lineio[dev]);\n\tif (err < 0)\n\t\treturn err;\n#endif\n\terr = snd_ensoniq_pcm(ensoniq, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ensoniq_pcm2(ensoniq, 1);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ensoniq_midi(ensoniq, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_ensoniq_create_gameport(ensoniq, dev);\n\n\tstrcpy(card->driver, DRIVER_NAME);\n\n\tstrcpy(card->shortname, \"Ensoniq AudioPCI\");\n\tsprintf(card->longname, \"%s %s at 0x%lx, irq %i\",\n\t\tcard->shortname,\n\t\tcard->driver,\n\t\tensoniq->port,\n\t\tensoniq->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n}\n\nstatic int snd_audiopci_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_audiopci_probe(pci, pci_id));\n}\n\nstatic struct pci_driver ens137x_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_audiopci_ids,\n\t.probe = snd_audiopci_probe,\n\t.driver = {\n\t\t.pm = SND_ENSONIQ_PM_OPS,\n\t},\n};\n\t\nmodule_pci_driver(ens137x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}