{
  "module_name": "atiixp.c",
  "hash_id": "4497ef59434eaf6d72bf8d8d2b609293203df88fad3f258928fb1e5e38cb6629",
  "original_prompt": "Ingested from linux-6.6.14/sound/pci/atiixp.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"ATI IXP AC97 controller\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic int ac97_clock = 48000;\nstatic char *ac97_quirk;\nstatic bool spdif_aclink = 1;\nstatic int ac97_codec = -1;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for ATI IXP controller.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for ATI IXP controller.\");\nmodule_param(ac97_clock, int, 0444);\nMODULE_PARM_DESC(ac97_clock, \"AC'97 codec clock (default 48000Hz).\");\nmodule_param(ac97_quirk, charp, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 workaround for strange hardware.\");\nmodule_param(ac97_codec, int, 0444);\nMODULE_PARM_DESC(ac97_codec, \"Specify codec instead of probing.\");\nmodule_param(spdif_aclink, bool, 0444);\nMODULE_PARM_DESC(spdif_aclink, \"S/PDIF over AC-link.\");\n\n \nstatic bool enable;\nmodule_param(enable, bool, 0444);\n\n\n \n\n#define ATI_REG_ISR\t\t\t0x00\t \n#define  ATI_REG_ISR_IN_XRUN\t\t(1U<<0)\n#define  ATI_REG_ISR_IN_STATUS\t\t(1U<<1)\n#define  ATI_REG_ISR_OUT_XRUN\t\t(1U<<2)\n#define  ATI_REG_ISR_OUT_STATUS\t\t(1U<<3)\n#define  ATI_REG_ISR_SPDF_XRUN\t\t(1U<<4)\n#define  ATI_REG_ISR_SPDF_STATUS\t(1U<<5)\n#define  ATI_REG_ISR_PHYS_INTR\t\t(1U<<8)\n#define  ATI_REG_ISR_PHYS_MISMATCH\t(1U<<9)\n#define  ATI_REG_ISR_CODEC0_NOT_READY\t(1U<<10)\n#define  ATI_REG_ISR_CODEC1_NOT_READY\t(1U<<11)\n#define  ATI_REG_ISR_CODEC2_NOT_READY\t(1U<<12)\n#define  ATI_REG_ISR_NEW_FRAME\t\t(1U<<13)\n\n#define ATI_REG_IER\t\t\t0x04\t \n#define  ATI_REG_IER_IN_XRUN_EN\t\t(1U<<0)\n#define  ATI_REG_IER_IO_STATUS_EN\t(1U<<1)\n#define  ATI_REG_IER_OUT_XRUN_EN\t(1U<<2)\n#define  ATI_REG_IER_OUT_XRUN_COND\t(1U<<3)\n#define  ATI_REG_IER_SPDF_XRUN_EN\t(1U<<4)\n#define  ATI_REG_IER_SPDF_STATUS_EN\t(1U<<5)\n#define  ATI_REG_IER_PHYS_INTR_EN\t(1U<<8)\n#define  ATI_REG_IER_PHYS_MISMATCH_EN\t(1U<<9)\n#define  ATI_REG_IER_CODEC0_INTR_EN\t(1U<<10)\n#define  ATI_REG_IER_CODEC1_INTR_EN\t(1U<<11)\n#define  ATI_REG_IER_CODEC2_INTR_EN\t(1U<<12)\n#define  ATI_REG_IER_NEW_FRAME_EN\t(1U<<13)\t \n#define  ATI_REG_IER_SET_BUS_BUSY\t(1U<<14)\t \n\n#define ATI_REG_CMD\t\t\t0x08\t \n#define  ATI_REG_CMD_POWERDOWN\t\t(1U<<0)\n#define  ATI_REG_CMD_RECEIVE_EN\t\t(1U<<1)\n#define  ATI_REG_CMD_SEND_EN\t\t(1U<<2)\n#define  ATI_REG_CMD_STATUS_MEM\t\t(1U<<3)\n#define  ATI_REG_CMD_SPDF_OUT_EN\t(1U<<4)\n#define  ATI_REG_CMD_SPDF_STATUS_MEM\t(1U<<5)\n#define  ATI_REG_CMD_SPDF_THRESHOLD\t(3U<<6)\n#define  ATI_REG_CMD_SPDF_THRESHOLD_SHIFT\t6\n#define  ATI_REG_CMD_IN_DMA_EN\t\t(1U<<8)\n#define  ATI_REG_CMD_OUT_DMA_EN\t\t(1U<<9)\n#define  ATI_REG_CMD_SPDF_DMA_EN\t(1U<<10)\n#define  ATI_REG_CMD_SPDF_OUT_STOPPED\t(1U<<11)\n#define  ATI_REG_CMD_SPDF_CONFIG_MASK\t(7U<<12)\n#define   ATI_REG_CMD_SPDF_CONFIG_34\t(1U<<12)\n#define   ATI_REG_CMD_SPDF_CONFIG_78\t(2U<<12)\n#define   ATI_REG_CMD_SPDF_CONFIG_69\t(3U<<12)\n#define   ATI_REG_CMD_SPDF_CONFIG_01\t(4U<<12)\n#define  ATI_REG_CMD_INTERLEAVE_SPDF\t(1U<<16)\n#define  ATI_REG_CMD_AUDIO_PRESENT\t(1U<<20)\n#define  ATI_REG_CMD_INTERLEAVE_IN\t(1U<<21)\n#define  ATI_REG_CMD_INTERLEAVE_OUT\t(1U<<22)\n#define  ATI_REG_CMD_LOOPBACK_EN\t(1U<<23)\n#define  ATI_REG_CMD_PACKED_DIS\t\t(1U<<24)\n#define  ATI_REG_CMD_BURST_EN\t\t(1U<<25)\n#define  ATI_REG_CMD_PANIC_EN\t\t(1U<<26)\n#define  ATI_REG_CMD_MODEM_PRESENT\t(1U<<27)\n#define  ATI_REG_CMD_ACLINK_ACTIVE\t(1U<<28)\n#define  ATI_REG_CMD_AC_SOFT_RESET\t(1U<<29)\n#define  ATI_REG_CMD_AC_SYNC\t\t(1U<<30)\n#define  ATI_REG_CMD_AC_RESET\t\t(1U<<31)\n\n#define ATI_REG_PHYS_OUT_ADDR\t\t0x0c\n#define  ATI_REG_PHYS_OUT_CODEC_MASK\t(3U<<0)\n#define  ATI_REG_PHYS_OUT_RW\t\t(1U<<2)\n#define  ATI_REG_PHYS_OUT_ADDR_EN\t(1U<<8)\n#define  ATI_REG_PHYS_OUT_ADDR_SHIFT\t9\n#define  ATI_REG_PHYS_OUT_DATA_SHIFT\t16\n\n#define ATI_REG_PHYS_IN_ADDR\t\t0x10\n#define  ATI_REG_PHYS_IN_READ_FLAG\t(1U<<8)\n#define  ATI_REG_PHYS_IN_ADDR_SHIFT\t9\n#define  ATI_REG_PHYS_IN_DATA_SHIFT\t16\n\n#define ATI_REG_SLOTREQ\t\t\t0x14\n\n#define ATI_REG_COUNTER\t\t\t0x18\n#define  ATI_REG_COUNTER_SLOT\t\t(3U<<0)\t \n#define  ATI_REG_COUNTER_BITCLOCK\t(31U<<8)\n\n#define ATI_REG_IN_FIFO_THRESHOLD\t0x1c\n\n#define ATI_REG_IN_DMA_LINKPTR\t\t0x20\n#define ATI_REG_IN_DMA_DT_START\t\t0x24\t \n#define ATI_REG_IN_DMA_DT_NEXT\t\t0x28\t \n#define ATI_REG_IN_DMA_DT_CUR\t\t0x2c\t \n#define ATI_REG_IN_DMA_DT_SIZE\t\t0x30\n\n#define ATI_REG_OUT_DMA_SLOT\t\t0x34\n#define  ATI_REG_OUT_DMA_SLOT_BIT(x)\t(1U << ((x) - 3))\n#define  ATI_REG_OUT_DMA_SLOT_MASK\t0x1ff\n#define  ATI_REG_OUT_DMA_THRESHOLD_MASK\t0xf800\n#define  ATI_REG_OUT_DMA_THRESHOLD_SHIFT\t11\n\n#define ATI_REG_OUT_DMA_LINKPTR\t\t0x38\n#define ATI_REG_OUT_DMA_DT_START\t0x3c\t \n#define ATI_REG_OUT_DMA_DT_NEXT\t\t0x40\t \n#define ATI_REG_OUT_DMA_DT_CUR\t\t0x44\t \n#define ATI_REG_OUT_DMA_DT_SIZE\t\t0x48\n\n#define ATI_REG_SPDF_CMD\t\t0x4c\n#define  ATI_REG_SPDF_CMD_LFSR\t\t(1U<<4)\n#define  ATI_REG_SPDF_CMD_SINGLE_CH\t(1U<<5)\n#define  ATI_REG_SPDF_CMD_LFSR_ACC\t(0xff<<8)\t \n\n#define ATI_REG_SPDF_DMA_LINKPTR\t0x50\n#define ATI_REG_SPDF_DMA_DT_START\t0x54\t \n#define ATI_REG_SPDF_DMA_DT_NEXT\t0x58\t \n#define ATI_REG_SPDF_DMA_DT_CUR\t\t0x5c\t \n#define ATI_REG_SPDF_DMA_DT_SIZE\t0x60\n\n#define ATI_REG_MODEM_MIRROR\t\t0x7c\n#define ATI_REG_AUDIO_MIRROR\t\t0x80\n\n#define ATI_REG_6CH_REORDER\t\t0x84\t \n#define  ATI_REG_6CH_REORDER_EN\t\t(1U<<0)\t \n\n#define ATI_REG_FIFO_FLUSH\t\t0x88\n#define  ATI_REG_FIFO_OUT_FLUSH\t\t(1U<<0)\n#define  ATI_REG_FIFO_IN_FLUSH\t\t(1U<<1)\n\n \n#define  ATI_REG_LINKPTR_EN\t\t(1U<<0)\n\n \n#define  ATI_REG_DMA_DT_SIZE\t\t(0xffffU<<0)\n#define  ATI_REG_DMA_FIFO_USED\t\t(0x1fU<<16)\n#define  ATI_REG_DMA_FIFO_FREE\t\t(0x1fU<<21)\n#define  ATI_REG_DMA_STATE\t\t(7U<<26)\n\n\n#define ATI_MAX_DESCRIPTORS\t256\t \n\n\nstruct atiixp;\n\n \n\nstruct atiixp_dma_desc {\n\t__le32 addr;\t \n\tu16 status;\t \n\tu16 size;\t \n\t__le32 next;\t \n};\n\n \nenum { ATI_DMA_PLAYBACK, ATI_DMA_CAPTURE, ATI_DMA_SPDIF, NUM_ATI_DMAS };  \nenum { ATI_PCM_OUT, ATI_PCM_IN, ATI_PCM_SPDIF, NUM_ATI_PCMS };  \nenum { ATI_PCMDEV_ANALOG, ATI_PCMDEV_DIGITAL, NUM_ATI_PCMDEVS };  \n\n#define NUM_ATI_CODECS\t3\n\n\n \nstruct atiixp_dma_ops {\n\tint type;\t\t\t \n\tunsigned int llp_offset;\t \n\tunsigned int dt_cur;\t\t \n\t \n\tvoid (*enable_dma)(struct atiixp *chip, int on);\n\t \n\tvoid (*enable_transfer)(struct atiixp *chip, int on);\n \t \n\tvoid (*flush_dma)(struct atiixp *chip);\n};\n\n \nstruct atiixp_dma {\n\tconst struct atiixp_dma_ops *ops;\n\tstruct snd_dma_buffer desc_buf;\n\tstruct snd_pcm_substream *substream;\t \n\tunsigned int buf_addr, buf_bytes;\t \n\tunsigned int period_bytes, periods;\n\tint opened;\n\tint running;\n\tint suspended;\n\tint pcm_open_flag;\n\tint ac97_pcm_type;\t \n\tunsigned int saved_curptr;\n};\n\n \nstruct atiixp {\n\tstruct snd_card *card;\n\tstruct pci_dev *pci;\n\n\tunsigned long addr;\n\tvoid __iomem *remap_addr;\n\tint irq;\n\t\n\tstruct snd_ac97_bus *ac97_bus;\n\tstruct snd_ac97 *ac97[NUM_ATI_CODECS];\n\n\tspinlock_t reg_lock;\n\n\tstruct atiixp_dma dmas[NUM_ATI_DMAS];\n\tstruct ac97_pcm *pcms[NUM_ATI_PCMS];\n\tstruct snd_pcm *pcmdevs[NUM_ATI_PCMDEVS];\n\n\tint max_channels;\t\t \n\n\tunsigned int codec_not_ready_bits;\t \n\n\tint spdif_over_aclink;\t\t \n\tstruct mutex open_mutex;\t \n};\n\n\n \nstatic const struct pci_device_id snd_atiixp_ids[] = {\n\t{ PCI_VDEVICE(ATI, 0x4341), 0 },  \n\t{ PCI_VDEVICE(ATI, 0x4361), 0 },  \n\t{ PCI_VDEVICE(ATI, 0x4370), 0 },  \n\t{ PCI_VDEVICE(ATI, 0x4382), 0 },  \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, snd_atiixp_ids);\n\nstatic const struct snd_pci_quirk atiixp_quirks[] = {\n\tSND_PCI_QUIRK(0x105b, 0x0c81, \"Foxconn RC4107MA-RS2\", 0),\n\tSND_PCI_QUIRK(0x15bd, 0x3100, \"DFI RS482\", 0),\n\t{ }  \n};\n\n \n\n \nstatic int snd_atiixp_update_bits(struct atiixp *chip, unsigned int reg,\n\t\t\t\t unsigned int mask, unsigned int value)\n{\n\tvoid __iomem *addr = chip->remap_addr + reg;\n\tunsigned int data, old_data;\n\told_data = data = readl(addr);\n\tdata &= ~mask;\n\tdata |= value;\n\tif (old_data == data)\n\t\treturn 0;\n\twritel(data, addr);\n\treturn 1;\n}\n\n \n#define atiixp_write(chip,reg,value) \\\n\twritel(value, chip->remap_addr + ATI_REG_##reg)\n#define atiixp_read(chip,reg) \\\n\treadl(chip->remap_addr + ATI_REG_##reg)\n#define atiixp_update(chip,reg,mask,val) \\\n\tsnd_atiixp_update_bits(chip, ATI_REG_##reg, mask, val)\n\n \n\n#define ATI_DESC_LIST_SIZE \\\n\tPAGE_ALIGN(ATI_MAX_DESCRIPTORS * sizeof(struct atiixp_dma_desc))\n\n \nstatic int atiixp_build_dma_packets(struct atiixp *chip, struct atiixp_dma *dma,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    unsigned int periods,\n\t\t\t\t    unsigned int period_bytes)\n{\n\tunsigned int i;\n\tu32 addr, desc_addr;\n\tunsigned long flags;\n\n\tif (periods > ATI_MAX_DESCRIPTORS)\n\t\treturn -ENOMEM;\n\n\tif (dma->desc_buf.area == NULL) {\n\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t&chip->pci->dev,\n\t\t\t\t\tATI_DESC_LIST_SIZE,\n\t\t\t\t\t&dma->desc_buf) < 0)\n\t\t\treturn -ENOMEM;\n\t\tdma->period_bytes = dma->periods = 0;  \n\t}\n\n\tif (dma->periods == periods && dma->period_bytes == period_bytes)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(&chip->reg_lock, flags);\n\twritel(0, chip->remap_addr + dma->ops->llp_offset);\n\tdma->ops->enable_dma(chip, 0);\n\tdma->ops->enable_dma(chip, 1);\n\tspin_unlock_irqrestore(&chip->reg_lock, flags);\n\n\t \n\taddr = (u32)substream->runtime->dma_addr;\n\tdesc_addr = (u32)dma->desc_buf.addr;\n\tfor (i = 0; i < periods; i++) {\n\t\tstruct atiixp_dma_desc *desc;\n\t\tdesc = &((struct atiixp_dma_desc *)dma->desc_buf.area)[i];\n\t\tdesc->addr = cpu_to_le32(addr);\n\t\tdesc->status = 0;\n\t\tdesc->size = period_bytes >> 2;  \n\t\tdesc_addr += sizeof(struct atiixp_dma_desc);\n\t\tif (i == periods - 1)\n\t\t\tdesc->next = cpu_to_le32((u32)dma->desc_buf.addr);\n\t\telse\n\t\t\tdesc->next = cpu_to_le32(desc_addr);\n\t\taddr += period_bytes;\n\t}\n\n\twritel((u32)dma->desc_buf.addr | ATI_REG_LINKPTR_EN,\n\t       chip->remap_addr + dma->ops->llp_offset);\n\n\tdma->period_bytes = period_bytes;\n\tdma->periods = periods;\n\n\treturn 0;\n}\n\n \nstatic void atiixp_clear_dma_packets(struct atiixp *chip, struct atiixp_dma *dma,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tif (dma->desc_buf.area) {\n\t\twritel(0, chip->remap_addr + dma->ops->llp_offset);\n\t\tsnd_dma_free_pages(&dma->desc_buf);\n\t\tdma->desc_buf.area = NULL;\n\t}\n}\n\n \nstatic int snd_atiixp_acquire_codec(struct atiixp *chip)\n{\n\tint timeout = 1000;\n\n\twhile (atiixp_read(chip, PHYS_OUT_ADDR) & ATI_REG_PHYS_OUT_ADDR_EN) {\n\t\tif (! timeout--) {\n\t\t\tdev_warn(chip->card->dev, \"codec acquire timeout\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn 0;\n}\n\nstatic unsigned short snd_atiixp_codec_read(struct atiixp *chip, unsigned short codec, unsigned short reg)\n{\n\tunsigned int data;\n\tint timeout;\n\n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn 0xffff;\n\tdata = (reg << ATI_REG_PHYS_OUT_ADDR_SHIFT) |\n\t\tATI_REG_PHYS_OUT_ADDR_EN |\n\t\tATI_REG_PHYS_OUT_RW |\n\t\tcodec;\n\tatiixp_write(chip, PHYS_OUT_ADDR, data);\n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn 0xffff;\n\ttimeout = 1000;\n\tdo {\n\t\tdata = atiixp_read(chip, PHYS_IN_ADDR);\n\t\tif (data & ATI_REG_PHYS_IN_READ_FLAG)\n\t\t\treturn data >> ATI_REG_PHYS_IN_DATA_SHIFT;\n\t\tudelay(1);\n\t} while (--timeout);\n\t \n\tif (reg < 0x7c)\n\t\tdev_warn(chip->card->dev, \"codec read timeout (reg %x)\\n\", reg);\n\treturn 0xffff;\n}\n\n\nstatic void snd_atiixp_codec_write(struct atiixp *chip, unsigned short codec,\n\t\t\t\t   unsigned short reg, unsigned short val)\n{\n\tunsigned int data;\n    \n\tif (snd_atiixp_acquire_codec(chip) < 0)\n\t\treturn;\n\tdata = ((unsigned int)val << ATI_REG_PHYS_OUT_DATA_SHIFT) |\n\t\t((unsigned int)reg << ATI_REG_PHYS_OUT_ADDR_SHIFT) |\n\t\tATI_REG_PHYS_OUT_ADDR_EN | codec;\n\tatiixp_write(chip, PHYS_OUT_ADDR, data);\n}\n\n\nstatic unsigned short snd_atiixp_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t   unsigned short reg)\n{\n\tstruct atiixp *chip = ac97->private_data;\n\treturn snd_atiixp_codec_read(chip, ac97->num, reg);\n    \n}\n\nstatic void snd_atiixp_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\t  unsigned short val)\n{\n\tstruct atiixp *chip = ac97->private_data;\n\tsnd_atiixp_codec_write(chip, ac97->num, reg, val);\n}\n\n \nstatic int snd_atiixp_aclink_reset(struct atiixp *chip)\n{\n\tint timeout;\n\n\t \n\tif (atiixp_update(chip, CMD, ATI_REG_CMD_POWERDOWN, 0))\n\t\tudelay(10);\n\n\t \n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SOFT_RESET, ATI_REG_CMD_AC_SOFT_RESET);\n\tatiixp_read(chip, CMD);\n\tudelay(10);\n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SOFT_RESET, 0);\n    \n\ttimeout = 10;\n\twhile (! (atiixp_read(chip, CMD) & ATI_REG_CMD_ACLINK_ACTIVE)) {\n\t\t \n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET,\n\t\t\t      ATI_REG_CMD_AC_SYNC);\n\t\tatiixp_read(chip, CMD);\n\t\tmdelay(1);\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_RESET, ATI_REG_CMD_AC_RESET);\n\t\tif (!--timeout) {\n\t\t\tdev_err(chip->card->dev, \"codec reset timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tatiixp_update(chip, CMD, ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET,\n\t\t      ATI_REG_CMD_AC_SYNC|ATI_REG_CMD_AC_RESET);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_atiixp_aclink_down(struct atiixp *chip)\n{\n\t\n\t\n\tatiixp_update(chip, CMD,\n\t\t     ATI_REG_CMD_POWERDOWN | ATI_REG_CMD_AC_RESET,\n\t\t     ATI_REG_CMD_POWERDOWN);\n\treturn 0;\n}\n#endif\n\n \n\n#define ALL_CODEC_NOT_READY \\\n\t    (ATI_REG_ISR_CODEC0_NOT_READY |\\\n\t     ATI_REG_ISR_CODEC1_NOT_READY |\\\n\t     ATI_REG_ISR_CODEC2_NOT_READY)\n#define CODEC_CHECK_BITS (ALL_CODEC_NOT_READY|ATI_REG_ISR_NEW_FRAME)\n\nstatic int ac97_probing_bugs(struct pci_dev *pci)\n{\n\tconst struct snd_pci_quirk *q;\n\n\tq = snd_pci_quirk_lookup(pci, atiixp_quirks);\n\tif (q) {\n\t\tdev_dbg(&pci->dev, \"atiixp quirk for %s.  Forcing codec %d\\n\",\n\t\t\tsnd_pci_quirk_name(q), q->value);\n\t\treturn q->value;\n\t}\n\t \n\treturn -1;\n}\n\nstatic int snd_atiixp_codec_detect(struct atiixp *chip)\n{\n\tint timeout;\n\n\tchip->codec_not_ready_bits = 0;\n\tif (ac97_codec == -1)\n\t\tac97_codec = ac97_probing_bugs(chip->pci);\n\tif (ac97_codec >= 0) {\n\t\tchip->codec_not_ready_bits |= \n\t\t\tCODEC_CHECK_BITS ^ (1 << (ac97_codec + 10));\n\t\treturn 0;\n\t}\n\n\tatiixp_write(chip, IER, CODEC_CHECK_BITS);\n\t \n\ttimeout = 50;\n\twhile (timeout-- > 0) {\n\t\tmdelay(1);\n\t\tif (chip->codec_not_ready_bits)\n\t\t\tbreak;\n\t}\n\tatiixp_write(chip, IER, 0);  \n\n\tif ((chip->codec_not_ready_bits & ALL_CODEC_NOT_READY) == ALL_CODEC_NOT_READY) {\n\t\tdev_err(chip->card->dev, \"no codec detected!\\n\");\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int snd_atiixp_chip_start(struct atiixp *chip)\n{\n\tunsigned int reg;\n\n\t \n\treg = atiixp_read(chip, CMD);\n\treg |= 0x02 << ATI_REG_CMD_SPDF_THRESHOLD_SHIFT;\n\treg |= ATI_REG_CMD_BURST_EN;\n\tatiixp_write(chip, CMD, reg);\n\n\treg = atiixp_read(chip, SPDF_CMD);\n\treg &= ~(ATI_REG_SPDF_CMD_LFSR|ATI_REG_SPDF_CMD_SINGLE_CH);\n\tatiixp_write(chip, SPDF_CMD, reg);\n\n\t \n\tatiixp_write(chip, ISR, 0xffffffff);\n\t \n\tatiixp_write(chip, IER,\n\t\t     ATI_REG_IER_IO_STATUS_EN |\n\t\t     ATI_REG_IER_IN_XRUN_EN |\n\t\t     ATI_REG_IER_OUT_XRUN_EN |\n\t\t     ATI_REG_IER_SPDF_XRUN_EN |\n\t\t     ATI_REG_IER_SPDF_STATUS_EN);\n\treturn 0;\n}\n\n\n \nstatic int snd_atiixp_chip_stop(struct atiixp *chip)\n{\n\t \n\tatiixp_write(chip, ISR, atiixp_read(chip, ISR));\n\t \n\tatiixp_write(chip, IER, 0);\n\treturn 0;\n}\n\n\n \n\n \nstatic snd_pcm_uframes_t snd_atiixp_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct atiixp_dma *dma = runtime->private_data;\n\tunsigned int curptr;\n\tint timeout = 1000;\n\n\twhile (timeout--) {\n\t\tcurptr = readl(chip->remap_addr + dma->ops->dt_cur);\n\t\tif (curptr < dma->buf_addr)\n\t\t\tcontinue;\n\t\tcurptr -= dma->buf_addr;\n\t\tif (curptr >= dma->buf_bytes)\n\t\t\tcontinue;\n\t\treturn bytes_to_frames(runtime, curptr);\n\t}\n\tdev_dbg(chip->card->dev, \"invalid DMA pointer read 0x%x (buf=%x)\\n\",\n\t\t   readl(chip->remap_addr + dma->ops->dt_cur), dma->buf_addr);\n\treturn 0;\n}\n\n \nstatic void snd_atiixp_xrun_dma(struct atiixp *chip, struct atiixp_dma *dma)\n{\n\tif (! dma->substream || ! dma->running)\n\t\treturn;\n\tdev_dbg(chip->card->dev, \"XRUN detected (DMA %d)\\n\", dma->ops->type);\n\tsnd_pcm_stop_xrun(dma->substream);\n}\n\n \nstatic void snd_atiixp_update_dma(struct atiixp *chip, struct atiixp_dma *dma)\n{\n\tif (! dma->substream || ! dma->running)\n\t\treturn;\n\tsnd_pcm_period_elapsed(dma->substream);\n}\n\n \n \nstatic void snd_atiixp_check_bus_busy(struct atiixp *chip)\n{\n\tunsigned int bus_busy;\n\tif (atiixp_read(chip, CMD) & (ATI_REG_CMD_SEND_EN |\n\t\t\t\t      ATI_REG_CMD_RECEIVE_EN |\n\t\t\t\t      ATI_REG_CMD_SPDF_OUT_EN))\n\t\tbus_busy = ATI_REG_IER_SET_BUS_BUSY;\n\telse\n\t\tbus_busy = 0;\n\tatiixp_update(chip, IER, ATI_REG_IER_SET_BUS_BUSY, bus_busy);\n}\n\n \nstatic int snd_atiixp_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\tint err = 0;\n\n\tif (snd_BUG_ON(!dma->ops->enable_transfer ||\n\t\t       !dma->ops->flush_dma))\n\t\treturn -EINVAL;\n\n\tspin_lock(&chip->reg_lock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (dma->running && dma->suspended &&\n\t\t    cmd == SNDRV_PCM_TRIGGER_RESUME)\n\t\t\twritel(dma->saved_curptr, chip->remap_addr +\n\t\t\t       dma->ops->dt_cur);\n\t\tdma->ops->enable_transfer(chip, 1);\n\t\tdma->running = 1;\n\t\tdma->suspended = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tdma->suspended = cmd == SNDRV_PCM_TRIGGER_SUSPEND;\n\t\tif (dma->running && dma->suspended)\n\t\t\tdma->saved_curptr = readl(chip->remap_addr +\n\t\t\t\t\t\t  dma->ops->dt_cur);\n\t\tdma->ops->enable_transfer(chip, 0);\n\t\tdma->running = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (! err) {\n\t\tsnd_atiixp_check_bus_busy(chip);\n\t\tif (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\t\tdma->ops->flush_dma(chip);\n\t\t\tsnd_atiixp_check_bus_busy(chip);\n\t\t}\n\t}\n\tspin_unlock(&chip->reg_lock);\n\treturn err;\n}\n\n\n \n\n \nstatic void atiixp_out_flush_dma(struct atiixp *chip)\n{\n\tatiixp_write(chip, FIFO_FLUSH, ATI_REG_FIFO_OUT_FLUSH);\n}\n\n \nstatic void atiixp_out_enable_dma(struct atiixp *chip, int on)\n{\n\tunsigned int data;\n\tdata = atiixp_read(chip, CMD);\n\tif (on) {\n\t\tif (data & ATI_REG_CMD_OUT_DMA_EN)\n\t\t\treturn;\n\t\tatiixp_out_flush_dma(chip);\n\t\tdata |= ATI_REG_CMD_OUT_DMA_EN;\n\t} else\n\t\tdata &= ~ATI_REG_CMD_OUT_DMA_EN;\n\tatiixp_write(chip, CMD, data);\n}\n\n \nstatic void atiixp_out_enable_transfer(struct atiixp *chip, int on)\n{\n\tatiixp_update(chip, CMD, ATI_REG_CMD_SEND_EN,\n\t\t      on ? ATI_REG_CMD_SEND_EN : 0);\n}\n\n \nstatic void atiixp_in_enable_dma(struct atiixp *chip, int on)\n{\n\tatiixp_update(chip, CMD, ATI_REG_CMD_IN_DMA_EN,\n\t\t      on ? ATI_REG_CMD_IN_DMA_EN : 0);\n}\n\n \nstatic void atiixp_in_enable_transfer(struct atiixp *chip, int on)\n{\n\tif (on) {\n\t\tunsigned int data = atiixp_read(chip, CMD);\n\t\tif (! (data & ATI_REG_CMD_RECEIVE_EN)) {\n\t\t\tdata |= ATI_REG_CMD_RECEIVE_EN;\n#if 0  \n\t\t\t \n\t\t\twhile ((atiixp_read(chip, COUNTER) &\n\t\t\t\tATI_REG_COUNTER_SLOT) != 5)\n\t\t\t\t;\n#endif\n\t\t\tatiixp_write(chip, CMD, data);\n\t\t}\n\t} else\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_RECEIVE_EN, 0);\n}\n\n \nstatic void atiixp_in_flush_dma(struct atiixp *chip)\n{\n\tatiixp_write(chip, FIFO_FLUSH, ATI_REG_FIFO_IN_FLUSH);\n}\n\n \nstatic void atiixp_spdif_enable_dma(struct atiixp *chip, int on)\n{\n\tatiixp_update(chip, CMD, ATI_REG_CMD_SPDF_DMA_EN,\n\t\t      on ? ATI_REG_CMD_SPDF_DMA_EN : 0);\n}\n\n \nstatic void atiixp_spdif_enable_transfer(struct atiixp *chip, int on)\n{\n\tunsigned int data;\n\tdata = atiixp_read(chip, CMD);\n\tif (on)\n\t\tdata |= ATI_REG_CMD_SPDF_OUT_EN;\n\telse\n\t\tdata &= ~ATI_REG_CMD_SPDF_OUT_EN;\n\tatiixp_write(chip, CMD, data);\n}\n\n \nstatic void atiixp_spdif_flush_dma(struct atiixp *chip)\n{\n\tint timeout;\n\n\t \n\tatiixp_spdif_enable_dma(chip, 0);\n\tatiixp_spdif_enable_transfer(chip, 1);\n\t\n\ttimeout = 100;\n\tdo {\n\t\tif (! (atiixp_read(chip, SPDF_DMA_DT_SIZE) & ATI_REG_DMA_FIFO_USED))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (timeout-- > 0);\n\n\tatiixp_spdif_enable_transfer(chip, 0);\n}\n\n \nstatic int snd_atiixp_spdif_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tif (chip->spdif_over_aclink) {\n\t\tunsigned int data;\n\t\t \n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_SPDF_CONFIG_MASK,\n\t\t\t      ATI_REG_CMD_SPDF_CONFIG_01);\n\t\tdata = atiixp_read(chip, OUT_DMA_SLOT) & ~ATI_REG_OUT_DMA_SLOT_MASK;\n\t\tdata |= ATI_REG_OUT_DMA_SLOT_BIT(10) |\n\t\t\tATI_REG_OUT_DMA_SLOT_BIT(11);\n\t\tdata |= 0x04 << ATI_REG_OUT_DMA_THRESHOLD_SHIFT;\n\t\tatiixp_write(chip, OUT_DMA_SLOT, data);\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_OUT,\n\t\t\t      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?\n\t\t\t      ATI_REG_CMD_INTERLEAVE_OUT : 0);\n\t} else {\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_SPDF_CONFIG_MASK, 0);\n\t\tatiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_SPDF, 0);\n\t}\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tunsigned int data;\n\n\tspin_lock_irq(&chip->reg_lock);\n\tdata = atiixp_read(chip, OUT_DMA_SLOT) & ~ATI_REG_OUT_DMA_SLOT_MASK;\n\tswitch (substream->runtime->channels) {\n\tcase 8:\n\t\tdata |= ATI_REG_OUT_DMA_SLOT_BIT(10) |\n\t\t\tATI_REG_OUT_DMA_SLOT_BIT(11);\n\t\tfallthrough;\n\tcase 6:\n\t\tdata |= ATI_REG_OUT_DMA_SLOT_BIT(7) |\n\t\t\tATI_REG_OUT_DMA_SLOT_BIT(8);\n\t\tfallthrough;\n\tcase 4:\n\t\tdata |= ATI_REG_OUT_DMA_SLOT_BIT(6) |\n\t\t\tATI_REG_OUT_DMA_SLOT_BIT(9);\n\t\tfallthrough;\n\tdefault:\n\t\tdata |= ATI_REG_OUT_DMA_SLOT_BIT(3) |\n\t\t\tATI_REG_OUT_DMA_SLOT_BIT(4);\n\t\tbreak;\n\t}\n\n\t \n\tdata |= 0x04 << ATI_REG_OUT_DMA_THRESHOLD_SHIFT;\n\tatiixp_write(chip, OUT_DMA_SLOT, data);\n\n\tatiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_OUT,\n\t\t      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?\n\t\t      ATI_REG_CMD_INTERLEAVE_OUT : 0);\n\n\t \n\tatiixp_update(chip, 6CH_REORDER, ATI_REG_6CH_REORDER_EN,\n\t\t      substream->runtime->channels >= 6 ? ATI_REG_6CH_REORDER_EN: 0);\n    \n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\n\tspin_lock_irq(&chip->reg_lock);\n\tatiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_IN,\n\t\t      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?\n\t\t      ATI_REG_CMD_INTERLEAVE_IN : 0);\n\tspin_unlock_irq(&chip->reg_lock);\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\tint err;\n\n\tdma->buf_addr = substream->runtime->dma_addr;\n\tdma->buf_bytes = params_buffer_bytes(hw_params);\n\n\terr = atiixp_build_dma_packets(chip, dma, substream,\n\t\t\t\t       params_periods(hw_params),\n\t\t\t\t       params_period_bytes(hw_params));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dma->ac97_pcm_type >= 0) {\n\t\tstruct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];\n\t\t \n\t\tif (dma->pcm_open_flag) {\n\t\t\tsnd_ac97_pcm_close(pcm);\n\t\t\tdma->pcm_open_flag = 0;\n\t\t}\n\t\terr = snd_ac97_pcm_open(pcm, params_rate(hw_params),\n\t\t\t\t\tparams_channels(hw_params),\n\t\t\t\t\tpcm->r[0].slots);\n\t\tif (err >= 0)\n\t\t\tdma->pcm_open_flag = 1;\n\t}\n\n\treturn err;\n}\n\nstatic int snd_atiixp_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tstruct atiixp_dma *dma = substream->runtime->private_data;\n\n\tif (dma->pcm_open_flag) {\n\t\tstruct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];\n\t\tsnd_ac97_pcm_close(pcm);\n\t\tdma->pcm_open_flag = 0;\n\t}\n\tatiixp_clear_dma_packets(chip, dma, substream);\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_hardware snd_atiixp_pcm_hw =\n{\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min =\t\t48000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t2,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t256 * 1024,\n\t.period_bytes_min =\t32,\n\t.period_bytes_max =\t128 * 1024,\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tATI_MAX_DESCRIPTORS,\n};\n\nstatic int snd_atiixp_pcm_open(struct snd_pcm_substream *substream,\n\t\t\t       struct atiixp_dma *dma, int pcm_type)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\tif (snd_BUG_ON(!dma->ops || !dma->ops->enable_dma))\n\t\treturn -EINVAL;\n\n\tif (dma->opened)\n\t\treturn -EBUSY;\n\tdma->substream = substream;\n\truntime->hw = snd_atiixp_pcm_hw;\n\tdma->ac97_pcm_type = pcm_type;\n\tif (pcm_type >= 0) {\n\t\truntime->hw.rates = chip->pcms[pcm_type]->rates;\n\t\tsnd_pcm_limit_hw_rates(runtime);\n\t} else {\n\t\t \n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;\n\t}\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\truntime->private_data = dma;\n\n\t \n\tspin_lock_irq(&chip->reg_lock);\n\tdma->ops->enable_dma(chip, 1);\n\tspin_unlock_irq(&chip->reg_lock);\n\tdma->opened = 1;\n\n\treturn 0;\n}\n\nstatic int snd_atiixp_pcm_close(struct snd_pcm_substream *substream,\n\t\t\t\tstruct atiixp_dma *dma)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\t \n\tif (snd_BUG_ON(!dma->ops || !dma->ops->enable_dma))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&chip->reg_lock);\n\tdma->ops->enable_dma(chip, 0);\n\tspin_unlock_irq(&chip->reg_lock);\n\tdma->substream = NULL;\n\tdma->opened = 0;\n\treturn 0;\n}\n\n \nstatic int snd_atiixp_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\n\tmutex_lock(&chip->open_mutex);\n\terr = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 0);\n\tmutex_unlock(&chip->open_mutex);\n\tif (err < 0)\n\t\treturn err;\n\tsubstream->runtime->hw.channels_max = chip->max_channels;\n\tif (chip->max_channels > 2)\n\t\t \n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\treturn 0;\n}\n\nstatic int snd_atiixp_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\tmutex_lock(&chip->open_mutex);\n\terr = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);\n\tmutex_unlock(&chip->open_mutex);\n\treturn err;\n}\n\nstatic int snd_atiixp_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\treturn snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE], 1);\n}\n\nstatic int snd_atiixp_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\treturn snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_CAPTURE]);\n}\n\nstatic int snd_atiixp_spdif_open(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\tmutex_lock(&chip->open_mutex);\n\tif (chip->spdif_over_aclink)  \n\t\terr = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 2);\n\telse\n\t\terr = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_SPDIF], -1);\n\tmutex_unlock(&chip->open_mutex);\n\treturn err;\n}\n\nstatic int snd_atiixp_spdif_close(struct snd_pcm_substream *substream)\n{\n\tstruct atiixp *chip = snd_pcm_substream_chip(substream);\n\tint err;\n\tmutex_lock(&chip->open_mutex);\n\tif (chip->spdif_over_aclink)\n\t\terr = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);\n\telse\n\t\terr = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_SPDIF]);\n\tmutex_unlock(&chip->open_mutex);\n\treturn err;\n}\n\n \nstatic const struct snd_pcm_ops snd_atiixp_playback_ops = {\n\t.open =\t\tsnd_atiixp_playback_open,\n\t.close =\tsnd_atiixp_playback_close,\n\t.hw_params =\tsnd_atiixp_pcm_hw_params,\n\t.hw_free =\tsnd_atiixp_pcm_hw_free,\n\t.prepare =\tsnd_atiixp_playback_prepare,\n\t.trigger =\tsnd_atiixp_pcm_trigger,\n\t.pointer =\tsnd_atiixp_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_atiixp_capture_ops = {\n\t.open =\t\tsnd_atiixp_capture_open,\n\t.close =\tsnd_atiixp_capture_close,\n\t.hw_params =\tsnd_atiixp_pcm_hw_params,\n\t.hw_free =\tsnd_atiixp_pcm_hw_free,\n\t.prepare =\tsnd_atiixp_capture_prepare,\n\t.trigger =\tsnd_atiixp_pcm_trigger,\n\t.pointer =\tsnd_atiixp_pcm_pointer,\n};\n\n \nstatic const struct snd_pcm_ops snd_atiixp_spdif_ops = {\n\t.open =\t\tsnd_atiixp_spdif_open,\n\t.close =\tsnd_atiixp_spdif_close,\n\t.hw_params =\tsnd_atiixp_pcm_hw_params,\n\t.hw_free =\tsnd_atiixp_pcm_hw_free,\n\t.prepare =\tsnd_atiixp_spdif_prepare,\n\t.trigger =\tsnd_atiixp_pcm_trigger,\n\t.pointer =\tsnd_atiixp_pcm_pointer,\n};\n\nstatic const struct ac97_pcm atiixp_pcm_defs[] = {\n\t \n\t{\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_CENTER) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_SLEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_SRIGHT) |\n\t\t\t\t\t (1 << AC97_SLOT_LFE)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.stream = 1,\n\t\t.exclusive = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_PCM_LEFT) |\n\t\t\t\t\t (1 << AC97_SLOT_PCM_RIGHT)\n\t\t\t}\n\t\t}\n\t},\n\t \n\t{\n\t\t.exclusive = 1,\n\t\t.spdif = 1,\n\t\t.r = {\t{\n\t\t\t\t.slots = (1 << AC97_SLOT_SPDIF_LEFT2) |\n\t\t\t\t\t (1 << AC97_SLOT_SPDIF_RIGHT2)\n\t\t\t}\n\t\t}\n\t},\n};\n\nstatic const struct atiixp_dma_ops snd_atiixp_playback_dma_ops = {\n\t.type = ATI_DMA_PLAYBACK,\n\t.llp_offset = ATI_REG_OUT_DMA_LINKPTR,\n\t.dt_cur = ATI_REG_OUT_DMA_DT_CUR,\n\t.enable_dma = atiixp_out_enable_dma,\n\t.enable_transfer = atiixp_out_enable_transfer,\n\t.flush_dma = atiixp_out_flush_dma,\n};\n\t\nstatic const struct atiixp_dma_ops snd_atiixp_capture_dma_ops = {\n\t.type = ATI_DMA_CAPTURE,\n\t.llp_offset = ATI_REG_IN_DMA_LINKPTR,\n\t.dt_cur = ATI_REG_IN_DMA_DT_CUR,\n\t.enable_dma = atiixp_in_enable_dma,\n\t.enable_transfer = atiixp_in_enable_transfer,\n\t.flush_dma = atiixp_in_flush_dma,\n};\n\t\nstatic const struct atiixp_dma_ops snd_atiixp_spdif_dma_ops = {\n\t.type = ATI_DMA_SPDIF,\n\t.llp_offset = ATI_REG_SPDF_DMA_LINKPTR,\n\t.dt_cur = ATI_REG_SPDF_DMA_DT_CUR,\n\t.enable_dma = atiixp_spdif_enable_dma,\n\t.enable_transfer = atiixp_spdif_enable_transfer,\n\t.flush_dma = atiixp_spdif_flush_dma,\n};\n\t\n\nstatic int snd_atiixp_pcm_new(struct atiixp *chip)\n{\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_chmap *chmap;\n\tstruct snd_ac97_bus *pbus = chip->ac97_bus;\n\tint err, i, num_pcms;\n\n\t \n\tchip->dmas[ATI_DMA_PLAYBACK].ops = &snd_atiixp_playback_dma_ops;\n\tchip->dmas[ATI_DMA_CAPTURE].ops = &snd_atiixp_capture_dma_ops;\n\tif (! chip->spdif_over_aclink)\n\t\tchip->dmas[ATI_DMA_SPDIF].ops = &snd_atiixp_spdif_dma_ops;\n\n\t \n\tif (chip->spdif_over_aclink)\n\t\tnum_pcms = 3;\n\telse\n\t\tnum_pcms = 2;\n\terr = snd_ac97_pcm_assign(pbus, num_pcms, atiixp_pcm_defs);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < num_pcms; i++)\n\t\tchip->pcms[i] = &pbus->pcms[i];\n\n\tchip->max_channels = 2;\n\tif (pbus->pcms[ATI_PCM_OUT].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {\n\t\tif (pbus->pcms[ATI_PCM_OUT].r[0].slots & (1 << AC97_SLOT_LFE))\n\t\t\tchip->max_channels = 6;\n\t\telse\n\t\t\tchip->max_channels = 4;\n\t}\n\n\t \n\terr = snd_pcm_new(chip->card, \"ATI IXP AC97\",\n\t\t\t  ATI_PCMDEV_ANALOG, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_atiixp_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_atiixp_capture_ops);\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"ATI IXP AC97\");\n\tchip->pcmdevs[ATI_PCMDEV_ANALOG] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 128*1024);\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t     snd_pcm_alt_chmaps, chip->max_channels, 0,\n\t\t\t\t     &chmap);\n\tif (err < 0)\n\t\treturn err;\n\tchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\n\tchip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\n\n\t \n\tif (chip->pcms[ATI_PCM_SPDIF] && ! chip->pcms[ATI_PCM_SPDIF]->rates)\n\t\treturn 0;\n\t\t\n\t \n\tif (chip->pcms[ATI_PCM_SPDIF])\n\t\tchip->pcms[ATI_PCM_SPDIF]->rates = SNDRV_PCM_RATE_48000;\n\n\t \n\terr = snd_pcm_new(chip->card, \"ATI IXP IEC958\",\n\t\t\t  ATI_PCMDEV_DIGITAL, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_atiixp_spdif_ops);\n\tpcm->private_data = chip;\n\tif (chip->spdif_over_aclink)\n\t\tstrcpy(pcm->name, \"ATI IXP IEC958 (AC97)\");\n\telse\n\t\tstrcpy(pcm->name, \"ATI IXP IEC958 (Direct)\");\n\tchip->pcmdevs[ATI_PCMDEV_DIGITAL] = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->pci->dev, 64*1024, 128*1024);\n\n\t \n\tfor (i = 0; i < NUM_ATI_CODECS; i++) {\n\t\tif (chip->ac97[i])\n\t\t\tsnd_ac97_update_bits(chip->ac97[i],\n\t\t\t\t\t     AC97_EXTENDED_STATUS,\n\t\t\t\t\t     0x03 << 4, 0x03 << 4);\n\t}\n\n\treturn 0;\n}\n\n\n\n \nstatic irqreturn_t snd_atiixp_interrupt(int irq, void *dev_id)\n{\n\tstruct atiixp *chip = dev_id;\n\tunsigned int status;\n\n\tstatus = atiixp_read(chip, ISR);\n\n\tif (! status)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & ATI_REG_ISR_OUT_XRUN)\n\t\tsnd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_PLAYBACK]);\n\telse if (status & ATI_REG_ISR_OUT_STATUS)\n\t\tsnd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_PLAYBACK]);\n\tif (status & ATI_REG_ISR_IN_XRUN)\n\t\tsnd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_CAPTURE]);\n\telse if (status & ATI_REG_ISR_IN_STATUS)\n\t\tsnd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_CAPTURE]);\n\tif (! chip->spdif_over_aclink) {\n\t\tif (status & ATI_REG_ISR_SPDF_XRUN)\n\t\t\tsnd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_SPDIF]);\n\t\telse if (status & ATI_REG_ISR_SPDF_STATUS)\n\t\t\tsnd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_SPDIF]);\n\t}\n\n\t \n\tif (status & CODEC_CHECK_BITS) {\n\t\tunsigned int detected;\n\t\tdetected = status & CODEC_CHECK_BITS;\n\t\tspin_lock(&chip->reg_lock);\n\t\tchip->codec_not_ready_bits |= detected;\n\t\tatiixp_update(chip, IER, detected, 0);  \n\t\tspin_unlock(&chip->reg_lock);\n\t}\n\n\t \n\tatiixp_write(chip, ISR, status);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic const struct ac97_quirk ac97_quirks[] = {\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x006b,\n\t\t.name = \"HP Pavilion ZV5030US\",\n\t\t.type = AC97_TUNE_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x308b,\n\t\t.name = \"HP nx6125\",\n\t\t.type = AC97_TUNE_MUTE_LED\n\t},\n\t{\n\t\t.subvendor = 0x103c,\n\t\t.subdevice = 0x3091,\n\t\t.name = \"unknown HP\",\n\t\t.type = AC97_TUNE_MUTE_LED\n\t},\n\t{ }  \n};\n\nstatic int snd_atiixp_mixer_new(struct atiixp *chip, int clock,\n\t\t\t\tconst char *quirk_override)\n{\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint i, err;\n\tint codec_count;\n\tstatic const struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_atiixp_ac97_write,\n\t\t.read = snd_atiixp_ac97_read,\n\t};\n\tstatic const unsigned int codec_skip[NUM_ATI_CODECS] = {\n\t\tATI_REG_ISR_CODEC0_NOT_READY,\n\t\tATI_REG_ISR_CODEC1_NOT_READY,\n\t\tATI_REG_ISR_CODEC2_NOT_READY,\n\t};\n\n\tif (snd_atiixp_codec_detect(chip) < 0)\n\t\treturn -ENXIO;\n\n\terr = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus);\n\tif (err < 0)\n\t\treturn err;\n\tpbus->clock = clock;\n\tchip->ac97_bus = pbus;\n\n\tcodec_count = 0;\n\tfor (i = 0; i < NUM_ATI_CODECS; i++) {\n\t\tif (chip->codec_not_ready_bits & codec_skip[i])\n\t\t\tcontinue;\n\t\tmemset(&ac97, 0, sizeof(ac97));\n\t\tac97.private_data = chip;\n\t\tac97.pci = chip->pci;\n\t\tac97.num = i;\n\t\tac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;\n\t\tif (! chip->spdif_over_aclink)\n\t\t\tac97.scaps |= AC97_SCAP_NO_SPDIF;\n\t\terr = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i]);\n\t\tif (err < 0) {\n\t\t\tchip->ac97[i] = NULL;  \n\t\t\tdev_dbg(chip->card->dev,\n\t\t\t\t\"codec %d not available for audio\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tcodec_count++;\n\t}\n\n\tif (! codec_count) {\n\t\tdev_err(chip->card->dev, \"no codec available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int snd_atiixp_suspend(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct atiixp *chip = card->private_data;\n\tint i;\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\tfor (i = 0; i < NUM_ATI_CODECS; i++)\n\t\tsnd_ac97_suspend(chip->ac97[i]);\n\tsnd_atiixp_aclink_down(chip);\n\tsnd_atiixp_chip_stop(chip);\n\treturn 0;\n}\n\nstatic int snd_atiixp_resume(struct device *dev)\n{\n\tstruct snd_card *card = dev_get_drvdata(dev);\n\tstruct atiixp *chip = card->private_data;\n\tint i;\n\n\tsnd_atiixp_aclink_reset(chip);\n\tsnd_atiixp_chip_start(chip);\n\n\tfor (i = 0; i < NUM_ATI_CODECS; i++)\n\t\tsnd_ac97_resume(chip->ac97[i]);\n\n\tfor (i = 0; i < NUM_ATI_PCMDEVS; i++)\n\t\tif (chip->pcmdevs[i]) {\n\t\t\tstruct atiixp_dma *dma = &chip->dmas[i];\n\t\t\tif (dma->substream && dma->suspended) {\n\t\t\t\tdma->ops->enable_dma(chip, 1);\n\t\t\t\tdma->substream->ops->prepare(dma->substream);\n\t\t\t\twritel((u32)dma->desc_buf.addr | ATI_REG_LINKPTR_EN,\n\t\t\t\t       chip->remap_addr + dma->ops->llp_offset);\n\t\t\t}\n\t\t}\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_atiixp_pm, snd_atiixp_suspend, snd_atiixp_resume);\n#define SND_ATIIXP_PM_OPS\t&snd_atiixp_pm\n#else\n#define SND_ATIIXP_PM_OPS\tNULL\n#endif  \n\n\n \n\nstatic void snd_atiixp_proc_read(struct snd_info_entry *entry,\n\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct atiixp *chip = entry->private_data;\n\tint i;\n\n\tfor (i = 0; i < 256; i += 4)\n\t\tsnd_iprintf(buffer, \"%02x: %08x\\n\", i, readl(chip->remap_addr + i));\n}\n\nstatic void snd_atiixp_proc_init(struct atiixp *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"atiixp\", chip, snd_atiixp_proc_read);\n}\n\n\n \n\nstatic void snd_atiixp_free(struct snd_card *card)\n{\n\tsnd_atiixp_chip_stop(card->private_data);\n}\n\n \nstatic int snd_atiixp_init(struct snd_card *card, struct pci_dev *pci)\n{\n\tstruct atiixp *chip = card->private_data;\n\tint err;\n\n\terr = pcim_enable_device(pci);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_init(&chip->reg_lock);\n\tmutex_init(&chip->open_mutex);\n\tchip->card = card;\n\tchip->pci = pci;\n\tchip->irq = -1;\n\terr = pcim_iomap_regions(pci, 1 << 0, \"ATI IXP AC97\");\n\tif (err < 0)\n\t\treturn err;\n\tchip->addr = pci_resource_start(pci, 0);\n\tchip->remap_addr = pcim_iomap_table(pci)[0];\n\n\tif (devm_request_irq(&pci->dev, pci->irq, snd_atiixp_interrupt,\n\t\t\t     IRQF_SHARED, KBUILD_MODNAME, chip)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq = pci->irq;\n\tcard->sync_irq = chip->irq;\n\tcard->private_free = snd_atiixp_free;\n\tpci_set_master(pci);\n\n\treturn 0;\n}\n\n\nstatic int __snd_atiixp_probe(struct pci_dev *pci,\n\t\t\t      const struct pci_device_id *pci_id)\n{\n\tstruct snd_card *card;\n\tstruct atiixp *chip;\n\tint err;\n\n\terr = snd_devm_card_new(&pci->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*chip), &card);\n\tif (err < 0)\n\t\treturn err;\n\tchip = card->private_data;\n\n\tstrcpy(card->driver, spdif_aclink ? \"ATIIXP\" : \"ATIIXP-SPDMA\");\n\tstrcpy(card->shortname, \"ATI IXP\");\n\terr = snd_atiixp_init(card, pci);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_atiixp_aclink_reset(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->spdif_over_aclink = spdif_aclink;\n\n\terr = snd_atiixp_mixer_new(chip, ac97_clock, ac97_quirk);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_atiixp_pcm_new(chip);\n\tif (err < 0)\n\t\treturn err;\n\t\n\tsnd_atiixp_proc_init(chip);\n\n\tsnd_atiixp_chip_start(chip);\n\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s rev %x with %s at %#lx, irq %i\", card->shortname,\n\t\t pci->revision,\n\t\t chip->ac97[0] ? snd_ac97_get_short_name(chip->ac97[0]) : \"?\",\n\t\t chip->addr, chip->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpci_set_drvdata(pci, card);\n\treturn 0;\n}\n\nstatic int snd_atiixp_probe(struct pci_dev *pci,\n\t\t\t    const struct pci_device_id *pci_id)\n{\n\treturn snd_card_free_on_error(&pci->dev, __snd_atiixp_probe(pci, pci_id));\n}\n\nstatic struct pci_driver atiixp_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_atiixp_ids,\n\t.probe = snd_atiixp_probe,\n\t.driver = {\n\t\t.pm = SND_ATIIXP_PM_OPS,\n\t},\n};\n\nmodule_pci_driver(atiixp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}