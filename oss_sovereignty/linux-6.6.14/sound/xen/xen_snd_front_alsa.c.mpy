{
  "module_name": "xen_snd_front_alsa.c",
  "hash_id": "f4a530e51eb34e9d580f6116d67cd6ea6d5fd6351f127ba8343d0976b2d4e140",
  "original_prompt": "Ingested from linux-6.6.14/sound/xen/xen_snd_front_alsa.c",
  "human_readable_source": "\n\n \n\n#include <linux/platform_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include <xen/xenbus.h>\n#include <xen/xen-front-pgdir-shbuf.h>\n\n#include \"xen_snd_front.h\"\n#include \"xen_snd_front_alsa.h\"\n#include \"xen_snd_front_cfg.h\"\n#include \"xen_snd_front_evtchnl.h\"\n\nstruct xen_snd_front_pcm_stream_info {\n\tstruct xen_snd_front_info *front_info;\n\tstruct xen_snd_front_evtchnl_pair *evt_pair;\n\n\t \n\tstruct xen_front_pgdir_shbuf shbuf;\n\tu8 *buffer;\n\tsize_t buffer_sz;\n\tint num_pages;\n\tstruct page **pages;\n\n\tint index;\n\n\tbool is_open;\n\tstruct snd_pcm_hardware pcm_hw;\n\n\t \n\tsnd_pcm_uframes_t be_cur_frame;\n\t \n\tatomic_t hw_ptr;\n\t \n\tu32 out_frames;\n};\n\nstruct xen_snd_front_pcm_instance_info {\n\tstruct xen_snd_front_card_info *card_info;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_hardware pcm_hw;\n\tint num_pcm_streams_pb;\n\tstruct xen_snd_front_pcm_stream_info *streams_pb;\n\tint num_pcm_streams_cap;\n\tstruct xen_snd_front_pcm_stream_info *streams_cap;\n};\n\nstruct xen_snd_front_card_info {\n\tstruct xen_snd_front_info *front_info;\n\tstruct snd_card *card;\n\tstruct snd_pcm_hardware pcm_hw;\n\tint num_pcm_instances;\n\tstruct xen_snd_front_pcm_instance_info *pcm_instances;\n};\n\nstruct alsa_sndif_sample_format {\n\tu8 sndif;\n\tsnd_pcm_format_t alsa;\n};\n\nstruct alsa_sndif_hw_param {\n\tu8 sndif;\n\tsnd_pcm_hw_param_t alsa;\n};\n\nstatic const struct alsa_sndif_sample_format ALSA_SNDIF_FORMATS[] = {\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U8,\n\t\t.alsa = SNDRV_PCM_FORMAT_U8\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S8,\n\t\t.alsa = SNDRV_PCM_FORMAT_S8\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U16_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U16_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U16_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U16_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S16_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S16_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S16_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S16_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U24_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U24_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U24_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U24_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S24_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S24_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S24_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S24_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U32_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U32_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_U32_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_U32_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S32_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S32_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_S32_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_S32_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_A_LAW,\n\t\t.alsa = SNDRV_PCM_FORMAT_A_LAW\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_MU_LAW,\n\t\t.alsa = SNDRV_PCM_FORMAT_MU_LAW\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_F32_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_FLOAT_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_F32_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_FLOAT_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_F64_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_FLOAT64_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_F64_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_FLOAT64_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_IEC958_SUBFRAME_LE,\n\t\t.alsa = SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_IEC958_SUBFRAME_BE,\n\t\t.alsa = SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_IMA_ADPCM,\n\t\t.alsa = SNDRV_PCM_FORMAT_IMA_ADPCM\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_MPEG,\n\t\t.alsa = SNDRV_PCM_FORMAT_MPEG\n\t},\n\t{\n\t\t.sndif = XENSND_PCM_FORMAT_GSM,\n\t\t.alsa = SNDRV_PCM_FORMAT_GSM\n\t},\n};\n\nstatic int to_sndif_format(snd_pcm_format_t format)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ALSA_SNDIF_FORMATS); i++)\n\t\tif (ALSA_SNDIF_FORMATS[i].alsa == format)\n\t\t\treturn ALSA_SNDIF_FORMATS[i].sndif;\n\n\treturn -EINVAL;\n}\n\nstatic u64 to_sndif_formats_mask(u64 alsa_formats)\n{\n\tu64 mask;\n\tint i;\n\n\tmask = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ALSA_SNDIF_FORMATS); i++)\n\t\tif (pcm_format_to_bits(ALSA_SNDIF_FORMATS[i].alsa) & alsa_formats)\n\t\t\tmask |= BIT_ULL(ALSA_SNDIF_FORMATS[i].sndif);\n\n\treturn mask;\n}\n\nstatic u64 to_alsa_formats_mask(u64 sndif_formats)\n{\n\tu64 mask;\n\tint i;\n\n\tmask = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ALSA_SNDIF_FORMATS); i++)\n\t\tif (BIT_ULL(ALSA_SNDIF_FORMATS[i].sndif) & sndif_formats)\n\t\t\tmask |= pcm_format_to_bits(ALSA_SNDIF_FORMATS[i].alsa);\n\n\treturn mask;\n}\n\nstatic void stream_clear(struct xen_snd_front_pcm_stream_info *stream)\n{\n\tstream->is_open = false;\n\tstream->be_cur_frame = 0;\n\tstream->out_frames = 0;\n\tatomic_set(&stream->hw_ptr, 0);\n\txen_snd_front_evtchnl_pair_clear(stream->evt_pair);\n\tmemset(&stream->shbuf, 0, sizeof(stream->shbuf));\n\tstream->buffer = NULL;\n\tstream->buffer_sz = 0;\n\tstream->pages = NULL;\n\tstream->num_pages = 0;\n}\n\nstatic void stream_free(struct xen_snd_front_pcm_stream_info *stream)\n{\n\txen_front_pgdir_shbuf_unmap(&stream->shbuf);\n\txen_front_pgdir_shbuf_free(&stream->shbuf);\n\tif (stream->buffer)\n\t\tfree_pages_exact(stream->buffer, stream->buffer_sz);\n\tkfree(stream->pages);\n\tstream_clear(stream);\n}\n\nstatic struct xen_snd_front_pcm_stream_info *\nstream_get(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_instance_info *pcm_instance =\n\t\t\tsnd_pcm_substream_chip(substream);\n\tstruct xen_snd_front_pcm_stream_info *stream;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tstream = &pcm_instance->streams_pb[substream->number];\n\telse\n\t\tstream = &pcm_instance->streams_cap[substream->number];\n\n\treturn stream;\n}\n\nstatic int alsa_hw_rule(struct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = rule->private;\n\tstruct device *dev = &stream->front_info->xb_dev->dev;\n\tstruct snd_mask *formats =\n\t\t\thw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_interval *rates =\n\t\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels =\n\t\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_interval *period =\n\t\t\thw_param_interval(params,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\tstruct snd_interval *buffer =\n\t\t\thw_param_interval(params,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE);\n\tstruct xensnd_query_hw_param req;\n\tstruct xensnd_query_hw_param resp;\n\tstruct snd_interval interval;\n\tstruct snd_mask mask;\n\tu64 sndif_formats;\n\tint changed, ret;\n\n\t \n\n\treq.formats = to_sndif_formats_mask((u64)formats->bits[0] |\n\t\t\t\t\t    (u64)(formats->bits[1]) << 32);\n\n\treq.rates.min = rates->min;\n\treq.rates.max = rates->max;\n\n\treq.channels.min = channels->min;\n\treq.channels.max = channels->max;\n\n\treq.buffer.min = buffer->min;\n\treq.buffer.max = buffer->max;\n\n\treq.period.min = period->min;\n\treq.period.max = period->max;\n\n\tret = xen_snd_front_stream_query_hw_param(&stream->evt_pair->req,\n\t\t\t\t\t\t  &req, &resp);\n\tif (ret < 0) {\n\t\t \n\t\tif (ret == -EIO || ret == -ETIMEDOUT)\n\t\t\tdev_err(dev, \"Failed to query ALSA HW parameters\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tchanged  = 0;\n\n\tsndif_formats = to_alsa_formats_mask(resp.formats);\n\tsnd_mask_none(&mask);\n\tmask.bits[0] = (u32)sndif_formats;\n\tmask.bits[1] = (u32)(sndif_formats >> 32);\n\tret = snd_mask_refine(formats, &mask);\n\tif (ret < 0)\n\t\treturn ret;\n\tchanged |= ret;\n\n\tinterval.openmin = 0;\n\tinterval.openmax = 0;\n\tinterval.integer = 1;\n\n\tinterval.min = resp.rates.min;\n\tinterval.max = resp.rates.max;\n\tret = snd_interval_refine(rates, &interval);\n\tif (ret < 0)\n\t\treturn ret;\n\tchanged |= ret;\n\n\tinterval.min = resp.channels.min;\n\tinterval.max = resp.channels.max;\n\tret = snd_interval_refine(channels, &interval);\n\tif (ret < 0)\n\t\treturn ret;\n\tchanged |= ret;\n\n\tinterval.min = resp.buffer.min;\n\tinterval.max = resp.buffer.max;\n\tret = snd_interval_refine(buffer, &interval);\n\tif (ret < 0)\n\t\treturn ret;\n\tchanged |= ret;\n\n\tinterval.min = resp.period.min;\n\tinterval.max = resp.period.max;\n\tret = snd_interval_refine(period, &interval);\n\tif (ret < 0)\n\t\treturn ret;\n\tchanged |= ret;\n\n\treturn changed;\n}\n\nstatic int alsa_open(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_instance_info *pcm_instance =\n\t\t\tsnd_pcm_substream_chip(substream);\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xen_snd_front_info *front_info =\n\t\t\tpcm_instance->card_info->front_info;\n\tstruct device *dev = &front_info->xb_dev->dev;\n\tint ret;\n\n\t \n\truntime->hw = stream->pcm_hw;\n\truntime->hw.info &= ~(SNDRV_PCM_INFO_MMAP |\n\t\t\t      SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t      SNDRV_PCM_INFO_DOUBLE |\n\t\t\t      SNDRV_PCM_INFO_BATCH |\n\t\t\t      SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t\t      SNDRV_PCM_INFO_RESUME |\n\t\t\t      SNDRV_PCM_INFO_PAUSE);\n\truntime->hw.info |= SNDRV_PCM_INFO_INTERLEAVED;\n\n\tstream->evt_pair = &front_info->evt_pairs[stream->index];\n\n\tstream->front_info = front_info;\n\n\tstream->evt_pair->evt.u.evt.substream = substream;\n\n\tstream_clear(stream);\n\n\txen_snd_front_evtchnl_pair_set_connected(stream->evt_pair, true);\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  alsa_hw_rule, stream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add HW rule for SNDRV_PCM_HW_PARAM_FORMAT\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  alsa_hw_rule, stream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add HW rule for SNDRV_PCM_HW_PARAM_RATE\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  alsa_hw_rule, stream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add HW rule for SNDRV_PCM_HW_PARAM_CHANNELS\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t  alsa_hw_rule, stream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add HW rule for SNDRV_PCM_HW_PARAM_PERIOD_SIZE\\n\");\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t  alsa_hw_rule, stream,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_BUFFER_SIZE, -1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add HW rule for SNDRV_PCM_HW_PARAM_BUFFER_SIZE\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int alsa_close(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\n\txen_snd_front_evtchnl_pair_set_connected(stream->evt_pair, false);\n\treturn 0;\n}\n\nstatic int shbuf_setup_backstore(struct xen_snd_front_pcm_stream_info *stream,\n\t\t\t\t size_t buffer_sz)\n{\n\tint i;\n\n\tstream->buffer = alloc_pages_exact(buffer_sz, GFP_KERNEL);\n\tif (!stream->buffer)\n\t\treturn -ENOMEM;\n\n\tstream->buffer_sz = buffer_sz;\n\tstream->num_pages = DIV_ROUND_UP(stream->buffer_sz, PAGE_SIZE);\n\tstream->pages = kcalloc(stream->num_pages, sizeof(struct page *),\n\t\t\t\tGFP_KERNEL);\n\tif (!stream->pages)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < stream->num_pages; i++)\n\t\tstream->pages[i] = virt_to_page(stream->buffer + i * PAGE_SIZE);\n\n\treturn 0;\n}\n\nstatic int alsa_hw_params(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tstruct xen_snd_front_info *front_info = stream->front_info;\n\tstruct xen_front_pgdir_shbuf_cfg buf_cfg;\n\tint ret;\n\n\t \n\tstream_free(stream);\n\tret = shbuf_setup_backstore(stream, params_buffer_bytes(params));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tmemset(&buf_cfg, 0, sizeof(buf_cfg));\n\tbuf_cfg.xb_dev = front_info->xb_dev;\n\tbuf_cfg.pgdir = &stream->shbuf;\n\tbuf_cfg.num_pages = stream->num_pages;\n\tbuf_cfg.pages = stream->pages;\n\n\tret = xen_front_pgdir_shbuf_alloc(&buf_cfg);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = xen_front_pgdir_shbuf_map(&stream->shbuf);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tstream_free(stream);\n\tdev_err(&front_info->xb_dev->dev,\n\t\t\"Failed to allocate buffers for stream with index %d\\n\",\n\t\tstream->index);\n\treturn ret;\n}\n\nstatic int alsa_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tint ret;\n\n\tret = xen_snd_front_stream_close(&stream->evt_pair->req);\n\tstream_free(stream);\n\treturn ret;\n}\n\nstatic int alsa_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\n\tif (!stream->is_open) {\n\t\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\tu8 sndif_format;\n\t\tint ret;\n\n\t\tret = to_sndif_format(runtime->format);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&stream->front_info->xb_dev->dev,\n\t\t\t\t\"Unsupported sample format: %d\\n\",\n\t\t\t\truntime->format);\n\t\t\treturn ret;\n\t\t}\n\t\tsndif_format = ret;\n\n\t\tret = xen_snd_front_stream_prepare(&stream->evt_pair->req,\n\t\t\t\t\t\t   &stream->shbuf,\n\t\t\t\t\t\t   sndif_format,\n\t\t\t\t\t\t   runtime->channels,\n\t\t\t\t\t\t   runtime->rate,\n\t\t\t\t\t\t   snd_pcm_lib_buffer_bytes(substream),\n\t\t\t\t\t\t   snd_pcm_lib_period_bytes(substream));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstream->is_open = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int alsa_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tint type;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\ttype = XENSND_OP_TRIGGER_START;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\ttype = XENSND_OP_TRIGGER_RESUME;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\ttype = XENSND_OP_TRIGGER_STOP;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\ttype = XENSND_OP_TRIGGER_PAUSE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn xen_snd_front_stream_trigger(&stream->evt_pair->req, type);\n}\n\nvoid xen_snd_front_alsa_handle_cur_pos(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t\t       u64 pos_bytes)\n{\n\tstruct snd_pcm_substream *substream = evtchnl->u.evt.substream;\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tsnd_pcm_uframes_t delta, new_hw_ptr, cur_frame;\n\n\tcur_frame = bytes_to_frames(substream->runtime, pos_bytes);\n\n\tdelta = cur_frame - stream->be_cur_frame;\n\tstream->be_cur_frame = cur_frame;\n\n\tnew_hw_ptr = (snd_pcm_uframes_t)atomic_read(&stream->hw_ptr);\n\tnew_hw_ptr = (new_hw_ptr + delta) % substream->runtime->buffer_size;\n\tatomic_set(&stream->hw_ptr, (int)new_hw_ptr);\n\n\tstream->out_frames += delta;\n\tif (stream->out_frames > substream->runtime->period_size) {\n\t\tstream->out_frames %= substream->runtime->period_size;\n\t\tsnd_pcm_period_elapsed(substream);\n\t}\n}\n\nstatic snd_pcm_uframes_t alsa_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\n\treturn (snd_pcm_uframes_t)atomic_read(&stream->hw_ptr);\n}\n\nstatic int alsa_pb_copy(struct snd_pcm_substream *substream,\n\t\t\tint channel, unsigned long pos, struct iov_iter *src,\n\t\t\tunsigned long count)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\n\tif (unlikely(pos + count > stream->buffer_sz))\n\t\treturn -EINVAL;\n\n\tif (copy_from_iter(stream->buffer + pos, count, src) != count)\n\t\treturn -EFAULT;\n\n\treturn xen_snd_front_stream_write(&stream->evt_pair->req, pos, count);\n}\n\nstatic int alsa_cap_copy(struct snd_pcm_substream *substream,\n\t\t\t int channel, unsigned long pos, struct iov_iter *dst,\n\t\t\t unsigned long count)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\tint ret;\n\n\tif (unlikely(pos + count > stream->buffer_sz))\n\t\treturn -EINVAL;\n\n\tret = xen_snd_front_stream_read(&stream->evt_pair->req, pos, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_iter(stream->buffer + pos, count, dst) != count)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int alsa_pb_fill_silence(struct snd_pcm_substream *substream,\n\t\t\t\tint channel, unsigned long pos,\n\t\t\t\tunsigned long count)\n{\n\tstruct xen_snd_front_pcm_stream_info *stream = stream_get(substream);\n\n\tif (unlikely(pos + count > stream->buffer_sz))\n\t\treturn -EINVAL;\n\n\tmemset(stream->buffer + pos, 0, count);\n\n\treturn xen_snd_front_stream_write(&stream->evt_pair->req, pos, count);\n}\n\n \n\nstatic const struct snd_pcm_ops snd_drv_alsa_playback_ops = {\n\t.open\t\t= alsa_open,\n\t.close\t\t= alsa_close,\n\t.hw_params\t= alsa_hw_params,\n\t.hw_free\t= alsa_hw_free,\n\t.prepare\t= alsa_prepare,\n\t.trigger\t= alsa_trigger,\n\t.pointer\t= alsa_pointer,\n\t.copy\t\t= alsa_pb_copy,\n\t.fill_silence\t= alsa_pb_fill_silence,\n};\n\nstatic const struct snd_pcm_ops snd_drv_alsa_capture_ops = {\n\t.open\t\t= alsa_open,\n\t.close\t\t= alsa_close,\n\t.hw_params\t= alsa_hw_params,\n\t.hw_free\t= alsa_hw_free,\n\t.prepare\t= alsa_prepare,\n\t.trigger\t= alsa_trigger,\n\t.pointer\t= alsa_pointer,\n\t.copy\t\t= alsa_cap_copy,\n};\n\nstatic int new_pcm_instance(struct xen_snd_front_card_info *card_info,\n\t\t\t    struct xen_front_cfg_pcm_instance *instance_cfg,\n\t\t\t    struct xen_snd_front_pcm_instance_info *pcm_instance_info)\n{\n\tstruct snd_pcm *pcm;\n\tint ret, i;\n\n\tdev_dbg(&card_info->front_info->xb_dev->dev,\n\t\t\"New PCM device \\\"%s\\\" with id %d playback %d capture %d\",\n\t\tinstance_cfg->name,\n\t\tinstance_cfg->device_id,\n\t\tinstance_cfg->num_streams_pb,\n\t\tinstance_cfg->num_streams_cap);\n\n\tpcm_instance_info->card_info = card_info;\n\n\tpcm_instance_info->pcm_hw = instance_cfg->pcm_hw;\n\n\tif (instance_cfg->num_streams_pb) {\n\t\tpcm_instance_info->streams_pb =\n\t\t\t\tdevm_kcalloc(&card_info->card->card_dev,\n\t\t\t\t\t     instance_cfg->num_streams_pb,\n\t\t\t\t\t     sizeof(struct xen_snd_front_pcm_stream_info),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcm_instance_info->streams_pb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (instance_cfg->num_streams_cap) {\n\t\tpcm_instance_info->streams_cap =\n\t\t\t\tdevm_kcalloc(&card_info->card->card_dev,\n\t\t\t\t\t     instance_cfg->num_streams_cap,\n\t\t\t\t\t     sizeof(struct xen_snd_front_pcm_stream_info),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcm_instance_info->streams_cap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpcm_instance_info->num_pcm_streams_pb =\n\t\t\tinstance_cfg->num_streams_pb;\n\tpcm_instance_info->num_pcm_streams_cap =\n\t\t\tinstance_cfg->num_streams_cap;\n\n\tfor (i = 0; i < pcm_instance_info->num_pcm_streams_pb; i++) {\n\t\tpcm_instance_info->streams_pb[i].pcm_hw =\n\t\t\tinstance_cfg->streams_pb[i].pcm_hw;\n\t\tpcm_instance_info->streams_pb[i].index =\n\t\t\tinstance_cfg->streams_pb[i].index;\n\t}\n\n\tfor (i = 0; i < pcm_instance_info->num_pcm_streams_cap; i++) {\n\t\tpcm_instance_info->streams_cap[i].pcm_hw =\n\t\t\tinstance_cfg->streams_cap[i].pcm_hw;\n\t\tpcm_instance_info->streams_cap[i].index =\n\t\t\tinstance_cfg->streams_cap[i].index;\n\t}\n\n\tret = snd_pcm_new(card_info->card, instance_cfg->name,\n\t\t\t  instance_cfg->device_id,\n\t\t\t  instance_cfg->num_streams_pb,\n\t\t\t  instance_cfg->num_streams_cap,\n\t\t\t  &pcm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpcm->private_data = pcm_instance_info;\n\tpcm->info_flags = 0;\n\t \n\tpcm->nonatomic = true;\n\tstrscpy(pcm->name, \"Virtual card PCM\", sizeof(pcm->name));\n\n\tif (instance_cfg->num_streams_pb)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&snd_drv_alsa_playback_ops);\n\n\tif (instance_cfg->num_streams_cap)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&snd_drv_alsa_capture_ops);\n\n\tpcm_instance_info->pcm = pcm;\n\treturn 0;\n}\n\nint xen_snd_front_alsa_init(struct xen_snd_front_info *front_info)\n{\n\tstruct device *dev = &front_info->xb_dev->dev;\n\tstruct xen_front_cfg_card *cfg = &front_info->cfg;\n\tstruct xen_snd_front_card_info *card_info;\n\tstruct snd_card *card;\n\tint ret, i;\n\n\tdev_dbg(dev, \"Creating virtual sound card\\n\");\n\n\tret = snd_card_new(dev, 0, XENSND_DRIVER_NAME, THIS_MODULE,\n\t\t\t   sizeof(struct xen_snd_front_card_info), &card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcard_info = card->private_data;\n\tcard_info->front_info = front_info;\n\tfront_info->card_info = card_info;\n\tcard_info->card = card;\n\tcard_info->pcm_instances =\n\t\t\tdevm_kcalloc(dev, cfg->num_pcm_instances,\n\t\t\t\t     sizeof(struct xen_snd_front_pcm_instance_info),\n\t\t\t\t     GFP_KERNEL);\n\tif (!card_info->pcm_instances) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tcard_info->num_pcm_instances = cfg->num_pcm_instances;\n\tcard_info->pcm_hw = cfg->pcm_hw;\n\n\tfor (i = 0; i < cfg->num_pcm_instances; i++) {\n\t\tret = new_pcm_instance(card_info, &cfg->pcm_instances[i],\n\t\t\t\t       &card_info->pcm_instances[i]);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\tstrscpy(card->driver, XENSND_DRIVER_NAME, sizeof(card->driver));\n\tstrscpy(card->shortname, cfg->name_short, sizeof(card->shortname));\n\tstrscpy(card->longname, cfg->name_long, sizeof(card->longname));\n\n\tret = snd_card_register(card);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tsnd_card_free(card);\n\treturn ret;\n}\n\nvoid xen_snd_front_alsa_fini(struct xen_snd_front_info *front_info)\n{\n\tstruct xen_snd_front_card_info *card_info;\n\tstruct snd_card *card;\n\n\tcard_info = front_info->card_info;\n\tif (!card_info)\n\t\treturn;\n\n\tcard = card_info->card;\n\tif (!card)\n\t\treturn;\n\n\tdev_dbg(&front_info->xb_dev->dev, \"Removing virtual sound card %d\\n\",\n\t\tcard->number);\n\tsnd_card_free(card);\n\n\t \n\tcard_info->card = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}