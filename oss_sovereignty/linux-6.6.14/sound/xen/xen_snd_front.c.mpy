{
  "module_name": "xen_snd_front.c",
  "hash_id": "18a2862aa706f5362863d82f6f489d471f71730315f2e1e2f44bbc04eeb0c02f",
  "original_prompt": "Ingested from linux-6.6.14/sound/xen/xen_snd_front.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n\n#include <xen/page.h>\n#include <xen/platform_pci.h>\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n\n#include <xen/xen-front-pgdir-shbuf.h>\n#include <xen/interface/io/sndif.h>\n\n#include \"xen_snd_front.h\"\n#include \"xen_snd_front_alsa.h\"\n#include \"xen_snd_front_evtchnl.h\"\n\nstatic struct xensnd_req *\nbe_stream_prepare_req(struct xen_snd_front_evtchnl *evtchnl, u8 operation)\n{\n\tstruct xensnd_req *req;\n\n\treq = RING_GET_REQUEST(&evtchnl->u.req.ring,\n\t\t\t       evtchnl->u.req.ring.req_prod_pvt);\n\treq->operation = operation;\n\treq->id = evtchnl->evt_next_id++;\n\tevtchnl->evt_id = req->id;\n\treturn req;\n}\n\nstatic int be_stream_do_io(struct xen_snd_front_evtchnl *evtchnl)\n{\n\tif (unlikely(evtchnl->state != EVTCHNL_STATE_CONNECTED))\n\t\treturn -EIO;\n\n\treinit_completion(&evtchnl->u.req.completion);\n\txen_snd_front_evtchnl_flush(evtchnl);\n\treturn 0;\n}\n\nstatic int be_stream_wait_io(struct xen_snd_front_evtchnl *evtchnl)\n{\n\tif (wait_for_completion_timeout(&evtchnl->u.req.completion,\n\t\t\tmsecs_to_jiffies(VSND_WAIT_BACK_MS)) <= 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn evtchnl->u.req.resp_status;\n}\n\nint xen_snd_front_stream_query_hw_param(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t\t\tstruct xensnd_query_hw_param *hw_param_req,\n\t\t\t\t\tstruct xensnd_query_hw_param *hw_param_resp)\n{\n\tstruct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_HW_PARAM_QUERY);\n\treq->op.hw_param = *hw_param_req;\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tif (ret == 0)\n\t\t*hw_param_resp = evtchnl->u.req.resp.hw_param;\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nint xen_snd_front_stream_prepare(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t\t struct xen_front_pgdir_shbuf *shbuf,\n\t\t\t\t u8 format, unsigned int channels,\n\t\t\t\t unsigned int rate, u32 buffer_sz,\n\t\t\t\t u32 period_sz)\n{\n\tstruct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_OPEN);\n\treq->op.open.pcm_format = format;\n\treq->op.open.pcm_channels = channels;\n\treq->op.open.pcm_rate = rate;\n\treq->op.open.buffer_sz = buffer_sz;\n\treq->op.open.period_sz = period_sz;\n\treq->op.open.gref_directory =\n\t\txen_front_pgdir_shbuf_get_dir_start(shbuf);\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nint xen_snd_front_stream_close(struct xen_snd_front_evtchnl *evtchnl)\n{\n\t__always_unused struct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_CLOSE);\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nint xen_snd_front_stream_write(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t       unsigned long pos, unsigned long count)\n{\n\tstruct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_WRITE);\n\treq->op.rw.length = count;\n\treq->op.rw.offset = pos;\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nint xen_snd_front_stream_read(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t      unsigned long pos, unsigned long count)\n{\n\tstruct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_READ);\n\treq->op.rw.length = count;\n\treq->op.rw.offset = pos;\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nint xen_snd_front_stream_trigger(struct xen_snd_front_evtchnl *evtchnl,\n\t\t\t\t int type)\n{\n\tstruct xensnd_req *req;\n\tint ret;\n\n\tmutex_lock(&evtchnl->u.req.req_io_lock);\n\n\tmutex_lock(&evtchnl->ring_io_lock);\n\treq = be_stream_prepare_req(evtchnl, XENSND_OP_TRIGGER);\n\treq->op.trigger.type = type;\n\tmutex_unlock(&evtchnl->ring_io_lock);\n\n\tret = be_stream_do_io(evtchnl);\n\n\tif (ret == 0)\n\t\tret = be_stream_wait_io(evtchnl);\n\n\tmutex_unlock(&evtchnl->u.req.req_io_lock);\n\treturn ret;\n}\n\nstatic void xen_snd_drv_fini(struct xen_snd_front_info *front_info)\n{\n\txen_snd_front_alsa_fini(front_info);\n\txen_snd_front_evtchnl_free_all(front_info);\n}\n\nstatic int sndback_initwait(struct xen_snd_front_info *front_info)\n{\n\tint num_streams;\n\tint ret;\n\n\tret = xen_snd_front_cfg_card(front_info, &num_streams);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = xen_snd_front_evtchnl_create_all(front_info, num_streams);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn xen_snd_front_evtchnl_publish_all(front_info);\n}\n\nstatic int sndback_connect(struct xen_snd_front_info *front_info)\n{\n\treturn xen_snd_front_alsa_init(front_info);\n}\n\nstatic void sndback_disconnect(struct xen_snd_front_info *front_info)\n{\n\txen_snd_drv_fini(front_info);\n\txenbus_switch_state(front_info->xb_dev, XenbusStateInitialising);\n}\n\nstatic void sndback_changed(struct xenbus_device *xb_dev,\n\t\t\t    enum xenbus_state backend_state)\n{\n\tstruct xen_snd_front_info *front_info = dev_get_drvdata(&xb_dev->dev);\n\tint ret;\n\n\tdev_dbg(&xb_dev->dev, \"Backend state is %s, front is %s\\n\",\n\t\txenbus_strstate(backend_state),\n\t\txenbus_strstate(xb_dev->state));\n\n\tswitch (backend_state) {\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateInitialised:\n\t\tbreak;\n\n\tcase XenbusStateInitialising:\n\t\t \n\t\tsndback_disconnect(front_info);\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\t\t \n\t\tsndback_disconnect(front_info);\n\n\t\tret = sndback_initwait(front_info);\n\t\tif (ret < 0)\n\t\t\txenbus_dev_fatal(xb_dev, ret, \"initializing frontend\");\n\t\telse\n\t\t\txenbus_switch_state(xb_dev, XenbusStateInitialised);\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\tif (xb_dev->state != XenbusStateInitialised)\n\t\t\tbreak;\n\n\t\tret = sndback_connect(front_info);\n\t\tif (ret < 0)\n\t\t\txenbus_dev_fatal(xb_dev, ret, \"initializing frontend\");\n\t\telse\n\t\t\txenbus_switch_state(xb_dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosing:\n\t\t \n\t\tbreak;\n\n\tcase XenbusStateUnknown:\n\tcase XenbusStateClosed:\n\t\tif (xb_dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\n\t\tsndback_disconnect(front_info);\n\t\tbreak;\n\t}\n}\n\nstatic int xen_drv_probe(struct xenbus_device *xb_dev,\n\t\t\t const struct xenbus_device_id *id)\n{\n\tstruct xen_snd_front_info *front_info;\n\n\tfront_info = devm_kzalloc(&xb_dev->dev,\n\t\t\t\t  sizeof(*front_info), GFP_KERNEL);\n\tif (!front_info)\n\t\treturn -ENOMEM;\n\n\tfront_info->xb_dev = xb_dev;\n\tdev_set_drvdata(&xb_dev->dev, front_info);\n\n\treturn xenbus_switch_state(xb_dev, XenbusStateInitialising);\n}\n\nstatic void xen_drv_remove(struct xenbus_device *dev)\n{\n\tstruct xen_snd_front_info *front_info = dev_get_drvdata(&dev->dev);\n\tint to = 100;\n\n\txenbus_switch_state(dev, XenbusStateClosing);\n\n\t \n\twhile ((xenbus_read_unsigned(front_info->xb_dev->otherend, \"state\",\n\t\t\t\t     XenbusStateUnknown) != XenbusStateInitWait) &&\n\t       --to)\n\t\tmsleep(10);\n\n\tif (!to) {\n\t\tunsigned int state;\n\n\t\tstate = xenbus_read_unsigned(front_info->xb_dev->otherend,\n\t\t\t\t\t     \"state\", XenbusStateUnknown);\n\t\tpr_err(\"Backend state is %s while removing driver\\n\",\n\t\t       xenbus_strstate(state));\n\t}\n\n\txen_snd_drv_fini(front_info);\n\txenbus_frontend_closed(dev);\n}\n\nstatic const struct xenbus_device_id xen_drv_ids[] = {\n\t{ XENSND_DRIVER_NAME },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver xen_driver = {\n\t.ids = xen_drv_ids,\n\t.probe = xen_drv_probe,\n\t.remove = xen_drv_remove,\n\t.otherend_changed = sndback_changed,\n\t.not_essential = true,\n};\n\nstatic int __init xen_drv_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\t \n\tif (XEN_PAGE_SIZE != PAGE_SIZE) {\n\t\tpr_err(XENSND_DRIVER_NAME \": different kernel and Xen page sizes are not supported: XEN_PAGE_SIZE (%lu) != PAGE_SIZE (%lu)\\n\",\n\t\t       XEN_PAGE_SIZE, PAGE_SIZE);\n\t\treturn -ENODEV;\n\t}\n\n\tpr_info(\"Initialising Xen \" XENSND_DRIVER_NAME \" frontend driver\\n\");\n\treturn xenbus_register_frontend(&xen_driver);\n}\n\nstatic void __exit xen_drv_fini(void)\n{\n\tpr_info(\"Unregistering Xen \" XENSND_DRIVER_NAME \" frontend driver\\n\");\n\txenbus_unregister_driver(&xen_driver);\n}\n\nmodule_init(xen_drv_init);\nmodule_exit(xen_drv_fini);\n\nMODULE_DESCRIPTION(\"Xen virtual sound device frontend\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xen:\" XENSND_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}