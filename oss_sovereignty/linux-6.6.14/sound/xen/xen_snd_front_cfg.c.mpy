{
  "module_name": "xen_snd_front_cfg.c",
  "hash_id": "91ad22ef15e16d813304ada2f80ec88135764bfd03995ecb33bf7bdc982aea38",
  "original_prompt": "Ingested from linux-6.6.14/sound/xen/xen_snd_front_cfg.c",
  "human_readable_source": "\n\n \n\n#include <xen/xenbus.h>\n\n#include <xen/interface/io/sndif.h>\n\n#include \"xen_snd_front.h\"\n#include \"xen_snd_front_cfg.h\"\n\n \n#define VSND_MAX_STREAM\t\t8\n\nstruct cfg_hw_sample_rate {\n\tconst char *name;\n\tunsigned int mask;\n\tunsigned int value;\n};\n\nstatic const struct cfg_hw_sample_rate CFG_HW_SUPPORTED_RATES[] = {\n\t{ .name = \"5512\",   .mask = SNDRV_PCM_RATE_5512,   .value = 5512 },\n\t{ .name = \"8000\",   .mask = SNDRV_PCM_RATE_8000,   .value = 8000 },\n\t{ .name = \"11025\",  .mask = SNDRV_PCM_RATE_11025,  .value = 11025 },\n\t{ .name = \"16000\",  .mask = SNDRV_PCM_RATE_16000,  .value = 16000 },\n\t{ .name = \"22050\",  .mask = SNDRV_PCM_RATE_22050,  .value = 22050 },\n\t{ .name = \"32000\",  .mask = SNDRV_PCM_RATE_32000,  .value = 32000 },\n\t{ .name = \"44100\",  .mask = SNDRV_PCM_RATE_44100,  .value = 44100 },\n\t{ .name = \"48000\",  .mask = SNDRV_PCM_RATE_48000,  .value = 48000 },\n\t{ .name = \"64000\",  .mask = SNDRV_PCM_RATE_64000,  .value = 64000 },\n\t{ .name = \"96000\",  .mask = SNDRV_PCM_RATE_96000,  .value = 96000 },\n\t{ .name = \"176400\", .mask = SNDRV_PCM_RATE_176400, .value = 176400 },\n\t{ .name = \"192000\", .mask = SNDRV_PCM_RATE_192000, .value = 192000 },\n};\n\nstruct cfg_hw_sample_format {\n\tconst char *name;\n\tu64 mask;\n};\n\nstatic const struct cfg_hw_sample_format CFG_HW_SUPPORTED_FORMATS[] = {\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U8_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U8\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S8_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S8\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U16_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U16_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U16_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U16_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S16_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S16_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S16_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S16_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U24_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U24_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U24_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U24_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S24_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S24_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S24_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S24_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U32_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U32_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_U32_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_U32_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S32_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S32_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_S32_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_S32_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_A_LAW_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_A_LAW\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_MU_LAW_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_MU_LAW\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_F32_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_FLOAT_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_F32_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_FLOAT_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_F64_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_FLOAT64_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_F64_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_FLOAT64_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_IEC958_SUBFRAME_LE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_IEC958_SUBFRAME_BE_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_IMA_ADPCM_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_IMA_ADPCM\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_MPEG_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_MPEG\n\t},\n\t{\n\t\t.name = XENSND_PCM_FORMAT_GSM_STR,\n\t\t.mask = SNDRV_PCM_FMTBIT_GSM\n\t},\n};\n\nstatic void cfg_hw_rates(char *list, unsigned int len,\n\t\t\t const char *path, struct snd_pcm_hardware *pcm_hw)\n{\n\tchar *cur_rate;\n\tunsigned int cur_mask;\n\tunsigned int cur_value;\n\tunsigned int rates;\n\tunsigned int rate_min;\n\tunsigned int rate_max;\n\tint i;\n\n\trates = 0;\n\trate_min = -1;\n\trate_max = 0;\n\twhile ((cur_rate = strsep(&list, XENSND_LIST_SEPARATOR))) {\n\t\tfor (i = 0; i < ARRAY_SIZE(CFG_HW_SUPPORTED_RATES); i++)\n\t\t\tif (!strncasecmp(cur_rate,\n\t\t\t\t\t CFG_HW_SUPPORTED_RATES[i].name,\n\t\t\t\t\t XENSND_SAMPLE_RATE_MAX_LEN)) {\n\t\t\t\tcur_mask = CFG_HW_SUPPORTED_RATES[i].mask;\n\t\t\t\tcur_value = CFG_HW_SUPPORTED_RATES[i].value;\n\t\t\t\trates |= cur_mask;\n\t\t\t\tif (rate_min > cur_value)\n\t\t\t\t\trate_min = cur_value;\n\t\t\t\tif (rate_max < cur_value)\n\t\t\t\t\trate_max = cur_value;\n\t\t\t}\n\t}\n\n\tif (rates) {\n\t\tpcm_hw->rates = rates;\n\t\tpcm_hw->rate_min = rate_min;\n\t\tpcm_hw->rate_max = rate_max;\n\t}\n}\n\nstatic void cfg_formats(char *list, unsigned int len,\n\t\t\tconst char *path, struct snd_pcm_hardware *pcm_hw)\n{\n\tu64 formats;\n\tchar *cur_format;\n\tint i;\n\n\tformats = 0;\n\twhile ((cur_format = strsep(&list, XENSND_LIST_SEPARATOR))) {\n\t\tfor (i = 0; i < ARRAY_SIZE(CFG_HW_SUPPORTED_FORMATS); i++)\n\t\t\tif (!strncasecmp(cur_format,\n\t\t\t\t\t CFG_HW_SUPPORTED_FORMATS[i].name,\n\t\t\t\t\t XENSND_SAMPLE_FORMAT_MAX_LEN))\n\t\t\t\tformats |= CFG_HW_SUPPORTED_FORMATS[i].mask;\n\t}\n\n\tif (formats)\n\t\tpcm_hw->formats = formats;\n}\n\n#define MAX_BUFFER_SIZE\t\t(64 * 1024)\n#define MIN_PERIOD_SIZE\t\t64\n#define MAX_PERIOD_SIZE\t\tMAX_BUFFER_SIZE\n#define USE_FORMATS\t\t(SNDRV_PCM_FMTBIT_U8 | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE)\n#define USE_RATE\t\t(SNDRV_PCM_RATE_CONTINUOUS | \\\n\t\t\t\t SNDRV_PCM_RATE_8000_48000)\n#define USE_RATE_MIN\t\t5512\n#define USE_RATE_MAX\t\t48000\n#define USE_CHANNELS_MIN\t1\n#define USE_CHANNELS_MAX\t2\n#define USE_PERIODS_MIN\t\t2\n#define USE_PERIODS_MAX\t\t(MAX_BUFFER_SIZE / MIN_PERIOD_SIZE)\n\nstatic const struct snd_pcm_hardware SND_DRV_PCM_HW_DEFAULT = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_RESUME |\n\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = USE_FORMATS,\n\t.rates = USE_RATE,\n\t.rate_min = USE_RATE_MIN,\n\t.rate_max = USE_RATE_MAX,\n\t.channels_min = USE_CHANNELS_MIN,\n\t.channels_max = USE_CHANNELS_MAX,\n\t.buffer_bytes_max = MAX_BUFFER_SIZE,\n\t.period_bytes_min = MIN_PERIOD_SIZE,\n\t.period_bytes_max = MAX_PERIOD_SIZE,\n\t.periods_min = USE_PERIODS_MIN,\n\t.periods_max = USE_PERIODS_MAX,\n\t.fifo_size = 0,\n};\n\nstatic void cfg_read_pcm_hw(const char *path,\n\t\t\t    struct snd_pcm_hardware *parent_pcm_hw,\n\t\t\t    struct snd_pcm_hardware *pcm_hw)\n{\n\tchar *list;\n\tint val;\n\tsize_t buf_sz;\n\tunsigned int len;\n\n\t \n\tif (parent_pcm_hw)\n\t\t*pcm_hw = *parent_pcm_hw;\n\telse\n\t\t*pcm_hw = SND_DRV_PCM_HW_DEFAULT;\n\n\tval = xenbus_read_unsigned(path, XENSND_FIELD_CHANNELS_MIN, 0);\n\tif (val)\n\t\tpcm_hw->channels_min = val;\n\n\tval = xenbus_read_unsigned(path, XENSND_FIELD_CHANNELS_MAX, 0);\n\tif (val)\n\t\tpcm_hw->channels_max = val;\n\n\tlist = xenbus_read(XBT_NIL, path, XENSND_FIELD_SAMPLE_RATES, &len);\n\tif (!IS_ERR(list)) {\n\t\tcfg_hw_rates(list, len, path, pcm_hw);\n\t\tkfree(list);\n\t}\n\n\tlist = xenbus_read(XBT_NIL, path, XENSND_FIELD_SAMPLE_FORMATS, &len);\n\tif (!IS_ERR(list)) {\n\t\tcfg_formats(list, len, path, pcm_hw);\n\t\tkfree(list);\n\t}\n\n\tbuf_sz = xenbus_read_unsigned(path, XENSND_FIELD_BUFFER_SIZE, 0);\n\tif (buf_sz)\n\t\tpcm_hw->buffer_bytes_max = buf_sz;\n\n\t \n\tif (pcm_hw->channels_min > pcm_hw->channels_max)\n\t\tpcm_hw->channels_min = pcm_hw->channels_max;\n\n\tif (pcm_hw->rate_min > pcm_hw->rate_max)\n\t\tpcm_hw->rate_min = pcm_hw->rate_max;\n\n\tpcm_hw->period_bytes_max = pcm_hw->buffer_bytes_max;\n\n\tpcm_hw->periods_max = pcm_hw->period_bytes_max /\n\t\tpcm_hw->period_bytes_min;\n}\n\nstatic int cfg_get_stream_type(const char *path, int index,\n\t\t\t       int *num_pb, int *num_cap)\n{\n\tchar *str = NULL;\n\tchar *stream_path;\n\tint ret;\n\n\t*num_pb = 0;\n\t*num_cap = 0;\n\tstream_path = kasprintf(GFP_KERNEL, \"%s/%d\", path, index);\n\tif (!stream_path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tstr = xenbus_read(XBT_NIL, stream_path, XENSND_FIELD_TYPE, NULL);\n\tif (IS_ERR(str)) {\n\t\tret = PTR_ERR(str);\n\t\tstr = NULL;\n\t\tgoto fail;\n\t}\n\n\tif (!strncasecmp(str, XENSND_STREAM_TYPE_PLAYBACK,\n\t\t\t sizeof(XENSND_STREAM_TYPE_PLAYBACK))) {\n\t\t(*num_pb)++;\n\t} else if (!strncasecmp(str, XENSND_STREAM_TYPE_CAPTURE,\n\t\t\t      sizeof(XENSND_STREAM_TYPE_CAPTURE))) {\n\t\t(*num_cap)++;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\tret = 0;\n\nfail:\n\tkfree(stream_path);\n\tkfree(str);\n\treturn ret;\n}\n\nstatic int cfg_stream(struct xen_snd_front_info *front_info,\n\t\t      struct xen_front_cfg_pcm_instance *pcm_instance,\n\t\t      const char *path, int index, int *cur_pb, int *cur_cap,\n\t\t      int *stream_cnt)\n{\n\tchar *str = NULL;\n\tchar *stream_path;\n\tstruct xen_front_cfg_stream *stream;\n\tint ret;\n\n\tstream_path = devm_kasprintf(&front_info->xb_dev->dev,\n\t\t\t\t     GFP_KERNEL, \"%s/%d\", path, index);\n\tif (!stream_path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tstr = xenbus_read(XBT_NIL, stream_path, XENSND_FIELD_TYPE, NULL);\n\tif (IS_ERR(str)) {\n\t\tret = PTR_ERR(str);\n\t\tstr = NULL;\n\t\tgoto fail;\n\t}\n\n\tif (!strncasecmp(str, XENSND_STREAM_TYPE_PLAYBACK,\n\t\t\t sizeof(XENSND_STREAM_TYPE_PLAYBACK))) {\n\t\tstream = &pcm_instance->streams_pb[(*cur_pb)++];\n\t} else if (!strncasecmp(str, XENSND_STREAM_TYPE_CAPTURE,\n\t\t\t      sizeof(XENSND_STREAM_TYPE_CAPTURE))) {\n\t\tstream = &pcm_instance->streams_cap[(*cur_cap)++];\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tstream->index = (*stream_cnt)++;\n\tstream->xenstore_path = stream_path;\n\t \n\tcfg_read_pcm_hw(stream->xenstore_path,\n\t\t\t&pcm_instance->pcm_hw, &stream->pcm_hw);\n\tret = 0;\n\nfail:\n\tkfree(str);\n\treturn ret;\n}\n\nstatic int cfg_device(struct xen_snd_front_info *front_info,\n\t\t      struct xen_front_cfg_pcm_instance *pcm_instance,\n\t\t      struct snd_pcm_hardware *parent_pcm_hw,\n\t\t      const char *path, int node_index, int *stream_cnt)\n{\n\tchar *str;\n\tchar *device_path;\n\tint ret, i, num_streams;\n\tint num_pb, num_cap;\n\tint cur_pb, cur_cap;\n\tchar node[3];\n\n\tdevice_path = kasprintf(GFP_KERNEL, \"%s/%d\", path, node_index);\n\tif (!device_path)\n\t\treturn -ENOMEM;\n\n\tstr = xenbus_read(XBT_NIL, device_path, XENSND_FIELD_DEVICE_NAME, NULL);\n\tif (!IS_ERR(str)) {\n\t\tstrscpy(pcm_instance->name, str, sizeof(pcm_instance->name));\n\t\tkfree(str);\n\t}\n\n\tpcm_instance->device_id = node_index;\n\n\t \n\tcfg_read_pcm_hw(device_path, parent_pcm_hw, &pcm_instance->pcm_hw);\n\n\t \n\tnum_streams = 0;\n\tdo {\n\t\tsnprintf(node, sizeof(node), \"%d\", num_streams);\n\t\tif (!xenbus_exists(XBT_NIL, device_path, node))\n\t\t\tbreak;\n\n\t\tnum_streams++;\n\t} while (num_streams < VSND_MAX_STREAM);\n\n\tpcm_instance->num_streams_pb = 0;\n\tpcm_instance->num_streams_cap = 0;\n\t \n\tfor (i = 0; i < num_streams; i++) {\n\t\tret = cfg_get_stream_type(device_path, i, &num_pb, &num_cap);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\n\t\tpcm_instance->num_streams_pb += num_pb;\n\t\tpcm_instance->num_streams_cap += num_cap;\n\t}\n\n\tif (pcm_instance->num_streams_pb) {\n\t\tpcm_instance->streams_pb =\n\t\t\t\tdevm_kcalloc(&front_info->xb_dev->dev,\n\t\t\t\t\t     pcm_instance->num_streams_pb,\n\t\t\t\t\t     sizeof(struct xen_front_cfg_stream),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcm_instance->streams_pb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (pcm_instance->num_streams_cap) {\n\t\tpcm_instance->streams_cap =\n\t\t\t\tdevm_kcalloc(&front_info->xb_dev->dev,\n\t\t\t\t\t     pcm_instance->num_streams_cap,\n\t\t\t\t\t     sizeof(struct xen_front_cfg_stream),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!pcm_instance->streams_cap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tcur_pb = 0;\n\tcur_cap = 0;\n\tfor (i = 0; i < num_streams; i++) {\n\t\tret = cfg_stream(front_info, pcm_instance, device_path, i,\n\t\t\t\t &cur_pb, &cur_cap, stream_cnt);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\tret = 0;\n\nfail:\n\tkfree(device_path);\n\treturn ret;\n}\n\nint xen_snd_front_cfg_card(struct xen_snd_front_info *front_info,\n\t\t\t   int *stream_cnt)\n{\n\tstruct xenbus_device *xb_dev = front_info->xb_dev;\n\tstruct xen_front_cfg_card *cfg = &front_info->cfg;\n\tint ret, num_devices, i;\n\tchar node[3];\n\n\t*stream_cnt = 0;\n\tnum_devices = 0;\n\tdo {\n\t\tscnprintf(node, sizeof(node), \"%d\", num_devices);\n\t\tif (!xenbus_exists(XBT_NIL, xb_dev->nodename, node))\n\t\t\tbreak;\n\n\t\tnum_devices++;\n\t} while (num_devices < SNDRV_PCM_DEVICES);\n\n\tif (!num_devices) {\n\t\tdev_warn(&xb_dev->dev,\n\t\t\t \"No devices configured for sound card at %s\\n\",\n\t\t\t xb_dev->nodename);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcfg_read_pcm_hw(xb_dev->nodename, NULL, &cfg->pcm_hw);\n\n\tcfg->pcm_instances =\n\t\t\tdevm_kcalloc(&front_info->xb_dev->dev, num_devices,\n\t\t\t\t     sizeof(struct xen_front_cfg_pcm_instance),\n\t\t\t\t     GFP_KERNEL);\n\tif (!cfg->pcm_instances)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_devices; i++) {\n\t\tret = cfg_device(front_info, &cfg->pcm_instances[i],\n\t\t\t\t &cfg->pcm_hw, xb_dev->nodename, i, stream_cnt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tcfg->num_pcm_instances = num_devices;\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}