{
  "module_name": "xen_snd_front_evtchnl.c",
  "hash_id": "e3c635429585c810daf9331a338a5176a03bda858220cb33b397fe45e66d288e",
  "original_prompt": "Ingested from linux-6.6.14/sound/xen/xen_snd_front_evtchnl.c",
  "human_readable_source": "\n\n \n\n#include <xen/events.h>\n#include <xen/grant_table.h>\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n\n#include \"xen_snd_front.h\"\n#include \"xen_snd_front_alsa.h\"\n#include \"xen_snd_front_cfg.h\"\n#include \"xen_snd_front_evtchnl.h\"\n\nstatic irqreturn_t evtchnl_interrupt_req(int irq, void *dev_id)\n{\n\tstruct xen_snd_front_evtchnl *channel = dev_id;\n\tstruct xen_snd_front_info *front_info = channel->front_info;\n\tstruct xensnd_resp *resp;\n\tRING_IDX i, rp;\n\n\tif (unlikely(channel->state != EVTCHNL_STATE_CONNECTED))\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&channel->ring_io_lock);\n\nagain:\n\trp = channel->u.req.ring.sring->rsp_prod;\n\t \n\trmb();\n\n\t \n\tfor (i = channel->u.req.ring.rsp_cons; i != rp; i++) {\n\t\tresp = RING_GET_RESPONSE(&channel->u.req.ring, i);\n\t\tif (resp->id != channel->evt_id)\n\t\t\tcontinue;\n\t\tswitch (resp->operation) {\n\t\tcase XENSND_OP_OPEN:\n\t\tcase XENSND_OP_CLOSE:\n\t\tcase XENSND_OP_READ:\n\t\tcase XENSND_OP_WRITE:\n\t\tcase XENSND_OP_TRIGGER:\n\t\t\tchannel->u.req.resp_status = resp->status;\n\t\t\tcomplete(&channel->u.req.completion);\n\t\t\tbreak;\n\t\tcase XENSND_OP_HW_PARAM_QUERY:\n\t\t\tchannel->u.req.resp_status = resp->status;\n\t\t\tchannel->u.req.resp.hw_param =\n\t\t\t\t\tresp->resp.hw_param;\n\t\t\tcomplete(&channel->u.req.completion);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&front_info->xb_dev->dev,\n\t\t\t\t\"Operation %d is not supported\\n\",\n\t\t\t\tresp->operation);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchannel->u.req.ring.rsp_cons = i;\n\tif (i != channel->u.req.ring.req_prod_pvt) {\n\t\tint more_to_do;\n\n\t\tRING_FINAL_CHECK_FOR_RESPONSES(&channel->u.req.ring,\n\t\t\t\t\t       more_to_do);\n\t\tif (more_to_do)\n\t\t\tgoto again;\n\t} else {\n\t\tchannel->u.req.ring.sring->rsp_event = i + 1;\n\t}\n\n\tmutex_unlock(&channel->ring_io_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t evtchnl_interrupt_evt(int irq, void *dev_id)\n{\n\tstruct xen_snd_front_evtchnl *channel = dev_id;\n\tstruct xensnd_event_page *page = channel->u.evt.page;\n\tu32 cons, prod;\n\n\tif (unlikely(channel->state != EVTCHNL_STATE_CONNECTED))\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&channel->ring_io_lock);\n\n\tprod = page->in_prod;\n\t \n\tvirt_rmb();\n\tif (prod == page->in_cons)\n\t\tgoto out;\n\n\t \n\tfor (cons = page->in_cons; cons != prod; cons++) {\n\t\tstruct xensnd_evt *event;\n\n\t\tevent = &XENSND_IN_RING_REF(page, cons);\n\t\tif (unlikely(event->id != channel->evt_id++))\n\t\t\tcontinue;\n\n\t\tswitch (event->type) {\n\t\tcase XENSND_EVT_CUR_POS:\n\t\t\txen_snd_front_alsa_handle_cur_pos(channel,\n\t\t\t\t\t\t\t  event->op.cur_pos.position);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpage->in_cons = cons;\n\t \n\tvirt_wmb();\n\nout:\n\tmutex_unlock(&channel->ring_io_lock);\n\treturn IRQ_HANDLED;\n}\n\nvoid xen_snd_front_evtchnl_flush(struct xen_snd_front_evtchnl *channel)\n{\n\tint notify;\n\n\tchannel->u.req.ring.req_prod_pvt++;\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&channel->u.req.ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(channel->irq);\n}\n\nstatic void evtchnl_free(struct xen_snd_front_info *front_info,\n\t\t\t struct xen_snd_front_evtchnl *channel)\n{\n\tvoid *page = NULL;\n\n\tif (channel->type == EVTCHNL_TYPE_REQ)\n\t\tpage = channel->u.req.ring.sring;\n\telse if (channel->type == EVTCHNL_TYPE_EVT)\n\t\tpage = channel->u.evt.page;\n\n\tif (!page)\n\t\treturn;\n\n\tchannel->state = EVTCHNL_STATE_DISCONNECTED;\n\tif (channel->type == EVTCHNL_TYPE_REQ) {\n\t\t \n\t\tchannel->u.req.resp_status = -EIO;\n\t\tcomplete_all(&channel->u.req.completion);\n\t}\n\n\tif (channel->irq)\n\t\tunbind_from_irqhandler(channel->irq, channel);\n\n\tif (channel->port)\n\t\txenbus_free_evtchn(front_info->xb_dev, channel->port);\n\n\t \n\txenbus_teardown_ring(&page, 1, &channel->gref);\n\n\tmemset(channel, 0, sizeof(*channel));\n}\n\nvoid xen_snd_front_evtchnl_free_all(struct xen_snd_front_info *front_info)\n{\n\tint i;\n\n\tif (!front_info->evt_pairs)\n\t\treturn;\n\n\tfor (i = 0; i < front_info->num_evt_pairs; i++) {\n\t\tevtchnl_free(front_info, &front_info->evt_pairs[i].req);\n\t\tevtchnl_free(front_info, &front_info->evt_pairs[i].evt);\n\t}\n\n\tkfree(front_info->evt_pairs);\n\tfront_info->evt_pairs = NULL;\n}\n\nstatic int evtchnl_alloc(struct xen_snd_front_info *front_info, int index,\n\t\t\t struct xen_snd_front_evtchnl *channel,\n\t\t\t enum xen_snd_front_evtchnl_type type)\n{\n\tstruct xenbus_device *xb_dev = front_info->xb_dev;\n\tvoid *page;\n\tirq_handler_t handler;\n\tchar *handler_name = NULL;\n\tint ret;\n\n\tmemset(channel, 0, sizeof(*channel));\n\tchannel->type = type;\n\tchannel->index = index;\n\tchannel->front_info = front_info;\n\tchannel->state = EVTCHNL_STATE_DISCONNECTED;\n\tret = xenbus_setup_ring(xb_dev, GFP_KERNEL, &page, 1, &channel->gref);\n\tif (ret)\n\t\tgoto fail;\n\n\thandler_name = kasprintf(GFP_KERNEL, \"%s-%s\", XENSND_DRIVER_NAME,\n\t\t\t\t type == EVTCHNL_TYPE_REQ ?\n\t\t\t\t XENSND_FIELD_RING_REF :\n\t\t\t\t XENSND_FIELD_EVT_RING_REF);\n\tif (!handler_name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmutex_init(&channel->ring_io_lock);\n\n\tif (type == EVTCHNL_TYPE_REQ) {\n\t\tstruct xen_sndif_sring *sring = page;\n\n\t\tinit_completion(&channel->u.req.completion);\n\t\tmutex_init(&channel->u.req.req_io_lock);\n\t\tXEN_FRONT_RING_INIT(&channel->u.req.ring, sring, XEN_PAGE_SIZE);\n\n\t\thandler = evtchnl_interrupt_req;\n\t} else {\n\t\tchannel->u.evt.page = page;\n\t\thandler = evtchnl_interrupt_evt;\n\t}\n\n\tret = xenbus_alloc_evtchn(xb_dev, &channel->port);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = bind_evtchn_to_irq(channel->port);\n\tif (ret < 0) {\n\t\tdev_err(&xb_dev->dev,\n\t\t\t\"Failed to bind IRQ for domid %d port %d: %d\\n\",\n\t\t\tfront_info->xb_dev->otherend_id, channel->port, ret);\n\t\tgoto fail;\n\t}\n\n\tchannel->irq = ret;\n\n\tret = request_threaded_irq(channel->irq, NULL, handler,\n\t\t\t\t   IRQF_ONESHOT, handler_name, channel);\n\tif (ret < 0) {\n\t\tdev_err(&xb_dev->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\tchannel->irq, ret);\n\t\tgoto fail;\n\t}\n\n\tkfree(handler_name);\n\treturn 0;\n\nfail:\n\tkfree(handler_name);\n\tdev_err(&xb_dev->dev, \"Failed to allocate ring: %d\\n\", ret);\n\treturn ret;\n}\n\nint xen_snd_front_evtchnl_create_all(struct xen_snd_front_info *front_info,\n\t\t\t\t     int num_streams)\n{\n\tstruct xen_front_cfg_card *cfg = &front_info->cfg;\n\tstruct device *dev = &front_info->xb_dev->dev;\n\tint d, ret = 0;\n\n\tfront_info->evt_pairs =\n\t\t\tkcalloc(num_streams,\n\t\t\t\tsizeof(struct xen_snd_front_evtchnl_pair),\n\t\t\t\tGFP_KERNEL);\n\tif (!front_info->evt_pairs)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (d = 0; d < cfg->num_pcm_instances; d++) {\n\t\tstruct xen_front_cfg_pcm_instance *pcm_instance;\n\t\tint s, index;\n\n\t\tpcm_instance = &cfg->pcm_instances[d];\n\n\t\tfor (s = 0; s < pcm_instance->num_streams_pb; s++) {\n\t\t\tindex = pcm_instance->streams_pb[s].index;\n\n\t\t\tret = evtchnl_alloc(front_info, index,\n\t\t\t\t\t    &front_info->evt_pairs[index].req,\n\t\t\t\t\t    EVTCHNL_TYPE_REQ);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error allocating control channel\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tret = evtchnl_alloc(front_info, index,\n\t\t\t\t\t    &front_info->evt_pairs[index].evt,\n\t\t\t\t\t    EVTCHNL_TYPE_EVT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error allocating in-event channel\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tfor (s = 0; s < pcm_instance->num_streams_cap; s++) {\n\t\t\tindex = pcm_instance->streams_cap[s].index;\n\n\t\t\tret = evtchnl_alloc(front_info, index,\n\t\t\t\t\t    &front_info->evt_pairs[index].req,\n\t\t\t\t\t    EVTCHNL_TYPE_REQ);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error allocating control channel\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tret = evtchnl_alloc(front_info, index,\n\t\t\t\t\t    &front_info->evt_pairs[index].evt,\n\t\t\t\t\t    EVTCHNL_TYPE_EVT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Error allocating in-event channel\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfront_info->num_evt_pairs = num_streams;\n\treturn 0;\n\nfail:\n\txen_snd_front_evtchnl_free_all(front_info);\n\treturn ret;\n}\n\nstatic int evtchnl_publish(struct xenbus_transaction xbt,\n\t\t\t   struct xen_snd_front_evtchnl *channel,\n\t\t\t   const char *path, const char *node_ring,\n\t\t\t   const char *node_chnl)\n{\n\tstruct xenbus_device *xb_dev = channel->front_info->xb_dev;\n\tint ret;\n\n\t \n\tret = xenbus_printf(xbt, path, node_ring, \"%u\", channel->gref);\n\tif (ret < 0) {\n\t\tdev_err(&xb_dev->dev, \"Error writing ring-ref: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = xenbus_printf(xbt, path, node_chnl, \"%u\", channel->port);\n\tif (ret < 0) {\n\t\tdev_err(&xb_dev->dev, \"Error writing event channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint xen_snd_front_evtchnl_publish_all(struct xen_snd_front_info *front_info)\n{\n\tstruct xen_front_cfg_card *cfg = &front_info->cfg;\n\tstruct xenbus_transaction xbt;\n\tint ret, d;\n\nagain:\n\tret = xenbus_transaction_start(&xbt);\n\tif (ret < 0) {\n\t\txenbus_dev_fatal(front_info->xb_dev, ret,\n\t\t\t\t \"starting transaction\");\n\t\treturn ret;\n\t}\n\n\tfor (d = 0; d < cfg->num_pcm_instances; d++) {\n\t\tstruct xen_front_cfg_pcm_instance *pcm_instance;\n\t\tint s, index;\n\n\t\tpcm_instance = &cfg->pcm_instances[d];\n\n\t\tfor (s = 0; s < pcm_instance->num_streams_pb; s++) {\n\t\t\tindex = pcm_instance->streams_pb[s].index;\n\n\t\t\tret = evtchnl_publish(xbt,\n\t\t\t\t\t      &front_info->evt_pairs[index].req,\n\t\t\t\t\t      pcm_instance->streams_pb[s].xenstore_path,\n\t\t\t\t\t      XENSND_FIELD_RING_REF,\n\t\t\t\t\t      XENSND_FIELD_EVT_CHNL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tret = evtchnl_publish(xbt,\n\t\t\t\t\t      &front_info->evt_pairs[index].evt,\n\t\t\t\t\t      pcm_instance->streams_pb[s].xenstore_path,\n\t\t\t\t\t      XENSND_FIELD_EVT_RING_REF,\n\t\t\t\t\t      XENSND_FIELD_EVT_EVT_CHNL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (s = 0; s < pcm_instance->num_streams_cap; s++) {\n\t\t\tindex = pcm_instance->streams_cap[s].index;\n\n\t\t\tret = evtchnl_publish(xbt,\n\t\t\t\t\t      &front_info->evt_pairs[index].req,\n\t\t\t\t\t      pcm_instance->streams_cap[s].xenstore_path,\n\t\t\t\t\t      XENSND_FIELD_RING_REF,\n\t\t\t\t\t      XENSND_FIELD_EVT_CHNL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tret = evtchnl_publish(xbt,\n\t\t\t\t\t      &front_info->evt_pairs[index].evt,\n\t\t\t\t\t      pcm_instance->streams_cap[s].xenstore_path,\n\t\t\t\t\t      XENSND_FIELD_EVT_RING_REF,\n\t\t\t\t\t      XENSND_FIELD_EVT_EVT_CHNL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = xenbus_transaction_end(xbt, 0);\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\txenbus_dev_fatal(front_info->xb_dev, ret,\n\t\t\t\t \"completing transaction\");\n\t\tgoto fail_to_end;\n\t}\n\treturn 0;\nfail:\n\txenbus_transaction_end(xbt, 1);\nfail_to_end:\n\txenbus_dev_fatal(front_info->xb_dev, ret, \"writing XenStore\");\n\treturn ret;\n}\n\nvoid xen_snd_front_evtchnl_pair_set_connected(struct xen_snd_front_evtchnl_pair *evt_pair,\n\t\t\t\t\t      bool is_connected)\n{\n\tenum xen_snd_front_evtchnl_state state;\n\n\tif (is_connected)\n\t\tstate = EVTCHNL_STATE_CONNECTED;\n\telse\n\t\tstate = EVTCHNL_STATE_DISCONNECTED;\n\n\tmutex_lock(&evt_pair->req.ring_io_lock);\n\tevt_pair->req.state = state;\n\tmutex_unlock(&evt_pair->req.ring_io_lock);\n\n\tmutex_lock(&evt_pair->evt.ring_io_lock);\n\tevt_pair->evt.state = state;\n\tmutex_unlock(&evt_pair->evt.ring_io_lock);\n}\n\nvoid xen_snd_front_evtchnl_pair_clear(struct xen_snd_front_evtchnl_pair *evt_pair)\n{\n\tmutex_lock(&evt_pair->req.ring_io_lock);\n\tevt_pair->req.evt_next_id = 0;\n\tmutex_unlock(&evt_pair->req.ring_io_lock);\n\n\tmutex_lock(&evt_pair->evt.ring_io_lock);\n\tevt_pair->evt.evt_next_id = 0;\n\tmutex_unlock(&evt_pair->evt.ring_io_lock);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}