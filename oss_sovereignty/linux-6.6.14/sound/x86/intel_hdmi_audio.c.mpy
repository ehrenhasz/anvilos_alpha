{
  "module_name": "intel_hdmi_audio.c",
  "hash_id": "46deefb7e58706ac3e91e83ba7793bbddd73a8672910102733ec50d603961a35",
  "original_prompt": "Ingested from linux-6.6.14/sound/x86/intel_hdmi_audio.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/asoundef.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/control.h>\n#include <sound/jack.h>\n#include <drm/drm_edid.h>\n#include <drm/intel_lpe_audio.h>\n#include \"intel_hdmi_audio.h\"\n\n#define INTEL_HDMI_AUDIO_SUSPEND_DELAY_MS  5000\n\n#define for_each_pipe(card_ctx, pipe) \\\n\tfor ((pipe) = 0; (pipe) < (card_ctx)->num_pipes; (pipe)++)\n#define for_each_port(card_ctx, port) \\\n\tfor ((port) = 0; (port) < (card_ctx)->num_ports; (port)++)\n\n \nstatic int hdmi_card_index = SNDRV_DEFAULT_IDX1;\nstatic char *hdmi_card_id = SNDRV_DEFAULT_STR1;\nstatic bool single_port;\n\nmodule_param_named(index, hdmi_card_index, int, 0444);\nMODULE_PARM_DESC(index,\n\t\t\"Index value for INTEL Intel HDMI Audio controller.\");\nmodule_param_named(id, hdmi_card_id, charp, 0444);\nMODULE_PARM_DESC(id,\n\t\t\"ID string for INTEL Intel HDMI Audio controller.\");\nmodule_param(single_port, bool, 0444);\nMODULE_PARM_DESC(single_port,\n\t\t\"Single-port mode (for compatibility)\");\n\n \nstatic const int eld_speaker_allocation_bits[] = {\n\t[0] = FL | FR,\n\t[1] = LFE,\n\t[2] = FC,\n\t[3] = RL | RR,\n\t[4] = RC,\n\t[5] = FLC | FRC,\n\t[6] = RLC | RRC,\n\t \n\t[7] = 0,\n};\n\n \nstatic struct cea_channel_speaker_allocation channel_allocations[] = {\n \n{ .ca_index = 0x00,  .speakers = {   0,    0,   0,   0,   0,    0,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x01,  .speakers = {   0,    0,   0,   0,   0,  LFE,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x02,  .speakers = {   0,    0,   0,   0,  FC,    0,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x08,  .speakers = {   0,    0,  RR,  RL,   0,    0,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x09,  .speakers = {   0,    0,  RR,  RL,   0,  LFE,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x0a,  .speakers = {   0,    0,  RR,  RL,  FC,    0,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x0b,  .speakers = {   0,    0,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x0f,  .speakers = {   0,   RC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\t\t\t\t \n{ .ca_index = 0x13,  .speakers = { RRC,  RLC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n\n{ .ca_index = 0x03,  .speakers = {   0,    0,   0,   0,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x04,  .speakers = {   0,    0,   0,  RC,   0,    0,  FR,  FL } },\n{ .ca_index = 0x05,  .speakers = {   0,    0,   0,  RC,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x06,  .speakers = {   0,    0,   0,  RC,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x07,  .speakers = {   0,    0,   0,  RC,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x0c,  .speakers = {   0,   RC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x0d,  .speakers = {   0,   RC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x0e,  .speakers = {   0,   RC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x10,  .speakers = { RRC,  RLC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x11,  .speakers = { RRC,  RLC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x12,  .speakers = { RRC,  RLC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x14,  .speakers = { FRC,  FLC,   0,   0,   0,    0,  FR,  FL } },\n{ .ca_index = 0x15,  .speakers = { FRC,  FLC,   0,   0,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x16,  .speakers = { FRC,  FLC,   0,   0,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x17,  .speakers = { FRC,  FLC,   0,   0,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x18,  .speakers = { FRC,  FLC,   0,  RC,   0,    0,  FR,  FL } },\n{ .ca_index = 0x19,  .speakers = { FRC,  FLC,   0,  RC,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x1a,  .speakers = { FRC,  FLC,   0,  RC,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x1b,  .speakers = { FRC,  FLC,   0,  RC,  FC,  LFE,  FR,  FL } },\n{ .ca_index = 0x1c,  .speakers = { FRC,  FLC,  RR,  RL,   0,    0,  FR,  FL } },\n{ .ca_index = 0x1d,  .speakers = { FRC,  FLC,  RR,  RL,   0,  LFE,  FR,  FL } },\n{ .ca_index = 0x1e,  .speakers = { FRC,  FLC,  RR,  RL,  FC,    0,  FR,  FL } },\n{ .ca_index = 0x1f,  .speakers = { FRC,  FLC,  RR,  RL,  FC,  LFE,  FR,  FL } },\n};\n\nstatic const struct channel_map_table map_tables[] = {\n\t{ SNDRV_CHMAP_FL,       0x00,   FL },\n\t{ SNDRV_CHMAP_FR,       0x01,   FR },\n\t{ SNDRV_CHMAP_RL,       0x04,   RL },\n\t{ SNDRV_CHMAP_RR,       0x05,   RR },\n\t{ SNDRV_CHMAP_LFE,      0x02,   LFE },\n\t{ SNDRV_CHMAP_FC,       0x03,   FC },\n\t{ SNDRV_CHMAP_RLC,      0x06,   RLC },\n\t{ SNDRV_CHMAP_RRC,      0x07,   RRC },\n\t{}  \n};\n\n \nstatic const struct snd_pcm_hardware had_pcm_hardware = {\n\t.info =\t(SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP),\n\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t    SNDRV_PCM_FMTBIT_S32_LE),\n\t.rates = SNDRV_PCM_RATE_32000 |\n\t\tSNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000 |\n\t\tSNDRV_PCM_RATE_88200 |\n\t\tSNDRV_PCM_RATE_96000 |\n\t\tSNDRV_PCM_RATE_176400 |\n\t\tSNDRV_PCM_RATE_192000,\n\t.rate_min = HAD_MIN_RATE,\n\t.rate_max = HAD_MAX_RATE,\n\t.channels_min = HAD_MIN_CHANNEL,\n\t.channels_max = HAD_MAX_CHANNEL,\n\t.buffer_bytes_max = HAD_MAX_BUFFER,\n\t.period_bytes_min = HAD_MIN_PERIOD_BYTES,\n\t.period_bytes_max = HAD_MAX_PERIOD_BYTES,\n\t.periods_min = HAD_MIN_PERIODS,\n\t.periods_max = HAD_MAX_PERIODS,\n\t.fifo_size = HAD_FIFO_SIZE,\n};\n\n \nstatic struct snd_pcm_substream *\nhad_substream_get(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\n\tsubstream = intelhaddata->stream_info.substream;\n\tif (substream)\n\t\tintelhaddata->stream_info.substream_refcount++;\n\tspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\n\treturn substream;\n}\n\n \nstatic void had_substream_put(struct snd_intelhad *intelhaddata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\n\tintelhaddata->stream_info.substream_refcount--;\n\tspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\n}\n\nstatic u32 had_config_offset(int pipe)\n{\n\tswitch (pipe) {\n\tdefault:\n\tcase 0:\n\t\treturn AUDIO_HDMI_CONFIG_A;\n\tcase 1:\n\t\treturn AUDIO_HDMI_CONFIG_B;\n\tcase 2:\n\t\treturn AUDIO_HDMI_CONFIG_C;\n\t}\n}\n\n \nstatic u32 had_read_register_raw(struct snd_intelhad_card *card_ctx,\n\t\t\t\t int pipe, u32 reg)\n{\n\treturn ioread32(card_ctx->mmio_start + had_config_offset(pipe) + reg);\n}\n\nstatic void had_write_register_raw(struct snd_intelhad_card *card_ctx,\n\t\t\t\t   int pipe, u32 reg, u32 val)\n{\n\tiowrite32(val, card_ctx->mmio_start + had_config_offset(pipe) + reg);\n}\n\nstatic void had_read_register(struct snd_intelhad *ctx, u32 reg, u32 *val)\n{\n\tif (!ctx->connected)\n\t\t*val = 0;\n\telse\n\t\t*val = had_read_register_raw(ctx->card_ctx, ctx->pipe, reg);\n}\n\nstatic void had_write_register(struct snd_intelhad *ctx, u32 reg, u32 val)\n{\n\tif (ctx->connected)\n\t\thad_write_register_raw(ctx->card_ctx, ctx->pipe, reg, val);\n}\n\n \nstatic void had_enable_audio(struct snd_intelhad *intelhaddata,\n\t\t\t     bool enable)\n{\n\t \n\tintelhaddata->aud_config.regx.aud_en = enable;\n\thad_write_register(intelhaddata, AUD_CONFIG,\n\t\t\t   intelhaddata->aud_config.regval);\n}\n\n \nstatic void had_ack_irqs(struct snd_intelhad *ctx)\n{\n\tu32 status_reg;\n\n\tif (!ctx->connected)\n\t\treturn;\n\thad_read_register(ctx, AUD_HDMI_STATUS, &status_reg);\n\tstatus_reg |= HDMI_AUDIO_BUFFER_DONE | HDMI_AUDIO_UNDERRUN;\n\thad_write_register(ctx, AUD_HDMI_STATUS, status_reg);\n\thad_read_register(ctx, AUD_HDMI_STATUS, &status_reg);\n}\n\n \nstatic void had_reset_audio(struct snd_intelhad *intelhaddata)\n{\n\thad_write_register(intelhaddata, AUD_HDMI_STATUS,\n\t\t\t   AUD_HDMI_STATUSG_MASK_FUNCRST);\n\thad_write_register(intelhaddata, AUD_HDMI_STATUS, 0);\n}\n\n \nstatic int had_prog_status_reg(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_intelhad *intelhaddata)\n{\n\tunion aud_ch_status_0 ch_stat0 = {.regval = 0};\n\tunion aud_ch_status_1 ch_stat1 = {.regval = 0};\n\n\tch_stat0.regx.lpcm_id = (intelhaddata->aes_bits &\n\t\t\t\t\t  IEC958_AES0_NONAUDIO) >> 1;\n\tch_stat0.regx.clk_acc = (intelhaddata->aes_bits &\n\t\t\t\t\t  IEC958_AES3_CON_CLOCK) >> 4;\n\n\tswitch (substream->runtime->rate) {\n\tcase AUD_SAMPLE_RATE_32:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_32KHZ;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_44_1:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_44KHZ;\n\t\tbreak;\n\tcase AUD_SAMPLE_RATE_48:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_48KHZ;\n\t\tbreak;\n\tcase AUD_SAMPLE_RATE_88_2:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_88KHZ;\n\t\tbreak;\n\tcase AUD_SAMPLE_RATE_96:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_96KHZ;\n\t\tbreak;\n\tcase AUD_SAMPLE_RATE_176_4:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_176KHZ;\n\t\tbreak;\n\tcase AUD_SAMPLE_RATE_192:\n\t\tch_stat0.regx.samp_freq = CH_STATUS_MAP_192KHZ;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\thad_write_register(intelhaddata,\n\t\t\t   AUD_CH_STATUS_0, ch_stat0.regval);\n\n\tswitch (substream->runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_20;\n\t\tch_stat1.regx.wrd_len = SMPL_WIDTH_16BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tch_stat1.regx.max_wrd_len = MAX_SMPL_WIDTH_24;\n\t\tch_stat1.regx.wrd_len = SMPL_WIDTH_24BITS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thad_write_register(intelhaddata,\n\t\t\t   AUD_CH_STATUS_1, ch_stat1.regval);\n\treturn 0;\n}\n\n \nstatic int had_init_audio_ctrl(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_intelhad *intelhaddata)\n{\n\tunion aud_cfg cfg_val = {.regval = 0};\n\tunion aud_buf_config buf_cfg = {.regval = 0};\n\tu8 channels;\n\n\thad_prog_status_reg(substream, intelhaddata);\n\n\tbuf_cfg.regx.audio_fifo_watermark = FIFO_THRESHOLD;\n\tbuf_cfg.regx.dma_fifo_watermark = DMA_FIFO_THRESHOLD;\n\tbuf_cfg.regx.aud_delay = 0;\n\thad_write_register(intelhaddata, AUD_BUF_CONFIG, buf_cfg.regval);\n\n\tchannels = substream->runtime->channels;\n\tcfg_val.regx.num_ch = channels - 2;\n\tif (channels <= 2)\n\t\tcfg_val.regx.layout = LAYOUT0;\n\telse\n\t\tcfg_val.regx.layout = LAYOUT1;\n\n\tif (substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE)\n\t\tcfg_val.regx.packet_mode = 1;\n\n\tif (substream->runtime->format == SNDRV_PCM_FORMAT_S32_LE)\n\t\tcfg_val.regx.left_align = 1;\n\n\tcfg_val.regx.val_bit = 1;\n\n\t \n\tif (intelhaddata->dp_output) {\n\t\tcfg_val.regx.dp_modei = 1;\n\t\tcfg_val.regx.set = 1;\n\t}\n\n\thad_write_register(intelhaddata, AUD_CONFIG, cfg_val.regval);\n\tintelhaddata->aud_config = cfg_val;\n\treturn 0;\n}\n\n \nstatic void init_channel_allocations(void)\n{\n\tint i, j;\n\tstruct cea_channel_speaker_allocation *p;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tp = channel_allocations + i;\n\t\tp->channels = 0;\n\t\tp->spk_mask = 0;\n\t\tfor (j = 0; j < ARRAY_SIZE(p->speakers); j++)\n\t\t\tif (p->speakers[j]) {\n\t\t\t\tp->channels++;\n\t\t\t\tp->spk_mask |= p->speakers[j];\n\t\t\t}\n\t}\n}\n\n \nstatic int had_channel_allocation(struct snd_intelhad *intelhaddata,\n\t\t\t\t  int channels)\n{\n\tint i;\n\tint ca = 0;\n\tint spk_mask = 0;\n\n\t \n\tif (channels <= 2)\n\t\treturn 0;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\n\t\tif (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))\n\t\t\tspk_mask |= eld_speaker_allocation_bits[i];\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tif (channels == channel_allocations[i].channels &&\n\t\t(spk_mask & channel_allocations[i].spk_mask) ==\n\t\t\t\tchannel_allocations[i].spk_mask) {\n\t\t\tca = channel_allocations[i].ca_index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(intelhaddata->dev, \"select CA 0x%x for %d\\n\", ca, channels);\n\n\treturn ca;\n}\n\n \nstatic int spk_to_chmap(int spk)\n{\n\tconst struct channel_map_table *t = map_tables;\n\n\tfor (; t->map; t++) {\n\t\tif (t->spk_mask == spk)\n\t\t\treturn t->map;\n\t}\n\treturn 0;\n}\n\nstatic void had_build_channel_allocation_map(struct snd_intelhad *intelhaddata)\n{\n\tint i, c;\n\tint spk_mask = 0;\n\tstruct snd_pcm_chmap_elem *chmap;\n\tu8 eld_high, eld_high_mask = 0xF0;\n\tu8 high_msb;\n\n\tkfree(intelhaddata->chmap->chmap);\n\tintelhaddata->chmap->chmap = NULL;\n\n\tchmap = kzalloc(sizeof(*chmap), GFP_KERNEL);\n\tif (!chmap)\n\t\treturn;\n\n\tdev_dbg(intelhaddata->dev, \"eld speaker = %x\\n\",\n\t\tintelhaddata->eld[DRM_ELD_SPEAKER]);\n\n\t \n\n\t \n\n\t \n\teld_high = intelhaddata->eld[DRM_ELD_SPEAKER] & eld_high_mask;\n\tif ((eld_high & (eld_high-1)) && (eld_high > 0x1F)) {\n\t\t \n\t\t \n\t\tfor (i = 1; i < 4; i++) {\n\t\t\thigh_msb = eld_high & (0x80 >> i);\n\t\t\tif (high_msb) {\n\t\t\t\tintelhaddata->eld[DRM_ELD_SPEAKER] &=\n\t\t\t\t\thigh_msb | 0xF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\n\t\tif (intelhaddata->eld[DRM_ELD_SPEAKER] & (1 << i))\n\t\t\tspk_mask |= eld_speaker_allocation_bits[i];\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\n\t\tif (spk_mask == channel_allocations[i].spk_mask) {\n\t\t\tfor (c = 0; c < channel_allocations[i].channels; c++) {\n\t\t\t\tchmap->map[c] = spk_to_chmap(\n\t\t\t\t\tchannel_allocations[i].speakers[\n\t\t\t\t\t\t(MAX_SPEAKERS - 1) - c]);\n\t\t\t}\n\t\t\tchmap->channels = channel_allocations[i].channels;\n\t\t\tintelhaddata->chmap->chmap = chmap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= ARRAY_SIZE(channel_allocations))\n\t\tkfree(chmap);\n}\n\n \nstatic int had_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = HAD_MAX_CHANNEL;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\nstatic int had_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct snd_intelhad *intelhaddata = info->private_data;\n\tint i;\n\tconst struct snd_pcm_chmap_elem *chmap;\n\n\tmemset(ucontrol->value.integer.value, 0,\n\t       sizeof(long) * HAD_MAX_CHANNEL);\n\tmutex_lock(&intelhaddata->mutex);\n\tif (!intelhaddata->chmap->chmap) {\n\t\tmutex_unlock(&intelhaddata->mutex);\n\t\treturn 0;\n\t}\n\n\tchmap = intelhaddata->chmap->chmap;\n\tfor (i = 0; i < chmap->channels; i++)\n\t\tucontrol->value.integer.value[i] = chmap->map[i];\n\tmutex_unlock(&intelhaddata->mutex);\n\n\treturn 0;\n}\n\nstatic int had_register_chmap_ctls(struct snd_intelhad *intelhaddata,\n\t\t\t\t\t\tstruct snd_pcm *pcm)\n{\n\tint err;\n\n\terr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\tNULL, 0, (unsigned long)intelhaddata,\n\t\t\t&intelhaddata->chmap);\n\tif (err < 0)\n\t\treturn err;\n\n\tintelhaddata->chmap->private_data = intelhaddata;\n\tintelhaddata->chmap->kctl->info = had_chmap_ctl_info;\n\tintelhaddata->chmap->kctl->get = had_chmap_ctl_get;\n\tintelhaddata->chmap->chmap = NULL;\n\treturn 0;\n}\n\n \nstatic void had_prog_dip(struct snd_pcm_substream *substream,\n\t\t\t struct snd_intelhad *intelhaddata)\n{\n\tint i;\n\tunion aud_ctrl_st ctrl_state = {.regval = 0};\n\tunion aud_info_frame2 frame2 = {.regval = 0};\n\tunion aud_info_frame3 frame3 = {.regval = 0};\n\tu8 checksum = 0;\n\tu32 info_frame;\n\tint channels;\n\tint ca;\n\n\tchannels = substream->runtime->channels;\n\n\thad_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);\n\n\tca = had_channel_allocation(intelhaddata, channels);\n\tif (intelhaddata->dp_output) {\n\t\tinfo_frame = DP_INFO_FRAME_WORD1;\n\t\tframe2.regval = (substream->runtime->channels - 1) | (ca << 24);\n\t} else {\n\t\tinfo_frame = HDMI_INFO_FRAME_WORD1;\n\t\tframe2.regx.chnl_cnt = substream->runtime->channels - 1;\n\t\tframe3.regx.chnl_alloc = ca;\n\n\t\t \n\t\tfor (i = 0; i < BYTES_PER_WORD; i++)\n\t\t\tchecksum += (info_frame >> (i * 8)) & 0xff;\n\t\tfor (i = 0; i < BYTES_PER_WORD; i++)\n\t\t\tchecksum += (frame2.regval >> (i * 8)) & 0xff;\n\t\tfor (i = 0; i < BYTES_PER_WORD; i++)\n\t\t\tchecksum += (frame3.regval >> (i * 8)) & 0xff;\n\n\t\tframe2.regx.chksum = -(checksum);\n\t}\n\n\thad_write_register(intelhaddata, AUD_HDMIW_INFOFR, info_frame);\n\thad_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame2.regval);\n\thad_write_register(intelhaddata, AUD_HDMIW_INFOFR, frame3.regval);\n\n\t \n\tfor (i = 0; i < HAD_MAX_DIP_WORDS-VALID_DIP_WORDS; i++)\n\t\thad_write_register(intelhaddata, AUD_HDMIW_INFOFR, 0x0);\n\n\tctrl_state.regx.dip_freq = 1;\n\tctrl_state.regx.dip_en_sta = 1;\n\thad_write_register(intelhaddata, AUD_CNTL_ST, ctrl_state.regval);\n}\n\nstatic int had_calculate_maud_value(u32 aud_samp_freq, u32 link_rate)\n{\n\tu32 maud_val;\n\n\t \n\tif (link_rate == DP_2_7_GHZ) {\n\t\tswitch (aud_samp_freq) {\n\t\tcase AUD_SAMPLE_RATE_32:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_32_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_44_1:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_44_1_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_48:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_48_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_88_2:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_88_2_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_96:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_96_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_176_4:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_176_4_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase HAD_MAX_RATE:\n\t\t\tmaud_val = HAD_MAX_RATE_DP_2_7_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmaud_val = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else if (link_rate == DP_1_62_GHZ) {\n\t\tswitch (aud_samp_freq) {\n\t\tcase AUD_SAMPLE_RATE_32:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_32_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_44_1:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_44_1_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_48:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_48_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_88_2:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_88_2_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_96:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_96_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase AUD_SAMPLE_RATE_176_4:\n\t\t\tmaud_val = AUD_SAMPLE_RATE_176_4_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tcase HAD_MAX_RATE:\n\t\t\tmaud_val = HAD_MAX_RATE_DP_1_62_MAUD_VAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmaud_val = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmaud_val = -EINVAL;\n\n\treturn maud_val;\n}\n\n \nstatic void had_prog_cts(u32 aud_samp_freq, u32 tmds, u32 link_rate,\n\t\t\t u32 n_param, struct snd_intelhad *intelhaddata)\n{\n\tu32 cts_val;\n\tu64 dividend, divisor;\n\n\tif (intelhaddata->dp_output) {\n\t\t \n\t\tcts_val = had_calculate_maud_value(aud_samp_freq, link_rate);\n\t} else {\n\t\t \n\t\tdividend = (u64)tmds * n_param*1000;\n\t\tdivisor = 128 * aud_samp_freq;\n\t\tcts_val = div64_u64(dividend, divisor);\n\t}\n\tdev_dbg(intelhaddata->dev, \"TMDS value=%d, N value=%d, CTS Value=%d\\n\",\n\t\t tmds, n_param, cts_val);\n\thad_write_register(intelhaddata, AUD_HDMI_CTS, (BIT(24) | cts_val));\n}\n\nstatic int had_calculate_n_value(u32 aud_samp_freq)\n{\n\tint n_val;\n\n\t \n\tswitch (aud_samp_freq) {\n\tcase AUD_SAMPLE_RATE_32:\n\t\tn_val = 4096;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_44_1:\n\t\tn_val = 6272;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_48:\n\t\tn_val = 6144;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_88_2:\n\t\tn_val = 12544;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_96:\n\t\tn_val = 12288;\n\t\tbreak;\n\n\tcase AUD_SAMPLE_RATE_176_4:\n\t\tn_val = 25088;\n\t\tbreak;\n\n\tcase HAD_MAX_RATE:\n\t\tn_val = 24576;\n\t\tbreak;\n\n\tdefault:\n\t\tn_val = -EINVAL;\n\t\tbreak;\n\t}\n\treturn n_val;\n}\n\n \nstatic int had_prog_n(u32 aud_samp_freq, u32 *n_param,\n\t\t      struct snd_intelhad *intelhaddata)\n{\n\tint n_val;\n\n\tif (intelhaddata->dp_output) {\n\t\t \n\n\t\tn_val = DP_NAUD_VAL;\n\t} else\n\t\tn_val =\thad_calculate_n_value(aud_samp_freq);\n\n\tif (n_val < 0)\n\t\treturn n_val;\n\n\thad_write_register(intelhaddata, AUD_N_ENABLE, (BIT(24) | n_val));\n\t*n_param = n_val;\n\treturn 0;\n}\n\n \n\n#define AUD_BUF_ADDR(x)\t\t(AUD_BUF_A_ADDR + (x) * HAD_REG_WIDTH)\n#define AUD_BUF_LEN(x)\t\t(AUD_BUF_A_LENGTH + (x) * HAD_REG_WIDTH)\n\n \nstatic void had_prog_bd(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_intelhad *intelhaddata)\n{\n\tint idx = intelhaddata->bd_head;\n\tint ofs = intelhaddata->pcmbuf_filled * intelhaddata->period_bytes;\n\tu32 addr = substream->runtime->dma_addr + ofs;\n\n\taddr |= AUD_BUF_VALID;\n\tif (!substream->runtime->no_period_wakeup)\n\t\taddr |= AUD_BUF_INTR_EN;\n\thad_write_register(intelhaddata, AUD_BUF_ADDR(idx), addr);\n\thad_write_register(intelhaddata, AUD_BUF_LEN(idx),\n\t\t\t   intelhaddata->period_bytes);\n\n\t \n\tintelhaddata->bd_head++;\n\tintelhaddata->bd_head %= intelhaddata->num_bds;\n\tintelhaddata->pcmbuf_filled++;\n\tintelhaddata->pcmbuf_filled %= substream->runtime->periods;\n}\n\n \nstatic void had_invalidate_bd(struct snd_intelhad *intelhaddata,\n\t\t\t      int idx)\n{\n\thad_write_register(intelhaddata, AUD_BUF_ADDR(idx), 0);\n\thad_write_register(intelhaddata, AUD_BUF_LEN(idx), 0);\n}\n\n \nstatic void had_init_ringbuf(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint i, num_periods;\n\n\tnum_periods = runtime->periods;\n\tintelhaddata->num_bds = min(num_periods, HAD_NUM_OF_RING_BUFS);\n\t \n\tintelhaddata->num_bds = max(intelhaddata->num_bds, 2U);\n\tintelhaddata->period_bytes =\n\t\tframes_to_bytes(runtime, runtime->period_size);\n\tWARN_ON(intelhaddata->period_bytes & 0x3f);\n\n\tintelhaddata->bd_head = 0;\n\tintelhaddata->pcmbuf_head = 0;\n\tintelhaddata->pcmbuf_filled = 0;\n\n\tfor (i = 0; i < HAD_NUM_OF_RING_BUFS; i++) {\n\t\tif (i < intelhaddata->num_bds)\n\t\t\thad_prog_bd(substream, intelhaddata);\n\t\telse  \n\t\t\thad_invalidate_bd(intelhaddata, i);\n\t}\n\n\tintelhaddata->bd_head = 0;  \n}\n\n \nstatic void had_advance_ringbuf(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_intelhad *intelhaddata)\n{\n\tint num_periods = substream->runtime->periods;\n\n\t \n\thad_prog_bd(substream, intelhaddata);\n\n\t \n\tintelhaddata->pcmbuf_head++;\n\tintelhaddata->pcmbuf_head %= num_periods;\n}\n\n \nstatic int had_process_ringbuf(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_intelhad *intelhaddata)\n{\n\tint len, processed;\n\tunsigned long flags;\n\n\tprocessed = 0;\n\tspin_lock_irqsave(&intelhaddata->had_spinlock, flags);\n\tfor (;;) {\n\t\t \n\t\thad_read_register(intelhaddata,\n\t\t\t\t  AUD_BUF_LEN(intelhaddata->bd_head),\n\t\t\t\t  &len);\n\t\tif (len < 0 || len > intelhaddata->period_bytes) {\n\t\t\tdev_dbg(intelhaddata->dev, \"Invalid buf length %d\\n\",\n\t\t\t\tlen);\n\t\t\tlen = -EPIPE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (len > 0)  \n\t\t\tbreak;\n\n\t\t \n\t\tif (++processed >= intelhaddata->num_bds) {\n\t\t\tlen = -EPIPE;  \n\t\t\tgoto out;\n\t\t}\n\t\thad_advance_ringbuf(substream, intelhaddata);\n\t}\n\n\tlen = intelhaddata->period_bytes - len;\n\tlen += intelhaddata->period_bytes * intelhaddata->pcmbuf_head;\n out:\n\tspin_unlock_irqrestore(&intelhaddata->had_spinlock, flags);\n\treturn len;\n}\n\n \nstatic void had_process_buffer_done(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tsubstream = had_substream_get(intelhaddata);\n\tif (!substream)\n\t\treturn;  \n\n\tif (!intelhaddata->connected) {\n\t\tsnd_pcm_stop_xrun(substream);\n\t\tgoto out;  \n\t}\n\n\t \n\tif (had_process_ringbuf(substream, intelhaddata) < 0)\n\t\tsnd_pcm_stop_xrun(substream);\n\telse\n\t\tsnd_pcm_period_elapsed(substream);\n\n out:\n\thad_substream_put(intelhaddata);\n}\n\n \nstatic void wait_clear_underrun_bit(struct snd_intelhad *intelhaddata)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = 0; i < 100; i++) {\n\t\t \n\t\thad_read_register(intelhaddata, AUD_HDMI_STATUS, &val);\n\t\tif (!(val & AUD_HDMI_STATUS_MASK_UNDERRUN))\n\t\t\treturn;\n\t\tudelay(100);\n\t\tcond_resched();\n\t\thad_write_register(intelhaddata, AUD_HDMI_STATUS, val);\n\t}\n\tdev_err(intelhaddata->dev, \"Unable to clear UNDERRUN bits\\n\");\n}\n\n \nstatic int had_pcm_sync_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_intelhad *intelhaddata = snd_pcm_substream_chip(substream);\n\n\tif (!intelhaddata->connected)\n\t\treturn 0;\n\n\t \n\thad_reset_audio(intelhaddata);\n\twait_clear_underrun_bit(intelhaddata);\n\treturn 0;\n}\n\n \nstatic void had_process_buffer_underrun(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\n\t \n\tsubstream = had_substream_get(intelhaddata);\n\tif (substream) {\n\t\tsnd_pcm_stop_xrun(substream);\n\t\thad_substream_put(intelhaddata);\n\t}\n}\n\n \nstatic int had_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_intelhad *intelhaddata;\n\tstruct snd_pcm_runtime *runtime;\n\tint retval;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\truntime = substream->runtime;\n\n\tretval = pm_runtime_resume_and_get(intelhaddata->dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\truntime->hw = had_pcm_hardware;\n\n\tretval = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t \n\tretval = snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t \n\tspin_lock_irq(&intelhaddata->had_spinlock);\n\tintelhaddata->stream_info.substream = substream;\n\tintelhaddata->stream_info.substream_refcount++;\n\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\n\treturn retval;\n error:\n\tpm_runtime_mark_last_busy(intelhaddata->dev);\n\tpm_runtime_put_autosuspend(intelhaddata->dev);\n\treturn retval;\n}\n\n \nstatic int had_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_intelhad *intelhaddata;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\n\t \n\tspin_lock_irq(&intelhaddata->had_spinlock);\n\tintelhaddata->stream_info.substream = NULL;\n\tintelhaddata->stream_info.substream_refcount--;\n\twhile (intelhaddata->stream_info.substream_refcount > 0) {\n\t\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\t\tcpu_relax();\n\t\tspin_lock_irq(&intelhaddata->had_spinlock);\n\t}\n\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\n\tpm_runtime_mark_last_busy(intelhaddata->dev);\n\tpm_runtime_put_autosuspend(intelhaddata->dev);\n\treturn 0;\n}\n\n \nstatic int had_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_intelhad *intelhaddata;\n\tint buf_size;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\tbuf_size = params_buffer_bytes(hw_params);\n\tdev_dbg(intelhaddata->dev, \"%s:allocated memory = %d\\n\",\n\t\t__func__, buf_size);\n\treturn 0;\n}\n\n \nstatic int had_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tint retval = 0;\n\tstruct snd_intelhad *intelhaddata;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\n\tspin_lock(&intelhaddata->had_spinlock);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t \n\t\thad_ack_irqs(intelhaddata);  \n\t\thad_enable_audio(intelhaddata, true);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\thad_enable_audio(intelhaddata, false);\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\tspin_unlock(&intelhaddata->had_spinlock);\n\treturn retval;\n}\n\n \nstatic int had_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tint retval;\n\tu32 disp_samp_freq, n_param;\n\tu32 link_rate = 0;\n\tstruct snd_intelhad *intelhaddata;\n\tstruct snd_pcm_runtime *runtime;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\truntime = substream->runtime;\n\n\tdev_dbg(intelhaddata->dev, \"period_size=%d\\n\",\n\t\t(int)frames_to_bytes(runtime, runtime->period_size));\n\tdev_dbg(intelhaddata->dev, \"periods=%d\\n\", runtime->periods);\n\tdev_dbg(intelhaddata->dev, \"buffer_size=%d\\n\",\n\t\t(int)snd_pcm_lib_buffer_bytes(substream));\n\tdev_dbg(intelhaddata->dev, \"rate=%d\\n\", runtime->rate);\n\tdev_dbg(intelhaddata->dev, \"channels=%d\\n\", runtime->channels);\n\n\t \n\tdisp_samp_freq = intelhaddata->tmds_clock_speed;\n\n\tretval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);\n\tif (retval) {\n\t\tdev_err(intelhaddata->dev,\n\t\t\t\"programming N value failed %#x\\n\", retval);\n\t\tgoto prep_end;\n\t}\n\n\tif (intelhaddata->dp_output)\n\t\tlink_rate = intelhaddata->link_rate;\n\n\thad_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,\n\t\t     n_param, intelhaddata);\n\n\thad_prog_dip(substream, intelhaddata);\n\n\tretval = had_init_audio_ctrl(substream, intelhaddata);\n\n\t \n\thad_init_ringbuf(substream, intelhaddata);\n\n\t \n\n\thad_write_register(intelhaddata, AUD_BUF_CH_SWAP, SWAP_LFE_CENTER);\n\nprep_end:\n\treturn retval;\n}\n\n \nstatic snd_pcm_uframes_t had_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_intelhad *intelhaddata;\n\tint len;\n\n\tintelhaddata = snd_pcm_substream_chip(substream);\n\n\tif (!intelhaddata->connected)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\n\tlen = had_process_ringbuf(substream, intelhaddata);\n\tif (len < 0)\n\t\treturn SNDRV_PCM_POS_XRUN;\n\tlen = bytes_to_frames(substream->runtime, len);\n\t \n\tlen %= substream->runtime->buffer_size;\n\treturn len;\n}\n\n \nstatic const struct snd_pcm_ops had_pcm_ops = {\n\t.open =\t\thad_pcm_open,\n\t.close =\thad_pcm_close,\n\t.hw_params =\thad_pcm_hw_params,\n\t.prepare =\thad_pcm_prepare,\n\t.trigger =\thad_pcm_trigger,\n\t.sync_stop =\thad_pcm_sync_stop,\n\t.pointer =\thad_pcm_pointer,\n};\n\n \nstatic int had_process_mode_change(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\tint retval = 0;\n\tu32 disp_samp_freq, n_param;\n\tu32 link_rate = 0;\n\n\tsubstream = had_substream_get(intelhaddata);\n\tif (!substream)\n\t\treturn 0;\n\n\t \n\thad_enable_audio(intelhaddata, false);\n\n\t \n\tdisp_samp_freq = intelhaddata->tmds_clock_speed;\n\n\tretval = had_prog_n(substream->runtime->rate, &n_param, intelhaddata);\n\tif (retval) {\n\t\tdev_err(intelhaddata->dev,\n\t\t\t\"programming N value failed %#x\\n\", retval);\n\t\tgoto out;\n\t}\n\n\tif (intelhaddata->dp_output)\n\t\tlink_rate = intelhaddata->link_rate;\n\n\thad_prog_cts(substream->runtime->rate, disp_samp_freq, link_rate,\n\t\t     n_param, intelhaddata);\n\n\t \n\thad_enable_audio(intelhaddata, true);\n\nout:\n\thad_substream_put(intelhaddata);\n\treturn retval;\n}\n\n \nstatic void had_process_hot_plug(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tspin_lock_irq(&intelhaddata->had_spinlock);\n\tif (intelhaddata->connected) {\n\t\tdev_dbg(intelhaddata->dev, \"Device already connected\\n\");\n\t\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\t\treturn;\n\t}\n\n\t \n\thad_enable_audio(intelhaddata, false);\n\n\tintelhaddata->connected = true;\n\tdev_dbg(intelhaddata->dev,\n\t\t\"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_CONNECTED\\n\",\n\t\t\t__func__, __LINE__);\n\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\n\thad_build_channel_allocation_map(intelhaddata);\n\n\t \n\tsubstream = had_substream_get(intelhaddata);\n\tif (substream) {\n\t\tsnd_pcm_stop_xrun(substream);\n\t\thad_substream_put(intelhaddata);\n\t}\n\n\tsnd_jack_report(intelhaddata->jack, SND_JACK_AVOUT);\n}\n\n \nstatic void had_process_hot_unplug(struct snd_intelhad *intelhaddata)\n{\n\tstruct snd_pcm_substream *substream;\n\n\tspin_lock_irq(&intelhaddata->had_spinlock);\n\tif (!intelhaddata->connected) {\n\t\tdev_dbg(intelhaddata->dev, \"Device already disconnected\\n\");\n\t\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\t\treturn;\n\n\t}\n\n\t \n\thad_enable_audio(intelhaddata, false);\n\n\tintelhaddata->connected = false;\n\tdev_dbg(intelhaddata->dev,\n\t\t\"%s @ %d:DEBUG PLUG/UNPLUG : HAD_DRV_DISCONNECTED\\n\",\n\t\t\t__func__, __LINE__);\n\tspin_unlock_irq(&intelhaddata->had_spinlock);\n\n\tkfree(intelhaddata->chmap->chmap);\n\tintelhaddata->chmap->chmap = NULL;\n\n\t \n\tsubstream = had_substream_get(intelhaddata);\n\tif (substream) {\n\t\tsnd_pcm_stop_xrun(substream);\n\t\thad_substream_put(intelhaddata);\n\t}\n\n\tsnd_jack_report(intelhaddata->jack, 0);\n}\n\n \n\nstatic int had_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int had_iec958_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&intelhaddata->mutex);\n\tucontrol->value.iec958.status[0] = (intelhaddata->aes_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (intelhaddata->aes_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] =\n\t\t\t\t\t(intelhaddata->aes_bits >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] =\n\t\t\t\t\t(intelhaddata->aes_bits >> 24) & 0xff;\n\tmutex_unlock(&intelhaddata->mutex);\n\treturn 0;\n}\n\nstatic int had_iec958_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n\treturn 0;\n}\n\nstatic int had_iec958_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tunsigned int val;\n\tstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\n\tint changed = 0;\n\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t\t(ucontrol->value.iec958.status[1] << 8) |\n\t\t(ucontrol->value.iec958.status[2] << 16) |\n\t\t(ucontrol->value.iec958.status[3] << 24);\n\tmutex_lock(&intelhaddata->mutex);\n\tif (intelhaddata->aes_bits != val) {\n\t\tintelhaddata->aes_bits = val;\n\t\tchanged = 1;\n\t}\n\tmutex_unlock(&intelhaddata->mutex);\n\treturn changed;\n}\n\nstatic int had_ctl_eld_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = HDMI_MAX_ELD_BYTES;\n\treturn 0;\n}\n\nstatic int had_ctl_eld_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_intelhad *intelhaddata = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&intelhaddata->mutex);\n\tmemcpy(ucontrol->value.bytes.data, intelhaddata->eld,\n\t       HDMI_MAX_ELD_BYTES);\n\tmutex_unlock(&intelhaddata->mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new had_controls[] = {\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, MASK),\n\t\t.info = had_iec958_info,  \n\t\t.get = had_iec958_mask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = had_iec958_info,\n\t\t.get = had_iec958_get,\n\t\t.put = had_iec958_put,\n\t},\n\t{\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"ELD\",\n\t\t.info = had_ctl_eld_info,\n\t\t.get = had_ctl_eld_get,\n\t},\n};\n\n \nstatic irqreturn_t display_pipe_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct snd_intelhad_card *card_ctx = dev_id;\n\tu32 audio_stat[3] = {};\n\tint pipe, port;\n\n\tfor_each_pipe(card_ctx, pipe) {\n\t\t \n\t\taudio_stat[pipe] = had_read_register_raw(card_ctx, pipe,\n\t\t\t\t\t\t\t AUD_HDMI_STATUS) &\n\t\t\t(HDMI_AUDIO_UNDERRUN | HDMI_AUDIO_BUFFER_DONE);\n\n\t\tif (audio_stat[pipe])\n\t\t\thad_write_register_raw(card_ctx, pipe,\n\t\t\t\t\t       AUD_HDMI_STATUS, audio_stat[pipe]);\n\t}\n\n\tfor_each_port(card_ctx, port) {\n\t\tstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\n\t\tint pipe = ctx->pipe;\n\n\t\tif (pipe < 0)\n\t\t\tcontinue;\n\n\t\tif (audio_stat[pipe] & HDMI_AUDIO_BUFFER_DONE)\n\t\t\thad_process_buffer_done(ctx);\n\t\tif (audio_stat[pipe] & HDMI_AUDIO_UNDERRUN)\n\t\t\thad_process_buffer_underrun(ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void notify_audio_lpe(struct platform_device *pdev, int port)\n{\n\tstruct snd_intelhad_card *card_ctx = platform_get_drvdata(pdev);\n\tstruct snd_intelhad *ctx;\n\n\tctx = &card_ctx->pcm_ctx[single_port ? 0 : port];\n\tif (single_port)\n\t\tctx->port = port;\n\n\tschedule_work(&ctx->hdmi_audio_wq);\n}\n\n \nstatic void had_audio_wq(struct work_struct *work)\n{\n\tstruct snd_intelhad *ctx =\n\t\tcontainer_of(work, struct snd_intelhad, hdmi_audio_wq);\n\tstruct intel_hdmi_lpe_audio_pdata *pdata = ctx->dev->platform_data;\n\tstruct intel_hdmi_lpe_audio_port_pdata *ppdata = &pdata->port[ctx->port];\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(ctx->dev);\n\tif (ret < 0)\n\t\treturn;\n\n\tmutex_lock(&ctx->mutex);\n\tif (ppdata->pipe < 0) {\n\t\tdev_dbg(ctx->dev, \"%s: Event: HAD_NOTIFY_HOT_UNPLUG : port = %d\\n\",\n\t\t\t__func__, ctx->port);\n\n\t\tmemset(ctx->eld, 0, sizeof(ctx->eld));  \n\n\t\tctx->dp_output = false;\n\t\tctx->tmds_clock_speed = 0;\n\t\tctx->link_rate = 0;\n\n\t\t \n\t\thad_process_hot_unplug(ctx);\n\n\t\tctx->pipe = -1;\n\t} else {\n\t\tdev_dbg(ctx->dev, \"%s: HAD_NOTIFY_ELD : port = %d, tmds = %d\\n\",\n\t\t\t__func__, ctx->port, ppdata->ls_clock);\n\n\t\tmemcpy(ctx->eld, ppdata->eld, sizeof(ctx->eld));\n\n\t\tctx->dp_output = ppdata->dp_output;\n\t\tif (ctx->dp_output) {\n\t\t\tctx->tmds_clock_speed = 0;\n\t\t\tctx->link_rate = ppdata->ls_clock;\n\t\t} else {\n\t\t\tctx->tmds_clock_speed = ppdata->ls_clock;\n\t\t\tctx->link_rate = 0;\n\t\t}\n\n\t\t \n\t\thad_process_hot_plug(ctx);\n\n\t\tctx->pipe = ppdata->pipe;\n\n\t\t \n\t\thad_process_mode_change(ctx);\n\t}\n\n\tmutex_unlock(&ctx->mutex);\n\tpm_runtime_mark_last_busy(ctx->dev);\n\tpm_runtime_put_autosuspend(ctx->dev);\n}\n\n \nstatic int had_create_jack(struct snd_intelhad *ctx,\n\t\t\t   struct snd_pcm *pcm)\n{\n\tchar hdmi_str[32];\n\tint err;\n\n\tsnprintf(hdmi_str, sizeof(hdmi_str),\n\t\t \"HDMI/DP,pcm=%d\", pcm->device);\n\n\terr = snd_jack_new(ctx->card_ctx->card, hdmi_str,\n\t\t\t   SND_JACK_AVOUT, &ctx->jack,\n\t\t\t   true, false);\n\tif (err < 0)\n\t\treturn err;\n\tctx->jack->private_data = ctx;\n\treturn 0;\n}\n\n \n\nstatic int __maybe_unused hdmi_lpe_audio_suspend(struct device *dev)\n{\n\tstruct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);\n\n\tsnd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D3hot);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hdmi_lpe_audio_resume(struct device *dev)\n{\n\tstruct snd_intelhad_card *card_ctx = dev_get_drvdata(dev);\n\n\tpm_runtime_mark_last_busy(dev);\n\n\tsnd_power_change_state(card_ctx->card, SNDRV_CTL_POWER_D0);\n\n\treturn 0;\n}\n\n \nstatic void hdmi_lpe_audio_free(struct snd_card *card)\n{\n\tstruct snd_intelhad_card *card_ctx = card->private_data;\n\tstruct intel_hdmi_lpe_audio_pdata *pdata = card_ctx->dev->platform_data;\n\tint port;\n\n\tspin_lock_irq(&pdata->lpe_audio_slock);\n\tpdata->notify_audio_lpe = NULL;\n\tspin_unlock_irq(&pdata->lpe_audio_slock);\n\n\tfor_each_port(card_ctx, port) {\n\t\tstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\n\n\t\tcancel_work_sync(&ctx->hdmi_audio_wq);\n\t}\n}\n\n \nstatic int __hdmi_lpe_audio_probe(struct platform_device *pdev)\n{\n\tstruct snd_card *card;\n\tstruct snd_intelhad_card *card_ctx;\n\tstruct snd_intelhad *ctx;\n\tstruct snd_pcm *pcm;\n\tstruct intel_hdmi_lpe_audio_pdata *pdata;\n\tint irq;\n\tstruct resource *res_mmio;\n\tint port, ret;\n\n\tpdata = pdev->dev.platform_data;\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"%s: quit: pdata not allocated by i915!!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tres_mmio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mmio) {\n\t\tdev_err(&pdev->dev, \"Could not get IO_MEM resources\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tret = snd_devm_card_new(&pdev->dev, hdmi_card_index, hdmi_card_id,\n\t\t\t\tTHIS_MODULE, sizeof(*card_ctx), &card);\n\tif (ret)\n\t\treturn ret;\n\n\tcard_ctx = card->private_data;\n\tcard_ctx->dev = &pdev->dev;\n\tcard_ctx->card = card;\n\tstrcpy(card->driver, INTEL_HAD);\n\tstrcpy(card->shortname, \"Intel HDMI/DP LPE Audio\");\n\tstrcpy(card->longname, \"Intel HDMI/DP LPE Audio\");\n\n\tcard_ctx->irq = -1;\n\n\tcard->private_free = hdmi_lpe_audio_free;\n\n\tplatform_set_drvdata(pdev, card_ctx);\n\n\tcard_ctx->num_pipes = pdata->num_pipes;\n\tcard_ctx->num_ports = single_port ? 1 : pdata->num_ports;\n\n\tfor_each_port(card_ctx, port) {\n\t\tctx = &card_ctx->pcm_ctx[port];\n\t\tctx->card_ctx = card_ctx;\n\t\tctx->dev = card_ctx->dev;\n\t\tctx->port = single_port ? -1 : port;\n\t\tctx->pipe = -1;\n\n\t\tspin_lock_init(&ctx->had_spinlock);\n\t\tmutex_init(&ctx->mutex);\n\t\tINIT_WORK(&ctx->hdmi_audio_wq, had_audio_wq);\n\t}\n\n\tdev_dbg(&pdev->dev, \"%s: mmio_start = 0x%x, mmio_end = 0x%x\\n\",\n\t\t__func__, (unsigned int)res_mmio->start,\n\t\t(unsigned int)res_mmio->end);\n\n\tcard_ctx->mmio_start =\n\t\tdevm_ioremap(&pdev->dev, res_mmio->start,\n\t\t\t     (size_t)(resource_size(res_mmio)));\n\tif (!card_ctx->mmio_start) {\n\t\tdev_err(&pdev->dev, \"Could not get ioremap\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq, display_pipe_interrupt_handler,\n\t\t\t       0, pdev->name, card_ctx);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\treturn ret;\n\t}\n\n\tcard_ctx->irq = irq;\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tinit_channel_allocations();\n\n\tcard_ctx->num_pipes = pdata->num_pipes;\n\tcard_ctx->num_ports = single_port ? 1 : pdata->num_ports;\n\n\tfor_each_port(card_ctx, port) {\n\t\tint i;\n\n\t\tctx = &card_ctx->pcm_ctx[port];\n\t\tret = snd_pcm_new(card, INTEL_HAD, port, MAX_PB_STREAMS,\n\t\t\t\t  MAX_CAP_STREAMS, &pcm);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tpcm->private_data = ctx;\n\t\tpcm->info_flags = 0;\n\t\tstrscpy(pcm->name, card->shortname, strlen(card->shortname));\n\t\t \n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &had_pcm_ops);\n\n\t\t \n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC,\n\t\t\t\t\t       card->dev, HAD_DEFAULT_BUFFER,\n\t\t\t\t\t       HAD_MAX_BUFFER);\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(had_controls); i++) {\n\t\t\tstruct snd_kcontrol *kctl;\n\n\t\t\tkctl = snd_ctl_new1(&had_controls[i], ctx);\n\t\t\tif (!kctl)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tkctl->id.device = pcm->device;\n\n\t\t\tret = snd_ctl_add(card, kctl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = had_register_chmap_ctls(ctx, pcm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = had_create_jack(ctx, pcm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = snd_card_register(card);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irq(&pdata->lpe_audio_slock);\n\tpdata->notify_audio_lpe = notify_audio_lpe;\n\tspin_unlock_irq(&pdata->lpe_audio_slock);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, INTEL_HDMI_AUDIO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_idle(&pdev->dev);\n\n\tdev_dbg(&pdev->dev, \"%s: handle pending notification\\n\", __func__);\n\tfor_each_port(card_ctx, port) {\n\t\tstruct snd_intelhad *ctx = &card_ctx->pcm_ctx[port];\n\n\t\tschedule_work(&ctx->hdmi_audio_wq);\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_lpe_audio_probe(struct platform_device *pdev)\n{\n\treturn snd_card_free_on_error(&pdev->dev, __hdmi_lpe_audio_probe(pdev));\n}\n\nstatic const struct dev_pm_ops hdmi_lpe_audio_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(hdmi_lpe_audio_suspend, hdmi_lpe_audio_resume)\n};\n\nstatic struct platform_driver hdmi_lpe_audio_driver = {\n\t.driver\t\t= {\n\t\t.name  = \"hdmi-lpe-audio\",\n\t\t.pm = &hdmi_lpe_audio_pm,\n\t},\n\t.probe          = hdmi_lpe_audio_probe,\n};\n\nmodule_platform_driver(hdmi_lpe_audio_driver);\nMODULE_ALIAS(\"platform:hdmi_lpe_audio\");\n\nMODULE_AUTHOR(\"Sailaja Bandarupalli <sailaja.bandarupalli@intel.com>\");\nMODULE_AUTHOR(\"Ramesh Babu K V <ramesh.babu@intel.com>\");\nMODULE_AUTHOR(\"Vaibhav Agarwal <vaibhav.agarwal@intel.com>\");\nMODULE_AUTHOR(\"Jerome Anand <jerome.anand@intel.com>\");\nMODULE_DESCRIPTION(\"Intel HDMI Audio driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}