{
  "module_name": "bus.c",
  "hash_id": "225d42515a82274d303b2fcf1e40365ea83a08c94177a7eabddea8f48bac8363",
  "original_prompt": "Ingested from linux-6.6.14/sound/ac97/bus.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <sound/ac97/codec.h>\n#include <sound/ac97/controller.h>\n#include <sound/ac97/regs.h>\n\n#include \"ac97_core.h\"\n\n \nstatic DEFINE_MUTEX(ac97_controllers_mutex);\nstatic DEFINE_IDR(ac97_adapter_idr);\nstatic LIST_HEAD(ac97_controllers);\n\nstatic struct bus_type ac97_bus_type;\n\nstatic inline struct ac97_controller*\nto_ac97_controller(struct device *ac97_adapter)\n{\n\treturn container_of(ac97_adapter, struct ac97_controller, adap);\n}\n\nstatic int ac97_unbound_ctrl_write(struct ac97_controller *adrv, int slot,\n\t\t     unsigned short reg, unsigned short val)\n{\n\treturn -ENODEV;\n}\n\nstatic int ac97_unbound_ctrl_read(struct ac97_controller *adrv, int slot,\n\t\t\t\t  unsigned short reg)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct ac97_controller_ops ac97_unbound_ctrl_ops = {\n\t.write = ac97_unbound_ctrl_write,\n\t.read = ac97_unbound_ctrl_read,\n};\n\nstatic struct ac97_controller ac97_unbound_ctrl = {\n\t.ops = &ac97_unbound_ctrl_ops,\n};\n\nstatic struct ac97_codec_device *\nac97_codec_find(struct ac97_controller *ac97_ctrl, unsigned int codec_num)\n{\n\tif (codec_num >= AC97_BUS_MAX_CODECS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ac97_ctrl->codecs[codec_num];\n}\n\nstatic struct device_node *\nac97_of_get_child_device(struct ac97_controller *ac97_ctrl, int idx,\n\t\t\t unsigned int vendor_id)\n{\n\tstruct device_node *node;\n\tu32 reg;\n\tchar compat[] = \"ac97,0000,0000\";\n\n\tsnprintf(compat, sizeof(compat), \"ac97,%04x,%04x\",\n\t\t vendor_id >> 16, vendor_id & 0xffff);\n\n\tfor_each_child_of_node(ac97_ctrl->parent->of_node, node) {\n\t\tif ((idx != of_property_read_u32(node, \"reg\", &reg)) ||\n\t\t    !of_device_is_compatible(node, compat))\n\t\t\tcontinue;\n\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ac97_codec_release(struct device *dev)\n{\n\tstruct ac97_codec_device *adev;\n\tstruct ac97_controller *ac97_ctrl;\n\n\tadev = to_ac97_device(dev);\n\tac97_ctrl = adev->ac97_ctrl;\n\tac97_ctrl->codecs[adev->num] = NULL;\n\tof_node_put(dev->of_node);\n\tkfree(adev);\n}\n\nstatic int ac97_codec_add(struct ac97_controller *ac97_ctrl, int idx,\n\t\t   unsigned int vendor_id)\n{\n\tstruct ac97_codec_device *codec;\n\tint ret;\n\n\tcodec = kzalloc(sizeof(*codec), GFP_KERNEL);\n\tif (!codec)\n\t\treturn -ENOMEM;\n\tac97_ctrl->codecs[idx] = codec;\n\tcodec->vendor_id = vendor_id;\n\tcodec->dev.release = ac97_codec_release;\n\tcodec->dev.bus = &ac97_bus_type;\n\tcodec->dev.parent = &ac97_ctrl->adap;\n\tcodec->num = idx;\n\tcodec->ac97_ctrl = ac97_ctrl;\n\n\tdevice_initialize(&codec->dev);\n\tdev_set_name(&codec->dev, \"%s:%u\", dev_name(ac97_ctrl->parent), idx);\n\tcodec->dev.of_node = ac97_of_get_child_device(ac97_ctrl, idx,\n\t\t\t\t\t\t      vendor_id);\n\n\tret = device_add(&codec->dev);\n\tif (ret) {\n\t\tput_device(&codec->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nunsigned int snd_ac97_bus_scan_one(struct ac97_controller *adrv,\n\t\t\t\t   unsigned int codec_num)\n{\n\tunsigned short vid1, vid2;\n\tint ret;\n\n\tret = adrv->ops->read(adrv, codec_num, AC97_VENDOR_ID1);\n\tvid1 = (ret & 0xffff);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret = adrv->ops->read(adrv, codec_num, AC97_VENDOR_ID2);\n\tvid2 = (ret & 0xffff);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tdev_dbg(&adrv->adap, \"%s(codec_num=%u): vendor_id=0x%08x\\n\",\n\t\t__func__, codec_num, AC97_ID(vid1, vid2));\n\treturn AC97_ID(vid1, vid2);\n}\n\nstatic int ac97_bus_scan(struct ac97_controller *ac97_ctrl)\n{\n\tint ret, i;\n\tunsigned int vendor_id;\n\n\tfor (i = 0; i < AC97_BUS_MAX_CODECS; i++) {\n\t\tif (ac97_codec_find(ac97_ctrl, i))\n\t\t\tcontinue;\n\t\tif (!(ac97_ctrl->slots_available & BIT(i)))\n\t\t\tcontinue;\n\t\tvendor_id = snd_ac97_bus_scan_one(ac97_ctrl, i);\n\t\tif (!vendor_id)\n\t\t\tcontinue;\n\n\t\tret = ac97_codec_add(ac97_ctrl, i, vendor_id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int ac97_bus_reset(struct ac97_controller *ac97_ctrl)\n{\n\tac97_ctrl->ops->reset(ac97_ctrl);\n\n\treturn 0;\n}\n\n \nint snd_ac97_codec_driver_register(struct ac97_codec_driver *drv)\n{\n\tdrv->driver.bus = &ac97_bus_type;\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(snd_ac97_codec_driver_register);\n\n \nvoid snd_ac97_codec_driver_unregister(struct ac97_codec_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(snd_ac97_codec_driver_unregister);\n\n \nvoid *snd_ac97_codec_get_platdata(const struct ac97_codec_device *adev)\n{\n\tstruct ac97_controller *ac97_ctrl = adev->ac97_ctrl;\n\n\treturn ac97_ctrl->codecs_pdata[adev->num];\n}\nEXPORT_SYMBOL_GPL(snd_ac97_codec_get_platdata);\n\nstatic void ac97_ctrl_codecs_unregister(struct ac97_controller *ac97_ctrl)\n{\n\tint i;\n\n\tfor (i = 0; i < AC97_BUS_MAX_CODECS; i++)\n\t\tif (ac97_ctrl->codecs[i]) {\n\t\t\tac97_ctrl->codecs[i]->ac97_ctrl = &ac97_unbound_ctrl;\n\t\t\tdevice_unregister(&ac97_ctrl->codecs[i]->dev);\n\t\t}\n}\n\nstatic ssize_t cold_reset_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct ac97_controller *ac97_ctrl;\n\n\tmutex_lock(&ac97_controllers_mutex);\n\tac97_ctrl = to_ac97_controller(dev);\n\tac97_ctrl->ops->reset(ac97_ctrl);\n\tmutex_unlock(&ac97_controllers_mutex);\n\treturn len;\n}\nstatic DEVICE_ATTR_WO(cold_reset);\n\nstatic ssize_t warm_reset_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t len)\n{\n\tstruct ac97_controller *ac97_ctrl;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ac97_controllers_mutex);\n\tac97_ctrl = to_ac97_controller(dev);\n\tac97_ctrl->ops->warm_reset(ac97_ctrl);\n\tmutex_unlock(&ac97_controllers_mutex);\n\treturn len;\n}\nstatic DEVICE_ATTR_WO(warm_reset);\n\nstatic struct attribute *ac97_controller_device_attrs[] = {\n\t&dev_attr_cold_reset.attr,\n\t&dev_attr_warm_reset.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ac97_adapter_attr_group = {\n\t.name\t= \"ac97_operations\",\n\t.attrs\t= ac97_controller_device_attrs,\n};\n\nstatic const struct attribute_group *ac97_adapter_groups[] = {\n\t&ac97_adapter_attr_group,\n\tNULL,\n};\n\nstatic void ac97_del_adapter(struct ac97_controller *ac97_ctrl)\n{\n\tmutex_lock(&ac97_controllers_mutex);\n\tac97_ctrl_codecs_unregister(ac97_ctrl);\n\tlist_del(&ac97_ctrl->controllers);\n\tmutex_unlock(&ac97_controllers_mutex);\n\n\tdevice_unregister(&ac97_ctrl->adap);\n}\n\nstatic void ac97_adapter_release(struct device *dev)\n{\n\tstruct ac97_controller *ac97_ctrl;\n\n\tac97_ctrl = to_ac97_controller(dev);\n\tidr_remove(&ac97_adapter_idr, ac97_ctrl->nr);\n\tdev_dbg(&ac97_ctrl->adap, \"adapter unregistered by %s\\n\",\n\t\tdev_name(ac97_ctrl->parent));\n}\n\nstatic const struct device_type ac97_adapter_type = {\n\t.groups\t\t= ac97_adapter_groups,\n\t.release\t= ac97_adapter_release,\n};\n\nstatic int ac97_add_adapter(struct ac97_controller *ac97_ctrl)\n{\n\tint ret;\n\n\tmutex_lock(&ac97_controllers_mutex);\n\tret = idr_alloc(&ac97_adapter_idr, ac97_ctrl, 0, 0, GFP_KERNEL);\n\tac97_ctrl->nr = ret;\n\tif (ret >= 0) {\n\t\tdev_set_name(&ac97_ctrl->adap, \"ac97-%d\", ret);\n\t\tac97_ctrl->adap.type = &ac97_adapter_type;\n\t\tac97_ctrl->adap.parent = ac97_ctrl->parent;\n\t\tret = device_register(&ac97_ctrl->adap);\n\t\tif (ret)\n\t\t\tput_device(&ac97_ctrl->adap);\n\t}\n\tif (!ret)\n\t\tlist_add(&ac97_ctrl->controllers, &ac97_controllers);\n\tmutex_unlock(&ac97_controllers_mutex);\n\n\tif (!ret)\n\t\tdev_dbg(&ac97_ctrl->adap, \"adapter registered by %s\\n\",\n\t\t\tdev_name(ac97_ctrl->parent));\n\treturn ret;\n}\n\n \nstruct ac97_controller *snd_ac97_controller_register(\n\tconst struct ac97_controller_ops *ops, struct device *dev,\n\tunsigned short slots_available, void **codecs_pdata)\n{\n\tstruct ac97_controller *ac97_ctrl;\n\tint ret, i;\n\n\tac97_ctrl = kzalloc(sizeof(*ac97_ctrl), GFP_KERNEL);\n\tif (!ac97_ctrl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < AC97_BUS_MAX_CODECS && codecs_pdata; i++)\n\t\tac97_ctrl->codecs_pdata[i] = codecs_pdata[i];\n\n\tac97_ctrl->ops = ops;\n\tac97_ctrl->slots_available = slots_available;\n\tac97_ctrl->parent = dev;\n\tret = ac97_add_adapter(ac97_ctrl);\n\n\tif (ret)\n\t\tgoto err;\n\tac97_bus_reset(ac97_ctrl);\n\tac97_bus_scan(ac97_ctrl);\n\n\treturn ac97_ctrl;\nerr:\n\tkfree(ac97_ctrl);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(snd_ac97_controller_register);\n\n \nvoid snd_ac97_controller_unregister(struct ac97_controller *ac97_ctrl)\n{\n\tac97_del_adapter(ac97_ctrl);\n}\nEXPORT_SYMBOL_GPL(snd_ac97_controller_unregister);\n\n#ifdef CONFIG_PM\nstatic int ac97_pm_runtime_suspend(struct device *dev)\n{\n\tstruct ac97_codec_device *codec = to_ac97_device(dev);\n\tint ret = pm_generic_runtime_suspend(dev);\n\n\tif (ret == 0 && dev->driver) {\n\t\tif (pm_runtime_is_irq_safe(dev))\n\t\t\tclk_disable(codec->clk);\n\t\telse\n\t\t\tclk_disable_unprepare(codec->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int ac97_pm_runtime_resume(struct device *dev)\n{\n\tstruct ac97_codec_device *codec = to_ac97_device(dev);\n\tint ret;\n\n\tif (dev->driver) {\n\t\tif (pm_runtime_is_irq_safe(dev))\n\t\t\tret = clk_enable(codec->clk);\n\t\telse\n\t\t\tret = clk_prepare_enable(codec->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn pm_generic_runtime_resume(dev);\n}\n#endif  \n\nstatic const struct dev_pm_ops ac97_pm = {\n\t.suspend\t= pm_generic_suspend,\n\t.resume\t\t= pm_generic_resume,\n\t.freeze\t\t= pm_generic_freeze,\n\t.thaw\t\t= pm_generic_thaw,\n\t.poweroff\t= pm_generic_poweroff,\n\t.restore\t= pm_generic_restore,\n\tSET_RUNTIME_PM_OPS(\n\t\tac97_pm_runtime_suspend,\n\t\tac97_pm_runtime_resume,\n\t\tNULL)\n};\n\nstatic int ac97_get_enable_clk(struct ac97_codec_device *adev)\n{\n\tint ret;\n\n\tadev->clk = clk_get(&adev->dev, \"ac97_clk\");\n\tif (IS_ERR(adev->clk))\n\t\treturn PTR_ERR(adev->clk);\n\n\tret = clk_prepare_enable(adev->clk);\n\tif (ret)\n\t\tclk_put(adev->clk);\n\n\treturn ret;\n}\n\nstatic void ac97_put_disable_clk(struct ac97_codec_device *adev)\n{\n\tclk_disable_unprepare(adev->clk);\n\tclk_put(adev->clk);\n}\n\nstatic ssize_t vendor_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ac97_codec_device *codec = to_ac97_device(dev);\n\n\treturn sysfs_emit(buf, \"%08x\", codec->vendor_id);\n}\nstatic DEVICE_ATTR_RO(vendor_id);\n\nstatic struct attribute *ac97_dev_attrs[] = {\n\t&dev_attr_vendor_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ac97_dev);\n\nstatic int ac97_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(dev);\n\tstruct ac97_codec_driver *adrv = to_ac97_driver(drv);\n\tconst struct ac97_id *id = adrv->id_table;\n\tint i = 0;\n\n\tif (adev->vendor_id == 0x0 || adev->vendor_id == 0xffffffff)\n\t\treturn false;\n\n\tdo {\n\t\tif (ac97_ids_match(id[i].id, adev->vendor_id, id[i].mask))\n\t\t\treturn true;\n\t} while (id[i++].id);\n\n\treturn false;\n}\n\nstatic int ac97_bus_probe(struct device *dev)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(dev);\n\tstruct ac97_codec_driver *adrv = to_ac97_driver(dev->driver);\n\tint ret;\n\n\tret = ac97_get_enable_clk(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tret = adrv->probe(adev);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\tac97_put_disable_clk(adev);\n\n\treturn ret;\n}\n\nstatic void ac97_bus_remove(struct device *dev)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(dev);\n\tstruct ac97_codec_driver *adrv = to_ac97_driver(dev->driver);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn;\n\n\tadrv->remove(adev);\n\tpm_runtime_put_noidle(dev);\n\tac97_put_disable_clk(adev);\n\n\tpm_runtime_disable(dev);\n}\n\nstatic struct bus_type ac97_bus_type = {\n\t.name\t\t= \"ac97bus\",\n\t.dev_groups\t= ac97_dev_groups,\n\t.match\t\t= ac97_bus_match,\n\t.pm\t\t= &ac97_pm,\n\t.probe\t\t= ac97_bus_probe,\n\t.remove\t\t= ac97_bus_remove,\n};\n\nstatic int __init ac97_bus_init(void)\n{\n\treturn bus_register(&ac97_bus_type);\n}\nsubsys_initcall(ac97_bus_init);\n\nstatic void __exit ac97_bus_exit(void)\n{\n\tbus_unregister(&ac97_bus_type);\n}\nmodule_exit(ac97_bus_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Jarzmik <robert.jarzmik@free.fr>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}