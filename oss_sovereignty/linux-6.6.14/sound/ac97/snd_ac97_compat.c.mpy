{
  "module_name": "snd_ac97_compat.c",
  "hash_id": "773fc905fba8ecc4e2e246b6d6f7a5d63f7a0c168f3bf05258ee07c883d230de",
  "original_prompt": "Ingested from linux-6.6.14/sound/ac97/snd_ac97_compat.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <sound/ac97/codec.h>\n#include <sound/ac97/compat.h>\n#include <sound/ac97/controller.h>\n#include <sound/soc.h>\n\n#include \"ac97_core.h\"\n\nstatic void compat_ac97_release(struct device *dev)\n{\n\tkfree(to_ac97_t(dev));\n}\n\nstatic void compat_ac97_reset(struct snd_ac97 *ac97)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(ac97->private_data);\n\tstruct ac97_controller *actrl = adev->ac97_ctrl;\n\n\tif (actrl->ops->reset)\n\t\tactrl->ops->reset(actrl);\n}\n\nstatic void compat_ac97_warm_reset(struct snd_ac97 *ac97)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(ac97->private_data);\n\tstruct ac97_controller *actrl = adev->ac97_ctrl;\n\n\tif (actrl->ops->warm_reset)\n\t\tactrl->ops->warm_reset(actrl);\n}\n\nstatic void compat_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t      unsigned short val)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(ac97->private_data);\n\tstruct ac97_controller *actrl = adev->ac97_ctrl;\n\n\tactrl->ops->write(actrl, ac97->num, reg, val);\n}\n\nstatic unsigned short compat_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t       unsigned short reg)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(ac97->private_data);\n\tstruct ac97_controller *actrl = adev->ac97_ctrl;\n\n\treturn actrl->ops->read(actrl, ac97->num, reg);\n}\n\nstatic const struct snd_ac97_bus_ops compat_snd_ac97_bus_ops = {\n\t.reset = compat_ac97_reset,\n\t.warm_reset = compat_ac97_warm_reset,\n\t.write = compat_ac97_write,\n\t.read = compat_ac97_read,\n};\n\nstatic struct snd_ac97_bus compat_soc_ac97_bus = {\n\t.ops = &compat_snd_ac97_bus_ops,\n};\n\nstruct snd_ac97 *snd_ac97_compat_alloc(struct ac97_codec_device *adev)\n{\n\tstruct snd_ac97 *ac97;\n\tint ret;\n\n\tac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);\n\tif (ac97 == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tac97->private_data = adev;\n\tac97->bus = &compat_soc_ac97_bus;\n\n\tac97->dev.parent = &adev->dev;\n\tac97->dev.release = compat_ac97_release;\n\tdev_set_name(&ac97->dev, \"%s-compat\", dev_name(&adev->dev));\n\tret = device_register(&ac97->dev);\n\tif (ret) {\n\t\tput_device(&ac97->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ac97;\n}\nEXPORT_SYMBOL_GPL(snd_ac97_compat_alloc);\n\nvoid snd_ac97_compat_release(struct snd_ac97 *ac97)\n{\n\tdevice_unregister(&ac97->dev);\n}\nEXPORT_SYMBOL_GPL(snd_ac97_compat_release);\n\nint snd_ac97_reset(struct snd_ac97 *ac97, bool try_warm, unsigned int id,\n\tunsigned int id_mask)\n{\n\tstruct ac97_codec_device *adev = to_ac97_device(ac97->private_data);\n\tstruct ac97_controller *actrl = adev->ac97_ctrl;\n\tunsigned int scanned;\n\n\tif (try_warm) {\n\t\tcompat_ac97_warm_reset(ac97);\n\t\tscanned = snd_ac97_bus_scan_one(actrl, adev->num);\n\t\tif (ac97_ids_match(scanned, adev->vendor_id, id_mask))\n\t\t\treturn 1;\n\t}\n\n\tcompat_ac97_reset(ac97);\n\tcompat_ac97_warm_reset(ac97);\n\tscanned = snd_ac97_bus_scan_one(actrl, adev->num);\n\tif (ac97_ids_match(scanned, adev->vendor_id, id_mask))\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(snd_ac97_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}