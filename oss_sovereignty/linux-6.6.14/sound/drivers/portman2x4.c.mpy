{
  "module_name": "portman2x4.c",
  "hash_id": "cefe3103d4af326a08a7d5c47d247e0e440a6a3f97d59987b63db5b1e1b252ef",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/portman2x4.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/parport.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n#include <sound/control.h>\n\n#define CARD_NAME \"Portman 2x4\"\n#define DRIVER_NAME \"portman\"\n#define PLATFORM_DRIVER \"snd_portman2x4\"\n\nstatic int index[SNDRV_CARDS]  = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS]   = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nstatic struct platform_device *platform_devices[SNDRV_CARDS]; \nstatic int device_count;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\n\nMODULE_AUTHOR(\"Levent Guendogdu, Tobias Gehrig, Matthias Koenig\");\nMODULE_DESCRIPTION(\"Midiman Portman2x4\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define PORTMAN_NUM_INPUT_PORTS 2\n#define PORTMAN_NUM_OUTPUT_PORTS 4\n\nstruct portman {\n\tspinlock_t reg_lock;\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tstruct pardevice *pardev;\n\tint open_count;\n\tint mode[PORTMAN_NUM_INPUT_PORTS];\n\tstruct snd_rawmidi_substream *midi_input[PORTMAN_NUM_INPUT_PORTS];\n};\n\nstatic int portman_free(struct portman *pm)\n{\n\tkfree(pm);\n\treturn 0;\n}\n\nstatic int portman_create(struct snd_card *card,\n\t\t\t  struct pardevice *pardev,\n\t\t\t  struct portman **rchip)\n{\n\tstruct portman *pm;\n\n\t*rchip = NULL;\n\n\tpm = kzalloc(sizeof(struct portman), GFP_KERNEL);\n\tif (pm == NULL) \n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_init(&pm->reg_lock);\n\tpm->card = card;\n\tpm->pardev = pardev;\n\n\t*rchip = pm;\n\n\treturn 0;\n}\n\n \n\n \n#define\tPP_STAT_BSY   \t0x80\t \n#define\tPP_STAT_ACK   \t0x40\t \n#define\tPP_STAT_POUT  \t0x20\t \n#define\tPP_STAT_SEL   \t0x10\t \n#define\tPP_STAT_ERR   \t0x08\t \n\n \n#define\tPP_CMD_IEN  \t0x10\t \n#define\tPP_CMD_SELI \t0x08\t \n#define\tPP_CMD_INIT \t0x04\t \n#define\tPP_CMD_FEED \t0x02\t \n#define\tPP_CMD_STB      0x01\t \n\n \n#define\tINT_EN\t \tPP_CMD_IEN\t \n#define\tSTROBE\t        PP_CMD_STB\t \n\n \n#define\tRXDATA0\t\t(0 << 1)\t \n#define\tRXDATA1\t\t(1 << 1)\t \n#define\tGEN_CTL\t\t(2 << 1)\t \n#define\tSYNC_CTL \t(3 << 1)\t \n#define\tTXDATA0\t\t(4 << 1)\t \n#define\tTXDATA1\t\t(5 << 1)\t \n#define\tTXDATA2\t\t(6 << 1)\t \n#define\tTXDATA3\t\t(7 << 1)\t \n\n \n#define\tESTB\t\tPP_STAT_POUT\t \n#define\tINT_REQ         PP_STAT_ACK\t \n#define\tBUSY            PP_STAT_ERR\t \n\n \n#define\tRXAVAIL\t\tPP_STAT_SEL\t \n\n#define\tSYNC_STAT\tPP_STAT_SEL\t \n\n#define\tTXEMPTY\t\tPP_STAT_SEL\t \n\n\n\n\n \n#define\tRXDATA\t\tPP_STAT_BSY\t \n\n#define\tSYNC_DATA       PP_STAT_BSY\t \n\t\t\t\t\t \n#define\tDATA_ECHO       PP_STAT_BSY\t \n#define\tA0_ECHO         PP_STAT_BSY\t \n#define\tA1_ECHO         PP_STAT_BSY\t \n#define\tA2_ECHO         PP_STAT_BSY\t \n\n#define PORTMAN2X4_MODE_INPUT_TRIGGERED\t 0x01\n\n \nstatic inline void portman_write_command(struct portman *pm, u8 value)\n{\n\tparport_write_control(pm->pardev->port, value);\n}\n\nstatic inline u8 portman_read_status(struct portman *pm)\n{\n\treturn parport_read_status(pm->pardev->port);\n}\n\nstatic inline void portman_write_data(struct portman *pm, u8 value)\n{\n\tparport_write_data(pm->pardev->port, value);\n}\n\nstatic void portman_write_midi(struct portman *pm, \n\t\t\t       int port, u8 mididata)\n{\n\tint command = ((port + 4) << 1);\n\n\t \n\tcommand |= INT_EN;\n\n\t \n\n\tdo {\n\t\tportman_write_command(pm, command);\n\n\t\t \n\n\t\tportman_write_data(pm, mididata);\n\t\t\n\t\t \n\t} while ((portman_read_status(pm) & TXEMPTY) != TXEMPTY);\n\n\t \n\n\tportman_write_command(pm, command | STROBE);\n\n\t \n\n\twhile ((portman_read_status(pm) & ESTB) == 0)\n\t\tcpu_relax();\n\n\t \n\tportman_write_command(pm, command);\n\n\twhile ((portman_read_status(pm) & ESTB) == ESTB)\n\t\tcpu_relax();\n\n\t \n\n\twhile ((portman_read_status(pm) & BUSY) == BUSY)\n\t\tcpu_relax();\n\n\t \n}\n\n\n \nstatic int portman_read_midi(struct portman *pm, int port)\n{\n\tunsigned char midi_data = 0;\n\tunsigned char cmdout;\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\n\t \n\tcmdout = (port << 1) | INT_EN;\t \n\tportman_write_command(pm, cmdout);\n\n\twhile ((portman_read_status(pm) & ESTB) == ESTB)\n\t\tcpu_relax();\t \n\n\t \n\tif ((portman_read_status(pm) & RXAVAIL) == 0)\n\t\treturn -1;\t \n\n\t \n\tportman_write_command(pm, cmdout | STROBE);\t \n\n\twhile ((portman_read_status(pm) & ESTB) == 0)\n\t\tcpu_relax();  \n\n\t \n\tmidi_data = (portman_read_status(pm) & 128);\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 1) & 64;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 2) & 32;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 3) & 16;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 4) & 8;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 5) & 4;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 6) & 2;\n\tportman_write_data(pm, 1);\t \n\n\t \n\tportman_write_data(pm, 0);\t \n\tmidi_data |= (portman_read_status(pm) >> 7) & 1;\n\tportman_write_data(pm, 1);\t \n\tportman_write_data(pm, 0);\t \n\n\n\t \n\tportman_write_command(pm, cmdout);\t \n\n\t \n\twhile ((portman_read_status(pm) & ESTB) == ESTB)\n\t\tcpu_relax();\n\n\treturn (midi_data & 255);\t \n}\n\n \nstatic int portman_data_avail(struct portman *pm, int channel)\n{\n\tint command = INT_EN;\n\tswitch (channel) {\n\tcase 0:\n\t\tcommand |= RXDATA0;\n\t\tbreak;\n\tcase 1:\n\t\tcommand |= RXDATA1;\n\t\tbreak;\n\t}\n\t \n\tportman_write_command(pm, command);\n\t \n\tif ((portman_read_status(pm) & RXAVAIL) == RXAVAIL)\n\t\treturn 1;\t \n\n\t \n\treturn 0;\n}\n\n\n \nstatic void portman_flush_input(struct portman *pm, unsigned char port)\n{\n\t \n\tunsigned int i = 0;\n\tunsigned char command = 0;\n\n\tswitch (port) {\n\tcase 0:\n\t\tcommand = RXDATA0;\n\t\tbreak;\n\tcase 1:\n\t\tcommand = RXDATA1;\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_WARNING\n\t\t\t   \"portman_flush_input() Won't flush port %i\\n\",\n\t\t\t   port);\n\t\treturn;\n\t}\n\n\t \n\tportman_write_command(pm, command);\n\n\t \n\tportman_write_command(pm, command | STROBE);\n\n\t \n\twhile ((portman_read_status(pm) & ESTB) == 0)\n\t\tcpu_relax();\n\n\t \n\tportman_write_data(pm, 0);\n\n\t \n\tfor (i = 0; i < 250; i++) {\n\t\tportman_write_data(pm, 1);\n\t\tportman_write_data(pm, 0);\n\t}\n\n\t \n\tportman_write_command(pm, command | INT_EN);\n\n\t \n\twhile ((portman_read_status(pm) & ESTB) == ESTB)\n\t\tcpu_relax();\n}\n\nstatic int portman_probe(struct parport *p)\n{\n\t \n\t \n\tparport_write_data(p, 0);\n\n\t \n\t \n\tparport_write_control(p, 0);\n\n\t \n\t \n\tparport_write_control(p, RXDATA0);\t \n\n\t \n\t \n\tif ((parport_read_status(p) & ESTB) == ESTB)\n\t\treturn 1;\t \n\n\t \n\t \n\tparport_write_control(p, RXDATA0 | STROBE);\t \n\n\t \n\tif ((parport_read_status(p) & ESTB) != ESTB)\n\t\treturn 1;\t \n\n\t \n\tparport_write_control(p, 0);\t \n\n\t \n\t \n\tparport_write_control(p, TXDATA0);\t \n\n\t \n\t \n\tif ((parport_read_status(p) & TXEMPTY) == 0)\n\t\treturn 2;\n\n\t \n\treturn 0;\n}\n\nstatic int portman_device_init(struct portman *pm)\n{\n\tportman_flush_input(pm, 0);\n\tportman_flush_input(pm, 1);\n\n\treturn 0;\n}\n\n \nstatic int snd_portman_midi_open(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int snd_portman_midi_close(struct snd_rawmidi_substream *substream)\n{\n\treturn 0;\n}\n\nstatic void snd_portman_midi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t   int up)\n{\n\tstruct portman *pm = substream->rmidi->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pm->reg_lock, flags);\n\tif (up)\n\t\tpm->mode[substream->number] |= PORTMAN2X4_MODE_INPUT_TRIGGERED;\n\telse\n\t\tpm->mode[substream->number] &= ~PORTMAN2X4_MODE_INPUT_TRIGGERED;\n\tspin_unlock_irqrestore(&pm->reg_lock, flags);\n}\n\nstatic void snd_portman_midi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t    int up)\n{\n\tstruct portman *pm = substream->rmidi->private_data;\n\tunsigned long flags;\n\tunsigned char byte;\n\n\tspin_lock_irqsave(&pm->reg_lock, flags);\n\tif (up) {\n\t\twhile ((snd_rawmidi_transmit(substream, &byte, 1) == 1))\n\t\t\tportman_write_midi(pm, substream->number, byte);\n\t}\n\tspin_unlock_irqrestore(&pm->reg_lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_portman_midi_output = {\n\t.open =\t\tsnd_portman_midi_open,\n\t.close =\tsnd_portman_midi_close,\n\t.trigger =\tsnd_portman_midi_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_portman_midi_input = {\n\t.open =\t\tsnd_portman_midi_open,\n\t.close =\tsnd_portman_midi_close,\n\t.trigger =\tsnd_portman_midi_input_trigger,\n};\n\n \nstatic int snd_portman_rawmidi_create(struct snd_card *card)\n{\n\tstruct portman *pm = card->private_data;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *substream;\n\tint err;\n\t\n\terr = snd_rawmidi_new(card, CARD_NAME, 0, \n\t\t\t      PORTMAN_NUM_OUTPUT_PORTS, \n\t\t\t      PORTMAN_NUM_INPUT_PORTS, \n\t\t\t      &rmidi);\n\tif (err < 0) \n\t\treturn err;\n\n\trmidi->private_data = pm;\n\tstrcpy(rmidi->name, CARD_NAME);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t            SNDRV_RAWMIDI_INFO_INPUT |\n                            SNDRV_RAWMIDI_INFO_DUPLEX;\n\n\tpm->rmidi = rmidi;\n\n\t \n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, \n\t\t\t    &snd_portman_midi_output);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, \n\t\t\t    &snd_portman_midi_input);\n\n\t \n\t \n\tlist_for_each_entry(substream,\n\t\t\t    &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,\n\t\t\t    list) {\n\t\tsprintf(substream->name,\n\t\t\t\"Portman2x4 %d\", substream->number+1);\n\t}\n\t \n\tlist_for_each_entry(substream,\n\t\t\t    &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,\n\t\t\t    list) {\n\t\tpm->midi_input[substream->number] = substream;\n\t\tsprintf(substream->name,\n\t\t\t\"Portman2x4 %d\", substream->number+1);\n\t}\n\n\treturn err;\n}\n\n \nstatic void snd_portman_interrupt(void *userdata)\n{\n\tunsigned char midivalue = 0;\n\tstruct portman *pm = ((struct snd_card*)userdata)->private_data;\n\n\tspin_lock(&pm->reg_lock);\n\n\t \n\twhile ((portman_read_status(pm) & INT_REQ) == INT_REQ) {\n\t\t \n\t\tif (portman_data_avail(pm, 0)) {\n\t\t\t \n\t\t\tmidivalue = portman_read_midi(pm, 0);\n\t\t\t \n\t\t\tif (pm->mode[0] & PORTMAN2X4_MODE_INPUT_TRIGGERED)\n\t\t\t\tsnd_rawmidi_receive(pm->midi_input[0],\n\t\t\t\t\t\t    &midivalue, 1);\n\n\t\t}\n\t\t \n\t\tif (portman_data_avail(pm, 1)) {\n\t\t\t \n\t\t\tmidivalue = portman_read_midi(pm, 1);\n\t\t\t \n\t\t\tif (pm->mode[1] & PORTMAN2X4_MODE_INPUT_TRIGGERED)\n\t\t\t\tsnd_rawmidi_receive(pm->midi_input[1],\n\t\t\t\t\t\t    &midivalue, 1);\n\t\t}\n\n\t}\n\n\tspin_unlock(&pm->reg_lock);\n}\n\nstatic void snd_portman_attach(struct parport *p)\n{\n\tstruct platform_device *device;\n\n\tdevice = platform_device_alloc(PLATFORM_DRIVER, device_count);\n\tif (!device)\n\t\treturn;\n\n\t \n\tplatform_set_drvdata(device, p);\n\n\tif (platform_device_add(device) < 0) {\n\t\tplatform_device_put(device);\n\t\treturn;\n\t}\n\n\t \n\tif (!platform_get_drvdata(device)) {\n\t\tplatform_device_unregister(device);\n\t\treturn;\n\t}\n\n\t \n\tplatform_devices[device_count] = device;\n\tdevice_count++;\n}\n\nstatic void snd_portman_detach(struct parport *p)\n{\n\t \n}\n\nstatic int snd_portman_dev_probe(struct pardevice *pardev)\n{\n\tif (strcmp(pardev->name, DRIVER_NAME))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver portman_parport_driver = {\n\t.name\t\t= \"portman2x4\",\n\t.probe\t\t= snd_portman_dev_probe,\n\t.match_port\t= snd_portman_attach,\n\t.detach\t\t= snd_portman_detach,\n\t.devmodel\t= true,\n};\n\n \nstatic void snd_portman_card_private_free(struct snd_card *card)\n{\n\tstruct portman *pm = card->private_data;\n\tstruct pardevice *pardev = pm->pardev;\n\n\tif (pardev) {\n\t\tparport_release(pardev);\n\t\tparport_unregister_device(pardev);\n\t}\n\n\tportman_free(pm);\n}\n\nstatic int snd_portman_probe(struct platform_device *pdev)\n{\n\tstruct pardevice *pardev;\n\tstruct parport *p;\n\tint dev = pdev->id;\n\tstruct snd_card *card = NULL;\n\tstruct portman *pm = NULL;\n\tint err;\n\tstruct pardev_cb portman_cb = {\n\t\t.preempt = NULL,\n\t\t.wakeup = NULL,\n\t\t.irq_func = snd_portman_interrupt,\t \n\t\t.flags = PARPORT_DEV_EXCL,\t\t \n\t};\n\n\tp = platform_get_drvdata(pdev);\n\tplatform_set_drvdata(pdev, NULL);\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) \n\t\treturn -ENOENT;\n\n\terr = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot create card\\n\");\n\t\treturn err;\n\t}\n\tstrcpy(card->driver, DRIVER_NAME);\n\tstrcpy(card->shortname, CARD_NAME);\n\tsprintf(card->longname,  \"%s at 0x%lx, irq %i\", \n\t\tcard->shortname, p->base, p->irq);\n\n\tportman_cb.private = card;\t\t\t    \n\tpardev = parport_register_dev_model(p,\t\t    \n\t\t\t\t\t    DRIVER_NAME,    \n\t\t\t\t\t    &portman_cb,    \n\t\t\t\t\t    pdev->id);\t    \n\tif (pardev == NULL) {\n\t\tsnd_printd(\"Cannot register pardevice\\n\");\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\n\t \n\tif (parport_claim(pardev)) {\n\t\tsnd_printd(\"Cannot claim parport 0x%lx\\n\", pardev->port->base);\n\t\terr = -EIO;\n\t\tgoto free_pardev;\n\t}\n\n\terr = portman_create(card, pardev, &pm);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot create main component\\n\");\n\t\tgoto release_pardev;\n\t}\n\tcard->private_data = pm;\n\tcard->private_free = snd_portman_card_private_free;\n\n\terr = portman_probe(p);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\t\n\terr = snd_portman_rawmidi_create(card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Creating Rawmidi component failed\\n\");\n\t\tgoto __err;\n\t}\n\n\t \n\terr = portman_device_init(pm);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tplatform_set_drvdata(pdev, card);\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot register card\\n\");\n\t\tgoto __err;\n\t}\n\n\tsnd_printk(KERN_INFO \"Portman 2x4 on 0x%lx\\n\", p->base);\n\treturn 0;\n\nrelease_pardev:\n\tparport_release(pardev);\nfree_pardev:\n\tparport_unregister_device(pardev);\n__err:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_portman_remove(struct platform_device *pdev)\n{\n\tstruct snd_card *card = platform_get_drvdata(pdev);\n\n\tif (card)\n\t\tsnd_card_free(card);\n}\n\n\nstatic struct platform_driver snd_portman_driver = {\n\t.probe  = snd_portman_probe,\n\t.remove_new = snd_portman_remove,\n\t.driver = {\n\t\t.name = PLATFORM_DRIVER,\n\t}\n};\n\n \nstatic void snd_portman_unregister_all(void)\n{\n\tint i;\n\n\tfor (i = 0; i < SNDRV_CARDS; ++i) {\n\t\tif (platform_devices[i]) {\n\t\t\tplatform_device_unregister(platform_devices[i]);\n\t\t\tplatform_devices[i] = NULL;\n\t\t}\n\t}\t\t\n\tplatform_driver_unregister(&snd_portman_driver);\n\tparport_unregister_driver(&portman_parport_driver);\n}\n\nstatic int __init snd_portman_module_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&snd_portman_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (parport_register_driver(&portman_parport_driver) != 0) {\n\t\tplatform_driver_unregister(&snd_portman_driver);\n\t\treturn -EIO;\n\t}\n\n\tif (device_count == 0) {\n\t\tsnd_portman_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit snd_portman_module_exit(void)\n{\n\tsnd_portman_unregister_all();\n}\n\nmodule_init(snd_portman_module_init);\nmodule_exit(snd_portman_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}