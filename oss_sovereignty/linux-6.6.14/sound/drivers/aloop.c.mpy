{
  "module_name": "aloop.c",
  "hash_id": "899758e5d5a45444580cec82c86b126222773d8184714545f15c7a8cfd3bff57",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/aloop.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n#include <sound/timer.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"A loopback soundcard\");\nMODULE_LICENSE(\"GPL\");\n\n#define MAX_PCM_SUBSTREAMS\t8\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};\nstatic int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};\nstatic int pcm_notify[SNDRV_CARDS];\nstatic char *timer_source[SNDRV_CARDS];\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for loopback soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for loopback soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable this loopback soundcard.\");\nmodule_param_array(pcm_substreams, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_substreams, \"PCM substreams # (1-8) for loopback driver.\");\nmodule_param_array(pcm_notify, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_notify, \"Break capture when PCM format/rate/channels changes.\");\nmodule_param_array(timer_source, charp, NULL, 0444);\nMODULE_PARM_DESC(timer_source, \"Sound card name or number and device/subdevice number of timer to be used. Empty string for jiffies timer [default].\");\n\n#define NO_PITCH 100000\n\n#define CABLE_VALID_PLAYBACK\tBIT(SNDRV_PCM_STREAM_PLAYBACK)\n#define CABLE_VALID_CAPTURE\tBIT(SNDRV_PCM_STREAM_CAPTURE)\n#define CABLE_VALID_BOTH\t(CABLE_VALID_PLAYBACK | CABLE_VALID_CAPTURE)\n\nstruct loopback_cable;\nstruct loopback_pcm;\n\nstruct loopback_ops {\n\t \n\tint (*open)(struct loopback_pcm *dpcm);\n\t \n\tint (*start)(struct loopback_pcm *dpcm);\n\t \n\tint (*stop)(struct loopback_pcm *dpcm);\n\t \n\tint (*stop_sync)(struct loopback_pcm *dpcm);\n\t \n\tint (*close_substream)(struct loopback_pcm *dpcm);\n\t \n\tint (*close_cable)(struct loopback_pcm *dpcm);\n\t \n\tunsigned int (*pos_update)(struct loopback_cable *cable);\n\t \n\tvoid (*dpcm_info)(struct loopback_pcm *dpcm,\n\t\t\t  struct snd_info_buffer *buffer);\n};\n\nstruct loopback_cable {\n\tspinlock_t lock;\n\tstruct loopback_pcm *streams[2];\n\tstruct snd_pcm_hardware hw;\n\t \n\tunsigned int valid;\n\tunsigned int running;\n\tunsigned int pause;\n\t \n\tconst struct loopback_ops *ops;\n\t \n\tstruct {\n\t\tint stream;\n\t\tstruct snd_timer_id id;\n\t\tstruct work_struct event_work;\n\t\tstruct snd_timer_instance *instance;\n\t} snd_timer;\n};\n\nstruct loopback_setup {\n\tunsigned int notify: 1;\n\tunsigned int rate_shift;\n\tsnd_pcm_format_t format;\n\tunsigned int rate;\n\tunsigned int channels;\n\tstruct snd_ctl_elem_id active_id;\n\tstruct snd_ctl_elem_id format_id;\n\tstruct snd_ctl_elem_id rate_id;\n\tstruct snd_ctl_elem_id channels_id;\n};\n\nstruct loopback {\n\tstruct snd_card *card;\n\tstruct mutex cable_lock;\n\tstruct loopback_cable *cables[MAX_PCM_SUBSTREAMS][2];\n\tstruct snd_pcm *pcm[2];\n\tstruct loopback_setup setup[MAX_PCM_SUBSTREAMS][2];\n\tconst char *timer_source;\n};\n\nstruct loopback_pcm {\n\tstruct loopback *loopback;\n\tstruct snd_pcm_substream *substream;\n\tstruct loopback_cable *cable;\n\tunsigned int pcm_buffer_size;\n\tunsigned int buf_pos;\t \n\tunsigned int silent_size;\n\t \n\tunsigned int pcm_period_size;\n\tunsigned int pcm_bps;\t\t \n\tunsigned int pcm_salign;\t \n\tunsigned int pcm_rate_shift;\t \n\t \n\tunsigned int period_update_pending :1;\n\t \n\tunsigned int irq_pos;\t\t \n\tunsigned int period_size_frac;\t \n\tunsigned int last_drift;\n\tunsigned long last_jiffies;\n\t \n\tstruct timer_list timer;\n};\n\nstatic struct platform_device *devices[SNDRV_CARDS];\n\nstatic inline unsigned int byte_pos(struct loopback_pcm *dpcm, unsigned int x)\n{\n\tif (dpcm->pcm_rate_shift == NO_PITCH) {\n\t\tx /= HZ;\n\t} else {\n\t\tx = div_u64(NO_PITCH * (unsigned long long)x,\n\t\t\t    HZ * (unsigned long long)dpcm->pcm_rate_shift);\n\t}\n\treturn x - (x % dpcm->pcm_salign);\n}\n\nstatic inline unsigned int frac_pos(struct loopback_pcm *dpcm, unsigned int x)\n{\n\tif (dpcm->pcm_rate_shift == NO_PITCH) {\t \n\t\treturn x * HZ;\n\t} else {\n\t\tx = div_u64(dpcm->pcm_rate_shift * (unsigned long long)x * HZ,\n\t\t\t    NO_PITCH);\n\t}\n\treturn x;\n}\n\nstatic inline struct loopback_setup *get_setup(struct loopback_pcm *dpcm)\n{\n\tint device = dpcm->substream->pstr->pcm->device;\n\t\n\tif (dpcm->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdevice ^= 1;\n\treturn &dpcm->loopback->setup[dpcm->substream->number][device];\n}\n\nstatic inline unsigned int get_notify(struct loopback_pcm *dpcm)\n{\n\treturn get_setup(dpcm)->notify;\n}\n\nstatic inline unsigned int get_rate_shift(struct loopback_pcm *dpcm)\n{\n\treturn get_setup(dpcm)->rate_shift;\n}\n\n \nstatic int loopback_jiffies_timer_start(struct loopback_pcm *dpcm)\n{\n\tunsigned long tick;\n\tunsigned int rate_shift = get_rate_shift(dpcm);\n\n\tif (rate_shift != dpcm->pcm_rate_shift) {\n\t\tdpcm->pcm_rate_shift = rate_shift;\n\t\tdpcm->period_size_frac = frac_pos(dpcm, dpcm->pcm_period_size);\n\t}\n\tif (dpcm->period_size_frac <= dpcm->irq_pos) {\n\t\tdpcm->irq_pos %= dpcm->period_size_frac;\n\t\tdpcm->period_update_pending = 1;\n\t}\n\ttick = dpcm->period_size_frac - dpcm->irq_pos;\n\ttick = DIV_ROUND_UP(tick, dpcm->pcm_bps);\n\tmod_timer(&dpcm->timer, jiffies + tick);\n\n\treturn 0;\n}\n\n \nstatic int loopback_snd_timer_start(struct loopback_pcm *dpcm)\n{\n\tstruct loopback_cable *cable = dpcm->cable;\n\tint err;\n\n\t \n\terr = snd_timer_start(cable->snd_timer.instance, 1);\n\tif (err < 0) {\n\t\t \n\t\tif (err == -EBUSY)\n\t\t\treturn 0;\n\n\t\tpcm_err(dpcm->substream->pcm,\n\t\t\t\"snd_timer_start(%d,%d,%d) failed with %d\",\n\t\t\tcable->snd_timer.id.card,\n\t\t\tcable->snd_timer.id.device,\n\t\t\tcable->snd_timer.id.subdevice,\n\t\t\terr);\n\t}\n\n\treturn err;\n}\n\n \nstatic inline int loopback_jiffies_timer_stop(struct loopback_pcm *dpcm)\n{\n\tdel_timer(&dpcm->timer);\n\tdpcm->timer.expires = 0;\n\n\treturn 0;\n}\n\n \nstatic int loopback_snd_timer_stop(struct loopback_pcm *dpcm)\n{\n\tstruct loopback_cable *cable = dpcm->cable;\n\tint err;\n\n\t \n\tif (cable->running ^ cable->pause)\n\t\treturn 0;\n\n\terr = snd_timer_stop(cable->snd_timer.instance);\n\tif (err < 0) {\n\t\tpcm_err(dpcm->substream->pcm,\n\t\t\t\"snd_timer_stop(%d,%d,%d) failed with %d\",\n\t\t\tcable->snd_timer.id.card,\n\t\t\tcable->snd_timer.id.device,\n\t\t\tcable->snd_timer.id.subdevice,\n\t\t\terr);\n\t}\n\n\treturn err;\n}\n\nstatic inline int loopback_jiffies_timer_stop_sync(struct loopback_pcm *dpcm)\n{\n\tdel_timer_sync(&dpcm->timer);\n\n\treturn 0;\n}\n\n \nstatic int loopback_snd_timer_close_cable(struct loopback_pcm *dpcm)\n{\n\tstruct loopback_cable *cable = dpcm->cable;\n\n\t \n\tif (!cable->snd_timer.instance)\n\t\treturn 0;\n\n\t \n\tsnd_timer_close(cable->snd_timer.instance);\n\n\t \n\tcancel_work_sync(&cable->snd_timer.event_work);\n\n\tsnd_timer_instance_free(cable->snd_timer.instance);\n\tmemset(&cable->snd_timer, 0, sizeof(cable->snd_timer));\n\n\treturn 0;\n}\n\nstatic int loopback_check_format(struct loopback_cable *cable, int stream)\n{\n\tstruct snd_pcm_runtime *runtime, *cruntime;\n\tstruct loopback_setup *setup;\n\tstruct snd_card *card;\n\tint check;\n\n\tif (cable->valid != CABLE_VALID_BOTH) {\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tgoto __notify;\n\t\treturn 0;\n\t}\n\truntime = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->\n\t\t\t\t\t\t\tsubstream->runtime;\n\tcruntime = cable->streams[SNDRV_PCM_STREAM_CAPTURE]->\n\t\t\t\t\t\t\tsubstream->runtime;\n\tcheck = runtime->format != cruntime->format ||\n\t\truntime->rate != cruntime->rate ||\n\t\truntime->channels != cruntime->channels;\n\tif (!check)\n\t\treturn 0;\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\treturn -EIO;\n\t} else {\n\t\tsnd_pcm_stop(cable->streams[SNDRV_PCM_STREAM_CAPTURE]->\n\t\t\t\t\tsubstream, SNDRV_PCM_STATE_DRAINING);\n\t      __notify:\n\t\truntime = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->\n\t\t\t\t\t\t\tsubstream->runtime;\n\t\tsetup = get_setup(cable->streams[SNDRV_PCM_STREAM_PLAYBACK]);\n\t\tcard = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->loopback->card;\n\t\tif (setup->format != runtime->format) {\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t\t\t&setup->format_id);\n\t\t\tsetup->format = runtime->format;\n\t\t}\n\t\tif (setup->rate != runtime->rate) {\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t\t\t&setup->rate_id);\n\t\t\tsetup->rate = runtime->rate;\n\t\t}\n\t\tif (setup->channels != runtime->channels) {\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\t\t\t&setup->channels_id);\n\t\t\tsetup->channels = runtime->channels;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void loopback_active_notify(struct loopback_pcm *dpcm)\n{\n\tsnd_ctl_notify(dpcm->loopback->card,\n\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t       &get_setup(dpcm)->active_id);\n}\n\nstatic int loopback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tint err = 0, stream = 1 << substream->stream;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\terr = loopback_check_format(cable, substream->stream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdpcm->last_jiffies = jiffies;\n\t\tdpcm->pcm_rate_shift = 0;\n\t\tdpcm->last_drift = 0;\n\t\tspin_lock(&cable->lock);\t\n\t\tcable->running |= stream;\n\t\tcable->pause &= ~stream;\n\t\terr = cable->ops->start(dpcm);\n\t\tspin_unlock(&cable->lock);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tloopback_active_notify(dpcm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tspin_lock(&cable->lock);\t\n\t\tcable->running &= ~stream;\n\t\tcable->pause &= ~stream;\n\t\terr = cable->ops->stop(dpcm);\n\t\tspin_unlock(&cable->lock);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tloopback_active_notify(dpcm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tspin_lock(&cable->lock);\t\n\t\tcable->pause |= stream;\n\t\terr = cable->ops->stop(dpcm);\n\t\tspin_unlock(&cable->lock);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tloopback_active_notify(dpcm);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tspin_lock(&cable->lock);\n\t\tdpcm->last_jiffies = jiffies;\n\t\tcable->pause &= ~stream;\n\t\terr = cable->ops->start(dpcm);\n\t\tspin_unlock(&cable->lock);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tloopback_active_notify(dpcm);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic void params_change(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tstruct loopback_cable *cable = dpcm->cable;\n\n\tcable->hw.formats = pcm_format_to_bits(runtime->format);\n\tcable->hw.rate_min = runtime->rate;\n\tcable->hw.rate_max = runtime->rate;\n\tcable->hw.channels_min = runtime->channels;\n\tcable->hw.channels_max = runtime->channels;\n\n\tif (cable->snd_timer.instance) {\n\t\tcable->hw.period_bytes_min =\n\t\t\t\tframes_to_bytes(runtime, runtime->period_size);\n\t\tcable->hw.period_bytes_max = cable->hw.period_bytes_min;\n\t}\n\n}\n\nstatic int loopback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tint err, bps, salign;\n\n\tif (cable->ops->stop_sync) {\n\t\terr = cable->ops->stop_sync(dpcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tsalign = (snd_pcm_format_physical_width(runtime->format) *\n\t\t\t\t\t\truntime->channels) / 8;\n\tbps = salign * runtime->rate;\n\tif (bps <= 0 || salign <= 0)\n\t\treturn -EINVAL;\n\n\tdpcm->buf_pos = 0;\n\tdpcm->pcm_buffer_size = frames_to_bytes(runtime, runtime->buffer_size);\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t \n\t\tdpcm->silent_size = dpcm->pcm_buffer_size;\n\t\tsnd_pcm_format_set_silence(runtime->format, runtime->dma_area,\n\t\t\t\t\t   runtime->buffer_size * runtime->channels);\n\t}\n\n\tdpcm->irq_pos = 0;\n\tdpcm->period_update_pending = 0;\n\tdpcm->pcm_bps = bps;\n\tdpcm->pcm_salign = salign;\n\tdpcm->pcm_period_size = frames_to_bytes(runtime, runtime->period_size);\n\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tif (!(cable->valid & ~(1 << substream->stream)) ||\n            (get_setup(dpcm)->notify &&\n\t     substream->stream == SNDRV_PCM_STREAM_PLAYBACK))\n\t\tparams_change(substream);\n\tcable->valid |= 1 << substream->stream;\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n\n\treturn 0;\n}\n\nstatic void clear_capture_buf(struct loopback_pcm *dpcm, unsigned int bytes)\n{\n\tstruct snd_pcm_runtime *runtime = dpcm->substream->runtime;\n\tchar *dst = runtime->dma_area;\n\tunsigned int dst_off = dpcm->buf_pos;\n\n\tif (dpcm->silent_size >= dpcm->pcm_buffer_size)\n\t\treturn;\n\tif (dpcm->silent_size + bytes > dpcm->pcm_buffer_size)\n\t\tbytes = dpcm->pcm_buffer_size - dpcm->silent_size;\n\n\tfor (;;) {\n\t\tunsigned int size = bytes;\n\t\tif (dst_off + size > dpcm->pcm_buffer_size)\n\t\t\tsize = dpcm->pcm_buffer_size - dst_off;\n\t\tsnd_pcm_format_set_silence(runtime->format, dst + dst_off,\n\t\t\t\t\t   bytes_to_frames(runtime, size) *\n\t\t\t\t\t   \truntime->channels);\n\t\tdpcm->silent_size += size;\n\t\tbytes -= size;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tdst_off = 0;\n\t}\n}\n\nstatic void copy_play_buf(struct loopback_pcm *play,\n\t\t\t  struct loopback_pcm *capt,\n\t\t\t  unsigned int bytes)\n{\n\tstruct snd_pcm_runtime *runtime = play->substream->runtime;\n\tchar *src = runtime->dma_area;\n\tchar *dst = capt->substream->runtime->dma_area;\n\tunsigned int src_off = play->buf_pos;\n\tunsigned int dst_off = capt->buf_pos;\n\tunsigned int clear_bytes = 0;\n\n\t \n\tif (runtime->state == SNDRV_PCM_STATE_DRAINING &&\n\t    snd_pcm_playback_hw_avail(runtime) < runtime->buffer_size) { \n\t    \tsnd_pcm_uframes_t appl_ptr, appl_ptr1, diff;\n\t\tappl_ptr = appl_ptr1 = runtime->control->appl_ptr;\n\t\tappl_ptr1 -= appl_ptr1 % runtime->buffer_size;\n\t\tappl_ptr1 += play->buf_pos / play->pcm_salign;\n\t\tif (appl_ptr < appl_ptr1)\n\t\t\tappl_ptr1 -= runtime->buffer_size;\n\t\tdiff = (appl_ptr - appl_ptr1) * play->pcm_salign;\n\t\tif (diff < bytes) {\n\t\t\tclear_bytes = bytes - diff;\n\t\t\tbytes = diff;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tunsigned int size = bytes;\n\t\tif (src_off + size > play->pcm_buffer_size)\n\t\t\tsize = play->pcm_buffer_size - src_off;\n\t\tif (dst_off + size > capt->pcm_buffer_size)\n\t\t\tsize = capt->pcm_buffer_size - dst_off;\n\t\tmemcpy(dst + dst_off, src + src_off, size);\n\t\tcapt->silent_size = 0;\n\t\tbytes -= size;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tsrc_off = (src_off + size) % play->pcm_buffer_size;\n\t\tdst_off = (dst_off + size) % capt->pcm_buffer_size;\n\t}\n\n\tif (clear_bytes > 0) {\n\t\tclear_capture_buf(capt, clear_bytes);\n\t\tcapt->silent_size = 0;\n\t}\n}\n\nstatic inline unsigned int bytepos_delta(struct loopback_pcm *dpcm,\n\t\t\t\t\t unsigned int jiffies_delta)\n{\n\tunsigned long last_pos;\n\tunsigned int delta;\n\n\tlast_pos = byte_pos(dpcm, dpcm->irq_pos);\n\tdpcm->irq_pos += jiffies_delta * dpcm->pcm_bps;\n\tdelta = byte_pos(dpcm, dpcm->irq_pos) - last_pos;\n\tif (delta >= dpcm->last_drift)\n\t\tdelta -= dpcm->last_drift;\n\tdpcm->last_drift = 0;\n\tif (dpcm->irq_pos >= dpcm->period_size_frac) {\n\t\tdpcm->irq_pos %= dpcm->period_size_frac;\n\t\tdpcm->period_update_pending = 1;\n\t}\n\treturn delta;\n}\n\nstatic inline void bytepos_finish(struct loopback_pcm *dpcm,\n\t\t\t\t  unsigned int delta)\n{\n\tdpcm->buf_pos += delta;\n\tdpcm->buf_pos %= dpcm->pcm_buffer_size;\n}\n\n \nstatic unsigned int loopback_jiffies_timer_pos_update\n\t\t(struct loopback_cable *cable)\n{\n\tstruct loopback_pcm *dpcm_play =\n\t\t\tcable->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tstruct loopback_pcm *dpcm_capt =\n\t\t\tcable->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tunsigned long delta_play = 0, delta_capt = 0, cur_jiffies;\n\tunsigned int running, count1, count2;\n\n\tcur_jiffies = jiffies;\n\trunning = cable->running ^ cable->pause;\n\tif (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) {\n\t\tdelta_play = cur_jiffies - dpcm_play->last_jiffies;\n\t\tdpcm_play->last_jiffies += delta_play;\n\t}\n\n\tif (running & (1 << SNDRV_PCM_STREAM_CAPTURE)) {\n\t\tdelta_capt = cur_jiffies - dpcm_capt->last_jiffies;\n\t\tdpcm_capt->last_jiffies += delta_capt;\n\t}\n\n\tif (delta_play == 0 && delta_capt == 0)\n\t\tgoto unlock;\n\t\t\n\tif (delta_play > delta_capt) {\n\t\tcount1 = bytepos_delta(dpcm_play, delta_play - delta_capt);\n\t\tbytepos_finish(dpcm_play, count1);\n\t\tdelta_play = delta_capt;\n\t} else if (delta_play < delta_capt) {\n\t\tcount1 = bytepos_delta(dpcm_capt, delta_capt - delta_play);\n\t\tclear_capture_buf(dpcm_capt, count1);\n\t\tbytepos_finish(dpcm_capt, count1);\n\t\tdelta_capt = delta_play;\n\t}\n\n\tif (delta_play == 0 && delta_capt == 0)\n\t\tgoto unlock;\n\n\t \n\tcount1 = bytepos_delta(dpcm_play, delta_play);\n\tcount2 = bytepos_delta(dpcm_capt, delta_capt);\n\tif (count1 < count2) {\n\t\tdpcm_capt->last_drift = count2 - count1;\n\t\tcount1 = count2;\n\t} else if (count1 > count2) {\n\t\tdpcm_play->last_drift = count1 - count2;\n\t}\n\tcopy_play_buf(dpcm_play, dpcm_capt, count1);\n\tbytepos_finish(dpcm_play, count1);\n\tbytepos_finish(dpcm_capt, count1);\n unlock:\n\treturn running;\n}\n\nstatic void loopback_jiffies_timer_function(struct timer_list *t)\n{\n\tstruct loopback_pcm *dpcm = from_timer(dpcm, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dpcm->cable->lock, flags);\n\tif (loopback_jiffies_timer_pos_update(dpcm->cable) &\n\t\t\t(1 << dpcm->substream->stream)) {\n\t\tloopback_jiffies_timer_start(dpcm);\n\t\tif (dpcm->period_update_pending) {\n\t\t\tdpcm->period_update_pending = 0;\n\t\t\tspin_unlock_irqrestore(&dpcm->cable->lock, flags);\n\t\t\t \n\t\t\tsnd_pcm_period_elapsed(dpcm->substream);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dpcm->cable->lock, flags);\n}\n\n \nstatic int loopback_snd_timer_check_resolution(struct snd_pcm_runtime *runtime,\n\t\t\t\t\t       unsigned long resolution)\n{\n\tif (resolution != runtime->timer_resolution) {\n\t\tstruct loopback_pcm *dpcm = runtime->private_data;\n\t\tstruct loopback_cable *cable = dpcm->cable;\n\t\t \n\t\tsnd_pcm_uframes_t period_size_usec =\n\t\t\t\tresolution / 1000 * runtime->rate;\n\t\t \n\t\tsnd_pcm_uframes_t period_size =\n\t\t\t\t(period_size_usec + 500 * 1000) / (1000 * 1000);\n\n\t\tpcm_err(dpcm->substream->pcm,\n\t\t\t\"Period size (%lu frames) of loopback device is not corresponding to timer resolution (%lu nsec = %lu frames) of card timer %d,%d,%d. Use period size of %lu frames for loopback device.\",\n\t\t\truntime->period_size, resolution, period_size,\n\t\t\tcable->snd_timer.id.card,\n\t\t\tcable->snd_timer.id.device,\n\t\t\tcable->snd_timer.id.subdevice,\n\t\t\tperiod_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void loopback_snd_timer_period_elapsed(struct loopback_cable *cable,\n\t\t\t\t\t      int event,\n\t\t\t\t\t      unsigned long resolution)\n{\n\tstruct loopback_pcm *dpcm_play, *dpcm_capt;\n\tstruct snd_pcm_substream *substream_play, *substream_capt;\n\tstruct snd_pcm_runtime *valid_runtime;\n\tunsigned int running, elapsed_bytes;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cable->lock, flags);\n\trunning = cable->running ^ cable->pause;\n\t \n\tif (!running) {\n\t\tspin_unlock_irqrestore(&cable->lock, flags);\n\t\treturn;\n\t}\n\n\tdpcm_play = cable->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tdpcm_capt = cable->streams[SNDRV_PCM_STREAM_CAPTURE];\n\n\tif (event == SNDRV_TIMER_EVENT_MSTOP) {\n\t\tif (!dpcm_play ||\n\t\t    dpcm_play->substream->runtime->state !=\n\t\t\t\tSNDRV_PCM_STATE_DRAINING) {\n\t\t\tspin_unlock_irqrestore(&cable->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsubstream_play = (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) ?\n\t\t\tdpcm_play->substream : NULL;\n\tsubstream_capt = (running & (1 << SNDRV_PCM_STREAM_CAPTURE)) ?\n\t\t\tdpcm_capt->substream : NULL;\n\tvalid_runtime = (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) ?\n\t\t\t\tdpcm_play->substream->runtime :\n\t\t\t\tdpcm_capt->substream->runtime;\n\n\t \n\tif (event == SNDRV_TIMER_EVENT_TICK) {\n\t\t \n\t\tif (loopback_snd_timer_check_resolution(valid_runtime,\n\t\t\t\t\t\t\tresolution) < 0) {\n\t\t\tspin_unlock_irqrestore(&cable->lock, flags);\n\t\t\tif (substream_play)\n\t\t\t\tsnd_pcm_stop_xrun(substream_play);\n\t\t\tif (substream_capt)\n\t\t\t\tsnd_pcm_stop_xrun(substream_capt);\n\t\t\treturn;\n\t\t}\n\t}\n\n\telapsed_bytes = frames_to_bytes(valid_runtime,\n\t\t\t\t\tvalid_runtime->period_size);\n\t \n\tif ((running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&\n\t    (running & (1 << SNDRV_PCM_STREAM_CAPTURE))) {\n\t\tcopy_play_buf(dpcm_play, dpcm_capt, elapsed_bytes);\n\t\tbytepos_finish(dpcm_play, elapsed_bytes);\n\t\tbytepos_finish(dpcm_capt, elapsed_bytes);\n\t} else if (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) {\n\t\tbytepos_finish(dpcm_play, elapsed_bytes);\n\t} else if (running & (1 << SNDRV_PCM_STREAM_CAPTURE)) {\n\t\tclear_capture_buf(dpcm_capt, elapsed_bytes);\n\t\tbytepos_finish(dpcm_capt, elapsed_bytes);\n\t}\n\tspin_unlock_irqrestore(&cable->lock, flags);\n\n\tif (substream_play)\n\t\tsnd_pcm_period_elapsed(substream_play);\n\tif (substream_capt)\n\t\tsnd_pcm_period_elapsed(substream_capt);\n}\n\nstatic void loopback_snd_timer_function(struct snd_timer_instance *timeri,\n\t\t\t\t\tunsigned long resolution,\n\t\t\t\t\tunsigned long ticks)\n{\n\tstruct loopback_cable *cable = timeri->callback_data;\n\n\tloopback_snd_timer_period_elapsed(cable, SNDRV_TIMER_EVENT_TICK,\n\t\t\t\t\t  resolution);\n}\n\nstatic void loopback_snd_timer_work(struct work_struct *work)\n{\n\tstruct loopback_cable *cable;\n\n\tcable = container_of(work, struct loopback_cable, snd_timer.event_work);\n\tloopback_snd_timer_period_elapsed(cable, SNDRV_TIMER_EVENT_MSTOP, 0);\n}\n\nstatic void loopback_snd_timer_event(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec64 *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\t \n\n\tif (event == SNDRV_TIMER_EVENT_MSTOP) {\n\t\tstruct loopback_cable *cable = timeri->callback_data;\n\n\t\t \n\t\tschedule_work(&cable->snd_timer.event_work);\n\t}\n}\n\nstatic void loopback_jiffies_timer_dpcm_info(struct loopback_pcm *dpcm,\n\t\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tsnd_iprintf(buffer, \"    update_pending:\\t%u\\n\",\n\t\t    dpcm->period_update_pending);\n\tsnd_iprintf(buffer, \"    irq_pos:\\t\\t%u\\n\", dpcm->irq_pos);\n\tsnd_iprintf(buffer, \"    period_frac:\\t%u\\n\", dpcm->period_size_frac);\n\tsnd_iprintf(buffer, \"    last_jiffies:\\t%lu (%lu)\\n\",\n\t\t    dpcm->last_jiffies, jiffies);\n\tsnd_iprintf(buffer, \"    timer_expires:\\t%lu\\n\", dpcm->timer.expires);\n}\n\nstatic void loopback_snd_timer_dpcm_info(struct loopback_pcm *dpcm,\n\t\t\t\t\t struct snd_info_buffer *buffer)\n{\n\tstruct loopback_cable *cable = dpcm->cable;\n\n\tsnd_iprintf(buffer, \"    sound timer:\\thw:%d,%d,%d\\n\",\n\t\t    cable->snd_timer.id.card,\n\t\t    cable->snd_timer.id.device,\n\t\t    cable->snd_timer.id.subdevice);\n\tsnd_iprintf(buffer, \"    timer open:\\t\\t%s\\n\",\n\t\t    (cable->snd_timer.stream == SNDRV_PCM_STREAM_CAPTURE) ?\n\t\t\t    \"capture\" : \"playback\");\n}\n\nstatic snd_pcm_uframes_t loopback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tsnd_pcm_uframes_t pos;\n\n\tspin_lock(&dpcm->cable->lock);\n\tif (dpcm->cable->ops->pos_update)\n\t\tdpcm->cable->ops->pos_update(dpcm->cable);\n\tpos = dpcm->buf_pos;\n\tspin_unlock(&dpcm->cable->lock);\n\treturn bytes_to_frames(runtime, pos);\n}\n\nstatic const struct snd_pcm_hardware loopback_pcm_hardware =\n{\n\t.info =\t\t(SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP |\n\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE |\n\t\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats =\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE |\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE |\n\t\t\t SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE),\n\t.rates =\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_192000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t192000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t32,\n\t.buffer_bytes_max =\t2 * 1024 * 1024,\n\t.period_bytes_min =\t64,\n\t \n\t.period_bytes_max =\t1024 * 1024,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n\t.fifo_size =\t\t0,\n};\n\nstatic void loopback_runtime_free(struct snd_pcm_runtime *runtime)\n{\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tkfree(dpcm);\n}\n\nstatic int loopback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback_pcm *dpcm = runtime->private_data;\n\tstruct loopback_cable *cable = dpcm->cable;\n\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tcable->valid &= ~(1 << substream->stream);\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n\treturn 0;\n}\n\nstatic unsigned int get_cable_index(struct snd_pcm_substream *substream)\n{\n\tif (!substream->pcm->device)\n\t\treturn substream->stream;\n\telse\n\t\treturn !substream->stream;\n}\n\nstatic int rule_format(struct snd_pcm_hw_params *params,\n\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct loopback_pcm *dpcm = rule->private;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tstruct snd_mask m;\n\n\tsnd_mask_none(&m);\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tm.bits[0] = (u_int32_t)cable->hw.formats;\n\tm.bits[1] = (u_int32_t)(cable->hw.formats >> 32);\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n\treturn snd_mask_refine(hw_param_mask(params, rule->var), &m);\n}\n\nstatic int rule_rate(struct snd_pcm_hw_params *params,\n\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct loopback_pcm *dpcm = rule->private;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tstruct snd_interval t;\n\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tt.min = cable->hw.rate_min;\n\tt.max = cable->hw.rate_max;\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n        t.openmin = t.openmax = 0;\n        t.integer = 0;\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t struct snd_pcm_hw_rule *rule)\n{\n\tstruct loopback_pcm *dpcm = rule->private;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tstruct snd_interval t;\n\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tt.min = cable->hw.channels_min;\n\tt.max = cable->hw.channels_max;\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n        t.openmin = t.openmax = 0;\n        t.integer = 0;\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic int rule_period_bytes(struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct loopback_pcm *dpcm = rule->private;\n\tstruct loopback_cable *cable = dpcm->cable;\n\tstruct snd_interval t;\n\n\tmutex_lock(&dpcm->loopback->cable_lock);\n\tt.min = cable->hw.period_bytes_min;\n\tt.max = cable->hw.period_bytes_max;\n\tmutex_unlock(&dpcm->loopback->cable_lock);\n\tt.openmin = 0;\n\tt.openmax = 0;\n\tt.integer = 0;\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nstatic void free_cable(struct snd_pcm_substream *substream)\n{\n\tstruct loopback *loopback = substream->private_data;\n\tint dev = get_cable_index(substream);\n\tstruct loopback_cable *cable;\n\n\tcable = loopback->cables[substream->number][dev];\n\tif (!cable)\n\t\treturn;\n\tif (cable->streams[!substream->stream]) {\n\t\t \n\t\tspin_lock_irq(&cable->lock);\n\t\tcable->streams[substream->stream] = NULL;\n\t\tspin_unlock_irq(&cable->lock);\n\t} else {\n\t\tstruct loopback_pcm *dpcm = substream->runtime->private_data;\n\n\t\tif (cable->ops && cable->ops->close_cable && dpcm)\n\t\t\tcable->ops->close_cable(dpcm);\n\t\t \n\t\tloopback->cables[substream->number][dev] = NULL;\n\t\tkfree(cable);\n\t}\n}\n\nstatic int loopback_jiffies_timer_open(struct loopback_pcm *dpcm)\n{\n\ttimer_setup(&dpcm->timer, loopback_jiffies_timer_function, 0);\n\n\treturn 0;\n}\n\nstatic const struct loopback_ops loopback_jiffies_timer_ops = {\n\t.open = loopback_jiffies_timer_open,\n\t.start = loopback_jiffies_timer_start,\n\t.stop = loopback_jiffies_timer_stop,\n\t.stop_sync = loopback_jiffies_timer_stop_sync,\n\t.close_substream = loopback_jiffies_timer_stop_sync,\n\t.pos_update = loopback_jiffies_timer_pos_update,\n\t.dpcm_info = loopback_jiffies_timer_dpcm_info,\n};\n\nstatic int loopback_parse_timer_id(const char *str,\n\t\t\t\t   struct snd_timer_id *tid)\n{\n\t \n\tconst char * const sep_dev = \".,\";\n\tconst char * const sep_pref = \":\";\n\tconst char *name = str;\n\tchar *sep, save = '\\0';\n\tint card_idx = 0, dev = 0, subdev = 0;\n\tint err;\n\n\tsep = strpbrk(str, sep_pref);\n\tif (sep)\n\t\tname = sep + 1;\n\tsep = strpbrk(name, sep_dev);\n\tif (sep) {\n\t\tsave = *sep;\n\t\t*sep = '\\0';\n\t}\n\terr = kstrtoint(name, 0, &card_idx);\n\tif (err == -EINVAL) {\n\t\t \n\t\tfor (card_idx = 0; card_idx < snd_ecards_limit; card_idx++) {\n\t\t\tstruct snd_card *card = snd_card_ref(card_idx);\n\n\t\t\tif (card) {\n\t\t\t\tif (!strcmp(card->id, name))\n\t\t\t\t\terr = 0;\n\t\t\t\tsnd_card_unref(card);\n\t\t\t}\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (sep) {\n\t\t*sep = save;\n\t\tif (!err) {\n\t\t\tchar *sep2, save2 = '\\0';\n\n\t\t\tsep2 = strpbrk(sep + 1, sep_dev);\n\t\t\tif (sep2) {\n\t\t\t\tsave2 = *sep2;\n\t\t\t\t*sep2 = '\\0';\n\t\t\t}\n\t\t\terr = kstrtoint(sep + 1, 0, &dev);\n\t\t\tif (sep2) {\n\t\t\t\t*sep2 = save2;\n\t\t\t\tif (!err)\n\t\t\t\t\terr = kstrtoint(sep2 + 1, 0, &subdev);\n\t\t\t}\n\t\t}\n\t}\n\tif (!err && tid) {\n\t\ttid->card = card_idx;\n\t\ttid->device = dev;\n\t\ttid->subdevice = subdev;\n\t}\n\treturn err;\n}\n\n \nstatic int loopback_snd_timer_open(struct loopback_pcm *dpcm)\n{\n\tint err = 0;\n\tstruct snd_timer_id tid = {\n\t\t.dev_class = SNDRV_TIMER_CLASS_PCM,\n\t\t.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION,\n\t};\n\tstruct snd_timer_instance *timeri;\n\tstruct loopback_cable *cable = dpcm->cable;\n\n\t \n\tif (cable->snd_timer.instance)\n\t\tgoto exit;\n\n\terr = loopback_parse_timer_id(dpcm->loopback->timer_source, &tid);\n\tif (err < 0) {\n\t\tpcm_err(dpcm->substream->pcm,\n\t\t\t\"Parsing timer source \\'%s\\' failed with %d\",\n\t\t\tdpcm->loopback->timer_source, err);\n\t\tgoto exit;\n\t}\n\n\tcable->snd_timer.stream = dpcm->substream->stream;\n\tcable->snd_timer.id = tid;\n\n\ttimeri = snd_timer_instance_new(dpcm->loopback->card->id);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\t \n\ttimeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\ttimeri->callback = loopback_snd_timer_function;\n\ttimeri->callback_data = (void *)cable;\n\ttimeri->ccallback = loopback_snd_timer_event;\n\n\t \n\tINIT_WORK(&cable->snd_timer.event_work, loopback_snd_timer_work);\n\n\t \n\terr = snd_timer_open(timeri, &cable->snd_timer.id, current->pid);\n\tif (err < 0) {\n\t\tpcm_err(dpcm->substream->pcm,\n\t\t\t\"snd_timer_open (%d,%d,%d) failed with %d\",\n\t\t\tcable->snd_timer.id.card,\n\t\t\tcable->snd_timer.id.device,\n\t\t\tcable->snd_timer.id.subdevice,\n\t\t\terr);\n\t\tsnd_timer_instance_free(timeri);\n\t\tgoto exit;\n\t}\n\n\tcable->snd_timer.instance = timeri;\n\nexit:\n\treturn err;\n}\n\n \nstatic const struct loopback_ops loopback_snd_timer_ops = {\n\t.open = loopback_snd_timer_open,\n\t.start = loopback_snd_timer_start,\n\t.stop = loopback_snd_timer_stop,\n\t.close_cable = loopback_snd_timer_close_cable,\n\t.dpcm_info = loopback_snd_timer_dpcm_info,\n};\n\nstatic int loopback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loopback *loopback = substream->private_data;\n\tstruct loopback_pcm *dpcm;\n\tstruct loopback_cable *cable = NULL;\n\tint err = 0;\n\tint dev = get_cable_index(substream);\n\n\tmutex_lock(&loopback->cable_lock);\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (!dpcm) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tdpcm->loopback = loopback;\n\tdpcm->substream = substream;\n\n\tcable = loopback->cables[substream->number][dev];\n\tif (!cable) {\n\t\tcable = kzalloc(sizeof(*cable), GFP_KERNEL);\n\t\tif (!cable) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\tspin_lock_init(&cable->lock);\n\t\tcable->hw = loopback_pcm_hardware;\n\t\tif (loopback->timer_source)\n\t\t\tcable->ops = &loopback_snd_timer_ops;\n\t\telse\n\t\t\tcable->ops = &loopback_jiffies_timer_ops;\n\t\tloopback->cables[substream->number][dev] = cable;\n\t}\n\tdpcm->cable = cable;\n\truntime->private_data = dpcm;\n\n\tif (cable->ops->open) {\n\t\terr = cable->ops->open(dpcm);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\n\t \n\t \n\t \n\terr = snd_pcm_hw_rule_add(runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  rule_format, dpcm,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (err < 0)\n\t\tgoto unlock;\n\terr = snd_pcm_hw_rule_add(runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t  rule_rate, dpcm,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\tif (err < 0)\n\t\tgoto unlock;\n\terr = snd_pcm_hw_rule_add(runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  rule_channels, dpcm,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\t \n\tif (cable->snd_timer.instance) {\n\t\terr = snd_pcm_hw_rule_add(runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t  rule_period_bytes, dpcm,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_PERIOD_BYTES, -1);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\truntime->private_free = loopback_runtime_free;\n\tif (get_notify(dpcm))\n\t\truntime->hw = loopback_pcm_hardware;\n\telse\n\t\truntime->hw = cable->hw;\n\n\tspin_lock_irq(&cable->lock);\n\tcable->streams[substream->stream] = dpcm;\n\tspin_unlock_irq(&cable->lock);\n\n unlock:\n\tif (err < 0) {\n\t\tfree_cable(substream);\n\t\tkfree(dpcm);\n\t}\n\tmutex_unlock(&loopback->cable_lock);\n\treturn err;\n}\n\nstatic int loopback_close(struct snd_pcm_substream *substream)\n{\n\tstruct loopback *loopback = substream->private_data;\n\tstruct loopback_pcm *dpcm = substream->runtime->private_data;\n\tint err = 0;\n\n\tif (dpcm->cable->ops->close_substream)\n\t\terr = dpcm->cable->ops->close_substream(dpcm);\n\tmutex_lock(&loopback->cable_lock);\n\tfree_cable(substream);\n\tmutex_unlock(&loopback->cable_lock);\n\treturn err;\n}\n\nstatic const struct snd_pcm_ops loopback_pcm_ops = {\n\t.open =\t\tloopback_open,\n\t.close =\tloopback_close,\n\t.hw_free =\tloopback_hw_free,\n\t.prepare =\tloopback_prepare,\n\t.trigger =\tloopback_trigger,\n\t.pointer =\tloopback_pointer,\n};\n\nstatic int loopback_pcm_new(struct loopback *loopback,\n\t\t\t    int device, int substreams)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(loopback->card, \"Loopback PCM\", device,\n\t\t\t  substreams, substreams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &loopback_pcm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &loopback_pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\tpcm->private_data = loopback;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"Loopback PCM\");\n\n\tloopback->pcm[device] = pcm;\n\treturn 0;\n}\n\nstatic int loopback_rate_shift_info(struct snd_kcontrol *kcontrol,   \n\t\t\t\t    struct snd_ctl_elem_info *uinfo) \n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 80000;\n\tuinfo->value.integer.max = 120000;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}                                  \n\nstatic int loopback_rate_shift_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\t\n\tmutex_lock(&loopback->cable_lock);\n\tucontrol->value.integer.value[0] =\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].rate_shift;\n\tmutex_unlock(&loopback->cable_lock);\n\treturn 0;\n}\n\nstatic int loopback_rate_shift_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tval = ucontrol->value.integer.value[0];\n\tif (val < 80000)\n\t\tval = 80000;\n\tif (val > 120000)\n\t\tval = 120000;\t\n\tmutex_lock(&loopback->cable_lock);\n\tif (val != loopback->setup[kcontrol->id.subdevice]\n\t\t\t\t  [kcontrol->id.device].rate_shift) {\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].rate_shift = val;\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&loopback->cable_lock);\n\treturn change;\n}\n\nstatic int loopback_notify_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\t\n\tmutex_lock(&loopback->cable_lock);\n\tucontrol->value.integer.value[0] =\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].notify;\n\tmutex_unlock(&loopback->cable_lock);\n\treturn 0;\n}\n\nstatic int loopback_notify_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\tint change = 0;\n\n\tval = ucontrol->value.integer.value[0] ? 1 : 0;\n\tmutex_lock(&loopback->cable_lock);\n\tif (val != loopback->setup[kcontrol->id.subdevice]\n\t\t\t\t[kcontrol->id.device].notify) {\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t[kcontrol->id.device].notify = val;\n\t\tchange = 1;\n\t}\n\tmutex_unlock(&loopback->cable_lock);\n\treturn change;\n}\n\nstatic int loopback_active_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\tstruct loopback_cable *cable;\n\n\tunsigned int val = 0;\n\n\tmutex_lock(&loopback->cable_lock);\n\tcable = loopback->cables[kcontrol->id.subdevice][kcontrol->id.device ^ 1];\n\tif (cable != NULL) {\n\t\tunsigned int running = cable->running ^ cable->pause;\n\n\t\tval = (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) ? 1 : 0;\n\t}\n\tmutex_unlock(&loopback->cable_lock);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\nstatic int loopback_format_info(struct snd_kcontrol *kcontrol,   \n\t\t\t\tstruct snd_ctl_elem_info *uinfo) \n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = (__force int)SNDRV_PCM_FORMAT_LAST;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}                                  \n\nstatic int loopback_format_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\t\n\tucontrol->value.integer.value[0] =\n\t\t(__force int)loopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].format;\n\treturn 0;\n}\n\nstatic int loopback_rate_info(struct snd_kcontrol *kcontrol,   \n\t\t\t      struct snd_ctl_elem_info *uinfo) \n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}                                  \n\nstatic int loopback_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\t\n\tmutex_lock(&loopback->cable_lock);\n\tucontrol->value.integer.value[0] =\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].rate;\n\tmutex_unlock(&loopback->cable_lock);\n\treturn 0;\n}\n\nstatic int loopback_channels_info(struct snd_kcontrol *kcontrol,   \n\t\t\t\t  struct snd_ctl_elem_info *uinfo) \n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 1;\n\tuinfo->value.integer.max = 1024;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}                                  \n\nstatic int loopback_channels_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\n\t\n\tmutex_lock(&loopback->cable_lock);\n\tucontrol->value.integer.value[0] =\n\t\tloopback->setup[kcontrol->id.subdevice]\n\t\t\t       [kcontrol->id.device].channels;\n\tmutex_unlock(&loopback->cable_lock);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new loopback_controls[]  = {\n{\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Rate Shift 100000\",\n\t.info =         loopback_rate_shift_info,\n\t.get =          loopback_rate_shift_get,\n\t.put =          loopback_rate_shift_put,\n},\n{\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Notify\",\n\t.info =         snd_ctl_boolean_mono_info,\n\t.get =          loopback_notify_get,\n\t.put =          loopback_notify_put,\n},\n#define ACTIVE_IDX 2\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Slave Active\",\n\t.info =         snd_ctl_boolean_mono_info,\n\t.get =          loopback_active_get,\n},\n#define FORMAT_IDX 3\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Slave Format\",\n\t.info =         loopback_format_info,\n\t.get =          loopback_format_get\n},\n#define RATE_IDX 4\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Slave Rate\",\n\t.info =         loopback_rate_info,\n\t.get =          loopback_rate_get\n},\n#define CHANNELS_IDX 5\n{\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         \"PCM Slave Channels\",\n\t.info =         loopback_channels_info,\n\t.get =          loopback_channels_get\n}\n};\n\nstatic int loopback_mixer_new(struct loopback *loopback, int notify)\n{\n\tstruct snd_card *card = loopback->card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_kcontrol *kctl;\n\tstruct loopback_setup *setup;\n\tint err, dev, substr, substr_count, idx;\n\n\tstrcpy(card->mixername, \"Loopback Mixer\");\n\tfor (dev = 0; dev < 2; dev++) {\n\t\tpcm = loopback->pcm[dev];\n\t\tsubstr_count =\n\t\t    pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count;\n\t\tfor (substr = 0; substr < substr_count; substr++) {\n\t\t\tsetup = &loopback->setup[substr][dev];\n\t\t\tsetup->notify = notify;\n\t\t\tsetup->rate_shift = NO_PITCH;\n\t\t\tsetup->format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t\tsetup->rate = 48000;\n\t\t\tsetup->channels = 2;\n\t\t\tfor (idx = 0; idx < ARRAY_SIZE(loopback_controls);\n\t\t\t\t\t\t\t\t\tidx++) {\n\t\t\t\tkctl = snd_ctl_new1(&loopback_controls[idx],\n\t\t\t\t\t\t    loopback);\n\t\t\t\tif (!kctl)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tkctl->id.device = dev;\n\t\t\t\tkctl->id.subdevice = substr;\n\n\t\t\t\t \n\t\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\n\t\t\t\tswitch (idx) {\n\t\t\t\tcase ACTIVE_IDX:\n\t\t\t\t\tsetup->active_id = kctl->id;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FORMAT_IDX:\n\t\t\t\t\tsetup->format_id = kctl->id;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RATE_IDX:\n\t\t\t\t\tsetup->rate_id = kctl->id;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHANNELS_IDX:\n\t\t\t\t\tsetup->channels_id = kctl->id;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void print_dpcm_info(struct snd_info_buffer *buffer,\n\t\t\t    struct loopback_pcm *dpcm,\n\t\t\t    const char *id)\n{\n\tsnd_iprintf(buffer, \"  %s\\n\", id);\n\tif (dpcm == NULL) {\n\t\tsnd_iprintf(buffer, \"    inactive\\n\");\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, \"    buffer_size:\\t%u\\n\", dpcm->pcm_buffer_size);\n\tsnd_iprintf(buffer, \"    buffer_pos:\\t\\t%u\\n\", dpcm->buf_pos);\n\tsnd_iprintf(buffer, \"    silent_size:\\t%u\\n\", dpcm->silent_size);\n\tsnd_iprintf(buffer, \"    period_size:\\t%u\\n\", dpcm->pcm_period_size);\n\tsnd_iprintf(buffer, \"    bytes_per_sec:\\t%u\\n\", dpcm->pcm_bps);\n\tsnd_iprintf(buffer, \"    sample_align:\\t%u\\n\", dpcm->pcm_salign);\n\tsnd_iprintf(buffer, \"    rate_shift:\\t\\t%u\\n\", dpcm->pcm_rate_shift);\n\tif (dpcm->cable->ops->dpcm_info)\n\t\tdpcm->cable->ops->dpcm_info(dpcm, buffer);\n}\n\nstatic void print_substream_info(struct snd_info_buffer *buffer,\n\t\t\t\t struct loopback *loopback,\n\t\t\t\t int sub,\n\t\t\t\t int num)\n{\n\tstruct loopback_cable *cable = loopback->cables[sub][num];\n\n\tsnd_iprintf(buffer, \"Cable %i substream %i:\\n\", num, sub);\n\tif (cable == NULL) {\n\t\tsnd_iprintf(buffer, \"  inactive\\n\");\n\t\treturn;\n\t}\n\tsnd_iprintf(buffer, \"  valid: %u\\n\", cable->valid);\n\tsnd_iprintf(buffer, \"  running: %u\\n\", cable->running);\n\tsnd_iprintf(buffer, \"  pause: %u\\n\", cable->pause);\n\tprint_dpcm_info(buffer, cable->streams[0], \"Playback\");\n\tprint_dpcm_info(buffer, cable->streams[1], \"Capture\");\n}\n\nstatic void print_cable_info(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct loopback *loopback = entry->private_data;\n\tint sub, num;\n\n\tmutex_lock(&loopback->cable_lock);\n\tnum = entry->name[strlen(entry->name)-1];\n\tnum = num == '0' ? 0 : 1;\n\tfor (sub = 0; sub < MAX_PCM_SUBSTREAMS; sub++)\n\t\tprint_substream_info(buffer, loopback, sub, num);\n\tmutex_unlock(&loopback->cable_lock);\n}\n\nstatic int loopback_cable_proc_new(struct loopback *loopback, int cidx)\n{\n\tchar name[32];\n\n\tsnprintf(name, sizeof(name), \"cable#%d\", cidx);\n\treturn snd_card_ro_proc_new(loopback->card, name, loopback,\n\t\t\t\t    print_cable_info);\n}\n\nstatic void loopback_set_timer_source(struct loopback *loopback,\n\t\t\t\t      const char *value)\n{\n\tif (loopback->timer_source) {\n\t\tdevm_kfree(loopback->card->dev, loopback->timer_source);\n\t\tloopback->timer_source = NULL;\n\t}\n\tif (value && *value)\n\t\tloopback->timer_source = devm_kstrdup(loopback->card->dev,\n\t\t\t\t\t\t      value, GFP_KERNEL);\n}\n\nstatic void print_timer_source_info(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct loopback *loopback = entry->private_data;\n\n\tmutex_lock(&loopback->cable_lock);\n\tsnd_iprintf(buffer, \"%s\\n\",\n\t\t    loopback->timer_source ? loopback->timer_source : \"\");\n\tmutex_unlock(&loopback->cable_lock);\n}\n\nstatic void change_timer_source_info(struct snd_info_entry *entry,\n\t\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct loopback *loopback = entry->private_data;\n\tchar line[64];\n\n\tmutex_lock(&loopback->cable_lock);\n\tif (!snd_info_get_line(buffer, line, sizeof(line)))\n\t\tloopback_set_timer_source(loopback, strim(line));\n\tmutex_unlock(&loopback->cable_lock);\n}\n\nstatic int loopback_timer_source_proc_new(struct loopback *loopback)\n{\n\treturn snd_card_rw_proc_new(loopback->card, \"timer_source\", loopback,\n\t\t\t\t    print_timer_source_info,\n\t\t\t\t    change_timer_source_info);\n}\n\nstatic int loopback_probe(struct platform_device *devptr)\n{\n\tstruct snd_card *card;\n\tstruct loopback *loopback;\n\tint dev = devptr->id;\n\tint err;\n\n\terr = snd_devm_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct loopback), &card);\n\tif (err < 0)\n\t\treturn err;\n\tloopback = card->private_data;\n\n\tif (pcm_substreams[dev] < 1)\n\t\tpcm_substreams[dev] = 1;\n\tif (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)\n\t\tpcm_substreams[dev] = MAX_PCM_SUBSTREAMS;\n\t\n\tloopback->card = card;\n\tloopback_set_timer_source(loopback, timer_source[dev]);\n\n\tmutex_init(&loopback->cable_lock);\n\n\terr = loopback_pcm_new(loopback, 0, pcm_substreams[dev]);\n\tif (err < 0)\n\t\treturn err;\n\terr = loopback_pcm_new(loopback, 1, pcm_substreams[dev]);\n\tif (err < 0)\n\t\treturn err;\n\terr = loopback_mixer_new(loopback, pcm_notify[dev] ? 1 : 0);\n\tif (err < 0)\n\t\treturn err;\n\tloopback_cable_proc_new(loopback, 0);\n\tloopback_cable_proc_new(loopback, 1);\n\tloopback_timer_source_proc_new(loopback);\n\tstrcpy(card->driver, \"Loopback\");\n\tstrcpy(card->shortname, \"Loopback\");\n\tsprintf(card->longname, \"Loopback %i\", dev + 1);\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int loopback_suspend(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\treturn 0;\n}\n\t\nstatic int loopback_resume(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(loopback_pm, loopback_suspend, loopback_resume);\n#define LOOPBACK_PM_OPS\t&loopback_pm\n#else\n#define LOOPBACK_PM_OPS\tNULL\n#endif\n\n#define SND_LOOPBACK_DRIVER\t\"snd_aloop\"\n\nstatic struct platform_driver loopback_driver = {\n\t.probe\t\t= loopback_probe,\n\t.driver\t\t= {\n\t\t.name\t= SND_LOOPBACK_DRIVER,\n\t\t.pm\t= LOOPBACK_PM_OPS,\n\t},\n};\n\nstatic void loopback_unregister_all(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); ++i)\n\t\tplatform_device_unregister(devices[i]);\n\tplatform_driver_unregister(&loopback_driver);\n}\n\nstatic int __init alsa_card_loopback_init(void)\n{\n\tint i, err, cards;\n\n\terr = platform_driver_register(&loopback_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\n\tcards = 0;\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tstruct platform_device *device;\n\t\tif (!enable[i])\n\t\t\tcontinue;\n\t\tdevice = platform_device_register_simple(SND_LOOPBACK_DRIVER,\n\t\t\t\t\t\t\t i, NULL, 0);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (!platform_get_drvdata(device)) {\n\t\t\tplatform_device_unregister(device);\n\t\t\tcontinue;\n\t\t}\n\t\tdevices[i] = device;\n\t\tcards++;\n\t}\n\tif (!cards) {\n#ifdef MODULE\n\t\tprintk(KERN_ERR \"aloop: No loopback enabled\\n\");\n#endif\n\t\tloopback_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_loopback_exit(void)\n{\n\tloopback_unregister_all();\n}\n\nmodule_init(alsa_card_loopback_init)\nmodule_exit(alsa_card_loopback_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}