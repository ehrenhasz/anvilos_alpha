{
  "module_name": "pcmtest.c",
  "hash_id": "0ab48e30c033758f07a14344f1d7b67887c800fef79d2bb424b4a22d0fb208fb",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/pcmtest.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <sound/pcm.h>\n#include <sound/core.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n#include <linux/random.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\n#define TIMER_PER_SEC 5\n#define TIMER_INTERVAL (HZ / TIMER_PER_SEC)\n#define DELAY_JIFFIES HZ\n#define PLAYBACK_SUBSTREAM_CNT\t8\n#define CAPTURE_SUBSTREAM_CNT\t8\n#define MAX_CHANNELS_NUM\t4\n\n#define DEFAULT_PATTERN\t\t\"abacaba\"\n#define DEFAULT_PATTERN_LEN\t7\n\n#define FILL_MODE_RAND\t0\n#define FILL_MODE_PAT\t1\n\n#define MAX_PATTERN_LEN 4096\n\nstatic int index = -1;\nstatic char *id = \"pcmtest\";\nstatic bool enable = true;\nstatic int inject_delay;\nstatic bool inject_hwpars_err;\nstatic bool inject_prepare_err;\nstatic bool inject_trigger_err;\nstatic bool inject_open_err;\n\nstatic short fill_mode = FILL_MODE_PAT;\n\nstatic u8 playback_capture_test;\nstatic u8 ioctl_reset_test;\nstatic struct dentry *driver_debug_dir;\n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for pcmtest soundcard\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for pcmtest soundcard\");\nmodule_param(enable, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable pcmtest soundcard.\");\nmodule_param(fill_mode, short, 0600);\nMODULE_PARM_DESC(fill_mode, \"Buffer fill mode: rand(0) or pattern(1)\");\nmodule_param(inject_delay, int, 0600);\nMODULE_PARM_DESC(inject_delay, \"Inject delays during playback/capture (in jiffies)\");\nmodule_param(inject_hwpars_err, bool, 0600);\nMODULE_PARM_DESC(inject_hwpars_err, \"Inject EBUSY error in the 'hw_params' callback\");\nmodule_param(inject_prepare_err, bool, 0600);\nMODULE_PARM_DESC(inject_prepare_err, \"Inject EINVAL error in the 'prepare' callback\");\nmodule_param(inject_trigger_err, bool, 0600);\nMODULE_PARM_DESC(inject_trigger_err, \"Inject EINVAL error in the 'trigger' callback\");\nmodule_param(inject_open_err, bool, 0600);\nMODULE_PARM_DESC(inject_open_err, \"Inject EBUSY error in the 'open' callback\");\n\nstruct pcmtst {\n\tstruct snd_pcm *pcm;\n\tstruct snd_card *card;\n\tstruct platform_device *pdev;\n};\n\nstruct pcmtst_buf_iter {\n\tsize_t buf_pos;\t\t\t\t\n\tsize_t period_pos;\t\t\t\n\tsize_t b_rw;\t\t\t\t\n\tsize_t s_rw_ch;\t\t\t\t\n\tunsigned int sample_bytes;\t\t\n\tbool is_buf_corrupted;\t\t\t\n\tsize_t period_bytes;\t\t\t\n\tbool interleaved;\t\t\t\n\tsize_t total_bytes;\t\t\t\n\tsize_t chan_block;\t\t\t\n\tstruct snd_pcm_substream *substream;\n\tbool suspend;\t\t\t\t\n\tstruct timer_list timer_instance;\n};\n\nstatic struct snd_pcm_hardware snd_pcmtst_hw = {\n\t.info = (SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_NONINTERLEAVED |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_PAUSE),\n\t.formats =\t\tSNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,\n\t.rates =\t\tSNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t8000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\tMAX_CHANNELS_NUM,\n\t.buffer_bytes_max =\t128 * 1024,\n\t.period_bytes_min =\t4096,\n\t.period_bytes_max =\t32768,\n\t.periods_min =\t\t1,\n\t.periods_max =\t\t1024,\n};\n\nstruct pattern_buf {\n\tchar *buf;\n\tu32 len;\n};\n\nstatic int buf_allocated;\nstatic struct pattern_buf patt_bufs[MAX_CHANNELS_NUM];\n\nstatic inline void inc_buf_pos(struct pcmtst_buf_iter *v_iter, size_t by, size_t bytes)\n{\n\tv_iter->total_bytes += by;\n\tv_iter->buf_pos += by;\n\tif (v_iter->buf_pos >= bytes)\n\t\tv_iter->buf_pos %= bytes;\n}\n\n \nstatic inline size_t buf_pos_n(struct pcmtst_buf_iter *v_iter, unsigned int channels,\n\t\t\t       unsigned int chan_num)\n{\n\treturn v_iter->buf_pos / channels + v_iter->chan_block * chan_num;\n}\n\n \nstatic inline size_t ch_pos_i(size_t b_total, unsigned int channels, unsigned int b_sample)\n{\n\treturn b_total / channels / b_sample * b_sample + (b_total % b_sample);\n}\n\nstatic void check_buf_block_i(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tsize_t i;\n\tshort ch_num;\n\tu8 current_byte;\n\n\tfor (i = 0; i < v_iter->b_rw; i++) {\n\t\tcurrent_byte = runtime->dma_area[v_iter->buf_pos];\n\t\tif (!current_byte)\n\t\t\tbreak;\n\t\tch_num = (v_iter->total_bytes / v_iter->sample_bytes) % runtime->channels;\n\t\tif (current_byte != patt_bufs[ch_num].buf[ch_pos_i(v_iter->total_bytes,\n\t\t\t\t\t\t\t\t   runtime->channels,\n\t\t\t\t\t\t\t\t   v_iter->sample_bytes)\n\t\t\t\t\t\t\t  % patt_bufs[ch_num].len]) {\n\t\t\tv_iter->is_buf_corrupted = true;\n\t\t\tbreak;\n\t\t}\n\t\tinc_buf_pos(v_iter, 1, runtime->dma_bytes);\n\t}\n\t\n\tinc_buf_pos(v_iter, v_iter->b_rw - i, runtime->dma_bytes);\n}\n\nstatic void check_buf_block_ni(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tunsigned int channels = runtime->channels;\n\tsize_t i;\n\tshort ch_num;\n\tu8 current_byte;\n\n\tfor (i = 0; i < v_iter->b_rw; i++) {\n\t\tch_num = i % channels;\n\t\tcurrent_byte = runtime->dma_area[buf_pos_n(v_iter, channels, ch_num)];\n\t\tif (!current_byte)\n\t\t\tbreak;\n\t\tif (current_byte != patt_bufs[ch_num].buf[(v_iter->total_bytes / channels)\n\t\t\t\t\t\t\t  % patt_bufs[ch_num].len]) {\n\t\t\tv_iter->is_buf_corrupted = true;\n\t\t\tbreak;\n\t\t}\n\t\tinc_buf_pos(v_iter, 1, runtime->dma_bytes);\n\t}\n\tinc_buf_pos(v_iter, v_iter->b_rw - i, runtime->dma_bytes);\n}\n\n \nstatic void check_buf_block(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tif (v_iter->interleaved)\n\t\tcheck_buf_block_i(v_iter, runtime);\n\telse\n\t\tcheck_buf_block_ni(v_iter, runtime);\n}\n\n \nstatic void fill_block_pattern_n(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tsize_t i;\n\tunsigned int channels = runtime->channels;\n\tshort ch_num;\n\n\tfor (i = 0; i < v_iter->b_rw; i++) {\n\t\tch_num = i % channels;\n\t\truntime->dma_area[buf_pos_n(v_iter, channels, ch_num)] =\n\t\t\tpatt_bufs[ch_num].buf[(v_iter->total_bytes / channels)\n\t\t\t\t\t      % patt_bufs[ch_num].len];\n\t\tinc_buf_pos(v_iter, 1, runtime->dma_bytes);\n\t}\n}\n\n \nstatic void fill_block_pattern_i(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tsize_t sample;\n\tsize_t pos_in_ch, pos_pattern;\n\tshort ch, pos_sample;\n\n\tpos_in_ch = ch_pos_i(v_iter->total_bytes, runtime->channels, v_iter->sample_bytes);\n\n\tfor (sample = 0; sample < v_iter->s_rw_ch; sample++) {\n\t\tfor (ch = 0; ch < runtime->channels; ch++) {\n\t\t\tfor (pos_sample = 0; pos_sample < v_iter->sample_bytes; pos_sample++) {\n\t\t\t\tpos_pattern = (pos_in_ch + sample * v_iter->sample_bytes\n\t\t\t\t\t      + pos_sample) % patt_bufs[ch].len;\n\t\t\t\truntime->dma_area[v_iter->buf_pos] = patt_bufs[ch].buf[pos_pattern];\n\t\t\t\tinc_buf_pos(v_iter, 1, runtime->dma_bytes);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void fill_block_pattern(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tif (v_iter->interleaved)\n\t\tfill_block_pattern_i(v_iter, runtime);\n\telse\n\t\tfill_block_pattern_n(v_iter, runtime);\n}\n\nstatic void fill_block_rand_n(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tunsigned int channels = runtime->channels;\n\t \n\tsize_t bytes_remain = runtime->dma_bytes - v_iter->buf_pos;\n\tunsigned int i;\n\n\tfor (i = 0; i < channels; i++) {\n\t\tif (v_iter->b_rw <= bytes_remain) {\n\t\t\t \n\t\t\tget_random_bytes(runtime->dma_area + buf_pos_n(v_iter, channels, i),\n\t\t\t\t\t v_iter->b_rw / channels);\n\t\t} else {\n\t\t\t \n\t\t\tget_random_bytes(runtime->dma_area + buf_pos_n(v_iter, channels, i),\n\t\t\t\t\t bytes_remain / channels);\n\t\t\tget_random_bytes(runtime->dma_area + v_iter->chan_block * i,\n\t\t\t\t\t (v_iter->b_rw - bytes_remain) / channels);\n\t\t}\n\t}\n\tinc_buf_pos(v_iter, v_iter->b_rw, runtime->dma_bytes);\n}\n\nstatic void fill_block_rand_i(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tsize_t in_cur_block = runtime->dma_bytes - v_iter->buf_pos;\n\n\tif (v_iter->b_rw <= in_cur_block) {\n\t\tget_random_bytes(&runtime->dma_area[v_iter->buf_pos], v_iter->b_rw);\n\t} else {\n\t\tget_random_bytes(&runtime->dma_area[v_iter->buf_pos], in_cur_block);\n\t\tget_random_bytes(runtime->dma_area, v_iter->b_rw - in_cur_block);\n\t}\n\tinc_buf_pos(v_iter, v_iter->b_rw, runtime->dma_bytes);\n}\n\nstatic void fill_block_random(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tif (v_iter->interleaved)\n\t\tfill_block_rand_i(v_iter, runtime);\n\telse\n\t\tfill_block_rand_n(v_iter, runtime);\n}\n\nstatic void fill_block(struct pcmtst_buf_iter *v_iter, struct snd_pcm_runtime *runtime)\n{\n\tswitch (fill_mode) {\n\tcase FILL_MODE_RAND:\n\t\tfill_block_random(v_iter, runtime);\n\t\tbreak;\n\tcase FILL_MODE_PAT:\n\t\tfill_block_pattern(v_iter, runtime);\n\t\tbreak;\n\t}\n}\n\n \nstatic void timer_timeout(struct timer_list *data)\n{\n\tstruct pcmtst_buf_iter *v_iter;\n\tstruct snd_pcm_substream *substream;\n\n\tv_iter = from_timer(v_iter, data, timer_instance);\n\tsubstream = v_iter->substream;\n\n\tif (v_iter->suspend)\n\t\treturn;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && !v_iter->is_buf_corrupted)\n\t\tcheck_buf_block(v_iter, substream->runtime);\n\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tfill_block(v_iter, substream->runtime);\n\telse\n\t\tinc_buf_pos(v_iter, v_iter->b_rw, substream->runtime->dma_bytes);\n\n\tv_iter->period_pos += v_iter->b_rw;\n\tif (v_iter->period_pos >= v_iter->period_bytes) {\n\t\tv_iter->period_pos %= v_iter->period_bytes;\n\t\tsnd_pcm_period_elapsed(substream);\n\t}\n\n\tif (!v_iter->suspend)\n\t\tmod_timer(&v_iter->timer_instance, jiffies + TIMER_INTERVAL + inject_delay);\n}\n\nstatic int snd_pcmtst_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmtst_buf_iter *v_iter;\n\n\tif (inject_open_err)\n\t\treturn -EBUSY;\n\n\tv_iter = kzalloc(sizeof(*v_iter), GFP_KERNEL);\n\tif (!v_iter)\n\t\treturn -ENOMEM;\n\n\tv_iter->substream = substream;\n\truntime->hw = snd_pcmtst_hw;\n\truntime->private_data = v_iter;\n\n\tplayback_capture_test = 0;\n\tioctl_reset_test = 0;\n\n\ttimer_setup(&v_iter->timer_instance, timer_timeout, 0);\n\n\treturn 0;\n}\n\nstatic int snd_pcmtst_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct pcmtst_buf_iter *v_iter = substream->runtime->private_data;\n\n\ttimer_shutdown_sync(&v_iter->timer_instance);\n\tplayback_capture_test = !v_iter->is_buf_corrupted;\n\tkfree(v_iter);\n\treturn 0;\n}\n\nstatic inline void reset_buf_iterator(struct pcmtst_buf_iter *v_iter)\n{\n\tv_iter->buf_pos = 0;\n\tv_iter->is_buf_corrupted = false;\n\tv_iter->period_pos = 0;\n\tv_iter->total_bytes = 0;\n}\n\nstatic inline void start_pcmtest_timer(struct pcmtst_buf_iter *v_iter)\n{\n\tv_iter->suspend = false;\n\tmod_timer(&v_iter->timer_instance, jiffies + TIMER_INTERVAL);\n}\n\nstatic int snd_pcmtst_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct pcmtst_buf_iter *v_iter = substream->runtime->private_data;\n\n\tif (inject_trigger_err)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\treset_buf_iterator(v_iter);\n\t\tstart_pcmtest_timer(v_iter);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tstart_pcmtest_timer(v_iter);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tv_iter->suspend = true;\n\t\ttimer_delete(&v_iter->timer_instance);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_pcmtst_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct pcmtst_buf_iter *v_iter = substream->runtime->private_data;\n\n\treturn bytes_to_frames(substream->runtime, v_iter->buf_pos);\n}\n\nstatic int snd_pcmtst_free(struct pcmtst *pcmtst)\n{\n\tif (!pcmtst)\n\t\treturn 0;\n\tkfree(pcmtst);\n\treturn 0;\n}\n\n\nstatic int snd_pcmtst_dev_free(struct snd_device *device)\n{\n\treturn 0;\n}\n\nstatic void pcmtst_pdev_release(struct device *dev)\n{\n}\n\nstatic int snd_pcmtst_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcmtst_buf_iter *v_iter = runtime->private_data;\n\n\tif (inject_prepare_err)\n\t\treturn -EINVAL;\n\n\tv_iter->sample_bytes = samples_to_bytes(runtime, 1);\n\tv_iter->period_bytes = snd_pcm_lib_period_bytes(substream);\n\tv_iter->interleaved = true;\n\tif (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED ||\n\t    runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED) {\n\t\tv_iter->chan_block = snd_pcm_lib_buffer_bytes(substream) / runtime->channels;\n\t\tv_iter->interleaved = false;\n\t}\n\t\n\tv_iter->s_rw_ch = runtime->rate / TIMER_PER_SEC;\n\tv_iter->b_rw = v_iter->s_rw_ch * v_iter->sample_bytes * runtime->channels;\n\n\treturn 0;\n}\n\nstatic int snd_pcmtst_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tif (inject_hwpars_err)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int snd_pcmtst_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic int snd_pcmtst_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\tioctl_reset_test = 1;\n\t\tbreak;\n\t}\n\treturn snd_pcm_lib_ioctl(substream, cmd, arg);\n}\n\nstatic int snd_pcmtst_sync_stop(struct snd_pcm_substream *substream)\n{\n\tstruct pcmtst_buf_iter *v_iter = substream->runtime->private_data;\n\n\ttimer_delete_sync(&v_iter->timer_instance);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_pcmtst_playback_ops = {\n\t.open =\t\tsnd_pcmtst_pcm_open,\n\t.close =\tsnd_pcmtst_pcm_close,\n\t.trigger =\tsnd_pcmtst_pcm_trigger,\n\t.hw_params =\tsnd_pcmtst_pcm_hw_params,\n\t.ioctl =\tsnd_pcmtst_ioctl,\n\t.sync_stop =\tsnd_pcmtst_sync_stop,\n\t.hw_free =\tsnd_pcmtst_pcm_hw_free,\n\t.prepare =\tsnd_pcmtst_pcm_prepare,\n\t.pointer =\tsnd_pcmtst_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_pcmtst_capture_ops = {\n\t.open =\t\tsnd_pcmtst_pcm_open,\n\t.close =\tsnd_pcmtst_pcm_close,\n\t.trigger =\tsnd_pcmtst_pcm_trigger,\n\t.hw_params =\tsnd_pcmtst_pcm_hw_params,\n\t.hw_free =\tsnd_pcmtst_pcm_hw_free,\n\t.ioctl =\tsnd_pcmtst_ioctl,\n\t.sync_stop =\tsnd_pcmtst_sync_stop,\n\t.prepare =\tsnd_pcmtst_pcm_prepare,\n\t.pointer =\tsnd_pcmtst_pcm_pointer,\n};\n\nstatic int snd_pcmtst_new_pcm(struct pcmtst *pcmtst)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(pcmtst->card, \"PCMTest\", 0, PLAYBACK_SUBSTREAM_CNT,\n\t\t\t  CAPTURE_SUBSTREAM_CNT, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->private_data = pcmtst;\n\tstrcpy(pcm->name, \"PCMTest\");\n\tpcmtst->pcm = pcm;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_pcmtst_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pcmtst_capture_ops);\n\n\terr = snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &pcmtst->pdev->dev,\n\t\t\t\t\t     0, 128 * 1024);\n\treturn err;\n}\n\nstatic int snd_pcmtst_create(struct snd_card *card, struct platform_device *pdev,\n\t\t\t     struct pcmtst **r_pcmtst)\n{\n\tstruct pcmtst *pcmtst;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_pcmtst_dev_free,\n\t};\n\n\tpcmtst = kzalloc(sizeof(*pcmtst), GFP_KERNEL);\n\tif (!pcmtst)\n\t\treturn -ENOMEM;\n\tpcmtst->card = card;\n\tpcmtst->pdev = pdev;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pcmtst, &ops);\n\tif (err < 0)\n\t\tgoto _err_free_chip;\n\n\terr = snd_pcmtst_new_pcm(pcmtst);\n\tif (err < 0)\n\t\tgoto _err_free_chip;\n\n\t*r_pcmtst = pcmtst;\n\treturn 0;\n\n_err_free_chip:\n\tsnd_pcmtst_free(pcmtst);\n\treturn err;\n}\n\nstatic int pcmtst_probe(struct platform_device *pdev)\n{\n\tstruct snd_card *card;\n\tstruct pcmtst *pcmtst;\n\tint err;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\terr = snd_devm_card_new(&pdev->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcmtst_create(card, pdev, &pcmtst);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"PCM-TEST Driver\");\n\tstrcpy(card->shortname, \"PCM-Test\");\n\tstrcpy(card->longname, \"PCM-Test virtual driver\");\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, pcmtst);\n\n\treturn 0;\n}\n\nstatic void pdev_remove(struct platform_device *pdev)\n{\n\tstruct pcmtst *pcmtst = platform_get_drvdata(pdev);\n\n\tsnd_pcmtst_free(pcmtst);\n}\n\nstatic struct platform_device pcmtst_pdev = {\n\t.name =\t\t\"pcmtest\",\n\t.dev.release =\tpcmtst_pdev_release,\n};\n\nstatic struct platform_driver pcmtst_pdrv = {\n\t.probe =\tpcmtst_probe,\n\t.remove_new =\tpdev_remove,\n\t.driver =\t{\n\t\t.name = \"pcmtest\",\n\t},\n};\n\nstatic ssize_t pattern_write(struct file *file, const char __user *u_buff, size_t len, loff_t *off)\n{\n\tstruct pattern_buf *patt_buf = file->f_inode->i_private;\n\tssize_t to_write = len;\n\n\tif (*off + to_write > MAX_PATTERN_LEN)\n\t\tto_write = MAX_PATTERN_LEN - *off;\n\n\t\n\tif (to_write <= 0)\n\t\treturn len;\n\n\tif (copy_from_user(patt_buf->buf + *off, u_buff, to_write))\n\t\treturn -EFAULT;\n\n\tpatt_buf->len = *off + to_write;\n\t*off += to_write;\n\n\treturn to_write;\n}\n\nstatic ssize_t pattern_read(struct file *file, char __user *u_buff, size_t len, loff_t *off)\n{\n\tstruct pattern_buf *patt_buf = file->f_inode->i_private;\n\tssize_t to_read = len;\n\n\tif (*off + to_read >= MAX_PATTERN_LEN)\n\t\tto_read = MAX_PATTERN_LEN - *off;\n\tif (to_read <= 0)\n\t\treturn 0;\n\n\tif (copy_to_user(u_buff, patt_buf->buf + *off, to_read))\n\t\tto_read = 0;\n\telse\n\t\t*off += to_read;\n\n\treturn to_read;\n}\n\nstatic const struct file_operations fill_pattern_fops = {\n\t.read = pattern_read,\n\t.write = pattern_write,\n};\n\nstatic int setup_patt_bufs(void)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(patt_bufs); i++) {\n\t\tpatt_bufs[i].buf = kzalloc(MAX_PATTERN_LEN, GFP_KERNEL);\n\t\tif (!patt_bufs[i].buf)\n\t\t\tbreak;\n\t\tstrcpy(patt_bufs[i].buf, DEFAULT_PATTERN);\n\t\tpatt_bufs[i].len = DEFAULT_PATTERN_LEN;\n\t}\n\n\treturn i;\n}\n\nstatic const char * const pattern_files[] = { \"fill_pattern0\", \"fill_pattern1\",\n\t\t\t\t\t      \"fill_pattern2\", \"fill_pattern3\"};\nstatic int init_debug_files(int buf_count)\n{\n\tsize_t i;\n\tchar len_file_name[32];\n\n\tdriver_debug_dir = debugfs_create_dir(\"pcmtest\", NULL);\n\tif (IS_ERR(driver_debug_dir))\n\t\treturn PTR_ERR(driver_debug_dir);\n\tdebugfs_create_u8(\"pc_test\", 0444, driver_debug_dir, &playback_capture_test);\n\tdebugfs_create_u8(\"ioctl_test\", 0444, driver_debug_dir, &ioctl_reset_test);\n\n\tfor (i = 0; i < buf_count; i++) {\n\t\tdebugfs_create_file(pattern_files[i], 0600, driver_debug_dir,\n\t\t\t\t    &patt_bufs[i], &fill_pattern_fops);\n\t\tsnprintf(len_file_name, sizeof(len_file_name), \"%s_len\", pattern_files[i]);\n\t\tdebugfs_create_u32(len_file_name, 0444, driver_debug_dir, &patt_bufs[i].len);\n\t}\n\n\treturn 0;\n}\n\nstatic void free_pattern_buffers(void)\n{\n\tint i;\n\n\tfor (i = 0; i < buf_allocated; i++)\n\t\tkfree(patt_bufs[i].buf);\n}\n\nstatic void clear_debug_files(void)\n{\n\tdebugfs_remove_recursive(driver_debug_dir);\n}\n\nstatic int __init mod_init(void)\n{\n\tint err = 0;\n\n\tbuf_allocated = setup_patt_bufs();\n\tif (!buf_allocated)\n\t\treturn -ENOMEM;\n\n\tsnd_pcmtst_hw.channels_max = buf_allocated;\n\n\terr = init_debug_files(buf_allocated);\n\tif (err)\n\t\treturn err;\n\terr = platform_device_register(&pcmtst_pdev);\n\tif (err)\n\t\treturn err;\n\terr = platform_driver_register(&pcmtst_pdrv);\n\tif (err)\n\t\tplatform_device_unregister(&pcmtst_pdev);\n\treturn err;\n}\n\nstatic void __exit mod_exit(void)\n{\n\tclear_debug_files();\n\tfree_pattern_buffers();\n\n\tplatform_driver_unregister(&pcmtst_pdrv);\n\tplatform_device_unregister(&pcmtst_pdev);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ivan Orlov\");\nmodule_init(mod_init);\nmodule_exit(mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}