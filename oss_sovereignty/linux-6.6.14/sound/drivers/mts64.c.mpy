{
  "module_name": "mts64.c",
  "hash_id": "160bdaf580794ac50b5270b37a3f4a671ce86f3ce15ecd2939332a337e4ce205",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/mts64.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/parport.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n#include <sound/control.h>\n\n#define CARD_NAME \"Miditerminal 4140\"\n#define DRIVER_NAME \"MTS64\"\n#define PLATFORM_DRIVER \"snd_mts64\"\n\nstatic int index[SNDRV_CARDS]  = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS]   = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nstatic struct platform_device *platform_devices[SNDRV_CARDS]; \nstatic int device_count;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\n\nMODULE_AUTHOR(\"Matthias Koenig <mk@phasorlab.de>\");\nMODULE_DESCRIPTION(\"ESI Miditerminal 4140\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define MTS64_NUM_INPUT_PORTS 5\n#define MTS64_NUM_OUTPUT_PORTS 4\n#define MTS64_SMPTE_SUBSTREAM 4\n\nstruct mts64 {\n\tspinlock_t lock;\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tstruct pardevice *pardev;\n\tint open_count;\n\tint current_midi_output_port;\n\tint current_midi_input_port;\n\tu8 mode[MTS64_NUM_INPUT_PORTS];\n\tstruct snd_rawmidi_substream *midi_input_substream[MTS64_NUM_INPUT_PORTS];\n\tint smpte_switch;\n\tu8 time[4];  \n\tu8 fps;\n};\n\nstatic int snd_mts64_free(struct mts64 *mts)\n{\n\tkfree(mts);\n\treturn 0;\n}\n\nstatic int snd_mts64_create(struct snd_card *card,\n\t\t\t    struct pardevice *pardev,\n\t\t\t    struct mts64 **rchip)\n{\n\tstruct mts64 *mts;\n\n\t*rchip = NULL;\n\n\tmts = kzalloc(sizeof(struct mts64), GFP_KERNEL);\n\tif (mts == NULL) \n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_init(&mts->lock);\n\tmts->card = card;\n\tmts->pardev = pardev;\n\tmts->current_midi_output_port = -1;\n\tmts->current_midi_input_port = -1;\n\n\t*rchip = mts;\n\n\treturn 0;\n}\n\n \n\n \n#define MTS64_STAT_BSY             0x80\n#define MTS64_STAT_BIT_SET         0x20   \n#define MTS64_STAT_PORT            0x10   \n\n \n#define MTS64_CTL_READOUT          0x08   \n#define MTS64_CTL_WRITE_CMD        0x06  \n#define MTS64_CTL_WRITE_DATA       0x02  \n#define MTS64_CTL_STROBE           0x01  \n\n \n#define MTS64_CMD_RESET            0xfe\n#define MTS64_CMD_PROBE            0x8f   \n#define MTS64_CMD_SMPTE_SET_TIME   0xe8\n#define MTS64_CMD_SMPTE_SET_FPS    0xee\n#define MTS64_CMD_SMPTE_STOP       0xef\n#define MTS64_CMD_SMPTE_FPS_24     0xe3\n#define MTS64_CMD_SMPTE_FPS_25     0xe2\n#define MTS64_CMD_SMPTE_FPS_2997   0xe4 \n#define MTS64_CMD_SMPTE_FPS_30D    0xe1\n#define MTS64_CMD_SMPTE_FPS_30     0xe0\n#define MTS64_CMD_COM_OPEN         0xf8   \n#define MTS64_CMD_COM_CLOSE1       0xff   \n#define MTS64_CMD_COM_CLOSE2       0xf5\n\n \nstatic void mts64_enable_readout(struct parport *p);\nstatic void mts64_disable_readout(struct parport *p);\nstatic int mts64_device_ready(struct parport *p);\nstatic int mts64_device_init(struct parport *p);\nstatic int mts64_device_open(struct mts64 *mts);\nstatic int mts64_device_close(struct mts64 *mts);\nstatic u8 mts64_map_midi_input(u8 c);\nstatic int mts64_probe(struct parport *p);\nstatic u16 mts64_read(struct parport *p);\nstatic u8 mts64_read_char(struct parport *p);\nstatic void mts64_smpte_start(struct parport *p,\n\t\t\t      u8 hours, u8 minutes,\n\t\t\t      u8 seconds, u8 frames,\n\t\t\t      u8 idx);\nstatic void mts64_smpte_stop(struct parport *p);\nstatic void mts64_write_command(struct parport *p, u8 c);\nstatic void mts64_write_data(struct parport *p, u8 c);\nstatic void mts64_write_midi(struct mts64 *mts, u8 c, int midiport);\n\n\n \nstatic void mts64_enable_readout(struct parport *p)\n{\n\tu8 c;\n\n\tc = parport_read_control(p);\n\tc |= MTS64_CTL_READOUT;\n\tparport_write_control(p, c); \n}\n\n \nstatic void mts64_disable_readout(struct parport *p)\n{\n\tu8 c;\n\n\tc = parport_read_control(p);\n\tc &= ~MTS64_CTL_READOUT;\n\tparport_write_control(p, c);\n}\n\n \nstatic int mts64_device_ready(struct parport *p)\n{\n\tint i;\n\tu8 c;\n\n\tfor (i = 0; i < 0xffff; ++i) {\n\t\tc = parport_read_status(p);\n\t\tc &= MTS64_STAT_BSY;\n\t\tif (c != 0) \n\t\t\treturn 1;\n\t} \n\n\treturn 0;\n}\n\n \nstatic int mts64_device_init(struct parport *p)\n{\n\tint i;\n\n\tmts64_write_command(p, MTS64_CMD_RESET);\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tmsleep(100);\n\n\t\tif (mts64_probe(p) == 0) {\n\t\t\t \n\t\t\tmts64_disable_readout(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmts64_disable_readout(p);\n\n\treturn -EIO;\n}\n\n \nstatic int mts64_device_open(struct mts64 *mts)\n{\n\tint i;\n\tstruct parport *p = mts->pardev->port;\n\n\tfor (i = 0; i < 5; ++i)\n\t\tmts64_write_command(p, MTS64_CMD_COM_OPEN);\n\n\treturn 0;\n}\n\n \nstatic int mts64_device_close(struct mts64 *mts)\n{\n\tint i;\n\tstruct parport *p = mts->pardev->port;\n\n\tfor (i = 0; i < 5; ++i) {\n\t\tmts64_write_command(p, MTS64_CMD_COM_CLOSE1);\n\t\tmts64_write_command(p, MTS64_CMD_COM_CLOSE2);\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 mts64_map_midi_input(u8 c)\n{\n\tstatic const u8 map[] = { 0, 1, 4, 2, 3 };\n\n\treturn map[c];\n}\n\n\n \nstatic int mts64_probe(struct parport *p)\n{\n\tu8 c;\n\n\tmts64_smpte_stop(p);\n\tmts64_write_command(p, MTS64_CMD_PROBE);\n\n\tmsleep(50);\n\t\n\tc = mts64_read(p);\n\n\tc &= 0x00ff;\n\tif (c != MTS64_CMD_PROBE) \n\t\treturn -ENODEV;\n\telse \n\t\treturn 0;\n\n}\n\n \nstatic u16 mts64_read(struct parport *p)\n{\n\tu8 data, status;\n\n\tmts64_device_ready(p);\n\tmts64_enable_readout(p);\n\tstatus = parport_read_status(p);\n\tdata = mts64_read_char(p);\n\tmts64_disable_readout(p);\n\n\treturn (status << 8) | data;\n}\n\n \nstatic u8 mts64_read_char(struct parport *p)\n{\n\tu8 c = 0;\n\tu8 status;\n\tu8 i;\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tparport_write_data(p, i);\n\t\tc >>= 1;\n\t\tstatus = parport_read_status(p);\n\t\tif (status & MTS64_STAT_BIT_SET) \n\t\t\tc |= 0x80;\n\t}\n\t\n\treturn c;\n}\n\n \nstatic void mts64_smpte_start(struct parport *p,\n\t\t\t      u8 hours, u8 minutes,\n\t\t\t      u8 seconds, u8 frames,\n\t\t\t      u8 idx)\n{\n\tstatic const u8 fps[5] = { MTS64_CMD_SMPTE_FPS_24,\n\t\t\t     MTS64_CMD_SMPTE_FPS_25,\n\t\t\t     MTS64_CMD_SMPTE_FPS_2997, \n\t\t\t     MTS64_CMD_SMPTE_FPS_30D,\n\t\t\t     MTS64_CMD_SMPTE_FPS_30    };\n\n\tmts64_write_command(p, MTS64_CMD_SMPTE_SET_TIME);\n\tmts64_write_command(p, frames);\n\tmts64_write_command(p, seconds);\n\tmts64_write_command(p, minutes);\n\tmts64_write_command(p, hours);\n\n\tmts64_write_command(p, MTS64_CMD_SMPTE_SET_FPS);\n\tmts64_write_command(p, fps[idx]);\n}\n\n \nstatic void mts64_smpte_stop(struct parport *p)\n{\n\tmts64_write_command(p, MTS64_CMD_SMPTE_STOP);\n}\n\n \nstatic void mts64_write_command(struct parport *p, u8 c)\n{\n\tmts64_device_ready(p);\n\n\tparport_write_data(p, c);\n\n\tparport_write_control(p, MTS64_CTL_WRITE_CMD);\n\tparport_write_control(p, MTS64_CTL_WRITE_CMD | MTS64_CTL_STROBE);\n\tparport_write_control(p, MTS64_CTL_WRITE_CMD);\n}\n\n \nstatic void mts64_write_data(struct parport *p, u8 c)\n{\n\tmts64_device_ready(p);\n\n\tparport_write_data(p, c);\n\n\tparport_write_control(p, MTS64_CTL_WRITE_DATA);\n\tparport_write_control(p, MTS64_CTL_WRITE_DATA | MTS64_CTL_STROBE);\n\tparport_write_control(p, MTS64_CTL_WRITE_DATA);\n}\n\n \nstatic void mts64_write_midi(struct mts64 *mts, u8 c,\n\t\t\t     int midiport)\n{\n\tstruct parport *p = mts->pardev->port;\n\n\t \n\tif (mts->current_midi_output_port != midiport)\n\t\tmts64_write_command(p, midiport);\n\n\t \n\tmts64_write_data(p, c);\n}\n\n \n\n \n#define snd_mts64_ctl_smpte_switch_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int snd_mts64_ctl_smpte_switch_get(struct snd_kcontrol* kctl,\n\t\t\t\t\t  struct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\n\tspin_lock_irq(&mts->lock);\n\tuctl->value.integer.value[0] = mts->smpte_switch;\n\tspin_unlock_irq(&mts->lock);\n\n\treturn 0;\n}\n\n \nstatic int snd_mts64_ctl_smpte_switch_put(struct snd_kcontrol* kctl,\n\t\t\t\t\t  struct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\tint changed = 0;\n\tint val = !!uctl->value.integer.value[0];\n\n\tspin_lock_irq(&mts->lock);\n\tif (mts->smpte_switch == val)\n\t\tgoto __out;\n\n\tchanged = 1;\n\tmts->smpte_switch = val;\n\tif (mts->smpte_switch) {\n\t\tmts64_smpte_start(mts->pardev->port,\n\t\t\t\t  mts->time[0], mts->time[1],\n\t\t\t\t  mts->time[2], mts->time[3],\n\t\t\t\t  mts->fps);\n\t} else {\n\t\tmts64_smpte_stop(mts->pardev->port);\n\t}\n__out:\n\tspin_unlock_irq(&mts->lock);\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_switch = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Playback Switch\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info = snd_mts64_ctl_smpte_switch_info,\n\t.get  = snd_mts64_ctl_smpte_switch_get,\n\t.put  = snd_mts64_ctl_smpte_switch_put\n};\n\n \nstatic int snd_mts64_ctl_smpte_time_h_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 23;\n\treturn 0;\n}\n\nstatic int snd_mts64_ctl_smpte_time_f_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 99;\n\treturn 0;\n}\n\nstatic int snd_mts64_ctl_smpte_time_info(struct snd_kcontrol *kctl,\n\t\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 59;\n\treturn 0;\n}\n\nstatic int snd_mts64_ctl_smpte_time_get(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\tint idx = kctl->private_value;\n\n\tspin_lock_irq(&mts->lock);\n\tuctl->value.integer.value[0] = mts->time[idx];\n\tspin_unlock_irq(&mts->lock);\n\n\treturn 0;\n}\n\nstatic int snd_mts64_ctl_smpte_time_put(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\tint idx = kctl->private_value;\n\tunsigned int time = uctl->value.integer.value[0] % 60;\n\tint changed = 0;\n\n\tspin_lock_irq(&mts->lock);\n\tif (mts->time[idx] != time) {\n\t\tchanged = 1;\n\t\tmts->time[idx] = time;\n\t}\n\tspin_unlock_irq(&mts->lock);\n\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_time_hours = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Time Hours\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info = snd_mts64_ctl_smpte_time_h_info,\n\t.get  = snd_mts64_ctl_smpte_time_get,\n\t.put  = snd_mts64_ctl_smpte_time_put\n};\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_time_minutes = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Time Minutes\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 1,\n\t.info = snd_mts64_ctl_smpte_time_info,\n\t.get  = snd_mts64_ctl_smpte_time_get,\n\t.put  = snd_mts64_ctl_smpte_time_put\n};\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_time_seconds = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Time Seconds\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 2,\n\t.info = snd_mts64_ctl_smpte_time_info,\n\t.get  = snd_mts64_ctl_smpte_time_get,\n\t.put  = snd_mts64_ctl_smpte_time_put\n};\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_time_frames = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Time Frames\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 3,\n\t.info = snd_mts64_ctl_smpte_time_f_info,\n\t.get  = snd_mts64_ctl_smpte_time_get,\n\t.put  = snd_mts64_ctl_smpte_time_put\n};\n\n \nstatic int snd_mts64_ctl_smpte_fps_info(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[5] = {\n\t\t\"24\", \"25\", \"29.97\", \"30D\", \"30\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 5, texts);\n}\n\nstatic int snd_mts64_ctl_smpte_fps_get(struct snd_kcontrol *kctl,\n\t\t\t\t       struct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\n\tspin_lock_irq(&mts->lock);\n\tuctl->value.enumerated.item[0] = mts->fps;\n\tspin_unlock_irq(&mts->lock);\n\n\treturn 0;\n}\n\nstatic int snd_mts64_ctl_smpte_fps_put(struct snd_kcontrol *kctl,\n\t\t\t\t       struct snd_ctl_elem_value *uctl)\n{\n\tstruct mts64 *mts = snd_kcontrol_chip(kctl);\n\tint changed = 0;\n\n\tif (uctl->value.enumerated.item[0] >= 5)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&mts->lock);\n\tif (mts->fps != uctl->value.enumerated.item[0]) {\n\t\tchanged = 1;\n\t\tmts->fps = uctl->value.enumerated.item[0];\n\t}\n\tspin_unlock_irq(&mts->lock);\n\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new mts64_ctl_smpte_fps = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name  = \"SMPTE Fps\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value = 0,\n\t.info  = snd_mts64_ctl_smpte_fps_info,\n\t.get   = snd_mts64_ctl_smpte_fps_get,\n\t.put   = snd_mts64_ctl_smpte_fps_put\n};\n\n\nstatic int snd_mts64_ctl_create(struct snd_card *card,\n\t\t\t\tstruct mts64 *mts)\n{\n\tint err, i;\n\tstatic const struct snd_kcontrol_new *control[] = {\n\t\t&mts64_ctl_smpte_switch,\n\t\t&mts64_ctl_smpte_time_hours,\n\t\t&mts64_ctl_smpte_time_minutes,\n\t\t&mts64_ctl_smpte_time_seconds,\n\t\t&mts64_ctl_smpte_time_frames,\n\t\t&mts64_ctl_smpte_fps,\n\t        NULL  };\n\n\tfor (i = 0; control[i]; ++i) {\n\t\terr = snd_ctl_add(card, snd_ctl_new1(control[i], mts));\n\t\tif (err < 0) {\n\t\t\tsnd_printd(\"Cannot create control: %s\\n\", \n\t\t\t\t   control[i]->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define MTS64_MODE_INPUT_TRIGGERED 0x01\n\nstatic int snd_mts64_rawmidi_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct mts64 *mts = substream->rmidi->private_data;\n\n\tif (mts->open_count == 0) {\n\t\t \n\t\tmts64_device_open(mts);\n\n\t\tmsleep(50);\n\t}\n\t++(mts->open_count);\n\n\treturn 0;\n}\n\nstatic int snd_mts64_rawmidi_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct mts64 *mts = substream->rmidi->private_data;\n\tunsigned long flags;\n\n\t--(mts->open_count);\n\tif (mts->open_count == 0) {\n\t\t \n\t\tspin_lock_irqsave(&mts->lock, flags);\n\t\tmts64_device_close(mts);\n\t\tspin_unlock_irqrestore(&mts->lock, flags);\n\n\t\tmsleep(500);\n\n\t} else if (mts->open_count < 0)\n\t\tmts->open_count = 0;\n\n\treturn 0;\n}\n\nstatic void snd_mts64_rawmidi_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t     int up)\n{\n\tstruct mts64 *mts = substream->rmidi->private_data;\n\tu8 data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mts->lock, flags);\n\twhile (snd_rawmidi_transmit_peek(substream, &data, 1) == 1) {\n\t\tmts64_write_midi(mts, data, substream->number+1);\n\t\tsnd_rawmidi_transmit_ack(substream, 1);\n\t}\n\tspin_unlock_irqrestore(&mts->lock, flags);\n}\n\nstatic void snd_mts64_rawmidi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t    int up)\n{\n\tstruct mts64 *mts = substream->rmidi->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mts->lock, flags);\n\tif (up)\n\t\tmts->mode[substream->number] |= MTS64_MODE_INPUT_TRIGGERED;\n\telse\n \t\tmts->mode[substream->number] &= ~MTS64_MODE_INPUT_TRIGGERED;\n\t\n\tspin_unlock_irqrestore(&mts->lock, flags);\n}\n\nstatic const struct snd_rawmidi_ops snd_mts64_rawmidi_output_ops = {\n\t.open    = snd_mts64_rawmidi_open,\n\t.close   = snd_mts64_rawmidi_close,\n\t.trigger = snd_mts64_rawmidi_output_trigger\n};\n\nstatic const struct snd_rawmidi_ops snd_mts64_rawmidi_input_ops = {\n\t.open    = snd_mts64_rawmidi_open,\n\t.close   = snd_mts64_rawmidi_close,\n\t.trigger = snd_mts64_rawmidi_input_trigger\n};\n\n \nstatic int snd_mts64_rawmidi_create(struct snd_card *card)\n{\n\tstruct mts64 *mts = card->private_data;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *substream;\n\tstruct list_head *list;\n\tint err;\n\t\n\terr = snd_rawmidi_new(card, CARD_NAME, 0, \n\t\t\t      MTS64_NUM_OUTPUT_PORTS, \n\t\t\t      MTS64_NUM_INPUT_PORTS, \n\t\t\t      &rmidi);\n\tif (err < 0) \n\t\treturn err;\n\n\trmidi->private_data = mts;\n\tstrcpy(rmidi->name, CARD_NAME);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t            SNDRV_RAWMIDI_INFO_INPUT |\n                            SNDRV_RAWMIDI_INFO_DUPLEX;\n\n\tmts->rmidi = rmidi;\n\n\t \n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, \n\t\t\t    &snd_mts64_rawmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, \n\t\t\t    &snd_mts64_rawmidi_input_ops);\n\n\t \n\t \n\tlist_for_each(list, \n\t\t      &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {\n\t\tsubstream = list_entry(list, struct snd_rawmidi_substream, list);\n\t\tsprintf(substream->name,\n\t\t\t\"Miditerminal %d\", substream->number+1);\n\t}\n\t \n\tlist_for_each(list, \n\t\t      &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {\n\t\tsubstream = list_entry(list, struct snd_rawmidi_substream, list);\n\t\tmts->midi_input_substream[substream->number] = substream;\n\t\tswitch(substream->number) {\n\t\tcase MTS64_SMPTE_SUBSTREAM:\n\t\t\tstrcpy(substream->name, \"Miditerminal SMPTE\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(substream->name,\n\t\t\t\t\"Miditerminal %d\", substream->number+1);\n\t\t}\n\t}\n\n\t \n\terr = snd_mts64_ctl_create(card, mts);\n\n\treturn err;\n}\n\n \nstatic void snd_mts64_interrupt(void *private)\n{\n\tstruct mts64 *mts = ((struct snd_card*)private)->private_data;\n\tu16 ret;\n\tu8 status, data;\n\tstruct snd_rawmidi_substream *substream;\n\n\tif (!mts)\n\t\treturn;\n\n\tspin_lock(&mts->lock);\n\tret = mts64_read(mts->pardev->port);\n\tdata = ret & 0x00ff;\n\tstatus = ret >> 8;\n\n\tif (status & MTS64_STAT_PORT) {\n\t\tmts->current_midi_input_port = mts64_map_midi_input(data);\n\t} else {\n\t\tif (mts->current_midi_input_port == -1) \n\t\t\tgoto __out;\n\t\tsubstream = mts->midi_input_substream[mts->current_midi_input_port];\n\t\tif (mts->mode[substream->number] & MTS64_MODE_INPUT_TRIGGERED)\n\t\t\tsnd_rawmidi_receive(substream, &data, 1);\n\t}\n__out:\n\tspin_unlock(&mts->lock);\n}\n\nstatic void snd_mts64_attach(struct parport *p)\n{\n\tstruct platform_device *device;\n\n\tdevice = platform_device_alloc(PLATFORM_DRIVER, device_count);\n\tif (!device)\n\t\treturn;\n\n\t \n\tplatform_set_drvdata(device, p);\n\n\tif (platform_device_add(device) < 0) {\n\t\tplatform_device_put(device);\n\t\treturn;\n\t}\n\n\t \n\tif (!platform_get_drvdata(device)) {\n\t\tplatform_device_unregister(device);\n\t\treturn;\n\t}\n\n\t \n\tplatform_devices[device_count] = device;\n\tdevice_count++;\n}\n\nstatic void snd_mts64_detach(struct parport *p)\n{\n\t \n}\n\nstatic int snd_mts64_dev_probe(struct pardevice *pardev)\n{\n\tif (strcmp(pardev->name, DRIVER_NAME))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver mts64_parport_driver = {\n\t.name\t\t= \"mts64\",\n\t.probe\t\t= snd_mts64_dev_probe,\n\t.match_port\t= snd_mts64_attach,\n\t.detach\t\t= snd_mts64_detach,\n\t.devmodel\t= true,\n};\n\n \nstatic void snd_mts64_card_private_free(struct snd_card *card)\n{\n\tstruct mts64 *mts = card->private_data;\n\tstruct pardevice *pardev = mts->pardev;\n\n\tif (pardev) {\n\t\tparport_release(pardev);\n\t\tparport_unregister_device(pardev);\n\t}\n\n\tsnd_mts64_free(mts);\n}\n\nstatic int snd_mts64_probe(struct platform_device *pdev)\n{\n\tstruct pardevice *pardev;\n\tstruct parport *p;\n\tint dev = pdev->id;\n\tstruct snd_card *card = NULL;\n\tstruct mts64 *mts = NULL;\n\tint err;\n\tstruct pardev_cb mts64_cb = {\n\t\t.preempt = NULL,\n\t\t.wakeup = NULL,\n\t\t.irq_func = snd_mts64_interrupt,\t \n\t\t.flags = PARPORT_DEV_EXCL,\t\t \n\t};\n\n\tp = platform_get_drvdata(pdev);\n\tplatform_set_drvdata(pdev, NULL);\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) \n\t\treturn -ENOENT;\n\n\terr = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot create card\\n\");\n\t\treturn err;\n\t}\n\tstrcpy(card->driver, DRIVER_NAME);\n\tstrcpy(card->shortname, \"ESI \" CARD_NAME);\n\tsprintf(card->longname,  \"%s at 0x%lx, irq %i\", \n\t\tcard->shortname, p->base, p->irq);\n\n\tmts64_cb.private = card;\t\t\t  \n\tpardev = parport_register_dev_model(p,\t\t  \n\t\t\t\t\t    DRIVER_NAME,  \n\t\t\t\t\t    &mts64_cb,\t  \n\t\t\t\t\t    pdev->id);\t  \n\tif (!pardev) {\n\t\tsnd_printd(\"Cannot register pardevice\\n\");\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\n\t \n\tif (parport_claim(pardev)) {\n\t\tsnd_printd(\"Cannot claim parport 0x%lx\\n\", pardev->port->base);\n\t\terr = -EIO;\n\t\tgoto free_pardev;\n\t}\n\n\terr = snd_mts64_create(card, pardev, &mts);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot create main component\\n\");\n\t\tgoto release_pardev;\n\t}\n\tcard->private_data = mts;\n\tcard->private_free = snd_mts64_card_private_free;\n\n\terr = mts64_probe(p);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto __err;\n\t}\n\t\n\terr = snd_mts64_rawmidi_create(card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Creating Rawmidi component failed\\n\");\n\t\tgoto __err;\n\t}\n\n\t \n\terr = mts64_device_init(p);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tplatform_set_drvdata(pdev, card);\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tsnd_printd(\"Cannot register card\\n\");\n\t\tgoto __err;\n\t}\n\n\tsnd_printk(KERN_INFO \"ESI Miditerminal 4140 on 0x%lx\\n\", p->base);\n\treturn 0;\n\nrelease_pardev:\n\tparport_release(pardev);\nfree_pardev:\n\tparport_unregister_device(pardev);\n__err:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_mts64_remove(struct platform_device *pdev)\n{\n\tstruct snd_card *card = platform_get_drvdata(pdev);\n\n\tif (card)\n\t\tsnd_card_free(card);\n}\n\nstatic struct platform_driver snd_mts64_driver = {\n\t.probe  = snd_mts64_probe,\n\t.remove_new = snd_mts64_remove,\n\t.driver = {\n\t\t.name = PLATFORM_DRIVER,\n\t}\n};\n\n \nstatic void snd_mts64_unregister_all(void)\n{\n\tint i;\n\n\tfor (i = 0; i < SNDRV_CARDS; ++i) {\n\t\tif (platform_devices[i]) {\n\t\t\tplatform_device_unregister(platform_devices[i]);\n\t\t\tplatform_devices[i] = NULL;\n\t\t}\n\t}\t\t\n\tplatform_driver_unregister(&snd_mts64_driver);\n\tparport_unregister_driver(&mts64_parport_driver);\n}\n\nstatic int __init snd_mts64_module_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&snd_mts64_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (parport_register_driver(&mts64_parport_driver) != 0) {\n\t\tplatform_driver_unregister(&snd_mts64_driver);\n\t\treturn -EIO;\n\t}\n\n\tif (device_count == 0) {\n\t\tsnd_mts64_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit snd_mts64_module_exit(void)\n{\n\tsnd_mts64_unregister_all();\n}\n\nmodule_init(snd_mts64_module_init);\nmodule_exit(snd_mts64_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}