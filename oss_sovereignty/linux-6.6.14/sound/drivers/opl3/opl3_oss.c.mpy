{
  "module_name": "opl3_oss.c",
  "hash_id": "e97aa18848fd7a6a6d6314b338b25f44a6bf22fb5c7baa0c4306c382c4952255",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl3/opl3_oss.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include \"opl3_voice.h\"\n\nstatic int snd_opl3_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure);\nstatic int snd_opl3_close_seq_oss(struct snd_seq_oss_arg *arg);\nstatic int snd_opl3_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd, unsigned long ioarg);\nstatic int snd_opl3_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format, const char __user *buf, int offs, int count);\nstatic int snd_opl3_reset_seq_oss(struct snd_seq_oss_arg *arg);\n\n \n\nstatic const struct snd_seq_oss_callback oss_callback = {\n\t.owner = \tTHIS_MODULE,\n\t.open =\t\tsnd_opl3_open_seq_oss,\n\t.close =\tsnd_opl3_close_seq_oss,\n\t.ioctl =\tsnd_opl3_ioctl_seq_oss,\n\t.load_patch =\tsnd_opl3_load_patch_seq_oss,\n\t.reset =\tsnd_opl3_reset_seq_oss,\n};\n\nstatic int snd_opl3_oss_event_input(struct snd_seq_event *ev, int direct,\n\t\t\t\t    void *private_data, int atomic, int hop)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\n\tif (ev->type != SNDRV_SEQ_EVENT_OSS)\n\t\tsnd_midi_process_event(&opl3_ops, ev, opl3->oss_chset);\n\treturn 0;\n}\n\n \n\nstatic void snd_opl3_oss_free_port(void *private_data)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\n\tsnd_midi_channel_free_set(opl3->oss_chset);\n}\n\nstatic int snd_opl3_oss_create_port(struct snd_opl3 * opl3)\n{\n\tstruct snd_seq_port_callback callbacks;\n\tchar name[32];\n\tint voices, opl_ver;\n\n\tvoices = (opl3->hardware < OPL3_HW_OPL3) ?\n\t\tMAX_OPL2_VOICES : MAX_OPL3_VOICES;\n\topl3->oss_chset = snd_midi_channel_alloc_set(voices);\n\tif (opl3->oss_chset == NULL)\n\t\treturn -ENOMEM;\n\topl3->oss_chset->private_data = opl3;\n\n\tmemset(&callbacks, 0, sizeof(callbacks));\n\tcallbacks.owner = THIS_MODULE;\n\tcallbacks.event_input = snd_opl3_oss_event_input;\n\tcallbacks.private_free = snd_opl3_oss_free_port;\n\tcallbacks.private_data = opl3;\n\n\topl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\n\tsprintf(name, \"OPL%i OSS Port\", opl_ver);\n\n\topl3->oss_chset->client = opl3->seq_client;\n\topl3->oss_chset->port = snd_seq_event_port_attach(opl3->seq_client, &callbacks,\n\t\t\t\t\t\t\t  SNDRV_SEQ_PORT_CAP_WRITE,\n\t\t\t\t\t\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\t\t\t\t\t\t  SNDRV_SEQ_PORT_TYPE_MIDI_GM |\n\t\t\t\t\t\t\t  SNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\t\t\t\t\t\t  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\n\t\t\t\t\t\t\t  voices, voices,\n\t\t\t\t\t\t\t  name);\n\tif (opl3->oss_chset->port < 0) {\n\t\tint port;\n\t\tport = opl3->oss_chset->port;\n\t\tsnd_midi_channel_free_set(opl3->oss_chset);\n\t\treturn port;\n\t}\n\treturn 0;\n}\n\n \n\n \nvoid snd_opl3_init_seq_oss(struct snd_opl3 *opl3, char *name)\n{\n\tstruct snd_seq_oss_reg *arg;\n\tstruct snd_seq_device *dev;\n\n\tif (snd_seq_device_new(opl3->card, 0, SNDRV_SEQ_DEV_ID_OSS,\n\t\t\t       sizeof(struct snd_seq_oss_reg), &dev) < 0)\n\t\treturn;\n\n\topl3->oss_seq_dev = dev;\n\tstrscpy(dev->name, name, sizeof(dev->name));\n\targ = SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\targ->type = SYNTH_TYPE_FM;\n\tif (opl3->hardware < OPL3_HW_OPL3) {\n\t\targ->subtype = FM_TYPE_ADLIB;\n\t\targ->nvoices = MAX_OPL2_VOICES;\n\t} else {\n\t\targ->subtype = FM_TYPE_OPL3;\n\t\targ->nvoices = MAX_OPL3_VOICES;\n\t}\n\targ->oper = oss_callback;\n\targ->private_data = opl3;\n\n\tif (snd_opl3_oss_create_port(opl3)) {\n\t\t \n\t\tsnd_device_register(opl3->card, dev);\n\t}\n}\n\n \nvoid snd_opl3_free_seq_oss(struct snd_opl3 *opl3)\n{\n\tif (opl3->oss_seq_dev) {\n\t\t \n\t\topl3->oss_seq_dev = NULL;\n\t}\n}\n\n \n\n \nstatic int snd_opl3_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)\n{\n\tstruct snd_opl3 *opl3 = closure;\n\tint err;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\n\terr = snd_opl3_synth_setup(opl3);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\targ->private_data = opl3;\n\targ->addr.client = opl3->oss_chset->client;\n\targ->addr.port = opl3->oss_chset->port;\n\n\terr = snd_opl3_synth_use_inc(opl3);\n\tif (err < 0)\n\t\treturn err;\n\n\topl3->synth_mode = SNDRV_OPL3_MODE_SYNTH;\n\treturn 0;\n}\n\n \nstatic int snd_opl3_close_seq_oss(struct snd_seq_oss_arg *arg)\n{\n\tstruct snd_opl3 *opl3;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\topl3 = arg->private_data;\n\n\tsnd_opl3_synth_cleanup(opl3);\n\n\tsnd_opl3_synth_use_dec(opl3);\n\treturn 0;\n}\n\n \n\n \n#define SBFM_MAXINSTR\t256\n\nstatic int snd_opl3_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,\n\t\t\t\t       const char __user *buf, int offs, int count)\n{\n\tstruct snd_opl3 *opl3;\n\tstruct sbi_instrument sbi;\n\tchar name[32];\n\tint err, type;\n\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\topl3 = arg->private_data;\n\n\tif (format == FM_PATCH)\n\t\ttype = FM_PATCH_OPL2;\n\telse if (format == OPL3_PATCH)\n\t\ttype = FM_PATCH_OPL3;\n\telse\n\t\treturn -EINVAL;\n\n\tif (count < (int)sizeof(sbi)) {\n\t\tsnd_printk(KERN_ERR \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (copy_from_user(&sbi, buf, sizeof(sbi)))\n\t\treturn -EFAULT;\n\n\tif (sbi.channel < 0 || sbi.channel >= SBFM_MAXINSTR) {\n\t\tsnd_printk(KERN_ERR \"FM Error: Invalid instrument number %d\\n\",\n\t\t\t   sbi.channel);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(name, 0, sizeof(name));\n\tsprintf(name, \"Chan%d\", sbi.channel);\n\n\terr = snd_opl3_load_patch(opl3, sbi.channel, 127, type, name, NULL,\n\t\t\t\t  sbi.operators);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sizeof(sbi);\n}\n\n \nstatic int snd_opl3_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd,\n\t\t\t\t  unsigned long ioarg)\n{\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\t\tcase SNDCTL_FM_LOAD_INSTR:\n\t\t\tsnd_printk(KERN_ERR \"OPL3: \"\n\t\t\t\t   \"Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. \"\n\t\t\t\t   \"Fix the program.\\n\");\n\t\t\treturn -EINVAL;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\treturn 0x7fffffff;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\t\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int snd_opl3_reset_seq_oss(struct snd_seq_oss_arg *arg)\n{\n\tif (snd_BUG_ON(!arg))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}