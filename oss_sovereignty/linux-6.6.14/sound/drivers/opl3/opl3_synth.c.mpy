{
  "module_name": "opl3_synth.c",
  "hash_id": "56f0c3681df3058f198ac8a06699e6525d5b5661c3d6716caf864a1bd58af126",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl3/opl3_synth.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/nospec.h>\n#include <sound/opl3.h>\n#include <sound/asound_fm.h>\n#include \"opl3_voice.h\"\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n#define OPL3_SUPPORT_SYNTH\n#endif\n\n \n\n\n \n\nchar snd_opl3_regmap[MAX_OPL2_VOICES][4] =\n{\n \n \n\t{ 0x00, 0x03, 0x08, 0x0b },\n\t{ 0x01, 0x04, 0x09, 0x0c },\n\t{ 0x02, 0x05, 0x0a, 0x0d },\n\n\t{ 0x08, 0x0b, 0x00, 0x00 },\n\t{ 0x09, 0x0c, 0x00, 0x00 },\n\t{ 0x0a, 0x0d, 0x00, 0x00 },\n\n\t{ 0x10, 0x13, 0x00, 0x00 },\t \n\t{ 0x11, 0x14, 0x00, 0x00 },\t \n\t{ 0x12, 0x15, 0x00, 0x00 }\t \n};\n\nEXPORT_SYMBOL(snd_opl3_regmap);\n\n \nstatic int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note);\nstatic int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * voice);\nstatic int snd_opl3_set_params(struct snd_opl3 * opl3, struct snd_dm_fm_params * params);\nstatic int snd_opl3_set_mode(struct snd_opl3 * opl3, int mode);\nstatic int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection);\n\n \n\n \nint snd_opl3_open(struct snd_hwdep * hw, struct file *file)\n{\n\treturn 0;\n}\n\n \nint snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,\n\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_opl3 *opl3 = hw->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (snd_BUG_ON(!opl3))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\t\t \n\tcase SNDRV_DM_FM_IOCTL_INFO:\n\t\t{\n\t\t\tstruct snd_dm_fm_info info;\n\n\t\t\tmemset(&info, 0, sizeof(info));\n\n\t\t\tinfo.fm_mode = opl3->fm_mode;\n\t\t\tinfo.rhythm = opl3->rhythm;\n\t\t\tif (copy_to_user(argp, &info, sizeof(struct snd_dm_fm_info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\tcase SNDRV_DM_FM_IOCTL_RESET:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_RESET:\n#endif\n\t\tsnd_opl3_reset(opl3);\n\t\treturn 0;\n\n\tcase SNDRV_DM_FM_IOCTL_PLAY_NOTE:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE:\n#endif\n\t\t{\n\t\t\tstruct snd_dm_fm_note note;\n\t\t\tif (copy_from_user(&note, argp, sizeof(struct snd_dm_fm_note)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn snd_opl3_play_note(opl3, &note);\n\t\t}\n\n\tcase SNDRV_DM_FM_IOCTL_SET_VOICE:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_SET_VOICE:\n#endif\n\t\t{\n\t\t\tstruct snd_dm_fm_voice voice;\n\t\t\tif (copy_from_user(&voice, argp, sizeof(struct snd_dm_fm_voice)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn snd_opl3_set_voice(opl3, &voice);\n\t\t}\n\n\tcase SNDRV_DM_FM_IOCTL_SET_PARAMS:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS:\n#endif\n\t\t{\n\t\t\tstruct snd_dm_fm_params params;\n\t\t\tif (copy_from_user(&params, argp, sizeof(struct snd_dm_fm_params)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn snd_opl3_set_params(opl3, &params);\n\t\t}\n\n\tcase SNDRV_DM_FM_IOCTL_SET_MODE:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_SET_MODE:\n#endif\n\t\treturn snd_opl3_set_mode(opl3, (int) arg);\n\n\tcase SNDRV_DM_FM_IOCTL_SET_CONNECTION:\n#ifdef CONFIG_SND_OSSEMUL\n\tcase SNDRV_DM_FM_OSS_IOCTL_SET_OPL:\n#endif\n\t\treturn snd_opl3_set_connection(opl3, (int) arg);\n\n#ifdef OPL3_SUPPORT_SYNTH\n\tcase SNDRV_DM_FM_IOCTL_CLEAR_PATCHES:\n\t\tsnd_opl3_clear_patches(opl3);\n\t\treturn 0;\n#endif\n\n#ifdef CONFIG_SND_DEBUG\n\tdefault:\n\t\tsnd_printk(KERN_WARNING \"unknown IOCTL: 0x%x\\n\", cmd);\n#endif\n\t}\n\treturn -ENOTTY;\n}\n\n \nint snd_opl3_release(struct snd_hwdep * hw, struct file *file)\n{\n\tstruct snd_opl3 *opl3 = hw->private_data;\n\n\tsnd_opl3_reset(opl3);\n\treturn 0;\n}\n\n#ifdef OPL3_SUPPORT_SYNTH\n \nlong snd_opl3_write(struct snd_hwdep *hw, const char __user *buf, long count,\n\t\t    loff_t *offset)\n{\n\tstruct snd_opl3 *opl3 = hw->private_data;\n\tlong result = 0;\n\tint err = 0;\n\tstruct sbi_patch inst;\n\n\twhile (count >= sizeof(inst)) {\n\t\tunsigned char type;\n\t\tif (copy_from_user(&inst, buf, sizeof(inst)))\n\t\t\treturn -EFAULT;\n\t\tif (!memcmp(inst.key, FM_KEY_SBI, 4) ||\n\t\t    !memcmp(inst.key, FM_KEY_2OP, 4))\n\t\t\ttype = FM_PATCH_OPL2;\n\t\telse if (!memcmp(inst.key, FM_KEY_4OP, 4))\n\t\t\ttype = FM_PATCH_OPL3;\n\t\telse  \n\t\t\tbreak;\n\t\terr = snd_opl3_load_patch(opl3, inst.prog, inst.bank, type,\n\t\t\t\t\t  inst.name, inst.extension,\n\t\t\t\t\t  inst.data);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tresult += sizeof(inst);\n\t\tcount -= sizeof(inst);\n\t}\n\treturn result > 0 ? result : err;\n}\n\n\n \n\n \n#define AM_VIB\t\t0\n#define KSL_LEVEL\t2\n#define ATTACK_DECAY\t4\n#define SUSTAIN_RELEASE\t6\n#define WAVE_SELECT\t8\n\n \n#define CONNECTION\t10\n#define OFFSET_4OP\t11\n\n \nint snd_opl3_load_patch(struct snd_opl3 *opl3,\n\t\t\tint prog, int bank, int type,\n\t\t\tconst char *name,\n\t\t\tconst unsigned char *ext,\n\t\t\tconst unsigned char *data)\n{\n\tstruct fm_patch *patch;\n\tint i;\n\n\tpatch = snd_opl3_find_patch(opl3, prog, bank, 1);\n\tif (!patch)\n\t\treturn -ENOMEM;\n\n\tpatch->type = type;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tpatch->inst.op[i].am_vib = data[AM_VIB + i];\n\t\tpatch->inst.op[i].ksl_level = data[KSL_LEVEL + i];\n\t\tpatch->inst.op[i].attack_decay = data[ATTACK_DECAY + i];\n\t\tpatch->inst.op[i].sustain_release = data[SUSTAIN_RELEASE + i];\n\t\tpatch->inst.op[i].wave_select = data[WAVE_SELECT + i];\n\t}\n\tpatch->inst.feedback_connection[0] = data[CONNECTION];\n\n\tif (type == FM_PATCH_OPL3) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tpatch->inst.op[i+2].am_vib =\n\t\t\t\tdata[OFFSET_4OP + AM_VIB + i];\n\t\t\tpatch->inst.op[i+2].ksl_level =\n\t\t\t\tdata[OFFSET_4OP + KSL_LEVEL + i];\n\t\t\tpatch->inst.op[i+2].attack_decay =\n\t\t\t\tdata[OFFSET_4OP + ATTACK_DECAY + i];\n\t\t\tpatch->inst.op[i+2].sustain_release =\n\t\t\t\tdata[OFFSET_4OP + SUSTAIN_RELEASE + i];\n\t\t\tpatch->inst.op[i+2].wave_select =\n\t\t\t\tdata[OFFSET_4OP + WAVE_SELECT + i];\n\t\t}\n\t\tpatch->inst.feedback_connection[1] =\n\t\t\tdata[OFFSET_4OP + CONNECTION];\n\t}\n\n\tif (ext) {\n\t\tpatch->inst.echo_delay = ext[0];\n\t\tpatch->inst.echo_atten = ext[1];\n\t\tpatch->inst.chorus_spread = ext[2];\n\t\tpatch->inst.trnsps = ext[3];\n\t\tpatch->inst.fix_dur = ext[4];\n\t\tpatch->inst.modes = ext[5];\n\t\tpatch->inst.fix_key = ext[6];\n\t}\n\n\tif (name)\n\t\tstrscpy(patch->name, name, sizeof(patch->name));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_opl3_load_patch);\n\n \nstruct fm_patch *snd_opl3_find_patch(struct snd_opl3 *opl3, int prog, int bank,\n\t\t\t\t     int create_patch)\n{\n\t \n\tunsigned int key = (prog + bank) % OPL3_PATCH_HASH_SIZE;\n\tstruct fm_patch *patch;\n\n\tfor (patch = opl3->patch_table[key]; patch; patch = patch->next) {\n\t\tif (patch->prog == prog && patch->bank == bank)\n\t\t\treturn patch;\n\t}\n\tif (!create_patch)\n\t\treturn NULL;\n\n\tpatch = kzalloc(sizeof(*patch), GFP_KERNEL);\n\tif (!patch)\n\t\treturn NULL;\n\tpatch->prog = prog;\n\tpatch->bank = bank;\n\tpatch->next = opl3->patch_table[key];\n\topl3->patch_table[key] = patch;\n\treturn patch;\n}\nEXPORT_SYMBOL(snd_opl3_find_patch);\n\n \nvoid snd_opl3_clear_patches(struct snd_opl3 *opl3)\n{\n\tint i;\n\tfor (i = 0; i <  OPL3_PATCH_HASH_SIZE; i++) {\n\t\tstruct fm_patch *patch, *next;\n\t\tfor (patch = opl3->patch_table[i]; patch; patch = next) {\n\t\t\tnext = patch->next;\n\t\t\tkfree(patch);\n\t\t}\n\t}\n\tmemset(opl3->patch_table, 0, sizeof(opl3->patch_table));\n}\n#endif  \n\n \n\nvoid snd_opl3_reset(struct snd_opl3 * opl3)\n{\n\tunsigned short opl3_reg;\n\n\tunsigned short reg_side;\n\tunsigned char voice_offset;\n\n\tint max_voices, i;\n\n\tmax_voices = (opl3->hardware < OPL3_HW_OPL3) ?\n\t\tMAX_OPL2_VOICES : MAX_OPL3_VOICES;\n\n\tfor (i = 0; i < max_voices; i++) {\n\t\t \n\t\tif (i < MAX_OPL2_VOICES) {\n\t\t\t \n\t\t\treg_side = OPL3_LEFT;\n\t\t\tvoice_offset = i;\n\t\t} else {\n\t\t\t \n\t\t\treg_side = OPL3_RIGHT;\n\t\t\tvoice_offset = i - MAX_OPL2_VOICES;\n\t\t}\n\t\topl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][0]);\n\t\topl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK);  \n\t\topl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][1]);\n\t\topl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK);  \n\n\t\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\t\topl3->command(opl3, opl3_reg, 0x00);\t \n\t}\n\n\topl3->max_voices = MAX_OPL2_VOICES;\n\topl3->fm_mode = SNDRV_DM_FM_MODE_OPL2;\n\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);\t \n\topl3->rhythm = 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_reset);\n\nstatic int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note)\n{\n\tunsigned short reg_side;\n\tunsigned char voice_offset;\n\n\tunsigned short opl3_reg;\n\tunsigned char reg_val;\n\n\t \n\t \n\tif (note->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?\n\t\t\t    MAX_OPL3_VOICES : MAX_OPL2_VOICES))\n\t\treturn -EINVAL;\n\n\t \n\tif (note->voice < MAX_OPL2_VOICES) {\n\t\t \n\t\treg_side = OPL3_LEFT;\n\t\tvoice_offset = note->voice;\n\t} else {\n\t\t \n\t\treg_side = OPL3_RIGHT;\n\t\tvoice_offset = note->voice - MAX_OPL2_VOICES;\n\t}\n\n\t \n\treg_val = (unsigned char) note->fnum;\n\topl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\t\n\treg_val = 0x00;\n\t \n\tif (note->key_on)\n\t\treg_val |= OPL3_KEYON_BIT;\n\t \n\treg_val |= (note->octave << 2) & OPL3_BLOCKNUM_MASK;\n\t \n\treg_val |= (unsigned char) (note->fnum >> 8) & OPL3_FNUM_HIGH_MASK;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\treturn 0;\n}\n\n\nstatic int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * voice)\n{\n\tunsigned short reg_side;\n\tunsigned char op_offset;\n\tunsigned char voice_offset, voice_op;\n\n\tunsigned short opl3_reg;\n\tunsigned char reg_val;\n\n\t \n\tif (voice->op > 1)\n\t\treturn -EINVAL;\n\t \n\t \n\tif (voice->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?\n\t\t\t     MAX_OPL3_VOICES : MAX_OPL2_VOICES))\n\t\treturn -EINVAL;\n\n\t \n\tif (voice->voice < MAX_OPL2_VOICES) {\n\t\t \n\t\treg_side = OPL3_LEFT;\n\t\tvoice_offset = voice->voice;\n\t} else {\n\t\t \n\t\treg_side = OPL3_RIGHT;\n\t\tvoice_offset = voice->voice - MAX_OPL2_VOICES;\n\t}\n\t \n\tvoice_offset = array_index_nospec(voice_offset, MAX_OPL2_VOICES);\n\tvoice_op = array_index_nospec(voice->op, 4);\n\top_offset = snd_opl3_regmap[voice_offset][voice_op];\n\n\treg_val = 0x00;\n\t \n\tif (voice->am)\n\t\treg_val |= OPL3_TREMOLO_ON;\n\t \n\tif (voice->vibrato)\n\t\treg_val |= OPL3_VIBRATO_ON;\n\t \n\tif (voice->do_sustain)\n\t\treg_val |= OPL3_SUSTAIN_ON;\n\t  \n\tif (voice->kbd_scale)\n\t\treg_val |= OPL3_KSR;\n\t \n\treg_val |= voice->harmonic & OPL3_MULTIPLE_MASK;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\t \n\treg_val = (voice->scale_level << 6) & OPL3_KSL_MASK;\n\t \n\treg_val |= ~voice->volume & OPL3_TOTAL_LEVEL_MASK;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\t \n\treg_val = (voice->attack << 4) & OPL3_ATTACK_MASK;\n\t \n\treg_val |= voice->decay & OPL3_DECAY_MASK;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\t \n\treg_val = (voice->sustain << 4) & OPL3_SUSTAIN_MASK;\n\t \n\treg_val |= voice->release & OPL3_RELEASE_MASK;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\t \n\treg_val = (voice->feedback << 1) & OPL3_FEEDBACK_MASK;\n\t \n\tif (voice->connection)\n\t\treg_val |= OPL3_CONNECTION_BIT;\n\t \n\tif (opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) {\n\t\tif (voice->left)\n\t\t\treg_val |= OPL3_VOICE_TO_LEFT;\n\t\tif (voice->right)\n\t\t\treg_val |= OPL3_VOICE_TO_RIGHT;\n\t}\n\t \n\topl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\t \n\treg_val = voice->waveform & OPL3_WAVE_SELECT_MASK;\n\topl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\treturn 0;\n}\n\nstatic int snd_opl3_set_params(struct snd_opl3 * opl3, struct snd_dm_fm_params * params)\n{\n\tunsigned char reg_val;\n\n\treg_val = 0x00;\n\t \n\tif (params->kbd_split)\n\t\treg_val |= OPL3_KEYBOARD_SPLIT;\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_KBD_SPLIT, reg_val);\n\n\treg_val = 0x00;\n\t \n\tif (params->am_depth)\n\t\treg_val |= OPL3_TREMOLO_DEPTH;\n\t \n\tif (params->vib_depth)\n\t\treg_val |= OPL3_VIBRATO_DEPTH;\n\t \n\tif (params->rhythm) {\n\t\treg_val |= OPL3_PERCUSSION_ENABLE;\n\t\topl3->rhythm = 1;\n\t} else {\n\t\topl3->rhythm = 0;\n\t}\n\t \n\tif (params->bass)\n\t\treg_val |= OPL3_BASSDRUM_ON;\n\tif (params->snare)\n\t\treg_val |= OPL3_SNAREDRUM_ON;\n\tif (params->tomtom)\n\t\treg_val |= OPL3_TOMTOM_ON;\n\tif (params->cymbal)\n\t\treg_val |= OPL3_CYMBAL_ON;\n\tif (params->hihat)\n\t\treg_val |= OPL3_HIHAT_ON;\n\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, reg_val);\n\treturn 0;\n}\n\nstatic int snd_opl3_set_mode(struct snd_opl3 * opl3, int mode)\n{\n\tif ((mode == SNDRV_DM_FM_MODE_OPL3) && (opl3->hardware < OPL3_HW_OPL3))\n\t\treturn -EINVAL;\n\n\topl3->fm_mode = mode;\n\tif (opl3->hardware >= OPL3_HW_OPL3)\n\t\topl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, 0x00);\t \n\n\treturn 0;\n}\n\nstatic int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection)\n{\n\tunsigned char reg_val;\n\n\t \n\tif (opl3->fm_mode != SNDRV_DM_FM_MODE_OPL3)\n\t\treturn -EINVAL;\n\n\treg_val = connection & (OPL3_RIGHT_4OP_0 | OPL3_RIGHT_4OP_1 | OPL3_RIGHT_4OP_2 |\n\t\t\t\tOPL3_LEFT_4OP_0 | OPL3_LEFT_4OP_1 | OPL3_LEFT_4OP_2);\n\t \n\topl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, reg_val);\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}