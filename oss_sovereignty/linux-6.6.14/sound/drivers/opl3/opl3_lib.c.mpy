{
  "module_name": "opl3_lib.c",
  "hash_id": "f07f41e93bd7f0710eaa546f52304edd9a7adf3875eb9ff686d6e82a5d4d493a",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl3/opl3_lib.c",
  "human_readable_source": "\n \n\n#include <sound/opl3.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <sound/minors.h>\n#include \"opl3_voice.h\"\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>, Hannu Savolainen 1993-1996, Rob Hooft\");\nMODULE_DESCRIPTION(\"Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void snd_opl2_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)\n{\n\tunsigned long flags;\n\tunsigned long port;\n\n\t \n\n\tport = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;\n\n\tspin_lock_irqsave(&opl3->reg_lock, flags);\n\n\toutb((unsigned char) cmd, port);\n\tudelay(10);\n\n\toutb((unsigned char) val, port + 1);\n\tudelay(30);\n\n\tspin_unlock_irqrestore(&opl3->reg_lock, flags);\n}\n\nstatic void snd_opl3_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)\n{\n\tunsigned long flags;\n\tunsigned long port;\n\n\t \n\n\tport = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;\n\n\tspin_lock_irqsave(&opl3->reg_lock, flags);\n\n\toutb((unsigned char) cmd, port);\n\tinb(opl3->l_port);\n\tinb(opl3->l_port);\n\n\toutb((unsigned char) val, port + 1);\n\tinb(opl3->l_port);\n\tinb(opl3->l_port);\n\n\tspin_unlock_irqrestore(&opl3->reg_lock, flags);\n}\n\nstatic int snd_opl3_detect(struct snd_opl3 * opl3)\n{\n\t \n\n\tunsigned char stat1, stat2, signature;\n\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);\n\tsignature = stat1 = inb(opl3->l_port);\t \n\tif ((stat1 & 0xe0) != 0x00) {\t \n\t\tsnd_printd(\"OPL3: stat1 = 0x%x\\n\", stat1);\n\t\treturn -ENODEV;\n\t}\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 0xff);\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER2_MASK | OPL3_TIMER1_START);\n\t \n\tudelay(200);\n\t \n\tstat2 = inb(opl3->l_port);\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);\n\tif ((stat2 & 0xe0) != 0xc0) {\t \n\t\tsnd_printd(\"OPL3: stat2 = 0x%x\\n\", stat2);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (opl3->hardware != OPL3_HW_AUTO)\n\t\treturn 0;\n\n\t \n\tif (signature == 0x06) {\t \n\t\topl3->hardware = OPL3_HW_OPL2;\n\t} else {\n\t\t \n\t\tif (snd_BUG_ON(!opl3->r_port))\n\t\t\treturn -ENODEV;\n\t\topl3->hardware = OPL3_HW_OPL3;\n\t}\n\treturn 0;\n}\n\n \n\n \n\nstatic int snd_opl3_timer1_start(struct snd_timer * timer)\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n\tunsigned int ticks;\n\tstruct snd_opl3 *opl3;\n\n\topl3 = snd_timer_chip(timer);\n\tspin_lock_irqsave(&opl3->timer_lock, flags);\n\tticks = timer->sticks;\n\ttmp = (opl3->timer_enable | OPL3_TIMER1_START) & ~OPL3_TIMER1_MASK;\n\topl3->timer_enable = tmp;\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 256 - ticks);\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\t \n\tspin_unlock_irqrestore(&opl3->timer_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_opl3_timer1_stop(struct snd_timer * timer)\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n\tstruct snd_opl3 *opl3;\n\n\topl3 = snd_timer_chip(timer);\n\tspin_lock_irqsave(&opl3->timer_lock, flags);\n\ttmp = (opl3->timer_enable | OPL3_TIMER1_MASK) & ~OPL3_TIMER1_START;\n\topl3->timer_enable = tmp;\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\t \n\tspin_unlock_irqrestore(&opl3->timer_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int snd_opl3_timer2_start(struct snd_timer * timer)\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n\tunsigned int ticks;\n\tstruct snd_opl3 *opl3;\n\n\topl3 = snd_timer_chip(timer);\n\tspin_lock_irqsave(&opl3->timer_lock, flags);\n\tticks = timer->sticks;\n\ttmp = (opl3->timer_enable | OPL3_TIMER2_START) & ~OPL3_TIMER2_MASK;\n\topl3->timer_enable = tmp;\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER2, 256 - ticks);\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\t \n\tspin_unlock_irqrestore(&opl3->timer_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_opl3_timer2_stop(struct snd_timer * timer)\n{\n\tunsigned long flags;\n\tunsigned char tmp;\n\tstruct snd_opl3 *opl3;\n\n\topl3 = snd_timer_chip(timer);\n\tspin_lock_irqsave(&opl3->timer_lock, flags);\n\ttmp = (opl3->timer_enable | OPL3_TIMER2_MASK) & ~OPL3_TIMER2_START;\n\topl3->timer_enable = tmp;\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);\t \n\tspin_unlock_irqrestore(&opl3->timer_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic const struct snd_timer_hardware snd_opl3_timer1 =\n{\n\t.flags =\tSNDRV_TIMER_HW_STOP,\n\t.resolution =\t80000,\n\t.ticks =\t256,\n\t.start =\tsnd_opl3_timer1_start,\n\t.stop =\t\tsnd_opl3_timer1_stop,\n};\n\nstatic const struct snd_timer_hardware snd_opl3_timer2 =\n{\n\t.flags =\tSNDRV_TIMER_HW_STOP,\n\t.resolution =\t320000,\n\t.ticks =\t256,\n\t.start =\tsnd_opl3_timer2_start,\n\t.stop =\t\tsnd_opl3_timer2_stop,\n};\n\nstatic int snd_opl3_timer1_init(struct snd_opl3 * opl3, int timer_no)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = opl3->card->number;\n\ttid.device = timer_no;\n\ttid.subdevice = 0;\n\terr = snd_timer_new(opl3->card, \"AdLib timer #1\", &tid, &timer);\n\tif (err >= 0) {\n\t\tstrcpy(timer->name, \"AdLib timer #1\");\n\t\ttimer->private_data = opl3;\n\t\ttimer->hw = snd_opl3_timer1;\n\t}\n\topl3->timer1 = timer;\n\treturn err;\n}\n\nstatic int snd_opl3_timer2_init(struct snd_opl3 * opl3, int timer_no)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = opl3->card->number;\n\ttid.device = timer_no;\n\ttid.subdevice = 0;\n\terr = snd_timer_new(opl3->card, \"AdLib timer #2\", &tid, &timer);\n\tif (err >= 0) {\n\t\tstrcpy(timer->name, \"AdLib timer #2\");\n\t\ttimer->private_data = opl3;\n\t\ttimer->hw = snd_opl3_timer2;\n\t}\n\topl3->timer2 = timer;\n\treturn err;\n}\n\n \n\nvoid snd_opl3_interrupt(struct snd_hwdep * hw)\n{\n\tunsigned char status;\n\tstruct snd_opl3 *opl3;\n\tstruct snd_timer *timer;\n\n\tif (hw == NULL)\n\t\treturn;\n\n\topl3 = hw->private_data;\n\tstatus = inb(opl3->l_port);\n#if 0\n\tsnd_printk(KERN_DEBUG \"AdLib IRQ status = 0x%x\\n\", status);\n#endif\n\tif (!(status & 0x80))\n\t\treturn;\n\n\tif (status & 0x40) {\n\t\ttimer = opl3->timer1;\n\t\tsnd_timer_interrupt(timer, timer->sticks);\n\t}\n\tif (status & 0x20) {\n\t\ttimer = opl3->timer2;\n\t\tsnd_timer_interrupt(timer, timer->sticks);\n\t}\n}\n\nEXPORT_SYMBOL(snd_opl3_interrupt);\n\n \n\nstatic int snd_opl3_free(struct snd_opl3 *opl3)\n{\n\tif (snd_BUG_ON(!opl3))\n\t\treturn -ENXIO;\n\tif (opl3->private_free)\n\t\topl3->private_free(opl3);\n\tsnd_opl3_clear_patches(opl3);\n\trelease_and_free_resource(opl3->res_l_port);\n\trelease_and_free_resource(opl3->res_r_port);\n\tkfree(opl3);\n\treturn 0;\n}\n\nstatic int snd_opl3_dev_free(struct snd_device *device)\n{\n\tstruct snd_opl3 *opl3 = device->device_data;\n\treturn snd_opl3_free(opl3);\n}\n\nint snd_opl3_new(struct snd_card *card,\n\t\t unsigned short hardware,\n\t\t struct snd_opl3 **ropl3)\n{\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_opl3_dev_free,\n\t};\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\t*ropl3 = NULL;\n\topl3 = kzalloc(sizeof(*opl3), GFP_KERNEL);\n\tif (!opl3)\n\t\treturn -ENOMEM;\n\n\topl3->card = card;\n\topl3->hardware = hardware;\n\tspin_lock_init(&opl3->reg_lock);\n\tspin_lock_init(&opl3->timer_lock);\n\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops);\n\tif (err < 0) {\n\t\tsnd_opl3_free(opl3);\n\t\treturn err;\n\t}\n\n\t*ropl3 = opl3;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_new);\n\nint snd_opl3_init(struct snd_opl3 *opl3)\n{\n\tif (! opl3->command) {\n\t\tprintk(KERN_ERR \"snd_opl3_init: command not defined!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);\n\t \n\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);\n\n\tswitch (opl3->hardware & OPL3_HW_MASK) {\n\tcase OPL3_HW_OPL2:\n\t\topl3->max_voices = MAX_OPL2_VOICES;\n\t\tbreak;\n\tcase OPL3_HW_OPL3:\n\tcase OPL3_HW_OPL4:\n\t\topl3->max_voices = MAX_OPL3_VOICES;\n\t\t \n\t\topl3->command(opl3, OPL3_RIGHT | OPL3_REG_MODE, OPL3_OPL3_ENABLE);\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_init);\n\nint snd_opl3_create(struct snd_card *card,\n\t\t    unsigned long l_port,\n\t\t    unsigned long r_port,\n\t\t    unsigned short hardware,\n\t\t    int integrated,\n\t\t    struct snd_opl3 ** ropl3)\n{\n\tstruct snd_opl3 *opl3;\n\tint err;\n\n\t*ropl3 = NULL;\n\terr = snd_opl3_new(card, hardware, &opl3);\n\tif (err < 0)\n\t\treturn err;\n\tif (! integrated) {\n\t\topl3->res_l_port = request_region(l_port, 2, \"OPL2/3 (left)\");\n\t\tif (!opl3->res_l_port) {\n\t\t\tsnd_printk(KERN_ERR \"opl3: can't grab left port 0x%lx\\n\", l_port);\n\t\t\tsnd_device_free(card, opl3);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (r_port != 0) {\n\t\t\topl3->res_r_port = request_region(r_port, 2, \"OPL2/3 (right)\");\n\t\t\tif (!opl3->res_r_port) {\n\t\t\t\tsnd_printk(KERN_ERR \"opl3: can't grab right port 0x%lx\\n\", r_port);\n\t\t\t\tsnd_device_free(card, opl3);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\topl3->l_port = l_port;\n\topl3->r_port = r_port;\n\n\tswitch (opl3->hardware) {\n\t \n\tcase OPL3_HW_OPL3_SV:\n\tcase OPL3_HW_OPL3_CS:\n\tcase OPL3_HW_OPL3_FM801:\n\t\topl3->command = &snd_opl3_command;\n\t\tbreak;\n\tdefault:\n\t\topl3->command = &snd_opl2_command;\n\t\terr = snd_opl3_detect(opl3);\n\t\tif (err < 0) {\n\t\t\tsnd_printd(\"OPL2/3 chip not detected at 0x%lx/0x%lx\\n\",\n\t\t\t\t   opl3->l_port, opl3->r_port);\n\t\t\tsnd_device_free(card, opl3);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tswitch (opl3->hardware & OPL3_HW_MASK) {\n\t\tcase OPL3_HW_OPL3:\n\t\tcase OPL3_HW_OPL4:\n\t\t\topl3->command = &snd_opl3_command;\n\t\t}\n\t}\n\n\tsnd_opl3_init(opl3);\n\n\t*ropl3 = opl3;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_create);\n\nint snd_opl3_timer_new(struct snd_opl3 * opl3, int timer1_dev, int timer2_dev)\n{\n\tint err;\n\n\tif (timer1_dev >= 0) {\n\t\terr = snd_opl3_timer1_init(opl3, timer1_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (timer2_dev >= 0) {\n\t\terr = snd_opl3_timer2_init(opl3, timer2_dev);\n\t\tif (err < 0) {\n\t\t\tsnd_device_free(opl3->card, opl3->timer1);\n\t\t\topl3->timer1 = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_timer_new);\n\nint snd_opl3_hwdep_new(struct snd_opl3 * opl3,\n\t\t       int device, int seq_device,\n\t\t       struct snd_hwdep ** rhwdep)\n{\n\tstruct snd_hwdep *hw;\n\tstruct snd_card *card = opl3->card;\n\tint err;\n\n\tif (rhwdep)\n\t\t*rhwdep = NULL;\n\n\t \n\n\terr = snd_hwdep_new(card, \"OPL2/OPL3\", device, &hw);\n\tif (err < 0) {\n\t\tsnd_device_free(card, opl3);\n\t\treturn err;\n\t}\n\thw->private_data = opl3;\n\thw->exclusive = 1;\n#ifdef CONFIG_SND_OSSEMUL\n\tif (device == 0)\n\t\thw->oss_type = SNDRV_OSS_DEVICE_TYPE_DMFM;\n#endif\n\tstrcpy(hw->name, hw->id);\n\tswitch (opl3->hardware & OPL3_HW_MASK) {\n\tcase OPL3_HW_OPL2:\n\t\tstrcpy(hw->name, \"OPL2 FM\");\n\t\thw->iface = SNDRV_HWDEP_IFACE_OPL2;\n\t\tbreak;\n\tcase OPL3_HW_OPL3:\n\t\tstrcpy(hw->name, \"OPL3 FM\");\n\t\thw->iface = SNDRV_HWDEP_IFACE_OPL3;\n\t\tbreak;\n\tcase OPL3_HW_OPL4:\n\t\tstrcpy(hw->name, \"OPL4 FM\");\n\t\thw->iface = SNDRV_HWDEP_IFACE_OPL4;\n\t\tbreak;\n\t}\n\n\t \n\thw->ops.open = snd_opl3_open;\n\thw->ops.ioctl = snd_opl3_ioctl;\n\thw->ops.write = snd_opl3_write;\n\thw->ops.release = snd_opl3_release;\n\n\topl3->hwdep = hw;\n\topl3->seq_dev_num = seq_device;\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\tif (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,\n\t\t\t       sizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {\n\t\tstrcpy(opl3->seq_dev->name, hw->name);\n\t\t*(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(opl3->seq_dev) = opl3;\n\t}\n#endif\n\tif (rhwdep)\n\t\t*rhwdep = hw;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl3_hwdep_new);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}