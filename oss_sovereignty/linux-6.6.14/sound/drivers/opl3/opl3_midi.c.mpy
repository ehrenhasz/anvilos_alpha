{
  "module_name": "opl3_midi.c",
  "hash_id": "5b42d118b54e194764d64b24724db0dbd1b8fdfb2653622982d534fb22e2fb17",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl3/opl3_midi.c",
  "human_readable_source": "\n \n\n#undef DEBUG_ALLOC\n#undef DEBUG_MIDI\n\n#include \"opl3_voice.h\"\n#include <sound/asoundef.h>\n\nstatic void snd_opl3_note_off_unsafe(void *p, int note, int vel,\n\t\t\t\t     struct snd_midi_channel *chan);\n \n\nstatic const char opl3_volume_table[128] =\n{\n\t-63, -48, -40, -35, -32, -29, -27, -26,\n\t-24, -23, -21, -20, -19, -18, -18, -17,\n\t-16, -15, -15, -14, -13, -13, -12, -12,\n\t-11, -11, -10, -10, -10, -9, -9, -8,\n\t-8, -8, -7, -7, -7, -6, -6, -6,\n\t-5, -5, -5, -5, -4, -4, -4, -4,\n\t-3, -3, -3, -3, -2, -2, -2, -2,\n\t-2, -1, -1, -1, -1, 0, 0, 0,\n\t0, 0, 0, 1, 1, 1, 1, 1,\n\t1, 2, 2, 2, 2, 2, 2, 2,\n\t3, 3, 3, 3, 3, 3, 3, 4,\n\t4, 4, 4, 4, 4, 4, 4, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 7, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 8, 8, 8, 8, 8\n};\n\nvoid snd_opl3_calc_volume(unsigned char *volbyte, int vel,\n\t\t\t  struct snd_midi_channel *chan)\n{\n\tint oldvol, newvol, n;\n\tint volume;\n\n\tvolume = (vel * chan->gm_volume * chan->gm_expression) / (127*127);\n\tif (volume > 127)\n\t\tvolume = 127;\n\n\toldvol = OPL3_TOTAL_LEVEL_MASK - (*volbyte & OPL3_TOTAL_LEVEL_MASK);\n\n\tnewvol = opl3_volume_table[volume] + oldvol;\n\tif (newvol > OPL3_TOTAL_LEVEL_MASK)\n\t\tnewvol = OPL3_TOTAL_LEVEL_MASK;\n\telse if (newvol < 0)\n\t\tnewvol = 0;\n\n\tn = OPL3_TOTAL_LEVEL_MASK - (newvol & OPL3_TOTAL_LEVEL_MASK);\n\n\t*volbyte = (*volbyte & OPL3_KSL_MASK) | (n & OPL3_TOTAL_LEVEL_MASK);\n}\n\n \nstatic const short opl3_note_table[16] =\n{\n\t305, 323,\t \n\t343, 363, 385, 408, 432, 458, 485, 514, 544, 577, 611, 647,\n\t686, 726\t \n};\n\nstatic void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,\n\t\t\t\tint note, struct snd_midi_channel *chan)\n{\n\tint block = ((note / 12) & 0x07) - 1;\n\tint idx = (note % 12) + 2;\n\tint freq;\n\n\tif (chan->midi_pitchbend) {\n\t\tint pitchbend = chan->midi_pitchbend;\n\t\tint segment;\n\n\t\tif (pitchbend < -0x2000)\n\t\t\tpitchbend = -0x2000;\n\t\tif (pitchbend > 0x1FFF)\n\t\t\tpitchbend = 0x1FFF;\n\n\t\tsegment = pitchbend / 0x1000;\n\t\tfreq = opl3_note_table[idx+segment];\n\t\tfreq += ((opl3_note_table[idx+segment+1] - freq) *\n\t\t\t (pitchbend % 0x1000)) / 0x1000;\n\t} else {\n\t\tfreq = opl3_note_table[idx];\n\t}\n\n\t*fnum = (unsigned char) freq;\n\t*blocknum = ((freq >> 8) & OPL3_FNUM_HIGH_MASK) |\n\t\t((block << 2) & OPL3_BLOCKNUM_MASK);\n}\n\n\n#ifdef DEBUG_ALLOC\nstatic void debug_alloc(struct snd_opl3 *opl3, char *s, int voice) {\n\tint i;\n\tchar *str = \"x.24\";\n\n\tprintk(KERN_DEBUG \"time %.5i: %s [%.2i]: \", opl3->use_time, s, voice);\n\tfor (i = 0; i < opl3->max_voices; i++)\n\t\tprintk(KERN_CONT \"%c\", *(str + opl3->voices[i].state + 1));\n\tprintk(KERN_CONT \"\\n\");\n}\n#endif\n\n \nstatic int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,\n\t\t\t  struct snd_midi_channel *chan) {\n\tint chan_4op_1;\t\t \n\tint chan_4op_2;\t\t \n\n\tstruct snd_opl3_voice *vp, *vp2;\n\tunsigned int voice_time;\n\tint i;\n\n#ifdef DEBUG_ALLOC\n\tchar *alloc_type[3] = { \"FREE     \", \"CHEAP    \", \"EXPENSIVE\" };\n#endif\n\n\t \n\tenum {\n\t\tFREE = 0, CHEAP, EXPENSIVE, END\n\t};\n\n\t \n\tstruct best {\n\t\tunsigned int time;\n\t\tint voice;\n\t} best[END];\n\tstruct best *bp;\n\n\tfor (i = 0; i < END; i++) {\n\t\tbest[i].time = (unsigned int)(-1);  \n\t\tbest[i].voice = -1;\n\t}\n\n\t \n\tfor (i = 0; i < opl3->max_voices; i++) {\n\t\tvp = &opl3->voices[i];\n\n\t\tif (vp->state == SNDRV_OPL3_ST_NOT_AVAIL)\n\t\t   \n\t\t\tcontinue;\n\n\t\tvoice_time = vp->time;\n\t\tbp = best;\n\n\t\tchan_4op_1 = ((i < 3) || (i > 8 && i < 12));\n\t\tchan_4op_2 = ((i > 2 && i < 6) || (i > 11 && i < 15));\n\t\tif (instr_4op) {\n\t\t\t \n\t\t\t \n\t\t\tif (!chan_4op_1)\n\t\t\t\tcontinue;\n\n\t\t\tif (vp->state)\n\t\t\t\t \n\t\t\t\tbp++;\n\t\t\t \n\t\t\tvp2 = &opl3->voices[i + 3];\n\t\t\tif (vp2->state == SNDRV_OPL3_ST_ON_2OP) {\n\t\t\t\t \n\t\t\t\tbp++;\n\t\t\t\tvoice_time = max(voice_time, vp2->time);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((chan_4op_1) || (chan_4op_2))\n\t\t\t\t \n\t\t\t\tbp++;\n\t\t\telse if (vp->state)\n\t\t\t\t \n\t\t\t\tbp++;\n\t\t\t \n\t\t\tif (vp->state)\n\t\t\t\tbp++;\n\t\t}\n\t\tif (voice_time < bp->time) {\n\t\t\tbp->time = voice_time;\n\t\t\tbp->voice = i;\n\t\t}\n\t}\n\n\tfor (i = 0; i < END; i++) {\n\t\tif (best[i].voice >= 0) {\n#ifdef DEBUG_ALLOC\n\t\t\tprintk(KERN_DEBUG \"%s %iop allocation on voice %i\\n\",\n\t\t\t       alloc_type[i], instr_4op ? 4 : 2,\n\t\t\t       best[i].voice);\n#endif\n\t\t\treturn best[i].voice;\n\t\t}\n\t}\n\t \n\treturn -1;\n}\n\n \n\n \nvoid snd_opl3_timer_func(struct timer_list *t)\n{\n\n\tstruct snd_opl3 *opl3 = from_timer(opl3, t, tlist);\n\tunsigned long flags;\n\tint again = 0;\n\tint i;\n\n\tspin_lock_irqsave(&opl3->voice_lock, flags);\n\tfor (i = 0; i < opl3->max_voices; i++) {\n\t\tstruct snd_opl3_voice *vp = &opl3->voices[i];\n\t\tif (vp->state > 0 && vp->note_off_check) {\n\t\t\tif (vp->note_off == jiffies)\n\t\t\t\tsnd_opl3_note_off_unsafe(opl3, vp->note, 0,\n\t\t\t\t\t\t\t vp->chan);\n\t\t\telse\n\t\t\t\tagain++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n\n\tspin_lock_irqsave(&opl3->sys_timer_lock, flags);\n\tif (again)\n\t\tmod_timer(&opl3->tlist, jiffies + 1);\t \n\telse\n\t\topl3->sys_timer_status = 0;\n\tspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\n}\n\n \nstatic void snd_opl3_start_timer(struct snd_opl3 *opl3)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&opl3->sys_timer_lock, flags);\n\tif (! opl3->sys_timer_status) {\n\t\tmod_timer(&opl3->tlist, jiffies + 1);\n\t\topl3->sys_timer_status = 1;\n\t}\n\tspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\n}\n\n \n\n\nstatic const int snd_opl3_oss_map[MAX_OPL3_VOICES] = {\n\t0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17, 3, 4 ,5, 12, 13, 14\n};\n\n \nvoid snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)\n{\n\tstruct snd_opl3 *opl3;\n\tint instr_4op;\n\n\tint voice;\n\tstruct snd_opl3_voice *vp, *vp2;\n\tunsigned short connect_mask;\n\tunsigned char connection;\n\tunsigned char vol_op[4];\n\n\tint extra_prg = 0;\n\n\tunsigned short reg_side;\n\tunsigned char op_offset;\n\tunsigned char voice_offset;\n\tunsigned short opl3_reg;\n\tunsigned char reg_val;\n\tunsigned char prg, bank;\n\n\tint key = note;\n\tunsigned char fnum, blocknum;\n\tint i;\n\n\tstruct fm_patch *patch;\n\tstruct fm_instrument *fm;\n\tunsigned long flags;\n\n\topl3 = p;\n\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"Note on, ch %i, inst %i, note %i, vel %i\\n\",\n\t\t   chan->number, chan->midi_program, note, vel);\n#endif\n\n\t \n\t \n\tif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\n\t\tif (chan->drum_channel) {\n\t\t\t \n\t\t\tbank = 128;\n\t\t\tprg = note;\n\t\t} else {\n\t\t\tbank = chan->gm_bank_select;\n\t\t\tprg = chan->midi_program;\n\t\t}\n\t} else {\n\t\t \n\t\tif (chan->number >= MAX_OPL3_VOICES)\n\t\t\treturn;\n\n\t\t \n\t\tbank = 127;\n\t\tprg = chan->midi_program;\n\t}\n\n\tspin_lock_irqsave(&opl3->voice_lock, flags);\n\n\tif (use_internal_drums) {\n\t\tsnd_opl3_drum_switch(opl3, note, vel, 1, chan);\n\t\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n\t\treturn;\n\t}\n\n __extra_prg:\n\tpatch = snd_opl3_find_patch(opl3, prg, bank, 0);\n\tif (!patch) {\n\t\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n\t\treturn;\n\t}\n\n\tfm = &patch->inst;\n\tswitch (patch->type) {\n\tcase FM_PATCH_OPL2:\n\t\tinstr_4op = 0;\n\t\tbreak;\n\tcase FM_PATCH_OPL3:\n\t\tif (opl3->hardware >= OPL3_HW_OPL3) {\n\t\t\tinstr_4op = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n\t\treturn;\n\t}\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"  --> OPL%i instrument: %s\\n\",\n\t\t   instr_4op ? 3 : 2, patch->name);\n#endif\n\t \n\t \n\tif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\n\t\tvoice = opl3_get_voice(opl3, instr_4op, chan);\n\t} else {\n\t\t \n\t\tvoice = snd_opl3_oss_map[chan->number];\t\t\n\t}\n\n\tif (voice < 0) {\n\t\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n\t\treturn;\n\t}\n\n\tif (voice < MAX_OPL2_VOICES) {\n\t\t \n\t\treg_side = OPL3_LEFT;\n\t\tvoice_offset = voice;\n\t\tconnect_mask = (OPL3_LEFT_4OP_0 << voice_offset) & 0x07;\n\t} else {\n\t\t \n\t\treg_side = OPL3_RIGHT;\n\t\tvoice_offset = voice - MAX_OPL2_VOICES;\n\t\tconnect_mask = (OPL3_RIGHT_4OP_0 << voice_offset) & 0x38;\n\t}\n\n\t \n\tvp = &opl3->voices[voice];\n\tif (vp->state > 0) {\n\t\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\t\treg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\t}\n\tif (instr_4op) {\n\t\tvp2 = &opl3->voices[voice + 3];\n\t\tif (vp2->state > 0) {\n\t\t\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK +\n\t\t\t\t\t       voice_offset + 3);\n\t\t\treg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;\n\t\t\topl3->command(opl3, opl3_reg, reg_val);\n\t\t}\n\t}\n\n\t \n\tif (instr_4op) {\n\t\tif ((opl3->connection_reg ^ connect_mask) & connect_mask) {\n\t\t\topl3->connection_reg |= connect_mask;\n\t\t\t \n\t\t\topl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;\n\t\t\topl3->command(opl3, opl3_reg, opl3->connection_reg);\n\t\t}\n\t} else {\n\t\tif ((opl3->connection_reg ^ ~connect_mask) & connect_mask) {\n\t\t\topl3->connection_reg &= ~connect_mask;\n\t\t\t \n\t\t\topl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;\n\t\t\topl3->command(opl3, opl3_reg, opl3->connection_reg);\n\t\t}\n\t}\n\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"  --> setting OPL3 connection: 0x%x\\n\",\n\t\t   opl3->connection_reg);\n#endif\n\t \n\tfor (i = 0; i < (instr_4op ? 4 : 2); i++)\n\t\tvol_op[i] = fm->op[i].ksl_level;\n\n\tconnection = fm->feedback_connection[0] & 0x01;\n\tif (instr_4op) {\n\t\tconnection <<= 1;\n\t\tconnection |= fm->feedback_connection[1] & 0x01;\n\n\t\tsnd_opl3_calc_volume(&vol_op[3], vel, chan);\n\t\tswitch (connection) {\n\t\tcase 0x03:\n\t\t\tsnd_opl3_calc_volume(&vol_op[2], vel, chan);\n\t\t\tfallthrough;\n\t\tcase 0x02:\n\t\t\tsnd_opl3_calc_volume(&vol_op[0], vel, chan);\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tsnd_opl3_calc_volume(&vol_op[1], vel, chan);\n\t\t}\n\t} else {\n\t\tsnd_opl3_calc_volume(&vol_op[1], vel, chan);\n\t\tif (connection)\n\t\t\tsnd_opl3_calc_volume(&vol_op[0], vel, chan);\n\t}\n\n\t \n\tfor (i = 0; i < (instr_4op ? 4 : 2); i++) {\n#ifdef DEBUG_MIDI\n\t\tsnd_printk(KERN_DEBUG \"  --> programming operator %i\\n\", i);\n#endif\n\t\top_offset = snd_opl3_regmap[voice_offset][i];\n\n\t\t  \n\t\treg_val = fm->op[i].am_vib;\n\t\topl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\n\t\t  \n\t\treg_val = vol_op[i];\n\t\topl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\n\t\t  \n\t\treg_val = fm->op[i].attack_decay;\n\t\topl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\n\t\t  \n\t\treg_val = fm->op[i].sustain_release;\n\t\topl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\n\t\t \n\t\treg_val = fm->op[i].wave_select;\n\t\topl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\t}\n\n\t \n\treg_val = fm->feedback_connection[0];\n\t \n\treg_val |= OPL3_STEREO_BITS;\n\tif (chan->gm_pan < 43)\n\t\treg_val &= ~OPL3_VOICE_TO_RIGHT;\n\tif (chan->gm_pan > 85)\n\t\treg_val &= ~OPL3_VOICE_TO_LEFT;\n\topl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);\n\topl3->command(opl3, opl3_reg, reg_val);\n\n\tif (instr_4op) {\n\t\t \n\t\treg_val = fm->feedback_connection[1] & OPL3_CONNECTION_BIT;\n\t\t \n\t\treg_val |= OPL3_STEREO_BITS;\n\t\tif (chan->gm_pan < 43)\n\t\t\treg_val &= ~OPL3_VOICE_TO_RIGHT;\n\t\tif (chan->gm_pan > 85)\n\t\t\treg_val &= ~OPL3_VOICE_TO_LEFT;\n\t\topl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION +\n\t\t\t\t       voice_offset + 3);\n\t\topl3->command(opl3, opl3_reg, reg_val);\n\t}\n\n\t \n\tif (fm->fix_key)\n\t\tnote = fm->fix_key;\n\t \n\tif (fm->trnsps)\n\t\tnote += (fm->trnsps - 64);\n\n\tsnd_opl3_calc_pitch(&fnum, &blocknum, note, chan);\n\n\t \n\topl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\n\topl3->command(opl3, opl3_reg, fnum);\n\n\topl3->voices[voice].keyon_reg = blocknum;\n\n\t \n\tblocknum |= OPL3_KEYON_BIT;\n\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"  --> trigger voice %i\\n\", voice);\n#endif\n\t  \n\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\topl3->command(opl3, opl3_reg, blocknum);\n\n\t \n\tif (fm->fix_dur) {\n\t\topl3->voices[voice].note_off = jiffies +\n\t\t\t(fm->fix_dur * HZ) / 100;\n\t\tsnd_opl3_start_timer(opl3);\n\t\topl3->voices[voice].note_off_check = 1;\n\t} else\n\t\topl3->voices[voice].note_off_check = 0;\n\n\t \n\textra_prg = (extra_prg) ? 0 : fm->modes;\n\n\t \n\tvp->time = opl3->use_time++;\n\tvp->note = key;\n\tvp->chan = chan;\n\n\tif (instr_4op) {\n\t\tvp->state = SNDRV_OPL3_ST_ON_4OP;\n\n\t\tvp2 = &opl3->voices[voice + 3];\n\t\tvp2->time = opl3->use_time++;\n\t\tvp2->note = key;\n\t\tvp2->chan = chan;\n\t\tvp2->state = SNDRV_OPL3_ST_NOT_AVAIL;\n\t} else {\n\t\tif (vp->state == SNDRV_OPL3_ST_ON_4OP) {\n\t\t\t \n\t\t\tvp2 = &opl3->voices[voice + 3];\n\t\t\tvp2->time = opl3->use_time++;\n\t\t\tvp2->state = SNDRV_OPL3_ST_OFF;\n\t\t}\n\t\tvp->state = SNDRV_OPL3_ST_ON_2OP;\n\t}\n\n#ifdef DEBUG_ALLOC\n\tdebug_alloc(opl3, \"note on \", voice);\n#endif\n\n\t \n\tif (extra_prg) {\n\t\tif (extra_prg > 128) {\n\t\t\tbank = 128;\n\t\t\t \n\t\t\tprg = extra_prg - 128 + 35 - 1;\n\t\t} else {\n\t\t\tbank = 0;\n\t\t\tprg = extra_prg - 1;\n\t\t}\n#ifdef DEBUG_MIDI\n\t\tsnd_printk(KERN_DEBUG \" *** allocating extra program\\n\");\n#endif\n\t\tgoto __extra_prg;\n\t}\n\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n}\n\nstatic void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)\n{\n\tunsigned short reg_side;\n\tunsigned char voice_offset;\n\tunsigned short opl3_reg;\n\n\tstruct snd_opl3_voice *vp, *vp2;\n\n\tif (snd_BUG_ON(voice >= MAX_OPL3_VOICES))\n\t\treturn;\n\n\tvp = &opl3->voices[voice];\n\tif (voice < MAX_OPL2_VOICES) {\n\t\t \n\t\treg_side = OPL3_LEFT;\n\t\tvoice_offset = voice;\n\t} else {\n\t\t \n\t\treg_side = OPL3_RIGHT;\n\t\tvoice_offset = voice - MAX_OPL2_VOICES;\n\t}\n\n\t \n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"  --> kill voice %i\\n\", voice);\n#endif\n\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\t \n\topl3->command(opl3, opl3_reg, vp->keyon_reg);\n\n\t \n\tvp->time = opl3->use_time++;\n\n\tif (vp->state == SNDRV_OPL3_ST_ON_4OP) {\n\t\tvp2 = &opl3->voices[voice + 3];\n\n\t\tvp2->time = opl3->use_time++;\n\t\tvp2->state = SNDRV_OPL3_ST_OFF;\n\t}\n\tvp->state = SNDRV_OPL3_ST_OFF;\n#ifdef DEBUG_ALLOC\n\tdebug_alloc(opl3, \"note off\", voice);\n#endif\n\n}\n\n \nstatic void snd_opl3_note_off_unsafe(void *p, int note, int vel,\n\t\t\t\t     struct snd_midi_channel *chan)\n{\n  \tstruct snd_opl3 *opl3;\n\n\tint voice;\n\tstruct snd_opl3_voice *vp;\n\n\topl3 = p;\n\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"Note off, ch %i, inst %i, note %i\\n\",\n\t\t   chan->number, chan->midi_program, note);\n#endif\n\n\tif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\n\t\tif (chan->drum_channel && use_internal_drums) {\n\t\t\tsnd_opl3_drum_switch(opl3, note, vel, 0, chan);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tfor (voice = 0; voice < opl3->max_voices; voice++) {\n\t\t\tvp = &opl3->voices[voice];\n\t\t\tif (vp->state > 0 && vp->chan == chan && vp->note == note) {\n\t\t\t\tsnd_opl3_kill_voice(opl3, voice);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (chan->number < MAX_OPL3_VOICES) {\n\t\t\tvoice = snd_opl3_oss_map[chan->number];\t\t\n\t\t\tsnd_opl3_kill_voice(opl3, voice);\n\t\t}\n\t}\n}\n\nvoid snd_opl3_note_off(void *p, int note, int vel,\n\t\t       struct snd_midi_channel *chan)\n{\n\tstruct snd_opl3 *opl3 = p;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&opl3->voice_lock, flags);\n\tsnd_opl3_note_off_unsafe(p, note, vel, chan);\n\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n}\n\n \nvoid snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)\n{\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"Key pressure, ch#: %i, inst#: %i\\n\",\n\t\t   chan->number, chan->midi_program);\n#endif\n}\n\n \nvoid snd_opl3_terminate_note(void *p, int note, struct snd_midi_channel *chan)\n{\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"Terminate note, ch#: %i, inst#: %i\\n\",\n\t\t   chan->number, chan->midi_program);\n#endif\n}\n\nstatic void snd_opl3_update_pitch(struct snd_opl3 *opl3, int voice)\n{\n\tunsigned short reg_side;\n\tunsigned char voice_offset;\n\tunsigned short opl3_reg;\n\n\tunsigned char fnum, blocknum;\n\n\tstruct snd_opl3_voice *vp;\n\n\tif (snd_BUG_ON(voice >= MAX_OPL3_VOICES))\n\t\treturn;\n\n\tvp = &opl3->voices[voice];\n\tif (vp->chan == NULL)\n\t\treturn;  \n\n\tif (voice < MAX_OPL2_VOICES) {\n\t\t \n\t\treg_side = OPL3_LEFT;\n\t\tvoice_offset = voice;\n\t} else {\n\t\t \n\t\treg_side = OPL3_RIGHT;\n\t\tvoice_offset = voice - MAX_OPL2_VOICES;\n\t}\n\n\tsnd_opl3_calc_pitch(&fnum, &blocknum, vp->note, vp->chan);\n\n\t \n\topl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\n\topl3->command(opl3, opl3_reg, fnum);\n\n\tvp->keyon_reg = blocknum;\n\n\t \n\tblocknum |= OPL3_KEYON_BIT;\n\n\t  \n\topl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\n\topl3->command(opl3, opl3_reg, blocknum);\n\n\tvp->time = opl3->use_time++;\n}\n\n \nstatic void snd_opl3_pitch_ctrl(struct snd_opl3 *opl3, struct snd_midi_channel *chan)\n{\n\tint voice;\n\tstruct snd_opl3_voice *vp;\n\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&opl3->voice_lock, flags);\n\n\tif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\n\t\tfor (voice = 0; voice < opl3->max_voices; voice++) {\n\t\t\tvp = &opl3->voices[voice];\n\t\t\tif (vp->state > 0 && vp->chan == chan) {\n\t\t\t\tsnd_opl3_update_pitch(opl3, voice);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (chan->number < MAX_OPL3_VOICES) {\n\t\t\tvoice = snd_opl3_oss_map[chan->number];\t\t\n\t\t\tsnd_opl3_update_pitch(opl3, voice);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&opl3->voice_lock, flags);\n}\n\n \nvoid snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)\n{\n  \tstruct snd_opl3 *opl3;\n\n\topl3 = p;\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"Controller, TYPE = %i, ch#: %i, inst#: %i\\n\",\n\t\t   type, chan->number, chan->midi_program);\n#endif\n\n\tswitch (type) {\n\tcase MIDI_CTL_MSB_MODWHEEL:\n\t\tif (chan->control[MIDI_CTL_MSB_MODWHEEL] > 63)\n\t\t\topl3->drum_reg |= OPL3_VIBRATO_DEPTH;\n\t\telse \n\t\t\topl3->drum_reg &= ~OPL3_VIBRATO_DEPTH;\n\t\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,\n\t\t\t\t opl3->drum_reg);\n\t\tbreak;\n\tcase MIDI_CTL_E2_TREMOLO_DEPTH:\n\t\tif (chan->control[MIDI_CTL_E2_TREMOLO_DEPTH] > 63)\n\t\t\topl3->drum_reg |= OPL3_TREMOLO_DEPTH;\n\t\telse \n\t\t\topl3->drum_reg &= ~OPL3_TREMOLO_DEPTH;\n\t\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,\n\t\t\t\t opl3->drum_reg);\n\t\tbreak;\n\tcase MIDI_CTL_PITCHBEND:\n\t\tsnd_opl3_pitch_ctrl(opl3, chan);\n\t\tbreak;\n\t}\n}\n\n \nvoid snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,\n\t\t   struct snd_midi_channel_set *chset)\n{\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"NRPN, ch#: %i, inst#: %i\\n\",\n\t\t   chan->number, chan->midi_program);\n#endif\n}\n\n \nvoid snd_opl3_sysex(void *p, unsigned char *buf, int len,\n\t\t    int parsed, struct snd_midi_channel_set *chset)\n{\n#ifdef DEBUG_MIDI\n\tsnd_printk(KERN_DEBUG \"SYSEX\\n\");\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}