{
  "module_name": "opl3_seq.c",
  "hash_id": "b0699fd42b9f968792f7b742cb59e68773ffc2d90a5d6aefd0dd688684ed4f6d",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl3/opl3_seq.c",
  "human_readable_source": "\n \n\n#include \"opl3_voice.h\"\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Uros Bizjak <uros@kss-loka.si>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ALSA driver for OPL3 FM synth\");\n\nbool use_internal_drums = 0;\nmodule_param(use_internal_drums, bool, 0444);\nMODULE_PARM_DESC(use_internal_drums, \"Enable internal OPL2/3 drums.\");\n\nint snd_opl3_synth_use_inc(struct snd_opl3 * opl3)\n{\n\tif (!try_module_get(opl3->card->module))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\nvoid snd_opl3_synth_use_dec(struct snd_opl3 * opl3)\n{\n\tmodule_put(opl3->card->module);\n}\n\nint snd_opl3_synth_setup(struct snd_opl3 * opl3)\n{\n\tint idx;\n\tstruct snd_hwdep *hwdep = opl3->hwdep;\n\n\tmutex_lock(&hwdep->open_mutex);\n\tif (hwdep->used) {\n\t\tmutex_unlock(&hwdep->open_mutex);\n\t\treturn -EBUSY;\n\t}\n\thwdep->used++;\n\tmutex_unlock(&hwdep->open_mutex);\n\n\tsnd_opl3_reset(opl3);\n\n\tfor (idx = 0; idx < MAX_OPL3_VOICES; idx++) {\n\t\topl3->voices[idx].state = SNDRV_OPL3_ST_OFF;\n\t\topl3->voices[idx].time = 0;\n\t\topl3->voices[idx].keyon_reg = 0x00;\n\t}\n\topl3->use_time = 0;\n\topl3->connection_reg = 0x00;\n\tif (opl3->hardware >= OPL3_HW_OPL3) {\n\t\t \n\t\topl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT,\n\t\t\t\t opl3->connection_reg);\n\t\topl3->max_voices = MAX_OPL3_VOICES;\n\t}\n\treturn 0;\n}\n\nvoid snd_opl3_synth_cleanup(struct snd_opl3 * opl3)\n{\n\tunsigned long flags;\n\tstruct snd_hwdep *hwdep;\n\n\t \n\tspin_lock_irqsave(&opl3->sys_timer_lock, flags);\n\tif (opl3->sys_timer_status) {\n\t\tdel_timer(&opl3->tlist);\n\t\topl3->sys_timer_status = 0;\n\t}\n\tspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\n\n\tsnd_opl3_reset(opl3);\n\thwdep = opl3->hwdep;\n\tmutex_lock(&hwdep->open_mutex);\n\thwdep->used--;\n\tmutex_unlock(&hwdep->open_mutex);\n\twake_up(&hwdep->open_wait);\n}\n\nstatic int snd_opl3_synth_use(void *private_data, struct snd_seq_port_subscribe * info)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\tint err;\n\n\terr = snd_opl3_synth_setup(opl3);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (use_internal_drums) {\n\t\t \n\t\topl3->voices[6].state = opl3->voices[7].state = \n\t\t\topl3->voices[8].state = SNDRV_OPL3_ST_NOT_AVAIL;\n\t\tsnd_opl3_load_drums(opl3);\n\t\topl3->drum_reg = OPL3_PERCUSSION_ENABLE;\n\t\topl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, opl3->drum_reg);\n\t} else {\n\t\topl3->drum_reg = 0x00;\n\t}\n\n\tif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {\n\t\terr = snd_opl3_synth_use_inc(opl3);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\topl3->synth_mode = SNDRV_OPL3_MODE_SEQ;\n\treturn 0;\n}\n\nstatic int snd_opl3_synth_unuse(void *private_data, struct snd_seq_port_subscribe * info)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\n\tsnd_opl3_synth_cleanup(opl3);\n\n\tif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)\n\t\tsnd_opl3_synth_use_dec(opl3);\n\treturn 0;\n}\n\n \nconst struct snd_midi_op opl3_ops = {\n\t.note_on =\t\tsnd_opl3_note_on,\n\t.note_off =\t\tsnd_opl3_note_off,\n\t.key_press =\t\tsnd_opl3_key_press,\n\t.note_terminate =\tsnd_opl3_terminate_note,\n\t.control =\t\tsnd_opl3_control,\n\t.nrpn =\t\t\tsnd_opl3_nrpn,\n\t.sysex =\t\tsnd_opl3_sysex,\n};\n\nstatic int snd_opl3_synth_event_input(struct snd_seq_event * ev, int direct,\n\t\t\t\t      void *private_data, int atomic, int hop)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\n\tsnd_midi_process_event(&opl3_ops, ev, opl3->chset);\n\treturn 0;\n}\n\n \n\nstatic void snd_opl3_synth_free_port(void *private_data)\n{\n\tstruct snd_opl3 *opl3 = private_data;\n\n\tsnd_midi_channel_free_set(opl3->chset);\n}\n\nstatic int snd_opl3_synth_create_port(struct snd_opl3 * opl3)\n{\n\tstruct snd_seq_port_callback callbacks;\n\tchar name[32];\n\tint voices, opl_ver;\n\n\tvoices = (opl3->hardware < OPL3_HW_OPL3) ?\n\t\tMAX_OPL2_VOICES : MAX_OPL3_VOICES;\n\topl3->chset = snd_midi_channel_alloc_set(16);\n\tif (opl3->chset == NULL)\n\t\treturn -ENOMEM;\n\topl3->chset->private_data = opl3;\n\n\tmemset(&callbacks, 0, sizeof(callbacks));\n\tcallbacks.owner = THIS_MODULE;\n\tcallbacks.use = snd_opl3_synth_use;\n\tcallbacks.unuse = snd_opl3_synth_unuse;\n\tcallbacks.event_input = snd_opl3_synth_event_input;\n\tcallbacks.private_free = snd_opl3_synth_free_port;\n\tcallbacks.private_data = opl3;\n\n\topl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\n\tsprintf(name, \"OPL%i FM Port\", opl_ver);\n\n\topl3->chset->client = opl3->seq_client;\n\topl3->chset->port = snd_seq_event_port_attach(opl3->seq_client, &callbacks,\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_CAP_WRITE |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_MIDI_GM |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\n\t\t\t\t\t\t      16, voices,\n\t\t\t\t\t\t      name);\n\tif (opl3->chset->port < 0) {\n\t\tint port;\n\t\tport = opl3->chset->port;\n\t\tsnd_midi_channel_free_set(opl3->chset);\n\t\treturn port;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int snd_opl3_seq_probe(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_opl3 *opl3;\n\tint client, err;\n\tchar name[32];\n\tint opl_ver;\n\n\topl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\tif (opl3 == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&opl3->voice_lock);\n\n\topl3->seq_client = -1;\n\n\t \n\topl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\n\tsprintf(name, \"OPL%i FM synth\", opl_ver);\n\tclient = opl3->seq_client =\n\t\tsnd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num,\n\t\t\t\t\t     name);\n\tif (client < 0)\n\t\treturn client;\n\n\terr = snd_opl3_synth_create_port(opl3);\n\tif (err < 0) {\n\t\tsnd_seq_delete_kernel_client(client);\n\t\topl3->seq_client = -1;\n\t\treturn err;\n\t}\n\n\t \n\ttimer_setup(&opl3->tlist, snd_opl3_timer_func, 0);\n\tspin_lock_init(&opl3->sys_timer_lock);\n\topl3->sys_timer_status = 0;\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\tsnd_opl3_init_seq_oss(opl3, name);\n#endif\n\treturn 0;\n}\n\nstatic int snd_opl3_seq_remove(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_opl3 *opl3;\n\n\topl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\tif (opl3 == NULL)\n\t\treturn -EINVAL;\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)\n\tsnd_opl3_free_seq_oss(opl3);\n#endif\n\tif (opl3->seq_client >= 0) {\n\t\tsnd_seq_delete_kernel_client(opl3->seq_client);\n\t\topl3->seq_client = -1;\n\t}\n\treturn 0;\n}\n\nstatic struct snd_seq_driver opl3_seq_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.probe = snd_opl3_seq_probe,\n\t\t.remove = snd_opl3_seq_remove,\n\t},\n\t.id = SNDRV_SEQ_DEV_ID_OPL3,\n\t.argsize = sizeof(struct snd_opl3 *),\n};\n\nmodule_snd_seq_driver(opl3_seq_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}