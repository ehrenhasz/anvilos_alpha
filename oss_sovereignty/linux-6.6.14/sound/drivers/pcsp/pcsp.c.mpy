{
  "module_name": "pcsp.c",
  "hash_id": "44f66ad23462b925cc79a242de636d73f4b466a505499d94100f7bf63b03fe1c",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/pcsp/pcsp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/mm.h>\n#include \"pcsp_input.h\"\n#include \"pcsp.h\"\n\nMODULE_AUTHOR(\"Stas Sergeev <stsp@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"PC-Speaker driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pcspkr\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;\t \nstatic char *id = SNDRV_DEFAULT_STR1;\t \nstatic bool enable = SNDRV_DEFAULT_ENABLE1;\t \nstatic bool nopcm;\t \n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for pcsp soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for pcsp soundcard.\");\nmodule_param(enable, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable PC-Speaker sound.\");\nmodule_param(nopcm, bool, 0444);\nMODULE_PARM_DESC(nopcm, \"Disable PC-Speaker PCM sound. Only beeps remain.\");\n\nstruct snd_pcsp pcsp_chip;\n\nstatic int snd_pcsp_create(struct snd_card *card)\n{\n\tunsigned int resolution = hrtimer_resolution;\n\tint div, min_div, order;\n\n\tif (!nopcm) {\n\t\tif (resolution > PCSP_MAX_PERIOD_NS) {\n\t\t\tprintk(KERN_ERR \"PCSP: Timer resolution is not sufficient \"\n\t\t\t\t\"(%unS)\\n\", resolution);\n\t\t\tprintk(KERN_ERR \"PCSP: Make sure you have HPET and ACPI \"\n\t\t\t\t\"enabled.\\n\");\n\t\t\tprintk(KERN_ERR \"PCSP: Turned into nopcm mode.\\n\");\n\t\t\tnopcm = 1;\n\t\t}\n\t}\n\n\tif (loops_per_jiffy >= PCSP_MIN_LPJ && resolution <= PCSP_MIN_PERIOD_NS)\n\t\tmin_div = MIN_DIV;\n\telse\n\t\tmin_div = MAX_DIV;\n#if PCSP_DEBUG\n\tprintk(KERN_DEBUG \"PCSP: lpj=%li, min_div=%i, res=%u\\n\",\n\t       loops_per_jiffy, min_div, resolution);\n#endif\n\n\tdiv = MAX_DIV / min_div;\n\torder = fls(div) - 1;\n\n\tpcsp_chip.max_treble = min(order, PCSP_MAX_TREBLE);\n\tpcsp_chip.treble = min(pcsp_chip.max_treble, PCSP_DEFAULT_TREBLE);\n\tpcsp_chip.playback_ptr = 0;\n\tpcsp_chip.period_ptr = 0;\n\tatomic_set(&pcsp_chip.timer_active, 0);\n\tpcsp_chip.enable = 1;\n\tpcsp_chip.pcspkr = 1;\n\n\tspin_lock_init(&pcsp_chip.substream_lock);\n\n\tpcsp_chip.card = card;\n\tpcsp_chip.port = 0x61;\n\tpcsp_chip.irq = -1;\n\tpcsp_chip.dma = -1;\n\tcard->private_data = &pcsp_chip;\n\n\treturn 0;\n}\n\nstatic void pcsp_stop_beep(struct snd_pcsp *chip);\n\nstatic void alsa_card_pcsp_free(struct snd_card *card)\n{\n\tpcsp_stop_beep(card->private_data);\n}\n\nstatic int snd_card_pcsp_probe(int devnum, struct device *dev)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (devnum != 0)\n\t\treturn -EINVAL;\n\n\thrtimer_init(&pcsp_chip.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tpcsp_chip.timer.function = pcsp_do_timer;\n\n\terr = snd_devm_card_new(dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcsp_create(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!nopcm) {\n\t\terr = snd_pcsp_new_pcm(&pcsp_chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\terr = snd_pcsp_new_mixer(&pcsp_chip, nopcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"PC-Speaker\");\n\tstrcpy(card->shortname, \"pcsp\");\n\tsprintf(card->longname, \"Internal PC-Speaker at port 0x%x\",\n\t\tpcsp_chip.port);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tcard->private_free = alsa_card_pcsp_free;\n\n\treturn 0;\n}\n\nstatic int alsa_card_pcsp_init(struct device *dev)\n{\n\tint err;\n\n\terr = snd_card_pcsp_probe(0, dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"PC-Speaker initialization failed.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (debug_pagealloc_enabled()) {\n\t\tprintk(KERN_WARNING \"PCSP: CONFIG_DEBUG_PAGEALLOC is enabled, \"\n\t\t       \"which may make the sound noisy.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int pcsp_probe(struct platform_device *dev)\n{\n\tint err;\n\n\terr = pcspkr_input_init(&pcsp_chip.input_dev, &dev->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = alsa_card_pcsp_init(&dev->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(dev, &pcsp_chip);\n\treturn 0;\n}\n\nstatic void pcsp_stop_beep(struct snd_pcsp *chip)\n{\n\tpcsp_sync_stop(chip);\n\tpcspkr_stop_sound();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pcsp_suspend(struct device *dev)\n{\n\tstruct snd_pcsp *chip = dev_get_drvdata(dev);\n\tpcsp_stop_beep(chip);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pcsp_pm, pcsp_suspend, NULL);\n#define PCSP_PM_OPS\t&pcsp_pm\n#else\n#define PCSP_PM_OPS\tNULL\n#endif\t \n\nstatic void pcsp_shutdown(struct platform_device *dev)\n{\n\tstruct snd_pcsp *chip = platform_get_drvdata(dev);\n\tpcsp_stop_beep(chip);\n}\n\nstatic struct platform_driver pcsp_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pcspkr\",\n\t\t.pm\t= PCSP_PM_OPS,\n\t},\n\t.probe\t\t= pcsp_probe,\n\t.shutdown\t= pcsp_shutdown,\n};\n\nstatic int __init pcsp_init(void)\n{\n\tif (!enable)\n\t\treturn -ENODEV;\n\treturn platform_driver_register(&pcsp_platform_driver);\n}\n\nstatic void __exit pcsp_exit(void)\n{\n\tplatform_driver_unregister(&pcsp_platform_driver);\n}\n\nmodule_init(pcsp_init);\nmodule_exit(pcsp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}