{
  "module_name": "pcsp_lib.c",
  "hash_id": "d8df5c49edc1968a96b8abb4fa41e543d555f100b663f1ec0e1f2bd0280eaf10",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/pcsp/pcsp_lib.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <sound/pcm.h>\n#include \"pcsp.h\"\n\nstatic bool nforce_wa;\nmodule_param(nforce_wa, bool, 0444);\nMODULE_PARM_DESC(nforce_wa, \"Apply NForce chipset workaround \"\n\t\t\"(expect bad sound)\");\n\n#define DMIX_WANTS_S16\t1\n\n \nstatic void pcsp_call_pcm_elapsed(struct work_struct *work)\n{\n\tif (atomic_read(&pcsp_chip.timer_active)) {\n\t\tstruct snd_pcm_substream *substream;\n\t\tsubstream = pcsp_chip.playback_substream;\n\t\tif (substream)\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t}\n}\n\nstatic DECLARE_WORK(pcsp_pcm_work, pcsp_call_pcm_elapsed);\n\n \nstatic u64 pcsp_timer_update(struct snd_pcsp *chip)\n{\n\tunsigned char timer_cnt, val;\n\tu64 ns;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (chip->thalf) {\n\t\toutb(chip->val61, 0x61);\n\t\tchip->thalf = 0;\n\t\treturn chip->ns_rem;\n\t}\n\n\tsubstream = chip->playback_substream;\n\tif (!substream)\n\t\treturn 0;\n\n\truntime = substream->runtime;\n\t \n\tval = runtime->dma_area[chip->playback_ptr + chip->fmt_size - 1];\n\tif (chip->is_signed)\n\t\tval ^= 0x80;\n\ttimer_cnt = val * CUR_DIV() / 256;\n\n\tif (timer_cnt && chip->enable) {\n\t\traw_spin_lock_irqsave(&i8253_lock, flags);\n\t\tif (!nforce_wa) {\n\t\t\toutb_p(chip->val61, 0x61);\n\t\t\toutb_p(timer_cnt, 0x42);\n\t\t\toutb(chip->val61 ^ 1, 0x61);\n\t\t} else {\n\t\t\toutb(chip->val61 ^ 2, 0x61);\n\t\t\tchip->thalf = 1;\n\t\t}\n\t\traw_spin_unlock_irqrestore(&i8253_lock, flags);\n\t}\n\n\tchip->ns_rem = PCSP_PERIOD_NS();\n\tns = (chip->thalf ? PCSP_CALC_NS(timer_cnt) : chip->ns_rem);\n\tchip->ns_rem -= ns;\n\treturn ns;\n}\n\nstatic void pcsp_pointer_update(struct snd_pcsp *chip)\n{\n\tstruct snd_pcm_substream *substream;\n\tsize_t period_bytes, buffer_bytes;\n\tint periods_elapsed;\n\tunsigned long flags;\n\n\t \n\tsubstream = chip->playback_substream;\n\tif (!substream)\n\t\treturn;\n\n\tperiod_bytes = snd_pcm_lib_period_bytes(substream);\n\tbuffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\n\tspin_lock_irqsave(&chip->substream_lock, flags);\n\tchip->playback_ptr += PCSP_INDEX_INC() * chip->fmt_size;\n\tperiods_elapsed = chip->playback_ptr - chip->period_ptr;\n\tif (periods_elapsed < 0) {\n#if PCSP_DEBUG\n\t\tprintk(KERN_INFO \"PCSP: buffer_bytes mod period_bytes != 0 ? \"\n\t\t\t\"(%zi %zi %zi)\\n\",\n\t\t\tchip->playback_ptr, period_bytes, buffer_bytes);\n#endif\n\t\tperiods_elapsed += buffer_bytes;\n\t}\n\tperiods_elapsed /= period_bytes;\n\t \n\tchip->playback_ptr %= buffer_bytes;\n\n\tif (periods_elapsed) {\n\t\tchip->period_ptr += periods_elapsed * period_bytes;\n\t\tchip->period_ptr %= buffer_bytes;\n\t\tqueue_work(system_highpri_wq, &pcsp_pcm_work);\n\t}\n\tspin_unlock_irqrestore(&chip->substream_lock, flags);\n}\n\nenum hrtimer_restart pcsp_do_timer(struct hrtimer *handle)\n{\n\tstruct snd_pcsp *chip = container_of(handle, struct snd_pcsp, timer);\n\tint pointer_update;\n\tu64 ns;\n\n\tif (!atomic_read(&chip->timer_active) || !chip->playback_substream)\n\t\treturn HRTIMER_NORESTART;\n\n\tpointer_update = !chip->thalf;\n\tns = pcsp_timer_update(chip);\n\tif (!ns) {\n\t\tprintk(KERN_WARNING \"PCSP: unexpected stop\\n\");\n\t\treturn HRTIMER_NORESTART;\n\t}\n\n\tif (pointer_update)\n\t\tpcsp_pointer_update(chip);\n\n\thrtimer_forward_now(handle, ns_to_ktime(ns));\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int pcsp_start_playing(struct snd_pcsp *chip)\n{\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: start_playing called\\n\");\n#endif\n\tif (atomic_read(&chip->timer_active)) {\n\t\tprintk(KERN_ERR \"PCSP: Timer already active\\n\");\n\t\treturn -EIO;\n\t}\n\n\traw_spin_lock(&i8253_lock);\n\tchip->val61 = inb(0x61) | 0x03;\n\toutb_p(0x92, 0x43);\t \n\traw_spin_unlock(&i8253_lock);\n\tatomic_set(&chip->timer_active, 1);\n\tchip->thalf = 0;\n\n\thrtimer_start(&pcsp_chip.timer, 0, HRTIMER_MODE_REL);\n\treturn 0;\n}\n\nstatic void pcsp_stop_playing(struct snd_pcsp *chip)\n{\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: stop_playing called\\n\");\n#endif\n\tif (!atomic_read(&chip->timer_active))\n\t\treturn;\n\n\tatomic_set(&chip->timer_active, 0);\n\traw_spin_lock(&i8253_lock);\n\t \n\toutb_p(0xb6, 0x43);\t \n\toutb(chip->val61 & 0xFC, 0x61);\n\traw_spin_unlock(&i8253_lock);\n}\n\n \nvoid pcsp_sync_stop(struct snd_pcsp *chip)\n{\n\tlocal_irq_disable();\n\tpcsp_stop_playing(chip);\n\tlocal_irq_enable();\n\thrtimer_cancel(&chip->timer);\n\tcancel_work_sync(&pcsp_pcm_work);\n}\n\nstatic int snd_pcsp_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: close called\\n\");\n#endif\n\tpcsp_sync_stop(chip);\n\tchip->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_pcsp_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n\tpcsp_sync_stop(chip);\n\treturn 0;\n}\n\nstatic int snd_pcsp_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: hw_free called\\n\");\n#endif\n\tpcsp_sync_stop(chip);\n\treturn 0;\n}\n\nstatic int snd_pcsp_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n\tpcsp_sync_stop(chip);\n\tchip->playback_ptr = 0;\n\tchip->period_ptr = 0;\n\tchip->fmt_size =\n\t\tsnd_pcm_format_physical_width(substream->runtime->format) >> 3;\n\tchip->is_signed = snd_pcm_format_signed(substream->runtime->format);\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: prepare called, \"\n\t\t\t\"size=%zi psize=%zi f=%zi f1=%i fsize=%i\\n\",\n\t\t\tsnd_pcm_lib_buffer_bytes(substream),\n\t\t\tsnd_pcm_lib_period_bytes(substream),\n\t\t\tsnd_pcm_lib_buffer_bytes(substream) /\n\t\t\tsnd_pcm_lib_period_bytes(substream),\n\t\t\tsubstream->runtime->periods,\n\t\t\tchip->fmt_size);\n#endif\n\treturn 0;\n}\n\nstatic int snd_pcsp_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: trigger called\\n\");\n#endif\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\treturn pcsp_start_playing(chip);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tpcsp_stop_playing(chip);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_pcsp_playback_pointer(struct snd_pcm_substream\n\t\t\t\t\t\t   *substream)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n\tunsigned int pos;\n\tspin_lock(&chip->substream_lock);\n\tpos = chip->playback_ptr;\n\tspin_unlock(&chip->substream_lock);\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic const struct snd_pcm_hardware snd_pcsp_playback = {\n\t.info = (SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_HALF_DUPLEX |\n\t\t SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats = (SNDRV_PCM_FMTBIT_U8\n#if DMIX_WANTS_S16\n\t\t    | SNDRV_PCM_FMTBIT_S16_LE\n#endif\n\t    ),\n\t.rates = SNDRV_PCM_RATE_KNOT,\n\t.rate_min = PCSP_DEFAULT_SRATE,\n\t.rate_max = PCSP_DEFAULT_SRATE,\n\t.channels_min = 1,\n\t.channels_max = 1,\n\t.buffer_bytes_max = PCSP_BUFFER_SIZE,\n\t.period_bytes_min = 64,\n\t.period_bytes_max = PCSP_MAX_PERIOD_SIZE,\n\t.periods_min = 2,\n\t.periods_max = PCSP_MAX_PERIODS,\n\t.fifo_size = 0,\n};\n\nstatic int snd_pcsp_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n#if PCSP_DEBUG\n\tprintk(KERN_INFO \"PCSP: open called\\n\");\n#endif\n\tif (atomic_read(&chip->timer_active)) {\n\t\tprintk(KERN_ERR \"PCSP: still active!!\\n\");\n\t\treturn -EBUSY;\n\t}\n\truntime->hw = snd_pcsp_playback;\n\tchip->playback_substream = substream;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_pcsp_playback_ops = {\n\t.open = snd_pcsp_playback_open,\n\t.close = snd_pcsp_playback_close,\n\t.hw_params = snd_pcsp_playback_hw_params,\n\t.hw_free = snd_pcsp_playback_hw_free,\n\t.prepare = snd_pcsp_playback_prepare,\n\t.trigger = snd_pcsp_trigger,\n\t.pointer = snd_pcsp_playback_pointer,\n};\n\nint snd_pcsp_new_pcm(struct snd_pcsp *chip)\n{\n\tint err;\n\n\terr = snd_pcm_new(chip->card, \"pcspeaker\", 0, 1, 0, &chip->pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(chip->pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_pcsp_playback_ops);\n\n\tchip->pcm->private_data = chip;\n\tchip->pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\n\tstrcpy(chip->pcm->name, \"pcsp\");\n\n\tsnd_pcm_set_managed_buffer_all(chip->pcm,\n\t\t\t\t       SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL,\n\t\t\t\t       PCSP_BUFFER_SIZE,\n\t\t\t\t       PCSP_BUFFER_SIZE);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}