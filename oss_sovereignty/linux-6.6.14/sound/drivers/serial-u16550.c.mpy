{
  "module_name": "serial-u16550.c",
  "hash_id": "f2e4df6fcd40c373aace5dce9c492b1f29b82b90ecd3409d63bb46e598dac403",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/serial-u16550.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/rawmidi.h>\n#include <sound/initval.h>\n\n#include <linux/serial_reg.h>\n#include <linux/jiffies.h>\n\nMODULE_DESCRIPTION(\"MIDI serial u16550\");\nMODULE_LICENSE(\"GPL\");\n\n#define SNDRV_SERIAL_SOUNDCANVAS 0  \n#define SNDRV_SERIAL_MS124T 1       \n#define SNDRV_SERIAL_MS124W_SA 2    \n#define SNDRV_SERIAL_MS124W_MB 3    \n#define SNDRV_SERIAL_GENERIC 4      \n#define SNDRV_SERIAL_MAX_ADAPTOR SNDRV_SERIAL_GENERIC\nstatic const char * const adaptor_names[] = {\n\t\"Soundcanvas\",\n        \"MS-124T\",\n\t\"MS-124W S/A\",\n\t\"MS-124W M/B\",\n\t\"Generic\"\n};\n\n#define SNDRV_SERIAL_NORMALBUFF 0  \n#define SNDRV_SERIAL_DROPBUFF   1  \n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;  \nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;  \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ; \t \nstatic int speed[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 38400};  \nstatic int base[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 115200};  \nstatic int outs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\t  \nstatic int ins[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\t \nstatic int adaptor[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = SNDRV_SERIAL_SOUNDCANVAS};\nstatic bool droponfull[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS -1)] = SNDRV_SERIAL_NORMALBUFF };\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Serial MIDI.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Serial MIDI.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable UART16550A chip.\");\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for UART16550A chip.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for UART16550A chip.\");\nmodule_param_array(speed, int, NULL, 0444);\nMODULE_PARM_DESC(speed, \"Speed in bauds.\");\nmodule_param_array(base, int, NULL, 0444);\nMODULE_PARM_DESC(base, \"Base for divisor in bauds.\");\nmodule_param_array(outs, int, NULL, 0444);\nMODULE_PARM_DESC(outs, \"Number of MIDI outputs.\");\nmodule_param_array(ins, int, NULL, 0444);\nMODULE_PARM_DESC(ins, \"Number of MIDI inputs.\");\nmodule_param_array(droponfull, bool, NULL, 0444);\nMODULE_PARM_DESC(droponfull, \"Flag to enable drop-on-full buffer mode\");\n\nmodule_param_array(adaptor, int, NULL, 0444);\nMODULE_PARM_DESC(adaptor, \"Type of adaptor.\");\n\n    \n\n#define SNDRV_SERIAL_MAX_OUTS\t16\t\t \n#define SNDRV_SERIAL_MAX_INS\t16\t\t \n\n#define TX_BUFF_SIZE\t\t(1<<15)\t\t \n#define TX_BUFF_MASK\t\t(TX_BUFF_SIZE - 1)\n\n#define SERIAL_MODE_NOT_OPENED \t\t(0)\n#define SERIAL_MODE_INPUT_OPEN\t\t(1 << 0)\n#define SERIAL_MODE_OUTPUT_OPEN\t\t(1 << 1)\n#define SERIAL_MODE_INPUT_TRIGGERED\t(1 << 2)\n#define SERIAL_MODE_OUTPUT_TRIGGERED\t(1 << 3)\n\nstruct snd_uart16550 {\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tstruct snd_rawmidi_substream *midi_output[SNDRV_SERIAL_MAX_OUTS];\n\tstruct snd_rawmidi_substream *midi_input[SNDRV_SERIAL_MAX_INS];\n\n\tint filemode;\t\t \n\n\tspinlock_t open_lock;\n\n\tint irq;\n\n\tunsigned long base;\n\n\tunsigned int speed;\n\tunsigned int speed_base;\n\tunsigned char divisor;\n\n\tunsigned char old_divisor_lsb;\n\tunsigned char old_divisor_msb;\n\tunsigned char old_line_ctrl_reg;\n\n\t \n\tshort int fifo_limit;\t \n        short int fifo_count;\t \n\n\t \n\tint adaptor;\n\n\t \n\tint prev_in;\n\tunsigned char rstatus;\n\n\t \n\tint prev_out;\n\tunsigned char prev_status[SNDRV_SERIAL_MAX_OUTS];\n\n\t \n\tunsigned char tx_buff[TX_BUFF_SIZE];\n\tint buff_in_count;\n        int buff_in;\n        int buff_out;\n        int drop_on_full;\n\n\t \n\tunsigned int timer_running:1;\n\tstruct timer_list buffer_timer;\n\n};\n\nstatic struct platform_device *devices[SNDRV_CARDS];\n\nstatic inline void snd_uart16550_add_timer(struct snd_uart16550 *uart)\n{\n\tif (!uart->timer_running) {\n\t\t \n\t\tmod_timer(&uart->buffer_timer, jiffies + (HZ + 255) / 256);\n\t\tuart->timer_running = 1;\n\t}\n}\n\nstatic inline void snd_uart16550_del_timer(struct snd_uart16550 *uart)\n{\n\tif (uart->timer_running) {\n\t\tdel_timer(&uart->buffer_timer);\n\t\tuart->timer_running = 0;\n\t}\n}\n\n \nstatic inline void snd_uart16550_buffer_output(struct snd_uart16550 *uart)\n{\n\tunsigned short buff_out = uart->buff_out;\n\tif (uart->buff_in_count > 0) {\n\t\toutb(uart->tx_buff[buff_out], uart->base + UART_TX);\n\t\tuart->fifo_count++;\n\t\tbuff_out++;\n\t\tbuff_out &= TX_BUFF_MASK;\n\t\tuart->buff_out = buff_out;\n\t\tuart->buff_in_count--;\n\t}\n}\n\n \nstatic void snd_uart16550_io_loop(struct snd_uart16550 * uart)\n{\n\tunsigned char c, status;\n\tint substream;\n\n\t \n\tsubstream = uart->prev_in;\n\n\t \n\twhile ((status = inb(uart->base + UART_LSR)) & UART_LSR_DR) {\n\t\t \n\t\tc = inb(uart->base + UART_RX);\n\n\t\t \n\t\tif (c & 0x80)\n\t\t\tuart->rstatus = c;\n\n\t\t \n\t\tif (uart->adaptor == SNDRV_SERIAL_GENERIC) {\n\t\t\tif (uart->rstatus == 0xf5) {\n\t\t\t\tif (c <= SNDRV_SERIAL_MAX_INS && c > 0)\n\t\t\t\t\tsubstream = c - 1;\n\t\t\t\tif (c != 0xf5)\n\t\t\t\t\t \n\t\t\t\t\tuart->rstatus = 0;\n\t\t\t} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN)\n\t\t\t\t   && uart->midi_input[substream])\n\t\t\t\tsnd_rawmidi_receive(uart->midi_input[substream],\n\t\t\t\t\t\t    &c, 1);\n\t\t} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) &&\n\t\t\t   uart->midi_input[substream])\n\t\t\tsnd_rawmidi_receive(uart->midi_input[substream], &c, 1);\n\n\t\tif (status & UART_LSR_OE)\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"%s: Overrun on device at 0x%lx\\n\",\n\t\t\t       uart->rmidi->name, uart->base);\n\t}\n\n\t \n\tuart->prev_in = substream;\n\n\t \n\t \n\tif (status & UART_LSR_THRE)\n\t\tuart->fifo_count = 0;\n\tif (uart->adaptor == SNDRV_SERIAL_MS124W_SA\n\t   || uart->adaptor == SNDRV_SERIAL_GENERIC) {\n\t\t \n\t\tstatus = inb(uart->base + UART_MSR);\n\t\twhile (uart->fifo_count == 0 && (status & UART_MSR_CTS) &&\n\t\t       uart->buff_in_count > 0) {\n\t\t       snd_uart16550_buffer_output(uart);\n\t\t       status = inb(uart->base + UART_MSR);\n\t\t}\n\t} else {\n\t\t \n\t\twhile (uart->fifo_count < uart->fifo_limit  \n\t\t       && uart->buff_in_count > 0)\t \n\t\t\tsnd_uart16550_buffer_output(uart);\n\t}\n\tif (uart->irq < 0 && uart->buff_in_count > 0)\n\t\tsnd_uart16550_add_timer(uart);\n}\n\n \nstatic irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_uart16550 *uart;\n\n\tuart = dev_id;\n\tspin_lock(&uart->open_lock);\n\tif (uart->filemode == SERIAL_MODE_NOT_OPENED) {\n\t\tspin_unlock(&uart->open_lock);\n\t\treturn IRQ_NONE;\n\t}\n\t \n\tinb(uart->base + UART_IIR);\n\tsnd_uart16550_io_loop(uart);\n\tspin_unlock(&uart->open_lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void snd_uart16550_buffer_timer(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart;\n\n\tuart = from_timer(uart, t, buffer_timer);\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tsnd_uart16550_del_timer(uart);\n\tsnd_uart16550_io_loop(uart);\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n}\n\n \nstatic int snd_uart16550_detect(struct snd_uart16550 *uart)\n{\n\tunsigned long io_base = uart->base;\n\tint ok;\n\tunsigned char c;\n\n\t \n\tif (io_base == 0 || io_base == SNDRV_AUTO_PORT) {\n\t\treturn -ENODEV;\t \n\t}\n\n\tif (!devm_request_region(uart->card->dev, io_base, 8, \"Serial MIDI\")) {\n\t\tsnd_printk(KERN_ERR \"u16550: can't grab port 0x%lx\\n\", io_base);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tok = 1;\n\t \n\toutb(UART_LCR_WLEN8, io_base + UART_LCR);  \n\tc = inb(io_base + UART_IER);\n\t \n\tif ((c & 0xf0) != 0)\n\t\tok = 0;\t\t \n\n\toutb(0xaa, io_base + UART_SCR);\n\t \n\tc = inb(io_base + UART_SCR);\n\t \n\tif (c != 0xaa)\n\t\tok = 0;\t\t \n\n\toutb(0x55, io_base + UART_SCR);\n\t \n\tc = inb(io_base + UART_SCR);\n\t \n\tif (c != 0x55)\n\t\tok = 0;\t\t \n\n\treturn ok;\n}\n\nstatic void snd_uart16550_do_open(struct snd_uart16550 * uart)\n{\n\tchar byte;\n\n\t \n\tuart->buff_in_count = 0;\n\tuart->buff_in = 0;\n\tuart->buff_out = 0;\n\tuart->fifo_limit = 1;\n\tuart->fifo_count = 0;\n\tuart->timer_running = 0;\n\n\toutb(UART_FCR_ENABLE_FIFO\t \n\t     | UART_FCR_CLEAR_RCVR\t \n\t     | UART_FCR_CLEAR_XMIT\t \n\t     | UART_FCR_TRIGGER_4\t \n\t \n\t     ,uart->base + UART_FCR);\t \n\n\tif ((inb(uart->base + UART_IIR) & 0xf0) == 0xc0)\n\t\tuart->fifo_limit = 16;\n\tif (uart->divisor != 0) {\n\t\tuart->old_line_ctrl_reg = inb(uart->base + UART_LCR);\n\t\toutb(UART_LCR_DLAB\t \n\t\t     ,uart->base + UART_LCR);\t \n\t\tuart->old_divisor_lsb = inb(uart->base + UART_DLL);\n\t\tuart->old_divisor_msb = inb(uart->base + UART_DLM);\n\n\t\toutb(uart->divisor\n\t\t     ,uart->base + UART_DLL);\t \n\t\toutb(0\n\t\t     ,uart->base + UART_DLM);\t \n\t\t \n\t}\n\t \n\toutb(UART_LCR_WLEN8\t \n\t     | 0\t\t \n\t     | 0\t\t \n\t     | 0\t\t \n\t     ,uart->base + UART_LCR);\t \n\n\tswitch (uart->adaptor) {\n\tdefault:\n\t\toutb(UART_MCR_RTS\t \n\t\t     | UART_MCR_DTR\t \n\t\t     | UART_MCR_OUT2\t \n\t\t     ,uart->base + UART_MCR);\t \n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124W_SA:\n\tcase SNDRV_SERIAL_MS124W_MB:\n\t\t  \n\t\toutb(UART_MCR_RTS | (0&UART_MCR_DTR) | UART_MCR_OUT2,\n\t\t     uart->base + UART_MCR);\n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124T:\n\t\t \n\t\toutb(UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2,\n\t\t     uart->base + UART_MCR);\n\t\tbreak;\n\t}\n\n\tif (uart->irq < 0) {\n\t\tbyte = (0 & UART_IER_RDI)\t \n\t\t    |(0 & UART_IER_THRI)\t \n\t\t    ;\n\t} else if (uart->adaptor == SNDRV_SERIAL_MS124W_SA) {\n\t\tbyte = UART_IER_RDI\t \n\t\t    | UART_IER_MSI\t \n\t\t    ;\n\t} else if (uart->adaptor == SNDRV_SERIAL_GENERIC) {\n\t\tbyte = UART_IER_RDI\t \n\t\t    | UART_IER_MSI\t \n\t\t    | UART_IER_THRI\t \n\t\t    ;\n\t} else {\n\t\tbyte = UART_IER_RDI\t \n\t\t    | UART_IER_THRI\t \n\t\t    ;\n\t}\n\toutb(byte, uart->base + UART_IER);\t \n\n\tinb(uart->base + UART_LSR);\t \n\tinb(uart->base + UART_IIR);\t \n\tinb(uart->base + UART_RX);\t \n}\n\nstatic void snd_uart16550_do_close(struct snd_uart16550 * uart)\n{\n\tif (uart->irq < 0)\n\t\tsnd_uart16550_del_timer(uart);\n\n\t \n\n\toutb((0 & UART_IER_RDI)\t\t \n\t     |(0 & UART_IER_THRI)\t \n\t     ,uart->base + UART_IER);\t \n\n\tswitch (uart->adaptor) {\n\tdefault:\n\t\toutb((0 & UART_MCR_RTS)\t\t \n\t\t     |(0 & UART_MCR_DTR)\t \n\t\t     |(0 & UART_MCR_OUT2)\t \n\t\t     ,uart->base + UART_MCR);\t \n\t  break;\n\tcase SNDRV_SERIAL_MS124W_SA:\n\tcase SNDRV_SERIAL_MS124W_MB:\n\t\t  \n\t\toutb(UART_MCR_RTS | (0&UART_MCR_DTR) | (0&UART_MCR_OUT2),\n\t\t     uart->base + UART_MCR);\n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124T:\n\t\t \n\t\toutb(UART_MCR_RTS | UART_MCR_DTR | (0&UART_MCR_OUT2),\n\t\t     uart->base + UART_MCR);\n\t\tbreak;\n\t}\n\n\tinb(uart->base + UART_IIR);\t \n\n\t \n\tif (uart->divisor != 0) {\n\t\toutb(UART_LCR_DLAB\t\t \n\t\t     ,uart->base + UART_LCR);\t \n\t\toutb(uart->old_divisor_lsb\n\t\t     ,uart->base + UART_DLL);\t \n\t\toutb(uart->old_divisor_msb\n\t\t     ,uart->base + UART_DLM);\t \n\t\t \n\t\toutb(uart->old_line_ctrl_reg\n\t\t     ,uart->base + UART_LCR);\t \n\t}\n}\n\nstatic int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tif (uart->filemode == SERIAL_MODE_NOT_OPENED)\n\t\tsnd_uart16550_do_open(uart);\n\tuart->filemode |= SERIAL_MODE_INPUT_OPEN;\n\tuart->midi_input[substream->number] = substream;\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n\treturn 0;\n}\n\nstatic int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tuart->filemode &= ~SERIAL_MODE_INPUT_OPEN;\n\tuart->midi_input[substream->number] = NULL;\n\tif (uart->filemode == SERIAL_MODE_NOT_OPENED)\n\t\tsnd_uart16550_do_close(uart);\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n\treturn 0;\n}\n\nstatic void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\tint up)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tif (up)\n\t\tuart->filemode |= SERIAL_MODE_INPUT_TRIGGERED;\n\telse\n\t\tuart->filemode &= ~SERIAL_MODE_INPUT_TRIGGERED;\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n}\n\nstatic int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tif (uart->filemode == SERIAL_MODE_NOT_OPENED)\n\t\tsnd_uart16550_do_open(uart);\n\tuart->filemode |= SERIAL_MODE_OUTPUT_OPEN;\n\tuart->midi_output[substream->number] = substream;\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n\treturn 0;\n};\n\nstatic int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tuart->filemode &= ~SERIAL_MODE_OUTPUT_OPEN;\n\tuart->midi_output[substream->number] = NULL;\n\tif (uart->filemode == SERIAL_MODE_NOT_OPENED)\n\t\tsnd_uart16550_do_close(uart);\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n\treturn 0;\n};\n\nstatic inline int snd_uart16550_buffer_can_write(struct snd_uart16550 *uart,\n\t\t\t\t\t\t int Num)\n{\n\tif (uart->buff_in_count + Num < TX_BUFF_SIZE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic inline int snd_uart16550_write_buffer(struct snd_uart16550 *uart,\n\t\t\t\t\t     unsigned char byte)\n{\n\tunsigned short buff_in = uart->buff_in;\n\tif (uart->buff_in_count < TX_BUFF_SIZE) {\n\t\tuart->tx_buff[buff_in] = byte;\n\t\tbuff_in++;\n\t\tbuff_in &= TX_BUFF_MASK;\n\t\tuart->buff_in = buff_in;\n\t\tuart->buff_in_count++;\n\t\tif (uart->irq < 0)  \n\t\t\tsnd_uart16550_add_timer(uart);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int snd_uart16550_output_byte(struct snd_uart16550 *uart,\n\t\t\t\t     struct snd_rawmidi_substream *substream,\n\t\t\t\t     unsigned char midi_byte)\n{\n\tif (uart->buff_in_count == 0                     \n\t    && ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&\n\t    uart->adaptor != SNDRV_SERIAL_GENERIC) ||\n\t\t(uart->fifo_count == 0                   \n\t\t && (inb(uart->base + UART_MSR) & UART_MSR_CTS)))) {  \n\n\t         \n\t\tif ((inb(uart->base + UART_LSR) & UART_LSR_THRE) != 0) {\n\t\t         \n\t\t        uart->fifo_count = 1;\n\t\t\toutb(midi_byte, uart->base + UART_TX);\n\t\t} else {\n\t\t        if (uart->fifo_count < uart->fifo_limit) {\n\t\t\t        uart->fifo_count++;\n\t\t\t\toutb(midi_byte, uart->base + UART_TX);\n\t\t\t} else {\n\t\t\t         \n\t\t\t\tsnd_uart16550_write_buffer(uart, midi_byte);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!snd_uart16550_write_buffer(uart, midi_byte)) {\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"%s: Buffer overrun on device at 0x%lx\\n\",\n\t\t\t\t   uart->rmidi->name, uart->base);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)\n{\n\tunsigned long flags;\n\tunsigned char midi_byte, addr_byte;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\tchar first;\n\tstatic unsigned long lasttime = 0;\n\t\n\t \n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\n\tif (uart->irq < 0)\t \n\t\tsnd_uart16550_io_loop(uart);\n\n\tif (uart->adaptor == SNDRV_SERIAL_MS124W_MB) {\n\t\twhile (1) {\n\t\t\t \n\t\t\t \n\t\t\tif (uart->buff_in_count > TX_BUFF_SIZE - 2)\n\t\t\t\tbreak;\n\t\t\tif (snd_rawmidi_transmit(substream, &midi_byte, 1) != 1)\n\t\t\t\tbreak;\n#ifdef SNDRV_SERIAL_MS124W_MB_NOCOMBO\n\t\t\t \n\t\t\taddr_byte = (1 << (substream->number + 4)) | 0x08;\n#else\n\t\t\t \n\t\t\taddr_byte = (substream->number << 4) | 0x08;\n\t\t\t \n\t\t\tif (addr_byte == 0x08)\n\t\t\t\taddr_byte = 0xf8;\n#endif\n\t\t\tsnd_uart16550_output_byte(uart, substream, addr_byte);\n\t\t\t \n\t\t\tsnd_uart16550_output_byte(uart, substream, midi_byte);\n\t\t}\n\t} else {\n\t\tfirst = 0;\n\t\twhile (snd_rawmidi_transmit_peek(substream, &midi_byte, 1) == 1) {\n\t\t\t \n\t\t\tif (first == 0 &&\n\t\t\t    (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||\n\t\t\t     uart->adaptor == SNDRV_SERIAL_GENERIC) &&\n\t\t\t    (uart->prev_out != substream->number ||\n\t\t\t     time_after(jiffies, lasttime + 3*HZ))) {\n\n\t\t\t\tif (snd_uart16550_buffer_can_write(uart, 3)) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tuart->prev_out = substream->number;\n\t\t\t\t\t \n\t\t\t\t\tsnd_uart16550_output_byte(uart, substream,\n\t\t\t\t\t\t\t\t  0xf5);\n\t\t\t\t\t \n\t\t\t\t\tsnd_uart16550_output_byte(uart, substream,\n\t\t\t\t\t\t\t\t  uart->prev_out + 1);\n\t\t\t\t\t \n\t\t\t\t\tif (midi_byte < 0x80 &&\n\t\t\t\t\t    uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS)\n\t\t\t\t\t\tsnd_uart16550_output_byte(uart, substream, uart->prev_status[uart->prev_out]);\n\t\t\t\t} else if (!uart->drop_on_full)\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!snd_uart16550_output_byte(uart, substream, midi_byte) &&\n\t\t\t    !uart->drop_on_full )\n\t\t\t\tbreak;\n\n\t\t\tif (midi_byte >= 0x80 && midi_byte < 0xf0)\n\t\t\t\tuart->prev_status[uart->prev_out] = midi_byte;\n\t\t\tfirst = 1;\n\n\t\t\tsnd_rawmidi_transmit_ack( substream, 1 );\n\t\t}\n\t\tlasttime = jiffies;\n\t}\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n}\n\nstatic void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t\t int up)\n{\n\tunsigned long flags;\n\tstruct snd_uart16550 *uart = substream->rmidi->private_data;\n\n\tspin_lock_irqsave(&uart->open_lock, flags);\n\tif (up)\n\t\tuart->filemode |= SERIAL_MODE_OUTPUT_TRIGGERED;\n\telse\n\t\tuart->filemode &= ~SERIAL_MODE_OUTPUT_TRIGGERED;\n\tspin_unlock_irqrestore(&uart->open_lock, flags);\n\tif (up)\n\t\tsnd_uart16550_output_write(substream);\n}\n\nstatic const struct snd_rawmidi_ops snd_uart16550_output =\n{\n\t.open =\t\tsnd_uart16550_output_open,\n\t.close =\tsnd_uart16550_output_close,\n\t.trigger =\tsnd_uart16550_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_uart16550_input =\n{\n\t.open =\t\tsnd_uart16550_input_open,\n\t.close =\tsnd_uart16550_input_close,\n\t.trigger =\tsnd_uart16550_input_trigger,\n};\n\nstatic int snd_uart16550_create(struct snd_card *card,\n\t\t\t\tunsigned long iobase,\n\t\t\t\tint irq,\n\t\t\t\tunsigned int speed,\n\t\t\t\tunsigned int base,\n\t\t\t\tint adaptor,\n\t\t\t\tint droponfull,\n\t\t\t\tstruct snd_uart16550 **ruart)\n{\n\tstruct snd_uart16550 *uart;\n\tint err;\n\n\n\tuart = devm_kzalloc(card->dev, sizeof(*uart), GFP_KERNEL);\n\tif (!uart)\n\t\treturn -ENOMEM;\n\tuart->adaptor = adaptor;\n\tuart->card = card;\n\tspin_lock_init(&uart->open_lock);\n\tuart->irq = -1;\n\tuart->base = iobase;\n\tuart->drop_on_full = droponfull;\n\n\terr = snd_uart16550_detect(uart);\n\tif (err <= 0) {\n\t\tprintk(KERN_ERR \"no UART detected at 0x%lx\\n\", iobase);\n\t\treturn -ENODEV;\n\t}\n\n\tif (irq >= 0 && irq != SNDRV_AUTO_IRQ) {\n\t\tif (devm_request_irq(card->dev, irq, snd_uart16550_interrupt,\n\t\t\t\t     0, \"Serial MIDI\", uart)) {\n\t\t\tsnd_printk(KERN_WARNING\n\t\t\t\t   \"irq %d busy. Using Polling.\\n\", irq);\n\t\t} else {\n\t\t\tuart->irq = irq;\n\t\t}\n\t}\n\tuart->divisor = base / speed;\n\tuart->speed = base / (unsigned int)uart->divisor;\n\tuart->speed_base = base;\n\tuart->prev_out = -1;\n\tuart->prev_in = 0;\n\tuart->rstatus = 0;\n\tmemset(uart->prev_status, 0x80, sizeof(unsigned char) * SNDRV_SERIAL_MAX_OUTS);\n\ttimer_setup(&uart->buffer_timer, snd_uart16550_buffer_timer, 0);\n\tuart->timer_running = 0;\n\n\tswitch (uart->adaptor) {\n\tcase SNDRV_SERIAL_MS124W_SA:\n\tcase SNDRV_SERIAL_MS124W_MB:\n\t\t  \n\t\toutb(UART_MCR_RTS | (0&UART_MCR_DTR), uart->base + UART_MCR);\n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124T:\n\t\t \n\t\toutb(UART_MCR_RTS | UART_MCR_DTR, uart->base + UART_MCR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ruart)\n\t\t*ruart = uart;\n\n\treturn 0;\n}\n\nstatic void snd_uart16550_substreams(struct snd_rawmidi_str *stream)\n{\n\tstruct snd_rawmidi_substream *substream;\n\n\tlist_for_each_entry(substream, &stream->substreams, list) {\n\t\tsprintf(substream->name, \"Serial MIDI %d\", substream->number + 1);\n\t}\n}\n\nstatic int snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,\n\t\t\t       int outs, int ins,\n\t\t\t       struct snd_rawmidi **rmidi)\n{\n\tstruct snd_rawmidi *rrawmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(uart->card, \"UART Serial MIDI\", device,\n\t\t\t      outs, ins, &rrawmidi);\n\tif (err < 0)\n\t\treturn err;\n\tsnd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_uart16550_input);\n\tsnd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_uart16550_output);\n\tstrcpy(rrawmidi->name, \"Serial MIDI\");\n\tsnd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);\n\tsnd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);\n\trrawmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t       SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t       SNDRV_RAWMIDI_INFO_DUPLEX;\n\trrawmidi->private_data = uart;\n\tif (rmidi)\n\t\t*rmidi = rrawmidi;\n\treturn 0;\n}\n\nstatic int snd_serial_probe(struct platform_device *devptr)\n{\n\tstruct snd_card *card;\n\tstruct snd_uart16550 *uart;\n\tint err;\n\tint dev = devptr->id;\n\n\tswitch (adaptor[dev]) {\n\tcase SNDRV_SERIAL_SOUNDCANVAS:\n\t\tins[dev] = 1;\n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124T:\n\tcase SNDRV_SERIAL_MS124W_SA:\n\t\touts[dev] = 1;\n\t\tins[dev] = 1;\n\t\tbreak;\n\tcase SNDRV_SERIAL_MS124W_MB:\n\t\touts[dev] = 16;\n\t\tins[dev] = 1;\n\t\tbreak;\n\tcase SNDRV_SERIAL_GENERIC:\n\t\tbreak;\n\tdefault:\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"Adaptor type is out of range 0-%d (%d)\\n\",\n\t\t\t   SNDRV_SERIAL_MAX_ADAPTOR, adaptor[dev]);\n\t\treturn -ENODEV;\n\t}\n\n\tif (outs[dev] < 1 || outs[dev] > SNDRV_SERIAL_MAX_OUTS) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"Count of outputs is out of range 1-%d (%d)\\n\",\n\t\t\t   SNDRV_SERIAL_MAX_OUTS, outs[dev]);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ins[dev] < 1 || ins[dev] > SNDRV_SERIAL_MAX_INS) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"Count of inputs is out of range 1-%d (%d)\\n\",\n\t\t\t   SNDRV_SERIAL_MAX_INS, ins[dev]);\n\t\treturn -ENODEV;\n\t}\n\n\terr  = snd_devm_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\t 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"Serial\");\n\tstrcpy(card->shortname, \"Serial MIDI (UART16550A)\");\n\n\terr = snd_uart16550_create(card, port[dev], irq[dev], speed[dev],\n\t\t\t\t   base[dev], adaptor[dev], droponfull[dev],\n\t\t\t\t   &uart);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi);\n\tif (err < 0)\n\t\treturn err;\n\n\tsprintf(card->longname, \"%s [%s] at %#lx, irq %d\",\n\t\tcard->shortname,\n\t\tadaptor_names[uart->adaptor],\n\t\tuart->base,\n\t\tuart->irq);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#define SND_SERIAL_DRIVER\t\"snd_serial_u16550\"\n\nstatic struct platform_driver snd_serial_driver = {\n\t.probe\t\t= snd_serial_probe,\n\t.driver\t\t= {\n\t\t.name\t= SND_SERIAL_DRIVER,\n\t},\n};\n\nstatic void snd_serial_unregister_all(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); ++i)\n\t\tplatform_device_unregister(devices[i]);\n\tplatform_driver_unregister(&snd_serial_driver);\n}\n\nstatic int __init alsa_card_serial_init(void)\n{\n\tint i, cards, err;\n\n\terr = platform_driver_register(&snd_serial_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tcards = 0;\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tstruct platform_device *device;\n\t\tif (! enable[i])\n\t\t\tcontinue;\n\t\tdevice = platform_device_register_simple(SND_SERIAL_DRIVER,\n\t\t\t\t\t\t\t i, NULL, 0);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (!platform_get_drvdata(device)) {\n\t\t\tplatform_device_unregister(device);\n\t\t\tcontinue;\n\t\t}\n\t\tdevices[i] = device;\n\t\tcards++;\n\t}\n\tif (! cards) {\n#ifdef MODULE\n\t\tprintk(KERN_ERR \"serial midi soundcard not found or device busy\\n\");\n#endif\n\t\tsnd_serial_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_serial_exit(void)\n{\n\tsnd_serial_unregister_all();\n}\n\nmodule_init(alsa_card_serial_init)\nmodule_exit(alsa_card_serial_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}