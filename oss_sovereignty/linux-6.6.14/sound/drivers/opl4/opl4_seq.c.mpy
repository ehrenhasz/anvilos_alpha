{
  "module_name": "opl4_seq.c",
  "hash_id": "e806e28793f7a1a148792ffc4c08187afcc4bec26c285b46e67fe3ce95eb854a",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl4/opl4_seq.c",
  "human_readable_source": " \n\n#include \"opl4_local.h\"\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"OPL4 wavetable synth driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nint volume_boost = 8;\n\nmodule_param(volume_boost, int, 0644);\nMODULE_PARM_DESC(volume_boost, \"Additional volume for OPL4 wavetable sounds.\");\n\nstatic int snd_opl4_seq_use_inc(struct snd_opl4 *opl4)\n{\n\tif (!try_module_get(opl4->card->module))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void snd_opl4_seq_use_dec(struct snd_opl4 *opl4)\n{\n\tmodule_put(opl4->card->module);\n}\n\nstatic int snd_opl4_seq_use(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_opl4 *opl4 = private_data;\n\tint err;\n\n\tmutex_lock(&opl4->access_mutex);\n\n\tif (opl4->used) {\n\t\tmutex_unlock(&opl4->access_mutex);\n\t\treturn -EBUSY;\n\t}\n\topl4->used++;\n\n\tif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {\n\t\terr = snd_opl4_seq_use_inc(opl4);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&opl4->access_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmutex_unlock(&opl4->access_mutex);\n\n\tsnd_opl4_synth_reset(opl4);\n\treturn 0;\n}\n\nstatic int snd_opl4_seq_unuse(void *private_data, struct snd_seq_port_subscribe *info)\n{\n\tstruct snd_opl4 *opl4 = private_data;\n\n\tsnd_opl4_synth_shutdown(opl4);\n\n\tmutex_lock(&opl4->access_mutex);\n\topl4->used--;\n\tmutex_unlock(&opl4->access_mutex);\n\n\tif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)\n\t\tsnd_opl4_seq_use_dec(opl4);\n\treturn 0;\n}\n\nstatic const struct snd_midi_op opl4_ops = {\n\t.note_on =\t\tsnd_opl4_note_on,\n\t.note_off =\t\tsnd_opl4_note_off,\n\t.note_terminate =\tsnd_opl4_terminate_note,\n\t.control =\t\tsnd_opl4_control,\n\t.sysex =\t\tsnd_opl4_sysex,\n};\n\nstatic int snd_opl4_seq_event_input(struct snd_seq_event *ev, int direct,\n\t\t\t\t    void *private_data, int atomic, int hop)\n{\n\tstruct snd_opl4 *opl4 = private_data;\n\n\tsnd_midi_process_event(&opl4_ops, ev, opl4->chset);\n\treturn 0;\n}\n\nstatic void snd_opl4_seq_free_port(void *private_data)\n{\n\tstruct snd_opl4 *opl4 = private_data;\n\n\tsnd_midi_channel_free_set(opl4->chset);\n}\n\nstatic int snd_opl4_seq_probe(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_opl4 *opl4;\n\tint client;\n\tstruct snd_seq_port_callback pcallbacks;\n\n\topl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\tif (!opl4)\n\t\treturn -EINVAL;\n\n\tif (snd_yrw801_detect(opl4) < 0)\n\t\treturn -ENODEV;\n\n\topl4->chset = snd_midi_channel_alloc_set(16);\n\tif (!opl4->chset)\n\t\treturn -ENOMEM;\n\topl4->chset->private_data = opl4;\n\n\t \n\tclient = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num,\n\t\t\t\t\t      \"OPL4 Wavetable\");\n\tif (client < 0) {\n\t\tsnd_midi_channel_free_set(opl4->chset);\n\t\treturn client;\n\t}\n\topl4->seq_client = client;\n\topl4->chset->client = client;\n\n\t \n\tmemset(&pcallbacks, 0, sizeof(pcallbacks));\n\tpcallbacks.owner = THIS_MODULE;\n\tpcallbacks.use = snd_opl4_seq_use;\n\tpcallbacks.unuse = snd_opl4_seq_unuse;\n\tpcallbacks.event_input = snd_opl4_seq_event_input;\n\tpcallbacks.private_free = snd_opl4_seq_free_port;\n\tpcallbacks.private_data = opl4;\n\n\topl4->chset->port = snd_seq_event_port_attach(client, &pcallbacks,\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_CAP_WRITE |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_MIDI_GM |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_HARDWARE |\n\t\t\t\t\t\t      SNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\n\t\t\t\t\t\t      16, 24,\n\t\t\t\t\t\t      \"OPL4 Wavetable Port\");\n\tif (opl4->chset->port < 0) {\n\t\tint err = opl4->chset->port;\n\t\tsnd_midi_channel_free_set(opl4->chset);\n\t\tsnd_seq_delete_kernel_client(client);\n\t\topl4->seq_client = -1;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_opl4_seq_remove(struct device *_dev)\n{\n\tstruct snd_seq_device *dev = to_seq_dev(_dev);\n\tstruct snd_opl4 *opl4;\n\n\topl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\n\tif (!opl4)\n\t\treturn -EINVAL;\n\n\tif (opl4->seq_client >= 0) {\n\t\tsnd_seq_delete_kernel_client(opl4->seq_client);\n\t\topl4->seq_client = -1;\n\t}\n\treturn 0;\n}\n\nstatic struct snd_seq_driver opl4_seq_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.probe = snd_opl4_seq_probe,\n\t\t.remove = snd_opl4_seq_remove,\n\t},\n\t.id = SNDRV_SEQ_DEV_ID_OPL4,\n\t.argsize = sizeof(struct snd_opl4 *),\n};\n\nmodule_snd_seq_driver(opl4_seq_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}