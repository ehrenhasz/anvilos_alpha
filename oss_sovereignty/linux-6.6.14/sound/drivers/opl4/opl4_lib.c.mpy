{
  "module_name": "opl4_lib.c",
  "hash_id": "272faf3716922c36ec0673c6a96a06e79f1e1680cddcdb966108553edcc4d608",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl4/opl4_lib.c",
  "human_readable_source": "\n \n\n#include \"opl4_local.h\"\n#include <sound/initval.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\nMODULE_AUTHOR(\"Clemens Ladisch <clemens@ladisch.de>\");\nMODULE_DESCRIPTION(\"OPL4 driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic inline void snd_opl4_wait(struct snd_opl4 *opl4)\n{\n\tint timeout = 10;\n\twhile ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)\n\t\t;\n}\n\nvoid snd_opl4_write(struct snd_opl4 *opl4, u8 reg, u8 value)\n{\n\tsnd_opl4_wait(opl4);\n\toutb(reg, opl4->pcm_port);\n\n\tsnd_opl4_wait(opl4);\n\toutb(value, opl4->pcm_port + 1);\n}\n\nEXPORT_SYMBOL(snd_opl4_write);\n\nu8 snd_opl4_read(struct snd_opl4 *opl4, u8 reg)\n{\n\tsnd_opl4_wait(opl4);\n\toutb(reg, opl4->pcm_port);\n\n\tsnd_opl4_wait(opl4);\n\treturn inb(opl4->pcm_port + 1);\n}\n\nEXPORT_SYMBOL(snd_opl4_read);\n\nvoid snd_opl4_read_memory(struct snd_opl4 *opl4, char *buf, int offset, int size)\n{\n\tunsigned long flags;\n\tu8 memcfg;\n\n\tspin_lock_irqsave(&opl4->reg_lock, flags);\n\n\tmemcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);\n\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);\n\n\tsnd_opl4_wait(opl4);\n\toutb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);\n\tsnd_opl4_wait(opl4);\n\tinsb(opl4->pcm_port + 1, buf, size);\n\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);\n\n\tspin_unlock_irqrestore(&opl4->reg_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_opl4_read_memory);\n\nvoid snd_opl4_write_memory(struct snd_opl4 *opl4, const char *buf, int offset, int size)\n{\n\tunsigned long flags;\n\tu8 memcfg;\n\n\tspin_lock_irqsave(&opl4->reg_lock, flags);\n\n\tmemcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);\n\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);\n\n\tsnd_opl4_wait(opl4);\n\toutb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);\n\tsnd_opl4_wait(opl4);\n\toutsb(opl4->pcm_port + 1, buf, size);\n\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);\n\n\tspin_unlock_irqrestore(&opl4->reg_lock, flags);\n}\n\nEXPORT_SYMBOL(snd_opl4_write_memory);\n\nstatic void snd_opl4_enable_opl4(struct snd_opl4 *opl4)\n{\n\toutb(OPL3_REG_MODE, opl4->fm_port + 2);\n\tinb(opl4->fm_port);\n\tinb(opl4->fm_port);\n\toutb(OPL3_OPL3_ENABLE | OPL3_OPL4_ENABLE, opl4->fm_port + 3);\n\tinb(opl4->fm_port);\n\tinb(opl4->fm_port);\n}\n\nstatic int snd_opl4_detect(struct snd_opl4 *opl4)\n{\n\tu8 id1, id2;\n\n\tsnd_opl4_enable_opl4(opl4);\n\n\tid1 = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\n\tsnd_printdd(\"OPL4[02]=%02x\\n\", id1);\n\tswitch (id1 & OPL4_DEVICE_ID_MASK) {\n\tcase 0x20:\n\t\topl4->hardware = OPL3_HW_OPL4;\n\t\tbreak;\n\tcase 0x40:\n\t\topl4->hardware = OPL3_HW_OPL4_ML;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x00);\n\tsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0xff);\n\tid1 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_FM);\n\tid2 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_PCM);\n\tsnd_printdd(\"OPL4 id1=%02x id2=%02x\\n\", id1, id2);\n       \tif (id1 != 0x00 || id2 != 0xff)\n\t\treturn -ENODEV;\n\n\tsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x3f);\n\tsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0x3f);\n\tsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, 0x00);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\nstatic void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)\n{\n\tstruct snd_opl4 *opl4 = seq_dev->private_data;\n\topl4->seq_dev = NULL;\n}\n\nstatic int snd_opl4_create_seq_dev(struct snd_opl4 *opl4, int seq_device)\n{\n\topl4->seq_dev_num = seq_device;\n\tif (snd_seq_device_new(opl4->card, seq_device, SNDRV_SEQ_DEV_ID_OPL4,\n\t\t\t       sizeof(struct snd_opl4 *), &opl4->seq_dev) >= 0) {\n\t\tstrcpy(opl4->seq_dev->name, \"OPL4 Wavetable\");\n\t\t*(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(opl4->seq_dev) = opl4;\n\t\topl4->seq_dev->private_data = opl4;\n\t\topl4->seq_dev->private_free = snd_opl4_seq_dev_free;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void snd_opl4_free(struct snd_opl4 *opl4)\n{\n\tsnd_opl4_free_proc(opl4);\n\trelease_and_free_resource(opl4->res_fm_port);\n\trelease_and_free_resource(opl4->res_pcm_port);\n\tkfree(opl4);\n}\n\nstatic int snd_opl4_dev_free(struct snd_device *device)\n{\n\tstruct snd_opl4 *opl4 = device->device_data;\n\tsnd_opl4_free(opl4);\n\treturn 0;\n}\n\nint snd_opl4_create(struct snd_card *card,\n\t\t    unsigned long fm_port, unsigned long pcm_port,\n\t\t    int seq_device,\n\t\t    struct snd_opl3 **ropl3, struct snd_opl4 **ropl4)\n{\n\tstruct snd_opl4 *opl4;\n\tstruct snd_opl3 *opl3;\n\tint err;\n\tstatic const struct snd_device_ops ops = {\n\t\t.dev_free = snd_opl4_dev_free\n\t};\n\n\tif (ropl3)\n\t\t*ropl3 = NULL;\n\tif (ropl4)\n\t\t*ropl4 = NULL;\n\n\topl4 = kzalloc(sizeof(*opl4), GFP_KERNEL);\n\tif (!opl4)\n\t\treturn -ENOMEM;\n\n\topl4->res_fm_port = request_region(fm_port, 8, \"OPL4 FM\");\n\topl4->res_pcm_port = request_region(pcm_port, 8, \"OPL4 PCM/MIX\");\n\tif (!opl4->res_fm_port || !opl4->res_pcm_port) {\n\t\tsnd_printk(KERN_ERR \"opl4: can't grab ports 0x%lx, 0x%lx\\n\", fm_port, pcm_port);\n\t\tsnd_opl4_free(opl4);\n\t\treturn -EBUSY;\n\t}\n\n\topl4->card = card;\n\topl4->fm_port = fm_port;\n\topl4->pcm_port = pcm_port;\n\tspin_lock_init(&opl4->reg_lock);\n\tmutex_init(&opl4->access_mutex);\n\n\terr = snd_opl4_detect(opl4);\n\tif (err < 0) {\n\t\tsnd_opl4_free(opl4);\n\t\tsnd_printd(\"OPL4 chip not detected at %#lx/%#lx\\n\", fm_port, pcm_port);\n\t\treturn err;\n\t}\n\n\terr = snd_device_new(card, SNDRV_DEV_CODEC, opl4, &ops);\n\tif (err < 0) {\n\t\tsnd_opl4_free(opl4);\n\t\treturn err;\n\t}\n\n\terr = snd_opl3_create(card, fm_port, fm_port + 2, opl4->hardware, 1, &opl3);\n\tif (err < 0) {\n\t\tsnd_device_free(card, opl4);\n\t\treturn err;\n\t}\n\n\t \n\tsnd_opl4_enable_opl4(opl4);\n\n\tsnd_opl4_create_mixer(opl4);\n\tsnd_opl4_create_proc(opl4);\n\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\n\topl4->seq_client = -1;\n\tif (opl4->hardware < OPL3_HW_OPL4_ML)\n\t\tsnd_opl4_create_seq_dev(opl4, seq_device);\n#endif\n\n\tif (ropl3)\n\t\t*ropl3 = opl3;\n\tif (ropl4)\n\t\t*ropl4 = opl4;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_opl4_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}