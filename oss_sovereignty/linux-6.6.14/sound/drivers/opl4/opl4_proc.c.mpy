{
  "module_name": "opl4_proc.c",
  "hash_id": "5184374d8361c94ab7784956d015e20e7385483e4a671a6e2cad3f10bd61a8e2",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/opl4/opl4_proc.c",
  "human_readable_source": "\n \n\n#include \"opl4_local.h\"\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <sound/info.h>\n\nstatic int snd_opl4_mem_proc_open(struct snd_info_entry *entry,\n\t\t\t\t  unsigned short mode, void **file_private_data)\n{\n\tstruct snd_opl4 *opl4 = entry->private_data;\n\n\tmutex_lock(&opl4->access_mutex);\n\tif (opl4->memory_access) {\n\t\tmutex_unlock(&opl4->access_mutex);\n\t\treturn -EBUSY;\n\t}\n\topl4->memory_access++;\n\tmutex_unlock(&opl4->access_mutex);\n\treturn 0;\n}\n\nstatic int snd_opl4_mem_proc_release(struct snd_info_entry *entry,\n\t\t\t\t     unsigned short mode, void *file_private_data)\n{\n\tstruct snd_opl4 *opl4 = entry->private_data;\n\n\tmutex_lock(&opl4->access_mutex);\n\topl4->memory_access--;\n\tmutex_unlock(&opl4->access_mutex);\n\treturn 0;\n}\n\nstatic ssize_t snd_opl4_mem_proc_read(struct snd_info_entry *entry,\n\t\t\t\t      void *file_private_data,\n\t\t\t\t      struct file *file, char __user *_buf,\n\t\t\t\t      size_t count, loff_t pos)\n{\n\tstruct snd_opl4 *opl4 = entry->private_data;\n\tchar* buf;\n\n\tbuf = vmalloc(count);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tsnd_opl4_read_memory(opl4, buf, pos, count);\n\tif (copy_to_user(_buf, buf, count)) {\n\t\tvfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tvfree(buf);\n\treturn count;\n}\n\nstatic ssize_t snd_opl4_mem_proc_write(struct snd_info_entry *entry,\n\t\t\t\t       void *file_private_data,\n\t\t\t\t       struct file *file,\n\t\t\t\t       const char __user *_buf,\n\t\t\t\t       size_t count, loff_t pos)\n{\n\tstruct snd_opl4 *opl4 = entry->private_data;\n\tchar *buf;\n\n\tbuf = vmalloc(count);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, _buf, count)) {\n\t\tvfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tsnd_opl4_write_memory(opl4, buf, pos, count);\n\tvfree(buf);\n\treturn count;\n}\n\nstatic const struct snd_info_entry_ops snd_opl4_mem_proc_ops = {\n\t.open = snd_opl4_mem_proc_open,\n\t.release = snd_opl4_mem_proc_release,\n\t.read = snd_opl4_mem_proc_read,\n\t.write = snd_opl4_mem_proc_write,\n};\n\nint snd_opl4_create_proc(struct snd_opl4 *opl4)\n{\n\tstruct snd_info_entry *entry;\n\n\tentry = snd_info_create_card_entry(opl4->card, \"opl4-mem\", opl4->card->proc_root);\n\tif (entry) {\n\t\tif (opl4->hardware < OPL3_HW_OPL4_ML) {\n\t\t\t \n\t\t\tentry->mode |= 0200;\n\t\t\tentry->size = 4 * 1024 * 1024;\n\t\t} else {\n\t\t\t \n\t\t\tentry->size = 1 * 1024 * 1024;\n\t\t}\n\t\tentry->content = SNDRV_INFO_CONTENT_DATA;\n\t\tentry->c.ops = &snd_opl4_mem_proc_ops;\n\t\tentry->module = THIS_MODULE;\n\t\tentry->private_data = opl4;\n\t}\n\topl4->proc_entry = entry;\n\treturn 0;\n}\n\nvoid snd_opl4_free_proc(struct snd_opl4 *opl4)\n{\n\tsnd_info_free_entry(opl4->proc_entry);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}