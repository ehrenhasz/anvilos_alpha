{
  "module_name": "vx_uer.c",
  "hash_id": "2158d1c816eda45d83679e604c227fd89dba87c5f1109bb8c75cd04fa47b5f79",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/vx/vx_uer.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/vx_core.h>\n#include \"vx_cmd.h\"\n\n\n \nstatic int vx_modify_board_clock(struct vx_core *chip, int sync)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_MODIFY_CLOCK);\n\t \n\tif (sync)\n\t\trmh.Cmd[0] |= CMD_MODIFY_CLOCK_S_BIT;\n\treturn vx_send_msg(chip, &rmh);\n}\n\n \nstatic int vx_modify_board_inputs(struct vx_core *chip)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_RESYNC_AUDIO_INPUTS);\n        rmh.Cmd[0] |= 1 << 0;  \n\treturn vx_send_msg(chip, &rmh);\n}\n\n \nstatic int vx_read_one_cbit(struct vx_core *chip, int index)\n{\n\tint val;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->type >= VX_TYPE_VXPOCKET) {\n\t\tvx_outb(chip, CSUER, 1);  \n\t\tvx_outb(chip, RUER, index & XX_UER_CBITS_OFFSET_MASK);\n\t\tval = (vx_inb(chip, RUER) >> 7) & 0x01;\n\t} else {\n\t\tvx_outl(chip, CSUER, 1);  \n\t\tvx_outl(chip, RUER, index & XX_UER_CBITS_OFFSET_MASK);\n\t\tval = (vx_inl(chip, RUER) >> 7) & 0x01;\n\t}\n\tmutex_unlock(&chip->lock);\n\treturn val;\n}\n\n \nstatic void vx_write_one_cbit(struct vx_core *chip, int index, int val)\n{\n\tval = !!val;\t \n\tmutex_lock(&chip->lock);\n\tif (vx_is_pcmcia(chip)) {\n\t\tvx_outb(chip, CSUER, 0);  \n\t\tvx_outb(chip, RUER, (val << 7) | (index & XX_UER_CBITS_OFFSET_MASK));\n\t} else {\n\t\tvx_outl(chip, CSUER, 0);  \n\t\tvx_outl(chip, RUER, (val << 7) | (index & XX_UER_CBITS_OFFSET_MASK));\n\t}\n\tmutex_unlock(&chip->lock);\n}\n\n \nstatic int vx_read_uer_status(struct vx_core *chip, unsigned int *mode)\n{\n\tint val, freq;\n\n\t \n\tfreq = 0;\n\n\t \n\tif (vx_is_pcmcia(chip))\n\t    val = vx_inb(chip, CSUER);\n\telse\n\t    val = vx_inl(chip, CSUER);\n\tif (val < 0)\n\t\treturn val;\n\t \n\tif (val & VX_SUER_CLOCK_PRESENT_MASK) {\n\t\tswitch (val & VX_SUER_FREQ_MASK) {\n\t\tcase VX_SUER_FREQ_32KHz_MASK:\n\t\t\tfreq = 32000;\n\t\t\tbreak;\n\t\tcase VX_SUER_FREQ_44KHz_MASK:\n\t\t\tfreq = 44100;\n\t\t\tbreak;\n\t\tcase VX_SUER_FREQ_48KHz_MASK:\n\t\t\tfreq = 48000;\n\t\t\tbreak;\n\t\t}\n        }\n\tif (val & VX_SUER_DATA_PRESENT_MASK)\n\t\t \n\t\t*mode = vx_read_one_cbit(chip, 0) ?\n\t\t\tVX_UER_MODE_PROFESSIONAL : VX_UER_MODE_CONSUMER;\n\telse\n\t\t*mode = VX_UER_MODE_NOT_PRESENT;\n\n\treturn freq;\n}\n\n\n \n\nstatic int vx_calc_clock_from_freq(struct vx_core *chip, int freq)\n{\n\tint hexfreq;\n\n\tif (snd_BUG_ON(freq <= 0))\n\t\treturn 0;\n\n\thexfreq = (28224000 * 10) / freq;\n\thexfreq = (hexfreq + 5) / 10;\n\n\t \n\tif (snd_BUG_ON(hexfreq <= 0x00000200))\n\t\treturn 0;\n\n\tif (hexfreq <= 0x03ff)\n\t\treturn hexfreq - 0x00000201;\n\tif (hexfreq <= 0x07ff) \n\t\treturn (hexfreq / 2) - 1;\n\tif (hexfreq <= 0x0fff)\n\t\treturn (hexfreq / 4) + 0x000001ff;\n\n\treturn 0x5fe; \t \n}\n\n\n \nstatic void vx_change_clock_source(struct vx_core *chip, int source)\n{\n\t \n\tvx_toggle_dac_mute(chip, 1);\n\tmutex_lock(&chip->lock);\n\tchip->ops->set_clock_source(chip, source);\n\tchip->clock_source = source;\n\tmutex_unlock(&chip->lock);\n\t \n\tvx_toggle_dac_mute(chip, 0);\n}\n\n\n \nvoid vx_set_internal_clock(struct vx_core *chip, unsigned int freq)\n{\n\tint clock;\n\n\t \n\tclock = vx_calc_clock_from_freq(chip, freq);\n\tsnd_printdd(KERN_DEBUG \"set internal clock to 0x%x from freq %d\\n\", clock, freq);\n\tmutex_lock(&chip->lock);\n\tif (vx_is_pcmcia(chip)) {\n\t\tvx_outb(chip, HIFREQ, (clock >> 8) & 0x0f);\n\t\tvx_outb(chip, LOFREQ, clock & 0xff);\n\t} else {\n\t\tvx_outl(chip, HIFREQ, (clock >> 8) & 0x0f);\n\t\tvx_outl(chip, LOFREQ, clock & 0xff);\n\t}\n\tmutex_unlock(&chip->lock);\n}\n\n\n \nvoid vx_set_iec958_status(struct vx_core *chip, unsigned int bits)\n{\n\tint i;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn;\n\n\tfor (i = 0; i < 32; i++)\n\t\tvx_write_one_cbit(chip, i, bits & (1 << i));\n}\n\n\n \nint vx_set_clock(struct vx_core *chip, unsigned int freq)\n{\n\tint src_changed = 0;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn 0;\n\n\t \n\tvx_sync_audio_source(chip);\n\n\tif (chip->clock_mode == VX_CLOCK_MODE_EXTERNAL ||\n\t    (chip->clock_mode == VX_CLOCK_MODE_AUTO &&\n\t     chip->audio_source == VX_AUDIO_SRC_DIGITAL)) {\n\t\tif (chip->clock_source != UER_SYNC) {\n\t\t\tvx_change_clock_source(chip, UER_SYNC);\n\t\t\tmdelay(6);\n\t\t\tsrc_changed = 1;\n\t\t}\n\t} else if (chip->clock_mode == VX_CLOCK_MODE_INTERNAL ||\n\t\t   (chip->clock_mode == VX_CLOCK_MODE_AUTO &&\n\t\t    chip->audio_source != VX_AUDIO_SRC_DIGITAL)) {\n\t\tif (chip->clock_source != INTERNAL_QUARTZ) {\n\t\t\tvx_change_clock_source(chip, INTERNAL_QUARTZ);\n\t\t\tsrc_changed = 1;\n\t\t}\n\t\tif (chip->freq == freq)\n\t\t\treturn 0;\n\t\tvx_set_internal_clock(chip, freq);\n\t\tif (src_changed)\n\t\t\tvx_modify_board_inputs(chip);\n\t}\n\tif (chip->freq == freq)\n\t\treturn 0;\n\tchip->freq = freq;\n\tvx_modify_board_clock(chip, 1);\n\treturn 0;\n}\n\n\n \nint vx_change_frequency(struct vx_core *chip)\n{\n\tint freq;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn 0;\n\n\tif (chip->clock_source == INTERNAL_QUARTZ)\n\t\treturn 0;\n\t \n\tfreq = vx_read_uer_status(chip, &chip->uer_detected);\n\tif (freq < 0)\n\t\treturn freq;\n\t \n\tif (freq == 48000 || freq == 44100 || freq == 32000)\n\t\tchip->freq_detected = freq;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}