{
  "module_name": "vx_core.c",
  "hash_id": "c9760e11d425fb9cf2a72641c8f4a6f90eb4f8cea8c44d35c621cf4f4f59444f",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/vx/vx_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/asoundef.h>\n#include <sound/info.h>\n#include <sound/vx_core.h>\n#include \"vx_cmd.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"Common routines for Digigram VX drivers\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nint snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time)\n{\n\tunsigned long end_time = jiffies + (time * HZ + 999) / 1000;\n\tstatic const char * const reg_names[VX_REG_MAX] = {\n\t\t\"ICR\", \"CVR\", \"ISR\", \"IVR\", \"RXH\", \"RXM\", \"RXL\",\n\t\t\"DMA\", \"CDSP\", \"RFREQ\", \"RUER/V2\", \"DATA\", \"MEMIRQ\",\n\t\t\"ACQ\", \"BIT0\", \"BIT1\", \"MIC0\", \"MIC1\", \"MIC2\",\n\t\t\"MIC3\", \"INTCSR\", \"CNTRL\", \"GPIOC\",\n\t\t\"LOFREQ\", \"HIFREQ\", \"CSUER\", \"RUER\"\n\t};\n\n\tdo {\n\t\tif ((snd_vx_inb(chip, reg) & mask) == bit)\n\t\t\treturn 0;\n\t\t\n\t} while (time_after_eq(end_time, jiffies));\n\tsnd_printd(KERN_DEBUG \"vx_check_reg_bit: timeout, reg=%s, mask=0x%x, val=0x%x\\n\", reg_names[reg], mask, snd_vx_inb(chip, reg));\n\treturn -EIO;\n}\n\nEXPORT_SYMBOL(snd_vx_check_reg_bit);\n\n \nstatic int vx_send_irq_dsp(struct vx_core *chip, int num)\n{\n\tint nirq;\n\n\t \n\tif (snd_vx_check_reg_bit(chip, VX_CVR, CVR_HC, 0, 200) < 0)\n\t\treturn -EIO;\n\n\tnirq = num;\n\tif (vx_has_new_dsp(chip))\n\t\tnirq += VXP_IRQ_OFFSET;\n\tvx_outb(chip, CVR, (nirq >> 1) | CVR_HC);\n\treturn 0;\n}\n\n\n \nstatic int vx_reset_chk(struct vx_core *chip)\n{\n\t \n\tif (vx_send_irq_dsp(chip, IRQ_RESET_CHK) < 0)\n\t\treturn -EIO;\n\t \n\tif (vx_check_isr(chip, ISR_CHK, 0, 200) < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int vx_transfer_end(struct vx_core *chip, int cmd)\n{\n\tint err;\n\n\terr = vx_reset_chk(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = vx_send_irq_dsp(chip, cmd);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = vx_wait_isr_bit(chip, ISR_CHK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = vx_inb(chip, ISR);\n\tif (err & ISR_ERR) {\n\t\terr = vx_wait_for_rx_full(chip);\n\t\tif (err < 0) {\n\t\t\tsnd_printd(KERN_DEBUG \"transfer_end: error in rx_full\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = vx_inb(chip, RXH) << 16;\n\t\terr |= vx_inb(chip, RXM) << 8;\n\t\terr |= vx_inb(chip, RXL);\n\t\tsnd_printd(KERN_DEBUG \"transfer_end: error = 0x%x\\n\", err);\n\t\treturn -(VX_ERR_MASK | err);\n\t}\n\treturn 0;\n}\n\n \nstatic int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)\n{\n\tint i, err, val, size;\n\n\t \n\tif (rmh->DspStat == RMH_SSIZE_FIXED && rmh->LgStat == 0)\n\t\treturn 0;\n\n\t \n\terr = vx_wait_for_rx_full(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tval = vx_inb(chip, RXH) << 16;\n\tval |= vx_inb(chip, RXM) << 8;\n\tval |= vx_inb(chip, RXL);\n\n\t \n\tswitch (rmh->DspStat) {\n\tcase RMH_SSIZE_ARG:\n\t\tsize = val & 0xff;\n\t\trmh->Stat[0] = val & 0xffff00;\n\t\trmh->LgStat = size + 1;\n\t\tbreak;\n\tcase RMH_SSIZE_MASK:\n\t\t \n\t\trmh->Stat[0] = val;\n\t\tsize = 0;\n\t\twhile (val) {\n\t\t\tif (val & 0x01)\n\t\t\t\tsize++;\n\t\t\tval >>= 1;\n\t\t}\n\t\trmh->LgStat = size + 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsize = rmh->LgStat;\n\t\trmh->Stat[0] = val;   \n\t\tsize--;               \n\t\tbreak;\n        }\n\n\tif (size < 1)\n\t\treturn 0;\n\tif (snd_BUG_ON(size >= SIZE_MAX_STATUS))\n\t\treturn -EINVAL;\n\n\tfor (i = 1; i <= size; i++) {\n\t\t \n\t\terr = vx_send_irq_dsp(chip, IRQ_MESS_WRITE_NEXT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t \n\t\terr = vx_wait_for_rx_full(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\trmh->Stat[i] = vx_inb(chip, RXH) << 16;\n\t\trmh->Stat[i] |= vx_inb(chip, RXM) <<  8;\n\t\trmh->Stat[i] |= vx_inb(chip, RXL);\n\t}\n\n\treturn vx_transfer_end(chip, IRQ_MESS_WRITE_END);\n}\n\n\n#define MASK_MORE_THAN_1_WORD_COMMAND   0x00008000\n#define MASK_1_WORD_COMMAND             0x00ff7fff\n\n \nint vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)\n{\n\tint i, err;\n\t\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\terr = vx_reset_chk(chip);\n\tif (err < 0) {\n\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: vx_reset_chk error\\n\");\n\t\treturn err;\n\t}\n\n#if 0\n\tprintk(KERN_DEBUG \"rmh: cmd = 0x%06x, length = %d, stype = %d\\n\",\n\t       rmh->Cmd[0], rmh->LgCmd, rmh->DspStat);\n\tif (rmh->LgCmd > 1) {\n\t\tprintk(KERN_DEBUG \"  \");\n\t\tfor (i = 1; i < rmh->LgCmd; i++)\n\t\t\tprintk(KERN_CONT \"0x%06x \", rmh->Cmd[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n#endif\n\t \n\tif (rmh->LgCmd > 1)\n\t\trmh->Cmd[0] |= MASK_MORE_THAN_1_WORD_COMMAND;\n\telse\n\t\trmh->Cmd[0] &= MASK_1_WORD_COMMAND;\n\n\t \n\terr = vx_wait_isr_bit(chip, ISR_TX_EMPTY);\n\tif (err < 0) {\n\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: wait tx empty error\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tvx_outb(chip, TXH, (rmh->Cmd[0] >> 16) & 0xff);\n\tvx_outb(chip, TXM, (rmh->Cmd[0] >> 8) & 0xff);\n\tvx_outb(chip, TXL, rmh->Cmd[0] & 0xff);\n\n\t \n\terr = vx_send_irq_dsp(chip, IRQ_MESSAGE);\n\tif (err < 0) {\n\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: send IRQ_MESSAGE error\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = vx_wait_isr_bit(chip, ISR_CHK);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (vx_inb(chip, ISR) & ISR_ERR) {\n\t\terr = vx_wait_for_rx_full(chip);\n\t\tif (err < 0) {\n\t\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: rx_full read error\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = vx_inb(chip, RXH) << 16;\n\t\terr |= vx_inb(chip, RXM) << 8;\n\t\terr |= vx_inb(chip, RXL);\n\t\tsnd_printd(KERN_DEBUG \"msg got error = 0x%x at cmd[0]\\n\", err);\n\t\terr = -(VX_ERR_MASK | err);\n\t\treturn err;\n\t}\n\n\t \n\tif (rmh->LgCmd > 1) {\n\t\tfor (i = 1; i < rmh->LgCmd; i++) {\n\t\t\t \n\t\t\terr = vx_wait_isr_bit(chip, ISR_TX_READY);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: tx_ready error\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t \n\t\t\tvx_outb(chip, TXH, (rmh->Cmd[i] >> 16) & 0xff);\n\t\t\tvx_outb(chip, TXM, (rmh->Cmd[i] >> 8) & 0xff);\n\t\t\tvx_outb(chip, TXL, rmh->Cmd[i] & 0xff);\n\n\t\t\t \n\t\t\terr = vx_send_irq_dsp(chip, IRQ_MESS_READ_NEXT);\n\t\t\tif (err < 0) {\n\t\t\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: IRQ_READ_NEXT error\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\t \n\t\terr = vx_wait_isr_bit(chip, ISR_TX_READY);\n\t\tif (err < 0) {\n\t\t\tsnd_printd(KERN_DEBUG \"vx_send_msg: TX_READY error\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\terr = vx_transfer_end(chip, IRQ_MESS_READ_END);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn vx_read_status(chip, rmh);\n}\n\n\n \nint vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh)\n{\n\tint err;\n\n\tmutex_lock(&chip->lock);\n\terr = vx_send_msg_nolock(chip, rmh);\n\tmutex_unlock(&chip->lock);\n\treturn err;\n}\n\n\n \nint vx_send_rih_nolock(struct vx_core *chip, int cmd)\n{\n\tint err;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n#if 0\n\tprintk(KERN_DEBUG \"send_rih: cmd = 0x%x\\n\", cmd);\n#endif\n\terr = vx_reset_chk(chip);\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = vx_send_irq_dsp(chip, cmd);\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = vx_wait_isr_bit(chip, ISR_CHK);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tif (vx_inb(chip, ISR) & ISR_ERR) {\n\t\terr = vx_wait_for_rx_full(chip);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = vx_inb(chip, RXH) << 16;\n\t\terr |= vx_inb(chip, RXM) << 8;\n\t\terr |= vx_inb(chip, RXL);\n\t\treturn -(VX_ERR_MASK | err);\n\t}\n\treturn 0;\n}\n\n\n \nint vx_send_rih(struct vx_core *chip, int cmd)\n{\n\tint err;\n\n\tmutex_lock(&chip->lock);\n\terr = vx_send_rih_nolock(chip, cmd);\n\tmutex_unlock(&chip->lock);\n\treturn err;\n}\n\n#define END_OF_RESET_WAIT_TIME\t\t500\t \n\n \nint snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)\n{\n\tunsigned int i;\n\tint no_fillup = vx_has_new_dsp(chip);\n\n\t \n\tif (boot->size <= 0)\n\t\treturn -EINVAL;\n\tif (boot->size % 3)\n\t\treturn -EINVAL;\n#if 0\n\t{\n\t\t \n\t\tunsigned int c = ((u32)boot->data[0] << 16) | ((u32)boot->data[1] << 8) | boot->data[2];\n\t\tif (boot->size != (c + 2) * 3)\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\n\t \n\tvx_reset_dsp(chip);\n\t\n\tudelay(END_OF_RESET_WAIT_TIME);  \n\n\t \n\tfor (i = 0; i < 0x600; i += 3) {\n\t\tif (i >= boot->size) {\n\t\t\tif (no_fillup)\n\t\t\t\tbreak;\n\t\t\tif (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"dsp boot failed at %d\\n\", i);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tvx_outb(chip, TXH, 0);\n\t\t\tvx_outb(chip, TXM, 0);\n\t\t\tvx_outb(chip, TXL, 0);\n\t\t} else {\n\t\t\tconst unsigned char *image = boot->data + i;\n\t\t\tif (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"dsp boot failed at %d\\n\", i);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tvx_outb(chip, TXH, image[0]);\n\t\t\tvx_outb(chip, TXM, image[1]);\n\t\t\tvx_outb(chip, TXL, image[2]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_vx_load_boot_image);\n\n \nstatic int vx_test_irq_src(struct vx_core *chip, unsigned int *ret)\n{\n\tint err;\n\n\tvx_init_rmh(&chip->irq_rmh, CMD_TEST_IT);\n\tmutex_lock(&chip->lock);\n\terr = vx_send_msg_nolock(chip, &chip->irq_rmh);\n\tif (err < 0)\n\t\t*ret = 0;\n\telse\n\t\t*ret = chip->irq_rmh.Stat[0];\n\tmutex_unlock(&chip->lock);\n\treturn err;\n}\n\n\n \nirqreturn_t snd_vx_threaded_irq_handler(int irq, void *dev)\n{\n\tstruct vx_core *chip = dev;\n\tunsigned int events;\n\t\t\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn IRQ_HANDLED;\n\n\tif (vx_test_irq_src(chip, &events) < 0)\n\t\treturn IRQ_HANDLED;\n    \n#if 0\n\tif (events & 0x000800)\n\t\tprintk(KERN_ERR \"DSP Stream underrun ! IRQ events = 0x%x\\n\", events);\n#endif\n\t\n\n\t \n\tif (events & FATAL_DSP_ERROR) {\n\t\tsnd_printk(KERN_ERR \"vx_core: fatal DSP error!!\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (events & TIME_CODE_EVENT_PENDING) {\n\t\t;  \n\t}\n\n\t \n\tif (events & FREQUENCY_CHANGE_EVENT_PENDING)\n\t\tvx_change_frequency(chip);\n\n\t \n\tvx_pcm_update_intr(chip, events);\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(snd_vx_threaded_irq_handler);\n\n \nirqreturn_t snd_vx_irq_handler(int irq, void *dev)\n{\n\tstruct vx_core *chip = dev;\n\n\tif (! (chip->chip_status & VX_STAT_CHIP_INIT) ||\n\t    (chip->chip_status & VX_STAT_IS_STALE))\n\t\treturn IRQ_NONE;\n\tif (! vx_test_and_ack(chip))\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_NONE;\n}\n\nEXPORT_SYMBOL(snd_vx_irq_handler);\n\n \nstatic void vx_reset_board(struct vx_core *chip, int cold_reset)\n{\n\tif (snd_BUG_ON(!chip->ops->reset_board))\n\t\treturn;\n\n\t \n\tchip->audio_source = VX_AUDIO_SRC_LINE;\n\tif (cold_reset) {\n\t\tchip->audio_source_target = chip->audio_source;\n\t\tchip->clock_source = INTERNAL_QUARTZ;\n\t\tchip->clock_mode = VX_CLOCK_MODE_AUTO;\n\t\tchip->freq = 48000;\n\t\tchip->uer_detected = VX_UER_MODE_NOT_PRESENT;\n\t\tchip->uer_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;\n\t}\n\n\tchip->ops->reset_board(chip, cold_reset);\n\n\tvx_reset_codec(chip, cold_reset);\n\n\tvx_set_internal_clock(chip, chip->freq);\n\n\t \n\tvx_reset_dsp(chip);\n\n\tif (vx_is_pcmcia(chip)) {\n\t\t \n\t\tvx_test_and_ack(chip);\n\t\tvx_validate_irq(chip, 1);\n\t}\n\n\t \n\tvx_set_iec958_status(chip, chip->uer_bits);\n}\n\n\n \n\nstatic void vx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\n{\n\tstruct vx_core *chip = entry->private_data;\n\tstatic const char * const audio_src_vxp[] = { \"Line\", \"Mic\", \"Digital\" };\n\tstatic const char * const audio_src_vx2[] = { \"Analog\", \"Analog\", \"Digital\" };\n\tstatic const char * const clock_mode[] = { \"Auto\", \"Internal\", \"External\" };\n\tstatic const char * const clock_src[] = { \"Internal\", \"External\" };\n\tstatic const char * const uer_type[] = { \"Consumer\", \"Professional\", \"Not Present\" };\n\t\n\tsnd_iprintf(buffer, \"%s\\n\", chip->card->longname);\n\tsnd_iprintf(buffer, \"Xilinx Firmware: %s\\n\",\n\t\t    (chip->chip_status & VX_STAT_XILINX_LOADED) ? \"Loaded\" : \"No\");\n\tsnd_iprintf(buffer, \"Device Initialized: %s\\n\",\n\t\t    (chip->chip_status & VX_STAT_DEVICE_INIT) ? \"Yes\" : \"No\");\n\tsnd_iprintf(buffer, \"DSP audio info:\");\n\tif (chip->audio_info & VX_AUDIO_INFO_REAL_TIME)\n\t\tsnd_iprintf(buffer, \" realtime\");\n\tif (chip->audio_info & VX_AUDIO_INFO_OFFLINE)\n\t\tsnd_iprintf(buffer, \" offline\");\n\tif (chip->audio_info & VX_AUDIO_INFO_MPEG1)\n\t\tsnd_iprintf(buffer, \" mpeg1\");\n\tif (chip->audio_info & VX_AUDIO_INFO_MPEG2)\n\t\tsnd_iprintf(buffer, \" mpeg2\");\n\tif (chip->audio_info & VX_AUDIO_INFO_LINEAR_8)\n\t\tsnd_iprintf(buffer, \" linear8\");\n\tif (chip->audio_info & VX_AUDIO_INFO_LINEAR_16)\n\t\tsnd_iprintf(buffer, \" linear16\");\n\tif (chip->audio_info & VX_AUDIO_INFO_LINEAR_24)\n\t\tsnd_iprintf(buffer, \" linear24\");\n\tsnd_iprintf(buffer, \"\\n\");\n\tsnd_iprintf(buffer, \"Input Source: %s\\n\", vx_is_pcmcia(chip) ?\n\t\t    audio_src_vxp[chip->audio_source] :\n\t\t    audio_src_vx2[chip->audio_source]);\n\tsnd_iprintf(buffer, \"Clock Mode: %s\\n\", clock_mode[chip->clock_mode]);\n\tsnd_iprintf(buffer, \"Clock Source: %s\\n\", clock_src[chip->clock_source]);\n\tsnd_iprintf(buffer, \"Frequency: %d\\n\", chip->freq);\n\tsnd_iprintf(buffer, \"Detected Frequency: %d\\n\", chip->freq_detected);\n\tsnd_iprintf(buffer, \"Detected UER type: %s\\n\", uer_type[chip->uer_detected]);\n\tsnd_iprintf(buffer, \"Min/Max/Cur IBL: %d/%d/%d (granularity=%d)\\n\",\n\t\t    chip->ibl.min_size, chip->ibl.max_size, chip->ibl.size,\n\t\t    chip->ibl.granularity);\n}\n\nstatic void vx_proc_init(struct vx_core *chip)\n{\n\tsnd_card_ro_proc_new(chip->card, \"vx-status\", chip, vx_proc_read);\n}\n\n\n \nint snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *boot)\n{\n\tint err;\n\tint cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);\n\n\tvx_reset_board(chip, cold_reset);\n\tvx_validate_irq(chip, 0);\n\n\terr = snd_vx_load_boot_image(chip, boot);\n\tif (err < 0)\n\t\treturn err;\n\tmsleep(10);\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_vx_dsp_boot);\n\n \nint snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)\n{\n\tunsigned int i;\n\tint err;\n\tunsigned int csum = 0;\n\tconst unsigned char *image, *cptr;\n\n\tif (dsp->size % 3)\n\t\treturn -EINVAL;\n\n\tvx_toggle_dac_mute(chip, 1);\n\n\t \n\tfor (i = 0; i < dsp->size; i += 3) {\n\t\timage = dsp->data + i;\n\t\t \n\t\terr = vx_wait_isr_bit(chip, ISR_TX_EMPTY);\n\t\tif (err < 0) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"dsp loading error at position %d\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t\tcptr = image;\n\t\tcsum ^= *cptr;\n\t\tcsum = (csum >> 24) | (csum << 8);\n\t\tvx_outb(chip, TXH, *cptr++);\n\t\tcsum ^= *cptr;\n\t\tcsum = (csum >> 24) | (csum << 8);\n\t\tvx_outb(chip, TXM, *cptr++);\n\t\tcsum ^= *cptr;\n\t\tcsum = (csum >> 24) | (csum << 8);\n\t\tvx_outb(chip, TXL, *cptr++);\n\t}\n\tsnd_printdd(KERN_DEBUG \"checksum = 0x%08x\\n\", csum);\n\n\tmsleep(200);\n\n\terr = vx_wait_isr_bit(chip, ISR_CHK);\n\tif (err < 0)\n\t\treturn err;\n\n\tvx_toggle_dac_mute(chip, 0);\n\n\tvx_test_and_ack(chip);\n\tvx_validate_irq(chip, 1);\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_vx_dsp_load);\n\n#ifdef CONFIG_PM\n \nint snd_vx_suspend(struct vx_core *chip)\n{\n\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tchip->chip_status |= VX_STAT_IN_SUSPEND;\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_vx_suspend);\n\n \nint snd_vx_resume(struct vx_core *chip)\n{\n\tint i, err;\n\n\tchip->chip_status &= ~VX_STAT_CHIP_INIT;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (! chip->firmware[i])\n\t\t\tcontinue;\n\t\terr = chip->ops->load_dsp(chip, i, chip->firmware[i]);\n\t\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"vx: firmware resume error at DSP %d\\n\", i);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tchip->chip_status |= VX_STAT_CHIP_INIT;\n\tchip->chip_status &= ~VX_STAT_IN_SUSPEND;\n\n\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_vx_resume);\n#endif\n\nstatic void snd_vx_release(struct device *dev, void *data)\n{\n\tsnd_vx_free_firmware(data);\n}\n\n \nstruct vx_core *snd_vx_create(struct snd_card *card,\n\t\t\t      const struct snd_vx_hardware *hw,\n\t\t\t      const struct snd_vx_ops *ops,\n\t\t\t      int extra_size)\n{\n\tstruct vx_core *chip;\n\n\tif (snd_BUG_ON(!card || !hw || !ops))\n\t\treturn NULL;\n\n\tchip = devres_alloc(snd_vx_release, sizeof(*chip) + extra_size,\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn NULL;\n\tmutex_init(&chip->lock);\n\tchip->irq = -1;\n\tchip->hw = hw;\n\tchip->type = hw->type;\n\tchip->ops = ops;\n\tmutex_init(&chip->mixer_mutex);\n\n\tchip->card = card;\n\tcard->private_data = chip;\n\tstrcpy(card->driver, hw->name);\n\tsprintf(card->shortname, \"Digigram %s\", hw->name);\n\n\tvx_proc_init(chip);\n\n\treturn chip;\n}\n\nEXPORT_SYMBOL(snd_vx_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}