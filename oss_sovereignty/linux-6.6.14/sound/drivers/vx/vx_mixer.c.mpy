{
  "module_name": "vx_mixer.c",
  "hash_id": "9dee1b1445a0eef6bde415cdfe75949cae05d489f087ef0a991574f0305f4608",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/vx/vx_mixer.c",
  "human_readable_source": "\n \n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/vx_core.h>\n#include \"vx_cmd.h\"\n\n\n \nstatic void vx_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)\n{\n\tif (snd_BUG_ON(!chip->ops->write_codec))\n\t\treturn;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn;\n\n\tmutex_lock(&chip->lock);\n\tchip->ops->write_codec(chip, codec, data);\n\tmutex_unlock(&chip->lock);\n}\n\n \nunion vx_codec_data {\n\tu32 l;\n#ifdef SNDRV_BIG_ENDIAN\n\tstruct w {\n\t\tu16 h;\n\t\tu16 l;\n\t} w;\n\tstruct b {\n\t\tu8 hh;\n\t\tu8 mh;\n\t\tu8 ml;\n\t\tu8 ll;\n\t} b;\n#else  \n\tstruct w {\n\t\tu16 l;\n\t\tu16 h;\n\t} w;\n\tstruct b {\n\t\tu8 ll;\n\t\tu8 ml;\n\t\tu8 mh;\n\t\tu8 hh;\n\t} b;\n#endif\n};\n\n#define SET_CDC_DATA_SEL(di,s)          ((di).b.mh = (u8) (s))\n#define SET_CDC_DATA_REG(di,r)          ((di).b.ml = (u8) (r))\n#define SET_CDC_DATA_VAL(di,d)          ((di).b.ll = (u8) (d))\n#define SET_CDC_DATA_INIT(di)           ((di).l = 0L, SET_CDC_DATA_SEL(di,XX_CODEC_SELECTOR))\n\n \nstatic void vx_set_codec_reg(struct vx_core *chip, int codec, int reg, int val)\n{\n\tunion vx_codec_data data;\n\t \n\tSET_CDC_DATA_INIT(data);\n\tSET_CDC_DATA_REG(data, reg);\n\tSET_CDC_DATA_VAL(data, val);\n\tvx_write_codec_reg(chip, codec, data.l);\n}\n\n\n \nstatic void vx_set_analog_output_level(struct vx_core *chip, int codec, int left, int right)\n{\n\tleft  = chip->hw->output_level_max - left;\n\tright = chip->hw->output_level_max - right;\n\n\tif (chip->ops->akm_write) {\n\t\tchip->ops->akm_write(chip, XX_CODEC_LEVEL_LEFT_REGISTER, left);\n\t\tchip->ops->akm_write(chip, XX_CODEC_LEVEL_RIGHT_REGISTER, right);\n\t} else {\n\t\t \n\t\tvx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_LEFT_REGISTER, left);\n\t\tvx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_RIGHT_REGISTER, right);\n\t}\n}\n\n\n \n\n#define DAC_ATTEN_MIN\t0x08\n#define DAC_ATTEN_MAX\t0x38\n\nvoid vx_toggle_dac_mute(struct vx_core *chip, int mute)\n{\n\tunsigned int i;\n\tfor (i = 0; i < chip->hw->num_codecs; i++) {\n\t\tif (chip->ops->akm_write)\n\t\t\tchip->ops->akm_write(chip, XX_CODEC_DAC_CONTROL_REGISTER, mute);  \n\t\telse\n\t\t\tvx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER,\n\t\t\t\t\t mute ? DAC_ATTEN_MAX : DAC_ATTEN_MIN);\n\t}\n}\n\n \nvoid vx_reset_codec(struct vx_core *chip, int cold_reset)\n{\n\tunsigned int i;\n\tint port = chip->type >= VX_TYPE_VXPOCKET ? 0x75 : 0x65;\n\n\tchip->ops->reset_codec(chip);\n\n\t \n\tif (! chip->ops->akm_write) {\n\t\t \n\t\tfor (i = 0; i < chip->hw->num_codecs; i++) {\n\t\t\t \n\t\t\tvx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER, DAC_ATTEN_MAX);\n\t\t\t \n\t\t\tvx_set_codec_reg(chip, i, XX_CODEC_ADC_CONTROL_REGISTER, 0x00);\n\t\t\t \n\t\t\tvx_set_codec_reg(chip, i, XX_CODEC_PORT_MODE_REGISTER, port);\n\t\t\t \n\t\t\tvx_set_codec_reg(chip, i, XX_CODEC_CLOCK_CONTROL_REGISTER, 0x00);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < chip->hw->num_codecs; i++) {\n\t\tchip->output_level[i][0] = 0;\n\t\tchip->output_level[i][1] = 0;\n\t\tvx_set_analog_output_level(chip, i, 0, 0);\n\t}\n}\n\n \nstatic void vx_change_audio_source(struct vx_core *chip, int src)\n{\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn;\n\n\tmutex_lock(&chip->lock);\n\tchip->ops->change_audio_source(chip, src);\n\tmutex_unlock(&chip->lock);\n}\n\n\n \nint vx_sync_audio_source(struct vx_core *chip)\n{\n\tif (chip->audio_source_target == chip->audio_source ||\n\t    chip->pcm_running)\n\t\treturn 0;\n\tvx_change_audio_source(chip, chip->audio_source_target);\n\tchip->audio_source = chip->audio_source_target;\n\treturn 1;\n}\n\n\n \nstruct vx_audio_level {\n\tunsigned int has_level: 1;\n\tunsigned int has_monitor_level: 1;\n\tunsigned int has_mute: 1;\n\tunsigned int has_monitor_mute: 1;\n\tunsigned int mute;\n\tunsigned int monitor_mute;\n\tshort level;\n\tshort monitor_level;\n};\n\nstatic int vx_adjust_audio_level(struct vx_core *chip, int audio, int capture,\n\t\t\t\t struct vx_audio_level *info)\n{\n\tstruct vx_rmh rmh;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n        vx_init_rmh(&rmh, CMD_AUDIO_LEVEL_ADJUST);\n\tif (capture)\n\t\trmh.Cmd[0] |= COMMAND_RECORD_MASK;\n\t \n\trmh.Cmd[1] = 1 << audio;\n\trmh.Cmd[2] = 0;\n\tif (info->has_level) {\n\t\trmh.Cmd[0] |=  VALID_AUDIO_IO_DIGITAL_LEVEL;\n\t\trmh.Cmd[2] |= info->level;\n        }\n\tif (info->has_monitor_level) {\n\t\trmh.Cmd[0] |=  VALID_AUDIO_IO_MONITORING_LEVEL;\n\t\trmh.Cmd[2] |= ((unsigned int)info->monitor_level << 10);\n        }\n\tif (info->has_mute) { \n\t\trmh.Cmd[0] |= VALID_AUDIO_IO_MUTE_LEVEL;\n\t\tif (info->mute)\n\t\t\trmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_LEVEL;\n\t}\n\tif (info->has_monitor_mute) {\n\t\t  \n\t\trmh.Cmd[0] |=  VALID_AUDIO_IO_MUTE_MONITORING_1 | VALID_AUDIO_IO_MUTE_MONITORING_2;\n\t\tif (info->monitor_mute)\n\t\t\trmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_MONITORING_1;\n\t}\n\n\treturn vx_send_msg(chip, &rmh);\n}\n\n    \n#if 0 \nstatic int vx_read_audio_level(struct vx_core *chip, int audio, int capture,\n\t\t\t       struct vx_audio_level *info)\n{\n\tint err;\n\tstruct vx_rmh rmh;\n\n\tmemset(info, 0, sizeof(*info));\n        vx_init_rmh(&rmh, CMD_GET_AUDIO_LEVELS);\n\tif (capture)\n\t\trmh.Cmd[0] |= COMMAND_RECORD_MASK;\n\t \n\trmh.Cmd[1] = 1 << audio;\n\terr = vx_send_msg(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\tinfo.level = rmh.Stat[0] & MASK_DSP_WORD_LEVEL;\n\tinfo.monitor_level = (rmh.Stat[0] >> 10) & MASK_DSP_WORD_LEVEL;\n\tinfo.mute = (rmh.Stat[i] & AUDIO_IO_HAS_MUTE_LEVEL) ? 1 : 0;\n\tinfo.monitor_mute = (rmh.Stat[i] & AUDIO_IO_HAS_MUTE_MONITORING_1) ? 1 : 0;\n\treturn 0;\n}\n#endif \n\n \nint vx_set_monitor_level(struct vx_core *chip, int audio, int level, int active)\n{\n\tstruct vx_audio_level info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.has_monitor_level = 1;\n\tinfo.monitor_level = level;\n\tinfo.has_monitor_mute = 1;\n\tinfo.monitor_mute = !active;\n\tchip->audio_monitor[audio] = level;\n\tchip->audio_monitor_active[audio] = active;\n\treturn vx_adjust_audio_level(chip, audio, 0, &info);  \n}\n\n\n \nstatic int vx_set_audio_switch(struct vx_core *chip, int audio, int active)\n{\n\tstruct vx_audio_level info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.has_mute = 1;\n\tinfo.mute = !active;\n\tchip->audio_active[audio] = active;\n\treturn vx_adjust_audio_level(chip, audio, 0, &info);  \n}\n\n \nstatic int vx_set_audio_gain(struct vx_core *chip, int audio, int capture, int level)\n{\n\tstruct vx_audio_level info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.has_level = 1;\n\tinfo.level = level;\n\tchip->audio_gain[capture][audio] = level;\n\treturn vx_adjust_audio_level(chip, audio, capture, &info);\n}\n\n \nstatic void vx_reset_audio_levels(struct vx_core *chip)\n{\n\tunsigned int i, c;\n\tstruct vx_audio_level info;\n\n\tmemset(chip->audio_gain, 0, sizeof(chip->audio_gain));\n\tmemset(chip->audio_active, 0, sizeof(chip->audio_active));\n\tmemset(chip->audio_monitor, 0, sizeof(chip->audio_monitor));\n\tmemset(chip->audio_monitor_active, 0, sizeof(chip->audio_monitor_active));\n\n\tfor (c = 0; c < 2; c++) {\n\t\tfor (i = 0; i < chip->hw->num_ins * 2; i++) {\n\t\t\tmemset(&info, 0, sizeof(info));\n\t\t\tif (c == 0) {\n\t\t\t\tinfo.has_monitor_level = 1;\n\t\t\t\tinfo.has_mute = 1;\n\t\t\t\tinfo.has_monitor_mute = 1;\n\t\t\t}\n\t\t\tinfo.has_level = 1;\n\t\t\tinfo.level = CVAL_0DB;  \n\t\t\tvx_adjust_audio_level(chip, i, c, &info);\n\t\t\tchip->audio_gain[c][i] = CVAL_0DB;\n\t\t\tchip->audio_monitor[i] = CVAL_0DB;\n\t\t}\n\t}\n}\n\n\n \n\n#define VU_METER_CHANNELS\t2\n\nstruct vx_vu_meter {\n\tint saturated;\n\tint vu_level;\n\tint peak_level;\n};\n\n \nstatic int vx_get_audio_vu_meter(struct vx_core *chip, int audio, int capture, struct vx_vu_meter *info)\n{\n\tstruct vx_rmh rmh;\n\tint i, err;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\tvx_init_rmh(&rmh, CMD_AUDIO_VU_PIC_METER);\n\trmh.LgStat += 2 * VU_METER_CHANNELS;\n\tif (capture)\n\t\trmh.Cmd[0] |= COMMAND_RECORD_MASK;\n    \n         \n\trmh.Cmd[1] = 0;\n\tfor (i = 0; i < VU_METER_CHANNELS; i++)\n\t\trmh.Cmd[1] |= 1 << (audio + i);\n\terr = vx_send_msg(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tfor (i = 0; i < 2 * VU_METER_CHANNELS; i +=2) {\n\t\tinfo->saturated = (rmh.Stat[0] & (1 << (audio + i))) ? 1 : 0;\n\t\tinfo->vu_level = rmh.Stat[i + 1];\n\t\tinfo->peak_level = rmh.Stat[i + 2];\n\t\tinfo++;\n\t}\n\treturn 0;\n}\n   \n\n \n\n \nstatic int vx_output_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = chip->hw->output_level_max;\n\treturn 0;\n}\n\nstatic int vx_output_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->id.index;\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->output_level[codec][0];\n\tucontrol->value.integer.value[1] = chip->output_level[codec][1];\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint codec = kcontrol->id.index;\n\tunsigned int val[2], vmax;\n\n\tvmax = chip->hw->output_level_max;\n\tval[0] = ucontrol->value.integer.value[0];\n\tval[1] = ucontrol->value.integer.value[1];\n\tif (val[0] > vmax || val[1] > vmax)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mixer_mutex);\n\tif (val[0] != chip->output_level[codec][0] ||\n\t    val[1] != chip->output_level[codec][1]) {\n\t\tvx_set_analog_output_level(chip, codec, val[0], val[1]);\n\t\tchip->output_level[codec][0] = val[0];\n\t\tchip->output_level[codec][1] = val[1];\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_output_level = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.name =\t\t\"Master Playback Volume\",\n\t.info =\t\tvx_output_level_info,\n\t.get =\t\tvx_output_level_get,\n\t.put =\t\tvx_output_level_put,\n\t \n};\n\n \nstatic int vx_audio_src_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts_mic[3] = {\n\t\t\"Digital\", \"Line\", \"Mic\"\n\t};\n\tstatic const char * const texts_vx2[2] = {\n\t\t\"Digital\", \"Analog\"\n\t};\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\n\tif (chip->type >= VX_TYPE_VXPOCKET)\n\t\treturn snd_ctl_enum_info(uinfo, 1, 3, texts_mic);\n\telse\n\t\treturn snd_ctl_enum_info(uinfo, 1, 2, texts_vx2);\n}\n\nstatic int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = chip->audio_source_target;\n\treturn 0;\n}\n\nstatic int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\n\tif (chip->type >= VX_TYPE_VXPOCKET) {\n\t\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (ucontrol->value.enumerated.item[0] > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&chip->mixer_mutex);\n\tif (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {\n\t\tchip->audio_source_target = ucontrol->value.enumerated.item[0];\n\t\tvx_sync_audio_source(chip);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_audio_src = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Capture Source\",\n\t.info =\t\tvx_audio_src_info,\n\t.get =\t\tvx_audio_src_get,\n\t.put =\t\tvx_audio_src_put,\n};\n\n \nstatic int vx_clock_mode_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"Auto\", \"Internal\", \"External\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tucontrol->value.enumerated.item[0] = chip->clock_mode;\n\treturn 0;\n}\n\nstatic int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.enumerated.item[0] > 2)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mixer_mutex);\n\tif (chip->clock_mode != ucontrol->value.enumerated.item[0]) {\n\t\tchip->clock_mode = ucontrol->value.enumerated.item[0];\n\t\tvx_set_clock(chip, chip->freq);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_clock_mode = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Clock Mode\",\n\t.info =\t\tvx_clock_mode_info,\n\t.get =\t\tvx_clock_mode_get,\n\t.put =\t\tvx_clock_mode_put,\n};\n\n \nstatic int vx_audio_gain_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = CVAL_MAX;\n\treturn 0;\n}\n\nstatic int vx_audio_gain_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\tint capture = (kcontrol->private_value >> 8) & 1;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->audio_gain[capture][audio];\n\tucontrol->value.integer.value[1] = chip->audio_gain[capture][audio+1];\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_audio_gain_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\tint capture = (kcontrol->private_value >> 8) & 1;\n\tunsigned int val[2];\n\n\tval[0] = ucontrol->value.integer.value[0];\n\tval[1] = ucontrol->value.integer.value[1];\n\tif (val[0] > CVAL_MAX || val[1] > CVAL_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&chip->mixer_mutex);\n\tif (val[0] != chip->audio_gain[capture][audio] ||\n\t    val[1] != chip->audio_gain[capture][audio+1]) {\n\t\tvx_set_audio_gain(chip, audio, capture, val[0]);\n\t\tvx_set_audio_gain(chip, audio+1, capture, val[1]);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_audio_monitor_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->audio_monitor[audio];\n\tucontrol->value.integer.value[1] = chip->audio_monitor[audio+1];\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\tunsigned int val[2];\n\n\tval[0] = ucontrol->value.integer.value[0];\n\tval[1] = ucontrol->value.integer.value[1];\n\tif (val[0] > CVAL_MAX || val[1] > CVAL_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tif (val[0] != chip->audio_monitor[audio] ||\n\t    val[1] != chip->audio_monitor[audio+1]) {\n\t\tvx_set_monitor_level(chip, audio, val[0],\n\t\t\t\t     chip->audio_monitor_active[audio]);\n\t\tvx_set_monitor_level(chip, audio+1, val[1],\n\t\t\t\t     chip->audio_monitor_active[audio+1]);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\n#define vx_audio_sw_info\tsnd_ctl_boolean_stereo_info\n\nstatic int vx_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->audio_active[audio];\n\tucontrol->value.integer.value[1] = chip->audio_active[audio+1];\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tif (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||\n\t    ucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {\n\t\tvx_set_audio_switch(chip, audio,\n\t\t\t\t    !!ucontrol->value.integer.value[0]);\n\t\tvx_set_audio_switch(chip, audio+1,\n\t\t\t\t    !!ucontrol->value.integer.value[1]);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.integer.value[0] = chip->audio_monitor_active[audio];\n\tucontrol->value.integer.value[1] = chip->audio_monitor_active[audio+1];\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tint audio = kcontrol->private_value & 0xff;\n\n\tmutex_lock(&chip->mixer_mutex);\n\tif (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||\n\t    ucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {\n\t\tvx_set_monitor_level(chip, audio, chip->audio_monitor[audio],\n\t\t\t\t     !!ucontrol->value.integer.value[0]);\n\t\tvx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],\n\t\t\t\t     !!ucontrol->value.integer.value[1]);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);\n\nstatic const struct snd_kcontrol_new vx_control_audio_gain = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t \n\t.info =         vx_audio_gain_info,\n\t.get =          vx_audio_gain_get,\n\t.put =          vx_audio_gain_put,\n\t.tlv = { .p = db_scale_audio_gain },\n};\nstatic const struct snd_kcontrol_new vx_control_output_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"PCM Playback Switch\",\n\t.info =         vx_audio_sw_info,\n\t.get =          vx_audio_sw_get,\n\t.put =          vx_audio_sw_put\n};\nstatic const struct snd_kcontrol_new vx_control_monitor_gain = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Monitoring Volume\",\n\t.access =\t(SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READ),\n\t.info =         vx_audio_gain_info,\t \n\t.get =          vx_audio_monitor_get,\n\t.put =          vx_audio_monitor_put,\n\t.tlv = { .p = db_scale_audio_gain },\n};\nstatic const struct snd_kcontrol_new vx_control_monitor_switch = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =         \"Monitoring Switch\",\n\t.info =         vx_audio_sw_info,\t \n\t.get =          vx_monitor_sw_get,\n\t.put =          vx_monitor_sw_put\n};\n\n\n \nstatic int vx_iec958_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int vx_iec958_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&chip->mixer_mutex);\n\tucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;\n\tucontrol->value.iec958.status[1] = (chip->uer_bits >> 8) & 0xff;\n\tucontrol->value.iec958.status[2] = (chip->uer_bits >> 16) & 0xff;\n\tucontrol->value.iec958.status[3] = (chip->uer_bits >> 24) & 0xff;\n\tmutex_unlock(&chip->mixer_mutex);\n        return 0;\n}\n\nstatic int vx_iec958_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.iec958.status[0] = 0xff;\n\tucontrol->value.iec958.status[1] = 0xff;\n\tucontrol->value.iec958.status[2] = 0xff;\n\tucontrol->value.iec958.status[3] = 0xff;\n        return 0;\n}\n\nstatic int vx_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned int val;\n\n\tval = (ucontrol->value.iec958.status[0] << 0) |\n\t      (ucontrol->value.iec958.status[1] << 8) |\n\t      (ucontrol->value.iec958.status[2] << 16) |\n\t      (ucontrol->value.iec958.status[3] << 24);\n\tmutex_lock(&chip->mixer_mutex);\n\tif (chip->uer_bits != val) {\n\t\tchip->uer_bits = val;\n\t\tvx_set_iec958_status(chip, val);\n\t\tmutex_unlock(&chip->mixer_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&chip->mixer_mutex);\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_iec958_mask = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,MASK),\n\t.info =\t\tvx_iec958_info,\t \n\t.get =\t\tvx_iec958_mask_get,\n};\n\nstatic const struct snd_kcontrol_new vx_control_iec958 = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =         SNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =         vx_iec958_info,\n\t.get =          vx_iec958_get,\n\t.put =          vx_iec958_put\n};\n\n\n \n\n#define METER_MAX\t0xff\n#define METER_SHIFT\t16\n\nstatic int vx_vu_meter_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = METER_MAX;\n\treturn 0;\n}\n\nstatic int vx_vu_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tstruct vx_vu_meter meter[2];\n\tint audio = kcontrol->private_value & 0xff;\n\tint capture = (kcontrol->private_value >> 8) & 1;\n\n\tvx_get_audio_vu_meter(chip, audio, capture, meter);\n\tucontrol->value.integer.value[0] = meter[0].vu_level >> METER_SHIFT;\n\tucontrol->value.integer.value[1] = meter[1].vu_level >> METER_SHIFT;\n\treturn 0;\n}\n\nstatic int vx_peak_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tstruct vx_vu_meter meter[2];\n\tint audio = kcontrol->private_value & 0xff;\n\tint capture = (kcontrol->private_value >> 8) & 1;\n\n\tvx_get_audio_vu_meter(chip, audio, capture, meter);\n\tucontrol->value.integer.value[0] = meter[0].peak_level >> METER_SHIFT;\n\tucontrol->value.integer.value[1] = meter[1].peak_level >> METER_SHIFT;\n\treturn 0;\n}\n\n#define vx_saturation_info\tsnd_ctl_boolean_stereo_info\n\nstatic int vx_saturation_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\n\tstruct vx_vu_meter meter[2];\n\tint audio = kcontrol->private_value & 0xff;\n\n\tvx_get_audio_vu_meter(chip, audio, 1, meter);  \n\tucontrol->value.integer.value[0] = meter[0].saturated;\n\tucontrol->value.integer.value[1] = meter[1].saturated;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new vx_control_vu_meter = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t \n\t.info =\t\tvx_vu_meter_info,\n\t.get =\t\tvx_vu_meter_get,\n};\n\nstatic const struct snd_kcontrol_new vx_control_peak_meter = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t \n\t.info =\t\tvx_vu_meter_info,\t \n\t.get =\t\tvx_peak_meter_get,\n};\n\nstatic const struct snd_kcontrol_new vx_control_saturation = {\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name =\t\t\"Input Saturation\",\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info =\t\tvx_saturation_info,\n\t.get =\t\tvx_saturation_get,\n};\n\n\n\n \n\nint snd_vx_mixer_new(struct vx_core *chip)\n{\n\tunsigned int i, c;\n\tint err;\n\tstruct snd_kcontrol_new temp;\n\tstruct snd_card *card = chip->card;\n\tchar name[32];\n\n\tstrcpy(card->mixername, card->driver);\n\n\t \n\tfor (i = 0; i < chip->hw->num_outs; i++) {\n\t\ttemp = vx_control_output_level;\n\t\ttemp.index = i;\n\t\ttemp.tlv.p = chip->hw->output_level_db_scale;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < chip->hw->num_outs; i++) {\n\t\tint val = i * 2;\n\t\ttemp = vx_control_audio_gain;\n\t\ttemp.index = i;\n\t\ttemp.name = \"PCM Playback Volume\";\n\t\ttemp.private_value = val;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\ttemp = vx_control_output_switch;\n\t\ttemp.index = i;\n\t\ttemp.private_value = val;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\ttemp = vx_control_monitor_gain;\n\t\ttemp.index = i;\n\t\ttemp.private_value = val;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\ttemp = vx_control_monitor_switch;\n\t\ttemp.index = i;\n\t\ttemp.private_value = val;\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < chip->hw->num_outs; i++) {\n\t\ttemp = vx_control_audio_gain;\n\t\ttemp.index = i;\n\t\ttemp.name = \"PCM Capture Volume\";\n\t\ttemp.private_value = (i * 2) | (1 << 8);\n\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = snd_ctl_add(card, snd_ctl_new1(&vx_control_audio_src, chip));\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = snd_ctl_add(card, snd_ctl_new1(&vx_control_clock_mode, chip));\n\tif (err < 0)\n\t\treturn err;\n\t \n\terr = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958_mask, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958, chip));\n\tif (err < 0)\n\t\treturn err;\n\t \n\tfor (c = 0; c < 2; c++) {\n\t\tstatic const char * const dir[2] = { \"Output\", \"Input\" };\n\t\tfor (i = 0; i < chip->hw->num_ins; i++) {\n\t\t\tint val = (i * 2) | (c << 8);\n\t\t\tif (c == 1) {\n\t\t\t\ttemp = vx_control_saturation;\n\t\t\t\ttemp.index = i;\n\t\t\t\ttemp.private_value = val;\n\t\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tsprintf(name, \"%s VU Meter\", dir[c]);\n\t\t\ttemp = vx_control_vu_meter;\n\t\t\ttemp.index = i;\n\t\t\ttemp.name = name;\n\t\t\ttemp.private_value = val;\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tsprintf(name, \"%s Peak Meter\", dir[c]);\n\t\t\ttemp = vx_control_peak_meter;\n\t\t\ttemp.index = i;\n\t\t\ttemp.name = name;\n\t\t\ttemp.private_value = val;\n\t\t\terr = snd_ctl_add(card, snd_ctl_new1(&temp, chip));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\tvx_reset_audio_levels(chip);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}