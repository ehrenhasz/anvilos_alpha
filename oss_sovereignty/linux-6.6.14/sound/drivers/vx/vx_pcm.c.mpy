{
  "module_name": "vx_pcm.c",
  "hash_id": "88ea46e4fbd883095100d7a26425f3992923288ef34800965a161805dde1b073",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/vx/vx_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <sound/core.h>\n#include <sound/asoundef.h>\n#include <sound/pcm.h>\n#include <sound/vx_core.h>\n#include \"vx_cmd.h\"\n\n\n \nstatic void vx_pcm_read_per_bytes(struct vx_core *chip, struct snd_pcm_runtime *runtime,\n\t\t\t\t  struct vx_pipe *pipe)\n{\n\tint offset = pipe->hw_ptr;\n\tunsigned char *buf = (unsigned char *)(runtime->dma_area + offset);\n\t*buf++ = vx_inb(chip, RXH);\n\tif (++offset >= pipe->buffer_bytes) {\n\t\toffset = 0;\n\t\tbuf = (unsigned char *)runtime->dma_area;\n\t}\n\t*buf++ = vx_inb(chip, RXM);\n\tif (++offset >= pipe->buffer_bytes) {\n\t\toffset = 0;\n\t\tbuf = (unsigned char *)runtime->dma_area;\n\t}\n\t*buf++ = vx_inb(chip, RXL);\n\tif (++offset >= pipe->buffer_bytes) {\n\t\toffset = 0;\n\t}\n\tpipe->hw_ptr = offset;\n}\n\n \nstatic void vx_set_pcx_time(struct vx_core *chip, pcx_time_t *pc_time,\n\t\t\t    unsigned int *dsp_time)\n{\n\tdsp_time[0] = (unsigned int)((*pc_time) >> 24) & PCX_TIME_HI_MASK;\n\tdsp_time[1] = (unsigned int)(*pc_time) &  MASK_DSP_WORD;\n}\n\n \nstatic int vx_set_differed_time(struct vx_core *chip, struct vx_rmh *rmh,\n\t\t\t\tstruct vx_pipe *pipe)\n{\n\t \n\tif (! (pipe->differed_type & DC_DIFFERED_DELAY))\n\t\treturn 0;\n\t\t\n\t \n\trmh->Cmd[0] |= DSP_DIFFERED_COMMAND_MASK;\n\n\t \n\tvx_set_pcx_time(chip, &pipe->pcx_time, &rmh->Cmd[1]);\n\n\t \n\tif (pipe->differed_type & DC_NOTIFY_DELAY)\n\t\trmh->Cmd[1] |= NOTIFY_MASK_TIME_HIGH ;\n\n\t \n\tif (pipe->differed_type & DC_MULTIPLE_DELAY)\n\t\trmh->Cmd[1] |= MULTIPLE_MASK_TIME_HIGH;\n\n\t \n\tif (pipe->differed_type & DC_STREAM_TIME_DELAY)\n\t\trmh->Cmd[1] |= STREAM_MASK_TIME_HIGH;\n\t\t\n\trmh->LgCmd += 2;\n\treturn 2;\n}\n\n \nstatic int vx_set_stream_format(struct vx_core *chip, struct vx_pipe *pipe,\n\t\t\t\tunsigned int data)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, pipe->is_capture ?\n\t\t    CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);\n\trmh.Cmd[0] |= pipe->number << FIELD_SIZE;\n\n         \n\tvx_set_differed_time(chip, &rmh, pipe);\n\n\trmh.Cmd[rmh.LgCmd] = (data & 0xFFFFFF00) >> 8;\n\trmh.Cmd[rmh.LgCmd + 1] = (data & 0xFF) << 16  ;\n\trmh.LgCmd += 2;\n    \n\treturn vx_send_msg(chip, &rmh);\n}\n\n\n \nstatic int vx_set_format(struct vx_core *chip, struct vx_pipe *pipe,\n\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tunsigned int header = HEADER_FMT_BASE;\n\n\tif (runtime->channels == 1)\n\t\theader |= HEADER_FMT_MONO;\n\tif (snd_pcm_format_little_endian(runtime->format))\n\t\theader |= HEADER_FMT_INTEL;\n\tif (runtime->rate < 32000 && runtime->rate > 11025)\n\t\theader |= HEADER_FMT_UPTO32;\n\telse if (runtime->rate <= 11025)\n\t\theader |= HEADER_FMT_UPTO11;\n\n\tswitch (snd_pcm_format_physical_width(runtime->format)) {\n\t \n\tcase 16: header |= HEADER_FMT_16BITS; break;\n\tcase 24: header |= HEADER_FMT_24BITS; break;\n\tdefault : \n\t\tsnd_BUG();\n\t\treturn -EINVAL;\n\t}\n\n\treturn vx_set_stream_format(chip, pipe, header);\n}\n\n \nstatic int vx_set_ibl(struct vx_core *chip, struct vx_ibl_info *info)\n{\n\tint err;\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_IBL);\n\trmh.Cmd[0] |= info->size & 0x03ffff;\n\terr = vx_send_msg(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->size = rmh.Stat[0];\n\tinfo->max_size = rmh.Stat[1];\n\tinfo->min_size = rmh.Stat[2];\n\tinfo->granularity = rmh.Stat[3];\n\tsnd_printdd(KERN_DEBUG \"vx_set_ibl: size = %d, max = %d, min = %d, gran = %d\\n\",\n\t\t   info->size, info->max_size, info->min_size, info->granularity);\n\treturn 0;\n}\n\n\n \nstatic int vx_get_pipe_state(struct vx_core *chip, struct vx_pipe *pipe, int *state)\n{\n\tint err;\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_PIPE_STATE);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\terr = vx_send_msg(chip, &rmh);\n\tif (! err)\n\t\t*state = (rmh.Stat[0] & (1 << pipe->number)) ? 1 : 0;\n\treturn err;\n}\n\n\n \nstatic int vx_query_hbuffer_size(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tint result;\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_SIZE_HBUFFER);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\tif (pipe->is_capture)\n\t\trmh.Cmd[0] |= 0x00000001;\n\tresult = vx_send_msg(chip, &rmh);\n\tif (! result)\n\t\tresult = rmh.Stat[0] & 0xffff;\n\treturn result;\n}\n\n\n \nstatic int vx_pipe_can_start(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tint err;\n\tstruct vx_rmh rmh;\n        \n\tvx_init_rmh(&rmh, CMD_CAN_START_PIPE);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\trmh.Cmd[0] |= 1;\n\n\terr = vx_send_msg(chip, &rmh);\n\tif (! err) {\n\t\tif (rmh.Stat[0])\n\t\t\terr = 1;\n\t}\n\treturn err;\n}\n\n \nstatic int vx_conf_pipe(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_CONF_PIPE);\n\tif (pipe->is_capture)\n\t\trmh.Cmd[0] |= COMMAND_RECORD_MASK;\n\trmh.Cmd[1] = 1 << pipe->number;\n\treturn vx_send_msg(chip, &rmh);\n}\n\n \nstatic int vx_send_irqa(struct vx_core *chip)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_SEND_IRQA);\n\treturn vx_send_msg(chip, &rmh);\n}\n\n\n#define MAX_WAIT_FOR_DSP        250\n \n#define CAN_START_DELAY         2\t \n#define WAIT_STATE_DELAY        2\t \n\n \nstatic int vx_toggle_pipe(struct vx_core *chip, struct vx_pipe *pipe, int state)\n{\n\tint err, i, cur_state;\n\n\t \n\tif (vx_get_pipe_state(chip, pipe, &cur_state) < 0)\n\t\treturn -EBADFD;\n\tif (state == cur_state)\n\t\treturn 0;\n\n\t \n\tif (state) {\n\t\tfor (i = 0 ; i < MAX_WAIT_FOR_DSP; i++) {\n\t\t\terr = vx_pipe_can_start(chip, pipe);\n\t\t\tif (err > 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tmdelay(1);\n\t\t}\n\t}\n    \n\terr = vx_conf_pipe(chip, pipe);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = vx_send_irqa(chip);\n\tif (err < 0)\n\t\treturn err;\n    \n\t \n\tfor (i = 0; i < MAX_WAIT_FOR_DSP; i++) {\n\t\terr = vx_get_pipe_state(chip, pipe, &cur_state);\n\t\tif (err < 0 || cur_state == state)\n\t\t\tbreak;\n\t\terr = -EIO;\n\t\tmdelay(1);\n\t}\n\treturn err < 0 ? -EIO : 0;\n}\n\n    \n \nstatic int vx_stop_pipe(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\tvx_init_rmh(&rmh, CMD_STOP_PIPE);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\treturn vx_send_msg(chip, &rmh);\n}\n\n\n \nstatic int vx_alloc_pipe(struct vx_core *chip, int capture,\n\t\t\t int audioid, int num_audio,\n\t\t\t struct vx_pipe **pipep)\n{\n\tint err;\n\tstruct vx_pipe *pipe;\n\tstruct vx_rmh rmh;\n\tint data_mode;\n\n\t*pipep = NULL;\n\tvx_init_rmh(&rmh, CMD_RES_PIPE);\n\tvx_set_pipe_cmd_params(&rmh, capture, audioid, num_audio);\n#if 0\t\n\tif (underrun_skip_sound)\n\t\trmh.Cmd[0] |= BIT_SKIP_SOUND;\n#endif\t\n\tdata_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;\n\tif (! capture && data_mode)\n\t\trmh.Cmd[0] |= BIT_DATA_MODE;\n\terr = vx_send_msg(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpipe = kzalloc(sizeof(*pipe), GFP_KERNEL);\n\tif (! pipe) {\n\t\t \n\t\tvx_init_rmh(&rmh, CMD_FREE_PIPE);\n\t\tvx_set_pipe_cmd_params(&rmh, capture, audioid, 0);\n\t\tvx_send_msg(chip, &rmh);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpipe->number = audioid;\n\tpipe->is_capture = capture;\n\tpipe->channels = num_audio;\n\tpipe->differed_type = 0;\n\tpipe->pcx_time = 0;\n\tpipe->data_mode = data_mode;\n\t*pipep = pipe;\n\n\treturn 0;\n}\n\n\n \nstatic int vx_free_pipe(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_FREE_PIPE);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\tvx_send_msg(chip, &rmh);\n\n\tkfree(pipe);\n\treturn 0;\n}\n\n\n \nstatic int vx_start_stream(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_START_ONE_STREAM);\n\tvx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);\n\tvx_set_differed_time(chip, &rmh, pipe);\n\treturn vx_send_msg(chip, &rmh);\n}\n\n\n \nstatic int vx_stop_stream(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\n\tvx_init_rmh(&rmh, CMD_STOP_STREAM);\n\tvx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);\n\treturn vx_send_msg(chip, &rmh);\n}\n\n\n \n\nstatic const struct snd_pcm_hardware vx_pcm_playback_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID  \n\t\t\t\t  ),\n\t.formats =\t\t( \n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t126,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tVX_MAX_PERIODS,\n\t.fifo_size =\t\t126,\n};\n\n\n \nstatic int vx_pcm_playback_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct vx_pipe *pipe = NULL;\n\tunsigned int audio;\n\tint err;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\taudio = subs->pcm->device * 2;\n\tif (snd_BUG_ON(audio >= chip->audio_outs))\n\t\treturn -EINVAL;\n\t\n\t \n\tpipe = chip->playback_pipes[audio];\n\tif (! pipe) {\n\t\t \n\t\terr = vx_alloc_pipe(chip, 0, audio, 2, &pipe);  \n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\t \n\tpipe->references++;\n\n\tpipe->substream = subs;\n\tchip->playback_pipes[audio] = pipe;\n\n\truntime->hw = vx_pcm_playback_hw;\n\truntime->hw.period_bytes_min = chip->ibl.size;\n\truntime->private_data = pipe;\n\n\t  \n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);\n\n\treturn 0;\n}\n\n \nstatic int vx_pcm_playback_close(struct snd_pcm_substream *subs)\n{\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct vx_pipe *pipe;\n\n\tif (! subs->runtime->private_data)\n\t\treturn -EINVAL;\n\n\tpipe = subs->runtime->private_data;\n\n\tif (--pipe->references == 0) {\n\t\tchip->playback_pipes[pipe->number] = NULL;\n\t\tvx_free_pipe(chip, pipe);\n\t}\n\n\treturn 0;\n\n}\n\n\n \nstatic int vx_notify_end_of_buffer(struct vx_core *chip, struct vx_pipe *pipe)\n{\n\tint err;\n\tstruct vx_rmh rmh;   \n\n\t \n\tvx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);\n\tvx_init_rmh(&rmh, CMD_NOTIFY_END_OF_BUFFER);\n\tvx_set_stream_cmd_params(&rmh, 0, pipe->number);\n\terr = vx_send_msg_nolock(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\t \n\tvx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);\n\treturn 0;\n}\n\n \nstatic int vx_pcm_playback_transfer_chunk(struct vx_core *chip,\n\t\t\t\t\t  struct snd_pcm_runtime *runtime,\n\t\t\t\t\t  struct vx_pipe *pipe, int size)\n{\n\tint space, err = 0;\n\n\tspace = vx_query_hbuffer_size(chip, pipe);\n\tif (space < 0) {\n\t\t \n\t\tvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\n\t\tsnd_printd(\"error hbuffer\\n\");\n\t\treturn space;\n\t}\n\tif (space < size) {\n\t\tvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\n\t\tsnd_printd(\"no enough hbuffer space %d\\n\", space);\n\t\treturn -EIO;  \n\t}\n\t\t\n\t \n\tmutex_lock(&chip->lock);\n\tvx_pseudo_dma_write(chip, runtime, pipe, size);\n\terr = vx_notify_end_of_buffer(chip, pipe);\n\t \n\tvx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);\n\tmutex_unlock(&chip->lock);\n\treturn err;\n}\n\n \nstatic int vx_update_pipe_position(struct vx_core *chip,\n\t\t\t\t   struct snd_pcm_runtime *runtime,\n\t\t\t\t   struct vx_pipe *pipe)\n{\n\tstruct vx_rmh rmh;\n\tint err, update;\n\tu64 count;\n\n\tvx_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);\n\tvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\n\terr = vx_send_msg(chip, &rmh);\n\tif (err < 0)\n\t\treturn err;\n\n\tcount = ((u64)(rmh.Stat[0] & 0xfffff) << 24) | (u64)rmh.Stat[1];\n\tupdate = (int)(count - pipe->cur_count);\n\tpipe->cur_count = count;\n\tpipe->position += update;\n\tif (pipe->position >= (int)runtime->buffer_size)\n\t\tpipe->position %= runtime->buffer_size;\n\tpipe->transferred += update;\n\treturn 0;\n}\n\n \nstatic void vx_pcm_playback_transfer(struct vx_core *chip,\n\t\t\t\t     struct snd_pcm_substream *subs,\n\t\t\t\t     struct vx_pipe *pipe, int nchunks)\n{\n\tint i, err;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\tif (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))\n\t\treturn;\n\tfor (i = 0; i < nchunks; i++) {\n\t\terr = vx_pcm_playback_transfer_chunk(chip, runtime, pipe,\n\t\t\t\t\t\t     chip->ibl.size);\n\t\tif (err < 0)\n\t\t\treturn;\n\t}\n}\n\n \nstatic void vx_pcm_playback_update(struct vx_core *chip,\n\t\t\t\t   struct snd_pcm_substream *subs,\n\t\t\t\t   struct vx_pipe *pipe)\n{\n\tint err;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\tif (pipe->running && ! (chip->chip_status & VX_STAT_IS_STALE)) {\n\t\terr = vx_update_pipe_position(chip, runtime, pipe);\n\t\tif (err < 0)\n\t\t\treturn;\n\t\tif (pipe->transferred >= (int)runtime->period_size) {\n\t\t\tpipe->transferred %= runtime->period_size;\n\t\t\tsnd_pcm_period_elapsed(subs);\n\t\t}\n\t}\n}\n\n \nstatic int vx_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\n{\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct vx_pipe *pipe = subs->runtime->private_data;\n\tint err;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\t\t\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (! pipe->is_capture)\n\t\t\tvx_pcm_playback_transfer(chip, subs, pipe, 2);\n\t\terr = vx_start_stream(chip, pipe);\n\t\tif (err < 0) {\n\t\t\tpr_debug(\"vx: cannot start stream\\n\");\n\t\t\treturn err;\n\t\t}\n\t\terr = vx_toggle_pipe(chip, pipe, 1);\n\t\tif (err < 0) {\n\t\t\tpr_debug(\"vx: cannot start pipe\\n\");\n\t\t\tvx_stop_stream(chip, pipe);\n\t\t\treturn err;\n\t\t}\n\t\tchip->pcm_running++;\n\t\tpipe->running = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tvx_toggle_pipe(chip, pipe, 0);\n\t\tvx_stop_pipe(chip, pipe);\n\t\tvx_stop_stream(chip, pipe);\n\t\tchip->pcm_running--;\n\t\tpipe->running = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\terr = vx_toggle_pipe(chip, pipe, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\terr = vx_toggle_pipe(chip, pipe, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct vx_pipe *pipe = runtime->private_data;\n\treturn pipe->position;\n}\n\n \nstatic int vx_pcm_prepare(struct snd_pcm_substream *subs)\n{\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct vx_pipe *pipe = runtime->private_data;\n\tint err, data_mode;\n\t \n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\tdata_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;\n\tif (data_mode != pipe->data_mode && ! pipe->is_capture) {\n\t\t \n\t\t \n\t\tstruct vx_rmh rmh;\n\t\tsnd_printdd(KERN_DEBUG \"reopen the pipe with data_mode = %d\\n\", data_mode);\n\t\tvx_init_rmh(&rmh, CMD_FREE_PIPE);\n\t\tvx_set_pipe_cmd_params(&rmh, 0, pipe->number, 0);\n\t\terr = vx_send_msg(chip, &rmh);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tvx_init_rmh(&rmh, CMD_RES_PIPE);\n\t\tvx_set_pipe_cmd_params(&rmh, 0, pipe->number, pipe->channels);\n\t\tif (data_mode)\n\t\t\trmh.Cmd[0] |= BIT_DATA_MODE;\n\t\terr = vx_send_msg(chip, &rmh);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpipe->data_mode = data_mode;\n\t}\n\n\tif (chip->pcm_running && chip->freq != runtime->rate) {\n\t\tsnd_printk(KERN_ERR \"vx: cannot set different clock %d \"\n\t\t\t   \"from the current %d\\n\", runtime->rate, chip->freq);\n\t\treturn -EINVAL;\n\t}\n\tvx_set_clock(chip, runtime->rate);\n\n\terr = vx_set_format(chip, pipe, runtime);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (vx_is_pcmcia(chip)) {\n\t\tpipe->align = 2;  \n\t} else {\n\t\tpipe->align = 4;  \n\t}\n\n\tpipe->buffer_bytes = frames_to_bytes(runtime, runtime->buffer_size);\n\tpipe->period_bytes = frames_to_bytes(runtime, runtime->period_size);\n\tpipe->hw_ptr = 0;\n\n\t \n\tvx_update_pipe_position(chip, runtime, pipe);\n\t \n\tpipe->transferred = 0;\n\tpipe->position = 0;\n\n\tpipe->prepared = 1;\n\n\treturn 0;\n}\n\n\n \nstatic const struct snd_pcm_ops vx_pcm_playback_ops = {\n\t.open =\t\tvx_pcm_playback_open,\n\t.close =\tvx_pcm_playback_close,\n\t.prepare =\tvx_pcm_prepare,\n\t.trigger =\tvx_pcm_trigger,\n\t.pointer =\tvx_pcm_playback_pointer,\n};\n\n\n \n\nstatic const struct snd_pcm_hardware vx_pcm_capture_hw = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID  \n\t\t\t\t  ),\n\t.formats =\t\t( \n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE),\n\t.rates =\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =\t\t5000,\n\t.rate_max =\t\t48000,\n\t.channels_min =\t\t1,\n\t.channels_max =\t\t2,\n\t.buffer_bytes_max =\t(128*1024),\n\t.period_bytes_min =\t126,\n\t.period_bytes_max =\t(128*1024),\n\t.periods_min =\t\t2,\n\t.periods_max =\t\tVX_MAX_PERIODS,\n\t.fifo_size =\t\t126,\n};\n\n\n \nstatic int vx_pcm_capture_open(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct vx_pipe *pipe;\n\tstruct vx_pipe *pipe_out_monitoring = NULL;\n\tunsigned int audio;\n\tint err;\n\n\tif (chip->chip_status & VX_STAT_IS_STALE)\n\t\treturn -EBUSY;\n\n\taudio = subs->pcm->device * 2;\n\tif (snd_BUG_ON(audio >= chip->audio_ins))\n\t\treturn -EINVAL;\n\terr = vx_alloc_pipe(chip, 1, audio, 2, &pipe);\n\tif (err < 0)\n\t\treturn err;\n\tpipe->substream = subs;\n\tchip->capture_pipes[audio] = pipe;\n\n\t \n\tif (chip->audio_monitor_active[audio]) {\n\t\tpipe_out_monitoring = chip->playback_pipes[audio];\n\t\tif (! pipe_out_monitoring) {\n\t\t\t \n\t\t\terr = vx_alloc_pipe(chip, 0, audio, 2, &pipe_out_monitoring);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tchip->playback_pipes[audio] = pipe_out_monitoring;\n\t\t}\n\t\tpipe_out_monitoring->references++;\n\t\t \n\t\tvx_set_monitor_level(chip, audio, chip->audio_monitor[audio],\n\t\t\t\t     chip->audio_monitor_active[audio]);\n\t\t \n\t\tvx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],\n\t\t\t\t     chip->audio_monitor_active[audio+1]); \n\t}\n\n\tpipe->monitoring_pipe = pipe_out_monitoring;  \n\n\truntime->hw = vx_pcm_capture_hw;\n\truntime->hw.period_bytes_min = chip->ibl.size;\n\truntime->private_data = pipe;\n\n\t  \n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);\n\tsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);\n\n\treturn 0;\n}\n\n \nstatic int vx_pcm_capture_close(struct snd_pcm_substream *subs)\n{\n\tstruct vx_core *chip = snd_pcm_substream_chip(subs);\n\tstruct vx_pipe *pipe;\n\tstruct vx_pipe *pipe_out_monitoring;\n\t\n\tif (! subs->runtime->private_data)\n\t\treturn -EINVAL;\n\tpipe = subs->runtime->private_data;\n\tchip->capture_pipes[pipe->number] = NULL;\n\n\tpipe_out_monitoring = pipe->monitoring_pipe;\n\n\t \n\tif (pipe_out_monitoring) {\n\t\tif (--pipe_out_monitoring->references == 0) {\n\t\t\tvx_free_pipe(chip, pipe_out_monitoring);\n\t\t\tchip->playback_pipes[pipe->number] = NULL;\n\t\t\tpipe->monitoring_pipe = NULL;\n\t\t}\n\t}\n\t\n\tvx_free_pipe(chip, pipe);\n\treturn 0;\n}\n\n\n\n#define DMA_READ_ALIGN\t6\t \n\n \nstatic void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream *subs,\n\t\t\t\t  struct vx_pipe *pipe)\n{\n\tint size, space, count;\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\n\tif (!pipe->running || (chip->chip_status & VX_STAT_IS_STALE))\n\t\treturn;\n\n\tsize = runtime->buffer_size - snd_pcm_capture_avail(runtime);\n\tif (! size)\n\t\treturn;\n\tsize = frames_to_bytes(runtime, size);\n\tspace = vx_query_hbuffer_size(chip, pipe);\n\tif (space < 0)\n\t\tgoto _error;\n\tif (size > space)\n\t\tsize = space;\n\tsize = (size / 3) * 3;  \n\tif (size < DMA_READ_ALIGN)\n\t\tgoto _error;\n\n\t \n\tcount = size - DMA_READ_ALIGN;\n\t \n\twhile (count > 0) {\n\t\tif ((pipe->hw_ptr % pipe->align) == 0)\n\t\t\tbreak;\n\t\tif (vx_wait_for_rx_full(chip) < 0)\n\t\t\tgoto _error;\n\t\tvx_pcm_read_per_bytes(chip, runtime, pipe);\n\t\tcount -= 3;\n\t}\n\tif (count > 0) {\n\t\t \n\t\tint align = pipe->align * 3;\n\t\tspace = (count / align) * align;\n\t\tif (space > 0) {\n\t\t\tvx_pseudo_dma_read(chip, runtime, pipe, space);\n\t\t\tcount -= space;\n\t\t}\n\t}\n\t \n\twhile (count > 0) {\n\t\tif (vx_wait_for_rx_full(chip) < 0)\n\t\t\tgoto _error;\n\t\tvx_pcm_read_per_bytes(chip, runtime, pipe);\n\t\tcount -= 3;\n\t}\n\t \n\tvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\n\t \n\tcount = DMA_READ_ALIGN;\n\twhile (count > 0) {\n\t\tvx_pcm_read_per_bytes(chip, runtime, pipe);\n\t\tcount -= 3;\n\t}\n\t \n\tpipe->transferred += size;\n\tif (pipe->transferred >= pipe->period_bytes) {\n\t\tpipe->transferred %= pipe->period_bytes;\n\t\tsnd_pcm_period_elapsed(subs);\n\t}\n\treturn;\n\n _error:\n\t \n\tvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\n\treturn;\n}\n\n \nstatic snd_pcm_uframes_t vx_pcm_capture_pointer(struct snd_pcm_substream *subs)\n{\n\tstruct snd_pcm_runtime *runtime = subs->runtime;\n\tstruct vx_pipe *pipe = runtime->private_data;\n\treturn bytes_to_frames(runtime, pipe->hw_ptr);\n}\n\n \nstatic const struct snd_pcm_ops vx_pcm_capture_ops = {\n\t.open =\t\tvx_pcm_capture_open,\n\t.close =\tvx_pcm_capture_close,\n\t.prepare =\tvx_pcm_prepare,\n\t.trigger =\tvx_pcm_trigger,\n\t.pointer =\tvx_pcm_capture_pointer,\n};\n\n\n \nvoid vx_pcm_update_intr(struct vx_core *chip, unsigned int events)\n{\n\tunsigned int i;\n\tstruct vx_pipe *pipe;\n\n#define EVENT_MASK\t(END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)\n\n\tif (events & EVENT_MASK) {\n\t\tvx_init_rmh(&chip->irq_rmh, CMD_ASYNC);\n\t\tif (events & ASYNC_EVENTS_PENDING)\n\t\t\tchip->irq_rmh.Cmd[0] |= 0x00000001;\t \n\t\tif (events & END_OF_BUFFER_EVENTS_PENDING)\n\t\t\tchip->irq_rmh.Cmd[0] |= 0x00000002;\t \n\n\t\tif (vx_send_msg(chip, &chip->irq_rmh) < 0) {\n\t\t\tsnd_printdd(KERN_ERR \"msg send error!!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ti = 1;\n\t\twhile (i < chip->irq_rmh.LgStat) {\n\t\t\tint p, buf, capture, eob;\n\t\t\tp = chip->irq_rmh.Stat[i] & MASK_FIRST_FIELD;\n\t\t\tcapture = (chip->irq_rmh.Stat[i] & 0x400000) ? 1 : 0;\n\t\t\teob = (chip->irq_rmh.Stat[i] & 0x800000) ? 1 : 0;\n\t\t\ti++;\n\t\t\tif (events & ASYNC_EVENTS_PENDING)\n\t\t\t\ti++;\n\t\t\tbuf = 1;  \n\t\t\tif (events & END_OF_BUFFER_EVENTS_PENDING) {\n\t\t\t\tif (eob)\n\t\t\t\t\tbuf = chip->irq_rmh.Stat[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (capture)\n\t\t\t\tcontinue;\n\t\t\tif (snd_BUG_ON(p < 0 || p >= chip->audio_outs))\n\t\t\t\tcontinue;\n\t\t\tpipe = chip->playback_pipes[p];\n\t\t\tif (pipe && pipe->substream) {\n\t\t\t\tvx_pcm_playback_update(chip, pipe->substream, pipe);\n\t\t\t\tvx_pcm_playback_transfer(chip, pipe->substream, pipe, buf);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < chip->audio_ins; i++) {\n\t\tpipe = chip->capture_pipes[i];\n\t\tif (pipe && pipe->substream)\n\t\t\tvx_pcm_capture_update(chip, pipe->substream, pipe);\n\t}\n}\n\n\n \nstatic int vx_init_audio_io(struct vx_core *chip)\n{\n\tstruct vx_rmh rmh;\n\tint preferred;\n\n\tvx_init_rmh(&rmh, CMD_SUPPORTED);\n\tif (vx_send_msg(chip, &rmh) < 0) {\n\t\tsnd_printk(KERN_ERR \"vx: cannot get the supported audio data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->audio_outs = rmh.Stat[0] & MASK_FIRST_FIELD;\n\tchip->audio_ins = (rmh.Stat[0] >> (FIELD_SIZE*2)) & MASK_FIRST_FIELD;\n\tchip->audio_info = rmh.Stat[1];\n\n\t \n\tchip->playback_pipes = kcalloc(chip->audio_outs, sizeof(struct vx_pipe *), GFP_KERNEL);\n\tif (!chip->playback_pipes)\n\t\treturn -ENOMEM;\n\tchip->capture_pipes = kcalloc(chip->audio_ins, sizeof(struct vx_pipe *), GFP_KERNEL);\n\tif (!chip->capture_pipes) {\n\t\tkfree(chip->playback_pipes);\n\t\treturn -ENOMEM;\n\t}\n\n\tpreferred = chip->ibl.size;\n\tchip->ibl.size = 0;\n\tvx_set_ibl(chip, &chip->ibl);  \n\tif (preferred > 0) {\n\t\tchip->ibl.size = roundup(preferred, chip->ibl.granularity);\n\t\tif (chip->ibl.size > chip->ibl.max_size)\n\t\t\tchip->ibl.size = chip->ibl.max_size;\n\t} else\n\t\tchip->ibl.size = chip->ibl.min_size;  \n\tvx_set_ibl(chip, &chip->ibl);\n\n\treturn 0;\n}\n\n\n \nstatic void snd_vx_pcm_free(struct snd_pcm *pcm)\n{\n\tstruct vx_core *chip = pcm->private_data;\n\tchip->pcm[pcm->device] = NULL;\n\tkfree(chip->playback_pipes);\n\tchip->playback_pipes = NULL;\n\tkfree(chip->capture_pipes);\n\tchip->capture_pipes = NULL;\n}\n\n \nint snd_vx_pcm_new(struct vx_core *chip)\n{\n\tstruct snd_pcm *pcm;\n\tunsigned int i;\n\tint err;\n\n\terr = vx_init_audio_io(chip);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < chip->hw->num_codecs; i++) {\n\t\tunsigned int outs, ins;\n\t\touts = chip->audio_outs > i * 2 ? 1 : 0;\n\t\tins = chip->audio_ins > i * 2 ? 1 : 0;\n\t\tif (! outs && ! ins)\n\t\t\tbreak;\n\t\terr = snd_pcm_new(chip->card, \"VX PCM\", i,\n\t\t\t\t  outs, ins, &pcm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (outs)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &vx_pcm_playback_ops);\n\t\tif (ins)\n\t\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vx_pcm_capture_ops);\n\t\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t\t       NULL, 0, 0);\n\n\t\tpcm->private_data = chip;\n\t\tpcm->private_free = snd_vx_pcm_free;\n\t\tpcm->info_flags = 0;\n\t\tpcm->nonatomic = true;\n\t\tstrcpy(pcm->name, chip->card->shortname);\n\t\tchip->pcm[i] = pcm;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}