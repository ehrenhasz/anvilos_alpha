{
  "module_name": "mpu401.c",
  "hash_id": "b7b227145b2631c7b9ca141b6ce8d40de5300b7b5b9c5f53714ebab4fcbef127",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/mpu401/mpu401.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pnp.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/mpu401.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"MPU-401 UART\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -2};  \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;\t \n#ifdef CONFIG_PNP\nstatic bool pnp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n#endif\nstatic long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;\t \nstatic int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;\t \nstatic bool uart_enter[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for MPU-401 device.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for MPU-401 device.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable MPU-401 device.\");\n#ifdef CONFIG_PNP\nmodule_param_array(pnp, bool, NULL, 0444);\nMODULE_PARM_DESC(pnp, \"PnP detection for MPU-401 device.\");\n#endif\nmodule_param_hw_array(port, long, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"Port # for MPU-401 device.\");\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ # for MPU-401 device.\");\nmodule_param_array(uart_enter, bool, NULL, 0444);\nMODULE_PARM_DESC(uart_enter, \"Issue UART_ENTER command at open.\");\n\nstatic struct platform_device *platform_devices[SNDRV_CARDS];\nstatic int pnp_registered;\nstatic unsigned int snd_mpu401_devices;\n\nstatic int snd_mpu401_create(struct device *devptr, int dev,\n\t\t\t     struct snd_card **rcard)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (!uart_enter[dev])\n\t\tsnd_printk(KERN_ERR \"the uart_enter option is obsolete; remove it\\n\");\n\n\t*rcard = NULL;\n\terr = snd_devm_card_new(devptr, index[dev], id[dev], THIS_MODULE,\n\t\t\t\t0, &card);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(card->driver, \"MPU-401 UART\");\n\tstrcpy(card->shortname, card->driver);\n\tsprintf(card->longname, \"%s at %#lx, \", card->shortname, port[dev]);\n\tif (irq[dev] >= 0) {\n\t\tsprintf(card->longname + strlen(card->longname), \"irq %d\", irq[dev]);\n\t} else {\n\t\tstrcat(card->longname, \"polled\");\n\t}\n\n\terr = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port[dev], 0,\n\t\t\t\t  irq[dev], NULL);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"MPU401 not detected at 0x%lx\\n\", port[dev]);\n\t\treturn err;\n\t}\n\n\t*rcard = card;\n\treturn 0;\n}\n\nstatic int snd_mpu401_probe(struct platform_device *devptr)\n{\n\tint dev = devptr->id;\n\tint err;\n\tstruct snd_card *card;\n\n\tif (port[dev] == SNDRV_AUTO_PORT) {\n\t\tsnd_printk(KERN_ERR \"specify port\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (irq[dev] == SNDRV_AUTO_IRQ) {\n\t\tsnd_printk(KERN_ERR \"specify or disable IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = snd_mpu401_create(&devptr->dev, dev, &card);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#define SND_MPU401_DRIVER\t\"snd_mpu401\"\n\nstatic struct platform_driver snd_mpu401_driver = {\n\t.probe\t\t= snd_mpu401_probe,\n\t.driver\t\t= {\n\t\t.name\t= SND_MPU401_DRIVER,\n\t},\n};\n\n\n#ifdef CONFIG_PNP\n\n#define IO_EXTENT 2\n\nstatic const struct pnp_device_id snd_mpu401_pnpids[] = {\n\t{ .id = \"PNPb006\" },\n\t{ .id = \"\" }\n};\n\nMODULE_DEVICE_TABLE(pnp, snd_mpu401_pnpids);\n\nstatic int snd_mpu401_pnp(int dev, struct pnp_dev *device,\n\t\t\t  const struct pnp_device_id *id)\n{\n\tif (!pnp_port_valid(device, 0) ||\n\t    pnp_port_flags(device, 0) & IORESOURCE_DISABLED) {\n\t\tsnd_printk(KERN_ERR \"no PnP port\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (pnp_port_len(device, 0) < IO_EXTENT) {\n\t\tsnd_printk(KERN_ERR \"PnP port length is %llu, expected %d\\n\",\n\t\t\t   (unsigned long long)pnp_port_len(device, 0),\n\t\t\t   IO_EXTENT);\n\t\treturn -ENODEV;\n\t}\n\tport[dev] = pnp_port_start(device, 0);\n\n\tif (!pnp_irq_valid(device, 0) ||\n\t    pnp_irq_flags(device, 0) & IORESOURCE_DISABLED) {\n\t\tsnd_printk(KERN_WARNING \"no PnP irq, using polling\\n\");\n\t\tirq[dev] = -1;\n\t} else {\n\t\tirq[dev] = pnp_irq(device, 0);\n\t}\n\treturn 0;\n}\n\nstatic int snd_mpu401_pnp_probe(struct pnp_dev *pnp_dev,\n\t\t\t\tconst struct pnp_device_id *id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tint err;\n\n\tfor ( ; dev < SNDRV_CARDS; ++dev) {\n\t\tif (!enable[dev] || !pnp[dev])\n\t\t\tcontinue;\n\t\terr = snd_mpu401_pnp(dev, pnp_dev, id);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_mpu401_create(&pnp_dev->dev, dev, &card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = snd_card_register(card);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpnp_set_drvdata(pnp_dev, card);\n\t\tsnd_mpu401_devices++;\n\t\t++dev;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic struct pnp_driver snd_mpu401_pnp_driver = {\n\t.name = \"mpu401\",\n\t.id_table = snd_mpu401_pnpids,\n\t.probe = snd_mpu401_pnp_probe,\n};\n#else\nstatic struct pnp_driver snd_mpu401_pnp_driver;\n#endif\n\nstatic void snd_mpu401_unregister_all(void)\n{\n\tint i;\n\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&snd_mpu401_pnp_driver);\n\tfor (i = 0; i < ARRAY_SIZE(platform_devices); ++i)\n\t\tplatform_device_unregister(platform_devices[i]);\n\tplatform_driver_unregister(&snd_mpu401_driver);\n}\n\nstatic int __init alsa_card_mpu401_init(void)\n{\n\tint i, err;\n\n\terr = platform_driver_register(&snd_mpu401_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tstruct platform_device *device;\n\t\tif (! enable[i])\n\t\t\tcontinue;\n#ifdef CONFIG_PNP\n\t\tif (pnp[i])\n\t\t\tcontinue;\n#endif\n\t\tdevice = platform_device_register_simple(SND_MPU401_DRIVER,\n\t\t\t\t\t\t\t i, NULL, 0);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (!platform_get_drvdata(device)) {\n\t\t\tplatform_device_unregister(device);\n\t\t\tcontinue;\n\t\t}\n\t\tplatform_devices[i] = device;\n\t\tsnd_mpu401_devices++;\n\t}\n\terr = pnp_register_driver(&snd_mpu401_pnp_driver);\n\tif (!err)\n\t\tpnp_registered = 1;\n\n\tif (!snd_mpu401_devices) {\n#ifdef MODULE\n\t\tprintk(KERN_ERR \"MPU-401 device not found or device busy\\n\");\n#endif\n\t\tsnd_mpu401_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_mpu401_exit(void)\n{\n\tsnd_mpu401_unregister_all();\n}\n\nmodule_init(alsa_card_mpu401_init)\nmodule_exit(alsa_card_mpu401_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}