{
  "module_name": "mpu401_uart.c",
  "hash_id": "f1bc44fc77a1a8f613096db17ccbbe4d11a4bd5a43a3331ca53bcc89e2301f91",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/mpu401/mpu401_uart.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <sound/core.h>\n#include <sound/mpu401.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Routines for control of MPU-401 in UART mode\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu);\nstatic void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu);\n\n \n\n#define snd_mpu401_input_avail(mpu) \\\n\t(!(mpu->read(mpu, MPU401C(mpu)) & MPU401_RX_EMPTY))\n#define snd_mpu401_output_ready(mpu) \\\n\t(!(mpu->read(mpu, MPU401C(mpu)) & MPU401_TX_FULL))\n\n \nstatic void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data,\n\t\t\t      unsigned long addr)\n{\n\toutb(data, addr);\n}\n\nstatic unsigned char mpu401_read_port(struct snd_mpu401 *mpu,\n\t\t\t\t      unsigned long addr)\n{\n\treturn inb(addr);\n}\n\nstatic void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data,\n\t\t\t      unsigned long addr)\n{\n\twriteb(data, (void __iomem *)addr);\n}\n\nstatic unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu,\n\t\t\t\t      unsigned long addr)\n{\n\treturn readb((void __iomem *)addr);\n}\n \n\nstatic void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)\n{\n\tint timeout = 100000;\n\tfor (; timeout > 0 && snd_mpu401_input_avail(mpu); timeout--)\n\t\tmpu->read(mpu, MPU401D(mpu));\n#ifdef CONFIG_SND_DEBUG\n\tif (timeout <= 0)\n\t\tsnd_printk(KERN_ERR \"cmd: clear rx timeout (status = 0x%x)\\n\",\n\t\t\t   mpu->read(mpu, MPU401C(mpu)));\n#endif\n}\n\nstatic void uart_interrupt_tx(struct snd_mpu401 *mpu)\n{\n\tunsigned long flags;\n\n\tif (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&\n\t    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {\n\t\tspin_lock_irqsave(&mpu->output_lock, flags);\n\t\tsnd_mpu401_uart_output_write(mpu);\n\t\tspin_unlock_irqrestore(&mpu->output_lock, flags);\n\t}\n}\n\nstatic void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)\n{\n\tunsigned long flags;\n\n\tif (mpu->info_flags & MPU401_INFO_INPUT) {\n\t\tspin_lock_irqsave(&mpu->input_lock, flags);\n\t\tif (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))\n\t\t\tsnd_mpu401_uart_input_read(mpu);\n\t\telse\n\t\t\tsnd_mpu401_uart_clear_rx(mpu);\n\t\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n\t}\n\tif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\n\t\t \n\t\tuart_interrupt_tx(mpu);\n}\n\n \nirqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_mpu401 *mpu = dev_id;\n\t\n\tif (!mpu)\n\t\treturn IRQ_NONE;\n\t_snd_mpu401_uart_interrupt(mpu);\n\treturn IRQ_HANDLED;\n}\n\nEXPORT_SYMBOL(snd_mpu401_uart_interrupt);\n\n \nirqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id)\n{\n\tstruct snd_mpu401 *mpu = dev_id;\n\t\n\tif (!mpu)\n\t\treturn IRQ_NONE;\n\tuart_interrupt_tx(mpu);\n\treturn IRQ_HANDLED;\n}\n\nEXPORT_SYMBOL(snd_mpu401_uart_interrupt_tx);\n\n \nstatic void snd_mpu401_uart_timer(struct timer_list *t)\n{\n\tstruct snd_mpu401 *mpu = from_timer(mpu, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mpu->timer_lock, flags);\n\t \n\tmod_timer(&mpu->timer,  1 + jiffies);\n\tspin_unlock_irqrestore(&mpu->timer_lock, flags);\n\tif (mpu->rmidi)\n\t\t_snd_mpu401_uart_interrupt(mpu);\n}\n\n \nstatic void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&mpu->timer_lock, flags);\n\tif (mpu->timer_invoked == 0) {\n\t\ttimer_setup(&mpu->timer, snd_mpu401_uart_timer, 0);\n\t\tmod_timer(&mpu->timer, 1 + jiffies);\n\t} \n\tmpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER :\n\t\tMPU401_MODE_OUTPUT_TIMER;\n\tspin_unlock_irqrestore (&mpu->timer_lock, flags);\n}\n\n \nstatic void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&mpu->timer_lock, flags);\n\tif (mpu->timer_invoked) {\n\t\tmpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER :\n\t\t\t~MPU401_MODE_OUTPUT_TIMER;\n\t\tif (! mpu->timer_invoked)\n\t\t\tdel_timer(&mpu->timer);\n\t}\n\tspin_unlock_irqrestore (&mpu->timer_lock, flags);\n}\n\n \n\nstatic int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,\n\t\t\t       int ack)\n{\n\tunsigned long flags;\n\tint timeout, ok;\n\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\tif (mpu->hardware != MPU401_HW_TRID4DWAVE) {\n\t\tmpu->write(mpu, 0x00, MPU401D(mpu));\n\t\t \n\t}\n\t \n\tif (mpu->hardware != MPU401_HW_SB) {\n\t\tfor (timeout = 1000; timeout > 0 &&\n\t\t\t     !snd_mpu401_output_ready(mpu); timeout--)\n\t\t\tudelay(10);\n#ifdef CONFIG_SND_DEBUG\n\t\tif (!timeout)\n\t\t\tsnd_printk(KERN_ERR \"cmd: tx timeout (status = 0x%x)\\n\",\n\t\t\t\t   mpu->read(mpu, MPU401C(mpu)));\n#endif\n\t}\n\tmpu->write(mpu, cmd, MPU401C(mpu));\n\tif (ack && !(mpu->info_flags & MPU401_INFO_NO_ACK)) {\n\t\tok = 0;\n\t\ttimeout = 10000;\n\t\twhile (!ok && timeout-- > 0) {\n\t\t\tif (snd_mpu401_input_avail(mpu)) {\n\t\t\t\tif (mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t\tif (!ok && mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)\n\t\t\tok = 1;\n\t} else\n\t\tok = 1;\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n\tif (!ok) {\n\t\tsnd_printk(KERN_ERR \"cmd: 0x%x failed at 0x%lx \"\n\t\t\t   \"(status = 0x%x, data = 0x%x)\\n\", cmd, mpu->port,\n\t\t\t   mpu->read(mpu, MPU401C(mpu)),\n\t\t\t   mpu->read(mpu, MPU401D(mpu)));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int snd_mpu401_do_reset(struct snd_mpu401 *mpu)\n{\n\tif (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))\n\t\treturn -EIO;\n\tif (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 0))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int snd_mpu401_uart_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_mpu401 *mpu;\n\tint err;\n\n\tmpu = substream->rmidi->private_data;\n\tif (mpu->open_input) {\n\t\terr = mpu->open_input(mpu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {\n\t\tif (snd_mpu401_do_reset(mpu) < 0)\n\t\t\tgoto error_out;\n\t}\n\tmpu->substream_input = substream;\n\tset_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);\n\treturn 0;\n\nerror_out:\n\tif (mpu->open_input && mpu->close_input)\n\t\tmpu->close_input(mpu);\n\treturn -EIO;\n}\n\nstatic int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_mpu401 *mpu;\n\tint err;\n\n\tmpu = substream->rmidi->private_data;\n\tif (mpu->open_output) {\n\t\terr = mpu->open_output(mpu);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {\n\t\tif (snd_mpu401_do_reset(mpu) < 0)\n\t\t\tgoto error_out;\n\t}\n\tmpu->substream_output = substream;\n\tset_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);\n\treturn 0;\n\nerror_out:\n\tif (mpu->open_output && mpu->close_output)\n\t\tmpu->close_output(mpu);\n\treturn -EIO;\n}\n\nstatic int snd_mpu401_uart_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_mpu401 *mpu;\n\tint err = 0;\n\n\tmpu = substream->rmidi->private_data;\n\tclear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);\n\tmpu->substream_input = NULL;\n\tif (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))\n\t\terr = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);\n\tif (mpu->close_input)\n\t\tmpu->close_input(mpu);\n\tif (err)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int snd_mpu401_uart_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct snd_mpu401 *mpu;\n\tint err = 0;\n\n\tmpu = substream->rmidi->private_data;\n\tclear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);\n\tmpu->substream_output = NULL;\n\tif (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))\n\t\terr = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);\n\tif (mpu->close_output)\n\t\tmpu->close_output(mpu);\n\tif (err)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic void\nsnd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_mpu401 *mpu;\n\tint max = 64;\n\n\tmpu = substream->rmidi->private_data;\n\tif (up) {\n\t\tif (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t       &mpu->mode)) {\n\t\t\t \n\t\t\twhile (max-- > 0)\n\t\t\t\tmpu->read(mpu, MPU401D(mpu));\n\t\t\tif (mpu->info_flags & MPU401_INFO_USE_TIMER)\n\t\t\t\tsnd_mpu401_uart_add_timer(mpu, 1);\n\t\t}\n\t\t\n\t\t \n\t\tspin_lock_irqsave(&mpu->input_lock, flags);\n\t\tsnd_mpu401_uart_input_read(mpu);\n\t\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n\t} else {\n\t\tif (mpu->info_flags & MPU401_INFO_USE_TIMER)\n\t\t\tsnd_mpu401_uart_remove_timer(mpu, 1);\n\t\tclear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);\n\t}\n\n}\n\n \nstatic void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu)\n{\n\tint max = 128;\n\tunsigned char byte;\n\n\twhile (max-- > 0) {\n\t\tif (! snd_mpu401_input_avail(mpu))\n\t\t\tbreak;  \n\t\tbyte = mpu->read(mpu, MPU401D(mpu));\n\t\tif (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode))\n\t\t\tsnd_rawmidi_receive(mpu->substream_input, &byte, 1);\n\t}\n}\n\n \n\n \nstatic void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)\n{\n\tunsigned char byte;\n\tint max = 256;\n\n\tdo {\n\t\tif (snd_rawmidi_transmit_peek(mpu->substream_output,\n\t\t\t\t\t      &byte, 1) == 1) {\n\t\t\t \n\t\t\tif (!snd_mpu401_output_ready(mpu) &&\n\t\t\t    !snd_mpu401_output_ready(mpu))\n\t\t\t\tbreak;\t \n\t\t\tmpu->write(mpu, byte, MPU401D(mpu));\n\t\t\tsnd_rawmidi_transmit_ack(mpu->substream_output, 1);\n\t\t} else {\n\t\t\tsnd_mpu401_uart_remove_timer (mpu, 0);\n\t\t\tbreak;\t \n\t\t}\n\t} while (--max > 0);\n}\n\n \nstatic void\nsnd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tunsigned long flags;\n\tstruct snd_mpu401 *mpu;\n\n\tmpu = substream->rmidi->private_data;\n\tif (up) {\n\t\tset_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);\n\n\t\t \n\t\tif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\n\t\t\tsnd_mpu401_uart_add_timer(mpu, 0);\n\n\t\t \n\t\tspin_lock_irqsave(&mpu->output_lock, flags);\n\t\tsnd_mpu401_uart_output_write(mpu);\n\t\tspin_unlock_irqrestore(&mpu->output_lock, flags);\n\t} else {\n\t\tif (! (mpu->info_flags & MPU401_INFO_TX_IRQ))\n\t\t\tsnd_mpu401_uart_remove_timer(mpu, 0);\n\t\tclear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);\n\t}\n}\n\n \n\nstatic const struct snd_rawmidi_ops snd_mpu401_uart_output =\n{\n\t.open =\t\tsnd_mpu401_uart_output_open,\n\t.close =\tsnd_mpu401_uart_output_close,\n\t.trigger =\tsnd_mpu401_uart_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_mpu401_uart_input =\n{\n\t.open =\t\tsnd_mpu401_uart_input_open,\n\t.close =\tsnd_mpu401_uart_input_close,\n\t.trigger =\tsnd_mpu401_uart_input_trigger,\n};\n\nstatic void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_mpu401 *mpu = rmidi->private_data;\n\tif (mpu->irq >= 0)\n\t\tfree_irq(mpu->irq, (void *) mpu);\n\trelease_and_free_resource(mpu->res);\n\tkfree(mpu);\n}\n\n \nint snd_mpu401_uart_new(struct snd_card *card, int device,\n\t\t\tunsigned short hardware,\n\t\t\tunsigned long port,\n\t\t\tunsigned int info_flags,\n\t\t\tint irq,\n\t\t\tstruct snd_rawmidi ** rrawmidi)\n{\n\tstruct snd_mpu401 *mpu;\n\tstruct snd_rawmidi *rmidi;\n\tint in_enable, out_enable;\n\tint err;\n\n\tif (rrawmidi)\n\t\t*rrawmidi = NULL;\n\tif (! (info_flags & (MPU401_INFO_INPUT | MPU401_INFO_OUTPUT)))\n\t\tinfo_flags |= MPU401_INFO_INPUT | MPU401_INFO_OUTPUT;\n\tin_enable = (info_flags & MPU401_INFO_INPUT) ? 1 : 0;\n\tout_enable = (info_flags & MPU401_INFO_OUTPUT) ? 1 : 0;\n\terr = snd_rawmidi_new(card, \"MPU-401U\", device,\n\t\t\t      out_enable, in_enable, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tmpu = kzalloc(sizeof(*mpu), GFP_KERNEL);\n\tif (!mpu) {\n\t\terr = -ENOMEM;\n\t\tgoto free_device;\n\t}\n\trmidi->private_data = mpu;\n\trmidi->private_free = snd_mpu401_uart_free;\n\tspin_lock_init(&mpu->input_lock);\n\tspin_lock_init(&mpu->output_lock);\n\tspin_lock_init(&mpu->timer_lock);\n\tmpu->hardware = hardware;\n\tmpu->irq = -1;\n\tif (! (info_flags & MPU401_INFO_INTEGRATED)) {\n\t\tint res_size = hardware == MPU401_HW_PC98II ? 4 : 2;\n\t\tmpu->res = request_region(port, res_size, \"MPU401 UART\");\n\t\tif (!mpu->res) {\n\t\t\tsnd_printk(KERN_ERR \"mpu401_uart: \"\n\t\t\t\t   \"unable to grab port 0x%lx size %d\\n\",\n\t\t\t\t   port, res_size);\n\t\t\terr = -EBUSY;\n\t\t\tgoto free_device;\n\t\t}\n\t}\n\tif (info_flags & MPU401_INFO_MMIO) {\n\t\tmpu->write = mpu401_write_mmio;\n\t\tmpu->read = mpu401_read_mmio;\n\t} else {\n\t\tmpu->write = mpu401_write_port;\n\t\tmpu->read = mpu401_read_port;\n\t}\n\tmpu->port = port;\n\tif (hardware == MPU401_HW_PC98II)\n\t\tmpu->cport = port + 2;\n\telse\n\t\tmpu->cport = port + 1;\n\tif (irq >= 0) {\n\t\tif (request_irq(irq, snd_mpu401_uart_interrupt, 0,\n\t\t\t\t\"MPU401 UART\", (void *) mpu)) {\n\t\t\tsnd_printk(KERN_ERR \"mpu401_uart: \"\n\t\t\t\t   \"unable to grab IRQ %d\\n\", irq);\n\t\t\terr = -EBUSY;\n\t\t\tgoto free_device;\n\t\t}\n\t}\n\tif (irq < 0 && !(info_flags & MPU401_INFO_IRQ_HOOK))\n\t\tinfo_flags |= MPU401_INFO_USE_TIMER;\n\tmpu->info_flags = info_flags;\n\tmpu->irq = irq;\n\tif (card->shortname[0])\n\t\tsnprintf(rmidi->name, sizeof(rmidi->name), \"%s MIDI\",\n\t\t\t card->shortname);\n\telse\n\t\tsprintf(rmidi->name, \"MPU-401 MIDI %d-%d\",card->number, device);\n\tif (out_enable) {\n\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t    &snd_mpu401_uart_output);\n\t\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;\n\t}\n\tif (in_enable) {\n\t\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t    &snd_mpu401_uart_input);\n\t\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\n\t\tif (out_enable)\n\t\t\trmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;\n\t}\n\tmpu->rmidi = rmidi;\n\tif (rrawmidi)\n\t\t*rrawmidi = rmidi;\n\treturn 0;\nfree_device:\n\tsnd_device_free(card, rmidi);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_mpu401_uart_new);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}