{
  "module_name": "dummy.c",
  "hash_id": "69a09e0cda216afcd649e6c47c1f3d2a9ef3fb1a0d57c6772c551f4114559aaf",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/dummy.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/hrtimer.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/info.h>\n#include <sound/initval.h>\n\nMODULE_AUTHOR(\"Jaroslav Kysela <perex@perex.cz>\");\nMODULE_DESCRIPTION(\"Dummy soundcard (/dev/null)\");\nMODULE_LICENSE(\"GPL\");\n\n#define MAX_PCM_DEVICES\t\t4\n#define MAX_PCM_SUBSTREAMS\t128\n#define MAX_MIDI_DEVICES\t2\n\n \n#define MAX_BUFFER_SIZE\t\t(64*1024)\n#define MIN_PERIOD_SIZE\t\t64\n#define MAX_PERIOD_SIZE\t\tMAX_BUFFER_SIZE\n#define USE_FORMATS \t\t(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE)\n#define USE_RATE\t\tSNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000\n#define USE_RATE_MIN\t\t5500\n#define USE_RATE_MAX\t\t48000\n#define USE_CHANNELS_MIN \t1\n#define USE_CHANNELS_MAX \t2\n#define USE_PERIODS_MIN \t1\n#define USE_PERIODS_MAX \t1024\n#define USE_MIXER_VOLUME_LEVEL_MIN\t-50\n#define USE_MIXER_VOLUME_LEVEL_MAX\t100\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};\nstatic char *model[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = NULL};\nstatic int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};\nstatic int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};\n\nstatic int mixer_volume_level_min = USE_MIXER_VOLUME_LEVEL_MIN;\nstatic int mixer_volume_level_max = USE_MIXER_VOLUME_LEVEL_MAX;\n#ifdef CONFIG_HIGH_RES_TIMERS\nstatic bool hrtimer = 1;\n#endif\nstatic bool fake_buffer = 1;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for dummy soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for dummy soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable this dummy soundcard.\");\nmodule_param_array(model, charp, NULL, 0444);\nMODULE_PARM_DESC(model, \"Soundcard model.\");\nmodule_param_array(pcm_devs, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_devs, \"PCM devices # (0-4) for dummy driver.\");\nmodule_param_array(pcm_substreams, int, NULL, 0444);\nMODULE_PARM_DESC(pcm_substreams, \"PCM substreams # (1-128) for dummy driver.\");\n\n\nmodule_param(mixer_volume_level_min, int, 0444);\nMODULE_PARM_DESC(mixer_volume_level_min, \"Minimum mixer volume level for dummy driver. Default: -50\");\nmodule_param(mixer_volume_level_max, int, 0444);\nMODULE_PARM_DESC(mixer_volume_level_max, \"Maximum mixer volume level for dummy driver. Default: 100\");\nmodule_param(fake_buffer, bool, 0444);\nMODULE_PARM_DESC(fake_buffer, \"Fake buffer allocations.\");\n#ifdef CONFIG_HIGH_RES_TIMERS\nmodule_param(hrtimer, bool, 0644);\nMODULE_PARM_DESC(hrtimer, \"Use hrtimer as the timer source.\");\n#endif\n\nstatic struct platform_device *devices[SNDRV_CARDS];\n\n#define MIXER_ADDR_MASTER\t0\n#define MIXER_ADDR_LINE\t\t1\n#define MIXER_ADDR_MIC\t\t2\n#define MIXER_ADDR_SYNTH\t3\n#define MIXER_ADDR_CD\t\t4\n#define MIXER_ADDR_LAST\t\t4\n\nstruct dummy_timer_ops {\n\tint (*create)(struct snd_pcm_substream *);\n\tvoid (*free)(struct snd_pcm_substream *);\n\tint (*prepare)(struct snd_pcm_substream *);\n\tint (*start)(struct snd_pcm_substream *);\n\tint (*stop)(struct snd_pcm_substream *);\n\tsnd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);\n};\n\n#define get_dummy_ops(substream) \\\n\t(*(const struct dummy_timer_ops **)(substream)->runtime->private_data)\n\nstruct dummy_model {\n\tconst char *name;\n\tint (*playback_constraints)(struct snd_pcm_runtime *runtime);\n\tint (*capture_constraints)(struct snd_pcm_runtime *runtime);\n\tu64 formats;\n\tsize_t buffer_bytes_max;\n\tsize_t period_bytes_min;\n\tsize_t period_bytes_max;\n\tunsigned int periods_min;\n\tunsigned int periods_max;\n\tunsigned int rates;\n\tunsigned int rate_min;\n\tunsigned int rate_max;\n\tunsigned int channels_min;\n\tunsigned int channels_max;\n};\n\nstruct snd_dummy {\n\tstruct snd_card *card;\n\tconst struct dummy_model *model;\n\tstruct snd_pcm *pcm;\n\tstruct snd_pcm_hardware pcm_hw;\n\tspinlock_t mixer_lock;\n\tint mixer_volume[MIXER_ADDR_LAST+1][2];\n\tint capture_source[MIXER_ADDR_LAST+1][2];\n\tint iobox;\n\tstruct snd_kcontrol *cd_volume_ctl;\n\tstruct snd_kcontrol *cd_switch_ctl;\n};\n\n \n\nstatic int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)\n{\n\tint err;\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic const struct dummy_model model_emu10k1 = {\n\t.name = \"emu10k1\",\n\t.playback_constraints = emu10k1_playback_constraints,\n\t.buffer_bytes_max = 128 * 1024,\n};\n\nstatic const struct dummy_model model_rme9652 = {\n\t.name = \"rme9652\",\n\t.buffer_bytes_max = 26 * 64 * 1024,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 26,\n\t.channels_max = 26,\n\t.periods_min = 2,\n\t.periods_max = 2,\n};\n\nstatic const struct dummy_model model_ice1712 = {\n\t.name = \"ice1712\",\n\t.buffer_bytes_max = 256 * 1024,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 10,\n\t.channels_max = 10,\n\t.periods_min = 1,\n\t.periods_max = 1024,\n};\n\nstatic const struct dummy_model model_uda1341 = {\n\t.name = \"uda1341\",\n\t.buffer_bytes_max = 16380,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.periods_min = 2,\n\t.periods_max = 255,\n};\n\nstatic const struct dummy_model model_ac97 = {\n\t.name = \"ac97\",\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000,\n\t.rate_min = 48000,\n\t.rate_max = 48000,\n};\n\nstatic const struct dummy_model model_ca0106 = {\n\t.name = \"ca0106\",\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.buffer_bytes_max = ((65536-64)*8),\n\t.period_bytes_max = (65536-64),\n\t.periods_min = 2,\n\t.periods_max = 8,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_96000|SNDRV_PCM_RATE_192000,\n\t.rate_min = 48000,\n\t.rate_max = 192000,\n};\n\nstatic const struct dummy_model *dummy_models[] = {\n\t&model_emu10k1,\n\t&model_rme9652,\n\t&model_ice1712,\n\t&model_uda1341,\n\t&model_ac97,\n\t&model_ca0106,\n\tNULL\n};\n\n \n\nstruct dummy_systimer_pcm {\n\t \n\tconst struct dummy_timer_ops *timer_ops;\n\tspinlock_t lock;\n\tstruct timer_list timer;\n\tunsigned long base_time;\n\tunsigned int frac_pos;\t \n\tunsigned int frac_period_rest;\n\tunsigned int frac_buffer_size;\t \n\tunsigned int frac_period_size;\t \n\tunsigned int rate;\n\tint elapsed;\n\tstruct snd_pcm_substream *substream;\n};\n\nstatic void dummy_systimer_rearm(struct dummy_systimer_pcm *dpcm)\n{\n\tmod_timer(&dpcm->timer, jiffies +\n\t\tDIV_ROUND_UP(dpcm->frac_period_rest, dpcm->rate));\n}\n\nstatic void dummy_systimer_update(struct dummy_systimer_pcm *dpcm)\n{\n\tunsigned long delta;\n\n\tdelta = jiffies - dpcm->base_time;\n\tif (!delta)\n\t\treturn;\n\tdpcm->base_time += delta;\n\tdelta *= dpcm->rate;\n\tdpcm->frac_pos += delta;\n\twhile (dpcm->frac_pos >= dpcm->frac_buffer_size)\n\t\tdpcm->frac_pos -= dpcm->frac_buffer_size;\n\twhile (dpcm->frac_period_rest <= delta) {\n\t\tdpcm->elapsed++;\n\t\tdpcm->frac_period_rest += dpcm->frac_period_size;\n\t}\n\tdpcm->frac_period_rest -= delta;\n}\n\nstatic int dummy_systimer_start(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\n\tspin_lock(&dpcm->lock);\n\tdpcm->base_time = jiffies;\n\tdummy_systimer_rearm(dpcm);\n\tspin_unlock(&dpcm->lock);\n\treturn 0;\n}\n\nstatic int dummy_systimer_stop(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\n\tspin_lock(&dpcm->lock);\n\tdel_timer(&dpcm->timer);\n\tspin_unlock(&dpcm->lock);\n\treturn 0;\n}\n\nstatic int dummy_systimer_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dummy_systimer_pcm *dpcm = runtime->private_data;\n\n\tdpcm->frac_pos = 0;\n\tdpcm->rate = runtime->rate;\n\tdpcm->frac_buffer_size = runtime->buffer_size * HZ;\n\tdpcm->frac_period_size = runtime->period_size * HZ;\n\tdpcm->frac_period_rest = dpcm->frac_period_size;\n\tdpcm->elapsed = 0;\n\n\treturn 0;\n}\n\nstatic void dummy_systimer_callback(struct timer_list *t)\n{\n\tstruct dummy_systimer_pcm *dpcm = from_timer(dpcm, t, timer);\n\tunsigned long flags;\n\tint elapsed = 0;\n\n\tspin_lock_irqsave(&dpcm->lock, flags);\n\tdummy_systimer_update(dpcm);\n\tdummy_systimer_rearm(dpcm);\n\telapsed = dpcm->elapsed;\n\tdpcm->elapsed = 0;\n\tspin_unlock_irqrestore(&dpcm->lock, flags);\n\tif (elapsed)\n\t\tsnd_pcm_period_elapsed(dpcm->substream);\n}\n\nstatic snd_pcm_uframes_t\ndummy_systimer_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\n\tsnd_pcm_uframes_t pos;\n\n\tspin_lock(&dpcm->lock);\n\tdummy_systimer_update(dpcm);\n\tpos = dpcm->frac_pos / HZ;\n\tspin_unlock(&dpcm->lock);\n\treturn pos;\n}\n\nstatic int dummy_systimer_create(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_systimer_pcm *dpcm;\n\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (!dpcm)\n\t\treturn -ENOMEM;\n\tsubstream->runtime->private_data = dpcm;\n\ttimer_setup(&dpcm->timer, dummy_systimer_callback, 0);\n\tspin_lock_init(&dpcm->lock);\n\tdpcm->substream = substream;\n\treturn 0;\n}\n\nstatic void dummy_systimer_free(struct snd_pcm_substream *substream)\n{\n\tkfree(substream->runtime->private_data);\n}\n\nstatic const struct dummy_timer_ops dummy_systimer_ops = {\n\t.create =\tdummy_systimer_create,\n\t.free =\t\tdummy_systimer_free,\n\t.prepare =\tdummy_systimer_prepare,\n\t.start =\tdummy_systimer_start,\n\t.stop =\t\tdummy_systimer_stop,\n\t.pointer =\tdummy_systimer_pointer,\n};\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n \n\nstruct dummy_hrtimer_pcm {\n\t \n\tconst struct dummy_timer_ops *timer_ops;\n\tktime_t base_time;\n\tktime_t period_time;\n\tatomic_t running;\n\tstruct hrtimer timer;\n\tstruct snd_pcm_substream *substream;\n};\n\nstatic enum hrtimer_restart dummy_hrtimer_callback(struct hrtimer *timer)\n{\n\tstruct dummy_hrtimer_pcm *dpcm;\n\n\tdpcm = container_of(timer, struct dummy_hrtimer_pcm, timer);\n\tif (!atomic_read(&dpcm->running))\n\t\treturn HRTIMER_NORESTART;\n\t \n\tsnd_pcm_period_elapsed(dpcm->substream);\n\tif (!atomic_read(&dpcm->running))\n\t\treturn HRTIMER_NORESTART;\n\n\thrtimer_forward_now(timer, dpcm->period_time);\n\treturn HRTIMER_RESTART;\n}\n\nstatic int dummy_hrtimer_start(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\n\n\tdpcm->base_time = hrtimer_cb_get_time(&dpcm->timer);\n\thrtimer_start(&dpcm->timer, dpcm->period_time, HRTIMER_MODE_REL_SOFT);\n\tatomic_set(&dpcm->running, 1);\n\treturn 0;\n}\n\nstatic int dummy_hrtimer_stop(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\n\n\tatomic_set(&dpcm->running, 0);\n\tif (!hrtimer_callback_running(&dpcm->timer))\n\t\thrtimer_cancel(&dpcm->timer);\n\treturn 0;\n}\n\nstatic inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)\n{\n\thrtimer_cancel(&dpcm->timer);\n}\n\nstatic snd_pcm_uframes_t\ndummy_hrtimer_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dummy_hrtimer_pcm *dpcm = runtime->private_data;\n\tu64 delta;\n\tu32 pos;\n\n\tdelta = ktime_us_delta(hrtimer_cb_get_time(&dpcm->timer),\n\t\t\t       dpcm->base_time);\n\tdelta = div_u64(delta * runtime->rate + 999999, 1000000);\n\tdiv_u64_rem(delta, runtime->buffer_size, &pos);\n\treturn pos;\n}\n\nstatic int dummy_hrtimer_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dummy_hrtimer_pcm *dpcm = runtime->private_data;\n\tunsigned int period, rate;\n\tlong sec;\n\tunsigned long nsecs;\n\n\tdummy_hrtimer_sync(dpcm);\n\tperiod = runtime->period_size;\n\trate = runtime->rate;\n\tsec = period / rate;\n\tperiod %= rate;\n\tnsecs = div_u64((u64)period * 1000000000UL + rate - 1, rate);\n\tdpcm->period_time = ktime_set(sec, nsecs);\n\n\treturn 0;\n}\n\nstatic int dummy_hrtimer_create(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_hrtimer_pcm *dpcm;\n\n\tdpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\n\tif (!dpcm)\n\t\treturn -ENOMEM;\n\tsubstream->runtime->private_data = dpcm;\n\thrtimer_init(&dpcm->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tdpcm->timer.function = dummy_hrtimer_callback;\n\tdpcm->substream = substream;\n\tatomic_set(&dpcm->running, 0);\n\treturn 0;\n}\n\nstatic void dummy_hrtimer_free(struct snd_pcm_substream *substream)\n{\n\tstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\n\tdummy_hrtimer_sync(dpcm);\n\tkfree(dpcm);\n}\n\nstatic const struct dummy_timer_ops dummy_hrtimer_ops = {\n\t.create =\tdummy_hrtimer_create,\n\t.free =\t\tdummy_hrtimer_free,\n\t.prepare =\tdummy_hrtimer_prepare,\n\t.start =\tdummy_hrtimer_start,\n\t.stop =\t\tdummy_hrtimer_stop,\n\t.pointer =\tdummy_hrtimer_pointer,\n};\n\n#endif  \n\n \n\nstatic int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\treturn get_dummy_ops(substream)->start(substream);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\treturn get_dummy_ops(substream)->stop(substream);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int dummy_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\treturn get_dummy_ops(substream)->prepare(substream);\n}\n\nstatic snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\treturn get_dummy_ops(substream)->pointer(substream);\n}\n\nstatic const struct snd_pcm_hardware dummy_pcm_hardware = {\n\t.info =\t\t\t(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID),\n\t.formats =\t\tUSE_FORMATS,\n\t.rates =\t\tUSE_RATE,\n\t.rate_min =\t\tUSE_RATE_MIN,\n\t.rate_max =\t\tUSE_RATE_MAX,\n\t.channels_min =\t\tUSE_CHANNELS_MIN,\n\t.channels_max =\t\tUSE_CHANNELS_MAX,\n\t.buffer_bytes_max =\tMAX_BUFFER_SIZE,\n\t.period_bytes_min =\tMIN_PERIOD_SIZE,\n\t.period_bytes_max =\tMAX_PERIOD_SIZE,\n\t.periods_min =\t\tUSE_PERIODS_MIN,\n\t.periods_max =\t\tUSE_PERIODS_MAX,\n\t.fifo_size =\t\t0,\n};\n\nstatic int dummy_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *hw_params)\n{\n\tif (fake_buffer) {\n\t\t \n\t\tsubstream->runtime->dma_bytes = params_buffer_bytes(hw_params);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int dummy_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\n\tconst struct dummy_model *model = dummy->model;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tconst struct dummy_timer_ops *ops;\n\tint err;\n\n\tops = &dummy_systimer_ops;\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tif (hrtimer)\n\t\tops = &dummy_hrtimer_ops;\n#endif\n\n\terr = ops->create(substream);\n\tif (err < 0)\n\t\treturn err;\n\tget_dummy_ops(substream) = ops;\n\n\truntime->hw = dummy->pcm_hw;\n\tif (substream->pcm->device & 1) {\n\t\truntime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;\n\t\truntime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;\n\t}\n\tif (substream->pcm->device & 2)\n\t\truntime->hw.info &= ~(SNDRV_PCM_INFO_MMAP |\n\t\t\t\t      SNDRV_PCM_INFO_MMAP_VALID);\n\n\tif (model == NULL)\n\t\treturn 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (model->playback_constraints)\n\t\t\terr = model->playback_constraints(substream->runtime);\n\t} else {\n\t\tif (model->capture_constraints)\n\t\t\terr = model->capture_constraints(substream->runtime);\n\t}\n\tif (err < 0) {\n\t\tget_dummy_ops(substream)->free(substream);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int dummy_pcm_close(struct snd_pcm_substream *substream)\n{\n\tget_dummy_ops(substream)->free(substream);\n\treturn 0;\n}\n\n \n\nstatic void *dummy_page[2];\n\nstatic void free_fake_buffer(void)\n{\n\tif (fake_buffer) {\n\t\tint i;\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tif (dummy_page[i]) {\n\t\t\t\tfree_page((unsigned long)dummy_page[i]);\n\t\t\t\tdummy_page[i] = NULL;\n\t\t\t}\n\t}\n}\n\nstatic int alloc_fake_buffer(void)\n{\n\tint i;\n\n\tif (!fake_buffer)\n\t\treturn 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tdummy_page[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!dummy_page[i]) {\n\t\t\tfree_fake_buffer();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dummy_pcm_copy(struct snd_pcm_substream *substream,\n\t\t\t  int channel, unsigned long pos,\n\t\t\t  struct iov_iter *iter, unsigned long bytes)\n{\n\treturn 0;  \n}\n\nstatic int dummy_pcm_silence(struct snd_pcm_substream *substream,\n\t\t\t     int channel, unsigned long pos,\n\t\t\t     unsigned long bytes)\n{\n\treturn 0;  \n}\n\nstatic struct page *dummy_pcm_page(struct snd_pcm_substream *substream,\n\t\t\t\t   unsigned long offset)\n{\n\treturn virt_to_page(dummy_page[substream->stream]);  \n}\n\nstatic const struct snd_pcm_ops dummy_pcm_ops = {\n\t.open =\t\tdummy_pcm_open,\n\t.close =\tdummy_pcm_close,\n\t.hw_params =\tdummy_pcm_hw_params,\n\t.prepare =\tdummy_pcm_prepare,\n\t.trigger =\tdummy_pcm_trigger,\n\t.pointer =\tdummy_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops dummy_pcm_ops_no_buf = {\n\t.open =\t\tdummy_pcm_open,\n\t.close =\tdummy_pcm_close,\n\t.hw_params =\tdummy_pcm_hw_params,\n\t.prepare =\tdummy_pcm_prepare,\n\t.trigger =\tdummy_pcm_trigger,\n\t.pointer =\tdummy_pcm_pointer,\n\t.copy =\t\tdummy_pcm_copy,\n\t.fill_silence =\tdummy_pcm_silence,\n\t.page =\t\tdummy_pcm_page,\n};\n\nstatic int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,\n\t\t\t      int substreams)\n{\n\tstruct snd_pcm *pcm;\n\tconst struct snd_pcm_ops *ops;\n\tint err;\n\n\terr = snd_pcm_new(dummy->card, \"Dummy PCM\", device,\n\t\t\t       substreams, substreams, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tdummy->pcm = pcm;\n\tif (fake_buffer)\n\t\tops = &dummy_pcm_ops_no_buf;\n\telse\n\t\tops = &dummy_pcm_ops;\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, ops);\n\tpcm->private_data = dummy;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, \"Dummy PCM\");\n\tif (!fake_buffer) {\n\t\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\tSNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\tNULL,\n\t\t\t0, 64*1024);\n\t}\n\treturn 0;\n}\n\n \n\n#define DUMMY_VOLUME(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \\\n  .name = xname, .index = xindex, \\\n  .info = snd_dummy_volume_info, \\\n  .get = snd_dummy_volume_get, .put = snd_dummy_volume_put, \\\n  .private_value = addr, \\\n  .tlv = { .p = db_scale_dummy } }\n\nstatic int snd_dummy_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = mixer_volume_level_min;\n\tuinfo->value.integer.max = mixer_volume_level_max;\n\treturn 0;\n}\n\nstatic int snd_dummy_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\tint addr = kcontrol->private_value;\n\n\tspin_lock_irq(&dummy->mixer_lock);\n\tucontrol->value.integer.value[0] = dummy->mixer_volume[addr][0];\n\tucontrol->value.integer.value[1] = dummy->mixer_volume[addr][1];\n\tspin_unlock_irq(&dummy->mixer_lock);\n\treturn 0;\n}\n\nstatic int snd_dummy_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\tint change, addr = kcontrol->private_value;\n\tint left, right;\n\n\tleft = ucontrol->value.integer.value[0];\n\tif (left < mixer_volume_level_min)\n\t\tleft = mixer_volume_level_min;\n\tif (left > mixer_volume_level_max)\n\t\tleft = mixer_volume_level_max;\n\tright = ucontrol->value.integer.value[1];\n\tif (right < mixer_volume_level_min)\n\t\tright = mixer_volume_level_min;\n\tif (right > mixer_volume_level_max)\n\t\tright = mixer_volume_level_max;\n\tspin_lock_irq(&dummy->mixer_lock);\n\tchange = dummy->mixer_volume[addr][0] != left ||\n\t         dummy->mixer_volume[addr][1] != right;\n\tdummy->mixer_volume[addr][0] = left;\n\tdummy->mixer_volume[addr][1] = right;\n\tspin_unlock_irq(&dummy->mixer_lock);\n\treturn change;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);\n\n#define DUMMY_CAPSRC(xname, xindex, addr) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \\\n  .info = snd_dummy_capsrc_info, \\\n  .get = snd_dummy_capsrc_get, .put = snd_dummy_capsrc_put, \\\n  .private_value = addr }\n\n#define snd_dummy_capsrc_info\tsnd_ctl_boolean_stereo_info\n\nstatic int snd_dummy_capsrc_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\tint addr = kcontrol->private_value;\n\n\tspin_lock_irq(&dummy->mixer_lock);\n\tucontrol->value.integer.value[0] = dummy->capture_source[addr][0];\n\tucontrol->value.integer.value[1] = dummy->capture_source[addr][1];\n\tspin_unlock_irq(&dummy->mixer_lock);\n\treturn 0;\n}\n\nstatic int snd_dummy_capsrc_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\tint change, addr = kcontrol->private_value;\n\tint left, right;\n\n\tleft = ucontrol->value.integer.value[0] & 1;\n\tright = ucontrol->value.integer.value[1] & 1;\n\tspin_lock_irq(&dummy->mixer_lock);\n\tchange = dummy->capture_source[addr][0] != left &&\n\t         dummy->capture_source[addr][1] != right;\n\tdummy->capture_source[addr][0] = left;\n\tdummy->capture_source[addr][1] = right;\n\tspin_unlock_irq(&dummy->mixer_lock);\n\treturn change;\n}\n\nstatic int snd_dummy_iobox_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"None\", \"CD Player\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n\nstatic int snd_dummy_iobox_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\n\tvalue->value.enumerated.item[0] = dummy->iobox;\n\treturn 0;\n}\n\nstatic int snd_dummy_iobox_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *value)\n{\n\tstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\n\tchanged = value->value.enumerated.item[0] != dummy->iobox;\n\tif (changed) {\n\t\tdummy->iobox = value->value.enumerated.item[0];\n\n\t\tif (dummy->iobox) {\n\t\t\tdummy->cd_volume_ctl->vd[0].access &=\n\t\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\tdummy->cd_switch_ctl->vd[0].access &=\n\t\t\t\t~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t} else {\n\t\t\tdummy->cd_volume_ctl->vd[0].access |=\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t\tdummy->cd_switch_ctl->vd[0].access |=\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t\t}\n\n\t\tsnd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &dummy->cd_volume_ctl->id);\n\t\tsnd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &dummy->cd_switch_ctl->id);\n\t}\n\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new snd_dummy_controls[] = {\nDUMMY_VOLUME(\"Master Volume\", 0, MIXER_ADDR_MASTER),\nDUMMY_CAPSRC(\"Master Capture Switch\", 0, MIXER_ADDR_MASTER),\nDUMMY_VOLUME(\"Synth Volume\", 0, MIXER_ADDR_SYNTH),\nDUMMY_CAPSRC(\"Synth Capture Switch\", 0, MIXER_ADDR_SYNTH),\nDUMMY_VOLUME(\"Line Volume\", 0, MIXER_ADDR_LINE),\nDUMMY_CAPSRC(\"Line Capture Switch\", 0, MIXER_ADDR_LINE),\nDUMMY_VOLUME(\"Mic Volume\", 0, MIXER_ADDR_MIC),\nDUMMY_CAPSRC(\"Mic Capture Switch\", 0, MIXER_ADDR_MIC),\nDUMMY_VOLUME(\"CD Volume\", 0, MIXER_ADDR_CD),\nDUMMY_CAPSRC(\"CD Capture Switch\", 0, MIXER_ADDR_CD),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name  = \"External I/O Box\",\n\t.info  = snd_dummy_iobox_info,\n\t.get   = snd_dummy_iobox_get,\n\t.put   = snd_dummy_iobox_put,\n},\n};\n\nstatic int snd_card_dummy_new_mixer(struct snd_dummy *dummy)\n{\n\tstruct snd_card *card = dummy->card;\n\tstruct snd_kcontrol *kcontrol;\n\tunsigned int idx;\n\tint err;\n\n\tspin_lock_init(&dummy->mixer_lock);\n\tstrcpy(card->mixername, \"Dummy Mixer\");\n\tdummy->iobox = 1;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_dummy_controls); idx++) {\n\t\tkcontrol = snd_ctl_new1(&snd_dummy_controls[idx], dummy);\n\t\terr = snd_ctl_add(card, kcontrol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!strcmp(kcontrol->id.name, \"CD Volume\"))\n\t\t\tdummy->cd_volume_ctl = kcontrol;\n\t\telse if (!strcmp(kcontrol->id.name, \"CD Capture Switch\"))\n\t\t\tdummy->cd_switch_ctl = kcontrol;\n\n\t}\n\treturn 0;\n}\n\n#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_SND_PROC_FS)\n \nstatic void print_formats(struct snd_dummy *dummy,\n\t\t\t  struct snd_info_buffer *buffer)\n{\n\tsnd_pcm_format_t i;\n\n\tpcm_for_each_format(i) {\n\t\tif (dummy->pcm_hw.formats & pcm_format_to_bits(i))\n\t\t\tsnd_iprintf(buffer, \" %s\", snd_pcm_format_name(i));\n\t}\n}\n\nstatic void print_rates(struct snd_dummy *dummy,\n\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstatic const int rates[] = {\n\t\t5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,\n\t\t64000, 88200, 96000, 176400, 192000,\n\t};\n\tint i;\n\n\tif (dummy->pcm_hw.rates & SNDRV_PCM_RATE_CONTINUOUS)\n\t\tsnd_iprintf(buffer, \" continuous\");\n\tif (dummy->pcm_hw.rates & SNDRV_PCM_RATE_KNOT)\n\t\tsnd_iprintf(buffer, \" knot\");\n\tfor (i = 0; i < ARRAY_SIZE(rates); i++)\n\t\tif (dummy->pcm_hw.rates & (1 << i))\n\t\t\tsnd_iprintf(buffer, \" %d\", rates[i]);\n}\n\n#define get_dummy_int_ptr(dummy, ofs) \\\n\t(unsigned int *)((char *)&((dummy)->pcm_hw) + (ofs))\n#define get_dummy_ll_ptr(dummy, ofs) \\\n\t(unsigned long long *)((char *)&((dummy)->pcm_hw) + (ofs))\n\nstruct dummy_hw_field {\n\tconst char *name;\n\tconst char *format;\n\tunsigned int offset;\n\tunsigned int size;\n};\n#define FIELD_ENTRY(item, fmt) {\t\t   \\\n\t.name = #item,\t\t\t\t   \\\n\t.format = fmt,\t\t\t\t   \\\n\t.offset = offsetof(struct snd_pcm_hardware, item), \\\n\t.size = sizeof(dummy_pcm_hardware.item) }\n\nstatic const struct dummy_hw_field fields[] = {\n\tFIELD_ENTRY(formats, \"%#llx\"),\n\tFIELD_ENTRY(rates, \"%#x\"),\n\tFIELD_ENTRY(rate_min, \"%d\"),\n\tFIELD_ENTRY(rate_max, \"%d\"),\n\tFIELD_ENTRY(channels_min, \"%d\"),\n\tFIELD_ENTRY(channels_max, \"%d\"),\n\tFIELD_ENTRY(buffer_bytes_max, \"%ld\"),\n\tFIELD_ENTRY(period_bytes_min, \"%ld\"),\n\tFIELD_ENTRY(period_bytes_max, \"%ld\"),\n\tFIELD_ENTRY(periods_min, \"%d\"),\n\tFIELD_ENTRY(periods_max, \"%d\"),\n};\n\nstatic void dummy_proc_read(struct snd_info_entry *entry,\n\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_dummy *dummy = entry->private_data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fields); i++) {\n\t\tsnd_iprintf(buffer, \"%s \", fields[i].name);\n\t\tif (fields[i].size == sizeof(int))\n\t\t\tsnd_iprintf(buffer, fields[i].format,\n\t\t\t\t*get_dummy_int_ptr(dummy, fields[i].offset));\n\t\telse\n\t\t\tsnd_iprintf(buffer, fields[i].format,\n\t\t\t\t*get_dummy_ll_ptr(dummy, fields[i].offset));\n\t\tif (!strcmp(fields[i].name, \"formats\"))\n\t\t\tprint_formats(dummy, buffer);\n\t\telse if (!strcmp(fields[i].name, \"rates\"))\n\t\t\tprint_rates(dummy, buffer);\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t}\n}\n\nstatic void dummy_proc_write(struct snd_info_entry *entry,\n\t\t\t     struct snd_info_buffer *buffer)\n{\n\tstruct snd_dummy *dummy = entry->private_data;\n\tchar line[64];\n\n\twhile (!snd_info_get_line(buffer, line, sizeof(line))) {\n\t\tchar item[20];\n\t\tconst char *ptr;\n\t\tunsigned long long val;\n\t\tint i;\n\n\t\tptr = snd_info_get_str(item, line, sizeof(item));\n\t\tfor (i = 0; i < ARRAY_SIZE(fields); i++) {\n\t\t\tif (!strcmp(item, fields[i].name))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(fields))\n\t\t\tcontinue;\n\t\tsnd_info_get_str(item, ptr, sizeof(item));\n\t\tif (kstrtoull(item, 0, &val))\n\t\t\tcontinue;\n\t\tif (fields[i].size == sizeof(int))\n\t\t\t*get_dummy_int_ptr(dummy, fields[i].offset) = val;\n\t\telse\n\t\t\t*get_dummy_ll_ptr(dummy, fields[i].offset) = val;\n\t}\n}\n\nstatic void dummy_proc_init(struct snd_dummy *chip)\n{\n\tsnd_card_rw_proc_new(chip->card, \"dummy_pcm\", chip,\n\t\t\t     dummy_proc_read, dummy_proc_write);\n}\n#else\n#define dummy_proc_init(x)\n#endif  \n\nstatic int snd_dummy_probe(struct platform_device *devptr)\n{\n\tstruct snd_card *card;\n\tstruct snd_dummy *dummy;\n\tconst struct dummy_model *m = NULL, **mdl;\n\tint idx, err;\n\tint dev = devptr->id;\n\n\terr = snd_devm_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t\tsizeof(struct snd_dummy), &card);\n\tif (err < 0)\n\t\treturn err;\n\tdummy = card->private_data;\n\tdummy->card = card;\n\tfor (mdl = dummy_models; *mdl && model[dev]; mdl++) {\n\t\tif (strcmp(model[dev], (*mdl)->name) == 0) {\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"snd-dummy: Using model '%s' for card %i\\n\",\n\t\t\t\t(*mdl)->name, card->number);\n\t\t\tm = dummy->model = *mdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {\n\t\tif (pcm_substreams[dev] < 1)\n\t\t\tpcm_substreams[dev] = 1;\n\t\tif (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)\n\t\t\tpcm_substreams[dev] = MAX_PCM_SUBSTREAMS;\n\t\terr = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdummy->pcm_hw = dummy_pcm_hardware;\n\tif (m) {\n\t\tif (m->formats)\n\t\t\tdummy->pcm_hw.formats = m->formats;\n\t\tif (m->buffer_bytes_max)\n\t\t\tdummy->pcm_hw.buffer_bytes_max = m->buffer_bytes_max;\n\t\tif (m->period_bytes_min)\n\t\t\tdummy->pcm_hw.period_bytes_min = m->period_bytes_min;\n\t\tif (m->period_bytes_max)\n\t\t\tdummy->pcm_hw.period_bytes_max = m->period_bytes_max;\n\t\tif (m->periods_min)\n\t\t\tdummy->pcm_hw.periods_min = m->periods_min;\n\t\tif (m->periods_max)\n\t\t\tdummy->pcm_hw.periods_max = m->periods_max;\n\t\tif (m->rates)\n\t\t\tdummy->pcm_hw.rates = m->rates;\n\t\tif (m->rate_min)\n\t\t\tdummy->pcm_hw.rate_min = m->rate_min;\n\t\tif (m->rate_max)\n\t\t\tdummy->pcm_hw.rate_max = m->rate_max;\n\t\tif (m->channels_min)\n\t\t\tdummy->pcm_hw.channels_min = m->channels_min;\n\t\tif (m->channels_max)\n\t\t\tdummy->pcm_hw.channels_max = m->channels_max;\n\t}\n\n\tif (mixer_volume_level_min > mixer_volume_level_max) {\n\t\tpr_warn(\"snd-dummy: Invalid mixer volume level: min=%d, max=%d. Fall back to default value.\\n\",\n\t\tmixer_volume_level_min, mixer_volume_level_max);\n\t\tmixer_volume_level_min = USE_MIXER_VOLUME_LEVEL_MIN;\n\t\tmixer_volume_level_max = USE_MIXER_VOLUME_LEVEL_MAX;\n\t}\n\terr = snd_card_dummy_new_mixer(dummy);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(card->driver, \"Dummy\");\n\tstrcpy(card->shortname, \"Dummy\");\n\tsprintf(card->longname, \"Dummy %i\", dev + 1);\n\n\tdummy_proc_init(dummy);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\treturn err;\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int snd_dummy_suspend(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\n\treturn 0;\n}\n\nstatic int snd_dummy_resume(struct device *pdev)\n{\n\tstruct snd_card *card = dev_get_drvdata(pdev);\n\n\tsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(snd_dummy_pm, snd_dummy_suspend, snd_dummy_resume);\n#define SND_DUMMY_PM_OPS\t&snd_dummy_pm\n#else\n#define SND_DUMMY_PM_OPS\tNULL\n#endif\n\n#define SND_DUMMY_DRIVER\t\"snd_dummy\"\n\nstatic struct platform_driver snd_dummy_driver = {\n\t.probe\t\t= snd_dummy_probe,\n\t.driver\t\t= {\n\t\t.name\t= SND_DUMMY_DRIVER,\n\t\t.pm\t= SND_DUMMY_PM_OPS,\n\t},\n};\n\nstatic void snd_dummy_unregister_all(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); ++i)\n\t\tplatform_device_unregister(devices[i]);\n\tplatform_driver_unregister(&snd_dummy_driver);\n\tfree_fake_buffer();\n}\n\nstatic int __init alsa_card_dummy_init(void)\n{\n\tint i, cards, err;\n\n\terr = platform_driver_register(&snd_dummy_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = alloc_fake_buffer();\n\tif (err < 0) {\n\t\tplatform_driver_unregister(&snd_dummy_driver);\n\t\treturn err;\n\t}\n\n\tcards = 0;\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tstruct platform_device *device;\n\t\tif (! enable[i])\n\t\t\tcontinue;\n\t\tdevice = platform_device_register_simple(SND_DUMMY_DRIVER,\n\t\t\t\t\t\t\t i, NULL, 0);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (!platform_get_drvdata(device)) {\n\t\t\tplatform_device_unregister(device);\n\t\t\tcontinue;\n\t\t}\n\t\tdevices[i] = device;\n\t\tcards++;\n\t}\n\tif (!cards) {\n#ifdef MODULE\n\t\tprintk(KERN_ERR \"Dummy soundcard not found or device busy\\n\");\n#endif\n\t\tsnd_dummy_unregister_all();\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit alsa_card_dummy_exit(void)\n{\n\tsnd_dummy_unregister_all();\n}\n\nmodule_init(alsa_card_dummy_init)\nmodule_exit(alsa_card_dummy_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}