{
  "module_name": "mtpav.c",
  "hash_id": "6c664513e17b61ad0eda09a0bc7739b6d4f0dfaeaeef2dbdff8a5837ecc72eb6",
  "original_prompt": "Ingested from linux-6.6.14/sound/drivers/mtpav.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/moduleparam.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n#include <linux/delay.h>\n\n \nMODULE_AUTHOR(\"Michael T. Mayers\");\nMODULE_DESCRIPTION(\"MOTU MidiTimePiece AV multiport MIDI\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define MTPAV_IOBASE\t\t0x378\n#define MTPAV_IRQ\t\t7\n#define MTPAV_MAX_PORTS\t\t8\n\nstatic int index = SNDRV_DEFAULT_IDX1;\nstatic char *id = SNDRV_DEFAULT_STR1;\nstatic long port = MTPAV_IOBASE;\t \nstatic int irq = MTPAV_IRQ;\t\t \nstatic int hwports = MTPAV_MAX_PORTS;\t \n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for MotuMTPAV MIDI.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for MotuMTPAV MIDI.\");\nmodule_param_hw(port, long, ioport, 0444);\nMODULE_PARM_DESC(port, \"Parallel port # for MotuMTPAV MIDI.\");\nmodule_param_hw(irq, int, irq, 0444);\nMODULE_PARM_DESC(irq, \"Parallel IRQ # for MotuMTPAV MIDI.\");\nmodule_param(hwports, int, 0444);\nMODULE_PARM_DESC(hwports, \"Hardware ports # for MotuMTPAV MIDI.\");\n\nstatic struct platform_device *device;\n\n \n \n\n \n#define SIGS_BYTE 0x08\n#define SIGS_RFD 0x80\n#define SIGS_IRQ 0x40\n#define SIGS_IN0 0x10\n#define SIGS_IN1 0x20\n\n#define SIGC_WRITE 0x04\n#define SIGC_READ 0x08\n#define SIGC_INTEN 0x10\n\n#define DREG 0\n#define SREG 1\n#define CREG 2\n\n \n#define MTPAV_MODE_INPUT_OPENED\t\t0x01\n#define MTPAV_MODE_OUTPUT_OPENED\t0x02\n#define MTPAV_MODE_INPUT_TRIGGERED\t0x04\n#define MTPAV_MODE_OUTPUT_TRIGGERED\t0x08\n\n#define NUMPORTS (0x12+1)\n\n\n \n\nstruct mtpav_port {\n\tu8 number;\n\tu8 hwport;\n\tu8 mode;\n\tu8 running_status;\n\tstruct snd_rawmidi_substream *input;\n\tstruct snd_rawmidi_substream *output;\n};\n\nstruct mtpav {\n\tstruct snd_card *card;\n\tunsigned long port;\n\tstruct resource *res_port;\n\tint irq;\t\t\t \n\tspinlock_t spinlock;\n\tint share_irq;\t\t\t \n\tint istimer;\t\t\t \n\tstruct timer_list timer;\t \n\tstruct snd_rawmidi *rmidi;\n\tint num_ports;\t\t \n\tstruct mtpav_port ports[NUMPORTS];\t \n\n\tu32 inmidiport;\t\t \n\tu32 inmidistate;\t \n\n\tu32 outmidihwport;\t \n};\n\n\n \n\n#define MTPAV_PIDX_COMPUTER\t0\n#define MTPAV_PIDX_ADAT\t\t1\n#define MTPAV_PIDX_BROADCAST\t2\n\n\nstatic int translate_subdevice_to_hwport(struct mtpav *chip, int subdev)\n{\n\tif (subdev < 0)\n\t\treturn 0x01;  \n\telse if (subdev < chip->num_ports)\n\t\treturn subdev + 1;  \n\telse if (subdev < chip->num_ports * 2)\n\t\treturn subdev - chip->num_ports + 0x09;  \n\telse if (subdev == chip->num_ports * 2 + MTPAV_PIDX_COMPUTER)\n\t\treturn 0x11;  \n\telse if (subdev == chip->num_ports + MTPAV_PIDX_ADAT)\n\t\treturn 0x63;\t\t \n\treturn 0;  \n}\n\nstatic int translate_hwport_to_subdevice(struct mtpav *chip, int hwport)\n{\n\tint p;\n\tif (hwport <= 0x00)  \n\t\treturn chip->num_ports + MTPAV_PIDX_BROADCAST;\n\telse if (hwport <= 0x08) {  \n\t\tp = hwport - 1;\n\t\tif (p >= chip->num_ports)\n\t\t\tp = 0;\n\t\treturn p;\n\t} else if (hwport <= 0x10) {  \n\t\tp = hwport - 0x09 + chip->num_ports;\n\t\tif (p >= chip->num_ports * 2)\n\t\t\tp = chip->num_ports;\n\t\treturn p;\n\t} else if (hwport == 0x11)   \n\t\treturn chip->num_ports + MTPAV_PIDX_COMPUTER;\n\telse   \n\t\treturn chip->num_ports + MTPAV_PIDX_ADAT;\n}\n\n\n \n\nstatic u8 snd_mtpav_getreg(struct mtpav *chip, u16 reg)\n{\n\tu8 rval = 0;\n\n\tif (reg == SREG) {\n\t\trval = inb(chip->port + SREG);\n\t\trval = (rval & 0xf8);\n\t} else if (reg == CREG) {\n\t\trval = inb(chip->port + CREG);\n\t\trval = (rval & 0x1c);\n\t}\n\n\treturn rval;\n}\n\n \n\nstatic inline void snd_mtpav_mputreg(struct mtpav *chip, u16 reg, u8 val)\n{\n\tif (reg == DREG || reg == CREG)\n\t\toutb(val, chip->port + reg);\n}\n\n \n\nstatic void snd_mtpav_wait_rfdhi(struct mtpav *chip)\n{\n\tint counts = 10000;\n\tu8 sbyte;\n\n\tsbyte = snd_mtpav_getreg(chip, SREG);\n\twhile (!(sbyte & SIGS_RFD) && counts--) {\n\t\tsbyte = snd_mtpav_getreg(chip, SREG);\n\t\tudelay(10);\n\t}\n}\n\nstatic void snd_mtpav_send_byte(struct mtpav *chip, u8 byte)\n{\n\tu8 tcbyt;\n\tu8 clrwrite;\n\tu8 setwrite;\n\n\tsnd_mtpav_wait_rfdhi(chip);\n\n\t \n\n\ttcbyt = snd_mtpav_getreg(chip, CREG);\n\tclrwrite = tcbyt & (SIGC_WRITE ^ 0xff);\n\tsetwrite = tcbyt | SIGC_WRITE;\n\n\tsnd_mtpav_mputreg(chip, DREG, byte);\n\tsnd_mtpav_mputreg(chip, CREG, clrwrite);\t \n\n\tsnd_mtpav_mputreg(chip, CREG, setwrite);\t \n\n}\n\n\n \n\n \nstatic void snd_mtpav_output_port_write(struct mtpav *mtp_card,\n\t\t\t\t\tstruct mtpav_port *portp,\n\t\t\t\t\tstruct snd_rawmidi_substream *substream)\n{\n\tu8 outbyte;\n\n\t \n\t \n\tif (snd_rawmidi_transmit(substream, &outbyte, 1) != 1)\n\t\treturn;\n\n\t \n\n\tif (portp->hwport != mtp_card->outmidihwport) {\n\t\tmtp_card->outmidihwport = portp->hwport;\n\n\t\tsnd_mtpav_send_byte(mtp_card, 0xf5);\n\t\tsnd_mtpav_send_byte(mtp_card, portp->hwport);\n\t\t \n\t\tif (!(outbyte & 0x80) && portp->running_status)\n\t\t\tsnd_mtpav_send_byte(mtp_card, portp->running_status);\n\t}\n\n\t \n\n\tdo {\n\t\tif (outbyte & 0x80)\n\t\t\tportp->running_status = outbyte;\n\t\t\n\t\tsnd_mtpav_send_byte(mtp_card, outbyte);\n\t} while (snd_rawmidi_transmit(substream, &outbyte, 1) == 1);\n}\n\nstatic void snd_mtpav_output_write(struct snd_rawmidi_substream *substream)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tsnd_mtpav_output_port_write(mtp_card, portp, substream);\n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n}\n\n\n \n\nstatic void snd_mtpav_portscan(struct mtpav *chip)\t \n{\n\tu8 p;\n\n\tfor (p = 0; p < 8; p++) {\n\t\tsnd_mtpav_send_byte(chip, 0xf5);\n\t\tsnd_mtpav_send_byte(chip, p);\n\t\tsnd_mtpav_send_byte(chip, 0xfe);\n\t}\n}\n\n \n\nstatic int snd_mtpav_input_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tportp->mode |= MTPAV_MODE_INPUT_OPENED;\n\tportp->input = substream;\n\tif (mtp_card->share_irq++ == 0)\n\t\tsnd_mtpav_mputreg(mtp_card, CREG, (SIGC_INTEN | SIGC_WRITE));\t \n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\treturn 0;\n}\n\n \n\nstatic int snd_mtpav_input_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tportp->mode &= ~MTPAV_MODE_INPUT_OPENED;\n\tportp->input = NULL;\n\tif (--mtp_card->share_irq == 0)\n\t\tsnd_mtpav_mputreg(mtp_card, CREG, 0);\t \n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\treturn 0;\n}\n\n \n\nstatic void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tif (up)\n\t\tportp->mode |= MTPAV_MODE_INPUT_TRIGGERED;\n\telse\n\t\tportp->mode &= ~MTPAV_MODE_INPUT_TRIGGERED;\n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\n}\n\n\n \n\nstatic void snd_mtpav_output_timer(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct mtpav *chip = from_timer(chip, t, timer);\n\tint p;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\t \n\tmod_timer(&chip->timer, 1 + jiffies);\n\t \n\tfor (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {\n\t\tstruct mtpav_port *portp = &chip->ports[p];\n\t\tif ((portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED) && portp->output)\n\t\t\tsnd_mtpav_output_port_write(chip, portp, portp->output);\n\t}\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n}\n\n \nstatic void snd_mtpav_add_output_timer(struct mtpav *chip)\n{\n\tmod_timer(&chip->timer, 1 + jiffies);\n}\n\n \nstatic void snd_mtpav_remove_output_timer(struct mtpav *chip)\n{\n\tdel_timer(&chip->timer);\n}\n\n \n\nstatic int snd_mtpav_output_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tportp->mode |= MTPAV_MODE_OUTPUT_OPENED;\n\tportp->output = substream;\n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\treturn 0;\n};\n\n \n\nstatic int snd_mtpav_output_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tportp->mode &= ~MTPAV_MODE_OUTPUT_OPENED;\n\tportp->output = NULL;\n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\treturn 0;\n};\n\n \n\nstatic void snd_mtpav_output_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct mtpav *mtp_card = substream->rmidi->private_data;\n\tstruct mtpav_port *portp = &mtp_card->ports[substream->number];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtp_card->spinlock, flags);\n\tif (up) {\n\t\tif (! (portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED)) {\n\t\t\tif (mtp_card->istimer++ == 0)\n\t\t\t\tsnd_mtpav_add_output_timer(mtp_card);\n\t\t\tportp->mode |= MTPAV_MODE_OUTPUT_TRIGGERED;\n\t\t}\n\t} else {\n\t\tportp->mode &= ~MTPAV_MODE_OUTPUT_TRIGGERED;\n\t\tif (--mtp_card->istimer == 0)\n\t\t\tsnd_mtpav_remove_output_timer(mtp_card);\n\t}\n\tspin_unlock_irqrestore(&mtp_card->spinlock, flags);\n\n\tif (up)\n\t\tsnd_mtpav_output_write(substream);\n}\n\n \n\nstatic void snd_mtpav_inmidi_process(struct mtpav *mcrd, u8 inbyte)\n{\n\tstruct mtpav_port *portp;\n\n\tif ((int)mcrd->inmidiport > mcrd->num_ports * 2 + MTPAV_PIDX_BROADCAST)\n\t\treturn;\n\n\tportp = &mcrd->ports[mcrd->inmidiport];\n\tif (portp->mode & MTPAV_MODE_INPUT_TRIGGERED)\n\t\tsnd_rawmidi_receive(portp->input, &inbyte, 1);\n}\n\nstatic void snd_mtpav_inmidi_h(struct mtpav *mcrd, u8 inbyte)\n{\n\tif (inbyte >= 0xf8) {\n\t\t \n\t\tsnd_mtpav_inmidi_process(mcrd, inbyte);\n\t\treturn;\n\t}\n\n\tif (mcrd->inmidistate == 0) {\t \n\t\tif (inbyte == 0xf5)\t \n\t\t\tmcrd->inmidistate = 1;\n\t\telse\n\t\t\tsnd_mtpav_inmidi_process(mcrd, inbyte);\n\t} else if (mcrd->inmidistate) {\n\t\tmcrd->inmidiport = translate_hwport_to_subdevice(mcrd, inbyte);\n\t\tmcrd->inmidistate = 0;\n\t}\n}\n\nstatic void snd_mtpav_read_bytes(struct mtpav *mcrd)\n{\n\tu8 clrread, setread;\n\tu8 mtp_read_byte;\n\tu8 sr, cbyt;\n\tint i;\n\n\tu8 sbyt = snd_mtpav_getreg(mcrd, SREG);\n\n\t \n\n\tif (!(sbyt & SIGS_BYTE))\n\t\treturn;\n\n\tcbyt = snd_mtpav_getreg(mcrd, CREG);\n\tclrread = cbyt & (SIGC_READ ^ 0xff);\n\tsetread = cbyt | SIGC_READ;\n\n\tdo {\n\n\t\tmtp_read_byte = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tsnd_mtpav_mputreg(mcrd, CREG, setread);\n\t\t\tsr = snd_mtpav_getreg(mcrd, SREG);\n\t\t\tsnd_mtpav_mputreg(mcrd, CREG, clrread);\n\n\t\t\tsr &= SIGS_IN0 | SIGS_IN1;\n\t\t\tsr >>= 4;\n\t\t\tmtp_read_byte |= sr << (i * 2);\n\t\t}\n\n\t\tsnd_mtpav_inmidi_h(mcrd, mtp_read_byte);\n\n\t\tsbyt = snd_mtpav_getreg(mcrd, SREG);\n\n\t} while (sbyt & SIGS_BYTE);\n}\n\nstatic irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)\n{\n\tstruct mtpav *mcard = dev_id;\n\n\tspin_lock(&mcard->spinlock);\n\tsnd_mtpav_read_bytes(mcard);\n\tspin_unlock(&mcard->spinlock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int snd_mtpav_get_ISA(struct mtpav *mcard)\n{\n\tmcard->res_port = devm_request_region(mcard->card->dev, port, 3,\n\t\t\t\t\t      \"MotuMTPAV MIDI\");\n\tif (!mcard->res_port) {\n\t\tsnd_printk(KERN_ERR \"MTVAP port 0x%lx is busy\\n\", port);\n\t\treturn -EBUSY;\n\t}\n\tmcard->port = port;\n\tif (devm_request_irq(mcard->card->dev, irq, snd_mtpav_irqh, 0,\n\t\t\t     \"MOTU MTPAV\", mcard)) {\n\t\tsnd_printk(KERN_ERR \"MTVAP IRQ %d busy\\n\", irq);\n\t\treturn -EBUSY;\n\t}\n\tmcard->irq = irq;\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_rawmidi_ops snd_mtpav_output = {\n\t.open =\t\tsnd_mtpav_output_open,\n\t.close =\tsnd_mtpav_output_close,\n\t.trigger =\tsnd_mtpav_output_trigger,\n};\n\nstatic const struct snd_rawmidi_ops snd_mtpav_input = {\n\t.open =\t\tsnd_mtpav_input_open,\n\t.close =\tsnd_mtpav_input_close,\n\t.trigger =\tsnd_mtpav_input_trigger,\n};\n\n\n \n\nstatic void snd_mtpav_set_name(struct mtpav *chip,\n\t\t\t       struct snd_rawmidi_substream *substream)\n{\n\tif (substream->number >= 0 && substream->number < chip->num_ports)\n\t\tsprintf(substream->name, \"MTP direct %d\", (substream->number % chip->num_ports) + 1);\n\telse if (substream->number >= 8 && substream->number < chip->num_ports * 2)\n\t\tsprintf(substream->name, \"MTP remote %d\", (substream->number % chip->num_ports) + 1);\n\telse if (substream->number == chip->num_ports * 2)\n\t\tstrcpy(substream->name, \"MTP computer\");\n\telse if (substream->number == chip->num_ports * 2 + 1)\n\t\tstrcpy(substream->name, \"MTP ADAT\");\n\telse\n\t\tstrcpy(substream->name, \"MTP broadcast\");\n}\n\nstatic int snd_mtpav_get_RAWMIDI(struct mtpav *mcard)\n{\n\tint rval;\n\tstruct snd_rawmidi *rawmidi;\n\tstruct snd_rawmidi_substream *substream;\n\tstruct list_head *list;\n\n\tif (hwports < 1)\n\t\thwports = 1;\n\telse if (hwports > 8)\n\t\thwports = 8;\n\tmcard->num_ports = hwports;\n\n\trval = snd_rawmidi_new(mcard->card, \"MotuMIDI\", 0,\n\t\t\t       mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,\n\t\t\t       mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,\n\t\t\t       &mcard->rmidi);\n\tif (rval < 0)\n\t\treturn rval;\n\trawmidi = mcard->rmidi;\n\trawmidi->private_data = mcard;\n\n\tlist_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {\n\t\tsubstream = list_entry(list, struct snd_rawmidi_substream, list);\n\t\tsnd_mtpav_set_name(mcard, substream);\n\t\tsubstream->ops = &snd_mtpav_input;\n\t}\n\tlist_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {\n\t\tsubstream = list_entry(list, struct snd_rawmidi_substream, list);\n\t\tsnd_mtpav_set_name(mcard, substream);\n\t\tsubstream->ops = &snd_mtpav_output;\n\t\tmcard->ports[substream->number].hwport = translate_subdevice_to_hwport(mcard, substream->number);\n\t}\n\trawmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t       SNDRV_RAWMIDI_INFO_DUPLEX;\n\tsprintf(rawmidi->name, \"MTP AV MIDI\");\n\treturn 0;\n}\n\n \n\nstatic void snd_mtpav_free(struct snd_card *card)\n{\n\tstruct mtpav *crd = card->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&crd->spinlock, flags);\n\tif (crd->istimer > 0)\n\t\tsnd_mtpav_remove_output_timer(crd);\n\tspin_unlock_irqrestore(&crd->spinlock, flags);\n}\n\n \nstatic int snd_mtpav_probe(struct platform_device *dev)\n{\n\tstruct snd_card *card;\n\tint err;\n\tstruct mtpav *mtp_card;\n\n\terr = snd_devm_card_new(&dev->dev, index, id, THIS_MODULE,\n\t\t\t\tsizeof(*mtp_card), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tmtp_card = card->private_data;\n\tspin_lock_init(&mtp_card->spinlock);\n\tmtp_card->card = card;\n\tmtp_card->irq = -1;\n\tmtp_card->share_irq = 0;\n\tmtp_card->inmidistate = 0;\n\tmtp_card->outmidihwport = 0xffffffff;\n\ttimer_setup(&mtp_card->timer, snd_mtpav_output_timer, 0);\n\n\terr = snd_mtpav_get_RAWMIDI(mtp_card);\n\tif (err < 0)\n\t\treturn err;\n\n\tmtp_card->inmidiport = mtp_card->num_ports + MTPAV_PIDX_BROADCAST;\n\n\terr = snd_mtpav_get_ISA(mtp_card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"MTPAV\");\n\tstrcpy(card->shortname, \"MTPAV on parallel port\");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"MTPAV on parallel port at 0x%lx\", port);\n\n\tsnd_mtpav_portscan(mtp_card);\n\n\terr = snd_card_register(mtp_card->card);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard->private_free = snd_mtpav_free;\n\n\tplatform_set_drvdata(dev, card);\n\tprintk(KERN_INFO \"Motu MidiTimePiece on parallel port irq: %d ioport: 0x%lx\\n\", irq, port);\n\treturn 0;\n}\n\n#define SND_MTPAV_DRIVER\t\"snd_mtpav\"\n\nstatic struct platform_driver snd_mtpav_driver = {\n\t.probe\t\t= snd_mtpav_probe,\n\t.driver\t\t= {\n\t\t.name\t= SND_MTPAV_DRIVER,\n\t},\n};\n\nstatic int __init alsa_card_mtpav_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&snd_mtpav_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tdevice = platform_device_register_simple(SND_MTPAV_DRIVER, -1, NULL, 0);\n\tif (!IS_ERR(device)) {\n\t\tif (platform_get_drvdata(device))\n\t\t\treturn 0;\n\t\tplatform_device_unregister(device);\n\t\terr = -ENODEV;\n\t} else\n\t\terr = PTR_ERR(device);\n\tplatform_driver_unregister(&snd_mtpav_driver);\n\treturn err;\n}\n\nstatic void __exit alsa_card_mtpav_exit(void)\n{\n\tplatform_device_unregister(device);\n\tplatform_driver_unregister(&snd_mtpav_driver);\n}\n\nmodule_init(alsa_card_mtpav_init)\nmodule_exit(alsa_card_mtpav_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}