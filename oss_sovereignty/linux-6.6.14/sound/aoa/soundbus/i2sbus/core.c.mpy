{
  "module_name": "core.c",
  "hash_id": "8fcf0cee0f70570db8393ca6a0f2b83b8c59bf6736bb0b9156d95405fa4c6649",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/soundbus/i2sbus/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <sound/core.h>\n\n#include <asm/macio.h>\n#include <asm/dbdma.h>\n\n#include \"../soundbus.h\"\n#include \"i2sbus.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_DESCRIPTION(\"Apple Soundbus: I2S support\");\n\nstatic int force;\nmodule_param(force, int, 0444);\nMODULE_PARM_DESC(force, \"Force loading i2sbus even when\"\n\t\t\t\" no layout-id property is present\");\n\nstatic const struct of_device_id i2sbus_match[] = {\n\t{ .name = \"i2s\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, i2sbus_match);\n\nstatic int alloc_dbdma_descriptor_ring(struct i2sbus_dev *i2sdev,\n\t\t\t\t       struct dbdma_command_mem *r,\n\t\t\t\t       int numcmds)\n{\n\t \n\tr->size = (numcmds + 3) * sizeof(struct dbdma_cmd);\n\t \n\tr->space = dma_alloc_coherent(&macio_get_pci_dev(i2sdev->macio)->dev,\n\t\t\t\t      r->size, &r->bus_addr, GFP_KERNEL);\n\tif (!r->space)\n\t\treturn -ENOMEM;\n\n\tr->cmds = (void*)DBDMA_ALIGN(r->space);\n\tr->bus_cmd_start = r->bus_addr +\n\t\t\t   (dma_addr_t)((char*)r->cmds - (char*)r->space);\n\n\treturn 0;\n}\n\nstatic void free_dbdma_descriptor_ring(struct i2sbus_dev *i2sdev,\n\t\t\t\t       struct dbdma_command_mem *r)\n{\n\tif (!r->space) return;\n\n\tdma_free_coherent(&macio_get_pci_dev(i2sdev->macio)->dev,\n\t\t\t    r->size, r->space, r->bus_addr);\n}\n\nstatic void i2sbus_release_dev(struct device *dev)\n{\n\tstruct i2sbus_dev *i2sdev;\n\tint i;\n\n\ti2sdev = container_of(dev, struct i2sbus_dev, sound.ofdev.dev);\n\tiounmap(i2sdev->intfregs);\n\tiounmap(i2sdev->out.dbdma);\n\tiounmap(i2sdev->in.dbdma);\n\tfor (i = aoa_resource_i2smmio; i <= aoa_resource_rxdbdma; i++)\n\t\trelease_and_free_resource(i2sdev->allocated_resource[i]);\n\tfree_dbdma_descriptor_ring(i2sdev, &i2sdev->out.dbdma_ring);\n\tfree_dbdma_descriptor_ring(i2sdev, &i2sdev->in.dbdma_ring);\n\tfor (i = aoa_resource_i2smmio; i <= aoa_resource_rxdbdma; i++)\n\t\tfree_irq(i2sdev->interrupts[i], i2sdev);\n\ti2sbus_control_remove_dev(i2sdev->control, i2sdev);\n\tmutex_destroy(&i2sdev->lock);\n\tkfree(i2sdev);\n}\n\nstatic irqreturn_t i2sbus_bus_intr(int irq, void *devid)\n{\n\tstruct i2sbus_dev *dev = devid;\n\tu32 intreg;\n\n\tspin_lock(&dev->low_lock);\n\tintreg = in_le32(&dev->intfregs->intr_ctl);\n\n\t \n\tout_le32(&dev->intfregs->intr_ctl, intreg);\n\n\tspin_unlock(&dev->low_lock);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic int i2sbus_get_and_fixup_rsrc(struct device_node *np, int index,\n\t\t\t\t     int layout, struct resource *res)\n{\n\tstruct device_node *parent;\n\tint pindex, rc = -ENXIO;\n\tconst u32 *reg;\n\n\t \n\tif (layout != 76 && layout != 36)\n\t\treturn of_address_to_resource(np, index, res);\n\n\tparent = of_get_parent(np);\n\tpindex = (index == aoa_resource_i2smmio) ? 0 : 1;\n\trc = of_address_to_resource(parent, pindex, res);\n\tif (rc)\n\t\tgoto bail;\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (reg == NULL) {\n\t\trc = -ENXIO;\n\t\tgoto bail;\n\t}\n\tres->start += reg[index * 2];\n\tres->end = res->start + reg[index * 2 + 1] - 1;\n bail:\n\tof_node_put(parent);\n\treturn rc;\n}\n\n \n \nstatic int i2sbus_add_dev(struct macio_dev *macio,\n\t\t\t  struct i2sbus_control *control,\n\t\t\t  struct device_node *np)\n{\n\tstruct i2sbus_dev *dev;\n\tstruct device_node *child, *sound = NULL;\n\tstruct resource *r;\n\tint i, layout = 0, rlen, ok = force;\n\tchar node_name[6];\n\tstatic const char *rnames[] = { \"i2sbus: %pOFn (control)\",\n\t\t\t\t\t\"i2sbus: %pOFn (tx)\",\n\t\t\t\t\t\"i2sbus: %pOFn (rx)\" };\n\tstatic const irq_handler_t ints[] = {\n\t\ti2sbus_bus_intr,\n\t\ti2sbus_tx_intr,\n\t\ti2sbus_rx_intr\n\t};\n\n\tif (snprintf(node_name, sizeof(node_name), \"%pOFn\", np) != 5)\n\t\treturn 0;\n\tif (strncmp(node_name, \"i2s-\", 4))\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(struct i2sbus_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn 0;\n\n\ti = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_node_name_eq(child, \"sound\")) {\n\t\t\ti++;\n\t\t\tsound = child;\n\t\t}\n\t}\n\tif (i == 1) {\n\t\tconst u32 *id = of_get_property(sound, \"layout-id\", NULL);\n\n\t\tif (id) {\n\t\t\tlayout = *id;\n\t\t\tsnprintf(dev->sound.modalias, 32,\n\t\t\t\t \"sound-layout-%d\", layout);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tid = of_get_property(sound, \"device-id\", NULL);\n\t\t\t \n\t\t\tif (id && (*id == 22 || *id == 14 || *id == 35 ||\n\t\t\t\t   *id == 31 || *id == 44)) {\n\t\t\t\tsnprintf(dev->sound.modalias, 32,\n\t\t\t\t\t \"aoa-device-id-%d\", *id);\n\t\t\t\tok = 1;\n\t\t\t\tlayout = -1;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!ok) {\n\t\tkfree(dev);\n\t\treturn 0;\n\t}\n\n\tmutex_init(&dev->lock);\n\tspin_lock_init(&dev->low_lock);\n\tdev->sound.ofdev.archdata.dma_mask = macio->ofdev.archdata.dma_mask;\n\tdev->sound.ofdev.dev.of_node = np;\n\tdev->sound.ofdev.dev.dma_mask = &dev->sound.ofdev.archdata.dma_mask;\n\tdev->sound.ofdev.dev.parent = &macio->ofdev.dev;\n\tdev->sound.ofdev.dev.release = i2sbus_release_dev;\n\tdev->sound.attach_codec = i2sbus_attach_codec;\n\tdev->sound.detach_codec = i2sbus_detach_codec;\n\tdev->sound.pcmid = -1;\n\tdev->macio = macio;\n\tdev->control = control;\n\tdev->bus_number = node_name[4] - 'a';\n\tINIT_LIST_HEAD(&dev->sound.codec_list);\n\n\tfor (i = aoa_resource_i2smmio; i <= aoa_resource_rxdbdma; i++) {\n\t\tdev->interrupts[i] = -1;\n\t\tsnprintf(dev->rnames[i], sizeof(dev->rnames[i]),\n\t\t\t rnames[i], np);\n\t}\n\tfor (i = aoa_resource_i2smmio; i <= aoa_resource_rxdbdma; i++) {\n\t\tint irq = irq_of_parse_and_map(np, i);\n\t\tif (request_irq(irq, ints[i], 0, dev->rnames[i], dev))\n\t\t\tgoto err;\n\t\tdev->interrupts[i] = irq;\n\t}\n\n\n\t \n\tfor (i = aoa_resource_i2smmio; i <= aoa_resource_rxdbdma; i++) {\n\t\tif (i2sbus_get_and_fixup_rsrc(np,i,layout,&dev->resources[i]))\n\t\t\tgoto err;\n\t\t \n\t\tdev->allocated_resource[i] =\n\t\t\trequest_mem_region(dev->resources[i].start,\n\t\t\t\t\t   resource_size(&dev->resources[i]),\n\t\t\t\t\t   dev->rnames[i]);\n\t\tif (!dev->allocated_resource[i]) {\n\t\t\tprintk(KERN_ERR \"i2sbus: failed to claim resource %d!\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tr = &dev->resources[aoa_resource_i2smmio];\n\trlen = resource_size(r);\n\tif (rlen < sizeof(struct i2s_interface_regs))\n\t\tgoto err;\n\tdev->intfregs = ioremap(r->start, rlen);\n\n\tr = &dev->resources[aoa_resource_txdbdma];\n\trlen = resource_size(r);\n\tif (rlen < sizeof(struct dbdma_regs))\n\t\tgoto err;\n\tdev->out.dbdma = ioremap(r->start, rlen);\n\n\tr = &dev->resources[aoa_resource_rxdbdma];\n\trlen = resource_size(r);\n\tif (rlen < sizeof(struct dbdma_regs))\n\t\tgoto err;\n\tdev->in.dbdma = ioremap(r->start, rlen);\n\n\tif (!dev->intfregs || !dev->out.dbdma || !dev->in.dbdma)\n\t\tgoto err;\n\n\tif (alloc_dbdma_descriptor_ring(dev, &dev->out.dbdma_ring,\n\t\t\t\t\tMAX_DBDMA_COMMANDS))\n\t\tgoto err;\n\tif (alloc_dbdma_descriptor_ring(dev, &dev->in.dbdma_ring,\n\t\t\t\t\tMAX_DBDMA_COMMANDS))\n\t\tgoto err;\n\n\tif (i2sbus_control_add_dev(dev->control, dev)) {\n\t\tprintk(KERN_ERR \"i2sbus: control layer didn't like bus\\n\");\n\t\tgoto err;\n\t}\n\n\tif (soundbus_add_one(&dev->sound)) {\n\t\tprintk(KERN_DEBUG \"i2sbus: device registration error!\\n\");\n\t\tif (dev->sound.ofdev.dev.kobj.state_initialized) {\n\t\t\tsoundbus_dev_put(&dev->sound);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto err;\n\t}\n\n\t \n\ti2sbus_control_cell(dev->control, dev, 1);\n\ti2sbus_control_enable(dev->control, dev);\n\ti2sbus_control_clock(dev->control, dev, 1);\n\n\treturn 1;\n err:\n\tfor (i=0;i<3;i++)\n\t\tif (dev->interrupts[i] != -1)\n\t\t\tfree_irq(dev->interrupts[i], dev);\n\tfree_dbdma_descriptor_ring(dev, &dev->out.dbdma_ring);\n\tfree_dbdma_descriptor_ring(dev, &dev->in.dbdma_ring);\n\tiounmap(dev->intfregs);\n\tiounmap(dev->out.dbdma);\n\tiounmap(dev->in.dbdma);\n\tfor (i=0;i<3;i++)\n\t\trelease_and_free_resource(dev->allocated_resource[i]);\n\tmutex_destroy(&dev->lock);\n\tkfree(dev);\n\treturn 0;\n}\n\nstatic int i2sbus_probe(struct macio_dev* dev, const struct of_device_id *match)\n{\n\tstruct device_node *np = NULL;\n\tint got = 0, err;\n\tstruct i2sbus_control *control = NULL;\n\n\terr = i2sbus_control_init(dev, &control);\n\tif (err)\n\t\treturn err;\n\tif (!control) {\n\t\tprintk(KERN_ERR \"i2sbus_control_init API breakage\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twhile ((np = of_get_next_child(dev->ofdev.dev.of_node, np))) {\n\t\tif (of_device_is_compatible(np, \"i2sbus\") ||\n\t\t    of_device_is_compatible(np, \"i2s-modem\")) {\n\t\t\tgot += i2sbus_add_dev(dev, control, np);\n\t\t}\n\t}\n\n\tif (!got) {\n\t\t \n\t\ti2sbus_control_destroy(control);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_set_drvdata(&dev->ofdev.dev, control);\n\n\treturn 0;\n}\n\nstatic int i2sbus_remove(struct macio_dev* dev)\n{\n\tstruct i2sbus_control *control = dev_get_drvdata(&dev->ofdev.dev);\n\tstruct i2sbus_dev *i2sdev, *tmp;\n\n\tlist_for_each_entry_safe(i2sdev, tmp, &control->list, item)\n\t\tsoundbus_remove_one(&i2sdev->sound);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int i2sbus_suspend(struct macio_dev* dev, pm_message_t state)\n{\n\tstruct i2sbus_control *control = dev_get_drvdata(&dev->ofdev.dev);\n\tstruct codec_info_item *cii;\n\tstruct i2sbus_dev* i2sdev;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(i2sdev, &control->list, item) {\n\t\t \n\t\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\t\terr = 0;\n\t\t\tif (cii->codec->suspend)\n\t\t\t\terr = cii->codec->suspend(cii, state);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\n\t\t \n\t\ti2sbus_wait_for_stop_both(i2sdev);\n\t}\n\n\treturn ret;\n}\n\nstatic int i2sbus_resume(struct macio_dev* dev)\n{\n\tstruct i2sbus_control *control = dev_get_drvdata(&dev->ofdev.dev);\n\tstruct codec_info_item *cii;\n\tstruct i2sbus_dev* i2sdev;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(i2sdev, &control->list, item) {\n\t\t \n\t\ti2sbus_pcm_prepare_both(i2sdev);\n\n\t\t \n\t\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\t\terr = 0;\n\t\t\tif (cii->codec->resume)\n\t\t\t\terr = cii->codec->resume(cii);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#endif  \n\nstatic int i2sbus_shutdown(struct macio_dev* dev)\n{\n\treturn 0;\n}\n\nstatic struct macio_driver i2sbus_drv = {\n\t.driver = {\n\t\t.name = \"soundbus-i2s\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = i2sbus_match,\n\t},\n\t.probe = i2sbus_probe,\n\t.remove = i2sbus_remove,\n#ifdef CONFIG_PM\n\t.suspend = i2sbus_suspend,\n\t.resume = i2sbus_resume,\n#endif\n\t.shutdown = i2sbus_shutdown,\n};\n\nstatic int __init soundbus_i2sbus_init(void)\n{\n\treturn macio_register_driver(&i2sbus_drv);\n}\n\nstatic void __exit soundbus_i2sbus_exit(void)\n{\n\tmacio_unregister_driver(&i2sbus_drv);\n}\n\nmodule_init(soundbus_i2sbus_init);\nmodule_exit(soundbus_i2sbus_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}