{
  "module_name": "pcm.c",
  "hash_id": "aa1e66fca1c23e0407d92c2f0d605683f6dbe845b4cada24dbe495661610f635",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/soundbus/i2sbus/pcm.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <asm/macio.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include \"../soundbus.h\"\n#include \"i2sbus.h\"\n\nstatic inline void get_pcm_info(struct i2sbus_dev *i2sdev, int in,\n\t\t\t\tstruct pcm_info **pi, struct pcm_info **other)\n{\n\tif (in) {\n\t\tif (pi)\n\t\t\t*pi = &i2sdev->in;\n\t\tif (other)\n\t\t\t*other = &i2sdev->out;\n\t} else {\n\t\tif (pi)\n\t\t\t*pi = &i2sdev->out;\n\t\tif (other)\n\t\t\t*other = &i2sdev->in;\n\t}\n}\n\nstatic int clock_and_divisors(int mclk, int sclk, int rate, int *out)\n{\n\t \n\tif (mclk % sclk)\n\t\treturn -1;\n\t \n\tif (i2s_sf_sclkdiv(mclk / sclk, out))\n\t\treturn -1;\n\n\tif (I2S_CLOCK_SPEED_18MHz % (rate * mclk) == 0) {\n\t\tif (!i2s_sf_mclkdiv(I2S_CLOCK_SPEED_18MHz / (rate * mclk), out)) {\n\t\t\t*out |= I2S_SF_CLOCK_SOURCE_18MHz;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (I2S_CLOCK_SPEED_45MHz % (rate * mclk) == 0) {\n\t\tif (!i2s_sf_mclkdiv(I2S_CLOCK_SPEED_45MHz / (rate * mclk), out)) {\n\t\t\t*out |= I2S_SF_CLOCK_SOURCE_45MHz;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (I2S_CLOCK_SPEED_49MHz % (rate * mclk) == 0) {\n\t\tif (!i2s_sf_mclkdiv(I2S_CLOCK_SPEED_49MHz / (rate * mclk), out)) {\n\t\t\t*out |= I2S_SF_CLOCK_SOURCE_49MHz;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\n#define CHECK_RATE(rate)\t\t\t\t\t\t\\\n\tdo { if (rates & SNDRV_PCM_RATE_ ##rate) {\t\t\t\\\n\t\tint dummy;\t\t\t\t\t\t\\\n\t\tif (clock_and_divisors(sysclock_factor,\t\t\t\\\n\t\t\t\t       bus_factor, rate, &dummy))\t\\\n\t\t\trates &= ~SNDRV_PCM_RATE_ ##rate;\t\t\\\n\t} } while (0)\n\nstatic int i2sbus_pcm_open(struct i2sbus_dev *i2sdev, int in)\n{\n\tstruct pcm_info *pi, *other;\n\tstruct soundbus_dev *sdev;\n\tint masks_inited = 0, err;\n\tstruct codec_info_item *cii, *rev;\n\tstruct snd_pcm_hardware *hw;\n\tu64 formats = 0;\n\tunsigned int rates = 0;\n\tstruct transfer_info v;\n\tint result = 0;\n\tint bus_factor = 0, sysclock_factor = 0;\n\tint found_this;\n\n\tmutex_lock(&i2sdev->lock);\n\n\tget_pcm_info(i2sdev, in, &pi, &other);\n\n\thw = &pi->substream->runtime->hw;\n\tsdev = &i2sdev->sound;\n\n\tif (pi->active) {\n\t\t \n\t\tresult = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tlist_for_each_entry(cii, &sdev->codec_list, list) {\n\t\tstruct transfer_info *ti = cii->codec->transfers;\n\t\tbus_factor = cii->codec->bus_factor;\n\t\tsysclock_factor = cii->codec->sysclock_factor;\n\t\twhile (ti->formats && ti->rates) {\n\t\t\tv = *ti;\n\t\t\tif (ti->transfer_in == in\n\t\t\t    && cii->codec->usable(cii, ti, &v)) {\n\t\t\t\tif (masks_inited) {\n\t\t\t\t\tformats &= v.formats;\n\t\t\t\t\trates &= v.rates;\n\t\t\t\t} else {\n\t\t\t\t\tformats = v.formats;\n\t\t\t\t\trates = v.rates;\n\t\t\t\t\tmasks_inited = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tti++;\n\t\t}\n\t}\n\tif (!masks_inited || !bus_factor || !sysclock_factor) {\n\t\tresult = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\t \n\thw->info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t   SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_RESUME |\n\t\t   SNDRV_PCM_INFO_JOINT_DUPLEX;\n\n\tCHECK_RATE(5512);\n\tCHECK_RATE(8000);\n\tCHECK_RATE(11025);\n\tCHECK_RATE(16000);\n\tCHECK_RATE(22050);\n\tCHECK_RATE(32000);\n\tCHECK_RATE(44100);\n\tCHECK_RATE(48000);\n\tCHECK_RATE(64000);\n\tCHECK_RATE(88200);\n\tCHECK_RATE(96000);\n\tCHECK_RATE(176400);\n\tCHECK_RATE(192000);\n\thw->rates = rates;\n\n\t \n\tif (formats & SNDRV_PCM_FMTBIT_S24_BE)\n\t\tformats |= SNDRV_PCM_FMTBIT_S32_BE;\n\tif (formats & SNDRV_PCM_FMTBIT_U24_BE)\n\t\tformats |= SNDRV_PCM_FMTBIT_U32_BE;\n\t \n\thw->formats = formats & (SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t\t SNDRV_PCM_FMTBIT_U16_BE |\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_BE |\n\t\t\t\t SNDRV_PCM_FMTBIT_U32_BE);\n\n\t \n\thw->rate_min = 5512;\n\thw->rate_max = 192000;\n\t \n\tif (other->active) {\n\t\t \n\t\thw->formats &= pcm_format_to_bits(i2sdev->format);\n\t\t \n\t\thw->rate_min = i2sdev->rate;\n\t\thw->rate_max = i2sdev->rate;\n\t}\n\n\thw->channels_min = 2;\n\thw->channels_max = 2;\n\t \n\thw->buffer_bytes_max = 131072;\n\thw->period_bytes_min = 256;\n\thw->period_bytes_max = 16384;\n\thw->periods_min = 3;\n\thw->periods_max = MAX_DBDMA_COMMANDS;\n\terr = snd_pcm_hw_constraint_integer(pi->substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0) {\n\t\tresult = err;\n\t\tgoto out_unlock;\n\t}\n\tlist_for_each_entry(cii, &sdev->codec_list, list) {\n\t\tif (cii->codec->open) {\n\t\t\terr = cii->codec->open(cii, pi->substream);\n\t\t\tif (err) {\n\t\t\t\tresult = err;\n\t\t\t\t \n\t\t\t\tfound_this = 0;\n\t\t\t\tlist_for_each_entry_reverse(rev,\n\t\t\t\t    &sdev->codec_list, list) {\n\t\t\t\t\tif (found_this && rev->codec->close) {\n\t\t\t\t\t\trev->codec->close(rev,\n\t\t\t\t\t\t\t\tpi->substream);\n\t\t\t\t\t}\n\t\t\t\t\tif (rev == cii)\n\t\t\t\t\t\tfound_this = 1;\n\t\t\t\t}\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n out_unlock:\n\tmutex_unlock(&i2sdev->lock);\n\treturn result;\n}\n\n#undef CHECK_RATE\n\nstatic int i2sbus_pcm_close(struct i2sbus_dev *i2sdev, int in)\n{\n\tstruct codec_info_item *cii;\n\tstruct pcm_info *pi;\n\tint err = 0, tmp;\n\n\tmutex_lock(&i2sdev->lock);\n\n\tget_pcm_info(i2sdev, in, &pi, NULL);\n\n\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\tif (cii->codec->close) {\n\t\t\ttmp = cii->codec->close(cii, pi->substream);\n\t\t\tif (tmp)\n\t\t\t\terr = tmp;\n\t\t}\n\t}\n\n\tpi->substream = NULL;\n\tpi->active = 0;\n\tmutex_unlock(&i2sdev->lock);\n\treturn err;\n}\n\nstatic void i2sbus_wait_for_stop(struct i2sbus_dev *i2sdev,\n\t\t\t\t struct pcm_info *pi)\n{\n\tunsigned long flags;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tlong timeout;\n\n\tspin_lock_irqsave(&i2sdev->low_lock, flags);\n\tif (pi->dbdma_ring.stopping) {\n\t\tpi->stop_completion = &done;\n\t\tspin_unlock_irqrestore(&i2sdev->low_lock, flags);\n\t\ttimeout = wait_for_completion_timeout(&done, HZ);\n\t\tspin_lock_irqsave(&i2sdev->low_lock, flags);\n\t\tpi->stop_completion = NULL;\n\t\tif (timeout == 0) {\n\t\t\t \n\t\t\tprintk(KERN_ERR \"i2sbus_wait_for_stop: timed out\\n\");\n\t\t\t \n\t\t\tout_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);\n\t\t\tpi->dbdma_ring.stopping = 0;\n\t\t\ttimeout = 10;\n\t\t\twhile (in_le32(&pi->dbdma->status) & ACTIVE) {\n\t\t\t\tif (--timeout <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&i2sdev->low_lock, flags);\n}\n\n#ifdef CONFIG_PM\nvoid i2sbus_wait_for_stop_both(struct i2sbus_dev *i2sdev)\n{\n\tstruct pcm_info *pi;\n\n\tget_pcm_info(i2sdev, 0, &pi, NULL);\n\ti2sbus_wait_for_stop(i2sdev, pi);\n\tget_pcm_info(i2sdev, 1, &pi, NULL);\n\ti2sbus_wait_for_stop(i2sdev, pi);\n}\n#endif\n\nstatic inline int i2sbus_hw_free(struct snd_pcm_substream *substream, int in)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\tstruct pcm_info *pi;\n\n\tget_pcm_info(i2sdev, in, &pi, NULL);\n\tif (pi->dbdma_ring.stopping)\n\t\ti2sbus_wait_for_stop(i2sdev, pi);\n\treturn 0;\n}\n\nstatic int i2sbus_playback_hw_free(struct snd_pcm_substream *substream)\n{\n\treturn i2sbus_hw_free(substream, 0);\n}\n\nstatic int i2sbus_record_hw_free(struct snd_pcm_substream *substream)\n{\n\treturn i2sbus_hw_free(substream, 1);\n}\n\nstatic int i2sbus_pcm_prepare(struct i2sbus_dev *i2sdev, int in)\n{\n\t \n\tstruct snd_pcm_runtime *runtime;\n\tstruct dbdma_cmd *command;\n\tint i, periodsize, nperiods;\n\tdma_addr_t offset;\n\tstruct bus_info bi;\n\tstruct codec_info_item *cii;\n\tint sfr = 0;\t\t \n\tint dws = 0;\t\t \n\tint input_16bit;\n\tstruct pcm_info *pi, *other;\n\tint cnt;\n\tint result = 0;\n\tunsigned int cmd, stopaddr;\n\n\tmutex_lock(&i2sdev->lock);\n\n\tget_pcm_info(i2sdev, in, &pi, &other);\n\n\tif (pi->dbdma_ring.running) {\n\t\tresult = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (pi->dbdma_ring.stopping)\n\t\ti2sbus_wait_for_stop(i2sdev, pi);\n\n\tif (!pi->substream || !pi->substream->runtime) {\n\t\tresult = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\truntime = pi->substream->runtime;\n\tpi->active = 1;\n\tif (other->active &&\n\t    ((i2sdev->format != runtime->format)\n\t     || (i2sdev->rate != runtime->rate))) {\n\t\tresult = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\ti2sdev->format = runtime->format;\n\ti2sdev->rate = runtime->rate;\n\n\tperiodsize = snd_pcm_lib_period_bytes(pi->substream);\n\tnperiods = pi->substream->runtime->periods;\n\tpi->current_period = 0;\n\n\t \n\tcommand = pi->dbdma_ring.cmds;\n\tmemset(command, 0, (nperiods + 2) * sizeof(struct dbdma_cmd));\n\n\t \n\t \n\toffset = runtime->dma_addr;\n\tcmd = (in? INPUT_MORE: OUTPUT_MORE) | BR_IFSET | INTR_ALWAYS;\n\tstopaddr = pi->dbdma_ring.bus_cmd_start +\n\t\t(nperiods + 1) * sizeof(struct dbdma_cmd);\n\tfor (i = 0; i < nperiods; i++, command++, offset += periodsize) {\n\t\tcommand->command = cpu_to_le16(cmd);\n\t\tcommand->cmd_dep = cpu_to_le32(stopaddr);\n\t\tcommand->phy_addr = cpu_to_le32(offset);\n\t\tcommand->req_count = cpu_to_le16(periodsize);\n\t}\n\n\t \n\tcommand->command = cpu_to_le16(DBDMA_NOP | BR_ALWAYS);\n\tcommand->cmd_dep = cpu_to_le32(pi->dbdma_ring.bus_cmd_start);\n\tcommand++;\n\n\t \n\tcommand->command = cpu_to_le16(DBDMA_STOP);\n\n\t \n\tswitch (runtime->format) {\n\t \n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\tcase SNDRV_PCM_FORMAT_U16_BE:\n\t\t \n\t\tbi.bus_factor = 0;\n\t\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\t\tbi.bus_factor = cii->codec->bus_factor;\n\t\t\tbreak;\n\t\t}\n\t\tif (!bi.bus_factor) {\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tinput_16bit = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_BE:\n\tcase SNDRV_PCM_FORMAT_U32_BE:\n\t\t \n\t\tbi.bus_factor = 64;\n\t\tinput_16bit = 0;\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\t \n\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\tbi.sysclock_factor = cii->codec->sysclock_factor;\n\t\tbreak;\n\t}\n\n\tif (clock_and_divisors(bi.sysclock_factor,\n\t\t\t       bi.bus_factor,\n\t\t\t       runtime->rate,\n\t\t\t       &sfr) < 0) {\n\t\tresult = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tswitch (bi.bus_factor) {\n\tcase 32:\n\t\tsfr |= I2S_SF_SERIAL_FORMAT_I2S_32X;\n\t\tbreak;\n\tcase 64:\n\t\tsfr |= I2S_SF_SERIAL_FORMAT_I2S_64X;\n\t\tbreak;\n\t}\n\t \n\tsfr |= I2S_SF_SCLK_MASTER;\n\n\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list) {\n\t\tint err = 0;\n\t\tif (cii->codec->prepare)\n\t\t\terr = cii->codec->prepare(cii, &bi, pi->substream);\n\t\tif (err) {\n\t\t\tresult = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\t \n\tif (input_16bit)\n\t\tdws =\t(2 << I2S_DWS_NUM_CHANNELS_IN_SHIFT) |\n\t\t\t(2 << I2S_DWS_NUM_CHANNELS_OUT_SHIFT) |\n\t\t\tI2S_DWS_DATA_IN_16BIT | I2S_DWS_DATA_OUT_16BIT;\n\telse\n\t\tdws =\t(2 << I2S_DWS_NUM_CHANNELS_IN_SHIFT) |\n\t\t\t(2 << I2S_DWS_NUM_CHANNELS_OUT_SHIFT) |\n\t\t\tI2S_DWS_DATA_IN_24BIT | I2S_DWS_DATA_OUT_24BIT;\n\n\t \n\t \n\tif (in_le32(&i2sdev->intfregs->serial_format) == sfr\n\t && in_le32(&i2sdev->intfregs->data_word_sizes) == dws)\n\t\tgoto out_unlock;\n\n\t \n\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list)\n\t\tif (cii->codec->switch_clock)\n\t\t\tcii->codec->switch_clock(cii, CLOCK_SWITCH_PREPARE_SLAVE);\n\n\ti2sbus_control_enable(i2sdev->control, i2sdev);\n\ti2sbus_control_cell(i2sdev->control, i2sdev, 1);\n\n\tout_le32(&i2sdev->intfregs->intr_ctl, I2S_PENDING_CLOCKS_STOPPED);\n\n\ti2sbus_control_clock(i2sdev->control, i2sdev, 0);\n\n\tmsleep(1);\n\n\t \n\tcnt = 100;\n\twhile (cnt-- &&\n\t    !(in_le32(&i2sdev->intfregs->intr_ctl) & I2S_PENDING_CLOCKS_STOPPED)) {\n\t\tmsleep(5);\n\t}\n\tout_le32(&i2sdev->intfregs->intr_ctl, I2S_PENDING_CLOCKS_STOPPED);\n\n\t \n\tout_le32(&i2sdev->intfregs->serial_format, sfr);\n\tout_le32(&i2sdev->intfregs->data_word_sizes, dws);\n\n        i2sbus_control_enable(i2sdev->control, i2sdev);\n        i2sbus_control_cell(i2sdev->control, i2sdev, 1);\n        i2sbus_control_clock(i2sdev->control, i2sdev, 1);\n\tmsleep(1);\n\n\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list)\n\t\tif (cii->codec->switch_clock)\n\t\t\tcii->codec->switch_clock(cii, CLOCK_SWITCH_SLAVE);\n\n out_unlock:\n\tmutex_unlock(&i2sdev->lock);\n\treturn result;\n}\n\n#ifdef CONFIG_PM\nvoid i2sbus_pcm_prepare_both(struct i2sbus_dev *i2sdev)\n{\n\ti2sbus_pcm_prepare(i2sdev, 0);\n\ti2sbus_pcm_prepare(i2sdev, 1);\n}\n#endif\n\nstatic int i2sbus_pcm_trigger(struct i2sbus_dev *i2sdev, int in, int cmd)\n{\n\tstruct codec_info_item *cii;\n\tstruct pcm_info *pi;\n\tint result = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2sdev->low_lock, flags);\n\n\tget_pcm_info(i2sdev, in, &pi, NULL);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (pi->dbdma_ring.running) {\n\t\t\tresult = -EALREADY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list)\n\t\t\tif (cii->codec->start)\n\t\t\t\tcii->codec->start(cii, pi->substream);\n\t\tpi->dbdma_ring.running = 1;\n\n\t\tif (pi->dbdma_ring.stopping) {\n\t\t\t \n\t\t\tout_le32(&pi->dbdma->control, 1 << 16);\n\t\t\tif (in_le32(&pi->dbdma->status) & ACTIVE) {\n\t\t\t\t \n\t\t\t\tudelay(10);\n\t\t\t\tif (in_le32(&pi->dbdma->status) & ACTIVE) {\n\t\t\t\t\tpi->dbdma_ring.stopping = 0;\n\t\t\t\t\tgoto out_unlock;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tout_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);\n\n\t\t \n\t\tout_le32(&pi->dbdma->br_sel, (1 << 16) | 1);\n\n\t\t \n\t\tout_le32(&pi->dbdma->cmdptr, pi->dbdma_ring.bus_cmd_start);\n\n\t\t \n\t\tpi->current_period = 0;\n\t\tpi->frame_count = in_le32(&i2sdev->intfregs->frame_count);\n\n\t\t \n\t\tout_le32(&pi->dbdma->control, (RUN << 16) | RUN);\n\n\t\t \n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (!pi->dbdma_ring.running) {\n\t\t\tresult = -EALREADY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tpi->dbdma_ring.running = 0;\n\n\t\t \n\t\tout_le32(&pi->dbdma->control, (1 << 16) | 1);\n\t\tpi->dbdma_ring.stopping = 1;\n\n\t\tlist_for_each_entry(cii, &i2sdev->sound.codec_list, list)\n\t\t\tif (cii->codec->stop)\n\t\t\t\tcii->codec->stop(cii, pi->substream);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n out_unlock:\n\tspin_unlock_irqrestore(&i2sdev->low_lock, flags);\n\treturn result;\n}\n\nstatic snd_pcm_uframes_t i2sbus_pcm_pointer(struct i2sbus_dev *i2sdev, int in)\n{\n\tstruct pcm_info *pi;\n\tu32 fc;\n\n\tget_pcm_info(i2sdev, in, &pi, NULL);\n\n\tfc = in_le32(&i2sdev->intfregs->frame_count);\n\tfc = fc - pi->frame_count;\n\n\tif (fc >= pi->substream->runtime->buffer_size)\n\t\tfc %= pi->substream->runtime->buffer_size;\n\treturn fc;\n}\n\nstatic inline void handle_interrupt(struct i2sbus_dev *i2sdev, int in)\n{\n\tstruct pcm_info *pi;\n\tu32 fc, nframes;\n\tu32 status;\n\tint timeout, i;\n\tint dma_stopped = 0;\n\tstruct snd_pcm_runtime *runtime;\n\n\tspin_lock(&i2sdev->low_lock);\n\tget_pcm_info(i2sdev, in, &pi, NULL);\n\tif (!pi->dbdma_ring.running && !pi->dbdma_ring.stopping)\n\t\tgoto out_unlock;\n\n\ti = pi->current_period;\n\truntime = pi->substream->runtime;\n\twhile (pi->dbdma_ring.cmds[i].xfer_status) {\n\t\tif (le16_to_cpu(pi->dbdma_ring.cmds[i].xfer_status) & BT)\n\t\t\t \n\t\t\tdma_stopped = 1;\n\t\tpi->dbdma_ring.cmds[i].xfer_status = 0;\n\n\t\tif (++i >= runtime->periods) {\n\t\t\ti = 0;\n\t\t\tpi->frame_count += runtime->buffer_size;\n\t\t}\n\t\tpi->current_period = i;\n\n\t\t \n\t\tfc = in_le32(&i2sdev->intfregs->frame_count);\n\t\tnframes = i * runtime->period_size;\n\t\tif (fc < pi->frame_count + nframes)\n\t\t\tpi->frame_count = fc - nframes;\n\t}\n\n\tif (dma_stopped) {\n\t\ttimeout = 1000;\n\t\tfor (;;) {\n\t\t\tstatus = in_le32(&pi->dbdma->status);\n\t\t\tif (!(status & ACTIVE) && (!in || (status & 0x80)))\n\t\t\t\tbreak;\n\t\t\tif (--timeout <= 0) {\n\t\t\t\tprintk(KERN_ERR \"i2sbus: timed out \"\n\t\t\t\t       \"waiting for DMA to stop!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\n\t\t \n\t\tout_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);\n\n\t\tpi->dbdma_ring.stopping = 0;\n\t\tif (pi->stop_completion)\n\t\t\tcomplete(pi->stop_completion);\n\t}\n\n\tif (!pi->dbdma_ring.running)\n\t\tgoto out_unlock;\n\tspin_unlock(&i2sdev->low_lock);\n\t \n\tsnd_pcm_period_elapsed(pi->substream);\n\treturn;\n\n out_unlock:\n\tspin_unlock(&i2sdev->low_lock);\n}\n\nirqreturn_t i2sbus_tx_intr(int irq, void *devid)\n{\n\thandle_interrupt((struct i2sbus_dev *)devid, 0);\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t i2sbus_rx_intr(int irq, void *devid)\n{\n\thandle_interrupt((struct i2sbus_dev *)devid, 1);\n\treturn IRQ_HANDLED;\n}\n\nstatic int i2sbus_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\ti2sdev->out.substream = substream;\n\treturn i2sbus_pcm_open(i2sdev, 0);\n}\n\nstatic int i2sbus_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\tint err;\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->out.substream != substream)\n\t\treturn -EINVAL;\n\terr = i2sbus_pcm_close(i2sdev, 0);\n\tif (!err)\n\t\ti2sdev->out.substream = NULL;\n\treturn err;\n}\n\nstatic int i2sbus_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->out.substream != substream)\n\t\treturn -EINVAL;\n\treturn i2sbus_pcm_prepare(i2sdev, 0);\n}\n\nstatic int i2sbus_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->out.substream != substream)\n\t\treturn -EINVAL;\n\treturn i2sbus_pcm_trigger(i2sdev, 0, cmd);\n}\n\nstatic snd_pcm_uframes_t i2sbus_playback_pointer(struct snd_pcm_substream\n\t\t\t\t\t\t *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->out.substream != substream)\n\t\treturn 0;\n\treturn i2sbus_pcm_pointer(i2sdev, 0);\n}\n\nstatic const struct snd_pcm_ops i2sbus_playback_ops = {\n\t.open =\t\ti2sbus_playback_open,\n\t.close =\ti2sbus_playback_close,\n\t.hw_free =\ti2sbus_playback_hw_free,\n\t.prepare =\ti2sbus_playback_prepare,\n\t.trigger =\ti2sbus_playback_trigger,\n\t.pointer =\ti2sbus_playback_pointer,\n};\n\nstatic int i2sbus_record_open(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\ti2sdev->in.substream = substream;\n\treturn i2sbus_pcm_open(i2sdev, 1);\n}\n\nstatic int i2sbus_record_close(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\tint err;\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->in.substream != substream)\n\t\treturn -EINVAL;\n\terr = i2sbus_pcm_close(i2sdev, 1);\n\tif (!err)\n\t\ti2sdev->in.substream = NULL;\n\treturn err;\n}\n\nstatic int i2sbus_record_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->in.substream != substream)\n\t\treturn -EINVAL;\n\treturn i2sbus_pcm_prepare(i2sdev, 1);\n}\n\nstatic int i2sbus_record_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->in.substream != substream)\n\t\treturn -EINVAL;\n\treturn i2sbus_pcm_trigger(i2sdev, 1, cmd);\n}\n\nstatic snd_pcm_uframes_t i2sbus_record_pointer(struct snd_pcm_substream\n\t\t\t\t\t       *substream)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);\n\n\tif (!i2sdev)\n\t\treturn -EINVAL;\n\tif (i2sdev->in.substream != substream)\n\t\treturn 0;\n\treturn i2sbus_pcm_pointer(i2sdev, 1);\n}\n\nstatic const struct snd_pcm_ops i2sbus_record_ops = {\n\t.open =\t\ti2sbus_record_open,\n\t.close =\ti2sbus_record_close,\n\t.hw_free =\ti2sbus_record_hw_free,\n\t.prepare =\ti2sbus_record_prepare,\n\t.trigger =\ti2sbus_record_trigger,\n\t.pointer =\ti2sbus_record_pointer,\n};\n\nstatic void i2sbus_private_free(struct snd_pcm *pcm)\n{\n\tstruct i2sbus_dev *i2sdev = snd_pcm_chip(pcm);\n\tstruct codec_info_item *p, *tmp;\n\n\ti2sdev->sound.pcm = NULL;\n\ti2sdev->out.created = 0;\n\ti2sdev->in.created = 0;\n\tlist_for_each_entry_safe(p, tmp, &i2sdev->sound.codec_list, list) {\n\t\tprintk(KERN_ERR \"i2sbus: a codec didn't unregister!\\n\");\n\t\tlist_del(&p->list);\n\t\tmodule_put(p->codec->owner);\n\t\tkfree(p);\n\t}\n\tsoundbus_dev_put(&i2sdev->sound);\n\tmodule_put(THIS_MODULE);\n}\n\nint\ni2sbus_attach_codec(struct soundbus_dev *dev, struct snd_card *card,\n\t\t    struct codec_info *ci, void *data)\n{\n\tint err, in = 0, out = 0;\n\tstruct transfer_info *tmp;\n\tstruct i2sbus_dev *i2sdev = soundbus_dev_to_i2sbus_dev(dev);\n\tstruct codec_info_item *cii;\n\n\tif (!dev->pcmname || dev->pcmid == -1) {\n\t\tprintk(KERN_ERR \"i2sbus: pcm name and id must be set!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(cii, &dev->codec_list, list) {\n\t\tif (cii->codec_data == data)\n\t\t\treturn -EALREADY;\n\t}\n\n\tif (!ci->transfers || !ci->transfers->formats\n\t    || !ci->transfers->rates || !ci->usable)\n\t\treturn -EINVAL;\n\n\t \n\tif (ci->bus_factor != 32 && ci->bus_factor != 64)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(cii, &dev->codec_list, list) {\n\t\tif (cii->codec->sysclock_factor != ci->sysclock_factor) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"cannot yet handle multiple different sysclocks!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (cii->codec->bus_factor != ci->bus_factor) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"cannot yet handle multiple different bus clocks!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttmp = ci->transfers;\n\twhile (tmp->formats && tmp->rates) {\n\t\tif (tmp->transfer_in)\n\t\t\tin = 1;\n\t\telse\n\t\t\tout = 1;\n\t\ttmp++;\n\t}\n\n\tcii = kzalloc(sizeof(struct codec_info_item), GFP_KERNEL);\n\tif (!cii)\n\t\treturn -ENOMEM;\n\n\t \n\tcii->sdev = soundbus_dev_get(dev);\n\tcii->codec = ci;\n\tcii->codec_data = data;\n\n\tif (!cii->sdev) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"i2sbus: failed to get soundbus dev reference\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_free_cii;\n\t}\n\n\tif (!try_module_get(THIS_MODULE)) {\n\t\tprintk(KERN_DEBUG \"i2sbus: failed to get module reference!\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out_put_sdev;\n\t}\n\n\tif (!try_module_get(ci->owner)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"i2sbus: failed to get module reference to codec owner!\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out_put_this_module;\n\t}\n\n\tif (!dev->pcm) {\n\t\terr = snd_pcm_new(card, dev->pcmname, dev->pcmid, 0, 0,\n\t\t\t\t  &dev->pcm);\n\t\tif (err) {\n\t\t\tprintk(KERN_DEBUG \"i2sbus: failed to create pcm\\n\");\n\t\t\tgoto out_put_ci_module;\n\t\t}\n\t}\n\n\t \n\tout = in = 1;\n\n\tif (!i2sdev->out.created && out) {\n\t\tif (dev->pcm->card != card) {\n\t\t\t \n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Can't attach same bus to different cards!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_ci_module;\n\t\t}\n\t\terr = snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK, 1);\n\t\tif (err)\n\t\t\tgoto out_put_ci_module;\n\t\tsnd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t&i2sbus_playback_ops);\n\t\tdev->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].dev->parent =\n\t\t\t&dev->ofdev.dev;\n\t\ti2sdev->out.created = 1;\n\t}\n\n\tif (!i2sdev->in.created && in) {\n\t\tif (dev->pcm->card != card) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Can't attach same bus to different cards!\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_ci_module;\n\t\t}\n\t\terr = snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_CAPTURE, 1);\n\t\tif (err)\n\t\t\tgoto out_put_ci_module;\n\t\tsnd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t&i2sbus_record_ops);\n\t\tdev->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].dev->parent =\n\t\t\t&dev->ofdev.dev;\n\t\ti2sdev->in.created = 1;\n\t}\n\n\t \n\terr = snd_device_register(card, dev->pcm);\n\tif (err) {\n\t\tprintk(KERN_ERR \"i2sbus: error registering new pcm\\n\");\n\t\tgoto out_put_ci_module;\n\t}\n\t \n\tlist_add(&cii->list, &dev->codec_list);\n\n\tdev->pcm->private_data = i2sdev;\n\tdev->pcm->private_free = i2sbus_private_free;\n\n\t \n\tsnd_pcm_set_managed_buffer_all(\n\t\tdev->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t&macio_get_pci_dev(i2sdev->macio)->dev,\n\t\t64 * 1024, 64 * 1024);\n\n\treturn 0;\n out_put_ci_module:\n\tmodule_put(ci->owner);\n out_put_this_module:\n\tmodule_put(THIS_MODULE);\n out_put_sdev:\n\tsoundbus_dev_put(dev);\n out_free_cii:\n\tkfree(cii);\n\treturn err;\n}\n\nvoid i2sbus_detach_codec(struct soundbus_dev *dev, void *data)\n{\n\tstruct codec_info_item *cii = NULL, *i;\n\n\tlist_for_each_entry(i, &dev->codec_list, list) {\n\t\tif (i->codec_data == data) {\n\t\t\tcii = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cii) {\n\t\tlist_del(&cii->list);\n\t\tmodule_put(cii->codec->owner);\n\t\tkfree(cii);\n\t}\n\t \n\tif (list_empty(&dev->codec_list) && dev->pcm) {\n\t\t \n\t\tsnd_device_free(dev->pcm->card, dev->pcm);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}