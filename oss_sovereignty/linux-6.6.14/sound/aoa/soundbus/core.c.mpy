{
  "module_name": "core.c",
  "hash_id": "72634375580a8bcc98ad1cc327aded2aa188c9f45d3236dd2a0cf3df7a14b84c",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/soundbus/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"soundbus.h\"\n\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Apple Soundbus\");\n\nstruct soundbus_dev *soundbus_dev_get(struct soundbus_dev *dev)\n{\n\tstruct device *tmp;\n\n\tif (!dev)\n\t\treturn NULL;\n\ttmp = get_device(&dev->ofdev.dev);\n\tif (tmp)\n\t\treturn to_soundbus_device(tmp);\n\telse\n\t\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(soundbus_dev_get);\n\nvoid soundbus_dev_put(struct soundbus_dev *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->ofdev.dev);\n}\nEXPORT_SYMBOL_GPL(soundbus_dev_put);\n\nstatic int soundbus_probe(struct device *dev)\n{\n\tint error = -ENODEV;\n\tstruct soundbus_driver *drv;\n\tstruct soundbus_dev *soundbus_dev;\n\n\tdrv = to_soundbus_driver(dev->driver);\n\tsoundbus_dev = to_soundbus_device(dev);\n\n\tif (!drv->probe)\n\t\treturn error;\n\n\tsoundbus_dev_get(soundbus_dev);\n\n\terror = drv->probe(soundbus_dev);\n\tif (error)\n\t\tsoundbus_dev_put(soundbus_dev);\n\n\treturn error;\n}\n\n\nstatic int soundbus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct soundbus_dev * soundbus_dev;\n\tconst struct platform_device * of;\n\tconst char *compat;\n\tint retval = 0;\n\tint cplen, seen = 0;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tsoundbus_dev = to_soundbus_device(dev);\n\tif (!soundbus_dev)\n\t\treturn -ENODEV;\n\n\tof = &soundbus_dev->ofdev;\n\n\t \n\tretval = add_uevent_var(env, \"OF_NAME=%pOFn\", of->dev.of_node);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = add_uevent_var(env, \"OF_TYPE=%s\", of_node_get_device_type(of->dev.of_node));\n\tif (retval)\n\t\treturn retval;\n\n\t \n\n\tcompat = of_get_property(of->dev.of_node, \"compatible\", &cplen);\n\twhile (compat && cplen > 0) {\n\t\tint tmp = env->buflen;\n\t\tretval = add_uevent_var(env, \"OF_COMPATIBLE_%d=%s\", seen, compat);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tcompat += env->buflen - tmp;\n\t\tcplen -= env->buflen - tmp;\n\t\tseen += 1;\n\t}\n\n\tretval = add_uevent_var(env, \"OF_COMPATIBLE_N=%d\", seen);\n\tif (retval)\n\t\treturn retval;\n\tretval = add_uevent_var(env, \"MODALIAS=%s\", soundbus_dev->modalias);\n\n\treturn retval;\n}\n\nstatic void soundbus_device_remove(struct device *dev)\n{\n\tstruct soundbus_dev * soundbus_dev = to_soundbus_device(dev);\n\tstruct soundbus_driver * drv = to_soundbus_driver(dev->driver);\n\n\tif (dev->driver && drv->remove)\n\t\tdrv->remove(soundbus_dev);\n\tsoundbus_dev_put(soundbus_dev);\n}\n\nstatic void soundbus_device_shutdown(struct device *dev)\n{\n\tstruct soundbus_dev * soundbus_dev = to_soundbus_device(dev);\n\tstruct soundbus_driver * drv = to_soundbus_driver(dev->driver);\n\n\tif (dev->driver && drv->shutdown)\n\t\tdrv->shutdown(soundbus_dev);\n}\n\n \nATTRIBUTE_GROUPS(soundbus_dev);\nstatic struct bus_type soundbus_bus_type = {\n\t.name\t\t= \"aoa-soundbus\",\n\t.probe\t\t= soundbus_probe,\n\t.uevent\t\t= soundbus_uevent,\n\t.remove\t\t= soundbus_device_remove,\n\t.shutdown\t= soundbus_device_shutdown,\n\t.dev_groups\t= soundbus_dev_groups,\n};\n\nint soundbus_add_one(struct soundbus_dev *dev)\n{\n\tstatic int devcount;\n\n\t \n\tif (!dev->attach_codec ||\n\t    !dev->ofdev.dev.of_node ||\n\t    dev->pcmname ||\n\t    dev->pcmid != -1) {\n\t\tprintk(KERN_ERR \"soundbus: adding device failed sanity check!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_set_name(&dev->ofdev.dev, \"soundbus:%x\", ++devcount);\n\tdev->ofdev.dev.bus = &soundbus_bus_type;\n\treturn of_device_register(&dev->ofdev);\n}\nEXPORT_SYMBOL_GPL(soundbus_add_one);\n\nvoid soundbus_remove_one(struct soundbus_dev *dev)\n{\n\tof_device_unregister(&dev->ofdev);\n}\nEXPORT_SYMBOL_GPL(soundbus_remove_one);\n\nint soundbus_register_driver(struct soundbus_driver *drv)\n{\n\t \n\tdrv->driver.name = drv->name;\n\tdrv->driver.bus = &soundbus_bus_type;\n\n\t \n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(soundbus_register_driver);\n\nvoid soundbus_unregister_driver(struct soundbus_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(soundbus_unregister_driver);\n\nstatic int __init soundbus_init(void)\n{\n\treturn bus_register(&soundbus_bus_type);\n}\n\nstatic void __exit soundbus_exit(void)\n{\n\tbus_unregister(&soundbus_bus_type);\n}\n\nsubsys_initcall(soundbus_init);\nmodule_exit(soundbus_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}