{
  "module_name": "onyx.c",
  "hash_id": "eda1464cc0878d050b1f87ce58f0ed3696feab6fdf5dc51e1a4d4337e984db3f",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/codecs/onyx.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"pcm3052 (onyx) codec driver for snd-aoa\");\n\n#include \"onyx.h\"\n#include \"../aoa.h\"\n#include \"../soundbus/soundbus.h\"\n\n\n#define PFX \"snd-aoa-codec-onyx: \"\n\nstruct onyx {\n\t \n\tu8\t\t\tcache[16];\n\tstruct i2c_client\t*i2c;\n\tstruct aoa_codec\tcodec;\n\tu32\t\t\tinitialised:1,\n\t\t\t\tspdif_locked:1,\n\t\t\t\tanalog_locked:1,\n\t\t\t\toriginal_mute:2;\n\tint\t\t\topen_count;\n\tstruct codec_info\t*codec_info;\n\n\t \n\tstruct mutex mutex;\n};\n#define codec_to_onyx(c) container_of(c, struct onyx, codec)\n\n \nstatic int onyx_read_register(struct onyx *onyx, u8 reg, u8 *value)\n{\n\ts32 v;\n\n\tif (reg != ONYX_REG_CONTROL) {\n\t\t*value = onyx->cache[reg-FIRSTREGISTER];\n\t\treturn 0;\n\t}\n\tv = i2c_smbus_read_byte_data(onyx->i2c, reg);\n\tif (v < 0) {\n\t\t*value = 0;\n\t\treturn -1;\n\t}\n\t*value = (u8)v;\n\tonyx->cache[ONYX_REG_CONTROL-FIRSTREGISTER] = *value;\n\treturn 0;\n}\n\nstatic int onyx_write_register(struct onyx *onyx, u8 reg, u8 value)\n{\n\tint result;\n\n\tresult = i2c_smbus_write_byte_data(onyx->i2c, reg, value);\n\tif (!result)\n\t\tonyx->cache[reg-FIRSTREGISTER] = value;\n\treturn result;\n}\n\n \n\nstatic int onyx_dev_register(struct snd_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct snd_device_ops ops = {\n\t.dev_register = onyx_dev_register,\n};\n\n \n#define VOLUME_RANGE_SHIFT\t128\n\nstatic int onyx_snd_vol_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = -128 + VOLUME_RANGE_SHIFT;\n\tuinfo->value.integer.max = -1 + VOLUME_RANGE_SHIFT;\n\treturn 0;\n}\n\nstatic int onyx_snd_vol_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\ts8 l, r;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_LEFT, &l);\n\tonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT, &r);\n\tmutex_unlock(&onyx->mutex);\n\n\tucontrol->value.integer.value[0] = l + VOLUME_RANGE_SHIFT;\n\tucontrol->value.integer.value[1] = r + VOLUME_RANGE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int onyx_snd_vol_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\ts8 l, r;\n\n\tif (ucontrol->value.integer.value[0] < -128 + VOLUME_RANGE_SHIFT ||\n\t    ucontrol->value.integer.value[0] > -1 + VOLUME_RANGE_SHIFT)\n\t\treturn -EINVAL;\n\tif (ucontrol->value.integer.value[1] < -128 + VOLUME_RANGE_SHIFT ||\n\t    ucontrol->value.integer.value[1] > -1 + VOLUME_RANGE_SHIFT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_LEFT, &l);\n\tonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT, &r);\n\n\tif (l + VOLUME_RANGE_SHIFT == ucontrol->value.integer.value[0] &&\n\t    r + VOLUME_RANGE_SHIFT == ucontrol->value.integer.value[1]) {\n\t\tmutex_unlock(&onyx->mutex);\n\t\treturn 0;\n\t}\n\n\tonyx_write_register(onyx, ONYX_REG_DAC_ATTEN_LEFT,\n\t\t\t    ucontrol->value.integer.value[0]\n\t\t\t     - VOLUME_RANGE_SHIFT);\n\tonyx_write_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT,\n\t\t\t    ucontrol->value.integer.value[1]\n\t\t\t     - VOLUME_RANGE_SHIFT);\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new volume_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Master Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = onyx_snd_vol_info,\n\t.get = onyx_snd_vol_get,\n\t.put = onyx_snd_vol_put,\n};\n\n \n#define INPUTGAIN_RANGE_SHIFT\t(-3)\n\nstatic int onyx_snd_inputgain_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 3 + INPUTGAIN_RANGE_SHIFT;\n\tuinfo->value.integer.max = 28 + INPUTGAIN_RANGE_SHIFT;\n\treturn 0;\n}\n\nstatic int onyx_snd_inputgain_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 ig;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &ig);\n\tmutex_unlock(&onyx->mutex);\n\n\tucontrol->value.integer.value[0] =\n\t\t(ig & ONYX_ADC_PGA_GAIN_MASK) + INPUTGAIN_RANGE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int onyx_snd_inputgain_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 v, n;\n\n\tif (ucontrol->value.integer.value[0] < 3 + INPUTGAIN_RANGE_SHIFT ||\n\t    ucontrol->value.integer.value[0] > 28 + INPUTGAIN_RANGE_SHIFT)\n\t\treturn -EINVAL;\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\n\tn = v;\n\tn &= ~ONYX_ADC_PGA_GAIN_MASK;\n\tn |= (ucontrol->value.integer.value[0] - INPUTGAIN_RANGE_SHIFT)\n\t\t& ONYX_ADC_PGA_GAIN_MASK;\n\tonyx_write_register(onyx, ONYX_REG_ADC_CONTROL, n);\n\tmutex_unlock(&onyx->mutex);\n\n\treturn n != v;\n}\n\nstatic const struct snd_kcontrol_new inputgain_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Master Capture Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = onyx_snd_inputgain_info,\n\t.get = onyx_snd_inputgain_get,\n\t.put = onyx_snd_inputgain_put,\n};\n\nstatic int onyx_snd_capture_source_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = { \"Line-In\", \"Microphone\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int onyx_snd_capture_source_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\ts8 v;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\n\tmutex_unlock(&onyx->mutex);\n\n\tucontrol->value.enumerated.item[0] = !!(v&ONYX_ADC_INPUT_MIC);\n\n\treturn 0;\n}\n\nstatic void onyx_set_capture_source(struct onyx *onyx, int mic)\n{\n\ts8 v;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\n\tv &= ~ONYX_ADC_INPUT_MIC;\n\tif (mic)\n\t\tv |= ONYX_ADC_INPUT_MIC;\n\tonyx_write_register(onyx, ONYX_REG_ADC_CONTROL, v);\n\tmutex_unlock(&onyx->mutex);\n}\n\nstatic int onyx_snd_capture_source_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tif (ucontrol->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tonyx_set_capture_source(snd_kcontrol_chip(kcontrol),\n\t\t\t\tucontrol->value.enumerated.item[0]);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new capture_source_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t \n\t.name = \"Capture Source\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = onyx_snd_capture_source_info,\n\t.get = onyx_snd_capture_source_get,\n\t.put = onyx_snd_capture_source_put,\n};\n\n#define onyx_snd_mute_info\tsnd_ctl_boolean_stereo_info\n\nstatic int onyx_snd_mute_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 c;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &c);\n\tmutex_unlock(&onyx->mutex);\n\n\tucontrol->value.integer.value[0] = !(c & ONYX_MUTE_LEFT);\n\tucontrol->value.integer.value[1] = !(c & ONYX_MUTE_RIGHT);\n\n\treturn 0;\n}\n\nstatic int onyx_snd_mute_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 v = 0, c = 0;\n\tint err = -EBUSY;\n\n\tmutex_lock(&onyx->mutex);\n\tif (onyx->analog_locked)\n\t\tgoto out_unlock;\n\n\tonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\n\tc = v;\n\tc &= ~(ONYX_MUTE_RIGHT | ONYX_MUTE_LEFT);\n\tif (!ucontrol->value.integer.value[0])\n\t\tc |= ONYX_MUTE_LEFT;\n\tif (!ucontrol->value.integer.value[1])\n\t\tc |= ONYX_MUTE_RIGHT;\n\terr = onyx_write_register(onyx, ONYX_REG_DAC_CONTROL, c);\n\n out_unlock:\n\tmutex_unlock(&onyx->mutex);\n\n\treturn !err ? (v != c) : err;\n}\n\nstatic const struct snd_kcontrol_new mute_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Master Playback Switch\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = onyx_snd_mute_info,\n\t.get = onyx_snd_mute_get,\n\t.put = onyx_snd_mute_put,\n};\n\n\n#define onyx_snd_single_bit_info\tsnd_ctl_boolean_mono_info\n\n#define FLAG_POLARITY_INVERT\t1\n#define FLAG_SPDIFLOCK\t\t2\n\nstatic int onyx_snd_single_bit_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 c;\n\tlong int pv = kcontrol->private_value;\n\tu8 polarity = (pv >> 16) & FLAG_POLARITY_INVERT;\n\tu8 address = (pv >> 8) & 0xff;\n\tu8 mask = pv & 0xff;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, address, &c);\n\tmutex_unlock(&onyx->mutex);\n\n\tucontrol->value.integer.value[0] = !!(c & mask) ^ polarity;\n\n\treturn 0;\n}\n\nstatic int onyx_snd_single_bit_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 v = 0, c = 0;\n\tint err;\n\tlong int pv = kcontrol->private_value;\n\tu8 polarity = (pv >> 16) & FLAG_POLARITY_INVERT;\n\tu8 spdiflock = (pv >> 16) & FLAG_SPDIFLOCK;\n\tu8 address = (pv >> 8) & 0xff;\n\tu8 mask = pv & 0xff;\n\n\tmutex_lock(&onyx->mutex);\n\tif (spdiflock && onyx->spdif_locked) {\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tonyx_read_register(onyx, address, &v);\n\tc = v;\n\tc &= ~(mask);\n\tif (!!ucontrol->value.integer.value[0] ^ polarity)\n\t\tc |= mask;\n\terr = onyx_write_register(onyx, address, c);\n\n out_unlock:\n\tmutex_unlock(&onyx->mutex);\n\n\treturn !err ? (v != c) : err;\n}\n\n#define SINGLE_BIT(n, type, description, address, mask, flags)\t \t\\\nstatic const struct snd_kcontrol_new n##_control = {\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_##type,\t\t\t\t\\\n\t.name = description,\t\t\t\t\t\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\t\t\t\\\n\t.info = onyx_snd_single_bit_info,\t\t\t\t\\\n\t.get = onyx_snd_single_bit_get,\t\t\t\t\t\\\n\t.put = onyx_snd_single_bit_put,\t\t\t\t\t\\\n\t.private_value = (flags << 16) | (address << 8) | mask\t\t\\\n}\n\nSINGLE_BIT(spdif,\n\t   MIXER,\n\t   SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, SWITCH),\n\t   ONYX_REG_DIG_INFO4,\n\t   ONYX_SPDIF_ENABLE,\n\t   FLAG_SPDIFLOCK);\nSINGLE_BIT(ovr1,\n\t   MIXER,\n\t   \"Oversampling Rate\",\n\t   ONYX_REG_DAC_CONTROL,\n\t   ONYX_OVR1,\n\t   0);\nSINGLE_BIT(flt0,\n\t   MIXER,\n\t   \"Fast Digital Filter Rolloff\",\n\t   ONYX_REG_DAC_FILTER,\n\t   ONYX_ROLLOFF_FAST,\n\t   FLAG_POLARITY_INVERT);\nSINGLE_BIT(hpf,\n\t   MIXER,\n\t   \"Highpass Filter\",\n\t   ONYX_REG_ADC_HPF_BYPASS,\n\t   ONYX_HPF_DISABLE,\n\t   FLAG_POLARITY_INVERT);\nSINGLE_BIT(dm12,\n\t   MIXER,\n\t   \"Digital De-Emphasis\",\n\t   ONYX_REG_DAC_DEEMPH,\n\t   ONYX_DIGDEEMPH_CTRL,\n\t   0);\n\nstatic int onyx_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int onyx_spdif_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tucontrol->value.iec958.status[0] = 0x3e;\n\tucontrol->value.iec958.status[1] = 0xff;\n\n\tucontrol->value.iec958.status[3] = 0x3f;\n\tucontrol->value.iec958.status[4] = 0x0f;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new onyx_spdif_mask = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,CON_MASK),\n\t.info =\t\tonyx_spdif_info,\n\t.get =\t\tonyx_spdif_mask_get,\n};\n\nstatic int onyx_spdif_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 v;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO1, &v);\n\tucontrol->value.iec958.status[0] = v & 0x3e;\n\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO2, &v);\n\tucontrol->value.iec958.status[1] = v;\n\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO3, &v);\n\tucontrol->value.iec958.status[3] = v & 0x3f;\n\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\n\tucontrol->value.iec958.status[4] = v & 0x0f;\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 0;\n}\n\nstatic int onyx_spdif_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\n\tu8 v;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO1, &v);\n\tv = (v & ~0x3e) | (ucontrol->value.iec958.status[0] & 0x3e);\n\tonyx_write_register(onyx, ONYX_REG_DIG_INFO1, v);\n\n\tv = ucontrol->value.iec958.status[1];\n\tonyx_write_register(onyx, ONYX_REG_DIG_INFO2, v);\n\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO3, &v);\n\tv = (v & ~0x3f) | (ucontrol->value.iec958.status[3] & 0x3f);\n\tonyx_write_register(onyx, ONYX_REG_DIG_INFO3, v);\n\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\n\tv = (v & ~0x0f) | (ucontrol->value.iec958.status[4] & 0x0f);\n\tonyx_write_register(onyx, ONYX_REG_DIG_INFO4, v);\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new onyx_spdif_ctrl = {\n\t.access =\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t.name =\t\tSNDRV_CTL_NAME_IEC958(\"\",PLAYBACK,DEFAULT),\n\t.info =\t\tonyx_spdif_info,\n\t.get =\t\tonyx_spdif_get,\n\t.put =\t\tonyx_spdif_put,\n};\n\n \n\nstatic const u8 register_map[] = {\n\tONYX_REG_DAC_ATTEN_LEFT,\n\tONYX_REG_DAC_ATTEN_RIGHT,\n\tONYX_REG_CONTROL,\n\tONYX_REG_DAC_CONTROL,\n\tONYX_REG_DAC_DEEMPH,\n\tONYX_REG_DAC_FILTER,\n\tONYX_REG_DAC_OUTPHASE,\n\tONYX_REG_ADC_CONTROL,\n\tONYX_REG_ADC_HPF_BYPASS,\n\tONYX_REG_DIG_INFO1,\n\tONYX_REG_DIG_INFO2,\n\tONYX_REG_DIG_INFO3,\n\tONYX_REG_DIG_INFO4\n};\n\nstatic const u8 initial_values[ARRAY_SIZE(register_map)] = {\n\t0x80, 0x80,  \n\tONYX_MRST | ONYX_SRST,  \n\tONYX_MUTE_LEFT | ONYX_MUTE_RIGHT,\n\t0,  \n\tONYX_DAC_FILTER_ALWAYS,\n\tONYX_OUTPHASE_INVERTED,\n\t(-1   + 8) & 0xF,  \n\tONYX_ADC_HPF_ALWAYS,\n\t(1<<2),\t \n\t2,\t \n\t0,\t \n\t1\t \n};\n\n \nstatic int onyx_register_init(struct onyx *onyx)\n{\n\tint i;\n\tu8 val;\n\tu8 regs[sizeof(initial_values)];\n\n\tif (!onyx->initialised) {\n\t\tmemcpy(regs, initial_values, sizeof(initial_values));\n\t\tif (onyx_read_register(onyx, ONYX_REG_CONTROL, &val))\n\t\t\treturn -1;\n\t\tval &= ~ONYX_SILICONVERSION;\n\t\tval |= initial_values[3];\n\t\tregs[3] = val;\n\t} else {\n\t\tfor (i=0; i<sizeof(register_map); i++)\n\t\t\tregs[i] = onyx->cache[register_map[i]-FIRSTREGISTER];\n\t}\n\n\tfor (i=0; i<sizeof(register_map); i++) {\n\t\tif (onyx_write_register(onyx, register_map[i], regs[i]))\n\t\t\treturn -1;\n\t}\n\tonyx->initialised = 1;\n\treturn 0;\n}\n\nstatic struct transfer_info onyx_transfers[] = {\n\t \n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.transfer_in = 1,\n\t\t.must_be_clock_source = 0,\n\t\t.tag = 0,\n\t},\n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_BE\n#ifdef SNDRV_PCM_FMTBIT_COMPRESSED_16BE\n\t\t\t   | SNDRV_PCM_FMTBIT_COMPRESSED_16BE\n#endif\n\t\t,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.tag = 0,\n\t},\n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.transfer_in = 0,\n\t\t.must_be_clock_source = 0,\n\t\t.tag = 1,\n\t},\n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t   SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 |\n\t\t\t SNDRV_PCM_RATE_48000,\n\t\t.transfer_in = 0,\n\t\t.must_be_clock_source = 0,\n\t\t.tag = 2,\n\t},\n#ifdef SNDRV_PCM_FMTBIT_COMPRESSED_16BE\n\t \n\t{\n\t\t \n\t\t.formats =  SNDRV_PCM_FMTBIT_COMPRESSED_16BE,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 |\n\t\t\t SNDRV_PCM_RATE_48000,\n\t\t.tag = 2,\n\t},\n#endif\n\t{}\n};\n\nstatic int onyx_usable(struct codec_info_item *cii,\n\t\t       struct transfer_info *ti,\n\t\t       struct transfer_info *out)\n{\n\tu8 v;\n\tstruct onyx *onyx = cii->codec_data;\n\tint spdif_enabled, analog_enabled;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\n\tspdif_enabled = !!(v & ONYX_SPDIF_ENABLE);\n\tonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\n\tanalog_enabled =\n\t\t(v & (ONYX_MUTE_RIGHT|ONYX_MUTE_LEFT))\n\t\t != (ONYX_MUTE_RIGHT|ONYX_MUTE_LEFT);\n\tmutex_unlock(&onyx->mutex);\n\n\tswitch (ti->tag) {\n\tcase 0: return 1;\n\tcase 1:\treturn analog_enabled;\n\tcase 2: return spdif_enabled;\n\t}\n\treturn 1;\n}\n\nstatic int onyx_prepare(struct codec_info_item *cii,\n\t\t\tstruct bus_info *bi,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tu8 v;\n\tstruct onyx *onyx = cii->codec_data;\n\tint err = -EBUSY;\n\n\tmutex_lock(&onyx->mutex);\n\n#ifdef SNDRV_PCM_FMTBIT_COMPRESSED_16BE\n\tif (substream->runtime->format == SNDRV_PCM_FMTBIT_COMPRESSED_16BE) {\n\t\t \n\t\tonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\n\t\tif (onyx_write_register(onyx,\n\t\t\t\t\tONYX_REG_DAC_CONTROL,\n\t\t\t\t\tv | ONYX_MUTE_RIGHT | ONYX_MUTE_LEFT))\n\t\t\tgoto out_unlock;\n\t\tonyx->analog_locked = 1;\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\tswitch (substream->runtime->rate) {\n\tcase 32000:\n\tcase 44100:\n\tcase 48000:\n\t\t \n\t\t \n\t\terr = 0;\n\t\tgoto out_unlock;\n\tdefault:\n\t\t \n\t\tonyx_read_register(cii->codec_data, ONYX_REG_DIG_INFO4, &v);\n\t\tif (onyx_write_register(onyx,\n\t\t\t\t\tONYX_REG_DIG_INFO4,\n\t\t\t\t\tv & ~ONYX_SPDIF_ENABLE))\n\t\t\tgoto out_unlock;\n\t\tonyx->spdif_locked = 1;\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n out_unlock:\n\tmutex_unlock(&onyx->mutex);\n\n\treturn err;\n}\n\nstatic int onyx_open(struct codec_info_item *cii,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct onyx *onyx = cii->codec_data;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx->open_count++;\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 0;\n}\n\nstatic int onyx_close(struct codec_info_item *cii,\n\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct onyx *onyx = cii->codec_data;\n\n\tmutex_lock(&onyx->mutex);\n\tonyx->open_count--;\n\tif (!onyx->open_count)\n\t\tonyx->spdif_locked = onyx->analog_locked = 0;\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 0;\n}\n\nstatic int onyx_switch_clock(struct codec_info_item *cii,\n\t\t\t     enum clock_switch what)\n{\n\tstruct onyx *onyx = cii->codec_data;\n\n\tmutex_lock(&onyx->mutex);\n\t \n\tswitch (what) {\n\tcase CLOCK_SWITCH_PREPARE_SLAVE:\n\t\tonyx->codec.gpio->methods->all_amps_off(onyx->codec.gpio);\n\t\tbreak;\n\tcase CLOCK_SWITCH_SLAVE:\n\t\tonyx->codec.gpio->methods->all_amps_restore(onyx->codec.gpio);\n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\tmutex_unlock(&onyx->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int onyx_suspend(struct codec_info_item *cii, pm_message_t state)\n{\n\tstruct onyx *onyx = cii->codec_data;\n\tu8 v;\n\tint err = -ENXIO;\n\n\tmutex_lock(&onyx->mutex);\n\tif (onyx_read_register(onyx, ONYX_REG_CONTROL, &v))\n\t\tgoto out_unlock;\n\tonyx_write_register(onyx, ONYX_REG_CONTROL, v | ONYX_ADPSV | ONYX_DAPSV);\n\t \n\terr = 0;\n out_unlock:\n\tmutex_unlock(&onyx->mutex);\n\n\treturn err;\n}\n\nstatic int onyx_resume(struct codec_info_item *cii)\n{\n\tstruct onyx *onyx = cii->codec_data;\n\tu8 v;\n\tint err = -ENXIO;\n\n\tmutex_lock(&onyx->mutex);\n\n\t \n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\n\tmsleep(1);\n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 1);\n\tmsleep(1);\n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\n\tmsleep(1);\n\n\t \n\tif (onyx_read_register(onyx, ONYX_REG_CONTROL, &v))\n\t\tgoto out_unlock;\n\tonyx_write_register(onyx, ONYX_REG_CONTROL, v & ~(ONYX_ADPSV | ONYX_DAPSV));\n\t \n\tmsleep(2205000/8000);\n\t \n\tonyx_register_init(onyx);\n\terr = 0;\n out_unlock:\n\tmutex_unlock(&onyx->mutex);\n\n\treturn err;\n}\n\n#endif  \n\nstatic struct codec_info onyx_codec_info = {\n\t.transfers = onyx_transfers,\n\t.sysclock_factor = 256,\n\t.bus_factor = 64,\n\t.owner = THIS_MODULE,\n\t.usable = onyx_usable,\n\t.prepare = onyx_prepare,\n\t.open = onyx_open,\n\t.close = onyx_close,\n\t.switch_clock = onyx_switch_clock,\n#ifdef CONFIG_PM\n\t.suspend = onyx_suspend,\n\t.resume = onyx_resume,\n#endif\n};\n\nstatic int onyx_init_codec(struct aoa_codec *codec)\n{\n\tstruct onyx *onyx = codec_to_onyx(codec);\n\tstruct snd_kcontrol *ctl;\n\tstruct codec_info *ci = &onyx_codec_info;\n\tu8 v;\n\tint err;\n\n\tif (!onyx->codec.gpio || !onyx->codec.gpio->methods) {\n\t\tprintk(KERN_ERR PFX \"gpios not assigned!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\n\tmsleep(1);\n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 1);\n\tmsleep(1);\n\tonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\n\tmsleep(1);\n\n\tif (onyx_register_init(onyx)) {\n\t\tprintk(KERN_ERR PFX \"failed to initialise onyx registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (aoa_snd_device_new(SNDRV_DEV_CODEC, onyx, &ops)) {\n\t\tprintk(KERN_ERR PFX \"failed to create onyx snd device!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif ((onyx->codec.connected & 0xF) == 0)\n\t\treturn -ENOTCONN;\n\n\t \n\tif ((onyx->codec.connected & 0xC) == 0) {\n\t\tif (!onyx->codec_info)\n\t\t\tonyx->codec_info = kmalloc(sizeof(struct codec_info), GFP_KERNEL);\n\t\tif (!onyx->codec_info)\n\t\t\treturn -ENOMEM;\n\t\tci = onyx->codec_info;\n\t\t*ci = onyx_codec_info;\n\t\tci->transfers++;\n\t}\n\n\t \n\tif ((onyx->codec.connected & 3) == 0) {\n\t\tif (!onyx->codec_info)\n\t\t\tonyx->codec_info = kmalloc(sizeof(struct codec_info), GFP_KERNEL);\n\t\tif (!onyx->codec_info)\n\t\t\treturn -ENOMEM;\n\t\tci = onyx->codec_info;\n\t\t \n\t\t*ci = onyx_codec_info;\n\t\tci->transfers[1].formats = 0;\n\t}\n\n\tif (onyx->codec.soundbus_dev->attach_codec(onyx->codec.soundbus_dev,\n\t\t\t\t\t\t   aoa_get_card(),\n\t\t\t\t\t\t   ci, onyx)) {\n\t\tprintk(KERN_ERR PFX \"error creating onyx pcm\\n\");\n\t\treturn -ENODEV;\n\t}\n#define ADDCTL(n)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tctl = snd_ctl_new1(&n, onyx);\t\t\t\t\\\n\t\tif (ctl) {\t\t\t\t\t\t\\\n\t\t\tctl->id.device =\t\t\t\t\\\n\t\t\t\tonyx->codec.soundbus_dev->pcm->device;\t\\\n\t\t\terr = aoa_snd_ctl_add(ctl);\t\t\t\\\n\t\t\tif (err)\t\t\t\t\t\\\n\t\t\t\tgoto error;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (onyx->codec.soundbus_dev->pcm) {\n\t\t \n\t\tif ((onyx->codec.connected & 0xC) == 0xC)\n\t\t\tADDCTL(capture_source_control);\n\t\telse if (onyx->codec.connected & 4)\n\t\t\tonyx_set_capture_source(onyx, 0);\n\t\telse\n\t\t\tonyx_set_capture_source(onyx, 1);\n\t\tif (onyx->codec.connected & 0xC)\n\t\t\tADDCTL(inputgain_control);\n\n\t\t \n\t\tif (onyx->codec.connected & 1) {\n\t\t\tADDCTL(volume_control);\n\t\t\tADDCTL(mute_control);\n\t\t\tADDCTL(ovr1_control);\n\t\t\tADDCTL(flt0_control);\n\t\t\tADDCTL(hpf_control);\n\t\t\tADDCTL(dm12_control);\n\t\t\t \n\t\t}\n\t\tif (onyx->codec.connected & 2) {\n\t\t\tADDCTL(onyx_spdif_mask);\n\t\t\tADDCTL(onyx_spdif_ctrl);\n\t\t}\n\t\tif ((onyx->codec.connected & 3) == 3)\n\t\t\tADDCTL(spdif_control);\n\t\t \n\t\tif ((onyx->codec.connected & 3) == 2) {\n\t\t\tonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\n\t\t\tv |= ONYX_SPDIF_ENABLE;\n\t\t\tonyx_write_register(onyx, ONYX_REG_DIG_INFO4, v);\n\t\t}\n\t}\n#undef ADDCTL\n\tprintk(KERN_INFO PFX \"attached to onyx codec via i2c\\n\");\n\n\treturn 0;\n error:\n\tonyx->codec.soundbus_dev->detach_codec(onyx->codec.soundbus_dev, onyx);\n\tsnd_device_free(aoa_get_card(), onyx);\n\treturn err;\n}\n\nstatic void onyx_exit_codec(struct aoa_codec *codec)\n{\n\tstruct onyx *onyx = codec_to_onyx(codec);\n\n\tif (!onyx->codec.soundbus_dev) {\n\t\tprintk(KERN_ERR PFX \"onyx_exit_codec called without soundbus_dev!\\n\");\n\t\treturn;\n\t}\n\tonyx->codec.soundbus_dev->detach_codec(onyx->codec.soundbus_dev, onyx);\n}\n\nstatic int onyx_i2c_probe(struct i2c_client *client)\n{\n\tstruct device_node *node = client->dev.of_node;\n\tstruct onyx *onyx;\n\tu8 dummy;\n\n\tonyx = kzalloc(sizeof(struct onyx), GFP_KERNEL);\n\n\tif (!onyx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&onyx->mutex);\n\tonyx->i2c = client;\n\ti2c_set_clientdata(client, onyx);\n\n\t \n\tif (onyx_read_register(onyx, ONYX_REG_CONTROL, &dummy) != 0) {\n\t\tprintk(KERN_ERR PFX \"failed to read control register\\n\");\n\t\tgoto fail;\n\t}\n\n\tstrscpy(onyx->codec.name, \"onyx\", MAX_CODEC_NAME_LEN);\n\tonyx->codec.owner = THIS_MODULE;\n\tonyx->codec.init = onyx_init_codec;\n\tonyx->codec.exit = onyx_exit_codec;\n\tonyx->codec.node = of_node_get(node);\n\n\tif (aoa_codec_register(&onyx->codec)) {\n\t\tgoto fail;\n\t}\n\tprintk(KERN_DEBUG PFX \"created and attached onyx instance\\n\");\n\treturn 0;\n fail:\n\tkfree(onyx);\n\treturn -ENODEV;\n}\n\nstatic void onyx_i2c_remove(struct i2c_client *client)\n{\n\tstruct onyx *onyx = i2c_get_clientdata(client);\n\n\taoa_codec_unregister(&onyx->codec);\n\tof_node_put(onyx->codec.node);\n\tkfree(onyx->codec_info);\n\tkfree(onyx);\n}\n\nstatic const struct i2c_device_id onyx_i2c_id[] = {\n\t{ \"MAC,pcm3052\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c,onyx_i2c_id);\n\nstatic struct i2c_driver onyx_driver = {\n\t.driver = {\n\t\t.name = \"aoa_codec_onyx\",\n\t},\n\t.probe = onyx_i2c_probe,\n\t.remove = onyx_i2c_remove,\n\t.id_table = onyx_i2c_id,\n};\n\nmodule_i2c_driver(onyx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}