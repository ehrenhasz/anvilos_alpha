{
  "module_name": "toonie.c",
  "hash_id": "12817e7ce59ec67bf12c904e3cf8a01d2f3cbc7ecb3992dcfa09f37c14b9560d",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/codecs/toonie.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"toonie codec driver for snd-aoa\");\n\n#include \"../aoa.h\"\n#include \"../soundbus/soundbus.h\"\n\n\n#define PFX \"snd-aoa-codec-toonie: \"\n\nstruct toonie {\n\tstruct aoa_codec\tcodec;\n};\n#define codec_to_toonie(c) container_of(c, struct toonie, codec)\n\nstatic int toonie_dev_register(struct snd_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct snd_device_ops ops = {\n\t.dev_register = toonie_dev_register,\n};\n\nstatic struct transfer_info toonie_transfers[] = {\n\t \n\t{\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 |\n\t\t\t SNDRV_PCM_RATE_48000 |\n\t\t\t SNDRV_PCM_RATE_88200 |\n\t\t\t SNDRV_PCM_RATE_96000,\n\t},\n\t{}\n};\n\nstatic int toonie_usable(struct codec_info_item *cii,\n\t\t\t struct transfer_info *ti,\n\t\t\t struct transfer_info *out)\n{\n\treturn 1;\n}\n\n#ifdef CONFIG_PM\nstatic int toonie_suspend(struct codec_info_item *cii, pm_message_t state)\n{\n\t \n\treturn 0;\n}\n\nstatic int toonie_resume(struct codec_info_item *cii)\n{\n\treturn 0;\n}\n#endif  \n\nstatic struct codec_info toonie_codec_info = {\n\t.transfers = toonie_transfers,\n\t.sysclock_factor = 256,\n\t.bus_factor = 64,\n\t.owner = THIS_MODULE,\n\t.usable = toonie_usable,\n#ifdef CONFIG_PM\n\t.suspend = toonie_suspend,\n\t.resume = toonie_resume,\n#endif\n};\n\nstatic int toonie_init_codec(struct aoa_codec *codec)\n{\n\tstruct toonie *toonie = codec_to_toonie(codec);\n\n\t \n\tif (toonie->codec.connected != 1)\n\t\treturn -ENOTCONN;\n\n\tif (aoa_snd_device_new(SNDRV_DEV_CODEC, toonie, &ops)) {\n\t\tprintk(KERN_ERR PFX \"failed to create toonie snd device!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (toonie->codec.soundbus_dev->attach_codec(toonie->codec.soundbus_dev,\n\t\t\t\t\t\t     aoa_get_card(),\n\t\t\t\t\t\t     &toonie_codec_info, toonie)) {\n\t\tprintk(KERN_ERR PFX \"error creating toonie pcm\\n\");\n\t\tsnd_device_free(aoa_get_card(), toonie);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void toonie_exit_codec(struct aoa_codec *codec)\n{\n\tstruct toonie *toonie = codec_to_toonie(codec);\n\n\tif (!toonie->codec.soundbus_dev) {\n\t\tprintk(KERN_ERR PFX \"toonie_exit_codec called without soundbus_dev!\\n\");\n\t\treturn;\n\t}\n\ttoonie->codec.soundbus_dev->detach_codec(toonie->codec.soundbus_dev, toonie);\n}\n\nstatic struct toonie *toonie;\n\nstatic int __init toonie_init(void)\n{\n\ttoonie = kzalloc(sizeof(struct toonie), GFP_KERNEL);\n\n\tif (!toonie)\n\t\treturn -ENOMEM;\n\n\tstrscpy(toonie->codec.name, \"toonie\", sizeof(toonie->codec.name));\n\ttoonie->codec.owner = THIS_MODULE;\n\ttoonie->codec.init = toonie_init_codec;\n\ttoonie->codec.exit = toonie_exit_codec;\n\n\tif (aoa_codec_register(&toonie->codec)) {\n\t\tkfree(toonie);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit toonie_exit(void)\n{\n\taoa_codec_unregister(&toonie->codec);\n\tkfree(toonie);\n}\n\nmodule_init(toonie_init);\nmodule_exit(toonie_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}