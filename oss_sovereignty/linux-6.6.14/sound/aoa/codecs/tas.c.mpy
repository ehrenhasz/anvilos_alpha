{
  "module_name": "tas.c",
  "hash_id": "47178ffc91cffb9348405f17e5e38d69a6d2b705fbae8d06f34b34ef2643a03d",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/codecs/tas.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <asm/pmac_low_i2c.h>\n#include <asm/prom.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"tas codec driver for snd-aoa\");\n\n#include \"tas.h\"\n#include \"tas-gain-table.h\"\n#include \"tas-basstreble.h\"\n#include \"../aoa.h\"\n#include \"../soundbus/soundbus.h\"\n\n#define PFX \"snd-aoa-codec-tas: \"\n\n\nstruct tas {\n\tstruct aoa_codec\tcodec;\n\tstruct i2c_client\t*i2c;\n\tu32\t\t\tmute_l:1, mute_r:1 ,\n\t\t\t\tcontrols_created:1 ,\n\t\t\t\tdrc_enabled:1,\n\t\t\t\thw_enabled:1;\n\tu8\t\t\tcached_volume_l, cached_volume_r;\n\tu8\t\t\tmixer_l[3], mixer_r[3];\n\tu8\t\t\tbass, treble;\n\tu8\t\t\tacr;\n\tint\t\t\tdrc_range;\n\t \n\tstruct mutex\t\tmtx;\n};\n\nstatic int tas_reset_init(struct tas *tas);\n\nstatic struct tas *codec_to_tas(struct aoa_codec *codec)\n{\n\treturn container_of(codec, struct tas, codec);\n}\n\nstatic inline int tas_write_reg(struct tas *tas, u8 reg, u8 len, u8 *data)\n{\n\tif (len == 1)\n\t\treturn i2c_smbus_write_byte_data(tas->i2c, reg, *data);\n\telse\n\t\treturn i2c_smbus_write_i2c_block_data(tas->i2c, reg, len, data);\n}\n\nstatic void tas3004_set_drc(struct tas *tas)\n{\n\tunsigned char val[6];\n\n\tif (tas->drc_enabled)\n\t\tval[0] = 0x50;  \n\telse\n\t\tval[0] = 0x51;  \n\tval[1] = 0x02;  \n\tif (tas->drc_range > 0xef)\n\t\tval[2] = 0xef;\n\telse if (tas->drc_range < 0)\n\t\tval[2] = 0x00;\n\telse\n\t\tval[2] = tas->drc_range;\n\tval[3] = 0xb0;\n\tval[4] = 0x60;\n\tval[5] = 0xa0;\n\n\ttas_write_reg(tas, TAS_REG_DRC, 6, val);\n}\n\nstatic void tas_set_treble(struct tas *tas)\n{\n\tu8 tmp;\n\n\ttmp = tas3004_treble(tas->treble);\n\ttas_write_reg(tas, TAS_REG_TREBLE, 1, &tmp);\n}\n\nstatic void tas_set_bass(struct tas *tas)\n{\n\tu8 tmp;\n\n\ttmp = tas3004_bass(tas->bass);\n\ttas_write_reg(tas, TAS_REG_BASS, 1, &tmp);\n}\n\nstatic void tas_set_volume(struct tas *tas)\n{\n\tu8 block[6];\n\tint tmp;\n\tu8 left, right;\n\n\tleft = tas->cached_volume_l;\n\tright = tas->cached_volume_r;\n\n\tif (left > 177) left = 177;\n\tif (right > 177) right = 177;\n\n\tif (tas->mute_l) left = 0;\n\tif (tas->mute_r) right = 0;\n\n\t \n\ttmp = tas_gaintable[left];\n\tblock[0] = tmp>>20;\n\tblock[1] = tmp>>12;\n\tblock[2] = tmp>>4;\n\ttmp = tas_gaintable[right];\n\tblock[3] = tmp>>20;\n\tblock[4] = tmp>>12;\n\tblock[5] = tmp>>4;\n\ttas_write_reg(tas, TAS_REG_VOL, 6, block);\n}\n\nstatic void tas_set_mixer(struct tas *tas)\n{\n\tu8 block[9];\n\tint tmp, i;\n\tu8 val;\n\n\tfor (i=0;i<3;i++) {\n\t\tval = tas->mixer_l[i];\n\t\tif (val > 177) val = 177;\n\t\ttmp = tas_gaintable[val];\n\t\tblock[3*i+0] = tmp>>16;\n\t\tblock[3*i+1] = tmp>>8;\n\t\tblock[3*i+2] = tmp;\n\t}\n\ttas_write_reg(tas, TAS_REG_LMIX, 9, block);\n\n\tfor (i=0;i<3;i++) {\n\t\tval = tas->mixer_r[i];\n\t\tif (val > 177) val = 177;\n\t\ttmp = tas_gaintable[val];\n\t\tblock[3*i+0] = tmp>>16;\n\t\tblock[3*i+1] = tmp>>8;\n\t\tblock[3*i+2] = tmp;\n\t}\n\ttas_write_reg(tas, TAS_REG_RMIX, 9, block);\n}\n\n \n\nstatic int tas_dev_register(struct snd_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct snd_device_ops ops = {\n\t.dev_register = tas_dev_register,\n};\n\nstatic int tas_snd_vol_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 177;\n\treturn 0;\n}\n\nstatic int tas_snd_vol_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->cached_volume_l;\n\tucontrol->value.integer.value[1] = tas->cached_volume_r;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_vol_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.integer.value[0] < 0 ||\n\t    ucontrol->value.integer.value[0] > 177)\n\t\treturn -EINVAL;\n\tif (ucontrol->value.integer.value[1] < 0 ||\n\t    ucontrol->value.integer.value[1] > 177)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tas->mtx);\n\tif (tas->cached_volume_l == ucontrol->value.integer.value[0]\n\t && tas->cached_volume_r == ucontrol->value.integer.value[1]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->cached_volume_l = ucontrol->value.integer.value[0];\n\ttas->cached_volume_r = ucontrol->value.integer.value[1];\n\tif (tas->hw_enabled)\n\t\ttas_set_volume(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new volume_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Master Playback Volume\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_vol_info,\n\t.get = tas_snd_vol_get,\n\t.put = tas_snd_vol_put,\n};\n\n#define tas_snd_mute_info\tsnd_ctl_boolean_stereo_info\n\nstatic int tas_snd_mute_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = !tas->mute_l;\n\tucontrol->value.integer.value[1] = !tas->mute_r;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_mute_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tif (tas->mute_l == !ucontrol->value.integer.value[0]\n\t && tas->mute_r == !ucontrol->value.integer.value[1]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->mute_l = !ucontrol->value.integer.value[0];\n\ttas->mute_r = !ucontrol->value.integer.value[1];\n\tif (tas->hw_enabled)\n\t\ttas_set_volume(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new mute_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Master Playback Switch\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_mute_info,\n\t.get = tas_snd_mute_get,\n\t.put = tas_snd_mute_put,\n};\n\nstatic int tas_snd_mixer_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 177;\n\treturn 0;\n}\n\nstatic int tas_snd_mixer_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->mixer_l[idx];\n\tucontrol->value.integer.value[1] = tas->mixer_r[idx];\n\tmutex_unlock(&tas->mtx);\n\n\treturn 0;\n}\n\nstatic int tas_snd_mixer_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\tint idx = kcontrol->private_value;\n\n\tmutex_lock(&tas->mtx);\n\tif (tas->mixer_l[idx] == ucontrol->value.integer.value[0]\n\t && tas->mixer_r[idx] == ucontrol->value.integer.value[1]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->mixer_l[idx] = ucontrol->value.integer.value[0];\n\ttas->mixer_r[idx] = ucontrol->value.integer.value[1];\n\n\tif (tas->hw_enabled)\n\t\ttas_set_mixer(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\n#define MIXER_CONTROL(n,descr,idx)\t\t\t\\\nstatic const struct snd_kcontrol_new n##_control = {\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\\\n\t.name = descr \" Playback Volume\",\t\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\t\\\n\t.info = tas_snd_mixer_info,\t\t\t\\\n\t.get = tas_snd_mixer_get,\t\t\t\\\n\t.put = tas_snd_mixer_put,\t\t\t\\\n\t.private_value = idx,\t\t\t\t\\\n}\n\nMIXER_CONTROL(pcm1, \"PCM\", 0);\nMIXER_CONTROL(monitor, \"Monitor\", 2);\n\nstatic int tas_snd_drc_range_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = TAS3004_DRC_MAX;\n\treturn 0;\n}\n\nstatic int tas_snd_drc_range_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->drc_range;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_drc_range_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.integer.value[0] < 0 ||\n\t    ucontrol->value.integer.value[0] > TAS3004_DRC_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tas->mtx);\n\tif (tas->drc_range == ucontrol->value.integer.value[0]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->drc_range = ucontrol->value.integer.value[0];\n\tif (tas->hw_enabled)\n\t\ttas3004_set_drc(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new drc_range_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DRC Range\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_drc_range_info,\n\t.get = tas_snd_drc_range_get,\n\t.put = tas_snd_drc_range_put,\n};\n\n#define tas_snd_drc_switch_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int tas_snd_drc_switch_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->drc_enabled;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_drc_switch_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tif (tas->drc_enabled == ucontrol->value.integer.value[0]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->drc_enabled = !!ucontrol->value.integer.value[0];\n\tif (tas->hw_enabled)\n\t\ttas3004_set_drc(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new drc_switch_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"DRC Range Switch\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_drc_switch_info,\n\t.get = tas_snd_drc_switch_get,\n\t.put = tas_snd_drc_switch_put,\n};\n\nstatic int tas_snd_capture_source_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[] = { \"Line-In\", \"Microphone\" };\n\n\treturn snd_ctl_enum_info(uinfo, 1, 2, texts);\n}\n\nstatic int tas_snd_capture_source_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.enumerated.item[0] = !!(tas->acr & TAS_ACR_INPUT_B);\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_capture_source_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\tint oldacr;\n\n\tif (ucontrol->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&tas->mtx);\n\toldacr = tas->acr;\n\n\t \n\ttas->acr &= ~(TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL);\n\tif (ucontrol->value.enumerated.item[0])\n\t\ttas->acr |= TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL |\n\t\t      TAS_ACR_B_MON_SEL_RIGHT;\n\tif (oldacr == tas->acr) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\tif (tas->hw_enabled)\n\t\ttas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new capture_source_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t \n\t.name = \"Capture Source\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_capture_source_info,\n\t.get = tas_snd_capture_source_get,\n\t.put = tas_snd_capture_source_put,\n};\n\nstatic int tas_snd_treble_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = TAS3004_TREBLE_MIN;\n\tuinfo->value.integer.max = TAS3004_TREBLE_MAX;\n\treturn 0;\n}\n\nstatic int tas_snd_treble_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->treble;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_treble_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.integer.value[0] < TAS3004_TREBLE_MIN ||\n\t    ucontrol->value.integer.value[0] > TAS3004_TREBLE_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&tas->mtx);\n\tif (tas->treble == ucontrol->value.integer.value[0]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->treble = ucontrol->value.integer.value[0];\n\tif (tas->hw_enabled)\n\t\ttas_set_treble(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new treble_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Treble\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_treble_info,\n\t.get = tas_snd_treble_get,\n\t.put = tas_snd_treble_put,\n};\n\nstatic int tas_snd_bass_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = TAS3004_BASS_MIN;\n\tuinfo->value.integer.max = TAS3004_BASS_MAX;\n\treturn 0;\n}\n\nstatic int tas_snd_bass_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&tas->mtx);\n\tucontrol->value.integer.value[0] = tas->bass;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_snd_bass_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct tas *tas = snd_kcontrol_chip(kcontrol);\n\n\tif (ucontrol->value.integer.value[0] < TAS3004_BASS_MIN ||\n\t    ucontrol->value.integer.value[0] > TAS3004_BASS_MAX)\n\t\treturn -EINVAL;\n\tmutex_lock(&tas->mtx);\n\tif (tas->bass == ucontrol->value.integer.value[0]) {\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn 0;\n\t}\n\n\ttas->bass = ucontrol->value.integer.value[0];\n\tif (tas->hw_enabled)\n\t\ttas_set_bass(tas);\n\tmutex_unlock(&tas->mtx);\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new bass_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Bass\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = tas_snd_bass_info,\n\t.get = tas_snd_bass_get,\n\t.put = tas_snd_bass_put,\n};\n\nstatic struct transfer_info tas_transfers[] = {\n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t\t.transfer_in = 1,\n\t},\n\t{\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S24_BE,\n\t\t.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t\t.transfer_in = 0,\n\t},\n\t{}\n};\n\nstatic int tas_usable(struct codec_info_item *cii,\n\t\t      struct transfer_info *ti,\n\t\t      struct transfer_info *out)\n{\n\treturn 1;\n}\n\nstatic int tas_reset_init(struct tas *tas)\n{\n\tu8 tmp;\n\n\ttas->codec.gpio->methods->all_amps_off(tas->codec.gpio);\n\tmsleep(5);\n\ttas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 0);\n\tmsleep(5);\n\ttas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 1);\n\tmsleep(20);\n\ttas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 0);\n\tmsleep(10);\n\ttas->codec.gpio->methods->all_amps_restore(tas->codec.gpio);\n\n\ttmp = TAS_MCS_SCLK64 | TAS_MCS_SPORT_MODE_I2S | TAS_MCS_SPORT_WL_24BIT;\n\tif (tas_write_reg(tas, TAS_REG_MCS, 1, &tmp))\n\t\tgoto outerr;\n\n\ttas->acr |= TAS_ACR_ANALOG_PDOWN;\n\tif (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))\n\t\tgoto outerr;\n\n\ttmp = 0;\n\tif (tas_write_reg(tas, TAS_REG_MCS2, 1, &tmp))\n\t\tgoto outerr;\n\n\ttas3004_set_drc(tas);\n\n\t \n\ttas->treble = TAS3004_TREBLE_ZERO;\n\ttas->bass = TAS3004_BASS_ZERO;\n\ttas_set_treble(tas);\n\ttas_set_bass(tas);\n\n\ttas->acr &= ~TAS_ACR_ANALOG_PDOWN;\n\tif (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))\n\t\tgoto outerr;\n\n\treturn 0;\n outerr:\n\treturn -ENODEV;\n}\n\nstatic int tas_switch_clock(struct codec_info_item *cii, enum clock_switch clock)\n{\n\tstruct tas *tas = cii->codec_data;\n\n\tswitch(clock) {\n\tcase CLOCK_SWITCH_PREPARE_SLAVE:\n\t\t \n\t\ttas->codec.gpio->methods->all_amps_off(tas->codec.gpio);\n\t\ttas->hw_enabled = 0;\n\t\tbreak;\n\tcase CLOCK_SWITCH_SLAVE:\n\t\t \n\t\tmutex_lock(&tas->mtx);\n\t\ttas_reset_init(tas);\n\t\ttas_set_volume(tas);\n\t\ttas_set_mixer(tas);\n\t\ttas->hw_enabled = 1;\n\t\ttas->codec.gpio->methods->all_amps_restore(tas->codec.gpio);\n\t\tmutex_unlock(&tas->mtx);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n \nstatic int tas_suspend(struct tas *tas)\n{\n\tmutex_lock(&tas->mtx);\n\ttas->hw_enabled = 0;\n\ttas->acr |= TAS_ACR_ANALOG_PDOWN;\n\ttas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int tas_resume(struct tas *tas)\n{\n\t \n\tmutex_lock(&tas->mtx);\n\ttas_reset_init(tas);\n\ttas_set_volume(tas);\n\ttas_set_mixer(tas);\n\ttas->hw_enabled = 1;\n\tmutex_unlock(&tas->mtx);\n\treturn 0;\n}\n\nstatic int _tas_suspend(struct codec_info_item *cii, pm_message_t state)\n{\n\treturn tas_suspend(cii->codec_data);\n}\n\nstatic int _tas_resume(struct codec_info_item *cii)\n{\n\treturn tas_resume(cii->codec_data);\n}\n#else  \n#define _tas_suspend\tNULL\n#define _tas_resume\tNULL\n#endif  \n\nstatic struct codec_info tas_codec_info = {\n\t.transfers = tas_transfers,\n\t \n\t.sysclock_factor = 256,\n\t \n\t.bus_factor = 64,\n\t.owner = THIS_MODULE,\n\t.usable = tas_usable,\n\t.switch_clock = tas_switch_clock,\n\t.suspend = _tas_suspend,\n\t.resume = _tas_resume,\n};\n\nstatic int tas_init_codec(struct aoa_codec *codec)\n{\n\tstruct tas *tas = codec_to_tas(codec);\n\tint err;\n\n\tif (!tas->codec.gpio || !tas->codec.gpio->methods) {\n\t\tprintk(KERN_ERR PFX \"gpios not assigned!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&tas->mtx);\n\tif (tas_reset_init(tas)) {\n\t\tprintk(KERN_ERR PFX \"tas failed to initialise\\n\");\n\t\tmutex_unlock(&tas->mtx);\n\t\treturn -ENXIO;\n\t}\n\ttas->hw_enabled = 1;\n\tmutex_unlock(&tas->mtx);\n\n\tif (tas->codec.soundbus_dev->attach_codec(tas->codec.soundbus_dev,\n\t\t\t\t\t\t   aoa_get_card(),\n\t\t\t\t\t\t   &tas_codec_info, tas)) {\n\t\tprintk(KERN_ERR PFX \"error attaching tas to soundbus\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (aoa_snd_device_new(SNDRV_DEV_CODEC, tas, &ops)) {\n\t\tprintk(KERN_ERR PFX \"failed to create tas snd device!\\n\");\n\t\treturn -ENODEV;\n\t}\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&volume_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&mute_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&pcm1_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&monitor_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&capture_source_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&drc_range_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&drc_switch_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&treble_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\terr = aoa_snd_ctl_add(snd_ctl_new1(&bass_control, tas));\n\tif (err)\n\t\tgoto error;\n\n\treturn 0;\n error:\n\ttas->codec.soundbus_dev->detach_codec(tas->codec.soundbus_dev, tas);\n\tsnd_device_free(aoa_get_card(), tas);\n\treturn err;\n}\n\nstatic void tas_exit_codec(struct aoa_codec *codec)\n{\n\tstruct tas *tas = codec_to_tas(codec);\n\n\tif (!tas->codec.soundbus_dev)\n\t\treturn;\n\ttas->codec.soundbus_dev->detach_codec(tas->codec.soundbus_dev, tas);\n}\n\n\nstatic int tas_i2c_probe(struct i2c_client *client)\n{\n\tstruct device_node *node = client->dev.of_node;\n\tstruct tas *tas;\n\n\ttas = kzalloc(sizeof(struct tas), GFP_KERNEL);\n\n\tif (!tas)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tas->mtx);\n\ttas->i2c = client;\n\ti2c_set_clientdata(client, tas);\n\n\t \n\ttas->drc_range = TAS3004_DRC_MAX / 2;\n\n\tstrscpy(tas->codec.name, \"tas\", MAX_CODEC_NAME_LEN);\n\ttas->codec.owner = THIS_MODULE;\n\ttas->codec.init = tas_init_codec;\n\ttas->codec.exit = tas_exit_codec;\n\ttas->codec.node = of_node_get(node);\n\n\tif (aoa_codec_register(&tas->codec)) {\n\t\tgoto fail;\n\t}\n\tprintk(KERN_DEBUG\n\t       \"snd-aoa-codec-tas: tas found, addr 0x%02x on %pOF\\n\",\n\t       (unsigned int)client->addr, node);\n\treturn 0;\n fail:\n\tmutex_destroy(&tas->mtx);\n\tkfree(tas);\n\treturn -EINVAL;\n}\n\nstatic void tas_i2c_remove(struct i2c_client *client)\n{\n\tstruct tas *tas = i2c_get_clientdata(client);\n\tu8 tmp = TAS_ACR_ANALOG_PDOWN;\n\n\taoa_codec_unregister(&tas->codec);\n\tof_node_put(tas->codec.node);\n\n\t \n\ttas_write_reg(tas, TAS_REG_ACR, 1, &tmp);\n\n\tmutex_destroy(&tas->mtx);\n\tkfree(tas);\n}\n\nstatic const struct i2c_device_id tas_i2c_id[] = {\n\t{ \"MAC,tas3004\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c,tas_i2c_id);\n\nstatic struct i2c_driver tas_driver = {\n\t.driver = {\n\t\t.name = \"aoa_codec_tas\",\n\t},\n\t.probe = tas_i2c_probe,\n\t.remove = tas_i2c_remove,\n\t.id_table = tas_i2c_id,\n};\n\nmodule_i2c_driver(tas_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}