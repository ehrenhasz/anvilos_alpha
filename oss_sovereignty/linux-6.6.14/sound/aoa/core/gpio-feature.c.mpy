{
  "module_name": "gpio-feature.c",
  "hash_id": "ebfcc28f5e4efd8953c1a13640efb1b3c31914310e17f1404f2e3481e4cfc644",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/core/gpio-feature.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n#include <asm/pmac_feature.h>\n#include \"../aoa.h\"\n\n \n\n \nstatic int headphone_mute_gpio;\nstatic int master_mute_gpio;\nstatic int amp_mute_gpio;\nstatic int lineout_mute_gpio;\nstatic int hw_reset_gpio;\nstatic int lineout_detect_gpio;\nstatic int headphone_detect_gpio;\nstatic int linein_detect_gpio;\n\n \nstatic int headphone_mute_gpio_activestate;\nstatic int master_mute_gpio_activestate;\nstatic int amp_mute_gpio_activestate;\nstatic int lineout_mute_gpio_activestate;\nstatic int hw_reset_gpio_activestate;\nstatic int lineout_detect_gpio_activestate;\nstatic int headphone_detect_gpio_activestate;\nstatic int linein_detect_gpio_activestate;\n\n \nstatic struct device_node *lineout_detect_node;\nstatic struct device_node *linein_detect_node;\nstatic struct device_node *headphone_detect_node;\n\nstatic int lineout_detect_irq;\nstatic int linein_detect_irq;\nstatic int headphone_detect_irq;\n\nstatic struct device_node *get_gpio(char *name,\n\t\t\t\t    char *altname,\n\t\t\t\t    int *gpioptr,\n\t\t\t\t    int *gpioactiveptr)\n{\n\tstruct device_node *np, *gpio;\n\tconst u32 *reg;\n\tconst char *audio_gpio;\n\n\t*gpioptr = -1;\n\n\t \n\tnp = of_find_node_by_name(NULL, name);\n\tif (!np) {\n\t\t \n\t\tgpio = of_find_node_by_name(NULL, \"gpio\");\n\t\tif (!gpio)\n\t\t\treturn NULL;\n\t\twhile ((np = of_get_next_child(gpio, np))) {\n\t\t\taudio_gpio = of_get_property(np, \"audio-gpio\", NULL);\n\t\t\tif (!audio_gpio)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(audio_gpio, name) == 0)\n\t\t\t\tbreak;\n\t\t\tif (altname && (strcmp(audio_gpio, altname) == 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tof_node_put(gpio);\n\t\t \n\t\tif (!np)\n\t\t\treturn NULL;\n\t}\n\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (!reg) {\n\t\tof_node_put(np);\n\t\treturn NULL;\n\t}\n\n\t*gpioptr = *reg;\n\n\t \n\tif (*gpioptr < 0x50)\n\t\t*gpioptr += 0x50;\n\n\treg = of_get_property(np, \"audio-gpio-active-state\", NULL);\n\tif (!reg)\n\t\t \n\t\t*gpioactiveptr = 0;\n\telse\n\t\t*gpioactiveptr = *reg;\n\n\treturn np;\n}\n\nstatic void get_irq(struct device_node * np, int *irqptr)\n{\n\tif (np)\n\t\t*irqptr = irq_of_parse_and_map(np, 0);\n\telse\n\t\t*irqptr = 0;\n}\n\n \n#define SWITCH_GPIO(name, v, on)\t\t\t\t\\\n\t(((v)&~1) | ((on)?\t\t\t\t\t\\\n\t\t\t(name##_gpio_activestate==0?4:5):\t\\\n\t\t\t(name##_gpio_activestate==0?5:4)))\n\n#define FTR_GPIO(name, bit)\t\t\t\t\t\\\nstatic void ftr_gpio_set_##name(struct gpio_runtime *rt, int on)\\\n{\t\t\t\t\t\t\t\t\\\n\tint v;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!rt)) return;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (name##_mute_gpio < 0)\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tv = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL,\t\t\\\n\t\t\t      name##_mute_gpio,\t\t\t\\\n\t\t\t      0);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tv = SWITCH_GPIO(name##_mute, v, !on);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,\t\t\\\n\t\t\t  name##_mute_gpio, v);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\trt->implementation_private &= ~(1<<bit);\t\t\\\n\trt->implementation_private |= (!!on << bit);\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int ftr_gpio_get_##name(struct gpio_runtime *rt)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!rt)) return 0;\t\t\t\t\\\n\treturn (rt->implementation_private>>bit)&1;\t\t\\\n}\n\nFTR_GPIO(headphone, 0);\nFTR_GPIO(amp, 1);\nFTR_GPIO(lineout, 2);\nFTR_GPIO(master, 3);\n\nstatic void ftr_gpio_set_hw_reset(struct gpio_runtime *rt, int on)\n{\n\tint v;\n\n\tif (unlikely(!rt)) return;\n\tif (hw_reset_gpio < 0)\n\t\treturn;\n\n\tv = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL,\n\t\t\t      hw_reset_gpio, 0);\n\tv = SWITCH_GPIO(hw_reset, v, on);\n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,\n\t\t\t  hw_reset_gpio, v);\n}\n\nstatic struct gpio_methods methods;\n\nstatic void ftr_gpio_all_amps_off(struct gpio_runtime *rt)\n{\n\tint saved;\n\n\tif (unlikely(!rt)) return;\n\tsaved = rt->implementation_private;\n\tftr_gpio_set_headphone(rt, 0);\n\tftr_gpio_set_amp(rt, 0);\n\tftr_gpio_set_lineout(rt, 0);\n\tif (methods.set_master)\n\t\tftr_gpio_set_master(rt, 0);\n\trt->implementation_private = saved;\n}\n\nstatic void ftr_gpio_all_amps_restore(struct gpio_runtime *rt)\n{\n\tint s;\n\n\tif (unlikely(!rt)) return;\n\ts = rt->implementation_private;\n\tftr_gpio_set_headphone(rt, (s>>0)&1);\n\tftr_gpio_set_amp(rt, (s>>1)&1);\n\tftr_gpio_set_lineout(rt, (s>>2)&1);\n\tif (methods.set_master)\n\t\tftr_gpio_set_master(rt, (s>>3)&1);\n}\n\nstatic void ftr_handle_notify(struct work_struct *work)\n{\n\tstruct gpio_notification *notif =\n\t\tcontainer_of(work, struct gpio_notification, work.work);\n\n\tmutex_lock(&notif->mutex);\n\tif (notif->notify)\n\t\tnotif->notify(notif->data);\n\tmutex_unlock(&notif->mutex);\n}\n\nstatic void gpio_enable_dual_edge(int gpio)\n{\n\tint v;\n\n\tif (gpio == -1)\n\t\treturn;\n\tv = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio, 0);\n\tv |= 0x80;  \n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, gpio, v);\n}\n\nstatic void ftr_gpio_init(struct gpio_runtime *rt)\n{\n\tget_gpio(\"headphone-mute\", NULL,\n\t\t &headphone_mute_gpio,\n\t\t &headphone_mute_gpio_activestate);\n\tget_gpio(\"amp-mute\", NULL,\n\t\t &amp_mute_gpio,\n\t\t &amp_mute_gpio_activestate);\n\tget_gpio(\"lineout-mute\", NULL,\n\t\t &lineout_mute_gpio,\n\t\t &lineout_mute_gpio_activestate);\n\tget_gpio(\"hw-reset\", \"audio-hw-reset\",\n\t\t &hw_reset_gpio,\n\t\t &hw_reset_gpio_activestate);\n\tif (get_gpio(\"master-mute\", NULL,\n\t\t     &master_mute_gpio,\n\t\t     &master_mute_gpio_activestate)) {\n\t\tmethods.set_master = ftr_gpio_set_master;\n\t\tmethods.get_master = ftr_gpio_get_master;\n\t}\n\n\theadphone_detect_node = get_gpio(\"headphone-detect\", NULL,\n\t\t\t\t\t &headphone_detect_gpio,\n\t\t\t\t\t &headphone_detect_gpio_activestate);\n\t \n\tlineout_detect_node = get_gpio(\"lineout-detect\", \"line-output-detect\",\n\t\t\t\t       &lineout_detect_gpio,\n\t\t\t\t       &lineout_detect_gpio_activestate);\n\tlinein_detect_node = get_gpio(\"linein-detect\", \"line-input-detect\",\n\t\t\t\t      &linein_detect_gpio,\n\t\t\t\t      &linein_detect_gpio_activestate);\n\n\tgpio_enable_dual_edge(headphone_detect_gpio);\n\tgpio_enable_dual_edge(lineout_detect_gpio);\n\tgpio_enable_dual_edge(linein_detect_gpio);\n\n\tget_irq(headphone_detect_node, &headphone_detect_irq);\n\tget_irq(lineout_detect_node, &lineout_detect_irq);\n\tget_irq(linein_detect_node, &linein_detect_irq);\n\n\tftr_gpio_all_amps_off(rt);\n\trt->implementation_private = 0;\n\tINIT_DELAYED_WORK(&rt->headphone_notify.work, ftr_handle_notify);\n\tINIT_DELAYED_WORK(&rt->line_in_notify.work, ftr_handle_notify);\n\tINIT_DELAYED_WORK(&rt->line_out_notify.work, ftr_handle_notify);\n\tmutex_init(&rt->headphone_notify.mutex);\n\tmutex_init(&rt->line_in_notify.mutex);\n\tmutex_init(&rt->line_out_notify.mutex);\n}\n\nstatic void ftr_gpio_exit(struct gpio_runtime *rt)\n{\n\tftr_gpio_all_amps_off(rt);\n\trt->implementation_private = 0;\n\tif (rt->headphone_notify.notify)\n\t\tfree_irq(headphone_detect_irq, &rt->headphone_notify);\n\tif (rt->line_in_notify.gpio_private)\n\t\tfree_irq(linein_detect_irq, &rt->line_in_notify);\n\tif (rt->line_out_notify.gpio_private)\n\t\tfree_irq(lineout_detect_irq, &rt->line_out_notify);\n\tcancel_delayed_work_sync(&rt->headphone_notify.work);\n\tcancel_delayed_work_sync(&rt->line_in_notify.work);\n\tcancel_delayed_work_sync(&rt->line_out_notify.work);\n\tmutex_destroy(&rt->headphone_notify.mutex);\n\tmutex_destroy(&rt->line_in_notify.mutex);\n\tmutex_destroy(&rt->line_out_notify.mutex);\n}\n\nstatic irqreturn_t ftr_handle_notify_irq(int xx, void *data)\n{\n\tstruct gpio_notification *notif = data;\n\n\tschedule_delayed_work(&notif->work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ftr_set_notify(struct gpio_runtime *rt,\n\t\t\t  enum notify_type type,\n\t\t\t  notify_func_t notify,\n\t\t\t  void *data)\n{\n\tstruct gpio_notification *notif;\n\tnotify_func_t old;\n\tint irq;\n\tchar *name;\n\tint err = -EBUSY;\n\n\tswitch (type) {\n\tcase AOA_NOTIFY_HEADPHONE:\n\t\tnotif = &rt->headphone_notify;\n\t\tname = \"headphone-detect\";\n\t\tirq = headphone_detect_irq;\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_IN:\n\t\tnotif = &rt->line_in_notify;\n\t\tname = \"linein-detect\";\n\t\tirq = linein_detect_irq;\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_OUT:\n\t\tnotif = &rt->line_out_notify;\n\t\tname = \"lineout-detect\";\n\t\tirq = lineout_detect_irq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!irq)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&notif->mutex);\n\n\told = notif->notify;\n\n\tif (!old && !notify) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (old && notify) {\n\t\tif (old == notify && notif->data == data)\n\t\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (old && !notify)\n\t\tfree_irq(irq, notif);\n\n\tif (!old && notify) {\n\t\terr = request_irq(irq, ftr_handle_notify_irq, 0, name, notif);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tnotif->notify = notify;\n\tnotif->data = data;\n\n\terr = 0;\n out_unlock:\n\tmutex_unlock(&notif->mutex);\n\treturn err;\n}\n\nstatic int ftr_get_detect(struct gpio_runtime *rt,\n\t\t\t  enum notify_type type)\n{\n\tint gpio, ret, active;\n\n\tswitch (type) {\n\tcase AOA_NOTIFY_HEADPHONE:\n\t\tgpio = headphone_detect_gpio;\n\t\tactive = headphone_detect_gpio_activestate;\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_IN:\n\t\tgpio = linein_detect_gpio;\n\t\tactive = linein_detect_gpio_activestate;\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_OUT:\n\t\tgpio = lineout_detect_gpio;\n\t\tactive = lineout_detect_gpio_activestate;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (gpio == -1)\n\t\treturn -ENODEV;\n\n\tret = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ((ret >> 1) & 1) == active;\n}\n\nstatic struct gpio_methods methods = {\n\t.init\t\t\t= ftr_gpio_init,\n\t.exit\t\t\t= ftr_gpio_exit,\n\t.all_amps_off\t\t= ftr_gpio_all_amps_off,\n\t.all_amps_restore\t= ftr_gpio_all_amps_restore,\n\t.set_headphone\t\t= ftr_gpio_set_headphone,\n\t.set_speakers\t\t= ftr_gpio_set_amp,\n\t.set_lineout\t\t= ftr_gpio_set_lineout,\n\t.set_hw_reset\t\t= ftr_gpio_set_hw_reset,\n\t.get_headphone\t\t= ftr_gpio_get_headphone,\n\t.get_speakers\t\t= ftr_gpio_get_amp,\n\t.get_lineout\t\t= ftr_gpio_get_lineout,\n\t.set_notify\t\t= ftr_set_notify,\n\t.get_detect\t\t= ftr_get_detect,\n};\n\nstruct gpio_methods *ftr_gpio_methods = &methods;\nEXPORT_SYMBOL_GPL(ftr_gpio_methods);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}