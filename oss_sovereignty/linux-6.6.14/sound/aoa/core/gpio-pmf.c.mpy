{
  "module_name": "gpio-pmf.c",
  "hash_id": "aa53be10a717449018df39f1cfa6e0942891ddf9f0b9b4cd57d684d22be996a7",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/core/gpio-pmf.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/pmac_feature.h>\n#include <asm/pmac_pfunc.h>\n#include \"../aoa.h\"\n\n#define PMF_GPIO(name, bit)\t\t\t\t\t\\\nstatic void pmf_gpio_set_##name(struct gpio_runtime *rt, int on)\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct pmf_args args = { .count = 1, .u[0].v = !on };\t\\\n\tint rc;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tif (unlikely(!rt)) return;\t\t\t\t\\\n\trc = pmf_call_function(rt->node, #name \"-mute\", &args);\t\\\n\tif (rc && rc != -ENODEV)\t\t\t\t\\\n\t\tprintk(KERN_WARNING \"pmf_gpio_set_\" #name\t\\\n\t\t\" failed, rc: %d\\n\", rc);\t\t\t\\\n\trt->implementation_private &= ~(1<<bit);\t\t\\\n\trt->implementation_private |= (!!on << bit);\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int pmf_gpio_get_##name(struct gpio_runtime *rt)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!rt)) return 0;\t\t\t\t\\\n\treturn (rt->implementation_private>>bit)&1;\t\t\\\n}\n\nPMF_GPIO(headphone, 0);\nPMF_GPIO(amp, 1);\nPMF_GPIO(lineout, 2);\n\nstatic void pmf_gpio_set_hw_reset(struct gpio_runtime *rt, int on)\n{\n\tstruct pmf_args args = { .count = 1, .u[0].v = !!on };\n\tint rc;\n\n\tif (unlikely(!rt)) return;\n\trc = pmf_call_function(rt->node, \"hw-reset\", &args);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"pmf_gpio_set_hw_reset\"\n\t\t       \" failed, rc: %d\\n\", rc);\n}\n\nstatic void pmf_gpio_all_amps_off(struct gpio_runtime *rt)\n{\n\tint saved;\n\n\tif (unlikely(!rt)) return;\n\tsaved = rt->implementation_private;\n\tpmf_gpio_set_headphone(rt, 0);\n\tpmf_gpio_set_amp(rt, 0);\n\tpmf_gpio_set_lineout(rt, 0);\n\trt->implementation_private = saved;\n}\n\nstatic void pmf_gpio_all_amps_restore(struct gpio_runtime *rt)\n{\n\tint s;\n\n\tif (unlikely(!rt)) return;\n\ts = rt->implementation_private;\n\tpmf_gpio_set_headphone(rt, (s>>0)&1);\n\tpmf_gpio_set_amp(rt, (s>>1)&1);\n\tpmf_gpio_set_lineout(rt, (s>>2)&1);\n}\n\nstatic void pmf_handle_notify(struct work_struct *work)\n{\n\tstruct gpio_notification *notif =\n\t\tcontainer_of(work, struct gpio_notification, work.work);\n\n\tmutex_lock(&notif->mutex);\n\tif (notif->notify)\n\t\tnotif->notify(notif->data);\n\tmutex_unlock(&notif->mutex);\n}\n\nstatic void pmf_gpio_init(struct gpio_runtime *rt)\n{\n\tpmf_gpio_all_amps_off(rt);\n\trt->implementation_private = 0;\n\tINIT_DELAYED_WORK(&rt->headphone_notify.work, pmf_handle_notify);\n\tINIT_DELAYED_WORK(&rt->line_in_notify.work, pmf_handle_notify);\n\tINIT_DELAYED_WORK(&rt->line_out_notify.work, pmf_handle_notify);\n\tmutex_init(&rt->headphone_notify.mutex);\n\tmutex_init(&rt->line_in_notify.mutex);\n\tmutex_init(&rt->line_out_notify.mutex);\n}\n\nstatic void pmf_gpio_exit(struct gpio_runtime *rt)\n{\n\tpmf_gpio_all_amps_off(rt);\n\trt->implementation_private = 0;\n\n\tif (rt->headphone_notify.gpio_private)\n\t\tpmf_unregister_irq_client(rt->headphone_notify.gpio_private);\n\tif (rt->line_in_notify.gpio_private)\n\t\tpmf_unregister_irq_client(rt->line_in_notify.gpio_private);\n\tif (rt->line_out_notify.gpio_private)\n\t\tpmf_unregister_irq_client(rt->line_out_notify.gpio_private);\n\n\t \n\tcancel_delayed_work_sync(&rt->headphone_notify.work);\n\tcancel_delayed_work_sync(&rt->line_in_notify.work);\n\tcancel_delayed_work_sync(&rt->line_out_notify.work);\n\n\tmutex_destroy(&rt->headphone_notify.mutex);\n\tmutex_destroy(&rt->line_in_notify.mutex);\n\tmutex_destroy(&rt->line_out_notify.mutex);\n\n\tkfree(rt->headphone_notify.gpio_private);\n\tkfree(rt->line_in_notify.gpio_private);\n\tkfree(rt->line_out_notify.gpio_private);\n}\n\nstatic void pmf_handle_notify_irq(void *data)\n{\n\tstruct gpio_notification *notif = data;\n\n\tschedule_delayed_work(&notif->work, 0);\n}\n\nstatic int pmf_set_notify(struct gpio_runtime *rt,\n\t\t\t  enum notify_type type,\n\t\t\t  notify_func_t notify,\n\t\t\t  void *data)\n{\n\tstruct gpio_notification *notif;\n\tnotify_func_t old;\n\tstruct pmf_irq_client *irq_client;\n\tchar *name;\n\tint err = -EBUSY;\n\n\tswitch (type) {\n\tcase AOA_NOTIFY_HEADPHONE:\n\t\tnotif = &rt->headphone_notify;\n\t\tname = \"headphone-detect\";\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_IN:\n\t\tnotif = &rt->line_in_notify;\n\t\tname = \"linein-detect\";\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_OUT:\n\t\tnotif = &rt->line_out_notify;\n\t\tname = \"lineout-detect\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&notif->mutex);\n\n\told = notif->notify;\n\n\tif (!old && !notify) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (old && notify) {\n\t\tif (old == notify && notif->data == data)\n\t\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (old && !notify) {\n\t\tirq_client = notif->gpio_private;\n\t\tpmf_unregister_irq_client(irq_client);\n\t\tkfree(irq_client);\n\t\tnotif->gpio_private = NULL;\n\t}\n\tif (!old && notify) {\n\t\tirq_client = kzalloc(sizeof(struct pmf_irq_client),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!irq_client) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tirq_client->data = notif;\n\t\tirq_client->handler = pmf_handle_notify_irq;\n\t\tirq_client->owner = THIS_MODULE;\n\t\terr = pmf_register_irq_client(rt->node,\n\t\t\t\t\t      name,\n\t\t\t\t\t      irq_client);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"snd-aoa: gpio layer failed to\"\n\t\t\t\t\t\" register %s irq (%d)\\n\", name, err);\n\t\t\tkfree(irq_client);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tnotif->gpio_private = irq_client;\n\t}\n\tnotif->notify = notify;\n\tnotif->data = data;\n\n\terr = 0;\n out_unlock:\n\tmutex_unlock(&notif->mutex);\n\treturn err;\n}\n\nstatic int pmf_get_detect(struct gpio_runtime *rt,\n\t\t\t  enum notify_type type)\n{\n\tchar *name;\n\tint err = -EBUSY, ret;\n\tstruct pmf_args args = { .count = 1, .u[0].p = &ret };\n\n\tswitch (type) {\n\tcase AOA_NOTIFY_HEADPHONE:\n\t\tname = \"headphone-detect\";\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_IN:\n\t\tname = \"linein-detect\";\n\t\tbreak;\n\tcase AOA_NOTIFY_LINE_OUT:\n\t\tname = \"lineout-detect\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = pmf_call_function(rt->node, name, &args);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}\n\nstatic struct gpio_methods methods = {\n\t.init\t\t\t= pmf_gpio_init,\n\t.exit\t\t\t= pmf_gpio_exit,\n\t.all_amps_off\t\t= pmf_gpio_all_amps_off,\n\t.all_amps_restore\t= pmf_gpio_all_amps_restore,\n\t.set_headphone\t\t= pmf_gpio_set_headphone,\n\t.set_speakers\t\t= pmf_gpio_set_amp,\n\t.set_lineout\t\t= pmf_gpio_set_lineout,\n\t.set_hw_reset\t\t= pmf_gpio_set_hw_reset,\n\t.get_headphone\t\t= pmf_gpio_get_headphone,\n\t.get_speakers\t\t= pmf_gpio_get_amp,\n\t.get_lineout\t\t= pmf_gpio_get_lineout,\n\t.set_notify\t\t= pmf_set_notify,\n\t.get_detect\t\t= pmf_get_detect,\n};\n\nstruct gpio_methods *pmf_gpio_methods = &methods;\nEXPORT_SYMBOL_GPL(pmf_gpio_methods);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}