{
  "module_name": "layout.c",
  "hash_id": "6c0ded8498b862779e50c499e96c27081bf4fe67fe6e4d69ba85a3cc09bb2501",
  "original_prompt": "Ingested from linux-6.6.14/sound/aoa/fabrics/layout.c",
  "human_readable_source": "\n \n#include <asm/prom.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"../aoa.h\"\n#include \"../soundbus/soundbus.h\"\n\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Layout-ID fabric for snd-aoa\");\n\n#define MAX_CODECS_PER_BUS\t2\n\n \n#define CC_SPEAKERS\t(1<<0)\n#define CC_HEADPHONE\t(1<<1)\n#define CC_LINEOUT\t(1<<2)\n#define CC_DIGITALOUT\t(1<<3)\n#define CC_LINEIN\t(1<<4)\n#define CC_MICROPHONE\t(1<<5)\n#define CC_DIGITALIN\t(1<<6)\n \n#define CC_LINEOUT_LABELLED_HEADPHONE\t(1<<7)\n\nstruct codec_connection {\n\t \n\tint connected;\n\t \n\tint codec_bit;\n};\n\nstruct codec_connect_info {\n\tchar *name;\n\tstruct codec_connection *connections;\n};\n\n#define LAYOUT_FLAG_COMBO_LINEOUT_SPDIF\t(1<<0)\n\nstruct layout {\n\tunsigned int layout_id, device_id;\n\tstruct codec_connect_info codecs[MAX_CODECS_PER_BUS];\n\tint flags;\n\n\t \n\tchar *busname;\n\tint pcmid;\n};\n\nMODULE_ALIAS(\"sound-layout-36\");\nMODULE_ALIAS(\"sound-layout-41\");\nMODULE_ALIAS(\"sound-layout-45\");\nMODULE_ALIAS(\"sound-layout-47\");\nMODULE_ALIAS(\"sound-layout-48\");\nMODULE_ALIAS(\"sound-layout-49\");\nMODULE_ALIAS(\"sound-layout-50\");\nMODULE_ALIAS(\"sound-layout-51\");\nMODULE_ALIAS(\"sound-layout-56\");\nMODULE_ALIAS(\"sound-layout-57\");\nMODULE_ALIAS(\"sound-layout-58\");\nMODULE_ALIAS(\"sound-layout-60\");\nMODULE_ALIAS(\"sound-layout-61\");\nMODULE_ALIAS(\"sound-layout-62\");\nMODULE_ALIAS(\"sound-layout-64\");\nMODULE_ALIAS(\"sound-layout-65\");\nMODULE_ALIAS(\"sound-layout-66\");\nMODULE_ALIAS(\"sound-layout-67\");\nMODULE_ALIAS(\"sound-layout-68\");\nMODULE_ALIAS(\"sound-layout-69\");\nMODULE_ALIAS(\"sound-layout-70\");\nMODULE_ALIAS(\"sound-layout-72\");\nMODULE_ALIAS(\"sound-layout-76\");\nMODULE_ALIAS(\"sound-layout-80\");\nMODULE_ALIAS(\"sound-layout-82\");\nMODULE_ALIAS(\"sound-layout-84\");\nMODULE_ALIAS(\"sound-layout-86\");\nMODULE_ALIAS(\"sound-layout-90\");\nMODULE_ALIAS(\"sound-layout-92\");\nMODULE_ALIAS(\"sound-layout-94\");\nMODULE_ALIAS(\"sound-layout-96\");\nMODULE_ALIAS(\"sound-layout-98\");\nMODULE_ALIAS(\"sound-layout-100\");\n\nMODULE_ALIAS(\"aoa-device-id-14\");\nMODULE_ALIAS(\"aoa-device-id-22\");\nMODULE_ALIAS(\"aoa-device-id-31\");\nMODULE_ALIAS(\"aoa-device-id-35\");\nMODULE_ALIAS(\"aoa-device-id-44\");\n\n \nstatic struct codec_connection onyx_connections_nomic[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE | CC_LINEOUT,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_DIGITALOUT,\n\t\t.codec_bit = 1,\n\t},\n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection onyx_connections_noheadphones[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_LINEOUT |\n\t\t\t     CC_LINEOUT_LABELLED_HEADPHONE,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_DIGITALOUT,\n\t\t.codec_bit = 1,\n\t},\n\t \n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{\n\t\t.connected = CC_MICROPHONE,\n\t\t.codec_bit = 3,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection onyx_connections_reallineout[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_LINEOUT | CC_HEADPHONE,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_DIGITALOUT,\n\t\t.codec_bit = 1,\n\t},\n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection tas_connections_nolineout[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{\n\t\t.connected = CC_MICROPHONE,\n\t\t.codec_bit = 3,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection tas_connections_noline[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_MICROPHONE,\n\t\t.codec_bit = 3,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection tas_connections_nomic[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE | CC_LINEOUT,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{}  \n};\n\n \nstatic struct codec_connection tas_connections_all[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE | CC_LINEOUT,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_LINEIN,\n\t\t.codec_bit = 2,\n\t},\n\t{\n\t\t.connected = CC_MICROPHONE,\n\t\t.codec_bit = 3,\n\t},\n\t{}  \n};\n\nstatic struct codec_connection toonie_connections[] = {\n\t{\n\t\t.connected = CC_SPEAKERS | CC_HEADPHONE,\n\t\t.codec_bit = 0,\n\t},\n\t{}  \n};\n\nstatic struct codec_connection topaz_input[] = {\n\t{\n\t\t.connected = CC_DIGITALIN,\n\t\t.codec_bit = 0,\n\t},\n\t{}  \n};\n\nstatic struct codec_connection topaz_output[] = {\n\t{\n\t\t.connected = CC_DIGITALOUT,\n\t\t.codec_bit = 1,\n\t},\n\t{}  \n};\n\nstatic struct codec_connection topaz_inout[] = {\n\t{\n\t\t.connected = CC_DIGITALIN,\n\t\t.codec_bit = 0,\n\t},\n\t{\n\t\t.connected = CC_DIGITALOUT,\n\t\t.codec_bit = 1,\n\t},\n\t{}  \n};\n\nstatic struct layout layouts[] = {\n\t \n\t{ .layout_id = 82,\n\t  .flags = LAYOUT_FLAG_COMBO_LINEOUT_SPDIF,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 60,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_reallineout,\n\t  },\n\t},\n\t \n\t{ .layout_id = 61,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 64,\n\t  .flags = LAYOUT_FLAG_COMBO_LINEOUT_SPDIF,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t \n\t{ .layout_id = 65,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 84,\n\t  .flags = LAYOUT_FLAG_COMBO_LINEOUT_SPDIF,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 45,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 68,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_nomic,\n\t  },\n\t},\n\t \n\t{ .layout_id = 69,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t  .busname = \"digital in\", .pcmid = 1 },\n\t \n\t{ .layout_id = 70,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nolineout,\n\t  },\n\t},\n\t \n\t{ .layout_id = 51,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nolineout,\n\t  },\n\t},\n\t \n\t{ .device_id = 31,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nolineout,\n\t  },\n\t},\n\t \n\t{ .device_id = 44,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_all,\n\t  },\n\t},\n\t \n\t{ .layout_id = 80,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_noline,\n\t  },\n\t},\n\t \n\t{ .layout_id = 72,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nolineout,\n\t  },\n\t},\n\t \n\t{ .layout_id = 86,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_nomic,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t \n\t{ .layout_id = 92,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nolineout,\n\t  },\n\t},\n\t \n\t{ .layout_id = 58,\n\t  .codecs[0] = {\n\t\t.name = \"toonie\",\n\t\t.connections = toonie_connections,\n\t  },\n\t},\n\t{\n\t  .layout_id = 96,\n\t  .codecs[0] = {\n\t  \t.name = \"onyx\",\n\t  \t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t \n\t{ .layout_id = 41,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_all,\n\t  },\n\t},\n\t{ .layout_id = 36,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nomic,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_inout,\n\t  },\n\t},\n\t{ .layout_id = 47,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t{ .layout_id = 48,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t{ .layout_id = 49,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_nomic,\n\t  },\n\t},\n\t{ .layout_id = 50,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t{ .layout_id = 56,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t{ .layout_id = 57,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t{ .layout_id = 62,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_output,\n\t  },\n\t},\n\t{ .layout_id = 66,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t{ .layout_id = 67,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t},\n\t{ .layout_id = 76,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_nomic,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_inout,\n\t  },\n\t},\n\t{ .layout_id = 90,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_noline,\n\t  },\n\t},\n\t{ .layout_id = 94,\n\t  .codecs[0] = {\n\t\t.name = \"onyx\",\n\t\t \n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t{ .layout_id = 98,\n\t  .codecs[0] = {\n\t\t.name = \"toonie\",\n\t\t.connections = toonie_connections,\n\t  },\n\t},\n\t{ .layout_id = 100,\n\t  .codecs[0] = {\n\t\t.name = \"topaz\",\n\t\t.connections = topaz_input,\n\t  },\n\t  .codecs[1] = {\n\t\t.name = \"onyx\",\n\t\t.connections = onyx_connections_noheadphones,\n\t  },\n\t},\n\t \n\t{ .device_id = 14,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_noline,\n\t  },\n\t},\n\t \n\t{ .device_id = 22,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_all,\n\t  },\n\t},\n\t \n\t{ .device_id = 35,\n\t  .codecs[0] = {\n\t\t.name = \"tas\",\n\t\t.connections = tas_connections_all,\n\t  },\n\t},\n\t{}\n};\n\nstatic struct layout *find_layout_by_id(unsigned int id)\n{\n\tstruct layout *l;\n\n\tl = layouts;\n\twhile (l->codecs[0].name) {\n\t\tif (l->layout_id == id)\n\t\t\treturn l;\n\t\tl++;\n\t}\n\treturn NULL;\n}\n\nstatic struct layout *find_layout_by_device(unsigned int id)\n{\n\tstruct layout *l;\n\n\tl = layouts;\n\twhile (l->codecs[0].name) {\n\t\tif (l->device_id == id)\n\t\t\treturn l;\n\t\tl++;\n\t}\n\treturn NULL;\n}\n\nstatic void use_layout(struct layout *l)\n{\n\tint i;\n\n\tfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\n\t\tif (l->codecs[i].name) {\n\t\t\trequest_module(\"snd-aoa-codec-%s\", l->codecs[i].name);\n\t\t}\n\t}\n\t \n}\n\nstruct layout_dev;\n\nstruct layout_dev_ptr {\n\tstruct layout_dev *ptr;\n};\n\nstruct layout_dev {\n\tstruct list_head list;\n\tstruct soundbus_dev *sdev;\n\tstruct device_node *sound;\n\tstruct aoa_codec *codecs[MAX_CODECS_PER_BUS];\n\tstruct layout *layout;\n\tstruct gpio_runtime gpio;\n\n\t \n\tstruct snd_kcontrol *headphone_ctrl;\n\tstruct snd_kcontrol *lineout_ctrl;\n\tstruct snd_kcontrol *speaker_ctrl;\n\tstruct snd_kcontrol *master_ctrl;\n\tstruct snd_kcontrol *headphone_detected_ctrl;\n\tstruct snd_kcontrol *lineout_detected_ctrl;\n\n\tstruct layout_dev_ptr selfptr_headphone;\n\tstruct layout_dev_ptr selfptr_lineout;\n\n\tu32 have_lineout_detect:1,\n\t    have_headphone_detect:1,\n\t    switch_on_headphone:1,\n\t    switch_on_lineout:1;\n};\n\nstatic LIST_HEAD(layouts_list);\nstatic int layouts_list_items;\n \nstatic struct layout_dev *layout_device;\n\n#define control_info\tsnd_ctl_boolean_mono_info\n\n#define AMP_CONTROL(n, description)\t\t\t\t\t\\\nstatic int n##_control_get(struct snd_kcontrol *kcontrol,\t\t\\\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gpio_runtime *gpio = snd_kcontrol_chip(kcontrol);\t\\\n\tif (gpio->methods && gpio->methods->get_##n)\t\t\t\\\n\t\tucontrol->value.integer.value[0] =\t\t\t\\\n\t\t\tgpio->methods->get_##n(gpio);\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int n##_control_put(struct snd_kcontrol *kcontrol,\t\t\\\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct gpio_runtime *gpio = snd_kcontrol_chip(kcontrol);\t\\\n\tif (gpio->methods && gpio->methods->set_##n)\t\t\t\\\n\t\tgpio->methods->set_##n(gpio,\t\t\t\t\\\n\t\t\t!!ucontrol->value.integer.value[0]);\t\t\\\n\treturn 1;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const struct snd_kcontrol_new n##_ctl = {\t\t\t\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t\\\n\t.name = description,\t\t\t\t\t\t\\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,                      \\\n\t.info = control_info,\t\t\t\t\t\t\\\n\t.get = n##_control_get,\t\t\t\t\t\t\\\n\t.put = n##_control_put,\t\t\t\t\t\t\\\n}\n\nAMP_CONTROL(headphone, \"Headphone Switch\");\nAMP_CONTROL(speakers, \"Speakers Switch\");\nAMP_CONTROL(lineout, \"Line-Out Switch\");\nAMP_CONTROL(master, \"Master Switch\");\n\nstatic int detect_choice_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\n\n\tswitch (kcontrol->private_value) {\n\tcase 0:\n\t\tucontrol->value.integer.value[0] = ldev->switch_on_headphone;\n\t\tbreak;\n\tcase 1:\n\t\tucontrol->value.integer.value[0] = ldev->switch_on_lineout;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int detect_choice_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\n\n\tswitch (kcontrol->private_value) {\n\tcase 0:\n\t\tldev->switch_on_headphone = !!ucontrol->value.integer.value[0];\n\t\tbreak;\n\tcase 1:\n\t\tldev->switch_on_lineout = !!ucontrol->value.integer.value[0];\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new headphone_detect_choice = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Headphone Detect Autoswitch\",\n\t.info = control_info,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.get = detect_choice_get,\n\t.put = detect_choice_put,\n\t.private_value = 0,\n};\n\nstatic const struct snd_kcontrol_new lineout_detect_choice = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line-Out Detect Autoswitch\",\n\t.info = control_info,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.get = detect_choice_get,\n\t.put = detect_choice_put,\n\t.private_value = 1,\n};\n\nstatic int detected_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct layout_dev *ldev = snd_kcontrol_chip(kcontrol);\n\tint v;\n\n\tswitch (kcontrol->private_value) {\n\tcase 0:\n\t\tv = ldev->gpio.methods->get_detect(&ldev->gpio,\n\t\t\t\t\t\t   AOA_NOTIFY_HEADPHONE);\n\t\tbreak;\n\tcase 1:\n\t\tv = ldev->gpio.methods->get_detect(&ldev->gpio,\n\t\t\t\t\t\t   AOA_NOTIFY_LINE_OUT);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tucontrol->value.integer.value[0] = v;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new headphone_detected = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Headphone Detected\",\n\t.info = control_info,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.get = detected_get,\n\t.private_value = 0,\n};\n\nstatic const struct snd_kcontrol_new lineout_detected = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Line-Out Detected\",\n\t.info = control_info,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.get = detected_get,\n\t.private_value = 1,\n};\n\nstatic int check_codec(struct aoa_codec *codec,\n\t\t       struct layout_dev *ldev,\n\t\t       struct codec_connect_info *cci)\n{\n\tconst u32 *ref;\n\tchar propname[32];\n\tstruct codec_connection *cc;\n\n\t \n\tif (of_node_name_eq(codec->node, \"codec\")) {\n\t\tsnprintf(propname, sizeof(propname),\n\t\t\t \"platform-%s-codec-ref\", codec->name);\n\t\tref = of_get_property(ldev->sound, propname, NULL);\n\t\tif (!ref) {\n\t\t\tprintk(KERN_INFO \"snd-aoa-fabric-layout: \"\n\t\t\t\t\"required property %s not present\\n\", propname);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (*ref != codec->node->phandle) {\n\t\t\tprintk(KERN_INFO \"snd-aoa-fabric-layout: \"\n\t\t\t\t\"%s doesn't match!\\n\", propname);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tif (layouts_list_items != 1) {\n\t\t\tprintk(KERN_INFO \"snd-aoa-fabric-layout: \"\n\t\t\t\t\"more than one soundbus, but no references.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tcodec->soundbus_dev = ldev->sdev;\n\tcodec->gpio = &ldev->gpio;\n\n\tcc = cci->connections;\n\tif (!cc)\n\t\treturn -EINVAL;\n\n\tprintk(KERN_INFO \"snd-aoa-fabric-layout: can use this codec\\n\");\n\n\tcodec->connected = 0;\n\tcodec->fabric_data = cc;\n\n\twhile (cc->connected) {\n\t\tcodec->connected |= 1<<cc->codec_bit;\n\t\tcc++;\n\t}\n\n\treturn 0;\n}\n\nstatic int layout_found_codec(struct aoa_codec *codec)\n{\n\tstruct layout_dev *ldev;\n\tint i;\n\n\tlist_for_each_entry(ldev, &layouts_list, list) {\n\t\tfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\n\t\t\tif (!ldev->layout->codecs[i].name)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ldev->layout->codecs[i].name, codec->name) == 0) {\n\t\t\t\tif (check_codec(codec,\n\t\t\t\t\t\tldev,\n\t\t\t\t\t\t&ldev->layout->codecs[i]) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic void layout_remove_codec(struct aoa_codec *codec)\n{\n\tint i;\n\t \n\n\tcodec->soundbus_dev = NULL;\n\tcodec->gpio = NULL;\n\tfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\n\t}\n}\n\nstatic void layout_notify(void *data)\n{\n\tstruct layout_dev_ptr *dptr = data;\n\tstruct layout_dev *ldev;\n\tint v, update;\n\tstruct snd_kcontrol *detected, *c;\n\tstruct snd_card *card = aoa_get_card();\n\n\tldev = dptr->ptr;\n\tif (data == &ldev->selfptr_headphone) {\n\t\tv = ldev->gpio.methods->get_detect(&ldev->gpio, AOA_NOTIFY_HEADPHONE);\n\t\tdetected = ldev->headphone_detected_ctrl;\n\t\tupdate = ldev->switch_on_headphone;\n\t\tif (update) {\n\t\t\tldev->gpio.methods->set_speakers(&ldev->gpio, !v);\n\t\t\tldev->gpio.methods->set_headphone(&ldev->gpio, v);\n\t\t\tldev->gpio.methods->set_lineout(&ldev->gpio, 0);\n\t\t}\n\t} else if (data == &ldev->selfptr_lineout) {\n\t\tv = ldev->gpio.methods->get_detect(&ldev->gpio, AOA_NOTIFY_LINE_OUT);\n\t\tdetected = ldev->lineout_detected_ctrl;\n\t\tupdate = ldev->switch_on_lineout;\n\t\tif (update) {\n\t\t\tldev->gpio.methods->set_speakers(&ldev->gpio, !v);\n\t\t\tldev->gpio.methods->set_headphone(&ldev->gpio, 0);\n\t\t\tldev->gpio.methods->set_lineout(&ldev->gpio, v);\n\t\t}\n\t} else\n\t\treturn;\n\n\tif (detected)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &detected->id);\n\tif (update) {\n\t\tc = ldev->headphone_ctrl;\n\t\tif (c)\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\n\t\tc = ldev->speaker_ctrl;\n\t\tif (c)\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\n\t\tc = ldev->lineout_ctrl;\n\t\tif (c)\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &c->id);\n\t}\n}\n\nstatic void layout_attached_codec(struct aoa_codec *codec)\n{\n\tstruct codec_connection *cc;\n\tstruct snd_kcontrol *ctl;\n\tint headphones, lineout;\n\tstruct layout_dev *ldev = layout_device;\n\n\t \n\n\tcc = codec->fabric_data;\n\n\theadphones = codec->gpio->methods->get_detect(codec->gpio,\n\t\t\t\t\t\t      AOA_NOTIFY_HEADPHONE);\n \tlineout = codec->gpio->methods->get_detect(codec->gpio,\n\t\t\t\t\t\t   AOA_NOTIFY_LINE_OUT);\n\n\tif (codec->gpio->methods->set_master) {\n\t\tctl = snd_ctl_new1(&master_ctl, codec->gpio);\n\t\tldev->master_ctrl = ctl;\n\t\taoa_snd_ctl_add(ctl);\n\t}\n\twhile (cc->connected) {\n\t\tif (cc->connected & CC_SPEAKERS) {\n\t\t\tif (headphones <= 0 && lineout <= 0)\n\t\t\t\tldev->gpio.methods->set_speakers(codec->gpio, 1);\n\t\t\tctl = snd_ctl_new1(&speakers_ctl, codec->gpio);\n\t\t\tldev->speaker_ctrl = ctl;\n\t\t\taoa_snd_ctl_add(ctl);\n\t\t}\n\t\tif (cc->connected & CC_HEADPHONE) {\n\t\t\tif (headphones == 1)\n\t\t\t\tldev->gpio.methods->set_headphone(codec->gpio, 1);\n\t\t\tctl = snd_ctl_new1(&headphone_ctl, codec->gpio);\n\t\t\tldev->headphone_ctrl = ctl;\n\t\t\taoa_snd_ctl_add(ctl);\n\t\t\tldev->have_headphone_detect =\n\t\t\t\t!ldev->gpio.methods\n\t\t\t\t\t->set_notify(&ldev->gpio,\n\t\t\t\t\t\t     AOA_NOTIFY_HEADPHONE,\n\t\t\t\t\t\t     layout_notify,\n\t\t\t\t\t\t     &ldev->selfptr_headphone);\n\t\t\tif (ldev->have_headphone_detect) {\n\t\t\t\tctl = snd_ctl_new1(&headphone_detect_choice,\n\t\t\t\t\t\t   ldev);\n\t\t\t\taoa_snd_ctl_add(ctl);\n\t\t\t\tctl = snd_ctl_new1(&headphone_detected,\n\t\t\t\t\t\t   ldev);\n\t\t\t\tldev->headphone_detected_ctrl = ctl;\n\t\t\t\taoa_snd_ctl_add(ctl);\n\t\t\t}\n\t\t}\n\t\tif (cc->connected & CC_LINEOUT) {\n\t\t\tif (lineout == 1)\n\t\t\t\tldev->gpio.methods->set_lineout(codec->gpio, 1);\n\t\t\tctl = snd_ctl_new1(&lineout_ctl, codec->gpio);\n\t\t\tif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\n\t\t\t\tstrscpy(ctl->id.name,\n\t\t\t\t\t\"Headphone Switch\", sizeof(ctl->id.name));\n\t\t\tldev->lineout_ctrl = ctl;\n\t\t\taoa_snd_ctl_add(ctl);\n\t\t\tldev->have_lineout_detect =\n\t\t\t\t!ldev->gpio.methods\n\t\t\t\t\t->set_notify(&ldev->gpio,\n\t\t\t\t\t\t     AOA_NOTIFY_LINE_OUT,\n\t\t\t\t\t\t     layout_notify,\n\t\t\t\t\t\t     &ldev->selfptr_lineout);\n\t\t\tif (ldev->have_lineout_detect) {\n\t\t\t\tctl = snd_ctl_new1(&lineout_detect_choice,\n\t\t\t\t\t\t   ldev);\n\t\t\t\tif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\n\t\t\t\t\tstrscpy(ctl->id.name,\n\t\t\t\t\t\t\"Headphone Detect Autoswitch\",\n\t\t\t\t\t\tsizeof(ctl->id.name));\n\t\t\t\taoa_snd_ctl_add(ctl);\n\t\t\t\tctl = snd_ctl_new1(&lineout_detected,\n\t\t\t\t\t\t   ldev);\n\t\t\t\tif (cc->connected & CC_LINEOUT_LABELLED_HEADPHONE)\n\t\t\t\t\tstrscpy(ctl->id.name,\n\t\t\t\t\t\t\"Headphone Detected\",\n\t\t\t\t\t\tsizeof(ctl->id.name));\n\t\t\t\tldev->lineout_detected_ctrl = ctl;\n\t\t\t\taoa_snd_ctl_add(ctl);\n\t\t\t}\n\t\t}\n\t\tcc++;\n\t}\n\t \n\tif (ldev->have_headphone_detect)\n\t\tlayout_notify(&ldev->selfptr_headphone);\n\tif (ldev->have_lineout_detect)\n\t\tlayout_notify(&ldev->selfptr_lineout);\n}\n\nstatic struct aoa_fabric layout_fabric = {\n\t.name = \"SoundByLayout\",\n\t.owner = THIS_MODULE,\n\t.found_codec = layout_found_codec,\n\t.remove_codec = layout_remove_codec,\n\t.attached_codec = layout_attached_codec,\n};\n\nstatic int aoa_fabric_layout_probe(struct soundbus_dev *sdev)\n{\n\tstruct device_node *sound = NULL;\n\tconst unsigned int *id;\n\tstruct layout *layout = NULL;\n\tstruct layout_dev *ldev = NULL;\n\tint err;\n\n\t \n\tif (layout_device)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_child_of_node(sdev->ofdev.dev.of_node, sound) {\n\t\tif (of_node_is_type(sound, \"soundchip\"))\n\t\t\tbreak;\n\t}\n\tif (!sound)\n\t\treturn -ENODEV;\n\n\tid = of_get_property(sound, \"layout-id\", NULL);\n\tif (id) {\n\t\tlayout = find_layout_by_id(*id);\n\t} else {\n\t\tid = of_get_property(sound, \"device-id\", NULL);\n\t\tif (id)\n\t\t\tlayout = find_layout_by_device(*id);\n\t}\n\n\tif (!layout) {\n\t\tprintk(KERN_ERR \"snd-aoa-fabric-layout: unknown layout\\n\");\n\t\tgoto outnodev;\n\t}\n\n\tldev = kzalloc(sizeof(struct layout_dev), GFP_KERNEL);\n\tif (!ldev)\n\t\tgoto outnodev;\n\n\tlayout_device = ldev;\n\tldev->sdev = sdev;\n\tldev->sound = sound;\n\tldev->layout = layout;\n\tldev->gpio.node = sound->parent;\n\tswitch (layout->layout_id) {\n\tcase 0:   \n\tcase 41:  \n\tcase 51:  \n\tcase 58:  \n\t\tldev->gpio.methods = ftr_gpio_methods;\n\t\tprintk(KERN_DEBUG\n\t\t       \"snd-aoa-fabric-layout: Using direct GPIOs\\n\");\n\t\tbreak;\n\tdefault:\n\t\tldev->gpio.methods = pmf_gpio_methods;\n\t\tprintk(KERN_DEBUG\n\t\t       \"snd-aoa-fabric-layout: Using PMF GPIOs\\n\");\n\t}\n\tldev->selfptr_headphone.ptr = ldev;\n\tldev->selfptr_lineout.ptr = ldev;\n\tdev_set_drvdata(&sdev->ofdev.dev, ldev);\n\tlist_add(&ldev->list, &layouts_list);\n\tlayouts_list_items++;\n\n\t \n\tsdev->pcmid = ldev->layout->pcmid;\n\tif (ldev->layout->busname) {\n\t\tsdev->pcmname = ldev->layout->busname;\n\t} else {\n\t\tsdev->pcmname = \"Master\";\n\t}\n\n\tldev->gpio.methods->init(&ldev->gpio);\n\n\terr = aoa_fabric_register(&layout_fabric, &sdev->ofdev.dev);\n\tif (err && err != -EALREADY) {\n\t\tprintk(KERN_INFO \"snd-aoa-fabric-layout: can't use,\"\n\t\t\t\t \" another fabric is active!\\n\");\n\t\tgoto outlistdel;\n\t}\n\n\tuse_layout(layout);\n\tldev->switch_on_headphone = 1;\n\tldev->switch_on_lineout = 1;\n\treturn 0;\n outlistdel:\n\t \n\tldev->gpio.methods->exit(&ldev->gpio);\n\t \n\tsdev->pcmname = NULL;\n\tsdev->pcmid = -1;\n\tlist_del(&ldev->list);\n\tlayouts_list_items--;\n\tkfree(ldev);\n outnodev:\n \tof_node_put(sound);\n \tlayout_device = NULL;\n\treturn -ENODEV;\n}\n\nstatic void aoa_fabric_layout_remove(struct soundbus_dev *sdev)\n{\n\tstruct layout_dev *ldev = dev_get_drvdata(&sdev->ofdev.dev);\n\tint i;\n\n\tfor (i=0; i<MAX_CODECS_PER_BUS; i++) {\n\t\tif (ldev->codecs[i]) {\n\t\t\taoa_fabric_unlink_codec(ldev->codecs[i]);\n\t\t}\n\t\tldev->codecs[i] = NULL;\n\t}\n\tlist_del(&ldev->list);\n\tlayouts_list_items--;\n\tof_node_put(ldev->sound);\n\n\tldev->gpio.methods->set_notify(&ldev->gpio,\n\t\t\t\t       AOA_NOTIFY_HEADPHONE,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\tldev->gpio.methods->set_notify(&ldev->gpio,\n\t\t\t\t       AOA_NOTIFY_LINE_OUT,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\n\tldev->gpio.methods->exit(&ldev->gpio);\n\tlayout_device = NULL;\n\tkfree(ldev);\n\tsdev->pcmid = -1;\n\tsdev->pcmname = NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int aoa_fabric_layout_suspend(struct device *dev)\n{\n\tstruct layout_dev *ldev = dev_get_drvdata(dev);\n\n\tif (ldev->gpio.methods && ldev->gpio.methods->all_amps_off)\n\t\tldev->gpio.methods->all_amps_off(&ldev->gpio);\n\n\treturn 0;\n}\n\nstatic int aoa_fabric_layout_resume(struct device *dev)\n{\n\tstruct layout_dev *ldev = dev_get_drvdata(dev);\n\n\tif (ldev->gpio.methods && ldev->gpio.methods->all_amps_restore)\n\t\tldev->gpio.methods->all_amps_restore(&ldev->gpio);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(aoa_fabric_layout_pm_ops,\n\taoa_fabric_layout_suspend, aoa_fabric_layout_resume);\n\n#endif\n\nstatic struct soundbus_driver aoa_soundbus_driver = {\n\t.name = \"snd_aoa_soundbus_drv\",\n\t.owner = THIS_MODULE,\n\t.probe = aoa_fabric_layout_probe,\n\t.remove = aoa_fabric_layout_remove,\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &aoa_fabric_layout_pm_ops,\n#endif\n\t}\n};\n\nstatic int __init aoa_fabric_layout_init(void)\n{\n\treturn soundbus_register_driver(&aoa_soundbus_driver);\n}\n\nstatic void __exit aoa_fabric_layout_exit(void)\n{\n\tsoundbus_unregister_driver(&aoa_soundbus_driver);\n\taoa_fabric_unregister(&layout_fabric);\n}\n\nmodule_init(aoa_fabric_layout_init);\nmodule_exit(aoa_fabric_layout_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}