{
  "module_name": "snd-n64.c",
  "hash_id": "6543416f2aaef12060633a48241781698238ef7bea7d5da0f66b8ca11510bf6e",
  "original_prompt": "Ingested from linux-6.6.14/sound/mips/snd-n64.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\nMODULE_AUTHOR(\"Lauri Kasanen <cand@gmx.com>\");\nMODULE_DESCRIPTION(\"N64 Audio\");\nMODULE_LICENSE(\"GPL\");\n\n#define AI_NTSC_DACRATE 48681812\n#define AI_STATUS_BUSY  (1 << 30)\n#define AI_STATUS_FULL  (1 << 31)\n\n#define AI_ADDR_REG 0\n#define AI_LEN_REG 1\n#define AI_CONTROL_REG 2\n#define AI_STATUS_REG 3\n#define AI_RATE_REG 4\n#define AI_BITCLOCK_REG 5\n\n#define MI_INTR_REG 2\n#define MI_MASK_REG 3\n\n#define MI_INTR_AI 0x04\n\n#define MI_MASK_CLR_AI 0x0010\n#define MI_MASK_SET_AI 0x0020\n\n\nstruct n64audio {\n\tu32 __iomem *ai_reg_base;\n\tu32 __iomem *mi_reg_base;\n\n\tvoid *ring_base;\n\tdma_addr_t ring_base_dma;\n\n\tstruct snd_card *card;\n\n\tstruct {\n\t\tstruct snd_pcm_substream *substream;\n\t\tint pos, nextpos;\n\t\tu32 writesize;\n\t\tu32 bufsize;\n\t\tspinlock_t lock;\n\t} chan;\n};\n\nstatic void n64audio_write_reg(struct n64audio *priv, const u8 reg, const u32 value)\n{\n\twritel(value, priv->ai_reg_base + reg);\n}\n\nstatic void n64mi_write_reg(struct n64audio *priv, const u8 reg, const u32 value)\n{\n\twritel(value, priv->mi_reg_base + reg);\n}\n\nstatic u32 n64mi_read_reg(struct n64audio *priv, const u8 reg)\n{\n\treturn readl(priv->mi_reg_base + reg);\n}\n\nstatic void n64audio_push(struct n64audio *priv)\n{\n\tstruct snd_pcm_runtime *runtime = priv->chan.substream->runtime;\n\tunsigned long flags;\n\tu32 count;\n\n\tspin_lock_irqsave(&priv->chan.lock, flags);\n\n\tcount = priv->chan.writesize;\n\n\tmemcpy(priv->ring_base + priv->chan.nextpos,\n\t       runtime->dma_area + priv->chan.nextpos, count);\n\n\t \n\tn64audio_write_reg(priv, AI_ADDR_REG, priv->ring_base_dma + priv->chan.nextpos);\n\tbarrier();\n\tn64audio_write_reg(priv, AI_LEN_REG, count);\n\n\tpriv->chan.nextpos += count;\n\tpriv->chan.nextpos %= priv->chan.bufsize;\n\n\truntime->delay = runtime->period_size;\n\n\tspin_unlock_irqrestore(&priv->chan.lock, flags);\n}\n\nstatic irqreturn_t n64audio_isr(int irq, void *dev_id)\n{\n\tstruct n64audio *priv = dev_id;\n\tconst u32 intrs = n64mi_read_reg(priv, MI_INTR_REG);\n\tunsigned long flags;\n\n\t \n\tif (!(intrs & MI_INTR_AI))\n\t\treturn IRQ_NONE;\n\n\tn64audio_write_reg(priv, AI_STATUS_REG, 1);\n\n\tif (priv->chan.substream && snd_pcm_running(priv->chan.substream)) {\n\t\tspin_lock_irqsave(&priv->chan.lock, flags);\n\n\t\tpriv->chan.pos = priv->chan.nextpos;\n\n\t\tspin_unlock_irqrestore(&priv->chan.lock, flags);\n\n\t\tsnd_pcm_period_elapsed(priv->chan.substream);\n\t\tif (priv->chan.substream && snd_pcm_running(priv->chan.substream))\n\t\t\tn64audio_push(priv);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware n64audio_pcm_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.formats =          SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates =            SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =         8000,\n\t.rate_max =         48000,\n\t.channels_min =     2,\n\t.channels_max =     2,\n\t.buffer_bytes_max = 32768,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = 32768,\n\t.periods_min =      3,\n\t\n\t.periods_max =      128,\n};\n\nstatic int hw_rule_period_size(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\tint changed = 0;\n\n\t \n\n\tif (is_power_of_2(c->min)) {\n\t\tc->min += 2;\n\t\tchanged = 1;\n\t}\n\tif (is_power_of_2(c->max)) {\n\t\tc->max -= 2;\n\t\tchanged = 1;\n\t}\n\tif (snd_interval_checkempty(c)) {\n\t\tc->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\n\treturn changed;\n}\n\nstatic int n64audio_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->hw = n64audio_pcm_hw;\n\terr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t    hw_rule_period_size, NULL, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int n64audio_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct n64audio *priv = substream->pcm->private_data;\n\tu32 rate;\n\n\trate = ((2 * AI_NTSC_DACRATE / runtime->rate) + 1) / 2 - 1;\n\n\tn64audio_write_reg(priv, AI_RATE_REG, rate);\n\n\trate /= 66;\n\tif (rate > 16)\n\t\trate = 16;\n\tn64audio_write_reg(priv, AI_BITCLOCK_REG, rate - 1);\n\n\tspin_lock_irq(&priv->chan.lock);\n\n\t \n\tpriv->chan.pos = 0;\n\tpriv->chan.nextpos = 0;\n\tpriv->chan.substream = substream;\n\tpriv->chan.writesize = snd_pcm_lib_period_bytes(substream);\n\tpriv->chan.bufsize = snd_pcm_lib_buffer_bytes(substream);\n\n\tspin_unlock_irq(&priv->chan.lock);\n\treturn 0;\n}\n\nstatic int n64audio_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd)\n{\n\tstruct n64audio *priv = substream->pcm->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tn64audio_push(substream->pcm->private_data);\n\t\tn64audio_write_reg(priv, AI_CONTROL_REG, 1);\n\t\tn64mi_write_reg(priv, MI_MASK_REG, MI_MASK_SET_AI);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tn64audio_write_reg(priv, AI_CONTROL_REG, 0);\n\t\tn64mi_write_reg(priv, MI_MASK_REG, MI_MASK_CLR_AI);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t n64audio_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct n64audio *priv = substream->pcm->private_data;\n\n\treturn bytes_to_frames(substream->runtime,\n\t\t\t       priv->chan.pos);\n}\n\nstatic int n64audio_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct n64audio *priv = substream->pcm->private_data;\n\n\tpriv->chan.substream = NULL;\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops n64audio_pcm_ops = {\n\t.open =\t\tn64audio_pcm_open,\n\t.prepare =\tn64audio_pcm_prepare,\n\t.trigger =\tn64audio_pcm_trigger,\n\t.pointer =\tn64audio_pcm_pointer,\n\t.close =\tn64audio_pcm_close,\n};\n\n \nstatic int __init n64audio_probe(struct platform_device *pdev)\n{\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct n64audio *priv;\n\tint err, irq;\n\n\terr = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1,\n\t\t\t   SNDRV_DEFAULT_STR1,\n\t\t\t   THIS_MODULE, sizeof(*priv), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv = card->private_data;\n\n\tspin_lock_init(&priv->chan.lock);\n\n\tpriv->card = card;\n\n\tpriv->ring_base = dma_alloc_coherent(card->dev, 32 * 1024, &priv->ring_base_dma,\n\t\t\t\t\t     GFP_DMA|GFP_KERNEL);\n\tif (!priv->ring_base) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_card;\n\t}\n\n\tpriv->mi_reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mi_reg_base)) {\n\t\terr = PTR_ERR(priv->mi_reg_base);\n\t\tgoto fail_dma_alloc;\n\t}\n\n\tpriv->ai_reg_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->ai_reg_base)) {\n\t\terr = PTR_ERR(priv->ai_reg_base);\n\t\tgoto fail_dma_alloc;\n\t}\n\n\terr = snd_pcm_new(card, \"N64 Audio\", 0, 1, 0, &pcm);\n\tif (err < 0)\n\t\tgoto fail_dma_alloc;\n\n\tpcm->private_data = priv;\n\tstrcpy(pcm->name, \"N64 Audio\");\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &n64audio_pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, card->dev, 0, 0);\n\n\tstrcpy(card->driver, \"N64 Audio\");\n\tstrcpy(card->shortname, \"N64 Audio\");\n\tstrcpy(card->longname, \"N64 Audio\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail_dma_alloc;\n\t}\n\tif (devm_request_irq(&pdev->dev, irq, n64audio_isr,\n\t\t\t\tIRQF_SHARED, \"N64 Audio\", priv)) {\n\t\terr = -EBUSY;\n\t\tgoto fail_dma_alloc;\n\t}\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto fail_dma_alloc;\n\n\treturn 0;\n\nfail_dma_alloc:\n\tdma_free_coherent(card->dev, 32 * 1024, priv->ring_base, priv->ring_base_dma);\n\nfail_card:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic struct platform_driver n64audio_driver = {\n\t.driver = {\n\t\t.name = \"n64audio\",\n\t},\n};\n\nstatic int __init n64audio_init(void)\n{\n\treturn platform_driver_probe(&n64audio_driver, n64audio_probe);\n}\n\nmodule_init(n64audio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}