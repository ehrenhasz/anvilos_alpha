{
  "module_name": "sgio2audio.c",
  "hash_id": "6cf6d071c2522e3053c200f8caebf23733365c6015ca9ba1da91d081fee4aa20",
  "original_prompt": "Ingested from linux-6.6.14/sound/mips/sgio2audio.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <asm/ip32/ip32_ints.h>\n#include <asm/ip32/mace.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#define SNDRV_GET_ID\n#include <sound/initval.h>\n#include <sound/ad1843.h>\n\n\nMODULE_AUTHOR(\"Vivien Chappelier <vivien.chappelier@linux-mips.org>\");\nMODULE_DESCRIPTION(\"SGI O2 Audio\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index = SNDRV_DEFAULT_IDX1;   \nstatic char *id = SNDRV_DEFAULT_STR1;    \n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for SGI O2 soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for SGI O2 soundcard.\");\n\n\n#define AUDIO_CONTROL_RESET              BIT(0)  \n#define AUDIO_CONTROL_CODEC_PRESENT      BIT(1)  \n\n#define CODEC_CONTROL_WORD_SHIFT        0\n#define CODEC_CONTROL_READ              BIT(16)\n#define CODEC_CONTROL_ADDRESS_SHIFT     17\n\n#define CHANNEL_CONTROL_RESET           BIT(10)  \n#define CHANNEL_DMA_ENABLE              BIT(9)   \n#define CHANNEL_INT_THRESHOLD_DISABLED  (0 << 5)  \n#define CHANNEL_INT_THRESHOLD_25        (1 << 5)  \n#define CHANNEL_INT_THRESHOLD_50        (2 << 5)  \n#define CHANNEL_INT_THRESHOLD_75        (3 << 5)  \n#define CHANNEL_INT_THRESHOLD_EMPTY     (4 << 5)  \n#define CHANNEL_INT_THRESHOLD_NOT_EMPTY (5 << 5)  \n#define CHANNEL_INT_THRESHOLD_FULL      (6 << 5)  \n#define CHANNEL_INT_THRESHOLD_NOT_FULL  (7 << 5)  \n\n#define CHANNEL_RING_SHIFT              12\n#define CHANNEL_RING_SIZE               (1 << CHANNEL_RING_SHIFT)\n#define CHANNEL_RING_MASK               (CHANNEL_RING_SIZE - 1)\n\n#define CHANNEL_LEFT_SHIFT 40\n#define CHANNEL_RIGHT_SHIFT 8\n\nstruct snd_sgio2audio_chan {\n\tint idx;\n\tstruct snd_pcm_substream *substream;\n\tint pos;\n\tsnd_pcm_uframes_t size;\n\tspinlock_t lock;\n};\n\n \nstruct snd_sgio2audio {\n\tstruct snd_card *card;\n\n\t \n\tstruct snd_ad1843 ad1843;\n\tspinlock_t ad1843_lock;\n\n\t \n\tstruct snd_sgio2audio_chan channel[3];\n\n\t \n\tvoid *ring_base;\n\tdma_addr_t ring_base_dma;\n};\n\n \n\n \nstatic int read_ad1843_reg(void *priv, int reg)\n{\n\tstruct snd_sgio2audio *chip = priv;\n\tint val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->ad1843_lock, flags);\n\n\twriteq((reg << CODEC_CONTROL_ADDRESS_SHIFT) |\n\t       CODEC_CONTROL_READ, &mace->perif.audio.codec_control);\n\twmb();\n\tval = readq(&mace->perif.audio.codec_control);  \n\tudelay(200);\n\n\tval = readq(&mace->perif.audio.codec_read);\n\n\tspin_unlock_irqrestore(&chip->ad1843_lock, flags);\n\treturn val;\n}\n\n \nstatic int write_ad1843_reg(void *priv, int reg, int word)\n{\n\tstruct snd_sgio2audio *chip = priv;\n\tint val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->ad1843_lock, flags);\n\n\twriteq((reg << CODEC_CONTROL_ADDRESS_SHIFT) |\n\t       (word << CODEC_CONTROL_WORD_SHIFT),\n\t       &mace->perif.audio.codec_control);\n\twmb();\n\tval = readq(&mace->perif.audio.codec_control);  \n\tudelay(200);\n\n\tspin_unlock_irqrestore(&chip->ad1843_lock, flags);\n\treturn 0;\n}\n\nstatic int sgio2audio_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = ad1843_get_gain_max(&chip->ad1843,\n\t\t\t\t\t     (int)kcontrol->private_value);\n\treturn 0;\n}\n\nstatic int sgio2audio_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\n\tint vol;\n\n\tvol = ad1843_get_gain(&chip->ad1843, (int)kcontrol->private_value);\n\n\tucontrol->value.integer.value[0] = (vol >> 8) & 0xFF;\n\tucontrol->value.integer.value[1] = vol & 0xFF;\n\n\treturn 0;\n}\n\nstatic int sgio2audio_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\n\tint newvol, oldvol;\n\n\toldvol = ad1843_get_gain(&chip->ad1843, kcontrol->private_value);\n\tnewvol = (ucontrol->value.integer.value[0] << 8) |\n\t\tucontrol->value.integer.value[1];\n\n\tnewvol = ad1843_set_gain(&chip->ad1843, kcontrol->private_value,\n\t\tnewvol);\n\n\treturn newvol != oldvol;\n}\n\nstatic int sgio2audio_source_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[3] = {\n\t\t\"Cam Mic\", \"Mic\", \"Line\"\n\t};\n\treturn snd_ctl_enum_info(uinfo, 1, 3, texts);\n}\n\nstatic int sgio2audio_source_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.enumerated.item[0] = ad1843_get_recsrc(&chip->ad1843);\n\treturn 0;\n}\n\nstatic int sgio2audio_source_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\n\tint newsrc, oldsrc;\n\n\toldsrc = ad1843_get_recsrc(&chip->ad1843);\n\tnewsrc = ad1843_set_recsrc(&chip->ad1843,\n\t\t\t\t   ucontrol->value.enumerated.item[0]);\n\n\treturn newsrc != oldsrc;\n}\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_pcm0 = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"PCM Playback Volume\",\n\t.index          = 0,\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_PCM_0,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_pcm1 = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"PCM Playback Volume\",\n\t.index          = 1,\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_PCM_1,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_reclevel = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Capture Volume\",\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_RECLEV,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_recsource = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Capture Source\",\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info           = sgio2audio_source_info,\n\t.get            = sgio2audio_source_get,\n\t.put            = sgio2audio_source_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_line = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Line Playback Volume\",\n\t.index          = 0,\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_LINE,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_cd = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Line Playback Volume\",\n\t.index          = 1,\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_LINE_2,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n \nstatic const struct snd_kcontrol_new sgio2audio_ctrl_mic = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Mic Playback Volume\",\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = AD1843_GAIN_MIC,\n\t.info           = sgio2audio_gain_info,\n\t.get            = sgio2audio_gain_get,\n\t.put            = sgio2audio_gain_put,\n};\n\n\nstatic int snd_sgio2audio_new_mixer(struct snd_sgio2audio *chip)\n{\n\tint err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_pcm0, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_pcm1, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_reclevel, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_recsource, chip));\n\tif (err < 0)\n\t\treturn err;\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_line, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_cd, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(chip->card,\n\t\t\t  snd_ctl_new1(&sgio2audio_ctrl_mic, chip));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\n \n \nstatic int snd_sgio2audio_dma_pull_frag(struct snd_sgio2audio *chip,\n\t\t\t\t\tunsigned int ch, unsigned int count)\n{\n\tint ret;\n\tunsigned long src_base, src_pos, dst_mask;\n\tunsigned char *dst_base;\n\tint dst_pos;\n\tu64 *src;\n\ts16 *dst;\n\tu64 x;\n\tunsigned long flags;\n\tstruct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;\n\n\tspin_lock_irqsave(&chip->channel[ch].lock, flags);\n\n\tsrc_base = (unsigned long) chip->ring_base | (ch << CHANNEL_RING_SHIFT);\n\tsrc_pos = readq(&mace->perif.audio.chan[ch].read_ptr);\n\tdst_base = runtime->dma_area;\n\tdst_pos = chip->channel[ch].pos;\n\tdst_mask = frames_to_bytes(runtime, runtime->buffer_size) - 1;\n\n\t \n\tchip->channel[ch].size += (count >> 3);  \n\tret = chip->channel[ch].size >= runtime->period_size;\n\tchip->channel[ch].size %= runtime->period_size;\n\n\twhile (count) {\n\t\tsrc = (u64 *)(src_base + src_pos);\n\t\tdst = (s16 *)(dst_base + dst_pos);\n\n\t\tx = *src;\n\t\tdst[0] = (x >> CHANNEL_LEFT_SHIFT) & 0xffff;\n\t\tdst[1] = (x >> CHANNEL_RIGHT_SHIFT) & 0xffff;\n\n\t\tsrc_pos = (src_pos + sizeof(u64)) & CHANNEL_RING_MASK;\n\t\tdst_pos = (dst_pos + 2 * sizeof(s16)) & dst_mask;\n\t\tcount -= sizeof(u64);\n\t}\n\n\twriteq(src_pos, &mace->perif.audio.chan[ch].read_ptr);  \n\tchip->channel[ch].pos = dst_pos;\n\n\tspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\n\treturn ret;\n}\n\n \n \nstatic int snd_sgio2audio_dma_push_frag(struct snd_sgio2audio *chip,\n\t\t\t\t\tunsigned int ch, unsigned int count)\n{\n\tint ret;\n\ts64 l, r;\n\tunsigned long dst_base, dst_pos, src_mask;\n\tunsigned char *src_base;\n\tint src_pos;\n\tu64 *dst;\n\ts16 *src;\n\tunsigned long flags;\n\tstruct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;\n\n\tspin_lock_irqsave(&chip->channel[ch].lock, flags);\n\n\tdst_base = (unsigned long)chip->ring_base | (ch << CHANNEL_RING_SHIFT);\n\tdst_pos = readq(&mace->perif.audio.chan[ch].write_ptr);\n\tsrc_base = runtime->dma_area;\n\tsrc_pos = chip->channel[ch].pos;\n\tsrc_mask = frames_to_bytes(runtime, runtime->buffer_size) - 1;\n\n\t \n\tchip->channel[ch].size += (count >> 3);  \n\tret = chip->channel[ch].size >= runtime->period_size;\n\tchip->channel[ch].size %= runtime->period_size;\n\n\twhile (count) {\n\t\tsrc = (s16 *)(src_base + src_pos);\n\t\tdst = (u64 *)(dst_base + dst_pos);\n\n\t\tl = src[0];  \n\t\tr = src[1];  \n\n\t\t*dst = ((l & 0x00ffffff) << CHANNEL_LEFT_SHIFT) |\n\t\t\t((r & 0x00ffffff) << CHANNEL_RIGHT_SHIFT);\n\n\t\tdst_pos = (dst_pos + sizeof(u64)) & CHANNEL_RING_MASK;\n\t\tsrc_pos = (src_pos + 2 * sizeof(s16)) & src_mask;\n\t\tcount -= sizeof(u64);\n\t}\n\n\twriteq(dst_pos, &mace->perif.audio.chan[ch].write_ptr);  \n\tchip->channel[ch].pos = src_pos;\n\n\tspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\n\treturn ret;\n}\n\nstatic int snd_sgio2audio_dma_start(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\n\tint ch = chan->idx;\n\n\t \n\twriteq(CHANNEL_CONTROL_RESET, &mace->perif.audio.chan[ch].control);\n\tudelay(10);\n\twriteq(0, &mace->perif.audio.chan[ch].control);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\tsnd_sgio2audio_dma_push_frag(chip, ch, CHANNEL_RING_SIZE - 32);\n\t}\n\t \n\twriteq(CHANNEL_DMA_ENABLE | CHANNEL_INT_THRESHOLD_50,\n\t       &mace->perif.audio.chan[ch].control);\n\treturn 0;\n}\n\nstatic int snd_sgio2audio_dma_stop(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\n\n\twriteq(0, &mace->perif.audio.chan[chan->idx].control);\n\treturn 0;\n}\n\nstatic irqreturn_t snd_sgio2audio_dma_in_isr(int irq, void *dev_id)\n{\n\tstruct snd_sgio2audio_chan *chan = dev_id;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_sgio2audio *chip;\n\tint count, ch;\n\n\tsubstream = chan->substream;\n\tchip = snd_pcm_substream_chip(substream);\n\tch = chan->idx;\n\n\t \n\tcount = CHANNEL_RING_SIZE -\n\t\treadq(&mace->perif.audio.chan[ch].depth) - 32;\n\tif (snd_sgio2audio_dma_pull_frag(chip, ch, count))\n\t\tsnd_pcm_period_elapsed(substream);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t snd_sgio2audio_dma_out_isr(int irq, void *dev_id)\n{\n\tstruct snd_sgio2audio_chan *chan = dev_id;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_sgio2audio *chip;\n\tint count, ch;\n\n\tsubstream = chan->substream;\n\tchip = snd_pcm_substream_chip(substream);\n\tch = chan->idx;\n\t \n\tcount = CHANNEL_RING_SIZE -\n\t\treadq(&mace->perif.audio.chan[ch].depth) - 32;\n\tif (snd_sgio2audio_dma_push_frag(chip, ch, count))\n\t\tsnd_pcm_period_elapsed(substream);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t snd_sgio2audio_error_isr(int irq, void *dev_id)\n{\n\tstruct snd_sgio2audio_chan *chan = dev_id;\n\tstruct snd_pcm_substream *substream;\n\n\tsubstream = chan->substream;\n\tsnd_sgio2audio_dma_stop(substream);\n\tsnd_sgio2audio_dma_start(substream);\n\treturn IRQ_HANDLED;\n}\n\n \n \nstatic const struct snd_pcm_hardware snd_sgio2audio_pcm_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.formats =          SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates =            SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =         8000,\n\t.rate_max =         48000,\n\t.channels_min =     2,\n\t.channels_max =     2,\n\t.buffer_bytes_max = 65536,\n\t.period_bytes_min = 32768,\n\t.period_bytes_max = 65536,\n\t.periods_min =      1,\n\t.periods_max =      1024,\n};\n\n \nstatic int snd_sgio2audio_playback1_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_sgio2audio_pcm_hw;\n\truntime->private_data = &chip->channel[1];\n\treturn 0;\n}\n\nstatic int snd_sgio2audio_playback2_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_sgio2audio_pcm_hw;\n\truntime->private_data = &chip->channel[2];\n\treturn 0;\n}\n\n \nstatic int snd_sgio2audio_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_sgio2audio_pcm_hw;\n\truntime->private_data = &chip->channel[0];\n\treturn 0;\n}\n\n \nstatic int snd_sgio2audio_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic int snd_sgio2audio_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\n\tint ch = chan->idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->channel[ch].lock, flags);\n\n\t \n\tchip->channel[ch].pos = 0;\n\tchip->channel[ch].size = 0;\n\tchip->channel[ch].substream = substream;\n\n\t \n\t \n\tswitch (substream->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tad1843_setup_dac(&chip->ad1843,\n\t\t\t\t ch - 1,\n\t\t\t\t runtime->rate,\n\t\t\t\t SNDRV_PCM_FORMAT_S16_LE,\n\t\t\t\t runtime->channels);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tad1843_setup_adc(&chip->ad1843,\n\t\t\t\t runtime->rate,\n\t\t\t\t SNDRV_PCM_FORMAT_S16_LE,\n\t\t\t\t runtime->channels);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\n\treturn 0;\n}\n\n \nstatic int snd_sgio2audio_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tsnd_sgio2audio_dma_start(substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t \n\t\tsnd_sgio2audio_dma_stop(substream);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t\nsnd_sgio2audio_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\n\n\t \n\treturn bytes_to_frames(substream->runtime,\n\t\t\t       chip->channel[chan->idx].pos);\n}\n\n \nstatic const struct snd_pcm_ops snd_sgio2audio_playback1_ops = {\n\t.open =        snd_sgio2audio_playback1_open,\n\t.close =       snd_sgio2audio_pcm_close,\n\t.prepare =     snd_sgio2audio_pcm_prepare,\n\t.trigger =     snd_sgio2audio_pcm_trigger,\n\t.pointer =     snd_sgio2audio_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_sgio2audio_playback2_ops = {\n\t.open =        snd_sgio2audio_playback2_open,\n\t.close =       snd_sgio2audio_pcm_close,\n\t.prepare =     snd_sgio2audio_pcm_prepare,\n\t.trigger =     snd_sgio2audio_pcm_trigger,\n\t.pointer =     snd_sgio2audio_pcm_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_sgio2audio_capture_ops = {\n\t.open =        snd_sgio2audio_capture_open,\n\t.close =       snd_sgio2audio_pcm_close,\n\t.prepare =     snd_sgio2audio_pcm_prepare,\n\t.trigger =     snd_sgio2audio_pcm_trigger,\n\t.pointer =     snd_sgio2audio_pcm_pointer,\n};\n\n \n\n \nstatic int snd_sgio2audio_new_pcm(struct snd_sgio2audio *chip)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\t \n\terr = snd_pcm_new(chip->card, \"SGI O2 Audio\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"SGI O2 DAC1\");\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_sgio2audio_playback1_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_sgio2audio_capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\t \n\terr = snd_pcm_new(chip->card, \"SGI O2 Audio\", 1, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"SGI O2 DAC2\");\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_sgio2audio_playback2_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\n\treturn 0;\n}\n\nstatic struct {\n\tint idx;\n\tint irq;\n\tirqreturn_t (*isr)(int, void *);\n\tconst char *desc;\n} snd_sgio2_isr_table[] = {\n\t{\n\t\t.idx = 0,\n\t\t.irq = MACEISA_AUDIO1_DMAT_IRQ,\n\t\t.isr = snd_sgio2audio_dma_in_isr,\n\t\t.desc = \"Capture DMA Channel 0\"\n\t}, {\n\t\t.idx = 0,\n\t\t.irq = MACEISA_AUDIO1_OF_IRQ,\n\t\t.isr = snd_sgio2audio_error_isr,\n\t\t.desc = \"Capture Overflow\"\n\t}, {\n\t\t.idx = 1,\n\t\t.irq = MACEISA_AUDIO2_DMAT_IRQ,\n\t\t.isr = snd_sgio2audio_dma_out_isr,\n\t\t.desc = \"Playback DMA Channel 1\"\n\t}, {\n\t\t.idx = 1,\n\t\t.irq = MACEISA_AUDIO2_MERR_IRQ,\n\t\t.isr = snd_sgio2audio_error_isr,\n\t\t.desc = \"Memory Error Channel 1\"\n\t}, {\n\t\t.idx = 2,\n\t\t.irq = MACEISA_AUDIO3_DMAT_IRQ,\n\t\t.isr = snd_sgio2audio_dma_out_isr,\n\t\t.desc = \"Playback DMA Channel 2\"\n\t}, {\n\t\t.idx = 2,\n\t\t.irq = MACEISA_AUDIO3_MERR_IRQ,\n\t\t.isr = snd_sgio2audio_error_isr,\n\t\t.desc = \"Memory Error Channel 2\"\n\t}\n};\n\n \n\nstatic int snd_sgio2audio_free(struct snd_sgio2audio *chip)\n{\n\tint i;\n\n\t \n\twriteq(AUDIO_CONTROL_RESET, &mace->perif.audio.control);\n\tudelay(1);\n\twriteq(0, &mace->perif.audio.control);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(snd_sgio2_isr_table); i++)\n\t\tfree_irq(snd_sgio2_isr_table[i].irq,\n\t\t\t &chip->channel[snd_sgio2_isr_table[i].idx]);\n\n\tdma_free_coherent(chip->card->dev, MACEISA_RINGBUFFERS_SIZE,\n\t\t\t  chip->ring_base, chip->ring_base_dma);\n\n\t \n\tkfree(chip);\n\treturn 0;\n}\n\nstatic int snd_sgio2audio_dev_free(struct snd_device *device)\n{\n\tstruct snd_sgio2audio *chip = device->device_data;\n\n\treturn snd_sgio2audio_free(chip);\n}\n\nstatic const struct snd_device_ops ops = {\n\t.dev_free = snd_sgio2audio_dev_free,\n};\n\nstatic int snd_sgio2audio_create(struct snd_card *card,\n\t\t\t\t struct snd_sgio2audio **rchip)\n{\n\tstruct snd_sgio2audio *chip;\n\tint i, err;\n\n\t*rchip = NULL;\n\n\t \n\t \n\tif (!(readq(&mace->perif.audio.control) & AUDIO_CONTROL_CODEC_PRESENT))\n\t\treturn -ENOENT;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->card = card;\n\n\tchip->ring_base = dma_alloc_coherent(card->dev,\n\t\t\t\t\t     MACEISA_RINGBUFFERS_SIZE,\n\t\t\t\t\t     &chip->ring_base_dma, GFP_KERNEL);\n\tif (chip->ring_base == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"sgio2audio: could not allocate ring buffers\\n\");\n\t\tkfree(chip);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&chip->ad1843_lock);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tspin_lock_init(&chip->channel[i].lock);\n\t\tchip->channel[i].idx = i;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(snd_sgio2_isr_table); i++) {\n\t\tif (request_irq(snd_sgio2_isr_table[i].irq,\n\t\t\t\tsnd_sgio2_isr_table[i].isr,\n\t\t\t\t0,\n\t\t\t\tsnd_sgio2_isr_table[i].desc,\n\t\t\t\t&chip->channel[snd_sgio2_isr_table[i].idx])) {\n\t\t\tsnd_sgio2audio_free(chip);\n\t\t\tprintk(KERN_ERR \"sgio2audio: cannot allocate irq %d\\n\",\n\t\t\t       snd_sgio2_isr_table[i].irq);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\twriteq(AUDIO_CONTROL_RESET, &mace->perif.audio.control);\n\tudelay(1);\n\twriteq(0, &mace->perif.audio.control);\n\tmsleep_interruptible(1);  \n\n\t \n\twriteq(chip->ring_base_dma, &mace->perif.ctrl.ringbase);\n\n\t \n\tchip->ad1843.read = read_ad1843_reg;\n\tchip->ad1843.write = write_ad1843_reg;\n\tchip->ad1843.chip = chip;\n\n\t \n\terr = ad1843_init(&chip->ad1843);\n\tif (err < 0) {\n\t\tsnd_sgio2audio_free(chip);\n\t\treturn err;\n\t}\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tsnd_sgio2audio_free(chip);\n\t\treturn err;\n\t}\n\t*rchip = chip;\n\treturn 0;\n}\n\nstatic int snd_sgio2audio_probe(struct platform_device *pdev)\n{\n\tstruct snd_card *card;\n\tstruct snd_sgio2audio *chip;\n\tint err;\n\n\terr = snd_card_new(&pdev->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_sgio2audio_create(card, &chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\terr = snd_sgio2audio_new_pcm(chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\terr = snd_sgio2audio_new_mixer(chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, \"SGI O2 Audio\");\n\tstrcpy(card->shortname, \"SGI O2 Audio\");\n\tsprintf(card->longname, \"%s irq %i-%i\",\n\t\tcard->shortname,\n\t\tMACEISA_AUDIO1_DMAT_IRQ,\n\t\tMACEISA_AUDIO3_MERR_IRQ);\n\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tplatform_set_drvdata(pdev, card);\n\treturn 0;\n}\n\nstatic void snd_sgio2audio_remove(struct platform_device *pdev)\n{\n\tstruct snd_card *card = platform_get_drvdata(pdev);\n\n\tsnd_card_free(card);\n}\n\nstatic struct platform_driver sgio2audio_driver = {\n\t.probe\t= snd_sgio2audio_probe,\n\t.remove_new = snd_sgio2audio_remove,\n\t.driver = {\n\t\t.name\t= \"sgio2audio\",\n\t}\n};\n\nmodule_platform_driver(sgio2audio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}