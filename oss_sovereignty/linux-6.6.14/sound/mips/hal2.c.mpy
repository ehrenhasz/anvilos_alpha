{
  "module_name": "hal2.c",
  "hash_id": "7a3c1b2a2e293528c3d7498d1e2b8fcd6ae5959d0e2348b61065a351db8a9791",
  "original_prompt": "Ingested from linux-6.6.14/sound/mips/hal2.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <asm/sgi/hpc3.h>\n#include <asm/sgi/ip22.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/pcm-indirect.h>\n#include <sound/initval.h>\n\n#include \"hal2.h\"\n\nstatic int index = SNDRV_DEFAULT_IDX1;   \nstatic char *id = SNDRV_DEFAULT_STR1;    \n\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for SGI HAL2 soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for SGI HAL2 soundcard.\");\nMODULE_DESCRIPTION(\"ALSA driver for SGI HAL2 audio\");\nMODULE_AUTHOR(\"Thomas Bogendoerfer\");\nMODULE_LICENSE(\"GPL\");\n\n\n#define H2_BLOCK_SIZE\t1024\n#define H2_BUF_SIZE\t16384\n\nstruct hal2_pbus {\n\tstruct hpc3_pbus_dmacregs *pbus;\n\tint pbusnr;\n\tunsigned int ctrl;\t\t \n};\n\nstruct hal2_desc {\n\tstruct hpc_dma_desc desc;\n\tu32 pad;\t\t\t \n};\n\nstruct hal2_codec {\n\tstruct snd_pcm_indirect pcm_indirect;\n\tstruct snd_pcm_substream *substream;\n\n\tunsigned char *buffer;\n\tdma_addr_t buffer_dma;\n\tstruct hal2_desc *desc;\n\tdma_addr_t desc_dma;\n\tint desc_count;\n\tstruct hal2_pbus pbus;\n\tint voices;\t\t\t \n\tunsigned int sample_rate;\n\tunsigned int master;\t\t \n\tunsigned short mod;\t\t \n\tunsigned short inc;\t\t \n};\n\n#define H2_MIX_OUTPUT_ATT\t0\n#define H2_MIX_INPUT_GAIN\t1\n\nstruct snd_hal2 {\n\tstruct snd_card *card;\n\n\tstruct hal2_ctl_regs *ctl_regs;\t \n\tstruct hal2_aes_regs *aes_regs;\t \n\tstruct hal2_vol_regs *vol_regs;\t \n\tstruct hal2_syn_regs *syn_regs;\t \n\n\tstruct hal2_codec dac;\n\tstruct hal2_codec adc;\n};\n\n#define H2_INDIRECT_WAIT(regs)\twhile (hal2_read(&regs->isr) & H2_ISR_TSTATUS);\n\n#define H2_READ_ADDR(addr)\t(addr | (1<<7))\n#define H2_WRITE_ADDR(addr)\t(addr)\n\nstatic inline u32 hal2_read(u32 *reg)\n{\n\treturn __raw_readl(reg);\n}\n\nstatic inline void hal2_write(u32 val, u32 *reg)\n{\n\t__raw_writel(val, reg);\n}\n\n\nstatic u32 hal2_i_read32(struct snd_hal2 *hal2, u16 addr)\n{\n\tu32 ret;\n\tstruct hal2_ctl_regs *regs = hal2->ctl_regs;\n\n\thal2_write(H2_READ_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n\tret = hal2_read(&regs->idr0) & 0xffff;\n\thal2_write(H2_READ_ADDR(addr) | 0x1, &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n\tret |= (hal2_read(&regs->idr0) & 0xffff) << 16;\n\treturn ret;\n}\n\nstatic void hal2_i_write16(struct snd_hal2 *hal2, u16 addr, u16 val)\n{\n\tstruct hal2_ctl_regs *regs = hal2->ctl_regs;\n\n\thal2_write(val, &regs->idr0);\n\thal2_write(0, &regs->idr1);\n\thal2_write(0, &regs->idr2);\n\thal2_write(0, &regs->idr3);\n\thal2_write(H2_WRITE_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n}\n\nstatic void hal2_i_write32(struct snd_hal2 *hal2, u16 addr, u32 val)\n{\n\tstruct hal2_ctl_regs *regs = hal2->ctl_regs;\n\n\thal2_write(val & 0xffff, &regs->idr0);\n\thal2_write(val >> 16, &regs->idr1);\n\thal2_write(0, &regs->idr2);\n\thal2_write(0, &regs->idr3);\n\thal2_write(H2_WRITE_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n}\n\nstatic void hal2_i_setbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)\n{\n\tstruct hal2_ctl_regs *regs = hal2->ctl_regs;\n\n\thal2_write(H2_READ_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n\thal2_write((hal2_read(&regs->idr0) & 0xffff) | bit, &regs->idr0);\n\thal2_write(0, &regs->idr1);\n\thal2_write(0, &regs->idr2);\n\thal2_write(0, &regs->idr3);\n\thal2_write(H2_WRITE_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n}\n\nstatic void hal2_i_clearbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)\n{\n\tstruct hal2_ctl_regs *regs = hal2->ctl_regs;\n\n\thal2_write(H2_READ_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n\thal2_write((hal2_read(&regs->idr0) & 0xffff) & ~bit, &regs->idr0);\n\thal2_write(0, &regs->idr1);\n\thal2_write(0, &regs->idr2);\n\thal2_write(0, &regs->idr3);\n\thal2_write(H2_WRITE_ADDR(addr), &regs->iar);\n\tH2_INDIRECT_WAIT(regs);\n}\n\nstatic int hal2_gain_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tswitch ((int)kcontrol->private_value) {\n\tcase H2_MIX_OUTPUT_ATT:\n\t\tuinfo->value.integer.max = 31;\n\t\tbreak;\n\tcase H2_MIX_INPUT_GAIN:\n\t\tuinfo->value.integer.max = 15;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int hal2_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);\n\tu32 tmp;\n\tint l, r;\n\n\tswitch ((int)kcontrol->private_value) {\n\tcase H2_MIX_OUTPUT_ATT:\n\t\ttmp = hal2_i_read32(hal2, H2I_DAC_C2);\n\t\tif (tmp & H2I_C2_MUTE) {\n\t\t\tl = 0;\n\t\t\tr = 0;\n\t\t} else {\n\t\t\tl = 31 - ((tmp >> H2I_C2_L_ATT_SHIFT) & 31);\n\t\t\tr = 31 - ((tmp >> H2I_C2_R_ATT_SHIFT) & 31);\n\t\t}\n\t\tbreak;\n\tcase H2_MIX_INPUT_GAIN:\n\t\ttmp = hal2_i_read32(hal2, H2I_ADC_C2);\n\t\tl = (tmp >> H2I_C2_L_GAIN_SHIFT) & 15;\n\t\tr = (tmp >> H2I_C2_R_GAIN_SHIFT) & 15;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tucontrol->value.integer.value[0] = l;\n\tucontrol->value.integer.value[1] = r;\n\n\treturn 0;\n}\n\nstatic int hal2_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);\n\tu32 old, new;\n\tint l, r;\n\n\tl = ucontrol->value.integer.value[0];\n\tr = ucontrol->value.integer.value[1];\n\n\tswitch ((int)kcontrol->private_value) {\n\tcase H2_MIX_OUTPUT_ATT:\n\t\told = hal2_i_read32(hal2, H2I_DAC_C2);\n\t\tnew = old & ~(H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);\n\t\tif (l | r) {\n\t\t\tl = 31 - l;\n\t\t\tr = 31 - r;\n\t\t\tnew |= (l << H2I_C2_L_ATT_SHIFT);\n\t\t\tnew |= (r << H2I_C2_R_ATT_SHIFT);\n\t\t} else\n\t\t\tnew |= H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE;\n\t\thal2_i_write32(hal2, H2I_DAC_C2, new);\n\t\tbreak;\n\tcase H2_MIX_INPUT_GAIN:\n\t\told = hal2_i_read32(hal2, H2I_ADC_C2);\n\t\tnew = old & ~(H2I_C2_L_GAIN_M | H2I_C2_R_GAIN_M);\n\t\tnew |= (l << H2I_C2_L_GAIN_SHIFT);\n\t\tnew |= (r << H2I_C2_R_GAIN_SHIFT);\n\t\thal2_i_write32(hal2, H2I_ADC_C2, new);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn old != new;\n}\n\nstatic const struct snd_kcontrol_new hal2_ctrl_headphone = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Headphone Playback Volume\",\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = H2_MIX_OUTPUT_ATT,\n\t.info           = hal2_gain_info,\n\t.get            = hal2_gain_get,\n\t.put            = hal2_gain_put,\n};\n\nstatic const struct snd_kcontrol_new hal2_ctrl_mic = {\n\t.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name           = \"Mic Capture Volume\",\n\t.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.private_value  = H2_MIX_INPUT_GAIN,\n\t.info           = hal2_gain_info,\n\t.get            = hal2_gain_get,\n\t.put            = hal2_gain_put,\n};\n\nstatic int hal2_mixer_create(struct snd_hal2 *hal2)\n{\n\tint err;\n\n\t \n\thal2_i_write32(hal2, H2I_DAC_C2,\n\t\t       H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);\n\t \n\thal2_i_write32(hal2, H2I_ADC_C2, 0);\n\n\terr = snd_ctl_add(hal2->card,\n\t\t\t  snd_ctl_new1(&hal2_ctrl_headphone, hal2));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_ctl_add(hal2->card,\n\t\t\t  snd_ctl_new1(&hal2_ctrl_mic, hal2));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic irqreturn_t hal2_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_hal2 *hal2 = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\n\t \n\tif (hal2->dac.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {\n\t\tsnd_pcm_period_elapsed(hal2->dac.substream);\n\t\tret = IRQ_HANDLED;\n\t}\n\tif (hal2->adc.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {\n\t\tsnd_pcm_period_elapsed(hal2->adc.substream);\n\t\tret = IRQ_HANDLED;\n\t}\n\treturn ret;\n}\n\nstatic int hal2_compute_rate(struct hal2_codec *codec, unsigned int rate)\n{\n\tunsigned short mod;\n\n\tif (44100 % rate < 48000 % rate) {\n\t\tmod = 4 * 44100 / rate;\n\t\tcodec->master = 44100;\n\t} else {\n\t\tmod = 4 * 48000 / rate;\n\t\tcodec->master = 48000;\n\t}\n\n\tcodec->inc = 4;\n\tcodec->mod = mod;\n\trate = 4 * codec->master / mod;\n\n\treturn rate;\n}\n\nstatic void hal2_set_dac_rate(struct snd_hal2 *hal2)\n{\n\tunsigned int master = hal2->dac.master;\n\tint inc = hal2->dac.inc;\n\tint mod = hal2->dac.mod;\n\n\thal2_i_write16(hal2, H2I_BRES1_C1, (master == 44100) ? 1 : 0);\n\thal2_i_write32(hal2, H2I_BRES1_C2,\n\t\t       ((0xffff & (inc - mod - 1)) << 16) | inc);\n}\n\nstatic void hal2_set_adc_rate(struct snd_hal2 *hal2)\n{\n\tunsigned int master = hal2->adc.master;\n\tint inc = hal2->adc.inc;\n\tint mod = hal2->adc.mod;\n\n\thal2_i_write16(hal2, H2I_BRES2_C1, (master == 44100) ? 1 : 0);\n\thal2_i_write32(hal2, H2I_BRES2_C2,\n\t\t       ((0xffff & (inc - mod - 1)) << 16) | inc);\n}\n\nstatic void hal2_setup_dac(struct snd_hal2 *hal2)\n{\n\tunsigned int fifobeg, fifoend, highwater, sample_size;\n\tstruct hal2_pbus *pbus = &hal2->dac.pbus;\n\n\t \n\tsample_size = 2 * hal2->dac.voices;\n\t \n\thighwater = (sample_size * 2) >> 1;\t \n\tfifobeg = 0;\t\t\t\t \n\tfifoend = (sample_size * 4) >> 3;\t \n\tpbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_LD |\n\t\t     (highwater << 8) | (fifobeg << 16) | (fifoend << 24);\n\t \n\tpbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\n\thal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);\n\t \n\thal2_set_dac_rate(hal2);\n\t \n\thal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECTX);\n\t \n\thal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));\n\t \n\thal2_i_write16(hal2, H2I_DAC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)\n\t\t\t| (1 << H2I_C1_CLKID_SHIFT)\n\t\t\t| (hal2->dac.voices << H2I_C1_DATAT_SHIFT));\n}\n\nstatic void hal2_setup_adc(struct snd_hal2 *hal2)\n{\n\tunsigned int fifobeg, fifoend, highwater, sample_size;\n\tstruct hal2_pbus *pbus = &hal2->adc.pbus;\n\n\tsample_size = 2 * hal2->adc.voices;\n\thighwater = (sample_size * 2) >> 1;\t\t \n\tfifobeg = (4 * 4) >> 3;\t\t\t\t \n\tfifoend = (4 * 4 + sample_size * 4) >> 3;\t \n\tpbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_RCV | HPC3_PDMACTRL_LD |\n\t\t     (highwater << 8) | (fifobeg << 16) | (fifoend << 24);\n\tpbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\n\thal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);\n\t \n\thal2_set_adc_rate(hal2);\n\t \n\thal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECR);\n\t \n\thal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));\n\t \n\thal2_i_write16(hal2, H2I_ADC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)\n\t\t\t| (2 << H2I_C1_CLKID_SHIFT)\n\t\t\t| (hal2->adc.voices << H2I_C1_DATAT_SHIFT));\n}\n\nstatic void hal2_start_dac(struct snd_hal2 *hal2)\n{\n\tstruct hal2_pbus *pbus = &hal2->dac.pbus;\n\n\tpbus->pbus->pbdma_dptr = hal2->dac.desc_dma;\n\tpbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;\n\t \n\thal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);\n}\n\nstatic void hal2_start_adc(struct snd_hal2 *hal2)\n{\n\tstruct hal2_pbus *pbus = &hal2->adc.pbus;\n\n\tpbus->pbus->pbdma_dptr = hal2->adc.desc_dma;\n\tpbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;\n\t \n\thal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);\n}\n\nstatic inline void hal2_stop_dac(struct snd_hal2 *hal2)\n{\n\thal2->dac.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\n\t \n}\n\nstatic inline void hal2_stop_adc(struct snd_hal2 *hal2)\n{\n\thal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\n}\n\nstatic int hal2_alloc_dmabuf(struct snd_hal2 *hal2, struct hal2_codec *codec,\n\t\tenum dma_data_direction buffer_dir)\n{\n\tstruct device *dev = hal2->card->dev;\n\tstruct hal2_desc *desc;\n\tdma_addr_t desc_dma, buffer_dma;\n\tint count = H2_BUF_SIZE / H2_BLOCK_SIZE;\n\tint i;\n\n\tcodec->buffer = dma_alloc_noncoherent(dev, H2_BUF_SIZE, &buffer_dma,\n\t\t\t\t\tbuffer_dir, GFP_KERNEL);\n\tif (!codec->buffer)\n\t\treturn -ENOMEM;\n\tdesc = dma_alloc_noncoherent(dev, count * sizeof(struct hal2_desc),\n\t\t\t&desc_dma, DMA_BIDIRECTIONAL, GFP_KERNEL);\n\tif (!desc) {\n\t\tdma_free_noncoherent(dev, H2_BUF_SIZE, codec->buffer, buffer_dma,\n\t\t\t\tbuffer_dir);\n\t\treturn -ENOMEM;\n\t}\n\tcodec->buffer_dma = buffer_dma;\n\tcodec->desc_dma = desc_dma;\n\tcodec->desc = desc;\n\tfor (i = 0; i < count; i++) {\n\t\tdesc->desc.pbuf = buffer_dma + i * H2_BLOCK_SIZE;\n\t\tdesc->desc.cntinfo = HPCDMA_XIE | H2_BLOCK_SIZE;\n\t\tdesc->desc.pnext = (i == count - 1) ?\n\t\t      desc_dma : desc_dma + (i + 1) * sizeof(struct hal2_desc);\n\t\tdesc++;\n\t}\n\tdma_sync_single_for_device(dev, codec->desc_dma,\n\t\t\t\t   count * sizeof(struct hal2_desc),\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tcodec->desc_count = count;\n\treturn 0;\n}\n\nstatic void hal2_free_dmabuf(struct snd_hal2 *hal2, struct hal2_codec *codec,\n\t\tenum dma_data_direction buffer_dir)\n{\n\tstruct device *dev = hal2->card->dev;\n\n\tdma_free_noncoherent(dev, codec->desc_count * sizeof(struct hal2_desc),\n\t\t       codec->desc, codec->desc_dma, DMA_BIDIRECTIONAL);\n\tdma_free_noncoherent(dev, H2_BUF_SIZE, codec->buffer, codec->buffer_dma,\n\t\t\tbuffer_dir);\n}\n\nstatic const struct snd_pcm_hardware hal2_pcm_hw = {\n\t.info = (SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_SYNC_APPLPTR),\n\t.formats =          SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates =            SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =         8000,\n\t.rate_max =         48000,\n\t.channels_min =     2,\n\t.channels_max =     2,\n\t.buffer_bytes_max = 65536,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = 65536,\n\t.periods_min =      2,\n\t.periods_max =      1024,\n};\n\nstatic int hal2_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\truntime->hw = hal2_pcm_hw;\n\treturn hal2_alloc_dmabuf(hal2, &hal2->dac, DMA_TO_DEVICE);\n}\n\nstatic int hal2_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\thal2_free_dmabuf(hal2, &hal2->dac, DMA_TO_DEVICE);\n\treturn 0;\n}\n\nstatic int hal2_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct hal2_codec *dac = &hal2->dac;\n\n\tdac->voices = runtime->channels;\n\tdac->sample_rate = hal2_compute_rate(dac, runtime->rate);\n\tmemset(&dac->pcm_indirect, 0, sizeof(dac->pcm_indirect));\n\tdac->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;\n\tdac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;\n\tdac->pcm_indirect.hw_io = dac->buffer_dma;\n\tdac->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tdac->substream = substream;\n\thal2_setup_dac(hal2);\n\treturn 0;\n}\n\nstatic int hal2_playback_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\thal2_start_dac(hal2);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\thal2_stop_dac(hal2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nhal2_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct hal2_codec *dac = &hal2->dac;\n\n\treturn snd_pcm_indirect_playback_pointer(substream, &dac->pcm_indirect,\n\t\t\t\t\t\t dac->pbus.pbus->pbdma_bptr);\n}\n\nstatic void hal2_playback_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tunsigned char *buf = hal2->dac.buffer + rec->hw_data;\n\n\tmemcpy(buf, substream->runtime->dma_area + rec->sw_data, bytes);\n\tdma_sync_single_for_device(hal2->card->dev,\n\t\t\thal2->dac.buffer_dma + rec->hw_data, bytes,\n\t\t\tDMA_TO_DEVICE);\n\n}\n\nstatic int hal2_playback_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct hal2_codec *dac = &hal2->dac;\n\n\treturn snd_pcm_indirect_playback_transfer(substream,\n\t\t\t\t\t\t  &dac->pcm_indirect,\n\t\t\t\t\t\t  hal2_playback_transfer);\n}\n\nstatic int hal2_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\truntime->hw = hal2_pcm_hw;\n\treturn hal2_alloc_dmabuf(hal2, &hal2->adc, DMA_FROM_DEVICE);\n}\n\nstatic int hal2_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\thal2_free_dmabuf(hal2, &hal2->adc, DMA_FROM_DEVICE);\n\treturn 0;\n}\n\nstatic int hal2_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct hal2_codec *adc = &hal2->adc;\n\n\tadc->voices = runtime->channels;\n\tadc->sample_rate = hal2_compute_rate(adc, runtime->rate);\n\tmemset(&adc->pcm_indirect, 0, sizeof(adc->pcm_indirect));\n\tadc->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;\n\tadc->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;\n\tadc->pcm_indirect.hw_io = adc->buffer_dma;\n\tadc->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tadc->substream = substream;\n\thal2_setup_adc(hal2);\n\treturn 0;\n}\n\nstatic int hal2_capture_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\thal2_start_adc(hal2);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\thal2_stop_adc(hal2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nhal2_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct hal2_codec *adc = &hal2->adc;\n\n\treturn snd_pcm_indirect_capture_pointer(substream, &adc->pcm_indirect,\n\t\t\t\t\t\tadc->pbus.pbus->pbdma_bptr);\n}\n\nstatic void hal2_capture_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_indirect *rec, size_t bytes)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tunsigned char *buf = hal2->adc.buffer + rec->hw_data;\n\n\tdma_sync_single_for_cpu(hal2->card->dev,\n\t\t\thal2->adc.buffer_dma + rec->hw_data, bytes,\n\t\t\tDMA_FROM_DEVICE);\n\tmemcpy(substream->runtime->dma_area + rec->sw_data, buf, bytes);\n}\n\nstatic int hal2_capture_ack(struct snd_pcm_substream *substream)\n{\n\tstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\n\tstruct hal2_codec *adc = &hal2->adc;\n\n\treturn snd_pcm_indirect_capture_transfer(substream,\n\t\t\t\t\t\t &adc->pcm_indirect,\n\t\t\t\t\t\t hal2_capture_transfer);\n}\n\nstatic const struct snd_pcm_ops hal2_playback_ops = {\n\t.open =        hal2_playback_open,\n\t.close =       hal2_playback_close,\n\t.prepare =     hal2_playback_prepare,\n\t.trigger =     hal2_playback_trigger,\n\t.pointer =     hal2_playback_pointer,\n\t.ack =         hal2_playback_ack,\n};\n\nstatic const struct snd_pcm_ops hal2_capture_ops = {\n\t.open =        hal2_capture_open,\n\t.close =       hal2_capture_close,\n\t.prepare =     hal2_capture_prepare,\n\t.trigger =     hal2_capture_trigger,\n\t.pointer =     hal2_capture_pointer,\n\t.ack =         hal2_capture_ack,\n};\n\nstatic int hal2_pcm_create(struct snd_hal2 *hal2)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\t \n\terr = snd_pcm_new(hal2->card, \"SGI HAL2 Audio\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = hal2;\n\tstrcpy(pcm->name, \"SGI HAL2\");\n\n\t \n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&hal2_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&hal2_capture_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 0, 1024 * 1024);\n\n\treturn 0;\n}\n\nstatic int hal2_dev_free(struct snd_device *device)\n{\n\tstruct snd_hal2 *hal2 = device->device_data;\n\n\tfree_irq(SGI_HPCDMA_IRQ, hal2);\n\tkfree(hal2);\n\treturn 0;\n}\n\nstatic const struct snd_device_ops hal2_ops = {\n\t.dev_free = hal2_dev_free,\n};\n\nstatic void hal2_init_codec(struct hal2_codec *codec, struct hpc3_regs *hpc3,\n\t\t\t    int index)\n{\n\tcodec->pbus.pbusnr = index;\n\tcodec->pbus.pbus = &hpc3->pbdma[index];\n}\n\nstatic int hal2_detect(struct snd_hal2 *hal2)\n{\n\tunsigned short board, major, minor;\n\tunsigned short rev;\n\n\t \n\thal2_write(0, &hal2->ctl_regs->isr);\n\n\t \n\thal2_write(H2_ISR_GLOBAL_RESET_N | H2_ISR_CODEC_RESET_N,\n\t\t   &hal2->ctl_regs->isr);\n\n\n\thal2_i_write16(hal2, H2I_RELAY_C, H2I_RELAY_C_STATE);\n\trev = hal2_read(&hal2->ctl_regs->rev);\n\tif (rev & H2_REV_AUDIO_PRESENT)\n\t\treturn -ENODEV;\n\n\tboard = (rev & H2_REV_BOARD_M) >> 12;\n\tmajor = (rev & H2_REV_MAJOR_CHIP_M) >> 4;\n\tminor = (rev & H2_REV_MINOR_CHIP_M);\n\n\tprintk(KERN_INFO \"SGI HAL2 revision %i.%i.%i\\n\",\n\t       board, major, minor);\n\n\treturn 0;\n}\n\nstatic int hal2_create(struct snd_card *card, struct snd_hal2 **rchip)\n{\n\tstruct snd_hal2 *hal2;\n\tstruct hpc3_regs *hpc3 = hpc3c0;\n\tint err;\n\n\thal2 = kzalloc(sizeof(*hal2), GFP_KERNEL);\n\tif (!hal2)\n\t\treturn -ENOMEM;\n\n\thal2->card = card;\n\n\tif (request_irq(SGI_HPCDMA_IRQ, hal2_interrupt, IRQF_SHARED,\n\t\t\t\"SGI HAL2\", hal2)) {\n\t\tprintk(KERN_ERR \"HAL2: Can't get irq %d\\n\", SGI_HPCDMA_IRQ);\n\t\tkfree(hal2);\n\t\treturn -EAGAIN;\n\t}\n\n\thal2->ctl_regs = (struct hal2_ctl_regs *)hpc3->pbus_extregs[0];\n\thal2->aes_regs = (struct hal2_aes_regs *)hpc3->pbus_extregs[1];\n\thal2->vol_regs = (struct hal2_vol_regs *)hpc3->pbus_extregs[2];\n\thal2->syn_regs = (struct hal2_syn_regs *)hpc3->pbus_extregs[3];\n\n\tif (hal2_detect(hal2) < 0) {\n\t\tkfree(hal2);\n\t\treturn -ENODEV;\n\t}\n\n\thal2_init_codec(&hal2->dac, hpc3, 0);\n\thal2_init_codec(&hal2->adc, hpc3, 1);\n\n\t \n#define HAL2_PBUS_DMACFG ((0 << HPC3_DMACFG_D3R_SHIFT) | \\\n\t\t\t  (2 << HPC3_DMACFG_D4R_SHIFT) | \\\n\t\t\t  (2 << HPC3_DMACFG_D5R_SHIFT) | \\\n\t\t\t  (0 << HPC3_DMACFG_D3W_SHIFT) | \\\n\t\t\t  (2 << HPC3_DMACFG_D4W_SHIFT) | \\\n\t\t\t  (2 << HPC3_DMACFG_D5W_SHIFT) | \\\n\t\t\t\tHPC3_DMACFG_DS16 | \\\n\t\t\t\tHPC3_DMACFG_EVENHI | \\\n\t\t\t\tHPC3_DMACFG_RTIME | \\\n\t\t\t  (8 << HPC3_DMACFG_BURST_SHIFT) | \\\n\t\t\t\tHPC3_DMACFG_DRQLIVE)\n\t \n\thpc3->pbus_dmacfg[hal2->dac.pbus.pbusnr][0] = 0x8208844;\n\thpc3->pbus_dmacfg[hal2->adc.pbus.pbusnr][0] = 0x8208844;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, hal2, &hal2_ops);\n\tif (err < 0) {\n\t\tfree_irq(SGI_HPCDMA_IRQ, hal2);\n\t\tkfree(hal2);\n\t\treturn err;\n\t}\n\t*rchip = hal2;\n\treturn 0;\n}\n\nstatic int hal2_probe(struct platform_device *pdev)\n{\n\tstruct snd_card *card;\n\tstruct snd_hal2 *chip;\n\tint err;\n\n\terr = snd_card_new(&pdev->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = hal2_create(card, &chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\terr = hal2_pcm_create(chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\terr = hal2_mixer_create(chip);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, \"SGI HAL2 Audio\");\n\tstrcpy(card->shortname, \"SGI HAL2 Audio\");\n\tsprintf(card->longname, \"%s irq %i\",\n\t\tcard->shortname,\n\t\tSGI_HPCDMA_IRQ);\n\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\tplatform_set_drvdata(pdev, card);\n\treturn 0;\n}\n\nstatic void hal2_remove(struct platform_device *pdev)\n{\n\tstruct snd_card *card = platform_get_drvdata(pdev);\n\n\tsnd_card_free(card);\n}\n\nstatic struct platform_driver hal2_driver = {\n\t.probe\t= hal2_probe,\n\t.remove_new = hal2_remove,\n\t.driver = {\n\t\t.name\t= \"sgihal2\",\n\t}\n};\n\nmodule_platform_driver(hal2_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}