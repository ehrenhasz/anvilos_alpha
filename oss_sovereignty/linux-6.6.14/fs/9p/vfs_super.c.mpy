{
  "module_name": "vfs_super.c",
  "hash_id": "e707b1bcfc760743dfc1911c8494cb1a0a470e9557b33e033dd6e972de2ae3ef",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_super.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/magic.h>\n#include <linux/fscache.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic const struct super_operations v9fs_super_ops, v9fs_super_ops_dotl;\n\n \n\nstatic int v9fs_set_super(struct super_block *s, void *data)\n{\n\ts->s_fs_info = data;\n\treturn set_anon_super(s, data);\n}\n\n \n\nstatic int\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\n\t\tint flags)\n{\n\tint ret;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\n\tsb->s_blocksize = 1 << sb->s_blocksize_bits;\n\tsb->s_magic = V9FS_MAGIC;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tsb->s_op = &v9fs_super_ops_dotl;\n\t\tif (!(v9ses->flags & V9FS_NO_XATTR))\n\t\t\tsb->s_xattr = v9fs_xattr_handlers;\n\t} else {\n\t\tsb->s_op = &v9fs_super_ops;\n\t\tsb->s_time_max = U32_MAX;\n\t}\n\n\tsb->s_time_min = 0;\n\n\tret = super_setup_bdi(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!v9ses->cache) {\n\t\tsb->s_bdi->ra_pages = 0;\n\t\tsb->s_bdi->io_pages = 0;\n\t} else {\n\t\tsb->s_bdi->ra_pages = v9ses->maxdata >> PAGE_SHIFT;\n\t\tsb->s_bdi->io_pages = v9ses->maxdata >> PAGE_SHIFT;\n\t}\n\n\tsb->s_flags |= SB_ACTIVE;\n\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\tif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\n\t\tsb->s_flags |= SB_POSIXACL;\n#endif\n\n\treturn 0;\n}\n\n \n\nstatic struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = NULL;\n\tstruct v9fs_session_info *v9ses = NULL;\n\tumode_t mode = 0777 | S_ISVTX;\n\tstruct p9_fid *fid;\n\tint retval = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\n\tif (!v9ses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfid = v9fs_session_init(v9ses, dev_name, data);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tgoto free_session;\n\t}\n\n\tsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\n\tif (IS_ERR(sb)) {\n\t\tretval = PTR_ERR(sb);\n\t\tgoto clunk_fid;\n\t}\n\tretval = v9fs_fill_super(sb, v9ses, flags);\n\tif (retval)\n\t\tgoto release_sb;\n\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE))\n\t\tsb->s_d_op = &v9fs_cached_dentry_operations;\n\telse\n\t\tsb->s_d_op = &v9fs_dentry_operations;\n\n\tinode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\n\tif (IS_ERR(inode)) {\n\t\tretval = PTR_ERR(inode);\n\t\tgoto release_sb;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tretval = -ENOMEM;\n\t\tgoto release_sb;\n\t}\n\tsb->s_root = root;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tstruct p9_stat_dotl *st = NULL;\n\n\t\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode_dotl(st, d_inode(root), 0);\n\t\tkfree(st);\n\t} else {\n\t\tstruct p9_wstat *st = NULL;\n\n\t\tst = p9_client_stat(fid);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode(st, d_inode(root), sb, 0);\n\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t}\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto release_sb;\n\tv9fs_fid_add(root, &fid);\n\n\tp9_debug(P9_DEBUG_VFS, \" simple set mount, return 0\\n\");\n\treturn dget(sb->s_root);\n\nclunk_fid:\n\tp9_fid_put(fid);\n\tv9fs_session_close(v9ses);\nfree_session:\n\tkfree(v9ses);\n\treturn ERR_PTR(retval);\n\nrelease_sb:\n\t \n\tp9_fid_put(fid);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(retval);\n}\n\n \n\nstatic void v9fs_kill_super(struct super_block *s)\n{\n\tstruct v9fs_session_info *v9ses = s->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \" %p\\n\", s);\n\n\tkill_anon_super(s);\n\n\tv9fs_session_cancel(v9ses);\n\tv9fs_session_close(v9ses);\n\tkfree(v9ses);\n\ts->s_fs_info = NULL;\n\tp9_debug(P9_DEBUG_VFS, \"exiting kill_super\\n\");\n}\n\nstatic void\nv9fs_umount_begin(struct super_block *sb)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = sb->s_fs_info;\n\tv9fs_session_begin_cancel(v9ses);\n}\n\nstatic int v9fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_rstatfs rs;\n\tint res;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid)) {\n\t\tres = PTR_ERR(fid);\n\t\tgoto done;\n\t}\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tres = p9_client_statfs(fid, &rs);\n\t\tif (res == 0) {\n\t\t\tbuf->f_type = rs.type;\n\t\t\tbuf->f_bsize = rs.bsize;\n\t\t\tbuf->f_blocks = rs.blocks;\n\t\t\tbuf->f_bfree = rs.bfree;\n\t\t\tbuf->f_bavail = rs.bavail;\n\t\t\tbuf->f_files = rs.files;\n\t\t\tbuf->f_ffree = rs.ffree;\n\t\t\tbuf->f_fsid = u64_to_fsid(rs.fsid);\n\t\t\tbuf->f_namelen = rs.namelen;\n\t\t}\n\t\tif (res != -ENOSYS)\n\t\t\tgoto done;\n\t}\n\tres = simple_statfs(dentry, buf);\ndone:\n\tp9_fid_put(fid);\n\treturn res;\n}\n\nstatic int v9fs_drop_inode(struct inode *inode)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE))\n\t\treturn generic_drop_inode(inode);\n\t \n\treturn 1;\n}\n\nstatic int v9fs_write_inode(struct inode *inode,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct v9fs_inode *v9inode;\n\n\t \n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p\\n\", __func__, inode);\n\n\tv9inode = V9FS_I(inode);\n\tfscache_unpin_writeback(wbc, v9fs_inode_cookie(v9inode));\n\n\treturn 0;\n}\n\nstatic int v9fs_write_inode_dotl(struct inode *inode,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct v9fs_inode *v9inode;\n\n\tv9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p\\n\", __func__, inode);\n\n\tfscache_unpin_writeback(wbc, v9fs_inode_cookie(v9inode));\n\n\treturn 0;\n}\n\nstatic const struct super_operations v9fs_super_ops = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.free_inode = v9fs_free_inode,\n\t.statfs = simple_statfs,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = v9fs_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode,\n};\n\nstatic const struct super_operations v9fs_super_ops_dotl = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.free_inode = v9fs_free_inode,\n\t.statfs = v9fs_statfs,\n\t.drop_inode = v9fs_drop_inode,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = v9fs_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode_dotl,\n};\n\nstruct file_system_type v9fs_fs_type = {\n\t.name = \"9p\",\n\t.mount = v9fs_mount,\n\t.kill_sb = v9fs_kill_super,\n\t.owner = THIS_MODULE,\n\t.fs_flags = FS_RENAME_DOES_D_MOVE,\n};\nMODULE_ALIAS_FS(\"9p\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}