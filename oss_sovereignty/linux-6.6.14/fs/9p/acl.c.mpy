{
  "module_name": "acl.c",
  "hash_id": "f50ef2630b7280f47442bc54d9e03a1ae49877ebd5c3426caffa74fab0f10183",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/acl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl_xattr.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n\nstatic struct posix_acl *v9fs_fid_get_acl(struct p9_fid *fid, const char *name)\n{\n\tssize_t size;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl = NULL;\n\n\tsize = v9fs_fid_xattr_get(fid, name, NULL, 0);\n\tif (size < 0)\n\t\treturn ERR_PTR(size);\n\tif (size == 0)\n\t\treturn ERR_PTR(-ENODATA);\n\n\tvalue = kzalloc(size, GFP_NOFS);\n\tif (!value)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsize = v9fs_fid_xattr_get(fid, name, value, size);\n\tif (size < 0)\n\t\tacl = ERR_PTR(size);\n\telse if (size == 0)\n\t\tacl = ERR_PTR(-ENODATA);\n\telse\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\tkfree(value);\n\treturn acl;\n}\n\nstatic struct posix_acl *v9fs_acl_get(struct dentry *dentry, const char *name)\n{\n\tstruct p9_fid *fid;\n\tstruct posix_acl *acl = NULL;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn ERR_CAST(fid);\n\n\tacl = v9fs_fid_get_acl(fid, name);\n\tp9_fid_put(fid);\n\treturn acl;\n}\n\nstatic struct posix_acl *__v9fs_get_acl(struct p9_fid *fid, const char *name)\n{\n\tint retval;\n\tstruct posix_acl *acl = NULL;\n\n\tacl = v9fs_fid_get_acl(fid, name);\n\tif (!IS_ERR(acl))\n\t\treturn acl;\n\n\tretval = PTR_ERR(acl);\n\tif (retval == -ENODATA || retval == -ENOSYS || retval == -EOPNOTSUPP)\n\t\treturn NULL;\n\n\t \n\treturn ERR_PTR(-EIO);\n}\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t \n\tdacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}\n\nstatic struct posix_acl *v9fs_get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\t \n\tacl = get_cached_acl(inode, type);\n\tBUG_ON(is_uncached_acl(acl));\n\treturn acl;\n}\n\nstruct posix_acl *v9fs_iop_get_inode_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\t \n\t\treturn NULL;\n\t}\n\treturn v9fs_get_cached_acl(inode, type);\n\n}\n\nstruct posix_acl *v9fs_iop_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry, int type)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t \n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_acl_get(dentry, posix_acl_xattr_name(type));\n\treturn v9fs_get_cached_acl(d_inode(dentry), type);\n}\n\nint v9fs_iop_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct posix_acl *acl, int type)\n{\n\tint retval;\n\tsize_t size = 0;\n\tvoid *value = NULL;\n\tconst char *acl_name;\n\tstruct v9fs_session_info *v9ses;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (acl) {\n\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tretval = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (retval < 0)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\tacl_name = posix_acl_xattr_name(type);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) {\n\t\tretval = v9fs_xattr_set(dentry, acl_name, value, size, 0);\n\t\tgoto err_out;\n\t}\n\n\tif (S_ISLNK(inode->i_mode)) {\n\t\tretval = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode)) {\n\t\tretval = -EPERM;\n\t\tgoto err_out;\n\t}\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tstruct iattr iattr = {};\n\t\t\tstruct posix_acl *acl_mode = acl;\n\n\t\t\tretval = posix_acl_update_mode(&nop_mnt_idmap, inode,\n\t\t\t\t\t\t       &iattr.ia_mode,\n\t\t\t\t\t\t       &acl_mode);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t\tif (!acl_mode) {\n\t\t\t\t \n\t\t\t\tkfree(value);\n\t\t\t\tvalue = NULL;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t \n\t\t\tv9fs_vfs_setattr_dotl(&nop_mnt_idmap, dentry, &iattr);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tretval = v9fs_xattr_set(dentry, acl_name, value, size, 0);\n\tif (!retval)\n\t\tset_cached_acl(inode, type, acl);\n\nerr_out:\n\tkfree(value);\n\treturn retval;\n}\n\nstatic int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)\n{\n\tint retval;\n\tchar *name;\n\tsize_t size;\n\tvoid *buffer;\n\n\tif (!acl)\n\t\treturn 0;\n\n\t \n\tsize = posix_acl_xattr_size(acl->a_count);\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tretval = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\n\tif (retval < 0)\n\t\tgoto err_free_out;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_fid_xattr_set(fid, name, buffer, size, 0);\nerr_free_out:\n\tkfree(buffer);\n\treturn retval;\n}\n\nint v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}