{
  "module_name": "v9fs.h",
  "hash_id": "4d8934f94ea81f4dac41033f81c00557bc72049569702b8e0fde230ce9fc1578",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/v9fs.h",
  "human_readable_source": " \n \n#ifndef FS_9P_V9FS_H\n#define FS_9P_V9FS_H\n\n#include <linux/backing-dev.h>\n#include <linux/netfs.h>\n\n \n#define\tV9FS_ACCESS_ANY (V9FS_ACCESS_SINGLE | \\\n\t\t\t V9FS_ACCESS_USER |   \\\n\t\t\t V9FS_ACCESS_CLIENT)\n#define V9FS_ACCESS_MASK V9FS_ACCESS_ANY\n#define V9FS_ACL_MASK V9FS_POSIX_ACL\n\nenum p9_session_flags {\n\tV9FS_PROTO_2000U    = 0x01,\n\tV9FS_PROTO_2000L    = 0x02,\n\tV9FS_ACCESS_SINGLE  = 0x04,\n\tV9FS_ACCESS_USER    = 0x08,\n\tV9FS_ACCESS_CLIENT  = 0x10,\n\tV9FS_POSIX_ACL      = 0x20,\n\tV9FS_NO_XATTR       = 0x40,\n\tV9FS_IGNORE_QV      = 0x80,  \n\tV9FS_DIRECT_IO      = 0x100,\n\tV9FS_SYNC           = 0x200\n};\n\n \n\nenum p9_cache_shortcuts {\n\tCACHE_SC_NONE       = 0b00000000,\n\tCACHE_SC_READAHEAD  = 0b00000001,\n\tCACHE_SC_MMAP       = 0b00000101,\n\tCACHE_SC_LOOSE      = 0b00001111,\n\tCACHE_SC_FSCACHE    = 0b10001111,\n};\n\n \n\nenum p9_cache_bits {\n\tCACHE_NONE          = 0b00000000,\n\tCACHE_FILE          = 0b00000001,\n\tCACHE_META          = 0b00000010,\n\tCACHE_WRITEBACK     = 0b00000100,\n\tCACHE_LOOSE         = 0b00001000,\n\tCACHE_FSCACHE       = 0b10000000,\n};\n\n \n\nstruct v9fs_session_info {\n\t \n\tunsigned int flags;\n\tunsigned char nodev;\n\tunsigned short debug;\n\tunsigned int afid;\n\tunsigned int cache;\n#ifdef CONFIG_9P_FSCACHE\n\tchar *cachetag;\n\tstruct fscache_volume *fscache;\n#endif\n\n\tchar *uname;\t\t \n\tchar *aname;\t\t \n\tunsigned int maxdata;\t \n\tkuid_t dfltuid;\t\t \n\tkgid_t dfltgid;\t\t \n\tkuid_t uid;\t\t \n\tstruct p9_client *clnt;\t \n\tstruct list_head slist;  \n\tstruct rw_semaphore rename_sem;\n\tlong session_lock_timeout;  \n};\n\n \n#define V9FS_INO_INVALID_ATTR 0x01\n\nstruct v9fs_inode {\n\tstruct netfs_inode netfs;  \n\tstruct p9_qid qid;\n\tunsigned int cache_validity;\n\tstruct mutex v_mutex;\n};\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, netfs.inode);\n}\n\nstatic inline struct fscache_cookie *v9fs_inode_cookie(struct v9fs_inode *v9inode)\n{\n#ifdef CONFIG_9P_FSCACHE\n\treturn netfs_i_cookie(&v9inode->netfs);\n#else\n\treturn NULL;\n#endif\n}\n\nstatic inline struct fscache_volume *v9fs_session_cache(struct v9fs_session_info *v9ses)\n{\n#ifdef CONFIG_9P_FSCACHE\n\treturn v9ses->fscache;\n#else\n\treturn NULL;\n#endif\n}\n\n\nextern int v9fs_show_options(struct seq_file *m, struct dentry *root);\n\nstruct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t\t\t const char *dev_name, char *data);\nextern void v9fs_session_close(struct v9fs_session_info *v9ses);\nextern void v9fs_session_cancel(struct v9fs_session_info *v9ses);\nextern void v9fs_session_begin_cancel(struct v9fs_session_info *v9ses);\nextern struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags);\nextern int v9fs_vfs_unlink(struct inode *i, struct dentry *d);\nextern int v9fs_vfs_rmdir(struct inode *i, struct dentry *d);\nextern int v9fs_vfs_rename(struct mnt_idmap *idmap,\n\t\t\t   struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t   unsigned int flags);\nextern struct inode *v9fs_inode_from_fid(struct v9fs_session_info *v9ses,\n\t\t\t\t\t struct p9_fid *fid,\n\t\t\t\t\t struct super_block *sb, int new);\nextern const struct inode_operations v9fs_dir_inode_operations_dotl;\nextern const struct inode_operations v9fs_file_inode_operations_dotl;\nextern const struct inode_operations v9fs_symlink_inode_operations_dotl;\nextern const struct netfs_request_ops v9fs_req_ops;\nextern struct inode *v9fs_inode_from_fid_dotl(struct v9fs_session_info *v9ses,\n\t\t\t\t\t      struct p9_fid *fid,\n\t\t\t\t\t      struct super_block *sb, int new);\n\n \n#define V9FS_PORT\t564\n#define V9FS_DEFUSER\t\"nobody\"\n#define V9FS_DEFANAME\t\"\"\n#define V9FS_DEFUID\tKUIDT_INIT(-2)\n#define V9FS_DEFGID\tKGIDT_INIT(-2)\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}\n\n \nstatic inline struct inode *\nv9fs_get_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\tstruct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 0);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 0);\n}\n\n \nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}