{
  "module_name": "vfs_inode_dotl.c",
  "hash_id": "1a4bed0167947df806a92a503ae2290c27a50bab54cb3e409c7f4b7c7d862b6f",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_inode_dotl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n#include \"cache.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic int\nv9fs_vfs_mknod_dotl(struct mnt_idmap *idmap, struct inode *dir,\n\t\t    struct dentry *dentry, umode_t omode, dev_t rdev);\n\n \n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t \n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}\n\nstatic int v9fs_test_inode_dotl(struct inode *inode, void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\t \n\tif (inode_wrong_type(inode, st->st_mode))\n\t\treturn 0;\n\n\tif (inode->i_generation != st->st_gen)\n\t\treturn 0;\n\n\t \n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\n\tif (v9inode->qid.path != st->qid.path)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int v9fs_test_new_inode_dotl(struct inode *inode, void *data)\n{\n\treturn 0;\n}\n\nstatic int v9fs_set_inode_dotl(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\tinode->i_generation = st->st_gen;\n\treturn 0;\n}\n\nstatic struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *inode, void *data);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t \n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode, 0);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}\n\nstruct inode *\nv9fs_inode_from_fid_dotl(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t struct super_block *sb, int new)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC | P9_STATS_GEN);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget_dotl(sb, &st->qid, fid, st, new);\n\tkfree(st);\n\treturn inode;\n}\n\nstruct dotl_openflag_map {\n\tint open_flag;\n\tint dotl_flag;\n};\n\nstatic int v9fs_mapped_dotl_flags(int flags)\n{\n\tint i;\n\tint rflags = 0;\n\tstruct dotl_openflag_map dotl_oflag_map[] = {\n\t\t{ O_CREAT,\tP9_DOTL_CREATE },\n\t\t{ O_EXCL,\tP9_DOTL_EXCL },\n\t\t{ O_NOCTTY,\tP9_DOTL_NOCTTY },\n\t\t{ O_APPEND,\tP9_DOTL_APPEND },\n\t\t{ O_NONBLOCK,\tP9_DOTL_NONBLOCK },\n\t\t{ O_DSYNC,\tP9_DOTL_DSYNC },\n\t\t{ FASYNC,\tP9_DOTL_FASYNC },\n\t\t{ O_DIRECT,\tP9_DOTL_DIRECT },\n\t\t{ O_LARGEFILE,\tP9_DOTL_LARGEFILE },\n\t\t{ O_DIRECTORY,\tP9_DOTL_DIRECTORY },\n\t\t{ O_NOFOLLOW,\tP9_DOTL_NOFOLLOW },\n\t\t{ O_NOATIME,\tP9_DOTL_NOATIME },\n\t\t{ O_CLOEXEC,\tP9_DOTL_CLOEXEC },\n\t\t{ O_SYNC,\tP9_DOTL_SYNC},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n\t\tif (flags & dotl_oflag_map[i].open_flag)\n\t\t\trflags |= dotl_oflag_map[i].dotl_flag;\n\t}\n\treturn rflags;\n}\n\n \nint v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t \n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}\n\n \nstatic int\nv9fs_vfs_create_dotl(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t omode, bool excl)\n{\n\treturn v9fs_vfs_mknod_dotl(idmap, dir, dentry, omode, 0);\n}\n\nstatic int\nv9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,\n\t\t\t  struct file *file, unsigned int flags, umode_t omode)\n{\n\tint err = 0;\n\tkgid_t gid;\n\tumode_t mode;\n\tint p9_omode = v9fs_open_to_dotl_flags(flags);\n\tconst unsigned char *name = NULL;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *fid = NULL;\n\tstruct p9_fid *dfid = NULL, *ofid = NULL;\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *pacl = NULL, *dacl = NULL;\n\tstruct dentry *res = NULL;\n\n\tif (d_in_lookup(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t \n\tif (!(flags & O_CREAT) || d_really_is_positive(dentry))\n\t\treturn\tfinish_no_open(file, res);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tname = dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"name:%s flags:0x%x mode:0x%x\\n\",\n\t\t name, flags, omode);\n\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tofid = clone_fid(dfid);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\tmode = omode;\n\t \n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in create %d\\n\",\n\t\t\t err);\n\t\tgoto out;\n\t}\n\n\tif ((v9ses->cache & CACHE_WRITEBACK) && (p9_omode & P9_OWRITE)) {\n\t\tp9_omode = (p9_omode & ~P9_OWRITE) | P9_ORDWR;\n\t\tp9_debug(P9_DEBUG_CACHE,\n\t\t\t\"write-only file with writeback enabled, creating w/ O_RDWR\\n\");\n\t}\n\terr = p9_client_create_dotl(ofid, name, p9_omode, mode, gid, &qid);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_open_dotl failed in create %d\\n\",\n\t\t\t err);\n\t\tgoto out;\n\t}\n\tv9fs_invalidate_inode_attr(dir);\n\n\t \n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\t \n\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\n\tv9fs_fid_add(dentry, &fid);\n\td_instantiate(dentry, inode);\n\n\t \n\terr = finish_open(file, dentry, generic_file_open);\n\tif (err)\n\t\tgoto out;\n\tfile->private_data = ofid;\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->cache & CACHE_FSCACHE) {\n\t\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\t\tfscache_use_cookie(v9fs_inode_cookie(v9inode),\n\t\t\t\t   file->f_mode & FMODE_WRITE);\n\t}\n#endif\n\tv9fs_fid_add_modes(ofid, v9ses->flags, v9ses->cache, flags);\n\tv9fs_open_fid_add(inode, &ofid);\n\tfile->f_mode |= FMODE_CREATED;\nout:\n\tp9_fid_put(dfid);\n\tp9_fid_put(ofid);\n\tp9_fid_put(fid);\n\tv9fs_put_acl(dacl, pacl);\n\tdput(res);\n\treturn err;\n}\n\n \n\nstatic int v9fs_vfs_mkdir_dotl(struct mnt_idmap *idmap,\n\t\t\t       struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t omode)\n{\n\tint err;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tkgid_t gid;\n\tconst unsigned char *name;\n\tumode_t mode;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tomode |= S_IFDIR;\n\tif (dir->i_mode & S_ISGID)\n\t\tomode |= S_ISGID;\n\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t \n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mkdir %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = dentry->d_name.name;\n\terr = p9_client_mkdir_dotl(dfid, name, mode, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\n\t \n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, &fid);\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t\terr = 0;\n\t} else {\n\t\t \n\t\tinode = v9fs_get_inode(dir->i_sb, mode, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\n\tinc_nlink(dir);\n\tv9fs_invalidate_inode_attr(dir);\nerror:\n\tp9_fid_put(fid);\n\tv9fs_put_acl(dacl, pacl);\n\tp9_fid_put(dfid);\n\treturn err;\n}\n\nstatic int\nv9fs_vfs_getattr_dotl(struct mnt_idmap *idmap,\n\t\t      const struct path *path, struct kstat *stat,\n\t\t      u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct p9_stat_dotl *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\t\treturn 0;\n\t} else if (v9ses->cache) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tint retval = filemap_fdatawrite(inode->i_mapping);\n\n\t\t\tif (retval)\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t    \"flushing writeback during getattr returned %d\\n\", retval);\n\t\t}\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t \n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tp9_fid_put(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode_dotl(st, d_inode(dentry), 0);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(dentry), stat);\n\t \n\tstat->blksize = st->st_blksize;\n\n\tkfree(st);\n\treturn 0;\n}\n\n \n#define P9_ATTR_MODE\t\t(1 << 0)\n#define P9_ATTR_UID\t\t(1 << 1)\n#define P9_ATTR_GID\t\t(1 << 2)\n#define P9_ATTR_SIZE\t\t(1 << 3)\n#define P9_ATTR_ATIME\t\t(1 << 4)\n#define P9_ATTR_MTIME\t\t(1 << 5)\n#define P9_ATTR_CTIME\t\t(1 << 6)\n#define P9_ATTR_ATIME_SET\t(1 << 7)\n#define P9_ATTR_MTIME_SET\t(1 << 8)\n\nstruct dotl_iattr_map {\n\tint iattr_valid;\n\tint p9_iattr_valid;\n};\n\nstatic int v9fs_mapped_iattr_valid(int iattr_valid)\n{\n\tint i;\n\tint p9_iattr_valid = 0;\n\tstruct dotl_iattr_map dotl_iattr_map[] = {\n\t\t{ ATTR_MODE,\t\tP9_ATTR_MODE },\n\t\t{ ATTR_UID,\t\tP9_ATTR_UID },\n\t\t{ ATTR_GID,\t\tP9_ATTR_GID },\n\t\t{ ATTR_SIZE,\t\tP9_ATTR_SIZE },\n\t\t{ ATTR_ATIME,\t\tP9_ATTR_ATIME },\n\t\t{ ATTR_MTIME,\t\tP9_ATTR_MTIME },\n\t\t{ ATTR_CTIME,\t\tP9_ATTR_CTIME },\n\t\t{ ATTR_ATIME_SET,\tP9_ATTR_ATIME_SET },\n\t\t{ ATTR_MTIME_SET,\tP9_ATTR_MTIME_SET },\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\n\t\tif (iattr_valid & dotl_iattr_map[i].iattr_valid)\n\t\t\tp9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\n\t}\n\treturn p9_iattr_valid;\n}\n\n \n\nint v9fs_vfs_setattr_dotl(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval, use_dentry = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct v9fs_session_info __maybe_unused *v9ses;\n\tstruct p9_fid *fid = NULL;\n\tstruct p9_iattr_dotl p9attr = {\n\t\t.uid = INVALID_UID,\n\t\t.gid = INVALID_GID,\n\t};\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tretval = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\n\tp9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\tp9attr.mode = iattr->ia_mode;\n\tif (iattr->ia_valid & ATTR_UID)\n\t\tp9attr.uid = iattr->ia_uid;\n\tif (iattr->ia_valid & ATTR_GID)\n\t\tp9attr.gid = iattr->ia_gid;\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\tp9attr.size = iattr->ia_size;\n\tif (iattr->ia_valid & ATTR_ATIME_SET) {\n\t\tp9attr.atime_sec = iattr->ia_atime.tv_sec;\n\t\tp9attr.atime_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME_SET) {\n\t\tp9attr.mtime_sec = iattr->ia_mtime.tv_sec;\n\t\tp9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n\n\tif (iattr->ia_valid & ATTR_FILE) {\n\t\tfid = iattr->ia_file->private_data;\n\t\tWARN_ON(!fid);\n\t}\n\tif (!fid) {\n\t\tfid = v9fs_fid_lookup(dentry);\n\t\tuse_dentry = 1;\n\t}\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t \n\tif (S_ISREG(inode->i_mode)) {\n\t\tretval = filemap_fdatawrite(inode->i_mapping);\n\t\tif (retval < 0)\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t    \"Flushing file prior to setattr failed: %d\\n\", retval);\n\t}\n\n\tretval = p9_client_setattr(fid, &p9attr);\n\tif (retval < 0) {\n\t\tif (use_dentry)\n\t\t\tp9_fid_put(fid);\n\t\treturn retval;\n\t}\n\n\tif ((iattr->ia_valid & ATTR_SIZE) && iattr->ia_size !=\n\t\t i_size_read(inode)) {\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\ttruncate_pagecache(inode, iattr->ia_size);\n\n#ifdef CONFIG_9P_FSCACHE\n\t\tif (v9ses->cache & CACHE_FSCACHE)\n\t\t\tfscache_resize_cookie(v9fs_inode_cookie(V9FS_I(inode)),\n\t\t\t\tiattr->ia_size);\n#endif\n\t}\n\n\tv9fs_invalidate_inode_attr(inode);\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tmark_inode_dirty(inode);\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t \n\t\tretval = v9fs_acl_chmod(inode, fid);\n\t\tif (retval < 0) {\n\t\t\tif (use_dentry)\n\t\t\t\tp9_fid_put(fid);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tif (use_dentry)\n\t\tp9_fid_put(fid);\n\n\treturn 0;\n}\n\n \n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,\n\t\t      unsigned int flags)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode_set_ctime(inode, stat->st_ctime_sec,\n\t\t\t\tstat->st_ctime_nsec);\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n\t\t\tv9fs_i_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode_set_ctime(inode, stat->st_ctime_sec,\n\t\t\t\t\tstat->st_ctime_nsec);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tmode = stat->st_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE) &&\n\t\t    stat->st_result_mask & P9_STATS_SIZE)\n\t\t\tv9fs_i_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t \n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}\n\nstatic int\nv9fs_vfs_symlink_dotl(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, const char *symname)\n{\n\tint err;\n\tkgid_t gid;\n\tconst unsigned char *name;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *dfid;\n\tstruct p9_fid *fid = NULL;\n\tstruct v9fs_session_info *v9ses;\n\n\tname = dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"%lu,%s,%s\\n\", dir->i_ino, name, symname);\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\t \n\terr = p9_client_symlink(dfid, name, symname, gid, &qid);\n\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_symlink failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\t \n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, &fid);\n\t\td_instantiate(dentry, inode);\n\t\terr = 0;\n\t} else {\n\t\t \n\t\tinode = v9fs_get_inode(dir->i_sb, S_IFLNK, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t}\n\nerror:\n\tp9_fid_put(fid);\n\tp9_fid_put(dfid);\n\treturn err;\n}\n\n \n\nstatic int\nv9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *dfid, *oldfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir ino: %lu, old_name: %pd, new_name: %pd\\n\",\n\t\t dir->i_ino, old_dentry, dentry);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid))\n\t\treturn PTR_ERR(dfid);\n\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid)) {\n\t\tp9_fid_put(dfid);\n\t\treturn PTR_ERR(oldfid);\n\t}\n\n\terr = p9_client_link(dfid, oldfid, dentry->d_name.name);\n\n\tp9_fid_put(dfid);\n\tp9_fid_put(oldfid);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_link failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\t \n\t\tstruct p9_fid *fid;\n\n\t\tfid = v9fs_fid_lookup(old_dentry);\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\tv9fs_refresh_inode_dotl(fid, d_inode(old_dentry));\n\t\tp9_fid_put(fid);\n\t}\n\tihold(d_inode(old_dentry));\n\td_instantiate(dentry, d_inode(old_dentry));\n\n\treturn err;\n}\n\n \nstatic int\nv9fs_vfs_mknod_dotl(struct mnt_idmap *idmap, struct inode *dir,\n\t\t    struct dentry *dentry, umode_t omode, dev_t rdev)\n{\n\tint err;\n\tkgid_t gid;\n\tconst unsigned char *name;\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %x MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, omode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t \n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mknod %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = dentry->d_name.name;\n\n\terr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tv9fs_invalidate_inode_attr(dir);\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\n\t \n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\tv9fs_fid_add(dentry, &fid);\n\t\td_instantiate(dentry, inode);\n\t\terr = 0;\n\t} else {\n\t\t \n\t\tinode = v9fs_get_inode(dir->i_sb, mode, rdev);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\nerror:\n\tp9_fid_put(fid);\n\tv9fs_put_acl(dacl, pacl);\n\tp9_fid_put(dfid);\n\n\treturn err;\n}\n\n \n\nstatic const char *\nv9fs_vfs_get_link_dotl(struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct delayed_call *done)\n{\n\tstruct p9_fid *fid;\n\tchar *target;\n\tint retval;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn ERR_CAST(fid);\n\tretval = p9_client_readlink(fid, &target);\n\tp9_fid_put(fid);\n\tif (retval)\n\t\treturn ERR_PTR(retval);\n\tset_delayed_call(done, kfree_link, target);\n\treturn target;\n}\n\nint v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\tunsigned int flags;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t \n\tif (inode_wrong_type(inode, st->st_mode))\n\t\tgoto out;\n\n\t \n\tflags = (v9ses->cache & CACHE_LOOSE) ?\n\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n\tv9fs_stat2inode_dotl(st, inode, flags);\nout:\n\tkfree(st);\n\treturn 0;\n}\n\nconst struct inode_operations v9fs_dir_inode_operations_dotl = {\n\t.create = v9fs_vfs_create_dotl,\n\t.atomic_open = v9fs_vfs_atomic_open_dotl,\n\t.lookup = v9fs_vfs_lookup,\n\t.link = v9fs_vfs_link_dotl,\n\t.symlink = v9fs_vfs_symlink_dotl,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir_dotl,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod_dotl,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr_dotl,\n\t.setattr = v9fs_vfs_setattr_dotl,\n\t.listxattr = v9fs_listxattr,\n\t.get_inode_acl = v9fs_iop_get_inode_acl,\n\t.get_acl = v9fs_iop_get_acl,\n\t.set_acl = v9fs_iop_set_acl,\n};\n\nconst struct inode_operations v9fs_file_inode_operations_dotl = {\n\t.getattr = v9fs_vfs_getattr_dotl,\n\t.setattr = v9fs_vfs_setattr_dotl,\n\t.listxattr = v9fs_listxattr,\n\t.get_inode_acl = v9fs_iop_get_inode_acl,\n\t.get_acl = v9fs_iop_get_acl,\n\t.set_acl = v9fs_iop_set_acl,\n};\n\nconst struct inode_operations v9fs_symlink_inode_operations_dotl = {\n\t.get_link = v9fs_vfs_get_link_dotl,\n\t.getattr = v9fs_vfs_getattr_dotl,\n\t.setattr = v9fs_vfs_setattr_dotl,\n\t.listxattr = v9fs_listxattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}