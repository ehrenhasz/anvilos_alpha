{
  "module_name": "vfs_addr.c",
  "hash_id": "b7b970829384a5c23a50afbe2df9390d4a804d32dd00889551ba7225a806b31b",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_addr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/uio.h>\n#include <linux/netfs.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n\n \nstatic void v9fs_issue_read(struct netfs_io_subrequest *subreq)\n{\n\tstruct netfs_io_request *rreq = subreq->rreq;\n\tstruct p9_fid *fid = rreq->netfs_priv;\n\tstruct iov_iter to;\n\tloff_t pos = subreq->start + subreq->transferred;\n\tsize_t len = subreq->len   - subreq->transferred;\n\tint total, err;\n\n\tiov_iter_xarray(&to, ITER_DEST, &rreq->mapping->i_pages, pos, len);\n\n\ttotal = p9_client_read(fid, pos, &to, &err);\n\n\t \n\t__set_bit(NETFS_SREQ_CLEAR_TAIL, &subreq->flags);\n\n\tnetfs_subreq_terminated(subreq, err ?: total, false);\n}\n\n \nstatic int v9fs_init_request(struct netfs_io_request *rreq, struct file *file)\n{\n\tstruct p9_fid *fid = file->private_data;\n\n\tBUG_ON(!fid);\n\n\t \n\tWARN_ON(rreq->origin == NETFS_READ_FOR_WRITE &&\n\t\t\t!(fid->mode & P9_ORDWR));\n\n\tp9_fid_get(fid);\n\trreq->netfs_priv = fid;\n\treturn 0;\n}\n\n \nstatic void v9fs_free_request(struct netfs_io_request *rreq)\n{\n\tstruct p9_fid *fid = rreq->netfs_priv;\n\n\tp9_fid_put(fid);\n}\n\n \nstatic int v9fs_begin_cache_operation(struct netfs_io_request *rreq)\n{\n#ifdef CONFIG_9P_FSCACHE\n\tstruct fscache_cookie *cookie = v9fs_inode_cookie(V9FS_I(rreq->inode));\n\n\treturn fscache_begin_read_operation(&rreq->cache_resources, cookie);\n#else\n\treturn -ENOBUFS;\n#endif\n}\n\nconst struct netfs_request_ops v9fs_req_ops = {\n\t.init_request\t\t= v9fs_init_request,\n\t.free_request\t\t= v9fs_free_request,\n\t.begin_cache_operation\t= v9fs_begin_cache_operation,\n\t.issue_read\t\t= v9fs_issue_read,\n};\n\n \n\nstatic bool v9fs_release_folio(struct folio *folio, gfp_t gfp)\n{\n\tif (folio_test_private(folio))\n\t\treturn false;\n#ifdef CONFIG_9P_FSCACHE\n\tif (folio_test_fscache(folio)) {\n\t\tif (current_is_kswapd() || !(gfp & __GFP_FS))\n\t\t\treturn false;\n\t\tfolio_wait_fscache(folio);\n\t}\n\tfscache_note_page_release(v9fs_inode_cookie(V9FS_I(folio_inode(folio))));\n#endif\n\treturn true;\n}\n\nstatic void v9fs_invalidate_folio(struct folio *folio, size_t offset,\n\t\t\t\t size_t length)\n{\n\tfolio_wait_fscache(folio);\n}\n\n#ifdef CONFIG_9P_FSCACHE\nstatic void v9fs_write_to_cache_done(void *priv, ssize_t transferred_or_error,\n\t\t\t\t     bool was_async)\n{\n\tstruct v9fs_inode *v9inode = priv;\n\t__le32 version;\n\n\tif (IS_ERR_VALUE(transferred_or_error) &&\n\t    transferred_or_error != -ENOBUFS) {\n\t\tversion = cpu_to_le32(v9inode->qid.version);\n\t\tfscache_invalidate(v9fs_inode_cookie(v9inode), &version,\n\t\t\t\t   i_size_read(&v9inode->netfs.inode), 0);\n\t}\n}\n#endif\n\nstatic int v9fs_vfs_write_folio_locked(struct folio *folio)\n{\n\tstruct inode *inode = folio_inode(folio);\n\tloff_t start = folio_pos(folio);\n\tloff_t i_size = i_size_read(inode);\n\tstruct iov_iter from;\n\tsize_t len = folio_size(folio);\n\tstruct p9_fid *writeback_fid;\n\tint err;\n\tstruct v9fs_inode __maybe_unused *v9inode = V9FS_I(inode);\n\tstruct fscache_cookie __maybe_unused *cookie = v9fs_inode_cookie(v9inode);\n\n\tif (start >= i_size)\n\t\treturn 0;  \n\n\tlen = min_t(loff_t, i_size - start, len);\n\n\tiov_iter_xarray(&from, ITER_SOURCE, &folio_mapping(folio)->i_pages, start, len);\n\n\twriteback_fid = v9fs_fid_find_inode(inode, true, INVALID_UID, true);\n\tif (!writeback_fid) {\n\t\tWARN_ONCE(1, \"folio expected an open fid inode->i_private=%p\\n\",\n\t\t\tinode->i_private);\n\t\treturn -EINVAL;\n\t}\n\n\tfolio_wait_fscache(folio);\n\tfolio_start_writeback(folio);\n\n\tp9_client_write(writeback_fid, start, &from, &err);\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (err == 0 &&\n\t\tfscache_cookie_enabled(cookie) &&\n\t\ttest_bit(FSCACHE_COOKIE_IS_CACHING, &cookie->flags)) {\n\t\tfolio_start_fscache(folio);\n\t\tfscache_write_to_cache(v9fs_inode_cookie(v9inode),\n\t\t\t\t\tfolio_mapping(folio), start, len, i_size,\n\t\t\t\t\tv9fs_write_to_cache_done, v9inode,\n\t\t\t\t\ttrue);\n\t}\n#endif\n\n\tfolio_end_writeback(folio);\n\tp9_fid_put(writeback_fid);\n\n\treturn err;\n}\n\nstatic int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct folio *folio = page_folio(page);\n\tint retval;\n\n\tp9_debug(P9_DEBUG_VFS, \"folio %p\\n\", folio);\n\n\tretval = v9fs_vfs_write_folio_locked(folio);\n\tif (retval < 0) {\n\t\tif (retval == -EAGAIN) {\n\t\t\tfolio_redirty_for_writepage(wbc, folio);\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tmapping_set_error(folio_mapping(folio), retval);\n\t\t}\n\t} else\n\t\tretval = 0;\n\n\tfolio_unlock(folio);\n\treturn retval;\n}\n\nstatic int v9fs_launder_folio(struct folio *folio)\n{\n\tint retval;\n\n\tif (folio_clear_dirty_for_io(folio)) {\n\t\tretval = v9fs_vfs_write_folio_locked(folio);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tfolio_wait_fscache(folio);\n\treturn 0;\n}\n\n \nstatic ssize_t\nv9fs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tloff_t pos = iocb->ki_pos;\n\tssize_t n;\n\tint err = 0;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tn = p9_client_write(file->private_data, pos, iter, &err);\n\t\tif (n) {\n\t\t\tstruct inode *inode = file_inode(file);\n\t\t\tloff_t i_size = i_size_read(inode);\n\n\t\t\tif (pos + n > i_size)\n\t\t\t\tinode_add_bytes(inode, pos + n - i_size);\n\t\t}\n\t} else {\n\t\tn = p9_client_read(file->private_data, pos, iter, &err);\n\t}\n\treturn n ? n : err;\n}\n\nstatic int v9fs_write_begin(struct file *filp, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned int len,\n\t\t\t    struct page **subpagep, void **fsdata)\n{\n\tint retval;\n\tstruct folio *folio;\n\tstruct v9fs_inode *v9inode = V9FS_I(mapping->host);\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\t \n\tretval = netfs_write_begin(&v9inode->netfs, filp, mapping, pos, len, &folio, fsdata);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t*subpagep = &folio->page;\n\treturn retval;\n}\n\nstatic int v9fs_write_end(struct file *filp, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned int len, unsigned int copied,\n\t\t\t  struct page *subpage, void *fsdata)\n{\n\tloff_t last_pos = pos + copied;\n\tstruct folio *folio = page_folio(subpage);\n\tstruct inode *inode = mapping->host;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tif (unlikely(copied < len)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfolio_mark_uptodate(folio);\n\t}\n\n\t \n\tif (last_pos > inode->i_size) {\n\t\tinode_add_bytes(inode, last_pos - inode->i_size);\n\t\ti_size_write(inode, last_pos);\n#ifdef CONFIG_9P_FSCACHE\n\t\tfscache_update_cookie(v9fs_inode_cookie(V9FS_I(inode)), NULL,\n\t\t\t&last_pos);\n#endif\n\t}\n\tfolio_mark_dirty(folio);\nout:\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\treturn copied;\n}\n\n#ifdef CONFIG_9P_FSCACHE\n \nstatic bool v9fs_dirty_folio(struct address_space *mapping, struct folio *folio)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(mapping->host);\n\n\treturn fscache_dirty_folio(mapping, folio, v9fs_inode_cookie(v9inode));\n}\n#else\n#define v9fs_dirty_folio filemap_dirty_folio\n#endif\n\nconst struct address_space_operations v9fs_addr_operations = {\n\t.read_folio = netfs_read_folio,\n\t.readahead = netfs_readahead,\n\t.dirty_folio = v9fs_dirty_folio,\n\t.writepage = v9fs_vfs_writepage,\n\t.write_begin = v9fs_write_begin,\n\t.write_end = v9fs_write_end,\n\t.release_folio = v9fs_release_folio,\n\t.invalidate_folio = v9fs_invalidate_folio,\n\t.launder_folio = v9fs_launder_folio,\n\t.direct_IO = v9fs_direct_IO,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}