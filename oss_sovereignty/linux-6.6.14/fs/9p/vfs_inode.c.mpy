{
  "module_name": "vfs_inode.c",
  "hash_id": "8d7fdfb6d5f63f9b1bea7912077b2cdc26f9171b97090ed1bc3d22e43adb658b",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_inode.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n#include \"cache.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic const struct inode_operations v9fs_dir_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu;\nstatic const struct inode_operations v9fs_file_inode_operations;\nstatic const struct inode_operations v9fs_symlink_inode_operations;\n\n \n\nstatic u32 unixmode2p9mode(struct v9fs_session_info *v9ses, umode_t mode)\n{\n\tint res;\n\n\tres = mode & 0777;\n\tif (S_ISDIR(mode))\n\t\tres |= P9_DMDIR;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (v9ses->nodev == 0) {\n\t\t\tif (S_ISSOCK(mode))\n\t\t\t\tres |= P9_DMSOCKET;\n\t\t\tif (S_ISFIFO(mode))\n\t\t\t\tres |= P9_DMNAMEDPIPE;\n\t\t\tif (S_ISBLK(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t\tif (S_ISCHR(mode))\n\t\t\t\tres |= P9_DMDEVICE;\n\t\t}\n\n\t\tif ((mode & S_ISUID) == S_ISUID)\n\t\t\tres |= P9_DMSETUID;\n\t\tif ((mode & S_ISGID) == S_ISGID)\n\t\t\tres |= P9_DMSETGID;\n\t\tif ((mode & S_ISVTX) == S_ISVTX)\n\t\t\tres |= P9_DMSETVTX;\n\t}\n\treturn res;\n}\n\n \nstatic int p9mode2perm(struct v9fs_session_info *v9ses,\n\t\t       struct p9_wstat *stat)\n{\n\tint res;\n\tint mode = stat->mode;\n\n\tres = mode & S_IALLUGO;\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif ((mode & P9_DMSETUID) == P9_DMSETUID)\n\t\t\tres |= S_ISUID;\n\n\t\tif ((mode & P9_DMSETGID) == P9_DMSETGID)\n\t\t\tres |= S_ISGID;\n\n\t\tif ((mode & P9_DMSETVTX) == P9_DMSETVTX)\n\t\t\tres |= S_ISVTX;\n\t}\n\treturn res;\n}\n\n \nstatic umode_t p9mode2unixmode(struct v9fs_session_info *v9ses,\n\t\t\t       struct p9_wstat *stat, dev_t *rdev)\n{\n\tint res, r;\n\tu32 mode = stat->mode;\n\n\t*rdev = 0;\n\tres = p9mode2perm(v9ses, stat);\n\n\tif ((mode & P9_DMDIR) == P9_DMDIR)\n\t\tres |= S_IFDIR;\n\telse if ((mode & P9_DMSYMLINK) && (v9fs_proto_dotu(v9ses)))\n\t\tres |= S_IFLNK;\n\telse if ((mode & P9_DMSOCKET) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFSOCK;\n\telse if ((mode & P9_DMNAMEDPIPE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0))\n\t\tres |= S_IFIFO;\n\telse if ((mode & P9_DMDEVICE) && (v9fs_proto_dotu(v9ses))\n\t\t && (v9ses->nodev == 0)) {\n\t\tchar type = 0;\n\t\tint major = -1, minor = -1;\n\n\t\tr = sscanf(stat->extension, \"%c %i %i\", &type, &major, &minor);\n\t\tif (r != 3) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"invalid device string, umode will be bogus: %s\\n\",\n\t\t\t\t stat->extension);\n\t\t\treturn res;\n\t\t}\n\t\tswitch (type) {\n\t\tcase 'c':\n\t\t\tres |= S_IFCHR;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tres |= S_IFBLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp9_debug(P9_DEBUG_ERROR, \"Unknown special type %c %s\\n\",\n\t\t\t\t type, stat->extension);\n\t\t}\n\t\t*rdev = MKDEV(major, minor);\n\t} else\n\t\tres |= S_IFREG;\n\n\treturn res;\n}\n\n \n\nint v9fs_uflags2omode(int uflags, int extended)\n{\n\tint ret;\n\n\tswitch (uflags&3) {\n\tdefault:\n\tcase O_RDONLY:\n\t\tret = P9_OREAD;\n\t\tbreak;\n\n\tcase O_WRONLY:\n\t\tret = P9_OWRITE;\n\t\tbreak;\n\n\tcase O_RDWR:\n\t\tret = P9_ORDWR;\n\t\tbreak;\n\t}\n\n\tif (extended) {\n\t\tif (uflags & O_EXCL)\n\t\t\tret |= P9_OEXCL;\n\n\t\tif (uflags & O_APPEND)\n\t\t\tret |= P9_OAPPEND;\n\t}\n\n\treturn ret;\n}\n\n \n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}\n\n \nstruct inode *v9fs_alloc_inode(struct super_block *sb)\n{\n\tstruct v9fs_inode *v9inode;\n\n\tv9inode = alloc_inode_sb(sb, v9fs_inode_cache, GFP_KERNEL);\n\tif (!v9inode)\n\t\treturn NULL;\n\tv9inode->cache_validity = 0;\n\tmutex_init(&v9inode->v_mutex);\n\treturn &v9inode->netfs.inode;\n}\n\n \n\nvoid v9fs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(v9fs_inode_cache, V9FS_I(inode));\n}\n\n \nstatic void v9fs_set_netfs_context(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tnetfs_inode_init(&v9inode->netfs, &v9fs_req_ops);\n}\n\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(&nop_mnt_idmap, inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\tinode->i_private = NULL;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tv9fs_set_netfs_context(inode);\nerror:\n\treturn err;\n\n}\n\n \n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}\n\n \nvoid v9fs_evict_inode(struct inode *inode)\n{\n\tstruct v9fs_inode __maybe_unused *v9inode = V9FS_I(inode);\n\t__le32 __maybe_unused version;\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n#ifdef CONFIG_9P_FSCACHE\n\tversion = cpu_to_le32(v9inode->qid.version);\n\tfscache_clear_inode_writeback(v9fs_inode_cookie(v9inode), inode,\n\t\t\t\t      &version);\n#endif\n\n\tclear_inode(inode);\n\tfilemap_fdatawrite(&inode->i_data);\n\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_relinquish_cookie(v9fs_inode_cookie(v9inode), false);\n#endif\n}\n\nstatic int v9fs_test_inode(struct inode *inode, void *data)\n{\n\tint umode;\n\tdev_t rdev;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(inode);\n\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\t \n\tif (inode_wrong_type(inode, umode))\n\t\treturn 0;\n\n\t \n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\n\tif (v9inode->qid.path != st->qid.path)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int v9fs_test_new_inode(struct inode *inode, void *data)\n{\n\treturn 0;\n}\n\nstatic int v9fs_set_inode(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_wstat *st = (struct p9_wstat *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\treturn 0;\n}\n\nstatic struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *inode, void *data);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t \n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb, 0);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}\n\nstruct inode *\nv9fs_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t    struct super_block *sb, int new)\n{\n\tstruct p9_wstat *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget(sb, &st->qid, st, new);\n\tp9stat_free(st);\n\tkfree(st);\n\treturn inode;\n}\n\n \nstatic int v9fs_at_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\tif (flags & AT_REMOVEDIR)\n\t\trflags |= P9_DOTL_AT_REMOVEDIR;\n\n\treturn rflags;\n}\n\n \nstatic void v9fs_dec_count(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}\n\n \n\nstatic int v9fs_remove(struct inode *dir, struct dentry *dentry, int flags)\n{\n\tstruct inode *inode;\n\tint retval = -EOPNOTSUPP;\n\tstruct p9_fid *v9fid, *dfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p dentry: %p rmdir: %x\\n\",\n\t\t dir, dentry, flags);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tinode = d_inode(dentry);\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\tretval = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif (v9fs_proto_dotl(v9ses))\n\t\tretval = p9_client_unlinkat(dfid, dentry->d_name.name,\n\t\t\t\t\t    v9fs_at_to_dotl_flags(flags));\n\tp9_fid_put(dfid);\n\tif (retval == -EOPNOTSUPP) {\n\t\t \n\t\tv9fid = v9fs_fid_clone(dentry);\n\t\tif (IS_ERR(v9fid))\n\t\t\treturn PTR_ERR(v9fid);\n\t\tretval = p9_client_remove(v9fid);\n\t}\n\tif (!retval) {\n\t\t \n\t\tif (flags & AT_REMOVEDIR) {\n\t\t\tclear_nlink(inode);\n\t\t\tv9fs_dec_count(dir);\n\t\t} else\n\t\t\tv9fs_dec_count(inode);\n\n\t\tv9fs_invalidate_inode_attr(inode);\n\t\tv9fs_invalidate_inode_attr(dir);\n\n\t\t \n\t\t \n\t\tdentry->d_op->d_release(dentry);\n\t}\n\treturn retval;\n}\n\n \nstatic struct p9_fid *\nv9fs_create(struct v9fs_session_info *v9ses, struct inode *dir,\n\t\tstruct dentry *dentry, char *extension, u32 perm, u8 mode)\n{\n\tint err;\n\tconst unsigned char *name;\n\tstruct p9_fid *dfid, *ofid = NULL, *fid = NULL;\n\tstruct inode *inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\n\tname = dentry->d_name.name;\n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\tofid = clone_fid(dfid);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\terr = p9_client_fcreate(ofid, name, perm, mode, extension);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_fcreate failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tif (!(perm & P9_DMLINK)) {\n\t\t \n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"p9_client_walk failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS,\n\t\t\t\t   \"inode creation failed %d\\n\", err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, &fid);\n\t\td_instantiate(dentry, inode);\n\t}\n\tp9_fid_put(dfid);\n\treturn ofid;\nerror:\n\tp9_fid_put(dfid);\n\tp9_fid_put(ofid);\n\tp9_fid_put(fid);\n\treturn ERR_PTR(err);\n}\n\n \n\nstatic int\nv9fs_vfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tu32 perm = unixmode2p9mode(v9ses, mode);\n\tstruct p9_fid *fid;\n\n\t \n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_ORDWR);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_fid_put(fid);\n\n\treturn 0;\n}\n\n \n\nstatic int v9fs_vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tu32 perm;\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\terr = 0;\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode | S_IFDIR);\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, P9_OREAD);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tfid = NULL;\n\t} else {\n\t\tinc_nlink(dir);\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\n\tif (fid)\n\t\tp9_fid_put(fid);\n\n\treturn err;\n}\n\n \n\nstruct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tconst unsigned char *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t \n\tdfid = v9fs_parent_fid(dentry);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\t \n\tname = dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tp9_fid_put(dfid);\n\tif (fid == ERR_PTR(-ENOENT))\n\t\tinode = NULL;\n\telse if (IS_ERR(fid))\n\t\tinode = ERR_CAST(fid);\n\telse if (v9ses->cache & (CACHE_META|CACHE_LOOSE))\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t \n\tres = d_splice_alias(inode, dentry);\n\tif (!IS_ERR(fid)) {\n\t\tif (!res)\n\t\t\tv9fs_fid_add(dentry, &fid);\n\t\telse if (!IS_ERR(res))\n\t\t\tv9fs_fid_add(res, &fid);\n\t\telse\n\t\t\tp9_fid_put(fid);\n\t}\n\treturn res;\n}\n\nstatic int\nv9fs_vfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned int flags, umode_t mode)\n{\n\tint err;\n\tu32 perm;\n\tstruct v9fs_inode __maybe_unused *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct dentry *res = NULL;\n\tstruct inode *inode;\n\tint p9_omode;\n\n\tif (d_in_lookup(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t \n\tif (!(flags & O_CREAT) || d_really_is_positive(dentry))\n\t\treturn finish_no_open(file, res);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tperm = unixmode2p9mode(v9ses, mode);\n\tp9_omode = v9fs_uflags2omode(flags, v9fs_proto_dotu(v9ses));\n\n\tif ((v9ses->cache & CACHE_WRITEBACK) && (p9_omode & P9_OWRITE)) {\n\t\tp9_omode = (p9_omode & ~P9_OWRITE) | P9_ORDWR;\n\t\tp9_debug(P9_DEBUG_CACHE,\n\t\t\t\"write-only file with writeback enabled, creating w/ O_RDWR\\n\");\n\t}\n\tfid = v9fs_create(v9ses, dir, dentry, NULL, perm, p9_omode);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tinode = d_inode(dentry);\n\tv9inode = V9FS_I(inode);\n\terr = finish_open(file, dentry, generic_file_open);\n\tif (err)\n\t\tgoto error;\n\n\tfile->private_data = fid;\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->cache & CACHE_FSCACHE)\n\t\tfscache_use_cookie(v9fs_inode_cookie(v9inode),\n\t\t\t\t   file->f_mode & FMODE_WRITE);\n#endif\n\n\tv9fs_fid_add_modes(fid, v9ses->flags, v9ses->cache, file->f_flags);\n\tv9fs_open_fid_add(inode, &fid);\n\n\tfile->f_mode |= FMODE_CREATED;\nout:\n\tdput(res);\n\treturn err;\n\nerror:\n\tp9_fid_put(fid);\n\tgoto out;\n}\n\n \n\nint v9fs_vfs_unlink(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, 0);\n}\n\n \n\nint v9fs_vfs_rmdir(struct inode *i, struct dentry *d)\n{\n\treturn v9fs_remove(i, d, AT_REMOVEDIR);\n}\n\n \n\nint\nv9fs_vfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\tstruct dentry *old_dentry, struct inode *new_dir,\n\t\tstruct dentry *new_dentry, unsigned int flags)\n{\n\tint retval;\n\tstruct inode *old_inode;\n\tstruct inode *new_inode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *oldfid = NULL, *dfid = NULL;\n\tstruct p9_fid *olddirfid = NULL;\n\tstruct p9_fid *newdirfid = NULL;\n\tstruct p9_wstat wstat;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\told_inode = d_inode(old_dentry);\n\tnew_inode = d_inode(new_dentry);\n\tv9ses = v9fs_inode2v9ses(old_inode);\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tdfid = v9fs_parent_fid(old_dentry);\n\tolddirfid = clone_fid(dfid);\n\tp9_fid_put(dfid);\n\tdfid = NULL;\n\n\tif (IS_ERR(olddirfid)) {\n\t\tretval = PTR_ERR(olddirfid);\n\t\tgoto error;\n\t}\n\n\tdfid = v9fs_parent_fid(new_dentry);\n\tnewdirfid = clone_fid(dfid);\n\tp9_fid_put(dfid);\n\tdfid = NULL;\n\n\tif (IS_ERR(newdirfid)) {\n\t\tretval = PTR_ERR(newdirfid);\n\t\tgoto error;\n\t}\n\n\tdown_write(&v9ses->rename_sem);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tretval = p9_client_renameat(olddirfid, old_dentry->d_name.name,\n\t\t\t\t\t    newdirfid, new_dentry->d_name.name);\n\t\tif (retval == -EOPNOTSUPP)\n\t\t\tretval = p9_client_rename(oldfid, newdirfid,\n\t\t\t\t\t\t  new_dentry->d_name.name);\n\t\tif (retval != -EOPNOTSUPP)\n\t\t\tgoto error_locked;\n\t}\n\tif (old_dentry->d_parent != new_dentry->d_parent) {\n\t\t \n\n\t\tp9_debug(P9_DEBUG_ERROR, \"old dir and new dir are different\\n\");\n\t\tretval = -EXDEV;\n\t\tgoto error_locked;\n\t}\n\tv9fs_blank_wstat(&wstat);\n\twstat.muid = v9ses->uname;\n\twstat.name = new_dentry->d_name.name;\n\tretval = p9_client_wstat(oldfid, &wstat);\n\nerror_locked:\n\tif (!retval) {\n\t\tif (new_inode) {\n\t\t\tif (S_ISDIR(new_inode->i_mode))\n\t\t\t\tclear_nlink(new_inode);\n\t\t\telse\n\t\t\t\tv9fs_dec_count(new_inode);\n\t\t}\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif (!new_inode)\n\t\t\t\tinc_nlink(new_dir);\n\t\t\tv9fs_dec_count(old_dir);\n\t\t}\n\t\tv9fs_invalidate_inode_attr(old_inode);\n\t\tv9fs_invalidate_inode_attr(old_dir);\n\t\tv9fs_invalidate_inode_attr(new_dir);\n\n\t\t \n\t\td_move(old_dentry, new_dentry);\n\t}\n\tup_write(&v9ses->rename_sem);\n\nerror:\n\tp9_fid_put(newdirfid);\n\tp9_fid_put(olddirfid);\n\tp9_fid_put(oldfid);\n\treturn retval;\n}\n\n \n\nstatic int\nv9fs_vfs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache & (CACHE_META|CACHE_LOOSE)) {\n\t\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\t\treturn 0;\n\t} else if (v9ses->cache & CACHE_WRITEBACK) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tint retval = filemap_fdatawrite(inode->i_mapping);\n\n\t\t\tif (retval)\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t    \"flushing writeback during getattr returned %d\\n\", retval);\n\t\t}\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tp9_fid_put(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(dentry), stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}\n\n \n\nstatic int v9fs_vfs_setattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval, use_dentry = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL;\n\tstruct p9_wstat wstat;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\tretval = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (iattr->ia_valid & ATTR_FILE) {\n\t\tfid = iattr->ia_file->private_data;\n\t\tWARN_ON(!fid);\n\t}\n\tif (!fid) {\n\t\tfid = v9fs_fid_lookup(dentry);\n\t\tuse_dentry = 1;\n\t}\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_blank_wstat(&wstat);\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\twstat.mode = unixmode2p9mode(v9ses, iattr->ia_mode);\n\n\tif (iattr->ia_valid & ATTR_MTIME)\n\t\twstat.mtime = iattr->ia_mtime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_ATIME)\n\t\twstat.atime = iattr->ia_atime.tv_sec;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\twstat.length = iattr->ia_size;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tif (iattr->ia_valid & ATTR_UID)\n\t\t\twstat.n_uid = iattr->ia_uid;\n\n\t\tif (iattr->ia_valid & ATTR_GID)\n\t\t\twstat.n_gid = iattr->ia_gid;\n\t}\n\n\t \n\tif (d_is_reg(dentry)) {\n\t\tretval = filemap_fdatawrite(inode->i_mapping);\n\t\tif (retval)\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t    \"flushing writeback during setattr returned %d\\n\", retval);\n\t}\n\n\tretval = p9_client_wstat(fid, &wstat);\n\n\tif (use_dentry)\n\t\tp9_fid_put(fid);\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t\t iattr->ia_size != i_size_read(inode)) {\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\ttruncate_pagecache(inode, iattr->ia_size);\n\n#ifdef CONFIG_9P_FSCACHE\n\t\tif (v9ses->cache & CACHE_FSCACHE) {\n\t\t\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\t\t\tfscache_resize_cookie(v9fs_inode_cookie(v9inode), iattr->ia_size);\n\t\t}\n#endif\n\t}\n\n\tv9fs_invalidate_inode_attr(inode);\n\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n \n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\t\t struct super_block *sb, unsigned int flags)\n{\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode_set_ctime(inode, stat->mtime, 0);\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses)) {\n\t\t\tunsigned int i_nlink;\n\t\t\t \n\t\t\t \n\t\t\tif (sscanf(stat->extension,\n\t\t\t\t   \" HARDLINKCOUNT %u\", &i_nlink) == 1)\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\n\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n\t\tv9fs_i_size_write(inode, stat->length);\n\t \n\tinode->i_blocks = (stat->length + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}\n\n \n\nino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}\n\n \n\nstatic const char *v9fs_vfs_get_link(struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct delayed_call *done)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\tchar *res;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (!v9fs_proto_dotu(v9ses))\n\t\treturn ERR_PTR(-EBADF);\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\tfid = v9fs_fid_lookup(dentry);\n\n\tif (IS_ERR(fid))\n\t\treturn ERR_CAST(fid);\n\n\tst = p9_client_stat(fid);\n\tp9_fid_put(fid);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tif (!(st->mode & P9_DMSYMLINK)) {\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tres = st->extension;\n\tst->extension = NULL;\n\tif (strlen(res) >= PATH_MAX)\n\t\tres[PATH_MAX - 1] = '\\0';\n\n\tp9stat_free(st);\n\tkfree(st);\n\tset_delayed_call(done, kfree_link, res);\n\treturn res;\n}\n\n \n\nstatic int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,\n\tu32 perm, const char *extension)\n{\n\tstruct p9_fid *fid;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tif (!v9fs_proto_dotu(v9ses)) {\n\t\tp9_debug(P9_DEBUG_ERROR, \"not extended\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfid = v9fs_create(v9ses, dir, dentry, (char *) extension, perm,\n\t\t\t\t\t\t\t\tP9_OREAD);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tv9fs_invalidate_inode_attr(dir);\n\tp9_fid_put(fid);\n\treturn 0;\n}\n\n \n\nstatic int\nv9fs_vfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t struct dentry *dentry, const char *symname)\n{\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%s\\n\",\n\t\t dir->i_ino, dentry, symname);\n\n\treturn v9fs_vfs_mkspecial(dir, dentry, P9_DMSYMLINK, symname);\n}\n\n#define U32_MAX_DIGITS 10\n\n \n\nstatic int\nv9fs_vfs_link(struct dentry *old_dentry, struct inode *dir,\n\t      struct dentry *dentry)\n{\n\tint retval;\n\tchar name[1 + U32_MAX_DIGITS + 2];  \n\tstruct p9_fid *oldfid;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd,%pd\\n\",\n\t\t dir->i_ino, dentry, old_dentry);\n\n\toldfid = v9fs_fid_clone(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\tsprintf(name, \"%d\\n\", oldfid->fid);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);\n\tif (!retval) {\n\t\tv9fs_refresh_inode(oldfid, d_inode(old_dentry));\n\t\tv9fs_invalidate_inode_attr(dir);\n\t}\n\tp9_fid_put(oldfid);\n\treturn retval;\n}\n\n \n\nstatic int\nv9fs_vfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t       struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(dir);\n\tint retval;\n\tchar name[2 + U32_MAX_DIGITS + 1 + U32_MAX_DIGITS + 1];\n\tu32 perm;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %x MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, mode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\t \n\tif (S_ISBLK(mode))\n\t\tsprintf(name, \"b %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse if (S_ISCHR(mode))\n\t\tsprintf(name, \"c %u %u\", MAJOR(rdev), MINOR(rdev));\n\telse\n\t\t*name = 0;\n\n\tperm = unixmode2p9mode(v9ses, mode);\n\tretval = v9fs_vfs_mkspecial(dir, dentry, perm, name);\n\n\treturn retval;\n}\n\nint v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\tunsigned int flags;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t \n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif (inode_wrong_type(inode, umode))\n\t\tgoto out;\n\n\t \n\tflags = (v9ses->cache & CACHE_LOOSE) ?\n\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n\tv9fs_stat2inode(st, inode, inode->i_sb, flags);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}\n\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nstatic const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nstatic const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nstatic const struct inode_operations v9fs_symlink_inode_operations = {\n\t.get_link = v9fs_vfs_get_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}