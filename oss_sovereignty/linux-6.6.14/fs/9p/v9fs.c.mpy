{
  "module_name": "v9fs.c",
  "hash_id": "65cdc41aad7770c87c0af0c2d321713227e21612f587800a9d7ca7cded20f480",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/v9fs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n#include <net/9p/transport.h>\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"cache.h\"\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\nstatic LIST_HEAD(v9fs_sessionlist);\nstruct kmem_cache *v9fs_inode_cache;\n\n \n\nenum {\n\t \n\tOpt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,\n\t \n\tOpt_uname, Opt_remotename, Opt_cache, Opt_cachetag,\n\t \n\tOpt_nodevmap, Opt_noxattr, Opt_directio, Opt_ignoreqv,\n\t \n\tOpt_access, Opt_posixacl,\n\t \n\tOpt_locktimeout,\n\t \n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_debug, \"debug=%x\"},\n\t{Opt_dfltuid, \"dfltuid=%u\"},\n\t{Opt_dfltgid, \"dfltgid=%u\"},\n\t{Opt_afid, \"afid=%u\"},\n\t{Opt_uname, \"uname=%s\"},\n\t{Opt_remotename, \"aname=%s\"},\n\t{Opt_nodevmap, \"nodevmap\"},\n\t{Opt_noxattr, \"noxattr\"},\n\t{Opt_directio, \"directio\"},\n\t{Opt_ignoreqv, \"ignoreqv\"},\n\t{Opt_cache, \"cache=%s\"},\n\t{Opt_cachetag, \"cachetag=%s\"},\n\t{Opt_access, \"access=%s\"},\n\t{Opt_posixacl, \"posixacl\"},\n\t{Opt_locktimeout, \"locktimeout=%u\"},\n\t{Opt_err, NULL}\n};\n\n \nstatic int get_cache_mode(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"loose\")) {\n\t\tversion = CACHE_SC_LOOSE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: loose\\n\");\n\t} else if (!strcmp(s, \"fscache\")) {\n\t\tversion = CACHE_SC_FSCACHE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: fscache\\n\");\n\t} else if (!strcmp(s, \"mmap\")) {\n\t\tversion = CACHE_SC_MMAP;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: mmap\\n\");\n\t} else if (!strcmp(s, \"readahead\")) {\n\t\tversion = CACHE_SC_READAHEAD;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: readahead\\n\");\n\t} else if (!strcmp(s, \"none\")) {\n\t\tversion = CACHE_SC_NONE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: none\\n\");\n\t} else if (kstrtoint(s, 0, &version) != 0) {\n\t\tversion = -EINVAL;\n\t\tpr_info(\"Unknown Cache mode or invalid value %s\\n\", s);\n\t}\n\treturn version;\n}\n\n \nint v9fs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct v9fs_session_info *v9ses = root->d_sb->s_fs_info;\n\n\tif (v9ses->debug)\n\t\tseq_printf(m, \",debug=%x\", v9ses->debug);\n\tif (!uid_eq(v9ses->dfltuid, V9FS_DEFUID))\n\t\tseq_printf(m, \",dfltuid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, v9ses->dfltuid));\n\tif (!gid_eq(v9ses->dfltgid, V9FS_DEFGID))\n\t\tseq_printf(m, \",dfltgid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, v9ses->dfltgid));\n\tif (v9ses->afid != ~0)\n\t\tseq_printf(m, \",afid=%u\", v9ses->afid);\n\tif (strcmp(v9ses->uname, V9FS_DEFUSER) != 0)\n\t\tseq_printf(m, \",uname=%s\", v9ses->uname);\n\tif (strcmp(v9ses->aname, V9FS_DEFANAME) != 0)\n\t\tseq_printf(m, \",aname=%s\", v9ses->aname);\n\tif (v9ses->nodev)\n\t\tseq_puts(m, \",nodevmap\");\n\tif (v9ses->cache)\n\t\tseq_printf(m, \",cache=%x\", v9ses->cache);\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->cachetag && (v9ses->cache & CACHE_FSCACHE))\n\t\tseq_printf(m, \",cachetag=%s\", v9ses->cachetag);\n#endif\n\n\tswitch (v9ses->flags & V9FS_ACCESS_MASK) {\n\tcase V9FS_ACCESS_USER:\n\t\tseq_puts(m, \",access=user\");\n\t\tbreak;\n\tcase V9FS_ACCESS_ANY:\n\t\tseq_puts(m, \",access=any\");\n\t\tbreak;\n\tcase V9FS_ACCESS_CLIENT:\n\t\tseq_puts(m, \",access=client\");\n\t\tbreak;\n\tcase V9FS_ACCESS_SINGLE:\n\t\tseq_printf(m, \",access=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, v9ses->uid));\n\t\tbreak;\n\t}\n\n\tif (v9ses->flags & V9FS_IGNORE_QV)\n\t\tseq_puts(m, \",ignoreqv\");\n\tif (v9ses->flags & V9FS_DIRECT_IO)\n\t\tseq_puts(m, \",directio\");\n\tif (v9ses->flags & V9FS_POSIX_ACL)\n\t\tseq_puts(m, \",posixacl\");\n\n\tif (v9ses->flags & V9FS_NO_XATTR)\n\t\tseq_puts(m, \",noxattr\");\n\n\treturn p9_show_client_options(m, v9ses->clnt);\n}\n\n \n\nstatic int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\n{\n\tchar *options, *tmp_options;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint option = 0;\n\tchar *s;\n\tint ret = 0;\n\n\t \n\tv9ses->afid = ~0;\n\tv9ses->debug = 0;\n\tv9ses->cache = CACHE_NONE;\n#ifdef CONFIG_9P_FSCACHE\n\tv9ses->cachetag = NULL;\n#endif\n\tv9ses->session_lock_timeout = P9_LOCK_TIMEOUT;\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_option_alloc;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_debug:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t} else {\n\t\t\t\tv9ses->debug = option;\n#ifdef CONFIG_NET_9P_DEBUG\n\t\t\t\tp9_debug_level = option;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Opt_dfltuid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(v9ses->dfltuid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"uid field, but not a uid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_dfltgid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(v9ses->dfltgid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"gid field, but not a gid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_afid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t} else {\n\t\t\t\tv9ses->afid = option;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_uname:\n\t\t\tkfree(v9ses->uname);\n\t\t\tv9ses->uname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->uname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_remotename:\n\t\t\tkfree(v9ses->aname);\n\t\t\tv9ses->aname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->aname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_nodevmap:\n\t\t\tv9ses->nodev = 1;\n\t\t\tbreak;\n\t\tcase Opt_noxattr:\n\t\t\tv9ses->flags |= V9FS_NO_XATTR;\n\t\t\tbreak;\n\t\tcase Opt_directio:\n\t\t\tv9ses->flags |= V9FS_DIRECT_IO;\n\t\t\tbreak;\n\t\tcase Opt_ignoreqv:\n\t\t\tv9ses->flags |= V9FS_IGNORE_QV;\n\t\t\tbreak;\n\t\tcase Opt_cachetag:\n#ifdef CONFIG_9P_FSCACHE\n\t\t\tkfree(v9ses->cachetag);\n\t\t\tv9ses->cachetag = match_strdup(&args[0]);\n\t\t\tif (!v9ses->cachetag) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of cache arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tr = get_cache_mode(s);\n\t\t\tif (r < 0)\n\t\t\t\tret = r;\n\t\t\telse\n\t\t\t\tv9ses->cache = r;\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_access:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of access arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\t\tif (strcmp(s, \"user\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t\t\telse if (strcmp(s, \"any\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\t\telse if (strcmp(s, \"client\") == 0) {\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_CLIENT;\n\t\t\t} else {\n\t\t\t\tuid_t uid;\n\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_SINGLE;\n\t\t\t\tr = kstrtouint(s, 10, &uid);\n\t\t\t\tif (r) {\n\t\t\t\t\tret = r;\n\t\t\t\t\tpr_info(\"Unknown access argument %s: %d\\n\",\n\t\t\t\t\t\ts, r);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tv9ses->uid = make_kuid(current_user_ns(), uid);\n\t\t\t\tif (!uid_valid(v9ses->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Unknown uid %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_posixacl:\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\t\t\tv9ses->flags |= V9FS_POSIX_ACL;\n#else\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tcase Opt_locktimeout:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (option < 1) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"locktimeout must be a greater than zero integer.\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->session_lock_timeout = (long)option * HZ;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tkfree(tmp_options);\nfail_option_alloc:\n\treturn ret;\n}\n\n \n\nstruct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t  const char *dev_name, char *data)\n{\n\tstruct p9_fid *fid;\n\tint rc = -ENOMEM;\n\n\tv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\n\tif (!v9ses->uname)\n\t\tgoto err_names;\n\n\tv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\n\tif (!v9ses->aname)\n\t\tgoto err_names;\n\tinit_rwsem(&v9ses->rename_sem);\n\n\tv9ses->uid = INVALID_UID;\n\tv9ses->dfltuid = V9FS_DEFUID;\n\tv9ses->dfltgid = V9FS_DEFGID;\n\n\tv9ses->clnt = p9_client_create(dev_name, data);\n\tif (IS_ERR(v9ses->clnt)) {\n\t\trc = PTR_ERR(v9ses->clnt);\n\t\tp9_debug(P9_DEBUG_ERROR, \"problem initializing 9p client\\n\");\n\t\tgoto err_names;\n\t}\n\n\tv9ses->flags = V9FS_ACCESS_USER;\n\n\tif (p9_is_proto_dotl(v9ses->clnt)) {\n\t\tv9ses->flags = V9FS_ACCESS_CLIENT;\n\t\tv9ses->flags |= V9FS_PROTO_2000L;\n\t} else if (p9_is_proto_dotu(v9ses->clnt)) {\n\t\tv9ses->flags |= V9FS_PROTO_2000U;\n\t}\n\n\trc = v9fs_parse_options(v9ses, data);\n\tif (rc < 0)\n\t\tgoto err_clnt;\n\n\tv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\n\n\tif (!v9fs_proto_dotl(v9ses) &&\n\t    ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t \n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t}\n\t \n\t \n\tif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\n\t\t((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\n\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\tv9ses->uid = INVALID_UID;\n\t}\n\tif (!v9fs_proto_dotl(v9ses) ||\n\t\t!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t \n\t\tv9ses->flags &= ~V9FS_ACL_MASK;\n\t}\n\n\tfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\n\t\t\t\t\t\t\tv9ses->aname);\n\tif (IS_ERR(fid)) {\n\t\trc = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_ERROR, \"cannot attach\\n\");\n\t\tgoto err_clnt;\n\t}\n\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\n\t\tfid->uid = v9ses->uid;\n\telse\n\t\tfid->uid = INVALID_UID;\n\n#ifdef CONFIG_9P_FSCACHE\n\t \n\tif (v9ses->cache & CACHE_FSCACHE) {\n\t\trc = v9fs_cache_session_get_cookie(v9ses, dev_name);\n\t\tif (rc < 0)\n\t\t\tgoto err_clnt;\n\t}\n#endif\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_add(&v9ses->slist, &v9fs_sessionlist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n\n\treturn fid;\n\nerr_clnt:\n#ifdef CONFIG_9P_FSCACHE\n\tkfree(v9ses->cachetag);\n#endif\n\tp9_client_destroy(v9ses->clnt);\nerr_names:\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\treturn ERR_PTR(rc);\n}\n\n \n\nvoid v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_relinquish_volume(v9fs_session_cache(v9ses), NULL, false);\n\tkfree(v9ses->cachetag);\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}\n\n \n\nvoid v9fs_session_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"cancel session %p\\n\", v9ses);\n\tp9_client_disconnect(v9ses->clnt);\n}\n\n \n\nvoid v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"begin cancel session %p\\n\", v9ses);\n\tp9_client_begin_disconnect(v9ses->clnt);\n}\n\nstatic struct kobject *v9fs_kobj;\n\n#ifdef CONFIG_9P_FSCACHE\n \nstatic ssize_t caches_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t n = 0, count = 0, limit = PAGE_SIZE;\n\tstruct v9fs_session_info *v9ses;\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_for_each_entry(v9ses, &v9fs_sessionlist, slist) {\n\t\tif (v9ses->cachetag) {\n\t\t\tn = snprintf(buf, limit, \"%s\\n\", v9ses->cachetag);\n\t\t\tif (n < 0) {\n\t\t\t\tcount = n;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcount += n;\n\t\t\tlimit -= n;\n\t\t}\n\t}\n\n\tspin_unlock(&v9fs_sessionlist_lock);\n\treturn count;\n}\n\nstatic struct kobj_attribute v9fs_attr_cache = __ATTR_RO(caches);\n#endif  \n\nstatic struct attribute *v9fs_attrs[] = {\n#ifdef CONFIG_9P_FSCACHE\n\t&v9fs_attr_cache.attr,\n#endif\n\tNULL,\n};\n\nstatic const struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\n \n\nstatic int __init v9fs_sysfs_init(void)\n{\n\tv9fs_kobj = kobject_create_and_add(\"9p\", fs_kobj);\n\tif (!v9fs_kobj)\n\t\treturn -ENOMEM;\n\n\tif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\n\t\tkobject_put(v9fs_kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}\n\nstatic void v9fs_inode_init_once(void *foo)\n{\n\tstruct v9fs_inode *v9inode = (struct v9fs_inode *)foo;\n\n\tmemset(&v9inode->qid, 0, sizeof(v9inode->qid));\n\tinode_init_once(&v9inode->netfs.inode);\n}\n\n \nstatic int v9fs_init_inode_cache(void)\n{\n\tv9fs_inode_cache = kmem_cache_create(\"v9fs_inode_cache\",\n\t\t\t\t\t  sizeof(struct v9fs_inode),\n\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t  v9fs_inode_init_once);\n\tif (!v9fs_inode_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic void v9fs_destroy_inode_cache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}\n\nstatic int v9fs_cache_register(void)\n{\n\tint ret;\n\n\tret = v9fs_init_inode_cache();\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret;\n}\n\nstatic void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n}\n\n \n\nstatic int __init init_v9fs(void)\n{\n\tint err;\n\n\tpr_info(\"Installing v9fs 9p2000 file system support\\n\");\n\t \n\n\terr = v9fs_cache_register();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register v9fs for caching\\n\");\n\t\treturn err;\n\t}\n\n\terr = v9fs_sysfs_init();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register with sysfs\\n\");\n\t\tgoto out_cache;\n\t}\n\terr = register_filesystem(&v9fs_fs_type);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register filesystem\\n\");\n\t\tgoto out_sysfs_cleanup;\n\t}\n\n\treturn 0;\n\nout_sysfs_cleanup:\n\tv9fs_sysfs_cleanup();\n\nout_cache:\n\tv9fs_cache_unregister();\n\n\treturn err;\n}\n\n \n\nstatic void __exit exit_v9fs(void)\n{\n\tv9fs_sysfs_cleanup();\n\tv9fs_cache_unregister();\n\tunregister_filesystem(&v9fs_fs_type);\n}\n\nmodule_init(init_v9fs)\nmodule_exit(exit_v9fs)\n\nMODULE_AUTHOR(\"Latchesar Ionkov <lucho@ionkov.net>\");\nMODULE_AUTHOR(\"Eric Van Hensbergen <ericvh@gmail.com>\");\nMODULE_AUTHOR(\"Ron Minnich <rminnich@lanl.gov>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}