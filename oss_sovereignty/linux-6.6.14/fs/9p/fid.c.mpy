{
  "module_name": "fid.c",
  "hash_id": "eb3d93390c0db6dfdb6d25e3c50395db116825e44a0bdeec1bc936aac7014621",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/fid.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n\nstatic inline void __add_fid(struct dentry *dentry, struct p9_fid *fid)\n{\n\thlist_add_head(&fid->dlist, (struct hlist_head *)&dentry->d_fsdata);\n}\n\n\n \nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid **pfid)\n{\n\tstruct p9_fid *fid = *pfid;\n\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n\n\t*pfid = NULL;\n}\n\nstatic bool v9fs_is_writeable(int mode)\n{\n\tif (mode & (P9_OWRITE|P9_ORDWR))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstruct p9_fid *v9fs_fid_find_inode(struct inode *inode, bool want_writeable,\n\tkuid_t uid, bool any)\n{\n\tstruct hlist_head *h;\n\tstruct p9_fid *fid, *ret = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" inode: %p\\n\", inode);\n\n\tspin_lock(&inode->i_lock);\n\th = (struct hlist_head *)&inode->i_private;\n\thlist_for_each_entry(fid, h, ilist) {\n\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\tif (want_writeable && !v9fs_is_writeable(fid->mode)) {\n\t\t\t\tp9_debug(P9_DEBUG_VFS, \" mode: %x not writeable?\\n\",\n\t\t\t\t\t\t\tfid->mode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp9_fid_get(fid);\n\t\t\tret = fid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\n \n\nvoid v9fs_open_fid_add(struct inode *inode, struct p9_fid **pfid)\n{\n\tstruct p9_fid *fid = *pfid;\n\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&fid->ilist, (struct hlist_head *)&inode->i_private);\n\tspin_unlock(&inode->i_lock);\n\n\t*pfid = NULL;\n}\n\n\n \n\nstatic struct p9_fid *v9fs_fid_find(struct dentry *dentry, kuid_t uid, int any)\n{\n\tstruct p9_fid *fid, *ret;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p) uid %d any %d\\n\",\n\t\t dentry, dentry, from_kuid(&init_user_ns, uid),\n\t\t any);\n\tret = NULL;\n\t \n\tif (dentry->d_fsdata) {\n\t\tstruct hlist_head *h = (struct hlist_head *)&dentry->d_fsdata;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\thlist_for_each_entry(fid, h, dlist) {\n\t\t\tif (any || uid_eq(fid->uid, uid)) {\n\t\t\t\tret = fid;\n\t\t\t\tp9_fid_get(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t} else {\n\t\tif (dentry->d_inode)\n\t\t\tret = v9fs_fid_find_inode(dentry->d_inode, false, uid, any);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int build_path_from_dentry(struct v9fs_session_info *v9ses,\n\t\t\t\t  struct dentry *dentry, const unsigned char ***names)\n{\n\tint n = 0, i;\n\tconst unsigned char **wnames;\n\tstruct dentry *ds;\n\n\tfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\n\t\tn++;\n\n\twnames = kmalloc_array(n, sizeof(char *), GFP_KERNEL);\n\tif (!wnames)\n\t\tgoto err_out;\n\n\tfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\n\t\twnames[i] = ds->d_name.name;\n\n\t*names = wnames;\n\treturn n;\nerr_out:\n\treturn -ENOMEM;\n}\n\nstatic struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\n\t\t\t\t\t       kuid_t uid, int any)\n{\n\tstruct dentry *ds;\n\tconst unsigned char **wnames, *uname;\n\tint i, n, l, access;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid, *root_fid, *old_fid;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tfid = v9fs_fid_find(dentry, uid, any);\n\tif (fid)\n\t\treturn fid;\n\t \n\tdown_read(&v9ses->rename_sem);\n\tds = dentry->d_parent;\n\tfid = v9fs_fid_find(ds, uid, any);\n\tif (fid) {\n\t\t \n\t\told_fid = fid;\n\n\t\tfid = p9_client_walk(old_fid, 1, &dentry->d_name.name, 1);\n\t\tp9_fid_put(old_fid);\n\t\tgoto fid_out;\n\t}\n\tup_read(&v9ses->rename_sem);\n\n\t \n\troot_fid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\n\tif (!root_fid) {\n\t\t \n\t\tif (access == V9FS_ACCESS_SINGLE)\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\tif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\n\t\t\tuname = NULL;\n\t\telse\n\t\t\tuname = v9ses->uname;\n\n\t\tfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\n\t\t\t\t       v9ses->aname);\n\t\tif (IS_ERR(fid))\n\t\t\treturn fid;\n\n\t\troot_fid = p9_fid_get(fid);\n\t\tv9fs_fid_add(dentry->d_sb->s_root, &fid);\n\t}\n\t \n\tif (dentry->d_sb->s_root == dentry)\n\t\treturn root_fid;\n\n\t \n\tdown_read(&v9ses->rename_sem);\n\tn  = build_path_from_dentry(v9ses, dentry, &wnames);\n\tif (n < 0) {\n\t\tfid = ERR_PTR(n);\n\t\tgoto err_out;\n\t}\n\tfid = root_fid;\n\told_fid = root_fid;\n\ti = 0;\n\twhile (i < n) {\n\t\tl = min(n - i, P9_MAXWELEM);\n\t\t \n\t\tfid = p9_client_walk(old_fid, l, &wnames[i],\n\t\t\t\t     old_fid == root_fid  );\n\t\t \n\t\tif (fid != old_fid) {\n\t\t\tp9_fid_put(old_fid);\n\t\t\told_fid = fid;\n\t\t}\n\t\tif (IS_ERR(fid)) {\n\t\t\tkfree(wnames);\n\t\t\tgoto err_out;\n\t\t}\n\t\ti += l;\n\t}\n\tkfree(wnames);\nfid_out:\n\tif (!IS_ERR(fid)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (d_unhashed(dentry)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tp9_fid_put(fid);\n\t\t\tfid = ERR_PTR(-ENOENT);\n\t\t} else {\n\t\t\t__add_fid(dentry, fid);\n\t\t\tp9_fid_get(fid);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t}\nerr_out:\n\tup_read(&v9ses->rename_sem);\n\treturn fid;\n}\n\n \n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}