{
  "module_name": "vfs_dir.c",
  "hash_id": "85c47d1ccb7230f2112a7247ec0441b1198d1644bfd746a69fa16428808b0140",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_dir.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n#include <linux/fscache.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n\n \n\nstruct p9_rdir {\n\tint head;\n\tint tail;\n\tuint8_t buf[];\n};\n\n \n\nstatic inline int dt_type(struct p9_wstat *mistat)\n{\n\tunsigned long perm = mistat->mode;\n\tint rettype = DT_REG;\n\n\tif (perm & P9_DMDIR)\n\t\trettype = DT_DIR;\n\tif (perm & P9_DMSYMLINK)\n\t\trettype = DT_LNK;\n\n\treturn rettype;\n}\n\n \n\nstatic struct p9_rdir *v9fs_alloc_rdir_buf(struct file *filp, int buflen)\n{\n\tstruct p9_fid *fid = filp->private_data;\n\n\tif (!fid->rdir)\n\t\tfid->rdir = kzalloc(sizeof(struct p9_rdir) + buflen, GFP_KERNEL);\n\treturn fid->rdir;\n}\n\n \n\nstatic int v9fs_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tbool over;\n\tstruct p9_wstat st;\n\tint err = 0;\n\tstruct p9_fid *fid;\n\tint buflen;\n\tstruct p9_rdir *rdir;\n\tstruct kvec kvec;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pD\\n\", file);\n\tfid = file->private_data;\n\n\tbuflen = fid->clnt->msize - P9_IOHDRSZ;\n\n\trdir = v9fs_alloc_rdir_buf(file, buflen);\n\tif (!rdir)\n\t\treturn -ENOMEM;\n\tkvec.iov_base = rdir->buf;\n\tkvec.iov_len = buflen;\n\n\twhile (1) {\n\t\tif (rdir->tail == rdir->head) {\n\t\t\tstruct iov_iter to;\n\t\t\tint n;\n\n\t\t\tiov_iter_kvec(&to, ITER_DEST, &kvec, 1, buflen);\n\t\t\tn = p9_client_read(file->private_data, ctx->pos, &to,\n\t\t\t\t\t   &err);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (n == 0)\n\t\t\t\treturn 0;\n\n\t\t\trdir->head = 0;\n\t\t\trdir->tail = n;\n\t\t}\n\t\twhile (rdir->head < rdir->tail) {\n\t\t\terr = p9stat_read(fid->clnt, rdir->buf + rdir->head,\n\t\t\t\t\t  rdir->tail - rdir->head, &st);\n\t\t\tif (err <= 0) {\n\t\t\t\tp9_debug(P9_DEBUG_VFS, \"returned %d\\n\", err);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tover = !dir_emit(ctx, st.name, strlen(st.name),\n\t\t\t\t\t v9fs_qid2ino(&st.qid), dt_type(&st));\n\t\t\tp9stat_free(&st);\n\t\t\tif (over)\n\t\t\t\treturn 0;\n\n\t\t\trdir->head += err;\n\t\t\tctx->pos += err;\n\t\t}\n\t}\n}\n\n \nstatic int v9fs_dir_readdir_dotl(struct file *file, struct dir_context *ctx)\n{\n\tint err = 0;\n\tstruct p9_fid *fid;\n\tint buflen;\n\tstruct p9_rdir *rdir;\n\tstruct p9_dirent curdirent;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pD\\n\", file);\n\tfid = file->private_data;\n\n\tbuflen = fid->clnt->msize - P9_READDIRHDRSZ;\n\n\trdir = v9fs_alloc_rdir_buf(file, buflen);\n\tif (!rdir)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tif (rdir->tail == rdir->head) {\n\t\t\terr = p9_client_readdir(fid, rdir->buf, buflen,\n\t\t\t\t\t\tctx->pos);\n\t\t\tif (err <= 0)\n\t\t\t\treturn err;\n\n\t\t\trdir->head = 0;\n\t\t\trdir->tail = err;\n\t\t}\n\n\t\twhile (rdir->head < rdir->tail) {\n\n\t\t\terr = p9dirent_read(fid->clnt, rdir->buf + rdir->head,\n\t\t\t\t\t    rdir->tail - rdir->head,\n\t\t\t\t\t    &curdirent);\n\t\t\tif (err < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_VFS, \"returned %d\\n\", err);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (!dir_emit(ctx, curdirent.d_name,\n\t\t\t\t      strlen(curdirent.d_name),\n\t\t\t\t      v9fs_qid2ino(&curdirent.qid),\n\t\t\t\t      curdirent.d_type))\n\t\t\t\treturn 0;\n\n\t\t\tctx->pos = curdirent.d_off;\n\t\t\trdir->head += err;\n\t\t}\n\t}\n}\n\n\n \n\nint v9fs_dir_release(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_fid *fid;\n\t__le32 version;\n\tloff_t i_size;\n\tint retval = 0, put_err;\n\n\tfid = filp->private_data;\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p filp: %p fid: %d\\n\",\n\t\t inode, filp, fid ? fid->fid : -1);\n\n\tif (fid) {\n\t\tif ((S_ISREG(inode->i_mode)) && (filp->f_mode & FMODE_WRITE))\n\t\t\tretval = filemap_fdatawrite(inode->i_mapping);\n\n\t\tspin_lock(&inode->i_lock);\n\t\thlist_del(&fid->ilist);\n\t\tspin_unlock(&inode->i_lock);\n\t\tput_err = p9_fid_put(fid);\n\t\tretval = retval < 0 ? retval : put_err;\n\t}\n\n\tif ((filp->f_mode & FMODE_WRITE)) {\n\t\tversion = cpu_to_le32(v9inode->qid.version);\n\t\ti_size = i_size_read(inode);\n\t\tfscache_unuse_cookie(v9fs_inode_cookie(v9inode),\n\t\t\t\t     &version, &i_size);\n\t} else {\n\t\tfscache_unuse_cookie(v9fs_inode_cookie(v9inode), NULL, NULL);\n\t}\n\treturn retval;\n}\n\nconst struct file_operations v9fs_dir_operations = {\n\t.read = generic_read_dir,\n\t.llseek = generic_file_llseek,\n\t.iterate_shared = v9fs_dir_readdir,\n\t.open = v9fs_file_open,\n\t.release = v9fs_dir_release,\n};\n\nconst struct file_operations v9fs_dir_operations_dotl = {\n\t.read = generic_read_dir,\n\t.llseek = generic_file_llseek,\n\t.iterate_shared = v9fs_dir_readdir_dotl,\n\t.open = v9fs_file_open,\n\t.release = v9fs_dir_release,\n\t.fsync = v9fs_file_fsync_dotl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}