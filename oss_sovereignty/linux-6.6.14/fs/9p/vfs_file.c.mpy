{
  "module_name": "vfs_file.c",
  "hash_id": "acbc5b830d292797b5339525fb5b2bb835e5e357dbda01cb8e0f74e6f7b11a72",
  "original_prompt": "Ingested from linux-6.6.14/fs/9p/vfs_file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <net/9p/9p.h>\n#include <net/9p/client.h>\n\n#include \"v9fs.h\"\n#include \"v9fs_vfs.h\"\n#include \"fid.h\"\n#include \"cache.h\"\n\nstatic const struct vm_operations_struct v9fs_mmap_file_vm_ops;\n\n \n\nint v9fs_file_open(struct inode *inode, struct file *file)\n{\n\tint err;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tint omode;\n\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p file: %p\\n\", inode, file);\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9fs_proto_dotl(v9ses))\n\t\tomode = v9fs_open_to_dotl_flags(file->f_flags);\n\telse\n\t\tomode = v9fs_uflags2omode(file->f_flags,\n\t\t\t\t\tv9fs_proto_dotu(v9ses));\n\tfid = file->private_data;\n\tif (!fid) {\n\t\tfid = v9fs_fid_clone(file_dentry(file));\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\tif ((v9ses->cache & CACHE_WRITEBACK) && (omode & P9_OWRITE)) {\n\t\t\tint writeback_omode = (omode & ~P9_OWRITE) | P9_ORDWR;\n\n\t\t\tp9_debug(P9_DEBUG_CACHE, \"write-only file with writeback enabled, try opening O_RDWR\\n\");\n\t\t\terr = p9_client_open(fid, writeback_omode);\n\t\t\tif (err < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_CACHE, \"could not open O_RDWR, disabling caches\\n\");\n\t\t\t\terr = p9_client_open(fid, omode);\n\t\t\t\tfid->mode |= P9L_DIRECT;\n\t\t\t}\n\t\t} else {\n\t\t\terr = p9_client_open(fid, omode);\n\t\t}\n\t\tif (err < 0) {\n\t\t\tp9_fid_put(fid);\n\t\t\treturn err;\n\t\t}\n\t\tif ((file->f_flags & O_APPEND) &&\n\t\t\t(!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)))\n\t\t\tgeneric_file_llseek(file, 0, SEEK_END);\n\n\t\tfile->private_data = fid;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->cache & CACHE_FSCACHE)\n\t\tfscache_use_cookie(v9fs_inode_cookie(V9FS_I(inode)),\n\t\t\t\t   file->f_mode & FMODE_WRITE);\n#endif\n\tv9fs_fid_add_modes(fid, v9ses->flags, v9ses->cache, file->f_flags);\n\tv9fs_open_fid_add(inode, &fid);\n\treturn 0;\n}\n\n \n\nstatic int v9fs_file_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p lock: %p\\n\", filp, fl);\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int v9fs_file_do_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct p9_flock flock;\n\tstruct p9_fid *fid;\n\tuint8_t status = P9_LOCK_ERROR;\n\tint res = 0;\n\tunsigned char fl_type;\n\tstruct v9fs_session_info *v9ses;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tBUG_ON((fl->fl_flags & FL_POSIX) != FL_POSIX);\n\n\tres = locks_lock_file_wait(filp, fl);\n\tif (res < 0)\n\t\tgoto out;\n\n\t \n\tmemset(&flock, 0, sizeof(flock));\n\t \n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tflock.type = P9_LOCK_TYPE_RDLCK;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tflock.type = P9_LOCK_TYPE_WRLCK;\n\t\tbreak;\n\tcase F_UNLCK:\n\t\tflock.type = P9_LOCK_TYPE_UNLCK;\n\t\tbreak;\n\t}\n\tflock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tflock.length = 0;\n\telse\n\t\tflock.length = fl->fl_end - fl->fl_start + 1;\n\tflock.proc_id = fl->fl_pid;\n\tflock.client_id = fid->clnt->name;\n\tif (IS_SETLKW(cmd))\n\t\tflock.flags = P9_LOCK_FLAGS_BLOCK;\n\n\tv9ses = v9fs_inode2v9ses(file_inode(filp));\n\n\t \n\tfor (;;) {\n\t\tres = p9_client_lock_dotl(fid, &flock, &status);\n\t\tif (res < 0)\n\t\t\tgoto out_unlock;\n\n\t\tif (status != P9_LOCK_BLOCKED)\n\t\t\tbreak;\n\t\tif (status == P9_LOCK_BLOCKED && !IS_SETLKW(cmd))\n\t\t\tbreak;\n\t\tif (schedule_timeout_interruptible(v9ses->session_lock_timeout)\n\t\t\t\t!= 0)\n\t\t\tbreak;\n\t\t \n\t\tif (flock.client_id != fid->clnt->name) {\n\t\t\tkfree(flock.client_id);\n\t\t\tflock.client_id = fid->clnt->name;\n\t\t}\n\t}\n\n\t \n\tswitch (status) {\n\tcase P9_LOCK_SUCCESS:\n\t\tres = 0;\n\t\tbreak;\n\tcase P9_LOCK_BLOCKED:\n\t\tres = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"unknown lock status code: %d\\n\", status);\n\t\tfallthrough;\n\tcase P9_LOCK_ERROR:\n\tcase P9_LOCK_GRACE:\n\t\tres = -ENOLCK;\n\t\tbreak;\n\t}\n\nout_unlock:\n\t \n\tif (res < 0 && fl->fl_type != F_UNLCK) {\n\t\tfl_type = fl->fl_type;\n\t\tfl->fl_type = F_UNLCK;\n\t\t \n\t\tlocks_lock_file_wait(filp, fl);\n\t\tfl->fl_type = fl_type;\n\t}\n\tif (flock.client_id != fid->clnt->name)\n\t\tkfree(flock.client_id);\nout:\n\treturn res;\n}\n\nstatic int v9fs_file_getlock(struct file *filp, struct file_lock *fl)\n{\n\tstruct p9_getlock glock;\n\tstruct p9_fid *fid;\n\tint res = 0;\n\n\tfid = filp->private_data;\n\tBUG_ON(fid == NULL);\n\n\tposix_test_lock(filp, fl);\n\t \n\tif (fl->fl_type != F_UNLCK)\n\t\treturn res;\n\n\t \n\tmemset(&glock, 0, sizeof(glock));\n\tglock.type  = P9_LOCK_TYPE_UNLCK;\n\tglock.start = fl->fl_start;\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tglock.length = 0;\n\telse\n\t\tglock.length = fl->fl_end - fl->fl_start + 1;\n\tglock.proc_id = fl->fl_pid;\n\tglock.client_id = fid->clnt->name;\n\n\tres = p9_client_getlock_dotl(fid, &glock);\n\tif (res < 0)\n\t\tgoto out;\n\t \n\tswitch (glock.type) {\n\tcase P9_LOCK_TYPE_RDLCK:\n\t\tfl->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_WRLCK:\n\t\tfl->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase P9_LOCK_TYPE_UNLCK:\n\t\tfl->fl_type = F_UNLCK;\n\t\tbreak;\n\t}\n\tif (glock.type != P9_LOCK_TYPE_UNLCK) {\n\t\tfl->fl_start = glock.start;\n\t\tif (glock.length == 0)\n\t\t\tfl->fl_end = OFFSET_MAX;\n\t\telse\n\t\t\tfl->fl_end = glock.start + glock.length - 1;\n\t\tfl->fl_pid = -glock.proc_id;\n\t}\nout:\n\tif (glock.client_id != fid->clnt->name)\n\t\tkfree(glock.client_id);\n\treturn res;\n}\n\n \n\nstatic int v9fs_file_lock_dotl(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse if (IS_GETLK(cmd))\n\t\tret = v9fs_file_getlock(filp, fl);\n\telse\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n \n\nstatic int v9fs_file_flock_dotl(struct file *filp, int cmd,\n\tstruct file_lock *fl)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint ret = -ENOLCK;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp: %p cmd:%d lock: %p name: %pD\\n\",\n\t\t filp, cmd, fl, filp);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\tgoto out_err;\n\n\tif ((IS_SETLK(cmd) || IS_SETLKW(cmd)) && fl->fl_type != F_UNLCK) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\t}\n\t \n\tfl->fl_flags |= FL_POSIX;\n\tfl->fl_flags ^= FL_FLOCK;\n\n\tif (IS_SETLK(cmd) | IS_SETLKW(cmd))\n\t\tret = v9fs_file_do_lock(filp, cmd, fl);\n\telse\n\t\tret = -EINVAL;\nout_err:\n\treturn ret;\n}\n\n \nstatic ssize_t\nv9fs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct p9_fid *fid = iocb->ki_filp->private_data;\n\tint ret, err = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d count %zu offset %lld\\n\",\n\t\t fid->fid, iov_iter_count(to), iocb->ki_pos);\n\n\tif (!(fid->mode & P9L_DIRECT)) {\n\t\tp9_debug(P9_DEBUG_VFS, \"(cached)\\n\");\n\t\treturn generic_file_read_iter(iocb, to);\n\t}\n\n\tif (iocb->ki_filp->f_flags & O_NONBLOCK)\n\t\tret = p9_client_read_once(fid, iocb->ki_pos, to, &err);\n\telse\n\t\tret = p9_client_read(fid, iocb->ki_pos, to, &err);\n\tif (!ret)\n\t\treturn err;\n\n\tiocb->ki_pos += ret;\n\treturn ret;\n}\n\n \nstatic ssize_t v9fs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t     struct pipe_inode_info *pipe,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tstruct p9_fid *fid = in->private_data;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d count %zu offset %lld\\n\",\n\t\t fid->fid, len, *ppos);\n\n\tif (fid->mode & P9L_DIRECT)\n\t\treturn copy_splice_read(in, ppos, pipe, len, flags);\n\treturn filemap_splice_read(in, ppos, pipe, len, flags);\n}\n\n \nstatic ssize_t\nv9fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct p9_fid *fid = file->private_data;\n\tssize_t retval;\n\tloff_t origin;\n\tint err = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d\\n\", fid->fid);\n\n\tif (!(fid->mode & (P9L_DIRECT | P9L_NOWRITECACHE))) {\n\t\tp9_debug(P9_DEBUG_CACHE, \"(cached)\\n\");\n\t\treturn generic_file_write_iter(iocb, from);\n\t}\n\n\tretval = generic_write_checks(iocb, from);\n\tif (retval <= 0)\n\t\treturn retval;\n\n\torigin = iocb->ki_pos;\n\tretval = p9_client_write(file->private_data, iocb->ki_pos, from, &err);\n\tif (retval > 0) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tloff_t i_size;\n\t\tunsigned long pg_start, pg_end;\n\n\t\tpg_start = origin >> PAGE_SHIFT;\n\t\tpg_end = (origin + retval - 1) >> PAGE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\tiocb->ki_pos += retval;\n\t\ti_size = i_size_read(inode);\n\t\tif (iocb->ki_pos > i_size) {\n\t\t\tinode_add_bytes(inode, iocb->ki_pos - i_size);\n\t\t\t \n\t\t\tv9fs_i_size_write(inode, iocb->ki_pos);\n\t\t}\n\t\treturn retval;\n\t}\n\treturn err;\n}\n\nstatic int v9fs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct p9_wstat wstat;\n\tint retval;\n\n\tretval = file_write_and_wait_range(filp, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tinode_lock(inode);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\tv9fs_blank_wstat(&wstat);\n\n\tretval = p9_client_wstat(fid, &wstat);\n\tinode_unlock(inode);\n\n\treturn retval;\n}\n\nint v9fs_file_fsync_dotl(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct p9_fid *fid;\n\tstruct inode *inode = filp->f_mapping->host;\n\tint retval;\n\n\tretval = file_write_and_wait_range(filp, start, end);\n\tif (retval)\n\t\treturn retval;\n\n\tinode_lock(inode);\n\tp9_debug(P9_DEBUG_VFS, \"filp %p datasync %x\\n\", filp, datasync);\n\n\tfid = filp->private_data;\n\n\tretval = p9_client_fsync(fid, datasync);\n\tinode_unlock(inode);\n\n\treturn retval;\n}\n\nstatic int\nv9fs_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tint retval;\n\tstruct inode *inode = file_inode(filp);\n\tstruct v9fs_session_info *v9ses = v9fs_inode2v9ses(inode);\n\n\tp9_debug(P9_DEBUG_MMAP, \"filp :%p\\n\", filp);\n\n\tif (!(v9ses->cache & CACHE_WRITEBACK)) {\n\t\tp9_debug(P9_DEBUG_CACHE, \"(read-only mmap mode)\");\n\t\treturn generic_file_readonly_mmap(filp, vma);\n\t}\n\n\tretval = generic_file_mmap(filp, vma);\n\tif (!retval)\n\t\tvma->vm_ops = &v9fs_mmap_file_vm_ops;\n\n\treturn retval;\n}\n\nstatic vm_fault_t\nv9fs_vm_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct folio *folio = page_folio(vmf->page);\n\tstruct file *filp = vmf->vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\n\n\tp9_debug(P9_DEBUG_VFS, \"folio %p fid %lx\\n\",\n\t\t folio, (unsigned long)filp->private_data);\n\n\t \n#ifdef CONFIG_9P_FSCACHE\n\tif (folio_test_fscache(folio) &&\n\t    folio_wait_fscache_killable(folio) < 0)\n\t\treturn VM_FAULT_NOPAGE;\n#endif\n\n\t \n\tfile_update_time(filp);\n\n\tif (folio_lock_killable(folio) < 0)\n\t\treturn VM_FAULT_RETRY;\n\tif (folio_mapping(folio) != inode->i_mapping)\n\t\tgoto out_unlock;\n\tfolio_wait_stable(folio);\n\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tfolio_unlock(folio);\n\treturn VM_FAULT_NOPAGE;\n}\n\nstatic void v9fs_mmap_vm_close(struct vm_area_struct *vma)\n{\n\tstruct inode *inode;\n\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.range_start = (loff_t)vma->vm_pgoff * PAGE_SIZE,\n\t\t  \n\t\t.range_end = (loff_t)vma->vm_pgoff * PAGE_SIZE +\n\t\t\t(vma->vm_end - vma->vm_start - 1),\n\t};\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn;\n\n\tp9_debug(P9_DEBUG_VFS, \"9p VMA close, %p, flushing\", vma);\n\n\tinode = file_inode(vma->vm_file);\n\tfilemap_fdatawrite_wbc(inode->i_mapping, &wbc);\n}\n\nstatic const struct vm_operations_struct v9fs_mmap_file_vm_ops = {\n\t.close = v9fs_mmap_vm_close,\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = v9fs_vm_page_mkwrite,\n};\n\nconst struct file_operations v9fs_file_operations = {\n\t.llseek = generic_file_llseek,\n\t.read_iter = v9fs_file_read_iter,\n\t.write_iter = v9fs_file_write_iter,\n\t.open = v9fs_file_open,\n\t.release = v9fs_dir_release,\n\t.lock = v9fs_file_lock,\n\t.mmap = generic_file_readonly_mmap,\n\t.splice_read = v9fs_file_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.fsync = v9fs_file_fsync,\n};\n\nconst struct file_operations v9fs_file_operations_dotl = {\n\t.llseek = generic_file_llseek,\n\t.read_iter = v9fs_file_read_iter,\n\t.write_iter = v9fs_file_write_iter,\n\t.open = v9fs_file_open,\n\t.release = v9fs_dir_release,\n\t.lock = v9fs_file_lock_dotl,\n\t.flock = v9fs_file_flock_dotl,\n\t.mmap = v9fs_file_mmap,\n\t.splice_read = v9fs_file_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.fsync = v9fs_file_fsync_dotl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}