{
  "module_name": "inode.c",
  "hash_id": "4724aa63e7e5a2e0b0a62cd19d6c4c20d5ed8423933e7df984fd088eb4b3dc6d",
  "original_prompt": "Ingested from linux-6.6.14/fs/omfs/inode.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/cred.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/seq_file.h>\n#include <linux/crc-itu-t.h>\n#include \"omfs.h\"\n\nMODULE_AUTHOR(\"Bob Copeland <me@bobcopeland.com>\");\nMODULE_DESCRIPTION(\"OMFS (ReplayTV/Karma) Filesystem for Linux\");\nMODULE_LICENSE(\"GPL\");\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}\n\nstruct inode *omfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tu64 new_block;\n\tint err;\n\tint len;\n\tstruct omfs_sb_info *sbi = OMFS_SB(dir->i_sb);\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = omfs_allocate_range(dir->i_sb, sbi->s_mirrors, sbi->s_mirrors,\n\t\t\t&new_block, &len);\n\tif (err)\n\t\tgoto fail;\n\n\tinode->i_ino = new_block;\n\tinode_init_owner(&nop_mnt_idmap, inode, NULL, mode);\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &omfs_file_inops;\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = 0;\n\t\tbreak;\n\t}\n\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\treturn inode;\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void omfs_update_checksums(struct omfs_inode *oi)\n{\n\tint xor, i, ofs = 0, count;\n\tu16 crc = 0;\n\tunsigned char *ptr = (unsigned char *) oi;\n\n\tcount = be32_to_cpu(oi->i_head.h_body_size);\n\tofs = sizeof(struct omfs_header);\n\n\tcrc = crc_itu_t(crc, ptr + ofs, count);\n\toi->i_head.h_crc = cpu_to_be16(crc);\n\n\txor = ptr[0];\n\tfor (i = 1; i < OMFS_XOR_COUNT; i++)\n\t\txor ^= ptr[i];\n\n\toi->i_head.h_check_xor = xor;\n}\n\nstatic int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t \n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode_get_ctime(inode).tv_sec * 1000LL +\n\t\t((inode_get_ctime(inode).tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t \n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}\n\nstatic int omfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __omfs_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}\n\nint omfs_sync_inode(struct inode *inode)\n{\n\treturn __omfs_write_inode(inode, 1);\n}\n\n \nstatic void omfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\tomfs_shrink_inode(inode);\n\t}\n\n\tomfs_clear_range(inode->i_sb, inode->i_ino, 2);\n}\n\nstruct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t \n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode_set_ctime(inode, ctime, nsecs);\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}\n\nstatic void omfs_put_super(struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tkfree(sbi->s_imap);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n}\n\nstatic int omfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct omfs_sb_info *sbi = OMFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\tbuf->f_type = OMFS_MAGIC;\n\tbuf->f_bsize = sbi->s_blocksize;\n\tbuf->f_blocks = sbi->s_num_blocks;\n\tbuf->f_files = sbi->s_num_blocks;\n\tbuf->f_namelen = OMFS_NAMELEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\tbuf->f_bfree = buf->f_bavail = buf->f_ffree =\n\t\tomfs_count_free(s);\n\n\treturn 0;\n}\n\n \nstatic int omfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(root->d_sb);\n\tumode_t cur_umask = current_umask();\n\n\tif (!uid_eq(sbi->s_uid, current_uid()))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, sbi->s_uid));\n\tif (!gid_eq(sbi->s_gid, current_gid()))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, sbi->s_gid));\n\n\tif (sbi->s_dmask == sbi->s_fmask) {\n\t\tif (sbi->s_fmask != cur_umask)\n\t\t\tseq_printf(m, \",umask=%o\", sbi->s_fmask);\n\t} else {\n\t\tif (sbi->s_dmask != cur_umask)\n\t\t\tseq_printf(m, \",dmask=%o\", sbi->s_dmask);\n\t\tif (sbi->s_fmask != cur_umask)\n\t\t\tseq_printf(m, \",fmask=%o\", sbi->s_fmask);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct super_operations omfs_sops = {\n\t.write_inode\t= omfs_write_inode,\n\t.evict_inode\t= omfs_evict_inode,\n\t.put_super\t= omfs_put_super,\n\t.statfs\t\t= omfs_statfs,\n\t.show_options\t= omfs_show_options,\n};\n\n \nstatic int omfs_get_imap(struct super_block *sb)\n{\n\tunsigned int bitmap_size, array_size;\n\tint count;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmemdup(bh->b_data, sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n\n\tkfree(sbi->s_imap);\nnomem:\n\tsbi->s_imap = NULL;\n\tsbi->s_imap_size = 0;\n\treturn -ENOMEM;\n}\n\nenum {\n\tOpt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_options(char *options, struct omfs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(sbi->s_uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(sbi->s_gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = sbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int omfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh, *bh2;\n\tstruct omfs_super_block *omfs_sb;\n\tstruct omfs_root_block *omfs_rb;\n\tstruct omfs_sb_info *sbi;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(struct omfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tsbi->s_uid = current_uid();\n\tsbi->s_gid = current_gid();\n\tsbi->s_dmask = sbi->s_fmask = current_umask();\n\n\tif (!parse_options((char *) data, sbi))\n\t\tgoto end;\n\n\tsb->s_maxbytes = 0xffffffff;\n\n\tsb->s_time_gran = NSEC_PER_MSEC;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U64_MAX / MSEC_PER_SEC;\n\n\tsb_set_blocksize(sb, 0x200);\n\n\tbh = sb_bread(sb, 0);\n\tif (!bh)\n\t\tgoto end;\n\n\tomfs_sb = (struct omfs_super_block *)bh->b_data;\n\n\tif (omfs_sb->s_magic != cpu_to_be32(OMFS_MAGIC)) {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"omfs: Invalid superblock (%x)\\n\",\n\t\t\t\t   omfs_sb->s_magic);\n\t\tgoto out_brelse_bh;\n\t}\n\tsb->s_magic = OMFS_MAGIC;\n\n\tsbi->s_num_blocks = be64_to_cpu(omfs_sb->s_num_blocks);\n\tsbi->s_blocksize = be32_to_cpu(omfs_sb->s_blocksize);\n\tsbi->s_mirrors = be32_to_cpu(omfs_sb->s_mirrors);\n\tsbi->s_root_ino = be64_to_cpu(omfs_sb->s_root_block);\n\tsbi->s_sys_blocksize = be32_to_cpu(omfs_sb->s_sys_blocksize);\n\tmutex_init(&sbi->s_bitmap_lock);\n\n\tif (sbi->s_num_blocks > OMFS_MAX_BLOCKS) {\n\t\tprintk(KERN_ERR \"omfs: sysblock number (%llx) is out of range\\n\",\n\t\t       (unsigned long long)sbi->s_num_blocks);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_sys_blocksize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: sysblock size (%d) is out of range\\n\",\n\t\t\tsbi->s_sys_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_blocksize < sbi->s_sys_blocksize ||\n\t    sbi->s_blocksize > OMFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: block size (%d) is out of range\\n\",\n\t\t\tsbi->s_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\t \n\tsb_set_blocksize(sb, sbi->s_sys_blocksize);\n\n\t \n\tsbi->s_block_shift = get_bitmask_order(sbi->s_blocksize) -\n\t\tget_bitmask_order(sbi->s_sys_blocksize);\n\n\tbh2 = omfs_bread(sb, be64_to_cpu(omfs_sb->s_root_block));\n\tif (!bh2)\n\t\tgoto out_brelse_bh;\n\n\tomfs_rb = (struct omfs_root_block *)bh2->b_data;\n\n\tsbi->s_bitmap_ino = be64_to_cpu(omfs_rb->r_bitmap);\n\tsbi->s_clustersize = be32_to_cpu(omfs_rb->r_clustersize);\n\n\tif (sbi->s_num_blocks != be64_to_cpu(omfs_rb->r_num_blocks)) {\n\t\tprintk(KERN_ERR \"omfs: block count discrepancy between \"\n\t\t\t\"super and root blocks (%llx, %llx)\\n\",\n\t\t\t(unsigned long long)sbi->s_num_blocks,\n\t\t\t(unsigned long long)be64_to_cpu(omfs_rb->r_num_blocks));\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tif (sbi->s_bitmap_ino != ~0ULL &&\n\t    sbi->s_bitmap_ino > sbi->s_num_blocks) {\n\t\tprintk(KERN_ERR \"omfs: free space bitmap location is corrupt \"\n\t\t\t\"(%llx, total blocks %llx)\\n\",\n\t\t\t(unsigned long long) sbi->s_bitmap_ino,\n\t\t\t(unsigned long long) sbi->s_num_blocks);\n\t\tgoto out_brelse_bh2;\n\t}\n\tif (sbi->s_clustersize < 1 ||\n\t    sbi->s_clustersize > OMFS_MAX_CLUSTER_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: cluster size out of range (%d)\",\n\t\t\tsbi->s_clustersize);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tret = omfs_get_imap(sb);\n\tif (ret)\n\t\tgoto out_brelse_bh2;\n\n\tsb->s_op = &omfs_sops;\n\n\troot = omfs_iget(sb, be64_to_cpu(omfs_rb->r_root_dir));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto out_brelse_bh2;\n\t}\n\tprintk(KERN_DEBUG \"omfs: Mounted volume %s\\n\", omfs_rb->r_name);\n\n\tret = 0;\nout_brelse_bh2:\n\tbrelse(bh2);\nout_brelse_bh:\n\tbrelse(bh);\nend:\n\tif (ret)\n\t\tkfree(sbi);\n\treturn ret;\n}\n\nstatic struct dentry *omfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, omfs_fill_super);\n}\n\nstatic struct file_system_type omfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"omfs\",\n\t.mount = omfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"omfs\");\n\nstatic int __init init_omfs_fs(void)\n{\n\treturn register_filesystem(&omfs_fs_type);\n}\n\nstatic void __exit exit_omfs_fs(void)\n{\n\tunregister_filesystem(&omfs_fs_type);\n}\n\nmodule_init(init_omfs_fs);\nmodule_exit(exit_omfs_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}