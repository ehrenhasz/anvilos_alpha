{
  "module_name": "bitmap.c",
  "hash_id": "88b9ff2447d46ed5bb85aa6268d41e124017385d1adf8bcf10e98b29575e955a",
  "original_prompt": "Ingested from linux-6.6.14/fs/omfs/bitmap.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <asm/div64.h>\n#include \"omfs.h\"\n\nunsigned long omfs_count_free(struct super_block *sb)\n{\n\tunsigned int i;\n\tunsigned long sum = 0;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint nbits = sb->s_blocksize * 8;\n\n\tfor (i = 0; i < sbi->s_imap_size; i++)\n\t\tsum += nbits - bitmap_weight(sbi->s_imap[i], nbits);\n\n\treturn sum;\n}\n\n \nstatic int count_run(unsigned long **addr, int nbits,\n\t\tint addrlen, int bit, int max)\n{\n\tint count = 0;\n\tint x;\n\n\tfor (; addrlen > 0; addrlen--, addr++) {\n\t\tx = find_next_bit(*addr, nbits, bit);\n\t\tcount += x - bit;\n\n\t\tif (x < nbits || count > max)\n\t\t\treturn min(count, max);\n\n\t\tbit = 0;\n\t}\n\treturn min(count, max);\n}\n\n \nstatic int set_run(struct super_block *sb, int map,\n\t\tint nbits, int bit, int count, int set)\n{\n\tint i;\n\tint err;\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\n \terr = -ENOMEM;\n\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\tif (!bh)\n\t\tgoto out;\n\n\tfor (i = 0; i < count; i++, bit++) {\n\t\tif (bit >= nbits) {\n\t\t\tbit = 0;\n\t\t\tmap++;\n\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread(sb,\n\t\t\t\tclus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\t\tif (!bh)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (set) {\n\t\t\tset_bit(bit, sbi->s_imap[map]);\n\t\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\t} else {\n\t\t\tclear_bit(bit, sbi->s_imap[map]);\n\t\t\tclear_bit(bit, (unsigned long *)bh->b_data);\n\t\t}\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\terr = 0;\nout:\n\treturn err;\n}\n\n \nint omfs_allocate_block(struct super_block *sb, u64 block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tunsigned int map, bit;\n\tint ret = 0;\n\tu64 tmp;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tif (map >= sbi->s_imap_size || test_and_set_bit(bit, sbi->s_imap[map]))\n\t\tgoto out;\n\n\tif (sbi->s_bitmap_ino > 0) {\n\t\tbh = sb_bread(sb, clus_to_blk(sbi, sbi->s_bitmap_ino) + map);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tset_bit(bit, (unsigned long *)bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tret = 1;\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}\n\n\n \nint omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = (u64) i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}\n\n \nint omfs_clear_range(struct super_block *sb, u64 block, int count)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}