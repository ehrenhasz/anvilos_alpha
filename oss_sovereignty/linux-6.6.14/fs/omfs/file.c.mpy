{
  "module_name": "file.c",
  "hash_id": "c48170850a11fb6e52c8cc0026fd27e3cb93153f770a4d2ba065c874724d9025",
  "original_prompt": "Ingested from linux-6.6.14/fs/omfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include \"omfs.h\"\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry);\n}\n\nvoid omfs_make_empty_table(struct buffer_head *bh, int offset)\n{\n\tstruct omfs_extent *oe = (struct omfs_extent *) &bh->b_data[offset];\n\n\toe->e_next = ~cpu_to_be64(0ULL);\n\toe->e_extent_count = cpu_to_be32(1),\n\toe->e_fill = cpu_to_be32(0x22),\n\toe->e_entry[0].e_cluster = ~cpu_to_be64(0ULL);\n\toe->e_entry[0].e_blocks = ~cpu_to_be64(0ULL);\n}\n\nint omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t \n\tnext = inode->i_ino;\n\n\t \n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = oe->e_entry;\n\n\t\t \n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic void omfs_truncate(struct inode *inode)\n{\n\tomfs_shrink_inode(inode);\n\tmark_inode_dirty(inode);\n}\n\n \nstatic int omfs_grow_extent(struct inode *inode, struct omfs_extent *oe,\n\t\t\tu64 *ret_block)\n{\n\tstruct omfs_extent_entry *terminator;\n\tstruct omfs_extent_entry *entry = oe->e_entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tu32 extent_count = be32_to_cpu(oe->e_extent_count);\n\tu64 new_block = 0;\n\tu32 max_count;\n\tint new_count;\n\tint ret = 0;\n\n\t \n\n\t \n\n\t \n\tif (extent_count < 1)\n\t\treturn -EIO;\n\n\t \n\tterminator = entry + extent_count - 1;\n\tif (extent_count > 1) {\n\t\tentry = terminator-1;\n\t\tnew_block = be64_to_cpu(entry->e_cluster) +\n\t\t\tbe64_to_cpu(entry->e_blocks);\n\n\t\tif (omfs_allocate_block(inode->i_sb, new_block)) {\n\t\t\tbe64_add_cpu(&entry->e_blocks, 1);\n\t\t\tterminator->e_blocks = ~(cpu_to_be64(\n\t\t\t\tbe64_to_cpu(~terminator->e_blocks) + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmax_count = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\t \n\tif (be32_to_cpu(oe->e_extent_count) > max_count-1)\n\t\treturn -EIO;\n\n\t \n\tret = omfs_allocate_range(inode->i_sb, 1, sbi->s_clustersize,\n\t\t&new_block, &new_count);\n\tif (ret)\n\t\tgoto out_fail;\n\n\t \n\tentry = terminator;\n\tterminator++;\n\tmemcpy(terminator, entry, sizeof(struct omfs_extent_entry));\n\n\tentry->e_cluster = cpu_to_be64(new_block);\n\tentry->e_blocks = cpu_to_be64((u64) new_count);\n\n\tterminator->e_blocks = ~(cpu_to_be64(\n\t\tbe64_to_cpu(~terminator->e_blocks) + (u64) new_count));\n\n\t \n\tbe32_add_cpu(&oe->e_extent_count, 1);\n\nout:\n\t*ret_block = new_block;\nout_fail:\n\treturn ret;\n}\n\n \nstatic sector_t find_block(struct inode *inode, struct omfs_extent_entry *ent,\n\t\t\tsector_t block, int count, int *left)\n{\n\t \n\tsector_t searched = 0;\n\tfor (; count > 1; count--) {\n\t\tint numblocks = clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\tbe64_to_cpu(ent->e_blocks));\n\n\t\tif (block >= searched  &&\n\t\t    block < searched + numblocks) {\n\t\t\t \n\t\t\t*left = numblocks - (block - searched);\n\t\t\treturn clus_to_blk(OMFS_SB(inode->i_sb),\n\t\t\t\tbe64_to_cpu(ent->e_cluster)) +\n\t\t\t\tblock - searched;\n\t\t}\n\t\tsearched += numblocks;\n\t\tent++;\n\t}\n\treturn 0;\n}\n\nstatic int omfs_get_block(struct inode *inode, sector_t block,\n\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct buffer_head *bh;\n\tsector_t next, offset;\n\tint ret;\n\tu64 new_block;\n\tu32 max_extents;\n\tint extent_count;\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tint max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint remain;\n\n\tret = -EIO;\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\tnext = inode->i_ino;\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = oe->e_entry;\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\toffset = find_block(inode, entry, block, extent_count, &remain);\n\t\tif (offset > 0) {\n\t\t\tret = 0;\n\t\t\tmap_bh(bh_result, inode->i_sb, offset);\n\t\t\tif (remain > max_blocks)\n\t\t\t\tremain = max_blocks;\n\t\t\tbh_result->b_size = (remain << inode->i_blkbits);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbrelse(bh);\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tif (create) {\n\t\tret = omfs_grow_extent(inode, oe, &new_block);\n\t\tif (ret == 0) {\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmap_bh(bh_result, inode->i_sb,\n\t\t\t\t\tclus_to_blk(sbi, new_block));\n\t\t}\n\t}\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}\n\nstatic int omfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, omfs_get_block);\n}\n\nstatic void omfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, omfs_get_block);\n}\n\nstatic int\nomfs_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, omfs_get_block);\n}\n\nstatic void omfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tomfs_truncate(inode);\n\t}\n}\n\nstatic int omfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, pagep, omfs_get_block);\n\tif (unlikely(ret))\n\t\tomfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t omfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, omfs_get_block);\n}\n\nconst struct file_operations omfs_file_operations = {\n\t.llseek = generic_file_llseek,\n\t.read_iter = generic_file_read_iter,\n\t.write_iter = generic_file_write_iter,\n\t.mmap = generic_file_mmap,\n\t.fsync = generic_file_fsync,\n\t.splice_read = filemap_splice_read,\n};\n\nstatic int omfs_setattr(struct mnt_idmap *idmap,\n\t\t\tstruct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tomfs_truncate(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nconst struct inode_operations omfs_file_inops = {\n\t.setattr = omfs_setattr,\n};\n\nconst struct address_space_operations omfs_aops = {\n\t.dirty_folio = block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = omfs_read_folio,\n\t.readahead = omfs_readahead,\n\t.writepages = omfs_writepages,\n\t.write_begin = omfs_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = omfs_bmap,\n\t.migrate_folio = buffer_migrate_folio,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}