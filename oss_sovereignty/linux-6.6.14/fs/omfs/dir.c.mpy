{
  "module_name": "dir.c",
  "hash_id": "bc336219e0601672870f5f45e664eef9ea6ed177453676506df311e3e3adf1ae",
  "original_prompt": "Ingested from linux-6.6.14/fs/omfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/buffer_head.h>\n#include \"omfs.h\"\n\nstatic int omfs_hash(const char *name, int namelen, int mod)\n{\n\tint i, hash = 0;\n\tfor (i = 0; i < namelen; i++)\n\t\thash ^= tolower(name[i]) << (i % 24);\n\treturn hash % mod;\n}\n\n \nstatic struct buffer_head *omfs_get_bucket(struct inode *dir,\n\t\tconst char *name, int namelen, int *ofs)\n{\n\tint nbuckets = (dir->i_size - OMFS_DIR_START)/8;\n\tint bucket = omfs_hash(name, namelen, nbuckets);\n\n\t*ofs = OMFS_DIR_START + bucket * 8;\n\treturn omfs_bread(dir->i_sb, dir->i_ino);\n}\n\nstatic struct buffer_head *omfs_scan_list(struct inode *dir, u64 block,\n\t\t\t\tconst char *name, int namelen,\n\t\t\t\tu64 *prev_block)\n{\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\tint err = -ENOENT;\n\t*prev_block = ~0;\n\n\twhile (block != ~0) {\n\t\tbh = omfs_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, block)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (strncmp(oi->i_name, name, namelen) == 0)\n\t\t\treturn bh;\n\n\t\t*prev_block = block;\n\t\tblock = be64_to_cpu(oi->i_sibling);\n\t\tbrelse(bh);\n\t}\nerr:\n\treturn ERR_PTR(err);\n}\n\nstatic struct buffer_head *omfs_find_entry(struct inode *dir,\n\t\t\t\t\t   const char *name, int namelen)\n{\n\tstruct buffer_head *bh;\n\tint ofs;\n\tu64 block, dummy;\n\n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tblock = be64_to_cpu(*((__be64 *) &bh->b_data[ofs]));\n\tbrelse(bh);\n\n\treturn omfs_scan_list(dir, block, name, namelen, &dummy);\n}\n\nint omfs_make_empty(struct inode *inode, struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tstruct omfs_inode *oi;\n\n\tbh = omfs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tmemset(bh->b_data, 0, sizeof(struct omfs_inode));\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmemset(&bh->b_data[OMFS_DIR_START], 0xff,\n\t\t\tsbi->s_sys_blocksize - OMFS_DIR_START);\n\t} else\n\t\tomfs_make_empty_table(bh, OMFS_EXTENT_START);\n\n\toi = (struct omfs_inode *) bh->b_data;\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\toi->i_sibling = ~cpu_to_be64(0ULL);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\treturn 0;\n}\n\nstatic int omfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 block;\n\t__be64 *entry;\n\tint ofs;\n\n\t \n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\t*entry = cpu_to_be64(inode->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\t \n\tbh = omfs_bread(dir->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\tmemcpy(oi->i_name, name, namelen);\n\tmemset(oi->i_name + namelen, 0, OMFS_NAMELEN - namelen);\n\toi->i_sibling = cpu_to_be64(block);\n\toi->i_parent = cpu_to_be64(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinode_set_ctime_current(dir);\n\n\t \n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\n\nstatic int omfs_delete_entry(struct dentry *dentry)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct inode *dirty;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh, *bh2;\n\t__be64 *entry, next;\n\tu64 block, prev;\n\tint ofs;\n\tint err = -ENOMEM;\n\n\t \n\tbh = omfs_get_bucket(dir, name, namelen, &ofs);\n\tif (!bh)\n\t\tgoto out;\n\n\tentry = (__be64 *) &bh->b_data[ofs];\n\tblock = be64_to_cpu(*entry);\n\n\tbh2 = omfs_scan_list(dir, block, name, namelen, &prev);\n\tif (IS_ERR(bh2)) {\n\t\terr = PTR_ERR(bh2);\n\t\tgoto out_free_bh;\n\t}\n\n\toi = (struct omfs_inode *) bh2->b_data;\n\tnext = oi->i_sibling;\n\tbrelse(bh2);\n\n\tif (prev != ~0) {\n\t\t \n\t\tbrelse(bh);\n\t\tbh = omfs_bread(dir->i_sb, prev);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tentry = &oi->i_sibling;\n\t}\n\n\t*entry = next;\n\tmark_buffer_dirty(bh);\n\n\tif (prev != ~0) {\n\t\tdirty = omfs_iget(dir->i_sb, prev);\n\t\tif (!IS_ERR(dirty)) {\n\t\t\tmark_inode_dirty(dirty);\n\t\t\tiput(dirty);\n\t\t}\n\t}\n\n\terr = 0;\nout_free_bh:\n\tbrelse(bh);\nout:\n\treturn err;\n}\n\nstatic int omfs_dir_is_empty(struct inode *inode)\n{\n\tint nbuckets = (inode->i_size - OMFS_DIR_START) / 8;\n\tstruct buffer_head *bh;\n\tu64 *ptr;\n\tint i;\n\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\n\tif (!bh)\n\t\treturn 0;\n\n\tptr = (u64 *) &bh->b_data[OMFS_DIR_START];\n\n\tfor (i = 0; i < nbuckets; i++, ptr++)\n\t\tif (*ptr != ~0)\n\t\t\tbreak;\n\n\tbrelse(bh);\n\treturn *ptr != ~0;\n}\n\nstatic int omfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint ret;\n\n\n\tif (S_ISDIR(inode->i_mode) &&\n\t    !omfs_dir_is_empty(inode))\n\t\treturn -ENOTEMPTY;\n\n\tret = omfs_delete_entry(dentry);\n\tif (ret)\n\t\treturn ret;\n\t\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tmark_inode_dirty(dir);\n\treturn 0;\n}\n\nstatic int omfs_add_node(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint err;\n\tstruct inode *inode = omfs_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\terr = omfs_make_empty(inode, dir->i_sb);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\terr = omfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_free_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\nout_free_inode:\n\tiput(inode);\n\treturn err;\n}\n\nstatic int omfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFDIR);\n}\n\nstatic int omfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn omfs_add_node(dir, dentry, mode | S_IFREG);\n}\n\nstatic struct dentry *omfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\n\tif (dentry->d_name.len > OMFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = omfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (!IS_ERR(bh)) {\n\t\tstruct omfs_inode *oi = (struct omfs_inode *)bh->b_data;\n\t\tino_t ino = be64_to_cpu(oi->i_head.h_self);\n\t\tbrelse(bh);\n\t\tinode = omfs_iget(dir->i_sb, ino);\n\t} else if (bh != ERR_PTR(-ENOENT)) {\n\t\tinode = ERR_CAST(bh);\n\t}\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nint omfs_is_bad(struct omfs_sb_info *sbi, struct omfs_header *header,\n\tu64 fsblock)\n{\n\tint is_bad;\n\tu64 ino = be64_to_cpu(header->h_self);\n\tis_bad = ((ino != fsblock) || (ino < sbi->s_root_ino) ||\n\t\t(ino > sbi->s_num_blocks));\n\n\tif (is_bad)\n\t\tprintk(KERN_WARNING \"omfs: bad hash chain detected\\n\");\n\n\treturn is_bad;\n}\n\nstatic bool omfs_fill_chain(struct inode *dir, struct dir_context *ctx,\n\t\tu64 fsblock, int hindex)\n{\n\t \n\twhile (fsblock != ~0) {\n\t\tstruct buffer_head *bh = omfs_bread(dir->i_sb, fsblock);\n\t\tstruct omfs_inode *oi;\n\t\tu64 self;\n\t\tunsigned char d_type;\n\n\t\tif (!bh)\n\t\t\treturn true;\n\n\t\toi = (struct omfs_inode *) bh->b_data;\n\t\tif (omfs_is_bad(OMFS_SB(dir->i_sb), &oi->i_head, fsblock)) {\n\t\t\tbrelse(bh);\n\t\t\treturn true;\n\t\t}\n\n\t\tself = fsblock;\n\t\tfsblock = be64_to_cpu(oi->i_sibling);\n\n\t\t \n\t\tif (hindex) {\n\t\t\thindex--;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = (oi->i_type == OMFS_DIR) ? DT_DIR : DT_REG;\n\n\t\tif (!dir_emit(ctx, oi->i_name,\n\t\t\t      strnlen(oi->i_name, OMFS_NAMELEN),\n\t\t\t      self, d_type)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\tbrelse(bh);\n\t\tctx->pos++;\n\t}\n\treturn true;\n}\n\nstatic int omfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tint err;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tif (new_inode) {\n\t\t \n\t\terr = omfs_remove(new_dir, new_dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = omfs_delete_entry(old_dentry);\n\tif (err)\n\t\tgoto out;\n\n\tmark_inode_dirty(old_dir);\n\terr = omfs_add_link(new_dentry, old_inode);\n\tif (err)\n\t\tgoto out;\n\n\tinode_set_ctime_current(old_inode);\n\tmark_inode_dirty(old_inode);\nout:\n\treturn err;\n}\n\nstatic int omfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct buffer_head *bh;\n\t__be64 *p;\n\tunsigned int hchain, hindex;\n\tint nbuckets;\n\n\tif (ctx->pos >> 32)\n\t\treturn -EINVAL;\n\n\tif (ctx->pos < 1 << 20) {\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1 << 20;\n\t}\n\n\tnbuckets = (dir->i_size - OMFS_DIR_START) / 8;\n\n\t \n\thchain = (ctx->pos >> 20) - 1;\n\thindex = ctx->pos & 0xfffff;\n\n\tbh = omfs_bread(dir->i_sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EINVAL;\n\n\tp = (__be64 *)(bh->b_data + OMFS_DIR_START) + hchain;\n\n\tfor (; hchain < nbuckets; hchain++) {\n\t\t__u64 fsblock = be64_to_cpu(*p++);\n\t\tif (!omfs_fill_chain(dir, ctx, fsblock, hindex))\n\t\t\tbreak;\n\t\thindex = 0;\n\t\tctx->pos = (hchain+2) << 20;\n\t}\n\tbrelse(bh);\n\treturn 0;\n}\n\nconst struct inode_operations omfs_dir_inops = {\n\t.lookup = omfs_lookup,\n\t.mkdir = omfs_mkdir,\n\t.rename = omfs_rename,\n\t.create = omfs_create,\n\t.unlink = omfs_remove,\n\t.rmdir = omfs_remove,\n};\n\nconst struct file_operations omfs_dir_operations = {\n\t.read = generic_read_dir,\n\t.iterate_shared = omfs_readdir,\n\t.llseek = generic_file_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}