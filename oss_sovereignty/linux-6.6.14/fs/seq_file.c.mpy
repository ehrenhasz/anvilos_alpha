{
  "module_name": "seq_file.c",
  "hash_id": "eb43ff3553cf651ac539db65356beef130cde93e6f3320b1f1a2d5f9295170fc",
  "original_prompt": "Ingested from linux-6.6.14/fs/seq_file.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cache.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n#include <linux/string_helpers.h>\n#include <linux/uio.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n\nstatic struct kmem_cache *seq_file_cache __ro_after_init;\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}\n\n \nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p;\n\n\tWARN_ON(file->private_data);\n\n\tp = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = p;\n\n\tmutex_init(&p->lock);\n\tp->op = op;\n\n\t\n\t\n\tp->file = file;\n\n\t \n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_open);\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0;\n\tint error = 0;\n\tvoid *p;\n\n\tm->index = 0;\n\tm->count = m->from = 0;\n\tif (!offset)\n\t\treturn 0;\n\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &m->index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset)\n\t\t\tbreak;\n\t}\n\tm->op->stop(m, p);\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}\n\n \nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = size};\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tiov_iter_init(&iter, ITER_DEST, &iov, 1, size);\n\n\tkiocb.ki_pos = *ppos;\n\tret = seq_read_iter(&kiocb, &iter);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\nEXPORT_SYMBOL(seq_read);\n\n \nssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct seq_file *m = iocb->ki_filp->private_data;\n\tsize_t copied = 0;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tmutex_lock(&m->lock);\n\n\t \n\tif (iocb->ki_pos == 0) {\n\t\tm->index = 0;\n\t\tm->count = 0;\n\t}\n\n\t \n\tif (unlikely(iocb->ki_pos != m->read_pos)) {\n\t\twhile ((err = traverse(m, iocb->ki_pos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t \n\t\t\tm->read_pos = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = iocb->ki_pos;\n\t\t}\n\t}\n\n\t \n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t\n\tif (m->count) {\n\t\tn = copy_to_iter(m->buf + m->from, m->count, iter);\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tcopied += n;\n\t\tif (m->count)\t\n\t\t\tgoto Done;\n\t}\n\t\n\tm->from = 0;\n\tp = m->op->start(m, &m->index);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\t\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\t\t\n\t\t\tbreak;\n\t\tif (unlikely(err))\t\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) { \n\t\t\tp = m->op->next(m, p, &m->index);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!seq_has_overflowed(m)) \n\t\t\tgoto Fill;\n\t\t\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tp = m->op->start(m, &m->index);\n\t}\n\t\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t\n\t\n\t\n\twhile (1) {\n\t\tsize_t offs = m->count;\n\t\tloff_t pos = m->index;\n\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos == m->index) {\n\t\t\tpr_info_ratelimited(\"buggy .next function %ps did not update position index\\n\",\n\t\t\t\t\t    m->op->next);\n\t\t\tm->index++;\n\t\t}\n\t\tif (!p || IS_ERR(p))\t\n\t\t\tbreak;\n\t\tif (m->count >= iov_iter_count(iter))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err > 0) {\t\t\n\t\t\tm->count = offs;\n\t\t} else if (err || seq_has_overflowed(m)) {\n\t\t\tm->count = offs;\n\t\t\tbreak;\n\t\t}\n\t}\n\tm->op->stop(m, p);\n\tn = copy_to_iter(m->buf, m->count, iter);\n\tcopied += n;\n\tm->count -= n;\n\tm->from = n;\nDone:\n\tif (unlikely(!copied)) {\n\t\tcopied = m->count ? -EFAULT : err;\n\t} else {\n\t\tiocb->ki_pos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\n}\nEXPORT_SYMBOL(seq_read_iter);\n\n \nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tfallthrough;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t \n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(seq_lseek);\n\n \nint seq_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tkvfree(m->buf);\n\tkmem_cache_free(seq_file_cache, m);\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_release);\n\n \nvoid seq_escape_mem(struct seq_file *m, const char *src, size_t len,\n\t\t    unsigned int flags, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint ret;\n\n\tret = string_escape_mem(src, len, buf, size, flags, esc);\n\tseq_commit(m, ret < size ? ret : -1);\n}\nEXPORT_SYMBOL(seq_escape_mem);\n\nvoid seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_vprintf);\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL(seq_printf);\n\n#ifdef CONFIG_BINARY_PRINTF\nvoid seq_bprintf(struct seq_file *m, const char *f, const u32 *binary)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = bstr_printf(m->buf + m->count, m->size - m->count, f,\n\t\t\t\t  binary);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_bprintf);\n#endif  \n\n \nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(mangle_path);\n\n \nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_path);\n\n \nint seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}\nEXPORT_SYMBOL(seq_file_path);\n\n \nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}\n\n \nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_dentry);\n\nvoid *single_start(struct seq_file *p, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}\n\nstatic void *single_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn NULL;\n}\n\nstatic void single_stop(struct seq_file *p, void *v)\n{\n}\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(single_open);\n\nint single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data, size_t size)\n{\n\tchar *buf = seq_buf_alloc(size);\n\tint ret;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = single_open(file, show, data);\n\tif (ret) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\t((struct seq_file *)file->private_data)->buf = buf;\n\t((struct seq_file *)file->private_data)->size = size;\n\treturn 0;\n}\nEXPORT_SYMBOL(single_open_size);\n\nint single_release(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\n\tint res = seq_release(inode, file);\n\tkfree(op);\n\treturn res;\n}\nEXPORT_SYMBOL(single_release);\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}\nEXPORT_SYMBOL(seq_release_private);\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL_ACCOUNT);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL(__seq_open_private);\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL(seq_open_private);\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}\nEXPORT_SYMBOL(seq_putc);\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}\nEXPORT_SYMBOL(seq_puts);\n\n \nvoid seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num, unsigned int width)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size)  \n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (!width)\n\t\twidth = 1;\n\n\tif (m->count + width >= m->size)\n\t\tgoto overflow;\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, width);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\n\nvoid seq_put_decimal_ull(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num)\n{\n\treturn seq_put_decimal_ull_width(m, delimiter, num, 0);\n}\nEXPORT_SYMBOL(seq_put_decimal_ull);\n\n \nvoid seq_put_hex_ll(struct seq_file *m, const char *delimiter,\n\t\t\t\tunsigned long long v, unsigned int width)\n{\n\tunsigned int len;\n\tint i;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\t \n\tif (v == 0)\n\t\tlen = 1;\n\telse\n\t\tlen = (sizeof(v) * 8 - __builtin_clzll(v) + 3) / 4;\n\n\tif (len < width)\n\t\tlen = width;\n\n\tif (m->count + len > m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tm->buf[m->count + i] = hex_asc[0xf & v];\n\t\tv = v >> 4;\n\t}\n\tm->count += len;\n}\n\nvoid seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)\n{\n\tint len;\n\n\tif (m->count + 3 >= m->size)  \n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (m->count + 2 >= m->size)\n\t\tgoto overflow;\n\n\tif (num < 0) {\n\t\tm->buf[m->count++] = '-';\n\t\tnum = -num;\n\t}\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, 0);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_put_decimal_ll);\n\n \nint seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}\nEXPORT_SYMBOL(seq_write);\n\n \nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0) {\n\t\tif (size + m->count > m->size) {\n\t\t\tseq_set_overflow(m);\n\t\t\treturn;\n\t\t}\n\t\tmemset(m->buf + m->count, ' ', size);\n\t\tm->count += size;\n\t}\n\tif (c)\n\t\tseq_putc(m, c);\n}\nEXPORT_SYMBOL(seq_pad);\n\n \nvoid seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, const void *buf, size_t len,\n\t\t  bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tchar *buffer;\n\tsize_t size;\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len && !seq_has_overflowed(m); i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tseq_printf(m, \"%s%p: \", prefix_str, ptr + i);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tseq_printf(m, \"%s%.8x: \", prefix_str, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"%s\", prefix_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tsize = seq_get_buf(m, &buffer);\n\t\tret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t\t buffer, size, ascii);\n\t\tseq_commit(m, ret < size ? ret : -1);\n\n\t\tseq_putc(m, '\\n');\n\t}\n}\nEXPORT_SYMBOL(seq_hex_dump);\n\nstruct list_head *seq_list_start(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_list_start);\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_list_start_head);\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}\nEXPORT_SYMBOL(seq_list_next);\n\nstruct list_head *seq_list_start_rcu(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each_rcu(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_list_start_rcu);\n\nstruct list_head *seq_list_start_head_rcu(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start_rcu(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_list_start_head_rcu);\n\nstruct list_head *seq_list_next_rcu(void *v, struct list_head *head,\n\t\t\t\t    loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = list_next_rcu((struct list_head *)v);\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}\nEXPORT_SYMBOL(seq_list_next_rcu);\n\n \nstruct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\thlist_for_each(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start);\n\n \nstruct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head);\n\n \nstruct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn head->first;\n\telse\n\t\treturn node->next;\n}\nEXPORT_SYMBOL(seq_hlist_next);\n\n \nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_rcu);\n\n \nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head_rcu);\n\n \nstruct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t      struct hlist_head *head,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn rcu_dereference(head->first);\n\telse\n\t\treturn rcu_dereference(node->next);\n}\nEXPORT_SYMBOL(seq_hlist_next_rcu);\n\n \nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_percpu);\n\n \nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_next_percpu);\n\nvoid __init seq_file_init(void)\n{\n\tseq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}