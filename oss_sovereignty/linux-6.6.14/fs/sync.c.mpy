{
  "module_name": "sync.c",
  "hash_id": "36ed161faabbecdcfe894d5c7ff0ef7e5d14b4f7f388258f42fbecb1f59e8351",
  "original_prompt": "Ingested from linux-6.6.14/fs/sync.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/writeback.h>\n#include <linux/syscalls.h>\n#include <linux/linkage.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/backing-dev.h>\n#include \"internal.h\"\n\n#define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \\\n\t\t\tSYNC_FILE_RANGE_WAIT_AFTER)\n\n \nint sync_filesystem(struct super_block *sb)\n{\n\tint ret = 0;\n\n\t \n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t \n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\t \n\twriteback_inodes_sb(sb, WB_REASON_SYNC);\n\tif (sb->s_op->sync_fs) {\n\t\tret = sb->s_op->sync_fs(sb, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = sync_blockdev_nowait(sb->s_bdev);\n\tif (ret)\n\t\treturn ret;\n\n\tsync_inodes_sb(sb);\n\tif (sb->s_op->sync_fs) {\n\t\tret = sb->s_op->sync_fs(sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn sync_blockdev(sb->s_bdev);\n}\nEXPORT_SYMBOL(sync_filesystem);\n\nstatic void sync_inodes_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb))\n\t\tsync_inodes_sb(sb);\n}\n\nstatic void sync_fs_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb) && !(sb->s_iflags & SB_I_SKIP_SYNC) &&\n\t    sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, *(int *)arg);\n}\n\n \nvoid ksys_sync(void)\n{\n\tint nowait = 0, wait = 1;\n\n\twakeup_flusher_threads(WB_REASON_SYNC);\n\titerate_supers(sync_inodes_one_sb, NULL);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &wait);\n\tsync_bdevs(false);\n\tsync_bdevs(true);\n\tif (unlikely(laptop_mode))\n\t\tlaptop_sync_completion();\n}\n\nSYSCALL_DEFINE0(sync)\n{\n\tksys_sync();\n\treturn 0;\n}\n\nstatic void do_sync_work(struct work_struct *work)\n{\n\tint nowait = 0;\n\n\t \n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\tsync_bdevs(false);\n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\tsync_bdevs(false);\n\tprintk(\"Emergency Sync complete\\n\");\n\tkfree(work);\n}\n\nvoid emergency_sync(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_sync_work);\n\t\tschedule_work(work);\n\t}\n}\n\n \nSYSCALL_DEFINE1(syncfs, int, fd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct super_block *sb;\n\tint ret, ret2;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tsb = f.file->f_path.dentry->d_sb;\n\n\tdown_read(&sb->s_umount);\n\tret = sync_filesystem(sb);\n\tup_read(&sb->s_umount);\n\n\tret2 = errseq_check_and_advance(&sb->s_wb_err, &f.file->f_sb_err);\n\n\tfdput(f);\n\treturn ret ? ret : ret2;\n}\n\n \nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}\nEXPORT_SYMBOL(vfs_fsync_range);\n\n \nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}\nEXPORT_SYMBOL(vfs_fsync);\n\nstatic int do_fsync(unsigned int fd, int datasync)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (f.file) {\n\t\tret = vfs_fsync(f.file, datasync);\n\t\tfdput(f);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(fsync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 0);\n}\n\nSYSCALL_DEFINE1(fdatasync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 1);\n}\n\nint sync_file_range(struct file *file, loff_t offset, loff_t nbytes,\n\t\t    unsigned int flags)\n{\n\tint ret;\n\tstruct address_space *mapping;\n\tloff_t endbyte;\t\t\t \n\tumode_t i_mode;\n\n\tret = -EINVAL;\n\tif (flags & ~VALID_FLAGS)\n\t\tgoto out;\n\n\tendbyte = offset + nbytes;\n\n\tif ((s64)offset < 0)\n\t\tgoto out;\n\tif ((s64)endbyte < 0)\n\t\tgoto out;\n\tif (endbyte < offset)\n\t\tgoto out;\n\n\tif (sizeof(pgoff_t) == 4) {\n\t\tif (offset >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (endbyte >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t \n\t\t\tnbytes = 0;\n\t\t}\n\t}\n\n\tif (nbytes == 0)\n\t\tendbyte = LLONG_MAX;\n\telse\n\t\tendbyte--;\t\t \n\n\ti_mode = file_inode(file)->i_mode;\n\tret = -ESPIPE;\n\tif (!S_ISREG(i_mode) && !S_ISBLK(i_mode) && !S_ISDIR(i_mode) &&\n\t\t\t!S_ISLNK(i_mode))\n\t\tgoto out;\n\n\tmapping = file->f_mapping;\n\tret = 0;\n\tif (flags & SYNC_FILE_RANGE_WAIT_BEFORE) {\n\t\tret = file_fdatawait_range(file, offset, endbyte);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WRITE) {\n\t\tint sync_mode = WB_SYNC_NONE;\n\n\t\tif ((flags & SYNC_FILE_RANGE_WRITE_AND_WAIT) ==\n\t\t\t     SYNC_FILE_RANGE_WRITE_AND_WAIT)\n\t\t\tsync_mode = WB_SYNC_ALL;\n\n\t\tret = __filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t sync_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WAIT_AFTER)\n\t\tret = file_fdatawait_range(file, offset, endbyte);\n\nout:\n\treturn ret;\n}\n\n \nint ksys_sync_file_range(int fd, loff_t offset, loff_t nbytes,\n\t\t\t unsigned int flags)\n{\n\tint ret;\n\tstruct fd f;\n\n\tret = -EBADF;\n\tf = fdget(fd);\n\tif (f.file)\n\t\tret = sync_file_range(f.file, offset, nbytes, flags);\n\n\tfdput(f);\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(sync_file_range, int, fd, loff_t, offset, loff_t, nbytes,\n\t\t\t\tunsigned int, flags)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}\n\n#if defined(CONFIG_COMPAT) && defined(__ARCH_WANT_COMPAT_SYNC_FILE_RANGE)\nCOMPAT_SYSCALL_DEFINE6(sync_file_range, int, fd, compat_arg_u64_dual(offset),\n\t\t       compat_arg_u64_dual(nbytes), unsigned int, flags)\n{\n\treturn ksys_sync_file_range(fd, compat_arg_u64_glue(offset),\n\t\t\t\t    compat_arg_u64_glue(nbytes), flags);\n}\n#endif\n\n \nSYSCALL_DEFINE4(sync_file_range2, int, fd, unsigned int, flags,\n\t\t\t\t loff_t, offset, loff_t, nbytes)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}