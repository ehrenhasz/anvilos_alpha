{
  "module_name": "generic.c",
  "hash_id": "6c54c0d457b27fe0a9dab911ef2bbc2118debf948b12647542169d07ce325ce0",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/generic.c",
  "human_readable_source": "\n \n\n#include <linux/cache.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\n#include \"internal.h\"\n\nstatic DEFINE_RWLOCK(proc_subdir_lock);\n\nstruct kmem_cache *proc_dir_entry_cache __ro_after_init;\n\nvoid pde_free(struct proc_dir_entry *pde)\n{\n\tif (S_ISLNK(pde->mode))\n\t\tkfree(pde->data);\n\tif (pde->name != pde->inline_name)\n\t\tkfree(pde->name);\n\tkmem_cache_free(proc_dir_entry_cache, pde);\n}\n\nstatic int proc_match(const char *name, struct proc_dir_entry *de, unsigned int len)\n{\n\tif (len < de->namelen)\n\t\treturn -1;\n\tif (len > de->namelen)\n\t\treturn 1;\n\n\treturn memcmp(name, de->name, len);\n}\n\nstatic struct proc_dir_entry *pde_subdir_first(struct proc_dir_entry *dir)\n{\n\treturn rb_entry_safe(rb_first(&dir->subdir), struct proc_dir_entry,\n\t\t\t     subdir_node);\n}\n\nstatic struct proc_dir_entry *pde_subdir_next(struct proc_dir_entry *dir)\n{\n\treturn rb_entry_safe(rb_next(&dir->subdir_node), struct proc_dir_entry,\n\t\t\t     subdir_node);\n}\n\nstatic struct proc_dir_entry *pde_subdir_find(struct proc_dir_entry *dir,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      unsigned int len)\n{\n\tstruct rb_node *node = dir->subdir.rb_node;\n\n\twhile (node) {\n\t\tstruct proc_dir_entry *de = rb_entry(node,\n\t\t\t\t\t\t     struct proc_dir_entry,\n\t\t\t\t\t\t     subdir_node);\n\t\tint result = proc_match(name, de, len);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn de;\n\t}\n\treturn NULL;\n}\n\nstatic bool pde_subdir_insert(struct proc_dir_entry *dir,\n\t\t\t      struct proc_dir_entry *de)\n{\n\tstruct rb_root *root = &dir->subdir;\n\tstruct rb_node **new = &root->rb_node, *parent = NULL;\n\n\t \n\twhile (*new) {\n\t\tstruct proc_dir_entry *this = rb_entry(*new,\n\t\t\t\t\t\t       struct proc_dir_entry,\n\t\t\t\t\t\t       subdir_node);\n\t\tint result = proc_match(de->name, this, de->namelen);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &(*new)->rb_left;\n\t\telse if (result > 0)\n\t\t\tnew = &(*new)->rb_right;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t \n\trb_link_node(&de->subdir_node, parent, new);\n\trb_insert_color(&de->subdir_node, root);\n\treturn true;\n}\n\nstatic int proc_notify_change(struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct proc_dir_entry *de = PDE(inode);\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\n\tproc_set_user(de, inode->i_uid, inode->i_gid);\n\tde->mode = inode->i_mode;\n\treturn 0;\n}\n\nstatic int proc_getattr(struct mnt_idmap *idmap,\n\t\t\tconst struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct proc_dir_entry *de = PDE(inode);\n\tif (de) {\n\t\tnlink_t nlink = READ_ONCE(de->nlink);\n\t\tif (nlink > 0) {\n\t\t\tset_nlink(inode, nlink);\n\t\t}\n\t}\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\n \nstatic int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,\n\t\t\t     const char **residual)\n{\n\tconst char     \t\t*cp = name, *next;\n\tstruct proc_dir_entry\t*de;\n\n\tde = *ret ?: &proc_root;\n\twhile ((next = strchr(cp, '/')) != NULL) {\n\t\tde = pde_subdir_find(de, cp, next - cp);\n\t\tif (!de) {\n\t\t\tWARN(1, \"name '%s'\\n\", name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tcp = next + 1;\n\t}\n\t*residual = cp;\n\t*ret = de;\n\treturn 0;\n}\n\nstatic int xlate_proc_name(const char *name, struct proc_dir_entry **ret,\n\t\t\t   const char **residual)\n{\n\tint rv;\n\n\tread_lock(&proc_subdir_lock);\n\trv = __xlate_proc_name(name, ret, residual);\n\tread_unlock(&proc_subdir_lock);\n\treturn rv;\n}\n\nstatic DEFINE_IDA(proc_inum_ida);\n\n#define PROC_DYNAMIC_FIRST 0xF0000000U\n\n \nint proc_alloc_inum(unsigned int *inum)\n{\n\tint i;\n\n\ti = ida_simple_get(&proc_inum_ida, 0, UINT_MAX - PROC_DYNAMIC_FIRST + 1,\n\t\t\t   GFP_KERNEL);\n\tif (i < 0)\n\t\treturn i;\n\n\t*inum = PROC_DYNAMIC_FIRST + (unsigned int)i;\n\treturn 0;\n}\n\nvoid proc_free_inum(unsigned int inum)\n{\n\tida_simple_remove(&proc_inum_ida, inum - PROC_DYNAMIC_FIRST);\n}\n\nstatic int proc_misc_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (atomic_read(&PDE(d_inode(dentry))->in_use) < 0)\n\t\treturn 0;  \n\treturn 1;\n}\n\nstatic int proc_misc_d_delete(const struct dentry *dentry)\n{\n\treturn atomic_read(&PDE(d_inode(dentry))->in_use) < 0;\n}\n\nstatic const struct dentry_operations proc_misc_dentry_ops = {\n\t.d_revalidate\t= proc_misc_d_revalidate,\n\t.d_delete\t= proc_misc_d_delete,\n};\n\n \nstruct dentry *proc_lookup_de(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct proc_dir_entry *de)\n{\n\tstruct inode *inode;\n\n\tread_lock(&proc_subdir_lock);\n\tde = pde_subdir_find(de, dentry->d_name.name, dentry->d_name.len);\n\tif (de) {\n\t\tpde_get(de);\n\t\tread_unlock(&proc_subdir_lock);\n\t\tinode = proc_get_inode(dir->i_sb, de);\n\t\tif (!inode)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\td_set_d_op(dentry, de->proc_dops);\n\t\treturn d_splice_alias(inode, dentry);\n\t}\n\tread_unlock(&proc_subdir_lock);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstruct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct proc_fs_info *fs_info = proc_sb_info(dir->i_sb);\n\n\tif (fs_info->pidonly == PROC_PIDONLY_ON)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn proc_lookup_de(dir, dentry, PDE(dir));\n}\n\n \nint proc_readdir_de(struct file *file, struct dir_context *ctx,\n\t\t    struct proc_dir_entry *de)\n{\n\tint i;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\ti = ctx->pos - 2;\n\tread_lock(&proc_subdir_lock);\n\tde = pde_subdir_first(de);\n\tfor (;;) {\n\t\tif (!de) {\n\t\t\tread_unlock(&proc_subdir_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!i)\n\t\t\tbreak;\n\t\tde = pde_subdir_next(de);\n\t\ti--;\n\t}\n\n\tdo {\n\t\tstruct proc_dir_entry *next;\n\t\tpde_get(de);\n\t\tread_unlock(&proc_subdir_lock);\n\t\tif (!dir_emit(ctx, de->name, de->namelen,\n\t\t\t    de->low_ino, de->mode >> 12)) {\n\t\t\tpde_put(de);\n\t\t\treturn 0;\n\t\t}\n\t\tctx->pos++;\n\t\tread_lock(&proc_subdir_lock);\n\t\tnext = pde_subdir_next(de);\n\t\tpde_put(de);\n\t\tde = next;\n\t} while (de);\n\tread_unlock(&proc_subdir_lock);\n\treturn 1;\n}\n\nint proc_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct proc_fs_info *fs_info = proc_sb_info(inode->i_sb);\n\n\tif (fs_info->pidonly == PROC_PIDONLY_ON)\n\t\treturn 1;\n\n\treturn proc_readdir_de(file, ctx, PDE(inode));\n}\n\n \nstatic const struct file_operations proc_dir_operations = {\n\t.llseek\t\t\t= generic_file_llseek,\n\t.read\t\t\t= generic_read_dir,\n\t.iterate_shared\t\t= proc_readdir,\n};\n\nstatic int proc_net_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn 0;\n}\n\nconst struct dentry_operations proc_net_dentry_ops = {\n\t.d_revalidate\t= proc_net_d_revalidate,\n\t.d_delete\t= always_delete_dentry,\n};\n\n \nstatic const struct inode_operations proc_dir_inode_operations = {\n\t.lookup\t\t= proc_lookup,\n\t.getattr\t= proc_getattr,\n\t.setattr\t= proc_notify_change,\n};\n\n \nstruct proc_dir_entry *proc_register(struct proc_dir_entry *dir,\n\t\tstruct proc_dir_entry *dp)\n{\n\tif (proc_alloc_inum(&dp->low_ino))\n\t\tgoto out_free_entry;\n\n\twrite_lock(&proc_subdir_lock);\n\tdp->parent = dir;\n\tif (pde_subdir_insert(dir, dp) == false) {\n\t\tWARN(1, \"proc_dir_entry '%s/%s' already registered\\n\",\n\t\t     dir->name, dp->name);\n\t\twrite_unlock(&proc_subdir_lock);\n\t\tgoto out_free_inum;\n\t}\n\tdir->nlink++;\n\twrite_unlock(&proc_subdir_lock);\n\n\treturn dp;\nout_free_inum:\n\tproc_free_inum(dp->low_ino);\nout_free_entry:\n\tpde_free(dp);\n\treturn NULL;\n}\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (qstr.len == 1 && fn[0] == '.') {\n\t\tWARN(1, \"name '.'\\n\");\n\t\treturn NULL;\n\t}\n\tif (qstr.len == 2 && fn[0] == '.' && fn[1] == '.') {\n\t\tWARN(1, \"name '..'\\n\");\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\tif (is_empty_pde(*parent)) {\n\t\tWARN(1, \"attempt to add to permanently empty directory\");\n\t\treturn NULL;\n\t}\n\n\tent = kmem_cache_zalloc(proc_dir_entry_cache, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tif (qstr.len + 1 <= SIZEOF_PDE_INLINE_NAME) {\n\t\tent->name = ent->inline_name;\n\t} else {\n\t\tent->name = kmalloc(qstr.len + 1, GFP_KERNEL);\n\t\tif (!ent->name) {\n\t\t\tpde_free(ent);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\trefcount_set(&ent->refcnt, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\n\tproc_set_user(ent, (*parent)->uid, (*parent)->gid);\n\n\tent->proc_dops = &proc_misc_dentry_ops;\n\t \n\tif ((*parent)->proc_dops == &proc_net_dentry_ops)\n\t\tpde_force_lookup(ent);\n\nout:\n\treturn ent;\n}\n\nstruct proc_dir_entry *proc_symlink(const char *name,\n\t\tstruct proc_dir_entry *parent, const char *dest)\n{\n\tstruct proc_dir_entry *ent;\n\n\tent = __proc_create(&parent, name,\n\t\t\t  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);\n\n\tif (ent) {\n\t\tent->data = kmalloc((ent->size=strlen(dest))+1, GFP_KERNEL);\n\t\tif (ent->data) {\n\t\t\tstrcpy((char*)ent->data,dest);\n\t\t\tent->proc_iops = &proc_link_inode_operations;\n\t\t\tent = proc_register(parent, ent);\n\t\t} else {\n\t\t\tpde_free(ent);\n\t\t\tent = NULL;\n\t\t}\n\t}\n\treturn ent;\n}\nEXPORT_SYMBOL(proc_symlink);\n\nstruct proc_dir_entry *_proc_mkdir(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, void *data, bool force_lookup)\n{\n\tstruct proc_dir_entry *ent;\n\n\tif (mode == 0)\n\t\tmode = S_IRUGO | S_IXUGO;\n\n\tent = __proc_create(&parent, name, S_IFDIR | mode, 2);\n\tif (ent) {\n\t\tent->data = data;\n\t\tent->proc_dir_ops = &proc_dir_operations;\n\t\tent->proc_iops = &proc_dir_inode_operations;\n\t\tif (force_lookup) {\n\t\t\tpde_force_lookup(ent);\n\t\t}\n\t\tent = proc_register(parent, ent);\n\t}\n\treturn ent;\n}\nEXPORT_SYMBOL_GPL(_proc_mkdir);\n\nstruct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, void *data)\n{\n\treturn _proc_mkdir(name, mode, parent, data, false);\n}\nEXPORT_SYMBOL_GPL(proc_mkdir_data);\n\nstruct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,\n\t\t\t\t       struct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, mode, parent, NULL);\n}\nEXPORT_SYMBOL(proc_mkdir_mode);\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}\nEXPORT_SYMBOL(proc_mkdir);\n\nstruct proc_dir_entry *proc_create_mount_point(const char *name)\n{\n\tumode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tstruct proc_dir_entry *ent, *parent = NULL;\n\n\tent = __proc_create(&parent, name, mode, 2);\n\tif (ent) {\n\t\tent->data = NULL;\n\t\tent->proc_dir_ops = NULL;\n\t\tent->proc_iops = NULL;\n\t\tent = proc_register(parent, ent);\n\t}\n\treturn ent;\n}\nEXPORT_SYMBOL(proc_create_mount_point);\n\nstruct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry **parent, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tif (WARN_ON_ONCE(!S_ISREG(mode)))\n\t\treturn NULL;\n\n\tp = __proc_create(parent, name, mode, 1);\n\tif (p) {\n\t\tp->proc_iops = &proc_file_inode_operations;\n\t\tp->data = data;\n\t}\n\treturn p;\n}\n\nstatic inline void pde_set_flags(struct proc_dir_entry *pde)\n{\n\tif (pde->proc_ops->proc_flags & PROC_ENTRY_PERMANENT)\n\t\tpde->flags |= PROC_ENTRY_PERMANENT;\n}\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent,\n\t\tconst struct proc_ops *proc_ops, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tp->proc_ops = proc_ops;\n\tpde_set_flags(p);\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL(proc_create_data);\n \nstruct proc_dir_entry *proc_create(const char *name, umode_t mode,\n\t\t\t\t   struct proc_dir_entry *parent,\n\t\t\t\t   const struct proc_ops *proc_ops)\n{\n\treturn proc_create_data(name, mode, parent, proc_ops, NULL);\n}\nEXPORT_SYMBOL(proc_create);\n\nstatic int proc_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\n\tif (de->state_size)\n\t\treturn seq_open_private(file, de->seq_ops, de->state_size);\n\treturn seq_open(file, de->seq_ops);\n}\n\nstatic int proc_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\n\tif (de->state_size)\n\t\treturn seq_release_private(inode, file);\n\treturn seq_release(inode, file);\n}\n\nstatic const struct proc_ops proc_seq_ops = {\n\t \n\t.proc_open\t= proc_seq_open,\n\t.proc_read_iter\t= seq_read_iter,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= proc_seq_release,\n};\n\nstruct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, const struct seq_operations *ops,\n\t\tunsigned int state_size, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tp->proc_ops = &proc_seq_ops;\n\tp->seq_ops = ops;\n\tp->state_size = state_size;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL(proc_create_seq_private);\n\nstatic int proc_single_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\n\treturn single_open(file, de->single_show, de->data);\n}\n\nstatic const struct proc_ops proc_single_ops = {\n\t \n\t.proc_open\t= proc_single_open,\n\t.proc_read_iter = seq_read_iter,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstruct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent,\n\t\tint (*show)(struct seq_file *, void *), void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tp->proc_ops = &proc_single_ops;\n\tp->single_show = show;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL(proc_create_single_data);\n\nvoid proc_set_size(struct proc_dir_entry *de, loff_t size)\n{\n\tde->size = size;\n}\nEXPORT_SYMBOL(proc_set_size);\n\nvoid proc_set_user(struct proc_dir_entry *de, kuid_t uid, kgid_t gid)\n{\n\tde->uid = uid;\n\tde->gid = gid;\n}\nEXPORT_SYMBOL(proc_set_user);\n\nvoid pde_put(struct proc_dir_entry *pde)\n{\n\tif (refcount_dec_and_test(&pde->refcnt)) {\n\t\tproc_free_inum(pde->low_ino);\n\t\tpde_free(pde);\n\t}\n}\n\n \nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\twrite_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\twrite_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de) {\n\t\tif (unlikely(pde_is_permanent(de))) {\n\t\t\tWARN(1, \"removing permanent /proc entry '%s'\", de->name);\n\t\t\tde = NULL;\n\t\t} else {\n\t\t\trb_erase(&de->subdir_node, &parent->subdir);\n\t\t\tif (S_ISDIR(de->mode))\n\t\t\t\tparent->nlink--;\n\t\t}\n\t}\n\twrite_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}\nEXPORT_SYMBOL(remove_proc_entry);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\twrite_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\twrite_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\twrite_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tif (unlikely(pde_is_permanent(root))) {\n\t\twrite_unlock(&proc_subdir_lock);\n\t\tWARN(1, \"removing permanent /proc entry '%s/%s'\",\n\t\t\troot->parent->name, root->name);\n\t\treturn -EINVAL;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\tif (unlikely(pde_is_permanent(next))) {\n\t\t\t\twrite_unlock(&proc_subdir_lock);\n\t\t\t\tWARN(1, \"removing permanent /proc entry '%s/%s'\",\n\t\t\t\t\tnext->parent->name, next->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\twrite_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\twrite_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}\nEXPORT_SYMBOL(remove_proc_subtree);\n\nvoid *proc_get_parent_data(const struct inode *inode)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\treturn de->parent->data;\n}\nEXPORT_SYMBOL_GPL(proc_get_parent_data);\n\nvoid proc_remove(struct proc_dir_entry *de)\n{\n\tif (de)\n\t\tremove_proc_subtree(de->name, de->parent);\n}\nEXPORT_SYMBOL(proc_remove);\n\n \nssize_t proc_simple_write(struct file *f, const char __user *ubuf, size_t size,\n\t\t\t  loff_t *_pos)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(f));\n\tchar *buf;\n\tint ret;\n\n\tif (!pde->write)\n\t\treturn -EACCES;\n\tif (size == 0 || size > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\tbuf = memdup_user_nul(ubuf, size);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tret = pde->write(f, buf, size);\n\tkfree(buf);\n\treturn ret == 0 ? size : ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}