{
  "module_name": "proc_sysctl.c",
  "hash_id": "ff74e1bc7924e2598bae7c8e8c27da626e4f0ad4b8e82de12e7b7b95cab46e88",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/proc_sysctl.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/security.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/uio.h>\n#include <linux/module.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/mount.h>\n#include <linux/kmemleak.h>\n#include \"internal.h\"\n\n#define list_for_each_table_entry(entry, header)\t\\\n\tentry = header->ctl_table;\t\t\t\\\n\tfor (size_t i = 0 ; i < header->ctl_table_size && entry->procname; ++i, entry++)\n\nstatic const struct dentry_operations proc_sys_dentry_operations;\nstatic const struct file_operations proc_sys_file_operations;\nstatic const struct inode_operations proc_sys_inode_operations;\nstatic const struct file_operations proc_sys_dir_file_operations;\nstatic const struct inode_operations proc_sys_dir_operations;\n\n \nstatic struct ctl_table sysctl_mount_point[] = {\n\t{.type = SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY }\n};\n\n \nstruct ctl_table_header *register_sysctl_mount_point(const char *path)\n{\n\treturn register_sysctl_sz(path, sysctl_mount_point, 0);\n}\nEXPORT_SYMBOL(register_sysctl_mount_point);\n\n#define sysctl_is_perm_empty_ctl_table(tptr)\t\t\\\n\t(tptr[0].type == SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY)\n#define sysctl_is_perm_empty_ctl_header(hptr)\t\t\\\n\t(sysctl_is_perm_empty_ctl_table(hptr->ctl_table))\n#define sysctl_set_perm_empty_ctl_header(hptr)\t\t\\\n\t(hptr->ctl_table[0].type = SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY)\n#define sysctl_clear_perm_empty_ctl_header(hptr)\t\\\n\t(hptr->ctl_table[0].type = SYSCTL_TABLE_TYPE_DEFAULT)\n\nvoid proc_sys_poll_notify(struct ctl_table_poll *poll)\n{\n\tif (!poll)\n\t\treturn;\n\n\tatomic_inc(&poll->event);\n\twake_up_interruptible(&poll->wait);\n}\n\nstatic struct ctl_table root_table[] = {\n\t{\n\t\t.procname = \"\",\n\t\t.mode = S_IFDIR|S_IRUGO|S_IXUGO,\n\t},\n\t{ }\n};\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}\n\nstatic int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint cmp;\n\n\tcmp = memcmp(name1, name2, min(len1, len2));\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}\n\n \nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\tstruct rb_node **p = &head->parent->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst char *name = entry->procname;\n\tint namelen = strlen(name);\n\n\twhile (*p) {\n\t\tstruct ctl_table_header *parent_head;\n\t\tstruct ctl_table *parent_entry;\n\t\tstruct ctl_node *parent_node;\n\t\tconst char *parent_name;\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tparent_node = rb_entry(parent, struct ctl_node, node);\n\t\tparent_head = parent_node->header;\n\t\tparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\n\t\tparent_name = parent_entry->procname;\n\n\t\tcmp = namecmp(name, namelen, parent_name, strlen(parent_name));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tpr_err(\"sysctl duplicate entry: \");\n\t\t\tsysctl_print_dir(head->parent);\n\t\t\tpr_cont(\"%s\\n\", entry->procname);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &head->parent->root);\n\treturn 0;\n}\n\nstatic void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table, size_t table_size)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_size = table_size;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tINIT_HLIST_HEAD(&head->inodes);\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\n\t\tlist_for_each_table_entry(entry, head) {\n\t\t\tnode->header = head;\n\t\t\tnode++;\n\t\t}\n\t}\n}\n\nstatic void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\n\tlist_for_each_table_entry(entry, head)\n\t\terase_entry(head, entry);\n}\n\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tstruct ctl_table_header *dir_h = &dir->header;\n\tint err;\n\n\n\t \n\tif (sysctl_is_perm_empty_ctl_header(dir_h))\n\t\treturn -EROFS;\n\n\t \n\tif (sysctl_is_perm_empty_ctl_table(header->ctl_table)) {\n\t\tif (!RB_EMPTY_ROOT(&dir->root))\n\t\t\treturn -EINVAL;\n\t\tsysctl_set_perm_empty_ctl_header(dir_h);\n\t}\n\n\tdir_h->nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tlist_for_each_table_entry(entry, header) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\tif (header->ctl_table == sysctl_mount_point)\n\t\tsysctl_clear_perm_empty_ctl_header(dir_h);\n\theader->parent = NULL;\n\tdrop_sysctl_table(dir_h);\n\treturn err;\n}\n\n \nstatic int use_table(struct ctl_table_header *p)\n{\n\tif (unlikely(p->unregistering))\n\t\treturn 0;\n\tp->used++;\n\treturn 1;\n}\n\n \nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}\n\nstatic void proc_sys_invalidate_dcache(struct ctl_table_header *head)\n{\n\tproc_invalidate_siblings_dcache(&head->inodes, &sysctl_lock);\n}\n\n \nstatic void start_unregistering(struct ctl_table_header *p)\n{\n\t \n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t} else {\n\t\t \n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t\tspin_unlock(&sysctl_lock);\n\t}\n\t \n\tproc_sys_invalidate_dcache(p);\n\t \n\tspin_lock(&sysctl_lock);\n\terase_header(p);\n}\n\nstatic struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root);\n\treturn set;\n}\n\nstatic struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}\n\nstatic struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}\n\nstatic void first_entry(struct ctl_dir *dir,\n\tstruct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = NULL;\n\tstruct ctl_table *entry = NULL;\n\tstruct ctl_node *ctl_node;\n\n\tspin_lock(&sysctl_lock);\n\tctl_node = first_usable_entry(rb_first(&dir->root));\n\tspin_unlock(&sysctl_lock);\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}\n\nstatic void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = *phead;\n\tstruct ctl_table *entry = *pentry;\n\tstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\n\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\n\tctl_node = first_usable_entry(rb_next(&ctl_node->node));\n\tspin_unlock(&sysctl_lock);\n\thead = NULL;\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}\n\n \n\nstatic int test_perm(int mode, int op)\n{\n\tif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\n\t\tmode >>= 6;\n\telse if (in_egroup_p(GLOBAL_ROOT_GID))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}\n\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = head->root;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\n\tei = PROC_I(inode);\n\n\tspin_lock(&sysctl_lock);\n\tif (unlikely(head->unregistering)) {\n\t\tspin_unlock(&sysctl_lock);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\thlist_add_head_rcu(&ei->sibling_inodes, &head->inodes);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t\tif (sysctl_is_perm_empty_ctl_header(head))\n\t\t\tmake_empty_dir_inode(inode);\n\t}\n\n\tif (root->set_ownership)\n\t\troot->set_ownership(head, table, &inode->i_uid, &inode->i_gid);\n\telse {\n\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t}\n\n\treturn inode;\n}\n\nvoid proc_sys_evict_inode(struct inode *inode, struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thlist_del_init_rcu(&PROC_I(inode)->sibling_inodes);\n\tif (!--head->count)\n\t\tkfree_rcu(head, rcu);\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}\n\nstatic struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct ctl_table_header *head = grab_header(dir);\n\tstruct ctl_table_header *h = NULL;\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct ctl_table *p;\n\tstruct inode *inode;\n\tstruct dentry *err = ERR_PTR(-ENOENT);\n\tstruct ctl_dir *ctl_dir;\n\tint ret;\n\n\tif (IS_ERR(head))\n\t\treturn ERR_CAST(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tp = lookup_entry(&h, ctl_dir, name->name, name->len);\n\tif (!p)\n\t\tgoto out;\n\n\tif (S_ISLNK(p->mode)) {\n\t\tret = sysctl_follow_link(&h, &p);\n\t\terr = ERR_PTR(ret);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tinode = proc_sys_make_inode(dir->i_sb, h ? h : head, p);\n\tif (IS_ERR(inode)) {\n\t\terr = ERR_CAST(inode);\n\t\tgoto out;\n\t}\n\n\td_set_d_op(dentry, &proc_sys_dentry_operations);\n\terr = d_splice_alias(inode, dentry);\n\nout:\n\tif (h)\n\t\tsysctl_head_finish(h);\n\tsysctl_head_finish(head);\n\treturn err;\n}\n\nstatic ssize_t proc_sys_call_handler(struct kiocb *iocb, struct iov_iter *iter,\n\t\tint write)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tsize_t count = iov_iter_count(iter);\n\tchar *kbuf;\n\tssize_t error;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t \n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t \n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t \n\terror = -ENOMEM;\n\tif (count >= KMALLOC_MAX_SIZE)\n\t\tgoto out;\n\tkbuf = kvzalloc(count + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\tgoto out;\n\n\tif (write) {\n\t\terror = -EFAULT;\n\t\tif (!copy_from_iter_full(kbuf, count, iter))\n\t\t\tgoto out_free_buf;\n\t\tkbuf[count] = '\\0';\n\t}\n\n\terror = BPF_CGROUP_RUN_PROG_SYSCTL(head, table, write, &kbuf, &count,\n\t\t\t\t\t   &iocb->ki_pos);\n\tif (error)\n\t\tgoto out_free_buf;\n\n\t \n\terror = table->proc_handler(table, write, kbuf, &count, &iocb->ki_pos);\n\tif (error)\n\t\tgoto out_free_buf;\n\n\tif (!write) {\n\t\terror = -EFAULT;\n\t\tif (copy_to_iter(kbuf, count, iter) < count)\n\t\t\tgoto out_free_buf;\n\t}\n\n\terror = count;\nout_free_buf:\n\tkvfree(kbuf);\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}\n\nstatic ssize_t proc_sys_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\treturn proc_sys_call_handler(iocb, iter, 0);\n}\n\nstatic ssize_t proc_sys_write(struct kiocb *iocb, struct iov_iter *iter)\n{\n\treturn proc_sys_call_handler(iocb, iter, 1);\n}\n\nstatic int proc_sys_open(struct inode *inode, struct file *filp)\n{\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\t \n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tif (table->poll)\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\n\tsysctl_head_finish(head);\n\n\treturn 0;\n}\n\nstatic __poll_t proc_sys_poll(struct file *filp, poll_table *wait)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tunsigned long event;\n\n\t \n\tif (IS_ERR(head))\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\tif (!table->poll)\n\t\tgoto out;\n\n\tevent = (unsigned long)filp->private_data;\n\tpoll_wait(filp, &table->poll->wait, wait);\n\n\tif (event != atomic_read(&table->poll->event)) {\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\t\tret = EPOLLIN | EPOLLRDNORM | EPOLLERR | EPOLLPRI;\n\t}\n\nout:\n\tsysctl_head_finish(head);\n\n\treturn ret;\n}\n\nstatic bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(dir, qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\t\tchild = d_alloc_parallel(dir, &qname, &wq);\n\t\tif (IS_ERR(child))\n\t\t\treturn false;\n\t\tif (d_in_lookup(child)) {\n\t\t\tstruct dentry *res;\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (IS_ERR(inode)) {\n\t\t\t\td_lookup_done(child);\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\tres = d_splice_alias(inode, child);\n\t\t\td_lookup_done(child);\n\t\t\tif (unlikely(res)) {\n\t\t\t\tif (IS_ERR(res)) {\n\t\t\t\t\tdput(child);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdput(child);\n\t\t\t\tchild = res;\n\t\t\t}\n\t\t}\n\t}\n\tinode = d_inode(child);\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}\n\nstatic bool proc_sys_link_fill_cache(struct file *file,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    struct ctl_table_header *head,\n\t\t\t\t    struct ctl_table *table)\n{\n\tbool ret = true;\n\n\thead = sysctl_head_grab(head);\n\tif (IS_ERR(head))\n\t\treturn false;\n\n\t \n\tif (sysctl_follow_link(&head, &table))\n\t\tgoto out;\n\n\tret = proc_sys_fill_cache(file, ctx, head, table);\nout:\n\tsysctl_head_finish(head);\n\treturn ret;\n}\n\nstatic int scan(struct ctl_table_header *head, struct ctl_table *table,\n\t\tunsigned long *pos, struct file *file,\n\t\tstruct dir_context *ctx)\n{\n\tbool res;\n\n\tif ((*pos)++ < ctx->pos)\n\t\treturn true;\n\n\tif (unlikely(S_ISLNK(table->mode)))\n\t\tres = proc_sys_link_fill_cache(file, ctx, head, table);\n\telse\n\t\tres = proc_sys_fill_cache(file, ctx, head, table);\n\n\tif (res)\n\t\tctx->pos = *pos;\n\n\treturn res;\n}\n\nstatic int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tpos = 2;\n\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tsysctl_head_finish(head);\n\treturn 0;\n}\n\nstatic int proc_sys_permission(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, int mask)\n{\n\t \n\tstruct ctl_table_header *head;\n\tstruct ctl_table *table;\n\tint error;\n\n\t \n\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\n\thead = grab_header(inode);\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\ttable = PROC_I(inode)->sysctl_entry;\n\tif (!table)  \n\t\terror = mask & MAY_WRITE ? -EACCES : 0;\n\telse  \n\t\terror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\n\n\tsysctl_head_finish(head);\n\treturn error;\n}\n\nstatic int proc_sys_setattr(struct mnt_idmap *idmap,\n\t\t\t    struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\tif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\treturn -EPERM;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\treturn 0;\n}\n\nstatic int proc_sys_getattr(struct mnt_idmap *idmap,\n\t\t\t    const struct path *path, struct kstat *stat,\n\t\t\t    u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tif (table)\n\t\tstat->mode = (stat->mode & S_IFMT) | table->mode;\n\n\tsysctl_head_finish(head);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read_iter\t= proc_sys_read,\n\t.write_iter\t= proc_sys_write,\n\t.splice_read\t= copy_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nstatic const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nstatic int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn !PROC_I(d_inode(dentry))->sysctl->unregistering;\n}\n\nstatic int proc_sys_delete(const struct dentry *dentry)\n{\n\treturn !!PROC_I(d_inode(dentry))->sysctl->unregistering;\n}\n\nstatic int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}\n\nstatic int proc_sys_compare(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct ctl_table_header *head;\n\tstruct inode *inode;\n\n\t \n\t \n\tinode = d_inode_rcu(dentry);\n\tif (!inode)\n\t\treturn 1;\n\tif (name->len != len)\n\t\treturn 1;\n\tif (memcmp(name->name, str, len))\n\t\treturn 1;\n\thead = rcu_dereference(PROC_I(inode)->sysctl);\n\treturn !head || !sysctl_is_seen(head);\n}\n\nstatic const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};\n\nstatic struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}\n\nstatic struct ctl_dir *new_dir(struct ctl_table_set *set,\n\t\t\t       const char *name, int namelen)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_dir *new;\n\tstruct ctl_node *node;\n\tchar *new_name;\n\n\tnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1,\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(new + 1);\n\ttable = (struct ctl_table *)(node + 1);\n\tnew_name = (char *)(table + 2);\n\tmemcpy(new_name, name, namelen);\n\ttable[0].procname = new_name;\n\ttable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinit_header(&new->header, set->dir.header.root, set, node, table, 1);\n\n\treturn new;\n}\n\n \nstatic struct ctl_dir *get_subdir(struct ctl_dir *dir,\n\t\t\t\t  const char *name, int namelen)\n{\n\tstruct ctl_table_set *set = dir->header.set;\n\tstruct ctl_dir *subdir, *new = NULL;\n\tint err;\n\n\tspin_lock(&sysctl_lock);\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\tspin_unlock(&sysctl_lock);\n\tnew = new_dir(set, name, namelen);\n\tspin_lock(&sysctl_lock);\n\tsubdir = ERR_PTR(-ENOMEM);\n\tif (!new)\n\t\tgoto failed;\n\n\t \n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\t \n\terr = insert_header(dir, &new->header);\n\tsubdir = ERR_PTR(err);\n\tif (err)\n\t\tgoto failed;\n\tsubdir = new;\nfound:\n\tsubdir->header.nreg++;\nfailed:\n\tif (IS_ERR(subdir)) {\n\t\tpr_err(\"sysctl could not get directory: \");\n\t\tsysctl_print_dir(dir);\n\t\tpr_cont(\"%*.*s %ld\\n\", namelen, namelen, name,\n\t\t\tPTR_ERR(subdir));\n\t}\n\tdrop_sysctl_table(&dir->header);\n\tif (new)\n\t\tdrop_sysctl_table(&new->header);\n\tspin_unlock(&sysctl_lock);\n\treturn subdir;\n}\n\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}\n\nstatic int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"sysctl table check failed: %s/%s %pV\\n\",\n\t       path, table->procname, &vaf);\n\n\tva_end(args);\n\treturn -EINVAL;\n}\n\nstatic int sysctl_check_table_array(const char *path, struct ctl_table *table)\n{\n\tint err = 0;\n\n\tif ((table->proc_handler == proc_douintvec) ||\n\t    (table->proc_handler == proc_douintvec_minmax)) {\n\t\tif (table->maxlen != sizeof(unsigned int))\n\t\t\terr |= sysctl_err(path, table, \"array not allowed\");\n\t}\n\n\tif (table->proc_handler == proc_dou8vec_minmax) {\n\t\tif (table->maxlen != sizeof(u8))\n\t\t\terr |= sysctl_err(path, table, \"array not allowed\");\n\t}\n\n\tif (table->proc_handler == proc_dobool) {\n\t\tif (table->maxlen != sizeof(bool))\n\t\t\terr |= sysctl_err(path, table, \"array not allowed\");\n\t}\n\n\treturn err;\n}\n\nstatic int sysctl_check_table(const char *path, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err = 0;\n\tlist_for_each_table_entry(entry, header) {\n\t\tif ((entry->proc_handler == proc_dostring) ||\n\t\t    (entry->proc_handler == proc_dobool) ||\n\t\t    (entry->proc_handler == proc_dointvec) ||\n\t\t    (entry->proc_handler == proc_douintvec) ||\n\t\t    (entry->proc_handler == proc_douintvec_minmax) ||\n\t\t    (entry->proc_handler == proc_dointvec_minmax) ||\n\t\t    (entry->proc_handler == proc_dou8vec_minmax) ||\n\t\t    (entry->proc_handler == proc_dointvec_jiffies) ||\n\t\t    (entry->proc_handler == proc_dointvec_userhz_jiffies) ||\n\t\t    (entry->proc_handler == proc_dointvec_ms_jiffies) ||\n\t\t    (entry->proc_handler == proc_doulongvec_minmax) ||\n\t\t    (entry->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\n\t\t\tif (!entry->data)\n\t\t\t\terr |= sysctl_err(path, entry, \"No data\");\n\t\t\tif (!entry->maxlen)\n\t\t\t\terr |= sysctl_err(path, entry, \"No maxlen\");\n\t\t\telse\n\t\t\t\terr |= sysctl_check_table_array(path, entry);\n\t\t}\n\t\tif (!entry->proc_handler)\n\t\t\terr |= sysctl_err(path, entry, \"No proc_handler\");\n\n\t\tif ((entry->mode & (S_IRUGO|S_IWUGO)) != entry->mode)\n\t\t\terr |= sysctl_err(path, entry, \"bogus .mode 0%o\",\n\t\t\t\tentry->mode);\n\t}\n\treturn err;\n}\n\nstatic struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table_header *head)\n{\n\tstruct ctl_table *link_table, *entry, *link;\n\tstruct ctl_table_header *links;\n\tstruct ctl_node *node;\n\tchar *link_name;\n\tint nr_entries, name_bytes;\n\n\tname_bytes = 0;\n\tnr_entries = 0;\n\tlist_for_each_table_entry(entry, head) {\n\t\tnr_entries++;\n\t\tname_bytes += strlen(entry->procname) + 1;\n\t}\n\n\tlinks = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes,\n\t\t\tGFP_KERNEL);\n\n\tif (!links)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(links + 1);\n\tlink_table = (struct ctl_table *)(node + nr_entries);\n\tlink_name = (char *)&link_table[nr_entries + 1];\n\tlink = link_table;\n\n\tlist_for_each_table_entry(entry, head) {\n\t\tint len = strlen(entry->procname) + 1;\n\t\tmemcpy(link_name, entry->procname, len);\n\t\tlink->procname = link_name;\n\t\tlink->mode = S_IFLNK|S_IRWXUGO;\n\t\tlink->data = head->root;\n\t\tlink_name += len;\n\t\tlink++;\n\t}\n\tinit_header(links, dir->header.root, dir->header.set, node, link_table,\n\t\t    head->ctl_table_size);\n\tlinks->nreg = nr_entries;\n\n\treturn links;\n}\n\nstatic bool get_links(struct ctl_dir *dir,\n\t\t      struct ctl_table_header *header,\n\t\t      struct ctl_table_root *link_root)\n{\n\tstruct ctl_table_header *tmp_head;\n\tstruct ctl_table *entry, *link;\n\n\t \n\tlist_for_each_table_entry(entry, header) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&tmp_head, dir, procname, strlen(procname));\n\t\tif (!link)\n\t\t\treturn false;\n\t\tif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\n\t\t\tcontinue;\n\t\tif (S_ISLNK(link->mode) && (link->data == link_root))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\t \n\tlist_for_each_table_entry(entry, header) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&tmp_head, dir, procname, strlen(procname));\n\t\ttmp_head->nreg++;\n\t}\n\treturn true;\n}\n\nstatic int insert_links(struct ctl_table_header *head)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table_header *links;\n\tint err;\n\n\tif (head->set == root_set)\n\t\treturn 0;\n\n\tcore_parent = xlate_dir(root_set, head->parent);\n\tif (IS_ERR(core_parent))\n\t\treturn 0;\n\n\tif (get_links(core_parent, head, head->root))\n\t\treturn 0;\n\n\tcore_parent->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tlinks = new_links(core_parent, head);\n\n\tspin_lock(&sysctl_lock);\n\terr = -ENOMEM;\n\tif (!links)\n\t\tgoto out;\n\n\terr = 0;\n\tif (get_links(core_parent, head, head->root)) {\n\t\tkfree(links);\n\t\tgoto out;\n\t}\n\n\terr = insert_header(core_parent, links);\n\tif (err)\n\t\tkfree(links);\nout:\n\tdrop_sysctl_table(&core_parent->header);\n\treturn err;\n}\n\n \nstatic struct ctl_dir *sysctl_mkdir_p(struct ctl_dir *dir, const char *path)\n{\n\tconst char *name, *nextname;\n\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tbreak;\n\t}\n\treturn dir;\n}\n\n \nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table, size_t table_size)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tstruct ctl_dir *dir;\n\tstruct ctl_node *node;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*table_size, GFP_KERNEL_ACCOUNT);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table, table_size);\n\tif (sysctl_check_table(path, header))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t \n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tdir = sysctl_mkdir_p(dir, path);\n\tif (IS_ERR(dir))\n\t\tgoto fail;\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\treturn NULL;\n}\n\n \nstruct ctl_table_header *register_sysctl_sz(const char *path, struct ctl_table *table,\n\t\t\t\t\t    size_t table_size)\n{\n\treturn __register_sysctl_table(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table, table_size);\n}\nEXPORT_SYMBOL(register_sysctl_sz);\n\n \nvoid __init __register_sysctl_init(const char *path, struct ctl_table *table,\n\t\t\t\t const char *table_name, size_t table_size)\n{\n\tstruct ctl_table_header *hdr = register_sysctl_sz(path, table, table_size);\n\n\tif (unlikely(!hdr)) {\n\t\tpr_err(\"failed when register_sysctl_sz %s to %s\\n\", table_name, path);\n\t\treturn;\n\t}\n\tkmemleak_not_leak(hdr);\n}\n\nstatic void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tlist_for_each_table_entry(entry, header) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"%s\\n\", name);\n\t\t}\n\t}\n}\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tif (parent) {\n\t\tput_links(header);\n\t\tstart_unregistering(header);\n\t}\n\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}\n\n \nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}\nEXPORT_SYMBOL(unregister_sysctl_table);\n\nvoid setup_sysctl_set(struct ctl_table_set *set,\n\tstruct ctl_table_root *root,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n\tmemset(set, 0, sizeof(*set));\n\tset->is_seen = is_seen;\n\tinit_header(&set->dir.header, root, set, NULL, root_table, 1);\n}\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}\n\nint __init proc_sys_init(void)\n{\n\tstruct proc_dir_entry *proc_sys_root;\n\n\tproc_sys_root = proc_mkdir(\"sys\", NULL);\n\tproc_sys_root->proc_iops = &proc_sys_dir_operations;\n\tproc_sys_root->proc_dir_ops = &proc_sys_dir_file_operations;\n\tproc_sys_root->nlink = 0;\n\n\treturn sysctl_init_bases();\n}\n\nstruct sysctl_alias {\n\tconst char *kernel_param;\n\tconst char *sysctl_param;\n};\n\n \nstatic const struct sysctl_alias sysctl_aliases[] = {\n\t{\"hardlockup_all_cpu_backtrace\",\t\"kernel.hardlockup_all_cpu_backtrace\" },\n\t{\"hung_task_panic\",\t\t\t\"kernel.hung_task_panic\" },\n\t{\"numa_zonelist_order\",\t\t\t\"vm.numa_zonelist_order\" },\n\t{\"softlockup_all_cpu_backtrace\",\t\"kernel.softlockup_all_cpu_backtrace\" },\n\t{ }\n};\n\nstatic const char *sysctl_find_alias(char *param)\n{\n\tconst struct sysctl_alias *alias;\n\n\tfor (alias = &sysctl_aliases[0]; alias->kernel_param != NULL; alias++) {\n\t\tif (strcmp(alias->kernel_param, param) == 0)\n\t\t\treturn alias->sysctl_param;\n\t}\n\n\treturn NULL;\n}\n\nbool sysctl_is_alias(char *param)\n{\n\tconst char *alias = sysctl_find_alias(param);\n\n\treturn alias != NULL;\n}\n\n \nstatic int process_sysctl_arg(char *param, char *val,\n\t\t\t       const char *unused, void *arg)\n{\n\tchar *path;\n\tstruct vfsmount **proc_mnt = arg;\n\tstruct file_system_type *proc_fs_type;\n\tstruct file *file;\n\tint len;\n\tint err;\n\tloff_t pos = 0;\n\tssize_t wret;\n\n\tif (strncmp(param, \"sysctl\", sizeof(\"sysctl\") - 1) == 0) {\n\t\tparam += sizeof(\"sysctl\") - 1;\n\n\t\tif (param[0] != '/' && param[0] != '.')\n\t\t\treturn 0;\n\n\t\tparam++;\n\t} else {\n\t\tparam = (char *) sysctl_find_alias(param);\n\t\tif (!param)\n\t\t\treturn 0;\n\t}\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tlen = strlen(val);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!*proc_mnt) {\n\t\tproc_fs_type = get_fs_type(\"proc\");\n\t\tif (!proc_fs_type) {\n\t\t\tpr_err(\"Failed to find procfs to set sysctl from command line\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t*proc_mnt = kern_mount(proc_fs_type);\n\t\tput_filesystem(proc_fs_type);\n\t\tif (IS_ERR(*proc_mnt)) {\n\t\t\tpr_err(\"Failed to mount procfs to set sysctl from command line\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpath = kasprintf(GFP_KERNEL, \"sys/%s\", param);\n\tif (!path)\n\t\tpanic(\"%s: Failed to allocate path for %s\\n\", __func__, param);\n\tstrreplace(path, '.', '/');\n\n\tfile = file_open_root_mnt(*proc_mnt, path, O_WRONLY, 0);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tif (err == -ENOENT)\n\t\t\tpr_err(\"Failed to set sysctl parameter '%s=%s': parameter not found\\n\",\n\t\t\t\tparam, val);\n\t\telse if (err == -EACCES)\n\t\t\tpr_err(\"Failed to set sysctl parameter '%s=%s': permission denied (read-only?)\\n\",\n\t\t\t\tparam, val);\n\t\telse\n\t\t\tpr_err(\"Error %pe opening proc file to set sysctl parameter '%s=%s'\\n\",\n\t\t\t\tfile, param, val);\n\t\tgoto out;\n\t}\n\twret = kernel_write(file, val, len, &pos);\n\tif (wret < 0) {\n\t\terr = wret;\n\t\tif (err == -EINVAL)\n\t\t\tpr_err(\"Failed to set sysctl parameter '%s=%s': invalid value\\n\",\n\t\t\t\tparam, val);\n\t\telse\n\t\t\tpr_err(\"Error %pe writing to proc file to set sysctl parameter '%s=%s'\\n\",\n\t\t\t\tERR_PTR(err), param, val);\n\t} else if (wret != len) {\n\t\tpr_err(\"Wrote only %zd bytes of %d writing to proc file %s to set sysctl parameter '%s=%s\\n\",\n\t\t\twret, len, path, param, val);\n\t}\n\n\terr = filp_close(file, NULL);\n\tif (err)\n\t\tpr_err(\"Error %pe closing proc file to set sysctl parameter '%s=%s\\n\",\n\t\t\tERR_PTR(err), param, val);\nout:\n\tkfree(path);\n\treturn 0;\n}\n\nvoid do_sysctl_args(void)\n{\n\tchar *command_line;\n\tstruct vfsmount *proc_mnt = NULL;\n\n\tcommand_line = kstrdup(saved_command_line, GFP_KERNEL);\n\tif (!command_line)\n\t\tpanic(\"%s: Failed to allocate copy of command line\\n\", __func__);\n\n\tparse_args(\"Setting sysctl args\", command_line,\n\t\t   NULL, 0, -1, -1, &proc_mnt, process_sysctl_arg);\n\n\tif (proc_mnt)\n\t\tkern_unmount(proc_mnt);\n\n\tkfree(command_line);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}