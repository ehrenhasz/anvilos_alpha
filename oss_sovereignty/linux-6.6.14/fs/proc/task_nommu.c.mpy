{
  "module_name": "task_nommu.c",
  "hash_id": "4dc69cd6caaf02af9deb59ed4d409d0059b6fd416fe40fd23dd3cd4096bd47cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/task_nommu.c",
  "human_readable_source": "\n\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched/mm.h>\n\n#include \"internal.h\"\n\n \nvoid task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tVMA_ITERATOR(vmi, mm, 0);\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tunsigned long bytes = 0, sbytes = 0, slack = 0, size;\n\n\tmmap_read_lock(mm);\n\tfor_each_vma(vmi, vma) {\n\t\tbytes += kobjsize(vma);\n\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize = kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t} else {\n\t\t\tsize = vma->vm_end - vma->vm_start;\n\t\t}\n\n\t\tif (atomic_read(&mm->mm_count) > 1 ||\n\t\t    is_nommu_shared_mapping(vma->vm_flags)) {\n\t\t\tsbytes += size;\n\t\t} else {\n\t\t\tbytes += size;\n\t\t\tif (region)\n\t\t\t\tslack = region->vm_end - vma->vm_end;\n\t\t}\n\t}\n\n\tif (atomic_read(&mm->mm_count) > 1)\n\t\tsbytes += kobjsize(mm);\n\telse\n\t\tbytes += kobjsize(mm);\n\n\tif (current->fs && current->fs->users > 1)\n\t\tsbytes += kobjsize(current->fs);\n\telse\n\t\tbytes += kobjsize(current->fs);\n\n\tif (current->files && atomic_read(&current->files->count) > 1)\n\t\tsbytes += kobjsize(current->files);\n\telse\n\t\tbytes += kobjsize(current->files);\n\n\tif (current->sighand && refcount_read(&current->sighand->count) > 1)\n\t\tsbytes += kobjsize(current->sighand);\n\telse\n\t\tbytes += kobjsize(current->sighand);\n\n\tbytes += kobjsize(current);  \n\n\tmmap_read_unlock(mm);\n\n\tseq_printf(m,\n\t\t\"Mem:\\t%8lu bytes\\n\"\n\t\t\"Slack:\\t%8lu bytes\\n\"\n\t\t\"Shared:\\t%8lu bytes\\n\",\n\t\tbytes, slack, sbytes);\n}\n\nunsigned long task_vsize(struct mm_struct *mm)\n{\n\tVMA_ITERATOR(vmi, mm, 0);\n\tstruct vm_area_struct *vma;\n\tunsigned long vsize = 0;\n\n\tmmap_read_lock(mm);\n\tfor_each_vma(vmi, vma)\n\t\tvsize += vma->vm_end - vma->vm_start;\n\tmmap_read_unlock(mm);\n\treturn vsize;\n}\n\nunsigned long task_statm(struct mm_struct *mm,\n\t\t\t unsigned long *shared, unsigned long *text,\n\t\t\t unsigned long *data, unsigned long *resident)\n{\n\tVMA_ITERATOR(vmi, mm, 0);\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tunsigned long size = kobjsize(mm);\n\n\tmmap_read_lock(mm);\n\tfor_each_vma(vmi, vma) {\n\t\tsize += kobjsize(vma);\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize += kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t}\n\t}\n\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\t*data = (PAGE_ALIGN(mm->start_stack) - (mm->start_data & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\tmmap_read_unlock(mm);\n\tsize >>= PAGE_SHIFT;\n\tsize += *text + *data;\n\t*resident = size;\n\treturn size;\n}\n\n \nstatic int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\tunsigned long long pgoff = 0;\n\n\tflags = vma->vm_flags;\n\tfile = vma->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   vma->vm_start,\n\t\t   vma->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   pgoff,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_file_path(m, file, \"\");\n\t} else if (mm && vma_is_initial_stack(vma)) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, \"[stack]\");\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\n \nstatic int show_map(struct seq_file *m, void *_p)\n{\n\treturn nommu_vma_show(m, _p);\n}\n\nstatic struct vm_area_struct *proc_get_vma(struct proc_maps_private *priv,\n\t\t\t\t\t\tloff_t *ppos)\n{\n\tstruct vm_area_struct *vma = vma_next(&priv->iter);\n\n\tif (vma) {\n\t\t*ppos = vma->vm_start;\n\t} else {\n\t\t*ppos = -1UL;\n\t}\n\n\treturn vma;\n}\n\nstatic void *m_start(struct seq_file *m, loff_t *ppos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long last_addr = *ppos;\n\tstruct mm_struct *mm;\n\n\t \n\tif (last_addr == -1UL)\n\t\treturn NULL;\n\n\t \n\tpriv->task = get_proc_task(priv->inode);\n\tif (!priv->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\tmm = priv->mm;\n\tif (!mm || !mmget_not_zero(mm)) {\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (mmap_read_lock_killable(mm)) {\n\t\tmmput(mm);\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t\treturn ERR_PTR(-EINTR);\n\t}\n\n\tvma_iter_init(&priv->iter, mm, last_addr);\n\n\treturn proc_get_vma(priv, ppos);\n}\n\nstatic void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct mm_struct *mm = priv->mm;\n\n\tif (!priv->task)\n\t\treturn;\n\n\tmmap_read_unlock(mm);\n\tmmput(mm);\n\tput_task_struct(priv->task);\n\tpriv->task = NULL;\n}\n\nstatic void *m_next(struct seq_file *m, void *_p, loff_t *ppos)\n{\n\treturn proc_get_vma(m->private, ppos);\n}\n\nstatic const struct seq_operations proc_pid_maps_ops = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_map\n};\n\nstatic int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct proc_maps_private *priv = seq->private;\n\n\tif (priv->mm)\n\t\tmmdrop(priv->mm);\n\n\treturn seq_release_private(inode, file);\n}\n\nstatic int pid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn maps_open(inode, file, &proc_pid_maps_ops);\n}\n\nconst struct file_operations proc_pid_maps_operations = {\n\t.open\t\t= pid_maps_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= map_release,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}