{
  "module_name": "root.c",
  "hash_id": "b4c2b81c342dce407b6d53d7cef2fcba69719773d78520a59f997ba76e075803",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/root.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/stat.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/user_namespace.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_parser.h>\n#include <linux/cred.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstruct proc_fs_context {\n\tstruct pid_namespace\t*pid_ns;\n\tunsigned int\t\tmask;\n\tenum proc_hidepid\thidepid;\n\tint\t\t\tgid;\n\tenum proc_pidonly\tpidonly;\n};\n\nenum proc_param {\n\tOpt_gid,\n\tOpt_hidepid,\n\tOpt_subset,\n};\n\nstatic const struct fs_parameter_spec proc_fs_parameters[] = {\n\tfsparam_u32(\"gid\",\tOpt_gid),\n\tfsparam_string(\"hidepid\",\tOpt_hidepid),\n\tfsparam_string(\"subset\",\tOpt_subset),\n\t{}\n};\n\nstatic inline int valid_hidepid(unsigned int value)\n{\n\treturn (value == HIDEPID_OFF ||\n\t\tvalue == HIDEPID_NO_ACCESS ||\n\t\tvalue == HIDEPID_INVISIBLE ||\n\t\tvalue == HIDEPID_NOT_PTRACEABLE);\n}\n\nstatic int proc_parse_hidepid_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\tstruct fs_parameter_spec hidepid_u32_spec = fsparam_u32(\"hidepid\", Opt_hidepid);\n\tstruct fs_parse_result result;\n\tint base = (unsigned long)hidepid_u32_spec.data;\n\n\tif (param->type != fs_value_is_string)\n\t\treturn invalf(fc, \"proc: unexpected type of hidepid value\\n\");\n\n\tif (!kstrtouint(param->string, base, &result.uint_32)) {\n\t\tif (!valid_hidepid(result.uint_32))\n\t\t\treturn invalf(fc, \"proc: unknown value of hidepid - %s\\n\", param->string);\n\t\tctx->hidepid = result.uint_32;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(param->string, \"off\"))\n\t\tctx->hidepid = HIDEPID_OFF;\n\telse if (!strcmp(param->string, \"noaccess\"))\n\t\tctx->hidepid = HIDEPID_NO_ACCESS;\n\telse if (!strcmp(param->string, \"invisible\"))\n\t\tctx->hidepid = HIDEPID_INVISIBLE;\n\telse if (!strcmp(param->string, \"ptraceable\"))\n\t\tctx->hidepid = HIDEPID_NOT_PTRACEABLE;\n\telse\n\t\treturn invalf(fc, \"proc: unknown value of hidepid - %s\\n\", param->string);\n\n\treturn 0;\n}\n\nstatic int proc_parse_subset_param(struct fs_context *fc, char *value)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\n\twhile (value) {\n\t\tchar *ptr = strchr(value, ',');\n\n\t\tif (ptr != NULL)\n\t\t\t*ptr++ = '\\0';\n\n\t\tif (*value != '\\0') {\n\t\t\tif (!strcmp(value, \"pid\")) {\n\t\t\t\tctx->pidonly = PROC_PIDONLY_ON;\n\t\t\t} else {\n\t\t\t\treturn invalf(fc, \"proc: unsupported subset option - %s\\n\", value);\n\t\t\t}\n\t\t}\n\t\tvalue = ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int proc_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, proc_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_gid:\n\t\tctx->gid = result.uint_32;\n\t\tbreak;\n\n\tcase Opt_hidepid:\n\t\tif (proc_parse_hidepid_param(fc, param))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase Opt_subset:\n\t\tif (proc_parse_subset_param(fc, param->string) < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tctx->mask |= 1 << opt;\n\treturn 0;\n}\n\nstatic void proc_apply_options(struct proc_fs_info *fs_info,\n\t\t\t       struct fs_context *fc,\n\t\t\t       struct user_namespace *user_ns)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\n\tif (ctx->mask & (1 << Opt_gid))\n\t\tfs_info->pid_gid = make_kgid(user_ns, ctx->gid);\n\tif (ctx->mask & (1 << Opt_hidepid))\n\t\tfs_info->hide_pid = ctx->hidepid;\n\tif (ctx->mask & (1 << Opt_subset))\n\t\tfs_info->pidonly = ctx->pidonly;\n}\n\nstatic int proc_fill_super(struct super_block *s, struct fs_context *fc)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\tstruct inode *root_inode;\n\tstruct proc_fs_info *fs_info;\n\tint ret;\n\n\tfs_info = kzalloc(sizeof(*fs_info), GFP_KERNEL);\n\tif (!fs_info)\n\t\treturn -ENOMEM;\n\n\tfs_info->pid_ns = get_pid_ns(ctx->pid_ns);\n\tproc_apply_options(fs_info, fc, current_user_ns());\n\n\t \n\ts->s_iflags |= SB_I_USERNS_VISIBLE | SB_I_NOEXEC | SB_I_NODEV;\n\ts->s_flags |= SB_NODIRATIME | SB_NOSUID | SB_NOEXEC;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = PROC_SUPER_MAGIC;\n\ts->s_op = &proc_sops;\n\ts->s_time_gran = 1;\n\ts->s_fs_info = fs_info;\n\n\t \n\ts->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;\n\n\t \n\ts->s_shrink.seeks = 0;\n\n\tpde_get(&proc_root);\n\troot_inode = proc_get_inode(s, &proc_root);\n\tif (!root_inode) {\n\t\tpr_err(\"proc_fill_super: get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root) {\n\t\tpr_err(\"proc_fill_super: allocate dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = proc_setup_self(s);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\treturn proc_setup_thread_self(s);\n}\n\nstatic int proc_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct proc_fs_info *fs_info = proc_sb_info(sb);\n\n\tsync_filesystem(sb);\n\n\tproc_apply_options(fs_info, fc, current_user_ns());\n\treturn 0;\n}\n\nstatic int proc_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, proc_fill_super);\n}\n\nstatic void proc_fs_context_free(struct fs_context *fc)\n{\n\tstruct proc_fs_context *ctx = fc->fs_private;\n\n\tput_pid_ns(ctx->pid_ns);\n\tkfree(ctx);\n}\n\nstatic const struct fs_context_operations proc_fs_context_ops = {\n\t.free\t\t= proc_fs_context_free,\n\t.parse_param\t= proc_parse_param,\n\t.get_tree\t= proc_get_tree,\n\t.reconfigure\t= proc_reconfigure,\n};\n\nstatic int proc_init_fs_context(struct fs_context *fc)\n{\n\tstruct proc_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct proc_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->pid_ns = get_pid_ns(task_active_pid_ns(current));\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->pid_ns->user_ns);\n\tfc->fs_private = ctx;\n\tfc->ops = &proc_fs_context_ops;\n\treturn 0;\n}\n\nstatic void proc_kill_sb(struct super_block *sb)\n{\n\tstruct proc_fs_info *fs_info = proc_sb_info(sb);\n\n\tif (!fs_info) {\n\t\tkill_anon_super(sb);\n\t\treturn;\n\t}\n\n\tdput(fs_info->proc_self);\n\tdput(fs_info->proc_thread_self);\n\n\tkill_anon_super(sb);\n\tput_pid_ns(fs_info->pid_ns);\n\tkfree(fs_info);\n}\n\nstatic struct file_system_type proc_fs_type = {\n\t.name\t\t\t= \"proc\",\n\t.init_fs_context\t= proc_init_fs_context,\n\t.parameters\t\t= proc_fs_parameters,\n\t.kill_sb\t\t= proc_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT | FS_DISALLOW_NOTIFY_PERM,\n};\n\nvoid __init proc_root_init(void)\n{\n\tproc_init_kmemcache();\n\tset_proc_pid_nlink();\n\tproc_self_init();\n\tproc_thread_self_init();\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_create_mount_point(\"fs/nfsd\");  \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t \n\tproc_create_mount_point(\"openprom\");\n#endif\n\tproc_tty_init();\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n\n\t \n\tregister_filesystem(&proc_fs_type);\n}\n\nstatic int proc_root_getattr(struct mnt_idmap *idmap,\n\t\t\t     const struct path *path, struct kstat *stat,\n\t\t\t     u32 request_mask, unsigned int query_flags)\n{\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, d_inode(path->dentry),\n\t\t\t stat);\n\tstat->nlink = proc_root.nlink + nr_processes();\n\treturn 0;\n}\n\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\n{\n\tif (!proc_pid_lookup(dentry, flags))\n\t\treturn NULL;\n\n\treturn proc_lookup(dir, dentry, flags);\n}\n\nstatic int proc_root_readdir(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos < FIRST_PROCESS_ENTRY) {\n\t\tint error = proc_readdir(file, ctx);\n\t\tif (unlikely(error <= 0))\n\t\t\treturn error;\n\t\tctx->pos = FIRST_PROCESS_ENTRY;\n\t}\n\n\treturn proc_pid_readdir(file, ctx);\n}\n\n \nstatic const struct file_operations proc_root_operations = {\n\t.read\t\t = generic_read_dir,\n\t.iterate_shared\t = proc_root_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n \nstatic const struct inode_operations proc_root_inode_operations = {\n\t.lookup\t\t= proc_root_lookup,\n\t.getattr\t= proc_root_getattr,\n};\n\n \nstruct proc_dir_entry proc_root = {\n\t.low_ino\t= PROC_ROOT_INO, \n\t.namelen\t= 5, \n\t.mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO, \n\t.nlink\t\t= 2, \n\t.refcnt\t\t= REFCOUNT_INIT(1),\n\t.proc_iops\t= &proc_root_inode_operations, \n\t.proc_dir_ops\t= &proc_root_operations,\n\t.parent\t\t= &proc_root,\n\t.subdir\t\t= RB_ROOT,\n\t.name\t\t= \"/proc\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}