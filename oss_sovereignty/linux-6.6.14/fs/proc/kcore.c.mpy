{
  "module_name": "kcore.c",
  "hash_id": "65ff8fd3f25baa83069a8e1d00887ee98b0d16f8165f51e38a1d1c31f36c4d28",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/kcore.c",
  "human_readable_source": "\n \n\n#include <linux/crash_core.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/kcore.h>\n#include <linux/user.h>\n#include <linux/capability.h>\n#include <linux/elf.h>\n#include <linux/elfcore.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/printk.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n#include <asm/io.h>\n#include <linux/list.h>\n#include <linux/ioport.h>\n#include <linux/memory.h>\n#include <linux/sched/task.h>\n#include <linux/security.h>\n#include <asm/sections.h>\n#include \"internal.h\"\n\n#define CORE_STR \"CORE\"\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\nstatic struct proc_dir_entry *proc_root_kcore;\n\n\n#ifndef kc_vaddr_to_offset\n#define\tkc_vaddr_to_offset(v) ((v) - PAGE_OFFSET)\n#endif\n#ifndef\tkc_offset_to_vaddr\n#define\tkc_offset_to_vaddr(o) ((o) + PAGE_OFFSET)\n#endif\n\nstatic LIST_HEAD(kclist_head);\nstatic DECLARE_RWSEM(kclist_lock);\nstatic int kcore_need_update = 1;\n\n \nstatic int (*mem_pfn_is_ram)(unsigned long pfn);\n\nint __init register_mem_pfn_is_ram(int (*fn)(unsigned long pfn))\n{\n\tif (mem_pfn_is_ram)\n\t\treturn -EBUSY;\n\tmem_pfn_is_ram = fn;\n\treturn 0;\n}\n\nstatic int pfn_is_ram(unsigned long pfn)\n{\n\tif (mem_pfn_is_ram)\n\t\treturn mem_pfn_is_ram(pfn);\n\telse\n\t\treturn 1;\n}\n\n \nvoid __init kclist_add(struct kcore_list *new, void *addr, size_t size,\n\t\t       int type)\n{\n\tnew->addr = (unsigned long)addr;\n\tnew->size = size;\n\tnew->type = type;\n\n\tlist_add_tail(&new->list, &kclist_head);\n}\n\nstatic size_t get_kcore_size(int *nphdr, size_t *phdrs_len, size_t *notes_len,\n\t\t\t     size_t *data_offset)\n{\n\tsize_t try, size;\n\tstruct kcore_list *m;\n\n\t*nphdr = 1;  \n\tsize = 0;\n\n\tlist_for_each_entry(m, &kclist_head, list) {\n\t\ttry = kc_vaddr_to_offset((size_t)m->addr + m->size);\n\t\tif (try > size)\n\t\t\tsize = try;\n\t\t*nphdr = *nphdr + 1;\n\t}\n\n\t*phdrs_len = *nphdr * sizeof(struct elf_phdr);\n\t*notes_len = (4 * sizeof(struct elf_note) +\n\t\t      3 * ALIGN(sizeof(CORE_STR), 4) +\n\t\t      VMCOREINFO_NOTE_NAME_BYTES +\n\t\t      ALIGN(sizeof(struct elf_prstatus), 4) +\n\t\t      ALIGN(sizeof(struct elf_prpsinfo), 4) +\n\t\t      ALIGN(arch_task_struct_size, 4) +\n\t\t      ALIGN(vmcoreinfo_size, 4));\n\t*data_offset = PAGE_ALIGN(sizeof(struct elfhdr) + *phdrs_len +\n\t\t\t\t  *notes_len);\n\treturn *data_offset + size;\n}\n\n#ifdef CONFIG_HIGHMEM\n \nstatic int kcore_ram_list(struct list_head *head)\n{\n\tstruct kcore_list *ent;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->addr = (unsigned long)__va(0);\n\tent->size = max_low_pfn << PAGE_SHIFT;\n\tent->type = KCORE_RAM;\n\tlist_add(&ent->list, head);\n\treturn 0;\n}\n\n#else  \n\n#ifdef CONFIG_SPARSEMEM_VMEMMAP\n \nstatic int\nget_sparsemem_vmemmap_info(struct kcore_list *ent, struct list_head *head)\n{\n\tunsigned long pfn = __pa(ent->addr) >> PAGE_SHIFT;\n\tunsigned long nr_pages = ent->size >> PAGE_SHIFT;\n\tunsigned long start, end;\n\tstruct kcore_list *vmm, *tmp;\n\n\n\tstart = ((unsigned long)pfn_to_page(pfn)) & PAGE_MASK;\n\tend = ((unsigned long)pfn_to_page(pfn + nr_pages)) - 1;\n\tend = PAGE_ALIGN(end);\n\t \n\tlist_for_each_entry(tmp, head, list) {\n\t\tif (tmp->type != KCORE_VMEMMAP)\n\t\t\tcontinue;\n\t\tif (start < tmp->addr + tmp->size)\n\t\t\tif (end > tmp->addr)\n\t\t\t\tend = tmp->addr;\n\t}\n\tif (start < end) {\n\t\tvmm = kmalloc(sizeof(*vmm), GFP_KERNEL);\n\t\tif (!vmm)\n\t\t\treturn 0;\n\t\tvmm->addr = start;\n\t\tvmm->size = end - start;\n\t\tvmm->type = KCORE_VMEMMAP;\n\t\tlist_add_tail(&vmm->list, head);\n\t}\n\treturn 1;\n\n}\n#else\nstatic int\nget_sparsemem_vmemmap_info(struct kcore_list *ent, struct list_head *head)\n{\n\treturn 1;\n}\n\n#endif\n\nstatic int\nkclist_add_private(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\tstruct list_head *head = (struct list_head *)arg;\n\tstruct kcore_list *ent;\n\tstruct page *p;\n\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\n\tp = pfn_to_page(pfn);\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->addr = (unsigned long)page_to_virt(p);\n\tent->size = nr_pages << PAGE_SHIFT;\n\n\tif (!virt_addr_valid((void *)ent->addr))\n\t\tgoto free_out;\n\n\t \n\tif (ULONG_MAX - ent->addr < ent->size)\n\t\tent->size = ULONG_MAX - ent->addr;\n\n\t \n\tif (VMALLOC_START > ent->addr) {\n\t\tif (VMALLOC_START - ent->addr < ent->size)\n\t\t\tent->size = VMALLOC_START - ent->addr;\n\t}\n\n\tent->type = KCORE_RAM;\n\tlist_add_tail(&ent->list, head);\n\n\tif (!get_sparsemem_vmemmap_info(ent, head)) {\n\t\tlist_del(&ent->list);\n\t\tgoto free_out;\n\t}\n\n\treturn 0;\nfree_out:\n\tkfree(ent);\n\treturn 1;\n}\n\nstatic int kcore_ram_list(struct list_head *list)\n{\n\tint nid, ret;\n\tunsigned long end_pfn;\n\n\t \n\t \n\tend_pfn = 0;\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long node_end;\n\t\tnode_end = node_end_pfn(nid);\n\t\tif (end_pfn < node_end)\n\t\t\tend_pfn = node_end;\n\t}\n\t \n\tret = walk_system_ram_range(0, end_pfn, list, kclist_add_private);\n\tif (ret)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n#endif  \n\nstatic int kcore_update_ram(void)\n{\n\tLIST_HEAD(list);\n\tLIST_HEAD(garbage);\n\tint nphdr;\n\tsize_t phdrs_len, notes_len, data_offset;\n\tstruct kcore_list *tmp, *pos;\n\tint ret = 0;\n\n\tdown_write(&kclist_lock);\n\tif (!xchg(&kcore_need_update, 0))\n\t\tgoto out;\n\n\tret = kcore_ram_list(&list);\n\tif (ret) {\n\t\t \n\t\tWRITE_ONCE(kcore_need_update, 1);\n\t\tlist_splice_tail(&list, &garbage);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(pos, tmp, &kclist_head, list) {\n\t\tif (pos->type == KCORE_RAM || pos->type == KCORE_VMEMMAP)\n\t\t\tlist_move(&pos->list, &garbage);\n\t}\n\tlist_splice_tail(&list, &kclist_head);\n\n\tproc_root_kcore->size = get_kcore_size(&nphdr, &phdrs_len, &notes_len,\n\t\t\t\t\t       &data_offset);\n\nout:\n\tup_write(&kclist_lock);\n\tlist_for_each_entry_safe(pos, tmp, &garbage, list) {\n\t\tlist_del(&pos->list);\n\t\tkfree(pos);\n\t}\n\treturn ret;\n}\n\nstatic void append_kcore_note(char *notes, size_t *i, const char *name,\n\t\t\t      unsigned int type, const void *desc,\n\t\t\t      size_t descsz)\n{\n\tstruct elf_note *note = (struct elf_note *)&notes[*i];\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = descsz;\n\tnote->n_type = type;\n\t*i += sizeof(*note);\n\tmemcpy(&notes[*i], name, note->n_namesz);\n\t*i = ALIGN(*i + note->n_namesz, 4);\n\tmemcpy(&notes[*i], desc, descsz);\n\t*i = ALIGN(*i + descsz, 4);\n}\n\nstatic ssize_t read_kcore_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tchar *buf = file->private_data;\n\tloff_t *fpos = &iocb->ki_pos;\n\tsize_t phdrs_offset, notes_offset, data_offset;\n\tsize_t page_offline_frozen = 1;\n\tsize_t phdrs_len, notes_len;\n\tstruct kcore_list *m;\n\tsize_t tsz;\n\tint nphdr;\n\tunsigned long start;\n\tsize_t buflen = iov_iter_count(iter);\n\tsize_t orig_buflen = buflen;\n\tint ret = 0;\n\n\tdown_read(&kclist_lock);\n\t \n\tpage_offline_freeze();\n\n\tget_kcore_size(&nphdr, &phdrs_len, &notes_len, &data_offset);\n\tphdrs_offset = sizeof(struct elfhdr);\n\tnotes_offset = phdrs_offset + phdrs_len;\n\n\t \n\tif (buflen && *fpos < sizeof(struct elfhdr)) {\n\t\tstruct elfhdr ehdr = {\n\t\t\t.e_ident = {\n\t\t\t\t[EI_MAG0] = ELFMAG0,\n\t\t\t\t[EI_MAG1] = ELFMAG1,\n\t\t\t\t[EI_MAG2] = ELFMAG2,\n\t\t\t\t[EI_MAG3] = ELFMAG3,\n\t\t\t\t[EI_CLASS] = ELF_CLASS,\n\t\t\t\t[EI_DATA] = ELF_DATA,\n\t\t\t\t[EI_VERSION] = EV_CURRENT,\n\t\t\t\t[EI_OSABI] = ELF_OSABI,\n\t\t\t},\n\t\t\t.e_type = ET_CORE,\n\t\t\t.e_machine = ELF_ARCH,\n\t\t\t.e_version = EV_CURRENT,\n\t\t\t.e_phoff = sizeof(struct elfhdr),\n\t\t\t.e_flags = ELF_CORE_EFLAGS,\n\t\t\t.e_ehsize = sizeof(struct elfhdr),\n\t\t\t.e_phentsize = sizeof(struct elf_phdr),\n\t\t\t.e_phnum = nphdr,\n\t\t};\n\n\t\ttsz = min_t(size_t, buflen, sizeof(struct elfhdr) - *fpos);\n\t\tif (copy_to_iter((char *)&ehdr + *fpos, tsz, iter) != tsz) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t}\n\n\t \n\tif (buflen && *fpos < phdrs_offset + phdrs_len) {\n\t\tstruct elf_phdr *phdrs, *phdr;\n\n\t\tphdrs = kzalloc(phdrs_len, GFP_KERNEL);\n\t\tif (!phdrs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tphdrs[0].p_type = PT_NOTE;\n\t\tphdrs[0].p_offset = notes_offset;\n\t\tphdrs[0].p_filesz = notes_len;\n\n\t\tphdr = &phdrs[1];\n\t\tlist_for_each_entry(m, &kclist_head, list) {\n\t\t\tphdr->p_type = PT_LOAD;\n\t\t\tphdr->p_flags = PF_R | PF_W | PF_X;\n\t\t\tphdr->p_offset = kc_vaddr_to_offset(m->addr) + data_offset;\n\t\t\tphdr->p_vaddr = (size_t)m->addr;\n\t\t\tif (m->type == KCORE_RAM)\n\t\t\t\tphdr->p_paddr = __pa(m->addr);\n\t\t\telse if (m->type == KCORE_TEXT)\n\t\t\t\tphdr->p_paddr = __pa_symbol(m->addr);\n\t\t\telse\n\t\t\t\tphdr->p_paddr = (elf_addr_t)-1;\n\t\t\tphdr->p_filesz = phdr->p_memsz = m->size;\n\t\t\tphdr->p_align = PAGE_SIZE;\n\t\t\tphdr++;\n\t\t}\n\n\t\ttsz = min_t(size_t, buflen, phdrs_offset + phdrs_len - *fpos);\n\t\tif (copy_to_iter((char *)phdrs + *fpos - phdrs_offset, tsz,\n\t\t\t\t iter) != tsz) {\n\t\t\tkfree(phdrs);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkfree(phdrs);\n\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t}\n\n\t \n\tif (buflen && *fpos < notes_offset + notes_len) {\n\t\tstruct elf_prstatus prstatus = {};\n\t\tstruct elf_prpsinfo prpsinfo = {\n\t\t\t.pr_sname = 'R',\n\t\t\t.pr_fname = \"vmlinux\",\n\t\t};\n\t\tchar *notes;\n\t\tsize_t i = 0;\n\n\t\tstrscpy(prpsinfo.pr_psargs, saved_command_line,\n\t\t\tsizeof(prpsinfo.pr_psargs));\n\n\t\tnotes = kzalloc(notes_len, GFP_KERNEL);\n\t\tif (!notes) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tappend_kcore_note(notes, &i, CORE_STR, NT_PRSTATUS, &prstatus,\n\t\t\t\t  sizeof(prstatus));\n\t\tappend_kcore_note(notes, &i, CORE_STR, NT_PRPSINFO, &prpsinfo,\n\t\t\t\t  sizeof(prpsinfo));\n\t\tappend_kcore_note(notes, &i, CORE_STR, NT_TASKSTRUCT, current,\n\t\t\t\t  arch_task_struct_size);\n\t\t \n\t\tappend_kcore_note(notes, &i, VMCOREINFO_NOTE_NAME, 0,\n\t\t\t\t  vmcoreinfo_data,\n\t\t\t\t  min(vmcoreinfo_size, notes_len - i));\n\n\t\ttsz = min_t(size_t, buflen, notes_offset + notes_len - *fpos);\n\t\tif (copy_to_iter(notes + *fpos - notes_offset, tsz, iter) != tsz) {\n\t\t\tkfree(notes);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkfree(notes);\n\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t}\n\n\t \n\tstart = kc_offset_to_vaddr(*fpos - data_offset);\n\tif ((tsz = (PAGE_SIZE - (start & ~PAGE_MASK))) > buflen)\n\t\ttsz = buflen;\n\n\tm = NULL;\n\twhile (buflen) {\n\t\tstruct page *page;\n\t\tunsigned long pfn;\n\n\t\t \n\t\tif (!m || start < m->addr || start >= m->addr + m->size) {\n\t\t\tstruct kcore_list *iter;\n\n\t\t\tm = NULL;\n\t\t\tlist_for_each_entry(iter, &kclist_head, list) {\n\t\t\t\tif (start >= iter->addr &&\n\t\t\t\t    start < iter->addr + iter->size) {\n\t\t\t\t\tm = iter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (page_offline_frozen++ % MAX_ORDER_NR_PAGES == 0) {\n\t\t\tpage_offline_thaw();\n\t\t\tcond_resched();\n\t\t\tpage_offline_freeze();\n\t\t}\n\n\t\tif (!m) {\n\t\t\tif (iov_iter_zero(tsz, iter) != tsz) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t}\n\n\t\tswitch (m->type) {\n\t\tcase KCORE_VMALLOC:\n\t\t{\n\t\t\tconst char *src = (char *)start;\n\t\t\tsize_t read = 0, left = tsz;\n\n\t\t\t \n\t\t\twhile (true) {\n\t\t\t\tread += vread_iter(iter, src, left);\n\t\t\t\tif (read == tsz)\n\t\t\t\t\tbreak;\n\n\t\t\t\tsrc += read;\n\t\t\t\tleft -= read;\n\n\t\t\t\tif (fault_in_iov_iter_writeable(iter, left)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase KCORE_USER:\n\t\t\t \n\t\t\tif (copy_to_iter((char *)start, tsz, iter) != tsz) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KCORE_RAM:\n\t\t\tpfn = __pa(start) >> PAGE_SHIFT;\n\t\t\tpage = pfn_to_online_page(pfn);\n\n\t\t\t \n\t\t\tif (!page || PageOffline(page) ||\n\t\t\t    is_page_hwpoison(page) || !pfn_is_ram(pfn)) {\n\t\t\t\tif (iov_iter_zero(tsz, iter) != tsz) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase KCORE_VMEMMAP:\n\t\tcase KCORE_TEXT:\n\t\t\t \n\t\t\tif (copy_from_kernel_nofault(buf, (void *)start, tsz)) {\n\t\t\t\tif (iov_iter_zero(tsz, iter) != tsz) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t \n\t\t\t} else if (_copy_to_iter(buf, tsz, iter) != tsz) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn_once(\"Unhandled KCORE type: %d\\n\", m->type);\n\t\t\tif (iov_iter_zero(tsz, iter) != tsz) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nskip:\n\t\tbuflen -= tsz;\n\t\t*fpos += tsz;\n\t\tstart += tsz;\n\t\ttsz = (buflen > PAGE_SIZE ? PAGE_SIZE : buflen);\n\t}\n\nout:\n\tpage_offline_thaw();\n\tup_read(&kclist_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn orig_buflen - buflen;\n}\n\nstatic int open_kcore(struct inode *inode, struct file *filp)\n{\n\tint ret = security_locked_down(LOCKDOWN_KCORE);\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!filp->private_data)\n\t\treturn -ENOMEM;\n\n\tif (kcore_need_update)\n\t\tkcore_update_ram();\n\tif (i_size_read(inode) != proc_root_kcore->size) {\n\t\tinode_lock(inode);\n\t\ti_size_write(inode, proc_root_kcore->size);\n\t\tinode_unlock(inode);\n\t}\n\treturn 0;\n}\n\nstatic int release_kcore(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct proc_ops kcore_proc_ops = {\n\t.proc_read_iter\t= read_kcore_iter,\n\t.proc_open\t= open_kcore,\n\t.proc_release\t= release_kcore,\n\t.proc_lseek\t= default_llseek,\n};\n\n \nstatic int __meminit kcore_callback(struct notifier_block *self,\n\t\t\t\t    unsigned long action, void *arg)\n{\n\tswitch (action) {\n\tcase MEM_ONLINE:\n\tcase MEM_OFFLINE:\n\t\tkcore_need_update = 1;\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\n\nstatic struct kcore_list kcore_vmalloc;\n\n#ifdef CONFIG_ARCH_PROC_KCORE_TEXT\nstatic struct kcore_list kcore_text;\n \nstatic void __init proc_kcore_text_init(void)\n{\n\tkclist_add(&kcore_text, _text, _end - _text, KCORE_TEXT);\n}\n#else\nstatic void __init proc_kcore_text_init(void)\n{\n}\n#endif\n\n#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)\n \nstatic struct kcore_list kcore_modules;\nstatic void __init add_modules_range(void)\n{\n\tif (MODULES_VADDR != VMALLOC_START && MODULES_END != VMALLOC_END) {\n\t\tkclist_add(&kcore_modules, (void *)MODULES_VADDR,\n\t\t\tMODULES_END - MODULES_VADDR, KCORE_VMALLOC);\n\t}\n}\n#else\nstatic void __init add_modules_range(void)\n{\n}\n#endif\n\nstatic int __init proc_kcore_init(void)\n{\n\tproc_root_kcore = proc_create(\"kcore\", S_IRUSR, NULL, &kcore_proc_ops);\n\tif (!proc_root_kcore) {\n\t\tpr_err(\"couldn't create /proc/kcore\\n\");\n\t\treturn 0;  \n\t}\n\t \n\tproc_kcore_text_init();\n\t \n\tkclist_add(&kcore_vmalloc, (void *)VMALLOC_START,\n\t\tVMALLOC_END - VMALLOC_START, KCORE_VMALLOC);\n\tadd_modules_range();\n\t \n\tkcore_update_ram();\n\thotplug_memory_notifier(kcore_callback, DEFAULT_CALLBACK_PRI);\n\n\treturn 0;\n}\nfs_initcall(proc_kcore_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}