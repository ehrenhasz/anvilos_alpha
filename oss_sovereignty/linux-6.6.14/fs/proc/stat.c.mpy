{
  "module_name": "stat.c",
  "hash_id": "80817b7ab6e956baf455e8dcf93197b4b4ff58e40c42ae9b92059363b5244553",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/stat.c",
  "human_readable_source": "\n#include <linux/cpumask.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/sched/stat.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/time_namespace.h>\n#include <linux/irqnr.h>\n#include <linux/sched/cputime.h>\n#include <linux/tick.h>\n\n#ifndef arch_irq_stat_cpu\n#define arch_irq_stat_cpu(cpu) 0\n#endif\n#ifndef arch_irq_stat\n#define arch_irq_stat() 0\n#endif\n\nu64 get_idle_time(struct kernel_cpustat *kcs, int cpu)\n{\n\tu64 idle, idle_usecs = -1ULL;\n\n\tif (cpu_online(cpu))\n\t\tidle_usecs = get_cpu_idle_time_us(cpu, NULL);\n\n\tif (idle_usecs == -1ULL)\n\t\t \n\t\tidle = kcs->cpustat[CPUTIME_IDLE];\n\telse\n\t\tidle = idle_usecs * NSEC_PER_USEC;\n\n\treturn idle;\n}\n\nstatic u64 get_iowait_time(struct kernel_cpustat *kcs, int cpu)\n{\n\tu64 iowait, iowait_usecs = -1ULL;\n\n\tif (cpu_online(cpu))\n\t\tiowait_usecs = get_cpu_iowait_time_us(cpu, NULL);\n\n\tif (iowait_usecs == -1ULL)\n\t\t \n\t\tiowait = kcs->cpustat[CPUTIME_IOWAIT];\n\telse\n\t\tiowait = iowait_usecs * NSEC_PER_USEC;\n\n\treturn iowait;\n}\n\nstatic void show_irq_gap(struct seq_file *p, unsigned int gap)\n{\n\tstatic const char zeros[] = \" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\";\n\n\twhile (gap > 0) {\n\t\tunsigned int inc;\n\n\t\tinc = min_t(unsigned int, gap, ARRAY_SIZE(zeros) / 2);\n\t\tseq_write(p, zeros, 2 * inc);\n\t\tgap -= inc;\n\t}\n}\n\nstatic void show_all_irqs(struct seq_file *p)\n{\n\tunsigned int i, next = 0;\n\n\tfor_each_active_irq(i) {\n\t\tshow_irq_gap(p, i - next);\n\t\tseq_put_decimal_ull(p, \" \", kstat_irqs_usr(i));\n\t\tnext = i + 1;\n\t}\n\tshow_irq_gap(p, nr_irqs - next);\n}\n\nstatic int show_stat(struct seq_file *p, void *v)\n{\n\tint i, j;\n\tu64 user, nice, system, idle, iowait, irq, softirq, steal;\n\tu64 guest, guest_nice;\n\tu64 sum = 0;\n\tu64 sum_softirq = 0;\n\tunsigned int per_softirq_sums[NR_SOFTIRQS] = {0};\n\tstruct timespec64 boottime;\n\n\tuser = nice = system = idle = iowait =\n\t\tirq = softirq = steal = 0;\n\tguest = guest_nice = 0;\n\tgetboottime64(&boottime);\n\t \n\ttimens_sub_boottime(&boottime);\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser\t\t+= cpustat[CPUTIME_USER];\n\t\tnice\t\t+= cpustat[CPUTIME_NICE];\n\t\tsystem\t\t+= cpustat[CPUTIME_SYSTEM];\n\t\tidle\t\t+= get_idle_time(&kcpustat, i);\n\t\tiowait\t\t+= get_iowait_time(&kcpustat, i);\n\t\tirq\t\t+= cpustat[CPUTIME_IRQ];\n\t\tsoftirq\t\t+= cpustat[CPUTIME_SOFTIRQ];\n\t\tsteal\t\t+= cpustat[CPUTIME_STEAL];\n\t\tguest\t\t+= cpustat[CPUTIME_GUEST];\n\t\tguest_nice\t+= cpustat[CPUTIME_GUEST_NICE];\n\t\tsum\t\t+= kstat_cpu_irqs_sum(i);\n\t\tsum\t\t+= arch_irq_stat_cpu(i);\n\n\t\tfor (j = 0; j < NR_SOFTIRQS; j++) {\n\t\t\tunsigned int softirq_stat = kstat_softirqs_cpu(j, i);\n\n\t\t\tper_softirq_sums[j] += softirq_stat;\n\t\t\tsum_softirq += softirq_stat;\n\t\t}\n\t}\n\tsum += arch_irq_stat();\n\n\tseq_put_decimal_ull(p, \"cpu  \", nsec_to_clock_t(user));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(nice));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(system));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(idle));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(iowait));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(irq));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(softirq));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(steal));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(guest));\n\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(guest_nice));\n\tseq_putc(p, '\\n');\n\n\tfor_each_online_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\t \n\t\tuser\t\t= cpustat[CPUTIME_USER];\n\t\tnice\t\t= cpustat[CPUTIME_NICE];\n\t\tsystem\t\t= cpustat[CPUTIME_SYSTEM];\n\t\tidle\t\t= get_idle_time(&kcpustat, i);\n\t\tiowait\t\t= get_iowait_time(&kcpustat, i);\n\t\tirq\t\t= cpustat[CPUTIME_IRQ];\n\t\tsoftirq\t\t= cpustat[CPUTIME_SOFTIRQ];\n\t\tsteal\t\t= cpustat[CPUTIME_STEAL];\n\t\tguest\t\t= cpustat[CPUTIME_GUEST];\n\t\tguest_nice\t= cpustat[CPUTIME_GUEST_NICE];\n\t\tseq_printf(p, \"cpu%d\", i);\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(user));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(nice));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(system));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(idle));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(iowait));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(irq));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(softirq));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(steal));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(guest));\n\t\tseq_put_decimal_ull(p, \" \", nsec_to_clock_t(guest_nice));\n\t\tseq_putc(p, '\\n');\n\t}\n\tseq_put_decimal_ull(p, \"intr \", (unsigned long long)sum);\n\n\tshow_all_irqs(p);\n\n\tseq_printf(p,\n\t\t\"\\nctxt %llu\\n\"\n\t\t\"btime %llu\\n\"\n\t\t\"processes %lu\\n\"\n\t\t\"procs_running %u\\n\"\n\t\t\"procs_blocked %u\\n\",\n\t\tnr_context_switches(),\n\t\t(unsigned long long)boottime.tv_sec,\n\t\ttotal_forks,\n\t\tnr_running(),\n\t\tnr_iowait());\n\n\tseq_put_decimal_ull(p, \"softirq \", (unsigned long long)sum_softirq);\n\n\tfor (i = 0; i < NR_SOFTIRQS; i++)\n\t\tseq_put_decimal_ull(p, \" \", per_softirq_sums[i]);\n\tseq_putc(p, '\\n');\n\n\treturn 0;\n}\n\nstatic int stat_open(struct inode *inode, struct file *file)\n{\n\tunsigned int size = 1024 + 128 * num_online_cpus();\n\n\t \n\tsize += 2 * nr_irqs;\n\treturn single_open_size(file, show_stat, NULL, size);\n}\n\nstatic const struct proc_ops stat_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_open\t= stat_open,\n\t.proc_read_iter\t= seq_read_iter,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstatic int __init proc_stat_init(void)\n{\n\tproc_create(\"stat\", 0, NULL, &stat_proc_ops);\n\treturn 0;\n}\nfs_initcall(proc_stat_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}