{
  "module_name": "namespaces.c",
  "hash_id": "0641f5370a7283a963611d8a92fa61d6bf0b1376941e41aa6d1a5ee7f6e7ebfd",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/namespaces.c",
  "human_readable_source": "\n#include <linux/proc_fs.h>\n#include <linux/nsproxy.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/utsname.h>\n#include <net/net_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include \"internal.h\"\n\n\nstatic const struct proc_ns_operations *ns_entries[] = {\n#ifdef CONFIG_NET_NS\n\t&netns_operations,\n#endif\n#ifdef CONFIG_UTS_NS\n\t&utsns_operations,\n#endif\n#ifdef CONFIG_IPC_NS\n\t&ipcns_operations,\n#endif\n#ifdef CONFIG_PID_NS\n\t&pidns_operations,\n\t&pidns_for_children_operations,\n#endif\n#ifdef CONFIG_USER_NS\n\t&userns_operations,\n#endif\n\t&mntns_operations,\n#ifdef CONFIG_CGROUPS\n\t&cgroupns_operations,\n#endif\n#ifdef CONFIG_TIME_NS\n\t&timens_operations,\n\t&timens_for_children_operations,\n#endif\n};\n\nstatic const char *proc_ns_get_link(struct dentry *dentry,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    struct delayed_call *done)\n{\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tstruct path ns_path;\n\tint error = -EACCES;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out;\n\n\terror = ns_get_path(&ns_path, task, ns_ops);\n\tif (error)\n\t\tgoto out;\n\n\terror = nd_jump_link(&ns_path);\nout:\n\tput_task_struct(task);\n\treturn ERR_PTR(error);\n}\n\nstatic int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns_ops;\n\tstruct task_struct *task;\n\tchar name[50];\n\tint res = -EACCES;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn res;\n\n\tif (ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {\n\t\tres = ns_get_name(name, sizeof(name), task, ns_ops);\n\t\tif (res >= 0)\n\t\t\tres = readlink_copy(buffer, buflen, name);\n\t}\n\tput_task_struct(task);\n\treturn res;\n}\n\nstatic const struct inode_operations proc_ns_link_inode_operations = {\n\t.readlink\t= proc_ns_readlink,\n\t.get_link\t= proc_ns_get_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_ns_instantiate(struct dentry *dentry,\n\tstruct task_struct *task, const void *ptr)\n{\n\tconst struct proc_ns_operations *ns_ops = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dentry->d_sb, task, S_IFLNK | S_IRWXUGO);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tei = PROC_I(inode);\n\tinode->i_op = &proc_ns_link_inode_operations;\n\tei->ns_ops = ns_ops;\n\tpid_update_inode(task, inode);\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct proc_ns_operations **entry, **last;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tif (ctx->pos >= 2 + ARRAY_SIZE(ns_entries))\n\t\tgoto out;\n\tentry = ns_entries + (ctx->pos - 2);\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\n\twhile (entry <= last) {\n\t\tconst struct proc_ns_operations *ops = *entry;\n\t\tif (!proc_fill_cache(file, ctx, ops->name, strlen(ops->name),\n\t\t\t\t     proc_ns_instantiate, task, ops))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t\tentry++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}\n\nconst struct file_operations proc_ns_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_ns_dir_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic struct dentry *proc_ns_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct proc_ns_operations **entry, **last;\n\tunsigned int len = dentry->d_name.len;\n\tstruct dentry *res = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tlast = &ns_entries[ARRAY_SIZE(ns_entries)];\n\tfor (entry = ns_entries; entry < last; entry++) {\n\t\tif (strlen((*entry)->name) != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, (*entry)->name, len))\n\t\t\tbreak;\n\t}\n\tif (entry == last)\n\t\tgoto out;\n\n\tres = proc_ns_instantiate(dentry, task, *entry);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn res;\n}\n\nconst struct inode_operations proc_ns_dir_inode_operations = {\n\t.lookup\t\t= proc_ns_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}