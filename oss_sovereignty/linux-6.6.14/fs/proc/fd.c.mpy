{
  "module_name": "fd.c",
  "hash_id": "8d7b809ad219e89b27c9f4d3f556756b80272102f29bc9d2295b17f2873139ca",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/fd.c",
  "human_readable_source": "\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/dcache.h>\n#include <linux/path.h>\n#include <linux/fdtable.h>\n#include <linux/namei.h>\n#include <linux/pid.h>\n#include <linux/ptrace.h>\n#include <linux/bitmap.h>\n#include <linux/security.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n\n#include <linux/proc_fs.h>\n\n#include \"../mount.h\"\n#include \"internal.h\"\n#include \"fd.h\"\n\nstatic int seq_show(struct seq_file *m, void *v)\n{\n\tstruct files_struct *files = NULL;\n\tint f_flags = 0, ret = -ENOENT;\n\tstruct file *file = NULL;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(m->private);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files) {\n\t\tunsigned int fd = proc_fd(m->private);\n\n\t\tspin_lock(&files->file_lock);\n\t\tfile = files_lookup_fd_locked(files, fd);\n\t\tif (file) {\n\t\t\tstruct fdtable *fdt = files_fdtable(files);\n\n\t\t\tf_flags = file->f_flags;\n\t\t\tif (close_on_exec(fd, fdt))\n\t\t\t\tf_flags |= O_CLOEXEC;\n\n\t\t\tget_file(file);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t}\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\nino:\\t%lu\\n\",\n\t\t   (long long)file->f_pos, f_flags,\n\t\t   real_mount(file->f_path.mnt)->mnt_id,\n\t\t   file_inode(file)->i_ino);\n\n\t \n\tshow_fd_locks(m, file, files);\n\tif (seq_has_overflowed(m))\n\t\tgoto out;\n\n\tif (file->f_op->show_fdinfo)\n\t\tfile->f_op->show_fdinfo(m, file);\n\nout:\n\tfput(file);\n\treturn 0;\n}\n\nstatic int proc_fdinfo_access_allowed(struct inode *inode)\n{\n\tbool allowed = false;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tallowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n\tput_task_struct(task);\n\n\tif (!allowed)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int seq_fdinfo_open(struct inode *inode, struct file *file)\n{\n\tint ret = proc_fdinfo_access_allowed(inode);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn single_open(file, seq_show, inode);\n}\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= seq_fdinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic bool tid_fd_mode(struct task_struct *task, unsigned fd, fmode_t *mode)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, fd);\n\tif (file)\n\t\t*mode = file->f_mode;\n\trcu_read_unlock();\n\treturn !!file;\n}\n\nstatic void tid_fd_update_inode(struct task_struct *task, struct inode *inode,\n\t\t\t\tfmode_t f_mode)\n{\n\ttask_dump_owner(task, 0, &inode->i_uid, &inode->i_gid);\n\n\tif (S_ISLNK(inode->i_mode)) {\n\t\tunsigned i_mode = S_IFLNK;\n\t\tif (f_mode & FMODE_READ)\n\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\tif (f_mode & FMODE_WRITE)\n\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\tinode->i_mode = i_mode;\n\t}\n\tsecurity_task_to_inode(task, inode);\n}\n\nstatic int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct task_struct *task;\n\tstruct inode *inode;\n\tunsigned int fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfmode_t f_mode;\n\t\tif (tid_fd_mode(task, fd, &f_mode)) {\n\t\t\ttid_fd_update_inode(task, inode, f_mode);\n\t\t\tput_task_struct(task);\n\t\t\treturn 1;\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}\n\nstatic const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int proc_fd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task;\n\tint ret = -ENOENT;\n\n\ttask = get_proc_task(d_inode(dentry));\n\tif (task) {\n\t\tunsigned int fd = proc_fd(d_inode(dentry));\n\t\tstruct file *fd_file;\n\n\t\tfd_file = fget_task(task, fd);\n\t\tif (fd_file) {\n\t\t\t*path = fd_file->f_path;\n\t\t\tpath_get(&fd_file->f_path);\n\t\t\tret = 0;\n\t\t\tfput(fd_file);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\n\treturn ret;\n}\n\nstruct fd_data {\n\tfmode_t mode;\n\tunsigned fd;\n};\n\nstatic struct dentry *proc_fd_instantiate(struct dentry *dentry,\n\tstruct task_struct *task, const void *ptr)\n{\n\tconst struct fd_data *data = ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dentry->d_sb, task, S_IFLNK);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tei = PROC_I(inode);\n\tei->fd = data->fd;\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\n\tei->op.proc_get_link = proc_fd_link;\n\ttid_fd_update_inode(task, inode, data->mode);\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tstruct fd_data data = {.fd = name_to_int(&dentry->d_name)};\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (data.fd == ~0U)\n\t\tgoto out;\n\tif (!tid_fd_mode(task, data.fd, &data.mode))\n\t\tgoto out;\n\n\tresult = instantiate(dentry, task, &data);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn result;\n}\n\nstatic int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;; fd++) {\n\t\tstruct file *f;\n\t\tstruct fd_data data;\n\t\tchar name[10 + 1];\n\t\tunsigned int len;\n\n\t\tf = task_lookup_next_fd_rcu(p, &fd);\n\t\tctx->pos = fd + 2LL;\n\t\tif (!f)\n\t\t\tbreak;\n\t\tdata.mode = f->f_mode;\n\t\trcu_read_unlock();\n\t\tdata.fd = fd;\n\n\t\tlen = snprintf(name, sizeof(name), \"%u\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     &data))\n\t\t\tgoto out;\n\t\tcond_resched();\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout:\n\tput_task_struct(p);\n\treturn 0;\n}\n\nstatic int proc_readfd_count(struct inode *inode, loff_t *count)\n{\n\tstruct task_struct *p = get_proc_task(inode);\n\tstruct fdtable *fdt;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\ttask_lock(p);\n\tif (p->files) {\n\t\trcu_read_lock();\n\n\t\tfdt = files_fdtable(p->files);\n\t\t*count = bitmap_weight(fdt->open_fds, fdt->max_fds);\n\n\t\trcu_read_unlock();\n\t}\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int proc_readfd(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx, proc_fd_instantiate);\n}\n\nconst struct file_operations proc_fd_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_readfd,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}\n\n \nint proc_fd_permission(struct mnt_idmap *idmap,\n\t\t       struct inode *inode, int mask)\n{\n\tstruct task_struct *p;\n\tint rv;\n\n\trv = generic_permission(&nop_mnt_idmap, inode, mask);\n\tif (rv == 0)\n\t\treturn rv;\n\n\trcu_read_lock();\n\tp = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (p && same_thread_group(p, current))\n\t\trv = 0;\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\nstatic int proc_fd_getattr(struct mnt_idmap *idmap,\n\t\t\tconst struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tint rv = 0;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\trv = proc_readfd_count(inode, &stat->size);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t}\n\n\treturn rv;\n}\n\nconst struct inode_operations proc_fd_inode_operations = {\n\t.lookup\t\t= proc_lookupfd,\n\t.permission\t= proc_fd_permission,\n\t.getattr\t= proc_fd_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_fdinfo_instantiate(struct dentry *dentry,\n\tstruct task_struct *task, const void *ptr)\n{\n\tconst struct fd_data *data = ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dentry->d_sb, task, S_IFREG | S_IRUGO);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tei = PROC_I(inode);\n\tei->fd = data->fd;\n\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\ttid_fd_update_inode(task, inode, 0);\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct dentry *\nproc_lookupfdinfo(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}\n\nstatic int proc_readfdinfo(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx,\n\t\t\t\t  proc_fdinfo_instantiate);\n}\n\nstatic int proc_open_fdinfo(struct inode *inode, struct file *file)\n{\n\tint ret = proc_fdinfo_access_allowed(inode);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nconst struct inode_operations proc_fdinfo_inode_operations = {\n\t.lookup\t\t= proc_lookupfdinfo,\n\t.setattr\t= proc_setattr,\n};\n\nconst struct file_operations proc_fdinfo_operations = {\n\t.open\t\t= proc_open_fdinfo,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_readfdinfo,\n\t.llseek\t\t= generic_file_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}