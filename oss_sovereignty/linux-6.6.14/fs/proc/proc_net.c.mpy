{
  "module_name": "proc_net.c",
  "hash_id": "b80c476e3d528c2caa4aa7720cd3211d7bf4547bf23f77058cb1a5be43afbdb1",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/proc_net.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/nsproxy.h>\n#include <linux/uidgid.h>\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n\n#include \"internal.h\"\n\nstatic inline struct net *PDE_NET(struct proc_dir_entry *pde)\n{\n\treturn pde->parent->data;\n}\n\nstatic struct net *get_proc_net(const struct inode *inode)\n{\n\treturn maybe_get_net(PDE_NET(PDE(inode)));\n}\n\nstatic int seq_open_net(struct inode *inode, struct file *file)\n{\n\tunsigned int state_size = PDE(inode)->state_size;\n\tstruct seq_net_private *p;\n\tstruct net *net;\n\n\tWARN_ON_ONCE(state_size < sizeof(*p));\n\n\tif (file->f_mode & FMODE_WRITE && !PDE(inode)->write)\n\t\treturn -EACCES;\n\n\tnet = get_proc_net(inode);\n\tif (!net)\n\t\treturn -ENXIO;\n\n\tp = __seq_open_private(file, PDE(inode)->seq_ops, state_size);\n\tif (!p) {\n\t\tput_net(net);\n\t\treturn -ENOMEM;\n\t}\n#ifdef CONFIG_NET_NS\n\tp->net = net;\n\tnetns_tracker_alloc(net, &p->ns_tracker, GFP_KERNEL);\n#endif\n\treturn 0;\n}\n\nstatic void seq_file_net_put_net(struct seq_file *seq)\n{\n#ifdef CONFIG_NET_NS\n\tstruct seq_net_private *priv = seq->private;\n\n\tput_net_track(priv->net, &priv->ns_tracker);\n#else\n\tput_net(&init_net);\n#endif\n}\n\nstatic int seq_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq = f->private_data;\n\n\tseq_file_net_put_net(seq);\n\tseq_release_private(ino, f);\n\treturn 0;\n}\n\nstatic const struct proc_ops proc_net_seq_ops = {\n\t.proc_open\t= seq_open_net,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= proc_simple_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_net,\n};\n\nint bpf_iter_init_seq_net(void *priv_data, struct bpf_iter_aux_info *aux)\n{\n#ifdef CONFIG_NET_NS\n\tstruct seq_net_private *p = priv_data;\n\n\tp->net = get_net_track(current->nsproxy->net_ns, &p->ns_tracker,\n\t\t\t       GFP_KERNEL);\n#endif\n\treturn 0;\n}\n\nvoid bpf_iter_fini_seq_net(void *priv_data)\n{\n#ifdef CONFIG_NET_NS\n\tstruct seq_net_private *p = priv_data;\n\n\tput_net_track(p->net, &p->ns_tracker);\n#endif\n}\n\nstruct proc_dir_entry *proc_create_net_data(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, const struct seq_operations *ops,\n\t\tunsigned int state_size, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tpde_force_lookup(p);\n\tp->proc_ops = &proc_net_seq_ops;\n\tp->seq_ops = ops;\n\tp->state_size = state_size;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL_GPL(proc_create_net_data);\n\n \nstruct proc_dir_entry *proc_create_net_data_write(const char *name, umode_t mode,\n\t\t\t\t\t\t  struct proc_dir_entry *parent,\n\t\t\t\t\t\t  const struct seq_operations *ops,\n\t\t\t\t\t\t  proc_write_t write,\n\t\t\t\t\t\t  unsigned int state_size, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tpde_force_lookup(p);\n\tp->proc_ops = &proc_net_seq_ops;\n\tp->seq_ops = ops;\n\tp->state_size = state_size;\n\tp->write = write;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL_GPL(proc_create_net_data_write);\n\nstatic int single_open_net(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *de = PDE(inode);\n\tstruct net *net;\n\tint err;\n\n\tnet = get_proc_net(inode);\n\tif (!net)\n\t\treturn -ENXIO;\n\n\terr = single_open(file, de->single_show, net);\n\tif (err)\n\t\tput_net(net);\n\treturn err;\n}\n\nstatic int single_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq = f->private_data;\n\tput_net(seq->private);\n\treturn single_release(ino, f);\n}\n\nstatic const struct proc_ops proc_net_single_ops = {\n\t.proc_open\t= single_open_net,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= proc_simple_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release_net,\n};\n\nstruct proc_dir_entry *proc_create_net_single(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent,\n\t\tint (*show)(struct seq_file *, void *), void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tpde_force_lookup(p);\n\tp->proc_ops = &proc_net_single_ops;\n\tp->single_show = show;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL_GPL(proc_create_net_single);\n\n \nstruct proc_dir_entry *proc_create_net_single_write(const char *name, umode_t mode,\n\t\t\t\t\t\t    struct proc_dir_entry *parent,\n\t\t\t\t\t\t    int (*show)(struct seq_file *, void *),\n\t\t\t\t\t\t    proc_write_t write,\n\t\t\t\t\t\t    void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tpde_force_lookup(p);\n\tp->proc_ops = &proc_net_single_ops;\n\tp->single_show = show;\n\tp->write = write;\n\treturn proc_register(parent, p);\n}\nEXPORT_SYMBOL_GPL(proc_create_net_single_write);\n\nstatic struct net *get_proc_task_net(struct inode *dir)\n{\n\tstruct task_struct *task;\n\tstruct nsproxy *ns;\n\tstruct net *net = NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(dir), PIDTYPE_PID);\n\tif (task != NULL) {\n\t\ttask_lock(task);\n\t\tns = task->nsproxy;\n\t\tif (ns != NULL)\n\t\t\tnet = get_net(ns->net_ns);\n\t\ttask_unlock(task);\n\t}\n\trcu_read_unlock();\n\n\treturn net;\n}\n\nstatic struct dentry *proc_tgid_net_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *de;\n\tstruct net *net;\n\n\tde = ERR_PTR(-ENOENT);\n\tnet = get_proc_task_net(dir);\n\tif (net != NULL) {\n\t\tde = proc_lookup_de(dir, dentry, net->proc_net);\n\t\tput_net(net);\n\t}\n\treturn de;\n}\n\nstatic int proc_tgid_net_getattr(struct mnt_idmap *idmap,\n\t\t\t\t const struct path *path, struct kstat *stat,\n\t\t\t\t u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct net *net;\n\n\tnet = get_proc_task_net(inode);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\tif (net != NULL) {\n\t\tstat->nlink = net->proc_net->nlink;\n\t\tput_net(net);\n\t}\n\n\treturn 0;\n}\n\nconst struct inode_operations proc_net_inode_operations = {\n\t.lookup\t\t= proc_tgid_net_lookup,\n\t.getattr\t= proc_tgid_net_getattr,\n\t.setattr        = proc_setattr,\n};\n\nstatic int proc_tgid_net_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint ret;\n\tstruct net *net;\n\n\tret = -EINVAL;\n\tnet = get_proc_task_net(file_inode(file));\n\tif (net != NULL) {\n\t\tret = proc_readdir_de(file, ctx, net->proc_net);\n\t\tput_net(net);\n\t}\n\treturn ret;\n}\n\nconst struct file_operations proc_net_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_tgid_net_readdir,\n};\n\nstatic __net_init int proc_net_ns_init(struct net *net)\n{\n\tstruct proc_dir_entry *netd, *net_statd;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint err;\n\n\t \n\terr = -ENOMEM;\n\tnetd = kmem_cache_zalloc(proc_dir_entry_cache, GFP_KERNEL);\n\tif (!netd)\n\t\tgoto out;\n\n\tnetd->subdir = RB_ROOT;\n\tnetd->data = net;\n\tnetd->nlink = 2;\n\tnetd->namelen = 3;\n\tnetd->parent = &proc_root;\n\tnetd->name = netd->inline_name;\n\tmemcpy(netd->name, \"net\", 4);\n\n\tuid = make_kuid(net->user_ns, 0);\n\tif (!uid_valid(uid))\n\t\tuid = netd->uid;\n\n\tgid = make_kgid(net->user_ns, 0);\n\tif (!gid_valid(gid))\n\t\tgid = netd->gid;\n\n\tproc_set_user(netd, uid, gid);\n\n\t \n\tpde_force_lookup(netd);\n\n\terr = -EEXIST;\n\tnet_statd = proc_net_mkdir(net, \"stat\", netd);\n\tif (!net_statd)\n\t\tgoto free_net;\n\n\tnet->proc_net = netd;\n\tnet->proc_net_stat = net_statd;\n\treturn 0;\n\nfree_net:\n\tpde_free(netd);\nout:\n\treturn err;\n}\n\nstatic __net_exit void proc_net_ns_exit(struct net *net)\n{\n\tremove_proc_entry(\"stat\", net->proc_net);\n\tpde_free(net->proc_net);\n}\n\nstatic struct pernet_operations __net_initdata proc_net_ns_ops = {\n\t.init = proc_net_ns_init,\n\t.exit = proc_net_ns_exit,\n};\n\nint __init proc_net_init(void)\n{\n\tproc_symlink(\"net\", NULL, \"self/net\");\n\n\treturn register_pernet_subsys(&proc_net_ns_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}