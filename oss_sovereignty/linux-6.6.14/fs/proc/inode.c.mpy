{
  "module_name": "inode.c",
  "hash_id": "6d142cdd828d6006ef66c23166b9177b725b9611aa82346e4a10413ef3e6fc64",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/inode.c",
  "human_readable_source": "\n \n\n#include <linux/cache.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/pid_namespace.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/completion.h>\n#include <linux/poll.h>\n#include <linux/printk.h>\n#include <linux/file.h>\n#include <linux/limits.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/bug.h>\n\n#include \"internal.h\"\n\nstatic void proc_evict_inode(struct inode *inode)\n{\n\tstruct proc_dir_entry *de;\n\tstruct ctl_table_header *head;\n\tstruct proc_inode *ei = PROC_I(inode);\n\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\t \n\tif (ei->pid) {\n\t\tproc_pid_evict_inode(ei);\n\t\tei->pid = NULL;\n\t}\n\n\t \n\tde = ei->pde;\n\tif (de) {\n\t\tpde_put(de);\n\t\tei->pde = NULL;\n\t}\n\n\thead = ei->sysctl;\n\tif (head) {\n\t\tRCU_INIT_POINTER(ei->sysctl, NULL);\n\t\tproc_sys_evict_inode(inode, head);\n\t}\n}\n\nstatic struct kmem_cache *proc_inode_cachep __ro_after_init;\nstatic struct kmem_cache *pde_opener_cache __ro_after_init;\n\nstatic struct inode *proc_alloc_inode(struct super_block *sb)\n{\n\tstruct proc_inode *ei;\n\n\tei = alloc_inode_sb(sb, proc_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->pid = NULL;\n\tei->fd = 0;\n\tei->op.proc_get_link = NULL;\n\tei->pde = NULL;\n\tei->sysctl = NULL;\n\tei->sysctl_entry = NULL;\n\tINIT_HLIST_NODE(&ei->sibling_inodes);\n\tei->ns_ops = NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void proc_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(proc_inode_cachep, PROC_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct proc_inode *ei = (struct proc_inode *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nvoid __init proc_init_kmemcache(void)\n{\n\tproc_inode_cachep = kmem_cache_create(\"proc_inode_cache\",\n\t\t\t\t\t     sizeof(struct proc_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT|\n\t\t\t\t\t\tSLAB_PANIC),\n\t\t\t\t\t     init_once);\n\tpde_opener_cache =\n\t\tkmem_cache_create(\"pde_opener\", sizeof(struct pde_opener), 0,\n\t\t\t\t  SLAB_ACCOUNT|SLAB_PANIC, NULL);\n\tproc_dir_entry_cache = kmem_cache_create_usercopy(\n\t\t\"proc_dir_entry\", SIZEOF_PDE, 0, SLAB_PANIC,\n\t\toffsetof(struct proc_dir_entry, inline_name),\n\t\tSIZEOF_PDE_INLINE_NAME, NULL);\n\tBUILD_BUG_ON(sizeof(struct proc_dir_entry) >= SIZEOF_PDE);\n}\n\nvoid proc_invalidate_siblings_dcache(struct hlist_head *inodes, spinlock_t *lock)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct hlist_node *node;\n\tstruct super_block *old_sb = NULL;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tstruct super_block *sb;\n\t\tnode = hlist_first_rcu(inodes);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tei = hlist_entry(node, struct proc_inode, sibling_inodes);\n\t\tspin_lock(lock);\n\t\thlist_del_init_rcu(&ei->sibling_inodes);\n\t\tspin_unlock(lock);\n\n\t\tinode = &ei->vfs_inode;\n\t\tsb = inode->i_sb;\n\t\tif ((sb != old_sb) && !atomic_inc_not_zero(&sb->s_active))\n\t\t\tcontinue;\n\t\tinode = igrab(inode);\n\t\trcu_read_unlock();\n\t\tif (sb != old_sb) {\n\t\t\tif (old_sb)\n\t\t\t\tdeactivate_super(old_sb);\n\t\t\told_sb = sb;\n\t\t}\n\t\tif (unlikely(!inode)) {\n\t\t\trcu_read_lock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tstruct dentry *dir = d_find_any_alias(inode);\n\t\t\tif (dir) {\n\t\t\t\td_invalidate(dir);\n\t\t\t\tdput(dir);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct dentry *dentry;\n\t\t\twhile ((dentry = d_find_alias(inode))) {\n\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t}\n\t\tiput(inode);\n\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n\tif (old_sb)\n\t\tdeactivate_super(old_sb);\n}\n\nstatic inline const char *hidepid2str(enum proc_hidepid v)\n{\n\tswitch (v) {\n\t\tcase HIDEPID_OFF: return \"off\";\n\t\tcase HIDEPID_NO_ACCESS: return \"noaccess\";\n\t\tcase HIDEPID_INVISIBLE: return \"invisible\";\n\t\tcase HIDEPID_NOT_PTRACEABLE: return \"ptraceable\";\n\t}\n\tWARN_ONCE(1, \"bad hide_pid value: %d\\n\", v);\n\treturn \"unknown\";\n}\n\nstatic int proc_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct proc_fs_info *fs_info = proc_sb_info(root->d_sb);\n\n\tif (!gid_eq(fs_info->pid_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid_munged(&init_user_ns, fs_info->pid_gid));\n\tif (fs_info->hide_pid != HIDEPID_OFF)\n\t\tseq_printf(seq, \",hidepid=%s\", hidepid2str(fs_info->hide_pid));\n\tif (fs_info->pidonly != PROC_PIDONLY_OFF)\n\t\tseq_printf(seq, \",subset=pid\");\n\n\treturn 0;\n}\n\nconst struct super_operations proc_sops = {\n\t.alloc_inode\t= proc_alloc_inode,\n\t.free_inode\t= proc_free_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= proc_evict_inode,\n\t.statfs\t\t= simple_statfs,\n\t.show_options\t= proc_show_options,\n};\n\nenum {BIAS = -1U<<31};\n\nstatic inline int use_pde(struct proc_dir_entry *pde)\n{\n\treturn likely(atomic_inc_unless_negative(&pde->in_use));\n}\n\nstatic void unuse_pde(struct proc_dir_entry *pde)\n{\n\tif (unlikely(atomic_dec_return(&pde->in_use) == BIAS))\n\t\tcomplete(pde->pde_unload_completion);\n}\n\n \nstatic void close_pdeo(struct proc_dir_entry *pde, struct pde_opener *pdeo)\n\t__releases(&pde->pde_unload_lock)\n{\n\t \n\tif (pdeo->closing) {\n\t\t \n\t\tDECLARE_COMPLETION_ONSTACK(c);\n\t\tpdeo->c = &c;\n\t\tspin_unlock(&pde->pde_unload_lock);\n\t\twait_for_completion(&c);\n\t} else {\n\t\tstruct file *file;\n\t\tstruct completion *c;\n\n\t\tpdeo->closing = true;\n\t\tspin_unlock(&pde->pde_unload_lock);\n\n\t\tfile = pdeo->file;\n\t\tpde->proc_ops->proc_release(file_inode(file), file);\n\n\t\tspin_lock(&pde->pde_unload_lock);\n\t\t \n\t\tlist_del(&pdeo->lh);\n\t\tc = pdeo->c;\n\t\tspin_unlock(&pde->pde_unload_lock);\n\t\tif (unlikely(c))\n\t\t\tcomplete(c);\n\t\tkmem_cache_free(pde_opener_cache, pdeo);\n\t}\n}\n\nvoid proc_entry_rundown(struct proc_dir_entry *de)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\t \n\tde->pde_unload_completion = &c;\n\tif (atomic_add_return(BIAS, &de->in_use) != BIAS)\n\t\twait_for_completion(&c);\n\n\t \n\n\tspin_lock(&de->pde_unload_lock);\n\twhile (!list_empty(&de->pde_openers)) {\n\t\tstruct pde_opener *pdeo;\n\t\tpdeo = list_first_entry(&de->pde_openers, struct pde_opener, lh);\n\t\tclose_pdeo(de, pdeo);\n\t\tspin_lock(&de->pde_unload_lock);\n\t}\n\tspin_unlock(&de->pde_unload_lock);\n}\n\nstatic loff_t proc_reg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tloff_t rv = -EINVAL;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde->proc_ops->proc_lseek(file, offset, whence);\n\t} else if (use_pde(pde)) {\n\t\trv = pde->proc_ops->proc_lseek(file, offset, whence);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(iocb->ki_filp));\n\tssize_t ret;\n\n\tif (pde_is_permanent(pde))\n\t\treturn pde->proc_ops->proc_read_iter(iocb, iter);\n\n\tif (!use_pde(pde))\n\t\treturn -EIO;\n\tret = pde->proc_ops->proc_read_iter(iocb, iter);\n\tunuse_pde(pde);\n\treturn ret;\n}\n\nstatic ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\ttypeof_member(struct proc_ops, proc_read) read;\n\n\tread = pde->proc_ops->proc_read;\n\tif (read)\n\t\treturn read(file, buf, count, ppos);\n\treturn -EIO;\n}\n\nstatic ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tssize_t rv = -EIO;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_read(pde, file, buf, count, ppos);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_read(pde, file, buf, count, ppos);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\ttypeof_member(struct proc_ops, proc_write) write;\n\n\twrite = pde->proc_ops->proc_write;\n\tif (write)\n\t\treturn write(file, buf, count, ppos);\n\treturn -EIO;\n}\n\nstatic ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tssize_t rv = -EIO;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_write(pde, file, buf, count, ppos);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_write(pde, file, buf, count, ppos);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n{\n\ttypeof_member(struct proc_ops, proc_poll) poll;\n\n\tpoll = pde->proc_ops->proc_poll;\n\tif (poll)\n\t\treturn poll(file, pts);\n\treturn DEFAULT_POLLMASK;\n}\n\nstatic __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\t__poll_t rv = DEFAULT_POLLMASK;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_poll(pde, file, pts);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_poll(pde, file, pts);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\ttypeof_member(struct proc_ops, proc_ioctl) ioctl;\n\n\tioctl = pde->proc_ops->proc_ioctl;\n\tif (ioctl)\n\t\treturn ioctl(file, cmd, arg);\n\treturn -ENOTTY;\n}\n\nstatic long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tlong rv = -ENOTTY;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_ioctl(pde, file, cmd, arg);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_ioctl(pde, file, cmd, arg);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\ttypeof_member(struct proc_ops, proc_compat_ioctl) compat_ioctl;\n\n\tcompat_ioctl = pde->proc_ops->proc_compat_ioctl;\n\tif (compat_ioctl)\n\t\treturn compat_ioctl(file, cmd, arg);\n\treturn -ENOTTY;\n}\n\nstatic long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tlong rv = -ENOTTY;\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_compat_ioctl(pde, file, cmd, arg);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_compat_ioctl(pde, file, cmd, arg);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n#endif\n\nstatic int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n{\n\ttypeof_member(struct proc_ops, proc_mmap) mmap;\n\n\tmmap = pde->proc_ops->proc_mmap;\n\tif (mmap)\n\t\treturn mmap(file, vma);\n\treturn -EIO;\n}\n\nstatic int proc_reg_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tint rv = -EIO;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_mmap(pde, file, vma);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_mmap(pde, file, vma);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic unsigned long\npde_get_unmapped_area(struct proc_dir_entry *pde, struct file *file, unsigned long orig_addr,\n\t\t\t   unsigned long len, unsigned long pgoff,\n\t\t\t   unsigned long flags)\n{\n\ttypeof_member(struct proc_ops, proc_get_unmapped_area) get_area;\n\n\tget_area = pde->proc_ops->proc_get_unmapped_area;\n#ifdef CONFIG_MMU\n\tif (!get_area)\n\t\tget_area = current->mm->get_unmapped_area;\n#endif\n\tif (get_area)\n\t\treturn get_area(file, orig_addr, len, pgoff, flags);\n\treturn orig_addr;\n}\n\nstatic unsigned long\nproc_reg_get_unmapped_area(struct file *file, unsigned long orig_addr,\n\t\t\t   unsigned long len, unsigned long pgoff,\n\t\t\t   unsigned long flags)\n{\n\tstruct proc_dir_entry *pde = PDE(file_inode(file));\n\tunsigned long rv = -EIO;\n\n\tif (pde_is_permanent(pde)) {\n\t\treturn pde_get_unmapped_area(pde, file, orig_addr, len, pgoff, flags);\n\t} else if (use_pde(pde)) {\n\t\trv = pde_get_unmapped_area(pde, file, orig_addr, len, pgoff, flags);\n\t\tunuse_pde(pde);\n\t}\n\treturn rv;\n}\n\nstatic int proc_reg_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *pde = PDE(inode);\n\tint rv = 0;\n\ttypeof_member(struct proc_ops, proc_open) open;\n\ttypeof_member(struct proc_ops, proc_release) release;\n\tstruct pde_opener *pdeo;\n\n\tif (!pde->proc_ops->proc_lseek)\n\t\tfile->f_mode &= ~FMODE_LSEEK;\n\n\tif (pde_is_permanent(pde)) {\n\t\topen = pde->proc_ops->proc_open;\n\t\tif (open)\n\t\t\trv = open(inode, file);\n\t\treturn rv;\n\t}\n\n\t \n\tif (!use_pde(pde))\n\t\treturn -ENOENT;\n\n\trelease = pde->proc_ops->proc_release;\n\tif (release) {\n\t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n\t\tif (!pdeo) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_unuse;\n\t\t}\n\t}\n\n\topen = pde->proc_ops->proc_open;\n\tif (open)\n\t\trv = open(inode, file);\n\n\tif (release) {\n\t\tif (rv == 0) {\n\t\t\t \n\t\t\tpdeo->file = file;\n\t\t\tpdeo->closing = false;\n\t\t\tpdeo->c = NULL;\n\t\t\tspin_lock(&pde->pde_unload_lock);\n\t\t\tlist_add(&pdeo->lh, &pde->pde_openers);\n\t\t\tspin_unlock(&pde->pde_unload_lock);\n\t\t} else\n\t\t\tkmem_cache_free(pde_opener_cache, pdeo);\n\t}\n\nout_unuse:\n\tunuse_pde(pde);\n\treturn rv;\n}\n\nstatic int proc_reg_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_dir_entry *pde = PDE(inode);\n\tstruct pde_opener *pdeo;\n\n\tif (pde_is_permanent(pde)) {\n\t\ttypeof_member(struct proc_ops, proc_release) release;\n\n\t\trelease = pde->proc_ops->proc_release;\n\t\tif (release) {\n\t\t\treturn release(inode, file);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tspin_lock(&pde->pde_unload_lock);\n\tlist_for_each_entry(pdeo, &pde->pde_openers, lh) {\n\t\tif (pdeo->file == file) {\n\t\t\tclose_pdeo(pde, pdeo);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&pde->pde_unload_lock);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_reg_file_ops = {\n\t.llseek\t\t= proc_reg_llseek,\n\t.read\t\t= proc_reg_read,\n\t.write\t\t= proc_reg_write,\n\t.poll\t\t= proc_reg_poll,\n\t.unlocked_ioctl\t= proc_reg_unlocked_ioctl,\n\t.mmap\t\t= proc_reg_mmap,\n\t.get_unmapped_area = proc_reg_get_unmapped_area,\n\t.open\t\t= proc_reg_open,\n\t.release\t= proc_reg_release,\n};\n\nstatic const struct file_operations proc_iter_file_ops = {\n\t.llseek\t\t= proc_reg_llseek,\n\t.read_iter\t= proc_reg_read_iter,\n\t.write\t\t= proc_reg_write,\n\t.splice_read\t= copy_splice_read,\n\t.poll\t\t= proc_reg_poll,\n\t.unlocked_ioctl\t= proc_reg_unlocked_ioctl,\n\t.mmap\t\t= proc_reg_mmap,\n\t.get_unmapped_area = proc_reg_get_unmapped_area,\n\t.open\t\t= proc_reg_open,\n\t.release\t= proc_reg_release,\n};\n\n#ifdef CONFIG_COMPAT\nstatic const struct file_operations proc_reg_file_ops_compat = {\n\t.llseek\t\t= proc_reg_llseek,\n\t.read\t\t= proc_reg_read,\n\t.write\t\t= proc_reg_write,\n\t.poll\t\t= proc_reg_poll,\n\t.unlocked_ioctl\t= proc_reg_unlocked_ioctl,\n\t.compat_ioctl\t= proc_reg_compat_ioctl,\n\t.mmap\t\t= proc_reg_mmap,\n\t.get_unmapped_area = proc_reg_get_unmapped_area,\n\t.open\t\t= proc_reg_open,\n\t.release\t= proc_reg_release,\n};\n\nstatic const struct file_operations proc_iter_file_ops_compat = {\n\t.llseek\t\t= proc_reg_llseek,\n\t.read_iter\t= proc_reg_read_iter,\n\t.splice_read\t= copy_splice_read,\n\t.write\t\t= proc_reg_write,\n\t.poll\t\t= proc_reg_poll,\n\t.unlocked_ioctl\t= proc_reg_unlocked_ioctl,\n\t.compat_ioctl\t= proc_reg_compat_ioctl,\n\t.mmap\t\t= proc_reg_mmap,\n\t.get_unmapped_area = proc_reg_get_unmapped_area,\n\t.open\t\t= proc_reg_open,\n\t.release\t= proc_reg_release,\n};\n#endif\n\nstatic void proc_put_link(void *p)\n{\n\tunuse_pde(p);\n}\n\nstatic const char *proc_get_link(struct dentry *dentry,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct delayed_call *done)\n{\n\tstruct proc_dir_entry *pde = PDE(inode);\n\tif (!use_pde(pde))\n\t\treturn ERR_PTR(-EINVAL);\n\tset_delayed_call(done, proc_put_link, pde);\n\treturn pde->data;\n}\n\nconst struct inode_operations proc_link_inode_operations = {\n\t.get_link\t= proc_get_link,\n};\n\nstruct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (!inode) {\n\t\tpde_put(de);\n\t\treturn NULL;\n\t}\n\n\tinode->i_private = de->data;\n\tinode->i_ino = de->low_ino;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tPROC_I(inode)->pde = de;\n\tif (is_empty_pde(de)) {\n\t\tmake_empty_dir_inode(inode);\n\t\treturn inode;\n\t}\n\n\tif (de->mode) {\n\t\tinode->i_mode = de->mode;\n\t\tinode->i_uid = de->uid;\n\t\tinode->i_gid = de->gid;\n\t}\n\tif (de->size)\n\t\tinode->i_size = de->size;\n\tif (de->nlink)\n\t\tset_nlink(inode, de->nlink);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = de->proc_iops;\n\t\tif (de->proc_ops->proc_read_iter)\n\t\t\tinode->i_fop = &proc_iter_file_ops;\n\t\telse\n\t\t\tinode->i_fop = &proc_reg_file_ops;\n#ifdef CONFIG_COMPAT\n\t\tif (de->proc_ops->proc_compat_ioctl) {\n\t\t\tif (de->proc_ops->proc_read_iter)\n\t\t\t\tinode->i_fop = &proc_iter_file_ops_compat;\n\t\t\telse\n\t\t\t\tinode->i_fop = &proc_reg_file_ops_compat;\n\t\t}\n#endif\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = de->proc_iops;\n\t\tinode->i_fop = de->proc_dir_ops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = de->proc_iops;\n\t\tinode->i_fop = NULL;\n\t} else {\n\t\tBUG();\n\t}\n\treturn inode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}