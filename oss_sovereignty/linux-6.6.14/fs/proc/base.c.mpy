{
  "module_name": "base.c",
  "hash_id": "ee3f1e1c6ca0ddaefc236c8174bce8466d21d48d2eafb80ef9f9c8660bf3311f",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/base.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/generic-radix-tree.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/printk.h>\n#include <linux/cache.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/posix-timers.h>\n#include <linux/time_namespace.h>\n#include <linux/resctrl.h>\n#include <linux/cn_proc.h>\n#include <linux/ksm.h>\n#include <trace/events/oom.h>\n#include \"internal.h\"\n#include \"fd.h\"\n\n#include \"../../lib/kstrtox.h\"\n\n \n\nstatic u8 nlink_tid __ro_after_init;\nstatic u8 nlink_tgid __ro_after_init;\n\nstruct pid_entry {\n\tconst char *name;\n\tunsigned int len;\n\tumode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)),\t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n#define ATTR(LSM, NAME, MODE)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)),\t\t\t\\\n\t\tNULL, &proc_pid_attr_operations,\t\\\n\t\t{ .lsm = LSM })\n\n \nstatic unsigned int __init pid_entry_nlink(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 2;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(d_inode(dentry));\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\n \nstatic ssize_t get_mm_proctitle(struct mm_struct *mm, char __user *buf,\n\t\t\t\tsize_t count, unsigned long pos,\n\t\t\t\tunsigned long arg_start)\n{\n\tchar *page;\n\tint ret, got;\n\n\tif (pos >= PAGE_SIZE)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tgot = access_remote_vm(mm, arg_start, page, PAGE_SIZE, FOLL_ANON);\n\tif (got > 0) {\n\t\tint len = strnlen(page, got);\n\n\t\t \n\t\tif (len < got)\n\t\t\tlen++;\n\n\t\tif (len > pos) {\n\t\t\tlen -= pos;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tlen -= copy_to_user(buf, page+pos, len);\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tret = len;\n\t\t}\n\t}\n\tfree_page((unsigned long)page);\n\treturn ret;\n}\n\nstatic ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long pos, len;\n\tchar *page, c;\n\n\t \n\tif (!mm->env_end)\n\t\treturn 0;\n\n\tspin_lock(&mm->arg_lock);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tspin_unlock(&mm->arg_lock);\n\n\tif (arg_start >= arg_end)\n\t\treturn 0;\n\n\t \n\tif (env_start != arg_end || env_end < env_start)\n\t\tenv_start = env_end = arg_end;\n\tlen = env_end - arg_start;\n\n\t \n\tpos = *ppos;\n\tif (pos >= len)\n\t\treturn 0;\n\tif (count > len - pos)\n\t\tcount = len - pos;\n\tif (!count)\n\t\treturn 0;\n\n\t \n\tif (access_remote_vm(mm, arg_end-1, &c, 1, FOLL_ANON) == 1 && c)\n\t\treturn get_mm_proctitle(mm, buf, count, pos, arg_start);\n\n\t \n\tpos += arg_start;\n\tif (pos < arg_start || pos >= arg_end)\n\t\treturn 0;\n\tif (count > arg_end - pos)\n\t\tcount = arg_end - pos;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlen = 0;\n\twhile (count) {\n\t\tint got;\n\t\tsize_t size = min_t(size_t, PAGE_SIZE, count);\n\n\t\tgot = access_remote_vm(mm, pos, page, size, FOLL_ANON);\n\t\tif (got <= 0)\n\t\t\tbreak;\n\t\tgot -= copy_to_user(buf, page, got);\n\t\tif (unlikely(!got)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tpos += got;\n\t\tbuf += got;\n\t\tlen += got;\n\t\tcount -= got;\n\t}\n\n\tfree_page((unsigned long)page);\n\treturn len;\n}\n\nstatic ssize_t get_task_cmdline(struct task_struct *tsk, char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct mm_struct *mm;\n\tssize_t ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tret = get_mm_cmdline(mm, buf, count, pos);\n\tmmput(mm);\n\treturn ret;\n}\n\nstatic ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tssize_t ret;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tret = get_task_cmdline(tsk, buf, count, pos);\n\tput_task_struct(tsk);\n\tif (ret > 0)\n\t\t*pos += ret;\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_cmdline_ops = {\n\t.read\t= proc_pid_cmdline_read,\n\t.llseek\t= generic_file_llseek,\n};\n\n#ifdef CONFIG_KALLSYMS\n \nstatic int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto print0;\n\n\twchan = get_wchan(task);\n\tif (wchan && !lookup_symbol_name(wchan, symname)) {\n\t\tseq_puts(m, symname);\n\t\treturn 0;\n\t}\n\nprint0:\n\tseq_putc(m, '0');\n\treturn 0;\n}\n#endif  \n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = down_read_killable(&task->signal->exec_update_lock);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\tup_read(&task->signal->exec_update_lock);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tup_read(&task->signal->exec_update_lock);\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long *entries;\n\tint err;\n\n\t \n\tif (!file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tentries = kmalloc_array(MAX_STACK_TRACE_DEPTH, sizeof(*entries),\n\t\t\t\tGFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tunsigned int i, nr_entries;\n\n\t\tnr_entries = stack_trace_save_tsk(task, entries,\n\t\t\t\t\t\t  MAX_STACK_TRACE_DEPTH, 0);\n\n\t\tfor (i = 0; i < nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<0>] %pB\\n\", (void *)entries[i]);\n\t\t}\n\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_SCHED_INFO\n \nstatic int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t      struct pid *pid, struct task_struct *task)\n{\n\tif (unlikely(!sched_info_on()))\n\t\tseq_puts(m, \"0 0 0\\n\");\n\telse\n\t\tseq_printf(m, \"%llu %llu %lu\\n\",\n\t\t   (unsigned long long)task->se.sum_exec_runtime,\n\t\t   (unsigned long long)task->sched_info.run_delay,\n\t\t   task->sched_info.pcount);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < LT_SAVECOUNT; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_tsk_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic int proc_oom_score(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long totalpages = totalram_pages() + total_swap_pages;\n\tunsigned long points = 0;\n\tlong badness;\n\n\tbadness = oom_badness(task, totalpages);\n\t \n\tif (badness != LONG_MIN)\n\t\tpoints = (1000 + badness * 1000 / (long)totalpages) * 2 / 3;\n\n\tseq_printf(m, \"%lu\\n\", points);\n\n\treturn 0;\n}\n\nstruct limit_names {\n\tconst char *name;\n\tconst char *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n \nstatic int proc_pid_limits(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t \n\tseq_puts(m, \"Limit                     \"\n\t\t\"Soft Limit           \"\n\t\t\"Hard Limit           \"\n\t\t\"Units     \\n\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-25s %-20s \",\n\t\t\t\t   lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-25s %-20lu \",\n\t\t\t\t   lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-20lu \", rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tseq_printf(m, \"%-10s\\n\", lnames[i].unit);\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\tstruct syscall_info info;\n\tu64 *args = &info.data.args[0];\n\tint res;\n\n\tres = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &info))\n\t\tseq_puts(m, \"running\\n\");\n\telse if (info.data.nr < 0)\n\t\tseq_printf(m, \"%d 0x%llx 0x%llx\\n\",\n\t\t\t   info.data.nr, info.sp, info.data.instruction_pointer);\n\telse\n\t\tseq_printf(m,\n\t\t       \"%d 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx\\n\",\n\t\t       info.data.nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       info.sp, info.data.instruction_pointer);\n\tunlock_trace(task);\n\n\treturn 0;\n}\n#endif  \n\n \n \n \n\n \nstatic bool proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tbool allowed = false;\n\t \n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nint proc_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\treturn 0;\n}\n\n \nstatic bool has_pid_permissions(struct proc_fs_info *fs_info,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t enum proc_hidepid hide_pid_min)\n{\n\t \n\tif (fs_info->hide_pid == HIDEPID_NOT_PTRACEABLE)\n\t\treturn ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n\n\tif (fs_info->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(fs_info->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);\n}\n\n\nstatic int proc_pid_permission(struct mnt_idmap *idmap,\n\t\t\t       struct inode *inode, int mask)\n{\n\tstruct proc_fs_info *fs_info = proc_sb_info(inode->i_sb);\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\thas_perms = has_pid_permissions(fs_info, task, HIDEPID_NO_ACCESS);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (fs_info->hide_pid == HIDEPID_INVISIBLE) {\n\t\t\t \n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\n\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns = proc_pid_ns(inode->i_sb);\n\tstruct pid *pid = proc_pid(inode);\n\tstruct task_struct *task;\n\tint ret;\n\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode | PTRACE_MODE_FSCREDS);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t \n\t\t\tmmgrab(mm);\n\t\t\t \n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}\n\nstatic int mem_open(struct inode *inode, struct file *file)\n{\n\tint ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);\n\n\t \n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\n\treturn ret;\n}\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\tunsigned int flags;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tflags = FOLL_FORCE | (write ? FOLL_WRITE : 0);\n\n\twhile (count > 0) {\n\t\tsize_t this_len = min_t(size_t, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, flags);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}\n\nstatic ssize_t mem_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, buf, count, ppos, 0);\n}\n\nstatic ssize_t mem_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, (char __user*)buf, count, ppos, 1);\n}\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic int mem_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n\t.release\t= mem_release,\n};\n\nstatic int environ_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ);\n}\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t \n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tspin_lock(&mm->arg_lock);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tspin_unlock(&mm->arg_lock);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.open\t\t= environ_open,\n\t.read\t\t= environ_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= mem_release,\n};\n\nstatic int auxv_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ_FSCREDS);\n}\n\nstatic ssize_t auxv_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned int nwords = 0;\n\n\tif (!mm)\n\t\treturn 0;\n\tdo {\n\t\tnwords += 2;\n\t} while (mm->saved_auxv[nwords - 2] != 0);  \n\treturn simple_read_from_buffer(buf, count, ppos, mm->saved_auxv,\n\t\t\t\t       nwords * sizeof(mm->saved_auxv[0]));\n}\n\nstatic const struct file_operations proc_auxv_operations = {\n\t.open\t\t= auxv_open,\n\t.read\t\t= auxv_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= mem_release,\n};\n\nstatic ssize_t oom_adj_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj = OOM_ADJUST_MIN;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MAX)\n\t\toom_adj = OOM_ADJUST_MAX;\n\telse\n\t\toom_adj = (task->signal->oom_score_adj * -OOM_DISABLE) /\n\t\t\t  OOM_SCORE_ADJ_MAX;\n\tput_task_struct(task);\n\tif (oom_adj > OOM_ADJUST_MAX)\n\t\toom_adj = OOM_ADJUST_MAX;\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic int __set_oom_adj(struct file *file, int oom_adj, bool legacy)\n{\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tint err = 0;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tmutex_lock(&oom_adj_mutex);\n\tif (legacy) {\n\t\tif (oom_adj < task->signal->oom_score_adj &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\t \n\t\tpr_warn_once(\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t\t  current->comm, task_pid_nr(current), task_pid_nr(task),\n\t\t\t  task_pid_nr(task));\n\t} else {\n\t\tif ((short)oom_adj < task->signal->oom_score_adj_min &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\t \n\tif (!task->vfork_done) {\n\t\tstruct task_struct *p = find_lock_task_mm(task);\n\n\t\tif (p) {\n\t\t\tif (test_bit(MMF_MULTIPROCESS, &p->mm->flags)) {\n\t\t\t\tmm = p->mm;\n\t\t\t\tmmgrab(mm);\n\t\t\t}\n\t\t\ttask_unlock(p);\n\t\t}\n\t}\n\n\ttask->signal->oom_score_adj = oom_adj;\n\tif (!legacy && has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = (short)oom_adj;\n\ttrace_oom_score_adj_update(task);\n\n\tif (mm) {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p) {\n\t\t\tif (same_thread_group(task, p))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (p->flags & PF_KTHREAD || is_global_init(p))\n\t\t\t\tcontinue;\n\n\t\t\ttask_lock(p);\n\t\t\tif (!p->vfork_done && process_shares_mm(p, mm)) {\n\t\t\t\tp->signal->oom_score_adj = oom_adj;\n\t\t\t\tif (!legacy && has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\t\t\t\tp->signal->oom_score_adj_min = (short)oom_adj;\n\t\t\t}\n\t\t\ttask_unlock(p);\n\t\t}\n\t\trcu_read_unlock();\n\t\tmmdrop(mm);\n\t}\nerr_unlock:\n\tmutex_unlock(&oom_adj_mutex);\n\tput_task_struct(task);\n\treturn err;\n}\n\n \nstatic ssize_t oom_adj_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adj);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adj < OOM_ADJUST_MIN || oom_adj > OOM_ADJUST_MAX) &&\n\t     oom_adj != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (oom_adj == OOM_ADJUST_MAX)\n\t\toom_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\toom_adj = (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;\n\n\terr = __set_oom_adj(file, oom_adj, true);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_adj_operations = {\n\t.read\t\t= oom_adj_read,\n\t.write\t\t= oom_adj_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tshort oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\toom_score_adj = task->signal->oom_score_adj;\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%hd\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar buffer[PROC_NUMBUF];\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = __set_oom_adj(file, oom_score_adj, false);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_score_adj_operations = {\n\t.read\t\t= oom_score_adj_read,\n\t.write\t\t= oom_score_adj_write,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_AUDIT\n#define TMPBUFLEN 11\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task)));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tuid_t loginuid;\n\tkuid_t kloginuid;\n\tint rv;\n\n\t \n\tif (current->flags & PF_KTHREAD)\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (*ppos != 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\trv = kstrtou32_from_user(buf, count, 10, &loginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\n\t \n\tif (loginuid == AUDIT_UID_UNSET) {\n\t\tkloginuid = INVALID_UID;\n\t} else {\n\t\tkloginuid = make_kuid(file->f_cred->user_ns, loginuid);\n\t\tif (!uid_valid(kloginuid))\n\t\t\treturn -EINVAL;\n\t}\n\n\trv = audit_set_loginuid(kloginuid);\n\tif (rv < 0)\n\t\treturn rv;\n\treturn count;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint make_it_fail;\n\tint rv;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 0, &make_it_fail);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (make_it_fail < 0 || make_it_fail > 1)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_fail_nth_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tint err;\n\tunsigned int n;\n\n\terr = kstrtouint_from_user(buf, count, 0, &n);\n\tif (err)\n\t\treturn err;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->fail_nth = n;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic ssize_t proc_fail_nth_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar numbuf[PROC_NUMBUF];\n\tssize_t len;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tlen = snprintf(numbuf, sizeof(numbuf), \"%u\\n\", task->fail_nth);\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, numbuf, len);\n}\n\nstatic const struct file_operations proc_fail_nth_operations = {\n\t.read\t\t= proc_fail_nth_read,\n\t.write\t\t= proc_fail_nth_write,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n \nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns = proc_pid_ns(inode->i_sb);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, ns, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n \nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = proc_sched_autogroup_set_nice(p, nice);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_autogroup_operations = {\n\t.open\t\t= sched_autogroup_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_autogroup_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif  \n\n#ifdef CONFIG_TIME_NS\nstatic int timens_offsets_show(struct seq_file *m, void *v)\n{\n\tstruct task_struct *p;\n\n\tp = get_proc_task(file_inode(m->file));\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_timens_show_offsets(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t timens_offsets_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct proc_timens_offset offsets[2];\n\tchar *kbuf = NULL, *pos, *next_line;\n\tstruct task_struct *p;\n\tint ret, noffsets;\n\n\t \n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t \n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t \n\tret = -EINVAL;\n\tnoffsets = 0;\n\tfor (pos = kbuf; pos; pos = next_line) {\n\t\tstruct proc_timens_offset *off = &offsets[noffsets];\n\t\tchar clock[10];\n\t\tint err;\n\n\t\t \n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\terr = sscanf(pos, \"%9s %lld %lu\", clock,\n\t\t\t\t&off->val.tv_sec, &off->val.tv_nsec);\n\t\tif (err != 3 || off->val.tv_nsec >= NSEC_PER_SEC)\n\t\t\tgoto out;\n\n\t\tclock[sizeof(clock) - 1] = 0;\n\t\tif (strcmp(clock, \"monotonic\") == 0 ||\n\t\t    strcmp(clock, __stringify(CLOCK_MONOTONIC)) == 0)\n\t\t\toff->clockid = CLOCK_MONOTONIC;\n\t\telse if (strcmp(clock, \"boottime\") == 0 ||\n\t\t\t strcmp(clock, __stringify(CLOCK_BOOTTIME)) == 0)\n\t\t\toff->clockid = CLOCK_BOOTTIME;\n\t\telse\n\t\t\tgoto out;\n\n\t\tnoffsets++;\n\t\tif (noffsets == ARRAY_SIZE(offsets)) {\n\t\t\tif (next_line)\n\t\t\t\tcount = next_line - kbuf;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = -ESRCH;\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\tgoto out;\n\tret = proc_timens_set_offset(file, p, offsets, noffsets);\n\tput_task_struct(p);\n\tif (ret)\n\t\tgoto out;\n\n\tret = count;\nout:\n\tkfree(kbuf);\n\treturn ret;\n}\n\nstatic int timens_offsets_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, timens_offsets_show, inode);\n}\n\nstatic const struct file_operations proc_timens_offsets_operations = {\n\t.open\t\t= timens_offsets_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= timens_offsets_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n#endif  \n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\tconst size_t maxlen = sizeof(buffer) - 1;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (copy_from_user(buffer, buf, count > maxlen ? maxlen : count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p)) {\n\t\tset_task_comm(p, buffer);\n\t\tproc_comm_connector(p);\n\t}\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tproc_task_name(m, p, false);\n\tseq_putc(m, '\\n');\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_exe_link(struct dentry *dentry, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\treturn -ENOENT;\n\texe_file = get_task_exe_file(task);\n\tput_task_struct(task);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic const char *proc_pid_get_link(struct dentry *dentry,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct delayed_call *done)\n{\n\tstruct path path;\n\tint error = -EACCES;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\t \n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = nd_jump_link(&path);\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(const struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = kmalloc(PATH_MAX, GFP_KERNEL);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PATH_MAX);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PATH_MAX - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tkfree(tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct path path;\n\n\t \n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nconst struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_pid_get_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n \n\nvoid task_dump_owner(struct task_struct *task, umode_t mode,\n\t\t     kuid_t *ruid, kgid_t *rgid)\n{\n\t \n\tconst struct cred *cred;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (unlikely(task->flags & PF_KTHREAD)) {\n\t\t*ruid = GLOBAL_ROOT_UID;\n\t\t*rgid = GLOBAL_ROOT_GID;\n\t\treturn;\n\t}\n\n\t \n\trcu_read_lock();\n\tcred = __task_cred(task);\n\tuid = cred->euid;\n\tgid = cred->egid;\n\trcu_read_unlock();\n\n\t \n\tif (mode != (S_IFDIR|S_IRUGO|S_IXUGO)) {\n\t\tstruct mm_struct *mm;\n\t\ttask_lock(task);\n\t\tmm = task->mm;\n\t\t \n\t\tif (mm) {\n\t\t\tif (get_dumpable(mm) != SUID_DUMP_USER) {\n\t\t\t\tstruct user_namespace *user_ns = mm->user_ns;\n\n\t\t\t\tuid = make_kuid(user_ns, 0);\n\t\t\t\tif (!uid_valid(uid))\n\t\t\t\t\tuid = GLOBAL_ROOT_UID;\n\n\t\t\t\tgid = make_kgid(user_ns, 0);\n\t\t\t\tif (!gid_valid(gid))\n\t\t\t\t\tgid = GLOBAL_ROOT_GID;\n\t\t\t}\n\t\t} else {\n\t\t\tuid = GLOBAL_ROOT_UID;\n\t\t\tgid = GLOBAL_ROOT_GID;\n\t\t}\n\t\ttask_unlock(task);\n\t}\n\t*ruid = uid;\n\t*rgid = gid;\n}\n\nvoid proc_pid_evict_inode(struct proc_inode *ei)\n{\n\tstruct pid *pid = ei->pid;\n\n\tif (S_ISDIR(ei->vfs_inode.i_mode)) {\n\t\tspin_lock(&pid->lock);\n\t\thlist_del_init_rcu(&ei->sibling_inodes);\n\t\tspin_unlock(&pid->lock);\n\t}\n\n\tput_pid(pid);\n}\n\nstruct inode *proc_pid_make_inode(struct super_block *sb,\n\t\t\t\t  struct task_struct *task, umode_t mode)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tstruct pid *pid;\n\n\t \n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t \n\tei = PROC_I(inode);\n\tinode->i_mode = mode;\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_op = &proc_def_inode_operations;\n\n\t \n\tpid = get_task_pid(task, PIDTYPE_PID);\n\tif (!pid)\n\t\tgoto out_unlock;\n\n\t \n\tei->pid = pid;\n\n\ttask_dump_owner(task, 0, &inode->i_uid, &inode->i_gid);\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\n \nstatic struct inode *proc_pid_make_base_inode(struct super_block *sb,\n\t\t\t\tstruct task_struct *task, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct pid *pid;\n\n\tinode = proc_pid_make_inode(sb, task, mode);\n\tif (!inode)\n\t\treturn NULL;\n\n\t \n\tei = PROC_I(inode);\n\tpid = ei->pid;\n\tspin_lock(&pid->lock);\n\thlist_add_head_rcu(&ei->sibling_inodes, &pid->inodes);\n\tspin_unlock(&pid->lock);\n\n\treturn inode;\n}\n\nint pid_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct proc_fs_info *fs_info = proc_sb_info(inode->i_sb);\n\tstruct task_struct *task;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\tstat->uid = GLOBAL_ROOT_UID;\n\tstat->gid = GLOBAL_ROOT_GID;\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(fs_info, task, HIDEPID_INVISIBLE)) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\treturn -ENOENT;\n\t\t}\n\t\ttask_dump_owner(task, inode->i_mode, &stat->uid, &stat->gid);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n \n\n \nvoid pid_update_inode(struct task_struct *task, struct inode *inode)\n{\n\ttask_dump_owner(task, inode->i_mode, &inode->i_uid, &inode->i_gid);\n\n\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\tsecurity_task_to_inode(task, inode);\n}\n\n \nstatic int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tinode = d_inode_rcu(dentry);\n\tif (!inode)\n\t\tgoto out;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\n\tif (task) {\n\t\tpid_update_inode(task, inode);\n\t\tret = 1;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}\n\nint pid_delete_dentry(const struct dentry *dentry)\n{\n\t \n\treturn proc_inode_is_dead(d_inode(dentry));\n}\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n \n\n \nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, unsigned int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type = DT_UNKNOWN;\n\tino_t ino = 1;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\t\tchild = d_alloc_parallel(dir, &qname, &wq);\n\t\tif (IS_ERR(child))\n\t\t\tgoto end_instantiate;\n\t\tif (d_in_lookup(child)) {\n\t\t\tstruct dentry *res;\n\t\t\tres = instantiate(child, task, ptr);\n\t\t\td_lookup_done(child);\n\t\t\tif (unlikely(res)) {\n\t\t\t\tdput(child);\n\t\t\t\tchild = res;\n\t\t\t\tif (IS_ERR(child))\n\t\t\t\t\tgoto end_instantiate;\n\t\t\t}\n\t\t}\n\t}\n\tinode = d_inode(child);\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\nend_instantiate:\n\treturn dir_emit(ctx, name, len, ino, type);\n}\n\n \nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tconst char *str = dentry->d_name.name;\n\tunsigned long long sval, eval;\n\tunsigned int len;\n\n\tif (str[0] == '0' && str[1] != '-')\n\t\treturn -EINVAL;\n\tlen = _parse_integer(str, 16, &sval);\n\tif (len & KSTRTOX_OVERFLOW)\n\t\treturn -EINVAL;\n\tif (sval != (unsigned long)sval)\n\t\treturn -EINVAL;\n\tstr += len;\n\n\tif (*str != '-')\n\t\treturn -EINVAL;\n\tstr++;\n\n\tif (str[0] == '0' && str[1])\n\t\treturn -EINVAL;\n\tlen = _parse_integer(str, 16, &eval);\n\tif (len & KSTRTOX_OVERFLOW)\n\t\treturn -EINVAL;\n\tif (eval != (unsigned long)eval)\n\t\treturn -EINVAL;\n\tstr += len;\n\n\tif (*str != '\\0')\n\t\treturn -EINVAL;\n\n\t*start = sval;\n\t*end = eval;\n\n\treturn 0;\n}\n\nstatic int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tstruct inode *inode;\n\tint status = 0;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = d_inode(dentry);\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\n\tmm = mm_access(task, PTRACE_MODE_READ_FSCREDS);\n\tif (IS_ERR_OR_NULL(mm))\n\t\tgoto out;\n\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tstatus = mmap_read_lock_killable(mm);\n\t\tif (!status) {\n\t\t\texact_vma_exists = !!find_exact_vma(mm, vm_start,\n\t\t\t\t\t\t\t    vm_end);\n\t\t\tmmap_read_unlock(mm);\n\t\t}\n\t}\n\n\tmmput(mm);\n\n\tif (exact_vma_exists) {\n\t\ttask_dump_owner(task, 0, &inode->i_uid, &inode->i_gid);\n\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\n\nout:\n\tput_task_struct(task);\n\nout_notask:\n\treturn status;\n}\n\nstatic const struct dentry_operations tid_map_files_dentry_operations = {\n\t.d_revalidate\t= map_files_d_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int map_files_get_link(struct dentry *dentry, struct path *path)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint rc;\n\n\trc = -ENOENT;\n\ttask = get_proc_task(d_inode(dentry));\n\tif (!task)\n\t\tgoto out;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\tgoto out;\n\n\trc = dname_to_vma_addr(dentry, &vm_start, &vm_end);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = mmap_read_lock_killable(mm);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = -ENOENT;\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (vma && vma->vm_file) {\n\t\t*path = vma->vm_file->f_path;\n\t\tpath_get(path);\n\t\trc = 0;\n\t}\n\tmmap_read_unlock(mm);\n\nout_mmput:\n\tmmput(mm);\nout:\n\treturn rc;\n}\n\nstruct map_files_info {\n\tunsigned long\tstart;\n\tunsigned long\tend;\n\tfmode_t\t\tmode;\n};\n\n \nstatic const char *\nproc_map_files_get_link(struct dentry *dentry,\n\t\t\tstruct inode *inode,\n\t\t        struct delayed_call *done)\n{\n\tif (!checkpoint_restore_ns_capable(&init_user_ns))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn proc_pid_get_link(dentry, inode, done);\n}\n\n \nstatic const struct inode_operations proc_map_files_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.get_link\t= proc_map_files_get_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *\nproc_map_files_instantiate(struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dentry->d_sb, task, S_IFLNK |\n\t\t\t\t    ((mode & FMODE_READ ) ? S_IRUSR : 0) |\n\t\t\t\t    ((mode & FMODE_WRITE) ? S_IWUSR : 0));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = map_files_get_link;\n\n\tinode->i_op = &proc_map_files_link_inode_operations;\n\tinode->i_size = 64;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct dentry *proc_map_files_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct dentry *result;\n\tstruct mm_struct *mm;\n\n\tresult = ERR_PTR(-ENOENT);\n\ttask = get_proc_task(dir);\n\tif (!task)\n\t\tgoto out;\n\n\tresult = ERR_PTR(-EACCES);\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tresult = ERR_PTR(-ENOENT);\n\tif (dname_to_vma_addr(dentry, &vm_start, &vm_end))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tresult = ERR_PTR(-EINTR);\n\tif (mmap_read_lock_killable(mm))\n\t\tgoto out_put_mm;\n\n\tresult = ERR_PTR(-ENOENT);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (!vma)\n\t\tgoto out_no_vma;\n\n\tif (vma->vm_file)\n\t\tresult = proc_map_files_instantiate(dentry, task,\n\t\t\t\t(void *)(unsigned long)vma->vm_file->f_mode);\n\nout_no_vma:\n\tmmap_read_unlock(mm);\nout_put_mm:\n\tmmput(mm);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\nstatic const struct inode_operations proc_map_files_inode_operations = {\n\t.lookup\t\t= proc_map_files_lookup,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long nr_files, pos, i;\n\tGENRADIX(struct map_files_info) fa;\n\tstruct map_files_info *p;\n\tint ret;\n\tstruct vma_iterator vmi;\n\n\tgenradix_init(&fa);\n\n\tret = -ENOENT;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))\n\t\tgoto out_put_task;\n\n\tret = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tret = mmap_read_lock_killable(mm);\n\tif (ret) {\n\t\tmmput(mm);\n\t\tgoto out_put_task;\n\t}\n\n\tnr_files = 0;\n\n\t \n\n\tpos = 2;\n\tvma_iter_init(&vmi, mm, 0);\n\tfor_each_vma(vmi, vma) {\n\t\tif (!vma->vm_file)\n\t\t\tcontinue;\n\t\tif (++pos <= ctx->pos)\n\t\t\tcontinue;\n\n\t\tp = genradix_ptr_alloc(&fa, nr_files++, GFP_KERNEL);\n\t\tif (!p) {\n\t\t\tret = -ENOMEM;\n\t\t\tmmap_read_unlock(mm);\n\t\t\tmmput(mm);\n\t\t\tgoto out_put_task;\n\t\t}\n\n\t\tp->start = vma->vm_start;\n\t\tp->end = vma->vm_end;\n\t\tp->mode = vma->vm_file->f_mode;\n\t}\n\tmmap_read_unlock(mm);\n\tmmput(mm);\n\n\tfor (i = 0; i < nr_files; i++) {\n\t\tchar buf[4 * sizeof(long) + 2];\t \n\t\tunsigned int len;\n\n\t\tp = genradix_ptr(&fa, i);\n\t\tlen = snprintf(buf, sizeof(buf), \"%lx-%lx\", p->start, p->end);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t      buf, len,\n\t\t\t\t      proc_map_files_instantiate,\n\t\t\t\t      task,\n\t\t\t\t      (void *)(unsigned long)p->mode))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\nout_put_task:\n\tput_task_struct(task);\nout:\n\tgenradix_free(&fa);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_map_files_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_map_files_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n#if defined(CONFIG_CHECKPOINT_RESTORE) && defined(CONFIG_POSIX_TIMERS)\nstruct timers_private {\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tstruct sighand_struct *sighand;\n\tstruct pid_namespace *ns;\n\tunsigned long flags;\n};\n\nstatic void *timers_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\n\ttp->task = get_pid_task(tp->pid, PIDTYPE_PID);\n\tif (!tp->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\ttp->sighand = lock_task_sighand(tp->task, &tp->flags);\n\tif (!tp->sighand)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn seq_list_start(&tp->task->signal->posix_timers, *pos);\n}\n\nstatic void *timers_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\treturn seq_list_next(v, &tp->task->signal->posix_timers, pos);\n}\n\nstatic void timers_stop(struct seq_file *m, void *v)\n{\n\tstruct timers_private *tp = m->private;\n\n\tif (tp->sighand) {\n\t\tunlock_task_sighand(tp->task, &tp->flags);\n\t\ttp->sighand = NULL;\n\t}\n\n\tif (tp->task) {\n\t\tput_task_struct(tp->task);\n\t\ttp->task = NULL;\n\t}\n}\n\nstatic int show_timer(struct seq_file *m, void *v)\n{\n\tstruct k_itimer *timer;\n\tstruct timers_private *tp = m->private;\n\tint notify;\n\tstatic const char * const nstr[] = {\n\t\t[SIGEV_SIGNAL] = \"signal\",\n\t\t[SIGEV_NONE] = \"none\",\n\t\t[SIGEV_THREAD] = \"thread\",\n\t};\n\n\ttimer = list_entry((struct list_head *)v, struct k_itimer, list);\n\tnotify = timer->it_sigev_notify;\n\n\tseq_printf(m, \"ID: %d\\n\", timer->it_id);\n\tseq_printf(m, \"signal: %d/%px\\n\",\n\t\t   timer->sigq->info.si_signo,\n\t\t   timer->sigq->info.si_value.sival_ptr);\n\tseq_printf(m, \"notify: %s/%s.%d\\n\",\n\t\t   nstr[notify & ~SIGEV_THREAD_ID],\n\t\t   (notify & SIGEV_THREAD_ID) ? \"tid\" : \"pid\",\n\t\t   pid_nr_ns(timer->it_pid, tp->ns));\n\tseq_printf(m, \"ClockID: %d\\n\", timer->it_clock);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations proc_timers_seq_ops = {\n\t.start\t= timers_start,\n\t.next\t= timers_next,\n\t.stop\t= timers_stop,\n\t.show\t= show_timer,\n};\n\nstatic int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = proc_pid_ns(inode->i_sb);\n\treturn 0;\n}\n\nstatic const struct file_operations proc_timers_operations = {\n\t.open\t\t= proc_timers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n};\n#endif\n\nstatic ssize_t timerslack_ns_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tu64 slack_ns;\n\tint err;\n\n\terr = kstrtoull_from_user(buf, count, 10, &slack_ns);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (p != current) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tcount = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\terr = security_task_setscheduler(p);\n\t\tif (err) {\n\t\t\tcount = err;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttask_lock(p);\n\tif (slack_ns == 0)\n\t\tp->timer_slack_ns = p->default_timer_slack_ns;\n\telse\n\t\tp->timer_slack_ns = slack_ns;\n\ttask_unlock(p);\n\nout:\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int timerslack_ns_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\tint err = 0;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (p != current) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\terr = security_task_getscheduler(p);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\ttask_lock(p);\n\tseq_printf(m, \"%llu\\n\", p->timer_slack_ns);\n\ttask_unlock(p);\n\nout:\n\tput_task_struct(p);\n\n\treturn err;\n}\n\nstatic int timerslack_ns_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, timerslack_ns_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_timerslack_ns_operations = {\n\t.open\t\t= timerslack_ns_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= timerslack_ns_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic struct dentry *proc_pident_instantiate(struct dentry *dentry,\n\tstruct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dentry->d_sb, task, p->mode);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tei = PROC_I(inode);\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t \n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\tpid_update_inode(task, inode);\n\td_set_d_op(dentry, &pid_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *p,\n\t\t\t\t\t const struct pid_entry *end)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tstruct dentry *res = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t \n\tfor (; p < end; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len)) {\n\t\t\tres = proc_pident_instantiate(dentry, task, p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tput_task_struct(task);\nout_no_task:\n\treturn res;\n}\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p < ents + nents; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY\nstatic int proc_pid_attr_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = NULL;\n\t__mem_open(inode, file, PTRACE_MODE_READ_FSCREDS);\n\treturn 0;\n}\n\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task, PROC_I(inode)->op.lsm,\n\t\t\t\t      file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task;\n\tvoid *page;\n\tint rv;\n\n\t \n\tif (file->private_data != current->mm)\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\t \n\tif (current != task) {\n\t\trcu_read_unlock();\n\t\treturn -EACCES;\n\t}\n\t \n\tif (current_cred() != current_real_cred()) {\n\t\trcu_read_unlock();\n\t\treturn -EBUSY;\n\t}\n\trcu_read_unlock();\n\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t \n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user(buf, count);\n\tif (IS_ERR(page)) {\n\t\trv = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\t \n\trv = mutex_lock_interruptible(&current->signal->cred_guard_mutex);\n\tif (rv < 0)\n\t\tgoto out_free;\n\n\trv = security_setprocattr(PROC_I(inode)->op.lsm,\n\t\t\t\t  file->f_path.dentry->d_name.name, page,\n\t\t\t\t  count);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_free:\n\tkfree(page);\nout:\n\treturn rv;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.open\t\t= proc_pid_attr_open,\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= mem_release,\n};\n\n#define LSM_DIR_OPS(LSM) \\\nstatic int proc_##LSM##_attr_dir_iterate(struct file *filp, \\\n\t\t\t     struct dir_context *ctx) \\\n{ \\\n\treturn proc_pident_readdir(filp, ctx, \\\n\t\t\t\t   LSM##_attr_dir_stuff, \\\n\t\t\t\t   ARRAY_SIZE(LSM##_attr_dir_stuff)); \\\n} \\\n\\\nstatic const struct file_operations proc_##LSM##_attr_dir_ops = { \\\n\t.read\t\t= generic_read_dir, \\\n\t.iterate_shared\t= proc_##LSM##_attr_dir_iterate, \\\n\t.llseek\t\t= default_llseek, \\\n}; \\\n\\\nstatic struct dentry *proc_##LSM##_attr_dir_lookup(struct inode *dir, \\\n\t\t\t\tstruct dentry *dentry, unsigned int flags) \\\n{ \\\n\treturn proc_pident_lookup(dir, dentry, \\\n\t\t\t\t  LSM##_attr_dir_stuff, \\\n\t\t\t\t  LSM##_attr_dir_stuff + ARRAY_SIZE(LSM##_attr_dir_stuff)); \\\n} \\\n\\\nstatic const struct inode_operations proc_##LSM##_attr_dir_inode_ops = { \\\n\t.lookup\t\t= proc_##LSM##_attr_dir_lookup, \\\n\t.getattr\t= pid_getattr, \\\n\t.setattr\t= proc_setattr, \\\n}\n\n#ifdef CONFIG_SECURITY_SMACK\nstatic const struct pid_entry smack_attr_dir_stuff[] = {\n\tATTR(\"smack\", \"current\",\t0666),\n};\nLSM_DIR_OPS(smack);\n#endif\n\n#ifdef CONFIG_SECURITY_APPARMOR\nstatic const struct pid_entry apparmor_attr_dir_stuff[] = {\n\tATTR(\"apparmor\", \"current\",\t0666),\n\tATTR(\"apparmor\", \"prev\",\t0444),\n\tATTR(\"apparmor\", \"exec\",\t0666),\n};\nLSM_DIR_OPS(apparmor);\n#endif\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tATTR(NULL, \"current\",\t\t0666),\n\tATTR(NULL, \"prev\",\t\t0444),\n\tATTR(NULL, \"exec\",\t\t0666),\n\tATTR(NULL, \"fscreate\",\t\t0666),\n\tATTR(NULL, \"keycreate\",\t\t0666),\n\tATTR(NULL, \"sockcreate\",\t0666),\n#ifdef CONFIG_SECURITY_SMACK\n\tDIR(\"smack\",\t\t\t0555,\n\t    proc_smack_attr_dir_inode_ops, proc_smack_attr_dir_ops),\n#endif\n#ifdef CONFIG_SECURITY_APPARMOR\n\tDIR(\"apparmor\",\t\t\t0555,\n\t    proc_apparmor_attr_dir_inode_ops, proc_apparmor_attr_dir_ops),\n#endif\n};\n\nstatic int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx, \n\t\t\t\t   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_attr_dir_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff,\n\t\t\t\t  attr_dir_stuff + ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = kstrtouint_from_user(buf, count, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\tret = 0;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = down_read_killable(&task->signal->exec_update_lock);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tseq_printf(m,\n\t\t   \"rchar: %llu\\n\"\n\t\t   \"wchar: %llu\\n\"\n\t\t   \"syscr: %llu\\n\"\n\t\t   \"syscw: %llu\\n\"\n\t\t   \"read_bytes: %llu\\n\"\n\t\t   \"write_bytes: %llu\\n\"\n\t\t   \"cancelled_write_bytes: %llu\\n\",\n\t\t   (unsigned long long)acct.rchar,\n\t\t   (unsigned long long)acct.wchar,\n\t\t   (unsigned long long)acct.syscr,\n\t\t   (unsigned long long)acct.syscw,\n\t\t   (unsigned long long)acct.read_bytes,\n\t\t   (unsigned long long)acct.write_bytes,\n\t\t   (unsigned long long)acct.cancelled_write_bytes);\n\tresult = 0;\n\nout_unlock:\n\tup_read(&task->signal->exec_update_lock);\n\treturn result;\n}\n\nstatic int proc_tid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 1);\n}\n#endif  \n\n#ifdef CONFIG_USER_NS\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_id_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tput_user_ns(ns);\n\treturn seq_release(inode, file);\n}\n\nstatic int proc_uid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_uid_seq_operations);\n}\n\nstatic int proc_gid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_gid_seq_operations);\n}\n\nstatic int proc_projid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_projid_seq_operations);\n}\n\nstatic const struct file_operations proc_uid_map_operations = {\n\t.open\t\t= proc_uid_map_open,\n\t.write\t\t= proc_uid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_gid_map_operations = {\n\t.open\t\t= proc_gid_map_open,\n\t.write\t\t= proc_gid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic const struct file_operations proc_projid_map_operations = {\n\t.open\t\t= proc_projid_map_open,\n\t.write\t\t= proc_projid_map_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_id_map_release,\n};\n\nstatic int proc_setgroups_open(struct inode *inode, struct file *file)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = -EACCES;\n\t\tif (!ns_capable(ns, CAP_SYS_ADMIN))\n\t\t\tgoto err_put_ns;\n\t}\n\n\tret = single_open(file, &proc_setgroups_show, ns);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}\n\nstatic int proc_setgroups_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tint ret = single_release(inode, file);\n\tput_user_ns(ns);\n\treturn ret;\n}\n\nstatic const struct file_operations proc_setgroups_operations = {\n\t.open\t\t= proc_setgroups_open,\n\t.write\t\t= proc_setgroups_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_setgroups_release,\n};\n#endif  \n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}\n\n#ifdef CONFIG_LIVEPATCH\nstatic int proc_pid_patch_state(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tseq_printf(m, \"%d\\n\", task->patch_state);\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_KSM\nstatic int proc_pid_ksm_merging_pages(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tseq_printf(m, \"%lu\\n\", mm->ksm_merging_pages);\n\t\tmmput(mm);\n\t}\n\n\treturn 0;\n}\nstatic int proc_pid_ksm_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tseq_printf(m, \"ksm_rmap_items %lu\\n\", mm->ksm_rmap_items);\n\t\tseq_printf(m, \"ksm_zero_pages %lu\\n\", mm->ksm_zero_pages);\n\t\tseq_printf(m, \"ksm_merging_pages %lu\\n\", mm->ksm_merging_pages);\n\t\tseq_printf(m, \"ksm_process_profit %ld\\n\", ksm_process_profit(mm));\n\t\tmmput(mm);\n\t}\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_STACKLEAK_METRICS\nstatic int proc_stack_depth(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tunsigned long prev_depth = THREAD_SIZE -\n\t\t\t\t(task->prev_lowest_stack & (THREAD_SIZE - 1));\n\tunsigned long depth = THREAD_SIZE -\n\t\t\t\t(task->lowest_stack & (THREAD_SIZE - 1));\n\n\tseq_printf(m, \"previous stack depth: %lu\\nstack depth: %lu\\n\",\n\t\t\t\t\t\t\tprev_depth, depth);\n\treturn 0;\n}\n#endif  \n\n \nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n\tDIR(\"fdinfo\",     S_IRUGO|S_IXUGO, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tREG(\"auxv\",       S_IRUSR, proc_auxv_operations),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n#ifdef CONFIG_TIME_NS\n\tREG(\"timens_offsets\",  S_IRUGO|S_IWUSR, proc_timens_offsets_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",    S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"smaps_rollup\", S_IRUGO, proc_pid_smaps_rollup_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n#ifdef CONFIG_PROC_CPU_RESCTRL\n\tONE(\"cpu_resctrl_groups\", S_IRUGO, proc_resctrl_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDIT\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n\tREG(\"fail-nth\", 0644, proc_fail_nth_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#if defined(CONFIG_CHECKPOINT_RESTORE) && defined(CONFIG_POSIX_TIMERS)\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n\tREG(\"timerslack_ns\", S_IRUGO|S_IWUGO, proc_pid_set_timerslack_ns_operations),\n#ifdef CONFIG_LIVEPATCH\n\tONE(\"patch_state\",  S_IRUSR, proc_pid_patch_state),\n#endif\n#ifdef CONFIG_STACKLEAK_METRICS\n\tONE(\"stack_depth\", S_IRUGO, proc_stack_depth),\n#endif\n#ifdef CONFIG_PROC_PID_ARCH_STATUS\n\tONE(\"arch_status\", S_IRUGO, proc_pid_arch_status),\n#endif\n#ifdef CONFIG_SECCOMP_CACHE_DEBUG\n\tONE(\"seccomp_cache\", S_IRUSR, proc_pid_seccomp_cache),\n#endif\n#ifdef CONFIG_KSM\n\tONE(\"ksm_merging_pages\",  S_IRUSR, proc_pid_ksm_merging_pages),\n\tONE(\"ksm_stat\",  S_IRUSR, proc_pid_ksm_stat),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_tgid_base_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstruct pid *tgid_pidfd_to_pid(const struct file *file)\n{\n\tif (file->f_op != &proc_tgid_base_operations)\n\t\treturn ERR_PTR(-EBADF);\n\n\treturn proc_pid(file_inode(file));\n}\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff,\n\t\t\t\t  tgid_base_stuff + ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\n \n\nvoid proc_flush_pid(struct pid *pid)\n{\n\tproc_invalidate_siblings_dcache(&pid->inodes, &pid->lock);\n}\n\nstatic struct dentry *proc_pid_instantiate(struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_base_inode(dentry->d_sb, task,\n\t\t\t\t\t S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, nlink_tgid);\n\tpid_update_inode(task, inode);\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstruct dentry *proc_pid_lookup(struct dentry *dentry, unsigned int flags)\n{\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct proc_fs_info *fs_info;\n\tstruct pid_namespace *ns;\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tfs_info = proc_sb_info(dentry->d_sb);\n\tns = fs_info->pid_ns;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\t \n\tif (fs_info->hide_pid == HIDEPID_NOT_PTRACEABLE) {\n\t\tif (!has_pid_permissions(fs_info, task, HIDEPID_NO_ACCESS))\n\t\t\tgoto out_put_task;\n\t}\n\n\tresult = proc_pid_instantiate(dentry, task, NULL);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\n \nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_TGID);\n\t\tif (!iter.task) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)\n\n \nint proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct proc_fs_info *fs_info = proc_sb_info(file_inode(file)->i_sb);\n\tstruct pid_namespace *ns = proc_pid_ns(file_inode(file)->i_sb);\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = d_inode(fs_info->proc_self);\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = d_inode(fs_info->proc_thread_self);\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[10 + 1];\n\t\tunsigned int len;\n\n\t\tcond_resched();\n\t\tif (!has_pid_permissions(fs_info, iter.task, HIDEPID_INVISIBLE))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%u\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}\n\n \nstatic int proc_tid_comm_permission(struct mnt_idmap *idmap,\n\t\t\t\t    struct inode *inode, int mask)\n{\n\tbool is_same_tgroup;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\tis_same_tgroup = same_thread_group(current, task);\n\tput_task_struct(task);\n\n\tif (likely(is_same_tgroup && !(mask & MAY_EXEC))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\nstatic const struct inode_operations proc_tid_comm_inode_operations = {\n\t\t.setattr\t= proc_setattr,\n\t\t.permission\t= proc_tid_comm_permission,\n};\n\n \nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUGO|S_IXUGO, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tREG(\"auxv\",      S_IRUSR, proc_auxv_operations),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tNOD(\"comm\",      S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t &proc_tid_comm_inode_operations,\n\t\t\t &proc_pid_set_comm_operations, {}),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tREG(\"cmdline\",   S_IRUGO, proc_pid_cmdline_ops),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_PROC_CHILDREN\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"smaps_rollup\", S_IRUGO, proc_pid_smaps_rollup_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHED_INFO\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n#ifdef CONFIG_PROC_CPU_RESCTRL\n\tONE(\"cpu_resctrl_groups\", S_IRUGO, proc_resctrl_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDIT\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n\tREG(\"fail-nth\", 0644, proc_fail_nth_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_LIVEPATCH\n\tONE(\"patch_state\",  S_IRUSR, proc_pid_patch_state),\n#endif\n#ifdef CONFIG_PROC_PID_ARCH_STATUS\n\tONE(\"arch_status\", S_IRUGO, proc_pid_arch_status),\n#endif\n#ifdef CONFIG_SECCOMP_CACHE_DEBUG\n\tONE(\"seccomp_cache\", S_IRUSR, proc_pid_seccomp_cache),\n#endif\n#ifdef CONFIG_KSM\n\tONE(\"ksm_merging_pages\",  S_IRUSR, proc_pid_ksm_merging_pages),\n\tONE(\"ksm_stat\",  S_IRUSR, proc_pid_ksm_stat),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff,\n\t\t\t\t  tid_base_stuff + ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_tid_base_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_task_instantiate(struct dentry *dentry,\n\tstruct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_base_inode(dentry->d_sb, task,\n\t\t\t\t\t S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags |= S_IMMUTABLE;\n\n\tset_nlink(inode, nlink_tid);\n\tpid_update_inode(task, inode);\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct proc_fs_info *fs_info;\n\tstruct pid_namespace *ns;\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(&dentry->d_name);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tfs_info = proc_sb_info(dentry->d_sb);\n\tns = fs_info->pid_ns;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn result;\n}\n\n \nstatic struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t \n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t \n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t \n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t \n\tfor_each_thread(task, pos) {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t};\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n \nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\n \nstatic int proc_task_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *task;\n\tstruct pid_namespace *ns;\n\tint tid;\n\n\tif (proc_inode_is_dead(inode))\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t \n\tns = proc_pid_ns(inode->i_sb);\n\ttid = (int)file->f_version;\n\tfile->f_version = 0;\n\tfor (task = first_tid(proc_pid(inode), tid, ctx->pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), ctx->pos++) {\n\t\tchar name[10 + 1];\n\t\tunsigned int len;\n\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tif (!tid)\n\t\t\tcontinue;\t \n\t\tlen = snprintf(name, sizeof(name), \"%u\", tid);\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL)) {\n\t\t\t \n\t\t\tfile->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int proc_task_getattr(struct mnt_idmap *idmap,\n\t\t\t     const struct path *path, struct kstat *stat,\n\t\t\t     u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= proc_task_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nvoid __init set_proc_pid_nlink(void)\n{\n\tnlink_tid = pid_entry_nlink(tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n\tnlink_tgid = pid_entry_nlink(tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}