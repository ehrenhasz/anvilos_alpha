{
  "module_name": "array.c",
  "hash_id": "c62fb194cef232645fa854dc1fdcab3c4cf4e370b04070f644947a052da1a168",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/array.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/time_namespace.h>\n#include <linux/kernel.h>\n#include <linux/kernel_stat.h>\n#include <linux/tty.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/cputime.h>\n#include <linux/proc_fs.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/times.h>\n#include <linux/cpuset.h>\n#include <linux/rcupdate.h>\n#include <linux/delayacct.h>\n#include <linux/seq_file.h>\n#include <linux/pid_namespace.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/string_helpers.h>\n#include <linux/user_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/kthread.h>\n#include <linux/mmu_context.h>\n\n#include <asm/processor.h>\n#include \"internal.h\"\n\nvoid proc_task_name(struct seq_file *m, struct task_struct *p, bool escape)\n{\n\tchar tcomm[64];\n\n\t \n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_comm(tcomm, sizeof(tcomm), p);\n\telse if (p->flags & PF_KTHREAD)\n\t\tget_kthread_comm(tcomm, sizeof(tcomm), p);\n\telse\n\t\t__get_task_comm(tcomm, sizeof(tcomm), p);\n\n\tif (escape)\n\t\tseq_escape_str(m, tcomm, ESCAPE_SPACE | ESCAPE_SPECIAL, \"\\n\\\\\");\n\telse\n\t\tseq_printf(m, \"%.64s\", tcomm);\n}\n\n \nstatic const char * const task_state_array[] = {\n\n\t \n\t\"R (running)\",\t\t \n\t\"S (sleeping)\",\t\t \n\t\"D (disk sleep)\",\t \n\t\"T (stopped)\",\t\t \n\t\"t (tracing stop)\",\t \n\t\"X (dead)\",\t\t \n\t\"Z (zombie)\",\t\t \n\t\"P (parked)\",\t\t \n\n\t \n\t\"I (idle)\",\t\t \n};\n\nstatic inline const char *get_task_state(struct task_struct *tsk)\n{\n\tBUILD_BUG_ON(1 + ilog2(TASK_REPORT_MAX) != ARRAY_SIZE(task_state_array));\n\treturn task_state_array[task_state_index(tsk)];\n}\n\nstatic inline void task_state(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *p)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(m);\n\tstruct group_info *group_info;\n\tint g, umask = -1;\n\tstruct task_struct *tracer;\n\tconst struct cred *cred;\n\tpid_t ppid, tpid = 0, tgid, ngid;\n\tunsigned int max_fds = 0;\n\n\trcu_read_lock();\n\tppid = pid_alive(p) ?\n\t\ttask_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;\n\n\ttracer = ptrace_parent(p);\n\tif (tracer)\n\t\ttpid = task_pid_nr_ns(tracer, ns);\n\n\ttgid = task_tgid_nr_ns(p, ns);\n\tngid = task_numa_group_id(p);\n\tcred = get_task_cred(p);\n\n\ttask_lock(p);\n\tif (p->fs)\n\t\tumask = p->fs->umask;\n\tif (p->files)\n\t\tmax_fds = files_fdtable(p->files)->max_fds;\n\ttask_unlock(p);\n\trcu_read_unlock();\n\n\tif (umask >= 0)\n\t\tseq_printf(m, \"Umask:\\t%#04o\\n\", umask);\n\tseq_puts(m, \"State:\\t\");\n\tseq_puts(m, get_task_state(p));\n\n\tseq_put_decimal_ull(m, \"\\nTgid:\\t\", tgid);\n\tseq_put_decimal_ull(m, \"\\nNgid:\\t\", ngid);\n\tseq_put_decimal_ull(m, \"\\nPid:\\t\", pid_nr_ns(pid, ns));\n\tseq_put_decimal_ull(m, \"\\nPPid:\\t\", ppid);\n\tseq_put_decimal_ull(m, \"\\nTracerPid:\\t\", tpid);\n\tseq_put_decimal_ull(m, \"\\nUid:\\t\", from_kuid_munged(user_ns, cred->uid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kuid_munged(user_ns, cred->euid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kuid_munged(user_ns, cred->suid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kuid_munged(user_ns, cred->fsuid));\n\tseq_put_decimal_ull(m, \"\\nGid:\\t\", from_kgid_munged(user_ns, cred->gid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kgid_munged(user_ns, cred->egid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kgid_munged(user_ns, cred->sgid));\n\tseq_put_decimal_ull(m, \"\\t\", from_kgid_munged(user_ns, cred->fsgid));\n\tseq_put_decimal_ull(m, \"\\nFDSize:\\t\", max_fds);\n\n\tseq_puts(m, \"\\nGroups:\\t\");\n\tgroup_info = cred->group_info;\n\tfor (g = 0; g < group_info->ngroups; g++)\n\t\tseq_put_decimal_ull(m, g ? \" \" : \"\",\n\t\t\t\tfrom_kgid_munged(user_ns, group_info->gid[g]));\n\tput_cred(cred);\n\t \n\tseq_putc(m, ' ');\n\n#ifdef CONFIG_PID_NS\n\tseq_puts(m, \"\\nNStgid:\");\n\tfor (g = ns->level; g <= pid->level; g++)\n\t\tseq_put_decimal_ull(m, \"\\t\", task_tgid_nr_ns(p, pid->numbers[g].ns));\n\tseq_puts(m, \"\\nNSpid:\");\n\tfor (g = ns->level; g <= pid->level; g++)\n\t\tseq_put_decimal_ull(m, \"\\t\", task_pid_nr_ns(p, pid->numbers[g].ns));\n\tseq_puts(m, \"\\nNSpgid:\");\n\tfor (g = ns->level; g <= pid->level; g++)\n\t\tseq_put_decimal_ull(m, \"\\t\", task_pgrp_nr_ns(p, pid->numbers[g].ns));\n\tseq_puts(m, \"\\nNSsid:\");\n\tfor (g = ns->level; g <= pid->level; g++)\n\t\tseq_put_decimal_ull(m, \"\\t\", task_session_nr_ns(p, pid->numbers[g].ns));\n#endif\n\tseq_putc(m, '\\n');\n\n\tseq_printf(m, \"Kthread:\\t%c\\n\", p->flags & PF_KTHREAD ? '1' : '0');\n}\n\nvoid render_sigset_t(struct seq_file *m, const char *header,\n\t\t\t\tsigset_t *set)\n{\n\tint i;\n\n\tseq_puts(m, header);\n\n\ti = _NSIG;\n\tdo {\n\t\tint x = 0;\n\n\t\ti -= 4;\n\t\tif (sigismember(set, i+1)) x |= 1;\n\t\tif (sigismember(set, i+2)) x |= 2;\n\t\tif (sigismember(set, i+3)) x |= 4;\n\t\tif (sigismember(set, i+4)) x |= 8;\n\t\tseq_putc(m, hex_asc[x]);\n\t} while (i >= 4);\n\n\tseq_putc(m, '\\n');\n}\n\nstatic void collect_sigign_sigcatch(struct task_struct *p, sigset_t *sigign,\n\t\t\t\t    sigset_t *sigcatch)\n{\n\tstruct k_sigaction *k;\n\tint i;\n\n\tk = p->sighand->action;\n\tfor (i = 1; i <= _NSIG; ++i, ++k) {\n\t\tif (k->sa.sa_handler == SIG_IGN)\n\t\t\tsigaddset(sigign, i);\n\t\telse if (k->sa.sa_handler != SIG_DFL)\n\t\t\tsigaddset(sigcatch, i);\n\t}\n}\n\nstatic inline void task_sig(struct seq_file *m, struct task_struct *p)\n{\n\tunsigned long flags;\n\tsigset_t pending, shpending, blocked, ignored, caught;\n\tint num_threads = 0;\n\tunsigned int qsize = 0;\n\tunsigned long qlim = 0;\n\n\tsigemptyset(&pending);\n\tsigemptyset(&shpending);\n\tsigemptyset(&blocked);\n\tsigemptyset(&ignored);\n\tsigemptyset(&caught);\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tpending = p->pending.signal;\n\t\tshpending = p->signal->shared_pending.signal;\n\t\tblocked = p->blocked;\n\t\tcollect_sigign_sigcatch(p, &ignored, &caught);\n\t\tnum_threads = get_nr_threads(p);\n\t\trcu_read_lock();   \n\t\tqsize = get_rlimit_value(task_ucounts(p), UCOUNT_RLIMIT_SIGPENDING);\n\t\trcu_read_unlock();\n\t\tqlim = task_rlimit(p, RLIMIT_SIGPENDING);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tseq_put_decimal_ull(m, \"Threads:\\t\", num_threads);\n\tseq_put_decimal_ull(m, \"\\nSigQ:\\t\", qsize);\n\tseq_put_decimal_ull(m, \"/\", qlim);\n\n\t \n\trender_sigset_t(m, \"\\nSigPnd:\\t\", &pending);\n\trender_sigset_t(m, \"ShdPnd:\\t\", &shpending);\n\trender_sigset_t(m, \"SigBlk:\\t\", &blocked);\n\trender_sigset_t(m, \"SigIgn:\\t\", &ignored);\n\trender_sigset_t(m, \"SigCgt:\\t\", &caught);\n}\n\nstatic void render_cap_t(struct seq_file *m, const char *header,\n\t\t\tkernel_cap_t *a)\n{\n\tseq_puts(m, header);\n\tseq_put_hex_ll(m, NULL, a->val, 16);\n\tseq_putc(m, '\\n');\n}\n\nstatic inline void task_cap(struct seq_file *m, struct task_struct *p)\n{\n\tconst struct cred *cred;\n\tkernel_cap_t cap_inheritable, cap_permitted, cap_effective,\n\t\t\tcap_bset, cap_ambient;\n\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tcap_inheritable\t= cred->cap_inheritable;\n\tcap_permitted\t= cred->cap_permitted;\n\tcap_effective\t= cred->cap_effective;\n\tcap_bset\t= cred->cap_bset;\n\tcap_ambient\t= cred->cap_ambient;\n\trcu_read_unlock();\n\n\trender_cap_t(m, \"CapInh:\\t\", &cap_inheritable);\n\trender_cap_t(m, \"CapPrm:\\t\", &cap_permitted);\n\trender_cap_t(m, \"CapEff:\\t\", &cap_effective);\n\trender_cap_t(m, \"CapBnd:\\t\", &cap_bset);\n\trender_cap_t(m, \"CapAmb:\\t\", &cap_ambient);\n}\n\nstatic inline void task_seccomp(struct seq_file *m, struct task_struct *p)\n{\n\tseq_put_decimal_ull(m, \"NoNewPrivs:\\t\", task_no_new_privs(p));\n#ifdef CONFIG_SECCOMP\n\tseq_put_decimal_ull(m, \"\\nSeccomp:\\t\", p->seccomp.mode);\n#ifdef CONFIG_SECCOMP_FILTER\n\tseq_put_decimal_ull(m, \"\\nSeccomp_filters:\\t\",\n\t\t\t    atomic_read(&p->seccomp.filter_count));\n#endif\n#endif\n\tseq_puts(m, \"\\nSpeculation_Store_Bypass:\\t\");\n\tswitch (arch_prctl_spec_ctrl_get(p, PR_SPEC_STORE_BYPASS)) {\n\tcase -EINVAL:\n\t\tseq_puts(m, \"unknown\");\n\t\tbreak;\n\tcase PR_SPEC_NOT_AFFECTED:\n\t\tseq_puts(m, \"not vulnerable\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE:\n\t\tseq_puts(m, \"thread force mitigated\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_DISABLE:\n\t\tseq_puts(m, \"thread mitigated\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_ENABLE:\n\t\tseq_puts(m, \"thread vulnerable\");\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\t\tseq_puts(m, \"globally mitigated\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"vulnerable\");\n\t\tbreak;\n\t}\n\n\tseq_puts(m, \"\\nSpeculationIndirectBranch:\\t\");\n\tswitch (arch_prctl_spec_ctrl_get(p, PR_SPEC_INDIRECT_BRANCH)) {\n\tcase -EINVAL:\n\t\tseq_puts(m, \"unsupported\");\n\t\tbreak;\n\tcase PR_SPEC_NOT_AFFECTED:\n\t\tseq_puts(m, \"not affected\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE:\n\t\tseq_puts(m, \"conditional force disabled\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_DISABLE:\n\t\tseq_puts(m, \"conditional disabled\");\n\t\tbreak;\n\tcase PR_SPEC_PRCTL | PR_SPEC_ENABLE:\n\t\tseq_puts(m, \"conditional enabled\");\n\t\tbreak;\n\tcase PR_SPEC_ENABLE:\n\t\tseq_puts(m, \"always enabled\");\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\t\tseq_puts(m, \"always disabled\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"unknown\");\n\t\tbreak;\n\t}\n\tseq_putc(m, '\\n');\n}\n\nstatic inline void task_context_switch_counts(struct seq_file *m,\n\t\t\t\t\t\tstruct task_struct *p)\n{\n\tseq_put_decimal_ull(m, \"voluntary_ctxt_switches:\\t\", p->nvcsw);\n\tseq_put_decimal_ull(m, \"\\nnonvoluntary_ctxt_switches:\\t\", p->nivcsw);\n\tseq_putc(m, '\\n');\n}\n\nstatic void task_cpus_allowed(struct seq_file *m, struct task_struct *task)\n{\n\tseq_printf(m, \"Cpus_allowed:\\t%*pb\\n\",\n\t\t   cpumask_pr_args(&task->cpus_mask));\n\tseq_printf(m, \"Cpus_allowed_list:\\t%*pbl\\n\",\n\t\t   cpumask_pr_args(&task->cpus_mask));\n}\n\nstatic inline void task_core_dumping(struct seq_file *m, struct task_struct *task)\n{\n\tseq_put_decimal_ull(m, \"CoreDumping:\\t\", !!task->signal->core_state);\n\tseq_putc(m, '\\n');\n}\n\nstatic inline void task_thp_status(struct seq_file *m, struct mm_struct *mm)\n{\n\tbool thp_enabled = IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE);\n\n\tif (thp_enabled)\n\t\tthp_enabled = !test_bit(MMF_DISABLE_THP, &mm->flags);\n\tseq_printf(m, \"THP_enabled:\\t%d\\n\", thp_enabled);\n}\n\nstatic inline void task_untag_mask(struct seq_file *m, struct mm_struct *mm)\n{\n\tseq_printf(m, \"untag_mask:\\t%#lx\\n\", mm_untag_mask(mm));\n}\n\n__weak void arch_proc_pid_thread_features(struct seq_file *m,\n\t\t\t\t\t  struct task_struct *task)\n{\n}\n\nint proc_pid_status(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = get_task_mm(task);\n\n\tseq_puts(m, \"Name:\\t\");\n\tproc_task_name(m, task, true);\n\tseq_putc(m, '\\n');\n\n\ttask_state(m, ns, pid, task);\n\n\tif (mm) {\n\t\ttask_mem(m, mm);\n\t\ttask_core_dumping(m, task);\n\t\ttask_thp_status(m, mm);\n\t\ttask_untag_mask(m, mm);\n\t\tmmput(mm);\n\t}\n\ttask_sig(m, task);\n\ttask_cap(m, task);\n\ttask_seccomp(m, task);\n\ttask_cpus_allowed(m, task);\n\tcpuset_task_status_allowed(m, task);\n\ttask_context_switch_counts(m, task);\n\tarch_proc_pid_thread_features(m, task);\n\treturn 0;\n}\n\nstatic int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task, int whole)\n{\n\tunsigned long vsize, eip, esp, wchan = 0;\n\tint priority, nice;\n\tint tty_pgrp = -1, tty_nr = 0;\n\tsigset_t sigign, sigcatch;\n\tchar state;\n\tpid_t ppid = 0, pgid = -1, sid = -1;\n\tint num_threads = 0;\n\tint permitted;\n\tstruct mm_struct *mm;\n\tunsigned long long start_time;\n\tunsigned long cmin_flt = 0, cmaj_flt = 0;\n\tunsigned long  min_flt = 0,  maj_flt = 0;\n\tu64 cutime, cstime, utime, stime;\n\tu64 cgtime, gtime;\n\tunsigned long rsslim = 0;\n\tunsigned long flags;\n\tint exit_code = task->exit_code;\n\n\tstate = *get_task_state(task);\n\tvsize = eip = esp = 0;\n\tpermitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tvsize = task_vsize(mm);\n\t\t \n\t\tif (permitted && (task->flags & (PF_EXITING|PF_DUMPCORE))) {\n\t\t\tif (try_get_task_stack(task)) {\n\t\t\t\teip = KSTK_EIP(task);\n\t\t\t\tesp = KSTK_ESP(task);\n\t\t\t\tput_task_stack(task);\n\t\t\t}\n\t\t}\n\t}\n\n\tsigemptyset(&sigign);\n\tsigemptyset(&sigcatch);\n\tcutime = cstime = utime = stime = 0;\n\tcgtime = gtime = 0;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\tstruct signal_struct *sig = task->signal;\n\n\t\tif (sig->tty) {\n\t\t\tstruct pid *pgrp = tty_get_pgrp(sig->tty);\n\t\t\ttty_pgrp = pid_nr_ns(pgrp, ns);\n\t\t\tput_pid(pgrp);\n\t\t\ttty_nr = new_encode_dev(tty_devnum(sig->tty));\n\t\t}\n\n\t\tnum_threads = get_nr_threads(task);\n\t\tcollect_sigign_sigcatch(task, &sigign, &sigcatch);\n\n\t\tcmin_flt = sig->cmin_flt;\n\t\tcmaj_flt = sig->cmaj_flt;\n\t\tcutime = sig->cutime;\n\t\tcstime = sig->cstime;\n\t\tcgtime = sig->cgtime;\n\t\trsslim = READ_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\n\n\t\t \n\t\tif (whole) {\n\t\t\tstruct task_struct *t = task;\n\t\t\tdo {\n\t\t\t\tmin_flt += t->min_flt;\n\t\t\t\tmaj_flt += t->maj_flt;\n\t\t\t\tgtime += task_gtime(t);\n\t\t\t} while_each_thread(task, t);\n\n\t\t\tmin_flt += sig->min_flt;\n\t\t\tmaj_flt += sig->maj_flt;\n\t\t\tthread_group_cputime_adjusted(task, &utime, &stime);\n\t\t\tgtime += sig->gtime;\n\n\t\t\tif (sig->flags & (SIGNAL_GROUP_EXIT | SIGNAL_STOP_STOPPED))\n\t\t\t\texit_code = sig->group_exit_code;\n\t\t}\n\n\t\tsid = task_session_nr_ns(task, ns);\n\t\tppid = task_tgid_nr_ns(task->real_parent, ns);\n\t\tpgid = task_pgrp_nr_ns(task, ns);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tif (permitted && (!whole || num_threads < 2))\n\t\twchan = !task_is_running(task);\n\tif (!whole) {\n\t\tmin_flt = task->min_flt;\n\t\tmaj_flt = task->maj_flt;\n\t\ttask_cputime_adjusted(task, &utime, &stime);\n\t\tgtime = task_gtime(task);\n\t}\n\n\t \n\t \n\tpriority = task_prio(task);\n\tnice = task_nice(task);\n\n\t \n\tstart_time =\n\t\tnsec_to_clock_t(timens_add_boottime_ns(task->start_boottime));\n\n\tseq_put_decimal_ull(m, \"\", pid_nr_ns(pid, ns));\n\tseq_puts(m, \" (\");\n\tproc_task_name(m, task, false);\n\tseq_puts(m, \") \");\n\tseq_putc(m, state);\n\tseq_put_decimal_ll(m, \" \", ppid);\n\tseq_put_decimal_ll(m, \" \", pgid);\n\tseq_put_decimal_ll(m, \" \", sid);\n\tseq_put_decimal_ll(m, \" \", tty_nr);\n\tseq_put_decimal_ll(m, \" \", tty_pgrp);\n\tseq_put_decimal_ull(m, \" \", task->flags);\n\tseq_put_decimal_ull(m, \" \", min_flt);\n\tseq_put_decimal_ull(m, \" \", cmin_flt);\n\tseq_put_decimal_ull(m, \" \", maj_flt);\n\tseq_put_decimal_ull(m, \" \", cmaj_flt);\n\tseq_put_decimal_ull(m, \" \", nsec_to_clock_t(utime));\n\tseq_put_decimal_ull(m, \" \", nsec_to_clock_t(stime));\n\tseq_put_decimal_ll(m, \" \", nsec_to_clock_t(cutime));\n\tseq_put_decimal_ll(m, \" \", nsec_to_clock_t(cstime));\n\tseq_put_decimal_ll(m, \" \", priority);\n\tseq_put_decimal_ll(m, \" \", nice);\n\tseq_put_decimal_ll(m, \" \", num_threads);\n\tseq_put_decimal_ull(m, \" \", 0);\n\tseq_put_decimal_ull(m, \" \", start_time);\n\tseq_put_decimal_ull(m, \" \", vsize);\n\tseq_put_decimal_ull(m, \" \", mm ? get_mm_rss(mm) : 0);\n\tseq_put_decimal_ull(m, \" \", rsslim);\n\tseq_put_decimal_ull(m, \" \", mm ? (permitted ? mm->start_code : 1) : 0);\n\tseq_put_decimal_ull(m, \" \", mm ? (permitted ? mm->end_code : 1) : 0);\n\tseq_put_decimal_ull(m, \" \", (permitted && mm) ? mm->start_stack : 0);\n\tseq_put_decimal_ull(m, \" \", esp);\n\tseq_put_decimal_ull(m, \" \", eip);\n\t \n\tseq_put_decimal_ull(m, \" \", task->pending.signal.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, \" \", task->blocked.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, \" \", sigign.sig[0] & 0x7fffffffUL);\n\tseq_put_decimal_ull(m, \" \", sigcatch.sig[0] & 0x7fffffffUL);\n\n\t \n\tseq_put_decimal_ull(m, \" \", wchan);\n\n\tseq_put_decimal_ull(m, \" \", 0);\n\tseq_put_decimal_ull(m, \" \", 0);\n\tseq_put_decimal_ll(m, \" \", task->exit_signal);\n\tseq_put_decimal_ll(m, \" \", task_cpu(task));\n\tseq_put_decimal_ull(m, \" \", task->rt_priority);\n\tseq_put_decimal_ull(m, \" \", task->policy);\n\tseq_put_decimal_ull(m, \" \", delayacct_blkio_ticks(task));\n\tseq_put_decimal_ull(m, \" \", nsec_to_clock_t(gtime));\n\tseq_put_decimal_ll(m, \" \", nsec_to_clock_t(cgtime));\n\n\tif (mm && permitted) {\n\t\tseq_put_decimal_ull(m, \" \", mm->start_data);\n\t\tseq_put_decimal_ull(m, \" \", mm->end_data);\n\t\tseq_put_decimal_ull(m, \" \", mm->start_brk);\n\t\tseq_put_decimal_ull(m, \" \", mm->arg_start);\n\t\tseq_put_decimal_ull(m, \" \", mm->arg_end);\n\t\tseq_put_decimal_ull(m, \" \", mm->env_start);\n\t\tseq_put_decimal_ull(m, \" \", mm->env_end);\n\t} else\n\t\tseq_puts(m, \" 0 0 0 0 0 0 0\");\n\n\tif (permitted)\n\t\tseq_put_decimal_ll(m, \" \", exit_code);\n\telse\n\t\tseq_puts(m, \" 0\");\n\n\tseq_putc(m, '\\n');\n\tif (mm)\n\t\tmmput(mm);\n\treturn 0;\n}\n\nint proc_tid_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\treturn do_task_stat(m, ns, pid, task, 0);\n}\n\nint proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\treturn do_task_stat(m, ns, pid, task, 1);\n}\n\nint proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,\n\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = get_task_mm(task);\n\n\tif (mm) {\n\t\tunsigned long size;\n\t\tunsigned long resident = 0;\n\t\tunsigned long shared = 0;\n\t\tunsigned long text = 0;\n\t\tunsigned long data = 0;\n\n\t\tsize = task_statm(mm, &shared, &text, &data, &resident);\n\t\tmmput(mm);\n\n\t\t \n\t\tseq_put_decimal_ull(m, \"\", size);\n\t\tseq_put_decimal_ull(m, \" \", resident);\n\t\tseq_put_decimal_ull(m, \" \", shared);\n\t\tseq_put_decimal_ull(m, \" \", text);\n\t\tseq_put_decimal_ull(m, \" \", 0);\n\t\tseq_put_decimal_ull(m, \" \", data);\n\t\tseq_put_decimal_ull(m, \" \", 0);\n\t\tseq_putc(m, '\\n');\n\t} else {\n\t\tseq_write(m, \"0 0 0 0 0 0 0\\n\", 14);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_CHILDREN\nstatic struct pid *\nget_children_pid(struct inode *inode, struct pid *pid_prev, loff_t pos)\n{\n\tstruct task_struct *start, *task;\n\tstruct pid *pid = NULL;\n\n\tread_lock(&tasklist_lock);\n\n\tstart = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (!start)\n\t\tgoto out;\n\n\t \n\tif (pid_prev) {\n\t\ttask = pid_task(pid_prev, PIDTYPE_PID);\n\t\tif (task && task->real_parent == start &&\n\t\t    !(list_empty(&task->sibling))) {\n\t\t\tif (list_is_last(&task->sibling, &start->children))\n\t\t\t\tgoto out;\n\t\t\ttask = list_first_entry(&task->sibling,\n\t\t\t\t\t\tstruct task_struct, sibling);\n\t\t\tpid = get_pid(task_pid(task));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(task, &start->children, sibling) {\n\t\tif (pos-- == 0) {\n\t\t\tpid = get_pid(task_pid(task));\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&tasklist_lock);\n\treturn pid;\n}\n\nstatic int children_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct inode *inode = file_inode(seq->file);\n\n\tseq_printf(seq, \"%d \", pid_nr_ns(v, proc_pid_ns(inode->i_sb)));\n\treturn 0;\n}\n\nstatic void *children_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn get_children_pid(file_inode(seq->file), NULL, *pos);\n}\n\nstatic void *children_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct pid *pid;\n\n\tpid = get_children_pid(file_inode(seq->file), v, *pos + 1);\n\tput_pid(v);\n\n\t++*pos;\n\treturn pid;\n}\n\nstatic void children_seq_stop(struct seq_file *seq, void *v)\n{\n\tput_pid(v);\n}\n\nstatic const struct seq_operations children_seq_ops = {\n\t.start\t= children_seq_start,\n\t.next\t= children_seq_next,\n\t.stop\t= children_seq_stop,\n\t.show\t= children_seq_show,\n};\n\nstatic int children_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &children_seq_ops);\n}\n\nconst struct file_operations proc_tid_children_operations = {\n\t.open    = children_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}