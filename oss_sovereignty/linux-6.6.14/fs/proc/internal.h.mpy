{
  "module_name": "internal.h",
  "hash_id": "368608ad9533a4b534b1e1593c3c56f9e6560b540ca646ef2bd184c7f02e3bde",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/internal.h",
  "human_readable_source": " \n \n\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/refcount.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/binfmts.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task.h>\n\nstruct ctl_table_header;\nstruct mempolicy;\n\n \nstruct proc_dir_entry {\n\t \n\tatomic_t in_use;\n\trefcount_t refcnt;\n\tstruct list_head pde_openers;\t \n\t \n\tspinlock_t pde_unload_lock;\n\tstruct completion *pde_unload_completion;\n\tconst struct inode_operations *proc_iops;\n\tunion {\n\t\tconst struct proc_ops *proc_ops;\n\t\tconst struct file_operations *proc_dir_ops;\n\t};\n\tconst struct dentry_operations *proc_dops;\n\tunion {\n\t\tconst struct seq_operations *seq_ops;\n\t\tint (*single_show)(struct seq_file *, void *);\n\t};\n\tproc_write_t write;\n\tvoid *data;\n\tunsigned int state_size;\n\tunsigned int low_ino;\n\tnlink_t nlink;\n\tkuid_t uid;\n\tkgid_t gid;\n\tloff_t size;\n\tstruct proc_dir_entry *parent;\n\tstruct rb_root subdir;\n\tstruct rb_node subdir_node;\n\tchar *name;\n\tumode_t mode;\n\tu8 flags;\n\tu8 namelen;\n\tchar inline_name[];\n} __randomize_layout;\n\n#define SIZEOF_PDE\t(\t\t\t\t\\\n\tsizeof(struct proc_dir_entry) < 128 ? 128 :\t\\\n\tsizeof(struct proc_dir_entry) < 192 ? 192 :\t\\\n\tsizeof(struct proc_dir_entry) < 256 ? 256 :\t\\\n\tsizeof(struct proc_dir_entry) < 512 ? 512 :\t\\\n\t0)\n#define SIZEOF_PDE_INLINE_NAME (SIZEOF_PDE - sizeof(struct proc_dir_entry))\n\nstatic inline bool pde_is_permanent(const struct proc_dir_entry *pde)\n{\n\treturn pde->flags & PROC_ENTRY_PERMANENT;\n}\n\nstatic inline void pde_make_permanent(struct proc_dir_entry *pde)\n{\n\tpde->flags |= PROC_ENTRY_PERMANENT;\n}\n\nextern struct kmem_cache *proc_dir_entry_cache;\nvoid pde_free(struct proc_dir_entry *pde);\n\nunion proc_op {\n\tint (*proc_get_link)(struct dentry *, struct path *);\n\tint (*proc_show)(struct seq_file *m,\n\t\tstruct pid_namespace *ns, struct pid *pid,\n\t\tstruct task_struct *task);\n\tconst char *lsm;\n};\n\nstruct proc_inode {\n\tstruct pid *pid;\n\tunsigned int fd;\n\tunion proc_op op;\n\tstruct proc_dir_entry *pde;\n\tstruct ctl_table_header *sysctl;\n\tstruct ctl_table *sysctl_entry;\n\tstruct hlist_node sibling_inodes;\n\tconst struct proc_ns_operations *ns_ops;\n\tstruct inode vfs_inode;\n} __randomize_layout;\n\n \nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}\n\nstatic inline struct proc_dir_entry *PDE(const struct inode *inode)\n{\n\treturn PROC_I(inode)->pde;\n}\n\nstatic inline struct pid *proc_pid(const struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}\n\nstatic inline struct task_struct *get_proc_task(const struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}\n\nvoid task_dump_owner(struct task_struct *task, umode_t mode,\n\t\t     kuid_t *ruid, kgid_t *rgid);\n\nunsigned name_to_int(const struct qstr *qstr);\n \n#define FIRST_PROCESS_ENTRY 256\n\n \n#define PROC_NUMBUF 13\n\n \nextern const struct file_operations proc_tid_children_operations;\n\nextern void proc_task_name(struct seq_file *m, struct task_struct *p,\n\t\t\t   bool escape);\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\n\n \nextern const struct dentry_operations pid_dentry_operations;\nextern int pid_getattr(struct mnt_idmap *, const struct path *,\n\t\t       struct kstat *, u32, unsigned int);\nextern int proc_setattr(struct mnt_idmap *, struct dentry *,\n\t\t\tstruct iattr *);\nextern void proc_pid_evict_inode(struct proc_inode *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *, umode_t);\nextern void pid_update_inode(struct task_struct *, struct inode *);\nextern int pid_delete_dentry(const struct dentry *);\nextern int proc_pid_readdir(struct file *, struct dir_context *);\nstruct dentry *proc_pid_lookup(struct dentry *, unsigned int);\nextern loff_t mem_lseek(struct file *, loff_t, int);\n\n \ntypedef struct dentry *instantiate_t(struct dentry *,\n\t\t\t\t     struct task_struct *, const void *);\nbool proc_fill_cache(struct file *, struct dir_context *, const char *, unsigned int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\n \nstruct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry **parent, void *data);\nstruct proc_dir_entry *proc_register(struct proc_dir_entry *dir,\n\t\tstruct proc_dir_entry *dp);\nextern struct dentry *proc_lookup(struct inode *, struct dentry *, unsigned int);\nstruct dentry *proc_lookup_de(struct inode *, struct dentry *, struct proc_dir_entry *);\nextern int proc_readdir(struct file *, struct dir_context *);\nint proc_readdir_de(struct file *, struct dir_context *, struct proc_dir_entry *);\n\nstatic inline void pde_get(struct proc_dir_entry *pde)\n{\n\trefcount_inc(&pde->refcnt);\n}\nextern void pde_put(struct proc_dir_entry *);\n\nstatic inline bool is_empty_pde(const struct proc_dir_entry *pde)\n{\n\treturn S_ISDIR(pde->mode) && !pde->proc_iops;\n}\nextern ssize_t proc_simple_write(struct file *, const char __user *, size_t, loff_t *);\n\n \nstruct pde_opener {\n\tstruct list_head lh;\n\tstruct file *file;\n\tbool closing;\n\tstruct completion *c;\n} __randomize_layout;\nextern const struct inode_operations proc_link_inode_operations;\nextern const struct inode_operations proc_pid_link_inode_operations;\nextern const struct super_operations proc_sops;\n\nvoid proc_init_kmemcache(void);\nvoid proc_invalidate_siblings_dcache(struct hlist_head *inodes, spinlock_t *lock);\nvoid set_proc_pid_nlink(void);\nextern struct inode *proc_get_inode(struct super_block *, struct proc_dir_entry *);\nextern void proc_entry_rundown(struct proc_dir_entry *);\n\n \nextern const struct inode_operations proc_ns_dir_inode_operations;\nextern const struct file_operations proc_ns_dir_operations;\n\n \nextern const struct file_operations proc_net_operations;\nextern const struct inode_operations proc_net_inode_operations;\n\n#ifdef CONFIG_NET\nextern int proc_net_init(void);\n#else\nstatic inline int proc_net_init(void) { return 0; }\n#endif\n\n \nextern int proc_setup_self(struct super_block *);\n\n \nextern int proc_setup_thread_self(struct super_block *);\nextern void proc_thread_self_init(void);\n\n \n#ifdef CONFIG_PROC_SYSCTL\nextern int proc_sys_init(void);\nextern void proc_sys_evict_inode(struct inode *inode,\n\t\t\t\t struct ctl_table_header *head);\n#else\nstatic inline void proc_sys_init(void) { }\nstatic inline void proc_sys_evict_inode(struct  inode *inode,\n\t\t\t\t\tstruct ctl_table_header *head) { }\n#endif\n\n \n#ifdef CONFIG_TTY\nextern void proc_tty_init(void);\n#else\nstatic inline void proc_tty_init(void) {}\n#endif\n\n \nextern struct proc_dir_entry proc_root;\n\nextern void proc_self_init(void);\n\n \nstruct mem_size_stats;\nstruct proc_maps_private {\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct vma_iterator iter;\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *task_mempolicy;\n#endif\n} __randomize_layout;\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode);\n\nextern const struct file_operations proc_pid_maps_operations;\nextern const struct file_operations proc_pid_numa_maps_operations;\nextern const struct file_operations proc_pid_smaps_operations;\nextern const struct file_operations proc_pid_smaps_rollup_operations;\nextern const struct file_operations proc_clear_refs_operations;\nextern const struct file_operations proc_pagemap_operations;\n\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nextern const struct dentry_operations proc_net_dentry_ops;\nstatic inline void pde_force_lookup(struct proc_dir_entry *pde)\n{\n\t \n\tpde->proc_dops = &proc_net_dentry_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}