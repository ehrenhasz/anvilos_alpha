{
  "module_name": "meminfo.c",
  "hash_id": "a05a89dbe13f995c91736930706dcbfe693a03a951659e2b8d28357c1c9008ac",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/meminfo.c",
  "human_readable_source": "\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/mmzone.h>\n#include <linux/memblock.h>\n#include <linux/proc_fs.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/vmstat.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#ifdef CONFIG_CMA\n#include <linux/cma.h>\n#endif\n#include <linux/zswap.h>\n#include <asm/page.h>\n#include \"internal.h\"\n\nvoid __attribute__((weak)) arch_report_meminfo(struct seq_file *m)\n{\n}\n\nstatic void show_val_kb(struct seq_file *m, const char *s, unsigned long num)\n{\n\tseq_put_decimal_ull_width(m, s, num << (PAGE_SHIFT - 10), 8);\n\tseq_write(m, \" kB\\n\", 4);\n}\n\nstatic int meminfo_proc_show(struct seq_file *m, void *v)\n{\n\tstruct sysinfo i;\n\tunsigned long committed;\n\tlong cached;\n\tlong available;\n\tunsigned long pages[NR_LRU_LISTS];\n\tunsigned long sreclaimable, sunreclaim;\n\tint lru;\n\n\tsi_meminfo(&i);\n\tsi_swapinfo(&i);\n\tcommitted = vm_memory_committed();\n\n\tcached = global_node_page_state(NR_FILE_PAGES) -\n\t\t\ttotal_swapcache_pages() - i.bufferram;\n\tif (cached < 0)\n\t\tcached = 0;\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_node_page_state(NR_LRU_BASE + lru);\n\n\tavailable = si_mem_available();\n\tsreclaimable = global_node_page_state_pages(NR_SLAB_RECLAIMABLE_B);\n\tsunreclaim = global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B);\n\n\tshow_val_kb(m, \"MemTotal:       \", i.totalram);\n\tshow_val_kb(m, \"MemFree:        \", i.freeram);\n\tshow_val_kb(m, \"MemAvailable:   \", available);\n\tshow_val_kb(m, \"Buffers:        \", i.bufferram);\n\tshow_val_kb(m, \"Cached:         \", cached);\n\tshow_val_kb(m, \"SwapCached:     \", total_swapcache_pages());\n\tshow_val_kb(m, \"Active:         \", pages[LRU_ACTIVE_ANON] +\n\t\t\t\t\t   pages[LRU_ACTIVE_FILE]);\n\tshow_val_kb(m, \"Inactive:       \", pages[LRU_INACTIVE_ANON] +\n\t\t\t\t\t   pages[LRU_INACTIVE_FILE]);\n\tshow_val_kb(m, \"Active(anon):   \", pages[LRU_ACTIVE_ANON]);\n\tshow_val_kb(m, \"Inactive(anon): \", pages[LRU_INACTIVE_ANON]);\n\tshow_val_kb(m, \"Active(file):   \", pages[LRU_ACTIVE_FILE]);\n\tshow_val_kb(m, \"Inactive(file): \", pages[LRU_INACTIVE_FILE]);\n\tshow_val_kb(m, \"Unevictable:    \", pages[LRU_UNEVICTABLE]);\n\tshow_val_kb(m, \"Mlocked:        \", global_zone_page_state(NR_MLOCK));\n\n#ifdef CONFIG_HIGHMEM\n\tshow_val_kb(m, \"HighTotal:      \", i.totalhigh);\n\tshow_val_kb(m, \"HighFree:       \", i.freehigh);\n\tshow_val_kb(m, \"LowTotal:       \", i.totalram - i.totalhigh);\n\tshow_val_kb(m, \"LowFree:        \", i.freeram - i.freehigh);\n#endif\n\n#ifndef CONFIG_MMU\n\tshow_val_kb(m, \"MmapCopy:       \",\n\t\t    (unsigned long)atomic_long_read(&mmap_pages_allocated));\n#endif\n\n\tshow_val_kb(m, \"SwapTotal:      \", i.totalswap);\n\tshow_val_kb(m, \"SwapFree:       \", i.freeswap);\n#ifdef CONFIG_ZSWAP\n\tseq_printf(m,  \"Zswap:          %8lu kB\\n\",\n\t\t   (unsigned long)(zswap_pool_total_size >> 10));\n\tseq_printf(m,  \"Zswapped:       %8lu kB\\n\",\n\t\t   (unsigned long)atomic_read(&zswap_stored_pages) <<\n\t\t   (PAGE_SHIFT - 10));\n#endif\n\tshow_val_kb(m, \"Dirty:          \",\n\t\t    global_node_page_state(NR_FILE_DIRTY));\n\tshow_val_kb(m, \"Writeback:      \",\n\t\t    global_node_page_state(NR_WRITEBACK));\n\tshow_val_kb(m, \"AnonPages:      \",\n\t\t    global_node_page_state(NR_ANON_MAPPED));\n\tshow_val_kb(m, \"Mapped:         \",\n\t\t    global_node_page_state(NR_FILE_MAPPED));\n\tshow_val_kb(m, \"Shmem:          \", i.sharedram);\n\tshow_val_kb(m, \"KReclaimable:   \", sreclaimable +\n\t\t    global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE));\n\tshow_val_kb(m, \"Slab:           \", sreclaimable + sunreclaim);\n\tshow_val_kb(m, \"SReclaimable:   \", sreclaimable);\n\tshow_val_kb(m, \"SUnreclaim:     \", sunreclaim);\n\tseq_printf(m, \"KernelStack:    %8lu kB\\n\",\n\t\t   global_node_page_state(NR_KERNEL_STACK_KB));\n#ifdef CONFIG_SHADOW_CALL_STACK\n\tseq_printf(m, \"ShadowCallStack:%8lu kB\\n\",\n\t\t   global_node_page_state(NR_KERNEL_SCS_KB));\n#endif\n\tshow_val_kb(m, \"PageTables:     \",\n\t\t    global_node_page_state(NR_PAGETABLE));\n\tshow_val_kb(m, \"SecPageTables:  \",\n\t\t    global_node_page_state(NR_SECONDARY_PAGETABLE));\n\n\tshow_val_kb(m, \"NFS_Unstable:   \", 0);\n\tshow_val_kb(m, \"Bounce:         \",\n\t\t    global_zone_page_state(NR_BOUNCE));\n\tshow_val_kb(m, \"WritebackTmp:   \",\n\t\t    global_node_page_state(NR_WRITEBACK_TEMP));\n\tshow_val_kb(m, \"CommitLimit:    \", vm_commit_limit());\n\tshow_val_kb(m, \"Committed_AS:   \", committed);\n\tseq_printf(m, \"VmallocTotal:   %8lu kB\\n\",\n\t\t   (unsigned long)VMALLOC_TOTAL >> 10);\n\tshow_val_kb(m, \"VmallocUsed:    \", vmalloc_nr_pages());\n\tshow_val_kb(m, \"VmallocChunk:   \", 0ul);\n\tshow_val_kb(m, \"Percpu:         \", pcpu_nr_pages());\n\n\tmemtest_report_meminfo(m);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tseq_printf(m, \"HardwareCorrupted: %5lu kB\\n\",\n\t\t   atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10));\n#endif\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tshow_val_kb(m, \"AnonHugePages:  \",\n\t\t    global_node_page_state(NR_ANON_THPS));\n\tshow_val_kb(m, \"ShmemHugePages: \",\n\t\t    global_node_page_state(NR_SHMEM_THPS));\n\tshow_val_kb(m, \"ShmemPmdMapped: \",\n\t\t    global_node_page_state(NR_SHMEM_PMDMAPPED));\n\tshow_val_kb(m, \"FileHugePages:  \",\n\t\t    global_node_page_state(NR_FILE_THPS));\n\tshow_val_kb(m, \"FilePmdMapped:  \",\n\t\t    global_node_page_state(NR_FILE_PMDMAPPED));\n#endif\n\n#ifdef CONFIG_CMA\n\tshow_val_kb(m, \"CmaTotal:       \", totalcma_pages);\n\tshow_val_kb(m, \"CmaFree:        \",\n\t\t    global_zone_page_state(NR_FREE_CMA_PAGES));\n#endif\n\n#ifdef CONFIG_UNACCEPTED_MEMORY\n\tshow_val_kb(m, \"Unaccepted:     \",\n\t\t    global_zone_page_state(NR_UNACCEPTED));\n#endif\n\n\thugetlb_report_meminfo(m);\n\n\tarch_report_meminfo(m);\n\n\treturn 0;\n}\n\nstatic int __init proc_meminfo_init(void)\n{\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_create_single(\"meminfo\", 0, NULL, meminfo_proc_show);\n\tpde_make_permanent(pde);\n\treturn 0;\n}\nfs_initcall(proc_meminfo_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}