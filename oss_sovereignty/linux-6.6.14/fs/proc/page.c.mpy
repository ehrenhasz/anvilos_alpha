{
  "module_name": "page.c",
  "hash_id": "d178a027f96c63f85babba494dd055d3835b640ff10edf34708ed345ed9625b7",
  "original_prompt": "Ingested from linux-6.6.14/fs/proc/page.c",
  "human_readable_source": "\n#include <linux/memblock.h>\n#include <linux/compiler.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/ksm.h>\n#include <linux/mm.h>\n#include <linux/mmzone.h>\n#include <linux/huge_mm.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/hugetlb.h>\n#include <linux/memremap.h>\n#include <linux/memcontrol.h>\n#include <linux/mmu_notifier.h>\n#include <linux/page_idle.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KPMSIZE sizeof(u64)\n#define KPMMASK (KPMSIZE - 1)\n#define KPMBITS (KPMSIZE * BITS_PER_BYTE)\n\nstatic inline unsigned long get_max_dump_pfn(void)\n{\n#ifdef CONFIG_SPARSEMEM\n\t \n\treturn round_up(max_pfn, PAGES_PER_SECTION);\n#else\n\treturn max_pfn;\n#endif\n}\n\n \nstatic ssize_t kpagecount_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst unsigned long max_dump_pfn = get_max_dump_pfn();\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\tu64 pcount;\n\n\tpfn = src / KPMSIZE;\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\tif (src >= max_dump_pfn * KPMSIZE)\n\t\treturn 0;\n\tcount = min_t(unsigned long, count, (max_dump_pfn * KPMSIZE) - src);\n\n\twhile (count > 0) {\n\t\t \n\t\tppage = pfn_to_online_page(pfn);\n\n\t\tif (!ppage || PageSlab(ppage) || page_has_type(ppage))\n\t\t\tpcount = 0;\n\t\telse\n\t\t\tpcount = page_mapcount(ppage);\n\n\t\tif (put_user(pcount, out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\n\t\tcond_resched();\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}\n\nstatic const struct proc_ops kpagecount_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_lseek\t= mem_lseek,\n\t.proc_read\t= kpagecount_read,\n};\n\n \n\nstatic inline u64 kpf_copy_bit(u64 kflags, int ubit, int kbit)\n{\n\treturn ((kflags >> kbit) & 1) << ubit;\n}\n\nu64 stable_page_flags(struct page *page)\n{\n\tu64 k;\n\tu64 u;\n\n\t \n\tif (!page)\n\t\treturn 1 << KPF_NOPAGE;\n\n\tk = page->flags;\n\tu = 0;\n\n\t \n\tif (!PageSlab(page) && page_mapped(page))\n\t\tu |= 1 << KPF_MMAP;\n\tif (PageAnon(page))\n\t\tu |= 1 << KPF_ANON;\n\tif (PageKsm(page))\n\t\tu |= 1 << KPF_KSM;\n\n\t \n\tif (PageHead(page))\n\t\tu |= 1 << KPF_COMPOUND_HEAD;\n\tif (PageTail(page))\n\t\tu |= 1 << KPF_COMPOUND_TAIL;\n\tif (PageHuge(page))\n\t\tu |= 1 << KPF_HUGE;\n\t \n\telse if (PageTransCompound(page)) {\n\t\tstruct page *head = compound_head(page);\n\n\t\tif (PageLRU(head) || PageAnon(head))\n\t\t\tu |= 1 << KPF_THP;\n\t\telse if (is_huge_zero_page(head)) {\n\t\t\tu |= 1 << KPF_ZERO_PAGE;\n\t\t\tu |= 1 << KPF_THP;\n\t\t}\n\t} else if (is_zero_pfn(page_to_pfn(page)))\n\t\tu |= 1 << KPF_ZERO_PAGE;\n\n\n\t \n\tif (PageBuddy(page))\n\t\tu |= 1 << KPF_BUDDY;\n\telse if (page_count(page) == 0 && is_free_buddy_page(page))\n\t\tu |= 1 << KPF_BUDDY;\n\n\tif (PageOffline(page))\n\t\tu |= 1 << KPF_OFFLINE;\n\tif (PageTable(page))\n\t\tu |= 1 << KPF_PGTABLE;\n\n\tif (page_is_idle(page))\n\t\tu |= 1 << KPF_IDLE;\n\n\tu |= kpf_copy_bit(k, KPF_LOCKED,\tPG_locked);\n\n\tu |= kpf_copy_bit(k, KPF_SLAB,\t\tPG_slab);\n\tif (PageTail(page) && PageSlab(page))\n\t\tu |= 1 << KPF_SLAB;\n\n\tu |= kpf_copy_bit(k, KPF_ERROR,\t\tPG_error);\n\tu |= kpf_copy_bit(k, KPF_DIRTY,\t\tPG_dirty);\n\tu |= kpf_copy_bit(k, KPF_UPTODATE,\tPG_uptodate);\n\tu |= kpf_copy_bit(k, KPF_WRITEBACK,\tPG_writeback);\n\n\tu |= kpf_copy_bit(k, KPF_LRU,\t\tPG_lru);\n\tu |= kpf_copy_bit(k, KPF_REFERENCED,\tPG_referenced);\n\tu |= kpf_copy_bit(k, KPF_ACTIVE,\tPG_active);\n\tu |= kpf_copy_bit(k, KPF_RECLAIM,\tPG_reclaim);\n\n\tif (PageSwapCache(page))\n\t\tu |= 1 << KPF_SWAPCACHE;\n\tu |= kpf_copy_bit(k, KPF_SWAPBACKED,\tPG_swapbacked);\n\n\tu |= kpf_copy_bit(k, KPF_UNEVICTABLE,\tPG_unevictable);\n\tu |= kpf_copy_bit(k, KPF_MLOCKED,\tPG_mlocked);\n\n#ifdef CONFIG_MEMORY_FAILURE\n\tu |= kpf_copy_bit(k, KPF_HWPOISON,\tPG_hwpoison);\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tu |= kpf_copy_bit(k, KPF_UNCACHED,\tPG_uncached);\n#endif\n\n\tu |= kpf_copy_bit(k, KPF_RESERVED,\tPG_reserved);\n\tu |= kpf_copy_bit(k, KPF_MAPPEDTODISK,\tPG_mappedtodisk);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE,\tPG_private);\n\tu |= kpf_copy_bit(k, KPF_PRIVATE_2,\tPG_private_2);\n\tu |= kpf_copy_bit(k, KPF_OWNER_PRIVATE,\tPG_owner_priv_1);\n\tu |= kpf_copy_bit(k, KPF_ARCH,\t\tPG_arch_1);\n#ifdef CONFIG_ARCH_USES_PG_ARCH_X\n\tu |= kpf_copy_bit(k, KPF_ARCH_2,\tPG_arch_2);\n\tu |= kpf_copy_bit(k, KPF_ARCH_3,\tPG_arch_3);\n#endif\n\n\treturn u;\n};\n\nstatic ssize_t kpageflags_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst unsigned long max_dump_pfn = get_max_dump_pfn();\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\n\tpfn = src / KPMSIZE;\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\tif (src >= max_dump_pfn * KPMSIZE)\n\t\treturn 0;\n\tcount = min_t(unsigned long, count, (max_dump_pfn * KPMSIZE) - src);\n\n\twhile (count > 0) {\n\t\t \n\t\tppage = pfn_to_online_page(pfn);\n\n\t\tif (put_user(stable_page_flags(ppage), out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\n\t\tcond_resched();\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}\n\nstatic const struct proc_ops kpageflags_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_lseek\t= mem_lseek,\n\t.proc_read\t= kpageflags_read,\n};\n\n#ifdef CONFIG_MEMCG\nstatic ssize_t kpagecgroup_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tconst unsigned long max_dump_pfn = get_max_dump_pfn();\n\tu64 __user *out = (u64 __user *)buf;\n\tstruct page *ppage;\n\tunsigned long src = *ppos;\n\tunsigned long pfn;\n\tssize_t ret = 0;\n\tu64 ino;\n\n\tpfn = src / KPMSIZE;\n\tif (src & KPMMASK || count & KPMMASK)\n\t\treturn -EINVAL;\n\tif (src >= max_dump_pfn * KPMSIZE)\n\t\treturn 0;\n\tcount = min_t(unsigned long, count, (max_dump_pfn * KPMSIZE) - src);\n\n\twhile (count > 0) {\n\t\t \n\t\tppage = pfn_to_online_page(pfn);\n\n\t\tif (ppage)\n\t\t\tino = page_cgroup_ino(ppage);\n\t\telse\n\t\t\tino = 0;\n\n\t\tif (put_user(ino, out)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpfn++;\n\t\tout++;\n\t\tcount -= KPMSIZE;\n\n\t\tcond_resched();\n\t}\n\n\t*ppos += (char __user *)out - buf;\n\tif (!ret)\n\t\tret = (char __user *)out - buf;\n\treturn ret;\n}\n\nstatic const struct proc_ops kpagecgroup_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_lseek\t= mem_lseek,\n\t.proc_read\t= kpagecgroup_read,\n};\n#endif  \n\nstatic int __init proc_page_init(void)\n{\n\tproc_create(\"kpagecount\", S_IRUSR, NULL, &kpagecount_proc_ops);\n\tproc_create(\"kpageflags\", S_IRUSR, NULL, &kpageflags_proc_ops);\n#ifdef CONFIG_MEMCG\n\tproc_create(\"kpagecgroup\", S_IRUSR, NULL, &kpagecgroup_proc_ops);\n#endif\n\treturn 0;\n}\nfs_initcall(proc_page_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}