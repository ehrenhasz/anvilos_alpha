{
  "module_name": "file.c",
  "hash_id": "15b0669d13fa9049b55b10fa251462e0cf7557abc1a80545b131d6ca9d07aa59",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/file.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n#include <linux/mpage.h>\n#include <linux/iomap.h>\n#include <linux/fiemap.h>\n\n#define BLOCKS(size) (((size) + 511) >> 9)\n\nstatic int hpfs_file_release(struct inode *inode, struct file *file)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_write_if_changed(inode);\n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}\n\nint hpfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = file_write_and_wait_range(file, start, end);\n\tif (ret)\n\t\treturn ret;\n\treturn sync_blockdev(inode->i_sb->s_bdev);\n}\n\n \n\nstatic secno hpfs_bmap(struct inode *inode, unsigned file_secno, unsigned *n_secs)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tunsigned n, disk_secno;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tif (BLOCKS(hpfs_i(inode)->mmu_private) <= file_secno) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\tif (!(fnode = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) return 0;\n\tdisk_secno = hpfs_bplus_lookup(inode->i_sb, inode, &fnode->btree, file_secno, bh);\n\tif (disk_secno == -1) return 0;\n\tif (hpfs_chk_sectors(inode->i_sb, disk_secno, 1, \"bmap\")) return 0;\n\tn = file_secno - hpfs_inode->i_file_sec;\n\tif (n < hpfs_inode->i_n_secs) {\n\t\t*n_secs = hpfs_inode->i_n_secs - n;\n\t\treturn hpfs_inode->i_disk_sec + n;\n\t}\n\t*n_secs = 1;\n\treturn disk_secno;\n}\n\nvoid hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return  ;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}\n\nstatic int hpfs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tint r;\n\tsecno s;\n\tunsigned n_secs;\n\thpfs_lock(inode->i_sb);\n\ts = hpfs_bmap(inode, iblock, &n_secs);\n\tif (s) {\n\t\tif (bh_result->b_size >> 9 < n_secs)\n\t\t\tn_secs = bh_result->b_size >> 9;\n\t\tn_secs = hpfs_search_hotfix_map_for_range(inode->i_sb, s, n_secs);\n\t\tif (unlikely(!n_secs)) {\n\t\t\ts = hpfs_search_hotfix_map(inode->i_sb, s);\n\t\t\tn_secs = 1;\n\t\t}\n\t\tmap_bh(bh_result, inode->i_sb, s);\n\t\tbh_result->b_size = n_secs << 9;\n\t\tgoto ret_0;\n\t}\n\tif (!create) goto ret_0;\n\tif (iblock<<9 != hpfs_i(inode)->mmu_private) {\n\t\tBUG();\n\t\tr = -EIO;\n\t\tgoto ret_r;\n\t}\n\tif ((s = hpfs_add_sector_to_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1)) == -1) {\n\t\thpfs_truncate_btree(inode->i_sb, inode->i_ino, 1, inode->i_blocks - 1);\n\t\tr = -ENOSPC;\n\t\tgoto ret_r;\n\t}\n\tinode->i_blocks++;\n\thpfs_i(inode)->mmu_private += 512;\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, hpfs_search_hotfix_map(inode->i_sb, s));\n\tret_0:\n\tr = 0;\n\tret_r:\n\thpfs_unlock(inode->i_sb);\n\treturn r;\n}\n\nstatic int hpfs_iomap_begin(struct inode *inode, loff_t offset, loff_t length,\n\t\tunsigned flags, struct iomap *iomap, struct iomap *srcmap)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int blkbits = inode->i_blkbits;\n\tunsigned int n_secs;\n\tsecno s;\n\n\tif (WARN_ON_ONCE(flags & (IOMAP_WRITE | IOMAP_ZERO)))\n\t\treturn -EINVAL;\n\n\tiomap->bdev = inode->i_sb->s_bdev;\n\tiomap->offset = offset;\n\n\thpfs_lock(sb);\n\ts = hpfs_bmap(inode, offset >> blkbits, &n_secs);\n\tif (s) {\n\t\tn_secs = hpfs_search_hotfix_map_for_range(sb, s,\n\t\t\t\tmin_t(loff_t, n_secs, length));\n\t\tif (unlikely(!n_secs)) {\n\t\t\ts = hpfs_search_hotfix_map(sb, s);\n\t\t\tn_secs = 1;\n\t\t}\n\t\tiomap->type = IOMAP_MAPPED;\n\t\tiomap->flags = IOMAP_F_MERGED;\n\t\tiomap->addr = (u64)s << blkbits;\n\t\tiomap->length = (u64)n_secs << blkbits;\n\t} else {\n\t\tiomap->type = IOMAP_HOLE;\n\t\tiomap->addr = IOMAP_NULL_ADDR;\n\t\tiomap->length = 1 << blkbits;\n\t}\n\n\thpfs_unlock(sb);\n\treturn 0;\n}\n\nstatic const struct iomap_ops hpfs_iomap_ops = {\n\t.iomap_begin\t\t= hpfs_iomap_begin,\n};\n\nstatic int hpfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, hpfs_get_block);\n}\n\nstatic void hpfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, hpfs_get_block);\n}\n\nstatic int hpfs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hpfs_get_block);\n}\n\nstatic void hpfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\thpfs_unlock(inode->i_sb);\n}\n\nstatic int hpfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t\thpfs_get_block,\n\t\t\t\t&hpfs_i(mapping->host)->mmu_private);\n\tif (unlikely(ret))\n\t\thpfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic int hpfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *pagep, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint err;\n\terr = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);\n\tif (err < len)\n\t\thpfs_write_failed(mapping, pos + len);\n\tif (!(err < 0)) {\n\t\t \n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_i(inode)->i_dirty = 1;\n\t\thpfs_unlock(inode->i_sb);\n\t}\n\treturn err;\n}\n\nstatic sector_t _hpfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hpfs_get_block);\n}\n\nstatic int hpfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo, u64 start, u64 len)\n{\n\tint ret;\n\n\tinode_lock(inode);\n\tlen = min_t(u64, len, i_size_read(inode));\n\tret = iomap_fiemap(inode, fieinfo, start, len, &hpfs_iomap_ops);\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nconst struct address_space_operations hpfs_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio = hpfs_read_folio,\n\t.readahead = hpfs_readahead,\n\t.writepages = hpfs_writepages,\n\t.write_begin = hpfs_write_begin,\n\t.write_end = hpfs_write_end,\n\t.bmap = _hpfs_bmap,\n\t.migrate_folio = buffer_migrate_folio,\n};\n\nconst struct file_operations hpfs_file_ops =\n{\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.release\t= hpfs_file_release,\n\t.fsync\t\t= hpfs_file_fsync,\n\t.splice_read\t= filemap_splice_read,\n\t.unlocked_ioctl\t= hpfs_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n\nconst struct inode_operations hpfs_file_iops =\n{\n\t.setattr\t= hpfs_setattr,\n\t.fiemap\t\t= hpfs_fiemap,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}