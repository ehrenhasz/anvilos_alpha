{
  "module_name": "map.c",
  "hash_id": "9829a428d623aae93aa2faccc1de40b48a6bbe941471a2891d63604c8c074481",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/map.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}\n\nvoid hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}\n\n \n\nunsigned char *hpfs_load_code_page(struct super_block *s, secno cps)\n{\n\tstruct buffer_head *bh;\n\tsecno cpds;\n\tunsigned cpi;\n\tunsigned char *ptr;\n\tunsigned char *cp_table;\n\tint i;\n\tstruct code_page_data *cpd;\n\tstruct code_page_directory *cp = hpfs_map_sector(s, cps, &bh, 0);\n\tif (!cp) return NULL;\n\tif (le32_to_cpu(cp->magic) != CP_DIR_MAGIC) {\n\t\tpr_err(\"Code page directory magic doesn't match (magic = %08x)\\n\",\n\t\t\tle32_to_cpu(cp->magic));\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tif (!le32_to_cpu(cp->n_code_pages)) {\n\t\tpr_err(\"n_code_pages == 0\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tcpds = le32_to_cpu(cp->array[0].code_page_data);\n\tcpi = le16_to_cpu(cp->array[0].index);\n\tbrelse(bh);\n\n\tif (cpi >= 3) {\n\t\tpr_err(\"Code page index out of array\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif (!(cpd = hpfs_map_sector(s, cpds, &bh, 0))) return NULL;\n\tif (le16_to_cpu(cpd->offs[cpi]) > 0x178) {\n\t\tpr_err(\"Code page index out of sector\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tptr = (unsigned char *)cpd + le16_to_cpu(cpd->offs[cpi]) + 6;\n\tif (!(cp_table = kmalloc(256, GFP_KERNEL))) {\n\t\tpr_err(\"out of memory for code page table\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tmemcpy(cp_table, ptr, 128);\n\tbrelse(bh);\n\n\t \n\n\tfor (i=128; i<256; i++) cp_table[i]=i;\n\tfor (i=128; i<256; i++) if (cp_table[i-128]!=i && cp_table[i-128]>=128)\n\t\tcp_table[cp_table[i-128]] = i;\n\t\n\treturn cp_table;\n}\n\n__le32 *hpfs_load_bitmap_directory(struct super_block *s, secno bmp)\n{\n\tstruct buffer_head *bh;\n\tint n = (hpfs_sb(s)->sb_fs_size + 0x200000 - 1) >> 21;\n\tint i;\n\t__le32 *b;\n\tif (!(b = kmalloc_array(n, 512, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for bitmap directory\\n\");\n\t\treturn NULL;\n\t}\t\n\tfor (i=0;i<n;i++) {\n\t\t__le32 *d = hpfs_map_sector(s, bmp+i, &bh, n - i - 1);\n\t\tif (!d) {\n\t\t\tkfree(b);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy((char *)b + 512 * i, d, 512);\n\t\tbrelse(bh);\n\t}\n\treturn b;\n}\n\nvoid hpfs_load_hotfix_map(struct super_block *s, struct hpfs_spare_block *spareblock)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *directory;\n\tu32 n_hotfixes, n_used_hotfixes;\n\tunsigned i;\n\n\tn_hotfixes = le32_to_cpu(spareblock->n_spares);\n\tn_used_hotfixes = le32_to_cpu(spareblock->n_spares_used);\n\n\tif (n_hotfixes > 256 || n_used_hotfixes > n_hotfixes) {\n\t\thpfs_error(s, \"invalid number of hotfixes: %u, used: %u\", n_hotfixes, n_used_hotfixes);\n\t\treturn;\n\t}\n\tif (!(directory = hpfs_map_4sectors(s, le32_to_cpu(spareblock->hotfix_map), &qbh, 0))) {\n\t\thpfs_error(s, \"can't load hotfix map\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < n_used_hotfixes; i++) {\n\t\thpfs_sb(s)->hotfix_from[i] = le32_to_cpu(directory[i]);\n\t\thpfs_sb(s)->hotfix_to[i] = le32_to_cpu(directory[n_hotfixes + i]);\n\t}\n\thpfs_sb(s)->n_hotfixes = n_used_hotfixes;\n\thpfs_brelse4(&qbh);\n}\n\n \n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}\n\n \n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t \n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & SB_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}\n\ndnode_secno hpfs_fnode_dno(struct super_block *s, ino_t ino)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tdnode_secno dno;\n\n\tfnode = hpfs_map_fnode(s, ino, &bh);\n\tif (!fnode)\n\t\treturn 0;\n\n\tdno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\tbrelse(bh);\n\treturn dno;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}