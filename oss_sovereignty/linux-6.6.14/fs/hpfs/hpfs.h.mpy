{
  "module_name": "hpfs.h",
  "hash_id": "d872603ae46cbde9c0a53ba1ab6fcf61c7d8d1d87d93bc8c160ca136253fc8d9",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/hpfs.h",
  "human_readable_source": " \n \n\n \n\n#if !defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)\n#error unknown endian\n#endif\n\n \n\ntypedef u32 secno;\t\t\t \n\ntypedef secno dnode_secno;\t\t \ntypedef secno fnode_secno;\t\t \ntypedef secno anode_secno;\t\t \n\ntypedef u32 time32_t;\t\t \n\n \n\n \n\n#define BB_MAGIC 0xaa55\n\nstruct hpfs_boot_block\n{\n  u8 jmp[3];\n  u8 oem_id[8];\n  u8 bytes_per_sector[2];\t \n  u8 sectors_per_cluster;\n  u8 n_reserved_sectors[2];\n  u8 n_fats;\n  u8 n_rootdir_entries[2];\n  u8 n_sectors_s[2];\n  u8 media_byte;\n  __le16 sectors_per_fat;\n  __le16 sectors_per_track;\n  __le16 heads_per_cyl;\n  __le32 n_hidden_sectors;\n  __le32 n_sectors_l;\t\t \n  u8 drive_number;\n  u8 mbz;\n  u8 sig_28h;\t\t\t \n  u8 vol_serno[4];\n  u8 vol_label[11];\n  u8 sig_hpfs[8];\t\t \n  u8 pad[448];\n  __le16 magic;\t\t\t \n};\n\n\n \n\n \n\n#define SB_MAGIC 0xf995e849\n\nstruct hpfs_super_block\n{\n  __le32 magic;\t\t\t\t \n  __le32 magic1;\t\t\t \n  u8 version;\t\t\t\t \n  u8 funcversion;\t\t\t \n  __le16 zero;\t\t\t\t \n  __le32 root;\t\t\t\t \n  __le32 n_sectors;\t\t\t \n  __le32 n_badblocks;\t\t\t \n  __le32 bitmaps;\t\t\t \n  __le32 zero1;\t\t\t\t \n  __le32 badblocks;\t\t\t \n  __le32 zero3;\t\t\t\t \n  __le32 last_chkdsk;\t\t\t \n  __le32 last_optimize;\t\t\t \n  __le32 n_dir_band;\t\t\t \n  __le32 dir_band_start;\t\t\t \n  __le32 dir_band_end;\t\t\t \n  __le32 dir_band_bitmap;\t\t \n  u8 volume_name[32];\t\t\t \n  __le32 user_id_table;\t\t\t \n  u32 zero6[103];\t\t\t \n};\n\n\n \n\n \n\n#define SP_MAGIC 0xf9911849\n\nstruct hpfs_spare_block\n{\n  __le32 magic;\t\t\t\t \n  __le32 magic1;\t\t\t\t \n\n#ifdef __LITTLE_ENDIAN\n  u8 dirty: 1;\t\t\t\t \n  u8 sparedir_used: 1;\t\t\t \n  u8 hotfixes_used: 1;\t\t\t \n  u8 bad_sector: 1;\t\t\t \n  u8 bad_bitmap: 1;\t\t\t \n  u8 fast: 1;\t\t\t\t \n  u8 old_wrote: 1;\t\t\t \n  u8 old_wrote_1: 1;\t\t\t \n#else\n  u8 old_wrote_1: 1;\t\t\t \n  u8 old_wrote: 1;\t\t\t \n  u8 fast: 1;\t\t\t\t \n  u8 bad_bitmap: 1;\t\t\t \n  u8 bad_sector: 1;\t\t\t \n  u8 hotfixes_used: 1;\t\t\t \n  u8 sparedir_used: 1;\t\t\t \n  u8 dirty: 1;\t\t\t\t \n#endif\n\n#ifdef __LITTLE_ENDIAN\n  u8 install_dasd_limits: 1;\t\t \n  u8 resynch_dasd_limits: 1;\n  u8 dasd_limits_operational: 1;\n  u8 multimedia_active: 1;\n  u8 dce_acls_active: 1;\n  u8 dasd_limits_dirty: 1;\n  u8 flag67: 2;\n#else\n  u8 flag67: 2;\n  u8 dasd_limits_dirty: 1;\n  u8 dce_acls_active: 1;\n  u8 multimedia_active: 1;\n  u8 dasd_limits_operational: 1;\n  u8 resynch_dasd_limits: 1;\n  u8 install_dasd_limits: 1;\t\t \n#endif\n\n  u8 mm_contlgulty;\n  u8 unused;\n\n  __le32 hotfix_map;\t\t\t \n  __le32 n_spares_used;\t\t\t \n  __le32 n_spares;\t\t\t \n  __le32 n_dnode_spares_free;\t\t \n  __le32 n_dnode_spares;\t\t \n  __le32 code_page_dir;\t\t\t \n  __le32 n_code_pages;\t\t\t \n  __le32 super_crc;\t\t\t \n  __le32 spare_crc;\t\t\t \n  __le32 zero1[15];\t\t\t \n  __le32 spare_dnodes[100];\t\t \n  __le32 zero2[1];\t\t\t \n};\n\n \n\n#define BAD_MAGIC 0\n       \n \n\n\n \n\n\n \n\n \n\n#define CP_DIR_MAGIC 0x494521f7\n\nstruct code_page_directory\n{\n  __le32 magic;\t\t\t\t \n  __le32 n_code_pages;\t\t\t \n  __le32 zero1[2];\n  struct {\n    __le16 ix;\t\t\t\t \n    __le16 code_page_number;\t\t \n    __le32 bounds;\t\t\t \n    __le32 code_page_data;\t\t \n    __le16 index;\t\t\t \n    __le16 unknown;\t\t\t \n  } array[31];\t\t\t\t \n};\n\n \n\n#define CP_DATA_MAGIC 0x894521f7\n\nstruct code_page_data\n{\n  __le32 magic;\t\t\t\t \n  __le32 n_used;\t\t\t \n  __le32 bounds[3];\t\t\t \n  __le16 offs[3];\t\t\t \n  struct {\n    __le16 ix;\t\t\t\t \n    __le16 code_page_number;\t\t \n    __le16 unknown;\t\t\t \n    u8 map[128];\t\t\t \n    __le16 zero2;\n  } code_page[3];\n  u8 incognita[78];\n};\n\n\n \n\n\n \n\n \n\n#define DNODE_MAGIC   0x77e40aae\n\nstruct dnode {\n  __le32 magic;\t\t\t\t \n  __le32 first_free;\t\t\t \n#ifdef __LITTLE_ENDIAN\n  u8 root_dnode: 1;\t\t\t \n  u8 increment_me: 7;\t\t\t \n\t\t\t\t\t \n#else\n  u8 increment_me: 7;\t\t\t \n\t\t\t\t\t \n  u8 root_dnode: 1;\t\t\t \n#endif\n  u8 increment_me2[3];\n  __le32 up;\t\t\t\t \n  __le32 self;\t\t\t \n  u8 dirent[2028];\t\t\t \n};\n\nstruct hpfs_dirent {\n  __le16 length;\t\t\t \n\n#ifdef __LITTLE_ENDIAN\n  u8 first: 1;\t\t\t\t \n  u8 has_acl: 1;\n  u8 down: 1;\t\t\t\t \n  u8 last: 1;\t\t\t\t \n  u8 has_ea: 1;\t\t\t\t \n  u8 has_xtd_perm: 1;\t\t\t \n  u8 has_explicit_acl: 1;\n  u8 has_needea: 1;\t\t\t \n#else\n  u8 has_needea: 1;\t\t\t \n  u8 has_explicit_acl: 1;\n  u8 has_xtd_perm: 1;\t\t\t \n  u8 has_ea: 1;\t\t\t\t \n  u8 last: 1;\t\t\t\t \n  u8 down: 1;\t\t\t\t \n  u8 has_acl: 1;\n  u8 first: 1;\t\t\t\t \n#endif\n\n#ifdef __LITTLE_ENDIAN\n  u8 read_only: 1;\t\t\t \n  u8 hidden: 1;\t\t\t\t \n  u8 system: 1;\t\t\t\t \n  u8 flag11: 1;\t\t\t\t \n  u8 directory: 1;\t\t\t \n  u8 archive: 1;\t\t\t \n  u8 not_8x3: 1;\t\t\t \n  u8 flag15: 1;\n#else\n  u8 flag15: 1;\n  u8 not_8x3: 1;\t\t\t \n  u8 archive: 1;\t\t\t \n  u8 directory: 1;\t\t\t \n  u8 flag11: 1;\t\t\t\t \n  u8 system: 1;\t\t\t\t \n  u8 hidden: 1;\t\t\t\t \n  u8 read_only: 1;\t\t\t \n#endif\n\n  __le32 fnode;\t\t\t\t \n  __le32 write_date;\t\t\t \n  __le32 file_size;\t\t\t \n  __le32 read_date;\t\t\t \n  __le32 creation_date;\t\t\t \n  __le32 ea_size;\t\t\t \n  u8 no_of_acls;\t\t\t \n  u8 ix;\t\t\t\t \n  u8 namelen;\t\t\t\t \n  u8 name[];\t\t\t\t \n   \n};\n\n\n \n\n \n\nstruct bplus_leaf_node\n{\n  __le32 file_secno;\t\t\t \n  __le32 length;\t\t\t \n  __le32 disk_secno;\t\t\t \n};\n\nstruct bplus_internal_node\n{\n  __le32 file_secno;\t\t\t \n  __le32 down;\t\t\t\t \n};\n\nenum {\n\tBP_hbff = 1,\n\tBP_fnode_parent = 0x20,\n\tBP_binary_search = 0x40,\n\tBP_internal = 0x80\n};\nstruct bplus_header\n{\n  u8 flags;\t\t\t\t \n  u8 fill[3];\n  u8 n_free_nodes;\t\t\t \n  u8 n_used_nodes;\t\t\t \n  __le16 first_free;\t\t\t \n  union {\n\t \n\tDECLARE_FLEX_ARRAY(struct bplus_internal_node, internal);\n\t \n\tDECLARE_FLEX_ARRAY(struct bplus_leaf_node, external);\n  } u;\n};\n\nstatic inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}\n\nstatic inline bool bp_fnode_parent(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_fnode_parent;\n}\n\n \n\n \n\n#define FNODE_MAGIC 0xf7e40aae\n\nenum {FNODE_anode = cpu_to_le16(2), FNODE_dir = cpu_to_le16(256)};\nstruct fnode\n{\n  __le32 magic;\t\t\t\t \n  __le32 zero1[2];\t\t\t \n  u8 len, name[15];\t\t\t \n  __le32 up;\t\t\t\t \n  __le32 acl_size_l;\n  __le32 acl_secno;\n  __le16 acl_size_s;\n  u8 acl_anode;\n  u8 zero2;\t\t\t\t \n  __le32 ea_size_l;\t\t\t \n  __le32 ea_secno;\t\t\t \n  __le16 ea_size_s;\t\t\t \n\n  __le16 flags;\t\t\t\t \n\t\t\t\t\t \n  struct bplus_header btree;\t\t \n  union {\n    struct bplus_leaf_node external[8];\n    struct bplus_internal_node internal[12];\n  } u;\n\n  __le32 file_size;\t\t\t \n  __le32 n_needea;\t\t\t \n  u8 user_id[16];\t\t\t \n  __le16 ea_offs;\t\t\t \n  u8 dasd_limit_treshhold;\n  u8 dasd_limit_delta;\n  __le32 dasd_limit;\n  __le32 dasd_usage;\n  u8 ea[316];\t\t\t\t \n};\n\nstatic inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}\n\nstatic inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}\n\n\n \n\n#define ANODE_MAGIC 0x37e40aae\n\nstruct anode\n{\n  __le32 magic;\t\t\t\t \n  __le32 self;\t\t\t\t \n  __le32 up;\t\t\t\t \n\n  struct bplus_header btree;\t\t \n  union {\n    struct bplus_leaf_node external[40];\n    struct bplus_internal_node internal[60];\n  } u;\n\n  __le32 fill[3];\t\t\t \n};\n\n\n \n\nenum {EA_indirect = 1, EA_anode = 2, EA_needea = 128 };\nstruct extended_attribute\n{\n  u8 flags;\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n  u8 namelen;\t\t\t\t \n  u8 valuelen_lo;\t\t\t \n  u8 valuelen_hi;\t\t\t \n  u8 name[];\n   \n};\n\nstatic inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}\n\nstatic inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}