{
  "module_name": "ea.c",
  "hash_id": "c8991c291abe687a87e7659c73686d7c25dd66f93e78d2a84e52d2ce87292c58",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/ea.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\n \n\nvoid hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tunsigned pos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tstruct extended_attribute *ea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (ea_indirect(ea)) {\n\t\t\tif (ea_valuelen(ea) != 8) {\n\t\t\t\thpfs_error(s, \"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\",\n\t\t\t\t\tano ? \"anode\" : \"sectors\", a, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\n\t\t\t\treturn;\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\n\telse {\n\t\tstruct buffer_head *bh;\n\t\tstruct anode *anode;\n\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\thpfs_remove_btree(s, &anode->btree);\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, a, 1);\n\t\t}\n\t}\n}\n\nstatic char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\n{\n\tchar *ret;\n\tif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\n\t\tpr_err(\"out of memory for EA\\n\");\n\t\treturn NULL;\n\t}\n\tif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret[size] = 0;\n\treturn ret;\n}\n\nstatic void set_indirect_ea(struct super_block *s, int ano, secno a,\n\t\t\t    const char *data, int size)\n{\n\thpfs_ea_write(s, a, ano, 0, size, data);\n}\n\n \n\nint hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\n\t\tchar *buf, int size)\n{\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tchar ex[4 + 255 + 1 + 8];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buf, ea_data(ea), ea_valuelen(ea));\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn -EIO;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\n\t\t\t\treturn -EIO;\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn -ENOENT;\nindirect:\n\tif (ea_len(ea) >= size)\n\t\treturn -EINVAL;\n\tif (hpfs_ea_read(s, ea_sec(ea), ea_in_anode(ea), 0, ea_len(ea), buf))\n\t\treturn -EIO;\n\tbuf[ea_len(ea)] = 0;\n\treturn 0;\n}\n\n \nchar *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\n{\n\tchar *ret;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ret, ea_data(ea), ea_valuelen(ea));\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn NULL;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\n\t\t\t\tkfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn NULL;\n}\n\n \n\nvoid hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t \n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t \n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}\n\t\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}