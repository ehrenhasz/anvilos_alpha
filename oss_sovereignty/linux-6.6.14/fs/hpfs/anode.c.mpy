{
  "module_name": "anode.c",
  "hash_id": "4b570c86ce2b4425fcca2e88c35ed625993baca0bdd2d214bbf73efe9ef4539c",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/anode.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\n \n\nsecno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}\n\n \n\nsecno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s,  0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32( -1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t \n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}\n\n \n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}\n\n \n\nstatic secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}\n\nint hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}\n\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}\n\n \n\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno));  \n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}\n\n \n\nvoid hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end;\n\tif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\n\tif (!fnode_is_dir(fnode)) hpfs_remove_btree(s, &fnode->btree);\n\telse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\n\tea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (ea_indirect(ea))\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\thpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l));\n\tbrelse(bh);\n\thpfs_free_sectors(s, fno, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}