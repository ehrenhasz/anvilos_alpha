{
  "module_name": "buffer.c",
  "hash_id": "aa946e092dd29ef03405f61265af9108d1944ca6d3265310a6f57dcce83bcc60",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/buffer.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"hpfs_fn.h\"\n\nsecno hpfs_search_hotfix_map(struct super_block *s, secno sec)\n{\n\tunsigned i;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tfor (i = 0; unlikely(i < sbi->n_hotfixes); i++) {\n\t\tif (sbi->hotfix_from[i] == sec) {\n\t\t\treturn sbi->hotfix_to[i];\n\t\t}\n\t}\n\treturn sec;\n}\n\nunsigned hpfs_search_hotfix_map_for_range(struct super_block *s, secno sec, unsigned n)\n{\n\tunsigned i;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tfor (i = 0; unlikely(i < sbi->n_hotfixes); i++) {\n\t\tif (sbi->hotfix_from[i] >= sec && sbi->hotfix_from[i] < sec + n) {\n\t\t\tn = sbi->hotfix_from[i] - sec;\n\t\t}\n\t}\n\treturn n;\n}\n\nvoid hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tif (unlikely(hpfs_search_hotfix_map_for_range(s, secno, n) != n))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}\n\n \n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, hpfs_search_hotfix_map(s, secno));\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}\n\n \n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t \n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, hpfs_search_hotfix_map(s, secno))) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}\n\n \n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!hpfs_map_sector(s, secno + 0, &qbh->bh[0], 0)) goto bail0;\n\tif (!hpfs_map_sector(s, secno + 1, &qbh->bh[1], 0)) goto bail1;\n\tif (!hpfs_map_sector(s, secno + 2, &qbh->bh[2], 0)) goto bail2;\n\tif (!hpfs_map_sector(s, secno + 3, &qbh->bh[3], 0)) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}\n\n \n\nvoid *hpfs_get_4sectors(struct super_block *s, unsigned secno,\n                          struct quad_buffer_head *qbh)\n{\n\tcond_resched();\n\n\thpfs_lock_assert(s);\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!hpfs_get_sector(s, secno + 0, &qbh->bh[0])) goto bail0;\n\tif (!hpfs_get_sector(s, secno + 1, &qbh->bh[1])) goto bail1;\n\tif (!hpfs_get_sector(s, secno + 2, &qbh->bh[2])) goto bail2;\n\tif (!hpfs_get_sector(s, secno + 3, &qbh->bh[3])) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tif (!(qbh->data = kmalloc(2048, GFP_NOFS))) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\treturn qbh->data;\n\nbail4:\n\tbrelse(qbh->bh[3]);\nbail3:\n\tbrelse(qbh->bh[2]);\nbail2:\n\tbrelse(qbh->bh[1]);\nbail1:\n\tbrelse(qbh->bh[0]);\nbail0:\n\treturn NULL;\n}\n\t\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}\t\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}