{
  "module_name": "dir.c",
  "hash_id": "97e0e9a99f08b677442fcc0c2317a5224ce5fd0ab4f7f436ce26d682f85e4446",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/dir.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"hpfs_fn.h\"\n\nstatic int hpfs_dir_release(struct inode *inode, struct file *filp)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_del_pos(inode, &filp->f_pos);\n\t \n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}\n\n \n\nstatic loff_t hpfs_dir_lseek(struct file *filp, loff_t off, int whence)\n{\n\tloff_t new_off = off + (whence == 1 ? filp->f_pos : 0);\n\tloff_t pos;\n\tstruct quad_buffer_head qbh;\n\tstruct inode *i = file_inode(filp);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct super_block *s = i->i_sb;\n\n\t \n\tif (whence == SEEK_DATA || whence == SEEK_HOLE)\n\t\treturn -EINVAL;\n\n\tinode_lock(i);\n\thpfs_lock(s);\n\n\t \n\tif (new_off == 0 || new_off == 1 || new_off == 11 || new_off == 12 || new_off == 13) goto ok;\n\tpos = ((loff_t) hpfs_de_as_down_as_possible(s, hpfs_inode->i_dno) << 4) + 1;\n\twhile (pos != new_off) {\n\t\tif (map_pos_dirent(i, &pos, &qbh)) hpfs_brelse4(&qbh);\n\t\telse goto fail;\n\t\tif (pos == 12) goto fail;\n\t}\n\tif (unlikely(hpfs_add_pos(i, &filp->f_pos) < 0)) {\n\t\thpfs_unlock(s);\n\t\tinode_unlock(i);\n\t\treturn -ENOMEM;\n\t}\nok:\n\tfilp->f_pos = new_off;\n\thpfs_unlock(s);\n\tinode_unlock(i);\n\treturn new_off;\nfail:\n\t \n\thpfs_unlock(s);\n\tinode_unlock(i);\n\treturn -ESPIPE;\n}\n\nstatic int hpfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tint lc;\n\tloff_t next_pos;\n\tunsigned char *tempname;\n\tint c1, c2 = 0;\n\tint ret = 0;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\tif (hpfs_chk_sectors(inode->i_sb, inode->i_ino, 1, \"dir_fnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hpfs_chk_sectors(inode->i_sb, hpfs_inode->i_dno, 4, \"dir_dnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (hpfs_sb(inode->i_sb)->sb_chk >= 2) {\n\t\tstruct buffer_head *bh;\n\t\tstruct fnode *fno;\n\t\tint e = 0;\n\t\tif (!(fno = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) {\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fnode_is_dir(fno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"not a directory, fnode %08lx\",\n\t\t\t\t\t(unsigned long)inode->i_ino);\n\t\t}\n\t\tif (hpfs_inode->i_dno != le32_to_cpu(fno->u.external[0].disk_secno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"corrupted inode: i_dno == %08x, fnode -> dnode == %08x\", hpfs_inode->i_dno, le32_to_cpu(fno->u.external[0].disk_secno));\n\t\t}\n\t\tbrelse(bh);\n\t\tif (e) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlc = hpfs_sb(inode->i_sb)->sb_lowercase;\n\tif (ctx->pos == 12) {  \n\t\tctx->pos = 13;  \n\t\tgoto out;\n\t}\n\tif (ctx->pos == 13) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t\n\twhile (1) {\n\t\tagain:\n\t\t \n\t\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(inode->i_sb, ctx->pos, &c1, &c2, \"hpfs_readdir\")) {\n\t\t\t\tret = -EFSERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (ctx->pos == 12)\n\t\t\tgoto out;\n\t\tif (ctx->pos == 3 || ctx->pos == 4 || ctx->pos == 5) {\n\t\t\tpr_err(\"pos==%d\\n\", (int)ctx->pos);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 11;\n\t\t}\n\t\tif (ctx->pos == 11) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, hpfs_inode->i_parent_dir, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 1;\n\t\t}\n\t\tif (ctx->pos == 1) {\n\t\t\tret = hpfs_add_pos(inode, &file->f_pos);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, hpfs_inode->i_dno) << 4) + 1;\n\t\t}\n\t\tnext_pos = ctx->pos;\n\t\tif (!(de = map_pos_dirent(inode, &next_pos, &qbh))) {\n\t\t\tctx->pos = next_pos;\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (de->first || de->last) {\n\t\t\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\t\t\tif (de->first && !de->last && (de->namelen != 2\n\t\t\t\t    || de ->name[0] != 1 || de->name[1] != 1))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad ^A^A entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t\tif (de->last && (de->namelen != 1 || de ->name[0] != 255))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad \\\\377 entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t}\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tctx->pos = next_pos;\n\t\t\tgoto again;\n\t\t}\n\t\ttempname = hpfs_translate_name(inode->i_sb, de->name, de->namelen, lc, de->not_8x3);\n\t\tif (!dir_emit(ctx, tempname, de->namelen, le32_to_cpu(de->fnode), DT_UNKNOWN)) {\n\t\t\tif (tempname != de->name) kfree(tempname);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = next_pos;\n\t\tif (tempname != de->name) kfree(tempname);\n\t\thpfs_brelse4(&qbh);\n\t}\nout:\n\thpfs_unlock(inode->i_sb);\n\treturn ret;\n}\n\n \n\nstruct dentry *hpfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tino_t ino;\n\tint err;\n\tstruct inode *result = NULL;\n\tstruct hpfs_inode_info *hpfs_result;\n\n\thpfs_lock(dir->i_sb);\n\tif ((err = hpfs_chk_name(name, &len))) {\n\t\tif (err == -ENAMETOOLONG) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t\tgoto end_add;\n\t}\n\n\t \n\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, NULL, &qbh);\n\n\t \n\n\tif (!de) goto end;\n\n\t \n\n\tino = le32_to_cpu(de->fnode);\n\n\t \n\n\tresult = iget_locked(dir->i_sb, ino);\n\tif (!result) {\n\t\thpfs_error(dir->i_sb, \"hpfs_lookup: can't get inode\");\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tgoto bail1;\n\t}\n\tif (result->i_state & I_NEW) {\n\t\thpfs_init_inode(result);\n\t\tif (de->directory)\n\t\t\thpfs_read_inode(result);\n\t\telse if (le32_to_cpu(de->ea_size) && hpfs_sb(dir->i_sb)->sb_eas)\n\t\t\thpfs_read_inode(result);\n\t\telse {\n\t\t\tresult->i_mode |= S_IFREG;\n\t\t\tresult->i_mode &= ~0111;\n\t\t\tresult->i_op = &hpfs_file_iops;\n\t\t\tresult->i_fop = &hpfs_file_ops;\n\t\t\tset_nlink(result, 1);\n\t\t}\n\t\tunlock_new_inode(result);\n\t}\n\thpfs_result = hpfs_i(result);\n\tif (!de->directory) hpfs_result->i_parent_dir = dir->i_ino;\n\n\tif (de->has_acl || de->has_xtd_perm) if (!sb_rdonly(dir->i_sb)) {\n\t\thpfs_error(result->i_sb, \"ACLs or XPERM found. This is probably HPFS386. This driver doesn't support it now. Send me some info on these structures\");\n\t\tiput(result);\n\t\tresult = ERR_PTR(-EINVAL);\n\t\tgoto bail1;\n\t}\n\n\t \n\n\tif (!inode_get_ctime(result).tv_sec) {\n\t\ttime64_t csec = local_to_gmt(dir->i_sb, le32_to_cpu(de->creation_date));\n\n\t\tinode_set_ctime(result, csec ? csec : 1, 0);\n\t\tresult->i_mtime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->write_date));\n\t\tresult->i_mtime.tv_nsec = 0;\n\t\tresult->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->read_date));\n\t\tresult->i_atime.tv_nsec = 0;\n\t\thpfs_result->i_ea_size = le32_to_cpu(de->ea_size);\n\t\tif (!hpfs_result->i_ea_mode && de->read_only)\n\t\t\tresult->i_mode &= ~0222;\n\t\tif (!de->directory) {\n\t\t\tif (result->i_size == -1) {\n\t\t\t\tresult->i_size = le32_to_cpu(de->file_size);\n\t\t\t\tresult->i_data.a_ops = &hpfs_aops;\n\t\t\t\thpfs_i(result)->mmu_private = result->i_size;\n\t\t\t \n\t\t\t\tresult->i_blocks = 1 + ((result->i_size + 511) >> 9);\n\t\t\t}\n\t\t}\n\t}\n\nbail1:\n\thpfs_brelse4(&qbh);\n\n\t \n\nend:\nend_add:\n\thpfs_unlock(dir->i_sb);\n\treturn d_splice_alias(result, dentry);\n}\n\nconst struct file_operations hpfs_dir_ops =\n{\n\t.llseek\t\t= hpfs_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= hpfs_readdir,\n\t.release\t= hpfs_dir_release,\n\t.fsync\t\t= hpfs_file_fsync,\n\t.unlocked_ioctl\t= hpfs_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}