{
  "module_name": "namei.c",
  "hash_id": "ad9da04197aa1a393dc3a06eb9ff917657deaceef34866e9d3fe52471d240ba4",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/namei.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_update_directory_times(struct inode *dir)\n{\n\ttime64_t t = local_to_gmt(dir->i_sb, local_get_seconds(dir->i_sb));\n\tif (t == dir->i_mtime.tv_sec &&\n\t    t == inode_get_ctime(dir).tv_sec)\n\t\treturn;\n\tdir->i_mtime = inode_set_ctime(dir, t, 0);\n\thpfs_write_inode_nolock(dir);\n}\n\nstatic int hpfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh0;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de;\n\tstruct fnode *fnode;\n\tstruct dnode *dnode;\n\tstruct inode *result;\n\tfnode_secno fno;\n\tdnode_secno dno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tdnode = hpfs_alloc_dnode(dir->i_sb, fno, &dno, &qbh0);\n\tif (!dnode)\n\t\tgoto bail1;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.directory = 1;\n\tif (!(mode & 0222)) dee.read_only = 1;\n\t \n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(local_get_seconds(dir->i_sb));\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail2;\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\thpfs_i(result)->i_dno = dno;\n\tresult->i_mtime = result->i_atime =\n\t\tinode_set_ctime(result, local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date)), 0);\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode |= S_IFDIR;\n\tresult->i_op = &hpfs_dir_iops;\n\tresult->i_fop = &hpfs_dir_ops;\n\tresult->i_blocks = 4;\n\tresult->i_size = 2048;\n\tset_nlink(result, 2);\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail3;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail3;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tfnode->flags |= FNODE_dir;\n\tfnode->btree.n_free_nodes = 7;\n\tfnode->btree.n_used_nodes = 1;\n\tfnode->btree.first_free = cpu_to_le16(0x14);\n\tfnode->u.external[0].disk_secno = cpu_to_le32(dno);\n\tfnode->u.external[0].file_secno = cpu_to_le32(-1);\n\tdnode->root_dnode = 1;\n\tdnode->up = cpu_to_le32(fno);\n\tde = hpfs_add_de(dir->i_sb, dnode, \"\\001\\001\", 2, 0);\n\tde->creation_date = de->write_date = de->read_date = cpu_to_le32(local_get_seconds(dir->i_sb));\n\tif (!(mode & 0222)) de->read_only = 1;\n\tde->first = de->directory = 1;\n\t \n\tde->fnode = cpu_to_le32(fno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_mark_4buffers_dirty(&qbh0);\n\thpfs_brelse4(&qbh0);\n\tinc_nlink(dir);\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFDIR)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFDIR;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\thpfs_update_directory_times(dir);\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail3:\n\tiput(result);\nbail2:\n\thpfs_brelse4(&qbh0);\n\thpfs_free_dnode(dir->i_sb, dno);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct inode *result = NULL;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len)))\n\t\treturn err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(local_get_seconds(dir->i_sb));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\t\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\tresult->i_mode |= S_IFREG;\n\tresult->i_mode &= ~0111;\n\tresult->i_op = &hpfs_file_iops;\n\tresult->i_fop = &hpfs_file_ops;\n\tset_nlink(result, 1);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_mtime = result->i_atime =\n\t\tinode_set_ctime(result, local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date)), 0);\n\thpfs_i(result)->i_ea_size = 0;\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\tresult->i_blocks = 1;\n\tresult->i_size = 0;\n\tresult->i_data.a_ops = &hpfs_aops;\n\thpfs_i(result)->mmu_private = 0;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFREG)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFREG;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\thpfs_update_directory_times(dir);\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\n\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result = NULL;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) return -EPERM;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(local_get_seconds(dir->i_sb));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_mtime = result->i_atime =\n\t\tinode_set_ctime(result, local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date)), 0);\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tset_nlink(result, 1);\n\tresult->i_size = 0;\n\tresult->i_blocks = 1;\n\tinit_special_inode(result, mode, rdev);\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\thpfs_update_directory_times(dir);\n\td_instantiate(dentry, result);\n\tbrelse(bh);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symlink)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) {\n\t\thpfs_unlock(dir->i_sb);\n\t\treturn -EPERM;\n\t}\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(local_get_seconds(dir->i_sb));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\tresult->i_ino = fno;\n\thpfs_init_inode(result);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_mtime = result->i_atime =\n\t\tinode_set_ctime(result, local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date)), 0);\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode = S_IFLNK | 0777;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tresult->i_blocks = 1;\n\tset_nlink(result, 1);\n\tresult->i_size = strlen(symlink);\n\tinode_nohighmem(result);\n\tresult->i_op = &page_symlink_inode_operations;\n\tresult->i_data.a_ops = &hpfs_symlink_aops;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\thpfs_set_ea(result, fnode, \"SYMLINK\", symlink, strlen(symlink));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\thpfs_update_directory_times(dir);\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = d_inode(dentry);\n\tdnode_secno dno;\n\tint r;\n\tint err;\n\n\thpfs_lock(dir->i_sb);\n\thpfs_adjust_length(name, &len);\n\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -EISDIR;\n\tif (de->directory)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\t\t \n\t\terr = -ENOSPC;\n\t\tbreak;\n\tdefault:\n\t\tdrop_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\n\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\tif (!err)\n\t\thpfs_update_directory_times(dir);\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = d_inode(dentry);\n\tdnode_secno dno;\n\tint n_items = 0;\n\tint err;\n\tint r;\n\n\thpfs_adjust_length(name, &len);\n\thpfs_lock(dir->i_sb);\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -ENOTDIR;\n\tif (!de->directory)\n\t\tgoto out1;\n\n\thpfs_count_dnodes(dir->i_sb, hpfs_i(inode)->i_dno, NULL, NULL, &n_items);\n\terr = -ENOTEMPTY;\n\tif (n_items)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\n\t\terr = -ENOSPC;\n\t\tbreak;\n\tdefault:\n\t\tdrop_nlink(dir);\n\t\tclear_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\tif (!err)\n\t\thpfs_update_directory_times(dir);\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}\n\nstatic int hpfs_symlink_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tchar *link = page_address(page);\n\tstruct inode *i = page->mapping->host;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = -EIO;\n\thpfs_lock(i->i_sb);\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh)))\n\t\tgoto fail;\n\terr = hpfs_read_ea(i->i_sb, fnode, \"SYMLINK\", link, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto fail;\n\thpfs_unlock(i->i_sb);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nfail:\n\thpfs_unlock(i->i_sb);\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn err;\n}\n\nconst struct address_space_operations hpfs_symlink_aops = {\n\t.read_folio\t= hpfs_symlink_read_folio\n};\n\nstatic int hpfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\tconst unsigned char *old_name = old_dentry->d_name.name;\n\tunsigned old_len = old_dentry->d_name.len;\n\tconst unsigned char *new_name = new_dentry->d_name.name;\n\tunsigned new_len = new_dentry->d_name.len;\n\tstruct inode *i = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct quad_buffer_head qbh, qbh1;\n\tstruct hpfs_dirent *dep, *nde;\n\tstruct hpfs_dirent de;\n\tdnode_secno dno;\n\tint r;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint err;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tif ((err = hpfs_chk_name(new_name, &new_len))) return err;\n\terr = 0;\n\thpfs_adjust_length(old_name, &old_len);\n\n\thpfs_lock(i->i_sb);\n\t \n\t\n\t \n\tif (new_inode && S_ISDIR(new_inode->i_mode)) {\n\t\terr = -EINVAL;\n\t\tgoto end1;\n\t}\n\n\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed\");\n\t\terr = -ENOENT;\n\t\tgoto end1;\n\t}\n\tcopy_de(&de, dep);\n\tde.hidden = new_name[0] == '.';\n\n\tif (new_inode) {\n\t\tint r;\n\t\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 1)) != 2) {\n\t\t\tif ((nde = map_dirent(new_dir, hpfs_i(new_dir)->i_dno, new_name, new_len, NULL, &qbh1))) {\n\t\t\t\tclear_nlink(new_inode);\n\t\t\t\tcopy_de(nde, &de);\n\t\t\t\tmemcpy(nde->name, new_name, new_len);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\thpfs_error(new_dir->i_sb, \"hpfs_rename: could not find dirent\");\n\t\t\terr = -EFSERROR;\n\t\t\tgoto end1;\n\t\t}\n\t\terr = -ENOSPC;\n\t\tgoto end1;\n\t}\n\n\tif (new_dir == old_dir) hpfs_brelse4(&qbh);\n\n\tif ((r = hpfs_add_dirent(new_dir, new_name, new_len, &de))) {\n\t\tif (r == -1) hpfs_error(new_dir->i_sb, \"hpfs_rename: dirent already exists!\");\n\t\terr = r == 1 ? -ENOSPC : -EFSERROR;\n\t\tif (new_dir != old_dir) hpfs_brelse4(&qbh);\n\t\tgoto end1;\n\t}\n\t\n\tif (new_dir == old_dir)\n\t\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed at #2\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto end1;\n\t\t}\n\n\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 0))) {\n\t\thpfs_error(i->i_sb, \"hpfs_rename: could not remove dirent\");\n\t\terr = r == 2 ? -ENOSPC : -EFSERROR;\n\t\tgoto end1;\n\t}\n\nend:\n\thpfs_i(i)->i_parent_dir = new_dir->i_ino;\n\tif (S_ISDIR(i->i_mode)) {\n\t\tinc_nlink(new_dir);\n\t\tdrop_nlink(old_dir);\n\t}\n\tif ((fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) {\n\t\tfnode->up = cpu_to_le32(new_dir->i_ino);\n\t\tfnode->len = new_len;\n\t\tmemcpy(fnode->name, new_name, new_len>15?15:new_len);\n\t\tif (new_len < 15) memset(&fnode->name[new_len], 0, 15 - new_len);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\nend1:\n\tif (!err) {\n\t\thpfs_update_directory_times(old_dir);\n\t\thpfs_update_directory_times(new_dir);\n\t}\n\thpfs_unlock(i->i_sb);\n\treturn err;\n}\n\nconst struct inode_operations hpfs_dir_iops =\n{\n\t.create\t\t= hpfs_create,\n\t.lookup\t\t= hpfs_lookup,\n\t.unlink\t\t= hpfs_unlink,\n\t.symlink\t= hpfs_symlink,\n\t.mkdir\t\t= hpfs_mkdir,\n\t.rmdir\t\t= hpfs_rmdir,\n\t.mknod\t\t= hpfs_mknod,\n\t.rename\t\t= hpfs_rename,\n\t.setattr\t= hpfs_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}