{
  "module_name": "dnode.c",
  "hash_id": "5c70d7f5995b8dd3dc8ad20760c1886f6625a5418cf835a9b8e79cfccdc25067",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/dnode.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\nstatic loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}\n\nint hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos)\n\t\t\t\treturn 0;\n\tif (!(i&0x0f)) {\n\t\tppos = kmalloc_array(i + 0x11, sizeof(loff_t *), GFP_NOFS);\n\t\tif (!ppos) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n\treturn 0;\n}\n\nvoid hpfs_del_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i, **j;\n\n\tif (!hpfs_inode->i_rddir_off) goto not_f;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\n\tgoto not_f;\n\tfnd:\n\tfor (j = i + 1; *j; j++) ;\n\t*i = *(j - 1);\n\t*(j - 1) = NULL;\n\tif (j - 1 == hpfs_inode->i_rddir_off) {\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\treturn;\n\tnot_f:\n\t \n\treturn;\n}\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}\n\nstatic void hpfs_pos_subst(loff_t *p, loff_t f, loff_t t)\n{\n\tif (*p == f) *p = t;\n}\n\n \n\nstatic void hpfs_pos_ins(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) + c;\n\t\tif (n > 0x3f)\n\t\t\tpr_err(\"%s(): %08x + %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}\n\nstatic void hpfs_pos_del(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) - c;\n\t\tif (n < 1)\n\t\t\tpr_err(\"%s(): %08x - %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}\n\nstatic struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}\n\nstatic void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}\n\n \n\nstruct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}\n\n \n\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}\n\nstatic void fix_up_ptrs(struct super_block *s, struct dnode *d)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\t\t}\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t}\n\t\t}\n}\n\n \n\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t \n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}\n\n \n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}\n\n \n\nstatic secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\n{\n\tdnode_secno dno, ddno;\n\tdnode_secno chk_up = to;\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de, *nde;\n\tint a;\n\tloff_t t;\n\tint c1, c2 = 0;\n\tdno = from;\n\twhile (1) {\n\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"move_to_top\"))\n\t\t\t\treturn 0;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) {\n\t\t\tif (le32_to_cpu(dnode->up) != chk_up) {\n\t\t\t\thpfs_error(i->i_sb, \"move_to_top: up pointer from %08x should be %08x, is %08x\",\n\t\t\t\t\tdno, chk_up, le32_to_cpu(dnode->up));\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchk_up = dno;\n\t\t}\n\t\tif (!(de = dnode_last_de(dnode))) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x has no last de\", dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!de->down) break;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t}\n\twhile (!(de = dnode_pre_last_de(dnode))) {\n\t\tdnode_secno up = le32_to_cpu(dnode->up);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\n\t\tif (up == to) return to;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\n\t\tif (dnode->root_dnode) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: got to root_dnode while moving from %08x to %08x\", from, to);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tde = dnode_last_de(dnode);\n\t\tif (!de || !de->down) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x doesn't point down to %08x\", up, dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\tle16_add_cpu(&de->length, -4);\n\t\tde->down = 0;\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\tdno = up;\n\t}\n\tt = get_pos(dnode, de);\n\tfor_all_poss(i, hpfs_pos_subst, t, 4);\n\tfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\n\tif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\thpfs_error(i->i_sb, \"out of memory for dirent - directory will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\treturn 0;\n\t}\n\tmemcpy(nde, de, le16_to_cpu(de->length));\n\tddno = de->down ? de_down_pointer(de) : 0;\n\thpfs_delete_de(i->i_sb, dnode, de);\n\tset_last_pointer(i->i_sb, dnode, ddno);\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\ta = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\n\tkfree(nde);\n\tif (a) return 0;\n\treturn dno;\n}\n\n \n\nstatic void delete_empty_dnode(struct inode *i, dnode_secno dno)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tdnode_secno down, up, ndown;\n\tint p;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\ttry_it_again:\n\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"delete_empty_dnode\")) return;\n\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\n\tif (le32_to_cpu(dnode->first_free) > 56) goto end;\n\tif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\n\t\tstruct hpfs_dirent *de_end;\n\t\tint root = dnode->root_dnode;\n\t\tup = le32_to_cpu(dnode->up);\n\t\tde = dnode_first_de(dnode);\n\t\tdown = de->down ? de_down_pointer(de) : 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: root dnode %08x is empty\", dno);\n\t\t\tgoto end;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tif (root) {\n\t\t\tstruct fnode *fnode;\n\t\t\tstruct buffer_head *bh;\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\t\tif (up != i->i_ino) {\n\t\t\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\t\t   \"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx\",\n\t\t\t\t\t\t   dno, up,\n\t\t\t\t\t\t   (unsigned long)i->i_ino);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\td1->root_dnode = 1;\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t\tif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\n\t\t\t\tfnode->u.external[0].disk_secno = cpu_to_le32(down);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\thpfs_inode->i_dno = down;\n\t\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\n\t\t\treturn;\n\t\t}\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\n\t\tp = 1;\n\t\tde_end = dnode_end_de(dnode);\n\t\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\n\t\t\tif (de->down) if (de_down_pointer(de) == dno) goto fnd;\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: pointer to dnode %08x not found in dnode %08x\", dno, up);\n\t\tgoto end;\n\t\tfnd:\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\n\t\tif (!down) {\n\t\t\tde->down = 0;\n\t\t\tle16_add_cpu(&de->length, -4);\n\t\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\t\tmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\n\t\t\t\t(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\n\t\t} else {\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\t*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: dnode %08x, first_free == %03x\", dno, le32_to_cpu(dnode->first_free));\n\t\tgoto end;\n\t}\n\n\tif (!de->last) {\n\t\tstruct hpfs_dirent *de_next = de_next_de(de);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tif (!de_next->down) goto endm;\n\t\tndown = de_down_pointer(de_next);\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\tgoto endm;\n\t\t}\n\t\tmemcpy(de_cp, de, le16_to_cpu(de->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\n\t\tfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\n\t\tif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\n\t\t \n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t} else {\n\t\tstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tdnode_secno dlp;\n\t\tif (!de_prev) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: empty dnode %08x\", up);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tdno = up;\n\t\t\tgoto try_it_again;\n\t\t}\n\t\tif (!de_prev->down) goto endm;\n\t\tndown = de_down_pointer(de_prev);\n\t\tif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\n\t\t\tstruct hpfs_dirent *del = dnode_last_de(d1);\n\t\t\tdlp = del->down ? de_down_pointer(del) : 0;\n\t\t\tif (!dlp && down) {\n\t\t\t\tif (le32_to_cpu(d1->first_free) > 2044) {\n\t\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\t\tpr_err(\"terminating balancing operation\\n\");\n\t\t\t\t\t}\n\t\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\t\tgoto endm;\n\t\t\t\t}\n\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\tpr_err(\"goin'on\\n\");\n\t\t\t\t}\n\t\t\t\tle16_add_cpu(&del->length, 4);\n\t\t\t\tdel->down = 1;\n\t\t\t\tle32_add_cpu(&d1->first_free, 4);\n\t\t\t}\n\t\t\tif (dlp && !down) {\n\t\t\t\tle16_add_cpu(&del->length, -4);\n\t\t\t\tdel->down = 0;\n\t\t\t\tle32_add_cpu(&d1->first_free, -4);\n\t\t\t} else if (down)\n\t\t\t\t*(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\n\t\t} else goto endm;\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\thpfs_brelse4(&qbh1);\n\t\t\tgoto endm;\n\t\t}\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de_prev);\n\t\tif (!de_prev->down) {\n\t\t\tle16_add_cpu(&de_prev->length, 4);\n\t\t\tde_prev->down = 1;\n\t\t\tle32_add_cpu(&dnode->first_free, 4);\n\t\t}\n\t\t*(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\n\t\tif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t}\n\tendm:\n\thpfs_mark_4buffers_dirty(&qbh);\n\tend:\n\thpfs_brelse4(&qbh);\n}\n\n\n \n\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}\n\nvoid hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}\n\nstatic struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}\n\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}\n\nstruct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t \n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t \n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}\n\n \n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}\n\n \n\nvoid hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tdnode_secno d1, d2, rdno = dno;\n\twhile (1) {\n\t\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\t\tde = dnode_first_de(dnode);\n\t\tif (de->last) {\n\t\t\tif (de->down) d1 = de_down_pointer(de);\n\t\t\telse goto error;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t\tdno = d1;\n\t\t} else break;\n\t}\n\tif (!de->first) goto error;\n\td1 = de->down ? de_down_pointer(de) : 0;\n\tde = de_next_de(de);\n\tif (!de->last) goto error;\n\td2 = de->down ? de_down_pointer(de) : 0;\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\tdo {\n\t\twhile (d1) {\n\t\t\tif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\n\t\t\tde = dnode_first_de(dnode);\n\t\t\tif (!de->last) goto error;\n\t\t\td1 = de->down ? de_down_pointer(de) : 0;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t}\n\t\td1 = d2;\n\t\td2 = 0;\n\t} while (d1);\n\treturn;\n\terror:\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\thpfs_error(s, \"directory %08x is corrupted or not empty\", rdno);\n}\n\n \n\nstruct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\n\t\t\t\t     struct fnode *f, struct quad_buffer_head *qbh)\n{\n\tunsigned char *name1;\n\tunsigned char *name2;\n\tint name1len, name2len;\n\tstruct dnode *d;\n\tdnode_secno dno, downd;\n\tstruct fnode *upf;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de, *de_end;\n\tint c;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tname1 = f->name;\n\tif (!(name2 = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't map dirent\\n\");\n\t\treturn NULL;\n\t}\n\tif (f->len <= 15)\n\t\tmemcpy(name2, name1, name1len = name2len = f->len);\n\telse {\n\t\tmemcpy(name2, name1, 15);\n\t\tmemset(name2 + 15, 0xff, 256 - 15);\n\t\t \n\t\tname1len = 15; name2len = 256;\n\t}\n\tif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\t\n\tif (!fnode_is_dir(upf)) {\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"fnode %08x has non-directory parent %08x\", fno, le32_to_cpu(f->up));\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tdno = le32_to_cpu(upf->u.external[0].disk_secno);\n\tbrelse(bh);\n\tgo_down:\n\tdownd = 0;\n\tgo_up:\n\tif (!(d = hpfs_map_dnode(s, dno, qbh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tde_end = dnode_end_de(d);\n\tde = dnode_first_de(d);\n\tif (downd) {\n\t\twhile (de < de_end) {\n\t\t\tif (de->down) if (de_down_pointer(de) == downd) goto f;\n\t\t\tde = de_next_de(de);\n\t\t}\n\t\thpfs_error(s, \"pointer to dnode %08x not found in dnode %08x\", downd, dno);\n\t\thpfs_brelse4(qbh);\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tnext_de:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\n\tif (c < 0 && de->down) {\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(qbh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"map_fnode_dirent #1\")) {\n\t\t\t\tkfree(name2);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tgoto go_down;\n\t}\n\tf:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\n\tif (c < 0 && !de->last) goto not_found;\n\tif ((de = de_next_de(de)) < de_end) goto next_de;\n\tif (d->root_dnode) goto not_found;\n\tdownd = dno;\n\tdno = le32_to_cpu(d->up);\n\thpfs_brelse4(qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, downd, &d1, &d2, \"map_fnode_dirent #2\")) {\n\t\t\tkfree(name2);\n\t\t\treturn NULL;\n\t\t}\n\tgoto go_up;\n\tnot_found:\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"dirent for fnode %08x not found\", fno);\n\tkfree(name2);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}