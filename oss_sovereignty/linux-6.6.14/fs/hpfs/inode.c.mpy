{
  "module_name": "inode.c",
  "hash_id": "4648484275cbd89d50cdd456bbbc2768e0e051945177b564450281287830a613",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/inode.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/user_namespace.h>\n#include \"hpfs_fn.h\"\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\tinode_set_ctime(i, 0, 0);\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}\n\nvoid hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t \n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(i);\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}\n\nstatic void hpfs_write_inode_ea(struct inode *i, struct fnode *fnode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\t  if (hpfs_sb(i->i_sb)->sb_eas >= 2) {\n\t\t__le32 ea;\n\t\tif (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {\n\t\t\tea = cpu_to_le32(i_uid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"UID\", (char*)&ea, 2);\n\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t}\n\t\tif (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {\n\t\t\tea = cpu_to_le32(i_gid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"GID\", (char *)&ea, 2);\n\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t}\n\t\tif (!S_ISLNK(i->i_mode))\n\t\t\tif ((i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0 : 0111))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))\n\t\t\t  && i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0222 : 0333))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {\n\t\t\t\tea = cpu_to_le32(i->i_mode);\n\t\t\t\t \n\t\t\t\thpfs_set_ea(i, fnode, \"MODE\", (char *)&ea, 2);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\tif (S_ISBLK(i->i_mode) || S_ISCHR(i->i_mode)) {\n\t\t\tea = cpu_to_le32(new_encode_dev(i->i_rdev));\n\t\t\thpfs_set_ea(i, fnode, \"DEV\", (char *)&ea, 4);\n\t\t}\n\t}\n}\n\nvoid hpfs_write_inode(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct inode *parent;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (hpfs_inode->i_rddir_off && !atomic_read(&i->i_count)) {\n\t\tif (*hpfs_inode->i_rddir_off)\n\t\t\tpr_err(\"write_inode: some position still there\\n\");\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\tif (!i->i_nlink) {\n\t\treturn;\n\t}\n\tparent = iget_locked(i->i_sb, hpfs_inode->i_parent_dir);\n\tif (parent) {\n\t\thpfs_inode->i_dirty = 0;\n\t\tif (parent->i_state & I_NEW) {\n\t\t\thpfs_init_inode(parent);\n\t\t\thpfs_read_inode(parent);\n\t\t\tunlock_new_inode(parent);\n\t\t}\n\t\thpfs_write_inode_nolock(i);\n\t\tiput(parent);\n\t}\n}\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, inode_get_ctime(i).tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, inode_get_ctime(i).tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32( 0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}\n\nint hpfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error = -EINVAL;\n\n\thpfs_lock(inode->i_sb);\n\tif (inode->i_ino == hpfs_sb(inode->i_sb)->sb_root)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_UID) &&\n\t    from_kuid(&init_user_ns, attr->ia_uid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_GID) &&\n\t    from_kgid(&init_user_ns, attr->ia_gid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size)\n\t\tgoto out_unlock;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\n\thpfs_write_inode(inode);\n\n out_unlock:\n\thpfs_unlock(inode->i_sb);\n\treturn error;\n}\n\nvoid hpfs_write_if_changed(struct inode *inode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\n\tif (hpfs_inode->i_dirty)\n\t\thpfs_write_inode(inode);\n}\n\nvoid hpfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (!inode->i_nlink) {\n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_remove_fnode(inode->i_sb, inode->i_ino);\n\t\thpfs_unlock(inode->i_sb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}