{
  "module_name": "name.c",
  "hash_id": "edef26e21b71bf354684683808fd292bcd4e9c3b9ac2c21a126ca36c0cb7259c",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/name.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\nstatic inline int not_allowed_char(unsigned char c)\n{\n\treturn c<' ' || c=='\"' || c=='*' || c=='/' || c==':' || c=='<' ||\n\t      c=='>' || c=='?' || c=='\\\\' || c=='|';\n}\n\nstatic inline int no_dos_char(unsigned char c)\n{\t \n\treturn c=='+' || c==',' || c==';' || c=='=' || c=='[' || c==']';\n}\n\nstatic inline unsigned char upcase(unsigned char *dir, unsigned char a)\n{\n\tif (a<128 || a==255) return a>='a' && a<='z' ? a - 0x20 : a;\n\tif (!dir) return a;\n\treturn dir[a-128];\n}\n\nunsigned char hpfs_upcase(unsigned char *dir, unsigned char a)\n{\n\treturn upcase(dir, a);\n}\n\nstatic inline unsigned char locase(unsigned char *dir, unsigned char a)\n{\n\tif (a<128 || a==255) return a>='A' && a<='Z' ? a + 0x20 : a;\n\tif (!dir) return a;\n\treturn dir[a];\n}\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}\n\nunsigned char *hpfs_translate_name(struct super_block *s, unsigned char *from,\n\t\t\t  unsigned len, int lc, int lng)\n{\n\tunsigned char *to;\n\tint i;\n\tif (hpfs_sb(s)->sb_chk >= 2) if (hpfs_is_name_long(from, len) != lng) {\n\t\tpr_err(\"Long name flag mismatch - name \");\n\t\tfor (i = 0; i < len; i++)\n\t\t\tpr_cont(\"%c\", from[i]);\n\t\tpr_cont(\" misidentified as %s.\\n\", lng ? \"short\" : \"long\");\n\t\tpr_err(\"It's nothing serious. It could happen because of bug in OS/2.\\nSet checks=normal to disable this message.\\n\");\n\t}\n\tif (!lc) return from;\n\tif (!(to = kmalloc(len, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for name conversion buffer\\n\");\n\t\treturn from;\n\t}\n\tfor (i = 0; i < len; i++) to[i] = locase(hpfs_sb(s)->sb_cp_table,from[i]);\n\treturn to;\n}\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}\n\nint hpfs_is_name_long(const unsigned char *name, unsigned len)\n{\n\tint i,j;\n\tfor (i = 0; i < len && name[i] != '.'; i++)\n\t\tif (no_dos_char(name[i])) return 1;\n\tif (!i || i > 8) return 1;\n\tif (i == len) return 0;\n\tfor (j = i + 1; j < len; j++)\n\t\tif (name[j] == '.' || no_dos_char(name[i])) return 1;\n\treturn j - i > 4;\n}\n\n \n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}