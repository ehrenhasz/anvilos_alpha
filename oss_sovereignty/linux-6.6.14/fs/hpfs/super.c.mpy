{
  "module_name": "super.c",
  "hash_id": "f8da960a98fe8998e84a7eeb62b6479aa96dad95e8b67edb19189e430be6a70c",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/super.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/statfs.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n \n\nstatic void mark_dirty(struct super_block *s, int remount)\n{\n\tif (hpfs_sb(s)->sb_chkdsk && (remount || !sb_rdonly(s))) {\n\t\tstruct buffer_head *bh;\n\t\tstruct hpfs_spare_block *sb;\n\t\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\t\tsb->dirty = 1;\n\t\t\tsb->old_wrote = 0;\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t}\n}\n\n \n\nstatic void unmark_dirty(struct super_block *s)\n{\n\tstruct buffer_head *bh;\n\tstruct hpfs_spare_block *sb;\n\tif (sb_rdonly(s)) return;\n\tsync_blockdev(s->s_bdev);\n\tif ((sb = hpfs_map_sector(s, 17, &bh, 0))) {\n\t\tsb->dirty = hpfs_sb(s)->sb_chkdsk > 1 - hpfs_sb(s)->sb_was_error;\n\t\tsb->old_wrote = hpfs_sb(s)->sb_chkdsk >= 2 && !hpfs_sb(s)->sb_was_error;\n\t\tmark_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}\n\n \nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"filesystem error: %pV\", &vaf);\n\n\tva_end(args);\n\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (sb_rdonly(s))\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= SB_RDONLY;\n\t\t\t}\n\t\t} else if (sb_rdonly(s))\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}\n\n \n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}\n\nstatic void free_sbi(struct hpfs_sb_info *sbi)\n{\n\tkfree(sbi->sb_cp_table);\n\tkfree(sbi->sb_bmp_dir);\n\tkfree(sbi);\n}\n\nstatic void lazy_free_sbi(struct rcu_head *rcu)\n{\n\tfree_sbi(container_of(rcu, struct hpfs_sb_info, rcu));\n}\n\nstatic void hpfs_put_super(struct super_block *s)\n{\n\thpfs_lock(s);\n\tunmark_dirty(s);\n\thpfs_unlock(s);\n\tcall_rcu(&hpfs_sb(s)->rcu, lazy_free_sbi);\n}\n\nstatic unsigned hpfs_count_one_bitmap(struct super_block *s, secno secno)\n{\n\tstruct quad_buffer_head qbh;\n\tunsigned long *bits;\n\tunsigned count;\n\n\tbits = hpfs_map_4sectors(s, secno, &qbh, 0);\n\tif (!bits)\n\t\treturn (unsigned)-1;\n\tcount = bitmap_weight(bits, 2048 * BITS_PER_BYTE);\n\thpfs_brelse4(&qbh);\n\treturn count;\n}\n\nstatic unsigned count_bitmaps(struct super_block *s)\n{\n\tunsigned n, count, n_bands;\n\tn_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tcount = 0;\n\tfor (n = 0; n < COUNT_RD_AHEAD; n++) {\n\t\thpfs_prefetch_bitmap(s, n);\n\t}\n\tfor (n = 0; n < n_bands; n++) {\n\t\tunsigned c;\n\t\thpfs_prefetch_bitmap(s, n + COUNT_RD_AHEAD);\n\t\tc = hpfs_count_one_bitmap(s, le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[n]));\n\t\tif (c != (unsigned)-1)\n\t\t\tcount += c;\n\t}\n\treturn count;\n}\n\nunsigned hpfs_get_free_dnodes(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes == (unsigned)-1) {\n\t\tunsigned c = hpfs_count_one_bitmap(s, sbi->sb_dmap);\n\t\tif (c == (unsigned)-1)\n\t\t\treturn 0;\n\t\tsbi->sb_n_free_dnodes = c;\n\t}\n\treturn sbi->sb_n_free_dnodes;\n}\n\nstatic int hpfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\thpfs_lock(s);\n\n\tif (sbi->sb_n_free == (unsigned)-1)\n\t\tsbi->sb_n_free = count_bitmaps(s);\n\n\tbuf->f_type = s->s_magic;\n\tbuf->f_bsize = 512;\n\tbuf->f_blocks = sbi->sb_fs_size;\n\tbuf->f_bfree = sbi->sb_n_free;\n\tbuf->f_bavail = sbi->sb_n_free;\n\tbuf->f_files = sbi->sb_dirband_size / 4;\n\tbuf->f_ffree = hpfs_get_free_dnodes(s);\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = 254;\n\n\thpfs_unlock(s);\n\n\treturn 0;\n}\n\n\nlong hpfs_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\t\tcase FITRIM: {\n\t\t\tstruct fstrim_range range;\n\t\t\tsecno n_trimmed;\n\t\t\tint r;\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\treturn -EPERM;\n\t\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg, sizeof(range)))\n\t\t\t\treturn -EFAULT;\n\t\t\tr = hpfs_trim_fs(file_inode(file)->i_sb, range.start >> 9, (range.start + range.len) >> 9, (range.minlen + 511) >> 9, &n_trimmed);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\trange.len = (u64)n_trimmed << 9;\n\t\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range, sizeof(range)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\tdefault: {\n\t\t\treturn -ENOIOCTLCMD;\n\t\t}\n\t}\n}\n\n\nstatic struct kmem_cache * hpfs_inode_cachep;\n\nstatic struct inode *hpfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hpfs_inode_info *ei;\n\tei = alloc_inode_sb(sb, hpfs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void hpfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct hpfs_inode_info *ei = (struct hpfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\thpfs_inode_cachep = kmem_cache_create(\"hpfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct hpfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (hpfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(hpfs_inode_cachep);\n}\n\n \n\nenum {\n\tOpt_help, Opt_uid, Opt_gid, Opt_umask, Opt_case_lower, Opt_case_asis,\n\tOpt_check_none, Opt_check_normal, Opt_check_strict,\n\tOpt_err_cont, Opt_err_ro, Opt_err_panic,\n\tOpt_eas_no, Opt_eas_ro, Opt_eas_rw,\n\tOpt_chkdsk_no, Opt_chkdsk_errors, Opt_chkdsk_always,\n\tOpt_timeshift, Opt_err,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_help, \"help\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_case_lower, \"case=lower\"},\n\t{Opt_case_asis, \"case=asis\"},\n\t{Opt_check_none, \"check=none\"},\n\t{Opt_check_normal, \"check=normal\"},\n\t{Opt_check_strict, \"check=strict\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_eas_no, \"eas=no\"},\n\t{Opt_eas_ro, \"eas=ro\"},\n\t{Opt_eas_rw, \"eas=rw\"},\n\t{Opt_chkdsk_no, \"chkdsk=no\"},\n\t{Opt_chkdsk_errors, \"chkdsk=errors\"},\n\t{Opt_chkdsk_always, \"chkdsk=always\"},\n\t{Opt_timeshift, \"timeshift=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int parse_opts(char *opts, kuid_t *uid, kgid_t *gid, umode_t *umask,\n\t\t      int *lowercase, int *eas, int *chk, int *errs,\n\t\t      int *chkdsk, int *timeshift)\n{\n\tchar *p;\n\tint option;\n\n\tif (!opts)\n\t\treturn 1;\n\n\t \n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_help:\n\t\t\treturn 2;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\t*umask = option;\n\t\t\tbreak;\n\t\tcase Opt_case_lower:\n\t\t\t*lowercase = 1;\n\t\t\tbreak;\n\t\tcase Opt_case_asis:\n\t\t\t*lowercase = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_none:\n\t\t\t*chk = 0;\n\t\t\tbreak;\n\t\tcase Opt_check_normal:\n\t\t\t*chk = 1;\n\t\t\tbreak;\n\t\tcase Opt_check_strict:\n\t\t\t*chk = 2;\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\t*errs = 0;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\t*errs = 1;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\t*errs = 2;\n\t\t\tbreak;\n\t\tcase Opt_eas_no:\n\t\t\t*eas = 0;\n\t\t\tbreak;\n\t\tcase Opt_eas_ro:\n\t\t\t*eas = 1;\n\t\t\tbreak;\n\t\tcase Opt_eas_rw:\n\t\t\t*eas = 2;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_no:\n\t\t\t*chkdsk = 0;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_errors:\n\t\t\t*chkdsk = 1;\n\t\t\tbreak;\n\t\tcase Opt_chkdsk_always:\n\t\t\t*chkdsk = 2;\n\t\t\tbreak;\n\t\tcase Opt_timeshift:\n\t\t{\n\t\t\tint m = 1;\n\t\t\tchar *rhs = args[0].from;\n\t\t\tif (!rhs || !*rhs)\n\t\t\t\treturn 0;\n\t\t\tif (*rhs == '-') m = -1;\n\t\t\tif (*rhs == '+' || *rhs == '-') rhs++;\n\t\t\t*timeshift = simple_strtoul(rhs, &rhs, 0) * m;\n\t\t\tif (*rhs)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline void hpfs_help(void)\n{\n\tpr_info(\"\\n\\\nHPFS filesystem options:\\n\\\n      help              do not mount and display this text\\n\\\n      uid=xxx           set uid of files that don't have uid specified in eas\\n\\\n      gid=xxx           set gid of files that don't have gid specified in eas\\n\\\n      umask=xxx         set mode of files that don't have mode specified in eas\\n\\\n      case=lower        lowercase all files\\n\\\n      case=asis         do not lowercase files (default)\\n\\\n      check=none        no fs checks - kernel may crash on corrupted filesystem\\n\\\n      check=normal      do some checks - it should not crash (default)\\n\\\n      check=strict      do extra time-consuming checks, used for debugging\\n\\\n      errors=continue   continue on errors\\n\\\n      errors=remount-ro remount read-only if errors found (default)\\n\\\n      errors=panic      panic on errors\\n\\\n      chkdsk=no         do not mark fs for chkdsking even if there were errors\\n\\\n      chkdsk=errors     mark fs dirty if errors found (default)\\n\\\n      chkdsk=always     always mark fs dirty - used for debugging\\n\\\n      eas=no            ignore extended attributes\\n\\\n      eas=ro            read but do not write extended attributes\\n\\\n      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\\n\\\n      timeshift=nnn\tadd nnn seconds to file times\\n\\\n\\n\");\n}\n\nstatic int hpfs_remount_fs(struct super_block *s, int *flags, char *data)\n{\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\tint o;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\n\tsync_filesystem(s);\n\n\t*flags |= SB_NOATIME;\n\n\thpfs_lock(s);\n\tuid = sbi->sb_uid; gid = sbi->sb_gid;\n\tumask = 0777 & ~sbi->sb_mode;\n\tlowercase = sbi->sb_lowercase;\n\teas = sbi->sb_eas; chk = sbi->sb_chk; chkdsk = sbi->sb_chkdsk;\n\terrs = sbi->sb_err; timeshift = sbi->sb_timeshift;\n\n\tif (!(o = parse_opts(data, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto out_err;\n\t}\n\tif (o == 2) {\n\t\thpfs_help();\n\t\tgoto out_err;\n\t}\n\tif (timeshift != sbi->sb_timeshift) {\n\t\tpr_err(\"timeshift can't be changed using remount.\\n\");\n\t\tgoto out_err;\n\t}\n\n\tunmark_dirty(s);\n\n\tsbi->sb_uid = uid; sbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas; sbi->sb_chk = chk; sbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs; sbi->sb_timeshift = timeshift;\n\n\tif (!(*flags & SB_RDONLY)) mark_dirty(s, 1);\n\n\thpfs_unlock(s);\n\treturn 0;\n\nout_err:\n\thpfs_unlock(s);\n\treturn -EINVAL;\n}\n\nstatic int hpfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(root->d_sb);\n\n\tseq_printf(seq, \",uid=%u\", from_kuid_munged(&init_user_ns, sbi->sb_uid));\n\tseq_printf(seq, \",gid=%u\", from_kgid_munged(&init_user_ns, sbi->sb_gid));\n\tseq_printf(seq, \",umask=%03o\", (~sbi->sb_mode & 0777));\n\tif (sbi->sb_lowercase)\n\t\tseq_printf(seq, \",case=lower\");\n\tif (!sbi->sb_chk)\n\t\tseq_printf(seq, \",check=none\");\n\tif (sbi->sb_chk == 2)\n\t\tseq_printf(seq, \",check=strict\");\n\tif (!sbi->sb_err)\n\t\tseq_printf(seq, \",errors=continue\");\n\tif (sbi->sb_err == 2)\n\t\tseq_printf(seq, \",errors=panic\");\n\tif (!sbi->sb_chkdsk)\n\t\tseq_printf(seq, \",chkdsk=no\");\n\tif (sbi->sb_chkdsk == 2)\n\t\tseq_printf(seq, \",chkdsk=always\");\n\tif (!sbi->sb_eas)\n\t\tseq_printf(seq, \",eas=no\");\n\tif (sbi->sb_eas == 1)\n\t\tseq_printf(seq, \",eas=ro\");\n\tif (sbi->sb_timeshift)\n\t\tseq_printf(seq, \",timeshift=%d\", sbi->sb_timeshift);\n\treturn 0;\n}\n\n/* Super operations */\n\nstatic const struct super_operations hpfs_sops =\n{\n\t.alloc_inode\t= hpfs_alloc_inode,\n\t.free_inode\t= hpfs_free_inode,\n\t.evict_inode\t= hpfs_evict_inode,\n\t.put_super\t= hpfs_put_super,\n\t.statfs\t\t= hpfs_statfs,\n\t.remount_fs\t= hpfs_remount_fs,\n\t.show_options\t= hpfs_show_options,\n};\n\nstatic int hpfs_fill_super(struct super_block *s, void *options, int silent)\n{\n\tstruct buffer_head *bh0, *bh1, *bh2;\n\tstruct hpfs_boot_block *bootblock;\n\tstruct hpfs_super_block *superblock;\n\tstruct hpfs_spare_block *spareblock;\n\tstruct hpfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t umask;\n\tint lowercase, eas, chk, errs, chkdsk, timeshift;\n\n\tdnode_secno root_dno;\n\tstruct hpfs_dirent *de = NULL;\n\tstruct quad_buffer_head qbh;\n\n\tint o;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi) {\n\t\treturn -ENOMEM;\n\t}\n\ts->s_fs_info = sbi;\n\n\tmutex_init(&sbi->hpfs_mutex);\n\thpfs_lock(s);\n\n\tuid = current_uid();\n\tgid = current_gid();\n\tumask = current_umask();\n\tlowercase = 0;\n\teas = 2;\n\tchk = 1;\n\terrs = 1;\n\tchkdsk = 1;\n\ttimeshift = 0;\n\n\tif (!(o = parse_opts(options, &uid, &gid, &umask, &lowercase,\n\t    &eas, &chk, &errs, &chkdsk, &timeshift))) {\n\t\tpr_err(\"bad mount options.\\n\");\n\t\tgoto bail0;\n\t}\n\tif (o==2) {\n\t\thpfs_help();\n\t\tgoto bail0;\n\t}\n\n\t/*sbi->sb_mounting = 1;*/\n\tsb_set_blocksize(s, 512);\n\tsbi->sb_fs_size = -1;\n\tif (!(bootblock = hpfs_map_sector(s, 0, &bh0, 0))) goto bail1;\n\tif (!(superblock = hpfs_map_sector(s, 16, &bh1, 1))) goto bail2;\n\tif (!(spareblock = hpfs_map_sector(s, 17, &bh2, 0))) goto bail3;\n\n\t/* Check magics */\n\tif (/*le16_to_cpu(bootblock->magic) != BB_MAGIC\n\t    ||*/ le32_to_cpu(superblock->magic) != SB_MAGIC\n\t    || le32_to_cpu(spareblock->magic) != SP_MAGIC) {\n\t\tif (!silent)\n\t\t\tpr_err(\"Bad magic ... probably not HPFS\\n\");\n\t\tgoto bail4;\n\t}\n\n\t/* Check version */\n\tif (!sb_rdonly(s) && superblock->funcversion != 2 && superblock->funcversion != 3) {\n\t\tpr_err(\"Bad version %d,%d. Mount readonly to go around\\n\",\n\t\t\t(int)superblock->version, (int)superblock->funcversion);\n\t\tpr_err(\"please try recent version of HPFS driver at http://artax.karlin.mff.cuni.cz/~mikulas/vyplody/hpfs/index-e.cgi and if it still can't understand this format, contact author - mikulas@artax.karlin.mff.cuni.cz\\n\");\n\t\tgoto bail4;\n\t}\n\n\ts->s_flags |= SB_NOATIME;\n\n\t/* Fill superblock stuff */\n\ts->s_magic = HPFS_SUPER_MAGIC;\n\ts->s_op = &hpfs_sops;\n\ts->s_d_op = &hpfs_dentry_operations;\n\ts->s_time_min =  local_to_gmt(s, 0);\n\ts->s_time_max =  local_to_gmt(s, U32_MAX);\n\n\tsbi->sb_root = le32_to_cpu(superblock->root);\n\tsbi->sb_fs_size = le32_to_cpu(superblock->n_sectors);\n\tsbi->sb_bitmaps = le32_to_cpu(superblock->bitmaps);\n\tsbi->sb_dirband_start = le32_to_cpu(superblock->dir_band_start);\n\tsbi->sb_dirband_size = le32_to_cpu(superblock->n_dir_band);\n\tsbi->sb_dmap = le32_to_cpu(superblock->dir_band_bitmap);\n\tsbi->sb_uid = uid;\n\tsbi->sb_gid = gid;\n\tsbi->sb_mode = 0777 & ~umask;\n\tsbi->sb_n_free = -1;\n\tsbi->sb_n_free_dnodes = -1;\n\tsbi->sb_lowercase = lowercase;\n\tsbi->sb_eas = eas;\n\tsbi->sb_chk = chk;\n\tsbi->sb_chkdsk = chkdsk;\n\tsbi->sb_err = errs;\n\tsbi->sb_timeshift = timeshift;\n\tsbi->sb_was_error = 0;\n\tsbi->sb_cp_table = NULL;\n\tsbi->sb_c_bitmap = -1;\n\tsbi->sb_max_fwd_alloc = 0xffffff;\n\n\tif (sbi->sb_fs_size >= 0x80000000) {\n\t\thpfs_error(s, \"invalid size in superblock: %08x\",\n\t\t\t(unsigned)sbi->sb_fs_size);\n\t\tgoto bail4;\n\t}\n\n\tif (spareblock->n_spares_used)\n\t\thpfs_load_hotfix_map(s, spareblock);\n\n\t/* Load bitmap directory */\n\tif (!(sbi->sb_bmp_dir = hpfs_load_bitmap_directory(s, le32_to_cpu(superblock->bitmaps))))\n\t\tgoto bail4;\n\t\n\t/* Check for general fs errors*/\n\tif (spareblock->dirty && !spareblock->old_wrote) {\n\t\tif (errs == 2) {\n\t\t\tpr_err(\"Improperly stopped, not mounted\\n\");\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"improperly stopped\");\n\t}\n\n\tif (!sb_rdonly(s)) {\n\t\tspareblock->dirty = 1;\n\t\tspareblock->old_wrote = 0;\n\t\tmark_buffer_dirty(bh2);\n\t}\n\n\tif (le32_to_cpu(spareblock->n_dnode_spares) != le32_to_cpu(spareblock->n_dnode_spares_free)) {\n\t\tif (errs >= 2) {\n\t\t\tpr_err(\"Spare dnodes used, try chkdsk\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\thpfs_error(s, \"warning: spare dnodes used, try chkdsk\");\n\t\tif (errs == 0)\n\t\t\tpr_err(\"Proceeding, but your filesystem could be corrupted if you delete files or directories\\n\");\n\t}\n\tif (chk) {\n\t\tunsigned a;\n\t\tif (le32_to_cpu(superblock->dir_band_end) - le32_to_cpu(superblock->dir_band_start) + 1 != le32_to_cpu(superblock->n_dir_band) ||\n\t\t    le32_to_cpu(superblock->dir_band_end) < le32_to_cpu(superblock->dir_band_start) || le32_to_cpu(superblock->n_dir_band) > 0x4000) {\n\t\t\thpfs_error(s, \"dir band size mismatch: dir_band_start==%08x, dir_band_end==%08x, n_dir_band==%08x\",\n\t\t\t\tle32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->dir_band_end), le32_to_cpu(superblock->n_dir_band));\n\t\t\tgoto bail4;\n\t\t}\n\t\ta = sbi->sb_dirband_size;\n\t\tsbi->sb_dirband_size = 0;\n\t\tif (hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_start), le32_to_cpu(superblock->n_dir_band), \"dir_band\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->dir_band_bitmap), 4, \"dir_band_bitmap\") ||\n\t\t    hpfs_chk_sectors(s, le32_to_cpu(superblock->bitmaps), 4, \"bitmaps\")) {\n\t\t\tmark_dirty(s, 0);\n\t\t\tgoto bail4;\n\t\t}\n\t\tsbi->sb_dirband_size = a;\n\t} else\n\t\tpr_err(\"You really don't want any checks? You are crazy...\\n\");\n\n\t/* Load code page table */\n\tif (le32_to_cpu(spareblock->n_code_pages))\n\t\tif (!(sbi->sb_cp_table = hpfs_load_code_page(s, le32_to_cpu(spareblock->code_page_dir))))\n\t\t\tpr_err(\"code page support is disabled\\n\");\n\n\tbrelse(bh2);\n\tbrelse(bh1);\n\tbrelse(bh0);\n\n\troot = iget_locked(s, sbi->sb_root);\n\tif (!root)\n\t\tgoto bail0;\n\thpfs_init_inode(root);\n\thpfs_read_inode(root);\n\tunlock_new_inode(root);\n\ts->s_root = d_make_root(root);\n\tif (!s->s_root)\n\t\tgoto bail0;\n\n\t/*\n\t * find the root directory's . pointer & finish filling in the inode\n\t */\n\n\troot_dno = hpfs_fnode_dno(s, sbi->sb_root);\n\tif (root_dno)\n\t\tde = map_dirent(root, root_dno, \"\\001\\001\", 2, NULL, &qbh);\n\tif (!de)\n\t\thpfs_error(s, \"unable to find root dir\");\n\telse {\n\t\troot->i_atime.tv_sec = local_to_gmt(s, le32_to_cpu(de->read_date));\n\t\troot->i_atime.tv_nsec = 0;\n\t\troot->i_mtime.tv_sec = local_to_gmt(s, le32_to_cpu(de->write_date));\n\t\troot->i_mtime.tv_nsec = 0;\n\t\tinode_set_ctime(root,\n\t\t\t\tlocal_to_gmt(s, le32_to_cpu(de->creation_date)),\n\t\t\t\t0);\n\t\thpfs_i(root)->i_ea_size = le32_to_cpu(de->ea_size);\n\t\thpfs_i(root)->i_parent_dir = root->i_ino;\n\t\tif (root->i_size == -1)\n\t\t\troot->i_size = 2048;\n\t\tif (root->i_blocks == -1)\n\t\t\troot->i_blocks = 5;\n\t\thpfs_brelse4(&qbh);\n\t}\n\thpfs_unlock(s);\n\treturn 0;\n\nbail4:\tbrelse(bh2);\nbail3:\tbrelse(bh1);\nbail2:\tbrelse(bh0);\nbail1:\nbail0:\n\thpfs_unlock(s);\n\tfree_sbi(sbi);\n\treturn -EINVAL;\n}\n\nstatic struct dentry *hpfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hpfs_fill_super);\n}\n\nstatic struct file_system_type hpfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hpfs\",\n\t.mount\t\t= hpfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"hpfs\");\n\nstatic int __init init_hpfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&hpfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_hpfs_fs(void)\n{\n\tunregister_filesystem(&hpfs_fs_type);\n\tdestroy_inodecache();\n}\n\nmodule_init(init_hpfs_fs)\nmodule_exit(exit_hpfs_fs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}