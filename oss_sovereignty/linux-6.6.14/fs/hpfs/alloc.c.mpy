{
  "module_name": "alloc.c",
  "hash_id": "86be644c2860a26961c986d37572cb427e82fcb227991671219b0df3f2e0c1d8",
  "original_prompt": "Ingested from linux-6.6.14/fs/hpfs/alloc.c",
  "human_readable_source": "\n \n\n#include \"hpfs_fn.h\"\n\nstatic void hpfs_claim_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free)) {\n\t\t\thpfs_error(s, \"free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free--;\n\t}\n}\n\nstatic void hpfs_claim_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free >= sbi->sb_fs_size)) {\n\t\t\thpfs_error(s, \"free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free++;\n\t}\n}\n\nstatic void hpfs_claim_dirband_alloc(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(!sbi->sb_n_free_dnodes)) {\n\t\t\thpfs_error(s, \"dirband free count underflow, allocating sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes--;\n\t}\n}\n\nstatic void hpfs_claim_dirband_free(struct super_block *s, secno sec)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (sbi->sb_n_free_dnodes != (unsigned)-1) {\n\t\tif (unlikely(sbi->sb_n_free_dnodes >= sbi->sb_dirband_size / 4)) {\n\t\t\thpfs_error(s, \"dirband free count overflow, freeing sector %08x\", sec);\n\t\t\tsbi->sb_n_free_dnodes = -1;\n\t\t\treturn;\n\t\t}\n\t\tsbi->sb_n_free_dnodes++;\n\t}\n}\n\n \n\nstatic int chk_if_allocated(struct super_block *s, secno sec, char *msg)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"chk\"))) goto fail;\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f)) & 1) {\n\t\thpfs_error(s, \"sector '%s' - %08x not allocated in bitmap\", msg, sec);\n\t\tgoto fail1;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (sec >= hpfs_sb(s)->sb_dirband_start && sec < hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\tunsigned ssec = (sec - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto fail;\n\t\tif ((le32_to_cpu(bmp[ssec >> 5]) >> (ssec & 0x1f)) & 1) {\n\t\t\thpfs_error(s, \"sector '%s' - %08x not allocated in directory bitmap\", msg, sec);\n\t\t\tgoto fail1;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\treturn 0;\n\tfail1:\n\thpfs_brelse4(&qbh);\n\tfail:\n\treturn 1;\n}\n\n \n\t\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}\n\nstatic secno alloc_in_bmp(struct super_block *s, secno near, unsigned n, unsigned forward)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tunsigned bs = near & ~0x3fff;\n\tunsigned nr = (near & 0x3fff) & ~(n - 1);\n\t \n\tunsigned i, q;\n\tint a, b;\n\tsecno ret = 0;\n\tif (n != 1 && n != 4) {\n\t\thpfs_error(s, \"Bad allocation size: %d\", n);\n\t\treturn 0;\n\t}\n\tif (bs != ~0x3fff) {\n\t\tif (!(bmp = hpfs_map_bitmap(s, near >> 14, &qbh, \"aib\"))) goto uls;\n\t} else {\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) goto uls;\n\t}\n\tif (!tstbits(bmp, nr, n + forward)) {\n\t\tret = bs + nr;\n\t\tgoto rt;\n\t}\n\tq = nr + n; b = 0;\n\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\tq += a;\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\tif (!b) {\n\t\t\tif (q>>5 != nr>>5) {\n\t\t\t\tb = 1;\n\t\t\t\tq = nr & 0x1f;\n\t\t\t}\n\t\t} else if (q > nr) break;\n\t}\n\tif (!a) {\n\t\tret = bs + q;\n\t\tgoto rt;\n\t}\n\tnr >>= 5;\n\t \n\ti = nr;\n\tdo {\n\t\tif (!le32_to_cpu(bmp[i])) goto cont;\n\t\tif (n + forward >= 0x3f && le32_to_cpu(bmp[i]) != 0xffffffff) goto cont;\n\t\tq = i<<5;\n\t\tif (i > 0) {\n\t\t\tunsigned k = le32_to_cpu(bmp[i-1]);\n\t\t\twhile (k & 0x80000000) {\n\t\t\t\tq--; k <<= 1;\n\t\t\t}\n\t\t}\n\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\twhile ((a = tstbits(bmp, q, n + forward)) != 0) {\n\t\t\tq += a;\n\t\t\tif (n != 1) q = ((q-1)&~(n-1))+n;\n\t\t\tif (q>>5 > i) break;\n\t\t}\n\t\tif (!a) {\n\t\t\tret = bs + q;\n\t\t\tgoto rt;\n\t\t}\n\t\tcont:\n\t\ti++, i &= 0x1ff;\n\t} while (i != nr);\n\trt:\n\tif (ret) {\n\t\tif (hpfs_sb(s)->sb_chk && ((ret >> 14) != (bs >> 14) || (le32_to_cpu(bmp[(ret & 0x3fff) >> 5]) | ~(((1 << n) - 1) << (ret & 0x1f))) != 0xffffffff)) {\n\t\t\thpfs_error(s, \"Allocation doesn't work! Wanted %d, allocated at %08x\", n, ret);\n\t\t\tret = 0;\n\t\t\tgoto b;\n\t\t}\n\t\tbmp[(ret & 0x3fff) >> 5] &= cpu_to_le32(~(((1 << n) - 1) << (ret & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t}\n\tb:\n\thpfs_brelse4(&qbh);\n\tuls:\n\treturn ret;\n}\n\n \n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t \n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}\n\nstatic secno alloc_in_dirband(struct super_block *s, secno near)\n{\n\tunsigned nr = near;\n\tsecno sec;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tif (nr < sbi->sb_dirband_start)\n\t\tnr = sbi->sb_dirband_start;\n\tif (nr >= sbi->sb_dirband_start + sbi->sb_dirband_size)\n\t\tnr = sbi->sb_dirband_start + sbi->sb_dirband_size - 4;\n\tnr -= sbi->sb_dirband_start;\n\tnr >>= 2;\n\tsec = alloc_in_bmp(s, (~0x3fff) | nr, 1, 0);\n\tif (!sec) return 0;\n\thpfs_claim_dirband_alloc(s, sec);\n\treturn ((sec & 0x3fff) << 2) + sbi->sb_dirband_start;\n}\n\n \n\nint hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}\n\n \n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t \n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}\n\n \n\nint hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}\n\nstruct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}\n\nstruct anode *hpfs_alloc_anode(struct super_block *s, secno near, anode_secno *ano,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct anode *a;\n\tif (!(*ano = hpfs_alloc_sector(s, near, 1, ANODE_ALLOC_FWD))) return NULL;\n\tif (!(a = hpfs_get_sector(s, *ano, bh))) {\n\t\thpfs_free_sectors(s, *ano, 1);\n\t\treturn NULL;\n\t}\n\tmemset(a, 0, 512);\n\ta->magic = cpu_to_le32(ANODE_MAGIC);\n\ta->self = cpu_to_le32(*ano);\n\ta->btree.n_free_nodes = 40;\n\ta->btree.n_used_nodes = 0;\n\ta->btree.first_free = cpu_to_le16(8);\n\treturn a;\n}\n\nstatic unsigned find_run(__le32 *bmp, unsigned *idx)\n{\n\tunsigned len;\n\twhile (tstbits(bmp, *idx, 1)) {\n\t\t(*idx)++;\n\t\tif (unlikely(*idx >= 0x4000))\n\t\t\treturn 0;\n\t}\n\tlen = 1;\n\twhile (!tstbits(bmp, *idx + len, 1))\n\t\tlen++;\n\treturn len;\n}\n\nstatic int do_trim(struct super_block *s, secno start, unsigned len, secno limit_start, secno limit_end, unsigned minlen, unsigned *result)\n{\n\tint err;\n\tsecno end;\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\tend = start + len;\n\tif (start < limit_start)\n\t\tstart = limit_start;\n\tif (end > limit_end)\n\t\tend = limit_end;\n\tif (start >= end)\n\t\treturn 0;\n\tif (end - start < minlen)\n\t\treturn 0;\n\terr = sb_issue_discard(s, start, end - start, GFP_NOFS, 0);\n\tif (err)\n\t\treturn err;\n\t*result += end - start;\n\treturn 0;\n}\n\nint hpfs_trim_fs(struct super_block *s, u64 start, u64 end, u64 minlen, unsigned *result)\n{\n\tint err = 0;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tunsigned idx, len, start_bmp, end_bmp;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\n\t*result = 0;\n\tif (!end || end > sbi->sb_fs_size)\n\t\tend = sbi->sb_fs_size;\n\tif (start >= sbi->sb_fs_size)\n\t\treturn 0;\n\tif (minlen > 0x4000)\n\t\treturn 0;\n\tif (start < sbi->sb_dirband_start + sbi->sb_dirband_size && end > sbi->sb_dirband_start) {\n\t\thpfs_lock(s);\n\t\tif (sb_rdonly(s)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto unlock_1;\n\t\t}\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock_1;\n\t\t}\n\t\tidx = 0;\n\t\twhile ((len = find_run(bmp, &idx)) && !err) {\n\t\t\terr = do_trim(s, sbi->sb_dirband_start + idx * 4, len * 4, start, end, minlen, result);\n\t\t\tidx += len;\n\t\t}\n\t\thpfs_brelse4(&qbh);\nunlock_1:\n\t\thpfs_unlock(s);\n\t}\n\tstart_bmp = start >> 14;\n\tend_bmp = (end + 0x3fff) >> 14;\n\twhile (start_bmp < end_bmp && !err) {\n\t\thpfs_lock(s);\n\t\tif (sb_rdonly(s)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto unlock_2;\n\t\t}\n\t\tif (!(bmp = hpfs_map_bitmap(s, start_bmp, &qbh, \"trim\"))) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock_2;\n\t\t}\n\t\tidx = 0;\n\t\twhile ((len = find_run(bmp, &idx)) && !err) {\n\t\t\terr = do_trim(s, (start_bmp << 14) + idx, len, start, end, minlen, result);\n\t\t\tidx += len;\n\t\t}\n\t\thpfs_brelse4(&qbh);\nunlock_2:\n\t\thpfs_unlock(s);\n\t\tstart_bmp++;\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}