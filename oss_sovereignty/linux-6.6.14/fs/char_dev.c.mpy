{
  "module_name": "char_dev.c",
  "hash_id": "53c8aa46f07e14fdf54dd958db663206effdba310a7317d19f09a288e2499390",
  "original_prompt": "Ingested from linux-6.6.14/fs/char_dev.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\n#include <linux/kobject.h>\n#include <linux/kobj_map.h>\n#include <linux/cdev.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/tty.h>\n\n#include \"internal.h\"\n\nstatic struct kobj_map *cdev_map;\n\nstatic DEFINE_MUTEX(chrdevs_lock);\n\n#define CHRDEV_MAJOR_HASH_SIZE 255\n\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t \n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\n \nstatic inline int major_to_index(unsigned major)\n{\n\treturn major % CHRDEV_MAJOR_HASH_SIZE;\n}\n\n#ifdef CONFIG_PROC_FS\n\nvoid chrdev_show(struct seq_file *f, off_t offset)\n{\n\tstruct char_device_struct *cd;\n\n\tmutex_lock(&chrdevs_lock);\n\tfor (cd = chrdevs[major_to_index(offset)]; cd; cd = cd->next) {\n\t\tif (cd->major == offset)\n\t\t\tseq_printf(f, \"%3d %s\\n\", cd->major, cd->name);\n\t}\n\tmutex_unlock(&chrdevs_lock);\n}\n\n#endif  \n\nstatic int find_dynamic_major(void)\n{\n\tint i;\n\tstruct char_device_struct *cd;\n\n\tfor (i = ARRAY_SIZE(chrdevs)-1; i >= CHRDEV_MAJOR_DYN_END; i--) {\n\t\tif (chrdevs[i] == NULL)\n\t\t\treturn i;\n\t}\n\n\tfor (i = CHRDEV_MAJOR_DYN_EXT_START;\n\t     i >= CHRDEV_MAJOR_DYN_EXT_END; i--) {\n\t\tfor (cd = chrdevs[major_to_index(i)]; cd; cd = cd->next)\n\t\t\tif (cd->major == i)\n\t\t\t\tbreak;\n\n\t\tif (cd == NULL)\n\t\t\treturn i;\n\t}\n\n\treturn -EBUSY;\n}\n\n \nstatic struct char_device_struct *\n__register_chrdev_region(unsigned int major, unsigned int baseminor,\n\t\t\t   int minorct, const char *name)\n{\n\tstruct char_device_struct *cd, *curr, *prev = NULL;\n\tint ret;\n\tint i;\n\n\tif (major >= CHRDEV_MAJOR_MAX) {\n\t\tpr_err(\"CHRDEV \\\"%s\\\" major requested (%u) is greater than the maximum (%u)\\n\",\n\t\t       name, major, CHRDEV_MAJOR_MAX-1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (minorct > MINORMASK + 1 - baseminor) {\n\t\tpr_err(\"CHRDEV \\\"%s\\\" minor range requested (%u-%u) is out of range of maximum range (%u-%u) for a single major\\n\",\n\t\t\tname, baseminor, baseminor + minorct - 1, 0, MINORMASK);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);\n\tif (cd == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&chrdevs_lock);\n\n\tif (major == 0) {\n\t\tret = find_dynamic_major();\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"CHRDEV \\\"%s\\\" dynamic allocation region is full\\n\",\n\t\t\t       name);\n\t\t\tgoto out;\n\t\t}\n\t\tmajor = ret;\n\t}\n\n\tret = -EBUSY;\n\ti = major_to_index(major);\n\tfor (curr = chrdevs[i]; curr; prev = curr, curr = curr->next) {\n\t\tif (curr->major < major)\n\t\t\tcontinue;\n\n\t\tif (curr->major > major)\n\t\t\tbreak;\n\n\t\tif (curr->baseminor + curr->minorct <= baseminor)\n\t\t\tcontinue;\n\n\t\tif (curr->baseminor >= baseminor + minorct)\n\t\t\tbreak;\n\n\t\tgoto out;\n\t}\n\n\tcd->major = major;\n\tcd->baseminor = baseminor;\n\tcd->minorct = minorct;\n\tstrscpy(cd->name, name, sizeof(cd->name));\n\n\tif (!prev) {\n\t\tcd->next = curr;\n\t\tchrdevs[i] = cd;\n\t} else {\n\t\tcd->next = prev->next;\n\t\tprev->next = cd;\n\t}\n\n\tmutex_unlock(&chrdevs_lock);\n\treturn cd;\nout:\n\tmutex_unlock(&chrdevs_lock);\n\tkfree(cd);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct char_device_struct *\n__unregister_chrdev_region(unsigned major, unsigned baseminor, int minorct)\n{\n\tstruct char_device_struct *cd = NULL, **cp;\n\tint i = major_to_index(major);\n\n\tmutex_lock(&chrdevs_lock);\n\tfor (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)\n\t\tif ((*cp)->major == major &&\n\t\t    (*cp)->baseminor == baseminor &&\n\t\t    (*cp)->minorct == minorct)\n\t\t\tbreak;\n\tif (*cp) {\n\t\tcd = *cp;\n\t\t*cp = cd->next;\n\t}\n\tmutex_unlock(&chrdevs_lock);\n\treturn cd;\n}\n\n \nint register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}\n\n \nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,\n\t\t\tconst char *name)\n{\n\tstruct char_device_struct *cd;\n\tcd = __register_chrdev_region(0, baseminor, count, name);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\t*dev = MKDEV(cd->major, cd->baseminor);\n\treturn 0;\n}\n\n \nint __register_chrdev(unsigned int major, unsigned int baseminor,\n\t\t      unsigned int count, const char *name,\n\t\t      const struct file_operations *fops)\n{\n\tstruct char_device_struct *cd;\n\tstruct cdev *cdev;\n\tint err = -ENOMEM;\n\n\tcd = __register_chrdev_region(major, baseminor, count, name);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto out2;\n\n\tcdev->owner = fops->owner;\n\tcdev->ops = fops;\n\tkobject_set_name(&cdev->kobj, \"%s\", name);\n\n\terr = cdev_add(cdev, MKDEV(cd->major, baseminor), count);\n\tif (err)\n\t\tgoto out;\n\n\tcd->cdev = cdev;\n\n\treturn major ? 0 : cd->major;\nout:\n\tkobject_put(&cdev->kobj);\nout2:\n\tkfree(__unregister_chrdev_region(cd->major, baseminor, count));\n\treturn err;\n}\n\n \nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}\n\n \nvoid __unregister_chrdev(unsigned int major, unsigned int baseminor,\n\t\t\t unsigned int count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\n\tcd = __unregister_chrdev_region(major, baseminor, count);\n\tif (cd && cd->cdev)\n\t\tcdev_del(cd->cdev);\n\tkfree(cd);\n}\n\nstatic DEFINE_SPINLOCK(cdev_lock);\n\nstatic struct kobject *cdev_get(struct cdev *p)\n{\n\tstruct module *owner = p->owner;\n\tstruct kobject *kobj;\n\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get_unless_zero(&p->kobj);\n\tif (!kobj)\n\t\tmodule_put(owner);\n\treturn kobj;\n}\n\nvoid cdev_put(struct cdev *p)\n{\n\tif (p) {\n\t\tstruct module *owner = p->owner;\n\t\tkobject_put(&p->kobj);\n\t\tmodule_put(owner);\n\t}\n}\n\n \nstatic int chrdev_open(struct inode *inode, struct file *filp)\n{\n\tconst struct file_operations *fops;\n\tstruct cdev *p;\n\tstruct cdev *new = NULL;\n\tint ret = 0;\n\n\tspin_lock(&cdev_lock);\n\tp = inode->i_cdev;\n\tif (!p) {\n\t\tstruct kobject *kobj;\n\t\tint idx;\n\t\tspin_unlock(&cdev_lock);\n\t\tkobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);\n\t\tif (!kobj)\n\t\t\treturn -ENXIO;\n\t\tnew = container_of(kobj, struct cdev, kobj);\n\t\tspin_lock(&cdev_lock);\n\t\t \n\t\tp = inode->i_cdev;\n\t\tif (!p) {\n\t\t\tinode->i_cdev = p = new;\n\t\t\tlist_add(&inode->i_devices, &p->list);\n\t\t\tnew = NULL;\n\t\t} else if (!cdev_get(p))\n\t\t\tret = -ENXIO;\n\t} else if (!cdev_get(p))\n\t\tret = -ENXIO;\n\tspin_unlock(&cdev_lock);\n\tcdev_put(new);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENXIO;\n\tfops = fops_get(p->ops);\n\tif (!fops)\n\t\tgoto out_cdev_put;\n\n\treplace_fops(filp, fops);\n\tif (filp->f_op->open) {\n\t\tret = filp->f_op->open(inode, filp);\n\t\tif (ret)\n\t\t\tgoto out_cdev_put;\n\t}\n\n\treturn 0;\n\n out_cdev_put:\n\tcdev_put(p);\n\treturn ret;\n}\n\nvoid cd_forget(struct inode *inode)\n{\n\tspin_lock(&cdev_lock);\n\tlist_del_init(&inode->i_devices);\n\tinode->i_cdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&cdev_lock);\n}\n\nstatic void cdev_purge(struct cdev *cdev)\n{\n\tspin_lock(&cdev_lock);\n\twhile (!list_empty(&cdev->list)) {\n\t\tstruct inode *inode;\n\t\tinode = container_of(cdev->list.next, struct inode, i_devices);\n\t\tlist_del_init(&inode->i_devices);\n\t\tinode->i_cdev = NULL;\n\t}\n\tspin_unlock(&cdev_lock);\n}\n\n \nconst struct file_operations def_chr_fops = {\n\t.open = chrdev_open,\n\t.llseek = noop_llseek,\n};\n\nstatic struct kobject *exact_match(dev_t dev, int *part, void *data)\n{\n\tstruct cdev *p = data;\n\treturn &p->kobj;\n}\n\nstatic int exact_lock(dev_t dev, void *data)\n{\n\tstruct cdev *p = data;\n\treturn cdev_get(p) ? 0 : -1;\n}\n\n \nint cdev_add(struct cdev *p, dev_t dev, unsigned count)\n{\n\tint error;\n\n\tp->dev = dev;\n\tp->count = count;\n\n\tif (WARN_ON(dev == WHITEOUT_DEV)) {\n\t\terror = -EBUSY;\n\t\tgoto err;\n\t}\n\n\terror = kobj_map(cdev_map, dev, count, NULL,\n\t\t\t exact_match, exact_lock, p);\n\tif (error)\n\t\tgoto err;\n\n\tkobject_get(p->kobj.parent);\n\n\treturn 0;\n\nerr:\n\tkfree_const(p->kobj.name);\n\tp->kobj.name = NULL;\n\treturn error;\n}\n\n \nvoid cdev_set_parent(struct cdev *p, struct kobject *kobj)\n{\n\tWARN_ON(!kobj->state_initialized);\n\tp->kobj.parent = kobj;\n}\n\n \nint cdev_device_add(struct cdev *cdev, struct device *dev)\n{\n\tint rc = 0;\n\n\tif (dev->devt) {\n\t\tcdev_set_parent(cdev, &dev->kobj);\n\n\t\trc = cdev_add(cdev, dev->devt, 1);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = device_add(dev);\n\tif (rc && dev->devt)\n\t\tcdev_del(cdev);\n\n\treturn rc;\n}\n\n \nvoid cdev_device_del(struct cdev *cdev, struct device *dev)\n{\n\tdevice_del(dev);\n\tif (dev->devt)\n\t\tcdev_del(cdev);\n}\n\nstatic void cdev_unmap(dev_t dev, unsigned count)\n{\n\tkobj_unmap(cdev_map, dev, count);\n}\n\n \nvoid cdev_del(struct cdev *p)\n{\n\tcdev_unmap(p->dev, p->count);\n\tkobject_put(&p->kobj);\n}\n\n\nstatic void cdev_default_release(struct kobject *kobj)\n{\n\tstruct cdev *p = container_of(kobj, struct cdev, kobj);\n\tstruct kobject *parent = kobj->parent;\n\n\tcdev_purge(p);\n\tkobject_put(parent);\n}\n\nstatic void cdev_dynamic_release(struct kobject *kobj)\n{\n\tstruct cdev *p = container_of(kobj, struct cdev, kobj);\n\tstruct kobject *parent = kobj->parent;\n\n\tcdev_purge(p);\n\tkfree(p);\n\tkobject_put(parent);\n}\n\nstatic struct kobj_type ktype_cdev_default = {\n\t.release\t= cdev_default_release,\n};\n\nstatic struct kobj_type ktype_cdev_dynamic = {\n\t.release\t= cdev_dynamic_release,\n};\n\n \nstruct cdev *cdev_alloc(void)\n{\n\tstruct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);\n\tif (p) {\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tkobject_init(&p->kobj, &ktype_cdev_dynamic);\n\t}\n\treturn p;\n}\n\n \nvoid cdev_init(struct cdev *cdev, const struct file_operations *fops)\n{\n\tmemset(cdev, 0, sizeof *cdev);\n\tINIT_LIST_HEAD(&cdev->list);\n\tkobject_init(&cdev->kobj, &ktype_cdev_default);\n\tcdev->ops = fops;\n}\n\nstatic struct kobject *base_probe(dev_t dev, int *part, void *data)\n{\n\tif (request_module(\"char-major-%d-%d\", MAJOR(dev), MINOR(dev)) > 0)\n\t\t \n\t\trequest_module(\"char-major-%d\", MAJOR(dev));\n\treturn NULL;\n}\n\nvoid __init chrdev_init(void)\n{\n\tcdev_map = kobj_map_init(base_probe, &chrdevs_lock);\n}\n\n\n \nEXPORT_SYMBOL(register_chrdev_region);\nEXPORT_SYMBOL(unregister_chrdev_region);\nEXPORT_SYMBOL(alloc_chrdev_region);\nEXPORT_SYMBOL(cdev_init);\nEXPORT_SYMBOL(cdev_alloc);\nEXPORT_SYMBOL(cdev_del);\nEXPORT_SYMBOL(cdev_add);\nEXPORT_SYMBOL(cdev_set_parent);\nEXPORT_SYMBOL(cdev_device_add);\nEXPORT_SYMBOL(cdev_device_del);\nEXPORT_SYMBOL(__register_chrdev);\nEXPORT_SYMBOL(__unregister_chrdev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}