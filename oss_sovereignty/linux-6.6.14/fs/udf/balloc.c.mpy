{
  "module_name": "balloc.c",
  "hash_id": "e2e239087b42611d33020d2bacd94d06ae9b07018d07380ee6189da4430eb55c",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/balloc.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include <linux/bitops.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\n#define udf_clear_bit\t__test_and_clear_bit_le\n#define udf_set_bit\t__test_and_set_bit_le\n#define udf_test_bit\ttest_bit_le\n#define udf_find_next_one_bit\tfind_next_bit_le\n\nstatic int read_block_bitmap(struct super_block *sb,\n\t\t\t     struct udf_bitmap *bitmap, unsigned int block,\n\t\t\t     unsigned long bitmap_nr)\n{\n\tstruct buffer_head *bh = NULL;\n\tint i;\n\tint max_bits, off, count;\n\tstruct kernel_lb_addr loc;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\n\tbh = sb_bread(sb, udf_get_lb_pblock(sb, &loc, block));\n\tbitmap->s_block_bitmap[bitmap_nr] = bh;\n\tif (!bh)\n\t\treturn -EIO;\n\n\t \n\tmax_bits = sb->s_blocksize * 8;\n\tif (!bitmap_nr) {\n\t\toff = sizeof(struct spaceBitmapDesc) << 3;\n\t\tcount = min(max_bits - off, bitmap->s_nr_groups);\n\t} else {\n\t\t \n\t\tif (bitmap_nr >\n\t\t    (bitmap->s_nr_groups >> (sb->s_blocksize_bits + 3)) + 2)\n\t\t\treturn 0;\n\t\toff = 0;\n\t\tcount = bitmap->s_nr_groups - bitmap_nr * max_bits +\n\t\t\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\t\tcount = min(count, max_bits);\n\t}\n\n\tfor (i = 0; i < count; i++)\n\t\tif (udf_test_bit(i + off, bh->b_data))\n\t\t\treturn -EFSCORRUPTED;\n\treturn 0;\n}\n\nstatic int __load_block_bitmap(struct super_block *sb,\n\t\t\t       struct udf_bitmap *bitmap,\n\t\t\t       unsigned int block_group)\n{\n\tint retval = 0;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tif (block_group >= nr_groups) {\n\t\tudf_debug(\"block_group (%u) > nr_groups (%d)\\n\",\n\t\t\t  block_group, nr_groups);\n\t}\n\n\tif (bitmap->s_block_bitmap[block_group])\n\t\treturn block_group;\n\n\tretval = read_block_bitmap(sb, bitmap, block_group, block_group);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn block_group;\n}\n\nstatic inline int load_block_bitmap(struct super_block *sb,\n\t\t\t\t    struct udf_bitmap *bitmap,\n\t\t\t\t    unsigned int block_group)\n{\n\tint slot;\n\n\tslot = __load_block_bitmap(sb, bitmap, block_group);\n\n\tif (slot < 0)\n\t\treturn slot;\n\n\tif (!bitmap->s_block_bitmap[slot])\n\t\treturn -EIO;\n\n\treturn slot;\n}\n\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\tif (!sbi->s_lvid_bh)\n\t\treturn;\n\n\tlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\n\tle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\n\tudf_updated_lvid(sb);\n}\n\nstatic void udf_bitmap_free_blocks(struct super_block *sb,\n\t\t\t\t   struct udf_bitmap *bitmap,\n\t\t\t\t   struct kernel_lb_addr *bloc,\n\t\t\t\t   uint32_t offset,\n\t\t\t\t   uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_part_map *partmap;\n\tunsigned long block;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tint bitmap_nr;\n\tunsigned long overflow;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%u < %d || %u + %u > %u\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tblock = bloc->logicalBlockNum + offset +\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tdo {\n\t\toverflow = 0;\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\t \n\t\tif (bit + count > (sb->s_blocksize << 3)) {\n\t\t\toverflow = bit + count - (sb->s_blocksize << 3);\n\t\t\tcount -= overflow;\n\t\t}\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (udf_set_bit(bit + i, bh->b_data)) {\n\t\t\t\tudf_debug(\"bit %lu already set\\n\", bit + i);\n\t\t\t\tudf_debug(\"byte=%2x\\n\",\n\t\t\t\t\t  ((__u8 *)bh->b_data)[(bit + i) >> 3]);\n\t\t\t}\n\t\t}\n\t\tudf_add_free_space(sb, sbi->s_partition, count);\n\t\tmark_buffer_dirty(bh);\n\t\tif (overflow) {\n\t\t\tblock += count;\n\t\t\tcount = overflow;\n\t\t}\n\t} while (overflow);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}\n\nstatic int udf_bitmap_prealloc_blocks(struct super_block *sb,\n\t\t\t\t      struct udf_bitmap *bitmap,\n\t\t\t\t      uint16_t partition, uint32_t first_block,\n\t\t\t\t      uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tint bit, block, block_group;\n\tint bitmap_nr;\n\tstruct buffer_head *bh;\n\t__u32 part_len;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpart_len = sbi->s_partmaps[partition].s_partition_len;\n\tif (first_block >= part_len)\n\t\tgoto out;\n\n\tif (first_block + block_count > part_len)\n\t\tblock_count = part_len - first_block;\n\n\tdo {\n\t\tblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\n\t\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto out;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\n\t\tbit = block % (sb->s_blocksize << 3);\n\n\t\twhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\n\t\t\tif (!udf_clear_bit(bit, bh->b_data))\n\t\t\t\tgoto out;\n\t\t\tblock_count--;\n\t\t\talloc_count++;\n\t\t\tbit++;\n\t\t\tblock++;\n\t\t}\n\t\tmark_buffer_dirty(bh);\n\t} while (block_count > 0);\n\nout:\n\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}\n\nstatic udf_pblk_t udf_bitmap_new_block(struct super_block *sb,\n\t\t\t\tstruct udf_bitmap *bitmap, uint16_t partition,\n\t\t\t\tuint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint newbit, bit = 0;\n\tudf_pblk_t block;\n\tint block_group, group_start;\n\tint end_goal, nr_groups, bitmap_nr, i;\n\tstruct buffer_head *bh = NULL;\n\tchar *ptr;\n\tudf_pblk_t newblock = 0;\n\n\t*err = -ENOSPC;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\nrepeat:\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\tnr_groups = bitmap->s_nr_groups;\n\tblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\n\tblock_group = block >> (sb->s_blocksize_bits + 3);\n\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\tif (bitmap_nr < 0)\n\t\tgoto error_return;\n\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t      sb->s_blocksize - group_start);\n\n\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\tbit = block % (sb->s_blocksize << 3);\n\t\tif (udf_test_bit(bit, bh->b_data))\n\t\t\tgoto got_block;\n\n\t\tend_goal = (bit + 63) & ~63;\n\t\tbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\n\t\tif (bit < end_goal)\n\t\t\tgoto got_block;\n\n\t\tptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\n\t\t\t      sb->s_blocksize - ((bit + 7) >> 3));\n\t\tnewbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto search_back;\n\t\t}\n\n\t\tnewbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t       sb->s_blocksize << 3, bit);\n\t\tif (newbit < sb->s_blocksize << 3) {\n\t\t\tbit = newbit;\n\t\t\tgoto got_block;\n\t\t}\n\t}\n\n\tfor (i = 0; i < (nr_groups * 2); i++) {\n\t\tblock_group++;\n\t\tif (block_group >= nr_groups)\n\t\t\tblock_group = 0;\n\t\tgroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\n\n\t\tbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\n\t\tif (bitmap_nr < 0)\n\t\t\tgoto error_return;\n\t\tbh = bitmap->s_block_bitmap[bitmap_nr];\n\t\tif (i < nr_groups) {\n\t\t\tptr = memscan((char *)bh->b_data + group_start, 0xFF,\n\t\t\t\t      sb->s_blocksize - group_start);\n\t\t\tif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\n\t\t\t\tbit = (ptr - ((char *)bh->b_data)) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbit = udf_find_next_one_bit(bh->b_data,\n\t\t\t\t\t\t    sb->s_blocksize << 3,\n\t\t\t\t\t\t    group_start << 3);\n\t\t\tif (bit < sb->s_blocksize << 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= (nr_groups * 2)) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn newblock;\n\t}\n\tif (bit < sb->s_blocksize << 3)\n\t\tgoto search_back;\n\telse\n\t\tbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\n\t\t\t\t\t    group_start << 3);\n\tif (bit >= sb->s_blocksize << 3) {\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\nsearch_back:\n\ti = 0;\n\twhile (i < 7 && bit > (group_start << 3) &&\n\t       udf_test_bit(bit - 1, bh->b_data)) {\n\t\t++i;\n\t\t--bit;\n\t}\n\ngot_block:\n\tnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\n\t\t(sizeof(struct spaceBitmapDesc) << 3);\n\n\tif (newblock >= sbi->s_partmaps[partition].s_partition_len) {\n\t\t \n\t\tudf_err(sb, \"bitmap for partition %d corrupted (block %u marked\"\n\t\t\t\" as free, partition length is %u)\\n\", partition,\n\t\t\tnewblock, sbi->s_partmaps[partition].s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tif (!udf_clear_bit(bit, bh->b_data)) {\n\t\tudf_debug(\"bit already cleared for block %d\\n\", bit);\n\t\tgoto repeat;\n\t}\n\n\tmark_buffer_dirty(bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n\nerror_return:\n\t*err = -EIO;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn 0;\n}\n\nstatic void udf_table_free_blocks(struct super_block *sb,\n\t\t\t\t  struct inode *table,\n\t\t\t\t  struct kernel_lb_addr *bloc,\n\t\t\t\t  uint32_t offset,\n\t\t\t\t  uint32_t count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *partmap;\n\tuint32_t start, end;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position oepos, epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tpartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\n\tif (bloc->logicalBlockNum + count < count ||\n\t    (bloc->logicalBlockNum + count) > partmap->s_partition_len) {\n\t\tudf_debug(\"%u < %d || %u + %u > %u\\n\",\n\t\t\t  bloc->logicalBlockNum, 0,\n\t\t\t  bloc->logicalBlockNum, count,\n\t\t\t  partmap->s_partition_len);\n\t\tgoto error_return;\n\t}\n\n\tiinfo = UDF_I(table);\n\tudf_add_free_space(sb, sbi->s_partition, count);\n\n\tstart = bloc->logicalBlockNum + offset;\n\tend = bloc->logicalBlockNum + offset + count - 1;\n\n\tepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\n\telen = 0;\n\tepos.block = oepos.block = iinfo->i_location;\n\tepos.bh = oepos.bh = NULL;\n\n\twhile (count &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (((eloc.logicalBlockNum +\n\t\t\t(elen >> sb->s_blocksize_bits)) == start)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tstart += tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tstart += count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t} else if (eloc.logicalBlockNum == (end + 1)) {\n\t\t\tif ((0x3FFFFFFF - elen) <\n\t\t\t\t\t(count << sb->s_blocksize_bits)) {\n\t\t\t\tuint32_t tmp = ((0x3FFFFFFF - elen) >>\n\t\t\t\t\t\tsb->s_blocksize_bits);\n\t\t\t\tcount -= tmp;\n\t\t\t\tend -= tmp;\n\t\t\t\teloc.logicalBlockNum -= tmp;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(0x40000000 - sb->s_blocksize);\n\t\t\t} else {\n\t\t\t\teloc.logicalBlockNum = start;\n\t\t\t\telen = (etype << 30) |\n\t\t\t\t\t(elen +\n\t\t\t\t\t(count << sb->s_blocksize_bits));\n\t\t\t\tend -= count;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tudf_write_aext(table, &oepos, &eloc, elen, 1);\n\t\t}\n\n\t\tif (epos.bh != oepos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = 0;\n\t\t} else {\n\t\t\toepos.offset = epos.offset;\n\t\t}\n\t}\n\n\tif (count) {\n\t\t \n\n\t\tint adsize;\n\n\t\teloc.logicalBlockNum = start;\n\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t(count << sb->s_blocksize_bits);\n\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tadsize = sizeof(struct short_ad);\n\t\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tadsize = sizeof(struct long_ad);\n\t\telse {\n\t\t\tbrelse(oepos.bh);\n\t\t\tbrelse(epos.bh);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (epos.offset + (2 * adsize) > sb->s_blocksize) {\n\t\t\t \n\t\t\tudf_setup_indirect_aext(table, eloc.logicalBlockNum,\n\t\t\t\t\t\t&epos);\n\n\t\t\teloc.logicalBlockNum++;\n\t\t\telen -= sb->s_blocksize;\n\t\t}\n\n\t\t \n\t\tif (elen)\n\t\t\t__udf_add_aext(table, &epos, &eloc, elen, 1);\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\nerror_return:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn;\n}\n\nstatic int udf_table_prealloc_blocks(struct super_block *sb,\n\t\t\t\t     struct inode *table, uint16_t partition,\n\t\t\t\t     uint32_t first_block, uint32_t block_count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint alloc_count = 0;\n\tuint32_t elen, adsize;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo;\n\n\tif (first_block >= sbi->s_partmaps[partition].s_partition_len)\n\t\treturn 0;\n\n\tiinfo = UDF_I(table);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = NULL;\n\teloc.logicalBlockNum = 0xFFFFFFFF;\n\n\twhile (first_block != eloc.logicalBlockNum &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_debug(\"eloc=%u, elen=%u, first_block=%u\\n\",\n\t\t\t  eloc.logicalBlockNum, elen, first_block);\n\t\t;  \n\t}\n\n\tif (first_block == eloc.logicalBlockNum) {\n\t\tepos.offset -= adsize;\n\n\t\talloc_count = (elen >> sb->s_blocksize_bits);\n\t\tif (alloc_count > block_count) {\n\t\t\talloc_count = block_count;\n\t\t\teloc.logicalBlockNum += alloc_count;\n\t\t\telen -= (alloc_count << sb->s_blocksize_bits);\n\t\t\tudf_write_aext(table, &epos, &eloc,\n\t\t\t\t\t(etype << 30) | elen, 1);\n\t\t} else\n\t\t\tudf_delete_aext(table, epos);\n\t} else {\n\t\talloc_count = 0;\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (alloc_count)\n\t\tudf_add_free_space(sb, partition, -alloc_count);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn alloc_count;\n}\n\nstatic udf_pblk_t udf_table_new_block(struct super_block *sb,\n\t\t\t       struct inode *table, uint16_t partition,\n\t\t\t       uint32_t goal, int *err)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\n\tudf_pblk_t newblock = 0;\n\tuint32_t adsize;\n\tuint32_t elen, goal_elen = 0;\n\tstruct kernel_lb_addr eloc, goal_eloc;\n\tstruct extent_position epos, goal_epos;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(table);\n\n\t*err = -ENOSPC;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn newblock;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (goal >= sbi->s_partmaps[partition].s_partition_len)\n\t\tgoal = 0;\n\n\t \n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.block = iinfo->i_location;\n\tepos.bh = goal_epos.bh = NULL;\n\n\twhile (spread &&\n\t       (etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\n\t\tif (goal >= eloc.logicalBlockNum) {\n\t\t\tif (goal < eloc.logicalBlockNum +\n\t\t\t\t\t(elen >> sb->s_blocksize_bits))\n\t\t\t\tnspread = 0;\n\t\t\telse\n\t\t\t\tnspread = goal - eloc.logicalBlockNum -\n\t\t\t\t\t(elen >> sb->s_blocksize_bits);\n\t\t} else {\n\t\t\tnspread = eloc.logicalBlockNum - goal;\n\t\t}\n\n\t\tif (nspread < spread) {\n\t\t\tspread = nspread;\n\t\t\tif (goal_epos.bh != epos.bh) {\n\t\t\t\tbrelse(goal_epos.bh);\n\t\t\t\tgoal_epos.bh = epos.bh;\n\t\t\t\tget_bh(goal_epos.bh);\n\t\t\t}\n\t\t\tgoal_epos.block = epos.block;\n\t\t\tgoal_epos.offset = epos.offset - adsize;\n\t\t\tgoal_eloc = eloc;\n\t\t\tgoal_elen = (etype << 30) | elen;\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\n\tif (spread == 0xFFFFFFFF) {\n\t\tbrelse(goal_epos.bh);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\t \n\n\tnewblock = goal_eloc.logicalBlockNum;\n\tgoal_eloc.logicalBlockNum++;\n\tgoal_elen -= sb->s_blocksize;\n\n\tif (goal_elen)\n\t\tudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\n\telse\n\t\tudf_delete_aext(table, goal_epos);\n\tbrelse(goal_epos.bh);\n\n\tudf_add_free_space(sb, partition, -1);\n\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t*err = 0;\n\treturn newblock;\n}\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}\n\ninline int udf_prealloc_blocks(struct super_block *sb,\n\t\t\t       struct inode *inode,\n\t\t\t       uint16_t partition, uint32_t first_block,\n\t\t\t       uint32_t block_count)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint allocated;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_uspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_uspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse\n\t\treturn 0;\n\n\tif (inode && allocated > 0)\n\t\tinode_add_bytes(inode, allocated << sb->s_blocksize_bits);\n\treturn allocated;\n}\n\ninline udf_pblk_t udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tudf_pblk_t block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}