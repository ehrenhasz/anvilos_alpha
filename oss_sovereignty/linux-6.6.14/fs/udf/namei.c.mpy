{
  "module_name": "namei.c",
  "hash_id": "b699d5e3c778fc1e7e334cf9de9bde954f7fe821e31ac6f38eb784cdfde39b91",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/namei.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/crc-itu-t.h>\n#include <linux/exportfs.h>\n#include <linux/iversion.h>\n\nstatic inline int udf_match(int len1, const unsigned char *name1, int len2,\n\t\t\t    const unsigned char *name2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\treturn !memcmp(name1, name2, len1);\n}\n\n \nstatic int udf_fiiter_find_entry(struct inode *dir, const struct qstr *child,\n\t\t\t\t struct udf_fileident_iter *iter)\n{\n\tint flen;\n\tunsigned char *fname = NULL;\n\tstruct super_block *sb = dir->i_sb;\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tint ret;\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\treturn -ENOMEM;\n\n\tfor (ret = udf_fiiter_init(iter, dir, 0);\n\t     !ret && iter->pos < dir->i_size;\n\t     ret = udf_fiiter_advance(iter)) {\n\t\tif (iter->fi.fileCharacteristics & FID_FILE_CHAR_DELETED) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (iter->fi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((iter->fi.fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!iter->fi.lengthFileIdent)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, iter->name,\n\t\t\t\titer->fi.lengthFileIdent, fname, UDF_NAME_LEN);\n\t\tif (flen < 0) {\n\t\t\tret = flen;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\tif (!ret)\n\t\tret = -ENOENT;\n\nout_err:\n\tudf_fiiter_release(iter);\nout_ok:\n\tkfree(fname);\n\n\treturn ret;\n}\n\nstatic struct dentry *udf_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct udf_fileident_iter iter;\n\tint err;\n\n\tif (dentry->d_name.len > UDF_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\terr = udf_fiiter_find_entry(dir, &dentry->d_name, &iter);\n\tif (err < 0 && err != -ENOENT)\n\t\treturn ERR_PTR(err);\n\n\tif (err == 0) {\n\t\tstruct kernel_lb_addr loc;\n\n\t\tloc = lelb_to_cpu(iter.fi.icb.extLocation);\n\t\tudf_fiiter_release(&iter);\n\n\t\tinode = udf_iget(dir->i_sb, &loc);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int udf_expand_dir_adinicb(struct inode *inode, udf_pblk_t *block)\n{\n\tudf_pblk_t newblock;\n\tstruct buffer_head *dbh = NULL;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\tuint8_t alloctype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_fileident_iter iter;\n\tuint8_t *impuse;\n\tint ret;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\talloctype = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\talloctype = ICBTAG_FLAG_AD_LONG;\n\n\tif (!inode->i_size) {\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\n\t \n\t*block = udf_new_block(inode->i_sb, inode,\n\t\t\t       iinfo->i_location.partitionReferenceNum,\n\t\t\t       iinfo->i_location.logicalBlockNum, &ret);\n\tif (!(*block))\n\t\treturn ret;\n\tnewblock = udf_get_pblock(inode->i_sb, *block,\n\t\t\t\t  iinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\tif (newblock == 0xffffffff)\n\t\treturn -EFSCORRUPTED;\n\tdbh = sb_getblk(inode->i_sb, newblock);\n\tif (!dbh)\n\t\treturn -ENOMEM;\n\tlock_buffer(dbh);\n\tmemcpy(dbh->b_data, iinfo->i_data, inode->i_size);\n\tmemset(dbh->b_data + inode->i_size, 0,\n\t       inode->i_sb->s_blocksize - inode->i_size);\n\tset_buffer_uptodate(dbh);\n\tunlock_buffer(dbh);\n\n\t \n\tiinfo->i_alloc_type = alloctype;\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0, iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\teloc.logicalBlockNum = *block;\n\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\tiinfo->i_lenExtents = inode->i_size;\n\tepos.bh = NULL;\n\tepos.block = iinfo->i_location;\n\tepos.offset = udf_file_entry_alloc_offset(inode);\n\tret = udf_add_aext(inode, &epos, &eloc, inode->i_size, 0);\n\tbrelse(epos.bh);\n\tif (ret < 0) {\n\t\tbrelse(dbh);\n\t\tudf_free_blocks(inode->i_sb, inode, &eloc, 0, 1);\n\t\treturn ret;\n\t}\n\tmark_inode_dirty(inode);\n\n\t \n\tfor (ret = udf_fiiter_init(&iter, inode, 0);\n\t     !ret && iter.pos < inode->i_size;\n\t     ret = udf_fiiter_advance(&iter)) {\n\t\titer.fi.descTag.tagLocation = cpu_to_le32(*block);\n\t\tif (iter.fi.lengthOfImpUse != cpu_to_le16(0))\n\t\t\timpuse = dbh->b_data + iter.pos +\n\t\t\t\t\t\tsizeof(struct fileIdentDesc);\n\t\telse\n\t\t\timpuse = NULL;\n\t\tudf_fiiter_write_fi(&iter, impuse);\n\t}\n\tbrelse(dbh);\n\t \n\tWARN_ON_ONCE(ret);\n\tudf_fiiter_release(&iter);\n\n\treturn 0;\n}\n\nstatic int udf_fiiter_add_entry(struct inode *dir, struct dentry *dentry,\n\t\t\t\tstruct udf_fileident_iter *iter)\n{\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint nfidlen, namelen = 0;\n\tint ret;\n\tint off, blksize = 1 << dir->i_blkbits;\n\tudf_pblk_t block;\n\tchar name[UDF_NAME_LEN_CS0];\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len)\n\t\t\treturn -EINVAL;\n\t\tnamelen = udf_put_filename(dir->i_sb, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len,\n\t\t\t\t\t   name, UDF_NAME_LEN_CS0);\n\t\tif (!namelen)\n\t\t\treturn -ENAMETOOLONG;\n\t}\n\tnfidlen = ALIGN(sizeof(struct fileIdentDesc) + namelen, UDF_NAME_PAD);\n\n\tfor (ret = udf_fiiter_init(iter, dir, 0);\n\t     !ret && iter->pos < dir->i_size;\n\t     ret = udf_fiiter_advance(iter)) {\n\t\tif (iter->fi.fileCharacteristics & FID_FILE_CHAR_DELETED) {\n\t\t\tif (udf_dir_entry_len(&iter->fi) == nfidlen) {\n\t\t\t\titer->fi.descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\titer->fi.fileVersionNum = cpu_to_le16(1);\n\t\t\t\titer->fi.fileCharacteristics = 0;\n\t\t\t\titer->fi.lengthFileIdent = namelen;\n\t\t\t\titer->fi.lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tmemcpy(iter->namebuf, name, namelen);\n\t\t\t\titer->name = iter->namebuf;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret) {\n\t\tudf_fiiter_release(iter);\n\t\treturn ret;\n\t}\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    blksize - udf_ext0_offset(dir) - iter->pos < nfidlen) {\n\t\tudf_fiiter_release(iter);\n\t\tret = udf_expand_dir_adinicb(dir, &block);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = udf_fiiter_init(iter, dir, dir->i_size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t} else {\n\t\tblock = iter->eloc.logicalBlockNum +\n\t\t\t\t((iter->elen - 1) >> dir->i_blkbits);\n\t}\n\toff = iter->pos & (blksize - 1);\n\tif (!off)\n\t\toff = blksize;\n\t \n\tif (blksize - udf_ext0_offset(dir) - off >= nfidlen)\n\t\tgoto store_fi;\n\n\tret = udf_fiiter_append_blk(iter);\n\tif (ret) {\n\t\tudf_fiiter_release(iter);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(iter->pos & (blksize - 1)))\n\t\tblock = iter->eloc.logicalBlockNum +\n\t\t\t\t((iter->elen - 1) >> dir->i_blkbits);\nstore_fi:\n\tmemset(&iter->fi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(dir->i_sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)(&iter->fi), TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)(&iter->fi), TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\titer->fi.fileVersionNum = cpu_to_le16(1);\n\titer->fi.lengthFileIdent = namelen;\n\titer->fi.lengthOfImpUse = cpu_to_le16(0);\n\tmemcpy(iter->namebuf, name, namelen);\n\titer->name = iter->namebuf;\n\n\tdir->i_size += nfidlen;\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tdinfo->i_lenAlloc += nfidlen;\n\t} else {\n\t\t \n\t\tudf_fiiter_update_elen(iter, iter->elen -\n\t\t\t\t\t(dinfo->i_lenExtents - dir->i_size));\n\t}\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}\n\nstatic void udf_fiiter_delete_entry(struct udf_fileident_iter *iter)\n{\n\titer->fi.fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(iter->dir->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&iter->fi.icb, 0x00, sizeof(struct long_ad));\n\n\tudf_fiiter_write_fi(iter, NULL);\n}\n\nstatic void udf_add_fid_counter(struct super_block *sb, bool dir, int val)\n{\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tif (!lvidiu)\n\t\treturn;\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tif (dir)\n\t\tle32_add_cpu(&lvidiu->numDirs, val);\n\telse\n\t\tle32_add_cpu(&lvidiu->numFiles, val);\n\tudf_updated_lvid(sb);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n}\n\nstatic int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct udf_fileident_iter iter;\n\tint err;\n\n\terr = udf_fiiter_add_entry(dir, dentry, &iter);\n\tif (err) {\n\t\tinode_dec_link_count(inode);\n\t\tdiscard_new_inode(inode);\n\t\treturn err;\n\t}\n\titer.fi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\titer.fi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)iter.fi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_fiiter_write_fi(&iter, NULL);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tudf_fiiter_release(&iter);\n\tudf_add_fid_counter(dir->i_sb, false, 1);\n\td_instantiate_new(dentry, inode);\n\n\treturn 0;\n}\n\nstatic int udf_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\n\treturn udf_add_nondir(dentry, inode);\n}\n\nstatic int udf_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct file *file, umode_t mode)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\td_tmpfile(file, inode);\n\tunlock_new_inode(inode);\n\treturn finish_open_simple(file, 0);\n}\n\nstatic int udf_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = udf_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, mode, rdev);\n\treturn udf_add_nondir(dentry, inode);\n}\n\nstatic int udf_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct udf_fileident_iter iter;\n\tint err;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct udf_inode_info *iinfo;\n\n\tinode = udf_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tinode->i_op = &udf_dir_inode_operations;\n\tinode->i_fop = &udf_dir_operations;\n\terr = udf_fiiter_add_entry(inode, NULL, &iter);\n\tif (err) {\n\t\tclear_nlink(inode);\n\t\tdiscard_new_inode(inode);\n\t\treturn err;\n\t}\n\tset_nlink(inode, 2);\n\titer.fi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\titer.fi.icb.extLocation = cpu_to_lelb(dinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)iter.fi.icb.impUse)->impUse =\n\t\tcpu_to_le32(dinfo->i_unique & 0x00000000FFFFFFFFUL);\n\titer.fi.fileCharacteristics =\n\t\t\tFID_FILE_CHAR_DIRECTORY | FID_FILE_CHAR_PARENT;\n\tudf_fiiter_write_fi(&iter, NULL);\n\tudf_fiiter_release(&iter);\n\tmark_inode_dirty(inode);\n\n\terr = udf_fiiter_add_entry(dir, dentry, &iter);\n\tif (err) {\n\t\tclear_nlink(inode);\n\t\tdiscard_new_inode(inode);\n\t\treturn err;\n\t}\n\titer.fi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\titer.fi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)iter.fi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\titer.fi.fileCharacteristics |= FID_FILE_CHAR_DIRECTORY;\n\tudf_fiiter_write_fi(&iter, NULL);\n\tudf_fiiter_release(&iter);\n\tudf_add_fid_counter(dir->i_sb, true, 1);\n\tinc_nlink(dir);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\td_instantiate_new(dentry, inode);\n\n\treturn 0;\n}\n\nstatic int empty_dir(struct inode *dir)\n{\n\tstruct udf_fileident_iter iter;\n\tint ret;\n\n\tfor (ret = udf_fiiter_init(&iter, dir, 0);\n\t     !ret && iter.pos < dir->i_size;\n\t     ret = udf_fiiter_advance(&iter)) {\n\t\tif (iter.fi.lengthFileIdent &&\n\t\t    !(iter.fi.fileCharacteristics & FID_FILE_CHAR_DELETED)) {\n\t\t\tudf_fiiter_release(&iter);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tudf_fiiter_release(&iter);\n\n\treturn 1;\n}\n\nstatic int udf_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint ret;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct udf_fileident_iter iter;\n\tstruct kernel_lb_addr tloc;\n\n\tret = udf_fiiter_find_entry(dir, &dentry->d_name, &iter);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFSCORRUPTED;\n\ttloc = lelb_to_cpu(iter.fi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_rmdir;\n\tret = -ENOTEMPTY;\n\tif (!empty_dir(inode))\n\t\tgoto end_rmdir;\n\tudf_fiiter_delete_entry(&iter);\n\tif (inode->i_nlink != 2)\n\t\tudf_warn(inode->i_sb, \"empty directory has nlink != 2 (%u)\\n\",\n\t\t\t inode->i_nlink);\n\tclear_nlink(inode);\n\tinode->i_size = 0;\n\tinode_dec_link_count(dir);\n\tudf_add_fid_counter(dir->i_sb, true, -1);\n\tdir->i_mtime = inode_set_ctime_to_ts(dir,\n\t\t\t\t\t     inode_set_ctime_current(inode));\n\tmark_inode_dirty(dir);\n\tret = 0;\nend_rmdir:\n\tudf_fiiter_release(&iter);\nout:\n\treturn ret;\n}\n\nstatic int udf_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint ret;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct udf_fileident_iter iter;\n\tstruct kernel_lb_addr tloc;\n\n\tret = udf_fiiter_find_entry(dir, &dentry->d_name, &iter);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFSCORRUPTED;\n\ttloc = lelb_to_cpu(iter.fi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\tif (!inode->i_nlink) {\n\t\tudf_debug(\"Deleting nonexistent file (%lu), %u\\n\",\n\t\t\t  inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tudf_fiiter_delete_entry(&iter);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tinode_dec_link_count(inode);\n\tudf_add_fid_counter(dir->i_sb, false, -1);\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\tret = 0;\nend_unlink:\n\tudf_fiiter_release(&iter);\nout:\n\treturn ret;\n}\n\nstatic int udf_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, const char *symname)\n{\n\tstruct inode *inode = udf_new_inode(dir, S_IFLNK | 0777);\n\tstruct pathComponent *pc;\n\tconst char *compstart;\n\tstruct extent_position epos = {};\n\tint eoffset, elen = 0;\n\tuint8_t *ea;\n\tint err;\n\tudf_pblk_t block;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tstruct udf_inode_info *iinfo;\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tdown_write(&iinfo->i_data_sem);\n\tname = kmalloc(UDF_NAME_LEN_CS0, GFP_NOFS);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_no_entry;\n\t}\n\n\tinode->i_data.a_ops = &udf_symlink_aops;\n\tinode->i_op = &udf_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tstruct kernel_lb_addr eloc;\n\t\tuint32_t bsize;\n\n\t\tblock = udf_new_block(sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tiinfo->i_location.logicalBlockNum, &err);\n\t\tif (!block)\n\t\t\tgoto out_no_entry;\n\t\tepos.block = iinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(inode);\n\t\tepos.bh = NULL;\n\t\teloc.logicalBlockNum = block;\n\t\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\tbsize = sb->s_blocksize;\n\t\tiinfo->i_lenExtents = bsize;\n\t\terr = udf_add_aext(inode, &epos, &eloc, bsize, 0);\n\t\tbrelse(epos.bh);\n\t\tif (err < 0) {\n\t\t\tudf_free_blocks(sb, inode, &eloc, 0, 1);\n\t\t\tgoto out_no_entry;\n\t\t}\n\n\t\tblock = udf_get_pblock(sb, block,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\t\tepos.bh = sb_getblk(sb, block);\n\t\tif (unlikely(!epos.bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tudf_free_blocks(sb, inode, &eloc, 0, 1);\n\t\t\tgoto out_no_entry;\n\t\t}\n\t\tlock_buffer(epos.bh);\n\t\tmemset(epos.bh->b_data, 0x00, bsize);\n\t\tset_buffer_uptodate(epos.bh);\n\t\tunlock_buffer(epos.bh);\n\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\tea = epos.bh->b_data + udf_ext0_offset(inode);\n\t} else\n\t\tea = iinfo->i_data + iinfo->i_lenEAttr;\n\n\teoffset = sb->s_blocksize - udf_ext0_offset(inode);\n\tpc = (struct pathComponent *)ea;\n\n\tif (*symname == '/') {\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname == '/');\n\n\t\tpc->componentType = 1;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\telen += sizeof(struct pathComponent);\n\t}\n\n\terr = -ENAMETOOLONG;\n\n\twhile (*symname) {\n\t\tif (elen + sizeof(struct pathComponent) > eoffset)\n\t\t\tgoto out_no_entry;\n\n\t\tpc = (struct pathComponent *)(ea + elen);\n\n\t\tcompstart = symname;\n\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname && *symname != '/');\n\n\t\tpc->componentType = 5;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\tif (compstart[0] == '.') {\n\t\t\tif ((symname - compstart) == 1)\n\t\t\t\tpc->componentType = 4;\n\t\t\telse if ((symname - compstart) == 2 &&\n\t\t\t\t\tcompstart[1] == '.')\n\t\t\t\tpc->componentType = 3;\n\t\t}\n\n\t\tif (pc->componentType == 5) {\n\t\t\tnamelen = udf_put_filename(sb, compstart,\n\t\t\t\t\t\t   symname - compstart,\n\t\t\t\t\t\t   name, UDF_NAME_LEN_CS0);\n\t\t\tif (!namelen)\n\t\t\t\tgoto out_no_entry;\n\n\t\t\tif (elen + sizeof(struct pathComponent) + namelen >\n\t\t\t\t\teoffset)\n\t\t\t\tgoto out_no_entry;\n\t\t\telse\n\t\t\t\tpc->lengthComponentIdent = namelen;\n\n\t\t\tmemcpy(pc->componentIdent, name, namelen);\n\t\t}\n\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\n\t\tif (*symname) {\n\t\t\tdo {\n\t\t\t\tsymname++;\n\t\t\t} while (*symname == '/');\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tinode->i_size = elen;\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\telse\n\t\tudf_truncate_tail_extent(inode);\n\tmark_inode_dirty(inode);\n\tup_write(&iinfo->i_data_sem);\n\n\terr = udf_add_nondir(dentry, inode);\nout:\n\tkfree(name);\n\treturn err;\n\nout_no_entry:\n\tup_write(&iinfo->i_data_sem);\n\tinode_dec_link_count(inode);\n\tdiscard_new_inode(inode);\n\tgoto out;\n}\n\nstatic int udf_link(struct dentry *old_dentry, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct udf_fileident_iter iter;\n\tint err;\n\n\terr = udf_fiiter_add_entry(dir, dentry, &iter);\n\tif (err)\n\t\treturn err;\n\titer.fi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\titer.fi.icb.extLocation = cpu_to_lelb(UDF_I(inode)->i_location);\n\tif (UDF_SB(inode->i_sb)->s_lvid_bh) {\n\t\t*(__le32 *)((struct allocDescImpUse *)iter.fi.icb.impUse)->impUse =\n\t\t\tcpu_to_le32(lvid_get_unique_id(inode->i_sb));\n\t}\n\tudf_fiiter_write_fi(&iter, NULL);\n\tudf_fiiter_release(&iter);\n\n\tinc_nlink(inode);\n\tudf_add_fid_counter(dir->i_sb, false, 1);\n\tinode_set_ctime_current(inode);\n\tmark_inode_dirty(inode);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}\n\n \nstatic int udf_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct udf_fileident_iter oiter, niter, diriter;\n\tbool has_diriter = false;\n\tint retval;\n\tstruct kernel_lb_addr tloc;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tretval = udf_fiiter_find_entry(old_dir, &old_dentry->d_name, &oiter);\n\tif (retval)\n\t\treturn retval;\n\n\ttloc = lelb_to_cpu(oiter.fi.icb.extLocation);\n\tif (udf_get_lb_pblock(old_dir->i_sb, &tloc, 0) != old_inode->i_ino) {\n\t\tretval = -ENOENT;\n\t\tgoto out_oiter;\n\t}\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tif (new_inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir(new_inode))\n\t\t\t\tgoto out_oiter;\n\t\t}\n\t\tretval = udf_fiiter_find_entry(old_inode, &dotdot_name,\n\t\t\t\t\t       &diriter);\n\t\tif (retval == -ENOENT) {\n\t\t\tudf_err(old_inode->i_sb,\n\t\t\t\t\"directory (ino %lu) has no '..' entry\\n\",\n\t\t\t\told_inode->i_ino);\n\t\t\tretval = -EFSCORRUPTED;\n\t\t}\n\t\tif (retval)\n\t\t\tgoto out_oiter;\n\t\thas_diriter = true;\n\t\ttloc = lelb_to_cpu(diriter.fi.icb.extLocation);\n\t\tif (udf_get_lb_pblock(old_inode->i_sb, &tloc, 0) !=\n\t\t\t\told_dir->i_ino) {\n\t\t\tretval = -EFSCORRUPTED;\n\t\t\tudf_err(old_inode->i_sb,\n\t\t\t\t\"directory (ino %lu) has parent entry pointing to another inode (%lu != %u)\\n\",\n\t\t\t\told_inode->i_ino, old_dir->i_ino,\n\t\t\t\tudf_get_lb_pblock(old_inode->i_sb, &tloc, 0));\n\t\t\tgoto out_oiter;\n\t\t}\n\t}\n\n\tretval = udf_fiiter_find_entry(new_dir, &new_dentry->d_name, &niter);\n\tif (retval && retval != -ENOENT)\n\t\tgoto out_oiter;\n\t \n\tif (!retval && !new_inode) {\n\t\tretval = -EFSCORRUPTED;\n\t\tudf_fiiter_release(&niter);\n\t\tgoto out_oiter;\n\t}\n\t \n\tif (retval) {\n\t\tudf_fiiter_release(&niter);\n\t\tretval = udf_fiiter_add_entry(new_dir, new_dentry, &niter);\n\t\tif (retval)\n\t\t\tgoto out_oiter;\n\t}\n\n\t \n\tinode_set_ctime_current(old_inode);\n\tmark_inode_dirty(old_inode);\n\n\t \n\tniter.fi.fileVersionNum = oiter.fi.fileVersionNum;\n\tniter.fi.fileCharacteristics = oiter.fi.fileCharacteristics;\n\tmemcpy(&(niter.fi.icb), &(oiter.fi.icb), sizeof(oiter.fi.icb));\n\tudf_fiiter_write_fi(&niter, NULL);\n\tudf_fiiter_release(&niter);\n\n\t \n\tudf_fiiter_release(&oiter);\n\tretval = udf_fiiter_find_entry(old_dir, &old_dentry->d_name, &oiter);\n\tif (retval) {\n\t\tudf_err(old_dir->i_sb,\n\t\t\t\"failed to find renamed entry again in directory (ino %lu)\\n\",\n\t\t\told_dir->i_ino);\n\t} else {\n\t\tudf_fiiter_delete_entry(&oiter);\n\t\tudf_fiiter_release(&oiter);\n\t}\n\n\tif (new_inode) {\n\t\tinode_set_ctime_current(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t\tudf_add_fid_counter(old_dir->i_sb, S_ISDIR(new_inode->i_mode),\n\t\t\t\t    -1);\n\t}\n\told_dir->i_mtime = inode_set_ctime_current(old_dir);\n\tnew_dir->i_mtime = inode_set_ctime_current(new_dir);\n\tmark_inode_dirty(old_dir);\n\tmark_inode_dirty(new_dir);\n\n\tif (has_diriter) {\n\t\tdiriter.fi.icb.extLocation =\n\t\t\t\t\tcpu_to_lelb(UDF_I(new_dir)->i_location);\n\t\tudf_update_tag((char *)&diriter.fi,\n\t\t\t       udf_dir_entry_len(&diriter.fi));\n\t\tudf_fiiter_write_fi(&diriter, NULL);\n\t\tudf_fiiter_release(&diriter);\n\n\t\tinode_dec_link_count(old_dir);\n\t\tif (new_inode)\n\t\t\tinode_dec_link_count(new_inode);\n\t\telse {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\treturn 0;\nout_oiter:\n\tif (has_diriter)\n\t\tudf_fiiter_release(&diriter);\n\tudf_fiiter_release(&oiter);\n\n\treturn retval;\n}\n\nstatic struct dentry *udf_get_parent(struct dentry *child)\n{\n\tstruct kernel_lb_addr tloc;\n\tstruct inode *inode = NULL;\n\tstruct udf_fileident_iter iter;\n\tint err;\n\n\terr = udf_fiiter_find_entry(d_inode(child), &dotdot_name, &iter);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\ttloc = lelb_to_cpu(iter.fi.icb.extLocation);\n\tudf_fiiter_release(&iter);\n\tinode = udf_iget(child->d_sb, &tloc);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn d_obtain_alias(inode);\n}\n\n\nstatic struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *udf_fh_to_dentry(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len < 3 ||\n\t    (fh_type != FILEID_UDF_WITH_PARENT &&\n\t     fh_type != FILEID_UDF_WITHOUT_PARENT))\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.block, fid->udf.partref,\n\t\t\tfid->udf.generation);\n}\n\nstatic struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len < 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}\nstatic int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}\n\nconst struct export_operations udf_export_ops = {\n\t.encode_fh\t= udf_encode_fh,\n\t.fh_to_dentry   = udf_fh_to_dentry,\n\t.fh_to_parent   = udf_fh_to_parent,\n\t.get_parent     = udf_get_parent,\n};\n\nconst struct inode_operations udf_dir_inode_operations = {\n\t.lookup\t\t\t\t= udf_lookup,\n\t.create\t\t\t\t= udf_create,\n\t.link\t\t\t\t= udf_link,\n\t.unlink\t\t\t\t= udf_unlink,\n\t.symlink\t\t\t= udf_symlink,\n\t.mkdir\t\t\t\t= udf_mkdir,\n\t.rmdir\t\t\t\t= udf_rmdir,\n\t.mknod\t\t\t\t= udf_mknod,\n\t.rename\t\t\t\t= udf_rename,\n\t.tmpfile\t\t\t= udf_tmpfile,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}