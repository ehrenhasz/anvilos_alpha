{
  "module_name": "udftime.c",
  "hash_id": "e9ebde0944d50c92674d806bdd796173d97fdac7a13ddd142dbfdfb3ec549c3f",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/udftime.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"udfdecl.h\"\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid\nudf_disk_stamp_to_time(struct timespec64 *dest, struct timestamp src)\n{\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t \n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047)  \n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tdest->tv_sec = mktime64(year, src.month, src.day, src.hour, src.minute,\n\t\t\tsrc.second);\n\tdest->tv_sec -= offset * 60;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\t \n\tdest->tv_nsec %= NSEC_PER_SEC;\n}\n\nvoid\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec64 ts)\n{\n\ttime64_t seconds;\n\tint16_t offset;\n\tstruct tm tm;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tseconds = ts.tv_sec + offset * 60;\n\ttime64_to_tm(seconds, 0, &tm);\n\tdest->year = cpu_to_le16(tm.tm_year + 1900);\n\tdest->month = tm.tm_mon + 1;\n\tdest->day = tm.tm_mday;\n\tdest->hour = tm.tm_hour;\n\tdest->minute = tm.tm_min;\n\tdest->second = tm.tm_sec;\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}