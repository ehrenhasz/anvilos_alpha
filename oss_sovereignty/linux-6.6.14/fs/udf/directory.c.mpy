{
  "module_name": "directory.c",
  "hash_id": "0499442bf13d09c73f29482a902cae9a8ffc22d23f5287c46c36193e32af4656",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/directory.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include \"udf_i.h\"\n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/bio.h>\n#include <linux/crc-itu-t.h>\n#include <linux/iversion.h>\n\nstatic int udf_verify_fi(struct udf_fileident_iter *iter)\n{\n\tunsigned int len;\n\n\tif (iter->fi.descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has entry at pos %llu with incorrect tag %x\\n\",\n\t\t\titer->dir->i_ino, (unsigned long long)iter->pos,\n\t\t\tle16_to_cpu(iter->fi.descTag.tagIdent));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tlen = udf_dir_entry_len(&iter->fi);\n\tif (le16_to_cpu(iter->fi.lengthOfImpUse) & 3) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has entry at pos %llu with unaligned length of impUse field\\n\",\n\t\t\titer->dir->i_ino, (unsigned long long)iter->pos);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t \n\tif (len > 1 << iter->dir->i_blkbits) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has too big (%u) entry at pos %llu\\n\",\n\t\t\titer->dir->i_ino, len, (unsigned long long)iter->pos);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (iter->pos + len > iter->dir->i_size) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has entry past directory size at pos %llu\\n\",\n\t\t\titer->dir->i_ino, (unsigned long long)iter->pos);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (udf_dir_entry_len(&iter->fi) !=\n\t    sizeof(struct tag) + le16_to_cpu(iter->fi.descTag.descCRCLength)) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has entry where CRC length (%u) does not match entry length (%u)\\n\",\n\t\t\titer->dir->i_ino,\n\t\t\t(unsigned)le16_to_cpu(iter->fi.descTag.descCRCLength),\n\t\t\t(unsigned)(udf_dir_entry_len(&iter->fi) -\n\t\t\t\t\t\t\tsizeof(struct tag)));\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nstatic int udf_copy_fi(struct udf_fileident_iter *iter)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(iter->dir);\n\tu32 blksize = 1 << iter->dir->i_blkbits;\n\tu32 off, len, nameoff;\n\tint err;\n\n\t \n\tif (iter->pos >= iter->dir->i_size) {\n\t\titer->name = NULL;\n\t\treturn 0;\n\t}\n\tif (iter->dir->i_size < iter->pos + sizeof(struct fileIdentDesc)) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"directory (ino %lu) has entry straddling EOF\\n\",\n\t\t\titer->dir->i_ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tmemcpy(&iter->fi, iinfo->i_data + iinfo->i_lenEAttr + iter->pos,\n\t\t       sizeof(struct fileIdentDesc));\n\t\terr = udf_verify_fi(iter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\titer->name = iinfo->i_data + iinfo->i_lenEAttr + iter->pos +\n\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\tle16_to_cpu(iter->fi.lengthOfImpUse);\n\t\treturn 0;\n\t}\n\n\toff = iter->pos & (blksize - 1);\n\tlen = min_t(u32, sizeof(struct fileIdentDesc), blksize - off);\n\tmemcpy(&iter->fi, iter->bh[0]->b_data + off, len);\n\tif (len < sizeof(struct fileIdentDesc))\n\t\tmemcpy((char *)(&iter->fi) + len, iter->bh[1]->b_data,\n\t\t       sizeof(struct fileIdentDesc) - len);\n\terr = udf_verify_fi(iter);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tnameoff = off + sizeof(struct fileIdentDesc) +\n\t\t\t\tle16_to_cpu(iter->fi.lengthOfImpUse);\n\tif (off + udf_dir_entry_len(&iter->fi) <= blksize) {\n\t\titer->name = iter->bh[0]->b_data + nameoff;\n\t} else if (nameoff >= blksize) {\n\t\titer->name = iter->bh[1]->b_data + (nameoff - blksize);\n\t} else {\n\t\titer->name = iter->namebuf;\n\t\tlen = blksize - nameoff;\n\t\tmemcpy(iter->name, iter->bh[0]->b_data + nameoff, len);\n\t\tmemcpy(iter->name + len, iter->bh[1]->b_data,\n\t\t       iter->fi.lengthFileIdent - len);\n\t}\n\treturn 0;\n}\n\n \nstatic void udf_readahead_dir(struct udf_fileident_iter *iter)\n{\n\tunsigned int ralen = 16 >> (iter->dir->i_blkbits - 9);\n\tstruct buffer_head *tmp, *bha[16];\n\tint i, num;\n\tudf_pblk_t blk;\n\n\tif (iter->loffset & (ralen - 1))\n\t\treturn;\n\n\tif (iter->loffset + ralen > (iter->elen >> iter->dir->i_blkbits))\n\t\tralen = (iter->elen >> iter->dir->i_blkbits) - iter->loffset;\n\tnum = 0;\n\tfor (i = 0; i < ralen; i++) {\n\t\tblk = udf_get_lb_pblock(iter->dir->i_sb, &iter->eloc,\n\t\t\t\t\titer->loffset + i);\n\t\ttmp = sb_getblk(iter->dir->i_sb, blk);\n\t\tif (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))\n\t\t\tbha[num++] = tmp;\n\t\telse\n\t\t\tbrelse(tmp);\n\t}\n\tif (num) {\n\t\tbh_readahead_batch(num, bha, REQ_RAHEAD);\n\t\tfor (i = 0; i < num; i++)\n\t\t\tbrelse(bha[i]);\n\t}\n}\n\nstatic struct buffer_head *udf_fiiter_bread_blk(struct udf_fileident_iter *iter)\n{\n\tudf_pblk_t blk;\n\n\tudf_readahead_dir(iter);\n\tblk = udf_get_lb_pblock(iter->dir->i_sb, &iter->eloc, iter->loffset);\n\treturn sb_bread(iter->dir->i_sb, blk);\n}\n\n \nstatic int udf_fiiter_advance_blk(struct udf_fileident_iter *iter)\n{\n\titer->loffset++;\n\tif (iter->loffset < DIV_ROUND_UP(iter->elen, 1<<iter->dir->i_blkbits))\n\t\treturn 0;\n\n\titer->loffset = 0;\n\tif (udf_next_aext(iter->dir, &iter->epos, &iter->eloc, &iter->elen, 1)\n\t\t\t!= (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (iter->pos == iter->dir->i_size) {\n\t\t\titer->elen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"extent after position %llu not allocated in directory (ino %lu)\\n\",\n\t\t\t(unsigned long long)iter->pos, iter->dir->i_ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nstatic int udf_fiiter_load_bhs(struct udf_fileident_iter *iter)\n{\n\tint blksize = 1 << iter->dir->i_blkbits;\n\tint off = iter->pos & (blksize - 1);\n\tint err;\n\tstruct fileIdentDesc *fi;\n\n\t \n\tif (!iter->bh[0] && iter->elen) {\n\t\titer->bh[0] = udf_fiiter_bread_blk(iter);\n\t\tif (!iter->bh[0]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tif (!buffer_uptodate(iter->bh[0])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\t \n\tif (iter->pos >= iter->dir->i_size)\n\t\treturn 0;\n\t \n\tif (off + sizeof(struct fileIdentDesc) > blksize)\n\t\tgoto fetch_next;\n\tfi = (struct fileIdentDesc *)(iter->bh[0]->b_data + off);\n\t \n\tif (off + udf_dir_entry_len(fi) > blksize) {\nfetch_next:\n\t\terr = udf_fiiter_advance_blk(iter);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\titer->bh[1] = udf_fiiter_bread_blk(iter);\n\t\tif (!iter->bh[1]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tif (!buffer_uptodate(iter->bh[1])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\treturn 0;\nout_brelse:\n\tbrelse(iter->bh[0]);\n\tbrelse(iter->bh[1]);\n\titer->bh[0] = iter->bh[1] = NULL;\n\treturn err;\n}\n\nint udf_fiiter_init(struct udf_fileident_iter *iter, struct inode *dir,\n\t\t    loff_t pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\tint err = 0;\n\n\titer->dir = dir;\n\titer->bh[0] = iter->bh[1] = NULL;\n\titer->pos = pos;\n\titer->elen = 0;\n\titer->epos.bh = NULL;\n\titer->name = NULL;\n\t \n\titer->namebuf = kmalloc(UDF_NAME_LEN_CS0, GFP_KERNEL | __GFP_NOFAIL);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\terr = udf_copy_fi(iter);\n\t\tgoto out;\n\t}\n\n\tif (inode_bmap(dir, iter->pos >> dir->i_blkbits, &iter->epos,\n\t\t       &iter->eloc, &iter->elen, &iter->loffset) !=\n\t    (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (pos == dir->i_size)\n\t\t\treturn 0;\n\t\tudf_err(dir->i_sb,\n\t\t\t\"position %llu not allocated in directory (ino %lu)\\n\",\n\t\t\t(unsigned long long)pos, dir->i_ino);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\terr = udf_fiiter_load_bhs(iter);\n\tif (err < 0)\n\t\tgoto out;\n\terr = udf_copy_fi(iter);\nout:\n\tif (err < 0)\n\t\tudf_fiiter_release(iter);\n\treturn err;\n}\n\nint udf_fiiter_advance(struct udf_fileident_iter *iter)\n{\n\tunsigned int oldoff, len;\n\tint blksize = 1 << iter->dir->i_blkbits;\n\tint err;\n\n\toldoff = iter->pos & (blksize - 1);\n\tlen = udf_dir_entry_len(&iter->fi);\n\titer->pos += len;\n\tif (UDF_I(iter->dir)->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (oldoff + len >= blksize) {\n\t\t\tbrelse(iter->bh[0]);\n\t\t\titer->bh[0] = NULL;\n\t\t\t \n\t\t\tif (iter->bh[1]) {\n\t\t\t\titer->bh[0] = iter->bh[1];\n\t\t\t\titer->bh[1] = NULL;\n\t\t\t} else {\n\t\t\t\terr = udf_fiiter_advance_blk(iter);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\terr = udf_fiiter_load_bhs(iter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn udf_copy_fi(iter);\n}\n\nvoid udf_fiiter_release(struct udf_fileident_iter *iter)\n{\n\titer->dir = NULL;\n\tbrelse(iter->bh[0]);\n\tbrelse(iter->bh[1]);\n\titer->bh[0] = iter->bh[1] = NULL;\n\tkfree(iter->namebuf);\n\titer->namebuf = NULL;\n}\n\nstatic void udf_copy_to_bufs(void *buf1, int len1, void *buf2, int len2,\n\t\t\t     int off, void *src, int len)\n{\n\tint copy;\n\n\tif (off >= len1) {\n\t\toff -= len1;\n\t} else {\n\t\tcopy = min(off + len, len1) - off;\n\t\tmemcpy(buf1 + off, src, copy);\n\t\tsrc += copy;\n\t\tlen -= copy;\n\t\toff = 0;\n\t}\n\tif (len > 0) {\n\t\tif (WARN_ON_ONCE(off + len > len2 || !buf2))\n\t\t\treturn;\n\t\tmemcpy(buf2 + off, src, len);\n\t}\n}\n\nstatic uint16_t udf_crc_fi_bufs(void *buf1, int len1, void *buf2, int len2,\n\t\t\t\tint off, int len)\n{\n\tint copy;\n\tuint16_t crc = 0;\n\n\tif (off >= len1) {\n\t\toff -= len1;\n\t} else {\n\t\tcopy = min(off + len, len1) - off;\n\t\tcrc = crc_itu_t(crc, buf1 + off, copy);\n\t\tlen -= copy;\n\t\toff = 0;\n\t}\n\tif (len > 0) {\n\t\tif (WARN_ON_ONCE(off + len > len2 || !buf2))\n\t\t\treturn 0;\n\t\tcrc = crc_itu_t(crc, buf2 + off, len);\n\t}\n\treturn crc;\n}\n\nstatic void udf_copy_fi_to_bufs(char *buf1, int len1, char *buf2, int len2,\n\t\t\t\tint off, struct fileIdentDesc *fi,\n\t\t\t\tuint8_t *impuse, uint8_t *name)\n{\n\tuint16_t crc;\n\tint fioff = off;\n\tint crcoff = off + sizeof(struct tag);\n\tunsigned int crclen = udf_dir_entry_len(fi) - sizeof(struct tag);\n\tchar zeros[UDF_NAME_PAD] = {};\n\tint endoff = off + udf_dir_entry_len(fi);\n\n\tudf_copy_to_bufs(buf1, len1, buf2, len2, off, fi,\n\t\t\t sizeof(struct fileIdentDesc));\n\toff += sizeof(struct fileIdentDesc);\n\tif (impuse)\n\t\tudf_copy_to_bufs(buf1, len1, buf2, len2, off, impuse,\n\t\t\t\t le16_to_cpu(fi->lengthOfImpUse));\n\toff += le16_to_cpu(fi->lengthOfImpUse);\n\tif (name) {\n\t\tudf_copy_to_bufs(buf1, len1, buf2, len2, off, name,\n\t\t\t\t fi->lengthFileIdent);\n\t\toff += fi->lengthFileIdent;\n\t\tudf_copy_to_bufs(buf1, len1, buf2, len2, off, zeros,\n\t\t\t\t endoff - off);\n\t}\n\n\tcrc = udf_crc_fi_bufs(buf1, len1, buf2, len2, crcoff, crclen);\n\tfi->descTag.descCRC = cpu_to_le16(crc);\n\tfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfi->descTag.tagChecksum = udf_tag_checksum(&fi->descTag);\n\n\tudf_copy_to_bufs(buf1, len1, buf2, len2, fioff, fi, sizeof(struct tag));\n}\n\nvoid udf_fiiter_write_fi(struct udf_fileident_iter *iter, uint8_t *impuse)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(iter->dir);\n\tvoid *buf1, *buf2 = NULL;\n\tint len1, len2 = 0, off;\n\tint blksize = 1 << iter->dir->i_blkbits;\n\n\toff = iter->pos & (blksize - 1);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tbuf1 = iinfo->i_data + iinfo->i_lenEAttr;\n\t\tlen1 = iter->dir->i_size;\n\t} else {\n\t\tbuf1 = iter->bh[0]->b_data;\n\t\tlen1 = blksize;\n\t\tif (iter->bh[1]) {\n\t\t\tbuf2 = iter->bh[1]->b_data;\n\t\t\tlen2 = blksize;\n\t\t}\n\t}\n\n\tudf_copy_fi_to_bufs(buf1, len1, buf2, len2, off, &iter->fi, impuse,\n\t\t\t    iter->name == iter->namebuf ? iter->name : NULL);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tmark_inode_dirty(iter->dir);\n\t} else {\n\t\tmark_buffer_dirty_inode(iter->bh[0], iter->dir);\n\t\tif (iter->bh[1])\n\t\t\tmark_buffer_dirty_inode(iter->bh[1], iter->dir);\n\t}\n\tinode_inc_iversion(iter->dir);\n}\n\nvoid udf_fiiter_update_elen(struct udf_fileident_iter *iter, uint32_t new_elen)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(iter->dir);\n\tint diff = new_elen - iter->elen;\n\n\t \n\tif (!iter->elen)\n\t\treturn;\n\titer->elen = new_elen;\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\titer->epos.offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\titer->epos.offset -= sizeof(struct long_ad);\n\tudf_write_aext(iter->dir, &iter->epos, &iter->eloc, iter->elen, 1);\n\tiinfo->i_lenExtents += diff;\n\tmark_inode_dirty(iter->dir);\n}\n\n \nint udf_fiiter_append_blk(struct udf_fileident_iter *iter)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(iter->dir);\n\tint blksize = 1 << iter->dir->i_blkbits;\n\tstruct buffer_head *bh;\n\tsector_t block;\n\tuint32_t old_elen = iter->elen;\n\tint err;\n\n\tif (WARN_ON_ONCE(iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB))\n\t\treturn -EINVAL;\n\n\t \n\tudf_fiiter_update_elen(iter, ALIGN(iter->elen, blksize));\n\n\t \n\tblock = iinfo->i_lenExtents >> iter->dir->i_blkbits;\n\tbh = udf_bread(iter->dir, block, 1, &err);\n\tif (!bh) {\n\t\tudf_fiiter_update_elen(iter, old_elen);\n\t\treturn err;\n\t}\n\tif (inode_bmap(iter->dir, block, &iter->epos, &iter->eloc, &iter->elen,\n\t\t       &iter->loffset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tudf_err(iter->dir->i_sb,\n\t\t\t\"block %llu not allocated in directory (ino %lu)\\n\",\n\t\t\t(unsigned long long)block, iter->dir->i_ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (!(iter->pos & (blksize - 1))) {\n\t\tbrelse(iter->bh[0]);\n\t\titer->bh[0] = bh;\n\t} else {\n\t\titer->bh[1] = bh;\n\t}\n\treturn 0;\n}\n\nstruct short_ad *udf_get_fileshortad(uint8_t *ptr, int maxoffset, uint32_t *offset,\n\t\t\t      int inc)\n{\n\tstruct short_ad *sa;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct short_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tsa = (struct short_ad *)ptr;\n\t\tif (sa->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct short_ad);\n\treturn sa;\n}\n\nstruct long_ad *udf_get_filelongad(uint8_t *ptr, int maxoffset, uint32_t *offset, int inc)\n{\n\tstruct long_ad *la;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct long_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tla = (struct long_ad *)ptr;\n\t\tif (la->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct long_ad);\n\treturn la;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}