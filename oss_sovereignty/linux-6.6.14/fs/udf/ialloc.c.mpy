{
  "module_name": "ialloc.c",
  "hash_id": "7ae0701e6cc715b36e134c2b7322806bd3e8b4c6d117444e9e0f1b01b8db4af0",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/ialloc.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\nvoid udf_free_inode(struct inode *inode)\n{\n\tudf_free_blocks(inode->i_sb, NULL, &UDF_I(inode)->i_location, 0, 1);\n}\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tudf_pblk_t block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry),\n\t\t\t\t\tGFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct fileEntry),\n\t\t\t\t\tGFP_KERNEL);\n\t}\n\tif (!iinfo->i_data) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tiinfo->i_unique = lvid_get_unique_id(sb);\n\tinode->i_generation = iinfo->i_unique;\n\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = sbi->s_uid;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = sbi->s_gid;\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tiinfo->i_extraPerms = FE_PERM_U_CHATTR;\n\tudf_update_extra_perms(inode, mode);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tiinfo->i_crtime = inode->i_mtime;\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}