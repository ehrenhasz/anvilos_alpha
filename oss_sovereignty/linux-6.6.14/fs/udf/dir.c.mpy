{
  "module_name": "dir.c",
  "hash_id": "c42715412b9beb8de2d1c1712c4d147ad98787e357c7305a582a663f169271d2",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/dir.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/iversion.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\nstatic int udf_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tloff_t nf_pos, emit_pos = 0;\n\tint flen;\n\tunsigned char *fname = NULL;\n\tint ret = 0;\n\tstruct super_block *sb = dir->i_sb;\n\tbool pos_valid = false;\n\tstruct udf_fileident_iter iter;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tnf_pos = (ctx->pos - 1) << 2;\n\tif (nf_pos >= dir->i_size)\n\t\tgoto out;\n\n\t \n\tif (!inode_eq_iversion(dir, file->f_version)) {\n\t\temit_pos = nf_pos;\n\t\tnf_pos = 0;\n\t} else {\n\t\tpos_valid = true;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (ret = udf_fiiter_init(&iter, dir, nf_pos);\n\t     !ret && iter.pos < dir->i_size;\n\t     ret = udf_fiiter_advance(&iter)) {\n\t\tstruct kernel_lb_addr tloc;\n\t\tudf_pblk_t iblock;\n\n\t\t \n\t\tif (iter.pos < emit_pos)\n\t\t\tcontinue;\n\n\t\t \n\t\tpos_valid = true;\n\t\tctx->pos = (iter.pos >> 2) + 1;\n\n\t\tif (iter.fi.fileCharacteristics & FID_FILE_CHAR_DELETED) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (iter.fi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (iter.fi.fileCharacteristics & FID_FILE_CHAR_PARENT) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tgoto out_iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflen = udf_get_filename(sb, iter.name,\n\t\t\t\titer.fi.lengthFileIdent, fname, UDF_NAME_LEN);\n\t\tif (flen < 0)\n\t\t\tcontinue;\n\n\t\ttloc = lelb_to_cpu(iter.fi.icb.extLocation);\n\t\tiblock = udf_get_lb_pblock(sb, &tloc, 0);\n\t\tif (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))\n\t\t\tgoto out_iter;\n\t}\n\n\tif (!ret) {\n\t\tctx->pos = (iter.pos >> 2) + 1;\n\t\tpos_valid = true;\n\t}\nout_iter:\n\tudf_fiiter_release(&iter);\nout:\n\tif (pos_valid)\n\t\tfile->f_version = inode_query_iversion(dir);\n\tkfree(fname);\n\n\treturn ret;\n}\n\n \nconst struct file_operations udf_dir_operations = {\n\t.llseek\t\t\t= generic_file_llseek,\n\t.read\t\t\t= generic_read_dir,\n\t.iterate_shared\t\t= udf_readdir,\n\t.unlocked_ioctl\t\t= udf_ioctl,\n\t.fsync\t\t\t= generic_file_fsync,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}