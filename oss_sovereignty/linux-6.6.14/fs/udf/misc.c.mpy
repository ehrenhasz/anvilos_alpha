{
  "module_name": "misc.c",
  "hash_id": "e35ef4d5cd2a4775a8a8e817b9eecf349fbdd65b826c0973eadb79da2d79e7fe",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/misc.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/crc-itu-t.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\nstruct genericFormat *udf_add_extendedattr(struct inode *inode, uint32_t size,\n\t\t\t\t\t   uint32_t type, uint8_t loc)\n{\n\tuint8_t *ea = NULL, *ad = NULL;\n\tint offset;\n\tuint16_t crclen;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_data;\n\tif (iinfo->i_lenEAttr) {\n\t\tad = iinfo->i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tad = ea;\n\t\tsize += sizeof(struct extendedAttrHeaderDesc);\n\t}\n\n\toffset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -\n\t\tiinfo->i_lenAlloc;\n\n\t \n\n\tif (loc & 0x01 && offset >= size) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\tif (iinfo->i_lenAlloc)\n\t\t\tmemmove(&ad[size], ad, iinfo->i_lenAlloc);\n\n\t\tif (iinfo->i_lenEAttr) {\n\t\t\t \n\t\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\n\t\t\tsize -= sizeof(struct extendedAttrHeaderDesc);\n\t\t\tiinfo->i_lenEAttr +=\n\t\t\t\tsizeof(struct extendedAttrHeaderDesc);\n\t\t\teahd->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EAHD);\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(3);\n\t\t\telse\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(2);\n\t\t\teahd->descTag.tagSerialNum =\n\t\t\t\t\tcpu_to_le16(sbi->s_serial_number);\n\t\t\teahd->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\t\t\teahd->impAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t\teahd->appAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t}\n\n\t\toffset = iinfo->i_lenEAttr;\n\t\tif (type < 2048) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t\tif (le32_to_cpu(eahd->impAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t ial =\n\t\t\t\t\tle32_to_cpu(eahd->impAttrLocation);\n\t\t\t\tmemmove(&ea[offset - ial + size],\n\t\t\t\t\t&ea[ial], offset - ial);\n\t\t\t\toffset -= ial;\n\t\t\t\teahd->impAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(ial + size);\n\t\t\t}\n\t\t} else if (type < 65536) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t}\n\t\t \n\t\tcrclen = sizeof(struct extendedAttrHeaderDesc) - sizeof(struct tag);\n\t\teahd->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\teahd->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen));\n\t\teahd->descTag.tagChecksum = udf_tag_checksum(&eahd->descTag);\n\t\tiinfo->i_lenEAttr += size;\n\t\treturn (struct genericFormat *)&ea[offset];\n\t}\n\n\treturn NULL;\n}\n\nstruct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t \n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset + sizeof(*gaf) < iinfo->i_lenEAttr) {\n\t\t\tuint32_t attrLength;\n\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tattrLength = le32_to_cpu(gaf->attrLength);\n\n\t\t\t \n\t\t\tif ((attrLength < sizeof(*gaf)) ||\n\t\t\t    (attrLength > (iinfo->i_lenEAttr - offset)))\n\t\t\t\tbreak;\n\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += attrLength;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t \n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%u\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t \n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t \n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t \n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %u: crc = %u, crclen = %u\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}\n\nstruct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}\n\nvoid udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4)  \n\t\t\tchecksum += data[i];\n\treturn checksum;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}