{
  "module_name": "truncate.c",
  "hash_id": "5c475c2fb86218680fa05628bf6c7609f0f29184464da123a733365ea8f09342",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/truncate.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include <linux/fs.h>\n#include <linux/mm.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\nstatic void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block > first_block) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}\n\n \nvoid udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t \n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t \n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}\n\nvoid udf_discard_prealloc(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct extent_position prev_epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint bsize = i_blocksize(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    ALIGN(inode->i_size, bsize) == ALIGN(iinfo->i_lenExtents, bsize))\n\t\treturn;\n\n\tepos.block = iinfo->i_location;\n\n\t \n\twhile (udf_next_aext(inode, &epos, &eloc, &elen, 0) != -1) {\n\t\tbrelse(prev_epos.bh);\n\t\tprev_epos = epos;\n\t\tif (prev_epos.bh)\n\t\t\tget_bh(prev_epos.bh);\n\n\t\tetype = udf_next_aext(inode, &epos, &eloc, &elen, 1);\n\t\tlbcount += elen;\n\t}\n\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\tlbcount -= elen;\n\t\tudf_delete_aext(inode, prev_epos);\n\t\tudf_free_blocks(inode->i_sb, inode, &eloc, 0,\n\t\t\t\tDIV_ROUND_UP(elen, bsize));\n\t}\n\t \n\tiinfo->i_lenExtents = lbcount;\n\tbrelse(epos.bh);\n\tbrelse(prev_epos.bh);\n}\n\nstatic void udf_update_alloc_ext_desc(struct inode *inode,\n\t\t\t\t      struct extent_position *epos,\n\t\t\t\t      u32 lenalloc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\n\tint len = sizeof(struct allocExtDesc);\n\n\taed->lengthAllocDescs =\tcpu_to_le32(lenalloc);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\n\t\tlen += lenalloc;\n\n\tudf_update_tag(epos->bh->b_data, len);\n\tmark_buffer_dirty_inode(epos->bh, inode);\n}\n\n \nint udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t \n\t\tWARN_ON(byte_offset);\n\t\treturn 0;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDESCS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t \n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = sb_bread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\t \n\t\t\tif (!epos.bh)\n\t\t\t\treturn -EIO;\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}