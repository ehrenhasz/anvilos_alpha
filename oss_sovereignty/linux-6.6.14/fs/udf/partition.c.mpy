{
  "module_name": "partition.c",
  "hash_id": "0002f4e49172555d796d1758745bc5772bf48600078ba9ec0270c2bdb3bad91c",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/partition.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n\nuint32_t udf_get_pblock(struct super_block *sb, uint32_t block,\n\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tif (partition >= sbi->s_partitions) {\n\t\tudf_debug(\"block=%u, partition=%u, offset=%u: invalid partition\\n\",\n\t\t\t  block, partition, offset);\n\t\treturn 0xFFFFFFFF;\n\t}\n\tmap = &sbi->s_partmaps[partition];\n\tif (map->s_partition_func)\n\t\treturn map->s_partition_func(sb, block, partition, offset);\n\telse\n\t\treturn map->s_partition_root + block + offset;\n}\n\nuint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint32_t newblock;\n\tuint32_t index;\n\tuint32_t loc;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_virtual_data *vdata;\n\tstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\n\tint err;\n\n\tmap = &sbi->s_partmaps[partition];\n\tvdata = &map->s_type_specific.s_virtual;\n\n\tif (block > vdata->s_num_entries) {\n\t\tudf_debug(\"Trying to access block beyond end of VAT (%u max %u)\\n\",\n\t\t\t  block, vdata->s_num_entries);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tloc = le32_to_cpu(((__le32 *)(iinfo->i_data +\n\t\t\tvdata->s_start_offset))[block]);\n\t\tgoto translate;\n\t}\n\tindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\n\tif (block >= index) {\n\t\tblock -= index;\n\t\tnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\n\t\tindex = block % (sb->s_blocksize / sizeof(uint32_t));\n\t} else {\n\t\tnewblock = 0;\n\t\tindex = vdata->s_start_offset / sizeof(uint32_t) + block;\n\t}\n\n\tbh = udf_bread(sbi->s_vat_inode, newblock, 0, &err);\n\tif (!bh) {\n\t\tudf_debug(\"get_pblock(UDF_VIRTUAL_MAP:%p,%u,%u)\\n\",\n\t\t\t  sb, block, partition);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\n\n\tbrelse(bh);\n\ntranslate:\n\tif (iinfo->i_location.partitionReferenceNum == partition) {\n\t\tudf_debug(\"recursive call to udf_get_pblock!\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\treturn udf_get_pblock(sb, loc,\n\t\t\t      iinfo->i_location.partitionReferenceNum,\n\t\t\t      offset);\n}\n\ninline uint32_t udf_get_pblock_virt20(struct super_block *sb, uint32_t block,\n\t\t\t\t      uint16_t partition, uint32_t offset)\n{\n\treturn udf_get_pblock_virt15(sb, block, partition, offset);\n}\n\nuint32_t udf_get_pblock_spar15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tint i;\n\tstruct sparingTable *st = NULL;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tuint32_t packet;\n\tstruct udf_sparing_data *sdata;\n\n\tmap = &sbi->s_partmaps[partition];\n\tsdata = &map->s_type_specific.s_sparing;\n\tpacket = (block + offset) & ~(sdata->s_packet_len - 1);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sdata->s_spar_map[i] != NULL) {\n\t\t\tst = (struct sparingTable *)\n\t\t\t\t\tsdata->s_spar_map[i]->b_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (st) {\n\t\tfor (i = 0; i < le16_to_cpu(st->reallocationTableLen); i++) {\n\t\t\tstruct sparingEntry *entry = &st->mapEntry[i];\n\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\t\t\tif (origLoc >= 0xFFFFFFF0)\n\t\t\t\tbreak;\n\t\t\telse if (origLoc == packet)\n\t\t\t\treturn le32_to_cpu(entry->mappedLocation) +\n\t\t\t\t\t((block + offset) &\n\t\t\t\t\t\t(sdata->s_packet_len - 1));\n\t\t\telse if (origLoc > packet)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn map->s_partition_root + block + offset;\n}\n\nint udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\n{\n\tstruct udf_sparing_data *sdata;\n\tstruct sparingTable *st = NULL;\n\tstruct sparingEntry mapEntry;\n\tuint32_t packet;\n\tint i, j, k, l;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tu16 reallocationTableLen;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tif (old_block > map->s_partition_root &&\n\t\t    old_block < map->s_partition_root + map->s_partition_len) {\n\t\t\tsdata = &map->s_type_specific.s_sparing;\n\t\t\tpacket = (old_block - map->s_partition_root) &\n\t\t\t\t\t\t~(sdata->s_packet_len - 1);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (sdata->s_spar_map[j] != NULL) {\n\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\tsdata->s_spar_map[j]->b_data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (!st) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\treallocationTableLen =\n\t\t\t\t\tle16_to_cpu(st->reallocationTableLen);\n\t\t\tfor (k = 0; k < reallocationTableLen; k++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[k];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc == 0xFFFFFFFF) {\n\t\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\t\tint len;\n\t\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\t\tif (!bh)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\t\tentry->origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\t\tlen =\n\t\t\t\t\t\t  sizeof(struct sparingTable) +\n\t\t\t\t\t\t  reallocationTableLen *\n\t\t\t\t\t\t  sizeof(struct sparingEntry);\n\t\t\t\t\t\tudf_update_tag((char *)st, len);\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\t}\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc == packet) {\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc > packet)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (l = k; l < reallocationTableLen; l++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[l];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc != 0xFFFFFFFF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\tif (!bh)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh->b_data;\n\t\t\t\t\tmapEntry = st->mapEntry[l];\n\t\t\t\t\tmapEntry.origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\tmemmove(&st->mapEntry[k + 1],\n\t\t\t\t\t\t&st->mapEntry[k],\n\t\t\t\t\t\t(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tst->mapEntry[k] = mapEntry;\n\t\t\t\t\tudf_update_tag((char *)st,\n\t\t\t\t\t\tsizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t}\n\t\t\t\t*new_block =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\t      st->mapEntry[k].mappedLocation) +\n\t\t\t\t\t((old_block - map->s_partition_root) &\n\t\t\t\t\t (sdata->s_packet_len - 1));\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}  \n\t}\n\n\tif (i == sbi->s_partitions) {\n\t\t \n\t\t \n\t\tret = 1;\n\t}\n\nout:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn ret;\n}\n\nstatic uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\n\t\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_part_map *map;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t ext_offset;\n\tstruct extent_position epos = {};\n\tuint32_t phyblock;\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tphyblock = 0xFFFFFFFF;\n\telse {\n\t\tmap = &UDF_SB(sb)->s_partmaps[partition];\n\t\t \n\t\tphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\n\t\t\tmap->s_type_specific.s_metadata.s_phys_partition_ref,\n\t\t\text_offset + offset);\n\t}\n\n\tbrelse(epos.bh);\n\treturn phyblock;\n}\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\tif (!inode)\n\t\treturn 0xFFFFFFFF;\n\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc,\n\t\t\t\tmdata->s_phys_partition_ref);\n\t\t\tif (IS_ERR(mdata->s_mirror_fe))\n\t\t\t\tmdata->s_mirror_fe = NULL;\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}