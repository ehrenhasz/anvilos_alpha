{
  "module_name": "file.c",
  "hash_id": "abc5119bad52d4ebaad24a9c5e86ed927c3e095f383024f7862e9726b3202867",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/file.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/string.h>  \n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\nstatic vm_fault_t udf_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned int end;\n\tvm_fault_t ret = VM_FAULT_LOCKED;\n\tint err;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\tfilemap_invalidate_lock_shared(mapping);\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif (page->mapping != inode->i_mapping || page_offset(page) >= size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out_unlock;\n\t}\n\t \n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tgoto out_dirty;\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tend = size & ~PAGE_MASK;\n\telse\n\t\tend = PAGE_SIZE;\n\terr = __block_write_begin(page, 0, end, udf_get_block);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_unlock;\n\t}\n\n\tblock_commit_write(page, 0, end);\nout_dirty:\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\nout_unlock:\n\tfilemap_invalidate_unlock_shared(mapping);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct udf_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= udf_page_mkwrite,\n};\n\nstatic ssize_t udf_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t retval;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tinode_lock(inode);\n\n\tretval = generic_write_checks(iocb, from);\n\tif (retval <= 0)\n\t\tgoto out;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    inode->i_sb->s_blocksize < (udf_file_entry_alloc_offset(inode) +\n\t\t\t\t iocb->ki_pos + iov_iter_count(from))) {\n\t\tfilemap_invalidate_lock(inode->i_mapping);\n\t\tretval = udf_expand_file_adinicb(inode);\n\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\n\tretval = __generic_file_write_iter(iocb, from);\nout:\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB && retval > 0) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tinode_unlock(inode);\n\n\tif (retval > 0) {\n\t\tmark_inode_dirty(inode);\n\t\tretval = generic_write_sync(iocb, retval);\n\t}\n\n\treturn retval;\n}\n\nlong udf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tlong old_block, new_block;\n\tint result;\n\n\tif (file_permission(filp, MAY_READ) != 0) {\n\t\tudf_debug(\"no permission to access inode %lu\\n\", inode->i_ino);\n\t\treturn -EPERM;\n\t}\n\n\tif (!arg && ((cmd == UDF_GETVOLIDENT) || (cmd == UDF_GETEASIZE) ||\n\t\t     (cmd == UDF_RELOCATE_BLOCKS) || (cmd == UDF_GETEABLOCK))) {\n\t\tudf_debug(\"invalid argument to udf_ioctl\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase UDF_GETVOLIDENT:\n\t\tif (copy_to_user((char __user *)arg,\n\t\t\t\t UDF_SB(inode->i_sb)->s_volume_ident, 32))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase UDF_RELOCATE_BLOCKS:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(old_block, (long __user *)arg))\n\t\t\treturn -EFAULT;\n\t\tresult = udf_relocate_blocks(inode->i_sb,\n\t\t\t\t\t\told_block, &new_block);\n\t\tif (result == 0)\n\t\t\tresult = put_user(new_block, (long __user *)arg);\n\t\treturn result;\n\tcase UDF_GETEASIZE:\n\t\treturn put_user(UDF_I(inode)->i_lenEAttr, (int __user *)arg);\n\tcase UDF_GETEABLOCK:\n\t\treturn copy_to_user((char __user *)arg,\n\t\t\t\t    UDF_I(inode)->i_data,\n\t\t\t\t    UDF_I(inode)->i_lenEAttr) ? -EFAULT : 0;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int udf_release_file(struct inode *inode, struct file *filp)\n{\n\tif (filp->f_mode & FMODE_WRITE &&\n\t    atomic_read(&inode->i_writecount) == 1) {\n\t\t \n\t\tinode_lock(inode);\n\t\tdown_write(&UDF_I(inode)->i_data_sem);\n\t\tudf_discard_prealloc(inode);\n\t\tudf_truncate_tail_extent(inode);\n\t\tup_write(&UDF_I(inode)->i_data_sem);\n\t\tinode_unlock(inode);\n\t}\n\treturn 0;\n}\n\nstatic int udf_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tvma->vm_ops = &udf_file_vm_ops;\n\n\treturn 0;\n}\n\nconst struct file_operations udf_file_operations = {\n\t.read_iter\t\t= generic_file_read_iter,\n\t.unlocked_ioctl\t\t= udf_ioctl,\n\t.open\t\t\t= generic_file_open,\n\t.mmap\t\t\t= udf_file_mmap,\n\t.write_iter\t\t= udf_file_write_iter,\n\t.release\t\t= udf_release_file,\n\t.fsync\t\t\t= generic_file_fsync,\n\t.splice_read\t\t= filemap_splice_read,\n\t.splice_write\t\t= iter_file_splice_write,\n\t.llseek\t\t\t= generic_file_llseek,\n};\n\nstatic int udf_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t       struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_UID) &&\n\t    UDF_QUERY_FLAG(sb, UDF_FLAG_UID_SET) &&\n\t    !uid_eq(attr->ia_uid, UDF_SB(sb)->s_uid))\n\t\treturn -EPERM;\n\tif ((attr->ia_valid & ATTR_GID) &&\n\t    UDF_QUERY_FLAG(sb, UDF_FLAG_GID_SET) &&\n\t    !gid_eq(attr->ia_gid, UDF_SB(sb)->s_gid))\n\t\treturn -EPERM;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = udf_setsize(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\tudf_update_extra_perms(inode, attr->ia_mode);\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nconst struct inode_operations udf_file_inode_operations = {\n\t.setattr\t\t= udf_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}