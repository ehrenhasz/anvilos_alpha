{
  "module_name": "unicode.c",
  "hash_id": "9cefe49eaea747cfdaedf9d39f4b96a408d2553f708f4709422e364b2373533e",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/unicode.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include <linux/kernel.h>\n#include <linux/string.h>\t \n#include <linux/nls.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n\n#include \"udf_sb.h\"\n\n#define PLANE_SIZE 0x10000\n#define UNICODE_MAX 0x10ffff\n#define SURROGATE_MASK 0xfffff800\n#define SURROGATE_PAIR 0x0000d800\n#define SURROGATE_LOW  0x00000400\n#define SURROGATE_CHAR_BITS 10\n#define SURROGATE_CHAR_MASK ((1 << SURROGATE_CHAR_BITS) - 1)\n\n#define ILLEGAL_CHAR_MARK\t'_'\n#define EXT_MARK\t\t'.'\n#define CRC_MARK\t\t'#'\n#define EXT_SIZE\t\t5\n \n#define CRC_LEN\t\t\t5\n\nstatic unicode_t get_utf16_char(const uint8_t *str_i, int str_i_max_len,\n\t\t\t\tint str_i_idx, int u_ch, unicode_t *ret)\n{\n\tunicode_t c;\n\tint start_idx = str_i_idx;\n\n\t \n\tc = str_i[str_i_idx++];\n\tif (u_ch > 1)\n\t\tc = (c << 8) | str_i[str_i_idx++];\n\tif ((c & SURROGATE_MASK) == SURROGATE_PAIR) {\n\t\tunicode_t next;\n\n\t\t \n\t\tif (str_i_idx >= str_i_max_len) {\n\t\t\tc = UNICODE_MAX + 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (c & SURROGATE_LOW) {\n\t\t\tc = UNICODE_MAX + 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON_ONCE(u_ch != 2);\n\t\tnext = str_i[str_i_idx++] << 8;\n\t\tnext |= str_i[str_i_idx++];\n\t\tif ((next & SURROGATE_MASK) != SURROGATE_PAIR ||\n\t\t    !(next & SURROGATE_LOW)) {\n\t\t\tc = UNICODE_MAX + 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tc = PLANE_SIZE +\n\t\t    ((c & SURROGATE_CHAR_MASK) << SURROGATE_CHAR_BITS) +\n\t\t    (next & SURROGATE_CHAR_MASK);\n\t}\nout:\n\t*ret = c;\n\treturn str_i_idx - start_idx;\n}\n\n\nstatic int udf_name_conv_char(uint8_t *str_o, int str_o_max_len,\n\t\t\t      int *str_o_idx,\n\t\t\t      const uint8_t *str_i, int str_i_max_len,\n\t\t\t      int *str_i_idx,\n\t\t\t      int u_ch, int *needsCRC,\n\t\t\t      int (*conv_f)(wchar_t, unsigned char *, int),\n\t\t\t      int translate)\n{\n\tunicode_t c;\n\tint illChar = 0;\n\tint len, gotch = 0;\n\n\twhile (!gotch && *str_i_idx < str_i_max_len) {\n\t\tif (*str_o_idx >= str_o_max_len) {\n\t\t\t*needsCRC = 1;\n\t\t\treturn gotch;\n\t\t}\n\n\t\tlen = get_utf16_char(str_i, str_i_max_len, *str_i_idx, u_ch,\n\t\t\t\t     &c);\n\t\t \n\t\tif (c == 0 || c > UNICODE_MAX || (conv_f && c > MAX_WCHAR_T) ||\n\t\t    (translate && c == '/')) {\n\t\t\tillChar = 1;\n\t\t\tif (!translate)\n\t\t\t\tgotch = 1;\n\t\t} else if (illChar)\n\t\t\tbreak;\n\t\telse\n\t\t\tgotch = 1;\n\t\t*str_i_idx += len;\n\t}\n\tif (illChar) {\n\t\t*needsCRC = 1;\n\t\tc = ILLEGAL_CHAR_MARK;\n\t\tgotch = 1;\n\t}\n\tif (gotch) {\n\t\tif (conv_f) {\n\t\t\tlen = conv_f(c, &str_o[*str_o_idx],\n\t\t\t\t     str_o_max_len - *str_o_idx);\n\t\t} else {\n\t\t\tlen = utf32_to_utf8(c, &str_o[*str_o_idx],\n\t\t\t\t\t    str_o_max_len - *str_o_idx);\n\t\t\tif (len < 0)\n\t\t\t\tlen = -ENAMETOOLONG;\n\t\t}\n\t\t \n\t\tif (len >= 0)\n\t\t\t*str_o_idx += len;\n\t\telse if (len == -ENAMETOOLONG) {\n\t\t\t*needsCRC = 1;\n\t\t\tgotch = 0;\n\t\t} else {\n\t\t\tstr_o[(*str_o_idx)++] = ILLEGAL_CHAR_MARK;\n\t\t\t*needsCRC = 1;\n\t\t}\n\t}\n\treturn gotch;\n}\n\nstatic int udf_name_from_CS0(struct super_block *sb,\n\t\t\t     uint8_t *str_o, int str_max_len,\n\t\t\t     const uint8_t *ocu, int ocu_len,\n\t\t\t     int translate)\n{\n\tuint32_t c;\n\tuint8_t cmp_id;\n\tint idx, len;\n\tint u_ch;\n\tint needsCRC = 0;\n\tint ext_i_len, ext_max_len;\n\tint str_o_len = 0;\t \n\tint ext_o_len = 0;\t \n\tint ext_crc_len = 0;\t \n\tint i_ext = -1;\t\t \n\tint o_crc = 0;\t\t \n\tunsigned short valueCRC;\n\tuint8_t ext[EXT_SIZE * NLS_MAX_CHARSET_SIZE + 1];\n\tuint8_t crc[CRC_LEN];\n\tint (*conv_f)(wchar_t, unsigned char *, int);\n\n\tif (str_max_len <= 0)\n\t\treturn 0;\n\n\tif (ocu_len == 0) {\n\t\tmemset(str_o, 0, str_max_len);\n\t\treturn 0;\n\t}\n\n\tif (UDF_SB(sb)->s_nls_map)\n\t\tconv_f = UDF_SB(sb)->s_nls_map->uni2char;\n\telse\n\t\tconv_f = NULL;\n\n\tcmp_id = ocu[0];\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(str_o, 0, str_max_len);\n\t\tpr_err(\"unknown compression code (%u)\\n\", cmp_id);\n\t\treturn -EINVAL;\n\t}\n\tu_ch = cmp_id >> 3;\n\n\tocu++;\n\tocu_len--;\n\n\tif (ocu_len % u_ch) {\n\t\tpr_err(\"incorrect filename length (%d)\\n\", ocu_len + 1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (translate) {\n\t\t \n\t\tfor (idx = ocu_len - u_ch, ext_i_len = 0;\n\t\t     (idx >= 0) && (ext_i_len < EXT_SIZE);\n\t\t     idx -= u_ch, ext_i_len++) {\n\t\t\tc = ocu[idx];\n\t\t\tif (u_ch > 1)\n\t\t\t\tc = (c << 8) | ocu[idx + 1];\n\n\t\t\tif (c == EXT_MARK) {\n\t\t\t\tif (ext_i_len)\n\t\t\t\t\ti_ext = idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i_ext >= 0) {\n\t\t\t \n\t\t\text_max_len = min_t(int, sizeof(ext), str_max_len);\n\t\t\text[ext_o_len++] = EXT_MARK;\n\t\t\tidx = i_ext + u_ch;\n\t\t\twhile (udf_name_conv_char(ext, ext_max_len, &ext_o_len,\n\t\t\t\t\t\t  ocu, ocu_len, &idx,\n\t\t\t\t\t\t  u_ch, &needsCRC,\n\t\t\t\t\t\t  conv_f, translate)) {\n\t\t\t\tif ((ext_o_len + CRC_LEN) < str_max_len)\n\t\t\t\t\text_crc_len = ext_o_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tidx = 0;\n\twhile (1) {\n\t\tif (translate && (idx == i_ext)) {\n\t\t\tif (str_o_len > (str_max_len - ext_o_len))\n\t\t\t\tneedsCRC = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!udf_name_conv_char(str_o, str_max_len, &str_o_len,\n\t\t\t\t\tocu, ocu_len, &idx,\n\t\t\t\t\tu_ch, &needsCRC, conv_f, translate))\n\t\t\tbreak;\n\n\t\tif (translate &&\n\t\t    (str_o_len <= (str_max_len - ext_o_len - CRC_LEN)))\n\t\t\to_crc = str_o_len;\n\t}\n\n\tif (translate) {\n\t\tif (str_o_len > 0 && str_o_len <= 2 && str_o[0] == '.' &&\n\t\t    (str_o_len == 1 || str_o[1] == '.'))\n\t\t\tneedsCRC = 1;\n\t\tif (needsCRC) {\n\t\t\tstr_o_len = o_crc;\n\t\t\tvalueCRC = crc_itu_t(0, ocu, ocu_len);\n\t\t\tcrc[0] = CRC_MARK;\n\t\t\tcrc[1] = hex_asc_upper_hi(valueCRC >> 8);\n\t\t\tcrc[2] = hex_asc_upper_lo(valueCRC >> 8);\n\t\t\tcrc[3] = hex_asc_upper_hi(valueCRC);\n\t\t\tcrc[4] = hex_asc_upper_lo(valueCRC);\n\t\t\tlen = min_t(int, CRC_LEN, str_max_len - str_o_len);\n\t\t\tmemcpy(&str_o[str_o_len], crc, len);\n\t\t\tstr_o_len += len;\n\t\t\text_o_len = ext_crc_len;\n\t\t}\n\t\tif (ext_o_len > 0) {\n\t\t\tmemcpy(&str_o[str_o_len], ext, ext_o_len);\n\t\t\tstr_o_len += ext_o_len;\n\t\t}\n\t}\n\n\treturn str_o_len;\n}\n\nstatic int udf_name_to_CS0(struct super_block *sb,\n\t\t\t   uint8_t *ocu, int ocu_max_len,\n\t\t\t   const uint8_t *str_i, int str_len)\n{\n\tint i, len;\n\tunsigned int max_val;\n\tint u_len, u_ch;\n\tunicode_t uni_char;\n\tint (*conv_f)(const unsigned char *, int, wchar_t *);\n\n\tif (ocu_max_len <= 0)\n\t\treturn 0;\n\n\tif (UDF_SB(sb)->s_nls_map)\n\t\tconv_f = UDF_SB(sb)->s_nls_map->char2uni;\n\telse\n\t\tconv_f = NULL;\n\n\tmemset(ocu, 0, ocu_max_len);\n\tocu[0] = 8;\n\tmax_val = 0xff;\n\tu_ch = 1;\n\ntry_again:\n\tu_len = 1;\n\tfor (i = 0; i < str_len; i += len) {\n\t\t \n\t\tif (u_len + u_ch > ocu_max_len)\n\t\t\treturn 0;\n\t\tif (conv_f) {\n\t\t\twchar_t wchar;\n\n\t\t\tlen = conv_f(&str_i[i], str_len - i, &wchar);\n\t\t\tif (len > 0)\n\t\t\t\tuni_char = wchar;\n\t\t} else {\n\t\t\tlen = utf8_to_utf32(&str_i[i], str_len - i,\n\t\t\t\t\t    &uni_char);\n\t\t}\n\t\t \n\t\tif (len <= 0 || uni_char > UNICODE_MAX) {\n\t\t\tlen = 1;\n\t\t\tuni_char = '?';\n\t\t}\n\n\t\tif (uni_char > max_val) {\n\t\t\tunicode_t c;\n\n\t\t\tif (max_val == 0xff) {\n\t\t\t\tmax_val = 0xffff;\n\t\t\t\tocu[0] = 0x10;\n\t\t\t\tu_ch = 2;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\t \n\t\t\tif (u_len + 2 * u_ch > ocu_max_len)\n\t\t\t\treturn 0;\n\n\t\t\tuni_char -= PLANE_SIZE;\n\t\t\tc = SURROGATE_PAIR |\n\t\t\t    ((uni_char >> SURROGATE_CHAR_BITS) &\n\t\t\t     SURROGATE_CHAR_MASK);\n\t\t\tocu[u_len++] = (uint8_t)(c >> 8);\n\t\t\tocu[u_len++] = (uint8_t)(c & 0xff);\n\t\t\tuni_char = SURROGATE_PAIR | SURROGATE_LOW |\n\t\t\t\t\t(uni_char & SURROGATE_CHAR_MASK);\n\t\t}\n\n\t\tif (max_val == 0xffff)\n\t\t\tocu[u_len++] = (uint8_t)(uni_char >> 8);\n\t\tocu[u_len++] = (uint8_t)(uni_char & 0xff);\n\t}\n\n\treturn u_len;\n}\n\n \nint udf_dstrCS0toChar(struct super_block *sb, uint8_t *utf_o, int o_len,\n\t\t      const uint8_t *ocu_i, int i_len)\n{\n\tint s_len = 0;\n\n\tif (i_len > 0) {\n\t\ts_len = ocu_i[i_len - 1];\n\t\tif (s_len >= i_len) {\n\t\t\tpr_warn(\"incorrect dstring lengths (%d/%d),\"\n\t\t\t\t\" truncating\\n\", s_len, i_len);\n\t\t\ts_len = i_len - 1;\n\t\t\t \n\t\t\tif (ocu_i[0] == 16)\n\t\t\t\ts_len -= (s_len - 1) & 2;\n\t\t}\n\t}\n\n\treturn udf_name_from_CS0(sb, utf_o, o_len, ocu_i, s_len, 0);\n}\n\nint udf_get_filename(struct super_block *sb, const uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tint ret;\n\n\tif (!slen)\n\t\treturn -EIO;\n\n\tif (dlen <= 0)\n\t\treturn 0;\n\n\tret = udf_name_from_CS0(sb, dname, dlen, sname, slen, 1);\n\t \n\tif (ret == 0)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\nint udf_put_filename(struct super_block *sb, const uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\treturn udf_name_to_CS0(sb, dname, dlen, sname, slen);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}