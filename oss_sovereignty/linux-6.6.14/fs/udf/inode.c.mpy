{
  "module_name": "inode.c",
  "hash_id": "49150fe8d13771f414576d837691c1a09fdcb97d8cc90306f4ee000bf679ffb6",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/inode.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/mpage.h>\n#include <linux/uio.h>\n#include <linux/bio.h>\n\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\n#define FE_MAPPED_PERMS\t(FE_PERM_U_READ | FE_PERM_U_WRITE | FE_PERM_U_EXEC | \\\n\t\t\t FE_PERM_G_READ | FE_PERM_G_WRITE | FE_PERM_G_EXEC | \\\n\t\t\t FE_PERM_O_READ | FE_PERM_O_WRITE | FE_PERM_O_EXEC)\n\n#define FE_DELETE_PERMS\t(FE_PERM_U_DELETE | FE_PERM_G_DELETE | \\\n\t\t\t FE_PERM_O_DELETE)\n\nstruct udf_map_rq;\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic int inode_getblk(struct inode *inode, struct udf_map_rq *map);\nstatic int udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t   struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, udf_pblk_t,\n\t\t\t      struct kernel_long_ad *, int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad *, int *);\nstatic void udf_merge_extents(struct inode *, struct kernel_long_ad *, int *);\nstatic int udf_update_extents(struct inode *, struct kernel_long_ad *, int,\n\t\t\t      int, struct extent_position *);\nstatic int udf_get_block_wb(struct inode *inode, sector_t block,\n\t\t\t    struct buffer_head *bh_result, int create);\n\nstatic void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}\n\n \nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}\n\n \nstatic int udf_read_extent_cache(struct inode *inode, loff_t bcount,\n\t\t\t\t loff_t *lbcount, struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint ret = 0;\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\tif ((iinfo->cached_extent.lstart <= bcount) &&\n\t    (iinfo->cached_extent.lstart != -1)) {\n\t\t \n\t\t*lbcount = iinfo->cached_extent.lstart;\n\t\tmemcpy(pos, &iinfo->cached_extent.epos,\n\t\t       sizeof(struct extent_position));\n\t\tif (pos->bh)\n\t\t\tget_bh(pos->bh);\n\t\tret = 1;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n\treturn ret;\n}\n\n \nstatic void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t \n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos, sizeof(*pos));\n\tiinfo->cached_extent.lstart = estart;\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tiinfo->cached_extent.epos.offset -= sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tiinfo->cached_extent.epos.offset -= sizeof(struct long_ad);\n\t\tbreak;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}\n\nvoid udf_evict_inode(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint want_delete = 0;\n\n\tif (!is_bad_inode(inode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\twant_delete = 1;\n\t\t\tudf_setsize(inode, 0);\n\t\t\tudf_update_inode(inode, IS_SYNC(inode));\n\t\t}\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB &&\n\t\t    inode->i_size != iinfo->i_lenExtents) {\n\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t \"Inode %lu (mode %o) has inode size %llu different from extent length %llu. Filesystem need not be standards compliant.\\n\",\n\t\t\t\t inode->i_ino, inode->i_mode,\n\t\t\t\t (unsigned long long)inode->i_size,\n\t\t\t\t (unsigned long long)iinfo->i_lenExtents);\n\t\t}\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tkfree(iinfo->i_data);\n\tiinfo->i_data = NULL;\n\tudf_clear_extent_cache(inode);\n\tif (want_delete) {\n\t\tudf_free_inode(inode);\n\t}\n}\n\nstatic void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}\n\nstatic int udf_adinicb_writepage(struct folio *folio,\n\t\t\t\t struct writeback_control *wbc, void *data)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tBUG_ON(!folio_test_locked(folio));\n\tBUG_ON(folio->index != 0);\n\tmemcpy_from_file_folio(iinfo->i_data + iinfo->i_lenEAttr, folio, 0,\n\t\t       i_size_read(inode));\n\tfolio_unlock(folio);\n\tmark_inode_dirty(inode);\n\n\treturn 0;\n}\n\nstatic int udf_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn mpage_writepages(mapping, wbc, udf_get_block_wb);\n\treturn write_cache_pages(mapping, wbc, udf_adinicb_writepage, NULL);\n}\n\nstatic void udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = i_size_read(inode);\n\n\tkaddr = kmap_local_page(page);\n\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr, isize);\n\tmemset(kaddr + isize, 0, PAGE_SIZE - isize);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap_local(kaddr);\n}\n\nstatic int udf_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(file_inode(file));\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tudf_adinicb_readpage(&folio->page);\n\t\tfolio_unlock(folio);\n\t\treturn 0;\n\t}\n\treturn mpage_read_folio(folio, udf_get_block);\n}\n\nstatic void udf_readahead(struct readahead_control *rac)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(rac->mapping->host);\n\n\t \n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn;\n\n\tmpage_readahead(rac, udf_get_block);\n}\n\nstatic int udf_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len,\n\t\t\t   struct page **pagep, void **fsdata)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(file_inode(file));\n\tstruct page *page;\n\tint ret;\n\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tret = block_write_begin(mapping, pos, len, pagep,\n\t\t\t\t\tudf_get_block);\n\t\tif (unlikely(ret))\n\t\t\tudf_write_failed(mapping, pos + len);\n\t\treturn ret;\n\t}\n\tif (WARN_ON_ONCE(pos >= PAGE_SIZE))\n\t\treturn -EIO;\n\tpage = grab_cache_page_write_begin(mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\tif (!PageUptodate(page))\n\t\tudf_adinicb_readpage(page);\n\treturn 0;\n}\n\nstatic int udf_write_end(struct file *file, struct address_space *mapping,\n\t\t\t loff_t pos, unsigned len, unsigned copied,\n\t\t\t struct page *page, void *fsdata)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t last_pos;\n\n\tif (UDF_I(inode)->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn generic_write_end(file, mapping, pos, len, copied, page,\n\t\t\t\t\t fsdata);\n\tlast_pos = pos + copied;\n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn copied;\n}\n\nstatic ssize_t udf_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\t \n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn 0;\n\tret = blockdev_direct_IO(iocb, inode, iter, udf_get_block);\n\tif (unlikely(ret < 0 && iov_iter_rw(iter) == WRITE))\n\t\tudf_write_failed(mapping, iocb->ki_pos + count);\n\treturn ret;\n}\n\nstatic sector_t udf_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(mapping->host);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn -EINVAL;\n\treturn generic_block_bmap(mapping, block, udf_get_block);\n}\n\nconst struct address_space_operations udf_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= udf_read_folio,\n\t.readahead\t= udf_readahead,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= udf_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\n \nint udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page))\n\t\tudf_adinicb_readpage(page);\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t \n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy_to_page(page, 0, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\t       inode->i_size);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}\n\n#define UDF_MAP_CREATE\t\t0x01\t \n#define UDF_MAP_NOPREALLOC\t0x02\t \n\n#define UDF_BLK_MAPPED\t0x01\t \n#define UDF_BLK_NEW\t0x02\t \n\nstruct udf_map_rq {\n\tsector_t lblk;\n\tudf_pblk_t pblk;\n\tint iflags;\t\t \n\tint oflags;\t\t \n};\n\nstatic int udf_map_block(struct inode *inode, struct udf_map_rq *map)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (WARN_ON_ONCE(iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB))\n\t\treturn -EFSCORRUPTED;\n\n\tmap->oflags = 0;\n\tif (!(map->iflags & UDF_MAP_CREATE)) {\n\t\tstruct kernel_lb_addr eloc;\n\t\tuint32_t elen;\n\t\tsector_t offset;\n\t\tstruct extent_position epos = {};\n\n\t\tdown_read(&iinfo->i_data_sem);\n\t\tif (inode_bmap(inode, map->lblk, &epos, &eloc, &elen, &offset)\n\t\t\t\t== (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tmap->pblk = udf_get_lb_pblock(inode->i_sb, &eloc,\n\t\t\t\t\t\t\toffset);\n\t\t\tmap->oflags |= UDF_BLK_MAPPED;\n\t\t}\n\t\tup_read(&iinfo->i_data_sem);\n\t\tbrelse(epos.bh);\n\n\t\treturn 0;\n\t}\n\n\tdown_write(&iinfo->i_data_sem);\n\t \n\tif (((loff_t)map->lblk) << inode->i_blkbits >= iinfo->i_lenExtents)\n\t\tudf_discard_prealloc(inode);\n\tudf_clear_extent_cache(inode);\n\terr = inode_getblk(inode, map);\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}\n\nstatic int __udf_get_block(struct inode *inode, sector_t block,\n\t\t\t   struct buffer_head *bh_result, int flags)\n{\n\tint err;\n\tstruct udf_map_rq map = {\n\t\t.lblk = block,\n\t\t.iflags = flags,\n\t};\n\n\terr = udf_map_block(inode, &map);\n\tif (err < 0)\n\t\treturn err;\n\tif (map.oflags & UDF_BLK_MAPPED) {\n\t\tmap_bh(bh_result, inode->i_sb, map.pblk);\n\t\tif (map.oflags & UDF_BLK_NEW)\n\t\t\tset_buffer_new(bh_result);\n\t}\n\treturn 0;\n}\n\nint udf_get_block(struct inode *inode, sector_t block,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\tint flags = create ? UDF_MAP_CREATE : 0;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\tflags |= UDF_MAP_NOPREALLOC;\n\treturn __udf_get_block(inode, block, bh_result, flags);\n}\n\n \nstatic int udf_get_block_wb(struct inode *inode, sector_t block,\n\t\t\t    struct buffer_head *bh_result, int create)\n{\n\treturn __udf_get_block(inode, block, bh_result, 0);\n}\n\n \nstatic int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      loff_t new_block_bytes)\n{\n\tuint32_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t \n\tif (!new_block_bytes && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t \n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\tadd = 0;\n\t \n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = (1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tif (add > new_block_bytes)\n\t\t\tadd = new_block_bytes;\n\t\tnew_block_bytes -= add;\n\t\tlast_ext->extLength += add;\n\t}\n\n\tif (fake) {\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tcount++;\n\t} else {\n\t\tstruct kernel_lb_addr tmploc;\n\t\tuint32_t tmplen;\n\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t\t \n\t\tif (new_block_bytes)\n\t\t\tudf_next_aext(inode, last_pos, &tmploc, &tmplen, 0);\n\t}\n\tiinfo->i_lenExtents += add;\n\n\t \n\tif (!new_block_bytes)\n\t\tgoto out;\n\n\t \n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << 30) - sb->s_blocksize;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED | add;\n\n\t \n\twhile (new_block_bytes > add) {\n\t\tnew_block_bytes -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tiinfo->i_lenExtents += add;\n\t\tcount++;\n\t}\n\tif (new_block_bytes) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\tnew_block_bytes;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tiinfo->i_lenExtents += new_block_bytes;\n\t\tcount++;\n\t}\n\nout:\n\t \n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\nout_err:\n\t \n\tudf_clear_extent_cache(inode);\n\tudf_truncate_extents(inode);\n\treturn err;\n}\n\n \nstatic void udf_do_extend_final_block(struct inode *inode,\n\t\t\t\t      struct extent_position *last_pos,\n\t\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t\t      uint32_t new_elen)\n{\n\tuint32_t added_bytes;\n\n\t \n\tif (new_elen <= (last_ext->extLength & UDF_EXTENT_LENGTH_MASK))\n\t\treturn;\n\tadded_bytes = new_elen - (last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tlast_ext->extLength += added_bytes;\n\tUDF_I(inode)->i_lenExtents += added_bytes;\n\n\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\tlast_ext->extLength, 1);\n}\n\nstatic int udf_extend_file(struct inode *inode, loff_t newsize)\n{\n\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tloff_t new_elen;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err = 0;\n\tbool within_last_ext;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tdown_write(&iinfo->i_data_sem);\n\t \n\tudf_discard_prealloc(inode);\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\twithin_last_ext = (etype != -1);\n\t \n\tWARN_ON_ONCE(within_last_ext &&\n\t\t     elen > ((loff_t)offset + 1) << inode->i_blkbits);\n\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n\t    (epos.bh && epos.offset == sizeof(struct allocExtDesc))) {\n\t\t \n\t\textent.extLocation.logicalBlockNum = 0;\n\t\textent.extLocation.partitionReferenceNum = 0;\n\t\textent.extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t} else {\n\t\tepos.offset -= adsize;\n\t\tetype = udf_next_aext(inode, &epos, &extent.extLocation,\n\t\t\t\t      &extent.extLength, 0);\n\t\textent.extLength |= etype << 30;\n\t}\n\n\tnew_elen = ((loff_t)offset << inode->i_blkbits) |\n\t\t\t\t\t(newsize & (sb->s_blocksize - 1));\n\n\t \n\tif (within_last_ext) {\n\t\t \n\t\tudf_do_extend_final_block(inode, &epos, &extent, new_elen);\n\t} else {\n\t\terr = udf_do_extend_file(inode, &epos, &extent, new_elen);\n\t}\n\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\nout:\n\tbrelse(epos.bh);\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}\n\nstatic int inode_getblk(struct inode *inode, struct udf_map_rq *map)\n{\n\tstruct kernel_long_ad laarr[EXTENT_MERGE_SIZE];\n\tstruct extent_position prev_epos, cur_epos, next_epos;\n\tint count = 0, startnum = 0, endnum = 0;\n\tuint32_t elen = 0, tmpelen;\n\tstruct kernel_lb_addr eloc, tmpeloc;\n\tint c = 1;\n\tloff_t lbcount = 0, b_off = 0;\n\tudf_pblk_t newblocknum;\n\tsector_t offset = 0;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tudf_pblk_t goal = 0, pgoal = iinfo->i_location.logicalBlockNum;\n\tint lastblock = 0;\n\tbool isBeyondEOF;\n\tint ret = 0;\n\n\tprev_epos.offset = udf_file_entry_alloc_offset(inode);\n\tprev_epos.block = iinfo->i_location;\n\tprev_epos.bh = NULL;\n\tcur_epos = next_epos = prev_epos;\n\tb_off = (loff_t)map->lblk << inode->i_sb->s_blocksize_bits;\n\n\t \n\tdo {\n\t\tif (prev_epos.bh != cur_epos.bh) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tget_bh(cur_epos.bh);\n\t\t\tprev_epos.bh = cur_epos.bh;\n\t\t}\n\t\tif (cur_epos.bh != next_epos.bh) {\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tget_bh(next_epos.bh);\n\t\t\tcur_epos.bh = next_epos.bh;\n\t\t}\n\n\t\tlbcount += elen;\n\n\t\tprev_epos.block = cur_epos.block;\n\t\tcur_epos.block = next_epos.block;\n\n\t\tprev_epos.offset = cur_epos.offset;\n\t\tcur_epos.offset = next_epos.offset;\n\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 1);\n\t\tif (etype == -1)\n\t\t\tbreak;\n\n\t\tc = !c;\n\n\t\tlaarr[c].extLength = (etype << 30) | elen;\n\t\tlaarr[c].extLocation = eloc;\n\n\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tpgoal = eloc.logicalBlockNum +\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t inode->i_sb->s_blocksize_bits);\n\n\t\tcount++;\n\t} while (lbcount + elen <= b_off);\n\n\tb_off -= lbcount;\n\toffset = b_off >> inode->i_sb->s_blocksize_bits;\n\t \n\tudf_next_aext(inode, &prev_epos, &tmpeloc, &tmpelen, 0);\n\tudf_next_aext(inode, &cur_epos, &tmpeloc, &tmpelen, 0);\n\n\t \n\n\tif (etype == (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (elen & (inode->i_sb->s_blocksize - 1)) {\n\t\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) &\n\t\t\t\t ~(inode->i_sb->s_blocksize - 1));\n\t\t\tiinfo->i_lenExtents =\n\t\t\t\tALIGN(iinfo->i_lenExtents,\n\t\t\t\t      inode->i_sb->s_blocksize);\n\t\t\tudf_write_aext(inode, &cur_epos, &eloc, elen, 1);\n\t\t}\n\t\tmap->oflags = UDF_BLK_MAPPED;\n\t\tmap->pblk = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (etype == -1) {\n\t\tloff_t hole_len;\n\n\t\tisBeyondEOF = true;\n\t\tif (count) {\n\t\t\tif (c)\n\t\t\t\tlaarr[0] = laarr[1];\n\t\t\tstartnum = 1;\n\t\t} else {\n\t\t\t \n\t\t\tmemset(&laarr[0].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tlaarr[0].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t\t \n\t\t\tstartnum = (offset > 0);\n\t\t}\n\t\t \n\t\thole_len = (loff_t)offset << inode->i_blkbits;\n\t\tret = udf_do_extend_file(inode, &prev_epos, laarr, hole_len);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t\tc = 0;\n\t\toffset = 0;\n\t\tcount += ret;\n\t\t \n\t\tif (count)\n\t\t\tc = !c;\n\t\tlaarr[c].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\tinode->i_sb->s_blocksize;\n\t\tmemset(&laarr[c].extLocation, 0x00,\n\t\t\tsizeof(struct kernel_lb_addr));\n\t\tcount++;\n\t\tendnum = c + 1;\n\t\tlastblock = 1;\n\t} else {\n\t\tisBeyondEOF = false;\n\t\tendnum = startnum = ((count > 2) ? 2 : count);\n\n\t\t \n\t\tif (!c && count != 1) {\n\t\t\tlaarr[2] = laarr[0];\n\t\t\tlaarr[0] = laarr[1];\n\t\t\tlaarr[1] = laarr[2];\n\t\t\tc = 1;\n\t\t}\n\n\t\t \n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0);\n\t\tif (etype != -1) {\n\t\t\tlaarr[c + 1].extLength = (etype << 30) | elen;\n\t\t\tlaarr[c + 1].extLocation = eloc;\n\t\t\tcount++;\n\t\t\tstartnum++;\n\t\t\tendnum++;\n\t\t} else\n\t\t\tlastblock = 1;\n\t}\n\n\t \n\tif ((laarr[c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\tnewblocknum = laarr[c].extLocation.logicalBlockNum + offset;\n\telse {  \n\t\tif (iinfo->i_next_alloc_block == map->lblk)\n\t\t\tgoal = iinfo->i_next_alloc_goal;\n\n\t\tif (!goal) {\n\t\t\tif (!(goal = pgoal))  \n\t\t\t\tgoal = iinfo->i_location.logicalBlockNum + 1;\n\t\t}\n\n\t\tnewblocknum = udf_new_block(inode->i_sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tgoal, &ret);\n\t\tif (!newblocknum)\n\t\t\tgoto out_free;\n\t\tif (isBeyondEOF)\n\t\t\tiinfo->i_lenExtents += inode->i_sb->s_blocksize;\n\t}\n\n\t \n\tudf_split_extents(inode, &c, offset, newblocknum, laarr, &endnum);\n\n\tif (!(map->iflags & UDF_MAP_NOPREALLOC))\n\t\tudf_prealloc_extents(inode, c, lastblock, laarr, &endnum);\n\n\t \n\tudf_merge_extents(inode, laarr, &endnum);\n\n\t \n\tret = udf_update_extents(inode, laarr, startnum, endnum, &prev_epos);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tmap->pblk = udf_get_pblock(inode->i_sb, newblocknum,\n\t\t\t\tiinfo->i_location.partitionReferenceNum, 0);\n\tif (!map->pblk) {\n\t\tret = -EFSCORRUPTED;\n\t\tgoto out_free;\n\t}\n\tmap->oflags = UDF_BLK_NEW | UDF_BLK_MAPPED;\n\tiinfo->i_next_alloc_block = map->lblk + 1;\n\tiinfo->i_next_alloc_goal = newblocknum + 1;\n\tinode_set_ctime_current(inode);\n\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\tret = 0;\nout_free:\n\tbrelse(prev_epos.bh);\n\tbrelse(cur_epos.bh);\n\tbrelse(next_epos.bh);\n\treturn ret;\n}\n\nstatic void udf_split_extents(struct inode *inode, int *c, int offset,\n\t\t\t       udf_pblk_t newblocknum,\n\t\t\t       struct kernel_long_ad *laarr, int *endnum)\n{\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tif ((laarr[*c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30) ||\n\t    (laarr[*c].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\tint curr = *c;\n\t\tint blen = ((laarr[curr].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t    blocksize - 1) >> blocksize_bits;\n\t\tint8_t etype = (laarr[curr].extLength >> 30);\n\n\t\tif (blen == 1)\n\t\t\t;\n\t\telse if (!offset || blen == offset + 1) {\n\t\t\tlaarr[curr + 2] = laarr[curr + 1];\n\t\t\tlaarr[curr + 1] = laarr[curr];\n\t\t} else {\n\t\t\tlaarr[curr + 3] = laarr[curr + 1];\n\t\t\tlaarr[curr + 2] = laarr[curr + 1] = laarr[curr];\n\t\t}\n\n\t\tif (offset) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t\t&laarr[curr].extLocation,\n\t\t\t\t\t\t0, offset);\n\t\t\t\tlaarr[curr].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum = 0;\n\t\t\t\tlaarr[curr].extLocation.\n\t\t\t\t\t\tpartitionReferenceNum = 0;\n\t\t\t} else\n\t\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*c)++;\n\t\t\t(*endnum)++;\n\t\t}\n\n\t\tlaarr[curr].extLocation.logicalBlockNum = newblocknum;\n\t\tif (etype == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tlaarr[curr].extLocation.partitionReferenceNum =\n\t\t\t\tUDF_I(inode)->i_location.partitionReferenceNum;\n\t\tlaarr[curr].extLength = EXT_RECORDED_ALLOCATED |\n\t\t\tblocksize;\n\t\tcurr++;\n\n\t\tif (blen != offset + 1) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum +=\n\t\t\t\t\t\t\t\toffset + 1;\n\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t((blen - (offset + 1)) << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*endnum)++;\n\t\t}\n\t}\n}\n\nstatic void udf_prealloc_extents(struct inode *inode, int c, int lastblock,\n\t\t\t\t struct kernel_long_ad *laarr,\n\t\t\t\t int *endnum)\n{\n\tint start, length = 0, currlength = 0, i;\n\n\tif (*endnum >= (c + 1)) {\n\t\tif (!lastblock)\n\t\t\treturn;\n\t\telse\n\t\t\tstart = c;\n\t} else {\n\t\tif ((laarr[c + 1].extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tstart = c + 1;\n\t\t\tlength = currlength =\n\t\t\t\t(((laarr[c + 1].extLength &\n\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tinode->i_sb->s_blocksize - 1) >>\n\t\t\t\tinode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tstart = c;\n\t}\n\n\tfor (i = start + 1; i <= *endnum; i++) {\n\t\tif (i == *endnum) {\n\t\t\tif (lastblock)\n\t\t\t\tlength += UDF_DEFAULT_PREALLOC_BLOCKS;\n\t\t} else if ((laarr[i].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\t\tlength += (((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (length) {\n\t\tint next = laarr[start].extLocation.logicalBlockNum +\n\t\t\t(((laarr[start].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  inode->i_sb->s_blocksize - 1) >>\n\t\t\t  inode->i_sb->s_blocksize_bits);\n\t\tint numalloc = udf_prealloc_blocks(inode->i_sb, inode,\n\t\t\t\tlaarr[start].extLocation.partitionReferenceNum,\n\t\t\t\tnext, (UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength);\n\t\tif (numalloc) \t{\n\t\t\tif (start == (c + 1))\n\t\t\t\tlaarr[start].extLength +=\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\telse {\n\t\t\t\tmemmove(&laarr[c + 2], &laarr[c + 1],\n\t\t\t\t\tsizeof(struct long_ad) * (*endnum - (c + 1)));\n\t\t\t\t(*endnum)++;\n\t\t\t\tlaarr[c + 1].extLocation.logicalBlockNum = next;\n\t\t\t\tlaarr[c + 1].extLocation.partitionReferenceNum =\n\t\t\t\t\tlaarr[c].extLocation.\n\t\t\t\t\t\t\tpartitionReferenceNum;\n\t\t\t\tlaarr[c + 1].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED |\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\tstart = c + 1;\n\t\t\t}\n\n\t\t\tfor (i = start + 1; numalloc && i < *endnum; i++) {\n\t\t\t\tint elen = ((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits;\n\n\t\t\t\tif (elen > numalloc) {\n\t\t\t\t\tlaarr[i].extLength -=\n\t\t\t\t\t\t(numalloc <<\n\t\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\t\tnumalloc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnumalloc -= elen;\n\t\t\t\t\tif (*endnum > (i + 1))\n\t\t\t\t\t\tmemmove(&laarr[i],\n\t\t\t\t\t\t\t&laarr[i + 1],\n\t\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1)));\n\t\t\t\t\ti--;\n\t\t\t\t\t(*endnum)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tUDF_I(inode)->i_lenExtents +=\n\t\t\t\tnumalloc << inode->i_sb->s_blocksize_bits;\n\t\t}\n\t}\n}\n\nstatic void udf_merge_extents(struct inode *inode, struct kernel_long_ad *laarr,\n\t\t\t      int *endnum)\n{\n\tint i;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tfor (i = 0; i < (*endnum - 1); i++) {\n\t\tstruct kernel_long_ad *li   = &laarr[i];\n\t\tstruct kernel_long_ad *lip1   = &laarr[i + 1];\n\n\t\tif (((li->extLength >> 30) == (lip1->extLength >> 30)) &&\n\t\t\t(((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) ||\n\t\t\t((lip1->extLocation.logicalBlockNum -\n\t\t\t  li->extLocation.logicalBlockNum) ==\n\t\t\t(((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\tblocksize - 1) >> blocksize_bits)))) {\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) <= UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if (((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) &&\n\t\t\t   ((lip1->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t  UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t   (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t   ~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t  blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if ((li->extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t&li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) |\n\t\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t}\n\t}\n}\n\nstatic int udf_update_extents(struct inode *inode, struct kernel_long_ad *laarr,\n\t\t\t      int startnum, int endnum,\n\t\t\t      struct extent_position *epos)\n{\n\tint start = 0, i;\n\tstruct kernel_lb_addr tmploc;\n\tuint32_t tmplen;\n\tint err;\n\n\tif (startnum > endnum) {\n\t\tfor (i = 0; i < (startnum - endnum); i++)\n\t\t\tudf_delete_aext(inode, *epos);\n\t} else if (startnum < endnum) {\n\t\tfor (i = 0; i < (endnum - startnum); i++) {\n\t\t\terr = udf_insert_aext(inode, *epos,\n\t\t\t\t\t      laarr[i].extLocation,\n\t\t\t\t\t      laarr[i].extLength);\n\t\t\t \n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tudf_next_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t\t      &laarr[i].extLength, 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\n\tfor (i = start; i < endnum; i++) {\n\t\tudf_next_aext(inode, epos, &tmploc, &tmplen, 0);\n\t\tudf_write_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t       laarr[i].extLength, 1);\n\t}\n\treturn 0;\n}\n\nstruct buffer_head *udf_bread(struct inode *inode, udf_pblk_t block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_map_rq map = {\n\t\t.lblk = block,\n\t\t.iflags = UDF_MAP_NOPREALLOC | (create ? UDF_MAP_CREATE : 0),\n\t};\n\n\t*err = udf_map_block(inode, &map);\n\tif (*err || !(map.oflags & UDF_BLK_MAPPED))\n\t\treturn NULL;\n\n\tbh = sb_getblk(inode->i_sb, map.pblk);\n\tif (!bh) {\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tif (map.oflags & UDF_BLK_NEW) {\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty_inode(bh, inode);\n\t\treturn bh;\n\t}\n\n\tif (bh_read(bh, 0) >= 0)\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}\n\nint udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err = 0;\n\tstruct udf_inode_info *iinfo;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize >=\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err)\n\t\t\tgoto out_unlock;\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\ttruncate_setsize(inode, newsize);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\terr = udf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\nupdate_time:\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\nout_unlock:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\treturn err;\n}\n\n \n#define UDF_MAX_ICB_NESTING 1024\n\nstatic int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\tuint32_t uid, gid;\n\tstruct timespec64 ctime;\n\nreread:\n\tif (iloc->partitionReferenceNum >= sbi->s_partitions) {\n\t\tudf_debug(\"partition reference: %u > logical volume partitions: %u\\n\",\n\t\t\t  iloc->partitionReferenceNum, sbi->s_partitions);\n\t\treturn -EIO;\n\t}\n\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%u, partition=%u out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t \n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %lu) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %lu) failed ident=%u\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %u\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse  \n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_SHORT &&\n\t    iinfo->i_alloc_type != ICBTAG_FLAG_AD_LONG &&\n\t    iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tiinfo->i_hidden = hidden_inode;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\tuid = le32_to_cpu(fe->uid);\n\tif (uid == UDF_INVALID_ID ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = sbi->s_uid;\n\telse\n\t\ti_uid_write(inode, uid);\n\n\tgid = le32_to_cpu(fe->gid);\n\tif (gid == UDF_INVALID_ID ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = sbi->s_gid;\n\telse\n\t\ti_gid_write(inode, gid);\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tiinfo->i_extraPerms = le32_to_cpu(fe->permissions) & ~FE_MAPPED_PERMS;\n\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tudf_disk_stamp_to_time(&inode->i_atime, fe->accessTime);\n\t\tudf_disk_stamp_to_time(&inode->i_mtime, fe->modificationTime);\n\t\tudf_disk_stamp_to_time(&ctime, fe->attrTime);\n\t\tinode_set_ctime_to_ts(inode, ctime);\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t\tiinfo->i_streamdir = 0;\n\t\tiinfo->i_lenStreams = 0;\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tudf_disk_stamp_to_time(&inode->i_atime, efe->accessTime);\n\t\tudf_disk_stamp_to_time(&inode->i_mtime, efe->modificationTime);\n\t\tudf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime);\n\t\tudf_disk_stamp_to_time(&ctime, efe->attrTime);\n\t\tinode_set_ctime_to_ts(inode, ctime);\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\n\t\t \n\t\tiinfo->i_streamdir = (efe->streamDirectoryICB.extLength != 0);\n\t\tiinfo->i_locStreamdir =\n\t\t\tlelb_to_cpu(efe->streamDirectoryICB.extLocation);\n\t\tiinfo->i_lenStreams = le64_to_cpu(efe->objectSize);\n\t\tif (iinfo->i_lenStreams >= inode->i_size)\n\t\t\tiinfo->i_lenStreams -= inode->i_size;\n\t\telse\n\t\t\tiinfo->i_lenStreams = 0;\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t \n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t \n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t \n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t \n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t \n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mode = S_IFLNK | 0777;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %lu) failed unknown file type=%u\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t \n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic int udf_alloc_i_data(struct inode *inode, size_t size)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tiinfo->i_data = kmalloc(size, GFP_KERNEL);\n\tif (!iinfo->i_data)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic umode_t udf_convert_permissions(struct fileEntry *fe)\n{\n\tumode_t mode;\n\tuint32_t permissions;\n\tuint32_t flags;\n\n\tpermissions = le32_to_cpu(fe->permissions);\n\tflags = le16_to_cpu(fe->icbTag.flags);\n\n\tmode =\t((permissions) & 0007) |\n\t\t((permissions >> 2) & 0070) |\n\t\t((permissions >> 4) & 0700) |\n\t\t((flags & ICBTAG_FLAG_SETUID) ? S_ISUID : 0) |\n\t\t((flags & ICBTAG_FLAG_SETGID) ? S_ISGID : 0) |\n\t\t((flags & ICBTAG_FLAG_STICKY) ? S_ISVTX : 0);\n\n\treturn mode;\n}\n\nvoid udf_update_extra_perms(struct inode *inode, umode_t mode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\t \n\tiinfo->i_extraPerms &= ~FE_DELETE_PERMS;\n\tif (mode & 0200)\n\t\tiinfo->i_extraPerms |= FE_PERM_U_DELETE;\n\tif (mode & 0020)\n\t\tiinfo->i_extraPerms |= FE_PERM_G_DELETE;\n\tif (mode & 0002)\n\t\tiinfo->i_extraPerms |= FE_PERM_O_DELETE;\n}\n\nint udf_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn udf_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}\n\nstatic int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}\n\nstatic void udf_adjust_time(struct udf_inode_info *iinfo, struct timespec64 time)\n{\n\tif (iinfo->i_crtime.tv_sec > time.tv_sec ||\n\t    (iinfo->i_crtime.tv_sec == time.tv_sec &&\n\t     iinfo->i_crtime.tv_nsec > time.tv_nsec))\n\t\tiinfo->i_crtime = time;\n}\n\nstatic int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = sb_getblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -EIO;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tcrclen = sizeof(struct unallocSpaceEntry);\n\n\t\tgoto finish;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(UDF_INVALID_ID);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(UDF_INVALID_ID);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & 0007)) |\n\t\t   ((inode->i_mode & 0070) << 2) |\n\t\t   ((inode->i_mode & 0700) << 4);\n\n\tudfperms |= iinfo->i_extraPerms;\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse {\n\t\tif (iinfo->i_hidden)\n\t\t\tfe->fileLinkCount = cpu_to_le16(0);\n\t\telse\n\t\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\t}\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(*eid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0;  \n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode_get_ctime(inode));\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize =\n\t\t\tcpu_to_le64(inode->i_size + iinfo->i_lenStreams);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_streamdir) {\n\t\t\tstruct long_ad *icb_lad = &efe->streamDirectoryICB;\n\n\t\t\ticb_lad->extLocation =\n\t\t\t\tcpu_to_lelb(iinfo->i_locStreamdir);\n\t\t\ticb_lad->extLength =\n\t\t\t\tcpu_to_le32(inode->i_sb->s_blocksize);\n\t\t}\n\n\t\tudf_adjust_time(iinfo, inode->i_atime);\n\t\tudf_adjust_time(iinfo, inode->i_mtime);\n\t\tudf_adjust_time(iinfo, inode_get_ctime(inode));\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode_get_ctime(inode));\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(efe->impIdent));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\nfinish:\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (iinfo->i_use)\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_USE;\n\telse if (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t \n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}\n\nstruct inode *__udf_iget(struct super_block *sb, struct kernel_lb_addr *ino,\n\t\t\t bool hidden_inode)\n{\n\tunsigned long block = udf_get_lb_pblock(sb, ino, 0);\n\tstruct inode *inode = iget_locked(sb, block);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\tif (UDF_I(inode)->i_hidden != hidden_inode) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\treturn inode;\n\t}\n\n\tmemcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));\n\terr = udf_read_inode(inode, hidden_inode);\n\tif (err < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n\nint udf_setup_indirect_aext(struct inode *inode, udf_pblk_t block,\n\t\t\t    struct extent_position *epos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh;\n\tstruct allocExtDesc *aed;\n\tstruct extent_position nepos;\n\tstruct kernel_lb_addr neloc;\n\tint ver, adsize;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tneloc.logicalBlockNum = block;\n\tneloc.partitionReferenceNum = epos->block.partitionReferenceNum;\n\n\tbh = sb_getblk(sb, udf_get_lb_pblock(sb, &neloc, 0));\n\tif (!bh)\n\t\treturn -EIO;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0x00, sb->s_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taed = (struct allocExtDesc *)(bh->b_data);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT)) {\n\t\taed->previousAllocExtLocation =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t}\n\taed->lengthAllocDescs = cpu_to_le32(0);\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tver = 3;\n\telse\n\t\tver = 2;\n\tudf_new_tag(bh->b_data, TAG_IDENT_AED, ver, 1, block,\n\t\t    sizeof(struct tag));\n\n\tnepos.block = neloc;\n\tnepos.offset = sizeof(struct allocExtDesc);\n\tnepos.bh = bh;\n\n\t \n\tif (epos->offset + adsize > sb->s_blocksize) {\n\t\tstruct kernel_lb_addr cp_loc;\n\t\tuint32_t cp_len;\n\t\tint cp_type;\n\n\t\tepos->offset -= adsize;\n\t\tcp_type = udf_current_aext(inode, epos, &cp_loc, &cp_len, 0);\n\t\tcp_len |= ((uint32_t)cp_type) << 30;\n\n\t\t__udf_add_aext(inode, &nepos, &cp_loc, cp_len, 1);\n\t\tudf_write_aext(inode, epos, &nepos.block,\n\t\t\t       sb->s_blocksize | EXT_NEXT_EXTENT_ALLOCDESCS, 0);\n\t} else {\n\t\t__udf_add_aext(inode, epos, &nepos.block,\n\t\t\t       sb->s_blocksize | EXT_NEXT_EXTENT_ALLOCDESCS, 0);\n\t}\n\n\tbrelse(epos->bh);\n\t*epos = nepos;\n\n\treturn 0;\n}\n\n \nint __udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t   struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct allocExtDesc *aed;\n\tint adsize;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (!epos->bh) {\n\t\tWARN_ON(iinfo->i_lenAlloc !=\n\t\t\tepos->offset - udf_file_entry_alloc_offset(inode));\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tWARN_ON(le32_to_cpu(aed->lengthAllocDescs) !=\n\t\t\tepos->offset - sizeof(struct allocExtDesc));\n\t\tWARN_ON(epos->offset + adsize > inode->i_sb->s_blocksize);\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}\n\n \nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > sb->s_blocksize) {\n\t\tint err;\n\t\tudf_pblk_t new_block;\n\n\t\tnew_block = udf_new_block(sb, NULL,\n\t\t\t\t\t  epos->block.partitionReferenceNum,\n\t\t\t\t\t  epos->block.logicalBlockNum, &err);\n\t\tif (!new_block)\n\t\t\treturn -ENOSPC;\n\n\t\terr = udf_setup_indirect_aext(inode, new_block, epos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn __udf_add_aext(inode, epos, eloc, elen, inc);\n}\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}\n\n \n#define UDF_MAX_INDIR_EXTS 16\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\tunsigned int indirections = 0;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDESCS >> 30)) {\n\t\tudf_pblk_t block;\n\n\t\tif (++indirections > UDF_MAX_INDIR_EXTS) {\n\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\"too many indirect extents in inode %lu\\n\",\n\t\t\t\tinode->i_ino);\n\t\t\treturn -1;\n\t\t}\n\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = sb_bread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %u failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}\n\nint8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %u unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}\n\nstatic int udf_insert_aext(struct inode *inode, struct extent_position epos,\n\t\t\t   struct kernel_lb_addr neloc, uint32_t nelen)\n{\n\tstruct kernel_lb_addr oeloc;\n\tuint32_t oelen;\n\tint8_t etype;\n\tint err;\n\n\tif (epos.bh)\n\t\tget_bh(epos.bh);\n\n\twhile ((etype = udf_next_aext(inode, &epos, &oeloc, &oelen, 0)) != -1) {\n\t\tudf_write_aext(inode, &epos, &neloc, nelen, 1);\n\t\tneloc = oeloc;\n\t\tnelen = (etype << 30) | oelen;\n\t}\n\terr = udf_add_aext(inode, &epos, &neloc, nelen, 1);\n\tbrelse(epos.bh);\n\n\treturn err;\n}\n\nint8_t udf_delete_aext(struct inode *inode, struct extent_position epos)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount = (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t \n\tudf_update_extent_cache(inode, lbcount - *elen, pos);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}