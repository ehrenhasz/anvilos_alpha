{
  "module_name": "symlink.c",
  "hash_id": "4fb4173c2b5efc221410acbd1b069187143bdef521c8d7113ea40e88b8bfccc5",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/symlink.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include \"udf_i.h\"\n\nstatic int udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t \n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\telen += sizeof(struct pathComponent);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t \n\t\t\tif (pc->lengthComponentIdent > 0) {\n\t\t\t\telen += pc->lengthComponentIdent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t \n\t\t\tbreak;\n\t\tcase 5:\n\t\t\telen += pc->lengthComponentIdent;\n\t\t\tif (elen > fromlen)\n\t\t\t\treturn -EIO;\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tif (comp_len < 0)\n\t\t\t\treturn comp_len;\n\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}\n\nstatic int udf_symlink_filler(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = 0;\n\tunsigned char *p = page_address(page);\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\t \n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unlock;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = udf_bread(inode, 0, 0, &err);\n\t\tif (!bh) {\n\t\t\tif (!err)\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out_err;\n\t\t}\n\t\tsymlink = bh->b_data;\n\t}\n\n\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nout_err:\n\tSetPageError(page);\nout_unlock:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic int udf_symlink_getattr(struct mnt_idmap *idmap,\n\t\t\t       const struct path *path, struct kstat *stat,\n\t\t\t       u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct page *page;\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tpage = read_mapping_page(inode->i_mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\t \n\tstat->size = strlen(page_address(page));\n\tput_page(page);\n\n\treturn 0;\n}\n\n \nconst struct address_space_operations udf_symlink_aops = {\n\t.read_folio\t\t= udf_symlink_filler,\n};\n\nconst struct inode_operations udf_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.getattr\t= udf_symlink_getattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}