{
  "module_name": "super.c",
  "hash_id": "9174726691f8de6333670d06626b7601016f9ea652e2a4d85b3c1f7856228434",
  "original_prompt": "Ingested from linux-6.6.14/fs/udf/super.c",
  "human_readable_source": "\n \n\n#include \"udfdecl.h\"\n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/stat.h>\n#include <linux/cdrom.h>\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/bitmap.h>\n#include <linux/crc-itu-t.h>\n#include <linux/log2.h>\n#include <asm/byteorder.h>\n#include <linux/iversion.h>\n\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n\n#include <linux/init.h>\n#include <linux/uaccess.h>\n\nenum {\n\tVDS_POS_PRIMARY_VOL_DESC,\n\tVDS_POS_UNALLOC_SPACE_DESC,\n\tVDS_POS_LOGICAL_VOL_DESC,\n\tVDS_POS_IMP_USE_VOL_DESC,\n\tVDS_POS_LENGTH\n};\n\n#define VSD_FIRST_SECTOR_OFFSET\t\t32768\n#define VSD_MAX_SECTOR_OFFSET\t\t0x800000\n\n \n#define UDF_MAX_TD_NESTING 64\n#define UDF_MAX_LVID_NESTING 1000\n\nenum { UDF_MAX_LINKS = 0xffff };\n \n#define UDF_MAX_FILESIZE (1ULL << 42)\n\n \nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_load_logicalvolint(struct super_block *, struct kernel_extent_ad);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\nstatic int udf_statfs(struct dentry *, struct kstatfs *);\nstatic int udf_show_options(struct seq_file *, struct dentry *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\t \n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)\n\t\t\t\t\t(((uint8_t *)(lvid + 1)) + offset);\n}\n\n \nstatic struct dentry *udf_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, udf_fill_super);\n}\n\nstatic struct file_system_type udf_fstype = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"udf\",\n\t.mount\t\t= udf_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"udf\");\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic struct inode *udf_alloc_inode(struct super_block *sb)\n{\n\tstruct udf_inode_info *ei;\n\tei = alloc_inode_sb(sb, udf_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->i_unique = 0;\n\tei->i_lenExtents = 0;\n\tei->i_lenStreams = 0;\n\tei->i_next_alloc_block = 0;\n\tei->i_next_alloc_goal = 0;\n\tei->i_strat4096 = 0;\n\tei->i_streamdir = 0;\n\tei->i_hidden = 0;\n\tinit_rwsem(&ei->i_data_sem);\n\tei->cached_extent.lstart = -1;\n\tspin_lock_init(&ei->i_extent_cache_lock);\n\tinode_set_iversion(&ei->vfs_inode, 1);\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void udf_free_in_core_inode(struct inode *inode)\n{\n\tkmem_cache_free(udf_inode_cachep, UDF_I(inode));\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct udf_inode_info *ei = foo;\n\n\tei->i_data = NULL;\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tudf_inode_cachep = kmem_cache_create(\"udf_inode_cache\",\n\t\t\t\t\t     sizeof(struct udf_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD |\n\t\t\t\t\t\t SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (!udf_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}\n\n \nstatic const struct super_operations udf_sb_ops = {\n\t.alloc_inode\t= udf_alloc_inode,\n\t.free_inode\t= udf_free_in_core_inode,\n\t.write_inode\t= udf_write_inode,\n\t.evict_inode\t= udf_evict_inode,\n\t.put_super\t= udf_put_super,\n\t.sync_fs\t= udf_sync_fs,\n\t.statfs\t\t= udf_statfs,\n\t.remount_fs\t= udf_remount_fs,\n\t.show_options\t= udf_show_options,\n};\n\nstruct udf_options {\n\tunsigned char novrs;\n\tunsigned int blocksize;\n\tunsigned int session;\n\tunsigned int lastblock;\n\tunsigned int anchor;\n\tunsigned int flags;\n\tumode_t umask;\n\tkgid_t gid;\n\tkuid_t uid;\n\tumode_t fmode;\n\tumode_t dmode;\n\tstruct nls_table *nls_map;\n};\n\nstatic int __init init_udf_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&udf_fstype);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tdestroy_inodecache();\n\nout1:\n\treturn err;\n}\n\nstatic void __exit exit_udf_fs(void)\n{\n\tunregister_filesystem(&udf_fstype);\n\tdestroy_inodecache();\n}\n\nstatic int udf_sb_alloc_partition_maps(struct super_block *sb, u32 count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tsbi->s_partmaps = kcalloc(count, sizeof(*sbi->s_partmaps), GFP_KERNEL);\n\tif (!sbi->s_partmaps) {\n\t\tsbi->s_partitions = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->s_partitions = count;\n\treturn 0;\n}\n\nstatic void udf_sb_free_bitmap(struct udf_bitmap *bitmap)\n{\n\tint i;\n\tint nr_groups = bitmap->s_nr_groups;\n\n\tfor (i = 0; i < nr_groups; i++)\n\t\tbrelse(bitmap->s_block_bitmap[i]);\n\n\tkvfree(bitmap);\n}\n\nstatic void udf_free_partition(struct udf_part_map *map)\n{\n\tint i;\n\tstruct udf_meta_data *mdata;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tiput(map->s_uspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_uspace.s_bitmap);\n\tif (map->s_partition_type == UDF_SPARABLE_MAP15)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbrelse(map->s_type_specific.s_sparing.s_spar_map[i]);\n\telse if (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tmdata = &map->s_type_specific.s_metadata;\n\t\tiput(mdata->s_metadata_fe);\n\t\tmdata->s_metadata_fe = NULL;\n\n\t\tiput(mdata->s_mirror_fe);\n\t\tmdata->s_mirror_fe = NULL;\n\n\t\tiput(mdata->s_bitmap_fe);\n\t\tmdata->s_bitmap_fe = NULL;\n\t}\n}\n\nstatic void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\n\tif (!sbi->s_partmaps)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}\n\nstatic int udf_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT))\n\t\tseq_puts(seq, \",nostrict\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_BLOCKSIZE_SET))\n\t\tseq_printf(seq, \",bs=%lu\", sb->s_blocksize);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\tseq_puts(seq, \",unhide\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\tseq_puts(seq, \",undelete\");\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tseq_puts(seq, \",noadinicb\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_USE_SHORT_AD))\n\t\tseq_puts(seq, \",shortad\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_FORGET))\n\t\tseq_puts(seq, \",uid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_FORGET))\n\t\tseq_puts(seq, \",gid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_SET))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid(&init_user_ns, sbi->s_uid));\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_SET))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid(&init_user_ns, sbi->s_gid));\n\tif (sbi->s_umask != 0)\n\t\tseq_printf(seq, \",umask=%ho\", sbi->s_umask);\n\tif (sbi->s_fmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",mode=%ho\", sbi->s_fmode);\n\tif (sbi->s_dmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",dmode=%ho\", sbi->s_dmode);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_SESSION_SET))\n\t\tseq_printf(seq, \",session=%d\", sbi->s_session);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_LASTBLOCK_SET))\n\t\tseq_printf(seq, \",lastblock=%u\", sbi->s_last_block);\n\tif (sbi->s_anchor != 0)\n\t\tseq_printf(seq, \",anchor=%u\", sbi->s_anchor);\n\tif (sbi->s_nls_map)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->s_nls_map->charset);\n\telse\n\t\tseq_puts(seq, \",iocharset=utf8\");\n\n\treturn 0;\n}\n\n \n\nenum {\n\tOpt_novrs, Opt_nostrict, Opt_bs, Opt_unhide, Opt_undelete,\n\tOpt_noadinicb, Opt_adinicb, Opt_shortad, Opt_longad,\n\tOpt_gid, Opt_uid, Opt_umask, Opt_session, Opt_lastblock,\n\tOpt_anchor, Opt_volume, Opt_partition, Opt_fileset,\n\tOpt_rootdir, Opt_utf8, Opt_iocharset,\n\tOpt_err, Opt_uforget, Opt_uignore, Opt_gforget, Opt_gignore,\n\tOpt_fmode, Opt_dmode\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};\n\nstatic int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\tunsigned int uv;\n\n\tuopt->novrs = 0;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_uint(args, &uv))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), uv);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_uint(args, &uv))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), uv);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\tcase Opt_partition:\n\t\tcase Opt_fileset:\n\t\tcase Opt_rootdir:\n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tif (!remount) {\n\t\t\t\tunload_nls(uopt->nls_map);\n\t\t\t\tuopt->nls_map = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tif (!remount) {\n\t\t\t\tunload_nls(uopt->nls_map);\n\t\t\t\tuopt->nls_map = NULL;\n\t\t\t}\n\t\t\t \n\t\t\tif (!remount && strcmp(args[0].from, \"utf8\") != 0) {\n\t\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\t\tif (!uopt->nls_map) {\n\t\t\t\t\tpr_err(\"iocharset %s not found\\n\",\n\t\t\t\t\t\targs[0].from);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_uignore:\n\t\tcase Opt_gignore:\n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int udf_remount_fs(struct super_block *sb, int *flags, char *options)\n{\n\tstruct udf_options uopt;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint error = 0;\n\n\tif (!(*flags & SB_RDONLY) && UDF_QUERY_FLAG(sb, UDF_FLAG_RW_INCOMPAT))\n\t\treturn -EACCES;\n\n\tsync_filesystem(sb);\n\n\tuopt.flags = sbi->s_flags;\n\tuopt.uid   = sbi->s_uid;\n\tuopt.gid   = sbi->s_gid;\n\tuopt.umask = sbi->s_umask;\n\tuopt.fmode = sbi->s_fmode;\n\tuopt.dmode = sbi->s_dmode;\n\tuopt.nls_map = NULL;\n\n\tif (!udf_parse_options(options, &uopt, true))\n\t\treturn -EINVAL;\n\n\twrite_lock(&sbi->s_cred_lock);\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid   = uopt.uid;\n\tsbi->s_gid   = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\twrite_unlock(&sbi->s_cred_lock);\n\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\tgoto out_unlock;\n\n\tif (*flags & SB_RDONLY)\n\t\tudf_close_lvid(sb);\n\telse\n\t\tudf_open_lvid(sb);\n\nout_unlock:\n\treturn error;\n}\n\n \nstatic int identify_vsd(const struct volStructDesc *vsd)\n{\n\tint ret = 0;\n\n\tif (!memcmp(vsd->stdIdent, VSD_STD_ID_CD001, VSD_STD_ID_LEN)) {\n\t\tswitch (vsd->structType) {\n\t\tcase 0:\n\t\t\tudf_debug(\"ISO9660 Boot Record found\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tudf_debug(\"ISO9660 Primary Volume Descriptor found\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tudf_debug(\"ISO9660 Supplementary Volume Descriptor found\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tudf_debug(\"ISO9660 Volume Partition Descriptor found\\n\");\n\t\t\tbreak;\n\t\tcase 255:\n\t\t\tudf_debug(\"ISO9660 Volume Descriptor Set Terminator found\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tudf_debug(\"ISO9660 VRS (%u) found\\n\", vsd->structType);\n\t\t\tbreak;\n\t\t}\n\t} else if (!memcmp(vsd->stdIdent, VSD_STD_ID_BEA01, VSD_STD_ID_LEN))\n\t\t;  \n\telse if (!memcmp(vsd->stdIdent, VSD_STD_ID_NSR02, VSD_STD_ID_LEN))\n\t\tret = 1;\n\telse if (!memcmp(vsd->stdIdent, VSD_STD_ID_NSR03, VSD_STD_ID_LEN))\n\t\tret = 1;\n\telse if (!memcmp(vsd->stdIdent, VSD_STD_ID_BOOT2, VSD_STD_ID_LEN))\n\t\t;  \n\telse if (!memcmp(vsd->stdIdent, VSD_STD_ID_CDW02, VSD_STD_ID_LEN))\n\t\t;  \n\telse {\n\t\t \n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int udf_check_vsd(struct super_block *sb)\n{\n\tstruct volStructDesc *vsd = NULL;\n\tloff_t sector = VSD_FIRST_SECTOR_OFFSET;\n\tint sectorsize;\n\tstruct buffer_head *bh = NULL;\n\tint nsr = 0;\n\tstruct udf_sb_info *sbi;\n\tloff_t session_offset;\n\n\tsbi = UDF_SB(sb);\n\tif (sb->s_blocksize < sizeof(struct volStructDesc))\n\t\tsectorsize = sizeof(struct volStructDesc);\n\telse\n\t\tsectorsize = sb->s_blocksize;\n\n\tsession_offset = (loff_t)sbi->s_session << sb->s_blocksize_bits;\n\tsector += session_offset;\n\n\tudf_debug(\"Starting at sector %u (%lu byte sectors)\\n\",\n\t\t  (unsigned int)(sector >> sb->s_blocksize_bits),\n\t\t  sb->s_blocksize);\n\t \n\tfor (; !nsr && sector < VSD_MAX_SECTOR_OFFSET; sector += sectorsize) {\n\t\t \n\t\tbh = sb_bread(sb, sector >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\tvsd = (struct volStructDesc *)(bh->b_data +\n\t\t\t\t\t      (sector & (sb->s_blocksize - 1)));\n\t\tnsr = identify_vsd(vsd);\n\t\t \n\t\tif (nsr) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sb->s_blocksize == 4096) {\n\t\t\tnsr = identify_vsd(vsd + 1);\n\t\t\t \n\t\t\tif (nsr < 0)\n\t\t\t\tnsr = 0;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tif (nsr > 0)\n\t\treturn 1;\n\telse if (!bh && sector - session_offset == VSD_FIRST_SECTOR_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nstatic int udf_verify_domain_identifier(struct super_block *sb,\n\t\t\t\t\tstruct regid *ident, char *dname)\n{\n\tstruct domainIdentSuffix *suffix;\n\n\tif (memcmp(ident->ident, UDF_ID_COMPLIANT, strlen(UDF_ID_COMPLIANT))) {\n\t\tudf_warn(sb, \"Not OSTA UDF compliant %s descriptor.\\n\", dname);\n\t\tgoto force_ro;\n\t}\n\tif (ident->flags & ENTITYID_FLAGS_DIRTY) {\n\t\tudf_warn(sb, \"Possibly not OSTA UDF compliant %s descriptor.\\n\",\n\t\t\t dname);\n\t\tgoto force_ro;\n\t}\n\tsuffix = (struct domainIdentSuffix *)ident->identSuffix;\n\tif ((suffix->domainFlags & DOMAIN_FLAGS_HARD_WRITE_PROTECT) ||\n\t    (suffix->domainFlags & DOMAIN_FLAGS_SOFT_WRITE_PROTECT)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tudf_warn(sb, \"Descriptor for %s marked write protected.\"\n\t\t\t\t \" Forcing read only mount.\\n\", dname);\n\t\t}\n\t\tgoto force_ro;\n\t}\n\treturn 0;\n\nforce_ro:\n\tif (!sb_rdonly(sb))\n\t\treturn -EACCES;\n\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\treturn 0;\n}\n\nstatic int udf_load_fileset(struct super_block *sb, struct fileSetDesc *fset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tint ret;\n\n\tret = udf_verify_domain_identifier(sb, &fset->domainIdent, \"file set\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*root = lelb_to_cpu(fset->rootDirectoryICB.extLocation);\n\tUDF_SB(sb)->s_serial_number = le16_to_cpu(fset->descTag.tagSerialNum);\n\n\tudf_debug(\"Rootdir at block=%u, partition=%u\\n\",\n\t\t  root->logicalBlockNum, root->partitionReferenceNum);\n\treturn 0;\n}\n\nstatic int udf_find_fileset(struct super_block *sb,\n\t\t\t    struct kernel_lb_addr *fileset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tif (fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t    fileset->partitionReferenceNum == 0xFFFF)\n\t\treturn -EINVAL;\n\n\tbh = udf_read_ptagged(sb, fileset, 0, &ident);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (ident != TAG_IDENT_FSD) {\n\t\tbrelse(bh);\n\t\treturn -EINVAL;\n\t}\n\n\tudf_debug(\"Fileset at block=%u, partition=%u\\n\",\n\t\t  fileset->logicalBlockNum, fileset->partitionReferenceNum);\n\n\tUDF_SB(sb)->s_partition = fileset->partitionReferenceNum;\n\tret = udf_load_fileset(sb, (struct fileSetDesc *)bh->b_data, root);\n\tbrelse(bh);\n\treturn ret;\n}\n\n \nstatic int udf_load_pvoldesc(struct super_block *sb, sector_t block)\n{\n\tstruct primaryVolDesc *pvoldesc;\n\tuint8_t *outstr;\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\tstruct timestamp *ts;\n\n\toutstr = kmalloc(128, GFP_NOFS);\n\tif (!outstr)\n\t\treturn -ENOMEM;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh) {\n\t\tret = -EAGAIN;\n\t\tgoto out2;\n\t}\n\n\tif (ident != TAG_IDENT_PVD) {\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tpvoldesc = (struct primaryVolDesc *)bh->b_data;\n\n\tudf_disk_stamp_to_time(&UDF_SB(sb)->s_record_time,\n\t\t\t      pvoldesc->recordingDateAndTime);\n\tts = &pvoldesc->recordingDateAndTime;\n\tudf_debug(\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t  le16_to_cpu(ts->year), ts->month, ts->day, ts->hour,\n\t\t  ts->minute, le16_to_cpu(ts->typeAndTimezone));\n\n\tret = udf_dstrCS0toChar(sb, outstr, 31, pvoldesc->volIdent, 32);\n\tif (ret < 0) {\n\t\tstrcpy(UDF_SB(sb)->s_volume_ident, \"InvalidName\");\n\t\tpr_warn(\"incorrect volume identification, setting to \"\n\t\t\t\"'InvalidName'\\n\");\n\t} else {\n\t\tstrncpy(UDF_SB(sb)->s_volume_ident, outstr, ret);\n\t}\n\tudf_debug(\"volIdent[] = '%s'\\n\", UDF_SB(sb)->s_volume_ident);\n\n\tret = udf_dstrCS0toChar(sb, outstr, 127, pvoldesc->volSetIdent, 128);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\toutstr[ret] = 0;\n\tudf_debug(\"volSetIdent[] = '%s'\\n\", outstr);\n\n\tret = 0;\nout_bh:\n\tbrelse(bh);\nout2:\n\tkfree(outstr);\n\treturn ret;\n}\n\nstruct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_ref)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_ref;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}\n\nstatic int udf_load_metadata_files(struct super_block *sb, int partition,\n\t\t\t\t   int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tstruct kernel_lb_addr addr;\n\tstruct inode *fe;\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tmdata->s_phys_partition_ref = type1_index;\n\n\t \n\tudf_debug(\"Metadata file location: block = %u part = %u\\n\",\n\t\t  mdata->s_meta_file_loc, mdata->s_phys_partition_ref);\n\n\tfe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,\n\t\t\t\t\t mdata->s_phys_partition_ref);\n\tif (IS_ERR(fe)) {\n\t\t \n\t\tudf_debug(\"Mirror metadata file location: block = %u part = %u\\n\",\n\t\t\t  mdata->s_mirror_file_loc, mdata->s_phys_partition_ref);\n\n\t\tfe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,\n\t\t\t\t\t\t mdata->s_phys_partition_ref);\n\n\t\tif (IS_ERR(fe)) {\n\t\t\tudf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");\n\t\t\treturn PTR_ERR(fe);\n\t\t}\n\t\tmdata->s_mirror_fe = fe;\n\t} else\n\t\tmdata->s_metadata_fe = fe;\n\n\n\t \n\tif (mdata->s_bitmap_file_loc != 0xFFFFFFFF) {\n\t\taddr.logicalBlockNum = mdata->s_bitmap_file_loc;\n\t\taddr.partitionReferenceNum = mdata->s_phys_partition_ref;\n\n\t\tudf_debug(\"Bitmap file location: block = %u part = %u\\n\",\n\t\t\t  addr.logicalBlockNum, addr.partitionReferenceNum);\n\n\t\tfe = udf_iget_special(sb, &addr);\n\t\tif (IS_ERR(fe)) {\n\t\t\tif (sb_rdonly(sb))\n\t\t\t\tudf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tudf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");\n\t\t\t\treturn PTR_ERR(fe);\n\t\t\t}\n\t\t} else\n\t\t\tmdata->s_bitmap_fe = fe;\n\t}\n\n\tudf_debug(\"udf_load_metadata_files Ok\\n\");\n\treturn 0;\n}\n\nint udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}\n\nstatic struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)\n{\n\tstruct udf_bitmap *bitmap;\n\tint nr_groups = udf_compute_nr_groups(sb, index);\n\n\tbitmap = kvzalloc(struct_size(bitmap, s_block_bitmap, nr_groups),\n\t\t\t  GFP_KERNEL);\n\tif (!bitmap)\n\t\treturn NULL;\n\n\tbitmap->s_nr_groups = nr_groups;\n\treturn bitmap;\n}\n\nstatic int check_partition_desc(struct super_block *sb,\n\t\t\t\tstruct partitionDesc *p,\n\t\t\t\tstruct udf_part_map *map)\n{\n\tbool umap, utable, fmap, ftable;\n\tstruct partitionHeaderDesc *phd;\n\n\tswitch (le32_to_cpu(p->accessType)) {\n\tcase PD_ACCESS_TYPE_READ_ONLY:\n\tcase PD_ACCESS_TYPE_WRITE_ONCE:\n\tcase PD_ACCESS_TYPE_NONE:\n\t\tgoto force_ro;\n\t}\n\n\t \n\tif (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&\n\t    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))\n\t\tgoto force_ro;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tutable = phd->unallocSpaceTable.extLength;\n\tumap = phd->unallocSpaceBitmap.extLength;\n\tftable = phd->freedSpaceTable.extLength;\n\tfmap = phd->freedSpaceBitmap.extLength;\n\n\t \n\tif (!utable && !umap && !ftable && !fmap)\n\t\tgoto force_ro;\n\n\t \n\tif (ftable || fmap)\n\t\tgoto force_ro;\n\t \n\tif (utable && umap)\n\t\tgoto force_ro;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t    map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t    map->s_partition_type == UDF_METADATA_MAP25)\n\t\tgoto force_ro;\n\n\treturn 0;\nforce_ro:\n\tif (!sb_rdonly(sb))\n\t\treturn -EACCES;\n\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\treturn 0;\n}\n\nstatic int udf_fill_partdesc_info(struct super_block *sb,\n\t\tstruct partitionDesc *p, int p_index)\n{\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct partitionHeaderDesc *phd;\n\tint err;\n\n\tmap = &sbi->s_partmaps[p_index];\n\n\tmap->s_partition_len = le32_to_cpu(p->partitionLength);  \n\tmap->s_partition_root = le32_to_cpu(p->partitionStartingLocation);\n\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_READ_ONLY))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_READ_ONLY;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_WRITE_ONCE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_WRITE_ONCE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_REWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_REWRITABLE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_OVERWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;\n\n\tudf_debug(\"Partition (%d type %x) starts at physical %u, block length %u\\n\",\n\t\t  p_index, map->s_partition_type,\n\t\t  map->s_partition_root, map->s_partition_len);\n\n\terr = check_partition_desc(sb, p, map);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_RW_INCOMPAT))\n\t\treturn 0;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tif (phd->unallocSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_uspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;\n\t\tudf_debug(\"unallocSpaceTable (part %d) @ %lu\\n\",\n\t\t\t  p_index, map->s_uspace.s_table->i_ino);\n\t}\n\n\tif (phd->unallocSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_uspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;\n\t\tudf_debug(\"unallocSpaceBitmap (part %d) @ %u\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\n\treturn 0;\n}\n\nstatic void udf_find_vat_block(struct super_block *sb, int p_index,\n\t\t\t       int type1_index, sector_t start_block)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tsector_t vat_block;\n\tstruct kernel_lb_addr ino;\n\tstruct inode *inode;\n\n\t \n\tino.partitionReferenceNum = type1_index;\n\tfor (vat_block = start_block;\n\t     vat_block >= map->s_partition_root &&\n\t     vat_block >= start_block - 3; vat_block--) {\n\t\tino.logicalBlockNum = vat_block - map->s_partition_root;\n\t\tinode = udf_iget_special(sb, &ino);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tsbi->s_vat_inode = inode;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int udf_load_vat(struct super_block *sb, int p_index, int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_inode_info *vati;\n\tstruct virtualAllocationTable20 *vat20;\n\tsector_t blocks = sb_bdev_nr_blocks(sb);\n\n\tudf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);\n\tif (!sbi->s_vat_inode &&\n\t    sbi->s_last_block != blocks - 1) {\n\t\tpr_notice(\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\",\n\t\t\t  (unsigned long)sbi->s_last_block,\n\t\t\t  (unsigned long)blocks - 1);\n\t\tudf_find_vat_block(sb, p_index, type1_index, blocks - 1);\n\t}\n\tif (!sbi->s_vat_inode)\n\t\treturn -EIO;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15) {\n\t\tmap->s_type_specific.s_virtual.s_start_offset = 0;\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size - 36) >> 2;\n\t} else if (map->s_partition_type == UDF_VIRTUAL_MAP20) {\n\t\tvati = UDF_I(sbi->s_vat_inode);\n\t\tif (vati->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tint err = 0;\n\n\t\t\tbh = udf_bread(sbi->s_vat_inode, 0, 0, &err);\n\t\t\tif (!bh) {\n\t\t\t\tif (!err)\n\t\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tvat20 = (struct virtualAllocationTable20 *)bh->b_data;\n\t\t} else {\n\t\t\tvat20 = (struct virtualAllocationTable20 *)\n\t\t\t\t\t\t\tvati->i_data;\n\t\t}\n\n\t\tmap->s_type_specific.s_virtual.s_start_offset =\n\t\t\tle16_to_cpu(vat20->lengthHeader);\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size -\n\t\t\t\tmap->s_type_specific.s_virtual.\n\t\t\t\t\ts_start_offset) >> 2;\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}\n\n \nstatic int udf_load_partdesc(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh;\n\tstruct partitionDesc *p;\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i, type1_idx;\n\tuint16_t partitionNumber;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_PD) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tp = (struct partitionDesc *)bh->b_data;\n\tpartitionNumber = le16_to_cpu(p->partitionNumber);\n\n\t \n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\t\tudf_debug(\"Searching map: (%u == %u)\\n\",\n\t\t\t  map->s_partition_num, partitionNumber);\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_TYPE1_MAP15 ||\n\t\t     map->s_partition_type == UDF_SPARABLE_MAP15))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tudf_debug(\"Partition (%u) not found in partition map\\n\",\n\t\t\t  partitionNumber);\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\t \n\ttype1_idx = i;\n\tmap = NULL;  \n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t\t     map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t\t     map->s_partition_type == UDF_METADATA_MAP25))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\tif (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tret = udf_load_metadata_files(sb, i, type1_idx);\n\t\tif (ret < 0) {\n\t\t\tudf_err(sb, \"error loading MetaData partition map %d\\n\",\n\t\t\t\ti);\n\t\t\tgoto out_bh;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!sb_rdonly(sb)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out_bh;\n\t\t}\n\t\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\t\tret = udf_load_vat(sb, i, type1_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out_bh;\n\t}\n\tret = 0;\nout_bh:\n\t \n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\tif (le32_to_cpu(spm->sizeSparingTable) > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too big sparing table size (%u)\\n\",\n\t\t\tle32_to_cpu(spm->sizeSparingTable));\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}\n\nstatic int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (table_len > sb->s_blocksize - sizeof(*lvd)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_verify_domain_identifier(sb, &lvd->domainIdent,\n\t\t\t\t\t   \"logical volume\");\n\tif (ret)\n\t\tgoto out_bh;\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tret = udf_load_sparable_map(sb, map,\n\t\t\t\t\t(struct sparablePartitionMap *)gpm);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %u  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%u\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%u\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%u\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%u\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%u\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %u\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%u) type %u on volume %u\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%u, partition=%u\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\tret = 0;\n\n\tif (!sbi->s_lvid_bh) {\n\t\t \n\t\tif (sb_rdonly(sb)) {\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\t\t} else {\n\t\t\tudf_warn(sb, \"Damaged or missing LVID, forcing \"\n\t\t\t\t     \"readonly mount\\n\");\n\t\t\tret = -EACCES;\n\t\t}\n\t}\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}\n\n \nstatic void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh, *final_bh;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tint indirections = 0;\n\tu32 parts, impuselen;\n\n\twhile (++indirections <= UDF_MAX_LVID_NESTING) {\n\t\tfinal_bh = NULL;\n\t\twhile (loc.extLength > 0 &&\n\t\t\t(bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t\tloc.extLocation, &ident))) {\n\t\t\tif (ident != TAG_IDENT_LVID) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(final_bh);\n\t\t\tfinal_bh = bh;\n\n\t\t\tloc.extLength -= sb->s_blocksize;\n\t\t\tloc.extLocation++;\n\t\t}\n\n\t\tif (!final_bh)\n\t\t\treturn;\n\n\t\tbrelse(sbi->s_lvid_bh);\n\t\tsbi->s_lvid_bh = final_bh;\n\n\t\tlvid = (struct logicalVolIntegrityDesc *)final_bh->b_data;\n\t\tif (lvid->nextIntegrityExt.extLength == 0)\n\t\t\tgoto check;\n\n\t\tloc = leea_to_cpu(lvid->nextIntegrityExt);\n\t}\n\n\tudf_warn(sb, \"Too many LVID indirections (max %u), ignoring.\\n\",\n\t\tUDF_MAX_LVID_NESTING);\nout_err:\n\tbrelse(sbi->s_lvid_bh);\n\tsbi->s_lvid_bh = NULL;\n\treturn;\ncheck:\n\tparts = le32_to_cpu(lvid->numOfPartitions);\n\timpuselen = le32_to_cpu(lvid->lengthOfImpUse);\n\tif (parts >= sb->s_blocksize || impuselen >= sb->s_blocksize ||\n\t    sizeof(struct logicalVolIntegrityDesc) + impuselen +\n\t    2 * parts * sizeof(u32) > sb->s_blocksize) {\n\t\tudf_warn(sb, \"Corrupted LVID (parts=%u, impuselen=%u), \"\n\t\t\t \"ignoring.\\n\", parts, impuselen);\n\t\tgoto out_err;\n\t}\n}\n\n \n#define PART_DESC_ALLOC_STEP 32\n\nstruct part_desc_seq_scan_data {\n\tstruct udf_vds_record rec;\n\tu32 partnum;\n};\n\nstruct desc_seq_scan_data {\n\tstruct udf_vds_record vds[VDS_POS_LENGTH];\n\tunsigned int size_part_descs;\n\tunsigned int num_part_descs;\n\tstruct part_desc_seq_scan_data *part_descs_loc;\n};\n\nstatic struct udf_vds_record *handle_partition_descriptor(\n\t\t\t\tstruct buffer_head *bh,\n\t\t\t\tstruct desc_seq_scan_data *data)\n{\n\tstruct partitionDesc *desc = (struct partitionDesc *)bh->b_data;\n\tint partnum;\n\tint i;\n\n\tpartnum = le16_to_cpu(desc->partitionNumber);\n\tfor (i = 0; i < data->num_part_descs; i++)\n\t\tif (partnum == data->part_descs_loc[i].partnum)\n\t\t\treturn &(data->part_descs_loc[i].rec);\n\tif (data->num_part_descs >= data->size_part_descs) {\n\t\tstruct part_desc_seq_scan_data *new_loc;\n\t\tunsigned int new_size = ALIGN(partnum, PART_DESC_ALLOC_STEP);\n\n\t\tnew_loc = kcalloc(new_size, sizeof(*new_loc), GFP_KERNEL);\n\t\tif (!new_loc)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tmemcpy(new_loc, data->part_descs_loc,\n\t\t       data->size_part_descs * sizeof(*new_loc));\n\t\tkfree(data->part_descs_loc);\n\t\tdata->part_descs_loc = new_loc;\n\t\tdata->size_part_descs = new_size;\n\t}\n\treturn &(data->part_descs_loc[data->num_part_descs++].rec);\n}\n\n\nstatic struct udf_vds_record *get_volume_descriptor_record(uint16_t ident,\n\t\tstruct buffer_head *bh, struct desc_seq_scan_data *data)\n{\n\tswitch (ident) {\n\tcase TAG_IDENT_PVD:  \n\t\treturn &(data->vds[VDS_POS_PRIMARY_VOL_DESC]);\n\tcase TAG_IDENT_IUVD:  \n\t\treturn &(data->vds[VDS_POS_IMP_USE_VOL_DESC]);\n\tcase TAG_IDENT_LVD:  \n\t\treturn &(data->vds[VDS_POS_LOGICAL_VOL_DESC]);\n\tcase TAG_IDENT_USD:  \n\t\treturn &(data->vds[VDS_POS_UNALLOC_SPACE_DESC]);\n\tcase TAG_IDENT_PD:  \n\t\treturn handle_partition_descriptor(bh, data);\n\t}\n\treturn NULL;\n}\n\n \nstatic noinline int udf_process_sequence(\n\t\tstruct super_block *sb,\n\t\tsector_t block, sector_t lastblock,\n\t\tstruct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_vds_record *curr;\n\tstruct generic_desc *gd;\n\tstruct volDescPtr *vdp;\n\tbool done = false;\n\tuint32_t vdsn;\n\tuint16_t ident;\n\tint ret;\n\tunsigned int indirections = 0;\n\tstruct desc_seq_scan_data data;\n\tunsigned int i;\n\n\tmemset(data.vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);\n\tdata.size_part_descs = PART_DESC_ALLOC_STEP;\n\tdata.num_part_descs = 0;\n\tdata.part_descs_loc = kcalloc(data.size_part_descs,\n\t\t\t\t      sizeof(*data.part_descs_loc),\n\t\t\t\t      GFP_KERNEL);\n\tif (!data.part_descs_loc)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (; (!done && block <= lastblock); block++) {\n\t\tbh = udf_read_tagged(sb, block, block, &ident);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\t \n\t\tgd = (struct generic_desc *)bh->b_data;\n\t\tvdsn = le32_to_cpu(gd->volDescSeqNum);\n\t\tswitch (ident) {\n\t\tcase TAG_IDENT_VDP:  \n\t\t\tif (++indirections > UDF_MAX_TD_NESTING) {\n\t\t\t\tudf_err(sb, \"too many Volume Descriptor \"\n\t\t\t\t\t\"Pointers (max %u supported)\\n\",\n\t\t\t\t\tUDF_MAX_TD_NESTING);\n\t\t\t\tbrelse(bh);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvdp = (struct volDescPtr *)bh->b_data;\n\t\t\tblock = le32_to_cpu(vdp->nextVolDescSeqExt.extLocation);\n\t\t\tlastblock = le32_to_cpu(\n\t\t\t\tvdp->nextVolDescSeqExt.extLength) >>\n\t\t\t\tsb->s_blocksize_bits;\n\t\t\tlastblock += block - 1;\n\t\t\t \n\t\t\tblock--;\n\t\t\tbreak;\n\t\tcase TAG_IDENT_PVD:  \n\t\tcase TAG_IDENT_IUVD:  \n\t\tcase TAG_IDENT_LVD:  \n\t\tcase TAG_IDENT_USD:  \n\t\tcase TAG_IDENT_PD:  \n\t\t\tcurr = get_volume_descriptor_record(ident, bh, &data);\n\t\t\tif (IS_ERR(curr)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tret = PTR_ERR(curr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (!curr)\n\t\t\t\tbreak;\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_TD:  \n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t \n\tif (!data.vds[VDS_POS_PRIMARY_VOL_DESC].block) {\n\t\tudf_err(sb, \"Primary Volume Descriptor not found!\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tret = udf_load_pvoldesc(sb, data.vds[VDS_POS_PRIMARY_VOL_DESC].block);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (data.vds[VDS_POS_LOGICAL_VOL_DESC].block) {\n\t\tret = udf_load_logicalvol(sb,\n\t\t\t\tdata.vds[VDS_POS_LOGICAL_VOL_DESC].block,\n\t\t\t\tfileset);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < data.num_part_descs; i++) {\n\t\tret = udf_load_partdesc(sb, data.part_descs_loc[i].rec.block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tkfree(data.part_descs_loc);\n\treturn ret;\n}\n\n \nstatic int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tsector_t main_s, main_e, reserve_s, reserve_e;\n\tint ret;\n\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\n\t \n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s - 1;\n\n\t \n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s - 1;\n\n\t \n\t \n\tret = udf_process_sequence(sb, main_s, main_e, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\tudf_sb_free_partitions(sb);\n\tret = udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n\tif (ret < 0) {\n\t\tudf_sb_free_partitions(sb);\n\t\t \n\t\tif (ret == -EAGAIN)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\n \nstatic int udf_check_anchor_block(struct super_block *sb, sector_t block,\n\t\t\t\t  struct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_AVDP) {\n\t\tbrelse(bh);\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_sequence(sb, bh, fileset);\n\tbrelse(bh);\n\treturn ret;\n}\n\n \nstatic int udf_scan_anchors(struct super_block *sb, udf_pblk_t *lastblock,\n\t\t\t    struct kernel_lb_addr *fileset)\n{\n\tudf_pblk_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tint ret;\n\n\t \n\tif (sbi->s_anchor) {\n\t\tret = udf_check_anchor_block(sb, sbi->s_anchor, fileset);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\t \n\tret = udf_check_anchor_block(sb, sbi->s_session + 256, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\t \n\tlast[last_count++] = *lastblock;\n\tif (*lastblock >= 1)\n\t\tlast[last_count++] = *lastblock - 1;\n\tlast[last_count++] = *lastblock + 1;\n\tif (*lastblock >= 2)\n\t\tlast[last_count++] = *lastblock - 2;\n\tif (*lastblock >= 150)\n\t\tlast[last_count++] = *lastblock - 150;\n\tif (*lastblock >= 152)\n\t\tlast[last_count++] = *lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb_bdev_nr_blocks(sb))\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i], fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i] - 256, fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treturn udf_check_anchor_block(sb, sbi->s_session + 512, fileset);\n}\n\n \nstatic int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint nsr = 0;\n\tint ret;\n\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\t \n\t\tnsr = udf_check_vsd(sb);\n\t\tif (!nsr) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nsr == -1)\n\t\t\tudf_debug(\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\", VSD_FIRST_SECTOR_OFFSET);\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\n\t \n\tsbi->s_anchor = uopt->anchor;\n\tret = udf_scan_anchors(sb, &sbi->s_last_block, fileset);\n\tif (ret < 0) {\n\t\tif (!silent && ret == -EAGAIN)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void udf_finalize_lvid(struct logicalVolIntegrityDesc *lvid)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, ts);\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n}\n\nstatic void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tif (le32_to_cpu(lvid->integrityType) == LVID_INTEGRITY_TYPE_CLOSE)\n\t\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\telse\n\t\tUDF_SET_FLAG(sb, UDF_FLAG_INCONSISTENT);\n\n\tudf_finalize_lvid(lvid);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t \n\tsync_dirty_buffer(bh);\n}\n\nstatic void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_INCONSISTENT))\n\t\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\t \n\tset_buffer_uptodate(bh);\n\tudf_finalize_lvid(lvid);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t \n\tsync_dirty_buffer(bh);\n}\n\nu64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tudf_updated_lvid(sb);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\n\treturn ret;\n}\n\nstatic int udf_fill_super(struct super_block *sb, void *options, int silent)\n{\n\tint ret = -EINVAL;\n\tstruct inode *inode = NULL;\n\tstruct udf_options uopt;\n\tstruct kernel_lb_addr rootdir, fileset;\n\tstruct udf_sb_info *sbi;\n\tbool lvid_open = false;\n\n\tuopt.flags = (1 << UDF_FLAG_USE_AD_IN_ICB) | (1 << UDF_FLAG_STRICT);\n\t \n\tuopt.uid = make_kuid(current_user_ns(), overflowuid);\n\tuopt.gid = make_kgid(current_user_ns(), overflowgid);\n\tuopt.umask = 0;\n\tuopt.fmode = UDF_INVALID_MODE;\n\tuopt.dmode = UDF_INVALID_MODE;\n\tuopt.nls_map = NULL;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tmutex_init(&sbi->s_alloc_mutex);\n\n\tif (!udf_parse_options((char *)options, &uopt, false))\n\t\tgoto parse_options_failure;\n\n\tfileset.logicalBlockNum = 0xFFFFFFFF;\n\tfileset.partitionReferenceNum = 0xFFFF;\n\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid = uopt.uid;\n\tsbi->s_gid = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\tsbi->s_nls_map = uopt.nls_map;\n\trwlock_init(&sbi->s_cred_lock);\n\n\tif (uopt.session == 0xFFFFFFFF)\n\t\tsbi->s_session = udf_get_last_session(sb);\n\telse\n\t\tsbi->s_session = uopt.session;\n\n\tudf_debug(\"Multi-session=%d\\n\", sbi->s_session);\n\n\t \n\tsb->s_op = &udf_sb_ops;\n\tsb->s_export_op = &udf_export_ops;\n\n\tsb->s_magic = UDF_SUPER_MAGIC;\n\tsb->s_time_gran = 1000;\n\n\tif (uopt.flags & (1 << UDF_FLAG_BLOCKSIZE_SET)) {\n\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t} else {\n\t\tuopt.blocksize = bdev_logical_block_size(sb->s_bdev);\n\t\twhile (uopt.blocksize <= 4096) {\n\t\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (!silent && ret != -EACCES) {\n\t\t\t\t\tpr_notice(\"Scanning with blocksize %u failed\\n\",\n\t\t\t\t\t\t  uopt.blocksize);\n\t\t\t\t}\n\t\t\t\tbrelse(sbi->s_lvid_bh);\n\t\t\t\tsbi->s_lvid_bh = NULL;\n\t\t\t\t \n\t\t\t\tif (ret == -EACCES)\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t\tuopt.blocksize <<= 1;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN) {\n\t\t\tudf_warn(sb, \"No partition found (1)\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto error_out;\n\t}\n\n\tudf_debug(\"Lastblock=%u\\n\", sbi->s_last_block);\n\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDescImpUse *lvidiu =\n\t\t\t\t\t\t\tudf_sb_lvidiu(sb);\n\t\tuint16_t minUDFReadRev;\n\t\tuint16_t minUDFWriteRev;\n\n\t\tif (!lvidiu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t}\n\t\tminUDFReadRev = le16_to_cpu(lvidiu->minUDFReadRev);\n\t\tminUDFWriteRev = le16_to_cpu(lvidiu->minUDFWriteRev);\n\t\tif (minUDFReadRev > UDF_MAX_READ_VERSION) {\n\t\t\tudf_err(sb, \"minUDFReadRev=%x (max is %x)\\n\",\n\t\t\t\tminUDFReadRev,\n\t\t\t\tUDF_MAX_READ_VERSION);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t} else if (minUDFWriteRev > UDF_MAX_WRITE_VERSION) {\n\t\t\tif (!sb_rdonly(sb)) {\n\t\t\t\tret = -EACCES;\n\t\t\t\tgoto error_out;\n\t\t\t}\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\t\t}\n\n\t\tsbi->s_udfrev = minUDFWriteRev;\n\n\t\tif (minUDFReadRev >= UDF_VERS_USE_EXTENDED_FE)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_EXTENDED_FE);\n\t\tif (minUDFReadRev >= UDF_VERS_USE_STREAMS)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_STREAMS);\n\t}\n\n\tif (!sbi->s_partitions) {\n\t\tudf_warn(sb, \"No partition found (2)\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (sbi->s_partmaps[sbi->s_partition].s_partition_flags &\n\t\t\tUDF_PART_FLAG_READ_ONLY) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto error_out;\n\t\t}\n\t\tUDF_SET_FLAG(sb, UDF_FLAG_RW_INCOMPAT);\n\t}\n\n\tret = udf_find_fileset(sb, &fileset, &rootdir);\n\tif (ret < 0) {\n\t\tudf_warn(sb, \"No fileset found\\n\");\n\t\tgoto error_out;\n\t}\n\n\tif (!silent) {\n\t\tstruct timestamp ts;\n\t\tudf_time_to_disk_stamp(&ts, sbi->s_record_time);\n\t\tudf_info(\"Mounting volume '%s', timestamp %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t sbi->s_volume_ident,\n\t\t\t le16_to_cpu(ts.year), ts.month, ts.day,\n\t\t\t ts.hour, ts.minute, le16_to_cpu(ts.typeAndTimezone));\n\t}\n\tif (!sb_rdonly(sb)) {\n\t\tudf_open_lvid(sb);\n\t\tlvid_open = true;\n\t}\n\n\t \n\t \n\t \n\tinode = udf_iget(sb, &rootdir);\n\tif (IS_ERR(inode)) {\n\t\tudf_err(sb, \"Error in udf_iget, block=%u, partition=%u\\n\",\n\t\t       rootdir.logicalBlockNum, rootdir.partitionReferenceNum);\n\t\tret = PTR_ERR(inode);\n\t\tgoto error_out;\n\t}\n\n\t \n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tudf_err(sb, \"Couldn't allocate root dentry\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\tsb->s_maxbytes = UDF_MAX_FILESIZE;\n\tsb->s_max_links = UDF_MAX_LINKS;\n\treturn 0;\n\nerror_out:\n\tiput(sbi->s_vat_inode);\nparse_options_failure:\n\tunload_nls(uopt.nls_map);\n\tif (lvid_open)\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\n\treturn ret;\n}\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}\n\nstatic void udf_put_super(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\n\tiput(sbi->s_vat_inode);\n\tunload_nls(sbi->s_nls_map);\n\tif (!sb_rdonly(sb))\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tmutex_destroy(&sbi->s_alloc_mutex);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}\n\nstatic int udf_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (sbi->s_lvid_dirty) {\n\t\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\t\tstruct logicalVolIntegrityDesc *lvid;\n\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\t\tudf_finalize_lvid(lvid);\n\n\t\t \n\t\tmark_buffer_dirty(bh);\n\t\tsbi->s_lvid_dirty = 0;\n\t}\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\n\treturn 0;\n}\n\nstatic int udf_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tbuf->f_type = UDF_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->s_partmaps[sbi->s_partition].s_partition_len;\n\tbuf->f_bfree = udf_count_free(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\t \n\tbuf->f_files = (lvidiu != NULL ? (le32_to_cpu(lvidiu->numFiles) +\n\t\t\t\t\t  le32_to_cpu(lvidiu->numDirs)) : 0)\n\t\t\t+ buf->f_bfree;\n\tbuf->f_ffree = buf->f_bfree;\n\tbuf->f_namelen = UDF_NAME_LEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\treturn 0;\n}\n\nstatic unsigned int udf_count_free_bitmap(struct super_block *sb,\n\t\t\t\t\t  struct udf_bitmap *bitmap)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned int accum = 0;\n\tint index;\n\tudf_pblk_t block = 0, newblock;\n\tstruct kernel_lb_addr loc;\n\tuint32_t bytes;\n\tuint8_t *ptr;\n\tuint16_t ident;\n\tstruct spaceBitmapDesc *bm;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\tbh = udf_read_ptagged(sb, &loc, 0, &ident);\n\n\tif (!bh) {\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t} else if (ident != TAG_IDENT_SBD) {\n\t\tbrelse(bh);\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t}\n\n\tbm = (struct spaceBitmapDesc *)bh->b_data;\n\tbytes = le32_to_cpu(bm->numOfBytes);\n\tindex = sizeof(struct spaceBitmapDesc);  \n\tptr = (uint8_t *)bh->b_data;\n\n\twhile (bytes > 0) {\n\t\tu32 cur_bytes = min_t(u32, bytes, sb->s_blocksize - index);\n\t\taccum += bitmap_weight((const unsigned long *)(ptr + index),\n\t\t\t\t\tcur_bytes * 8);\n\t\tbytes -= cur_bytes;\n\t\tif (bytes) {\n\t\t\tbrelse(bh);\n\t\t\tnewblock = udf_get_lb_pblock(sb, &loc, ++block);\n\t\t\tbh = sb_bread(sb, newblock);\n\t\t\tif (!bh) {\n\t\t\t\tudf_debug(\"read failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tindex = 0;\n\t\t\tptr = (uint8_t *)bh->b_data;\n\t\t}\n\t}\n\tbrelse(bh);\nout:\n\treturn accum;\n}\n\nstatic unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile (udf_next_aext(table, &epos, &eloc, &elen, 1) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}\n\nstatic unsigned int udf_count_free(struct super_block *sb)\n{\n\tunsigned int accum = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tunsigned int part = sbi->s_partition;\n\tint ptype = sbi->s_partmaps[part].s_partition_type;\n\n\tif (ptype == UDF_METADATA_MAP25) {\n\t\tpart = sbi->s_partmaps[part].s_type_specific.s_metadata.\n\t\t\t\t\t\t\ts_phys_partition_ref;\n\t} else if (ptype == UDF_VIRTUAL_MAP15 || ptype == UDF_VIRTUAL_MAP20) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDesc *lvid =\n\t\t\t(struct logicalVolIntegrityDesc *)\n\t\t\tsbi->s_lvid_bh->b_data;\n\t\tif (le32_to_cpu(lvid->numOfPartitions) > part) {\n\t\t\taccum = le32_to_cpu(\n\t\t\t\t\tlvid->freeSpaceTable[part]);\n\t\t\tif (accum == 0xFFFFFFFF)\n\t\t\t\taccum = 0;\n\t\t}\n\t}\n\n\tif (accum)\n\t\treturn accum;\n\n\tmap = &sbi->s_partmaps[part];\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_uspace.s_bitmap);\n\t}\n\tif (accum)\n\t\treturn accum;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_uspace.s_table);\n\t}\n\treturn accum;\n}\n\nMODULE_AUTHOR(\"Ben Fennema\");\nMODULE_DESCRIPTION(\"Universal Disk Format Filesystem\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_udf_fs)\nmodule_exit(exit_udf_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}