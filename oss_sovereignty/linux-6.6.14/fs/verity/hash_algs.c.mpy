{
  "module_name": "hash_algs.c",
  "hash_id": "7872c8ade9ea29a1095e5dc2c3003e5c7f257ab6fa3d9c2f7ea5759d57828c8f",
  "original_prompt": "Ingested from linux-6.6.14/fs/verity/hash_algs.c",
  "human_readable_source": "\n \n\n#include \"fsverity_private.h\"\n\n#include <crypto/hash.h>\n\n \nstruct fsverity_hash_alg fsverity_hash_algs[] = {\n\t[FS_VERITY_HASH_ALG_SHA256] = {\n\t\t.name = \"sha256\",\n\t\t.digest_size = SHA256_DIGEST_SIZE,\n\t\t.block_size = SHA256_BLOCK_SIZE,\n\t\t.algo_id = HASH_ALGO_SHA256,\n\t},\n\t[FS_VERITY_HASH_ALG_SHA512] = {\n\t\t.name = \"sha512\",\n\t\t.digest_size = SHA512_DIGEST_SIZE,\n\t\t.block_size = SHA512_BLOCK_SIZE,\n\t\t.algo_id = HASH_ALGO_SHA512,\n\t},\n};\n\nstatic DEFINE_MUTEX(fsverity_hash_alg_init_mutex);\n\n \nconst struct fsverity_hash_alg *fsverity_get_hash_alg(const struct inode *inode,\n\t\t\t\t\t\t      unsigned int num)\n{\n\tstruct fsverity_hash_alg *alg;\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\tif (num >= ARRAY_SIZE(fsverity_hash_algs) ||\n\t    !fsverity_hash_algs[num].name) {\n\t\tfsverity_warn(inode, \"Unknown hash algorithm number: %u\", num);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\talg = &fsverity_hash_algs[num];\n\n\t \n\tif (likely(smp_load_acquire(&alg->tfm) != NULL))\n\t\treturn alg;\n\n\tmutex_lock(&fsverity_hash_alg_init_mutex);\n\n\tif (alg->tfm != NULL)\n\t\tgoto out_unlock;\n\n\ttfm = crypto_alloc_shash(alg->name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tif (PTR_ERR(tfm) == -ENOENT) {\n\t\t\tfsverity_warn(inode,\n\t\t\t\t      \"Missing crypto API support for hash algorithm \\\"%s\\\"\",\n\t\t\t\t      alg->name);\n\t\t\talg = ERR_PTR(-ENOPKG);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tfsverity_err(inode,\n\t\t\t     \"Error allocating hash algorithm \\\"%s\\\": %ld\",\n\t\t\t     alg->name, PTR_ERR(tfm));\n\t\talg = ERR_CAST(tfm);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EINVAL;\n\tif (WARN_ON_ONCE(alg->digest_size != crypto_shash_digestsize(tfm)))\n\t\tgoto err_free_tfm;\n\tif (WARN_ON_ONCE(alg->block_size != crypto_shash_blocksize(tfm)))\n\t\tgoto err_free_tfm;\n\n\tpr_info(\"%s using implementation \\\"%s\\\"\\n\",\n\t\talg->name, crypto_shash_driver_name(tfm));\n\n\t \n\tsmp_store_release(&alg->tfm, tfm);\n\tgoto out_unlock;\n\nerr_free_tfm:\n\tcrypto_free_shash(tfm);\n\talg = ERR_PTR(err);\nout_unlock:\n\tmutex_unlock(&fsverity_hash_alg_init_mutex);\n\treturn alg;\n}\n\n \nconst u8 *fsverity_prepare_hash_state(const struct fsverity_hash_alg *alg,\n\t\t\t\t      const u8 *salt, size_t salt_size)\n{\n\tu8 *hashstate = NULL;\n\tSHASH_DESC_ON_STACK(desc, alg->tfm);\n\tu8 *padded_salt = NULL;\n\tsize_t padded_salt_size;\n\tint err;\n\n\tdesc->tfm = alg->tfm;\n\n\tif (salt_size == 0)\n\t\treturn NULL;\n\n\thashstate = kmalloc(crypto_shash_statesize(alg->tfm), GFP_KERNEL);\n\tif (!hashstate)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpadded_salt_size = round_up(salt_size, alg->block_size);\n\tpadded_salt = kzalloc(padded_salt_size, GFP_KERNEL);\n\tif (!padded_salt) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\tmemcpy(padded_salt, salt, salt_size);\n\terr = crypto_shash_init(desc);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = crypto_shash_update(desc, padded_salt, padded_salt_size);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = crypto_shash_export(desc, hashstate);\n\tif (err)\n\t\tgoto err_free;\nout:\n\tkfree(padded_salt);\n\treturn hashstate;\n\nerr_free:\n\tkfree(hashstate);\n\thashstate = ERR_PTR(err);\n\tgoto out;\n}\n\n \nint fsverity_hash_block(const struct merkle_tree_params *params,\n\t\t\tconst struct inode *inode, const void *data, u8 *out)\n{\n\tSHASH_DESC_ON_STACK(desc, params->hash_alg->tfm);\n\tint err;\n\n\tdesc->tfm = params->hash_alg->tfm;\n\n\tif (params->hashstate) {\n\t\terr = crypto_shash_import(desc, params->hashstate);\n\t\tif (err) {\n\t\t\tfsverity_err(inode,\n\t\t\t\t     \"Error %d importing hash state\", err);\n\t\t\treturn err;\n\t\t}\n\t\terr = crypto_shash_finup(desc, data, params->block_size, out);\n\t} else {\n\t\terr = crypto_shash_digest(desc, data, params->block_size, out);\n\t}\n\tif (err)\n\t\tfsverity_err(inode, \"Error %d computing block hash\", err);\n\treturn err;\n}\n\n \nint fsverity_hash_buffer(const struct fsverity_hash_alg *alg,\n\t\t\t const void *data, size_t size, u8 *out)\n{\n\treturn crypto_shash_tfm_digest(alg->tfm, data, size, out);\n}\n\nvoid __init fsverity_check_hash_algs(void)\n{\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fsverity_hash_algs); i++) {\n\t\tconst struct fsverity_hash_alg *alg = &fsverity_hash_algs[i];\n\n\t\tif (!alg->name)\n\t\t\tcontinue;\n\n\t\t \n\t\tBUG_ON(i == 0);\n\n\t\tBUG_ON(alg->digest_size > FS_VERITY_MAX_DIGEST_SIZE);\n\n\t\t \n\t\tBUG_ON(!is_power_of_2(alg->digest_size));\n\t\tBUG_ON(!is_power_of_2(alg->block_size));\n\n\t\t \n\t\tBUG_ON(alg->algo_id == 0);\n\t\tBUG_ON(alg->digest_size != hash_digest_size[alg->algo_id]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}