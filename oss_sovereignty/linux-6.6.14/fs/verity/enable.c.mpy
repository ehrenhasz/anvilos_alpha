{
  "module_name": "enable.c",
  "hash_id": "48e6185accc451b3fed62de4452872ed5f6c34cadc1cd1d822256acc5d3a35fa",
  "original_prompt": "Ingested from linux-6.6.14/fs/verity/enable.c",
  "human_readable_source": "\n \n\n#include \"fsverity_private.h\"\n\n#include <crypto/hash.h>\n#include <linux/mount.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n\nstruct block_buffer {\n\tu32 filled;\n\tbool is_root_hash;\n\tu8 *data;\n};\n\n \nstatic int hash_one_block(struct inode *inode,\n\t\t\t  const struct merkle_tree_params *params,\n\t\t\t  struct block_buffer *cur)\n{\n\tstruct block_buffer *next = cur + 1;\n\tint err;\n\n\t \n\tif (WARN_ON_ONCE(next->is_root_hash && next->filled != 0))\n\t\treturn -EINVAL;\n\n\t \n\tmemset(&cur->data[cur->filled], 0, params->block_size - cur->filled);\n\n\terr = fsverity_hash_block(params, inode, cur->data,\n\t\t\t\t  &next->data[next->filled]);\n\tif (err)\n\t\treturn err;\n\tnext->filled += params->digest_size;\n\tcur->filled = 0;\n\treturn 0;\n}\n\nstatic int write_merkle_tree_block(struct inode *inode, const u8 *buf,\n\t\t\t\t   unsigned long index,\n\t\t\t\t   const struct merkle_tree_params *params)\n{\n\tu64 pos = (u64)index << params->log_blocksize;\n\tint err;\n\n\terr = inode->i_sb->s_vop->write_merkle_tree_block(inode, buf, pos,\n\t\t\t\t\t\t\t  params->block_size);\n\tif (err)\n\t\tfsverity_err(inode, \"Error %d writing Merkle tree block %lu\",\n\t\t\t     err, index);\n\treturn err;\n}\n\n \nstatic int build_merkle_tree(struct file *filp,\n\t\t\t     const struct merkle_tree_params *params,\n\t\t\t     u8 *root_hash)\n{\n\tstruct inode *inode = file_inode(filp);\n\tconst u64 data_size = inode->i_size;\n\tconst int num_levels = params->num_levels;\n\tstruct block_buffer _buffers[1 + FS_VERITY_MAX_LEVELS + 1] = {};\n\tstruct block_buffer *buffers = &_buffers[1];\n\tunsigned long level_offset[FS_VERITY_MAX_LEVELS];\n\tint level;\n\tu64 offset;\n\tint err;\n\n\tif (data_size == 0) {\n\t\t \n\t\tmemset(root_hash, 0, params->digest_size);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (level = -1; level < num_levels; level++) {\n\t\tbuffers[level].data = kzalloc(params->block_size, GFP_KERNEL);\n\t\tif (!buffers[level].data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbuffers[num_levels].data = root_hash;\n\tbuffers[num_levels].is_root_hash = true;\n\n\tBUILD_BUG_ON(sizeof(level_offset) != sizeof(params->level_start));\n\tmemcpy(level_offset, params->level_start, sizeof(level_offset));\n\n\t \n\tfor (offset = 0; offset < data_size; offset += params->block_size) {\n\t\tssize_t bytes_read;\n\t\tloff_t pos = offset;\n\n\t\tbuffers[-1].filled = min_t(u64, params->block_size,\n\t\t\t\t\t   data_size - offset);\n\t\tbytes_read = __kernel_read(filp, buffers[-1].data,\n\t\t\t\t\t   buffers[-1].filled, &pos);\n\t\tif (bytes_read < 0) {\n\t\t\terr = bytes_read;\n\t\t\tfsverity_err(inode, \"Error %d reading file data\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tif (bytes_read != buffers[-1].filled) {\n\t\t\terr = -EINVAL;\n\t\t\tfsverity_err(inode, \"Short read of file data\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = hash_one_block(inode, params, &buffers[-1]);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfor (level = 0; level < num_levels; level++) {\n\t\t\tif (buffers[level].filled + params->digest_size <=\n\t\t\t    params->block_size) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\n\t\t\terr = hash_one_block(inode, params, &buffers[level]);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = write_merkle_tree_block(inode,\n\t\t\t\t\t\t      buffers[level].data,\n\t\t\t\t\t\t      level_offset[level],\n\t\t\t\t\t\t      params);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlevel_offset[level]++;\n\t\t}\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t}\n\t \n\tfor (level = 0; level < num_levels; level++) {\n\t\tif (buffers[level].filled != 0) {\n\t\t\terr = hash_one_block(inode, params, &buffers[level]);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = write_merkle_tree_block(inode,\n\t\t\t\t\t\t      buffers[level].data,\n\t\t\t\t\t\t      level_offset[level],\n\t\t\t\t\t\t      params);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tif (WARN_ON_ONCE(buffers[num_levels].filled != params->digest_size)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\tfor (level = -1; level < num_levels; level++)\n\t\tkfree(buffers[level].data);\n\treturn err;\n}\n\nstatic int enable_verity(struct file *filp,\n\t\t\t const struct fsverity_enable_arg *arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tconst struct fsverity_operations *vops = inode->i_sb->s_vop;\n\tstruct merkle_tree_params params = { };\n\tstruct fsverity_descriptor *desc;\n\tsize_t desc_size = struct_size(desc, signature, arg->sig_size);\n\tstruct fsverity_info *vi;\n\tint err;\n\n\t \n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\tdesc->version = 1;\n\tdesc->hash_algorithm = arg->hash_algorithm;\n\tdesc->log_blocksize = ilog2(arg->block_size);\n\n\t \n\tif (arg->salt_size &&\n\t    copy_from_user(desc->salt, u64_to_user_ptr(arg->salt_ptr),\n\t\t\t   arg->salt_size)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tdesc->salt_size = arg->salt_size;\n\n\t \n\tif (arg->sig_size &&\n\t    copy_from_user(desc->signature, u64_to_user_ptr(arg->sig_ptr),\n\t\t\t   arg->sig_size)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tdesc->sig_size = cpu_to_le32(arg->sig_size);\n\n\tdesc->data_size = cpu_to_le64(inode->i_size);\n\n\t \n\terr = fsverity_init_merkle_tree_params(&params, inode,\n\t\t\t\t\t       arg->hash_algorithm,\n\t\t\t\t\t       desc->log_blocksize,\n\t\t\t\t\t       desc->salt, desc->salt_size);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tinode_lock(inode);\n\tif (IS_VERITY(inode))\n\t\terr = -EEXIST;\n\telse\n\t\terr = vops->begin_enable_verity(filp);\n\tinode_unlock(inode);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tBUILD_BUG_ON(sizeof(desc->root_hash) < FS_VERITY_MAX_DIGEST_SIZE);\n\terr = build_merkle_tree(filp, &params, desc->root_hash);\n\tif (err) {\n\t\tfsverity_err(inode, \"Error %d building Merkle tree\", err);\n\t\tgoto rollback;\n\t}\n\n\t \n\tvi = fsverity_create_info(inode, desc);\n\tif (IS_ERR(vi)) {\n\t\terr = PTR_ERR(vi);\n\t\tgoto rollback;\n\t}\n\n\t \n\tinode_lock(inode);\n\terr = vops->end_enable_verity(filp, desc, desc_size, params.tree_size);\n\tinode_unlock(inode);\n\tif (err) {\n\t\tfsverity_err(inode, \"%ps() failed with err %d\",\n\t\t\t     vops->end_enable_verity, err);\n\t\tfsverity_free_info(vi);\n\t} else if (WARN_ON_ONCE(!IS_VERITY(inode))) {\n\t\terr = -EINVAL;\n\t\tfsverity_free_info(vi);\n\t} else {\n\t\t \n\n\t\t \n\t\tfsverity_set_info(inode, vi);\n\t}\nout:\n\tkfree(params.hashstate);\n\tkfree(desc);\n\treturn err;\n\nrollback:\n\tinode_lock(inode);\n\t(void)vops->end_enable_verity(filp, NULL, 0, params.tree_size);\n\tinode_unlock(inode);\n\tgoto out;\n}\n\n \nint fsverity_ioctl_enable(struct file *filp, const void __user *uarg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct fsverity_enable_arg arg;\n\tint err;\n\n\tif (copy_from_user(&arg, uarg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (arg.version != 1)\n\t\treturn -EINVAL;\n\n\tif (arg.__reserved1 ||\n\t    memchr_inv(arg.__reserved2, 0, sizeof(arg.__reserved2)))\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(arg.block_size))\n\t\treturn -EINVAL;\n\n\tif (arg.salt_size > sizeof_field(struct fsverity_descriptor, salt))\n\t\treturn -EMSGSIZE;\n\n\tif (arg.sig_size > FS_VERITY_MAX_SIGNATURE_SIZE)\n\t\treturn -EMSGSIZE;\n\n\t \n\n\terr = file_permission(filp, MAY_WRITE);\n\tif (err)\n\t\treturn err;\n\t \n\tif (!(filp->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\tif (IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terr = mnt_want_write_file(filp);\n\tif (err)  \n\t\treturn err;\n\n\terr = deny_write_access(filp);\n\tif (err)  \n\t\tgoto out_drop_write;\n\n\terr = enable_verity(filp, &arg);\n\n\t \n\n\t \n\tallow_write_access(filp);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fsverity_ioctl_enable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}