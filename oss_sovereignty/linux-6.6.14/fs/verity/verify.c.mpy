{
  "module_name": "verify.c",
  "hash_id": "2d7bcf030cda73516e400f2d192188c7ee6c367606d8fb9741e7f194de44e845",
  "original_prompt": "Ingested from linux-6.6.14/fs/verity/verify.c",
  "human_readable_source": "\n \n\n#include \"fsverity_private.h\"\n\n#include <crypto/hash.h>\n#include <linux/bio.h>\n\nstatic struct workqueue_struct *fsverity_read_workqueue;\n\n \nstatic bool is_hash_block_verified(struct fsverity_info *vi, struct page *hpage,\n\t\t\t\t   unsigned long hblock_idx)\n{\n\tbool verified;\n\tunsigned int blocks_per_page;\n\tunsigned int i;\n\n\t \n\tif (!vi->hash_block_verified)\n\t\treturn PageChecked(hpage);\n\n\t \n\tif (PageChecked(hpage)) {\n\t\t \n\t\tsmp_rmb();\n\t\treturn test_bit(hblock_idx, vi->hash_block_verified);\n\t}\n\tspin_lock(&vi->hash_page_init_lock);\n\tif (PageChecked(hpage)) {\n\t\tverified = test_bit(hblock_idx, vi->hash_block_verified);\n\t} else {\n\t\tblocks_per_page = vi->tree_params.blocks_per_page;\n\t\thblock_idx = round_down(hblock_idx, blocks_per_page);\n\t\tfor (i = 0; i < blocks_per_page; i++)\n\t\t\tclear_bit(hblock_idx + i, vi->hash_block_verified);\n\t\t \n\t\tsmp_wmb();\n\t\tSetPageChecked(hpage);\n\t\tverified = false;\n\t}\n\tspin_unlock(&vi->hash_page_init_lock);\n\treturn verified;\n}\n\n \nstatic bool\nverify_data_block(struct inode *inode, struct fsverity_info *vi,\n\t\t  const void *data, u64 data_pos, unsigned long max_ra_pages)\n{\n\tconst struct merkle_tree_params *params = &vi->tree_params;\n\tconst unsigned int hsize = params->digest_size;\n\tint level;\n\tu8 _want_hash[FS_VERITY_MAX_DIGEST_SIZE];\n\tconst u8 *want_hash;\n\tu8 real_hash[FS_VERITY_MAX_DIGEST_SIZE];\n\t \n\tstruct {\n\t\t \n\t\tstruct page *page;\n\t\t \n\t\tconst void *addr;\n\t\t \n\t\tunsigned long index;\n\t\t \n\t\tunsigned int hoffset;\n\t} hblocks[FS_VERITY_MAX_LEVELS];\n\t \n\tu64 hidx = data_pos >> params->log_blocksize;\n\n\t \n\tBUILD_BUG_ON(1 + FS_VERITY_MAX_LEVELS > KM_MAX_IDX);\n\n\tif (unlikely(data_pos >= inode->i_size)) {\n\t\t \n\t\tif (memchr_inv(data, 0, params->block_size)) {\n\t\t\tfsverity_err(inode,\n\t\t\t\t     \"FILE CORRUPTED!  Data past EOF is not zeroed\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t \n\tfor (level = 0; level < params->num_levels; level++) {\n\t\tunsigned long next_hidx;\n\t\tunsigned long hblock_idx;\n\t\tpgoff_t hpage_idx;\n\t\tunsigned int hblock_offset_in_page;\n\t\tunsigned int hoffset;\n\t\tstruct page *hpage;\n\t\tconst void *haddr;\n\n\t\t \n\t\tnext_hidx = hidx >> params->log_arity;\n\n\t\t \n\t\thblock_idx = params->level_start[level] + next_hidx;\n\n\t\t \n\t\thpage_idx = hblock_idx >> params->log_blocks_per_page;\n\n\t\t \n\t\thblock_offset_in_page =\n\t\t\t(hblock_idx << params->log_blocksize) & ~PAGE_MASK;\n\n\t\t \n\t\thoffset = (hidx << params->log_digestsize) &\n\t\t\t  (params->block_size - 1);\n\n\t\thpage = inode->i_sb->s_vop->read_merkle_tree_page(inode,\n\t\t\t\thpage_idx, level == 0 ? min(max_ra_pages,\n\t\t\t\t\tparams->tree_pages - hpage_idx) : 0);\n\t\tif (IS_ERR(hpage)) {\n\t\t\tfsverity_err(inode,\n\t\t\t\t     \"Error %ld reading Merkle tree page %lu\",\n\t\t\t\t     PTR_ERR(hpage), hpage_idx);\n\t\t\tgoto error;\n\t\t}\n\t\thaddr = kmap_local_page(hpage) + hblock_offset_in_page;\n\t\tif (is_hash_block_verified(vi, hpage, hblock_idx)) {\n\t\t\tmemcpy(_want_hash, haddr + hoffset, hsize);\n\t\t\twant_hash = _want_hash;\n\t\t\tkunmap_local(haddr);\n\t\t\tput_page(hpage);\n\t\t\tgoto descend;\n\t\t}\n\t\thblocks[level].page = hpage;\n\t\thblocks[level].addr = haddr;\n\t\thblocks[level].index = hblock_idx;\n\t\thblocks[level].hoffset = hoffset;\n\t\thidx = next_hidx;\n\t}\n\n\twant_hash = vi->root_hash;\ndescend:\n\t \n\tfor (; level > 0; level--) {\n\t\tstruct page *hpage = hblocks[level - 1].page;\n\t\tconst void *haddr = hblocks[level - 1].addr;\n\t\tunsigned long hblock_idx = hblocks[level - 1].index;\n\t\tunsigned int hoffset = hblocks[level - 1].hoffset;\n\n\t\tif (fsverity_hash_block(params, inode, haddr, real_hash) != 0)\n\t\t\tgoto error;\n\t\tif (memcmp(want_hash, real_hash, hsize) != 0)\n\t\t\tgoto corrupted;\n\t\t \n\t\tif (vi->hash_block_verified)\n\t\t\tset_bit(hblock_idx, vi->hash_block_verified);\n\t\telse\n\t\t\tSetPageChecked(hpage);\n\t\tmemcpy(_want_hash, haddr + hoffset, hsize);\n\t\twant_hash = _want_hash;\n\t\tkunmap_local(haddr);\n\t\tput_page(hpage);\n\t}\n\n\t \n\tif (fsverity_hash_block(params, inode, data, real_hash) != 0)\n\t\tgoto error;\n\tif (memcmp(want_hash, real_hash, hsize) != 0)\n\t\tgoto corrupted;\n\treturn true;\n\ncorrupted:\n\tfsverity_err(inode,\n\t\t     \"FILE CORRUPTED! pos=%llu, level=%d, want_hash=%s:%*phN, real_hash=%s:%*phN\",\n\t\t     data_pos, level - 1,\n\t\t     params->hash_alg->name, hsize, want_hash,\n\t\t     params->hash_alg->name, hsize, real_hash);\nerror:\n\tfor (; level > 0; level--) {\n\t\tkunmap_local(hblocks[level - 1].addr);\n\t\tput_page(hblocks[level - 1].page);\n\t}\n\treturn false;\n}\n\nstatic bool\nverify_data_blocks(struct folio *data_folio, size_t len, size_t offset,\n\t\t   unsigned long max_ra_pages)\n{\n\tstruct inode *inode = data_folio->mapping->host;\n\tstruct fsverity_info *vi = inode->i_verity_info;\n\tconst unsigned int block_size = vi->tree_params.block_size;\n\tu64 pos = (u64)data_folio->index << PAGE_SHIFT;\n\n\tif (WARN_ON_ONCE(len <= 0 || !IS_ALIGNED(len | offset, block_size)))\n\t\treturn false;\n\tif (WARN_ON_ONCE(!folio_test_locked(data_folio) ||\n\t\t\t folio_test_uptodate(data_folio)))\n\t\treturn false;\n\tdo {\n\t\tvoid *data;\n\t\tbool valid;\n\n\t\tdata = kmap_local_folio(data_folio, offset);\n\t\tvalid = verify_data_block(inode, vi, data, pos + offset,\n\t\t\t\t\t  max_ra_pages);\n\t\tkunmap_local(data);\n\t\tif (!valid)\n\t\t\treturn false;\n\t\toffset += block_size;\n\t\tlen -= block_size;\n\t} while (len);\n\treturn true;\n}\n\n \nbool fsverity_verify_blocks(struct folio *folio, size_t len, size_t offset)\n{\n\treturn verify_data_blocks(folio, len, offset, 0);\n}\nEXPORT_SYMBOL_GPL(fsverity_verify_blocks);\n\n#ifdef CONFIG_BLOCK\n \nvoid fsverity_verify_bio(struct bio *bio)\n{\n\tstruct folio_iter fi;\n\tunsigned long max_ra_pages = 0;\n\n\tif (bio->bi_opf & REQ_RAHEAD) {\n\t\t \n\t\tmax_ra_pages = bio->bi_iter.bi_size >> (PAGE_SHIFT + 2);\n\t}\n\n\tbio_for_each_folio_all(fi, bio) {\n\t\tif (!verify_data_blocks(fi.folio, fi.length, fi.offset,\n\t\t\t\t\tmax_ra_pages)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(fsverity_verify_bio);\n#endif  \n\n \nvoid fsverity_enqueue_verify_work(struct work_struct *work)\n{\n\tqueue_work(fsverity_read_workqueue, work);\n}\nEXPORT_SYMBOL_GPL(fsverity_enqueue_verify_work);\n\nvoid __init fsverity_init_workqueue(void)\n{\n\t \n\tfsverity_read_workqueue = alloc_workqueue(\"fsverity_read_queue\",\n\t\t\t\t\t\t  WQ_HIGHPRI,\n\t\t\t\t\t\t  num_online_cpus());\n\tif (!fsverity_read_workqueue)\n\t\tpanic(\"failed to allocate fsverity_read_queue\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}