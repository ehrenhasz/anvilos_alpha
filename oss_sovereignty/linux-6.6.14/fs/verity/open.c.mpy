{
  "module_name": "open.c",
  "hash_id": "c932b169f72be4747341556a2bbe18b6345eb027e0e6db756d4e774be01f2074",
  "original_prompt": "Ingested from linux-6.6.14/fs/verity/open.c",
  "human_readable_source": "\n \n\n#include \"fsverity_private.h\"\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *fsverity_info_cachep;\n\n \nint fsverity_init_merkle_tree_params(struct merkle_tree_params *params,\n\t\t\t\t     const struct inode *inode,\n\t\t\t\t     unsigned int hash_algorithm,\n\t\t\t\t     unsigned int log_blocksize,\n\t\t\t\t     const u8 *salt, size_t salt_size)\n{\n\tconst struct fsverity_hash_alg *hash_alg;\n\tint err;\n\tu64 blocks;\n\tu64 blocks_in_level[FS_VERITY_MAX_LEVELS];\n\tu64 offset;\n\tint level;\n\n\tmemset(params, 0, sizeof(*params));\n\n\thash_alg = fsverity_get_hash_alg(inode, hash_algorithm);\n\tif (IS_ERR(hash_alg))\n\t\treturn PTR_ERR(hash_alg);\n\tparams->hash_alg = hash_alg;\n\tparams->digest_size = hash_alg->digest_size;\n\n\tparams->hashstate = fsverity_prepare_hash_state(hash_alg, salt,\n\t\t\t\t\t\t\tsalt_size);\n\tif (IS_ERR(params->hashstate)) {\n\t\terr = PTR_ERR(params->hashstate);\n\t\tparams->hashstate = NULL;\n\t\tfsverity_err(inode, \"Error %d preparing hash state\", err);\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (log_blocksize < 10 || log_blocksize > PAGE_SHIFT ||\n\t    log_blocksize > inode->i_blkbits) {\n\t\tfsverity_warn(inode, \"Unsupported log_blocksize: %u\",\n\t\t\t      log_blocksize);\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tparams->log_blocksize = log_blocksize;\n\tparams->block_size = 1 << log_blocksize;\n\tparams->log_blocks_per_page = PAGE_SHIFT - log_blocksize;\n\tparams->blocks_per_page = 1 << params->log_blocks_per_page;\n\n\tif (WARN_ON_ONCE(!is_power_of_2(params->digest_size))) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tif (params->block_size < 2 * params->digest_size) {\n\t\tfsverity_warn(inode,\n\t\t\t      \"Merkle tree block size (%u) too small for hash algorithm \\\"%s\\\"\",\n\t\t\t      params->block_size, hash_alg->name);\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tparams->log_digestsize = ilog2(params->digest_size);\n\tparams->log_arity = log_blocksize - params->log_digestsize;\n\tparams->hashes_per_block = 1 << params->log_arity;\n\n\t \n\n\t \n\tblocks = ((u64)inode->i_size + params->block_size - 1) >> log_blocksize;\n\twhile (blocks > 1) {\n\t\tif (params->num_levels >= FS_VERITY_MAX_LEVELS) {\n\t\t\tfsverity_err(inode, \"Too many levels in Merkle tree\");\n\t\t\terr = -EFBIG;\n\t\t\tgoto out_err;\n\t\t}\n\t\tblocks = (blocks + params->hashes_per_block - 1) >>\n\t\t\t params->log_arity;\n\t\tblocks_in_level[params->num_levels++] = blocks;\n\t}\n\n\t \n\toffset = 0;\n\tfor (level = (int)params->num_levels - 1; level >= 0; level--) {\n\t\tparams->level_start[level] = offset;\n\t\toffset += blocks_in_level[level];\n\t}\n\n\t \n\tif ((params->block_size != PAGE_SIZE && offset > 1 << 23) ||\n\t    offset > ULONG_MAX) {\n\t\tfsverity_err(inode, \"Too many blocks in Merkle tree\");\n\t\terr = -EFBIG;\n\t\tgoto out_err;\n\t}\n\n\tparams->tree_size = offset << log_blocksize;\n\tparams->tree_pages = PAGE_ALIGN(params->tree_size) >> PAGE_SHIFT;\n\treturn 0;\n\nout_err:\n\tkfree(params->hashstate);\n\tmemset(params, 0, sizeof(*params));\n\treturn err;\n}\n\n \nstatic int compute_file_digest(const struct fsverity_hash_alg *hash_alg,\n\t\t\t       struct fsverity_descriptor *desc,\n\t\t\t       u8 *file_digest)\n{\n\t__le32 sig_size = desc->sig_size;\n\tint err;\n\n\tdesc->sig_size = 0;\n\terr = fsverity_hash_buffer(hash_alg, desc, sizeof(*desc), file_digest);\n\tdesc->sig_size = sig_size;\n\n\treturn err;\n}\n\n \nstruct fsverity_info *fsverity_create_info(const struct inode *inode,\n\t\t\t\t\t   struct fsverity_descriptor *desc)\n{\n\tstruct fsverity_info *vi;\n\tint err;\n\n\tvi = kmem_cache_zalloc(fsverity_info_cachep, GFP_KERNEL);\n\tif (!vi)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvi->inode = inode;\n\n\terr = fsverity_init_merkle_tree_params(&vi->tree_params, inode,\n\t\t\t\t\t       desc->hash_algorithm,\n\t\t\t\t\t       desc->log_blocksize,\n\t\t\t\t\t       desc->salt, desc->salt_size);\n\tif (err) {\n\t\tfsverity_err(inode,\n\t\t\t     \"Error %d initializing Merkle tree parameters\",\n\t\t\t     err);\n\t\tgoto fail;\n\t}\n\n\tmemcpy(vi->root_hash, desc->root_hash, vi->tree_params.digest_size);\n\n\terr = compute_file_digest(vi->tree_params.hash_alg, desc,\n\t\t\t\t  vi->file_digest);\n\tif (err) {\n\t\tfsverity_err(inode, \"Error %d computing file digest\", err);\n\t\tgoto fail;\n\t}\n\n\terr = fsverity_verify_signature(vi, desc->signature,\n\t\t\t\t\tle32_to_cpu(desc->sig_size));\n\tif (err)\n\t\tgoto fail;\n\n\tif (vi->tree_params.block_size != PAGE_SIZE) {\n\t\t \n\t\tunsigned long num_bits =\n\t\t\tvi->tree_params.tree_pages <<\n\t\t\tvi->tree_params.log_blocks_per_page;\n\n\t\tvi->hash_block_verified = kvcalloc(BITS_TO_LONGS(num_bits),\n\t\t\t\t\t\t   sizeof(unsigned long),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!vi->hash_block_verified) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tspin_lock_init(&vi->hash_page_init_lock);\n\t}\n\n\treturn vi;\n\nfail:\n\tfsverity_free_info(vi);\n\treturn ERR_PTR(err);\n}\n\nvoid fsverity_set_info(struct inode *inode, struct fsverity_info *vi)\n{\n\t \n\tif (cmpxchg_release(&inode->i_verity_info, NULL, vi) != NULL) {\n\t\t \n\t\tfsverity_free_info(vi);\n\t\t \n\t\t(void)fsverity_get_info(inode);\n\t}\n}\n\nvoid fsverity_free_info(struct fsverity_info *vi)\n{\n\tif (!vi)\n\t\treturn;\n\tkfree(vi->tree_params.hashstate);\n\tkvfree(vi->hash_block_verified);\n\tkmem_cache_free(fsverity_info_cachep, vi);\n}\n\nstatic bool validate_fsverity_descriptor(struct inode *inode,\n\t\t\t\t\t const struct fsverity_descriptor *desc,\n\t\t\t\t\t size_t desc_size)\n{\n\tif (desc_size < sizeof(*desc)) {\n\t\tfsverity_err(inode, \"Unrecognized descriptor size: %zu bytes\",\n\t\t\t     desc_size);\n\t\treturn false;\n\t}\n\n\tif (desc->version != 1) {\n\t\tfsverity_err(inode, \"Unrecognized descriptor version: %u\",\n\t\t\t     desc->version);\n\t\treturn false;\n\t}\n\n\tif (memchr_inv(desc->__reserved, 0, sizeof(desc->__reserved))) {\n\t\tfsverity_err(inode, \"Reserved bits set in descriptor\");\n\t\treturn false;\n\t}\n\n\tif (desc->salt_size > sizeof(desc->salt)) {\n\t\tfsverity_err(inode, \"Invalid salt_size: %u\", desc->salt_size);\n\t\treturn false;\n\t}\n\n\tif (le64_to_cpu(desc->data_size) != inode->i_size) {\n\t\tfsverity_err(inode,\n\t\t\t     \"Wrong data_size: %llu (desc) != %lld (inode)\",\n\t\t\t     le64_to_cpu(desc->data_size), inode->i_size);\n\t\treturn false;\n\t}\n\n\tif (le32_to_cpu(desc->sig_size) > desc_size - sizeof(*desc)) {\n\t\tfsverity_err(inode, \"Signature overflows verity descriptor\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint fsverity_get_descriptor(struct inode *inode,\n\t\t\t    struct fsverity_descriptor **desc_ret)\n{\n\tint res;\n\tstruct fsverity_descriptor *desc;\n\n\tres = inode->i_sb->s_vop->get_verity_descriptor(inode, NULL, 0);\n\tif (res < 0) {\n\t\tfsverity_err(inode,\n\t\t\t     \"Error %d getting verity descriptor size\", res);\n\t\treturn res;\n\t}\n\tif (res > FS_VERITY_MAX_DESCRIPTOR_SIZE) {\n\t\tfsverity_err(inode, \"Verity descriptor is too large (%d bytes)\",\n\t\t\t     res);\n\t\treturn -EMSGSIZE;\n\t}\n\tdesc = kmalloc(res, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\tres = inode->i_sb->s_vop->get_verity_descriptor(inode, desc, res);\n\tif (res < 0) {\n\t\tfsverity_err(inode, \"Error %d reading verity descriptor\", res);\n\t\tkfree(desc);\n\t\treturn res;\n\t}\n\n\tif (!validate_fsverity_descriptor(inode, desc, res)) {\n\t\tkfree(desc);\n\t\treturn -EINVAL;\n\t}\n\n\t*desc_ret = desc;\n\treturn 0;\n}\n\n \nstatic int ensure_verity_info(struct inode *inode)\n{\n\tstruct fsverity_info *vi = fsverity_get_info(inode);\n\tstruct fsverity_descriptor *desc;\n\tint err;\n\n\tif (vi)\n\t\treturn 0;\n\n\terr = fsverity_get_descriptor(inode, &desc);\n\tif (err)\n\t\treturn err;\n\n\tvi = fsverity_create_info(inode, desc);\n\tif (IS_ERR(vi)) {\n\t\terr = PTR_ERR(vi);\n\t\tgoto out_free_desc;\n\t}\n\n\tfsverity_set_info(inode, vi);\n\terr = 0;\nout_free_desc:\n\tkfree(desc);\n\treturn err;\n}\n\nint __fsverity_file_open(struct inode *inode, struct file *filp)\n{\n\tif (filp->f_mode & FMODE_WRITE)\n\t\treturn -EPERM;\n\treturn ensure_verity_info(inode);\n}\nEXPORT_SYMBOL_GPL(__fsverity_file_open);\n\nint __fsverity_prepare_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn -EPERM;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__fsverity_prepare_setattr);\n\nvoid __fsverity_cleanup_inode(struct inode *inode)\n{\n\tfsverity_free_info(inode->i_verity_info);\n\tinode->i_verity_info = NULL;\n}\nEXPORT_SYMBOL_GPL(__fsverity_cleanup_inode);\n\nvoid __init fsverity_init_info_cache(void)\n{\n\tfsverity_info_cachep = KMEM_CACHE_USERCOPY(\n\t\t\t\t\tfsverity_info,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_PANIC,\n\t\t\t\t\tfile_digest);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}