{
  "module_name": "internal.h",
  "hash_id": "282e6bf2405edaca2130e280c708b9abf7a67f02b6b20d08887ff8fc5e79a410",
  "original_prompt": "Ingested from linux-6.6.14/fs/internal.h",
  "human_readable_source": " \n \n\nstruct super_block;\nstruct file_system_type;\nstruct iomap;\nstruct iomap_ops;\nstruct linux_binprm;\nstruct path;\nstruct mount;\nstruct shrink_control;\nstruct fs_context;\nstruct pipe_inode_info;\nstruct iov_iter;\nstruct mnt_idmap;\n\n \n#ifdef CONFIG_BLOCK\nextern void __init bdev_cache_init(void);\n#else\nstatic inline void bdev_cache_init(void)\n{\n}\n#endif  \n\n \nint __block_write_begin_int(struct folio *folio, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, const struct iomap *iomap);\n\n \nextern void __init chrdev_init(void);\n\n \nextern const struct fs_context_operations legacy_fs_context_ops;\nextern int parse_monolithic_mount_data(struct fs_context *, void *);\nextern void vfs_clean_context(struct fs_context *fc);\nextern int finish_clean_context(struct fs_context *fc);\n\n \nextern int filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t\t   struct path *path, struct path *root);\nint do_rmdir(int dfd, struct filename *name);\nint do_unlinkat(int dfd, struct filename *name);\nint may_linkat(struct mnt_idmap *idmap, const struct path *link);\nint do_renameat2(int olddfd, struct filename *oldname, int newdfd,\n\t\t struct filename *newname, unsigned int flags);\nint do_mkdirat(int dfd, struct filename *name, umode_t mode);\nint do_symlinkat(struct filename *from, int newdfd, struct filename *to);\nint do_linkat(int olddfd, struct filename *old, int newdfd,\n\t\t\tstruct filename *new, int flags);\n\n \nextern struct vfsmount *lookup_mnt(const struct path *);\nextern int finish_automount(struct vfsmount *, const struct path *);\n\nextern int sb_prepare_remount_readonly(struct super_block *);\n\nextern void __init mnt_init(void);\n\nextern int __mnt_want_write_file(struct file *);\nextern void __mnt_drop_write_file(struct file *);\n\nextern void dissolve_on_fput(struct vfsmount *);\nextern bool may_mount(void);\n\nint path_mount(const char *dev_name, struct path *path,\n\t\tconst char *type_page, unsigned long flags, void *data_page);\nint path_umount(struct path *path, int flags);\n\n \nextern void chroot_fs_refs(const struct path *, const struct path *);\n\n \nstruct file *alloc_empty_file(int flags, const struct cred *cred);\nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred);\nstruct file *alloc_empty_backing_file(int flags, const struct cred *cred);\n\nstatic inline void put_file_access(struct file *file)\n{\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\n\t\ti_readcount_dec(file->f_inode);\n\t} else if (file->f_mode & FMODE_WRITER) {\n\t\tput_write_access(file->f_inode);\n\t\t__mnt_drop_write(file->f_path.mnt);\n\t}\n}\n\n \nextern int reconfigure_super(struct fs_context *);\nextern bool super_trylock_shared(struct super_block *sb);\nstruct super_block *user_get_super(dev_t, bool excl);\nvoid put_super(struct super_block *sb);\nextern bool mount_capable(struct fs_context *);\nint sb_init_dio_done_wq(struct super_block *sb);\n\n \nstatic inline void sb_start_ro_state_change(struct super_block *sb)\n{\n\tWRITE_ONCE(sb->s_readonly_remount, 1);\n\t \n\tsmp_wmb();\n}\n\n \nstatic inline void sb_end_ro_state_change(struct super_block *sb)\n{\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(sb->s_readonly_remount, 0);\n}\n\n \nstruct open_flags {\n\tint open_flag;\n\tumode_t mode;\n\tint acc_mode;\n\tint intent;\n\tint lookup_flags;\n};\nextern struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op);\nextern struct file *do_file_open_root(const struct path *,\n\t\tconst char *, const struct open_flags *);\nextern struct open_how build_open_how(int flags, umode_t mode);\nextern int build_open_flags(const struct open_how *how, struct open_flags *op);\nextern struct file *__close_fd_get_file(unsigned int fd);\n\nlong do_sys_ftruncate(unsigned int fd, loff_t length, int small);\nint chmod_common(const struct path *path, umode_t mode);\nint do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,\n\t\tint flag);\nint chown_common(const struct path *path, uid_t user, gid_t group);\nextern int vfs_open(const struct path *, struct file *);\n\n \nextern long prune_icache_sb(struct super_block *sb, struct shrink_control *sc);\nint dentry_needs_remove_privs(struct mnt_idmap *, struct dentry *dentry);\nbool in_group_or_capable(struct mnt_idmap *idmap,\n\t\t\t const struct inode *inode, vfsgid_t vfsgid);\nvoid lock_two_inodes(struct inode *inode1, struct inode *inode2,\n\t\t     unsigned subclass1, unsigned subclass2);\n\n \nextern long get_nr_dirty_inodes(void);\nvoid invalidate_inodes(struct super_block *sb);\n\n \nextern int d_set_mounted(struct dentry *dentry);\nextern long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc);\nextern struct dentry *d_alloc_cursor(struct dentry *);\nextern struct dentry * d_alloc_pseudo(struct super_block *, const struct qstr *);\nextern char *simple_dname(struct dentry *, char *, int);\nextern void dput_to_list(struct dentry *, struct list_head *);\nextern void shrink_dentry_list(struct list_head *);\n\n \nextern const struct file_operations pipefifo_fops;\n\n \nextern void group_pin_kill(struct hlist_head *p);\nextern void mnt_pin_kill(struct mount *m);\n\n \nextern const struct dentry_operations ns_dentry_operations;\n\n \n\nint getname_statx_lookup_flags(int flags);\nint do_statx(int dfd, struct filename *filename, unsigned int flags,\n\t     unsigned int mask, struct statx __user *buffer);\n\n \nlong splice_file_to_pipe(struct file *in,\n\t\t\t struct pipe_inode_info *opipe,\n\t\t\t loff_t *offset,\n\t\t\t size_t len, unsigned int flags);\n\n \nstruct xattr_name {\n\tchar name[XATTR_NAME_MAX + 1];\n};\n\nstruct xattr_ctx {\n\t \n\tunion {\n\t\tconst void __user *cvalue;\n\t\tvoid __user *value;\n\t};\n\tvoid *kvalue;\n\tsize_t size;\n\t \n\tstruct xattr_name *kname;\n\tunsigned int flags;\n};\n\n\nssize_t do_getxattr(struct mnt_idmap *idmap,\n\t\t    struct dentry *d,\n\t\t    struct xattr_ctx *ctx);\n\nint setxattr_copy(const char __user *name, struct xattr_ctx *ctx);\nint do_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tstruct xattr_ctx *ctx);\nint may_write_xattr(struct mnt_idmap *idmap, struct inode *inode);\n\n#ifdef CONFIG_FS_POSIX_ACL\nint do_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t       const char *acl_name, const void *kvalue, size_t size);\nssize_t do_get_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   const char *acl_name, void *kvalue, size_t size);\n#else\nstatic inline int do_set_acl(struct mnt_idmap *idmap,\n\t\t\t     struct dentry *dentry, const char *acl_name,\n\t\t\t     const void *kvalue, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline ssize_t do_get_acl(struct mnt_idmap *idmap,\n\t\t\t\t struct dentry *dentry, const char *acl_name,\n\t\t\t\t void *kvalue, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nssize_t __kernel_write_iter(struct file *file, struct iov_iter *from, loff_t *pos);\n\n \nstruct mnt_idmap *alloc_mnt_idmap(struct user_namespace *mnt_userns);\nstruct mnt_idmap *mnt_idmap_get(struct mnt_idmap *idmap);\nvoid mnt_idmap_put(struct mnt_idmap *idmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}