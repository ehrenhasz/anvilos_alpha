{
  "module_name": "mount.h",
  "hash_id": "3ed6f6601363f18cda34590848bb06ec5ccf148578e947c14d4b401b1cca6be5",
  "original_prompt": "Ingested from linux-6.6.14/fs/mount.h",
  "human_readable_source": " \n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/ns_common.h>\n#include <linux/fs_pin.h>\n\nstruct mnt_namespace {\n\tstruct ns_common\tns;\n\tstruct mount *\troot;\n\t \n\tstruct list_head\tlist;\n\tspinlock_t\t\tns_lock;\n\tstruct user_namespace\t*user_ns;\n\tstruct ucounts\t\t*ucounts;\n\tu64\t\t\tseq;\t \n\twait_queue_head_t poll;\n\tu64 event;\n\tunsigned int\t\tmounts;  \n\tunsigned int\t\tpending_mounts;\n} __randomize_layout;\n\nstruct mnt_pcp {\n\tint mnt_count;\n\tint mnt_writers;\n};\n\nstruct mountpoint {\n\tstruct hlist_node m_hash;\n\tstruct dentry *m_dentry;\n\tstruct hlist_head m_list;\n\tint m_count;\n};\n\nstruct mount {\n\tstruct hlist_node mnt_hash;\n\tstruct mount *mnt_parent;\n\tstruct dentry *mnt_mountpoint;\n\tstruct vfsmount mnt;\n\tunion {\n\t\tstruct rcu_head mnt_rcu;\n\t\tstruct llist_node mnt_llist;\n\t};\n#ifdef CONFIG_SMP\n\tstruct mnt_pcp __percpu *mnt_pcp;\n#else\n\tint mnt_count;\n\tint mnt_writers;\n#endif\n\tstruct list_head mnt_mounts;\t \n\tstruct list_head mnt_child;\t \n\tstruct list_head mnt_instance;\t \n\tconst char *mnt_devname;\t \n\tstruct list_head mnt_list;\n\tstruct list_head mnt_expire;\t \n\tstruct list_head mnt_share;\t \n\tstruct list_head mnt_slave_list; \n\tstruct list_head mnt_slave;\t \n\tstruct mount *mnt_master;\t \n\tstruct mnt_namespace *mnt_ns;\t \n\tstruct mountpoint *mnt_mp;\t \n\tunion {\n\t\tstruct hlist_node mnt_mp_list;\t \n\t\tstruct hlist_node mnt_umount;\n\t};\n\tstruct list_head mnt_umounting;  \n#ifdef CONFIG_FSNOTIFY\n\tstruct fsnotify_mark_connector __rcu *mnt_fsnotify_marks;\n\t__u32 mnt_fsnotify_mask;\n#endif\n\tint mnt_id;\t\t\t \n\tint mnt_group_id;\t\t \n\tint mnt_expiry_mark;\t\t \n\tstruct hlist_head mnt_pins;\n\tstruct hlist_head mnt_stuck_children;\n} __randomize_layout;\n\n#define MNT_NS_INTERNAL ERR_PTR(-EINVAL)  \n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}\n\nstatic inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}\n\nstatic inline int is_mounted(struct vfsmount *mnt)\n{\n\t \n\treturn !IS_ERR_OR_NULL(real_mount(mnt)->mnt_ns);\n}\n\nextern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline bool __path_is_mountpoint(const struct path *path)\n{\n\tstruct mount *m = __lookup_mnt(path->mnt, path->dentry);\n\treturn m && likely(!(m->mnt.mnt_flags & MNT_SYNC_UMOUNT));\n}\n\nextern void __detach_mounts(struct dentry *dentry);\n\nstatic inline void detach_mounts(struct dentry *dentry)\n{\n\tif (!d_mountpoint(dentry))\n\t\treturn;\n\t__detach_mounts(dentry);\n}\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\trefcount_inc(&ns->ns.count);\n}\n\nextern seqlock_t mount_lock;\n\nstruct proc_mounts {\n\tstruct mnt_namespace *ns;\n\tstruct path root;\n\tint (*show)(struct seq_file *, struct vfsmount *);\n\tstruct mount cursor;\n};\n\nextern const struct seq_operations mounts_op;\n\nextern bool __is_local_mountpoint(struct dentry *dentry);\nstatic inline bool is_local_mountpoint(struct dentry *dentry)\n{\n\tif (!d_mountpoint(dentry))\n\t\treturn false;\n\n\treturn __is_local_mountpoint(dentry);\n}\n\nstatic inline bool is_anon_ns(struct mnt_namespace *ns)\n{\n\treturn ns->seq == 0;\n}\n\nextern void mnt_cursor_del(struct mnt_namespace *ns, struct mount *cursor);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}