{
  "module_name": "fhandle.c",
  "hash_id": "6fca1ffcd817958aa1bdbb68fac817f41d11f975ff04ac6493dacb1a792b0d5c",
  "original_prompt": "Ingested from linux-6.6.14/fs/fhandle.c",
  "human_readable_source": "\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/exportfs.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include \"internal.h\"\n#include \"mount.h\"\n\nstatic long do_sys_name_to_handle(const struct path *path,\n\t\t\t\t  struct file_handle __user *ufh,\n\t\t\t\t  int __user *mnt_id, int fh_flags)\n{\n\tlong retval;\n\tstruct file_handle f_handle;\n\tint handle_dwords, handle_bytes;\n\tstruct file_handle *handle = NULL;\n\n\t \n\tif (!path->dentry->d_sb->s_export_op ||\n\t    (!(fh_flags & EXPORT_FH_FID) &&\n\t     !path->dentry->d_sb->s_export_op->fh_to_dentry))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle)))\n\t\treturn -EFAULT;\n\n\tif (f_handle.handle_bytes > MAX_HANDLE_SZ)\n\t\treturn -EINVAL;\n\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\t \n\thandle_dwords = f_handle.handle_bytes >> 2;\n\n\t \n\tretval = exportfs_encode_fh(path->dentry,\n\t\t\t\t    (struct fid *)handle->f_handle,\n\t\t\t\t    &handle_dwords, fh_flags);\n\thandle->handle_type = retval;\n\t \n\thandle_bytes = handle_dwords * sizeof(u32);\n\thandle->handle_bytes = handle_bytes;\n\tif ((handle->handle_bytes > f_handle.handle_bytes) ||\n\t    (retval == FILEID_INVALID) || (retval < 0)) {\n\t\t \n\t\tif (retval == FILEID_INVALID || retval == -ENOSPC)\n\t\t\tretval = -EOVERFLOW;\n\t\t \n\t\thandle_bytes = 0;\n\t} else\n\t\tretval = 0;\n\t \n\tif (put_user(real_mount(path->mnt)->mnt_id, mnt_id) ||\n\t    copy_to_user(ufh, handle,\n\t\t\t sizeof(struct file_handle) + handle_bytes))\n\t\tretval = -EFAULT;\n\tkfree(handle);\n\treturn retval;\n}\n\n \nSYSCALL_DEFINE5(name_to_handle_at, int, dfd, const char __user *, name,\n\t\tstruct file_handle __user *, handle, int __user *, mnt_id,\n\t\tint, flag)\n{\n\tstruct path path;\n\tint lookup_flags;\n\tint fh_flags;\n\tint err;\n\n\tif (flag & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH | AT_HANDLE_FID))\n\t\treturn -EINVAL;\n\n\tlookup_flags = (flag & AT_SYMLINK_FOLLOW) ? LOOKUP_FOLLOW : 0;\n\tfh_flags = (flag & AT_HANDLE_FID) ? EXPORT_FH_FID : 0;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\terr = user_path_at(dfd, name, lookup_flags, &path);\n\tif (!err) {\n\t\terr = do_sys_name_to_handle(&path, handle, mnt_id, fh_flags);\n\t\tpath_put(&path);\n\t}\n\treturn err;\n}\n\nstatic struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}\n\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}\n\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t \n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}\n\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t \n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t \n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}\n\nstatic long do_handle_open(int mountdirfd, struct file_handle __user *ufh,\n\t\t\t   int open_flag)\n{\n\tlong retval = 0;\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tretval = handle_to_path(mountdirfd, ufh, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tfd = get_unused_fd_flags(open_flag);\n\tif (fd < 0) {\n\t\tpath_put(&path);\n\t\treturn fd;\n\t}\n\tfile = file_open_root(&path, \"\", open_flag, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tretval =  PTR_ERR(file);\n\t} else {\n\t\tretval = fd;\n\t\tfd_install(fd, file);\n\t}\n\tpath_put(&path);\n\treturn retval;\n}\n\n \nSYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\tstruct file_handle __user *, handle,\n\t\tint, flags)\n{\n\tlong ret;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\tret = do_handle_open(mountdirfd, handle, flags);\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n \nCOMPAT_SYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\t\t     struct file_handle __user *, handle, int, flags)\n{\n\treturn do_handle_open(mountdirfd, handle, flags);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}