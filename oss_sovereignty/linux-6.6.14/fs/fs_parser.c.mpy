{
  "module_name": "fs_parser.c",
  "hash_id": "57e5b34542fdec2a9777b7b5a3072ca5a34c5b3c8a0b6405e514da761e779e62",
  "original_prompt": "Ingested from linux-6.6.14/fs/fs_parser.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include \"internal.h\"\n\nstatic const struct constant_table bool_names[] = {\n\t{ \"0\",\t\tfalse },\n\t{ \"1\",\t\ttrue },\n\t{ \"false\",\tfalse },\n\t{ \"no\",\t\tfalse },\n\t{ \"true\",\ttrue },\n\t{ \"yes\",\ttrue },\n\t{ },\n};\n\nstatic const struct constant_table *\n__lookup_constant(const struct constant_table *tbl, const char *name)\n{\n\tfor ( ; tbl->name; tbl++)\n\t\tif (strcmp(name, tbl->name) == 0)\n\t\t\treturn tbl;\n\treturn NULL;\n}\n\n \nint lookup_constant(const struct constant_table *tbl, const char *name, int not_found)\n{\n\tconst struct constant_table *p = __lookup_constant(tbl, name);\n\n\treturn p ? p->value : not_found;\n}\nEXPORT_SYMBOL(lookup_constant);\n\nstatic inline bool is_flag(const struct fs_parameter_spec *p)\n{\n\treturn p->type == NULL;\n}\n\nstatic const struct fs_parameter_spec *fs_lookup_key(\n\tconst struct fs_parameter_spec *desc,\n\tstruct fs_parameter *param, bool *negated)\n{\n\tconst struct fs_parameter_spec *p, *other = NULL;\n\tconst char *name = param->key;\n\tbool want_flag = param->type == fs_value_is_flag;\n\n\t*negated = false;\n\tfor (p = desc; p->name; p++) {\n\t\tif (strcmp(p->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (likely(is_flag(p) == want_flag))\n\t\t\treturn p;\n\t\tother = p;\n\t}\n\tif (want_flag) {\n\t\tif (name[0] == 'n' && name[1] == 'o' && name[2]) {\n\t\t\tfor (p = desc; p->name; p++) {\n\t\t\t\tif (strcmp(p->name, name + 2) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(p->flags & fs_param_neg_with_no))\n\t\t\t\t\tcontinue;\n\t\t\t\t*negated = true;\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t}\n\treturn other;\n}\n\n \nint __fs_parse(struct p_log *log,\n\t     const struct fs_parameter_spec *desc,\n\t     struct fs_parameter *param,\n\t     struct fs_parse_result *result)\n{\n\tconst struct fs_parameter_spec *p;\n\n\tresult->uint_64 = 0;\n\n\tp = fs_lookup_key(desc, param, &result->negated);\n\tif (!p)\n\t\treturn -ENOPARAM;\n\n\tif (p->flags & fs_param_deprecated)\n\t\twarn_plog(log, \"Deprecated parameter '%s'\", param->key);\n\n\t \n\tif (is_flag(p)) {\n\t\tif (param->type != fs_value_is_flag)\n\t\t\treturn inval_plog(log, \"Unexpected value for '%s'\",\n\t\t\t\t      param->key);\n\t\tresult->boolean = !result->negated;\n\t} else  {\n\t\tint ret = p->type(log, p, param, result);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn p->opt;\n}\nEXPORT_SYMBOL(__fs_parse);\n\n \nint fs_lookup_param(struct fs_context *fc,\n\t\t    struct fs_parameter *param,\n\t\t    bool want_bdev,\n\t\t    unsigned int flags,\n\t\t    struct path *_path)\n{\n\tstruct filename *f;\n\tbool put_f;\n\tint ret;\n\n\tswitch (param->type) {\n\tcase fs_value_is_string:\n\t\tf = getname_kernel(param->string);\n\t\tif (IS_ERR(f))\n\t\t\treturn PTR_ERR(f);\n\t\tput_f = true;\n\t\tbreak;\n\tcase fs_value_is_filename:\n\t\tf = param->name;\n\t\tput_f = false;\n\t\tbreak;\n\tdefault:\n\t\treturn invalf(fc, \"%s: not usable as path\", param->key);\n\t}\n\n\tret = filename_lookup(param->dirfd, f, flags, _path, NULL);\n\tif (ret < 0) {\n\t\terrorf(fc, \"%s: Lookup failure for '%s'\", param->key, f->name);\n\t\tgoto out;\n\t}\n\n\tif (want_bdev &&\n\t    !S_ISBLK(d_backing_inode(_path->dentry)->i_mode)) {\n\t\tpath_put(_path);\n\t\t_path->dentry = NULL;\n\t\t_path->mnt = NULL;\n\t\terrorf(fc, \"%s: Non-blockdev passed as '%s'\",\n\t\t       param->key, f->name);\n\t\tret = -ENOTBLK;\n\t}\n\nout:\n\tif (put_f)\n\t\tputname(f);\n\treturn ret;\n}\nEXPORT_SYMBOL(fs_lookup_param);\n\nstatic int fs_param_bad_value(struct p_log *log, struct fs_parameter *param)\n{\n\treturn inval_plog(log, \"Bad value for '%s'\", param->key);\n}\n\nint fs_param_is_bool(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t     struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tint b;\n\tif (param->type != fs_value_is_string)\n\t\treturn fs_param_bad_value(log, param);\n\tif (!*param->string && (p->flags & fs_param_can_be_empty))\n\t\treturn 0;\n\tb = lookup_constant(bool_names, param->string, -1);\n\tif (b == -1)\n\t\treturn fs_param_bad_value(log, param);\n\tresult->boolean = b;\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_bool);\n\nint fs_param_is_u32(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t    struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tint base = (unsigned long)p->data;\n\tif (param->type != fs_value_is_string)\n\t\treturn fs_param_bad_value(log, param);\n\tif (!*param->string && (p->flags & fs_param_can_be_empty))\n\t\treturn 0;\n\tif (kstrtouint(param->string, base, &result->uint_32) < 0)\n\t\treturn fs_param_bad_value(log, param);\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_u32);\n\nint fs_param_is_s32(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t    struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tif (param->type != fs_value_is_string)\n\t\treturn fs_param_bad_value(log, param);\n\tif (!*param->string && (p->flags & fs_param_can_be_empty))\n\t\treturn 0;\n\tif (kstrtoint(param->string, 0, &result->int_32) < 0)\n\t\treturn fs_param_bad_value(log, param);\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_s32);\n\nint fs_param_is_u64(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t    struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tif (param->type != fs_value_is_string)\n\t\treturn fs_param_bad_value(log, param);\n\tif (!*param->string && (p->flags & fs_param_can_be_empty))\n\t\treturn 0;\n\tif (kstrtoull(param->string, 0, &result->uint_64) < 0)\n\t\treturn fs_param_bad_value(log, param);\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_u64);\n\nint fs_param_is_enum(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t     struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tconst struct constant_table *c;\n\tif (param->type != fs_value_is_string)\n\t\treturn fs_param_bad_value(log, param);\n\tif (!*param->string && (p->flags & fs_param_can_be_empty))\n\t\treturn 0;\n\tc = __lookup_constant(p->data, param->string);\n\tif (!c)\n\t\treturn fs_param_bad_value(log, param);\n\tresult->uint_32 = c->value;\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_enum);\n\nint fs_param_is_string(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t       struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tif (param->type != fs_value_is_string ||\n\t    (!*param->string && !(p->flags & fs_param_can_be_empty)))\n\t\treturn fs_param_bad_value(log, param);\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_string);\n\nint fs_param_is_blob(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t     struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tif (param->type != fs_value_is_blob)\n\t\treturn fs_param_bad_value(log, param);\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_blob);\n\nint fs_param_is_fd(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t  struct fs_parameter *param, struct fs_parse_result *result)\n{\n\tswitch (param->type) {\n\tcase fs_value_is_string:\n\t\tif ((!*param->string && !(p->flags & fs_param_can_be_empty)) ||\n\t\t    kstrtouint(param->string, 0, &result->uint_32) < 0)\n\t\t\tbreak;\n\t\tif (result->uint_32 <= INT_MAX)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase fs_value_is_file:\n\t\tresult->uint_32 = param->dirfd;\n\t\tif (result->uint_32 <= INT_MAX)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn fs_param_bad_value(log, param);\n}\nEXPORT_SYMBOL(fs_param_is_fd);\n\nint fs_param_is_blockdev(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t  struct fs_parameter *param, struct fs_parse_result *result)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_blockdev);\n\nint fs_param_is_path(struct p_log *log, const struct fs_parameter_spec *p,\n\t\t     struct fs_parameter *param, struct fs_parse_result *result)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(fs_param_is_path);\n\n#ifdef CONFIG_VALIDATE_FS_PARSER\n \nbool validate_constant_table(const struct constant_table *tbl, size_t tbl_size,\n\t\t\t     int low, int high, int special)\n{\n\tsize_t i;\n\tbool good = true;\n\n\tif (tbl_size == 0) {\n\t\tpr_warn(\"VALIDATE C-TBL: Empty\\n\");\n\t\treturn true;\n\t}\n\n\tfor (i = 0; i < tbl_size; i++) {\n\t\tif (!tbl[i].name) {\n\t\t\tpr_err(\"VALIDATE C-TBL[%zu]: Null\\n\", i);\n\t\t\tgood = false;\n\t\t} else if (i > 0 && tbl[i - 1].name) {\n\t\t\tint c = strcmp(tbl[i-1].name, tbl[i].name);\n\n\t\t\tif (c == 0) {\n\t\t\t\tpr_err(\"VALIDATE C-TBL[%zu]: Duplicate %s\\n\",\n\t\t\t\t       i, tbl[i].name);\n\t\t\t\tgood = false;\n\t\t\t}\n\t\t\tif (c > 0) {\n\t\t\t\tpr_err(\"VALIDATE C-TBL[%zu]: Missorted %s>=%s\\n\",\n\t\t\t\t       i, tbl[i-1].name, tbl[i].name);\n\t\t\t\tgood = false;\n\t\t\t}\n\t\t}\n\n\t\tif (tbl[i].value != special &&\n\t\t    (tbl[i].value < low || tbl[i].value > high)) {\n\t\t\tpr_err(\"VALIDATE C-TBL[%zu]: %s->%d const out of range (%d-%d)\\n\",\n\t\t\t       i, tbl[i].name, tbl[i].value, low, high);\n\t\t\tgood = false;\n\t\t}\n\t}\n\n\treturn good;\n}\n\n \nbool fs_validate_description(const char *name,\n\tconst struct fs_parameter_spec *desc)\n{\n\tconst struct fs_parameter_spec *param, *p2;\n\tbool good = true;\n\n\tfor (param = desc; param->name; param++) {\n\t\t \n\t\tfor (p2 = desc; p2 < param; p2++) {\n\t\t\tif (strcmp(param->name, p2->name) == 0) {\n\t\t\t\tif (is_flag(param) != is_flag(p2))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_err(\"VALIDATE %s: PARAM[%s]: Duplicate\\n\",\n\t\t\t\t       name, param->name);\n\t\t\t\tgood = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn good;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}