{
  "module_name": "ext4_jbd2.c",
  "hash_id": "73333636b07bcd8f2bc2610adcca974fe79a714d8e4ec553b263f786582339cc",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/ext4_jbd2.c",
  "human_readable_source": "\n \n\n#include \"ext4_jbd2.h\"\n\n#include <trace/events/ext4.h>\n\nint ext4_inode_journal_mode(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) == NULL)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t \n\t \n\tif (!S_ISREG(inode->i_mode) ||\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EA_INODE) ||\n\t    test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA) &&\n\t    !test_opt(inode->i_sb, DELALLOC))) {\n\t\t \n\t\tif (S_ISREG(inode->i_mode) && IS_ENCRYPTED(inode))\n\t\t\treturn EXT4_INODE_ORDERED_DATA_MODE;   \n\t\treturn EXT4_INODE_JOURNAL_DATA_MODE;\t \n\t}\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\treturn EXT4_INODE_ORDERED_DATA_MODE;\t \n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t \n\tBUG();\n}\n\n \nstatic handle_t *ext4_get_nojournal(void)\n{\n\thandle_t *handle = current->journal_info;\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\n\n\tref_cnt++;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n\treturn handle;\n}\n\n\n \nstatic void ext4_put_nojournal(handle_t *handle)\n{\n\tunsigned long ref_cnt = (unsigned long)handle;\n\n\tBUG_ON(ref_cnt == 0);\n\n\tref_cnt--;\n\thandle = (handle_t *)ref_cnt;\n\n\tcurrent->journal_info = handle;\n}\n\n \nstatic int ext4_journal_check_start(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tmight_sleep();\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn -EIO;\n\n\tif (WARN_ON_ONCE(sb_rdonly(sb)))\n\t\treturn -EROFS;\n\n\tWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tjournal = EXT4_SB(sb)->s_journal;\n\t \n\tif (journal && is_journal_aborted(journal)) {\n\t\text4_abort(sb, -journal->j_errno, \"Detected aborted journal\");\n\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\nhandle_t *__ext4_journal_start_sb(struct inode *inode,\n\t\t\t\t  struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks,\n\t\t\t\t  int revoke_creds)\n{\n\tjournal_t *journal;\n\tint err;\n\tif (inode)\n\t\ttrace_ext4_journal_start_inode(inode, blocks, rsv_blocks,\n\t\t\t\t\trevoke_creds, type,\n\t\t\t\t\t_RET_IP_);\n\telse\n\t\ttrace_ext4_journal_start_sb(sb, blocks, rsv_blocks,\n\t\t\t\t\trevoke_creds, type,\n\t\t\t\t\t_RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal || (EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY))\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, revoke_creds,\n\t\t\t\t   GFP_NOFS, type, line);\n}\n\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\terr = handle->h_err;\n\tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb,\n\t\t\t\tjbd2_handle_buffer_credits(handle), _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}\n\nint __ext4_journal_ensure_credits(handle_t *handle, int check_cred,\n\t\t\t\t  int extend_cred, int revoke_cred)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tif (jbd2_handle_buffer_credits(handle) >= check_cred &&\n\t    handle->h_revoke_credits >= revoke_cred)\n\t\treturn 0;\n\textend_cred = max(0, extend_cred - jbd2_handle_buffer_credits(handle));\n\trevoke_cred = max(0, revoke_cred - handle->h_revoke_credits);\n\treturn ext4_journal_extend(handle, extend_cred, revoke_cred);\n}\n\nstatic void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t\t      const char *err_fn,\n\t\t\t\t      struct buffer_head *bh,\n\t\t\t\t      handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\n\tjbd2_journal_abort_handle(handle);\n}\n\nstatic void ext4_check_bdev_write_error(struct super_block *sb)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\n\t \n\tif (errseq_check(&mapping->wb_err, READ_ONCE(sbi->s_bdev_wb_err))) {\n\t\tspin_lock(&sbi->s_bdev_wb_lock);\n\t\terr = errseq_check_and_advance(&mapping->wb_err, &sbi->s_bdev_wb_err);\n\t\tspin_unlock(&sbi->s_bdev_wb_lock);\n\t\tif (err)\n\t\t\text4_error_err(sb, -err,\n\t\t\t\t       \"Error while async write back metadata\");\n\t}\n}\n\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\n\t\t\t\t    handle_t *handle, struct super_block *sb,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    enum ext4_journal_trigger_type trigger_type)\n{\n\tint err;\n\n\tmight_sleep();\n\n\text4_check_bdev_write_error(sb);\n\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (trigger_type == EXT4_JTR_NONE || !ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\tBUG_ON(trigger_type >= EXT4_JOURNAL_TRIGGER_COUNT);\n\tjbd2_journal_set_triggers(bh,\n\t\t&EXT4_SB(sb)->s_journal_triggers[trigger_type].tr_triggers);\n\treturn 0;\n}\n\n \nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\n\t\t  int is_metadata, struct inode *inode,\n\t\t  struct buffer_head *bh, ext4_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext4_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\text4_debug(\"forgetting bh %p: is_metadata=%d, mode %o, data mode %x\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t \n\tif (!ext4_handle_valid(handle)) {\n\t\tbforget(bh);\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext4_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call jbd2_journal_forget\");\n\t\t\terr = jbd2_journal_forget(handle, bh);\n\t\t\tif (err)\n\t\t\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t\t\t  bh, handle, err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tBUFFER_TRACE(bh, \"call jbd2_journal_revoke\");\n\terr = jbd2_journal_revoke(handle, blocknr, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__,\n\t\t\t\t\t  bh, handle, err);\n\t\t__ext4_error(inode->i_sb, where, line, true, -err, 0,\n\t\t\t     \"error %d when attempting revoke\", err);\n\t}\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}\n\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\n\t\t\t\thandle_t *handle, struct super_block *sb,\n\t\t\t\tstruct buffer_head *bh,\n\t\t\t\tenum ext4_journal_trigger_type trigger_type)\n{\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\n\terr = jbd2_journal_get_create_access(handle, bh);\n\tif (err) {\n\t\text4_journal_abort_handle(where, line, __func__, bh, handle,\n\t\t\t\t\t  err);\n\t\treturn err;\n\t}\n\tif (trigger_type == EXT4_JTR_NONE || !ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\tBUG_ON(trigger_type >= EXT4_JOURNAL_TRIGGER_COUNT);\n\tjbd2_journal_set_triggers(bh,\n\t\t&EXT4_SB(sb)->s_journal_triggers[trigger_type].tr_triggers);\n\treturn 0;\n}\n\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\n\t\t\t\t handle_t *handle, struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint err = 0;\n\n\tmight_sleep();\n\n\tset_buffer_meta(bh);\n\tset_buffer_prio(bh);\n\tset_buffer_uptodate(bh);\n\tif (ext4_handle_valid(handle)) {\n\t\terr = jbd2_journal_dirty_metadata(handle, bh);\n\t\t \n\t\tif (!is_handle_aborted(handle) && WARN_ON_ONCE(err)) {\n\t\t\text4_journal_abort_handle(where, line, __func__, bh,\n\t\t\t\t\t\t  handle, err);\n\t\t\tif (inode == NULL) {\n\t\t\t\tpr_err(\"EXT4: jbd2_journal_dirty_metadata \"\n\t\t\t\t       \"failed: handle type %u started at \"\n\t\t\t\t       \"line %u, credits %u/%u, errcode %d\",\n\t\t\t\t       handle->h_type,\n\t\t\t\t       handle->h_line_no,\n\t\t\t\t       handle->h_requested_credits,\n\t\t\t\t       jbd2_handle_buffer_credits(handle), err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_error_inode(inode, where, line,\n\t\t\t\t\t bh->b_blocknr,\n\t\t\t\t\t \"journal_dirty_metadata failed: \"\n\t\t\t\t\t \"handle type %u started at line %u, \"\n\t\t\t\t\t \"credits %u/%u, errcode %d\",\n\t\t\t\t\t handle->h_type,\n\t\t\t\t\t handle->h_line_no,\n\t\t\t\t\t handle->h_requested_credits,\n\t\t\t\t\t jbd2_handle_buffer_credits(handle),\n\t\t\t\t\t err);\n\t\t}\n\t} else {\n\t\tif (inode)\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\telse\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (inode && inode_needs_sync(inode)) {\n\t\t\tsync_dirty_buffer(bh);\n\t\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\t\text4_error_inode_err(inode, where, line,\n\t\t\t\t\t\t     bh->b_blocknr, EIO,\n\t\t\t\t\t\"IO error syncing itable block\");\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}