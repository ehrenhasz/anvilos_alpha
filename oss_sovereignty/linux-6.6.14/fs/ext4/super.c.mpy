{
  "module_name": "super.c",
  "hash_id": "fb27296ad8c7e761dd23fa9de0e0380822ab5c2525da261d00c3788920f1c846",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/super.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/vfs.h>\n#include <linux/random.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/ctype.h>\n#include <linux/log2.h>\n#include <linux/crc16.h>\n#include <linux/dax.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/unicode.h>\n#include <linux/part_stat.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n\n#include \"ext4.h\"\n#include \"ext4_extents.h\"\t \n#include \"ext4_jbd2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"mballoc.h\"\n#include \"fsmap.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/ext4.h>\n\nstatic struct ext4_lazy_init *ext4_li_info;\nstatic DEFINE_MUTEX(ext4_li_mtx);\nstatic struct ratelimit_state ext4_mount_msg_ratelimit;\n\nstatic int ext4_load_journal(struct super_block *, struct ext4_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root);\nstatic void ext4_update_super(struct super_block *sb);\nstatic int ext4_commit_super(struct super_block *sb);\nstatic int ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic int ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t  struct ext4_super_block *es);\nstatic int ext4_sync_fs(struct super_block *sb, int wait);\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_destroy_lazyinit_thread(void);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic void ext4_clear_request_list(void);\nstatic struct inode *ext4_get_journal_inode(struct super_block *sb,\n\t\t\t\t\t    unsigned int journal_inum);\nstatic int ext4_validate_options(struct fs_context *fc);\nstatic int ext4_check_opt_consistency(struct fs_context *fc,\n\t\t\t\t      struct super_block *sb);\nstatic void ext4_apply_options(struct fs_context *fc, struct super_block *sb);\nstatic int ext4_parse_param(struct fs_context *fc, struct fs_parameter *param);\nstatic int ext4_get_tree(struct fs_context *fc);\nstatic int ext4_reconfigure(struct fs_context *fc);\nstatic void ext4_fc_free(struct fs_context *fc);\nstatic int ext4_init_fs_context(struct fs_context *fc);\nstatic void ext4_kill_sb(struct super_block *sb);\nstatic const struct fs_parameter_spec ext4_param_specs[];\n\n \n\nstatic const struct fs_context_operations ext4_context_ops = {\n\t.parse_param\t= ext4_parse_param,\n\t.get_tree\t= ext4_get_tree,\n\t.reconfigure\t= ext4_reconfigure,\n\t.free\t\t= ext4_fc_free,\n};\n\n\n#if !defined(CONFIG_EXT2_FS) && !defined(CONFIG_EXT2_FS_MODULE) && defined(CONFIG_EXT4_USE_FOR_EXT2)\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"ext2\",\n\t.init_fs_context\t= ext4_init_fs_context,\n\t.parameters\t\t= ext4_param_specs,\n\t.kill_sb\t\t= ext4_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext2\");\nMODULE_ALIAS(\"ext2\");\n#define IS_EXT2_SB(sb) ((sb)->s_type == &ext2_fs_type)\n#else\n#define IS_EXT2_SB(sb) (0)\n#endif\n\n\nstatic struct file_system_type ext3_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"ext3\",\n\t.init_fs_context\t= ext4_init_fs_context,\n\t.parameters\t\t= ext4_param_specs,\n\t.kill_sb\t\t= ext4_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext3\");\nMODULE_ALIAS(\"ext3\");\n#define IS_EXT3_SB(sb) ((sb)->s_type == &ext3_fs_type)\n\n\nstatic inline void __ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags,\n\t\t\t\t  bh_end_io_t *end_io)\n{\n\t \n\tclear_buffer_verified(bh);\n\n\tbh->b_end_io = end_io ? end_io : end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ | op_flags, bh);\n}\n\nvoid ext4_read_bh_nowait(struct buffer_head *bh, blk_opf_t op_flags,\n\t\t\t bh_end_io_t *end_io)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (ext4_buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\t__ext4_read_bh(bh, op_flags, end_io);\n}\n\nint ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags, bh_end_io_t *end_io)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (ext4_buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\t__ext4_read_bh(bh, op_flags, end_io);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\n\nint ext4_read_bh_lock(struct buffer_head *bh, blk_opf_t op_flags, bool wait)\n{\n\tlock_buffer(bh);\n\tif (!wait) {\n\t\text4_read_bh_nowait(bh, op_flags, NULL);\n\t\treturn 0;\n\t}\n\treturn ext4_read_bh(bh, op_flags, NULL);\n}\n\n \nstatic struct buffer_head *__ext4_sb_bread_gfp(struct super_block *sb,\n\t\t\t\t\t       sector_t block,\n\t\t\t\t\t       blk_opf_t op_flags, gfp_t gfp)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tbh = sb_getblk_gfp(sb, block, gfp);\n\tif (bh == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (ext4_buffer_uptodate(bh))\n\t\treturn bh;\n\n\tret = ext4_read_bh_lock(bh, REQ_META | op_flags, true);\n\tif (ret) {\n\t\tput_bh(bh);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn bh;\n}\n\nstruct buffer_head *ext4_sb_bread(struct super_block *sb, sector_t block,\n\t\t\t\t   blk_opf_t op_flags)\n{\n\treturn __ext4_sb_bread_gfp(sb, block, op_flags, __GFP_MOVABLE);\n}\n\nstruct buffer_head *ext4_sb_bread_unmovable(struct super_block *sb,\n\t\t\t\t\t    sector_t block)\n{\n\treturn __ext4_sb_bread_gfp(sb, block, 0, 0);\n}\n\nvoid ext4_sb_breadahead_unmovable(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh = sb_getblk_gfp(sb, block, 0);\n\n\tif (likely(bh)) {\n\t\tif (trylock_buffer(bh))\n\t\t\text4_read_bh_nowait(bh, REQ_RAHEAD, NULL);\n\t\tbrelse(bh);\n\t}\n}\n\nstatic int ext4_verify_csum_type(struct super_block *sb,\n\t\t\t\t struct ext4_super_block *es)\n{\n\tif (!ext4_has_feature_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum_type == EXT4_CRC32C_CHKSUM;\n}\n\n__le32 ext4_superblock_csum(struct super_block *sb,\n\t\t\t    struct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct ext4_super_block, s_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ~0, (char *)es, offset);\n\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_superblock_csum_verify(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn es->s_checksum == ext4_superblock_csum(sb, es);\n}\n\nvoid ext4_superblock_csum_set(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tes->s_checksum = ext4_superblock_csum(sb, es);\n}\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}\n\n__u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}\n\n__u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}\n\n__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}\n\nvoid ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_block_bitmap_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_block_bitmap_hi = cpu_to_le32(blk >> 32);\n}\n\nvoid ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t   struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_bitmap_lo  = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_bitmap_hi = cpu_to_le32(blk >> 32);\n}\n\nvoid ext4_inode_table_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk)\n{\n\tbg->bg_inode_table_lo = cpu_to_le32((u32)blk);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_inode_table_hi = cpu_to_le32(blk >> 32);\n}\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}\n\nvoid ext4_free_inodes_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_inodes_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_inodes_count_hi = cpu_to_le16(count >> 16);\n}\n\nvoid ext4_used_dirs_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_used_dirs_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_used_dirs_count_hi = cpu_to_le16(count >> 16);\n}\n\nvoid ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}\n\nstatic void __ext4_update_tstamp(__le32 *lo, __u8 *hi, time64_t now)\n{\n\tnow = clamp_val(now, 0, (1ull << 40) - 1);\n\n\t*lo = cpu_to_le32(lower_32_bits(now));\n\t*hi = upper_32_bits(now);\n}\n\nstatic time64_t __ext4_get_tstamp(__le32 *lo, __u8 *hi)\n{\n\treturn ((time64_t)(*hi) << 32) + le32_to_cpu(*lo);\n}\n#define ext4_update_tstamp(es, tstamp) \\\n\t__ext4_update_tstamp(&(es)->tstamp, &(es)->tstamp ## _hi, \\\n\t\t\t     ktime_get_real_seconds())\n#define ext4_get_tstamp(es, tstamp) \\\n\t__ext4_get_tstamp(&(es)->tstamp, &(es)->tstamp ## _hi)\n\n#define EXT4_SB_REFRESH_INTERVAL_SEC (3600)  \n#define EXT4_SB_REFRESH_INTERVAL_KB (16384)  \n\n \nstatic void ext4_maybe_update_superblock(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tjournal_t *journal = sbi->s_journal;\n\ttime64_t now;\n\t__u64 last_update;\n\t__u64 lifetime_write_kbytes;\n\t__u64 diff_size;\n\n\tif (sb_rdonly(sb) || !(sb->s_flags & SB_ACTIVE) ||\n\t    !journal || (journal->j_flags & JBD2_UNMOUNT))\n\t\treturn;\n\n\tnow = ktime_get_real_seconds();\n\tlast_update = ext4_get_tstamp(es, s_wtime);\n\n\tif (likely(now - last_update < EXT4_SB_REFRESH_INTERVAL_SEC))\n\t\treturn;\n\n\tlifetime_write_kbytes = sbi->s_kbytes_written +\n\t\t((part_stat_read(sb->s_bdev, sectors[STAT_WRITE]) -\n\t\t  sbi->s_sectors_written_start) >> 1);\n\n\t \n\tdiff_size = lifetime_write_kbytes - le64_to_cpu(es->s_kbytes_written);\n\n\tif (diff_size > EXT4_SB_REFRESH_INTERVAL_KB)\n\t\tschedule_work(&EXT4_SB(sb)->s_sb_upd_work);\n}\n\n \nstatic int block_device_ejected(struct super_block *sb)\n{\n\tstruct inode *bd_inode = sb->s_bdev->bd_inode;\n\tstruct backing_dev_info *bdi = inode_to_bdi(bd_inode);\n\n\treturn bdi->dev == NULL;\n}\n\nstatic void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce;\n\n\tBUG_ON(txn->t_state == T_FINISHED);\n\n\text4_process_freed_data(sb, txn->t_tid);\n\text4_maybe_update_superblock(sb);\n\n\tspin_lock(&sbi->s_md_lock);\n\twhile (!list_empty(&txn->t_private_list)) {\n\t\tjce = list_entry(txn->t_private_list.next,\n\t\t\t\t struct ext4_journal_cb_entry, jce_list);\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}\n\n \nstatic int ext4_journalled_writepage_callback(struct folio *folio,\n\t\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t\t      void *data)\n{\n\ttransaction_t *transaction = (transaction_t *) data;\n\tstruct buffer_head *bh, *head;\n\tstruct journal_head *jh;\n\n\tbh = head = folio_buffers(folio);\n\tdo {\n\t\t \n\t\tjh = bh2jh(bh);\n\t\tif (buffer_dirty(bh) ||\n\t\t    (jh && (jh->b_transaction != transaction ||\n\t\t\t    jh->b_next_transaction))) {\n\t\t\tfolio_redirty_for_writepage(wbc, folio);\n\t\t\tgoto out;\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\nout:\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}\n\nstatic int ext4_journalled_submit_inode_data_buffers(struct jbd2_inode *jinode)\n{\n\tstruct address_space *mapping = jinode->i_vfs_inode->i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode =  WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = jinode->i_dirty_start,\n\t\t.range_end = jinode->i_dirty_end,\n        };\n\n\treturn write_cache_pages(mapping, &wbc,\n\t\t\t\t ext4_journalled_writepage_callback,\n\t\t\t\t jinode->i_transaction);\n}\n\nstatic int ext4_journal_submit_inode_data_buffers(struct jbd2_inode *jinode)\n{\n\tint ret;\n\n\tif (ext4_should_journal_data(jinode->i_vfs_inode))\n\t\tret = ext4_journalled_submit_inode_data_buffers(jinode);\n\telse\n\t\tret = ext4_normal_submit_inode_data_buffers(jinode);\n\treturn ret;\n}\n\nstatic int ext4_journal_finish_inode_data_buffers(struct jbd2_inode *jinode)\n{\n\tint ret = 0;\n\n\tif (!ext4_should_journal_data(jinode->i_vfs_inode))\n\t\tret = jbd2_journal_finish_inode_data_buffers(jinode);\n\n\treturn ret;\n}\n\nstatic bool system_going_down(void)\n{\n\treturn system_state == SYSTEM_HALT || system_state == SYSTEM_POWER_OFF\n\t\t|| system_state == SYSTEM_RESTART;\n}\n\nstruct ext4_err_translation {\n\tint code;\n\tint errno;\n};\n\n#define EXT4_ERR_TRANSLATE(err) { .code = EXT4_ERR_##err, .errno = err }\n\nstatic struct ext4_err_translation err_translation[] = {\n\tEXT4_ERR_TRANSLATE(EIO),\n\tEXT4_ERR_TRANSLATE(ENOMEM),\n\tEXT4_ERR_TRANSLATE(EFSBADCRC),\n\tEXT4_ERR_TRANSLATE(EFSCORRUPTED),\n\tEXT4_ERR_TRANSLATE(ENOSPC),\n\tEXT4_ERR_TRANSLATE(ENOKEY),\n\tEXT4_ERR_TRANSLATE(EROFS),\n\tEXT4_ERR_TRANSLATE(EFBIG),\n\tEXT4_ERR_TRANSLATE(EEXIST),\n\tEXT4_ERR_TRANSLATE(ERANGE),\n\tEXT4_ERR_TRANSLATE(EOVERFLOW),\n\tEXT4_ERR_TRANSLATE(EBUSY),\n\tEXT4_ERR_TRANSLATE(ENOTDIR),\n\tEXT4_ERR_TRANSLATE(ENOTEMPTY),\n\tEXT4_ERR_TRANSLATE(ESHUTDOWN),\n\tEXT4_ERR_TRANSLATE(EFAULT),\n};\n\nstatic int ext4_errno_to_code(int errno)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(err_translation); i++)\n\t\tif (err_translation[i].errno == errno)\n\t\t\treturn err_translation[i].code;\n\treturn EXT4_ERR_UNKNOWN;\n}\n\nstatic void save_error_info(struct super_block *sb, int error,\n\t\t\t    __u32 ino, __u64 block,\n\t\t\t    const char *func, unsigned int line)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t \n\tif (error == 0)\n\t\terror = EFSCORRUPTED;\n\n\tspin_lock(&sbi->s_error_lock);\n\tsbi->s_add_error_count++;\n\tsbi->s_last_error_code = error;\n\tsbi->s_last_error_line = line;\n\tsbi->s_last_error_ino = ino;\n\tsbi->s_last_error_block = block;\n\tsbi->s_last_error_func = func;\n\tsbi->s_last_error_time = ktime_get_real_seconds();\n\tif (!sbi->s_first_error_time) {\n\t\tsbi->s_first_error_code = error;\n\t\tsbi->s_first_error_line = line;\n\t\tsbi->s_first_error_ino = ino;\n\t\tsbi->s_first_error_block = block;\n\t\tsbi->s_first_error_func = func;\n\t\tsbi->s_first_error_time = sbi->s_last_error_time;\n\t}\n\tspin_unlock(&sbi->s_error_lock);\n}\n\n \nstatic void ext4_handle_error(struct super_block *sb, bool force_ro, int error,\n\t\t\t      __u32 ino, __u64 block,\n\t\t\t      const char *func, unsigned int line)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tbool continue_fs = !force_ro && test_opt(sb, ERRORS_CONT);\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\tif (test_opt(sb, WARN_ON_ERROR))\n\t\tWARN_ON_ONCE(1);\n\n\tif (!continue_fs && !sb_rdonly(sb)) {\n\t\tset_bit(EXT4_FLAGS_SHUTDOWN, &EXT4_SB(sb)->s_ext4_flags);\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\n\tif (!bdev_read_only(sb->s_bdev)) {\n\t\tsave_error_info(sb, error, ino, block, func, line);\n\t\t \n\t\tif (continue_fs && journal)\n\t\t\tschedule_work(&EXT4_SB(sb)->s_sb_upd_work);\n\t\telse\n\t\t\text4_commit_super(sb);\n\t}\n\n\t \n\tif (test_opt(sb, ERRORS_PANIC) && !system_going_down()) {\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\t}\n\n\tif (sb_rdonly(sb) || continue_fs)\n\t\treturn;\n\n\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t \n\tsmp_wmb();\n\tsb->s_flags |= SB_RDONLY;\n}\n\nstatic void update_super_work(struct work_struct *work)\n{\n\tstruct ext4_sb_info *sbi = container_of(work, struct ext4_sb_info,\n\t\t\t\t\t\ts_sb_upd_work);\n\tjournal_t *journal = sbi->s_journal;\n\thandle_t *handle;\n\n\t \n\tif (!sb_rdonly(sbi->s_sb) && journal) {\n\t\tstruct buffer_head *sbh = sbi->s_sbh;\n\t\tbool call_notify_err = false;\n\n\t\thandle = jbd2_journal_start(journal, 1);\n\t\tif (IS_ERR(handle))\n\t\t\tgoto write_directly;\n\t\tif (jbd2_journal_get_write_access(handle, sbh)) {\n\t\t\tjbd2_journal_stop(handle);\n\t\t\tgoto write_directly;\n\t\t}\n\n\t\tif (sbi->s_add_error_count > 0)\n\t\t\tcall_notify_err = true;\n\n\t\text4_update_super(sbi->s_sb);\n\t\tif (buffer_write_io_error(sbh) || !buffer_uptodate(sbh)) {\n\t\t\text4_msg(sbi->s_sb, KERN_ERR, \"previous I/O error to \"\n\t\t\t\t \"superblock detected\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\n\t\tif (jbd2_journal_dirty_metadata(handle, sbh)) {\n\t\t\tjbd2_journal_stop(handle);\n\t\t\tgoto write_directly;\n\t\t}\n\t\tjbd2_journal_stop(handle);\n\n\t\tif (call_notify_err)\n\t\t\text4_notify_error_sysfs(sbi);\n\n\t\treturn;\n\t}\nwrite_directly:\n\t \n\text4_commit_super(sbi->s_sb);\n\text4_notify_error_sysfs(sbi);\n}\n\n#define ext4_error_ratelimit(sb)\t\t\t\t\t\\\n\t\t___ratelimit(&(EXT4_SB(sb)->s_err_ratelimit_state),\t\\\n\t\t\t     \"EXT4-fs error\")\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, bool force_ro, int error, __u64 block,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn;\n\n\ttrace_ext4_error(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tfsnotify_sb_error(sb, NULL, error ? error : EFSCORRUPTED);\n\n\text4_handle_error(sb, force_ro, error, 0, block, function, line);\n}\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block, int error,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn;\n\n\ttrace_ext4_error(inode->i_sb, function, line);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tfsnotify_sb_error(inode->i_sb, inode, error ? error : EFSCORRUPTED);\n\n\text4_handle_error(inode->i_sb, false, error, inode->i_ino, block,\n\t\t\t  function, line);\n}\n\nvoid __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn;\n\n\ttrace_ext4_error(inode->i_sb, function, line);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = file_path(file, pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tfsnotify_sb_error(inode->i_sb, inode, EFSCORRUPTED);\n\n\text4_handle_error(inode->i_sb, false, EFSCORRUPTED, inode->i_ino, block,\n\t\t\t  function, line);\n}\n\nconst char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t      char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EFSCORRUPTED:\n\t\terrstr = \"Corrupt filesystem\";\n\t\tbreak;\n\tcase -EFSBADCRC:\n\t\terrstr = \"Filesystem failed CRC\";\n\t\tbreak;\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (nbuf) {\n\t\t\t \n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}\n\n \n\nvoid __ext4_std_error(struct super_block *sb, const char *function,\n\t\t      unsigned int line, int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn;\n\n\t \n\tif (errno == -EROFS && journal_current_handle() == NULL && sb_rdonly(sb))\n\t\treturn;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\terrstr = ext4_decode_error(sb, errno, nbuf);\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n\t\t       sb->s_id, function, line, errstr);\n\t}\n\tfsnotify_sb_error(sb, NULL, errno ? errno : EFSCORRUPTED);\n\n\text4_handle_error(sb, false, -errno, 0, 0, function, line);\n}\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (sb) {\n\t\tatomic_inc(&EXT4_SB(sb)->s_msg_count);\n\t\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state),\n\t\t\t\t  \"EXT4-fs\"))\n\t\t\treturn;\n\t}\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\telse\n\t\tprintk(\"%sEXT4-fs: %pV\\n\", prefix, &vaf);\n\tva_end(args);\n}\n\nstatic int ext4_warning_ratelimit(struct super_block *sb)\n{\n\tatomic_inc(&EXT4_SB(sb)->s_warning_count);\n\treturn ___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t    \"EXT4-fs warning\");\n}\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!ext4_warning_ratelimit(sb))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}\n\nvoid __ext4_warning_inode(const struct inode *inode, const char *function,\n\t\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!ext4_warning_ratelimit(inode->i_sb))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: \"\n\t       \"inode #%lu: comm %s: %pV\\n\", inode->i_sb->s_id,\n\t       function, line, inode->i_ino, current->comm, &vaf);\n\tva_end(args);\n}\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn;\n\n\ttrace_ext4_error(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\tif (test_opt(sb, WARN_ON_ERROR))\n\t\t\tWARN_ON_ONCE(1);\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tif (!bdev_read_only(sb->s_bdev)) {\n\t\t\tsave_error_info(sb, EFSCORRUPTED, ino, block, function,\n\t\t\t\t\tline);\n\t\t\tschedule_work(&EXT4_SB(sb)->s_sb_upd_work);\n\t\t}\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb, false, EFSCORRUPTED, ino, block, function, line);\n\t \n\text4_lock_group(sb, grp);\n\treturn;\n}\n\nvoid ext4_mark_group_bitmap_corrupted(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, group, NULL);\n\tint ret;\n\n\tif (!grp || !gdp)\n\t\treturn;\n\tif (flags & EXT4_GROUP_INFO_BBITMAP_CORRUPT) {\n\t\tret = ext4_test_and_set_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t\t\t    &grp->bb_state);\n\t\tif (!ret)\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t}\n\n\tif (flags & EXT4_GROUP_INFO_IBITMAP_CORRUPT) {\n\t\tret = ext4_test_and_set_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT,\n\t\t\t\t\t    &grp->bb_state);\n\t\tif (!ret && gdp) {\n\t\t\tint count;\n\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t}\n}\n\nvoid ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t \n\t \n\n\t \n}\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;\n}\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}\n\n#ifdef CONFIG_QUOTA\nstatic int ext4_quota_off(struct super_block *sb, int type);\n\nstatic inline void ext4_quotas_off(struct super_block *sb, int type)\n{\n\tBUG_ON(type > EXT4_MAXQUOTAS);\n\n\t \n\tfor (type--; type >= 0; type--)\n\t\text4_quota_off(sb, type);\n}\n\n \nstatic inline char *get_qf_name(struct super_block *sb,\n\t\t\t\tstruct ext4_sb_info *sbi,\n\t\t\t\tint type)\n{\n\treturn rcu_dereference_protected(sbi->s_qf_names[type],\n\t\t\t\t\t lockdep_is_held(&sb->s_umount));\n}\n#else\nstatic inline void ext4_quotas_off(struct super_block *sb, int type)\n{\n}\n#endif\n\nstatic int ext4_percpu_param_init(struct ext4_sb_info *sbi)\n{\n\text4_fsblk_t block;\n\tint err;\n\n\tblock = ext4_count_free_clusters(sbi->s_sb);\n\text4_free_blocks_count_set(sbi->s_es, EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sbi->s_sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sbi->s_sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_sra_exceeded_retry_limit, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_writepages_rwsem);\n\n\tif (err)\n\t\text4_msg(sbi->s_sb, KERN_ERR, \"insufficient memory\");\n\n\treturn err;\n}\n\nstatic void ext4_percpu_param_destroy(struct ext4_sb_info *sbi)\n{\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_sra_exceeded_retry_limit);\n\tpercpu_free_rwsem(&sbi->s_writepages_rwsem);\n}\n\nstatic void ext4_group_desc_free(struct ext4_sb_info *sbi)\n{\n\tstruct buffer_head **group_desc;\n\tint i;\n\n\trcu_read_lock();\n\tgroup_desc = rcu_dereference(sbi->s_group_desc);\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(group_desc[i]);\n\tkvfree(group_desc);\n\trcu_read_unlock();\n}\n\nstatic void ext4_flex_groups_free(struct ext4_sb_info *sbi)\n{\n\tstruct flex_groups **flex_groups;\n\tint i;\n\n\trcu_read_lock();\n\tflex_groups = rcu_dereference(sbi->s_flex_groups);\n\tif (flex_groups) {\n\t\tfor (i = 0; i < sbi->s_flex_groups_allocated; i++)\n\t\t\tkvfree(flex_groups[i]);\n\t\tkvfree(flex_groups);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint aborted = 0;\n\tint err;\n\n\t \n\text4_unregister_sysfs(sb);\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs unmount\"))\n\t\text4_msg(sb, KERN_INFO, \"unmounting filesystem %pU.\",\n\t\t\t &sb->s_uuid);\n\n\text4_unregister_li_request(sb);\n\text4_quotas_off(sb, EXT4_MAXQUOTAS);\n\n\tflush_work(&sbi->s_sb_upd_work);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\text4_release_orphan_info(sb);\n\n\tif (sbi->s_journal) {\n\t\taborted = is_journal_aborted(sbi->s_journal);\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif ((err < 0) && !aborted) {\n\t\t\text4_abort(sb, -err, \"Couldn't clean up the journal\");\n\t\t}\n\t}\n\n\text4_es_unregister_shrinker(sbi);\n\ttimer_shutdown_sync(&sbi->s_err_report);\n\text4_release_system_zone(sb);\n\text4_mb_release(sb);\n\text4_ext_release(sb);\n\n\tif (!sb_rdonly(sb) && !aborted) {\n\t\text4_clear_feature_journal_needs_recovery(sb);\n\t\text4_clear_feature_orphan_present(sb);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!sb_rdonly(sb))\n\t\text4_commit_super(sb);\n\n\text4_group_desc_free(sbi);\n\text4_flex_groups_free(sbi);\n\text4_percpu_param_destroy(sbi);\n#ifdef CONFIG_QUOTA\n\tfor (int i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(get_qf_name(sb, sbi, i));\n#endif\n\n\t \n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tASSERT(list_empty(&sbi->s_orphan));\n\n\tsync_blockdev(sb->s_bdev);\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->s_journal_bdev) {\n\t\t \n\t\tsync_blockdev(sbi->s_journal_bdev);\n\t\tinvalidate_bdev(sbi->s_journal_bdev);\n\t}\n\n\text4_xattr_destroy_cache(sbi->s_ea_inode_cache);\n\tsbi->s_ea_inode_cache = NULL;\n\n\text4_xattr_destroy_cache(sbi->s_ea_block_cache);\n\tsbi->s_ea_block_cache = NULL;\n\n\text4_stop_mmpd(sbi);\n\n\tbrelse(sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\t \n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tfs_put_dax(sbi->s_daxdev, NULL);\n\tfscrypt_free_dummy_policy(&sbi->s_dummy_enc_policy);\n#if IS_ENABLED(CONFIG_UNICODE)\n\tutf8_unload(sb->s_encoding);\n#endif\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache *ext4_inode_cachep;\n\n \nstatic struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\n\tei = alloc_inode_sb(sb, ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tinode_set_iversion(&ei->vfs_inode, 1);\n\tei->i_flags = 0;\n\tspin_lock_init(&ei->i_raw_lock);\n\tei->i_prealloc_node = RB_ROOT;\n\tatomic_set(&ei->i_prealloc_active, 0);\n\trwlock_init(&ei->i_prealloc_lock);\n\text4_es_init_tree(&ei->i_es_tree);\n\trwlock_init(&ei->i_es_lock);\n\tINIT_LIST_HEAD(&ei->i_es_list);\n\tei->i_es_all_nr = 0;\n\tei->i_es_shk_nr = 0;\n\tei->i_es_shrink_lblk = 0;\n\tei->i_reserved_data_blocks = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n\text4_init_pending_tree(&ei->i_pending_tree);\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\tei->jinode = NULL;\n\tINIT_LIST_HEAD(&ei->i_rsv_conversion_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\tatomic_set(&ei->i_unwritten, 0);\n\tINIT_WORK(&ei->i_rsv_conversion_work, ext4_end_io_rsv_work);\n\text4_fc_init_inode(&ei->vfs_inode);\n\tmutex_init(&ei->i_fc_lock);\n\treturn &ei->vfs_inode;\n}\n\nstatic int ext4_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\tif (!drop)\n\t\tdrop = fscrypt_drop_inode(inode);\n\n\ttrace_ext4_drop_inode(inode, drop);\n\treturn drop;\n}\n\nstatic void ext4_free_in_core_inode(struct inode *inode)\n{\n\tfscrypt_free_inode(inode);\n\tif (!list_empty(&(EXT4_I(inode)->i_fc_list))) {\n\t\tpr_warn(\"%s: inode %ld still in fc list\",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tkmem_cache_free(ext4_inode_cachep, EXT4_I(inode));\n}\n\nstatic void ext4_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT4_I(inode)->i_orphan))) {\n\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t \"Inode %lu (%p): orphan list check failed!\",\n\t\t\t inode->i_ino, EXT4_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT4_I(inode), sizeof(struct ext4_inode_info),\n\t\t\t\ttrue);\n\t\tdump_stack();\n\t}\n\n\tif (EXT4_I(inode)->i_reserved_data_blocks)\n\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t \"Inode %lu (%p): i_reserved_data_blocks (%u) not cleared!\",\n\t\t\t inode->i_ino, EXT4_I(inode),\n\t\t\t EXT4_I(inode)->i_reserved_data_blocks);\n}\n\nstatic void ext4_shutdown(struct super_block *sb)\n{\n       ext4_force_shutdown(sb, EXT4_GOING_FLAGS_NOLOGFLUSH);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinode_init_once(&ei->vfs_inode);\n\text4_fc_init_inode(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create_usercopy(\"ext4_inode_cache\",\n\t\t\t\tsizeof(struct ext4_inode_info), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD|\n\t\t\t\t\tSLAB_ACCOUNT),\n\t\t\t\toffsetof(struct ext4_inode_info, i_data),\n\t\t\t\tsizeof_field(struct ext4_inode_info, i_data),\n\t\t\t\tinit_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ext4_inode_cachep);\n}\n\nvoid ext4_clear_inode(struct inode *inode)\n{\n\text4_fc_del(inode);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\text4_discard_preallocations(inode, 0);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tdquot_drop(inode);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n\tfscrypt_put_encryption_info(inode);\n\tfsverity_cleanup_inode(inode);\n}\n\nstatic struct inode *ext4_nfs_get_inode(struct super_block *sb,\n\t\t\t\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\t \n\tinode = ext4_iget(sb, ino, EXT4_IGET_HANDLE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *ext4_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}\n\nstatic struct dentry *ext4_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext4_nfs_get_inode);\n}\n\nstatic int ext4_nfs_commit_metadata(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL\n\t};\n\n\ttrace_ext4_nfs_commit_metadata(inode);\n\treturn ext4_write_inode(inode, &wbc);\n}\n\n#ifdef CONFIG_QUOTA\nstatic const char * const quotatypes[] = INITQFNAMES;\n#define QTYPE2NAME(t) (quotatypes[t])\n\nstatic int ext4_write_dquot(struct dquot *dquot);\nstatic int ext4_acquire_dquot(struct dquot *dquot);\nstatic int ext4_release_dquot(struct dquot *dquot);\nstatic int ext4_mark_dquot_dirty(struct dquot *dquot);\nstatic int ext4_write_info(struct super_block *sb, int type);\nstatic int ext4_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t const struct path *path);\nstatic ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off);\nstatic ssize_t ext4_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off);\nstatic int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags);\n\nstatic struct dquot **ext4_get_dquots(struct inode *inode)\n{\n\treturn EXT4_I(inode)->i_dquot;\n}\n\nstatic const struct dquot_operations ext4_quota_operations = {\n\t.get_reserved_space\t= ext4_get_reserved_space,\n\t.write_dquot\t\t= ext4_write_dquot,\n\t.acquire_dquot\t\t= ext4_acquire_dquot,\n\t.release_dquot\t\t= ext4_release_dquot,\n\t.mark_dirty\t\t= ext4_mark_dquot_dirty,\n\t.write_info\t\t= ext4_write_info,\n\t.alloc_dquot\t\t= dquot_alloc,\n\t.destroy_dquot\t\t= dquot_destroy,\n\t.get_projid\t\t= ext4_get_projid,\n\t.get_inode_usage\t= ext4_get_inode_usage,\n\t.get_next_id\t\t= dquot_get_next_id,\n};\n\nstatic const struct quotactl_ops ext4_qctl_operations = {\n\t.quota_on\t= ext4_quota_on,\n\t.quota_off\t= ext4_quota_off,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_state\t= dquot_get_state,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk,\n\t.get_nextdqblk\t= dquot_get_next_dqblk,\n};\n#endif\n\nstatic const struct super_operations ext4_sops = {\n\t.alloc_inode\t= ext4_alloc_inode,\n\t.free_inode\t= ext4_free_in_core_inode,\n\t.destroy_inode\t= ext4_destroy_inode,\n\t.write_inode\t= ext4_write_inode,\n\t.dirty_inode\t= ext4_dirty_inode,\n\t.drop_inode\t= ext4_drop_inode,\n\t.evict_inode\t= ext4_evict_inode,\n\t.put_super\t= ext4_put_super,\n\t.sync_fs\t= ext4_sync_fs,\n\t.freeze_fs\t= ext4_freeze,\n\t.unfreeze_fs\t= ext4_unfreeze,\n\t.statfs\t\t= ext4_statfs,\n\t.show_options\t= ext4_show_options,\n\t.shutdown\t= ext4_shutdown,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext4_quota_read,\n\t.quota_write\t= ext4_quota_write,\n\t.get_dquots\t= ext4_get_dquots,\n#endif\n};\n\nstatic const struct export_operations ext4_export_ops = {\n\t.fh_to_dentry = ext4_fh_to_dentry,\n\t.fh_to_parent = ext4_fh_to_parent,\n\t.get_parent = ext4_get_parent,\n\t.commit_metadata = ext4_nfs_commit_metadata,\n};\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb,\n\tOpt_nouid32, Opt_debug, Opt_removed,\n\tOpt_user_xattr, Opt_acl,\n\tOpt_auto_da_alloc, Opt_noauto_da_alloc, Opt_noload,\n\tOpt_commit, Opt_min_batch_time, Opt_max_batch_time, Opt_journal_dev,\n\tOpt_journal_path, Opt_journal_checksum, Opt_journal_async_commit,\n\tOpt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,\n\tOpt_data_err_abort, Opt_data_err_ignore, Opt_test_dummy_encryption,\n\tOpt_inlinecrypt,\n\tOpt_usrjquota, Opt_grpjquota, Opt_quota,\n\tOpt_noquota, Opt_barrier, Opt_nobarrier, Opt_err,\n\tOpt_usrquota, Opt_grpquota, Opt_prjquota,\n\tOpt_dax, Opt_dax_always, Opt_dax_inode, Opt_dax_never,\n\tOpt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_warn_on_error,\n\tOpt_nowarn_on_error, Opt_mblk_io_submit, Opt_debug_want_extra_isize,\n\tOpt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,\n\tOpt_inode_readahead_blks, Opt_journal_ioprio,\n\tOpt_dioread_nolock, Opt_dioread_lock,\n\tOpt_discard, Opt_nodiscard, Opt_init_itable, Opt_noinit_itable,\n\tOpt_max_dir_size_kb, Opt_nojournal_checksum, Opt_nombcache,\n\tOpt_no_prefetch_block_bitmaps, Opt_mb_optimize_scan,\n\tOpt_errors, Opt_data, Opt_data_err, Opt_jqfmt, Opt_dax_type,\n#ifdef CONFIG_EXT4_DEBUG\n\tOpt_fc_debug_max_replay, Opt_fc_debug_force\n#endif\n};\n\nstatic const struct constant_table ext4_param_errors[] = {\n\t{\"continue\",\tEXT4_MOUNT_ERRORS_CONT},\n\t{\"panic\",\tEXT4_MOUNT_ERRORS_PANIC},\n\t{\"remount-ro\",\tEXT4_MOUNT_ERRORS_RO},\n\t{}\n};\n\nstatic const struct constant_table ext4_param_data[] = {\n\t{\"journal\",\tEXT4_MOUNT_JOURNAL_DATA},\n\t{\"ordered\",\tEXT4_MOUNT_ORDERED_DATA},\n\t{\"writeback\",\tEXT4_MOUNT_WRITEBACK_DATA},\n\t{}\n};\n\nstatic const struct constant_table ext4_param_data_err[] = {\n\t{\"abort\",\tOpt_data_err_abort},\n\t{\"ignore\",\tOpt_data_err_ignore},\n\t{}\n};\n\nstatic const struct constant_table ext4_param_jqfmt[] = {\n\t{\"vfsold\",\tQFMT_VFS_OLD},\n\t{\"vfsv0\",\tQFMT_VFS_V0},\n\t{\"vfsv1\",\tQFMT_VFS_V1},\n\t{}\n};\n\nstatic const struct constant_table ext4_param_dax[] = {\n\t{\"always\",\tOpt_dax_always},\n\t{\"inode\",\tOpt_dax_inode},\n\t{\"never\",\tOpt_dax_never},\n\t{}\n};\n\n \n#define fsparam_string_empty(NAME, OPT) \\\n\t__fsparam(fs_param_is_string, NAME, OPT, fs_param_can_be_empty, NULL)\n\n \nstatic const struct fs_parameter_spec ext4_param_specs[] = {\n\tfsparam_flag\t(\"bsddf\",\t\tOpt_bsd_df),\n\tfsparam_flag\t(\"minixdf\",\t\tOpt_minix_df),\n\tfsparam_flag\t(\"grpid\",\t\tOpt_grpid),\n\tfsparam_flag\t(\"bsdgroups\",\t\tOpt_grpid),\n\tfsparam_flag\t(\"nogrpid\",\t\tOpt_nogrpid),\n\tfsparam_flag\t(\"sysvgroups\",\t\tOpt_nogrpid),\n\tfsparam_u32\t(\"resgid\",\t\tOpt_resgid),\n\tfsparam_u32\t(\"resuid\",\t\tOpt_resuid),\n\tfsparam_u32\t(\"sb\",\t\t\tOpt_sb),\n\tfsparam_enum\t(\"errors\",\t\tOpt_errors, ext4_param_errors),\n\tfsparam_flag\t(\"nouid32\",\t\tOpt_nouid32),\n\tfsparam_flag\t(\"debug\",\t\tOpt_debug),\n\tfsparam_flag\t(\"oldalloc\",\t\tOpt_removed),\n\tfsparam_flag\t(\"orlov\",\t\tOpt_removed),\n\tfsparam_flag\t(\"user_xattr\",\t\tOpt_user_xattr),\n\tfsparam_flag\t(\"acl\",\t\t\tOpt_acl),\n\tfsparam_flag\t(\"norecovery\",\t\tOpt_noload),\n\tfsparam_flag\t(\"noload\",\t\tOpt_noload),\n\tfsparam_flag\t(\"bh\",\t\t\tOpt_removed),\n\tfsparam_flag\t(\"nobh\",\t\tOpt_removed),\n\tfsparam_u32\t(\"commit\",\t\tOpt_commit),\n\tfsparam_u32\t(\"min_batch_time\",\tOpt_min_batch_time),\n\tfsparam_u32\t(\"max_batch_time\",\tOpt_max_batch_time),\n\tfsparam_u32\t(\"journal_dev\",\t\tOpt_journal_dev),\n\tfsparam_bdev\t(\"journal_path\",\tOpt_journal_path),\n\tfsparam_flag\t(\"journal_checksum\",\tOpt_journal_checksum),\n\tfsparam_flag\t(\"nojournal_checksum\",\tOpt_nojournal_checksum),\n\tfsparam_flag\t(\"journal_async_commit\",Opt_journal_async_commit),\n\tfsparam_flag\t(\"abort\",\t\tOpt_abort),\n\tfsparam_enum\t(\"data\",\t\tOpt_data, ext4_param_data),\n\tfsparam_enum\t(\"data_err\",\t\tOpt_data_err,\n\t\t\t\t\t\text4_param_data_err),\n\tfsparam_string_empty\n\t\t\t(\"usrjquota\",\t\tOpt_usrjquota),\n\tfsparam_string_empty\n\t\t\t(\"grpjquota\",\t\tOpt_grpjquota),\n\tfsparam_enum\t(\"jqfmt\",\t\tOpt_jqfmt, ext4_param_jqfmt),\n\tfsparam_flag\t(\"grpquota\",\t\tOpt_grpquota),\n\tfsparam_flag\t(\"quota\",\t\tOpt_quota),\n\tfsparam_flag\t(\"noquota\",\t\tOpt_noquota),\n\tfsparam_flag\t(\"usrquota\",\t\tOpt_usrquota),\n\tfsparam_flag\t(\"prjquota\",\t\tOpt_prjquota),\n\tfsparam_flag\t(\"barrier\",\t\tOpt_barrier),\n\tfsparam_u32\t(\"barrier\",\t\tOpt_barrier),\n\tfsparam_flag\t(\"nobarrier\",\t\tOpt_nobarrier),\n\tfsparam_flag\t(\"i_version\",\t\tOpt_removed),\n\tfsparam_flag\t(\"dax\",\t\t\tOpt_dax),\n\tfsparam_enum\t(\"dax\",\t\t\tOpt_dax_type, ext4_param_dax),\n\tfsparam_u32\t(\"stripe\",\t\tOpt_stripe),\n\tfsparam_flag\t(\"delalloc\",\t\tOpt_delalloc),\n\tfsparam_flag\t(\"nodelalloc\",\t\tOpt_nodelalloc),\n\tfsparam_flag\t(\"warn_on_error\",\tOpt_warn_on_error),\n\tfsparam_flag\t(\"nowarn_on_error\",\tOpt_nowarn_on_error),\n\tfsparam_u32\t(\"debug_want_extra_isize\",\n\t\t\t\t\t\tOpt_debug_want_extra_isize),\n\tfsparam_flag\t(\"mblk_io_submit\",\tOpt_removed),\n\tfsparam_flag\t(\"nomblk_io_submit\",\tOpt_removed),\n\tfsparam_flag\t(\"block_validity\",\tOpt_block_validity),\n\tfsparam_flag\t(\"noblock_validity\",\tOpt_noblock_validity),\n\tfsparam_u32\t(\"inode_readahead_blks\",\n\t\t\t\t\t\tOpt_inode_readahead_blks),\n\tfsparam_u32\t(\"journal_ioprio\",\tOpt_journal_ioprio),\n\tfsparam_u32\t(\"auto_da_alloc\",\tOpt_auto_da_alloc),\n\tfsparam_flag\t(\"auto_da_alloc\",\tOpt_auto_da_alloc),\n\tfsparam_flag\t(\"noauto_da_alloc\",\tOpt_noauto_da_alloc),\n\tfsparam_flag\t(\"dioread_nolock\",\tOpt_dioread_nolock),\n\tfsparam_flag\t(\"nodioread_nolock\",\tOpt_dioread_lock),\n\tfsparam_flag\t(\"dioread_lock\",\tOpt_dioread_lock),\n\tfsparam_flag\t(\"discard\",\t\tOpt_discard),\n\tfsparam_flag\t(\"nodiscard\",\t\tOpt_nodiscard),\n\tfsparam_u32\t(\"init_itable\",\t\tOpt_init_itable),\n\tfsparam_flag\t(\"init_itable\",\t\tOpt_init_itable),\n\tfsparam_flag\t(\"noinit_itable\",\tOpt_noinit_itable),\n#ifdef CONFIG_EXT4_DEBUG\n\tfsparam_flag\t(\"fc_debug_force\",\tOpt_fc_debug_force),\n\tfsparam_u32\t(\"fc_debug_max_replay\",\tOpt_fc_debug_max_replay),\n#endif\n\tfsparam_u32\t(\"max_dir_size_kb\",\tOpt_max_dir_size_kb),\n\tfsparam_flag\t(\"test_dummy_encryption\",\n\t\t\t\t\t\tOpt_test_dummy_encryption),\n\tfsparam_string\t(\"test_dummy_encryption\",\n\t\t\t\t\t\tOpt_test_dummy_encryption),\n\tfsparam_flag\t(\"inlinecrypt\",\t\tOpt_inlinecrypt),\n\tfsparam_flag\t(\"nombcache\",\t\tOpt_nombcache),\n\tfsparam_flag\t(\"no_mbcache\",\t\tOpt_nombcache),\t \n\tfsparam_flag\t(\"prefetch_block_bitmaps\",\n\t\t\t\t\t\tOpt_removed),\n\tfsparam_flag\t(\"no_prefetch_block_bitmaps\",\n\t\t\t\t\t\tOpt_no_prefetch_block_bitmaps),\n\tfsparam_s32\t(\"mb_optimize_scan\",\tOpt_mb_optimize_scan),\n\tfsparam_string\t(\"check\",\t\tOpt_removed),\t \n\tfsparam_flag\t(\"nocheck\",\t\tOpt_removed),\t \n\tfsparam_flag\t(\"reservation\",\t\tOpt_removed),\t \n\tfsparam_flag\t(\"noreservation\",\tOpt_removed),\t \n\tfsparam_u32\t(\"journal\",\t\tOpt_removed),\t \n\t{}\n};\n\n#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))\n\n#define MOPT_SET\t0x0001\n#define MOPT_CLEAR\t0x0002\n#define MOPT_NOSUPPORT\t0x0004\n#define MOPT_EXPLICIT\t0x0008\n#ifdef CONFIG_QUOTA\n#define MOPT_Q\t\t0\n#define MOPT_QFMT\t0x0010\n#else\n#define MOPT_Q\t\tMOPT_NOSUPPORT\n#define MOPT_QFMT\tMOPT_NOSUPPORT\n#endif\n#define MOPT_NO_EXT2\t0x0020\n#define MOPT_NO_EXT3\t0x0040\n#define MOPT_EXT4_ONLY\t(MOPT_NO_EXT2 | MOPT_NO_EXT3)\n#define MOPT_SKIP\t0x0080\n#define\tMOPT_2\t\t0x0100\n\nstatic const struct mount_opts {\n\tint\ttoken;\n\tint\tmount_opt;\n\tint\tflags;\n} ext4_mount_opts[] = {\n\t{Opt_minix_df, EXT4_MOUNT_MINIX_DF, MOPT_SET},\n\t{Opt_bsd_df, EXT4_MOUNT_MINIX_DF, MOPT_CLEAR},\n\t{Opt_grpid, EXT4_MOUNT_GRPID, MOPT_SET},\n\t{Opt_nogrpid, EXT4_MOUNT_GRPID, MOPT_CLEAR},\n\t{Opt_block_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_SET},\n\t{Opt_noblock_validity, EXT4_MOUNT_BLOCK_VALIDITY, MOPT_CLEAR},\n\t{Opt_dioread_nolock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_SET},\n\t{Opt_dioread_lock, EXT4_MOUNT_DIOREAD_NOLOCK,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_discard, EXT4_MOUNT_DISCARD, MOPT_SET},\n\t{Opt_nodiscard, EXT4_MOUNT_DISCARD, MOPT_CLEAR},\n\t{Opt_delalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_nodelalloc, EXT4_MOUNT_DELALLOC,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_warn_on_error, EXT4_MOUNT_WARN_ON_ERROR, MOPT_SET},\n\t{Opt_nowarn_on_error, EXT4_MOUNT_WARN_ON_ERROR, MOPT_CLEAR},\n\t{Opt_commit, 0, MOPT_NO_EXT2},\n\t{Opt_nojournal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_CLEAR},\n\t{Opt_journal_checksum, EXT4_MOUNT_JOURNAL_CHECKSUM,\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_journal_async_commit, (EXT4_MOUNT_JOURNAL_ASYNC_COMMIT |\n\t\t\t\t    EXT4_MOUNT_JOURNAL_CHECKSUM),\n\t MOPT_EXT4_ONLY | MOPT_SET | MOPT_EXPLICIT},\n\t{Opt_noload, EXT4_MOUNT_NOLOAD, MOPT_NO_EXT2 | MOPT_SET},\n\t{Opt_data_err, EXT4_MOUNT_DATA_ERR_ABORT, MOPT_NO_EXT2},\n\t{Opt_barrier, EXT4_MOUNT_BARRIER, MOPT_SET},\n\t{Opt_nobarrier, EXT4_MOUNT_BARRIER, MOPT_CLEAR},\n\t{Opt_noauto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_SET},\n\t{Opt_auto_da_alloc, EXT4_MOUNT_NO_AUTO_DA_ALLOC, MOPT_CLEAR},\n\t{Opt_noinit_itable, EXT4_MOUNT_INIT_INODE_TABLE, MOPT_CLEAR},\n\t{Opt_dax_type, 0, MOPT_EXT4_ONLY},\n\t{Opt_journal_dev, 0, MOPT_NO_EXT2},\n\t{Opt_journal_path, 0, MOPT_NO_EXT2},\n\t{Opt_journal_ioprio, 0, MOPT_NO_EXT2},\n\t{Opt_data, 0, MOPT_NO_EXT2},\n\t{Opt_user_xattr, EXT4_MOUNT_XATTR_USER, MOPT_SET},\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t{Opt_acl, EXT4_MOUNT_POSIX_ACL, MOPT_SET},\n#else\n\t{Opt_acl, 0, MOPT_NOSUPPORT},\n#endif\n\t{Opt_nouid32, EXT4_MOUNT_NO_UID32, MOPT_SET},\n\t{Opt_debug, EXT4_MOUNT_DEBUG, MOPT_SET},\n\t{Opt_quota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA, MOPT_SET | MOPT_Q},\n\t{Opt_usrquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_grpquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_GRPQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_prjquota, EXT4_MOUNT_QUOTA | EXT4_MOUNT_PRJQUOTA,\n\t\t\t\t\t\t\tMOPT_SET | MOPT_Q},\n\t{Opt_noquota, (EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t       EXT4_MOUNT_GRPQUOTA | EXT4_MOUNT_PRJQUOTA),\n\t\t\t\t\t\t\tMOPT_CLEAR | MOPT_Q},\n\t{Opt_usrjquota, 0, MOPT_Q},\n\t{Opt_grpjquota, 0, MOPT_Q},\n\t{Opt_jqfmt, 0, MOPT_QFMT},\n\t{Opt_nombcache, EXT4_MOUNT_NO_MBCACHE, MOPT_SET},\n\t{Opt_no_prefetch_block_bitmaps, EXT4_MOUNT_NO_PREFETCH_BLOCK_BITMAPS,\n\t MOPT_SET},\n#ifdef CONFIG_EXT4_DEBUG\n\t{Opt_fc_debug_force, EXT4_MOUNT2_JOURNAL_FAST_COMMIT,\n\t MOPT_SET | MOPT_2 | MOPT_EXT4_ONLY},\n#endif\n\t{Opt_abort, EXT4_MOUNT2_ABORT, MOPT_SET | MOPT_2},\n\t{Opt_err, 0, 0}\n};\n\n#if IS_ENABLED(CONFIG_UNICODE)\nstatic const struct ext4_sb_encodings {\n\t__u16 magic;\n\tchar *name;\n\tunsigned int version;\n} ext4_sb_encoding_map[] = {\n\t{EXT4_ENC_UTF8_12_1, \"utf8\", UNICODE_AGE(12, 1, 0)},\n};\n\nstatic const struct ext4_sb_encodings *\next4_sb_read_encoding(const struct ext4_super_block *es)\n{\n\t__u16 magic = le16_to_cpu(es->s_encoding);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ext4_sb_encoding_map); i++)\n\t\tif (magic == ext4_sb_encoding_map[i].magic)\n\t\t\treturn &ext4_sb_encoding_map[i];\n\n\treturn NULL;\n}\n#endif\n\n#define EXT4_SPEC_JQUOTA\t\t\t(1 <<  0)\n#define EXT4_SPEC_JQFMT\t\t\t\t(1 <<  1)\n#define EXT4_SPEC_DATAJ\t\t\t\t(1 <<  2)\n#define EXT4_SPEC_SB_BLOCK\t\t\t(1 <<  3)\n#define EXT4_SPEC_JOURNAL_DEV\t\t\t(1 <<  4)\n#define EXT4_SPEC_JOURNAL_IOPRIO\t\t(1 <<  5)\n#define EXT4_SPEC_s_want_extra_isize\t\t(1 <<  7)\n#define EXT4_SPEC_s_max_batch_time\t\t(1 <<  8)\n#define EXT4_SPEC_s_min_batch_time\t\t(1 <<  9)\n#define EXT4_SPEC_s_inode_readahead_blks\t(1 << 10)\n#define EXT4_SPEC_s_li_wait_mult\t\t(1 << 11)\n#define EXT4_SPEC_s_max_dir_size_kb\t\t(1 << 12)\n#define EXT4_SPEC_s_stripe\t\t\t(1 << 13)\n#define EXT4_SPEC_s_resuid\t\t\t(1 << 14)\n#define EXT4_SPEC_s_resgid\t\t\t(1 << 15)\n#define EXT4_SPEC_s_commit_interval\t\t(1 << 16)\n#define EXT4_SPEC_s_fc_debug_max_replay\t\t(1 << 17)\n#define EXT4_SPEC_s_sb_block\t\t\t(1 << 18)\n#define EXT4_SPEC_mb_optimize_scan\t\t(1 << 19)\n\nstruct ext4_fs_context {\n\tchar\t\t*s_qf_names[EXT4_MAXQUOTAS];\n\tstruct fscrypt_dummy_policy dummy_enc_policy;\n\tint\t\ts_jquota_fmt;\t \n#ifdef CONFIG_EXT4_DEBUG\n\tint s_fc_debug_max_replay;\n#endif\n\tunsigned short\tqname_spec;\n\tunsigned long\tvals_s_flags;\t \n\tunsigned long\tmask_s_flags;\t \n\tunsigned long\tjournal_devnum;\n\tunsigned long\ts_commit_interval;\n\tunsigned long\ts_stripe;\n\tunsigned int\ts_inode_readahead_blks;\n\tunsigned int\ts_want_extra_isize;\n\tunsigned int\ts_li_wait_mult;\n\tunsigned int\ts_max_dir_size_kb;\n\tunsigned int\tjournal_ioprio;\n\tunsigned int\tvals_s_mount_opt;\n\tunsigned int\tmask_s_mount_opt;\n\tunsigned int\tvals_s_mount_opt2;\n\tunsigned int\tmask_s_mount_opt2;\n\tunsigned int\topt_flags;\t \n\tunsigned int\tspec;\n\tu32\t\ts_max_batch_time;\n\tu32\t\ts_min_batch_time;\n\tkuid_t\t\ts_resuid;\n\tkgid_t\t\ts_resgid;\n\text4_fsblk_t\ts_sb_block;\n};\n\nstatic void ext4_fc_free(struct fs_context *fc)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tint i;\n\n\tif (!ctx)\n\t\treturn;\n\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(ctx->s_qf_names[i]);\n\n\tfscrypt_free_dummy_policy(&ctx->dummy_enc_policy);\n\tkfree(ctx);\n}\n\nint ext4_init_fs_context(struct fs_context *fc)\n{\n\tstruct ext4_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct ext4_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tfc->fs_private = ctx;\n\tfc->ops = &ext4_context_ops;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\n \nstatic int note_qf_name(struct fs_context *fc, int qtype,\n\t\t       struct fs_parameter *param)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tchar *qname;\n\n\tif (param->size < 1) {\n\t\text4_msg(NULL, KERN_ERR, \"Missing quota name\");\n\t\treturn -EINVAL;\n\t}\n\tif (strchr(param->string, '/')) {\n\t\text4_msg(NULL, KERN_ERR,\n\t\t\t \"quotafile must be on filesystem root\");\n\t\treturn -EINVAL;\n\t}\n\tif (ctx->s_qf_names[qtype]) {\n\t\tif (strcmp(ctx->s_qf_names[qtype], param->string) != 0) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tqname = kmemdup_nul(param->string, param->size, GFP_KERNEL);\n\tif (!qname) {\n\t\text4_msg(NULL, KERN_ERR,\n\t\t\t \"Not enough memory for storing quotafile name\");\n\t\treturn -ENOMEM;\n\t}\n\tctx->s_qf_names[qtype] = qname;\n\tctx->qname_spec |= 1 << qtype;\n\tctx->spec |= EXT4_SPEC_JQUOTA;\n\treturn 0;\n}\n\n \nstatic int unnote_qf_name(struct fs_context *fc, int qtype)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\n\tif (ctx->s_qf_names[qtype])\n\t\tkfree(ctx->s_qf_names[qtype]);\n\n\tctx->s_qf_names[qtype] = NULL;\n\tctx->qname_spec |= 1 << qtype;\n\tctx->spec |= EXT4_SPEC_JQUOTA;\n\treturn 0;\n}\n#endif\n\nstatic int ext4_parse_test_dummy_encryption(const struct fs_parameter *param,\n\t\t\t\t\t    struct ext4_fs_context *ctx)\n{\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_FS_ENCRYPTION)) {\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"test_dummy_encryption option not supported\");\n\t\treturn -EINVAL;\n\t}\n\terr = fscrypt_parse_test_dummy_encryption(param,\n\t\t\t\t\t\t  &ctx->dummy_enc_policy);\n\tif (err == -EINVAL) {\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"Value of option \\\"%s\\\" is unrecognized\", param->key);\n\t} else if (err == -EEXIST) {\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"Conflicting test_dummy_encryption options\");\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\n#define EXT4_SET_CTX(name)\t\t\t\t\t\t\\\nstatic inline void ctx_set_##name(struct ext4_fs_context *ctx,\t\t\\\n\t\t\t\t  unsigned long flag)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tctx->mask_s_##name |= flag;\t\t\t\t\t\\\n\tctx->vals_s_##name |= flag;\t\t\t\t\t\\\n}\n\n#define EXT4_CLEAR_CTX(name)\t\t\t\t\t\t\\\nstatic inline void ctx_clear_##name(struct ext4_fs_context *ctx,\t\\\n\t\t\t\t    unsigned long flag)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tctx->mask_s_##name |= flag;\t\t\t\t\t\\\n\tctx->vals_s_##name &= ~flag;\t\t\t\t\t\\\n}\n\n#define EXT4_TEST_CTX(name)\t\t\t\t\t\t\\\nstatic inline unsigned long\t\t\t\t\t\t\\\nctx_test_##name(struct ext4_fs_context *ctx, unsigned long flag)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (ctx->vals_s_##name & flag);\t\t\t\t\\\n}\n\nEXT4_SET_CTX(flags);  \nEXT4_SET_CTX(mount_opt);\nEXT4_CLEAR_CTX(mount_opt);\nEXT4_TEST_CTX(mount_opt);\nEXT4_SET_CTX(mount_opt2);\nEXT4_CLEAR_CTX(mount_opt2);\nEXT4_TEST_CTX(mount_opt2);\n\nstatic int ext4_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct fs_parse_result result;\n\tconst struct mount_opts *m;\n\tint is_remount;\n\tkuid_t uid;\n\tkgid_t gid;\n\tint token;\n\n\ttoken = fs_parse(fc, ext4_param_specs, param, &result);\n\tif (token < 0)\n\t\treturn token;\n\tis_remount = fc->purpose == FS_CONTEXT_FOR_RECONFIGURE;\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++)\n\t\tif (token == m->token)\n\t\t\tbreak;\n\n\tctx->opt_flags |= m->flags;\n\n\tif (m->flags & MOPT_EXPLICIT) {\n\t\tif (m->mount_opt & EXT4_MOUNT_DELALLOC) {\n\t\t\tctx_set_mount_opt2(ctx, EXT4_MOUNT2_EXPLICIT_DELALLOC);\n\t\t} else if (m->mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) {\n\t\t\tctx_set_mount_opt2(ctx,\n\t\t\t\t       EXT4_MOUNT2_EXPLICIT_JOURNAL_CHECKSUM);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (m->flags & MOPT_NOSUPPORT) {\n\t\text4_msg(NULL, KERN_ERR, \"%s option not supported\",\n\t\t\t param->key);\n\t\treturn 0;\n\t}\n\n\tswitch (token) {\n#ifdef CONFIG_QUOTA\n\tcase Opt_usrjquota:\n\t\tif (!*param->string)\n\t\t\treturn unnote_qf_name(fc, USRQUOTA);\n\t\telse\n\t\t\treturn note_qf_name(fc, USRQUOTA, param);\n\tcase Opt_grpjquota:\n\t\tif (!*param->string)\n\t\t\treturn unnote_qf_name(fc, GRPQUOTA);\n\t\telse\n\t\t\treturn note_qf_name(fc, GRPQUOTA, param);\n#endif\n\tcase Opt_sb:\n\t\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {\n\t\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t\t \"Ignoring %s option on remount\", param->key);\n\t\t} else {\n\t\t\tctx->s_sb_block = result.uint_32;\n\t\t\tctx->spec |= EXT4_SPEC_s_sb_block;\n\t\t}\n\t\treturn 0;\n\tcase Opt_removed:\n\t\text4_msg(NULL, KERN_WARNING, \"Ignoring removed %s option\",\n\t\t\t param->key);\n\t\treturn 0;\n\tcase Opt_inlinecrypt:\n#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT\n\t\tctx_set_flags(ctx, SB_INLINECRYPT);\n#else\n\t\text4_msg(NULL, KERN_ERR, \"inline encryption not supported\");\n#endif\n\t\treturn 0;\n\tcase Opt_errors:\n\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_ERRORS_MASK);\n\t\tctx_set_mount_opt(ctx, result.uint_32);\n\t\treturn 0;\n#ifdef CONFIG_QUOTA\n\tcase Opt_jqfmt:\n\t\tctx->s_jquota_fmt = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_JQFMT;\n\t\treturn 0;\n#endif\n\tcase Opt_data:\n\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_DATA_FLAGS);\n\t\tctx_set_mount_opt(ctx, result.uint_32);\n\t\tctx->spec |= EXT4_SPEC_DATAJ;\n\t\treturn 0;\n\tcase Opt_commit:\n\t\tif (result.uint_32 == 0)\n\t\t\tresult.uint_32 = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\telse if (result.uint_32 > INT_MAX / HZ) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"Invalid commit interval %d, \"\n\t\t\t\t \"must be smaller than %d\",\n\t\t\t\t result.uint_32, INT_MAX / HZ);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->s_commit_interval = HZ * result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_commit_interval;\n\t\treturn 0;\n\tcase Opt_debug_want_extra_isize:\n\t\tif ((result.uint_32 & 1) || (result.uint_32 < 4)) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"Invalid want_extra_isize %d\", result.uint_32);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->s_want_extra_isize = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_want_extra_isize;\n\t\treturn 0;\n\tcase Opt_max_batch_time:\n\t\tctx->s_max_batch_time = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_max_batch_time;\n\t\treturn 0;\n\tcase Opt_min_batch_time:\n\t\tctx->s_min_batch_time = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_min_batch_time;\n\t\treturn 0;\n\tcase Opt_inode_readahead_blks:\n\t\tif (result.uint_32 &&\n\t\t    (result.uint_32 > (1 << 30) ||\n\t\t     !is_power_of_2(result.uint_32))) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"EXT4-fs: inode_readahead_blks must be \"\n\t\t\t\t \"0 or a power of 2 smaller than 2^31\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->s_inode_readahead_blks = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_inode_readahead_blks;\n\t\treturn 0;\n\tcase Opt_init_itable:\n\t\tctx_set_mount_opt(ctx, EXT4_MOUNT_INIT_INODE_TABLE);\n\t\tctx->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\t\tif (param->type == fs_value_is_string)\n\t\t\tctx->s_li_wait_mult = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_li_wait_mult;\n\t\treturn 0;\n\tcase Opt_max_dir_size_kb:\n\t\tctx->s_max_dir_size_kb = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_max_dir_size_kb;\n\t\treturn 0;\n#ifdef CONFIG_EXT4_DEBUG\n\tcase Opt_fc_debug_max_replay:\n\t\tctx->s_fc_debug_max_replay = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_fc_debug_max_replay;\n\t\treturn 0;\n#endif\n\tcase Opt_stripe:\n\t\tctx->s_stripe = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_s_stripe;\n\t\treturn 0;\n\tcase Opt_resuid:\n\t\tuid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(uid)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"Invalid uid value %d\",\n\t\t\t\t result.uint_32);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->s_resuid = uid;\n\t\tctx->spec |= EXT4_SPEC_s_resuid;\n\t\treturn 0;\n\tcase Opt_resgid:\n\t\tgid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(gid)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"Invalid gid value %d\",\n\t\t\t\t result.uint_32);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->s_resgid = gid;\n\t\tctx->spec |= EXT4_SPEC_s_resgid;\n\t\treturn 0;\n\tcase Opt_journal_dev:\n\t\tif (is_remount) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->journal_devnum = result.uint_32;\n\t\tctx->spec |= EXT4_SPEC_JOURNAL_DEV;\n\t\treturn 0;\n\tcase Opt_journal_path:\n\t{\n\t\tstruct inode *journal_inode;\n\t\tstruct path path;\n\t\tint error;\n\n\t\tif (is_remount) {\n\t\t\text4_msg(NULL, KERN_ERR,\n\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terror = fs_lookup_param(fc, param, 1, LOOKUP_FOLLOW, &path);\n\t\tif (error) {\n\t\t\text4_msg(NULL, KERN_ERR, \"error: could not find \"\n\t\t\t\t \"journal device path\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tjournal_inode = d_inode(path.dentry);\n\t\tctx->journal_devnum = new_encode_dev(journal_inode->i_rdev);\n\t\tctx->spec |= EXT4_SPEC_JOURNAL_DEV;\n\t\tpath_put(&path);\n\t\treturn 0;\n\t}\n\tcase Opt_journal_ioprio:\n\t\tif (result.uint_32 > 7) {\n\t\t\text4_msg(NULL, KERN_ERR, \"Invalid journal IO priority\"\n\t\t\t\t \" (must be 0-7)\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->journal_ioprio =\n\t\t\tIOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, result.uint_32);\n\t\tctx->spec |= EXT4_SPEC_JOURNAL_IOPRIO;\n\t\treturn 0;\n\tcase Opt_test_dummy_encryption:\n\t\treturn ext4_parse_test_dummy_encryption(param, ctx);\n\tcase Opt_dax:\n\tcase Opt_dax_type:\n#ifdef CONFIG_FS_DAX\n\t{\n\t\tint type = (token == Opt_dax) ?\n\t\t\t   Opt_dax : result.uint_32;\n\n\t\tswitch (type) {\n\t\tcase Opt_dax:\n\t\tcase Opt_dax_always:\n\t\t\tctx_set_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);\n\t\t\tctx_clear_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);\n\t\t\tbreak;\n\t\tcase Opt_dax_never:\n\t\t\tctx_set_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);\n\t\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);\n\t\t\tbreak;\n\t\tcase Opt_dax_inode:\n\t\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);\n\t\t\tctx_clear_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);\n\t\t\t \n\t\t\tctx_set_mount_opt2(ctx, EXT4_MOUNT2_DAX_INODE);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n#else\n\t\text4_msg(NULL, KERN_INFO, \"dax option not supported\");\n\t\treturn -EINVAL;\n#endif\n\tcase Opt_data_err:\n\t\tif (result.uint_32 == Opt_data_err_abort)\n\t\t\tctx_set_mount_opt(ctx, m->mount_opt);\n\t\telse if (result.uint_32 == Opt_data_err_ignore)\n\t\t\tctx_clear_mount_opt(ctx, m->mount_opt);\n\t\treturn 0;\n\tcase Opt_mb_optimize_scan:\n\t\tif (result.int_32 == 1) {\n\t\t\tctx_set_mount_opt2(ctx, EXT4_MOUNT2_MB_OPTIMIZE_SCAN);\n\t\t\tctx->spec |= EXT4_SPEC_mb_optimize_scan;\n\t\t} else if (result.int_32 == 0) {\n\t\t\tctx_clear_mount_opt2(ctx, EXT4_MOUNT2_MB_OPTIMIZE_SCAN);\n\t\t\tctx->spec |= EXT4_SPEC_mb_optimize_scan;\n\t\t} else {\n\t\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t\t \"mb_optimize_scan should be set to 0 or 1.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (m->token == Opt_err) {\n\t\text4_msg(NULL, KERN_WARNING, \"buggy handling of option %s\",\n\t\t\t param->key);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\telse {\n\t\tunsigned int set = 0;\n\n\t\tif ((param->type == fs_value_is_flag) ||\n\t\t    result.uint_32 > 0)\n\t\t\tset = 1;\n\n\t\tif (m->flags & MOPT_CLEAR)\n\t\t\tset = !set;\n\t\telse if (unlikely(!(m->flags & MOPT_SET))) {\n\t\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t\t \"buggy handling of option %s\",\n\t\t\t\t param->key);\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (m->flags & MOPT_2) {\n\t\t\tif (set != 0)\n\t\t\t\tctx_set_mount_opt2(ctx, m->mount_opt);\n\t\t\telse\n\t\t\t\tctx_clear_mount_opt2(ctx, m->mount_opt);\n\t\t} else {\n\t\t\tif (set != 0)\n\t\t\t\tctx_set_mount_opt(ctx, m->mount_opt);\n\t\t\telse\n\t\t\t\tctx_clear_mount_opt(ctx, m->mount_opt);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_options(struct fs_context *fc, char *options)\n{\n\tstruct fs_parameter param;\n\tint ret;\n\tchar *key;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((key = strsep(&options, \",\")) != NULL) {\n\t\tif (*key) {\n\t\t\tsize_t v_len = 0;\n\t\t\tchar *value = strchr(key, '=');\n\n\t\t\tparam.type = fs_value_is_flag;\n\t\t\tparam.string = NULL;\n\n\t\t\tif (value) {\n\t\t\t\tif (value == key)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t*value++ = 0;\n\t\t\t\tv_len = strlen(value);\n\t\t\t\tparam.string = kmemdup_nul(value, v_len,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\t\tif (!param.string)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tparam.type = fs_value_is_string;\n\t\t\t}\n\n\t\t\tparam.key = key;\n\t\t\tparam.size = v_len;\n\n\t\t\tret = ext4_parse_param(fc, &param);\n\t\t\tif (param.string)\n\t\t\t\tkfree(param.string);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ext4_validate_options(fc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int parse_apply_sb_mount_options(struct super_block *sb,\n\t\t\t\t\tstruct ext4_fs_context *m_ctx)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *s_mount_opts = NULL;\n\tstruct ext4_fs_context *s_ctx = NULL;\n\tstruct fs_context *fc = NULL;\n\tint ret = -ENOMEM;\n\n\tif (!sbi->s_es->s_mount_opts[0])\n\t\treturn 0;\n\n\ts_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\tsizeof(sbi->s_es->s_mount_opts),\n\t\t\t\tGFP_KERNEL);\n\tif (!s_mount_opts)\n\t\treturn ret;\n\n\tfc = kzalloc(sizeof(struct fs_context), GFP_KERNEL);\n\tif (!fc)\n\t\tgoto out_free;\n\n\ts_ctx = kzalloc(sizeof(struct ext4_fs_context), GFP_KERNEL);\n\tif (!s_ctx)\n\t\tgoto out_free;\n\n\tfc->fs_private = s_ctx;\n\tfc->s_fs_info = sbi;\n\n\tret = parse_options(fc, s_mount_opts);\n\tif (ret < 0)\n\t\tgoto parse_failed;\n\n\tret = ext4_check_opt_consistency(fc, sb);\n\tif (ret < 0) {\nparse_failed:\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t s_mount_opts);\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tif (s_ctx->spec & EXT4_SPEC_JOURNAL_DEV)\n\t\tm_ctx->journal_devnum = s_ctx->journal_devnum;\n\tif (s_ctx->spec & EXT4_SPEC_JOURNAL_IOPRIO)\n\t\tm_ctx->journal_ioprio = s_ctx->journal_ioprio;\n\n\text4_apply_options(fc, sb);\n\tret = 0;\n\nout_free:\n\tif (fc) {\n\t\text4_fc_free(fc);\n\t\tkfree(fc);\n\t}\n\tkfree(s_mount_opts);\n\treturn ret;\n}\n\nstatic void ext4_apply_quota_options(struct fs_context *fc,\n\t\t\t\t     struct super_block *sb)\n{\n#ifdef CONFIG_QUOTA\n\tbool quota_feature = ext4_has_feature_quota(sb);\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *qname;\n\tint i;\n\n\tif (quota_feature)\n\t\treturn;\n\n\tif (ctx->spec & EXT4_SPEC_JQUOTA) {\n\t\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\t\tif (!(ctx->qname_spec & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\tqname = ctx->s_qf_names[i];  \n\t\t\tif (qname)\n\t\t\t\tset_opt(sb, QUOTA);\n\t\t\tctx->s_qf_names[i] = NULL;\n\t\t\tqname = rcu_replace_pointer(sbi->s_qf_names[i], qname,\n\t\t\t\t\t\tlockdep_is_held(&sb->s_umount));\n\t\t\tif (qname)\n\t\t\t\tkfree_rcu_mightsleep(qname);\n\t\t}\n\t}\n\n\tif (ctx->spec & EXT4_SPEC_JQFMT)\n\t\tsbi->s_jquota_fmt = ctx->s_jquota_fmt;\n#endif\n}\n\n \nstatic int ext4_check_quota_consistency(struct fs_context *fc,\n\t\t\t\t\tstruct super_block *sb)\n{\n#ifdef CONFIG_QUOTA\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tbool quota_feature = ext4_has_feature_quota(sb);\n\tbool quota_loaded = sb_any_quota_loaded(sb);\n\tbool usr_qf_name, grp_qf_name, usrquota, grpquota;\n\tint quota_flags, i;\n\n\t \n\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_PRJQUOTA) &&\n\t    !ext4_has_feature_project(sb)) {\n\t\text4_msg(NULL, KERN_ERR, \"Project quota feature not enabled. \"\n\t\t\t \"Cannot enable project quota enforcement.\");\n\t\treturn -EINVAL;\n\t}\n\n\tquota_flags = EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |\n\t\t      EXT4_MOUNT_GRPQUOTA | EXT4_MOUNT_PRJQUOTA;\n\tif (quota_loaded &&\n\t    ctx->mask_s_mount_opt & quota_flags &&\n\t    !ctx_test_mount_opt(ctx, quota_flags))\n\t\tgoto err_quota_change;\n\n\tif (ctx->spec & EXT4_SPEC_JQUOTA) {\n\n\t\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\t\tif (!(ctx->qname_spec & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\tif (quota_loaded &&\n\t\t\t    !!sbi->s_qf_names[i] != !!ctx->s_qf_names[i])\n\t\t\t\tgoto err_jquota_change;\n\n\t\t\tif (sbi->s_qf_names[i] && ctx->s_qf_names[i] &&\n\t\t\t    strcmp(get_qf_name(sb, sbi, i),\n\t\t\t\t   ctx->s_qf_names[i]) != 0)\n\t\t\t\tgoto err_jquota_specified;\n\t\t}\n\n\t\tif (quota_feature) {\n\t\t\text4_msg(NULL, KERN_INFO,\n\t\t\t\t \"Journaled quota options ignored when \"\n\t\t\t\t \"QUOTA feature is enabled\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (ctx->spec & EXT4_SPEC_JQFMT) {\n\t\tif (sbi->s_jquota_fmt != ctx->s_jquota_fmt && quota_loaded)\n\t\t\tgoto err_jquota_change;\n\t\tif (quota_feature) {\n\t\t\text4_msg(NULL, KERN_INFO, \"Quota format mount options \"\n\t\t\t\t \"ignored when QUOTA feature is enabled\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tusr_qf_name = (get_qf_name(sb, sbi, USRQUOTA) ||\n\t\t       ctx->s_qf_names[USRQUOTA]);\n\tgrp_qf_name = (get_qf_name(sb, sbi, GRPQUOTA) ||\n\t\t       ctx->s_qf_names[GRPQUOTA]);\n\n\tusrquota = (ctx_test_mount_opt(ctx, EXT4_MOUNT_USRQUOTA) ||\n\t\t    test_opt(sb, USRQUOTA));\n\n\tgrpquota = (ctx_test_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA) ||\n\t\t    test_opt(sb, GRPQUOTA));\n\n\tif (usr_qf_name) {\n\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_USRQUOTA);\n\t\tusrquota = false;\n\t}\n\tif (grp_qf_name) {\n\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA);\n\t\tgrpquota = false;\n\t}\n\n\tif (usr_qf_name || grp_qf_name) {\n\t\tif (usrquota || grpquota) {\n\t\t\text4_msg(NULL, KERN_ERR, \"old and new quota \"\n\t\t\t\t \"format mixing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(ctx->spec & EXT4_SPEC_JQFMT || sbi->s_jquota_fmt)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"journaled quota format \"\n\t\t\t\t \"not specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_quota_change:\n\text4_msg(NULL, KERN_ERR,\n\t\t \"Cannot change quota options when quota turned on\");\n\treturn -EINVAL;\nerr_jquota_change:\n\text4_msg(NULL, KERN_ERR, \"Cannot change journaled quota \"\n\t\t \"options when quota turned on\");\n\treturn -EINVAL;\nerr_jquota_specified:\n\text4_msg(NULL, KERN_ERR, \"%s quota file already specified\",\n\t\t QTYPE2NAME(i));\n\treturn -EINVAL;\n#else\n\treturn 0;\n#endif\n}\n\nstatic int ext4_check_test_dummy_encryption(const struct fs_context *fc,\n\t\t\t\t\t    struct super_block *sb)\n{\n\tconst struct ext4_fs_context *ctx = fc->fs_private;\n\tconst struct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!fscrypt_is_dummy_policy_set(&ctx->dummy_enc_policy))\n\t\treturn 0;\n\n\tif (!ext4_has_feature_encrypt(sb)) {\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"test_dummy_encryption requires encrypt feature\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {\n\t\tif (fscrypt_dummy_policies_equal(&sbi->s_dummy_enc_policy,\n\t\t\t\t\t\t &ctx->dummy_enc_policy))\n\t\t\treturn 0;\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"Can't set or change test_dummy_encryption on remount\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (fscrypt_is_dummy_policy_set(&sbi->s_dummy_enc_policy)) {\n\t\tif (fscrypt_dummy_policies_equal(&sbi->s_dummy_enc_policy,\n\t\t\t\t\t\t &ctx->dummy_enc_policy))\n\t\t\treturn 0;\n\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t \"Conflicting test_dummy_encryption options\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void ext4_apply_test_dummy_encryption(struct ext4_fs_context *ctx,\n\t\t\t\t\t     struct super_block *sb)\n{\n\tif (!fscrypt_is_dummy_policy_set(&ctx->dummy_enc_policy) ||\n\t     \n\t    fscrypt_is_dummy_policy_set(&EXT4_SB(sb)->s_dummy_enc_policy))\n\t\treturn;\n\tEXT4_SB(sb)->s_dummy_enc_policy = ctx->dummy_enc_policy;\n\tmemset(&ctx->dummy_enc_policy, 0, sizeof(ctx->dummy_enc_policy));\n\text4_msg(sb, KERN_WARNING, \"Test dummy encryption mode enabled\");\n}\n\nstatic int ext4_check_opt_consistency(struct fs_context *fc,\n\t\t\t\t      struct super_block *sb)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_sb_info *sbi = fc->s_fs_info;\n\tint is_remount = fc->purpose == FS_CONTEXT_FOR_RECONFIGURE;\n\tint err;\n\n\tif ((ctx->opt_flags & MOPT_NO_EXT2) && IS_EXT2_SB(sb)) {\n\t\text4_msg(NULL, KERN_ERR,\n\t\t\t \"Mount option(s) incompatible with ext2\");\n\t\treturn -EINVAL;\n\t}\n\tif ((ctx->opt_flags & MOPT_NO_EXT3) && IS_EXT3_SB(sb)) {\n\t\text4_msg(NULL, KERN_ERR,\n\t\t\t \"Mount option(s) incompatible with ext3\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->s_want_extra_isize >\n\t    (sbi->s_inode_size - EXT4_GOOD_OLD_INODE_SIZE)) {\n\t\text4_msg(NULL, KERN_ERR,\n\t\t\t \"Invalid want_extra_isize %d\",\n\t\t\t ctx->s_want_extra_isize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\t\tif (blocksize < PAGE_SIZE)\n\t\t\text4_msg(NULL, KERN_WARNING, \"Warning: mounting with an \"\n\t\t\t\t \"experimental mount option 'dioread_nolock' \"\n\t\t\t\t \"for blocksize < PAGE_SIZE\");\n\t}\n\n\terr = ext4_check_test_dummy_encryption(fc, sb);\n\tif (err)\n\t\treturn err;\n\n\tif ((ctx->spec & EXT4_SPEC_DATAJ) && is_remount) {\n\t\tif (!sbi->s_journal) {\n\t\t\text4_msg(NULL, KERN_WARNING,\n\t\t\t\t \"Remounting file system with no journal \"\n\t\t\t\t \"so ignoring journalled data option\");\n\t\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_DATA_FLAGS);\n\t\t} else if (ctx_test_mount_opt(ctx, EXT4_MOUNT_DATA_FLAGS) !=\n\t\t\t   test_opt(sb, DATA_FLAGS)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"Cannot change data mode \"\n\t\t\t\t \"on remount\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (is_remount) {\n\t\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS) &&\n\t\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS) &&\n\t\t    (!(sbi->s_mount_opt & EXT4_MOUNT_DAX_ALWAYS) ||\n\t\t     (sbi->s_mount_opt2 & EXT4_MOUNT2_DAX_NEVER))) {\nfail_dax_change_remount:\n\t\t\text4_msg(NULL, KERN_ERR, \"can't change \"\n\t\t\t\t \"dax mount option while remounting\");\n\t\t\treturn -EINVAL;\n\t\t} else if (ctx_test_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER) &&\n\t\t\t (!(sbi->s_mount_opt2 & EXT4_MOUNT2_DAX_NEVER) ||\n\t\t\t  (sbi->s_mount_opt & EXT4_MOUNT_DAX_ALWAYS))) {\n\t\t\tgoto fail_dax_change_remount;\n\t\t} else if (ctx_test_mount_opt2(ctx, EXT4_MOUNT2_DAX_INODE) &&\n\t\t\t   ((sbi->s_mount_opt & EXT4_MOUNT_DAX_ALWAYS) ||\n\t\t\t    (sbi->s_mount_opt2 & EXT4_MOUNT2_DAX_NEVER) ||\n\t\t\t    !(sbi->s_mount_opt2 & EXT4_MOUNT2_DAX_INODE))) {\n\t\t\tgoto fail_dax_change_remount;\n\t\t}\n\t}\n\n\treturn ext4_check_quota_consistency(fc, sb);\n}\n\nstatic void ext4_apply_options(struct fs_context *fc, struct super_block *sb)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_sb_info *sbi = fc->s_fs_info;\n\n\tsbi->s_mount_opt &= ~ctx->mask_s_mount_opt;\n\tsbi->s_mount_opt |= ctx->vals_s_mount_opt;\n\tsbi->s_mount_opt2 &= ~ctx->mask_s_mount_opt2;\n\tsbi->s_mount_opt2 |= ctx->vals_s_mount_opt2;\n\tsb->s_flags &= ~ctx->mask_s_flags;\n\tsb->s_flags |= ctx->vals_s_flags;\n\n#define APPLY(X) ({ if (ctx->spec & EXT4_SPEC_##X) sbi->X = ctx->X; })\n\tAPPLY(s_commit_interval);\n\tAPPLY(s_stripe);\n\tAPPLY(s_max_batch_time);\n\tAPPLY(s_min_batch_time);\n\tAPPLY(s_want_extra_isize);\n\tAPPLY(s_inode_readahead_blks);\n\tAPPLY(s_max_dir_size_kb);\n\tAPPLY(s_li_wait_mult);\n\tAPPLY(s_resgid);\n\tAPPLY(s_resuid);\n\n#ifdef CONFIG_EXT4_DEBUG\n\tAPPLY(s_fc_debug_max_replay);\n#endif\n\n\text4_apply_quota_options(fc, sb);\n\text4_apply_test_dummy_encryption(ctx, sb);\n}\n\n\nstatic int ext4_validate_options(struct fs_context *fc)\n{\n#ifdef CONFIG_QUOTA\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tchar *usr_qf_name, *grp_qf_name;\n\n\tusr_qf_name = ctx->s_qf_names[USRQUOTA];\n\tgrp_qf_name = ctx->s_qf_names[GRPQUOTA];\n\n\tif (usr_qf_name || grp_qf_name) {\n\t\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_USRQUOTA) && usr_qf_name)\n\t\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_USRQUOTA);\n\n\t\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA) && grp_qf_name)\n\t\t\tctx_clear_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA);\n\n\t\tif (ctx_test_mount_opt(ctx, EXT4_MOUNT_USRQUOTA) ||\n\t\t    ctx_test_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA)) {\n\t\t\text4_msg(NULL, KERN_ERR, \"old and new quota \"\n\t\t\t\t \"format mixing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic inline void ext4_show_quota_options(struct seq_file *seq,\n\t\t\t\t\t   struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *usr_qf_name, *grp_qf_name;\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\trcu_read_lock();\n\tusr_qf_name = rcu_dereference(sbi->s_qf_names[USRQUOTA]);\n\tgrp_qf_name = rcu_dereference(sbi->s_qf_names[GRPQUOTA]);\n\tif (usr_qf_name)\n\t\tseq_show_option(seq, \"usrjquota\", usr_qf_name);\n\tif (grp_qf_name)\n\t\tseq_show_option(seq, \"grpjquota\", grp_qf_name);\n\trcu_read_unlock();\n#endif\n}\n\nstatic const char *token2str(int token)\n{\n\tconst struct fs_parameter_spec *spec;\n\n\tfor (spec = ext4_param_specs; spec->name != NULL; spec++)\n\t\tif (spec->opt == token && !spec->type)\n\t\t\tbreak;\n\treturn spec->name;\n}\n\n \nstatic int _ext4_show_options(struct seq_file *seq, struct super_block *sb,\n\t\t\t      int nodefs)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint def_errors;\n\tconst struct mount_opts *m;\n\tchar sep = nodefs ? '\\n' : ',';\n\n#define SEQ_OPTS_PUTS(str) seq_printf(seq, \"%c\" str, sep)\n#define SEQ_OPTS_PRINT(str, arg) seq_printf(seq, \"%c\" str, sep, arg)\n\n\tif (sbi->s_sb_block != 1)\n\t\tSEQ_OPTS_PRINT(\"sb=%llu\", sbi->s_sb_block);\n\n\tfor (m = ext4_mount_opts; m->token != Opt_err; m++) {\n\t\tint want_set = m->flags & MOPT_SET;\n\t\tint opt_2 = m->flags & MOPT_2;\n\t\tunsigned int mount_opt, def_mount_opt;\n\n\t\tif (((m->flags & (MOPT_SET|MOPT_CLEAR)) == 0) ||\n\t\t    m->flags & MOPT_SKIP)\n\t\t\tcontinue;\n\n\t\tif (opt_2) {\n\t\t\tmount_opt = sbi->s_mount_opt2;\n\t\t\tdef_mount_opt = sbi->s_def_mount_opt2;\n\t\t} else {\n\t\t\tmount_opt = sbi->s_mount_opt;\n\t\t\tdef_mount_opt = sbi->s_def_mount_opt;\n\t\t}\n\t\t \n\t\tif (!nodefs && !(m->mount_opt & (mount_opt ^ def_mount_opt)))\n\t\t\tcontinue;\n\t\t \n\t\tif ((want_set &&\n\t\t     (mount_opt & m->mount_opt) != m->mount_opt) ||\n\t\t    (!want_set && (mount_opt & m->mount_opt)))\n\t\t\tcontinue;\n\t\tSEQ_OPTS_PRINT(\"%s\", token2str(m->token));\n\t}\n\n\tif (nodefs || !uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT4_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID)\n\t\tSEQ_OPTS_PRINT(\"resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\tif (nodefs || !gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT4_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID)\n\t\tSEQ_OPTS_PRINT(\"resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\tdef_errors = nodefs ? -1 : le16_to_cpu(es->s_errors);\n\tif (test_opt(sb, ERRORS_RO) && def_errors != EXT4_ERRORS_RO)\n\t\tSEQ_OPTS_PUTS(\"errors=remount-ro\");\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tSEQ_OPTS_PUTS(\"errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tSEQ_OPTS_PUTS(\"errors=panic\");\n\tif (nodefs || sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ)\n\t\tSEQ_OPTS_PRINT(\"commit=%lu\", sbi->s_commit_interval / HZ);\n\tif (nodefs || sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"min_batch_time=%u\", sbi->s_min_batch_time);\n\tif (nodefs || sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME)\n\t\tSEQ_OPTS_PRINT(\"max_batch_time=%u\", sbi->s_max_batch_time);\n\tif (nodefs || sbi->s_stripe)\n\t\tSEQ_OPTS_PRINT(\"stripe=%lu\", sbi->s_stripe);\n\tif (nodefs || EXT4_MOUNT_DATA_FLAGS &\n\t\t\t(sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=journal\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=ordered\");\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\t\tSEQ_OPTS_PUTS(\"data=writeback\");\n\t}\n\tif (nodefs ||\n\t    sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tSEQ_OPTS_PRINT(\"inode_readahead_blks=%u\",\n\t\t\t       sbi->s_inode_readahead_blks);\n\n\tif (test_opt(sb, INIT_INODE_TABLE) && (nodefs ||\n\t\t       (sbi->s_li_wait_mult != EXT4_DEF_LI_WAIT_MULT)))\n\t\tSEQ_OPTS_PRINT(\"init_itable=%u\", sbi->s_li_wait_mult);\n\tif (nodefs || sbi->s_max_dir_size_kb)\n\t\tSEQ_OPTS_PRINT(\"max_dir_size_kb=%u\", sbi->s_max_dir_size_kb);\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tSEQ_OPTS_PUTS(\"data_err=abort\");\n\n\tfscrypt_show_test_dummy_encryption(seq, sep, sb);\n\n\tif (sb->s_flags & SB_INLINECRYPT)\n\t\tSEQ_OPTS_PUTS(\"inlinecrypt\");\n\n\tif (test_opt(sb, DAX_ALWAYS)) {\n\t\tif (IS_EXT2_SB(sb))\n\t\t\tSEQ_OPTS_PUTS(\"dax\");\n\t\telse\n\t\t\tSEQ_OPTS_PUTS(\"dax=always\");\n\t} else if (test_opt2(sb, DAX_NEVER)) {\n\t\tSEQ_OPTS_PUTS(\"dax=never\");\n\t} else if (test_opt2(sb, DAX_INODE)) {\n\t\tSEQ_OPTS_PUTS(\"dax=inode\");\n\t}\n\n\tif (sbi->s_groups_count >= MB_DEFAULT_LINEAR_SCAN_THRESHOLD &&\n\t\t\t!test_opt2(sb, MB_OPTIMIZE_SCAN)) {\n\t\tSEQ_OPTS_PUTS(\"mb_optimize_scan=0\");\n\t} else if (sbi->s_groups_count < MB_DEFAULT_LINEAR_SCAN_THRESHOLD &&\n\t\t\ttest_opt2(sb, MB_OPTIMIZE_SCAN)) {\n\t\tSEQ_OPTS_PUTS(\"mb_optimize_scan=1\");\n\t}\n\n\text4_show_quota_options(seq, sb);\n\treturn 0;\n}\n\nstatic int ext4_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn _ext4_show_options(seq, root->d_sb, 0);\n}\n\nint ext4_seq_options_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tint rc;\n\n\tseq_puts(seq, sb_rdonly(sb) ? \"ro\" : \"rw\");\n\trc = _ext4_show_options(seq, sb, 1);\n\tseq_puts(seq, \"\\n\");\n\treturn rc;\n}\n\nstatic int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\terr = -EROFS;\n\t\tgoto done;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t (ext4_get_tstamp(es, s_lastcheck) +\n\t\t  le32_to_cpu(es->s_checkinterval) <= ktime_get_real_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\text4_update_tstamp(es, s_mtime);\n\tif (sbi->s_journal) {\n\t\text4_set_feature_journal_needs_recovery(sb);\n\t\tif (ext4_has_feature_orphan_file(sb))\n\t\t\text4_set_feature_orphan_present(sb);\n\t}\n\n\terr = ext4_commit_super(sb);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\treturn err;\n}\n\nint ext4_alloc_flex_bg_array(struct super_block *sb, ext4_group_t ngroup)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct flex_groups **old_groups, **new_groups;\n\tint size, i, j;\n\n\tif (!sbi->s_log_groups_per_flex)\n\t\treturn 0;\n\n\tsize = ext4_flex_group(sbi, ngroup - 1) + 1;\n\tif (size <= sbi->s_flex_groups_allocated)\n\t\treturn 0;\n\n\tnew_groups = kvzalloc(roundup_pow_of_two(size *\n\t\t\t      sizeof(*sbi->s_flex_groups)), GFP_KERNEL);\n\tif (!new_groups) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"not enough memory for %d flex group pointers\", size);\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = sbi->s_flex_groups_allocated; i < size; i++) {\n\t\tnew_groups[i] = kvzalloc(roundup_pow_of_two(\n\t\t\t\t\t sizeof(struct flex_groups)),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!new_groups[i]) {\n\t\t\tfor (j = sbi->s_flex_groups_allocated; j < i; j++)\n\t\t\t\tkvfree(new_groups[j]);\n\t\t\tkvfree(new_groups);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"not enough memory for %d flex groups\", size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\trcu_read_lock();\n\told_groups = rcu_dereference(sbi->s_flex_groups);\n\tif (old_groups)\n\t\tmemcpy(new_groups, old_groups,\n\t\t       (sbi->s_flex_groups_allocated *\n\t\t\tsizeof(struct flex_groups *)));\n\trcu_read_unlock();\n\trcu_assign_pointer(sbi->s_flex_groups, new_groups);\n\tsbi->s_flex_groups_allocated = size;\n\tif (old_groups)\n\t\text4_kvfree_array_rcu(old_groups);\n\treturn 0;\n}\n\nstatic int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct flex_groups *fg;\n\text4_group_t flex_group;\n\tint i, err;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\terr = ext4_alloc_flex_bg_array(sb, sbi->s_groups_count);\n\tif (err)\n\t\tgoto failed;\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tfg = sbi_array_rcu_deref(sbi, s_flex_groups, flex_group);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp), &fg->free_inodes);\n\t\tatomic64_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t     &fg->free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp), &fg->used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}\n\nstatic __le16 ext4_group_desc_csum(struct super_block *sb, __u32 block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tint offset = offsetof(struct ext4_group_desc, bg_checksum);\n\t__u16 crc = 0;\n\t__le32 le_group = cpu_to_le32(block_group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sbi->s_sb)) {\n\t\t \n\t\t__u32 csum32;\n\t\t__u16 dummy_csum = 0;\n\n\t\tcsum32 = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&le_group,\n\t\t\t\t     sizeof(le_group));\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp, offset);\n\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)&dummy_csum,\n\t\t\t\t     sizeof(dummy_csum));\n\t\toffset += sizeof(dummy_csum);\n\t\tif (offset < sbi->s_desc_size)\n\t\t\tcsum32 = ext4_chksum(sbi, csum32, (__u8 *)gdp + offset,\n\t\t\t\t\t     sbi->s_desc_size - offset);\n\n\t\tcrc = csum32 & 0xFFFF;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!ext4_has_feature_gdt_csum(sb))\n\t\treturn 0;\n\n\tcrc = crc16(~0, sbi->s_es->s_uuid, sizeof(sbi->s_es->s_uuid));\n\tcrc = crc16(crc, (__u8 *)&le_group, sizeof(le_group));\n\tcrc = crc16(crc, (__u8 *)gdp, offset);\n\toffset += sizeof(gdp->bg_checksum);  \n\t \n\tif (ext4_has_feature_64bit(sb) && offset < sbi->s_desc_size)\n\t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t    sbi->s_desc_size - offset);\n\nout:\n\treturn cpu_to_le16(crc);\n}\n\nint ext4_group_desc_csum_verify(struct super_block *sb, __u32 block_group,\n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(sb, block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(sb, block_group, gdp);\n}\n\n \nstatic int ext4_check_descriptors(struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t sb_block,\n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t last_bg_block = sb_block + ext4_bg_num_gdb(sb, 0);\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap == sb_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Block bitmap for group %u overlaps \"\n\t\t\t\t \"superblock\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (block_bitmap >= sb_block + 1 &&\n\t\t    block_bitmap <= last_bg_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Block bitmap for group %u overlaps \"\n\t\t\t\t \"block group descriptors\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap == sb_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Inode bitmap for group %u overlaps \"\n\t\t\t\t \"superblock\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (inode_bitmap >= sb_block + 1 &&\n\t\t    inode_bitmap <= last_bg_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Inode bitmap for group %u overlaps \"\n\t\t\t\t \"block group descriptors\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table == sb_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Inode table for group %u overlaps \"\n\t\t\t\t \"superblock\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (inode_table >= sb_block + 1 &&\n\t\t    inode_table <= last_bg_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Inode table for group %u overlaps \"\n\t\t\t\t \"block group descriptors\", i);\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\treturn 0;\n\t\t}\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sb, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sb, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!sb_rdonly(sb)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\treturn 1;\n}\n\n \nstatic loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\tBUILD_BUG_ON(sizeof(blkcnt_t) < sizeof(u64));\n\n\tif (!has_huge_files) {\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t \n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t \n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t \n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}\n\n \nstatic loff_t ext4_max_bitmap_size(int bits, int has_huge_files)\n{\n\tloff_t upper_limit, res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tunsigned int ppb = 1 << (bits - 2);\n\n\t \n\tif (!has_huge_files) {\n\t\t \n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t \n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t \n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t \n\tres += ppb;\n\tres += ppb * ppb;\n\tres += ((loff_t)ppb) * ppb * ppb;\n\t \n\tmeta_blocks = 1;\n\tmeta_blocks += 1 + ppb;\n\tmeta_blocks += 1 + ppb + ppb * ppb;\n\t \n\tif (res + meta_blocks <= upper_limit)\n\t\tgoto check_lfs;\n\n\tres = upper_limit;\n\t \n\tupper_limit -= EXT4_NDIR_BLOCKS;\n\t \n\tmeta_blocks = 1;\n\tupper_limit -= ppb;\n\t \n\tif (upper_limit < ppb * ppb) {\n\t\tmeta_blocks += 1 + DIV_ROUND_UP_ULL(upper_limit, ppb);\n\t\tres -= meta_blocks;\n\t\tgoto check_lfs;\n\t}\n\tmeta_blocks += 1 + ppb;\n\tupper_limit -= ppb * ppb;\n\t \n\tmeta_blocks += 1 + DIV_ROUND_UP_ULL(upper_limit, ppb) +\n\t\tDIV_ROUND_UP_ULL(upper_limit, ppb*ppb);\n\tres -= meta_blocks;\ncheck_lfs:\n\tres <<= bits;\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic ext4_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!ext4_has_feature_meta_bg(sb) || nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\t \n\tif (sb->s_blocksize == 1024 && nr == 0 &&\n\t    le32_to_cpu(sbi->s_es->s_first_data_block) == 0)\n\t\thas_super++;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}\n\n \nstatic unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width && stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride && stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t \n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nint ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (ext4_has_unknown_ext4_incompat_features(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n#if !IS_ENABLED(CONFIG_UNICODE)\n\tif (ext4_has_feature_casefold(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Filesystem with casefold feature cannot be \"\n\t\t\t \"mounted without CONFIG_UNICODE\");\n\t\treturn 0;\n\t}\n#endif\n\n\tif (readonly)\n\t\treturn 1;\n\n\tif (ext4_has_feature_readonly(sb)) {\n\t\text4_msg(sb, KERN_INFO, \"filesystem is read-only\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t\treturn 1;\n\t}\n\n\t \n\tif (ext4_has_unknown_ext4_ro_compat_features(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\tif (ext4_has_feature_bigalloc(sb) && !ext4_has_feature_extents(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Can't support bigalloc feature without \"\n\t\t\t \"extents feature\\n\");\n\t\treturn 0;\n\t}\n\n#if !IS_ENABLED(CONFIG_QUOTA) || !IS_ENABLED(CONFIG_QFMT_V2)\n\tif (!readonly && (ext4_has_feature_quota(sb) ||\n\t\t\t  ext4_has_feature_project(sb))) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"The kernel was not built with CONFIG_QUOTA and CONFIG_QFMT_V2\");\n\t\treturn 0;\n\t}\n#endif   \n\treturn 1;\n}\n\n \nstatic void print_daily_error_info(struct timer_list *t)\n{\n\tstruct ext4_sb_info *sbi = from_timer(sbi, t, s_err_report);\n\tstruct super_block *sb = sbi->s_sb;\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\tif (es->s_error_count)\n\t\t \n\t\text4_msg(sb, KERN_NOTICE, \"error count since last fsck: %u\",\n\t\t\t le32_to_cpu(es->s_error_count));\n\tif (es->s_first_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): initial error at time %llu: %.*s:%d\",\n\t\t       sb->s_id,\n\t\t       ext4_get_tstamp(es, s_first_error_time),\n\t\t       (int) sizeof(es->s_first_error_func),\n\t\t       es->s_first_error_func,\n\t\t       le32_to_cpu(es->s_first_error_line));\n\t\tif (es->s_first_error_ino)\n\t\t\tprintk(KERN_CONT \": inode %u\",\n\t\t\t       le32_to_cpu(es->s_first_error_ino));\n\t\tif (es->s_first_error_block)\n\t\t\tprintk(KERN_CONT \": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_first_error_block));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tif (es->s_last_error_time) {\n\t\tprintk(KERN_NOTICE \"EXT4-fs (%s): last error at time %llu: %.*s:%d\",\n\t\t       sb->s_id,\n\t\t       ext4_get_tstamp(es, s_last_error_time),\n\t\t       (int) sizeof(es->s_last_error_func),\n\t\t       es->s_last_error_func,\n\t\t       le32_to_cpu(es->s_last_error_line));\n\t\tif (es->s_last_error_ino)\n\t\t\tprintk(KERN_CONT \": inode %u\",\n\t\t\t       le32_to_cpu(es->s_last_error_ino));\n\t\tif (es->s_last_error_block)\n\t\t\tprintk(KERN_CONT \": block %llu\", (unsigned long long)\n\t\t\t       le64_to_cpu(es->s_last_error_block));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tmod_timer(&sbi->s_err_report, jiffies + 24*60*60*HZ);   \n}\n\n \nstatic int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct super_block *sb = elr->lr_super;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\text4_group_t group = elr->lr_next_group;\n\tunsigned int prefetch_ios = 0;\n\tint ret = 0;\n\tint nr = EXT4_SB(sb)->s_mb_prefetch;\n\tu64 start_time;\n\n\tif (elr->lr_mode == EXT4_LI_MODE_PREFETCH_BBITMAP) {\n\t\telr->lr_next_group = ext4_mb_prefetch(sb, group, nr, &prefetch_ios);\n\t\text4_mb_prefetch_fini(sb, elr->lr_next_group, nr);\n\t\ttrace_ext4_prefetch_bitmaps(sb, group, elr->lr_next_group, nr);\n\t\tif (group >= elr->lr_next_group) {\n\t\t\tret = 1;\n\t\t\tif (elr->lr_first_not_zeroed != ngroups &&\n\t\t\t    !sb_rdonly(sb) && test_opt(sb, INIT_INODE_TABLE)) {\n\t\t\t\telr->lr_next_group = elr->lr_first_not_zeroed;\n\t\t\t\telr->lr_mode = EXT4_LI_MODE_ITABLE;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfor (; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\tstart_time = ktime_get_real_ns();\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\ttrace_ext4_lazy_itable_init(sb, group);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\telr->lr_timeout = nsecs_to_jiffies((ktime_get_real_ns() - start_time) *\n\t\t\t\tEXT4_SB(elr->lr_super)->s_li_wait_mult);\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\treturn ret;\n}\n\n \nstatic void ext4_remove_li_request(struct ext4_li_request *elr)\n{\n\tif (!elr)\n\t\treturn;\n\n\tlist_del(&elr->lr_request);\n\tEXT4_SB(elr->lr_super)->s_li_request = NULL;\n\tkfree(elr);\n}\n\nstatic void ext4_unregister_li_request(struct super_block *sb)\n{\n\tmutex_lock(&ext4_li_mtx);\n\tif (!ext4_li_info) {\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\text4_remove_li_request(EXT4_SB(sb)->s_li_request);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\tmutex_unlock(&ext4_li_mtx);\n}\n\nstatic struct task_struct *ext4_lazyinit_task;\n\n \nstatic int ext4_lazyinit_thread(void *arg)\n{\n\tstruct ext4_lazy_init *eli = arg;\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\tunsigned long next_wakeup, cur;\n\n\tBUG_ON(NULL == eli);\n\tset_freezable();\n\ncont_thread:\n\twhile (true) {\n\t\tnext_wakeup = MAX_JIFFY_OFFSET;\n\n\t\tmutex_lock(&eli->li_list_mtx);\n\t\tif (list_empty(&eli->li_request_list)) {\n\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\tgoto exit_thread;\n\t\t}\n\t\tlist_for_each_safe(pos, n, &eli->li_request_list) {\n\t\t\tint err = 0;\n\t\t\tint progress = 0;\n\t\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t\t lr_request);\n\n\t\t\tif (time_before(jiffies, elr->lr_next_sched)) {\n\t\t\t\tif (time_before(elr->lr_next_sched, next_wakeup))\n\t\t\t\t\tnext_wakeup = elr->lr_next_sched;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (down_read_trylock(&elr->lr_super->s_umount)) {\n\t\t\t\tif (sb_start_write_trylock(elr->lr_super)) {\n\t\t\t\t\tprogress = 1;\n\t\t\t\t\t \n\t\t\t\t\tmutex_unlock(&eli->li_list_mtx);\n\t\t\t\t\terr = ext4_run_li_request(elr);\n\t\t\t\t\tsb_end_write(elr->lr_super);\n\t\t\t\t\tmutex_lock(&eli->li_list_mtx);\n\t\t\t\t\tn = pos->next;\n\t\t\t\t}\n\t\t\t\tup_read((&elr->lr_super->s_umount));\n\t\t\t}\n\t\t\t \n\t\t\tif (err) {\n\t\t\t\text4_remove_li_request(elr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!progress) {\n\t\t\t\telr->lr_next_sched = jiffies +\n\t\t\t\t\tget_random_u32_below(EXT4_DEF_LI_MAX_START_DELAY * HZ);\n\t\t\t}\n\t\t\tif (time_before(elr->lr_next_sched, next_wakeup))\n\t\t\t\tnext_wakeup = elr->lr_next_sched;\n\t\t}\n\t\tmutex_unlock(&eli->li_list_mtx);\n\n\t\ttry_to_freeze();\n\n\t\tcur = jiffies;\n\t\tif ((time_after_eq(cur, next_wakeup)) ||\n\t\t    (MAX_JIFFY_OFFSET == next_wakeup)) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tschedule_timeout_interruptible(next_wakeup - cur);\n\n\t\tif (kthread_should_stop()) {\n\t\t\text4_clear_request_list();\n\t\t\tgoto exit_thread;\n\t\t}\n\t}\n\nexit_thread:\n\t \n\tmutex_lock(&ext4_li_mtx);\n\tmutex_lock(&eli->li_list_mtx);\n\tif (!list_empty(&eli->li_request_list)) {\n\t\tmutex_unlock(&eli->li_list_mtx);\n\t\tmutex_unlock(&ext4_li_mtx);\n\t\tgoto cont_thread;\n\t}\n\tmutex_unlock(&eli->li_list_mtx);\n\tkfree(ext4_li_info);\n\text4_li_info = NULL;\n\tmutex_unlock(&ext4_li_mtx);\n\n\treturn 0;\n}\n\nstatic void ext4_clear_request_list(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct ext4_li_request *elr;\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_for_each_safe(pos, n, &ext4_li_info->li_request_list) {\n\t\telr = list_entry(pos, struct ext4_li_request,\n\t\t\t\t lr_request);\n\t\text4_remove_li_request(elr);\n\t}\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n}\n\nstatic int ext4_run_lazyinit_thread(void)\n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4-fs: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\treturn 0;\n}\n\n \nstatic ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn ngroups;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\treturn group;\n}\n\nstatic int ext4_li_info_new(void)\n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}\n\nstatic struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_first_not_zeroed = start;\n\tif (test_opt(sb, NO_PREFETCH_BLOCK_BITMAPS)) {\n\t\telr->lr_mode = EXT4_LI_MODE_ITABLE;\n\t\telr->lr_next_group = start;\n\t} else {\n\t\telr->lr_mode = EXT4_LI_MODE_PREFETCH_BBITMAP;\n\t}\n\n\t \n\telr->lr_next_sched = jiffies + get_random_u32_below(EXT4_DEF_LI_MAX_START_DELAY * HZ);\n\treturn elr;\n}\n\nint ext4_register_li_request(struct super_block *sb,\n\t\t\t     ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr = NULL;\n\text4_group_t ngroups = sbi->s_groups_count;\n\tint ret = 0;\n\n\tmutex_lock(&ext4_li_mtx);\n\tif (sbi->s_li_request != NULL) {\n\t\t \n\t\tsbi->s_li_request->lr_timeout = 0;\n\t\tgoto out;\n\t}\n\n\tif (sb_rdonly(sb) ||\n\t    (test_opt(sb, NO_PREFETCH_BLOCK_BITMAPS) &&\n\t     (first_not_zeroed == ngroups || !test_opt(sb, INIT_INODE_TABLE))))\n\t\tgoto out;\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t \n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}\n\n \nstatic void ext4_destroy_lazyinit_thread(void)\n{\n\t \n\tif (!ext4_li_info || !ext4_lazyinit_task)\n\t\treturn;\n\n\tkthread_stop(ext4_lazyinit_task);\n}\n\nstatic int set_journal_csum_feature_set(struct super_block *sb)\n{\n\tint ret = 1;\n\tint compat, incompat;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t \n\t\tcompat = 0;\n\t\tincompat = JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t} else {\n\t\t \n\t\tcompat = JBD2_FEATURE_COMPAT_CHECKSUM;\n\t\tincompat = 0;\n\t}\n\n\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V3 |\n\t\t\tJBD2_FEATURE_INCOMPAT_CSUM_V2);\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT |\n\t\t\t\tincompat);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tret = jbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tcompat, 0,\n\t\t\t\tincompat);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int count_overhead(struct super_block *sb, ext4_group_t grp,\n\t\t\t  char *buf)\n{\n\tstruct ext4_sb_info\t*sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc\t*gdp;\n\text4_fsblk_t\t\tfirst_block, last_block, b;\n\text4_group_t\t\ti, ngroups = ext4_get_groups_count(sb);\n\tint\t\t\ts, j, count = 0;\n\tint\t\t\thas_super = ext4_bg_has_super(sb, grp);\n\n\tif (!ext4_has_feature_bigalloc(sb))\n\t\treturn (has_super + ext4_bg_num_gdb(sb, grp) +\n\t\t\t(has_super ? le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0) +\n\t\t\tsbi->s_itb_per_group + 2);\n\n\tfirst_block = le32_to_cpu(sbi->s_es->s_first_data_block) +\n\t\t(grp * EXT4_BLOCKS_PER_GROUP(sb));\n\tlast_block = first_block + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tb = ext4_block_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_bitmap(sb, gdp);\n\t\tif (b >= first_block && b <= last_block) {\n\t\t\text4_set_bit(EXT4_B2C(sbi, b - first_block), buf);\n\t\t\tcount++;\n\t\t}\n\t\tb = ext4_inode_table(sb, gdp);\n\t\tif (b >= first_block && b + sbi->s_itb_per_group <= last_block)\n\t\t\tfor (j = 0; j < sbi->s_itb_per_group; j++, b++) {\n\t\t\t\tint c = EXT4_B2C(sbi, b - first_block);\n\t\t\t\text4_set_bit(c, buf);\n\t\t\t\tcount++;\n\t\t\t}\n\t\tif (i != grp)\n\t\t\tcontinue;\n\t\ts = 0;\n\t\tif (ext4_bg_has_super(sb, grp)) {\n\t\t\text4_set_bit(s++, buf);\n\t\t\tcount++;\n\t\t}\n\t\tj = ext4_bg_num_gdb(sb, grp);\n\t\tif (s + j > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\t\text4_error(sb, \"Invalid number of block group \"\n\t\t\t\t   \"descriptor blocks: %d\", j);\n\t\t\tj = EXT4_BLOCKS_PER_GROUP(sb) - s;\n\t\t}\n\t\tcount += j;\n\t\tfor (; j > 0; j--)\n\t\t\text4_set_bit(EXT4_B2C(sbi, s++), buf);\n\t}\n\tif (!count)\n\t\treturn 0;\n\treturn EXT4_CLUSTERS_PER_GROUP(sb) -\n\t\text4_count_free(buf, EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n}\n\n \nint ext4_calculate_overhead(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct inode *j_inode;\n\tunsigned int j_blocks, j_inum = le32_to_cpu(es->s_journal_inum);\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\text4_fsblk_t overhead = 0;\n\tchar *buf = (char *) get_zeroed_page(GFP_NOFS);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\n\t \n\toverhead = EXT4_B2C(sbi, le32_to_cpu(es->s_first_data_block));\n\n\t \n\tfor (i = 0; i < ngroups; i++) {\n\t\tint blks;\n\n\t\tblks = count_overhead(sb, i, buf);\n\t\toverhead += blks;\n\t\tif (blks)\n\t\t\tmemset(buf, 0, PAGE_SIZE);\n\t\tcond_resched();\n\t}\n\n\t \n\tif (sbi->s_journal && !sbi->s_journal_bdev)\n\t\toverhead += EXT4_NUM_B2C(sbi, sbi->s_journal->j_total_len);\n\telse if (ext4_has_feature_journal(sb) && !sbi->s_journal && j_inum) {\n\t\t \n\t\tj_inode = ext4_get_journal_inode(sb, j_inum);\n\t\tif (!IS_ERR(j_inode)) {\n\t\t\tj_blocks = j_inode->i_size >> sb->s_blocksize_bits;\n\t\t\toverhead += EXT4_NUM_B2C(sbi, j_blocks);\n\t\t\tiput(j_inode);\n\t\t} else {\n\t\t\text4_msg(sb, KERN_ERR, \"can't get journal size\");\n\t\t}\n\t}\n\tsbi->s_overhead = overhead;\n\tsmp_wmb();\n\tfree_page((unsigned long) buf);\n\treturn 0;\n}\n\nstatic void ext4_set_resv_clusters(struct super_block *sb)\n{\n\text4_fsblk_t resv_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t \n\tif (!ext4_has_feature_extents(sb))\n\t\treturn;\n\t \n\tresv_clusters = (ext4_blocks_count(sbi->s_es) >>\n\t\t\t sbi->s_cluster_bits);\n\n\tdo_div(resv_clusters, 50);\n\tresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n\n\tatomic64_set(&sbi->s_resv_clusters, resv_clusters);\n}\n\nstatic const char *ext4_quota_mode(struct super_block *sb)\n{\n#ifdef CONFIG_QUOTA\n\tif (!ext4_quota_capable(sb))\n\t\treturn \"none\";\n\n\tif (EXT4_SB(sb)->s_journal && ext4_is_quota_journalled(sb))\n\t\treturn \"journalled\";\n\telse\n\t\treturn \"writeback\";\n#else\n\treturn \"disabled\";\n#endif\n}\n\nstatic void ext4_setup_csum_trigger(struct super_block *sb,\n\t\t\t\t    enum ext4_journal_trigger_type type,\n\t\t\t\t    void (*trigger)(\n\t\t\t\t\tstruct jbd2_buffer_trigger_type *type,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tvoid *mapped_data,\n\t\t\t\t\tsize_t size))\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tsbi->s_journal_triggers[type].sb = sb;\n\tsbi->s_journal_triggers[type].tr_triggers.t_frozen = trigger;\n}\n\nstatic void ext4_free_sbi(struct ext4_sb_info *sbi)\n{\n\tif (!sbi)\n\t\treturn;\n\n\tkfree(sbi->s_blockgroup_lock);\n\tfs_put_dax(sbi->s_daxdev, NULL);\n\tkfree(sbi);\n}\n\nstatic struct ext4_sb_info *ext4_alloc_sbi(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn NULL;\n\n\tsbi->s_daxdev = fs_dax_get_by_bdev(sb->s_bdev, &sbi->s_dax_part_off,\n\t\t\t\t\t   NULL, NULL);\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto err_out;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\treturn sbi;\nerr_out:\n\tfs_put_dax(sbi->s_daxdev, NULL);\n\tkfree(sbi);\n\treturn NULL;\n}\n\nstatic void ext4_set_def_opts(struct super_block *sb,\n\t\t\t      struct ext4_super_block *es)\n{\n\tunsigned long def_mount_opts;\n\n\t \n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t \n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\tif (ext4_has_feature_fast_commit(sb))\n\t\tset_opt2(sb, JOURNAL_FAST_COMMIT);\n\t \n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t \n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t \n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\tif (sb->s_blocksize == PAGE_SIZE)\n\t\tset_opt(sb, DIOREAD_NOLOCK);\n}\n\nstatic int ext4_handle_clustersize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint clustersize;\n\n\t \n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\tif (ext4_has_feature_bigalloc(sb)) {\n\t\tif (clustersize < sb->s_blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%lu)\", clustersize, sb->s_blocksize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > sb->s_blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / sb->s_blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (clustersize != sb->s_blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"fragment/cluster size (%d) != \"\n\t\t\t\t \"block size (%lu)\", clustersize, sb->s_blocksize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / sb->s_blocksize;\n\n\t \n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\treturn 0;\n}\n\nstatic void ext4_fast_commit_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t \n\tatomic_set(&sbi->s_fc_subtid, 0);\n\tINIT_LIST_HEAD(&sbi->s_fc_q[FC_Q_MAIN]);\n\tINIT_LIST_HEAD(&sbi->s_fc_q[FC_Q_STAGING]);\n\tINIT_LIST_HEAD(&sbi->s_fc_dentry_q[FC_Q_MAIN]);\n\tINIT_LIST_HEAD(&sbi->s_fc_dentry_q[FC_Q_STAGING]);\n\tsbi->s_fc_bytes = 0;\n\text4_clear_mount_flag(sb, EXT4_MF_FC_INELIGIBLE);\n\tsbi->s_fc_ineligible_tid = 0;\n\tspin_lock_init(&sbi->s_fc_lock);\n\tmemset(&sbi->s_fc_stats, 0, sizeof(sbi->s_fc_stats));\n\tsbi->s_fc_replay_state.fc_regions = NULL;\n\tsbi->s_fc_replay_state.fc_regions_size = 0;\n\tsbi->s_fc_replay_state.fc_regions_used = 0;\n\tsbi->s_fc_replay_state.fc_regions_valid = 0;\n\tsbi->s_fc_replay_state.fc_modified_inodes = NULL;\n\tsbi->s_fc_replay_state.fc_modified_inodes_size = 0;\n\tsbi->s_fc_replay_state.fc_modified_inodes_used = 0;\n}\n\nstatic int ext4_inode_info_init(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif (sbi->s_first_ino < EXT4_GOOD_OLD_FIRST_INO) {\n\t\t\text4_msg(sb, KERN_ERR, \"invalid first ino: %u\",\n\t\t\t\t sbi->s_first_ino);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > sb->s_blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\text4_msg(sb, KERN_ERR, \"blocksize: %lu\", sb->s_blocksize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (sbi->s_inode_size >= offsetof(struct ext4_inode, i_atime_extra) +\n\t\t\tsizeof(((struct ext4_inode *)0)->i_atime_extra)) {\n\t\t\tsb->s_time_gran = 1;\n\t\t\tsb->s_time_max = EXT4_EXTRA_TIMESTAMP_MAX;\n\t\t} else {\n\t\t\tsb->s_time_gran = NSEC_PER_SEC;\n\t\t\tsb->s_time_max = EXT4_NON_EXTRA_TIMESTAMP_MAX;\n\t\t}\n\t\tsb->s_time_min = EXT4_TIMESTAMP_MIN;\n\t}\n\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tunsigned v, max = (sbi->s_inode_size -\n\t\t\t\t\t   EXT4_GOOD_OLD_INODE_SIZE);\n\n\t\t\tv = le16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (v > max) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"bad s_want_extra_isize: %d\", v);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (sbi->s_want_extra_isize < v)\n\t\t\t\tsbi->s_want_extra_isize = v;\n\n\t\t\tv = le16_to_cpu(es->s_min_extra_isize);\n\t\t\tif (v > max) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"bad s_min_extra_isize: %d\", v);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (sbi->s_want_extra_isize < v)\n\t\t\t\tsbi->s_want_extra_isize = v;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_UNICODE)\nstatic int ext4_encoding_init(struct super_block *sb, struct ext4_super_block *es)\n{\n\tconst struct ext4_sb_encodings *encoding_info;\n\tstruct unicode_map *encoding;\n\t__u16 encoding_flags = le16_to_cpu(es->s_encoding_flags);\n\n\tif (!ext4_has_feature_casefold(sb) || sb->s_encoding)\n\t\treturn 0;\n\n\tencoding_info = ext4_sb_read_encoding(es);\n\tif (!encoding_info) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Encoding requested by superblock is unknown\");\n\t\treturn -EINVAL;\n\t}\n\n\tencoding = utf8_load(encoding_info->version);\n\tif (IS_ERR(encoding)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"can't mount with superblock charset: %s-%u.%u.%u \"\n\t\t\t\"not supported by the kernel. flags: 0x%x.\",\n\t\t\tencoding_info->name,\n\t\t\tunicode_major(encoding_info->version),\n\t\t\tunicode_minor(encoding_info->version),\n\t\t\tunicode_rev(encoding_info->version),\n\t\t\tencoding_flags);\n\t\treturn -EINVAL;\n\t}\n\text4_msg(sb, KERN_INFO,\"Using encoding defined by superblock: \"\n\t\t\"%s-%u.%u.%u with flags 0x%hx\", encoding_info->name,\n\t\tunicode_major(encoding_info->version),\n\t\tunicode_minor(encoding_info->version),\n\t\tunicode_rev(encoding_info->version),\n\t\tencoding_flags);\n\n\tsb->s_encoding = encoding;\n\tsb->s_encoding_flags = encoding_flags;\n\n\treturn 0;\n}\n#else\nstatic inline int ext4_encoding_init(struct super_block *sb, struct ext4_super_block *es)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ext4_init_metadata_csum(struct super_block *sb, struct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t \n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t \n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\treturn -EINVAL;\n\t}\n\text4_setup_csum_trigger(sb, EXT4_JTR_ORPHAN_FILE,\n\t\t\t\text4_orphan_file_block_trigger);\n\n\t \n\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\tint ret = PTR_ERR(sbi->s_chksum_driver);\n\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\tsbi->s_chksum_driver = NULL;\n\t\treturn ret;\n\t}\n\n\t \n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\treturn -EFSBADCRC;\n\t}\n\n\t \n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb) || ext4_has_feature_ea_inode(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\treturn 0;\n}\n\nstatic int ext4_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t\t    struct ext4_super_block *es,\n\t\t\t\t\t    int silent)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (ext4_has_feature_ea_inode(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"ea_inode feature is not supported for Hurd\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\t \n\t\t\tif (silent && ext4_feature_set_ok(sb, sb_rdonly(sb)))\n\t\t\t\treturn -EINVAL;\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\t \n\t\t\tif (silent && ext4_feature_set_ok(sb, sb_rdonly(sb)))\n\t\t\t\treturn -EINVAL;\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!ext4_feature_set_ok(sb, (sb_rdonly(sb))))\n\t\treturn -EINVAL;\n\n\tif (sbi->s_daxdev) {\n\t\tif (sb->s_blocksize == PAGE_SIZE)\n\t\t\tset_bit(EXT4_FLAGS_BDEV_IS_DAX, &sbi->s_ext4_flags);\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR, \"unsupported blocksize for DAX\\n\");\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX_ALWAYS) {\n\t\tif (ext4_has_feature_inline_data(sb)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot use DAX on a filesystem\"\n\t\t\t\t\t\" that may contain inline data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!test_bit(EXT4_FLAGS_BDEV_IS_DAX, &sbi->s_ext4_flags)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\"DAX unsupported by block device.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ext4_check_geometry(struct super_block *sb,\n\t\t\t       struct ext4_super_block *es)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t__u64 blocks_count;\n\tint err;\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (sb->s_blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\treturn -EINVAL;\n\t}\n\t \n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\treturn err;\n\t}\n\n\t \n\tblocks_count = sb_bdev_nr_blocks(sb);\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\treturn -EINVAL;\n\t}\n\tif ((es->s_first_data_block == 0) && (es->s_log_block_size == 0) &&\n\t    (sbi->s_cluster_ratio == 1)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block is 0 with a 1k block and cluster size\");\n\t\treturn -EINVAL;\n\t}\n\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %llu \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", blocks_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tif (((u64)sbi->s_groups_count * sbi->s_inodes_per_group) !=\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_msg(sb, KERN_ERR, \"inodes count not valid: %u vs %llu\",\n\t\t\t le32_to_cpu(es->s_inodes_count),\n\t\t\t ((u64)sbi->s_groups_count * sbi->s_inodes_per_group));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ext4_group_desc_init(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es,\n\t\t\t\text4_fsblk_t logical_sb_block,\n\t\t\t\text4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int db_count;\n\text4_fsblk_t block;\n\tint i;\n\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) > db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\trcu_assign_pointer(sbi->s_group_desc,\n\t\t\t   kvmalloc_array(db_count,\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL));\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\t \n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\text4_sb_breadahead_unmovable(sb, block);\n\t}\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tstruct buffer_head *bh;\n\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tbh = ext4_sb_bread_unmovable(sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tsbi->s_gdb_count = i;\n\t\t\treturn PTR_ERR(bh);\n\t\t}\n\t\trcu_read_lock();\n\t\trcu_dereference(sbi->s_group_desc)[i] = bh;\n\t\trcu_read_unlock();\n\t}\n\tsbi->s_gdb_count = db_count;\n\tif (!ext4_check_descriptors(sb, logical_sb_block, first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\nstatic int ext4_load_and_init_journal(struct super_block *sb,\n\t\t\t\t      struct ext4_super_block *es,\n\t\t\t\t      struct ext4_fs_context *ctx)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\n\terr = ext4_load_journal(sb, es, ctx->journal_devnum);\n\tif (err)\n\t\treturn err;\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto out;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto out;\n\t}\n\n\tif (test_opt2(sb, JOURNAL_FAST_COMMIT) &&\n\t\t!jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t\t  JBD2_FEATURE_INCOMPAT_FAST_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Failed to set fast commit journal feature\");\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t \n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\t\tsbi->s_def_mount_opt |= EXT4_MOUNT_ORDERED_DATA;\n\t\t} else {\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\t\tsbi->s_def_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;\n\t\t}\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\"journal_async_commit in data=ordered mode\");\n\t\tgoto out;\n\t}\n\n\tset_task_ioprio(sbi->s_journal->j_task, ctx->journal_ioprio);\n\n\tsbi->s_journal->j_submit_inode_data_buffers =\n\t\text4_journal_submit_inode_data_buffers;\n\tsbi->s_journal->j_finish_inode_data_buffers =\n\t\text4_journal_finish_inode_data_buffers;\n\n\treturn 0;\n\nout:\n\t \n\tflush_work(&sbi->s_sb_upd_work);\n\tjbd2_journal_destroy(sbi->s_journal);\n\tsbi->s_journal = NULL;\n\treturn -EINVAL;\n}\n\nstatic int ext4_check_journal_data_mode(struct super_block *sb)\n{\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting with \"\n\t\t\t    \"data=journal disables delayed allocation, \"\n\t\t\t    \"dioread_nolock, O_DIRECT and fast_commit support!\\n\");\n\t\t \n\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\tclear_opt2(sb, JOURNAL_FAST_COMMIT);\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (test_opt(sb, DAX_ALWAYS)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ext4_has_feature_encrypt(sb)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"encrypted files will use data=ordered \"\n\t\t\t\t \"instead of data journaling mode\");\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\treturn 0;\n}\n\nstatic int ext4_load_super(struct super_block *sb, ext4_fsblk_t *lsb,\n\t\t\t   int silent)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es;\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tstruct buffer_head *bh;\n\tint ret = -EINVAL;\n\tint blocksize;\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sbi->s_sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sbi->s_sb_block;\n\t}\n\n\tbh = ext4_sb_bread_unmovable(sb, logical_sb_block);\n\tif (IS_ERR(bh)) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\treturn PTR_ERR(bh);\n\t}\n\t \n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto out;\n\t}\n\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\tgoto out;\n\t}\n\n\tblocksize = EXT4_MIN_BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\t \n\tif (sb->s_blocksize == blocksize) {\n\t\t*lsb = logical_sb_block;\n\t\tsbi->s_sbh = bh;\n\t\treturn 0;\n\t}\n\n\t \n\tbrelse(bh);\n\t \n\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\tblocksize);\n\t\tbh = NULL;\n\t\tgoto out;\n\t}\n\n\tlogical_sb_block = sbi->s_sb_block * EXT4_MIN_BLOCK_SIZE;\n\toffset = do_div(logical_sb_block, blocksize);\n\tbh = ext4_sb_bread_unmovable(sb, logical_sb_block);\n\tif (IS_ERR(bh)) {\n\t\text4_msg(sb, KERN_ERR, \"Can't read superblock on 2nd try\");\n\t\tret = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto out;\n\t}\n\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\tsbi->s_es = es;\n\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\text4_msg(sb, KERN_ERR, \"Magic mismatch, very weird!\");\n\t\tgoto out;\n\t}\n\t*lsb = logical_sb_block;\n\tsbi->s_sbh = bh;\n\treturn 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic void ext4_hash_info_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tunsigned int i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!sb_rdonly(sb))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n}\n\nstatic int ext4_block_group_meta_init(struct super_block *sb, int silent)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint has_huge_files;\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_blocks_per_group == 0) {\n\t\tif (!silent)\n\t\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\t\treturn -EINVAL;\n\t}\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_inodes_per_group);\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_mount_state = le16_to_cpu(es->s_state) & ~EXT4_FC_REPLAY;\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\treturn 0;\n}\n\nstatic int __ext4_fill_super(struct fs_context *fc, struct super_block *sb)\n{\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t logical_sb_block;\n\tstruct inode *root;\n\tint needs_recovery;\n\tint err;\n\text4_group_t first_not_zeroed;\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tint silent = fc->sb_flags & SB_SILENT;\n\n\t \n\tif (!(ctx->spec & EXT4_SPEC_JOURNAL_IOPRIO))\n\t\tctx->journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sectors_written_start =\n\t\tpart_stat_read(sb->s_bdev, sectors[STAT_WRITE]);\n\n\terr = ext4_load_super(sb, &logical_sb_block, silent);\n\tif (err)\n\t\tgoto out_fail;\n\n\tes = sbi->s_es;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\terr = ext4_init_metadata_csum(sb, es);\n\tif (err)\n\t\tgoto failed_mount;\n\n\text4_set_def_opts(sb, es);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\t \n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\terr = ext4_inode_info_init(sb, es);\n\tif (err)\n\t\tgoto failed_mount;\n\n\terr = parse_apply_sb_mount_options(sb, ctx);\n\tif (err < 0)\n\t\tgoto failed_mount;\n\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tsbi->s_def_mount_opt2 = sbi->s_mount_opt2;\n\n\terr = ext4_check_opt_consistency(fc, sb);\n\tif (err < 0)\n\t\tgoto failed_mount;\n\n\text4_apply_options(fc, sb);\n\n\terr = ext4_encoding_init(sb, es);\n\tif (err)\n\t\tgoto failed_mount;\n\n\terr = ext4_check_journal_data_mode(sb);\n\tif (err)\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t \n\tsb->s_flags |= SB_I_VERSION;\n\n\terr = ext4_check_feature_compatibility(sb, es, silent);\n\tif (err)\n\t\tgoto failed_mount;\n\n\terr = ext4_block_group_meta_init(sb, silent);\n\tif (err)\n\t\tgoto failed_mount;\n\n\text4_hash_info_init(sb);\n\n\terr = ext4_handle_clustersize(sb);\n\tif (err)\n\t\tgoto failed_mount;\n\n\terr = ext4_check_geometry(sb, es);\n\tif (err)\n\t\tgoto failed_mount;\n\n\ttimer_setup(&sbi->s_err_report, print_daily_error_info, 0);\n\tspin_lock_init(&sbi->s_error_lock);\n\tINIT_WORK(&sbi->s_sb_upd_work, update_super_work);\n\n\terr = ext4_group_desc_init(sb, es, logical_sb_block, &first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount3;\n\n\terr = ext4_es_register_shrinker(sbi);\n\tif (err)\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\t \n\tif (sbi->s_stripe > 0 && sbi->s_cluster_ratio > 1 &&\n\t    sbi->s_stripe % sbi->s_cluster_ratio != 0) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"stripe (%lu) is not aligned with cluster size (%u), \"\n\t\t\t \"stripe is disabled\",\n\t\t\t sbi->s_stripe, sbi->s_cluster_ratio);\n\t\tsbi->s_stripe = 0;\n\t}\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t \n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_FS_ENCRYPTION\n\tsb->s_cop = &ext4_cryptops;\n#endif\n#ifdef CONFIG_FS_VERITY\n\tsb->s_vop = &ext4_verityops;\n#endif\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(&sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan);  \n\tmutex_init(&sbi->s_orphan_lock);\n\n\text4_fast_commit_init(sb);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_orphan_present(sb) ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !sb_rdonly(sb)) {\n\t\terr = ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block));\n\t\tif (err)\n\t\t\tgoto failed_mount3a;\n\t}\n\n\terr = -EINVAL;\n\t \n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\terr = ext4_load_and_init_journal(sb, es, ctx);\n\t\tif (err)\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !sb_rdonly(sb) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount3a;\n\t} else {\n\t\t \n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount3a;\n\t\t}\n\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount3a;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount3a;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount3a;\n\t\t}\n\t\tsbi->s_def_mount_opt &= ~EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tclear_opt2(sb, JOURNAL_FAST_COMMIT);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t}\n\n\tif (!test_opt(sb, NO_MBCACHE)) {\n\t\tsbi->s_ea_block_cache = ext4_xattr_create_cache();\n\t\tif (!sbi->s_ea_block_cache) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Failed to create ea_block_cache\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\n\t\tif (ext4_has_feature_ea_inode(sb)) {\n\t\t\tsbi->s_ea_inode_cache = ext4_xattr_create_cache();\n\t\t\tif (!sbi->s_ea_inode_cache) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Failed to create ea_inode_cache\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto failed_mount_wq;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\t \n\tif (sbi->s_overhead > ext4_blocks_count(es))\n\t\tsbi->s_overhead = 0;\n\t \n\tif (!ext4_has_feature_bigalloc(sb))\n\t\tsbi->s_overhead = 0;\n\tif (sbi->s_overhead == 0) {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t \n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t \n\n\troot = ext4_iget(sb, EXT4_ROOT_INO, EXT4_IGET_SPECIAL);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\terr = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto failed_mount4;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\terr = ext4_setup_super(sb, es, sb_rdonly(sb));\n\tif (err == -EROFS) {\n\t\tsb->s_flags |= SB_RDONLY;\n\t} else if (err)\n\t\tgoto failed_mount4a;\n\n\text4_set_resv_clusters(sb);\n\n\tif (test_opt(sb, BLOCK_VALIDITY)) {\n\t\terr = ext4_setup_system_zone(sb);\n\t\tif (err) {\n\t\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t\t \"zone (%d)\", err);\n\t\t\tgoto failed_mount4a;\n\t\t}\n\t}\n\text4_fc_replay_cleanup(sb);\n\n\text4_ext_init(sb);\n\n\t \n\tif (!(ctx->spec & EXT4_SPEC_mb_optimize_scan)) {\n\t\tif (sbi->s_groups_count >= MB_DEFAULT_LINEAR_SCAN_THRESHOLD)\n\t\t\tset_opt2(sb, MB_OPTIMIZE_SCAN);\n\t\telse\n\t\t\tclear_opt2(sb, MB_OPTIMIZE_SCAN);\n\t}\n\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\t \n\tif (sbi->s_journal)\n\t\tsbi->s_journal->j_commit_callback =\n\t\t\text4_journal_commit_callback;\n\n\terr = ext4_percpu_param_init(sbi);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n\terr = ext4_init_orphan_info(sb);\n\tif (err)\n\t\tgoto failed_mount8;\n#ifdef CONFIG_QUOTA\n\t \n\tif (ext4_has_feature_quota(sb) && !sb_rdonly(sb)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount9;\n\t}\n#endif   \n\n\t \n\tspin_lock_init(&sbi->s_bdev_wb_lock);\n\terrseq_check_and_advance(&sb->s_bdev->bd_inode->i_mapping->wb_err,\n\t\t\t\t &sbi->s_bdev_wb_err);\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\t \n\text4_superblock_csum_set(sb);\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\terr = ext4_mark_recovery_complete(sb, es);\n\t\tif (err)\n\t\t\tgoto failed_mount10;\n\t}\n\n\tif (test_opt(sb, DISCARD) && !bdev_max_discard_sectors(sb->s_bdev))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"mounting with \\\"discard\\\" option, but the device does not support discard\");\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ);  \n\n\t \n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\tatomic_set(&sbi->s_warning_count, 0);\n\tatomic_set(&sbi->s_msg_count, 0);\n\n\treturn 0;\n\nfailed_mount10:\n\text4_quotas_off(sb, EXT4_MAXQUOTAS);\nfailed_mount9: __maybe_unused\n\text4_release_orphan_info(sb);\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n\tkobject_put(&sbi->s_kobj);\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\text4_flex_groups_free(sbi);\n\text4_percpu_param_destroy(sbi);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\text4_xattr_destroy_cache(sbi->s_ea_inode_cache);\n\tsbi->s_ea_inode_cache = NULL;\n\n\text4_xattr_destroy_cache(sbi->s_ea_block_cache);\n\tsbi->s_ea_block_cache = NULL;\n\n\tif (sbi->s_journal) {\n\t\t \n\t\tflush_work(&sbi->s_sb_upd_work);\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\t \n\tflush_work(&sbi->s_sb_upd_work);\n\tdel_timer_sync(&sbi->s_err_report);\n\text4_stop_mmpd(sbi);\n\text4_group_desc_free(sbi);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tutf8_unload(sb->s_encoding);\n#endif\n\n#ifdef CONFIG_QUOTA\n\tfor (unsigned int i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(get_qf_name(sb, sbi, i));\n#endif\n\tfscrypt_free_dummy_policy(&sbi->s_dummy_enc_policy);\n\tbrelse(sbi->s_sbh);\n\tif (sbi->s_journal_bdev) {\n\t\tinvalidate_bdev(sbi->s_journal_bdev);\n\t\tblkdev_put(sbi->s_journal_bdev, sb);\n\t}\nout_fail:\n\tinvalidate_bdev(sb->s_bdev);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}\n\nstatic int ext4_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_sb_info *sbi;\n\tconst char *descr;\n\tint ret;\n\n\tsbi = ext4_alloc_sbi(sb);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tfc->s_fs_info = sbi;\n\n\t \n\tstrreplace(sb->s_id, '/', '!');\n\n\tsbi->s_sb_block = 1;\t \n\tif (ctx->spec & EXT4_SPEC_s_sb_block)\n\t\tsbi->s_sb_block = ctx->s_sb_block;\n\n\tret = __ext4_fill_super(fc, sb);\n\tif (ret < 0)\n\t\tgoto free_sbi;\n\n\tif (sbi->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem %pU %s with%s. \"\n\t\t\t \"Quota mode: %s.\", &sb->s_uuid,\n\t\t\t sb_rdonly(sb) ? \"ro\" : \"r/w\", descr,\n\t\t\t ext4_quota_mode(sb));\n\n\t \n\text4_update_overhead(sb, false);\n\treturn 0;\n\nfree_sbi:\n\text4_free_sbi(sbi);\n\tfc->s_fs_info = NULL;\n\treturn ret;\n}\n\nstatic int ext4_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_bdev(fc, ext4_fill_super);\n}\n\n \nstatic void ext4_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tjournal->j_commit_interval = sbi->s_commit_interval;\n\tjournal->j_min_batch_time = sbi->s_min_batch_time;\n\tjournal->j_max_batch_time = sbi->s_max_batch_time;\n\text4_fc_init(sb, journal);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JBD2_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JBD2_ABORT_ON_SYNCDATA_ERR;\n\t \n\tjournal->j_flags |= JBD2_CYCLE_RECORD;\n\twrite_unlock(&journal->j_state_lock);\n}\n\nstatic struct inode *ext4_get_journal_inode(struct super_block *sb,\n\t\t\t\t\t     unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\n\t \n\tjournal_inode = ext4_iget(sb, journal_inum, EXT4_IGET_SPECIAL);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn ERR_CAST(journal_inode);\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!S_ISREG(journal_inode->i_mode) || IS_ENCRYPTED(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\text4_debug(\"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\treturn journal_inode;\n}\n\nstatic int ext4_journal_bmap(journal_t *journal, sector_t *block)\n{\n\tstruct ext4_map_blocks map;\n\tint ret;\n\n\tif (journal->j_inode == NULL)\n\t\treturn 0;\n\n\tmap.m_lblk = *block;\n\tmap.m_len = 1;\n\tret = ext4_map_blocks(NULL, journal->j_inode, &map, 0);\n\tif (ret <= 0) {\n\t\text4_msg(journal->j_inode->i_sb, KERN_CRIT,\n\t\t\t \"journal bmap failed: block %llu ret %d\\n\",\n\t\t\t *block, ret);\n\t\tjbd2_journal_abort(journal, ret ? ret : -EIO);\n\t\treturn ret;\n\t}\n\t*block = map.m_pblk;\n\treturn 0;\n}\n\nstatic journal_t *ext4_open_inode_journal(struct super_block *sb,\n\t\t\t\t\t  unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tjournal_inode = ext4_get_journal_inode(sb, journal_inum);\n\tif (IS_ERR(journal_inode))\n\t\treturn ERR_CAST(journal_inode);\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (IS_ERR(journal)) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn ERR_CAST(journal);\n\t}\n\tjournal->j_private = sb;\n\tjournal->j_bmap = ext4_journal_bmap;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}\n\nstatic struct block_device *ext4_get_journal_blkdev(struct super_block *sb,\n\t\t\t\t\tdev_t j_dev, ext4_fsblk_t *j_start,\n\t\t\t\t\text4_fsblk_t *j_len)\n{\n\tstruct buffer_head *bh;\n\tstruct block_device *bdev;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tint errno;\n\n\t \n\tup_write(&sb->s_umount);\n\tbdev = blkdev_get_by_dev(j_dev, BLK_OPEN_READ | BLK_OPEN_WRITE, sb,\n\t\t\t\t &fs_holder_ops);\n\tdown_write(&sb->s_umount);\n\tif (IS_ERR(bdev)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"failed to open journal device unknown-block(%u,%u) %ld\",\n\t\t\t MAJOR(j_dev), MINOR(j_dev), PTR_ERR(bdev));\n\t\treturn ERR_CAST(bdev);\n\t}\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\terrno = -EINVAL;\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tbh = __bread(bdev, sb_block, blocksize);\n\tif (!bh) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\terrno = -EINVAL;\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has bad superblock\");\n\t\terrno = -EFSCORRUPTED;\n\t\tgoto out_bh;\n\t}\n\n\tif ((le32_to_cpu(es->s_feature_ro_compat) &\n\t     EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has corrupt superblock\");\n\t\terrno = -EFSCORRUPTED;\n\t\tgoto out_bh;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\terrno = -EFSCORRUPTED;\n\t\tgoto out_bh;\n\t}\n\n\t*j_start = sb_block + 1;\n\t*j_len = ext4_blocks_count(es);\n\tbrelse(bh);\n\treturn bdev;\n\nout_bh:\n\tbrelse(bh);\nout_bdev:\n\tblkdev_put(bdev, sb);\n\treturn ERR_PTR(errno);\n}\n\nstatic journal_t *ext4_open_dev_journal(struct super_block *sb,\n\t\t\t\t\tdev_t j_dev)\n{\n\tjournal_t *journal;\n\text4_fsblk_t j_start;\n\text4_fsblk_t j_len;\n\tstruct block_device *journal_bdev;\n\tint errno = 0;\n\n\tjournal_bdev = ext4_get_journal_blkdev(sb, j_dev, &j_start, &j_len);\n\tif (IS_ERR(journal_bdev))\n\t\treturn ERR_CAST(journal_bdev);\n\n\tjournal = jbd2_journal_init_dev(journal_bdev, sb->s_bdev, j_start,\n\t\t\t\t\tj_len, sb->s_blocksize);\n\tif (IS_ERR(journal)) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\terrno = PTR_ERR(journal);\n\t\tgoto out_bdev;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\terrno = -EINVAL;\n\t\tgoto out_journal;\n\t}\n\tjournal->j_private = sb;\n\tEXT4_SB(sb)->s_journal_bdev = journal_bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\tblkdev_put(journal_bdev, sb);\n\treturn ERR_PTR(errno);\n}\n\nstatic int ext4_load_journal(struct super_block *sb,\n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\tint journal_dev_ro;\n\n\tif (WARN_ON_ONCE(!ext4_has_feature_journal(sb)))\n\t\treturn -EFSCORRUPTED;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem has both journal inode and journal device!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tjournal = ext4_open_inode_journal(sb, journal_inum);\n\t\tif (IS_ERR(journal))\n\t\t\treturn PTR_ERR(journal);\n\t} else {\n\t\tjournal = ext4_open_dev_journal(sb, journal_dev);\n\t\tif (IS_ERR(journal))\n\t\t\treturn PTR_ERR(journal);\n\t}\n\n\tjournal_dev_ro = bdev_read_only(journal->j_dev);\n\treally_read_only = bdev_read_only(sb->s_bdev) | journal_dev_ro;\n\n\tif (journal_dev_ro && !sb_rdonly(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"journal device read-only, try mounting with '-o ro'\");\n\t\terr = -EROFS;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (ext4_has_feature_journal_needs_recovery(sb)) {\n\t\tif (sb_rdonly(sb)) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed \"\n\t\t\t\t\t\"(try mounting with noload)\");\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!ext4_has_feature_journal_needs_recovery(sb))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\t__le16 orig_state;\n\t\tbool changed = false;\n\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save && memcmp(((char *) es) + EXT4_S_ERR_START,\n\t\t\t\t   save, EXT4_S_ERR_LEN)) {\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\t\tchanged = true;\n\t\t}\n\t\tkfree(save);\n\t\torig_state = es->s_state;\n\t\tes->s_state |= cpu_to_le16(EXT4_SB(sb)->s_mount_state &\n\t\t\t\t\t   EXT4_ERROR_FS);\n\t\tif (orig_state != es->s_state)\n\t\t\tchanged = true;\n\t\t \n\t\tif (changed && !really_read_only) {\n\t\t\tint err2;\n\t\t\terr2 = ext4_commit_super(sb);\n\t\t\terr = err ? : err2;\n\t\t}\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tgoto err_out;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\terr = ext4_clear_journal_err(sb, es);\n\tif (err) {\n\t\tEXT4_SB(sb)->s_journal = NULL;\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\t\text4_commit_super(sb);\n\t}\n\tif (!really_read_only && journal_inum &&\n\t    journal_inum != le32_to_cpu(es->s_journal_inum)) {\n\t\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\t\text4_commit_super(sb);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tjbd2_journal_destroy(journal);\n\treturn err;\n}\n\n \nstatic void ext4_update_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *sbh = sbi->s_sbh;\n\n\tlock_buffer(sbh);\n\t \n\tif (!sb_rdonly(sb))\n\t\text4_update_tstamp(es, s_wtime);\n\tes->s_kbytes_written =\n\t\tcpu_to_le64(sbi->s_kbytes_written +\n\t\t    ((part_stat_read(sb->s_bdev, sectors[STAT_WRITE]) -\n\t\t      sbi->s_sectors_written_start) >> 1));\n\tif (percpu_counter_initialized(&sbi->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(sbi, percpu_counter_sum_positive(\n\t\t\t\t&sbi->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&sbi->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&sbi->s_freeinodes_counter));\n\t \n\tspin_lock(&sbi->s_error_lock);\n\tif (sbi->s_add_error_count > 0) {\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\tif (!es->s_first_error_time && !es->s_first_error_time_hi) {\n\t\t\t__ext4_update_tstamp(&es->s_first_error_time,\n\t\t\t\t\t     &es->s_first_error_time_hi,\n\t\t\t\t\t     sbi->s_first_error_time);\n\t\t\tstrncpy(es->s_first_error_func, sbi->s_first_error_func,\n\t\t\t\tsizeof(es->s_first_error_func));\n\t\t\tes->s_first_error_line =\n\t\t\t\tcpu_to_le32(sbi->s_first_error_line);\n\t\t\tes->s_first_error_ino =\n\t\t\t\tcpu_to_le32(sbi->s_first_error_ino);\n\t\t\tes->s_first_error_block =\n\t\t\t\tcpu_to_le64(sbi->s_first_error_block);\n\t\t\tes->s_first_error_errcode =\n\t\t\t\text4_errno_to_code(sbi->s_first_error_code);\n\t\t}\n\t\t__ext4_update_tstamp(&es->s_last_error_time,\n\t\t\t\t     &es->s_last_error_time_hi,\n\t\t\t\t     sbi->s_last_error_time);\n\t\tstrncpy(es->s_last_error_func, sbi->s_last_error_func,\n\t\t\tsizeof(es->s_last_error_func));\n\t\tes->s_last_error_line = cpu_to_le32(sbi->s_last_error_line);\n\t\tes->s_last_error_ino = cpu_to_le32(sbi->s_last_error_ino);\n\t\tes->s_last_error_block = cpu_to_le64(sbi->s_last_error_block);\n\t\tes->s_last_error_errcode =\n\t\t\t\text4_errno_to_code(sbi->s_last_error_code);\n\t\t \n\t\tif (!es->s_error_count)\n\t\t\tmod_timer(&sbi->s_err_report, jiffies + 24*60*60*HZ);\n\t\tle32_add_cpu(&es->s_error_count, sbi->s_add_error_count);\n\t\tsbi->s_add_error_count = 0;\n\t}\n\tspin_unlock(&sbi->s_error_lock);\n\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbh);\n}\n\nstatic int ext4_commit_super(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\n\tif (!sbh)\n\t\treturn -EINVAL;\n\tif (block_device_ejected(sb))\n\t\treturn -ENODEV;\n\n\text4_update_super(sb);\n\n\tlock_buffer(sbh);\n\t \n\tif (!buffer_mapped(sbh)) {\n\t\tunlock_buffer(sbh);\n\t\treturn -EIO;\n\t}\n\n\tif (buffer_write_io_error(sbh) || !buffer_uptodate(sbh)) {\n\t\t \n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tget_bh(sbh);\n\t \n\tclear_buffer_dirty(sbh);\n\tsbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(REQ_OP_WRITE | REQ_SYNC |\n\t\t  (test_opt(sb, BARRIER) ? REQ_FUA : 0), sbh);\n\twait_on_buffer(sbh);\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t       \"superblock\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t       struct ext4_super_block *es)\n{\n\tint err;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!ext4_has_feature_journal(sb)) {\n\t\tif (journal != NULL) {\n\t\t\text4_error(sb, \"Journal got removed while the fs was \"\n\t\t\t\t   \"mounted!\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\terr = jbd2_journal_flush(journal, 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (sb_rdonly(sb) && (ext4_has_feature_journal_needs_recovery(sb) ||\n\t    ext4_has_feature_orphan_present(sb))) {\n\t\tif (!ext4_orphan_file_empty(sb)) {\n\t\t\text4_error(sb, \"Orphan file not empty on read-only fs.\");\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\text4_clear_feature_journal_needs_recovery(sb);\n\t\text4_clear_feature_orphan_present(sb);\n\t\text4_commit_super(sb);\n\t}\nout:\n\tjbd2_journal_unlock_updates(journal);\n\treturn err;\n}\n\n \nstatic int ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tif (!ext4_has_feature_journal(sb)) {\n\t\text4_error(sb, \"Journal got removed while the fs was mounted!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t \n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\tj_errno = ext4_commit_super(sb);\n\t\tif (j_errno)\n\t\t\treturn j_errno;\n\t\text4_warning(sb, \"Marked fs in need of filesystem check.\");\n\n\t\tjbd2_journal_clear_err(journal);\n\t\tjbd2_journal_update_sb_errno(journal);\n\t}\n\treturn 0;\n}\n\n \nint ext4_force_commit(struct super_block *sb)\n{\n\treturn ext4_journal_force_commit(EXT4_SB(sb)->s_journal);\n}\n\nstatic int ext4_sync_fs(struct super_block *sb, int wait)\n{\n\tint ret = 0;\n\ttid_t target;\n\tbool needs_barrier = false;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn 0;\n\n\ttrace_ext4_sync_fs(sb, wait);\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\t \n\tdquot_writeback_dquots(sb, -1);\n\t \n\tif (sbi->s_journal) {\n\t\ttarget = jbd2_get_latest_transaction(sbi->s_journal);\n\t\tif (wait && sbi->s_journal->j_flags & JBD2_BARRIER &&\n\t\t    !jbd2_trans_will_send_data_barrier(sbi->s_journal, target))\n\t\t\tneeds_barrier = true;\n\n\t\tif (jbd2_journal_start_commit(sbi->s_journal, &target)) {\n\t\t\tif (wait)\n\t\t\t\tret = jbd2_log_wait_commit(sbi->s_journal,\n\t\t\t\t\t\t\t   target);\n\t\t}\n\t} else if (wait && test_opt(sb, BARRIER))\n\t\tneeds_barrier = true;\n\tif (needs_barrier) {\n\t\tint err;\n\t\terr = blkdev_issue_flush(sb->s_bdev);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ext4_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (journal) {\n\t\t \n\t\tjbd2_journal_lock_updates(journal);\n\n\t\t \n\t\terror = jbd2_journal_flush(journal, 0);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\text4_clear_feature_journal_needs_recovery(sb);\n\t\tif (ext4_orphan_file_empty(sb))\n\t\t\text4_clear_feature_orphan_present(sb);\n\t}\n\n\terror = ext4_commit_super(sb);\nout:\n\tif (journal)\n\t\t \n\t\tjbd2_journal_unlock_updates(journal);\n\treturn error;\n}\n\n \nstatic int ext4_unfreeze(struct super_block *sb)\n{\n\tif (ext4_forced_shutdown(sb))\n\t\treturn 0;\n\n\tif (EXT4_SB(sb)->s_journal) {\n\t\t \n\t\text4_set_feature_journal_needs_recovery(sb);\n\t\tif (ext4_has_feature_orphan_file(sb))\n\t\t\text4_set_feature_orphan_present(sb);\n\t}\n\n\text4_commit_super(sb);\n\treturn 0;\n}\n\n \nstruct ext4_mount_options {\n\tunsigned long s_mount_opt;\n\tunsigned long s_mount_opt2;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned long s_commit_interval;\n\tu32 s_min_batch_time, s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\tint s_jquota_fmt;\n\tchar *s_qf_names[EXT4_MAXQUOTAS];\n#endif\n};\n\nstatic int __ext4_remount(struct fs_context *fc, struct super_block *sb)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\text4_group_t g;\n\tint err = 0;\n\tint alloc_ctx;\n#ifdef CONFIG_QUOTA\n\tint enable_quota = 0;\n\tint i, j;\n\tchar *to_free[EXT4_MAXQUOTAS];\n#endif\n\n\n\t \n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\tchar *qf_name = get_qf_name(sb, sbi, i);\n\n\t\t\told_opts.s_qf_names[i] = kstrdup(qf_name, GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (!(ctx->spec & EXT4_SPEC_JOURNAL_IOPRIO)) {\n\t\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\t\tctx->journal_ioprio =\n\t\t\t\tsbi->s_journal->j_task->io_context->ioprio;\n\t\telse\n\t\t\tctx->journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\t}\n\n\t \n\talloc_ctx = ext4_writepages_down_write(sb);\n\text4_apply_options(fc, sb);\n\text4_writepages_up_write(sb, alloc_ctx);\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t} else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA) {\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t\"journal_async_commit in data=ordered mode\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_NO_MBCACHE) {\n\t\text4_msg(sb, KERN_ERR, \"can't enable nombcache during remount\");\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (test_opt2(sb, ABORT))\n\t\text4_abort(sb, ESHUTDOWN, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? SB_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, ctx->journal_ioprio);\n\t}\n\n\t \n\tflush_work(&sbi->s_sb_upd_work);\n\n\tif ((bool)(fc->sb_flags & SB_RDONLY) != sb_rdonly(sb)) {\n\t\tif (ext4_forced_shutdown(sb)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (fc->sb_flags & SB_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t \n\t\t\tsb->s_flags |= SB_RDONLY;\n\n\t\t\t \n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal) {\n\t\t\t\t \n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (ext4_has_feature_readonly(sb) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t \n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sb, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (es->s_last_orphan || !ext4_orphan_file_empty(sb)) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sbi->s_journal) {\n\t\t\t\terr = ext4_clear_journal_err(sb, es);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\tsbi->s_mount_state = (le16_to_cpu(es->s_state) &\n\t\t\t\t\t      ~EXT4_FC_REPLAY);\n\n\t\t\terr = ext4_setup_super(sb, es, 0);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\n\t\t\tsb->s_flags &= ~SB_RDONLY;\n\t\t\tif (ext4_has_feature_mmp(sb)) {\n\t\t\t\terr = ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block));\n\t\t\t\tif (err)\n\t\t\t\t\tgoto restore_opts;\n\t\t\t}\n#ifdef CONFIG_QUOTA\n\t\t\tenable_quota = 1;\n#endif\n\t\t}\n\t}\n\n\t \n\tif (test_opt(sb, BLOCK_VALIDITY) && !sbi->s_system_blks) {\n\t\terr = ext4_setup_system_zone(sb);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t}\n\n\tif (sbi->s_journal == NULL && !(old_sb_flags & SB_RDONLY)) {\n\t\terr = ext4_commit_super(sb);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t}\n\n#ifdef CONFIG_QUOTA\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (ext4_has_feature_quota(sb)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (!test_opt(sb, BLOCK_VALIDITY) && sbi->s_system_blks)\n\t\text4_release_system_zone(sb);\n\n\t \n\tif (sb_rdonly(sb) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\tif (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))\n\t\text4_stop_mmpd(sbi);\n\n\treturn 0;\n\nrestore_opts:\n\t \n\tif (sb_rdonly(sb) && !(old_sb_flags & SB_RDONLY) &&\n\t    sb_any_quota_suspended(sb))\n\t\tdquot_resume(sb, -1);\n\n\talloc_ctx = ext4_writepages_down_write(sb);\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n\text4_writepages_up_write(sb, alloc_ctx);\n\n\tif (!test_opt(sb, BLOCK_VALIDITY) && sbi->s_system_blks)\n\t\text4_release_system_zone(sb);\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tto_free[i] = get_qf_name(sb, sbi, i);\n\t\trcu_assign_pointer(sbi->s_qf_names[i], old_opts.s_qf_names[i]);\n\t}\n\tsynchronize_rcu();\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(to_free[i]);\n#endif\n\tif (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))\n\t\text4_stop_mmpd(sbi);\n\treturn err;\n}\n\nstatic int ext4_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tint ret;\n\n\tfc->s_fs_info = EXT4_SB(sb);\n\n\tret = ext4_check_opt_consistency(fc, sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __ext4_remount(fc, sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\text4_msg(sb, KERN_INFO, \"re-mounted %pU %s. Quota mode: %s.\",\n\t\t &sb->s_uuid, sb_rdonly(sb) ? \"ro\" : \"r/w\",\n\t\t ext4_quota_mode(sb));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int ext4_statfs_project(struct super_block *sb,\n\t\t\t       kprojid_t projid, struct kstatfs *buf)\n{\n\tstruct kqid qid;\n\tstruct dquot *dquot;\n\tu64 limit;\n\tu64 curblock;\n\n\tqid = make_kqid_projid(projid);\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tspin_lock(&dquot->dq_dqb_lock);\n\n\tlimit = min_not_zero(dquot->dq_dqb.dqb_bsoftlimit,\n\t\t\t     dquot->dq_dqb.dqb_bhardlimit);\n\tlimit >>= sb->s_blocksize_bits;\n\n\tif (limit && buf->f_blocks > limit) {\n\t\tcurblock = (dquot->dq_dqb.dqb_curspace +\n\t\t\t    dquot->dq_dqb.dqb_rsvspace) >> sb->s_blocksize_bits;\n\t\tbuf->f_blocks = limit;\n\t\tbuf->f_bfree = buf->f_bavail =\n\t\t\t(buf->f_blocks > curblock) ?\n\t\t\t (buf->f_blocks - curblock) : 0;\n\t}\n\n\tlimit = min_not_zero(dquot->dq_dqb.dqb_isoftlimit,\n\t\t\t     dquot->dq_dqb.dqb_ihardlimit);\n\tif (limit && buf->f_files > limit) {\n\t\tbuf->f_files = limit;\n\t\tbuf->f_ffree =\n\t\t\t(buf->f_files > dquot->dq_dqb.dqb_curinodes) ?\n\t\t\t (buf->f_files - dquot->dq_dqb.dqb_curinodes) : 0;\n\t}\n\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tdqput(dquot);\n\treturn 0;\n}\n#endif\n\nstatic int ext4_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t overhead = 0, resv_blocks;\n\ts64 bfree;\n\tresv_blocks = EXT4_C2B(sbi, atomic64_read(&sbi->s_resv_clusters));\n\n\tif (!test_opt(sb, MINIX_DF))\n\t\toverhead = sbi->s_overhead;\n\n\tbuf->f_type = EXT4_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = ext4_blocks_count(es) - EXT4_C2B(sbi, overhead);\n\tbfree = percpu_counter_sum_positive(&sbi->s_freeclusters_counter) -\n\t\tpercpu_counter_sum_positive(&sbi->s_dirtyclusters_counter);\n\t \n\tbuf->f_bfree = EXT4_C2B(sbi, max_t(s64, bfree, 0));\n\tbuf->f_bavail = buf->f_bfree -\n\t\t\t(ext4_r_blocks_count(es) + resv_blocks);\n\tif (buf->f_bfree < (ext4_r_blocks_count(es) + resv_blocks))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT4_NAME_LEN;\n\tbuf->f_fsid = uuid_to_fsid(es->s_uuid);\n\n#ifdef CONFIG_QUOTA\n\tif (ext4_test_inode_flag(dentry->d_inode, EXT4_INODE_PROJINHERIT) &&\n\t    sb_has_quota_limits_enabled(sb, PRJQUOTA))\n\t\text4_statfs_project(sb, EXT4_I(dentry->d_inode)->i_projid, buf);\n#endif\n\treturn 0;\n}\n\n\n#ifdef CONFIG_QUOTA\n\n \nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}\n\nstatic int ext4_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext4_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext4_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext4_journal_start(dquot_to_inode(dquot), EXT4_HT_QUOTA,\n\t\t\t\t    EXT4_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t \n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext4_mark_dquot_dirty(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\n\tif (ext4_is_quota_journalled(sb)) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext4_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}\n\nstatic int ext4_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t \n\thandle = ext4_journal_start_sb(sb, EXT4_HT_QUOTA, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic void lockdep_set_quota_inode(struct inode *inode, int subclass)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\t \n\t(void) ei;\t \n\tlockdep_set_subclass(&ei->i_data_sem, subclass);\n}\n\n \nstatic int ext4_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t const struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t \n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\n\t \n\tif (IS_NOQUOTA(d_inode(path->dentry)))\n\t\treturn -EBUSY;\n\n\t \n\tif (EXT4_SB(sb)->s_qf_names[type]) {\n\t\t \n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t\"Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work\");\n\t\tsb_dqopt(sb)->flags |= DQUOT_NOLIST_DIRTY;\n\t} else {\n\t\t \n\t\tsb_dqopt(sb)->flags &= ~DQUOT_NOLIST_DIRTY;\n\t}\n\n\tlockdep_set_quota_inode(path->dentry->d_inode, I_DATA_SEM_QUOTA);\n\terr = dquot_quota_on(sb, type, format_id, path);\n\tif (!err) {\n\t\tstruct inode *inode = d_inode(path->dentry);\n\t\thandle_t *handle;\n\n\t\t \n\t\tinode_lock(inode);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);\n\t\tif (IS_ERR(handle))\n\t\t\tgoto unlock_inode;\n\t\tEXT4_I(inode)->i_flags |= EXT4_NOATIME_FL | EXT4_IMMUTABLE_FL;\n\t\tinode_set_flags(inode, S_NOATIME | S_IMMUTABLE,\n\t\t\t\tS_NOATIME | S_IMMUTABLE);\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\tunlock_inode:\n\t\tinode_unlock(inode);\n\t\tif (err)\n\t\t\tdquot_quota_off(sb, type);\n\t}\n\tif (err)\n\t\tlockdep_set_quota_inode(path->dentry->d_inode,\n\t\t\t\t\t     I_DATA_SEM_NORMAL);\n\treturn err;\n}\n\nstatic inline bool ext4_check_quota_inum(int type, unsigned long qf_inum)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn qf_inum == EXT4_USR_QUOTA_INO;\n\tcase GRPQUOTA:\n\t\treturn qf_inum == EXT4_GRP_QUOTA_INO;\n\tcase PRJQUOTA:\n\t\treturn qf_inum >= EXT4_GOOD_OLD_FIRST_INO;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int ext4_quota_enable(struct super_block *sb, int type, int format_id,\n\t\t\t     unsigned int flags)\n{\n\tint err;\n\tstruct inode *qf_inode;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)\n\t};\n\n\tBUG_ON(!ext4_has_feature_quota(sb));\n\n\tif (!qf_inums[type])\n\t\treturn -EPERM;\n\n\tif (!ext4_check_quota_inum(type, qf_inums[type])) {\n\t\text4_error(sb, \"Bad quota inum: %lu, type: %d\",\n\t\t\t\tqf_inums[type], type);\n\t\treturn -EUCLEAN;\n\t}\n\n\tqf_inode = ext4_iget(sb, qf_inums[type], EXT4_IGET_SPECIAL);\n\tif (IS_ERR(qf_inode)) {\n\t\text4_error(sb, \"Bad quota inode: %lu, type: %d\",\n\t\t\t\tqf_inums[type], type);\n\t\treturn PTR_ERR(qf_inode);\n\t}\n\n\t \n\tqf_inode->i_flags |= S_NOQUOTA;\n\tlockdep_set_quota_inode(qf_inode, I_DATA_SEM_QUOTA);\n\terr = dquot_load_quota_inode(qf_inode, type, format_id, flags);\n\tif (err)\n\t\tlockdep_set_quota_inode(qf_inode, I_DATA_SEM_NORMAL);\n\tiput(qf_inode);\n\n\treturn err;\n}\n\n \nint ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)\n\t};\n\tbool quota_mopt[EXT4_MAXQUOTAS] = {\n\t\ttest_opt(sb, USRQUOTA),\n\t\ttest_opt(sb, GRPQUOTA),\n\t\ttest_opt(sb, PRJQUOTA),\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\tDQUOT_USAGE_ENABLED |\n\t\t\t\t(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d, ino=%lu). \"\n\t\t\t\t\t\"Please run e2fsck to fix.\", type,\n\t\t\t\t\terr, qf_inums[type]);\n\n\t\t\t\text4_quotas_off(sb, type);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ext4_quota_off(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\thandle_t *handle;\n\tint err;\n\n\t \n\tif (test_opt(sb, DELALLOC))\n\t\tsync_filesystem(sb);\n\n\tif (!inode || !igrab(inode))\n\t\tgoto out;\n\n\terr = dquot_quota_off(sb, type);\n\tif (err || ext4_has_feature_quota(sb))\n\t\tgoto out_put;\n\t \n\tif (sb_rdonly(sb))\n\t\tgoto out_put;\n\n\tinode_lock(inode);\n\t \n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto out_unlock;\n\t}\n\tEXT4_I(inode)->i_flags &= ~(EXT4_NOATIME_FL | EXT4_IMMUTABLE_FL);\n\tinode_set_flags(inode, 0, S_NOATIME | S_IMMUTABLE);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\nout_unlock:\n\tinode_unlock(inode);\nout_put:\n\tlockdep_set_quota_inode(inode, I_DATA_SEM_NORMAL);\n\tiput(inode);\n\treturn err;\nout:\n\treturn dquot_quota_off(sb, type);\n}\n\n \nstatic ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(unsigned long, sb->s_blocksize - offset, toread);\n\t\tbh = ext4_bread(NULL, inode, blk, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tif (!bh)\t \n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t ext4_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\text4_lblk_t blk = off >> EXT4_BLOCK_SIZE_BITS(sb);\n\tint err = 0, err2 = 0, offset = off & (sb->s_blocksize - 1);\n\tint retries = 0;\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (!handle) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\t \n\tif (sb->s_blocksize - offset < len) {\n\t\text4_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tbh = ext4_bread(handle, inode, blk,\n\t\t\t\tEXT4_GET_BLOCKS_CREATE |\n\t\t\t\tEXT4_GET_BLOCKS_METADATA_NOFAIL);\n\t} while (PTR_ERR(bh) == -ENOSPC &&\n\t\t ext4_should_retry_alloc(inode->i_sb, &retries));\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto out;\n\tBUFFER_TRACE(bh, \"get write access\");\n\terr = ext4_journal_get_write_access(handle, sb, bh, EXT4_JTR_NONE);\n\tif (err) {\n\t\tbrelse(bh);\n\t\treturn err;\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tbrelse(bh);\nout:\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT4_I(inode)->i_disksize = inode->i_size;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err2 && !err))\n\t\t\terr = err2;\n\t}\n\treturn err ? err : len;\n}\n#endif\n\n#if !defined(CONFIG_EXT2_FS) && !defined(CONFIG_EXT2_FS_MODULE) && defined(CONFIG_EXT4_USE_FOR_EXT2)\nstatic inline void register_as_ext2(void)\n{\n\tint err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext2 (%d)\\n\", err);\n}\n\nstatic inline void unregister_as_ext2(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n}\n\nstatic inline int ext2_feature_set_ok(struct super_block *sb)\n{\n\tif (ext4_has_unknown_ext2_incompat_features(sb))\n\t\treturn 0;\n\tif (sb_rdonly(sb))\n\t\treturn 1;\n\tif (ext4_has_unknown_ext2_ro_compat_features(sb))\n\t\treturn 0;\n\treturn 1;\n}\n#else\nstatic inline void register_as_ext2(void) { }\nstatic inline void unregister_as_ext2(void) { }\nstatic inline int ext2_feature_set_ok(struct super_block *sb) { return 0; }\n#endif\n\nstatic inline void register_as_ext3(void)\n{\n\tint err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs: Unable to register as ext3 (%d)\\n\", err);\n}\n\nstatic inline void unregister_as_ext3(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n}\n\nstatic inline int ext3_feature_set_ok(struct super_block *sb)\n{\n\tif (ext4_has_unknown_ext3_incompat_features(sb))\n\t\treturn 0;\n\tif (!ext4_has_feature_journal(sb))\n\t\treturn 0;\n\tif (sb_rdonly(sb))\n\t\treturn 1;\n\tif (ext4_has_unknown_ext3_ro_compat_features(sb))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void ext4_kill_sb(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct block_device *journal_bdev = sbi ? sbi->s_journal_bdev : NULL;\n\n\tkill_block_super(sb);\n\n\tif (journal_bdev)\n\t\tblkdev_put(journal_bdev, sb);\n}\n\nstatic struct file_system_type ext4_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"ext4\",\n\t.init_fs_context\t= ext4_init_fs_context,\n\t.parameters\t\t= ext4_param_specs,\n\t.kill_sb\t\t= ext4_kill_sb,\n\t.fs_flags\t\t= FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"ext4\");\n\n \nwait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];\n\nstatic int __init ext4_init_fs(void)\n{\n\tint i, err;\n\n\tratelimit_state_init(&ext4_mount_msg_ratelimit, 30 * HZ, 64);\n\text4_li_info = NULL;\n\n\t \n\text4_check_flag_values();\n\n\tfor (i = 0; i < EXT4_WQ_HASH_SZ; i++)\n\t\tinit_waitqueue_head(&ext4__ioend_wq[i]);\n\n\terr = ext4_init_es();\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_init_pending();\n\tif (err)\n\t\tgoto out7;\n\n\terr = ext4_init_post_read_processing();\n\tif (err)\n\t\tgoto out6;\n\n\terr = ext4_init_pageio();\n\tif (err)\n\t\tgoto out5;\n\n\terr = ext4_init_system_zone();\n\tif (err)\n\t\tgoto out4;\n\n\terr = ext4_init_sysfs();\n\tif (err)\n\t\tgoto out3;\n\n\terr = ext4_init_mballoc();\n\tif (err)\n\t\tgoto out2;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\n\terr = ext4_fc_init_dentry_cache();\n\tif (err)\n\t\tgoto out05;\n\n\tregister_as_ext3();\n\tregister_as_ext2();\n\terr = register_filesystem(&ext4_fs_type);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\text4_fc_destroy_dentry_cache();\nout05:\n\tdestroy_inodecache();\nout1:\n\text4_exit_mballoc();\nout2:\n\text4_exit_sysfs();\nout3:\n\text4_exit_system_zone();\nout4:\n\text4_exit_pageio();\nout5:\n\text4_exit_post_read_processing();\nout6:\n\text4_exit_pending();\nout7:\n\text4_exit_es();\n\n\treturn err;\n}\n\nstatic void __exit ext4_exit_fs(void)\n{\n\text4_destroy_lazyinit_thread();\n\tunregister_as_ext2();\n\tunregister_as_ext3();\n\tunregister_filesystem(&ext4_fs_type);\n\text4_fc_destroy_dentry_cache();\n\tdestroy_inodecache();\n\text4_exit_mballoc();\n\text4_exit_sysfs();\n\text4_exit_system_zone();\n\text4_exit_pageio();\n\text4_exit_post_read_processing();\n\text4_exit_es();\n\text4_exit_pending();\n}\n\nMODULE_AUTHOR(\"Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others\");\nMODULE_DESCRIPTION(\"Fourth Extended Filesystem\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: crc32c\");\nmodule_init(ext4_init_fs)\nmodule_exit(ext4_exit_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}