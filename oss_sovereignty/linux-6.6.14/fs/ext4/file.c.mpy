{
  "module_name": "file.c",
  "hash_id": "ac2346ab0382f8ecac2a2f10285bd462eba6f4b0d747ec627bc7f2b7a5c21c6c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/file.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/mount.h>\n#include <linux/path.h>\n#include <linux/dax.h>\n#include <linux/quotaops.h>\n#include <linux/pagevec.h>\n#include <linux/uio.h>\n#include <linux/mman.h>\n#include <linux/backing-dev.h>\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"truncate.h\"\n\n \nstatic bool ext4_should_use_dio(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tu32 dio_align = ext4_dio_alignment(inode);\n\n\tif (dio_align == 0)\n\t\treturn false;\n\n\tif (dio_align == 1)\n\t\treturn true;\n\n\treturn IS_ALIGNED(iocb->ki_pos | iov_iter_alignment(iter), dio_align);\n}\n\nstatic ssize_t ext4_dio_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tssize_t ret;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock_shared(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock_shared(inode);\n\t}\n\n\tif (!ext4_should_use_dio(iocb, to)) {\n\t\tinode_unlock_shared(inode);\n\t\t \n\t\tiocb->ki_flags &= ~IOCB_DIRECT;\n\t\treturn generic_file_read_iter(iocb, to);\n\t}\n\n\tret = iomap_dio_rw(iocb, to, &ext4_iomap_ops, NULL, 0, NULL, 0);\n\tinode_unlock_shared(inode);\n\n\tfile_accessed(iocb->ki_filp);\n\treturn ret;\n}\n\n#ifdef CONFIG_FS_DAX\nstatic ssize_t ext4_dax_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t ret;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock_shared(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock_shared(inode);\n\t}\n\t \n\tif (!IS_DAX(inode)) {\n\t\tinode_unlock_shared(inode);\n\t\t \n\t\treturn generic_file_read_iter(iocb, to);\n\t}\n\tret = dax_iomap_rw(iocb, to, &ext4_iomap_ops);\n\tinode_unlock_shared(inode);\n\n\tfile_accessed(iocb->ki_filp);\n\treturn ret;\n}\n#endif\n\nstatic ssize_t ext4_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n\tif (!iov_iter_count(to))\n\t\treturn 0;  \n\n#ifdef CONFIG_FS_DAX\n\tif (IS_DAX(inode))\n\t\treturn ext4_dax_read_iter(iocb, to);\n#endif\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn ext4_dio_read_iter(iocb, to);\n\n\treturn generic_file_read_iter(iocb, to);\n}\n\nstatic ssize_t ext4_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t     struct pipe_inode_info *pipe,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(in);\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\treturn filemap_splice_read(in, ppos, pipe, len, flags);\n}\n\n \nstatic int ext4_release_file(struct inode *inode, struct file *filp)\n{\n\tif (ext4_test_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE)) {\n\t\text4_alloc_da_blocks(inode);\n\t\text4_clear_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\t}\n\t \n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t\t\t(atomic_read(&inode->i_writecount) == 1) &&\n\t\t\t!EXT4_I(inode)->i_reserved_data_blocks) {\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_discard_preallocations(inode, 0);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t}\n\tif (is_dx(inode) && filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}\n\n \nstatic bool\next4_unaligned_io(struct inode *inode, struct iov_iter *from, loff_t pos)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long blockmask = sb->s_blocksize - 1;\n\n\tif ((pos | iov_iter_alignment(from)) & blockmask)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\next4_extending_io(struct inode *inode, loff_t offset, size_t len)\n{\n\tif (offset + len > i_size_read(inode) ||\n\t    offset + len > EXT4_I(inode)->i_disksize)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool ext4_overwrite_io(struct inode *inode,\n\t\t\t      loff_t pos, loff_t len, bool *unwritten)\n{\n\tstruct ext4_map_blocks map;\n\tunsigned int blkbits = inode->i_blkbits;\n\tint err, blklen;\n\n\tif (pos + len > i_size_read(inode))\n\t\treturn false;\n\n\tmap.m_lblk = pos >> blkbits;\n\tmap.m_len = EXT4_MAX_BLOCKS(len, pos, blkbits);\n\tblklen = map.m_len;\n\n\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\tif (err != blklen)\n\t\treturn false;\n\t \n\t*unwritten = !(map.m_flags & EXT4_MAP_MAPPED);\n\treturn true;\n}\n\nstatic ssize_t ext4_generic_write_checks(struct kiocb *iocb,\n\t\t\t\t\t struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t ret;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn -EPERM;\n\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\t \n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\tif (iocb->ki_pos >= sbi->s_bitmap_maxbytes)\n\t\t\treturn -EFBIG;\n\t\tiov_iter_truncate(from, sbi->s_bitmap_maxbytes - iocb->ki_pos);\n\t}\n\n\treturn iov_iter_count(from);\n}\n\nstatic ssize_t ext4_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t ret, count;\n\n\tcount = ext4_generic_write_checks(iocb, from);\n\tif (count <= 0)\n\t\treturn count;\n\n\tret = file_modified(iocb->ki_filp);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t ext4_buffered_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\tssize_t ret;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tret = ext4_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tret = generic_perform_write(iocb, from);\n\nout:\n\tinode_unlock(inode);\n\tif (unlikely(ret <= 0))\n\t\treturn ret;\n\treturn generic_write_sync(iocb, ret);\n}\n\nstatic ssize_t ext4_handle_inode_extension(struct inode *inode, loff_t offset,\n\t\t\t\t\t   ssize_t count)\n{\n\thandle_t *handle;\n\n\tlockdep_assert_held_write(&inode->i_rwsem);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (ext4_update_inode_size(inode, offset + count)) {\n\t\tint ret = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(ret)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\n\treturn count;\n}\n\n \nstatic void ext4_inode_extension_cleanup(struct inode *inode, ssize_t count)\n{\n\tlockdep_assert_held_write(&inode->i_rwsem);\n\tif (count < 0) {\n\t\text4_truncate_failed_write(inode);\n\t\t \n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t\treturn;\n\t}\n\t \n\tif (!list_empty(&EXT4_I(inode)->i_orphan) && inode->i_nlink) {\n\t\thandle_t *handle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\n\t\tif (IS_ERR(handle)) {\n\t\t\t \n\t\t\text4_orphan_del(NULL, inode);\n\t\t\treturn;\n\t\t}\n\t\text4_orphan_del(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n}\n\nstatic int ext4_dio_write_end_io(struct kiocb *iocb, ssize_t size,\n\t\t\t\t int error, unsigned int flags)\n{\n\tloff_t pos = iocb->ki_pos;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (!error && size && flags & IOMAP_DIO_UNWRITTEN)\n\t\terror = ext4_convert_unwritten_extents(NULL, inode, pos, size);\n\tif (error)\n\t\treturn error;\n\t \n\tif (pos + size <= READ_ONCE(EXT4_I(inode)->i_disksize) &&\n\t    pos + size <= i_size_read(inode))\n\t\treturn size;\n\treturn ext4_handle_inode_extension(inode, pos, size);\n}\n\nstatic const struct iomap_dio_ops ext4_dio_write_ops = {\n\t.end_io = ext4_dio_write_end_io,\n};\n\n \nstatic ssize_t ext4_dio_write_checks(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t\t     bool *ilock_shared, bool *extend,\n\t\t\t\t     bool *unwritten, int *dio_flags)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tloff_t offset;\n\tsize_t count;\n\tssize_t ret;\n\tbool overwrite, unaligned_io;\n\nrestart:\n\tret = ext4_generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\toffset = iocb->ki_pos;\n\tcount = ret;\n\n\tunaligned_io = ext4_unaligned_io(inode, from, offset);\n\t*extend = ext4_extending_io(inode, offset, count);\n\toverwrite = ext4_overwrite_io(inode, offset, count, unwritten);\n\n\t \n\tif (*ilock_shared &&\n\t    ((!IS_NOSEC(inode) || *extend || !overwrite ||\n\t     (unaligned_io && *unwritten)))) {\n\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tinode_unlock_shared(inode);\n\t\t*ilock_shared = false;\n\t\tinode_lock(inode);\n\t\tgoto restart;\n\t}\n\n\t \n\tif (!*ilock_shared && (unaligned_io || *extend)) {\n\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (unaligned_io && (!overwrite || *unwritten))\n\t\t\tinode_dio_wait(inode);\n\t\t*dio_flags = IOMAP_DIO_FORCE_WAIT;\n\t}\n\n\tret = file_modified(file);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn count;\nout:\n\tif (*ilock_shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\n\treturn ret;\n}\n\nstatic ssize_t ext4_dio_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t ret;\n\thandle_t *handle;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tloff_t offset = iocb->ki_pos;\n\tsize_t count = iov_iter_count(from);\n\tconst struct iomap_ops *iomap_ops = &ext4_iomap_ops;\n\tbool extend = false, unwritten = false;\n\tbool ilock_shared = true;\n\tint dio_flags = 0;\n\n\t \n\tif (offset + count > i_size_read(inode))\n\t\tilock_shared = false;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (ilock_shared) {\n\t\t\tif (!inode_trylock_shared(inode))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tif (!inode_trylock(inode))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (ilock_shared)\n\t\t\tinode_lock_shared(inode);\n\t\telse\n\t\t\tinode_lock(inode);\n\t}\n\n\t \n\tif (!ext4_should_use_dio(iocb, from)) {\n\t\tif (ilock_shared)\n\t\t\tinode_unlock_shared(inode);\n\t\telse\n\t\t\tinode_unlock(inode);\n\t\treturn ext4_buffered_write_iter(iocb, from);\n\t}\n\n\t \n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\n\tret = ext4_dio_write_checks(iocb, from, &ilock_shared, &extend,\n\t\t\t\t    &unwritten, &dio_flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\toffset = iocb->ki_pos;\n\tcount = ret;\n\n\tif (extend) {\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ext4_orphan_add(handle, inode);\n\t\tif (ret) {\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (ilock_shared && !unwritten)\n\t\tiomap_ops = &ext4_iomap_overwrite_ops;\n\tret = iomap_dio_rw(iocb, from, iomap_ops, &ext4_dio_write_ops,\n\t\t\t   dio_flags, NULL, 0);\n\tif (ret == -ENOTBLK)\n\t\tret = 0;\n\tif (extend) {\n\t\t \n\t\tWARN_ON_ONCE(ret == -EIOCBQUEUED);\n\t\text4_inode_extension_cleanup(inode, ret);\n\t}\n\nout:\n\tif (ilock_shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\n\n\tif (ret >= 0 && iov_iter_count(from)) {\n\t\tssize_t err;\n\t\tloff_t endbyte;\n\n\t\toffset = iocb->ki_pos;\n\t\terr = ext4_buffered_write_iter(iocb, from);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tret += err;\n\t\tendbyte = offset + err - 1;\n\t\terr = filemap_write_and_wait_range(iocb->ki_filp->f_mapping,\n\t\t\t\t\t\t   offset, endbyte);\n\t\tif (!err)\n\t\t\tinvalidate_mapping_pages(iocb->ki_filp->f_mapping,\n\t\t\t\t\t\t offset >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_FS_DAX\nstatic ssize_t\next4_dax_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t ret;\n\tsize_t count;\n\tloff_t offset;\n\thandle_t *handle;\n\tbool extend = false;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock(inode))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tinode_lock(inode);\n\t}\n\n\tret = ext4_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\toffset = iocb->ki_pos;\n\tcount = iov_iter_count(from);\n\n\tif (offset + count > EXT4_I(inode)->i_disksize) {\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ext4_orphan_add(handle, inode);\n\t\tif (ret) {\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\textend = true;\n\t\text4_journal_stop(handle);\n\t}\n\n\tret = dax_iomap_rw(iocb, from, &ext4_iomap_ops);\n\n\tif (extend) {\n\t\tret = ext4_handle_inode_extension(inode, offset, ret);\n\t\text4_inode_extension_cleanup(inode, ret);\n\t}\nout:\n\tinode_unlock(inode);\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\treturn ret;\n}\n#endif\n\nstatic ssize_t\next4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n#ifdef CONFIG_FS_DAX\n\tif (IS_DAX(inode))\n\t\treturn ext4_dax_write_iter(iocb, from);\n#endif\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn ext4_dio_write_iter(iocb, from);\n\telse\n\t\treturn ext4_buffered_write_iter(iocb, from);\n}\n\n#ifdef CONFIG_FS_DAX\nstatic vm_fault_t ext4_dax_huge_fault(struct vm_fault *vmf, unsigned int order)\n{\n\tint error = 0;\n\tvm_fault_t result;\n\tint retries = 0;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\n\t \n\tbool write = (vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t(vmf->vma->vm_flags & VM_SHARED);\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tpfn_t pfn;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vmf->vma->vm_file);\n\t\tfilemap_invalidate_lock_shared(mapping);\nretry:\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t       EXT4_DATA_TRANS_BLOCKS(sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tfilemap_invalidate_unlock_shared(mapping);\n\t\t\tsb_end_pagefault(sb);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t} else {\n\t\tfilemap_invalidate_lock_shared(mapping);\n\t}\n\tresult = dax_iomap_fault(vmf, order, &pfn, &error, &ext4_iomap_ops);\n\tif (write) {\n\t\text4_journal_stop(handle);\n\n\t\tif ((result & VM_FAULT_ERROR) && error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(sb, &retries))\n\t\t\tgoto retry;\n\t\t \n\t\tif (result & VM_FAULT_NEEDDSYNC)\n\t\t\tresult = dax_finish_sync_fault(vmf, order, pfn);\n\t\tfilemap_invalidate_unlock_shared(mapping);\n\t\tsb_end_pagefault(sb);\n\t} else {\n\t\tfilemap_invalidate_unlock_shared(mapping);\n\t}\n\n\treturn result;\n}\n\nstatic vm_fault_t ext4_dax_fault(struct vm_fault *vmf)\n{\n\treturn ext4_dax_huge_fault(vmf, 0);\n}\n\nstatic const struct vm_operations_struct ext4_dax_vm_ops = {\n\t.fault\t\t= ext4_dax_fault,\n\t.huge_fault\t= ext4_dax_huge_fault,\n\t.page_mkwrite\t= ext4_dax_fault,\n\t.pfn_mkwrite\t= ext4_dax_fault,\n};\n#else\n#define ext4_dax_vm_ops\text4_file_vm_ops\n#endif\n\nstatic const struct vm_operations_struct ext4_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite   = ext4_page_mkwrite,\n};\n\nstatic int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct dax_device *dax_dev = EXT4_SB(inode->i_sb)->s_daxdev;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n\t \n\tif (!daxdev_mapping_supported(vma, dax_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tfile_accessed(file);\n\tif (IS_DAX(file_inode(file))) {\n\t\tvma->vm_ops = &ext4_dax_vm_ops;\n\t\tvm_flags_set(vma, VM_HUGEPAGE);\n\t} else {\n\t\tvma->vm_ops = &ext4_file_vm_ops;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_sample_last_mounted(struct super_block *sb,\n\t\t\t\t    struct vfsmount *mnt)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct path path;\n\tchar buf[64], *cp;\n\thandle_t *handle;\n\tint err;\n\n\tif (likely(ext4_test_mount_flag(sb, EXT4_MF_MNTDIR_SAMPLED)))\n\t\treturn 0;\n\n\tif (sb_rdonly(sb) || !sb_start_intwrite_trylock(sb))\n\t\treturn 0;\n\n\text4_set_mount_flag(sb, EXT4_MF_MNTDIR_SAMPLED);\n\t \n\tmemset(buf, 0, sizeof(buf));\n\tpath.mnt = mnt;\n\tpath.dentry = mnt->mnt_root;\n\tcp = d_path(&path, buf, sizeof(buf));\n\terr = 0;\n\tif (IS_ERR(cp))\n\t\tgoto out;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\terr = PTR_ERR(handle);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, sbi->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out_journal;\n\tlock_buffer(sbi->s_sbh);\n\tstrncpy(sbi->s_es->s_last_mounted, cp,\n\t\tsizeof(sbi->s_es->s_last_mounted));\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbi->s_sbh);\n\text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tsb_end_intwrite(sb);\n\treturn err;\n}\n\nstatic int ext4_file_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n\tret = ext4_sample_last_mounted(inode->i_sb, filp->f_path.mnt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fscrypt_file_open(inode, filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fsverity_file_open(inode, filp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfilp->f_mode |= FMODE_NOWAIT | FMODE_BUF_RASYNC |\n\t\t\tFMODE_DIO_PARALLEL_WRITE;\n\treturn dquot_file_open(inode, filp);\n}\n\n \nloff_t ext4_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes;\n\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\telse\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tdefault:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_HOLE:\n\t\tinode_lock_shared(inode);\n\t\toffset = iomap_seek_hole(inode, offset,\n\t\t\t\t\t &ext4_iomap_report_ops);\n\t\tinode_unlock_shared(inode);\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\tinode_lock_shared(inode);\n\t\toffset = iomap_seek_data(inode, offset,\n\t\t\t\t\t &ext4_iomap_report_ops);\n\t\tinode_unlock_shared(inode);\n\t\tbreak;\n\t}\n\n\tif (offset < 0)\n\t\treturn offset;\n\treturn vfs_setpos(file, offset, maxbytes);\n}\n\nconst struct file_operations ext4_file_operations = {\n\t.llseek\t\t= ext4_llseek,\n\t.read_iter\t= ext4_file_read_iter,\n\t.write_iter\t= ext4_file_write_iter,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.unlocked_ioctl = ext4_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ext4_compat_ioctl,\n#endif\n\t.mmap\t\t= ext4_file_mmap,\n\t.mmap_supported_flags = MAP_SYNC,\n\t.open\t\t= ext4_file_open,\n\t.release\t= ext4_release_file,\n\t.fsync\t\t= ext4_sync_file,\n\t.get_unmapped_area = thp_get_unmapped_area,\n\t.splice_read\t= ext4_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fallocate\t= ext4_fallocate,\n};\n\nconst struct inode_operations ext4_file_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_file_getattr,\n\t.listxattr\t= ext4_listxattr,\n\t.get_inode_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n\t.fiemap\t\t= ext4_fiemap,\n\t.fileattr_get\t= ext4_fileattr_get,\n\t.fileattr_set\t= ext4_fileattr_set,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}