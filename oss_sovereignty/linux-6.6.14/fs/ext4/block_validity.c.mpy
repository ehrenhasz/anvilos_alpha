{
  "module_name": "block_validity.c",
  "hash_id": "51d475ed93a71fb03cccd007042302e562ce1a54b55027904fb74ea9978848e0",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/block_validity.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include \"ext4.h\"\n\nstruct ext4_system_zone {\n\tstruct rb_node\tnode;\n\text4_fsblk_t\tstart_blk;\n\tunsigned int\tcount;\n\tu32\t\tino;\n};\n\nstatic struct kmem_cache *ext4_system_zone_cachep;\n\nint __init ext4_init_system_zone(void)\n{\n\text4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);\n\tif (ext4_system_zone_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid ext4_exit_system_zone(void)\n{\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_system_zone_cachep);\n}\n\nstatic inline int can_merge(struct ext4_system_zone *entry1,\n\t\t     struct ext4_system_zone *entry2)\n{\n\tif ((entry1->start_blk + entry1->count) == entry2->start_blk &&\n\t    entry1->ino == entry2->ino)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void release_system_zone(struct ext4_system_blocks *system_blks)\n{\n\tstruct ext4_system_zone\t*entry, *n;\n\n\trbtree_postorder_for_each_entry_safe(entry, n,\n\t\t\t\t&system_blks->root, node)\n\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n}\n\n \nstatic int add_system_zone(struct ext4_system_blocks *system_blks,\n\t\t\t   ext4_fsblk_t start_blk,\n\t\t\t   unsigned int count, u32 ino)\n{\n\tstruct ext4_system_zone *new_entry, *entry;\n\tstruct rb_node **n = &system_blks->root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node = NULL;\n\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_system_zone, node);\n\t\tif (start_blk < entry->start_blk)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse\t \n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tnew_entry = kmem_cache_alloc(ext4_system_zone_cachep,\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_entry)\n\t\treturn -ENOMEM;\n\tnew_entry->start_blk = start_blk;\n\tnew_entry->count = count;\n\tnew_entry->ino = ino;\n\tnew_node = &new_entry->node;\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &system_blks->root);\n\n\t \n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(entry, new_entry)) {\n\t\t\tnew_entry->start_blk = entry->start_blk;\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &system_blks->root);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\n\t \n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tif (can_merge(new_entry, entry)) {\n\t\t\tnew_entry->count += entry->count;\n\t\t\trb_erase(node, &system_blks->root);\n\t\t\tkmem_cache_free(ext4_system_zone_cachep, entry);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void debug_print_tree(struct ext4_sb_info *sbi)\n{\n\tstruct rb_node *node;\n\tstruct ext4_system_zone *entry;\n\tstruct ext4_system_blocks *system_blks;\n\tint first = 1;\n\n\tprintk(KERN_INFO \"System zones: \");\n\trcu_read_lock();\n\tsystem_blks = rcu_dereference(sbi->s_system_blks);\n\tnode = rb_first(&system_blks->root);\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ext4_system_zone, node);\n\t\tprintk(KERN_CONT \"%s%llu-%llu\", first ? \"\" : \", \",\n\t\t       entry->start_blk, entry->start_blk + entry->count - 1);\n\t\tfirst = 0;\n\t\tnode = rb_next(node);\n\t}\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstatic int ext4_protect_reserved_inode(struct super_block *sb,\n\t\t\t\t       struct ext4_system_blocks *system_blks,\n\t\t\t\t       u32 ino)\n{\n\tstruct inode *inode;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_map_blocks map;\n\tu32 i = 0, num;\n\tint err = 0, n;\n\n\tif ((ino < EXT4_ROOT_INO) ||\n\t    (ino > le32_to_cpu(sbi->s_es->s_inodes_count)))\n\t\treturn -EINVAL;\n\tinode = ext4_iget(sb, ino, EXT4_IGET_SPECIAL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tnum = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\twhile (i < num) {\n\t\tcond_resched();\n\t\tmap.m_lblk = i;\n\t\tmap.m_len = num - i;\n\t\tn = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (n < 0) {\n\t\t\terr = n;\n\t\t\tbreak;\n\t\t}\n\t\tif (n == 0) {\n\t\t\ti++;\n\t\t} else {\n\t\t\terr = add_system_zone(system_blks, map.m_pblk, n, ino);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -EFSCORRUPTED) {\n\t\t\t\t\tEXT4_ERROR_INODE_ERR(inode, -err,\n\t\t\t\t\t\t\"blocks %llu-%llu from inode overlap system zone\",\n\t\t\t\t\t\tmap.m_pblk,\n\t\t\t\t\t\tmap.m_pblk + map.m_len - 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += n;\n\t\t}\n\t}\n\tiput(inode);\n\treturn err;\n}\n\nstatic void ext4_destroy_system_zone(struct rcu_head *rcu)\n{\n\tstruct ext4_system_blocks *system_blks;\n\n\tsystem_blks = container_of(rcu, struct ext4_system_blocks, rcu);\n\trelease_system_zone(system_blks);\n\tkfree(system_blks);\n}\n\n \nint ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_system_blocks *system_blks;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint ret;\n\n\tsystem_blks = kzalloc(sizeof(*system_blks), GFP_KERNEL);\n\tif (!system_blks)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tunsigned int meta_blks = ext4_num_base_meta_blocks(sb, i);\n\n\t\tcond_resched();\n\t\tif (meta_blks != 0) {\n\t\t\tret = add_system_zone(system_blks,\n\t\t\t\t\text4_group_first_block_no(sb, i),\n\t\t\t\t\tmeta_blks, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(system_blks,\n\t\t\t\text4_block_bitmap(sb, gdp), 1, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = add_system_zone(system_blks,\n\t\t\t\text4_inode_bitmap(sb, gdp), 1, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = add_system_zone(system_blks,\n\t\t\t\text4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\tif (ext4_has_feature_journal(sb) && sbi->s_es->s_journal_inum) {\n\t\tret = ext4_protect_reserved_inode(sb, system_blks,\n\t\t\t\tle32_to_cpu(sbi->s_es->s_journal_inum));\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\trcu_assign_pointer(sbi->s_system_blks, system_blks);\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(sbi);\n\treturn 0;\nerr:\n\trelease_system_zone(system_blks);\n\tkfree(system_blks);\n\treturn ret;\n}\n\n \nvoid ext4_release_system_zone(struct super_block *sb)\n{\n\tstruct ext4_system_blocks *system_blks;\n\n\tsystem_blks = rcu_dereference_protected(EXT4_SB(sb)->s_system_blks,\n\t\t\t\t\tlockdep_is_held(&sb->s_umount));\n\trcu_assign_pointer(EXT4_SB(sb)->s_system_blks, NULL);\n\n\tif (system_blks)\n\t\tcall_rcu(&system_blks->rcu, ext4_destroy_system_zone);\n}\n\nint ext4_sb_block_valid(struct super_block *sb, struct inode *inode,\n\t\t\t\text4_fsblk_t start_blk, unsigned int count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_system_blocks *system_blks;\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es)))\n\t\treturn 0;\n\n\t \n\trcu_read_lock();\n\tsystem_blks = rcu_dereference(sbi->s_system_blks);\n\tif (system_blks == NULL)\n\t\tgoto out_rcu;\n\n\tn = system_blks->root.rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tret = 0;\n\t\t\tif (inode)\n\t\t\t\tret = (entry->ino == inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\nout_rcu:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint ext4_inode_block_valid(struct inode *inode, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\treturn ext4_sb_block_valid(inode->i_sb, inode, start_blk, count);\n}\n\nint ext4_check_blockref(const char *function, unsigned int line,\n\t\t\tstruct inode *inode, __le32 *p, unsigned int max)\n{\n\t__le32 *bref = p;\n\tunsigned int blk;\n\n\tif (ext4_has_feature_journal(inode->i_sb) &&\n\t    (inode->i_ino ==\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n\t\treturn 0;\n\n\twhile (bref < p+max) {\n\t\tblk = le32_to_cpu(*bref++);\n\t\tif (blk &&\n\t\t    unlikely(!ext4_inode_block_valid(inode, blk, 1))) {\n\t\t\text4_error_inode(inode, function, line, blk,\n\t\t\t\t\t \"invalid block\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}