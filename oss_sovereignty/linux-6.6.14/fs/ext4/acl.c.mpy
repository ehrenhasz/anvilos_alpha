{
  "module_name": "acl.c",
  "hash_id": "05c53ac706abc2a47dd5091c357c33b81b805b1c65da609c6463f9a821131e75",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/acl.c",
  "human_readable_source": "\n \n\n#include <linux/quotaops.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n \nstatic struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstatic void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\n \nstruct posix_acl *\next4_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext4_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext4_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext4_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\n \nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl, int xattr_flags)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, xattr_flags);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}\n\nint\next4_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t     struct posix_acl *acl, int type)\n{\n\thandle_t *handle;\n\tint error, credits, retries = 0;\n\tsize_t acl_size = acl ? ext4_acl_size(acl->a_count) : 0;\n\tstruct inode *inode = d_inode(dentry);\n\tumode_t mode = inode->i_mode;\n\tint update_mode = 0;\n\n\terror = dquot_initialize(inode);\n\tif (error)\n\t\treturn error;\nretry:\n\terror = ext4_xattr_set_credits(inode, acl_size, false  ,\n\t\t\t\t       &credits);\n\tif (error)\n\t\treturn error;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif ((type == ACL_TYPE_ACCESS) && acl) {\n\t\terror = posix_acl_update_mode(idmap, inode, &mode, &acl);\n\t\tif (error)\n\t\t\tgoto out_stop;\n\t\tif (mode != inode->i_mode)\n\t\t\tupdate_mode = 1;\n\t}\n\n\terror = __ext4_set_acl(handle, inode, type, acl, 0  );\n\tif (!error && update_mode) {\n\t\tinode->i_mode = mode;\n\t\tinode_set_ctime_current(inode);\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t}\nout_stop:\n\text4_journal_stop(handle);\n\tif (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn error;\n}\n\n \nint\next4_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl, XATTR_CREATE);\n\t\tposix_acl_release(default_acl);\n\t} else {\n\t\tinode->i_default_acl = NULL;\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl, XATTR_CREATE);\n\t\tposix_acl_release(acl);\n\t} else {\n\t\tinode->i_acl = NULL;\n\t}\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}