{
  "module_name": "move_extent.c",
  "hash_id": "32d228fdf86efa41d7c514fa2554f6421887364974733c4ea9b04747bbac1401",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/move_extent.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"ext4_extents.h\"\n\n \nstatic inline int\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\n\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path;\n\n\tpath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (path[ext_depth(inode)].p_ext == NULL) {\n\t\text4_free_ext_path(path);\n\t\t*ppath = NULL;\n\t\treturn -ENODATA;\n\t}\n\t*ppath = path;\n\treturn 0;\n}\n\n \nvoid\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\n{\n\tif (first < second) {\n\t\tdown_write(&EXT4_I(first)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(second)->i_data_sem, I_DATA_SEM_OTHER);\n\t} else {\n\t\tdown_write(&EXT4_I(second)->i_data_sem);\n\t\tdown_write_nested(&EXT4_I(first)->i_data_sem, I_DATA_SEM_OTHER);\n\n\t}\n}\n\n \nvoid\next4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t      struct inode *donor_inode)\n{\n\tup_write(&EXT4_I(orig_inode)->i_data_sem);\n\tup_write(&EXT4_I(donor_inode)->i_data_sem);\n}\n\n \nstatic int\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\n\t\t    int unwritten, int *err)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ext;\n\tint ret = 0;\n\text4_lblk_t last = from + count;\n\twhile (from < last) {\n\t\t*err = get_ext_path(inode, from, &path);\n\t\tif (*err)\n\t\t\tgoto out;\n\t\text = path[ext_depth(inode)].p_ext;\n\t\tif (unwritten != ext4_ext_is_unwritten(ext))\n\t\t\tgoto out;\n\t\tfrom += ext4_ext_get_actual_len(ext);\n\t}\n\tret = 1;\nout:\n\text4_free_ext_path(path);\n\treturn ret;\n}\n\n \nstatic int\nmext_folio_double_lock(struct inode *inode1, struct inode *inode2,\n\t\t      pgoff_t index1, pgoff_t index2, struct folio *folio[2])\n{\n\tstruct address_space *mapping[2];\n\tunsigned int flags;\n\n\tBUG_ON(!inode1 || !inode2);\n\tif (inode1 < inode2) {\n\t\tmapping[0] = inode1->i_mapping;\n\t\tmapping[1] = inode2->i_mapping;\n\t} else {\n\t\tswap(index1, index2);\n\t\tmapping[0] = inode2->i_mapping;\n\t\tmapping[1] = inode1->i_mapping;\n\t}\n\n\tflags = memalloc_nofs_save();\n\tfolio[0] = __filemap_get_folio(mapping[0], index1, FGP_WRITEBEGIN,\n\t\t\tmapping_gfp_mask(mapping[0]));\n\tif (IS_ERR(folio[0])) {\n\t\tmemalloc_nofs_restore(flags);\n\t\treturn PTR_ERR(folio[0]);\n\t}\n\n\tfolio[1] = __filemap_get_folio(mapping[1], index2, FGP_WRITEBEGIN,\n\t\t\tmapping_gfp_mask(mapping[1]));\n\tmemalloc_nofs_restore(flags);\n\tif (IS_ERR(folio[1])) {\n\t\tfolio_unlock(folio[0]);\n\t\tfolio_put(folio[0]);\n\t\treturn PTR_ERR(folio[1]);\n\t}\n\t \n\tfolio_wait_writeback(folio[0]);\n\tfolio_wait_writeback(folio[1]);\n\tif (inode1 > inode2)\n\t\tswap(folio[0], folio[1]);\n\n\treturn 0;\n}\n\n \nstatic int\nmext_page_mkuptodate(struct folio *folio, unsigned from, unsigned to)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tsector_t block;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, block_start, block_end;\n\tint i, err,  nr = 0, partial = 0;\n\tBUG_ON(!folio_test_locked(folio));\n\tBUG_ON(folio_test_writeback(folio));\n\n\tif (folio_test_uptodate(folio))\n\t\treturn 0;\n\n\tblocksize = i_blocksize(inode);\n\thead = folio_buffers(folio);\n\tif (!head) {\n\t\tcreate_empty_buffers(&folio->page, blocksize, 0);\n\t\thead = folio_buffers(folio);\n\t}\n\n\tblock = (sector_t)folio->index << (PAGE_SHIFT - inode->i_blkbits);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\t\tif (!buffer_mapped(bh)) {\n\t\t\terr = ext4_get_block(inode, block, bh, 0);\n\t\t\tif (err) {\n\t\t\t\tfolio_set_error(folio);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tfolio_zero_range(folio, block_start, blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(nr >= MAX_BUF_PER_PAGE);\n\t\tarr[nr++] = bh;\n\t}\n\t \n\tif (!nr)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\terr = ext4_read_bh(bh, 0, NULL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tif (!partial)\n\t\tfolio_mark_uptodate(folio);\n\treturn 0;\n}\n\n \nstatic int\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\n\t\t     pgoff_t orig_page_offset, pgoff_t donor_page_offset,\n\t\t     int data_offset_in_page,\n\t\t     int block_len_in_page, int unwritten, int *err)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct folio *folio[2] = {NULL, NULL};\n\thandle_t *handle;\n\text4_lblk_t orig_blk_offset, donor_blk_offset;\n\tunsigned long blocksize = orig_inode->i_sb->s_blocksize;\n\tunsigned int tmp_data_size, data_size, replaced_size;\n\tint i, err2, jblocks, retries = 0;\n\tint replaced_count = 0;\n\tint from = data_offset_in_page << orig_inode->i_blkbits;\n\tint blocks_per_page = PAGE_SIZE >> orig_inode->i_blkbits;\n\tstruct super_block *sb = orig_inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\n\t \nagain:\n\t*err = 0;\n\tjblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\n\thandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\n\tif (IS_ERR(handle)) {\n\t\t*err = PTR_ERR(handle);\n\t\treturn 0;\n\t}\n\n\torig_blk_offset = orig_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\tdonor_blk_offset = donor_page_offset * blocks_per_page +\n\t\tdata_offset_in_page;\n\n\t \n\tif ((orig_blk_offset + block_len_in_page - 1) ==\n\t    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\n\t\t \n\t\ttmp_data_size = orig_inode->i_size & (blocksize - 1);\n\t\t \n\t\tif (tmp_data_size == 0)\n\t\t\ttmp_data_size = blocksize;\n\n\t\tdata_size = tmp_data_size +\n\t\t\t((block_len_in_page - 1) << orig_inode->i_blkbits);\n\t} else\n\t\tdata_size = block_len_in_page << orig_inode->i_blkbits;\n\n\treplaced_size = data_size;\n\n\t*err = mext_folio_double_lock(orig_inode, donor_inode, orig_page_offset,\n\t\t\t\t     donor_page_offset, folio);\n\tif (unlikely(*err < 0))\n\t\tgoto stop_journal;\n\t \n\n\tVM_BUG_ON_FOLIO(folio_test_large(folio[0]), folio[0]);\n\tVM_BUG_ON_FOLIO(folio_test_large(folio[1]), folio[1]);\n\tVM_BUG_ON_FOLIO(folio_nr_pages(folio[0]) != folio_nr_pages(folio[1]), folio[1]);\n\n\tif (unwritten) {\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\t \n\t\tunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\n\t\t\t\t\t\tblock_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\n\t\t\t\t\t\t block_len_in_page, 1, err);\n\t\tif (*err)\n\t\t\tgoto drop_data_sem;\n\n\t\tif (!unwritten) {\n\t\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t\tgoto data_copy;\n\t\t}\n\t\tif (!filemap_release_folio(folio[0], 0) ||\n\t\t    !filemap_release_folio(folio[1], 0)) {\n\t\t\t*err = -EBUSY;\n\t\t\tgoto drop_data_sem;\n\t\t}\n\t\treplaced_count = ext4_swap_extents(handle, orig_inode,\n\t\t\t\t\t\t   donor_inode, orig_blk_offset,\n\t\t\t\t\t\t   donor_blk_offset,\n\t\t\t\t\t\t   block_len_in_page, 1, err);\n\tdrop_data_sem:\n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\tgoto unlock_folios;\n\t}\ndata_copy:\n\t*err = mext_page_mkuptodate(folio[0], from, from + replaced_size);\n\tif (*err)\n\t\tgoto unlock_folios;\n\n\t \n\tif (!filemap_release_folio(folio[0], 0) ||\n\t    !filemap_release_folio(folio[1], 0)) {\n\t\t*err = -EBUSY;\n\t\tgoto unlock_folios;\n\t}\n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 1, err);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (*err) {\n\t\tif (replaced_count) {\n\t\t\tblock_len_in_page = replaced_count;\n\t\t\treplaced_size =\n\t\t\t\tblock_len_in_page << orig_inode->i_blkbits;\n\t\t} else\n\t\t\tgoto unlock_folios;\n\t}\n\t \n\tif (!folio_buffers(folio[0]))\n\t\tcreate_empty_buffers(&folio[0]->page, 1 << orig_inode->i_blkbits, 0);\n\tbh = folio_buffers(folio[0]);\n\tfor (i = 0; i < data_offset_in_page; i++)\n\t\tbh = bh->b_this_page;\n\tfor (i = 0; i < block_len_in_page; i++) {\n\t\t*err = ext4_get_block(orig_inode, orig_blk_offset + i, bh, 0);\n\t\tif (*err < 0)\n\t\t\tgoto repair_branches;\n\t\tbh = bh->b_this_page;\n\t}\n\n\tblock_commit_write(&folio[0]->page, from, from + replaced_size);\n\n\t \n\t*err = ext4_jbd2_inode_add_write(handle, orig_inode,\n\t\t\t(loff_t)orig_page_offset << PAGE_SHIFT, replaced_size);\n\nunlock_folios:\n\tfolio_unlock(folio[0]);\n\tfolio_put(folio[0]);\n\tfolio_unlock(folio[1]);\n\tfolio_put(folio[1]);\nstop_journal:\n\text4_journal_stop(handle);\n\tif (*err == -ENOSPC &&\n\t    ext4_should_retry_alloc(sb, &retries))\n\t\tgoto again;\n\t \n\tif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\n\t    jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\n\t\tgoto again;\n\treturn replaced_count;\n\nrepair_branches:\n\t \n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\treplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\n\t\t\t\t\t       orig_blk_offset, donor_blk_offset,\n\t\t\t\t\t   block_len_in_page, 0, &err2);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tif (replaced_count != block_len_in_page) {\n\t\text4_error_inode_block(orig_inode, (sector_t)(orig_blk_offset),\n\t\t\t\t       EIO, \"Unable to copy data block,\"\n\t\t\t\t       \" data will be lost.\");\n\t\t*err = -EIO;\n\t}\n\treplaced_count = 0;\n\tgoto unlock_folios;\n}\n\n \nstatic int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\t__u64 orig_eof, donor_eof;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\torig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\n\tdonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\n\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t \n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should not be swap files [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -ETXTBSY;\n\t}\n\n\tif (ext4_is_quota_file(orig_inode) && ext4_is_quota_file(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should not be quota files [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\n\t    (donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offsets are not aligned [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (donor_start + *len >= EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\tif (orig_eof <= orig_start)\n\t\t*len = 0;\n\telse if (orig_eof < orig_start + *len - 1)\n\t\t*len = orig_eof - orig_start;\n\tif (donor_eof <= donor_start)\n\t\t*len = 0;\n\telse if (donor_eof < donor_start + *len - 1)\n\t\t*len = donor_eof - donor_start;\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\n\t\t  __u64 donor_blk, __u64 len, __u64 *moved_len)\n{\n\tstruct inode *orig_inode = file_inode(o_filp);\n\tstruct inode *donor_inode = file_inode(d_filp);\n\tstruct ext4_ext_path *path = NULL;\n\tint blocks_per_page = PAGE_SIZE >> orig_inode->i_blkbits;\n\text4_lblk_t o_end, o_start = orig_blk;\n\text4_lblk_t d_start = donor_blk;\n\tint ret;\n\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (orig_inode == donor_inode) {\n\t\text4_debug(\"ext4 move extent: The argument files should not \"\n\t\t\t\"be same inode [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should be \"\n\t\t\t\"regular file [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ext4_should_journal_data(orig_inode) ||\n\t    ext4_should_journal_data(donor_inode)) {\n\t\text4_msg(orig_inode->i_sb, KERN_ERR,\n\t\t\t \"Online defrag not supported with data journaling\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (IS_ENCRYPTED(orig_inode) || IS_ENCRYPTED(donor_inode)) {\n\t\text4_msg(orig_inode->i_sb, KERN_ERR,\n\t\t\t \"Online defrag not supported for encrypted files\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tlock_two_nondirectories(orig_inode, donor_inode);\n\n\t \n\tinode_dio_wait(orig_inode);\n\tinode_dio_wait(donor_inode);\n\n\t \n\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t \n\tret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\n\t\t\t\t    donor_blk, &len);\n\tif (ret)\n\t\tgoto out;\n\to_end = o_start + len;\n\n\twhile (o_start < o_end) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t cur_blk, next_blk;\n\t\tpgoff_t orig_page_index, donor_page_index;\n\t\tint offset_in_page;\n\t\tint unwritten, cur_len;\n\n\t\tret = get_ext_path(orig_inode, o_start, &path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tex = path[path->p_depth].p_ext;\n\t\tcur_blk = le32_to_cpu(ex->ee_block);\n\t\tcur_len = ext4_ext_get_actual_len(ex);\n\t\t \n\t\tif (cur_blk + cur_len - 1 < o_start) {\n\t\t\tnext_blk = ext4_ext_next_allocated_block(path);\n\t\t\tif (next_blk == EXT_MAX_BLOCKS) {\n\t\t\t\tret = -ENODATA;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\td_start += next_blk - o_start;\n\t\t\to_start = next_blk;\n\t\t\tcontinue;\n\t\t \n\t\t} else if (cur_blk > o_start) {\n\t\t\t \n\t\t\td_start += cur_blk - o_start;\n\t\t\to_start = cur_blk;\n\t\t\t \n\t\t\tif (cur_blk >= o_end)\n\t\t\t\tgoto out;\n\t\t} else {  \n\t\t\tcur_len += cur_blk - o_start;\n\t\t}\n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tif (o_end - o_start < cur_len)\n\t\t\tcur_len = o_end - o_start;\n\n\t\torig_page_index = o_start >> (PAGE_SHIFT -\n\t\t\t\t\t       orig_inode->i_blkbits);\n\t\tdonor_page_index = d_start >> (PAGE_SHIFT -\n\t\t\t\t\t       donor_inode->i_blkbits);\n\t\toffset_in_page = o_start % blocks_per_page;\n\t\tif (cur_len > blocks_per_page - offset_in_page)\n\t\t\tcur_len = blocks_per_page - offset_in_page;\n\t\t \n\t\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\t\t \n\t\tmove_extent_per_page(o_filp, donor_inode,\n\t\t\t\t     orig_page_index, donor_page_index,\n\t\t\t\t     offset_in_page, cur_len,\n\t\t\t\t     unwritten, &ret);\n\t\text4_double_down_write_data_sem(orig_inode, donor_inode);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\to_start += cur_len;\n\t\td_start += cur_len;\n\t}\n\t*moved_len = o_start - orig_blk;\n\tif (*moved_len > len)\n\t\t*moved_len = len;\n\nout:\n\tif (*moved_len) {\n\t\text4_discard_preallocations(orig_inode, 0);\n\t\text4_discard_preallocations(donor_inode, 0);\n\t}\n\n\text4_free_ext_path(path);\n\text4_double_up_write_data_sem(orig_inode, donor_inode);\n\tunlock_two_nondirectories(orig_inode, donor_inode);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}