{
  "module_name": "balloc.c",
  "hash_id": "360e33fd5b4d8b0a0f8f9f0ff850d7c3178e41efd57bbe9b7ba5c540ae4aec39",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/balloc.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include \"mballoc.h\"\n\n#include <trace/events/ext4.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n \n\n \next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}\n\n \nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}\n\n \nstatic inline int ext4_block_in_group(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t block,\n\t\t\t\t      ext4_group_t block_group)\n{\n\text4_group_t actual_group;\n\n\tactual_group = ext4_get_group_number(sb, block);\n\treturn (actual_group == block_group) ? 1 : 0;\n}\n\n \nstatic unsigned ext4_num_overhead_clusters(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned base_clusters, num_clusters;\n\tint block_cluster = -1, inode_cluster;\n\tint itbl_cluster_start = -1, itbl_cluster_end = -1;\n\text4_fsblk_t start = ext4_group_first_block_no(sb, block_group);\n\text4_fsblk_t end = start + EXT4_BLOCKS_PER_GROUP(sb) - 1;\n\text4_fsblk_t itbl_blk_start, itbl_blk_end;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t \n\tbase_clusters = ext4_num_base_meta_clusters(sb, block_group);\n\tnum_clusters = base_clusters;\n\n\t \n\titbl_blk_start = ext4_inode_table(sb, gdp);\n\titbl_blk_end = itbl_blk_start + sbi->s_itb_per_group - 1;\n\tif (itbl_blk_start <= end && itbl_blk_end >= start) {\n\t\titbl_blk_start = itbl_blk_start >= start ?\n\t\t\titbl_blk_start : start;\n\t\titbl_blk_end = itbl_blk_end <= end ?\n\t\t\titbl_blk_end : end;\n\n\t\titbl_cluster_start = EXT4_B2C(sbi, itbl_blk_start - start);\n\t\titbl_cluster_end = EXT4_B2C(sbi, itbl_blk_end - start);\n\n\t\tnum_clusters += itbl_cluster_end - itbl_cluster_start + 1;\n\t\t \n\t\tif (itbl_cluster_start == base_clusters - 1)\n\t\t\tnum_clusters--;\n\t}\n\n\t \n\tif (ext4_block_in_group(sb, ext4_block_bitmap(sb, gdp), block_group)) {\n\t\tblock_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_block_bitmap(sb, gdp) - start);\n\t\tif (block_cluster >= base_clusters &&\n\t\t    (block_cluster < itbl_cluster_start ||\n\t\t    block_cluster > itbl_cluster_end))\n\t\t\tnum_clusters++;\n\t}\n\n\tif (ext4_block_in_group(sb, ext4_inode_bitmap(sb, gdp), block_group)) {\n\t\tinode_cluster = EXT4_B2C(sbi,\n\t\t\t\t\t ext4_inode_bitmap(sb, gdp) - start);\n\t\t \n\t\tif (inode_cluster != block_cluster &&\n\t\t    inode_cluster >= base_clusters &&\n\t\t    (inode_cluster < itbl_cluster_start ||\n\t\t    inode_cluster > itbl_cluster_end))\n\t\t\tnum_clusters++;\n\t}\n\n\treturn num_clusters;\n}\n\nstatic unsigned int num_clusters_in_group(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t block_group)\n{\n\tunsigned int blocks;\n\n\tif (block_group == ext4_get_groups_count(sb) - 1) {\n\t\t \n\t\tblocks = ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\t\text4_group_first_block_no(sb, block_group);\n\t} else\n\t\tblocks = EXT4_BLOCKS_PER_GROUP(sb);\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), blocks);\n}\n\n \nstatic int ext4_init_block_bitmap(struct super_block *sb,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_group_t block_group,\n\t\t\t\t   struct ext4_group_desc *gdp)\n{\n\tunsigned int bit, bit_max;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start, tmp;\n\n\tASSERT(buffer_locked(bh));\n\n\tif (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT |\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\n\tbit_max = ext4_num_base_meta_clusters(sb, block_group);\n\tif ((bit_max >> 3) >= bh->b_size)\n\t\treturn -EFSCORRUPTED;\n\n\tfor (bit = 0; bit < bit_max; bit++)\n\t\text4_set_bit(bit, bh->b_data);\n\n\tstart = ext4_group_first_block_no(sb, block_group);\n\n\t \n\ttmp = ext4_block_bitmap(sb, gdp);\n\tif (ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_bitmap(sb, gdp);\n\tif (ext4_block_in_group(sb, tmp, block_group))\n\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\n\ttmp = ext4_inode_table(sb, gdp);\n\tfor (; tmp < ext4_inode_table(sb, gdp) +\n\t\t     sbi->s_itb_per_group; tmp++) {\n\t\tif (ext4_block_in_group(sb, tmp, block_group))\n\t\t\text4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);\n\t}\n\n\t \n\text4_mark_bitmap_end(num_clusters_in_group(sb, block_group),\n\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\treturn 0;\n}\n\n \nunsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) -\n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}\n\n \n\n \nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh_p;\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tbh_p = sbi_array_rcu_deref(sbi, s_group_desc, group_desc);\n\t \n\tif (!bh_p) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)bh_p->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = bh_p;\n\treturn desc;\n}\n\nstatic ext4_fsblk_t ext4_valid_block_bitmap_padding(struct super_block *sb,\n\t\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_grpblk_t next_zero_bit;\n\tunsigned long bitmap_size = sb->s_blocksize * 8;\n\tunsigned int offset = num_clusters_in_group(sb, block_group);\n\n\tif (bitmap_size <= offset)\n\t\treturn 0;\n\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data, bitmap_size, offset);\n\n\treturn (next_zero_bit < bitmap_size ? next_zero_bit : 0);\n}\n\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\tstruct ext4_group_info **grp_info;\n\tlong indexv, indexh;\n\n\tif (unlikely(group >= EXT4_SB(sb)->s_groups_count))\n\t\treturn NULL;\n\tindexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\tindexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\tgrp_info = sbi_array_rcu_deref(EXT4_SB(sb), s_group_info, indexv);\n\treturn grp_info[indexh];\n}\n\n \nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_grpblk_t max_bit = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t \n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t \n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= max_bit ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t \n\t\treturn blk;\n\n\t \n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= max_bit ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t \n\t\treturn blk;\n\n\t \n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= max_bit ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group - 1) >= max_bit)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group - 1) + 1,\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group - 1) + 1)\n\t\t \n\t\treturn blk;\n\treturn 0;\n}\n\nstatic int ext4_validate_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *desc,\n\t\t\t\t      ext4_group_t block_group,\n\t\t\t\t      struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp;\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\tgrp = ext4_get_group_info(sb, block_group);\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\tif (!grp || EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\treturn -EFSCORRUPTED;\n\n\text4_lock_group(sb, block_group);\n\tif (buffer_verified(bh))\n\t\tgoto verified;\n\tif (unlikely(!ext4_block_bitmap_csum_verify(sb, desc, bh) ||\n\t\t     ext4_simulate_fail(sb, EXT4_SIM_BBITMAP_CRC))) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: bad block bitmap checksum\", block_group);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tblk = ext4_valid_block_bitmap(sb, desc, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: invalid block bitmap\",\n\t\t\t   block_group, blk);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tblk = ext4_valid_block_bitmap_padding(sb, block_group, bh);\n\tif (unlikely(blk != 0)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"bg %u: block %llu: padding at end of block bitmap is not set\",\n\t\t\t   block_group, blk);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\t\t EXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tset_buffer_verified(bh);\nverified:\n\text4_unlock_group(sb, block_group);\n\treturn 0;\n}\n\n \nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group,\n\t\t\t      bool ignore_locked)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid block bitmap block %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_warning(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t     \"block_group = %u, block_bitmap = %llu\",\n\t\t\t     block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (ignore_locked && buffer_locked(bh)) {\n\t\t \n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tif (block_group == 0) {\n\t\t\text4_unlock_group(sb, block_group);\n\t\t\tunlock_buffer(bh);\n\t\t\text4_error(sb, \"Block bitmap for bg 0 marked \"\n\t\t\t\t   \"uninitialized\");\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tif (err) {\n\t\t\text4_unlock_group(sb, block_group);\n\t\t\tunlock_buffer(bh);\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t \n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t \n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group, ignore_locked);\n\text4_read_bh_nowait(bh, REQ_META | REQ_PRIO |\n\t\t\t    (ignore_locked ? REQ_RAHEAD : 0),\n\t\t\t    ext4_end_bitmap_read);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n\n \nint ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn -EFSCORRUPTED;\n\twait_on_buffer(bh);\n\text4_simulate_fail_bh(sb, bh, EXT4_SIM_BBITMAP_EIO);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error_err(sb, EIO, \"Cannot read block bitmap - \"\n\t\t\t       \"block_group = %u, block_bitmap = %llu\",\n\t\t\t       block_group, (unsigned long long) bh->b_blocknr);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\treturn -EIO;\n\t}\n\tclear_buffer_new(bh);\n\t \n\treturn ext4_validate_block_bitmap(sb, desc, block_group, bh);\n}\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group, false);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\terr = ext4_wait_block_bitmap(sb, block_group, bh);\n\tif (err) {\n\t\tput_bh(bh);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn bh;\n}\n\n \nstatic int ext4_has_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t  s64 nclusters, unsigned int flags)\n{\n\ts64 free_clusters, dirty_clusters, rsv, resv_clusters;\n\tstruct percpu_counter *fcc = &sbi->s_freeclusters_counter;\n\tstruct percpu_counter *dcc = &sbi->s_dirtyclusters_counter;\n\n\tfree_clusters  = percpu_counter_read_positive(fcc);\n\tdirty_clusters = percpu_counter_read_positive(dcc);\n\tresv_clusters = atomic64_read(&sbi->s_resv_clusters);\n\n\t \n\trsv = (ext4_r_blocks_count(sbi->s_es) >> sbi->s_cluster_bits) +\n\t      resv_clusters;\n\n\tif (free_clusters - (nclusters + rsv + dirty_clusters) <\n\t\t\t\t\tEXT4_FREECLUSTERS_WATERMARK) {\n\t\tfree_clusters  = percpu_counter_sum_positive(fcc);\n\t\tdirty_clusters = percpu_counter_sum_positive(dcc);\n\t}\n\t \n\tif (free_clusters >= (rsv + nclusters + dirty_clusters))\n\t\treturn 1;\n\n\t \n\tif (uid_eq(sbi->s_resuid, current_fsuid()) ||\n\t    (!gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) && in_group_p(sbi->s_resgid)) ||\n\t    capable(CAP_SYS_RESOURCE) ||\n\t    (flags & EXT4_MB_USE_ROOT_BLOCKS)) {\n\n\t\tif (free_clusters >= (nclusters + dirty_clusters +\n\t\t\t\t      resv_clusters))\n\t\t\treturn 1;\n\t}\n\t \n\tif (flags & EXT4_MB_USE_RESERVED) {\n\t\tif (free_clusters >= (nclusters + dirty_clusters))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}\n\n \nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!sbi->s_journal)\n\t\treturn 0;\n\n\tif (++(*retries) > 3) {\n\t\tpercpu_counter_inc(&sbi->s_sra_exceeded_retry_limit);\n\t\treturn 0;\n\t}\n\n\t \n\tsmp_mb();\n\tif (sbi->s_mb_free_pending == 0) {\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\tatomic_inc(&sbi->s_retry_alloc_pending);\n\t\t\tflush_work(&sbi->s_discard_work);\n\t\t\tatomic_dec(&sbi->s_retry_alloc_pending);\n\t\t}\n\t\treturn ext4_has_free_clusters(sbi, 1, 0);\n\t}\n\n\t \n\text4_debug(\"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\t(void) jbd2_journal_force_commit_nested(sbi->s_journal);\n\treturn 1;\n}\n\n \next4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t \n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t \n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}\n\n \next4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\tbitmap_bh = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}\n\nstatic inline int test_root(ext4_group_t a, int b)\n{\n\twhile (1) {\n\t\tif (a < b)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn 1;\n\t\tif ((a % b) != 0)\n\t\t\treturn 0;\n\t\ta = a / b;\n\t}\n}\n\n \nint ext4_bg_has_super(struct super_block *sb, ext4_group_t group)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (group == 0)\n\t\treturn 1;\n\tif (ext4_has_feature_sparse_super2(sb)) {\n\t\tif (group == le32_to_cpu(es->s_backup_bgs[0]) ||\n\t\t    group == le32_to_cpu(es->s_backup_bgs[1]))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif ((group <= 1) || !ext4_has_feature_sparse_super(sb))\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\tif (test_root(group, 3) || (test_root(group, 5)) ||\n\t    test_root(group, 7))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned long ext4_bg_num_gdb_meta(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t first = metagroup * EXT4_DESC_PER_BLOCK(sb);\n\text4_group_t last = first + EXT4_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tif (!ext4_bg_has_super(sb, group))\n\t\treturn 0;\n\n\tif (ext4_has_feature_meta_bg(sb))\n\t\treturn le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\telse\n\t\treturn EXT4_SB(sb)->s_gdb_count;\n}\n\n \nunsigned long ext4_bg_num_gdb(struct super_block *sb, ext4_group_t group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT4_DESC_PER_BLOCK(sb);\n\n\tif (!ext4_has_feature_meta_bg(sb) || metagroup < first_meta_bg)\n\t\treturn ext4_bg_num_gdb_nometa(sb, group);\n\n\treturn ext4_bg_num_gdb_meta(sb,group);\n\n}\n\n \nunsigned int ext4_num_base_meta_blocks(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned num;\n\n\t \n\tnum = ext4_bg_has_super(sb, block_group);\n\n\tif (!ext4_has_feature_meta_bg(sb) ||\n\t    block_group < le32_to_cpu(sbi->s_es->s_first_meta_bg) *\n\t\t\t  sbi->s_desc_per_block) {\n\t\tif (num) {\n\t\t\tnum += ext4_bg_num_gdb_nometa(sb, block_group);\n\t\t\tnum += le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\t}\n\t} else {  \n\t\tnum += ext4_bg_num_gdb_meta(sb, block_group);\n\t}\n\treturn num;\n}\n\nstatic unsigned int ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t\text4_group_t block_group)\n{\n\treturn EXT4_NUM_B2C(EXT4_SB(sb), ext4_num_base_meta_blocks(sb, block_group));\n}\n\n \next4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_group_t block_group;\n\text4_grpblk_t colour;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));\n\text4_fsblk_t bg_start;\n\text4_fsblk_t last_block;\n\n\tblock_group = ei->i_block_group;\n\tif (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) {\n\t\t \n\t\tblock_group &= ~(flex_size-1);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tblock_group++;\n\t}\n\tbg_start = ext4_group_first_block_no(inode->i_sb, block_group);\n\tlast_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;\n\n\t \n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\treturn bg_start;\n\n\tif (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)\n\t\tcolour = (task_pid_nr(current) % 16) *\n\t\t\t(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\telse\n\t\tcolour = (task_pid_nr(current) % 16) *\n\t\t\t((last_block - bg_start) / 16);\n\treturn bg_start + colour;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}