{
  "module_name": "crypto.c",
  "hash_id": "3d67492582abbd8a40980b4a3adfbb88db04ebd07c894bb418fa5dbed88a0960",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/crypto.c",
  "human_readable_source": "\n\n#include <linux/quotaops.h>\n#include <linux/uuid.h>\n\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_fname_from_fscrypt_name(struct ext4_filename *dst,\n\t\t\t\t\t const struct fscrypt_name *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\n\tdst->usr_fname = src->usr_fname;\n\tdst->disk_name = src->disk_name;\n\tdst->hinfo.hash = src->hash;\n\tdst->hinfo.minor_hash = src->minor_hash;\n\tdst->crypto_buf = src->crypto_buf;\n}\n\nint ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_setup_filename(dir, iname, lookup, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\terr = ext4_fname_setup_ci_filename(dir, iname, fname);\n\tif (err)\n\t\text4_fname_free_filename(fname);\n#endif\n\treturn err;\n}\n\nint ext4_fname_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\tint err;\n\n\terr = fscrypt_prepare_lookup(dir, dentry, &name);\n\tif (err)\n\t\treturn err;\n\n\text4_fname_from_fscrypt_name(fname, &name);\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\terr = ext4_fname_setup_ci_filename(dir, &dentry->d_name, fname);\n\tif (err)\n\t\text4_fname_free_filename(fname);\n#endif\n\treturn err;\n}\n\nvoid ext4_fname_free_filename(struct ext4_filename *fname)\n{\n\tstruct fscrypt_name name;\n\n\tname.crypto_buf = fname->crypto_buf;\n\tfscrypt_free_filename(&name);\n\n\tfname->crypto_buf.name = NULL;\n\tfname->usr_fname = NULL;\n\tfname->disk_name.name = NULL;\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n\nstatic bool uuid_is_zero(__u8 u[16])\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (u[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint ext4_ioctl_get_encryption_pwsalt(struct file *filp, void __user *arg)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err, err2;\n\thandle_t *handle;\n\n\tif (!ext4_has_feature_encrypt(sb))\n\t\treturn -EOPNOTSUPP;\n\n\tif (uuid_is_zero(sbi->s_es->s_encrypt_pw_salt)) {\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto pwsalt_err_exit;\n\t\t}\n\t\terr = ext4_journal_get_write_access(handle, sb, sbi->s_sbh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err)\n\t\t\tgoto pwsalt_err_journal;\n\t\tlock_buffer(sbi->s_sbh);\n\t\tgenerate_random_uuid(sbi->s_es->s_encrypt_pw_salt);\n\t\text4_superblock_csum_set(sb);\n\t\tunlock_buffer(sbi->s_sbh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\npwsalt_err_journal:\n\t\terr2 = ext4_journal_stop(handle);\n\t\tif (err2 && !err)\n\t\t\terr = err2;\npwsalt_err_exit:\n\t\tmnt_drop_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(arg, sbi->s_es->s_encrypt_pw_salt, 16))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ext4_get_context(struct inode *inode, void *ctx, size_t len)\n{\n\treturn ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,\n\t\t\t\t EXT4_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len);\n}\n\nstatic int ext4_set_context(struct inode *inode, const void *ctx, size_t len,\n\t\t\t\t\t\t\tvoid *fs_data)\n{\n\thandle_t *handle = fs_data;\n\tint res, res2, credits, retries = 0;\n\n\t \n\tif (inode->i_ino == EXT4_ROOT_INO)\n\t\treturn -EPERM;\n\n\tif (WARN_ON_ONCE(IS_DAX(inode) && i_size_read(inode)))\n\t\treturn -EINVAL;\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_DAX))\n\t\treturn -EOPNOTSUPP;\n\n\tres = ext4_convert_inline_data(inode);\n\tif (res)\n\t\treturn res;\n\n\t \n\n\tif (handle) {\n\t\tres = ext4_xattr_set_handle(handle, inode,\n\t\t\t\t\t    EXT4_XATTR_INDEX_ENCRYPTION,\n\t\t\t\t\t    EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\t\t    ctx, len, 0);\n\t\tif (!res) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_ENCRYPT);\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\tEXT4_STATE_MAY_INLINE_DATA);\n\t\t\t \n\t\t\text4_set_inode_flags(inode, false);\n\t\t}\n\t\treturn res;\n\t}\n\n\tres = dquot_initialize(inode);\n\tif (res)\n\t\treturn res;\nretry:\n\tres = ext4_xattr_set_credits(inode, len, false  ,\n\t\t\t\t     &credits);\n\tif (res)\n\t\treturn res;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tres = ext4_xattr_set_handle(handle, inode, EXT4_XATTR_INDEX_ENCRYPTION,\n\t\t\t\t    EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\t    ctx, len, 0);\n\tif (!res) {\n\t\text4_set_inode_flag(inode, EXT4_INODE_ENCRYPT);\n\t\t \n\t\text4_set_inode_flags(inode, false);\n\t\tres = ext4_mark_inode_dirty(handle, inode);\n\t\tif (res)\n\t\t\tEXT4_ERROR_INODE(inode, \"Failed to mark inode dirty\");\n\t}\n\tres2 = ext4_journal_stop(handle);\n\n\tif (res == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\tif (!res)\n\t\tres = res2;\n\treturn res;\n}\n\nstatic const union fscrypt_policy *ext4_get_dummy_policy(struct super_block *sb)\n{\n\treturn EXT4_SB(sb)->s_dummy_enc_policy.policy;\n}\n\nstatic bool ext4_has_stable_inodes(struct super_block *sb)\n{\n\treturn ext4_has_feature_stable_inodes(sb);\n}\n\nstatic void ext4_get_ino_and_lblk_bits(struct super_block *sb,\n\t\t\t\t       int *ino_bits_ret, int *lblk_bits_ret)\n{\n\t*ino_bits_ret = 8 * sizeof(EXT4_SB(sb)->s_es->s_inodes_count);\n\t*lblk_bits_ret = 8 * sizeof(ext4_lblk_t);\n}\n\nconst struct fscrypt_operations ext4_cryptops = {\n\t.key_prefix\t\t= \"ext4:\",\n\t.get_context\t\t= ext4_get_context,\n\t.set_context\t\t= ext4_set_context,\n\t.get_dummy_policy\t= ext4_get_dummy_policy,\n\t.empty_dir\t\t= ext4_empty_dir,\n\t.has_stable_inodes\t= ext4_has_stable_inodes,\n\t.get_ino_and_lblk_bits\t= ext4_get_ino_and_lblk_bits,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}