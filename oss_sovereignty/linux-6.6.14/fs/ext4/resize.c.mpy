{
  "module_name": "resize.c",
  "hash_id": "2401d17364bbf7b0adfdc6833329b2564c965d082e3b2d65ddc20dc9e7cf00a1",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/resize.c",
  "human_readable_source": "\n \n\n\n#define EXT4FS_DEBUG\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n\n#include \"ext4_jbd2.h\"\n\nstruct ext4_rcu_ptr {\n\tstruct rcu_head rcu;\n\tvoid *ptr;\n};\n\nstatic void ext4_rcu_ptr_callback(struct rcu_head *head)\n{\n\tstruct ext4_rcu_ptr *ptr;\n\n\tptr = container_of(head, struct ext4_rcu_ptr, rcu);\n\tkvfree(ptr->ptr);\n\tkfree(ptr);\n}\n\nvoid ext4_kvfree_array_rcu(void *to_free)\n{\n\tstruct ext4_rcu_ptr *ptr = kzalloc(sizeof(*ptr), GFP_KERNEL);\n\n\tif (ptr) {\n\t\tptr->ptr = to_free;\n\t\tcall_rcu(&ptr->rcu, ext4_rcu_ptr_callback);\n\t\treturn;\n\t}\n\tsynchronize_rcu();\n\tkvfree(to_free);\n}\n\nint ext4_resize_begin(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\t \n\tif (EXT4_SB(sb)->s_es->s_reserved_gdt_blocks &&\n\t    !ext4_has_feature_resize_inode(sb)) {\n\t\text4_error(sb, \"resize_inode disabled but reserved GDT blocks non-zero\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (EXT4_B2C(sbi, sbi->s_sbh->b_blocknr) !=\n\t    le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) {\n\t\text4_warning(sb, \"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT4_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_has_feature_sparse_super2(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Online resizing not supported with sparse_super2\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_and_set_bit_lock(EXT4_FLAGS_RESIZING,\n\t\t\t\t  &EXT4_SB(sb)->s_ext4_flags))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\n\nint ext4_resize_end(struct super_block *sb, bool update_backups)\n{\n\tclear_bit_unlock(EXT4_FLAGS_RESIZING, &EXT4_SB(sb)->s_ext4_flags);\n\tsmp_mb__after_atomic();\n\tif (update_backups)\n\t\treturn ext4_update_overhead(sb, true);\n\treturn 0;\n}\n\nstatic ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\treturn (group >> EXT4_DESC_PER_BLOCK_BITS(sb)) <<\n\t       EXT4_DESC_PER_BLOCK_BITS(sb);\n}\n\nstatic ext4_fsblk_t ext4_meta_bg_first_block_no(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t group) {\n\tgroup = ext4_meta_bg_first_group(sb, group);\n\treturn ext4_group_first_block_no(sb, group);\n}\n\nstatic ext4_grpblk_t ext4_group_overhead_blocks(struct super_block *sb,\n\t\t\t\t\t\text4_group_t group) {\n\text4_grpblk_t overhead;\n\toverhead = ext4_bg_num_gdb(sb, group);\n\tif (ext4_bg_has_super(sb, group))\n\t\toverhead += 1 +\n\t\t\t  le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\treturn overhead;\n}\n\n#define outside(b, first, last)\t((b) < (first) || (b) >= (last))\n#define inside(b, first, last)\t((b) >= (first) && (b) < (last))\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t start = ext4_blocks_count(es);\n\text4_fsblk_t end = start + input->blocks_count;\n\text4_group_t group = input->group;\n\text4_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead;\n\text4_fsblk_t metaend;\n\tstruct buffer_head *bh = NULL;\n\text4_grpblk_t free_blocks_count, offset;\n\tint err = -EINVAL;\n\n\tif (group != sbi->s_groups_count) {\n\t\text4_warning(sb, \"Cannot add at group %u (only %u groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\t\treturn -EINVAL;\n\t}\n\n\toverhead = ext4_group_overhead_blocks(sb, group);\n\tmetaend = start + overhead;\n\tinput->free_clusters_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext4_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\text4_get_group_no_and_offset(sb, start, NULL, &offset);\n\tif (offset != 0)\n\t\t\text4_warning(sb, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text4_warning(sb, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text4_warning(sb, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (IS_ERR(bh = ext4_sb_bread(sb, end - 1, 0))) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\text4_warning(sb, \"Cannot read last block (%llu)\",\n\t\t\t     end - 1);\n\t} else if (outside(input->block_bitmap, start, end))\n\t\text4_warning(sb, \"Block bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text4_warning(sb, \"Inode bitmap not in group (block %llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t\t outside(itend - 1, start, end))\n\t\text4_warning(sb, \"Inode table not in group (blocks %llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text4_warning(sb, \"Block bitmap same as inode bitmap (%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in inode table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     (unsigned long long)input->inode_table, itend - 1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text4_warning(sb, \"Block bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->block_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text4_warning(sb, \"Inode bitmap (%llu) in GDT table (%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_bitmap,\n\t\t\t     start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t\t inside(itend - 1, start, metaend))\n\t\text4_warning(sb, \"Inode table (%llu-%llu) overlaps GDT table \"\n\t\t\t     \"(%llu-%llu)\",\n\t\t\t     (unsigned long long)input->inode_table,\n\t\t\t     itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}\n\n \nstruct ext4_new_flex_group_data {\n\tstruct ext4_new_group_data *groups;\t \n\t__u16 *bg_flags;\t\t\t \n\text4_group_t count;\t\t\t \n};\n\n \nstatic struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)\n{\n\tstruct ext4_new_flex_group_data *flex_gd;\n\n\tflex_gd = kmalloc(sizeof(*flex_gd), GFP_NOFS);\n\tif (flex_gd == NULL)\n\t\tgoto out3;\n\n\tif (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_group_data))\n\t\tgoto out2;\n\tflex_gd->count = flexbg_size;\n\n\tflex_gd->groups = kmalloc_array(flexbg_size,\n\t\t\t\t\tsizeof(struct ext4_new_group_data),\n\t\t\t\t\tGFP_NOFS);\n\tif (flex_gd->groups == NULL)\n\t\tgoto out2;\n\n\tflex_gd->bg_flags = kmalloc_array(flexbg_size, sizeof(__u16),\n\t\t\t\t\t  GFP_NOFS);\n\tif (flex_gd->bg_flags == NULL)\n\t\tgoto out1;\n\n\treturn flex_gd;\n\nout1:\n\tkfree(flex_gd->groups);\nout2:\n\tkfree(flex_gd);\nout3:\n\treturn NULL;\n}\n\nstatic void free_flex_gd(struct ext4_new_flex_group_data *flex_gd)\n{\n\tkfree(flex_gd->bg_flags);\n\tkfree(flex_gd->groups);\n\tkfree(flex_gd);\n}\n\n \nstatic int ext4_alloc_group_tables(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\t\tint flexbg_size)\n{\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t start_blk;\n\text4_fsblk_t last_blk;\n\text4_group_t src_group;\n\text4_group_t bb_index = 0;\n\text4_group_t ib_index = 0;\n\text4_group_t it_index = 0;\n\text4_group_t group;\n\text4_group_t last_group;\n\tunsigned overhead;\n\t__u16 uninit_mask = (flexbg_size > 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\n\tsrc_group = group_data[0].group;\n\tlast_group  = src_group + flex_gd->count - 1;\n\n\tBUG_ON((flexbg_size > 1) && ((src_group & ~(flexbg_size - 1)) !=\n\t       (last_group & ~(flexbg_size - 1))));\nnext_group:\n\tgroup = group_data[0].group;\n\tif (src_group >= group_data[0].group + flex_gd->count)\n\t\treturn -ENOSPC;\n\tstart_blk = ext4_group_first_block_no(sb, src_group);\n\tlast_blk = start_blk + group_data[src_group - group].blocks_count;\n\n\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\n\tstart_blk += overhead;\n\n\t \n\tsrc_group++;\n\tfor (; src_group <= last_group; src_group++) {\n\t\toverhead = ext4_group_overhead_blocks(sb, src_group);\n\t\tif (overhead == 0)\n\t\t\tlast_blk += group_data[src_group - group].blocks_count;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (; bb_index < flex_gd->count; bb_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[bb_index].block_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].mdata_blocks++;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t \n\tfor (; ib_index < flex_gd->count; ib_index++) {\n\t\tif (start_blk >= last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[ib_index].inode_bitmap = start_blk++;\n\t\tgroup = ext4_get_group_number(sb, start_blk - 1);\n\t\tgroup -= group_data[0].group;\n\t\tgroup_data[group].mdata_blocks++;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t}\n\n\t \n\tfor (; it_index < flex_gd->count; it_index++) {\n\t\tunsigned int itb = EXT4_SB(sb)->s_itb_per_group;\n\t\text4_fsblk_t next_group_start;\n\n\t\tif (start_blk + itb > last_blk)\n\t\t\tgoto next_group;\n\t\tgroup_data[it_index].inode_table = start_blk;\n\t\tgroup = ext4_get_group_number(sb, start_blk);\n\t\tnext_group_start = ext4_group_first_block_no(sb, group + 1);\n\t\tgroup -= group_data[0].group;\n\n\t\tif (start_blk + itb > next_group_start) {\n\t\t\tflex_gd->bg_flags[group + 1] &= uninit_mask;\n\t\t\toverhead = start_blk + itb - next_group_start;\n\t\t\tgroup_data[group + 1].mdata_blocks += overhead;\n\t\t\titb -= overhead;\n\t\t}\n\n\t\tgroup_data[group].mdata_blocks += itb;\n\t\tflex_gd->bg_flags[group] &= uninit_mask;\n\t\tstart_blk += EXT4_SB(sb)->s_itb_per_group;\n\t}\n\n\t \n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tgroup_data[i].free_clusters_count -=\n\t\t\t\tEXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t\t\t     group_data[i].mdata_blocks);\n\t}\n\n\tif (test_opt(sb, DEBUG)) {\n\t\tint i;\n\t\tgroup = group_data[0].group;\n\n\t\tprintk(KERN_DEBUG \"EXT4-fs: adding a flex group with \"\n\t\t       \"%d groups, flexbg size is %d:\\n\", flex_gd->count,\n\t\t       flexbg_size);\n\n\t\tfor (i = 0; i < flex_gd->count; i++) {\n\t\t\text4_debug(\n\t\t\t       \"adding %s group %u: %u blocks (%d free, %d mdata blocks)\\n\",\n\t\t\t       ext4_bg_has_super(sb, group + i) ? \"normal\" :\n\t\t\t       \"no-super\", group + i,\n\t\t\t       group_data[i].blocks_count,\n\t\t\t       group_data[i].free_clusters_count,\n\t\t\t       group_data[i].mdata_blocks);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext4_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, bh, EXT4_JTR_NONE);\n\tif (err) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\treturn bh;\n}\n\nstatic int ext4_resize_ensure_credits_batch(handle_t *handle, int credits)\n{\n\treturn ext4_journal_ensure_credits_fn(handle, credits,\n\t\tEXT4_MAX_TRANS_DATA, 0, 0);\n}\n\n \nstatic int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,\n\t\t\tstruct ext4_new_flex_group_data *flex_gd,\n\t\t\text4_fsblk_t first_cluster, ext4_fsblk_t last_cluster)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t count = last_cluster - first_cluster + 1;\n\text4_group_t count2;\n\n\text4_debug(\"mark clusters [%llu-%llu] used\\n\", first_cluster,\n\t\t   last_cluster);\n\tfor (count2 = count; count > 0;\n\t     count -= count2, first_cluster += count2) {\n\t\text4_fsblk_t start;\n\t\tstruct buffer_head *bh;\n\t\text4_group_t group;\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, EXT4_C2B(sbi, first_cluster));\n\t\tstart = EXT4_B2C(sbi, ext4_group_first_block_no(sb, group));\n\t\tgroup -= flex_gd->groups[0].group;\n\n\t\tcount2 = EXT4_CLUSTERS_PER_GROUP(sb) - (first_cluster - start);\n\t\tif (count2 > count)\n\t\t\tcount2 = count;\n\n\t\tif (flex_gd->bg_flags[group] & EXT4_BG_BLOCK_UNINIT) {\n\t\t\tBUG_ON(flex_gd->count > 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbh = sb_getblk(sb, flex_gd->groups[group].block_bitmap);\n\t\tif (unlikely(!bh))\n\t\t\treturn -ENOMEM;\n\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sb, bh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\text4_debug(\"mark block bitmap %#04llx (+%llu/%u)\\n\",\n\t\t\t   first_cluster, first_cluster - start, count2);\n\t\tmb_set_bits(bh->b_data, first_cluster - start, count2);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int setup_new_flex_group_blocks(struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tint group_table_count[] = {1, 1, EXT4_SB(sb)->s_itb_per_group};\n\text4_fsblk_t start;\n\text4_fsblk_t block;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\t__u16 *bg_flags = flex_gd->bg_flags;\n\thandle_t *handle;\n\text4_group_t group, count;\n\tstruct buffer_head *bh = NULL;\n\tint reserved_gdb, i, j, err = 0, err2;\n\tint meta_bg;\n\n\tBUG_ON(!flex_gd->count || !group_data ||\n\t       group_data[0].group != sbi->s_groups_count);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\n\t \n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tgroup = group_data[0].group;\n\tfor (i = 0; i < flex_gd->count; i++, group++) {\n\t\tunsigned long gdblocks;\n\t\text4_grpblk_t overhead;\n\n\t\tgdblocks = ext4_bg_num_gdb(sb, group);\n\t\tstart = ext4_group_first_block_no(sb, group);\n\n\t\tif (meta_bg == 0 && !ext4_bg_has_super(sb, group))\n\t\t\tgoto handle_itb;\n\n\t\tif (meta_bg == 1)\n\t\t\tgoto handle_itb;\n\n\t\tblock = start + ext4_bg_has_super(sb, group);\n\t\t \n\t\tfor (j = 0; j < gdblocks; j++, block++) {\n\t\t\tstruct buffer_head *gdb;\n\n\t\t\text4_debug(\"update backup group %#04llx\\n\", block);\n\t\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tgdb = sb_getblk(sb, block);\n\t\t\tif (unlikely(!gdb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUFFER_TRACE(gdb, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, sb, gdb,\n\t\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\t\tif (err) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gdb->b_data, sbi_array_rcu_deref(sbi,\n\t\t\t\ts_group_desc, j)->b_data, gdb->b_size);\n\t\t\tset_buffer_uptodate(gdb);\n\n\t\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(gdb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbrelse(gdb);\n\t\t}\n\n\t\t \n\t\tif (ext4_bg_has_super(sb, group)) {\n\t\t\terr = sb_issue_zeroout(sb, gdblocks + start + 1,\n\t\t\t\t\treserved_gdb, GFP_NOFS);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\nhandle_itb:\n\t\t \n\t\tif (!(bg_flags[i] & EXT4_BG_INODE_ZEROED))\n\t\t\tgoto handle_bb;\n\n\t\t \n\t\tblock = group_data[i].inode_table;\n\t\text4_debug(\"clear inode table blocks %#04llx -> %#04lx\\n\",\n\t\t\t   block, sbi->s_itb_per_group);\n\t\terr = sb_issue_zeroout(sb, block, sbi->s_itb_per_group,\n\t\t\t\t       GFP_NOFS);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_bb:\n\t\tif (bg_flags[i] & EXT4_BG_BLOCK_UNINIT)\n\t\t\tgoto handle_ib;\n\n\t\t \n\t\tblock = group_data[i].block_bitmap;\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tgoto out;\n\t\t}\n\t\toverhead = ext4_group_overhead_blocks(sb, group);\n\t\tif (overhead != 0) {\n\t\t\text4_debug(\"mark backup superblock %#04llx (+0)\\n\",\n\t\t\t\t   start);\n\t\t\tmb_set_bits(bh->b_data, 0,\n\t\t\t\t      EXT4_NUM_B2C(sbi, overhead));\n\t\t}\n\t\text4_mark_bitmap_end(EXT4_B2C(sbi, group_data[i].blocks_count),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tgoto out;\n\nhandle_ib:\n\t\tif (bg_flags[i] & EXT4_BG_INODE_UNINIT)\n\t\t\tcontinue;\n\n\t\t \n\t\tblock = group_data[i].inode_bitmap;\n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\t \n\t\tbh = bclean(handle, sb, block);\n\t\tif (IS_ERR(bh)) {\n\t\t\terr = PTR_ERR(bh);\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (j = 0; j < GROUP_TABLE_COUNT; j++) {\n\t\tcount = group_table_count[j];\n\t\tstart = (&group_data[0].block_bitmap)[j];\n\t\tblock = start;\n\t\tfor (i = 1; i < flex_gd->count; i++) {\n\t\t\tblock += group_table_count[j];\n\t\t\tif (block == (&group_data[i].block_bitmap)[j]) {\n\t\t\t\tcount += group_table_count[j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\t      flex_gd,\n\t\t\t\t\t\t      EXT4_B2C(sbi, start),\n\t\t\t\t\t\t      EXT4_B2C(sbi,\n\t\t\t\t\t\t\t       start + count\n\t\t\t\t\t\t\t       - 1));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tcount = group_table_count[j];\n\t\t\tstart = (&group_data[i].block_bitmap)[j];\n\t\t\tblock = start;\n\t\t}\n\n\t\tif (count) {\n\t\t\terr = set_flexbg_block_bitmap(sb, handle,\n\t\t\t\t\t\t      flex_gd,\n\t\t\t\t\t\t      EXT4_B2C(sbi, start),\n\t\t\t\t\t\t      EXT4_B2C(sbi,\n\t\t\t\t\t\t\t       start + count\n\t\t\t\t\t\t\t       - 1));\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\treturn err;\n}\n\n \nunsigned int ext4_list_backups(struct super_block *sb, unsigned int *three,\n\t\t\t       unsigned int *five, unsigned int *seven)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned int *min = three;\n\tint mult = 3;\n\tunsigned int ret;\n\n\tif (ext4_has_feature_sparse_super2(sb)) {\n\t\tdo {\n\t\t\tif (*min > 2)\n\t\t\t\treturn UINT_MAX;\n\t\t\tret = le32_to_cpu(es->s_backup_bgs[*min - 1]);\n\t\t\t*min += 1;\n\t\t} while (!ret);\n\t\treturn ret;\n\t}\n\n\tif (!ext4_has_feature_sparse_super(sb)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}\n\n \nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       ext4_group_t end,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext4_fsblk_t blk = primary->b_blocknr;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext4_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) !=\n\t\t    grp * EXT4_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text4_warning(sb, \"reserved GDT %llu\"\n\t\t\t\t     \" missing grp %d (%llu)\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp *\n\t\t\t\t     (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\t     blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT4_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}\n\n \nstatic int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\text4_fsblk_t gdblock = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc = NULL;\n\tstruct buffer_head *dind = NULL;\n\tstruct buffer_head *gdb_bh = NULL;\n\tint gdbackups;\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT4-fs: ext4_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\tgdb_bh = ext4_sb_bread(sb, gdblock, 0);\n\tif (IS_ERR(gdb_bh))\n\t\treturn PTR_ERR(gdb_bh);\n\n\tgdbackups = verify_reserved_gdb(sb, group, gdb_bh);\n\tif (gdbackups < 0) {\n\t\terr = gdbackups;\n\t\tgoto errout;\n\t}\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = ext4_sb_bread(sb, le32_to_cpu(*data), 0);\n\tif (IS_ERR(dind)) {\n\t\terr = PTR_ERR(dind);\n\t\tdind = NULL;\n\t\tgoto errout;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT4_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text4_warning(sb, \"new group %u GDT block %llu not reserved\",\n\t\t\t     group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, EXT4_SB(sb)->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, gdb_bh, EXT4_JTR_NONE);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tBUFFER_TRACE(dind, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, dind, EXT4_JTR_NONE);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\t \n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (unlikely(err))\n\t\tgoto errout;\n\n\tn_group_desc = kvmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\tgoto errout;\n\t}\n\n\t \n\tdata[gdb_num % EXT4_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext4_handle_dirty_metadata(handle, NULL, dind);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >>\n\t\t\t   (9 - EXT4_SB(sb)->s_cluster_bits);\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\tmemset(gdb_bh->b_data, 0, sb->s_blocksize);\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\tif (unlikely(err)) {\n\t\text4_std_error(sb, err);\n\t\tiloc.bh = NULL;\n\t\tgoto errout;\n\t}\n\tbrelse(dind);\n\n\trcu_read_lock();\n\to_group_desc = rcu_dereference(EXT4_SB(sb)->s_group_desc);\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\trcu_read_unlock();\n\tn_group_desc[gdb_num] = gdb_bh;\n\trcu_assign_pointer(EXT4_SB(sb)->s_group_desc, n_group_desc);\n\tEXT4_SB(sb)->s_gdb_count++;\n\text4_kvfree_array_rcu(o_group_desc);\n\n\tlock_buffer(EXT4_SB(sb)->s_sbh);\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(EXT4_SB(sb)->s_sbh);\n\terr = ext4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);\n\tif (err)\n\t\text4_std_error(sb, err);\n\treturn err;\nerrout:\n\tkvfree(n_group_desc);\n\tbrelse(iloc.bh);\n\tbrelse(dind);\n\tbrelse(gdb_bh);\n\n\text4_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}\n\n \nstatic int add_new_gdb_meta_bg(struct super_block *sb,\n\t\t\t       handle_t *handle, ext4_group_t group) {\n\text4_fsblk_t gdblock;\n\tstruct buffer_head *gdb_bh;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tunsigned long gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\tint err;\n\n\tgdblock = ext4_meta_bg_first_block_no(sb, group) +\n\t\t   ext4_bg_has_super(sb, group);\n\tgdb_bh = ext4_sb_bread(sb, gdblock, 0);\n\tif (IS_ERR(gdb_bh))\n\t\treturn PTR_ERR(gdb_bh);\n\tn_group_desc = kvmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\t\tGFP_KERNEL);\n\tif (!n_group_desc) {\n\t\tbrelse(gdb_bh);\n\t\terr = -ENOMEM;\n\t\text4_warning(sb, \"not enough memory for %lu groups\",\n\t\t\t     gdb_num + 1);\n\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\to_group_desc = rcu_dereference(EXT4_SB(sb)->s_group_desc);\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT4_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\trcu_read_unlock();\n\tn_group_desc[gdb_num] = gdb_bh;\n\n\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, gdb_bh, EXT4_JTR_NONE);\n\tif (err) {\n\t\tkvfree(n_group_desc);\n\t\tbrelse(gdb_bh);\n\t\treturn err;\n\t}\n\n\trcu_assign_pointer(EXT4_SB(sb)->s_group_desc, n_group_desc);\n\tEXT4_SB(sb)->s_gdb_count++;\n\text4_kvfree_array_rcu(o_group_desc);\n\treturn err;\n}\n\n \nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_group_t group)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT4_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tint cluster_bits = EXT4_SB(sb)->s_cluster_bits;\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext4_iloc iloc;\n\text4_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc_array(reserved_gdb, sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT4_I(inode)->i_data + EXT4_DIND_BLOCK;\n\tdind = ext4_sb_bread(sb, le32_to_cpu(*data), 0);\n\tif (IS_ERR(dind)) {\n\t\terr = PTR_ERR(dind);\n\t\tdind = NULL;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT4_SB(sb)->s_sbh->b_blocknr + 1 + EXT4_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT4_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT4_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT4_ADDR_PER_BLOCK(sb);\n\n\t \n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text4_warning(sb, \"reserved block %llu\"\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = ext4_sb_bread(sb, blk, 0);\n\t\tif (IS_ERR(primary[res])) {\n\t\t\terr = PTR_ERR(primary[res]);\n\t\t\tprimary[res] = NULL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tgdbackups = verify_reserved_gdb(sb, group, primary[res]);\n\t\tif (gdbackups < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tBUFFER_TRACE(primary[i], \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, sb, primary[i],\n\t\t\t\t\t\t\t EXT4_JTR_NONE)))\n\t\t\tgoto exit_bh;\n\t}\n\n\tif ((err = ext4_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t \n\tblk = group * EXT4_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t \n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext4_handle_dirty_metadata(handle, NULL, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> (9 - cluster_bits);\n\text4_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}\n\nstatic inline void ext4_set_block_group_nr(struct super_block *sb, char *data,\n\t\t\t\t\t   ext4_group_t group)\n{\n\tstruct ext4_super_block *es = (struct ext4_super_block *) data;\n\n\tes->s_block_group_nr = cpu_to_le16(group);\n\tif (ext4_has_metadata_csum(sb))\n\t\tes->s_checksum = ext4_superblock_csum(sb, es);\n}\n\n \nstatic void update_backups(struct super_block *sb, sector_t blk_off, char *data,\n\t\t\t   int size, int meta_bg)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t last;\n\tconst int bpg = EXT4_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\text4_group_t group = 0;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, EXT4_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\tif (meta_bg == 0) {\n\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\tlast = sbi->s_groups_count;\n\t} else {\n\t\tgroup = ext4_get_group_number(sb, blk_off) + 1;\n\t\tlast = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);\n\t}\n\n\twhile (group < sbi->s_groups_count) {\n\t\tstruct buffer_head *bh;\n\t\text4_fsblk_t backup_block;\n\t\tint has_super = ext4_bg_has_super(sb, group);\n\t\text4_fsblk_t first_block = ext4_group_first_block_no(sb, group);\n\n\t\t \n\t\terr = ext4_resize_ensure_credits_batch(handle, 1);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (meta_bg == 0)\n\t\t\tbackup_block = ((ext4_fsblk_t)group) * bpg + blk_off;\n\t\telse\n\t\t\tbackup_block = first_block + has_super;\n\n\t\tbh = sb_getblk(sb, backup_block);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text4_debug(\"update metadata backup %llu(+%llu)\\n\",\n\t\t\t   backup_block, backup_block -\n\t\t\t   ext4_group_first_block_no(sb, group));\n\t\tBUFFER_TRACE(bh, \"get_write_access\");\n\t\tif ((err = ext4_journal_get_write_access(handle, sb, bh,\n\t\t\t\t\t\t\t EXT4_JTR_NONE))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tif (has_super && (backup_block == first_block))\n\t\t\text4_set_block_group_nr(sb, bh->b_data, group);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (unlikely(err))\n\t\t\text4_std_error(sb, err);\n\t\tbrelse(bh);\n\n\t\tif (meta_bg == 0)\n\t\t\tgroup = ext4_list_backups(sb, &three, &five, &seven);\n\t\telse if (group == last)\n\t\t\tbreak;\n\t\telse\n\t\t\tgroup = last;\n\t}\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t \nexit_err:\n\tif (err) {\n\t\text4_warning(sb, \"can't update backup for group %u (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT4_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}\n\n \nstatic int ext4_add_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t      ext4_group_t group, struct inode *resize_inode,\n\t\t\t      ext4_group_t count)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *gdb_bh;\n\tint i, gdb_off, gdb_num, err = 0;\n\tint meta_bg;\n\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\tfor (i = 0; i < count; i++, group++) {\n\t\tint reserved_gdb = ext4_bg_has_super(sb, group) ?\n\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t \n\t\tif (gdb_off) {\n\t\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc,\n\t\t\t\t\t\t     gdb_num);\n\t\t\tBUFFER_TRACE(gdb_bh, \"get_write_access\");\n\t\t\terr = ext4_journal_get_write_access(handle, sb, gdb_bh,\n\t\t\t\t\t\t\t    EXT4_JTR_NONE);\n\n\t\t\tif (!err && reserved_gdb && ext4_bg_num_gdb(sb, group))\n\t\t\t\terr = reserve_backup_gdb(handle, resize_inode, group);\n\t\t} else if (meta_bg != 0) {\n\t\t\terr = add_new_gdb_meta_bg(sb, handle, group);\n\t\t} else {\n\t\t\terr = add_new_gdb(handle, resize_inode, group);\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic struct buffer_head *ext4_get_bitmap(struct super_block *sb, __u64 block)\n{\n\tstruct buffer_head *bh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\tif (ext4_read_bh(bh, 0, NULL) < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn bh;\n}\n\nstatic int ext4_set_bitmap_checksums(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *gdp,\n\t\t\t\t     struct ext4_new_group_data *group_data)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 0;\n\n\tbh = ext4_get_bitmap(sb, group_data->inode_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_inode_bitmap_csum_set(sb, gdp, bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\tbrelse(bh);\n\n\tbh = ext4_get_bitmap(sb, group_data->block_bitmap);\n\tif (!bh)\n\t\treturn -EIO;\n\text4_block_bitmap_csum_set(sb, gdp, bh);\n\tbrelse(bh);\n\n\treturn 0;\n}\n\n \nstatic int ext4_setup_new_descs(handle_t *handle, struct super_block *sb,\n\t\t\t\tstruct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_new_group_data\t*group_data = flex_gd->groups;\n\tstruct ext4_group_desc\t\t*gdp;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tstruct buffer_head\t\t*gdb_bh;\n\text4_group_t\t\t\tgroup;\n\t__u16\t\t\t\t*bg_flags = flex_gd->bg_flags;\n\tint\t\t\t\ti, gdb_off, gdb_num, err = 0;\n\n\n\tfor (i = 0; i < flex_gd->count; i++, group_data++, bg_flags++) {\n\t\tgroup = group_data->group;\n\n\t\tgdb_off = group % EXT4_DESC_PER_BLOCK(sb);\n\t\tgdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\n\t\t \n\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc, gdb_num);\n\t\t \n\t\tgdp = (struct ext4_group_desc *)(gdb_bh->b_data +\n\t\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\t\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n\t\text4_block_bitmap_set(sb, gdp, group_data->block_bitmap);\n\t\text4_inode_bitmap_set(sb, gdp, group_data->inode_bitmap);\n\t\terr = ext4_set_bitmap_checksums(sb, gdp, group_data);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_inode_table_set(sb, gdp, group_data->inode_table);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     group_data->free_clusters_count);\n\t\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t       EXT4_INODES_PER_GROUP(sb));\n\t\tgdp->bg_flags = cpu_to_le16(*bg_flags);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, gdb_bh);\n\t\tif (unlikely(err)) {\n\t\t\text4_std_error(sb, err);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = ext4_mb_add_groupinfo(sb, group, gdp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic void ext4_add_overhead(struct super_block *sb,\n                              const ext4_fsblk_t overhead)\n{\n       struct ext4_sb_info *sbi = EXT4_SB(sb);\n       struct ext4_super_block *es = sbi->s_es;\n\n       sbi->s_overhead += overhead;\n       es->s_overhead_clusters = cpu_to_le32(sbi->s_overhead);\n       smp_wmb();\n}\n\n \nstatic void ext4_update_super(struct super_block *sb,\n\t\t\t     struct ext4_new_flex_group_data *flex_gd)\n{\n\text4_fsblk_t blocks_count = 0;\n\text4_fsblk_t free_blocks = 0;\n\text4_fsblk_t reserved_blocks = 0;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i;\n\n\tBUG_ON(flex_gd->count == 0 || group_data == NULL);\n\t \n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tblocks_count += group_data[i].blocks_count;\n\t\tfree_blocks += EXT4_C2B(sbi, group_data[i].free_clusters_count);\n\t}\n\n\treserved_blocks = ext4_r_blocks_count(es) * 100;\n\treserved_blocks = div64_u64(reserved_blocks, ext4_blocks_count(es));\n\treserved_blocks *= blocks_count;\n\tdo_div(reserved_blocks, 100);\n\n\tlock_buffer(sbi->s_sbh);\n\text4_blocks_count_set(es, ext4_blocks_count(es) + blocks_count);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + free_blocks);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\tle32_add_cpu(&es->s_free_inodes_count, EXT4_INODES_PER_GROUP(sb) *\n\t\t     flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\", ext4_free_blocks_count(es));\n\t \n\tsmp_wmb();\n\n\t \n\tsbi->s_groups_count += flex_gd->count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\n\t \n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\t\t\treserved_blocks);\n\n\t \n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, free_blocks));\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb) * flex_gd->count);\n\n\text4_debug(\"free blocks count %llu\",\n\t\t   percpu_counter_read(&sbi->s_freeclusters_counter));\n\tif (ext4_has_feature_flex_bg(sb) && sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group;\n\t\tstruct flex_groups *fg;\n\n\t\tflex_group = ext4_flex_group(sbi, group_data[0].group);\n\t\tfg = sbi_array_rcu_deref(sbi, s_flex_groups, flex_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, free_blocks),\n\t\t\t     &fg->free_clusters);\n\t\tatomic_add(EXT4_INODES_PER_GROUP(sb) * flex_gd->count,\n\t\t\t   &fg->free_inodes);\n\t}\n\n\t \n\tif (ext4_has_feature_bigalloc(sb) && (sbi->s_overhead != 0))\n\t\text4_add_overhead(sb,\n\t\t\tEXT4_NUM_B2C(sbi, blocks_count - free_blocks));\n\telse\n\t\text4_calculate_overhead(sb);\n\tes->s_overhead_clusters = cpu_to_le32(sbi->s_overhead);\n\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbi->s_sbh);\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT4-fs: added group %u:\"\n\t\t       \"%llu blocks(%llu free %llu reserved)\\n\", flex_gd->count,\n\t\t       blocks_count, free_blocks, reserved_blocks);\n}\n\n \nstatic int ext4_flex_group_add(struct super_block *sb,\n\t\t\t       struct inode *resize_inode,\n\t\t\t       struct ext4_new_flex_group_data *flex_gd)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_group_t group;\n\thandle_t *handle;\n\tunsigned reserved_gdb;\n\tint err = 0, err2 = 0, credit;\n\n\tBUG_ON(!flex_gd->count || !flex_gd->groups || !flex_gd->bg_flags);\n\n\treserved_gdb = le16_to_cpu(es->s_reserved_gdt_blocks);\n\to_blocks_count = ext4_blocks_count(es);\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\n\terr = setup_new_flex_group_blocks(sb, flex_gd);\n\tif (err)\n\t\tgoto exit;\n\t \n\tcredit = 3;\t \n\t \n\tcredit += 1 + DIV_ROUND_UP(flex_gd->count, EXT4_DESC_PER_BLOCK(sb));\n\tcredit += reserved_gdb;\t \n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credit);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, sbi->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto exit_journal;\n\n\tgroup = flex_gd->groups[0].group;\n\tBUG_ON(group != sbi->s_groups_count);\n\terr = ext4_add_new_descs(handle, sb, group,\n\t\t\t\tresize_inode, flex_gd->count);\n\tif (err)\n\t\tgoto exit_journal;\n\n\terr = ext4_setup_new_descs(handle, sb, flex_gd);\n\tif (err)\n\t\tgoto exit_journal;\n\n\text4_update_super(sb, flex_gd);\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\nexit_journal:\n\terr2 = ext4_journal_stop(handle);\n\tif (!err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tint gdb_num = group / EXT4_DESC_PER_BLOCK(sb);\n\t\tint gdb_num_end = ((group + flex_gd->count - 1) /\n\t\t\t\t   EXT4_DESC_PER_BLOCK(sb));\n\t\tint meta_bg = ext4_has_feature_meta_bg(sb);\n\t\tsector_t padding_blocks = meta_bg ? 0 : sbi->s_sbh->b_blocknr -\n\t\t\t\t\t ext4_group_first_block_no(sb, 0);\n\t\tsector_t old_gdb = 0;\n\n\t\tupdate_backups(sb, ext4_group_first_block_no(sb, 0),\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t\tfor (; gdb_num <= gdb_num_end; gdb_num++) {\n\t\t\tstruct buffer_head *gdb_bh;\n\n\t\t\tgdb_bh = sbi_array_rcu_deref(sbi, s_group_desc,\n\t\t\t\t\t\t     gdb_num);\n\t\t\tif (old_gdb == gdb_bh->b_blocknr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backups(sb, gdb_bh->b_blocknr - padding_blocks,\n\t\t\t\t       gdb_bh->b_data, gdb_bh->b_size, meta_bg);\n\t\t\told_gdb = gdb_bh->b_blocknr;\n\t\t}\n\t}\nexit:\n\treturn err;\n}\n\nstatic int ext4_setup_next_flex_gd(struct super_block *sb,\n\t\t\t\t    struct ext4_new_flex_group_data *flex_gd,\n\t\t\t\t    ext4_fsblk_t n_blocks_count,\n\t\t\t\t    unsigned long flexbg_size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_new_group_data *group_data = flex_gd->groups;\n\text4_fsblk_t o_blocks_count;\n\text4_group_t n_group;\n\text4_group_t group;\n\text4_group_t last_group;\n\text4_grpblk_t last;\n\text4_grpblk_t clusters_per_group;\n\tunsigned long i;\n\n\tclusters_per_group = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (o_blocks_count == n_blocks_count)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\tBUG_ON(last);\n\text4_get_group_no_and_offset(sb, n_blocks_count - 1, &n_group, &last);\n\n\tlast_group = group | (flexbg_size - 1);\n\tif (last_group > n_group)\n\t\tlast_group = n_group;\n\n\tflex_gd->count = last_group - group + 1;\n\n\tfor (i = 0; i < flex_gd->count; i++) {\n\t\tint overhead;\n\n\t\tgroup_data[i].group = group + i;\n\t\tgroup_data[i].blocks_count = EXT4_BLOCKS_PER_GROUP(sb);\n\t\toverhead = ext4_group_overhead_blocks(sb, group + i);\n\t\tgroup_data[i].mdata_blocks = overhead;\n\t\tgroup_data[i].free_clusters_count = EXT4_CLUSTERS_PER_GROUP(sb);\n\t\tif (ext4_has_group_desc_csum(sb)) {\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_BLOCK_UNINIT |\n\t\t\t\t\t       EXT4_BG_INODE_UNINIT;\n\t\t\tif (!test_opt(sb, INIT_INODE_TABLE))\n\t\t\t\tflex_gd->bg_flags[i] |= EXT4_BG_INODE_ZEROED;\n\t\t} else\n\t\t\tflex_gd->bg_flags[i] = EXT4_BG_INODE_ZEROED;\n\t}\n\n\tif (last_group == n_group && ext4_has_group_desc_csum(sb))\n\t\t \n\t\tflex_gd->bg_flags[i - 1] &= ~EXT4_BG_BLOCK_UNINIT;\n\n\tif ((last_group == n_group) && (last != clusters_per_group - 1)) {\n\t\tgroup_data[i - 1].blocks_count = EXT4_C2B(sbi, last + 1);\n\t\tgroup_data[i - 1].free_clusters_count -= clusters_per_group -\n\t\t\t\t\t\t       last - 1;\n\t}\n\n\treturn 1;\n}\n\n \nint ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off;\n\tint err;\n\t__u16 bg_flags = 0;\n\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !ext4_has_feature_sparse_super(sb)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!ext4_has_feature_resize_inode(sb) ||\n\t\t    !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO, EXT4_IGET_SPECIAL);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, input->group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n}  \n\n \nstatic int ext4_group_extend_no_check(struct super_block *sb,\n\t\t\t\t      ext4_fsblk_t o_blocks_count, ext4_grpblk_t add)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\t \n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text4_warning(sb, \"error %d on journal start\", err);\n\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, EXT4_SB(sb)->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err) {\n\t\text4_warning(sb, \"error %d on journal write access\", err);\n\t\tgoto errout;\n\t}\n\n\tlock_buffer(EXT4_SB(sb)->s_sbh);\n\text4_blocks_count_set(es, o_blocks_count + add);\n\text4_free_blocks_count_set(es, ext4_free_blocks_count(es) + add);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(EXT4_SB(sb)->s_sbh);\n\text4_debug(\"freeing blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\n\t \n\terr = ext4_group_add_blocks(handle, sb, o_blocks_count, add);\n\tif (err)\n\t\tgoto errout;\n\text4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);\n\text4_debug(\"freed blocks %llu through %llu\\n\", o_blocks_count,\n\t\t   o_blocks_count + add);\nerrout:\n\terr2 = ext4_journal_stop(handle);\n\tif (err2 && !err)\n\t\terr = err2;\n\n\tif (!err) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: extended group to %llu \"\n\t\t\t       \"blocks\\n\", ext4_blocks_count(es));\n\t\tupdate_backups(sb, ext4_group_first_block_no(sb, 0),\n\t\t\t       (char *)es, sizeof(struct ext4_super_block), 0);\n\t}\n\treturn err;\n}\n\n \nint ext4_group_extend(struct super_block *sb, struct ext4_super_block *es,\n\t\t      ext4_fsblk_t n_blocks_count)\n{\n\text4_fsblk_t o_blocks_count;\n\text4_grpblk_t last;\n\text4_grpblk_t add;\n\tstruct buffer_head *bh;\n\text4_group_t group;\n\n\to_blocks_count = ext4_blocks_count(es);\n\n\tif (test_opt(sb, DEBUG))\n\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t \"extending last group from %llu to %llu blocks\",\n\t\t\t o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"filesystem too large to resize to %llu blocks safely\",\n\t\t\t n_blocks_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\text4_get_group_no_and_offset(sb, o_blocks_count, &group, &last);\n\n\tif (last == 0) {\n\t\text4_warning(sb, \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT4_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text4_warning(sb, \"will only finish group (%llu blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t \n\tbh = ext4_sb_bread(sb, o_blocks_count + add - 1, 0);\n\tif (IS_ERR(bh)) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\treturn ext4_group_extend_no_check(sb, o_blocks_count, add);\n}  \n\n\nstatic int num_desc_blocks(struct super_block *sb, ext4_group_t groups)\n{\n\treturn (groups + EXT4_DESC_PER_BLOCK(sb) - 1) / EXT4_DESC_PER_BLOCK(sb);\n}\n\n \nstatic int ext4_convert_meta_bg(struct super_block *sb, struct inode *inode)\n{\n\thandle_t *handle;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_fsblk_t nr;\n\tint i, ret, err = 0;\n\tint credits = 1;\n\n\text4_msg(sb, KERN_INFO, \"Converting file system to meta_bg\");\n\tif (inode) {\n\t\tif (es->s_reserved_gdt_blocks) {\n\t\t\text4_error(sb, \"Unexpected non-zero \"\n\t\t\t\t   \"s_reserved_gdt_blocks\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t \n\t\tif (inode->i_blocks != 1 << (inode->i_blkbits -\n\t\t\t\t\t     (9 - sbi->s_cluster_bits)))\n\t\t\tgoto invalid_resize_inode;\n\t\tfor (i = 0; i < EXT4_N_BLOCKS; i++) {\n\t\t\tif (i == EXT4_DIND_BLOCK) {\n\t\t\t\tif (ei->i_data[i])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tgoto invalid_resize_inode;\n\t\t\t}\n\t\t\tif (ei->i_data[i])\n\t\t\t\tgoto invalid_resize_inode;\n\t\t}\n\t\tcredits += 3;\t \n\t}\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_RESIZE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, sbi->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto errout;\n\n\tlock_buffer(sbi->s_sbh);\n\text4_clear_feature_resize_inode(sb);\n\text4_set_feature_meta_bg(sb);\n\tsbi->s_es->s_first_meta_bg =\n\t\tcpu_to_le32(num_desc_blocks(sb, sbi->s_groups_count));\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(sbi->s_sbh);\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto errout;\n\t}\n\n\tif (inode) {\n\t\tnr = le32_to_cpu(ei->i_data[EXT4_DIND_BLOCK]);\n\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\tei->i_data[EXT4_DIND_BLOCK] = 0;\n\t\tinode->i_blocks = 0;\n\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (err)\n\t\t\text4_std_error(sb, err);\n\t}\n\nerrout:\n\tret = ext4_journal_stop(handle);\n\treturn err ? err : ret;\n\ninvalid_resize_inode:\n\text4_error(sb, \"corrupted/inconsistent resize inode\");\n\treturn -EINVAL;\n}\n\n \nint ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)\n{\n\tstruct ext4_new_flex_group_data *flex_gd = NULL;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tstruct buffer_head *bh;\n\tstruct inode *resize_inode = NULL;\n\text4_grpblk_t add, offset;\n\tunsigned long n_desc_blocks;\n\tunsigned long o_desc_blocks;\n\text4_group_t o_group;\n\text4_group_t n_group;\n\text4_fsblk_t o_blocks_count;\n\text4_fsblk_t n_blocks_count_retry = 0;\n\tunsigned long last_update_time = 0;\n\tint err = 0, flexbg_size = 1 << sbi->s_log_groups_per_flex;\n\tint meta_bg;\n\n\t \n\tbh = ext4_sb_bread(sb, n_blocks_count - 1, 0);\n\tif (IS_ERR(bh)) {\n\t\text4_warning(sb, \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t \n\tif (ext4_has_feature_bigalloc(sb))\n\t\tn_blocks_count &= ~((1 << EXT4_CLUSTER_BITS(sb)) - 1);\n\nretry:\n\to_blocks_count = ext4_blocks_count(es);\n\n\text4_msg(sb, KERN_INFO, \"resizing filesystem from %llu \"\n\t\t \"to %llu blocks\", o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\t \n\t\text4_warning(sb, \"can't shrink FS - resize aborted\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count == o_blocks_count)\n\t\t \n\t\treturn 0;\n\n\tn_group = ext4_get_group_number(sb, n_blocks_count - 1);\n\tif (n_group >= (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {\n\t\text4_warning(sb, \"resize would cause inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\text4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset);\n\n\tn_desc_blocks = num_desc_blocks(sb, n_group + 1);\n\to_desc_blocks = num_desc_blocks(sb, sbi->s_groups_count);\n\n\tmeta_bg = ext4_has_feature_meta_bg(sb);\n\n\tif (ext4_has_feature_resize_inode(sb)) {\n\t\tif (meta_bg) {\n\t\t\text4_error(sb, \"resize_inode and meta_bg enabled \"\n\t\t\t\t   \"simultaneously\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (n_desc_blocks > o_desc_blocks +\n\t\t    le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\tn_blocks_count_retry = n_blocks_count;\n\t\t\tn_desc_blocks = o_desc_blocks +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\t\t\tn_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);\n\t\t\tn_blocks_count = (ext4_fsblk_t)n_group *\n\t\t\t\tEXT4_BLOCKS_PER_GROUP(sb) +\n\t\t\t\tle32_to_cpu(es->s_first_data_block);\n\t\t\tn_group--;  \n\t\t}\n\n\t\tif (!resize_inode)\n\t\t\tresize_inode = ext4_iget(sb, EXT4_RESIZE_INO,\n\t\t\t\t\t\t EXT4_IGET_SPECIAL);\n\t\tif (IS_ERR(resize_inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(resize_inode);\n\t\t}\n\t}\n\n\tif ((!resize_inode && !meta_bg) || n_blocks_count == o_blocks_count) {\n\t\terr = ext4_convert_meta_bg(sb, resize_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tif (n_blocks_count_retry) {\n\t\t\tn_blocks_count = n_blocks_count_retry;\n\t\t\tn_blocks_count_retry = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t \n\tif ((ext4_group_first_block_no(sb, n_group) +\n\t     ext4_group_overhead_blocks(sb, n_group) + 2 +\n\t     sbi->s_itb_per_group + sbi->s_cluster_ratio) >= n_blocks_count) {\n\t\tn_blocks_count = ext4_group_first_block_no(sb, n_group);\n\t\tn_group--;\n\t\tn_blocks_count_retry = 0;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tgoto retry;\n\t}\n\n\t \n\tif (n_group == o_group)\n\t\tadd = n_blocks_count - o_blocks_count;\n\telse\n\t\tadd = EXT4_C2B(sbi, EXT4_CLUSTERS_PER_GROUP(sb) - (offset + 1));\n\tif (add > 0) {\n\t\terr = ext4_group_extend_no_check(sb, o_blocks_count, add);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ext4_blocks_count(es) == n_blocks_count && n_blocks_count_retry == 0)\n\t\tgoto out;\n\n\terr = ext4_alloc_flex_bg_array(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_mb_alloc_groupinfo(sb, n_group + 1);\n\tif (err)\n\t\tgoto out;\n\n\tflex_gd = alloc_flex_gd(flexbg_size);\n\tif (flex_gd == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\twhile (ext4_setup_next_flex_gd(sb, flex_gd, n_blocks_count,\n\t\t\t\t\t      flexbg_size)) {\n\t\tif (time_is_before_jiffies(last_update_time + HZ * 10)) {\n\t\t\tif (last_update_time)\n\t\t\t\text4_msg(sb, KERN_INFO,\n\t\t\t\t\t \"resized to %llu blocks\",\n\t\t\t\t\t ext4_blocks_count(es));\n\t\t\tlast_update_time = jiffies;\n\t\t}\n\t\tif (ext4_alloc_group_tables(sb, flex_gd, flexbg_size) != 0)\n\t\t\tbreak;\n\t\terr = ext4_flex_group_add(sb, resize_inode, flex_gd);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tif (!err && n_blocks_count_retry) {\n\t\tn_blocks_count = n_blocks_count_retry;\n\t\tn_blocks_count_retry = 0;\n\t\tfree_flex_gd(flex_gd);\n\t\tflex_gd = NULL;\n\t\tif (resize_inode) {\n\t\t\tiput(resize_inode);\n\t\t\tresize_inode = NULL;\n\t\t}\n\t\tgoto retry;\n\t}\n\nout:\n\tif (flex_gd)\n\t\tfree_flex_gd(flex_gd);\n\tif (resize_inode != NULL)\n\t\tiput(resize_inode);\n\tif (err)\n\t\text4_warning(sb, \"error (%d) occurred during \"\n\t\t\t     \"file system resize\", err);\n\text4_msg(sb, KERN_INFO, \"resized filesystem to %llu\",\n\t\t ext4_blocks_count(es));\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}