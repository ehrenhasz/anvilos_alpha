{
  "module_name": "dir.c",
  "hash_id": "719ac7d8de7fe9b589564138dffbd051ab6781e9ebd9747db5339a3d585e5568",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/dir.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/iversion.h>\n#include <linux/unicode.h>\n#include \"ext4.h\"\n#include \"xattr.h\"\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\n \nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (ext4_has_feature_dir_index(inode->i_sb) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool is_fake_dir_entry(struct ext4_dir_entry_2 *de)\n{\n\t \n\tif ((de->name_len > 0) && (de->name_len <= 2) && (de->name[0] == '.') &&\n\t    (de->name[1] == '.' || de->name[1] == '\\0'))\n\t\treturn true;\n\t \n\tif (de->file_type == EXT4_FT_DIR_CSUM)\n\t\treturn true;\n\treturn false;\n}\n\n \nint __ext4_check_dir_entry(const char *function, unsigned int line,\n\t\t\t   struct inode *dir, struct file *filp,\n\t\t\t   struct ext4_dir_entry_2 *de,\n\t\t\t   struct buffer_head *bh, char *buf, int size,\n\t\t\t   unsigned int offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\tconst int next_offset = ((char *) de - buf) + rlen;\n\tbool fake = is_fake_dir_entry(de);\n\tbool has_csum = ext4_has_metadata_csum(dir->i_sb);\n\n\tif (unlikely(rlen < ext4_dir_rec_len(1, fake ? NULL : dir)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < ext4_dir_rec_len(de->name_len,\n\t\t\t\t\t\t\tfake ? NULL : dir)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(next_offset > size))\n\t\terror_msg = \"directory entry overrun\";\n\telse if (unlikely(next_offset > size - ext4_dir_rec_len(1,\n\t\t\t\t\t\t  has_csum ? NULL : dir) &&\n\t\t\t  next_offset != size))\n\t\terror_msg = \"directory entry too close to block end\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT4_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\telse\n\t\treturn 0;\n\n\tif (filp)\n\t\text4_error_file(filp, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u, \"\n\t\t\t\t\"inode=%u, rec_len=%d, size=%d fake=%d\",\n\t\t\t\terror_msg, offset, le32_to_cpu(de->inode),\n\t\t\t\trlen, size, fake);\n\telse\n\t\text4_error_inode(dir, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u, \"\n\t\t\t\t\"inode=%u, rec_len=%d, size=%d fake=%d\",\n\t\t\t\t error_msg, offset, le32_to_cpu(de->inode),\n\t\t\t\t rlen, size, fake);\n\n\treturn 1;\n}\n\nstatic int ext4_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned int offset;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct fscrypt_str fstr = FSTR_INIT(NULL, 0);\n\n\terr = fscrypt_prepare_readdir(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext4_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!ext4_has_metadata_csum(sb)) {\n\t\t\t \n\t\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_read_inline_dir(file, ctx,\n\t\t\t\t\t   &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = fscrypt_fname_alloc_buffer(EXT4_NAME_LEN, &fstr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tstruct ext4_map_blocks map;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto errout;\n\t\t}\n\t\tcond_resched();\n\t\toffset = ctx->pos & (sb->s_blocksize - 1);\n\t\tmap.m_lblk = ctx->pos >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\tmap.m_len = 1;\n\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (err == 0) {\n\t\t\t \n\t\t\tif (map.m_len == 0)\n\t\t\t\tmap.m_len = 1;\n\t\t\tctx->pos += map.m_len * sb->s_blocksize;\n\t\t\tcontinue;\n\t\t}\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map.m_pblk >>\n\t\t\t\t\t(PAGE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_SHIFT;\n\t\t\tbh = ext4_bread(NULL, inode, map.m_lblk, 0);\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\terr = PTR_ERR(bh);\n\t\t\t\tbh = NULL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (!bh) {\n\t\t\t \n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n\t\t\t\tbreak;\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!buffer_verified(bh) &&\n\t\t    !ext4_dirblock_csum_verify(inode, bh)) {\n\t\t\tEXT4_ERROR_FILE(file, 0, \"directory fails checksum \"\n\t\t\t\t\t\"at offset %llu\",\n\t\t\t\t\t(unsigned long long)ctx->pos);\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tset_buffer_verified(bh);\n\n\t\t \n\t\tif (!inode_eq_iversion(inode, file->f_version)) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t(bh->b_data + i);\n\t\t\t\t \n\t\t\t\tif (ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize) < ext4_dir_rec_len(1,\n\t\t\t\t\t\t\t\t\tinode))\n\t\t\t\t\tbreak;\n\t\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t    sb->s_blocksize);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\tfile->f_version = inode_query_iversion(inode);\n\t\t}\n\n\t\twhile (ctx->pos < inode->i_size\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ext4_dir_entry_2 *) (bh->b_data + offset);\n\t\t\tif (ext4_check_dir_entry(inode, file, de, bh,\n\t\t\t\t\t\t bh->b_data, bh->b_size,\n\t\t\t\t\t\t offset)) {\n\t\t\t\t \n\t\t\t\tctx->pos = (ctx->pos |\n\t\t\t\t\t\t(sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize);\n\t\t\tif (le32_to_cpu(de->inode)) {\n\t\t\t\tif (!IS_ENCRYPTED(inode)) {\n\t\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t    de->name_len,\n\t\t\t\t\t    le32_to_cpu(de->inode),\n\t\t\t\t\t    get_dtype(sb, de->file_type)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t} else {\n\t\t\t\t\tint save_len = fstr.len;\n\t\t\t\t\tstruct fscrypt_str de_name =\n\t\t\t\t\t\t\tFSTR_INIT(de->name,\n\t\t\t\t\t\t\t\tde->name_len);\n\n\t\t\t\t\t \n\t\t\t\t\terr = fscrypt_fname_disk_to_usr(inode,\n\t\t\t\t\t\tEXT4_DIRENT_HASH(de),\n\t\t\t\t\t\tEXT4_DIRENT_MINOR_HASH(de),\n\t\t\t\t\t\t&de_name, &fstr);\n\t\t\t\t\tde_name = fstr;\n\t\t\t\t\tfstr.len = save_len;\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tif (!dir_emit(ctx,\n\t\t\t\t\t    de_name.name, de_name.len,\n\t\t\t\t\t    le32_to_cpu(de->inode),\n\t\t\t\t\t    get_dtype(sb, de->file_type)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tsb->s_blocksize);\n\t\t}\n\t\tif ((ctx->pos < inode->i_size) && !dir_relax_shared(inode))\n\t\t\tgoto done;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\ndone:\n\terr = 0;\nerrout:\n\tfscrypt_fname_free_buffer(&fstr);\n\tbrelse(bh);\n\treturn err;\n}\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn in_compat_syscall();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}\n\n \nstatic inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}\n\n \nstatic inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}\n\n\n \nstatic loff_t ext4_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint dx_dir = is_dx_dir(inode);\n\tloff_t ret, htree_max = ext4_get_htree_eof(file);\n\n\tif (likely(dx_dir))\n\t\tret = generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\t    htree_max, htree_max);\n\telse\n\t\tret = ext4_llseek(file, offset, whence);\n\tfile->f_version = inode_peek_iversion(inode) - 1;\n\treturn ret;\n}\n\n \nstruct fname {\n\t__u32\t\thash;\n\t__u32\t\tminor_hash;\n\tstruct rb_node\trb_hash;\n\tstruct fname\t*next;\n\t__u32\t\tinode;\n\t__u8\t\tname_len;\n\t__u8\t\tfile_type;\n\tchar\t\tname[];\n};\n\n \nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}\n\n\nstatic struct dir_private_info *ext4_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}\n\nvoid ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}\n\n \nint ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t    struct ext4_dir_entry_2 *dirent,\n\t\t\t    struct fscrypt_str *ent_name)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t \n\tlen = sizeof(struct fname) + ent_name->len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = ent_name->len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, ent_name->name, ent_name->len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t \n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse  \n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}\n\n\n\n \nstatic int call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\", __func__, __LINE__,\n\t\t\t inode->i_ino, current->comm);\n\t\treturn 0;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name,\n\t\t\t\tfname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn 1;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint ret = 0;\n\n\tif (!info) {\n\t\tinfo = ext4_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext4_get_htree_eof(file))\n\t\treturn 0;\t \n\n\t \n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t \n\tif (info->extra_fname) {\n\t\tif (call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t \n\t\tif ((!info->curr_node) ||\n\t\t    !inode_eq_iversion(inode, file->f_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode_query_iversion(inode);\n\t\t\tret = ext4_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto finished;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int ext4_release_dir(struct inode *inode, struct file *filp)\n{\n\tif (filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}\n\nint ext4_check_all_de(struct inode *dir, struct buffer_head *bh, void *buf,\n\t\t      int buf_size)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tint rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = buf;\n\ttop = buf + buf_size;\n\twhile ((char *) de < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EFSCORRUPTED;\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\nconst struct file_operations ext4_dir_operations = {\n\t.llseek\t\t= ext4_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= ext4_readdir,\n\t.unlocked_ioctl = ext4_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ext4_compat_ioctl,\n#endif\n\t.fsync\t\t= ext4_sync_file,\n\t.release\t= ext4_release_dir,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}