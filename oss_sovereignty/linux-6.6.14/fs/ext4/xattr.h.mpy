{
  "module_name": "xattr.h",
  "hash_id": "4f582375f03c41c47f02b3ba8348c8059a12e42fd8010ea79f0fec8eb51dcd7e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/xattr.h",
  "human_readable_source": "\n \n\n#include <linux/xattr.h>\n\n \n#define EXT4_XATTR_MAGIC\t\t0xEA020000\n\n \n#define EXT4_XATTR_REFCOUNT_MAX\t\t1024\n\n \n#define EXT4_XATTR_INDEX_USER\t\t\t1\n#define EXT4_XATTR_INDEX_POSIX_ACL_ACCESS\t2\n#define EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT\t3\n#define EXT4_XATTR_INDEX_TRUSTED\t\t4\n#define\tEXT4_XATTR_INDEX_LUSTRE\t\t\t5\n#define EXT4_XATTR_INDEX_SECURITY\t        6\n#define EXT4_XATTR_INDEX_SYSTEM\t\t\t7\n#define EXT4_XATTR_INDEX_RICHACL\t\t8\n#define EXT4_XATTR_INDEX_ENCRYPTION\t\t9\n#define EXT4_XATTR_INDEX_HURD\t\t\t10  \n\nstruct ext4_xattr_header {\n\t__le32\th_magic;\t \n\t__le32\th_refcount;\t \n\t__le32\th_blocks;\t \n\t__le32\th_hash;\t\t \n\t__le32\th_checksum;\t \n\t\t\t\t \n\t__u32\th_reserved[3];\t \n};\n\nstruct ext4_xattr_ibody_header {\n\t__le32\th_magic;\t \n};\n\nstruct ext4_xattr_entry {\n\t__u8\te_name_len;\t \n\t__u8\te_name_index;\t \n\t__le16\te_value_offs;\t \n\t__le32\te_value_inum;\t \n\t__le32\te_value_size;\t \n\t__le32\te_hash;\t\t \n\tchar\te_name[];\t \n};\n\n#define EXT4_XATTR_PAD_BITS\t\t2\n#define EXT4_XATTR_PAD\t\t(1<<EXT4_XATTR_PAD_BITS)\n#define EXT4_XATTR_ROUND\t\t(EXT4_XATTR_PAD-1)\n#define EXT4_XATTR_LEN(name_len) \\\n\t(((name_len) + EXT4_XATTR_ROUND + \\\n\tsizeof(struct ext4_xattr_entry)) & ~EXT4_XATTR_ROUND)\n#define EXT4_XATTR_NEXT(entry) \\\n\t((struct ext4_xattr_entry *)( \\\n\t (char *)(entry) + EXT4_XATTR_LEN((entry)->e_name_len)))\n#define EXT4_XATTR_SIZE(size) \\\n\t(((size) + EXT4_XATTR_ROUND) & ~EXT4_XATTR_ROUND)\n\n#define IHDR(inode, raw_inode) \\\n\t((struct ext4_xattr_ibody_header *) \\\n\t\t((void *)raw_inode + \\\n\t\tEXT4_GOOD_OLD_INODE_SIZE + \\\n\t\tEXT4_I(inode)->i_extra_isize))\n#define IFIRST(hdr) ((struct ext4_xattr_entry *)((hdr)+1))\n\n \n#define EXT4_XATTR_SIZE_MAX (1 << 24)\n\n \n#define EXT4_XATTR_MIN_LARGE_EA_SIZE(b)\t\t\t\t\t\\\n\t((b) - EXT4_XATTR_LEN(3) - sizeof(struct ext4_xattr_header) - 4)\n\n#define BHDR(bh) ((struct ext4_xattr_header *)((bh)->b_data))\n#define ENTRY(ptr) ((struct ext4_xattr_entry *)(ptr))\n#define BFIRST(bh) ENTRY(BHDR(bh)+1)\n#define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)\n\n#define EXT4_ZERO_XATTR_VALUE ((void *)-1)\n\n \n#define EXT4_INODE_HAS_XATTR_SPACE(inode)\t\t\t\t\\\n\t((EXT4_I(inode)->i_extra_isize != 0) &&\t\t\t\t\\\n\t (EXT4_GOOD_OLD_INODE_SIZE + EXT4_I(inode)->i_extra_isize +\t\\\n\t  sizeof(struct ext4_xattr_ibody_header) + EXT4_XATTR_PAD <=\t\\\n\t  EXT4_INODE_SIZE((inode)->i_sb)))\n\nstruct ext4_xattr_info {\n\tconst char *name;\n\tconst void *value;\n\tsize_t value_len;\n\tint name_index;\n\tint in_inode;\n};\n\nstruct ext4_xattr_search {\n\tstruct ext4_xattr_entry *first;\n\tvoid *base;\n\tvoid *end;\n\tstruct ext4_xattr_entry *here;\n\tint not_found;\n};\n\nstruct ext4_xattr_ibody_find {\n\tstruct ext4_xattr_search s;\n\tstruct ext4_iloc iloc;\n};\n\nstruct ext4_xattr_inode_array {\n\tunsigned int count;\t\t \n\tstruct inode *inodes[];\n};\n\nextern const struct xattr_handler ext4_xattr_user_handler;\nextern const struct xattr_handler ext4_xattr_trusted_handler;\nextern const struct xattr_handler ext4_xattr_security_handler;\nextern const struct xattr_handler ext4_xattr_hurd_handler;\n\n#define EXT4_XATTR_NAME_ENCRYPTION_CONTEXT \"c\"\n\n \nstatic inline void ext4_write_lock_xattr(struct inode *inode, int *save)\n{\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\t*save = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n}\n\nstatic inline int ext4_write_trylock_xattr(struct inode *inode, int *save)\n{\n\tif (down_write_trylock(&EXT4_I(inode)->xattr_sem) == 0)\n\t\treturn 0;\n\t*save = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\treturn 1;\n}\n\nstatic inline void ext4_write_unlock_xattr(struct inode *inode, int *save)\n{\n\tif (*save == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n}\n\nextern ssize_t ext4_listxattr(struct dentry *, char *, size_t);\n\nextern int ext4_xattr_get(struct inode *, int, const char *, void *, size_t);\nextern int ext4_xattr_set(struct inode *, int, const char *, const void *, size_t, int);\nextern int ext4_xattr_set_handle(handle_t *, struct inode *, int, const char *, const void *, size_t, int);\nextern int ext4_xattr_set_credits(struct inode *inode, size_t value_len,\n\t\t\t\t  bool is_create, int *credits);\nextern int __ext4_xattr_set_credits(struct super_block *sb, struct inode *inode,\n\t\t\t\tstruct buffer_head *block_bh, size_t value_len,\n\t\t\t\tbool is_create);\n\nextern int ext4_xattr_delete_inode(handle_t *handle, struct inode *inode,\n\t\t\t\t   struct ext4_xattr_inode_array **array,\n\t\t\t\t   int extra_credits);\nextern void ext4_xattr_inode_array_free(struct ext4_xattr_inode_array *array);\n\nextern int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t    struct ext4_inode *raw_inode, handle_t *handle);\nextern void ext4_evict_ea_inode(struct inode *inode);\n\nextern const struct xattr_handler *ext4_xattr_handlers[];\n\nextern int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t\t struct ext4_xattr_ibody_find *is);\nextern int ext4_xattr_ibody_get(struct inode *inode, int name_index,\n\t\t\t\tconst char *name,\n\t\t\t\tvoid *buffer, size_t buffer_size);\nextern int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is);\n\nextern struct mb_cache *ext4_xattr_create_cache(void);\nextern void ext4_xattr_destroy_cache(struct mb_cache *);\n\n#ifdef CONFIG_EXT4_FS_SECURITY\nextern int ext4_init_security(handle_t *handle, struct inode *inode,\n\t\t\t      struct inode *dir, const struct qstr *qstr);\n#else\nstatic inline int ext4_init_security(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_LOCKDEP\nextern void ext4_xattr_inode_set_class(struct inode *ea_inode);\n#else\nstatic inline void ext4_xattr_inode_set_class(struct inode *ea_inode) { }\n#endif\n\nextern int ext4_get_inode_usage(struct inode *inode, qsize_t *usage);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}