{
  "module_name": "hash.c",
  "hash_id": "db9b415ef78c3299ef4c31c319e6cd56b161ef29f924a5821ee48b5470617774",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/hash.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/unicode.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include \"ext4.h\"\n\n#define DELTA 0x9E3779B9\n\nstatic void TEA_transform(__u32 buf[4], __u32 const in[])\n{\n\t__u32\tsum = 0;\n\t__u32\tb0 = buf[0], b1 = buf[1];\n\t__u32\ta = in[0], b = in[1], c = in[2], d = in[3];\n\tint\tn = 16;\n\n\tdo {\n\t\tsum += DELTA;\n\t\tb0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);\n\t\tb1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);\n\t} while (--n);\n\n\tbuf[0] += b0;\n\tbuf[1] += b1;\n}\n\n \n#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))\n#define G(x, y, z) (((x) & (y)) + (((x) ^ (y)) & (z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n\n \n#define ROUND(f, a, b, c, d, x, s)\t\\\n\t(a += f(b, c, d) + x, a = rol32(a, s))\n#define K1 0\n#define K2 013240474631UL\n#define K3 015666365641UL\n\n \nstatic __u32 half_md4_transform(__u32 buf[4], __u32 const in[8])\n{\n\t__u32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];\n\n\t \n\tROUND(F, a, b, c, d, in[0] + K1,  3);\n\tROUND(F, d, a, b, c, in[1] + K1,  7);\n\tROUND(F, c, d, a, b, in[2] + K1, 11);\n\tROUND(F, b, c, d, a, in[3] + K1, 19);\n\tROUND(F, a, b, c, d, in[4] + K1,  3);\n\tROUND(F, d, a, b, c, in[5] + K1,  7);\n\tROUND(F, c, d, a, b, in[6] + K1, 11);\n\tROUND(F, b, c, d, a, in[7] + K1, 19);\n\n\t \n\tROUND(G, a, b, c, d, in[1] + K2,  3);\n\tROUND(G, d, a, b, c, in[3] + K2,  5);\n\tROUND(G, c, d, a, b, in[5] + K2,  9);\n\tROUND(G, b, c, d, a, in[7] + K2, 13);\n\tROUND(G, a, b, c, d, in[0] + K2,  3);\n\tROUND(G, d, a, b, c, in[2] + K2,  5);\n\tROUND(G, c, d, a, b, in[4] + K2,  9);\n\tROUND(G, b, c, d, a, in[6] + K2, 13);\n\n\t \n\tROUND(H, a, b, c, d, in[3] + K3,  3);\n\tROUND(H, d, a, b, c, in[7] + K3,  9);\n\tROUND(H, c, d, a, b, in[2] + K3, 11);\n\tROUND(H, b, c, d, a, in[6] + K3, 15);\n\tROUND(H, a, b, c, d, in[1] + K3,  3);\n\tROUND(H, d, a, b, c, in[5] + K3,  9);\n\tROUND(H, c, d, a, b, in[0] + K3, 11);\n\tROUND(H, b, c, d, a, in[4] + K3, 15);\n\n\tbuf[0] += a;\n\tbuf[1] += b;\n\tbuf[2] += c;\n\tbuf[3] += d;\n\n\treturn buf[1];  \n}\n#undef ROUND\n#undef K1\n#undef K2\n#undef K3\n#undef F\n#undef G\n#undef H\n\n \nstatic __u32 dx_hack_hash_unsigned(const char *name, int len)\n{\n\t__u32 hash, hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;\n\tconst unsigned char *ucp = (const unsigned char *) name;\n\n\twhile (len--) {\n\t\thash = hash1 + (hash0 ^ (((int) *ucp++) * 7152373));\n\n\t\tif (hash & 0x80000000)\n\t\t\thash -= 0x7fffffff;\n\t\thash1 = hash0;\n\t\thash0 = hash;\n\t}\n\treturn hash0 << 1;\n}\n\nstatic __u32 dx_hack_hash_signed(const char *name, int len)\n{\n\t__u32 hash, hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;\n\tconst signed char *scp = (const signed char *) name;\n\n\twhile (len--) {\n\t\thash = hash1 + (hash0 ^ (((int) *scp++) * 7152373));\n\n\t\tif (hash & 0x80000000)\n\t\t\thash -= 0x7fffffff;\n\t\thash1 = hash0;\n\t\thash0 = hash;\n\t}\n\treturn hash0 << 1;\n}\n\nstatic void str2hashbuf_signed(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\tconst signed char *scp = (const signed char *) msg;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tval = ((int) scp[i]) + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}\n\nstatic void str2hashbuf_unsigned(const char *msg, int len, __u32 *buf, int num)\n{\n\t__u32\tpad, val;\n\tint\ti;\n\tconst unsigned char *ucp = (const unsigned char *) msg;\n\n\tpad = (__u32)len | ((__u32)len << 8);\n\tpad |= pad << 16;\n\n\tval = pad;\n\tif (len > num*4)\n\t\tlen = num * 4;\n\tfor (i = 0; i < len; i++) {\n\t\tval = ((int) ucp[i]) + (val << 8);\n\t\tif ((i % 4) == 3) {\n\t\t\t*buf++ = val;\n\t\t\tval = pad;\n\t\t\tnum--;\n\t\t}\n\t}\n\tif (--num >= 0)\n\t\t*buf++ = val;\n\twhile (--num >= 0)\n\t\t*buf++ = pad;\n}\n\n \nstatic int __ext4fs_dirhash(const struct inode *dir, const char *name, int len,\n\t\t\t    struct dx_hash_info *hinfo)\n{\n\t__u32\thash;\n\t__u32\tminor_hash = 0;\n\tconst char\t*p;\n\tint\t\ti;\n\t__u32\t\tin[8], buf[4];\n\tvoid\t\t(*str2hashbuf)(const char *, int, __u32 *, int) =\n\t\t\t\tstr2hashbuf_signed;\n\n\t \n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\t \n\tif (hinfo->seed) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (hinfo->seed[i]) {\n\t\t\t\tmemcpy(buf, hinfo->seed, sizeof(buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hinfo->hash_version) {\n\tcase DX_HASH_LEGACY_UNSIGNED:\n\t\thash = dx_hack_hash_unsigned(name, len);\n\t\tbreak;\n\tcase DX_HASH_LEGACY:\n\t\thash = dx_hack_hash_signed(name, len);\n\t\tbreak;\n\tcase DX_HASH_HALF_MD4_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\t\tfallthrough;\n\tcase DX_HASH_HALF_MD4:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 8);\n\t\t\thalf_md4_transform(buf, in);\n\t\t\tlen -= 32;\n\t\t\tp += 32;\n\t\t}\n\t\tminor_hash = buf[2];\n\t\thash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_TEA_UNSIGNED:\n\t\tstr2hashbuf = str2hashbuf_unsigned;\n\t\tfallthrough;\n\tcase DX_HASH_TEA:\n\t\tp = name;\n\t\twhile (len > 0) {\n\t\t\t(*str2hashbuf)(p, len, in, 4);\n\t\t\tTEA_transform(buf, in);\n\t\t\tlen -= 16;\n\t\t\tp += 16;\n\t\t}\n\t\thash = buf[0];\n\t\tminor_hash = buf[1];\n\t\tbreak;\n\tcase DX_HASH_SIPHASH:\n\t{\n\t\tstruct qstr qname = QSTR_INIT(name, len);\n\t\t__u64\tcombined_hash;\n\n\t\tif (fscrypt_has_encryption_key(dir)) {\n\t\t\tcombined_hash = fscrypt_fname_siphash(dir, &qname);\n\t\t} else {\n\t\t\text4_warning_inode(dir, \"Siphash requires key\");\n\t\t\treturn -1;\n\t\t}\n\n\t\thash = (__u32)(combined_hash >> 32);\n\t\tminor_hash = (__u32)combined_hash;\n\t\tbreak;\n\t}\n\tdefault:\n\t\thinfo->hash = 0;\n\t\thinfo->minor_hash = 0;\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"invalid/unsupported hash tree version %u\",\n\t\t\t     hinfo->hash_version);\n\t\treturn -EINVAL;\n\t}\n\thash = hash & ~1;\n\tif (hash == (EXT4_HTREE_EOF_32BIT << 1))\n\t\thash = (EXT4_HTREE_EOF_32BIT - 1) << 1;\n\thinfo->hash = hash;\n\thinfo->minor_hash = minor_hash;\n\treturn 0;\n}\n\nint ext4fs_dirhash(const struct inode *dir, const char *name, int len,\n\t\t   struct dx_hash_info *hinfo)\n{\n#if IS_ENABLED(CONFIG_UNICODE)\n\tconst struct unicode_map *um = dir->i_sb->s_encoding;\n\tint r, dlen;\n\tunsigned char *buff;\n\tstruct qstr qstr = {.name = name, .len = len };\n\n\tif (len && IS_CASEFOLDED(dir) &&\n\t   (!IS_ENCRYPTED(dir) || fscrypt_has_encryption_key(dir))) {\n\t\tbuff = kzalloc(sizeof(char) * PATH_MAX, GFP_KERNEL);\n\t\tif (!buff)\n\t\t\treturn -ENOMEM;\n\n\t\tdlen = utf8_casefold(um, &qstr, buff, PATH_MAX);\n\t\tif (dlen < 0) {\n\t\t\tkfree(buff);\n\t\t\tgoto opaque_seq;\n\t\t}\n\n\t\tr = __ext4fs_dirhash(dir, buff, dlen, hinfo);\n\n\t\tkfree(buff);\n\t\treturn r;\n\t}\nopaque_seq:\n#endif\n\treturn __ext4fs_dirhash(dir, name, len, hinfo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}