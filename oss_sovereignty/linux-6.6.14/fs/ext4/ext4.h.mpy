{
  "module_name": "ext4.h",
  "hash_id": "e7625a2b4a639ba5e9d6bf3e0ccb64be65225f739a6b3105bc53c5c4b986849d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/ext4.h",
  "human_readable_source": "\n \n\n#ifndef _EXT4_H\n#define _EXT4_H\n\n#include <linux/refcount.h>\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/magic.h>\n#include <linux/jbd2.h>\n#include <linux/quota.h>\n#include <linux/rwsem.h>\n#include <linux/rbtree.h>\n#include <linux/seqlock.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <crypto/hash.h>\n#include <linux/falloc.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/fiemap.h>\n#ifdef __KERNEL__\n#include <linux/compat.h>\n#endif\n#include <uapi/linux/ext4.h>\n\n#include <linux/fscrypt.h>\n#include <linux/fsverity.h>\n\n#include <linux/compiler.h>\n\n \n\n \n#define AGGRESSIVE_CHECK__\n\n \n#define DOUBLE_CHECK__\n\n \n#undef EXT4FS_DEBUG\n\n \n#ifdef EXT4FS_DEBUG\n#define ext4_debug(f, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"EXT4-fs DEBUG (%s, %d): %s:\",\t\\\n\t\t\t__FILE__, __LINE__, __func__);\t\t\t\\\n\t\tprintk(KERN_DEBUG f, ## a);\t\t\t\t\\\n\t} while (0)\n#else\n#define ext4_debug(fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n  \n#define EXT_DEBUG__\n\n \n#ifdef CONFIG_EXT4_DEBUG\n#define ext_debug(ino, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"[%s/%d] EXT4-fs (%s): ino %lu: (%s, %d): %s:\" fmt,\t\\\n\t\t current->comm, task_pid_nr(current),\t\t\t\\\n\t\t ino->i_sb->s_id, ino->i_ino, __FILE__, __LINE__,\t\\\n\t\t __func__, ##__VA_ARGS__)\n#else\n#define ext_debug(ino, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define ASSERT(assert)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!(assert))) {\t\t\t\t\t\\\n\t\tprintk(KERN_EMERG\t\t\t\t\t\\\n\t\t       \"Assertion failure in %s() at %s:%d: '%s'\\n\",\t\\\n\t\t       __func__, __FILE__, __LINE__, #assert);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \ntypedef int ext4_grpblk_t;\n\n \ntypedef unsigned long long ext4_fsblk_t;\n\n \ntypedef __u32 ext4_lblk_t;\n\n \ntypedef unsigned int ext4_group_t;\n\nenum SHIFT_DIRECTION {\n\tSHIFT_LEFT = 0,\n\tSHIFT_RIGHT,\n};\n\n \nenum criteria {\n\t \n\tCR_POWER2_ALIGNED,\n\n\t \n\tCR_GOAL_LEN_FAST,\n\n         \n\tCR_BEST_AVAIL_LEN,\n\n\t \n\tCR_GOAL_LEN_SLOW,\n\n\t \n\tCR_ANY_FREE,\n\n\t \n\tEXT4_MB_NUM_CRS\n};\n\n \n\n \n#define EXT4_MB_HINT_MERGE\t\t0x0001\n \n#define EXT4_MB_HINT_RESERVED\t\t0x0002\n \n#define EXT4_MB_HINT_METADATA\t\t0x0004\n \n#define EXT4_MB_HINT_FIRST\t\t0x0008\n \n#define EXT4_MB_HINT_BEST\t\t0x0010\n \n#define EXT4_MB_HINT_DATA\t\t0x0020\n \n#define EXT4_MB_HINT_NOPREALLOC\t\t0x0040\n \n#define EXT4_MB_HINT_GROUP_ALLOC\t0x0080\n \n#define EXT4_MB_HINT_GOAL_ONLY\t\t0x0100\n \n#define EXT4_MB_HINT_TRY_GOAL\t\t0x0200\n \n#define EXT4_MB_DELALLOC_RESERVED\t0x0400\n \n#define EXT4_MB_STREAM_ALLOC\t\t0x0800\n \n#define EXT4_MB_USE_ROOT_BLOCKS\t\t0x1000\n \n#define EXT4_MB_USE_RESERVED\t\t0x2000\n \n#define EXT4_MB_STRICT_CHECK\t\t0x4000\n \n#define EXT4_MB_CR_POWER2_ALIGNED_OPTIMIZED\t\t0x8000\n \n#define EXT4_MB_CR_GOAL_LEN_FAST_OPTIMIZED\t\t0x00010000\n \n#define EXT4_MB_CR_BEST_AVAIL_LEN_OPTIMIZED\t\t0x00020000\n\nstruct ext4_allocation_request {\n\t \n\tstruct inode *inode;\n\t \n\tunsigned int len;\n\t \n\text4_lblk_t logical;\n\t \n\text4_lblk_t lleft;\n\t \n\text4_lblk_t lright;\n\t \n\text4_fsblk_t goal;\n\t \n\text4_fsblk_t pleft;\n\t \n\text4_fsblk_t pright;\n\t \n\tunsigned int flags;\n};\n\n \n#define EXT4_MAP_NEW\t\tBIT(BH_New)\n#define EXT4_MAP_MAPPED\t\tBIT(BH_Mapped)\n#define EXT4_MAP_UNWRITTEN\tBIT(BH_Unwritten)\n#define EXT4_MAP_BOUNDARY\tBIT(BH_Boundary)\n#define EXT4_MAP_FLAGS\t\t(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\\\n\t\t\t\t EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY)\n\nstruct ext4_map_blocks {\n\text4_fsblk_t m_pblk;\n\text4_lblk_t m_lblk;\n\tunsigned int m_len;\n\tunsigned int m_flags;\n};\n\n \nstruct ext4_system_blocks {\n\tstruct rb_root root;\n\tstruct rcu_head rcu;\n};\n\n \n#define\tEXT4_IO_END_UNWRITTEN\t0x0001\n\nstruct ext4_io_end_vec {\n\tstruct list_head list;\t\t \n\tloff_t offset;\t\t\t \n\tssize_t size;\t\t\t \n};\n\n \ntypedef struct ext4_io_end {\n\tstruct list_head\tlist;\t\t \n\thandle_t\t\t*handle;\t \n\tstruct inode\t\t*inode;\t\t \n\tstruct bio\t\t*bio;\t\t \n\tunsigned int\t\tflag;\t\t \n\trefcount_t\t\tcount;\t\t \n\tstruct list_head\tlist_vec;\t \n} ext4_io_end_t;\n\nstruct ext4_io_submit {\n\tstruct writeback_control *io_wbc;\n\tstruct bio\t\t*io_bio;\n\text4_io_end_t\t\t*io_end;\n\tsector_t\t\tio_next_block;\n};\n\n \n#define\tEXT4_BAD_INO\t\t 1\t \n#define EXT4_ROOT_INO\t\t 2\t \n#define EXT4_USR_QUOTA_INO\t 3\t \n#define EXT4_GRP_QUOTA_INO\t 4\t \n#define EXT4_BOOT_LOADER_INO\t 5\t \n#define EXT4_UNDEL_DIR_INO\t 6\t \n#define EXT4_RESIZE_INO\t\t 7\t \n#define EXT4_JOURNAL_INO\t 8\t \n\n \n#define EXT4_GOOD_OLD_FIRST_INO\t11\n\n \n#define EXT4_LINK_MAX\t\t65000\n\n \n#define EXT4_MIN_BLOCK_SIZE\t\t1024\n#define\tEXT4_MAX_BLOCK_SIZE\t\t65536\n#define EXT4_MIN_BLOCK_LOG_SIZE\t\t10\n#define EXT4_MAX_BLOCK_LOG_SIZE\t\t16\n#define EXT4_MAX_CLUSTER_LOG_SIZE\t30\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE(s)\t\t((s)->s_blocksize)\n#else\n# define EXT4_BLOCK_SIZE(s)\t\t(EXT4_MIN_BLOCK_SIZE << (s)->s_log_block_size)\n#endif\n#define\tEXT4_ADDR_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / sizeof(__u32))\n#define EXT4_CLUSTER_SIZE(s)\t\t(EXT4_BLOCK_SIZE(s) << \\\n\t\t\t\t\t EXT4_SB(s)->s_cluster_bits)\n#ifdef __KERNEL__\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_blocksize_bits)\n# define EXT4_CLUSTER_BITS(s)\t\t(EXT4_SB(s)->s_cluster_bits)\n#else\n# define EXT4_BLOCK_SIZE_BITS(s)\t((s)->s_log_block_size + 10)\n#endif\n#ifdef __KERNEL__\n#define\tEXT4_ADDR_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_addr_per_block_bits)\n#define EXT4_INODE_SIZE(s)\t\t(EXT4_SB(s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t\t(EXT4_SB(s)->s_first_ino)\n#else\n#define EXT4_INODE_SIZE(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_INODE_SIZE : \\\n\t\t\t\t (s)->s_inode_size)\n#define EXT4_FIRST_INO(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\\n\t\t\t\t EXT4_GOOD_OLD_FIRST_INO : \\\n\t\t\t\t (s)->s_first_ino)\n#endif\n#define EXT4_BLOCK_ALIGN(size, blkbits)\t\tALIGN((size), (1 << (blkbits)))\n#define EXT4_MAX_BLOCKS(size, offset, blkbits) \\\n\t((EXT4_BLOCK_ALIGN(size + offset, blkbits) >> blkbits) - (offset >> \\\n\t\t\t\t\t\t\t\t  blkbits))\n\n \n#define EXT4_B2C(sbi, blk)\t((blk) >> (sbi)->s_cluster_bits)\n \n#define EXT4_C2B(sbi, cluster)\t((cluster) << (sbi)->s_cluster_bits)\n \n#define EXT4_NUM_B2C(sbi, blks)\t(((blks) + (sbi)->s_cluster_ratio - 1) >> \\\n\t\t\t\t (sbi)->s_cluster_bits)\n \n#define EXT4_PBLK_CMASK(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_CMASK(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t  ~((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n \n#define EXT4_LBLK_CFILL(sbi, lblk) ((lblk) |\t\t\t\t\\\n\t\t\t\t    ((ext4_lblk_t) (sbi)->s_cluster_ratio - 1))\n \n#define EXT4_PBLK_COFF(s, pblk) ((pblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_fsblk_t) (s)->s_cluster_ratio - 1))\n#define EXT4_LBLK_COFF(s, lblk) ((lblk) &\t\t\t\t\\\n\t\t\t\t ((ext4_lblk_t) (s)->s_cluster_ratio - 1))\n\n \nstruct ext4_group_desc\n{\n\t__le32\tbg_block_bitmap_lo;\t \n\t__le32\tbg_inode_bitmap_lo;\t \n\t__le32\tbg_inode_table_lo;\t \n\t__le16\tbg_free_blocks_count_lo; \n\t__le16\tbg_free_inodes_count_lo; \n\t__le16\tbg_used_dirs_count_lo;\t \n\t__le16\tbg_flags;\t\t \n\t__le32  bg_exclude_bitmap_lo;    \n\t__le16  bg_block_bitmap_csum_lo; \n\t__le16  bg_inode_bitmap_csum_lo; \n\t__le16  bg_itable_unused_lo;\t \n\t__le16  bg_checksum;\t\t \n\t__le32\tbg_block_bitmap_hi;\t \n\t__le32\tbg_inode_bitmap_hi;\t \n\t__le32\tbg_inode_table_hi;\t \n\t__le16\tbg_free_blocks_count_hi; \n\t__le16\tbg_free_inodes_count_hi; \n\t__le16\tbg_used_dirs_count_hi;\t \n\t__le16  bg_itable_unused_hi;     \n\t__le32  bg_exclude_bitmap_hi;    \n\t__le16  bg_block_bitmap_csum_hi; \n\t__le16  bg_inode_bitmap_csum_hi; \n\t__u32   bg_reserved;\n};\n\n#define EXT4_BG_INODE_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_inode_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n#define EXT4_BG_BLOCK_BITMAP_CSUM_HI_END\t\\\n\t(offsetof(struct ext4_group_desc, bg_block_bitmap_csum_hi) + \\\n\t sizeof(__le16))\n\n \n\nstruct flex_groups {\n\tatomic64_t\tfree_clusters;\n\tatomic_t\tfree_inodes;\n\tatomic_t\tused_dirs;\n};\n\n#define EXT4_BG_INODE_UNINIT\t0x0001  \n#define EXT4_BG_BLOCK_UNINIT\t0x0002  \n#define EXT4_BG_INODE_ZEROED\t0x0004  \n\n \n#define EXT4_MIN_DESC_SIZE\t\t32\n#define EXT4_MIN_DESC_SIZE_64BIT\t64\n#define\tEXT4_MAX_DESC_SIZE\t\tEXT4_MIN_BLOCK_SIZE\n#define EXT4_DESC_SIZE(s)\t\t(EXT4_SB(s)->s_desc_size)\n#ifdef __KERNEL__\n# define EXT4_BLOCKS_PER_GROUP(s)\t(EXT4_SB(s)->s_blocks_per_group)\n# define EXT4_CLUSTERS_PER_GROUP(s)\t(EXT4_SB(s)->s_clusters_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_SB(s)->s_desc_per_block)\n# define EXT4_INODES_PER_GROUP(s)\t(EXT4_SB(s)->s_inodes_per_group)\n# define EXT4_DESC_PER_BLOCK_BITS(s)\t(EXT4_SB(s)->s_desc_per_block_bits)\n#else\n# define EXT4_BLOCKS_PER_GROUP(s)\t((s)->s_blocks_per_group)\n# define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / EXT4_DESC_SIZE(s))\n# define EXT4_INODES_PER_GROUP(s)\t((s)->s_inodes_per_group)\n#endif\n\n \n#define\tEXT4_NDIR_BLOCKS\t\t12\n#define\tEXT4_IND_BLOCK\t\t\tEXT4_NDIR_BLOCKS\n#define\tEXT4_DIND_BLOCK\t\t\t(EXT4_IND_BLOCK + 1)\n#define\tEXT4_TIND_BLOCK\t\t\t(EXT4_DIND_BLOCK + 1)\n#define\tEXT4_N_BLOCKS\t\t\t(EXT4_TIND_BLOCK + 1)\n\n \n#define\tEXT4_SECRM_FL\t\t\t0x00000001  \n#define\tEXT4_UNRM_FL\t\t\t0x00000002  \n#define\tEXT4_COMPR_FL\t\t\t0x00000004  \n#define EXT4_SYNC_FL\t\t\t0x00000008  \n#define EXT4_IMMUTABLE_FL\t\t0x00000010  \n#define EXT4_APPEND_FL\t\t\t0x00000020  \n#define EXT4_NODUMP_FL\t\t\t0x00000040  \n#define EXT4_NOATIME_FL\t\t\t0x00000080  \n \n#define EXT4_DIRTY_FL\t\t\t0x00000100\n#define EXT4_COMPRBLK_FL\t\t0x00000200  \n#define EXT4_NOCOMPR_FL\t\t\t0x00000400  \n\t \n#define EXT4_ENCRYPT_FL\t\t\t0x00000800  \n \n#define EXT4_INDEX_FL\t\t\t0x00001000  \n#define EXT4_IMAGIC_FL\t\t\t0x00002000  \n#define EXT4_JOURNAL_DATA_FL\t\t0x00004000  \n#define EXT4_NOTAIL_FL\t\t\t0x00008000  \n#define EXT4_DIRSYNC_FL\t\t\t0x00010000  \n#define EXT4_TOPDIR_FL\t\t\t0x00020000  \n#define EXT4_HUGE_FILE_FL               0x00040000  \n#define EXT4_EXTENTS_FL\t\t\t0x00080000  \n#define EXT4_VERITY_FL\t\t\t0x00100000  \n#define EXT4_EA_INODE_FL\t        0x00200000  \n \n\n#define EXT4_DAX_FL\t\t\t0x02000000  \n\n#define EXT4_INLINE_DATA_FL\t\t0x10000000  \n#define EXT4_PROJINHERIT_FL\t\t0x20000000  \n#define EXT4_CASEFOLD_FL\t\t0x40000000  \n#define EXT4_RESERVED_FL\t\t0x80000000  \n\n \n#define EXT4_FL_USER_MODIFIABLE\t\t(EXT4_SECRM_FL | \\\n\t\t\t\t\t EXT4_UNRM_FL | \\\n\t\t\t\t\t EXT4_COMPR_FL | \\\n\t\t\t\t\t EXT4_SYNC_FL | \\\n\t\t\t\t\t EXT4_IMMUTABLE_FL | \\\n\t\t\t\t\t EXT4_APPEND_FL | \\\n\t\t\t\t\t EXT4_NODUMP_FL | \\\n\t\t\t\t\t EXT4_NOATIME_FL | \\\n\t\t\t\t\t EXT4_JOURNAL_DATA_FL | \\\n\t\t\t\t\t EXT4_NOTAIL_FL | \\\n\t\t\t\t\t EXT4_DIRSYNC_FL | \\\n\t\t\t\t\t EXT4_TOPDIR_FL | \\\n\t\t\t\t\t EXT4_EXTENTS_FL | \\\n\t\t\t\t\t 0x00400000   | \\\n\t\t\t\t\t EXT4_DAX_FL | \\\n\t\t\t\t\t EXT4_PROJINHERIT_FL | \\\n\t\t\t\t\t EXT4_CASEFOLD_FL)\n\n \n#define EXT4_FL_USER_VISIBLE\t\t(EXT4_FL_USER_MODIFIABLE | \\\n\t\t\t\t\t EXT4_DIRTY_FL | \\\n\t\t\t\t\t EXT4_COMPRBLK_FL | \\\n\t\t\t\t\t EXT4_NOCOMPR_FL | \\\n\t\t\t\t\t EXT4_ENCRYPT_FL | \\\n\t\t\t\t\t EXT4_INDEX_FL | \\\n\t\t\t\t\t EXT4_VERITY_FL | \\\n\t\t\t\t\t EXT4_INLINE_DATA_FL)\n\n \n#define EXT4_FL_INHERITED (EXT4_SECRM_FL | EXT4_UNRM_FL | EXT4_COMPR_FL |\\\n\t\t\t   EXT4_SYNC_FL | EXT4_NODUMP_FL | EXT4_NOATIME_FL |\\\n\t\t\t   EXT4_NOCOMPR_FL | EXT4_JOURNAL_DATA_FL |\\\n\t\t\t   EXT4_NOTAIL_FL | EXT4_DIRSYNC_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_DAX_FL)\n\n \n#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL | EXT4_CASEFOLD_FL |\\\n\t\t\t   EXT4_PROJINHERIT_FL))\n\n \n#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)\n\n \n#define EXT4_FL_SHOULD_SWAP (EXT4_HUGE_FILE_FL | EXT4_EXTENTS_FL)\n\n \n#define EXT4_DAX_MUT_EXCL (EXT4_VERITY_FL | EXT4_ENCRYPT_FL |\\\n\t\t\t   EXT4_JOURNAL_DATA_FL | EXT4_INLINE_DATA_FL)\n\n \nstatic inline __u32 ext4_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT4_REG_FLMASK;\n\telse\n\t\treturn flags & EXT4_OTHER_FLMASK;\n}\n\n \nenum {\n\tEXT4_INODE_SECRM\t= 0,\t \n\tEXT4_INODE_UNRM\t\t= 1,\t \n\tEXT4_INODE_COMPR\t= 2,\t \n\tEXT4_INODE_SYNC\t\t= 3,\t \n\tEXT4_INODE_IMMUTABLE\t= 4,\t \n\tEXT4_INODE_APPEND\t= 5,\t \n\tEXT4_INODE_NODUMP\t= 6,\t \n\tEXT4_INODE_NOATIME\t= 7,\t \n \n\tEXT4_INODE_DIRTY\t= 8,\n\tEXT4_INODE_COMPRBLK\t= 9,\t \n\tEXT4_INODE_NOCOMPR\t= 10,\t \n\tEXT4_INODE_ENCRYPT\t= 11,\t \n \n\tEXT4_INODE_INDEX\t= 12,\t \n\tEXT4_INODE_IMAGIC\t= 13,\t \n\tEXT4_INODE_JOURNAL_DATA\t= 14,\t \n\tEXT4_INODE_NOTAIL\t= 15,\t \n\tEXT4_INODE_DIRSYNC\t= 16,\t \n\tEXT4_INODE_TOPDIR\t= 17,\t \n\tEXT4_INODE_HUGE_FILE\t= 18,\t \n\tEXT4_INODE_EXTENTS\t= 19,\t \n\tEXT4_INODE_VERITY\t= 20,\t \n\tEXT4_INODE_EA_INODE\t= 21,\t \n \n\tEXT4_INODE_DAX\t\t= 25,\t \n\tEXT4_INODE_INLINE_DATA\t= 28,\t \n\tEXT4_INODE_PROJINHERIT\t= 29,\t \n\tEXT4_INODE_CASEFOLD\t= 30,\t \n\tEXT4_INODE_RESERVED\t= 31,\t \n};\n\n \n#define TEST_FLAG_VALUE(FLAG) (EXT4_##FLAG##_FL == (1U << EXT4_INODE_##FLAG))\n#define CHECK_FLAG_VALUE(FLAG) BUILD_BUG_ON(!TEST_FLAG_VALUE(FLAG))\n\nstatic inline void ext4_check_flag_values(void)\n{\n\tCHECK_FLAG_VALUE(SECRM);\n\tCHECK_FLAG_VALUE(UNRM);\n\tCHECK_FLAG_VALUE(COMPR);\n\tCHECK_FLAG_VALUE(SYNC);\n\tCHECK_FLAG_VALUE(IMMUTABLE);\n\tCHECK_FLAG_VALUE(APPEND);\n\tCHECK_FLAG_VALUE(NODUMP);\n\tCHECK_FLAG_VALUE(NOATIME);\n\tCHECK_FLAG_VALUE(DIRTY);\n\tCHECK_FLAG_VALUE(COMPRBLK);\n\tCHECK_FLAG_VALUE(NOCOMPR);\n\tCHECK_FLAG_VALUE(ENCRYPT);\n\tCHECK_FLAG_VALUE(INDEX);\n\tCHECK_FLAG_VALUE(IMAGIC);\n\tCHECK_FLAG_VALUE(JOURNAL_DATA);\n\tCHECK_FLAG_VALUE(NOTAIL);\n\tCHECK_FLAG_VALUE(DIRSYNC);\n\tCHECK_FLAG_VALUE(TOPDIR);\n\tCHECK_FLAG_VALUE(HUGE_FILE);\n\tCHECK_FLAG_VALUE(EXTENTS);\n\tCHECK_FLAG_VALUE(VERITY);\n\tCHECK_FLAG_VALUE(EA_INODE);\n\tCHECK_FLAG_VALUE(INLINE_DATA);\n\tCHECK_FLAG_VALUE(PROJINHERIT);\n\tCHECK_FLAG_VALUE(CASEFOLD);\n\tCHECK_FLAG_VALUE(RESERVED);\n}\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\nstruct compat_ext4_new_group_input {\n\tu32 group;\n\tcompat_u64 block_bitmap;\n\tcompat_u64 inode_bitmap;\n\tcompat_u64 inode_table;\n\tu32 blocks_count;\n\tu16 reserved_blocks;\n\tu16 unused;\n};\n#endif\n\n \nstruct ext4_new_group_data {\n\t__u32 group;\n\t__u64 block_bitmap;\n\t__u64 inode_bitmap;\n\t__u64 inode_table;\n\t__u32 blocks_count;\n\t__u16 reserved_blocks;\n\t__u16 mdata_blocks;\n\t__u32 free_clusters_count;\n};\n\n \nenum {\n\tBLOCK_BITMAP = 0,\t \n\tINODE_BITMAP,\t\t \n\tINODE_TABLE,\t\t \n\tGROUP_TABLE_COUNT,\n};\n\n \n\t \n#define EXT4_GET_BLOCKS_CREATE\t\t\t0x0001\n\t \n#define EXT4_GET_BLOCKS_UNWRIT_EXT\t\t0x0002\n#define EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT\t(EXT4_GET_BLOCKS_UNWRIT_EXT|\\\n\t\t\t\t\t\t EXT4_GET_BLOCKS_CREATE)\n\t \n#define EXT4_GET_BLOCKS_DELALLOC_RESERVE\t0x0004\n\t \n#define EXT4_GET_BLOCKS_PRE_IO\t\t\t0x0008\n#define EXT4_GET_BLOCKS_CONVERT\t\t\t0x0010\n#define EXT4_GET_BLOCKS_IO_CREATE_EXT\t\t(EXT4_GET_BLOCKS_PRE_IO|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t \n#define EXT4_GET_BLOCKS_IO_CONVERT_EXT\t\t(EXT4_GET_BLOCKS_CONVERT|\\\n\t\t\t\t\t EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT)\n\t \n#define EXT4_GET_BLOCKS_METADATA_NOFAIL\t\t0x0020\n\t \n#define EXT4_GET_BLOCKS_NO_NORMALIZE\t\t0x0040\n\t \n#define EXT4_GET_BLOCKS_CONVERT_UNWRITTEN\t0x0100\n\t \n#define EXT4_GET_BLOCKS_ZERO\t\t\t0x0200\n#define EXT4_GET_BLOCKS_CREATE_ZERO\t\t(EXT4_GET_BLOCKS_CREATE |\\\n\t\t\t\t\tEXT4_GET_BLOCKS_ZERO)\n\t \n#define EXT4_GET_BLOCKS_IO_SUBMIT\t\t0x0400\n\t \n#define EXT4_GET_BLOCKS_CACHED_NOWAIT\t\t0x0800\n\n \n#define EXT4_EX_NOCACHE\t\t\t\t0x40000000\n#define EXT4_EX_FORCE_CACHE\t\t\t0x20000000\n#define EXT4_EX_NOFAIL\t\t\t\t0x10000000\n\n \n#define EXT4_FREE_BLOCKS_METADATA\t\t0x0001\n#define EXT4_FREE_BLOCKS_FORGET\t\t\t0x0002\n#define EXT4_FREE_BLOCKS_VALIDATED\t\t0x0004\n#define EXT4_FREE_BLOCKS_NO_QUOT_UPDATE\t\t0x0008\n#define EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER\t0x0010\n#define EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER\t0x0020\n#define EXT4_FREE_BLOCKS_RERESERVE_CLUSTER      0x0040\n\n#if defined(__KERNEL__) && defined(CONFIG_COMPAT)\n \n#define EXT4_IOC32_GETVERSION\t\t_IOR('f', 3, int)\n#define EXT4_IOC32_SETVERSION\t\t_IOW('f', 4, int)\n#define EXT4_IOC32_GETRSVSZ\t\t_IOR('f', 5, int)\n#define EXT4_IOC32_SETRSVSZ\t\t_IOW('f', 6, int)\n#define EXT4_IOC32_GROUP_EXTEND\t\t_IOW('f', 7, unsigned int)\n#define EXT4_IOC32_GROUP_ADD\t\t_IOW('f', 8, struct compat_ext4_new_group_input)\n#define EXT4_IOC32_GETVERSION_OLD\tFS_IOC32_GETVERSION\n#define EXT4_IOC32_SETVERSION_OLD\tFS_IOC32_SETVERSION\n#endif\n\n \n#define EXT4_MAX_BLOCK_FILE_PHYS\t0xFFFFFFFF\n\n \n#define EXT4_MAX_LOGICAL_BLOCK\t\t0xFFFFFFFE\n\n \nstruct ext4_inode {\n\t__le16\ti_mode;\t\t \n\t__le16\ti_uid;\t\t \n\t__le32\ti_size_lo;\t \n\t__le32\ti_atime;\t \n\t__le32\ti_ctime;\t \n\t__le32\ti_mtime;\t \n\t__le32\ti_dtime;\t \n\t__le16\ti_gid;\t\t \n\t__le16\ti_links_count;\t \n\t__le32\ti_blocks_lo;\t \n\t__le32\ti_flags;\t \n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_version;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__u32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__u32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t \n\t__le32\ti_block[EXT4_N_BLOCKS]; \n\t__le32\ti_generation;\t \n\t__le32\ti_file_acl_lo;\t \n\t__le32\ti_size_high;\n\t__le32\ti_obso_faddr;\t \n\tunion {\n\t\tstruct {\n\t\t\t__le16\tl_i_blocks_high;  \n\t\t\t__le16\tl_i_file_acl_high;\n\t\t\t__le16\tl_i_uid_high;\t \n\t\t\t__le16\tl_i_gid_high;\t \n\t\t\t__le16\tl_i_checksum_lo; \n\t\t\t__le16\tl_i_reserved;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t \n\t\t\t__u16\th_i_mode_high;\n\t\t\t__u16\th_i_uid_high;\n\t\t\t__u16\th_i_gid_high;\n\t\t\t__u32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t \n\t\t\t__le16\tm_i_file_acl_high;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t \n\t__le16\ti_extra_isize;\n\t__le16\ti_checksum_hi;\t \n\t__le32  i_ctime_extra;   \n\t__le32  i_mtime_extra;   \n\t__le32  i_atime_extra;   \n\t__le32  i_crtime;        \n\t__le32  i_crtime_extra;  \n\t__le32  i_version_hi;\t \n\t__le32\ti_projid;\t \n};\n\n#define EXT4_EPOCH_BITS 2\n#define EXT4_EPOCH_MASK ((1 << EXT4_EPOCH_BITS) - 1)\n#define EXT4_NSEC_MASK  (~0UL << EXT4_EPOCH_BITS)\n\n \n#define EXT4_FITS_IN_INODE(ext4_inode, einode, field)\t\\\n\t((offsetof(typeof(*ext4_inode), field) +\t\\\n\t  sizeof((ext4_inode)->field))\t\t\t\\\n\t<= (EXT4_GOOD_OLD_INODE_SIZE +\t\t\t\\\n\t    (einode)->i_extra_isize))\t\t\t\\\n\n \n\nstatic inline __le32 ext4_encode_extra_time(struct timespec64 ts)\n{\n\tu32 extra = ((ts.tv_sec - (s32)ts.tv_sec) >> 32) & EXT4_EPOCH_MASK;\n\treturn cpu_to_le32(extra | (ts.tv_nsec << EXT4_EPOCH_BITS));\n}\n\nstatic inline struct timespec64 ext4_decode_extra_time(__le32 base,\n\t\t\t\t\t\t       __le32 extra)\n{\n\tstruct timespec64 ts = { .tv_sec = (signed)le32_to_cpu(base) };\n\n\tif (unlikely(extra & cpu_to_le32(EXT4_EPOCH_MASK)))\n\t\tts.tv_sec += (u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK) << 32;\n\tts.tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;\n\treturn ts;\n}\n\n#define EXT4_INODE_SET_XTIME_VAL(xtime, inode, raw_inode, ts)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra)) {\t\\\n\t\t(raw_inode)->xtime = cpu_to_le32((ts).tv_sec);\t\t\t\\\n\t\t(raw_inode)->xtime ## _extra = ext4_encode_extra_time(ts);\t\\\n\t} else\t\t\t\t\t\t\t\t\t\\\n\t\t(raw_inode)->xtime = cpu_to_le32(clamp_t(int32_t, (ts).tv_sec, S32_MIN, S32_MAX));\t\\\n} while (0)\n\n#define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\n\tEXT4_INODE_SET_XTIME_VAL(xtime, inode, raw_inode, (inode)->xtime)\n\n#define EXT4_INODE_SET_CTIME(inode, raw_inode)\t\t\t\t\t\\\n\tEXT4_INODE_SET_XTIME_VAL(i_ctime, inode, raw_inode, inode_get_ctime(inode))\n\n#define EXT4_EINODE_SET_XTIME(xtime, einode, raw_inode)\t\t\t\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))\t\t\t\\\n\t\tEXT4_INODE_SET_XTIME_VAL(xtime, &((einode)->vfs_inode),\t\t\\\n\t\t\t\t\t raw_inode, (einode)->xtime)\n\n#define EXT4_INODE_GET_XTIME_VAL(xtime, inode, raw_inode)\t\t\t\\\n\t(EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra) ?\t\\\n\t\text4_decode_extra_time((raw_inode)->xtime,\t\t\t\t\\\n\t\t\t\t       (raw_inode)->xtime ## _extra) :\t\t\\\n\t\t(struct timespec64) {\t\t\t\t\t\t\\\n\t\t\t.tv_sec = (signed)le32_to_cpu((raw_inode)->xtime)\t\\\n\t\t})\n\n#define EXT4_INODE_GET_XTIME(xtime, inode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\t(inode)->xtime = EXT4_INODE_GET_XTIME_VAL(xtime, inode, raw_inode);\t\\\n} while (0)\n\n#define EXT4_INODE_GET_CTIME(inode, raw_inode)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tinode_set_ctime_to_ts(inode,\t\t\t\t\t\t\\\n\t\tEXT4_INODE_GET_XTIME_VAL(i_ctime, inode, raw_inode));\t\t\\\n} while (0)\n\n#define EXT4_EINODE_GET_XTIME(xtime, einode, raw_inode)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tif (EXT4_FITS_IN_INODE(raw_inode, einode, xtime)) \t\t\t\\\n\t\t(einode)->xtime =\t\t\t\t\t\t\\\n\t\t\tEXT4_INODE_GET_XTIME_VAL(xtime, &(einode->vfs_inode),\t\\\n\t\t\t\t\t\t raw_inode);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\t(einode)->xtime = (struct timespec64){0, 0};\t\t\t\\\n} while (0)\n\n#define i_disk_version osd1.linux1.l_i_version\n\n#if defined(__KERNEL__) || defined(__linux__)\n#define i_reserved1\tosd1.linux1.l_i_reserved1\n#define i_file_acl_high\tosd2.linux2.l_i_file_acl_high\n#define i_blocks_high\tosd2.linux2.l_i_blocks_high\n#define i_uid_low\ti_uid\n#define i_gid_low\ti_gid\n#define i_uid_high\tosd2.linux2.l_i_uid_high\n#define i_gid_high\tosd2.linux2.l_i_gid_high\n#define i_checksum_lo\tosd2.linux2.l_i_checksum_lo\n\n#elif defined(__GNU__)\n\n#define i_translator\tosd1.hurd1.h_i_translator\n#define i_uid_high\tosd2.hurd2.h_i_uid_high\n#define i_gid_high\tosd2.hurd2.h_i_gid_high\n#define i_author\tosd2.hurd2.h_i_author\n\n#elif defined(__masix__)\n\n#define i_reserved1\tosd1.masix1.m_i_reserved1\n#define i_file_acl_high\tosd2.masix2.m_i_file_acl_high\n#define i_reserved2\tosd2.masix2.m_i_reserved2\n\n#endif  \n\n#include \"extents_status.h\"\n#include \"fast_commit.h\"\n\n \nenum {\n\tI_DATA_SEM_NORMAL = 0,\n\tI_DATA_SEM_OTHER,\n\tI_DATA_SEM_QUOTA,\n\tI_DATA_SEM_EA\n};\n\n\n \nstruct ext4_inode_info {\n\t__le32\ti_data[15];\t \n\t__u32\ti_dtime;\n\text4_fsblk_t\ti_file_acl;\n\n\t \n\text4_group_t\ti_block_group;\n\text4_lblk_t\ti_dir_start_lookup;\n#if (BITS_PER_LONG < 64)\n\tunsigned long\ti_state_flags;\t\t \n#endif\n\tunsigned long\ti_flags;\n\n\t \n\tstruct rw_semaphore xattr_sem;\n\n\t \n\tunion {\n\t\tstruct list_head i_orphan;\t \n\t\tunsigned int i_orphan_idx;\t \n\t};\n\n\t \n\n\t \n\tstruct list_head i_fc_dilist;\n\tstruct list_head i_fc_list;\t \n\n\t \n\text4_lblk_t i_fc_lblk_start;\n\n\t \n\text4_lblk_t i_fc_lblk_len;\n\n\t \n\tatomic_t  i_fc_updates;\n\n\t \n\twait_queue_head_t i_fc_wait;\n\n\t \n\tstruct mutex i_fc_lock;\n\n\t \n\tloff_t\ti_disksize;\n\n\t \n\tstruct rw_semaphore i_data_sem;\n\tstruct inode vfs_inode;\n\tstruct jbd2_inode *jinode;\n\n\tspinlock_t i_raw_lock;\t \n\n\t \n\tstruct timespec64 i_crtime;\n\n\t \n\tatomic_t i_prealloc_active;\n\tstruct rb_root i_prealloc_node;\n\trwlock_t i_prealloc_lock;\n\n\t \n\tstruct ext4_es_tree i_es_tree;\n\trwlock_t i_es_lock;\n\tstruct list_head i_es_list;\n\tunsigned int i_es_all_nr;\t \n\tunsigned int i_es_shk_nr;\t \n\text4_lblk_t i_es_shrink_lblk;\t \n\n\t \n\text4_group_t\ti_last_alloc_group;\n\n\t \n\t \n\tunsigned int i_reserved_data_blocks;\n\n\t \n\tstruct ext4_pending_tree i_pending_tree;\n\n\t \n\t__u16 i_extra_isize;\n\n\t \n\tu16 i_inline_off;\n\tu16 i_inline_size;\n\n#ifdef CONFIG_QUOTA\n\t \n\tqsize_t i_reserved_quota;\n#endif\n\n\t \n\tspinlock_t i_completed_io_lock;\n\t \n\tstruct list_head i_rsv_conversion_list;\n\tstruct work_struct i_rsv_conversion_work;\n\tatomic_t i_unwritten;  \n\n\tspinlock_t i_block_reservation_lock;\n\n\t \n\ttid_t i_sync_tid;\n\ttid_t i_datasync_tid;\n\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n#endif\n\n\t \n\t__u32 i_csum_seed;\n\n\tkprojid_t i_projid;\n};\n\n \n#define\tEXT4_VALID_FS\t\t\t0x0001\t \n#define\tEXT4_ERROR_FS\t\t\t0x0002\t \n#define\tEXT4_ORPHAN_FS\t\t\t0x0004\t \n#define EXT4_FC_REPLAY\t\t\t0x0020\t \n\n \n#define EXT2_FLAGS_SIGNED_HASH\t\t0x0001   \n#define EXT2_FLAGS_UNSIGNED_HASH\t0x0002   \n#define EXT2_FLAGS_TEST_FILESYS\t\t0x0004\t \n\n \n#define EXT4_MOUNT_NO_MBCACHE\t\t0x00001  \n#define EXT4_MOUNT_GRPID\t\t0x00004\t \n#define EXT4_MOUNT_DEBUG\t\t0x00008\t \n#define EXT4_MOUNT_ERRORS_CONT\t\t0x00010\t \n#define EXT4_MOUNT_ERRORS_RO\t\t0x00020\t \n#define EXT4_MOUNT_ERRORS_PANIC\t\t0x00040\t \n#define EXT4_MOUNT_ERRORS_MASK\t\t0x00070\n#define EXT4_MOUNT_MINIX_DF\t\t0x00080\t \n#define EXT4_MOUNT_NOLOAD\t\t0x00100\t \n#ifdef CONFIG_FS_DAX\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0x00200\t \n#else\n#define EXT4_MOUNT_DAX_ALWAYS\t\t0\n#endif\n#define EXT4_MOUNT_DATA_FLAGS\t\t0x00C00\t \n#define EXT4_MOUNT_JOURNAL_DATA\t\t0x00400\t \n#define EXT4_MOUNT_ORDERED_DATA\t\t0x00800\t \n#define EXT4_MOUNT_WRITEBACK_DATA\t0x00C00\t \n#define EXT4_MOUNT_UPDATE_JOURNAL\t0x01000\t \n#define EXT4_MOUNT_NO_UID32\t\t0x02000   \n#define EXT4_MOUNT_XATTR_USER\t\t0x04000\t \n#define EXT4_MOUNT_POSIX_ACL\t\t0x08000\t \n#define EXT4_MOUNT_NO_AUTO_DA_ALLOC\t0x10000\t \n#define EXT4_MOUNT_BARRIER\t\t0x20000  \n#define EXT4_MOUNT_QUOTA\t\t0x40000  \n#define EXT4_MOUNT_USRQUOTA\t\t0x80000  \n#define EXT4_MOUNT_GRPQUOTA\t\t0x100000  \n#define EXT4_MOUNT_PRJQUOTA\t\t0x200000  \n#define EXT4_MOUNT_DIOREAD_NOLOCK\t0x400000  \n#define EXT4_MOUNT_JOURNAL_CHECKSUM\t0x800000  \n#define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT\t0x1000000  \n#define EXT4_MOUNT_WARN_ON_ERROR\t0x2000000  \n#define EXT4_MOUNT_NO_PREFETCH_BLOCK_BITMAPS 0x4000000\n#define EXT4_MOUNT_DELALLOC\t\t0x8000000  \n#define EXT4_MOUNT_DATA_ERR_ABORT\t0x10000000  \n#define EXT4_MOUNT_BLOCK_VALIDITY\t0x20000000  \n#define EXT4_MOUNT_DISCARD\t\t0x40000000  \n#define EXT4_MOUNT_INIT_INODE_TABLE\t0x80000000  \n\n \n#define EXT4_MOUNT2_EXPLICIT_DELALLOC\t0x00000001  \n#define EXT4_MOUNT2_STD_GROUP_SIZE\t0x00000002  \n#define EXT4_MOUNT2_HURD_COMPAT\t\t0x00000004  \n#define EXT4_MOUNT2_EXPLICIT_JOURNAL_CHECKSUM\t0x00000008  \n\n#define EXT4_MOUNT2_JOURNAL_FAST_COMMIT\t0x00000010  \n#define EXT4_MOUNT2_DAX_NEVER\t\t0x00000020  \n#define EXT4_MOUNT2_DAX_INODE\t\t0x00000040  \n#define EXT4_MOUNT2_MB_OPTIMIZE_SCAN\t0x00000080  \n#define EXT4_MOUNT2_ABORT\t\t0x00000100  \n\n#define clear_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt &= \\\n\t\t\t\t\t\t~EXT4_MOUNT_##opt\n#define set_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt |= \\\n\t\t\t\t\t\tEXT4_MOUNT_##opt\n#define test_opt(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt & \\\n\t\t\t\t\t EXT4_MOUNT_##opt)\n\n#define clear_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 &= \\\n\t\t\t\t\t\t~EXT4_MOUNT2_##opt\n#define set_opt2(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt2 |= \\\n\t\t\t\t\t\tEXT4_MOUNT2_##opt\n#define test_opt2(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt2 & \\\n\t\t\t\t\t EXT4_MOUNT2_##opt)\n\n#define ext4_test_and_set_bit\t\t__test_and_set_bit_le\n#define ext4_set_bit\t\t\t__set_bit_le\n#define ext4_test_and_clear_bit\t\t__test_and_clear_bit_le\n#define ext4_clear_bit\t\t\t__clear_bit_le\n#define ext4_test_bit\t\t\ttest_bit_le\n#define ext4_find_next_zero_bit\t\tfind_next_zero_bit_le\n#define ext4_find_next_bit\t\tfind_next_bit_le\n\nextern void mb_set_bits(void *bm, int cur, int len);\n\n \n#define EXT4_DFL_MAX_MNT_COUNT\t\t20\t \n#define EXT4_DFL_CHECKINTERVAL\t\t0\t \n\n \n#define EXT4_ERRORS_CONTINUE\t\t1\t \n#define EXT4_ERRORS_RO\t\t\t2\t \n#define EXT4_ERRORS_PANIC\t\t3\t \n#define EXT4_ERRORS_DEFAULT\t\tEXT4_ERRORS_CONTINUE\n\n \n#define EXT4_CRC32C_CHKSUM\t\t1\n\n#define EXT4_LABEL_MAX\t\t\t16\n\n \nstruct ext4_super_block {\n \t__le32\ts_inodes_count;\t\t \n\t__le32\ts_blocks_count_lo;\t \n\t__le32\ts_r_blocks_count_lo;\t \n\t__le32\ts_free_blocks_count_lo;\t \n \t__le32\ts_free_inodes_count;\t \n\t__le32\ts_first_data_block;\t \n\t__le32\ts_log_block_size;\t \n\t__le32\ts_log_cluster_size;\t \n \t__le32\ts_blocks_per_group;\t \n\t__le32\ts_clusters_per_group;\t \n\t__le32\ts_inodes_per_group;\t \n\t__le32\ts_mtime;\t\t \n \t__le32\ts_wtime;\t\t \n\t__le16\ts_mnt_count;\t\t \n\t__le16\ts_max_mnt_count;\t \n\t__le16\ts_magic;\t\t \n\t__le16\ts_state;\t\t \n\t__le16\ts_errors;\t\t \n\t__le16\ts_minor_rev_level;\t \n \t__le32\ts_lastcheck;\t\t \n\t__le32\ts_checkinterval;\t \n\t__le32\ts_creator_os;\t\t \n\t__le32\ts_rev_level;\t\t \n \t__le16\ts_def_resuid;\t\t \n\t__le16\ts_def_resgid;\t\t \n\t \n\t__le32\ts_first_ino;\t\t \n\t__le16  s_inode_size;\t\t \n\t__le16\ts_block_group_nr;\t \n\t__le32\ts_feature_compat;\t \n \t__le32\ts_feature_incompat;\t \n\t__le32\ts_feature_ro_compat;\t \n \t__u8\ts_uuid[16];\t\t \n \tchar\ts_volume_name[EXT4_LABEL_MAX];\t \n \tchar\ts_last_mounted[64] __nonstring;\t \n \t__le32\ts_algorithm_usage_bitmap;  \n\t \n\t__u8\ts_prealloc_blocks;\t \n\t__u8\ts_prealloc_dir_blocks;\t \n\t__le16\ts_reserved_gdt_blocks;\t \n\t \n \t__u8\ts_journal_uuid[16];\t \n \t__le32\ts_journal_inum;\t\t \n\t__le32\ts_journal_dev;\t\t \n\t__le32\ts_last_orphan;\t\t \n\t__le32\ts_hash_seed[4];\t\t \n\t__u8\ts_def_hash_version;\t \n\t__u8\ts_jnl_backup_type;\n\t__le16  s_desc_size;\t\t \n \t__le32\ts_default_mount_opts;\n\t__le32\ts_first_meta_bg;\t \n\t__le32\ts_mkfs_time;\t\t \n\t__le32\ts_jnl_blocks[17];\t \n\t \n \t__le32\ts_blocks_count_hi;\t \n\t__le32\ts_r_blocks_count_hi;\t \n\t__le32\ts_free_blocks_count_hi;\t \n\t__le16\ts_min_extra_isize;\t \n\t__le16\ts_want_extra_isize; \t \n\t__le32\ts_flags;\t\t \n\t__le16  s_raid_stride;\t\t \n\t__le16  s_mmp_update_interval;   \n\t__le64  s_mmp_block;             \n\t__le32  s_raid_stripe_width;     \n\t__u8\ts_log_groups_per_flex;   \n\t__u8\ts_checksum_type;\t \n\t__u8\ts_encryption_level;\t \n\t__u8\ts_reserved_pad;\t\t \n\t__le64\ts_kbytes_written;\t \n\t__le32\ts_snapshot_inum;\t \n\t__le32\ts_snapshot_id;\t\t \n\t__le64\ts_snapshot_r_blocks_count;  \n\t__le32\ts_snapshot_list;\t \n#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)\n\t__le32\ts_error_count;\t\t \n\t__le32\ts_first_error_time;\t \n\t__le32\ts_first_error_ino;\t \n\t__le64\ts_first_error_block;\t \n\t__u8\ts_first_error_func[32] __nonstring;\t \n\t__le32\ts_first_error_line;\t \n\t__le32\ts_last_error_time;\t \n\t__le32\ts_last_error_ino;\t \n\t__le32\ts_last_error_line;\t \n\t__le64\ts_last_error_block;\t \n\t__u8\ts_last_error_func[32] __nonstring;\t \n#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)\n\t__u8\ts_mount_opts[64];\n\t__le32\ts_usr_quota_inum;\t \n\t__le32\ts_grp_quota_inum;\t \n\t__le32\ts_overhead_clusters;\t \n\t__le32\ts_backup_bgs[2];\t \n\t__u8\ts_encrypt_algos[4];\t \n\t__u8\ts_encrypt_pw_salt[16];\t \n\t__le32\ts_lpf_ino;\t\t \n\t__le32\ts_prj_quota_inum;\t \n\t__le32\ts_checksum_seed;\t \n\t__u8\ts_wtime_hi;\n\t__u8\ts_mtime_hi;\n\t__u8\ts_mkfs_time_hi;\n\t__u8\ts_lastcheck_hi;\n\t__u8\ts_first_error_time_hi;\n\t__u8\ts_last_error_time_hi;\n\t__u8\ts_first_error_errcode;\n\t__u8    s_last_error_errcode;\n\t__le16  s_encoding;\t\t \n\t__le16  s_encoding_flags;\t \n\t__le32  s_orphan_file_inum;\t \n\t__le32\ts_reserved[94];\t\t \n\t__le32\ts_checksum;\t\t \n};\n\n#define EXT4_S_ERR_LEN (EXT4_S_ERR_END - EXT4_S_ERR_START)\n\n#ifdef __KERNEL__\n\n \n#define EXT4_MAXQUOTAS 3\n\n#define EXT4_ENC_UTF8_12_1\t1\n\n \nenum ext4_journal_trigger_type {\n\tEXT4_JTR_ORPHAN_FILE,\n\tEXT4_JTR_NONE\t \n};\n\n#define EXT4_JOURNAL_TRIGGER_COUNT EXT4_JTR_NONE\n\nstruct ext4_journal_trigger {\n\tstruct jbd2_buffer_trigger_type tr_triggers;\n\tstruct super_block *sb;\n};\n\nstatic inline struct ext4_journal_trigger *EXT4_TRIGGER(\n\t\t\t\tstruct jbd2_buffer_trigger_type *trigger)\n{\n\treturn container_of(trigger, struct ext4_journal_trigger, tr_triggers);\n}\n\n#define EXT4_ORPHAN_BLOCK_MAGIC 0x0b10ca04\n\n \nstruct ext4_orphan_block_tail {\n\t__le32 ob_magic;\n\t__le32 ob_checksum;\n};\n\nstatic inline int ext4_inodes_per_orphan_block(struct super_block *sb)\n{\n\treturn (sb->s_blocksize - sizeof(struct ext4_orphan_block_tail)) /\n\t\t\tsizeof(u32);\n}\n\nstruct ext4_orphan_block {\n\tatomic_t ob_free_entries;\t \n\tstruct buffer_head *ob_bh;\t \n};\n\n \nstruct ext4_orphan_info {\n\tint of_blocks;\t\t\t \n\t__u32 of_csum_seed;\t\t \n\tstruct ext4_orphan_block *of_binfo;\t \n};\n\n \nstruct ext4_sb_info {\n\tunsigned long s_desc_size;\t \n\tunsigned long s_inodes_per_block; \n\tunsigned long s_blocks_per_group; \n\tunsigned long s_clusters_per_group;  \n\tunsigned long s_inodes_per_group; \n\tunsigned long s_itb_per_group;\t \n\tunsigned long s_gdb_count;\t \n\tunsigned long s_desc_per_block;\t \n\text4_group_t s_groups_count;\t \n\text4_group_t s_blockfile_groups; \n\tunsigned long s_overhead;   \n\tunsigned int s_cluster_ratio;\t \n\tunsigned int s_cluster_bits;\t \n\tloff_t s_bitmap_maxbytes;\t \n\tstruct buffer_head * s_sbh;\t \n\tstruct ext4_super_block *s_es;\t \n\tstruct buffer_head * __rcu *s_group_desc;\n\tunsigned int s_mount_opt;\n\tunsigned int s_mount_opt2;\n\tunsigned long s_mount_flags;\n\tunsigned int s_def_mount_opt;\n\tunsigned int s_def_mount_opt2;\n\text4_fsblk_t s_sb_block;\n\tatomic64_t s_resv_clusters;\n\tkuid_t s_resuid;\n\tkgid_t s_resgid;\n\tunsigned short s_mount_state;\n\tunsigned short s_pad;\n\tint s_addr_per_block_bits;\n\tint s_desc_per_block_bits;\n\tint s_inode_size;\n\tint s_first_ino;\n\tunsigned int s_inode_readahead_blks;\n\tunsigned int s_inode_goal;\n\tu32 s_hash_seed[4];\n\tint s_def_hash_version;\n\tint s_hash_unsigned;\t \n\tstruct percpu_counter s_freeclusters_counter;\n\tstruct percpu_counter s_freeinodes_counter;\n\tstruct percpu_counter s_dirs_counter;\n\tstruct percpu_counter s_dirtyclusters_counter;\n\tstruct percpu_counter s_sra_exceeded_retry_limit;\n\tstruct blockgroup_lock *s_blockgroup_lock;\n\tstruct proc_dir_entry *s_proc;\n\tstruct kobject s_kobj;\n\tstruct completion s_kobj_unregister;\n\tstruct super_block *s_sb;\n\tstruct buffer_head *s_mmp_bh;\n\n\t \n\tstruct journal_s *s_journal;\n\tunsigned long s_ext4_flags;\t\t \n\tstruct mutex s_orphan_lock;\t \n\tstruct list_head s_orphan;\t \n\tstruct ext4_orphan_info s_orphan_info;\n\tunsigned long s_commit_interval;\n\tu32 s_max_batch_time;\n\tu32 s_min_batch_time;\n\tstruct block_device *s_journal_bdev;\n#ifdef CONFIG_QUOTA\n\t \n\tchar __rcu *s_qf_names[EXT4_MAXQUOTAS];\n\tint s_jquota_fmt;\t\t\t \n#endif\n\tunsigned int s_want_extra_isize;  \n\tstruct ext4_system_blocks __rcu *s_system_blks;\n\n#ifdef EXTENTS_STATS\n\t \n\tunsigned long s_ext_min;\n\tunsigned long s_ext_max;\n\tunsigned long s_depth_max;\n\tspinlock_t s_ext_stats_lock;\n\tunsigned long s_ext_blocks;\n\tunsigned long s_ext_extents;\n#endif\n\n\t \n\tstruct ext4_group_info ** __rcu *s_group_info;\n\tstruct inode *s_buddy_cache;\n\tspinlock_t s_md_lock;\n\tunsigned short *s_mb_offsets;\n\tunsigned int *s_mb_maxs;\n\tunsigned int s_group_info_size;\n\tunsigned int s_mb_free_pending;\n\tstruct list_head s_freed_data_list;\t \n\tstruct list_head s_discard_list;\n\tstruct work_struct s_discard_work;\n\tatomic_t s_retry_alloc_pending;\n\tstruct list_head *s_mb_avg_fragment_size;\n\trwlock_t *s_mb_avg_fragment_size_locks;\n\tstruct list_head *s_mb_largest_free_orders;\n\trwlock_t *s_mb_largest_free_orders_locks;\n\n\t \n\tunsigned long s_stripe;\n\tunsigned int s_mb_max_linear_groups;\n\tunsigned int s_mb_stream_request;\n\tunsigned int s_mb_max_to_scan;\n\tunsigned int s_mb_min_to_scan;\n\tunsigned int s_mb_stats;\n\tunsigned int s_mb_order2_reqs;\n\tunsigned int s_mb_group_prealloc;\n\tunsigned int s_max_dir_size_kb;\n\t \n\tunsigned long s_mb_last_group;\n\tunsigned long s_mb_last_start;\n\tunsigned int s_mb_prefetch;\n\tunsigned int s_mb_prefetch_limit;\n\tunsigned int s_mb_best_avail_max_trim_order;\n\n\t \n\tatomic_t s_bal_reqs;\t \n\tatomic_t s_bal_success;\t \n\tatomic_t s_bal_allocated;\t \n\tatomic_t s_bal_ex_scanned;\t \n\tatomic_t s_bal_cX_ex_scanned[EXT4_MB_NUM_CRS];\t \n\tatomic_t s_bal_groups_scanned;\t \n\tatomic_t s_bal_goals;\t \n\tatomic_t s_bal_len_goals;\t \n\tatomic_t s_bal_breaks;\t \n\tatomic_t s_bal_2orders;\t \n\tatomic_t s_bal_p2_aligned_bad_suggestions;\n\tatomic_t s_bal_goal_fast_bad_suggestions;\n\tatomic_t s_bal_best_avail_bad_suggestions;\n\tatomic64_t s_bal_cX_groups_considered[EXT4_MB_NUM_CRS];\n\tatomic64_t s_bal_cX_hits[EXT4_MB_NUM_CRS];\n\tatomic64_t s_bal_cX_failed[EXT4_MB_NUM_CRS];\t\t \n\tatomic_t s_mb_buddies_generated;\t \n\tatomic64_t s_mb_generation_time;\n\tatomic_t s_mb_lost_chunks;\n\tatomic_t s_mb_preallocated;\n\tatomic_t s_mb_discarded;\n\tatomic_t s_lock_busy;\n\n\t \n\tstruct ext4_locality_group __percpu *s_locality_groups;\n\n\t \n\tunsigned long s_sectors_written_start;\n\tu64 s_kbytes_written;\n\n\t \n\tunsigned int s_extent_max_zeroout_kb;\n\n\tunsigned int s_log_groups_per_flex;\n\tstruct flex_groups * __rcu *s_flex_groups;\n\text4_group_t s_flex_groups_allocated;\n\n\t \n\tstruct workqueue_struct *rsv_conversion_wq;\n\n\t \n\tstruct timer_list s_err_report;\n\n\t \n\tstruct ext4_li_request *s_li_request;\n\t \n\tunsigned int s_li_wait_mult;\n\n\t \n\tstruct task_struct *s_mmp_tsk;\n\n\t \n\tunsigned long s_last_trim_minblks;\n\n\t \n\tstruct crypto_shash *s_chksum_driver;\n\n\t \n\t__u32 s_csum_seed;\n\n\t \n\tstruct shrinker s_es_shrinker;\n\tstruct list_head s_es_list;\t \n\tlong s_es_nr_inode;\n\tstruct ext4_es_stats s_es_stats;\n\tstruct mb_cache *s_ea_block_cache;\n\tstruct mb_cache *s_ea_inode_cache;\n\tspinlock_t s_es_lock ____cacheline_aligned_in_smp;\n\n\t \n\tstruct ext4_journal_trigger s_journal_triggers[EXT4_JOURNAL_TRIGGER_COUNT];\n\n\t \n\tstruct ratelimit_state s_err_ratelimit_state;\n\tstruct ratelimit_state s_warning_ratelimit_state;\n\tstruct ratelimit_state s_msg_ratelimit_state;\n\tatomic_t s_warning_count;\n\tatomic_t s_msg_count;\n\n\t \n\tstruct fscrypt_dummy_policy s_dummy_enc_policy;\n\n\t \n\tstruct percpu_rw_semaphore s_writepages_rwsem;\n\tstruct dax_device *s_daxdev;\n\tu64 s_dax_part_off;\n#ifdef CONFIG_EXT4_DEBUG\n\tunsigned long s_simulate_fail;\n#endif\n\t \n\terrseq_t s_bdev_wb_err;\n\tspinlock_t s_bdev_wb_lock;\n\n\t \n\tspinlock_t s_error_lock;\n\tint s_add_error_count;\n\tint s_first_error_code;\n\t__u32 s_first_error_line;\n\t__u32 s_first_error_ino;\n\t__u64 s_first_error_block;\n\tconst char *s_first_error_func;\n\ttime64_t s_first_error_time;\n\tint s_last_error_code;\n\t__u32 s_last_error_line;\n\t__u32 s_last_error_ino;\n\t__u64 s_last_error_block;\n\tconst char *s_last_error_func;\n\ttime64_t s_last_error_time;\n\t \n\tstruct work_struct s_sb_upd_work;\n\n\t \n\tatomic_t s_fc_subtid;\n\n\t \n#define FC_Q_MAIN\t0\n#define FC_Q_STAGING\t1\n\tstruct list_head s_fc_q[2];\t \n\tstruct list_head s_fc_dentry_q[2];\t \n\tunsigned int s_fc_bytes;\n\t \n\tspinlock_t s_fc_lock;\n\tstruct buffer_head *s_fc_bh;\n\tstruct ext4_fc_stats s_fc_stats;\n\ttid_t s_fc_ineligible_tid;\n#ifdef CONFIG_EXT4_DEBUG\n\tint s_fc_debug_max_replay;\n#endif\n\tstruct ext4_fc_replay_state s_fc_replay_state;\n};\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}\n\nstatic inline int ext4_writepages_down_read(struct super_block *sb)\n{\n\tpercpu_down_read(&EXT4_SB(sb)->s_writepages_rwsem);\n\treturn memalloc_nofs_save();\n}\n\nstatic inline void ext4_writepages_up_read(struct super_block *sb, int ctx)\n{\n\tmemalloc_nofs_restore(ctx);\n\tpercpu_up_read(&EXT4_SB(sb)->s_writepages_rwsem);\n}\n\nstatic inline int ext4_writepages_down_write(struct super_block *sb)\n{\n\tpercpu_down_write(&EXT4_SB(sb)->s_writepages_rwsem);\n\treturn memalloc_nofs_save();\n}\n\nstatic inline void ext4_writepages_up_write(struct super_block *sb, int ctx)\n{\n\tmemalloc_nofs_restore(ctx);\n\tpercpu_up_write(&EXT4_SB(sb)->s_writepages_rwsem);\n}\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}\n\n \n#define sbi_array_rcu_deref(sbi, field, index)\t\t\t\t   \\\n({\t\t\t\t\t\t\t\t\t   \\\n\ttypeof(*((sbi)->field)) _v;\t\t\t\t\t   \\\n\trcu_read_lock();\t\t\t\t\t\t   \\\n\t_v = ((typeof(_v)*)rcu_dereference((sbi)->field))[index];\t   \\\n\trcu_read_unlock();\t\t\t\t\t\t   \\\n\t_v;\t\t\t\t\t\t\t\t   \\\n})\n\n \nenum {\n\tEXT4_MF_MNTDIR_SAMPLED,\n\tEXT4_MF_FC_INELIGIBLE\t \n};\n\nstatic inline void ext4_set_mount_flag(struct super_block *sb, int bit)\n{\n\tset_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\nstatic inline void ext4_clear_mount_flag(struct super_block *sb, int bit)\n{\n\tclear_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\nstatic inline int ext4_test_mount_flag(struct super_block *sb, int bit)\n{\n\treturn test_bit(bit, &EXT4_SB(sb)->s_mount_flags);\n}\n\n\n \n#define EXT4_SIM_BBITMAP_EIO\t1\n#define EXT4_SIM_BBITMAP_CRC\t2\n#define EXT4_SIM_IBITMAP_EIO\t3\n#define EXT4_SIM_IBITMAP_CRC\t4\n#define EXT4_SIM_INODE_EIO\t5\n#define EXT4_SIM_INODE_CRC\t6\n#define EXT4_SIM_DIRBLOCK_EIO\t7\n#define EXT4_SIM_DIRBLOCK_CRC\t8\n\nstatic inline bool ext4_simulate_fail(struct super_block *sb,\n\t\t\t\t     unsigned long code)\n{\n#ifdef CONFIG_EXT4_DEBUG\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (unlikely(sbi->s_simulate_fail == code)) {\n\t\tsbi->s_simulate_fail = 0;\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic inline void ext4_simulate_fail_bh(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t unsigned long code)\n{\n\tif (!IS_ERR(bh) && ext4_simulate_fail(sb, code))\n\t\tclear_buffer_uptodate(bh);\n}\n\n \n#define EXT4_ERR_UNKNOWN\t 1\n#define EXT4_ERR_EIO\t\t 2\n#define EXT4_ERR_ENOMEM\t\t 3\n#define EXT4_ERR_EFSBADCRC\t 4\n#define EXT4_ERR_EFSCORRUPTED\t 5\n#define EXT4_ERR_ENOSPC\t\t 6\n#define EXT4_ERR_ENOKEY\t\t 7\n#define EXT4_ERR_EROFS\t\t 8\n#define EXT4_ERR_EFBIG\t\t 9\n#define EXT4_ERR_EEXIST\t\t10\n#define EXT4_ERR_ERANGE\t\t11\n#define EXT4_ERR_EOVERFLOW\t12\n#define EXT4_ERR_EBUSY\t\t13\n#define EXT4_ERR_ENOTDIR\t14\n#define EXT4_ERR_ENOTEMPTY\t15\n#define EXT4_ERR_ESHUTDOWN\t16\n#define EXT4_ERR_EFAULT\t\t17\n\n \nenum {\n\tEXT4_STATE_NEW,\t\t\t \n\tEXT4_STATE_XATTR,\t\t \n\tEXT4_STATE_NO_EXPAND,\t\t \n\tEXT4_STATE_DA_ALLOC_CLOSE,\t \n\tEXT4_STATE_EXT_MIGRATE,\t\t \n\tEXT4_STATE_NEWENTRY,\t\t \n\tEXT4_STATE_MAY_INLINE_DATA,\t \n\tEXT4_STATE_EXT_PRECACHED,\t \n\tEXT4_STATE_LUSTRE_EA_INODE,\t \n\tEXT4_STATE_VERITY_IN_PROGRESS,\t \n\tEXT4_STATE_FC_COMMITTING,\t \n\tEXT4_STATE_ORPHAN_FILE,\t\t \n};\n\n#define EXT4_INODE_BIT_FNS(name, field, offset)\t\t\t\t\\\nstatic inline int ext4_test_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_set_inode_##name(struct inode *inode, int bit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tset_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void ext4_clear_inode_##name(struct inode *inode, int bit) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tclear_bit(bit + (offset), &EXT4_I(inode)->i_##field);\t\t\\\n}\n\n \nstatic inline int ext4_test_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_flag(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_flag(struct inode *inode, int bit);\nEXT4_INODE_BIT_FNS(flag, flags, 0)\n\n \nstatic inline int ext4_test_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_set_inode_state(struct inode *inode, int bit);\nstatic inline void ext4_clear_inode_state(struct inode *inode, int bit);\n#if (BITS_PER_LONG < 64)\nEXT4_INODE_BIT_FNS(state, state_flags, 0)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t(ei)->i_state_flags = 0;\n}\n#else\nEXT4_INODE_BIT_FNS(state, flags, 32)\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t \n}\n#endif\n#else\n \n#define EXT4_SB(sb)\t(sb)\n#endif\n\nstatic inline bool ext4_verity_in_progress(struct inode *inode)\n{\n\treturn IS_ENABLED(CONFIG_FS_VERITY) &&\n\t       ext4_test_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n}\n\n#define NEXT_ORPHAN(inode) EXT4_I(inode)->i_dtime\n\n \n#define EXT4_OS_LINUX\t\t0\n#define EXT4_OS_HURD\t\t1\n#define EXT4_OS_MASIX\t\t2\n#define EXT4_OS_FREEBSD\t\t3\n#define EXT4_OS_LITES\t\t4\n\n \n#define EXT4_GOOD_OLD_REV\t0\t \n#define EXT4_DYNAMIC_REV\t1\t \n\n#define EXT4_MAX_SUPP_REV\tEXT4_DYNAMIC_REV\n\n#define EXT4_GOOD_OLD_INODE_SIZE 128\n\n#define EXT4_EXTRA_TIMESTAMP_MAX\t(((s64)1 << 34) - 1  + S32_MIN)\n#define EXT4_NON_EXTRA_TIMESTAMP_MAX\tS32_MAX\n#define EXT4_TIMESTAMP_MIN\t\tS32_MIN\n\n \n\n#define EXT4_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT4_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT4_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT4_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT4_FEATURE_COMPAT_RESIZE_INODE\t0x0010\n#define EXT4_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n#define EXT4_FEATURE_COMPAT_SPARSE_SUPER2\t0x0200\n \n#define EXT4_FEATURE_COMPAT_FAST_COMMIT\t\t0x0400\n#define EXT4_FEATURE_COMPAT_STABLE_INODES\t0x0800\n#define EXT4_FEATURE_COMPAT_ORPHAN_FILE\t\t0x1000\t \n\n#define EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT4_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT4_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT4_FEATURE_RO_COMPAT_HUGE_FILE        0x0008\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK\t0x0020\n#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE\t0x0040\n#define EXT4_FEATURE_RO_COMPAT_QUOTA\t\t0x0100\n#define EXT4_FEATURE_RO_COMPAT_BIGALLOC\t\t0x0200\n \n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_READONLY\t\t0x1000\n#define EXT4_FEATURE_RO_COMPAT_PROJECT\t\t0x2000\n#define EXT4_FEATURE_RO_COMPAT_VERITY\t\t0x8000\n#define EXT4_FEATURE_RO_COMPAT_ORPHAN_PRESENT\t0x10000  \n\n#define EXT4_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT4_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT4_FEATURE_INCOMPAT_RECOVER\t\t0x0004  \n#define EXT4_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008  \n#define EXT4_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT4_FEATURE_INCOMPAT_EXTENTS\t\t0x0040  \n#define EXT4_FEATURE_INCOMPAT_64BIT\t\t0x0080\n#define EXT4_FEATURE_INCOMPAT_MMP               0x0100\n#define EXT4_FEATURE_INCOMPAT_FLEX_BG\t\t0x0200\n#define EXT4_FEATURE_INCOMPAT_EA_INODE\t\t0x0400  \n#define EXT4_FEATURE_INCOMPAT_DIRDATA\t\t0x1000  \n#define EXT4_FEATURE_INCOMPAT_CSUM_SEED\t\t0x2000\n#define EXT4_FEATURE_INCOMPAT_LARGEDIR\t\t0x4000  \n#define EXT4_FEATURE_INCOMPAT_INLINE_DATA\t0x8000  \n#define EXT4_FEATURE_INCOMPAT_ENCRYPT\t\t0x10000\n#define EXT4_FEATURE_INCOMPAT_CASEFOLD\t\t0x20000\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\n\n#define EXT4_FEATURE_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_RO_COMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_ro_compat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_RO_COMPAT_##flagname); \\\n}\n\n#define EXT4_FEATURE_INCOMPAT_FUNCS(name, flagname) \\\nstatic inline bool ext4_has_feature_##name(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname)) != 0); \\\n} \\\nstatic inline void ext4_set_feature_##name(struct super_block *sb) \\\n{ \\\n\text4_update_dynamic_rev(sb); \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat |= \\\n\t\tcpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n} \\\nstatic inline void ext4_clear_feature_##name(struct super_block *sb) \\\n{ \\\n\tEXT4_SB(sb)->s_es->s_feature_incompat &= \\\n\t\t~cpu_to_le32(EXT4_FEATURE_INCOMPAT_##flagname); \\\n}\n\nEXT4_FEATURE_COMPAT_FUNCS(dir_prealloc,\t\tDIR_PREALLOC)\nEXT4_FEATURE_COMPAT_FUNCS(imagic_inodes,\tIMAGIC_INODES)\nEXT4_FEATURE_COMPAT_FUNCS(journal,\t\tHAS_JOURNAL)\nEXT4_FEATURE_COMPAT_FUNCS(xattr,\t\tEXT_ATTR)\nEXT4_FEATURE_COMPAT_FUNCS(resize_inode,\t\tRESIZE_INODE)\nEXT4_FEATURE_COMPAT_FUNCS(dir_index,\t\tDIR_INDEX)\nEXT4_FEATURE_COMPAT_FUNCS(sparse_super2,\tSPARSE_SUPER2)\nEXT4_FEATURE_COMPAT_FUNCS(fast_commit,\t\tFAST_COMMIT)\nEXT4_FEATURE_COMPAT_FUNCS(stable_inodes,\tSTABLE_INODES)\nEXT4_FEATURE_COMPAT_FUNCS(orphan_file,\t\tORPHAN_FILE)\n\nEXT4_FEATURE_RO_COMPAT_FUNCS(sparse_super,\tSPARSE_SUPER)\nEXT4_FEATURE_RO_COMPAT_FUNCS(large_file,\tLARGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(btree_dir,\t\tBTREE_DIR)\nEXT4_FEATURE_RO_COMPAT_FUNCS(huge_file,\t\tHUGE_FILE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(gdt_csum,\t\tGDT_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(dir_nlink,\t\tDIR_NLINK)\nEXT4_FEATURE_RO_COMPAT_FUNCS(extra_isize,\tEXTRA_ISIZE)\nEXT4_FEATURE_RO_COMPAT_FUNCS(quota,\t\tQUOTA)\nEXT4_FEATURE_RO_COMPAT_FUNCS(bigalloc,\t\tBIGALLOC)\nEXT4_FEATURE_RO_COMPAT_FUNCS(metadata_csum,\tMETADATA_CSUM)\nEXT4_FEATURE_RO_COMPAT_FUNCS(readonly,\t\tREADONLY)\nEXT4_FEATURE_RO_COMPAT_FUNCS(project,\t\tPROJECT)\nEXT4_FEATURE_RO_COMPAT_FUNCS(verity,\t\tVERITY)\nEXT4_FEATURE_RO_COMPAT_FUNCS(orphan_present,\tORPHAN_PRESENT)\n\nEXT4_FEATURE_INCOMPAT_FUNCS(compression,\tCOMPRESSION)\nEXT4_FEATURE_INCOMPAT_FUNCS(filetype,\t\tFILETYPE)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_needs_recovery,\tRECOVER)\nEXT4_FEATURE_INCOMPAT_FUNCS(journal_dev,\tJOURNAL_DEV)\nEXT4_FEATURE_INCOMPAT_FUNCS(meta_bg,\t\tMETA_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(extents,\t\tEXTENTS)\nEXT4_FEATURE_INCOMPAT_FUNCS(64bit,\t\t64BIT)\nEXT4_FEATURE_INCOMPAT_FUNCS(mmp,\t\tMMP)\nEXT4_FEATURE_INCOMPAT_FUNCS(flex_bg,\t\tFLEX_BG)\nEXT4_FEATURE_INCOMPAT_FUNCS(ea_inode,\t\tEA_INODE)\nEXT4_FEATURE_INCOMPAT_FUNCS(dirdata,\t\tDIRDATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(csum_seed,\t\tCSUM_SEED)\nEXT4_FEATURE_INCOMPAT_FUNCS(largedir,\t\tLARGEDIR)\nEXT4_FEATURE_INCOMPAT_FUNCS(inline_data,\tINLINE_DATA)\nEXT4_FEATURE_INCOMPAT_FUNCS(encrypt,\t\tENCRYPT)\nEXT4_FEATURE_INCOMPAT_FUNCS(casefold,\t\tCASEFOLD)\n\n#define EXT2_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT2_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT2_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT3_FEATURE_COMPAT_SUPP\tEXT4_FEATURE_COMPAT_EXT_ATTR\n#define EXT3_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG)\n#define EXT3_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR)\n\n#define EXT4_FEATURE_COMPAT_SUPP\t(EXT4_FEATURE_COMPAT_EXT_ATTR| \\\n\t\t\t\t\t EXT4_FEATURE_COMPAT_ORPHAN_FILE)\n#define EXT4_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EXTENTS| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_64BIT| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_FLEX_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EA_INODE| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_MMP | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_INLINE_DATA | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_ENCRYPT | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CASEFOLD | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_CSUM_SEED | \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_LARGEDIR)\n#define EXT4_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_GDT_CSUM| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_DIR_NLINK | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_HUGE_FILE |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BIGALLOC |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_METADATA_CSUM|\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_QUOTA |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_PROJECT |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_VERITY |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_ORPHAN_PRESENT)\n\n#define EXTN_FEATURE_FUNCS(ver) \\\nstatic inline bool ext4_has_unknown_ext##ver##_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_ro_compat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_ro_compat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_RO_COMPAT_SUPP)) != 0); \\\n} \\\nstatic inline bool ext4_has_unknown_ext##ver##_incompat_features(struct super_block *sb) \\\n{ \\\n\treturn ((EXT4_SB(sb)->s_es->s_feature_incompat & \\\n\t\tcpu_to_le32(~EXT##ver##_FEATURE_INCOMPAT_SUPP)) != 0); \\\n}\n\nEXTN_FEATURE_FUNCS(2)\nEXTN_FEATURE_FUNCS(3)\nEXTN_FEATURE_FUNCS(4)\n\nstatic inline bool ext4_has_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_compat != 0);\n}\nstatic inline bool ext4_has_ro_compat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_ro_compat != 0);\n}\nstatic inline bool ext4_has_incompat_features(struct super_block *sb)\n{\n\treturn (EXT4_SB(sb)->s_es->s_feature_incompat != 0);\n}\n\nextern int ext4_feature_set_ok(struct super_block *sb, int readonly);\n\n \n#define EXT4_FLAGS_RESIZING\t0\n#define EXT4_FLAGS_SHUTDOWN\t1\n#define EXT4_FLAGS_BDEV_IS_DAX\t2\n\nstatic inline int ext4_forced_shutdown(struct super_block *sb)\n{\n\treturn test_bit(EXT4_FLAGS_SHUTDOWN, &EXT4_SB(sb)->s_ext4_flags);\n}\n\n \n#define\tEXT4_DEF_RESUID\t\t0\n#define\tEXT4_DEF_RESGID\t\t0\n\n \n#define\tEXT4_DEF_PROJID\t\t0\n\n#define EXT4_DEF_INODE_READAHEAD_BLKS\t32\n\n \n#define EXT4_DEFM_DEBUG\t\t0x0001\n#define EXT4_DEFM_BSDGROUPS\t0x0002\n#define EXT4_DEFM_XATTR_USER\t0x0004\n#define EXT4_DEFM_ACL\t\t0x0008\n#define EXT4_DEFM_UID16\t\t0x0010\n#define EXT4_DEFM_JMODE\t\t0x0060\n#define EXT4_DEFM_JMODE_DATA\t0x0020\n#define EXT4_DEFM_JMODE_ORDERED\t0x0040\n#define EXT4_DEFM_JMODE_WBACK\t0x0060\n#define EXT4_DEFM_NOBARRIER\t0x0100\n#define EXT4_DEFM_BLOCK_VALIDITY 0x0200\n#define EXT4_DEFM_DISCARD\t0x0400\n#define EXT4_DEFM_NODELALLOC\t0x0800\n\n \n#define EXT4_DEF_MIN_BATCH_TIME\t0\n#define EXT4_DEF_MAX_BATCH_TIME\t15000  \n\n \n#define EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\t4\n\n \n#define EXT4_NAME_LEN 255\n \n#define EXT4_BASE_DIR_LEN (sizeof(struct ext4_dir_entry_2) - EXT4_NAME_LEN)\n\nstruct ext4_dir_entry {\n\t__le32\tinode;\t\t\t \n\t__le16\trec_len;\t\t \n\t__le16\tname_len;\t\t \n\tchar\tname[EXT4_NAME_LEN];\t \n};\n\n\n \nstruct ext4_dir_entry_hash {\n\t__le32 hash;\n\t__le32 minor_hash;\n};\n\n \nstruct ext4_dir_entry_2 {\n\t__le32\tinode;\t\t\t \n\t__le16\trec_len;\t\t \n\t__u8\tname_len;\t\t \n\t__u8\tfile_type;\t\t \n\tchar\tname[EXT4_NAME_LEN];\t \n};\n\n \n#define EXT4_DIRENT_HASHES(entry) \\\n\t((struct ext4_dir_entry_hash *) \\\n\t\t(((void *)(entry)) + \\\n\t\t((8 + (entry)->name_len + EXT4_DIR_ROUND) & ~EXT4_DIR_ROUND)))\n#define EXT4_DIRENT_HASH(entry) le32_to_cpu(EXT4_DIRENT_HASHES(de)->hash)\n#define EXT4_DIRENT_MINOR_HASH(entry) \\\n\t\tle32_to_cpu(EXT4_DIRENT_HASHES(de)->minor_hash)\n\nstatic inline bool ext4_hash_in_dirent(const struct inode *inode)\n{\n\treturn IS_CASEFOLDED(inode) && IS_ENCRYPTED(inode);\n}\n\n \nstruct ext4_dir_entry_tail {\n\t__le32\tdet_reserved_zero1;\t \n\t__le16\tdet_rec_len;\t\t \n\t__u8\tdet_reserved_zero2;\t \n\t__u8\tdet_reserved_ft;\t \n\t__le32\tdet_checksum;\t\t \n};\n\n#define EXT4_DIRENT_TAIL(block, blocksize) \\\n\t((struct ext4_dir_entry_tail *)(((void *)(block)) + \\\n\t\t\t\t\t((blocksize) - \\\n\t\t\t\t\t sizeof(struct ext4_dir_entry_tail))))\n\n \n#define EXT4_FT_UNKNOWN\t\t0\n#define EXT4_FT_REG_FILE\t1\n#define EXT4_FT_DIR\t\t2\n#define EXT4_FT_CHRDEV\t\t3\n#define EXT4_FT_BLKDEV\t\t4\n#define EXT4_FT_FIFO\t\t5\n#define EXT4_FT_SOCK\t\t6\n#define EXT4_FT_SYMLINK\t\t7\n\n#define EXT4_FT_MAX\t\t8\n\n#define EXT4_FT_DIR_CSUM\t0xDE\n\n \n#define EXT4_DIR_PAD\t\t\t4\n#define EXT4_DIR_ROUND\t\t\t(EXT4_DIR_PAD - 1)\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\n \nstatic inline unsigned int ext4_dir_rec_len(__u8 name_len,\n\t\t\t\t\t\tconst struct inode *dir)\n{\n\tint rec_len = (name_len + 8 + EXT4_DIR_ROUND);\n\n\tif (dir && ext4_hash_in_dirent(dir))\n\t\trec_len += sizeof(struct ext4_dir_entry_hash);\n\treturn (rec_len & ~EXT4_DIR_ROUND);\n}\n\n \nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}\n\nstatic inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)\n{\n\tBUG_ON((len > blocksize) || (blocksize > (1 << 18)) || (len & 3));\n#if (PAGE_SIZE >= 65536)\n\tif (len < 65536)\n\t\treturn cpu_to_le16(len);\n\tif (len == blocksize) {\n\t\tif (blocksize == 65536)\n\t\t\treturn cpu_to_le16(EXT4_MAX_REC_LEN);\n\t\telse\n\t\t\treturn cpu_to_le16(0);\n\t}\n\treturn cpu_to_le16((len & 65532) | ((len >> 16) & 3));\n#else\n\treturn cpu_to_le16(len);\n#endif\n}\n\n \n\n#define is_dx(dir) (ext4_has_feature_dir_index((dir)->i_sb) && \\\n\t\t    ext4_test_inode_flag((dir), EXT4_INODE_INDEX))\n#define EXT4_DIR_LINK_MAX(dir) unlikely((dir)->i_nlink >= EXT4_LINK_MAX && \\\n\t\t    !(ext4_has_feature_dir_nlink((dir)->i_sb) && is_dx(dir)))\n#define EXT4_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)\n\n \n\n#define DX_HASH_LEGACY\t\t\t0\n#define DX_HASH_HALF_MD4\t\t1\n#define DX_HASH_TEA\t\t\t2\n#define DX_HASH_LEGACY_UNSIGNED\t\t3\n#define DX_HASH_HALF_MD4_UNSIGNED\t4\n#define DX_HASH_TEA_UNSIGNED\t\t5\n#define DX_HASH_SIPHASH\t\t\t6\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\tBUG_ON(crypto_shash_update(&desc.shash, address, length));\n\n\treturn *(u32 *)desc.ctx;\n}\n\n#ifdef __KERNEL__\n\n \nstruct dx_hash_info\n{\n\tu32\t\thash;\n\tu32\t\tminor_hash;\n\tint\t\thash_version;\n\tu32\t\t*seed;\n};\n\n\n \n#define EXT4_HTREE_EOF_32BIT   ((1UL  << (32 - 1)) - 1)\n#define EXT4_HTREE_EOF_64BIT   ((1ULL << (64 - 1)) - 1)\n\n\n \n#define HASH_NB_ALWAYS\t\t1\n\nstruct ext4_filename {\n\tconst struct qstr *usr_fname;\n\tstruct fscrypt_str disk_name;\n\tstruct dx_hash_info hinfo;\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_str crypto_buf;\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tstruct fscrypt_str cf_name;\n#endif\n};\n\n#define fname_name(p) ((p)->disk_name.name)\n#define fname_usr_name(p) ((p)->usr_fname->name)\n#define fname_len(p)  ((p)->disk_name.len)\n\n \nstruct ext4_iloc\n{\n\tstruct buffer_head *bh;\n\tunsigned long offset;\n\text4_group_t block_group;\n};\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}\n\nstatic inline bool ext4_is_quota_file(struct inode *inode)\n{\n\treturn IS_NOQUOTA(inode) &&\n\t       !(EXT4_I(inode)->i_flags & EXT4_EA_INODE_FL);\n}\n\n \nstruct dir_private_info {\n\tstruct rb_root\troot;\n\tstruct rb_node\t*curr_node;\n\tstruct fname\t*extra_fname;\n\tloff_t\t\tlast_pos;\n\t__u32\t\tcurr_hash;\n\t__u32\t\tcurr_minor_hash;\n\t__u32\t\tnext_hash;\n};\n\n \nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}\n\n \n#define ERR_BAD_DX_DIR\t(-(MAX_ERRNO - 1))\n\n \n#define\tEXT4_HTREE_LEVEL_COMPAT\t2\n#define\tEXT4_HTREE_LEVEL\t3\n\nstatic inline int ext4_dir_htree_level(struct super_block *sb)\n{\n\treturn ext4_has_feature_largedir(sb) ?\n\t\tEXT4_HTREE_LEVEL : EXT4_HTREE_LEVEL_COMPAT;\n}\n\n \n#define EXT4_DEF_LI_WAIT_MULT\t\t\t10\n#define EXT4_DEF_LI_MAX_START_DELAY\t\t5\n#define EXT4_LAZYINIT_QUIT\t\t\t0x0001\n#define EXT4_LAZYINIT_RUNNING\t\t\t0x0002\n\n \nstruct ext4_lazy_init {\n\tunsigned long\t\tli_state;\n\tstruct list_head\tli_request_list;\n\tstruct mutex\t\tli_list_mtx;\n};\n\nenum ext4_li_mode {\n\tEXT4_LI_MODE_PREFETCH_BBITMAP,\n\tEXT4_LI_MODE_ITABLE,\n};\n\nstruct ext4_li_request {\n\tstruct super_block\t*lr_super;\n\tenum ext4_li_mode\tlr_mode;\n\text4_group_t\t\tlr_first_not_zeroed;\n\text4_group_t\t\tlr_next_group;\n\tstruct list_head\tlr_request;\n\tunsigned long\t\tlr_next_sched;\n\tunsigned long\t\tlr_timeout;\n};\n\nstruct ext4_features {\n\tstruct kobject f_kobj;\n\tstruct completion f_kobj_unregister;\n};\n\n \n#define EXT4_MMP_MAGIC     0x004D4D50U  \n#define EXT4_MMP_SEQ_CLEAN 0xFF4D4D50U  \n#define EXT4_MMP_SEQ_FSCK  0xE24D4D50U  \n#define EXT4_MMP_SEQ_MAX   0xE24D4D4FU  \n\nstruct mmp_struct {\n\t__le32\tmmp_magic;\t\t \n\t__le32\tmmp_seq;\t\t \n\n\t \n\t__le64\tmmp_time;\t\t \n\tchar\tmmp_nodename[64];\t \n\tchar\tmmp_bdevname[32];\t \n\n\t \n\t__le16\tmmp_check_interval;\n\n\t__le16\tmmp_pad1;\n\t__le32\tmmp_pad2[226];\n\t__le32\tmmp_checksum;\t\t \n};\n\n \nstruct mmpd_data {\n\tstruct buffer_head *bh;  \n\tstruct super_block *sb;   \n};\n\n \n#define EXT4_MMP_CHECK_MULT\t\t2UL\n\n \n#define EXT4_MMP_MIN_CHECK_INTERVAL\t5UL\n\n \n#define EXT4_MMP_MAX_CHECK_INTERVAL\t300UL\n\n \n\n \n# define NORET_TYPE\t \n# define ATTRIB_NORET\t__attribute__((noreturn))\n# define NORET_AND\tnoreturn,\n\n \nextern unsigned int ext4_count_free(char *bitmap, unsigned numchars);\nvoid ext4_inode_bitmap_csum_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh, int sz);\nint ext4_inode_bitmap_csum_verify(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh, int sz);\nvoid ext4_block_bitmap_csum_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh);\nint ext4_block_bitmap_csum_verify(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *gdp,\n\t\t\t\t  struct buffer_head *bh);\n\n \nextern void ext4_get_group_no_and_offset(struct super_block *sb,\n\t\t\t\t\t ext4_fsblk_t blocknr,\n\t\t\t\t\t ext4_group_t *blockgrpp,\n\t\t\t\t\t ext4_grpblk_t *offsetp);\nextern ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t\t  ext4_fsblk_t block);\n\nextern int ext4_bg_has_super(struct super_block *sb, ext4_group_t group);\nextern unsigned long ext4_bg_num_gdb(struct super_block *sb,\n\t\t\text4_group_t group);\nextern ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t\t ext4_fsblk_t goal,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t unsigned long *count,\n\t\t\t\t\t int *errp);\nextern int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t\t    s64 nclusters, unsigned int flags);\nextern ext4_fsblk_t ext4_count_free_clusters(struct super_block *);\nextern struct ext4_group_desc * ext4_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern struct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t\t   ext4_group_t group);\nextern int ext4_should_retry_alloc(struct super_block *sb, int *retries);\n\nextern struct buffer_head *ext4_read_block_bitmap_nowait(struct super_block *sb,\n\t\t\t\t\t\text4_group_t block_group,\n\t\t\t\t\t\tbool ignore_locked);\nextern int ext4_wait_block_bitmap(struct super_block *sb,\n\t\t\t\t  ext4_group_t block_group,\n\t\t\t\t  struct buffer_head *bh);\nextern struct buffer_head *ext4_read_block_bitmap(struct super_block *sb,\n\t\t\t\t\t\t  ext4_group_t block_group);\nextern unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t block_group,\n\t\t\t\t\t      struct ext4_group_desc *gdp);\next4_fsblk_t ext4_inode_to_goal_block(struct inode *);\n\n#if IS_ENABLED(CONFIG_UNICODE)\nextern int ext4_fname_setup_ci_filename(struct inode *dir,\n\t\t\t\t\t const struct qstr *iname,\n\t\t\t\t\t struct ext4_filename *fname);\n#endif\n\n \n#ifdef CONFIG_FS_ENCRYPTION\nextern const struct fscrypt_operations ext4_cryptops;\n\nint ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct ext4_filename *fname);\n\nint ext4_fname_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t      struct ext4_filename *fname);\n\nvoid ext4_fname_free_filename(struct ext4_filename *fname);\n\nint ext4_ioctl_get_encryption_pwsalt(struct file *filp, void __user *arg);\n\n#else  \nstatic inline int ext4_fname_setup_filename(struct inode *dir,\n\t\t\t\t\t    const struct qstr *iname,\n\t\t\t\t\t    int lookup,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\tint err = 0;\n\tfname->usr_fname = iname;\n\tfname->disk_name.name = (unsigned char *) iname->name;\n\tfname->disk_name.len = iname->len;\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\terr = ext4_fname_setup_ci_filename(dir, iname, fname);\n#endif\n\n\treturn err;\n}\n\nstatic inline int ext4_fname_prepare_lookup(struct inode *dir,\n\t\t\t\t\t    struct dentry *dentry,\n\t\t\t\t\t    struct ext4_filename *fname)\n{\n\treturn ext4_fname_setup_filename(dir, &dentry->d_name, 1, fname);\n}\n\nstatic inline void ext4_fname_free_filename(struct ext4_filename *fname)\n{\n#if IS_ENABLED(CONFIG_UNICODE)\n\tkfree(fname->cf_name.name);\n\tfname->cf_name.name = NULL;\n#endif\n}\n\nstatic inline int ext4_ioctl_get_encryption_pwsalt(struct file *filp,\n\t\t\t\t\t\t   void __user *arg)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif  \n\n \nextern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,\n\t\t\t\t  struct file *,\n\t\t\t\t  struct ext4_dir_entry_2 *,\n\t\t\t\t  struct buffer_head *, char *, int,\n\t\t\t\t  unsigned int);\n#define ext4_check_dir_entry(dir, filp, de, bh, buf, size, offset) \\\n\tunlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (filp), \\\n\t\t\t\t(de), (bh), (buf), (size), (offset)))\nextern int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t\t__u32 minor_hash,\n\t\t\t\tstruct ext4_dir_entry_2 *dirent,\n\t\t\t\tstruct fscrypt_str *ent_name);\nextern void ext4_htree_free_dir_info(struct dir_private_info *p);\nextern int ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size,\n\t\t\t     struct ext4_filename *fname,\n\t\t\t     struct ext4_dir_entry_2 **dest_de);\nvoid ext4_insert_dentry(struct inode *dir, struct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tstruct ext4_filename *fname);\nstatic inline void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!ext4_has_feature_dir_index(inode->i_sb) &&\n\t    ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) {\n\t\t \n\t\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(inode->i_sb));\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n\t}\n}\nstatic const unsigned char ext4_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic inline  unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!ext4_has_feature_filetype(sb) || filetype >= EXT4_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn ext4_filetype_table[filetype];\n}\nextern int ext4_check_all_de(struct inode *dir, struct buffer_head *bh,\n\t\t\t     void *buf, int buf_size);\n\n \nextern int ext4_sync_file(struct file *, loff_t, loff_t, int);\n\n \nextern int ext4fs_dirhash(const struct inode *dir, const char *name, int len,\n\t\t\t  struct dx_hash_info *hinfo);\n\n \nextern int ext4_mark_inode_used(struct super_block *sb, int ino);\nextern struct inode *__ext4_new_inode(struct mnt_idmap *, handle_t *,\n\t\t\t\t      struct inode *, umode_t,\n\t\t\t\t      const struct qstr *qstr, __u32 goal,\n\t\t\t\t      uid_t *owner, __u32 i_flags,\n\t\t\t\t      int handle_type, unsigned int line_no,\n\t\t\t\t      int nblocks);\n\n#define ext4_new_inode(handle, dir, mode, qstr, goal, owner, i_flags)          \\\n\t__ext4_new_inode(&nop_mnt_idmap, (handle), (dir), (mode), (qstr),      \\\n\t\t\t (goal), (owner), i_flags, 0, 0, 0)\n#define ext4_new_inode_start_handle(idmap, dir, mode, qstr, goal, owner, \\\n\t\t\t\t    type, nblocks)\t\t    \\\n\t__ext4_new_inode((idmap), NULL, (dir), (mode), (qstr), (goal), (owner), \\\n\t\t\t 0, (type), __LINE__, (nblocks))\n\n\nextern void ext4_free_inode(handle_t *, struct inode *);\nextern struct inode * ext4_orphan_get(struct super_block *, unsigned long);\nextern unsigned long ext4_count_free_inodes(struct super_block *);\nextern unsigned long ext4_count_dirs(struct super_block *);\nextern void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap);\nextern int ext4_init_inode_table(struct super_block *sb,\n\t\t\t\t ext4_group_t group, int barrier);\nextern void ext4_end_bitmap_read(struct buffer_head *bh, int uptodate);\n\n \nint ext4_fc_info_show(struct seq_file *seq, void *v);\nvoid ext4_fc_init(struct super_block *sb, journal_t *journal);\nvoid ext4_fc_init_inode(struct inode *inode);\nvoid ext4_fc_track_range(handle_t *handle, struct inode *inode, ext4_lblk_t start,\n\t\t\t ext4_lblk_t end);\nvoid __ext4_fc_track_unlink(handle_t *handle, struct inode *inode,\n\tstruct dentry *dentry);\nvoid __ext4_fc_track_link(handle_t *handle, struct inode *inode,\n\tstruct dentry *dentry);\nvoid ext4_fc_track_unlink(handle_t *handle, struct dentry *dentry);\nvoid ext4_fc_track_link(handle_t *handle, struct dentry *dentry);\nvoid __ext4_fc_track_create(handle_t *handle, struct inode *inode,\n\t\t\t    struct dentry *dentry);\nvoid ext4_fc_track_create(handle_t *handle, struct dentry *dentry);\nvoid ext4_fc_track_inode(handle_t *handle, struct inode *inode);\nvoid ext4_fc_mark_ineligible(struct super_block *sb, int reason, handle_t *handle);\nvoid ext4_fc_start_update(struct inode *inode);\nvoid ext4_fc_stop_update(struct inode *inode);\nvoid ext4_fc_del(struct inode *inode);\nbool ext4_fc_replay_check_excluded(struct super_block *sb, ext4_fsblk_t block);\nvoid ext4_fc_replay_cleanup(struct super_block *sb);\nint ext4_fc_commit(journal_t *journal, tid_t commit_tid);\nint __init ext4_fc_init_dentry_cache(void);\nvoid ext4_fc_destroy_dentry_cache(void);\nint ext4_fc_record_regions(struct super_block *sb, int ino,\n\t\t\t   ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t\t   int len, int replay);\n\n \nextern const struct seq_operations ext4_mb_seq_groups_ops;\nextern const struct seq_operations ext4_mb_seq_structs_summary_ops;\nextern int ext4_seq_mb_stats_show(struct seq_file *seq, void *offset);\nextern int ext4_mb_init(struct super_block *);\nextern int ext4_mb_release(struct super_block *);\nextern ext4_fsblk_t ext4_mb_new_blocks(handle_t *,\n\t\t\t\tstruct ext4_allocation_request *, int *);\nextern void ext4_discard_preallocations(struct inode *, unsigned int);\nextern int __init ext4_init_mballoc(void);\nextern void ext4_exit_mballoc(void);\nextern ext4_group_t ext4_mb_prefetch(struct super_block *sb,\n\t\t\t\t     ext4_group_t group,\n\t\t\t\t     unsigned int nr, int *cnt);\nextern void ext4_mb_prefetch_fini(struct super_block *sb, ext4_group_t group,\n\t\t\t\t  unsigned int nr);\n\nextern void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh, ext4_fsblk_t block,\n\t\t\t     unsigned long count, int flags);\nextern int ext4_mb_alloc_groupinfo(struct super_block *sb,\n\t\t\t\t   ext4_group_t ngroups);\nextern int ext4_mb_add_groupinfo(struct super_block *sb,\n\t\text4_group_t i, struct ext4_group_desc *desc);\nextern int ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t\text4_fsblk_t block, unsigned long count);\nextern int ext4_trim_fs(struct super_block *, struct fstrim_range *);\nextern void ext4_process_freed_data(struct super_block *sb, tid_t commit_tid);\nextern void ext4_mb_mark_bb(struct super_block *sb, ext4_fsblk_t block,\n\t\t       int len, int state);\nstatic inline bool ext4_mb_cr_expensive(enum criteria cr)\n{\n\treturn cr >= CR_GOAL_LEN_SLOW;\n}\n\n \nvoid ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t struct ext4_inode_info *ei);\nint ext4_inode_is_fast_symlink(struct inode *inode);\nstruct buffer_head *ext4_getblk(handle_t *, struct inode *, ext4_lblk_t, int);\nstruct buffer_head *ext4_bread(handle_t *, struct inode *, ext4_lblk_t, int);\nint ext4_bread_batch(struct inode *inode, ext4_lblk_t block, int bh_count,\n\t\t     bool wait, struct buffer_head **bhs);\nint ext4_get_block_unwritten(struct inode *inode, sector_t iblock,\n\t\t\t     struct buffer_head *bh_result, int create);\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create);\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct buffer_head *bh));\nint do_journal_get_write_access(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct buffer_head *bh);\n#define FALL_BACK_TO_NONDELALLOC 1\n#define CONVERT_INLINE_DATA\t 2\n\ntypedef enum {\n\tEXT4_IGET_NORMAL =\t0,\n\tEXT4_IGET_SPECIAL =\t0x0001,  \n\tEXT4_IGET_HANDLE = \t0x0002,\t \n\tEXT4_IGET_BAD =\t\t0x0004,  \n\tEXT4_IGET_EA_INODE =\t0x0008\t \n} ext4_iget_flags;\n\nextern struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,\n\t\t\t\t ext4_iget_flags flags, const char *function,\n\t\t\t\t unsigned int line);\n\n#define ext4_iget(sb, ino, flags) \\\n\t__ext4_iget((sb), (ino), (flags), __func__, __LINE__)\n\nextern int  ext4_write_inode(struct inode *, struct writeback_control *);\nextern int  ext4_setattr(struct mnt_idmap *, struct dentry *,\n\t\t\t struct iattr *);\nextern u32  ext4_dio_alignment(struct inode *inode);\nextern int  ext4_getattr(struct mnt_idmap *, const struct path *,\n\t\t\t struct kstat *, u32, unsigned int);\nextern void ext4_evict_inode(struct inode *);\nextern void ext4_clear_inode(struct inode *);\nextern int  ext4_file_getattr(struct mnt_idmap *, const struct path *,\n\t\t\t      struct kstat *, u32, unsigned int);\nextern void ext4_dirty_inode(struct inode *, int);\nextern int ext4_change_inode_journal_flag(struct inode *, int);\nextern int ext4_get_inode_loc(struct inode *, struct ext4_iloc *);\nextern int ext4_get_fc_inode_loc(struct super_block *sb, unsigned long ino,\n\t\t\t  struct ext4_iloc *iloc);\nextern int ext4_inode_attach_jinode(struct inode *inode);\nextern int ext4_can_truncate(struct inode *inode);\nextern int ext4_truncate(struct inode *);\nextern int ext4_break_layouts(struct inode *);\nextern int ext4_punch_hole(struct file *file, loff_t offset, loff_t length);\nextern void ext4_set_inode_flags(struct inode *, bool init);\nextern int ext4_alloc_da_blocks(struct inode *inode);\nextern void ext4_set_aops(struct inode *inode);\nextern int ext4_writepage_trans_blocks(struct inode *);\nextern int ext4_normal_submit_inode_data_buffers(struct jbd2_inode *jinode);\nextern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);\nextern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t lend);\nextern vm_fault_t ext4_page_mkwrite(struct vm_fault *vmf);\nextern qsize_t *ext4_get_reserved_space(struct inode *inode);\nextern int ext4_get_projid(struct inode *inode, kprojid_t *projid);\nextern void ext4_da_release_space(struct inode *inode, int to_free);\nextern void ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim);\nextern int ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_fsblk_t pblk, ext4_lblk_t len);\n\n \nextern int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_map_blocks *map, int flags);\nextern int ext4_ind_trans_blocks(struct inode *inode, int nrblocks);\nextern void ext4_ind_truncate(handle_t *, struct inode *inode);\nextern int ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t\t ext4_lblk_t start, ext4_lblk_t end);\n\n \nextern long ext4_ioctl(struct file *, unsigned int, unsigned long);\nextern long ext4_compat_ioctl(struct file *, unsigned int, unsigned long);\nint ext4_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa);\nint ext4_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nextern void ext4_reset_inode_seed(struct inode *inode);\nint ext4_update_overhead(struct super_block *sb, bool force);\nint ext4_force_shutdown(struct super_block *sb, u32 flags);\n\n \nextern int ext4_ext_migrate(struct inode *);\nextern int ext4_ind_migrate(struct inode *inode);\n\n \nextern int ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode);\nextern int ext4_dirblock_csum_verify(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh);\nextern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t\t__u32 start_minor_hash, __u32 *next_hash);\nextern int ext4_search_dir(struct buffer_head *bh,\n\t\t\t   char *search_buf,\n\t\t\t   int buf_size,\n\t\t\t   struct inode *dir,\n\t\t\t   struct ext4_filename *fname,\n\t\t\t   unsigned int offset,\n\t\t\t   struct ext4_dir_entry_2 **res_dir);\nextern int ext4_generic_delete_entry(struct inode *dir,\n\t\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *entry_buf,\n\t\t\t\t     int buf_size,\n\t\t\t\t     int csum_size);\nextern bool ext4_empty_dir(struct inode *inode);\n\n \nextern void ext4_kvfree_array_rcu(void *to_free);\nextern int ext4_group_add(struct super_block *sb,\n\t\t\t\tstruct ext4_new_group_data *input);\nextern int ext4_group_extend(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es,\n\t\t\t\text4_fsblk_t n_blocks_count);\nextern int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count);\nextern unsigned int ext4_list_backups(struct super_block *sb,\n\t\t\t\t      unsigned int *three, unsigned int *five,\n\t\t\t\t      unsigned int *seven);\n\n \nextern struct buffer_head *ext4_sb_bread(struct super_block *sb,\n\t\t\t\t\t sector_t block, blk_opf_t op_flags);\nextern struct buffer_head *ext4_sb_bread_unmovable(struct super_block *sb,\n\t\t\t\t\t\t   sector_t block);\nextern void ext4_read_bh_nowait(struct buffer_head *bh, blk_opf_t op_flags,\n\t\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags,\n\t\t\tbh_end_io_t *end_io);\nextern int ext4_read_bh_lock(struct buffer_head *bh, blk_opf_t op_flags, bool wait);\nextern void ext4_sb_breadahead_unmovable(struct super_block *sb, sector_t block);\nextern int ext4_seq_options_show(struct seq_file *seq, void *offset);\nextern int ext4_calculate_overhead(struct super_block *sb);\nextern __le32 ext4_superblock_csum(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nextern void ext4_superblock_csum_set(struct super_block *sb);\nextern int ext4_alloc_flex_bg_array(struct super_block *sb,\n\t\t\t\t    ext4_group_t ngroup);\nextern const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t\t     char nbuf[16]);\nextern void ext4_mark_group_bitmap_corrupted(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     unsigned int flags);\nextern unsigned int ext4_num_base_meta_blocks(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t block_group);\n\nextern __printf(7, 8)\nvoid __ext4_error(struct super_block *, const char *, unsigned int, bool,\n\t\t  int, __u64, const char *, ...);\nextern __printf(6, 7)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int,\n\t\t\text4_fsblk_t, int, const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning_inode(const struct inode *inode, const char *function,\n\t\t\t  unsigned int line, const char *fmt, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#define EXT4_ERROR_INODE(inode, fmt, a...) \\\n\text4_error_inode((inode), __func__, __LINE__, 0, (fmt), ## a)\n\n#define EXT4_ERROR_INODE_ERR(inode, err, fmt, a...)\t\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, 0, (err), (fmt), ## a)\n\n#define ext4_error_inode_block(inode, block, err, fmt, a...)\t\t\\\n\t__ext4_error_inode((inode), __func__, __LINE__, (block), (err),\t\\\n\t\t\t   (fmt), ## a)\n\n#define EXT4_ERROR_FILE(file, block, fmt, a...)\t\t\t\t\\\n\text4_error_file((file), __func__, __LINE__, (block), (fmt), ## a)\n\n#define ext4_abort(sb, err, fmt, a...)\t\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, true, (err), 0, (fmt), ## a)\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, 0, fmt, ##__VA_ARGS__)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\n\t__ext4_error_inode((inode), (func), (line), (block), \t\t\\\n\t\t\t   (err), (fmt), ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, false, 0, 0, (fmt),\t\\\n\t\t##__VA_ARGS__)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\n\t__ext4_error((sb), __func__, __LINE__, false, (err), 0, (fmt),\t\\\n\t\t##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\n\t__ext4_warning_inode(inode, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, 0, \" \");\t\t\\\n} while (0)\n#define ext4_error_inode_err(inode, func, line, block, err, fmt, ...)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, err, \" \");\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, false, 0, 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_err(sb, err, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, false, err, 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning_inode(inode, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning_inode(inode, \"\", 0, \" \");\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(ext4_has_feature_metadata_csum(sb) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn ext4_has_feature_metadata_csum(sb) &&\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn ext4_has_feature_gdt_csum(sb) || ext4_has_metadata_csum(sb);\n}\n\n#define ext4_read_incompat_64bit_val(es, name) \\\n\t(((es)->s_feature_incompat & cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT) \\\n\t\t? (ext4_fsblk_t)le32_to_cpu(es->name##_hi) << 32 : 0) | \\\n\t\tle32_to_cpu(es->name##_lo))\n\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_r_blocks_count);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ext4_read_incompat_64bit_val(es, s_free_blocks_count);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct super_block *sb,\n\t\t\t\tstruct ext4_inode *raw_inode)\n{\n\tif (ext4_has_feature_largedir(sb) ||\n\t    S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\n\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\n \nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n \n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n \nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !inode_is_locked(inode));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tWRITE_ONCE(EXT4_I(inode)->i_disksize, newsize);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n \nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nint ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t len);\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n#ifdef AGGRESSIVE_CHECK\n\tunsigned long\tbb_check_counter;\n#endif\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t \n\text4_grpblk_t\tbb_free;\t \n\text4_grpblk_t\tbb_fragments;\t \n\tint\t\tbb_avg_fragment_size_order;\t \n\text4_grpblk_t\tbb_largest_free_order; \n\text4_group_t\tbb_group;\t \n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\tstruct list_head bb_avg_fragment_size_node;\n\tstruct list_head bb_largest_free_order_node;\n\text4_grpblk_t\tbb_counters[];\t \n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT\t\t\\\n\t(1 << EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT)\n#define EXT4_GROUP_INFO_BBITMAP_READ_BIT\t4\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_TEST_AND_SET_READ(grp)\t\\\n\t(test_and_set_bit(EXT4_GROUP_INFO_BBITMAP_READ_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}\n\n \nstatic inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t \n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t \n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}\n\n#ifdef CONFIG_QUOTA\nstatic inline bool ext4_quota_capable(struct super_block *sb)\n{\n\treturn (test_opt(sb, QUOTA) || ext4_has_feature_quota(sb));\n}\n\nstatic inline bool ext4_is_quota_journalled(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\treturn (ext4_has_feature_quota(sb) ||\n\t\tsbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]);\n}\nint ext4_enable_quotas(struct super_block *sb);\n#endif\n\n \n#define ext4_check_indirect_blockref(inode, bh)\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    (__le32 *)(bh)->b_data,\t\t\t\\\n\t\t\t    EXT4_ADDR_PER_BLOCK((inode)->i_sb))\n\n#define ext4_ind_check_inode(inode)\t\t\t\t\t\\\n\text4_check_blockref(__func__, __LINE__, inode,\t\t\t\\\n\t\t\t    EXT4_I(inode)->i_data,\t\t\t\\\n\t\t\t    EXT4_NDIR_BLOCKS)\n\n \n\n \nextern const struct file_operations ext4_dir_operations;\n\n \nextern const struct inode_operations ext4_file_inode_operations;\nextern const struct file_operations ext4_file_operations;\nextern loff_t ext4_llseek(struct file *file, loff_t offset, int origin);\n\n \nextern int ext4_get_max_inline_size(struct inode *inode);\nextern int ext4_find_inline_data_nolock(struct inode *inode);\nextern int ext4_destroy_inline_data(handle_t *handle, struct inode *inode);\n\nint ext4_readpage_inline(struct inode *inode, struct folio *folio);\nextern int ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t loff_t pos, unsigned len,\n\t\t\t\t\t struct page **pagep);\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct folio *folio);\nextern int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   loff_t pos, unsigned len,\n\t\t\t\t\t   struct page **pagep,\n\t\t\t\t\t   void **fsdata);\nextern int ext4_try_add_inline_entry(handle_t *handle,\n\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t     struct inode *dir, struct inode *inode);\nextern int ext4_try_create_inline_dir(handle_t *handle,\n\t\t\t\t      struct inode *parent,\n\t\t\t\t      struct inode *inode);\nextern int ext4_read_inline_dir(struct file *filp,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tint *has_inline_data);\nextern int ext4_inlinedir_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash,\n\t\t\t\t  int *has_inline_data);\nextern struct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tstruct ext4_filename *fname,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data);\nextern int ext4_delete_inline_entry(handle_t *handle,\n\t\t\t\t    struct inode *dir,\n\t\t\t\t    struct ext4_dir_entry_2 *de_del,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    int *has_inline_data);\nextern bool empty_inline_dir(struct inode *dir, int *has_inline_data);\nextern struct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval);\nextern void *ext4_read_inline_link(struct inode *inode);\n\nstruct iomap;\nextern int ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap);\n\nextern int ext4_inline_data_truncate(struct inode *inode, int *has_inline);\n\nextern int ext4_convert_inline_data(struct inode *inode);\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}\n\n \nextern const struct inode_operations ext4_dir_inode_operations;\nextern const struct inode_operations ext4_special_inode_operations;\nextern struct dentry *ext4_get_parent(struct dentry *child);\nextern struct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t\t struct ext4_dir_entry_2 *de,\n\t\t\t\t int blocksize, int csum_size,\n\t\t\t\t unsigned int parent_ino, int dotdot_real_len);\nextern void ext4_initialize_dirent_tail(struct buffer_head *bh,\n\t\t\t\t\tunsigned int blocksize);\nextern int ext4_handle_dirty_dirblock(handle_t *handle, struct inode *inode,\n\t\t\t\t      struct buffer_head *bh);\nextern int __ext4_unlink(struct inode *dir, const struct qstr *d_name,\n\t\t\t struct inode *inode, struct dentry *dentry);\nextern int __ext4_link(struct inode *dir, struct inode *inode,\n\t\t       struct dentry *dentry);\n\n#define S_SHIFT 12\nstatic const unsigned char ext4_type_by_mode[(S_IFMT >> S_SHIFT) + 1] = {\n\t[S_IFREG >> S_SHIFT]\t= EXT4_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXT4_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXT4_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXT4_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXT4_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXT4_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXT4_FT_SYMLINK,\n};\n\nstatic inline void ext4_set_de_type(struct super_block *sb,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tumode_t mode) {\n\tif (ext4_has_feature_filetype(sb))\n\t\tde->file_type = ext4_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}\n\n \nextern int ext4_mpage_readpages(struct inode *inode,\n\t\tstruct readahead_control *rac, struct folio *folio);\nextern int __init ext4_init_post_read_processing(void);\nextern void ext4_exit_post_read_processing(void);\n\n \nextern const struct inode_operations ext4_encrypted_symlink_inode_operations;\nextern const struct inode_operations ext4_symlink_inode_operations;\nextern const struct inode_operations ext4_fast_symlink_inode_operations;\n\n \nextern void ext4_notify_error_sysfs(struct ext4_sb_info *sbi);\nextern int ext4_register_sysfs(struct super_block *sb);\nextern void ext4_unregister_sysfs(struct super_block *sb);\nextern int __init ext4_init_sysfs(void);\nextern void ext4_exit_sysfs(void);\n\n \nextern void ext4_release_system_zone(struct super_block *sb);\nextern int ext4_setup_system_zone(struct super_block *sb);\nextern int __init ext4_init_system_zone(void);\nextern void ext4_exit_system_zone(void);\nextern int ext4_inode_block_valid(struct inode *inode,\n\t\t\t\t  ext4_fsblk_t start_blk,\n\t\t\t\t  unsigned int count);\nextern int ext4_check_blockref(const char *, unsigned int,\n\t\t\t       struct inode *, __le32 *, unsigned int);\nextern int ext4_sb_block_valid(struct super_block *sb, struct inode *inode,\n\t\t\t\text4_fsblk_t start_blk, unsigned int count);\n\n\n \nstruct ext4_ext_path;\nstruct ext4_extent;\n\n \n#define EXT_MAX_BLOCKS\t0xffffffff\n\nextern void ext4_ext_tree_init(handle_t *handle, struct inode *inode);\nextern int ext4_ext_index_trans_blocks(struct inode *inode, int extents);\nextern int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t       struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_truncate(handle_t *, struct inode *);\nextern int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t ext4_lblk_t end);\nextern void ext4_ext_init(struct super_block *);\nextern void ext4_ext_release(struct super_block *);\nextern long ext4_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\nextern int ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t\t  loff_t offset, ssize_t len);\nextern int ext4_convert_unwritten_io_end_vec(handle_t *handle,\n\t\t\t\t\t     ext4_io_end_t *io_end);\nextern int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_map_blocks *map, int flags);\nextern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,\n\t\t\t\t\t\t   int num,\n\t\t\t\t\t\t   struct ext4_ext_path *path);\nextern int ext4_ext_insert_extent(handle_t *, struct inode *,\n\t\t\t\t  struct ext4_ext_path **,\n\t\t\t\t  struct ext4_extent *, int);\nextern struct ext4_ext_path *ext4_find_extent(struct inode *, ext4_lblk_t,\n\t\t\t\t\t      struct ext4_ext_path **,\n\t\t\t\t\t      int flags);\nextern void ext4_free_ext_path(struct ext4_ext_path *);\nextern int ext4_ext_check_inode(struct inode *inode);\nextern ext4_lblk_t ext4_ext_next_allocated_block(struct ext4_ext_path *path);\nextern int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t\t__u64 start, __u64 len);\nextern int ext4_get_es_cache(struct inode *inode,\n\t\t\t     struct fiemap_extent_info *fieinfo,\n\t\t\t     __u64 start, __u64 len);\nextern int ext4_ext_precache(struct inode *inode);\nextern int ext4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t\t\tstruct inode *inode2, ext4_lblk_t lblk1,\n\t\t\t     ext4_lblk_t lblk2,  ext4_lblk_t count,\n\t\t\t     int mark_unwritten,int *err);\nextern int ext4_clu_mapped(struct inode *inode, ext4_lblk_t lclu);\nextern int ext4_datasem_ensure_credits(handle_t *handle, struct inode *inode,\n\t\t\t\t       int check_cred, int restart_cred,\n\t\t\t\t       int revoke_cred);\nextern void ext4_ext_replay_shrink_inode(struct inode *inode, ext4_lblk_t end);\nextern int ext4_ext_replay_set_iblocks(struct inode *inode);\nextern int ext4_ext_replay_update_ex(struct inode *inode, ext4_lblk_t start,\n\t\tint len, int unwritten, ext4_fsblk_t pblk);\nextern int ext4_ext_clear_bb(struct inode *inode);\n\n\n \nextern void ext4_double_down_write_data_sem(struct inode *first,\n\t\t\t\t\t    struct inode *second);\nextern void ext4_double_up_write_data_sem(struct inode *orig_inode,\n\t\t\t\t\t  struct inode *donor_inode);\nextern int ext4_move_extents(struct file *o_filp, struct file *d_filp,\n\t\t\t     __u64 start_orig, __u64 start_donor,\n\t\t\t     __u64 len, __u64 *moved_len);\n\n \nextern int __init ext4_init_pageio(void);\nextern void ext4_exit_pageio(void);\nextern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);\nextern ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end);\nextern int ext4_put_io_end(ext4_io_end_t *io_end);\nextern void ext4_put_io_end_defer(ext4_io_end_t *io_end);\nextern void ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t\tstruct writeback_control *wbc);\nextern void ext4_end_io_rsv_work(struct work_struct *work);\nextern void ext4_io_submit(struct ext4_io_submit *io);\nint ext4_bio_write_folio(struct ext4_io_submit *io, struct folio *page,\n\t\tsize_t len);\nextern struct ext4_io_end_vec *ext4_alloc_io_end_vec(ext4_io_end_t *io_end);\nextern struct ext4_io_end_vec *ext4_last_io_end_vec(ext4_io_end_t *io_end);\n\n \nextern int ext4_multi_mount_protect(struct super_block *, ext4_fsblk_t);\n\n \nextern void ext4_stop_mmpd(struct ext4_sb_info *sbi);\n\n \nextern const struct fsverity_operations ext4_verityops;\n\n \nextern int ext4_orphan_add(handle_t *, struct inode *);\nextern int ext4_orphan_del(handle_t *, struct inode *);\nextern void ext4_orphan_cleanup(struct super_block *sb,\n\t\t\t\tstruct ext4_super_block *es);\nextern void ext4_release_orphan_info(struct super_block *sb);\nextern int ext4_init_orphan_info(struct super_block *sb);\nextern int ext4_orphan_file_empty(struct super_block *sb);\nextern void ext4_orphan_file_block_trigger(\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh,\n\t\t\t\tvoid *data, size_t size);\n\n \n#define BH_BITMAP_UPTODATE BH_JBDPrivateStart\n\nstatic inline int bitmap_uptodate(struct buffer_head *bh)\n{\n\treturn (buffer_uptodate(bh) &&\n\t\t\ttest_bit(BH_BITMAP_UPTODATE, &(bh)->b_state));\n}\nstatic inline void set_bitmap_uptodate(struct buffer_head *bh)\n{\n\tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n}\n\n \n#define EXT4_WQ_HASH_SZ\t\t37\n#define ext4_ioend_wq(v)   (&ext4__ioend_wq[((unsigned long)(v)) %\\\n\t\t\t\t\t    EXT4_WQ_HASH_SZ])\nextern wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];\n\nextern int ext4_resize_begin(struct super_block *sb);\nextern int ext4_resize_end(struct super_block *sb, bool update_backups);\n\nstatic inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}\n\nstatic inline void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)\n{\n\tstruct inode *inode = io_end->inode;\n\n\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\tio_end->flag &= ~EXT4_IO_END_UNWRITTEN;\n\t\t \n\t\tif (atomic_dec_and_test(&EXT4_I(inode)->i_unwritten))\n\t\t\twake_up_all(ext4_ioend_wq(inode));\n\t}\n}\n\nextern const struct iomap_ops ext4_iomap_ops;\nextern const struct iomap_ops ext4_iomap_overwrite_ops;\nextern const struct iomap_ops ext4_iomap_report_ops;\n\nstatic inline int ext4_buffer_uptodate(struct buffer_head *bh)\n{\n\t \n\tif (buffer_write_io_error(bh))\n\t\tset_buffer_uptodate(bh);\n\treturn buffer_uptodate(bh);\n}\n\n#endif\t \n\n#define EFSBADCRC\tEBADMSG\t\t \n#define EFSCORRUPTED\tEUCLEAN\t\t \n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}