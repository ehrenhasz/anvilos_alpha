{
  "module_name": "mmp.c",
  "hash_id": "b4a8789f1ac53f4d14a8034d46f1304782eb043c58c33c891cffa49ac70d832c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/mmp.c",
  "human_readable_source": "\n#include <linux/fs.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/utsname.h>\n#include <linux/kthread.h>\n\n#include \"ext4.h\"\n\n \nstatic __le32 ext4_mmp_csum(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint offset = offsetof(struct mmp_struct, mmp_checksum);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (char *)mmp, offset);\n\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\treturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\n}\n\nstatic void ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\n{\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\n}\n\n \nstatic int write_mmp_block_thawed(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\n\n\text4_mmp_csum_set(sb, mmp);\n\tlock_buffer(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_WRITE | REQ_SYNC | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh)))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tint err;\n\n\t \n\tsb_start_write(sb);\n\terr = write_mmp_block_thawed(sb, bh);\n\tsb_end_write(sb);\n\treturn err;\n}\n\n \nstatic int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\n\t\t\t  ext4_fsblk_t mmp_block)\n{\n\tstruct mmp_struct *mmp;\n\tint ret;\n\n\tif (*bh)\n\t\tclear_buffer_uptodate(*bh);\n\n\t \n\tif (!*bh) {\n\t\t*bh = sb_getblk(sb, mmp_block);\n\t\tif (!*bh) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto warn_exit;\n\t\t}\n\t}\n\n\tlock_buffer(*bh);\n\tret = ext4_read_bh(*bh, REQ_META | REQ_PRIO, NULL);\n\tif (ret)\n\t\tgoto warn_exit;\n\n\tmmp = (struct mmp_struct *)((*bh)->b_data);\n\tif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC) {\n\t\tret = -EFSCORRUPTED;\n\t\tgoto warn_exit;\n\t}\n\tif (!ext4_mmp_csum_verify(sb, mmp)) {\n\t\tret = -EFSBADCRC;\n\t\tgoto warn_exit;\n\t}\n\treturn 0;\nwarn_exit:\n\tbrelse(*bh);\n\t*bh = NULL;\n\text4_warning(sb, \"Error %d while reading MMP block %llu\",\n\t\t     ret, mmp_block);\n\treturn ret;\n}\n\n \nvoid __dump_mmp_msg(struct super_block *sb, struct mmp_struct *mmp,\n\t\t    const char *function, unsigned int line, const char *msg)\n{\n\t__ext4_warning(sb, function, line, \"%s\", msg);\n\t__ext4_warning(sb, function, line,\n\t\t       \"MMP failure info: last update time: %llu, last update node: %.*s, last update device: %.*s\",\n\t\t       (unsigned long long)le64_to_cpu(mmp->mmp_time),\n\t\t       (int)sizeof(mmp->mmp_nodename), mmp->mmp_nodename,\n\t\t       (int)sizeof(mmp->mmp_bdevname), mmp->mmp_bdevname);\n}\n\n \nstatic int kmmpd(void *data)\n{\n\tstruct super_block *sb = data;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_mmp_bh;\n\tstruct mmp_struct *mmp;\n\text4_fsblk_t mmp_block;\n\tu32 seq = 0;\n\tunsigned long failed_writes = 0;\n\tint mmp_update_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned mmp_check_interval;\n\tunsigned long last_update_time;\n\tunsigned long diff;\n\tint retval = 0;\n\n\tmmp_block = le64_to_cpu(es->s_mmp_block);\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tmmp->mmp_time = cpu_to_le64(ktime_get_real_seconds());\n\t \n\tmmp_check_interval = max(EXT4_MMP_CHECK_MULT * mmp_update_interval,\n\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\n\tmemcpy(mmp->mmp_nodename, init_utsname()->nodename,\n\t       sizeof(mmp->mmp_nodename));\n\n\twhile (!kthread_should_stop() && !ext4_forced_shutdown(sb)) {\n\t\tif (!ext4_has_feature_mmp(sb)) {\n\t\t\text4_warning(sb, \"kmmpd being stopped since MMP feature\"\n\t\t\t\t     \" has been disabled.\");\n\t\t\tgoto wait_to_exit;\n\t\t}\n\t\tif (++seq > EXT4_MMP_SEQ_MAX)\n\t\t\tseq = 1;\n\n\t\tmmp->mmp_seq = cpu_to_le32(seq);\n\t\tmmp->mmp_time = cpu_to_le64(ktime_get_real_seconds());\n\t\tlast_update_time = jiffies;\n\n\t\tretval = write_mmp_block(sb, bh);\n\t\t \n\t\tif (retval) {\n\t\t\tif ((failed_writes % 60) == 0) {\n\t\t\t\text4_error_err(sb, -retval,\n\t\t\t\t\t       \"Error writing to MMP block\");\n\t\t\t}\n\t\t\tfailed_writes++;\n\t\t}\n\n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff < mmp_update_interval * HZ)\n\t\t\tschedule_timeout_interruptible(mmp_update_interval *\n\t\t\t\t\t\t       HZ - diff);\n\n\t\t \n\t\tdiff = jiffies - last_update_time;\n\t\tif (diff > mmp_check_interval * HZ) {\n\t\t\tstruct buffer_head *bh_check = NULL;\n\t\t\tstruct mmp_struct *mmp_check;\n\n\t\t\tretval = read_mmp_block(sb, &bh_check, mmp_block);\n\t\t\tif (retval) {\n\t\t\t\text4_error_err(sb, -retval,\n\t\t\t\t\t       \"error reading MMP data: %d\",\n\t\t\t\t\t       retval);\n\t\t\t\tgoto wait_to_exit;\n\t\t\t}\n\n\t\t\tmmp_check = (struct mmp_struct *)(bh_check->b_data);\n\t\t\tif (mmp->mmp_seq != mmp_check->mmp_seq ||\n\t\t\t    memcmp(mmp->mmp_nodename, mmp_check->mmp_nodename,\n\t\t\t\t   sizeof(mmp->mmp_nodename))) {\n\t\t\t\tdump_mmp_msg(sb, mmp_check,\n\t\t\t\t\t     \"Error while updating MMP info. \"\n\t\t\t\t\t     \"The filesystem seems to have been\"\n\t\t\t\t\t     \" multiply mounted.\");\n\t\t\t\text4_error_err(sb, EBUSY, \"abort\");\n\t\t\t\tput_bh(bh_check);\n\t\t\t\tretval = -EBUSY;\n\t\t\t\tgoto wait_to_exit;\n\t\t\t}\n\t\t\tput_bh(bh_check);\n\t\t}\n\n\t\t  \n\t\tmmp_check_interval = max(min(EXT4_MMP_CHECK_MULT * diff / HZ,\n\t\t\t\t\t     EXT4_MMP_MAX_CHECK_INTERVAL),\n\t\t\t\t\t EXT4_MMP_MIN_CHECK_INTERVAL);\n\t\tmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\n\t}\n\n\t \n\tmmp->mmp_seq = cpu_to_le32(EXT4_MMP_SEQ_CLEAN);\n\tmmp->mmp_time = cpu_to_le64(ktime_get_real_seconds());\n\n\tretval = write_mmp_block(sb, bh);\n\nwait_to_exit:\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!kthread_should_stop())\n\t\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\treturn retval;\n}\n\nvoid ext4_stop_mmpd(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_mmp_tsk) {\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\t\tbrelse(sbi->s_mmp_bh);\n\t\tsbi->s_mmp_tsk = NULL;\n\t}\n}\n\n \nstatic unsigned int mmp_new_seq(void)\n{\n\treturn get_random_u32_below(EXT4_MMP_SEQ_MAX + 1);\n}\n\n \nint ext4_multi_mount_protect(struct super_block *sb,\n\t\t\t\t    ext4_fsblk_t mmp_block)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *bh = NULL;\n\tstruct mmp_struct *mmp = NULL;\n\tu32 seq;\n\tunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\n\tunsigned int wait_time = 0;\n\tint retval;\n\n\tif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\n\t    mmp_block >= ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"Invalid MMP block in superblock\");\n\t\tretval = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\n\tif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\n\t\tmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\n\n\t \n\tif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\n\t\tmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\n\n\tseq = le32_to_cpu(mmp->mmp_seq);\n\tif (seq == EXT4_MMP_SEQ_CLEAN)\n\t\tgoto skip;\n\n\tif (seq == EXT4_MMP_SEQ_FSCK) {\n\t\tdump_mmp_msg(sb, mmp, \"fsck is running on the filesystem\");\n\t\tretval = -EBUSY;\n\t\tgoto failed;\n\t}\n\n\twait_time = min(mmp_check_interval * 2 + 1,\n\t\t\tmmp_check_interval + 60);\n\n\t \n\tif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\n\t\text4_warning(sb, \"MMP interval %u higher than expected, please\"\n\t\t\t     \" wait.\\n\", wait_time * 2);\n\n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\\n\");\n\t\tretval = -ETIMEDOUT;\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tretval = -EBUSY;\n\t\tgoto failed;\n\t}\n\nskip:\n\t \n\tseq = mmp_new_seq();\n\tmmp->mmp_seq = cpu_to_le32(seq);\n\n\t \n\tretval = write_mmp_block_thawed(sb, bh);\n\tif (retval)\n\t\tgoto failed;\n\n\t \n\tif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\n\t\text4_warning(sb, \"MMP startup interrupted, failing mount\");\n\t\tretval = -ETIMEDOUT;\n\t\tgoto failed;\n\t}\n\n\tretval = read_mmp_block(sb, &bh, mmp_block);\n\tif (retval)\n\t\tgoto failed;\n\tmmp = (struct mmp_struct *)(bh->b_data);\n\tif (seq != le32_to_cpu(mmp->mmp_seq)) {\n\t\tdump_mmp_msg(sb, mmp,\n\t\t\t     \"Device is already active on another node.\");\n\t\tretval = -EBUSY;\n\t\tgoto failed;\n\t}\n\n\tEXT4_SB(sb)->s_mmp_bh = bh;\n\n\tBUILD_BUG_ON(sizeof(mmp->mmp_bdevname) < BDEVNAME_SIZE);\n\tsnprintf(mmp->mmp_bdevname, sizeof(mmp->mmp_bdevname),\n\t\t \"%pg\", bh->b_bdev);\n\n\t \n\tEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, sb, \"kmmpd-%.*s\",\n\t\t\t\t\t     (int)sizeof(mmp->mmp_bdevname),\n\t\t\t\t\t     mmp->mmp_bdevname);\n\tif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\n\t\tEXT4_SB(sb)->s_mmp_tsk = NULL;\n\t\text4_warning(sb, \"Unable to create kmmpd thread for %s.\",\n\t\t\t     sb->s_id);\n\t\tretval = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tbrelse(bh);\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}