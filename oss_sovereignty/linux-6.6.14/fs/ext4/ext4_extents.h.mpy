{
  "module_name": "ext4_extents.h",
  "hash_id": "8970f75ed48ba2fb66bd8860f167094724b3d41994a88817e556d8e4b5bbe0d9",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/ext4_extents.h",
  "human_readable_source": "\n \n\n#ifndef _EXT4_EXTENTS\n#define _EXT4_EXTENTS\n\n#include \"ext4.h\"\n\n \n#define AGGRESSIVE_TEST_\n\n \n#define EXTENTS_STATS__\n\n \n#define CHECK_BINSEARCH__\n\n \n#define EXT_STATS_\n\n\n \n\n \nstruct ext4_extent_tail {\n\t__le32\tet_checksum;\t \n};\n\n \nstruct ext4_extent {\n\t__le32\tee_block;\t \n\t__le16\tee_len;\t\t \n\t__le16\tee_start_hi;\t \n\t__le32\tee_start_lo;\t \n};\n\n \nstruct ext4_extent_idx {\n\t__le32\tei_block;\t \n\t__le32\tei_leaf_lo;\t \n\t__le16\tei_leaf_hi;\t \n\t__u16\tei_unused;\n};\n\n \nstruct ext4_extent_header {\n\t__le16\teh_magic;\t \n\t__le16\teh_entries;\t \n\t__le16\teh_max;\t\t \n\t__le16\teh_depth;\t \n\t__le32\teh_generation;\t \n};\n\n#define EXT4_EXT_MAGIC\t\tcpu_to_le16(0xf30a)\n#define EXT4_MAX_EXTENT_DEPTH 5\n\n#define EXT4_EXTENT_TAIL_OFFSET(hdr) \\\n\t(sizeof(struct ext4_extent_header) + \\\n\t (sizeof(struct ext4_extent) * le16_to_cpu((hdr)->eh_max)))\n\nstatic inline struct ext4_extent_tail *\nfind_ext4_extent_tail(struct ext4_extent_header *eh)\n{\n\treturn (struct ext4_extent_tail *)(((void *)eh) +\n\t\t\t\t\t   EXT4_EXTENT_TAIL_OFFSET(eh));\n}\n\n \nstruct ext4_ext_path {\n\text4_fsblk_t\t\t\tp_block;\n\t__u16\t\t\t\tp_depth;\n\t__u16\t\t\t\tp_maxdepth;\n\tstruct ext4_extent\t\t*p_ext;\n\tstruct ext4_extent_idx\t\t*p_idx;\n\tstruct ext4_extent_header\t*p_hdr;\n\tstruct buffer_head\t\t*p_bh;\n};\n\n \nstruct partial_cluster {\n\text4_fsblk_t pclu;   \n\text4_lblk_t lblk;    \n\tenum {initial, tofree, nofree} state;\n};\n\n \n\n \n#define EXT_INIT_MAX_LEN\t(1UL << 15)\n#define EXT_UNWRITTEN_MAX_LEN\t(EXT_INIT_MAX_LEN - 1)\n\n\n#define EXT_FIRST_EXTENT(__hdr__) \\\n\t((struct ext4_extent *) (((char *) (__hdr__)) +\t\t\\\n\t\t\t\t sizeof(struct ext4_extent_header)))\n#define EXT_FIRST_INDEX(__hdr__) \\\n\t((struct ext4_extent_idx *) (((char *) (__hdr__)) +\t\\\n\t\t\t\t     sizeof(struct ext4_extent_header)))\n#define EXT_HAS_FREE_INDEX(__path__) \\\n\t(le16_to_cpu((__path__)->p_hdr->eh_entries) \\\n\t\t\t\t     < le16_to_cpu((__path__)->p_hdr->eh_max))\n#define EXT_LAST_EXTENT(__hdr__) \\\n\t(EXT_FIRST_EXTENT((__hdr__)) + le16_to_cpu((__hdr__)->eh_entries) - 1)\n#define EXT_LAST_INDEX(__hdr__) \\\n\t(EXT_FIRST_INDEX((__hdr__)) + le16_to_cpu((__hdr__)->eh_entries) - 1)\n#define EXT_MAX_EXTENT(__hdr__)\t\\\n\t((le16_to_cpu((__hdr__)->eh_max)) ? \\\n\t((EXT_FIRST_EXTENT((__hdr__)) + le16_to_cpu((__hdr__)->eh_max) - 1)) \\\n\t\t\t\t\t: NULL)\n#define EXT_MAX_INDEX(__hdr__) \\\n\t((le16_to_cpu((__hdr__)->eh_max)) ? \\\n\t((EXT_FIRST_INDEX((__hdr__)) + le16_to_cpu((__hdr__)->eh_max) - 1)) \\\n\t\t\t\t\t: NULL)\n\nstatic inline struct ext4_extent_header *ext_inode_hdr(struct inode *inode)\n{\n\treturn (struct ext4_extent_header *) EXT4_I(inode)->i_data;\n}\n\nstatic inline struct ext4_extent_header *ext_block_hdr(struct buffer_head *bh)\n{\n\treturn (struct ext4_extent_header *) bh->b_data;\n}\n\nstatic inline unsigned short ext_depth(struct inode *inode)\n{\n\treturn le16_to_cpu(ext_inode_hdr(inode)->eh_depth);\n}\n\nstatic inline void ext4_ext_mark_unwritten(struct ext4_extent *ext)\n{\n\t \n\tBUG_ON((le16_to_cpu(ext->ee_len) & ~EXT_INIT_MAX_LEN) == 0);\n\text->ee_len |= cpu_to_le16(EXT_INIT_MAX_LEN);\n}\n\nstatic inline int ext4_ext_is_unwritten(struct ext4_extent *ext)\n{\n\t \n\treturn (le16_to_cpu(ext->ee_len) > EXT_INIT_MAX_LEN);\n}\n\nstatic inline int ext4_ext_get_actual_len(struct ext4_extent *ext)\n{\n\treturn (le16_to_cpu(ext->ee_len) <= EXT_INIT_MAX_LEN ?\n\t\tle16_to_cpu(ext->ee_len) :\n\t\t(le16_to_cpu(ext->ee_len) - EXT_INIT_MAX_LEN));\n}\n\nstatic inline void ext4_ext_mark_initialized(struct ext4_extent *ext)\n{\n\text->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ext));\n}\n\n \nstatic inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ex->ee_start_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ex->ee_start_hi) << 31) << 1;\n\treturn block;\n}\n\n \nstatic inline ext4_fsblk_t ext4_idx_pblock(struct ext4_extent_idx *ix)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ix->ei_leaf_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ix->ei_leaf_hi) << 31) << 1;\n\treturn block;\n}\n\n \nstatic inline void ext4_ext_store_pblock(struct ext4_extent *ex,\n\t\t\t\t\t ext4_fsblk_t pb)\n{\n\tex->ee_start_lo = cpu_to_le32((unsigned long) (pb & 0xffffffff));\n\tex->ee_start_hi = cpu_to_le16((unsigned long) ((pb >> 31) >> 1) &\n\t\t\t\t      0xffff);\n}\n\n \nstatic inline void ext4_idx_store_pblock(struct ext4_extent_idx *ix,\n\t\t\t\t\t ext4_fsblk_t pb)\n{\n\tix->ei_leaf_lo = cpu_to_le32((unsigned long) (pb & 0xffffffff));\n\tix->ei_leaf_hi = cpu_to_le16((unsigned long) ((pb >> 31) >> 1) &\n\t\t\t\t     0xffff);\n}\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}