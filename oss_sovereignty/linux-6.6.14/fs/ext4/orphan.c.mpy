{
  "module_name": "orphan.c",
  "hash_id": "7197edfdebd700c6bdd70427a733a19a9de510997177c823dbe56cc37577c0b3",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/orphan.c",
  "human_readable_source": " \n#include <linux/fs.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_orphan_file_add(handle_t *handle, struct inode *inode)\n{\n\tint i, j, start;\n\tstruct ext4_orphan_info *oi = &EXT4_SB(inode->i_sb)->s_orphan_info;\n\tint ret = 0;\n\tbool found = false;\n\t__le32 *bdata;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(inode->i_sb);\n\tint looped = 0;\n\n\t \n\tstart = raw_smp_processor_id()*13 % oi->of_blocks;\n\ti = start;\n\tdo {\n\t\tif (atomic_dec_if_positive(&oi->of_binfo[i].ob_free_entries)\n\t\t    >= 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (++i >= oi->of_blocks)\n\t\t\ti = 0;\n\t} while (i != start);\n\n\tif (!found) {\n\t\t \n\t\treturn -ENOSPC;\n\t}\n\n\tret = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\toi->of_binfo[i].ob_bh, EXT4_JTR_ORPHAN_FILE);\n\tif (ret) {\n\t\tatomic_inc(&oi->of_binfo[i].ob_free_entries);\n\t\treturn ret;\n\t}\n\n\tbdata = (__le32 *)(oi->of_binfo[i].ob_bh->b_data);\n\t \n\tj = 0;\n\tdo {\n\t\tif (looped) {\n\t\t\t \n\t\t\tif (looped > 3) {\n\t\t\t\tatomic_inc(&oi->of_binfo[i].ob_free_entries);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t\twhile (bdata[j]) {\n\t\t\tif (++j >= inodes_per_ob) {\n\t\t\t\tj = 0;\n\t\t\t\tlooped++;\n\t\t\t}\n\t\t}\n\t} while (cmpxchg(&bdata[j], (__le32)0, cpu_to_le32(inode->i_ino)) !=\n\t\t (__le32)0);\n\n\tEXT4_I(inode)->i_orphan_idx = i * inodes_per_ob + j;\n\text4_set_inode_state(inode, EXT4_STATE_ORPHAN_FILE);\n\n\treturn ext4_handle_dirty_metadata(handle, NULL, oi->of_binfo[i].ob_bh);\n}\n\n \nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !inode_is_locked(inode));\n\t \n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORPHAN_FILE) ||\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t \n\tASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tif (sbi->s_orphan_info.of_blocks) {\n\t\terr = ext4_orphan_file_add(handle, inode);\n\t\t \n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\t}\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, sbi->s_sbh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t \n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t \n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tlock_buffer(sbi->s_sbh);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\text4_superblock_csum_set(sb);\n\t\tunlock_buffer(sbi->s_sbh);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t \n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del_init(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t} else\n\t\tbrelse(iloc.bh);\n\n\text4_debug(\"superblock will point to %lu\\n\", inode->i_ino);\n\text4_debug(\"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}\n\nstatic int ext4_orphan_file_del(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_orphan_info *oi = &EXT4_SB(inode->i_sb)->s_orphan_info;\n\t__le32 *bdata;\n\tint blk, off;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(inode->i_sb);\n\tint ret = 0;\n\n\tif (!handle)\n\t\tgoto out;\n\tblk = EXT4_I(inode)->i_orphan_idx / inodes_per_ob;\n\toff = EXT4_I(inode)->i_orphan_idx % inodes_per_ob;\n\tif (WARN_ON_ONCE(blk >= oi->of_blocks))\n\t\tgoto out;\n\n\tret = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\toi->of_binfo[blk].ob_bh, EXT4_JTR_ORPHAN_FILE);\n\tif (ret)\n\t\tgoto out;\n\n\tbdata = (__le32 *)(oi->of_binfo[blk].ob_bh->b_data);\n\tbdata[off] = 0;\n\tatomic_inc(&oi->of_binfo[blk].ob_free_entries);\n\tret = ext4_handle_dirty_metadata(handle, NULL, oi->of_binfo[blk].ob_bh);\nout:\n\text4_clear_inode_state(inode, EXT4_STATE_ORPHAN_FILE);\n\tINIT_LIST_HEAD(&EXT4_I(inode)->i_orphan);\n\n\treturn ret;\n}\n\n \nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !inode_is_locked(inode));\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORPHAN_FILE))\n\t\treturn ext4_orphan_file_del(handle, inode);\n\n\t \n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t \n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\text4_debug(\"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t \n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\text4_debug(\"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\t\t\t    sbi->s_sbh, EXT4_JTR_NONE);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tlock_buffer(sbi->s_sbh);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\text4_superblock_csum_set(inode->i_sb);\n\t\tunlock_buffer(sbi->s_sbh);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\text4_debug(\"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int ext4_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb,\n\t\trcu_dereference_protected(EXT4_SB(sb)->s_qf_names[type],\n\t\t\t\t\t  lockdep_is_held(&sb->s_umount)),\n\t\tEXT4_SB(sb)->s_jquota_fmt, type);\n}\n#endif\n\nstatic void ext4_process_orphan(struct inode *inode,\n\t\t\t\tint *nr_truncates, int *nr_orphans)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tdquot_initialize(inode);\n\tif (inode->i_nlink) {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\text4_debug(\"truncating inode %lu to %lld bytes\\n\",\n\t\t\t   inode->i_ino, inode->i_size);\n\t\tinode_lock(inode);\n\t\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\t\tret = ext4_truncate(inode);\n\t\tif (ret) {\n\t\t\t \n\t\t\text4_orphan_del(NULL, inode);\n\t\t\text4_std_error(inode->i_sb, ret);\n\t\t}\n\t\tinode_unlock(inode);\n\t\t(*nr_truncates)++;\n\t} else {\n\t\tif (test_opt(sb, DEBUG))\n\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t__func__, inode->i_ino);\n\t\text4_debug(\"deleting unreferenced inode %lu\\n\",\n\t\t\t   inode->i_ino);\n\t\t(*nr_orphans)++;\n\t}\n\tiput(inode);   \n}\n\n \nvoid ext4_orphan_cleanup(struct super_block *sb, struct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n\tstruct inode *inode;\n\tint i, j;\n#ifdef CONFIG_QUOTA\n\tint quota_update = 0;\n#endif\n\t__le32 *bdata;\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(sb);\n\n\tif (!es->s_last_orphan && !oi->of_blocks) {\n\t\text4_debug(\"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t \n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t \n\t\tif (es->s_last_orphan && !(s_flags & SB_RDONLY)) {\n\t\t\text4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\text4_debug(\"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & SB_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~SB_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t \n\tif (ext4_has_feature_quota(sb) && (s_flags & SB_RDONLY)) {\n\t\tint ret = ext4_enable_quotas(sb);\n\n\t\tif (!ret)\n\t\t\tquota_update = 1;\n\t\telse\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\"Cannot turn on quotas: error %d\", ret);\n\t}\n\n\t \n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\n\t\t\tif (!ret)\n\t\t\t\tquota_update = 1;\n\t\t\telse\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: type %d: error %d\", i, ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\t \n\t\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\t\text4_debug(\"Skipping orphan recovery on fs with errors.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\text4_process_orphan(inode, &nr_truncates, &nr_orphans);\n\t}\n\n\tfor (i = 0; i < oi->of_blocks; i++) {\n\t\tbdata = (__le32 *)(oi->of_binfo[i].ob_bh->b_data);\n\t\tfor (j = 0; j < inodes_per_ob; j++) {\n\t\t\tif (!bdata[j])\n\t\t\t\tcontinue;\n\t\t\tinode = ext4_orphan_get(sb, le32_to_cpu(bdata[j]));\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tcontinue;\n\t\t\text4_set_inode_state(inode, EXT4_STATE_ORPHAN_FILE);\n\t\t\tEXT4_I(inode)->i_orphan_idx = i * inodes_per_ob + j;\n\t\t\text4_process_orphan(inode, &nr_truncates, &nr_orphans);\n\t\t}\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t \n\tif (quota_update) {\n\t\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\t\tif (sb_dqopt(sb)->files[i])\n\t\t\t\tdquot_quota_off(sb, i);\n\t\t}\n\t}\n#endif\n\tsb->s_flags = s_flags;  \n}\n\nvoid ext4_release_orphan_info(struct super_block *sb)\n{\n\tint i;\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\n\tif (!oi->of_blocks)\n\t\treturn;\n\tfor (i = 0; i < oi->of_blocks; i++)\n\t\tbrelse(oi->of_binfo[i].ob_bh);\n\tkfree(oi->of_binfo);\n}\n\nstatic struct ext4_orphan_block_tail *ext4_orphan_block_tail(\n\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\treturn (struct ext4_orphan_block_tail *)(bh->b_data + sb->s_blocksize -\n\t\t\t\tsizeof(struct ext4_orphan_block_tail));\n}\n\nstatic int ext4_orphan_file_block_csum_verify(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh)\n{\n\t__u32 calculated;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(sb);\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\tstruct ext4_orphan_block_tail *ot;\n\t__le64 dsk_block_nr = cpu_to_le64(bh->b_blocknr);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn 1;\n\n\tot = ext4_orphan_block_tail(sb, bh);\n\tcalculated = ext4_chksum(EXT4_SB(sb), oi->of_csum_seed,\n\t\t\t\t (__u8 *)&dsk_block_nr, sizeof(dsk_block_nr));\n\tcalculated = ext4_chksum(EXT4_SB(sb), calculated, (__u8 *)bh->b_data,\n\t\t\t\t inodes_per_ob * sizeof(__u32));\n\treturn le32_to_cpu(ot->ob_checksum) == calculated;\n}\n\n \nvoid ext4_orphan_file_block_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    void *data, size_t size)\n{\n\tstruct super_block *sb = EXT4_TRIGGER(triggers)->sb;\n\t__u32 csum;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(sb);\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\tstruct ext4_orphan_block_tail *ot;\n\t__le64 dsk_block_nr = cpu_to_le64(bh->b_blocknr);\n\n\tcsum = ext4_chksum(EXT4_SB(sb), oi->of_csum_seed,\n\t\t\t   (__u8 *)&dsk_block_nr, sizeof(dsk_block_nr));\n\tcsum = ext4_chksum(EXT4_SB(sb), csum, (__u8 *)data,\n\t\t\t   inodes_per_ob * sizeof(__u32));\n\tot = ext4_orphan_block_tail(sb, bh);\n\tot->ob_checksum = cpu_to_le32(csum);\n}\n\nint ext4_init_orphan_info(struct super_block *sb)\n{\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\tstruct inode *inode;\n\tint i, j;\n\tint ret;\n\tint free;\n\t__le32 *bdata;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(sb);\n\tstruct ext4_orphan_block_tail *ot;\n\tino_t orphan_ino = le32_to_cpu(EXT4_SB(sb)->s_es->s_orphan_file_inum);\n\n\tif (!ext4_has_feature_orphan_file(sb))\n\t\treturn 0;\n\n\tinode = ext4_iget(sb, orphan_ino, EXT4_IGET_SPECIAL);\n\tif (IS_ERR(inode)) {\n\t\text4_msg(sb, KERN_ERR, \"get orphan inode failed\");\n\t\treturn PTR_ERR(inode);\n\t}\n\toi->of_blocks = inode->i_size >> sb->s_blocksize_bits;\n\toi->of_csum_seed = EXT4_I(inode)->i_csum_seed;\n\toi->of_binfo = kmalloc(oi->of_blocks*sizeof(struct ext4_orphan_block),\n\t\t\t       GFP_KERNEL);\n\tif (!oi->of_binfo) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\tfor (i = 0; i < oi->of_blocks; i++) {\n\t\toi->of_binfo[i].ob_bh = ext4_bread(NULL, inode, i, 0);\n\t\tif (IS_ERR(oi->of_binfo[i].ob_bh)) {\n\t\t\tret = PTR_ERR(oi->of_binfo[i].ob_bh);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!oi->of_binfo[i].ob_bh) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_free;\n\t\t}\n\t\tot = ext4_orphan_block_tail(sb, oi->of_binfo[i].ob_bh);\n\t\tif (le32_to_cpu(ot->ob_magic) != EXT4_ORPHAN_BLOCK_MAGIC) {\n\t\t\text4_error(sb, \"orphan file block %d: bad magic\", i);\n\t\t\tret = -EIO;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!ext4_orphan_file_block_csum_verify(sb,\n\t\t\t\t\t\toi->of_binfo[i].ob_bh)) {\n\t\t\text4_error(sb, \"orphan file block %d: bad checksum\", i);\n\t\t\tret = -EIO;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbdata = (__le32 *)(oi->of_binfo[i].ob_bh->b_data);\n\t\tfree = 0;\n\t\tfor (j = 0; j < inodes_per_ob; j++)\n\t\t\tif (bdata[j] == 0)\n\t\t\t\tfree++;\n\t\tatomic_set(&oi->of_binfo[i].ob_free_entries, free);\n\t}\n\tiput(inode);\n\treturn 0;\nout_free:\n\tfor (i--; i >= 0; i--)\n\t\tbrelse(oi->of_binfo[i].ob_bh);\n\tkfree(oi->of_binfo);\nout_put:\n\tiput(inode);\n\treturn ret;\n}\n\nint ext4_orphan_file_empty(struct super_block *sb)\n{\n\tstruct ext4_orphan_info *oi = &EXT4_SB(sb)->s_orphan_info;\n\tint i;\n\tint inodes_per_ob = ext4_inodes_per_orphan_block(sb);\n\n\tif (!ext4_has_feature_orphan_file(sb))\n\t\treturn 1;\n\tfor (i = 0; i < oi->of_blocks; i++)\n\t\tif (atomic_read(&oi->of_binfo[i].ob_free_entries) !=\n\t\t    inodes_per_ob)\n\t\t\treturn 0;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}