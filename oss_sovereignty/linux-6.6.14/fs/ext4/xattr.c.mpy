{
  "module_name": "xattr.c",
  "hash_id": "1a6ef8e6e203982bcc92a24d8bf832b5dfa074aa1c9b005e442abc6bd2378b2d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/xattr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/mbcache.h>\n#include <linux/quotaops.h>\n#include <linux/iversion.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#ifdef EXT4_XATTR_DEBUG\n# define ea_idebug(inode, fmt, ...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"inode %s:%lu: \" fmt \"\\n\",\t\t\t\\\n\t       inode->i_sb->s_id, inode->i_ino, ##__VA_ARGS__)\n# define ea_bdebug(bh, fmt, ...)\t\t\t\t\t\\\n\tprintk(KERN_DEBUG \"block %pg:%lu: \" fmt \"\\n\",\t\t\t\\\n\t       bh->b_bdev, (unsigned long)bh->b_blocknr, ##__VA_ARGS__)\n#else\n# define ea_idebug(inode, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n# define ea_bdebug(bh, fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\nstatic void ext4_xattr_block_cache_insert(struct mb_cache *,\n\t\t\t\t\t  struct buffer_head *);\nstatic struct buffer_head *\next4_xattr_block_cache_find(struct inode *, struct ext4_xattr_header *,\n\t\t\t    struct mb_cache_entry **);\nstatic __le32 ext4_xattr_hash_entry(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count);\nstatic __le32 ext4_xattr_hash_entry_signed(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *);\n\nstatic const struct xattr_handler * const ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &nop_posix_acl_access,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &nop_posix_acl_default,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n\t[EXT4_XATTR_INDEX_HURD]\t\t     = &ext4_xattr_hurd_handler,\n};\n\nconst struct xattr_handler *ext4_xattr_handlers[] = {\n\t&ext4_xattr_user_handler,\n\t&ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t&ext4_xattr_security_handler,\n#endif\n\t&ext4_xattr_hurd_handler,\n\tNULL\n};\n\n#define EA_BLOCK_CACHE(inode)\t(((struct ext4_sb_info *) \\\n\t\t\t\tinode->i_sb->s_fs_info)->s_ea_block_cache)\n\n#define EA_INODE_CACHE(inode)\t(((struct ext4_sb_info *) \\\n\t\t\t\tinode->i_sb->s_fs_info)->s_ea_inode_cache)\n\nstatic int\next4_expand_inode_array(struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\tstruct inode *inode);\n\n#ifdef CONFIG_LOCKDEP\nvoid ext4_xattr_inode_set_class(struct inode *ea_inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(ea_inode);\n\n\tlockdep_set_subclass(&ea_inode->i_rwsem, 1);\n\t(void) ei;\t \n\tlockdep_set_subclass(&ei->i_data_sem, I_DATA_SEM_EA);\n}\n#endif\n\nstatic __le32 ext4_xattr_block_csum(struct inode *inode,\n\t\t\t\t    sector_t block_nr,\n\t\t\t\t    struct ext4_xattr_header *hdr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 csum;\n\t__le64 dsk_block_nr = cpu_to_le64(block_nr);\n\t__u32 dummy_csum = 0;\n\tint offset = offsetof(struct ext4_xattr_header, h_checksum);\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&dsk_block_nr,\n\t\t\t   sizeof(dsk_block_nr));\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)hdr, offset);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)&dummy_csum, sizeof(dummy_csum));\n\toffset += sizeof(dummy_csum);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)hdr + offset,\n\t\t\t   EXT4_BLOCK_SIZE(inode->i_sb) - offset);\n\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_xattr_block_csum_verify(struct inode *inode,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tstruct ext4_xattr_header *hdr = BHDR(bh);\n\tint ret = 1;\n\n\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\tlock_buffer(bh);\n\t\tret = (hdr->h_checksum == ext4_xattr_block_csum(inode,\n\t\t\t\t\t\t\tbh->b_blocknr, hdr));\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}\n\nstatic void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tBHDR(bh)->h_checksum = ext4_xattr_block_csum(inode,\n\t\t\t\t\t\tbh->b_blocknr, BHDR(bh));\n}\n\nstatic inline const char *ext4_xattr_prefix(int name_index,\n\t\t\t\t\t    struct dentry *dentry)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\n\tif (!xattr_handler_can_list(handler, dentry))\n\t\treturn NULL;\n\n\treturn xattr_prefix(handler);\n}\n\nstatic int\ncheck_xattrs(struct inode *inode, struct buffer_head *bh,\n\t     struct ext4_xattr_entry *entry, void *end, void *value_start,\n\t     const char *function, unsigned int line)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\tint err = -EFSCORRUPTED;\n\tchar *err_str;\n\n\tif (bh) {\n\t\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t\t    BHDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\t\terr_str = \"invalid header\";\n\t\t\tgoto errout;\n\t\t}\n\t\tif (buffer_verified(bh))\n\t\t\treturn 0;\n\t\tif (!ext4_xattr_block_csum_verify(inode, bh)) {\n\t\t\terr = -EFSBADCRC;\n\t\t\terr_str = \"invalid checksum\";\n\t\t\tgoto errout;\n\t\t}\n\t} else {\n\t\tstruct ext4_xattr_ibody_header *header = value_start;\n\n\t\theader -= 1;\n\t\tif (end - (void *)header < sizeof(*header) + sizeof(u32)) {\n\t\t\terr_str = \"in-inode xattr block too small\";\n\t\t\tgoto errout;\n\t\t}\n\t\tif (header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\t\terr_str = \"bad magic number in in-inode xattr\";\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\t \n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end) {\n\t\t\terr_str = \"e_name out of bounds\";\n\t\t\tgoto errout;\n\t\t}\n\t\tif (strnlen(e->e_name, e->e_name_len) != e->e_name_len) {\n\t\t\terr_str = \"bad e_name length\";\n\t\t\tgoto errout;\n\t\t}\n\t\te = next;\n\t}\n\n\t \n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tu32 size = le32_to_cpu(entry->e_value_size);\n\t\tunsigned long ea_ino = le32_to_cpu(entry->e_value_inum);\n\n\t\tif (!ext4_has_feature_ea_inode(inode->i_sb) && ea_ino) {\n\t\t\terr_str = \"ea_inode specified without ea_inode feature enabled\";\n\t\t\tgoto errout;\n\t\t}\n\t\tif (ea_ino && ((ea_ino == EXT4_ROOT_INO) ||\n\t\t\t       !ext4_valid_inum(inode->i_sb, ea_ino))) {\n\t\t\terr_str = \"invalid ea_ino\";\n\t\t\tgoto errout;\n\t\t}\n\t\tif (size > EXT4_XATTR_SIZE_MAX) {\n\t\t\terr_str = \"e_value size too large\";\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (size != 0 && entry->e_value_inum == 0) {\n\t\t\tu16 offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *value;\n\n\t\t\t \n\t\t\tif (offs > end - value_start) {\n\t\t\t\terr_str = \"e_value out of bounds\";\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tvalue = value_start + offs;\n\t\t\tif (value < (void *)e + sizeof(u32) ||\n\t\t\t    size > end - value ||\n\t\t\t    EXT4_XATTR_SIZE(size) > end - value) {\n\t\t\t\terr_str = \"overlapping e_value \";\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\tif (bh)\n\t\tset_buffer_verified(bh);\n\treturn 0;\n\nerrout:\n\tif (bh)\n\t\t__ext4_error_inode(inode, function, line, 0, -err,\n\t\t\t\t   \"corrupted xattr block %llu: %s\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr,\n\t\t\t\t   err_str);\n\telse\n\t\t__ext4_error_inode(inode, function, line, 0, -err,\n\t\t\t\t   \"corrupted in-inode xattr: %s\", err_str);\n\treturn err;\n}\n\nstatic inline int\n__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\treturn check_xattrs(inode, bh, BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t    bh->b_data, function, line);\n}\n\n#define ext4_xattr_check_block(inode, bh) \\\n\t__ext4_xattr_check_block((inode), (bh),  __func__, __LINE__)\n\n\nstatic inline int\n__xattr_check_inode(struct inode *inode, struct ext4_xattr_ibody_header *header,\n\t\t\t void *end, const char *function, unsigned int line)\n{\n\treturn check_xattrs(inode, NULL, IFIRST(header), end, IFIRST(header),\n\t\t\t    function, line);\n}\n\n#define xattr_check_inode(inode, header, end) \\\n\t__xattr_check_inode((inode), (header), (end), __func__, __LINE__)\n\nstatic int\nxattr_find_entry(struct inode *inode, struct ext4_xattr_entry **pentry,\n\t\t void *end, int name_index, const char *name, int sorted)\n{\n\tstruct ext4_xattr_entry *entry, *next;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tfor (entry = *pentry; !IS_LAST_ENTRY(entry); entry = next) {\n\t\tnext = EXT4_XATTR_NEXT(entry);\n\t\tif ((void *) next >= end) {\n\t\t\tEXT4_ERROR_INODE(inode, \"corrupted xattr entries\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\treturn cmp ? -ENODATA : 0;\n}\n\nstatic u32\next4_xattr_inode_hash(struct ext4_sb_info *sbi, const void *buffer, size_t size)\n{\n\treturn ext4_chksum(sbi, sbi->s_csum_seed, buffer, size);\n}\n\nstatic u64 ext4_xattr_inode_get_ref(struct inode *ea_inode)\n{\n\treturn ((u64) inode_get_ctime(ea_inode).tv_sec << 32) |\n\t\t(u32) inode_peek_iversion_raw(ea_inode);\n}\n\nstatic void ext4_xattr_inode_set_ref(struct inode *ea_inode, u64 ref_count)\n{\n\tinode_set_ctime(ea_inode, (u32)(ref_count >> 32), 0);\n\tinode_set_iversion_raw(ea_inode, ref_count & 0xffffffff);\n}\n\nstatic u32 ext4_xattr_inode_get_hash(struct inode *ea_inode)\n{\n\treturn (u32)ea_inode->i_atime.tv_sec;\n}\n\nstatic void ext4_xattr_inode_set_hash(struct inode *ea_inode, u32 hash)\n{\n\tea_inode->i_atime.tv_sec = hash;\n}\n\n \nstatic int ext4_xattr_inode_read(struct inode *ea_inode, void *buf, size_t size)\n{\n\tint blocksize = 1 << ea_inode->i_blkbits;\n\tint bh_count = (size + blocksize - 1) >> ea_inode->i_blkbits;\n\tint tail_size = (size % blocksize) ?: blocksize;\n\tstruct buffer_head *bhs_inline[8];\n\tstruct buffer_head **bhs = bhs_inline;\n\tint i, ret;\n\n\tif (bh_count > ARRAY_SIZE(bhs_inline)) {\n\t\tbhs = kmalloc_array(bh_count, sizeof(*bhs), GFP_NOFS);\n\t\tif (!bhs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = ext4_bread_batch(ea_inode, 0  , bh_count,\n\t\t\t       true  , bhs);\n\tif (ret)\n\t\tgoto free_bhs;\n\n\tfor (i = 0; i < bh_count; i++) {\n\t\t \n\t\tif (!bhs[i]) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto put_bhs;\n\t\t}\n\t\tmemcpy((char *)buf + blocksize * i, bhs[i]->b_data,\n\t\t       i < bh_count - 1 ? blocksize : tail_size);\n\t}\n\tret = 0;\nput_bhs:\n\tfor (i = 0; i < bh_count; i++)\n\t\tbrelse(bhs[i]);\nfree_bhs:\n\tif (bhs != bhs_inline)\n\t\tkfree(bhs);\n\treturn ret;\n}\n\n#define EXT4_XATTR_INODE_GET_PARENT(inode) ((__u32)(inode)->i_mtime.tv_sec)\n\nstatic int ext4_xattr_inode_iget(struct inode *parent, unsigned long ea_ino,\n\t\t\t\t u32 ea_inode_hash, struct inode **ea_inode)\n{\n\tstruct inode *inode;\n\tint err;\n\n\t \n\tif (parent->i_ino == ea_ino) {\n\t\text4_error(parent->i_sb,\n\t\t\t   \"Parent and EA inode have the same ino %lu\", ea_ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tinode = ext4_iget(parent->i_sb, ea_ino, EXT4_IGET_EA_INODE);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\text4_error(parent->i_sb,\n\t\t\t   \"error while reading EA inode %lu err=%d\", ea_ino,\n\t\t\t   err);\n\t\treturn err;\n\t}\n\text4_xattr_inode_set_class(inode);\n\n\t \n\tif (ea_inode_hash != ext4_xattr_inode_get_hash(inode) &&\n\t    EXT4_XATTR_INODE_GET_PARENT(inode) == parent->i_ino &&\n\t    inode->i_generation == parent->i_generation) {\n\t\text4_set_inode_state(inode, EXT4_STATE_LUSTRE_EA_INODE);\n\t\text4_xattr_inode_set_ref(inode, 1);\n\t} else {\n\t\tinode_lock(inode);\n\t\tinode->i_flags |= S_NOQUOTA;\n\t\tinode_unlock(inode);\n\t}\n\n\t*ea_inode = inode;\n\treturn 0;\n}\n\n \nvoid ext4_evict_ea_inode(struct inode *inode)\n{\n\tstruct mb_cache_entry *oe;\n\n\tif (!EA_INODE_CACHE(inode))\n\t\treturn;\n\t \n\twhile ((oe = mb_cache_entry_delete_or_get(EA_INODE_CACHE(inode),\n\t\t\text4_xattr_inode_get_hash(inode), inode->i_ino))) {\n\t\tmb_cache_entry_wait_unused(oe);\n\t\tmb_cache_entry_put(EA_INODE_CACHE(inode), oe);\n\t}\n}\n\nstatic int\next4_xattr_inode_verify_hashes(struct inode *ea_inode,\n\t\t\t       struct ext4_xattr_entry *entry, void *buffer,\n\t\t\t       size_t size)\n{\n\tu32 hash;\n\n\t \n\thash = ext4_xattr_inode_hash(EXT4_SB(ea_inode->i_sb), buffer, size);\n\tif (hash != ext4_xattr_inode_get_hash(ea_inode))\n\t\treturn -EFSCORRUPTED;\n\n\tif (entry) {\n\t\t__le32 e_hash, tmp_data;\n\n\t\t \n\t\ttmp_data = cpu_to_le32(hash);\n\t\te_hash = ext4_xattr_hash_entry(entry->e_name, entry->e_name_len,\n\t\t\t\t\t       &tmp_data, 1);\n\t\t \n\t\tif (e_hash == entry->e_hash)\n\t\t\treturn 0;\n\n\t\t \n\t\te_hash = ext4_xattr_hash_entry_signed(entry->e_name, entry->e_name_len,\n\t\t\t\t\t\t\t&tmp_data, 1);\n\t\t \n\t\tif (e_hash != entry->e_hash)\n\t\t\treturn -EFSCORRUPTED;\n\n\t\t \n\t\tpr_warn_once(\"ext4: filesystem with signed xattr name hash\");\n\t}\n\treturn 0;\n}\n\n \nstatic int\next4_xattr_inode_get(struct inode *inode, struct ext4_xattr_entry *entry,\n\t\t     void *buffer, size_t size)\n{\n\tstruct mb_cache *ea_inode_cache = EA_INODE_CACHE(inode);\n\tstruct inode *ea_inode;\n\tint err;\n\n\terr = ext4_xattr_inode_iget(inode, le32_to_cpu(entry->e_value_inum),\n\t\t\t\t    le32_to_cpu(entry->e_hash), &ea_inode);\n\tif (err) {\n\t\tea_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tif (i_size_read(ea_inode) != size) {\n\t\text4_warning_inode(ea_inode,\n\t\t\t\t   \"ea_inode file size=%llu entry size=%zu\",\n\t\t\t\t   i_size_read(ea_inode), size);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\terr = ext4_xattr_inode_read(ea_inode, buffer, size);\n\tif (err)\n\t\tgoto out;\n\n\tif (!ext4_test_inode_state(ea_inode, EXT4_STATE_LUSTRE_EA_INODE)) {\n\t\terr = ext4_xattr_inode_verify_hashes(ea_inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t   \"EA inode hash validation failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ea_inode_cache)\n\t\t\tmb_cache_entry_create(ea_inode_cache, GFP_NOFS,\n\t\t\t\t\text4_xattr_inode_get_hash(ea_inode),\n\t\t\t\t\tea_inode->i_ino, true  );\n\t}\nout:\n\tiput(ea_inode);\n\treturn err;\n}\n\nstatic int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\treturn -ENODATA;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\terror = ext4_xattr_check_block(inode, bh);\n\tif (error)\n\t\tgoto cleanup;\n\text4_xattr_block_cache_insert(ea_block_cache, bh);\n\tentry = BFIRST(bh);\n\tend = bh->b_data + bh->b_size;\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 1);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\terror = -ERANGE;\n\tif (unlikely(size > EXT4_XATTR_SIZE_MAX))\n\t\tgoto cleanup;\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\terror = ext4_xattr_inode_get(inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tu16 offset = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *p = bh->b_data + offset;\n\n\t\t\tif (unlikely(p + size > end))\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(buffer, p, size);\n\t\t}\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}\n\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\tentry = IFIRST(header);\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\terror = -ERANGE;\n\tif (unlikely(size > EXT4_XATTR_SIZE_MAX))\n\t\tgoto cleanup;\n\tif (buffer) {\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\terror = ext4_xattr_inode_get(inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tu16 offset = le16_to_cpu(entry->e_value_offs);\n\t\t\tvoid *p = (void *)IFIRST(header) + offset;\n\n\t\t\tif (unlikely(p + size > end))\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(buffer, p, size);\n\t\t}\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}\n\n \nint\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}\n\nstatic int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst char *prefix;\n\n\t\tprefix = ext4_xattr_prefix(entry->e_name_index, dentry);\n\t\tif (prefix) {\n\t\t\tsize_t prefix_len = strlen(prefix);\n\t\t\tsize_t size = prefix_len + entry->e_name_len + 1;\n\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\t\tbuffer += prefix_len;\n\t\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\t\tbuffer += entry->e_name_len;\n\t\t\t\t*buffer++ = 0;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;   \n}\n\nstatic int\next4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\treturn 0;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\terror = ext4_xattr_check_block(inode, bh);\n\tif (error)\n\t\tgoto cleanup;\n\text4_xattr_block_cache_insert(EA_BLOCK_CACHE(inode), bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer,\n\t\t\t\t\tbuffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}\n\nstatic int\next4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}\n\n \nssize_t\next4_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret, ret2;\n\n\tdown_read(&EXT4_I(d_inode(dentry))->xattr_sem);\n\tret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tif (buffer) {\n\t\tbuffer += ret;\n\t\tbuffer_size -= ret;\n\t}\n\tret = ext4_xattr_block_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tret += ret2;\nerrout:\n\tup_read(&EXT4_I(d_inode(dentry))->xattr_sem);\n\treturn ret;\n}\n\n \nstatic void ext4_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (ext4_has_feature_xattr(sb))\n\t\treturn;\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\tif (ext4_journal_get_write_access(handle, sb, EXT4_SB(sb)->s_sbh,\n\t\t\t\t\t  EXT4_JTR_NONE) == 0) {\n\t\tlock_buffer(EXT4_SB(sb)->s_sbh);\n\t\text4_set_feature_xattr(sb);\n\t\text4_superblock_csum_set(sb);\n\t\tunlock_buffer(EXT4_SB(sb)->s_sbh);\n\t\text4_handle_dirty_metadata(handle, NULL, EXT4_SB(sb)->s_sbh);\n\t}\n}\n\nint ext4_get_inode_usage(struct inode *inode, qsize_t *usage)\n{\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tqsize_t ea_inode_refs = 0;\n\tvoid *end;\n\tint ret;\n\n\tlockdep_assert_held_read(&EXT4_I(inode)->xattr_sem);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\tret = ext4_get_inode_loc(inode, &iloc);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\traw_inode = ext4_raw_inode(&iloc);\n\t\theader = IHDR(inode, raw_inode);\n\t\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\t\tret = xattr_check_inode(inode, header, end);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tfor (entry = IFIRST(header); !IS_LAST_ENTRY(entry);\n\t\t     entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\tea_inode_refs++;\n\t}\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ext4_xattr_check_block(inode, bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tfor (entry = BFIRST(bh); !IS_LAST_ENTRY(entry);\n\t\t     entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\tea_inode_refs++;\n\t}\n\t*usage = ea_inode_refs + 1;\n\tret = 0;\nout:\n\tbrelse(iloc.bh);\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic inline size_t round_up_cluster(struct inode *inode, size_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tsize_t cluster_size = 1 << (EXT4_SB(sb)->s_cluster_bits +\n\t\t\t\t    inode->i_blkbits);\n\tsize_t mask = ~(cluster_size - 1);\n\n\treturn (length + cluster_size - 1) & mask;\n}\n\nstatic int ext4_xattr_inode_alloc_quota(struct inode *inode, size_t len)\n{\n\tint err;\n\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\treturn err;\n\terr = dquot_alloc_space_nodirty(inode, round_up_cluster(inode, len));\n\tif (err)\n\t\tdquot_free_inode(inode);\n\treturn err;\n}\n\nstatic void ext4_xattr_inode_free_quota(struct inode *parent,\n\t\t\t\t\tstruct inode *ea_inode,\n\t\t\t\t\tsize_t len)\n{\n\tif (ea_inode &&\n\t    ext4_test_inode_state(ea_inode, EXT4_STATE_LUSTRE_EA_INODE))\n\t\treturn;\n\tdquot_free_space_nodirty(parent, round_up_cluster(parent, len));\n\tdquot_free_inode(parent);\n}\n\nint __ext4_xattr_set_credits(struct super_block *sb, struct inode *inode,\n\t\t\t     struct buffer_head *block_bh, size_t value_len,\n\t\t\t     bool is_create)\n{\n\tint credits;\n\tint blocks;\n\n\t \n\tcredits = 7;\n\n\t \n\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(sb);\n\n\t \n\tif (inode && ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\n\t \n\tif (!ext4_has_feature_ea_inode(sb))\n\t\treturn credits;\n\n\t \n\tcredits += 4;\n\n\t \n\tblocks = (value_len + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\n\t \n\tblocks += 1;\n\n\t \n\tcredits += blocks * 2;\n\n\t \n\tcredits += blocks;\n\n\tif (!is_create) {\n\t\t \n\t\tcredits += 4;\n\n\t\t \n\t\tblocks = XATTR_SIZE_MAX >> sb->s_blocksize_bits;\n\n\t\t \n\t\tblocks += 1;\n\n\t\t \n\t\tcredits += blocks * 2;\n\t}\n\n\t \n\tif (block_bh) {\n\t\tstruct ext4_xattr_entry *entry = BFIRST(block_bh);\n\n\t\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry))\n\t\t\tif (entry->e_value_inum)\n\t\t\t\t \n\t\t\t\tcredits += 1;\n\t}\n\treturn credits;\n}\n\nstatic int ext4_xattr_inode_update_ref(handle_t *handle, struct inode *ea_inode,\n\t\t\t\t       int ref_change)\n{\n\tstruct ext4_iloc iloc;\n\ts64 ref_count;\n\tint ret;\n\n\tinode_lock(ea_inode);\n\n\tret = ext4_reserve_inode_write(handle, ea_inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tref_count = ext4_xattr_inode_get_ref(ea_inode);\n\tref_count += ref_change;\n\text4_xattr_inode_set_ref(ea_inode, ref_count);\n\n\tif (ref_change > 0) {\n\t\tWARN_ONCE(ref_count <= 0, \"EA inode %lu ref_count=%lld\",\n\t\t\t  ea_inode->i_ino, ref_count);\n\n\t\tif (ref_count == 1) {\n\t\t\tWARN_ONCE(ea_inode->i_nlink, \"EA inode %lu i_nlink=%u\",\n\t\t\t\t  ea_inode->i_ino, ea_inode->i_nlink);\n\n\t\t\tset_nlink(ea_inode, 1);\n\t\t\text4_orphan_del(handle, ea_inode);\n\t\t}\n\t} else {\n\t\tWARN_ONCE(ref_count < 0, \"EA inode %lu ref_count=%lld\",\n\t\t\t  ea_inode->i_ino, ref_count);\n\n\t\tif (ref_count == 0) {\n\t\t\tWARN_ONCE(ea_inode->i_nlink != 1,\n\t\t\t\t  \"EA inode %lu i_nlink=%u\",\n\t\t\t\t  ea_inode->i_ino, ea_inode->i_nlink);\n\n\t\t\tclear_nlink(ea_inode);\n\t\t\text4_orphan_add(handle, ea_inode);\n\t\t}\n\t}\n\n\tret = ext4_mark_iloc_dirty(handle, ea_inode, &iloc);\n\tif (ret)\n\t\text4_warning_inode(ea_inode,\n\t\t\t\t   \"ext4_mark_iloc_dirty() failed ret=%d\", ret);\nout:\n\tinode_unlock(ea_inode);\n\treturn ret;\n}\n\nstatic int ext4_xattr_inode_inc_ref(handle_t *handle, struct inode *ea_inode)\n{\n\treturn ext4_xattr_inode_update_ref(handle, ea_inode, 1);\n}\n\nstatic int ext4_xattr_inode_dec_ref(handle_t *handle, struct inode *ea_inode)\n{\n\treturn ext4_xattr_inode_update_ref(handle, ea_inode, -1);\n}\n\nstatic int ext4_xattr_inode_inc_ref_all(handle_t *handle, struct inode *parent,\n\t\t\t\t\tstruct ext4_xattr_entry *first)\n{\n\tstruct inode *ea_inode;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *failed_entry;\n\tunsigned int ea_ino;\n\tint err, saved_err;\n\n\tfor (entry = first; !IS_LAST_ENTRY(entry);\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\terr = ext4_xattr_inode_inc_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode, \"inc ref error %d\", err);\n\t\t\tiput(ea_inode);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tiput(ea_inode);\n\t}\n\treturn 0;\n\ncleanup:\n\tsaved_err = err;\n\tfailed_entry = entry;\n\n\tfor (entry = first; entry != failed_entry;\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err) {\n\t\t\text4_warning(parent->i_sb,\n\t\t\t\t     \"cleanup ea_ino %u iget error %d\", ea_ino,\n\t\t\t\t     err);\n\t\t\tcontinue;\n\t\t}\n\t\terr = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (err)\n\t\t\text4_warning_inode(ea_inode, \"cleanup dec ref error %d\",\n\t\t\t\t\t   err);\n\t\tiput(ea_inode);\n\t}\n\treturn saved_err;\n}\n\nstatic int ext4_xattr_restart_fn(handle_t *handle, struct inode *inode,\n\t\t\tstruct buffer_head *bh, bool block_csum, bool dirty)\n{\n\tint error;\n\n\tif (bh && dirty) {\n\t\tif (block_csum)\n\t\t\text4_xattr_block_csum_set(inode, bh);\n\t\terror = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (error) {\n\t\t\text4_warning(inode->i_sb, \"Handle metadata (error %d)\",\n\t\t\t\t     error);\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\next4_xattr_inode_dec_ref_all(handle_t *handle, struct inode *parent,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     struct ext4_xattr_entry *first, bool block_csum,\n\t\t\t     struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t     int extra_credits, bool skip_quota)\n{\n\tstruct inode *ea_inode;\n\tstruct ext4_xattr_entry *entry;\n\tbool dirty = false;\n\tunsigned int ea_ino;\n\tint err;\n\tint credits;\n\n\t \n\tcredits = 2 + extra_credits;\n\n\tfor (entry = first; !IS_LAST_ENTRY(entry);\n\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\tif (!entry->e_value_inum)\n\t\t\tcontinue;\n\t\tea_ino = le32_to_cpu(entry->e_value_inum);\n\t\terr = ext4_xattr_inode_iget(parent, ea_ino,\n\t\t\t\t\t    le32_to_cpu(entry->e_hash),\n\t\t\t\t\t    &ea_inode);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = ext4_expand_inode_array(ea_inode_array, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t   \"Expand inode array err=%d\", err);\n\t\t\tiput(ea_inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ext4_journal_ensure_credits_fn(handle, credits, credits,\n\t\t\text4_free_metadata_revoke_credits(parent->i_sb, 1),\n\t\t\text4_xattr_restart_fn(handle, parent, bh, block_csum,\n\t\t\t\t\t      dirty));\n\t\tif (err < 0) {\n\t\t\text4_warning_inode(ea_inode, \"Ensure credits err=%d\",\n\t\t\t\t\t   err);\n\t\t\tcontinue;\n\t\t}\n\t\tif (err > 0) {\n\t\t\terr = ext4_journal_get_write_access(handle,\n\t\t\t\t\tparent->i_sb, bh, EXT4_JTR_NONE);\n\t\t\tif (err) {\n\t\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t\t\"Re-get write access err=%d\",\n\t\t\t\t\t\terr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\terr = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\text4_warning_inode(ea_inode, \"ea_inode dec ref err=%d\",\n\t\t\t\t\t   err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skip_quota)\n\t\t\text4_xattr_inode_free_quota(parent, ea_inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\n\t\t \n\t\tentry->e_value_inum = 0;\n\t\tentry->e_value_size = 0;\n\n\t\tdirty = true;\n\t}\n\n\tif (dirty) {\n\t\t \n\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\text4_warning_inode(parent,\n\t\t\t\t\t   \"handle dirty metadata err=%d\", err);\n\t}\n}\n\n \nstatic void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh,\n\t\t\t struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t int extra_credits)\n{\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\tu32 hash, ref;\n\tint error = 0;\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, inode->i_sb, bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (error)\n\t\tgoto out;\n\nretry_ref:\n\tlock_buffer(bh);\n\thash = le32_to_cpu(BHDR(bh)->h_hash);\n\tref = le32_to_cpu(BHDR(bh)->h_refcount);\n\tif (ref == 1) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\t \n\t\tif (ea_block_cache) {\n\t\t\tstruct mb_cache_entry *oe;\n\n\t\t\toe = mb_cache_entry_delete_or_get(ea_block_cache, hash,\n\t\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\tif (oe) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tmb_cache_entry_wait_unused(oe);\n\t\t\t\tmb_cache_entry_put(ea_block_cache, oe);\n\t\t\t\tgoto retry_ref;\n\t\t\t}\n\t\t}\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb))\n\t\t\text4_xattr_inode_dec_ref_all(handle, inode, bh,\n\t\t\t\t\t\t     BFIRST(bh),\n\t\t\t\t\t\t     true  ,\n\t\t\t\t\t\t     ea_inode_array,\n\t\t\t\t\t\t     extra_credits,\n\t\t\t\t\t\t     true  );\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tref--;\n\t\tBHDR(bh)->h_refcount = cpu_to_le32(ref);\n\t\tif (ref == EXT4_XATTR_REFCOUNT_MAX - 1) {\n\t\t\tstruct mb_cache_entry *ce;\n\n\t\t\tif (ea_block_cache) {\n\t\t\t\tce = mb_cache_entry_get(ea_block_cache, hash,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (ce) {\n\t\t\t\t\tset_bit(MBE_REUSABLE_B, &ce->e_flags);\n\t\t\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\text4_xattr_block_csum_set(inode, bh);\n\t\t \n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}\n\n \nstatic size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,\n\t\t\t\t    size_t *min_offs, void *base, int *total)\n{\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_inum && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < *min_offs)\n\t\t\t\t*min_offs = offs;\n\t\t}\n\t\tif (total)\n\t\t\t*total += EXT4_XATTR_LEN(last->e_name_len);\n\t}\n\treturn (*min_offs - ((void *)last - base) - sizeof(__u32));\n}\n\n \nstatic int ext4_xattr_inode_write(handle_t *handle, struct inode *ea_inode,\n\t\t\t\t  const void *buf, int bufsize)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block = 0;\n\tint blocksize = ea_inode->i_sb->s_blocksize;\n\tint max_blocks = (bufsize + blocksize - 1) >> ea_inode->i_blkbits;\n\tint csize, wsize = 0;\n\tint ret = 0, ret2 = 0;\n\tint retries = 0;\n\nretry:\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tstruct ext4_map_blocks map;\n\t\tmap.m_lblk = block += ret;\n\t\tmap.m_len = max_blocks -= ret;\n\n\t\tret = ext4_map_blocks(handle, ea_inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_CREATE);\n\t\tif (ret <= 0) {\n\t\t\text4_mark_inode_dirty(handle, ea_inode);\n\t\t\tif (ret == -ENOSPC &&\n\t\t\t    ext4_should_retry_alloc(ea_inode->i_sb, &retries)) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tblock = 0;\n\twhile (wsize < bufsize) {\n\t\tbrelse(bh);\n\t\tcsize = (bufsize - wsize) > blocksize ? blocksize :\n\t\t\t\t\t\t\t\tbufsize - wsize;\n\t\tbh = ext4_getblk(handle, ea_inode, block, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tif (!bh) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tEXT4_ERROR_INODE(ea_inode,\n\t\t\t\t\t \"ext4_getblk() return bh = NULL\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tret = ext4_journal_get_write_access(handle, ea_inode->i_sb, bh,\n\t\t\t\t\t\t   EXT4_JTR_NONE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmemcpy(bh->b_data, buf, csize);\n\t\tset_buffer_uptodate(bh);\n\t\text4_handle_dirty_metadata(handle, ea_inode, bh);\n\n\t\tbuf += csize;\n\t\twsize += csize;\n\t\tblock += 1;\n\t}\n\n\tinode_lock(ea_inode);\n\ti_size_write(ea_inode, wsize);\n\text4_update_i_disksize(ea_inode, wsize);\n\tinode_unlock(ea_inode);\n\n\tret2 = ext4_mark_inode_dirty(handle, ea_inode);\n\tif (unlikely(ret2 && !ret))\n\t\tret = ret2;\n\nout:\n\tbrelse(bh);\n\n\treturn ret;\n}\n\n \nstatic struct inode *ext4_xattr_inode_create(handle_t *handle,\n\t\t\t\t\t     struct inode *inode, u32 hash)\n{\n\tstruct inode *ea_inode = NULL;\n\tuid_t owner[2] = { i_uid_read(inode), i_gid_read(inode) };\n\tint err;\n\n\tif (inode->i_sb->s_root == NULL) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"refuse to create EA inode when umounting\");\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tea_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t  S_IFREG | 0600, NULL, inode->i_ino + 1, owner,\n\t\t\t\t  EXT4_EA_INODE_FL);\n\tif (!IS_ERR(ea_inode)) {\n\t\tea_inode->i_op = &ext4_file_inode_operations;\n\t\tea_inode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(ea_inode);\n\t\text4_xattr_inode_set_class(ea_inode);\n\t\tunlock_new_inode(ea_inode);\n\t\text4_xattr_inode_set_ref(ea_inode, 1);\n\t\text4_xattr_inode_set_hash(ea_inode, hash);\n\t\terr = ext4_mark_inode_dirty(handle, ea_inode);\n\t\tif (!err)\n\t\t\terr = ext4_inode_attach_jinode(ea_inode);\n\t\tif (err) {\n\t\t\tif (ext4_xattr_inode_dec_ref(handle, ea_inode))\n\t\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t\"cleanup dec ref error %d\", err);\n\t\t\tiput(ea_inode);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\t \n\t\tdquot_free_inode(ea_inode);\n\t\tdquot_drop(ea_inode);\n\t\tinode_lock(ea_inode);\n\t\tea_inode->i_flags |= S_NOQUOTA;\n\t\tinode_unlock(ea_inode);\n\t}\n\n\treturn ea_inode;\n}\n\nstatic struct inode *\next4_xattr_inode_cache_find(struct inode *inode, const void *value,\n\t\t\t    size_t value_len, u32 hash)\n{\n\tstruct inode *ea_inode;\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ea_inode_cache = EA_INODE_CACHE(inode);\n\tvoid *ea_data;\n\n\tif (!ea_inode_cache)\n\t\treturn NULL;\n\n\tce = mb_cache_entry_find_first(ea_inode_cache, hash);\n\tif (!ce)\n\t\treturn NULL;\n\n\tWARN_ON_ONCE(ext4_handle_valid(journal_current_handle()) &&\n\t\t     !(current->flags & PF_MEMALLOC_NOFS));\n\n\tea_data = kvmalloc(value_len, GFP_KERNEL);\n\tif (!ea_data) {\n\t\tmb_cache_entry_put(ea_inode_cache, ce);\n\t\treturn NULL;\n\t}\n\n\twhile (ce) {\n\t\tea_inode = ext4_iget(inode->i_sb, ce->e_value,\n\t\t\t\t     EXT4_IGET_EA_INODE);\n\t\tif (IS_ERR(ea_inode))\n\t\t\tgoto next_entry;\n\t\text4_xattr_inode_set_class(ea_inode);\n\t\tif (i_size_read(ea_inode) == value_len &&\n\t\t    !ext4_xattr_inode_read(ea_inode, ea_data, value_len) &&\n\t\t    !ext4_xattr_inode_verify_hashes(ea_inode, NULL, ea_data,\n\t\t\t\t\t\t    value_len) &&\n\t\t    !memcmp(value, ea_data, value_len)) {\n\t\t\tmb_cache_entry_touch(ea_inode_cache, ce);\n\t\t\tmb_cache_entry_put(ea_inode_cache, ce);\n\t\t\tkvfree(ea_data);\n\t\t\treturn ea_inode;\n\t\t}\n\t\tiput(ea_inode);\n\tnext_entry:\n\t\tce = mb_cache_entry_find_next(ea_inode_cache, ce);\n\t}\n\tkvfree(ea_data);\n\treturn NULL;\n}\n\n \nstatic int ext4_xattr_inode_lookup_create(handle_t *handle, struct inode *inode,\n\t\t\t\t\t  const void *value, size_t value_len,\n\t\t\t\t\t  struct inode **ret_inode)\n{\n\tstruct inode *ea_inode;\n\tu32 hash;\n\tint err;\n\n\thash = ext4_xattr_inode_hash(EXT4_SB(inode->i_sb), value, value_len);\n\tea_inode = ext4_xattr_inode_cache_find(inode, value, value_len, hash);\n\tif (ea_inode) {\n\t\terr = ext4_xattr_inode_inc_ref(handle, ea_inode);\n\t\tif (err) {\n\t\t\tiput(ea_inode);\n\t\t\treturn err;\n\t\t}\n\n\t\t*ret_inode = ea_inode;\n\t\treturn 0;\n\t}\n\n\t \n\tea_inode = ext4_xattr_inode_create(handle, inode, hash);\n\tif (IS_ERR(ea_inode))\n\t\treturn PTR_ERR(ea_inode);\n\n\terr = ext4_xattr_inode_write(handle, ea_inode, value, value_len);\n\tif (err) {\n\t\tif (ext4_xattr_inode_dec_ref(handle, ea_inode))\n\t\t\text4_warning_inode(ea_inode, \"cleanup dec ref error %d\", err);\n\t\tiput(ea_inode);\n\t\treturn err;\n\t}\n\n\tif (EA_INODE_CACHE(inode))\n\t\tmb_cache_entry_create(EA_INODE_CACHE(inode), GFP_NOFS, hash,\n\t\t\t\t      ea_inode->i_ino, true  );\n\n\t*ret_inode = ea_inode;\n\treturn 0;\n}\n\n \n#define EXT4_XATTR_BLOCK_RESERVE(inode)\tmin(i_blocksize(inode)/8, 1024U)\n\nstatic int ext4_xattr_set_entry(struct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_search *s,\n\t\t\t\thandle_t *handle, struct inode *inode,\n\t\t\t\tbool is_block)\n{\n\tstruct ext4_xattr_entry *last, *next;\n\tstruct ext4_xattr_entry *here = s->here;\n\tsize_t min_offs = s->end - s->base, name_len = strlen(i->name);\n\tint in_inode = i->in_inode;\n\tstruct inode *old_ea_inode = NULL;\n\tstruct inode *new_ea_inode = NULL;\n\tsize_t old_size, new_size;\n\tint ret;\n\n\t \n\told_size = (!s->not_found && !here->e_value_inum) ?\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(here->e_value_size)) : 0;\n\tnew_size = (i->value && !in_inode) ? EXT4_XATTR_SIZE(i->value_len) : 0;\n\n\t \n\tif (new_size && new_size == old_size) {\n\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\tvoid *val = s->base + offs;\n\n\t\there->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\tmemset(val, 0, new_size);\n\t\t} else {\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t \n\t\t\tmemset(val + i->value_len, 0, new_size - i->value_len);\n\t\t}\n\t\tgoto update_hash;\n\t}\n\n\t \n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = next) {\n\t\tnext = EXT4_XATTR_NEXT(last);\n\t\tif ((void *)next >= s->end) {\n\t\t\tEXT4_ERROR_INODE(inode, \"corrupted xattr entries\");\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!last->e_value_inum && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\n\t \n\tif (i->value) {\n\t\tsize_t free;\n\n\t\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\t\tif (!s->not_found)\n\t\t\tfree += EXT4_XATTR_LEN(name_len) + old_size;\n\n\t\tif (free < EXT4_XATTR_LEN(name_len) + new_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t    new_size && is_block &&\n\t\t    (min_offs + old_size - new_size) <\n\t\t\t\t\tEXT4_XATTR_BLOCK_RESERVE(inode)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!s->not_found && here->e_value_inum) {\n\t\tret = ext4_xattr_inode_iget(inode,\n\t\t\t\t\t    le32_to_cpu(here->e_value_inum),\n\t\t\t\t\t    le32_to_cpu(here->e_hash),\n\t\t\t\t\t    &old_ea_inode);\n\t\tif (ret) {\n\t\t\told_ea_inode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (i->value && in_inode) {\n\t\tWARN_ON_ONCE(!i->value_len);\n\n\t\tret = ext4_xattr_inode_alloc_quota(inode, i->value_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = ext4_xattr_inode_lookup_create(handle, inode, i->value,\n\t\t\t\t\t\t     i->value_len,\n\t\t\t\t\t\t     &new_ea_inode);\n\t\tif (ret) {\n\t\t\tnew_ea_inode = NULL;\n\t\t\text4_xattr_inode_free_quota(inode, NULL, i->value_len);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (old_ea_inode) {\n\t\t \n\t\tret = ext4_xattr_inode_dec_ref(handle, old_ea_inode);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (new_ea_inode) {\n\t\t\t\tint err;\n\n\t\t\t\terr = ext4_xattr_inode_dec_ref(handle,\n\t\t\t\t\t\t\t       new_ea_inode);\n\t\t\t\tif (err)\n\t\t\t\t\text4_warning_inode(new_ea_inode,\n\t\t\t\t\t\t  \"dec ref new_ea_inode err=%d\",\n\t\t\t\t\t\t  err);\n\t\t\t\text4_xattr_inode_free_quota(inode, new_ea_inode,\n\t\t\t\t\t\t\t    i->value_len);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\text4_xattr_inode_free_quota(inode, old_ea_inode,\n\t\t\t\t\t    le32_to_cpu(here->e_value_size));\n\t}\n\n\t \n\n\tif (!s->not_found && here->e_value_size && !here->e_value_inum) {\n\t\t \n\t\tvoid *first_val = s->base + min_offs;\n\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\tvoid *val = s->base + offs;\n\n\t\tmemmove(first_val + old_size, first_val, val - first_val);\n\t\tmemset(first_val, 0, old_size);\n\t\tmin_offs += old_size;\n\n\t\t \n\t\tlast = s->first;\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\n\t\t\tif (!last->e_value_inum &&\n\t\t\t    last->e_value_size && o < offs)\n\t\t\t\tlast->e_value_offs = cpu_to_le16(o + old_size);\n\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t}\n\t}\n\n\tif (!i->value) {\n\t\t \n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\n\t\tlast = ENTRY((void *)last - size);\n\t\tmemmove(here, (void *)here + size,\n\t\t\t(void *)last - (void *)here + sizeof(__u32));\n\t\tmemset(last, 0, size);\n\n\t\t \n\t\tif (!is_block && ext4_has_inline_data(inode)) {\n\t\t\tret = ext4_find_inline_data_nolock(inode);\n\t\t\tif (ret) {\n\t\t\t\text4_warning_inode(inode,\n\t\t\t\t\t\"unable to update i_inline_off\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else if (s->not_found) {\n\t\t \n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)here + sizeof(__u32);\n\n\t\tmemmove((void *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = i->name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, i->name, name_len);\n\t} else {\n\t\t \n\t\there->e_value_inum = 0;\n\t\there->e_value_offs = 0;\n\t\there->e_value_size = 0;\n\t}\n\n\tif (i->value) {\n\t\t \n\t\tif (in_inode) {\n\t\t\there->e_value_inum = cpu_to_le32(new_ea_inode->i_ino);\n\t\t} else if (i->value_len) {\n\t\t\tvoid *val = s->base + min_offs - new_size;\n\n\t\t\there->e_value_offs = cpu_to_le16(min_offs - new_size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, new_size);\n\t\t\t} else {\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t \n\t\t\t\tmemset(val + i->value_len, 0,\n\t\t\t\t       new_size - i->value_len);\n\t\t\t}\n\t\t}\n\t\there->e_value_size = cpu_to_le32(i->value_len);\n\t}\n\nupdate_hash:\n\tif (i->value) {\n\t\t__le32 hash = 0;\n\n\t\t \n\t\tif (in_inode) {\n\t\t\t__le32 crc32c_hash;\n\n\t\t\t \n\t\t\tcrc32c_hash = cpu_to_le32(\n\t\t\t\t       ext4_xattr_inode_get_hash(new_ea_inode));\n\t\t\thash = ext4_xattr_hash_entry(here->e_name,\n\t\t\t\t\t\t     here->e_name_len,\n\t\t\t\t\t\t     &crc32c_hash, 1);\n\t\t} else if (is_block) {\n\t\t\t__le32 *value = s->base + le16_to_cpu(\n\t\t\t\t\t\t\there->e_value_offs);\n\n\t\t\thash = ext4_xattr_hash_entry(here->e_name,\n\t\t\t\t\t\t     here->e_name_len, value,\n\t\t\t\t\t\t     new_size >> 2);\n\t\t}\n\t\there->e_hash = hash;\n\t}\n\n\tif (is_block)\n\t\text4_xattr_rehash((struct ext4_xattr_header *)s->base);\n\n\tret = 0;\nout:\n\tiput(old_ea_inode);\n\tiput(new_ea_inode);\n\treturn ret;\n}\n\nstruct ext4_xattr_block_find {\n\tstruct ext4_xattr_search s;\n\tstruct buffer_head *bh;\n};\n\nstatic int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t \n\t\tbs->bh = ext4_sb_bread(sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bs->bh)) {\n\t\t\terror = PTR_ERR(bs->bh);\n\t\t\tbs->bh = NULL;\n\t\t\treturn error;\n\t\t}\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\terror = ext4_xattr_check_block(inode, bs->bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = xattr_find_entry(inode, &bs->s.here, bs->s.end,\n\t\t\t\t\t i->name_index, i->name, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tbs->s.not_found = error;\n\t}\n\treturn 0;\n}\n\nstatic int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search s_copy = bs->s;\n\tstruct ext4_xattr_search *s = &s_copy;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\tstruct inode *ea_inode = NULL, *tmp_inode;\n\tsize_t old_ea_inode_quota = 0;\n\tunsigned int ea_ino;\n\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (s->base) {\n\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, sb, bs->bh,\n\t\t\t\t\t\t      EXT4_JTR_NONE);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(BHDR(bs->bh)->h_hash);\n\n\t\t\t \n\t\t\tif (ea_block_cache) {\n\t\t\t\tstruct mb_cache_entry *oe;\n\n\t\t\t\toe = mb_cache_entry_delete_or_get(ea_block_cache,\n\t\t\t\t\thash, bs->bh->b_blocknr);\n\t\t\t\tif (oe) {\n\t\t\t\t\t \n\t\t\t\t\tmb_cache_entry_put(ea_block_cache, oe);\n\t\t\t\t\tgoto clone_block;\n\t\t\t\t}\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s, handle, inode,\n\t\t\t\t\t\t     true  );\n\t\t\text4_xattr_block_csum_set(inode, bs->bh);\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t}\nclone_block:\n\t\tunlock_buffer(bs->bh);\n\t\tea_bdebug(bs->bh, \"cloning\");\n\t\ts->base = kmemdup(BHDR(bs->bh), bs->bh->b_size, GFP_NOFS);\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->here = ENTRY(s->base + offset);\n\t\ts->end = s->base + bs->bh->b_size;\n\n\t\t \n\t\tif (!s->not_found && s->here->e_value_inum) {\n\t\t\tea_ino = le32_to_cpu(s->here->e_value_inum);\n\t\t\terror = ext4_xattr_inode_iget(inode, ea_ino,\n\t\t\t\t      le32_to_cpu(s->here->e_hash),\n\t\t\t\t      &tmp_inode);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!ext4_test_inode_state(tmp_inode,\n\t\t\t\t\tEXT4_STATE_LUSTRE_EA_INODE)) {\n\t\t\t\t \n\t\t\t\told_ea_inode_quota = le32_to_cpu(\n\t\t\t\t\t\ts->here->e_value_size);\n\t\t\t}\n\t\t\tiput(tmp_inode);\n\n\t\t\ts->here->e_value_inum = 0;\n\t\t\ts->here->e_value_size = 0;\n\t\t}\n\t} else {\n\t\t \n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s, handle, inode, true  );\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (i->value && s->here->e_value_inum) {\n\t\t \n\t\tea_ino = le32_to_cpu(s->here->e_value_inum);\n\t\terror = ext4_xattr_inode_iget(inode, ea_ino,\n\t\t\t\t\t      le32_to_cpu(s->here->e_hash),\n\t\t\t\t\t      &ea_inode);\n\t\tif (error) {\n\t\t\tea_inode = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_block_cache_find(inode, header(s->base),\n\t\t\t\t\t\t     &ce);\n\t\tif (new_bh) {\n\t\t\t \n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\tu32 ref;\n\n#ifdef EXT4_XATTR_DEBUG\n\t\t\t\tWARN_ON_ONCE(dquot_initialize_needed(inode));\n#endif\n\t\t\t\t \n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(\n\t\t\t\t\t\thandle, sb, new_bh,\n\t\t\t\t\t\tEXT4_JTR_NONE);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\t \n\t\t\t\tref = le32_to_cpu(BHDR(new_bh)->h_refcount) + 1;\n\t\t\t\tif (ref > EXT4_XATTR_REFCOUNT_MAX) {\n\t\t\t\t\t \n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tdquot_free_block(inode,\n\t\t\t\t\t\t\t EXT4_C2B(EXT4_SB(sb),\n\t\t\t\t\t\t\t\t  1));\n\t\t\t\t\tbrelse(new_bh);\n\t\t\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\t\t\tce = NULL;\n\t\t\t\t\tnew_bh = NULL;\n\t\t\t\t\tgoto inserted;\n\t\t\t\t}\n\t\t\t\tBHDR(new_bh)->h_refcount = cpu_to_le32(ref);\n\t\t\t\tif (ref == EXT4_XATTR_REFCOUNT_MAX)\n\t\t\t\t\tclear_bit(MBE_REUSABLE_B, &ce->e_flags);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\t  ref);\n\t\t\t\text4_xattr_block_csum_set(inode, new_bh);\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_touch(ea_block_cache, ce);\n\t\t\tmb_cache_entry_put(ea_block_cache, ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t \n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\text4_xattr_block_cache_insert(ea_block_cache, bs->bh);\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t \n\t\t\text4_fsblk_t goal, block;\n\n#ifdef EXT4_XATTR_DEBUG\n\t\t\tWARN_ON_ONCE(dquot_initialize_needed(inode));\n#endif\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_inode_inc_ref_all(handle, inode,\n\t\t\t\t\t\t      ENTRY(header(s->base)+1));\n\t\t\tif (error)\n\t\t\t\tgoto getblk_failed;\n\t\t\tif (ea_inode) {\n\t\t\t\t \n\t\t\t\terror = ext4_xattr_inode_dec_ref(handle,\n\t\t\t\t\t\t\t\t ea_inode);\n\t\t\t\tif (error)\n\t\t\t\t\text4_warning_inode(ea_inode,\n\t\t\t\t\t\t\t   \"dec ref error=%d\",\n\t\t\t\t\t\t\t   error);\n\t\t\t\tiput(ea_inode);\n\t\t\t\tea_inode = NULL;\n\t\t\t}\n\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, sb,\n\t\t\t\t\t\t\tnew_bh, EXT4_JTR_NONE);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\text4_xattr_block_csum_set(inode, new_bh);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_block_cache_insert(ea_block_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_metadata(handle, inode,\n\t\t\t\t\t\t\t   new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (old_ea_inode_quota)\n\t\text4_xattr_inode_free_quota(inode, NULL, old_ea_inode_quota);\n\n\t \n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t \n\tif (bs->bh && bs->bh != new_bh) {\n\t\tstruct ext4_xattr_inode_array *ea_inode_array = NULL;\n\n\t\text4_xattr_release_block(handle, inode, bs->bh,\n\t\t\t\t\t &ea_inode_array,\n\t\t\t\t\t 0  );\n\t\text4_xattr_inode_array_free(ea_inode_array);\n\t}\n\terror = 0;\n\ncleanup:\n\tif (ea_inode) {\n\t\tint error2;\n\n\t\terror2 = ext4_xattr_inode_dec_ref(handle, ea_inode);\n\t\tif (error2)\n\t\t\text4_warning_inode(ea_inode, \"dec ref error=%d\",\n\t\t\t\t\t   error2);\n\n\t\t \n\t\tif (error)\n\t\t\text4_xattr_inode_free_quota(inode, ea_inode,\n\t\t\t\t\t\t    i_size_read(ea_inode));\n\t\tiput(ea_inode);\n\t}\n\tif (ce)\n\t\tmb_cache_entry_put(ea_block_cache, ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = xattr_check_inode(inode, header, is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\terror = xattr_find_entry(inode, &is->s.here, is->s.end,\n\t\t\t\t\t i->name_index, i->name, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}\n\nint ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n\t\treturn -ENOSPC;\n\n\terror = ext4_xattr_set_entry(i, s, handle, inode, false  );\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}\n\nstatic int ext4_xattr_value_same(struct ext4_xattr_search *s,\n\t\t\t\t struct ext4_xattr_info *i)\n{\n\tvoid *value;\n\n\t \n\tif (s->here->e_value_inum)\n\t\treturn 0;\n\tif (le32_to_cpu(s->here->e_value_size) != i->value_len)\n\t\treturn 0;\n\tvalue = ((void *)s->base) + le16_to_cpu(s->here->e_value_offs);\n\treturn !memcmp(value, i->value, i->value_len);\n}\n\nstatic struct buffer_head *ext4_xattr_get_block(struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\treturn NULL;\n\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\terror = ext4_xattr_check_block(inode, bh);\n\tif (error) {\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn bh;\n}\n\n \nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\t\t.in_inode = 0,\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\text4_write_lock_xattr(inode, &no_expand);\n\n\t \n\tif (ext4_handle_valid(handle)) {\n\t\tstruct buffer_head *bh;\n\t\tint credits;\n\n\t\tbh = ext4_xattr_get_block(inode);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tcredits = __ext4_xattr_set_credits(inode->i_sb, inode, bh,\n\t\t\t\t\t\t   value_len,\n\t\t\t\t\t\t   flags & XATTR_CREATE);\n\t\tbrelse(bh);\n\n\t\tif (jbd2_handle_buffer_credits(handle) < credits) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tWARN_ON_ONCE(!(current->flags & PF_MEMALLOC_NOFS));\n\t}\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = 0;\n\t\t \n\t\tif (!is.s.not_found && ext4_xattr_value_same(&is.s, &i))\n\t\t\tgoto cleanup;\n\t\tif (!bs.s.not_found && ext4_xattr_value_same(&bs.s, &i))\n\t\t\tgoto cleanup;\n\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t    (EXT4_XATTR_SIZE(i.value_len) >\n\t\t\tEXT4_XATTR_MIN_LARGE_EA_SIZE(inode->i_sb->s_blocksize)))\n\t\t\ti.in_inode = 1;\nretry_inode:\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\tbrelse(bs.bh);\n\t\t\t\tbs.bh = NULL;\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (!error && !is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t} else if (error == -ENOSPC) {\n\t\t\t\t \n\t\t\t\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t\t\t\t    i.value_len && !i.in_inode) {\n\t\t\t\t\ti.in_inode = 1;\n\t\t\t\t\tgoto retry_inode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode_set_ctime_current(inode);\n\t\tinode_inc_iversion(inode);\n\t\tif (!value)\n\t\t\tno_expand = 0;\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t \n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\text4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_XATTR, handle);\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\text4_write_unlock_xattr(inode, &no_expand);\n\treturn error;\n}\n\nint ext4_xattr_set_credits(struct inode *inode, size_t value_len,\n\t\t\t   bool is_create, int *credits)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\t*credits = 0;\n\n\tif (!EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\n\tbh = ext4_xattr_get_block(inode);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t} else {\n\t\t*credits = __ext4_xattr_set_credits(inode->i_sb, inode, bh,\n\t\t\t\t\t\t    value_len, is_create);\n\t\tbrelse(bh);\n\t\terr = 0;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn err;\n}\n\n \nint\next4_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tstruct super_block *sb = inode->i_sb;\n\tint error, retries = 0;\n\tint credits;\n\n\terror = dquot_initialize(inode);\n\tif (error)\n\t\treturn error;\n\nretry:\n\terror = ext4_xattr_set_credits(inode, value_len, flags & XATTR_CREATE,\n\t\t\t\t       &credits);\n\tif (error)\n\t\treturn error;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext4_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\text4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_XATTR, NULL);\n\n\treturn error;\n}\n\n \nstatic void ext4_xattr_shift_entries(struct ext4_xattr_entry *entry,\n\t\t\t\t     int value_offs_shift, void *to,\n\t\t\t\t     void *from, size_t n)\n{\n\tstruct ext4_xattr_entry *last = entry;\n\tint new_offs;\n\n\t \n\tBUG_ON(value_offs_shift > 0);\n\n\t \n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_inum && last->e_value_size) {\n\t\t\tnew_offs = le16_to_cpu(last->e_value_offs) +\n\t\t\t\t\t\t\tvalue_offs_shift;\n\t\t\tlast->e_value_offs = cpu_to_le16(new_offs);\n\t\t}\n\t}\n\t \n\tmemmove(to, from, n);\n}\n\n \nstatic int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,\n\t\t\t\t    struct ext4_inode *raw_inode,\n\t\t\t\t    struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\tstruct ext4_xattr_info i = {\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t\t.name_index = entry->e_name_index,\n\t\t.in_inode = !!entry->e_value_inum,\n\t};\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tint needs_kvfree = 0;\n\tint error;\n\n\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\tif (!is || !bs || !b_entry_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tis->s.not_found = -ENODATA;\n\tbs->s.not_found = -ENODATA;\n\tis->iloc.bh = NULL;\n\tbs->bh = NULL;\n\n\t \n\tif (entry->e_value_inum) {\n\t\tbuffer = kvmalloc(value_size, GFP_NOFS);\n\t\tif (!buffer) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tneeds_kvfree = 1;\n\t\terror = ext4_xattr_inode_get(inode, entry, buffer, value_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\tsize_t value_offs = le16_to_cpu(entry->e_value_offs);\n\t\tbuffer = (void *)IFIRST(header) + value_offs;\n\t}\n\n\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\tb_entry_name[entry->e_name_len] = '\\0';\n\ti.name = b_entry_name;\n\n\terror = ext4_get_inode_loc(inode, &is->iloc);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_find(inode, &i, is);\n\tif (error)\n\t\tgoto out;\n\n\ti.value = buffer;\n\ti.value_len = value_size;\n\terror = ext4_xattr_block_find(inode, &i, bs);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\tif (error)\n\t\tgoto out;\n\n\t \n\ti.value = NULL;\n\ti.value_len = 0;\n\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\nout:\n\tkfree(b_entry_name);\n\tif (needs_kvfree && buffer)\n\t\tkvfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tif (bs)\n\t\tbrelse(bs->bh);\n\tkfree(is);\n\tkfree(bs);\n\n\treturn error;\n}\n\nstatic int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,\n\t\t\t\t       struct ext4_inode *raw_inode,\n\t\t\t\t       int isize_diff, size_t ifree,\n\t\t\t\t       size_t bfree, int *total_ino)\n{\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tstruct ext4_xattr_entry *small_entry;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *last;\n\tunsigned int entry_size;\t \n\tunsigned int total_size;\t \n\tunsigned int min_total_size;\n\tint error;\n\n\twhile (isize_diff > ifree) {\n\t\tentry = NULL;\n\t\tsmall_entry = NULL;\n\t\tmin_total_size = ~0U;\n\t\tlast = IFIRST(header);\n\t\t \n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\t \n\t\t\tif ((last->e_name_len == 4) &&\n\t\t\t    (last->e_name_index == EXT4_XATTR_INDEX_SYSTEM) &&\n\t\t\t    !memcmp(last->e_name, \"data\", 4))\n\t\t\t\tcontinue;\n\t\t\ttotal_size = EXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (!last->e_value_inum)\n\t\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t       le32_to_cpu(last->e_value_size));\n\t\t\tif (total_size <= bfree &&\n\t\t\t    total_size < min_total_size) {\n\t\t\t\tif (total_size + ifree < isize_diff) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry == NULL)\n\t\t\t\treturn -ENOSPC;\n\t\t\tentry = small_entry;\n\t\t}\n\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ttotal_size = entry_size;\n\t\tif (!entry->e_value_inum)\n\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\terror = ext4_xattr_move_to_block(handle, inode, raw_inode,\n\t\t\t\t\t\t entry);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*total_ino -= entry_size;\n\t\tifree += total_size;\n\t\tbfree -= total_size;\n\t}\n\n\treturn 0;\n}\n\n \nint ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tsize_t min_offs;\n\tsize_t ifree, bfree;\n\tint total_ino;\n\tvoid *base, *end;\n\tint error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(sbi->s_es->s_min_extra_isize);\n\tint isize_diff;\t \n\nretry:\n\tisize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\theader = IHDR(inode, raw_inode);\n\n\t \n\n\tbase = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header) + sizeof(u32);\n\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\n\tifree = ext4_xattr_free_space(base, &min_offs, base, &total_ino);\n\tif (ifree >= isize_diff)\n\t\tgoto shift;\n\n\t \n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\t\terror = ext4_xattr_check_block(inode, bh);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tbfree = ext4_xattr_free_space(BFIRST(bh), &min_offs, base,\n\t\t\t\t\t      NULL);\n\t\tbrelse(bh);\n\t\tif (bfree + ifree < isize_diff) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tbfree = inode->i_sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_make_inode_space(handle, inode, raw_inode,\n\t\t\t\t\t    isize_diff, ifree, bfree,\n\t\t\t\t\t    &total_ino);\n\tif (error) {\n\t\tif (error == -ENOSPC && !tried_min_extra_isize &&\n\t\t    s_min_extra_isize) {\n\t\t\ttried_min_extra_isize++;\n\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\tgoto retry;\n\t\t}\n\t\tgoto cleanup;\n\t}\nshift:\n\t \n\text4_xattr_shift_entries(IFIRST(header), EXT4_I(inode)->i_extra_isize\n\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t(void *)header, total_ino);\n\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\n\tif (ext4_has_inline_data(inode))\n\t\terror = ext4_find_inline_data_nolock(inode);\n\ncleanup:\n\tif (error && (mnt_count != le16_to_cpu(sbi->s_es->s_mnt_count))) {\n\t\text4_warning(inode->i_sb, \"Unable to expand inode %lu. Delete some EAs or run e2fsck.\",\n\t\t\t     inode->i_ino);\n\t\tmnt_count = le16_to_cpu(sbi->s_es->s_mnt_count);\n\t}\n\treturn error;\n}\n\n#define EIA_INCR 16  \n#define EIA_MASK (EIA_INCR - 1)\n\n \nstatic int\next4_expand_inode_array(struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\tstruct inode *inode)\n{\n\tif (*ea_inode_array == NULL) {\n\t\t \n\t\t(*ea_inode_array) =\n\t\t\tkmalloc(offsetof(struct ext4_xattr_inode_array,\n\t\t\t\t\t inodes[EIA_MASK]),\n\t\t\t\tGFP_NOFS);\n\t\tif (*ea_inode_array == NULL)\n\t\t\treturn -ENOMEM;\n\t\t(*ea_inode_array)->count = 0;\n\t} else if (((*ea_inode_array)->count & EIA_MASK) == EIA_MASK) {\n\t\t \n\t\tstruct ext4_xattr_inode_array *new_array = NULL;\n\t\tint count = (*ea_inode_array)->count;\n\n\t\t \n\t\tnew_array = kmalloc(\n\t\t\t\toffsetof(struct ext4_xattr_inode_array,\n\t\t\t\t\t inodes[count + EIA_INCR]),\n\t\t\t\tGFP_NOFS);\n\t\tif (new_array == NULL)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(new_array, *ea_inode_array,\n\t\t       offsetof(struct ext4_xattr_inode_array, inodes[count]));\n\t\tkfree(*ea_inode_array);\n\t\t*ea_inode_array = new_array;\n\t}\n\t(*ea_inode_array)->inodes[(*ea_inode_array)->count++] = inode;\n\treturn 0;\n}\n\n \nint ext4_xattr_delete_inode(handle_t *handle, struct inode *inode,\n\t\t\t    struct ext4_xattr_inode_array **ea_inode_array,\n\t\t\t    int extra_credits)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_iloc iloc = { .bh = NULL };\n\tstruct ext4_xattr_entry *entry;\n\tstruct inode *ea_inode;\n\tint error;\n\n\terror = ext4_journal_ensure_credits(handle, extra_credits,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1));\n\tif (error < 0) {\n\t\tEXT4_ERROR_INODE(inode, \"ensure credits (error %d)\", error);\n\t\tgoto cleanup;\n\t}\n\n\tif (ext4_has_feature_ea_inode(inode->i_sb) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\n\t\terror = ext4_get_inode_loc(inode, &iloc);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"inode loc (error %d)\", error);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\terror = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\t\t\tiloc.bh, EXT4_JTR_NONE);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"write access (error %d)\",\n\t\t\t\t\t error);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\theader = IHDR(inode, ext4_raw_inode(&iloc));\n\t\tif (header->h_magic == cpu_to_le32(EXT4_XATTR_MAGIC))\n\t\t\text4_xattr_inode_dec_ref_all(handle, inode, iloc.bh,\n\t\t\t\t\t\t     IFIRST(header),\n\t\t\t\t\t\t     false  ,\n\t\t\t\t\t\t     ea_inode_array,\n\t\t\t\t\t\t     extra_credits,\n\t\t\t\t\t\t     false  );\n\t}\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = ext4_sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\terror = PTR_ERR(bh);\n\t\t\tif (error == -EIO) {\n\t\t\t\tEXT4_ERROR_INODE_ERR(inode, EIO,\n\t\t\t\t\t\t     \"block %llu read error\",\n\t\t\t\t\t\t     EXT4_I(inode)->i_file_acl);\n\t\t\t}\n\t\t\tbh = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\terror = ext4_xattr_check_block(inode, bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\tif (ext4_has_feature_ea_inode(inode->i_sb)) {\n\t\t\tfor (entry = BFIRST(bh); !IS_LAST_ENTRY(entry);\n\t\t\t     entry = EXT4_XATTR_NEXT(entry)) {\n\t\t\t\tif (!entry->e_value_inum)\n\t\t\t\t\tcontinue;\n\t\t\t\terror = ext4_xattr_inode_iget(inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_inum),\n\t\t\t\t\t      le32_to_cpu(entry->e_hash),\n\t\t\t\t\t      &ea_inode);\n\t\t\t\tif (error)\n\t\t\t\t\tcontinue;\n\t\t\t\text4_xattr_inode_free_quota(inode, ea_inode,\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\t\t\tiput(ea_inode);\n\t\t\t}\n\n\t\t}\n\n\t\text4_xattr_release_block(handle, inode, bh, ea_inode_array,\n\t\t\t\t\t extra_credits);\n\t\t \n\t\tEXT4_I(inode)->i_file_acl = 0;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\tif (error) {\n\t\t\tEXT4_ERROR_INODE(inode, \"mark inode dirty (error %d)\",\n\t\t\t\t\t error);\n\t\t\tgoto cleanup;\n\t\t}\n\t\text4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_XATTR, handle);\n\t}\n\terror = 0;\ncleanup:\n\tbrelse(iloc.bh);\n\tbrelse(bh);\n\treturn error;\n}\n\nvoid ext4_xattr_inode_array_free(struct ext4_xattr_inode_array *ea_inode_array)\n{\n\tint idx;\n\n\tif (ea_inode_array == NULL)\n\t\treturn;\n\n\tfor (idx = 0; idx < ea_inode_array->count; ++idx)\n\t\tiput(ea_inode_array->inodes[idx]);\n\tkfree(ea_inode_array);\n}\n\n \nstatic void\next4_xattr_block_cache_insert(struct mb_cache *ea_block_cache,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct ext4_xattr_header *header = BHDR(bh);\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tint reusable = le32_to_cpu(header->h_refcount) <\n\t\t       EXT4_XATTR_REFCOUNT_MAX;\n\tint error;\n\n\tif (!ea_block_cache)\n\t\treturn;\n\terror = mb_cache_entry_create(ea_block_cache, GFP_NOFS, hash,\n\t\t\t\t      bh->b_blocknr, reusable);\n\tif (error) {\n\t\tif (error == -EBUSY)\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n}\n\n \nstatic int\next4_xattr_cmp(struct ext4_xattr_header *header1,\n\t       struct ext4_xattr_header *header2)\n{\n\tstruct ext4_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    entry1->e_value_inum != entry2->e_value_inum ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (!entry1->e_value_inum &&\n\t\t    memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT4_XATTR_NEXT(entry1);\n\t\tentry2 = EXT4_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct buffer_head *\next4_xattr_block_cache_find(struct inode *inode,\n\t\t\t    struct ext4_xattr_header *header,\n\t\t\t    struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ea_block_cache = EA_BLOCK_CACHE(inode);\n\n\tif (!ea_block_cache)\n\t\treturn NULL;\n\tif (!header->h_hash)\n\t\treturn NULL;   \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\n\tce = mb_cache_entry_find_first(ea_block_cache, hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = ext4_sb_bread(inode->i_sb, ce->e_value, REQ_PRIO);\n\t\tif (IS_ERR(bh)) {\n\t\t\tif (PTR_ERR(bh) == -ENOMEM)\n\t\t\t\treturn NULL;\n\t\t\tbh = NULL;\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long)ce->e_value);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ea_block_cache, ce);\n\t}\n\treturn NULL;\n}\n\n#define NAME_HASH_SHIFT 5\n#define VALUE_HASH_SHIFT 16\n\n \nstatic __le32 ext4_xattr_hash_entry(char *name, size_t name_len, __le32 *value,\n\t\t\t\t    size_t value_count)\n{\n\t__u32 hash = 0;\n\n\twhile (name_len--) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       (unsigned char)*name++;\n\t}\n\twhile (value_count--) {\n\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(*value++);\n\t}\n\treturn cpu_to_le32(hash);\n}\n\n \nstatic __le32 ext4_xattr_hash_entry_signed(char *name, size_t name_len, __le32 *value, size_t value_count)\n{\n\t__u32 hash = 0;\n\n\twhile (name_len--) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       (signed char)*name++;\n\t}\n\twhile (value_count--) {\n\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(*value++);\n\t}\n\treturn cpu_to_le32(hash);\n}\n\n#undef NAME_HASH_SHIFT\n#undef VALUE_HASH_SHIFT\n\n#define BLOCK_HASH_SHIFT 16\n\n \nstatic void ext4_xattr_rehash(struct ext4_xattr_header *header)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t \n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}\n\n#undef BLOCK_HASH_SHIFT\n\n#define\tHASH_BUCKET_BITS\t10\n\nstruct mb_cache *\next4_xattr_create_cache(void)\n{\n\treturn mb_cache_create(HASH_BUCKET_BITS);\n}\n\nvoid ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}