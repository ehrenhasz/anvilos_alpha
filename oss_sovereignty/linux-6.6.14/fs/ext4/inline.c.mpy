{
  "module_name": "inline.c",
  "hash_id": "dcf67762bcd9e837bb4eee017b67bcbc96462b1df25d55d5d7fefb3ee36b9e96",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/inline.c",
  "human_readable_source": "\n \n\n#include <linux/iomap.h>\n#include <linux/fiemap.h>\n#include <linux/namei.h>\n#include <linux/iversion.h>\n#include <linux/sched/mm.h>\n\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include \"xattr.h\"\n#include \"truncate.h\"\n\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_INLINE_DOTDOT_OFFSET\t2\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nstatic int ext4_get_inline_size(struct inode *inode)\n{\n\tif (EXT4_I(inode)->i_inline_off)\n\t\treturn EXT4_I(inode)->i_inline_size;\n\n\treturn 0;\n}\n\nstatic int get_max_inline_xattr_value_size(struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tvoid *end;\n\tint free, min_offs;\n\n\tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n\t\treturn 0;\n\n\tmin_offs = EXT4_SB(inode->i_sb)->s_inode_size -\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE -\n\t\t\tEXT4_I(inode)->i_extra_isize -\n\t\t\tsizeof(struct ext4_xattr_ibody_header);\n\n\t \n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn EXT4_XATTR_SIZE(min_offs -\n\t\t\tEXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) -\n\t\t\tEXT4_XATTR_ROUND - sizeof(__u32));\n\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\n\t \n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tvoid *next = EXT4_XATTR_NEXT(entry);\n\n\t\tif (next >= end) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"corrupt xattr in inline inode\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (!entry->e_value_inum && entry->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t\tentry = next;\n\t}\n\tfree = min_offs -\n\t\t((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);\n\n\tif (EXT4_I(inode)->i_inline_off) {\n\t\tentry = (struct ext4_xattr_entry *)\n\t\t\t((void *)raw_inode + EXT4_I(inode)->i_inline_off);\n\n\t\tfree += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t\tgoto out;\n\t}\n\n\tfree -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA));\n\n\tif (free > EXT4_XATTR_ROUND)\n\t\tfree = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND);\n\telse\n\t\tfree = 0;\n\nout:\n\treturn free;\n}\n\n \nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode_err(inode, __func__, __LINE__, 0, -error,\n\t\t\t\t     \"can't get inode location %lu\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}\n\n \nint ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tif (!is.s.not_found) {\n\t\tif (is.s.here->e_value_inum) {\n\t\t\tEXT4_ERROR_INODE(inode, \"inline data xattr refers \"\n\t\t\t\t\t \"to an external xattr inode\");\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}\n\nstatic int ext4_read_inline_data(struct inode *inode, void *buffer,\n\t\t\t\t unsigned int len,\n\t\t\t\t struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tint cp_len = 0;\n\tstruct ext4_inode *raw_inode;\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(len > EXT4_I(inode)->i_inline_size);\n\n\tcp_len = min_t(unsigned int, len, EXT4_MIN_INLINE_DATA_SIZE);\n\n\traw_inode = ext4_raw_inode(iloc);\n\tmemcpy(buffer, (void *)(raw_inode->i_block), cp_len);\n\n\tlen -= cp_len;\n\tbuffer += cp_len;\n\n\tif (!len)\n\t\tgoto out;\n\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tlen = min_t(unsigned int, len,\n\t\t    (unsigned int)le32_to_cpu(entry->e_value_size));\n\n\tmemcpy(buffer,\n\t       (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs), len);\n\tcp_len += len;\n\nout:\n\treturn cp_len;\n}\n\n \nstatic void ext4_write_inline_data(struct inode *inode, struct ext4_iloc *iloc,\n\t\t\t\t   void *buffer, loff_t pos, unsigned int len)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint cp_len = 0;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\tBUG_ON(pos + len > EXT4_I(inode)->i_inline_size);\n\n\traw_inode = ext4_raw_inode(iloc);\n\tbuffer += pos;\n\n\tif (pos < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tcp_len = pos + len > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t EXT4_MIN_INLINE_DATA_SIZE - pos : len;\n\t\tmemcpy((void *)raw_inode->i_block + pos, buffer, cp_len);\n\n\t\tlen -= cp_len;\n\t\tbuffer += cp_len;\n\t\tpos += cp_len;\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tpos -= EXT4_MIN_INLINE_DATA_SIZE;\n\theader = IHDR(inode, raw_inode);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\tmemcpy((void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs) + pos,\n\t       buffer, len);\n}\n\nstatic int ext4_create_inline_data(handle_t *handle,\n\t\t\t\t   struct inode *inode, unsigned len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, inode->i_sb, is.iloc.bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (error)\n\t\tgoto out;\n\n\tif (len > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tvalue = EXT4_ZERO_XATTR_VALUE;\n\t\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tvalue = \"\";\n\t\tlen = 0;\n\t}\n\n\t \n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(!is.s.not_found);\n\n\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\text4_clear_inode_state(inode,\n\t\t\t\t\t       EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = len + EXT4_MIN_INLINE_DATA_SIZE;\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\text4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}\n\nstatic int ext4_update_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t   unsigned int len)\n{\n\tint error;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\t \n\tif (len <= EXT4_I(inode)->i_inline_size)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUG_ON(is.s.not_found);\n\n\tlen -= EXT4_MIN_INLINE_DATA_SIZE;\n\tvalue = kzalloc(len, GFP_NOFS);\n\tif (!value) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t     value, len);\n\tif (error < 0)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, inode->i_sb, is.iloc.bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (error)\n\t\tgoto out;\n\n\t \n\ti.value = value;\n\ti.value_len = len;\n\n\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t      (void *)ext4_raw_inode(&is.iloc));\n\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\nout:\n\tkfree(value);\n\tbrelse(is.iloc.bh);\n\treturn error;\n}\n\nstatic int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int len)\n{\n\tint ret, size, no_expand;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\treturn -ENOSPC;\n\n\tsize = ext4_get_max_inline_size(inode);\n\tif (size < len)\n\t\treturn -ENOSPC;\n\n\text4_write_lock_xattr(inode, &no_expand);\n\n\tif (ei->i_inline_off)\n\t\tret = ext4_update_inline_data(handle, inode, len);\n\telse\n\t\tret = ext4_create_inline_data(handle, inode, len);\n\n\text4_write_unlock_xattr(inode, &no_expand);\n\treturn ret;\n}\n\nstatic int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, inode->i_sb, is.iloc.bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (error)\n\t\tgoto out;\n\n\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\tmemset(ei->i_data, 0, EXT4_MIN_INLINE_DATA_SIZE);\n\n\tif (ext4_has_feature_extents(inode->i_sb)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}\n\nstatic int ext4_read_inline_folio(struct inode *inode, struct folio *folio)\n{\n\tvoid *kaddr;\n\tint ret = 0;\n\tsize_t len;\n\tstruct ext4_iloc iloc;\n\n\tBUG_ON(!folio_test_locked(folio));\n\tBUG_ON(!ext4_has_inline_data(inode));\n\tBUG_ON(folio->index);\n\n\tif (!EXT4_I(inode)->i_inline_off) {\n\t\text4_warning(inode->i_sb, \"inode %lu doesn't have inline data.\",\n\t\t\t     inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tlen = min_t(size_t, ext4_get_inline_size(inode), i_size_read(inode));\n\tBUG_ON(len > PAGE_SIZE);\n\tkaddr = kmap_local_folio(folio, 0);\n\tret = ext4_read_inline_data(inode, kaddr, len, &iloc);\n\tflush_dcache_folio(folio);\n\tkunmap_local(kaddr);\n\tfolio_zero_segment(folio, len, folio_size(folio));\n\tfolio_mark_uptodate(folio);\n\tbrelse(iloc.bh);\n\nout:\n\treturn ret;\n}\n\nint ext4_readpage_inline(struct inode *inode, struct folio *folio)\n{\n\tint ret = 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (!folio->index)\n\t\tret = ext4_read_inline_folio(inode, folio);\n\telse if (!folio_test_uptodate(folio)) {\n\t\tfolio_zero_segment(folio, 0, folio_size(folio));\n\t\tfolio_mark_uptodate(folio);\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tfolio_unlock(folio);\n\treturn ret >= 0 ? 0 : ret;\n}\n\nstatic int ext4_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t      struct inode *inode)\n{\n\tint ret, needed_blocks, no_expand;\n\thandle_t *handle = NULL;\n\tint retries = 0, sem_held = 0;\n\tstruct folio *folio = NULL;\n\tunsigned from, to;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\t \n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tfolio = __filemap_get_folio(mapping, 0, FGP_WRITEBEGIN | FGP_NOFS,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio)) {\n\t\tret = PTR_ERR(folio);\n\t\tgoto out_nofolio;\n\t}\n\n\text4_write_lock_xattr(inode, &no_expand);\n\tsem_held = 1;\n\t \n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfrom = 0;\n\tto = ext4_get_inline_size(inode);\n\tif (!folio_test_uptodate(folio)) {\n\t\tret = ext4_read_inline_folio(inode, folio);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\tret = __block_write_begin(&folio->page, from, to,\n\t\t\t\t\t  ext4_get_block_unwritten);\n\t} else\n\t\tret = __block_write_begin(&folio->page, from, to, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, inode,\n\t\t\t\t\t     folio_buffers(folio), from, to,\n\t\t\t\t\t     NULL, do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\tfolio = NULL;\n\t\text4_orphan_add(handle, inode);\n\t\text4_write_unlock_xattr(inode, &no_expand);\n\t\tsem_held = 0;\n\t\text4_journal_stop(handle);\n\t\thandle = NULL;\n\t\text4_truncate_failed_write(inode);\n\t\t \n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (folio)\n\t\tblock_commit_write(&folio->page, from, to);\nout:\n\tif (folio) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\nout_nofolio:\n\tif (sem_held)\n\t\text4_write_unlock_xattr(inode, &no_expand);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\n \nint ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  loff_t pos, unsigned len,\n\t\t\t\t  struct page **pagep)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct folio *folio;\n\tstruct ext4_iloc iloc;\n\n\tif (pos + len > ext4_get_max_inline_size(inode))\n\t\tgoto convert;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out;\n\n\t \n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tbrelse(iloc.bh);\n\t\tgoto convert;\n\t}\n\n\tret = ext4_journal_get_write_access(handle, inode->i_sb, iloc.bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (ret)\n\t\tgoto out;\n\n\tfolio = __filemap_get_folio(mapping, 0, FGP_WRITEBEGIN | FGP_NOFS,\n\t\t\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio)) {\n\t\tret = PTR_ERR(folio);\n\t\tgoto out;\n\t}\n\n\t*pagep = &folio->page;\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\tgoto out_up_read;\n\t}\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tret = ext4_read_inline_folio(inode, folio);\n\t\tif (ret < 0) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\tgoto out_up_read;\n\t\t}\n\t}\n\n\tret = 1;\n\thandle = NULL;\nout_up_read:\n\tup_read(&EXT4_I(inode)->xattr_sem);\nout:\n\tif (handle && (ret != 1))\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\nconvert:\n\treturn ext4_convert_inline_data_to_extent(mapping, inode);\n}\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct folio *folio)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tint no_expand;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\tint ret = 0, ret2;\n\n\tif (unlikely(copied < len) && !folio_test_uptodate(folio))\n\t\tcopied = 0;\n\n\tif (likely(copied)) {\n\t\tret = ext4_get_inode_loc(inode, &iloc);\n\t\tif (ret) {\n\t\t\tfolio_unlock(folio);\n\t\t\tfolio_put(folio);\n\t\t\text4_std_error(inode->i_sb, ret);\n\t\t\tgoto out;\n\t\t}\n\t\text4_write_lock_xattr(inode, &no_expand);\n\t\tBUG_ON(!ext4_has_inline_data(inode));\n\n\t\t \n\t\t(void) ext4_find_inline_data_nolock(inode);\n\n\t\tkaddr = kmap_local_folio(folio, 0);\n\t\text4_write_inline_data(inode, &iloc, kaddr, pos, copied);\n\t\tkunmap_local(kaddr);\n\t\tfolio_mark_uptodate(folio);\n\t\t \n\t\tfolio_clear_dirty(folio);\n\n\t\text4_write_unlock_xattr(inode, &no_expand);\n\t\tbrelse(iloc.bh);\n\n\t\t \n\t\text4_update_inode_size(inode, pos + copied);\n\t}\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\t \n\tif (likely(copied))\n\t\tmark_inode_dirty(inode);\nout:\n\t \n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\text4_orphan_add(handle, inode);\n\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t \n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret ? ret : copied;\n}\n\n \nstatic int ext4_da_convert_inline_data_to_extent(struct address_space *mapping,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t void **fsdata)\n{\n\tint ret = 0, inline_size;\n\tstruct folio *folio;\n\n\tfolio = __filemap_get_folio(mapping, 0, FGP_WRITEBEGIN,\n\t\t\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio))\n\t\treturn PTR_ERR(folio);\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tret = ext4_read_inline_folio(inode, folio);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __block_write_begin(&folio->page, 0, inline_size,\n\t\t\t\t  ext4_da_get_block_prep);\n\tif (ret) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\text4_truncate_failed_write(inode);\n\t\treturn ret;\n\t}\n\n\tfolio_mark_dirty(folio);\n\tfolio_mark_uptodate(folio);\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t*fsdata = (void *)CONVERT_INLINE_DATA;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (folio) {\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t}\n\treturn ret;\n}\n\n \nint ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct folio *folio;\n\tstruct ext4_iloc iloc;\n\tint retries = 0;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out_journal;\n\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    fsdata);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\t \n\tfolio = __filemap_get_folio(mapping, 0, FGP_WRITEBEGIN | FGP_NOFS,\n\t\t\t\t\tmapping_gfp_mask(mapping));\n\tif (IS_ERR(folio)) {\n\t\tret = PTR_ERR(folio);\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!folio_test_uptodate(folio)) {\n\t\tret = ext4_read_inline_folio(inode, folio);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\tret = ext4_journal_get_write_access(handle, inode->i_sb, iloc.bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (ret)\n\t\tgoto out_release_page;\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = &folio->page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tfolio_unlock(folio);\n\tfolio_put(folio);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\n#ifdef INLINE_DIR_DEBUG\nvoid ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,\n\t\t\t  void *inline_start, int inline_size)\n{\n\tint offset;\n\tunsigned short de_len;\n\tstruct ext4_dir_entry_2 *de = inline_start;\n\tvoid *dlimit = inline_start + inline_size;\n\n\ttrace_printk(\"inode %lu\\n\", dir->i_ino);\n\toffset = 0;\n\twhile ((void *)de < dlimit) {\n\t\tde_len = ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\ttrace_printk(\"de: off %u rlen %u name %.*s nlen %u ino %u\\n\",\n\t\t\t     offset, de_len, de->name_len, de->name,\n\t\t\t     de->name_len, le32_to_cpu(de->inode));\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t inline_start, inline_size, offset))\n\t\t\tBUG();\n\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n}\n#else\n#define ext4_show_inline_dir(dir, bh, inline_start, inline_size)\n#endif\n\n \nstatic int ext4_add_dirent_to_inline(handle_t *handle,\n\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t     struct inode *dir,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *inline_start, int inline_size)\n{\n\tint\t\terr;\n\tstruct ext4_dir_entry_2 *de;\n\n\terr = ext4_find_dest_de(dir, inode, iloc->bh, inline_start,\n\t\t\t\tinline_size, fname, &de);\n\tif (err)\n\t\treturn err;\n\n\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, iloc->bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\treturn err;\n\text4_insert_dentry(dir, inode, de, inline_size, fname);\n\n\text4_show_inline_dir(dir, iloc->bh, inline_start, inline_size);\n\n\t \n\tdir->i_mtime = inode_set_ctime_current(dir);\n\text4_update_dx_flag(dir);\n\tinode_inc_iversion(dir);\n\treturn 1;\n}\n\nstatic void *ext4_get_inline_xattr_pos(struct inode *inode,\n\t\t\t\t       struct ext4_iloc *iloc)\n{\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tBUG_ON(!EXT4_I(inode)->i_inline_off);\n\n\theader = IHDR(inode, ext4_raw_inode(iloc));\n\tentry = (struct ext4_xattr_entry *)((void *)ext4_raw_inode(iloc) +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\n\treturn (void *)IFIRST(header) + le16_to_cpu(entry->e_value_offs);\n}\n\n \nstatic void ext4_update_final_de(void *de_buf, int old_size, int new_size)\n{\n\tstruct ext4_dir_entry_2 *de, *prev_de;\n\tvoid *limit;\n\tint de_len;\n\n\tde = de_buf;\n\tif (old_size) {\n\t\tlimit = de_buf + old_size;\n\t\tdo {\n\t\t\tprev_de = de;\n\t\t\tde_len = ext4_rec_len_from_disk(de->rec_len, old_size);\n\t\t\tde_buf += de_len;\n\t\t\tde = de_buf;\n\t\t} while (de_buf < limit);\n\n\t\tprev_de->rec_len = ext4_rec_len_to_disk(de_len + new_size -\n\t\t\t\t\t\t\told_size, new_size);\n\t} else {\n\t\t \n\t\tde->inode = 0;\n\t\tde->rec_len = ext4_rec_len_to_disk(new_size, new_size);\n\t}\n}\n\nstatic int ext4_update_inline_dir(handle_t *handle, struct inode *dir,\n\t\t\t\t  struct ext4_iloc *iloc)\n{\n\tint ret;\n\tint old_size = EXT4_I(dir)->i_inline_size - EXT4_MIN_INLINE_DATA_SIZE;\n\tint new_size = get_max_inline_xattr_value_size(dir, iloc);\n\n\tif (new_size - old_size <= ext4_dir_rec_len(1, NULL))\n\t\treturn -ENOSPC;\n\n\tret = ext4_update_inline_data(handle, dir,\n\t\t\t\t      new_size + EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\text4_update_final_de(ext4_get_inline_xattr_pos(dir, iloc), old_size,\n\t\t\t     EXT4_I(dir)->i_inline_size -\n\t\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE);\n\tdir->i_size = EXT4_I(dir)->i_disksize = EXT4_I(dir)->i_inline_size;\n\treturn 0;\n}\n\nstatic void ext4_restore_inline_data(handle_t *handle, struct inode *inode,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     void *buf, int inline_size)\n{\n\tint ret;\n\n\tret = ext4_create_inline_data(handle, inode, inline_size);\n\tif (ret) {\n\t\text4_msg(inode->i_sb, KERN_EMERG,\n\t\t\t\"error restoring inline_data for inode -- potential data loss! (inode %lu, error %d)\",\n\t\t\tinode->i_ino, ret);\n\t\treturn;\n\t}\n\text4_write_inline_data(inode, iloc, buf, 0, inline_size);\n\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n}\n\nstatic int ext4_finish_convert_inline_dir(handle_t *handle,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  struct buffer_head *dir_block,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  int inline_size)\n{\n\tint err, csum_size = 0, header_size = 0;\n\tstruct ext4_dir_entry_2 *de;\n\tvoid *target = dir_block->b_data;\n\n\t \n\tde = target;\n\tde = ext4_init_dot_dotdot(inode, de,\n\t\tinode->i_sb->s_blocksize, csum_size,\n\t\tle32_to_cpu(((struct ext4_dir_entry_2 *)buf)->inode), 1);\n\theader_size = (void *)de - target;\n\n\tmemcpy((void *)de, buf + EXT4_INLINE_DOTDOT_SIZE,\n\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tinode->i_size = inode->i_sb->s_blocksize;\n\ti_size_write(inode, inode->i_sb->s_blocksize);\n\tEXT4_I(inode)->i_disksize = inode->i_sb->s_blocksize;\n\text4_update_final_de(dir_block->b_data,\n\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE + header_size,\n\t\t\tinode->i_sb->s_blocksize - csum_size);\n\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(dir_block,\n\t\t\t\t\t    inode->i_sb->s_blocksize);\n\tset_buffer_uptodate(dir_block);\n\tunlock_buffer(dir_block);\n\terr = ext4_handle_dirty_dirblock(handle, inode, dir_block);\n\tif (err)\n\t\treturn err;\n\tset_buffer_verified(dir_block);\n\treturn ext4_mark_inode_dirty(handle, inode);\n}\n\nstatic int ext4_convert_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_iloc *iloc)\n{\n\tint error;\n\tvoid *buf = NULL;\n\tstruct buffer_head *data_bh = NULL;\n\tstruct ext4_map_blocks map;\n\tint inline_size;\n\n\tinline_size = ext4_get_inline_size(inode);\n\tbuf = kmalloc(inline_size, GFP_NOFS);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = ext4_read_inline_data(inode, buf, inline_size, iloc);\n\tif (error < 0)\n\t\tgoto out;\n\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = ext4_check_all_de(inode, iloc->bh,\n\t\t\t\t\tbuf + EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = ext4_destroy_inline_data_nolock(handle, inode);\n\tif (error)\n\t\tgoto out;\n\n\tmap.m_lblk = 0;\n\tmap.m_len = 1;\n\tmap.m_flags = 0;\n\terror = ext4_map_blocks(handle, inode, &map, EXT4_GET_BLOCKS_CREATE);\n\tif (error < 0)\n\t\tgoto out_restore;\n\tif (!(map.m_flags & EXT4_MAP_MAPPED)) {\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\n\tdata_bh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (!data_bh) {\n\t\terror = -ENOMEM;\n\t\tgoto out_restore;\n\t}\n\n\tlock_buffer(data_bh);\n\terror = ext4_journal_get_create_access(handle, inode->i_sb, data_bh,\n\t\t\t\t\t       EXT4_JTR_NONE);\n\tif (error) {\n\t\tunlock_buffer(data_bh);\n\t\terror = -EIO;\n\t\tgoto out_restore;\n\t}\n\tmemset(data_bh->b_data, 0, inode->i_sb->s_blocksize);\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tmemcpy(data_bh->b_data, buf, inline_size);\n\t\tset_buffer_uptodate(data_bh);\n\t\tunlock_buffer(data_bh);\n\t\terror = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t   inode, data_bh);\n\t} else {\n\t\terror = ext4_finish_convert_inline_dir(handle, inode, data_bh,\n\t\t\t\t\t\t       buf, inline_size);\n\t}\n\nout_restore:\n\tif (error)\n\t\text4_restore_inline_data(handle, inode, iloc, buf, inline_size);\n\nout:\n\tbrelse(data_bh);\n\tkfree(buf);\n\treturn error;\n}\n\n \nint ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,\n\t\t\t      struct inode *dir, struct inode *inode)\n{\n\tint ret, ret2, inline_size, no_expand;\n\tvoid *inline_start;\n\tstruct ext4_iloc iloc;\n\n\tret = ext4_get_inode_loc(dir, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\text4_write_lock_xattr(dir, &no_expand);\n\tif (!ext4_has_inline_data(dir))\n\t\tgoto out;\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\t EXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\n\tret = ext4_add_dirent_to_inline(handle, fname, dir, inode, &iloc,\n\t\t\t\t\tinline_start, inline_size);\n\tif (ret != -ENOSPC)\n\t\tgoto out;\n\n\t \n\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\tif (!inline_size) {\n\t\t \n\t\tret = ext4_update_inline_dir(handle, dir, &iloc);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tinline_size = EXT4_I(dir)->i_inline_size -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_size) {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\n\t\tret = ext4_add_dirent_to_inline(handle, fname, dir,\n\t\t\t\t\t\tinode, &iloc, inline_start,\n\t\t\t\t\t\tinline_size);\n\n\t\tif (ret != -ENOSPC)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = ext4_convert_inline_data_nolock(handle, dir, &iloc);\n\nout:\n\text4_write_unlock_xattr(dir, &no_expand);\n\tret2 = ext4_mark_inode_dirty(handle, dir);\n\tif (unlikely(ret2 && !ret))\n\t\tret = ret2;\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\n \nint ext4_inlinedir_to_tree(struct file *dir_file,\n\t\t\t   struct inode *dir, ext4_lblk_t block,\n\t\t\t   struct dx_hash_info *hinfo,\n\t\t\t   __u32 start_hash, __u32 start_minor_hash,\n\t\t\t   int *has_inline_data)\n{\n\tint err = 0, count = 0;\n\tunsigned int parent_ino;\n\tint pos;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct inode *inode = file_inode(dir_file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tstruct ext4_dir_entry_2 fake;\n\tstruct fscrypt_str tmp_str;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpos = 0;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\twhile (pos < inline_size) {\n\t\t \n\t\tif (pos == 0) {\n\t\t\tfake.inode = cpu_to_le32(inode->i_ino);\n\t\t\tfake.name_len = 1;\n\t\t\tstrcpy(fake.name, \".\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t  ext4_dir_rec_len(fake.name_len, NULL),\n\t\t\t\t\t  inline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_OFFSET;\n\t\t} else if (pos == EXT4_INLINE_DOTDOT_OFFSET) {\n\t\t\tfake.inode = cpu_to_le32(parent_ino);\n\t\t\tfake.name_len = 2;\n\t\t\tstrcpy(fake.name, \"..\");\n\t\t\tfake.rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\t  ext4_dir_rec_len(fake.name_len, NULL),\n\t\t\t\t\t  inline_size);\n\t\t\text4_set_de_type(inode->i_sb, &fake, S_IFDIR);\n\t\t\tde = &fake;\n\t\t\tpos = EXT4_INLINE_DOTDOT_SIZE;\n\t\t} else {\n\t\t\tde = (struct ext4_dir_entry_2 *)(dir_buf + pos);\n\t\t\tpos += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t\t\tif (ext4_check_dir_entry(inode, dir_file, de,\n\t\t\t\t\t iloc.bh, dir_buf,\n\t\t\t\t\t inline_size, pos)) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext4_hash_in_dirent(dir)) {\n\t\t\thinfo->hash = EXT4_DIRENT_HASH(de);\n\t\t\thinfo->minor_hash = EXT4_DIRENT_MINOR_HASH(de);\n\t\t} else {\n\t\t\text4fs_dirhash(dir, de->name, de->name_len, hinfo);\n\t\t}\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\ttmp_str.name = de->name;\n\t\ttmp_str.len = de->name_len;\n\t\terr = ext4_htree_store_dirent(dir_file, hinfo->hash,\n\t\t\t\t\t      hinfo->minor_hash, de, &tmp_str);\n\t\tif (err) {\n\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\t\tcount++;\n\t}\n\tret = count;\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\n \nint ext4_read_inline_dir(struct file *file,\n\t\t\t struct dir_context *ctx,\n\t\t\t int *has_inline_data)\n{\n\tunsigned int offset, parent_ino;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct inode *inode = file_inode(file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tint dotdot_offset, dotdot_size, extra_offset, extra_size;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tsb = inode->i_sb;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\toffset = ctx->pos;\n\n\t \n\tdotdot_offset = ext4_dir_rec_len(1, NULL);\n\tdotdot_size = dotdot_offset + ext4_dir_rec_len(2, NULL);\n\textra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\n\textra_size = extra_offset + inline_size;\n\n\t \n\tif (!inode_eq_iversion(inode, file->f_version)) {\n\t\tfor (i = 0; i < extra_size && i < offset;) {\n\t\t\t \n\t\t\tif (!i) {\n\t\t\t\ti = dotdot_offset;\n\t\t\t\tcontinue;\n\t\t\t} else if (i == dotdot_offset) {\n\t\t\t\ti = dotdot_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t(dir_buf + i - extra_offset);\n\t\t\t \n\t\t\tif (ext4_rec_len_from_disk(de->rec_len, extra_size)\n\t\t\t\t< ext4_dir_rec_len(1, NULL))\n\t\t\t\tbreak;\n\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t    extra_size);\n\t\t}\n\t\toffset = i;\n\t\tctx->pos = offset;\n\t\tfile->f_version = inode_query_iversion(inode);\n\t}\n\n\twhile (ctx->pos < extra_size) {\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->pos == dotdot_offset) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, parent_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t(dir_buf + ctx->pos - extra_offset);\n\t\tif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\n\t\t\t\t\t extra_size, ctx->pos))\n\t\t\tgoto out;\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t      get_dtype(sb, de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\n\t}\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\nvoid *ext4_read_inline_link(struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tint ret, inline_size;\n\tvoid *link;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = -ENOMEM;\n\tinline_size = ext4_get_inline_size(inode);\n\tlink = kmalloc(inline_size + 1, GFP_NOFS);\n\tif (!link)\n\t\tgoto out;\n\n\tret = ext4_read_inline_data(inode, link, inline_size, &iloc);\n\tif (ret < 0) {\n\t\tkfree(link);\n\t\tgoto out;\n\t}\n\tnd_terminate_link(link, inode->i_size, ret);\nout:\n\tif (ret < 0)\n\t\tlink = ERR_PTR(ret);\n\tbrelse(iloc.bh);\n\treturn link;\n}\n\nstruct buffer_head *ext4_get_first_inline_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *retval)\n{\n\tstruct ext4_iloc iloc;\n\n\t*retval = ext4_get_inode_loc(inode, &iloc);\n\tif (*retval)\n\t\treturn NULL;\n\n\t*parent_de = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\n\treturn iloc.bh;\n}\n\n \nint ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\nstruct buffer_head *ext4_find_inline_entry(struct inode *dir,\n\t\t\t\t\tstruct ext4_filename *fname,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *has_inline_data)\n{\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\tint inline_size;\n\n\tif (ext4_get_inode_loc(dir, &iloc))\n\t\treturn NULL;\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\tinline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;\n\tret = ext4_search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t      dir, fname, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ext4_get_inline_size(dir) == EXT4_MIN_INLINE_DATA_SIZE)\n\t\tgoto out;\n\n\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\tinline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;\n\n\tret = ext4_search_dir(iloc.bh, inline_start, inline_size,\n\t\t\t      dir, fname, 0, res_dir);\n\tif (ret == 1)\n\t\tgoto out_find;\n\nout:\n\tbrelse(iloc.bh);\n\tiloc.bh = NULL;\nout_find:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\treturn iloc.bh;\n}\n\nint ext4_delete_inline_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     int *has_inline_data)\n{\n\tint err, inline_size, no_expand;\n\tstruct ext4_iloc iloc;\n\tvoid *inline_start;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err)\n\t\treturn err;\n\n\text4_write_lock_xattr(dir, &no_expand);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tif ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <\n\t\tEXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_start = (void *)ext4_raw_inode(&iloc)->i_block +\n\t\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t\tinline_size = EXT4_MIN_INLINE_DATA_SIZE -\n\t\t\t\tEXT4_INLINE_DOTDOT_SIZE;\n\t} else {\n\t\tinline_start = ext4_get_inline_xattr_pos(dir, &iloc);\n\t\tinline_size = ext4_get_inline_size(dir) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(dir, de_del, bh,\n\t\t\t\t\tinline_start, inline_size, 0);\n\tif (err)\n\t\tgoto out;\n\n\text4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);\nout:\n\text4_write_unlock_xattr(dir, &no_expand);\n\tif (likely(err == 0))\n\t\terr = ext4_mark_inode_dirty(handle, dir);\n\tbrelse(iloc.bh);\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}\n\n \nstatic inline struct ext4_dir_entry_2 *\next4_get_inline_entry(struct inode *inode,\n\t\t      struct ext4_iloc *iloc,\n\t\t      unsigned int offset,\n\t\t      void **inline_start,\n\t\t      int *inline_size)\n{\n\tvoid *inline_pos;\n\n\tBUG_ON(offset > ext4_get_inline_size(inode));\n\n\tif (offset < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\tinline_pos = (void *)ext4_raw_inode(iloc)->i_block;\n\t\t*inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\t} else {\n\t\tinline_pos = ext4_get_inline_xattr_pos(inode, iloc);\n\t\toffset -= EXT4_MIN_INLINE_DATA_SIZE;\n\t\t*inline_size = ext4_get_inline_size(inode) -\n\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE;\n\t}\n\n\tif (inline_start)\n\t\t*inline_start = inline_pos;\n\treturn (struct ext4_dir_entry_2 *)(inline_pos + offset);\n}\n\nbool empty_inline_dir(struct inode *dir, int *has_inline_data)\n{\n\tint err, inline_size;\n\tstruct ext4_iloc iloc;\n\tsize_t inline_len;\n\tvoid *inline_pos;\n\tunsigned int offset;\n\tstruct ext4_dir_entry_2 *de;\n\tbool ret = false;\n\n\terr = ext4_get_inode_loc(dir, &iloc);\n\tif (err) {\n\t\tEXT4_ERROR_INODE_ERR(dir, -err,\n\t\t\t\t     \"error %d getting inode %lu block\",\n\t\t\t\t     err, dir->i_ino);\n\t\treturn false;\n\t}\n\n\tdown_read(&EXT4_I(dir)->xattr_sem);\n\tif (!ext4_has_inline_data(dir)) {\n\t\t*has_inline_data = 0;\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tif (!le32_to_cpu(de->inode)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"bad inline directory (dir #%lu) - no `..'\",\n\t\t\t     dir->i_ino);\n\t\tgoto out;\n\t}\n\n\tinline_len = ext4_get_inline_size(dir);\n\toffset = EXT4_INLINE_DOTDOT_SIZE;\n\twhile (offset < inline_len) {\n\t\tde = ext4_get_inline_entry(dir, &iloc, offset,\n\t\t\t\t\t   &inline_pos, &inline_size);\n\t\tif (ext4_check_dir_entry(dir, NULL, de,\n\t\t\t\t\t iloc.bh, inline_pos,\n\t\t\t\t\t inline_size, offset)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"bad inline directory (dir #%lu) - \"\n\t\t\t\t     \"inode %u, rec_len %u, name_len %d\"\n\t\t\t\t     \"inline size %d\",\n\t\t\t\t     dir->i_ino, le32_to_cpu(de->inode),\n\t\t\t\t     le16_to_cpu(de->rec_len), de->name_len,\n\t\t\t\t     inline_size);\n\t\t\tgoto out;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tgoto out;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, inline_size);\n\t}\n\n\tret = true;\nout:\n\tup_read(&EXT4_I(dir)->xattr_sem);\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\nint ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\n{\n\tint ret, no_expand;\n\n\text4_write_lock_xattr(inode, &no_expand);\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\text4_write_unlock_xattr(inode, &no_expand);\n\n\treturn ret;\n}\n\nint ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap)\n{\n\t__u64 addr;\n\tint error = -EAGAIN;\n\tstruct ext4_iloc iloc;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode))\n\t\tgoto out;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\tgoto out;\n\n\taddr = (__u64)iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;\n\taddr += (char *)ext4_raw_inode(&iloc) - iloc.bh->b_data;\n\taddr += offsetof(struct ext4_inode, i_block);\n\n\tbrelse(iloc.bh);\n\n\tiomap->addr = addr;\n\tiomap->offset = 0;\n\tiomap->length = min_t(loff_t, ext4_get_inline_size(inode),\n\t\t\t      i_size_read(inode));\n\tiomap->type = IOMAP_INLINE;\n\tiomap->flags = 0;\n\nout:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}\n\nint ext4_inline_data_truncate(struct inode *inode, int *has_inline)\n{\n\thandle_t *handle;\n\tint inline_size, value_len, needed_blocks, no_expand, err = 0;\n\tsize_t i_size;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\text4_write_lock_xattr(inode, &no_expand);\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_write_unlock_xattr(inode, &no_expand);\n\t\t*has_inline = 0;\n\t\text4_journal_stop(handle);\n\t\treturn 0;\n\t}\n\n\tif ((err = ext4_orphan_add(handle, inode)) != 0)\n\t\tgoto out;\n\n\tif ((err = ext4_get_inode_loc(inode, &is.iloc)) != 0)\n\t\tgoto out;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\ti_size = inode->i_size;\n\tinline_size = ext4_get_inline_size(inode);\n\tEXT4_I(inode)->i_disksize = i_size;\n\n\tif (i_size < inline_size) {\n\t\t \n\t\tif (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\t\t\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\n\t\t \n\t\tif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tif ((err = ext4_xattr_ibody_find(inode, &i, &is)) != 0)\n\t\t\t\tgoto out_error;\n\n\t\t\tBUG_ON(is.s.not_found);\n\n\t\t\tvalue_len = le32_to_cpu(is.s.here->e_value_size);\n\t\t\tvalue = kmalloc(value_len, GFP_NOFS);\n\t\t\tif (!value) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\terr = ext4_xattr_ibody_get(inode, i.name_index,\n\t\t\t\t\t\t   i.name, value, value_len);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out_error;\n\n\t\t\ti.value = value;\n\t\t\ti.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\ti_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\n\t\t\terr = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\t\tif (err)\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t \n\t\tif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\n\t\t\tmemset(p + i_size, 0,\n\t\t\t       EXT4_MIN_INLINE_DATA_SIZE - i_size);\n\t\t}\n\n\t\tEXT4_I(inode)->i_inline_size = i_size <\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE : i_size;\n\t}\n\nout_error:\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\tbrelse(is.iloc.bh);\n\text4_write_unlock_xattr(inode, &no_expand);\n\tkfree(value);\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tif (err == 0) {\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\text4_journal_stop(handle);\n\treturn err;\n}\n\nint ext4_convert_inline_data(struct inode *inode)\n{\n\tint error, needed_blocks, no_expand;\n\thandle_t *handle;\n\tstruct ext4_iloc iloc;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t\treturn 0;\n\t} else if (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\t \n\t\terror = filemap_flush(inode->i_mapping);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (!ext4_has_inline_data(inode))\n\t\t\treturn 0;\n\t}\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\n\tiloc.bh = NULL;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t\tgoto out_free;\n\t}\n\n\text4_write_lock_xattr(inode, &no_expand);\n\tif (ext4_has_inline_data(inode))\n\t\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\n\text4_write_unlock_xattr(inode, &no_expand);\n\text4_journal_stop(handle);\nout_free:\n\tbrelse(iloc.bh);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}