{
  "module_name": "extents.c",
  "hash_id": "c9305db98db8e652886bf91aa513d1a33979b7965b94fcf1cb3e47e9496b4655",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/extents.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/highuid.h>\n#include <linux/pagemap.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/fiemap.h>\n#include <linux/iomap.h>\n#include <linux/sched/mm.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\n#include \"xattr.h\"\n\n#include <trace/events/ext4.h>\n\n \n#define EXT4_EXT_MAY_ZEROOUT\t0x1   \n#define EXT4_EXT_MARK_UNWRIT1\t0x2   \n#define EXT4_EXT_MARK_UNWRIT2\t0x4   \n\n#define EXT4_EXT_DATA_VALID1\t0x8   \n#define EXT4_EXT_DATA_VALID2\t0x10  \n\nstatic __le32 ext4_extent_block_csum(struct inode *inode,\n\t\t\t\t     struct ext4_extent_header *eh)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)eh,\n\t\t\t   EXT4_EXTENT_TAIL_OFFSET(eh));\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_extent_block_csum_verify(struct inode *inode,\n\t\t\t\t\t struct ext4_extent_header *eh)\n{\n\tstruct ext4_extent_tail *et;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tet = find_ext4_extent_tail(eh);\n\tif (et->et_checksum != ext4_extent_block_csum(inode, eh))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void ext4_extent_block_csum_set(struct inode *inode,\n\t\t\t\t       struct ext4_extent_header *eh)\n{\n\tstruct ext4_extent_tail *et;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tet = find_ext4_extent_tail(eh);\n\tet->et_checksum = ext4_extent_block_csum(inode, eh);\n}\n\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nstatic int ext4_ext_trunc_restart_fn(struct inode *inode, int *dropped)\n{\n\t \n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\text4_discard_preallocations(inode, 0);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\t*dropped = 1;\n\treturn 0;\n}\n\nstatic void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++) {\n\t\tbrelse(path->p_bh);\n\t\tpath->p_bh = NULL;\n\t}\n}\n\nvoid ext4_free_ext_path(struct ext4_ext_path *path)\n{\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}\n\n \nint ext4_datasem_ensure_credits(handle_t *handle, struct inode *inode,\n\t\t\t\tint check_cred, int restart_cred,\n\t\t\t\tint revoke_cred)\n{\n\tint ret;\n\tint dropped = 0;\n\n\tret = ext4_journal_ensure_credits_fn(handle, check_cred, restart_cred,\n\t\trevoke_cred, ext4_ext_trunc_restart_fn(inode, &dropped));\n\tif (dropped)\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\treturn ret;\n}\n\n \nstatic int ext4_ext_get_access(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path)\n{\n\tint err = 0;\n\n\tif (path->p_bh) {\n\t\t \n\t\tBUFFER_TRACE(path->p_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode->i_sb,\n\t\t\t\t\t\t    path->p_bh, EXT4_JTR_NONE);\n\t\t \n\t\tif (!err)\n\t\t\tclear_buffer_verified(path->p_bh);\n\t}\n\t \n\t \n\treturn err;\n}\n\n \nstatic int __ext4_ext_dirty(const char *where, unsigned int line,\n\t\t\t    handle_t *handle, struct inode *inode,\n\t\t\t    struct ext4_ext_path *path)\n{\n\tint err;\n\n\tWARN_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));\n\tif (path->p_bh) {\n\t\text4_extent_block_csum_set(inode, ext_block_hdr(path->p_bh));\n\t\t \n\t\terr = __ext4_handle_dirty_metadata(where, line, handle,\n\t\t\t\t\t\t   inode, path->p_bh);\n\t\t \n\t\tif (!err)\n\t\t\tset_buffer_verified(path->p_bh);\n\t} else {\n\t\t \n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t}\n\treturn err;\n}\n\n#define ext4_ext_dirty(handle, inode, path) \\\n\t\t__ext4_ext_dirty(__func__, __LINE__, (handle), (inode), (path))\n\nstatic ext4_fsblk_t ext4_ext_find_goal(struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      ext4_lblk_t block)\n{\n\tif (path) {\n\t\tint depth = path->p_depth;\n\t\tstruct ext4_extent *ex;\n\n\t\t \n\t\tex = path[depth].p_ext;\n\t\tif (ex) {\n\t\t\text4_fsblk_t ext_pblk = ext4_ext_pblock(ex);\n\t\t\text4_lblk_t ext_block = le32_to_cpu(ex->ee_block);\n\n\t\t\tif (block > ext_block)\n\t\t\t\treturn ext_pblk + (block - ext_block);\n\t\t\telse\n\t\t\t\treturn ext_pblk - (ext_block - block);\n\t\t}\n\n\t\t \n\t\tif (path[depth].p_bh)\n\t\t\treturn path[depth].p_bh->b_blocknr;\n\t}\n\n\t \n\treturn ext4_inode_to_goal_block(inode);\n}\n\n \nstatic ext4_fsblk_t\next4_ext_new_meta_block(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_ext_path *path,\n\t\t\tstruct ext4_extent *ex, int *err, unsigned int flags)\n{\n\text4_fsblk_t goal, newblock;\n\n\tgoal = ext4_ext_find_goal(inode, path, le32_to_cpu(ex->ee_block));\n\tnewblock = ext4_new_meta_blocks(handle, inode, goal, flags,\n\t\t\t\t\tNULL, err);\n\treturn newblock;\n}\n\nstatic inline int ext4_ext_space_block(struct inode *inode, int check)\n{\n\tint size;\n\n\tsize = (inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))\n\t\t\t/ sizeof(struct ext4_extent);\n#ifdef AGGRESSIVE_TEST\n\tif (!check && size > 6)\n\t\tsize = 6;\n#endif\n\treturn size;\n}\n\nstatic inline int ext4_ext_space_block_idx(struct inode *inode, int check)\n{\n\tint size;\n\n\tsize = (inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))\n\t\t\t/ sizeof(struct ext4_extent_idx);\n#ifdef AGGRESSIVE_TEST\n\tif (!check && size > 5)\n\t\tsize = 5;\n#endif\n\treturn size;\n}\n\nstatic inline int ext4_ext_space_root(struct inode *inode, int check)\n{\n\tint size;\n\n\tsize = sizeof(EXT4_I(inode)->i_data);\n\tsize -= sizeof(struct ext4_extent_header);\n\tsize /= sizeof(struct ext4_extent);\n#ifdef AGGRESSIVE_TEST\n\tif (!check && size > 3)\n\t\tsize = 3;\n#endif\n\treturn size;\n}\n\nstatic inline int ext4_ext_space_root_idx(struct inode *inode, int check)\n{\n\tint size;\n\n\tsize = sizeof(EXT4_I(inode)->i_data);\n\tsize -= sizeof(struct ext4_extent_header);\n\tsize /= sizeof(struct ext4_extent_idx);\n#ifdef AGGRESSIVE_TEST\n\tif (!check && size > 4)\n\t\tsize = 4;\n#endif\n\treturn size;\n}\n\nstatic inline int\next4_force_split_extent_at(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_ext_path **ppath, ext4_lblk_t lblk,\n\t\t\t   int nofail)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tint unwritten = ext4_ext_is_unwritten(path[path->p_depth].p_ext);\n\tint flags = EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO;\n\n\tif (nofail)\n\t\tflags |= EXT4_GET_BLOCKS_METADATA_NOFAIL | EXT4_EX_NOFAIL;\n\n\treturn ext4_split_extent_at(handle, inode, ppath, lblk, unwritten ?\n\t\t\tEXT4_EXT_MARK_UNWRIT1|EXT4_EXT_MARK_UNWRIT2 : 0,\n\t\t\tflags);\n}\n\nstatic int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}\n\nstatic int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t \n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_inode_block_valid(inode, block, len);\n}\n\nstatic int ext4_valid_extent_idx(struct inode *inode,\n\t\t\t\tstruct ext4_extent_idx *ext_idx)\n{\n\text4_fsblk_t block = ext4_idx_pblock(ext_idx);\n\n\treturn ext4_inode_block_valid(inode, block, 1);\n}\n\nstatic int ext4_valid_extent_entries(struct inode *inode,\n\t\t\t\t     struct ext4_extent_header *eh,\n\t\t\t\t     ext4_lblk_t lblk, ext4_fsblk_t *pblk,\n\t\t\t\t     int depth)\n{\n\tunsigned short entries;\n\text4_lblk_t lblock = 0;\n\text4_lblk_t cur = 0;\n\n\tif (eh->eh_entries == 0)\n\t\treturn 1;\n\n\tentries = le16_to_cpu(eh->eh_entries);\n\n\tif (depth == 0) {\n\t\t \n\t\tstruct ext4_extent *ext = EXT_FIRST_EXTENT(eh);\n\n\t\t \n\t\tif (depth != ext_depth(inode) &&\n\t\t    lblk != le32_to_cpu(ext->ee_block))\n\t\t\treturn 0;\n\t\twhile (entries) {\n\t\t\tif (!ext4_valid_extent(inode, ext))\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tlblock = le32_to_cpu(ext->ee_block);\n\t\t\tif (lblock < cur) {\n\t\t\t\t*pblk = ext4_ext_pblock(ext);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcur = lblock + ext4_ext_get_actual_len(ext);\n\t\t\text++;\n\t\t\tentries--;\n\t\t}\n\t} else {\n\t\tstruct ext4_extent_idx *ext_idx = EXT_FIRST_INDEX(eh);\n\n\t\t \n\t\tif (depth != ext_depth(inode) &&\n\t\t    lblk != le32_to_cpu(ext_idx->ei_block))\n\t\t\treturn 0;\n\t\twhile (entries) {\n\t\t\tif (!ext4_valid_extent_idx(inode, ext_idx))\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tlblock = le32_to_cpu(ext_idx->ei_block);\n\t\t\tif (lblock < cur) {\n\t\t\t\t*pblk = ext4_idx_pblock(ext_idx);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\text_idx++;\n\t\t\tentries--;\n\t\t\tcur = lblock + 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int __ext4_ext_check(const char *function, unsigned int line,\n\t\t\t    struct inode *inode, struct ext4_extent_header *eh,\n\t\t\t    int depth, ext4_fsblk_t pblk, ext4_lblk_t lblk)\n{\n\tconst char *error_msg;\n\tint max = 0, err = -EFSCORRUPTED;\n\n\tif (unlikely(eh->eh_magic != EXT4_EXT_MAGIC)) {\n\t\terror_msg = \"invalid magic\";\n\t\tgoto corrupted;\n\t}\n\tif (unlikely(le16_to_cpu(eh->eh_depth) != depth)) {\n\t\terror_msg = \"unexpected eh_depth\";\n\t\tgoto corrupted;\n\t}\n\tif (unlikely(eh->eh_max == 0)) {\n\t\terror_msg = \"invalid eh_max\";\n\t\tgoto corrupted;\n\t}\n\tmax = ext4_ext_max_entries(inode, depth);\n\tif (unlikely(le16_to_cpu(eh->eh_max) > max)) {\n\t\terror_msg = \"too large eh_max\";\n\t\tgoto corrupted;\n\t}\n\tif (unlikely(le16_to_cpu(eh->eh_entries) > le16_to_cpu(eh->eh_max))) {\n\t\terror_msg = \"invalid eh_entries\";\n\t\tgoto corrupted;\n\t}\n\tif (unlikely((eh->eh_entries == 0) && (depth > 0))) {\n\t\terror_msg = \"eh_entries is 0 but eh_depth is > 0\";\n\t\tgoto corrupted;\n\t}\n\tif (!ext4_valid_extent_entries(inode, eh, lblk, &pblk, depth)) {\n\t\terror_msg = \"invalid extent entries\";\n\t\tgoto corrupted;\n\t}\n\tif (unlikely(depth > 32)) {\n\t\terror_msg = \"too large eh_depth\";\n\t\tgoto corrupted;\n\t}\n\t \n\tif (ext_depth(inode) != depth &&\n\t    !ext4_extent_block_csum_verify(inode, eh)) {\n\t\terror_msg = \"extent tree corrupted\";\n\t\terr = -EFSBADCRC;\n\t\tgoto corrupted;\n\t}\n\treturn 0;\n\ncorrupted:\n\text4_error_inode_err(inode, function, line, 0, -err,\n\t\t\t     \"pblk %llu bad header/extent: %s - magic %x, \"\n\t\t\t     \"entries %u, max %u(%u), depth %u(%u)\",\n\t\t\t     (unsigned long long) pblk, error_msg,\n\t\t\t     le16_to_cpu(eh->eh_magic),\n\t\t\t     le16_to_cpu(eh->eh_entries),\n\t\t\t     le16_to_cpu(eh->eh_max),\n\t\t\t     max, le16_to_cpu(eh->eh_depth), depth);\n\treturn err;\n}\n\n#define ext4_ext_check(inode, eh, depth, pblk)\t\t\t\\\n\t__ext4_ext_check(__func__, __LINE__, (inode), (eh), (depth), (pblk), 0)\n\nint ext4_ext_check_inode(struct inode *inode)\n{\n\treturn ext4_ext_check(inode, ext_inode_hdr(inode), ext_depth(inode), 0);\n}\n\nstatic void ext4_cache_extents(struct inode *inode,\n\t\t\t       struct ext4_extent_header *eh)\n{\n\tstruct ext4_extent *ex = EXT_FIRST_EXTENT(eh);\n\text4_lblk_t prev = 0;\n\tint i;\n\n\tfor (i = le16_to_cpu(eh->eh_entries); i > 0; i--, ex++) {\n\t\tunsigned int status = EXTENT_STATUS_WRITTEN;\n\t\text4_lblk_t lblk = le32_to_cpu(ex->ee_block);\n\t\tint len = ext4_ext_get_actual_len(ex);\n\n\t\tif (prev && (prev != lblk))\n\t\t\text4_es_cache_extent(inode, prev, lblk - prev, ~0,\n\t\t\t\t\t     EXTENT_STATUS_HOLE);\n\n\t\tif (ext4_ext_is_unwritten(ex))\n\t\t\tstatus = EXTENT_STATUS_UNWRITTEN;\n\t\text4_es_cache_extent(inode, lblk, len,\n\t\t\t\t     ext4_ext_pblock(ex), status);\n\t\tprev = lblk + len;\n\t}\n}\n\nstatic struct buffer_head *\n__read_extent_tree_block(const char *function, unsigned int line,\n\t\t\t struct inode *inode, struct ext4_extent_idx *idx,\n\t\t\t int depth, int flags)\n{\n\tstruct buffer_head\t\t*bh;\n\tint\t\t\t\terr;\n\tgfp_t\t\t\t\tgfp_flags = __GFP_MOVABLE | GFP_NOFS;\n\text4_fsblk_t\t\t\tpblk;\n\n\tif (flags & EXT4_EX_NOFAIL)\n\t\tgfp_flags |= __GFP_NOFAIL;\n\n\tpblk = ext4_idx_pblock(idx);\n\tbh = sb_getblk_gfp(inode->i_sb, pblk, gfp_flags);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\ttrace_ext4_ext_load_extent(inode, pblk, _RET_IP_);\n\t\terr = ext4_read_bh(bh, 0, NULL);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\tif (buffer_verified(bh) && !(flags & EXT4_EX_FORCE_CACHE))\n\t\treturn bh;\n\terr = __ext4_ext_check(function, line, inode, ext_block_hdr(bh),\n\t\t\t       depth, pblk, le32_to_cpu(idx->ei_block));\n\tif (err)\n\t\tgoto errout;\n\tset_buffer_verified(bh);\n\t \n\tif (!(flags & EXT4_EX_NOCACHE) && depth == 0) {\n\t\tstruct ext4_extent_header *eh = ext_block_hdr(bh);\n\t\text4_cache_extents(inode, eh);\n\t}\n\treturn bh;\nerrout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n\n}\n\n#define read_extent_tree_block(inode, idx, depth, flags)\t\t\\\n\t__read_extent_tree_block(__func__, __LINE__, (inode), (idx),\t\\\n\t\t\t\t (depth), (flags))\n\n \nint ext4_ext_precache(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct buffer_head *bh;\n\tint i = 0, depth, ret = 0;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn 0;\t \n\n\tdown_read(&ei->i_data_sem);\n\tdepth = ext_depth(inode);\n\n\t \n\tif (!depth) {\n\t\tup_read(&ei->i_data_sem);\n\t\treturn ret;\n\t}\n\n\tpath = kcalloc(depth + 1, sizeof(struct ext4_ext_path),\n\t\t       GFP_NOFS);\n\tif (path == NULL) {\n\t\tup_read(&ei->i_data_sem);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath[0].p_hdr = ext_inode_hdr(inode);\n\tret = ext4_ext_check(inode, path[0].p_hdr, depth, 0);\n\tif (ret)\n\t\tgoto out;\n\tpath[0].p_idx = EXT_FIRST_INDEX(path[0].p_hdr);\n\twhile (i >= 0) {\n\t\t \n\t\tif ((i == depth) ||\n\t\t    path[i].p_idx > EXT_LAST_INDEX(path[i].p_hdr)) {\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tbh = read_extent_tree_block(inode, path[i].p_idx++,\n\t\t\t\t\t    depth - i - 1,\n\t\t\t\t\t    EXT4_EX_FORCE_CACHE);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tpath[i].p_bh = bh;\n\t\tpath[i].p_hdr = ext_block_hdr(bh);\n\t\tpath[i].p_idx = EXT_FIRST_INDEX(path[i].p_hdr);\n\t}\n\text4_set_inode_state(inode, EXT4_STATE_EXT_PRECACHED);\nout:\n\tup_read(&ei->i_data_sem);\n\text4_free_ext_path(path);\n\treturn ret;\n}\n\n#ifdef EXT_DEBUG\nstatic void ext4_ext_show_path(struct inode *inode, struct ext4_ext_path *path)\n{\n\tint k, l = path->p_depth;\n\n\text_debug(inode, \"path:\");\n\tfor (k = 0; k <= l; k++, path++) {\n\t\tif (path->p_idx) {\n\t\t\text_debug(inode, \"  %d->%llu\",\n\t\t\t\t  le32_to_cpu(path->p_idx->ei_block),\n\t\t\t\t  ext4_idx_pblock(path->p_idx));\n\t\t} else if (path->p_ext) {\n\t\t\text_debug(inode, \"  %d:[%d]%d:%llu \",\n\t\t\t\t  le32_to_cpu(path->p_ext->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(path->p_ext),\n\t\t\t\t  ext4_ext_get_actual_len(path->p_ext),\n\t\t\t\t  ext4_ext_pblock(path->p_ext));\n\t\t} else\n\t\t\text_debug(inode, \"  []\");\n\t}\n\text_debug(inode, \"\\n\");\n}\n\nstatic void ext4_ext_show_leaf(struct inode *inode, struct ext4_ext_path *path)\n{\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex;\n\tint i;\n\n\tif (!path)\n\t\treturn;\n\n\teh = path[depth].p_hdr;\n\tex = EXT_FIRST_EXTENT(eh);\n\n\text_debug(inode, \"Displaying leaf extents\\n\");\n\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ex++) {\n\t\text_debug(inode, \"%d:[%d]%d:%llu \", le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t  ext4_ext_get_actual_len(ex), ext4_ext_pblock(ex));\n\t}\n\text_debug(inode, \"\\n\");\n}\n\nstatic void ext4_ext_show_move(struct inode *inode, struct ext4_ext_path *path,\n\t\t\text4_fsblk_t newblock, int level)\n{\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent *ex;\n\n\tif (depth != level) {\n\t\tstruct ext4_extent_idx *idx;\n\t\tidx = path[level].p_idx;\n\t\twhile (idx <= EXT_MAX_INDEX(path[level].p_hdr)) {\n\t\t\text_debug(inode, \"%d: move %d:%llu in new index %llu\\n\",\n\t\t\t\t  level, le32_to_cpu(idx->ei_block),\n\t\t\t\t  ext4_idx_pblock(idx), newblock);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tex = path[depth].p_ext;\n\twhile (ex <= EXT_MAX_EXTENT(path[depth].p_hdr)) {\n\t\text_debug(inode, \"move %d:%llu:[%d]%d in new leaf %llu\\n\",\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\text4_ext_pblock(ex),\n\t\t\t\text4_ext_is_unwritten(ex),\n\t\t\t\text4_ext_get_actual_len(ex),\n\t\t\t\tnewblock);\n\t\tex++;\n\t}\n}\n\n#else\n#define ext4_ext_show_path(inode, path)\n#define ext4_ext_show_leaf(inode, path)\n#define ext4_ext_show_move(inode, path, newblock, level)\n#endif\n\n \nstatic void\next4_ext_binsearch_idx(struct inode *inode,\n\t\t\tstruct ext4_ext_path *path, ext4_lblk_t block)\n{\n\tstruct ext4_extent_header *eh = path->p_hdr;\n\tstruct ext4_extent_idx *r, *l, *m;\n\n\n\text_debug(inode, \"binsearch for %u(idx):  \", block);\n\n\tl = EXT_FIRST_INDEX(eh) + 1;\n\tr = EXT_LAST_INDEX(eh);\n\twhile (l <= r) {\n\t\tm = l + (r - l) / 2;\n\t\text_debug(inode, \"%p(%u):%p(%u):%p(%u) \", l,\n\t\t\t  le32_to_cpu(l->ei_block), m, le32_to_cpu(m->ei_block),\n\t\t\t  r, le32_to_cpu(r->ei_block));\n\n\t\tif (block < le32_to_cpu(m->ei_block))\n\t\t\tr = m - 1;\n\t\telse\n\t\t\tl = m + 1;\n\t}\n\n\tpath->p_idx = l - 1;\n\text_debug(inode, \"  -> %u->%lld \", le32_to_cpu(path->p_idx->ei_block),\n\t\t  ext4_idx_pblock(path->p_idx));\n\n#ifdef CHECK_BINSEARCH\n\t{\n\t\tstruct ext4_extent_idx *chix, *ix;\n\t\tint k;\n\n\t\tchix = ix = EXT_FIRST_INDEX(eh);\n\t\tfor (k = 0; k < le16_to_cpu(eh->eh_entries); k++, ix++) {\n\t\t\tif (k != 0 && le32_to_cpu(ix->ei_block) <=\n\t\t\t    le32_to_cpu(ix[-1].ei_block)) {\n\t\t\t\tprintk(KERN_DEBUG \"k=%d, ix=0x%p, \"\n\t\t\t\t       \"first=0x%p\\n\", k,\n\t\t\t\t       ix, EXT_FIRST_INDEX(eh));\n\t\t\t\tprintk(KERN_DEBUG \"%u <= %u\\n\",\n\t\t\t\t       le32_to_cpu(ix->ei_block),\n\t\t\t\t       le32_to_cpu(ix[-1].ei_block));\n\t\t\t}\n\t\t\tBUG_ON(k && le32_to_cpu(ix->ei_block)\n\t\t\t\t\t   <= le32_to_cpu(ix[-1].ei_block));\n\t\t\tif (block < le32_to_cpu(ix->ei_block))\n\t\t\t\tbreak;\n\t\t\tchix = ix;\n\t\t}\n\t\tBUG_ON(chix != path->p_idx);\n\t}\n#endif\n\n}\n\n \nstatic void\next4_ext_binsearch(struct inode *inode,\n\t\tstruct ext4_ext_path *path, ext4_lblk_t block)\n{\n\tstruct ext4_extent_header *eh = path->p_hdr;\n\tstruct ext4_extent *r, *l, *m;\n\n\tif (eh->eh_entries == 0) {\n\t\t \n\t\treturn;\n\t}\n\n\text_debug(inode, \"binsearch for %u:  \", block);\n\n\tl = EXT_FIRST_EXTENT(eh) + 1;\n\tr = EXT_LAST_EXTENT(eh);\n\n\twhile (l <= r) {\n\t\tm = l + (r - l) / 2;\n\t\text_debug(inode, \"%p(%u):%p(%u):%p(%u) \", l,\n\t\t\t  le32_to_cpu(l->ee_block), m, le32_to_cpu(m->ee_block),\n\t\t\t  r, le32_to_cpu(r->ee_block));\n\n\t\tif (block < le32_to_cpu(m->ee_block))\n\t\t\tr = m - 1;\n\t\telse\n\t\t\tl = m + 1;\n\t}\n\n\tpath->p_ext = l - 1;\n\text_debug(inode, \"  -> %d:%llu:[%d]%d \",\n\t\t\tle32_to_cpu(path->p_ext->ee_block),\n\t\t\text4_ext_pblock(path->p_ext),\n\t\t\text4_ext_is_unwritten(path->p_ext),\n\t\t\text4_ext_get_actual_len(path->p_ext));\n\n#ifdef CHECK_BINSEARCH\n\t{\n\t\tstruct ext4_extent *chex, *ex;\n\t\tint k;\n\n\t\tchex = ex = EXT_FIRST_EXTENT(eh);\n\t\tfor (k = 0; k < le16_to_cpu(eh->eh_entries); k++, ex++) {\n\t\t\tBUG_ON(k && le32_to_cpu(ex->ee_block)\n\t\t\t\t\t  <= le32_to_cpu(ex[-1].ee_block));\n\t\t\tif (block < le32_to_cpu(ex->ee_block))\n\t\t\t\tbreak;\n\t\t\tchex = ex;\n\t\t}\n\t\tBUG_ON(chex != path->p_ext);\n\t}\n#endif\n\n}\n\nvoid ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\teh->eh_generation = 0;\n\text4_mark_inode_dirty(handle, inode);\n}\n\nstruct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\tgfp_t gfp_flags = GFP_NOFS;\n\n\tif (flags & EXT4_EX_NOFAIL)\n\t\tgfp_flags |= __GFP_NOFAIL;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\tif (depth < 0 || depth > EXT4_MAX_EXTENT_DEPTH) {\n\t\tEXT4_ERROR_INODE(inode, \"inode has invalid extent depth: %d\",\n\t\t\t\t depth);\n\t\tret = -EFSCORRUPTED;\n\t\tgoto err;\n\t}\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t \n\t\tpath = kcalloc(depth + 2, sizeof(struct ext4_ext_path),\n\t\t\t\tgfp_flags);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\tif (!(flags & EXT4_EX_NOCACHE) && depth == 0)\n\t\text4_cache_extents(inode, eh);\n\t \n\twhile (i) {\n\t\text_debug(inode, \"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_idx, --i, flags);\n\t\tif (IS_ERR(bh)) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t \n\text4_ext_binsearch(inode, path + ppos, block);\n\t \n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_free_ext_path(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int ext4_ext_insert_index(handle_t *handle, struct inode *inode,\n\t\t\t\t struct ext4_ext_path *curp,\n\t\t\t\t int logical, ext4_fsblk_t ptr)\n{\n\tstruct ext4_extent_idx *ix;\n\tint len, err;\n\n\terr = ext4_ext_get_access(handle, inode, curp);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(logical == le32_to_cpu(curp->p_idx->ei_block))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"logical %d == ei_block %d!\",\n\t\t\t\t logical, le32_to_cpu(curp->p_idx->ei_block));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(le16_to_cpu(curp->p_hdr->eh_entries)\n\t\t\t     >= le16_to_cpu(curp->p_hdr->eh_max))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"eh_entries %d >= eh_max %d!\",\n\t\t\t\t le16_to_cpu(curp->p_hdr->eh_entries),\n\t\t\t\t le16_to_cpu(curp->p_hdr->eh_max));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (logical > le32_to_cpu(curp->p_idx->ei_block)) {\n\t\t \n\t\text_debug(inode, \"insert new index %d after: %llu\\n\",\n\t\t\t  logical, ptr);\n\t\tix = curp->p_idx + 1;\n\t} else {\n\t\t \n\t\text_debug(inode, \"insert new index %d before: %llu\\n\",\n\t\t\t  logical, ptr);\n\t\tix = curp->p_idx;\n\t}\n\n\tif (unlikely(ix > EXT_MAX_INDEX(curp->p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, \"ix > EXT_MAX_INDEX!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tlen = EXT_LAST_INDEX(curp->p_hdr) - ix + 1;\n\tBUG_ON(len < 0);\n\tif (len > 0) {\n\t\text_debug(inode, \"insert new index %d: \"\n\t\t\t\t\"move %d indices from 0x%p to 0x%p\\n\",\n\t\t\t\tlogical, len, ix, ix + 1);\n\t\tmemmove(ix + 1, ix, len * sizeof(struct ext4_extent_idx));\n\t}\n\n\tix->ei_block = cpu_to_le32(logical);\n\text4_idx_store_pblock(ix, ptr);\n\tle16_add_cpu(&curp->p_hdr->eh_entries, 1);\n\n\tif (unlikely(ix > EXT_LAST_INDEX(curp->p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, \"ix > EXT_LAST_INDEX!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\terr = ext4_ext_dirty(handle, inode, curp);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}\n\n \nstatic int ext4_ext_split(handle_t *handle, struct inode *inode,\n\t\t\t  unsigned int flags,\n\t\t\t  struct ext4_ext_path *path,\n\t\t\t  struct ext4_extent *newext, int at)\n{\n\tstruct buffer_head *bh = NULL;\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *neh;\n\tstruct ext4_extent_idx *fidx;\n\tint i = at, k, m, a;\n\text4_fsblk_t newblock, oldblock;\n\t__le32 border;\n\text4_fsblk_t *ablocks = NULL;  \n\tgfp_t gfp_flags = GFP_NOFS;\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\tif (flags & EXT4_EX_NOFAIL)\n\t\tgfp_flags |= __GFP_NOFAIL;\n\n\t \n\t \n\n\t \n\tif (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, \"p_ext > EXT_MAX_EXTENT!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {\n\t\tborder = path[depth].p_ext[1].ee_block;\n\t\text_debug(inode, \"leaf will be split.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\t  le32_to_cpu(border));\n\t} else {\n\t\tborder = newext->ee_block;\n\t\text_debug(inode, \"leaf will be added.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\tle32_to_cpu(border));\n\t}\n\n\t \n\n\t \n\tablocks = kcalloc(depth, sizeof(ext4_fsblk_t), gfp_flags);\n\tif (!ablocks)\n\t\treturn -ENOMEM;\n\n\t \n\text_debug(inode, \"allocate %d blocks for indexes/leaf\\n\", depth - at);\n\tfor (a = 0; a < depth - at; a++) {\n\t\tnewblock = ext4_ext_new_meta_block(handle, inode, path,\n\t\t\t\t\t\t   newext, &err, flags);\n\t\tif (newblock == 0)\n\t\t\tgoto cleanup;\n\t\tablocks[a] = newblock;\n\t}\n\n\t \n\tnewblock = ablocks[--a];\n\tif (unlikely(newblock == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"newblock == 0!\");\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh)) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, inode->i_sb, bh,\n\t\t\t\t\t     EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto cleanup;\n\n\tneh = ext_block_hdr(bh);\n\tneh->eh_entries = 0;\n\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\tneh->eh_depth = 0;\n\tneh->eh_generation = 0;\n\n\t \n\tif (unlikely(path[depth].p_hdr->eh_entries !=\n\t\t     path[depth].p_hdr->eh_max)) {\n\t\tEXT4_ERROR_INODE(inode, \"eh_entries %d != eh_max %d!\",\n\t\t\t\t path[depth].p_hdr->eh_entries,\n\t\t\t\t path[depth].p_hdr->eh_max);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\t \n\tm = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;\n\text4_ext_show_move(inode, path, newblock, depth);\n\tif (m) {\n\t\tstruct ext4_extent *ex;\n\t\tex = EXT_FIRST_EXTENT(neh);\n\t\tmemmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);\n\t\tle16_add_cpu(&neh->eh_entries, m);\n\t}\n\n\t \n\text_size = sizeof(struct ext4_extent_header) +\n\t\tsizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);\n\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);\n\text4_extent_block_csum_set(inode, neh);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto cleanup;\n\tbrelse(bh);\n\tbh = NULL;\n\n\t \n\tif (m) {\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tle16_add_cpu(&path[depth].p_hdr->eh_entries, -m);\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t}\n\n\t \n\tk = depth - at - 1;\n\tif (unlikely(k < 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"k %d < 0!\", k);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tif (k)\n\t\text_debug(inode, \"create %d intermediate indices\\n\", k);\n\t \n\t \n\ti = depth - 1;\n\twhile (k--) {\n\t\toldblock = newblock;\n\t\tnewblock = ablocks[--a];\n\t\tbh = sb_getblk(inode->i_sb, newblock);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tlock_buffer(bh);\n\n\t\terr = ext4_journal_get_create_access(handle, inode->i_sb, bh,\n\t\t\t\t\t\t     EXT4_JTR_NONE);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tneh = ext_block_hdr(bh);\n\t\tneh->eh_entries = cpu_to_le16(1);\n\t\tneh->eh_magic = EXT4_EXT_MAGIC;\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\t\tneh->eh_depth = cpu_to_le16(depth - i);\n\t\tneh->eh_generation = 0;\n\t\tfidx = EXT_FIRST_INDEX(neh);\n\t\tfidx->ei_block = border;\n\t\text4_idx_store_pblock(fidx, oldblock);\n\n\t\text_debug(inode, \"int.index at %d (block %llu): %u -> %llu\\n\",\n\t\t\t\ti, newblock, le32_to_cpu(border), oldblock);\n\n\t\t \n\t\tif (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=\n\t\t\t\t\tEXT_LAST_INDEX(path[i].p_hdr))) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!\",\n\t\t\t\t\t le32_to_cpu(path[i].p_ext->ee_block));\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t \n\t\tm = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;\n\t\text_debug(inode, \"cur 0x%p, last 0x%p\\n\", path[i].p_idx,\n\t\t\t\tEXT_MAX_INDEX(path[i].p_hdr));\n\t\text4_ext_show_move(inode, path, newblock, i);\n\t\tif (m) {\n\t\t\tmemmove(++fidx, path[i].p_idx,\n\t\t\t\tsizeof(struct ext4_extent_idx) * m);\n\t\t\tle16_add_cpu(&neh->eh_entries, m);\n\t\t}\n\t\t \n\t\text_size = sizeof(struct ext4_extent_header) +\n\t\t   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));\n\t\tmemset(bh->b_data + ext_size, 0,\n\t\t\tinode->i_sb->s_blocksize - ext_size);\n\t\text4_extent_block_csum_set(inode, neh);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\t \n\t\tif (m) {\n\t\t\terr = ext4_ext_get_access(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tle16_add_cpu(&path[i].p_hdr->eh_entries, -m);\n\t\t\terr = ext4_ext_dirty(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\ti--;\n\t}\n\n\t \n\terr = ext4_ext_insert_index(handle, inode, path + at,\n\t\t\t\t    le32_to_cpu(border), newblock);\n\ncleanup:\n\tif (bh) {\n\t\tif (buffer_locked(bh))\n\t\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tif (err) {\n\t\t \n\t\tfor (i = 0; i < depth; i++) {\n\t\t\tif (!ablocks[i])\n\t\t\t\tcontinue;\n\t\t\text4_free_blocks(handle, inode, NULL, ablocks[i], 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t}\n\t}\n\tkfree(ablocks);\n\n\treturn err;\n}\n\n \nstatic int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,\n\t\t\t\t unsigned int flags)\n{\n\tstruct ext4_extent_header *neh;\n\tstruct buffer_head *bh;\n\text4_fsblk_t newblock, goal = 0;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\t \n\tif (ext_depth(inode))\n\t\tgoal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));\n\tif (goal > le32_to_cpu(es->s_first_data_block)) {\n\t\tflags |= EXT4_MB_HINT_TRY_GOAL;\n\t\tgoal--;\n\t} else\n\t\tgoal = ext4_inode_to_goal_block(inode);\n\tnewblock = ext4_new_meta_blocks(handle, inode, goal, flags,\n\t\t\t\t\tNULL, &err);\n\tif (newblock == 0)\n\t\treturn err;\n\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, inode->i_sb, bh,\n\t\t\t\t\t     EXT4_JTR_NONE);\n\tif (err) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\text_size = sizeof(EXT4_I(inode)->i_data);\n\t \n\tmemmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);\n\t \n\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);\n\n\t \n\tneh = ext_block_hdr(bh);\n\t \n\tif (ext_depth(inode))\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\telse\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\text4_extent_block_csum_set(inode, neh);\n\tset_buffer_uptodate(bh);\n\tset_buffer_verified(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tneh = ext_inode_hdr(inode);\n\tneh->eh_entries = cpu_to_le16(1);\n\text4_idx_store_pblock(EXT_FIRST_INDEX(neh), newblock);\n\tif (neh->eh_depth == 0) {\n\t\t \n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));\n\t\tEXT_FIRST_INDEX(neh)->ei_block =\n\t\t\tEXT_FIRST_EXTENT(neh)->ee_block;\n\t}\n\text_debug(inode, \"new root: num %d(%d), lblock %d, ptr %llu\\n\",\n\t\t  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),\n\t\t  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),\n\t\t  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));\n\n\tle16_add_cpu(&neh->eh_depth, 1);\n\terr = ext4_mark_inode_dirty(handle, inode);\nout:\n\tbrelse(bh);\n\n\treturn err;\n}\n\n \nstatic int ext4_ext_create_new_leaf(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int mb_flags,\n\t\t\t\t    unsigned int gb_flags,\n\t\t\t\t    struct ext4_ext_path **ppath,\n\t\t\t\t    struct ext4_extent *newext)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_ext_path *curp;\n\tint depth, i, err = 0;\n\nrepeat:\n\ti = depth = ext_depth(inode);\n\n\t \n\tcurp = path + depth;\n\twhile (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {\n\t\ti--;\n\t\tcurp--;\n\t}\n\n\t \n\tif (EXT_HAS_FREE_INDEX(curp)) {\n\t\t \n\t\terr = ext4_ext_split(handle, inode, mb_flags, path, newext, i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tpath = ext4_find_extent(inode,\n\t\t\t\t    (ext4_lblk_t)le32_to_cpu(newext->ee_block),\n\t\t\t\t    ppath, gb_flags);\n\t\tif (IS_ERR(path))\n\t\t\terr = PTR_ERR(path);\n\t} else {\n\t\t \n\t\terr = ext4_ext_grow_indepth(handle, inode, mb_flags);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tpath = ext4_find_extent(inode,\n\t\t\t\t   (ext4_lblk_t)le32_to_cpu(newext->ee_block),\n\t\t\t\t    ppath, gb_flags);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdepth = ext_depth(inode);\n\t\tif (path[depth].p_hdr->eh_entries == path[depth].p_hdr->eh_max) {\n\t\t\t \n\t\t\tgoto repeat;\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\n \nstatic int ext4_ext_search_left(struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\text4_lblk_t *logical, ext4_fsblk_t *phys)\n{\n\tstruct ext4_extent_idx *ix;\n\tstruct ext4_extent *ex;\n\tint depth, ee_len;\n\n\tif (unlikely(path == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path == NULL *logical %d!\", *logical);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tdepth = path->p_depth;\n\t*phys = 0;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn 0;\n\n\t \n\n\tex = path[depth].p_ext;\n\tee_len = ext4_ext_get_actual_len(ex);\n\tif (*logical < le32_to_cpu(ex->ee_block)) {\n\t\tif (unlikely(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_FIRST_EXTENT != ex *logical %d ee_block %d!\",\n\t\t\t\t\t *logical, le32_to_cpu(ex->ee_block));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\twhile (--depth >= 0) {\n\t\t\tix = path[depth].p_idx;\n\t\t\tif (unlikely(ix != EXT_FIRST_INDEX(path[depth].p_hdr))) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t  \"ix (%d) != EXT_FIRST_INDEX (%d) (depth %d)!\",\n\t\t\t\t  ix != NULL ? le32_to_cpu(ix->ei_block) : 0,\n\t\t\t\t  le32_to_cpu(EXT_FIRST_INDEX(path[depth].p_hdr)->ei_block),\n\t\t\t\t  depth);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (unlikely(*logical < (le32_to_cpu(ex->ee_block) + ee_len))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"logical %d < ee_block %d + ee_len %d!\",\n\t\t\t\t *logical, le32_to_cpu(ex->ee_block), ee_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t*logical = le32_to_cpu(ex->ee_block) + ee_len - 1;\n\t*phys = ext4_ext_pblock(ex) + ee_len - 1;\n\treturn 0;\n}\n\n \nstatic int ext4_ext_search_right(struct inode *inode,\n\t\t\t\t struct ext4_ext_path *path,\n\t\t\t\t ext4_lblk_t *logical, ext4_fsblk_t *phys,\n\t\t\t\t struct ext4_extent *ret_ex)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent_idx *ix;\n\tstruct ext4_extent *ex;\n\tint depth;\t \n\tint ee_len;\n\n\tif (unlikely(path == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path == NULL *logical %d!\", *logical);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tdepth = path->p_depth;\n\t*phys = 0;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn 0;\n\n\t \n\n\tex = path[depth].p_ext;\n\tee_len = ext4_ext_get_actual_len(ex);\n\tif (*logical < le32_to_cpu(ex->ee_block)) {\n\t\tif (unlikely(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"first_extent(path[%d].p_hdr) != ex\",\n\t\t\t\t\t depth);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\twhile (--depth >= 0) {\n\t\t\tix = path[depth].p_idx;\n\t\t\tif (unlikely(ix != EXT_FIRST_INDEX(path[depth].p_hdr))) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"ix != EXT_FIRST_INDEX *logical %d!\",\n\t\t\t\t\t\t *logical);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t}\n\t\tgoto found_extent;\n\t}\n\n\tif (unlikely(*logical < (le32_to_cpu(ex->ee_block) + ee_len))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"logical %d < ee_block %d + ee_len %d!\",\n\t\t\t\t *logical, le32_to_cpu(ex->ee_block), ee_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ex != EXT_LAST_EXTENT(path[depth].p_hdr)) {\n\t\t \n\t\tex++;\n\t\tgoto found_extent;\n\t}\n\n\t \n\twhile (--depth >= 0) {\n\t\tix = path[depth].p_idx;\n\t\tif (ix != EXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\tgoto got_index;\n\t}\n\n\t \n\treturn 0;\n\ngot_index:\n\t \n\tix++;\n\twhile (++depth < path->p_depth) {\n\t\t \n\t\tbh = read_extent_tree_block(inode, ix, path->p_depth - depth, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\teh = ext_block_hdr(bh);\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tput_bh(bh);\n\t}\n\n\tbh = read_extent_tree_block(inode, ix, path->p_depth - depth, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\teh = ext_block_hdr(bh);\n\tex = EXT_FIRST_EXTENT(eh);\nfound_extent:\n\t*logical = le32_to_cpu(ex->ee_block);\n\t*phys = ext4_ext_pblock(ex);\n\tif (ret_ex)\n\t\t*ret_ex = *ex;\n\tif (bh)\n\t\tput_bh(bh);\n\treturn 1;\n}\n\n \next4_lblk_t\next4_ext_next_allocated_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn EXT_MAX_BLOCKS;\n\n\twhile (depth >= 0) {\n\t\tstruct ext4_ext_path *p = &path[depth];\n\n\t\tif (depth == path->p_depth) {\n\t\t\t \n\t\t\tif (p->p_ext && p->p_ext != EXT_LAST_EXTENT(p->p_hdr))\n\t\t\t\treturn le32_to_cpu(p->p_ext[1].ee_block);\n\t\t} else {\n\t\t\t \n\t\t\tif (p->p_idx != EXT_LAST_INDEX(p->p_hdr))\n\t\t\t\treturn le32_to_cpu(p->p_idx[1].ei_block);\n\t\t}\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}\n\n \nstatic ext4_lblk_t ext4_ext_next_leaf_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\t \n\tif (depth == 0)\n\t\treturn EXT_MAX_BLOCKS;\n\n\t \n\tdepth--;\n\n\twhile (depth >= 0) {\n\t\tif (path[depth].p_idx !=\n\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\treturn (ext4_lblk_t)\n\t\t\t\tle32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}\n\n \nstatic int ext4_ext_correct_indexes(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path)\n{\n\tstruct ext4_extent_header *eh;\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent *ex;\n\t__le32 border;\n\tint k, err = 0;\n\n\teh = path[depth].p_hdr;\n\tex = path[depth].p_ext;\n\n\tif (unlikely(ex == NULL || eh == NULL)) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"ex %p == NULL or eh %p == NULL\", ex, eh);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (depth == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (ex != EXT_FIRST_EXTENT(eh)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tk = depth - 1;\n\tborder = path[depth].p_ext->ee_block;\n\terr = ext4_ext_get_access(handle, inode, path + k);\n\tif (err)\n\t\treturn err;\n\tpath[k].p_idx->ei_block = border;\n\terr = ext4_ext_dirty(handle, inode, path + k);\n\tif (err)\n\t\treturn err;\n\n\twhile (k--) {\n\t\t \n\t\tif (path[k+1].p_idx != EXT_FIRST_INDEX(path[k+1].p_hdr))\n\t\t\tbreak;\n\t\terr = ext4_ext_get_access(handle, inode, path + k);\n\t\tif (err)\n\t\t\tbreak;\n\t\tpath[k].p_idx->ei_block = border;\n\t\terr = ext4_ext_dirty(handle, inode, path + k);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int ext4_can_extents_be_merged(struct inode *inode,\n\t\t\t\t      struct ext4_extent *ex1,\n\t\t\t\t      struct ext4_extent *ex2)\n{\n\tunsigned short ext1_ee_len, ext2_ee_len;\n\n\tif (ext4_ext_is_unwritten(ex1) != ext4_ext_is_unwritten(ex2))\n\t\treturn 0;\n\n\text1_ee_len = ext4_ext_get_actual_len(ex1);\n\text2_ee_len = ext4_ext_get_actual_len(ex2);\n\n\tif (le32_to_cpu(ex1->ee_block) + ext1_ee_len !=\n\t\t\tle32_to_cpu(ex2->ee_block))\n\t\treturn 0;\n\n\tif (ext1_ee_len + ext2_ee_len > EXT_INIT_MAX_LEN)\n\t\treturn 0;\n\n\tif (ext4_ext_is_unwritten(ex1) &&\n\t    ext1_ee_len + ext2_ee_len > EXT_UNWRITTEN_MAX_LEN)\n\t\treturn 0;\n#ifdef AGGRESSIVE_TEST\n\tif (ext1_ee_len >= 4)\n\t\treturn 0;\n#endif\n\n\tif (ext4_ext_pblock(ex1) + ext1_ee_len == ext4_ext_pblock(ex2))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ext4_ext_try_to_merge_right(struct inode *inode,\n\t\t\t\t struct ext4_ext_path *path,\n\t\t\t\t struct ext4_extent *ex)\n{\n\tstruct ext4_extent_header *eh;\n\tunsigned int depth, len;\n\tint merge_done = 0, unwritten;\n\n\tdepth = ext_depth(inode);\n\tBUG_ON(path[depth].p_hdr == NULL);\n\teh = path[depth].p_hdr;\n\n\twhile (ex < EXT_LAST_EXTENT(eh)) {\n\t\tif (!ext4_can_extents_be_merged(inode, ex, ex + 1))\n\t\t\tbreak;\n\t\t \n\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t+ ext4_ext_get_actual_len(ex + 1));\n\t\tif (unwritten)\n\t\t\text4_ext_mark_unwritten(ex);\n\n\t\tif (ex + 1 < EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = (EXT_LAST_EXTENT(eh) - ex - 1)\n\t\t\t\t* sizeof(struct ext4_extent);\n\t\t\tmemmove(ex + 1, ex + 2, len);\n\t\t}\n\t\tle16_add_cpu(&eh->eh_entries, -1);\n\t\tmerge_done = 1;\n\t\tWARN_ON(eh->eh_entries == 0);\n\t\tif (!eh->eh_entries)\n\t\t\tEXT4_ERROR_INODE(inode, \"eh->eh_entries = 0!\");\n\t}\n\n\treturn merge_done;\n}\n\n \nstatic void ext4_ext_try_to_merge_up(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct ext4_ext_path *path)\n{\n\tsize_t s;\n\tunsigned max_root = ext4_ext_space_root(inode, 0);\n\text4_fsblk_t blk;\n\n\tif ((path[0].p_depth != 1) ||\n\t    (le16_to_cpu(path[0].p_hdr->eh_entries) != 1) ||\n\t    (le16_to_cpu(path[1].p_hdr->eh_entries) > max_root))\n\t\treturn;\n\n\t \n\tif (ext4_journal_extend(handle, 2,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1)))\n\t\treturn;\n\n\t \n\tblk = ext4_idx_pblock(path[0].p_idx);\n\ts = le16_to_cpu(path[1].p_hdr->eh_entries) *\n\t\tsizeof(struct ext4_extent_idx);\n\ts += sizeof(struct ext4_extent_header);\n\n\tpath[1].p_maxdepth = path[0].p_maxdepth;\n\tmemcpy(path[0].p_hdr, path[1].p_hdr, s);\n\tpath[0].p_depth = 0;\n\tpath[0].p_ext = EXT_FIRST_EXTENT(path[0].p_hdr) +\n\t\t(path[1].p_ext - EXT_FIRST_EXTENT(path[1].p_hdr));\n\tpath[0].p_hdr->eh_max = cpu_to_le16(max_root);\n\n\tbrelse(path[1].p_bh);\n\text4_free_blocks(handle, inode, NULL, blk, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n}\n\n \nstatic void ext4_ext_try_to_merge(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  struct ext4_ext_path *path,\n\t\t\t\t  struct ext4_extent *ex)\n{\n\tstruct ext4_extent_header *eh;\n\tunsigned int depth;\n\tint merge_done = 0;\n\n\tdepth = ext_depth(inode);\n\tBUG_ON(path[depth].p_hdr == NULL);\n\teh = path[depth].p_hdr;\n\n\tif (ex > EXT_FIRST_EXTENT(eh))\n\t\tmerge_done = ext4_ext_try_to_merge_right(inode, path, ex - 1);\n\n\tif (!merge_done)\n\t\t(void) ext4_ext_try_to_merge_right(inode, path, ex);\n\n\text4_ext_try_to_merge_up(handle, inode, path);\n}\n\n \nstatic unsigned int ext4_ext_check_overlap(struct ext4_sb_info *sbi,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_extent *newext,\n\t\t\t\t\t   struct ext4_ext_path *path)\n{\n\text4_lblk_t b1, b2;\n\tunsigned int depth, len1;\n\tunsigned int ret = 0;\n\n\tb1 = le32_to_cpu(newext->ee_block);\n\tlen1 = ext4_ext_get_actual_len(newext);\n\tdepth = ext_depth(inode);\n\tif (!path[depth].p_ext)\n\t\tgoto out;\n\tb2 = EXT4_LBLK_CMASK(sbi, le32_to_cpu(path[depth].p_ext->ee_block));\n\n\t \n\tif (b2 < b1) {\n\t\tb2 = ext4_ext_next_allocated_block(path);\n\t\tif (b2 == EXT_MAX_BLOCKS)\n\t\t\tgoto out;\n\t\tb2 = EXT4_LBLK_CMASK(sbi, b2);\n\t}\n\n\t \n\tif (b1 + len1 < b1) {\n\t\tlen1 = EXT_MAX_BLOCKS - b1;\n\t\tnewext->ee_len = cpu_to_le16(len1);\n\t\tret = 1;\n\t}\n\n\t \n\tif (b1 + len1 > b2) {\n\t\tnewext->ee_len = cpu_to_le16(b2 - b1);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}\n\n \nint ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_extent *newext, int gb_flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex;  \n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tint mb_flags = 0, unwritten;\n\n\tif (gb_flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tmb_flags |= EXT4_MB_DELALLOC_RESERVED;\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (ex && !(gb_flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\n\t\t \n\t\tif (ex < EXT_LAST_EXTENT(eh) &&\n\t\t    (le32_to_cpu(ex->ee_block) +\n\t\t    ext4_ext_get_actual_len(ex) <\n\t\t    le32_to_cpu(newext->ee_block))) {\n\t\t\tex += 1;\n\t\t\tgoto prepend;\n\t\t} else if ((ex > EXT_FIRST_EXTENT(eh)) &&\n\t\t\t   (le32_to_cpu(newext->ee_block) +\n\t\t\t   ext4_ext_get_actual_len(newext) <\n\t\t\t   le32_to_cpu(ex->ee_block)))\n\t\t\tex -= 1;\n\n\t\t \n\t\tif (ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\t\text_debug(inode, \"append [%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\nprepend:\n\t\t \n\t\tif (ext4_can_extents_be_merged(inode, newext, ex)) {\n\t\t\text_debug(inode, \"prepend %u[%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  le32_to_cpu(newext->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_block = newext->ee_block;\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(newext));\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\t}\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t \n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = EXT_MAX_BLOCKS;\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))\n\t\tnext = ext4_ext_next_leaf_block(path);\n\tif (next != EXT_MAX_BLOCKS) {\n\t\text_debug(inode, \"next leaf block - %u\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_find_extent(inode, next, NULL, gb_flags);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(inode, \"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto has_space;\n\t\t}\n\t\text_debug(inode, \"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t \n\tif (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tmb_flags |= EXT4_MB_USE_RESERVED;\n\terr = ext4_ext_create_new_leaf(handle, inode, mb_flags, gb_flags,\n\t\t\t\t       ppath, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t \n\t\text_debug(inode, \"first extent in the leaf: %u:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tnearex = EXT_FIRST_EXTENT(eh);\n\t} else {\n\t\tif (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n\t\t\t \n\t\t\text_debug(inode, \"insert %u:%llu:[%d]%d before: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t\tnearex++;\n\t\t} else {\n\t\t\t \n\t\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\t\text_debug(inode, \"insert %u:%llu:[%d]%d after: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t}\n\t\tlen = EXT_LAST_EXTENT(eh) - nearex + 1;\n\t\tif (len > 0) {\n\t\t\text_debug(inode, \"insert %u:%llu:[%d]%d: \"\n\t\t\t\t\t\"move %d extents from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tlen, nearex, nearex + 1);\n\t\t\tmemmove(nearex + 1, nearex,\n\t\t\t\tlen * sizeof(struct ext4_extent));\n\t\t}\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tpath[depth].p_ext = nearex;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t \n\tif (!(gb_flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(handle, inode, path, nearex);\n\n\n\t \n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\ncleanup:\n\text4_free_ext_path(npath);\n\treturn err;\n}\n\nstatic int ext4_fill_es_cache_info(struct inode *inode,\n\t\t\t\t   ext4_lblk_t block, ext4_lblk_t num,\n\t\t\t\t   struct fiemap_extent_info *fieinfo)\n{\n\text4_lblk_t next, end = block + num - 1;\n\tstruct extent_status es;\n\tunsigned char blksize_bits = inode->i_sb->s_blocksize_bits;\n\tunsigned int flags;\n\tint err;\n\n\twhile (block <= end) {\n\t\tnext = 0;\n\t\tflags = 0;\n\t\tif (!ext4_es_lookup_extent(inode, block, &next, &es))\n\t\t\tbreak;\n\t\tif (ext4_es_is_unwritten(&es))\n\t\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tif (ext4_es_is_delayed(&es))\n\t\t\tflags |= (FIEMAP_EXTENT_DELALLOC |\n\t\t\t\t  FIEMAP_EXTENT_UNKNOWN);\n\t\tif (ext4_es_is_hole(&es))\n\t\t\tflags |= EXT4_FIEMAP_EXTENT_HOLE;\n\t\tif (next == 0)\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\tif (flags & (FIEMAP_EXTENT_DELALLOC|\n\t\t\t     EXT4_FIEMAP_EXTENT_HOLE))\n\t\t\tes.es_pblk = 0;\n\t\telse\n\t\t\tes.es_pblk = ext4_es_pblock(&es);\n\t\terr = fiemap_fill_next_extent(fieinfo,\n\t\t\t\t(__u64)es.es_lblk << blksize_bits,\n\t\t\t\t(__u64)es.es_pblk << blksize_bits,\n\t\t\t\t(__u64)es.es_len << blksize_bits,\n\t\t\t\tflags);\n\t\tif (next == 0)\n\t\t\tbreak;\n\t\tblock = next;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1)\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n\n \nstatic ext4_lblk_t ext4_ext_determine_hole(struct inode *inode,\n\t\t\t\t\t   struct ext4_ext_path *path,\n\t\t\t\t\t   ext4_lblk_t *lblk)\n{\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent *ex;\n\text4_lblk_t len;\n\n\tex = path[depth].p_ext;\n\tif (ex == NULL) {\n\t\t \n\t\t*lblk = 0;\n\t\tlen = EXT_MAX_BLOCKS;\n\t} else if (*lblk < le32_to_cpu(ex->ee_block)) {\n\t\tlen = le32_to_cpu(ex->ee_block) - *lblk;\n\t} else if (*lblk >= le32_to_cpu(ex->ee_block)\n\t\t\t+ ext4_ext_get_actual_len(ex)) {\n\t\text4_lblk_t next;\n\n\t\t*lblk = le32_to_cpu(ex->ee_block) + ext4_ext_get_actual_len(ex);\n\t\tnext = ext4_ext_next_allocated_block(path);\n\t\tBUG_ON(next == *lblk);\n\t\tlen = next - *lblk;\n\t} else {\n\t\tBUG();\n\t}\n\treturn len;\n}\n\n \nstatic void\next4_ext_put_gap_in_cache(struct inode *inode, ext4_lblk_t hole_start,\n\t\t\t  ext4_lblk_t hole_len)\n{\n\tstruct extent_status es;\n\n\text4_es_find_extent_range(inode, &ext4_es_is_delayed, hole_start,\n\t\t\t\t  hole_start + hole_len - 1, &es);\n\tif (es.es_len) {\n\t\t \n\t\tif (es.es_lblk <= hole_start)\n\t\t\treturn;\n\t\thole_len = min(es.es_lblk - hole_start, hole_len);\n\t}\n\text_debug(inode, \" -> %u:%u\\n\", hole_start, hole_len);\n\text4_es_insert_extent(inode, hole_start, hole_len, ~0,\n\t\t\t      EXTENT_STATUS_HOLE);\n}\n\n \nstatic int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_ext_path *path, int depth)\n{\n\tint err;\n\text4_fsblk_t leaf;\n\n\t \n\tdepth--;\n\tpath = path + depth;\n\tleaf = ext4_idx_pblock(path->p_idx);\n\tif (unlikely(path->p_hdr->eh_entries == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"path->p_hdr->eh_entries == 0\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\terr = ext4_ext_get_access(handle, inode, path);\n\tif (err)\n\t\treturn err;\n\n\tif (path->p_idx != EXT_LAST_INDEX(path->p_hdr)) {\n\t\tint len = EXT_LAST_INDEX(path->p_hdr) - path->p_idx;\n\t\tlen *= sizeof(struct ext4_extent_idx);\n\t\tmemmove(path->p_idx, path->p_idx + 1, len);\n\t}\n\n\tle16_add_cpu(&path->p_hdr->eh_entries, -1);\n\terr = ext4_ext_dirty(handle, inode, path);\n\tif (err)\n\t\treturn err;\n\text_debug(inode, \"index is empty, remove it, free block %llu\\n\", leaf);\n\ttrace_ext4_ext_rm_idx(inode, leaf);\n\n\text4_free_blocks(handle, inode, NULL, leaf, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\n\twhile (--depth >= 0) {\n\t\tif (path->p_idx != EXT_FIRST_INDEX(path->p_hdr))\n\t\t\tbreak;\n\t\tpath--;\n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err)\n\t\t\tbreak;\n\t\tpath->p_idx->ei_block = (path+1)->p_idx->ei_block;\n\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nint ext4_ext_calc_credits_for_single_extent(struct inode *inode, int nrblocks,\n\t\t\t\t\t\tstruct ext4_ext_path *path)\n{\n\tif (path) {\n\t\tint depth = ext_depth(inode);\n\t\tint ret = 0;\n\n\t\t \n\t\tif (le16_to_cpu(path[depth].p_hdr->eh_entries)\n\t\t\t\t< le16_to_cpu(path[depth].p_hdr->eh_max)) {\n\n\t\t\t \n\t\t\t \n\t\t\tret = 2 + EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ext4_chunk_trans_blocks(inode, nrblocks);\n}\n\n \nint ext4_ext_index_trans_blocks(struct inode *inode, int extents)\n{\n\tint index;\n\tint depth;\n\n\t \n\tif (ext4_has_inline_data(inode))\n\t\treturn 1;\n\n\tdepth = ext_depth(inode);\n\n\tif (extents <= 1)\n\t\tindex = depth * 2;\n\telse\n\t\tindex = depth * 3;\n\n\treturn index;\n}\n\nstatic inline int get_default_free_blocks_flags(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode) ||\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EA_INODE))\n\t\treturn EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET;\n\telse if (ext4_should_journal_data(inode))\n\t\treturn EXT4_FREE_BLOCKS_FORGET;\n\treturn 0;\n}\n\n \nstatic void ext4_rereserve_cluster(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tdquot_reclaim_block(inode, EXT4_C2B(sbi, 1));\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\tei->i_reserved_data_blocks++;\n\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, 1);\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, 1);\n\text4_remove_pending(inode, lblk);\n}\n\nstatic int ext4_remove_blocks(handle_t *handle, struct inode *inode,\n\t\t\t      struct ext4_extent *ex,\n\t\t\t      struct partial_cluster *partial,\n\t\t\t      ext4_lblk_t from, ext4_lblk_t to)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned short ee_len = ext4_ext_get_actual_len(ex);\n\text4_fsblk_t last_pblk, pblk;\n\text4_lblk_t num;\n\tint flags;\n\n\t \n\tif (from < le32_to_cpu(ex->ee_block) ||\n\t    to != le32_to_cpu(ex->ee_block) + ee_len - 1) {\n\t\text4_error(sbi->s_sb,\n\t\t\t   \"strange request: removal(2) %u-%u from %u:%u\",\n\t\t\t   from, to, le32_to_cpu(ex->ee_block), ee_len);\n\t\treturn 0;\n\t}\n\n#ifdef EXTENTS_STATS\n\tspin_lock(&sbi->s_ext_stats_lock);\n\tsbi->s_ext_blocks += ee_len;\n\tsbi->s_ext_extents++;\n\tif (ee_len < sbi->s_ext_min)\n\t\tsbi->s_ext_min = ee_len;\n\tif (ee_len > sbi->s_ext_max)\n\t\tsbi->s_ext_max = ee_len;\n\tif (ext_depth(inode) > sbi->s_depth_max)\n\t\tsbi->s_depth_max = ext_depth(inode);\n\tspin_unlock(&sbi->s_ext_stats_lock);\n#endif\n\n\ttrace_ext4_remove_blocks(inode, ex, from, to, partial);\n\n\t \n\tlast_pblk = ext4_ext_pblock(ex) + ee_len - 1;\n\n\tif (partial->state != initial &&\n\t    partial->pclu != EXT4_B2C(sbi, last_pblk)) {\n\t\tif (partial->state == tofree) {\n\t\t\tflags = get_default_free_blocks_flags(inode);\n\t\t\tif (ext4_is_pending(inode, partial->lblk))\n\t\t\t\tflags |= EXT4_FREE_BLOCKS_RERESERVE_CLUSTER;\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t EXT4_C2B(sbi, partial->pclu),\n\t\t\t\t\t sbi->s_cluster_ratio, flags);\n\t\t\tif (flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)\n\t\t\t\text4_rereserve_cluster(inode, partial->lblk);\n\t\t}\n\t\tpartial->state = initial;\n\t}\n\n\tnum = le32_to_cpu(ex->ee_block) + ee_len - from;\n\tpblk = ext4_ext_pblock(ex) + ee_len - num;\n\n\t \n\tflags = get_default_free_blocks_flags(inode);\n\n\t \n\tif ((EXT4_LBLK_COFF(sbi, to) != sbi->s_cluster_ratio - 1) &&\n\t    (EXT4_LBLK_CMASK(sbi, to) >= from) &&\n\t    (partial->state != nofree)) {\n\t\tif (ext4_is_pending(inode, to))\n\t\t\tflags |= EXT4_FREE_BLOCKS_RERESERVE_CLUSTER;\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_PBLK_CMASK(sbi, last_pblk),\n\t\t\t\t sbi->s_cluster_ratio, flags);\n\t\tif (flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)\n\t\t\text4_rereserve_cluster(inode, to);\n\t\tpartial->state = initial;\n\t\tflags = get_default_free_blocks_flags(inode);\n\t}\n\n\tflags |= EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER;\n\n\t \n\tflags |= EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER;\n\text4_free_blocks(handle, inode, NULL, pblk, num, flags);\n\n\t \n\tif (partial->state != initial && partial->pclu != EXT4_B2C(sbi, pblk))\n\t\tpartial->state = initial;\n\n\t \n\tif (EXT4_LBLK_COFF(sbi, from) && num == ee_len) {\n\t\tif (partial->state == initial) {\n\t\t\tpartial->pclu = EXT4_B2C(sbi, pblk);\n\t\t\tpartial->lblk = from;\n\t\t\tpartial->state = tofree;\n\t\t}\n\t} else {\n\t\tpartial->state = initial;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\next4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n\t\t struct ext4_ext_path *path,\n\t\t struct partial_cluster *partial,\n\t\t ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint err = 0, correct_index = 0;\n\tint depth = ext_depth(inode), credits, revoke_credits;\n\tstruct ext4_extent_header *eh;\n\text4_lblk_t a, b;\n\tunsigned num;\n\text4_lblk_t ex_ee_block;\n\tunsigned short ex_ee_len;\n\tunsigned unwritten = 0;\n\tstruct ext4_extent *ex;\n\text4_fsblk_t pblk;\n\n\t \n\text_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);\n\tif (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t \n\tex = path[depth].p_ext;\n\tif (!ex)\n\t\tex = EXT_LAST_EXTENT(eh);\n\n\tex_ee_block = le32_to_cpu(ex->ee_block);\n\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\ttrace_ext4_ext_rm_leaf(inode, start, ex, partial);\n\n\twhile (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {\n\n\t\tif (ext4_ext_is_unwritten(ex))\n\t\t\tunwritten = 1;\n\t\telse\n\t\t\tunwritten = 0;\n\n\t\text_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,\n\t\t\t  unwritten, ex_ee_len);\n\t\tpath[depth].p_ext = ex;\n\n\t\ta = max(ex_ee_block, start);\n\t\tb = min(ex_ee_block + ex_ee_len - 1, end);\n\n\t\text_debug(inode, \"  border %u:%u\\n\", a, b);\n\n\t\t \n\t\tif (end < ex_ee_block) {\n\t\t\t \n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex);\n\t\t\t\tpartial->pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial->state = nofree;\n\t\t\t}\n\t\t\tex--;\n\t\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t\t\tcontinue;\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"can not handle truncate %u:%u \"\n\t\t\t\t\t \"on extent %u:%u\",\n\t\t\t\t\t start, end, ex_ee_block,\n\t\t\t\t\t ex_ee_block + ex_ee_len - 1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t} else if (a != ex_ee_block) {\n\t\t\t \n\t\t\tnum = a - ex_ee_block;\n\t\t} else {\n\t\t\t \n\t\t\tnum = 0;\n\t\t}\n\t\t \n\t\tcredits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));\n\t\tif (ex == EXT_FIRST_EXTENT(eh)) {\n\t\t\tcorrect_index = 1;\n\t\t\tcredits += (ext_depth(inode)) + 1;\n\t\t}\n\t\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\t\t \n\t\trevoke_credits =\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb,\n\t\t\t\t\t\t\t  ext_depth(inode)) +\n\t\t\text4_free_data_revoke_credits(inode, b - a + 1);\n\n\t\terr = ext4_datasem_ensure_credits(handle, inode, credits,\n\t\t\t\t\t\t  credits, revoke_credits);\n\t\tif (err) {\n\t\t\tif (err > 0)\n\t\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (num == 0)\n\t\t\t \n\t\t\text4_ext_store_pblock(ex, 0);\n\n\t\tex->ee_len = cpu_to_le16(num);\n\t\t \n\t\tif (unwritten && num)\n\t\t\text4_ext_mark_unwritten(ex);\n\t\t \n\t\tif (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t \n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\n\t\t\t\t\tsizeof(struct ext4_extent));\n\n\t\t\t\t \n\t\t\t\tmemset(EXT_LAST_EXTENT(eh), 0,\n\t\t\t\t\tsizeof(struct ext4_extent));\n\t\t\t}\n\t\t\tle16_add_cpu(&eh->eh_entries, -1);\n\t\t}\n\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\text_debug(inode, \"new extent: %u:%u:%llu\\n\", ex_ee_block, num,\n\t\t\t\text4_ext_pblock(ex));\n\t\tex--;\n\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t}\n\n\tif (correct_index && eh->eh_entries)\n\t\terr = ext4_ext_correct_indexes(handle, inode, path);\n\n\t \n\tif (partial->state == tofree && ex >= EXT_FIRST_EXTENT(eh)) {\n\t\tpblk = ext4_ext_pblock(ex) + ex_ee_len - 1;\n\t\tif (partial->pclu != EXT4_B2C(sbi, pblk)) {\n\t\t\tint flags = get_default_free_blocks_flags(inode);\n\n\t\t\tif (ext4_is_pending(inode, partial->lblk))\n\t\t\t\tflags |= EXT4_FREE_BLOCKS_RERESERVE_CLUSTER;\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t EXT4_C2B(sbi, partial->pclu),\n\t\t\t\t\t sbi->s_cluster_ratio, flags);\n\t\t\tif (flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)\n\t\t\t\text4_rereserve_cluster(inode, partial->lblk);\n\t\t}\n\t\tpartial->state = initial;\n\t}\n\n\t \n\tif (err == 0 && eh->eh_entries == 0 && path[depth].p_bh != NULL)\n\t\terr = ext4_ext_rm_idx(handle, inode, path, depth);\n\nout:\n\treturn err;\n}\n\n \nstatic int\next4_ext_more_to_rm(struct ext4_ext_path *path)\n{\n\tBUG_ON(path->p_idx == NULL);\n\n\tif (path->p_idx < EXT_FIRST_INDEX(path->p_hdr))\n\t\treturn 0;\n\n\t \n\tif (le16_to_cpu(path->p_hdr->eh_entries) == path->p_block)\n\t\treturn 0;\n\treturn 1;\n}\n\nint ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t  ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct partial_cluster partial;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\tpartial.pclu = 0;\n\tpartial.lblk = 0;\n\tpartial.state = initial;\n\n\text_debug(inode, \"truncate since %u to %u\\n\", start, end);\n\n\t \n\thandle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\n\t\t\tdepth + 1,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, depth));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\ttrace_ext4_ext_remove_space(inode, start, end, depth);\n\n\t \n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block, ex_end, lblk;\n\t\text4_fsblk_t pblk;\n\n\t\t \n\t\tpath = ext4_find_extent(inode, end, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t \n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tex_end = ee_block + ext4_ext_get_actual_len(ex) - 1;\n\n\t\t \n\t\tif (end >= ee_block && end < ex_end) {\n\n\t\t\t \n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex) + end - ee_block + 1;\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = ext4_force_split_extent_at(handle, inode, &path,\n\t\t\t\t\t\t\t end + 1, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&\n\t\t\t   partial.state == initial) {\n\t\t\t \n\t\t\tlblk = ex_end + 1;\n\t\t\terr = ext4_ext_search_right(inode, path, &lblk, &pblk,\n\t\t\t\t\t\t    NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tif (pblk) {\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kcalloc(depth + 1, sizeof(struct ext4_ext_path),\n\t\t\t       GFP_NOFS | __GFP_NOFAIL);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_maxdepth = path[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t \n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n\t\t\t\t\t       &partial, start, end);\n\t\t\t \n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!path[i].p_hdr) {\n\t\t\text_debug(inode, \"initialize header\\n\");\n\t\t\tpath[i].p_hdr = ext_block_hdr(path[i].p_bh);\n\t\t}\n\n\t\tif (!path[i].p_idx) {\n\t\t\t \n\t\t\tpath[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;\n\t\t\text_debug(inode, \"init index ptr: hdr 0x%p, num %d\\n\",\n\t\t\t\t  path[i].p_hdr,\n\t\t\t\t  le16_to_cpu(path[i].p_hdr->eh_entries));\n\t\t} else {\n\t\t\t \n\t\t\tpath[i].p_idx--;\n\t\t}\n\n\t\text_debug(inode, \"level %d - index, first 0x%p, cur 0x%p\\n\",\n\t\t\t\ti, EXT_FIRST_INDEX(path[i].p_hdr),\n\t\t\t\tpath[i].p_idx);\n\t\tif (ext4_ext_more_to_rm(path + i)) {\n\t\t\tstruct buffer_head *bh;\n\t\t\t \n\t\t\text_debug(inode, \"move to level %d (block %llu)\\n\",\n\t\t\t\t  i + 1, ext4_idx_pblock(path[i].p_idx));\n\t\t\tmemset(path + i + 1, 0, sizeof(*path));\n\t\t\tbh = read_extent_tree_block(inode, path[i].p_idx,\n\t\t\t\t\t\t    depth - i - 1,\n\t\t\t\t\t\t    EXT4_EX_NOCACHE);\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\t \n\t\t\t\terr = PTR_ERR(bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tcond_resched();\n\t\t\tif (WARN_ON(i + 1 > depth)) {\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath[i + 1].p_bh = bh;\n\n\t\t\t \n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries);\n\t\t\ti++;\n\t\t} else {\n\t\t\t \n\t\t\tif (path[i].p_hdr->eh_entries == 0 && i > 0) {\n\t\t\t\t \n\t\t\t\terr = ext4_ext_rm_idx(handle, inode, path, i);\n\t\t\t}\n\t\t\t \n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\text_debug(inode, \"return to level %d\\n\", i);\n\t\t}\n\t}\n\n\ttrace_ext4_ext_remove_space_done(inode, start, end, depth, &partial,\n\t\t\t\t\t path->p_hdr->eh_entries);\n\n\t \n\tif (partial.state == tofree && err == 0) {\n\t\tint flags = get_default_free_blocks_flags(inode);\n\n\t\tif (ext4_is_pending(inode, partial.lblk))\n\t\t\tflags |= EXT4_FREE_BLOCKS_RERESERVE_CLUSTER;\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_C2B(sbi, partial.pclu),\n\t\t\t\t sbi->s_cluster_ratio, flags);\n\t\tif (flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)\n\t\t\text4_rereserve_cluster(inode, partial.lblk);\n\t\tpartial.state = initial;\n\t}\n\n\t \n\tif (path->p_hdr->eh_entries == 0) {\n\t\t \n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err == 0) {\n\t\t\text_inode_hdr(inode)->eh_depth = 0;\n\t\t\text_inode_hdr(inode)->eh_max =\n\t\t\t\tcpu_to_le16(ext4_ext_space_root(inode, 0));\n\t\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\t}\n\t}\nout:\n\text4_free_ext_path(path);\n\tpath = NULL;\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\text4_journal_stop(handle);\n\n\treturn err;\n}\n\n \nvoid ext4_ext_init(struct super_block *sb)\n{\n\t \n\n\tif (ext4_has_feature_extents(sb)) {\n#if defined(AGGRESSIVE_TEST) || defined(CHECK_BINSEARCH) || defined(EXTENTS_STATS)\n\t\tprintk(KERN_INFO \"EXT4-fs: file extents enabled\"\n#ifdef AGGRESSIVE_TEST\n\t\t       \", aggressive tests\"\n#endif\n#ifdef CHECK_BINSEARCH\n\t\t       \", check binsearch\"\n#endif\n#ifdef EXTENTS_STATS\n\t\t       \", stats\"\n#endif\n\t\t       \"\\n\");\n#endif\n#ifdef EXTENTS_STATS\n\t\tspin_lock_init(&EXT4_SB(sb)->s_ext_stats_lock);\n\t\tEXT4_SB(sb)->s_ext_min = 1 << 30;\n\t\tEXT4_SB(sb)->s_ext_max = 0;\n#endif\n\t}\n}\n\n \nvoid ext4_ext_release(struct super_block *sb)\n{\n\tif (!ext4_has_feature_extents(sb))\n\t\treturn;\n\n#ifdef EXTENTS_STATS\n\tif (EXT4_SB(sb)->s_ext_blocks && EXT4_SB(sb)->s_ext_extents) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\tprintk(KERN_ERR \"EXT4-fs: %lu blocks in %lu extents (%lu ave)\\n\",\n\t\t\tsbi->s_ext_blocks, sbi->s_ext_extents,\n\t\t\tsbi->s_ext_blocks / sbi->s_ext_extents);\n\t\tprintk(KERN_ERR \"EXT4-fs: extents: %lu min, %lu max, max depth %lu\\n\",\n\t\t\tsbi->s_ext_min, sbi->s_ext_max, sbi->s_depth_max);\n\t}\n#endif\n}\n\nstatic void ext4_zeroout_es(struct inode *inode, struct ext4_extent *ex)\n{\n\text4_lblk_t  ee_block;\n\text4_fsblk_t ee_pblock;\n\tunsigned int ee_len;\n\n\tee_block  = le32_to_cpu(ex->ee_block);\n\tee_len    = ext4_ext_get_actual_len(ex);\n\tee_pblock = ext4_ext_pblock(ex);\n\n\tif (ee_len == 0)\n\t\treturn;\n\n\text4_es_insert_extent(inode, ee_block, ee_len, ee_pblock,\n\t\t\t      EXTENT_STATUS_WRITTEN);\n}\n\n \nstatic int ext4_ext_zeroout(struct inode *inode, struct ext4_extent *ex)\n{\n\text4_fsblk_t ee_pblock;\n\tunsigned int ee_len;\n\n\tee_len    = ext4_ext_get_actual_len(ex);\n\tee_pblock = ext4_ext_pblock(ex);\n\treturn ext4_issue_zeroout(inode, le32_to_cpu(ex->ee_block), ee_pblock,\n\t\t\t\t  ee_len);\n}\n\n \nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex, zero_ex;\n\tstruct ext4_extent *ex2 = NULL;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\n\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n\n\text_debug(inode, \"logical block %llu\\n\", (unsigned long long)split);\n\n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\tBUG_ON(!ext4_ext_is_unwritten(ex) &&\n\t       split_flag & (EXT4_EXT_MAY_ZEROOUT |\n\t\t\t     EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t     EXT4_EXT_MARK_UNWRIT2));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t \n\t\tif (split_flag & EXT4_EXT_MARK_UNWRIT2)\n\t\t\text4_ext_mark_unwritten(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNWRIT1)\n\t\text4_ext_mark_unwritten(ex);\n\n\t \n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNWRIT2)\n\t\text4_ext_mark_unwritten(ex2);\n\n\terr = ext4_ext_insert_extent(handle, inode, ppath, &newex, flags);\n\tif (err != -ENOSPC && err != -EDQUOT && err != -ENOMEM)\n\t\tgoto out;\n\n\tif (EXT4_EXT_MAY_ZEROOUT & split_flag) {\n\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {\n\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1) {\n\t\t\t\terr = ext4_ext_zeroout(inode, ex2);\n\t\t\t\tzero_ex.ee_block = ex2->ee_block;\n\t\t\t\tzero_ex.ee_len = cpu_to_le16(\n\t\t\t\t\t\text4_ext_get_actual_len(ex2));\n\t\t\t\text4_ext_store_pblock(&zero_ex,\n\t\t\t\t\t\t      ext4_ext_pblock(ex2));\n\t\t\t} else {\n\t\t\t\terr = ext4_ext_zeroout(inode, ex);\n\t\t\t\tzero_ex.ee_block = ex->ee_block;\n\t\t\t\tzero_ex.ee_len = cpu_to_le16(\n\t\t\t\t\t\text4_ext_get_actual_len(ex));\n\t\t\t\text4_ext_store_pblock(&zero_ex,\n\t\t\t\t\t\t      ext4_ext_pblock(ex));\n\t\t\t}\n\t\t} else {\n\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n\t\t\tzero_ex.ee_block = orig_ex.ee_block;\n\t\t\tzero_ex.ee_len = cpu_to_le16(\n\t\t\t\t\t\text4_ext_get_actual_len(&orig_ex));\n\t\t\text4_ext_store_pblock(&zero_ex,\n\t\t\t\t\t      ext4_ext_pblock(&orig_ex));\n\t\t}\n\n\t\tif (!err) {\n\t\t\t \n\t\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\t\tif (!err)\n\t\t\t\t \n\t\t\t\text4_zeroout_es(inode, &zero_ex);\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t}\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\t \n\text4_ext_dirty(handle, inode, path + path->p_depth);\n\treturn err;\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}\n\n \nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path **ppath,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint unwritten;\n\tint split_flag1, flags1;\n\tint allocated = map->m_len;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tunwritten = ext4_ext_is_unwritten(ex);\n\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (unwritten)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNWRIT2;\n\t\tif (split_flag & EXT4_EXT_DATA_VALID2)\n\t\t\tsplit_flag1 |= EXT4_EXT_DATA_VALID1;\n\t\terr = ext4_split_extent_at(handle, inode, ppath,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t}\n\t \n\tpath = ext4_find_extent(inode, map->m_lblk, ppath, flags);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (!ex) {\n\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t (unsigned long) map->m_lblk);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tunwritten = ext4_ext_is_unwritten(ex);\n\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_DATA_VALID2;\n\t\tif (unwritten) {\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNWRIT1;\n\t\t\tsplit_flag1 |= split_flag & (EXT4_EXT_MAY_ZEROOUT |\n\t\t\t\t\t\t     EXT4_EXT_MARK_UNWRIT2);\n\t\t}\n\t\terr = ext4_split_extent_at(handle, inode, ppath,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : allocated;\n}\n\n \nstatic int ext4_ext_convert_to_initialized(handle_t *handle,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct ext4_map_blocks *map,\n\t\t\t\t\t   struct ext4_ext_path **ppath,\n\t\t\t\t\t   int flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_map_blocks split_map;\n\tstruct ext4_extent zero_ex1, zero_ex2;\n\tstruct ext4_extent *ex, *abut_ex;\n\text4_lblk_t ee_block, eof_block;\n\tunsigned int ee_len, depth, map_len = map->m_len;\n\tint allocated = 0, max_zeroout = 0;\n\tint err = 0;\n\tint split_flag = EXT4_EXT_DATA_VALID2;\n\n\text_debug(inode, \"logical block %llu, max_blocks %u\\n\",\n\t\t  (unsigned long long)map->m_lblk, map_len);\n\n\tsbi = EXT4_SB(inode->i_sb);\n\teof_block = (EXT4_I(inode)->i_disksize + inode->i_sb->s_blocksize - 1)\n\t\t\t>> inode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map_len)\n\t\teof_block = map->m_lblk + map_len;\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tzero_ex1.ee_len = 0;\n\tzero_ex2.ee_len = 0;\n\n\ttrace_ext4_ext_convert_to_initialized_enter(inode, map, ex);\n\n\t \n\tBUG_ON(!ext4_ext_is_unwritten(ex));\n\tBUG_ON(!in_range(map->m_lblk, ee_block, ee_len));\n\n\t \n\tif ((map->m_lblk == ee_block) &&\n\t\t \n\t\t(map_len < ee_len) &&\t\t \n\t\t(ex > EXT_FIRST_EXTENT(eh))) {\t \n\t\text4_lblk_t prev_lblk;\n\t\text4_fsblk_t prev_pblk, ee_pblk;\n\t\tunsigned int prev_len;\n\n\t\tabut_ex = ex - 1;\n\t\tprev_lblk = le32_to_cpu(abut_ex->ee_block);\n\t\tprev_len = ext4_ext_get_actual_len(abut_ex);\n\t\tprev_pblk = ext4_ext_pblock(abut_ex);\n\t\tee_pblk = ext4_ext_pblock(ex);\n\n\t\t \n\t\tif ((!ext4_ext_is_unwritten(abut_ex)) &&\t\t \n\t\t\t((prev_lblk + prev_len) == ee_block) &&\t\t \n\t\t\t((prev_pblk + prev_len) == ee_pblk) &&\t\t \n\t\t\t(prev_len < (EXT_INIT_MAX_LEN - map_len))) {\t \n\t\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\ttrace_ext4_ext_convert_to_initialized_fastpath(inode,\n\t\t\t\tmap, ex, abut_ex);\n\n\t\t\t \n\t\t\tex->ee_block = cpu_to_le32(ee_block + map_len);\n\t\t\text4_ext_store_pblock(ex, ee_pblk + map_len);\n\t\t\tex->ee_len = cpu_to_le16(ee_len - map_len);\n\t\t\text4_ext_mark_unwritten(ex);  \n\n\t\t\t \n\t\t\tabut_ex->ee_len = cpu_to_le16(prev_len + map_len);\n\n\t\t\t \n\t\t\tallocated = map_len;\n\t\t}\n\t} else if (((map->m_lblk + map_len) == (ee_block + ee_len)) &&\n\t\t   (map_len < ee_len) &&\t \n\t\t   ex < EXT_LAST_EXTENT(eh)) {\t \n\t\t \n\t\text4_lblk_t next_lblk;\n\t\text4_fsblk_t next_pblk, ee_pblk;\n\t\tunsigned int next_len;\n\n\t\tabut_ex = ex + 1;\n\t\tnext_lblk = le32_to_cpu(abut_ex->ee_block);\n\t\tnext_len = ext4_ext_get_actual_len(abut_ex);\n\t\tnext_pblk = ext4_ext_pblock(abut_ex);\n\t\tee_pblk = ext4_ext_pblock(ex);\n\n\t\t \n\t\tif ((!ext4_ext_is_unwritten(abut_ex)) &&\t\t \n\t\t    ((map->m_lblk + map_len) == next_lblk) &&\t\t \n\t\t    ((ee_pblk + ee_len) == next_pblk) &&\t\t \n\t\t    (next_len < (EXT_INIT_MAX_LEN - map_len))) {\t \n\t\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\ttrace_ext4_ext_convert_to_initialized_fastpath(inode,\n\t\t\t\tmap, ex, abut_ex);\n\n\t\t\t \n\t\t\tabut_ex->ee_block = cpu_to_le32(next_lblk - map_len);\n\t\t\text4_ext_store_pblock(abut_ex, next_pblk - map_len);\n\t\t\tex->ee_len = cpu_to_le16(ee_len - map_len);\n\t\t\text4_ext_mark_unwritten(ex);  \n\n\t\t\t \n\t\t\tabut_ex->ee_len = cpu_to_le16(next_len + map_len);\n\n\t\t\t \n\t\t\tallocated = map_len;\n\t\t}\n\t}\n\tif (allocated) {\n\t\t \n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\n\t\t \n\t\tpath[depth].p_ext = abut_ex;\n\t\tgoto out;\n\t} else\n\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\n\tWARN_ON(map->m_lblk < ee_block);\n\t \n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\n\tif (EXT4_EXT_MAY_ZEROOUT & split_flag)\n\t\tmax_zeroout = sbi->s_extent_max_zeroout_kb >>\n\t\t\t(inode->i_sb->s_blocksize_bits - 10);\n\n\t \n\tsplit_map.m_lblk = map->m_lblk;\n\tsplit_map.m_len = map->m_len;\n\n\tif (max_zeroout && (allocated > split_map.m_len)) {\n\t\tif (allocated <= max_zeroout) {\n\t\t\t \n\t\t\tzero_ex1.ee_block =\n\t\t\t\t cpu_to_le32(split_map.m_lblk +\n\t\t\t\t\t     split_map.m_len);\n\t\t\tzero_ex1.ee_len =\n\t\t\t\tcpu_to_le16(allocated - split_map.m_len);\n\t\t\text4_ext_store_pblock(&zero_ex1,\n\t\t\t\text4_ext_pblock(ex) + split_map.m_lblk +\n\t\t\t\tsplit_map.m_len - ee_block);\n\t\t\terr = ext4_ext_zeroout(inode, &zero_ex1);\n\t\t\tif (err)\n\t\t\t\tgoto fallback;\n\t\t\tsplit_map.m_len = allocated;\n\t\t}\n\t\tif (split_map.m_lblk - ee_block + split_map.m_len <\n\t\t\t\t\t\t\t\tmax_zeroout) {\n\t\t\t \n\t\t\tif (split_map.m_lblk != ee_block) {\n\t\t\t\tzero_ex2.ee_block = ex->ee_block;\n\t\t\t\tzero_ex2.ee_len = cpu_to_le16(split_map.m_lblk -\n\t\t\t\t\t\t\tee_block);\n\t\t\t\text4_ext_store_pblock(&zero_ex2,\n\t\t\t\t\t\t      ext4_ext_pblock(ex));\n\t\t\t\terr = ext4_ext_zeroout(inode, &zero_ex2);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto fallback;\n\t\t\t}\n\n\t\t\tsplit_map.m_len += split_map.m_lblk - ee_block;\n\t\t\tsplit_map.m_lblk = ee_block;\n\t\t\tallocated = map->m_len;\n\t\t}\n\t}\n\nfallback:\n\terr = ext4_split_extent(handle, inode, ppath, &split_map, split_flag,\n\t\t\t\tflags);\n\tif (err > 0)\n\t\terr = 0;\nout:\n\t \n\tif (!err) {\n\t\text4_zeroout_es(inode, &zero_ex1);\n\t\text4_zeroout_es(inode, &zero_ex2);\n\t}\n\treturn err ? err : allocated;\n}\n\n \nstatic int ext4_split_convert_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\n\text_debug(inode, \"logical block %llu, max_blocks %u\\n\",\n\t\t  (unsigned long long)map->m_lblk, map->m_len);\n\n\teof_block = (EXT4_I(inode)->i_disksize + inode->i_sb->s_blocksize - 1)\n\t\t\t>> inode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\t \n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\t \n\tif (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN) {\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID1;\n\t \n\t} else if (flags & EXT4_GET_BLOCKS_CONVERT) {\n\t\tsplit_flag |= ee_block + ee_len <= eof_block ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tsplit_flag |= (EXT4_EXT_MARK_UNWRIT2 | EXT4_EXT_DATA_VALID2);\n\t}\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, ppath, map, split_flag, flags);\n}\n\nstatic int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\t\tstruct ext4_ext_path **ppath)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\tunsigned int ee_len;\n\tint depth;\n\tint err = 0;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\text_debug(inode, \"logical block %llu, max_blocks %u\\n\",\n\t\t  (unsigned long long)ee_block, ee_len);\n\n\t \n\tif (ee_block != map->m_lblk || ee_len > map->m_len) {\n#ifdef CONFIG_EXT4_DEBUG\n\t\text4_warning(inode->i_sb, \"Inode (%ld) finished: extent logical block %llu,\"\n\t\t\t     \" len %u; IO logical block %llu, len %u\",\n\t\t\t     inode->i_ino, (unsigned long long)ee_block, ee_len,\n\t\t\t     (unsigned long long)map->m_lblk, map->m_len);\n#endif\n\t\terr = ext4_split_convert_extents(handle, inode, map, ppath,\n\t\t\t\t\t\t EXT4_GET_BLOCKS_CONVERT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath = ext4_find_extent(inode, map->m_lblk, ppath, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = ext_depth(inode);\n\t\tex = path[depth].p_ext;\n\t}\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\t \n\text4_ext_mark_initialized(ex);\n\n\t \n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t \n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}\n\nstatic int\nconvert_initialized_extent(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_map_blocks *map,\n\t\t\t   struct ext4_ext_path **ppath,\n\t\t\t   unsigned int *allocated)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\tunsigned int ee_len;\n\tint depth;\n\tint err = 0;\n\n\t \n\tif (map->m_len > EXT_UNWRITTEN_MAX_LEN)\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN / 2;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\text_debug(inode, \"logical block %llu, max_blocks %u\\n\",\n\t\t  (unsigned long long)ee_block, ee_len);\n\n\tif (ee_block != map->m_lblk || ee_len > map->m_len) {\n\t\terr = ext4_split_convert_extents(handle, inode, map, ppath,\n\t\t\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath = ext4_find_extent(inode, map->m_lblk, ppath, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = ext_depth(inode);\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t\t (unsigned long) map->m_lblk);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\treturn err;\n\t \n\text4_ext_mark_unwritten(ex);\n\n\t \n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t \n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\tif (err)\n\t\treturn err;\n\text4_ext_show_leaf(inode, path);\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\n\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\tif (*allocated > map->m_len)\n\t\t*allocated = map->m_len;\n\tmap->m_len = *allocated;\n\treturn 0;\n}\n\nstatic int\next4_ext_handle_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path **ppath, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tstruct ext4_ext_path __maybe_unused *path = *ppath;\n\tint ret = 0;\n\tint err = 0;\n\n\text_debug(inode, \"logical block %llu, max_blocks %u, flags 0x%x, allocated %u\\n\",\n\t\t  (unsigned long long)map->m_lblk, map->m_len, flags,\n\t\t  allocated);\n\text4_ext_show_leaf(inode, path);\n\n\t \n\tflags |= EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\n\ttrace_ext4_ext_handle_unwritten_extents(inode, map, flags,\n\t\t\t\t\t\t    allocated, newblock);\n\n\t \n\tif (flags & EXT4_GET_BLOCKS_PRE_IO) {\n\t\tret = ext4_split_convert_extents(handle, inode, map, ppath,\n\t\t\t\t\t flags | EXT4_GET_BLOCKS_CONVERT);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out2;\n\t\t}\n\t\t \n\t\tif (unlikely(ret == 0)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"unexpected ret == 0, m_len = %u\",\n\t\t\t\t\t map->m_len);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out2;\n\t\t}\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out;\n\t}\n\t \n\tif (flags & EXT4_GET_BLOCKS_CONVERT) {\n\t\terr = ext4_convert_unwritten_extents_endio(handle, inode, map,\n\t\t\t\t\t\t\t   ppath);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\tgoto map_out;\n\t}\n\t \n\t \n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto map_out;\n\t}\n\n\t \n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t \n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t \n\tret = ext4_ext_convert_to_initialized(handle, inode, map, ppath, flags);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t}\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\t \n\tif (unlikely(ret == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"unexpected ret == 0, m_len = %u\",\n\t\t\t\t map->m_len);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out2;\n\t}\n\nout:\n\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\nout1:\n\tmap->m_pblk = newblock;\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_len = allocated;\n\text4_ext_show_leaf(inode, path);\nout2:\n\treturn err ? err : allocated;\n}\n\n \nstatic int get_implied_cluster_alloc(struct super_block *sb,\n\t\t\t\t     struct ext4_map_blocks *map,\n\t\t\t\t     struct ext4_extent *ex,\n\t\t\t\t     struct ext4_ext_path *path)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_lblk_t c_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\text4_lblk_t ex_cluster_start, ex_cluster_end;\n\text4_lblk_t rr_cluster_start;\n\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\tunsigned short ee_len = ext4_ext_get_actual_len(ex);\n\n\t \n\tex_cluster_start = EXT4_B2C(sbi, ee_block);\n\tex_cluster_end = EXT4_B2C(sbi, ee_block + ee_len - 1);\n\n\t \n\trr_cluster_start = EXT4_B2C(sbi, map->m_lblk);\n\n\tif ((rr_cluster_start == ex_cluster_end) ||\n\t    (rr_cluster_start == ex_cluster_start)) {\n\t\tif (rr_cluster_start == ex_cluster_end)\n\t\t\tee_start += ee_len - 1;\n\t\tmap->m_pblk = EXT4_PBLK_CMASK(sbi, ee_start) + c_offset;\n\t\tmap->m_len = min(map->m_len,\n\t\t\t\t (unsigned) sbi->s_cluster_ratio - c_offset);\n\t\t \n\n\t\tif (map->m_lblk < ee_block)\n\t\t\tmap->m_len = min(map->m_len, ee_block - map->m_lblk);\n\n\t\t \n\t\tif (map->m_lblk > ee_block) {\n\t\t\text4_lblk_t next = ext4_ext_next_allocated_block(path);\n\t\t\tmap->m_len = min(map->m_len, next - map->m_lblk);\n\t\t}\n\n\t\ttrace_ext4_get_implied_cluster_alloc_exit(sb, map, 1);\n\t\treturn 1;\n\t}\n\n\ttrace_ext4_get_implied_cluster_alloc_exit(sb, map, 0);\n\treturn 0;\n}\n\n\n \nint ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0, pblk;\n\tint err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_lblk_t cluster_offset;\n\n\text_debug(inode, \"blocks %u/%u requested\\n\", map->m_lblk, map->m_len);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t \n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t \n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t \n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t \n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t \n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(inode, \"%u fit into %u:%d -> %llu\\n\",\n\t\t\t\t  map->m_lblk, ee_block, ee_len, newblock);\n\n\t\t\t \n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\terr = convert_initialized_extent(handle,\n\t\t\t\t\tinode, map, &path, &allocated);\n\t\t\t\tgoto out;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex)) {\n\t\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\t\t\tmap->m_pblk = newblock;\n\t\t\t\tif (allocated > map->m_len)\n\t\t\t\t\tallocated = map->m_len;\n\t\t\t\tmap->m_len = allocated;\n\t\t\t\text4_ext_show_leaf(inode, path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\text4_lblk_t hole_start, hole_len;\n\n\t\thole_start = map->m_lblk;\n\t\thole_len = ext4_ext_determine_hole(inode, path, &hole_start);\n\t\t \n\t\text4_ext_put_gap_in_cache(inode, hole_start, hole_len);\n\n\t\t \n\t\tif (hole_start != map->m_lblk)\n\t\t\thole_len -= map->m_lblk - hole_start;\n\t\tmap->m_pblk = 0;\n\t\tmap->m_len = min_t(unsigned int, map->m_len, hole_len);\n\n\t\tgoto out;\n\t}\n\n\t \n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t \n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t \n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out;\n\tar.lright = map->m_lblk;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tif ((sbi->s_cluster_ratio > 1) && err &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, &ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t \n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t \n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t \n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t \n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t \n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tif (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tar.flags |= EXT4_MB_USE_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\text_debug(inode, \"allocate new block: goal %llu, found %llu/%u, requested %u\\n\",\n\t\t  ar.goal, newblock, ar.len, allocated);\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t \n\tpblk = newblock + offset;\n\text4_ext_store_pblock(&newex, pblk);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t \n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t}\n\n\terr = ext4_ext_insert_extent(handle, inode, &path, &newex, flags);\n\tif (err) {\n\t\tif (allocated_clusters) {\n\t\t\tint fb_flags = 0;\n\n\t\t\t \n\t\t\text4_discard_preallocations(inode, 0);\n\t\t\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\t\t\tfb_flags = EXT4_FREE_BLOCKS_NO_QUOT_UPDATE;\n\t\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t\t EXT4_C2B(sbi, allocated_clusters),\n\t\t\t\t\t fb_flags);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (test_opt(inode->i_sb, DELALLOC) && allocated_clusters) {\n\t\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\t\t \n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t} else {\n\t\t\text4_lblk_t lblk, len;\n\t\t\tunsigned int n;\n\n\t\t\t \n\t\t\tlblk = EXT4_LBLK_CMASK(sbi, map->m_lblk);\n\t\t\tlen = allocated_clusters << sbi->s_cluster_bits;\n\t\t\tn = ext4_es_delayed_clu(inode, lblk, len);\n\t\t\tif (n > 0)\n\t\t\t\text4_da_update_reserve_space(inode, (int) n, 0);\n\t\t}\n\t}\n\n\t \n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\n\n\tmap->m_flags |= (EXT4_MAP_NEW | EXT4_MAP_MAPPED);\n\tmap->m_pblk = pblk;\n\tmap->m_len = ar.len;\n\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\nout:\n\text4_free_ext_path(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}\n\nint ext4_ext_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\tint err = 0;\n\n\t \n\n\t \n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err)\n\t\treturn err;\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\n\text4_es_remove_extent(inode, last_block, EXT_MAX_BLOCKS - last_block);\n\nretry_remove_space:\n\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n\tif (err == -ENOMEM) {\n\t\tmemalloc_retry_wait(GFP_ATOMIC);\n\t\tgoto retry_remove_space;\n\t}\n\treturn err;\n}\n\nstatic int ext4_alloc_file_blocks(struct file *file, ext4_lblk_t offset,\n\t\t\t\t  ext4_lblk_t len, loff_t new_size,\n\t\t\t\t  int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\thandle_t *handle;\n\tint ret = 0, ret2 = 0, ret3 = 0;\n\tint retries = 0;\n\tint depth = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits;\n\tloff_t epos;\n\n\tBUG_ON(!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS));\n\tmap.m_lblk = offset;\n\tmap.m_len = len;\n\t \n\tif (len <= EXT_UNWRITTEN_MAX_LEN)\n\t\tflags |= EXT4_GET_BLOCKS_NO_NORMALIZE;\n\n\t \n\tcredits = ext4_chunk_trans_blocks(inode, len);\n\tdepth = ext_depth(inode);\n\nretry:\n\twhile (len) {\n\t\t \n\t\tif (depth != ext_depth(inode)) {\n\t\t\tcredits = ext4_chunk_trans_blocks(inode, len);\n\t\t\tdepth = ext_depth(inode);\n\t\t}\n\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tbreak;\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map, flags);\n\t\tif (ret <= 0) {\n\t\t\text4_debug(\"inode #%lu: block %u: len %u: \"\n\t\t\t\t   \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t   inode->i_ino, map.m_lblk,\n\t\t\t\t   map.m_len, ret);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\text4_journal_stop(handle);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretries = 0;\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = len = len - ret;\n\t\tepos = (loff_t)map.m_lblk << inode->i_blkbits;\n\t\tinode_set_ctime_current(inode);\n\t\tif (new_size) {\n\t\t\tif (epos > new_size)\n\t\t\t\tepos = new_size;\n\t\t\tif (ext4_update_inode_size(inode, epos) & 0x1)\n\t\t\t\tinode->i_mtime = inode_get_ctime(inode);\n\t\t}\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\tret3 = ext4_journal_stop(handle);\n\t\tret2 = ret3 ? ret3 : ret2;\n\t\tif (unlikely(ret2))\n\t\t\tbreak;\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\treturn ret > 0 ? ret2 : ret;\n}\n\nstatic int ext4_collapse_range(struct file *file, loff_t offset, loff_t len);\n\nstatic int ext4_insert_range(struct file *file, loff_t offset, loff_t len);\n\nstatic long ext4_zero_range(struct file *file, loff_t offset,\n\t\t\t    loff_t len, int mode)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = file->f_mapping;\n\thandle_t *handle = NULL;\n\tunsigned int max_blocks;\n\tloff_t new_size = 0;\n\tint ret = 0;\n\tint flags;\n\tint credits;\n\tint partial_begin, partial_end;\n\tloff_t start, end;\n\text4_lblk_t lblk;\n\tunsigned int blkbits = inode->i_blkbits;\n\n\ttrace_ext4_zero_range(inode, offset, len, mode);\n\n\t \n\tstart = round_up(offset, 1 << blkbits);\n\tend = round_down((offset + len), 1 << blkbits);\n\n\tif (start < offset || end > offset + len)\n\t\treturn -EINVAL;\n\tpartial_begin = offset & ((1 << blkbits) - 1);\n\tpartial_end = (offset + len) & ((1 << blkbits) - 1);\n\n\tlblk = start >> blkbits;\n\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tinode_lock(inode);\n\n\t \n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    (offset + len > inode->i_size ||\n\t     offset + len > EXT4_I(inode)->i_disksize)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\n\t \n\tinode_dio_wait(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out_mutex;\n\n\t \n\tif (partial_begin || partial_end) {\n\t\tret = ext4_alloc_file_blocks(file,\n\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n\t\t\t\tnew_size, flags);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t \n\tif (max_blocks > 0) {\n\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\t\t  EXT4_EX_NOCACHE);\n\n\t\t \n\t\tfilemap_invalidate_lock(mapping);\n\n\t\tret = ext4_break_layouts(inode);\n\t\tif (ret) {\n\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tret = ext4_update_disksize_before_punch(inode, offset, len);\n\t\tif (ret) {\n\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\t \n\t\tif (ext4_should_journal_data(inode)) {\n\t\t\tret = filemap_write_and_wait_range(mapping, start, end);\n\t\t\tif (ret) {\n\t\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\t\tgoto out_mutex;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\n\t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,\n\t\t\t\t\t     flags);\n\t\tfilemap_invalidate_unlock(mapping);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\tif (!partial_begin && !partial_end)\n\t\tgoto out_mutex;\n\n\t \n\tcredits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;\n\tif (ext4_should_journal_data(inode))\n\t\tcredits += 2;\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(inode->i_sb, ret);\n\t\tgoto out_mutex;\n\t}\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tif (new_size)\n\t\text4_update_inode_size(inode, new_size);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\tif (unlikely(ret))\n\t\tgoto out_handle;\n\t \n\tret = ext4_zero_partial_blocks(handle, inode, offset, len);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\n\tif (file->f_flags & O_SYNC)\n\t\text4_handle_sync(handle);\n\nout_handle:\n\text4_journal_stop(handle);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\n \nlong ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t new_size = 0;\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint flags;\n\text4_lblk_t lblk;\n\tunsigned int blkbits = inode->i_blkbits;\n\n\t \n\tif (IS_ENCRYPTED(inode) &&\n\t    (mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |\n\t\t     FALLOC_FL_INSERT_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tret = ext4_convert_inline_data(inode);\n\tinode_unlock(inode);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tret = ext4_punch_hole(file, offset, len);\n\t\tgoto exit;\n\t}\n\n\tif (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tret = ext4_collapse_range(file, offset, len);\n\t\tgoto exit;\n\t}\n\n\tif (mode & FALLOC_FL_INSERT_RANGE) {\n\t\tret = ext4_insert_range(file, offset, len);\n\t\tgoto exit;\n\t}\n\n\tif (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tret = ext4_zero_range(file, offset, len, mode);\n\t\tgoto exit;\n\t}\n\ttrace_ext4_fallocate_enter(inode, offset, len, mode);\n\tlblk = offset >> blkbits;\n\n\tmax_blocks = EXT4_MAX_BLOCKS(len, offset, blkbits);\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\n\tinode_lock(inode);\n\n\t \n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    (offset + len > inode->i_size ||\n\t     offset + len > EXT4_I(inode)->i_disksize)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tinode_dio_wait(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tif (file->f_flags & O_SYNC && EXT4_SB(inode->i_sb)->s_journal) {\n\t\tret = ext4_fc_commit(EXT4_SB(inode->i_sb)->s_journal,\n\t\t\t\t\tEXT4_I(inode)->i_sync_tid);\n\t}\nout:\n\tinode_unlock(inode);\n\ttrace_ext4_fallocate_exit(inode, offset, max_blocks, ret);\nexit:\n\treturn ret;\n}\n\n \nint ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t   loff_t offset, ssize_t len)\n{\n\tunsigned int max_blocks;\n\tint ret = 0, ret2 = 0, ret3 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int blkbits = inode->i_blkbits;\n\tunsigned int credits = 0;\n\n\tmap.m_lblk = offset >> blkbits;\n\tmax_blocks = EXT4_MAX_BLOCKS(len, offset, blkbits);\n\n\tif (!handle) {\n\t\t \n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\tif (credits) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t\t    credits);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0)\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"inode #%lu: block %u: len %u: \"\n\t\t\t\t     \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t     inode->i_ino, map.m_lblk,\n\t\t\t\t     map.m_len, ret);\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (credits) {\n\t\t\tret3 = ext4_journal_stop(handle);\n\t\t\tif (unlikely(ret3))\n\t\t\t\tret2 = ret3;\n\t\t}\n\n\t\tif (ret <= 0 || ret2)\n\t\t\tbreak;\n\t}\n\treturn ret > 0 ? ret2 : ret;\n}\n\nint ext4_convert_unwritten_io_end_vec(handle_t *handle, ext4_io_end_t *io_end)\n{\n\tint ret = 0, err = 0;\n\tstruct ext4_io_end_vec *io_end_vec;\n\n\t \n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t}\n\n\tlist_for_each_entry(io_end_vec, &io_end->list_vec, list) {\n\t\tret = ext4_convert_unwritten_extents(handle, io_end->inode,\n\t\t\t\t\t\t     io_end_vec->offset,\n\t\t\t\t\t\t     io_end_vec->size);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (handle)\n\t\terr = ext4_journal_stop(handle);\n\n\treturn ret < 0 ? ret : err;\n}\n\nstatic int ext4_iomap_xattr_fiemap(struct inode *inode, struct iomap *iomap)\n{\n\t__u64 physical = 0;\n\t__u64 length = 0;\n\tint blockbits = inode->i_sb->s_blocksize_bits;\n\tint error = 0;\n\tu16 iomap_type;\n\n\t \n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\tstruct ext4_iloc iloc;\n\t\tint offset;\t \n\n\t\terror = ext4_get_inode_loc(inode, &iloc);\n\t\tif (error)\n\t\t\treturn error;\n\t\tphysical = (__u64)iloc.bh->b_blocknr << blockbits;\n\t\toffset = EXT4_GOOD_OLD_INODE_SIZE +\n\t\t\t\tEXT4_I(inode)->i_extra_isize;\n\t\tphysical += offset;\n\t\tlength = EXT4_SB(inode->i_sb)->s_inode_size - offset;\n\t\tbrelse(iloc.bh);\n\t\tiomap_type = IOMAP_INLINE;\n\t} else if (EXT4_I(inode)->i_file_acl) {  \n\t\tphysical = (__u64)EXT4_I(inode)->i_file_acl << blockbits;\n\t\tlength = inode->i_sb->s_blocksize;\n\t\tiomap_type = IOMAP_MAPPED;\n\t} else {\n\t\t \n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tiomap->addr = physical;\n\tiomap->offset = 0;\n\tiomap->length = length;\n\tiomap->type = iomap_type;\n\tiomap->flags = 0;\nout:\n\treturn error;\n}\n\nstatic int ext4_iomap_xattr_begin(struct inode *inode, loff_t offset,\n\t\t\t\t  loff_t length, unsigned flags,\n\t\t\t\t  struct iomap *iomap, struct iomap *srcmap)\n{\n\tint error;\n\n\terror = ext4_iomap_xattr_fiemap(inode, iomap);\n\tif (error == 0 && (offset >= iomap->length))\n\t\terror = -ENOENT;\n\treturn error;\n}\n\nstatic const struct iomap_ops ext4_iomap_xattr_ops = {\n\t.iomap_begin\t\t= ext4_iomap_xattr_begin,\n};\n\nstatic int ext4_fiemap_check_ranges(struct inode *inode, u64 start, u64 *len)\n{\n\tu64 maxbytes;\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\telse\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\n\tif (*len == 0)\n\t\treturn -EINVAL;\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t \n\tif (*len > maxbytes || (maxbytes - *len) < start)\n\t\t*len = maxbytes - start;\n\treturn 0;\n}\n\nint ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\tu64 start, u64 len)\n{\n\tint error = 0;\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_CACHE) {\n\t\terror = ext4_ext_precache(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_CACHE;\n\t}\n\n\t \n\terror = ext4_fiemap_check_ranges(inode, start, &len);\n\tif (error)\n\t\treturn error;\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_XATTR;\n\t\treturn iomap_fiemap(inode, fieinfo, start, len,\n\t\t\t\t    &ext4_iomap_xattr_ops);\n\t}\n\n\treturn iomap_fiemap(inode, fieinfo, start, len, &ext4_iomap_report_ops);\n}\n\nint ext4_get_es_cache(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t      __u64 start, __u64 len)\n{\n\text4_lblk_t start_blk, len_blks;\n\t__u64 last_blk;\n\tint error = 0;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline;\n\n\t\tdown_read(&EXT4_I(inode)->xattr_sem);\n\t\thas_inline = ext4_has_inline_data(inode);\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tif (has_inline)\n\t\t\treturn 0;\n\t}\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_CACHE) {\n\t\terror = ext4_ext_precache(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_CACHE;\n\t}\n\n\terror = fiemap_prep(inode, fieinfo, start, &len, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_fiemap_check_ranges(inode, start, &len);\n\tif (error)\n\t\treturn error;\n\n\tstart_blk = start >> inode->i_sb->s_blocksize_bits;\n\tlast_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;\n\tif (last_blk >= EXT_MAX_BLOCKS)\n\t\tlast_blk = EXT_MAX_BLOCKS-1;\n\tlen_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;\n\n\t \n\treturn ext4_fill_es_cache_info(inode, start_blk, len_blks, fieinfo);\n}\n\n \nstatic int\next4_ext_shift_path_extents(struct ext4_ext_path *path, ext4_lblk_t shift,\n\t\t\t    struct inode *inode, handle_t *handle,\n\t\t\t    enum SHIFT_DIRECTION SHIFT)\n{\n\tint depth, err = 0;\n\tstruct ext4_extent *ex_start, *ex_last;\n\tbool update = false;\n\tint credits, restart_credits;\n\tdepth = path->p_depth;\n\n\twhile (depth >= 0) {\n\t\tif (depth == path->p_depth) {\n\t\t\tex_start = path[depth].p_ext;\n\t\t\tif (!ex_start)\n\t\t\t\treturn -EFSCORRUPTED;\n\n\t\t\tex_last = EXT_LAST_EXTENT(path[depth].p_hdr);\n\t\t\t \n\t\t\tcredits = 3;\n\t\t\tif (ex_start == EXT_FIRST_EXTENT(path[depth].p_hdr)) {\n\t\t\t\tupdate = true;\n\t\t\t\t \n\t\t\t\tcredits = depth + 2;\n\t\t\t}\n\n\t\t\trestart_credits = ext4_writepage_trans_blocks(inode);\n\t\t\terr = ext4_datasem_ensure_credits(handle, inode, credits,\n\t\t\t\t\trestart_credits, 0);\n\t\t\tif (err) {\n\t\t\t\tif (err > 0)\n\t\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\twhile (ex_start <= ex_last) {\n\t\t\t\tif (SHIFT == SHIFT_LEFT) {\n\t\t\t\t\tle32_add_cpu(&ex_start->ee_block,\n\t\t\t\t\t\t-shift);\n\t\t\t\t\t \n\t\t\t\t\tif ((ex_start >\n\t\t\t\t\t    EXT_FIRST_EXTENT(path[depth].p_hdr))\n\t\t\t\t\t    &&\n\t\t\t\t\t    ext4_ext_try_to_merge_right(inode,\n\t\t\t\t\t    path, ex_start - 1))\n\t\t\t\t\t\tex_last--;\n\t\t\t\t\telse\n\t\t\t\t\t\tex_start++;\n\t\t\t\t} else {\n\t\t\t\t\tle32_add_cpu(&ex_last->ee_block, shift);\n\t\t\t\t\text4_ext_try_to_merge_right(inode, path,\n\t\t\t\t\t\tex_last);\n\t\t\t\t\tex_last--;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (--depth < 0 || !update)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (SHIFT == SHIFT_LEFT)\n\t\t\tle32_add_cpu(&path[depth].p_idx->ei_block, -shift);\n\t\telse\n\t\t\tle32_add_cpu(&path[depth].p_idx->ei_block, shift);\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (path[depth].p_idx != EXT_FIRST_INDEX(path[depth].p_hdr))\n\t\t\tbreak;\n\n\t\tdepth--;\n\t}\n\nout:\n\treturn err;\n}\n\n \nstatic int\next4_ext_shift_extents(struct inode *inode, handle_t *handle,\n\t\t       ext4_lblk_t start, ext4_lblk_t shift,\n\t\t       enum SHIFT_DIRECTION SHIFT)\n{\n\tstruct ext4_ext_path *path;\n\tint ret = 0, depth;\n\tstruct ext4_extent *extent;\n\text4_lblk_t stop, *iterator, ex_start, ex_end;\n\text4_lblk_t tmp = EXT_MAX_BLOCKS;\n\n\t \n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL,\n\t\t\t\tEXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tdepth = path->p_depth;\n\textent = path[depth].p_ext;\n\tif (!extent)\n\t\tgoto out;\n\n\tstop = le32_to_cpu(extent->ee_block);\n\n        \n\tif (SHIFT == SHIFT_LEFT) {\n\t\tpath = ext4_find_extent(inode, start - 1, &path,\n\t\t\t\t\tEXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = path->p_depth;\n\t\textent =  path[depth].p_ext;\n\t\tif (extent) {\n\t\t\tex_start = le32_to_cpu(extent->ee_block);\n\t\t\tex_end = le32_to_cpu(extent->ee_block) +\n\t\t\t\text4_ext_get_actual_len(extent);\n\t\t} else {\n\t\t\tex_start = 0;\n\t\t\tex_end = 0;\n\t\t}\n\n\t\tif ((start == ex_start && shift > ex_start) ||\n\t\t    (shift > start - ex_end)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (shift > EXT_MAX_BLOCKS -\n\t\t    (stop + ext4_ext_get_actual_len(extent))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \nagain:\n\tret = 0;\n\tif (SHIFT == SHIFT_LEFT)\n\t\titerator = &start;\n\telse\n\t\titerator = &stop;\n\n\tif (tmp != EXT_MAX_BLOCKS)\n\t\t*iterator = tmp;\n\n\t \n\twhile (iterator && start <= stop) {\n\t\tpath = ext4_find_extent(inode, *iterator, &path,\n\t\t\t\t\tEXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = path->p_depth;\n\t\textent = path[depth].p_ext;\n\t\tif (!extent) {\n\t\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t\t (unsigned long) *iterator);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (SHIFT == SHIFT_LEFT && *iterator >\n\t\t    le32_to_cpu(extent->ee_block)) {\n\t\t\t \n\t\t\tif (extent < EXT_LAST_EXTENT(path[depth].p_hdr)) {\n\t\t\t\tpath[depth].p_ext++;\n\t\t\t} else {\n\t\t\t\t*iterator = ext4_ext_next_allocated_block(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ttmp = *iterator;\n\t\tif (SHIFT == SHIFT_LEFT) {\n\t\t\textent = EXT_LAST_EXTENT(path[depth].p_hdr);\n\t\t\t*iterator = le32_to_cpu(extent->ee_block) +\n\t\t\t\t\text4_ext_get_actual_len(extent);\n\t\t} else {\n\t\t\textent = EXT_FIRST_EXTENT(path[depth].p_hdr);\n\t\t\tif (le32_to_cpu(extent->ee_block) > start)\n\t\t\t\t*iterator = le32_to_cpu(extent->ee_block) - 1;\n\t\t\telse if (le32_to_cpu(extent->ee_block) == start)\n\t\t\t\titerator = NULL;\n\t\t\telse {\n\t\t\t\textent = EXT_LAST_EXTENT(path[depth].p_hdr);\n\t\t\t\twhile (le32_to_cpu(extent->ee_block) >= start)\n\t\t\t\t\textent--;\n\n\t\t\t\tif (extent == EXT_LAST_EXTENT(path[depth].p_hdr))\n\t\t\t\t\tbreak;\n\n\t\t\t\textent++;\n\t\t\t\titerator = NULL;\n\t\t\t}\n\t\t\tpath[depth].p_ext = extent;\n\t\t}\n\t\tret = ext4_ext_shift_path_extents(path, shift, inode,\n\t\t\t\thandle, SHIFT);\n\t\t \n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\text4_free_ext_path(path);\n\treturn ret;\n}\n\n \nstatic int ext4_collapse_range(struct file *file, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\text4_lblk_t punch_start, punch_stop;\n\thandle_t *handle;\n\tunsigned int credits;\n\tloff_t new_size, ioffset;\n\tint ret;\n\n\t \n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!IS_ALIGNED(offset | len, EXT4_CLUSTER_SIZE(sb)))\n\t\treturn -EINVAL;\n\n\ttrace_ext4_collapse_range(inode, offset, len);\n\n\tpunch_start = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tpunch_stop = (offset + len) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\tinode_lock(inode);\n\t \n\tif (offset + len >= inode->i_size) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t \n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t \n\tinode_dio_wait(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out_mutex;\n\n\t \n\tfilemap_invalidate_lock(mapping);\n\n\tret = ext4_break_layouts(inode);\n\tif (ret)\n\t\tgoto out_mmap;\n\n\t \n\tioffset = round_down(offset, PAGE_SIZE);\n\t \n\tret = filemap_write_and_wait_range(mapping, ioffset, offset);\n\tif (ret)\n\t\tgoto out_mmap;\n\t \n\tret = filemap_write_and_wait_range(mapping, offset + len,\n\t\t\t\t\t   LLONG_MAX);\n\tif (ret)\n\t\tgoto out_mmap;\n\ttruncate_pagecache(inode, ioffset);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_mmap;\n\t}\n\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_FALLOC_RANGE, handle);\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode, 0);\n\text4_es_remove_extent(inode, punch_start, EXT_MAX_BLOCKS - punch_start);\n\n\tret = ext4_ext_remove_space(inode, punch_start, punch_stop - 1);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\text4_discard_preallocations(inode, 0);\n\n\tret = ext4_ext_shift_extents(inode, handle, punch_stop,\n\t\t\t\t     punch_stop - punch_start, SHIFT_LEFT);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tnew_size = inode->i_size - len;\n\ti_size_write(inode, new_size);\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\nout_stop:\n\text4_journal_stop(handle);\nout_mmap:\n\tfilemap_invalidate_unlock(mapping);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\n \nstatic int ext4_insert_range(struct file *file, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *extent;\n\text4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;\n\tunsigned int credits, ee_len;\n\tint ret = 0, depth, split_flag = 0;\n\tloff_t ioffset;\n\n\t \n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!IS_ALIGNED(offset | len, EXT4_CLUSTER_SIZE(sb)))\n\t\treturn -EINVAL;\n\n\ttrace_ext4_insert_range(inode, offset, len);\n\n\toffset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tlen_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\tinode_lock(inode);\n\t \n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t \n\tif (len > inode->i_sb->s_maxbytes - inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_mutex;\n\t}\n\n\t \n\tif (offset >= inode->i_size) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t \n\tinode_dio_wait(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out_mutex;\n\n\t \n\tfilemap_invalidate_lock(mapping);\n\n\tret = ext4_break_layouts(inode);\n\tif (ret)\n\t\tgoto out_mmap;\n\n\t \n\tioffset = round_down(offset, PAGE_SIZE);\n\t \n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\tLLONG_MAX);\n\tif (ret)\n\t\tgoto out_mmap;\n\ttruncate_pagecache(inode, ioffset);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_mmap;\n\t}\n\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_FALLOC_RANGE, handle);\n\n\t \n\tinode->i_size += len;\n\tEXT4_I(inode)->i_disksize += len;\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode, 0);\n\n\tpath = ext4_find_extent(inode, offset_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tdepth = ext_depth(inode);\n\textent = path[depth].p_ext;\n\tif (extent) {\n\t\tee_start_lblk = le32_to_cpu(extent->ee_block);\n\t\tee_len = ext4_ext_get_actual_len(extent);\n\n\t\t \n\t\tif ((offset_lblk > ee_start_lblk) &&\n\t\t\t\t(offset_lblk < (ee_start_lblk + ee_len))) {\n\t\t\tif (ext4_ext_is_unwritten(extent))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t\t\tEXT4_EXT_MARK_UNWRIT2;\n\t\t\tret = ext4_split_extent_at(handle, inode, &path,\n\t\t\t\t\toffset_lblk, split_flag,\n\t\t\t\t\tEXT4_EX_NOCACHE |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\tEXT4_GET_BLOCKS_METADATA_NOFAIL);\n\t\t}\n\n\t\text4_free_ext_path(path);\n\t\tif (ret < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto out_stop;\n\t\t}\n\t} else {\n\t\text4_free_ext_path(path);\n\t}\n\n\text4_es_remove_extent(inode, offset_lblk, EXT_MAX_BLOCKS - offset_lblk);\n\n\t \n\tret = ext4_ext_shift_extents(inode, handle,\n\t\tmax(ee_start_lblk, offset_lblk), len_lblk, SHIFT_RIGHT);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\nout_stop:\n\text4_journal_stop(handle);\nout_mmap:\n\tfilemap_invalidate_unlock(mapping);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\n \nint\next4_swap_extents(handle_t *handle, struct inode *inode1,\n\t\t  struct inode *inode2, ext4_lblk_t lblk1, ext4_lblk_t lblk2,\n\t\t  ext4_lblk_t count, int unwritten, int *erp)\n{\n\tstruct ext4_ext_path *path1 = NULL;\n\tstruct ext4_ext_path *path2 = NULL;\n\tint replaced_count = 0;\n\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode1)->i_data_sem));\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode2)->i_data_sem));\n\tBUG_ON(!inode_is_locked(inode1));\n\tBUG_ON(!inode_is_locked(inode2));\n\n\text4_es_remove_extent(inode1, lblk1, count);\n\text4_es_remove_extent(inode2, lblk2, count);\n\n\twhile (count) {\n\t\tstruct ext4_extent *ex1, *ex2, tmp_ex;\n\t\text4_lblk_t e1_blk, e2_blk;\n\t\tint e1_len, e2_len, len;\n\t\tint split = 0;\n\n\t\tpath1 = ext4_find_extent(inode1, lblk1, NULL, EXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path1)) {\n\t\t\t*erp = PTR_ERR(path1);\n\t\t\tpath1 = NULL;\n\t\tfinish:\n\t\t\tcount = 0;\n\t\t\tgoto repeat;\n\t\t}\n\t\tpath2 = ext4_find_extent(inode2, lblk2, NULL, EXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path2)) {\n\t\t\t*erp = PTR_ERR(path2);\n\t\t\tpath2 = NULL;\n\t\t\tgoto finish;\n\t\t}\n\t\tex1 = path1[path1->p_depth].p_ext;\n\t\tex2 = path2[path2->p_depth].p_ext;\n\t\t \n\t\tif (unlikely(!ex2 || !ex1))\n\t\t\tgoto finish;\n\n\t\te1_blk = le32_to_cpu(ex1->ee_block);\n\t\te2_blk = le32_to_cpu(ex2->ee_block);\n\t\te1_len = ext4_ext_get_actual_len(ex1);\n\t\te2_len = ext4_ext_get_actual_len(ex2);\n\n\t\t \n\t\tif (!in_range(lblk1, e1_blk, e1_len) ||\n\t\t    !in_range(lblk2, e2_blk, e2_len)) {\n\t\t\text4_lblk_t next1, next2;\n\n\t\t\t \n\t\t\tnext1 = ext4_ext_next_allocated_block(path1);\n\t\t\tnext2 = ext4_ext_next_allocated_block(path2);\n\t\t\t \n\t\t\tif (e1_blk > lblk1)\n\t\t\t\tnext1 = e1_blk;\n\t\t\tif (e2_blk > lblk2)\n\t\t\t\tnext2 = e2_blk;\n\t\t\t \n\t\t\tif (next1 == EXT_MAX_BLOCKS || next2 == EXT_MAX_BLOCKS)\n\t\t\t\tgoto finish;\n\t\t\t \n\t\t\tlen = next1 - lblk1;\n\t\t\tif (len < next2 - lblk2)\n\t\t\t\tlen = next2 - lblk2;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\t\t\tlblk1 += len;\n\t\t\tlblk2 += len;\n\t\t\tcount -= len;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t \n\t\tif (e1_blk < lblk1) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (e2_blk < lblk2) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2,  lblk2, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\t \n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\t \n\t\tlen = count;\n\t\tif (len > e1_blk + e1_len - lblk1)\n\t\t\tlen = e1_blk + e1_len - lblk1;\n\t\tif (len > e2_blk + e2_len - lblk2)\n\t\t\tlen = e2_blk + e2_len - lblk2;\n\n\t\tif (len != e1_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode1,\n\t\t\t\t\t\t&path1, lblk1 + len, 0);\n\t\t\tif (unlikely(*erp))\n\t\t\t\tgoto finish;\n\t\t}\n\t\tif (len != e2_len) {\n\t\t\tsplit = 1;\n\t\t\t*erp = ext4_force_split_extent_at(handle, inode2,\n\t\t\t\t\t\t&path2, lblk2 + len, 0);\n\t\t\tif (*erp)\n\t\t\t\tgoto finish;\n\t\t}\n\t\t \n\t\tif (split)\n\t\t\tgoto repeat;\n\n\t\tBUG_ON(e2_len != e1_len);\n\t\t*erp = ext4_ext_get_access(handle, inode1, path1 + path1->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_get_access(handle, inode2, path2 + path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\n\t\t \n\t\ttmp_ex = *ex1;\n\t\text4_ext_store_pblock(ex1, ext4_ext_pblock(ex2));\n\t\text4_ext_store_pblock(ex2, ext4_ext_pblock(&tmp_ex));\n\t\tex1->ee_len = cpu_to_le16(e2_len);\n\t\tex2->ee_len = cpu_to_le16(e1_len);\n\t\tif (unwritten)\n\t\t\text4_ext_mark_unwritten(ex2);\n\t\tif (ext4_ext_is_unwritten(&tmp_ex))\n\t\t\text4_ext_mark_unwritten(ex1);\n\n\t\text4_ext_try_to_merge(handle, inode2, path2, ex2);\n\t\text4_ext_try_to_merge(handle, inode1, path1, ex1);\n\t\t*erp = ext4_ext_dirty(handle, inode2, path2 +\n\t\t\t\t      path2->p_depth);\n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\t*erp = ext4_ext_dirty(handle, inode1, path1 +\n\t\t\t\t      path1->p_depth);\n\t\t \n\t\tif (unlikely(*erp))\n\t\t\tgoto finish;\n\t\tlblk1 += len;\n\t\tlblk2 += len;\n\t\treplaced_count += len;\n\t\tcount -= len;\n\n\trepeat:\n\t\text4_free_ext_path(path1);\n\t\text4_free_ext_path(path2);\n\t\tpath1 = path2 = NULL;\n\t}\n\treturn replaced_count;\n}\n\n \nint ext4_clu_mapped(struct inode *inode, ext4_lblk_t lclu)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_ext_path *path;\n\tint depth, mapped = 0, err = 0;\n\tstruct ext4_extent *extent;\n\text4_lblk_t first_lblk, first_lclu, last_lclu;\n\n\t \n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA) ||\n\t    ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\t \n\tpath = ext4_find_extent(inode, EXT4_C2B(sbi, lclu), NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t \n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t    \"bad extent address - lblock: %lu, depth: %d, pblock: %lld\",\n\t\t\t\t (unsigned long) EXT4_C2B(sbi, lclu),\n\t\t\t\t depth, path[depth].p_block);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\textent = path[depth].p_ext;\n\n\t \n\tif (extent == NULL)\n\t\tgoto out;\n\n\tfirst_lblk = le32_to_cpu(extent->ee_block);\n\tfirst_lclu = EXT4_B2C(sbi, first_lblk);\n\n\t \n\tif (lclu >= first_lclu) {\n\t\tlast_lclu = EXT4_B2C(sbi, first_lblk +\n\t\t\t\t     ext4_ext_get_actual_len(extent) - 1);\n\t\tif (lclu <= last_lclu) {\n\t\t\tmapped = 1;\n\t\t} else {\n\t\t\tfirst_lblk = ext4_ext_next_allocated_block(path);\n\t\t\tfirst_lclu = EXT4_B2C(sbi, first_lblk);\n\t\t\tif (lclu == first_lclu)\n\t\t\t\tmapped = 1;\n\t\t}\n\t}\n\nout:\n\text4_free_ext_path(path);\n\n\treturn err ? err : mapped;\n}\n\n \nint ext4_ext_replay_update_ex(struct inode *inode, ext4_lblk_t start,\n\t\t\t      int len, int unwritten, ext4_fsblk_t pblk)\n{\n\tstruct ext4_ext_path *path = NULL, *ppath;\n\tstruct ext4_extent *ex;\n\tint ret;\n\n\tpath = ext4_find_extent(inode, start, NULL, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tex = path[path->p_depth].p_ext;\n\tif (!ex) {\n\t\tret = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(ex->ee_block) != start ||\n\t\text4_ext_get_actual_len(ex) != len) {\n\t\t \n\t\tppath = path;\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\tret = ext4_force_split_extent_at(NULL, inode, &ppath, start, 1);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tkfree(path);\n\t\tpath = ext4_find_extent(inode, start, NULL, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn -1;\n\t\tppath = path;\n\t\tex = path[path->p_depth].p_ext;\n\t\tWARN_ON(le32_to_cpu(ex->ee_block) != start);\n\t\tif (ext4_ext_get_actual_len(ex) != len) {\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tret = ext4_force_split_extent_at(NULL, inode, &ppath,\n\t\t\t\t\t\t\t start + len, 1);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tkfree(path);\n\t\t\tpath = ext4_find_extent(inode, start, NULL, 0);\n\t\t\tif (IS_ERR(path))\n\t\t\t\treturn -EINVAL;\n\t\t\tex = path[path->p_depth].p_ext;\n\t\t}\n\t}\n\tif (unwritten)\n\t\text4_ext_mark_unwritten(ex);\n\telse\n\t\text4_ext_mark_initialized(ex);\n\text4_ext_store_pblock(ex, pblk);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_dirty(NULL, inode, &path[path->p_depth]);\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\text4_free_ext_path(path);\n\text4_mark_inode_dirty(NULL, inode);\n\treturn ret;\n}\n\n \nvoid ext4_ext_replay_shrink_inode(struct inode *inode, ext4_lblk_t end)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t old_cur, cur = 0;\n\n\twhile (cur < end) {\n\t\tpath = ext4_find_extent(inode, cur, NULL, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn;\n\t\tex = path[path->p_depth].p_ext;\n\t\tif (!ex) {\n\t\t\text4_free_ext_path(path);\n\t\t\text4_mark_inode_dirty(NULL, inode);\n\t\t\treturn;\n\t\t}\n\t\told_cur = cur;\n\t\tcur = le32_to_cpu(ex->ee_block) + ext4_ext_get_actual_len(ex);\n\t\tif (cur <= old_cur)\n\t\t\tcur = old_cur + 1;\n\t\text4_ext_try_to_merge(NULL, inode, path, ex);\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_ext_dirty(NULL, inode, &path[path->p_depth]);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_mark_inode_dirty(NULL, inode);\n\t\text4_free_ext_path(path);\n\t}\n}\n\n \nstatic int skip_hole(struct inode *inode, ext4_lblk_t *cur)\n{\n\tint ret;\n\tstruct ext4_map_blocks map;\n\n\tmap.m_lblk = *cur;\n\tmap.m_len = ((inode->i_size) >> inode->i_sb->s_blocksize_bits) - *cur;\n\n\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 0)\n\t\treturn 0;\n\t*cur = *cur + map.m_len;\n\treturn 0;\n}\n\n \nint ext4_ext_replay_set_iblocks(struct inode *inode)\n{\n\tstruct ext4_ext_path *path = NULL, *path2 = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t cur = 0, end;\n\tint numblks = 0, i, ret = 0;\n\text4_fsblk_t cmp1, cmp2;\n\tstruct ext4_map_blocks map;\n\n\t \n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tex = path[path->p_depth].p_ext;\n\tif (!ex) {\n\t\text4_free_ext_path(path);\n\t\tgoto out;\n\t}\n\tend = le32_to_cpu(ex->ee_block) + ext4_ext_get_actual_len(ex);\n\text4_free_ext_path(path);\n\n\t \n\tcur = 0;\n\twhile (cur < end) {\n\t\tmap.m_lblk = cur;\n\t\tmap.m_len = end - cur;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0)\n\t\t\tnumblks += ret;\n\t\tcur = cur + map.m_len;\n\t}\n\n\t \n\tcur = 0;\n\tret = skip_hole(inode, &cur);\n\tif (ret < 0)\n\t\tgoto out;\n\tpath = ext4_find_extent(inode, cur, NULL, 0);\n\tif (IS_ERR(path))\n\t\tgoto out;\n\tnumblks += path->p_depth;\n\text4_free_ext_path(path);\n\twhile (cur < end) {\n\t\tpath = ext4_find_extent(inode, cur, NULL, 0);\n\t\tif (IS_ERR(path))\n\t\t\tbreak;\n\t\tex = path[path->p_depth].p_ext;\n\t\tif (!ex) {\n\t\t\text4_free_ext_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tcur = max(cur + 1, le32_to_cpu(ex->ee_block) +\n\t\t\t\t\text4_ext_get_actual_len(ex));\n\t\tret = skip_hole(inode, &cur);\n\t\tif (ret < 0) {\n\t\t\text4_free_ext_path(path);\n\t\t\tbreak;\n\t\t}\n\t\tpath2 = ext4_find_extent(inode, cur, NULL, 0);\n\t\tif (IS_ERR(path2)) {\n\t\t\text4_free_ext_path(path);\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i <= max(path->p_depth, path2->p_depth); i++) {\n\t\t\tcmp1 = cmp2 = 0;\n\t\t\tif (i <= path->p_depth)\n\t\t\t\tcmp1 = path[i].p_bh ?\n\t\t\t\t\tpath[i].p_bh->b_blocknr : 0;\n\t\t\tif (i <= path2->p_depth)\n\t\t\t\tcmp2 = path2[i].p_bh ?\n\t\t\t\t\tpath2[i].p_bh->b_blocknr : 0;\n\t\t\tif (cmp1 != cmp2 && cmp2 != 0)\n\t\t\t\tnumblks++;\n\t\t}\n\t\text4_free_ext_path(path);\n\t\text4_free_ext_path(path2);\n\t}\n\nout:\n\tinode->i_blocks = numblks << (inode->i_sb->s_blocksize_bits - 9);\n\text4_mark_inode_dirty(NULL, inode);\n\treturn 0;\n}\n\nint ext4_ext_clear_bb(struct inode *inode)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t cur = 0, end;\n\tint j, ret = 0;\n\tstruct ext4_map_blocks map;\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA))\n\t\treturn 0;\n\n\t \n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tex = path[path->p_depth].p_ext;\n\tif (!ex) {\n\t\text4_free_ext_path(path);\n\t\treturn 0;\n\t}\n\tend = le32_to_cpu(ex->ee_block) + ext4_ext_get_actual_len(ex);\n\text4_free_ext_path(path);\n\n\tcur = 0;\n\twhile (cur < end) {\n\t\tmap.m_lblk = cur;\n\t\tmap.m_len = end - cur;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tpath = ext4_find_extent(inode, map.m_lblk, NULL, 0);\n\t\t\tif (!IS_ERR_OR_NULL(path)) {\n\t\t\t\tfor (j = 0; j < path->p_depth; j++) {\n\n\t\t\t\t\text4_mb_mark_bb(inode->i_sb,\n\t\t\t\t\t\t\tpath[j].p_block, 1, 0);\n\t\t\t\t\text4_fc_record_regions(inode->i_sb, inode->i_ino,\n\t\t\t\t\t\t\t0, path[j].p_block, 1, 1);\n\t\t\t\t}\n\t\t\t\text4_free_ext_path(path);\n\t\t\t}\n\t\t\text4_mb_mark_bb(inode->i_sb, map.m_pblk, map.m_len, 0);\n\t\t\text4_fc_record_regions(inode->i_sb, inode->i_ino,\n\t\t\t\t\tmap.m_lblk, map.m_pblk, map.m_len, 1);\n\t\t}\n\t\tcur = cur + map.m_len;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}