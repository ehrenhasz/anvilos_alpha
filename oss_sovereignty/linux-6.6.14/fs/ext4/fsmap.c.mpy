{
  "module_name": "fsmap.c",
  "hash_id": "b568bf5f4f686042fb75a5539e4f800d4426bdf1f1a437889370f63ee66e0af6",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/fsmap.c",
  "human_readable_source": "\n \n#include \"ext4.h\"\n#include <linux/fsmap.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include <linux/sort.h>\n#include <linux/list_sort.h>\n#include <trace/events/ext4.h>\n\n \nvoid ext4_fsmap_from_internal(struct super_block *sb, struct fsmap *dest,\n\t\t\t      struct ext4_fsmap *src)\n{\n\tdest->fmr_device = src->fmr_device;\n\tdest->fmr_flags = src->fmr_flags;\n\tdest->fmr_physical = src->fmr_physical << sb->s_blocksize_bits;\n\tdest->fmr_owner = src->fmr_owner;\n\tdest->fmr_offset = 0;\n\tdest->fmr_length = src->fmr_length << sb->s_blocksize_bits;\n\tdest->fmr_reserved[0] = 0;\n\tdest->fmr_reserved[1] = 0;\n\tdest->fmr_reserved[2] = 0;\n}\n\n \nvoid ext4_fsmap_to_internal(struct super_block *sb, struct ext4_fsmap *dest,\n\t\t\t    struct fsmap *src)\n{\n\tdest->fmr_device = src->fmr_device;\n\tdest->fmr_flags = src->fmr_flags;\n\tdest->fmr_physical = src->fmr_physical >> sb->s_blocksize_bits;\n\tdest->fmr_owner = src->fmr_owner;\n\tdest->fmr_length = src->fmr_length >> sb->s_blocksize_bits;\n}\n\n \nstruct ext4_getfsmap_info {\n\tstruct ext4_fsmap_head\t*gfi_head;\n\text4_fsmap_format_t\tgfi_formatter;\t \n\tvoid\t\t\t*gfi_format_arg; \n\text4_fsblk_t\t\tgfi_next_fsblk;\t \n\tu32\t\t\tgfi_dev;\t \n\text4_group_t\t\tgfi_agno;\t \n\tstruct ext4_fsmap\tgfi_low;\t \n\tstruct ext4_fsmap\tgfi_high;\t \n\tstruct ext4_fsmap\tgfi_lastfree;\t \n\tstruct list_head\tgfi_meta_list;\t \n\tbool\t\t\tgfi_last;\t \n};\n\n \nstruct ext4_getfsmap_dev {\n\tint\t\t\t(*gfd_fn)(struct super_block *sb,\n\t\t\t\t      struct ext4_fsmap *keys,\n\t\t\t\t      struct ext4_getfsmap_info *info);\n\tu32\t\t\tgfd_dev;\n};\n\n \nstatic int ext4_getfsmap_dev_compare(const void *p1, const void *p2)\n{\n\tconst struct ext4_getfsmap_dev *d1 = p1;\n\tconst struct ext4_getfsmap_dev *d2 = p2;\n\n\treturn d1->gfd_dev - d2->gfd_dev;\n}\n\n \nstatic bool ext4_getfsmap_rec_before_low_key(struct ext4_getfsmap_info *info,\n\t\t\t\t\t     struct ext4_fsmap *rec)\n{\n\treturn rec->fmr_physical < info->gfi_low.fmr_physical;\n}\n\n \nstatic int ext4_getfsmap_helper(struct super_block *sb,\n\t\t\t\tstruct ext4_getfsmap_info *info,\n\t\t\t\tstruct ext4_fsmap *rec)\n{\n\tstruct ext4_fsmap fmr;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t rec_fsblk = rec->fmr_physical;\n\text4_group_t agno;\n\text4_grpblk_t cno;\n\tint error;\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\t \n\tif (ext4_getfsmap_rec_before_low_key(info, rec)) {\n\t\trec_fsblk += rec->fmr_length;\n\t\tif (info->gfi_next_fsblk < rec_fsblk)\n\t\t\tinfo->gfi_next_fsblk = rec_fsblk;\n\t\treturn EXT4_QUERY_RANGE_CONTINUE;\n\t}\n\n\t \n\tif (info->gfi_head->fmh_count == 0) {\n\t\tif (info->gfi_head->fmh_entries == UINT_MAX)\n\t\t\treturn EXT4_QUERY_RANGE_ABORT;\n\n\t\tif (rec_fsblk > info->gfi_next_fsblk)\n\t\t\tinfo->gfi_head->fmh_entries++;\n\n\t\tif (info->gfi_last)\n\t\t\treturn EXT4_QUERY_RANGE_CONTINUE;\n\n\t\tinfo->gfi_head->fmh_entries++;\n\n\t\trec_fsblk += rec->fmr_length;\n\t\tif (info->gfi_next_fsblk < rec_fsblk)\n\t\t\tinfo->gfi_next_fsblk = rec_fsblk;\n\t\treturn EXT4_QUERY_RANGE_CONTINUE;\n\t}\n\n\t \n\tif (rec_fsblk > info->gfi_next_fsblk) {\n\t\tif (info->gfi_head->fmh_entries >= info->gfi_head->fmh_count)\n\t\t\treturn EXT4_QUERY_RANGE_ABORT;\n\n\t\text4_get_group_no_and_offset(sb, info->gfi_next_fsblk,\n\t\t\t\t&agno, &cno);\n\t\ttrace_ext4_fsmap_mapping(sb, info->gfi_dev, agno,\n\t\t\t\tEXT4_C2B(sbi, cno),\n\t\t\t\trec_fsblk - info->gfi_next_fsblk,\n\t\t\t\tEXT4_FMR_OWN_UNKNOWN);\n\n\t\tfmr.fmr_device = info->gfi_dev;\n\t\tfmr.fmr_physical = info->gfi_next_fsblk;\n\t\tfmr.fmr_owner = EXT4_FMR_OWN_UNKNOWN;\n\t\tfmr.fmr_length = rec_fsblk - info->gfi_next_fsblk;\n\t\tfmr.fmr_flags = FMR_OF_SPECIAL_OWNER;\n\t\terror = info->gfi_formatter(&fmr, info->gfi_format_arg);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo->gfi_head->fmh_entries++;\n\t}\n\n\tif (info->gfi_last)\n\t\tgoto out;\n\n\t \n\tif (info->gfi_head->fmh_entries >= info->gfi_head->fmh_count)\n\t\treturn EXT4_QUERY_RANGE_ABORT;\n\n\text4_get_group_no_and_offset(sb, rec_fsblk, &agno, &cno);\n\ttrace_ext4_fsmap_mapping(sb, info->gfi_dev, agno, EXT4_C2B(sbi, cno),\n\t\t\trec->fmr_length, rec->fmr_owner);\n\n\tfmr.fmr_device = info->gfi_dev;\n\tfmr.fmr_physical = rec_fsblk;\n\tfmr.fmr_owner = rec->fmr_owner;\n\tfmr.fmr_flags = FMR_OF_SPECIAL_OWNER;\n\tfmr.fmr_length = rec->fmr_length;\n\terror = info->gfi_formatter(&fmr, info->gfi_format_arg);\n\tif (error)\n\t\treturn error;\n\tinfo->gfi_head->fmh_entries++;\n\nout:\n\trec_fsblk += rec->fmr_length;\n\tif (info->gfi_next_fsblk < rec_fsblk)\n\t\tinfo->gfi_next_fsblk = rec_fsblk;\n\treturn EXT4_QUERY_RANGE_CONTINUE;\n}\n\nstatic inline ext4_fsblk_t ext4_fsmap_next_pblk(struct ext4_fsmap *fmr)\n{\n\treturn fmr->fmr_physical + fmr->fmr_length;\n}\n\n \nstatic int ext4_getfsmap_datadev_helper(struct super_block *sb,\n\t\t\t\t\text4_group_t agno, ext4_grpblk_t start,\n\t\t\t\t\text4_grpblk_t len, void *priv)\n{\n\tstruct ext4_fsmap irec;\n\tstruct ext4_getfsmap_info *info = priv;\n\tstruct ext4_fsmap *p;\n\tstruct ext4_fsmap *tmp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t fsb;\n\text4_fsblk_t fslen;\n\tint error;\n\n\tfsb = (EXT4_C2B(sbi, start) + ext4_group_first_block_no(sb, agno));\n\tfslen = EXT4_C2B(sbi, len);\n\n\t \n\tif (info->gfi_lastfree.fmr_owner) {\n\t\t \n\t\tif (ext4_fsmap_next_pblk(&info->gfi_lastfree) == fsb) {\n\t\t\tinfo->gfi_lastfree.fmr_length += fslen;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\terror = ext4_getfsmap_helper(sb, info, &info->gfi_lastfree);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo->gfi_lastfree.fmr_owner = 0;\n\t}\n\n\t \n\tlist_for_each_entry_safe(p, tmp, &info->gfi_meta_list, fmr_list) {\n\t\tif (p->fmr_physical + p->fmr_length <= info->gfi_next_fsblk) {\n\t\t\tlist_del(&p->fmr_list);\n\t\t\tkfree(p);\n\t\t} else if (p->fmr_physical < fsb) {\n\t\t\terror = ext4_getfsmap_helper(sb, info, p);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tlist_del(&p->fmr_list);\n\t\t\tkfree(p);\n\t\t}\n\t}\n\n\tirec.fmr_device = 0;\n\tirec.fmr_physical = fsb;\n\tirec.fmr_length = fslen;\n\tirec.fmr_owner = EXT4_FMR_OWN_FREE;\n\tirec.fmr_flags = 0;\n\n\t \n\tif (ext4_fsmap_next_pblk(&irec) ==\n\t\t\text4_group_first_block_no(sb, agno + 1)) {\n\t\tinfo->gfi_lastfree = irec;\n\t\treturn 0;\n\t}\n\n\t \n\treturn ext4_getfsmap_helper(sb, info, &irec);\n}\n\n \nstatic int ext4_getfsmap_logdev(struct super_block *sb, struct ext4_fsmap *keys,\n\t\t\t\tstruct ext4_getfsmap_info *info)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tstruct ext4_fsmap irec;\n\n\t \n\tinfo->gfi_low = keys[0];\n\tinfo->gfi_low.fmr_length = 0;\n\n\tmemset(&info->gfi_high, 0xFF, sizeof(info->gfi_high));\n\n\ttrace_ext4_fsmap_low_key(sb, info->gfi_dev, 0,\n\t\t\tinfo->gfi_low.fmr_physical,\n\t\t\tinfo->gfi_low.fmr_length,\n\t\t\tinfo->gfi_low.fmr_owner);\n\n\ttrace_ext4_fsmap_high_key(sb, info->gfi_dev, 0,\n\t\t\tinfo->gfi_high.fmr_physical,\n\t\t\tinfo->gfi_high.fmr_length,\n\t\t\tinfo->gfi_high.fmr_owner);\n\n\tif (keys[0].fmr_physical > 0)\n\t\treturn 0;\n\n\t \n\tirec.fmr_physical = journal->j_blk_offset;\n\tirec.fmr_length = journal->j_total_len;\n\tirec.fmr_owner = EXT4_FMR_OWN_LOG;\n\tirec.fmr_flags = 0;\n\n\treturn ext4_getfsmap_helper(sb, info, &irec);\n}\n\n \nstatic inline int ext4_getfsmap_fill(struct list_head *meta_list,\n\t\t\t\t     ext4_fsblk_t fsb, ext4_fsblk_t len,\n\t\t\t\t     uint64_t owner)\n{\n\tstruct ext4_fsmap *fsm;\n\n\tfsm = kmalloc(sizeof(*fsm), GFP_NOFS);\n\tif (!fsm)\n\t\treturn -ENOMEM;\n\tfsm->fmr_device = 0;\n\tfsm->fmr_flags = 0;\n\tfsm->fmr_physical = fsb;\n\tfsm->fmr_owner = owner;\n\tfsm->fmr_length = len;\n\tlist_add_tail(&fsm->fmr_list, meta_list);\n\n\treturn 0;\n}\n\n \nstatic unsigned int ext4_getfsmap_find_sb(struct super_block *sb,\n\t\t\t\t\t  ext4_group_t agno,\n\t\t\t\t\t  struct list_head *meta_list)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t fsb = ext4_group_first_block_no(sb, agno);\n\text4_fsblk_t len;\n\tunsigned long first_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\tunsigned long metagroup = agno / EXT4_DESC_PER_BLOCK(sb);\n\tint error;\n\n\t \n\tif (ext4_bg_has_super(sb, agno)) {\n\t\terror = ext4_getfsmap_fill(meta_list, fsb, 1, EXT4_FMR_OWN_FS);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfsb++;\n\t}\n\n\t \n\tlen = ext4_bg_num_gdb(sb, agno);\n\tif (!len)\n\t\treturn 0;\n\terror = ext4_getfsmap_fill(meta_list, fsb, len,\n\t\t\t\t   EXT4_FMR_OWN_GDT);\n\tif (error)\n\t\treturn error;\n\tfsb += len;\n\n\t \n\tif (!ext4_has_feature_meta_bg(sb) || metagroup < first_meta_bg) {\n\t\tlen = le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks);\n\t\terror = ext4_getfsmap_fill(meta_list, fsb, len,\n\t\t\t\t\t   EXT4_FMR_OWN_RESV_GDT);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ext4_getfsmap_compare(void *priv,\n\t\t\t\t const struct list_head *a,\n\t\t\t\t const struct list_head *b)\n{\n\tstruct ext4_fsmap *fa;\n\tstruct ext4_fsmap *fb;\n\n\tfa = container_of(a, struct ext4_fsmap, fmr_list);\n\tfb = container_of(b, struct ext4_fsmap, fmr_list);\n\tif (fa->fmr_physical < fb->fmr_physical)\n\t\treturn -1;\n\telse if (fa->fmr_physical > fb->fmr_physical)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void ext4_getfsmap_merge_fixed_metadata(struct list_head *meta_list)\n{\n\tstruct ext4_fsmap *p;\n\tstruct ext4_fsmap *prev = NULL;\n\tstruct ext4_fsmap *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, meta_list, fmr_list) {\n\t\tif (!prev) {\n\t\t\tprev = p;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prev->fmr_owner == p->fmr_owner &&\n\t\t    prev->fmr_physical + prev->fmr_length == p->fmr_physical) {\n\t\t\tprev->fmr_length += p->fmr_length;\n\t\t\tlist_del(&p->fmr_list);\n\t\t\tkfree(p);\n\t\t} else\n\t\t\tprev = p;\n\t}\n}\n\n \nstatic void ext4_getfsmap_free_fixed_metadata(struct list_head *meta_list)\n{\n\tstruct ext4_fsmap *p;\n\tstruct ext4_fsmap *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, meta_list, fmr_list) {\n\t\tlist_del(&p->fmr_list);\n\t\tkfree(p);\n\t}\n}\n\n \nstatic int ext4_getfsmap_find_fixed_metadata(struct super_block *sb,\n\t\t\t\t\t     struct list_head *meta_list)\n{\n\tstruct ext4_group_desc *gdp;\n\text4_group_t agno;\n\tint error;\n\n\tINIT_LIST_HEAD(meta_list);\n\n\t \n\tfor (agno = 0; agno < EXT4_SB(sb)->s_groups_count; agno++) {\n\t\tgdp = ext4_get_group_desc(sb, agno, NULL);\n\t\tif (!gdp) {\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\terror = ext4_getfsmap_find_sb(sb, agno, meta_list);\n\t\tif (error)\n\t\t\tgoto err;\n\n\t\t \n\t\terror = ext4_getfsmap_fill(meta_list,\n\t\t\t\t\t   ext4_block_bitmap(sb, gdp), 1,\n\t\t\t\t\t   EXT4_FMR_OWN_BLKBM);\n\t\tif (error)\n\t\t\tgoto err;\n\n\t\t \n\t\terror = ext4_getfsmap_fill(meta_list,\n\t\t\t\t\t   ext4_inode_bitmap(sb, gdp), 1,\n\t\t\t\t\t   EXT4_FMR_OWN_INOBM);\n\t\tif (error)\n\t\t\tgoto err;\n\n\t\t \n\t\terror = ext4_getfsmap_fill(meta_list,\n\t\t\t\t\t   ext4_inode_table(sb, gdp),\n\t\t\t\t\t   EXT4_SB(sb)->s_itb_per_group,\n\t\t\t\t\t   EXT4_FMR_OWN_INODES);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\t \n\tlist_sort(NULL, meta_list, ext4_getfsmap_compare);\n\n\t \n\text4_getfsmap_merge_fixed_metadata(meta_list);\n\n\treturn 0;\nerr:\n\text4_getfsmap_free_fixed_metadata(meta_list);\n\treturn error;\n}\n\n \nstatic int ext4_getfsmap_datadev(struct super_block *sb,\n\t\t\t\t struct ext4_fsmap *keys,\n\t\t\t\t struct ext4_getfsmap_info *info)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t start_fsb;\n\text4_fsblk_t end_fsb;\n\text4_fsblk_t bofs;\n\text4_fsblk_t eofs;\n\text4_group_t start_ag;\n\text4_group_t end_ag;\n\text4_grpblk_t first_cluster;\n\text4_grpblk_t last_cluster;\n\tint error = 0;\n\n\tbofs = le32_to_cpu(sbi->s_es->s_first_data_block);\n\teofs = ext4_blocks_count(sbi->s_es);\n\tif (keys[0].fmr_physical >= eofs)\n\t\treturn 0;\n\telse if (keys[0].fmr_physical < bofs)\n\t\tkeys[0].fmr_physical = bofs;\n\tif (keys[1].fmr_physical >= eofs)\n\t\tkeys[1].fmr_physical = eofs - 1;\n\tif (keys[1].fmr_physical < keys[0].fmr_physical)\n\t\treturn 0;\n\tstart_fsb = keys[0].fmr_physical;\n\tend_fsb = keys[1].fmr_physical;\n\n\t \n\text4_get_group_no_and_offset(sb, start_fsb, &start_ag, &first_cluster);\n\text4_get_group_no_and_offset(sb, end_fsb, &end_ag, &last_cluster);\n\n\t \n\tinfo->gfi_low = keys[0];\n\tinfo->gfi_low.fmr_physical = EXT4_C2B(sbi, first_cluster);\n\tinfo->gfi_low.fmr_length = 0;\n\n\tmemset(&info->gfi_high, 0xFF, sizeof(info->gfi_high));\n\n\t \n\terror = ext4_getfsmap_find_fixed_metadata(sb, &info->gfi_meta_list);\n\tif (error)\n\t\tgoto err;\n\n\t \n\tfor (info->gfi_agno = start_ag;\n\t     info->gfi_agno <= end_ag;\n\t     info->gfi_agno++) {\n\t\t \n\t\tif (info->gfi_agno == end_ag) {\n\t\t\tinfo->gfi_high = keys[1];\n\t\t\tinfo->gfi_high.fmr_physical = EXT4_C2B(sbi,\n\t\t\t\t\tlast_cluster);\n\t\t\tinfo->gfi_high.fmr_length = 0;\n\t\t}\n\n\t\ttrace_ext4_fsmap_low_key(sb, info->gfi_dev, info->gfi_agno,\n\t\t\t\tinfo->gfi_low.fmr_physical,\n\t\t\t\tinfo->gfi_low.fmr_length,\n\t\t\t\tinfo->gfi_low.fmr_owner);\n\n\t\ttrace_ext4_fsmap_high_key(sb, info->gfi_dev, info->gfi_agno,\n\t\t\t\tinfo->gfi_high.fmr_physical,\n\t\t\t\tinfo->gfi_high.fmr_length,\n\t\t\t\tinfo->gfi_high.fmr_owner);\n\n\t\terror = ext4_mballoc_query_range(sb, info->gfi_agno,\n\t\t\t\tEXT4_B2C(sbi, info->gfi_low.fmr_physical),\n\t\t\t\tEXT4_B2C(sbi, info->gfi_high.fmr_physical),\n\t\t\t\text4_getfsmap_datadev_helper, info);\n\t\tif (error)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (info->gfi_agno == start_ag)\n\t\t\tmemset(&info->gfi_low, 0, sizeof(info->gfi_low));\n\t}\n\n\t \n\tif (info->gfi_lastfree.fmr_owner) {\n\t\terror = ext4_getfsmap_helper(sb, info, &info->gfi_lastfree);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\t \n\tinfo->gfi_last = true;\n\terror = ext4_getfsmap_datadev_helper(sb, end_ag, last_cluster, 0, info);\n\tif (error)\n\t\tgoto err;\n\nerr:\n\text4_getfsmap_free_fixed_metadata(&info->gfi_meta_list);\n\treturn error;\n}\n\n \nstatic bool ext4_getfsmap_is_valid_device(struct super_block *sb,\n\t\t\t\t\t  struct ext4_fsmap *fm)\n{\n\tif (fm->fmr_device == 0 || fm->fmr_device == UINT_MAX ||\n\t    fm->fmr_device == new_encode_dev(sb->s_bdev->bd_dev))\n\t\treturn true;\n\tif (EXT4_SB(sb)->s_journal_bdev &&\n\t    fm->fmr_device == new_encode_dev(EXT4_SB(sb)->s_journal_bdev->bd_dev))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool ext4_getfsmap_check_keys(struct ext4_fsmap *low_key,\n\t\t\t\t     struct ext4_fsmap *high_key)\n{\n\tif (low_key->fmr_device > high_key->fmr_device)\n\t\treturn false;\n\tif (low_key->fmr_device < high_key->fmr_device)\n\t\treturn true;\n\n\tif (low_key->fmr_physical > high_key->fmr_physical)\n\t\treturn false;\n\tif (low_key->fmr_physical < high_key->fmr_physical)\n\t\treturn true;\n\n\tif (low_key->fmr_owner > high_key->fmr_owner)\n\t\treturn false;\n\tif (low_key->fmr_owner < high_key->fmr_owner)\n\t\treturn true;\n\n\treturn false;\n}\n\n#define EXT4_GETFSMAP_DEVS\t2\n \nint ext4_getfsmap(struct super_block *sb, struct ext4_fsmap_head *head,\n\t\t  ext4_fsmap_format_t formatter, void *arg)\n{\n\tstruct ext4_fsmap dkeys[2];\t \n\tstruct ext4_getfsmap_dev handlers[EXT4_GETFSMAP_DEVS];\n\tstruct ext4_getfsmap_info info = { NULL };\n\tint i;\n\tint error = 0;\n\n\tif (head->fmh_iflags & ~FMH_IF_VALID)\n\t\treturn -EINVAL;\n\tif (!ext4_getfsmap_is_valid_device(sb, &head->fmh_keys[0]) ||\n\t    !ext4_getfsmap_is_valid_device(sb, &head->fmh_keys[1]))\n\t\treturn -EINVAL;\n\n\thead->fmh_entries = 0;\n\n\t \n\tmemset(handlers, 0, sizeof(handlers));\n\thandlers[0].gfd_dev = new_encode_dev(sb->s_bdev->bd_dev);\n\thandlers[0].gfd_fn = ext4_getfsmap_datadev;\n\tif (EXT4_SB(sb)->s_journal_bdev) {\n\t\thandlers[1].gfd_dev = new_encode_dev(\n\t\t\t\tEXT4_SB(sb)->s_journal_bdev->bd_dev);\n\t\thandlers[1].gfd_fn = ext4_getfsmap_logdev;\n\t}\n\n\tsort(handlers, EXT4_GETFSMAP_DEVS, sizeof(struct ext4_getfsmap_dev),\n\t\t\text4_getfsmap_dev_compare, NULL);\n\n\t \n\tdkeys[0] = head->fmh_keys[0];\n\tdkeys[0].fmr_physical += dkeys[0].fmr_length;\n\tdkeys[0].fmr_owner = 0;\n\tdkeys[0].fmr_length = 0;\n\tmemset(&dkeys[1], 0xFF, sizeof(struct ext4_fsmap));\n\n\tif (!ext4_getfsmap_check_keys(dkeys, &head->fmh_keys[1]))\n\t\treturn -EINVAL;\n\n\tinfo.gfi_next_fsblk = head->fmh_keys[0].fmr_physical +\n\t\t\t  head->fmh_keys[0].fmr_length;\n\tinfo.gfi_formatter = formatter;\n\tinfo.gfi_format_arg = arg;\n\tinfo.gfi_head = head;\n\n\t \n\tfor (i = 0; i < EXT4_GETFSMAP_DEVS; i++) {\n\t\t \n\t\tif (!handlers[i].gfd_fn)\n\t\t\tcontinue;\n\t\tif (head->fmh_keys[0].fmr_device > handlers[i].gfd_dev)\n\t\t\tcontinue;\n\t\tif (head->fmh_keys[1].fmr_device < handlers[i].gfd_dev)\n\t\t\tbreak;\n\n\t\t \n\t\tif (handlers[i].gfd_dev == head->fmh_keys[1].fmr_device)\n\t\t\tdkeys[1] = head->fmh_keys[1];\n\t\tif (handlers[i].gfd_dev > head->fmh_keys[0].fmr_device)\n\t\t\tmemset(&dkeys[0], 0, sizeof(struct ext4_fsmap));\n\n\t\tinfo.gfi_dev = handlers[i].gfd_dev;\n\t\tinfo.gfi_last = false;\n\t\tinfo.gfi_agno = -1;\n\t\terror = handlers[i].gfd_fn(sb, dkeys, &info);\n\t\tif (error)\n\t\t\tbreak;\n\t\tinfo.gfi_next_fsblk = 0;\n\t}\n\n\thead->fmh_oflags = FMH_OF_DEV_T;\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}