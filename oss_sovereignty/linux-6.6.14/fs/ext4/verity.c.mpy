{
  "module_name": "verity.c",
  "hash_id": "8a397cc7fe5fc4f8b4ea65a228bc705a40a2ba2a6eae025d62e3c903d477a294",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/verity.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/quotaops.h>\n\n#include \"ext4.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline loff_t ext4_verity_metadata_pos(const struct inode *inode)\n{\n\treturn round_up(inode->i_size, 65536);\n}\n\n \nstatic int pagecache_read(struct inode *inode, void *buf, size_t count,\n\t\t\t  loff_t pos)\n{\n\twhile (count) {\n\t\tstruct folio *folio;\n\t\tsize_t n;\n\n\t\tfolio = read_mapping_folio(inode->i_mapping, pos >> PAGE_SHIFT,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(folio))\n\t\t\treturn PTR_ERR(folio);\n\n\t\tn = memcpy_from_file_folio(buf, folio, pos, count);\n\t\tfolio_put(folio);\n\n\t\tbuf += n;\n\t\tpos += n;\n\t\tcount -= n;\n\t}\n\treturn 0;\n}\n\n \nstatic int pagecache_write(struct inode *inode, const void *buf, size_t count,\n\t\t\t   loff_t pos)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\tif (pos + count > inode->i_sb->s_maxbytes)\n\t\treturn -EFBIG;\n\n\twhile (count) {\n\t\tsize_t n = min_t(size_t, count,\n\t\t\t\t PAGE_SIZE - offset_in_page(pos));\n\t\tstruct page *page;\n\t\tvoid *fsdata = NULL;\n\t\tint res;\n\n\t\tres = aops->write_begin(NULL, mapping, pos, n, &page, &fsdata);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tmemcpy_to_page(page, offset_in_page(pos), buf, n);\n\n\t\tres = aops->write_end(NULL, mapping, pos, n, n, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tif (res != n)\n\t\t\treturn -EIO;\n\n\t\tbuf += n;\n\t\tpos += n;\n\t\tcount -= n;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_begin_enable_verity(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tconst int credits = 2;  \n\thandle_t *handle;\n\tint err;\n\n\tif (IS_DAX(inode) || ext4_test_inode_flag(inode, EXT4_INODE_DAX))\n\t\treturn -EINVAL;\n\n\tif (ext4_verity_in_progress(inode))\n\t\treturn -EBUSY;\n\n\t \n\n\terr = ext4_inode_attach_jinode(inode);\n\tif (err)\n\t\treturn err;\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_convert_inline_data(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\text4_warning_inode(inode,\n\t\t\t\t   \"verity is only allowed on extent-based files\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\terr = ext4_truncate(inode);\n\tif (err)\n\t\treturn err;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_orphan_add(handle, inode);\n\tif (err == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n\n\text4_journal_stop(handle);\n\treturn err;\n}\n\n \nstatic int ext4_write_verity_descriptor(struct inode *inode, const void *desc,\n\t\t\t\t\tsize_t desc_size, u64 merkle_tree_size)\n{\n\tconst u64 desc_pos = round_up(ext4_verity_metadata_pos(inode) +\n\t\t\t\t      merkle_tree_size, i_blocksize(inode));\n\tconst u64 desc_end = desc_pos + desc_size;\n\tconst __le32 desc_size_disk = cpu_to_le32(desc_size);\n\tconst u64 desc_size_pos = round_up(desc_end + sizeof(desc_size_disk),\n\t\t\t\t\t   i_blocksize(inode)) -\n\t\t\t\t  sizeof(desc_size_disk);\n\tint err;\n\n\terr = pagecache_write(inode, desc, desc_size, desc_pos);\n\tif (err)\n\t\treturn err;\n\n\treturn pagecache_write(inode, &desc_size_disk, sizeof(desc_size_disk),\n\t\t\t       desc_size_pos);\n}\n\nstatic int ext4_end_enable_verity(struct file *filp, const void *desc,\n\t\t\t\t  size_t desc_size, u64 merkle_tree_size)\n{\n\tstruct inode *inode = file_inode(filp);\n\tconst int credits = 2;  \n\thandle_t *handle;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\t \n\tif (desc == NULL)\n\t\tgoto cleanup;\n\n\t \n\terr = ext4_write_verity_descriptor(inode, desc, desc_size,\n\t\t\t\t\t   merkle_tree_size);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\terr = filemap_write_and_wait(inode->i_mapping);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, credits);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto cleanup;\n\t}\n\n\terr = ext4_orphan_del(handle, inode);\n\tif (err)\n\t\tgoto stop_and_cleanup;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto stop_and_cleanup;\n\n\text4_set_inode_flag(inode, EXT4_INODE_VERITY);\n\text4_set_inode_flags(inode, false);\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\tif (err)\n\t\tgoto stop_and_cleanup;\n\n\text4_journal_stop(handle);\n\n\text4_clear_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n\treturn 0;\n\nstop_and_cleanup:\n\text4_journal_stop(handle);\ncleanup:\n\t \n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\text4_orphan_del(NULL, inode);\n\text4_clear_inode_state(inode, EXT4_STATE_VERITY_IN_PROGRESS);\n\treturn err;\n}\n\nstatic int ext4_get_verity_descriptor_location(struct inode *inode,\n\t\t\t\t\t       size_t *desc_size_ret,\n\t\t\t\t\t       u64 *desc_pos_ret)\n{\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *last_extent;\n\tu32 end_lblk;\n\tu64 desc_size_pos;\n\t__le32 desc_size_disk;\n\tu32 desc_size;\n\tu64 desc_pos;\n\tint err;\n\n\t \n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tEXT4_ERROR_INODE(inode, \"verity file doesn't use extents\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tlast_extent = path[path->p_depth].p_ext;\n\tif (!last_extent) {\n\t\tEXT4_ERROR_INODE(inode, \"verity file has no extents\");\n\t\text4_free_ext_path(path);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tend_lblk = le32_to_cpu(last_extent->ee_block) +\n\t\t   ext4_ext_get_actual_len(last_extent);\n\tdesc_size_pos = (u64)end_lblk << inode->i_blkbits;\n\text4_free_ext_path(path);\n\n\tif (desc_size_pos < sizeof(desc_size_disk))\n\t\tgoto bad;\n\tdesc_size_pos -= sizeof(desc_size_disk);\n\n\terr = pagecache_read(inode, &desc_size_disk, sizeof(desc_size_disk),\n\t\t\t     desc_size_pos);\n\tif (err)\n\t\treturn err;\n\tdesc_size = le32_to_cpu(desc_size_disk);\n\n\t \n\n\tif (desc_size > INT_MAX || desc_size > desc_size_pos)\n\t\tgoto bad;\n\n\tdesc_pos = round_down(desc_size_pos - desc_size, i_blocksize(inode));\n\tif (desc_pos < ext4_verity_metadata_pos(inode))\n\t\tgoto bad;\n\n\t*desc_size_ret = desc_size;\n\t*desc_pos_ret = desc_pos;\n\treturn 0;\n\nbad:\n\tEXT4_ERROR_INODE(inode, \"verity file corrupted; can't find descriptor\");\n\treturn -EFSCORRUPTED;\n}\n\nstatic int ext4_get_verity_descriptor(struct inode *inode, void *buf,\n\t\t\t\t      size_t buf_size)\n{\n\tsize_t desc_size = 0;\n\tu64 desc_pos = 0;\n\tint err;\n\n\terr = ext4_get_verity_descriptor_location(inode, &desc_size, &desc_pos);\n\tif (err)\n\t\treturn err;\n\n\tif (buf_size) {\n\t\tif (desc_size > buf_size)\n\t\t\treturn -ERANGE;\n\t\terr = pagecache_read(inode, buf, desc_size, desc_pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn desc_size;\n}\n\nstatic struct page *ext4_read_merkle_tree_page(struct inode *inode,\n\t\t\t\t\t       pgoff_t index,\n\t\t\t\t\t       unsigned long num_ra_pages)\n{\n\tstruct folio *folio;\n\n\tindex += ext4_verity_metadata_pos(inode) >> PAGE_SHIFT;\n\n\tfolio = __filemap_get_folio(inode->i_mapping, index, FGP_ACCESSED, 0);\n\tif (IS_ERR(folio) || !folio_test_uptodate(folio)) {\n\t\tDEFINE_READAHEAD(ractl, NULL, NULL, inode->i_mapping, index);\n\n\t\tif (!IS_ERR(folio))\n\t\t\tfolio_put(folio);\n\t\telse if (num_ra_pages > 1)\n\t\t\tpage_cache_ra_unbounded(&ractl, num_ra_pages, 0);\n\t\tfolio = read_mapping_folio(inode->i_mapping, index, NULL);\n\t\tif (IS_ERR(folio))\n\t\t\treturn ERR_CAST(folio);\n\t}\n\treturn folio_file_page(folio, index);\n}\n\nstatic int ext4_write_merkle_tree_block(struct inode *inode, const void *buf,\n\t\t\t\t\tu64 pos, unsigned int size)\n{\n\tpos += ext4_verity_metadata_pos(inode);\n\n\treturn pagecache_write(inode, buf, size, pos);\n}\n\nconst struct fsverity_operations ext4_verityops = {\n\t.begin_enable_verity\t= ext4_begin_enable_verity,\n\t.end_enable_verity\t= ext4_end_enable_verity,\n\t.get_verity_descriptor\t= ext4_get_verity_descriptor,\n\t.read_merkle_tree_page\t= ext4_read_merkle_tree_page,\n\t.write_merkle_tree_block = ext4_write_merkle_tree_block,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}