{
  "module_name": "fsync.c",
  "hash_id": "907157c9bffb03400b6a9a4284b9d96d138ddf2c7f25a3dbf979be6f7e8d020c",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/fsync.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#include <trace/events/ext4.h>\n\n \nstatic int ext4_sync_parent(struct inode *inode)\n{\n\tstruct dentry *dentry, *next;\n\tint ret = 0;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY))\n\t\treturn 0;\n\tdentry = d_find_any_alias(inode);\n\tif (!dentry)\n\t\treturn 0;\n\twhile (ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY)) {\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEWENTRY);\n\n\t\tnext = dget_parent(dentry);\n\t\tdput(dentry);\n\t\tdentry = next;\n\t\tinode = dentry->d_inode;\n\n\t\t \n\t\tret = sync_mapping_buffers(inode->i_mapping);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = sync_inode_metadata(inode, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdput(dentry);\n\treturn ret;\n}\n\nstatic int ext4_fsync_nojournal(struct file *file, loff_t start, loff_t end,\n\t\t\t\tint datasync, bool *needs_barrier)\n{\n\tstruct inode *inode = file->f_inode;\n\tint ret;\n\n\tret = generic_buffers_fsync_noflush(file, start, end, datasync);\n\tif (!ret)\n\t\tret = ext4_sync_parent(inode);\n\tif (test_opt(inode->i_sb, BARRIER))\n\t\t*needs_barrier = true;\n\n\treturn ret;\n}\n\nstatic int ext4_fsync_journal(struct inode *inode, bool datasync,\n\t\t\t     bool *needs_barrier)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn ext4_force_commit(inode->i_sb);\n\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !jbd2_trans_will_send_data_barrier(journal, commit_tid))\n\t\t*needs_barrier = true;\n\n\treturn ext4_fc_commit(journal, commit_tid);\n}\n\n \nint ext4_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret = 0, err;\n\tbool needs_barrier = false;\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (unlikely(ext4_forced_shutdown(inode->i_sb)))\n\t\treturn -EIO;\n\n\tASSERT(ext4_journal_current_handle() == NULL);\n\n\ttrace_ext4_sync_file_enter(file, datasync);\n\n\tif (sb_rdonly(inode->i_sb)) {\n\t\t \n\t\tsmp_rmb();\n\t\tif (ext4_forced_shutdown(inode->i_sb))\n\t\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tif (!EXT4_SB(inode->i_sb)->s_journal) {\n\t\tret = ext4_fsync_nojournal(file, start, end, datasync,\n\t\t\t\t\t   &needs_barrier);\n\t\tif (needs_barrier)\n\t\t\tgoto issue_flush;\n\t\tgoto out;\n\t}\n\n\tret = file_write_and_wait_range(file, start, end);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ext4_fsync_journal(inode, datasync, &needs_barrier);\n\nissue_flush:\n\tif (needs_barrier) {\n\t\terr = blkdev_issue_flush(inode->i_sb->s_bdev);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\nout:\n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\ttrace_ext4_sync_file_exit(inode, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}