{
  "module_name": "migrate.c",
  "hash_id": "ec07e8f936b138368873463af58db0ef0fd70040d20602d52019ca966d774d9d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/migrate.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\n\n \nstruct migrate_struct {\n\text4_lblk_t first_block, last_block, curr_block;\n\text4_fsblk_t first_pblock, last_pblock;\n};\n\nstatic int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t \n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t \n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\tretval = ext4_datasem_ensure_credits(handle, inode, needed, needed, 0);\n\tif (retval < 0)\n\t\tgoto err_out;\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_free_ext_path(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}\n\nstatic int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t \n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t \n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}\n\nstatic int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = ext4_sb_bread(inode->i_sb, pblock, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}\n\nstatic int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = ext4_sb_bread(inode->i_sb, pblock, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}\n\nstatic int update_tind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = ext4_sb_bread(inode->i_sb, pblock, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_dind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tlb->curr_block += max_entries * max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}\n\nstatic int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\tint err;\n\n\tbh = ext4_sb_bread(sb, le32_to_cpu(i_data), 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\terr = ext4_journal_ensure_credits(handle,\n\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS,\n\t\t\t\text4_free_metadata_revoke_credits(sb, 1));\n\t\t\tif (err < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\terr = ext4_journal_ensure_credits(handle, EXT4_RESERVE_TRANS_BLOCKS,\n\t\t\t\text4_free_metadata_revoke_credits(sb, 1));\n\tif (err < 0)\n\t\treturn err;\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}\n\nstatic int free_tind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i, retval = 0;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = ext4_sb_bread(inode->i_sb, le32_to_cpu(i_data), 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\tretval = free_dind_blocks(handle,\n\t\t\t\t\tinode, tmp_idata[i]);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\tretval = ext4_journal_ensure_credits(handle, EXT4_RESERVE_TRANS_BLOCKS,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1));\n\tif (retval < 0)\n\t\treturn retval;\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}\n\nstatic int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\n{\n\tint retval;\n\n\t \n\tif (i_data[0]) {\n\t\tretval = ext4_journal_ensure_credits(handle,\n\t\t\tEXT4_RESERVE_TRANS_BLOCKS,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1));\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\tle32_to_cpu(i_data[0]), 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\n\t \n\tif (i_data[1]) {\n\t\tretval = free_dind_blocks(handle, inode, i_data[1]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tif (i_data[2]) {\n\t\tretval = free_tind_blocks(handle, inode, i_data[2]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\n\t\t\t\t\t\tstruct inode *tmp_inode)\n{\n\tint retval, retval2 = 0;\n\t__le32\ti_data[3];\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\n\n\t \n\tretval = ext4_journal_ensure_credits(handle, 1, 0);\n\tif (retval < 0)\n\t\tgoto err_out;\n\n\ti_data[0] = ei->i_data[EXT4_IND_BLOCK];\n\ti_data[1] = ei->i_data[EXT4_DIND_BLOCK];\n\ti_data[2] = ei->i_data[EXT4_TIND_BLOCK];\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t \n\tif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\n\t\tretval = -EAGAIN;\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto err_out;\n\t} else\n\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t \n\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\n\n\t \n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += tmp_inode->i_blocks;\n\tspin_unlock(&inode->i_lock);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\n\t \n\tretval = free_ind_block(handle, inode, i_data);\n\tretval2 = ext4_mark_inode_dirty(handle, inode);\n\tif (unlikely(retval2 && !retval))\n\t\tretval = retval2;\n\nerr_out:\n\treturn retval;\n}\n\nstatic int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = ext4_sb_bread(inode->i_sb, block, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\tretval = ext4_journal_ensure_credits(handle, EXT4_RESERVE_TRANS_BLOCKS,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, 1));\n\tif (retval < 0)\n\t\treturn retval;\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}\n\n \nstatic int free_ext_block(handle_t *handle, struct inode *inode)\n{\n\tint i, retval = 0;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\n\tstruct ext4_extent_idx *ix;\n\tif (eh->eh_depth == 0)\n\t\t \n\t\treturn 0;\n\tix = EXT_FIRST_INDEX(eh);\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\tretval = free_ext_idx(handle, inode, ix);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn retval;\n}\n\nint ext4_ext_migrate(struct inode *inode)\n{\n\thandle_t *handle;\n\tint retval = 0, i;\n\t__le32 *i_data;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *tmp_inode = NULL;\n\tstruct migrate_struct lb;\n\tunsigned long max_entries;\n\t__u32 goal, tmp_csum_seed;\n\tuid_t owner[2];\n\tint alloc_ctx;\n\n\t \n\tif (!ext4_has_feature_extents(inode->i_sb) ||\n\t    ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) ||\n\t    ext4_has_inline_data(inode))\n\t\treturn -EINVAL;\n\n\tif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\n\t\t \n\t\treturn retval;\n\n\talloc_ctx = ext4_writepages_down_write(inode->i_sb);\n\n\t \n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\n\t\t3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out_unlock;\n\t}\n\tgoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\n\t\tEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\n\towner[0] = i_uid_read(inode);\n\towner[1] = i_gid_read(inode);\n\ttmp_inode = ext4_new_inode(handle, d_inode(inode->i_sb->s_root),\n\t\t\t\t   S_IFREG, NULL, goal, owner, 0);\n\tif (IS_ERR(tmp_inode)) {\n\t\tretval = PTR_ERR(tmp_inode);\n\t\text4_journal_stop(handle);\n\t\tgoto out_unlock;\n\t}\n\t \n\tei = EXT4_I(inode);\n\ttmp_csum_seed = EXT4_I(tmp_inode)->i_csum_seed;\n\tEXT4_I(tmp_inode)->i_csum_seed = ei->i_csum_seed;\n\ti_size_write(tmp_inode, i_size_read(inode));\n\t \n\tclear_nlink(tmp_inode);\n\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_journal_stop(handle);\n\n\t \n\t \n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\text4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out_tmp_inode;\n\t}\n\n\ti_data = ei->i_data;\n\tmemset(&lb, 0, sizeof(lb));\n\n\t \n\tmax_entries = inode->i_sb->s_blocksize >> 2;\n\tfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, tmp_inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t} else\n\t\t\tlb.curr_block++;\n\t}\n\tif (i_data[EXT4_IND_BLOCK]) {\n\t\tretval = update_ind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries;\n\tif (i_data[EXT4_DIND_BLOCK]) {\n\t\tretval = update_dind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries * max_entries;\n\tif (i_data[EXT4_TIND_BLOCK]) {\n\t\tretval = update_tind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\t \n\tretval = finish_range(handle, tmp_inode, &lb);\nerr_out:\n\tif (retval)\n\t\t \n\t\tfree_ext_block(handle, tmp_inode);\n\telse {\n\t\tretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\n\t\tif (retval)\n\t\t\t \n\t\t\tfree_ext_block(handle, tmp_inode);\n\t}\n\n\t \n\tretval = ext4_journal_ensure_credits(handle, 1, 0);\n\tif (retval < 0)\n\t\tgoto out_stop;\n\t \n\ti_size_write(tmp_inode, 0);\n\n\t \n\ttmp_inode->i_blocks = 0;\n\tEXT4_I(tmp_inode)->i_csum_seed = tmp_csum_seed;\n\n\t \n\text4_ext_tree_init(handle, tmp_inode);\nout_stop:\n\text4_journal_stop(handle);\nout_tmp_inode:\n\tunlock_new_inode(tmp_inode);\n\tiput(tmp_inode);\nout_unlock:\n\text4_writepages_up_write(inode->i_sb, alloc_ctx);\n\treturn retval;\n}\n\n \nint ext4_ind_migrate(struct inode *inode)\n{\n\tstruct ext4_extent_header\t*eh;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_super_block\t\t*es = sbi->s_es;\n\tstruct ext4_inode_info\t\t*ei = EXT4_I(inode);\n\tstruct ext4_extent\t\t*ex;\n\tunsigned int\t\t\ti, len;\n\text4_lblk_t\t\t\tstart, end;\n\text4_fsblk_t\t\t\tblk;\n\thandle_t\t\t\t*handle;\n\tint\t\t\t\tret, ret2 = 0;\n\tint\t\t\t\talloc_ctx;\n\n\tif (!ext4_has_feature_extents(inode->i_sb) ||\n\t    (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (ext4_has_feature_bigalloc(inode->i_sb))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\text4_alloc_da_blocks(inode);\n\n\talloc_ctx = ext4_writepages_down_write(inode->i_sb);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_unlock;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_check_inode(inode);\n\tif (ret)\n\t\tgoto errout;\n\n\teh = ext_inode_hdr(inode);\n\tex  = EXT_FIRST_EXTENT(eh);\n\tif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\n\t    eh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (eh->eh_entries == 0)\n\t\tblk = len = start = end = 0;\n\telse {\n\t\tlen = le16_to_cpu(ex->ee_len);\n\t\tblk = ext4_ext_pblock(ex);\n\t\tstart = le32_to_cpu(ex->ee_block);\n\t\tend = start + len - 1;\n\t\tif (end >= EXT4_NDIR_BLOCKS) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tfor (i = start; i <= end; i++)\n\t\tei->i_data[i] = cpu_to_le32(blk++);\n\tret2 = ext4_mark_inode_dirty(handle, inode);\n\tif (unlikely(ret2 && !ret))\n\t\tret = ret2;\nerrout:\n\text4_journal_stop(handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout_unlock:\n\text4_writepages_up_write(inode->i_sb, alloc_ctx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}