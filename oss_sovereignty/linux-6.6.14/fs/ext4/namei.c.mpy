{
  "module_name": "namei.c",
  "hash_id": "bb559b24706a3d1a8cf65dcb9f9311d4e726432ccf880e66bc81d39fd7de77c8",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/time.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/iversion.h>\n#include <linux/unicode.h>\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#include <trace/events/ext4.h>\n \n#define NAMEI_RA_CHUNKS  2\n#define NAMEI_RA_BLOCKS  4\n#define NAMEI_RA_SIZE\t     (NAMEI_RA_CHUNKS * NAMEI_RA_BLOCKS)\n\nstatic struct buffer_head *ext4_append(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\text4_lblk_t *block)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (unlikely(EXT4_SB(inode->i_sb)->s_max_dir_size_kb &&\n\t\t     ((inode->i_size >> 10) >=\n\t\t      EXT4_SB(inode->i_sb)->s_max_dir_size_kb)))\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t*block = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tmap.m_lblk = *block;\n\tmap.m_len = 1;\n\n\t \n\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (err) {\n\t\tEXT4_ERROR_INODE(inode, \"Logical block already allocated\");\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tbh = ext4_bread(handle, inode, *block, EXT4_GET_BLOCKS_CREATE);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tinode->i_size += inode->i_sb->s_blocksize;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err)\n\t\tgoto out;\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, inode->i_sb, bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\n\nout:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn ERR_PTR(err);\n}\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\n\n \ntypedef enum {\n\tEITHER, INDEX, DIRENT, DIRENT_HTREE\n} dirblock_type_t;\n\n#define ext4_read_dirblock(inode, block, type) \\\n\t__ext4_read_dirblock((inode), (block), (type), __func__, __LINE__)\n\nstatic struct buffer_head *__ext4_read_dirblock(struct inode *inode,\n\t\t\t\t\t\text4_lblk_t block,\n\t\t\t\t\t\tdirblock_type_t type,\n\t\t\t\t\t\tconst char *func,\n\t\t\t\t\t\tunsigned int line)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry *dirent;\n\tint is_dx_block = 0;\n\n\tif (block >= inode->i_size >> inode->i_blkbits) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t       \"Attempting to read directory block (%u) that is past i_size (%llu)\",\n\t\t       block, inode->i_size);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tif (ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_EIO))\n\t\tbh = ERR_PTR(-EIO);\n\telse\n\t\tbh = ext4_bread(NULL, inode, block, 0);\n\tif (IS_ERR(bh)) {\n\t\t__ext4_warning(inode->i_sb, func, line,\n\t\t\t       \"inode #%lu: lblock %lu: comm %s: \"\n\t\t\t       \"error %ld reading directory block\",\n\t\t\t       inode->i_ino, (unsigned long)block,\n\t\t\t       current->comm, PTR_ERR(bh));\n\n\t\treturn bh;\n\t}\n\tif (!bh && (type == INDEX || type == DIRENT_HTREE)) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t\t\t \"Directory hole found for htree %s block\",\n\t\t\t\t (type == INDEX) ? \"index\" : \"leaf\");\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!bh)\n\t\treturn NULL;\n\tdirent = (struct ext4_dir_entry *) bh->b_data;\n\t \n\tif (is_dx(inode)) {\n\t\tif (block == 0)\n\t\t\tis_dx_block = 1;\n\t\telse if (ext4_rec_len_from_disk(dirent->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize) ==\n\t\t\t inode->i_sb->s_blocksize)\n\t\t\tis_dx_block = 1;\n\t}\n\tif (!is_dx_block && type == INDEX) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t       \"directory leaf block found instead of index block\");\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!ext4_has_metadata_csum(inode->i_sb) ||\n\t    buffer_verified(bh))\n\t\treturn bh;\n\n\t \n\tif (is_dx_block && type == INDEX) {\n\t\tif (ext4_dx_csum_verify(inode, dirent) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory index failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\tif (!is_dx_block) {\n\t\tif (ext4_dirblock_csum_verify(inode, bh) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory block failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\treturn bh;\n}\n\n#ifdef DX_DEBUG\n#define dxtrace(command) command\n#else\n#define dxtrace(command)\n#endif\n\nstruct fake_dirent\n{\n\t__le32 inode;\n\t__le16 rec_len;\n\tu8 name_len;\n\tu8 file_type;\n};\n\nstruct dx_countlimit\n{\n\t__le16 limit;\n\t__le16 count;\n};\n\nstruct dx_entry\n{\n\t__le32 hash;\n\t__le32 block;\n};\n\n \n\nstruct dx_root\n{\n\tstruct fake_dirent dot;\n\tchar dot_name[4];\n\tstruct fake_dirent dotdot;\n\tchar dotdot_name[4];\n\tstruct dx_root_info\n\t{\n\t\t__le32 reserved_zero;\n\t\tu8 hash_version;\n\t\tu8 info_length;  \n\t\tu8 indirect_levels;\n\t\tu8 unused_flags;\n\t}\n\tinfo;\n\tstruct dx_entry\tentries[];\n};\n\nstruct dx_node\n{\n\tstruct fake_dirent fake;\n\tstruct dx_entry\tentries[];\n};\n\n\nstruct dx_frame\n{\n\tstruct buffer_head *bh;\n\tstruct dx_entry *entries;\n\tstruct dx_entry *at;\n};\n\nstruct dx_map_entry\n{\n\tu32 hash;\n\tu16 offs;\n\tu16 size;\n};\n\n \nstruct dx_tail {\n\tu32 dt_reserved;\n\t__le32 dt_checksum;\t \n};\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_root_limit(struct inode *dir, unsigned infosize);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(struct ext4_filename *fname,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic int dx_make_map(struct inode *dir, struct buffer_head *bh,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext4_dir_entry_2 *dx_move_dirents(struct inode *dir, char *from,\n\t\t\t\t\tchar *to, struct dx_map_entry *offsets,\n\t\t\t\t\tint count, unsigned int blocksize);\nstatic struct ext4_dir_entry_2 *dx_pack_dirents(struct inode *dir, char *base,\n\t\t\t\t\t\tunsigned int blocksize);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\tstruct ext4_filename *fname,\n\t\tstruct ext4_dir_entry_2 **res_dir);\nstatic int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir, struct inode *inode);\n\n \nvoid ext4_initialize_dirent_tail(struct buffer_head *bh,\n\t\t\t\t unsigned int blocksize)\n{\n\tstruct ext4_dir_entry_tail *t = EXT4_DIRENT_TAIL(bh->b_data, blocksize);\n\n\tmemset(t, 0, sizeof(struct ext4_dir_entry_tail));\n\tt->det_rec_len = ext4_rec_len_to_disk(\n\t\t\tsizeof(struct ext4_dir_entry_tail), blocksize);\n\tt->det_reserved_ft = EXT4_FT_DIR_CSUM;\n}\n\n \nstatic struct ext4_dir_entry_tail *get_dirent_tail(struct inode *inode,\n\t\t\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\tint blocksize = EXT4_BLOCK_SIZE(inode->i_sb);\n\n#ifdef PARANOID\n\tstruct ext4_dir_entry *d, *top;\n\n\td = (struct ext4_dir_entry *)bh->b_data;\n\ttop = (struct ext4_dir_entry *)(bh->b_data +\n\t\t(blocksize - sizeof(struct ext4_dir_entry_tail)));\n\twhile (d < top && ext4_rec_len_from_disk(d->rec_len, blocksize))\n\t\td = (struct ext4_dir_entry *)(((void *)d) +\n\t\t    ext4_rec_len_from_disk(d->rec_len, blocksize));\n\n\tif (d != top)\n\t\treturn NULL;\n\n\tt = (struct ext4_dir_entry_tail *)d;\n#else\n\tt = EXT4_DIRENT_TAIL(bh->b_data, EXT4_BLOCK_SIZE(inode->i_sb));\n#endif\n\n\tif (t->det_reserved_zero1 ||\n\t    (ext4_rec_len_from_disk(t->det_rec_len, blocksize) !=\n\t     sizeof(struct ext4_dir_entry_tail)) ||\n\t    t->det_reserved_zero2 ||\n\t    t->det_reserved_ft != EXT4_FT_DIR_CSUM)\n\t\treturn NULL;\n\n\treturn t;\n}\n\nstatic __le32 ext4_dirblock_csum(struct inode *inode, void *dirent, int size)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\treturn cpu_to_le32(csum);\n}\n\n#define warn_no_space_for_csum(inode)\t\t\t\t\t\\\n\t__warn_no_space_for_csum((inode), __func__, __LINE__)\n\nstatic void __warn_no_space_for_csum(struct inode *inode, const char *func,\n\t\t\t\t     unsigned int line)\n{\n\t__ext4_warning_inode(inode, func, line,\n\t\t\"No space for directory leaf checksum. Please run e2fsck -D.\");\n}\n\nint ext4_dirblock_csum_verify(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, bh);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirblock_csum(inode, bh->b_data,\n\t\t\t\t\t\t  (char *)t - bh->b_data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void ext4_dirblock_csum_set(struct inode *inode,\n\t\t\t\t struct buffer_head *bh)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tt = get_dirent_tail(inode, bh);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\n\tt->det_checksum = ext4_dirblock_csum(inode, bh->b_data,\n\t\t\t\t\t     (char *)t - bh->b_data);\n}\n\nint ext4_handle_dirty_dirblock(handle_t *handle,\n\t\t\t       struct inode *inode,\n\t\t\t       struct buffer_head *bh)\n{\n\text4_dirblock_csum_set(inode, bh);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}\n\nstatic struct dx_countlimit *get_dx_countlimit(struct inode *inode,\n\t\t\t\t\t       struct ext4_dir_entry *dirent,\n\t\t\t\t\t       int *offset)\n{\n\tstruct ext4_dir_entry *dp;\n\tstruct dx_root_info *root;\n\tint count_offset;\n\tint blocksize = EXT4_BLOCK_SIZE(inode->i_sb);\n\tunsigned int rlen = ext4_rec_len_from_disk(dirent->rec_len, blocksize);\n\n\tif (rlen == blocksize)\n\t\tcount_offset = 8;\n\telse if (rlen == 12) {\n\t\tdp = (struct ext4_dir_entry *)(((void *)dirent) + 12);\n\t\tif (ext4_rec_len_from_disk(dp->rec_len, blocksize) != blocksize - 12)\n\t\t\treturn NULL;\n\t\troot = (struct dx_root_info *)(((void *)dp + 12));\n\t\tif (root->reserved_zero ||\n\t\t    root->info_length != sizeof(struct dx_root_info))\n\t\t\treturn NULL;\n\t\tcount_offset = 32;\n\t} else\n\t\treturn NULL;\n\n\tif (offset)\n\t\t*offset = count_offset;\n\treturn (struct dx_countlimit *)(((void *)dirent) + count_offset);\n}\n\nstatic __le32 ext4_dx_csum(struct inode *inode, struct ext4_dir_entry *dirent,\n\t\t\t   int count_offset, int count, struct dx_tail *t)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__u32 csum;\n\tint size;\n\t__u32 dummy_csum = 0;\n\tint offset = offsetof(struct dx_tail, dt_checksum);\n\n\tsize = count_offset + (count * sizeof(struct dx_entry));\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)dirent, size);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)t, offset);\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)&dummy_csum, sizeof(dummy_csum));\n\n\treturn cpu_to_le32(csum);\n}\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn 0;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tif (t->dt_checksum != ext4_dx_csum(inode, dirent, count_offset,\n\t\t\t\t\t    count, t))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct dx_countlimit *c;\n\tstruct dx_tail *t;\n\tint count_offset, limit, count;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tc = get_dx_countlimit(inode, dirent, &count_offset);\n\tif (!c) {\n\t\tEXT4_ERROR_INODE(inode, \"dir seems corrupt?  Run e2fsck -D.\");\n\t\treturn;\n\t}\n\tlimit = le16_to_cpu(c->limit);\n\tcount = le16_to_cpu(c->count);\n\tif (count_offset + (limit * sizeof(struct dx_entry)) >\n\t    EXT4_BLOCK_SIZE(inode->i_sb) - sizeof(struct dx_tail)) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn;\n\t}\n\tt = (struct dx_tail *)(((struct dx_entry *)c) + limit);\n\n\tt->dt_checksum = ext4_dx_csum(inode, dirent, count_offset, count, t);\n}\n\nstatic inline int ext4_handle_dirty_dx_node(handle_t *handle,\n\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\text4_dx_csum_set(inode, (struct ext4_dir_entry *)bh->b_data);\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}\n\n \nstatic inline struct ext4_dir_entry_2 *\next4_next_entry(struct ext4_dir_entry_2 *p, unsigned long blocksize)\n{\n\treturn (struct ext4_dir_entry_2 *)((char *)p +\n\t\text4_rec_len_from_disk(p->rec_len, blocksize));\n}\n\n \n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->block) & 0x0fffffff;\n}\n\nstatic inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)\n{\n\tentry->block = cpu_to_le32(value);\n}\n\nstatic inline unsigned dx_get_hash(struct dx_entry *entry)\n{\n\treturn le32_to_cpu(entry->hash);\n}\n\nstatic inline void dx_set_hash(struct dx_entry *entry, unsigned value)\n{\n\tentry->hash = cpu_to_le32(value);\n}\n\nstatic inline unsigned dx_get_count(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->count);\n}\n\nstatic inline unsigned dx_get_limit(struct dx_entry *entries)\n{\n\treturn le16_to_cpu(((struct dx_countlimit *) entries)->limit);\n}\n\nstatic inline void dx_set_count(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->count = cpu_to_le16(value);\n}\n\nstatic inline void dx_set_limit(struct dx_entry *entries, unsigned value)\n{\n\t((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);\n}\n\nstatic inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned int entry_space = dir->i_sb->s_blocksize -\n\t\t\text4_dir_rec_len(1, NULL) -\n\t\t\text4_dir_rec_len(2, NULL) - infosize;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n\nstatic inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned int entry_space = dir->i_sb->s_blocksize -\n\t\t\text4_dir_rec_len(0, dir);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n\n \n#ifdef DX_DEBUG\nstatic void dx_show_index(char * label, struct dx_entry *entries)\n{\n\tint i, n = dx_get_count (entries);\n\tprintk(KERN_DEBUG \"%s index\", label);\n\tfor (i = 0; i < n; i++) {\n\t\tprintk(KERN_CONT \" %x->%lu\",\n\t\t       i ? dx_get_hash(entries + i) : 0,\n\t\t       (unsigned long)dx_get_block(entries + i));\n\t}\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstruct stats\n{\n\tunsigned names;\n\tunsigned space;\n\tunsigned bcount;\n};\n\nstatic struct stats dx_show_leaf(struct inode *dir,\n\t\t\t\tstruct dx_hash_info *hinfo,\n\t\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\t\tint size, int show_names)\n{\n\tunsigned names = 0, space = 0;\n\tchar *base = (char *) de;\n\tstruct dx_hash_info h = *hinfo;\n\n\tprintk(\"names: \");\n\twhile ((char *) de < base + size)\n\t{\n\t\tif (de->inode)\n\t\t{\n\t\t\tif (show_names)\n\t\t\t{\n#ifdef CONFIG_FS_ENCRYPTION\n\t\t\t\tint len;\n\t\t\t\tchar *name;\n\t\t\t\tstruct fscrypt_str fname_crypto_str =\n\t\t\t\t\tFSTR_INIT(NULL, 0);\n\t\t\t\tint res = 0;\n\n\t\t\t\tname  = de->name;\n\t\t\t\tlen = de->name_len;\n\t\t\t\tif (!IS_ENCRYPTED(dir)) {\n\t\t\t\t\t \n\t\t\t\t\t(void) ext4fs_dirhash(dir, de->name,\n\t\t\t\t\t\tde->name_len, &h);\n\t\t\t\t\tprintk(\"%*.s:(U)%x.%u \", len,\n\t\t\t\t\t       name, h.hash,\n\t\t\t\t\t       (unsigned) ((char *) de\n\t\t\t\t\t\t\t   - base));\n\t\t\t\t} else {\n\t\t\t\t\tstruct fscrypt_str de_name =\n\t\t\t\t\t\tFSTR_INIT(name, len);\n\n\t\t\t\t\t \n\t\t\t\t\tres = fscrypt_fname_alloc_buffer(\n\t\t\t\t\t\tlen, &fname_crypto_str);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\tprintk(KERN_WARNING \"Error \"\n\t\t\t\t\t\t\t\"allocating crypto \"\n\t\t\t\t\t\t\t\"buffer--skipping \"\n\t\t\t\t\t\t\t\"crypto\\n\");\n\t\t\t\t\tres = fscrypt_fname_disk_to_usr(dir,\n\t\t\t\t\t\t0, 0, &de_name,\n\t\t\t\t\t\t&fname_crypto_str);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tprintk(KERN_WARNING \"Error \"\n\t\t\t\t\t\t\t\"converting filename \"\n\t\t\t\t\t\t\t\"from disk to usr\"\n\t\t\t\t\t\t\t\"\\n\");\n\t\t\t\t\t\tname = \"??\";\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = fname_crypto_str.name;\n\t\t\t\t\t\tlen = fname_crypto_str.len;\n\t\t\t\t\t}\n\t\t\t\t\tif (IS_CASEFOLDED(dir))\n\t\t\t\t\t\th.hash = EXT4_DIRENT_HASH(de);\n\t\t\t\t\telse\n\t\t\t\t\t\t(void) ext4fs_dirhash(dir,\n\t\t\t\t\t\t\tde->name,\n\t\t\t\t\t\t\tde->name_len, &h);\n\t\t\t\t\tprintk(\"%*.s:(E)%x.%u \", len, name,\n\t\t\t\t\t       h.hash, (unsigned) ((char *) de\n\t\t\t\t\t\t\t\t   - base));\n\t\t\t\t\tfscrypt_fname_free_buffer(\n\t\t\t\t\t\t\t&fname_crypto_str);\n\t\t\t\t}\n#else\n\t\t\t\tint len = de->name_len;\n\t\t\t\tchar *name = de->name;\n\t\t\t\t(void) ext4fs_dirhash(dir, de->name,\n\t\t\t\t\t\t      de->name_len, &h);\n\t\t\t\tprintk(\"%*.s:%x.%u \", len, name, h.hash,\n\t\t\t\t       (unsigned) ((char *) de - base));\n#endif\n\t\t\t}\n\t\t\tspace += ext4_dir_rec_len(de->name_len, dir);\n\t\t\tnames++;\n\t\t}\n\t\tde = ext4_next_entry(de, size);\n\t}\n\tprintk(KERN_CONT \"(%i)\\n\", names);\n\treturn (struct stats) { names, space, 1 };\n}\n\nstruct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tbh = ext4_bread(NULL,dir, block, 0);\n\t\tif (!bh || IS_ERR(bh))\n\t\t\tcontinue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *)\n\t\t\tbh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}\n\n \nstatic inline void htree_rep_invariant_check(struct dx_entry *at,\n\t\t\t\t\t     struct dx_entry *target,\n\t\t\t\t\t     u32 hash, unsigned int n)\n{\n\twhile (n--) {\n\t\tdxtrace(printk(KERN_CONT \",\"));\n\t\tif (dx_get_hash(++at) > hash) {\n\t\t\tat--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tASSERT(at == target - 1);\n}\n#else  \nstatic inline void htree_rep_invariant_check(struct dx_entry *at,\n\t\t\t\t\t     struct dx_entry *target,\n\t\t\t\t\t     u32 hash, unsigned int n)\n{\n}\n#endif  \n\n \nstatic struct dx_frame *\ndx_probe(struct ext4_filename *fname, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in)\n{\n\tunsigned count, indirect, level, i;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct dx_frame *frame = frame_in;\n\tstruct dx_frame *ret_err = ERR_PTR(ERR_BAD_DX_DIR);\n\tu32 hash;\n\text4_lblk_t block;\n\text4_lblk_t blocks[EXT4_HTREE_LEVEL];\n\n\tmemset(frame_in, 0, EXT4_HTREE_LEVEL * sizeof(frame_in[0]));\n\tframe->bh = ext4_read_dirblock(dir, 0, INDEX);\n\tif (IS_ERR(frame->bh))\n\t\treturn (struct dx_frame *) frame->bh;\n\n\troot = (struct dx_root *) frame->bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY &&\n\t    root->info.hash_version != DX_HASH_SIPHASH) {\n\t\text4_warning_inode(dir, \"Unrecognised inode hash code %u\",\n\t\t\t\t   root->info.hash_version);\n\t\tgoto fail;\n\t}\n\tif (ext4_hash_in_dirent(dir)) {\n\t\tif (root->info.hash_version != DX_HASH_SIPHASH) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"Hash in dirent, but hash is not SIPHASH\");\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tif (root->info.hash_version == DX_HASH_SIPHASH) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"Hash code is SIPHASH, but hash not in dirent\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (fname)\n\t\thinfo = &fname->hinfo;\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t \n\tif (fname && fname_name(fname) &&\n\t    !(IS_ENCRYPTED(dir) && IS_CASEFOLDED(dir))) {\n\t\tint ret = ext4fs_dirhash(dir, fname_name(fname),\n\t\t\t\t\t fname_len(fname), hinfo);\n\t\tif (ret < 0) {\n\t\t\tret_err = ERR_PTR(ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning_inode(dir, \"Unimplemented hash flags: %#06x\",\n\t\t\t\t   root->info.unused_flags);\n\t\tgoto fail;\n\t}\n\n\tindirect = root->info.indirect_levels;\n\tif (indirect >= ext4_dir_htree_level(dir->i_sb)) {\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Directory (ino: %lu) htree depth %#06x exceed\"\n\t\t\t     \"supported value\", dir->i_ino,\n\t\t\t     ext4_dir_htree_level(dir->i_sb));\n\t\tif (ext4_dir_htree_level(dir->i_sb) < EXT4_HTREE_LEVEL) {\n\t\t\text4_warning(dir->i_sb, \"Enable large directory \"\n\t\t\t\t\t\t\"feature to access it\");\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tentries = (struct dx_entry *)(((char *)&root->info) +\n\t\t\t\t      root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning_inode(dir, \"dx entry: limit %u != root limit %u\",\n\t\t\t\t   dx_get_limit(entries),\n\t\t\t\t   dx_root_limit(dir, root->info.info_length));\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\tlevel = 0;\n\tblocks[0] = 0;\n\twhile (1) {\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\t   \"dx entry: count %u beyond limit %u\",\n\t\t\t\t\t   count, dx_get_limit(entries));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q) {\n\t\t\tm = p + (q - p) / 2;\n\t\t\tdxtrace(printk(KERN_CONT \".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\thtree_rep_invariant_check(entries, p, hash, count - 1);\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(KERN_CONT \" %x->%u\\n\",\n\t\t\t       at == entries ? 0 : dx_get_hash(at),\n\t\t\t       dx_get_block(at)));\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\n\t\tblock = dx_get_block(at);\n\t\tfor (i = 0; i <= level; i++) {\n\t\t\tif (blocks[i] == block) {\n\t\t\t\text4_warning_inode(dir,\n\t\t\t\t\t\"dx entry: tree cycle block %u points back to block %u\",\n\t\t\t\t\tblocks[level], block);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tif (++level > indirect)\n\t\t\treturn frame;\n\t\tblocks[level] = block;\n\t\tframe++;\n\t\tframe->bh = ext4_read_dirblock(dir, block, INDEX);\n\t\tif (IS_ERR(frame->bh)) {\n\t\t\tret_err = (struct dx_frame *) frame->bh;\n\t\t\tframe->bh = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tentries = ((struct dx_node *) frame->bh->b_data)->entries;\n\n\t\tif (dx_get_limit(entries) != dx_node_limit(dir)) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"dx entry: limit %u != node limit %u\",\n\t\t\t\tdx_get_limit(entries), dx_node_limit(dir));\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\n\n\tif (ret_err == ERR_PTR(ERR_BAD_DX_DIR))\n\t\text4_warning_inode(dir,\n\t\t\t\"Corrupt directory, running e2fsck is recommended\");\n\treturn ret_err;\n}\n\nstatic void dx_release(struct dx_frame *frames)\n{\n\tstruct dx_root_info *info;\n\tint i;\n\tunsigned int indirect_levels;\n\n\tif (frames[0].bh == NULL)\n\t\treturn;\n\n\tinfo = &((struct dx_root *)frames[0].bh->b_data)->info;\n\t \n\tindirect_levels = info->indirect_levels;\n\tfor (i = 0; i <= indirect_levels; i++) {\n\t\tif (frames[i].bh == NULL)\n\t\t\tbreak;\n\t\tbrelse(frames[i].bh);\n\t\tframes[i].bh = NULL;\n\t}\n}\n\n \nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash)\n{\n\tstruct dx_frame *p;\n\tstruct buffer_head *bh;\n\tint num_frames = 0;\n\t__u32 bhash;\n\n\tp = frame;\n\t \n\twhile (1) {\n\t\tif (++(p->at) < p->entries + dx_get_count(p->entries))\n\t\t\tbreak;\n\t\tif (p == frames)\n\t\t\treturn 0;\n\t\tnum_frames++;\n\t\tp--;\n\t}\n\n\t \n\tbhash = dx_get_hash(p->at);\n\tif (start_hash)\n\t\t*start_hash = bhash;\n\tif ((hash & 1) == 0) {\n\t\tif ((bhash & ~1) != hash)\n\t\t\treturn 0;\n\t}\n\t \n\twhile (num_frames--) {\n\t\tbh = ext4_read_dirblock(dir, dx_get_block(p->at), INDEX);\n\t\tif (IS_ERR(bh))\n\t\t\treturn PTR_ERR(bh);\n\t\tp++;\n\t\tbrelse(p->bh);\n\t\tp->bh = bh;\n\t\tp->at = p->entries = ((struct dx_node *) bh->b_data)->entries;\n\t}\n\treturn 1;\n}\n\n\n \nstatic int htree_dirblock_to_tree(struct file *dir_file,\n\t\t\t\t  struct inode *dir, ext4_lblk_t block,\n\t\t\t\t  struct dx_hash_info *hinfo,\n\t\t\t\t  __u32 start_hash, __u32 start_minor_hash)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *top;\n\tint err = 0, count = 0;\n\tstruct fscrypt_str fname_crypto_str = FSTR_INIT(NULL, 0), tmp_str;\n\tint csum = ext4_has_metadata_csum(dir->i_sb);\n\n\tdxtrace(printk(KERN_INFO \"In htree dirblock_to_tree: block %lu\\n\",\n\t\t\t\t\t\t\t(unsigned long)block));\n\tbh = ext4_read_dirblock(dir, block, DIRENT_HTREE);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t \n\ttop = (struct ext4_dir_entry_2 *) ((char *) de +\n\t\t\t\t\t   dir->i_sb->s_blocksize -\n\t\t\t\t\t   ext4_dir_rec_len(0,\n\t\t\t\t\t\t\t   csum ? NULL : dir));\n\t \n\tif (IS_ENCRYPTED(dir)) {\n\t\terr = fscrypt_prepare_readdir(dir);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t\terr = fscrypt_fname_alloc_buffer(EXT4_NAME_LEN,\n\t\t\t\t\t\t &fname_crypto_str);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (; de < top; de = ext4_next_entry(de, dir->i_sb->s_blocksize)) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\tbh->b_data, bh->b_size,\n\t\t\t\t(block<<EXT4_BLOCK_SIZE_BITS(dir->i_sb))\n\t\t\t\t\t + ((char *)de - bh->b_data))) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tif (ext4_hash_in_dirent(dir)) {\n\t\t\tif (de->name_len && de->inode) {\n\t\t\t\thinfo->hash = EXT4_DIRENT_HASH(de);\n\t\t\t\thinfo->minor_hash = EXT4_DIRENT_MINOR_HASH(de);\n\t\t\t} else {\n\t\t\t\thinfo->hash = 0;\n\t\t\t\thinfo->minor_hash = 0;\n\t\t\t}\n\t\t} else {\n\t\t\terr = ext4fs_dirhash(dir, de->name,\n\t\t\t\t\t     de->name_len, hinfo);\n\t\t\tif (err < 0) {\n\t\t\t\tcount = err;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\t\tif ((hinfo->hash < start_hash) ||\n\t\t    ((hinfo->hash == start_hash) &&\n\t\t     (hinfo->minor_hash < start_minor_hash)))\n\t\t\tcontinue;\n\t\tif (de->inode == 0)\n\t\t\tcontinue;\n\t\tif (!IS_ENCRYPTED(dir)) {\n\t\t\ttmp_str.name = de->name;\n\t\t\ttmp_str.len = de->name_len;\n\t\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de,\n\t\t\t\t   &tmp_str);\n\t\t} else {\n\t\t\tint save_len = fname_crypto_str.len;\n\t\t\tstruct fscrypt_str de_name = FSTR_INIT(de->name,\n\t\t\t\t\t\t\t\tde->name_len);\n\n\t\t\t \n\t\t\terr = fscrypt_fname_disk_to_usr(dir, hinfo->hash,\n\t\t\t\t\thinfo->minor_hash, &de_name,\n\t\t\t\t\t&fname_crypto_str);\n\t\t\tif (err) {\n\t\t\t\tcount = err;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = ext4_htree_store_dirent(dir_file,\n\t\t\t\t   hinfo->hash, hinfo->minor_hash, de,\n\t\t\t\t\t&fname_crypto_str);\n\t\t\tfname_crypto_str.len = save_len;\n\t\t}\n\t\tif (err != 0) {\n\t\t\tcount = err;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount++;\n\t}\nerrout:\n\tbrelse(bh);\n\tfscrypt_fname_free_buffer(&fname_crypto_str);\n\treturn count;\n}\n\n\n \nint ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\tstruct fscrypt_str tmp_str;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\tif (ext4_hash_in_dirent(dir))\n\t\t\thinfo.hash_version = DX_HASH_SIPHASH;\n\t\telse\n\t\t\thinfo.hash_version =\n\t\t\t\t\tEXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = ext4_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t       &hinfo, start_hash,\n\t\t\t\t\t\t       start_minor_hash,\n\t\t\t\t\t\t       &has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t \n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\ttmp_str.name = de->name;\n\t\ttmp_str.len = de->name_len;\n\t\terr = ext4_htree_store_dirent(dir_file, 0, 0,\n\t\t\t\t\t      de, &tmp_str);\n\t\tif (err != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\ttmp_str.name = de->name;\n\t\ttmp_str.len = de->name_len;\n\t\terr = ext4_htree_store_dirent(dir_file, 2, 0,\n\t\t\t\t\t      de, &tmp_str);\n\t\tif (err != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto errout;\n\t\t}\n\t\tcond_resched();\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t \n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}\n\nstatic inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  struct ext4_filename *fname,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn ext4_search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t       fname, offset, res_dir);\n}\n\n \n\n \nstatic int dx_make_map(struct inode *dir, struct buffer_head *bh,\n\t\t       struct dx_hash_info *hinfo,\n\t\t       struct dx_map_entry *map_tail)\n{\n\tint count = 0;\n\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)bh->b_data;\n\tunsigned int buflen = bh->b_size;\n\tchar *base = bh->b_data;\n\tstruct dx_hash_info h = *hinfo;\n\tint blocksize = EXT4_BLOCK_SIZE(dir->i_sb);\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tbuflen -= sizeof(struct ext4_dir_entry_tail);\n\n\twhile ((char *) de < base + buflen) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, base, buflen,\n\t\t\t\t\t ((char *)de) - base))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (de->name_len && de->inode) {\n\t\t\tif (ext4_hash_in_dirent(dir))\n\t\t\t\th.hash = EXT4_DIRENT_HASH(de);\n\t\t\telse {\n\t\t\t\tint err = ext4fs_dirhash(dir, de->name,\n\t\t\t\t\t\t     de->name_len, &h);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmap_tail--;\n\t\t\tmap_tail->hash = h.hash;\n\t\t\tmap_tail->offs = ((char *) de - base)>>2;\n\t\t\tmap_tail->size = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\tcount++;\n\t\t\tcond_resched();\n\t\t}\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn count;\n}\n\n \nstatic void dx_sort_map (struct dx_map_entry *map, unsigned count)\n{\n\tstruct dx_map_entry *p, *q, *top = map + count - 1;\n\tint more;\n\t \n\twhile (count > 2) {\n\t\tcount = count*10/13;\n\t\tif (count - 9 < 2)  \n\t\t\tcount = 11;\n\t\tfor (p = top, q = p - count; q >= map; p--, q--)\n\t\t\tif (p->hash < q->hash)\n\t\t\t\tswap(*p, *q);\n\t}\n\t \n\tdo {\n\t\tmore = 0;\n\t\tq = top;\n\t\twhile (q-- > map) {\n\t\t\tif (q[1].hash >= q[0].hash)\n\t\t\t\tcontinue;\n\t\t\tswap(*(q+1), *q);\n\t\t\tmore = 1;\n\t\t}\n\t} while(more);\n}\n\nstatic void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)\n{\n\tstruct dx_entry *entries = frame->entries;\n\tstruct dx_entry *old = frame->at, *new = old + 1;\n\tint count = dx_get_count(entries);\n\n\tASSERT(count < dx_get_limit(entries));\n\tASSERT(old < entries + count);\n\tmemmove(new + 1, new, (char *)(entries + count) - (char *)(new));\n\tdx_set_hash(new, hash);\n\tdx_set_block(new, block);\n\tdx_set_count(entries, count + 1);\n}\n\n#if IS_ENABLED(CONFIG_UNICODE)\n \nstatic int ext4_ci_compare(const struct inode *parent, const struct qstr *name,\n\t\t\t   u8 *de_name, size_t de_name_len, bool quick)\n{\n\tconst struct super_block *sb = parent->i_sb;\n\tconst struct unicode_map *um = sb->s_encoding;\n\tstruct fscrypt_str decrypted_name = FSTR_INIT(NULL, de_name_len);\n\tstruct qstr entry = QSTR_INIT(de_name, de_name_len);\n\tint ret;\n\n\tif (IS_ENCRYPTED(parent)) {\n\t\tconst struct fscrypt_str encrypted_name =\n\t\t\t\tFSTR_INIT(de_name, de_name_len);\n\n\t\tdecrypted_name.name = kmalloc(de_name_len, GFP_KERNEL);\n\t\tif (!decrypted_name.name)\n\t\t\treturn -ENOMEM;\n\t\tret = fscrypt_fname_disk_to_usr(parent, 0, 0, &encrypted_name,\n\t\t\t\t\t\t&decrypted_name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tentry.name = decrypted_name.name;\n\t\tentry.len = decrypted_name.len;\n\t}\n\n\tif (quick)\n\t\tret = utf8_strncasecmp_folded(um, name, &entry);\n\telse\n\t\tret = utf8_strncasecmp(um, name, &entry);\n\tif (ret < 0) {\n\t\t \n\t\tif (sb_has_strict_encoding(sb))\n\t\t\tret = -EINVAL;\n\t\telse if (name->len != entry.len)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = !!memcmp(name->name, entry.name, entry.len);\n\t}\nout:\n\tkfree(decrypted_name.name);\n\treturn ret;\n}\n\nint ext4_fname_setup_ci_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t\t  struct ext4_filename *name)\n{\n\tstruct fscrypt_str *cf_name = &name->cf_name;\n\tstruct dx_hash_info *hinfo = &name->hinfo;\n\tint len;\n\n\tif (!IS_CASEFOLDED(dir) ||\n\t    (IS_ENCRYPTED(dir) && !fscrypt_has_encryption_key(dir))) {\n\t\tcf_name->name = NULL;\n\t\treturn 0;\n\t}\n\n\tcf_name->name = kmalloc(EXT4_NAME_LEN, GFP_NOFS);\n\tif (!cf_name->name)\n\t\treturn -ENOMEM;\n\n\tlen = utf8_casefold(dir->i_sb->s_encoding,\n\t\t\t    iname, cf_name->name,\n\t\t\t    EXT4_NAME_LEN);\n\tif (len <= 0) {\n\t\tkfree(cf_name->name);\n\t\tcf_name->name = NULL;\n\t}\n\tcf_name->len = (unsigned) len;\n\tif (!IS_ENCRYPTED(dir))\n\t\treturn 0;\n\n\thinfo->hash_version = DX_HASH_SIPHASH;\n\thinfo->seed = NULL;\n\tif (cf_name->name)\n\t\treturn ext4fs_dirhash(dir, cf_name->name, cf_name->len, hinfo);\n\telse\n\t\treturn ext4fs_dirhash(dir, iname->name, iname->len, hinfo);\n}\n#endif\n\n \nstatic bool ext4_match(struct inode *parent,\n\t\t\t      const struct ext4_filename *fname,\n\t\t\t      struct ext4_dir_entry_2 *de)\n{\n\tstruct fscrypt_name f;\n\n\tif (!de->inode)\n\t\treturn false;\n\n\tf.usr_fname = fname->usr_fname;\n\tf.disk_name = fname->disk_name;\n#ifdef CONFIG_FS_ENCRYPTION\n\tf.crypto_buf = fname->crypto_buf;\n#endif\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (IS_CASEFOLDED(parent) &&\n\t    (!IS_ENCRYPTED(parent) || fscrypt_has_encryption_key(parent))) {\n\t\tif (fname->cf_name.name) {\n\t\t\tstruct qstr cf = {.name = fname->cf_name.name,\n\t\t\t\t\t  .len = fname->cf_name.len};\n\t\t\tif (IS_ENCRYPTED(parent)) {\n\t\t\t\tif (fname->hinfo.hash != EXT4_DIRENT_HASH(de) ||\n\t\t\t\t\tfname->hinfo.minor_hash !=\n\t\t\t\t\t\tEXT4_DIRENT_MINOR_HASH(de)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !ext4_ci_compare(parent, &cf, de->name,\n\t\t\t\t\t\t\tde->name_len, true);\n\t\t}\n\t\treturn !ext4_ci_compare(parent, fname->usr_fname, de->name,\n\t\t\t\t\t\tde->name_len, false);\n\t}\n#endif\n\n\treturn fscrypt_match_name(&f, de->name, de->name_len);\n}\n\n \nint ext4_search_dir(struct buffer_head *bh, char *search_buf, int buf_size,\n\t\t    struct inode *dir, struct ext4_filename *fname,\n\t\t    unsigned int offset, struct ext4_dir_entry_2 **res_dir)\n{\n\tstruct ext4_dir_entry_2 * de;\n\tchar * dlimit;\n\tint de_len;\n\n\tde = (struct ext4_dir_entry_2 *)search_buf;\n\tdlimit = search_buf + buf_size;\n\twhile ((char *) de < dlimit - EXT4_BASE_DIR_LEN) {\n\t\t \n\t\t \n\t\tif (de->name + de->name_len <= dlimit &&\n\t\t    ext4_match(dir, fname, de)) {\n\t\t\t \n\t\t\tif (ext4_check_dir_entry(dir, NULL, de, bh, search_buf,\n\t\t\t\t\t\t buf_size, offset))\n\t\t\t\treturn -1;\n\t\t\t*res_dir = de;\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tde_len = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\t\tif (de_len <= 0)\n\t\t\treturn -1;\n\t\toffset += de_len;\n\t\tde = (struct ext4_dir_entry_2 *) ((char *) de + de_len);\n\t}\n\treturn 0;\n}\n\nstatic int is_dx_internal_node(struct inode *dir, ext4_lblk_t block,\n\t\t\t       struct ext4_dir_entry *de)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (!is_dx(dir))\n\t\treturn 0;\n\tif (block == 0)\n\t\treturn 1;\n\tif (de->inode == 0 &&\n\t    ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) ==\n\t\t\tsb->s_blocksize)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct buffer_head *__ext4_find_entry(struct inode *dir,\n\t\t\t\t\t     struct ext4_filename *fname,\n\t\t\t\t\t     struct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\t     int *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block;\n\tconst u8 *name = fname->usr_fname->name;\n\tsize_t ra_max = 0;\t \n\tsize_t ra_ptr = 0;\t \n\text4_lblk_t  nblocks;\n\tint i, namelen, retval;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = fname->usr_fname->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, fname, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (inlined)\n\t\t\t*inlined = has_inline_data;\n\t\tif (has_inline_data)\n\t\t\tgoto cleanup_and_exit;\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t \n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tret = ext4_dx_find_entry(dir, fname, res_dir);\n\t\t \n\t\tif (!IS_ERR(ret) || PTR_ERR(ret) != ERR_BAD_DX_DIR)\n\t\t\tgoto cleanup_and_exit;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t\tret = NULL;\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (!nblocks) {\n\t\tret = NULL;\n\t\tgoto cleanup_and_exit;\n\t}\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t \n\t\tcond_resched();\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t \n\t\t\tra_ptr = 0;\n\t\t\tif (block < start)\n\t\t\t\tra_max = start - block;\n\t\t\telse\n\t\t\t\tra_max = nblocks - block;\n\t\t\tra_max = min(ra_max, ARRAY_SIZE(bh_use));\n\t\t\tretval = ext4_bread_batch(dir, block, ra_max,\n\t\t\t\t\t\t  false  , bh_use);\n\t\t\tif (retval) {\n\t\t\t\tret = ERR_PTR(retval);\n\t\t\t\tra_max = 0;\n\t\t\t\tgoto cleanup_and_exit;\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_ERR(dir, EIO,\n\t\t\t\t\t     \"reading directory lblock %lu\",\n\t\t\t\t\t     (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tret = ERR_PTR(-EIO);\n\t\t\tgoto cleanup_and_exit;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirblock_csum_verify(dir, bh)) {\n\t\t\tEXT4_ERROR_INODE_ERR(dir, EFSBADCRC,\n\t\t\t\t\t     \"checksumming directory \"\n\t\t\t\t\t     \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tret = ERR_PTR(-EFSBADCRC);\n\t\t\tgoto cleanup_and_exit;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, fname,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t \n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t \n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}\n\nstatic struct buffer_head *ext4_find_entry(struct inode *dir,\n\t\t\t\t\t   const struct qstr *d_name,\n\t\t\t\t\t   struct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\t   int *inlined)\n{\n\tint err;\n\tstruct ext4_filename fname;\n\tstruct buffer_head *bh;\n\n\terr = ext4_fname_setup_filename(dir, d_name, 1, &fname);\n\tif (err == -ENOENT)\n\t\treturn NULL;\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tbh = __ext4_find_entry(dir, &fname, res_dir, inlined);\n\n\text4_fname_free_filename(&fname);\n\treturn bh;\n}\n\nstatic struct buffer_head *ext4_lookup_entry(struct inode *dir,\n\t\t\t\t\t     struct dentry *dentry,\n\t\t\t\t\t     struct ext4_dir_entry_2 **res_dir)\n{\n\tint err;\n\tstruct ext4_filename fname;\n\tstruct buffer_head *bh;\n\n\terr = ext4_fname_prepare_lookup(dir, dentry, &fname);\n\tgeneric_set_encrypted_ci_d_ops(dentry);\n\tif (err == -ENOENT)\n\t\treturn NULL;\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tbh = __ext4_find_entry(dir, &fname, res_dir, NULL);\n\n\text4_fname_free_filename(&fname);\n\treturn bh;\n}\n\nstatic struct buffer_head * ext4_dx_find_entry(struct inode *dir,\n\t\t\tstruct ext4_filename *fname,\n\t\t\tstruct ext4_dir_entry_2 **res_dir)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct buffer_head *bh;\n\text4_lblk_t block;\n\tint retval;\n\n#ifdef CONFIG_FS_ENCRYPTION\n\t*res_dir = NULL;\n#endif\n\tframe = dx_probe(fname, dir, NULL, frames);\n\tif (IS_ERR(frame))\n\t\treturn (struct buffer_head *) frame;\n\tdo {\n\t\tblock = dx_get_block(frame->at);\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT_HTREE);\n\t\tif (IS_ERR(bh))\n\t\t\tgoto errout;\n\n\t\tretval = search_dirblock(bh, dir, fname,\n\t\t\t\t\t block << EXT4_BLOCK_SIZE_BITS(sb),\n\t\t\t\t\t res_dir);\n\t\tif (retval == 1)\n\t\t\tgoto success;\n\t\tbrelse(bh);\n\t\tif (retval == -1) {\n\t\t\tbh = ERR_PTR(ERR_BAD_DX_DIR);\n\t\t\tgoto errout;\n\t\t}\n\n\t\t \n\t\tretval = ext4_htree_next_block(dir, fname->hinfo.hash, frame,\n\t\t\t\t\t       frames, NULL);\n\t\tif (retval < 0) {\n\t\t\text4_warning_inode(dir,\n\t\t\t\t\"error %d reading directory index block\",\n\t\t\t\tretval);\n\t\t\tbh = ERR_PTR(retval);\n\t\t\tgoto errout;\n\t\t}\n\t} while (retval == 1);\n\n\tbh = NULL;\nerrout:\n\tdxtrace(printk(KERN_DEBUG \"%s not found\\n\", fname->usr_fname->name));\nsuccess:\n\tdx_release(frames);\n\treturn bh;\n}\n\nstatic struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct buffer_head *bh;\n\n\tif (dentry->d_name.len > EXT4_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbh = ext4_lookup_entry(dir, dentry, &de);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tinode = NULL;\n\tif (bh) {\n\t\t__u32 ino = le32_to_cpu(de->inode);\n\t\tbrelse(bh);\n\t\tif (!ext4_valid_inum(dir->i_sb, ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"bad inode number: %u\", ino);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tif (unlikely(ino == dir->i_ino)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"'%pd' linked to parent dir\",\n\t\t\t\t\t dentry);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tinode = ext4_iget(dir->i_sb, ino, EXT4_IGET_NORMAL);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\t \"deleted inode referenced: %u\",\n\t\t\t\t\t ino);\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tif (!IS_ERR(inode) && IS_ENCRYPTED(dir) &&\n\t\t    (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&\n\t\t    !fscrypt_has_permitted_context(dir, inode)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"Inconsistent encryption contexts: %lu/%lu\",\n\t\t\t\t     dir->i_ino, inode->i_ino);\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-EPERM);\n\t\t}\n\t}\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (!inode && IS_CASEFOLDED(dir)) {\n\t\t \n\t\treturn NULL;\n\t}\n#endif\n\treturn d_splice_alias(inode, dentry);\n}\n\n\nstruct dentry *ext4_get_parent(struct dentry *child)\n{\n\t__u32 ino;\n\tstruct ext4_dir_entry_2 * de;\n\tstruct buffer_head *bh;\n\n\tbh = ext4_find_entry(d_inode(child), &dotdot_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tif (!bh)\n\t\treturn ERR_PTR(-ENOENT);\n\tino = le32_to_cpu(de->inode);\n\tbrelse(bh);\n\n\tif (!ext4_valid_inum(child->d_sb, ino)) {\n\t\tEXT4_ERROR_INODE(d_inode(child),\n\t\t\t\t \"bad parent inode number: %u\", ino);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\treturn d_obtain_alias(ext4_iget(child->d_sb, ino, EXT4_IGET_NORMAL));\n}\n\n \nstatic struct ext4_dir_entry_2 *\ndx_move_dirents(struct inode *dir, char *from, char *to,\n\t\tstruct dx_map_entry *map, int count,\n\t\tunsigned blocksize)\n{\n\tunsigned rec_len = 0;\n\n\twhile (count--) {\n\t\tstruct ext4_dir_entry_2 *de = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t\t(from + (map->offs<<2));\n\t\trec_len = ext4_dir_rec_len(de->name_len, dir);\n\n\t\tmemcpy (to, de, rec_len);\n\t\t((struct ext4_dir_entry_2 *) to)->rec_len =\n\t\t\t\text4_rec_len_to_disk(rec_len, blocksize);\n\n\t\t \n\t\tde->inode = 0;\n\t\tmemset(&de->name_len, 0, ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t\tblocksize) -\n\t\t\t\t\t offsetof(struct ext4_dir_entry_2,\n\t\t\t\t\t\t\t\tname_len));\n\n\t\tmap++;\n\t\tto += rec_len;\n\t}\n\treturn (struct ext4_dir_entry_2 *) (to - rec_len);\n}\n\n \nstatic struct ext4_dir_entry_2 *dx_pack_dirents(struct inode *dir, char *base,\n\t\t\t\t\t\t\tunsigned int blocksize)\n{\n\tstruct ext4_dir_entry_2 *next, *to, *prev, *de = (struct ext4_dir_entry_2 *) base;\n\tunsigned rec_len = 0;\n\n\tprev = to = de;\n\twhile ((char*)de < base + blocksize) {\n\t\tnext = ext4_next_entry(de, blocksize);\n\t\tif (de->inode && de->name_len) {\n\t\t\trec_len = ext4_dir_rec_len(de->name_len, dir);\n\t\t\tif (de > to)\n\t\t\t\tmemmove(to, de, rec_len);\n\t\t\tto->rec_len = ext4_rec_len_to_disk(rec_len, blocksize);\n\t\t\tprev = to;\n\t\t\tto = (struct ext4_dir_entry_2 *) (((char *) to) + rec_len);\n\t\t}\n\t\tde = next;\n\t}\n\treturn prev;\n}\n\n \nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned continued;\n\tint count;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, *bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, frame->bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t \n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, *bh, hinfo, map);\n\tif (count < 0) {\n\t\terr = count;\n\t\tgoto journal_error;\n\t}\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t \n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t \n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t \n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t \n\tde2 = dx_move_dirents(dir, data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(dir, data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t \n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n\nint ext4_find_dest_de(struct inode *dir, struct inode *inode,\n\t\t      struct buffer_head *bh,\n\t\t      void *buf, int buf_size,\n\t\t      struct ext4_filename *fname,\n\t\t      struct ext4_dir_entry_2 **dest_de)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tunsigned short reclen = ext4_dir_rec_len(fname_len(fname), dir);\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = buf;\n\ttop = buf + buf_size - reclen;\n\twhile ((char *) de <= top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (ext4_match(dir, fname, de))\n\t\t\treturn -EEXIST;\n\t\tnlen = ext4_dir_rec_len(de->name_len, dir);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tif ((de->inode ? rlen - nlen : rlen) >= reclen)\n\t\t\tbreak;\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -ENOSPC;\n\n\t*dest_de = de;\n\treturn 0;\n}\n\nvoid ext4_insert_dentry(struct inode *dir,\n\t\t\tstruct inode *inode,\n\t\t\tstruct ext4_dir_entry_2 *de,\n\t\t\tint buf_size,\n\t\t\tstruct ext4_filename *fname)\n{\n\n\tint nlen, rlen;\n\n\tnlen = ext4_dir_rec_len(de->name_len, dir);\n\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\tif (de->inode) {\n\t\tstruct ext4_dir_entry_2 *de1 =\n\t\t\t(struct ext4_dir_entry_2 *)((char *)de + nlen);\n\t\tde1->rec_len = ext4_rec_len_to_disk(rlen - nlen, buf_size);\n\t\tde->rec_len = ext4_rec_len_to_disk(nlen, buf_size);\n\t\tde = de1;\n\t}\n\tde->file_type = EXT4_FT_UNKNOWN;\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text4_set_de_type(inode->i_sb, de, inode->i_mode);\n\tde->name_len = fname_len(fname);\n\tmemcpy(de->name, fname_name(fname), fname_len(fname));\n\tif (ext4_hash_in_dirent(dir)) {\n\t\tstruct dx_hash_info *hinfo = &fname->hinfo;\n\n\t\tEXT4_DIRENT_HASHES(de)->hash = cpu_to_le32(hinfo->hash);\n\t\tEXT4_DIRENT_HASHES(de)->minor_hash =\n\t\t\t\t\t\tcpu_to_le32(hinfo->minor_hash);\n\t}\n}\n\n \nstatic int add_dirent_to_buf(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir,\n\t\t\t     struct inode *inode, struct ext4_dir_entry_2 *de,\n\t\t\t     struct buffer_head *bh)\n{\n\tunsigned int\tblocksize = dir->i_sb->s_blocksize;\n\tint\t\tcsum_size = 0;\n\tint\t\terr, err2;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (!de) {\n\t\terr = ext4_find_dest_de(dir, inode, bh, bh->b_data,\n\t\t\t\t\tblocksize - csum_size, fname, &de);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err) {\n\t\text4_std_error(dir->i_sb, err);\n\t\treturn err;\n\t}\n\n\t \n\text4_insert_dentry(dir, inode, de, blocksize, fname);\n\n\t \n\tdir->i_mtime = inode_set_ctime_current(dir);\n\text4_update_dx_flag(dir);\n\tinode_inc_iversion(dir);\n\terr2 = ext4_mark_inode_dirty(handle, dir);\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh);\n\tif (err)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err ? err : err2;\n}\n\n \nstatic int make_indexed_dir(handle_t *handle, struct ext4_filename *fname,\n\t\t\t    struct inode *dir,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[EXT4_HTREE_LEVEL], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data2, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\tint csum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\tretval = ext4_journal_get_write_access(handle, dir->i_sb, bh,\n\t\t\t\t\t       EXT4_JTR_NONE);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t \n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len, blocksize));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\tEXT4_ERROR_INODE(dir, \"invalid rec_len for '..'\");\n\t\tbrelse(bh);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tlen = ((char *) root) + (blocksize - csum_size) - (char *) de;\n\n\t \n\tbh2 = ext4_append(handle, dir, &block);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(bh);\n\t\treturn PTR_ERR(bh2);\n\t}\n\text4_set_inode_flag(dir, EXT4_INODE_INDEX);\n\tdata2 = bh2->b_data;\n\n\tmemcpy(data2, de, len);\n\tmemset(de, 0, len);  \n\tde = (struct ext4_dir_entry_2 *) data2;\n\ttop = data2 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de, blocksize)) < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh2, data2, len,\n\t\t\t\t\t (data2 + (blocksize - csum_size) -\n\t\t\t\t\t  (char *) de))) {\n\t\t\tbrelse(bh2);\n\t\t\tbrelse(bh);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tde = de2;\n\t}\n\tde->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de, blocksize);\n\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\n\t \n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\tblocksize - ext4_dir_rec_len(2, NULL), blocksize);\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\tif (ext4_hash_in_dirent(dir))\n\t\troot->info.hash_version = DX_HASH_SIPHASH;\n\telse\n\t\troot->info.hash_version =\n\t\t\t\tEXT4_SB(dir->i_sb)->s_def_hash_version;\n\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t \n\tfname->hinfo.hash_version = root->info.hash_version;\n\tif (fname->hinfo.hash_version <= DX_HASH_TEA)\n\t\tfname->hinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\tfname->hinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\n\t \n\tif (!ext4_hash_in_dirent(dir)) {\n\t\tint err = ext4fs_dirhash(dir, fname_name(fname),\n\t\t\t\t\t fname_len(fname), &fname->hinfo);\n\t\tif (err < 0) {\n\t\t\tbrelse(bh2);\n\t\t\tbrelse(bh);\n\t\t\treturn err;\n\t\t}\n\t}\n\tmemset(frames, 0, sizeof(frames));\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\n\tretval = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (retval)\n\t\tgoto out_frames;\n\tretval = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (retval)\n\t\tgoto out_frames;\n\n\tde = do_split(handle,dir, &bh2, frame, &fname->hinfo);\n\tif (IS_ERR(de)) {\n\t\tretval = PTR_ERR(de);\n\t\tgoto out_frames;\n\t}\n\n\tretval = add_dirent_to_buf(handle, fname, dir, inode, de, bh2);\nout_frames:\n\t \n\tif (retval)\n\t\text4_mark_inode_dirty(handle, dir);\n\tdx_release(frames);\n\tbrelse(bh2);\n\treturn retval;\n}\n\n \nstatic int ext4_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t  struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct ext4_filename fname;\n\tint\tretval;\n\tint\tdx_fallback=0;\n\tunsigned blocksize;\n\text4_lblk_t block, blocks;\n\tint\tcsum_size = 0;\n\n\tif (ext4_has_metadata_csum(inode->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tsb = dir->i_sb;\n\tblocksize = sb->s_blocksize;\n\tif (!dentry->d_name.len)\n\t\treturn -EINVAL;\n\n\tif (fscrypt_is_nokey_name(dentry))\n\t\treturn -ENOKEY;\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (sb_has_strict_encoding(sb) && IS_CASEFOLDED(dir) &&\n\t    utf8_validate(sb->s_encoding, &dentry->d_name))\n\t\treturn -EINVAL;\n#endif\n\n\tretval = ext4_fname_setup_filename(dir, &dentry->d_name, 0, &fname);\n\tif (retval)\n\t\treturn retval;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tretval = ext4_try_add_inline_entry(handle, &fname, dir, inode);\n\t\tif (retval < 0)\n\t\t\tgoto out;\n\t\tif (retval == 1) {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (is_dx(dir)) {\n\t\tretval = ext4_dx_add_entry(handle, &fname, dir, inode);\n\t\tif (!retval || (retval != ERR_BAD_DX_DIR))\n\t\t\tgoto out;\n\t\t \n\t\tif (ext4_has_metadata_csum(sb)) {\n\t\t\tEXT4_ERROR_INODE(dir,\n\t\t\t\t\"Directory has corrupted htree index.\");\n\t\t\tretval = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\text4_clear_inode_flag(dir, EXT4_INODE_INDEX);\n\t\tdx_fallback++;\n\t\tretval = ext4_mark_inode_dirty(handle, dir);\n\t\tif (unlikely(retval))\n\t\t\tgoto out;\n\t}\n\tblocks = dir->i_size >> sb->s_blocksize_bits;\n\tfor (block = 0; block < blocks; block++) {\n\t\tbh = ext4_read_dirblock(dir, block, DIRENT);\n\t\tif (bh == NULL) {\n\t\t\tbh = ext4_bread(handle, dir, block,\n\t\t\t\t\tEXT4_GET_BLOCKS_CREATE);\n\t\t\tgoto add_to_new_block;\n\t\t}\n\t\tif (IS_ERR(bh)) {\n\t\t\tretval = PTR_ERR(bh);\n\t\t\tbh = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tretval = add_dirent_to_buf(handle, &fname, dir, inode,\n\t\t\t\t\t   NULL, bh);\n\t\tif (retval != -ENOSPC)\n\t\t\tgoto out;\n\n\t\tif (blocks == 1 && !dx_fallback &&\n\t\t    ext4_has_feature_dir_index(sb)) {\n\t\t\tretval = make_indexed_dir(handle, &fname, dir,\n\t\t\t\t\t\t  inode, bh);\n\t\t\tbh = NULL;  \n\t\t\tgoto out;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\tbh = ext4_append(handle, dir, &block);\nadd_to_new_block:\n\tif (IS_ERR(bh)) {\n\t\tretval = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto out;\n\t}\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);\n\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(bh, blocksize);\n\n\tretval = add_dirent_to_buf(handle, &fname, dir, inode, de, bh);\nout:\n\text4_fname_free_filename(&fname);\n\tbrelse(bh);\n\tif (retval == 0)\n\t\text4_set_inode_state(inode, EXT4_STATE_NEWENTRY);\n\treturn retval;\n}\n\n \nstatic int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,\n\t\t\t     struct inode *dir, struct inode *inode)\n{\n\tstruct dx_frame frames[EXT4_HTREE_LEVEL], *frame;\n\tstruct dx_entry *entries, *at;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ext4_dir_entry_2 *de;\n\tint restart;\n\tint err;\n\nagain:\n\trestart = 0;\n\tframe = dx_probe(fname, dir, NULL, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\tentries = frame->entries;\n\tat = frame->at;\n\tbh = ext4_read_dirblock(dir, dx_get_block(frame->at), DIRENT_HTREE);\n\tif (IS_ERR(bh)) {\n\t\terr = PTR_ERR(bh);\n\t\tbh = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, bh, EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto journal_error;\n\n\terr = add_dirent_to_buf(handle, fname, dir, inode, NULL, bh);\n\tif (err != -ENOSPC)\n\t\tgoto cleanup;\n\n\terr = 0;\n\t \n\tdxtrace(printk(KERN_DEBUG \"using %u of %u node entries\\n\",\n\t\t       dx_get_count(entries), dx_get_limit(entries)));\n\t \n\tif (dx_get_count(entries) == dx_get_limit(entries)) {\n\t\text4_lblk_t newblock;\n\t\tint levels = frame - frames + 1;\n\t\tunsigned int icount;\n\t\tint add_level = 1;\n\t\tstruct dx_entry *entries2;\n\t\tstruct dx_node *node2;\n\t\tstruct buffer_head *bh2;\n\n\t\twhile (frame > frames) {\n\t\t\tif (dx_get_count((frame - 1)->entries) <\n\t\t\t    dx_get_limit((frame - 1)->entries)) {\n\t\t\t\tadd_level = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe--;  \n\t\t\tat = frame->at;\n\t\t\tentries = frame->entries;\n\t\t\trestart = 1;\n\t\t}\n\t\tif (add_level && levels == ext4_dir_htree_level(sb)) {\n\t\t\text4_warning(sb, \"Directory (ino: %lu) index full, \"\n\t\t\t\t\t \"reach max htree level :%d\",\n\t\t\t\t\t dir->i_ino, levels);\n\t\t\tif (ext4_dir_htree_level(sb) < EXT4_HTREE_LEVEL) {\n\t\t\t\text4_warning(sb, \"Large directory feature is \"\n\t\t\t\t\t\t \"not enabled on this \"\n\t\t\t\t\t\t \"filesystem\");\n\t\t\t}\n\t\t\terr = -ENOSPC;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ticount = dx_get_count(entries);\n\t\tbh2 = ext4_append(handle, dir, &newblock);\n\t\tif (IS_ERR(bh2)) {\n\t\t\terr = PTR_ERR(bh2);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tnode2 = (struct dx_node *)(bh2->b_data);\n\t\tentries2 = node2->entries;\n\t\tmemset(&node2->fake, 0, sizeof(struct fake_dirent));\n\t\tnode2->fake.rec_len = ext4_rec_len_to_disk(sb->s_blocksize,\n\t\t\t\t\t\t\t   sb->s_blocksize);\n\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sb, frame->bh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err)\n\t\t\tgoto journal_error;\n\t\tif (!add_level) {\n\t\t\tunsigned icount1 = icount/2, icount2 = icount - icount1;\n\t\t\tunsigned hash2 = dx_get_hash(entries + icount1);\n\t\t\tdxtrace(printk(KERN_DEBUG \"Split index %i/%i\\n\",\n\t\t\t\t       icount1, icount2));\n\n\t\t\tBUFFER_TRACE(frame->bh, \"get_write_access\");  \n\t\t\terr = ext4_journal_get_write_access(handle, sb,\n\t\t\t\t\t\t\t    (frame - 1)->bh,\n\t\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\n\t\t\tmemcpy((char *) entries2, (char *) (entries + icount1),\n\t\t\t       icount2 * sizeof(struct dx_entry));\n\t\t\tdx_set_count(entries, icount1);\n\t\t\tdx_set_count(entries2, icount2);\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t \n\t\t\tif (at - entries >= icount1) {\n\t\t\t\tframe->at = at - entries - icount1 + entries2;\n\t\t\t\tframe->entries = entries = entries2;\n\t\t\t\tswap(frame->bh, bh2);\n\t\t\t}\n\t\t\tdx_insert_block((frame - 1), hash2, newblock);\n\t\t\tdxtrace(dx_show_index(\"node\", frame->entries));\n\t\t\tdxtrace(dx_show_index(\"node\",\n\t\t\t       ((struct dx_node *) bh2->b_data)->entries));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\tbrelse (bh2);\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t   (frame - 1)->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir,\n\t\t\t\t\t\t\tframe->bh);\n\t\t\tif (restart || err)\n\t\t\t\tgoto journal_error;\n\t\t} else {\n\t\t\tstruct dx_root *dxroot;\n\t\t\tmemcpy((char *) entries2, (char *) entries,\n\t\t\t       icount * sizeof(struct dx_entry));\n\t\t\tdx_set_limit(entries2, dx_node_limit(dir));\n\n\t\t\t \n\t\t\tdx_set_count(entries, 1);\n\t\t\tdx_set_block(entries + 0, newblock);\n\t\t\tdxroot = (struct dx_root *)frames[0].bh->b_data;\n\t\t\tdxroot->info.indirect_levels += 1;\n\t\t\tdxtrace(printk(KERN_DEBUG\n\t\t\t\t       \"Creating %d level index...\\n\",\n\t\t\t\t       dxroot->info.indirect_levels));\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\t\t\tif (err)\n\t\t\t\tgoto journal_error;\n\t\t\terr = ext4_handle_dirty_dx_node(handle, dir, bh2);\n\t\t\tbrelse(bh2);\n\t\t\trestart = 1;\n\t\t\tgoto journal_error;\n\t\t}\n\t}\n\tde = do_split(handle, dir, &bh, frame, &fname->hinfo);\n\tif (IS_ERR(de)) {\n\t\terr = PTR_ERR(de);\n\t\tgoto cleanup;\n\t}\n\terr = add_dirent_to_buf(handle, fname, dir, inode, de, bh);\n\tgoto cleanup;\n\njournal_error:\n\text4_std_error(dir->i_sb, err);  \ncleanup:\n\tbrelse(bh);\n\tdx_release(frames);\n\t \n\tif (restart && err == 0)\n\t\tgoto again;\n\treturn err;\n}\n\n \nint ext4_generic_delete_entry(struct inode *dir,\n\t\t\t      struct ext4_dir_entry_2 *de_del,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *entry_buf,\n\t\t\t      int buf_size,\n\t\t\t      int csum_size)\n{\n\tstruct ext4_dir_entry_2 *de, *pde;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint i;\n\n\ti = 0;\n\tpde = NULL;\n\tde = entry_buf;\n\twhile (i < buf_size - csum_size) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t entry_buf, buf_size, i))\n\t\t\treturn -EFSCORRUPTED;\n\t\tif (de == de_del)  {\n\t\t\tif (pde) {\n\t\t\t\tpde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_rec_len_from_disk(pde->rec_len,\n\t\t\t\t\t\t\t       blocksize) +\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t       blocksize),\n\t\t\t\t\tblocksize);\n\n\t\t\t\t \n\t\t\t\tmemset(de, 0, ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t\tblocksize));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tde->inode = 0;\n\t\t\t\tmemset(&de->name_len, 0,\n\t\t\t\t\text4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t\tblocksize) -\n\t\t\t\t\toffsetof(struct ext4_dir_entry_2,\n\t\t\t\t\t\t\t\tname_len));\n\t\t\t}\n\n\t\t\tinode_inc_iversion(dir);\n\t\t\treturn 0;\n\t\t}\n\t\ti += ext4_rec_len_from_disk(de->rec_len, blocksize);\n\t\tpde = de;\n\t\tde = ext4_next_entry(de, blocksize);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int ext4_delete_entry(handle_t *handle,\n\t\t\t     struct inode *dir,\n\t\t\t     struct ext4_dir_entry_2 *de_del,\n\t\t\t     struct buffer_head *bh)\n{\n\tint err, csum_size = 0;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\terr = ext4_delete_inline_entry(handle, dir, de_del, bh,\n\t\t\t\t\t       &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn err;\n\t}\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, dir->i_sb, bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = ext4_generic_delete_entry(dir, de_del, bh, bh->b_data,\n\t\t\t\t\tdir->i_sb->s_blocksize, csum_size);\n\tif (err)\n\t\tgoto out;\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tif (err != -ENOENT)\n\t\text4_std_error(dir->i_sb, err);\n\treturn err;\n}\n\n \nstatic void ext4_inc_count(struct inode *inode)\n{\n\tinc_nlink(inode);\n\tif (is_dx(inode) &&\n\t    (inode->i_nlink > EXT4_LINK_MAX || inode->i_nlink == 2))\n\t\tset_nlink(inode, 1);\n}\n\n \nstatic void ext4_dec_count(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) || inode->i_nlink > 2)\n\t\tdrop_nlink(inode);\n}\n\n\n \nstatic int ext4_add_nondir(handle_t *handle,\n\t\tstruct dentry *dentry, struct inode **inodep)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tstruct inode *inode = *inodep;\n\tint err = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (IS_DIRSYNC(dir))\n\t\t\text4_handle_sync(handle);\n\t\td_instantiate_new(dentry, inode);\n\t\t*inodep = NULL;\n\t\treturn err;\n\t}\n\tdrop_nlink(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_orphan_add(handle, inode);\n\tunlock_new_inode(inode);\n\treturn err;\n}\n\n \nstatic int ext4_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(idmap, dir, mode, &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\terr = ext4_add_nondir(handle, dentry, &inode);\n\t\tif (!err)\n\t\t\text4_fc_track_create(handle, dentry);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (!IS_ERR_OR_NULL(inode))\n\t\tiput(inode);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, credits, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(idmap, dir, mode, &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\terr = ext4_add_nondir(handle, dentry, &inode);\n\t\tif (!err)\n\t\t\text4_fc_track_create(handle, dentry);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (!IS_ERR_OR_NULL(inode))\n\t\tiput(inode);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct file *file, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\nretry:\n\tinode = ext4_new_inode_start_handle(idmap, dir, mode,\n\t\t\t\t\t    NULL, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR,\n\t\t\tEXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb) +\n\t\t\t  4 + EXT4_XATTR_TRANS_BLOCKS);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\td_tmpfile(file, inode);\n\t\terr = ext4_orphan_add(handle, inode);\n\t\tif (err)\n\t\t\tgoto err_unlock_inode;\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn finish_open_simple(file, err);\nerr_unlock_inode:\n\text4_journal_stop(handle);\n\tunlock_new_inode(inode);\n\treturn err;\n}\n\nstruct ext4_dir_entry_2 *ext4_init_dot_dotdot(struct inode *inode,\n\t\t\t  struct ext4_dir_entry_2 *de,\n\t\t\t  int blocksize, int csum_size,\n\t\t\t  unsigned int parent_ino, int dotdot_real_len)\n{\n\tde->inode = cpu_to_le32(inode->i_ino);\n\tde->name_len = 1;\n\tde->rec_len = ext4_rec_len_to_disk(ext4_dir_rec_len(de->name_len, NULL),\n\t\t\t\t\t   blocksize);\n\tstrcpy(de->name, \".\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\tde = ext4_next_entry(de, blocksize);\n\tde->inode = cpu_to_le32(parent_ino);\n\tde->name_len = 2;\n\tif (!dotdot_real_len)\n\t\tde->rec_len = ext4_rec_len_to_disk(blocksize -\n\t\t\t\t\t(csum_size + ext4_dir_rec_len(1, NULL)),\n\t\t\t\t\tblocksize);\n\telse\n\t\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\t\text4_dir_rec_len(de->name_len, NULL),\n\t\t\t\t\tblocksize);\n\tstrcpy(de->name, \"..\");\n\text4_set_de_type(inode->i_sb, de, S_IFDIR);\n\n\treturn ext4_next_entry(de, blocksize);\n}\n\nint ext4_init_new_dir(handle_t *handle, struct inode *dir,\n\t\t\t     struct inode *inode)\n{\n\tstruct buffer_head *dir_block = NULL;\n\tstruct ext4_dir_entry_2 *de;\n\text4_lblk_t block = 0;\n\tunsigned int blocksize = dir->i_sb->s_blocksize;\n\tint csum_size = 0;\n\tint err;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\terr = ext4_try_create_inline_dir(handle, dir, inode);\n\t\tif (err < 0 && err != -ENOSPC)\n\t\t\tgoto out;\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tinode->i_size = 0;\n\tdir_block = ext4_append(handle, inode, &block);\n\tif (IS_ERR(dir_block))\n\t\treturn PTR_ERR(dir_block);\n\tde = (struct ext4_dir_entry_2 *)dir_block->b_data;\n\text4_init_dot_dotdot(inode, de, blocksize, csum_size, dir->i_ino, 0);\n\tset_nlink(inode, 2);\n\tif (csum_size)\n\t\text4_initialize_dirent_tail(dir_block, blocksize);\n\n\tBUFFER_TRACE(dir_block, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_dirblock(handle, inode, dir_block);\n\tif (err)\n\t\tgoto out;\n\tset_buffer_verified(dir_block);\nout:\n\tbrelse(dir_block);\n\treturn err;\n}\n\nstatic int ext4_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, err2 = 0, credits, retries = 0;\n\n\tif (EXT4_DIR_LINK_MAX(dir))\n\t\treturn -EMLINK;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tcredits = (EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3);\nretry:\n\tinode = ext4_new_inode_start_handle(idmap, dir, S_IFDIR | mode,\n\t\t\t\t\t    &dentry->d_name,\n\t\t\t\t\t    0, NULL, EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_stop;\n\n\tinode->i_op = &ext4_dir_inode_operations;\n\tinode->i_fop = &ext4_dir_operations;\n\terr = ext4_init_new_dir(handle, dir, inode);\n\tif (err)\n\t\tgoto out_clear_inode;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (!err)\n\t\terr = ext4_add_entry(handle, dentry, inode);\n\tif (err) {\nout_clear_inode:\n\t\tclear_nlink(inode);\n\t\text4_orphan_add(handle, inode);\n\t\tunlock_new_inode(inode);\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err2))\n\t\t\terr = err2;\n\t\text4_journal_stop(handle);\n\t\tiput(inode);\n\t\tgoto out_retry;\n\t}\n\text4_inc_count(dir);\n\n\text4_update_dx_flag(dir);\n\terr = ext4_mark_inode_dirty(handle, dir);\n\tif (err)\n\t\tgoto out_clear_inode;\n\td_instantiate_new(dentry, inode);\n\text4_fc_track_create(handle, dentry);\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\tif (handle)\n\t\text4_journal_stop(handle);\nout_retry:\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\n \nbool ext4_empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\tint ret;\n\n\t\tret = empty_inline_dir(inode, &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn ret;\n\t}\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < ext4_dir_rec_len(1, NULL) +\n\t\t\t\t\text4_dir_rec_len(2, NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"invalid size\");\n\t\treturn false;\n\t}\n\t \n\tbh = ext4_read_dirblock(inode, 0, DIRENT_HTREE);\n\tif (IS_ERR(bh))\n\t\treturn false;\n\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data, bh->b_size,\n\t\t\t\t 0) ||\n\t    le32_to_cpu(de->inode) != inode->i_ino || strcmp(\".\", de->name)) {\n\t\text4_warning_inode(inode, \"directory missing '.'\");\n\t\tbrelse(bh);\n\t\treturn false;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de, sb->s_blocksize);\n\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data, bh->b_size,\n\t\t\t\t offset) ||\n\t    le32_to_cpu(de->inode) == 0 || strcmp(\"..\", de->name)) {\n\t\text4_warning_inode(inode, \"directory missing '..'\");\n\t\tbrelse(bh);\n\t\treturn false;\n\t}\n\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif (!(offset & (sb->s_blocksize - 1))) {\n\t\t\tunsigned int lblock;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_read_dirblock(inode, lblock, EITHER);\n\t\t\tif (bh == NULL) {\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn false;\n\t\t}\n\t\tde = (struct ext4_dir_entry_2 *) (bh->b_data +\n\t\t\t\t\t(offset & (sb->s_blocksize - 1)));\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh,\n\t\t\t\t\t bh->b_data, bh->b_size, offset) ||\n\t\t    le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn false;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn true;\n}\n\nstatic int ext4_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle = NULL;\n\n\tif (unlikely(ext4_forced_shutdown(dir->i_sb)))\n\t\treturn -EIO;\n\n\t \n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(d_inode(dentry));\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n\tbh = ext4_find_entry(dir, &dentry->d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (!bh)\n\t\tgoto end_rmdir;\n\n\tinode = d_inode(dentry);\n\n\tretval = -EFSCORRUPTED;\n\tif (le32_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto end_rmdir;\n\n\tretval = -ENOTEMPTY;\n\tif (!ext4_empty_dir(inode))\n\t\tgoto end_rmdir;\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rmdir;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tretval = ext4_delete_entry(handle, dir, de, bh);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (!EXT4_DIR_LINK_EMPTY(inode))\n\t\text4_warning_inode(inode,\n\t\t\t     \"empty directory '%.*s' has too many links (%u)\",\n\t\t\t     dentry->d_name.len, dentry->d_name.name,\n\t\t\t     inode->i_nlink);\n\tinode_inc_iversion(inode);\n\tclear_nlink(inode);\n\t \n\tinode->i_size = 0;\n\text4_orphan_add(handle, inode);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tinode_set_ctime_current(inode);\n\tretval = ext4_mark_inode_dirty(handle, inode);\n\tif (retval)\n\t\tgoto end_rmdir;\n\text4_dec_count(dir);\n\text4_update_dx_flag(dir);\n\text4_fc_track_unlink(handle, dentry);\n\tretval = ext4_mark_inode_dirty(handle, dir);\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\t \n\tif (IS_CASEFOLDED(dir))\n\t\td_invalidate(dentry);\n#endif\n\nend_rmdir:\n\tbrelse(bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}\n\nint __ext4_unlink(struct inode *dir, const struct qstr *d_name,\n\t\t  struct inode *inode,\n\t\t  struct dentry *dentry  )\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\thandle_t *handle;\n\tint skip_remove_dentry = 0;\n\n\t \n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tif (!bh)\n\t\treturn -ENOENT;\n\n\tif (le32_to_cpu(de->inode) != inode->i_ino) {\n\t\t \n\t\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\t\tskip_remove_dentry = 1;\n\t\telse\n\t\t\tgoto out_bh;\n\t}\n\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t\t\t    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out_bh;\n\t}\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tif (!skip_remove_dentry) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tif (retval)\n\t\t\tgoto out_handle;\n\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t\text4_update_dx_flag(dir);\n\t\tretval = ext4_mark_inode_dirty(handle, dir);\n\t\tif (retval)\n\t\t\tgoto out_handle;\n\t} else {\n\t\tretval = 0;\n\t}\n\tif (inode->i_nlink == 0)\n\t\text4_warning_inode(inode, \"Deleting file '%.*s' with no links\",\n\t\t\t\t   d_name->len, d_name->name);\n\telse\n\t\tdrop_nlink(inode);\n\tif (!inode->i_nlink)\n\t\text4_orphan_add(handle, inode);\n\tinode_set_ctime_current(inode);\n\tretval = ext4_mark_inode_dirty(handle, inode);\n\tif (dentry && !retval)\n\t\text4_fc_track_unlink(handle, dentry);\nout_handle:\n\text4_journal_stop(handle);\nout_bh:\n\tbrelse(bh);\n\treturn retval;\n}\n\nstatic int ext4_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\n\tif (unlikely(ext4_forced_shutdown(dir->i_sb)))\n\t\treturn -EIO;\n\n\ttrace_ext4_unlink_enter(dir, dentry);\n\t \n\tretval = dquot_initialize(dir);\n\tif (retval)\n\t\tgoto out_trace;\n\tretval = dquot_initialize(d_inode(dentry));\n\tif (retval)\n\t\tgoto out_trace;\n\n\tretval = __ext4_unlink(dir, &dentry->d_name, d_inode(dentry), dentry);\n#if IS_ENABLED(CONFIG_UNICODE)\n\t \n\tif (IS_CASEFOLDED(dir))\n\t\td_invalidate(dentry);\n#endif\n\nout_trace:\n\ttrace_ext4_unlink_exit(dentry, retval);\n\treturn retval;\n}\n\nstatic int ext4_init_symlink_block(handle_t *handle, struct inode *inode,\n\t\t\t\t   struct fscrypt_str *disk_link)\n{\n\tstruct buffer_head *bh;\n\tchar *kaddr;\n\tint err = 0;\n\n\tbh = ext4_bread(handle, inode, 0, EXT4_GET_BLOCKS_CREATE);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, inode->i_sb, bh, EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out;\n\n\tkaddr = (char *)bh->b_data;\n\tmemcpy(kaddr, disk_link->name, disk_link->len);\n\tinode->i_size = disk_link->len - 1;\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\nout:\n\tbrelse(bh);\n\treturn err;\n}\n\nstatic int ext4_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, len = strlen(symname);\n\tint credits;\n\tstruct fscrypt_str disk_link;\n\tint retries = 0;\n\n\tif (unlikely(ext4_forced_shutdown(dir->i_sb)))\n\t\treturn -EIO;\n\n\terr = fscrypt_prepare_symlink(dir, symname, len, dir->i_sb->s_blocksize,\n\t\t\t\t      &disk_link);\n\tif (err)\n\t\treturn err;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcredits = EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t  EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3;\nretry:\n\tinode = ext4_new_inode_start_handle(idmap, dir, S_IFLNK|S_IRWXUGO,\n\t\t\t\t\t    &dentry->d_name, 0, NULL,\n\t\t\t\t\t    EXT4_HT_DIR, credits);\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(inode)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_retry;\n\t}\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = fscrypt_encrypt_symlink(inode, symname, len, &disk_link);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t\tinode->i_op = &ext4_encrypted_symlink_inode_operations;\n\t} else {\n\t\tif ((disk_link.len > EXT4_N_BLOCKS * 4)) {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t} else {\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tinode->i_link = (char *)&EXT4_I(inode)->i_data;\n\t\t}\n\t}\n\n\tif ((disk_link.len > EXT4_N_BLOCKS * 4)) {\n\t\t \n\t\terr = ext4_init_symlink_block(handle, inode, &disk_link);\n\t\tif (err)\n\t\t\tgoto err_drop_inode;\n\t} else {\n\t\t \n\t\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\tmemcpy((char *)&EXT4_I(inode)->i_data, disk_link.name,\n\t\t       disk_link.len);\n\t\tinode->i_size = disk_link.len - 1;\n\t\tEXT4_I(inode)->i_disksize = inode->i_size;\n\t}\n\terr = ext4_add_nondir(handle, dentry, &inode);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tiput(inode);\n\tgoto out_retry;\n\nerr_drop_inode:\n\tclear_nlink(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_orphan_add(handle, inode);\n\tunlock_new_inode(inode);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tiput(inode);\nout_retry:\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\tif (disk_link.name != (unsigned char *)symname)\n\t\tkfree(disk_link.name);\n\treturn err;\n}\n\nint __ext4_link(struct inode *dir, struct inode *inode, struct dentry *dentry)\n{\n\thandle_t *handle;\n\tint err, retries = 0;\nretry:\n\thandle = ext4_journal_start(dir, EXT4_HT_DIR,\n\t\t(EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t EXT4_INDEX_EXTRA_TRANS_BLOCKS) + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tinode_set_ctime_current(inode);\n\text4_inc_count(inode);\n\tihold(inode);\n\n\terr = ext4_add_entry(handle, dentry, inode);\n\tif (!err) {\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\t \n\t\tif (inode->i_nlink == 1)\n\t\t\text4_orphan_del(handle, inode);\n\t\td_instantiate(dentry, inode);\n\t\text4_fc_track_link(handle, dentry);\n\t} else {\n\t\tdrop_nlink(inode);\n\t\tiput(inode);\n\t}\n\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}\n\nstatic int ext4_link(struct dentry *old_dentry,\n\t\t     struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint err;\n\n\tif (inode->i_nlink >= EXT4_LINK_MAX)\n\t\treturn -EMLINK;\n\n\terr = fscrypt_prepare_link(old_dentry, dir, dentry);\n\tif (err)\n\t\treturn err;\n\n\tif ((ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT)) &&\n\t    (!projid_eq(EXT4_I(dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\terr = dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\treturn __ext4_link(dir, inode, dentry);\n}\n\n \nstatic struct buffer_head *ext4_get_first_dir_block(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tint *retval,\n\t\t\t\t\tstruct ext4_dir_entry_2 **parent_de,\n\t\t\t\t\tint *inlined)\n{\n\tstruct buffer_head *bh;\n\n\tif (!ext4_has_inline_data(inode)) {\n\t\tstruct ext4_dir_entry_2 *de;\n\t\tunsigned int offset;\n\n\t\t \n\t\tbh = ext4_read_dirblock(inode, 0, DIRENT_HTREE);\n\t\tif (IS_ERR(bh)) {\n\t\t\t*retval = PTR_ERR(bh);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data,\n\t\t\t\t\t bh->b_size, 0) ||\n\t\t    le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t    strcmp(\".\", de->name)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"directory missing '.'\");\n\t\t\tbrelse(bh);\n\t\t\t*retval = -EFSCORRUPTED;\n\t\t\treturn NULL;\n\t\t}\n\t\toffset = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize);\n\t\tde = ext4_next_entry(de, inode->i_sb->s_blocksize);\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh, bh->b_data,\n\t\t\t\t\t bh->b_size, offset) ||\n\t\t    le32_to_cpu(de->inode) == 0 || strcmp(\"..\", de->name)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"directory missing '..'\");\n\t\t\tbrelse(bh);\n\t\t\t*retval = -EFSCORRUPTED;\n\t\t\treturn NULL;\n\t\t}\n\t\t*parent_de = de;\n\n\t\treturn bh;\n\t}\n\n\t*inlined = 1;\n\treturn ext4_get_first_inline_block(inode, parent_de, retval);\n}\n\nstruct ext4_renament {\n\tstruct inode *dir;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tbool is_dir;\n\tint dir_nlink_delta;\n\n\t \n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\tint inlined;\n\n\t \n\tstruct buffer_head *dir_bh;\n\tstruct ext4_dir_entry_2 *parent_de;\n\tint dir_inlined;\n};\n\nstatic int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)\n\t\treturn -EFSCORRUPTED;\n\tBUFFER_TRACE(ent->dir_bh, \"get_write_access\");\n\treturn ext4_journal_get_write_access(handle, ent->dir->i_sb,\n\t\t\t\t\t     ent->dir_bh, EXT4_JTR_NONE);\n}\n\nstatic int ext4_rename_dir_finish(handle_t *handle, struct ext4_renament *ent,\n\t\t\t\t  unsigned dir_ino)\n{\n\tint retval;\n\n\tent->parent_de->inode = cpu_to_le32(dir_ino);\n\tBUFFER_TRACE(ent->dir_bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->dir_inlined) {\n\t\tif (is_dx(ent->inode)) {\n\t\t\tretval = ext4_handle_dirty_dx_node(handle,\n\t\t\t\t\t\t\t   ent->inode,\n\t\t\t\t\t\t\t   ent->dir_bh);\n\t\t} else {\n\t\t\tretval = ext4_handle_dirty_dirblock(handle, ent->inode,\n\t\t\t\t\t\t\t    ent->dir_bh);\n\t\t}\n\t} else {\n\t\tretval = ext4_mark_inode_dirty(handle, ent->inode);\n\t}\n\tif (retval) {\n\t\text4_std_error(ent->dir->i_sb, retval);\n\t\treturn retval;\n\t}\n\treturn 0;\n}\n\nstatic int ext4_setent(handle_t *handle, struct ext4_renament *ent,\n\t\t       unsigned ino, unsigned file_type)\n{\n\tint retval, retval2;\n\n\tBUFFER_TRACE(ent->bh, \"get write access\");\n\tretval = ext4_journal_get_write_access(handle, ent->dir->i_sb, ent->bh,\n\t\t\t\t\t       EXT4_JTR_NONE);\n\tif (retval)\n\t\treturn retval;\n\tent->de->inode = cpu_to_le32(ino);\n\tif (ext4_has_feature_filetype(ent->dir->i_sb))\n\t\tent->de->file_type = file_type;\n\tinode_inc_iversion(ent->dir);\n\tent->dir->i_mtime = inode_set_ctime_current(ent->dir);\n\tretval = ext4_mark_inode_dirty(handle, ent->dir);\n\tBUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");\n\tif (!ent->inlined) {\n\t\tretval2 = ext4_handle_dirty_dirblock(handle, ent->dir, ent->bh);\n\t\tif (unlikely(retval2)) {\n\t\t\text4_std_error(ent->dir->i_sb, retval2);\n\t\t\treturn retval2;\n\t\t}\n\t}\n\treturn retval;\n}\n\nstatic void ext4_resetent(handle_t *handle, struct ext4_renament *ent,\n\t\t\t  unsigned ino, unsigned file_type)\n{\n\tstruct ext4_renament old = *ent;\n\tint retval = 0;\n\n\t \n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de,\n\t\t\t\t &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\tretval = PTR_ERR(old.bh);\n\tif (!old.bh)\n\t\tretval = -ENOENT;\n\tif (retval) {\n\t\text4_std_error(old.dir->i_sb, retval);\n\t\treturn;\n\t}\n\n\text4_setent(handle, &old, ino, file_type);\n\tbrelse(old.bh);\n}\n\nstatic int ext4_find_delete_entry(handle_t *handle, struct inode *dir,\n\t\t\t\t  const struct qstr *d_name)\n{\n\tint retval = -ENOENT;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de;\n\n\tbh = ext4_find_entry(dir, d_name, &de, NULL);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\tif (bh) {\n\t\tretval = ext4_delete_entry(handle, dir, de, bh);\n\t\tbrelse(bh);\n\t}\n\treturn retval;\n}\n\nstatic void ext4_rename_delete(handle_t *handle, struct ext4_renament *ent,\n\t\t\t       int force_reread)\n{\n\tint retval;\n\t \n\tif (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||\n\t    ent->de->name_len != ent->dentry->d_name.len ||\n\t    strncmp(ent->de->name, ent->dentry->d_name.name,\n\t\t    ent->de->name_len) ||\n\t    force_reread) {\n\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t&ent->dentry->d_name);\n\t} else {\n\t\tretval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh);\n\t\tif (retval == -ENOENT) {\n\t\t\tretval = ext4_find_delete_entry(handle, ent->dir,\n\t\t\t\t\t\t\t&ent->dentry->d_name);\n\t\t}\n\t}\n\n\tif (retval) {\n\t\text4_warning_inode(ent->dir,\n\t\t\t\t   \"Deleting old file: nlink %d, error=%d\",\n\t\t\t\t   ent->dir->i_nlink, retval);\n\t}\n}\n\nstatic void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)\n{\n\tif (ent->dir_nlink_delta) {\n\t\tif (ent->dir_nlink_delta == -1)\n\t\t\text4_dec_count(ent->dir);\n\t\telse\n\t\t\text4_inc_count(ent->dir);\n\t\text4_mark_inode_dirty(handle, ent->dir);\n\t}\n}\n\nstatic struct inode *ext4_whiteout_for_rename(struct mnt_idmap *idmap,\n\t\t\t\t\t      struct ext4_renament *ent,\n\t\t\t\t\t      int credits, handle_t **h)\n{\n\tstruct inode *wh;\n\thandle_t *handle;\n\tint retries = 0;\n\n\t \n\tcredits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +\n\t\t    EXT4_XATTR_TRANS_BLOCKS + 4);\nretry:\n\twh = ext4_new_inode_start_handle(idmap, ent->dir,\n\t\t\t\t\t S_IFCHR | WHITEOUT_MODE,\n\t\t\t\t\t &ent->dentry->d_name, 0, NULL,\n\t\t\t\t\t EXT4_HT_DIR, credits);\n\n\thandle = ext4_journal_current_handle();\n\tif (IS_ERR(wh)) {\n\t\tif (handle)\n\t\t\text4_journal_stop(handle);\n\t\tif (PTR_ERR(wh) == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(ent->dir->i_sb, &retries))\n\t\t\tgoto retry;\n\t} else {\n\t\t*h = handle;\n\t\tinit_special_inode(wh, wh->i_mode, WHITEOUT_DEV);\n\t\twh->i_op = &ext4_special_inode_operations;\n\t}\n\treturn wh;\n}\n\n \nstatic int ext4_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t       struct dentry *old_dentry, struct inode *new_dir,\n\t\t       struct dentry *new_dentry, unsigned int flags)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tint force_reread;\n\tint retval;\n\tstruct inode *whiteout = NULL;\n\tint credits;\n\tu8 old_file_type;\n\n\tif (new.inode && new.inode->i_nlink == 0) {\n\t\tEXT4_ERROR_INODE(new.inode,\n\t\t\t\t \"target of rename is already freed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT)) &&\n\t    (!projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(old.inode);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (new.inode) {\n\t\tretval = dquot_initialize(new.inode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de,\n\t\t\t\t &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\n\t \n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto release_bh;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto release_bh;\n\t}\n\tif (new.bh) {\n\t\tif (!new.inode) {\n\t\t\tbrelse(new.bh);\n\t\t\tnew.bh = NULL;\n\t\t}\n\t}\n\tif (new.inode && !test_opt(new.dir->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_alloc_da_blocks(old.inode);\n\n\tcredits = (2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t   EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2);\n\tif (!(flags & RENAME_WHITEOUT)) {\n\t\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tretval = PTR_ERR(handle);\n\t\t\tgoto release_bh;\n\t\t}\n\t} else {\n\t\twhiteout = ext4_whiteout_for_rename(idmap, &old, credits, &handle);\n\t\tif (IS_ERR(whiteout)) {\n\t\t\tretval = PTR_ERR(whiteout);\n\t\t\tgoto release_bh;\n\t\t}\n\t}\n\n\told_file_type = old.de->file_type;\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\tif (new.inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!ext4_empty_dir(new.inode))\n\t\t\t\tgoto end_rename;\n\t\t} else {\n\t\t\tretval = -EMLINK;\n\t\t\tif (new.dir != old.dir && EXT4_DIR_LINK_MAX(new.dir))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\t \n\tforce_reread = (new.dir->i_ino == old.dir->i_ino &&\n\t\t\text4_test_inode_flag(new.dir, EXT4_INODE_INLINE_DATA));\n\n\tif (whiteout) {\n\t\t \n\t\tretval = ext4_setent(handle, &old, whiteout->i_ino,\n\t\t\t\t     EXT4_FT_CHRDEV);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t\tretval = ext4_mark_inode_dirty(handle, whiteout);\n\t\tif (unlikely(retval))\n\t\t\tgoto end_rename;\n\n\t}\n\tif (!new.bh) {\n\t\tretval = ext4_add_entry(handle, new.dentry, old.inode);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t} else {\n\t\tretval = ext4_setent(handle, &new,\n\t\t\t\t     old.inode->i_ino, old_file_type);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (force_reread)\n\t\tforce_reread = !ext4_test_inode_flag(new.dir,\n\t\t\t\t\t\t     EXT4_INODE_INLINE_DATA);\n\n\t \n\tinode_set_ctime_current(old.inode);\n\tretval = ext4_mark_inode_dirty(handle, old.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\n\tif (!whiteout) {\n\t\t \n\t\text4_rename_delete(handle, &old, force_reread);\n\t}\n\n\tif (new.inode) {\n\t\text4_dec_count(new.inode);\n\t\tinode_set_ctime_current(new.inode);\n\t}\n\told.dir->i_mtime = inode_set_ctime_current(old.dir);\n\text4_update_dx_flag(old.dir);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\n\t\text4_dec_count(old.dir);\n\t\tif (new.inode) {\n\t\t\t \n\t\t\tclear_nlink(new.inode);\n\t\t} else {\n\t\t\text4_inc_count(new.dir);\n\t\t\text4_update_dx_flag(new.dir);\n\t\t\tretval = ext4_mark_inode_dirty(handle, new.dir);\n\t\t\tif (unlikely(retval))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t}\n\tretval = ext4_mark_inode_dirty(handle, old.dir);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\t \n\t\text4_fc_mark_ineligible(old.inode->i_sb,\n\t\t\tEXT4_FC_REASON_RENAME_DIR, handle);\n\t} else {\n\t\tstruct super_block *sb = old.inode->i_sb;\n\n\t\tif (new.inode)\n\t\t\text4_fc_track_unlink(handle, new.dentry);\n\t\tif (test_opt2(sb, JOURNAL_FAST_COMMIT) &&\n\t\t    !(EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY) &&\n\t\t    !(ext4_test_mount_flag(sb, EXT4_MF_FC_INELIGIBLE))) {\n\t\t\t__ext4_fc_track_link(handle, old.inode, new.dentry);\n\t\t\t__ext4_fc_track_unlink(handle, old.inode, old.dentry);\n\t\t\tif (whiteout)\n\t\t\t\t__ext4_fc_track_create(handle, whiteout,\n\t\t\t\t\t\t       old.dentry);\n\t\t}\n\t}\n\n\tif (new.inode) {\n\t\tretval = ext4_mark_inode_dirty(handle, new.inode);\n\t\tif (unlikely(retval))\n\t\t\tgoto end_rename;\n\t\tif (!new.inode->i_nlink)\n\t\t\text4_orphan_add(handle, new.inode);\n\t}\n\tretval = 0;\n\nend_rename:\n\tif (whiteout) {\n\t\tif (retval) {\n\t\t\text4_resetent(handle, &old,\n\t\t\t\t      old.inode->i_ino, old_file_type);\n\t\t\tdrop_nlink(whiteout);\n\t\t\text4_mark_inode_dirty(handle, whiteout);\n\t\t\text4_orphan_add(handle, whiteout);\n\t\t}\n\t\tunlock_new_inode(whiteout);\n\t\text4_journal_stop(handle);\n\t\tiput(whiteout);\n\t} else {\n\t\text4_journal_stop(handle);\n\t}\nrelease_bh:\n\tbrelse(old.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\n\treturn retval;\n}\n\nstatic int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tu8 new_file_type;\n\tint retval;\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)) ||\n\t    (ext4_test_inode_flag(old_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(old_dir)->i_projid,\n\t\t\tEXT4_I(new_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t \n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t \n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rename;\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\n\t \n\tif (old.dir != new.dir && old.is_dir != new.is_dir) {\n\t\told.dir_nlink_delta = old.is_dir ? -1 : 1;\n\t\tnew.dir_nlink_delta = -old.dir_nlink_delta;\n\t\tretval = -EMLINK;\n\t\tif ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||\n\t\t    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))\n\t\t\tgoto end_rename;\n\t}\n\n\tnew_file_type = new.de->file_type;\n\tretval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\tretval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);\n\tif (retval)\n\t\tgoto end_rename;\n\n\t \n\tinode_set_ctime_current(old.inode);\n\tinode_set_ctime_current(new.inode);\n\tretval = ext4_mark_inode_dirty(handle, old.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\tretval = ext4_mark_inode_dirty(handle, new.inode);\n\tif (unlikely(retval))\n\t\tgoto end_rename;\n\text4_fc_mark_ineligible(new.inode->i_sb,\n\t\t\t\tEXT4_FC_REASON_CROSS_RENAME, handle);\n\tif (old.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (new.dir_bh) {\n\t\tretval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\text4_update_dir_count(handle, &old);\n\text4_update_dir_count(handle, &new);\n\tretval = 0;\n\nend_rename:\n\tbrelse(old.dir_bh);\n\tbrelse(new.dir_bh);\n\tbrelse(old.bh);\n\tbrelse(new.bh);\n\tif (handle)\n\t\text4_journal_stop(handle);\n\treturn retval;\n}\n\nstatic int ext4_rename2(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tif (unlikely(ext4_forced_shutdown(old_dir->i_sb)))\n\t\treturn -EIO;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\n\treturn ext4_rename(idmap, old_dir, old_dentry, new_dir, new_dentry, flags);\n}\n\n \nconst struct inode_operations ext4_dir_inode_operations = {\n\t.create\t\t= ext4_create,\n\t.lookup\t\t= ext4_lookup,\n\t.link\t\t= ext4_link,\n\t.unlink\t\t= ext4_unlink,\n\t.symlink\t= ext4_symlink,\n\t.mkdir\t\t= ext4_mkdir,\n\t.rmdir\t\t= ext4_rmdir,\n\t.mknod\t\t= ext4_mknod,\n\t.tmpfile\t= ext4_tmpfile,\n\t.rename\t\t= ext4_rename2,\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n\t.get_inode_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n\t.fiemap         = ext4_fiemap,\n\t.fileattr_get\t= ext4_fileattr_get,\n\t.fileattr_set\t= ext4_fileattr_set,\n};\n\nconst struct inode_operations ext4_special_inode_operations = {\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n\t.get_inode_acl\t= ext4_get_acl,\n\t.set_acl\t= ext4_set_acl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}