{
  "module_name": "fast_commit.c",
  "hash_id": "9be47287704513e952e3181d08f388469e0834a8a077371cf7b7823d470c7822",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/fast_commit.c",
  "human_readable_source": "\n\n \n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\n#include \"mballoc.h\"\n\n \n\n#include <trace/events/ext4.h>\nstatic struct kmem_cache *ext4_fc_dentry_cachep;\n\nstatic void ext4_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tBUFFER_TRACE(bh, \"\");\n\tif (uptodate) {\n\t\text4_debug(\"%s: Block %lld up-to-date\",\n\t\t\t   __func__, bh->b_blocknr);\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\text4_debug(\"%s: Block %lld not up-to-date\",\n\t\t\t   __func__, bh->b_blocknr);\n\t\tclear_buffer_uptodate(bh);\n\t}\n\n\tunlock_buffer(bh);\n}\n\nstatic inline void ext4_fc_reset_inode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tei->i_fc_lblk_start = 0;\n\tei->i_fc_lblk_len = 0;\n}\n\nvoid ext4_fc_init_inode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_fc_reset_inode(inode);\n\text4_clear_inode_state(inode, EXT4_STATE_FC_COMMITTING);\n\tINIT_LIST_HEAD(&ei->i_fc_list);\n\tINIT_LIST_HEAD(&ei->i_fc_dilist);\n\tinit_waitqueue_head(&ei->i_fc_wait);\n\tatomic_set(&ei->i_fc_updates, 0);\n}\n\n \nstatic void ext4_fc_wait_committing_inode(struct inode *inode)\n__releases(&EXT4_SB(inode->i_sb)->s_fc_lock)\n{\n\twait_queue_head_t *wq;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n#if (BITS_PER_LONG < 64)\n\tDEFINE_WAIT_BIT(wait, &ei->i_state_flags,\n\t\t\tEXT4_STATE_FC_COMMITTING);\n\twq = bit_waitqueue(&ei->i_state_flags,\n\t\t\t\tEXT4_STATE_FC_COMMITTING);\n#else\n\tDEFINE_WAIT_BIT(wait, &ei->i_flags,\n\t\t\tEXT4_STATE_FC_COMMITTING);\n\twq = bit_waitqueue(&ei->i_flags,\n\t\t\t\tEXT4_STATE_FC_COMMITTING);\n#endif\n\tlockdep_assert_held(&EXT4_SB(inode->i_sb)->s_fc_lock);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&EXT4_SB(inode->i_sb)->s_fc_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n}\n\nstatic bool ext4_fc_disabled(struct super_block *sb)\n{\n\treturn (!test_opt2(sb, JOURNAL_FAST_COMMIT) ||\n\t\t(EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY));\n}\n\n \nvoid ext4_fc_start_update(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\nrestart:\n\tspin_lock(&EXT4_SB(inode->i_sb)->s_fc_lock);\n\tif (list_empty(&ei->i_fc_list))\n\t\tgoto out;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_FC_COMMITTING)) {\n\t\text4_fc_wait_committing_inode(inode);\n\t\tgoto restart;\n\t}\nout:\n\tatomic_inc(&ei->i_fc_updates);\n\tspin_unlock(&EXT4_SB(inode->i_sb)->s_fc_lock);\n}\n\n \nvoid ext4_fc_stop_update(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (atomic_dec_and_test(&ei->i_fc_updates))\n\t\twake_up_all(&ei->i_fc_wait);\n}\n\n \nvoid ext4_fc_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_fc_dentry_update *fc_dentry;\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\nrestart:\n\tspin_lock(&EXT4_SB(inode->i_sb)->s_fc_lock);\n\tif (list_empty(&ei->i_fc_list) && list_empty(&ei->i_fc_dilist)) {\n\t\tspin_unlock(&EXT4_SB(inode->i_sb)->s_fc_lock);\n\t\treturn;\n\t}\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_FC_COMMITTING)) {\n\t\text4_fc_wait_committing_inode(inode);\n\t\tgoto restart;\n\t}\n\n\tif (!list_empty(&ei->i_fc_list))\n\t\tlist_del_init(&ei->i_fc_list);\n\n\t \n\tif (list_empty(&ei->i_fc_dilist)) {\n\t\tspin_unlock(&sbi->s_fc_lock);\n\t\treturn;\n\t}\n\n\tfc_dentry = list_first_entry(&ei->i_fc_dilist, struct ext4_fc_dentry_update, fcd_dilist);\n\tWARN_ON(fc_dentry->fcd_op != EXT4_FC_TAG_CREAT);\n\tlist_del_init(&fc_dentry->fcd_list);\n\tlist_del_init(&fc_dentry->fcd_dilist);\n\n\tWARN_ON(!list_empty(&ei->i_fc_dilist));\n\tspin_unlock(&sbi->s_fc_lock);\n\n\tif (fc_dentry->fcd_name.name &&\n\t\tfc_dentry->fcd_name.len > DNAME_INLINE_LEN)\n\t\tkfree(fc_dentry->fcd_name.name);\n\tkmem_cache_free(ext4_fc_dentry_cachep, fc_dentry);\n\n\treturn;\n}\n\n \nvoid ext4_fc_mark_ineligible(struct super_block *sb, int reason, handle_t *handle)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\ttid_t tid;\n\n\tif (ext4_fc_disabled(sb))\n\t\treturn;\n\n\text4_set_mount_flag(sb, EXT4_MF_FC_INELIGIBLE);\n\tif (handle && !IS_ERR(handle))\n\t\ttid = handle->h_transaction->t_tid;\n\telse {\n\t\tread_lock(&sbi->s_journal->j_state_lock);\n\t\ttid = sbi->s_journal->j_running_transaction ?\n\t\t\t\tsbi->s_journal->j_running_transaction->t_tid : 0;\n\t\tread_unlock(&sbi->s_journal->j_state_lock);\n\t}\n\tspin_lock(&sbi->s_fc_lock);\n\tif (sbi->s_fc_ineligible_tid < tid)\n\t\tsbi->s_fc_ineligible_tid = tid;\n\tspin_unlock(&sbi->s_fc_lock);\n\tWARN_ON(reason >= EXT4_FC_REASON_MAX);\n\tsbi->s_fc_stats.fc_ineligible_reason_count[reason]++;\n}\n\n \nstatic int ext4_fc_track_template(\n\thandle_t *handle, struct inode *inode,\n\tint (*__fc_track_fn)(struct inode *, void *, bool),\n\tvoid *args, int enqueue)\n{\n\tbool update = false;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\ttid_t tid = 0;\n\tint ret;\n\n\ttid = handle->h_transaction->t_tid;\n\tmutex_lock(&ei->i_fc_lock);\n\tif (tid == ei->i_sync_tid) {\n\t\tupdate = true;\n\t} else {\n\t\text4_fc_reset_inode(inode);\n\t\tei->i_sync_tid = tid;\n\t}\n\tret = __fc_track_fn(inode, args, update);\n\tmutex_unlock(&ei->i_fc_lock);\n\n\tif (!enqueue)\n\t\treturn ret;\n\n\tspin_lock(&sbi->s_fc_lock);\n\tif (list_empty(&EXT4_I(inode)->i_fc_list))\n\t\tlist_add_tail(&EXT4_I(inode)->i_fc_list,\n\t\t\t\t(sbi->s_journal->j_flags & JBD2_FULL_COMMIT_ONGOING ||\n\t\t\t\t sbi->s_journal->j_flags & JBD2_FAST_COMMIT_ONGOING) ?\n\t\t\t\t&sbi->s_fc_q[FC_Q_STAGING] :\n\t\t\t\t&sbi->s_fc_q[FC_Q_MAIN]);\n\tspin_unlock(&sbi->s_fc_lock);\n\n\treturn ret;\n}\n\nstruct __track_dentry_update_args {\n\tstruct dentry *dentry;\n\tint op;\n};\n\n \nstatic int __track_dentry_update(struct inode *inode, void *arg, bool update)\n{\n\tstruct ext4_fc_dentry_update *node;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct __track_dentry_update_args *dentry_update =\n\t\t(struct __track_dentry_update_args *)arg;\n\tstruct dentry *dentry = dentry_update->dentry;\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tmutex_unlock(&ei->i_fc_lock);\n\n\tif (IS_ENCRYPTED(dir)) {\n\t\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_ENCRYPTED_FILENAME,\n\t\t\t\t\tNULL);\n\t\tmutex_lock(&ei->i_fc_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnode = kmem_cache_alloc(ext4_fc_dentry_cachep, GFP_NOFS);\n\tif (!node) {\n\t\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_NOMEM, NULL);\n\t\tmutex_lock(&ei->i_fc_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tnode->fcd_op = dentry_update->op;\n\tnode->fcd_parent = dir->i_ino;\n\tnode->fcd_ino = inode->i_ino;\n\tif (dentry->d_name.len > DNAME_INLINE_LEN) {\n\t\tnode->fcd_name.name = kmalloc(dentry->d_name.len, GFP_NOFS);\n\t\tif (!node->fcd_name.name) {\n\t\t\tkmem_cache_free(ext4_fc_dentry_cachep, node);\n\t\t\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_NOMEM, NULL);\n\t\t\tmutex_lock(&ei->i_fc_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy((u8 *)node->fcd_name.name, dentry->d_name.name,\n\t\t\tdentry->d_name.len);\n\t} else {\n\t\tmemcpy(node->fcd_iname, dentry->d_name.name,\n\t\t\tdentry->d_name.len);\n\t\tnode->fcd_name.name = node->fcd_iname;\n\t}\n\tnode->fcd_name.len = dentry->d_name.len;\n\tINIT_LIST_HEAD(&node->fcd_dilist);\n\tspin_lock(&sbi->s_fc_lock);\n\tif (sbi->s_journal->j_flags & JBD2_FULL_COMMIT_ONGOING ||\n\t\tsbi->s_journal->j_flags & JBD2_FAST_COMMIT_ONGOING)\n\t\tlist_add_tail(&node->fcd_list,\n\t\t\t\t&sbi->s_fc_dentry_q[FC_Q_STAGING]);\n\telse\n\t\tlist_add_tail(&node->fcd_list, &sbi->s_fc_dentry_q[FC_Q_MAIN]);\n\n\t \n\tif (dentry_update->op == EXT4_FC_TAG_CREAT) {\n\t\tWARN_ON(!list_empty(&ei->i_fc_dilist));\n\t\tlist_add_tail(&node->fcd_dilist, &ei->i_fc_dilist);\n\t}\n\tspin_unlock(&sbi->s_fc_lock);\n\tmutex_lock(&ei->i_fc_lock);\n\n\treturn 0;\n}\n\nvoid __ext4_fc_track_unlink(handle_t *handle,\n\t\tstruct inode *inode, struct dentry *dentry)\n{\n\tstruct __track_dentry_update_args args;\n\tint ret;\n\n\targs.dentry = dentry;\n\targs.op = EXT4_FC_TAG_UNLINK;\n\n\tret = ext4_fc_track_template(handle, inode, __track_dentry_update,\n\t\t\t\t\t(void *)&args, 0);\n\ttrace_ext4_fc_track_unlink(handle, inode, dentry, ret);\n}\n\nvoid ext4_fc_track_unlink(handle_t *handle, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (ext4_test_mount_flag(inode->i_sb, EXT4_MF_FC_INELIGIBLE))\n\t\treturn;\n\n\t__ext4_fc_track_unlink(handle, inode, dentry);\n}\n\nvoid __ext4_fc_track_link(handle_t *handle,\n\tstruct inode *inode, struct dentry *dentry)\n{\n\tstruct __track_dentry_update_args args;\n\tint ret;\n\n\targs.dentry = dentry;\n\targs.op = EXT4_FC_TAG_LINK;\n\n\tret = ext4_fc_track_template(handle, inode, __track_dentry_update,\n\t\t\t\t\t(void *)&args, 0);\n\ttrace_ext4_fc_track_link(handle, inode, dentry, ret);\n}\n\nvoid ext4_fc_track_link(handle_t *handle, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (ext4_test_mount_flag(inode->i_sb, EXT4_MF_FC_INELIGIBLE))\n\t\treturn;\n\n\t__ext4_fc_track_link(handle, inode, dentry);\n}\n\nvoid __ext4_fc_track_create(handle_t *handle, struct inode *inode,\n\t\t\t  struct dentry *dentry)\n{\n\tstruct __track_dentry_update_args args;\n\tint ret;\n\n\targs.dentry = dentry;\n\targs.op = EXT4_FC_TAG_CREAT;\n\n\tret = ext4_fc_track_template(handle, inode, __track_dentry_update,\n\t\t\t\t\t(void *)&args, 0);\n\ttrace_ext4_fc_track_create(handle, inode, dentry, ret);\n}\n\nvoid ext4_fc_track_create(handle_t *handle, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (ext4_test_mount_flag(inode->i_sb, EXT4_MF_FC_INELIGIBLE))\n\t\treturn;\n\n\t__ext4_fc_track_create(handle, inode, dentry);\n}\n\n \nstatic int __track_inode(struct inode *inode, void *arg, bool update)\n{\n\tif (update)\n\t\treturn -EEXIST;\n\n\tEXT4_I(inode)->i_fc_lblk_len = 0;\n\n\treturn 0;\n}\n\nvoid ext4_fc_track_inode(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\text4_fc_mark_ineligible(inode->i_sb,\n\t\t\t\t\tEXT4_FC_REASON_INODE_JOURNAL_DATA, handle);\n\t\treturn;\n\t}\n\n\tif (ext4_test_mount_flag(inode->i_sb, EXT4_MF_FC_INELIGIBLE))\n\t\treturn;\n\n\tret = ext4_fc_track_template(handle, inode, __track_inode, NULL, 1);\n\ttrace_ext4_fc_track_inode(handle, inode, ret);\n}\n\nstruct __track_range_args {\n\text4_lblk_t start, end;\n};\n\n \nstatic int __track_range(struct inode *inode, void *arg, bool update)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_lblk_t oldstart;\n\tstruct __track_range_args *__arg =\n\t\t(struct __track_range_args *)arg;\n\n\tif (inode->i_ino < EXT4_FIRST_INO(inode->i_sb)) {\n\t\text4_debug(\"Special inode %ld being modified\\n\", inode->i_ino);\n\t\treturn -ECANCELED;\n\t}\n\n\toldstart = ei->i_fc_lblk_start;\n\n\tif (update && ei->i_fc_lblk_len > 0) {\n\t\tei->i_fc_lblk_start = min(ei->i_fc_lblk_start, __arg->start);\n\t\tei->i_fc_lblk_len =\n\t\t\tmax(oldstart + ei->i_fc_lblk_len - 1, __arg->end) -\n\t\t\t\tei->i_fc_lblk_start + 1;\n\t} else {\n\t\tei->i_fc_lblk_start = __arg->start;\n\t\tei->i_fc_lblk_len = __arg->end - __arg->start + 1;\n\t}\n\n\treturn 0;\n}\n\nvoid ext4_fc_track_range(handle_t *handle, struct inode *inode, ext4_lblk_t start,\n\t\t\t ext4_lblk_t end)\n{\n\tstruct __track_range_args args;\n\tint ret;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (ext4_fc_disabled(inode->i_sb))\n\t\treturn;\n\n\tif (ext4_test_mount_flag(inode->i_sb, EXT4_MF_FC_INELIGIBLE))\n\t\treturn;\n\n\targs.start = start;\n\targs.end = end;\n\n\tret = ext4_fc_track_template(handle, inode,  __track_range, &args, 1);\n\n\ttrace_ext4_fc_track_range(handle, inode, start, end, ret);\n}\n\nstatic void ext4_fc_submit_bh(struct super_block *sb, bool is_tail)\n{\n\tblk_opf_t write_flags = REQ_SYNC;\n\tstruct buffer_head *bh = EXT4_SB(sb)->s_fc_bh;\n\n\t \n\tif (test_opt(sb, BARRIER) && is_tail)\n\t\twrite_flags |= REQ_FUA | REQ_PREFLUSH;\n\tlock_buffer(bh);\n\tset_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tbh->b_end_io = ext4_end_buffer_io_sync;\n\tsubmit_bh(REQ_OP_WRITE | write_flags, bh);\n\tEXT4_SB(sb)->s_fc_bh = NULL;\n}\n\n \n\n \nstatic u8 *ext4_fc_reserve_space(struct super_block *sb, int len, u32 *crc)\n{\n\tstruct ext4_fc_tl tl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh;\n\tint bsize = sbi->s_journal->j_blocksize;\n\tint ret, off = sbi->s_fc_bytes % bsize;\n\tint remaining;\n\tu8 *dst;\n\n\t \n\tif (len > bsize - EXT4_FC_TAG_BASE_LEN)\n\t\treturn NULL;\n\n\tif (!sbi->s_fc_bh) {\n\t\tret = jbd2_fc_get_buf(EXT4_SB(sb)->s_journal, &bh);\n\t\tif (ret)\n\t\t\treturn NULL;\n\t\tsbi->s_fc_bh = bh;\n\t}\n\tdst = sbi->s_fc_bh->b_data + off;\n\n\t \n\tremaining = bsize - EXT4_FC_TAG_BASE_LEN - off;\n\tif (len <= remaining) {\n\t\tsbi->s_fc_bytes += len;\n\t\treturn dst;\n\t}\n\n\t \n\n\ttl.fc_tag = cpu_to_le16(EXT4_FC_TAG_PAD);\n\ttl.fc_len = cpu_to_le16(remaining);\n\tmemcpy(dst, &tl, EXT4_FC_TAG_BASE_LEN);\n\tmemset(dst + EXT4_FC_TAG_BASE_LEN, 0, remaining);\n\t*crc = ext4_chksum(sbi, *crc, sbi->s_fc_bh->b_data, bsize);\n\n\text4_fc_submit_bh(sb, false);\n\n\tret = jbd2_fc_get_buf(EXT4_SB(sb)->s_journal, &bh);\n\tif (ret)\n\t\treturn NULL;\n\tsbi->s_fc_bh = bh;\n\tsbi->s_fc_bytes += bsize - off + len;\n\treturn sbi->s_fc_bh->b_data;\n}\n\n \nstatic int ext4_fc_write_tail(struct super_block *sb, u32 crc)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_fc_tl tl;\n\tstruct ext4_fc_tail tail;\n\tint off, bsize = sbi->s_journal->j_blocksize;\n\tu8 *dst;\n\n\t \n\tdst = ext4_fc_reserve_space(sb, EXT4_FC_TAG_BASE_LEN + sizeof(tail), &crc);\n\tif (!dst)\n\t\treturn -ENOSPC;\n\n\toff = sbi->s_fc_bytes % bsize;\n\n\ttl.fc_tag = cpu_to_le16(EXT4_FC_TAG_TAIL);\n\ttl.fc_len = cpu_to_le16(bsize - off + sizeof(struct ext4_fc_tail));\n\tsbi->s_fc_bytes = round_up(sbi->s_fc_bytes, bsize);\n\n\tmemcpy(dst, &tl, EXT4_FC_TAG_BASE_LEN);\n\tdst += EXT4_FC_TAG_BASE_LEN;\n\ttail.fc_tid = cpu_to_le32(sbi->s_journal->j_running_transaction->t_tid);\n\tmemcpy(dst, &tail.fc_tid, sizeof(tail.fc_tid));\n\tdst += sizeof(tail.fc_tid);\n\tcrc = ext4_chksum(sbi, crc, sbi->s_fc_bh->b_data,\n\t\t\t  dst - (u8 *)sbi->s_fc_bh->b_data);\n\ttail.fc_crc = cpu_to_le32(crc);\n\tmemcpy(dst, &tail.fc_crc, sizeof(tail.fc_crc));\n\tdst += sizeof(tail.fc_crc);\n\tmemset(dst, 0, bsize - off);  \n\n\text4_fc_submit_bh(sb, true);\n\n\treturn 0;\n}\n\n \nstatic bool ext4_fc_add_tlv(struct super_block *sb, u16 tag, u16 len, u8 *val,\n\t\t\t   u32 *crc)\n{\n\tstruct ext4_fc_tl tl;\n\tu8 *dst;\n\n\tdst = ext4_fc_reserve_space(sb, EXT4_FC_TAG_BASE_LEN + len, crc);\n\tif (!dst)\n\t\treturn false;\n\n\ttl.fc_tag = cpu_to_le16(tag);\n\ttl.fc_len = cpu_to_le16(len);\n\n\tmemcpy(dst, &tl, EXT4_FC_TAG_BASE_LEN);\n\tmemcpy(dst + EXT4_FC_TAG_BASE_LEN, val, len);\n\n\treturn true;\n}\n\n \nstatic bool ext4_fc_add_dentry_tlv(struct super_block *sb, u32 *crc,\n\t\t\t\t   struct ext4_fc_dentry_update *fc_dentry)\n{\n\tstruct ext4_fc_dentry_info fcd;\n\tstruct ext4_fc_tl tl;\n\tint dlen = fc_dentry->fcd_name.len;\n\tu8 *dst = ext4_fc_reserve_space(sb,\n\t\t\tEXT4_FC_TAG_BASE_LEN + sizeof(fcd) + dlen, crc);\n\n\tif (!dst)\n\t\treturn false;\n\n\tfcd.fc_parent_ino = cpu_to_le32(fc_dentry->fcd_parent);\n\tfcd.fc_ino = cpu_to_le32(fc_dentry->fcd_ino);\n\ttl.fc_tag = cpu_to_le16(fc_dentry->fcd_op);\n\ttl.fc_len = cpu_to_le16(sizeof(fcd) + dlen);\n\tmemcpy(dst, &tl, EXT4_FC_TAG_BASE_LEN);\n\tdst += EXT4_FC_TAG_BASE_LEN;\n\tmemcpy(dst, &fcd, sizeof(fcd));\n\tdst += sizeof(fcd);\n\tmemcpy(dst, fc_dentry->fcd_name.name, dlen);\n\n\treturn true;\n}\n\n \nstatic int ext4_fc_write_inode(struct inode *inode, u32 *crc)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint inode_len = EXT4_GOOD_OLD_INODE_SIZE;\n\tint ret;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_fc_inode fc_inode;\n\tstruct ext4_fc_tl tl;\n\tu8 *dst;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA))\n\t\tinode_len = EXT4_INODE_SIZE(inode->i_sb);\n\telse if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE)\n\t\tinode_len += ei->i_extra_isize;\n\n\tfc_inode.fc_ino = cpu_to_le32(inode->i_ino);\n\ttl.fc_tag = cpu_to_le16(EXT4_FC_TAG_INODE);\n\ttl.fc_len = cpu_to_le16(inode_len + sizeof(fc_inode.fc_ino));\n\n\tret = -ECANCELED;\n\tdst = ext4_fc_reserve_space(inode->i_sb,\n\t\tEXT4_FC_TAG_BASE_LEN + inode_len + sizeof(fc_inode.fc_ino), crc);\n\tif (!dst)\n\t\tgoto err;\n\n\tmemcpy(dst, &tl, EXT4_FC_TAG_BASE_LEN);\n\tdst += EXT4_FC_TAG_BASE_LEN;\n\tmemcpy(dst, &fc_inode, sizeof(fc_inode));\n\tdst += sizeof(fc_inode);\n\tmemcpy(dst, (u8 *)ext4_raw_inode(&iloc), inode_len);\n\tret = 0;\nerr:\n\tbrelse(iloc.bh);\n\treturn ret;\n}\n\n \nstatic int ext4_fc_write_inode_data(struct inode *inode, u32 *crc)\n{\n\text4_lblk_t old_blk_size, cur_lblk_off, new_blk_size;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_map_blocks map;\n\tstruct ext4_fc_add_range fc_ext;\n\tstruct ext4_fc_del_range lrange;\n\tstruct ext4_extent *ex;\n\tint ret;\n\n\tmutex_lock(&ei->i_fc_lock);\n\tif (ei->i_fc_lblk_len == 0) {\n\t\tmutex_unlock(&ei->i_fc_lock);\n\t\treturn 0;\n\t}\n\told_blk_size = ei->i_fc_lblk_start;\n\tnew_blk_size = ei->i_fc_lblk_start + ei->i_fc_lblk_len - 1;\n\tei->i_fc_lblk_len = 0;\n\tmutex_unlock(&ei->i_fc_lock);\n\n\tcur_lblk_off = old_blk_size;\n\text4_debug(\"will try writing %d to %d for inode %ld\\n\",\n\t\t   cur_lblk_off, new_blk_size, inode->i_ino);\n\n\twhile (cur_lblk_off <= new_blk_size) {\n\t\tmap.m_lblk = cur_lblk_off;\n\t\tmap.m_len = new_blk_size - cur_lblk_off + 1;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\treturn -ECANCELED;\n\n\t\tif (map.m_len == 0) {\n\t\t\tcur_lblk_off++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == 0) {\n\t\t\tlrange.fc_ino = cpu_to_le32(inode->i_ino);\n\t\t\tlrange.fc_lblk = cpu_to_le32(map.m_lblk);\n\t\t\tlrange.fc_len = cpu_to_le32(map.m_len);\n\t\t\tif (!ext4_fc_add_tlv(inode->i_sb, EXT4_FC_TAG_DEL_RANGE,\n\t\t\t\t\t    sizeof(lrange), (u8 *)&lrange, crc))\n\t\t\t\treturn -ENOSPC;\n\t\t} else {\n\t\t\tunsigned int max = (map.m_flags & EXT4_MAP_UNWRITTEN) ?\n\t\t\t\tEXT_UNWRITTEN_MAX_LEN : EXT_INIT_MAX_LEN;\n\n\t\t\t \n\t\t\tmap.m_len = min(max, map.m_len);\n\n\t\t\tfc_ext.fc_ino = cpu_to_le32(inode->i_ino);\n\t\t\tex = (struct ext4_extent *)&fc_ext.fc_ex;\n\t\t\tex->ee_block = cpu_to_le32(map.m_lblk);\n\t\t\tex->ee_len = cpu_to_le16(map.m_len);\n\t\t\text4_ext_store_pblock(ex, map.m_pblk);\n\t\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\telse\n\t\t\t\text4_ext_mark_initialized(ex);\n\t\t\tif (!ext4_fc_add_tlv(inode->i_sb, EXT4_FC_TAG_ADD_RANGE,\n\t\t\t\t\t    sizeof(fc_ext), (u8 *)&fc_ext, crc))\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tcur_lblk_off += map.m_len;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int ext4_fc_submit_inode_data_all(journal_t *journal)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_inode_info *ei;\n\tint ret = 0;\n\n\tspin_lock(&sbi->s_fc_lock);\n\tlist_for_each_entry(ei, &sbi->s_fc_q[FC_Q_MAIN], i_fc_list) {\n\t\text4_set_inode_state(&ei->vfs_inode, EXT4_STATE_FC_COMMITTING);\n\t\twhile (atomic_read(&ei->i_fc_updates)) {\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tprepare_to_wait(&ei->i_fc_wait, &wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tif (atomic_read(&ei->i_fc_updates)) {\n\t\t\t\tspin_unlock(&sbi->s_fc_lock);\n\t\t\t\tschedule();\n\t\t\t\tspin_lock(&sbi->s_fc_lock);\n\t\t\t}\n\t\t\tfinish_wait(&ei->i_fc_wait, &wait);\n\t\t}\n\t\tspin_unlock(&sbi->s_fc_lock);\n\t\tret = jbd2_submit_inode_data(journal, ei->jinode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock(&sbi->s_fc_lock);\n\t}\n\tspin_unlock(&sbi->s_fc_lock);\n\n\treturn ret;\n}\n\n \nstatic int ext4_fc_wait_inode_data_all(journal_t *journal)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_inode_info *pos, *n;\n\tint ret = 0;\n\n\tspin_lock(&sbi->s_fc_lock);\n\tlist_for_each_entry_safe(pos, n, &sbi->s_fc_q[FC_Q_MAIN], i_fc_list) {\n\t\tif (!ext4_test_inode_state(&pos->vfs_inode,\n\t\t\t\t\t   EXT4_STATE_FC_COMMITTING))\n\t\t\tcontinue;\n\t\tspin_unlock(&sbi->s_fc_lock);\n\n\t\tret = jbd2_wait_inode_data(journal, pos->jinode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock(&sbi->s_fc_lock);\n\t}\n\tspin_unlock(&sbi->s_fc_lock);\n\n\treturn 0;\n}\n\n \nstatic int ext4_fc_commit_dentry_updates(journal_t *journal, u32 *crc)\n__acquires(&sbi->s_fc_lock)\n__releases(&sbi->s_fc_lock)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_fc_dentry_update *fc_dentry, *fc_dentry_n;\n\tstruct inode *inode;\n\tstruct ext4_inode_info *ei;\n\tint ret;\n\n\tif (list_empty(&sbi->s_fc_dentry_q[FC_Q_MAIN]))\n\t\treturn 0;\n\tlist_for_each_entry_safe(fc_dentry, fc_dentry_n,\n\t\t\t\t &sbi->s_fc_dentry_q[FC_Q_MAIN], fcd_list) {\n\t\tif (fc_dentry->fcd_op != EXT4_FC_TAG_CREAT) {\n\t\t\tspin_unlock(&sbi->s_fc_lock);\n\t\t\tif (!ext4_fc_add_dentry_tlv(sb, crc, fc_dentry)) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto lock_and_exit;\n\t\t\t}\n\t\t\tspin_lock(&sbi->s_fc_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tWARN_ON(list_empty(&fc_dentry->fcd_dilist));\n\t\tei = list_first_entry(&fc_dentry->fcd_dilist,\n\t\t\t\tstruct ext4_inode_info, i_fc_dilist);\n\t\tinode = &ei->vfs_inode;\n\t\tWARN_ON(inode->i_ino != fc_dentry->fcd_ino);\n\n\t\tspin_unlock(&sbi->s_fc_lock);\n\n\t\t \n\t\tret = ext4_fc_write_inode(inode, crc);\n\t\tif (ret)\n\t\t\tgoto lock_and_exit;\n\n\t\tret = ext4_fc_write_inode_data(inode, crc);\n\t\tif (ret)\n\t\t\tgoto lock_and_exit;\n\n\t\tif (!ext4_fc_add_dentry_tlv(sb, crc, fc_dentry)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto lock_and_exit;\n\t\t}\n\n\t\tspin_lock(&sbi->s_fc_lock);\n\t}\n\treturn 0;\nlock_and_exit:\n\tspin_lock(&sbi->s_fc_lock);\n\treturn ret;\n}\n\nstatic int ext4_fc_perform_commit(journal_t *journal)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_inode_info *iter;\n\tstruct ext4_fc_head head;\n\tstruct inode *inode;\n\tstruct blk_plug plug;\n\tint ret = 0;\n\tu32 crc = 0;\n\n\tret = ext4_fc_submit_inode_data_all(journal);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_fc_wait_inode_data_all(journal);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (journal->j_fs_dev != journal->j_dev)\n\t\tblkdev_issue_flush(journal->j_fs_dev);\n\n\tblk_start_plug(&plug);\n\tif (sbi->s_fc_bytes == 0) {\n\t\t \n\t\thead.fc_features = cpu_to_le32(EXT4_FC_SUPPORTED_FEATURES);\n\t\thead.fc_tid = cpu_to_le32(\n\t\t\tsbi->s_journal->j_running_transaction->t_tid);\n\t\tif (!ext4_fc_add_tlv(sb, EXT4_FC_TAG_HEAD, sizeof(head),\n\t\t\t(u8 *)&head, &crc)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tspin_lock(&sbi->s_fc_lock);\n\tret = ext4_fc_commit_dentry_updates(journal, &crc);\n\tif (ret) {\n\t\tspin_unlock(&sbi->s_fc_lock);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(iter, &sbi->s_fc_q[FC_Q_MAIN], i_fc_list) {\n\t\tinode = &iter->vfs_inode;\n\t\tif (!ext4_test_inode_state(inode, EXT4_STATE_FC_COMMITTING))\n\t\t\tcontinue;\n\n\t\tspin_unlock(&sbi->s_fc_lock);\n\t\tret = ext4_fc_write_inode_data(inode, &crc);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = ext4_fc_write_inode(inode, &crc);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_fc_lock);\n\t}\n\tspin_unlock(&sbi->s_fc_lock);\n\n\tret = ext4_fc_write_tail(sb, crc);\n\nout:\n\tblk_finish_plug(&plug);\n\treturn ret;\n}\n\nstatic void ext4_fc_update_stats(struct super_block *sb, int status,\n\t\t\t\t u64 commit_time, int nblks, tid_t commit_tid)\n{\n\tstruct ext4_fc_stats *stats = &EXT4_SB(sb)->s_fc_stats;\n\n\text4_debug(\"Fast commit ended with status = %d for tid %u\",\n\t\t\tstatus, commit_tid);\n\tif (status == EXT4_FC_STATUS_OK) {\n\t\tstats->fc_num_commits++;\n\t\tstats->fc_numblks += nblks;\n\t\tif (likely(stats->s_fc_avg_commit_time))\n\t\t\tstats->s_fc_avg_commit_time =\n\t\t\t\t(commit_time +\n\t\t\t\t stats->s_fc_avg_commit_time * 3) / 4;\n\t\telse\n\t\t\tstats->s_fc_avg_commit_time = commit_time;\n\t} else if (status == EXT4_FC_STATUS_FAILED ||\n\t\t   status == EXT4_FC_STATUS_INELIGIBLE) {\n\t\tif (status == EXT4_FC_STATUS_FAILED)\n\t\t\tstats->fc_failed_commits++;\n\t\tstats->fc_ineligible_commits++;\n\t} else {\n\t\tstats->fc_skipped_commits++;\n\t}\n\ttrace_ext4_fc_commit_stop(sb, nblks, status, commit_tid);\n}\n\n \nint ext4_fc_commit(journal_t *journal, tid_t commit_tid)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint nblks = 0, ret, bsize = journal->j_blocksize;\n\tint subtid = atomic_read(&sbi->s_fc_subtid);\n\tint status = EXT4_FC_STATUS_OK, fc_bufs_before = 0;\n\tktime_t start_time, commit_time;\n\n\tif (!test_opt2(sb, JOURNAL_FAST_COMMIT))\n\t\treturn jbd2_complete_transaction(journal, commit_tid);\n\n\ttrace_ext4_fc_commit_start(sb, commit_tid);\n\n\tstart_time = ktime_get();\n\nrestart_fc:\n\tret = jbd2_fc_begin_commit(journal, commit_tid);\n\tif (ret == -EALREADY) {\n\t\t \n\t\tif (atomic_read(&sbi->s_fc_subtid) <= subtid &&\n\t\t\tcommit_tid > journal->j_commit_sequence)\n\t\t\tgoto restart_fc;\n\t\text4_fc_update_stats(sb, EXT4_FC_STATUS_SKIPPED, 0, 0,\n\t\t\t\tcommit_tid);\n\t\treturn 0;\n\t} else if (ret) {\n\t\t \n\t\text4_fc_update_stats(sb, EXT4_FC_STATUS_FAILED, 0, 0,\n\t\t\t\tcommit_tid);\n\t\treturn jbd2_complete_transaction(journal, commit_tid);\n\t}\n\n\t \n\tif (ext4_test_mount_flag(sb, EXT4_MF_FC_INELIGIBLE)) {\n\t\tstatus = EXT4_FC_STATUS_INELIGIBLE;\n\t\tgoto fallback;\n\t}\n\n\tfc_bufs_before = (sbi->s_fc_bytes + bsize - 1) / bsize;\n\tret = ext4_fc_perform_commit(journal);\n\tif (ret < 0) {\n\t\tstatus = EXT4_FC_STATUS_FAILED;\n\t\tgoto fallback;\n\t}\n\tnblks = (sbi->s_fc_bytes + bsize - 1) / bsize - fc_bufs_before;\n\tret = jbd2_fc_wait_bufs(journal, nblks);\n\tif (ret < 0) {\n\t\tstatus = EXT4_FC_STATUS_FAILED;\n\t\tgoto fallback;\n\t}\n\tatomic_inc(&sbi->s_fc_subtid);\n\tret = jbd2_fc_end_commit(journal);\n\t \n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\text4_fc_update_stats(sb, status, commit_time, nblks, commit_tid);\n\treturn ret;\n\nfallback:\n\tret = jbd2_fc_end_commit_fallback(journal);\n\text4_fc_update_stats(sb, status, 0, 0, commit_tid);\n\treturn ret;\n}\n\n \nstatic void ext4_fc_cleanup(journal_t *journal, int full, tid_t tid)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_inode_info *iter, *iter_n;\n\tstruct ext4_fc_dentry_update *fc_dentry;\n\n\tif (full && sbi->s_fc_bh)\n\t\tsbi->s_fc_bh = NULL;\n\n\ttrace_ext4_fc_cleanup(journal, full, tid);\n\tjbd2_fc_release_bufs(journal);\n\n\tspin_lock(&sbi->s_fc_lock);\n\tlist_for_each_entry_safe(iter, iter_n, &sbi->s_fc_q[FC_Q_MAIN],\n\t\t\t\t i_fc_list) {\n\t\tlist_del_init(&iter->i_fc_list);\n\t\text4_clear_inode_state(&iter->vfs_inode,\n\t\t\t\t       EXT4_STATE_FC_COMMITTING);\n\t\tif (iter->i_sync_tid <= tid)\n\t\t\text4_fc_reset_inode(&iter->vfs_inode);\n\t\t \n\t\tsmp_mb();\n#if (BITS_PER_LONG < 64)\n\t\twake_up_bit(&iter->i_state_flags, EXT4_STATE_FC_COMMITTING);\n#else\n\t\twake_up_bit(&iter->i_flags, EXT4_STATE_FC_COMMITTING);\n#endif\n\t}\n\n\twhile (!list_empty(&sbi->s_fc_dentry_q[FC_Q_MAIN])) {\n\t\tfc_dentry = list_first_entry(&sbi->s_fc_dentry_q[FC_Q_MAIN],\n\t\t\t\t\t     struct ext4_fc_dentry_update,\n\t\t\t\t\t     fcd_list);\n\t\tlist_del_init(&fc_dentry->fcd_list);\n\t\tlist_del_init(&fc_dentry->fcd_dilist);\n\t\tspin_unlock(&sbi->s_fc_lock);\n\n\t\tif (fc_dentry->fcd_name.name &&\n\t\t\tfc_dentry->fcd_name.len > DNAME_INLINE_LEN)\n\t\t\tkfree(fc_dentry->fcd_name.name);\n\t\tkmem_cache_free(ext4_fc_dentry_cachep, fc_dentry);\n\t\tspin_lock(&sbi->s_fc_lock);\n\t}\n\n\tlist_splice_init(&sbi->s_fc_dentry_q[FC_Q_STAGING],\n\t\t\t\t&sbi->s_fc_dentry_q[FC_Q_MAIN]);\n\tlist_splice_init(&sbi->s_fc_q[FC_Q_STAGING],\n\t\t\t\t&sbi->s_fc_q[FC_Q_MAIN]);\n\n\tif (tid >= sbi->s_fc_ineligible_tid) {\n\t\tsbi->s_fc_ineligible_tid = 0;\n\t\text4_clear_mount_flag(sb, EXT4_MF_FC_INELIGIBLE);\n\t}\n\n\tif (full)\n\t\tsbi->s_fc_bytes = 0;\n\tspin_unlock(&sbi->s_fc_lock);\n\ttrace_ext4_fc_stats(sb);\n}\n\n \n\n \nstruct dentry_info_args {\n\tint parent_ino, dname_len, ino, inode_len;\n\tchar *dname;\n};\n\n \nstruct ext4_fc_tl_mem {\n\tu16 fc_tag;\n\tu16 fc_len;\n};\n\nstatic inline void tl_to_darg(struct dentry_info_args *darg,\n\t\t\t      struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct ext4_fc_dentry_info fcd;\n\n\tmemcpy(&fcd, val, sizeof(fcd));\n\n\tdarg->parent_ino = le32_to_cpu(fcd.fc_parent_ino);\n\tdarg->ino = le32_to_cpu(fcd.fc_ino);\n\tdarg->dname = val + offsetof(struct ext4_fc_dentry_info, fc_dname);\n\tdarg->dname_len = tl->fc_len - sizeof(struct ext4_fc_dentry_info);\n}\n\nstatic inline void ext4_fc_get_tl(struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct ext4_fc_tl tl_disk;\n\n\tmemcpy(&tl_disk, val, EXT4_FC_TAG_BASE_LEN);\n\ttl->fc_len = le16_to_cpu(tl_disk.fc_len);\n\ttl->fc_tag = le16_to_cpu(tl_disk.fc_tag);\n}\n\n \nstatic int ext4_fc_replay_unlink(struct super_block *sb,\n\t\t\t\t struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct inode *inode, *old_parent;\n\tstruct qstr entry;\n\tstruct dentry_info_args darg;\n\tint ret = 0;\n\n\ttl_to_darg(&darg, tl, val);\n\n\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_UNLINK, darg.ino,\n\t\t\tdarg.parent_ino, darg.dname_len);\n\n\tentry.name = darg.dname;\n\tentry.len = darg.dname_len;\n\tinode = ext4_iget(sb, darg.ino, EXT4_IGET_NORMAL);\n\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"Inode %d not found\", darg.ino);\n\t\treturn 0;\n\t}\n\n\told_parent = ext4_iget(sb, darg.parent_ino,\n\t\t\t\tEXT4_IGET_NORMAL);\n\tif (IS_ERR(old_parent)) {\n\t\text4_debug(\"Dir with inode %d not found\", darg.parent_ino);\n\t\tiput(inode);\n\t\treturn 0;\n\t}\n\n\tret = __ext4_unlink(old_parent, &entry, inode, NULL);\n\t \n\tif (ret == -ENOENT)\n\t\tret = 0;\n\tiput(old_parent);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int ext4_fc_replay_link_internal(struct super_block *sb,\n\t\t\t\tstruct dentry_info_args *darg,\n\t\t\t\tstruct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tstruct dentry *dentry_dir = NULL, *dentry_inode = NULL;\n\tstruct qstr qstr_dname = QSTR_INIT(darg->dname, darg->dname_len);\n\tint ret = 0;\n\n\tdir = ext4_iget(sb, darg->parent_ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(dir)) {\n\t\text4_debug(\"Dir with inode %d not found.\", darg->parent_ino);\n\t\tdir = NULL;\n\t\tgoto out;\n\t}\n\n\tdentry_dir = d_obtain_alias(dir);\n\tif (IS_ERR(dentry_dir)) {\n\t\text4_debug(\"Failed to obtain dentry\");\n\t\tdentry_dir = NULL;\n\t\tgoto out;\n\t}\n\n\tdentry_inode = d_alloc(dentry_dir, &qstr_dname);\n\tif (!dentry_inode) {\n\t\text4_debug(\"Inode dentry not created.\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = __ext4_link(dir, inode, dentry_inode);\n\t \n\tif (ret && ret != -EEXIST) {\n\t\text4_debug(\"Failed to link\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tif (dentry_dir) {\n\t\td_drop(dentry_dir);\n\t\tdput(dentry_dir);\n\t} else if (dir) {\n\t\tiput(dir);\n\t}\n\tif (dentry_inode) {\n\t\td_drop(dentry_inode);\n\t\tdput(dentry_inode);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ext4_fc_replay_link(struct super_block *sb,\n\t\t\t       struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct inode *inode;\n\tstruct dentry_info_args darg;\n\tint ret = 0;\n\n\ttl_to_darg(&darg, tl, val);\n\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_LINK, darg.ino,\n\t\t\tdarg.parent_ino, darg.dname_len);\n\n\tinode = ext4_iget(sb, darg.ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"Inode not found.\");\n\t\treturn 0;\n\t}\n\n\tret = ext4_fc_replay_link_internal(sb, &darg, inode);\n\tiput(inode);\n\treturn ret;\n}\n\n \nstatic int ext4_fc_record_modified_inode(struct super_block *sb, int ino)\n{\n\tstruct ext4_fc_replay_state *state;\n\tint i;\n\n\tstate = &EXT4_SB(sb)->s_fc_replay_state;\n\tfor (i = 0; i < state->fc_modified_inodes_used; i++)\n\t\tif (state->fc_modified_inodes[i] == ino)\n\t\t\treturn 0;\n\tif (state->fc_modified_inodes_used == state->fc_modified_inodes_size) {\n\t\tint *fc_modified_inodes;\n\n\t\tfc_modified_inodes = krealloc(state->fc_modified_inodes,\n\t\t\t\tsizeof(int) * (state->fc_modified_inodes_size +\n\t\t\t\tEXT4_FC_REPLAY_REALLOC_INCREMENT),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!fc_modified_inodes)\n\t\t\treturn -ENOMEM;\n\t\tstate->fc_modified_inodes = fc_modified_inodes;\n\t\tstate->fc_modified_inodes_size +=\n\t\t\tEXT4_FC_REPLAY_REALLOC_INCREMENT;\n\t}\n\tstate->fc_modified_inodes[state->fc_modified_inodes_used++] = ino;\n\treturn 0;\n}\n\n \nstatic int ext4_fc_replay_inode(struct super_block *sb,\n\t\t\t\tstruct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct ext4_fc_inode fc_inode;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode *raw_fc_inode;\n\tstruct inode *inode = NULL;\n\tstruct ext4_iloc iloc;\n\tint inode_len, ino, ret, tag = tl->fc_tag;\n\tstruct ext4_extent_header *eh;\n\tsize_t off_gen = offsetof(struct ext4_inode, i_generation);\n\n\tmemcpy(&fc_inode, val, sizeof(fc_inode));\n\n\tino = le32_to_cpu(fc_inode.fc_ino);\n\ttrace_ext4_fc_replay(sb, tag, ino, 0, 0);\n\n\tinode = ext4_iget(sb, ino, EXT4_IGET_NORMAL);\n\tif (!IS_ERR(inode)) {\n\t\text4_ext_clear_bb(inode);\n\t\tiput(inode);\n\t}\n\tinode = NULL;\n\n\tret = ext4_fc_record_modified_inode(sb, ino);\n\tif (ret)\n\t\tgoto out;\n\n\traw_fc_inode = (struct ext4_inode *)\n\t\t(val + offsetof(struct ext4_fc_inode, fc_raw_inode));\n\tret = ext4_get_fc_inode_loc(sb, ino, &iloc);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_len = tl->fc_len - sizeof(struct ext4_fc_inode);\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tmemcpy(raw_inode, raw_fc_inode, offsetof(struct ext4_inode, i_block));\n\tmemcpy((u8 *)raw_inode + off_gen, (u8 *)raw_fc_inode + off_gen,\n\t       inode_len - off_gen);\n\tif (le32_to_cpu(raw_inode->i_flags) & EXT4_EXTENTS_FL) {\n\t\teh = (struct ext4_extent_header *)(&raw_inode->i_block[0]);\n\t\tif (eh->eh_magic != EXT4_EXT_MAGIC) {\n\t\t\tmemset(eh, 0, sizeof(*eh));\n\t\t\teh->eh_magic = EXT4_EXT_MAGIC;\n\t\t\teh->eh_max = cpu_to_le16(\n\t\t\t\t(sizeof(raw_inode->i_block) -\n\t\t\t\t sizeof(struct ext4_extent_header))\n\t\t\t\t / sizeof(struct ext4_extent));\n\t\t}\n\t} else if (le32_to_cpu(raw_inode->i_flags) & EXT4_INLINE_DATA_FL) {\n\t\tmemcpy(raw_inode->i_block, raw_fc_inode->i_block,\n\t\t\tsizeof(raw_inode->i_block));\n\t}\n\n\t \n\tret = ext4_handle_dirty_metadata(NULL, NULL, iloc.bh);\n\tif (ret)\n\t\tgoto out;\n\tret = sync_dirty_buffer(iloc.bh);\n\tif (ret)\n\t\tgoto out;\n\tret = ext4_mark_inode_used(sb, ino);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tinode = ext4_iget(sb, ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"Inode not found.\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA))\n\t\text4_ext_replay_set_iblocks(inode);\n\n\tinode->i_generation = le32_to_cpu(ext4_raw_inode(&iloc)->i_generation);\n\text4_reset_inode_seed(inode);\n\n\text4_inode_csum_set(inode, ext4_raw_inode(&iloc), EXT4_I(inode));\n\tret = ext4_handle_dirty_metadata(NULL, NULL, iloc.bh);\n\tsync_dirty_buffer(iloc.bh);\n\tbrelse(iloc.bh);\nout:\n\tiput(inode);\n\tif (!ret)\n\t\tblkdev_issue_flush(sb->s_bdev);\n\n\treturn 0;\n}\n\n \nstatic int ext4_fc_replay_create(struct super_block *sb,\n\t\t\t\t struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *dir = NULL;\n\tstruct dentry_info_args darg;\n\n\ttl_to_darg(&darg, tl, val);\n\n\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_CREAT, darg.ino,\n\t\t\tdarg.parent_ino, darg.dname_len);\n\n\t \n\tret = ext4_mark_inode_used(sb, darg.ino);\n\tif (ret)\n\t\tgoto out;\n\n\tinode = ext4_iget(sb, darg.ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"inode %d not found.\", darg.ino);\n\t\tinode = NULL;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t \n\t\tdir = ext4_iget(sb, darg.parent_ino, EXT4_IGET_NORMAL);\n\t\tif (IS_ERR(dir)) {\n\t\t\text4_debug(\"Dir %d not found.\", darg.ino);\n\t\t\tgoto out;\n\t\t}\n\t\tret = ext4_init_new_dir(NULL, dir, inode);\n\t\tiput(dir);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = ext4_fc_replay_link_internal(sb, &darg, inode);\n\tif (ret)\n\t\tgoto out;\n\tset_nlink(inode, 1);\n\text4_mark_inode_dirty(NULL, inode);\nout:\n\tiput(inode);\n\treturn ret;\n}\n\n \nint ext4_fc_record_regions(struct super_block *sb, int ino,\n\t\text4_lblk_t lblk, ext4_fsblk_t pblk, int len, int replay)\n{\n\tstruct ext4_fc_replay_state *state;\n\tstruct ext4_fc_alloc_region *region;\n\n\tstate = &EXT4_SB(sb)->s_fc_replay_state;\n\t \n\tif (replay && state->fc_regions_used != state->fc_regions_valid)\n\t\tstate->fc_regions_used = state->fc_regions_valid;\n\tif (state->fc_regions_used == state->fc_regions_size) {\n\t\tstruct ext4_fc_alloc_region *fc_regions;\n\n\t\tfc_regions = krealloc(state->fc_regions,\n\t\t\t\t      sizeof(struct ext4_fc_alloc_region) *\n\t\t\t\t      (state->fc_regions_size +\n\t\t\t\t       EXT4_FC_REPLAY_REALLOC_INCREMENT),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!fc_regions)\n\t\t\treturn -ENOMEM;\n\t\tstate->fc_regions_size +=\n\t\t\tEXT4_FC_REPLAY_REALLOC_INCREMENT;\n\t\tstate->fc_regions = fc_regions;\n\t}\n\tregion = &state->fc_regions[state->fc_regions_used++];\n\tregion->ino = ino;\n\tregion->lblk = lblk;\n\tregion->pblk = pblk;\n\tregion->len = len;\n\n\tif (replay)\n\t\tstate->fc_regions_valid++;\n\n\treturn 0;\n}\n\n \nstatic int ext4_fc_replay_add_range(struct super_block *sb,\n\t\t\t\t    struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct ext4_fc_add_range fc_add_ex;\n\tstruct ext4_extent newex, *ex;\n\tstruct inode *inode;\n\text4_lblk_t start, cur;\n\tint remaining, len;\n\text4_fsblk_t start_pblk;\n\tstruct ext4_map_blocks map;\n\tstruct ext4_ext_path *path = NULL;\n\tint ret;\n\n\tmemcpy(&fc_add_ex, val, sizeof(fc_add_ex));\n\tex = (struct ext4_extent *)&fc_add_ex.fc_ex;\n\n\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_ADD_RANGE,\n\t\tle32_to_cpu(fc_add_ex.fc_ino), le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\n\tinode = ext4_iget(sb, le32_to_cpu(fc_add_ex.fc_ino), EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"Inode not found.\");\n\t\treturn 0;\n\t}\n\n\tret = ext4_fc_record_modified_inode(sb, inode->i_ino);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = le32_to_cpu(ex->ee_block);\n\tstart_pblk = ext4_ext_pblock(ex);\n\tlen = ext4_ext_get_actual_len(ex);\n\n\tcur = start;\n\tremaining = len;\n\text4_debug(\"ADD_RANGE, lblk %d, pblk %lld, len %d, unwritten %d, inode %ld\\n\",\n\t\t  start, start_pblk, len, ext4_ext_is_unwritten(ex),\n\t\t  inode->i_ino);\n\n\twhile (remaining > 0) {\n\t\tmap.m_lblk = cur;\n\t\tmap.m_len = remaining;\n\t\tmap.m_pblk = 0;\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tpath = ext4_find_extent(inode, cur, NULL, 0);\n\t\t\tif (IS_ERR(path))\n\t\t\t\tgoto out;\n\t\t\tmemset(&newex, 0, sizeof(newex));\n\t\t\tnewex.ee_block = cpu_to_le32(cur);\n\t\t\text4_ext_store_pblock(\n\t\t\t\t&newex, start_pblk + cur - start);\n\t\t\tnewex.ee_len = cpu_to_le16(map.m_len);\n\t\t\tif (ext4_ext_is_unwritten(ex))\n\t\t\t\text4_ext_mark_unwritten(&newex);\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tret = ext4_ext_insert_extent(\n\t\t\t\tNULL, inode, &path, &newex, 0);\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\text4_free_ext_path(path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (start_pblk + cur - start != map.m_pblk) {\n\t\t\t \n\t\t\tret = ext4_ext_replay_update_ex(inode, cur, map.m_len,\n\t\t\t\t\text4_ext_is_unwritten(ex),\n\t\t\t\t\tstart_pblk + cur - start);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\text4_mb_mark_bb(inode->i_sb, map.m_pblk, map.m_len, 0);\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\text4_debug(\"Converting from %ld to %d %lld\",\n\t\t\t\tmap.m_flags & EXT4_MAP_UNWRITTEN,\n\t\t\text4_ext_is_unwritten(ex), map.m_pblk);\n\t\tret = ext4_ext_replay_update_ex(inode, cur, map.m_len,\n\t\t\t\t\text4_ext_is_unwritten(ex), map.m_pblk);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t \n\t\text4_ext_replay_shrink_inode(inode, start + len);\nnext:\n\t\tcur += map.m_len;\n\t\tremaining -= map.m_len;\n\t}\n\text4_ext_replay_shrink_inode(inode, i_size_read(inode) >>\n\t\t\t\t\tsb->s_blocksize_bits);\nout:\n\tiput(inode);\n\treturn 0;\n}\n\n \nstatic int\next4_fc_replay_del_range(struct super_block *sb,\n\t\t\t struct ext4_fc_tl_mem *tl, u8 *val)\n{\n\tstruct inode *inode;\n\tstruct ext4_fc_del_range lrange;\n\tstruct ext4_map_blocks map;\n\text4_lblk_t cur, remaining;\n\tint ret;\n\n\tmemcpy(&lrange, val, sizeof(lrange));\n\tcur = le32_to_cpu(lrange.fc_lblk);\n\tremaining = le32_to_cpu(lrange.fc_len);\n\n\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_DEL_RANGE,\n\t\tle32_to_cpu(lrange.fc_ino), cur, remaining);\n\n\tinode = ext4_iget(sb, le32_to_cpu(lrange.fc_ino), EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\text4_debug(\"Inode %d not found\", le32_to_cpu(lrange.fc_ino));\n\t\treturn 0;\n\t}\n\n\tret = ext4_fc_record_modified_inode(sb, inode->i_ino);\n\tif (ret)\n\t\tgoto out;\n\n\text4_debug(\"DEL_RANGE, inode %ld, lblk %d, len %d\\n\",\n\t\t\tinode->i_ino, le32_to_cpu(lrange.fc_lblk),\n\t\t\tle32_to_cpu(lrange.fc_len));\n\twhile (remaining > 0) {\n\t\tmap.m_lblk = cur;\n\t\tmap.m_len = remaining;\n\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret > 0) {\n\t\t\tremaining -= ret;\n\t\t\tcur += ret;\n\t\t\text4_mb_mark_bb(inode->i_sb, map.m_pblk, map.m_len, 0);\n\t\t} else {\n\t\t\tremaining -= map.m_len;\n\t\t\tcur += map.m_len;\n\t\t}\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_remove_space(inode, le32_to_cpu(lrange.fc_lblk),\n\t\t\t\tle32_to_cpu(lrange.fc_lblk) +\n\t\t\t\tle32_to_cpu(lrange.fc_len) - 1);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (ret)\n\t\tgoto out;\n\text4_ext_replay_shrink_inode(inode,\n\t\ti_size_read(inode) >> sb->s_blocksize_bits);\n\text4_mark_inode_dirty(NULL, inode);\nout:\n\tiput(inode);\n\treturn 0;\n}\n\nstatic void ext4_fc_set_bitmaps_and_counters(struct super_block *sb)\n{\n\tstruct ext4_fc_replay_state *state;\n\tstruct inode *inode;\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_map_blocks map;\n\tint i, ret, j;\n\text4_lblk_t cur, end;\n\n\tstate = &EXT4_SB(sb)->s_fc_replay_state;\n\tfor (i = 0; i < state->fc_modified_inodes_used; i++) {\n\t\tinode = ext4_iget(sb, state->fc_modified_inodes[i],\n\t\t\tEXT4_IGET_NORMAL);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_debug(\"Inode %d not found.\",\n\t\t\t\tstate->fc_modified_inodes[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tcur = 0;\n\t\tend = EXT_MAX_BLOCKS;\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA)) {\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (cur < end) {\n\t\t\tmap.m_lblk = cur;\n\t\t\tmap.m_len = end - cur;\n\n\t\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0) {\n\t\t\t\tpath = ext4_find_extent(inode, map.m_lblk, NULL, 0);\n\t\t\t\tif (!IS_ERR(path)) {\n\t\t\t\t\tfor (j = 0; j < path->p_depth; j++)\n\t\t\t\t\t\text4_mb_mark_bb(inode->i_sb,\n\t\t\t\t\t\t\tpath[j].p_block, 1, 1);\n\t\t\t\t\text4_free_ext_path(path);\n\t\t\t\t}\n\t\t\t\tcur += ret;\n\t\t\t\text4_mb_mark_bb(inode->i_sb, map.m_pblk,\n\t\t\t\t\t\t\tmap.m_len, 1);\n\t\t\t} else {\n\t\t\t\tcur = cur + (map.m_len ? map.m_len : 1);\n\t\t\t}\n\t\t}\n\t\tiput(inode);\n\t}\n}\n\n \nbool ext4_fc_replay_check_excluded(struct super_block *sb, ext4_fsblk_t blk)\n{\n\tint i;\n\tstruct ext4_fc_replay_state *state;\n\n\tstate = &EXT4_SB(sb)->s_fc_replay_state;\n\tfor (i = 0; i < state->fc_regions_valid; i++) {\n\t\tif (state->fc_regions[i].ino == 0 ||\n\t\t\tstate->fc_regions[i].len == 0)\n\t\t\tcontinue;\n\t\tif (in_range(blk, state->fc_regions[i].pblk,\n\t\t\t\t\tstate->fc_regions[i].len))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid ext4_fc_replay_cleanup(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tsbi->s_mount_state &= ~EXT4_FC_REPLAY;\n\tkfree(sbi->s_fc_replay_state.fc_regions);\n\tkfree(sbi->s_fc_replay_state.fc_modified_inodes);\n}\n\nstatic bool ext4_fc_value_len_isvalid(struct ext4_sb_info *sbi,\n\t\t\t\t      int tag, int len)\n{\n\tswitch (tag) {\n\tcase EXT4_FC_TAG_ADD_RANGE:\n\t\treturn len == sizeof(struct ext4_fc_add_range);\n\tcase EXT4_FC_TAG_DEL_RANGE:\n\t\treturn len == sizeof(struct ext4_fc_del_range);\n\tcase EXT4_FC_TAG_CREAT:\n\tcase EXT4_FC_TAG_LINK:\n\tcase EXT4_FC_TAG_UNLINK:\n\t\tlen -= sizeof(struct ext4_fc_dentry_info);\n\t\treturn len >= 1 && len <= EXT4_NAME_LEN;\n\tcase EXT4_FC_TAG_INODE:\n\t\tlen -= sizeof(struct ext4_fc_inode);\n\t\treturn len >= EXT4_GOOD_OLD_INODE_SIZE &&\n\t\t\tlen <= sbi->s_inode_size;\n\tcase EXT4_FC_TAG_PAD:\n\t\treturn true;  \n\tcase EXT4_FC_TAG_TAIL:\n\t\treturn len >= sizeof(struct ext4_fc_tail);\n\tcase EXT4_FC_TAG_HEAD:\n\t\treturn len == sizeof(struct ext4_fc_head);\n\t}\n\treturn false;\n}\n\n \nstatic int ext4_fc_replay_scan(journal_t *journal,\n\t\t\t\tstruct buffer_head *bh, int off,\n\t\t\t\ttid_t expected_tid)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_fc_replay_state *state;\n\tint ret = JBD2_FC_REPLAY_CONTINUE;\n\tstruct ext4_fc_add_range ext;\n\tstruct ext4_fc_tl_mem tl;\n\tstruct ext4_fc_tail tail;\n\t__u8 *start, *end, *cur, *val;\n\tstruct ext4_fc_head head;\n\tstruct ext4_extent *ex;\n\n\tstate = &sbi->s_fc_replay_state;\n\n\tstart = (u8 *)bh->b_data;\n\tend = start + journal->j_blocksize;\n\n\tif (state->fc_replay_expected_off == 0) {\n\t\tstate->fc_cur_tag = 0;\n\t\tstate->fc_replay_num_tags = 0;\n\t\tstate->fc_crc = 0;\n\t\tstate->fc_regions = NULL;\n\t\tstate->fc_regions_valid = state->fc_regions_used =\n\t\t\tstate->fc_regions_size = 0;\n\t\t \n\t\tif (le16_to_cpu(((struct ext4_fc_tl *)start)->fc_tag)\n\t\t\t!= EXT4_FC_TAG_HEAD)\n\t\t\treturn 0;\n\t}\n\n\tif (off != state->fc_replay_expected_off) {\n\t\tret = -EFSCORRUPTED;\n\t\tgoto out_err;\n\t}\n\n\tstate->fc_replay_expected_off++;\n\tfor (cur = start; cur <= end - EXT4_FC_TAG_BASE_LEN;\n\t     cur = cur + EXT4_FC_TAG_BASE_LEN + tl.fc_len) {\n\t\text4_fc_get_tl(&tl, cur);\n\t\tval = cur + EXT4_FC_TAG_BASE_LEN;\n\t\tif (tl.fc_len > end - val ||\n\t\t    !ext4_fc_value_len_isvalid(sbi, tl.fc_tag, tl.fc_len)) {\n\t\t\tret = state->fc_replay_num_tags ?\n\t\t\t\tJBD2_FC_REPLAY_STOP : -ECANCELED;\n\t\t\tgoto out_err;\n\t\t}\n\t\text4_debug(\"Scan phase, tag:%s, blk %lld\\n\",\n\t\t\t   tag2str(tl.fc_tag), bh->b_blocknr);\n\t\tswitch (tl.fc_tag) {\n\t\tcase EXT4_FC_TAG_ADD_RANGE:\n\t\t\tmemcpy(&ext, val, sizeof(ext));\n\t\t\tex = (struct ext4_extent *)&ext.fc_ex;\n\t\t\tret = ext4_fc_record_regions(sb,\n\t\t\t\tle32_to_cpu(ext.fc_ino),\n\t\t\t\tle32_to_cpu(ex->ee_block), ext4_ext_pblock(ex),\n\t\t\t\text4_ext_get_actual_len(ex), 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tret = JBD2_FC_REPLAY_CONTINUE;\n\t\t\tfallthrough;\n\t\tcase EXT4_FC_TAG_DEL_RANGE:\n\t\tcase EXT4_FC_TAG_LINK:\n\t\tcase EXT4_FC_TAG_UNLINK:\n\t\tcase EXT4_FC_TAG_CREAT:\n\t\tcase EXT4_FC_TAG_INODE:\n\t\tcase EXT4_FC_TAG_PAD:\n\t\t\tstate->fc_cur_tag++;\n\t\t\tstate->fc_crc = ext4_chksum(sbi, state->fc_crc, cur,\n\t\t\t\tEXT4_FC_TAG_BASE_LEN + tl.fc_len);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_TAIL:\n\t\t\tstate->fc_cur_tag++;\n\t\t\tmemcpy(&tail, val, sizeof(tail));\n\t\t\tstate->fc_crc = ext4_chksum(sbi, state->fc_crc, cur,\n\t\t\t\t\t\tEXT4_FC_TAG_BASE_LEN +\n\t\t\t\t\t\toffsetof(struct ext4_fc_tail,\n\t\t\t\t\t\tfc_crc));\n\t\t\tif (le32_to_cpu(tail.fc_tid) == expected_tid &&\n\t\t\t\tle32_to_cpu(tail.fc_crc) == state->fc_crc) {\n\t\t\t\tstate->fc_replay_num_tags = state->fc_cur_tag;\n\t\t\t\tstate->fc_regions_valid =\n\t\t\t\t\tstate->fc_regions_used;\n\t\t\t} else {\n\t\t\t\tret = state->fc_replay_num_tags ?\n\t\t\t\t\tJBD2_FC_REPLAY_STOP : -EFSBADCRC;\n\t\t\t}\n\t\t\tstate->fc_crc = 0;\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_HEAD:\n\t\t\tmemcpy(&head, val, sizeof(head));\n\t\t\tif (le32_to_cpu(head.fc_features) &\n\t\t\t\t~EXT4_FC_SUPPORTED_FEATURES) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (le32_to_cpu(head.fc_tid) != expected_tid) {\n\t\t\t\tret = JBD2_FC_REPLAY_STOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate->fc_cur_tag++;\n\t\t\tstate->fc_crc = ext4_chksum(sbi, state->fc_crc, cur,\n\t\t\t\tEXT4_FC_TAG_BASE_LEN + tl.fc_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = state->fc_replay_num_tags ?\n\t\t\t\tJBD2_FC_REPLAY_STOP : -ECANCELED;\n\t\t}\n\t\tif (ret < 0 || ret == JBD2_FC_REPLAY_STOP)\n\t\t\tbreak;\n\t}\n\nout_err:\n\ttrace_ext4_fc_replay_scan(sb, ret, off);\n\treturn ret;\n}\n\n \nstatic int ext4_fc_replay(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tenum passtype pass, int off, tid_t expected_tid)\n{\n\tstruct super_block *sb = journal->j_private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_fc_tl_mem tl;\n\t__u8 *start, *end, *cur, *val;\n\tint ret = JBD2_FC_REPLAY_CONTINUE;\n\tstruct ext4_fc_replay_state *state = &sbi->s_fc_replay_state;\n\tstruct ext4_fc_tail tail;\n\n\tif (pass == PASS_SCAN) {\n\t\tstate->fc_current_pass = PASS_SCAN;\n\t\treturn ext4_fc_replay_scan(journal, bh, off, expected_tid);\n\t}\n\n\tif (state->fc_current_pass != pass) {\n\t\tstate->fc_current_pass = pass;\n\t\tsbi->s_mount_state |= EXT4_FC_REPLAY;\n\t}\n\tif (!sbi->s_fc_replay_state.fc_replay_num_tags) {\n\t\text4_debug(\"Replay stops\\n\");\n\t\text4_fc_set_bitmaps_and_counters(sb);\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_EXT4_DEBUG\n\tif (sbi->s_fc_debug_max_replay && off >= sbi->s_fc_debug_max_replay) {\n\t\tpr_warn(\"Dropping fc block %d because max_replay set\\n\", off);\n\t\treturn JBD2_FC_REPLAY_STOP;\n\t}\n#endif\n\n\tstart = (u8 *)bh->b_data;\n\tend = start + journal->j_blocksize;\n\n\tfor (cur = start; cur <= end - EXT4_FC_TAG_BASE_LEN;\n\t     cur = cur + EXT4_FC_TAG_BASE_LEN + tl.fc_len) {\n\t\text4_fc_get_tl(&tl, cur);\n\t\tval = cur + EXT4_FC_TAG_BASE_LEN;\n\n\t\tif (state->fc_replay_num_tags == 0) {\n\t\t\tret = JBD2_FC_REPLAY_STOP;\n\t\t\text4_fc_set_bitmaps_and_counters(sb);\n\t\t\tbreak;\n\t\t}\n\n\t\text4_debug(\"Replay phase, tag:%s\\n\", tag2str(tl.fc_tag));\n\t\tstate->fc_replay_num_tags--;\n\t\tswitch (tl.fc_tag) {\n\t\tcase EXT4_FC_TAG_LINK:\n\t\t\tret = ext4_fc_replay_link(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_UNLINK:\n\t\t\tret = ext4_fc_replay_unlink(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_ADD_RANGE:\n\t\t\tret = ext4_fc_replay_add_range(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_CREAT:\n\t\t\tret = ext4_fc_replay_create(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_DEL_RANGE:\n\t\t\tret = ext4_fc_replay_del_range(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_INODE:\n\t\t\tret = ext4_fc_replay_inode(sb, &tl, val);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_PAD:\n\t\t\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_PAD, 0,\n\t\t\t\t\t     tl.fc_len, 0);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_TAIL:\n\t\t\ttrace_ext4_fc_replay(sb, EXT4_FC_TAG_TAIL,\n\t\t\t\t\t     0, tl.fc_len, 0);\n\t\t\tmemcpy(&tail, val, sizeof(tail));\n\t\t\tWARN_ON(le32_to_cpu(tail.fc_tid) != expected_tid);\n\t\t\tbreak;\n\t\tcase EXT4_FC_TAG_HEAD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_ext4_fc_replay(sb, tl.fc_tag, 0, tl.fc_len, 0);\n\t\t\tret = -ECANCELED;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = JBD2_FC_REPLAY_CONTINUE;\n\t}\n\treturn ret;\n}\n\nvoid ext4_fc_init(struct super_block *sb, journal_t *journal)\n{\n\t \n\tjournal->j_fc_replay_callback = ext4_fc_replay;\n\tif (!test_opt2(sb, JOURNAL_FAST_COMMIT))\n\t\treturn;\n\tjournal->j_fc_cleanup_callback = ext4_fc_cleanup;\n}\n\nstatic const char * const fc_ineligible_reasons[] = {\n\t[EXT4_FC_REASON_XATTR] = \"Extended attributes changed\",\n\t[EXT4_FC_REASON_CROSS_RENAME] = \"Cross rename\",\n\t[EXT4_FC_REASON_JOURNAL_FLAG_CHANGE] = \"Journal flag changed\",\n\t[EXT4_FC_REASON_NOMEM] = \"Insufficient memory\",\n\t[EXT4_FC_REASON_SWAP_BOOT] = \"Swap boot\",\n\t[EXT4_FC_REASON_RESIZE] = \"Resize\",\n\t[EXT4_FC_REASON_RENAME_DIR] = \"Dir renamed\",\n\t[EXT4_FC_REASON_FALLOC_RANGE] = \"Falloc range op\",\n\t[EXT4_FC_REASON_INODE_JOURNAL_DATA] = \"Data journalling\",\n\t[EXT4_FC_REASON_ENCRYPTED_FILENAME] = \"Encrypted filename\",\n};\n\nint ext4_fc_info_show(struct seq_file *seq, void *v)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB((struct super_block *)seq->private);\n\tstruct ext4_fc_stats *stats = &sbi->s_fc_stats;\n\tint i;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\n\tseq_printf(seq,\n\t\t\"fc stats:\\n%ld commits\\n%ld ineligible\\n%ld numblks\\n%lluus avg_commit_time\\n\",\n\t\t   stats->fc_num_commits, stats->fc_ineligible_commits,\n\t\t   stats->fc_numblks,\n\t\t   div_u64(stats->s_fc_avg_commit_time, 1000));\n\tseq_puts(seq, \"Ineligible reasons:\\n\");\n\tfor (i = 0; i < EXT4_FC_REASON_MAX; i++)\n\t\tseq_printf(seq, \"\\\"%s\\\":\\t%d\\n\", fc_ineligible_reasons[i],\n\t\t\tstats->fc_ineligible_reason_count[i]);\n\n\treturn 0;\n}\n\nint __init ext4_fc_init_dentry_cache(void)\n{\n\text4_fc_dentry_cachep = KMEM_CACHE(ext4_fc_dentry_update,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\n\tif (ext4_fc_dentry_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ext4_fc_destroy_dentry_cache(void)\n{\n\tkmem_cache_destroy(ext4_fc_dentry_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}