{
  "module_name": "mballoc.c",
  "hash_id": "511b784283314461cc56184620f1de49c63af613563f7bdebb61f8d74a60f60d",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/mballoc.c",
  "human_readable_source": "\n \n\n\n \n\n#include \"ext4_jbd2.h\"\n#include \"mballoc.h\"\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/backing-dev.h>\n#include <linux/freezer.h>\n#include <trace/events/ext4.h>\n\n \n\n \n\n \n\n  \n\n \nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\n \n#define NR_GRPINFO_CACHES 8\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic const char * const ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_new_preallocation(struct ext4_allocation_context *ac);\n\nstatic bool ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t       ext4_group_t group, enum criteria cr);\n\nstatic int ext4_try_to_trim_range(struct super_block *sb,\n\t\tstruct ext4_buddy *e4b, ext4_grpblk_t start,\n\t\text4_grpblk_t max, ext4_grpblk_t minblocks);\n\n \nstatic DEFINE_PER_CPU(u64, discard_pa_seq);\nstatic inline u64 ext4_get_discard_pa_seq_sum(void)\n{\n\tint __cpu;\n\tu64 __seq = 0;\n\n\tfor_each_possible_cpu(__cpu)\n\t\t__seq += per_cpu(discard_pa_seq, __cpu);\n\treturn __seq;\n}\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t \n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}\n\nstatic inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t \n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}\n\n#ifdef DOUBLE_CHECK\nstatic void mb_free_blocks_double(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint i;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(first + i, e4b->bd_info->bb_bitmap)) {\n\t\t\text4_fsblk_t blocknr;\n\n\t\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\t\tblocknr += EXT4_C2B(EXT4_SB(sb), first + i);\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing block already freed \"\n\t\t\t\t\t      \"(bit %u)\",\n\t\t\t\t\t      first + i);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t}\n\t\tmb_clear_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}\n\nstatic void mb_mark_used_double(struct ext4_buddy *e4b, int first, int count)\n{\n\tint i;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tBUG_ON(mb_test_bit(first + i, e4b->bd_info->bb_bitmap));\n\t\tmb_set_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}\n\nstatic void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tif (memcmp(e4b->bd_info->bb_bitmap, bitmap, e4b->bd_sb->s_blocksize)) {\n\t\tunsigned char *b1, *b2;\n\t\tint i;\n\t\tb1 = (unsigned char *) e4b->bd_info->bb_bitmap;\n\t\tb2 = (unsigned char *) bitmap;\n\t\tfor (i = 0; i < e4b->bd_sb->s_blocksize; i++) {\n\t\t\tif (b1[i] != b2[i]) {\n\t\t\t\text4_msg(e4b->bd_sb, KERN_ERR,\n\t\t\t\t\t \"corruption in group %u \"\n\t\t\t\t\t \"at byte %u(%u): %x in copy != %x \"\n\t\t\t\t\t \"on disk/prealloc\",\n\t\t\t\t\t e4b->bd_group, i, i * 8, b1[i], b2[i]);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void mb_group_bb_bitmap_alloc(struct super_block *sb,\n\t\t\tstruct ext4_group_info *grp, ext4_group_t group)\n{\n\tstruct buffer_head *bh;\n\n\tgrp->bb_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!grp->bb_bitmap)\n\t\treturn;\n\n\tbh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR_OR_NULL(bh)) {\n\t\tkfree(grp->bb_bitmap);\n\t\tgrp->bb_bitmap = NULL;\n\t\treturn;\n\t}\n\n\tmemcpy(grp->bb_bitmap, bh->b_data, sb->s_blocksize);\n\tput_bh(bh);\n}\n\nstatic void mb_group_bb_bitmap_free(struct ext4_group_info *grp)\n{\n\tkfree(grp->bb_bitmap);\n}\n\n#else\nstatic inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}\nstatic inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}\nstatic inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}\n\nstatic inline void mb_group_bb_bitmap_alloc(struct super_block *sb,\n\t\t\tstruct ext4_group_info *grp, ext4_group_t group)\n{\n\treturn;\n}\n\nstatic inline void mb_group_bb_bitmap_free(struct ext4_group_info *grp)\n{\n\treturn;\n}\n#endif\n\n#ifdef AGGRESSIVE_CHECK\n\n#define MB_CHECK_ASSERT(assert)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (!(assert)) {\t\t\t\t\t\t\\\n\t\tprintk(KERN_EMERG\t\t\t\t\t\\\n\t\t\t\"Assertion failure in %s() at %s:%d: \\\"%s\\\"\\n\",\t\\\n\t\t\tfunction, file, line, # assert);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic int __mb_check_buddy(struct ext4_buddy *e4b, char *file,\n\t\t\t\tconst char *function, int line)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tint order = e4b->bd_blkbits + 1;\n\tint max;\n\tint max2;\n\tint i;\n\tint j;\n\tint k;\n\tint count;\n\tstruct ext4_group_info *grp;\n\tint fragments = 0;\n\tint fstart;\n\tstruct list_head *cur;\n\tvoid *buddy;\n\tvoid *buddy2;\n\n\tif (e4b->bd_info->bb_check_counter++ % 10)\n\t\treturn 0;\n\n\twhile (order > 1) {\n\t\tbuddy = mb_find_buddy(e4b, order, &max);\n\t\tMB_CHECK_ASSERT(buddy);\n\t\tbuddy2 = mb_find_buddy(e4b, order - 1, &max2);\n\t\tMB_CHECK_ASSERT(buddy2);\n\t\tMB_CHECK_ASSERT(buddy != buddy2);\n\t\tMB_CHECK_ASSERT(max * 2 == max2);\n\n\t\tcount = 0;\n\t\tfor (i = 0; i < max; i++) {\n\n\t\t\tif (mb_test_bit(i, buddy)) {\n\t\t\t\t \n\t\t\t\tif (!mb_test_bit(i << 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit((i<<1)+1, buddy2));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tMB_CHECK_ASSERT(mb_test_bit(i << 1, buddy2));\n\t\t\tMB_CHECK_ASSERT(mb_test_bit((i << 1) + 1, buddy2));\n\n\t\t\tfor (j = 0; j < (1 << order); j++) {\n\t\t\t\tk = (i * (1 << order)) + j;\n\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t!mb_test_bit(k, e4b->bd_bitmap));\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tMB_CHECK_ASSERT(e4b->bd_info->bb_counters[order] == count);\n\t\torder--;\n\t}\n\n\tfstart = -1;\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tfor (i = 0; i < max; i++) {\n\t\tif (!mb_test_bit(i, buddy)) {\n\t\t\tMB_CHECK_ASSERT(i >= e4b->bd_info->bb_first_free);\n\t\t\tif (fstart == -1) {\n\t\t\t\tfragments++;\n\t\t\t\tfstart = i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfstart = -1;\n\t\t \n\t\tfor (j = 0; j < e4b->bd_blkbits + 1; j++) {\n\t\t\tbuddy2 = mb_find_buddy(e4b, j, &max2);\n\t\t\tk = i >> j;\n\t\t\tMB_CHECK_ASSERT(k < max2);\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k, buddy2));\n\t\t}\n\t}\n\tMB_CHECK_ASSERT(!EXT4_MB_GRP_NEED_INIT(e4b->bd_info));\n\tMB_CHECK_ASSERT(e4b->bd_info->bb_fragments == fragments);\n\n\tgrp = ext4_get_group_info(sb, e4b->bd_group);\n\tif (!grp)\n\t\treturn NULL;\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\text4_group_t groupnr;\n\t\tstruct ext4_prealloc_space *pa;\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart, &groupnr, &k);\n\t\tMB_CHECK_ASSERT(groupnr == e4b->bd_group);\n\t\tfor (i = 0; i < pa->pa_len; i++)\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k + i, buddy));\n\t}\n\treturn 0;\n}\n#undef MB_CHECK_ASSERT\n#define mb_check_buddy(e4b) __mb_check_buddy(e4b,\t\\\n\t\t\t\t\t__FILE__, __func__, __LINE__)\n#else\n#define mb_check_buddy(e4b)\n#endif\n\n \nstatic void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned int border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t \n\t\tmax = ffs(first | border) - 1;\n\n\t\t \n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t \n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}\n\nstatic int mb_avg_fragment_size_order(struct super_block *sb, ext4_grpblk_t len)\n{\n\tint order;\n\n\t \n\torder = fls(len) - 2;\n\tif (order < 0)\n\t\treturn 0;\n\tif (order == MB_NUM_ORDERS(sb))\n\t\torder--;\n\treturn order;\n}\n\n \nstatic void\nmb_update_avg_fragment_size(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint new_order;\n\n\tif (!test_opt2(sb, MB_OPTIMIZE_SCAN) || grp->bb_free == 0)\n\t\treturn;\n\n\tnew_order = mb_avg_fragment_size_order(sb,\n\t\t\t\t\tgrp->bb_free / grp->bb_fragments);\n\tif (new_order == grp->bb_avg_fragment_size_order)\n\t\treturn;\n\n\tif (grp->bb_avg_fragment_size_order != -1) {\n\t\twrite_lock(&sbi->s_mb_avg_fragment_size_locks[\n\t\t\t\t\tgrp->bb_avg_fragment_size_order]);\n\t\tlist_del(&grp->bb_avg_fragment_size_node);\n\t\twrite_unlock(&sbi->s_mb_avg_fragment_size_locks[\n\t\t\t\t\tgrp->bb_avg_fragment_size_order]);\n\t}\n\tgrp->bb_avg_fragment_size_order = new_order;\n\twrite_lock(&sbi->s_mb_avg_fragment_size_locks[\n\t\t\t\t\tgrp->bb_avg_fragment_size_order]);\n\tlist_add_tail(&grp->bb_avg_fragment_size_node,\n\t\t&sbi->s_mb_avg_fragment_size[grp->bb_avg_fragment_size_order]);\n\twrite_unlock(&sbi->s_mb_avg_fragment_size_locks[\n\t\t\t\t\tgrp->bb_avg_fragment_size_order]);\n}\n\n \nstatic void ext4_mb_choose_next_group_p2_aligned(struct ext4_allocation_context *ac,\n\t\t\tenum criteria *new_cr, ext4_group_t *group, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *iter;\n\tint i;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\n\tif (unlikely(sbi->s_mb_stats && ac->ac_flags & EXT4_MB_CR_POWER2_ALIGNED_OPTIMIZED))\n\t\tatomic_inc(&sbi->s_bal_p2_aligned_bad_suggestions);\n\n\tfor (i = ac->ac_2order; i < MB_NUM_ORDERS(ac->ac_sb); i++) {\n\t\tif (list_empty(&sbi->s_mb_largest_free_orders[i]))\n\t\t\tcontinue;\n\t\tread_lock(&sbi->s_mb_largest_free_orders_locks[i]);\n\t\tif (list_empty(&sbi->s_mb_largest_free_orders[i])) {\n\t\t\tread_unlock(&sbi->s_mb_largest_free_orders_locks[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_for_each_entry(iter, &sbi->s_mb_largest_free_orders[i],\n\t\t\t\t    bb_largest_free_order_node) {\n\t\t\tif (sbi->s_mb_stats)\n\t\t\t\tatomic64_inc(&sbi->s_bal_cX_groups_considered[CR_POWER2_ALIGNED]);\n\t\t\tif (likely(ext4_mb_good_group(ac, iter->bb_group, CR_POWER2_ALIGNED))) {\n\t\t\t\t*group = iter->bb_group;\n\t\t\t\tac->ac_flags |= EXT4_MB_CR_POWER2_ALIGNED_OPTIMIZED;\n\t\t\t\tread_unlock(&sbi->s_mb_largest_free_orders_locks[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&sbi->s_mb_largest_free_orders_locks[i]);\n\t}\n\n\t \n\t*new_cr = CR_GOAL_LEN_FAST;\n}\n\n \nstatic struct ext4_group_info *\next4_mb_find_good_group_avg_frag_lists(struct ext4_allocation_context *ac, int order)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct list_head *frag_list = &sbi->s_mb_avg_fragment_size[order];\n\trwlock_t *frag_list_lock = &sbi->s_mb_avg_fragment_size_locks[order];\n\tstruct ext4_group_info *grp = NULL, *iter;\n\tenum criteria cr = ac->ac_criteria;\n\n\tif (list_empty(frag_list))\n\t\treturn NULL;\n\tread_lock(frag_list_lock);\n\tif (list_empty(frag_list)) {\n\t\tread_unlock(frag_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(iter, frag_list, bb_avg_fragment_size_node) {\n\t\tif (sbi->s_mb_stats)\n\t\t\tatomic64_inc(&sbi->s_bal_cX_groups_considered[cr]);\n\t\tif (likely(ext4_mb_good_group(ac, iter->bb_group, cr))) {\n\t\t\tgrp = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(frag_list_lock);\n\treturn grp;\n}\n\n \nstatic void ext4_mb_choose_next_group_goal_fast(struct ext4_allocation_context *ac,\n\t\tenum criteria *new_cr, ext4_group_t *group, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = NULL;\n\tint i;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_CR_GOAL_LEN_FAST_OPTIMIZED)) {\n\t\tif (sbi->s_mb_stats)\n\t\t\tatomic_inc(&sbi->s_bal_goal_fast_bad_suggestions);\n\t}\n\n\tfor (i = mb_avg_fragment_size_order(ac->ac_sb, ac->ac_g_ex.fe_len);\n\t     i < MB_NUM_ORDERS(ac->ac_sb); i++) {\n\t\tgrp = ext4_mb_find_good_group_avg_frag_lists(ac, i);\n\t\tif (grp) {\n\t\t\t*group = grp->bb_group;\n\t\t\tac->ac_flags |= EXT4_MB_CR_GOAL_LEN_FAST_OPTIMIZED;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (ac->ac_flags & EXT4_MB_HINT_DATA)\n\t\t*new_cr = CR_BEST_AVAIL_LEN;\n\telse\n\t\t*new_cr = CR_GOAL_LEN_SLOW;\n}\n\n \nstatic void ext4_mb_choose_next_group_best_avail(struct ext4_allocation_context *ac,\n\t\tenum criteria *new_cr, ext4_group_t *group, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = NULL;\n\tint i, order, min_order;\n\tunsigned long num_stripe_clusters = 0;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_CR_BEST_AVAIL_LEN_OPTIMIZED)) {\n\t\tif (sbi->s_mb_stats)\n\t\t\tatomic_inc(&sbi->s_bal_best_avail_bad_suggestions);\n\t}\n\n\t \n\torder = fls(ac->ac_g_ex.fe_len) - 1;\n\tmin_order = order - sbi->s_mb_best_avail_max_trim_order;\n\tif (min_order < 0)\n\t\tmin_order = 0;\n\n\tif (sbi->s_stripe > 0) {\n\t\t \n\t\tnum_stripe_clusters = EXT4_NUM_B2C(sbi, sbi->s_stripe);\n\t\tif (1 << min_order < num_stripe_clusters)\n\t\t\t \n\t\t\tmin_order = fls(num_stripe_clusters) - 1;\n\t}\n\n\tif (1 << min_order < ac->ac_o_ex.fe_len)\n\t\tmin_order = fls(ac->ac_o_ex.fe_len);\n\n\tfor (i = order; i >= min_order; i--) {\n\t\tint frag_order;\n\t\t \n\t\tac->ac_g_ex.fe_len = 1 << i;\n\n\t\tif (num_stripe_clusters > 0) {\n\t\t\t \n\t\t\tac->ac_g_ex.fe_len = roundup(ac->ac_g_ex.fe_len,\n\t\t\t\t\t\t     num_stripe_clusters);\n\t\t}\n\n\t\tfrag_order = mb_avg_fragment_size_order(ac->ac_sb,\n\t\t\t\t\t\t\tac->ac_g_ex.fe_len);\n\n\t\tgrp = ext4_mb_find_good_group_avg_frag_lists(ac, frag_order);\n\t\tif (grp) {\n\t\t\t*group = grp->bb_group;\n\t\t\tac->ac_flags |= EXT4_MB_CR_BEST_AVAIL_LEN_OPTIMIZED;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tac->ac_g_ex.fe_len = ac->ac_orig_goal_len;\n\t*new_cr = CR_GOAL_LEN_SLOW;\n}\n\nstatic inline int should_optimize_scan(struct ext4_allocation_context *ac)\n{\n\tif (unlikely(!test_opt2(ac->ac_sb, MB_OPTIMIZE_SCAN)))\n\t\treturn 0;\n\tif (ac->ac_criteria >= CR_GOAL_LEN_SLOW)\n\t\treturn 0;\n\tif (!ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic ext4_group_t\nnext_linear_group(struct ext4_allocation_context *ac, ext4_group_t group,\n\t\t  ext4_group_t ngroups)\n{\n\tif (!should_optimize_scan(ac))\n\t\tgoto inc_and_return;\n\n\tif (ac->ac_groups_linear_remaining) {\n\t\tac->ac_groups_linear_remaining--;\n\t\tgoto inc_and_return;\n\t}\n\n\treturn group;\ninc_and_return:\n\t \n\treturn group + 1 >= ngroups ? 0 : group + 1;\n}\n\n \nstatic void ext4_mb_choose_next_group(struct ext4_allocation_context *ac,\n\t\tenum criteria *new_cr, ext4_group_t *group, ext4_group_t ngroups)\n{\n\t*new_cr = ac->ac_criteria;\n\n\tif (!should_optimize_scan(ac) || ac->ac_groups_linear_remaining) {\n\t\t*group = next_linear_group(ac, *group, ngroups);\n\t\treturn;\n\t}\n\n\tif (*new_cr == CR_POWER2_ALIGNED) {\n\t\text4_mb_choose_next_group_p2_aligned(ac, new_cr, group, ngroups);\n\t} else if (*new_cr == CR_GOAL_LEN_FAST) {\n\t\text4_mb_choose_next_group_goal_fast(ac, new_cr, group, ngroups);\n\t} else if (*new_cr == CR_BEST_AVAIL_LEN) {\n\t\text4_mb_choose_next_group_best_avail(ac, new_cr, group, ngroups);\n\t} else {\n\t\t \n\t\tWARN_ON(1);\n\t}\n}\n\n \nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint i;\n\n\tfor (i = MB_NUM_ORDERS(sb) - 1; i >= 0; i--)\n\t\tif (grp->bb_counters[i] > 0)\n\t\t\tbreak;\n\t \n\tif (!test_opt2(sb, MB_OPTIMIZE_SCAN) ||\n\t    i == grp->bb_largest_free_order) {\n\t\tgrp->bb_largest_free_order = i;\n\t\treturn;\n\t}\n\n\tif (grp->bb_largest_free_order >= 0) {\n\t\twrite_lock(&sbi->s_mb_largest_free_orders_locks[\n\t\t\t\t\t      grp->bb_largest_free_order]);\n\t\tlist_del_init(&grp->bb_largest_free_order_node);\n\t\twrite_unlock(&sbi->s_mb_largest_free_orders_locks[\n\t\t\t\t\t      grp->bb_largest_free_order]);\n\t}\n\tgrp->bb_largest_free_order = i;\n\tif (grp->bb_largest_free_order >= 0 && grp->bb_free) {\n\t\twrite_lock(&sbi->s_mb_largest_free_orders_locks[\n\t\t\t\t\t      grp->bb_largest_free_order]);\n\t\tlist_add_tail(&grp->bb_largest_free_order_node,\n\t\t      &sbi->s_mb_largest_free_orders[grp->bb_largest_free_order]);\n\t\twrite_unlock(&sbi->s_mb_largest_free_orders_locks[\n\t\t\t\t\t      grp->bb_largest_free_order]);\n\t}\n}\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t    void *buddy, void *bitmap, ext4_group_t group,\n\t\t\t    struct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t \n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t \n\t\tgrp->bb_free = free;\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\tmb_update_avg_fragment_size(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tatomic_inc(&sbi->s_mb_buddies_generated);\n\tatomic64_add(period, &sbi->s_mb_generation_time);\n}\n\n \n\nstatic int ext4_mb_init_cache(struct page *page, char *incore, gfp_t gfp)\n{\n\text4_group_t ngroups;\n\tunsigned int blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = i_blocksize(inode);\n\tblocks_per_page = PAGE_SIZE / blocksize;\n\n\tmb_debug(sb, \"init page %lu\\n\", page->index);\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t \n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, gfp);\n\t\tif (bh == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t \n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\tif (!grinfo)\n\t\t\tcontinue;\n\t\t \n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tbh[i] = ext4_read_block_bitmap_nowait(sb, group, false);\n\t\tif (IS_ERR(bh[i])) {\n\t\t\terr = PTR_ERR(bh[i]);\n\t\t\tbh[i] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(sb, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t \n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tint err2;\n\n\t\tif (!bh[i])\n\t\t\tcontinue;\n\t\terr2 = ext4_wait_block_bitmap(sb, group, bh[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (!buffer_verified(bh[group - first_group]))\n\t\t\t \n\t\t\tcontinue;\n\t\terr = 0;\n\n\t\t \n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t \n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\tif (!grinfo) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t        goto out;\n\t\t}\n\t\tif ((first_block + i) & 1) {\n\t\t\t \n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(sb, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t       (MB_NUM_ORDERS(sb)));\n\t\t\t \n\t\t\text4_lock_group(sb, group);\n\t\t\t \n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group, grinfo);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(sb, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t \n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t \n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\tWARN_ON_ONCE(!RB_EMPTY_ROOT(&grinfo->bb_free_root));\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t \n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}\n\n \nstatic int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b, gfp_t gfp)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_SIZE / sb->s_blocksize;\n\t \n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}\n\nstatic void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tput_page(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tput_page(e4b->bd_buddy_page);\n\t}\n}\n\n \nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group, gfp_t gfp)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(sb, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\tif (!this_grp)\n\t\treturn -EFSCORRUPTED;\n\n\t \n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b, gfp);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t \n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL, gfp);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t \n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t \n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap, gfp);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}\n\n \nstatic noinline_for_stack int\next4_mb_load_buddy_gfp(struct super_block *sb, ext4_group_t group,\n\t\t       struct ext4_buddy *e4b, gfp_t gfp)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(sb, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\tif (!grp)\n\t\treturn -EFSCORRUPTED;\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t \n\t\tret = ext4_mb_init_group(sb, group, gfp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t \n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t \n\t\t\tput_page(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\t\tif (page) {\n\t\t\tif (WARN_RATELIMIT(page->mapping != inode->i_mapping,\n\t\"ext4: bitmap's paging->mapping != inode->i_mapping\\n\")) {\n\t\t\t\t \n\t\t\t\tunlock_page(page);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL, gfp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, gfp);\n\t\tif (page) {\n\t\t\tif (WARN_RATELIMIT(page->mapping != inode->i_mapping,\n\t\"ext4: buddy bitmap's page->mapping != inode->i_mapping\\n\")) {\n\t\t\t\t \n\t\t\t\tunlock_page(page);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap,\n\t\t\t\t\t\t\t gfp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tput_page(page);\n\tif (e4b->bd_bitmap_page)\n\t\tput_page(e4b->bd_bitmap_page);\n\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}\n\nstatic int ext4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t      struct ext4_buddy *e4b)\n{\n\treturn ext4_mb_load_buddy_gfp(sb, group, e4b, GFP_NOFS);\n}\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tput_page(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tput_page(e4b->bd_buddy_page);\n}\n\n\nstatic int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1, max;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tbb = mb_find_buddy(e4b, order, &max);\n\t\tif (!mb_test_bit(block >> order, bb)) {\n\t\t\t \n\t\t\treturn order;\n\t\t}\n\t\torder++;\n\t}\n\treturn 0;\n}\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t \n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}\n\n \nstatic int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t \n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}\n\nvoid mb_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t \n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}\n\nstatic inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}\n\nstatic void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t \n\n\t\t \n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tbuddy2 = mb_find_buddy(e4b, order, &max);\n\t\tif (!buddy2) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t \n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\tthis_cpu_inc(discard_pa_seq);\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t \n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(sbi, block);\n\t\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY)) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing already freed block (bit %u); block bitmap corrupt.\",\n\t\t\t\t\t      block);\n\t\t\text4_mark_group_bitmap_corrupted(\n\t\t\t\tsb, e4b->bd_group,\n\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t \n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_update_avg_fragment_size(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t \n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t \n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tif (ex->fe_start + ex->fe_len > EXT4_CLUSTERS_PER_GROUP(e4b->bd_sb)) {\n\t\t \n\t\tWARN_ON(1);\n\t\text4_grp_locked_error(e4b->bd_sb, e4b->bd_group, 0, 0,\n\t\t\t\"corruption or bug in mb_find_extent \"\n\t\t\t\"block=%d, order=%d needed=%d ex=%u/%d/%d@%u\",\n\t\t\tblock, order, needed, ex->fe_group, ex->fe_start,\n\t\t\tex->fe_len, ex->fe_logical);\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t}\n\treturn ex->fe_len;\n}\n\nstatic int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\tbool split = false;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\tthis_cpu_inc(discard_pa_seq);\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t \n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t \n\twhile (len) {\n\t\tif (!split)\n\t\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t \n\t\t\tmlen = 1 << ord;\n\t\t\tif (!split)\n\t\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\telse\n\t\t\t\tsplit = false;\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t \n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\tsplit = true;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\tmb_update_avg_fragment_size(e4b->bd_sb, e4b->bd_info);\n\tmb_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}\n\n \nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t \n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t \n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t \n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\t \n\tif (ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\text4_mb_new_preallocation(ac);\n\n}\n\nstatic void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t \n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t \n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif (finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\text4_mb_use_best_found(ac, e4b);\n}\n\n \nstatic void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\tac->ac_cX_found[ac->ac_criteria]++;\n\n\t \n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t \n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t \n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t \n\tif (bex->fe_len < gex->fe_len) {\n\t\t \n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t \n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}\n\nstatic noinline_for_stack\nvoid ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n}\n\nstatic noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!grp)\n\t\treturn -EFSCORRUPTED;\n\tif (!(ac->ac_flags & (EXT4_MB_HINT_TRY_GOAL | EXT4_MB_HINT_GOAL_ONLY)))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11;  \n\n\tif (max >= ac->ac_g_ex.fe_len &&\n\t    ac->ac_g_ex.fe_len == EXT4_B2C(sbi, sbi->s_stripe)) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_grp_offs_to_block(ac->ac_sb, &ex);\n\t\t \n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t \n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}\n\n \nstatic noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i < MB_NUM_ORDERS(sb); i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tif (WARN_RATELIMIT(buddy == NULL,\n\t\t\t \"ext4: mb_simple_scan_group: mb_find_buddy failed, (%d)\\n\", i))\n\t\t\tcontinue;\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tif (k >= max) {\n\t\t\text4_grp_locked_error(ac->ac_sb, e4b->bd_group, 0, 0,\n\t\t\t\t\"%d free clusters of order %d. But found 0\",\n\t\t\t\tgrp->bb_counters[i], i);\n\t\t\text4_mark_group_bitmap_corrupted(ac->ac_sb,\n\t\t\t\t\t e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\tbreak;\n\t\t}\n\t\tac->ac_found++;\n\t\tac->ac_cX_found[ac->ac_criteria]++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_f_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}\n\n \nstatic noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i, j, freelen;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tif (WARN_ON(free <= 0))\n\t\treturn;\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t \n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ext4_mb_cr_expensive(ac->ac_criteria)) {\n\t\t\t \n\t\t\tj = mb_find_next_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\t\tfreelen = j - i;\n\n\t\t\tif (freelen < ac->ac_g_ex.fe_len) {\n\t\t\t\ti = j;\n\t\t\t\tfree -= freelen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tif (WARN_ON(ex.fe_len <= 0))\n\t\t\tbreak;\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\text4_mark_group_bitmap_corrupted(sb, e4b->bd_group,\n\t\t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE;  \n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}\n\n \nstatic noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i, stripe;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t \n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\tstripe = EXT4_B2C(sbi, sbi->s_stripe);\n\ti = EXT4_B2C(sbi, i);\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, stripe, &ex);\n\t\t\tif (max >= stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tac->ac_cX_found[ac->ac_criteria]++;\n\t\t\t\tex.fe_logical = 0xDEADF00D;  \n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += stripe;\n\t}\n}\n\n \nstatic bool ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, enum criteria cr)\n{\n\text4_grpblk_t free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < CR_POWER2_ALIGNED || cr >= EXT4_MB_NUM_CRS);\n\n\tif (unlikely(!grp || EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn false;\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn false;\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn false;\n\n\tswitch (cr) {\n\tcase CR_POWER2_ALIGNED:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t \n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn false;\n\n\t\tif (free < ac->ac_g_ex.fe_len)\n\t\t\treturn false;\n\n\t\tif (ac->ac_2order >= MB_NUM_ORDERS(ac->ac_sb))\n\t\t\treturn true;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase CR_GOAL_LEN_FAST:\n\tcase CR_BEST_AVAIL_LEN:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase CR_GOAL_LEN_SLOW:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase CR_ANY_FREE:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn false;\n}\n\n \nstatic int ext4_mb_good_group_nolock(struct ext4_allocation_context *ac,\n\t\t\t\t     ext4_group_t group, enum criteria cr)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tbool should_lock = ac->ac_flags & EXT4_MB_STRICT_CHECK;\n\text4_grpblk_t free;\n\tint ret = 0;\n\n\tif (!grp)\n\t\treturn -EFSCORRUPTED;\n\tif (sbi->s_mb_stats)\n\t\tatomic64_inc(&sbi->s_bal_cX_groups_considered[ac->ac_criteria]);\n\tif (should_lock) {\n\t\text4_lock_group(sb, group);\n\t\t__release(ext4_group_lock_ptr(sb, group));\n\t}\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\tgoto out;\n\t \n\tif (cr < CR_ANY_FREE && free < ac->ac_g_ex.fe_len)\n\t\tgoto out;\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\tgoto out;\n\tif (should_lock) {\n\t\t__acquire(ext4_group_lock_ptr(sb, group));\n\t\text4_unlock_group(sb, group);\n\t}\n\n\t \n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tstruct ext4_group_desc *gdp =\n\t\t\text4_get_group_desc(sb, group, NULL);\n\t\tint ret;\n\n\t\t \n\t\tif (!ext4_mb_cr_expensive(cr) &&\n\t\t    (!sbi->s_log_groups_per_flex ||\n\t\t     ((group & ((1 << sbi->s_log_groups_per_flex) - 1)) != 0)) &&\n\t\t    !(ext4_has_group_desc_csum(sb) &&\n\t\t      (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))))\n\t\t\treturn 0;\n\t\tret = ext4_mb_init_group(sb, group, GFP_NOFS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (should_lock) {\n\t\text4_lock_group(sb, group);\n\t\t__release(ext4_group_lock_ptr(sb, group));\n\t}\n\tret = ext4_mb_good_group(ac, group, cr);\nout:\n\tif (should_lock) {\n\t\t__acquire(ext4_group_lock_ptr(sb, group));\n\t\text4_unlock_group(sb, group);\n\t}\n\treturn ret;\n}\n\n \next4_group_t ext4_mb_prefetch(struct super_block *sb, ext4_group_t group,\n\t\t\t      unsigned int nr, int *cnt)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\twhile (nr-- > 0) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, group,\n\t\t\t\t\t\t\t\t  NULL);\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\t \n\t\tif (gdp && grp && !EXT4_MB_GRP_TEST_AND_SET_READ(grp) &&\n\t\t    EXT4_MB_GRP_NEED_INIT(grp) &&\n\t\t    ext4_free_group_clusters(sb, gdp) > 0 ) {\n\t\t\tbh = ext4_read_block_bitmap_nowait(sb, group, true);\n\t\t\tif (bh && !IS_ERR(bh)) {\n\t\t\t\tif (!buffer_uptodate(bh) && cnt)\n\t\t\t\t\t(*cnt)++;\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t}\n\t\tif (++group >= ngroups)\n\t\t\tgroup = 0;\n\t}\n\tblk_finish_plug(&plug);\n\treturn group;\n}\n\n \nvoid ext4_mb_prefetch_fini(struct super_block *sb, ext4_group_t group,\n\t\t\t   unsigned int nr)\n{\n\tstruct ext4_group_desc *gdp;\n\tstruct ext4_group_info *grp;\n\n\twhile (nr-- > 0) {\n\t\tif (!group)\n\t\t\tgroup = ext4_get_groups_count(sb);\n\t\tgroup--;\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tgrp = ext4_get_group_info(sb, group);\n\n\t\tif (grp && gdp && EXT4_MB_GRP_NEED_INIT(grp) &&\n\t\t    ext4_free_group_clusters(sb, gdp) > 0) {\n\t\t\tif (ext4_mb_init_group(sb, group, GFP_NOFS))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t prefetch_grp = 0, ngroups, group, i;\n\tenum criteria new_cr, cr = CR_GOAL_LEN_FAST;\n\tint err = 0, first_err = 0;\n\tunsigned int nr = 0, prefetch_ios = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\tint lost;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t \n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t \n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t \n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t \n\tif (i >= sbi->s_mb_order2_reqs && i <= MB_NUM_ORDERS(sb)) {\n\t\tif (is_power_of_2(ac->ac_g_ex.fe_len))\n\t\t\tac->ac_2order = array_index_nospec(i - 1,\n\t\t\t\t\t\t\t   MB_NUM_ORDERS(sb));\n\t}\n\n\t \n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t \n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t \n\tif (ac->ac_2order)\n\t\tcr = CR_POWER2_ALIGNED;\nrepeat:\n\tfor (; cr < EXT4_MB_NUM_CRS && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t \n\t\tgroup = ac->ac_g_ex.fe_group;\n\t\tac->ac_groups_linear_remaining = sbi->s_mb_max_linear_groups;\n\t\tprefetch_grp = group;\n\n\t\tfor (i = 0, new_cr = cr; i < ngroups; i++,\n\t\t     ext4_mb_choose_next_group(ac, &new_cr, &group, ngroups)) {\n\t\t\tint ret = 0;\n\n\t\t\tcond_resched();\n\t\t\tif (new_cr != cr) {\n\t\t\t\tcr = new_cr;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((prefetch_grp == group) &&\n\t\t\t    (ext4_mb_cr_expensive(cr) ||\n\t\t\t     prefetch_ios < sbi->s_mb_prefetch_limit)) {\n\t\t\t\tnr = sbi->s_mb_prefetch;\n\t\t\t\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t\t\t\tnr = 1 << sbi->s_log_groups_per_flex;\n\t\t\t\t\tnr -= group & (nr - 1);\n\t\t\t\t\tnr = min(nr, sbi->s_mb_prefetch);\n\t\t\t\t}\n\t\t\t\tprefetch_grp = ext4_mb_prefetch(sb, group,\n\t\t\t\t\t\t\tnr, &prefetch_ios);\n\t\t\t}\n\n\t\t\t \n\t\t\tret = ext4_mb_good_group_nolock(ac, group, cr);\n\t\t\tif (ret <= 0) {\n\t\t\t\tif (!first_err)\n\t\t\t\t\tfirst_err = ret;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t \n\t\t\tret = ext4_mb_good_group(ac, group, cr);\n\t\t\tif (ret == 0) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == CR_POWER2_ALIGNED)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if ((cr == CR_GOAL_LEN_FAST ||\n\t\t\t\t cr == CR_BEST_AVAIL_LEN) &&\n\t\t\t\t sbi->s_stripe &&\n\t\t\t\t !(ac->ac_g_ex.fe_len %\n\t\t\t\t EXT4_B2C(sbi, sbi->s_stripe)))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sbi->s_mb_stats && i == ngroups)\n\t\t\tatomic64_inc(&sbi->s_bal_cX_failed[cr]);\n\n\t\tif (i == ngroups && ac->ac_criteria == CR_BEST_AVAIL_LEN)\n\t\t\t \n\t\t\tac->ac_g_ex.fe_len = ac->ac_orig_goal_len;\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t \n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t \n\t\t\tlost = atomic_inc_return(&sbi->s_mb_lost_chunks);\n\t\t\tmb_debug(sb, \"lost chunk, group: %u, start: %d, len: %d, lost: %d\\n\",\n\t\t\t\t ac->ac_b_ex.fe_group, ac->ac_b_ex.fe_start,\n\t\t\t\t ac->ac_b_ex.fe_len, lost);\n\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = CR_ANY_FREE;\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\tif (sbi->s_mb_stats && ac->ac_status == AC_STATUS_FOUND)\n\t\tatomic64_inc(&sbi->s_bal_cX_hits[ac->ac_criteria]);\nout:\n\tif (!err && ac->ac_status != AC_STATUS_FOUND && first_err)\n\t\terr = first_err;\n\n\tmb_debug(sb, \"Best len %d, origin len %d, ac_status %u, ac_flags 0x%x, cr %d ret %d\\n\",\n\t\t ac->ac_b_ex.fe_len, ac->ac_o_ex.fe_len, ac->ac_status,\n\t\t ac->ac_flags, cr, err);\n\n\tif (nr)\n\t\text4_mb_prefetch_fini(sb, prefetch_grp, nr);\n\n\treturn err;\n}\n\nstatic void *ext4_mb_seq_groups_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\text4_group_t group;\n\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}\n\nstatic void *ext4_mb_seq_groups_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\text4_group_t group;\n\n\t++*pos;\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}\n\nstatic int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\text4_group_t group = (ext4_group_t) ((unsigned long) v);\n\tint i;\n\tint err, buddy_loaded = 0;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *grinfo;\n\tunsigned char blocksize_bits = min_t(unsigned char,\n\t\t\t\t\t     sb->s_blocksize_bits,\n\t\t\t\t\t     EXT4_MAX_BLOCK_LOG_SIZE);\n\tstruct sg {\n\t\tstruct ext4_group_info info;\n\t\text4_grpblk_t counters[EXT4_MAX_BLOCK_LOG_SIZE + 2];\n\t} sg;\n\n\tgroup--;\n\tif (group == 0)\n\t\tseq_puts(seq, \"#group: free  frags first [\"\n\t\t\t      \" 2^0   2^1   2^2   2^3   2^4   2^5   2^6  \"\n\t\t\t      \" 2^7   2^8   2^9   2^10  2^11  2^12  2^13  ]\\n\");\n\n\ti = (blocksize_bits + 2) * sizeof(sg.info.bb_counters[0]) +\n\t\tsizeof(struct ext4_group_info);\n\n\tgrinfo = ext4_get_group_info(sb, group);\n\tif (!grinfo)\n\t\treturn 0;\n\t \n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grinfo))) {\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\tseq_printf(seq, \"#%-5u: I/O error\\n\", group);\n\t\t\treturn 0;\n\t\t}\n\t\tbuddy_loaded = 1;\n\t}\n\n\tmemcpy(&sg, grinfo, i);\n\n\tif (buddy_loaded)\n\t\text4_mb_unload_buddy(&e4b);\n\n\tseq_printf(seq, \"#%-5u: %-5u %-5u %-5u [\", group, sg.info.bb_free,\n\t\t\tsg.info.bb_fragments, sg.info.bb_first_free);\n\tfor (i = 0; i <= 13; i++)\n\t\tseq_printf(seq, \" %-5u\", i <= blocksize_bits + 1 ?\n\t\t\t\tsg.info.bb_counters[i] : 0);\n\tseq_puts(seq, \" ]\\n\");\n\n\treturn 0;\n}\n\nstatic void ext4_mb_seq_groups_stop(struct seq_file *seq, void *v)\n{\n}\n\nconst struct seq_operations ext4_mb_seq_groups_ops = {\n\t.start  = ext4_mb_seq_groups_start,\n\t.next   = ext4_mb_seq_groups_next,\n\t.stop   = ext4_mb_seq_groups_stop,\n\t.show   = ext4_mb_seq_groups_show,\n};\n\nint ext4_seq_mb_stats_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tseq_puts(seq, \"mballoc:\\n\");\n\tif (!sbi->s_mb_stats) {\n\t\tseq_puts(seq, \"\\tmb stats collection turned off.\\n\");\n\t\tseq_puts(\n\t\t\tseq,\n\t\t\t\"\\tTo enable, please write \\\"1\\\" to sysfs file mb_stats.\\n\");\n\t\treturn 0;\n\t}\n\tseq_printf(seq, \"\\treqs: %u\\n\", atomic_read(&sbi->s_bal_reqs));\n\tseq_printf(seq, \"\\tsuccess: %u\\n\", atomic_read(&sbi->s_bal_success));\n\n\tseq_printf(seq, \"\\tgroups_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_groups_scanned));\n\n\t \n\tseq_puts(seq, \"\\tcr_p2_aligned_stats:\\n\");\n\tseq_printf(seq, \"\\t\\thits: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_hits[CR_POWER2_ALIGNED]));\n\tseq_printf(\n\t\tseq, \"\\t\\tgroups_considered: %llu\\n\",\n\t\tatomic64_read(\n\t\t\t&sbi->s_bal_cX_groups_considered[CR_POWER2_ALIGNED]));\n\tseq_printf(seq, \"\\t\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_cX_ex_scanned[CR_POWER2_ALIGNED]));\n\tseq_printf(seq, \"\\t\\tuseless_loops: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_failed[CR_POWER2_ALIGNED]));\n\tseq_printf(seq, \"\\t\\tbad_suggestions: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_p2_aligned_bad_suggestions));\n\n\t \n\tseq_puts(seq, \"\\tcr_goal_fast_stats:\\n\");\n\tseq_printf(seq, \"\\t\\thits: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_hits[CR_GOAL_LEN_FAST]));\n\tseq_printf(seq, \"\\t\\tgroups_considered: %llu\\n\",\n\t\t   atomic64_read(\n\t\t\t   &sbi->s_bal_cX_groups_considered[CR_GOAL_LEN_FAST]));\n\tseq_printf(seq, \"\\t\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_cX_ex_scanned[CR_GOAL_LEN_FAST]));\n\tseq_printf(seq, \"\\t\\tuseless_loops: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_failed[CR_GOAL_LEN_FAST]));\n\tseq_printf(seq, \"\\t\\tbad_suggestions: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_goal_fast_bad_suggestions));\n\n\t \n\tseq_puts(seq, \"\\tcr_best_avail_stats:\\n\");\n\tseq_printf(seq, \"\\t\\thits: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_hits[CR_BEST_AVAIL_LEN]));\n\tseq_printf(\n\t\tseq, \"\\t\\tgroups_considered: %llu\\n\",\n\t\tatomic64_read(\n\t\t\t&sbi->s_bal_cX_groups_considered[CR_BEST_AVAIL_LEN]));\n\tseq_printf(seq, \"\\t\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_cX_ex_scanned[CR_BEST_AVAIL_LEN]));\n\tseq_printf(seq, \"\\t\\tuseless_loops: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_failed[CR_BEST_AVAIL_LEN]));\n\tseq_printf(seq, \"\\t\\tbad_suggestions: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_best_avail_bad_suggestions));\n\n\t \n\tseq_puts(seq, \"\\tcr_goal_slow_stats:\\n\");\n\tseq_printf(seq, \"\\t\\thits: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_hits[CR_GOAL_LEN_SLOW]));\n\tseq_printf(seq, \"\\t\\tgroups_considered: %llu\\n\",\n\t\t   atomic64_read(\n\t\t\t   &sbi->s_bal_cX_groups_considered[CR_GOAL_LEN_SLOW]));\n\tseq_printf(seq, \"\\t\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_cX_ex_scanned[CR_GOAL_LEN_SLOW]));\n\tseq_printf(seq, \"\\t\\tuseless_loops: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_failed[CR_GOAL_LEN_SLOW]));\n\n\t \n\tseq_puts(seq, \"\\tcr_any_free_stats:\\n\");\n\tseq_printf(seq, \"\\t\\thits: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_hits[CR_ANY_FREE]));\n\tseq_printf(\n\t\tseq, \"\\t\\tgroups_considered: %llu\\n\",\n\t\tatomic64_read(&sbi->s_bal_cX_groups_considered[CR_ANY_FREE]));\n\tseq_printf(seq, \"\\t\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_cX_ex_scanned[CR_ANY_FREE]));\n\tseq_printf(seq, \"\\t\\tuseless_loops: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_bal_cX_failed[CR_ANY_FREE]));\n\n\t \n\tseq_printf(seq, \"\\textents_scanned: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_ex_scanned));\n\tseq_printf(seq, \"\\t\\tgoal_hits: %u\\n\", atomic_read(&sbi->s_bal_goals));\n\tseq_printf(seq, \"\\t\\tlen_goal_hits: %u\\n\",\n\t\t   atomic_read(&sbi->s_bal_len_goals));\n\tseq_printf(seq, \"\\t\\t2^n_hits: %u\\n\", atomic_read(&sbi->s_bal_2orders));\n\tseq_printf(seq, \"\\t\\tbreaks: %u\\n\", atomic_read(&sbi->s_bal_breaks));\n\tseq_printf(seq, \"\\t\\tlost: %u\\n\", atomic_read(&sbi->s_mb_lost_chunks));\n\tseq_printf(seq, \"\\tbuddies_generated: %u/%u\\n\",\n\t\t   atomic_read(&sbi->s_mb_buddies_generated),\n\t\t   ext4_get_groups_count(sb));\n\tseq_printf(seq, \"\\tbuddies_time_used: %llu\\n\",\n\t\t   atomic64_read(&sbi->s_mb_generation_time));\n\tseq_printf(seq, \"\\tpreallocated: %u\\n\",\n\t\t   atomic_read(&sbi->s_mb_preallocated));\n\tseq_printf(seq, \"\\tdiscarded: %u\\n\", atomic_read(&sbi->s_mb_discarded));\n\treturn 0;\n}\n\nstatic void *ext4_mb_seq_structs_summary_start(struct seq_file *seq, loff_t *pos)\n__acquires(&EXT4_SB(sb)->s_mb_rb_lock)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\tunsigned long position;\n\n\tif (*pos < 0 || *pos >= 2*MB_NUM_ORDERS(sb))\n\t\treturn NULL;\n\tposition = *pos + 1;\n\treturn (void *) ((unsigned long) position);\n}\n\nstatic void *ext4_mb_seq_structs_summary_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\tunsigned long position;\n\n\t++*pos;\n\tif (*pos < 0 || *pos >= 2*MB_NUM_ORDERS(sb))\n\t\treturn NULL;\n\tposition = *pos + 1;\n\treturn (void *) ((unsigned long) position);\n}\n\nstatic int ext4_mb_seq_structs_summary_show(struct seq_file *seq, void *v)\n{\n\tstruct super_block *sb = pde_data(file_inode(seq->file));\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long position = ((unsigned long) v);\n\tstruct ext4_group_info *grp;\n\tunsigned int count;\n\n\tposition--;\n\tif (position >= MB_NUM_ORDERS(sb)) {\n\t\tposition -= MB_NUM_ORDERS(sb);\n\t\tif (position == 0)\n\t\t\tseq_puts(seq, \"avg_fragment_size_lists:\\n\");\n\n\t\tcount = 0;\n\t\tread_lock(&sbi->s_mb_avg_fragment_size_locks[position]);\n\t\tlist_for_each_entry(grp, &sbi->s_mb_avg_fragment_size[position],\n\t\t\t\t    bb_avg_fragment_size_node)\n\t\t\tcount++;\n\t\tread_unlock(&sbi->s_mb_avg_fragment_size_locks[position]);\n\t\tseq_printf(seq, \"\\tlist_order_%u_groups: %u\\n\",\n\t\t\t\t\t(unsigned int)position, count);\n\t\treturn 0;\n\t}\n\n\tif (position == 0) {\n\t\tseq_printf(seq, \"optimize_scan: %d\\n\",\n\t\t\t   test_opt2(sb, MB_OPTIMIZE_SCAN) ? 1 : 0);\n\t\tseq_puts(seq, \"max_free_order_lists:\\n\");\n\t}\n\tcount = 0;\n\tread_lock(&sbi->s_mb_largest_free_orders_locks[position]);\n\tlist_for_each_entry(grp, &sbi->s_mb_largest_free_orders[position],\n\t\t\t    bb_largest_free_order_node)\n\t\tcount++;\n\tread_unlock(&sbi->s_mb_largest_free_orders_locks[position]);\n\tseq_printf(seq, \"\\tlist_order_%u_groups: %u\\n\",\n\t\t   (unsigned int)position, count);\n\n\treturn 0;\n}\n\nstatic void ext4_mb_seq_structs_summary_stop(struct seq_file *seq, void *v)\n{\n}\n\nconst struct seq_operations ext4_mb_seq_structs_summary_ops = {\n\t.start  = ext4_mb_seq_structs_summary_start,\n\t.next   = ext4_mb_seq_structs_summary_next,\n\t.stop   = ext4_mb_seq_structs_summary_stop,\n\t.show   = ext4_mb_seq_structs_summary_show,\n};\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}\n\n \nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***old_groupinfo, ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\trcu_read_lock();\n\told_groupinfo = rcu_dereference(sbi->s_group_info);\n\tif (old_groupinfo)\n\t\tmemcpy(new_groupinfo, old_groupinfo,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\trcu_read_unlock();\n\trcu_assign_pointer(sbi->s_group_info, new_groupinfo);\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\tif (old_groupinfo)\n\t\text4_kvfree_array_rcu(old_groupinfo);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\",\n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}\n\n \nint ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tint idx = group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t \n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_read_lock();\n\t\trcu_dereference(sbi->s_group_info)[idx] = meta_group_info;\n\t\trcu_read_unlock();\n\t}\n\n\tmeta_group_info = sbi_array_rcu_deref(sbi, s_group_info, idx);\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t \n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_largest_free_order_node);\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_avg_fragment_size_node);\n\tmeta_group_info[i]->bb_largest_free_order = -1;   \n\tmeta_group_info[i]->bb_avg_fragment_size_order = -1;   \n\tmeta_group_info[i]->bb_group = group;\n\n\tmb_group_bb_bitmap_alloc(sb, meta_group_info[i], group);\n\treturn 0;\n\nexit_group_info:\n\t \n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tstruct ext4_group_info ***group_info;\n\n\t\trcu_read_lock();\n\t\tgroup_info = rcu_dereference(sbi->s_group_info);\n\t\tkfree(group_info[idx]);\n\t\tgroup_info[idx] = NULL;\n\t\trcu_read_unlock();\n\t}\n\treturn -ENOMEM;\n}  \n\nstatic int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_group_info ***group_info;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t \n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tcond_resched();\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t \n\t\tif (sbi->s_es->s_log_groups_per_flex >= 32) {\n\t\t\text4_msg(sb, KERN_ERR, \"too many log groups per flexible block group\");\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tsbi->s_mb_prefetch = min_t(uint, 1 << sbi->s_es->s_log_groups_per_flex,\n\t\t\tBLK_MAX_SEGMENT_SIZE >> (sb->s_blocksize_bits - 9));\n\t\tsbi->s_mb_prefetch *= 8;  \n\t} else {\n\t\tsbi->s_mb_prefetch = 32;\n\t}\n\tif (sbi->s_mb_prefetch > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch = ext4_get_groups_count(sb);\n\t \n\tsbi->s_mb_prefetch_limit = sbi->s_mb_prefetch * 4;\n\tif (sbi->s_mb_prefetch_limit > ext4_get_groups_count(sb))\n\t\tsbi->s_mb_prefetch_limit = ext4_get_groups_count(sb);\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0) {\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, i);\n\n\t\tif (grp)\n\t\t\tkmem_cache_free(cachep, grp);\n\t}\n\ti = sbi->s_group_info_size;\n\trcu_read_lock();\n\tgroup_info = rcu_dereference(sbi->s_group_info);\n\twhile (i-- > 0)\n\t\tkfree(group_info[i]);\n\trcu_read_unlock();\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\trcu_read_lock();\n\tkvfree(rcu_dereference(sbi->s_group_info));\n\trcu_read_unlock();\n\treturn -ENOMEM;\n}\n\nstatic void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}\n\nstatic int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t \n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void ext4_discard_work(struct work_struct *work)\n{\n\tstruct ext4_sb_info *sbi = container_of(work,\n\t\t\tstruct ext4_sb_info, s_discard_work);\n\tstruct super_block *sb = sbi->s_sb;\n\tstruct ext4_free_data *fd, *nfd;\n\tstruct ext4_buddy e4b;\n\tLIST_HEAD(discard_list);\n\text4_group_t grp, load_grp;\n\tint err = 0;\n\n\tspin_lock(&sbi->s_md_lock);\n\tlist_splice_init(&sbi->s_discard_list, &discard_list);\n\tspin_unlock(&sbi->s_md_lock);\n\n\tload_grp = UINT_MAX;\n\tlist_for_each_entry_safe(fd, nfd, &discard_list, efd_list) {\n\t\t \n\t\tif ((sb->s_flags & SB_ACTIVE) && !err &&\n\t\t    !atomic_read(&sbi->s_retry_alloc_pending)) {\n\t\t\tgrp = fd->efd_group;\n\t\t\tif (grp != load_grp) {\n\t\t\t\tif (load_grp != UINT_MAX)\n\t\t\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\t\terr = ext4_mb_load_buddy(sb, grp, &e4b);\n\t\t\t\tif (err) {\n\t\t\t\t\tkmem_cache_free(ext4_free_data_cachep, fd);\n\t\t\t\t\tload_grp = UINT_MAX;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tload_grp = grp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text4_lock_group(sb, grp);\n\t\t\text4_try_to_trim_range(sb, &e4b, fd->efd_start_cluster,\n\t\t\t\t\t\tfd->efd_start_cluster + fd->efd_count - 1, 1);\n\t\t\text4_unlock_group(sb, grp);\n\t\t}\n\t\tkmem_cache_free(ext4_free_data_cachep, fd);\n\t}\n\n\tif (load_grp != UINT_MAX)\n\t\text4_mb_unload_buddy(&e4b);\n}\n\nint ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset, offset_incr;\n\tunsigned max;\n\tint ret;\n\n\ti = MB_NUM_ORDERS(sb) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = MB_NUM_ORDERS(sb) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\toffset_incr = 1 << (sb->s_blocksize_bits - 1);\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += offset_incr;\n\t\toffset_incr = offset_incr >> 1;\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i < MB_NUM_ORDERS(sb));\n\n\tsbi->s_mb_avg_fragment_size =\n\t\tkmalloc_array(MB_NUM_ORDERS(sb), sizeof(struct list_head),\n\t\t\tGFP_KERNEL);\n\tif (!sbi->s_mb_avg_fragment_size) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsbi->s_mb_avg_fragment_size_locks =\n\t\tkmalloc_array(MB_NUM_ORDERS(sb), sizeof(rwlock_t),\n\t\t\tGFP_KERNEL);\n\tif (!sbi->s_mb_avg_fragment_size_locks) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < MB_NUM_ORDERS(sb); i++) {\n\t\tINIT_LIST_HEAD(&sbi->s_mb_avg_fragment_size[i]);\n\t\trwlock_init(&sbi->s_mb_avg_fragment_size_locks[i]);\n\t}\n\tsbi->s_mb_largest_free_orders =\n\t\tkmalloc_array(MB_NUM_ORDERS(sb), sizeof(struct list_head),\n\t\t\tGFP_KERNEL);\n\tif (!sbi->s_mb_largest_free_orders) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsbi->s_mb_largest_free_orders_locks =\n\t\tkmalloc_array(MB_NUM_ORDERS(sb), sizeof(rwlock_t),\n\t\t\tGFP_KERNEL);\n\tif (!sbi->s_mb_largest_free_orders_locks) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < MB_NUM_ORDERS(sb); i++) {\n\t\tINIT_LIST_HEAD(&sbi->s_mb_largest_free_orders[i]);\n\t\trwlock_init(&sbi->s_mb_largest_free_orders_locks[i]);\n\t}\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tsbi->s_mb_free_pending = 0;\n\tINIT_LIST_HEAD(&sbi->s_freed_data_list);\n\tINIT_LIST_HEAD(&sbi->s_discard_list);\n\tINIT_WORK(&sbi->s_discard_work, ext4_discard_work);\n\tatomic_set(&sbi->s_retry_alloc_pending, 0);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\tsbi->s_mb_best_avail_max_trim_order = MB_DEFAULT_BEST_AVAIL_TRIM_ORDER;\n\n\t \n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t \n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, EXT4_B2C(sbi, sbi->s_stripe));\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\tif (bdev_nonrot(sb->s_bdev))\n\t\tsbi->s_mb_max_linear_groups = 0;\n\telse\n\t\tsbi->s_mb_max_linear_groups = MB_DEFAULT_LINEAR_LIMIT;\n\t \n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_avg_fragment_size);\n\tkfree(sbi->s_mb_avg_fragment_size_locks);\n\tkfree(sbi->s_mb_largest_free_orders);\n\tkfree(sbi->s_mb_largest_free_orders_locks);\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}\n\n \nstatic int ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\treturn count;\n}\n\nint ext4_mb_release(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tint num_meta_group_infos;\n\tstruct ext4_group_info *grinfo, ***group_info;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\tint count;\n\n\tif (test_opt(sb, DISCARD)) {\n\t\t \n\t\tflush_work(&sbi->s_discard_work);\n\t\tWARN_ON_ONCE(!list_empty(&sbi->s_discard_list));\n\t}\n\n\tif (sbi->s_group_info) {\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tcond_resched();\n\t\t\tgrinfo = ext4_get_group_info(sb, i);\n\t\t\tif (!grinfo)\n\t\t\t\tcontinue;\n\t\t\tmb_group_bb_bitmap_free(grinfo);\n\t\t\text4_lock_group(sb, i);\n\t\t\tcount = ext4_mb_cleanup_pa(grinfo);\n\t\t\tif (count)\n\t\t\t\tmb_debug(sb, \"mballoc: %d PAs left\\n\",\n\t\t\t\t\t count);\n\t\t\text4_unlock_group(sb, i);\n\t\t\tkmem_cache_free(cachep, grinfo);\n\t\t}\n\t\tnum_meta_group_infos = (ngroups +\n\t\t\t\tEXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\trcu_read_lock();\n\t\tgroup_info = rcu_dereference(sbi->s_group_info);\n\t\tfor (i = 0; i < num_meta_group_infos; i++)\n\t\t\tkfree(group_info[i]);\n\t\tkvfree(group_info);\n\t\trcu_read_unlock();\n\t}\n\tkfree(sbi->s_mb_avg_fragment_size);\n\tkfree(sbi->s_mb_avg_fragment_size_locks);\n\tkfree(sbi->s_mb_largest_free_orders);\n\tkfree(sbi->s_mb_largest_free_orders_locks);\n\tkfree(sbi->s_mb_offsets);\n\tkfree(sbi->s_mb_maxs);\n\tiput(sbi->s_buddy_cache);\n\tif (sbi->s_mb_stats) {\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u blocks %u reqs (%u success)\",\n\t\t\t\tatomic_read(&sbi->s_bal_allocated),\n\t\t\t\tatomic_read(&sbi->s_bal_reqs),\n\t\t\t\tatomic_read(&sbi->s_bal_success));\n\t\text4_msg(sb, KERN_INFO,\n\t\t      \"mballoc: %u extents scanned, %u groups scanned, %u goal hits, \"\n\t\t\t\t\"%u 2^N hits, %u breaks, %u lost\",\n\t\t\t\tatomic_read(&sbi->s_bal_ex_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_groups_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_goals),\n\t\t\t\tatomic_read(&sbi->s_bal_2orders),\n\t\t\t\tatomic_read(&sbi->s_bal_breaks),\n\t\t\t\tatomic_read(&sbi->s_mb_lost_chunks));\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u generated and it took %llu\",\n\t\t\t\tatomic_read(&sbi->s_mb_buddies_generated),\n\t\t\t\tatomic64_read(&sbi->s_mb_generation_time));\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u preallocated, %u discarded\",\n\t\t\t\tatomic_read(&sbi->s_mb_preallocated),\n\t\t\t\tatomic_read(&sbi->s_mb_discarded));\n\t}\n\n\tfree_percpu(sbi->s_locality_groups);\n\n\treturn 0;\n}\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count,\n\t\tstruct bio **biop)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\tif (biop) {\n\t\treturn __blkdev_issue_discard(sb->s_bdev,\n\t\t\t(sector_t)discard_block << (sb->s_blocksize_bits - 9),\n\t\t\t(sector_t)count << (sb->s_blocksize_bits - 9),\n\t\t\tGFP_NOFS, biop);\n\t} else\n\t\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}\n\nstatic void ext4_free_data_in_buddy(struct super_block *sb,\n\t\t\t\t    struct ext4_free_data *entry)\n{\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *db;\n\tint err, count = 0;\n\n\tmb_debug(sb, \"gonna free %u blocks in group %u (0x%p):\",\n\t\t entry->efd_count, entry->efd_group, entry);\n\n\terr = ext4_mb_load_buddy(sb, entry->efd_group, &e4b);\n\t \n\tBUG_ON(err != 0);\n\n\tspin_lock(&EXT4_SB(sb)->s_md_lock);\n\tEXT4_SB(sb)->s_mb_free_pending -= entry->efd_count;\n\tspin_unlock(&EXT4_SB(sb)->s_md_lock);\n\n\tdb = e4b.bd_info;\n\t \n\tcount += entry->efd_count;\n\text4_lock_group(sb, entry->efd_group);\n\t \n\trb_erase(&entry->efd_node, &(db->bb_free_root));\n\tmb_free_blocks(NULL, &e4b, entry->efd_start_cluster, entry->efd_count);\n\n\t \n\tif (!test_opt(sb, DISCARD))\n\t\tEXT4_MB_GRP_CLEAR_TRIMMED(db);\n\n\tif (!db->bb_free_root.rb_node) {\n\t\t \n\t\tput_page(e4b.bd_buddy_page);\n\t\tput_page(e4b.bd_bitmap_page);\n\t}\n\text4_unlock_group(sb, entry->efd_group);\n\text4_mb_unload_buddy(&e4b);\n\n\tmb_debug(sb, \"freed %d blocks in 1 structures\\n\", count);\n}\n\n \nvoid ext4_process_freed_data(struct super_block *sb, tid_t commit_tid)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_free_data *entry, *tmp;\n\tLIST_HEAD(freed_data_list);\n\tstruct list_head *cut_pos = NULL;\n\tbool wake;\n\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry(entry, &sbi->s_freed_data_list, efd_list) {\n\t\tif (entry->efd_tid != commit_tid)\n\t\t\tbreak;\n\t\tcut_pos = &entry->efd_list;\n\t}\n\tif (cut_pos)\n\t\tlist_cut_position(&freed_data_list, &sbi->s_freed_data_list,\n\t\t\t\t  cut_pos);\n\tspin_unlock(&sbi->s_md_lock);\n\n\tlist_for_each_entry(entry, &freed_data_list, efd_list)\n\t\text4_free_data_in_buddy(sb, entry);\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\twake = list_empty(&sbi->s_discard_list);\n\t\tlist_splice_tail(&freed_data_list, &sbi->s_discard_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tif (wake)\n\t\t\tqueue_work(system_unbound_wq, &sbi->s_discard_work);\n\t} else {\n\t\tlist_for_each_entry_safe(entry, tmp, &freed_data_list, efd_list)\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t}\n}\n\nint __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\tgoto out;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL)\n\t\tgoto out_pa_free;\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL)\n\t\tgoto out_ac_free;\n\n\treturn 0;\n\nout_ac_free:\n\tkmem_cache_destroy(ext4_ac_cachep);\nout_pa_free:\n\tkmem_cache_destroy(ext4_pspace_cachep);\nout:\n\treturn -ENOMEM;\n}\n\nvoid ext4_exit_mballoc(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}\n\n\n \nstatic noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\treturn PTR_ERR(bitmap_bh);\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, sb, bitmap_bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, gdp_bh, EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_inode_block_valid(ac->ac_inode, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t \n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\tmb_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EFSCORRUPTED;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\tmb_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t \n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t \n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}\n\n \nvoid ext4_mb_mark_bb(struct super_block *sb, ext4_fsblk_t block,\n\t\t\tint len, int state)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t group;\n\text4_grpblk_t blkoff;\n\tint i, err = 0;\n\tint already;\n\tunsigned int clen, clen_changed, thisgrp_len;\n\n\twhile (len > 0) {\n\t\text4_get_group_no_and_offset(sb, block, &group, &blkoff);\n\n\t\t \n\t\tthisgrp_len = min_t(unsigned int, (unsigned int)len,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - EXT4_C2B(sbi, blkoff));\n\t\tclen = EXT4_NUM_B2C(sbi, thisgrp_len);\n\n\t\tif (!ext4_sb_block_valid(sb, NULL, block, thisgrp_len)) {\n\t\t\text4_error(sb, \"Marking blocks in system zone - \"\n\t\t\t\t   \"Block = %llu, len = %u\",\n\t\t\t\t   block, thisgrp_len);\n\t\t\tbitmap_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\terr = PTR_ERR(bitmap_bh);\n\t\t\tbitmap_bh = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EIO;\n\t\tgdp = ext4_get_group_desc(sb, group, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tbreak;\n\n\t\text4_lock_group(sb, group);\n\t\talready = 0;\n\t\tfor (i = 0; i < clen; i++)\n\t\t\tif (!mb_test_bit(blkoff + i, bitmap_bh->b_data) ==\n\t\t\t\t\t !state)\n\t\t\t\talready++;\n\n\t\tclen_changed = clen - already;\n\t\tif (state)\n\t\t\tmb_set_bits(bitmap_bh->b_data, blkoff, clen);\n\t\telse\n\t\t\tmb_clear_bits(bitmap_bh->b_data, blkoff, clen);\n\t\tif (ext4_has_group_desc_csum(sb) &&\n\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t     ext4_free_clusters_after_init(sb, group, gdp));\n\t\t}\n\t\tif (state)\n\t\t\tclen = ext4_free_group_clusters(sb, gdp) - clen_changed;\n\t\telse\n\t\t\tclen = ext4_free_group_clusters(sb, gdp) + clen_changed;\n\n\t\text4_free_group_clusters_set(sb, gdp, clen);\n\t\text4_block_bitmap_csum_set(sb, gdp, bitmap_bh);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\n\t\text4_unlock_group(sb, group);\n\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t flex_group = ext4_flex_group(sbi, group);\n\t\t\tstruct flex_groups *fg = sbi_array_rcu_deref(sbi,\n\t\t\t\t\t\t   s_flex_groups, flex_group);\n\n\t\t\tif (state)\n\t\t\t\tatomic64_sub(clen_changed, &fg->free_clusters);\n\t\t\telse\n\t\t\t\tatomic64_add(clen_changed, &fg->free_clusters);\n\n\t\t}\n\n\t\terr = ext4_handle_dirty_metadata(NULL, NULL, bitmap_bh);\n\t\tif (err)\n\t\t\tbreak;\n\t\tsync_dirty_buffer(bitmap_bh);\n\t\terr = ext4_handle_dirty_metadata(NULL, NULL, gdp_bh);\n\t\tsync_dirty_buffer(gdp_bh);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tblock += thisgrp_len;\n\t\tlen -= thisgrp_len;\n\t\tbrelse(bitmap_bh);\n\t\tBUG_ON(len < 0);\n\t}\n\n\tif (err)\n\t\tbrelse(bitmap_bh);\n}\n\n \nstatic void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(sb, \"goal %u blocks for locality group\\n\", ac->ac_g_ex.fe_len);\n}\n\n \nstatic inline struct rb_node*\next4_mb_pa_rb_next_iter(ext4_lblk_t new_start, ext4_lblk_t cur_start, struct rb_node *node)\n{\n\tif (new_start < cur_start)\n\t\treturn node->rb_left;\n\telse\n\t\treturn node->rb_right;\n}\n\nstatic inline void\next4_mb_pa_assert_overlap(struct ext4_allocation_context *ac,\n\t\t\t  ext4_lblk_t start, loff_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *tmp_pa;\n\text4_lblk_t tmp_pa_start;\n\tloff_t tmp_pa_end;\n\tstruct rb_node *iter;\n\n\tread_lock(&ei->i_prealloc_lock);\n\tfor (iter = ei->i_prealloc_node.rb_node; iter;\n\t     iter = ext4_mb_pa_rb_next_iter(start, tmp_pa_start, iter)) {\n\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t  pa_node.inode_node);\n\t\ttmp_pa_start = tmp_pa->pa_lstart;\n\t\ttmp_pa_end = pa_logical_end(sbi, tmp_pa);\n\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted == 0)\n\t\t\tBUG_ON(!(start >= tmp_pa_end || end <= tmp_pa_start));\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t}\n\tread_unlock(&ei->i_prealloc_lock);\n}\n\n \nstatic inline void\next4_mb_pa_adjust_overlap(struct ext4_allocation_context *ac,\n\t\t\t  ext4_lblk_t *start, loff_t *end)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *tmp_pa = NULL, *left_pa = NULL, *right_pa = NULL;\n\tstruct rb_node *iter;\n\text4_lblk_t new_start, tmp_pa_start, right_pa_start = -1;\n\tloff_t new_end, tmp_pa_end, left_pa_end = -1;\n\n\tnew_start = *start;\n\tnew_end = *end;\n\n\t \n\tread_lock(&ei->i_prealloc_lock);\n\n\t \n\tfor (iter = ei->i_prealloc_node.rb_node; iter;\n\t     iter = ext4_mb_pa_rb_next_iter(ac->ac_o_ex.fe_logical,\n\t\t\t\t\t    tmp_pa_start, iter)) {\n\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t  pa_node.inode_node);\n\t\ttmp_pa_start = tmp_pa->pa_lstart;\n\t\ttmp_pa_end = pa_logical_end(sbi, tmp_pa);\n\n\t\t \n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted == 0)\n\t\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= tmp_pa_end ||\n\t\t\t\t ac->ac_o_ex.fe_logical < tmp_pa_start));\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t}\n\n\t \n\tif (tmp_pa) {\n\t\tif (tmp_pa->pa_lstart < ac->ac_o_ex.fe_logical) {\n\t\t\tstruct rb_node *tmp;\n\n\t\t\tleft_pa = tmp_pa;\n\t\t\ttmp = rb_next(&left_pa->pa_node.inode_node);\n\t\t\tif (tmp) {\n\t\t\t\tright_pa = rb_entry(tmp,\n\t\t\t\t\t\t    struct ext4_prealloc_space,\n\t\t\t\t\t\t    pa_node.inode_node);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct rb_node *tmp;\n\n\t\t\tright_pa = tmp_pa;\n\t\t\ttmp = rb_prev(&right_pa->pa_node.inode_node);\n\t\t\tif (tmp) {\n\t\t\t\tleft_pa = rb_entry(tmp,\n\t\t\t\t\t\t   struct ext4_prealloc_space,\n\t\t\t\t\t\t   pa_node.inode_node);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (left_pa) {\n\t\tfor (iter = &left_pa->pa_node.inode_node;;\n\t\t     iter = rb_prev(iter)) {\n\t\t\tif (!iter) {\n\t\t\t\tleft_pa = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t\t  pa_node.inode_node);\n\t\t\tleft_pa = tmp_pa;\n\t\t\tspin_lock(&tmp_pa->pa_lock);\n\t\t\tif (tmp_pa->pa_deleted == 0) {\n\t\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t}\n\t}\n\n\tif (right_pa) {\n\t\tfor (iter = &right_pa->pa_node.inode_node;;\n\t\t     iter = rb_next(iter)) {\n\t\t\tif (!iter) {\n\t\t\t\tright_pa = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t\t  pa_node.inode_node);\n\t\t\tright_pa = tmp_pa;\n\t\t\tspin_lock(&tmp_pa->pa_lock);\n\t\t\tif (tmp_pa->pa_deleted == 0) {\n\t\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t}\n\t}\n\n\tif (left_pa) {\n\t\tleft_pa_end = pa_logical_end(sbi, left_pa);\n\t\tBUG_ON(left_pa_end > ac->ac_o_ex.fe_logical);\n\t}\n\n\tif (right_pa) {\n\t\tright_pa_start = right_pa->pa_lstart;\n\t\tBUG_ON(right_pa_start <= ac->ac_o_ex.fe_logical);\n\t}\n\n\t \n\tif (left_pa) {\n\t\tif (left_pa_end > new_start)\n\t\t\tnew_start = left_pa_end;\n\t}\n\n\tif (right_pa) {\n\t\tif (right_pa_start < new_end)\n\t\t\tnew_end = right_pa_start;\n\t}\n\tread_unlock(&ei->i_prealloc_lock);\n\n\t \n\text4_mb_pa_assert_overlap(ac, new_start, new_end);\n\n\t*start = new_start;\n\t*end = new_end;\n}\n\n \nstatic noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint bsbits, max;\n\tloff_t size, start_off, end;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\n\t \n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t \n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t \n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t \n\tsize = extent_logical_end(sbi, &ac->ac_o_ex);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t \n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t \n\t \n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(EXT4_C2B(sbi, ac->ac_o_ex.fe_len),\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(sbi,\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t \n\tstart = max(start, rounddown(ac->ac_o_ex.fe_logical,\n\t\t\t(ext4_lblk_t)EXT4_BLOCKS_PER_GROUP(ac->ac_sb)));\n\n\t \n\tif (start + size > EXT_MAX_BLOCKS)\n\t\tsize = EXT_MAX_BLOCKS - start;\n\n\t \n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\t \n\tif (size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb))\n\t\tsize = EXT4_BLOCKS_PER_GROUP(ac->ac_sb);\n\n\tend = start + size;\n\n\text4_mb_pa_adjust_overlap(ac, &start, &end);\n\n\tsize = end - start;\n\n\t \n\tif (start + size <= ac->ac_o_ex.fe_logical ||\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t \n\n\t \n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\tac->ac_orig_goal_len = ac->ac_g_ex.fe_len;\n\n\t \n\tif (ar->pright && (ar->lright == (start + size)) &&\n\t    ar->pright >= size &&\n\t    ar->pright - size >= le32_to_cpu(es->s_first_data_block)) {\n\t\t \n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_g_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_g_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start) &&\n\t    ar->pleft + 1 < ext4_blocks_count(es)) {\n\t\t \n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_g_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_g_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(ac->ac_sb, \"goal: %lld(was %lld) blocks at %u\\n\", size,\n\t\t orig_size, start);\n}\n\nstatic void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len >= 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tfor (int i=0; i<EXT4_MB_NUM_CRS; i++) {\n\t\t\tatomic_add(ac->ac_cX_found[i], &sbi->s_bal_cX_ex_scanned[i]);\n\t\t}\n\n\t\tatomic_add(ac->ac_groups_scanned, &sbi->s_bal_groups_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\t \n\t\tif (ac->ac_f_ex.fe_len == ac->ac_orig_goal_len)\n\t\t\tatomic_inc(&sbi->s_bal_len_goals);\n\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}\n\n \nstatic void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (WARN_RATELIMIT(err,\n\t\t\t\t   \"ext4: mb_load_buddy failed (%d)\", err))\n\t\t\t \n\t\t\treturn;\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n}\n\n \nstatic void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t \n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\tpa->pa_free -= len;\n\n\tmb_debug(ac->ac_sb, \"use %llu/%d from inode pa %p\\n\", start, len, pa);\n}\n\n \nstatic void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t \n\tmb_debug(ac->ac_sb, \"use %u/%u from group pa %p\\n\",\n\t\t pa->pa_lstart, len, pa);\n}\n\n \nstatic struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t \n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}\n\n \nstatic bool\next4_mb_pa_goal_check(struct ext4_allocation_context *ac,\n\t\t      struct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\n\tif (likely(!(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY)))\n\t\treturn true;\n\n\t \n\tstart = pa->pa_pstart +\n\t\t(ac->ac_g_ex.fe_logical - pa->pa_lstart);\n\tif (ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex) != start)\n\t\treturn false;\n\n\tif (ac->ac_g_ex.fe_len > pa->pa_len -\n\t    EXT4_B2C(sbi, ac->ac_g_ex.fe_logical - pa->pa_lstart))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic noinline_for_stack bool\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *tmp_pa = NULL, *cpa = NULL;\n\tstruct rb_node *iter;\n\text4_fsblk_t goal_block;\n\n\t \n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn false;\n\n\t \n\tread_lock(&ei->i_prealloc_lock);\n\n\tif (RB_EMPTY_ROOT(&ei->i_prealloc_node)) {\n\t\tgoto try_group_pa;\n\t}\n\n\t \n\tfor (iter = ei->i_prealloc_node.rb_node; iter;\n\t     iter = ext4_mb_pa_rb_next_iter(ac->ac_o_ex.fe_logical,\n\t\t\t\t\t    tmp_pa->pa_lstart, iter)) {\n\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t  pa_node.inode_node);\n\t}\n\n\t \n\tif (tmp_pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\tstruct rb_node *tmp;\n\t\ttmp = rb_prev(&tmp_pa->pa_node.inode_node);\n\n\t\tif (tmp) {\n\t\t\ttmp_pa = rb_entry(tmp, struct ext4_prealloc_space,\n\t\t\t\t\t    pa_node.inode_node);\n\t\t} else {\n\t\t\t \n\t\t\tgoto try_group_pa;\n\t\t}\n\t}\n\n\tBUG_ON(!(tmp_pa && tmp_pa->pa_lstart <= ac->ac_o_ex.fe_logical));\n\n\t \n\tfor (iter = &tmp_pa->pa_node.inode_node;; iter = rb_prev(iter)) {\n\t\tif (!iter) {\n\t\t\t \n\t\t\tgoto try_group_pa;\n\t\t}\n\t\ttmp_pa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t\t  pa_node.inode_node);\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t}\n\t}\n\n\tBUG_ON(!(tmp_pa && tmp_pa->pa_lstart <= ac->ac_o_ex.fe_logical));\n\tBUG_ON(tmp_pa->pa_deleted == 1);\n\n\t \n\tif (ac->ac_o_ex.fe_logical >= pa_logical_end(sbi, tmp_pa)) {\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tgoto try_group_pa;\n\t}\n\n\t \n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t    (tmp_pa->pa_pstart + EXT4_C2B(sbi, tmp_pa->pa_len) >\n\t     EXT4_MAX_BLOCK_FILE_PHYS)) {\n\t\t \n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tgoto try_group_pa;\n\t}\n\n\tif (tmp_pa->pa_free && likely(ext4_mb_pa_goal_check(ac, tmp_pa))) {\n\t\tatomic_inc(&tmp_pa->pa_count);\n\t\text4_mb_use_inode_pa(ac, tmp_pa);\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tread_unlock(&ei->i_prealloc_lock);\n\t\treturn true;\n\t} else {\n\t\t \n\t\tWARN_ON_ONCE(tmp_pa->pa_free == 0);\n\t}\n\tspin_unlock(&tmp_pa->pa_lock);\ntry_group_pa:\n\tread_unlock(&ei->i_prealloc_lock);\n\n\t \n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn false;\n\n\t \n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn false;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t \n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t \n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_node.lg_list) {\n\t\t\tspin_lock(&tmp_pa->pa_lock);\n\t\t\tif (tmp_pa->pa_deleted == 0 &&\n\t\t\t\t\ttmp_pa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\ttmp_pa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\tif (!grp)\n\t\treturn;\n\n\t \n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\tmb_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(sb, \"preallocated %d for group %u\\n\", preallocated, group);\n}\n\nstatic void ext4_mb_mark_pa_deleted(struct super_block *sb,\n\t\t\t\t    struct ext4_prealloc_space *pa)\n{\n\tstruct ext4_inode_info *ei;\n\n\tif (pa->pa_deleted) {\n\t\text4_warning(sb, \"deleted pa, type:%d, pblk:%llu, lblk:%u, len:%d\\n\",\n\t\t\t     pa->pa_type, pa->pa_pstart, pa->pa_lstart,\n\t\t\t     pa->pa_len);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\n\tif (pa->pa_type == MB_INODE_PA) {\n\t\tei = EXT4_I(pa->pa_inode);\n\t\tatomic_dec(&ei->i_prealloc_active);\n\t}\n}\n\nstatic inline void ext4_mb_pa_free(struct ext4_prealloc_space *pa)\n{\n\tBUG_ON(!pa);\n\tBUG_ON(atomic_read(&pa->pa_count));\n\tBUG_ON(pa->pa_deleted == 0);\n\tkmem_cache_free(ext4_pspace_cachep, pa);\n}\n\nstatic void ext4_mb_pa_callback(struct rcu_head *head)\n{\n\tstruct ext4_prealloc_space *pa;\n\n\tpa = container_of(head, struct ext4_prealloc_space, u.pa_rcu);\n\text4_mb_pa_free(pa);\n}\n\n \nstatic void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\n\t \n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\text4_mb_mark_pa_deleted(sb, pa);\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t \n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t \n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tif (pa->pa_type == MB_INODE_PA) {\n\t\twrite_lock(pa->pa_node_lock.inode_lock);\n\t\trb_erase(&pa->pa_node.inode_node, &ei->i_prealloc_node);\n\t\twrite_unlock(pa->pa_node_lock.inode_lock);\n\t\text4_mb_pa_free(pa);\n\t} else {\n\t\tspin_lock(pa->pa_node_lock.lg_lock);\n\t\tlist_del_rcu(&pa->pa_node.lg_list);\n\t\tspin_unlock(pa->pa_node_lock.lg_lock);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}\n\nstatic void ext4_mb_pa_rb_insert(struct rb_root *root, struct rb_node *new)\n{\n\tstruct rb_node **iter = &root->rb_node, *parent = NULL;\n\tstruct ext4_prealloc_space *iter_pa, *new_pa;\n\text4_lblk_t iter_start, new_start;\n\n\twhile (*iter) {\n\t\titer_pa = rb_entry(*iter, struct ext4_prealloc_space,\n\t\t\t\t   pa_node.inode_node);\n\t\tnew_pa = rb_entry(new, struct ext4_prealloc_space,\n\t\t\t\t   pa_node.inode_node);\n\t\titer_start = iter_pa->pa_lstart;\n\t\tnew_start = new_pa->pa_lstart;\n\n\t\tparent = *iter;\n\t\tif (new_start < iter_start)\n\t\t\titer = &((*iter)->rb_left);\n\t\telse\n\t\t\titer = &((*iter)->rb_right);\n\t}\n\n\trb_link_node(new, parent, iter);\n\trb_insert_color(new, root);\n}\n\n \nstatic noinline_for_stack void\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t \n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\tBUG_ON(ac->ac_pa == NULL);\n\n\tpa = ac->ac_pa;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_orig_goal_len) {\n\t\tstruct ext4_free_extent ex = {\n\t\t\t.fe_logical = ac->ac_g_ex.fe_logical,\n\t\t\t.fe_len = ac->ac_orig_goal_len,\n\t\t};\n\t\tloff_t orig_goal_end = extent_logical_end(sbi, &ex);\n\n\t\t \n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t \n\t\tex.fe_len = ac->ac_b_ex.fe_len;\n\n\t\tex.fe_logical = orig_goal_end - EXT4_C2B(sbi, ex.fe_len);\n\t\tif (ac->ac_o_ex.fe_logical >= ex.fe_logical)\n\t\t\tgoto adjust_bex;\n\n\t\tex.fe_logical = ac->ac_g_ex.fe_logical;\n\t\tif (ac->ac_o_ex.fe_logical < extent_logical_end(sbi, &ex))\n\t\t\tgoto adjust_bex;\n\n\t\tex.fe_logical = ac->ac_o_ex.fe_logical;\nadjust_bex:\n\t\tac->ac_b_ex.fe_logical = ex.fe_logical;\n\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t\tBUG_ON(extent_logical_end(sbi, &ex) > orig_goal_end);\n\t}\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(sb, \"new inode pa %p: %llu/%d for %u\\n\", pa, pa->pa_pstart,\n\t\t pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\text4_mb_use_inode_pa(ac, pa);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tif (!grp)\n\t\treturn;\n\n\tpa->pa_node_lock.inode_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\n\twrite_lock(pa->pa_node_lock.inode_lock);\n\text4_mb_pa_rb_insert(&ei->i_prealloc_node, &pa->pa_node.inode_node);\n\twrite_unlock(pa->pa_node_lock.inode_lock);\n\tatomic_inc(&ei->i_prealloc_active);\n}\n\n \nstatic noinline_for_stack void\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t \n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\tBUG_ON(ac->ac_pa == NULL);\n\n\tpa = ac->ac_pa;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_node.lg_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(sb, \"new group pa %p: %llu/%d for %u\\n\", pa, pa->pa_pstart,\n\t\t pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tif (!grp)\n\t\treturn;\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_node_lock.lg_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\n\t \n}\n\nstatic void ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\text4_mb_new_group_pa(ac);\n\telse\n\t\text4_mb_new_inode_pa(ac);\n}\n\n \nstatic noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(sb, \"free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %d\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t \n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tif (unlikely(group != e4b->bd_group && pa->pa_len != 0)) {\n\t\text4_warning(sb, \"bad group: expected %u, group %u, pa_start %llu\",\n\t\t\t     e4b->bd_group, group, pa->pa_pstart);\n\t\treturn 0;\n\t}\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}\n\n \nstatic noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t     ext4_group_t group, int *busy)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tLIST_HEAD(list);\n\tstruct ext4_buddy e4b;\n\tstruct ext4_inode_info *ei;\n\tint err;\n\tint free = 0;\n\n\tif (!grp)\n\t\treturn 0;\n\tmb_debug(sb, \"discard preallocation for group %u\\n\", group);\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\tgoto out_dbg;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\text4_error_err(sb, -err,\n\t\t\t       \"Error %d reading block bitmap for %u\",\n\t\t\t       err, group);\n\t\tgoto out_dbg;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_warning(sb, \"Error %d loading buddy information for %u\",\n\t\t\t     err, group);\n\t\tput_bh(bitmap_bh);\n\t\tgoto out_dbg;\n\t}\n\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\t*busy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\text4_mb_mark_pa_deleted(sb, pa);\n\n\t\tif (!free)\n\t\t\tthis_cpu_inc(discard_pa_seq);\n\n\t\t \n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t \n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t \n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\tspin_lock(pa->pa_node_lock.lg_lock);\n\t\t\tlist_del_rcu(&pa->pa_node.lg_list);\n\t\t\tspin_unlock(pa->pa_node_lock.lg_lock);\n\t\t} else {\n\t\t\twrite_lock(pa->pa_node_lock.inode_lock);\n\t\t\tei = EXT4_I(pa->pa_inode);\n\t\t\trb_erase(&pa->pa_node.inode_node, &ei->i_prealloc_node);\n\t\t\twrite_unlock(pa->pa_node_lock.inode_lock);\n\t\t}\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t\t} else {\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\t\text4_mb_pa_free(pa);\n\t\t}\n\t}\n\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\nout_dbg:\n\tmb_debug(sb, \"discarded (%d) blocks preallocated for group %u bb_free (%d)\\n\",\n\t\t free, group, grp->bb_free);\n\treturn free;\n}\n\n \nvoid ext4_discard_preallocations(struct inode *inode, unsigned int needed)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tLIST_HEAD(list);\n\tstruct ext4_buddy e4b;\n\tstruct rb_node *iter;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tmb_debug(sb, \"discard preallocation for inode %lu\\n\",\n\t\t inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode,\n\t\t\tatomic_read(&ei->i_prealloc_active), needed);\n\n\tif (needed == 0)\n\t\tneeded = UINT_MAX;\n\nrepeat:\n\t \n\twrite_lock(&ei->i_prealloc_lock);\n\tfor (iter = rb_first(&ei->i_prealloc_node); iter && needed;\n\t     iter = rb_next(iter)) {\n\t\tpa = rb_entry(iter, struct ext4_prealloc_space,\n\t\t\t      pa_node.inode_node);\n\t\tBUG_ON(pa->pa_node_lock.inode_lock != &ei->i_prealloc_lock);\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t \n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\twrite_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\text4_mb_mark_pa_deleted(sb, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\trb_erase(&pa->pa_node.inode_node, &ei->i_prealloc_node);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tneeded--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tspin_unlock(&pa->pa_lock);\n\t\twrite_unlock(&ei->i_prealloc_lock);\n\n\t\t \n\n\t\t \n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\twrite_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy_gfp(sb, group, &e4b,\n\t\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\t\tif (err) {\n\t\t\text4_error_err(sb, -err, \"Error %d loading buddy information for %u\",\n\t\t\t\t       err, group);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\terr = PTR_ERR(bitmap_bh);\n\t\t\text4_error_err(sb, -err, \"Error %d reading block bitmap for %u\",\n\t\t\t\t       err, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\text4_mb_pa_free(pa);\n\t}\n}\n\nstatic int ext4_mb_pa_alloc(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa;\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_zalloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (!pa)\n\t\treturn -ENOMEM;\n\tatomic_set(&pa->pa_count, 1);\n\tac->ac_pa = pa;\n\treturn 0;\n}\n\nstatic void ext4_mb_pa_put_free(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\n\tBUG_ON(!pa);\n\tac->ac_pa = NULL;\n\tWARN_ON(!atomic_dec_and_test(&pa->pa_count));\n\t \n\tpa->pa_deleted = 1;\n\text4_mb_pa_free(pa);\n}\n\n#ifdef CONFIG_EXT4_DEBUG\nstatic inline void ext4_mb_show_pa(struct super_block *sb)\n{\n\text4_group_t i, ngroups;\n\n\tif (ext4_forced_shutdown(sb))\n\t\treturn;\n\n\tngroups = ext4_get_groups_count(sb);\n\tmb_debug(sb, \"groups: \");\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, i);\n\t\tstruct ext4_prealloc_space *pa;\n\t\text4_grpblk_t start;\n\t\tstruct list_head *cur;\n\n\t\tif (!grp)\n\t\t\tcontinue;\n\t\text4_lock_group(sb, i);\n\t\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\t\tpa = list_entry(cur, struct ext4_prealloc_space,\n\t\t\t\t\tpa_group_list);\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t\t     NULL, &start);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tmb_debug(sb, \"PA:%u:%d:%d\\n\", i, start,\n\t\t\t\t pa->pa_len);\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tmb_debug(sb, \"%u: %d/%d\\n\", i, grp->bb_free,\n\t\t\t grp->bb_fragments);\n\t}\n}\n\nstatic void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\n\tif (ext4_forced_shutdown(sb))\n\t\treturn;\n\n\tmb_debug(sb, \"Can't allocate:\"\n\t\t\t\" Allocation context details:\");\n\tmb_debug(sb, \"status %u flags 0x%x\",\n\t\t\tac->ac_status, ac->ac_flags);\n\tmb_debug(sb, \"orig %lu/%lu/%lu@%lu, \"\n\t\t\t\"goal %lu/%lu/%lu@%lu, \"\n\t\t\t\"best %lu/%lu/%lu@%lu cr %d\",\n\t\t\t(unsigned long)ac->ac_o_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_logical,\n\t\t\t(int)ac->ac_criteria);\n\tmb_debug(sb, \"%u found\", ac->ac_found);\n\tmb_debug(sb, \"used pa: %s, \", ac->ac_pa ? \"yes\" : \"no\");\n\tif (ac->ac_pa)\n\t\tmb_debug(sb, \"pa_type %s\\n\", ac->ac_pa->pa_type == MB_GROUP_PA ?\n\t\t\t \"group pa\" : \"inode pa\");\n\text4_mb_show_pa(sb);\n}\n#else\nstatic inline void ext4_mb_show_pa(struct super_block *sb)\n{\n}\nstatic inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\text4_mb_show_pa(ac->ac_sb);\n}\n#endif\n\n \nstatic void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\tbool inode_pa_eligible, group_pa_eligible;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tgroup_pa_eligible = sbi->s_mb_group_prealloc > 0;\n\tinode_pa_eligible = true;\n\tsize = extent_logical_end(sbi, &ac->ac_o_ex);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\t \n\tif ((size == isize) && !ext4_fs_is_busy(sbi) &&\n\t    !inode_is_open_for_write(ac->ac_inode))\n\t\tinode_pa_eligible = false;\n\n\tsize = max(size, isize);\n\t \n\tif (size > sbi->s_mb_stream_request)\n\t\tgroup_pa_eligible = false;\n\n\tif (!group_pa_eligible) {\n\t\tif (inode_pa_eligible)\n\t\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\telse\n\t\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t \n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t \n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t \n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}\n\nstatic noinline_for_stack void\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t \n\tlen = ar->len;\n\n\t \n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t \n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t \n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_orig_goal_len = ac->ac_g_ex.fe_len;\n\tac->ac_flags = ar->flags;\n\n\t \n\text4_mb_group_or_file(ac);\n\n\tmb_debug(sb, \"init ac: %u blocks @ %u, goal %u, flags 0x%x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tinode_is_open_for_write(ar->inode) ? \"\" : \"non-\");\n}\n\nstatic noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tLIST_HEAD(discard_list);\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(sb, \"discard locality group preallocation\\n\");\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\tpa_node.lg_list,\n\t\t\t\tlockdep_is_held(&lg->lg_prealloc_lock)) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t \n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t \n\t\text4_mb_mark_pa_deleted(sb, pa);\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_node.lg_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\t\tint err;\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\terr = ext4_mb_load_buddy_gfp(sb, group, &e4b,\n\t\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\t\tif (err) {\n\t\t\text4_error_err(sb, -err, \"Error %d loading buddy information for %u\",\n\t\t\t\t       err, group);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}\n\n \n\nstatic void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t \n\t\torder = PREALLOC_TB_SIZE - 1;\n\t \n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\tpa_node.lg_list,\n\t\t\t\tlockdep_is_held(&lg->lg_prealloc_lock)) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t \n\t\t\tlist_add_tail_rcu(&pa->pa_node.lg_list,\n\t\t\t\t\t\t&tmp_pa->pa_node.lg_list);\n\t\t\tadded = 1;\n\t\t\t \n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_node.lg_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t \n\tif (lg_prealloc_count > 8)\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n}\n\n \nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t \n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\n\t\t\t \n\t\t\tif (likely(pa->pa_free)) {\n\t\t\t\tspin_lock(pa->pa_node_lock.lg_lock);\n\t\t\t\tlist_del_rcu(&pa->pa_node.lg_list);\n\t\t\t\tspin_unlock(pa->pa_node_lock.lg_lock);\n\t\t\t\text4_mb_add_n_trim(ac);\n\t\t\t}\n\t\t}\n\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tput_page(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tput_page(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}\n\nstatic int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0, busy = 0;\n\tint retry = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n repeat:\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, &busy);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t\tcond_resched();\n\t}\n\n\tif (needed > 0 && busy && ++retry < 3) {\n\t\tbusy = 0;\n\t\tgoto repeat;\n\t}\n\n\treturn freed;\n}\n\nstatic bool ext4_mb_discard_preallocations_should_retry(struct super_block *sb,\n\t\t\tstruct ext4_allocation_context *ac, u64 *seq)\n{\n\tint freed;\n\tu64 seq_retry = 0;\n\tbool ret = false;\n\n\tfreed = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\tif (freed) {\n\t\tret = true;\n\t\tgoto out_dbg;\n\t}\n\tseq_retry = ext4_get_discard_pa_seq_sum();\n\tif (!(ac->ac_flags & EXT4_MB_STRICT_CHECK) || seq_retry != *seq) {\n\t\tac->ac_flags |= EXT4_MB_STRICT_CHECK;\n\t\t*seq = seq_retry;\n\t\tret = true;\n\t}\n\nout_dbg:\n\tmb_debug(sb, \"freed %d, retry ? %s\\n\", freed, ret ? \"yes\" : \"no\");\n\treturn ret;\n}\n\n \nstatic ext4_fsblk_t\next4_mb_new_blocks_simple(struct ext4_allocation_request *ar, int *errp)\n{\n\tstruct buffer_head *bitmap_bh;\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t group, nr;\n\text4_grpblk_t blkoff;\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_fsblk_t goal, block;\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\n\tar->len = 0;\n\text4_get_group_no_and_offset(sb, goal, &group, &blkoff);\n\tfor (nr = ext4_get_groups_count(sb); nr > 0; nr--) {\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\t*errp = PTR_ERR(bitmap_bh);\n\t\t\tpr_warn(\"Failed to read block bitmap\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (1) {\n\t\t\ti = mb_find_next_zero_bit(bitmap_bh->b_data, max,\n\t\t\t\t\t\tblkoff);\n\t\t\tif (i >= max)\n\t\t\t\tbreak;\n\t\t\tif (ext4_fc_replay_check_excluded(sb,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, i))) {\n\t\t\t\tblkoff = i + 1;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(bitmap_bh);\n\t\tif (i < max)\n\t\t\tbreak;\n\n\t\tif (++group >= ext4_get_groups_count(sb))\n\t\t\tgroup = 0;\n\n\t\tblkoff = 0;\n\t}\n\n\tif (i >= max) {\n\t\t*errp = -ENOSPC;\n\t\treturn 0;\n\t}\n\n\tblock = ext4_group_first_block_no(sb, group) + EXT4_C2B(sbi, i);\n\text4_mb_mark_bb(sb, block, 1, 1);\n\tar->len = 1;\n\n\treturn block;\n}\n\n \next4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\tint retries = 0;\n\tu64 seq;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\tif (sbi->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn ext4_mb_new_blocks_simple(ar, errp);\n\n\t \n\tif (ext4_is_quota_file(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t \n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t \n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\text4_mb_show_pa(sb);\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\text4_mb_initialize_context(ac, ar);\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tseq = this_cpu_read(discard_pa_seq);\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\n\n\t\t*errp = ext4_mb_pa_alloc(ac);\n\t\tif (*errp)\n\t\t\tgoto errout;\nrepeat:\n\t\t \n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\t \n\t\tif (*errp) {\n\t\t\text4_mb_pa_put_free(ac);\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t\tac->ac_o_ex.fe_len >= ac->ac_f_ex.fe_len)\n\t\t\text4_mb_pa_put_free(ac);\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tif (++retries < 3 &&\n\t\t    ext4_mb_discard_preallocations_should_retry(sb, ac, &seq))\n\t\t\tgoto repeat;\n\t\t \n\t\text4_mb_pa_put_free(ac);\n\t\t*errp = -ENOSPC;\n\t}\n\n\tif (*errp) {\nerrout:\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\n\tkmem_cache_free(ext4_ac_cachep, ac);\nout:\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t \n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}\n\n \nstatic void ext4_try_merge_freed_extent(struct ext4_sb_info *sbi,\n\t\t\t\t\tstruct ext4_free_data *entry,\n\t\t\t\t\tstruct ext4_free_data *new_entry,\n\t\t\t\t\tstruct rb_root *entry_rb_root)\n{\n\tif ((entry->efd_tid != new_entry->efd_tid) ||\n\t    (entry->efd_group != new_entry->efd_group))\n\t\treturn;\n\tif (entry->efd_start_cluster + entry->efd_count ==\n\t    new_entry->efd_start_cluster) {\n\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\tnew_entry->efd_count += entry->efd_count;\n\t} else if (new_entry->efd_start_cluster + new_entry->efd_count ==\n\t\t   entry->efd_start_cluster) {\n\t\tnew_entry->efd_count += entry->efd_count;\n\t} else\n\t\treturn;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_del(&entry->efd_list);\n\tspin_unlock(&sbi->s_md_lock);\n\trb_erase(&entry->efd_node, entry_rb_root);\n\tkmem_cache_free(ext4_free_data_cachep, entry);\n}\n\nstatic noinline_for_stack void\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\text4_grpblk_t clusters = new_entry->efd_count;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t \n\t\tget_page(e4b->bd_buddy_page);\n\t\tget_page(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\tkmem_cache_free(ext4_free_data_cachep, new_entry);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t \n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\text4_try_merge_freed_extent(sbi, entry, new_entry,\n\t\t\t\t\t    &(db->bb_free_root));\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\text4_try_merge_freed_extent(sbi, entry, new_entry,\n\t\t\t\t\t    &(db->bb_free_root));\n\t}\n\n\tspin_lock(&sbi->s_md_lock);\n\tlist_add_tail(&new_entry->efd_list, &sbi->s_freed_data_list);\n\tsbi->s_mb_free_pending += clusters;\n\tspin_unlock(&sbi->s_md_lock);\n}\n\nstatic void ext4_free_blocks_simple(struct inode *inode, ext4_fsblk_t block,\n\t\t\t\t\tunsigned long count)\n{\n\tstruct buffer_head *bitmap_bh;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\text4_group_t group;\n\text4_grpblk_t blkoff;\n\tint already_freed = 0, err, i;\n\n\text4_get_group_no_and_offset(sb, block, &group, &blkoff);\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\tpr_warn(\"Failed to read block bitmap\\n\");\n\t\treturn;\n\t}\n\tgdp = ext4_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto err_out;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(blkoff + i, bitmap_bh->b_data))\n\t\t\talready_freed++;\n\t}\n\tmb_clear_bits(bitmap_bh->b_data, blkoff, count);\n\terr = ext4_handle_dirty_metadata(NULL, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto err_out;\n\text4_free_group_clusters_set(\n\t\tsb, gdp, ext4_free_group_clusters(sb, gdp) +\n\t\tcount - already_freed);\n\text4_block_bitmap_csum_set(sb, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, group, gdp);\n\text4_handle_dirty_metadata(NULL, NULL, gdp_bh);\n\tsync_dirty_buffer(bitmap_bh);\n\tsync_dirty_buffer(gdp_bh);\n\nerr_out:\n\tbrelse(bitmap_bh);\n}\n\n \nstatic void ext4_mb_clear_bb(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t block, unsigned long count,\n\t\t\t       int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tstruct ext4_group_info *grp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tsbi = EXT4_SB(sb);\n\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_inode_block_valid(inode, block, count)) {\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t \n\t\tgoto error_return;\n\t}\n\tflags |= EXT4_FREE_BLOCKS_VALIDATED;\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tgrp = ext4_get_group_info(sb, block_group);\n\tif (unlikely(!grp || EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn;\n\n\t \n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t\t \n\t\tflags &= ~EXT4_FREE_BLOCKS_VALIDATED;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_inode_block_valid(inode, block, count)) {\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t \n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, sb, bitmap_bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto error_return;\n\n\t \n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, gd_bh, EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\t \n\terr = ext4_mb_load_buddy_gfp(sb, block_group, &e4b,\n\t\t\t\t     GFP_NOFS|__GFP_NOFAIL);\n\tif (err)\n\t\tgoto error_return;\n\n\t \n\tif (ext4_handle_valid(handle) &&\n\t    ((flags & EXT4_FREE_BLOCKS_METADATA) ||\n\t     !ext4_should_writeback_data(inode))) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t \n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep,\n\t\t\t\tGFP_NOFS|__GFP_NOFAIL);\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t \n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit,\n\t\t\t\t\t\t count_clusters, NULL);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%u block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\t \n\tif (!(flags & EXT4_FREE_BLOCKS_RERESERVE_CLUSTER)) {\n\t\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\t\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t\t   count_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t \n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t \n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\t \n\t\tflags &= ~EXT4_FREE_BLOCKS_VALIDATED;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n}\n\n \nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int overflow;\n\tstruct ext4_sb_info *sbi;\n\n\tsbi = EXT4_SB(sb);\n\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tif (sbi->s_mount_state & EXT4_FC_REPLAY) {\n\t\text4_free_blocks_simple(inode, block, EXT4_NUM_B2C(sbi, count));\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_inode_block_valid(inode, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\treturn;\n\t}\n\tflags |= EXT4_FREE_BLOCKS_VALIDATED;\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (bh && (flags & EXT4_FREE_BLOCKS_FORGET)) {\n\t\tBUG_ON(count > 1);\n\n\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t    inode, bh, block);\n\t}\n\n\t \n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t\t \n\t\tflags &= ~EXT4_FREE_BLOCKS_VALIDATED;\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t\t \n\t\tflags &= ~EXT4_FREE_BLOCKS_VALIDATED;\n\t}\n\n\tif (!bh && (flags & EXT4_FREE_BLOCKS_FORGET)) {\n\t\tint i;\n\t\tint is_metadata = flags & EXT4_FREE_BLOCKS_METADATA;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (is_metadata)\n\t\t\t\tbh = sb_find_get_block(inode->i_sb, block + i);\n\t\t\text4_forget(handle, is_metadata, inode, bh, block + i);\n\t\t}\n\t}\n\n\text4_mb_clear_bb(handle, inode, block, count, flags);\n}\n\n \nint ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, free_clusters_count;\n\text4_grpblk_t clusters_freed;\n\text4_fsblk_t first_cluster = EXT4_B2C(sbi, block);\n\text4_fsblk_t last_cluster = EXT4_B2C(sbi, block + count - 1);\n\tunsigned long cluster_count = last_cluster - first_cluster + 1;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t \n\tif (bit + cluster_count > EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too many blocks added to group %u\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh)) {\n\t\terr = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (!ext4_sb_block_valid(sb, NULL, block, count)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, sb, bitmap_bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto error_return;\n\n\t \n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, gd_bh, EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, clusters_freed = 0; i < cluster_count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tclusters_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t \n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, cluster_count);\n\tmb_free_blocks(NULL, &e4b, bit, cluster_count);\n\tfree_clusters_count = clusters_freed +\n\t\text4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, free_clusters_count);\n\text4_block_bitmap_csum_set(sb, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   clusters_freed);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(clusters_freed,\n\t\t\t     &sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t  flex_group)->free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t \n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t \n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}\n\n \nstatic int ext4_trim_extent(struct super_block *sb,\n\t\tint start, int count, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\text4_group_t group = e4b->bd_group;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t \n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count, NULL);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}\n\nstatic ext4_grpblk_t ext4_last_grp_cluster(struct super_block *sb,\n\t\t\t\t\t   ext4_group_t grp)\n{\n\tif (grp < ext4_get_groups_count(sb))\n\t\treturn EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\treturn (ext4_blocks_count(EXT4_SB(sb)->s_es) -\n\t\text4_group_first_block_no(sb, grp) - 1) >>\n\t\t\t\t\tEXT4_CLUSTER_BITS(sb);\n}\n\nstatic bool ext4_trim_interrupted(void)\n{\n\treturn fatal_signal_pending(current) || freezing(current);\n}\n\nstatic int ext4_try_to_trim_range(struct super_block *sb,\n\t\tstruct ext4_buddy *e4b, ext4_grpblk_t start,\n\t\text4_grpblk_t max, ext4_grpblk_t minblocks)\n__acquires(ext4_group_lock_ptr(sb, e4b->bd_group))\n__releases(ext4_group_lock_ptr(sb, e4b->bd_group))\n{\n\text4_grpblk_t next, count, free_count;\n\tbool set_trimmed = false;\n\tvoid *bitmap;\n\n\tbitmap = e4b->bd_bitmap;\n\tif (start == 0 && max >= ext4_last_grp_cluster(sb, e4b->bd_group))\n\t\tset_trimmed = true;\n\tstart = max(e4b->bd_info->bb_first_free, start);\n\tcount = 0;\n\tfree_count = 0;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tint ret = ext4_trim_extent(sb, start, next - start, e4b);\n\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\treturn count;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (ext4_trim_interrupted())\n\t\t\treturn count;\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, e4b->bd_group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, e4b->bd_group);\n\t\t}\n\n\t\tif ((e4b->bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (set_trimmed)\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b->bd_info);\n\n\treturn count;\n}\n\n \nstatic ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tstruct ext4_buddy e4b;\n\tint ret;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_warning(sb, \"Error %d loading buddy information for %u\",\n\t\t\t     ret, group);\n\t\treturn ret;\n\t}\n\n\text4_lock_group(sb, group);\n\n\tif (!EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) ||\n\t    minblocks < EXT4_SB(sb)->s_last_trim_minblks)\n\t\tret = ext4_try_to_trim_range(sb, &e4b, start, max, minblocks);\n\telse\n\t\tret = 0;\n\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tret, group);\n\n\treturn ret;\n}\n\n \nint ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tunsigned int discard_granularity = bdev_discard_granularity(sb->s_bdev);\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\t \n\tif (range->minlen < discard_granularity) {\n\t\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t\tdiscard_granularity >> sb->s_blocksize_bits);\n\t\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb))\n\t\t\tgoto out;\n\t}\n\tif (end >= max_blks - 1)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t \n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t \n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tif (ext4_trim_interrupted())\n\t\t\tbreak;\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\tif (!grp)\n\t\t\tcontinue;\n\t\t \n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group, GFP_NOFS);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\t end, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t \n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tEXT4_SB(sb)->s_last_trim_minblks = minlen;\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}\n\n \nint\next4_mballoc_query_range(\n\tstruct super_block\t\t*sb,\n\text4_group_t\t\t\tgroup,\n\text4_grpblk_t\t\t\tstart,\n\text4_grpblk_t\t\t\tend,\n\text4_mballoc_query_range_fn\tformatter,\n\tvoid\t\t\t\t*priv)\n{\n\tvoid\t\t\t\t*bitmap;\n\text4_grpblk_t\t\t\tnext;\n\tstruct ext4_buddy\t\te4b;\n\tint\t\t\t\terror;\n\n\terror = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (error)\n\t\treturn error;\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\n\tstart = max(e4b.bd_info->bb_first_free, start);\n\tif (end >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\twhile (start <= end) {\n\t\tstart = mb_find_next_zero_bit(bitmap, end + 1, start);\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, end + 1, start);\n\n\t\text4_unlock_group(sb, group);\n\t\terror = formatter(sb, group, start, next - start, priv);\n\t\tif (error)\n\t\t\tgoto out_unload;\n\t\text4_lock_group(sb, group);\n\n\t\tstart = next + 1;\n\t}\n\n\text4_unlock_group(sb, group);\nout_unload:\n\text4_mb_unload_buddy(&e4b);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}