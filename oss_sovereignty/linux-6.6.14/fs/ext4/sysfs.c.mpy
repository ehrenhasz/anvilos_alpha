{
  "module_name": "sysfs.c",
  "hash_id": "c5f8c10d136893930cbc25e12f647b933ada55bb4ed60f10d7e42679fbdbe50a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/part_stat.h>\n\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\ntypedef enum {\n\tattr_noop,\n\tattr_delayed_allocation_blocks,\n\tattr_session_write_kbytes,\n\tattr_lifetime_write_kbytes,\n\tattr_reserved_clusters,\n\tattr_sra_exceeded_retry_limit,\n\tattr_inode_readahead,\n\tattr_trigger_test_error,\n\tattr_first_error_time,\n\tattr_last_error_time,\n\tattr_feature,\n\tattr_pointer_ui,\n\tattr_pointer_ul,\n\tattr_pointer_u64,\n\tattr_pointer_u8,\n\tattr_pointer_string,\n\tattr_pointer_atomic,\n\tattr_journal_task,\n} attr_id_t;\n\ntypedef enum {\n\tptr_explicit,\n\tptr_ext4_sb_info_offset,\n\tptr_ext4_super_block_offset,\n} attr_ptr_t;\n\nstatic const char proc_dirname[] = \"fs/ext4\";\nstatic struct proc_dir_entry *ext4_proc_root;\n\nstruct ext4_attr {\n\tstruct attribute attr;\n\tshort attr_id;\n\tshort attr_ptr;\n\tunsigned short attr_size;\n\tunion {\n\t\tint offset;\n\t\tvoid *explicit_ptr;\n\t} u;\n};\n\nstatic ssize_t session_write_kbytes_show(struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\treturn sysfs_emit(buf, \"%lu\\n\",\n\t\t\t(part_stat_read(sb->s_bdev, sectors[STAT_WRITE]) -\n\t\t\t sbi->s_sectors_written_start) >> 1);\n}\n\nstatic ssize_t lifetime_write_kbytes_show(struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)(sbi->s_kbytes_written +\n\t\t\t((part_stat_read(sb->s_bdev, sectors[STAT_WRITE]) -\n\t\t\t  EXT4_SB(sb)->s_sectors_written_start) >> 1)));\n}\n\nstatic ssize_t inode_readahead_blks_store(struct ext4_sb_info *sbi,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint ret;\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret)\n\t\treturn ret;\n\n\tif (t && (!is_power_of_2(t) || t > 0x40000000))\n\t\treturn -EINVAL;\n\n\tsbi->s_inode_readahead_blks = t;\n\treturn count;\n}\n\nstatic ssize_t reserved_clusters_store(struct ext4_sb_info *sbi,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long long val;\n\text4_fsblk_t clusters = (ext4_blocks_count(sbi->s_es) >>\n\t\t\t\t sbi->s_cluster_bits);\n\tint ret;\n\n\tret = kstrtoull(skip_spaces(buf), 0, &val);\n\tif (ret || val >= clusters)\n\t\treturn -EINVAL;\n\n\tatomic64_set(&sbi->s_resv_clusters, val);\n\treturn count;\n}\n\nstatic ssize_t trigger_test_error(struct ext4_sb_info *sbi,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint len = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (len)\n\t\text4_error(sbi->s_sb, \"%.*s\", len, buf);\n\treturn count;\n}\n\nstatic ssize_t journal_task_show(struct ext4_sb_info *sbi, char *buf)\n{\n\tif (!sbi->s_journal)\n\t\treturn sysfs_emit(buf, \"<none>\\n\");\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\ttask_pid_vnr(sbi->s_journal->j_task));\n}\n\n#define EXT4_ATTR(_name,_mode,_id)\t\t\t\t\t\\\nstatic struct ext4_attr ext4_attr_##_name = {\t\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\t\\\n}\n\n#define EXT4_ATTR_FUNC(_name,_mode)  EXT4_ATTR(_name,_mode,_name)\n\n#define EXT4_ATTR_FEATURE(_name)   EXT4_ATTR(_name, 0444, feature)\n\n#define EXT4_ATTR_OFFSET(_name,_mode,_id,_struct,_elname)\t\\\nstatic struct ext4_attr ext4_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\\\n\t.attr_ptr = ptr_##_struct##_offset,\t\t\t\\\n\t.u = {\t\t\t\t\t\t\t\\\n\t\t.offset = offsetof(struct _struct, _elname),\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define EXT4_ATTR_STRING(_name,_mode,_size,_struct,_elname)\t\\\nstatic struct ext4_attr ext4_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.attr_id = attr_pointer_string,\t\t\t\t\\\n\t.attr_size = _size,\t\t\t\t\t\\\n\t.attr_ptr = ptr_##_struct##_offset,\t\t\t\\\n\t.u = {\t\t\t\t\t\t\t\\\n\t\t.offset = offsetof(struct _struct, _elname),\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define EXT4_RO_ATTR_ES_UI(_name,_elname)\t\t\t\t\\\n\tEXT4_ATTR_OFFSET(_name, 0444, pointer_ui, ext4_super_block, _elname)\n\n#define EXT4_RO_ATTR_ES_U8(_name,_elname)\t\t\t\t\\\n\tEXT4_ATTR_OFFSET(_name, 0444, pointer_u8, ext4_super_block, _elname)\n\n#define EXT4_RO_ATTR_ES_U64(_name,_elname)\t\t\t\t\\\n\tEXT4_ATTR_OFFSET(_name, 0444, pointer_u64, ext4_super_block, _elname)\n\n#define EXT4_RO_ATTR_ES_STRING(_name,_elname,_size)\t\t\t\\\n\tEXT4_ATTR_STRING(_name, 0444, _size, ext4_super_block, _elname)\n\n#define EXT4_RW_ATTR_SBI_UI(_name,_elname)\t\\\n\tEXT4_ATTR_OFFSET(_name, 0644, pointer_ui, ext4_sb_info, _elname)\n\n#define EXT4_RW_ATTR_SBI_UL(_name,_elname)\t\\\n\tEXT4_ATTR_OFFSET(_name, 0644, pointer_ul, ext4_sb_info, _elname)\n\n#define EXT4_RO_ATTR_SBI_ATOMIC(_name,_elname)\t\\\n\tEXT4_ATTR_OFFSET(_name, 0444, pointer_atomic, ext4_sb_info, _elname)\n\n#define EXT4_ATTR_PTR(_name,_mode,_id,_ptr) \\\nstatic struct ext4_attr ext4_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.attr_id = attr_##_id,\t\t\t\t\t\\\n\t.attr_ptr = ptr_explicit,\t\t\t\t\\\n\t.u = {\t\t\t\t\t\t\t\\\n\t\t.explicit_ptr = _ptr,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\n#define ATTR_LIST(name) &ext4_attr_##name.attr\n\nEXT4_ATTR_FUNC(delayed_allocation_blocks, 0444);\nEXT4_ATTR_FUNC(session_write_kbytes, 0444);\nEXT4_ATTR_FUNC(lifetime_write_kbytes, 0444);\nEXT4_ATTR_FUNC(reserved_clusters, 0644);\nEXT4_ATTR_FUNC(sra_exceeded_retry_limit, 0444);\n\nEXT4_ATTR_OFFSET(inode_readahead_blks, 0644, inode_readahead,\n\t\t ext4_sb_info, s_inode_readahead_blks);\nEXT4_RW_ATTR_SBI_UI(inode_goal, s_inode_goal);\nEXT4_RW_ATTR_SBI_UI(mb_stats, s_mb_stats);\nEXT4_RW_ATTR_SBI_UI(mb_max_to_scan, s_mb_max_to_scan);\nEXT4_RW_ATTR_SBI_UI(mb_min_to_scan, s_mb_min_to_scan);\nEXT4_RW_ATTR_SBI_UI(mb_order2_req, s_mb_order2_reqs);\nEXT4_RW_ATTR_SBI_UI(mb_stream_req, s_mb_stream_request);\nEXT4_RW_ATTR_SBI_UI(mb_group_prealloc, s_mb_group_prealloc);\nEXT4_RW_ATTR_SBI_UI(mb_max_linear_groups, s_mb_max_linear_groups);\nEXT4_RW_ATTR_SBI_UI(extent_max_zeroout_kb, s_extent_max_zeroout_kb);\nEXT4_ATTR(trigger_fs_error, 0200, trigger_test_error);\nEXT4_RW_ATTR_SBI_UI(err_ratelimit_interval_ms, s_err_ratelimit_state.interval);\nEXT4_RW_ATTR_SBI_UI(err_ratelimit_burst, s_err_ratelimit_state.burst);\nEXT4_RW_ATTR_SBI_UI(warning_ratelimit_interval_ms, s_warning_ratelimit_state.interval);\nEXT4_RW_ATTR_SBI_UI(warning_ratelimit_burst, s_warning_ratelimit_state.burst);\nEXT4_RW_ATTR_SBI_UI(msg_ratelimit_interval_ms, s_msg_ratelimit_state.interval);\nEXT4_RW_ATTR_SBI_UI(msg_ratelimit_burst, s_msg_ratelimit_state.burst);\nEXT4_RW_ATTR_SBI_UI(mb_best_avail_max_trim_order, s_mb_best_avail_max_trim_order);\n#ifdef CONFIG_EXT4_DEBUG\nEXT4_RW_ATTR_SBI_UL(simulate_fail, s_simulate_fail);\n#endif\nEXT4_RO_ATTR_SBI_ATOMIC(warning_count, s_warning_count);\nEXT4_RO_ATTR_SBI_ATOMIC(msg_count, s_msg_count);\nEXT4_RO_ATTR_ES_UI(errors_count, s_error_count);\nEXT4_RO_ATTR_ES_U8(first_error_errcode, s_first_error_errcode);\nEXT4_RO_ATTR_ES_U8(last_error_errcode, s_last_error_errcode);\nEXT4_RO_ATTR_ES_UI(first_error_ino, s_first_error_ino);\nEXT4_RO_ATTR_ES_UI(last_error_ino, s_last_error_ino);\nEXT4_RO_ATTR_ES_U64(first_error_block, s_first_error_block);\nEXT4_RO_ATTR_ES_U64(last_error_block, s_last_error_block);\nEXT4_RO_ATTR_ES_UI(first_error_line, s_first_error_line);\nEXT4_RO_ATTR_ES_UI(last_error_line, s_last_error_line);\nEXT4_RO_ATTR_ES_STRING(first_error_func, s_first_error_func, 32);\nEXT4_RO_ATTR_ES_STRING(last_error_func, s_last_error_func, 32);\nEXT4_ATTR(first_error_time, 0444, first_error_time);\nEXT4_ATTR(last_error_time, 0444, last_error_time);\nEXT4_ATTR(journal_task, 0444, journal_task);\nEXT4_RW_ATTR_SBI_UI(mb_prefetch, s_mb_prefetch);\nEXT4_RW_ATTR_SBI_UI(mb_prefetch_limit, s_mb_prefetch_limit);\nEXT4_RW_ATTR_SBI_UL(last_trim_minblks, s_last_trim_minblks);\n\nstatic unsigned int old_bump_val = 128;\nEXT4_ATTR_PTR(max_writeback_mb_bump, 0444, pointer_ui, &old_bump_val);\n\nstatic struct attribute *ext4_attrs[] = {\n\tATTR_LIST(delayed_allocation_blocks),\n\tATTR_LIST(session_write_kbytes),\n\tATTR_LIST(lifetime_write_kbytes),\n\tATTR_LIST(reserved_clusters),\n\tATTR_LIST(sra_exceeded_retry_limit),\n\tATTR_LIST(inode_readahead_blks),\n\tATTR_LIST(inode_goal),\n\tATTR_LIST(mb_stats),\n\tATTR_LIST(mb_max_to_scan),\n\tATTR_LIST(mb_min_to_scan),\n\tATTR_LIST(mb_order2_req),\n\tATTR_LIST(mb_stream_req),\n\tATTR_LIST(mb_group_prealloc),\n\tATTR_LIST(mb_max_linear_groups),\n\tATTR_LIST(max_writeback_mb_bump),\n\tATTR_LIST(extent_max_zeroout_kb),\n\tATTR_LIST(trigger_fs_error),\n\tATTR_LIST(err_ratelimit_interval_ms),\n\tATTR_LIST(err_ratelimit_burst),\n\tATTR_LIST(warning_ratelimit_interval_ms),\n\tATTR_LIST(warning_ratelimit_burst),\n\tATTR_LIST(msg_ratelimit_interval_ms),\n\tATTR_LIST(msg_ratelimit_burst),\n\tATTR_LIST(mb_best_avail_max_trim_order),\n\tATTR_LIST(errors_count),\n\tATTR_LIST(warning_count),\n\tATTR_LIST(msg_count),\n\tATTR_LIST(first_error_ino),\n\tATTR_LIST(last_error_ino),\n\tATTR_LIST(first_error_block),\n\tATTR_LIST(last_error_block),\n\tATTR_LIST(first_error_line),\n\tATTR_LIST(last_error_line),\n\tATTR_LIST(first_error_func),\n\tATTR_LIST(last_error_func),\n\tATTR_LIST(first_error_errcode),\n\tATTR_LIST(last_error_errcode),\n\tATTR_LIST(first_error_time),\n\tATTR_LIST(last_error_time),\n\tATTR_LIST(journal_task),\n#ifdef CONFIG_EXT4_DEBUG\n\tATTR_LIST(simulate_fail),\n#endif\n\tATTR_LIST(mb_prefetch),\n\tATTR_LIST(mb_prefetch_limit),\n\tATTR_LIST(last_trim_minblks),\n\tNULL,\n};\nATTRIBUTE_GROUPS(ext4);\n\n \nEXT4_ATTR_FEATURE(lazy_itable_init);\nEXT4_ATTR_FEATURE(batched_discard);\nEXT4_ATTR_FEATURE(meta_bg_resize);\n#ifdef CONFIG_FS_ENCRYPTION\nEXT4_ATTR_FEATURE(encryption);\nEXT4_ATTR_FEATURE(test_dummy_encryption_v2);\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\nEXT4_ATTR_FEATURE(casefold);\n#endif\n#ifdef CONFIG_FS_VERITY\nEXT4_ATTR_FEATURE(verity);\n#endif\nEXT4_ATTR_FEATURE(metadata_csum_seed);\nEXT4_ATTR_FEATURE(fast_commit);\n#if IS_ENABLED(CONFIG_UNICODE) && defined(CONFIG_FS_ENCRYPTION)\nEXT4_ATTR_FEATURE(encrypted_casefold);\n#endif\n\nstatic struct attribute *ext4_feat_attrs[] = {\n\tATTR_LIST(lazy_itable_init),\n\tATTR_LIST(batched_discard),\n\tATTR_LIST(meta_bg_resize),\n#ifdef CONFIG_FS_ENCRYPTION\n\tATTR_LIST(encryption),\n\tATTR_LIST(test_dummy_encryption_v2),\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tATTR_LIST(casefold),\n#endif\n#ifdef CONFIG_FS_VERITY\n\tATTR_LIST(verity),\n#endif\n\tATTR_LIST(metadata_csum_seed),\n\tATTR_LIST(fast_commit),\n#if IS_ENABLED(CONFIG_UNICODE) && defined(CONFIG_FS_ENCRYPTION)\n\tATTR_LIST(encrypted_casefold),\n#endif\n\tNULL,\n};\nATTRIBUTE_GROUPS(ext4_feat);\n\nstatic void *calc_ptr(struct ext4_attr *a, struct ext4_sb_info *sbi)\n{\n\tswitch (a->attr_ptr) {\n\tcase ptr_explicit:\n\t\treturn a->u.explicit_ptr;\n\tcase ptr_ext4_sb_info_offset:\n\t\treturn (void *) (((char *) sbi) + a->u.offset);\n\tcase ptr_ext4_super_block_offset:\n\t\treturn (void *) (((char *) sbi->s_es) + a->u.offset);\n\t}\n\treturn NULL;\n}\n\nstatic ssize_t __print_tstamp(char *buf, __le32 lo, __u8 hi)\n{\n\treturn sysfs_emit(buf, \"%lld\\n\",\n\t\t\t((time64_t)hi << 32) + le32_to_cpu(lo));\n}\n\n#define print_tstamp(buf, es, tstamp) \\\n\t__print_tstamp(buf, (es)->tstamp, (es)->tstamp ## _hi)\n\nstatic ssize_t ext4_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\tvoid *ptr = calc_ptr(a, sbi);\n\n\tswitch (a->attr_id) {\n\tcase attr_delayed_allocation_blocks:\n\t\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t\t(s64) EXT4_C2B(sbi,\n\t\t       percpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\tcase attr_session_write_kbytes:\n\t\treturn session_write_kbytes_show(sbi, buf);\n\tcase attr_lifetime_write_kbytes:\n\t\treturn lifetime_write_kbytes_show(sbi, buf);\n\tcase attr_reserved_clusters:\n\t\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t\t(unsigned long long)\n\t\t\t\tatomic64_read(&sbi->s_resv_clusters));\n\tcase attr_sra_exceeded_retry_limit:\n\t\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t\t(unsigned long long)\n\t\t\tpercpu_counter_sum(&sbi->s_sra_exceeded_retry_limit));\n\tcase attr_inode_readahead:\n\tcase attr_pointer_ui:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tif (a->attr_ptr == ptr_ext4_super_block_offset)\n\t\t\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t\t\tle32_to_cpup(ptr));\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t\t\t*((unsigned int *) ptr));\n\tcase attr_pointer_ul:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%lu\\n\",\n\t\t\t\t*((unsigned long *) ptr));\n\tcase attr_pointer_u8:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t\t*((unsigned char *) ptr));\n\tcase attr_pointer_u64:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tif (a->attr_ptr == ptr_ext4_super_block_offset)\n\t\t\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t\t\tle64_to_cpup(ptr));\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t\t\t*((unsigned long long *) ptr));\n\tcase attr_pointer_string:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%.*s\\n\", a->attr_size,\n\t\t\t\t(char *) ptr);\n\tcase attr_pointer_atomic:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t\tatomic_read((atomic_t *) ptr));\n\tcase attr_feature:\n\t\treturn sysfs_emit(buf, \"supported\\n\");\n\tcase attr_first_error_time:\n\t\treturn print_tstamp(buf, sbi->s_es, s_first_error_time);\n\tcase attr_last_error_time:\n\t\treturn print_tstamp(buf, sbi->s_es, s_last_error_time);\n\tcase attr_journal_task:\n\t\treturn journal_task_show(sbi, buf);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ext4_attr_store(struct kobject *kobj,\n\t\t\t       struct attribute *attr,\n\t\t\t       const char *buf, size_t len)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tstruct ext4_attr *a = container_of(attr, struct ext4_attr, attr);\n\tvoid *ptr = calc_ptr(a, sbi);\n\tunsigned long t;\n\tint ret;\n\n\tswitch (a->attr_id) {\n\tcase attr_reserved_clusters:\n\t\treturn reserved_clusters_store(sbi, buf, len);\n\tcase attr_pointer_ui:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (a->attr_ptr == ptr_ext4_super_block_offset)\n\t\t\t*((__le32 *) ptr) = cpu_to_le32(t);\n\t\telse\n\t\t\t*((unsigned int *) ptr) = t;\n\t\treturn len;\n\tcase attr_pointer_ul:\n\t\tif (!ptr)\n\t\t\treturn 0;\n\t\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*((unsigned long *) ptr) = t;\n\t\treturn len;\n\tcase attr_inode_readahead:\n\t\treturn inode_readahead_blks_store(sbi, buf, len);\n\tcase attr_trigger_test_error:\n\t\treturn trigger_test_error(sbi, buf, len);\n\t}\n\treturn 0;\n}\n\nstatic void ext4_sb_release(struct kobject *kobj)\n{\n\tstruct ext4_sb_info *sbi = container_of(kobj, struct ext4_sb_info,\n\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}\n\nstatic void ext4_feat_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct sysfs_ops ext4_attr_ops = {\n\t.show\t= ext4_attr_show,\n\t.store\t= ext4_attr_store,\n};\n\nstatic const struct kobj_type ext4_sb_ktype = {\n\t.default_groups = ext4_groups,\n\t.sysfs_ops\t= &ext4_attr_ops,\n\t.release\t= ext4_sb_release,\n};\n\nstatic const struct kobj_type ext4_feat_ktype = {\n\t.default_groups = ext4_feat_groups,\n\t.sysfs_ops\t= &ext4_attr_ops,\n\t.release\t= ext4_feat_release,\n};\n\nvoid ext4_notify_error_sysfs(struct ext4_sb_info *sbi)\n{\n\tsysfs_notify(&sbi->s_kobj, NULL, \"errors_count\");\n}\n\nstatic struct kobject *ext4_root;\n\nstatic struct kobject *ext4_feat;\n\nint ext4_register_sysfs(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_sb_ktype, ext4_root,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\tkobject_put(&sbi->s_kobj);\n\t\twait_for_completion(&sbi->s_kobj_unregister);\n\t\treturn err;\n\t}\n\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\tif (sbi->s_proc) {\n\t\tproc_create_single_data(\"options\", S_IRUGO, sbi->s_proc,\n\t\t\t\text4_seq_options_show, sb);\n\t\tproc_create_single_data(\"es_shrinker_info\", S_IRUGO,\n\t\t\t\tsbi->s_proc, ext4_seq_es_shrinker_info_show,\n\t\t\t\tsb);\n\t\tproc_create_single_data(\"fc_info\", 0444, sbi->s_proc,\n\t\t\t\t\text4_fc_info_show, sb);\n\t\tproc_create_seq_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t&ext4_mb_seq_groups_ops, sb);\n\t\tproc_create_single_data(\"mb_stats\", 0444, sbi->s_proc,\n\t\t\t\text4_seq_mb_stats_show, sb);\n\t\tproc_create_seq_data(\"mb_structs_summary\", 0444, sbi->s_proc,\n\t\t\t\t&ext4_mb_seq_structs_summary_ops, sb);\n\t}\n\treturn 0;\n}\n\nvoid ext4_unregister_sysfs(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sbi->s_proc)\n\t\tremove_proc_subtree(sb->s_id, ext4_proc_root);\n\tkobject_del(&sbi->s_kobj);\n}\n\nint __init ext4_init_sysfs(void)\n{\n\tint ret;\n\n\text4_root = kobject_create_and_add(\"ext4\", fs_kobj);\n\tif (!ext4_root)\n\t\treturn -ENOMEM;\n\n\text4_feat = kzalloc(sizeof(*ext4_feat), GFP_KERNEL);\n\tif (!ext4_feat) {\n\t\tret = -ENOMEM;\n\t\tgoto root_err;\n\t}\n\n\tret = kobject_init_and_add(ext4_feat, &ext4_feat_ktype,\n\t\t\t\t   ext4_root, \"features\");\n\tif (ret)\n\t\tgoto feat_err;\n\n\text4_proc_root = proc_mkdir(proc_dirname, NULL);\n\treturn ret;\n\nfeat_err:\n\tkobject_put(ext4_feat);\n\text4_feat = NULL;\nroot_err:\n\tkobject_put(ext4_root);\n\text4_root = NULL;\n\treturn ret;\n}\n\nvoid ext4_exit_sysfs(void)\n{\n\tkobject_put(ext4_feat);\n\text4_feat = NULL;\n\tkobject_put(ext4_root);\n\text4_root = NULL;\n\tremove_proc_entry(proc_dirname, NULL);\n\text4_proc_root = NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}