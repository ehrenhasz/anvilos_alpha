{
  "module_name": "ialloc.c",
  "hash_id": "c6d00e23845acbcdef6c746ba7823a66c43f1c758a32e61945694b40f0d6226a",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/ialloc.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/cred.h>\n\n#include <asm/byteorder.h>\n\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\n#include <trace/events/ext4.h>\n\n \n\n \n\n \nvoid ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text4_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text4_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}\n\nvoid ext4_end_bitmap_read(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t\tset_bitmap_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}\n\nstatic int ext4_validate_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *desc,\n\t\t\t\t      ext4_group_t block_group,\n\t\t\t\t      struct buffer_head *bh)\n{\n\text4_fsblk_t\tblk;\n\tstruct ext4_group_info *grp;\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\tgrp = ext4_get_group_info(sb, block_group);\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\tif (!grp || EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\treturn -EFSCORRUPTED;\n\n\text4_lock_group(sb, block_group);\n\tif (buffer_verified(bh))\n\t\tgoto verified;\n\tblk = ext4_inode_bitmap(sb, desc);\n\tif (!ext4_inode_bitmap_csum_verify(sb, desc, bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8) ||\n\t    ext4_simulate_fail(sb, EXT4_SIM_IBITMAP_CRC)) {\n\t\text4_unlock_group(sb, block_group);\n\t\text4_error(sb, \"Corrupt inode bitmap - block_group = %u, \"\n\t\t\t   \"inode_bitmap = %llu\", block_group, blk);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn -EFSBADCRC;\n\t}\n\tset_buffer_verified(bh);\nverified:\n\text4_unlock_group(sb, block_group);\n\treturn 0;\n}\n\n \nstatic struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_warning(sb, \"Cannot read inode bitmap - \"\n\t\t\t     \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t     block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {\n\t\tif (block_group == 0) {\n\t\t\text4_unlock_group(sb, block_group);\n\t\t\tunlock_buffer(bh);\n\t\t\text4_error(sb, \"Inode bitmap for bg 0 marked \"\n\t\t\t\t   \"uninitialized\");\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t \n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t \n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\text4_read_bh(bh, REQ_META | REQ_PRIO, ext4_end_bitmap_read);\n\text4_simulate_fail_bh(sb, bh, EXT4_SIM_IBITMAP_EIO);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error_err(sb, EIO, \"Cannot read inode bitmap - \"\n\t\t\t       \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t       block_group, bitmap_blk);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n\n \nvoid ext4_free_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\text4_group_t block_group;\n\tunsigned long bit;\n\tstruct ext4_group_desc *gdp;\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi;\n\tint fatal = 0, err, count, cleared;\n\tstruct ext4_group_info *grp;\n\n\tif (!sb) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s:%d: inode on \"\n\t\t       \"nonexistent device\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: count=%d\",\n\t\t\t __func__, __LINE__, inode->i_ino,\n\t\t\t atomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: nlink=%d\\n\",\n\t\t\t __func__, __LINE__, inode->i_ino, inode->i_nlink);\n\t\treturn;\n\t}\n\tsbi = EXT4_SB(sb);\n\n\tino = inode->i_ino;\n\text4_debug(\"freeing inode %lu\\n\", ino);\n\ttrace_ext4_free_inode(inode);\n\n\tdquot_initialize(inode);\n\tdquot_free_inode(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\t \n\text4_clear_inode(inode);\n\n\tes = sbi->s_es;\n\tif (ino < EXT4_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text4_error(sb, \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\t \n\tif (IS_ERR(bitmap_bh)) {\n\t\tfatal = PTR_ERR(bitmap_bh);\n\t\tbitmap_bh = NULL;\n\t\tgoto error_return;\n\t}\n\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY)) {\n\t\tgrp = ext4_get_group_info(sb, block_group);\n\t\tif (!grp || unlikely(EXT4_MB_GRP_IBITMAP_CORRUPT(grp))) {\n\t\t\tfatal = -EFSCORRUPTED;\n\t\t\tgoto error_return;\n\t\t}\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext4_journal_get_write_access(handle, sb, bitmap_bh,\n\t\t\t\t\t      EXT4_JTR_NONE);\n\tif (fatal)\n\t\tgoto error_return;\n\n\tfatal = -ESRCH;\n\tgdp = ext4_get_group_desc(sb, block_group, &bh2);\n\tif (gdp) {\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext4_journal_get_write_access(handle, sb, bh2,\n\t\t\t\t\t\t      EXT4_JTR_NONE);\n\t}\n\text4_lock_group(sb, block_group);\n\tcleared = ext4_test_and_clear_bit(bit, bitmap_bh->b_data);\n\tif (fatal || !cleared) {\n\t\text4_unlock_group(sb, block_group);\n\t\tgoto out;\n\t}\n\n\tcount = ext4_free_inodes_count(sb, gdp) + 1;\n\text4_free_inodes_set(sb, gdp, count);\n\tif (is_directory) {\n\t\tcount = ext4_used_dirs_count(sb, gdp) - 1;\n\t\text4_used_dirs_set(sb, gdp, count);\n\t\tif (percpu_counter_initialized(&sbi->s_dirs_counter))\n\t\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\t}\n\text4_inode_bitmap_csum_set(sb, gdp, bitmap_bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (percpu_counter_initialized(&sbi->s_freeinodes_counter))\n\t\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\tif (sbi->s_log_groups_per_flex) {\n\t\tstruct flex_groups *fg;\n\n\t\tfg = sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t ext4_flex_group(sbi, block_group));\n\t\tatomic_inc(&fg->free_inodes);\n\t\tif (is_directory)\n\t\t\tatomic_dec(&fg->used_dirs);\n\t}\n\tBUFFER_TRACE(bh2, \"call ext4_handle_dirty_metadata\");\n\tfatal = ext4_handle_dirty_metadata(handle, NULL, bh2);\nout:\n\tif (cleared) {\n\t\tBUFFER_TRACE(bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!fatal)\n\t\t\tfatal = err;\n\t} else {\n\t\text4_error(sb, \"bit already cleared for inode %lu\", ino);\n\t\text4_mark_group_bitmap_corrupted(sb, block_group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, fatal);\n}\n\nstruct orlov_stats {\n\t__u64 free_clusters;\n\t__u32 free_inodes;\n\t__u32 used_dirs;\n};\n\n \nstatic void get_orlov_stats(struct super_block *sb, ext4_group_t g,\n\t\t\t    int flex_size, struct orlov_stats *stats)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (flex_size > 1) {\n\t\tstruct flex_groups *fg = sbi_array_rcu_deref(EXT4_SB(sb),\n\t\t\t\t\t\t\t     s_flex_groups, g);\n\t\tstats->free_inodes = atomic_read(&fg->free_inodes);\n\t\tstats->free_clusters = atomic64_read(&fg->free_clusters);\n\t\tstats->used_dirs = atomic_read(&fg->used_dirs);\n\t\treturn;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, g, NULL);\n\tif (desc) {\n\t\tstats->free_inodes = ext4_free_inodes_count(sb, desc);\n\t\tstats->free_clusters = ext4_free_group_clusters(sb, desc);\n\t\tstats->used_dirs = ext4_used_dirs_count(sb, desc);\n\t} else {\n\t\tstats->free_inodes = 0;\n\t\tstats->free_clusters = 0;\n\t\tstats->used_dirs = 0;\n\t}\n}\n\n \n\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent,\n\t\t\t    ext4_group_t *group, umode_t mode,\n\t\t\t    const struct qstr *qstr)\n{\n\text4_group_t parent_group = EXT4_I(parent)->i_block_group;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t real_ngroups = ext4_get_groups_count(sb);\n\tint inodes_per_group = EXT4_INODES_PER_GROUP(sb);\n\tunsigned int freei, avefreei, grp_free;\n\text4_fsblk_t freec, avefreec;\n\tunsigned int ndirs;\n\tint max_dirs, min_inodes;\n\text4_grpblk_t min_clusters;\n\text4_group_t i, grp, g, ngroups;\n\tstruct ext4_group_desc *desc;\n\tstruct orlov_stats stats;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tstruct dx_hash_info hinfo;\n\n\tngroups = real_ngroups;\n\tif (flex_size > 1) {\n\t\tngroups = (real_ngroups + flex_size - 1) >>\n\t\t\tsbi->s_log_groups_per_flex;\n\t\tparent_group >>= sbi->s_log_groups_per_flex;\n\t}\n\n\tfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\n\tavefreei = freei / ngroups;\n\tfreec = percpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tavefreec = freec;\n\tdo_div(avefreec, ngroups);\n\tndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\n\n\tif (S_ISDIR(mode) &&\n\t    ((parent == d_inode(sb->s_root)) ||\n\t     (ext4_test_inode_flag(parent, EXT4_INODE_TOPDIR)))) {\n\t\tint best_ndir = inodes_per_group;\n\t\tint ret = -1;\n\n\t\tif (qstr) {\n\t\t\thinfo.hash_version = DX_HASH_HALF_MD4;\n\t\t\thinfo.seed = sbi->s_hash_seed;\n\t\t\text4fs_dirhash(parent, qstr->name, qstr->len, &hinfo);\n\t\t\tparent_group = hinfo.hash % ngroups;\n\t\t} else\n\t\t\tparent_group = get_random_u32_below(ngroups);\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tg = (parent_group + i) % ngroups;\n\t\t\tget_orlov_stats(sb, g, flex_size, &stats);\n\t\t\tif (!stats.free_inodes)\n\t\t\t\tcontinue;\n\t\t\tif (stats.used_dirs >= best_ndir)\n\t\t\t\tcontinue;\n\t\t\tif (stats.free_inodes < avefreei)\n\t\t\t\tcontinue;\n\t\t\tif (stats.free_clusters < avefreec)\n\t\t\t\tcontinue;\n\t\t\tgrp = g;\n\t\t\tret = 0;\n\t\t\tbest_ndir = stats.used_dirs;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto fallback;\n\tfound_flex_bg:\n\t\tif (flex_size == 1) {\n\t\t\t*group = grp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tgrp *= flex_size;\n\t\tfor (i = 0; i < flex_size; i++) {\n\t\t\tif (grp+i >= real_ngroups)\n\t\t\t\tbreak;\n\t\t\tdesc = ext4_get_group_desc(sb, grp+i, NULL);\n\t\t\tif (desc && ext4_free_inodes_count(sb, desc)) {\n\t\t\t\t*group = grp+i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tgoto fallback;\n\t}\n\n\tmax_dirs = ndirs / ngroups + inodes_per_group*flex_size / 16;\n\tmin_inodes = avefreei - inodes_per_group*flex_size / 4;\n\tif (min_inodes < 1)\n\t\tmin_inodes = 1;\n\tmin_clusters = avefreec - EXT4_CLUSTERS_PER_GROUP(sb)*flex_size / 4;\n\n\t \n\tif (EXT4_I(parent)->i_last_alloc_group != ~0) {\n\t\tparent_group = EXT4_I(parent)->i_last_alloc_group;\n\t\tif (flex_size > 1)\n\t\t\tparent_group >>= sbi->s_log_groups_per_flex;\n\t}\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgrp = (parent_group + i) % ngroups;\n\t\tget_orlov_stats(sb, grp, flex_size, &stats);\n\t\tif (stats.used_dirs >= max_dirs)\n\t\t\tcontinue;\n\t\tif (stats.free_inodes < min_inodes)\n\t\t\tcontinue;\n\t\tif (stats.free_clusters < min_clusters)\n\t\t\tcontinue;\n\t\tgoto found_flex_bg;\n\t}\n\nfallback:\n\tngroups = real_ngroups;\n\tavefreei = freei / ngroups;\nfallback_retry:\n\tparent_group = EXT4_I(parent)->i_block_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgrp = (parent_group + i) % ngroups;\n\t\tdesc = ext4_get_group_desc(sb, grp, NULL);\n\t\tif (desc) {\n\t\t\tgrp_free = ext4_free_inodes_count(sb, desc);\n\t\t\tif (grp_free && grp_free >= avefreei) {\n\t\t\t\t*group = grp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avefreei) {\n\t\t \n\t\tavefreei = 0;\n\t\tgoto fallback_retry;\n\t}\n\n\treturn -1;\n}\n\nstatic int find_group_other(struct super_block *sb, struct inode *parent,\n\t\t\t    ext4_group_t *group, umode_t mode)\n{\n\text4_group_t parent_group = EXT4_I(parent)->i_block_group;\n\text4_group_t i, last, ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(sb));\n\n\t \n\tif (flex_size > 1) {\n\t\tint retry = 0;\n\n\ttry_again:\n\t\tparent_group &= ~(flex_size-1);\n\t\tlast = parent_group + flex_size;\n\t\tif (last > ngroups)\n\t\t\tlast = ngroups;\n\t\tfor  (i = parent_group; i < last; i++) {\n\t\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\t\tif (desc && ext4_free_inodes_count(sb, desc)) {\n\t\t\t\t*group = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (!retry && EXT4_I(parent)->i_last_alloc_group != ~0) {\n\t\t\tretry = 1;\n\t\t\tparent_group = EXT4_I(parent)->i_last_alloc_group;\n\t\t\tgoto try_again;\n\t\t}\n\t\t \n\t\t*group = parent_group + flex_size;\n\t\tif (*group > ngroups)\n\t\t\t*group = 0;\n\t\treturn find_group_orlov(sb, parent, group, mode, NULL);\n\t}\n\n\t \n\t*group = parent_group;\n\tdesc = ext4_get_group_desc(sb, *group, NULL);\n\tif (desc && ext4_free_inodes_count(sb, desc) &&\n\t    ext4_free_group_clusters(sb, desc))\n\t\treturn 0;\n\n\t \n\t*group = (*group + parent->i_ino) % ngroups;\n\n\t \n\tfor (i = 1; i < ngroups; i <<= 1) {\n\t\t*group += i;\n\t\tif (*group >= ngroups)\n\t\t\t*group -= ngroups;\n\t\tdesc = ext4_get_group_desc(sb, *group, NULL);\n\t\tif (desc && ext4_free_inodes_count(sb, desc) &&\n\t\t    ext4_free_group_clusters(sb, desc))\n\t\t\treturn 0;\n\t}\n\n\t \n\t*group = parent_group;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tif (++*group >= ngroups)\n\t\t\t*group = 0;\n\t\tdesc = ext4_get_group_desc(sb, *group, NULL);\n\t\tif (desc && ext4_free_inodes_count(sb, desc))\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n \n#define RECENTCY_MIN\t60\n#define RECENTCY_DIRTY\t300\n\nstatic int recently_deleted(struct super_block *sb, ext4_group_t group, int ino)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct ext4_inode\t*raw_inode;\n\tstruct buffer_head\t*bh;\n\tint inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint offset, ret = 0;\n\tint recentcy = RECENTCY_MIN;\n\tu32 dtime, now;\n\n\tgdp = ext4_get_group_desc(sb, group, NULL);\n\tif (unlikely(!gdp))\n\t\treturn 0;\n\n\tbh = sb_find_get_block(sb, ext4_inode_table(sb, gdp) +\n\t\t       (ino / inodes_per_block));\n\tif (!bh || !buffer_uptodate(bh))\n\t\t \n\t\tgoto out;\n\n\toffset = (ino % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\traw_inode = (struct ext4_inode *) (bh->b_data + offset);\n\n\t \n\tdtime = le32_to_cpu(raw_inode->i_dtime);\n\tnow = ktime_get_real_seconds();\n\tif (buffer_dirty(bh))\n\t\trecentcy += RECENTCY_DIRTY;\n\n\tif (dtime && time_before32(dtime, now) &&\n\t    time_before32(now, dtime + recentcy))\n\t\tret = 1;\nout:\n\tbrelse(bh);\n\treturn ret;\n}\n\nstatic int find_inode_bit(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct buffer_head *bitmap, unsigned long *ino)\n{\n\tbool check_recently_deleted = EXT4_SB(sb)->s_journal == NULL;\n\tunsigned long recently_deleted_ino = EXT4_INODES_PER_GROUP(sb);\n\nnext:\n\t*ino = ext4_find_next_zero_bit((unsigned long *)\n\t\t\t\t       bitmap->b_data,\n\t\t\t\t       EXT4_INODES_PER_GROUP(sb), *ino);\n\tif (*ino >= EXT4_INODES_PER_GROUP(sb))\n\t\tgoto not_found;\n\n\tif (check_recently_deleted && recently_deleted(sb, group, *ino)) {\n\t\trecently_deleted_ino = *ino;\n\t\t*ino = *ino + 1;\n\t\tif (*ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto next;\n\t\tgoto not_found;\n\t}\n\treturn 1;\nnot_found:\n\tif (recently_deleted_ino >= EXT4_INODES_PER_GROUP(sb))\n\t\treturn 0;\n\t \n\t*ino = recently_deleted_ino;\n\treturn 1;\n}\n\nint ext4_mark_inode_used(struct super_block *sb, int ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count);\n\tstruct buffer_head *inode_bitmap_bh = NULL, *group_desc_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t group;\n\tint bit;\n\tint err = -EFSCORRUPTED;\n\n\tif (ino < EXT4_FIRST_INO(sb) || ino > max_ino)\n\t\tgoto out;\n\n\tgroup = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\tif (IS_ERR(inode_bitmap_bh))\n\t\treturn PTR_ERR(inode_bitmap_bh);\n\n\tif (ext4_test_bit(bit, inode_bitmap_bh->b_data)) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\tif (!gdp || !group_desc_bh) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\text4_set_bit(bit, inode_bitmap_bh->b_data);\n\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(NULL, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\terr = sync_dirty_buffer(inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(NULL, NULL, block_bitmap_bh);\n\t\tsync_dirty_buffer(block_bitmap_bh);\n\n\t\t \n\t\text4_lock_group(sb, group);\n\t\tif (ext4_has_group_desc_csum(sb) &&\n\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, gdp, block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\n\t\text4_lock_group(sb, group);  \n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\n\t\t \n\t\tif (bit >= free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - bit - 1));\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\n\text4_unlock_group(sb, group);\n\terr = ext4_handle_dirty_metadata(NULL, NULL, group_desc_bh);\n\tsync_dirty_buffer(group_desc_bh);\nout:\n\treturn err;\n}\n\nstatic int ext4_xattr_credits_for_new_inode(struct inode *dir, mode_t mode,\n\t\t\t\t\t    bool encrypt)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tint nblocks = 0;\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tstruct posix_acl *p = get_inode_acl(dir, ACL_TYPE_DEFAULT);\n\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\tif (p) {\n\t\tint acl_size = p->a_count * sizeof(ext4_acl_entry);\n\n\t\tnblocks += (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t__ext4_xattr_set_credits(sb, NULL  ,\n\t\t\t\t\t\t NULL  , acl_size,\n\t\t\t\t\t\t true  );\n\t\tposix_acl_release(p);\n\t}\n#endif\n\n#ifdef CONFIG_SECURITY\n\t{\n\t\tint num_security_xattrs = 1;\n\n#ifdef CONFIG_INTEGRITY\n\t\tnum_security_xattrs++;\n#endif\n\t\t \n\t\tnblocks += num_security_xattrs *\n\t\t\t__ext4_xattr_set_credits(sb, NULL  ,\n\t\t\t\t\t\t NULL  , 1024,\n\t\t\t\t\t\t true  );\n\t}\n#endif\n\tif (encrypt)\n\t\tnblocks += __ext4_xattr_set_credits(sb,\n\t\t\t\t\t\t    NULL  ,\n\t\t\t\t\t\t    NULL  ,\n\t\t\t\t\t\t    FSCRYPT_SET_CONTEXT_MAX_SIZE,\n\t\t\t\t\t\t    true  );\n\treturn nblocks;\n}\n\n \nstruct inode *__ext4_new_inode(struct mnt_idmap *idmap,\n\t\t\t       handle_t *handle, struct inode *dir,\n\t\t\t       umode_t mode, const struct qstr *qstr,\n\t\t\t       __u32 goal, uid_t *owner, __u32 i_flags,\n\t\t\t       int handle_type, unsigned int line_no,\n\t\t\t       int nblocks)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *inode_bitmap_bh = NULL;\n\tstruct buffer_head *group_desc_bh;\n\text4_group_t ngroups, group = 0;\n\tunsigned long ino = 0;\n\tstruct inode *inode;\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_sb_info *sbi;\n\tint ret2, err;\n\tstruct inode *ret;\n\text4_group_t i;\n\text4_group_t flex_group;\n\tstruct ext4_group_info *grp = NULL;\n\tbool encrypt = false;\n\n\t \n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sb)))\n\t\treturn ERR_PTR(-EIO);\n\n\tngroups = ext4_get_groups_count(sb);\n\ttrace_ext4_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT4_I(inode);\n\n\t \n\tif (owner) {\n\t\tinode->i_mode = mode;\n\t\ti_uid_write(inode, owner[0]);\n\t\ti_gid_write(inode, owner[1]);\n\t} else if (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode_fsuid_set(inode, idmap);\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(idmap, inode, dir, mode);\n\n\tif (ext4_has_feature_project(sb) &&\n\t    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))\n\t\tei->i_projid = EXT4_I(dir)->i_projid;\n\telse\n\t\tei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);\n\n\tif (!(i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = fscrypt_prepare_new_inode(dir, inode, &encrypt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {\n\t\tret2 = ext4_xattr_credits_for_new_inode(dir, mode, encrypt);\n\t\tif (ret2 < 0) {\n\t\t\terr = ret2;\n\t\t\tgoto out;\n\t\t}\n\t\tnblocks += ret2;\n\t}\n\n\tif (!goal)\n\t\tgoal = sbi->s_inode_goal;\n\n\tif (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {\n\t\tgroup = (goal - 1) / EXT4_INODES_PER_GROUP(sb);\n\t\tino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);\n\t\tret2 = 0;\n\t\tgoto got_group;\n\t}\n\n\tif (S_ISDIR(mode))\n\t\tret2 = find_group_orlov(sb, dir, &group, mode, qstr);\n\telse\n\t\tret2 = find_group_other(sb, dir, &group, mode);\n\ngot_group:\n\tEXT4_I(dir)->i_last_alloc_group = group;\n\terr = -ENOSPC;\n\tif (ret2 == -1)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < ngroups; i++, ino = 0) {\n\t\terr = -EIO;\n\n\t\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\t\tif (!gdp)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (ext4_free_inodes_count(sb, gdp) == 0)\n\t\t\tgoto next_group;\n\n\t\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY)) {\n\t\t\tgrp = ext4_get_group_info(sb, group);\n\t\t\t \n\t\t\tif (!grp || EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\t\t\tgoto next_group;\n\t\t}\n\n\t\tbrelse(inode_bitmap_bh);\n\t\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\t\t \n\t\tif (((!(sbi->s_mount_state & EXT4_FC_REPLAY))\n\t\t     && EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) ||\n\t\t    IS_ERR(inode_bitmap_bh)) {\n\t\t\tinode_bitmap_bh = NULL;\n\t\t\tgoto next_group;\n\t\t}\n\nrepeat_in_this_group:\n\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\tif (!ret2)\n\t\t\tgoto next_group;\n\n\t\tif (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {\n\t\t\text4_error(sb, \"reserved inode found cleared - \"\n\t\t\t\t   \"inode=%lu\", ino + 1);\n\t\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\t\tgoto next_group;\n\t\t}\n\n\t\tif ((!(sbi->s_mount_state & EXT4_FC_REPLAY)) && !handle) {\n\t\t\tBUG_ON(nblocks <= 0);\n\t\t\thandle = __ext4_journal_start_sb(NULL, dir->i_sb,\n\t\t\t\t line_no, handle_type, nblocks, 0,\n\t\t\t\t ext4_trans_default_revoke_credits(sb));\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terr = PTR_ERR(handle);\n\t\t\t\text4_std_error(sb, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUFFER_TRACE(inode_bitmap_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sb, inode_bitmap_bh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);\n\t\tif (ret2) {\n\t\t\t \n\t\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\t\tif (ret2) {\n\t\t\t\text4_set_bit(ino, inode_bitmap_bh->b_data);\n\t\t\t\tret2 = 0;\n\t\t\t} else {\n\t\t\t\tret2 = 1;  \n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tino++;\t\t \n\t\tif (!ret2)\n\t\t\tgoto got;  \n\n\t\tif (ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto repeat_in_this_group;\nnext_group:\n\t\tif (++group == ngroups)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sb, group_desc_bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\t\tBUFFER_TRACE(block_bitmap_bh, \"get block bitmap access\");\n\t\terr = ext4_journal_get_write_access(handle, sb, block_bitmap_bh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err) {\n\t\t\tbrelse(block_bitmap_bh);\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);\n\n\t\t \n\t\text4_lock_group(sb, group);\n\t\tif (ext4_has_group_desc_csum(sb) &&\n\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, gdp, block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\t\tstruct ext4_group_info *grp = NULL;\n\n\t\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY)) {\n\t\t\tgrp = ext4_get_group_info(sb, group);\n\t\t\tif (!grp) {\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdown_read(&grp->alloc_sem);  \n\t\t}\n\t\text4_lock_group(sb, group);  \n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\t\t \n\t\tif (ino > free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - ino));\n\t\tif (!(sbi->s_mount_state & EXT4_FC_REPLAY))\n\t\t\tup_read(&grp->alloc_sem);\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (S_ISDIR(mode)) {\n\t\text4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t f = ext4_flex_group(sbi, group);\n\n\t\t\tatomic_inc(&sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\t\tf)->used_dirs);\n\t\t}\n\t}\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\tflex_group = ext4_flex_group(sbi, group);\n\t\tatomic_dec(&sbi_array_rcu_deref(sbi, s_flex_groups,\n\t\t\t\t\t\tflex_group)->free_inodes);\n\t}\n\n\tinode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);\n\t \n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tei->i_crtime = inode->i_mtime;\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\t \n\tei->i_flags =\n\t\text4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);\n\tei->i_flags |= i_flags;\n\tei->i_file_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_group = group;\n\tei->i_last_alloc_group = ~0;\n\n\text4_set_inode_flags(inode, true);\n\tif (IS_DIRSYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (insert_inode_locked(inode) < 0) {\n\t\t \n\t\terr = -EIO;\n\t\text4_error(sb, \"failed to insert inode %lu: doubly allocated?\",\n\t\t\t   inode->i_ino);\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\tgoto out;\n\t}\n\tinode->i_generation = get_random_u32();\n\n\t \n\tif (ext4_has_metadata_csum(sb)) {\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\text4_clear_state_flags(ei);  \n\text4_set_inode_state(inode, EXT4_STATE_NEW);\n\n\tei->i_extra_isize = sbi->s_want_extra_isize;\n\tei->i_inline_off = 0;\n\tif (ext4_has_feature_inline_data(sb) &&\n\t    (!(ei->i_flags & EXT4_DAX_FL) || S_ISDIR(mode)))\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tret = inode;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\t \n\tif (encrypt) {\n\t\terr = fscrypt_set_context(inode, handle);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (!(ei->i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = ext4_init_acl(handle, inode, dir);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\n\t\terr = ext4_init_security(handle, inode, dir, qstr);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (ext4_has_feature_extents(sb)) {\n\t\t \n\t\tif (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text4_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_allocate_inode(inode, dir, mode);\n\tbrelse(inode_bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\nfail_drop:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nout:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\tbrelse(inode_bitmap_bh);\n\treturn ERR_PTR(err);\n}\n\n \nstruct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)\n{\n\tunsigned long max_ino = le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count);\n\text4_group_t block_group;\n\tint bit;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct inode *inode = NULL;\n\tint err = -EFSCORRUPTED;\n\n\tif (ino < EXT4_FIRST_INO(sb) || ino > max_ino)\n\t\tgoto bad_orphan;\n\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\tif (IS_ERR(bitmap_bh))\n\t\treturn ERR_CAST(bitmap_bh);\n\n\t \n\tif (!ext4_test_bit(bit, bitmap_bh->b_data))\n\t\tgoto bad_orphan;\n\n\tinode = ext4_iget(sb, ino, EXT4_IGET_NORMAL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\text4_error_err(sb, -err,\n\t\t\t       \"couldn't read orphan inode %lu (err %d)\",\n\t\t\t       ino, err);\n\t\tbrelse(bitmap_bh);\n\t\treturn inode;\n\t}\n\n\t \n\tif ((inode->i_nlink && !ext4_can_truncate(inode)) ||\n\t    is_bad_inode(inode))\n\t\tgoto bad_orphan;\n\n\tif (NEXT_ORPHAN(inode) > max_ino)\n\t\tgoto bad_orphan;\n\tbrelse(bitmap_bh);\n\treturn inode;\n\nbad_orphan:\n\text4_error(sb, \"bad orphan inode %lu\", ino);\n\tif (bitmap_bh)\n\t\tprintk(KERN_ERR \"ext4_test_bit(bit=%d, block=%llu) = %d\\n\",\n\t\t       bit, (unsigned long long)bitmap_bh->b_blocknr,\n\t\t       ext4_test_bit(bit, bitmap_bh->b_data));\n\tif (inode) {\n\t\tprintk(KERN_ERR \"is_bad_inode(inode)=%d\\n\",\n\t\t       is_bad_inode(inode));\n\t\tprintk(KERN_ERR \"NEXT_ORPHAN(inode)=%u\\n\",\n\t\t       NEXT_ORPHAN(inode));\n\t\tprintk(KERN_ERR \"max_ino=%lu\\n\", max_ino);\n\t\tprintk(KERN_ERR \"i_nlink=%u\\n\", inode->i_nlink);\n\t\t \n\t\tif (inode->i_nlink == 0)\n\t\t\tinode->i_blocks = 0;\n\t\tiput(inode);\n\t}\n\tbrelse(bitmap_bh);\n\treturn ERR_PTR(err);\n}\n\nunsigned long ext4_count_free_inodes(struct super_block *sb)\n{\n\tunsigned long desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\tunsigned long bitmap_count, x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_inode_bitmap(sb, i);\n\t\tif (IS_ERR(bitmap_bh)) {\n\t\t\tbitmap_bh = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %lu: stored = %d, counted = %lu\\n\",\n\t\t\t(unsigned long) i, ext4_free_inodes_count(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_inodes: \"\n\t       \"stored = %u, computed = %lu, %lu\\n\",\n\t       le32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += ext4_free_inodes_count(sb, gdp);\n\t\tcond_resched();\n\t}\n\treturn desc_count;\n#endif\n}\n\n \nunsigned long ext4_count_dirs(struct super_block * sb)\n{\n\tunsigned long count = 0;\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += ext4_used_dirs_count(sb, gdp);\n\t}\n\treturn count;\n}\n\n \nint ext4_init_inode_table(struct super_block *sb, ext4_group_t group,\n\t\t\t\t int barrier)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct buffer_head *group_desc_bh;\n\thandle_t *handle;\n\text4_fsblk_t blk;\n\tint num, ret = 0, used_blks = 0;\n\tunsigned long used_inos = 0;\n\n\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\tif (!gdp || !grp)\n\t\tgoto out;\n\n\t \n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))\n\t\tgoto out;\n\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tdown_write(&grp->alloc_sem);\n\t \n\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {\n\t\tused_inos = EXT4_INODES_PER_GROUP(sb) -\n\t\t\t    ext4_itable_unused_count(sb, gdp);\n\t\tused_blks = DIV_ROUND_UP(used_inos, sbi->s_inodes_per_block);\n\n\t\t \n\t\tif (used_blks < 0 || used_blks > sbi->s_itb_per_group) {\n\t\t\text4_error(sb, \"Something is wrong with group %u: \"\n\t\t\t\t   \"used itable blocks: %d; \"\n\t\t\t\t   \"itable unused count: %u\",\n\t\t\t\t   group, used_blks,\n\t\t\t\t   ext4_itable_unused_count(sb, gdp));\n\t\t\tret = 1;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tused_inos += group * EXT4_INODES_PER_GROUP(sb);\n\t\t \n\t\tif ((used_blks != sbi->s_itb_per_group) &&\n\t\t     (used_inos < EXT4_FIRST_INO(sb))) {\n\t\t\text4_error(sb, \"Something is wrong with group %u: \"\n\t\t\t\t   \"itable unused count: %u; \"\n\t\t\t\t   \"itables initialized count: %ld\",\n\t\t\t\t   group, ext4_itable_unused_count(sb, gdp),\n\t\t\t\t   used_inos);\n\t\t\tret = 1;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tblk = ext4_inode_table(sb, gdp) + used_blks;\n\tnum = sbi->s_itb_per_group - used_blks;\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\tret = ext4_journal_get_write_access(handle, sb, group_desc_bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tif (unlikely(num == 0))\n\t\tgoto skip_zeroout;\n\n\text4_debug(\"going to zero out inode table in group %d\\n\",\n\t\t   group);\n\tret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tif (barrier)\n\t\tblkdev_issue_flush(sb->s_bdev);\n\nskip_zeroout:\n\text4_lock_group(sb, group);\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\text4_group_desc_csum_set(sb, group, gdp);\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh,\n\t\t     \"call ext4_handle_dirty_metadata\");\n\tret = ext4_handle_dirty_metadata(handle, NULL,\n\t\t\t\t\t group_desc_bh);\n\nerr_out:\n\tup_write(&grp->alloc_sem);\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}