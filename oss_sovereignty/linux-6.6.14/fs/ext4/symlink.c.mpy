{
  "module_name": "symlink.c",
  "hash_id": "97c800373ddd51a8701c5e5c6440b3709028233626870636693c5fd58a94f0a8",
  "original_prompt": "Ingested from linux-6.6.14/fs/ext4/symlink.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include \"ext4.h\"\n#include \"xattr.h\"\n\nstatic const char *ext4_encrypted_get_link(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct delayed_call *done)\n{\n\tstruct buffer_head *bh = NULL;\n\tconst void *caddr;\n\tunsigned int max_size;\n\tconst char *paddr;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tif (ext4_inode_is_fast_symlink(inode)) {\n\t\tcaddr = EXT4_I(inode)->i_data;\n\t\tmax_size = sizeof(EXT4_I(inode)->i_data);\n\t} else {\n\t\tbh = ext4_bread(NULL, inode, 0, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn ERR_CAST(bh);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad symlink.\");\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t\tcaddr = bh->b_data;\n\t\tmax_size = inode->i_sb->s_blocksize;\n\t}\n\n\tpaddr = fscrypt_get_symlink(inode, caddr, max_size, done);\n\tbrelse(bh);\n\treturn paddr;\n}\n\nstatic int ext4_encrypted_symlink_getattr(struct mnt_idmap *idmap,\n\t\t\t\t\t  const struct path *path,\n\t\t\t\t\t  struct kstat *stat, u32 request_mask,\n\t\t\t\t\t  unsigned int query_flags)\n{\n\text4_getattr(idmap, path, stat, request_mask, query_flags);\n\n\treturn fscrypt_symlink_getattr(path, stat);\n}\n\nstatic void ext4_free_link(void *bh)\n{\n\tbrelse(bh);\n}\n\nstatic const char *ext4_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t struct delayed_call *callback)\n{\n\tstruct buffer_head *bh;\n\tchar *inline_link;\n\n\t \n\tif (ext4_has_inline_data(inode)) {\n\t\tif (!dentry)\n\t\t\treturn ERR_PTR(-ECHILD);\n\n\t\tinline_link = ext4_read_inline_link(inode);\n\t\tif (!IS_ERR(inline_link))\n\t\t\tset_delayed_call(callback, kfree_link, inline_link);\n\t\treturn inline_link;\n\t}\n\n\tif (!dentry) {\n\t\tbh = ext4_getblk(NULL, inode, 0, EXT4_GET_BLOCKS_CACHED_NOWAIT);\n\t\tif (IS_ERR(bh))\n\t\t\treturn ERR_CAST(bh);\n\t\tif (!bh || !ext4_buffer_uptodate(bh))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t} else {\n\t\tbh = ext4_bread(NULL, inode, 0, 0);\n\t\tif (IS_ERR(bh))\n\t\t\treturn ERR_CAST(bh);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad symlink.\");\n\t\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t\t}\n\t}\n\n\tset_delayed_call(callback, ext4_free_link, bh);\n\tnd_terminate_link(bh->b_data, inode->i_size,\n\t\t\t  inode->i_sb->s_blocksize - 1);\n\treturn bh->b_data;\n}\n\nconst struct inode_operations ext4_encrypted_symlink_inode_operations = {\n\t.get_link\t= ext4_encrypted_get_link,\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_encrypted_symlink_getattr,\n\t.listxattr\t= ext4_listxattr,\n};\n\nconst struct inode_operations ext4_symlink_inode_operations = {\n\t.get_link\t= ext4_get_link,\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n};\n\nconst struct inode_operations ext4_fast_symlink_inode_operations = {\n\t.get_link\t= simple_get_link,\n\t.setattr\t= ext4_setattr,\n\t.getattr\t= ext4_getattr,\n\t.listxattr\t= ext4_listxattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}