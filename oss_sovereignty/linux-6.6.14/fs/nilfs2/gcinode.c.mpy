{
  "module_name": "gcinode.c",
  "hash_id": "5edb02483548328f07532e535e83e54e8c1b44097fac523102c6c80fd0e085bd",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/gcinode.c",
  "human_readable_source": "\n \n \n\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include \"nilfs.h\"\n#include \"btree.h\"\n#include \"btnode.h\"\n#include \"page.h\"\n#include \"mdt.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n\n \nint nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\n\t\t\t\t   sector_t pbn, __u64 vbn,\n\t\t\t\t   struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (pbn == 0) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\terr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\n\t\tif (unlikely(err))  \n\t\t\tgoto failed;\n\t}\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tbh->b_bdev = inode->i_sb->s_bdev;\n\t\tset_buffer_mapped(bh);\n\t}\n\tbh->b_blocknr = pbn;\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, bh);\n\tif (vbn)\n\t\tbh->b_blocknr = vbn;\n out:\n\terr = 0;\n\t*out_bh = bh;\n\n failed:\n\tunlock_page(bh->b_page);\n\tput_page(bh->b_page);\n\tif (unlikely(err))\n\t\tbrelse(bh);\n\treturn err;\n}\n\n \nint nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\n\t\t\t\t   __u64 vbn, struct buffer_head **out_bh)\n{\n\tstruct inode *btnc_inode = NILFS_I(inode)->i_assoc_inode;\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(btnc_inode->i_mapping, vbn ? : pbn, pbn,\n\t\t\t\t\tREQ_OP_READ, out_bh, &pbn);\n\tif (ret == -EEXIST)  \n\t\tret = 0;\n\treturn ret;\n}\n\nint nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\n{\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct inode *inode = bh->b_folio->mapping->host;\n\n\t\tnilfs_err(inode->i_sb,\n\t\t\t  \"I/O error reading %s block for GC (ino=%lu, vblocknr=%llu)\",\n\t\t\t  buffer_nilfs_node(bh) ? \"node\" : \"data\",\n\t\t\t  inode->i_ino, (unsigned long long)bh->b_blocknr);\n\t\treturn -EIO;\n\t}\n\tif (buffer_dirty(bh))\n\t\treturn -EEXIST;\n\n\tif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\treturn -EIO;\n\t}\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}\n\nint nilfs_init_gcinode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\tinode->i_mapping->a_ops = &empty_aops;\n\n\tii->i_flags = 0;\n\tnilfs_bmap_init_gc(ii->i_bmap);\n\n\treturn nilfs_attach_btree_node_cache(inode);\n}\n\n \nvoid nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\n{\n\tstruct list_head *head = &nilfs->ns_gc_inodes;\n\tstruct nilfs_inode_info *ii;\n\n\twhile (!list_empty(head)) {\n\t\tii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(ii->i_assoc_inode->i_mapping);\n\t\tiput(&ii->vfs_inode);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}