{
  "module_name": "inode.c",
  "hash_id": "1755a4a4d9b4115d60b293f9b985ae54d00a7e0a86463391bd17674e7a0edc42",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/inode.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/gfp.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/fiemap.h>\n#include \"nilfs.h\"\n#include \"btnode.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"mdt.h\"\n#include \"cpfile.h\"\n#include \"ifile.h\"\n\n \nstruct nilfs_iget_args {\n\tu64 ino;\n\t__u64 cno;\n\tstruct nilfs_root *root;\n\tbool for_gc;\n\tbool for_btnc;\n\tbool for_shadow;\n};\n\nstatic int nilfs_iget_test(struct inode *inode, void *opaque);\n\nvoid nilfs_inode_add_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_add_bytes(inode, i_blocksize(inode) * n);\n\tif (root)\n\t\tatomic64_add(n, &root->blocks_count);\n}\n\nvoid nilfs_inode_sub_blocks(struct inode *inode, int n)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tinode_sub_bytes(inode, i_blocksize(inode) * n);\n\tif (root)\n\t\tatomic64_sub(n, &root->blocks_count);\n}\n\n \nint nilfs_get_block(struct inode *inode, sector_t blkoff,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 blknum = 0;\n\tint err = 0, ret;\n\tunsigned int maxblocks = bh_result->b_size >> inode->i_blkbits;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tret = nilfs_bmap_lookup_contig(ii->i_bmap, blkoff, &blknum, maxblocks);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tif (ret >= 0) {\t \n\t\tmap_bh(bh_result, inode->i_sb, blknum);\n\t\tif (ret > 0)\n\t\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tgoto out;\n\t}\n\t \n\tif (ret == -ENOENT && create) {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tbh_result->b_blocknr = 0;\n\t\terr = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\terr = nilfs_bmap_insert(ii->i_bmap, blkoff,\n\t\t\t\t\t(unsigned long)bh_result);\n\t\tif (unlikely(err != 0)) {\n\t\t\tif (err == -EEXIST) {\n\t\t\t\t \n\t\t\t\tnilfs_warn(inode->i_sb,\n\t\t\t\t\t   \"%s (ino=%lu): a race condition while inserting a data block at offset=%llu\",\n\t\t\t\t\t   __func__, inode->i_ino,\n\t\t\t\t\t   (unsigned long long)blkoff);\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tnilfs_transaction_abort(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\t\tnilfs_mark_inode_dirty_sync(inode);\n\t\tnilfs_transaction_commit(inode->i_sb);  \n\t\t \n\t\tset_buffer_new(bh_result);\n\t\tset_buffer_delay(bh_result);\n\t\tmap_bh(bh_result, inode->i_sb, 0);\n\t\t \n\n\t} else if (ret == -ENOENT) {\n\t\t \n\t\t;\n\t} else {\n\t\terr = ret;\n\t}\n\n out:\n\treturn err;\n}\n\n \nstatic int nilfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn mpage_read_folio(folio, nilfs_get_block);\n}\n\nstatic void nilfs_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, nilfs_get_block);\n}\n\nstatic int nilfs_writepages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tint err = 0;\n\n\tif (sb_rdonly(inode->i_sb)) {\n\t\tnilfs_clear_dirty_pages(mapping, false);\n\t\treturn -EROFS;\n\t}\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t    wbc->range_start,\n\t\t\t\t\t\t    wbc->range_end);\n\treturn err;\n}\n\nstatic int nilfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\tif (sb_rdonly(inode->i_sb)) {\n\t\t \n\t\tnilfs_clear_dirty_page(page, false);\n\t\tunlock_page(page);\n\t\treturn -EROFS;\n\t}\n\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\n\tif (wbc->sync_mode == WB_SYNC_ALL) {\n\t\terr = nilfs_construct_segment(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t} else if (wbc->for_reclaim)\n\t\tnilfs_flush_segment(inode->i_sb, inode->i_ino);\n\n\treturn 0;\n}\n\nstatic bool nilfs_dirty_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *head;\n\tunsigned int nr_dirty = 0;\n\tbool ret = filemap_dirty_folio(mapping, folio);\n\n\t \n\tspin_lock(&mapping->private_lock);\n\thead = folio_buffers(folio);\n\tif (head) {\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\t \n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t} else if (ret) {\n\t\tnr_dirty = 1 << (folio_shift(folio) - inode->i_blkbits);\n\t}\n\tspin_unlock(&mapping->private_lock);\n\n\tif (nr_dirty)\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\treturn ret;\n}\n\nvoid nilfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tnilfs_truncate(inode);\n\t}\n}\n\nstatic int nilfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len,\n\t\t\t     struct page **pagep, void **fsdata)\n\n{\n\tstruct inode *inode = mapping->host;\n\tint err = nilfs_transaction_begin(inode->i_sb, NULL, 1);\n\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = block_write_begin(mapping, pos, len, pagep, nilfs_get_block);\n\tif (unlikely(err)) {\n\t\tnilfs_write_failed(mapping, pos + len);\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t}\n\treturn err;\n}\n\nstatic int nilfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int start = pos & (PAGE_SIZE - 1);\n\tunsigned int nr_dirty;\n\tint err;\n\n\tnr_dirty = nilfs_page_count_clean_buffers(page, start,\n\t\t\t\t\t\t  start + copied);\n\tcopied = generic_write_end(file, mapping, pos, len, copied, page,\n\t\t\t\t   fsdata);\n\tnilfs_set_file_dirty(inode, nr_dirty);\n\terr = nilfs_transaction_commit(inode->i_sb);\n\treturn err ? : copied;\n}\n\nstatic ssize_t\nnilfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\treturn 0;\n\n\t \n\treturn blockdev_direct_IO(iocb, inode, iter, nilfs_get_block);\n}\n\nconst struct address_space_operations nilfs_aops = {\n\t.writepage\t\t= nilfs_writepage,\n\t.read_folio\t\t= nilfs_read_folio,\n\t.writepages\t\t= nilfs_writepages,\n\t.dirty_folio\t\t= nilfs_dirty_folio,\n\t.readahead\t\t= nilfs_readahead,\n\t.write_begin\t\t= nilfs_write_begin,\n\t.write_end\t\t= nilfs_write_end,\n\t.invalidate_folio\t= block_invalidate_folio,\n\t.direct_IO\t\t= nilfs_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n};\n\nstatic int nilfs_insert_inode_locked(struct inode *inode,\n\t\t\t\t     struct nilfs_root *root,\n\t\t\t\t     unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = false,\n\t\t.for_btnc = false, .for_shadow = false\n\t};\n\n\treturn insert_inode_locked4(inode, ino, nilfs_iget_test, &args);\n}\n\nstruct inode *nilfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_root *root;\n\tstruct buffer_head *bh;\n\tint err = -ENOMEM;\n\tino_t ino;\n\n\tinode = new_inode(sb);\n\tif (unlikely(!inode))\n\t\tgoto failed;\n\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t   mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));\n\n\troot = NILFS_I(dir)->i_root;\n\tii = NILFS_I(inode);\n\tii->i_state = BIT(NILFS_I_NEW);\n\tii->i_root = root;\n\n\terr = nilfs_ifile_create_inode(root->ifile, &ino, &bh);\n\tif (unlikely(err))\n\t\tgoto failed_ifile_create_inode;\n\t \n\n\tif (unlikely(ino < NILFS_USER_INO)) {\n\t\tnilfs_warn(sb,\n\t\t\t   \"inode bitmap is inconsistent for reserved inodes\");\n\t\tdo {\n\t\t\tbrelse(bh);\n\t\t\terr = nilfs_ifile_create_inode(root->ifile, &ino, &bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_ifile_create_inode;\n\t\t} while (ino < NILFS_USER_INO);\n\n\t\tnilfs_info(sb, \"repaired inode bitmap for reserved inodes\");\n\t}\n\tii->i_bh = bh;\n\n\tatomic64_inc(&root->inodes_count);\n\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\tinode->i_ino = ino;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, NULL);\n\t\tif (err < 0)\n\t\t\tgoto failed_after_creation;\n\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t \n\t}\n\n\tii->i_flags = nilfs_mask_flags(\n\t\tmode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);\n\n\t \n\t \n\tii->i_dir_start_lookup = 0;\n\tnilfs_set_inode_flags(inode);\n\tspin_lock(&nilfs->ns_next_gen_lock);\n\tinode->i_generation = nilfs->ns_next_generation++;\n\tspin_unlock(&nilfs->ns_next_gen_lock);\n\tif (nilfs_insert_inode_locked(inode, root, ino) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed_after_creation;\n\t}\n\n\terr = nilfs_init_acl(inode, dir);\n\tif (unlikely(err))\n\t\t \n\t\tgoto failed_after_creation;\n\n\treturn inode;\n\n failed_after_creation:\n\tclear_nlink(inode);\n\tif (inode->i_state & I_NEW)\n\t\tunlock_new_inode(inode);\n\tiput(inode);   \n\tgoto failed;\n\n failed_ifile_create_inode:\n\tmake_bad_inode(inode);\n\tiput(inode);\n failed:\n\treturn ERR_PTR(err);\n}\n\nvoid nilfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = NILFS_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & FS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tinode_set_flags(inode, new_fl, S_SYNC | S_APPEND | S_IMMUTABLE |\n\t\t\tS_NOATIME | S_DIRSYNC);\n}\n\nint nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode_set_ctime(inode, le64_to_cpu(raw_inode->i_ctime),\n\t\t\tle32_to_cpu(raw_inode->i_ctime_nsec));\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (nilfs_is_metadata_file_inode(inode) && !S_ISREG(inode->i_mode))\n\t\treturn -EIO;  \n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE;  \n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic int __nilfs_read_inode(struct super_block *sb,\n\t\t\t      struct nilfs_root *root, unsigned long ino,\n\t\t\t      struct inode *inode)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *bh;\n\tstruct nilfs_inode *raw_inode;\n\tint err;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\terr = nilfs_ifile_get_inode_block(root->ifile, ino, &bh);\n\tif (unlikely(err))\n\t\tgoto bad_inode;\n\n\traw_inode = nilfs_ifile_map_inode(root->ifile, ino, bh);\n\n\terr = nilfs_read_inode_common(inode, raw_inode);\n\tif (err)\n\t\tgoto failed_unmap;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_dir_inode_operations;\n\t\tinode->i_fop = &nilfs_dir_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &nilfs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t} else {\n\t\tinode->i_op = &nilfs_special_inode_operations;\n\t\tinit_special_inode(\n\t\t\tinode, inode->i_mode,\n\t\t\thuge_decode_dev(le64_to_cpu(raw_inode->i_device_code)));\n\t}\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tnilfs_set_inode_flags(inode);\n\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\t   mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));\n\treturn 0;\n\n failed_unmap:\n\tnilfs_ifile_unmap_inode(root->ifile, ino, bh);\n\tbrelse(bh);\n\n bad_inode:\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\treturn err;\n}\n\nstatic int nilfs_iget_test(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\tstruct nilfs_inode_info *ii;\n\n\tif (args->ino != inode->i_ino || args->root != NILFS_I(inode)->i_root)\n\t\treturn 0;\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_BTNC, &ii->i_state)) {\n\t\tif (!args->for_btnc)\n\t\t\treturn 0;\n\t} else if (args->for_btnc) {\n\t\treturn 0;\n\t}\n\tif (test_bit(NILFS_I_SHADOW, &ii->i_state)) {\n\t\tif (!args->for_shadow)\n\t\t\treturn 0;\n\t} else if (args->for_shadow) {\n\t\treturn 0;\n\t}\n\n\tif (!test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\treturn !args->for_gc;\n\n\treturn args->for_gc && args->cno == ii->i_cno;\n}\n\nstatic int nilfs_iget_set(struct inode *inode, void *opaque)\n{\n\tstruct nilfs_iget_args *args = opaque;\n\n\tinode->i_ino = args->ino;\n\tNILFS_I(inode)->i_cno = args->cno;\n\tNILFS_I(inode)->i_root = args->root;\n\tif (args->root && args->ino == NILFS_ROOT_INO)\n\t\tnilfs_get_root(args->root);\n\n\tif (args->for_gc)\n\t\tNILFS_I(inode)->i_state = BIT(NILFS_I_GCINODE);\n\tif (args->for_btnc)\n\t\tNILFS_I(inode)->i_state |= BIT(NILFS_I_BTNC);\n\tif (args->for_shadow)\n\t\tNILFS_I(inode)->i_state |= BIT(NILFS_I_SHADOW);\n\treturn 0;\n}\n\nstruct inode *nilfs_ilookup(struct super_block *sb, struct nilfs_root *root,\n\t\t\t    unsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = false,\n\t\t.for_btnc = false, .for_shadow = false\n\t};\n\n\treturn ilookup5(sb, ino, nilfs_iget_test, &args);\n}\n\nstruct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = false,\n\t\t.for_btnc = false, .for_shadow = false\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}\n\nstruct inode *nilfs_iget(struct super_block *sb, struct nilfs_root *root,\n\t\t\t unsigned long ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = nilfs_iget_locked(sb, root, ino);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = __nilfs_read_inode(sb, root, ino, inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\nstruct inode *nilfs_iget_for_gc(struct super_block *sb, unsigned long ino,\n\t\t\t\t__u64 cno)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = NULL, .cno = cno, .for_gc = true,\n\t\t.for_btnc = false, .for_shadow = false\n\t};\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = nilfs_init_gcinode(inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}\n\n \nint nilfs_attach_btree_node_cache(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *btnc_inode;\n\tstruct nilfs_iget_args args;\n\n\tif (ii->i_assoc_inode)\n\t\treturn 0;\n\n\targs.ino = inode->i_ino;\n\targs.root = ii->i_root;\n\targs.cno = ii->i_cno;\n\targs.for_gc = test_bit(NILFS_I_GCINODE, &ii->i_state) != 0;\n\targs.for_btnc = true;\n\targs.for_shadow = test_bit(NILFS_I_SHADOW, &ii->i_state) != 0;\n\n\tbtnc_inode = iget5_locked(inode->i_sb, inode->i_ino, nilfs_iget_test,\n\t\t\t\t  nilfs_iget_set, &args);\n\tif (unlikely(!btnc_inode))\n\t\treturn -ENOMEM;\n\tif (btnc_inode->i_state & I_NEW) {\n\t\tnilfs_init_btnc_inode(btnc_inode);\n\t\tunlock_new_inode(btnc_inode);\n\t}\n\tNILFS_I(btnc_inode)->i_assoc_inode = inode;\n\tNILFS_I(btnc_inode)->i_bmap = ii->i_bmap;\n\tii->i_assoc_inode = btnc_inode;\n\n\treturn 0;\n}\n\n \nvoid nilfs_detach_btree_node_cache(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *btnc_inode = ii->i_assoc_inode;\n\n\tif (btnc_inode) {\n\t\tNILFS_I(btnc_inode)->i_assoc_inode = NULL;\n\t\tii->i_assoc_inode = NULL;\n\t\tiput(btnc_inode);\n\t}\n}\n\n \nstruct inode *nilfs_iget_for_shadow(struct inode *inode)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = inode->i_ino, .root = NULL, .cno = 0, .for_gc = false,\n\t\t.for_btnc = false, .for_shadow = true\n\t};\n\tstruct inode *s_inode;\n\tint err;\n\n\ts_inode = iget5_locked(inode->i_sb, inode->i_ino, nilfs_iget_test,\n\t\t\t       nilfs_iget_set, &args);\n\tif (unlikely(!s_inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(s_inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tNILFS_I(s_inode)->i_flags = 0;\n\tmemset(NILFS_I(s_inode)->i_bmap, 0, sizeof(struct nilfs_bmap));\n\tmapping_set_gfp_mask(s_inode->i_mapping, GFP_NOFS);\n\n\terr = nilfs_attach_btree_node_cache(s_inode);\n\tif (unlikely(err)) {\n\t\tiget_failed(s_inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(s_inode);\n\treturn s_inode;\n}\n\nvoid nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode_get_ctime(inode).tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode_get_ctime(inode).tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t \n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t \n}\n\nvoid nilfs_update_inode(struct inode *inode, struct buffer_head *ibh, int flags)\n{\n\tino_t ino = inode->i_ino;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct inode *ifile = ii->i_root->ifile;\n\tstruct nilfs_inode *raw_inode;\n\n\traw_inode = nilfs_ifile_map_inode(ifile, ino, ibh);\n\n\tif (test_and_clear_bit(NILFS_I_NEW, &ii->i_state))\n\t\tmemset(raw_inode, 0, NILFS_MDT(ifile)->mi_entry_size);\n\tif (flags & I_DIRTY_DATASYNC)\n\t\tset_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\n\tnilfs_write_inode_common(inode, raw_inode, 0);\n\t\t \n\n\tnilfs_ifile_unmap_inode(ifile, ino, ibh);\n}\n\n#define NILFS_MAX_TRUNCATE_BLOCKS\t16384   \n\nstatic void nilfs_truncate_bmap(struct nilfs_inode_info *ii,\n\t\t\t\tunsigned long from)\n{\n\t__u64 b;\n\tint ret;\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\nrepeat:\n\tret = nilfs_bmap_last_key(ii->i_bmap, &b);\n\tif (ret == -ENOENT)\n\t\treturn;\n\telse if (ret < 0)\n\t\tgoto failed;\n\n\tif (b < from)\n\t\treturn;\n\n\tb -= min_t(__u64, NILFS_MAX_TRUNCATE_BLOCKS, b - from);\n\tret = nilfs_bmap_truncate(ii->i_bmap, b);\n\tnilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);\n\tif (!ret || (ret == -ENOMEM &&\n\t\t     nilfs_bmap_truncate(ii->i_bmap, b) == 0))\n\t\tgoto repeat;\n\nfailed:\n\tnilfs_warn(ii->vfs_inode.i_sb, \"error %d truncating bmap (ino=%lu)\",\n\t\t   ret, ii->vfs_inode.i_ino);\n}\n\nvoid nilfs_truncate(struct inode *inode)\n{\n\tunsigned long blkoff;\n\tunsigned int blocksize;\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (!test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\treturn;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn;\n\n\tblocksize = sb->s_blocksize;\n\tblkoff = (inode->i_size + blocksize - 1) >> sb->s_blocksize_bits;\n\tnilfs_transaction_begin(sb, &ti, 0);  \n\n\tblock_truncate_page(inode->i_mapping, inode->i_size, nilfs_get_block);\n\n\tnilfs_truncate_bmap(ii, blkoff);\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tnilfs_set_file_dirty(inode, 0);\n\tnilfs_transaction_commit(sb);\n\t \n}\n\nstatic void nilfs_clear_inode(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\t \n\tBUG_ON(!list_empty(&ii->i_dirty));\n\tbrelse(ii->i_bh);\n\tii->i_bh = NULL;\n\n\tif (nilfs_is_metadata_file_inode(inode))\n\t\tnilfs_mdt_clear(inode);\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state))\n\t\tnilfs_bmap_clear(ii->i_bmap);\n\n\tif (!test_bit(NILFS_I_BTNC, &ii->i_state))\n\t\tnilfs_detach_btree_node_cache(inode);\n\n\tif (ii->i_root && inode->i_ino == NILFS_ROOT_INO)\n\t\tnilfs_put_root(ii->i_root);\n}\n\nvoid nilfs_evict_inode(struct inode *inode)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs;\n\tint ret;\n\n\tif (inode->i_nlink || !ii->i_root || unlikely(is_bad_inode(inode))) {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t\tnilfs_clear_inode(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(sb, &ti, 0);  \n\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tnilfs = sb->s_fs_info;\n\tif (unlikely(sb_rdonly(sb) || !nilfs->ns_writer)) {\n\t\t \n\t\tclear_inode(inode);\n\t\tnilfs_clear_inode(inode);\n\t\tnilfs_transaction_abort(sb);\n\t\treturn;\n\t}\n\n\t \n\tnilfs_truncate_bmap(ii, 0);\n\tnilfs_mark_inode_dirty(inode);\n\tclear_inode(inode);\n\n\tret = nilfs_ifile_delete_inode(ii->i_root->ifile, inode->i_ino);\n\tif (!ret)\n\t\tatomic64_dec(&ii->i_root->inodes_count);\n\n\tnilfs_clear_inode(inode);\n\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\tnilfs_transaction_commit(sb);\n\t \n}\n\nint nilfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t  struct iattr *iattr)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = inode->i_sb;\n\tint err;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, iattr);\n\tif (err)\n\t\treturn err;\n\n\terr = nilfs_transaction_begin(sb, &ti, 0);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tnilfs_truncate(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, iattr);\n\tmark_inode_dirty(inode);\n\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\terr = nilfs_acl_chmod(inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t}\n\n\treturn nilfs_transaction_commit(sb);\n\nout_err:\n\tnilfs_transaction_abort(sb);\n\treturn err;\n}\n\nint nilfs_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t     int mask)\n{\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\n\tif ((mask & MAY_WRITE) && root &&\n\t    root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\treturn -EROFS;  \n\n\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\nint nilfs_load_inode_block(struct inode *inode, struct buffer_head **pbh)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (ii->i_bh == NULL || unlikely(!buffer_uptodate(ii->i_bh))) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\terr = nilfs_ifile_get_inode_block(ii->i_root->ifile,\n\t\t\t\t\t\t  inode->i_ino, pbh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tif (ii->i_bh == NULL)\n\t\t\tii->i_bh = *pbh;\n\t\telse if (unlikely(!buffer_uptodate(ii->i_bh))) {\n\t\t\t__brelse(ii->i_bh);\n\t\t\tii->i_bh = *pbh;\n\t\t} else {\n\t\t\tbrelse(*pbh);\n\t\t\t*pbh = ii->i_bh;\n\t\t}\n\t} else\n\t\t*pbh = ii->i_bh;\n\n\tget_bh(*pbh);\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}\n\nint nilfs_inode_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tint ret = 0;\n\n\tif (!list_empty(&ii->i_dirty)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tret = test_bit(NILFS_I_DIRTY, &ii->i_state) ||\n\t\t\ttest_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t}\n\treturn ret;\n}\n\nint nilfs_set_file_dirty(struct inode *inode, unsigned int nr_dirty)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\tatomic_add(nr_dirty, &nilfs->ns_ndirtyblks);\n\n\tif (test_and_set_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\treturn 0;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\t \n\t\tif (list_empty(&ii->i_dirty) && igrab(inode) == NULL) {\n\t\t\t \n\t\t\tnilfs_warn(inode->i_sb,\n\t\t\t\t   \"cannot set file dirty (ino=%lu): the file is being freed\",\n\t\t\t\t   inode->i_ino);\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\treturn -EINVAL;  \n\t\t}\n\t\tlist_move_tail(&ii->i_dirty, &nilfs->ns_dirty_files);\n\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn 0;\n}\n\nint __nilfs_mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct buffer_head *ibh;\n\tint err;\n\n\t \n\tif (unlikely(nilfs_purging(nilfs)))\n\t\treturn 0;\n\n\terr = nilfs_load_inode_block(inode, &ibh);\n\tif (unlikely(err)) {\n\t\tnilfs_warn(inode->i_sb,\n\t\t\t   \"cannot mark inode dirty (ino=%lu): error %d loading inode block\",\n\t\t\t   inode->i_ino, err);\n\t\treturn err;\n\t}\n\tnilfs_update_inode(inode, ibh, flags);\n\tmark_buffer_dirty(ibh);\n\tnilfs_mdt_mark_dirty(NILFS_I(inode)->i_root->ifile);\n\tbrelse(ibh);\n\treturn 0;\n}\n\n \nvoid nilfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_mdt_info *mdi = NILFS_MDT(inode);\n\n\tif (is_bad_inode(inode)) {\n\t\tnilfs_warn(inode->i_sb,\n\t\t\t   \"tried to mark bad_inode dirty. ignored.\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tif (mdi) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\treturn;\n\t}\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\t__nilfs_mark_inode_dirty(inode, flags);\n\tnilfs_transaction_commit(inode->i_sb);  \n}\n\nint nilfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t __u64 start, __u64 len)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 logical = 0, phys = 0, size = 0;\n\t__u32 flags = 0;\n\tloff_t isize;\n\tsector_t blkoff, end_blkoff;\n\tsector_t delalloc_blkoff;\n\tunsigned long delalloc_blklen;\n\tunsigned int blkbits = inode->i_blkbits;\n\tint ret, n;\n\n\tret = fiemap_prep(inode, fieinfo, start, &len, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tisize = i_size_read(inode);\n\n\tblkoff = start >> blkbits;\n\tend_blkoff = (start + len - 1) >> blkbits;\n\n\tdelalloc_blklen = nilfs_find_uncommitted_extent(inode, blkoff,\n\t\t\t\t\t\t\t&delalloc_blkoff);\n\n\tdo {\n\t\t__u64 blkphy;\n\t\tunsigned int maxblocks;\n\n\t\tif (delalloc_blklen && blkoff == delalloc_blkoff) {\n\t\t\tif (size) {\n\t\t\t\t \n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff)\n\t\t\t\tbreak;\n\n\t\t\tflags = FIEMAP_EXTENT_MERGED | FIEMAP_EXTENT_DELALLOC;\n\t\t\tlogical = blkoff << blkbits;\n\t\t\tphys = 0;\n\t\t\tsize = delalloc_blklen << blkbits;\n\n\t\t\tblkoff = delalloc_blkoff + delalloc_blklen;\n\t\t\tdelalloc_blklen = nilfs_find_uncommitted_extent(\n\t\t\t\tinode, blkoff, &delalloc_blkoff);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmaxblocks = INT_MAX;\n\t\tif (delalloc_blklen)\n\t\t\tmaxblocks = min_t(sector_t, delalloc_blkoff - blkoff,\n\t\t\t\t\t  maxblocks);\n\t\tblkphy = 0;\n\n\t\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\t\tn = nilfs_bmap_lookup_contig(\n\t\t\tNILFS_I(inode)->i_bmap, blkoff, &blkphy, maxblocks);\n\t\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\n\t\tif (n < 0) {\n\t\t\tint past_eof;\n\n\t\t\tif (unlikely(n != -ENOENT))\n\t\t\t\tbreak;  \n\n\t\t\t \n\t\t\tblkoff++;\n\t\t\tpast_eof = ((blkoff << blkbits) >= isize);\n\n\t\t\tif (size) {\n\t\t\t\t \n\n\t\t\t\tif (past_eof)\n\t\t\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\tfieinfo, logical, phys, size, flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tif (blkoff > end_blkoff || past_eof)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (size) {\n\t\t\t\tif (phys && blkphy << blkbits == phys + size) {\n\t\t\t\t\t \n\t\t\t\t\tsize += n << blkbits;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tret = fiemap_fill_next_extent(\n\t\t\t\t\t\tfieinfo, logical, phys, size,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tif (ret || blkoff > end_blkoff)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t \n\t\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\t\tsize = n << blkbits;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\t\t\t\tlogical = blkoff << blkbits;\n\t\t\t\tphys = blkphy << blkbits;\n\t\t\t\tsize = n << blkbits;\n\t\t\t}\n\t\t\tblkoff += n;\n\t\t}\n\t\tcond_resched();\n\t} while (true);\n\n\t \n\tif (ret == 1)\n\t\tret = 0;\n\n\tinode_unlock(inode);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}