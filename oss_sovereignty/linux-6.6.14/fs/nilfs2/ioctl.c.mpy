{
  "module_name": "ioctl.c",
  "hash_id": "d628b7eb608102c827e7c9183ef8b9928c8b76959e7b2f87658fcdda7041b3bf",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/capability.h>\t \n#include <linux/uaccess.h>\t \n#include <linux/vmalloc.h>\n#include <linux/compat.h>\t \n#include <linux/mount.h>\t \n#include <linux/buffer_head.h>\n#include <linux/fileattr.h>\n#include \"nilfs.h\"\n#include \"segment.h\"\n#include \"bmap.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"dat.h\"\n\n \nstatic int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,\n\t\t\t\t struct nilfs_argv *argv, int dir,\n\t\t\t\t ssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t   __u64 *, int,\n\t\t\t\t\t\t   void *, size_t, size_t))\n{\n\tvoid *buf;\n\tvoid __user *base = (void __user *)(unsigned long)argv->v_base;\n\tsize_t maxmembs, total, n;\n\tssize_t nr;\n\tint ret, i;\n\t__u64 pos, ppos;\n\n\tif (argv->v_nmembs == 0)\n\t\treturn 0;\n\n\tif (argv->v_size > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (argv->v_index > ~(__u64)0 - argv->v_nmembs)\n\t\treturn -EINVAL;\n\n\tbuf = (void *)get_zeroed_page(GFP_NOFS);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\tmaxmembs = PAGE_SIZE / argv->v_size;\n\n\tret = 0;\n\ttotal = 0;\n\tpos = argv->v_index;\n\tfor (i = 0; i < argv->v_nmembs; i += n) {\n\t\tn = (argv->v_nmembs - i < maxmembs) ?\n\t\t\targv->v_nmembs - i : maxmembs;\n\t\tif ((dir & _IOC_WRITE) &&\n\t\t    copy_from_user(buf, base + argv->v_size * i,\n\t\t\t\t   argv->v_size * n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tppos = pos;\n\t\tnr = dofunc(nilfs, &pos, argv->v_flags, buf, argv->v_size,\n\t\t\t       n);\n\t\tif (nr < 0) {\n\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif ((dir & _IOC_READ) &&\n\t\t    copy_to_user(base + argv->v_size * i, buf,\n\t\t\t\t argv->v_size * nr)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += nr;\n\t\tif ((size_t)nr < n)\n\t\t\tbreak;\n\t\tif (pos == ppos)\n\t\t\tpos += n;\n\t}\n\targv->v_nmembs = total;\n\n\tfree_pages((unsigned long)buf, 0);\n\treturn ret;\n}\n\n \nint nilfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tfileattr_fill_flags(fa, NILFS_I(inode)->i_flags & FS_FL_USER_VISIBLE);\n\n\treturn 0;\n}\n\n \nint nilfs_fileattr_set(struct mnt_idmap *idmap,\n\t\t       struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tflags = nilfs_mask_flags(inode->i_mode, fa->flags);\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\treturn ret;\n\n\toldflags = NILFS_I(inode)->i_flags & ~FS_FL_USER_MODIFIABLE;\n\tNILFS_I(inode)->i_flags = oldflags | (flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode_set_ctime_current(inode);\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\treturn nilfs_transaction_commit(inode->i_sb);\n}\n\n \nstatic int nilfs_ioctl_getversion(struct inode *inode, void __user *argp)\n{\n\treturn put_user(inode->i_generation, (int __user *)argp);\n}\n\n \nstatic int nilfs_ioctl_change_cpmode(struct inode *inode, struct file *filp,\n\t\t\t\t     unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_cpmode cpmode;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cpmode, argp, sizeof(cpmode)))\n\t\tgoto out;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_change_cpmode(\n\t\tnilfs->ns_cpfile, cpmode.cm_cno, cpmode.cm_mode);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb);  \n\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\n \nstatic int\nnilfs_ioctl_delete_checkpoint(struct inode *inode, struct file *filp,\n\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\t__u64 cno;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&cno, argp, sizeof(cno)))\n\t\tgoto out;\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_cpfile_delete_checkpoint(nilfs->ns_cpfile, cno);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb);  \nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\n \nstatic ssize_t\nnilfs_ioctl_do_get_cpinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_cpinfo(nilfs->ns_cpfile, posp, flags, buf,\n\t\t\t\t      size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_get_cpstat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_cpstat cpstat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &cpstat, sizeof(cpstat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}\n\n \nstatic ssize_t\nnilfs_ioctl_do_get_suinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_suinfo(nilfs->ns_sufile, *posp, buf, size,\n\t\t\t\t      nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_get_sustat(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_sustat sustat;\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &sustat, sizeof(sustat)))\n\t\tret = -EFAULT;\n\treturn ret;\n}\n\n \nstatic ssize_t\nnilfs_ioctl_do_get_vinfo(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t void *buf, size_t size, size_t nmembs)\n{\n\tint ret;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_dat_get_vinfo(nilfs->ns_dat, buf, size, nmembs);\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn ret;\n}\n\n \nstatic ssize_t\nnilfs_ioctl_do_get_bdescs(struct the_nilfs *nilfs, __u64 *posp, int flags,\n\t\t\t  void *buf, size_t size, size_t nmembs)\n{\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tint ret, i;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT) {\n\t\t\t\tup_read(&nilfs->ns_segctor_sem);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\treturn nmembs;\n}\n\n \nstatic int nilfs_ioctl_get_bdescs(struct inode *inode, struct file *filp,\n\t\t\t\t  unsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size != sizeof(struct nilfs_bdesc))\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd),\n\t\t\t\t    nilfs_ioctl_do_get_bdescs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_move_inode_block(struct inode *inode,\n\t\t\t\t\tstruct nilfs_vdesc *vdesc,\n\t\t\t\t\tstruct list_head *buffers)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (vdesc->vd_flags == 0)\n\t\tret = nilfs_gccache_submit_read_data(\n\t\t\tinode, vdesc->vd_offset, vdesc->vd_blocknr,\n\t\t\tvdesc->vd_vblocknr, &bh);\n\telse\n\t\tret = nilfs_gccache_submit_read_node(\n\t\t\tinode, vdesc->vd_blocknr, vdesc->vd_vblocknr, &bh);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tnilfs_crit(inode->i_sb,\n\t\t\t\t   \"%s: invalid virtual block address (%s): ino=%llu, cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\",\n\t\t\t\t   __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t\t   (unsigned long long)vdesc->vd_ino,\n\t\t\t\t   (unsigned long long)vdesc->vd_cno,\n\t\t\t\t   (unsigned long long)vdesc->vd_offset,\n\t\t\t\t   (unsigned long long)vdesc->vd_blocknr,\n\t\t\t\t   (unsigned long long)vdesc->vd_vblocknr);\n\t\treturn ret;\n\t}\n\tif (unlikely(!list_empty(&bh->b_assoc_buffers))) {\n\t\tnilfs_crit(inode->i_sb,\n\t\t\t   \"%s: conflicting %s buffer: ino=%llu, cno=%llu, offset=%llu, blocknr=%llu, vblocknr=%llu\",\n\t\t\t   __func__, vdesc->vd_flags ? \"node\" : \"data\",\n\t\t\t   (unsigned long long)vdesc->vd_ino,\n\t\t\t   (unsigned long long)vdesc->vd_cno,\n\t\t\t   (unsigned long long)vdesc->vd_offset,\n\t\t\t   (unsigned long long)vdesc->vd_blocknr,\n\t\t\t   (unsigned long long)vdesc->vd_vblocknr);\n\t\tbrelse(bh);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, buffers);\n\treturn 0;\n}\n\n \nstatic int nilfs_ioctl_move_blocks(struct super_block *sb,\n\t\t\t\t   struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct inode *inode;\n\tstruct nilfs_vdesc *vdesc;\n\tstruct buffer_head *bh, *n;\n\tLIST_HEAD(buffers);\n\tino_t ino;\n\t__u64 cno;\n\tint i, ret;\n\n\tfor (i = 0, vdesc = buf; i < nmembs; ) {\n\t\tino = vdesc->vd_ino;\n\t\tcno = vdesc->vd_cno;\n\t\tinode = nilfs_iget_for_gc(sb, ino, cno);\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (list_empty(&NILFS_I(inode)->i_dirty)) {\n\t\t\t \n\t\t\tigrab(inode);\n\t\t\tlist_add(&NILFS_I(inode)->i_dirty,\n\t\t\t\t &nilfs->ns_gc_inodes);\n\t\t}\n\n\t\tdo {\n\t\t\tret = nilfs_ioctl_move_inode_block(inode, vdesc,\n\t\t\t\t\t\t\t   &buffers);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tvdesc++;\n\t\t} while (++i < nmembs &&\n\t\t\t vdesc->vd_ino == ino && vdesc->vd_cno == cno);\n\n\t\tiput(inode);  \n\t}\n\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tret = nilfs_gccache_wait_and_mark_dirty(bh);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tWARN_ON(ret == -EEXIST);\n\t\t\tgoto failed;\n\t\t}\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn nmembs;\n\n failed:\n\tlist_for_each_entry_safe(bh, n, &buffers, b_assoc_buffers) {\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_delete_checkpoints(struct the_nilfs *nilfs,\n\t\t\t\t\t  struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct inode *cpfile = nilfs->ns_cpfile;\n\tstruct nilfs_period *periods = buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\tret = nilfs_cpfile_delete_checkpoints(\n\t\t\tcpfile, periods[i].p_start, periods[i].p_end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn nmembs;\n}\n\n \nstatic int nilfs_ioctl_free_vblocknrs(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tint ret;\n\n\tret = nilfs_dat_freev(nilfs->ns_dat, buf, nmembs);\n\n\treturn (ret < 0) ? ret : nmembs;\n}\n\n \nstatic int nilfs_ioctl_mark_blocks_dirty(struct the_nilfs *nilfs,\n\t\t\t\t\t struct nilfs_argv *argv, void *buf)\n{\n\tsize_t nmembs = argv->v_nmembs;\n\tstruct nilfs_bmap *bmap = NILFS_I(nilfs->ns_dat)->i_bmap;\n\tstruct nilfs_bdesc *bdescs = buf;\n\tstruct buffer_head *bh;\n\tint ret, i;\n\n\tfor (i = 0; i < nmembs; i++) {\n\t\t \n\t\tret = nilfs_bmap_lookup_at_level(bmap,\n\t\t\t\t\t\t bdescs[i].bd_offset,\n\t\t\t\t\t\t bdescs[i].bd_level + 1,\n\t\t\t\t\t\t &bdescs[i].bd_blocknr);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\treturn ret;\n\t\t\tbdescs[i].bd_blocknr = 0;\n\t\t}\n\t\tif (bdescs[i].bd_blocknr != bdescs[i].bd_oblocknr)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (bdescs[i].bd_level == 0) {\n\t\t\tret = nilfs_mdt_get_block(nilfs->ns_dat,\n\t\t\t\t\t\t  bdescs[i].bd_offset,\n\t\t\t\t\t\t  false, NULL, &bh);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tnilfs_mdt_mark_dirty(nilfs->ns_dat);\n\t\t\tput_bh(bh);\n\t\t} else {\n\t\t\tret = nilfs_bmap_mark(bmap, bdescs[i].bd_offset,\n\t\t\t\t\t      bdescs[i].bd_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn nmembs;\n}\n\nint nilfs_ioctl_prepare_clean_segments(struct the_nilfs *nilfs,\n\t\t\t\t       struct nilfs_argv *argv, void **kbufs)\n{\n\tconst char *msg;\n\tint ret;\n\n\tret = nilfs_ioctl_delete_checkpoints(nilfs, &argv[1], kbufs[1]);\n\tif (ret < 0) {\n\t\t \n\t\tmsg = \"cannot delete checkpoints\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_free_vblocknrs(nilfs, &argv[2], kbufs[2]);\n\tif (ret < 0) {\n\t\t \n\t\tmsg = \"cannot delete virtual blocks from DAT file\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_mark_blocks_dirty(nilfs, &argv[3], kbufs[3]);\n\tif (ret < 0) {\n\t\t \n\t\tmsg = \"cannot mark copying blocks dirty\";\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tnilfs_err(nilfs->ns_sb, \"error %d preparing GC: %s\", ret, msg);\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_clean_segments(struct inode *inode, struct file *filp,\n\t\t\t\t      unsigned int cmd, void __user *argp)\n{\n\tstruct nilfs_argv argv[5];\n\tstatic const size_t argsz[5] = {\n\t\tsizeof(struct nilfs_vdesc),\n\t\tsizeof(struct nilfs_period),\n\t\tsizeof(__u64),\n\t\tsizeof(struct nilfs_bdesc),\n\t\tsizeof(__u64),\n\t};\n\tvoid __user *base;\n\tvoid *kbufs[5];\n\tstruct the_nilfs *nilfs;\n\tsize_t len, nsegs;\n\tint n, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tnsegs = argv[4].v_nmembs;\n\tif (argv[4].v_size != argsz[4])\n\t\tgoto out;\n\tif (nsegs > UINT_MAX / sizeof(__u64))\n\t\tgoto out;\n\n\t \n\tkbufs[4] = memdup_user((void __user *)(unsigned long)argv[4].v_base,\n\t\t\t       nsegs * sizeof(__u64));\n\tif (IS_ERR(kbufs[4])) {\n\t\tret = PTR_ERR(kbufs[4]);\n\t\tgoto out;\n\t}\n\tnilfs = inode->i_sb->s_fs_info;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tret = -EINVAL;\n\t\tif (argv[n].v_size != argsz[n])\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs > nsegs * nilfs->ns_blocks_per_segment)\n\t\t\tgoto out_free;\n\n\t\tif (argv[n].v_nmembs >= UINT_MAX / argv[n].v_size)\n\t\t\tgoto out_free;\n\n\t\tlen = argv[n].v_size * argv[n].v_nmembs;\n\t\tbase = (void __user *)(unsigned long)argv[n].v_base;\n\t\tif (len == 0) {\n\t\t\tkbufs[n] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkbufs[n] = vmalloc(len);\n\t\tif (!kbufs[n]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (copy_from_user(kbufs[n], base, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tvfree(kbufs[n]);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t \n\tif (test_and_set_bit(THE_NILFS_GC_RUNNING, &nilfs->ns_flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = nilfs_ioctl_move_blocks(inode->i_sb, &argv[0], kbufs[0]);\n\tif (ret < 0) {\n\t\tnilfs_err(inode->i_sb,\n\t\t\t  \"error %d preparing GC: cannot read source blocks\",\n\t\t\t  ret);\n\t} else {\n\t\tif (nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t\tret = nilfs_clean_segments(inode->i_sb, argv, kbufs);\n\t}\n\n\tnilfs_remove_all_gcinodes(nilfs);\n\tclear_nilfs_gc_running(nilfs);\n\nout_free:\n\twhile (--n >= 0)\n\t\tvfree(kbufs[n]);\n\tkfree(kbufs[4]);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_sync(struct inode *inode, struct file *filp,\n\t\t\t    unsigned int cmd, void __user *argp)\n{\n\t__u64 cno;\n\tint ret;\n\tstruct the_nilfs *nilfs;\n\n\tret = nilfs_construct_segment(inode->i_sb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tret = nilfs_flush_device(nilfs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (argp != NULL) {\n\t\tdown_read(&nilfs->ns_segctor_sem);\n\t\tcno = nilfs->ns_cno - 1;\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tif (copy_to_user(argp, &cno, sizeof(cno)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic int nilfs_ioctl_resize(struct inode *inode, struct file *filp,\n\t\t\t      void __user *argp)\n{\n\t__u64 newsize;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&newsize, argp, sizeof(newsize)))\n\t\tgoto out_drop_write;\n\n\tret = nilfs_resize_fs(inode->i_sb, newsize);\n\nout_drop_write:\n\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_trim_fs(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!bdev_max_discard_sectors(nilfs->ns_bdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\trange.minlen = max_t(u64, range.minlen,\n\t\t\t     bdev_discard_granularity(nilfs->ns_bdev));\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_sufile_trim_fs(nilfs->ns_sufile, &range);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int nilfs_ioctl_set_alloc_range(struct inode *inode, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\t__u64 range[2];\n\t__u64 minseg, maxseg;\n\tunsigned long segbytes;\n\tint ret = -EPERM;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(range, argp, sizeof(__u64[2])))\n\t\tgoto out;\n\n\tret = -ERANGE;\n\tif (range[1] > bdev_nr_bytes(inode->i_sb->s_bdev))\n\t\tgoto out;\n\n\tsegbytes = nilfs->ns_blocks_per_segment * nilfs->ns_blocksize;\n\n\tminseg = range[0] + segbytes - 1;\n\tdo_div(minseg, segbytes);\n\n\tif (range[1] < 4096)\n\t\tgoto out;\n\n\tmaxseg = NILFS_SB2_OFFSET_BYTES(range[1]);\n\tif (maxseg < segbytes)\n\t\tgoto out;\n\n\tdo_div(maxseg, segbytes);\n\tmaxseg--;\n\n\tret = nilfs_sufile_set_alloc_range(nilfs->ns_sufile, minseg, maxseg);\nout:\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_get_info(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp,\n\t\t\t\tsize_t membsz,\n\t\t\t\tssize_t (*dofunc)(struct the_nilfs *,\n\t\t\t\t\t\t  __u64 *, int,\n\t\t\t\t\t\t  void *, size_t, size_t))\n\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_argv argv;\n\tint ret;\n\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\treturn -EFAULT;\n\n\tif (argv.v_size < membsz)\n\t\treturn -EINVAL;\n\n\tret = nilfs_ioctl_wrap_copy(nilfs, &argv, _IOC_DIR(cmd), dofunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &argv, sizeof(argv)))\n\t\tret = -EFAULT;\n\treturn ret;\n}\n\n \nstatic int nilfs_ioctl_set_suinfo(struct inode *inode, struct file *filp,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\tstruct nilfs_transaction_info ti;\n\tstruct nilfs_argv argv;\n\tsize_t len;\n\tvoid __user *base;\n\tvoid *kbuf;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&argv, argp, sizeof(argv)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (argv.v_size < sizeof(struct nilfs_suinfo_update))\n\t\tgoto out;\n\n\tif (argv.v_nmembs > nilfs->ns_nsegments)\n\t\tgoto out;\n\n\tif (argv.v_nmembs >= UINT_MAX / argv.v_size)\n\t\tgoto out;\n\n\tlen = argv.v_size * argv.v_nmembs;\n\tif (!len) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tbase = (void __user *)(unsigned long)argv.v_base;\n\tkbuf = vmalloc(len);\n\tif (!kbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(kbuf, base, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tnilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tret = nilfs_sufile_set_suinfo(nilfs->ns_sufile, kbuf, argv.v_size,\n\t\t\targv.v_nmembs);\n\tif (unlikely(ret < 0))\n\t\tnilfs_transaction_abort(inode->i_sb);\n\telse\n\t\tnilfs_transaction_commit(inode->i_sb);  \n\nout_free:\n\tvfree(kbuf);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nlong nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETVERSION:\n\t\treturn nilfs_ioctl_getversion(inode, argp);\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\t\treturn nilfs_ioctl_change_cpmode(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\t\treturn nilfs_ioctl_delete_checkpoint(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_CPINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_cpinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_cpinfo);\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\t\treturn nilfs_ioctl_get_cpstat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_suinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_suinfo);\n\tcase NILFS_IOCTL_SET_SUINFO:\n\t\treturn nilfs_ioctl_set_suinfo(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\t\treturn nilfs_ioctl_get_sustat(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_GET_VINFO:\n\t\treturn nilfs_ioctl_get_info(inode, filp, cmd, argp,\n\t\t\t\t\t    sizeof(struct nilfs_vinfo),\n\t\t\t\t\t    nilfs_ioctl_do_get_vinfo);\n\tcase NILFS_IOCTL_GET_BDESCS:\n\t\treturn nilfs_ioctl_get_bdescs(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\t\treturn nilfs_ioctl_clean_segments(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_SYNC:\n\t\treturn nilfs_ioctl_sync(inode, filp, cmd, argp);\n\tcase NILFS_IOCTL_RESIZE:\n\t\treturn nilfs_ioctl_resize(inode, filp, argp);\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\t\treturn nilfs_ioctl_set_alloc_range(inode, argp);\n\tcase FITRIM:\n\t\treturn nilfs_ioctl_trim_fs(inode, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nlong nilfs_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\tcase NILFS_IOCTL_CHANGE_CPMODE:\n\tcase NILFS_IOCTL_DELETE_CHECKPOINT:\n\tcase NILFS_IOCTL_GET_CPINFO:\n\tcase NILFS_IOCTL_GET_CPSTAT:\n\tcase NILFS_IOCTL_GET_SUINFO:\n\tcase NILFS_IOCTL_SET_SUINFO:\n\tcase NILFS_IOCTL_GET_SUSTAT:\n\tcase NILFS_IOCTL_GET_VINFO:\n\tcase NILFS_IOCTL_GET_BDESCS:\n\tcase NILFS_IOCTL_CLEAN_SEGMENTS:\n\tcase NILFS_IOCTL_SYNC:\n\tcase NILFS_IOCTL_RESIZE:\n\tcase NILFS_IOCTL_SET_ALLOC_RANGE:\n\tcase FITRIM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn nilfs_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}