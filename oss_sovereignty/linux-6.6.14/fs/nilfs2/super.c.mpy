{
  "module_name": "super.c",
  "hash_id": "a18445d71fe425af6fef062b0fb1c3370ae9e1a9d6774161292b5354680a73c3",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/super.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/crc32.h>\n#include <linux/vfs.h>\n#include <linux/writeback.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include \"nilfs.h\"\n#include \"export.h\"\n#include \"mdt.h\"\n#include \"alloc.h\"\n#include \"btree.h\"\n#include \"btnode.h\"\n#include \"page.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"  \n#include \"ifile.h\"\n#include \"dat.h\"\n#include \"segment.h\"\n#include \"segbuf.h\"\n\nMODULE_AUTHOR(\"NTT Corp.\");\nMODULE_DESCRIPTION(\"A New Implementation of the Log-structured Filesystem \"\n\t\t   \"(NILFS)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct kmem_cache *nilfs_inode_cachep;\nstruct kmem_cache *nilfs_transaction_cachep;\nstruct kmem_cache *nilfs_segbuf_cachep;\nstruct kmem_cache *nilfs_btree_path_cache;\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount);\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data);\n\nvoid __nilfs_msg(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint level;\n\n\tva_start(args, fmt);\n\n\tlevel = printk_get_level(fmt);\n\tvaf.fmt = printk_skip_level(fmt);\n\tvaf.va = &args;\n\n\tif (sb)\n\t\tprintk(\"%c%cNILFS (%s): %pV\\n\",\n\t\t       KERN_SOH_ASCII, level, sb->s_id, &vaf);\n\telse\n\t\tprintk(\"%c%cNILFS: %pV\\n\",\n\t\t       KERN_SOH_ASCII, level, &vaf);\n\n\tva_end(args);\n}\n\nstatic void nilfs_set_error(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\n\tdown_write(&nilfs->ns_sem);\n\tif (!(nilfs->ns_mount_state & NILFS_ERROR_FS)) {\n\t\tnilfs->ns_mount_state |= NILFS_ERROR_FS;\n\t\tsbp = nilfs_prepare_super(sb, 0);\n\t\tif (likely(sbp)) {\n\t\t\tsbp[0]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tif (sbp[1])\n\t\t\t\tsbp[1]->s_state |= cpu_to_le16(NILFS_ERROR_FS);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n}\n\n \nvoid __nilfs_error(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (!sb_rdonly(sb)) {\n\t\tnilfs_set_error(sb);\n\n\t\tif (nilfs_test_opt(nilfs, ERRORS_RO)) {\n\t\t\tprintk(KERN_CRIT \"Remounting filesystem read-only\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t}\n\t}\n\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tpanic(\"NILFS (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n}\n\nstruct inode *nilfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tii = alloc_inode_sb(sb, nilfs_inode_cachep, GFP_NOFS);\n\tif (!ii)\n\t\treturn NULL;\n\tii->i_bh = NULL;\n\tii->i_state = 0;\n\tii->i_cno = 0;\n\tii->i_assoc_inode = NULL;\n\tii->i_bmap = &ii->i_bmap_data;\n\treturn &ii->vfs_inode;\n}\n\nstatic void nilfs_free_inode(struct inode *inode)\n{\n\tif (nilfs_is_metadata_file_inode(inode))\n\t\tnilfs_mdt_destroy(inode);\n\n\tkmem_cache_free(nilfs_inode_cachep, NILFS_I(inode));\n}\n\nstatic int nilfs_sync_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n retry:\n\tset_buffer_dirty(nilfs->ns_sbh[0]);\n\tif (nilfs_test_opt(nilfs, BARRIER)) {\n\t\terr = __sync_dirty_buffer(nilfs->ns_sbh[0],\n\t\t\t\t\t  REQ_SYNC | REQ_PREFLUSH | REQ_FUA);\n\t} else {\n\t\terr = sync_dirty_buffer(nilfs->ns_sbh[0]);\n\t}\n\n\tif (unlikely(err)) {\n\t\tnilfs_err(sb, \"unable to write superblock: err=%d\", err);\n\t\tif (err == -EIO && nilfs->ns_sbh[1]) {\n\t\t\t \n\t\t\tmemcpy(nilfs->ns_sbp[1], nilfs->ns_sbp[0],\n\t\t\t       nilfs->ns_sbsize);\n\t\t\tnilfs_fall_back_super_block(nilfs);\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\tstruct nilfs_super_block *sbp = nilfs->ns_sbp[0];\n\n\t\tnilfs->ns_sbwcount++;\n\n\t\t \n\t\tclear_nilfs_discontinued(nilfs);\n\n\t\t \n\t\tif (nilfs->ns_sbh[1]) {\n\t\t\tif (flag == NILFS_SB_COMMIT_ALL) {\n\t\t\t\tset_buffer_dirty(nilfs->ns_sbh[1]);\n\t\t\t\tif (sync_dirty_buffer(nilfs->ns_sbh[1]) < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (le64_to_cpu(nilfs->ns_sbp[1]->s_last_cno) <\n\t\t\t    le64_to_cpu(nilfs->ns_sbp[0]->s_last_cno))\n\t\t\t\tsbp = nilfs->ns_sbp[1];\n\t\t}\n\n\t\tspin_lock(&nilfs->ns_last_segment_lock);\n\t\tnilfs->ns_prot_seq = le64_to_cpu(sbp->s_last_seq);\n\t\tspin_unlock(&nilfs->ns_last_segment_lock);\n\t}\n out:\n\treturn err;\n}\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t \n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t \n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tnilfs_crit(sb, \"superblock broke\");\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime64_t t;\n\n\t \n\tt = ktime_get_real_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t \n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}\n\n \nint nilfs_cleanup_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint flag = NILFS_SB_COMMIT;\n\tint ret = -EIO;\n\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (sbp) {\n\t\tsbp[0]->s_state = cpu_to_le16(nilfs->ns_mount_state);\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\tif (sbp[1] && sbp[0]->s_last_cno == sbp[1]->s_last_cno) {\n\t\t\t \n\t\t\tsbp[1]->s_state = sbp[0]->s_state;\n\t\t\tflag = NILFS_SB_COMMIT_ALL;\n\t\t}\n\t\tret = nilfs_commit_super(sb, flag);\n\t}\n\treturn ret;\n}\n\n \nstatic int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct buffer_head *nsbh;\n\tstruct nilfs_super_block *nsbp;\n\tsector_t blocknr, newblocknr;\n\tunsigned long offset;\n\tint sb2i;   \n\tint ret = 0;\n\n\t \n\tif (nilfs->ns_sbh[1] &&\n\t    nilfs->ns_sbh[1]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 1;\n\t\tblocknr = nilfs->ns_sbh[1]->b_blocknr;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr > nilfs->ns_first_data_block) {\n\t\tsb2i = 0;\n\t\tblocknr = nilfs->ns_sbh[0]->b_blocknr;\n\t} else {\n\t\tsb2i = -1;\n\t\tblocknr = 0;\n\t}\n\tif (sb2i >= 0 && (u64)blocknr << nilfs->ns_blocksize_bits == sb2off)\n\t\tgoto out;   \n\n\t \n\tnewblocknr = sb2off >> nilfs->ns_blocksize_bits;\n\toffset = sb2off & (nilfs->ns_blocksize - 1);\n\tnsbh = sb_getblk(sb, newblocknr);\n\tif (!nsbh) {\n\t\tnilfs_warn(sb,\n\t\t\t   \"unable to move secondary superblock to block %llu\",\n\t\t\t   (unsigned long long)newblocknr);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tnsbp = (void *)nsbh->b_data + offset;\n\n\tlock_buffer(nsbh);\n\tif (sb2i >= 0) {\n\t\t \n\t\tmemcpy(nsbp, nilfs->ns_sbp[sb2i], nilfs->ns_sbsize);\n\n\t\t \n\t\tmemset(nsbh->b_data, 0, offset);\n\t\tmemset((void *)nsbp + nilfs->ns_sbsize, 0,\n\t\t       nsbh->b_size - offset - nilfs->ns_sbsize);\n\t} else {\n\t\tmemset(nsbh->b_data, 0, nsbh->b_size);\n\t}\n\tset_buffer_uptodate(nsbh);\n\tunlock_buffer(nsbh);\n\n\tif (sb2i >= 0) {\n\t\tbrelse(nilfs->ns_sbh[sb2i]);\n\t\tnilfs->ns_sbh[sb2i] = nsbh;\n\t\tnilfs->ns_sbp[sb2i] = nsbp;\n\t} else if (nilfs->ns_sbh[0]->b_blocknr < nilfs->ns_first_data_block) {\n\t\t \n\t\tnilfs->ns_sbh[1] = nsbh;\n\t\tnilfs->ns_sbp[1] = nsbp;\n\t} else {\n\t\tbrelse(nsbh);\n\t}\nout:\n\treturn ret;\n}\n\n \nint nilfs_resize_fs(struct super_block *sb, __u64 newsize)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\t__u64 devsize, newnsegs;\n\tloff_t sb2off;\n\tint ret;\n\n\tret = -ERANGE;\n\tdevsize = bdev_nr_bytes(sb->s_bdev);\n\tif (newsize > devsize)\n\t\tgoto out;\n\n\t \n\tif (newsize < 4096) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tsb2off = NILFS_SB2_OFFSET_BYTES(newsize);\n\tnewnsegs = sb2off >> nilfs->ns_blocksize_bits;\n\tdo_div(newnsegs, nilfs->ns_blocks_per_segment);\n\n\tret = nilfs_sufile_resize(nilfs->ns_sufile, newnsegs);\n\tup_write(&nilfs->ns_segctor_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = nilfs_construct_segment(sb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_move_2nd_super(sb, sb2off);\n\tret = -EIO;\n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (likely(sbp)) {\n\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t \n\t\tsbp[0]->s_state = cpu_to_le16(le16_to_cpu(sbp[0]->s_state) &\n\t\t\t\t\t      ~NILFS_RESIZE_FS);\n\t\tsbp[0]->s_dev_size = cpu_to_le64(newsize);\n\t\tsbp[0]->s_nsegments = cpu_to_le64(nilfs->ns_nsegments);\n\t\tif (sbp[1])\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t\tret = nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\t \n\tif (!ret)\n\t\tnilfs_sufile_set_alloc_range(nilfs->ns_sufile, 0, newnsegs - 1);\nout:\n\treturn ret;\n}\n\nstatic void nilfs_put_super(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs_detach_log_writer(sb);\n\n\tif (!sb_rdonly(sb)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\tnilfs_sysfs_delete_device_group(nilfs);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n\tdestroy_nilfs(nilfs);\n\tsb->s_fs_info = NULL;\n}\n\nstatic int nilfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\t \n\tif (wait)\n\t\terr = nilfs_construct_segment(sb);\n\n\tdown_write(&nilfs->ns_sem);\n\tif (nilfs_sb_dirty(nilfs)) {\n\t\tsbp = nilfs_prepare_super(sb, nilfs_sb_will_flip(nilfs));\n\t\tif (likely(sbp)) {\n\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\tnilfs_commit_super(sb, NILFS_SB_COMMIT);\n\t\t}\n\t}\n\tup_write(&nilfs->ns_sem);\n\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}\n\nint nilfs_attach_checkpoint(struct super_block *sb, __u64 cno, int curr_mnt,\n\t\t\t    struct nilfs_root **rootp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct nilfs_checkpoint *raw_cp;\n\tstruct buffer_head *bh_cp;\n\tint err = -ENOMEM;\n\n\troot = nilfs_find_or_create_root(\n\t\tnilfs, curr_mnt ? NILFS_CPTREE_CURRENT_CNO : cno);\n\tif (!root)\n\t\treturn err;\n\n\tif (root->ifile)\n\t\tgoto reuse;  \n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, cno, 0, &raw_cp,\n\t\t\t\t\t  &bh_cp);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT || err == -EINVAL) {\n\t\t\tnilfs_err(sb,\n\t\t\t\t  \"Invalid checkpoint (checkpoint number=%llu)\",\n\t\t\t\t  (unsigned long long)cno);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_ifile_read(sb, root, nilfs->ns_inode_size,\n\t\t\t       &raw_cp->cp_ifile_inode, &root->ifile);\n\tif (err)\n\t\tgoto failed_bh;\n\n\tatomic64_set(&root->inodes_count,\n\t\t\tle64_to_cpu(raw_cp->cp_inodes_count));\n\tatomic64_set(&root->blocks_count,\n\t\t\tle64_to_cpu(raw_cp->cp_blocks_count));\n\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n\n reuse:\n\t*rootp = root;\n\treturn 0;\n\n failed_bh:\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, cno, bh_cp);\n failed:\n\tnilfs_put_root(root);\n\n\treturn err;\n}\n\nstatic int nilfs_freeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\t \n\tdown_write(&nilfs->ns_sem);\n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n}\n\nstatic int nilfs_unfreeze(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs_setup_super(sb, false);\n\tup_write(&nilfs->ns_sem);\n\treturn 0;\n}\n\nstatic int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct nilfs_root *root = NILFS_I(d_inode(dentry))->i_root;\n\tstruct the_nilfs *nilfs = root->nilfs;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tunsigned long long blocks;\n\tunsigned long overhead;\n\tunsigned long nrsvblocks;\n\tsector_t nfreeblocks;\n\tu64 nmaxinodes, nfreeinodes;\n\tint err;\n\n\t \n\tblocks = nilfs->ns_blocks_per_segment * nilfs->ns_nsegments\n\t\t- nilfs->ns_first_data_block;\n\tnrsvblocks = nilfs->ns_nrsvsegs * nilfs->ns_blocks_per_segment;\n\n\t \n\toverhead = 0;\n\n\terr = nilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = nilfs_ifile_count_free_inodes(root->ifile,\n\t\t\t\t\t    &nmaxinodes, &nfreeinodes);\n\tif (unlikely(err)) {\n\t\tnilfs_warn(sb, \"failed to count free inodes: err=%d\", err);\n\t\tif (err == -ERANGE) {\n\t\t\t \n\t\t\tnmaxinodes = atomic64_read(&root->inodes_count);\n\t\t\tnfreeinodes = 0;\n\t\t\terr = 0;\n\t\t} else\n\t\t\treturn err;\n\t}\n\n\tbuf->f_type = NILFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = blocks - overhead;\n\tbuf->f_bfree = nfreeblocks;\n\tbuf->f_bavail = (buf->f_bfree >= nrsvblocks) ?\n\t\t(buf->f_bfree - nrsvblocks) : 0;\n\tbuf->f_files = nmaxinodes;\n\tbuf->f_ffree = nfreeinodes;\n\tbuf->f_namelen = NILFS_NAME_LEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\treturn 0;\n}\n\nstatic int nilfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root = NILFS_I(d_inode(dentry))->i_root;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (root->cno != NILFS_CPTREE_CURRENT_CNO)\n\t\tseq_printf(seq, \",cp=%llu\", (unsigned long long)root->cno);\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (nilfs_test_opt(nilfs, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (nilfs_test_opt(nilfs, STRICT_ORDER))\n\t\tseq_puts(seq, \",order=strict\");\n\tif (nilfs_test_opt(nilfs, NORECOVERY))\n\t\tseq_puts(seq, \",norecovery\");\n\tif (nilfs_test_opt(nilfs, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\n\treturn 0;\n}\n\nstatic const struct super_operations nilfs_sops = {\n\t.alloc_inode    = nilfs_alloc_inode,\n\t.free_inode     = nilfs_free_inode,\n\t.dirty_inode    = nilfs_dirty_inode,\n\t.evict_inode    = nilfs_evict_inode,\n\t.put_super      = nilfs_put_super,\n\t.sync_fs        = nilfs_sync_fs,\n\t.freeze_fs\t= nilfs_freeze,\n\t.unfreeze_fs\t= nilfs_unfreeze,\n\t.statfs         = nilfs_statfs,\n\t.remount_fs     = nilfs_remount,\n\t.show_options = nilfs_show_options\n};\n\nenum {\n\tOpt_err_cont, Opt_err_panic, Opt_err_ro,\n\tOpt_barrier, Opt_nobarrier, Opt_snapshot, Opt_order, Opt_norecovery,\n\tOpt_discard, Opt_nodiscard, Opt_err,\n};\n\nstatic match_table_t tokens = {\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_snapshot, \"cp=%u\"},\n\t{Opt_order, \"order=%s\"},\n\t{Opt_norecovery, \"norecovery\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb, int is_remount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_barrier:\n\t\t\tnilfs_set_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tnilfs_clear_opt(nilfs, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_order:\n\t\t\tif (strcmp(args[0].from, \"relaxed\") == 0)\n\t\t\t\t \n\t\t\t\tnilfs_clear_opt(nilfs, STRICT_ORDER);\n\t\t\telse if (strcmp(args[0].from, \"strict\") == 0)\n\t\t\t\t \n\t\t\t\tnilfs_set_opt(nilfs, STRICT_ORDER);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tnilfs_write_opt(nilfs, ERROR_MODE, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_snapshot:\n\t\t\tif (is_remount) {\n\t\t\t\tnilfs_err(sb,\n\t\t\t\t\t  \"\\\"%s\\\" option is invalid for remount\",\n\t\t\t\t\t  p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_norecovery:\n\t\t\tnilfs_set_opt(nilfs, NORECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tnilfs_set_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnilfs_err(sb, \"unrecognized mount option \\\"%s\\\"\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline void\nnilfs_set_default_options(struct super_block *sb,\n\t\t\t  struct nilfs_super_block *sbp)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tnilfs->ns_mount_opt =\n\t\tNILFS_MOUNT_ERRORS_RO | NILFS_MOUNT_BARRIER;\n}\n\nstatic int nilfs_setup_super(struct super_block *sb, int is_mount)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint max_mnt_count;\n\tint mnt_count;\n\n\t \n\tsbp = nilfs_prepare_super(sb, 0);\n\tif (!sbp)\n\t\treturn -EIO;\n\n\tif (!is_mount)\n\t\tgoto skip_mount_setup;\n\n\tmax_mnt_count = le16_to_cpu(sbp[0]->s_max_mnt_count);\n\tmnt_count = le16_to_cpu(sbp[0]->s_mnt_count);\n\n\tif (nilfs->ns_mount_state & NILFS_ERROR_FS) {\n\t\tnilfs_warn(sb, \"mounting fs with errors\");\n#if 0\n\t} else if (max_mnt_count >= 0 && mnt_count >= max_mnt_count) {\n\t\tnilfs_warn(sb, \"maximal mount count reached\");\n#endif\n\t}\n\tif (!max_mnt_count)\n\t\tsbp[0]->s_max_mnt_count = cpu_to_le16(NILFS_DFL_MAX_MNT_COUNT);\n\n\tsbp[0]->s_mnt_count = cpu_to_le16(mnt_count + 1);\n\tsbp[0]->s_mtime = cpu_to_le64(ktime_get_real_seconds());\n\nskip_mount_setup:\n\tsbp[0]->s_state =\n\t\tcpu_to_le16(le16_to_cpu(sbp[0]->s_state) & ~NILFS_VALID_FS);\n\t \n\tif (sbp[1])\n\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\treturn nilfs_commit_super(sb, NILFS_SB_COMMIT_ALL);\n}\n\nstruct nilfs_super_block *nilfs_read_super_block(struct super_block *sb,\n\t\t\t\t\t\t u64 pos, int blocksize,\n\t\t\t\t\t\t struct buffer_head **pbh)\n{\n\tunsigned long long sb_index = pos;\n\tunsigned long offset;\n\n\toffset = do_div(sb_index, blocksize);\n\t*pbh = sb_bread(sb, sb_index);\n\tif (!*pbh)\n\t\treturn NULL;\n\treturn (struct nilfs_super_block *)((char *)(*pbh)->b_data + offset);\n}\n\nint nilfs_store_magic_and_option(struct super_block *sb,\n\t\t\t\t struct nilfs_super_block *sbp,\n\t\t\t\t char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tsb->s_magic = le16_to_cpu(sbp->s_magic);\n\n\t \n#ifdef NILFS_ATIME_DISABLE\n\tsb->s_flags |= SB_NOATIME;\n#endif\n\n\tnilfs_set_default_options(sb, sbp);\n\n\tnilfs->ns_resuid = le16_to_cpu(sbp->s_def_resuid);\n\tnilfs->ns_resgid = le16_to_cpu(sbp->s_def_resgid);\n\tnilfs->ns_interval = le32_to_cpu(sbp->s_c_interval);\n\tnilfs->ns_watermark = le32_to_cpu(sbp->s_c_block_max);\n\n\treturn !parse_options(data, sb, 0) ? -EINVAL : 0;\n}\n\nint nilfs_check_feature_compatibility(struct super_block *sb,\n\t\t\t\t      struct nilfs_super_block *sbp)\n{\n\t__u64 features;\n\n\tfeatures = le64_to_cpu(sbp->s_feature_incompat) &\n\t\t~NILFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tnilfs_err(sb,\n\t\t\t  \"couldn't mount because of unsupported optional features (%llx)\",\n\t\t\t  (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\tfeatures = le64_to_cpu(sbp->s_feature_compat_ro) &\n\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!sb_rdonly(sb) && features) {\n\t\tnilfs_err(sb,\n\t\t\t  \"couldn't mount RDWR because of unsupported optional features (%llx)\",\n\t\t\t  (unsigned long long)features);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int nilfs_get_root_dentry(struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode = nilfs_iget(sb, root, NILFS_ROOT_INO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tnilfs_err(sb, \"error %d getting root inode\", ret);\n\t\tgoto out;\n\t}\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_blocks || !inode->i_size) {\n\t\tiput(inode);\n\t\tnilfs_err(sb, \"corrupt root inode\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\tdentry = d_find_alias(inode);\n\t\tif (!dentry) {\n\t\t\tdentry = d_make_root(inode);\n\t\t\tif (!dentry) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed_dentry;\n\t\t\t}\n\t\t} else {\n\t\t\tiput(inode);\n\t\t}\n\t} else {\n\t\tdentry = d_obtain_root(inode);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto failed_dentry;\n\t\t}\n\t}\n\t*root_dentry = dentry;\n out:\n\treturn ret;\n\n failed_dentry:\n\tnilfs_err(sb, \"error %d getting root dentry\", ret);\n\tgoto out;\n}\n\nstatic int nilfs_attach_snapshot(struct super_block *s, __u64 cno,\n\t\t\t\t struct dentry **root_dentry)\n{\n\tstruct the_nilfs *nilfs = s->s_fs_info;\n\tstruct nilfs_root *root;\n\tint ret;\n\n\tmutex_lock(&nilfs->ns_snapshot_mount_mutex);\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tret = nilfs_cpfile_is_snapshot(nilfs->ns_cpfile, cno);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (ret < 0) {\n\t\tret = (ret == -ENOENT) ? -EINVAL : ret;\n\t\tgoto out;\n\t} else if (!ret) {\n\t\tnilfs_err(s,\n\t\t\t  \"The specified checkpoint is not a snapshot (checkpoint number=%llu)\",\n\t\t\t  (unsigned long long)cno);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_attach_checkpoint(s, cno, false, &root);\n\tif (ret) {\n\t\tnilfs_err(s,\n\t\t\t  \"error %d while loading snapshot (checkpoint number=%llu)\",\n\t\t\t  ret, (unsigned long long)cno);\n\t\tgoto out;\n\t}\n\tret = nilfs_get_root_dentry(s, root, root_dentry);\n\tnilfs_put_root(root);\n out:\n\tmutex_unlock(&nilfs->ns_snapshot_mount_mutex);\n\treturn ret;\n}\n\n \nstatic bool nilfs_tree_is_busy(struct dentry *root_dentry)\n{\n\tshrink_dcache_parent(root_dentry);\n\treturn d_count(root_dentry) > 1;\n}\n\nint nilfs_checkpoint_is_mounted(struct super_block *sb, __u64 cno)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tif (cno > nilfs->ns_cno)\n\t\treturn false;\n\n\tif (cno >= nilfs_last_cno(nilfs))\n\t\treturn true;\t \n\n\tret = false;\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root) {\n\t\tinode = nilfs_ilookup(sb, root, NILFS_ROOT_INO);\n\t\tif (inode) {\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (dentry) {\n\t\t\t\tret = nilfs_tree_is_busy(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t}\n\t\tnilfs_put_root(root);\n\t}\n\treturn ret;\n}\n\n \nstatic int\nnilfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct nilfs_root *fsroot;\n\t__u64 cno;\n\tint err;\n\n\tnilfs = alloc_nilfs(sb);\n\tif (!nilfs)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = nilfs;\n\n\terr = init_nilfs(nilfs, sb, (char *)data);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tsb->s_op = &nilfs_sops;\n\tsb->s_export_op = &nilfs_export_ops;\n\tsb->s_root = NULL;\n\tsb->s_time_gran = 1;\n\tsb->s_max_links = NILFS_LINK_MAX;\n\n\tsb->s_bdi = bdi_get(sb->s_bdev->bd_disk->bdi);\n\n\terr = load_nilfs(nilfs, sb);\n\tif (err)\n\t\tgoto failed_nilfs;\n\n\tcno = nilfs_last_cno(nilfs);\n\terr = nilfs_attach_checkpoint(sb, cno, true, &fsroot);\n\tif (err) {\n\t\tnilfs_err(sb,\n\t\t\t  \"error %d while loading last checkpoint (checkpoint number=%llu)\",\n\t\t\t  err, (unsigned long long)cno);\n\t\tgoto failed_unload;\n\t}\n\n\tif (!sb_rdonly(sb)) {\n\t\terr = nilfs_attach_log_writer(sb, fsroot);\n\t\tif (err)\n\t\t\tgoto failed_checkpoint;\n\t}\n\n\terr = nilfs_get_root_dentry(sb, fsroot, &sb->s_root);\n\tif (err)\n\t\tgoto failed_segctor;\n\n\tnilfs_put_root(fsroot);\n\n\tif (!sb_rdonly(sb)) {\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n\n\treturn 0;\n\n failed_segctor:\n\tnilfs_detach_log_writer(sb);\n\n failed_checkpoint:\n\tnilfs_put_root(fsroot);\n\n failed_unload:\n\tnilfs_sysfs_delete_device_group(nilfs);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_dat);\n\n failed_nilfs:\n\tdestroy_nilfs(nilfs);\n\treturn err;\n}\n\nstatic int nilfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tunsigned long old_sb_flags;\n\tunsigned long old_mount_opt;\n\tint err;\n\n\tsync_filesystem(sb);\n\told_sb_flags = sb->s_flags;\n\told_mount_opt = nilfs->ns_mount_opt;\n\n\tif (!parse_options(data, sb, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL);\n\n\terr = -EINVAL;\n\n\tif (!nilfs_valid_fs(nilfs)) {\n\t\tnilfs_warn(sb,\n\t\t\t   \"couldn't remount because the filesystem is in an incomplete recovery state\");\n\t\tgoto restore_opts;\n\t}\n\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\tgoto out;\n\tif (*flags & SB_RDONLY) {\n\t\tsb->s_flags |= SB_RDONLY;\n\n\t\t \n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_cleanup_super(sb);\n\t\tup_write(&nilfs->ns_sem);\n\t} else {\n\t\t__u64 features;\n\t\tstruct nilfs_root *root;\n\n\t\t \n\t\tdown_read(&nilfs->ns_sem);\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tup_read(&nilfs->ns_sem);\n\t\tif (features) {\n\t\t\tnilfs_warn(sb,\n\t\t\t\t   \"couldn't remount RDWR because of unsupported optional features (%llx)\",\n\t\t\t\t   (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tsb->s_flags &= ~SB_RDONLY;\n\n\t\troot = NILFS_I(d_inode(sb->s_root))->i_root;\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\n\t\tdown_write(&nilfs->ns_sem);\n\t\tnilfs_setup_super(sb, true);\n\t\tup_write(&nilfs->ns_sem);\n\t}\n out:\n\treturn 0;\n\n restore_opts:\n\tsb->s_flags = old_sb_flags;\n\tnilfs->ns_mount_opt = old_mount_opt;\n\treturn err;\n}\n\nstruct nilfs_super_data {\n\t__u64 cno;\n\tint flags;\n};\n\nstatic int nilfs_parse_snapshot_option(const char *option,\n\t\t\t\t       const substring_t *arg,\n\t\t\t\t       struct nilfs_super_data *sd)\n{\n\tunsigned long long val;\n\tconst char *msg = NULL;\n\tint err;\n\n\tif (!(sd->flags & SB_RDONLY)) {\n\t\tmsg = \"read-only option is not specified\";\n\t\tgoto parse_error;\n\t}\n\n\terr = kstrtoull(arg->from, 0, &val);\n\tif (err) {\n\t\tif (err == -ERANGE)\n\t\t\tmsg = \"too large checkpoint number\";\n\t\telse\n\t\t\tmsg = \"malformed argument\";\n\t\tgoto parse_error;\n\t} else if (val == 0) {\n\t\tmsg = \"invalid checkpoint number 0\";\n\t\tgoto parse_error;\n\t}\n\tsd->cno = val;\n\treturn 0;\n\nparse_error:\n\tnilfs_err(NULL, \"invalid option \\\"%s\\\": %s\", option, msg);\n\treturn 1;\n}\n\n \nstatic int nilfs_identify(char *data, struct nilfs_super_data *sd)\n{\n\tchar *p, *options = data;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tint ret = 0;\n\n\tdo {\n\t\tp = strsep(&options, \",\");\n\t\tif (p != NULL && *p) {\n\t\t\ttoken = match_token(p, tokens, args);\n\t\t\tif (token == Opt_snapshot)\n\t\t\t\tret = nilfs_parse_snapshot_option(p, &args[0],\n\t\t\t\t\t\t\t\t  sd);\n\t\t}\n\t\tif (!options)\n\t\t\tbreak;\n\t\tBUG_ON(options == data);\n\t\t*(options - 1) = ',';\n\t} while (!ret);\n\treturn ret;\n}\n\nstatic int nilfs_set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_dev = *(dev_t *)data;\n\treturn 0;\n}\n\nstatic int nilfs_test_bdev_super(struct super_block *s, void *data)\n{\n\treturn !(s->s_iflags & SB_I_RETIRED) && s->s_dev == *(dev_t *)data;\n}\n\nstatic struct dentry *\nnilfs_mount(struct file_system_type *fs_type, int flags,\n\t     const char *dev_name, void *data)\n{\n\tstruct nilfs_super_data sd = { .flags = flags };\n\tstruct super_block *s;\n\tdev_t dev;\n\tint err;\n\n\tif (nilfs_identify(data, &sd))\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = lookup_bdev(dev_name, &dev);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\ts = sget(fs_type, nilfs_test_bdev_super, nilfs_set_bdev_super, flags,\n\t\t &dev);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\tif (!s->s_root) {\n\t\t \n\t\tup_write(&s->s_umount);\n\t\terr = setup_bdev_super(s, flags, NULL);\n\t\tdown_write(&s->s_umount);\n\t\tif (!err)\n\t\t\terr = nilfs_fill_super(s, data,\n\t\t\t\t\t       flags & SB_SILENT ? 1 : 0);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else if (!sd.cno) {\n\t\tif (nilfs_tree_is_busy(s->s_root)) {\n\t\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {\n\t\t\t\tnilfs_err(s,\n\t\t\t\t\t  \"the device already has a %s mount.\",\n\t\t\t\t\t  sb_rdonly(s) ? \"read-only\" : \"read/write\");\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto failed_super;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\terr = nilfs_remount(s, &flags, data);\n\t\t\tif (err)\n\t\t\t\tgoto failed_super;\n\t\t}\n\t}\n\n\tif (sd.cno) {\n\t\tstruct dentry *root_dentry;\n\n\t\terr = nilfs_attach_snapshot(s, sd.cno, &root_dentry);\n\t\tif (err)\n\t\t\tgoto failed_super;\n\t\treturn root_dentry;\n\t}\n\n\treturn dget(s->s_root);\n\n failed_super:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(err);\n}\n\nstruct file_system_type nilfs_fs_type = {\n\t.owner    = THIS_MODULE,\n\t.name     = \"nilfs2\",\n\t.mount    = nilfs_mount,\n\t.kill_sb  = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"nilfs2\");\n\nstatic void nilfs_inode_init_once(void *obj)\n{\n\tstruct nilfs_inode_info *ii = obj;\n\n\tINIT_LIST_HEAD(&ii->i_dirty);\n#ifdef CONFIG_NILFS_XATTR\n\tinit_rwsem(&ii->xattr_sem);\n#endif\n\tinode_init_once(&ii->vfs_inode);\n}\n\nstatic void nilfs_segbuf_init_once(void *obj)\n{\n\tmemset(obj, 0, sizeof(struct nilfs_segment_buffer));\n}\n\nstatic void nilfs_destroy_cachep(void)\n{\n\t \n\trcu_barrier();\n\n\tkmem_cache_destroy(nilfs_inode_cachep);\n\tkmem_cache_destroy(nilfs_transaction_cachep);\n\tkmem_cache_destroy(nilfs_segbuf_cachep);\n\tkmem_cache_destroy(nilfs_btree_path_cache);\n}\n\nstatic int __init nilfs_init_cachep(void)\n{\n\tnilfs_inode_cachep = kmem_cache_create(\"nilfs2_inode_cache\",\n\t\t\tsizeof(struct nilfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_ACCOUNT,\n\t\t\tnilfs_inode_init_once);\n\tif (!nilfs_inode_cachep)\n\t\tgoto fail;\n\n\tnilfs_transaction_cachep = kmem_cache_create(\"nilfs2_transaction_cache\",\n\t\t\tsizeof(struct nilfs_transaction_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, NULL);\n\tif (!nilfs_transaction_cachep)\n\t\tgoto fail;\n\n\tnilfs_segbuf_cachep = kmem_cache_create(\"nilfs2_segbuf_cache\",\n\t\t\tsizeof(struct nilfs_segment_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT, nilfs_segbuf_init_once);\n\tif (!nilfs_segbuf_cachep)\n\t\tgoto fail;\n\n\tnilfs_btree_path_cache = kmem_cache_create(\"nilfs2_btree_path_cache\",\n\t\t\tsizeof(struct nilfs_btree_path) * NILFS_BTREE_LEVEL_MAX,\n\t\t\t0, 0, NULL);\n\tif (!nilfs_btree_path_cache)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tnilfs_destroy_cachep();\n\treturn -ENOMEM;\n}\n\nstatic int __init init_nilfs_fs(void)\n{\n\tint err;\n\n\terr = nilfs_init_cachep();\n\tif (err)\n\t\tgoto fail;\n\n\terr = nilfs_sysfs_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = register_filesystem(&nilfs_fs_type);\n\tif (err)\n\t\tgoto deinit_sysfs_entry;\n\n\tprintk(KERN_INFO \"NILFS version 2 loaded\\n\");\n\treturn 0;\n\ndeinit_sysfs_entry:\n\tnilfs_sysfs_exit();\nfree_cachep:\n\tnilfs_destroy_cachep();\nfail:\n\treturn err;\n}\n\nstatic void __exit exit_nilfs_fs(void)\n{\n\tnilfs_destroy_cachep();\n\tnilfs_sysfs_exit();\n\tunregister_filesystem(&nilfs_fs_type);\n}\n\nmodule_init(init_nilfs_fs)\nmodule_exit(exit_nilfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}