{
  "module_name": "file.c",
  "hash_id": "7e3a4dfcdf0b7f2c754f97cb431e40fbad87396b20ba7f4a73b40d09f7c3e7f1",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/file.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/writeback.h>\n#include \"nilfs.h\"\n#include \"segment.h\"\n\nint nilfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\t \n\tstruct the_nilfs *nilfs;\n\tstruct inode *inode = file->f_mapping->host;\n\tint err = 0;\n\n\tif (nilfs_inode_dirty(inode)) {\n\t\tif (datasync)\n\t\t\terr = nilfs_construct_dsync_segment(inode->i_sb, inode,\n\t\t\t\t\t\t\t    start, end);\n\t\telse\n\t\t\terr = nilfs_construct_segment(inode->i_sb);\n\t}\n\n\tnilfs = inode->i_sb->s_fs_info;\n\tif (!err)\n\t\terr = nilfs_flush_device(nilfs);\n\n\treturn err;\n}\n\nstatic vm_fault_t nilfs_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct nilfs_transaction_info ti;\n\tint ret = 0;\n\n\tif (unlikely(nilfs_near_disk_full(inode->i_sb->s_fs_info)))\n\t\treturn VM_FAULT_SIGBUS;  \n\n\tsb_start_pagefault(inode->i_sb);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping ||\n\t    page_offset(page) >= i_size_read(inode) || !PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tret = -EFAULT;\t \n\t\tgoto out;\n\t}\n\n\t \n\tif (PageMappedToDisk(page))\n\t\tgoto mapped;\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\t\tint fully_mapped = 1;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tfully_mapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (fully_mapped) {\n\t\t\tSetPageMappedToDisk(page);\n\t\t\tgoto mapped;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\t \n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 1);\n\t \n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tfile_update_time(vma->vm_file);\n\tret = block_page_mkwrite(vma, vmf, nilfs_get_block);\n\tif (ret) {\n\t\tnilfs_transaction_abort(inode->i_sb);\n\t\tgoto out;\n\t}\n\tnilfs_set_file_dirty(inode, 1 << (PAGE_SHIFT - inode->i_blkbits));\n\tnilfs_transaction_commit(inode->i_sb);\n\n mapped:\n\twait_for_stable_page(page);\n out:\n\tsb_end_pagefault(inode->i_sb);\n\treturn vmf_fs_error(ret);\n}\n\nstatic const struct vm_operations_struct nilfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= nilfs_page_mkwrite,\n};\n\nstatic int nilfs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tfile_accessed(file);\n\tvma->vm_ops = &nilfs_file_vm_ops;\n\treturn 0;\n}\n\n \nconst struct file_operations nilfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.unlocked_ioctl\t= nilfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= nilfs_compat_ioctl,\n#endif\t \n\t.mmap\t\t= nilfs_file_mmap,\n\t.open\t\t= generic_file_open,\n\t \n\t.fsync\t\t= nilfs_sync_file,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write   = iter_file_splice_write,\n};\n\nconst struct inode_operations nilfs_file_inode_operations = {\n\t.setattr\t= nilfs_setattr,\n\t.permission     = nilfs_permission,\n\t.fiemap\t\t= nilfs_fiemap,\n\t.fileattr_get\t= nilfs_fileattr_get,\n\t.fileattr_set\t= nilfs_fileattr_set,\n};\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}