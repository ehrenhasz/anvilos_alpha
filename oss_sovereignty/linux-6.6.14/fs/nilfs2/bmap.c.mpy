{
  "module_name": "bmap.c",
  "hash_id": "e031ffadb0fc8f0617ef9f70933490ce40618b0d1f383e17ebf9f4dc00032077",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/bmap.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include \"nilfs.h\"\n#include \"bmap.h\"\n#include \"btree.h\"\n#include \"direct.h\"\n#include \"btnode.h\"\n#include \"mdt.h\"\n#include \"dat.h\"\n#include \"alloc.h\"\n\nstruct inode *nilfs_bmap_get_dat(const struct nilfs_bmap *bmap)\n{\n\tstruct the_nilfs *nilfs = bmap->b_inode->i_sb->s_fs_info;\n\n\treturn nilfs->ns_dat;\n}\n\nstatic int nilfs_bmap_convert_error(struct nilfs_bmap *bmap,\n\t\t\t\t     const char *fname, int err)\n{\n\tstruct inode *inode = bmap->b_inode;\n\n\tif (err == -EINVAL) {\n\t\t__nilfs_error(inode->i_sb, fname,\n\t\t\t      \"broken bmap (inode number=%lu)\", inode->i_ino);\n\t\terr = -EIO;\n\t}\n\treturn err;\n}\n\n \nint nilfs_bmap_lookup_at_level(struct nilfs_bmap *bmap, __u64 key, int level,\n\t\t\t       __u64 *ptrp)\n{\n\tsector_t blocknr;\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup(bmap, key, level, ptrp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\tret = nilfs_dat_translate(nilfs_bmap_get_dat(bmap), *ptrp,\n\t\t\t\t\t  &blocknr);\n\t\tif (!ret)\n\t\t\t*ptrp = blocknr;\n\t\telse if (ret == -ENOENT) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n out:\n\tup_read(&bmap->b_sem);\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\nint nilfs_bmap_lookup_contig(struct nilfs_bmap *bmap, __u64 key, __u64 *ptrp,\n\t\t\t     unsigned int maxblocks)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_lookup_contig(bmap, key, ptrp, maxblocks);\n\tup_read(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\nstatic int nilfs_bmap_do_insert(struct nilfs_bmap *bmap, __u64 key, __u64 ptr)\n{\n\t__u64 keys[NILFS_BMAP_SMALL_HIGH + 1];\n\t__u64 ptrs[NILFS_BMAP_SMALL_HIGH + 1];\n\tint ret, n;\n\n\tif (bmap->b_ops->bop_check_insert != NULL) {\n\t\tret = bmap->b_ops->bop_check_insert(bmap, key);\n\t\tif (ret > 0) {\n\t\t\tn = bmap->b_ops->bop_gather_data(\n\t\t\t\tbmap, keys, ptrs, NILFS_BMAP_SMALL_HIGH + 1);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\t\t\tret = nilfs_btree_convert_and_insert(\n\t\t\t\tbmap, key, ptr, keys, ptrs, n);\n\t\t\tif (ret == 0)\n\t\t\t\tbmap->b_u.u_flags |= NILFS_BMAP_LARGE;\n\n\t\t\treturn ret;\n\t\t} else if (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn bmap->b_ops->bop_insert(bmap, key, ptr);\n}\n\n \nint nilfs_bmap_insert(struct nilfs_bmap *bmap, __u64 key, unsigned long rec)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_insert(bmap, key, rec);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\nstatic int nilfs_bmap_do_delete(struct nilfs_bmap *bmap, __u64 key)\n{\n\t__u64 keys[NILFS_BMAP_LARGE_LOW + 1];\n\t__u64 ptrs[NILFS_BMAP_LARGE_LOW + 1];\n\tint ret, n;\n\n\tif (bmap->b_ops->bop_check_delete != NULL) {\n\t\tret = bmap->b_ops->bop_check_delete(bmap, key);\n\t\tif (ret > 0) {\n\t\t\tn = bmap->b_ops->bop_gather_data(\n\t\t\t\tbmap, keys, ptrs, NILFS_BMAP_LARGE_LOW + 1);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\t\t\tret = nilfs_direct_delete_and_convert(\n\t\t\t\tbmap, key, keys, ptrs, n);\n\t\t\tif (ret == 0)\n\t\t\t\tbmap->b_u.u_flags &= ~NILFS_BMAP_LARGE;\n\n\t\t\treturn ret;\n\t\t} else if (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn bmap->b_ops->bop_delete(bmap, key);\n}\n\n \nint nilfs_bmap_seek_key(struct nilfs_bmap *bmap, __u64 start, __u64 *keyp)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_seek_key(bmap, start, keyp);\n\tup_read(&bmap->b_sem);\n\n\tif (ret < 0)\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\treturn ret;\n}\n\nint nilfs_bmap_last_key(struct nilfs_bmap *bmap, __u64 *keyp)\n{\n\tint ret;\n\n\tdown_read(&bmap->b_sem);\n\tret = bmap->b_ops->bop_last_key(bmap, keyp);\n\tup_read(&bmap->b_sem);\n\n\tif (ret < 0)\n\t\tret = nilfs_bmap_convert_error(bmap, __func__, ret);\n\treturn ret;\n}\n\n \nint nilfs_bmap_delete(struct nilfs_bmap *bmap, __u64 key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_delete(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\nstatic int nilfs_bmap_do_truncate(struct nilfs_bmap *bmap, __u64 key)\n{\n\t__u64 lastkey;\n\tint ret;\n\n\tret = bmap->b_ops->bop_last_key(bmap, &lastkey);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\twhile (key <= lastkey) {\n\t\tret = nilfs_bmap_do_delete(bmap, lastkey);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = bmap->b_ops->bop_last_key(bmap, &lastkey);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint nilfs_bmap_truncate(struct nilfs_bmap *bmap, __u64 key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_truncate(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\n \nvoid nilfs_bmap_clear(struct nilfs_bmap *bmap)\n{\n\tdown_write(&bmap->b_sem);\n\tif (bmap->b_ops->bop_clear != NULL)\n\t\tbmap->b_ops->bop_clear(bmap);\n\tup_write(&bmap->b_sem);\n}\n\n \nint nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\n \nvoid nilfs_bmap_lookup_dirty_buffers(struct nilfs_bmap *bmap,\n\t\t\t\t     struct list_head *listp)\n{\n\tif (bmap->b_ops->bop_lookup_dirty_buffers != NULL)\n\t\tbmap->b_ops->bop_lookup_dirty_buffers(bmap, listp);\n}\n\n \nint nilfs_bmap_assign(struct nilfs_bmap *bmap,\n\t\t      struct buffer_head **bh,\n\t\t      unsigned long blocknr,\n\t\t      union nilfs_binfo *binfo)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_assign(bmap, bh, blocknr, binfo);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\n \nint nilfs_bmap_mark(struct nilfs_bmap *bmap, __u64 key, int level)\n{\n\tint ret;\n\n\tif (bmap->b_ops->bop_mark == NULL)\n\t\treturn 0;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_mark(bmap, key, level);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}\n\n \nint nilfs_bmap_test_and_clear_dirty(struct nilfs_bmap *bmap)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_dirty(bmap);\n\tnilfs_bmap_clear_dirty(bmap);\n\tup_write(&bmap->b_sem);\n\treturn ret;\n}\n\n\n \n__u64 nilfs_bmap_data_get_key(const struct nilfs_bmap *bmap,\n\t\t\t      const struct buffer_head *bh)\n{\n\tstruct buffer_head *pbh;\n\t__u64 key;\n\n\tkey = page_index(bh->b_page) << (PAGE_SHIFT -\n\t\t\t\t\t bmap->b_inode->i_blkbits);\n\tfor (pbh = page_buffers(bh->b_page); pbh != bh; pbh = pbh->b_this_page)\n\t\tkey++;\n\n\treturn key;\n}\n\n__u64 nilfs_bmap_find_target_seq(const struct nilfs_bmap *bmap, __u64 key)\n{\n\t__s64 diff;\n\n\tdiff = key - bmap->b_last_allocated_key;\n\tif ((nilfs_bmap_keydiff_abs(diff) < NILFS_INODE_BMAP_SIZE) &&\n\t    (bmap->b_last_allocated_ptr != NILFS_BMAP_INVALID_PTR) &&\n\t    (bmap->b_last_allocated_ptr + diff > 0))\n\t\treturn bmap->b_last_allocated_ptr + diff;\n\telse\n\t\treturn NILFS_BMAP_INVALID_PTR;\n}\n\n#define NILFS_BMAP_GROUP_DIV\t8\n__u64 nilfs_bmap_find_target_in_group(const struct nilfs_bmap *bmap)\n{\n\tstruct inode *dat = nilfs_bmap_get_dat(bmap);\n\tunsigned long entries_per_group = nilfs_palloc_entries_per_group(dat);\n\tunsigned long group = bmap->b_inode->i_ino / entries_per_group;\n\n\treturn group * entries_per_group +\n\t\t(bmap->b_inode->i_ino % NILFS_BMAP_GROUP_DIV) *\n\t\t(entries_per_group / NILFS_BMAP_GROUP_DIV);\n}\n\nstatic struct lock_class_key nilfs_bmap_dat_lock_key;\nstatic struct lock_class_key nilfs_bmap_mdt_lock_key;\n\n \nint nilfs_bmap_read(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tif (raw_inode == NULL)\n\t\tmemset(bmap->b_u.u_data, 0, NILFS_BMAP_SIZE);\n\telse\n\t\tmemcpy(bmap->b_u.u_data, raw_inode->i_bmap, NILFS_BMAP_SIZE);\n\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_state = 0;\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tswitch (bmap->b_inode->i_ino) {\n\tcase NILFS_DAT_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_P;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_dat_lock_key);\n\t\tbreak;\n\tcase NILFS_CPFILE_INO:\n\tcase NILFS_SUFILE_INO:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VS;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tbreak;\n\tcase NILFS_IFILE_INO:\n\t\tlockdep_set_class(&bmap->b_sem, &nilfs_bmap_mdt_lock_key);\n\t\tfallthrough;\n\tdefault:\n\t\tbmap->b_ptr_type = NILFS_BMAP_PTR_VM;\n\t\tbmap->b_last_allocated_key = 0;\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tbreak;\n\t}\n\n\treturn (bmap->b_u.u_flags & NILFS_BMAP_LARGE) ?\n\t\tnilfs_btree_init(bmap) : nilfs_direct_init(bmap);\n}\n\n \nvoid nilfs_bmap_write(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tdown_write(&bmap->b_sem);\n\tmemcpy(raw_inode->i_bmap, bmap->b_u.u_data,\n\t       NILFS_INODE_BMAP_SIZE * sizeof(__le64));\n\tif (bmap->b_inode->i_ino == NILFS_DAT_INO)\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\n\tup_write(&bmap->b_sem);\n}\n\nvoid nilfs_bmap_init_gc(struct nilfs_bmap *bmap)\n{\n\tmemset(&bmap->b_u, 0, NILFS_BMAP_SIZE);\n\tinit_rwsem(&bmap->b_sem);\n\tbmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;\n\tbmap->b_ptr_type = NILFS_BMAP_PTR_U;\n\tbmap->b_last_allocated_key = 0;\n\tbmap->b_last_allocated_ptr = NILFS_BMAP_INVALID_PTR;\n\tbmap->b_state = 0;\n\tnilfs_btree_init_gc(bmap);\n}\n\nvoid nilfs_bmap_save(const struct nilfs_bmap *bmap,\n\t\t     struct nilfs_bmap_store *store)\n{\n\tmemcpy(store->data, bmap->b_u.u_data, sizeof(store->data));\n\tstore->last_allocated_key = bmap->b_last_allocated_key;\n\tstore->last_allocated_ptr = bmap->b_last_allocated_ptr;\n\tstore->state = bmap->b_state;\n}\n\nvoid nilfs_bmap_restore(struct nilfs_bmap *bmap,\n\t\t\tconst struct nilfs_bmap_store *store)\n{\n\tmemcpy(bmap->b_u.u_data, store->data, sizeof(store->data));\n\tbmap->b_last_allocated_key = store->last_allocated_key;\n\tbmap->b_last_allocated_ptr = store->last_allocated_ptr;\n\tbmap->b_state = store->state;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}