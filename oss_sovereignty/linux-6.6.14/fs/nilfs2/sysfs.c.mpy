{
  "module_name": "sysfs.c",
  "hash_id": "4f1cfa8b9454fcab3120f09d1ead99aab05d207aae6f0af369206e5f84dea79f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kobject.h>\n\n#include \"nilfs.h\"\n#include \"mdt.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"sysfs.h\"\n\n \nstatic struct kset *nilfs_kset;\n\n#define NILFS_DEV_INT_GROUP_OPS(name, parent_name) \\\nstatic ssize_t nilfs_##name##_attr_show(struct kobject *kobj, \\\n\t\t\t\t\tstruct attribute *attr, char *buf) \\\n{ \\\n\tstruct the_nilfs *nilfs = container_of(kobj->parent, \\\n\t\t\t\t\t\tstruct the_nilfs, \\\n\t\t\t\t\t\tns_##parent_name##_kobj); \\\n\tstruct nilfs_##name##_attr *a = container_of(attr, \\\n\t\t\t\t\t\tstruct nilfs_##name##_attr, \\\n\t\t\t\t\t\tattr); \\\n\treturn a->show ? a->show(a, nilfs, buf) : 0; \\\n} \\\nstatic ssize_t nilfs_##name##_attr_store(struct kobject *kobj, \\\n\t\t\t\t\t struct attribute *attr, \\\n\t\t\t\t\t const char *buf, size_t len) \\\n{ \\\n\tstruct the_nilfs *nilfs = container_of(kobj->parent, \\\n\t\t\t\t\t\tstruct the_nilfs, \\\n\t\t\t\t\t\tns_##parent_name##_kobj); \\\n\tstruct nilfs_##name##_attr *a = container_of(attr, \\\n\t\t\t\t\t\tstruct nilfs_##name##_attr, \\\n\t\t\t\t\t\tattr); \\\n\treturn a->store ? a->store(a, nilfs, buf, len) : 0; \\\n} \\\nstatic const struct sysfs_ops nilfs_##name##_attr_ops = { \\\n\t.show\t= nilfs_##name##_attr_show, \\\n\t.store\t= nilfs_##name##_attr_store, \\\n}\n\n#define NILFS_DEV_INT_GROUP_TYPE(name, parent_name) \\\nstatic void nilfs_##name##_attr_release(struct kobject *kobj) \\\n{ \\\n\tstruct nilfs_sysfs_##parent_name##_subgroups *subgroups = container_of(kobj, \\\n\t\t\t\t\t\tstruct nilfs_sysfs_##parent_name##_subgroups, \\\n\t\t\t\t\t\tsg_##name##_kobj); \\\n\tcomplete(&subgroups->sg_##name##_kobj_unregister); \\\n} \\\nstatic struct kobj_type nilfs_##name##_ktype = { \\\n\t.default_groups\t= nilfs_##name##_groups, \\\n\t.sysfs_ops\t= &nilfs_##name##_attr_ops, \\\n\t.release\t= nilfs_##name##_attr_release, \\\n}\n\n#define NILFS_DEV_INT_GROUP_FNS(name, parent_name) \\\nstatic int nilfs_sysfs_create_##name##_group(struct the_nilfs *nilfs) \\\n{ \\\n\tstruct kobject *parent; \\\n\tstruct kobject *kobj; \\\n\tstruct completion *kobj_unregister; \\\n\tstruct nilfs_sysfs_##parent_name##_subgroups *subgroups; \\\n\tint err; \\\n\tsubgroups = nilfs->ns_##parent_name##_subgroups; \\\n\tkobj = &subgroups->sg_##name##_kobj; \\\n\tkobj_unregister = &subgroups->sg_##name##_kobj_unregister; \\\n\tparent = &nilfs->ns_##parent_name##_kobj; \\\n\tkobj->kset = nilfs_kset; \\\n\tinit_completion(kobj_unregister); \\\n\terr = kobject_init_and_add(kobj, &nilfs_##name##_ktype, parent, \\\n\t\t\t\t    #name); \\\n\tif (err) \\\n\t\tkobject_put(kobj); \\\n\treturn err; \\\n} \\\nstatic void nilfs_sysfs_delete_##name##_group(struct the_nilfs *nilfs) \\\n{ \\\n\tkobject_put(&nilfs->ns_##parent_name##_subgroups->sg_##name##_kobj); \\\n}\n\n \n\nstatic ssize_t\nnilfs_snapshot_inodes_count_show(struct nilfs_snapshot_attr *attr,\n\t\t\t\t struct nilfs_root *root, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)atomic64_read(&root->inodes_count));\n}\n\nstatic ssize_t\nnilfs_snapshot_blocks_count_show(struct nilfs_snapshot_attr *attr,\n\t\t\t\t struct nilfs_root *root, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)atomic64_read(&root->blocks_count));\n}\n\nstatic const char snapshot_readme_str[] =\n\t\"The group contains details about mounted snapshot.\\n\\n\"\n\t\"(1) inodes_count\\n\\tshow number of inodes for snapshot.\\n\\n\"\n\t\"(2) blocks_count\\n\\tshow number of blocks for snapshot.\\n\\n\";\n\nstatic ssize_t\nnilfs_snapshot_README_show(struct nilfs_snapshot_attr *attr,\n\t\t\t    struct nilfs_root *root, char *buf)\n{\n\treturn sysfs_emit(buf, snapshot_readme_str);\n}\n\nNILFS_SNAPSHOT_RO_ATTR(inodes_count);\nNILFS_SNAPSHOT_RO_ATTR(blocks_count);\nNILFS_SNAPSHOT_RO_ATTR(README);\n\nstatic struct attribute *nilfs_snapshot_attrs[] = {\n\tNILFS_SNAPSHOT_ATTR_LIST(inodes_count),\n\tNILFS_SNAPSHOT_ATTR_LIST(blocks_count),\n\tNILFS_SNAPSHOT_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_snapshot);\n\nstatic ssize_t nilfs_snapshot_attr_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct nilfs_root *root =\n\t\t\tcontainer_of(kobj, struct nilfs_root, snapshot_kobj);\n\tstruct nilfs_snapshot_attr *a =\n\t\t\tcontainer_of(attr, struct nilfs_snapshot_attr, attr);\n\n\treturn a->show ? a->show(a, root, buf) : 0;\n}\n\nstatic ssize_t nilfs_snapshot_attr_store(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct nilfs_root *root =\n\t\t\tcontainer_of(kobj, struct nilfs_root, snapshot_kobj);\n\tstruct nilfs_snapshot_attr *a =\n\t\t\tcontainer_of(attr, struct nilfs_snapshot_attr, attr);\n\n\treturn a->store ? a->store(a, root, buf, len) : 0;\n}\n\nstatic void nilfs_snapshot_attr_release(struct kobject *kobj)\n{\n\tstruct nilfs_root *root = container_of(kobj, struct nilfs_root,\n\t\t\t\t\t\tsnapshot_kobj);\n\tcomplete(&root->snapshot_kobj_unregister);\n}\n\nstatic const struct sysfs_ops nilfs_snapshot_attr_ops = {\n\t.show\t= nilfs_snapshot_attr_show,\n\t.store\t= nilfs_snapshot_attr_store,\n};\n\nstatic struct kobj_type nilfs_snapshot_ktype = {\n\t.default_groups\t= nilfs_snapshot_groups,\n\t.sysfs_ops\t= &nilfs_snapshot_attr_ops,\n\t.release\t= nilfs_snapshot_attr_release,\n};\n\nint nilfs_sysfs_create_snapshot_group(struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs;\n\tstruct kobject *parent;\n\tint err;\n\n\tnilfs = root->nilfs;\n\tparent = &nilfs->ns_dev_subgroups->sg_mounted_snapshots_kobj;\n\troot->snapshot_kobj.kset = nilfs_kset;\n\tinit_completion(&root->snapshot_kobj_unregister);\n\n\tif (root->cno == NILFS_CPTREE_CURRENT_CNO) {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    &nilfs->ns_dev_kobj,\n\t\t\t\t\t    \"current_checkpoint\");\n\t} else {\n\t\terr = kobject_init_and_add(&root->snapshot_kobj,\n\t\t\t\t\t    &nilfs_snapshot_ktype,\n\t\t\t\t\t    parent,\n\t\t\t\t\t    \"%llu\", root->cno);\n\t}\n\n\tif (err)\n\t\tkobject_put(&root->snapshot_kobj);\n\n\treturn err;\n}\n\nvoid nilfs_sysfs_delete_snapshot_group(struct nilfs_root *root)\n{\n\tkobject_put(&root->snapshot_kobj);\n}\n\n \n\nstatic const char mounted_snapshots_readme_str[] =\n\t\"The mounted_snapshots group contains group for\\n\"\n\t\"every mounted snapshot.\\n\";\n\nstatic ssize_t\nnilfs_mounted_snapshots_README_show(struct nilfs_mounted_snapshots_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs, char *buf)\n{\n\treturn sysfs_emit(buf, mounted_snapshots_readme_str);\n}\n\nNILFS_MOUNTED_SNAPSHOTS_RO_ATTR(README);\n\nstatic struct attribute *nilfs_mounted_snapshots_attrs[] = {\n\tNILFS_MOUNTED_SNAPSHOTS_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_mounted_snapshots);\n\nNILFS_DEV_INT_GROUP_OPS(mounted_snapshots, dev);\nNILFS_DEV_INT_GROUP_TYPE(mounted_snapshots, dev);\nNILFS_DEV_INT_GROUP_FNS(mounted_snapshots, dev);\n\n \n\nstatic ssize_t\nnilfs_checkpoints_checkpoints_number_show(struct nilfs_checkpoints_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    char *buf)\n{\n\t__u64 ncheckpoints;\n\tstruct nilfs_cpstat cpstat;\n\tint err;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (err < 0) {\n\t\tnilfs_err(nilfs->ns_sb, \"unable to get checkpoint stat: err=%d\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tncheckpoints = cpstat.cs_ncps;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", ncheckpoints);\n}\n\nstatic ssize_t\nnilfs_checkpoints_snapshots_number_show(struct nilfs_checkpoints_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\t__u64 nsnapshots;\n\tstruct nilfs_cpstat cpstat;\n\tint err;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_cpfile_get_stat(nilfs->ns_cpfile, &cpstat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (err < 0) {\n\t\tnilfs_err(nilfs->ns_sb, \"unable to get checkpoint stat: err=%d\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tnsnapshots = cpstat.cs_nsss;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", nsnapshots);\n}\n\nstatic ssize_t\nnilfs_checkpoints_last_seg_checkpoint_show(struct nilfs_checkpoints_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    char *buf)\n{\n\t__u64 last_cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tlast_cno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", last_cno);\n}\n\nstatic ssize_t\nnilfs_checkpoints_next_checkpoint_show(struct nilfs_checkpoints_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\t__u64 cno;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tcno = nilfs->ns_cno;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", cno);\n}\n\nstatic const char checkpoints_readme_str[] =\n\t\"The checkpoints group contains attributes that describe\\n\"\n\t\"details about volume's checkpoints.\\n\\n\"\n\t\"(1) checkpoints_number\\n\\tshow number of checkpoints on volume.\\n\\n\"\n\t\"(2) snapshots_number\\n\\tshow number of snapshots on volume.\\n\\n\"\n\t\"(3) last_seg_checkpoint\\n\"\n\t\"\\tshow checkpoint number of the latest segment.\\n\\n\"\n\t\"(4) next_checkpoint\\n\\tshow next checkpoint number.\\n\\n\";\n\nstatic ssize_t\nnilfs_checkpoints_README_show(struct nilfs_checkpoints_attr *attr,\n\t\t\t\tstruct the_nilfs *nilfs, char *buf)\n{\n\treturn sysfs_emit(buf, checkpoints_readme_str);\n}\n\nNILFS_CHECKPOINTS_RO_ATTR(checkpoints_number);\nNILFS_CHECKPOINTS_RO_ATTR(snapshots_number);\nNILFS_CHECKPOINTS_RO_ATTR(last_seg_checkpoint);\nNILFS_CHECKPOINTS_RO_ATTR(next_checkpoint);\nNILFS_CHECKPOINTS_RO_ATTR(README);\n\nstatic struct attribute *nilfs_checkpoints_attrs[] = {\n\tNILFS_CHECKPOINTS_ATTR_LIST(checkpoints_number),\n\tNILFS_CHECKPOINTS_ATTR_LIST(snapshots_number),\n\tNILFS_CHECKPOINTS_ATTR_LIST(last_seg_checkpoint),\n\tNILFS_CHECKPOINTS_ATTR_LIST(next_checkpoint),\n\tNILFS_CHECKPOINTS_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_checkpoints);\n\nNILFS_DEV_INT_GROUP_OPS(checkpoints, dev);\nNILFS_DEV_INT_GROUP_TYPE(checkpoints, dev);\nNILFS_DEV_INT_GROUP_FNS(checkpoints, dev);\n\n \n\nstatic ssize_t\nnilfs_segments_segments_number_show(struct nilfs_segments_attr *attr,\n\t\t\t\t     struct the_nilfs *nilfs,\n\t\t\t\t     char *buf)\n{\n\treturn sysfs_emit(buf, \"%lu\\n\", nilfs->ns_nsegments);\n}\n\nstatic ssize_t\nnilfs_segments_blocks_per_segment_show(struct nilfs_segments_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%lu\\n\", nilfs->ns_blocks_per_segment);\n}\n\nstatic ssize_t\nnilfs_segments_clean_segments_show(struct nilfs_segments_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t    char *buf)\n{\n\tunsigned long ncleansegs;\n\n\tdown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", ncleansegs);\n}\n\nstatic ssize_t\nnilfs_segments_dirty_segments_show(struct nilfs_segments_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t    char *buf)\n{\n\tstruct nilfs_sustat sustat;\n\tint err;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\terr = nilfs_sufile_get_stat(nilfs->ns_sufile, &sustat);\n\tup_read(&nilfs->ns_segctor_sem);\n\tif (err < 0) {\n\t\tnilfs_err(nilfs->ns_sb, \"unable to get segment stat: err=%d\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\treturn sysfs_emit(buf, \"%llu\\n\", sustat.ss_ndirtysegs);\n}\n\nstatic const char segments_readme_str[] =\n\t\"The segments group contains attributes that describe\\n\"\n\t\"details about volume's segments.\\n\\n\"\n\t\"(1) segments_number\\n\\tshow number of segments on volume.\\n\\n\"\n\t\"(2) blocks_per_segment\\n\\tshow number of blocks in segment.\\n\\n\"\n\t\"(3) clean_segments\\n\\tshow count of clean segments.\\n\\n\"\n\t\"(4) dirty_segments\\n\\tshow count of dirty segments.\\n\\n\";\n\nstatic ssize_t\nnilfs_segments_README_show(struct nilfs_segments_attr *attr,\n\t\t\t    struct the_nilfs *nilfs,\n\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, segments_readme_str);\n}\n\nNILFS_SEGMENTS_RO_ATTR(segments_number);\nNILFS_SEGMENTS_RO_ATTR(blocks_per_segment);\nNILFS_SEGMENTS_RO_ATTR(clean_segments);\nNILFS_SEGMENTS_RO_ATTR(dirty_segments);\nNILFS_SEGMENTS_RO_ATTR(README);\n\nstatic struct attribute *nilfs_segments_attrs[] = {\n\tNILFS_SEGMENTS_ATTR_LIST(segments_number),\n\tNILFS_SEGMENTS_ATTR_LIST(blocks_per_segment),\n\tNILFS_SEGMENTS_ATTR_LIST(clean_segments),\n\tNILFS_SEGMENTS_ATTR_LIST(dirty_segments),\n\tNILFS_SEGMENTS_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_segments);\n\nNILFS_DEV_INT_GROUP_OPS(segments, dev);\nNILFS_DEV_INT_GROUP_TYPE(segments, dev);\nNILFS_DEV_INT_GROUP_FNS(segments, dev);\n\n \n\nstatic ssize_t\nnilfs_segctor_last_pseg_block_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t    char *buf)\n{\n\tsector_t last_pseg;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tlast_pseg = nilfs->ns_last_pseg;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)last_pseg);\n}\n\nstatic ssize_t\nnilfs_segctor_last_seg_sequence_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\tu64 last_seq;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tlast_seq = nilfs->ns_last_seq;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", last_seq);\n}\n\nstatic ssize_t\nnilfs_segctor_last_seg_checkpoint_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\t__u64 last_cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tlast_cno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", last_cno);\n}\n\nstatic ssize_t\nnilfs_segctor_current_seg_sequence_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\tu64 seg_seq;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tseg_seq = nilfs->ns_seg_seq;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", seg_seq);\n}\n\nstatic ssize_t\nnilfs_segctor_current_last_full_seg_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\t struct the_nilfs *nilfs,\n\t\t\t\t\t char *buf)\n{\n\t__u64 segnum;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tsegnum = nilfs->ns_segnum;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", segnum);\n}\n\nstatic ssize_t\nnilfs_segctor_next_full_seg_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t struct the_nilfs *nilfs,\n\t\t\t\t char *buf)\n{\n\t__u64 nextnum;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tnextnum = nilfs->ns_nextnum;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", nextnum);\n}\n\nstatic ssize_t\nnilfs_segctor_next_pseg_offset_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned long pseg_offset;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tpseg_offset = nilfs->ns_pseg_offset;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", pseg_offset);\n}\n\nstatic ssize_t\nnilfs_segctor_next_checkpoint_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\t__u64 cno;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tcno = nilfs->ns_cno;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", cno);\n}\n\nstatic ssize_t\nnilfs_segctor_last_seg_write_time_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\tchar *buf)\n{\n\ttime64_t ctime;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tctime = nilfs->ns_ctime;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%ptTs\\n\", &ctime);\n}\n\nstatic ssize_t\nnilfs_segctor_last_seg_write_time_secs_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    char *buf)\n{\n\ttime64_t ctime;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tctime = nilfs->ns_ctime;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", ctime);\n}\n\nstatic ssize_t\nnilfs_segctor_last_nongc_write_time_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\t struct the_nilfs *nilfs,\n\t\t\t\t\t char *buf)\n{\n\ttime64_t nongc_ctime;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tnongc_ctime = nilfs->ns_nongc_ctime;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%ptTs\\n\", &nongc_ctime);\n}\n\nstatic ssize_t\nnilfs_segctor_last_nongc_write_time_secs_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\t\t\tchar *buf)\n{\n\ttime64_t nongc_ctime;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tnongc_ctime = nilfs->ns_nongc_ctime;\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", nongc_ctime);\n}\n\nstatic ssize_t\nnilfs_segctor_dirty_data_blocks_count_show(struct nilfs_segctor_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    char *buf)\n{\n\tu32 ndirtyblks;\n\n\tdown_read(&nilfs->ns_segctor_sem);\n\tndirtyblks = atomic_read(&nilfs->ns_ndirtyblks);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\treturn sysfs_emit(buf, \"%u\\n\", ndirtyblks);\n}\n\nstatic const char segctor_readme_str[] =\n\t\"The segctor group contains attributes that describe\\n\"\n\t\"segctor thread activity details.\\n\\n\"\n\t\"(1) last_pseg_block\\n\"\n\t\"\\tshow start block number of the latest segment.\\n\\n\"\n\t\"(2) last_seg_sequence\\n\"\n\t\"\\tshow sequence value of the latest segment.\\n\\n\"\n\t\"(3) last_seg_checkpoint\\n\"\n\t\"\\tshow checkpoint number of the latest segment.\\n\\n\"\n\t\"(4) current_seg_sequence\\n\\tshow segment sequence counter.\\n\\n\"\n\t\"(5) current_last_full_seg\\n\"\n\t\"\\tshow index number of the latest full segment.\\n\\n\"\n\t\"(6) next_full_seg\\n\"\n\t\"\\tshow index number of the full segment index to be used next.\\n\\n\"\n\t\"(7) next_pseg_offset\\n\"\n\t\"\\tshow offset of next partial segment in the current full segment.\\n\\n\"\n\t\"(8) next_checkpoint\\n\\tshow next checkpoint number.\\n\\n\"\n\t\"(9) last_seg_write_time\\n\"\n\t\"\\tshow write time of the last segment in human-readable format.\\n\\n\"\n\t\"(10) last_seg_write_time_secs\\n\"\n\t\"\\tshow write time of the last segment in seconds.\\n\\n\"\n\t\"(11) last_nongc_write_time\\n\"\n\t\"\\tshow write time of the last segment not for cleaner operation \"\n\t\"in human-readable format.\\n\\n\"\n\t\"(12) last_nongc_write_time_secs\\n\"\n\t\"\\tshow write time of the last segment not for cleaner operation \"\n\t\"in seconds.\\n\\n\"\n\t\"(13) dirty_data_blocks_count\\n\"\n\t\"\\tshow number of dirty data blocks.\\n\\n\";\n\nstatic ssize_t\nnilfs_segctor_README_show(struct nilfs_segctor_attr *attr,\n\t\t\t  struct the_nilfs *nilfs, char *buf)\n{\n\treturn sysfs_emit(buf, segctor_readme_str);\n}\n\nNILFS_SEGCTOR_RO_ATTR(last_pseg_block);\nNILFS_SEGCTOR_RO_ATTR(last_seg_sequence);\nNILFS_SEGCTOR_RO_ATTR(last_seg_checkpoint);\nNILFS_SEGCTOR_RO_ATTR(current_seg_sequence);\nNILFS_SEGCTOR_RO_ATTR(current_last_full_seg);\nNILFS_SEGCTOR_RO_ATTR(next_full_seg);\nNILFS_SEGCTOR_RO_ATTR(next_pseg_offset);\nNILFS_SEGCTOR_RO_ATTR(next_checkpoint);\nNILFS_SEGCTOR_RO_ATTR(last_seg_write_time);\nNILFS_SEGCTOR_RO_ATTR(last_seg_write_time_secs);\nNILFS_SEGCTOR_RO_ATTR(last_nongc_write_time);\nNILFS_SEGCTOR_RO_ATTR(last_nongc_write_time_secs);\nNILFS_SEGCTOR_RO_ATTR(dirty_data_blocks_count);\nNILFS_SEGCTOR_RO_ATTR(README);\n\nstatic struct attribute *nilfs_segctor_attrs[] = {\n\tNILFS_SEGCTOR_ATTR_LIST(last_pseg_block),\n\tNILFS_SEGCTOR_ATTR_LIST(last_seg_sequence),\n\tNILFS_SEGCTOR_ATTR_LIST(last_seg_checkpoint),\n\tNILFS_SEGCTOR_ATTR_LIST(current_seg_sequence),\n\tNILFS_SEGCTOR_ATTR_LIST(current_last_full_seg),\n\tNILFS_SEGCTOR_ATTR_LIST(next_full_seg),\n\tNILFS_SEGCTOR_ATTR_LIST(next_pseg_offset),\n\tNILFS_SEGCTOR_ATTR_LIST(next_checkpoint),\n\tNILFS_SEGCTOR_ATTR_LIST(last_seg_write_time),\n\tNILFS_SEGCTOR_ATTR_LIST(last_seg_write_time_secs),\n\tNILFS_SEGCTOR_ATTR_LIST(last_nongc_write_time),\n\tNILFS_SEGCTOR_ATTR_LIST(last_nongc_write_time_secs),\n\tNILFS_SEGCTOR_ATTR_LIST(dirty_data_blocks_count),\n\tNILFS_SEGCTOR_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_segctor);\n\nNILFS_DEV_INT_GROUP_OPS(segctor, dev);\nNILFS_DEV_INT_GROUP_TYPE(segctor, dev);\nNILFS_DEV_INT_GROUP_FNS(segctor, dev);\n\n \n\nstatic ssize_t\nnilfs_superblock_sb_write_time_show(struct nilfs_superblock_attr *attr,\n\t\t\t\t     struct the_nilfs *nilfs,\n\t\t\t\t     char *buf)\n{\n\ttime64_t sbwtime;\n\n\tdown_read(&nilfs->ns_sem);\n\tsbwtime = nilfs->ns_sbwtime;\n\tup_read(&nilfs->ns_sem);\n\n\treturn sysfs_emit(buf, \"%ptTs\\n\", &sbwtime);\n}\n\nstatic ssize_t\nnilfs_superblock_sb_write_time_secs_show(struct nilfs_superblock_attr *attr,\n\t\t\t\t\t struct the_nilfs *nilfs,\n\t\t\t\t\t char *buf)\n{\n\ttime64_t sbwtime;\n\n\tdown_read(&nilfs->ns_sem);\n\tsbwtime = nilfs->ns_sbwtime;\n\tup_read(&nilfs->ns_sem);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", sbwtime);\n}\n\nstatic ssize_t\nnilfs_superblock_sb_write_count_show(struct nilfs_superblock_attr *attr,\n\t\t\t\t      struct the_nilfs *nilfs,\n\t\t\t\t      char *buf)\n{\n\tunsigned int sbwcount;\n\n\tdown_read(&nilfs->ns_sem);\n\tsbwcount = nilfs->ns_sbwcount;\n\tup_read(&nilfs->ns_sem);\n\n\treturn sysfs_emit(buf, \"%u\\n\", sbwcount);\n}\n\nstatic ssize_t\nnilfs_superblock_sb_update_frequency_show(struct nilfs_superblock_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    char *buf)\n{\n\tunsigned int sb_update_freq;\n\n\tdown_read(&nilfs->ns_sem);\n\tsb_update_freq = nilfs->ns_sb_update_freq;\n\tup_read(&nilfs->ns_sem);\n\n\treturn sysfs_emit(buf, \"%u\\n\", sb_update_freq);\n}\n\nstatic ssize_t\nnilfs_superblock_sb_update_frequency_store(struct nilfs_superblock_attr *attr,\n\t\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = kstrtouint(skip_spaces(buf), 0, &val);\n\tif (err) {\n\t\tnilfs_err(nilfs->ns_sb, \"unable to convert string: err=%d\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tif (val < NILFS_SB_FREQ) {\n\t\tval = NILFS_SB_FREQ;\n\t\tnilfs_warn(nilfs->ns_sb,\n\t\t\t   \"superblock update frequency cannot be lesser than 10 seconds\");\n\t}\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_sb_update_freq = val;\n\tup_write(&nilfs->ns_sem);\n\n\treturn count;\n}\n\nstatic const char sb_readme_str[] =\n\t\"The superblock group contains attributes that describe\\n\"\n\t\"superblock's details.\\n\\n\"\n\t\"(1) sb_write_time\\n\\tshow previous write time of super block \"\n\t\"in human-readable format.\\n\\n\"\n\t\"(2) sb_write_time_secs\\n\\tshow previous write time of super block \"\n\t\"in seconds.\\n\\n\"\n\t\"(3) sb_write_count\\n\\tshow write count of super block.\\n\\n\"\n\t\"(4) sb_update_frequency\\n\"\n\t\"\\tshow/set interval of periodical update of superblock (in seconds).\\n\\n\"\n\t\"\\tYou can set preferable frequency of superblock update by command:\\n\\n\"\n\t\"\\t'echo <val> > /sys/fs/<nilfs>/<dev>/superblock/sb_update_frequency'\\n\";\n\nstatic ssize_t\nnilfs_superblock_README_show(struct nilfs_superblock_attr *attr,\n\t\t\t\tstruct the_nilfs *nilfs, char *buf)\n{\n\treturn sysfs_emit(buf, sb_readme_str);\n}\n\nNILFS_SUPERBLOCK_RO_ATTR(sb_write_time);\nNILFS_SUPERBLOCK_RO_ATTR(sb_write_time_secs);\nNILFS_SUPERBLOCK_RO_ATTR(sb_write_count);\nNILFS_SUPERBLOCK_RW_ATTR(sb_update_frequency);\nNILFS_SUPERBLOCK_RO_ATTR(README);\n\nstatic struct attribute *nilfs_superblock_attrs[] = {\n\tNILFS_SUPERBLOCK_ATTR_LIST(sb_write_time),\n\tNILFS_SUPERBLOCK_ATTR_LIST(sb_write_time_secs),\n\tNILFS_SUPERBLOCK_ATTR_LIST(sb_write_count),\n\tNILFS_SUPERBLOCK_ATTR_LIST(sb_update_frequency),\n\tNILFS_SUPERBLOCK_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_superblock);\n\nNILFS_DEV_INT_GROUP_OPS(superblock, dev);\nNILFS_DEV_INT_GROUP_TYPE(superblock, dev);\nNILFS_DEV_INT_GROUP_FNS(superblock, dev);\n\n \n\nstatic\nssize_t nilfs_dev_revision_show(struct nilfs_dev_attr *attr,\n\t\t\t\tstruct the_nilfs *nilfs,\n\t\t\t\tchar *buf)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tu32 major = le32_to_cpu(sbp[0]->s_rev_level);\n\tu16 minor = le16_to_cpu(sbp[0]->s_minor_rev_level);\n\n\treturn sysfs_emit(buf, \"%d.%d\\n\", major, minor);\n}\n\nstatic\nssize_t nilfs_dev_blocksize_show(struct nilfs_dev_attr *attr,\n\t\t\t\t struct the_nilfs *nilfs,\n\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", nilfs->ns_blocksize);\n}\n\nstatic\nssize_t nilfs_dev_device_size_show(struct nilfs_dev_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t    char *buf)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tu64 dev_size = le64_to_cpu(sbp[0]->s_dev_size);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", dev_size);\n}\n\nstatic\nssize_t nilfs_dev_free_blocks_show(struct nilfs_dev_attr *attr,\n\t\t\t\t   struct the_nilfs *nilfs,\n\t\t\t\t   char *buf)\n{\n\tsector_t free_blocks = 0;\n\n\tnilfs_count_free_blocks(nilfs, &free_blocks);\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)free_blocks);\n}\n\nstatic\nssize_t nilfs_dev_uuid_show(struct nilfs_dev_attr *attr,\n\t\t\t    struct the_nilfs *nilfs,\n\t\t\t    char *buf)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\treturn sysfs_emit(buf, \"%pUb\\n\", sbp[0]->s_uuid);\n}\n\nstatic\nssize_t nilfs_dev_volume_name_show(struct nilfs_dev_attr *attr,\n\t\t\t\t    struct the_nilfs *nilfs,\n\t\t\t\t    char *buf)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\treturn scnprintf(buf, sizeof(sbp[0]->s_volume_name), \"%s\\n\",\n\t\t\t sbp[0]->s_volume_name);\n}\n\nstatic const char dev_readme_str[] =\n\t\"The <device> group contains attributes that describe file system\\n\"\n\t\"partition's details.\\n\\n\"\n\t\"(1) revision\\n\\tshow NILFS file system revision.\\n\\n\"\n\t\"(2) blocksize\\n\\tshow volume block size in bytes.\\n\\n\"\n\t\"(3) device_size\\n\\tshow volume size in bytes.\\n\\n\"\n\t\"(4) free_blocks\\n\\tshow count of free blocks on volume.\\n\\n\"\n\t\"(5) uuid\\n\\tshow volume's UUID.\\n\\n\"\n\t\"(6) volume_name\\n\\tshow volume's name.\\n\\n\";\n\nstatic ssize_t nilfs_dev_README_show(struct nilfs_dev_attr *attr,\n\t\t\t\t     struct the_nilfs *nilfs,\n\t\t\t\t     char *buf)\n{\n\treturn sysfs_emit(buf, dev_readme_str);\n}\n\nNILFS_DEV_RO_ATTR(revision);\nNILFS_DEV_RO_ATTR(blocksize);\nNILFS_DEV_RO_ATTR(device_size);\nNILFS_DEV_RO_ATTR(free_blocks);\nNILFS_DEV_RO_ATTR(uuid);\nNILFS_DEV_RO_ATTR(volume_name);\nNILFS_DEV_RO_ATTR(README);\n\nstatic struct attribute *nilfs_dev_attrs[] = {\n\tNILFS_DEV_ATTR_LIST(revision),\n\tNILFS_DEV_ATTR_LIST(blocksize),\n\tNILFS_DEV_ATTR_LIST(device_size),\n\tNILFS_DEV_ATTR_LIST(free_blocks),\n\tNILFS_DEV_ATTR_LIST(uuid),\n\tNILFS_DEV_ATTR_LIST(volume_name),\n\tNILFS_DEV_ATTR_LIST(README),\n\tNULL,\n};\nATTRIBUTE_GROUPS(nilfs_dev);\n\nstatic ssize_t nilfs_dev_attr_show(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, char *buf)\n{\n\tstruct the_nilfs *nilfs = container_of(kobj, struct the_nilfs,\n\t\t\t\t\t\tns_dev_kobj);\n\tstruct nilfs_dev_attr *a = container_of(attr, struct nilfs_dev_attr,\n\t\t\t\t\t\tattr);\n\n\treturn a->show ? a->show(a, nilfs, buf) : 0;\n}\n\nstatic ssize_t nilfs_dev_attr_store(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct the_nilfs *nilfs = container_of(kobj, struct the_nilfs,\n\t\t\t\t\t\tns_dev_kobj);\n\tstruct nilfs_dev_attr *a = container_of(attr, struct nilfs_dev_attr,\n\t\t\t\t\t\tattr);\n\n\treturn a->store ? a->store(a, nilfs, buf, len) : 0;\n}\n\nstatic void nilfs_dev_attr_release(struct kobject *kobj)\n{\n\tstruct the_nilfs *nilfs = container_of(kobj, struct the_nilfs,\n\t\t\t\t\t\tns_dev_kobj);\n\tcomplete(&nilfs->ns_dev_kobj_unregister);\n}\n\nstatic const struct sysfs_ops nilfs_dev_attr_ops = {\n\t.show\t= nilfs_dev_attr_show,\n\t.store\t= nilfs_dev_attr_store,\n};\n\nstatic struct kobj_type nilfs_dev_ktype = {\n\t.default_groups\t= nilfs_dev_groups,\n\t.sysfs_ops\t= &nilfs_dev_attr_ops,\n\t.release\t= nilfs_dev_attr_release,\n};\n\nint nilfs_sysfs_create_device_group(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tsize_t devgrp_size = sizeof(struct nilfs_sysfs_dev_subgroups);\n\tint err;\n\n\tnilfs->ns_dev_subgroups = kzalloc(devgrp_size, GFP_KERNEL);\n\tif (unlikely(!nilfs->ns_dev_subgroups)) {\n\t\terr = -ENOMEM;\n\t\tnilfs_err(sb, \"unable to allocate memory for device group\");\n\t\tgoto failed_create_device_group;\n\t}\n\n\tnilfs->ns_dev_kobj.kset = nilfs_kset;\n\tinit_completion(&nilfs->ns_dev_kobj_unregister);\n\terr = kobject_init_and_add(&nilfs->ns_dev_kobj, &nilfs_dev_ktype, NULL,\n\t\t\t\t    \"%s\", sb->s_id);\n\tif (err)\n\t\tgoto cleanup_dev_kobject;\n\n\terr = nilfs_sysfs_create_mounted_snapshots_group(nilfs);\n\tif (err)\n\t\tgoto cleanup_dev_kobject;\n\n\terr = nilfs_sysfs_create_checkpoints_group(nilfs);\n\tif (err)\n\t\tgoto delete_mounted_snapshots_group;\n\n\terr = nilfs_sysfs_create_segments_group(nilfs);\n\tif (err)\n\t\tgoto delete_checkpoints_group;\n\n\terr = nilfs_sysfs_create_superblock_group(nilfs);\n\tif (err)\n\t\tgoto delete_segments_group;\n\n\terr = nilfs_sysfs_create_segctor_group(nilfs);\n\tif (err)\n\t\tgoto delete_superblock_group;\n\n\treturn 0;\n\ndelete_superblock_group:\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\ndelete_segments_group:\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\ndelete_checkpoints_group:\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\ndelete_mounted_snapshots_group:\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\ncleanup_dev_kobject:\n\tkobject_put(&nilfs->ns_dev_kobj);\n\tkfree(nilfs->ns_dev_subgroups);\n\nfailed_create_device_group:\n\treturn err;\n}\n\nvoid nilfs_sysfs_delete_device_group(struct the_nilfs *nilfs)\n{\n\tnilfs_sysfs_delete_mounted_snapshots_group(nilfs);\n\tnilfs_sysfs_delete_checkpoints_group(nilfs);\n\tnilfs_sysfs_delete_segments_group(nilfs);\n\tnilfs_sysfs_delete_superblock_group(nilfs);\n\tnilfs_sysfs_delete_segctor_group(nilfs);\n\tkobject_del(&nilfs->ns_dev_kobj);\n\tkobject_put(&nilfs->ns_dev_kobj);\n\tkfree(nilfs->ns_dev_subgroups);\n}\n\n \n\nstatic ssize_t nilfs_feature_revision_show(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d.%d\\n\",\n\t\t\tNILFS_CURRENT_REV, NILFS_MINOR_REV);\n}\n\nstatic const char features_readme_str[] =\n\t\"The features group contains attributes that describe NILFS file\\n\"\n\t\"system driver features.\\n\\n\"\n\t\"(1) revision\\n\\tshow current revision of NILFS file system driver.\\n\";\n\nstatic ssize_t nilfs_feature_README_show(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, features_readme_str);\n}\n\nNILFS_FEATURE_RO_ATTR(revision);\nNILFS_FEATURE_RO_ATTR(README);\n\nstatic struct attribute *nilfs_feature_attrs[] = {\n\tNILFS_FEATURE_ATTR_LIST(revision),\n\tNILFS_FEATURE_ATTR_LIST(README),\n\tNULL,\n};\n\nstatic const struct attribute_group nilfs_feature_attr_group = {\n\t.name = \"features\",\n\t.attrs = nilfs_feature_attrs,\n};\n\nint __init nilfs_sysfs_init(void)\n{\n\tint err;\n\n\tnilfs_kset = kset_create_and_add(NILFS_ROOT_GROUP_NAME, NULL, fs_kobj);\n\tif (!nilfs_kset) {\n\t\terr = -ENOMEM;\n\t\tnilfs_err(NULL, \"unable to create sysfs entry: err=%d\", err);\n\t\tgoto failed_sysfs_init;\n\t}\n\n\terr = sysfs_create_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tif (unlikely(err)) {\n\t\tnilfs_err(NULL, \"unable to create feature group: err=%d\", err);\n\t\tgoto cleanup_sysfs_init;\n\t}\n\n\treturn 0;\n\ncleanup_sysfs_init:\n\tkset_unregister(nilfs_kset);\n\nfailed_sysfs_init:\n\treturn err;\n}\n\nvoid nilfs_sysfs_exit(void)\n{\n\tsysfs_remove_group(&nilfs_kset->kobj, &nilfs_feature_attr_group);\n\tkset_unregister(nilfs_kset);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}