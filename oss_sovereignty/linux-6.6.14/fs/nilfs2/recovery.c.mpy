{
  "module_name": "recovery.c",
  "hash_id": "9f18cc067a559612628c2c704adb008316298462a0a6f58851a2044e402ff959",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/recovery.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include \"nilfs.h\"\n#include \"segment.h\"\n#include \"sufile.h\"\n#include \"page.h\"\n#include \"segbuf.h\"\n\n \nenum {\n\tNILFS_SEG_VALID,\n\tNILFS_SEG_NO_SUPER_ROOT,\n\tNILFS_SEG_FAIL_IO,\n\tNILFS_SEG_FAIL_MAGIC,\n\tNILFS_SEG_FAIL_SEQ,\n\tNILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT,\n\tNILFS_SEG_FAIL_CHECKSUM_FULL,\n\tNILFS_SEG_FAIL_CONSISTENCY,\n};\n\n \nstruct nilfs_recovery_block {\n\tino_t ino;\t\t \n\tsector_t blocknr;\t \n\t__u64 vblocknr;\t\t \n\tunsigned long blkoff;\t \n\tstruct list_head list;\n};\n\n\nstatic int nilfs_warn_segment_error(struct super_block *sb, int err)\n{\n\tconst char *msg = NULL;\n\n\tswitch (err) {\n\tcase NILFS_SEG_FAIL_IO:\n\t\tnilfs_err(sb, \"I/O error reading segment\");\n\t\treturn -EIO;\n\tcase NILFS_SEG_FAIL_MAGIC:\n\t\tmsg = \"Magic number mismatch\";\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_SEQ:\n\t\tmsg = \"Sequence number mismatch\";\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT:\n\t\tmsg = \"Checksum error in super root\";\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CHECKSUM_FULL:\n\t\tmsg = \"Checksum error in segment payload\";\n\t\tbreak;\n\tcase NILFS_SEG_FAIL_CONSISTENCY:\n\t\tmsg = \"Inconsistency found\";\n\t\tbreak;\n\tcase NILFS_SEG_NO_SUPER_ROOT:\n\t\tmsg = \"No super root in the last segment\";\n\t\tbreak;\n\tdefault:\n\t\tnilfs_err(sb, \"unrecognized segment error %d\", err);\n\t\treturn -EINVAL;\n\t}\n\tnilfs_warn(sb, \"invalid segment: %s\", msg);\n\treturn -EINVAL;\n}\n\n \nstatic int nilfs_compute_checksum(struct the_nilfs *nilfs,\n\t\t\t\t  struct buffer_head *bhs, u32 *sum,\n\t\t\t\t  unsigned long offset, u64 check_bytes,\n\t\t\t\t  sector_t start, unsigned long nblock)\n{\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tunsigned long size;\n\tu32 crc;\n\n\tBUG_ON(offset >= blocksize);\n\tcheck_bytes -= offset;\n\tsize = min_t(u64, check_bytes, blocksize - offset);\n\tcrc = crc32_le(nilfs->ns_crc_seed,\n\t\t       (unsigned char *)bhs->b_data + offset, size);\n\tif (--nblock > 0) {\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tbh = __bread(nilfs->ns_bdev, ++start, blocksize);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tcheck_bytes -= size;\n\t\t\tsize = min_t(u64, check_bytes, blocksize);\n\t\t\tcrc = crc32_le(crc, bh->b_data, size);\n\t\t\tbrelse(bh);\n\t\t} while (--nblock > 0);\n\t}\n\t*sum = crc;\n\treturn 0;\n}\n\n \nint nilfs_read_super_root_block(struct the_nilfs *nilfs, sector_t sr_block,\n\t\t\t\tstruct buffer_head **pbh, int check)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *sr;\n\tu32 crc;\n\tint ret;\n\n\t*pbh = NULL;\n\tbh_sr = __bread(nilfs->ns_bdev, sr_block, nilfs->ns_blocksize);\n\tif (unlikely(!bh_sr)) {\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tgoto failed;\n\t}\n\n\tsr = (struct nilfs_super_root *)bh_sr->b_data;\n\tif (check) {\n\t\tunsigned int bytes = le16_to_cpu(sr->sr_bytes);\n\n\t\tif (bytes == 0 || bytes > nilfs->ns_blocksize) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (nilfs_compute_checksum(\n\t\t\t    nilfs, bh_sr, &crc, sizeof(sr->sr_sum), bytes,\n\t\t\t    sr_block, 1)) {\n\t\t\tret = NILFS_SEG_FAIL_IO;\n\t\t\tgoto failed_bh;\n\t\t}\n\t\tif (crc != le32_to_cpu(sr->sr_sum)) {\n\t\t\tret = NILFS_SEG_FAIL_CHECKSUM_SUPER_ROOT;\n\t\t\tgoto failed_bh;\n\t\t}\n\t}\n\t*pbh = bh_sr;\n\treturn 0;\n\n failed_bh:\n\tbrelse(bh_sr);\n\n failed:\n\treturn nilfs_warn_segment_error(nilfs->ns_sb, ret);\n}\n\n \nstatic struct buffer_head *\nnilfs_read_log_header(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t      struct nilfs_segment_summary **sum)\n{\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (bh_sum)\n\t\t*sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\treturn bh_sum;\n}\n\n \nstatic int nilfs_validate_log(struct the_nilfs *nilfs, u64 seg_seq,\n\t\t\t      struct buffer_head *bh_sum,\n\t\t\t      struct nilfs_segment_summary *sum)\n{\n\tunsigned long nblock;\n\tu32 crc;\n\tint ret;\n\n\tret = NILFS_SEG_FAIL_MAGIC;\n\tif (le32_to_cpu(sum->ss_magic) != NILFS_SEGSUM_MAGIC)\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_SEQ;\n\tif (le64_to_cpu(sum->ss_seq) != seg_seq)\n\t\tgoto out;\n\n\tnblock = le32_to_cpu(sum->ss_nblocks);\n\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\tif (unlikely(nblock == 0 || nblock > nilfs->ns_blocks_per_segment))\n\t\t \n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_IO;\n\tif (nilfs_compute_checksum(nilfs, bh_sum, &crc, sizeof(sum->ss_datasum),\n\t\t\t\t   ((u64)nblock << nilfs->ns_blocksize_bits),\n\t\t\t\t   bh_sum->b_blocknr, nblock))\n\t\tgoto out;\n\n\tret = NILFS_SEG_FAIL_CHECKSUM_FULL;\n\tif (crc != le32_to_cpu(sum->ss_datasum))\n\t\tgoto out;\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic void *nilfs_read_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t     struct buffer_head **pbh,\n\t\t\t\t     unsigned int *offset, unsigned int bytes)\n{\n\tvoid *ptr;\n\tsector_t blocknr;\n\n\tBUG_ON((*pbh)->b_size < *offset);\n\tif (bytes > (*pbh)->b_size - *offset) {\n\t\tblocknr = (*pbh)->b_blocknr;\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + 1,\n\t\t\t       nilfs->ns_blocksize);\n\t\tif (unlikely(!*pbh))\n\t\t\treturn NULL;\n\t\t*offset = 0;\n\t}\n\tptr = (*pbh)->b_data + *offset;\n\t*offset += bytes;\n\treturn ptr;\n}\n\n \nstatic void nilfs_skip_summary_info(struct the_nilfs *nilfs,\n\t\t\t\t    struct buffer_head **pbh,\n\t\t\t\t    unsigned int *offset, unsigned int bytes,\n\t\t\t\t    unsigned long count)\n{\n\tunsigned int rest_item_in_current_block\n\t\t= ((*pbh)->b_size - *offset) / bytes;\n\n\tif (count <= rest_item_in_current_block) {\n\t\t*offset += bytes * count;\n\t} else {\n\t\tsector_t blocknr = (*pbh)->b_blocknr;\n\t\tunsigned int nitem_per_block = (*pbh)->b_size / bytes;\n\t\tunsigned int bcnt;\n\n\t\tcount -= rest_item_in_current_block;\n\t\tbcnt = DIV_ROUND_UP(count, nitem_per_block);\n\t\t*offset = bytes * (count - (bcnt - 1) * nitem_per_block);\n\n\t\tbrelse(*pbh);\n\t\t*pbh = __bread(nilfs->ns_bdev, blocknr + bcnt,\n\t\t\t       nilfs->ns_blocksize);\n\t}\n}\n\n \nstatic int nilfs_scan_dsync_log(struct the_nilfs *nilfs, sector_t start_blocknr,\n\t\t\t\tstruct nilfs_segment_summary *sum,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct buffer_head *bh;\n\tunsigned int offset;\n\tu32 nfinfo, sumbytes;\n\tsector_t blocknr;\n\tino_t ino;\n\tint err = -EIO;\n\n\tnfinfo = le32_to_cpu(sum->ss_nfinfo);\n\tif (!nfinfo)\n\t\treturn 0;\n\n\tsumbytes = le32_to_cpu(sum->ss_sumbytes);\n\tblocknr = start_blocknr + DIV_ROUND_UP(sumbytes, nilfs->ns_blocksize);\n\tbh = __bread(nilfs->ns_bdev, start_blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh))\n\t\tgoto out;\n\n\toffset = le16_to_cpu(sum->ss_bytes);\n\tfor (;;) {\n\t\tunsigned long nblocks, ndatablk, nnodeblk;\n\t\tstruct nilfs_finfo *finfo;\n\n\t\tfinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\tsizeof(*finfo));\n\t\tif (unlikely(!finfo))\n\t\t\tgoto out;\n\n\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\t\tnnodeblk = nblocks - ndatablk;\n\n\t\twhile (ndatablk-- > 0) {\n\t\t\tstruct nilfs_recovery_block *rb;\n\t\t\tstruct nilfs_binfo_v *binfo;\n\n\t\t\tbinfo = nilfs_read_summary_info(nilfs, &bh, &offset,\n\t\t\t\t\t\t\tsizeof(*binfo));\n\t\t\tif (unlikely(!binfo))\n\t\t\t\tgoto out;\n\n\t\t\trb = kmalloc(sizeof(*rb), GFP_NOFS);\n\t\t\tif (unlikely(!rb)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trb->ino = ino;\n\t\t\trb->blocknr = blocknr++;\n\t\t\trb->vblocknr = le64_to_cpu(binfo->bi_vblocknr);\n\t\t\trb->blkoff = le64_to_cpu(binfo->bi_blkoff);\n\t\t\t \n\t\t\tlist_add_tail(&rb->list, head);\n\t\t}\n\t\tif (--nfinfo == 0)\n\t\t\tbreak;\n\t\tblocknr += nnodeblk;  \n\t\tnilfs_skip_summary_info(nilfs, &bh, &offset, sizeof(__le64),\n\t\t\t\t\tnnodeblk);\n\t\tif (unlikely(!bh))\n\t\t\tgoto out;\n\t}\n\terr = 0;\n out:\n\tbrelse(bh);    \n\treturn err;\n}\n\nstatic void dispose_recovery_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_recovery_block *rb;\n\n\t\trb = list_first_entry(head, struct nilfs_recovery_block, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb);\n\t}\n}\n\nstruct nilfs_segment_entry {\n\tstruct list_head\tlist;\n\t__u64\t\t\tsegnum;\n};\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}\n\nvoid nilfs_dispose_segment_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct nilfs_segment_entry *ent;\n\n\t\tent = list_first_entry(head, struct nilfs_segment_entry, list);\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}\n\nstatic int nilfs_prepare_segment_for_recovery(struct the_nilfs *nilfs,\n\t\t\t\t\t      struct super_block *sb,\n\t\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct list_head *head = &ri->ri_used_segments;\n\tstruct nilfs_segment_entry *ent, *n;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 segnum[4];\n\tint err;\n\tint i;\n\n\tsegnum[0] = nilfs->ns_segnum;\n\tsegnum[1] = nilfs->ns_nextnum;\n\tsegnum[2] = ri->ri_segnum;\n\tsegnum[3] = ri->ri_nextnum;\n\n\t \n\terr = nilfs_sufile_free(sufile, segnum[1]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tfor (i = 1; i < 4; i++) {\n\t\terr = nilfs_segment_list_add(head, segnum[i]);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\n\t \n\tlist_for_each_entry_safe(ent, n, head, list) {\n\t\tif (ent->segnum != segnum[0]) {\n\t\t\terr = nilfs_sufile_scrap(sufile, ent->segnum);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t}\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n\n\t \n\terr = nilfs_sufile_alloc(sufile, &segnum[0]);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq = ri->ri_seq + 2;\n\tnilfs->ns_nextnum = nilfs->ns_segnum = segnum[0];\n\n failed:\n\t \n\treturn err;\n}\n\nstatic int nilfs_recovery_copy_block(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_recovery_block *rb,\n\t\t\t\t     struct page *page)\n{\n\tstruct buffer_head *bh_org;\n\tvoid *kaddr;\n\n\tbh_org = __bread(nilfs->ns_bdev, rb->blocknr, nilfs->ns_blocksize);\n\tif (unlikely(!bh_org))\n\t\treturn -EIO;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr + bh_offset(bh_org), bh_org->b_data, bh_org->b_size);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh_org);\n\treturn 0;\n}\n\nstatic int nilfs_recover_dsync_blocks(struct the_nilfs *nilfs,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct nilfs_root *root,\n\t\t\t\t      struct list_head *head,\n\t\t\t\t      unsigned long *nr_salvaged_blocks)\n{\n\tstruct inode *inode;\n\tstruct nilfs_recovery_block *rb, *n;\n\tunsigned int blocksize = nilfs->ns_blocksize;\n\tstruct page *page;\n\tloff_t pos;\n\tint err = 0, err2 = 0;\n\n\tlist_for_each_entry_safe(rb, n, head, list) {\n\t\tinode = nilfs_iget(sb, root, rb->ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\tpos = rb->blkoff << inode->i_blkbits;\n\t\terr = block_write_begin(inode->i_mapping, pos, blocksize,\n\t\t\t\t\t&page, nilfs_get_block);\n\t\tif (unlikely(err)) {\n\t\t\tloff_t isize = inode->i_size;\n\n\t\t\tif (pos + blocksize > isize)\n\t\t\t\tnilfs_write_failed(inode->i_mapping,\n\t\t\t\t\t\t\tpos + blocksize);\n\t\t\tgoto failed_inode;\n\t\t}\n\n\t\terr = nilfs_recovery_copy_block(nilfs, rb, page);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\terr = nilfs_set_file_dirty(inode, 1);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_page;\n\n\t\tblock_write_end(NULL, inode->i_mapping, pos, blocksize,\n\t\t\t\tblocksize, page, NULL);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\t(*nr_salvaged_blocks)++;\n\t\tgoto next;\n\n failed_page:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n failed_inode:\n\t\tnilfs_warn(sb,\n\t\t\t   \"error %d recovering data block (ino=%lu, block-offset=%llu)\",\n\t\t\t   err, (unsigned long)rb->ino,\n\t\t\t   (unsigned long long)rb->blkoff);\n\t\tif (!err2)\n\t\t\terr2 = err;\n next:\n\t\tiput(inode);  \n\t\tlist_del_init(&rb->list);\n\t\tkfree(rb);\n\t}\n\treturn err2;\n}\n\n \nstatic int nilfs_do_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t struct nilfs_root *root,\n\t\t\t\t struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum = NULL;\n\tsector_t pseg_start;\n\tsector_t seg_start, seg_end;   \n\tunsigned long nsalvaged_blocks = 0;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\tint empty_seg = 0;\n\tint err = 0, ret;\n\tLIST_HEAD(dsync_blocks);   \n\tenum {\n\t\tRF_INIT_ST,\n\t\tRF_DSYNC_ST,    \n\t};\n\tint state = RF_INIT_ST;\n\n\tpseg_start = ri->ri_lsegs_start;\n\tseg_seq = ri->ri_lsegs_start_seq;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\twhile (segnum != ri->ri_segnum || pseg_start <= ri->ri_pseg_start) {\n\t\tbrelse(bh_sum);\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum) {\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (flags & NILFS_SS_SR)\n\t\t\tgoto confused;\n\n\t\t \n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tempty_seg = 0;\n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tif (!(flags & NILFS_SS_GC))\n\t\t\tnilfs->ns_nongc_ctime = nilfs->ns_ctime;\n\n\t\tswitch (state) {\n\t\tcase RF_INIT_ST:\n\t\t\tif (!(flags & NILFS_SS_LOGBGN) ||\n\t\t\t    !(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto try_next_pseg;\n\t\t\tstate = RF_DSYNC_ST;\n\t\t\tfallthrough;\n\t\tcase RF_DSYNC_ST:\n\t\t\tif (!(flags & NILFS_SS_SYNDT))\n\t\t\t\tgoto confused;\n\n\t\t\terr = nilfs_scan_dsync_log(nilfs, pseg_start, sum,\n\t\t\t\t\t\t   &dsync_blocks);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed;\n\t\t\tif (flags & NILFS_SS_LOGEND) {\n\t\t\t\terr = nilfs_recover_dsync_blocks(\n\t\t\t\t\tnilfs, sb, root, &dsync_blocks,\n\t\t\t\t\t&nsalvaged_blocks);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto failed;\n\t\t\t\tstate = RF_INIT_ST;\n\t\t\t}\n\t\t\tbreak;  \n\t\t}\n\n try_next_pseg:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\t\tpseg_start += le32_to_cpu(sum->ss_nblocks);\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\tif (pseg_start == ri->ri_lsegs_end)\n\t\t\tbreak;\n\n feed_segment:\n\t\t \n\t\tif (empty_seg++)\n\t\t\tbreak;\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n\tif (nsalvaged_blocks) {\n\t\tnilfs_info(sb, \"salvaged %lu blocks\", nsalvaged_blocks);\n\t\tri->ri_need_recovery = NILFS_RECOVERY_ROLLFORWARD_DONE;\n\t}\n out:\n\tbrelse(bh_sum);\n\tdispose_recovery_list(&dsync_blocks);\n\treturn err;\n\n confused:\n\terr = -EINVAL;\n failed:\n\tnilfs_err(sb,\n\t\t  \"error %d roll-forwarding partial segment at blocknr = %llu\",\n\t\t  err, (unsigned long long)pseg_start);\n\tgoto out;\n}\n\nstatic void nilfs_finish_roll_forward(struct the_nilfs *nilfs,\n\t\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif (nilfs_get_segnum_of_block(nilfs, ri->ri_lsegs_start) !=\n\t    nilfs_get_segnum_of_block(nilfs, ri->ri_super_root))\n\t\treturn;\n\n\tbh = __getblk(nilfs->ns_bdev, ri->ri_lsegs_start, nilfs->ns_blocksize);\n\tBUG_ON(!bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_dirty(bh);\n\terr = sync_dirty_buffer(bh);\n\tif (unlikely(err))\n\t\tnilfs_warn(nilfs->ns_sb,\n\t\t\t   \"buffer sync write failed during post-cleaning of recovery.\");\n\tbrelse(bh);\n}\n\n \nint nilfs_salvage_orphan_logs(struct the_nilfs *nilfs,\n\t\t\t      struct super_block *sb,\n\t\t\t      struct nilfs_recovery_info *ri)\n{\n\tstruct nilfs_root *root;\n\tint err;\n\n\tif (ri->ri_lsegs_start == 0 || ri->ri_lsegs_end == 0)\n\t\treturn 0;\n\n\terr = nilfs_attach_checkpoint(sb, ri->ri_cno, true, &root);\n\tif (unlikely(err)) {\n\t\tnilfs_err(sb, \"error %d loading the latest checkpoint\", err);\n\t\treturn err;\n\t}\n\n\terr = nilfs_do_roll_forward(nilfs, sb, root, ri);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (ri->ri_need_recovery == NILFS_RECOVERY_ROLLFORWARD_DONE) {\n\t\terr = nilfs_prepare_segment_for_recovery(nilfs, sb, ri);\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_err(sb, \"error %d preparing segment for recovery\",\n\t\t\t\t  err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\terr = nilfs_attach_log_writer(sb, root);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tset_nilfs_discontinued(nilfs);\n\t\terr = nilfs_construct_segment(sb);\n\t\tnilfs_detach_log_writer(sb);\n\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_err(sb, \"error %d writing segment for recovery\",\n\t\t\t\t  err);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnilfs_finish_roll_forward(nilfs, ri);\n\t}\n\n failed:\n\tnilfs_put_root(root);\n\treturn err;\n}\n\n \nint nilfs_search_super_root(struct the_nilfs *nilfs,\n\t\t\t    struct nilfs_recovery_info *ri)\n{\n\tstruct buffer_head *bh_sum = NULL;\n\tstruct nilfs_segment_summary *sum = NULL;\n\tsector_t pseg_start, pseg_end, sr_pseg_start = 0;\n\tsector_t seg_start, seg_end;  \n\tsector_t b, end;\n\tunsigned long nblocks;\n\tunsigned int flags;\n\tu64 seg_seq;\n\t__u64 segnum, nextnum = 0;\n\t__u64 cno;\n\tLIST_HEAD(segments);\n\tint empty_seg = 0, scan_newer = 0;\n\tint ret;\n\n\tpseg_start = nilfs->ns_last_pseg;\n\tseg_seq = nilfs->ns_last_seq;\n\tcno = nilfs->ns_last_cno;\n\tsegnum = nilfs_get_segnum_of_block(nilfs, pseg_start);\n\n\t \n\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\n\t \n\tb = seg_start;\n\twhile (b <= seg_end)\n\t\t__breadahead(nilfs->ns_bdev, b++, nilfs->ns_blocksize);\n\n\tfor (;;) {\n\t\tbrelse(bh_sum);\n\t\tret = NILFS_SEG_FAIL_IO;\n\t\tbh_sum = nilfs_read_log_header(nilfs, pseg_start, &sum);\n\t\tif (!bh_sum)\n\t\t\tgoto failed;\n\n\t\tret = nilfs_validate_log(nilfs, seg_seq, bh_sum, sum);\n\t\tif (ret) {\n\t\t\tif (ret == NILFS_SEG_FAIL_IO)\n\t\t\t\tgoto failed;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\tnblocks = le32_to_cpu(sum->ss_nblocks);\n\t\tpseg_end = pseg_start + nblocks - 1;\n\t\tif (unlikely(pseg_end > seg_end)) {\n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto strayed;\n\t\t}\n\n\t\t \n\t\tri->ri_pseg_start = pseg_start;\n\t\tri->ri_seq = seg_seq;\n\t\tri->ri_segnum = segnum;\n\t\tnextnum = nilfs_get_segnum_of_block(nilfs,\n\t\t\t\t\t\t    le64_to_cpu(sum->ss_next));\n\t\tri->ri_nextnum = nextnum;\n\t\tempty_seg = 0;\n\n\t\tflags = le16_to_cpu(sum->ss_flags);\n\t\tif (!(flags & NILFS_SS_SR) && !scan_newer) {\n\t\t\t \n\t\t\tret = NILFS_SEG_FAIL_CONSISTENCY;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (pseg_start == seg_start) {\n\t\t\tnilfs_get_segment_range(nilfs, nextnum, &b, &end);\n\t\t\twhile (b <= end)\n\t\t\t\t__breadahead(nilfs->ns_bdev, b++,\n\t\t\t\t\t     nilfs->ns_blocksize);\n\t\t}\n\t\tif (!(flags & NILFS_SS_SR)) {\n\t\t\tif (!ri->ri_lsegs_start && (flags & NILFS_SS_LOGBGN)) {\n\t\t\t\tri->ri_lsegs_start = pseg_start;\n\t\t\t\tri->ri_lsegs_start_seq = seg_seq;\n\t\t\t}\n\t\t\tif (flags & NILFS_SS_LOGEND)\n\t\t\t\tri->ri_lsegs_end = pseg_start;\n\t\t\tgoto try_next_pseg;\n\t\t}\n\n\t\t \n\t\tri->ri_cno = cno++;\n\t\tri->ri_super_root = pseg_end;\n\t\tri->ri_lsegs_start = ri->ri_lsegs_end = 0;\n\n\t\tnilfs_dispose_segment_list(&segments);\n\t\tsr_pseg_start = pseg_start;\n\t\tnilfs->ns_pseg_offset = pseg_start + nblocks - seg_start;\n\t\tnilfs->ns_seg_seq = seg_seq;\n\t\tnilfs->ns_segnum = segnum;\n\t\tnilfs->ns_cno = cno;   \n\t\tnilfs->ns_ctime = le64_to_cpu(sum->ss_create);\n\t\tnilfs->ns_nextnum = nextnum;\n\n\t\tif (scan_newer)\n\t\t\tri->ri_need_recovery = NILFS_RECOVERY_SR_UPDATED;\n\t\telse {\n\t\t\tif (nilfs->ns_mount_state & NILFS_VALID_FS)\n\t\t\t\tgoto super_root_found;\n\t\t\tscan_newer = 1;\n\t\t}\n\n try_next_pseg:\n\t\t \n\t\tpseg_start += nblocks;\n\t\tif (pseg_start < seg_end)\n\t\t\tcontinue;\n\t\tgoto feed_segment;\n\n strayed:\n\t\t \n\t\tif (!scan_newer)\n\t\t\t \n\t\t\tgoto failed;\n\n feed_segment:\n\t\t \n\t\tif (empty_seg++)\n\t\t\tgoto super_root_found;  \n\n\t\tret = nilfs_segment_list_add(&segments, segnum);\n\t\tif (unlikely(ret))\n\t\t\tgoto failed;\n\n\t\tseg_seq++;\n\t\tsegnum = nextnum;\n\t\tnilfs_get_segment_range(nilfs, segnum, &seg_start, &seg_end);\n\t\tpseg_start = seg_start;\n\t}\n\n super_root_found:\n\t \n\tbrelse(bh_sum);\n\tlist_splice_tail(&segments, &ri->ri_used_segments);\n\tnilfs->ns_last_pseg = sr_pseg_start;\n\tnilfs->ns_last_seq = nilfs->ns_seg_seq;\n\tnilfs->ns_last_cno = ri->ri_cno;\n\treturn 0;\n\n failed:\n\tbrelse(bh_sum);\n\tnilfs_dispose_segment_list(&segments);\n\treturn ret < 0 ? ret : nilfs_warn_segment_error(nilfs->ns_sb, ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}