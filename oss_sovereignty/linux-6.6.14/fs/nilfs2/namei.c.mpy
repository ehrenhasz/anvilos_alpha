{
  "module_name": "namei.c",
  "hash_id": "b83badf677fa90d471615a0938fecc7c7da704bff10163d6989c0ebf48383a7d",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/namei.c",
  "human_readable_source": "\n \n \n\n#include <linux/pagemap.h>\n#include \"nilfs.h\"\n#include \"export.h\"\n\n#define NILFS_FID_SIZE_NON_CONNECTABLE \\\n\t(offsetof(struct nilfs_fid, parent_gen) / 4)\n#define NILFS_FID_SIZE_CONNECTABLE\t(sizeof(struct nilfs_fid) / 4)\n\nstatic inline int nilfs_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = nilfs_add_link(dentry, inode);\n\n\tif (!err) {\n\t\td_instantiate_new(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}\n\n \n\nstatic struct dentry *\nnilfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tino_t ino;\n\n\tif (dentry->d_name.len > NILFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = nilfs_inode_by_name(dir, &dentry->d_name);\n\tinode = ino ? nilfs_iget(dir->i_sb, NILFS_I(dir)->i_root, ino) : NULL;\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int nilfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\tinode = nilfs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &nilfs_file_inode_operations;\n\t\tinode->i_fop = &nilfs_file_operations;\n\t\tinode->i_mapping->a_ops = &nilfs_aops;\n\t\tnilfs_mark_inode_dirty(inode);\n\t\terr = nilfs_add_nondir(dentry, inode);\n\t}\n\tif (!err)\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\telse\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n}\n\nstatic int\nnilfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t    struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\tinode = nilfs_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tnilfs_mark_inode_dirty(inode);\n\t\terr = nilfs_add_nondir(dentry, inode);\n\t}\n\tif (!err)\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\telse\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n}\n\nstatic int nilfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, const char *symname)\n{\n\tstruct nilfs_transaction_info ti;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned int l = strlen(symname) + 1;\n\tstruct inode *inode;\n\tint err;\n\n\tif (l > sb->s_blocksize)\n\t\treturn -ENAMETOOLONG;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\n\tinode = nilfs_new_inode(dir, S_IFLNK | 0777);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\t \n\tinode->i_op = &nilfs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_mapping->a_ops = &nilfs_aops;\n\terr = page_symlink(inode, symname, l);\n\tif (err)\n\t\tgoto out_fail;\n\n\t \n\t \n\n\terr = nilfs_add_nondir(dentry, inode);\nout:\n\tif (!err)\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\telse\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n\nout_fail:\n\tdrop_nlink(inode);\n\tnilfs_mark_inode_dirty(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tgoto out;\n}\n\nstatic int nilfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t      struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\n\tinode_set_ctime_current(inode);\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terr = nilfs_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\t} else {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t\tnilfs_transaction_abort(dir->i_sb);\n\t}\n\n\treturn err;\n}\n\nstatic int nilfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 1);\n\tif (err)\n\t\treturn err;\n\n\tinc_nlink(dir);\n\n\tinode = nilfs_new_inode(dir, S_IFDIR | mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tinode->i_op = &nilfs_dir_inode_operations;\n\tinode->i_fop = &nilfs_dir_operations;\n\tinode->i_mapping->a_ops = &nilfs_aops;\n\n\tinc_nlink(inode);\n\n\terr = nilfs_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = nilfs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\tnilfs_mark_inode_dirty(inode);\n\td_instantiate_new(dentry, inode);\nout:\n\tif (!err)\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\telse\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n\nout_fail:\n\tdrop_nlink(inode);\n\tdrop_nlink(inode);\n\tnilfs_mark_inode_dirty(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\nout_dir:\n\tdrop_nlink(dir);\n\tnilfs_mark_inode_dirty(dir);\n\tgoto out;\n}\n\nstatic int nilfs_do_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct nilfs_dir_entry *de;\n\tstruct page *page;\n\tint err;\n\n\terr = -ENOENT;\n\tde = nilfs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\tinode = d_inode(dentry);\n\terr = -EIO;\n\tif (le64_to_cpu(de->inode) != inode->i_ino)\n\t\tgoto out;\n\n\tif (!inode->i_nlink) {\n\t\tnilfs_warn(inode->i_sb,\n\t\t\t   \"deleting nonexistent file (ino=%lu), %d\",\n\t\t\t   inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\terr = nilfs_delete_entry(de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode_set_ctime_to_ts(inode, inode_get_ctime(dir));\n\tdrop_nlink(inode);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int nilfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = nilfs_do_unlink(dir, dentry);\n\n\tif (!err) {\n\t\tnilfs_mark_inode_dirty(dir);\n\t\tnilfs_mark_inode_dirty(d_inode(dentry));\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\t} else\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n}\n\nstatic int nilfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\terr = nilfs_transaction_begin(dir->i_sb, &ti, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOTEMPTY;\n\tif (nilfs_empty_dir(inode)) {\n\t\terr = nilfs_do_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tdrop_nlink(inode);\n\t\t\tnilfs_mark_inode_dirty(inode);\n\t\t\tdrop_nlink(dir);\n\t\t\tnilfs_mark_inode_dirty(dir);\n\t\t}\n\t}\n\tif (!err)\n\t\terr = nilfs_transaction_commit(dir->i_sb);\n\telse\n\t\tnilfs_transaction_abort(dir->i_sb);\n\n\treturn err;\n}\n\nstatic int nilfs_rename(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct page *dir_page = NULL;\n\tstruct nilfs_dir_entry *dir_de = NULL;\n\tstruct page *old_page;\n\tstruct nilfs_dir_entry *old_de;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\terr = nilfs_transaction_begin(old_dir->i_sb, &ti, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = -ENOENT;\n\told_de = nilfs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = nilfs_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct nilfs_dir_entry *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !nilfs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = nilfs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tnilfs_set_link(new_dir, new_de, new_page, old_inode);\n\t\tnilfs_mark_inode_dirty(new_dir);\n\t\tinode_set_ctime_current(new_inode);\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tdrop_nlink(new_inode);\n\t\tnilfs_mark_inode_dirty(new_inode);\n\t} else {\n\t\terr = nilfs_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tnilfs_mark_inode_dirty(new_dir);\n\t\t}\n\t}\n\n\t \n\tinode_set_ctime_current(old_inode);\n\n\tnilfs_delete_entry(old_de, old_page);\n\n\tif (dir_de) {\n\t\tnilfs_set_link(old_inode, dir_de, dir_page, new_dir);\n\t\tdrop_nlink(old_dir);\n\t}\n\tnilfs_mark_inode_dirty(old_dir);\n\tnilfs_mark_inode_dirty(old_inode);\n\n\terr = nilfs_transaction_commit(old_dir->i_sb);\n\treturn err;\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tput_page(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tput_page(old_page);\nout:\n\tnilfs_transaction_abort(old_dir->i_sb);\n\treturn err;\n}\n\n \nstatic struct dentry *nilfs_get_parent(struct dentry *child)\n{\n\tunsigned long ino;\n\tstruct inode *inode;\n\tstruct nilfs_root *root;\n\n\tino = nilfs_inode_by_name(d_inode(child), &dotdot_name);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\n\troot = NILFS_I(d_inode(child))->i_root;\n\n\tinode = nilfs_iget(child->d_sb, root, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *nilfs_get_dentry(struct super_block *sb, u64 cno,\n\t\t\t\t       u64 ino, u32 gen)\n{\n\tstruct nilfs_root *root;\n\tstruct inode *inode;\n\n\tif (ino < NILFS_FIRST_INO(sb) && ino != NILFS_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\n\troot = nilfs_lookup_root(sb->s_fs_info, cno);\n\tif (!root)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = nilfs_iget(sb, root, ino);\n\tnilfs_put_root(root);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (gen && inode->i_generation != gen) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *nilfs_fh_to_dentry(struct super_block *sb, struct fid *fh,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n\tstruct nilfs_fid *fid = (struct nilfs_fid *)fh;\n\n\tif (fh_len < NILFS_FID_SIZE_NON_CONNECTABLE ||\n\t    (fh_type != FILEID_NILFS_WITH_PARENT &&\n\t     fh_type != FILEID_NILFS_WITHOUT_PARENT))\n\t\treturn NULL;\n\n\treturn nilfs_get_dentry(sb, fid->cno, fid->ino, fid->gen);\n}\n\nstatic struct dentry *nilfs_fh_to_parent(struct super_block *sb, struct fid *fh,\n\t\t\t\t\t int fh_len, int fh_type)\n{\n\tstruct nilfs_fid *fid = (struct nilfs_fid *)fh;\n\n\tif (fh_len < NILFS_FID_SIZE_CONNECTABLE ||\n\t    fh_type != FILEID_NILFS_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn nilfs_get_dentry(sb, fid->cno, fid->parent_ino, fid->parent_gen);\n}\n\nstatic int nilfs_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t   struct inode *parent)\n{\n\tstruct nilfs_fid *fid = (struct nilfs_fid *)fh;\n\tstruct nilfs_root *root = NILFS_I(inode)->i_root;\n\tint type;\n\n\tif (parent && *lenp < NILFS_FID_SIZE_CONNECTABLE) {\n\t\t*lenp = NILFS_FID_SIZE_CONNECTABLE;\n\t\treturn FILEID_INVALID;\n\t}\n\tif (*lenp < NILFS_FID_SIZE_NON_CONNECTABLE) {\n\t\t*lenp = NILFS_FID_SIZE_NON_CONNECTABLE;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tfid->cno = root->cno;\n\tfid->ino = inode->i_ino;\n\tfid->gen = inode->i_generation;\n\n\tif (parent) {\n\t\tfid->parent_ino = parent->i_ino;\n\t\tfid->parent_gen = parent->i_generation;\n\t\ttype = FILEID_NILFS_WITH_PARENT;\n\t\t*lenp = NILFS_FID_SIZE_CONNECTABLE;\n\t} else {\n\t\ttype = FILEID_NILFS_WITHOUT_PARENT;\n\t\t*lenp = NILFS_FID_SIZE_NON_CONNECTABLE;\n\t}\n\n\treturn type;\n}\n\nconst struct inode_operations nilfs_dir_inode_operations = {\n\t.create\t\t= nilfs_create,\n\t.lookup\t\t= nilfs_lookup,\n\t.link\t\t= nilfs_link,\n\t.unlink\t\t= nilfs_unlink,\n\t.symlink\t= nilfs_symlink,\n\t.mkdir\t\t= nilfs_mkdir,\n\t.rmdir\t\t= nilfs_rmdir,\n\t.mknod\t\t= nilfs_mknod,\n\t.rename\t\t= nilfs_rename,\n\t.setattr\t= nilfs_setattr,\n\t.permission\t= nilfs_permission,\n\t.fiemap\t\t= nilfs_fiemap,\n\t.fileattr_get\t= nilfs_fileattr_get,\n\t.fileattr_set\t= nilfs_fileattr_set,\n};\n\nconst struct inode_operations nilfs_special_inode_operations = {\n\t.setattr\t= nilfs_setattr,\n\t.permission\t= nilfs_permission,\n};\n\nconst struct inode_operations nilfs_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n\t.permission     = nilfs_permission,\n};\n\nconst struct export_operations nilfs_export_ops = {\n\t.encode_fh = nilfs_encode_fh,\n\t.fh_to_dentry = nilfs_fh_to_dentry,\n\t.fh_to_parent = nilfs_fh_to_parent,\n\t.get_parent = nilfs_get_parent,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}