{
  "module_name": "direct.c",
  "hash_id": "4dcd259ebe694ec48650c4741fd40563416f79d42001b2ad92eacf7495a26fc6",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/direct.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include \"nilfs.h\"\n#include \"page.h\"\n#include \"direct.h\"\n#include \"alloc.h\"\n#include \"dat.h\"\n\nstatic inline __le64 *nilfs_direct_dptrs(const struct nilfs_bmap *direct)\n{\n\treturn (__le64 *)\n\t\t((struct nilfs_direct_node *)direct->b_u.u_data + 1);\n}\n\nstatic inline __u64\nnilfs_direct_get_ptr(const struct nilfs_bmap *direct, __u64 key)\n{\n\treturn le64_to_cpu(*(nilfs_direct_dptrs(direct) + key));\n}\n\nstatic inline void nilfs_direct_set_ptr(struct nilfs_bmap *direct,\n\t\t\t\t\t__u64 key, __u64 ptr)\n{\n\t*(nilfs_direct_dptrs(direct) + key) = cpu_to_le64(ptr);\n}\n\nstatic int nilfs_direct_lookup(const struct nilfs_bmap *direct,\n\t\t\t       __u64 key, int level, __u64 *ptrp)\n{\n\t__u64 ptr;\n\n\tif (key > NILFS_DIRECT_KEY_MAX || level != 1)\n\t\treturn -ENOENT;\n\tptr = nilfs_direct_get_ptr(direct, key);\n\tif (ptr == NILFS_BMAP_INVALID_PTR)\n\t\treturn -ENOENT;\n\n\t*ptrp = ptr;\n\treturn 0;\n}\n\nstatic int nilfs_direct_lookup_contig(const struct nilfs_bmap *direct,\n\t\t\t\t      __u64 key, __u64 *ptrp,\n\t\t\t\t      unsigned int maxblocks)\n{\n\tstruct inode *dat = NULL;\n\t__u64 ptr, ptr2;\n\tsector_t blocknr;\n\tint ret, cnt;\n\n\tif (key > NILFS_DIRECT_KEY_MAX)\n\t\treturn -ENOENT;\n\tptr = nilfs_direct_get_ptr(direct, key);\n\tif (ptr == NILFS_BMAP_INVALID_PTR)\n\t\treturn -ENOENT;\n\n\tif (NILFS_BMAP_USE_VBN(direct)) {\n\t\tdat = nilfs_bmap_get_dat(direct);\n\t\tret = nilfs_dat_translate(dat, ptr, &blocknr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tptr = blocknr;\n\t}\n\n\tmaxblocks = min_t(unsigned int, maxblocks,\n\t\t\t  NILFS_DIRECT_KEY_MAX - key + 1);\n\tfor (cnt = 1; cnt < maxblocks &&\n\t\t     (ptr2 = nilfs_direct_get_ptr(direct, key + cnt)) !=\n\t\t     NILFS_BMAP_INVALID_PTR;\n\t     cnt++) {\n\t\tif (dat) {\n\t\t\tret = nilfs_dat_translate(dat, ptr2, &blocknr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tptr2 = blocknr;\n\t\t}\n\t\tif (ptr2 != ptr + cnt)\n\t\t\tbreak;\n\t}\n\t*ptrp = ptr;\n\treturn cnt;\n}\n\nstatic __u64\nnilfs_direct_find_target_v(const struct nilfs_bmap *direct, __u64 key)\n{\n\t__u64 ptr;\n\n\tptr = nilfs_bmap_find_target_seq(direct, key);\n\tif (ptr != NILFS_BMAP_INVALID_PTR)\n\t\t \n\t\treturn ptr;\n\n\t \n\treturn nilfs_bmap_find_target_in_group(direct);\n}\n\nstatic int nilfs_direct_insert(struct nilfs_bmap *bmap, __u64 key, __u64 ptr)\n{\n\tunion nilfs_bmap_ptr_req req;\n\tstruct inode *dat = NULL;\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tif (key > NILFS_DIRECT_KEY_MAX)\n\t\treturn -ENOENT;\n\tif (nilfs_direct_get_ptr(bmap, key) != NILFS_BMAP_INVALID_PTR)\n\t\treturn -EEXIST;\n\n\tif (NILFS_BMAP_USE_VBN(bmap)) {\n\t\treq.bpr_ptr = nilfs_direct_find_target_v(bmap, key);\n\t\tdat = nilfs_bmap_get_dat(bmap);\n\t}\n\tret = nilfs_bmap_prepare_alloc_ptr(bmap, &req, dat);\n\tif (!ret) {\n\t\t \n\t\tbh = (struct buffer_head *)((unsigned long)ptr);\n\t\tset_buffer_nilfs_volatile(bh);\n\n\t\tnilfs_bmap_commit_alloc_ptr(bmap, &req, dat);\n\t\tnilfs_direct_set_ptr(bmap, key, req.bpr_ptr);\n\n\t\tif (!nilfs_bmap_dirty(bmap))\n\t\t\tnilfs_bmap_set_dirty(bmap);\n\n\t\tif (NILFS_BMAP_USE_VBN(bmap))\n\t\t\tnilfs_bmap_set_target_v(bmap, key, req.bpr_ptr);\n\n\t\tnilfs_inode_add_blocks(bmap->b_inode, 1);\n\t}\n\treturn ret;\n}\n\nstatic int nilfs_direct_delete(struct nilfs_bmap *bmap, __u64 key)\n{\n\tunion nilfs_bmap_ptr_req req;\n\tstruct inode *dat;\n\tint ret;\n\n\tif (key > NILFS_DIRECT_KEY_MAX ||\n\t    nilfs_direct_get_ptr(bmap, key) == NILFS_BMAP_INVALID_PTR)\n\t\treturn -ENOENT;\n\n\tdat = NILFS_BMAP_USE_VBN(bmap) ? nilfs_bmap_get_dat(bmap) : NULL;\n\treq.bpr_ptr = nilfs_direct_get_ptr(bmap, key);\n\n\tret = nilfs_bmap_prepare_end_ptr(bmap, &req, dat);\n\tif (!ret) {\n\t\tnilfs_bmap_commit_end_ptr(bmap, &req, dat);\n\t\tnilfs_direct_set_ptr(bmap, key, NILFS_BMAP_INVALID_PTR);\n\t\tnilfs_inode_sub_blocks(bmap->b_inode, 1);\n\t}\n\treturn ret;\n}\n\nstatic int nilfs_direct_seek_key(const struct nilfs_bmap *direct, __u64 start,\n\t\t\t\t __u64 *keyp)\n{\n\t__u64 key;\n\n\tfor (key = start; key <= NILFS_DIRECT_KEY_MAX; key++) {\n\t\tif (nilfs_direct_get_ptr(direct, key) !=\n\t\t    NILFS_BMAP_INVALID_PTR) {\n\t\t\t*keyp = key;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int nilfs_direct_last_key(const struct nilfs_bmap *direct, __u64 *keyp)\n{\n\t__u64 key, lastkey;\n\n\tlastkey = NILFS_DIRECT_KEY_MAX + 1;\n\tfor (key = NILFS_DIRECT_KEY_MIN; key <= NILFS_DIRECT_KEY_MAX; key++)\n\t\tif (nilfs_direct_get_ptr(direct, key) !=\n\t\t    NILFS_BMAP_INVALID_PTR)\n\t\t\tlastkey = key;\n\n\tif (lastkey == NILFS_DIRECT_KEY_MAX + 1)\n\t\treturn -ENOENT;\n\n\t*keyp = lastkey;\n\n\treturn 0;\n}\n\nstatic int nilfs_direct_check_insert(const struct nilfs_bmap *bmap, __u64 key)\n{\n\treturn key > NILFS_DIRECT_KEY_MAX;\n}\n\nstatic int nilfs_direct_gather_data(struct nilfs_bmap *direct,\n\t\t\t\t    __u64 *keys, __u64 *ptrs, int nitems)\n{\n\t__u64 key;\n\t__u64 ptr;\n\tint n;\n\n\tif (nitems > NILFS_DIRECT_NBLOCKS)\n\t\tnitems = NILFS_DIRECT_NBLOCKS;\n\tn = 0;\n\tfor (key = 0; key < nitems; key++) {\n\t\tptr = nilfs_direct_get_ptr(direct, key);\n\t\tif (ptr != NILFS_BMAP_INVALID_PTR) {\n\t\t\tkeys[n] = key;\n\t\t\tptrs[n] = ptr;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\nint nilfs_direct_delete_and_convert(struct nilfs_bmap *bmap,\n\t\t\t\t    __u64 key, __u64 *keys, __u64 *ptrs, int n)\n{\n\t__le64 *dptrs;\n\tint ret, i, j;\n\n\t \n\n\t \n\tret = bmap->b_ops->bop_delete(bmap, key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (bmap->b_ops->bop_clear != NULL)\n\t\tbmap->b_ops->bop_clear(bmap);\n\n\t \n\tdptrs = nilfs_direct_dptrs(bmap);\n\tfor (i = 0, j = 0; i < NILFS_DIRECT_NBLOCKS; i++) {\n\t\tif ((j < n) && (i == keys[j])) {\n\t\t\tdptrs[i] = (i != key) ?\n\t\t\t\tcpu_to_le64(ptrs[j]) :\n\t\t\t\tNILFS_BMAP_INVALID_PTR;\n\t\t\tj++;\n\t\t} else\n\t\t\tdptrs[i] = NILFS_BMAP_INVALID_PTR;\n\t}\n\n\tnilfs_direct_init(bmap);\n\treturn 0;\n}\n\nstatic int nilfs_direct_propagate(struct nilfs_bmap *bmap,\n\t\t\t\t  struct buffer_head *bh)\n{\n\tstruct nilfs_palloc_req oldreq, newreq;\n\tstruct inode *dat;\n\t__u64 key;\n\t__u64 ptr;\n\tint ret;\n\n\tif (!NILFS_BMAP_USE_VBN(bmap))\n\t\treturn 0;\n\n\tdat = nilfs_bmap_get_dat(bmap);\n\tkey = nilfs_bmap_data_get_key(bmap, bh);\n\tptr = nilfs_direct_get_ptr(bmap, key);\n\tif (!buffer_nilfs_volatile(bh)) {\n\t\toldreq.pr_entry_nr = ptr;\n\t\tnewreq.pr_entry_nr = ptr;\n\t\tret = nilfs_dat_prepare_update(dat, &oldreq, &newreq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnilfs_dat_commit_update(dat, &oldreq, &newreq,\n\t\t\t\t\tbmap->b_ptr_type == NILFS_BMAP_PTR_VS);\n\t\tset_buffer_nilfs_volatile(bh);\n\t\tnilfs_direct_set_ptr(bmap, key, newreq.pr_entry_nr);\n\t} else\n\t\tret = nilfs_dat_mark_dirty(dat, ptr);\n\n\treturn ret;\n}\n\nstatic int nilfs_direct_assign_v(struct nilfs_bmap *direct,\n\t\t\t\t __u64 key, __u64 ptr,\n\t\t\t\t struct buffer_head **bh,\n\t\t\t\t sector_t blocknr,\n\t\t\t\t union nilfs_binfo *binfo)\n{\n\tstruct inode *dat = nilfs_bmap_get_dat(direct);\n\tunion nilfs_bmap_ptr_req req;\n\tint ret;\n\n\treq.bpr_ptr = ptr;\n\tret = nilfs_dat_prepare_start(dat, &req.bpr_req);\n\tif (!ret) {\n\t\tnilfs_dat_commit_start(dat, &req.bpr_req, blocknr);\n\t\tbinfo->bi_v.bi_vblocknr = cpu_to_le64(ptr);\n\t\tbinfo->bi_v.bi_blkoff = cpu_to_le64(key);\n\t}\n\treturn ret;\n}\n\nstatic int nilfs_direct_assign_p(struct nilfs_bmap *direct,\n\t\t\t\t __u64 key, __u64 ptr,\n\t\t\t\t struct buffer_head **bh,\n\t\t\t\t sector_t blocknr,\n\t\t\t\t union nilfs_binfo *binfo)\n{\n\tnilfs_direct_set_ptr(direct, key, blocknr);\n\n\tbinfo->bi_dat.bi_blkoff = cpu_to_le64(key);\n\tbinfo->bi_dat.bi_level = 0;\n\tmemset(binfo->bi_dat.bi_pad, 0, sizeof(binfo->bi_dat.bi_pad));\n\n\treturn 0;\n}\n\nstatic int nilfs_direct_assign(struct nilfs_bmap *bmap,\n\t\t\t       struct buffer_head **bh,\n\t\t\t       sector_t blocknr,\n\t\t\t       union nilfs_binfo *binfo)\n{\n\t__u64 key;\n\t__u64 ptr;\n\n\tkey = nilfs_bmap_data_get_key(bmap, *bh);\n\tif (unlikely(key > NILFS_DIRECT_KEY_MAX)) {\n\t\tnilfs_crit(bmap->b_inode->i_sb,\n\t\t\t   \"%s (ino=%lu): invalid key: %llu\",\n\t\t\t   __func__,\n\t\t\t   bmap->b_inode->i_ino, (unsigned long long)key);\n\t\treturn -EINVAL;\n\t}\n\tptr = nilfs_direct_get_ptr(bmap, key);\n\tif (unlikely(ptr == NILFS_BMAP_INVALID_PTR)) {\n\t\tnilfs_crit(bmap->b_inode->i_sb,\n\t\t\t   \"%s (ino=%lu): invalid pointer: %llu\",\n\t\t\t   __func__,\n\t\t\t   bmap->b_inode->i_ino, (unsigned long long)ptr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn NILFS_BMAP_USE_VBN(bmap) ?\n\t\tnilfs_direct_assign_v(bmap, key, ptr, bh, blocknr, binfo) :\n\t\tnilfs_direct_assign_p(bmap, key, ptr, bh, blocknr, binfo);\n}\n\nstatic const struct nilfs_bmap_operations nilfs_direct_ops = {\n\t.bop_lookup\t\t=\tnilfs_direct_lookup,\n\t.bop_lookup_contig\t=\tnilfs_direct_lookup_contig,\n\t.bop_insert\t\t=\tnilfs_direct_insert,\n\t.bop_delete\t\t=\tnilfs_direct_delete,\n\t.bop_clear\t\t=\tNULL,\n\n\t.bop_propagate\t\t=\tnilfs_direct_propagate,\n\n\t.bop_lookup_dirty_buffers\t=\tNULL,\n\n\t.bop_assign\t\t=\tnilfs_direct_assign,\n\t.bop_mark\t\t=\tNULL,\n\n\t.bop_seek_key\t\t=\tnilfs_direct_seek_key,\n\t.bop_last_key\t\t=\tnilfs_direct_last_key,\n\n\t.bop_check_insert\t=\tnilfs_direct_check_insert,\n\t.bop_check_delete\t=\tNULL,\n\t.bop_gather_data\t=\tnilfs_direct_gather_data,\n};\n\n\nint nilfs_direct_init(struct nilfs_bmap *bmap)\n{\n\tbmap->b_ops = &nilfs_direct_ops;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}