{
  "module_name": "btnode.c",
  "hash_id": "418663a697be9e16dd2bd6d4e4c7367a51925c334f54a6f26abbe8e314155b86",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/btnode.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/gfp.h>\n#include \"nilfs.h\"\n#include \"mdt.h\"\n#include \"dat.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n\n\n \nvoid nilfs_init_btnc_inode(struct inode *btnc_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(btnc_inode);\n\n\tbtnc_inode->i_mode = S_IFREG;\n\tii->i_flags = 0;\n\tmemset(&ii->i_bmap_data, 0, sizeof(struct nilfs_bmap));\n\tmapping_set_gfp_mask(btnc_inode->i_mapping, GFP_NOFS);\n}\n\nvoid nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}\n\nstruct buffer_head *\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\n{\n\tstruct inode *inode = btnc->host;\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, BIT(BH_NILFS_Node));\n\tif (unlikely(!bh))\n\t\treturn NULL;\n\n\tif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\n\t\t     buffer_dirty(bh))) {\n\t\tbrelse(bh);\n\t\tBUG();\n\t}\n\tmemset(bh->b_data, 0, i_blocksize(inode));\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = blocknr;\n\tset_buffer_mapped(bh);\n\tset_buffer_uptodate(bh);\n\n\tunlock_page(bh->b_page);\n\tput_page(bh->b_page);\n\treturn bh;\n}\n\nint nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\n\t\t\t      sector_t pblocknr, blk_opf_t opf,\n\t\t\t      struct buffer_head **pbh, sector_t *submit_ptr)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = btnc->host;\n\tstruct page *page;\n\tint err;\n\n\tbh = nilfs_grab_buffer(inode, btnc, blocknr, BIT(BH_NILFS_Node));\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\terr = -EEXIST;  \n\tpage = bh->b_page;\n\n\tif (buffer_uptodate(bh) || buffer_dirty(bh))\n\t\tgoto found;\n\n\tif (pblocknr == 0) {\n\t\tpblocknr = blocknr;\n\t\tif (inode->i_ino != NILFS_DAT_INO) {\n\t\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t\t \n\t\t\terr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\n\t\t\t\t\t\t  &pblocknr);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto out_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opf & REQ_RAHEAD) {\n\t\tif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\n\t\t\terr = -EBUSY;  \n\t\t\tbrelse(bh);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else {  \n\t\tlock_buffer(bh);\n\t}\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\terr = -EEXIST;  \n\t\tgoto found;\n\t}\n\tset_buffer_mapped(bh);\n\tbh->b_bdev = inode->i_sb->s_bdev;\n\tbh->b_blocknr = pblocknr;  \n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(opf, bh);\n\tbh->b_blocknr = blocknr;  \n\t*submit_ptr = pblocknr;\n\terr = 0;\nfound:\n\t*pbh = bh;\n\nout_locked:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}\n\n \nvoid nilfs_btnode_delete(struct buffer_head *bh)\n{\n\tstruct address_space *mapping;\n\tstruct page *page = bh->b_page;\n\tpgoff_t index = page_index(page);\n\tint still_dirty;\n\n\tget_page(page);\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\n\tnilfs_forget_buffer(bh);\n\tstill_dirty = PageDirty(page);\n\tmapping = page->mapping;\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (!still_dirty && mapping)\n\t\tinvalidate_inode_pages2_range(mapping, index, index);\n}\n\n \nint nilfs_btnode_prepare_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh, *nbh;\n\tstruct inode *inode = btnc->host;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tint err;\n\n\tif (oldkey == newkey)\n\t\treturn 0;\n\n\tobh = ctxt->bh;\n\tctxt->newbh = NULL;\n\n\tif (inode->i_blkbits == PAGE_SHIFT) {\n\t\tstruct page *opage = obh->b_page;\n\t\tlock_page(opage);\nretry:\n\t\t \n\t\tif (unlikely(oldkey != opage->index))\n\t\t\tNILFS_PAGE_BUG(opage,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\n\t\txa_lock_irq(&btnc->i_pages);\n\t\terr = __xa_insert(&btnc->i_pages, newkey, opage, GFP_NOFS);\n\t\txa_unlock_irq(&btnc->i_pages);\n\t\t \n\t\tif (!err)\n\t\t\treturn 0;\n\t\telse if (err != -EBUSY)\n\t\t\tgoto failed_unlock;\n\n\t\terr = invalidate_inode_pages2_range(btnc, newkey, newkey);\n\t\tif (!err)\n\t\t\tgoto retry;\n\t\t \n\t\tunlock_page(opage);\n\t}\n\n\tnbh = nilfs_btnode_create_block(btnc, newkey);\n\tif (!nbh)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(nbh == obh);\n\tctxt->newbh = nbh;\n\treturn 0;\n\n failed_unlock:\n\tunlock_page(obh->b_page);\n\treturn err;\n}\n\n \nvoid nilfs_btnode_commit_change_key(struct address_space *btnc,\n\t\t\t\t    struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *obh = ctxt->bh, *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\tstruct page *opage;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t \n\t\topage = obh->b_page;\n\t\tif (unlikely(oldkey != opage->index))\n\t\t\tNILFS_PAGE_BUG(opage,\n\t\t\t\t       \"invalid oldkey %lld (newkey=%lld)\",\n\t\t\t\t       (unsigned long long)oldkey,\n\t\t\t\t       (unsigned long long)newkey);\n\t\tmark_buffer_dirty(obh);\n\n\t\txa_lock_irq(&btnc->i_pages);\n\t\t__xa_erase(&btnc->i_pages, oldkey);\n\t\t__xa_set_mark(&btnc->i_pages, newkey, PAGECACHE_TAG_DIRTY);\n\t\txa_unlock_irq(&btnc->i_pages);\n\n\t\topage->index = obh->b_blocknr = newkey;\n\t\tunlock_page(opage);\n\t} else {\n\t\tnilfs_copy_buffer(nbh, obh);\n\t\tmark_buffer_dirty(nbh);\n\n\t\tnbh->b_blocknr = newkey;\n\t\tctxt->bh = nbh;\n\t\tnilfs_btnode_delete(obh);  \n\t}\n}\n\n \nvoid nilfs_btnode_abort_change_key(struct address_space *btnc,\n\t\t\t\t   struct nilfs_btnode_chkey_ctxt *ctxt)\n{\n\tstruct buffer_head *nbh = ctxt->newbh;\n\t__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\n\n\tif (oldkey == newkey)\n\t\treturn;\n\n\tif (nbh == NULL) {\t \n\t\txa_erase_irq(&btnc->i_pages, newkey);\n\t\tunlock_page(ctxt->bh->b_page);\n\t} else {\n\t\t \n\t\tnilfs_btnode_delete(nbh);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}