{
  "module_name": "the_nilfs.h",
  "hash_id": "6889f0c92a4b1f4a0d7936ca8a20f671dce5f3e01dec75a58595733c0af81a5c",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/the_nilfs.h",
  "human_readable_source": " \n \n\n#ifndef _THE_NILFS_H\n#define _THE_NILFS_H\n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include <linux/rbtree.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/refcount.h>\n\nstruct nilfs_sc_info;\nstruct nilfs_sysfs_dev_subgroups;\n\n \nenum {\n\tTHE_NILFS_INIT = 0,      \n\tTHE_NILFS_DISCONTINUED,\t \n\tTHE_NILFS_GC_RUNNING,\t \n\tTHE_NILFS_SB_DIRTY,\t \n\tTHE_NILFS_PURGING,\t \n};\n\n \nstruct the_nilfs {\n\tunsigned long\t\tns_flags;\n\tint\t\t\tns_flushed_device;\n\n\tstruct super_block     *ns_sb;\n\tstruct block_device    *ns_bdev;\n\tstruct rw_semaphore\tns_sem;\n\tstruct mutex\t\tns_snapshot_mount_mutex;\n\n\t \n\tstruct buffer_head     *ns_sbh[2];\n\tstruct nilfs_super_block *ns_sbp[2];\n\ttime64_t\t\tns_sbwtime;\n\tunsigned int\t\tns_sbwcount;\n\tunsigned int\t\tns_sbsize;\n\tunsigned int\t\tns_mount_state;\n\tunsigned int\t\tns_sb_update_freq;\n\n\t \n\tu64\t\t\tns_seg_seq;\n\t__u64\t\t\tns_segnum;\n\t__u64\t\t\tns_nextnum;\n\tunsigned long\t\tns_pseg_offset;\n\t__u64\t\t\tns_cno;\n\ttime64_t\t\tns_ctime;\n\ttime64_t\t\tns_nongc_ctime;\n\tatomic_t\t\tns_ndirtyblks;\n\n\t \n\tspinlock_t\t\tns_last_segment_lock;\n\tsector_t\t\tns_last_pseg;\n\tu64\t\t\tns_last_seq;\n\t__u64\t\t\tns_last_cno;\n\tu64\t\t\tns_prot_seq;\n\tu64\t\t\tns_prev_seq;\n\n\tstruct nilfs_sc_info   *ns_writer;\n\tstruct rw_semaphore\tns_segctor_sem;\n\n\t \n\tstruct inode\t       *ns_dat;\n\tstruct inode\t       *ns_cpfile;\n\tstruct inode\t       *ns_sufile;\n\n\t \n\tstruct rb_root\t\tns_cptree;\n\tspinlock_t\t\tns_cptree_lock;\n\n\t \n\tstruct list_head\tns_dirty_files;\n\tspinlock_t\t\tns_inode_lock;\n\n\t \n\tstruct list_head\tns_gc_inodes;\n\n\t \n\tu32\t\t\tns_next_generation;\n\tspinlock_t\t\tns_next_gen_lock;\n\n\t \n\tunsigned long\t\tns_mount_opt;\n\n\tuid_t\t\t\tns_resuid;\n\tgid_t\t\t\tns_resgid;\n\tunsigned long\t\tns_interval;\n\tunsigned long\t\tns_watermark;\n\n\t \n\tunsigned int\t\tns_blocksize_bits;\n\tunsigned int\t\tns_blocksize;\n\tunsigned long\t\tns_nsegments;\n\tunsigned long\t\tns_blocks_per_segment;\n\tunsigned long\t\tns_r_segments_percentage;\n\tunsigned long\t\tns_nrsvsegs;\n\tunsigned long\t\tns_first_data_block;\n\tint\t\t\tns_inode_size;\n\tint\t\t\tns_first_ino;\n\tu32\t\t\tns_crc_seed;\n\n\t \n\tstruct kobject ns_dev_kobj;\n\tstruct completion ns_dev_kobj_unregister;\n\tstruct nilfs_sysfs_dev_subgroups *ns_dev_subgroups;\n};\n\n#define THE_NILFS_FNS(bit, name)\t\t\t\t\t\\\nstatic inline void set_nilfs_##name(struct the_nilfs *nilfs)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tset_bit(THE_NILFS_##bit, &(nilfs)->ns_flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void clear_nilfs_##name(struct the_nilfs *nilfs)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tclear_bit(THE_NILFS_##bit, &(nilfs)->ns_flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline int nilfs_##name(struct the_nilfs *nilfs)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn test_bit(THE_NILFS_##bit, &(nilfs)->ns_flags);\t\t\\\n}\n\nTHE_NILFS_FNS(INIT, init)\nTHE_NILFS_FNS(DISCONTINUED, discontinued)\nTHE_NILFS_FNS(GC_RUNNING, gc_running)\nTHE_NILFS_FNS(SB_DIRTY, sb_dirty)\nTHE_NILFS_FNS(PURGING, purging)\n\n \n#define nilfs_clear_opt(nilfs, opt)  \\\n\t((nilfs)->ns_mount_opt &= ~NILFS_MOUNT_##opt)\n#define nilfs_set_opt(nilfs, opt)  \\\n\t((nilfs)->ns_mount_opt |= NILFS_MOUNT_##opt)\n#define nilfs_test_opt(nilfs, opt) ((nilfs)->ns_mount_opt & NILFS_MOUNT_##opt)\n#define nilfs_write_opt(nilfs, mask, opt)\t\t\t\t\\\n\t((nilfs)->ns_mount_opt =\t\t\t\t\t\\\n\t\t(((nilfs)->ns_mount_opt & ~NILFS_MOUNT_##mask) |\t\\\n\t\t NILFS_MOUNT_##opt))\t\t\t\t\t\\\n\n \nstruct nilfs_root {\n\t__u64 cno;\n\tstruct rb_node rb_node;\n\n\trefcount_t count;\n\tstruct the_nilfs *nilfs;\n\tstruct inode *ifile;\n\n\tatomic64_t inodes_count;\n\tatomic64_t blocks_count;\n\n\t \n\tstruct kobject snapshot_kobj;\n\tstruct completion snapshot_kobj_unregister;\n};\n\n \n#define NILFS_CPTREE_CURRENT_CNO\t0\n\n \n#define NILFS_SB_FREQ\t\t10\n\nstatic inline int nilfs_sb_need_update(struct the_nilfs *nilfs)\n{\n\tu64 t = ktime_get_real_seconds();\n\n\treturn t < nilfs->ns_sbwtime ||\n\t\tt > nilfs->ns_sbwtime + nilfs->ns_sb_update_freq;\n}\n\nstatic inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}\n\nvoid nilfs_set_last_segment(struct the_nilfs *, sector_t, u64, __u64);\nstruct the_nilfs *alloc_nilfs(struct super_block *sb);\nvoid destroy_nilfs(struct the_nilfs *nilfs);\nint init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data);\nint load_nilfs(struct the_nilfs *nilfs, struct super_block *sb);\nunsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs);\nvoid nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs);\nint nilfs_discard_segments(struct the_nilfs *, __u64 *, size_t);\nint nilfs_count_free_blocks(struct the_nilfs *, sector_t *);\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno);\nstruct nilfs_root *nilfs_find_or_create_root(struct the_nilfs *nilfs,\n\t\t\t\t\t     __u64 cno);\nvoid nilfs_put_root(struct nilfs_root *root);\nint nilfs_near_disk_full(struct the_nilfs *);\nvoid nilfs_fall_back_super_block(struct the_nilfs *);\nvoid nilfs_swap_super_block(struct the_nilfs *);\n\n\nstatic inline void nilfs_get_root(struct nilfs_root *root)\n{\n\trefcount_inc(&root->count);\n}\n\nstatic inline int nilfs_valid_fs(struct the_nilfs *nilfs)\n{\n\tunsigned int valid_fs;\n\n\tdown_read(&nilfs->ns_sem);\n\tvalid_fs = (nilfs->ns_mount_state & NILFS_VALID_FS);\n\tup_read(&nilfs->ns_sem);\n\treturn valid_fs;\n}\n\nstatic inline void\nnilfs_get_segment_range(struct the_nilfs *nilfs, __u64 segnum,\n\t\t\tsector_t *seg_start, sector_t *seg_end)\n{\n\t*seg_start = (sector_t)nilfs->ns_blocks_per_segment * segnum;\n\t*seg_end = *seg_start + nilfs->ns_blocks_per_segment - 1;\n\tif (segnum == 0)\n\t\t*seg_start = nilfs->ns_first_data_block;\n}\n\nstatic inline sector_t\nnilfs_get_segment_start_blocknr(struct the_nilfs *nilfs, __u64 segnum)\n{\n\treturn (segnum == 0) ? nilfs->ns_first_data_block :\n\t\t(sector_t)nilfs->ns_blocks_per_segment * segnum;\n}\n\nstatic inline __u64\nnilfs_get_segnum_of_block(struct the_nilfs *nilfs, sector_t blocknr)\n{\n\tsector_t segnum = blocknr;\n\n\tsector_div(segnum, nilfs->ns_blocks_per_segment);\n\treturn segnum;\n}\n\nstatic inline void\nnilfs_terminate_segment(struct the_nilfs *nilfs, sector_t seg_start,\n\t\t\tsector_t seg_end)\n{\n\t \n\tnilfs->ns_pseg_offset = seg_end - seg_start + 1;\n}\n\nstatic inline void nilfs_shift_to_next_segment(struct the_nilfs *nilfs)\n{\n\t \n\tnilfs->ns_segnum = nilfs->ns_nextnum;\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq++;\n}\n\nstatic inline __u64 nilfs_last_cno(struct the_nilfs *nilfs)\n{\n\t__u64 cno;\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tcno = nilfs->ns_last_cno;\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n\treturn cno;\n}\n\nstatic inline int nilfs_segment_is_active(struct the_nilfs *nilfs, __u64 n)\n{\n\treturn n == nilfs->ns_segnum || n == nilfs->ns_nextnum;\n}\n\nstatic inline int nilfs_flush_device(struct the_nilfs *nilfs)\n{\n\tint err;\n\n\tif (!nilfs_test_opt(nilfs, BARRIER) || nilfs->ns_flushed_device)\n\t\treturn 0;\n\n\tnilfs->ns_flushed_device = 1;\n\t \n\tsmp_wmb();\n\n\terr = blkdev_issue_flush(nilfs->ns_bdev);\n\tif (err != -EIO)\n\t\terr = 0;\n\treturn err;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}