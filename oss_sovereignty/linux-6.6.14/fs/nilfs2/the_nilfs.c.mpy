{
  "module_name": "the_nilfs.c",
  "hash_id": "c6e0b38290ad901ef3f0655d9efc10f9cd470f424942d5774e7d2a9eb0e0171f",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/the_nilfs.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/random.h>\n#include <linux/log2.h>\n#include <linux/crc32.h>\n#include \"nilfs.h\"\n#include \"segment.h\"\n#include \"alloc.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"dat.h\"\n#include \"segbuf.h\"\n\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nvoid nilfs_set_last_segment(struct the_nilfs *nilfs,\n\t\t\t    sector_t start_blocknr, u64 seq, __u64 cno)\n{\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_last_pseg = start_blocknr;\n\tnilfs->ns_last_seq = seq;\n\tnilfs->ns_last_cno = cno;\n\n\tif (!nilfs_sb_dirty(nilfs)) {\n\t\tif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\n\t\t\tgoto stay_cursor;\n\n\t\tset_nilfs_sb_dirty(nilfs);\n\t}\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\n stay_cursor:\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}\n\n \nstruct the_nilfs *alloc_nilfs(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs;\n\n\tnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\n\tif (!nilfs)\n\t\treturn NULL;\n\n\tnilfs->ns_sb = sb;\n\tnilfs->ns_bdev = sb->s_bdev;\n\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\tinit_rwsem(&nilfs->ns_sem);\n\tmutex_init(&nilfs->ns_snapshot_mount_mutex);\n\tINIT_LIST_HEAD(&nilfs->ns_dirty_files);\n\tINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\n\tspin_lock_init(&nilfs->ns_inode_lock);\n\tspin_lock_init(&nilfs->ns_next_gen_lock);\n\tspin_lock_init(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_cptree = RB_ROOT;\n\tspin_lock_init(&nilfs->ns_cptree_lock);\n\tinit_rwsem(&nilfs->ns_segctor_sem);\n\tnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\n\n\treturn nilfs;\n}\n\n \nvoid destroy_nilfs(struct the_nilfs *nilfs)\n{\n\tmight_sleep();\n\tif (nilfs_init(nilfs)) {\n\t\tbrelse(nilfs->ns_sbh[0]);\n\t\tbrelse(nilfs->ns_sbh[1]);\n\t}\n\tkfree(nilfs);\n}\n\nstatic int nilfs_load_super_root(struct the_nilfs *nilfs,\n\t\t\t\t struct super_block *sb, sector_t sr_block)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct nilfs_inode *rawi;\n\tunsigned int dat_entry_size, segment_usage_size, checkpoint_size;\n\tunsigned int inode_size;\n\tint err;\n\n\terr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdown_read(&nilfs->ns_sem);\n\tdat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\n\tcheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\n\tsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\n\tup_read(&nilfs->ns_sem);\n\n\tinode_size = nilfs->ns_inode_size;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\n\terr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\n\tif (err)\n\t\tgoto failed;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\n\terr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\n\tif (err)\n\t\tgoto failed_dat;\n\n\trawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\n\terr = nilfs_sufile_read(sb, segment_usage_size, rawi,\n\t\t\t\t&nilfs->ns_sufile);\n\tif (err)\n\t\tgoto failed_cpfile;\n\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\n\n failed:\n\tbrelse(bh_sr);\n\treturn err;\n\n failed_cpfile:\n\tiput(nilfs->ns_cpfile);\n\n failed_dat:\n\tiput(nilfs->ns_dat);\n\tgoto failed;\n}\n\nstatic void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tmemset(ri, 0, sizeof(*ri));\n\tINIT_LIST_HEAD(&ri->ri_used_segments);\n}\n\nstatic void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\n{\n\tnilfs_dispose_segment_list(&ri->ri_used_segments);\n}\n\n \nstatic int nilfs_store_log_cursor(struct the_nilfs *nilfs,\n\t\t\t\t  struct nilfs_super_block *sbp)\n{\n\tint ret = 0;\n\n\tnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\n\tnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\n\tnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\n\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\tnilfs->ns_seg_seq = nilfs->ns_last_seq;\n\tnilfs->ns_segnum =\n\t\tnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\n\tnilfs->ns_cno = nilfs->ns_last_cno + 1;\n\tif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\n\t\tnilfs_err(nilfs->ns_sb,\n\t\t\t  \"pointed segment number is out of range: segnum=%llu, nsegments=%lu\",\n\t\t\t  (unsigned long long)nilfs->ns_segnum,\n\t\t\t  nilfs->ns_nsegments);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\n \nstatic int nilfs_get_blocksize(struct super_block *sb,\n\t\t\t       struct nilfs_super_block *sbp, int *blocksize)\n{\n\tunsigned int shift_bits = le32_to_cpu(sbp->s_log_block_size);\n\n\tif (unlikely(shift_bits >\n\t\t     ilog2(NILFS_MAX_BLOCK_SIZE) - BLOCK_SIZE_BITS)) {\n\t\tnilfs_err(sb, \"too large filesystem blocksize: 2 ^ %u KiB\",\n\t\t\t  shift_bits);\n\t\treturn -EINVAL;\n\t}\n\t*blocksize = BLOCK_SIZE << shift_bits;\n\treturn 0;\n}\n\n \nint load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\n{\n\tstruct nilfs_recovery_info ri;\n\tunsigned int s_flags = sb->s_flags;\n\tint really_read_only = bdev_read_only(nilfs->ns_bdev);\n\tint valid_fs = nilfs_valid_fs(nilfs);\n\tint err;\n\n\tif (!valid_fs) {\n\t\tnilfs_warn(sb, \"mounting unchecked fs\");\n\t\tif (s_flags & SB_RDONLY) {\n\t\t\tnilfs_info(sb,\n\t\t\t\t   \"recovery required for readonly filesystem\");\n\t\t\tnilfs_info(sb,\n\t\t\t\t   \"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tnilfs_init_recovery_info(&ri);\n\n\terr = nilfs_search_super_root(nilfs, &ri);\n\tif (unlikely(err)) {\n\t\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\t\tint blocksize;\n\n\t\tif (err != -EINVAL)\n\t\t\tgoto scan_error;\n\n\t\tif (!nilfs_valid_sb(sbp[1])) {\n\t\t\tnilfs_warn(sb,\n\t\t\t\t   \"unable to fall back to spare super block\");\n\t\t\tgoto scan_error;\n\t\t}\n\t\tnilfs_info(sb, \"trying rollback from an earlier position\");\n\n\t\t \n\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\tnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\n\t\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\n\t\t \n\t\terr = nilfs_get_blocksize(sb, sbp[0], &blocksize);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\tif (blocksize != nilfs->ns_blocksize) {\n\t\t\tnilfs_warn(sb,\n\t\t\t\t   \"blocksize differs between two super blocks (%d != %d)\",\n\t\t\t\t   blocksize, nilfs->ns_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto scan_error;\n\t\t}\n\n\t\terr = nilfs_store_log_cursor(nilfs, sbp[0]);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\n\t\t \n\t\tnilfs->ns_mount_state &= ~NILFS_VALID_FS;\n\t\tvalid_fs = 0;\n\n\t\terr = nilfs_search_super_root(nilfs, &ri);\n\t\tif (err)\n\t\t\tgoto scan_error;\n\t}\n\n\terr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\n\tif (unlikely(err)) {\n\t\tnilfs_err(sb, \"error %d while loading super root\", err);\n\t\tgoto failed;\n\t}\n\n\terr = nilfs_sysfs_create_device_group(sb);\n\tif (unlikely(err))\n\t\tgoto sysfs_error;\n\n\tif (valid_fs)\n\t\tgoto skip_recovery;\n\n\tif (s_flags & SB_RDONLY) {\n\t\t__u64 features;\n\n\t\tif (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\t\tnilfs_info(sb,\n\t\t\t\t   \"norecovery option specified, skipping roll-forward recovery\");\n\t\t\tgoto skip_recovery;\n\t\t}\n\t\tfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\n\t\t\t~NILFS_FEATURE_COMPAT_RO_SUPP;\n\t\tif (features) {\n\t\t\tnilfs_err(sb,\n\t\t\t\t  \"couldn't proceed with recovery because of unsupported optional features (%llx)\",\n\t\t\t\t  (unsigned long long)features);\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tif (really_read_only) {\n\t\t\tnilfs_err(sb,\n\t\t\t\t  \"write access unavailable, cannot proceed\");\n\t\t\terr = -EROFS;\n\t\t\tgoto failed_unload;\n\t\t}\n\t\tsb->s_flags &= ~SB_RDONLY;\n\t} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\n\t\tnilfs_err(sb,\n\t\t\t  \"recovery cancelled because norecovery option was specified for a read/write mount\");\n\t\terr = -EINVAL;\n\t\tgoto failed_unload;\n\t}\n\n\terr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\n\tif (err)\n\t\tgoto failed_unload;\n\n\tdown_write(&nilfs->ns_sem);\n\tnilfs->ns_mount_state |= NILFS_VALID_FS;  \n\terr = nilfs_cleanup_super(sb);\n\tup_write(&nilfs->ns_sem);\n\n\tif (err) {\n\t\tnilfs_err(sb,\n\t\t\t  \"error %d updating super block. recovery unfinished.\",\n\t\t\t  err);\n\t\tgoto failed_unload;\n\t}\n\tnilfs_info(sb, \"recovery complete\");\n\n skip_recovery:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn 0;\n\n scan_error:\n\tnilfs_err(sb, \"error %d while searching super root\", err);\n\tgoto failed;\n\n failed_unload:\n\tnilfs_sysfs_delete_device_group(nilfs);\n\n sysfs_error:\n\tiput(nilfs->ns_cpfile);\n\tiput(nilfs->ns_sufile);\n\tiput(nilfs->ns_dat);\n\n failed:\n\tnilfs_clear_recovery_info(&ri);\n\tsb->s_flags = s_flags;\n\treturn err;\n}\n\nstatic unsigned long long nilfs_max_size(unsigned int blkbits)\n{\n\tunsigned int max_bits;\n\tunsigned long long res = MAX_LFS_FILESIZE;  \n\n\tmax_bits = blkbits + NILFS_BMAP_KEY_BIT;  \n\tif (max_bits < 64)\n\t\tres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\n\treturn res;\n}\n\n \nunsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\treturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\n\t\t     DIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\n\t\t\t\t  100));\n}\n\n \nstatic u64 nilfs_max_segment_count(struct the_nilfs *nilfs)\n{\n\tu64 max_count = U64_MAX;\n\n\tdo_div(max_count, nilfs->ns_blocks_per_segment);\n\treturn min_t(u64, max_count, ULONG_MAX);\n}\n\nvoid nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\n{\n\tnilfs->ns_nsegments = nsegs;\n\tnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\n}\n\nstatic int nilfs_store_disk_layout(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_super_block *sbp)\n{\n\tu64 nsegments, nblocks;\n\n\tif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\n\t\tnilfs_err(nilfs->ns_sb,\n\t\t\t  \"unsupported revision (superblock rev.=%d.%d, current rev.=%d.%d). Please check the version of mkfs.nilfs(2).\",\n\t\t\t  le32_to_cpu(sbp->s_rev_level),\n\t\t\t  le16_to_cpu(sbp->s_minor_rev_level),\n\t\t\t  NILFS_CURRENT_REV, NILFS_MINOR_REV);\n\t\treturn -EINVAL;\n\t}\n\tnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\n\tif (nilfs->ns_sbsize > BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\n\tif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\n\t\tnilfs_err(nilfs->ns_sb, \"too large inode size: %d bytes\",\n\t\t\t  nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\n\t\tnilfs_err(nilfs->ns_sb, \"too small inode size: %d bytes\",\n\t\t\t  nilfs->ns_inode_size);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\n\n\tnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\n\t\tnilfs_err(nilfs->ns_sb, \"too short segment: %lu blocks\",\n\t\t\t  nilfs->ns_blocks_per_segment);\n\t\treturn -EINVAL;\n\t}\n\n\tnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\n\tnilfs->ns_r_segments_percentage =\n\t\tle32_to_cpu(sbp->s_r_segments_percentage);\n\tif (nilfs->ns_r_segments_percentage < 1 ||\n\t    nilfs->ns_r_segments_percentage > 99) {\n\t\tnilfs_err(nilfs->ns_sb,\n\t\t\t  \"invalid reserved segments percentage: %lu\",\n\t\t\t  nilfs->ns_r_segments_percentage);\n\t\treturn -EINVAL;\n\t}\n\n\tnsegments = le64_to_cpu(sbp->s_nsegments);\n\tif (nsegments > nilfs_max_segment_count(nilfs)) {\n\t\tnilfs_err(nilfs->ns_sb,\n\t\t\t  \"segment count %llu exceeds upper limit (%llu segments)\",\n\t\t\t  (unsigned long long)nsegments,\n\t\t\t  (unsigned long long)nilfs_max_segment_count(nilfs));\n\t\treturn -EINVAL;\n\t}\n\n\tnblocks = sb_bdev_nr_blocks(nilfs->ns_sb);\n\tif (nblocks) {\n\t\tu64 min_block_count = nsegments * nilfs->ns_blocks_per_segment;\n\t\t \n\n\t\tif (nblocks < min_block_count) {\n\t\t\tnilfs_err(nilfs->ns_sb,\n\t\t\t\t  \"total number of segment blocks %llu exceeds device size (%llu blocks)\",\n\t\t\t\t  (unsigned long long)min_block_count,\n\t\t\t\t  (unsigned long long)nblocks);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnilfs_set_nsegments(nilfs, nsegments);\n\tnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\n\treturn 0;\n}\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp)\n{\n\tstatic unsigned char sum[4];\n\tconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\n\tsize_t bytes;\n\tu32 crc;\n\n\tif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\n\t\treturn 0;\n\tbytes = le16_to_cpu(sbp->s_bytes);\n\tif (bytes < sumoff + 4 || bytes > BLOCK_SIZE)\n\t\treturn 0;\n\tcrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\n\t\t       sumoff);\n\tcrc = crc32_le(crc, sum, 4);\n\tcrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\n\t\t       bytes - sumoff - 4);\n\treturn crc == le32_to_cpu(sbp->s_sum);\n}\n\n \nstatic bool nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\tunsigned int shift_bits = le32_to_cpu(sbp->s_log_block_size);\n\tu32 blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\n\tu64 nsegments = le64_to_cpu(sbp->s_nsegments);\n\tu64 index;\n\n\tif (blocks_per_segment < NILFS_SEG_MIN_BLOCKS ||\n\t    shift_bits > ilog2(NILFS_MAX_BLOCK_SIZE) - BLOCK_SIZE_BITS)\n\t\treturn true;\n\n\tindex = offset >> (shift_bits + BLOCK_SIZE_BITS);\n\tdo_div(index, blocks_per_segment);\n\treturn index < nsegments;\n}\n\nstatic void nilfs_release_super_block(struct the_nilfs *nilfs)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (nilfs->ns_sbp[i]) {\n\t\t\tbrelse(nilfs->ns_sbh[i]);\n\t\t\tnilfs->ns_sbh[i] = NULL;\n\t\t\tnilfs->ns_sbp[i] = NULL;\n\t\t}\n\t}\n}\n\nvoid nilfs_fall_back_super_block(struct the_nilfs *nilfs)\n{\n\tbrelse(nilfs->ns_sbh[0]);\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = NULL;\n\tnilfs->ns_sbp[1] = NULL;\n}\n\nvoid nilfs_swap_super_block(struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *tsbh = nilfs->ns_sbh[0];\n\tstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\n\n\tnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\n\tnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\n\tnilfs->ns_sbh[1] = tsbh;\n\tnilfs->ns_sbp[1] = tsbp;\n}\n\nstatic int nilfs_load_super_block(struct the_nilfs *nilfs,\n\t\t\t\t  struct super_block *sb, int blocksize,\n\t\t\t\t  struct nilfs_super_block **sbpp)\n{\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\tstruct buffer_head **sbh = nilfs->ns_sbh;\n\tu64 sb2off, devsize = bdev_nr_bytes(nilfs->ns_bdev);\n\tint valid[2], swp = 0;\n\n\tif (devsize < NILFS_SEG_MIN_BLOCKS * NILFS_MIN_BLOCK_SIZE + 4096) {\n\t\tnilfs_err(sb, \"device size too small\");\n\t\treturn -EINVAL;\n\t}\n\tsb2off = NILFS_SB2_OFFSET_BYTES(devsize);\n\n\tsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\n\t\t\t\t\t&sbh[0]);\n\tsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\n\n\tif (!sbp[0]) {\n\t\tif (!sbp[1]) {\n\t\t\tnilfs_err(sb, \"unable to read superblock\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tnilfs_warn(sb,\n\t\t\t   \"unable to read primary superblock (blocksize = %d)\",\n\t\t\t   blocksize);\n\t} else if (!sbp[1]) {\n\t\tnilfs_warn(sb,\n\t\t\t   \"unable to read secondary superblock (blocksize = %d)\",\n\t\t\t   blocksize);\n\t}\n\n\t \n\tvalid[0] = nilfs_valid_sb(sbp[0]);\n\tvalid[1] = nilfs_valid_sb(sbp[1]);\n\tswp = valid[1] && (!valid[0] ||\n\t\t\t   le64_to_cpu(sbp[1]->s_last_cno) >\n\t\t\t   le64_to_cpu(sbp[0]->s_last_cno));\n\n\tif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\n\t\tbrelse(sbh[1]);\n\t\tsbh[1] = NULL;\n\t\tsbp[1] = NULL;\n\t\tvalid[1] = 0;\n\t\tswp = 0;\n\t}\n\tif (!valid[swp]) {\n\t\tnilfs_release_super_block(nilfs);\n\t\tnilfs_err(sb, \"couldn't find nilfs on the device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!valid[!swp])\n\t\tnilfs_warn(sb,\n\t\t\t   \"broken superblock, retrying with spare superblock (blocksize = %d)\",\n\t\t\t   blocksize);\n\tif (swp)\n\t\tnilfs_swap_super_block(nilfs);\n\n\tnilfs->ns_sbwcount = 0;\n\tnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\n\tnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\n\t*sbpp = sbp[0];\n\treturn 0;\n}\n\n \nint init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\n{\n\tstruct nilfs_super_block *sbp;\n\tint blocksize;\n\tint err;\n\n\tdown_write(&nilfs->ns_sem);\n\n\tblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tnilfs_err(sb, \"unable to set blocksize\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\tif (err)\n\t\tgoto out;\n\n\terr = nilfs_store_magic_and_option(sb, sbp, data);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_check_feature_compatibility(sb, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\terr = nilfs_get_blocksize(sb, sbp, &blocksize);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tif (blocksize < NILFS_MIN_BLOCK_SIZE) {\n\t\tnilfs_err(sb,\n\t\t\t  \"couldn't mount because of unsupported filesystem blocksize %d\",\n\t\t\t  blocksize);\n\t\terr = -EINVAL;\n\t\tgoto failed_sbh;\n\t}\n\tif (sb->s_blocksize != blocksize) {\n\t\tint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\n\n\t\tif (blocksize < hw_blocksize) {\n\t\t\tnilfs_err(sb,\n\t\t\t\t  \"blocksize %d too small for device (sector-size = %d)\",\n\t\t\t\t  blocksize, hw_blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed_sbh;\n\t\t}\n\t\tnilfs_release_super_block(nilfs);\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\tnilfs_err(sb, \"bad blocksize %d\", blocksize);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t\t \n\t}\n\tnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\n\tnilfs->ns_blocksize = blocksize;\n\n\tget_random_bytes(&nilfs->ns_next_generation,\n\t\t\t sizeof(nilfs->ns_next_generation));\n\n\terr = nilfs_store_disk_layout(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\n\n\tnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\n\n\terr = nilfs_store_log_cursor(nilfs, sbp);\n\tif (err)\n\t\tgoto failed_sbh;\n\n\tset_nilfs_init(nilfs);\n\terr = 0;\n out:\n\tup_write(&nilfs->ns_sem);\n\treturn err;\n\n failed_sbh:\n\tnilfs_release_super_block(nilfs);\n\tgoto out;\n}\n\nint nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\n\t\t\t    size_t nsegs)\n{\n\tsector_t seg_start, seg_end;\n\tsector_t start = 0, nblocks = 0;\n\tunsigned int sects_per_block;\n\t__u64 *sn;\n\tint ret = 0;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tfor (sn = segnump; sn < segnump + nsegs; sn++) {\n\t\tnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\n\n\t\tif (!nblocks) {\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t} else if (start + nblocks == seg_start) {\n\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t} else {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tnblocks = 0;\n\t\t}\n\t}\n\tif (nblocks)\n\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t   GFP_NOFS);\n\treturn ret;\n}\n\nint nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\n{\n\tunsigned long ncleansegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\t*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\n\treturn 0;\n}\n\nint nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}\n\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node *n;\n\tstruct nilfs_root *root;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\tn = nilfs->ns_cptree.rb_node;\n\twhile (n) {\n\t\troot = rb_entry(n, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tn = n->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\trefcount_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\treturn root;\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\treturn NULL;\n}\n\nstruct nilfs_root *\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\n{\n\tstruct rb_node **p, *parent;\n\tstruct nilfs_root *root, *new;\n\tint err;\n\n\troot = nilfs_lookup_root(nilfs, cno);\n\tif (root)\n\t\treturn root;\n\n\tnew = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tspin_lock(&nilfs->ns_cptree_lock);\n\n\tp = &nilfs->ns_cptree.rb_node;\n\tparent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\troot = rb_entry(parent, struct nilfs_root, rb_node);\n\n\t\tif (cno < root->cno) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (cno > root->cno) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\trefcount_inc(&root->count);\n\t\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\t\tkfree(new);\n\t\t\treturn root;\n\t\t}\n\t}\n\n\tnew->cno = cno;\n\tnew->ifile = NULL;\n\tnew->nilfs = nilfs;\n\trefcount_set(&new->count, 1);\n\tatomic64_set(&new->inodes_count, 0);\n\tatomic64_set(&new->blocks_count, 0);\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, &nilfs->ns_cptree);\n\n\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\terr = nilfs_sysfs_create_snapshot_group(new);\n\tif (err) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t}\n\n\treturn new;\n}\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = root->nilfs;\n\n\tif (refcount_dec_and_lock(&root->count, &nilfs->ns_cptree_lock)) {\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}