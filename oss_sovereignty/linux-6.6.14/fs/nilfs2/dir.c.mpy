{
  "module_name": "dir.c",
  "hash_id": "318830db2eec2293bea6c3ac42d7a5efd3c46d1378327713d36b2457adb51711",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/dir.c",
  "human_readable_source": "\n \n \n\n#include <linux/pagemap.h>\n#include \"nilfs.h\"\n#include \"page.h\"\n\nstatic inline unsigned int nilfs_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned int len = le16_to_cpu(dlen);\n\n#if (PAGE_SIZE >= 65536)\n\tif (len == NILFS_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}\n\nstatic inline __le16 nilfs_rec_len_to_disk(unsigned int len)\n{\n#if (PAGE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(NILFS_MAX_REC_LEN);\n\n\tBUG_ON(len > (1 << 16));\n#endif\n\treturn cpu_to_le16(len);\n}\n\n \nstatic inline unsigned int nilfs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}\n\n \nstatic unsigned int nilfs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned int last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_SHIFT;\n\tif (last_byte > PAGE_SIZE)\n\t\tlast_byte = PAGE_SIZE;\n\treturn last_byte;\n}\n\nstatic int nilfs_prepare_chunk(struct page *page, unsigned int from,\n\t\t\t       unsigned int to)\n{\n\tloff_t pos = page_offset(page) + from;\n\n\treturn __block_write_begin(page, pos, to - from, nilfs_get_block);\n}\n\nstatic void nilfs_commit_chunk(struct page *page,\n\t\t\t       struct address_space *mapping,\n\t\t\t       unsigned int from, unsigned int to)\n{\n\tstruct inode *dir = mapping->host;\n\tloff_t pos = page_offset(page) + from;\n\tunsigned int len = to - from;\n\tunsigned int nr_dirty, copied;\n\tint err;\n\n\tnr_dirty = nilfs_page_count_clean_buffers(page, from, to);\n\tcopied = block_write_end(NULL, mapping, pos, len, len, page, NULL);\n\tif (pos + copied > dir->i_size)\n\t\ti_size_write(dir, pos + copied);\n\tif (IS_DIRSYNC(dir))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\terr = nilfs_set_file_dirty(dir, nr_dirty);\n\tWARN_ON(err);  \n\tunlock_page(page);\n}\n\nstatic bool nilfs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned int chunk_size = nilfs_chunk_size(dir);\n\tchar *kaddr = page_address(page);\n\tunsigned int offs, rec_len;\n\tunsigned int limit = PAGE_SIZE;\n\tstruct nilfs_dir_entry *p;\n\tchar *error;\n\n\tif ((dir->i_size >> PAGE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - NILFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct nilfs_dir_entry *)(kaddr + offs);\n\t\trec_len = nilfs_rec_len_from_disk(p->rec_len);\n\n\t\tif (rec_len < NILFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < NILFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn true;\n\n\t \n\nEbadsize:\n\tnilfs_error(sb,\n\t\t    \"size of directory #%lu is not a multiple of chunk size\",\n\t\t    dir->i_ino);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\nbad_entry:\n\tnilfs_error(sb,\n\t\t    \"bad entry in directory #%lu: %s - offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t    dir->i_ino, error, (page->index << PAGE_SHIFT) + offs,\n\t\t    (unsigned long)le64_to_cpu(p->inode),\n\t\t    rec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct nilfs_dir_entry *)(kaddr + offs);\n\tnilfs_error(sb,\n\t\t    \"entry in directory #%lu spans the page boundary offset=%lu, inode=%lu\",\n\t\t    dir->i_ino, (page->index << PAGE_SHIFT) + offs,\n\t\t    (unsigned long)le64_to_cpu(p->inode));\nfail:\n\tSetPageError(page);\n\treturn false;\n}\n\nstatic struct page *nilfs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (unlikely(!PageChecked(page))) {\n\t\t\tif (!nilfs_check_page(page))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn page;\n\nfail:\n\tnilfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}\n\n \nstatic int\nnilfs_match(int len, const unsigned char *name, struct nilfs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}\n\n \nstatic struct nilfs_dir_entry *nilfs_next_entry(struct nilfs_dir_entry *p)\n{\n\treturn (struct nilfs_dir_entry *)((char *)p +\n\t\t\t\t\t  nilfs_rec_len_from_disk(p->rec_len));\n}\n\nstatic unsigned char\nnilfs_filetype_table[NILFS_FT_MAX] = {\n\t[NILFS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[NILFS_FT_REG_FILE]\t= DT_REG,\n\t[NILFS_FT_DIR]\t\t= DT_DIR,\n\t[NILFS_FT_CHRDEV]\t= DT_CHR,\n\t[NILFS_FT_BLKDEV]\t= DT_BLK,\n\t[NILFS_FT_FIFO]\t\t= DT_FIFO,\n\t[NILFS_FT_SOCK]\t\t= DT_SOCK,\n\t[NILFS_FT_SYMLINK]\t= DT_LNK,\n};\n\n#define S_SHIFT 12\nstatic unsigned char\nnilfs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= NILFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= NILFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= NILFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= NILFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= NILFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= NILFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= NILFS_FT_SYMLINK,\n};\n\nstatic void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\tde->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT];\n}\n\nstatic int nilfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned int offset = pos & ~PAGE_MASK;\n\tunsigned long n = pos >> PAGE_SHIFT;\n\tunsigned long npages = dir_pages(inode);\n\n\tif (pos > inode->i_size - NILFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct nilfs_dir_entry *de;\n\t\tstruct page *page = nilfs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tnilfs_error(sb, \"bad page in #%lu\", inode->i_ino);\n\t\t\tctx->pos += PAGE_SIZE - offset;\n\t\t\treturn -EIO;\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tde = (struct nilfs_dir_entry *)(kaddr + offset);\n\t\tlimit = kaddr + nilfs_last_byte(inode, n) -\n\t\t\tNILFS_DIR_REC_LEN(1);\n\t\tfor ( ; (char *)de <= limit; de = nilfs_next_entry(de)) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tnilfs_error(sb, \"zero-length directory entry\");\n\t\t\t\tnilfs_put_page(page);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->inode) {\n\t\t\t\tunsigned char t;\n\n\t\t\t\tif (de->file_type < NILFS_FT_MAX)\n\t\t\t\t\tt = nilfs_filetype_table[de->file_type];\n\t\t\t\telse\n\t\t\t\t\tt = DT_UNKNOWN;\n\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode), t)) {\n\t\t\t\t\tnilfs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += nilfs_rec_len_from_disk(de->rec_len);\n\t\t}\n\t\tnilfs_put_page(page);\n\t}\n\treturn 0;\n}\n\n \nstruct nilfs_dir_entry *\nnilfs_find_entry(struct inode *dir, const struct qstr *qstr,\n\t\t struct page **res_page)\n{\n\tconst unsigned char *name = qstr->name;\n\tint namelen = qstr->len;\n\tunsigned int reclen = NILFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct nilfs_inode_info *ei = NILFS_I(dir);\n\tstruct nilfs_dir_entry *de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t \n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\n\t\tpage = nilfs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct nilfs_dir_entry *)kaddr;\n\t\t\tkaddr += nilfs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\tnilfs_error(dir->i_sb,\n\t\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\t\tnilfs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (nilfs_match(namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = nilfs_next_entry(de);\n\t\t\t}\n\t\t\tnilfs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t \n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_SHIFT - 9)))) {\n\t\t\tnilfs_error(dir->i_sb,\n\t\t\t       \"dir %lu size %lld exceeds block count %llu\",\n\t\t\t       dir->i_ino, dir->i_size,\n\t\t\t       (unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}\n\nstruct nilfs_dir_entry *nilfs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = nilfs_get_page(dir, 0);\n\tstruct nilfs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = nilfs_next_entry(\n\t\t\t(struct nilfs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}\n\nino_t nilfs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct nilfs_dir_entry *de;\n\tstruct page *page;\n\n\tde = nilfs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = le64_to_cpu(de->inode);\n\t\tkunmap(page);\n\t\tput_page(page);\n\t}\n\treturn res;\n}\n\n \nvoid nilfs_set_link(struct inode *dir, struct nilfs_dir_entry *de,\n\t\t    struct page *page, struct inode *inode)\n{\n\tunsigned int from = (char *)de - (char *)page_address(page);\n\tunsigned int to = from + nilfs_rec_len_from_disk(de->rec_len);\n\tstruct address_space *mapping = page->mapping;\n\tint err;\n\n\tlock_page(page);\n\terr = nilfs_prepare_chunk(page, from, to);\n\tBUG_ON(err);\n\tde->inode = cpu_to_le64(inode->i_ino);\n\tnilfs_set_de_type(de, inode);\n\tnilfs_commit_chunk(page, mapping, from, to);\n\tnilfs_put_page(page);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n}\n\n \nint nilfs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = d_inode(dentry->d_parent);\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned int chunk_size = nilfs_chunk_size(dir);\n\tunsigned int reclen = NILFS_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct nilfs_dir_entry *de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tunsigned int from, to;\n\tint err;\n\n\t \n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = nilfs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + nilfs_last_byte(dir, n);\n\t\tde = (struct nilfs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t \n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = nilfs_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tnilfs_error(dir->i_sb,\n\t\t\t\t\t    \"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (nilfs_match(namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = NILFS_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = nilfs_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct nilfs_dir_entry *)((char *)de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\tnilfs_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tfrom = (char *)de - (char *)page_address(page);\n\tto = from + rec_len;\n\terr = nilfs_prepare_chunk(page, from, to);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\tstruct nilfs_dir_entry *de1;\n\n\t\tde1 = (struct nilfs_dir_entry *)((char *)de + name_len);\n\t\tde1->rec_len = nilfs_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = nilfs_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le64(inode->i_ino);\n\tnilfs_set_de_type(de, inode);\n\tnilfs_commit_chunk(page, page->mapping, from, to);\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tnilfs_mark_inode_dirty(dir);\n\t \nout_put:\n\tnilfs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}\n\n \nint nilfs_delete_entry(struct nilfs_dir_entry *dir, struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tchar *kaddr = page_address(page);\n\tunsigned int from, to;\n\tstruct nilfs_dir_entry *de, *pde = NULL;\n\tint err;\n\n\tfrom = ((char *)dir - kaddr) & ~(nilfs_chunk_size(inode) - 1);\n\tto = ((char *)dir - kaddr) + nilfs_rec_len_from_disk(dir->rec_len);\n\tde = (struct nilfs_dir_entry *)(kaddr + from);\n\n\twhile ((char *)de < (char *)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\tnilfs_error(inode->i_sb,\n\t\t\t\t    \"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = nilfs_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char *)pde - (char *)page_address(page);\n\tlock_page(page);\n\terr = nilfs_prepare_chunk(page, from, to);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->rec_len = nilfs_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\tnilfs_commit_chunk(page, mapping, from, to);\n\tinode->i_mtime = inode_set_ctime_current(inode);\nout:\n\tnilfs_put_page(page);\n\treturn err;\n}\n\n \nint nilfs_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tunsigned int chunk_size = nilfs_chunk_size(inode);\n\tstruct nilfs_dir_entry *de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_prepare_chunk(page, 0, chunk_size);\n\tif (unlikely(err)) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, chunk_size);\n\tde = (struct nilfs_dir_entry *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = nilfs_rec_len_to_disk(NILFS_DIR_REC_LEN(1));\n\tmemcpy(de->name, \".\\0\\0\", 4);\n\tde->inode = cpu_to_le64(inode->i_ino);\n\tnilfs_set_de_type(de, inode);\n\n\tde = (struct nilfs_dir_entry *)(kaddr + NILFS_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = nilfs_rec_len_to_disk(chunk_size - NILFS_DIR_REC_LEN(1));\n\tde->inode = cpu_to_le64(parent->i_ino);\n\tmemcpy(de->name, \"..\\0\", 4);\n\tnilfs_set_de_type(de, inode);\n\tkunmap_atomic(kaddr);\n\tnilfs_commit_chunk(page, mapping, 0, chunk_size);\nfail:\n\tput_page(page);\n\treturn err;\n}\n\n \nint nilfs_empty_dir(struct inode *inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct nilfs_dir_entry *de;\n\n\t\tpage = nilfs_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct nilfs_dir_entry *)kaddr;\n\t\tkaddr += nilfs_last_byte(inode, i) - NILFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tnilfs_error(inode->i_sb,\n\t\t\t\t\t    \"zero-length directory entry (kaddr=%p, de=%p)\",\n\t\t\t\t\t    kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t \n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le64(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = nilfs_next_entry(de);\n\t\t}\n\t\tnilfs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tnilfs_put_page(page);\n\treturn 0;\n}\n\nconst struct file_operations nilfs_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= nilfs_readdir,\n\t.unlocked_ioctl\t= nilfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= nilfs_compat_ioctl,\n#endif\t \n\t.fsync\t\t= nilfs_sync_file,\n\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}