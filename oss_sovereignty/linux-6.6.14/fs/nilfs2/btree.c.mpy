{
  "module_name": "btree.c",
  "hash_id": "c2e0fc66adc053f9a37629a13ff1242cf3b0643e2d8dd8d21710f129145fccd9",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/btree.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/pagevec.h>\n#include \"nilfs.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"dat.h\"\n\nstatic void __nilfs_btree_init(struct nilfs_bmap *bmap);\n\nstatic struct nilfs_btree_path *nilfs_btree_alloc_path(void)\n{\n\tstruct nilfs_btree_path *path;\n\tint level = NILFS_BTREE_LEVEL_DATA;\n\n\tpath = kmem_cache_alloc(nilfs_btree_path_cache, GFP_NOFS);\n\tif (path == NULL)\n\t\tgoto out;\n\n\tfor (; level < NILFS_BTREE_LEVEL_MAX; level++) {\n\t\tpath[level].bp_bh = NULL;\n\t\tpath[level].bp_sib_bh = NULL;\n\t\tpath[level].bp_index = 0;\n\t\tpath[level].bp_oldreq.bpr_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tpath[level].bp_newreq.bpr_ptr = NILFS_BMAP_INVALID_PTR;\n\t\tpath[level].bp_op = NULL;\n\t}\n\nout:\n\treturn path;\n}\n\nstatic void nilfs_btree_free_path(struct nilfs_btree_path *path)\n{\n\tint level = NILFS_BTREE_LEVEL_DATA;\n\n\tfor (; level < NILFS_BTREE_LEVEL_MAX; level++)\n\t\tbrelse(path[level].bp_bh);\n\n\tkmem_cache_free(nilfs_btree_path_cache, path);\n}\n\n \nstatic int nilfs_btree_get_new_block(const struct nilfs_bmap *btree,\n\t\t\t\t     __u64 ptr, struct buffer_head **bhp)\n{\n\tstruct inode *btnc_inode = NILFS_BMAP_I(btree)->i_assoc_inode;\n\tstruct address_space *btnc = btnc_inode->i_mapping;\n\tstruct buffer_head *bh;\n\n\tbh = nilfs_btnode_create_block(btnc, ptr);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tset_buffer_nilfs_volatile(bh);\n\t*bhp = bh;\n\treturn 0;\n}\n\nstatic int nilfs_btree_node_get_flags(const struct nilfs_btree_node *node)\n{\n\treturn node->bn_flags;\n}\n\nstatic void\nnilfs_btree_node_set_flags(struct nilfs_btree_node *node, int flags)\n{\n\tnode->bn_flags = flags;\n}\n\nstatic int nilfs_btree_node_root(const struct nilfs_btree_node *node)\n{\n\treturn nilfs_btree_node_get_flags(node) & NILFS_BTREE_NODE_ROOT;\n}\n\nstatic int nilfs_btree_node_get_level(const struct nilfs_btree_node *node)\n{\n\treturn node->bn_level;\n}\n\nstatic void\nnilfs_btree_node_set_level(struct nilfs_btree_node *node, int level)\n{\n\tnode->bn_level = level;\n}\n\nstatic int nilfs_btree_node_get_nchildren(const struct nilfs_btree_node *node)\n{\n\treturn le16_to_cpu(node->bn_nchildren);\n}\n\nstatic void\nnilfs_btree_node_set_nchildren(struct nilfs_btree_node *node, int nchildren)\n{\n\tnode->bn_nchildren = cpu_to_le16(nchildren);\n}\n\nstatic int nilfs_btree_node_size(const struct nilfs_bmap *btree)\n{\n\treturn i_blocksize(btree->b_inode);\n}\n\nstatic int nilfs_btree_nchildren_per_block(const struct nilfs_bmap *btree)\n{\n\treturn btree->b_nchildren_per_block;\n}\n\nstatic __le64 *\nnilfs_btree_node_dkeys(const struct nilfs_btree_node *node)\n{\n\treturn (__le64 *)((char *)(node + 1) +\n\t\t\t  (nilfs_btree_node_root(node) ?\n\t\t\t   0 : NILFS_BTREE_NODE_EXTRA_PAD_SIZE));\n}\n\nstatic __le64 *\nnilfs_btree_node_dptrs(const struct nilfs_btree_node *node, int ncmax)\n{\n\treturn (__le64 *)(nilfs_btree_node_dkeys(node) + ncmax);\n}\n\nstatic __u64\nnilfs_btree_node_get_key(const struct nilfs_btree_node *node, int index)\n{\n\treturn le64_to_cpu(*(nilfs_btree_node_dkeys(node) + index));\n}\n\nstatic void\nnilfs_btree_node_set_key(struct nilfs_btree_node *node, int index, __u64 key)\n{\n\t*(nilfs_btree_node_dkeys(node) + index) = cpu_to_le64(key);\n}\n\nstatic __u64\nnilfs_btree_node_get_ptr(const struct nilfs_btree_node *node, int index,\n\t\t\t int ncmax)\n{\n\treturn le64_to_cpu(*(nilfs_btree_node_dptrs(node, ncmax) + index));\n}\n\nstatic void\nnilfs_btree_node_set_ptr(struct nilfs_btree_node *node, int index, __u64 ptr,\n\t\t\t int ncmax)\n{\n\t*(nilfs_btree_node_dptrs(node, ncmax) + index) = cpu_to_le64(ptr);\n}\n\nstatic void nilfs_btree_node_init(struct nilfs_btree_node *node, int flags,\n\t\t\t\t  int level, int nchildren, int ncmax,\n\t\t\t\t  const __u64 *keys, const __u64 *ptrs)\n{\n\t__le64 *dkeys;\n\t__le64 *dptrs;\n\tint i;\n\n\tnilfs_btree_node_set_flags(node, flags);\n\tnilfs_btree_node_set_level(node, level);\n\tnilfs_btree_node_set_nchildren(node, nchildren);\n\n\tdkeys = nilfs_btree_node_dkeys(node);\n\tdptrs = nilfs_btree_node_dptrs(node, ncmax);\n\tfor (i = 0; i < nchildren; i++) {\n\t\tdkeys[i] = cpu_to_le64(keys[i]);\n\t\tdptrs[i] = cpu_to_le64(ptrs[i]);\n\t}\n}\n\n \nstatic void nilfs_btree_node_move_left(struct nilfs_btree_node *left,\n\t\t\t\t       struct nilfs_btree_node *right,\n\t\t\t\t       int n, int lncmax, int rncmax)\n{\n\t__le64 *ldkeys, *rdkeys;\n\t__le64 *ldptrs, *rdptrs;\n\tint lnchildren, rnchildren;\n\n\tldkeys = nilfs_btree_node_dkeys(left);\n\tldptrs = nilfs_btree_node_dptrs(left, lncmax);\n\tlnchildren = nilfs_btree_node_get_nchildren(left);\n\n\trdkeys = nilfs_btree_node_dkeys(right);\n\trdptrs = nilfs_btree_node_dptrs(right, rncmax);\n\trnchildren = nilfs_btree_node_get_nchildren(right);\n\n\tmemcpy(ldkeys + lnchildren, rdkeys, n * sizeof(*rdkeys));\n\tmemcpy(ldptrs + lnchildren, rdptrs, n * sizeof(*rdptrs));\n\tmemmove(rdkeys, rdkeys + n, (rnchildren - n) * sizeof(*rdkeys));\n\tmemmove(rdptrs, rdptrs + n, (rnchildren - n) * sizeof(*rdptrs));\n\n\tlnchildren += n;\n\trnchildren -= n;\n\tnilfs_btree_node_set_nchildren(left, lnchildren);\n\tnilfs_btree_node_set_nchildren(right, rnchildren);\n}\n\n \nstatic void nilfs_btree_node_move_right(struct nilfs_btree_node *left,\n\t\t\t\t\tstruct nilfs_btree_node *right,\n\t\t\t\t\tint n, int lncmax, int rncmax)\n{\n\t__le64 *ldkeys, *rdkeys;\n\t__le64 *ldptrs, *rdptrs;\n\tint lnchildren, rnchildren;\n\n\tldkeys = nilfs_btree_node_dkeys(left);\n\tldptrs = nilfs_btree_node_dptrs(left, lncmax);\n\tlnchildren = nilfs_btree_node_get_nchildren(left);\n\n\trdkeys = nilfs_btree_node_dkeys(right);\n\trdptrs = nilfs_btree_node_dptrs(right, rncmax);\n\trnchildren = nilfs_btree_node_get_nchildren(right);\n\n\tmemmove(rdkeys + n, rdkeys, rnchildren * sizeof(*rdkeys));\n\tmemmove(rdptrs + n, rdptrs, rnchildren * sizeof(*rdptrs));\n\tmemcpy(rdkeys, ldkeys + lnchildren - n, n * sizeof(*rdkeys));\n\tmemcpy(rdptrs, ldptrs + lnchildren - n, n * sizeof(*rdptrs));\n\n\tlnchildren -= n;\n\trnchildren += n;\n\tnilfs_btree_node_set_nchildren(left, lnchildren);\n\tnilfs_btree_node_set_nchildren(right, rnchildren);\n}\n\n \nstatic void nilfs_btree_node_insert(struct nilfs_btree_node *node, int index,\n\t\t\t\t    __u64 key, __u64 ptr, int ncmax)\n{\n\t__le64 *dkeys;\n\t__le64 *dptrs;\n\tint nchildren;\n\n\tdkeys = nilfs_btree_node_dkeys(node);\n\tdptrs = nilfs_btree_node_dptrs(node, ncmax);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tif (index < nchildren) {\n\t\tmemmove(dkeys + index + 1, dkeys + index,\n\t\t\t(nchildren - index) * sizeof(*dkeys));\n\t\tmemmove(dptrs + index + 1, dptrs + index,\n\t\t\t(nchildren - index) * sizeof(*dptrs));\n\t}\n\tdkeys[index] = cpu_to_le64(key);\n\tdptrs[index] = cpu_to_le64(ptr);\n\tnchildren++;\n\tnilfs_btree_node_set_nchildren(node, nchildren);\n}\n\n \nstatic void nilfs_btree_node_delete(struct nilfs_btree_node *node, int index,\n\t\t\t\t    __u64 *keyp, __u64 *ptrp, int ncmax)\n{\n\t__u64 key;\n\t__u64 ptr;\n\t__le64 *dkeys;\n\t__le64 *dptrs;\n\tint nchildren;\n\n\tdkeys = nilfs_btree_node_dkeys(node);\n\tdptrs = nilfs_btree_node_dptrs(node, ncmax);\n\tkey = le64_to_cpu(dkeys[index]);\n\tptr = le64_to_cpu(dptrs[index]);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tif (keyp != NULL)\n\t\t*keyp = key;\n\tif (ptrp != NULL)\n\t\t*ptrp = ptr;\n\n\tif (index < nchildren - 1) {\n\t\tmemmove(dkeys + index, dkeys + index + 1,\n\t\t\t(nchildren - index - 1) * sizeof(*dkeys));\n\t\tmemmove(dptrs + index, dptrs + index + 1,\n\t\t\t(nchildren - index - 1) * sizeof(*dptrs));\n\t}\n\tnchildren--;\n\tnilfs_btree_node_set_nchildren(node, nchildren);\n}\n\nstatic int nilfs_btree_node_lookup(const struct nilfs_btree_node *node,\n\t\t\t\t   __u64 key, int *indexp)\n{\n\t__u64 nkey;\n\tint index, low, high, s;\n\n\t \n\tlow = 0;\n\thigh = nilfs_btree_node_get_nchildren(node) - 1;\n\tindex = 0;\n\ts = 0;\n\twhile (low <= high) {\n\t\tindex = (low + high) / 2;\n\t\tnkey = nilfs_btree_node_get_key(node, index);\n\t\tif (nkey == key) {\n\t\t\ts = 0;\n\t\t\tgoto out;\n\t\t} else if (nkey < key) {\n\t\t\tlow = index + 1;\n\t\t\ts = -1;\n\t\t} else {\n\t\t\thigh = index - 1;\n\t\t\ts = 1;\n\t\t}\n\t}\n\n\t \n\tif (nilfs_btree_node_get_level(node) > NILFS_BTREE_LEVEL_NODE_MIN) {\n\t\tif (s > 0 && index > 0)\n\t\t\tindex--;\n\t} else if (s < 0)\n\t\tindex++;\n\n out:\n\t*indexp = index;\n\n\treturn s == 0;\n}\n\n \nstatic int nilfs_btree_node_broken(const struct nilfs_btree_node *node,\n\t\t\t\t   size_t size, struct inode *inode,\n\t\t\t\t   sector_t blocknr)\n{\n\tint level, flags, nchildren;\n\tint ret = 0;\n\n\tlevel = nilfs_btree_node_get_level(node);\n\tflags = nilfs_btree_node_get_flags(node);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\n\tif (unlikely(level < NILFS_BTREE_LEVEL_NODE_MIN ||\n\t\t     level >= NILFS_BTREE_LEVEL_MAX ||\n\t\t     (flags & NILFS_BTREE_NODE_ROOT) ||\n\t\t     nchildren < 0 ||\n\t\t     nchildren > NILFS_BTREE_NODE_NCHILDREN_MAX(size))) {\n\t\tnilfs_crit(inode->i_sb,\n\t\t\t   \"bad btree node (ino=%lu, blocknr=%llu): level = %d, flags = 0x%x, nchildren = %d\",\n\t\t\t   inode->i_ino, (unsigned long long)blocknr, level,\n\t\t\t   flags, nchildren);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n\n \nstatic int nilfs_btree_root_broken(const struct nilfs_btree_node *node,\n\t\t\t\t   struct inode *inode)\n{\n\tint level, flags, nchildren;\n\tint ret = 0;\n\n\tlevel = nilfs_btree_node_get_level(node);\n\tflags = nilfs_btree_node_get_flags(node);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\n\tif (unlikely(level < NILFS_BTREE_LEVEL_NODE_MIN ||\n\t\t     level >= NILFS_BTREE_LEVEL_MAX ||\n\t\t     nchildren < 0 ||\n\t\t     nchildren > NILFS_BTREE_ROOT_NCHILDREN_MAX)) {\n\t\tnilfs_crit(inode->i_sb,\n\t\t\t   \"bad btree root (ino=%lu): level = %d, flags = 0x%x, nchildren = %d\",\n\t\t\t   inode->i_ino, level, flags, nchildren);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n\nint nilfs_btree_broken_node_block(struct buffer_head *bh)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tif (buffer_nilfs_checked(bh))\n\t\treturn 0;\n\n\tinode = bh->b_folio->mapping->host;\n\tret = nilfs_btree_node_broken((struct nilfs_btree_node *)bh->b_data,\n\t\t\t\t      bh->b_size, inode, bh->b_blocknr);\n\tif (likely(!ret))\n\t\tset_buffer_nilfs_checked(bh);\n\treturn ret;\n}\n\nstatic struct nilfs_btree_node *\nnilfs_btree_get_root(const struct nilfs_bmap *btree)\n{\n\treturn (struct nilfs_btree_node *)btree->b_u.u_data;\n}\n\nstatic struct nilfs_btree_node *\nnilfs_btree_get_nonroot_node(const struct nilfs_btree_path *path, int level)\n{\n\treturn (struct nilfs_btree_node *)path[level].bp_bh->b_data;\n}\n\nstatic struct nilfs_btree_node *\nnilfs_btree_get_sib_node(const struct nilfs_btree_path *path, int level)\n{\n\treturn (struct nilfs_btree_node *)path[level].bp_sib_bh->b_data;\n}\n\nstatic int nilfs_btree_height(const struct nilfs_bmap *btree)\n{\n\treturn nilfs_btree_node_get_level(nilfs_btree_get_root(btree)) + 1;\n}\n\nstatic struct nilfs_btree_node *\nnilfs_btree_get_node(const struct nilfs_bmap *btree,\n\t\t     const struct nilfs_btree_path *path,\n\t\t     int level, int *ncmaxp)\n{\n\tstruct nilfs_btree_node *node;\n\n\tif (level == nilfs_btree_height(btree) - 1) {\n\t\tnode = nilfs_btree_get_root(btree);\n\t\t*ncmaxp = NILFS_BTREE_ROOT_NCHILDREN_MAX;\n\t} else {\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\t*ncmaxp = nilfs_btree_nchildren_per_block(btree);\n\t}\n\treturn node;\n}\n\nstatic int nilfs_btree_bad_node(const struct nilfs_bmap *btree,\n\t\t\t\tstruct nilfs_btree_node *node, int level)\n{\n\tif (unlikely(nilfs_btree_node_get_level(node) != level)) {\n\t\tdump_stack();\n\t\tnilfs_crit(btree->b_inode->i_sb,\n\t\t\t   \"btree level mismatch (ino=%lu): %d != %d\",\n\t\t\t   btree->b_inode->i_ino,\n\t\t\t   nilfs_btree_node_get_level(node), level);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct nilfs_btree_readahead_info {\n\tstruct nilfs_btree_node *node;\t \n\tint max_ra_blocks;\t\t \n\tint index;\t\t\t \n\tint ncmax;\t\t\t \n};\n\nstatic int __nilfs_btree_get_block(const struct nilfs_bmap *btree, __u64 ptr,\n\t\t\t\t   struct buffer_head **bhp,\n\t\t\t\t   const struct nilfs_btree_readahead_info *ra)\n{\n\tstruct inode *btnc_inode = NILFS_BMAP_I(btree)->i_assoc_inode;\n\tstruct address_space *btnc = btnc_inode->i_mapping;\n\tstruct buffer_head *bh, *ra_bh;\n\tsector_t submit_ptr = 0;\n\tint ret;\n\n\tret = nilfs_btnode_submit_block(btnc, ptr, 0, REQ_OP_READ, &bh,\n\t\t\t\t\t&submit_ptr);\n\tif (ret) {\n\t\tif (likely(ret == -EEXIST))\n\t\t\tgoto out_check;\n\t\tif (ret == -ENOENT) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (ra) {\n\t\tint i, n;\n\t\t__u64 ptr2;\n\n\t\t \n\t\tfor (n = ra->max_ra_blocks, i = ra->index + 1;\n\t\t     n > 0 && i < ra->ncmax; n--, i++) {\n\t\t\tptr2 = nilfs_btree_node_get_ptr(ra->node, i, ra->ncmax);\n\n\t\t\tret = nilfs_btnode_submit_block(btnc, ptr2, 0,\n\t\t\t\t\t\tREQ_OP_READ | REQ_RAHEAD,\n\t\t\t\t\t\t&ra_bh, &submit_ptr);\n\t\t\tif (likely(!ret || ret == -EEXIST))\n\t\t\t\tbrelse(ra_bh);\n\t\t\telse if (ret != -EBUSY)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_locked(bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(bh);\n\n out_no_wait:\n\tif (!buffer_uptodate(bh)) {\n\t\tnilfs_err(btree->b_inode->i_sb,\n\t\t\t  \"I/O error reading b-tree node block (ino=%lu, blocknr=%llu)\",\n\t\t\t  btree->b_inode->i_ino, (unsigned long long)ptr);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n out_check:\n\tif (nilfs_btree_broken_node_block(bh)) {\n\t\tclear_buffer_uptodate(bh);\n\t\tbrelse(bh);\n\t\treturn -EINVAL;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}\n\nstatic int nilfs_btree_get_block(const struct nilfs_bmap *btree, __u64 ptr,\n\t\t\t\t   struct buffer_head **bhp)\n{\n\treturn __nilfs_btree_get_block(btree, ptr, bhp, NULL);\n}\n\nstatic int nilfs_btree_do_lookup(const struct nilfs_bmap *btree,\n\t\t\t\t struct nilfs_btree_path *path,\n\t\t\t\t __u64 key, __u64 *ptrp, int minlevel,\n\t\t\t\t int readahead)\n{\n\tstruct nilfs_btree_node *node;\n\tstruct nilfs_btree_readahead_info p, *ra;\n\t__u64 ptr;\n\tint level, index, found, ncmax, ret;\n\n\tnode = nilfs_btree_get_root(btree);\n\tlevel = nilfs_btree_node_get_level(node);\n\tif (level < minlevel || nilfs_btree_node_get_nchildren(node) <= 0)\n\t\treturn -ENOENT;\n\n\tfound = nilfs_btree_node_lookup(node, key, &index);\n\tptr = nilfs_btree_node_get_ptr(node, index,\n\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\tpath[level].bp_bh = NULL;\n\tpath[level].bp_index = index;\n\n\tncmax = nilfs_btree_nchildren_per_block(btree);\n\n\twhile (--level >= minlevel) {\n\t\tra = NULL;\n\t\tif (level == NILFS_BTREE_LEVEL_NODE_MIN && readahead) {\n\t\t\tp.node = nilfs_btree_get_node(btree, path, level + 1,\n\t\t\t\t\t\t      &p.ncmax);\n\t\t\tp.index = index;\n\t\t\tp.max_ra_blocks = 7;\n\t\t\tra = &p;\n\t\t}\n\t\tret = __nilfs_btree_get_block(btree, ptr, &path[level].bp_bh,\n\t\t\t\t\t      ra);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tif (nilfs_btree_bad_node(btree, node, level))\n\t\t\treturn -EINVAL;\n\t\tif (!found)\n\t\t\tfound = nilfs_btree_node_lookup(node, key, &index);\n\t\telse\n\t\t\tindex = 0;\n\t\tif (index < ncmax) {\n\t\t\tptr = nilfs_btree_node_get_ptr(node, index, ncmax);\n\t\t} else {\n\t\t\tWARN_ON(found || level != NILFS_BTREE_LEVEL_NODE_MIN);\n\t\t\t \n\t\t\tptr = NILFS_BMAP_INVALID_PTR;\n\t\t}\n\t\tpath[level].bp_index = index;\n\t}\n\tif (!found)\n\t\treturn -ENOENT;\n\n\tif (ptrp != NULL)\n\t\t*ptrp = ptr;\n\n\treturn 0;\n}\n\nstatic int nilfs_btree_do_lookup_last(const struct nilfs_bmap *btree,\n\t\t\t\t      struct nilfs_btree_path *path,\n\t\t\t\t      __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node;\n\t__u64 ptr;\n\tint index, level, ncmax, ret;\n\n\tnode = nilfs_btree_get_root(btree);\n\tindex = nilfs_btree_node_get_nchildren(node) - 1;\n\tif (index < 0)\n\t\treturn -ENOENT;\n\tlevel = nilfs_btree_node_get_level(node);\n\tptr = nilfs_btree_node_get_ptr(node, index,\n\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\tpath[level].bp_bh = NULL;\n\tpath[level].bp_index = index;\n\tncmax = nilfs_btree_nchildren_per_block(btree);\n\n\tfor (level--; level > 0; level--) {\n\t\tret = nilfs_btree_get_block(btree, ptr, &path[level].bp_bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tif (nilfs_btree_bad_node(btree, node, level))\n\t\t\treturn -EINVAL;\n\t\tindex = nilfs_btree_node_get_nchildren(node) - 1;\n\t\tptr = nilfs_btree_node_get_ptr(node, index, ncmax);\n\t\tpath[level].bp_index = index;\n\t}\n\n\tif (keyp != NULL)\n\t\t*keyp = nilfs_btree_node_get_key(node, index);\n\tif (ptrp != NULL)\n\t\t*ptrp = ptr;\n\n\treturn 0;\n}\n\n \nstatic int nilfs_btree_get_next_key(const struct nilfs_bmap *btree,\n\t\t\t\t    const struct nilfs_btree_path *path,\n\t\t\t\t    int minlevel, __u64 *nextkey)\n{\n\tstruct nilfs_btree_node *node;\n\tint maxlevel = nilfs_btree_height(btree) - 1;\n\tint index, next_adj, level;\n\n\t \n\tnext_adj = 0;\n\tfor (level = minlevel; level <= maxlevel; level++) {\n\t\tif (level == maxlevel)\n\t\t\tnode = nilfs_btree_get_root(btree);\n\t\telse\n\t\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\n\t\tindex = path[level].bp_index + next_adj;\n\t\tif (index < nilfs_btree_node_get_nchildren(node)) {\n\t\t\t \n\t\t\t*nextkey = nilfs_btree_node_get_key(node, index);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tnext_adj = 1;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int nilfs_btree_lookup(const struct nilfs_bmap *btree,\n\t\t\t      __u64 key, int level, __u64 *ptrp)\n{\n\tstruct nilfs_btree_path *path;\n\tint ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, ptrp, level, 0);\n\n\tnilfs_btree_free_path(path);\n\n\treturn ret;\n}\n\nstatic int nilfs_btree_lookup_contig(const struct nilfs_bmap *btree,\n\t\t\t\t     __u64 key, __u64 *ptrp,\n\t\t\t\t     unsigned int maxblocks)\n{\n\tstruct nilfs_btree_path *path;\n\tstruct nilfs_btree_node *node;\n\tstruct inode *dat = NULL;\n\t__u64 ptr, ptr2;\n\tsector_t blocknr;\n\tint level = NILFS_BTREE_LEVEL_NODE_MIN;\n\tint ret, cnt, index, maxlevel, ncmax;\n\tstruct nilfs_btree_readahead_info p;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, &ptr, level, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (NILFS_BMAP_USE_VBN(btree)) {\n\t\tdat = nilfs_bmap_get_dat(btree);\n\t\tret = nilfs_dat_translate(dat, ptr, &blocknr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tptr = blocknr;\n\t}\n\tcnt = 1;\n\tif (cnt == maxblocks)\n\t\tgoto end;\n\n\tmaxlevel = nilfs_btree_height(btree) - 1;\n\tnode = nilfs_btree_get_node(btree, path, level, &ncmax);\n\tindex = path[level].bp_index + 1;\n\tfor (;;) {\n\t\twhile (index < nilfs_btree_node_get_nchildren(node)) {\n\t\t\tif (nilfs_btree_node_get_key(node, index) !=\n\t\t\t    key + cnt)\n\t\t\t\tgoto end;\n\t\t\tptr2 = nilfs_btree_node_get_ptr(node, index, ncmax);\n\t\t\tif (dat) {\n\t\t\t\tret = nilfs_dat_translate(dat, ptr2, &blocknr);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tptr2 = blocknr;\n\t\t\t}\n\t\t\tif (ptr2 != ptr + cnt || ++cnt == maxblocks)\n\t\t\t\tgoto end;\n\t\t\tindex++;\n\t\t}\n\t\tif (level == maxlevel)\n\t\t\tbreak;\n\n\t\t \n\t\tp.node = nilfs_btree_get_node(btree, path, level + 1, &p.ncmax);\n\t\tp.index = path[level + 1].bp_index + 1;\n\t\tp.max_ra_blocks = 7;\n\t\tif (p.index >= nilfs_btree_node_get_nchildren(p.node) ||\n\t\t    nilfs_btree_node_get_key(p.node, p.index) != key + cnt)\n\t\t\tbreak;\n\t\tptr2 = nilfs_btree_node_get_ptr(p.node, p.index, p.ncmax);\n\t\tpath[level + 1].bp_index = p.index;\n\n\t\tbrelse(path[level].bp_bh);\n\t\tpath[level].bp_bh = NULL;\n\n\t\tret = __nilfs_btree_get_block(btree, ptr2, &path[level].bp_bh,\n\t\t\t\t\t      &p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tncmax = nilfs_btree_nchildren_per_block(btree);\n\t\tindex = 0;\n\t\tpath[level].bp_index = index;\n\t}\n end:\n\t*ptrp = ptr;\n\tret = cnt;\n out:\n\tnilfs_btree_free_path(path);\n\treturn ret;\n}\n\nstatic void nilfs_btree_promote_key(struct nilfs_bmap *btree,\n\t\t\t\t    struct nilfs_btree_path *path,\n\t\t\t\t    int level, __u64 key)\n{\n\tif (level < nilfs_btree_height(btree) - 1) {\n\t\tdo {\n\t\t\tnilfs_btree_node_set_key(\n\t\t\t\tnilfs_btree_get_nonroot_node(path, level),\n\t\t\t\tpath[level].bp_index, key);\n\t\t\tif (!buffer_dirty(path[level].bp_bh))\n\t\t\t\tmark_buffer_dirty(path[level].bp_bh);\n\t\t} while ((path[level].bp_index == 0) &&\n\t\t\t (++level < nilfs_btree_height(btree) - 1));\n\t}\n\n\t \n\tif (level == nilfs_btree_height(btree) - 1) {\n\t\tnilfs_btree_node_set_key(nilfs_btree_get_root(btree),\n\t\t\t\t\t path[level].bp_index, key);\n\t}\n}\n\nstatic void nilfs_btree_do_insert(struct nilfs_bmap *btree,\n\t\t\t\t  struct nilfs_btree_path *path,\n\t\t\t\t  int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node;\n\tint ncblk;\n\n\tif (level < nilfs_btree_height(btree) - 1) {\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tncblk = nilfs_btree_nchildren_per_block(btree);\n\t\tnilfs_btree_node_insert(node, path[level].bp_index,\n\t\t\t\t\t*keyp, *ptrp, ncblk);\n\t\tif (!buffer_dirty(path[level].bp_bh))\n\t\t\tmark_buffer_dirty(path[level].bp_bh);\n\n\t\tif (path[level].bp_index == 0)\n\t\t\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\t\t\tnilfs_btree_node_get_key(node,\n\t\t\t\t\t\t\t\t\t 0));\n\t} else {\n\t\tnode = nilfs_btree_get_root(btree);\n\t\tnilfs_btree_node_insert(node, path[level].bp_index,\n\t\t\t\t\t*keyp, *ptrp,\n\t\t\t\t\tNILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t}\n}\n\nstatic void nilfs_btree_carry_left(struct nilfs_bmap *btree,\n\t\t\t\t   struct nilfs_btree_path *path,\n\t\t\t\t   int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *left;\n\tint nchildren, lnchildren, n, move, ncblk;\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tleft = nilfs_btree_get_sib_node(path, level);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tlnchildren = nilfs_btree_node_get_nchildren(left);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\tmove = 0;\n\n\tn = (nchildren + lnchildren + 1) / 2 - lnchildren;\n\tif (n > path[level].bp_index) {\n\t\t \n\t\tn--;\n\t\tmove = 1;\n\t}\n\n\tnilfs_btree_node_move_left(left, node, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\tnilfs_btree_node_get_key(node, 0));\n\n\tif (move) {\n\t\tbrelse(path[level].bp_bh);\n\t\tpath[level].bp_bh = path[level].bp_sib_bh;\n\t\tpath[level].bp_sib_bh = NULL;\n\t\tpath[level].bp_index += lnchildren;\n\t\tpath[level + 1].bp_index--;\n\t} else {\n\t\tbrelse(path[level].bp_sib_bh);\n\t\tpath[level].bp_sib_bh = NULL;\n\t\tpath[level].bp_index -= n;\n\t}\n\n\tnilfs_btree_do_insert(btree, path, level, keyp, ptrp);\n}\n\nstatic void nilfs_btree_carry_right(struct nilfs_bmap *btree,\n\t\t\t\t    struct nilfs_btree_path *path,\n\t\t\t\t    int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *right;\n\tint nchildren, rnchildren, n, move, ncblk;\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tright = nilfs_btree_get_sib_node(path, level);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\trnchildren = nilfs_btree_node_get_nchildren(right);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\tmove = 0;\n\n\tn = (nchildren + rnchildren + 1) / 2 - rnchildren;\n\tif (n > nchildren - path[level].bp_index) {\n\t\t \n\t\tn--;\n\t\tmove = 1;\n\t}\n\n\tnilfs_btree_node_move_right(node, right, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tpath[level + 1].bp_index++;\n\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\tnilfs_btree_node_get_key(right, 0));\n\tpath[level + 1].bp_index--;\n\n\tif (move) {\n\t\tbrelse(path[level].bp_bh);\n\t\tpath[level].bp_bh = path[level].bp_sib_bh;\n\t\tpath[level].bp_sib_bh = NULL;\n\t\tpath[level].bp_index -= nilfs_btree_node_get_nchildren(node);\n\t\tpath[level + 1].bp_index++;\n\t} else {\n\t\tbrelse(path[level].bp_sib_bh);\n\t\tpath[level].bp_sib_bh = NULL;\n\t}\n\n\tnilfs_btree_do_insert(btree, path, level, keyp, ptrp);\n}\n\nstatic void nilfs_btree_split(struct nilfs_bmap *btree,\n\t\t\t      struct nilfs_btree_path *path,\n\t\t\t      int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *right;\n\tint nchildren, n, move, ncblk;\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tright = nilfs_btree_get_sib_node(path, level);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\tmove = 0;\n\n\tn = (nchildren + 1) / 2;\n\tif (n > nchildren - path[level].bp_index) {\n\t\tn--;\n\t\tmove = 1;\n\t}\n\n\tnilfs_btree_node_move_right(node, right, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tif (move) {\n\t\tpath[level].bp_index -= nilfs_btree_node_get_nchildren(node);\n\t\tnilfs_btree_node_insert(right, path[level].bp_index,\n\t\t\t\t\t*keyp, *ptrp, ncblk);\n\n\t\t*keyp = nilfs_btree_node_get_key(right, 0);\n\t\t*ptrp = path[level].bp_newreq.bpr_ptr;\n\n\t\tbrelse(path[level].bp_bh);\n\t\tpath[level].bp_bh = path[level].bp_sib_bh;\n\t\tpath[level].bp_sib_bh = NULL;\n\t} else {\n\t\tnilfs_btree_do_insert(btree, path, level, keyp, ptrp);\n\n\t\t*keyp = nilfs_btree_node_get_key(right, 0);\n\t\t*ptrp = path[level].bp_newreq.bpr_ptr;\n\n\t\tbrelse(path[level].bp_sib_bh);\n\t\tpath[level].bp_sib_bh = NULL;\n\t}\n\n\tpath[level + 1].bp_index++;\n}\n\nstatic void nilfs_btree_grow(struct nilfs_bmap *btree,\n\t\t\t     struct nilfs_btree_path *path,\n\t\t\t     int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *root, *child;\n\tint n, ncblk;\n\n\troot = nilfs_btree_get_root(btree);\n\tchild = nilfs_btree_get_sib_node(path, level);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tn = nilfs_btree_node_get_nchildren(root);\n\n\tnilfs_btree_node_move_right(root, child, n,\n\t\t\t\t    NILFS_BTREE_ROOT_NCHILDREN_MAX, ncblk);\n\tnilfs_btree_node_set_level(root, level + 1);\n\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tpath[level].bp_bh = path[level].bp_sib_bh;\n\tpath[level].bp_sib_bh = NULL;\n\n\tnilfs_btree_do_insert(btree, path, level, keyp, ptrp);\n\n\t*keyp = nilfs_btree_node_get_key(child, 0);\n\t*ptrp = path[level].bp_newreq.bpr_ptr;\n}\n\nstatic __u64 nilfs_btree_find_near(const struct nilfs_bmap *btree,\n\t\t\t\t   const struct nilfs_btree_path *path)\n{\n\tstruct nilfs_btree_node *node;\n\tint level, ncmax;\n\n\tif (path == NULL)\n\t\treturn NILFS_BMAP_INVALID_PTR;\n\n\t \n\tlevel = NILFS_BTREE_LEVEL_NODE_MIN;\n\tif (path[level].bp_index > 0) {\n\t\tnode = nilfs_btree_get_node(btree, path, level, &ncmax);\n\t\treturn nilfs_btree_node_get_ptr(node,\n\t\t\t\t\t\tpath[level].bp_index - 1,\n\t\t\t\t\t\tncmax);\n\t}\n\n\t \n\tlevel = NILFS_BTREE_LEVEL_NODE_MIN + 1;\n\tif (level <= nilfs_btree_height(btree) - 1) {\n\t\tnode = nilfs_btree_get_node(btree, path, level, &ncmax);\n\t\treturn nilfs_btree_node_get_ptr(node, path[level].bp_index,\n\t\t\t\t\t\tncmax);\n\t}\n\n\treturn NILFS_BMAP_INVALID_PTR;\n}\n\nstatic __u64 nilfs_btree_find_target_v(const struct nilfs_bmap *btree,\n\t\t\t\t       const struct nilfs_btree_path *path,\n\t\t\t\t       __u64 key)\n{\n\t__u64 ptr;\n\n\tptr = nilfs_bmap_find_target_seq(btree, key);\n\tif (ptr != NILFS_BMAP_INVALID_PTR)\n\t\t \n\t\treturn ptr;\n\n\tptr = nilfs_btree_find_near(btree, path);\n\tif (ptr != NILFS_BMAP_INVALID_PTR)\n\t\t \n\t\treturn ptr;\n\n\t \n\treturn nilfs_bmap_find_target_in_group(btree);\n}\n\nstatic int nilfs_btree_prepare_insert(struct nilfs_bmap *btree,\n\t\t\t\t      struct nilfs_btree_path *path,\n\t\t\t\t      int *levelp, __u64 key, __u64 ptr,\n\t\t\t\t      struct nilfs_bmap_stats *stats)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *node, *parent, *sib;\n\t__u64 sibptr;\n\tint pindex, level, ncmax, ncblk, ret;\n\tstruct inode *dat = NULL;\n\n\tstats->bs_nblocks = 0;\n\tlevel = NILFS_BTREE_LEVEL_DATA;\n\n\t \n\tif (NILFS_BMAP_USE_VBN(btree)) {\n\t\tpath[level].bp_newreq.bpr_ptr =\n\t\t\tnilfs_btree_find_target_v(btree, path, key);\n\t\tdat = nilfs_bmap_get_dat(btree);\n\t}\n\n\tret = nilfs_bmap_prepare_alloc_ptr(btree, &path[level].bp_newreq, dat);\n\tif (ret < 0)\n\t\tgoto err_out_data;\n\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN;\n\t     level < nilfs_btree_height(btree) - 1;\n\t     level++) {\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tif (nilfs_btree_node_get_nchildren(node) < ncblk) {\n\t\t\tpath[level].bp_op = nilfs_btree_do_insert;\n\t\t\tstats->bs_nblocks++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\t\tpindex = path[level + 1].bp_index;\n\n\t\t \n\t\tif (pindex > 0) {\n\t\t\tsibptr = nilfs_btree_node_get_ptr(parent, pindex - 1,\n\t\t\t\t\t\t\t  ncmax);\n\t\t\tret = nilfs_btree_get_block(btree, sibptr, &bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out_child_node;\n\t\t\tsib = (struct nilfs_btree_node *)bh->b_data;\n\t\t\tif (nilfs_btree_node_get_nchildren(sib) < ncblk) {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_carry_left;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pindex < nilfs_btree_node_get_nchildren(parent) - 1) {\n\t\t\tsibptr = nilfs_btree_node_get_ptr(parent, pindex + 1,\n\t\t\t\t\t\t\t  ncmax);\n\t\t\tret = nilfs_btree_get_block(btree, sibptr, &bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out_child_node;\n\t\t\tsib = (struct nilfs_btree_node *)bh->b_data;\n\t\t\tif (nilfs_btree_node_get_nchildren(sib) < ncblk) {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_carry_right;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpath[level].bp_newreq.bpr_ptr =\n\t\t\tpath[level - 1].bp_newreq.bpr_ptr + 1;\n\t\tret = nilfs_bmap_prepare_alloc_ptr(btree,\n\t\t\t\t\t\t   &path[level].bp_newreq, dat);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_child_node;\n\t\tret = nilfs_btree_get_new_block(btree,\n\t\t\t\t\t\tpath[level].bp_newreq.bpr_ptr,\n\t\t\t\t\t\t&bh);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_curr_node;\n\n\t\tstats->bs_nblocks++;\n\n\t\tsib = (struct nilfs_btree_node *)bh->b_data;\n\t\tnilfs_btree_node_init(sib, 0, level, 0, ncblk, NULL, NULL);\n\t\tpath[level].bp_sib_bh = bh;\n\t\tpath[level].bp_op = nilfs_btree_split;\n\t}\n\n\t \n\tnode = nilfs_btree_get_root(btree);\n\tif (nilfs_btree_node_get_nchildren(node) <\n\t    NILFS_BTREE_ROOT_NCHILDREN_MAX) {\n\t\tpath[level].bp_op = nilfs_btree_do_insert;\n\t\tstats->bs_nblocks++;\n\t\tgoto out;\n\t}\n\n\t \n\tpath[level].bp_newreq.bpr_ptr = path[level - 1].bp_newreq.bpr_ptr + 1;\n\tret = nilfs_bmap_prepare_alloc_ptr(btree, &path[level].bp_newreq, dat);\n\tif (ret < 0)\n\t\tgoto err_out_child_node;\n\tret = nilfs_btree_get_new_block(btree, path[level].bp_newreq.bpr_ptr,\n\t\t\t\t\t&bh);\n\tif (ret < 0)\n\t\tgoto err_out_curr_node;\n\n\tnilfs_btree_node_init((struct nilfs_btree_node *)bh->b_data,\n\t\t\t      0, level, 0, ncblk, NULL, NULL);\n\tpath[level].bp_sib_bh = bh;\n\tpath[level].bp_op = nilfs_btree_grow;\n\n\tlevel++;\n\tpath[level].bp_op = nilfs_btree_do_insert;\n\n\t \n\tstats->bs_nblocks += 2;\n\n\t \n out:\n\t*levelp = level;\n\treturn ret;\n\n\t \n err_out_curr_node:\n\tnilfs_bmap_abort_alloc_ptr(btree, &path[level].bp_newreq, dat);\n err_out_child_node:\n\tfor (level--; level > NILFS_BTREE_LEVEL_DATA; level--) {\n\t\tnilfs_btnode_delete(path[level].bp_sib_bh);\n\t\tnilfs_bmap_abort_alloc_ptr(btree, &path[level].bp_newreq, dat);\n\n\t}\n\n\tnilfs_bmap_abort_alloc_ptr(btree, &path[level].bp_newreq, dat);\n err_out_data:\n\t*levelp = level;\n\tstats->bs_nblocks = 0;\n\treturn ret;\n}\n\nstatic void nilfs_btree_commit_insert(struct nilfs_bmap *btree,\n\t\t\t\t      struct nilfs_btree_path *path,\n\t\t\t\t      int maxlevel, __u64 key, __u64 ptr)\n{\n\tstruct inode *dat = NULL;\n\tint level;\n\n\tset_buffer_nilfs_volatile((struct buffer_head *)((unsigned long)ptr));\n\tptr = path[NILFS_BTREE_LEVEL_DATA].bp_newreq.bpr_ptr;\n\tif (NILFS_BMAP_USE_VBN(btree)) {\n\t\tnilfs_bmap_set_target_v(btree, key, ptr);\n\t\tdat = nilfs_bmap_get_dat(btree);\n\t}\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN; level <= maxlevel; level++) {\n\t\tnilfs_bmap_commit_alloc_ptr(btree,\n\t\t\t\t\t    &path[level - 1].bp_newreq, dat);\n\t\tpath[level].bp_op(btree, path, level, &key, &ptr);\n\t}\n\n\tif (!nilfs_bmap_dirty(btree))\n\t\tnilfs_bmap_set_dirty(btree);\n}\n\nstatic int nilfs_btree_insert(struct nilfs_bmap *btree, __u64 key, __u64 ptr)\n{\n\tstruct nilfs_btree_path *path;\n\tstruct nilfs_bmap_stats stats;\n\tint level, ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, NULL,\n\t\t\t\t    NILFS_BTREE_LEVEL_NODE_MIN, 0);\n\tif (ret != -ENOENT) {\n\t\tif (ret == 0)\n\t\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = nilfs_btree_prepare_insert(btree, path, &level, key, ptr, &stats);\n\tif (ret < 0)\n\t\tgoto out;\n\tnilfs_btree_commit_insert(btree, path, level, key, ptr);\n\tnilfs_inode_add_blocks(btree->b_inode, stats.bs_nblocks);\n\n out:\n\tnilfs_btree_free_path(path);\n\treturn ret;\n}\n\nstatic void nilfs_btree_do_delete(struct nilfs_bmap *btree,\n\t\t\t\t  struct nilfs_btree_path *path,\n\t\t\t\t  int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node;\n\tint ncblk;\n\n\tif (level < nilfs_btree_height(btree) - 1) {\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tncblk = nilfs_btree_nchildren_per_block(btree);\n\t\tnilfs_btree_node_delete(node, path[level].bp_index,\n\t\t\t\t\tkeyp, ptrp, ncblk);\n\t\tif (!buffer_dirty(path[level].bp_bh))\n\t\t\tmark_buffer_dirty(path[level].bp_bh);\n\t\tif (path[level].bp_index == 0)\n\t\t\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\tnilfs_btree_node_get_key(node, 0));\n\t} else {\n\t\tnode = nilfs_btree_get_root(btree);\n\t\tnilfs_btree_node_delete(node, path[level].bp_index,\n\t\t\t\t\tkeyp, ptrp,\n\t\t\t\t\tNILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t}\n}\n\nstatic void nilfs_btree_borrow_left(struct nilfs_bmap *btree,\n\t\t\t\t    struct nilfs_btree_path *path,\n\t\t\t\t    int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *left;\n\tint nchildren, lnchildren, n, ncblk;\n\n\tnilfs_btree_do_delete(btree, path, level, keyp, ptrp);\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tleft = nilfs_btree_get_sib_node(path, level);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tlnchildren = nilfs_btree_node_get_nchildren(left);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tn = (nchildren + lnchildren) / 2 - nchildren;\n\n\tnilfs_btree_node_move_right(left, node, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\tnilfs_btree_node_get_key(node, 0));\n\n\tbrelse(path[level].bp_sib_bh);\n\tpath[level].bp_sib_bh = NULL;\n\tpath[level].bp_index += n;\n}\n\nstatic void nilfs_btree_borrow_right(struct nilfs_bmap *btree,\n\t\t\t\t     struct nilfs_btree_path *path,\n\t\t\t\t     int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *right;\n\tint nchildren, rnchildren, n, ncblk;\n\n\tnilfs_btree_do_delete(btree, path, level, keyp, ptrp);\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tright = nilfs_btree_get_sib_node(path, level);\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\trnchildren = nilfs_btree_node_get_nchildren(right);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tn = (nchildren + rnchildren) / 2 - nchildren;\n\n\tnilfs_btree_node_move_left(node, right, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tpath[level + 1].bp_index++;\n\tnilfs_btree_promote_key(btree, path, level + 1,\n\t\t\t\tnilfs_btree_node_get_key(right, 0));\n\tpath[level + 1].bp_index--;\n\n\tbrelse(path[level].bp_sib_bh);\n\tpath[level].bp_sib_bh = NULL;\n}\n\nstatic void nilfs_btree_concat_left(struct nilfs_bmap *btree,\n\t\t\t\t    struct nilfs_btree_path *path,\n\t\t\t\t    int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *left;\n\tint n, ncblk;\n\n\tnilfs_btree_do_delete(btree, path, level, keyp, ptrp);\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tleft = nilfs_btree_get_sib_node(path, level);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tn = nilfs_btree_node_get_nchildren(node);\n\n\tnilfs_btree_node_move_left(left, node, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_sib_bh))\n\t\tmark_buffer_dirty(path[level].bp_sib_bh);\n\n\tnilfs_btnode_delete(path[level].bp_bh);\n\tpath[level].bp_bh = path[level].bp_sib_bh;\n\tpath[level].bp_sib_bh = NULL;\n\tpath[level].bp_index += nilfs_btree_node_get_nchildren(left);\n}\n\nstatic void nilfs_btree_concat_right(struct nilfs_bmap *btree,\n\t\t\t\t     struct nilfs_btree_path *path,\n\t\t\t\t     int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *node, *right;\n\tint n, ncblk;\n\n\tnilfs_btree_do_delete(btree, path, level, keyp, ptrp);\n\n\tnode = nilfs_btree_get_nonroot_node(path, level);\n\tright = nilfs_btree_get_sib_node(path, level);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tn = nilfs_btree_node_get_nchildren(right);\n\n\tnilfs_btree_node_move_left(node, right, n, ncblk, ncblk);\n\n\tif (!buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\n\tnilfs_btnode_delete(path[level].bp_sib_bh);\n\tpath[level].bp_sib_bh = NULL;\n\tpath[level + 1].bp_index++;\n}\n\nstatic void nilfs_btree_shrink(struct nilfs_bmap *btree,\n\t\t\t       struct nilfs_btree_path *path,\n\t\t\t       int level, __u64 *keyp, __u64 *ptrp)\n{\n\tstruct nilfs_btree_node *root, *child;\n\tint n, ncblk;\n\n\tnilfs_btree_do_delete(btree, path, level, keyp, ptrp);\n\n\troot = nilfs_btree_get_root(btree);\n\tchild = nilfs_btree_get_nonroot_node(path, level);\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tnilfs_btree_node_delete(root, 0, NULL, NULL,\n\t\t\t\tNILFS_BTREE_ROOT_NCHILDREN_MAX);\n\tnilfs_btree_node_set_level(root, level);\n\tn = nilfs_btree_node_get_nchildren(child);\n\tnilfs_btree_node_move_left(root, child, n,\n\t\t\t\t   NILFS_BTREE_ROOT_NCHILDREN_MAX, ncblk);\n\n\tnilfs_btnode_delete(path[level].bp_bh);\n\tpath[level].bp_bh = NULL;\n}\n\nstatic void nilfs_btree_nop(struct nilfs_bmap *btree,\n\t\t\t    struct nilfs_btree_path *path,\n\t\t\t    int level, __u64 *keyp, __u64 *ptrp)\n{\n}\n\nstatic int nilfs_btree_prepare_delete(struct nilfs_bmap *btree,\n\t\t\t\t      struct nilfs_btree_path *path,\n\t\t\t\t      int *levelp,\n\t\t\t\t      struct nilfs_bmap_stats *stats,\n\t\t\t\t      struct inode *dat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *node, *parent, *sib;\n\t__u64 sibptr;\n\tint pindex, dindex, level, ncmin, ncmax, ncblk, ret;\n\n\tret = 0;\n\tstats->bs_nblocks = 0;\n\tncmin = NILFS_BTREE_NODE_NCHILDREN_MIN(nilfs_btree_node_size(btree));\n\tncblk = nilfs_btree_nchildren_per_block(btree);\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN, dindex = path[level].bp_index;\n\t     level < nilfs_btree_height(btree) - 1;\n\t     level++) {\n\t\tnode = nilfs_btree_get_nonroot_node(path, level);\n\t\tpath[level].bp_oldreq.bpr_ptr =\n\t\t\tnilfs_btree_node_get_ptr(node, dindex, ncblk);\n\t\tret = nilfs_bmap_prepare_end_ptr(btree,\n\t\t\t\t\t\t &path[level].bp_oldreq, dat);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_child_node;\n\n\t\tif (nilfs_btree_node_get_nchildren(node) > ncmin) {\n\t\t\tpath[level].bp_op = nilfs_btree_do_delete;\n\t\t\tstats->bs_nblocks++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\t\tpindex = path[level + 1].bp_index;\n\t\tdindex = pindex;\n\n\t\tif (pindex > 0) {\n\t\t\t \n\t\t\tsibptr = nilfs_btree_node_get_ptr(parent, pindex - 1,\n\t\t\t\t\t\t\t  ncmax);\n\t\t\tret = nilfs_btree_get_block(btree, sibptr, &bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out_curr_node;\n\t\t\tsib = (struct nilfs_btree_node *)bh->b_data;\n\t\t\tif (nilfs_btree_node_get_nchildren(sib) > ncmin) {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_borrow_left;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_concat_left;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\t \n\t\t\t}\n\t\t} else if (pindex <\n\t\t\t   nilfs_btree_node_get_nchildren(parent) - 1) {\n\t\t\t \n\t\t\tsibptr = nilfs_btree_node_get_ptr(parent, pindex + 1,\n\t\t\t\t\t\t\t  ncmax);\n\t\t\tret = nilfs_btree_get_block(btree, sibptr, &bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out_curr_node;\n\t\t\tsib = (struct nilfs_btree_node *)bh->b_data;\n\t\t\tif (nilfs_btree_node_get_nchildren(sib) > ncmin) {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_borrow_right;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tpath[level].bp_sib_bh = bh;\n\t\t\t\tpath[level].bp_op = nilfs_btree_concat_right;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\t \n\t\t\t\tdindex = pindex + 1;\n\t\t\t\t \n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tWARN_ON(level != nilfs_btree_height(btree) - 2);\n\t\t\tif (nilfs_btree_node_get_nchildren(node) - 1 <=\n\t\t\t    NILFS_BTREE_ROOT_NCHILDREN_MAX) {\n\t\t\t\tpath[level].bp_op = nilfs_btree_shrink;\n\t\t\t\tstats->bs_nblocks += 2;\n\t\t\t\tlevel++;\n\t\t\t\tpath[level].bp_op = nilfs_btree_nop;\n\t\t\t\tgoto shrink_root_child;\n\t\t\t} else {\n\t\t\t\tpath[level].bp_op = nilfs_btree_do_delete;\n\t\t\t\tstats->bs_nblocks++;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpath[level].bp_op = nilfs_btree_do_delete;\n\tstats->bs_nblocks++;\n\nshrink_root_child:\n\tnode = nilfs_btree_get_root(btree);\n\tpath[level].bp_oldreq.bpr_ptr =\n\t\tnilfs_btree_node_get_ptr(node, dindex,\n\t\t\t\t\t NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\n\tret = nilfs_bmap_prepare_end_ptr(btree, &path[level].bp_oldreq, dat);\n\tif (ret < 0)\n\t\tgoto err_out_child_node;\n\n\t \n out:\n\t*levelp = level;\n\treturn ret;\n\n\t \n err_out_curr_node:\n\tnilfs_bmap_abort_end_ptr(btree, &path[level].bp_oldreq, dat);\n err_out_child_node:\n\tfor (level--; level >= NILFS_BTREE_LEVEL_NODE_MIN; level--) {\n\t\tbrelse(path[level].bp_sib_bh);\n\t\tnilfs_bmap_abort_end_ptr(btree, &path[level].bp_oldreq, dat);\n\t}\n\t*levelp = level;\n\tstats->bs_nblocks = 0;\n\treturn ret;\n}\n\nstatic void nilfs_btree_commit_delete(struct nilfs_bmap *btree,\n\t\t\t\t      struct nilfs_btree_path *path,\n\t\t\t\t      int maxlevel, struct inode *dat)\n{\n\tint level;\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN; level <= maxlevel; level++) {\n\t\tnilfs_bmap_commit_end_ptr(btree, &path[level].bp_oldreq, dat);\n\t\tpath[level].bp_op(btree, path, level, NULL, NULL);\n\t}\n\n\tif (!nilfs_bmap_dirty(btree))\n\t\tnilfs_bmap_set_dirty(btree);\n}\n\nstatic int nilfs_btree_delete(struct nilfs_bmap *btree, __u64 key)\n\n{\n\tstruct nilfs_btree_path *path;\n\tstruct nilfs_bmap_stats stats;\n\tstruct inode *dat;\n\tint level, ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, NULL,\n\t\t\t\t    NILFS_BTREE_LEVEL_NODE_MIN, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\n\tdat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;\n\n\tret = nilfs_btree_prepare_delete(btree, path, &level, &stats, dat);\n\tif (ret < 0)\n\t\tgoto out;\n\tnilfs_btree_commit_delete(btree, path, level, dat);\n\tnilfs_inode_sub_blocks(btree->b_inode, stats.bs_nblocks);\n\nout:\n\tnilfs_btree_free_path(path);\n\treturn ret;\n}\n\nstatic int nilfs_btree_seek_key(const struct nilfs_bmap *btree, __u64 start,\n\t\t\t\t__u64 *keyp)\n{\n\tstruct nilfs_btree_path *path;\n\tconst int minlevel = NILFS_BTREE_LEVEL_NODE_MIN;\n\tint ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, start, NULL, minlevel, 0);\n\tif (!ret)\n\t\t*keyp = start;\n\telse if (ret == -ENOENT)\n\t\tret = nilfs_btree_get_next_key(btree, path, minlevel, keyp);\n\n\tnilfs_btree_free_path(path);\n\treturn ret;\n}\n\nstatic int nilfs_btree_last_key(const struct nilfs_bmap *btree, __u64 *keyp)\n{\n\tstruct nilfs_btree_path *path;\n\tint ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup_last(btree, path, keyp, NULL);\n\n\tnilfs_btree_free_path(path);\n\n\treturn ret;\n}\n\nstatic int nilfs_btree_check_delete(struct nilfs_bmap *btree, __u64 key)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *root, *node;\n\t__u64 maxkey, nextmaxkey;\n\t__u64 ptr;\n\tint nchildren, ret;\n\n\troot = nilfs_btree_get_root(btree);\n\tswitch (nilfs_btree_height(btree)) {\n\tcase 2:\n\t\tbh = NULL;\n\t\tnode = root;\n\t\tbreak;\n\tcase 3:\n\t\tnchildren = nilfs_btree_node_get_nchildren(root);\n\t\tif (nchildren > 1)\n\t\t\treturn 0;\n\t\tptr = nilfs_btree_node_get_ptr(root, nchildren - 1,\n\t\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t\tret = nilfs_btree_get_block(btree, ptr, &bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tmaxkey = nilfs_btree_node_get_key(node, nchildren - 1);\n\tnextmaxkey = (nchildren > 1) ?\n\t\tnilfs_btree_node_get_key(node, nchildren - 2) : 0;\n\tbrelse(bh);\n\n\treturn (maxkey == key) && (nextmaxkey < NILFS_BMAP_LARGE_LOW);\n}\n\nstatic int nilfs_btree_gather_data(struct nilfs_bmap *btree,\n\t\t\t\t   __u64 *keys, __u64 *ptrs, int nitems)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *node, *root;\n\t__le64 *dkeys;\n\t__le64 *dptrs;\n\t__u64 ptr;\n\tint nchildren, ncmax, i, ret;\n\n\troot = nilfs_btree_get_root(btree);\n\tswitch (nilfs_btree_height(btree)) {\n\tcase 2:\n\t\tbh = NULL;\n\t\tnode = root;\n\t\tncmax = NILFS_BTREE_ROOT_NCHILDREN_MAX;\n\t\tbreak;\n\tcase 3:\n\t\tnchildren = nilfs_btree_node_get_nchildren(root);\n\t\tWARN_ON(nchildren > 1);\n\t\tptr = nilfs_btree_node_get_ptr(root, nchildren - 1,\n\t\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t\tret = nilfs_btree_get_block(btree, ptr, &bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tncmax = nilfs_btree_nchildren_per_block(btree);\n\t\tbreak;\n\tdefault:\n\t\tnode = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tnchildren = nilfs_btree_node_get_nchildren(node);\n\tif (nchildren < nitems)\n\t\tnitems = nchildren;\n\tdkeys = nilfs_btree_node_dkeys(node);\n\tdptrs = nilfs_btree_node_dptrs(node, ncmax);\n\tfor (i = 0; i < nitems; i++) {\n\t\tkeys[i] = le64_to_cpu(dkeys[i]);\n\t\tptrs[i] = le64_to_cpu(dptrs[i]);\n\t}\n\n\tbrelse(bh);\n\n\treturn nitems;\n}\n\nstatic int\nnilfs_btree_prepare_convert_and_insert(struct nilfs_bmap *btree, __u64 key,\n\t\t\t\t       union nilfs_bmap_ptr_req *dreq,\n\t\t\t\t       union nilfs_bmap_ptr_req *nreq,\n\t\t\t\t       struct buffer_head **bhp,\n\t\t\t\t       struct nilfs_bmap_stats *stats)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *dat = NULL;\n\tint ret;\n\n\tstats->bs_nblocks = 0;\n\n\t \n\t \n\tif (NILFS_BMAP_USE_VBN(btree)) {\n\t\tdreq->bpr_ptr = nilfs_btree_find_target_v(btree, NULL, key);\n\t\tdat = nilfs_bmap_get_dat(btree);\n\t}\n\n\tret = nilfs_attach_btree_node_cache(&NILFS_BMAP_I(btree)->vfs_inode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nilfs_bmap_prepare_alloc_ptr(btree, dreq, dat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*bhp = NULL;\n\tstats->bs_nblocks++;\n\tif (nreq != NULL) {\n\t\tnreq->bpr_ptr = dreq->bpr_ptr + 1;\n\t\tret = nilfs_bmap_prepare_alloc_ptr(btree, nreq, dat);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_dreq;\n\n\t\tret = nilfs_btree_get_new_block(btree, nreq->bpr_ptr, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_nreq;\n\n\t\t*bhp = bh;\n\t\tstats->bs_nblocks++;\n\t}\n\n\t \n\treturn 0;\n\n\t \n err_out_nreq:\n\tnilfs_bmap_abort_alloc_ptr(btree, nreq, dat);\n err_out_dreq:\n\tnilfs_bmap_abort_alloc_ptr(btree, dreq, dat);\n\tstats->bs_nblocks = 0;\n\treturn ret;\n\n}\n\nstatic void\nnilfs_btree_commit_convert_and_insert(struct nilfs_bmap *btree,\n\t\t\t\t      __u64 key, __u64 ptr,\n\t\t\t\t      const __u64 *keys, const __u64 *ptrs,\n\t\t\t\t      int n,\n\t\t\t\t      union nilfs_bmap_ptr_req *dreq,\n\t\t\t\t      union nilfs_bmap_ptr_req *nreq,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct nilfs_btree_node *node;\n\tstruct inode *dat;\n\t__u64 tmpptr;\n\tint ncblk;\n\n\t \n\tif (btree->b_ops->bop_clear != NULL)\n\t\tbtree->b_ops->bop_clear(btree);\n\n\t \n\tset_buffer_nilfs_volatile((struct buffer_head *)((unsigned long)ptr));\n\n\t \n\tdat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;\n\t__nilfs_btree_init(btree);\n\tif (nreq != NULL) {\n\t\tnilfs_bmap_commit_alloc_ptr(btree, dreq, dat);\n\t\tnilfs_bmap_commit_alloc_ptr(btree, nreq, dat);\n\n\t\t \n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tncblk = nilfs_btree_nchildren_per_block(btree);\n\t\tnilfs_btree_node_init(node, 0, 1, n, ncblk, keys, ptrs);\n\t\tnilfs_btree_node_insert(node, n, key, dreq->bpr_ptr, ncblk);\n\t\tif (!buffer_dirty(bh))\n\t\t\tmark_buffer_dirty(bh);\n\t\tif (!nilfs_bmap_dirty(btree))\n\t\t\tnilfs_bmap_set_dirty(btree);\n\n\t\tbrelse(bh);\n\n\t\t \n\t\tnode = nilfs_btree_get_root(btree);\n\t\ttmpptr = nreq->bpr_ptr;\n\t\tnilfs_btree_node_init(node, NILFS_BTREE_NODE_ROOT, 2, 1,\n\t\t\t\t      NILFS_BTREE_ROOT_NCHILDREN_MAX,\n\t\t\t\t      &keys[0], &tmpptr);\n\t} else {\n\t\tnilfs_bmap_commit_alloc_ptr(btree, dreq, dat);\n\n\t\t \n\t\tnode = nilfs_btree_get_root(btree);\n\t\tnilfs_btree_node_init(node, NILFS_BTREE_NODE_ROOT, 1, n,\n\t\t\t\t      NILFS_BTREE_ROOT_NCHILDREN_MAX,\n\t\t\t\t      keys, ptrs);\n\t\tnilfs_btree_node_insert(node, n, key, dreq->bpr_ptr,\n\t\t\t\t\tNILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t\tif (!nilfs_bmap_dirty(btree))\n\t\t\tnilfs_bmap_set_dirty(btree);\n\t}\n\n\tif (NILFS_BMAP_USE_VBN(btree))\n\t\tnilfs_bmap_set_target_v(btree, key, dreq->bpr_ptr);\n}\n\n \nint nilfs_btree_convert_and_insert(struct nilfs_bmap *btree,\n\t\t\t\t   __u64 key, __u64 ptr,\n\t\t\t\t   const __u64 *keys, const __u64 *ptrs, int n)\n{\n\tstruct buffer_head *bh = NULL;\n\tunion nilfs_bmap_ptr_req dreq, nreq, *di, *ni;\n\tstruct nilfs_bmap_stats stats;\n\tint ret;\n\n\tif (n + 1 <= NILFS_BTREE_ROOT_NCHILDREN_MAX) {\n\t\tdi = &dreq;\n\t\tni = NULL;\n\t} else if ((n + 1) <= NILFS_BTREE_NODE_NCHILDREN_MAX(\n\t\t\t   nilfs_btree_node_size(btree))) {\n\t\tdi = &dreq;\n\t\tni = &nreq;\n\t} else {\n\t\tdi = NULL;\n\t\tni = NULL;\n\t\tBUG();\n\t}\n\n\tret = nilfs_btree_prepare_convert_and_insert(btree, key, di, ni, &bh,\n\t\t\t\t\t\t     &stats);\n\tif (ret < 0)\n\t\treturn ret;\n\tnilfs_btree_commit_convert_and_insert(btree, key, ptr, keys, ptrs, n,\n\t\t\t\t\t      di, ni, bh);\n\tnilfs_inode_add_blocks(btree->b_inode, stats.bs_nblocks);\n\treturn 0;\n}\n\nstatic int nilfs_btree_propagate_p(struct nilfs_bmap *btree,\n\t\t\t\t   struct nilfs_btree_path *path,\n\t\t\t\t   int level,\n\t\t\t\t   struct buffer_head *bh)\n{\n\twhile ((++level < nilfs_btree_height(btree) - 1) &&\n\t       !buffer_dirty(path[level].bp_bh))\n\t\tmark_buffer_dirty(path[level].bp_bh);\n\n\treturn 0;\n}\n\nstatic int nilfs_btree_prepare_update_v(struct nilfs_bmap *btree,\n\t\t\t\t\tstruct nilfs_btree_path *path,\n\t\t\t\t\tint level, struct inode *dat)\n{\n\tstruct nilfs_btree_node *parent;\n\tint ncmax, ret;\n\n\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\tpath[level].bp_oldreq.bpr_ptr =\n\t\tnilfs_btree_node_get_ptr(parent, path[level + 1].bp_index,\n\t\t\t\t\t ncmax);\n\tpath[level].bp_newreq.bpr_ptr = path[level].bp_oldreq.bpr_ptr + 1;\n\tret = nilfs_dat_prepare_update(dat, &path[level].bp_oldreq.bpr_req,\n\t\t\t\t       &path[level].bp_newreq.bpr_req);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buffer_nilfs_node(path[level].bp_bh)) {\n\t\tpath[level].bp_ctxt.oldkey = path[level].bp_oldreq.bpr_ptr;\n\t\tpath[level].bp_ctxt.newkey = path[level].bp_newreq.bpr_ptr;\n\t\tpath[level].bp_ctxt.bh = path[level].bp_bh;\n\t\tret = nilfs_btnode_prepare_change_key(\n\t\t\tNILFS_BMAP_I(btree)->i_assoc_inode->i_mapping,\n\t\t\t&path[level].bp_ctxt);\n\t\tif (ret < 0) {\n\t\t\tnilfs_dat_abort_update(dat,\n\t\t\t\t\t       &path[level].bp_oldreq.bpr_req,\n\t\t\t\t\t       &path[level].bp_newreq.bpr_req);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void nilfs_btree_commit_update_v(struct nilfs_bmap *btree,\n\t\t\t\t\tstruct nilfs_btree_path *path,\n\t\t\t\t\tint level, struct inode *dat)\n{\n\tstruct nilfs_btree_node *parent;\n\tint ncmax;\n\n\tnilfs_dat_commit_update(dat, &path[level].bp_oldreq.bpr_req,\n\t\t\t\t&path[level].bp_newreq.bpr_req,\n\t\t\t\tbtree->b_ptr_type == NILFS_BMAP_PTR_VS);\n\n\tif (buffer_nilfs_node(path[level].bp_bh)) {\n\t\tnilfs_btnode_commit_change_key(\n\t\t\tNILFS_BMAP_I(btree)->i_assoc_inode->i_mapping,\n\t\t\t&path[level].bp_ctxt);\n\t\tpath[level].bp_bh = path[level].bp_ctxt.bh;\n\t}\n\tset_buffer_nilfs_volatile(path[level].bp_bh);\n\n\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\tnilfs_btree_node_set_ptr(parent, path[level + 1].bp_index,\n\t\t\t\t path[level].bp_newreq.bpr_ptr, ncmax);\n}\n\nstatic void nilfs_btree_abort_update_v(struct nilfs_bmap *btree,\n\t\t\t\t       struct nilfs_btree_path *path,\n\t\t\t\t       int level, struct inode *dat)\n{\n\tnilfs_dat_abort_update(dat, &path[level].bp_oldreq.bpr_req,\n\t\t\t       &path[level].bp_newreq.bpr_req);\n\tif (buffer_nilfs_node(path[level].bp_bh))\n\t\tnilfs_btnode_abort_change_key(\n\t\t\tNILFS_BMAP_I(btree)->i_assoc_inode->i_mapping,\n\t\t\t&path[level].bp_ctxt);\n}\n\nstatic int nilfs_btree_prepare_propagate_v(struct nilfs_bmap *btree,\n\t\t\t\t\t   struct nilfs_btree_path *path,\n\t\t\t\t\t   int minlevel, int *maxlevelp,\n\t\t\t\t\t   struct inode *dat)\n{\n\tint level, ret;\n\n\tlevel = minlevel;\n\tif (!buffer_nilfs_volatile(path[level].bp_bh)) {\n\t\tret = nilfs_btree_prepare_update_v(btree, path, level, dat);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\twhile ((++level < nilfs_btree_height(btree) - 1) &&\n\t       !buffer_dirty(path[level].bp_bh)) {\n\n\t\tWARN_ON(buffer_nilfs_volatile(path[level].bp_bh));\n\t\tret = nilfs_btree_prepare_update_v(btree, path, level, dat);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\t*maxlevelp = level - 1;\n\treturn 0;\n\n\t \n out:\n\twhile (--level > minlevel)\n\t\tnilfs_btree_abort_update_v(btree, path, level, dat);\n\tif (!buffer_nilfs_volatile(path[level].bp_bh))\n\t\tnilfs_btree_abort_update_v(btree, path, level, dat);\n\treturn ret;\n}\n\nstatic void nilfs_btree_commit_propagate_v(struct nilfs_bmap *btree,\n\t\t\t\t\t   struct nilfs_btree_path *path,\n\t\t\t\t\t   int minlevel, int maxlevel,\n\t\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t\t   struct inode *dat)\n{\n\tint level;\n\n\tif (!buffer_nilfs_volatile(path[minlevel].bp_bh))\n\t\tnilfs_btree_commit_update_v(btree, path, minlevel, dat);\n\n\tfor (level = minlevel + 1; level <= maxlevel; level++)\n\t\tnilfs_btree_commit_update_v(btree, path, level, dat);\n}\n\nstatic int nilfs_btree_propagate_v(struct nilfs_bmap *btree,\n\t\t\t\t   struct nilfs_btree_path *path,\n\t\t\t\t   int level, struct buffer_head *bh)\n{\n\tint maxlevel = 0, ret;\n\tstruct nilfs_btree_node *parent;\n\tstruct inode *dat = nilfs_bmap_get_dat(btree);\n\t__u64 ptr;\n\tint ncmax;\n\n\tget_bh(bh);\n\tpath[level].bp_bh = bh;\n\tret = nilfs_btree_prepare_propagate_v(btree, path, level, &maxlevel,\n\t\t\t\t\t      dat);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (buffer_nilfs_volatile(path[level].bp_bh)) {\n\t\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\t\tptr = nilfs_btree_node_get_ptr(parent,\n\t\t\t\t\t       path[level + 1].bp_index,\n\t\t\t\t\t       ncmax);\n\t\tret = nilfs_dat_mark_dirty(dat, ptr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tnilfs_btree_commit_propagate_v(btree, path, level, maxlevel, bh, dat);\n\n out:\n\tbrelse(path[level].bp_bh);\n\tpath[level].bp_bh = NULL;\n\treturn ret;\n}\n\nstatic int nilfs_btree_propagate(struct nilfs_bmap *btree,\n\t\t\t\t struct buffer_head *bh)\n{\n\tstruct nilfs_btree_path *path;\n\tstruct nilfs_btree_node *node;\n\t__u64 key;\n\tint level, ret;\n\n\tWARN_ON(!buffer_dirty(bh));\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tif (buffer_nilfs_node(bh)) {\n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tkey = nilfs_btree_node_get_key(node, 0);\n\t\tlevel = nilfs_btree_node_get_level(node);\n\t} else {\n\t\tkey = nilfs_bmap_data_get_key(btree, bh);\n\t\tlevel = NILFS_BTREE_LEVEL_DATA;\n\t}\n\n\tret = nilfs_btree_do_lookup(btree, path, key, NULL, level + 1, 0);\n\tif (ret < 0) {\n\t\tif (unlikely(ret == -ENOENT))\n\t\t\tnilfs_crit(btree->b_inode->i_sb,\n\t\t\t\t   \"writing node/leaf block does not appear in b-tree (ino=%lu) at key=%llu, level=%d\",\n\t\t\t\t   btree->b_inode->i_ino,\n\t\t\t\t   (unsigned long long)key, level);\n\t\tgoto out;\n\t}\n\n\tret = NILFS_BMAP_USE_VBN(btree) ?\n\t\tnilfs_btree_propagate_v(btree, path, level, bh) :\n\t\tnilfs_btree_propagate_p(btree, path, level, bh);\n\n out:\n\tnilfs_btree_free_path(path);\n\n\treturn ret;\n}\n\nstatic int nilfs_btree_propagate_gc(struct nilfs_bmap *btree,\n\t\t\t\t    struct buffer_head *bh)\n{\n\treturn nilfs_dat_mark_dirty(nilfs_bmap_get_dat(btree), bh->b_blocknr);\n}\n\nstatic void nilfs_btree_add_dirty_buffer(struct nilfs_bmap *btree,\n\t\t\t\t\t struct list_head *lists,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tstruct list_head *head;\n\tstruct buffer_head *cbh;\n\tstruct nilfs_btree_node *node, *cnode;\n\t__u64 key, ckey;\n\tint level;\n\n\tget_bh(bh);\n\tnode = (struct nilfs_btree_node *)bh->b_data;\n\tkey = nilfs_btree_node_get_key(node, 0);\n\tlevel = nilfs_btree_node_get_level(node);\n\tif (level < NILFS_BTREE_LEVEL_NODE_MIN ||\n\t    level >= NILFS_BTREE_LEVEL_MAX) {\n\t\tdump_stack();\n\t\tnilfs_warn(btree->b_inode->i_sb,\n\t\t\t   \"invalid btree level: %d (key=%llu, ino=%lu, blocknr=%llu)\",\n\t\t\t   level, (unsigned long long)key,\n\t\t\t   btree->b_inode->i_ino,\n\t\t\t   (unsigned long long)bh->b_blocknr);\n\t\treturn;\n\t}\n\n\tlist_for_each(head, &lists[level]) {\n\t\tcbh = list_entry(head, struct buffer_head, b_assoc_buffers);\n\t\tcnode = (struct nilfs_btree_node *)cbh->b_data;\n\t\tckey = nilfs_btree_node_get_key(cnode, 0);\n\t\tif (key < ckey)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(&bh->b_assoc_buffers, head);\n}\n\nstatic void nilfs_btree_lookup_dirty_buffers(struct nilfs_bmap *btree,\n\t\t\t\t\t     struct list_head *listp)\n{\n\tstruct inode *btnc_inode = NILFS_BMAP_I(btree)->i_assoc_inode;\n\tstruct address_space *btcache = btnc_inode->i_mapping;\n\tstruct list_head lists[NILFS_BTREE_LEVEL_MAX];\n\tstruct folio_batch fbatch;\n\tstruct buffer_head *bh, *head;\n\tpgoff_t index = 0;\n\tint level, i;\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN;\n\t     level < NILFS_BTREE_LEVEL_MAX;\n\t     level++)\n\t\tINIT_LIST_HEAD(&lists[level]);\n\n\tfolio_batch_init(&fbatch);\n\n\twhile (filemap_get_folios_tag(btcache, &index, (pgoff_t)-1,\n\t\t\t\tPAGECACHE_TAG_DIRTY, &fbatch)) {\n\t\tfor (i = 0; i < folio_batch_count(&fbatch); i++) {\n\t\t\tbh = head = folio_buffers(fbatch.folios[i]);\n\t\t\tdo {\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tnilfs_btree_add_dirty_buffer(btree,\n\t\t\t\t\t\t\t\t     lists, bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\t}\n\n\tfor (level = NILFS_BTREE_LEVEL_NODE_MIN;\n\t     level < NILFS_BTREE_LEVEL_MAX;\n\t     level++)\n\t\tlist_splice_tail(&lists[level], listp);\n}\n\nstatic int nilfs_btree_assign_p(struct nilfs_bmap *btree,\n\t\t\t\tstruct nilfs_btree_path *path,\n\t\t\t\tint level,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tsector_t blocknr,\n\t\t\t\tunion nilfs_binfo *binfo)\n{\n\tstruct nilfs_btree_node *parent;\n\t__u64 key;\n\t__u64 ptr;\n\tint ncmax, ret;\n\n\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\tptr = nilfs_btree_node_get_ptr(parent, path[level + 1].bp_index,\n\t\t\t\t       ncmax);\n\tif (buffer_nilfs_node(*bh)) {\n\t\tpath[level].bp_ctxt.oldkey = ptr;\n\t\tpath[level].bp_ctxt.newkey = blocknr;\n\t\tpath[level].bp_ctxt.bh = *bh;\n\t\tret = nilfs_btnode_prepare_change_key(\n\t\t\tNILFS_BMAP_I(btree)->i_assoc_inode->i_mapping,\n\t\t\t&path[level].bp_ctxt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnilfs_btnode_commit_change_key(\n\t\t\tNILFS_BMAP_I(btree)->i_assoc_inode->i_mapping,\n\t\t\t&path[level].bp_ctxt);\n\t\t*bh = path[level].bp_ctxt.bh;\n\t}\n\n\tnilfs_btree_node_set_ptr(parent, path[level + 1].bp_index, blocknr,\n\t\t\t\t ncmax);\n\n\tkey = nilfs_btree_node_get_key(parent, path[level + 1].bp_index);\n\t \n\tbinfo->bi_dat.bi_blkoff = cpu_to_le64(key);\n\tbinfo->bi_dat.bi_level = level;\n\tmemset(binfo->bi_dat.bi_pad, 0, sizeof(binfo->bi_dat.bi_pad));\n\n\treturn 0;\n}\n\nstatic int nilfs_btree_assign_v(struct nilfs_bmap *btree,\n\t\t\t\tstruct nilfs_btree_path *path,\n\t\t\t\tint level,\n\t\t\t\tstruct buffer_head **bh,\n\t\t\t\tsector_t blocknr,\n\t\t\t\tunion nilfs_binfo *binfo)\n{\n\tstruct nilfs_btree_node *parent;\n\tstruct inode *dat = nilfs_bmap_get_dat(btree);\n\t__u64 key;\n\t__u64 ptr;\n\tunion nilfs_bmap_ptr_req req;\n\tint ncmax, ret;\n\n\tparent = nilfs_btree_get_node(btree, path, level + 1, &ncmax);\n\tptr = nilfs_btree_node_get_ptr(parent, path[level + 1].bp_index,\n\t\t\t\t       ncmax);\n\treq.bpr_ptr = ptr;\n\tret = nilfs_dat_prepare_start(dat, &req.bpr_req);\n\tif (ret < 0)\n\t\treturn ret;\n\tnilfs_dat_commit_start(dat, &req.bpr_req, blocknr);\n\n\tkey = nilfs_btree_node_get_key(parent, path[level + 1].bp_index);\n\t \n\tbinfo->bi_v.bi_vblocknr = cpu_to_le64(ptr);\n\tbinfo->bi_v.bi_blkoff = cpu_to_le64(key);\n\n\treturn 0;\n}\n\nstatic int nilfs_btree_assign(struct nilfs_bmap *btree,\n\t\t\t      struct buffer_head **bh,\n\t\t\t      sector_t blocknr,\n\t\t\t      union nilfs_binfo *binfo)\n{\n\tstruct nilfs_btree_path *path;\n\tstruct nilfs_btree_node *node;\n\t__u64 key;\n\tint level, ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tif (buffer_nilfs_node(*bh)) {\n\t\tnode = (struct nilfs_btree_node *)(*bh)->b_data;\n\t\tkey = nilfs_btree_node_get_key(node, 0);\n\t\tlevel = nilfs_btree_node_get_level(node);\n\t} else {\n\t\tkey = nilfs_bmap_data_get_key(btree, *bh);\n\t\tlevel = NILFS_BTREE_LEVEL_DATA;\n\t}\n\n\tret = nilfs_btree_do_lookup(btree, path, key, NULL, level + 1, 0);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOENT);\n\t\tgoto out;\n\t}\n\n\tret = NILFS_BMAP_USE_VBN(btree) ?\n\t\tnilfs_btree_assign_v(btree, path, level, bh, blocknr, binfo) :\n\t\tnilfs_btree_assign_p(btree, path, level, bh, blocknr, binfo);\n\n out:\n\tnilfs_btree_free_path(path);\n\n\treturn ret;\n}\n\nstatic int nilfs_btree_assign_gc(struct nilfs_bmap *btree,\n\t\t\t\t struct buffer_head **bh,\n\t\t\t\t sector_t blocknr,\n\t\t\t\t union nilfs_binfo *binfo)\n{\n\tstruct nilfs_btree_node *node;\n\t__u64 key;\n\tint ret;\n\n\tret = nilfs_dat_move(nilfs_bmap_get_dat(btree), (*bh)->b_blocknr,\n\t\t\t     blocknr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (buffer_nilfs_node(*bh)) {\n\t\tnode = (struct nilfs_btree_node *)(*bh)->b_data;\n\t\tkey = nilfs_btree_node_get_key(node, 0);\n\t} else\n\t\tkey = nilfs_bmap_data_get_key(btree, *bh);\n\n\t \n\tbinfo->bi_v.bi_vblocknr = cpu_to_le64((*bh)->b_blocknr);\n\tbinfo->bi_v.bi_blkoff = cpu_to_le64(key);\n\n\treturn 0;\n}\n\nstatic int nilfs_btree_mark(struct nilfs_bmap *btree, __u64 key, int level)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_path *path;\n\t__u64 ptr;\n\tint ret;\n\n\tpath = nilfs_btree_alloc_path();\n\tif (path == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nilfs_btree_do_lookup(btree, path, key, &ptr, level + 1, 0);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOENT);\n\t\tgoto out;\n\t}\n\tret = nilfs_btree_get_block(btree, ptr, &bh);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOENT);\n\t\tgoto out;\n\t}\n\n\tif (!buffer_dirty(bh))\n\t\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif (!nilfs_bmap_dirty(btree))\n\t\tnilfs_bmap_set_dirty(btree);\n\n out:\n\tnilfs_btree_free_path(path);\n\treturn ret;\n}\n\nstatic const struct nilfs_bmap_operations nilfs_btree_ops = {\n\t.bop_lookup\t\t=\tnilfs_btree_lookup,\n\t.bop_lookup_contig\t=\tnilfs_btree_lookup_contig,\n\t.bop_insert\t\t=\tnilfs_btree_insert,\n\t.bop_delete\t\t=\tnilfs_btree_delete,\n\t.bop_clear\t\t=\tNULL,\n\n\t.bop_propagate\t\t=\tnilfs_btree_propagate,\n\n\t.bop_lookup_dirty_buffers =\tnilfs_btree_lookup_dirty_buffers,\n\n\t.bop_assign\t\t=\tnilfs_btree_assign,\n\t.bop_mark\t\t=\tnilfs_btree_mark,\n\n\t.bop_seek_key\t\t=\tnilfs_btree_seek_key,\n\t.bop_last_key\t\t=\tnilfs_btree_last_key,\n\n\t.bop_check_insert\t=\tNULL,\n\t.bop_check_delete\t=\tnilfs_btree_check_delete,\n\t.bop_gather_data\t=\tnilfs_btree_gather_data,\n};\n\nstatic const struct nilfs_bmap_operations nilfs_btree_ops_gc = {\n\t.bop_lookup\t\t=\tNULL,\n\t.bop_lookup_contig\t=\tNULL,\n\t.bop_insert\t\t=\tNULL,\n\t.bop_delete\t\t=\tNULL,\n\t.bop_clear\t\t=\tNULL,\n\n\t.bop_propagate\t\t=\tnilfs_btree_propagate_gc,\n\n\t.bop_lookup_dirty_buffers =\tnilfs_btree_lookup_dirty_buffers,\n\n\t.bop_assign\t\t=\tnilfs_btree_assign_gc,\n\t.bop_mark\t\t=\tNULL,\n\n\t.bop_seek_key\t\t=\tNULL,\n\t.bop_last_key\t\t=\tNULL,\n\n\t.bop_check_insert\t=\tNULL,\n\t.bop_check_delete\t=\tNULL,\n\t.bop_gather_data\t=\tNULL,\n};\n\nstatic void __nilfs_btree_init(struct nilfs_bmap *bmap)\n{\n\tbmap->b_ops = &nilfs_btree_ops;\n\tbmap->b_nchildren_per_block =\n\t\tNILFS_BTREE_NODE_NCHILDREN_MAX(nilfs_btree_node_size(bmap));\n}\n\nint nilfs_btree_init(struct nilfs_bmap *bmap)\n{\n\tint ret = 0;\n\n\t__nilfs_btree_init(bmap);\n\n\tif (nilfs_btree_root_broken(nilfs_btree_get_root(bmap), bmap->b_inode))\n\t\tret = -EIO;\n\telse\n\t\tret = nilfs_attach_btree_node_cache(\n\t\t\t&NILFS_BMAP_I(bmap)->vfs_inode);\n\n\treturn ret;\n}\n\nvoid nilfs_btree_init_gc(struct nilfs_bmap *bmap)\n{\n\tbmap->b_ops = &nilfs_btree_ops_gc;\n\tbmap->b_nchildren_per_block =\n\t\tNILFS_BTREE_NODE_NCHILDREN_MAX(nilfs_btree_node_size(bmap));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}