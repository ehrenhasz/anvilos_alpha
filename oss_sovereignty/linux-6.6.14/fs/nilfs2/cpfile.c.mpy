{
  "module_name": "cpfile.c",
  "hash_id": "b122c591b500520952bc3afd756479fcc6252b3762290d50095b6604e0487e11",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/cpfile.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"mdt.h\"\n#include \"cpfile.h\"\n\n\nstatic inline unsigned long\nnilfs_cpfile_checkpoints_per_block(const struct inode *cpfile)\n{\n\treturn NILFS_MDT(cpfile)->mi_entries_per_block;\n}\n\n \nstatic unsigned long\nnilfs_cpfile_get_blkoff(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\n\tdo_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n\treturn (unsigned long)tcno;\n}\n\n \nstatic unsigned long\nnilfs_cpfile_get_offset(const struct inode *cpfile, __u64 cno)\n{\n\t__u64 tcno = cno + NILFS_MDT(cpfile)->mi_first_entry_offset - 1;\n\n\treturn do_div(tcno, nilfs_cpfile_checkpoints_per_block(cpfile));\n}\n\nstatic __u64 nilfs_cpfile_first_checkpoint_in_block(const struct inode *cpfile,\n\t\t\t\t\t\t    unsigned long blkoff)\n{\n\treturn (__u64)nilfs_cpfile_checkpoints_per_block(cpfile) * blkoff\n\t\t+ 1 - NILFS_MDT(cpfile)->mi_first_entry_offset;\n}\n\nstatic unsigned long\nnilfs_cpfile_checkpoints_in_block(const struct inode *cpfile,\n\t\t\t\t  __u64 curr,\n\t\t\t\t  __u64 max)\n{\n\treturn min_t(__u64,\n\t\t     nilfs_cpfile_checkpoints_per_block(cpfile) -\n\t\t     nilfs_cpfile_get_offset(cpfile, curr),\n\t\t     max - curr);\n}\n\nstatic inline int nilfs_cpfile_is_in_first(const struct inode *cpfile,\n\t\t\t\t\t   __u64 cno)\n{\n\treturn nilfs_cpfile_get_blkoff(cpfile, cno) == 0;\n}\n\nstatic unsigned int\nnilfs_cpfile_block_add_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) + n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}\n\nstatic unsigned int\nnilfs_cpfile_block_sub_valid_checkpoints(const struct inode *cpfile,\n\t\t\t\t\t struct buffer_head *bh,\n\t\t\t\t\t void *kaddr,\n\t\t\t\t\t unsigned int n)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tunsigned int count;\n\n\tWARN_ON(le32_to_cpu(cp->cp_checkpoints_count) < n);\n\tcount = le32_to_cpu(cp->cp_checkpoints_count) - n;\n\tcp->cp_checkpoints_count = cpu_to_le32(count);\n\treturn count;\n}\n\nstatic inline struct nilfs_cpfile_header *\nnilfs_cpfile_block_get_header(const struct inode *cpfile,\n\t\t\t      struct buffer_head *bh,\n\t\t\t      void *kaddr)\n{\n\treturn kaddr + bh_offset(bh);\n}\n\nstatic struct nilfs_checkpoint *\nnilfs_cpfile_block_get_checkpoint(const struct inode *cpfile, __u64 cno,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  void *kaddr)\n{\n\treturn kaddr + bh_offset(bh) + nilfs_cpfile_get_offset(cpfile, cno) *\n\t\tNILFS_MDT(cpfile)->mi_entry_size;\n}\n\nstatic void nilfs_cpfile_block_init(struct inode *cpfile,\n\t\t\t\t    struct buffer_head *bh,\n\t\t\t\t    void *kaddr)\n{\n\tstruct nilfs_checkpoint *cp = kaddr + bh_offset(bh);\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\tint n = nilfs_cpfile_checkpoints_per_block(cpfile);\n\n\twhile (n-- > 0) {\n\t\tnilfs_checkpoint_set_invalid(cp);\n\t\tcp = (void *)cp + cpsz;\n\t}\n}\n\nstatic inline int nilfs_cpfile_get_header_block(struct inode *cpfile,\n\t\t\t\t\t\tstruct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile, 0, 0, NULL, bhp);\n}\n\nstatic inline int nilfs_cpfile_get_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t    __u64 cno,\n\t\t\t\t\t\t    int create,\n\t\t\t\t\t\t    struct buffer_head **bhp)\n{\n\treturn nilfs_mdt_get_block(cpfile,\n\t\t\t\t   nilfs_cpfile_get_blkoff(cpfile, cno),\n\t\t\t\t   create, nilfs_cpfile_block_init, bhp);\n}\n\n \nstatic int nilfs_cpfile_find_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t      __u64 start_cno, __u64 end_cno,\n\t\t\t\t\t      __u64 *cnop,\n\t\t\t\t\t      struct buffer_head **bhp)\n{\n\tunsigned long start, end, blkoff;\n\tint ret;\n\n\tif (unlikely(start_cno > end_cno))\n\t\treturn -ENOENT;\n\n\tstart = nilfs_cpfile_get_blkoff(cpfile, start_cno);\n\tend = nilfs_cpfile_get_blkoff(cpfile, end_cno);\n\n\tret = nilfs_mdt_find_block(cpfile, start, end, &blkoff, bhp);\n\tif (!ret)\n\t\t*cnop = (blkoff == start) ? start_cno :\n\t\t\tnilfs_cpfile_first_checkpoint_in_block(cpfile, blkoff);\n\treturn ret;\n}\n\nstatic inline int nilfs_cpfile_delete_checkpoint_block(struct inode *cpfile,\n\t\t\t\t\t\t       __u64 cno)\n{\n\treturn nilfs_mdt_delete_block(cpfile,\n\t\t\t\t      nilfs_cpfile_get_blkoff(cpfile, cno));\n}\n\n \nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t \n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\n \nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}\n\n \nint nilfs_cpfile_delete_checkpoints(struct inode *cpfile,\n\t\t\t\t    __u64 start,\n\t\t\t\t    __u64 end)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cno;\n\tvoid *kaddr;\n\tunsigned long tnicps;\n\tint ret, ncps, nicps, nss, count, i;\n\n\tif (unlikely(start == 0 || start > end)) {\n\t\tnilfs_err(cpfile->i_sb,\n\t\t\t  \"cannot delete checkpoints: invalid range [%llu, %llu)\",\n\t\t\t  (unsigned long long)start, (unsigned long long)end);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\ttnicps = 0;\n\tnss = 0;\n\n\tfor (cno = start; cno < end; cno += ncps) {\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, end);\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = kmap_atomic(cp_bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, cno, cp_bh, kaddr);\n\t\tnicps = 0;\n\t\tfor (i = 0; i < ncps; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\t\t\tnss++;\n\t\t\t} else if (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_checkpoint_set_invalid(cp);\n\t\t\t\tnicps++;\n\t\t\t}\n\t\t}\n\t\tif (nicps > 0) {\n\t\t\ttnicps += nicps;\n\t\t\tmark_buffer_dirty(cp_bh);\n\t\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno)) {\n\t\t\t\tcount =\n\t\t\t\t  nilfs_cpfile_block_sub_valid_checkpoints(\n\t\t\t\t\t\tcpfile, cp_bh, kaddr, nicps);\n\t\t\t\tif (count == 0) {\n\t\t\t\t\t \n\t\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\t\tbrelse(cp_bh);\n\t\t\t\t\tret =\n\t\t\t\t\t  nilfs_cpfile_delete_checkpoint_block(\n\t\t\t\t\t\t\t\t   cpfile, cno);\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnilfs_err(cpfile->i_sb,\n\t\t\t\t\t\t  \"error %d deleting checkpoint block\",\n\t\t\t\t\t\t  ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(cp_bh);\n\t}\n\n\tif (tnicps > 0) {\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, -(u64)tnicps);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tbrelse(header_bh);\n\tif (nss > 0)\n\t\tret = -EBUSY;\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\nstatic void nilfs_cpfile_checkpoint_to_cpinfo(struct inode *cpfile,\n\t\t\t\t\t      struct nilfs_checkpoint *cp,\n\t\t\t\t\t      struct nilfs_cpinfo *ci)\n{\n\tci->ci_flags = le32_to_cpu(cp->cp_flags);\n\tci->ci_cno = le64_to_cpu(cp->cp_cno);\n\tci->ci_create = le64_to_cpu(cp->cp_create);\n\tci->ci_nblk_inc = le64_to_cpu(cp->cp_nblk_inc);\n\tci->ci_inodes_count = le64_to_cpu(cp->cp_inodes_count);\n\tci->ci_blocks_count = le64_to_cpu(cp->cp_blocks_count);\n\tci->ci_next = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n}\n\nstatic ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned int cisz,\n\t\t\t\t\t  size_t nci)\n{\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\tstruct buffer_head *bh;\n\tsize_t cpsz = NILFS_MDT(cpfile)->mi_entry_size;\n\t__u64 cur_cno = nilfs_mdt_cno(cpfile), cno = *cnop;\n\tvoid *kaddr;\n\tint n, ret;\n\tint ncps, i;\n\n\tif (cno == 0)\n\t\treturn -ENOENT;  \n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tfor (n = 0; n < nci; cno += ncps) {\n\t\tret = nilfs_cpfile_find_checkpoint_block(\n\t\t\tcpfile, cno, cur_cno - 1, &cno, &bh);\n\t\tif (ret < 0) {\n\t\t\tif (likely(ret == -ENOENT))\n\t\t\t\tbreak;\n\t\t\tgoto out;\n\t\t}\n\t\tncps = nilfs_cpfile_checkpoints_in_block(cpfile, cno, cur_cno);\n\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tfor (i = 0; i < ncps && n < nci; i++, cp = (void *)cp + cpsz) {\n\t\t\tif (!nilfs_checkpoint_invalid(cp)) {\n\t\t\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp,\n\t\t\t\t\t\t\t\t  ci);\n\t\t\t\tci = (void *)ci + cisz;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t}\n\n\tret = n;\n\tif (n > 0) {\n\t\tci = (void *)ci - cisz;\n\t\t*cnop = ci->ci_cno + 1;\n\t}\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\nstatic ssize_t nilfs_cpfile_do_get_ssinfo(struct inode *cpfile, __u64 *cnop,\n\t\t\t\t\t  void *buf, unsigned int cisz,\n\t\t\t\t\t  size_t nci)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_cpinfo *ci = buf;\n\t__u64 curr = *cnop, next;\n\tunsigned long curr_blkoff, next_blkoff;\n\tvoid *kaddr;\n\tint n = 0, ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tif (curr == 0) {\n\t\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkaddr = kmap_atomic(bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tcurr = le64_to_cpu(header->ch_snapshot_list.ssl_next);\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(bh);\n\t\tif (curr == 0) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (unlikely(curr == ~(__u64)0)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcurr_blkoff = nilfs_cpfile_get_blkoff(cpfile, curr);\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr, 0, &bh);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;  \n\t\tgoto out;\n\t}\n\tkaddr = kmap_atomic(bh->b_page);\n\twhile (n < nci) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, curr, bh, kaddr);\n\t\tcurr = ~(__u64)0;  \n\t\tif (unlikely(nilfs_checkpoint_invalid(cp) ||\n\t\t\t     !nilfs_checkpoint_snapshot(cp)))\n\t\t\tbreak;\n\t\tnilfs_cpfile_checkpoint_to_cpinfo(cpfile, cp, ci);\n\t\tci = (void *)ci + cisz;\n\t\tn++;\n\t\tnext = le64_to_cpu(cp->cp_snapshot_list.ssl_next);\n\t\tif (next == 0)\n\t\t\tbreak;  \n\n\t\tnext_blkoff = nilfs_cpfile_get_blkoff(cpfile, next);\n\t\tif (curr_blkoff != next_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next,\n\t\t\t\t\t\t\t\t0, &bh);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tWARN_ON(ret == -ENOENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkaddr = kmap_atomic(bh->b_page);\n\t\t}\n\t\tcurr = next;\n\t\tcurr_blkoff = next_blkoff;\n\t}\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\t*cnop = curr;\n\tret = n;\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\n \n\nssize_t nilfs_cpfile_get_cpinfo(struct inode *cpfile, __u64 *cnop, int mode,\n\t\t\t\tvoid *buf, unsigned int cisz, size_t nci)\n{\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\treturn nilfs_cpfile_do_get_cpinfo(cpfile, cnop, buf, cisz, nci);\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_do_get_ssinfo(cpfile, cnop, buf, cisz, nci);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)\n{\n\tstruct nilfs_cpinfo ci;\n\t__u64 tcno = cno;\n\tssize_t nci;\n\n\tnci = nilfs_cpfile_do_get_cpinfo(cpfile, &tcno, &ci, sizeof(ci), 1);\n\tif (nci < 0)\n\t\treturn nci;\n\telse if (nci == 0 || ci.ci_cno != cno)\n\t\treturn -ENOENT;\n\telse if (nilfs_cpinfo_snapshot(&ci))\n\t\treturn -EBUSY;\n\n\treturn nilfs_cpfile_delete_checkpoints(cpfile, cno, cno + 1);\n}\n\nstatic struct nilfs_snapshot_list *\nnilfs_cpfile_block_get_snapshot_list(const struct inode *cpfile,\n\t\t\t\t     __u64 cno,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     void *kaddr)\n{\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\n\tif (cno != 0) {\n\t\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t} else {\n\t\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\t\tlist = &header->ch_snapshot_list;\n\t}\n\treturn list;\n}\n\nstatic int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *curr_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 curr, prev;\n\tunsigned long curr_blkoff, prev_blkoff;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT;  \n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tlist = &header->ch_snapshot_list;\n\tcurr_bh = header_bh;\n\tget_bh(curr_bh);\n\tcurr = 0;\n\tcurr_blkoff = 0;\n\tprev = le64_to_cpu(list->ssl_prev);\n\twhile (prev > cno) {\n\t\tprev_blkoff = nilfs_cpfile_get_blkoff(cpfile, prev);\n\t\tcurr = prev;\n\t\tif (curr_blkoff != prev_blkoff) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tbrelse(curr_bh);\n\t\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, curr,\n\t\t\t\t\t\t\t\t0, &curr_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_header;\n\t\t\tkaddr = kmap_atomic(curr_bh->b_page);\n\t\t}\n\t\tcurr_blkoff = prev_blkoff;\n\t\tcp = nilfs_cpfile_block_get_checkpoint(\n\t\t\tcpfile, curr, curr_bh, kaddr);\n\t\tlist = &cp->cp_snapshot_list;\n\t\tprev = le64_to_cpu(list->ssl_prev);\n\t}\n\tkunmap_atomic(kaddr);\n\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_curr;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(curr_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, curr, curr_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(curr);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(prev);\n\tnilfs_checkpoint_set_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(cno);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, 1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(curr_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_curr:\n\tbrelse(curr_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\nstatic int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *header_bh, *next_bh, *prev_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tstruct nilfs_snapshot_list *list;\n\t__u64 next, prev;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (cno == 0)\n\t\treturn -ENOENT;  \n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tret = -ENOENT;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\tif (!nilfs_checkpoint_snapshot(cp)) {\n\t\tret = 0;\n\t\tkunmap_atomic(kaddr);\n\t\tgoto out_cp;\n\t}\n\n\tlist = &cp->cp_snapshot_list;\n\tnext = le64_to_cpu(list->ssl_next);\n\tprev = le64_to_cpu(list->ssl_prev);\n\tkunmap_atomic(kaddr);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_cp;\n\tif (next != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, next, 0,\n\t\t\t\t\t\t\t&next_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t} else {\n\t\tnext_bh = header_bh;\n\t\tget_bh(next_bh);\n\t}\n\tif (prev != 0) {\n\t\tret = nilfs_cpfile_get_checkpoint_block(cpfile, prev, 0,\n\t\t\t\t\t\t\t&prev_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_next;\n\t} else {\n\t\tprev_bh = header_bh;\n\t\tget_bh(prev_bh);\n\t}\n\n\tkaddr = kmap_atomic(next_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, next, next_bh, kaddr);\n\tlist->ssl_prev = cpu_to_le64(prev);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(prev_bh->b_page);\n\tlist = nilfs_cpfile_block_get_snapshot_list(\n\t\tcpfile, prev, prev_bh, kaddr);\n\tlist->ssl_next = cpu_to_le64(next);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tcp->cp_snapshot_list.ssl_next = cpu_to_le64(0);\n\tcp->cp_snapshot_list.ssl_prev = cpu_to_le64(0);\n\tnilfs_checkpoint_clear_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, header_bh, kaddr);\n\tle64_add_cpu(&header->ch_nsnapshots, -1);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(next_bh);\n\tmark_buffer_dirty(prev_bh);\n\tmark_buffer_dirty(cp_bh);\n\tmark_buffer_dirty(header_bh);\n\tnilfs_mdt_mark_dirty(cpfile);\n\n\tbrelse(prev_bh);\n\n out_next:\n\tbrelse(next_bh);\n\n out_header:\n\tbrelse(header_bh);\n\n out_cp:\n\tbrelse(cp_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\n \nint nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\t \n\tif (cno == 0 || cno >= nilfs_mdt_cno(cpfile))\n\t\treturn -ENOENT;\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out;\n\tkaddr = kmap_atomic(bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp))\n\t\tret = -ENOENT;\n\telse\n\t\tret = nilfs_checkpoint_snapshot(cp);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\n \nint nilfs_cpfile_change_cpmode(struct inode *cpfile, __u64 cno, int mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase NILFS_CHECKPOINT:\n\t\tif (nilfs_checkpoint_is_mounted(cpfile->i_sb, cno))\n\t\t\t \n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tret = nilfs_cpfile_clear_snapshot(cpfile, cno);\n\t\treturn ret;\n\tcase NILFS_SNAPSHOT:\n\t\treturn nilfs_cpfile_set_snapshot(cpfile, cno);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint nilfs_cpfile_get_stat(struct inode *cpfile, struct nilfs_cpstat *cpstat)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_cpfile_header *header;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_read(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(bh->b_page);\n\theader = nilfs_cpfile_block_get_header(cpfile, bh, kaddr);\n\tcpstat->cs_cno = nilfs_mdt_cno(cpfile);\n\tcpstat->cs_ncps = le64_to_cpu(header->ch_ncheckpoints);\n\tcpstat->cs_nsss = le64_to_cpu(header->ch_nsnapshots);\n\tkunmap_atomic(kaddr);\n\tbrelse(bh);\n\n out_sem:\n\tup_read(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}\n\n \nint nilfs_cpfile_read(struct super_block *sb, size_t cpsize,\n\t\t      struct nilfs_inode *raw_inode, struct inode **inodep)\n{\n\tstruct inode *cpfile;\n\tint err;\n\n\tif (cpsize > sb->s_blocksize) {\n\t\tnilfs_err(sb, \"too large checkpoint size: %zu bytes\", cpsize);\n\t\treturn -EINVAL;\n\t} else if (cpsize < NILFS_MIN_CHECKPOINT_SIZE) {\n\t\tnilfs_err(sb, \"too small checkpoint size: %zu bytes\", cpsize);\n\t\treturn -EINVAL;\n\t}\n\n\tcpfile = nilfs_iget_locked(sb, NULL, NILFS_CPFILE_INO);\n\tif (unlikely(!cpfile))\n\t\treturn -ENOMEM;\n\tif (!(cpfile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(cpfile, NILFS_MDT_GFP, 0);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_mdt_set_entry_size(cpfile, cpsize,\n\t\t\t\t sizeof(struct nilfs_cpfile_header));\n\n\terr = nilfs_read_inode_common(cpfile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(cpfile);\n out:\n\t*inodep = cpfile;\n\treturn 0;\n failed:\n\tiget_failed(cpfile);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}