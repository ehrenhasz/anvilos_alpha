{
  "module_name": "ifile.c",
  "hash_id": "c570e0d4d1dc281cef4f542145301ae5d49b9c4c857113742eaf940cd2b587a9",
  "original_prompt": "Ingested from linux-6.6.14/fs/nilfs2/ifile.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/buffer_head.h>\n#include \"nilfs.h\"\n#include \"mdt.h\"\n#include \"alloc.h\"\n#include \"ifile.h\"\n\n \nstruct nilfs_ifile_info {\n\tstruct nilfs_mdt_info mi;\n\tstruct nilfs_palloc_cache palloc_cache;\n};\n\nstatic inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}\n\n \nint nilfs_ifile_create_inode(struct inode *ifile, ino_t *out_ino,\n\t\t\t     struct buffer_head **out_bh)\n{\n\tstruct nilfs_palloc_req req;\n\tint ret;\n\n\treq.pr_entry_nr = 0;   \n\treq.pr_entry_bh = NULL;\n\n\tret = nilfs_palloc_prepare_alloc_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 1,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_alloc_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\tnilfs_palloc_commit_alloc_entry(ifile, &req);\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tnilfs_mdt_mark_dirty(ifile);\n\t*out_ino = (ino_t)req.pr_entry_nr;\n\t*out_bh = req.pr_entry_bh;\n\treturn 0;\n}\n\n \nint nilfs_ifile_delete_inode(struct inode *ifile, ino_t ino)\n{\n\tstruct nilfs_palloc_req req = {\n\t\t.pr_entry_nr = ino, .pr_entry_bh = NULL\n\t};\n\tstruct nilfs_inode *raw_inode;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_prepare_free_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 0,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_free_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req.pr_entry_bh->b_page);\n\traw_inode = nilfs_palloc_block_get_entry(ifile, req.pr_entry_nr,\n\t\t\t\t\t\t req.pr_entry_bh, kaddr);\n\traw_inode->i_flags = 0;\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tbrelse(req.pr_entry_bh);\n\n\tnilfs_palloc_commit_free_entry(ifile, &req);\n\n\treturn 0;\n}\n\nint nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, \"bad inode number: %lu\", (unsigned long)ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warn(sb, \"error %d reading inode: ino=%lu\",\n\t\t\t   err, (unsigned long)ino);\n\treturn err;\n}\n\n \nint nilfs_ifile_count_free_inodes(struct inode *ifile,\n\t\t\t\t    u64 *nmaxinodes, u64 *nfreeinodes)\n{\n\tu64 nused;\n\tint err;\n\n\t*nmaxinodes = 0;\n\t*nfreeinodes = 0;\n\n\tnused = atomic64_read(&NILFS_I(ifile)->i_root->inodes_count);\n\terr = nilfs_palloc_count_max_entries(ifile, nused, nmaxinodes);\n\tif (likely(!err))\n\t\t*nfreeinodes = *nmaxinodes - nused;\n\treturn err;\n}\n\n \nint nilfs_ifile_read(struct super_block *sb, struct nilfs_root *root,\n\t\t     size_t inode_size, struct nilfs_inode *raw_inode,\n\t\t     struct inode **inodep)\n{\n\tstruct inode *ifile;\n\tint err;\n\n\tifile = nilfs_iget_locked(sb, root, NILFS_IFILE_INO);\n\tif (unlikely(!ifile))\n\t\treturn -ENOMEM;\n\tif (!(ifile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(ifile, NILFS_MDT_GFP,\n\t\t\t     sizeof(struct nilfs_ifile_info));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(ifile, inode_size);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_palloc_setup_cache(ifile, &NILFS_IFILE_I(ifile)->palloc_cache);\n\n\terr = nilfs_read_inode_common(ifile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(ifile);\n out:\n\t*inodep = ifile;\n\treturn 0;\n failed:\n\tiget_failed(ifile);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}