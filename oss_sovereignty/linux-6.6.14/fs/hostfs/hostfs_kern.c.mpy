{
  "module_name": "hostfs_kern.c",
  "hash_id": "3174234d5917663d65094c6b9e6b172b0900b54676cfaebd978642c22f5575f0",
  "original_prompt": "Ingested from linux-6.6.14/fs/hostfs/hostfs_kern.c",
  "human_readable_source": " \n\n#include <linux/fs.h>\n#include <linux/magic.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include \"hostfs.h\"\n#include <init.h>\n#include <kern.h>\n\nstruct hostfs_inode_info {\n\tint fd;\n\tfmode_t mode;\n\tstruct inode vfs_inode;\n\tstruct mutex open_mutex;\n\tdev_t dev;\n};\n\nstatic inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hostfs_inode_info, vfs_inode);\n}\n\n#define FILE_HOSTFS_I(file) HOSTFS_I(file_inode(file))\n\nstatic struct kmem_cache *hostfs_inode_cache;\n\n \nstatic char *root_ino = \"\";\nstatic int append = 0;\n\nstatic const struct inode_operations hostfs_iops;\nstatic const struct inode_operations hostfs_dir_iops;\nstatic const struct inode_operations hostfs_link_iops;\n\n#ifndef MODULE\nstatic int __init hostfs_args(char *options, int *add)\n{\n\tchar *ptr;\n\n\tptr = strchr(options, ',');\n\tif (ptr != NULL)\n\t\t*ptr++ = '\\0';\n\tif (*options != '\\0')\n\t\troot_ino = options;\n\n\toptions = ptr;\n\twhile (options) {\n\t\tptr = strchr(options, ',');\n\t\tif (ptr != NULL)\n\t\t\t*ptr++ = '\\0';\n\t\tif (*options != '\\0') {\n\t\t\tif (!strcmp(options, \"append\"))\n\t\t\t\tappend = 1;\n\t\t\telse printf(\"hostfs_args - unsupported option - %s\\n\",\n\t\t\t\t    options);\n\t\t}\n\t\toptions = ptr;\n\t}\n\treturn 0;\n}\n\n__uml_setup(\"hostfs=\", hostfs_args,\n\"hostfs=<root dir>,<flags>,...\\n\"\n\"    This is used to set hostfs parameters.  The root directory argument\\n\"\n\"    is used to confine all hostfs mounts to within the specified directory\\n\"\n\"    tree on the host.  If this isn't specified, then a user inside UML can\\n\"\n\"    mount anything on the host that's accessible to the user that's running\\n\"\n\"    it.\\n\"\n\"    The only flag currently supported is 'append', which specifies that all\\n\"\n\"    files opened by hostfs will be opened in append mode.\\n\\n\"\n);\n#endif\n\nstatic char *__dentry_name(struct dentry *dentry, char *name)\n{\n\tchar *p = dentry_path_raw(dentry, name, PATH_MAX);\n\tchar *root;\n\tsize_t len;\n\n\troot = dentry->d_sb->s_fs_info;\n\tlen = strlen(root);\n\tif (IS_ERR(p)) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\n\t \n\tBUG_ON(p + strlen(p) + 1 != name + PATH_MAX);\n\n\tstrscpy(name, root, PATH_MAX);\n\tif (len > p - name) {\n\t\t__putname(name);\n\t\treturn NULL;\n\t}\n\n\tif (p > name + len)\n\t\tstrcpy(name + len, p);\n\n\treturn name;\n}\n\nstatic char *dentry_name(struct dentry *dentry)\n{\n\tchar *name = __getname();\n\tif (!name)\n\t\treturn NULL;\n\n\treturn __dentry_name(dentry, name);\n}\n\nstatic char *inode_name(struct inode *ino)\n{\n\tstruct dentry *dentry;\n\tchar *name;\n\n\tdentry = d_find_alias(ino);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tname = dentry_name(dentry);\n\n\tdput(dentry);\n\n\treturn name;\n}\n\nstatic char *follow_link(char *link)\n{\n\tchar *name, *resolved, *end;\n\tint n;\n\n\tname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!name) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tn = hostfs_do_readlink(link, name, PATH_MAX);\n\tif (n < 0)\n\t\tgoto out_free;\n\telse if (n == PATH_MAX) {\n\t\tn = -E2BIG;\n\t\tgoto out_free;\n\t}\n\n\tif (*name == '/')\n\t\treturn name;\n\n\tend = strrchr(link, '/');\n\tif (end == NULL)\n\t\treturn name;\n\n\t*(end + 1) = '\\0';\n\n\tresolved = kasprintf(GFP_KERNEL, \"%s%s\", link, name);\n\tif (resolved == NULL) {\n\t\tn = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tkfree(name);\n\treturn resolved;\n\n out_free:\n\tkfree(name);\n\treturn ERR_PTR(n);\n}\n\nstatic int hostfs_statfs(struct dentry *dentry, struct kstatfs *sf)\n{\n\t \n\tint err;\n\tlong long f_blocks;\n\tlong long f_bfree;\n\tlong long f_bavail;\n\tlong long f_files;\n\tlong long f_ffree;\n\n\terr = do_statfs(dentry->d_sb->s_fs_info,\n\t\t\t&sf->f_bsize, &f_blocks, &f_bfree, &f_bavail, &f_files,\n\t\t\t&f_ffree, &sf->f_fsid, sizeof(sf->f_fsid),\n\t\t\t&sf->f_namelen);\n\tif (err)\n\t\treturn err;\n\tsf->f_blocks = f_blocks;\n\tsf->f_bfree = f_bfree;\n\tsf->f_bavail = f_bavail;\n\tsf->f_files = f_files;\n\tsf->f_ffree = f_ffree;\n\tsf->f_type = HOSTFS_SUPER_MAGIC;\n\treturn 0;\n}\n\nstatic struct inode *hostfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hostfs_inode_info *hi;\n\n\thi = alloc_inode_sb(sb, hostfs_inode_cache, GFP_KERNEL_ACCOUNT);\n\tif (hi == NULL)\n\t\treturn NULL;\n\thi->fd = -1;\n\thi->mode = 0;\n\thi->dev = 0;\n\tinode_init_once(&hi->vfs_inode);\n\tmutex_init(&hi->open_mutex);\n\treturn &hi->vfs_inode;\n}\n\nstatic void hostfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HOSTFS_I(inode)->fd != -1) {\n\t\tclose_file(&HOSTFS_I(inode)->fd);\n\t\tHOSTFS_I(inode)->fd = -1;\n\t\tHOSTFS_I(inode)->dev = 0;\n\t}\n}\n\nstatic void hostfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(hostfs_inode_cache, HOSTFS_I(inode));\n}\n\nstatic int hostfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tconst char *root_path = root->d_sb->s_fs_info;\n\tsize_t offset = strlen(root_ino) + 1;\n\n\tif (strlen(root_path) > offset)\n\t\tseq_show_option(seq, root_path + offset, NULL);\n\n\tif (append)\n\t\tseq_puts(seq, \",append\");\n\n\treturn 0;\n}\n\nstatic const struct super_operations hostfs_sbops = {\n\t.alloc_inode\t= hostfs_alloc_inode,\n\t.free_inode\t= hostfs_free_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= hostfs_evict_inode,\n\t.statfs\t\t= hostfs_statfs,\n\t.show_options\t= hostfs_show_options,\n};\n\nstatic int hostfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tvoid *dir;\n\tchar *name;\n\tunsigned long long next, ino;\n\tint error, len;\n\tunsigned int type;\n\n\tname = dentry_name(file->f_path.dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\tdir = open_dir(name, &error);\n\t__putname(name);\n\tif (dir == NULL)\n\t\treturn -error;\n\tnext = ctx->pos;\n\tseek_dir(dir, next);\n\twhile ((name = read_dir(dir, &next, &ino, &len, &type)) != NULL) {\n\t\tif (!dir_emit(ctx, name, len, ino, type))\n\t\t\tbreak;\n\t\tctx->pos = next;\n\t}\n\tclose_dir(dir);\n\treturn 0;\n}\n\nstatic int hostfs_open(struct inode *ino, struct file *file)\n{\n\tchar *name;\n\tfmode_t mode;\n\tint err;\n\tint r, w, fd;\n\n\tmode = file->f_mode & (FMODE_READ | FMODE_WRITE);\n\tif ((mode & HOSTFS_I(ino)->mode) == mode)\n\t\treturn 0;\n\n\tmode |= HOSTFS_I(ino)->mode;\n\nretry:\n\tr = w = 0;\n\n\tif (mode & FMODE_READ)\n\t\tr = 1;\n\tif (mode & FMODE_WRITE)\n\t\tr = w = 1;\n\n\tname = dentry_name(file_dentry(file));\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tfd = open_file(name, r, w, append);\n\t__putname(name);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmutex_lock(&HOSTFS_I(ino)->open_mutex);\n\t \n\tif ((mode & HOSTFS_I(ino)->mode) == mode) {\n\t\tmutex_unlock(&HOSTFS_I(ino)->open_mutex);\n\t\tclose_file(&fd);\n\t\treturn 0;\n\t}\n\tif ((mode | HOSTFS_I(ino)->mode) != mode) {\n\t\tmode |= HOSTFS_I(ino)->mode;\n\t\tmutex_unlock(&HOSTFS_I(ino)->open_mutex);\n\t\tclose_file(&fd);\n\t\tgoto retry;\n\t}\n\tif (HOSTFS_I(ino)->fd == -1) {\n\t\tHOSTFS_I(ino)->fd = fd;\n\t} else {\n\t\terr = replace_file(fd, HOSTFS_I(ino)->fd);\n\t\tclose_file(&fd);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&HOSTFS_I(ino)->open_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tHOSTFS_I(ino)->mode = mode;\n\tmutex_unlock(&HOSTFS_I(ino)->open_mutex);\n\n\treturn 0;\n}\n\nstatic int hostfs_file_release(struct inode *inode, struct file *file)\n{\n\tfilemap_write_and_wait(inode->i_mapping);\n\n\treturn 0;\n}\n\nstatic int hostfs_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\tint datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tret = file_write_and_wait_range(file, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\tret = fsync_file(HOSTFS_I(inode)->fd, datasync);\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic const struct file_operations hostfs_file_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.open\t\t= hostfs_open,\n\t.release\t= hostfs_file_release,\n\t.fsync\t\t= hostfs_fsync,\n};\n\nstatic const struct file_operations hostfs_dir_fops = {\n\t.llseek\t\t= generic_file_llseek,\n\t.iterate_shared\t= hostfs_readdir,\n\t.read\t\t= generic_read_dir,\n\t.open\t\t= hostfs_open,\n\t.fsync\t\t= hostfs_fsync,\n};\n\nstatic int hostfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tchar *buffer;\n\tloff_t base = page_offset(page);\n\tint count = PAGE_SIZE;\n\tint end_index = inode->i_size >> PAGE_SHIFT;\n\tint err;\n\n\tif (page->index >= end_index)\n\t\tcount = inode->i_size & (PAGE_SIZE-1);\n\n\tbuffer = kmap_local_page(page);\n\n\terr = write_file(HOSTFS_I(inode)->fd, &base, buffer, count);\n\tif (err != count) {\n\t\tif (err >= 0)\n\t\t\terr = -EIO;\n\t\tmapping_set_error(mapping, err);\n\t\tgoto out;\n\t}\n\n\tif (base > inode->i_size)\n\t\tinode->i_size = base;\n\n\terr = 0;\n\n out:\n\tkunmap_local(buffer);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstatic int hostfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tchar *buffer;\n\tloff_t start = page_offset(page);\n\tint bytes_read, ret = 0;\n\n\tbuffer = kmap_local_page(page);\n\tbytes_read = read_file(FILE_HOSTFS_I(file)->fd, &start, buffer,\n\t\t\tPAGE_SIZE);\n\tif (bytes_read < 0) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = bytes_read;\n\t\tgoto out;\n\t}\n\n\tmemset(buffer + bytes_read, 0, PAGE_SIZE - bytes_read);\n\n\tClearPageError(page);\n\tSetPageUptodate(page);\n\n out:\n\tflush_dcache_page(page);\n\tkunmap_local(buffer);\n\tunlock_page(page);\n\n\treturn ret;\n}\n\nstatic int hostfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t      loff_t pos, unsigned len,\n\t\t\t      struct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\n\t*pagep = grab_cache_page_write_begin(mapping, index);\n\tif (!*pagep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int hostfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned copied,\n\t\t\t    struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tvoid *buffer;\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tint err;\n\n\tbuffer = kmap_local_page(page);\n\terr = write_file(FILE_HOSTFS_I(file)->fd, &pos, buffer + from, copied);\n\tkunmap_local(buffer);\n\n\tif (!PageUptodate(page) && err == PAGE_SIZE)\n\t\tSetPageUptodate(page);\n\n\t \n\tif (err > 0 && (pos > inode->i_size))\n\t\tinode->i_size = pos;\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn err;\n}\n\nstatic const struct address_space_operations hostfs_aops = {\n\t.writepage \t= hostfs_writepage,\n\t.read_folio\t= hostfs_read_folio,\n\t.dirty_folio\t= filemap_dirty_folio,\n\t.write_begin\t= hostfs_write_begin,\n\t.write_end\t= hostfs_write_end,\n};\n\nstatic int hostfs_inode_update(struct inode *ino, const struct hostfs_stat *st)\n{\n\tset_nlink(ino, st->nlink);\n\ti_uid_write(ino, st->uid);\n\ti_gid_write(ino, st->gid);\n\tino->i_atime =\n\t\t(struct timespec64){ st->atime.tv_sec, st->atime.tv_nsec };\n\tino->i_mtime =\n\t\t(struct timespec64){ st->mtime.tv_sec, st->mtime.tv_nsec };\n\tinode_set_ctime(ino, st->ctime.tv_sec, st->ctime.tv_nsec);\n\tino->i_size = st->size;\n\tino->i_blocks = st->blocks;\n\treturn 0;\n}\n\nstatic int hostfs_inode_set(struct inode *ino, void *data)\n{\n\tstruct hostfs_stat *st = data;\n\tdev_t rdev;\n\n\t \n\trdev = MKDEV(st->maj, st->min);\n\n\tswitch (st->mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tino->i_op = &hostfs_link_iops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tino->i_op = &hostfs_dir_iops;\n\t\tino->i_fop = &hostfs_dir_fops;\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ino, st->mode & S_IFMT, rdev);\n\t\tino->i_op = &hostfs_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tino->i_op = &hostfs_iops;\n\t\tino->i_fop = &hostfs_file_fops;\n\t\tino->i_mapping->a_ops = &hostfs_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tHOSTFS_I(ino)->dev = st->dev;\n\tino->i_ino = st->ino;\n\tino->i_mode = st->mode;\n\treturn hostfs_inode_update(ino, st);\n}\n\nstatic int hostfs_inode_test(struct inode *inode, void *data)\n{\n\tconst struct hostfs_stat *st = data;\n\n\treturn inode->i_ino == st->ino && HOSTFS_I(inode)->dev == st->dev;\n}\n\nstatic struct inode *hostfs_iget(struct super_block *sb, char *name)\n{\n\tstruct inode *inode;\n\tstruct hostfs_stat st;\n\tint err = stat_file(name, &st, -1);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tinode = iget5_locked(sb, st.ino, hostfs_inode_test, hostfs_inode_set,\n\t\t\t     &st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tunlock_new_inode(inode);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\thostfs_inode_update(inode, &st);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\treturn inode;\n}\n\nstatic int hostfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint fd;\n\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tfd = file_create(name, mode & 0777);\n\tif (fd < 0) {\n\t\t__putname(name);\n\t\treturn fd;\n\t}\n\n\tinode = hostfs_iget(dir->i_sb, name);\n\t__putname(name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tHOSTFS_I(inode)->fd = fd;\n\tHOSTFS_I(inode)->mode = FMODE_READ | FMODE_WRITE;\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nstatic struct dentry *hostfs_lookup(struct inode *ino, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tchar *name;\n\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = hostfs_iget(ino->i_sb, name);\n\t__putname(name);\n\tif (IS_ERR(inode)) {\n\t\tif (PTR_ERR(inode) == -ENOENT)\n\t\t\tinode = NULL;\n\t\telse\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}\n\nstatic int hostfs_link(struct dentry *to, struct inode *ino,\n\t\t       struct dentry *from)\n{\n\tchar *from_name, *to_name;\n\tint err;\n\n\tif ((from_name = dentry_name(from)) == NULL)\n\t\treturn -ENOMEM;\n\tto_name = dentry_name(to);\n\tif (to_name == NULL) {\n\t\t__putname(from_name);\n\t\treturn -ENOMEM;\n\t}\n\terr = link_file(to_name, from_name);\n\t__putname(from_name);\n\t__putname(to_name);\n\treturn err;\n}\n\nstatic int hostfs_unlink(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif (append)\n\t\treturn -EPERM;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\n\terr = unlink_file(file);\n\t__putname(file);\n\treturn err;\n}\n\nstatic int hostfs_symlink(struct mnt_idmap *idmap, struct inode *ino,\n\t\t\t  struct dentry *dentry, const char *to)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = make_symlink(file, to);\n\t__putname(file);\n\treturn err;\n}\n\nstatic int hostfs_mkdir(struct mnt_idmap *idmap, struct inode *ino,\n\t\t\tstruct dentry *dentry, umode_t mode)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = do_mkdir(file, mode);\n\t__putname(file);\n\treturn err;\n}\n\nstatic int hostfs_rmdir(struct inode *ino, struct dentry *dentry)\n{\n\tchar *file;\n\tint err;\n\n\tif ((file = dentry_name(dentry)) == NULL)\n\t\treturn -ENOMEM;\n\terr = hostfs_do_rmdir(file);\n\t__putname(file);\n\treturn err;\n}\n\nstatic int hostfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint err;\n\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\terr = do_mknod(name, mode, MAJOR(dev), MINOR(dev));\n\tif (err) {\n\t\t__putname(name);\n\t\treturn err;\n\t}\n\n\tinode = hostfs_iget(dir->i_sb, name);\n\t__putname(name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nstatic int hostfs_rename2(struct mnt_idmap *idmap,\n\t\t\t  struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t  unsigned int flags)\n{\n\tchar *old_name, *new_name;\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\told_name = dentry_name(old_dentry);\n\tif (old_name == NULL)\n\t\treturn -ENOMEM;\n\tnew_name = dentry_name(new_dentry);\n\tif (new_name == NULL) {\n\t\t__putname(old_name);\n\t\treturn -ENOMEM;\n\t}\n\tif (!flags)\n\t\terr = rename_file(old_name, new_name);\n\telse\n\t\terr = rename2_file(old_name, new_name, flags);\n\n\t__putname(old_name);\n\t__putname(new_name);\n\treturn err;\n}\n\nstatic int hostfs_permission(struct mnt_idmap *idmap,\n\t\t\t     struct inode *ino, int desired)\n{\n\tchar *name;\n\tint r = 0, w = 0, x = 0, err;\n\n\tif (desired & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tif (desired & MAY_READ) r = 1;\n\tif (desired & MAY_WRITE) w = 1;\n\tif (desired & MAY_EXEC) x = 1;\n\tname = inode_name(ino);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tif (S_ISCHR(ino->i_mode) || S_ISBLK(ino->i_mode) ||\n\t    S_ISFIFO(ino->i_mode) || S_ISSOCK(ino->i_mode))\n\t\terr = 0;\n\telse\n\t\terr = access_file(name, r, w, x);\n\t__putname(name);\n\tif (!err)\n\t\terr = generic_permission(&nop_mnt_idmap, ino, desired);\n\treturn err;\n}\n\nstatic int hostfs_setattr(struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hostfs_iattr attrs;\n\tchar *name;\n\tint err;\n\n\tint fd = HOSTFS_I(inode)->fd;\n\n\terr = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (append)\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\tattrs.ia_valid = 0;\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MODE;\n\t\tattrs.ia_mode = attr->ia_mode;\n\t}\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_UID;\n\t\tattrs.ia_uid = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_GID;\n\t\tattrs.ia_gid = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_SIZE;\n\t\tattrs.ia_size = attr->ia_size;\n\t}\n\tif (attr->ia_valid & ATTR_ATIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME;\n\t\tattrs.ia_atime = (struct hostfs_timespec)\n\t\t\t{ attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec };\n\t}\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME;\n\t\tattrs.ia_mtime = (struct hostfs_timespec)\n\t\t\t{ attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec };\n\t}\n\tif (attr->ia_valid & ATTR_CTIME) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_CTIME;\n\t\tattrs.ia_ctime = (struct hostfs_timespec)\n\t\t\t{ attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec };\n\t}\n\tif (attr->ia_valid & ATTR_ATIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_ATIME_SET;\n\t}\n\tif (attr->ia_valid & ATTR_MTIME_SET) {\n\t\tattrs.ia_valid |= HOSTFS_ATTR_MTIME_SET;\n\t}\n\tname = dentry_name(dentry);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\terr = set_attr(name, &attrs, fd);\n\t__putname(name);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic const struct inode_operations hostfs_iops = {\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\n\nstatic const struct inode_operations hostfs_dir_iops = {\n\t.create\t\t= hostfs_create,\n\t.lookup\t\t= hostfs_lookup,\n\t.link\t\t= hostfs_link,\n\t.unlink\t\t= hostfs_unlink,\n\t.symlink\t= hostfs_symlink,\n\t.mkdir\t\t= hostfs_mkdir,\n\t.rmdir\t\t= hostfs_rmdir,\n\t.mknod\t\t= hostfs_mknod,\n\t.rename\t\t= hostfs_rename2,\n\t.permission\t= hostfs_permission,\n\t.setattr\t= hostfs_setattr,\n};\n\nstatic const char *hostfs_get_link(struct dentry *dentry,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct delayed_call *done)\n{\n\tchar *link;\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\tlink = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (link) {\n\t\tchar *path = dentry_name(dentry);\n\t\tint err = -ENOMEM;\n\t\tif (path) {\n\t\t\terr = hostfs_do_readlink(path, link, PATH_MAX);\n\t\t\tif (err == PATH_MAX)\n\t\t\t\terr = -E2BIG;\n\t\t\t__putname(path);\n\t\t}\n\t\tif (err < 0) {\n\t\t\tkfree(link);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t} else {\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tset_delayed_call(done, kfree_link, link);\n\treturn link;\n}\n\nstatic const struct inode_operations hostfs_link_iops = {\n\t.get_link\t= hostfs_get_link,\n};\n\nstatic int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)\n{\n\tstruct inode *root_inode;\n\tchar *host_root_path, *req_root = d;\n\tint err;\n\n\tsb->s_blocksize = 1024;\n\tsb->s_blocksize_bits = 10;\n\tsb->s_magic = HOSTFS_SUPER_MAGIC;\n\tsb->s_op = &hostfs_sbops;\n\tsb->s_d_op = &simple_dentry_operations;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\terr = super_setup_bdi(sb);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (req_root == NULL)\n\t\treq_root = \"\";\n\n\tsb->s_fs_info = host_root_path =\n\t\tkasprintf(GFP_KERNEL, \"%s/%s\", root_ino, req_root);\n\tif (host_root_path == NULL)\n\t\treturn -ENOMEM;\n\n\troot_inode = hostfs_iget(sb, host_root_path);\n\tif (IS_ERR(root_inode))\n\t\treturn PTR_ERR(root_inode);\n\n\tif (S_ISLNK(root_inode->i_mode)) {\n\t\tchar *name;\n\n\t\tiput(root_inode);\n\t\tname = follow_link(host_root_path);\n\t\tif (IS_ERR(name))\n\t\t\treturn PTR_ERR(name);\n\n\t\troot_inode = hostfs_iget(sb, name);\n\t\tkfree(name);\n\t\tif (IS_ERR(root_inode))\n\t\t\treturn PTR_ERR(root_inode);\n\t}\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (sb->s_root == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct dentry *hostfs_read_sb(struct file_system_type *type,\n\t\t\t  int flags, const char *dev_name,\n\t\t\t  void *data)\n{\n\treturn mount_nodev(type, flags, data, hostfs_fill_sb_common);\n}\n\nstatic void hostfs_kill_sb(struct super_block *s)\n{\n\tkill_anon_super(s);\n\tkfree(s->s_fs_info);\n}\n\nstatic struct file_system_type hostfs_type = {\n\t.owner \t\t= THIS_MODULE,\n\t.name \t\t= \"hostfs\",\n\t.mount\t \t= hostfs_read_sb,\n\t.kill_sb\t= hostfs_kill_sb,\n\t.fs_flags \t= 0,\n};\nMODULE_ALIAS_FS(\"hostfs\");\n\nstatic int __init init_hostfs(void)\n{\n\thostfs_inode_cache = KMEM_CACHE(hostfs_inode_info, 0);\n\tif (!hostfs_inode_cache)\n\t\treturn -ENOMEM;\n\treturn register_filesystem(&hostfs_type);\n}\n\nstatic void __exit exit_hostfs(void)\n{\n\tunregister_filesystem(&hostfs_type);\n\tkmem_cache_destroy(hostfs_inode_cache);\n}\n\nmodule_init(init_hostfs)\nmodule_exit(exit_hostfs)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}