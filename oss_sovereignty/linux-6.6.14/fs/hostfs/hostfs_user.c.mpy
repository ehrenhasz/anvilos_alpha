{
  "module_name": "hostfs_user.c",
  "hash_id": "284449ec33ffaff8119e2f65a4c392763206ff2be99918dd8bf55b864216b921",
  "original_prompt": "Ingested from linux-6.6.14/fs/hostfs/hostfs_user.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <sys/syscall.h>\n#include \"hostfs.h\"\n#include <utime.h>\n\nstatic void stat64_to_hostfs(const struct stat64 *buf, struct hostfs_stat *p)\n{\n\tp->ino = buf->st_ino;\n\tp->mode = buf->st_mode;\n\tp->nlink = buf->st_nlink;\n\tp->uid = buf->st_uid;\n\tp->gid = buf->st_gid;\n\tp->size = buf->st_size;\n\tp->atime.tv_sec = buf->st_atime;\n\tp->atime.tv_nsec = 0;\n\tp->ctime.tv_sec = buf->st_ctime;\n\tp->ctime.tv_nsec = 0;\n\tp->mtime.tv_sec = buf->st_mtime;\n\tp->mtime.tv_nsec = 0;\n\tp->blksize = buf->st_blksize;\n\tp->blocks = buf->st_blocks;\n\tp->maj = os_major(buf->st_rdev);\n\tp->min = os_minor(buf->st_rdev);\n\tp->dev = buf->st_dev;\n}\n\nint stat_file(const char *path, struct hostfs_stat *p, int fd)\n{\n\tstruct stat64 buf;\n\n\tif (fd >= 0) {\n\t\tif (fstat64(fd, &buf) < 0)\n\t\t\treturn -errno;\n\t} else if (lstat64(path, &buf) < 0) {\n\t\treturn -errno;\n\t}\n\tstat64_to_hostfs(&buf, p);\n\treturn 0;\n}\n\nint access_file(char *path, int r, int w, int x)\n{\n\tint mode = 0;\n\n\tif (r)\n\t\tmode = R_OK;\n\tif (w)\n\t\tmode |= W_OK;\n\tif (x)\n\t\tmode |= X_OK;\n\tif (access(path, mode) != 0)\n\t\treturn -errno;\n\telse return 0;\n}\n\nint open_file(char *path, int r, int w, int append)\n{\n\tint mode = 0, fd;\n\n\tif (r && !w)\n\t\tmode = O_RDONLY;\n\telse if (!r && w)\n\t\tmode = O_WRONLY;\n\telse if (r && w)\n\t\tmode = O_RDWR;\n\telse panic(\"Impossible mode in open_file\");\n\n\tif (append)\n\t\tmode |= O_APPEND;\n\tfd = open64(path, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\telse return fd;\n}\n\nvoid *open_dir(char *path, int *err_out)\n{\n\tDIR *dir;\n\n\tdir = opendir(path);\n\t*err_out = errno;\n\n\treturn dir;\n}\n\nvoid seek_dir(void *stream, unsigned long long pos)\n{\n\tDIR *dir = stream;\n\n\tseekdir(dir, pos);\n}\n\nchar *read_dir(void *stream, unsigned long long *pos_out,\n\t       unsigned long long *ino_out, int *len_out,\n\t       unsigned int *type_out)\n{\n\tDIR *dir = stream;\n\tstruct dirent *ent;\n\n\tent = readdir(dir);\n\tif (ent == NULL)\n\t\treturn NULL;\n\t*len_out = strlen(ent->d_name);\n\t*ino_out = ent->d_ino;\n\t*type_out = ent->d_type;\n\t*pos_out = ent->d_off;\n\treturn ent->d_name;\n}\n\nint read_file(int fd, unsigned long long *offset, char *buf, int len)\n{\n\tint n;\n\n\tn = pread64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}\n\nint write_file(int fd, unsigned long long *offset, const char *buf, int len)\n{\n\tint n;\n\n\tn = pwrite64(fd, buf, len, *offset);\n\tif (n < 0)\n\t\treturn -errno;\n\t*offset += n;\n\treturn n;\n}\n\nint lseek_file(int fd, long long offset, int whence)\n{\n\tint ret;\n\n\tret = lseek64(fd, offset, whence);\n\tif (ret < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint fsync_file(int fd, int datasync)\n{\n\tint ret;\n\tif (datasync)\n\t\tret = fdatasync(fd);\n\telse\n\t\tret = fsync(fd);\n\n\tif (ret < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint replace_file(int oldfd, int fd)\n{\n\treturn dup2(oldfd, fd);\n}\n\nvoid close_file(void *stream)\n{\n\tclose(*((int *) stream));\n}\n\nvoid close_dir(void *stream)\n{\n\tclosedir(stream);\n}\n\nint file_create(char *name, int mode)\n{\n\tint fd;\n\n\tfd = open64(name, O_CREAT | O_RDWR, mode);\n\tif (fd < 0)\n\t\treturn -errno;\n\treturn fd;\n}\n\nint set_attr(const char *file, struct hostfs_iattr *attrs, int fd)\n{\n\tstruct hostfs_stat st;\n\tstruct timeval times[2];\n\tint err, ma;\n\n\tif (attrs->ia_valid & HOSTFS_ATTR_MODE) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchmod(fd, attrs->ia_mode) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (chmod(file, attrs->ia_mode) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_UID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, attrs->ia_uid, -1))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, attrs->ia_uid, -1)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_GID) {\n\t\tif (fd >= 0) {\n\t\t\tif (fchown(fd, -1, attrs->ia_gid))\n\t\t\t\treturn -errno;\n\t\t} else if (chown(file, -1, attrs->ia_gid)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\tif (attrs->ia_valid & HOSTFS_ATTR_SIZE) {\n\t\tif (fd >= 0) {\n\t\t\tif (ftruncate(fd, attrs->ia_size))\n\t\t\t\treturn -errno;\n\t\t} else if (truncate(file, attrs->ia_size)) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t \n\tma = (HOSTFS_ATTR_ATIME_SET | HOSTFS_ATTR_MTIME_SET);\n\tif (attrs->ia_valid & ma) {\n\t\terr = stat_file(file, &st, fd);\n\t\tif (err != 0)\n\t\t\treturn err;\n\n\t\ttimes[0].tv_sec = st.atime.tv_sec;\n\t\ttimes[0].tv_usec = st.atime.tv_nsec / 1000;\n\t\ttimes[1].tv_sec = st.mtime.tv_sec;\n\t\ttimes[1].tv_usec = st.mtime.tv_nsec / 1000;\n\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_ATIME_SET) {\n\t\t\ttimes[0].tv_sec = attrs->ia_atime.tv_sec;\n\t\t\ttimes[0].tv_usec = attrs->ia_atime.tv_nsec / 1000;\n\t\t}\n\t\tif (attrs->ia_valid & HOSTFS_ATTR_MTIME_SET) {\n\t\t\ttimes[1].tv_sec = attrs->ia_mtime.tv_sec;\n\t\t\ttimes[1].tv_usec = attrs->ia_mtime.tv_nsec / 1000;\n\t\t}\n\n\t\tif (fd >= 0) {\n\t\t\tif (futimes(fd, times) != 0)\n\t\t\t\treturn -errno;\n\t\t} else if (utimes(file, times) != 0) {\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t \n\tif (attrs->ia_valid & (HOSTFS_ATTR_ATIME | HOSTFS_ATTR_MTIME)) {\n\t\terr = stat_file(file, &st, fd);\n\t\tattrs->ia_atime = st.atime;\n\t\tattrs->ia_mtime = st.mtime;\n\t\tif (err != 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint make_symlink(const char *from, const char *to)\n{\n\tint err;\n\n\terr = symlink(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint unlink_file(const char *file)\n{\n\tint err;\n\n\terr = unlink(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint do_mkdir(const char *file, int mode)\n{\n\tint err;\n\n\terr = mkdir(file, mode);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint hostfs_do_rmdir(const char *file)\n{\n\tint err;\n\n\terr = rmdir(file);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint do_mknod(const char *file, int mode, unsigned int major, unsigned int minor)\n{\n\tint err;\n\n\terr = mknod(file, mode, os_makedev(major, minor));\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint link_file(const char *to, const char *from)\n{\n\tint err;\n\n\terr = link(to, from);\n\tif (err)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint hostfs_do_readlink(char *file, char *buf, int size)\n{\n\tint n;\n\n\tn = readlink(file, buf, size);\n\tif (n < 0)\n\t\treturn -errno;\n\tif (n < size)\n\t\tbuf[n] = '\\0';\n\treturn n;\n}\n\nint rename_file(char *from, char *to)\n{\n\tint err;\n\n\terr = rename(from, to);\n\tif (err < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n\nint rename2_file(char *from, char *to, unsigned int flags)\n{\n\tint err;\n\n#ifndef SYS_renameat2\n#  ifdef __x86_64__\n#    define SYS_renameat2 316\n#  endif\n#  ifdef __i386__\n#    define SYS_renameat2 353\n#  endif\n#endif\n\n#ifdef SYS_renameat2\n\terr = syscall(SYS_renameat2, AT_FDCWD, from, AT_FDCWD, to, flags);\n\tif (err < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn -errno;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n#else\n\treturn -EINVAL;\n#endif\n}\n\nint do_statfs(char *root, long *bsize_out, long long *blocks_out,\n\t      long long *bfree_out, long long *bavail_out,\n\t      long long *files_out, long long *ffree_out,\n\t      void *fsid_out, int fsid_size, long *namelen_out)\n{\n\tstruct statfs64 buf;\n\tint err;\n\n\terr = statfs64(root, &buf);\n\tif (err < 0)\n\t\treturn -errno;\n\n\t*bsize_out = buf.f_bsize;\n\t*blocks_out = buf.f_blocks;\n\t*bfree_out = buf.f_bfree;\n\t*bavail_out = buf.f_bavail;\n\t*files_out = buf.f_files;\n\t*ffree_out = buf.f_ffree;\n\tmemcpy(fsid_out, &buf.f_fsid,\n\t       sizeof(buf.f_fsid) > fsid_size ? fsid_size :\n\t       sizeof(buf.f_fsid));\n\t*namelen_out = buf.f_namelen;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}