{
  "module_name": "inode.c",
  "hash_id": "6dd28182d0c87a9dbb765a683182c3d49e3ef66d40c1845b7c10a1f65419f647",
  "original_prompt": "Ingested from linux-6.6.14/fs/ramfs/inode.c",
  "human_readable_source": " \n\n \n\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/ramfs.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/seq_file.h>\n#include \"internal.h\"\n\nstruct ramfs_mount_opts {\n\tumode_t mode;\n};\n\nstruct ramfs_fs_info {\n\tstruct ramfs_mount_opts mount_opts;\n};\n\n#define RAMFS_DEFAULT_MODE\t0755\n\nstatic const struct super_operations ramfs_ops;\nstatic const struct inode_operations ramfs_dir_inode_operations;\n\nstruct inode *ramfs_get_inode(struct super_block *sb,\n\t\t\t\tconst struct inode *dir, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(&nop_mnt_idmap, inode, dir, mode);\n\t\tinode->i_mapping->a_ops = &ram_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_HIGHUSER);\n\t\tmapping_set_unevictable(inode->i_mapping);\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &ramfs_file_inode_operations;\n\t\t\tinode->i_fop = &ramfs_file_operations;\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinode->i_op = &ramfs_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t\t \n\t\t\tinc_nlink(inode);\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn inode;\n}\n\n \n \nstatic int\nramfs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t    struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tstruct inode * inode = ramfs_get_inode(dir->i_sb, dir, mode, dev);\n\tint error = -ENOSPC;\n\n\tif (inode) {\n\t\td_instantiate(dentry, inode);\n\t\tdget(dentry);\t \n\t\terror = 0;\n\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t}\n\treturn error;\n}\n\nstatic int ramfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode)\n{\n\tint retval = ramfs_mknod(&nop_mnt_idmap, dir, dentry, mode | S_IFDIR, 0);\n\tif (!retval)\n\t\tinc_nlink(dir);\n\treturn retval;\n}\n\nstatic int ramfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn ramfs_mknod(&nop_mnt_idmap, dir, dentry, mode | S_IFREG, 0);\n}\n\nstatic int ramfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, const char *symname)\n{\n\tstruct inode *inode;\n\tint error = -ENOSPC;\n\n\tinode = ramfs_get_inode(dir->i_sb, dir, S_IFLNK|S_IRWXUGO, 0);\n\tif (inode) {\n\t\tint l = strlen(symname)+1;\n\t\terror = page_symlink(inode, symname, l);\n\t\tif (!error) {\n\t\t\td_instantiate(dentry, inode);\n\t\t\tdget(dentry);\n\t\t\tdir->i_mtime = inode_set_ctime_current(dir);\n\t\t} else\n\t\t\tiput(inode);\n\t}\n\treturn error;\n}\n\nstatic int ramfs_tmpfile(struct mnt_idmap *idmap,\n\t\t\t struct inode *dir, struct file *file, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = ramfs_get_inode(dir->i_sb, dir, mode, 0);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\td_tmpfile(file, inode);\n\treturn finish_open_simple(file, 0);\n}\n\nstatic const struct inode_operations ramfs_dir_inode_operations = {\n\t.create\t\t= ramfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n\t.symlink\t= ramfs_symlink,\n\t.mkdir\t\t= ramfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n\t.mknod\t\t= ramfs_mknod,\n\t.rename\t\t= simple_rename,\n\t.tmpfile\t= ramfs_tmpfile,\n};\n\n \nstatic int ramfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct ramfs_fs_info *fsi = root->d_sb->s_fs_info;\n\n\tif (fsi->mount_opts.mode != RAMFS_DEFAULT_MODE)\n\t\tseq_printf(m, \",mode=%o\", fsi->mount_opts.mode);\n\treturn 0;\n}\n\nstatic const struct super_operations ramfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.show_options\t= ramfs_show_options,\n};\n\nenum ramfs_param {\n\tOpt_mode,\n};\n\nconst struct fs_parameter_spec ramfs_fs_parameters[] = {\n\tfsparam_u32oct(\"mode\",\tOpt_mode),\n\t{}\n};\n\nstatic int ramfs_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct ramfs_fs_info *fsi = fc->s_fs_info;\n\tint opt;\n\n\topt = fs_parse(fc, ramfs_fs_parameters, param, &result);\n\tif (opt == -ENOPARAM) {\n\t\topt = vfs_parse_fs_param_source(fc, param);\n\t\tif (opt != -ENOPARAM)\n\t\t\treturn opt;\n\t\t \n\t\treturn 0;\n\t}\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_mode:\n\t\tfsi->mount_opts.mode = result.uint_32 & S_IALLUGO;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ramfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct ramfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode;\n\n\tsb->s_maxbytes\t\t= MAX_LFS_FILESIZE;\n\tsb->s_blocksize\t\t= PAGE_SIZE;\n\tsb->s_blocksize_bits\t= PAGE_SHIFT;\n\tsb->s_magic\t\t= RAMFS_MAGIC;\n\tsb->s_op\t\t= &ramfs_ops;\n\tsb->s_time_gran\t\t= 1;\n\n\tinode = ramfs_get_inode(sb, NULL, S_IFDIR | fsi->mount_opts.mode, 0);\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ramfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, ramfs_fill_super);\n}\n\nstatic void ramfs_free_fc(struct fs_context *fc)\n{\n\tkfree(fc->s_fs_info);\n}\n\nstatic const struct fs_context_operations ramfs_context_ops = {\n\t.free\t\t= ramfs_free_fc,\n\t.parse_param\t= ramfs_parse_param,\n\t.get_tree\t= ramfs_get_tree,\n};\n\nint ramfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct ramfs_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(*fsi), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn -ENOMEM;\n\n\tfsi->mount_opts.mode = RAMFS_DEFAULT_MODE;\n\tfc->s_fs_info = fsi;\n\tfc->ops = &ramfs_context_ops;\n\treturn 0;\n}\n\nvoid ramfs_kill_sb(struct super_block *sb)\n{\n\tkfree(sb->s_fs_info);\n\tkill_litter_super(sb);\n}\n\nstatic struct file_system_type ramfs_fs_type = {\n\t.name\t\t= \"ramfs\",\n\t.init_fs_context = ramfs_init_fs_context,\n\t.parameters\t= ramfs_fs_parameters,\n\t.kill_sb\t= ramfs_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\nstatic int __init init_ramfs_fs(void)\n{\n\treturn register_filesystem(&ramfs_fs_type);\n}\nfs_initcall(init_ramfs_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}