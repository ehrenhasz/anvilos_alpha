{
  "module_name": "file-nommu.c",
  "hash_id": "37e842107d81397a2fff182ece02a68c6589bfbc851a515fdfa8af2d1b10bf9e",
  "original_prompt": "Ingested from linux-6.6.14/fs/ramfs/file-nommu.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/ramfs.h>\n#include <linux/pagevec.h>\n#include <linux/mman.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nstatic int ramfs_nommu_setattr(struct mnt_idmap *, struct dentry *, struct iattr *);\nstatic unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t\t   unsigned long len,\n\t\t\t\t\t\t   unsigned long pgoff,\n\t\t\t\t\t\t   unsigned long flags);\nstatic int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic unsigned ramfs_mmap_capabilities(struct file *file)\n{\n\treturn NOMMU_MAP_DIRECT | NOMMU_MAP_COPY | NOMMU_MAP_READ |\n\t\tNOMMU_MAP_WRITE | NOMMU_MAP_EXEC;\n}\n\nconst struct file_operations ramfs_file_operations = {\n\t.mmap_capabilities\t= ramfs_mmap_capabilities,\n\t.mmap\t\t\t= ramfs_nommu_mmap,\n\t.get_unmapped_area\t= ramfs_nommu_get_unmapped_area,\n\t.read_iter\t\t= generic_file_read_iter,\n\t.write_iter\t\t= generic_file_write_iter,\n\t.fsync\t\t\t= noop_fsync,\n\t.splice_read\t\t= filemap_splice_read,\n\t.splice_write\t\t= iter_file_splice_write,\n\t.llseek\t\t\t= generic_file_llseek,\n};\n\nconst struct inode_operations ramfs_file_inode_operations = {\n\t.setattr\t\t= ramfs_nommu_setattr,\n\t.getattr\t\t= simple_getattr,\n};\n\n \n \nint ramfs_nommu_expand_for_mapping(struct inode *inode, size_t newsize)\n{\n\tunsigned long npages, xpages, loop;\n\tstruct page *pages;\n\tunsigned order;\n\tvoid *data;\n\tint ret;\n\tgfp_t gfp = mapping_gfp_mask(inode->i_mapping);\n\n\t \n\torder = get_order(newsize);\n\tif (unlikely(order > MAX_ORDER))\n\t\treturn -EFBIG;\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\ti_size_write(inode, newsize);\n\n\t \n\tpages = alloc_pages(gfp, order);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t \n\txpages = 1UL << order;\n\tnpages = (newsize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\tsplit_page(pages, order);\n\n\t \n\tfor (loop = npages; loop < xpages; loop++)\n\t\t__free_page(pages + loop);\n\n\t \n\tnewsize = PAGE_SIZE * npages;\n\tdata = page_address(pages);\n\tmemset(data, 0, newsize);\n\n\t \n\tfor (loop = 0; loop < npages; loop++) {\n\t\tstruct page *page = pages + loop;\n\n\t\tret = add_to_page_cache_lru(page, inode->i_mapping, loop,\n\t\t\t\t\tgfp);\n\t\tif (ret < 0)\n\t\t\tgoto add_error;\n\n\t\t \n\t\tSetPageDirty(page);\n\t\tSetPageUptodate(page);\n\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t}\n\n\treturn 0;\n\nadd_error:\n\twhile (loop < npages)\n\t\t__free_page(pages + loop++);\n\treturn ret;\n}\n\n \n \nstatic int ramfs_nommu_resize(struct inode *inode, loff_t newsize, loff_t size)\n{\n\tint ret;\n\n\t \n\tif (size == 0) {\n\t\tif (unlikely(newsize >> 32))\n\t\t\treturn -EFBIG;\n\n\t\treturn ramfs_nommu_expand_for_mapping(inode, newsize);\n\t}\n\n\t \n\tif (newsize < size) {\n\t\tret = nommu_shrink_inode_mappings(inode, size, newsize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttruncate_setsize(inode, newsize);\n\treturn 0;\n}\n\n \n \nstatic int ramfs_nommu_setattr(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, struct iattr *ia)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int old_ia_valid = ia->ia_valid;\n\tint ret = 0;\n\n\t \n\tret = setattr_prepare(&nop_mnt_idmap, dentry, ia);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ia->ia_valid & ATTR_SIZE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (ia->ia_size != size) {\n\t\t\tret = ramfs_nommu_resize(inode, ia->ia_size, size);\n\t\t\tif (ret < 0 || ia->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tia->ia_valid |= ATTR_MTIME|ATTR_CTIME;\n\t\t}\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, ia);\n out:\n\tia->ia_valid = old_ia_valid;\n\treturn ret;\n}\n\n \n \nstatic unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t\t\t    unsigned long pgoff, unsigned long flags)\n{\n\tunsigned long maxpages, lpages, nr_folios, loop, ret, nr_pages, pfn;\n\tstruct inode *inode = file_inode(file);\n\tstruct folio_batch fbatch;\n\tloff_t isize;\n\n\t \n\tlpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tisize = i_size_read(inode);\n\n\tret = -ENOSYS;\n\tmaxpages = (isize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (pgoff >= maxpages)\n\t\tgoto out;\n\n\tif (maxpages - pgoff < lpages)\n\t\tgoto out;\n\n\t \n\tfolio_batch_init(&fbatch);\n\tnr_pages = 0;\nrepeat:\n\tnr_folios = filemap_get_folios_contig(inode->i_mapping, &pgoff,\n\t\t\tULONG_MAX, &fbatch);\n\tif (!nr_folios) {\n\t\tret = -ENOSYS;\n\t\treturn ret;\n\t}\n\n\tif (ret == -ENOSYS) {\n\t\tret = (unsigned long) folio_address(fbatch.folios[0]);\n\t\tpfn = folio_pfn(fbatch.folios[0]);\n\t}\n\t \n\tfor (loop = 0; loop < nr_folios; loop++) {\n\t\tif (pfn + nr_pages != folio_pfn(fbatch.folios[loop])) {\n\t\t\tret = -ENOSYS;\n\t\t\tgoto out_free;  \n\t\t}\n\t\tnr_pages += folio_nr_pages(fbatch.folios[loop]);\n\t\tif (nr_pages >= lpages)\n\t\t\tgoto out_free;  \n\t}\n\n\tif (nr_pages < lpages) {\n\t\tfolio_batch_release(&fbatch);\n\t\tgoto repeat;  \n\t}\n\t \n\nout_free:\n\tfolio_batch_release(&fbatch);\nout:\n\treturn ret;\n}\n\n \n \nstatic int ramfs_nommu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif (!is_nommu_shared_mapping(vma->vm_flags))\n\t\treturn -ENOSYS;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}