{
  "module_name": "vxfs_bmap.c",
  "hash_id": "a03a52ab7be1a0255a5143f11051c2deaab11c3b58c8c97528737180dfb49262",
  "original_prompt": "Ingested from linux-6.6.14/fs/freevxfs/vxfs_bmap.c",
  "human_readable_source": "\n \n\n \n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#include \"vxfs.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_extern.h\"\n\n\n#ifdef DIAGNOSTIC\nstatic void\nvxfs_typdump(struct vxfs_typed *typ)\n{\n\tprintk(KERN_DEBUG \"type=%Lu \", typ->vt_hdr >> VXFS_TYPED_TYPESHIFT);\n\tprintk(\"offset=%Lx \", typ->vt_hdr & VXFS_TYPED_OFFSETMASK);\n\tprintk(\"block=%x \", typ->vt_block);\n\tprintk(\"size=%x\\n\", typ->vt_size);\n}\n#endif\n\n \nstatic daddr_t\nvxfs_bmap_ext4(struct inode *ip, long bn)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct vxfs_inode_info *vip = VXFS_INO(ip);\n\tstruct vxfs_sb_info *sbi = VXFS_SBI(sb);\n\tunsigned long bsize = sb->s_blocksize;\n\tu32 indsize = fs32_to_cpu(sbi, vip->vii_ext4.ve4_indsize);\n\tint i;\n\n\tif (indsize > sb->s_blocksize)\n\t\tgoto fail_size;\n\n\tfor (i = 0; i < VXFS_NDADDR; i++) {\n\t\tstruct direct *d = vip->vii_ext4.ve4_direct + i;\n\t\tif (bn >= 0 && bn < fs32_to_cpu(sbi, d->size))\n\t\t\treturn (bn + fs32_to_cpu(sbi, d->extent));\n\t\tbn -= fs32_to_cpu(sbi, d->size);\n\t}\n\n\tif ((bn / (indsize * indsize * bsize / 4)) == 0) {\n\t\tstruct buffer_head *buf;\n\t\tdaddr_t\tbno;\n\t\t__fs32 *indir;\n\n\t\tbuf = sb_bread(sb,\n\t\t\tfs32_to_cpu(sbi, vip->vii_ext4.ve4_indir[0]));\n\t\tif (!buf || !buffer_mapped(buf))\n\t\t\tgoto fail_buf;\n\n\t\tindir = (__fs32 *)buf->b_data;\n\t\tbno = fs32_to_cpu(sbi, indir[(bn / indsize) % (indsize * bn)]) +\n\t\t\t(bn % indsize);\n\n\t\tbrelse(buf);\n\t\treturn bno;\n\t} else\n\t\tprintk(KERN_WARNING \"no matching indir?\");\n\n\treturn 0;\n\nfail_size:\n\tprintk(\"vxfs: indirect extent too big!\\n\");\nfail_buf:\n\treturn 0;\n}\n\n \nstatic daddr_t\nvxfs_bmap_indir(struct inode *ip, long indir, int size, long block)\n{\n\tstruct vxfs_sb_info\t\t*sbi = VXFS_SBI(ip->i_sb);\n\tstruct buffer_head\t\t*bp = NULL;\n\tdaddr_t\t\t\t\tpblock = 0;\n\tint\t\t\t\ti;\n\n\tfor (i = 0; i < size * VXFS_TYPED_PER_BLOCK(ip->i_sb); i++) {\n\t\tstruct vxfs_typed\t*typ;\n\t\tint64_t\t\t\toff;\n\n\t\tbp = sb_bread(ip->i_sb,\n\t\t\t\tindir + (i / VXFS_TYPED_PER_BLOCK(ip->i_sb)));\n\t\tif (!bp || !buffer_mapped(bp))\n\t\t\treturn 0;\n\n\t\ttyp = ((struct vxfs_typed *)bp->b_data) +\n\t\t\t(i % VXFS_TYPED_PER_BLOCK(ip->i_sb));\n\t\toff = fs64_to_cpu(sbi, typ->vt_hdr) & VXFS_TYPED_OFFSETMASK;\n\n\t\tif (block < off) {\n\t\t\tbrelse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch ((u_int32_t)(fs64_to_cpu(sbi, typ->vt_hdr) >>\n\t\t\t\tVXFS_TYPED_TYPESHIFT)) {\n\t\tcase VXFS_TYPED_INDIRECT:\n\t\t\tpblock = vxfs_bmap_indir(ip,\n\t\t\t\t\tfs32_to_cpu(sbi, typ->vt_block),\n\t\t\t\t\tfs32_to_cpu(sbi, typ->vt_size),\n\t\t\t\t\tblock - off);\n\t\t\tif (pblock == -2)\n\t\t\t\tbreak;\n\t\t\tgoto out;\n\t\tcase VXFS_TYPED_DATA:\n\t\t\tif ((block - off) >= fs32_to_cpu(sbi, typ->vt_size))\n\t\t\t\tbreak;\n\t\t\tpblock = fs32_to_cpu(sbi, typ->vt_block) + block - off;\n\t\t\tgoto out;\n\t\tcase VXFS_TYPED_INDIRECT_DEV4:\n\t\tcase VXFS_TYPED_DATA_DEV4: {\n\t\t\tstruct vxfs_typed_dev4\t*typ4 =\n\t\t\t\t(struct vxfs_typed_dev4 *)typ;\n\n\t\t\tprintk(KERN_INFO \"\\n\\nTYPED_DEV4 detected!\\n\");\n\t\t\tprintk(KERN_INFO \"block: %llu\\tsize: %lld\\tdev: %d\\n\",\n\t\t\t       fs64_to_cpu(sbi, typ4->vd4_block),\n\t\t\t       fs64_to_cpu(sbi, typ4->vd4_size),\n\t\t\t       fs32_to_cpu(sbi, typ4->vd4_dev));\n\t\t\tgoto fail;\n\t\t}\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s:%d vt_hdr %llu\\n\", __func__,\n\t\t\t\t__LINE__, fs64_to_cpu(sbi, typ->vt_hdr));\n\t\t\tBUG();\n\t\t}\n\t\tbrelse(bp);\n\t}\n\nfail:\n\tpblock = 0;\nout:\n\tbrelse(bp);\n\treturn (pblock);\n}\n\n \nstatic daddr_t\nvxfs_bmap_typed(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\tstruct vxfs_sb_info\t\t*sbi = VXFS_SBI(ip->i_sb);\n\tdaddr_t\t\t\t\tpblock = 0;\n\tint\t\t\t\ti;\n\n\tfor (i = 0; i < VXFS_NTYPED; i++) {\n\t\tstruct vxfs_typed\t*typ = vip->vii_org.typed + i;\n\t\tu64\t\t\thdr = fs64_to_cpu(sbi, typ->vt_hdr);\n\t\tint64_t\t\t\toff = (hdr & VXFS_TYPED_OFFSETMASK);\n\n#ifdef DIAGNOSTIC\n\t\tvxfs_typdump(typ);\n#endif\n\t\tif (iblock < off)\n\t\t\tcontinue;\n\t\tswitch ((u32)(hdr >> VXFS_TYPED_TYPESHIFT)) {\n\t\tcase VXFS_TYPED_INDIRECT:\n\t\t\tpblock = vxfs_bmap_indir(ip,\n\t\t\t\t\tfs32_to_cpu(sbi, typ->vt_block),\n\t\t\t\t\tfs32_to_cpu(sbi, typ->vt_size),\n\t\t\t\t\tiblock - off);\n\t\t\tif (pblock == -2)\n\t\t\t\tbreak;\n\t\t\treturn (pblock);\n\t\tcase VXFS_TYPED_DATA:\n\t\t\tif ((iblock - off) < fs32_to_cpu(sbi, typ->vt_size))\n\t\t\t\treturn (fs32_to_cpu(sbi, typ->vt_block) +\n\t\t\t\t\t\tiblock - off);\n\t\t\tbreak;\n\t\tcase VXFS_TYPED_INDIRECT_DEV4:\n\t\tcase VXFS_TYPED_DATA_DEV4: {\n\t\t\tstruct vxfs_typed_dev4\t*typ4 =\n\t\t\t\t(struct vxfs_typed_dev4 *)typ;\n\n\t\t\tprintk(KERN_INFO \"\\n\\nTYPED_DEV4 detected!\\n\");\n\t\t\tprintk(KERN_INFO \"block: %llu\\tsize: %lld\\tdev: %d\\n\",\n\t\t\t       fs64_to_cpu(sbi, typ4->vd4_block),\n\t\t\t       fs64_to_cpu(sbi, typ4->vd4_size),\n\t\t\t       fs32_to_cpu(sbi, typ4->vd4_dev));\n\t\t\treturn 0;\n\t\t}\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \ndaddr_t\nvxfs_bmap1(struct inode *ip, long iblock)\n{\n\tstruct vxfs_inode_info\t\t*vip = VXFS_INO(ip);\n\n\tif (VXFS_ISEXT4(vip))\n\t\treturn vxfs_bmap_ext4(ip, iblock);\n\tif (VXFS_ISTYPED(vip))\n\t\treturn vxfs_bmap_typed(ip, iblock);\n\tif (VXFS_ISNONE(vip))\n\t\tgoto unsupp;\n\tif (VXFS_ISIMMED(vip))\n\t\tgoto unsupp;\n\n\tprintk(KERN_WARNING \"vxfs: inode %ld has no valid orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\tBUG();\n\nunsupp:\n\tprintk(KERN_WARNING \"vxfs: inode %ld has an unsupported orgtype (%x)\\n\",\n\t\t\tip->i_ino, vip->vii_orgtype);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}