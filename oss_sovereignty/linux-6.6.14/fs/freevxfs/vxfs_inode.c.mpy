{
  "module_name": "vxfs_inode.c",
  "hash_id": "1f103722e1744293648e6ca17631293ae090d14914c07e8fc9815c079730e75d",
  "original_prompt": "Ingested from linux-6.6.14/fs/freevxfs/vxfs_inode.c",
  "human_readable_source": "\n \n\n \n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n\n#include \"vxfs.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_extern.h\"\n\n\n#ifdef DIAGNOSTIC\n \nvoid\nvxfs_dumpi(struct vxfs_inode_info *vip, ino_t ino)\n{\n\tprintk(KERN_DEBUG \"\\n\\n\");\n\tif (ino)\n\t\tprintk(KERN_DEBUG \"dumping vxfs inode %ld\\n\", ino);\n\telse\n\t\tprintk(KERN_DEBUG \"dumping unknown vxfs inode\\n\");\n\n\tprintk(KERN_DEBUG \"---------------------------\\n\");\n\tprintk(KERN_DEBUG \"mode is %x\\n\", vip->vii_mode);\n\tprintk(KERN_DEBUG \"nlink:%u, uid:%u, gid:%u\\n\",\n\t\t\tvip->vii_nlink, vip->vii_uid, vip->vii_gid);\n\tprintk(KERN_DEBUG \"size:%Lx, blocks:%u\\n\",\n\t\t\tvip->vii_size, vip->vii_blocks);\n\tprintk(KERN_DEBUG \"orgtype:%u\\n\", vip->vii_orgtype);\n}\n#endif\n\n \nstatic __inline__ umode_t\nvxfs_transmod(struct vxfs_inode_info *vip)\n{\n\tumode_t\t\t\tret = vip->vii_mode & ~VXFS_TYPE_MASK;\n\n\tif (VXFS_ISFIFO(vip))\n\t\tret |= S_IFIFO;\n\tif (VXFS_ISCHR(vip))\n\t\tret |= S_IFCHR;\n\tif (VXFS_ISDIR(vip))\n\t\tret |= S_IFDIR;\n\tif (VXFS_ISBLK(vip))\n\t\tret |= S_IFBLK;\n\tif (VXFS_ISLNK(vip))\n\t\tret |= S_IFLNK;\n\tif (VXFS_ISREG(vip))\n\t\tret |= S_IFREG;\n\tif (VXFS_ISSOC(vip))\n\t\tret |= S_IFSOCK;\n\n\treturn (ret);\n}\n\nstatic inline void dip2vip_cpy(struct vxfs_sb_info *sbi,\n\t\tstruct vxfs_inode_info *vip, struct vxfs_dinode *dip)\n{\n\tstruct inode *inode = &vip->vfs_inode;\n\n\tvip->vii_mode = fs32_to_cpu(sbi, dip->vdi_mode);\n\tvip->vii_nlink = fs32_to_cpu(sbi, dip->vdi_nlink);\n\tvip->vii_uid = fs32_to_cpu(sbi, dip->vdi_uid);\n\tvip->vii_gid = fs32_to_cpu(sbi, dip->vdi_gid);\n\tvip->vii_size = fs64_to_cpu(sbi, dip->vdi_size);\n\tvip->vii_atime = fs32_to_cpu(sbi, dip->vdi_atime);\n\tvip->vii_autime = fs32_to_cpu(sbi, dip->vdi_autime);\n\tvip->vii_mtime = fs32_to_cpu(sbi, dip->vdi_mtime);\n\tvip->vii_mutime = fs32_to_cpu(sbi, dip->vdi_mutime);\n\tvip->vii_ctime = fs32_to_cpu(sbi, dip->vdi_ctime);\n\tvip->vii_cutime = fs32_to_cpu(sbi, dip->vdi_cutime);\n\tvip->vii_orgtype = dip->vdi_orgtype;\n\n\tvip->vii_blocks = fs32_to_cpu(sbi, dip->vdi_blocks);\n\tvip->vii_gen = fs32_to_cpu(sbi, dip->vdi_gen);\n\n\tif (VXFS_ISDIR(vip))\n\t\tvip->vii_dotdot = fs32_to_cpu(sbi, dip->vdi_dotdot);\n\telse if (!VXFS_ISREG(vip) && !VXFS_ISLNK(vip))\n\t\tvip->vii_rdev = fs32_to_cpu(sbi, dip->vdi_rdev);\n\n\t \n\tmemcpy(&vip->vii_org, &dip->vdi_org, sizeof(vip->vii_org));\n\n\tinode->i_mode = vxfs_transmod(vip);\n\ti_uid_write(inode, (uid_t)vip->vii_uid);\n\ti_gid_write(inode, (gid_t)vip->vii_gid);\n\n\tset_nlink(inode, vip->vii_nlink);\n\tinode->i_size = vip->vii_size;\n\n\tinode->i_atime.tv_sec = vip->vii_atime;\n\tinode_set_ctime(inode, vip->vii_ctime, 0);\n\tinode->i_mtime.tv_sec = vip->vii_mtime;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\n\tinode->i_blocks = vip->vii_blocks;\n\tinode->i_generation = vip->vii_gen;\n}\n\n \nstruct inode *\nvxfs_blkiget(struct super_block *sbp, u_long extent, ino_t ino)\n{\n\tstruct buffer_head\t\t*bp;\n\tstruct inode\t\t\t*inode;\n\tu_long\t\t\t\tblock, offset;\n\n\tinode = new_inode(sbp);\n\tif (!inode)\n\t\treturn NULL;\n\tinode->i_ino = get_next_ino();\n\n\tblock = extent + ((ino * VXFS_ISIZE) / sbp->s_blocksize);\n\toffset = ((ino % (sbp->s_blocksize / VXFS_ISIZE)) * VXFS_ISIZE);\n\tbp = sb_bread(sbp, block);\n\n\tif (bp && buffer_mapped(bp)) {\n\t\tstruct vxfs_inode_info\t*vip = VXFS_INO(inode);\n\t\tstruct vxfs_dinode\t*dip;\n\n\t\tdip = (struct vxfs_dinode *)(bp->b_data + offset);\n\t\tdip2vip_cpy(VXFS_SBI(sbp), vip, dip);\n\t\tvip->vfs_inode.i_mapping->a_ops = &vxfs_aops;\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tbrelse(bp);\n\t\treturn inode;\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: unable to read block %ld\\n\", block);\n\tbrelse(bp);\n\tiput(inode);\n\treturn NULL;\n}\n\n \nstatic int\n__vxfs_iget(struct inode *ilistp, struct vxfs_inode_info *vip, ino_t ino)\n{\n\tstruct page\t\t\t*pp;\n\tu_long\t\t\t\toffset;\n\n\toffset = (ino % (PAGE_SIZE / VXFS_ISIZE)) * VXFS_ISIZE;\n\tpp = vxfs_get_page(ilistp->i_mapping, ino * VXFS_ISIZE / PAGE_SIZE);\n\n\tif (!IS_ERR(pp)) {\n\t\tstruct vxfs_dinode\t*dip;\n\t\tcaddr_t\t\t\tkaddr = (char *)page_address(pp);\n\n\t\tdip = (struct vxfs_dinode *)(kaddr + offset);\n\t\tdip2vip_cpy(VXFS_SBI(ilistp->i_sb), vip, dip);\n\t\tvip->vfs_inode.i_mapping->a_ops = &vxfs_aops;\n#ifdef DIAGNOSTIC\n\t\tvxfs_dumpi(vip, ino);\n#endif\n\t\tvxfs_put_page(pp);\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_WARNING \"vxfs: error on page 0x%p for inode %ld\\n\",\n\t\tpp, (unsigned long)ino);\n\treturn PTR_ERR(pp);\n}\n\n \nstruct inode *\nvxfs_stiget(struct super_block *sbp, ino_t ino)\n{\n\tstruct inode *inode;\n\tint error;\n\n\tinode = new_inode(sbp);\n\tif (!inode)\n\t\treturn NULL;\n\tinode->i_ino = get_next_ino();\n\n\terror = __vxfs_iget(VXFS_SBI(sbp)->vsi_stilist, VXFS_INO(inode), ino);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}\n\n \nstruct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\tint error;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = VXFS_INO(ip);\n\terror = __vxfs_iget(VXFS_SBI(sbp)->vsi_ilist, vip, ino);\n\tif (error) {\n\t\tiget_failed(ip);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tinode_nohighmem(ip);\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &simple_symlink_inode_operations;\n\t\t\tip->i_link = vip->vii_immed.vi_immed;\n\t\t\tnd_terminate_link(ip->i_link, ip->i_size,\n\t\t\t\t\t  sizeof(vip->vii_immed.vi_immed) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}\n\n \nvoid\nvxfs_evict_inode(struct inode *ip)\n{\n\ttruncate_inode_pages_final(&ip->i_data);\n\tclear_inode(ip);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}