{
  "module_name": "vxfs_lookup.c",
  "hash_id": "8d2f8af4811af3a32141f73730bf1bcf1673ef8d379bc932844eec6fcd113035",
  "original_prompt": "Ingested from linux-6.6.14/fs/freevxfs/vxfs_lookup.c",
  "human_readable_source": "\n \n\n \n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n\n#include \"vxfs.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_extern.h\"\n\n \n#define VXFS_BLOCK_PER_PAGE(sbp)  ((PAGE_SIZE / (sbp)->s_blocksize))\n\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int\t\tvxfs_readdir(struct file *, struct dir_context *);\n\nconst struct inode_operations vxfs_dir_inode_ops = {\n\t.lookup =\t\tvxfs_lookup,\n};\n\nconst struct file_operations vxfs_dir_operations = {\n\t.llseek =\t\tgeneric_file_llseek,\n\t.read =\t\t\tgeneric_read_dir,\n\t.iterate_shared =\tvxfs_readdir,\n};\n\n\n \nstatic struct vxfs_direct *\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\n{\n\tu_long bsize = ip->i_sb->s_blocksize;\n\tconst char *name = dp->d_name.name;\n\tint namelen = dp->d_name.len;\n\tloff_t limit = VXFS_DIRROUND(ip->i_size);\n\tstruct vxfs_direct *de_exit = NULL;\n\tloff_t pos = 0;\n\tstruct vxfs_sb_info *sbi = VXFS_SBI(ip->i_sb);\n\n\twhile (pos < limit) {\n\t\tstruct page *pp;\n\t\tchar *kaddr;\n\t\tint pg_ofs = pos & ~PAGE_MASK;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, pos >> PAGE_SHIFT);\n\t\tif (IS_ERR(pp))\n\t\t\treturn NULL;\n\t\tkaddr = (char *)page_address(pp);\n\n\t\twhile (pg_ofs < PAGE_SIZE && pos < limit) {\n\t\t\tstruct vxfs_direct *de;\n\n\t\t\tif ((pos & (bsize - 1)) < 4) {\n\t\t\t\tstruct vxfs_dirblk *dbp =\n\t\t\t\t\t(struct vxfs_dirblk *)\n\t\t\t\t\t (kaddr + (pos & ~PAGE_MASK));\n\t\t\t\tint overhead = VXFS_DIRBLKOV(sbi, dbp);\n\n\t\t\t\tpos += overhead;\n\t\t\t\tpg_ofs += overhead;\n\t\t\t}\n\t\t\tde = (struct vxfs_direct *)(kaddr + pg_ofs);\n\n\t\t\tif (!de->d_reclen) {\n\t\t\t\tpos += bsize - 1;\n\t\t\t\tpos &= ~(bsize - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpg_ofs += fs16_to_cpu(sbi, de->d_reclen);\n\t\t\tpos += fs16_to_cpu(sbi, de->d_reclen);\n\t\t\tif (!de->d_ino)\n\t\t\t\tcontinue;\n\n\t\t\tif (namelen != fs16_to_cpu(sbi, de->d_namelen))\n\t\t\t\tcontinue;\n\t\t\tif (!memcmp(name, de->d_name, namelen)) {\n\t\t\t\t*ppp = pp;\n\t\t\t\tde_exit = de;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!de_exit)\n\t\t\tvxfs_put_page(pp);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn de_exit;\n}\n\n \nstatic ino_t\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\n{\n\tstruct vxfs_direct\t\t*de;\n\tstruct page\t\t\t*pp;\n\tino_t\t\t\t\tino = 0;\n\n\tde = vxfs_find_entry(dip, dp, &pp);\n\tif (de) {\n\t\tino = fs32_to_cpu(VXFS_SBI(dip->i_sb), de->d_ino);\n\t\tkunmap(pp);\n\t\tput_page(pp);\n\t}\n\t\n\treturn (ino);\n}\n\n \nstatic struct dentry *\nvxfs_lookup(struct inode *dip, struct dentry *dp, unsigned int flags)\n{\n\tstruct inode\t\t*ip = NULL;\n\tino_t\t\t\tino;\n\t\t\t \n\tif (dp->d_name.len > VXFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t\t\t \n\tino = vxfs_inode_by_name(dip, dp);\n\tif (ino)\n\t\tip = vxfs_iget(dip->i_sb, ino);\n\treturn d_splice_alias(ip, dp);\n}\n\n \nstatic int\nvxfs_readdir(struct file *fp, struct dir_context *ctx)\n{\n\tstruct inode\t\t*ip = file_inode(fp);\n\tstruct super_block\t*sbp = ip->i_sb;\n\tu_long\t\t\tbsize = sbp->s_blocksize;\n\tloff_t\t\t\tpos, limit;\n\tstruct vxfs_sb_info\t*sbi = VXFS_SBI(sbp);\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(fp, ctx))\n\t\t\tgoto out;\n\t\tctx->pos++;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit(ctx, \"..\", 2, VXFS_INO(ip)->vii_dotdot, DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos++;\n\t}\n\n\tlimit = VXFS_DIRROUND(ip->i_size);\n\tif (ctx->pos > limit)\n\t\tgoto out;\n\n\tpos = ctx->pos & ~3L;\n\n\twhile (pos < limit) {\n\t\tstruct page *pp;\n\t\tchar *kaddr;\n\t\tint pg_ofs = pos & ~PAGE_MASK;\n\t\tint rc = 0;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, pos >> PAGE_SHIFT);\n\t\tif (IS_ERR(pp))\n\t\t\treturn -ENOMEM;\n\n\t\tkaddr = (char *)page_address(pp);\n\n\t\twhile (pg_ofs < PAGE_SIZE && pos < limit) {\n\t\t\tstruct vxfs_direct *de;\n\n\t\t\tif ((pos & (bsize - 1)) < 4) {\n\t\t\t\tstruct vxfs_dirblk *dbp =\n\t\t\t\t\t(struct vxfs_dirblk *)\n\t\t\t\t\t (kaddr + (pos & ~PAGE_MASK));\n\t\t\t\tint overhead = VXFS_DIRBLKOV(sbi, dbp);\n\n\t\t\t\tpos += overhead;\n\t\t\t\tpg_ofs += overhead;\n\t\t\t}\n\t\t\tde = (struct vxfs_direct *)(kaddr + pg_ofs);\n\n\t\t\tif (!de->d_reclen) {\n\t\t\t\tpos += bsize - 1;\n\t\t\t\tpos &= ~(bsize - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpg_ofs += fs16_to_cpu(sbi, de->d_reclen);\n\t\t\tpos += fs16_to_cpu(sbi, de->d_reclen);\n\t\t\tif (!de->d_ino)\n\t\t\t\tcontinue;\n\n\t\t\trc = dir_emit(ctx, de->d_name,\n\t\t\t\t\tfs16_to_cpu(sbi, de->d_namelen),\n\t\t\t\t\tfs32_to_cpu(sbi, de->d_ino),\n\t\t\t\t\tDT_UNKNOWN);\n\t\t\tif (!rc) {\n\t\t\t\t \n\t\t\t\tpos -= fs16_to_cpu(sbi, de->d_reclen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvxfs_put_page(pp);\n\t\tif (!rc)\n\t\t\tbreak;\n\t}\n\n\tctx->pos = pos | 2;\n\nout:\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}