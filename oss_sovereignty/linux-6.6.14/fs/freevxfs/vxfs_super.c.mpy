{
  "module_name": "vxfs_super.c",
  "hash_id": "534cac216d072597c165ea9a267c75788fd34b0883e0ab80d4617db4e62cc728",
  "original_prompt": "Ingested from linux-6.6.14/fs/freevxfs/vxfs_super.c",
  "human_readable_source": "\n \n\n \n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n\n#include \"vxfs.h\"\n#include \"vxfs_extern.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs_inode.h\"\n\n\nMODULE_AUTHOR(\"Christoph Hellwig, Krzysztof Blaszkowski\");\nMODULE_DESCRIPTION(\"Veritas Filesystem (VxFS) driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic struct kmem_cache *vxfs_inode_cachep;\n\n \n\nstatic void\nvxfs_put_super(struct super_block *sbp)\n{\n\tstruct vxfs_sb_info\t*infp = VXFS_SBI(sbp);\n\n\tiput(infp->vsi_fship);\n\tiput(infp->vsi_ilist);\n\tiput(infp->vsi_stilist);\n\n\tbrelse(infp->vsi_bp);\n\tkfree(infp);\n}\n\n \nstatic int\nvxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)\n{\n\tstruct vxfs_sb_info\t\t*infp = VXFS_SBI(dentry->d_sb);\n\tstruct vxfs_sb *raw_sb = infp->vsi_raw;\n\n\tbufp->f_type = VXFS_SUPER_MAGIC;\n\tbufp->f_bsize = dentry->d_sb->s_blocksize;\n\tbufp->f_blocks = fs32_to_cpu(infp, raw_sb->vs_dsize);\n\tbufp->f_bfree = fs32_to_cpu(infp, raw_sb->vs_free);\n\tbufp->f_bavail = 0;\n\tbufp->f_files = 0;\n\tbufp->f_ffree = fs32_to_cpu(infp, raw_sb->vs_ifree);\n\tbufp->f_namelen = VXFS_NAMELEN;\n\n\treturn 0;\n}\n\nstatic int vxfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_RDONLY;\n\treturn 0;\n}\n\nstatic struct inode *vxfs_alloc_inode(struct super_block *sb)\n{\n\tstruct vxfs_inode_info *vi;\n\n\tvi = alloc_inode_sb(sb, vxfs_inode_cachep, GFP_KERNEL);\n\tif (!vi)\n\t\treturn NULL;\n\tinode_init_once(&vi->vfs_inode);\n\treturn &vi->vfs_inode;\n}\n\nstatic void vxfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(vxfs_inode_cachep, VXFS_INO(inode));\n}\n\nstatic const struct super_operations vxfs_super_ops = {\n\t.alloc_inode\t\t= vxfs_alloc_inode,\n\t.free_inode\t\t= vxfs_free_inode,\n\t.evict_inode\t\t= vxfs_evict_inode,\n\t.put_super\t\t= vxfs_put_super,\n\t.statfs\t\t\t= vxfs_statfs,\n\t.remount_fs\t\t= vxfs_remount,\n};\n\nstatic int vxfs_try_sb_magic(struct super_block *sbp, int silent,\n\t\tunsigned blk, __fs32 magic)\n{\n\tstruct buffer_head *bp;\n\tstruct vxfs_sb *rsbp;\n\tstruct vxfs_sb_info *infp = VXFS_SBI(sbp);\n\tint rc = -ENOMEM;\n\n\tbp = sb_bread(sbp, blk);\n\tdo {\n\t\tif (!bp || !buffer_mapped(bp)) {\n\t\t\tif (!silent) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"vxfs: unable to read disk superblock at %u\\n\",\n\t\t\t\t\tblk);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\trc = -EINVAL;\n\t\trsbp = (struct vxfs_sb *)bp->b_data;\n\t\tif (rsbp->vs_magic != magic) {\n\t\t\tif (!silent)\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\t\"vxfs: WRONG superblock magic %08x at %u\\n\",\n\t\t\t\t\trsbp->vs_magic, blk);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = 0;\n\t\tinfp->vsi_raw = rsbp;\n\t\tinfp->vsi_bp = bp;\n\t} while (0);\n\n\tif (rc) {\n\t\tinfp->vsi_raw = NULL;\n\t\tinfp->vsi_bp = NULL;\n\t\tbrelse(bp);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int vxfs_fill_super(struct super_block *sbp, void *dp, int silent)\n{\n\tstruct vxfs_sb_info\t*infp;\n\tstruct vxfs_sb\t\t*rsbp;\n\tu_long\t\t\tbsize;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\tu32 j;\n\n\tsbp->s_flags |= SB_RDONLY;\n\n\tinfp = kzalloc(sizeof(*infp), GFP_KERNEL);\n\tif (!infp) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to allocate incore superblock\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbsize = sb_min_blocksize(sbp, BLOCK_SIZE);\n\tif (!bsize) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set blocksize\\n\");\n\t\tgoto out;\n\t}\n\n\tsbp->s_op = &vxfs_super_ops;\n\tsbp->s_fs_info = infp;\n\tsbp->s_time_min = 0;\n\tsbp->s_time_max = U32_MAX;\n\n\tif (!vxfs_try_sb_magic(sbp, silent, 1,\n\t\t\t(__force __fs32)cpu_to_le32(VXFS_SUPER_MAGIC))) {\n\t\t \n\t\tinfp->byte_order = VXFS_BO_LE;\n\t} else if (!vxfs_try_sb_magic(sbp, silent, 8,\n\t\t\t(__force __fs32)cpu_to_be32(VXFS_SUPER_MAGIC))) {\n\t\t \n\t\tinfp->byte_order = VXFS_BO_BE;\n\t} else {\n\t\tif (!silent)\n\t\t\tprintk(KERN_NOTICE \"vxfs: can't find superblock.\\n\");\n\t\tgoto out;\n\t}\n\n\trsbp = infp->vsi_raw;\n\tj = fs32_to_cpu(infp, rsbp->vs_version);\n\tif ((j < 2 || j > 4) && !silent) {\n\t\tprintk(KERN_NOTICE \"vxfs: unsupported VxFS version (%d)\\n\", j);\n\t\tgoto out;\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintk(KERN_DEBUG \"vxfs: supported VxFS version (%d)\\n\", j);\n\tprintk(KERN_DEBUG \"vxfs: blocksize: %d\\n\",\n\t\tfs32_to_cpu(infp, rsbp->vs_bsize));\n#endif\n\n\tsbp->s_magic = fs32_to_cpu(infp, rsbp->vs_magic);\n\n\tinfp->vsi_oltext = fs32_to_cpu(infp, rsbp->vs_oltext[0]);\n\tinfp->vsi_oltsize = fs32_to_cpu(infp, rsbp->vs_oltsize);\n\n\tj = fs32_to_cpu(infp, rsbp->vs_bsize);\n\tif (!sb_set_blocksize(sbp, j)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to set final block size\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_olt(sbp, bsize)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read olt\\n\");\n\t\tgoto out;\n\t}\n\n\tif (vxfs_read_fshead(sbp)) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to read fshead\\n\");\n\t\tgoto out;\n\t}\n\n\troot = vxfs_iget(sbp, VXFS_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\tsbp->s_root = d_make_root(root);\n\tif (!sbp->s_root) {\n\t\tprintk(KERN_WARNING \"vxfs: unable to get root dentry.\\n\");\n\t\tgoto out_free_ilist;\n\t}\n\n\treturn 0;\n\t\nout_free_ilist:\n\tiput(infp->vsi_fship);\n\tiput(infp->vsi_ilist);\n\tiput(infp->vsi_stilist);\nout:\n\tbrelse(infp->vsi_bp);\n\tkfree(infp);\n\treturn ret;\n}\n\n \nstatic struct dentry *vxfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, vxfs_fill_super);\n}\n\nstatic struct file_system_type vxfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vxfs\",\n\t.mount\t\t= vxfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"vxfs\");  \nMODULE_ALIAS(\"vxfs\");\n\nstatic int __init\nvxfs_init(void)\n{\n\tint rv;\n\n\tvxfs_inode_cachep = kmem_cache_create_usercopy(\"vxfs_inode\",\n\t\t\tsizeof(struct vxfs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\toffsetof(struct vxfs_inode_info, vii_immed.vi_immed),\n\t\t\tsizeof_field(struct vxfs_inode_info,\n\t\t\t\tvii_immed.vi_immed),\n\t\t\tNULL);\n\tif (!vxfs_inode_cachep)\n\t\treturn -ENOMEM;\n\trv = register_filesystem(&vxfs_fs_type);\n\tif (rv < 0)\n\t\tkmem_cache_destroy(vxfs_inode_cachep);\n\treturn rv;\n}\n\nstatic void __exit\nvxfs_cleanup(void)\n{\n\tunregister_filesystem(&vxfs_fs_type);\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(vxfs_inode_cachep);\n}\n\nmodule_init(vxfs_init);\nmodule_exit(vxfs_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}