{
  "module_name": "clntxdr.c",
  "hash_id": "f7609a173d1fa8f9800bf35078f86a581c97da91fc0ff421865a7d3db605dba4",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/clntxdr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/lockd/lockd.h>\n\n#include <uapi/linux/nfs2.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_XDR\n\n#if (NLMCLNT_OHSIZE > XDR_MAX_NETOBJ)\n#  error \"NLM host name cannot be larger than XDR_MAX_NETOBJ!\"\n#endif\n\n \n#define NLM_cookie_sz\t\t(1+(NLM_MAXCOOKIELEN>>2))\n#define NLM_caller_sz\t\t(1+(NLMCLNT_OHSIZE>>2))\n#define NLM_owner_sz\t\t(1+(NLMCLNT_OHSIZE>>2))\n#define NLM_fhandle_sz\t\t(1+(NFS2_FHSIZE>>2))\n#define NLM_lock_sz\t\t(3+NLM_caller_sz+NLM_owner_sz+NLM_fhandle_sz)\n#define NLM_holder_sz\t\t(4+NLM_owner_sz)\n\n#define NLM_testargs_sz\t\t(NLM_cookie_sz+1+NLM_lock_sz)\n#define NLM_lockargs_sz\t\t(NLM_cookie_sz+4+NLM_lock_sz)\n#define NLM_cancargs_sz\t\t(NLM_cookie_sz+2+NLM_lock_sz)\n#define NLM_unlockargs_sz\t(NLM_cookie_sz+NLM_lock_sz)\n\n#define NLM_testres_sz\t\t(NLM_cookie_sz+1+NLM_holder_sz)\n#define NLM_res_sz\t\t(NLM_cookie_sz+1)\n#define NLM_norep_sz\t\t(0)\n\n\nstatic s32 loff_t_to_s32(loff_t offset)\n{\n\ts32 res;\n\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}\n\nstatic void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}\n\n \n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}\n\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}\n\n \nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}\n\nstatic int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, (void *)&obj->data,\n\t\t\tXDR_MAX_NETOBJ);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\tobj->len = ret;\n\treturn 0;\n}\n\n \nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}\n\nstatic int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t \n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\n}\n\n \n\nstatic void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}\n\nstatic int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_nlm_holder(struct xdr_stream *xdr,\n\t\t\t      const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}\n\nstatic int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu32 exclusive, l_offset, l_len;\n\tint error;\n\t__be32 *p;\n\ts32 end;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tl_offset = be32_to_cpup(p++);\n\tl_len = be32_to_cpup(p);\n\tend = l_offset + l_len - 1;\n\n\tfl->fl_start = (loff_t)l_offset;\n\tif (l_len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = (loff_t)end;\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t \n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}\n\n \nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}\n\n\n \n\n \nstatic void nlm_xdr_enc_testargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}\n\n \nstatic void nlm_xdr_enc_lockargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n\tencode_bool(xdr, args->reclaim);\n\tencode_int32(xdr, args->state);\n}\n\n \nstatic void nlm_xdr_enc_cancargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}\n\n \nstatic void nlm_xdr_enc_unlockargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_nlm_lock(xdr, lock);\n}\n\n \nstatic void nlm_xdr_enc_res(struct rpc_rqst *req,\n\t\t\t    struct xdr_stream *xdr,\n\t\t\t    const void *data)\n{\n\tconst struct nlm_res *result = data;\n\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n}\n\n \nstatic void encode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm_holder(xdr, result);\n}\n\nstatic void nlm_xdr_enc_testres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst void *data)\n{\n\tconst struct nlm_res *result = data;\n\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n\tencode_nlm_testrply(xdr, result);\n}\n\n\n \n\n \nstatic int decode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm_holder(xdr, result);\nout:\n\treturn error;\n}\n\nstatic int nlm_xdr_dec_testres(struct rpc_rqst *req,\n\t\t\t       struct xdr_stream *xdr,\n\t\t\t       void *data)\n{\n\tstruct nlm_res *result = data;\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_testrply(xdr, result);\nout:\n\treturn error;\n}\n\n \nstatic int nlm_xdr_dec_res(struct rpc_rqst *req,\n\t\t\t   struct xdr_stream *xdr,\n\t\t\t   void *data)\n{\n\tstruct nlm_res *result = data;\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_stat(xdr, &result->status);\nout:\n\treturn error;\n}\n\n\n \n#define nlm_xdr_dec_norep\tNULL\n\n#define PROC(proc, argtype, restype)\t\\\n[NLMPROC_##proc] = {\t\t\t\t\t\t\t\\\n\t.p_proc      = NLMPROC_##proc,\t\t\t\t\t\\\n\t.p_encode    = nlm_xdr_enc_##argtype,\t\t\\\n\t.p_decode    = nlm_xdr_dec_##restype,\t\t\t\t\\\n\t.p_arglen    = NLM_##argtype##_sz,\t\t\t\t\\\n\t.p_replen    = NLM_##restype##_sz,\t\t\t\t\\\n\t.p_statidx   = NLMPROC_##proc,\t\t\t\t\t\\\n\t.p_name      = #proc,\t\t\t\t\t\t\\\n\t}\n\nstatic const struct rpc_procinfo nlm_procedures[] = {\n\tPROC(TEST,\t\ttestargs,\ttestres),\n\tPROC(LOCK,\t\tlockargs,\tres),\n\tPROC(CANCEL,\t\tcancargs,\tres),\n\tPROC(UNLOCK,\t\tunlockargs,\tres),\n\tPROC(GRANTED,\t\ttestargs,\tres),\n\tPROC(TEST_MSG,\t\ttestargs,\tnorep),\n\tPROC(LOCK_MSG,\t\tlockargs,\tnorep),\n\tPROC(CANCEL_MSG,\tcancargs,\tnorep),\n\tPROC(UNLOCK_MSG,\tunlockargs,\tnorep),\n\tPROC(GRANTED_MSG,\ttestargs,\tnorep),\n\tPROC(TEST_RES,\t\ttestres,\tnorep),\n\tPROC(LOCK_RES,\t\tres,\t\tnorep),\n\tPROC(CANCEL_RES,\tres,\t\tnorep),\n\tPROC(UNLOCK_RES,\tres,\t\tnorep),\n\tPROC(GRANTED_RES,\tres,\t\tnorep),\n};\n\nstatic unsigned int nlm_version1_counts[ARRAY_SIZE(nlm_procedures)];\nstatic const struct rpc_version\tnlm_version1 = {\n\t.number\t\t= 1,\n\t.nrprocs\t= ARRAY_SIZE(nlm_procedures),\n\t.procs\t\t= nlm_procedures,\n\t.counts\t\t= nlm_version1_counts,\n};\n\nstatic unsigned int nlm_version3_counts[ARRAY_SIZE(nlm_procedures)];\nstatic const struct rpc_version\tnlm_version3 = {\n\t.number\t\t= 3,\n\t.nrprocs\t= ARRAY_SIZE(nlm_procedures),\n\t.procs\t\t= nlm_procedures,\n\t.counts\t\t= nlm_version3_counts,\n};\n\nstatic const struct rpc_version\t*nlm_versions[] = {\n\t[1] = &nlm_version1,\n\t[3] = &nlm_version3,\n#ifdef CONFIG_LOCKD_V4\n\t[4] = &nlm_version4,\n#endif\n};\n\nstatic struct rpc_stat\t\tnlm_rpc_stats;\n\nconst struct rpc_program\tnlm_program = {\n\t.name\t\t= \"lockd\",\n\t.number\t\t= NLM_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(nlm_versions),\n\t.version\t= nlm_versions,\n\t.stats\t\t= &nlm_rpc_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}