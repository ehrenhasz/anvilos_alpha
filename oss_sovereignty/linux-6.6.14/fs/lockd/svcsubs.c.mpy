{
  "module_name": "svcsubs.c",
  "hash_id": "802e830950502b5992bb3646f5135d1639b5dd3797e8d1a8187d12c307bebd10",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svcsubs.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/share.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <uapi/linux/nfs2.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_SVCSUBS\n\n\n \n#define FILE_HASH_BITS\t\t7\n#define FILE_NRHASH\t\t(1<<FILE_HASH_BITS)\nstatic struct hlist_head\tnlm_files[FILE_NRHASH];\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\n#ifdef CONFIG_SUNRPC_DEBUG\nstatic inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)\n{\n\tu32 *fhp = (u32*)f->data;\n\n\t \n\tdprintk(\"lockd: %s (%08x %08x %08x %08x %08x %08x %08x %08x)\\n\",\n\t\tmsg, fhp[0], fhp[1], fhp[2], fhp[3],\n\t\tfhp[4], fhp[5], fhp[6], fhp[7]);\n}\n\nstatic inline void nlm_debug_print_file(char *msg, struct nlm_file *file)\n{\n\tstruct inode *inode = nlmsvc_file_inode(file);\n\n\tdprintk(\"lockd: %s %s/%ld\\n\",\n\t\tmsg, inode->i_sb->s_id, inode->i_ino);\n}\n#else\nstatic inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)\n{\n\treturn;\n}\n\nstatic inline void nlm_debug_print_file(char *msg, struct nlm_file *file)\n{\n\treturn;\n}\n#endif\n\nstatic inline unsigned int file_hash(struct nfs_fh *f)\n{\n\tunsigned int tmp=0;\n\tint i;\n\tfor (i=0; i<NFS2_FHSIZE;i++)\n\t\ttmp += f->data[i];\n\treturn tmp & (FILE_NRHASH - 1);\n}\n\nint lock_to_openmode(struct file_lock *lock)\n{\n\treturn (lock->fl_type == F_WRLCK) ? O_WRONLY : O_RDONLY;\n}\n\n \nstatic __be32 nlm_do_fopen(struct svc_rqst *rqstp,\n\t\t\t   struct nlm_file *file, int mode)\n{\n\tstruct file **fp = &file->f_file[mode];\n\t__be32\tnfserr;\n\n\tif (*fp)\n\t\treturn 0;\n\tnfserr = nlmsvc_ops->fopen(rqstp, &file->f_handle, fp, mode);\n\tif (nfserr)\n\t\tdprintk(\"lockd: open failed (error %d)\\n\", nfserr);\n\treturn nfserr;\n}\n\n \n__be32\nnlm_lookup_file(struct svc_rqst *rqstp, struct nlm_file **result,\n\t\t\t\t\tstruct nlm_lock *lock)\n{\n\tstruct nlm_file\t*file;\n\tunsigned int\thash;\n\t__be32\t\tnfserr;\n\tint\t\tmode;\n\n\tnlm_debug_print_fh(\"nlm_lookup_file\", &lock->fh);\n\n\thash = file_hash(&lock->fh);\n\tmode = lock_to_openmode(&lock->fl);\n\n\t \n\tmutex_lock(&nlm_file_mutex);\n\n\thlist_for_each_entry(file, &nlm_files[hash], f_list)\n\t\tif (!nfs_compare_fh(&file->f_handle, &lock->fh)) {\n\t\t\tmutex_lock(&file->f_mutex);\n\t\t\tnfserr = nlm_do_fopen(rqstp, file, mode);\n\t\t\tmutex_unlock(&file->f_mutex);\n\t\t\tgoto found;\n\t\t}\n\tnlm_debug_print_fh(\"creating file for\", &lock->fh);\n\n\tnfserr = nlm_lck_denied_nolocks;\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file)\n\t\tgoto out_free;\n\n\tmemcpy(&file->f_handle, &lock->fh, sizeof(struct nfs_fh));\n\tmutex_init(&file->f_mutex);\n\tINIT_HLIST_NODE(&file->f_list);\n\tINIT_LIST_HEAD(&file->f_blocks);\n\n\tnfserr = nlm_do_fopen(rqstp, file, mode);\n\tif (nfserr)\n\t\tgoto out_unlock;\n\n\thlist_add_head(&file->f_list, &nlm_files[hash]);\n\nfound:\n\tdprintk(\"lockd: found file %p (count %d)\\n\", file, file->f_count);\n\t*result = file;\n\tfile->f_count++;\n\nout_unlock:\n\tmutex_unlock(&nlm_file_mutex);\n\treturn nfserr;\n\nout_free:\n\tkfree(file);\n\tgoto out_unlock;\n}\n\n \nstatic inline void\nnlm_delete_file(struct nlm_file *file)\n{\n\tnlm_debug_print_file(\"closing file\", file);\n\tif (!hlist_unhashed(&file->f_list)) {\n\t\thlist_del(&file->f_list);\n\t\tif (file->f_file[O_RDONLY])\n\t\t\tnlmsvc_ops->fclose(file->f_file[O_RDONLY]);\n\t\tif (file->f_file[O_WRONLY])\n\t\t\tnlmsvc_ops->fclose(file->f_file[O_WRONLY]);\n\t\tkfree(file);\n\t} else {\n\t\tprintk(KERN_WARNING \"lockd: attempt to release unknown file!\\n\");\n\t}\n}\n\nstatic int nlm_unlock_files(struct nlm_file *file, const struct file_lock *fl)\n{\n\tstruct file_lock lock;\n\n\tlocks_init_lock(&lock);\n\tlock.fl_type  = F_UNLCK;\n\tlock.fl_start = 0;\n\tlock.fl_end   = OFFSET_MAX;\n\tlock.fl_owner = fl->fl_owner;\n\tlock.fl_pid   = fl->fl_pid;\n\tlock.fl_flags = FL_POSIX;\n\n\tlock.fl_file = file->f_file[O_RDONLY];\n\tif (lock.fl_file && vfs_lock_file(lock.fl_file, F_SETLK, &lock, NULL))\n\t\tgoto out_err;\n\tlock.fl_file = file->f_file[O_WRONLY];\n\tif (lock.fl_file && vfs_lock_file(lock.fl_file, F_SETLK, &lock, NULL))\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tpr_warn(\"lockd: unlock failure in %s:%d\\n\", __FILE__, __LINE__);\n\treturn 1;\n}\n\n \nstatic int\nnlm_traverse_locks(struct nlm_host *host, struct nlm_file *file,\n\t\t\tnlm_host_match_fn_t match)\n{\n\tstruct inode\t *inode = nlmsvc_file_inode(file);\n\tstruct file_lock *fl;\n\tstruct file_lock_context *flctx = locks_inode_context(inode);\n\tstruct nlm_host\t *lockhost;\n\n\tif (!flctx || list_empty_careful(&flctx->flc_posix))\n\t\treturn 0;\nagain:\n\tfile->f_locks = 0;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\tif (fl->fl_lmops != &nlmsvc_lock_operations)\n\t\t\tcontinue;\n\n\t\t \n\t\tfile->f_locks++;\n\n\t\tlockhost = ((struct nlm_lockowner *)fl->fl_owner)->host;\n\t\tif (match(lockhost, host)) {\n\n\t\t\tspin_unlock(&flctx->flc_lock);\n\t\t\tif (nlm_unlock_files(file, fl))\n\t\t\t\treturn 1;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\treturn 0;\n}\n\nstatic int\nnlmsvc_always_match(void *dummy1, struct nlm_host *dummy2)\n{\n\treturn 1;\n}\n\n \nstatic inline int\nnlm_inspect_file(struct nlm_host *host, struct nlm_file *file, nlm_host_match_fn_t match)\n{\n\tnlmsvc_traverse_blocks(host, file, match);\n\tnlmsvc_traverse_shares(host, file, match);\n\treturn nlm_traverse_locks(host, file, match);\n}\n\n \nstatic inline int\nnlm_file_inuse(struct nlm_file *file)\n{\n\tstruct inode\t *inode = nlmsvc_file_inode(file);\n\tstruct file_lock *fl;\n\tstruct file_lock_context *flctx = locks_inode_context(inode);\n\n\tif (file->f_count || !list_empty(&file->f_blocks) || file->f_shares)\n\t\treturn 1;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_lmops == &nlmsvc_lock_operations) {\n\t\t\t\tspin_unlock(&flctx->flc_lock);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfile->f_locks = 0;\n\treturn 0;\n}\n\nstatic void nlm_close_files(struct nlm_file *file)\n{\n\tif (file->f_file[O_RDONLY])\n\t\tnlmsvc_ops->fclose(file->f_file[O_RDONLY]);\n\tif (file->f_file[O_WRONLY])\n\t\tnlmsvc_ops->fclose(file->f_file[O_WRONLY]);\n}\n\n \nstatic int\nnlm_traverse_files(void *data, nlm_host_match_fn_t match,\n\t\tint (*is_failover_file)(void *data, struct nlm_file *file))\n{\n\tstruct hlist_node *next;\n\tstruct nlm_file\t*file;\n\tint i, ret = 0;\n\n\tmutex_lock(&nlm_file_mutex);\n\tfor (i = 0; i < FILE_NRHASH; i++) {\n\t\thlist_for_each_entry_safe(file, next, &nlm_files[i], f_list) {\n\t\t\tif (is_failover_file && !is_failover_file(data, file))\n\t\t\t\tcontinue;\n\t\t\tfile->f_count++;\n\t\t\tmutex_unlock(&nlm_file_mutex);\n\n\t\t\t \n\t\t\tif (nlm_inspect_file(data, file, match))\n\t\t\t\tret = 1;\n\n\t\t\tmutex_lock(&nlm_file_mutex);\n\t\t\tfile->f_count--;\n\t\t\t \n\t\t\tif (list_empty(&file->f_blocks) && !file->f_locks\n\t\t\t && !file->f_shares && !file->f_count) {\n\t\t\t\thlist_del(&file->f_list);\n\t\t\t\tnlm_close_files(file);\n\t\t\t\tkfree(file);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&nlm_file_mutex);\n\treturn ret;\n}\n\n \nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t \n\tmutex_lock(&nlm_file_mutex);\n\n\t \n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}\n\n \n\nstatic int\nnlmsvc_mark_host(void *data, struct nlm_host *hint)\n{\n\tstruct nlm_host *host = data;\n\n\tif ((hint->net == NULL) ||\n\t    (host->net == hint->net))\n\t\thost->h_inuse = 1;\n\treturn 0;\n}\n\nstatic int\nnlmsvc_same_host(void *data, struct nlm_host *other)\n{\n\tstruct nlm_host *host = data;\n\n\treturn host == other;\n}\n\nstatic int\nnlmsvc_is_client(void *data, struct nlm_host *dummy)\n{\n\tstruct nlm_host *host = data;\n\n\tif (host->h_server) {\n\t\t \n\t\tif (host->h_nsmhandle)\n\t\t\thost->h_nsmhandle->sm_sticky = 1;\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\n \nvoid\nnlmsvc_mark_resources(struct net *net)\n{\n\tstruct nlm_host hint;\n\n\tdprintk(\"lockd: %s for net %x\\n\", __func__, net ? net->ns.inum : 0);\n\thint.net = net;\n\tnlm_traverse_files(&hint, nlmsvc_mark_host, NULL);\n}\n\n \nvoid\nnlmsvc_free_host_resources(struct nlm_host *host)\n{\n\tdprintk(\"lockd: nlmsvc_free_host_resources\\n\");\n\n\tif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd: couldn't remove all locks held by %s\\n\",\n\t\t\thost->h_name);\n\t\tBUG();\n\t}\n}\n\n \nvoid\nnlmsvc_invalidate_all(void)\n{\n\t \n\tnlm_traverse_files(NULL, nlmsvc_is_client, NULL);\n}\n\n\nstatic int\nnlmsvc_match_sb(void *datap, struct nlm_file *file)\n{\n\tstruct super_block *sb = datap;\n\n\treturn sb == nlmsvc_file_inode(file)->i_sb;\n}\n\n \nint\nnlmsvc_unlock_all_by_sb(struct super_block *sb)\n{\n\tint ret;\n\n\tret = nlm_traverse_files(sb, nlmsvc_always_match, nlmsvc_match_sb);\n\treturn ret ? -EIO : 0;\n}\nEXPORT_SYMBOL_GPL(nlmsvc_unlock_all_by_sb);\n\nstatic int\nnlmsvc_match_ip(void *datap, struct nlm_host *host)\n{\n\treturn rpc_cmp_addr(nlm_srcaddr(host), datap);\n}\n\n \nint\nnlmsvc_unlock_all_by_ip(struct sockaddr *server_addr)\n{\n\tint ret;\n\n\tret = nlm_traverse_files(server_addr, nlmsvc_match_ip, NULL);\n\treturn ret ? -EIO : 0;\n}\nEXPORT_SYMBOL_GPL(nlmsvc_unlock_all_by_ip);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}