{
  "module_name": "svc.c",
  "hash_id": "03f9563237d12a88ae69b63911db2d896272158801a828c9ef82cbd2b3b1baa9",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/moduleparam.h>\n\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/uio.h>\n#include <linux/smp.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/inetdevice.h>\n\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <net/ip.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <linux/lockd/lockd.h>\n#include <linux/nfs.h>\n\n#include \"netns.h\"\n#include \"procfs.h\"\n\n#define NLMDBG_FACILITY\t\tNLMDBG_SVC\n#define LOCKD_BUFSIZE\t\t(1024 + NLMSVC_XDRSIZE)\n\nstatic struct svc_program\tnlmsvc_program;\n\nconst struct nlmsvc_binding\t*nlmsvc_ops;\nEXPORT_SYMBOL_GPL(nlmsvc_ops);\n\nstatic DEFINE_MUTEX(nlmsvc_mutex);\nstatic unsigned int\t\tnlmsvc_users;\nstatic struct svc_serv\t\t*nlmsvc_serv;\nunsigned long\t\t\tnlmsvc_timeout;\n\nstatic void nlmsvc_request_retry(struct timer_list *tl)\n{\n\tsvc_wake_up(nlmsvc_serv);\n}\nDEFINE_TIMER(nlmsvc_retry, nlmsvc_request_retry);\n\nunsigned int lockd_net_id;\n\n \nstatic unsigned long\t\tnlm_grace_period;\nstatic unsigned long\t\tnlm_timeout = LOCKD_DFLT_TIMEO;\nstatic int\t\t\tnlm_udpport, nlm_tcpport;\n\n \nstatic unsigned int\t\tnlm_max_connections = 1024;\n\n \nstatic const unsigned long\tnlm_grace_period_min = 0;\nstatic const unsigned long\tnlm_grace_period_max = 240;\nstatic const unsigned long\tnlm_timeout_min = 3;\nstatic const unsigned long\tnlm_timeout_max = 20;\n\n#ifdef CONFIG_SYSCTL\nstatic const int\t\tnlm_port_min = 0, nlm_port_max = 65535;\nstatic struct ctl_table_header * nlm_sysctl_table;\n#endif\n\nstatic unsigned long get_lockd_grace_period(void)\n{\n\t \n\tif (nlm_grace_period)\n\t\treturn roundup(nlm_grace_period, nlm_timeout) * HZ;\n\telse\n\t\treturn nlm_timeout * 5 * HZ;\n}\n\nstatic void grace_ender(struct work_struct *grace)\n{\n\tstruct delayed_work *dwork = to_delayed_work(grace);\n\tstruct lockd_net *ln = container_of(dwork, struct lockd_net,\n\t\t\t\t\t    grace_period_end);\n\n\tlocks_end_grace(&ln->lockd_manager);\n}\n\nstatic void set_grace_period(struct net *net)\n{\n\tunsigned long grace_period = get_lockd_grace_period();\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tlocks_start_grace(net, &ln->lockd_manager);\n\tcancel_delayed_work_sync(&ln->grace_period_end);\n\tschedule_delayed_work(&ln->grace_period_end, grace_period);\n}\n\n \nstatic int\nlockd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = vrqstp;\n\tstruct net *net = &init_net;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t \n\tset_freezable();\n\n\tdprintk(\"NFS locking service started (ver \" LOCKD_VERSION \").\\n\");\n\n\t \n\twhile (!kthread_should_stop()) {\n\t\t \n\t\trqstp->rq_server->sv_maxconn = nlm_max_connections;\n\n\t\tnlmsvc_retry_blocked();\n\t\tsvc_recv(rqstp);\n\t}\n\tif (nlmsvc_ops)\n\t\tnlmsvc_invalidate_all();\n\tnlm_shutdown_hosts();\n\tcancel_delayed_work_sync(&ln->grace_period_end);\n\tlocks_end_grace(&ln->lockd_manager);\n\n\tdprintk(\"lockd_down: service stopped\\n\");\n\n\tsvc_exit_thread(rqstp);\n\treturn 0;\n}\n\nstatic int create_lockd_listener(struct svc_serv *serv, const char *name,\n\t\t\t\t struct net *net, const int family,\n\t\t\t\t const unsigned short port,\n\t\t\t\t const struct cred *cred)\n{\n\tstruct svc_xprt *xprt;\n\n\txprt = svc_find_xprt(serv, name, net, family, 0);\n\tif (xprt == NULL)\n\t\treturn svc_xprt_create(serv, name, net, family, port,\n\t\t\t\t       SVC_SOCK_DEFAULTS, cred);\n\tsvc_xprt_put(xprt);\n\treturn 0;\n}\n\nstatic int create_lockd_family(struct svc_serv *serv, struct net *net,\n\t\t\t       const int family, const struct cred *cred)\n{\n\tint err;\n\n\terr = create_lockd_listener(serv, \"udp\", net, family, nlm_udpport,\n\t\t\tcred);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn create_lockd_listener(serv, \"tcp\", net, family, nlm_tcpport,\n\t\t\tcred);\n}\n\n \nstatic int make_socks(struct svc_serv *serv, struct net *net,\n\t\tconst struct cred *cred)\n{\n\tstatic int warned;\n\tint err;\n\n\terr = create_lockd_family(serv, net, PF_INET, cred);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = create_lockd_family(serv, net, PF_INET6, cred);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_err;\n\n\twarned = 0;\n\treturn 0;\n\nout_err:\n\tif (warned++ == 0)\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd_up: makesock failed, error=%d\\n\", err);\n\tsvc_xprt_destroy_all(serv, net);\n\tsvc_rpcb_cleanup(serv, net);\n\treturn err;\n}\n\nstatic int lockd_up_net(struct svc_serv *serv, struct net *net,\n\t\tconst struct cred *cred)\n{\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\tint error;\n\n\tif (ln->nlmsvc_users++)\n\t\treturn 0;\n\n\terror = svc_bind(serv, net);\n\tif (error)\n\t\tgoto err_bind;\n\n\terror = make_socks(serv, net, cred);\n\tif (error < 0)\n\t\tgoto err_bind;\n\tset_grace_period(net);\n\tdprintk(\"%s: per-net data created; net=%x\\n\", __func__, net->ns.inum);\n\treturn 0;\n\nerr_bind:\n\tln->nlmsvc_users--;\n\treturn error;\n}\n\nstatic void lockd_down_net(struct svc_serv *serv, struct net *net)\n{\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tif (ln->nlmsvc_users) {\n\t\tif (--ln->nlmsvc_users == 0) {\n\t\t\tnlm_shutdown_hosts_net(net);\n\t\t\tcancel_delayed_work_sync(&ln->grace_period_end);\n\t\t\tlocks_end_grace(&ln->lockd_manager);\n\t\t\tsvc_xprt_destroy_all(serv, net);\n\t\t\tsvc_rpcb_cleanup(serv, net);\n\t\t}\n\t} else {\n\t\tpr_err(\"%s: no users! net=%x\\n\",\n\t\t\t__func__, net->ns.inum);\n\t\tBUG();\n\t}\n}\n\nstatic int lockd_inetaddr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nlmsvc_serv) {\n\t\tdprintk(\"lockd_inetaddr_event: removed %pI4\\n\",\n\t\t\t&ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nlmsvc_serv, (struct sockaddr *)&sin);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block lockd_inetaddr_notifier = {\n\t.notifier_call = lockd_inetaddr_event,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int lockd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nlmsvc_serv) {\n\t\tdprintk(\"lockd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tif (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tsin6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\tsvc_age_temp_xprts_now(nlmsvc_serv, (struct sockaddr *)&sin6);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block lockd_inet6addr_notifier = {\n\t.notifier_call = lockd_inet6addr_event,\n};\n#endif\n\nstatic int lockd_get(void)\n{\n\tstruct svc_serv *serv;\n\tint error;\n\n\tif (nlmsvc_serv) {\n\t\tnlmsvc_users++;\n\t\treturn 0;\n\t}\n\n\t \n\tif (nlmsvc_users)\n\t\tprintk(KERN_WARNING\n\t\t\t\"lockd_up: no pid, %d users??\\n\", nlmsvc_users);\n\n\tif (!nlm_timeout)\n\t\tnlm_timeout = LOCKD_DFLT_TIMEO;\n\tnlmsvc_timeout = nlm_timeout * HZ;\n\n\tserv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, lockd);\n\tif (!serv) {\n\t\tprintk(KERN_WARNING \"lockd_up: create service failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tserv->sv_maxconn = nlm_max_connections;\n\terror = svc_set_num_threads(serv, NULL, 1);\n\t \n\tsvc_put(serv);\n\tif (error < 0)\n\t\treturn error;\n\n\tnlmsvc_serv = serv;\n\tregister_inetaddr_notifier(&lockd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&lockd_inet6addr_notifier);\n#endif\n\tdprintk(\"lockd_up: service created\\n\");\n\tnlmsvc_users++;\n\treturn 0;\n}\n\nstatic void lockd_put(void)\n{\n\tif (WARN(nlmsvc_users <= 0, \"lockd_down: no users!\\n\"))\n\t\treturn;\n\tif (--nlmsvc_users)\n\t\treturn;\n\n\tunregister_inetaddr_notifier(&lockd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&lockd_inet6addr_notifier);\n#endif\n\n\tsvc_set_num_threads(nlmsvc_serv, NULL, 0);\n\ttimer_delete_sync(&nlmsvc_retry);\n\tnlmsvc_serv = NULL;\n\tdprintk(\"lockd_down: service destroyed\\n\");\n}\n\n \nint lockd_up(struct net *net, const struct cred *cred)\n{\n\tint error;\n\n\tmutex_lock(&nlmsvc_mutex);\n\n\terror = lockd_get();\n\tif (error)\n\t\tgoto err;\n\n\terror = lockd_up_net(nlmsvc_serv, net, cred);\n\tif (error < 0) {\n\t\tlockd_put();\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&nlmsvc_mutex);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(lockd_up);\n\n \nvoid\nlockd_down(struct net *net)\n{\n\tmutex_lock(&nlmsvc_mutex);\n\tlockd_down_net(nlmsvc_serv, net);\n\tlockd_put();\n\tmutex_unlock(&nlmsvc_mutex);\n}\nEXPORT_SYMBOL_GPL(lockd_down);\n\n#ifdef CONFIG_SYSCTL\n\n \n\nstatic struct ctl_table nlm_sysctls[] = {\n\t{\n\t\t.procname\t= \"nlm_grace_period\",\n\t\t.data\t\t= &nlm_grace_period,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= (unsigned long *) &nlm_grace_period_min,\n\t\t.extra2\t\t= (unsigned long *) &nlm_grace_period_max,\n\t},\n\t{\n\t\t.procname\t= \"nlm_timeout\",\n\t\t.data\t\t= &nlm_timeout,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t\t.extra1\t\t= (unsigned long *) &nlm_timeout_min,\n\t\t.extra2\t\t= (unsigned long *) &nlm_timeout_max,\n\t},\n\t{\n\t\t.procname\t= \"nlm_udpport\",\n\t\t.data\t\t= &nlm_udpport,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (int *) &nlm_port_min,\n\t\t.extra2\t\t= (int *) &nlm_port_max,\n\t},\n\t{\n\t\t.procname\t= \"nlm_tcpport\",\n\t\t.data\t\t= &nlm_tcpport,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (int *) &nlm_port_min,\n\t\t.extra2\t\t= (int *) &nlm_port_max,\n\t},\n\t{\n\t\t.procname\t= \"nsm_use_hostnames\",\n\t\t.data\t\t= &nsm_use_hostnames,\n\t\t.maxlen\t\t= sizeof(bool),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dobool,\n\t},\n\t{\n\t\t.procname\t= \"nsm_local_state\",\n\t\t.data\t\t= &nsm_local_state,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\n#endif\t \n\n \n\n#define param_set_min_max(name, type, which_strtol, min, max)\t\t\\\nstatic int param_set_##name(const char *val, const struct kernel_param *kp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar *endp;\t\t\t\t\t\t\t\\\n\t__typeof__(type) num = which_strtol(val, &endp, 0);\t\t\\\n\tif (endp == val || *endp || num < (min) || num > (max))\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t*((type *) kp->arg) = num;\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nstatic inline int is_callback(u32 proc)\n{\n\treturn proc == NLMPROC_GRANTED\n\t\t|| proc == NLMPROC_GRANTED_MSG\n\t\t|| proc == NLMPROC_TEST_RES\n\t\t|| proc == NLMPROC_LOCK_RES\n\t\t|| proc == NLMPROC_CANCEL_RES\n\t\t|| proc == NLMPROC_UNLOCK_RES\n\t\t|| proc == NLMPROC_NSM_NOTIFY;\n}\n\n\nstatic enum svc_auth_status lockd_authenticate(struct svc_rqst *rqstp)\n{\n\trqstp->rq_client = NULL;\n\tswitch (rqstp->rq_authop->flavour) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\t\trqstp->rq_auth_stat = rpc_auth_ok;\n\t\t\tif (rqstp->rq_proc == 0)\n\t\t\t\treturn SVC_OK;\n\t\t\tif (is_callback(rqstp->rq_proc)) {\n\t\t\t\t \n\t\t\t\treturn SVC_OK;\n\t\t\t}\n\t\t\treturn svc_set_client(rqstp);\n\t}\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\treturn SVC_DENIED;\n}\n\n\nparam_set_min_max(port, int, simple_strtol, 0, 65535)\nparam_set_min_max(grace_period, unsigned long, simple_strtoul,\n\t\t  nlm_grace_period_min, nlm_grace_period_max)\nparam_set_min_max(timeout, unsigned long, simple_strtoul,\n\t\t  nlm_timeout_min, nlm_timeout_max)\n\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_DESCRIPTION(\"NFS file locking service version \" LOCKD_VERSION \".\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_call(nlm_grace_period, param_set_grace_period, param_get_ulong,\n\t\t  &nlm_grace_period, 0644);\nmodule_param_call(nlm_timeout, param_set_timeout, param_get_ulong,\n\t\t  &nlm_timeout, 0644);\nmodule_param_call(nlm_udpport, param_set_port, param_get_int,\n\t\t  &nlm_udpport, 0644);\nmodule_param_call(nlm_tcpport, param_set_port, param_get_int,\n\t\t  &nlm_tcpport, 0644);\nmodule_param(nsm_use_hostnames, bool, 0644);\nmodule_param(nlm_max_connections, uint, 0644);\n\nstatic int lockd_init_net(struct net *net)\n{\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tINIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);\n\tINIT_LIST_HEAD(&ln->lockd_manager.list);\n\tln->lockd_manager.block_opens = false;\n\tINIT_LIST_HEAD(&ln->nsm_handles);\n\treturn 0;\n}\n\nstatic void lockd_exit_net(struct net *net)\n{\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tWARN_ONCE(!list_empty(&ln->lockd_manager.list),\n\t\t  \"net %x %s: lockd_manager.list is not empty\\n\",\n\t\t  net->ns.inum, __func__);\n\tWARN_ONCE(!list_empty(&ln->nsm_handles),\n\t\t  \"net %x %s: nsm_handles list is not empty\\n\",\n\t\t  net->ns.inum, __func__);\n\tWARN_ONCE(delayed_work_pending(&ln->grace_period_end),\n\t\t  \"net %x %s: grace_period_end was not cancelled\\n\",\n\t\t  net->ns.inum, __func__);\n}\n\nstatic struct pernet_operations lockd_net_ops = {\n\t.init = lockd_init_net,\n\t.exit = lockd_exit_net,\n\t.id = &lockd_net_id,\n\t.size = sizeof(struct lockd_net),\n};\n\n\n \n\nstatic int __init init_nlm(void)\n{\n\tint err;\n\n#ifdef CONFIG_SYSCTL\n\terr = -ENOMEM;\n\tnlm_sysctl_table = register_sysctl(\"fs/nfs\", nlm_sysctls);\n\tif (nlm_sysctl_table == NULL)\n\t\tgoto err_sysctl;\n#endif\n\terr = register_pernet_subsys(&lockd_net_ops);\n\tif (err)\n\t\tgoto err_pernet;\n\n\terr = lockd_create_procfs();\n\tif (err)\n\t\tgoto err_procfs;\n\n\treturn 0;\n\nerr_procfs:\n\tunregister_pernet_subsys(&lockd_net_ops);\nerr_pernet:\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(nlm_sysctl_table);\nerr_sysctl:\n#endif\n\treturn err;\n}\n\nstatic void __exit exit_nlm(void)\n{\n\t \n\tnlm_shutdown_hosts();\n\tlockd_remove_procfs();\n\tunregister_pernet_subsys(&lockd_net_ops);\n#ifdef CONFIG_SYSCTL\n\tunregister_sysctl_table(nlm_sysctl_table);\n#endif\n}\n\nmodule_init(init_nlm);\nmodule_exit(exit_nlm);\n\n \nstatic int nlmsvc_dispatch(struct svc_rqst *rqstp)\n{\n\tconst struct svc_procedure *procp = rqstp->rq_procinfo;\n\t__be32 *statp = rqstp->rq_accept_statp;\n\n\tif (!procp->pc_decode(rqstp, &rqstp->rq_arg_stream))\n\t\tgoto out_decode_err;\n\n\t*statp = procp->pc_func(rqstp);\n\tif (*statp == rpc_drop_reply)\n\t\treturn 0;\n\tif (*statp != rpc_success)\n\t\treturn 1;\n\n\tif (!procp->pc_encode(rqstp, &rqstp->rq_res_stream))\n\t\tgoto out_encode_err;\n\n\treturn 1;\n\nout_decode_err:\n\t*statp = rpc_garbage_args;\n\treturn 1;\n\nout_encode_err:\n\t*statp = rpc_system_err;\n\treturn 1;\n}\n\n \nstatic DEFINE_PER_CPU_ALIGNED(unsigned long, nlmsvc_version1_count[17]);\nstatic const struct svc_version\tnlmsvc_version1 = {\n\t.vs_vers\t= 1,\n\t.vs_nproc\t= 17,\n\t.vs_proc\t= nlmsvc_procedures,\n\t.vs_count\t= nlmsvc_version1_count,\n\t.vs_dispatch\t= nlmsvc_dispatch,\n\t.vs_xdrsize\t= NLMSVC_XDRSIZE,\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nlmsvc_version3_count[ARRAY_SIZE(nlmsvc_procedures)]);\nstatic const struct svc_version\tnlmsvc_version3 = {\n\t.vs_vers\t= 3,\n\t.vs_nproc\t= ARRAY_SIZE(nlmsvc_procedures),\n\t.vs_proc\t= nlmsvc_procedures,\n\t.vs_count\t= nlmsvc_version3_count,\n\t.vs_dispatch\t= nlmsvc_dispatch,\n\t.vs_xdrsize\t= NLMSVC_XDRSIZE,\n};\n\n#ifdef CONFIG_LOCKD_V4\nstatic DEFINE_PER_CPU_ALIGNED(unsigned long,\n\t\t\t      nlmsvc_version4_count[ARRAY_SIZE(nlmsvc_procedures4)]);\nstatic const struct svc_version\tnlmsvc_version4 = {\n\t.vs_vers\t= 4,\n\t.vs_nproc\t= ARRAY_SIZE(nlmsvc_procedures4),\n\t.vs_proc\t= nlmsvc_procedures4,\n\t.vs_count\t= nlmsvc_version4_count,\n\t.vs_dispatch\t= nlmsvc_dispatch,\n\t.vs_xdrsize\t= NLMSVC_XDRSIZE,\n};\n#endif\n\nstatic const struct svc_version *nlmsvc_version[] = {\n\t[1] = &nlmsvc_version1,\n\t[3] = &nlmsvc_version3,\n#ifdef CONFIG_LOCKD_V4\n\t[4] = &nlmsvc_version4,\n#endif\n};\n\nstatic struct svc_stat\t\tnlmsvc_stats;\n\n#define NLM_NRVERS\tARRAY_SIZE(nlmsvc_version)\nstatic struct svc_program\tnlmsvc_program = {\n\t.pg_prog\t\t= NLM_PROGRAM,\t\t \n\t.pg_nvers\t\t= NLM_NRVERS,\t\t \n\t.pg_vers\t\t= nlmsvc_version,\t \n\t.pg_name\t\t= \"lockd\",\t\t \n\t.pg_class\t\t= \"nfsd\",\t\t \n\t.pg_stats\t\t= &nlmsvc_stats,\t \n\t.pg_authenticate\t= &lockd_authenticate,\t \n\t.pg_init_request\t= svc_generic_init_request,\n\t.pg_rpcbind_set\t\t= svc_generic_rpcbind_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}