{
  "module_name": "clntproc.c",
  "hash_id": "8bf18e56ccb481168138cbb36687e33b90afbc1d85ebde063f9ccc0f856a58a1",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/clntproc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/nfs_fs.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/lockd/lockd.h>\n\n#include \"trace.h\"\n\n#define NLMDBG_FACILITY\t\tNLMDBG_CLIENT\n#define NLMCLNT_GRACE_WAIT\t(5*HZ)\n#define NLMCLNT_POLL_TIMEOUT\t(30*HZ)\n#define NLMCLNT_MAX_RETRIES\t3\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlm_stat_to_errno(__be32 stat);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic const struct rpc_call_ops nlmclnt_unlock_ops;\nstatic const struct rpc_call_ops nlmclnt_cancel_ops;\n\n \nstatic atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);\n\nvoid nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}\n\nstatic struct nlm_lockowner *\nnlmclnt_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\trefcount_inc(&lockowner->count);\n\treturn lockowner;\n}\n\nstatic void nlmclnt_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!refcount_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmclnt_release_host(lockowner->host);\n\tkfree(lockowner);\n}\n\nstatic inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid == pid)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\n{\n\tuint32_t res;\n\tdo {\n\t\tres = host->h_pidcount++;\n\t} while (nlm_pidbusy(host, res) < 0);\n\treturn res;\n}\n\nstatic struct nlm_lockowner *__nlmclnt_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->owner != owner)\n\t\t\tcontinue;\n\t\treturn nlmclnt_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}\n\nstatic struct nlm_lockowner *nlmclnt_find_lockowner(struct nlm_host *host, fl_owner_t owner)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlmclnt_find_lockowner(host, owner);\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlmclnt_find_lockowner(host, owner);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\trefcount_set(&new->count, 1);\n\t\t\tnew->owner = owner;\n\t\t\tnew->pid = __nlm_alloc_pid(host);\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}\n\n \nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\tchar *nodename = req->a_host->h_rpcclnt->cl_nodename;\n\n\tnlmclnt_next_cookie(&argp->cookie);\n\tmemcpy(&lock->fh, NFS_FH(file_inode(fl->fl_file)), sizeof(struct nfs_fh));\n\tlock->caller  = nodename;\n\tlock->oh.data = req->a_owner;\n\tlock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), \"%u@%s\",\n\t\t\t\t(unsigned int)fl->fl_u.nfs_fl.owner->pid,\n\t\t\t\tnodename);\n\tlock->svid = fl->fl_u.nfs_fl.owner->pid;\n\tlock->fl.fl_start = fl->fl_start;\n\tlock->fl.fl_end = fl->fl_end;\n\tlock->fl.fl_type = fl->fl_type;\n}\n\nstatic void nlmclnt_release_lockargs(struct nlm_rqst *req)\n{\n\tWARN_ON_ONCE(req->a_args.lock.fl.fl_ops != NULL);\n}\n\n \nint nlmclnt_proc(struct nlm_host *host, int cmd, struct file_lock *fl, void *data)\n{\n\tstruct nlm_rqst\t\t*call;\n\tint\t\t\tstatus;\n\tconst struct nlmclnt_operations *nlmclnt_ops = host->h_nlmclnt_ops;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn -ENOMEM;\n\n\tif (nlmclnt_ops && nlmclnt_ops->nlmclnt_alloc_call)\n\t\tnlmclnt_ops->nlmclnt_alloc_call(data);\n\n\tnlmclnt_locks_init_private(fl, host);\n\tif (!fl->fl_u.nfs_fl.owner) {\n\t\t \n\t\tnlmclnt_release_call(call);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tnlmclnt_setlockargs(call, fl);\n\tcall->a_callback_data = data;\n\n\tif (IS_SETLK(cmd) || IS_SETLKW(cmd)) {\n\t\tif (fl->fl_type != F_UNLCK) {\n\t\t\tcall->a_args.block = IS_SETLKW(cmd) ? 1 : 0;\n\t\t\tstatus = nlmclnt_lock(call, fl);\n\t\t} else\n\t\t\tstatus = nlmclnt_unlock(call, fl);\n\t} else if (IS_GETLK(cmd))\n\t\tstatus = nlmclnt_test(call, fl);\n\telse\n\t\tstatus = -EINVAL;\n\tfl->fl_ops->fl_release_private(fl);\n\tfl->fl_ops = NULL;\n\n\tdprintk(\"lockd: clnt proc returns %d\\n\", status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nlmclnt_proc);\n\n \nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\trefcount_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}\n\nvoid nlmclnt_release_call(struct nlm_rqst *call)\n{\n\tconst struct nlmclnt_operations *nlmclnt_ops = call->a_host->h_nlmclnt_ops;\n\n\tif (!refcount_dec_and_test(&call->a_count))\n\t\treturn;\n\tif (nlmclnt_ops && nlmclnt_ops->nlmclnt_release_call)\n\t\tnlmclnt_ops->nlmclnt_release_call(call->a_callback_data);\n\tnlmclnt_release_host(call->a_host);\n\tnlmclnt_release_lockargs(call);\n\tkfree(call);\n}\n\nstatic void nlmclnt_rpc_release(void *data)\n{\n\tnlmclnt_release_call(data);\n}\n\nstatic int nlm_wait_on_grace(wait_queue_head_t *queue)\n{\n\tDEFINE_WAIT(wait);\n\tint status = -EINTR;\n\n\tprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\n\tif (!signalled ()) {\n\t\tschedule_timeout(NLMCLNT_GRACE_WAIT);\n\t\ttry_to_freeze();\n\t\tif (!signalled ())\n\t\t\tstatus = 0;\n\t}\n\tfinish_wait(queue, &wait);\n\treturn status;\n}\n\n \nstatic int\nnlmclnt_call(const struct cred *cred, struct nlm_rqst *req, u32 proc)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct nlm_args\t*argp = &req->a_args;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= argp,\n\t\t.rpc_resp\t= resp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: call procedure %d on %s\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\tdo {\n\t\tif (host->h_reclaiming && !argp->reclaim)\n\t\t\tgoto in_grace_period;\n\n\t\t \n\t\tif ((clnt = nlm_bind_host(host)) == NULL)\n\t\t\treturn -ENOLCK;\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\n\t\t \n\t\tif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n\t\t\tdprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n\t\t\tswitch (status) {\n\t\t\tcase -EPROTONOSUPPORT:\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase -ECONNREFUSED:\n\t\t\tcase -ETIMEDOUT:\n\t\t\tcase -ENOTCONN:\n\t\t\t\tnlm_rebind_host(host);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\treturn signalled () ? -EINTR : status;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\tif (resp->status == nlm_lck_denied_grace_period) {\n\t\t\tdprintk(\"lockd: server in grace period\\n\");\n\t\t\tif (argp->reclaim) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t     \"lockd: spurious grace period reject?!\\n\");\n\t\t\t\treturn -ENOLCK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!argp->reclaim) {\n\t\t\t\t \n\t\t\t\twake_up_all(&host->h_gracewait);\n\t\t\t}\n\t\t\tdprintk(\"lockd: server returns status %d\\n\",\n\t\t\t\tntohl(resp->status));\n\t\t\treturn 0;\t \n\t\t}\n\nin_grace_period:\n\t\t \n\t\tstatus = nlm_wait_on_grace(&host->h_gracewait);\n\t} while (status == 0);\n\n\treturn status;\n}\n\n \nstatic struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct rpc_clnt\t*clnt;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = req,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdprintk(\"lockd: call procedure %d on %s (async)\\n\",\n\t\t\t(int)proc, host->h_name);\n\n\t \n\tclnt = nlm_bind_host(host);\n\tif (clnt == NULL)\n\t\tgoto out_err;\n\tmsg->rpc_proc = &clnt->cl_procinfo[proc];\n\ttask_setup_data.rpc_client = clnt;\n\n         \n\treturn rpc_run_task(&task_setup_data);\nout_err:\n\ttk_ops->rpc_release(req);\n\treturn ERR_PTR(-ENOLCK);\n}\n\nstatic int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_task *task;\n\n\ttask = __nlm_async_call(req, proc, msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\n\n \nint nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}\n\nint nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}\n\n \nstatic int nlmclnt_async_call(const struct cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct rpc_task *task;\n\tint err;\n\n\ttask = __nlm_async_call(req, proc, &msg, tk_ops);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\terr = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn err;\n}\n\n \nstatic int\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tint\tstatus;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\n\tif (status < 0)\n\t\tgoto out;\n\n\tswitch (req->a_res.status) {\n\t\tcase nlm_granted:\n\t\t\tfl->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase nlm_lck_denied:\n\t\t\t \n\t\t\tfl->fl_start = req->a_res.lock.fl.fl_start;\n\t\t\tfl->fl_end = req->a_res.lock.fl.fl_end;\n\t\t\tfl->fl_type = req->a_res.lock.fl.fl_type;\n\t\t\tfl->fl_pid = -req->a_res.lock.fl.fl_pid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_stat_to_errno(req->a_res.status);\n\t}\nout:\n\ttrace_nlmclnt_test(&req->a_args.lock,\n\t\t\t   (const struct sockaddr *)&req->a_host->h_addr,\n\t\t\t   req->a_host->h_addrlen, req->a_res.status);\n\tnlmclnt_release_call(req);\n\treturn status;\n}\n\nstatic void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\n\tnew->fl_u.nfs_fl.owner = nlmclnt_get_lockowner(fl->fl_u.nfs_fl.owner);\n\tlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n}\n\nstatic void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlmclnt_put_lockowner(fl->fl_u.nfs_fl.owner);\n}\n\nstatic const struct file_lock_operations nlmclnt_lock_ops = {\n\t.fl_copy_lock = nlmclnt_locks_copy_lock,\n\t.fl_release_private = nlmclnt_locks_release_private,\n};\n\nstatic void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\n{\n\tfl->fl_u.nfs_fl.state = 0;\n\tfl->fl_u.nfs_fl.owner = nlmclnt_find_lockowner(host, fl->fl_owner);\n\tINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\n\tfl->fl_ops = &nlmclnt_lock_ops;\n}\n\nstatic int do_vfs_lock(struct file_lock *fl)\n{\n\treturn locks_lock_file_wait(fl->fl_file, fl);\n}\n\n \nstatic int\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tconst struct cred *cred = nfs_file_cred(fl->fl_file);\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tstruct nlm_wait block;\n\tunsigned char fl_flags = fl->fl_flags;\n\tunsigned char fl_type;\n\t__be32 b_status;\n\tint status = -ENOLCK;\n\n\tif (nsm_monitor(host) < 0)\n\t\tgoto out;\n\treq->a_args.state = nsm_local_state;\n\n\tfl->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(fl);\n\tfl->fl_flags = fl_flags;\n\tif (status < 0)\n\t\tgoto out;\n\n\tnlmclnt_prepare_block(&block, host, fl);\nagain:\n\t \n\tresp->status = nlm_lck_blocked;\n\n\t \n\tnlmclnt_queue_block(&block);\n\tfor (;;) {\n\t\t \n\t\tfl->fl_u.nfs_fl.state = host->h_state;\n\t\tstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\t \n\t\tif (resp->status == nlm_lck_denied_grace_period)\n\t\t\tcontinue;\n\t\tif (resp->status != nlm_lck_blocked)\n\t\t\tbreak;\n\t\t \n\t\tstatus = nlmclnt_wait(&block, req, NLMCLNT_POLL_TIMEOUT);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (block.b_status != nlm_lck_blocked)\n\t\t\tbreak;\n\t}\n\tb_status = nlmclnt_dequeue_block(&block);\n\tif (resp->status == nlm_lck_blocked)\n\t\tresp->status = b_status;\n\n\t \n\tif (resp->status == nlm_lck_blocked) {\n\t\tif (!req->a_args.block)\n\t\t\tgoto out_unlock;\n\t\tif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\n\t\t\tgoto out;\n\t}\n\n\tif (resp->status == nlm_granted) {\n\t\tdown_read(&host->h_rwsem);\n\t\t \n\t\tif (fl->fl_u.nfs_fl.state != host->h_state) {\n\t\t\tup_read(&host->h_rwsem);\n\t\t\tgoto again;\n\t\t}\n\t\t \n\t\tfl->fl_flags |= FL_SLEEP;\n\t\tif (do_vfs_lock(fl) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: VFS is out of sync with lock manager!\\n\", __func__);\n\t\tup_read(&host->h_rwsem);\n\t\tfl->fl_flags = fl_flags;\n\t\tstatus = 0;\n\t}\n\tif (status < 0)\n\t\tgoto out_unlock;\n\t \n\tif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\n\t\tstatus = -ENOLCK;\n\telse\n\t\tstatus = nlm_stat_to_errno(resp->status);\nout:\n\ttrace_nlmclnt_lock(&req->a_args.lock,\n\t\t\t   (const struct sockaddr *)&req->a_host->h_addr,\n\t\t\t   req->a_host->h_addrlen, req->a_res.status);\n\tnlmclnt_release_call(req);\n\treturn status;\nout_unlock:\n\t \n\ttrace_nlmclnt_lock(&req->a_args.lock,\n\t\t\t   (const struct sockaddr *)&req->a_host->h_addr,\n\t\t\t   req->a_host->h_addrlen, req->a_res.status);\n\tdprintk(\"lockd: lock attempt ended in fatal error.\\n\"\n\t\t\"       Attempting to unlock.\\n\");\n\tfl_type = fl->fl_type;\n\tfl->fl_type = F_UNLCK;\n\tdown_read(&host->h_rwsem);\n\tdo_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_type = fl_type;\n\tfl->fl_flags = fl_flags;\n\tnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\treturn status;\n}\n\n \nint\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl,\n\t\tstruct nlm_rqst *req)\n{\n\tint\t\tstatus;\n\n\tmemset(req, 0, sizeof(*req));\n\tlocks_init_lock(&req->a_args.lock.fl);\n\tlocks_init_lock(&req->a_res.lock.fl);\n\treq->a_host  = host;\n\n\t \n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.reclaim = 1;\n\n\tstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\n\tif (status >= 0 && req->a_res.status == nlm_granted)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"lockd: failed to reclaim lock for pid %d \"\n\t\t\t\t\"(errno %d, status %d)\\n\", fl->fl_pid,\n\t\t\t\tstatus, ntohl(req->a_res.status));\n\n\t \n\n\treturn -ENOLCK;\n}\n\n \nstatic int\nnlmclnt_unlock(struct nlm_rqst *req, struct file_lock *fl)\n{\n\tstruct nlm_host\t*host = req->a_host;\n\tstruct nlm_res\t*resp = &req->a_res;\n\tint status;\n\tunsigned char fl_flags = fl->fl_flags;\n\n\t \n\tfl->fl_flags |= FL_EXISTS;\n\tdown_read(&host->h_rwsem);\n\tstatus = do_vfs_lock(fl);\n\tup_read(&host->h_rwsem);\n\tfl->fl_flags = fl_flags;\n\tif (status == -ENOENT) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\trefcount_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_UNLOCK, &nlmclnt_unlock_ops);\n\tif (status < 0)\n\t\tgoto out;\n\n\tif (resp->status == nlm_granted)\n\t\tgoto out;\n\n\tif (resp->status != nlm_lck_denied_nolocks)\n\t\tprintk(\"lockd: unexpected unlock status: %d\\n\",\n\t\t\tntohl(resp->status));\n\t \n\tstatus = -ENOLCK;\nout:\n\ttrace_nlmclnt_unlock(&req->a_args.lock,\n\t\t\t     (const struct sockaddr *)&req->a_host->h_addr,\n\t\t\t     req->a_host->h_addrlen, req->a_res.status);\n\tnlmclnt_release_call(req);\n\treturn status;\n}\n\nstatic void nlmclnt_unlock_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tconst struct nlmclnt_operations *nlmclnt_ops = req->a_host->h_nlmclnt_ops;\n\tbool defer_call = false;\n\n\tif (nlmclnt_ops && nlmclnt_ops->nlmclnt_unlock_prepare)\n\t\tdefer_call = nlmclnt_ops->nlmclnt_unlock_prepare(task, req->a_callback_data);\n\n\tif (!defer_call)\n\t\trpc_call_start(task);\n}\n\nstatic void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_SIGNALLED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}\n\nstatic const struct rpc_call_ops nlmclnt_unlock_ops = {\n\t.rpc_call_prepare = nlmclnt_unlock_prepare,\n\t.rpc_call_done = nlmclnt_unlock_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\n \nstatic int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\n{\n\tstruct nlm_rqst\t*req;\n\tint status;\n\n\tdprintk(\"lockd: blocking lock attempt was interrupted by a signal.\\n\"\n\t\t\"       Attempting to cancel lock.\\n\");\n\n\treq = nlm_alloc_call(host);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->a_flags = RPC_TASK_ASYNC;\n\n\tnlmclnt_setlockargs(req, fl);\n\treq->a_args.block = block;\n\n\trefcount_inc(&req->a_count);\n\tstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\n\t\t\tNLMPROC_CANCEL, &nlmclnt_cancel_ops);\n\tif (status == 0 && req->a_res.status == nlm_lck_denied)\n\t\tstatus = -ENOLCK;\n\tnlmclnt_release_call(req);\n\treturn status;\n}\n\nstatic void nlmclnt_cancel_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_SIGNALLED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: CANCEL call error %d, retrying.\\n\",\n\t\t\t\t\ttask->tk_status);\n\t\tgoto retry_cancel;\n\t}\n\n\tswitch (status) {\n\tcase NLM_LCK_GRANTED:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\tcase NLM_LCK_DENIED:\n\t\t \n\t\tbreak;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\t\tdprintk(\"lockd: CANCEL failed (server has no locks)\\n\");\n\t\tgoto retry_cancel;\n\tdefault:\n\t\tprintk(KERN_NOTICE \"lockd: weird return %d for CANCEL call\\n\",\n\t\t\tstatus);\n\t}\n\ndie:\n\treturn;\n\nretry_cancel:\n\t \n\tif (req->a_retries++ >= NLMCLNT_MAX_RETRIES)\n\t\tgoto die;\n\tnlm_rebind_host(req->a_host);\n\trpc_restart_call(task);\n\trpc_delay(task, 30 * HZ);\n}\n\nstatic const struct rpc_call_ops nlmclnt_cancel_ops = {\n\t.rpc_call_done = nlmclnt_cancel_callback,\n\t.rpc_release = nlmclnt_rpc_release,\n};\n\n \nstatic int\nnlm_stat_to_errno(__be32 status)\n{\n\tswitch(ntohl(status)) {\n\tcase NLM_LCK_GRANTED:\n\t\treturn 0;\n\tcase NLM_LCK_DENIED:\n\t\treturn -EAGAIN;\n\tcase NLM_LCK_DENIED_NOLOCKS:\n\tcase NLM_LCK_DENIED_GRACE_PERIOD:\n\t\treturn -ENOLCK;\n\tcase NLM_LCK_BLOCKED:\n\t\tprintk(KERN_NOTICE \"lockd: unexpected status NLM_BLOCKED\\n\");\n\t\treturn -ENOLCK;\n#ifdef CONFIG_LOCKD_V4\n\tcase NLM_DEADLCK:\n\t\treturn -EDEADLK;\n\tcase NLM_ROFS:\n\t\treturn -EROFS;\n\tcase NLM_STALE_FH:\n\t\treturn -ESTALE;\n\tcase NLM_FBIG:\n\t\treturn -EOVERFLOW;\n\tcase NLM_FAILED:\n\t\treturn -ENOLCK;\n#endif\n\t}\n\tprintk(KERN_NOTICE \"lockd: unexpected server status %d\\n\",\n\t\t ntohl(status));\n\treturn -ENOLCK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}