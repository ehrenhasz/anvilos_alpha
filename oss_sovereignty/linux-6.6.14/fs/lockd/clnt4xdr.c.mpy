{
  "module_name": "clnt4xdr.c",
  "hash_id": "5babd1a7d807e7c2f962b2f807b845d08271c37f7df4358ab0891fdfa487c64d",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/clnt4xdr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/lockd/lockd.h>\n\n#include <uapi/linux/nfs3.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_XDR\n\n#if (NLMCLNT_OHSIZE > XDR_MAX_NETOBJ)\n#  error \"NLM host name cannot be larger than XDR_MAX_NETOBJ!\"\n#endif\n\n#if (NLMCLNT_OHSIZE > NLM_MAXSTRLEN)\n#  error \"NLM host name cannot be larger than NLM's maximum string length!\"\n#endif\n\n \n#define NLM4_void_sz\t\t(0)\n#define NLM4_cookie_sz\t\t(1+(NLM_MAXCOOKIELEN>>2))\n#define NLM4_caller_sz\t\t(1+(NLMCLNT_OHSIZE>>2))\n#define NLM4_owner_sz\t\t(1+(NLMCLNT_OHSIZE>>2))\n#define NLM4_fhandle_sz\t\t(1+(NFS3_FHSIZE>>2))\n#define NLM4_lock_sz\t\t(5+NLM4_caller_sz+NLM4_owner_sz+NLM4_fhandle_sz)\n#define NLM4_holder_sz\t\t(6+NLM4_owner_sz)\n\n#define NLM4_testargs_sz\t(NLM4_cookie_sz+1+NLM4_lock_sz)\n#define NLM4_lockargs_sz\t(NLM4_cookie_sz+4+NLM4_lock_sz)\n#define NLM4_cancargs_sz\t(NLM4_cookie_sz+2+NLM4_lock_sz)\n#define NLM4_unlockargs_sz\t(NLM4_cookie_sz+NLM4_lock_sz)\n\n#define NLM4_testres_sz\t\t(NLM4_cookie_sz+1+NLM4_holder_sz)\n#define NLM4_res_sz\t\t(NLM4_cookie_sz+1)\n#define NLM4_norep_sz\t\t(0)\n\n\nstatic s64 loff_t_to_s64(loff_t offset)\n{\n\ts64 res;\n\n\tif (offset >= NLM4_OFFSET_MAX)\n\t\tres = NLM4_OFFSET_MAX;\n\telse if (offset <= -NLM4_OFFSET_MAX)\n\t\tres = -NLM4_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}\n\nstatic void nlm4_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\t u64 *l_offset, u64 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s64(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s64(fl->fl_end - fl->fl_start + 1);\n}\n\n \n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}\n\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}\n\n \nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}\n\nstatic int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tssize_t ret;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, (void *)&obj->data,\n\t\t\t\t\t\tXDR_MAX_NETOBJ);\n\tif (unlikely(ret < 0))\n\t\treturn -EIO;\n\tobj->len = ret;\n\treturn 0;\n}\n\n \nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}\n\nstatic int decode_cookie(struct xdr_stream *xdr,\n\t\t\t     struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t \n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, fh->size);\n}\n\n \nstatic void encode_nlm4_stat(struct xdr_stream *xdr,\n\t\t\t     const __be32 stat)\n{\n\t__be32 *p;\n\n\tBUG_ON(be32_to_cpu(stat) > NLM_FAILED);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}\n\nstatic int decode_nlm4_stat(struct xdr_stream *xdr, __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm4_failed)))\n\t\tgoto out_bad_xdr;\n\t*stat = *p;\n\treturn 0;\nout_bad_xdr:\n\tdprintk(\"%s: server returned invalid nlm4_stats value: %u\\n\",\n\t\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_nlm4_holder(struct xdr_stream *xdr,\n\t\t\t       const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu64 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm4_compute_offsets(lock, &l_offset, &l_len);\n\tp = xdr_encode_hyper(p, l_offset);\n\txdr_encode_hyper(p, l_len);\n}\n\nstatic int decode_nlm4_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu64 l_offset, l_len;\n\tu32 exclusive;\n\tint error;\n\t__be32 *p;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 8 + 8);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tp = xdr_decode_hyper(p, &l_offset);\n\txdr_decode_hyper(p, &l_len);\n\tnlm4svc_set_file_lock_range(fl, l_offset, l_len);\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\treturn -EIO;\n}\n\n \nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t \n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}\n\n \nstatic void encode_nlm4_lock(struct xdr_stream *xdr,\n\t\t\t     const struct nlm_lock *lock)\n{\n\tu64 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 8 + 8);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm4_compute_offsets(lock, &l_offset, &l_len);\n\tp = xdr_encode_hyper(p, l_offset);\n\txdr_encode_hyper(p, l_len);\n}\n\n\n \n\n \nstatic void nlm4_xdr_enc_testargs(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm4_lock(xdr, lock);\n}\n\n \nstatic void nlm4_xdr_enc_lockargs(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm4_lock(xdr, lock);\n\tencode_bool(xdr, args->reclaim);\n\tencode_int32(xdr, args->state);\n}\n\n \nstatic void nlm4_xdr_enc_cancargs(struct rpc_rqst *req,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm4_lock(xdr, lock);\n}\n\n \nstatic void nlm4_xdr_enc_unlockargs(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    const void *data)\n{\n\tconst struct nlm_args *args = data;\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_nlm4_lock(xdr, lock);\n}\n\n \nstatic void nlm4_xdr_enc_res(struct rpc_rqst *req,\n\t\t\t     struct xdr_stream *xdr,\n\t\t\t     const void *data)\n{\n\tconst struct nlm_res *result = data;\n\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm4_stat(xdr, result->status);\n}\n\n \nstatic void nlm4_xdr_enc_testres(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct nlm_res *result = data;\n\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm4_stat(xdr, result->status);\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm4_holder(xdr, result);\n}\n\n\n \n\n \nstatic int decode_nlm4_testrply(struct xdr_stream *xdr,\n\t\t\t\tstruct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm4_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm4_holder(xdr, result);\nout:\n\treturn error;\n}\n\nstatic int nlm4_xdr_dec_testres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nlm_res *result = data;\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm4_testrply(xdr, result);\nout:\n\treturn error;\n}\n\n \nstatic int nlm4_xdr_dec_res(struct rpc_rqst *req,\n\t\t\t    struct xdr_stream *xdr,\n\t\t\t    void *data)\n{\n\tstruct nlm_res *result = data;\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm4_stat(xdr, &result->status);\nout:\n\treturn error;\n}\n\n\n \n#define nlm4_xdr_dec_norep\tNULL\n\n#define PROC(proc, argtype, restype)\t\t\t\t\t\\\n[NLMPROC_##proc] = {\t\t\t\t\t\t\t\\\n\t.p_proc      = NLMPROC_##proc,\t\t\t\t\t\\\n\t.p_encode    = nlm4_xdr_enc_##argtype,\t\t\t\t\\\n\t.p_decode    = nlm4_xdr_dec_##restype,\t\t\t\t\\\n\t.p_arglen    = NLM4_##argtype##_sz,\t\t\t\t\\\n\t.p_replen    = NLM4_##restype##_sz,\t\t\t\t\\\n\t.p_statidx   = NLMPROC_##proc,\t\t\t\t\t\\\n\t.p_name      = #proc,\t\t\t\t\t\t\\\n\t}\n\nstatic const struct rpc_procinfo nlm4_procedures[] = {\n\tPROC(TEST,\t\ttestargs,\ttestres),\n\tPROC(LOCK,\t\tlockargs,\tres),\n\tPROC(CANCEL,\t\tcancargs,\tres),\n\tPROC(UNLOCK,\t\tunlockargs,\tres),\n\tPROC(GRANTED,\t\ttestargs,\tres),\n\tPROC(TEST_MSG,\t\ttestargs,\tnorep),\n\tPROC(LOCK_MSG,\t\tlockargs,\tnorep),\n\tPROC(CANCEL_MSG,\tcancargs,\tnorep),\n\tPROC(UNLOCK_MSG,\tunlockargs,\tnorep),\n\tPROC(GRANTED_MSG,\ttestargs,\tnorep),\n\tPROC(TEST_RES,\t\ttestres,\tnorep),\n\tPROC(LOCK_RES,\t\tres,\t\tnorep),\n\tPROC(CANCEL_RES,\tres,\t\tnorep),\n\tPROC(UNLOCK_RES,\tres,\t\tnorep),\n\tPROC(GRANTED_RES,\tres,\t\tnorep),\n};\n\nstatic unsigned int nlm_version4_counts[ARRAY_SIZE(nlm4_procedures)];\nconst struct rpc_version nlm_version4 = {\n\t.number\t\t= 4,\n\t.nrprocs\t= ARRAY_SIZE(nlm4_procedures),\n\t.procs\t\t= nlm4_procedures,\n\t.counts\t\t= nlm_version4_counts,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}