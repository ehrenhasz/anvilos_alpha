{
  "module_name": "xdr.c",
  "hash_id": "9de06ee5d8f241f41da6fc3ce5a7b247049851a7808785e0c32be82b8c040669",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/xdr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/nfs.h>\n\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/lockd/lockd.h>\n\n#include <uapi/linux/nfs2.h>\n\n#include \"svcxdr.h\"\n\n\nstatic inline loff_t\ns32_to_loff_t(__s32 offset)\n{\n\treturn (loff_t)offset;\n}\n\nstatic inline __s32\nloff_t_to_s32(loff_t offset)\n{\n\t__s32 res;\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}\n\n \nstatic bool\nsvcxdr_decode_fhandle(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn false;\n\tif (len != NFS2_FHSIZE)\n\t\treturn false;\n\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p)\n\t\treturn false;\n\tfh->size = NFS2_FHSIZE;\n\tmemcpy(fh->data, p, len);\n\tmemset(fh->data + NFS2_FHSIZE, 0, sizeof(fh->data) - NFS2_FHSIZE);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_lock(struct xdr_stream *xdr, struct nlm_lock *lock)\n{\n\tstruct file_lock *fl = &lock->fl;\n\ts32 start, len, end;\n\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (!svcxdr_decode_fhandle(xdr, &lock->fh))\n\t\treturn false;\n\tif (!svcxdr_decode_owner(xdr, &lock->oh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &lock->svid) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &start) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn false;\n\n\tlocks_init_lock(fl);\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\n\tend = start + len - 1;\n\tfl->fl_start = s32_to_loff_t(start);\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = s32_to_loff_t(end);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_holder(struct xdr_stream *xdr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\ts32 start, len;\n\n\t \n\tif (xdr_stream_encode_bool(xdr, fl->fl_type != F_RDLCK) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, lock->svid) < 0)\n\t\treturn false;\n\tif (!svcxdr_encode_owner(xdr, &lock->oh))\n\t\treturn false;\n\tstart = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tlen = 0;\n\telse\n\t\tlen = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n\tif (xdr_stream_encode_u32(xdr, start) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, len) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_testrply(struct xdr_stream *xdr, const struct nlm_res *resp)\n{\n\tif (!svcxdr_encode_stats(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nlm_lck_denied:\n\t\tif (!svcxdr_encode_holder(xdr, &resp->lock))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n \n\nbool\nnlmsvc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nbool\nnlmsvc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &argp->block) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\tif (xdr_stream_decode_bool(xdr, &argp->reclaim) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\targp->monitor = 1;\t\t \n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &argp->block) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\targp->lock.fl.fl_type = F_UNLCK;\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_cookie(xdr, &resp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_stats(xdr, &resp->status))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_reboot *argp = rqstp->rq_argp;\n\t__be32 *p;\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn false;\n\tif (len > SM_MAXSTRLEN)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p)\n\t\treturn false;\n\targp->len = len;\n\targp->mon = (char *)p;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, SM_PRIV_SIZE);\n\tif (!p)\n\t\treturn false;\n\tmemcpy(&argp->priv.data, p, sizeof(argp->priv.data));\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(&lock->fl);\n\tlock->svid = ~(u32)0;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (!svcxdr_decode_fhandle(xdr, &lock->fh))\n\t\treturn false;\n\tif (!svcxdr_decode_owner(xdr, &lock->oh))\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &argp->fsm_mode) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->fsm_access) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnlmsvc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n \n\nbool\nnlmsvc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nbool\nnlmsvc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_cookie(xdr, &resp->cookie) &&\n\t\tsvcxdr_encode_testrply(xdr, resp);\n}\n\nbool\nnlmsvc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_cookie(xdr, &resp->cookie) &&\n\t\tsvcxdr_encode_stats(xdr, resp->status);\n}\n\nbool\nnlmsvc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_cookie(xdr, &resp->cookie))\n\t\treturn false;\n\tif (!svcxdr_encode_stats(xdr, resp->status))\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_u32(xdr, 0) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}