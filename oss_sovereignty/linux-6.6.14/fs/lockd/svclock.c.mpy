{
  "module_name": "svclock.c",
  "hash_id": "72981a13a2b93e6f85d9238a97b1d2d1bb8064ad8328b373ef3b97cbb704f324",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svclock.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/nlm.h>\n#include <linux/lockd/lockd.h>\n#include <linux/kthread.h>\n#include <linux/exportfs.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_SVCLOCK\n\n#ifdef CONFIG_LOCKD_V4\n#define nlm_deadlock\tnlm4_deadlock\n#else\n#define nlm_deadlock\tnlm_lck_denied\n#endif\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\nstatic const struct rpc_call_ops nlmsvc_grant_ops;\n\n \nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\nstatic const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t \n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t \n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}\n#endif\n\n \nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}\n\n \nstatic inline void\nnlmsvc_remove_block(struct nlm_block *block)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tif (!list_empty(&block->b_list)) {\n\t\tlist_del_init(&block->b_list);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n}\n\n \nstatic struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\tspin_unlock(&nlm_blocked_lock);\n\t\t\treturn block;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\treturn NULL;\n}\n\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline struct nlm_block *\nnlmsvc_find_block(struct nlm_cookie *cookie)\n{\n\tstruct nlm_block *block;\n\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\n\t\t\tgoto found;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\treturn NULL;\n\nfound:\n\tdprintk(\"nlmsvc_find_block(%s): block=%p\\n\", nlmdbg_cookie2a(cookie), block);\n\tkref_get(&block->b_count);\n\tspin_unlock(&nlm_blocked_lock);\n\treturn block;\n}\n\n \nstatic struct nlm_block *\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\n\t\t    struct nlm_file *file, struct nlm_lock *lock,\n\t\t    struct nlm_cookie *cookie)\n{\n\tstruct nlm_block\t*block;\n\tstruct nlm_rqst\t\t*call = NULL;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn NULL;\n\n\t \n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (block == NULL)\n\t\tgoto failed;\n\tkref_init(&block->b_count);\n\tINIT_LIST_HEAD(&block->b_list);\n\tINIT_LIST_HEAD(&block->b_flist);\n\n\tif (!nlmsvc_setgrantargs(call, lock))\n\t\tgoto failed_free;\n\n\t \n\tcall->a_args.lock.fl.fl_flags |= FL_SLEEP;\n\tcall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\n\tnlmclnt_next_cookie(&call->a_args.cookie);\n\n\tdprintk(\"lockd: created block %p...\\n\", block);\n\n\t \n\tblock->b_daemon = rqstp->rq_server;\n\tblock->b_host   = host;\n\tblock->b_file   = file;\n\tfile->f_count++;\n\n\t \n\tlist_add(&block->b_flist, &file->f_blocks);\n\n\t \n\tblock->b_call = call;\n\tcall->a_flags   = RPC_TASK_ASYNC;\n\tcall->a_block = block;\n\n\treturn block;\n\nfailed_free:\n\tkfree(block);\nfailed:\n\tnlmsvc_release_call(call);\n\treturn NULL;\n}\n\n \nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t \n\tstatus = locks_delete_block(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}\n\nstatic void nlmsvc_free_block(struct kref *kref)\n{\n\tstruct nlm_block *block = container_of(kref, struct nlm_block, b_count);\n\tstruct nlm_file\t\t*file = block->b_file;\n\n\tdprintk(\"lockd: freeing block %p...\\n\", block);\n\n\t \n\tlist_del_init(&block->b_flist);\n\tmutex_unlock(&file->f_mutex);\n\n\tnlmsvc_freegrantargs(block->b_call);\n\tnlmsvc_release_call(block->b_call);\n\tnlm_release_file(block->b_file);\n\tkfree(block);\n}\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}\n\n \nvoid nlmsvc_traverse_blocks(struct nlm_host *host,\n\t\t\tstruct nlm_file *file,\n\t\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_block *block, *next;\n\nrestart:\n\tmutex_lock(&file->f_mutex);\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry_safe(block, next, &file->f_blocks, b_flist) {\n\t\tif (!match(block->b_host, host))\n\t\t\tcontinue;\n\t\t \n\t\tif (list_empty(&block->b_list))\n\t\t\tcontinue;\n\t\tkref_get(&block->b_count);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tmutex_unlock(&file->f_mutex);\n\t\tnlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tmutex_unlock(&file->f_mutex);\n}\n\nstatic struct nlm_lockowner *\nnlmsvc_get_lockowner(struct nlm_lockowner *lockowner)\n{\n\trefcount_inc(&lockowner->count);\n\treturn lockowner;\n}\n\nvoid nlmsvc_put_lockowner(struct nlm_lockowner *lockowner)\n{\n\tif (!refcount_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\n\t\treturn;\n\tlist_del(&lockowner->list);\n\tspin_unlock(&lockowner->host->h_lock);\n\tnlmsvc_release_host(lockowner->host);\n\tkfree(lockowner);\n}\n\nstatic struct nlm_lockowner *__nlmsvc_find_lockowner(struct nlm_host *host, pid_t pid)\n{\n\tstruct nlm_lockowner *lockowner;\n\tlist_for_each_entry(lockowner, &host->h_lockowners, list) {\n\t\tif (lockowner->pid != pid)\n\t\t\tcontinue;\n\t\treturn nlmsvc_get_lockowner(lockowner);\n\t}\n\treturn NULL;\n}\n\nstatic struct nlm_lockowner *nlmsvc_find_lockowner(struct nlm_host *host, pid_t pid)\n{\n\tstruct nlm_lockowner *res, *new = NULL;\n\n\tspin_lock(&host->h_lock);\n\tres = __nlmsvc_find_lockowner(host, pid);\n\n\tif (res == NULL) {\n\t\tspin_unlock(&host->h_lock);\n\t\tnew = kmalloc(sizeof(*res), GFP_KERNEL);\n\t\tspin_lock(&host->h_lock);\n\t\tres = __nlmsvc_find_lockowner(host, pid);\n\t\tif (res == NULL && new != NULL) {\n\t\t\tres = new;\n\t\t\t \n\t\t\trefcount_set(&new->count, 1);\n\t\t\tnew->pid = pid;\n\t\t\tnew->host = nlm_get_host(host);\n\t\t\tlist_add(&new->list, &host->h_lockowners);\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\n\tspin_unlock(&host->h_lock);\n\tkfree(new);\n\treturn res;\n}\n\nvoid\nnlmsvc_release_lockowner(struct nlm_lock *lock)\n{\n\tif (lock->fl.fl_owner)\n\t\tnlmsvc_put_lockowner(lock->fl.fl_owner);\n}\n\nvoid nlmsvc_locks_init_private(struct file_lock *fl, struct nlm_host *host,\n\t\t\t\t\t\tpid_t pid)\n{\n\tfl->fl_owner = nlmsvc_find_lockowner(host, pid);\n}\n\n \nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\n{\n\tlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\n\tmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\n\tcall->a_args.lock.caller = utsname()->nodename;\n\tcall->a_args.lock.oh.len = lock->oh.len;\n\n\t \n\tcall->a_args.lock.oh.data = call->a_owner;\n\tcall->a_args.lock.svid = ((struct nlm_lockowner *)lock->fl.fl_owner)->pid;\n\n\tif (lock->oh.len > NLMCLNT_OHSIZE) {\n\t\tvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn 0;\n\t\tcall->a_args.lock.oh.data = (u8 *) data;\n\t}\n\n\tmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\n\treturn 1;\n}\n\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call)\n{\n\tif (call->a_args.lock.oh.data != call->a_owner)\n\t\tkfree(call->a_args.lock.oh.data);\n\n\tlocks_release_private(&call->a_args.lock.fl);\n}\n\n \nstatic __be32\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\n{\n\t__be32 status = nlm_lck_denied_nolocks;\n\n\tblock->b_flags |= B_QUEUED;\n\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\n\tblock->b_cache_req = &rqstp->rq_chandle;\n\tif (rqstp->rq_chandle.defer) {\n\t\tblock->b_deferred_req =\n\t\t\trqstp->rq_chandle.defer(block->b_cache_req);\n\t\tif (block->b_deferred_req != NULL)\n\t\t\tstatus = nlm_drop_reply;\n\t}\n\tdprintk(\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\",\n\t\tblock, block->b_flags, ntohl(status));\n\n\treturn status;\n}\n\n \n__be32\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t    struct nlm_host *host, struct nlm_lock *lock, int wait,\n\t    struct nlm_cookie *cookie, int reclaim)\n{\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\tstruct inode\t\t*inode = nlmsvc_file_inode(file);\n#endif\n\tstruct nlm_block\t*block = NULL;\n\tint\t\t\terror;\n\tint\t\t\tmode;\n\tint\t\t\tasync_block = 0;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino,\n\t\t\t\tlock->fl.fl_type, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end,\n\t\t\t\twait);\n\n\tif (nlmsvc_file_file(file)->f_op->lock) {\n\t\tasync_block = wait;\n\t\twait = 0;\n\t}\n\n\t \n\tmutex_lock(&file->f_mutex);\n\t \n\tblock = nlmsvc_lookup_block(file, lock);\n\tif (block == NULL) {\n\t\tblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\n\t\tret = nlm_lck_denied_nolocks;\n\t\tif (block == NULL)\n\t\t\tgoto out;\n\t\tlock = &block->b_call->a_args.lock;\n\t} else\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tif (block->b_flags & B_QUEUED) {\n\t\tdprintk(\"lockd: nlmsvc_lock deferred block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\tif (block->b_granted) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\t}\n\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nlm_drop_reply;\n\t\tgoto out;\n\t}\n\n\tif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\tif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tif (!wait)\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tmode = lock_to_openmode(&lock->fl);\n\terror = vfs_lock_file(file->f_file[mode], F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tdprintk(\"lockd: vfs_lock_file returned %d\\n\", error);\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t \n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\tret = async_block ? nlm_lck_blocked : nlm_lck_denied;\n\t\t\tgoto out;\n\t\tcase FILE_LOCK_DEFERRED:\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tret = nlmsvc_defer_lock_rqst(rqstp, block);\n\t\t\tgoto out;\n\t\tcase -EDEADLK:\n\t\t\tret = nlm_deadlock;\n\t\t\tgoto out;\n\t\tdefault:\t\t\t \n\t\t\tret = nlm_lck_denied_nolocks;\n\t\t\tgoto out;\n\t}\n\n\tret = nlm_lck_blocked;\n\n\t \n\tnlmsvc_insert_block(block, NLM_NEVER);\nout:\n\tmutex_unlock(&file->f_mutex);\n\tnlmsvc_release_block(block);\n\tdprintk(\"lockd: nlmsvc_lock returned %u\\n\", ret);\n\treturn ret;\n}\n\n \n__be32\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t\tstruct nlm_host *host, struct nlm_lock *lock,\n\t\tstruct nlm_lock *conflock, struct nlm_cookie *cookie)\n{\n\tint\t\t\terror;\n\tint\t\t\tmode;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\",\n\t\t\t\tnlmsvc_file_inode(file)->i_sb->s_id,\n\t\t\t\tnlmsvc_file_inode(file)->i_ino,\n\t\t\t\tlock->fl.fl_type,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tmode = lock_to_openmode(&lock->fl);\n\terror = vfs_test_lock(file->f_file[mode], &lock->fl);\n\tif (error) {\n\t\t \n\t\tif (error == FILE_LOCK_DEFERRED)\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tret = nlm_lck_denied_nolocks;\n\t\tgoto out;\n\t}\n\n\tif (lock->fl.fl_type == F_UNLCK) {\n\t\tret = nlm_granted;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\",\n\t\tlock->fl.fl_type, (long long)lock->fl.fl_start,\n\t\t(long long)lock->fl.fl_end);\n\tconflock->caller = \"somehost\";\t \n\tconflock->len = strlen(conflock->caller);\n\tconflock->oh.len = 0;\t\t \n\tconflock->svid = lock->fl.fl_pid;\n\tconflock->fl.fl_type = lock->fl.fl_type;\n\tconflock->fl.fl_start = lock->fl.fl_start;\n\tconflock->fl.fl_end = lock->fl.fl_end;\n\tlocks_release_private(&lock->fl);\n\n\tret = nlm_lck_denied;\nout:\n\treturn ret;\n}\n\n \n__be32\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tint\terror = 0;\n\n\tdprintk(\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tnlmsvc_file_inode(file)->i_sb->s_id,\n\t\t\t\tnlmsvc_file_inode(file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\t \n\tnlmsvc_cancel_blocked(net, file, lock);\n\n\tlock->fl.fl_type = F_UNLCK;\n\tlock->fl.fl_file = file->f_file[O_RDONLY];\n\tif (lock->fl.fl_file)\n\t\terror = vfs_lock_file(lock->fl.fl_file, F_SETLK,\n\t\t\t\t\t&lock->fl, NULL);\n\tlock->fl.fl_file = file->f_file[O_WRONLY];\n\tif (lock->fl.fl_file)\n\t\terror |= vfs_lock_file(lock->fl.fl_file, F_SETLK,\n\t\t\t\t\t&lock->fl, NULL);\n\n\treturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\n}\n\n \n__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\tint mode;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tnlmsvc_file_inode(file)->i_sb->s_id,\n\t\t\t\tnlmsvc_file_inode(file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tstruct file_lock *fl = &block->b_call->a_args.lock.fl;\n\n\t\tmode = lock_to_openmode(fl);\n\t\tvfs_cancel_lock(block->b_file->f_file[mode], fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}\n\n \nstatic void\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\n{\n\tblock->b_flags |= B_GOT_CALLBACK;\n\tif (result == 0)\n\t\tblock->b_granted = 1;\n\telse\n\t\tblock->b_flags |= B_TIMED_OUT;\n}\n\nstatic int nlmsvc_grant_deferred(struct file_lock *fl, int result)\n{\n\tstruct nlm_block *block;\n\tint rc = -ENOENT;\n\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tdprintk(\"lockd: nlmsvc_notify_blocked block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\t\tif (block->b_flags & B_QUEUED) {\n\t\t\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\t\t\trc = -ENOLCK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnlmsvc_update_deferred_block(block, result);\n\t\t\t} else if (result == 0)\n\t\t\t\tblock->b_granted = 1;\n\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tif (rc == -ENOENT)\n\t\tprintk(KERN_WARNING \"lockd: grant for unknown block\\n\");\n\treturn rc;\n}\n\n \nstatic void\nnlmsvc_notify_blocked(struct file_lock *fl)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"lockd: VFS unblock notification for block %p\\n\", fl);\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tspin_unlock(&nlm_blocked_lock);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tprintk(KERN_WARNING \"lockd: notification for unknown block!\\n\");\n}\n\nstatic fl_owner_t nlmsvc_get_owner(fl_owner_t owner)\n{\n\treturn nlmsvc_get_lockowner(owner);\n}\n\nstatic void nlmsvc_put_owner(fl_owner_t owner)\n{\n\tnlmsvc_put_lockowner(owner);\n}\n\nconst struct lock_manager_operations nlmsvc_lock_operations = {\n\t.lm_notify = nlmsvc_notify_blocked,\n\t.lm_grant = nlmsvc_grant_deferred,\n\t.lm_get_owner = nlmsvc_get_owner,\n\t.lm_put_owner = nlmsvc_put_owner,\n};\n\n \nstatic void\nnlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\tmode;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t \n\tnlmsvc_unlink_block(block);\n\n\t \n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t \n\t \n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\tmode = lock_to_openmode(&lock->fl);\n\terror = vfs_lock_file(file->f_file[mode], F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t \n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t \n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t \n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t \n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}\n\n \nstatic void nlmsvc_grant_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tstruct nlm_block\t*block = call->a_block;\n\tunsigned long\t\ttimeout;\n\n\tdprintk(\"lockd: GRANT_MSG RPC callback\\n\");\n\n\tspin_lock(&nlm_blocked_lock);\n\t \n\tif (list_empty(&block->b_list))\n\t\tgoto out;\n\n\t \n\tif (task->tk_status < 0) {\n\t\t \n\t\ttimeout = 10 * HZ;\n\t} else {\n\t\t \n\t\ttimeout = 60 * HZ;\n\t}\n\tnlmsvc_insert_block_locked(block, timeout);\n\tsvc_wake_up(block->b_daemon);\nout:\n\tspin_unlock(&nlm_blocked_lock);\n}\n\n \nstatic void nlmsvc_grant_release(void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tnlmsvc_release_block(call->a_block);\n}\n\nstatic const struct rpc_call_ops nlmsvc_grant_ops = {\n\t.rpc_call_done = nlmsvc_grant_callback,\n\t.rpc_release = nlmsvc_grant_release,\n};\n\n \nvoid\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\tint\t\t\terror;\n\n\tdprintk(\"grant_reply: looking for cookie %x, s=%d \\n\",\n\t\t*(unsigned int *)(cookie->data), status);\n\tif (!(block = nlmsvc_find_block(cookie)))\n\t\treturn;\n\n\tswitch (status) {\n\tcase nlm_lck_denied_grace_period:\n\t\t \n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tbreak;\n\tcase nlm_lck_denied:\n\t\t \n\t\tnlmsvc_unlink_block(block);\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tfl->fl_type = F_UNLCK;\n\t\terror = vfs_lock_file(fl->fl_file, F_SETLK, fl, NULL);\n\t\tif (error)\n\t\t\tpr_warn(\"lockd: unable to unlock lock rejected by client!\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnlmsvc_unlink_block(block);\n\t}\n\tnlmsvc_release_block(block);\n}\n\n \nstatic void\nretry_deferred_block(struct nlm_block *block)\n{\n\tif (!(block->b_flags & B_GOT_CALLBACK))\n\t\tblock->b_flags |= B_TIMED_OUT;\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\tdprintk(\"revisit block %p flags %d\\n\",\tblock, block->b_flags);\n\tif (block->b_deferred_req) {\n\t\tblock->b_deferred_req->revisit(block->b_deferred_req, 0);\n\t\tblock->b_deferred_req = NULL;\n\t}\n}\n\n \nvoid\nnlmsvc_retry_blocked(void)\n{\n\tunsigned long\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tstruct nlm_block *block;\n\n\tspin_lock(&nlm_blocked_lock);\n\twhile (!list_empty(&nlm_blocked) && !kthread_should_stop()) {\n\t\tblock = list_entry(nlm_blocked.next, struct nlm_block, b_list);\n\n\t\tif (block->b_when == NLM_NEVER)\n\t\t\tbreak;\n\t\tif (time_after(block->b_when, jiffies)) {\n\t\t\ttimeout = block->b_when - jiffies;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nlm_blocked_lock);\n\n\t\tdprintk(\"nlmsvc_retry_blocked(%p, when=%ld)\\n\",\n\t\t\tblock, block->b_when);\n\t\tif (block->b_flags & B_QUEUED) {\n\t\t\tdprintk(\"nlmsvc_retry_blocked delete block (%p, granted=%d, flags=%d)\\n\",\n\t\t\t\tblock, block->b_granted, block->b_flags);\n\t\t\tretry_deferred_block(block);\n\t\t} else\n\t\t\tnlmsvc_grant_blocked(block);\n\t\tspin_lock(&nlm_blocked_lock);\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\tif (timeout < MAX_SCHEDULE_TIMEOUT)\n\t\tmod_timer(&nlmsvc_retry, jiffies + timeout);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}