{
  "module_name": "svcshare.c",
  "hash_id": "43864731385905978b8fdf8cd3d4620a001086a1eee937afd94d95b44d86bc80",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svcshare.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/unistd.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/share.h>\n\nstatic inline int\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\n{\n\treturn share->s_owner.len == oh->len\n\t    && !memcmp(share->s_owner.data, oh->data, oh->len);\n}\n\n__be32\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\tu8\t\t\t*ohdata;\n\n\tfor (share = file->f_shares; share; share = share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh))\n\t\t\tgoto update;\n\t\tif ((argp->fsm_access & share->s_mode)\n\t\t || (argp->fsm_mode   & share->s_access ))\n\t\t\treturn nlm_lck_denied;\n\t}\n\n\tshare = kmalloc(sizeof(*share) + oh->len,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (share == NULL)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t \n\tohdata = (u8 *) (share + 1);\n\tmemcpy(ohdata, oh->data, oh->len);\n\n\tshare->s_file\t    = file;\n\tshare->s_host       = host;\n\tshare->s_owner.data = ohdata;\n\tshare->s_owner.len  = oh->len;\n\tshare->s_next       = file->f_shares;\n\tfile->f_shares      = share;\n\nupdate:\n\tshare->s_access = argp->fsm_access;\n\tshare->s_mode   = argp->fsm_mode;\n\treturn nlm_granted;\n}\n\n \n__be32\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\n\t\t\tstruct nlm_args *argp)\n{\n\tstruct nlm_share\t*share, **shpp;\n\tstruct xdr_netobj\t*oh = &argp->lock.oh;\n\n\tfor (shpp = &file->f_shares; (share = *shpp) != NULL;\n\t\t\t\t\tshpp = &share->s_next) {\n\t\tif (share->s_host == host && nlm_cmp_owner(share, oh)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\treturn nlm_granted;\n\t\t}\n\t}\n\n\t \n\treturn nlm_granted;\n}\n\n \nvoid nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file,\n\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_share\t*share, **shpp;\n\n\tshpp = &file->f_shares;\n\twhile ((share = *shpp) !=  NULL) {\n\t\tif (match(share->s_host, host)) {\n\t\t\t*shpp = share->s_next;\n\t\t\tkfree(share);\n\t\t\tcontinue;\n\t\t}\n\t\tshpp = &share->s_next;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}