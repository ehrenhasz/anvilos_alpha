{
  "module_name": "trace.h",
  "hash_id": "3c3543a654440cba0dc82f67227e8e16ac20d8ec1da2d1b620a88ca070c374fd",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/trace.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM lockd\n\n#if !defined(_TRACE_LOCKD_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_LOCKD_H\n\n#include <linux/tracepoint.h>\n#include <linux/crc32.h>\n#include <linux/nfs.h>\n#include <linux/lockd/lockd.h>\n\n#ifdef CONFIG_LOCKD_V4\n#define NLM_STATUS_LIST\t\t\t\t\t\\\n\tnlm_status_code(LCK_GRANTED)\t\t\t\\\n\tnlm_status_code(LCK_DENIED)\t\t\t\\\n\tnlm_status_code(LCK_DENIED_NOLOCKS)\t\t\\\n\tnlm_status_code(LCK_BLOCKED)\t\t\t\\\n\tnlm_status_code(LCK_DENIED_GRACE_PERIOD)\t\\\n\tnlm_status_code(DEADLCK)\t\t\t\\\n\tnlm_status_code(ROFS)\t\t\t\t\\\n\tnlm_status_code(STALE_FH)\t\t\t\\\n\tnlm_status_code(FBIG)\t\t\t\t\\\n\tnlm_status_code_end(FAILED)\n#else\n#define NLM_STATUS_LIST\t\t\t\t\t\\\n\tnlm_status_code(LCK_GRANTED)\t\t\t\\\n\tnlm_status_code(LCK_DENIED)\t\t\t\\\n\tnlm_status_code(LCK_DENIED_NOLOCKS)\t\t\\\n\tnlm_status_code(LCK_BLOCKED)\t\t\t\\\n\tnlm_status_code_end(LCK_DENIED_GRACE_PERIOD)\n#endif\n\n#undef nlm_status_code\n#undef nlm_status_code_end\n#define nlm_status_code(x)\tTRACE_DEFINE_ENUM(NLM_##x);\n#define nlm_status_code_end(x)\tTRACE_DEFINE_ENUM(NLM_##x);\n\nNLM_STATUS_LIST\n\n#undef nlm_status_code\n#undef nlm_status_code_end\n#define nlm_status_code(x)\t{ NLM_##x, #x },\n#define nlm_status_code_end(x)\t{ NLM_##x, #x }\n\n#define show_nlm_status(x)\t__print_symbolic(x, NLM_STATUS_LIST)\n\nDECLARE_EVENT_CLASS(nlmclnt_lock_event,\n\t\tTP_PROTO(\n\t\t\tconst struct nlm_lock *lock,\n\t\t\tconst struct sockaddr *addr,\n\t\t\tunsigned int addrlen,\n\t\t\t__be32 status\n\t\t),\n\n\t\tTP_ARGS(lock, addr, addrlen, status),\n\n\t\tTP_STRUCT__entry(\n\t\t\t__field(u32, oh)\n\t\t\t__field(u32, svid)\n\t\t\t__field(u32, fh)\n\t\t\t__field(unsigned long, status)\n\t\t\t__field(u64, start)\n\t\t\t__field(u64, len)\n\t\t\t__sockaddr(addr, addrlen)\n\t\t),\n\n\t\tTP_fast_assign(\n\t\t\t__entry->oh = ~crc32_le(0xffffffff, lock->oh.data, lock->oh.len);\n\t\t\t__entry->svid = lock->svid;\n\t\t\t__entry->fh = nfs_fhandle_hash(&lock->fh);\n\t\t\t__entry->start = lock->lock_start;\n\t\t\t__entry->len = lock->lock_len;\n\t\t\t__entry->status = be32_to_cpu(status);\n\t\t\t__assign_sockaddr(addr, addr, addrlen);\n\t\t),\n\n\t\tTP_printk(\n\t\t\t\"addr=%pISpc oh=0x%08x svid=0x%08x fh=0x%08x start=%llu len=%llu status=%s\",\n\t\t\t__get_sockaddr(addr), __entry->oh, __entry->svid,\n\t\t\t__entry->fh, __entry->start, __entry->len,\n\t\t\tshow_nlm_status(__entry->status)\n\t\t)\n);\n\n#define DEFINE_NLMCLNT_EVENT(name)\t\t\t\t\\\n\tDEFINE_EVENT(nlmclnt_lock_event, name,\t\t\t\\\n\t\t\tTP_PROTO(\t\t\t\t\\\n\t\t\t\tconst struct nlm_lock *lock,\t\\\n\t\t\t\tconst struct sockaddr *addr,\t\\\n\t\t\t\tunsigned int addrlen,\t\t\\\n\t\t\t\t__be32\tstatus\t\t\t\\\n\t\t\t),\t\t\t\t\t\\\n\t\t\tTP_ARGS(lock, addr, addrlen, status))\n\nDEFINE_NLMCLNT_EVENT(nlmclnt_test);\nDEFINE_NLMCLNT_EVENT(nlmclnt_lock);\nDEFINE_NLMCLNT_EVENT(nlmclnt_unlock);\nDEFINE_NLMCLNT_EVENT(nlmclnt_grant);\n\n#endif  \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}