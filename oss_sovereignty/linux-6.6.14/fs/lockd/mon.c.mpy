{
  "module_name": "mon.c",
  "hash_id": "668b466aaf0d226a01b2fe20b6c5717638d0d43638e88ecbb6b262779a29f373",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/mon.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/lockd/lockd.h>\n\n#include <asm/unaligned.h>\n\n#include \"netns.h\"\n\n#define NLMDBG_FACILITY\t\tNLMDBG_MONITOR\n#define NSM_PROGRAM\t\t100024\n#define NSM_VERSION\t\t1\n\nenum {\n\tNSMPROC_NULL,\n\tNSMPROC_STAT,\n\tNSMPROC_MON,\n\tNSMPROC_UNMON,\n\tNSMPROC_UNMON_ALL,\n\tNSMPROC_SIMU_CRASH,\n\tNSMPROC_NOTIFY,\n};\n\nstruct nsm_args {\n\tstruct nsm_private\t*priv;\n\tu32\t\t\tprog;\t\t \n\tu32\t\t\tvers;\n\tu32\t\t\tproc;\n\n\tchar\t\t\t*mon_name;\n\tconst char\t\t*nodename;\n};\n\nstruct nsm_res {\n\tu32\t\t\tstatus;\n\tu32\t\t\tstate;\n};\n\nstatic const struct rpc_program\tnsm_program;\nstatic\t\t\t\tDEFINE_SPINLOCK(nsm_lock);\n\n \nu32\t__read_mostly\t\tnsm_local_state;\nbool\t__read_mostly\t\tnsm_use_hostnames;\n\nstatic inline struct sockaddr *nsm_addr(const struct nsm_handle *nsm)\n{\n\treturn (struct sockaddr *)&nsm->sm_addr;\n}\n\nstatic struct rpc_clnt *nsm_create(struct net *net, const char *nodename)\n{\n\tstruct sockaddr_in sin = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_LOOPBACK),\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t\t= net,\n\t\t.protocol\t\t= XPRT_TRANSPORT_TCP,\n\t\t.address\t\t= (struct sockaddr *)&sin,\n\t\t.addrsize\t\t= sizeof(sin),\n\t\t.servername\t\t= \"rpc.statd\",\n\t\t.nodename\t\t= nodename,\n\t\t.program\t\t= &nsm_program,\n\t\t.version\t\t= NSM_VERSION,\n\t\t.authflavor\t\t= RPC_AUTH_NULL,\n\t\t.flags\t\t\t= RPC_CLNT_CREATE_NOPING,\n\t\t.cred\t\t\t= current_cred(),\n\t};\n\n\treturn rpc_create(&args);\n}\n\nstatic int nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res,\n\t\t\t const struct nlm_host *host)\n{\n\tint\t\tstatus;\n\tstruct rpc_clnt *clnt;\n\tstruct nsm_args args = {\n\t\t.priv\t\t= &nsm->sm_priv,\n\t\t.prog\t\t= NLM_PROGRAM,\n\t\t.vers\t\t= 3,\n\t\t.proc\t\t= NLMPROC_NSM_NOTIFY,\n\t\t.mon_name\t= nsm->sm_mon_name,\n\t\t.nodename\t= host->nodename,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= res,\n\t};\n\n\tmemset(res, 0, sizeof(*res));\n\n\tclnt = nsm_create(host->net, host->nodename);\n\tif (IS_ERR(clnt)) {\n\t\tdprintk(\"lockd: failed to create NSM upcall transport, \"\n\t\t\t\"status=%ld, net=%x\\n\", PTR_ERR(clnt),\n\t\t\thost->net->ns.inum);\n\t\treturn PTR_ERR(clnt);\n\t}\n\n\tmsg.rpc_proc = &clnt->cl_procinfo[proc];\n\tstatus = rpc_call_sync(clnt, &msg, RPC_TASK_SOFTCONN);\n\tif (status == -ECONNREFUSED) {\n\t\tdprintk(\"lockd:\tNSM upcall RPC failed, status=%d, forcing rebind\\n\",\n\t\t\t\tstatus);\n\t\trpc_force_rebind(clnt);\n\t\tstatus = rpc_call_sync(clnt, &msg, RPC_TASK_SOFTCONN);\n\t}\n\tif (status < 0)\n\t\tdprintk(\"lockd: NSM upcall RPC failed, status=%d\\n\",\n\t\t\t\tstatus);\n\telse\n\t\tstatus = 0;\n\n\trpc_shutdown_client(clnt);\n\treturn status;\n}\n\n \nint nsm_monitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint\t\tstatus;\n\n\tdprintk(\"lockd: nsm_monitor(%s)\\n\", nsm->sm_name);\n\n\tif (nsm->sm_monitored)\n\t\treturn 0;\n\n\t \n\tnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\n\n\tstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res, host);\n\tif (unlikely(res.status != 0))\n\t\tstatus = -EIO;\n\tif (unlikely(status < 0)) {\n\t\tpr_notice_ratelimited(\"lockd: cannot monitor %s\\n\", nsm->sm_name);\n\t\treturn status;\n\t}\n\n\tnsm->sm_monitored = 1;\n\tif (unlikely(nsm_local_state != res.state)) {\n\t\tnsm_local_state = res.state;\n\t\tdprintk(\"lockd: NSM state changed to %d\\n\", nsm_local_state);\n\t}\n\treturn 0;\n}\n\n \nvoid nsm_unmonitor(const struct nlm_host *host)\n{\n\tstruct nsm_handle *nsm = host->h_nsmhandle;\n\tstruct nsm_res\tres;\n\tint status;\n\n\tif (refcount_read(&nsm->sm_count) == 1\n\t && nsm->sm_monitored && !nsm->sm_sticky) {\n\t\tdprintk(\"lockd: nsm_unmonitor(%s)\\n\", nsm->sm_name);\n\n\t\tstatus = nsm_mon_unmon(nsm, NSMPROC_UNMON, &res, host);\n\t\tif (res.status != 0)\n\t\t\tstatus = -EIO;\n\t\tif (status < 0)\n\t\t\tprintk(KERN_NOTICE \"lockd: cannot unmonitor %s\\n\",\n\t\t\t\t\tnsm->sm_name);\n\t\telse\n\t\t\tnsm->sm_monitored = 0;\n\t}\n}\n\nstatic struct nsm_handle *nsm_lookup_hostname(const struct list_head *nsm_handles,\n\t\t\t\t\tconst char *hostname, const size_t len)\n{\n\tstruct nsm_handle *nsm;\n\n\tlist_for_each_entry(nsm, nsm_handles, sm_link)\n\t\tif (strlen(nsm->sm_name) == len &&\n\t\t    memcmp(nsm->sm_name, hostname, len) == 0)\n\t\t\treturn nsm;\n\treturn NULL;\n}\n\nstatic struct nsm_handle *nsm_lookup_addr(const struct list_head *nsm_handles,\n\t\t\t\t\tconst struct sockaddr *sap)\n{\n\tstruct nsm_handle *nsm;\n\n\tlist_for_each_entry(nsm, nsm_handles, sm_link)\n\t\tif (rpc_cmp_addr(nsm_addr(nsm), sap))\n\t\t\treturn nsm;\n\treturn NULL;\n}\n\nstatic struct nsm_handle *nsm_lookup_priv(const struct list_head *nsm_handles,\n\t\t\t\t\tconst struct nsm_private *priv)\n{\n\tstruct nsm_handle *nsm;\n\n\tlist_for_each_entry(nsm, nsm_handles, sm_link)\n\t\tif (memcmp(nsm->sm_priv.data, priv->data,\n\t\t\t\t\tsizeof(priv->data)) == 0)\n\t\t\treturn nsm;\n\treturn NULL;\n}\n\n \nstatic void nsm_init_private(struct nsm_handle *nsm)\n{\n\tu64 *p = (u64 *)&nsm->sm_priv.data;\n\ts64 ns;\n\n\tns = ktime_get_ns();\n\tput_unaligned(ns, p);\n\tput_unaligned((unsigned long)nsm, p + 1);\n}\n\nstatic struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,\n\t\t\t\t\t    const size_t salen,\n\t\t\t\t\t    const char *hostname,\n\t\t\t\t\t    const size_t hostname_len)\n{\n\tstruct nsm_handle *new;\n\n\tif (!hostname)\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(*new) + hostname_len + 1, GFP_KERNEL);\n\tif (unlikely(new == NULL))\n\t\treturn NULL;\n\n\trefcount_set(&new->sm_count, 1);\n\tnew->sm_name = (char *)(new + 1);\n\tmemcpy(nsm_addr(new), sap, salen);\n\tnew->sm_addrlen = salen;\n\tnsm_init_private(new);\n\n\tif (rpc_ntop(nsm_addr(new), new->sm_addrbuf,\n\t\t\t\t\tsizeof(new->sm_addrbuf)) == 0)\n\t\t(void)snprintf(new->sm_addrbuf, sizeof(new->sm_addrbuf),\n\t\t\t\t\"unsupported address family\");\n\tmemcpy(new->sm_name, hostname, hostname_len);\n\tnew->sm_name[hostname_len] = '\\0';\n\n\treturn new;\n}\n\n \nstruct nsm_handle *nsm_get_handle(const struct net *net,\n\t\t\t\t  const struct sockaddr *sap,\n\t\t\t\t  const size_t salen, const char *hostname,\n\t\t\t\t  const size_t hostname_len)\n{\n\tstruct nsm_handle *cached, *new = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tif (hostname && memchr(hostname, '/', hostname_len) != NULL) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_WARNING \"Invalid hostname \\\"%.*s\\\" \"\n\t\t\t\t\t    \"in NFS lock request\\n\",\n\t\t\t\t(int)hostname_len, hostname);\n\t\t}\n\t\treturn NULL;\n\t}\n\nretry:\n\tspin_lock(&nsm_lock);\n\n\tif (nsm_use_hostnames && hostname != NULL)\n\t\tcached = nsm_lookup_hostname(&ln->nsm_handles,\n\t\t\t\t\thostname, hostname_len);\n\telse\n\t\tcached = nsm_lookup_addr(&ln->nsm_handles, sap);\n\n\tif (cached != NULL) {\n\t\trefcount_inc(&cached->sm_count);\n\t\tspin_unlock(&nsm_lock);\n\t\tkfree(new);\n\t\tdprintk(\"lockd: found nsm_handle for %s (%s), \"\n\t\t\t\t\"cnt %d\\n\", cached->sm_name,\n\t\t\t\tcached->sm_addrbuf,\n\t\t\t\trefcount_read(&cached->sm_count));\n\t\treturn cached;\n\t}\n\n\tif (new != NULL) {\n\t\tlist_add(&new->sm_link, &ln->nsm_handles);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: created nsm_handle for %s (%s)\\n\",\n\t\t\t\tnew->sm_name, new->sm_addrbuf);\n\t\treturn new;\n\t}\n\n\tspin_unlock(&nsm_lock);\n\n\tnew = nsm_create_handle(sap, salen, hostname, hostname_len);\n\tif (unlikely(new == NULL))\n\t\treturn NULL;\n\tgoto retry;\n}\n\n \nstruct nsm_handle *nsm_reboot_lookup(const struct net *net,\n\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nsm_handle *cached;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tspin_lock(&nsm_lock);\n\n\tcached = nsm_lookup_priv(&ln->nsm_handles, &info->priv);\n\tif (unlikely(cached == NULL)) {\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: never saw rebooted peer '%.*s' before\\n\",\n\t\t\t\tinfo->len, info->mon);\n\t\treturn cached;\n\t}\n\n\trefcount_inc(&cached->sm_count);\n\tspin_unlock(&nsm_lock);\n\n\tdprintk(\"lockd: host %s (%s) rebooted, cnt %d\\n\",\n\t\t\tcached->sm_name, cached->sm_addrbuf,\n\t\t\trefcount_read(&cached->sm_count));\n\treturn cached;\n}\n\n \nvoid nsm_release(struct nsm_handle *nsm)\n{\n\tif (refcount_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\n\t\tlist_del(&nsm->sm_link);\n\t\tspin_unlock(&nsm_lock);\n\t\tdprintk(\"lockd: destroyed nsm_handle for %s (%s)\\n\",\n\t\t\t\tnsm->sm_name, nsm->sm_addrbuf);\n\t\tkfree(nsm);\n\t}\n}\n\n \n\nstatic void encode_nsm_string(struct xdr_stream *xdr, const char *string)\n{\n\tconst u32 len = strlen(string);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\txdr_encode_opaque(p, string, len);\n}\n\n \nstatic void encode_mon_name(struct xdr_stream *xdr, const struct nsm_args *argp)\n{\n\tencode_nsm_string(xdr, argp->mon_name);\n}\n\n \nstatic void encode_my_id(struct xdr_stream *xdr, const struct nsm_args *argp)\n{\n\t__be32 *p;\n\n\tencode_nsm_string(xdr, argp->nodename);\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(argp->prog);\n\t*p++ = cpu_to_be32(argp->vers);\n\t*p = cpu_to_be32(argp->proc);\n}\n\n \nstatic void encode_mon_id(struct xdr_stream *xdr, const struct nsm_args *argp)\n{\n\tencode_mon_name(xdr, argp);\n\tencode_my_id(xdr, argp);\n}\n\n \nstatic void encode_priv(struct xdr_stream *xdr, const struct nsm_args *argp)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, SM_PRIV_SIZE);\n\txdr_encode_opaque_fixed(p, argp->priv->data, SM_PRIV_SIZE);\n}\n\nstatic void nsm_xdr_enc_mon(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t    const void *argp)\n{\n\tencode_mon_id(xdr, argp);\n\tencode_priv(xdr, argp);\n}\n\nstatic void nsm_xdr_enc_unmon(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t      const void *argp)\n{\n\tencode_mon_id(xdr, argp);\n}\n\nstatic int nsm_xdr_dec_stat_res(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct nsm_res *resp = data;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tresp->status = be32_to_cpup(p++);\n\tresp->state = be32_to_cpup(p);\n\n\tdprintk(\"lockd: %s status %d state %d\\n\",\n\t\t__func__, resp->status, resp->state);\n\treturn 0;\n}\n\nstatic int nsm_xdr_dec_stat(struct rpc_rqst *rqstp,\n\t\t\t    struct xdr_stream *xdr,\n\t\t\t    void *data)\n{\n\tstruct nsm_res *resp = data;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tresp->state = be32_to_cpup(p);\n\n\tdprintk(\"lockd: %s state %d\\n\", __func__, resp->state);\n\treturn 0;\n}\n\n#define SM_my_name_sz\t(1+XDR_QUADLEN(SM_MAXSTRLEN))\n#define SM_my_id_sz\t(SM_my_name_sz+3)\n#define SM_mon_name_sz\t(1+XDR_QUADLEN(SM_MAXSTRLEN))\n#define SM_mon_id_sz\t(SM_mon_name_sz+SM_my_id_sz)\n#define SM_priv_sz\t(XDR_QUADLEN(SM_PRIV_SIZE))\n#define SM_mon_sz\t(SM_mon_id_sz+SM_priv_sz)\n#define SM_monres_sz\t2\n#define SM_unmonres_sz\t1\n\nstatic const struct rpc_procinfo nsm_procedures[] = {\n[NSMPROC_MON] = {\n\t\t.p_proc\t\t= NSMPROC_MON,\n\t\t.p_encode\t= nsm_xdr_enc_mon,\n\t\t.p_decode\t= nsm_xdr_dec_stat_res,\n\t\t.p_arglen\t= SM_mon_sz,\n\t\t.p_replen\t= SM_monres_sz,\n\t\t.p_statidx\t= NSMPROC_MON,\n\t\t.p_name\t\t= \"MONITOR\",\n\t},\n[NSMPROC_UNMON] = {\n\t\t.p_proc\t\t= NSMPROC_UNMON,\n\t\t.p_encode\t= nsm_xdr_enc_unmon,\n\t\t.p_decode\t= nsm_xdr_dec_stat,\n\t\t.p_arglen\t= SM_mon_id_sz,\n\t\t.p_replen\t= SM_unmonres_sz,\n\t\t.p_statidx\t= NSMPROC_UNMON,\n\t\t.p_name\t\t= \"UNMONITOR\",\n\t},\n};\n\nstatic unsigned int nsm_version1_counts[ARRAY_SIZE(nsm_procedures)];\nstatic const struct rpc_version nsm_version1 = {\n\t.number\t\t= 1,\n\t.nrprocs\t= ARRAY_SIZE(nsm_procedures),\n\t.procs\t\t= nsm_procedures,\n\t.counts\t\t= nsm_version1_counts,\n};\n\nstatic const struct rpc_version *nsm_version[] = {\n\t[1] = &nsm_version1,\n};\n\nstatic struct rpc_stat\t\tnsm_stats;\n\nstatic const struct rpc_program nsm_program = {\n\t.name\t\t= \"statd\",\n\t.number\t\t= NSM_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(nsm_version),\n\t.version\t= nsm_version,\n\t.stats\t\t= &nsm_stats\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}