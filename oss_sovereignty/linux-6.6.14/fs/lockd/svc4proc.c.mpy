{
  "module_name": "svc4proc.c",
  "hash_id": "f36507975fb41e02a220e7596e2f917e7cfc2eea1c71022c9e16997049f81b2b",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svc4proc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/share.h>\n#include <linux/sunrpc/svc_xprt.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_CLIENT\n\n \nstatic __be32\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\t__be32\t\t\terror = 0;\n\n\t \n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\tif (lock->lock_start > OFFSET_MAX ||\n\t    (lock->lock_len && ((lock->lock_len - 1) > (OFFSET_MAX - lock->lock_start))))\n\t\treturn nlm4_fbig;\n\n\t \n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t \n\tif (filp != NULL) {\n\t\tint mode = lock_to_openmode(&lock->fl);\n\n\t\terror = nlm_lookup_file(rqstp, &file, lock);\n\t\tif (error)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t \n\t\tlock->fl.fl_flags = FL_POSIX;\n\t\tlock->fl.fl_file  = file->f_file[mode];\n\t\tlock->fl.fl_pid = current->tgid;\n\t\tlock->fl.fl_start = (loff_t)lock->lock_start;\n\t\tlock->fl.fl_end = lock->lock_len ?\n\t\t\t\t   (loff_t)(lock->lock_start + lock->lock_len - 1) :\n\t\t\t\t   OFFSET_MAX;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t\tnlmsvc_locks_init_private(&lock->fl, host, (pid_t)lock->svid);\n\t\tif (!lock->fl.fl_owner) {\n\t\t\t \n\t\t\tnlmsvc_release_host(host);\n\t\t\treturn nlm_lck_denied_nolocks;\n\t\t}\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n \tif (error)\n\t\treturn error;\t\n\treturn nlm_lck_denied_nolocks;\n}\n\n \nstatic __be32\nnlm4svc_proc_null(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: NULL          called\\n\");\n\treturn rpc_success;\n}\n\n \nstatic __be32\n__nlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\tstruct nlm_lockowner *test_owner;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: TEST4        called\\n\");\n\tresp->cookie = argp->cookie;\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\ttest_owner = argp->lock.fl.fl_owner;\n\t \n\tresp->status = nlmsvc_testlock(rqstp, file, host, &argp->lock, &resp->lock, &resp->cookie);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: TEST4        status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_put_lockowner(test_owner);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}\n\nstatic __be32\nnlm4svc_proc_test(struct svc_rqst *rqstp)\n{\n\treturn __nlm4svc_proc_test(rqstp, rqstp->rq_resp);\n}\n\nstatic __be32\n__nlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: LOCK          called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n#if 0\n\t \n\tif (host->h_nsmstate && host->h_nsmstate != argp->state) {\n\t\tresp->status = nlm_lck_denied_nolocks;\n\t} else\n#endif\n\n\t \n\tresp->status = nlmsvc_lock(rqstp, file, host, &argp->lock,\n\t\t\t\t\targp->block, &argp->cookie,\n\t\t\t\t\targp->reclaim);\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: LOCK         status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}\n\nstatic __be32\nnlm4svc_proc_lock(struct svc_rqst *rqstp)\n{\n\treturn __nlm4svc_proc_lock(rqstp, rqstp->rq_resp);\n}\n\nstatic __be32\n__nlm4svc_proc_cancel(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: CANCEL        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = nlmsvc_cancel_blocked(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: CANCEL        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\nstatic __be32\nnlm4svc_proc_cancel(struct svc_rqst *rqstp)\n{\n\treturn __nlm4svc_proc_cancel(rqstp, rqstp->rq_resp);\n}\n\n \nstatic __be32\n__nlm4svc_proc_unlock(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNLOCK        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = nlmsvc_unlock(SVC_NET(rqstp), file, &argp->lock);\n\n\tdprintk(\"lockd: UNLOCK        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\nstatic __be32\nnlm4svc_proc_unlock(struct svc_rqst *rqstp)\n{\n\treturn __nlm4svc_proc_unlock(rqstp, rqstp->rq_resp);\n}\n\n \nstatic __be32\n__nlm4svc_proc_granted(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tresp->cookie = argp->cookie;\n\n\tdprintk(\"lockd: GRANTED       called\\n\");\n\tresp->status = nlmclnt_grant(svc_addr(rqstp), &argp->lock);\n\tdprintk(\"lockd: GRANTED       status %d\\n\", ntohl(resp->status));\n\treturn rpc_success;\n}\n\nstatic __be32\nnlm4svc_proc_granted(struct svc_rqst *rqstp)\n{\n\treturn __nlm4svc_proc_granted(rqstp, rqstp->rq_resp);\n}\n\n \nstatic void nlm4svc_callback_exit(struct rpc_task *task, void *data)\n{\n}\n\nstatic void nlm4svc_callback_release(void *data)\n{\n\tnlmsvc_release_call(data);\n}\n\nstatic const struct rpc_call_ops nlm4svc_callback_ops = {\n\t.rpc_call_done = nlm4svc_callback_exit,\n\t.rpc_release = nlm4svc_callback_release,\n};\n\n \nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc,\n\t\t__be32 (*func)(struct svc_rqst *,  struct nlm_res *))\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, __nlm4svc_proc_test);\n}\n\nstatic __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, __nlm4svc_proc_lock);\n}\n\nstatic __be32 nlm4svc_proc_cancel_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: CANCEL_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_CANCEL_RES, __nlm4svc_proc_cancel);\n}\n\nstatic __be32 nlm4svc_proc_unlock_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: UNLOCK_MSG    called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_UNLOCK_RES, __nlm4svc_proc_unlock);\n}\n\nstatic __be32 nlm4svc_proc_granted_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: GRANTED_MSG   called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_GRANTED_RES, __nlm4svc_proc_granted);\n}\n\n \nstatic __be32\nnlm4svc_proc_share(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: SHARE         called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp)) && !argp->reclaim) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = nlmsvc_share_file(host, file, argp);\n\n\tdprintk(\"lockd: SHARE         status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlm4svc_proc_unshare(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNSHARE       called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = nlmsvc_unshare_file(host, file, argp);\n\n\tdprintk(\"lockd: UNSHARE       status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlm4svc_proc_nm_lock(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tdprintk(\"lockd: NM_LOCK       called\\n\");\n\n\targp->monitor = 0;\t\t \n\treturn nlm4svc_proc_lock(rqstp);\n}\n\n \nstatic __be32\nnlm4svc_proc_free_all(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\n\t \n\tif (nlm4svc_retrieve_args(rqstp, argp, &host, NULL))\n\t\treturn rpc_success;\n\n\tnlmsvc_free_host_resources(host);\n\tnlmsvc_release_host(host);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlm4svc_proc_sm_notify(struct svc_rqst *rqstp)\n{\n\tstruct nlm_reboot *argp = rqstp->rq_argp;\n\n\tdprintk(\"lockd: SM_NOTIFY     called\\n\");\n\n\tif (!nlm_privileged_requester(rqstp)) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_WARNING \"lockd: rejected NSM callback from %s\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn rpc_system_err;\n\t}\n\n\tnlm_host_rebooted(SVC_NET(rqstp), argp);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlm4svc_proc_granted_res(struct svc_rqst *rqstp)\n{\n\tstruct nlm_res *argp = rqstp->rq_argp;\n\n        if (!nlmsvc_ops)\n                return rpc_success;\n\n        dprintk(\"lockd: GRANTED_RES   called\\n\");\n\n        nlmsvc_grant_reply(&argp->cookie, argp->status);\n        return rpc_success;\n}\n\nstatic __be32\nnlm4svc_proc_unused(struct svc_rqst *rqstp)\n{\n\treturn rpc_proc_unavail;\n}\n\n\n \n\nstruct nlm_void\t\t\t{ int dummy; };\n\n#define\tCk\t(1+XDR_QUADLEN(NLM_MAXCOOKIELEN))\t \n#define\tNo\t(1+1024/4)\t\t\t\t \n#define\tSt\t1\t\t\t\t\t \n#define\tRg\t4\t\t\t\t\t \n\nconst struct svc_procedure nlmsvc_procedures4[24] = {\n\t[NLMPROC_NULL] = {\n\t\t.pc_func = nlm4svc_proc_null,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[NLMPROC_TEST] = {\n\t\t.pc_func = nlm4svc_proc_test,\n\t\t.pc_decode = nlm4svc_decode_testargs,\n\t\t.pc_encode = nlm4svc_encode_testres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+2+No+Rg,\n\t\t.pc_name = \"TEST\",\n\t},\n\t[NLMPROC_LOCK] = {\n\t\t.pc_func = nlm4svc_proc_lock,\n\t\t.pc_decode = nlm4svc_decode_lockargs,\n\t\t.pc_encode = nlm4svc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"LOCK\",\n\t},\n\t[NLMPROC_CANCEL] = {\n\t\t.pc_func = nlm4svc_proc_cancel,\n\t\t.pc_decode = nlm4svc_decode_cancargs,\n\t\t.pc_encode = nlm4svc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"CANCEL\",\n\t},\n\t[NLMPROC_UNLOCK] = {\n\t\t.pc_func = nlm4svc_proc_unlock,\n\t\t.pc_decode = nlm4svc_decode_unlockargs,\n\t\t.pc_encode = nlm4svc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"UNLOCK\",\n\t},\n\t[NLMPROC_GRANTED] = {\n\t\t.pc_func = nlm4svc_proc_granted,\n\t\t.pc_decode = nlm4svc_decode_testargs,\n\t\t.pc_encode = nlm4svc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"GRANTED\",\n\t},\n\t[NLMPROC_TEST_MSG] = {\n\t\t.pc_func = nlm4svc_proc_test_msg,\n\t\t.pc_decode = nlm4svc_decode_testargs,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"TEST_MSG\",\n\t},\n\t[NLMPROC_LOCK_MSG] = {\n\t\t.pc_func = nlm4svc_proc_lock_msg,\n\t\t.pc_decode = nlm4svc_decode_lockargs,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"LOCK_MSG\",\n\t},\n\t[NLMPROC_CANCEL_MSG] = {\n\t\t.pc_func = nlm4svc_proc_cancel_msg,\n\t\t.pc_decode = nlm4svc_decode_cancargs,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"CANCEL_MSG\",\n\t},\n\t[NLMPROC_UNLOCK_MSG] = {\n\t\t.pc_func = nlm4svc_proc_unlock_msg,\n\t\t.pc_decode = nlm4svc_decode_unlockargs,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNLOCK_MSG\",\n\t},\n\t[NLMPROC_GRANTED_MSG] = {\n\t\t.pc_func = nlm4svc_proc_granted_msg,\n\t\t.pc_decode = nlm4svc_decode_testargs,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"GRANTED_MSG\",\n\t},\n\t[NLMPROC_TEST_RES] = {\n\t\t.pc_func = nlm4svc_proc_null,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"TEST_RES\",\n\t},\n\t[NLMPROC_LOCK_RES] = {\n\t\t.pc_func = nlm4svc_proc_null,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"LOCK_RES\",\n\t},\n\t[NLMPROC_CANCEL_RES] = {\n\t\t.pc_func = nlm4svc_proc_null,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"CANCEL_RES\",\n\t},\n\t[NLMPROC_UNLOCK_RES] = {\n\t\t.pc_func = nlm4svc_proc_null,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNLOCK_RES\",\n\t},\n\t[NLMPROC_GRANTED_RES] = {\n\t\t.pc_func = nlm4svc_proc_granted_res,\n\t\t.pc_decode = nlm4svc_decode_res,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"GRANTED_RES\",\n\t},\n\t[NLMPROC_NSM_NOTIFY] = {\n\t\t.pc_func = nlm4svc_proc_sm_notify,\n\t\t.pc_decode = nlm4svc_decode_reboot,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_reboot),\n\t\t.pc_argzero = sizeof(struct nlm_reboot),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"SM_NOTIFY\",\n\t},\n\t[17] = {\n\t\t.pc_func = nlm4svc_proc_unused,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[18] = {\n\t\t.pc_func = nlm4svc_proc_unused,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[19] = {\n\t\t.pc_func = nlm4svc_proc_unused,\n\t\t.pc_decode = nlm4svc_decode_void,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[NLMPROC_SHARE] = {\n\t\t.pc_func = nlm4svc_proc_share,\n\t\t.pc_decode = nlm4svc_decode_shareargs,\n\t\t.pc_encode = nlm4svc_encode_shareres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+1,\n\t\t.pc_name = \"SHARE\",\n\t},\n\t[NLMPROC_UNSHARE] = {\n\t\t.pc_func = nlm4svc_proc_unshare,\n\t\t.pc_decode = nlm4svc_decode_shareargs,\n\t\t.pc_encode = nlm4svc_encode_shareres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+1,\n\t\t.pc_name = \"UNSHARE\",\n\t},\n\t[NLMPROC_NM_LOCK] = {\n\t\t.pc_func = nlm4svc_proc_nm_lock,\n\t\t.pc_decode = nlm4svc_decode_lockargs,\n\t\t.pc_encode = nlm4svc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"NM_LOCK\",\n\t},\n\t[NLMPROC_FREE_ALL] = {\n\t\t.pc_func = nlm4svc_proc_free_all,\n\t\t.pc_decode = nlm4svc_decode_notify,\n\t\t.pc_encode = nlm4svc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"FREE_ALL\",\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}