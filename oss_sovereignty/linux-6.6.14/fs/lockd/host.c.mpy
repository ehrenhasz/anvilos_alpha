{
  "module_name": "host.c",
  "hash_id": "3a901911d5396a293e431559d4d201b7b53ffc19fb639550be3944b7e1d85f7d",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/host.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/lockd/lockd.h>\n#include <linux/mutex.h>\n\n#include <linux/sunrpc/svc_xprt.h>\n\n#include <net/ipv6.h>\n\n#include \"netns.h\"\n\n#define NLMDBG_FACILITY\t\tNLMDBG_HOSTCACHE\n#define NLM_HOST_NRHASH\t\t32\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n#define NLM_HOST_EXPIRE\t\t(300 * HZ)\n#define NLM_HOST_COLLECT\t(120 * HZ)\n\nstatic struct hlist_head\tnlm_server_hosts[NLM_HOST_NRHASH];\nstatic struct hlist_head\tnlm_client_hosts[NLM_HOST_NRHASH];\n\n#define for_each_host(host, chain, table) \\\n\tfor ((chain) = (table); \\\n\t     (chain) < (table) + NLM_HOST_NRHASH; ++(chain)) \\\n\t\thlist_for_each_entry((host), (chain), h_hash)\n\n#define for_each_host_safe(host, next, chain, table) \\\n\tfor ((chain) = (table); \\\n\t     (chain) < (table) + NLM_HOST_NRHASH; ++(chain)) \\\n\t\thlist_for_each_entry_safe((host), (next), \\\n\t\t\t\t\t\t(chain), h_hash)\n\nstatic unsigned long\t\tnrhosts;\nstatic DEFINE_MUTEX(nlm_host_mutex);\n\nstatic void\t\t\tnlm_gc_hosts(struct net *net);\n\nstruct nlm_lookup_host_info {\n\tconst int\t\tserver;\t\t \n\tconst struct sockaddr\t*sap;\t\t \n\tconst size_t\t\tsalen;\t\t \n\tconst unsigned short\tprotocol;\t \n\tconst u32\t\tversion;\t \n\tconst char\t\t*hostname;\t \n\tconst size_t\t\thostname_len;\t \n\tconst int\t\tnoresvport;\t \n\tstruct net\t\t*net;\t\t \n\tconst struct cred\t*cred;\n};\n\n \nstatic unsigned int __nlm_hash32(const __be32 n)\n{\n\tunsigned int hash = (__force u32)n ^ ((__force u32)n >> 16);\n\treturn hash ^ (hash >> 8);\n}\n\nstatic unsigned int __nlm_hash_addr4(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\treturn __nlm_hash32(sin->sin_addr.s_addr);\n}\n\nstatic unsigned int __nlm_hash_addr6(const struct sockaddr *sap)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr addr = sin6->sin6_addr;\n\treturn __nlm_hash32(addr.s6_addr32[0]) ^\n\t       __nlm_hash32(addr.s6_addr32[1]) ^\n\t       __nlm_hash32(addr.s6_addr32[2]) ^\n\t       __nlm_hash32(addr.s6_addr32[3]);\n}\n\nstatic unsigned int nlm_hash_address(const struct sockaddr *sap)\n{\n\tunsigned int hash;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\thash = __nlm_hash_addr4(sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\thash = __nlm_hash_addr6(sap);\n\t\tbreak;\n\tdefault:\n\t\thash = 0;\n\t}\n\treturn hash & (NLM_HOST_NRHASH - 1);\n}\n\n \nstatic struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,\n\t\t\t\t       struct nsm_handle *nsm)\n{\n\tstruct nlm_host *host = NULL;\n\tunsigned long now = jiffies;\n\n\tif (nsm != NULL)\n\t\trefcount_inc(&nsm->sm_count);\n\telse {\n\t\thost = NULL;\n\t\tnsm = nsm_get_handle(ni->net, ni->sap, ni->salen,\n\t\t\t\t\tni->hostname, ni->hostname_len);\n\t\tif (unlikely(nsm == NULL)) {\n\t\t\tdprintk(\"lockd: %s failed; no nsm handle\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thost = kmalloc(sizeof(*host), GFP_KERNEL);\n\tif (unlikely(host == NULL)) {\n\t\tdprintk(\"lockd: %s failed; no memory\\n\", __func__);\n\t\tnsm_release(nsm);\n\t\tgoto out;\n\t}\n\n\tmemcpy(nlm_addr(host), ni->sap, ni->salen);\n\thost->h_addrlen    = ni->salen;\n\trpc_set_port(nlm_addr(host), 0);\n\thost->h_srcaddrlen = 0;\n\n\thost->h_rpcclnt    = NULL;\n\thost->h_name\t   = nsm->sm_name;\n\thost->h_version    = ni->version;\n\thost->h_proto      = ni->protocol;\n\thost->h_reclaiming = 0;\n\thost->h_server     = ni->server;\n\thost->h_noresvport = ni->noresvport;\n\thost->h_inuse      = 0;\n\tinit_waitqueue_head(&host->h_gracewait);\n\tinit_rwsem(&host->h_rwsem);\n\thost->h_state      = 0;\n\thost->h_nsmstate   = 0;\n\thost->h_pidcount   = 0;\n\trefcount_set(&host->h_count, 1);\n\tmutex_init(&host->h_mutex);\n\thost->h_nextrebind = now + NLM_HOST_REBIND;\n\thost->h_expires    = now + NLM_HOST_EXPIRE;\n\tINIT_LIST_HEAD(&host->h_lockowners);\n\tspin_lock_init(&host->h_lock);\n\tINIT_LIST_HEAD(&host->h_granted);\n\tINIT_LIST_HEAD(&host->h_reclaim);\n\thost->h_nsmhandle  = nsm;\n\thost->h_addrbuf    = nsm->sm_addrbuf;\n\thost->net\t   = ni->net;\n\thost->h_cred\t   = get_cred(ni->cred);\n\tstrscpy(host->nodename, utsname()->nodename, sizeof(host->nodename));\n\nout:\n\treturn host;\n}\n\n \nstatic void nlm_destroy_host_locked(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\tstruct lockd_net *ln = net_generic(host->net, lockd_net_id);\n\n\tdprintk(\"lockd: destroy host %s\\n\", host->h_name);\n\n\thlist_del_init(&host->h_hash);\n\n\tnsm_unmonitor(host);\n\tnsm_release(host->h_nsmhandle);\n\n\tclnt = host->h_rpcclnt;\n\tif (clnt != NULL)\n\t\trpc_shutdown_client(clnt);\n\tput_cred(host->h_cred);\n\tkfree(host);\n\n\tln->nrhosts--;\n\tnrhosts--;\n}\n\n \nstruct nlm_host *nlmclnt_lookup_host(const struct sockaddr *sap,\n\t\t\t\t     const size_t salen,\n\t\t\t\t     const unsigned short protocol,\n\t\t\t\t     const u32 version,\n\t\t\t\t     const char *hostname,\n\t\t\t\t     int noresvport,\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct cred *cred)\n{\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 0,\n\t\t.sap\t\t= sap,\n\t\t.salen\t\t= salen,\n\t\t.protocol\t= protocol,\n\t\t.version\t= version,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= strlen(hostname),\n\t\t.noresvport\t= noresvport,\n\t\t.net\t\t= net,\n\t\t.cred\t\t= cred,\n\t};\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(hostname ? hostname : \"<none>\"), version,\n\t\t\t(protocol == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tchain = &nlm_client_hosts[nlm_hash_address(sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), sap))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != version)\n\t\t\tcontinue;\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\", __func__,\n\t\t\thost->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\", __func__,\n\t\thost->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}\n\n \nvoid nlmclnt_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release client host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(host->h_server);\n\n\tif (refcount_dec_and_mutex_lock(&host->h_count, &nlm_host_mutex)) {\n\t\tWARN_ON_ONCE(!list_empty(&host->h_lockowners));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_granted));\n\t\tWARN_ON_ONCE(!list_empty(&host->h_reclaim));\n\n\t\tnlm_destroy_host_locked(host);\n\t\tmutex_unlock(&nlm_host_mutex);\n\t}\n}\n\n \nstruct nlm_host *nlmsvc_lookup_host(const struct svc_rqst *rqstp,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    const size_t hostname_len)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host = NULL;\n\tstruct nsm_handle *nsm = NULL;\n\tstruct sockaddr *src_sap = svc_daddr(rqstp);\n\tsize_t src_len = rqstp->rq_daddrlen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nlm_lookup_host_info ni = {\n\t\t.server\t\t= 1,\n\t\t.sap\t\t= svc_addr(rqstp),\n\t\t.salen\t\t= rqstp->rq_addrlen,\n\t\t.protocol\t= rqstp->rq_prot,\n\t\t.version\t= rqstp->rq_vers,\n\t\t.hostname\t= hostname,\n\t\t.hostname_len\t= hostname_len,\n\t\t.net\t\t= net,\n\t};\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tdprintk(\"lockd: %s(host='%.*s', vers=%u, proto=%s)\\n\", __func__,\n\t\t\t(int)hostname_len, hostname, rqstp->rq_vers,\n\t\t\t(rqstp->rq_prot == IPPROTO_UDP ? \"udp\" : \"tcp\"));\n\n\tmutex_lock(&nlm_host_mutex);\n\n\tif (time_after_eq(jiffies, ln->next_gc))\n\t\tnlm_gc_hosts(net);\n\n\tchain = &nlm_server_hosts[nlm_hash_address(ni.sap)];\n\thlist_for_each_entry(host, chain, h_hash) {\n\t\tif (host->net != net)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(host), ni.sap))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (nsm == NULL)\n\t\t\tnsm = host->h_nsmhandle;\n\n\t\tif (host->h_proto != ni.protocol)\n\t\t\tcontinue;\n\t\tif (host->h_version != ni.version)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_srcaddr(host), src_sap))\n\t\t\tcontinue;\n\n\t\t \n\t\thlist_del(&host->h_hash);\n\t\thlist_add_head(&host->h_hash, chain);\n\n\t\tnlm_get_host(host);\n\t\tdprintk(\"lockd: %s found host %s (%s)\\n\",\n\t\t\t__func__, host->h_name, host->h_addrbuf);\n\t\tgoto out;\n\t}\n\n\thost = nlm_alloc_host(&ni, nsm);\n\tif (unlikely(host == NULL))\n\t\tgoto out;\n\n\tmemcpy(nlm_srcaddr(host), src_sap, src_len);\n\thost->h_srcaddrlen = src_len;\n\thlist_add_head(&host->h_hash, chain);\n\tln->nrhosts++;\n\tnrhosts++;\n\n\trefcount_inc(&host->h_count);\n\n\tdprintk(\"lockd: %s created host %s (%s)\\n\",\n\t\t__func__, host->h_name, host->h_addrbuf);\n\nout:\n\tmutex_unlock(&nlm_host_mutex);\n\treturn host;\n}\n\n \nvoid nlmsvc_release_host(struct nlm_host *host)\n{\n\tif (host == NULL)\n\t\treturn;\n\n\tdprintk(\"lockd: release server host %s\\n\", host->h_name);\n\n\tWARN_ON_ONCE(!host->h_server);\n\trefcount_dec(&host->h_count);\n}\n\n \nstruct rpc_clnt *\nnlm_bind_host(struct nlm_host *host)\n{\n\tstruct rpc_clnt\t*clnt;\n\n\tdprintk(\"lockd: nlm_bind_host %s (%s)\\n\",\n\t\t\thost->h_name, host->h_addrbuf);\n\n\t \n\tmutex_lock(&host->h_mutex);\n\n\t \n\tif ((clnt = host->h_rpcclnt) != NULL) {\n\t\tnlm_rebind_host(host);\n\t} else {\n\t\tunsigned long increment = nlmsvc_timeout;\n\t\tstruct rpc_timeout timeparms = {\n\t\t\t.to_initval\t= increment,\n\t\t\t.to_increment\t= increment,\n\t\t\t.to_maxval\t= increment * 6UL,\n\t\t\t.to_retries\t= 5U,\n\t\t};\n\t\tstruct rpc_create_args args = {\n\t\t\t.net\t\t= host->net,\n\t\t\t.protocol\t= host->h_proto,\n\t\t\t.address\t= nlm_addr(host),\n\t\t\t.addrsize\t= host->h_addrlen,\n\t\t\t.timeout\t= &timeparms,\n\t\t\t.servername\t= host->h_name,\n\t\t\t.program\t= &nlm_program,\n\t\t\t.version\t= host->h_version,\n\t\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\t   RPC_CLNT_CREATE_AUTOBIND |\n\t\t\t\t\t   RPC_CLNT_CREATE_REUSEPORT),\n\t\t\t.cred\t\t= host->h_cred,\n\t\t};\n\n\t\t \n\t\tif (!host->h_server)\n\t\t\targs.flags |= RPC_CLNT_CREATE_HARDRTRY;\n\t\tif (host->h_noresvport)\n\t\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\t\tif (host->h_srcaddrlen)\n\t\t\targs.saddress = nlm_srcaddr(host);\n\n\t\tclnt = rpc_create(&args);\n\t\tif (!IS_ERR(clnt))\n\t\t\thost->h_rpcclnt = clnt;\n\t\telse {\n\t\t\tprintk(\"lockd: couldn't create RPC handle for %s\\n\", host->h_name);\n\t\t\tclnt = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&host->h_mutex);\n\treturn clnt;\n}\n\n \nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tif (host->h_proto != IPPROTO_UDP)\n\t\treturn;\n\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}\n\n \nstruct nlm_host * nlm_get_host(struct nlm_host *host)\n{\n\tif (host) {\n\t\tdprintk(\"lockd: get host %s\\n\", host->h_name);\n\t\trefcount_inc(&host->h_count);\n\t\thost->h_expires = jiffies + NLM_HOST_EXPIRE;\n\t}\n\treturn host;\n}\n\nstatic struct nlm_host *next_host_state(struct hlist_head *cache,\n\t\t\t\t\tstruct nsm_handle *nsm,\n\t\t\t\t\tconst struct nlm_reboot *info)\n{\n\tstruct nlm_host *host;\n\tstruct hlist_head *chain;\n\n\tmutex_lock(&nlm_host_mutex);\n\tfor_each_host(host, chain, cache) {\n\t\tif (host->h_nsmhandle == nsm\n\t\t    && host->h_nsmstate != info->state) {\n\t\t\thost->h_nsmstate = info->state;\n\t\t\thost->h_state++;\n\n\t\t\tnlm_get_host(host);\n\t\t\tmutex_unlock(&nlm_host_mutex);\n\t\t\treturn host;\n\t\t}\n\t}\n\n\tmutex_unlock(&nlm_host_mutex);\n\treturn NULL;\n}\n\n \nvoid nlm_host_rebooted(const struct net *net, const struct nlm_reboot *info)\n{\n\tstruct nsm_handle *nsm;\n\tstruct nlm_host\t*host;\n\n\tnsm = nsm_reboot_lookup(net, info);\n\tif (unlikely(nsm == NULL))\n\t\treturn;\n\n\t \n\twhile ((host = next_host_state(nlm_server_hosts, nsm, info)) != NULL) {\n\t\tnlmsvc_free_host_resources(host);\n\t\tnlmsvc_release_host(host);\n\t}\n\twhile ((host = next_host_state(nlm_client_hosts, nsm, info)) != NULL) {\n\t\tnlmclnt_recovery(host);\n\t\tnlmclnt_release_host(host);\n\t}\n\n\tnsm_release(nsm);\n}\n\nstatic void nlm_complain_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tif (ln->nrhosts == 0)\n\t\t\treturn;\n\t\tpr_warn(\"lockd: couldn't shutdown host module for net %x!\\n\",\n\t\t\tnet->ns.inum);\n\t\tdprintk(\"lockd: %lu hosts left in net %x:\\n\", ln->nrhosts,\n\t\t\tnet->ns.inum);\n\t} else {\n\t\tif (nrhosts == 0)\n\t\t\treturn;\n\t\tprintk(KERN_WARNING \"lockd: couldn't shutdown host module!\\n\");\n\t\tdprintk(\"lockd: %lu hosts left:\\n\", nrhosts);\n\t}\n\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tdprintk(\"       %s (cnt %d use %d exp %ld net %x)\\n\",\n\t\t\thost->h_name, refcount_read(&host->h_count),\n\t\t\thost->h_inuse, host->h_expires, host->net->ns.inum);\n\t}\n}\n\nvoid\nnlm_shutdown_hosts_net(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct nlm_host\t*host;\n\n\tmutex_lock(&nlm_host_mutex);\n\n\t \n\tdprintk(\"lockd: nuking all hosts in net %x...\\n\",\n\t\tnet ? net->ns.inum : 0);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_expires = jiffies - 1;\n\t\tif (host->h_rpcclnt) {\n\t\t\trpc_shutdown_client(host->h_rpcclnt);\n\t\t\thost->h_rpcclnt = NULL;\n\t\t}\n\t\tnlmsvc_free_host_resources(host);\n\t}\n\n\t \n\tnlm_gc_hosts(net);\n\tnlm_complain_hosts(net);\n\tmutex_unlock(&nlm_host_mutex);\n}\n\n \nvoid\nnlm_shutdown_hosts(void)\n{\n\tdprintk(\"lockd: shutting down host module\\n\");\n\tnlm_shutdown_hosts_net(NULL);\n}\n\n \nstatic void\nnlm_gc_hosts(struct net *net)\n{\n\tstruct hlist_head *chain;\n\tstruct hlist_node *next;\n\tstruct nlm_host\t*host;\n\n\tdprintk(\"lockd: host garbage collection for net %x\\n\",\n\t\tnet ? net->ns.inum : 0);\n\tfor_each_host(host, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\thost->h_inuse = 0;\n\t}\n\n\t \n\tnlmsvc_mark_resources(net);\n\n\tfor_each_host_safe(host, next, chain, nlm_server_hosts) {\n\t\tif (net && host->net != net)\n\t\t\tcontinue;\n\t\tif (host->h_inuse || time_before(jiffies, host->h_expires)) {\n\t\t\tdprintk(\"nlm_gc_hosts skipping %s \"\n\t\t\t\t\"(cnt %d use %d exp %ld net %x)\\n\",\n\t\t\t\thost->h_name, refcount_read(&host->h_count),\n\t\t\t\thost->h_inuse, host->h_expires,\n\t\t\t\thost->net->ns.inum);\n\t\t\tcontinue;\n\t\t}\n\t\tif (refcount_dec_if_one(&host->h_count))\n\t\t\tnlm_destroy_host_locked(host);\n\t}\n\n\tif (net) {\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tln->next_gc = jiffies + NLM_HOST_COLLECT;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}