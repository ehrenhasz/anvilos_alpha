{
  "module_name": "clntlock.c",
  "hash_id": "7d34f84417809e39a5ade0e33a897cd6e35f5bda7401a3d36a198bd1e0aaaa95",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/clntlock.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/lockd.h>\n#include <linux/kthread.h>\n\n#include \"trace.h\"\n\n#define NLMDBG_FACILITY\t\tNLMDBG_CLIENT\n\n \nstatic int\t\t\treclaimer(void *ptr);\n\n \n\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\n \nstruct nlm_host *nlmclnt_init(const struct nlmclnt_initdata *nlm_init)\n{\n\tstruct nlm_host *host;\n\tu32 nlm_version = (nlm_init->nfs_version == 2) ? 1 : 4;\n\tint status;\n\n\tstatus = lockd_up(nlm_init->net, nlm_init->cred);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\thost = nlmclnt_lookup_host(nlm_init->address, nlm_init->addrlen,\n\t\t\t\t   nlm_init->protocol, nlm_version,\n\t\t\t\t   nlm_init->hostname, nlm_init->noresvport,\n\t\t\t\t   nlm_init->net, nlm_init->cred);\n\tif (host == NULL)\n\t\tgoto out_nohost;\n\tif (host->h_rpcclnt == NULL && nlm_bind_host(host) == NULL)\n\t\tgoto out_nobind;\n\n\thost->h_nlmclnt_ops = nlm_init->nlmclnt_ops;\n\treturn host;\nout_nobind:\n\tnlmclnt_release_host(host);\nout_nohost:\n\tlockd_down(nlm_init->net);\n\treturn ERR_PTR(-ENOLCK);\n}\nEXPORT_SYMBOL_GPL(nlmclnt_init);\n\n \nvoid nlmclnt_done(struct nlm_host *host)\n{\n\tstruct net *net = host->net;\n\n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n}\nEXPORT_SYMBOL_GPL(nlmclnt_done);\n\nvoid nlmclnt_prepare_block(struct nlm_wait *block, struct nlm_host *host, struct file_lock *fl)\n{\n\tblock->b_host = host;\n\tblock->b_lock = fl;\n\tinit_waitqueue_head(&block->b_wait);\n\tblock->b_status = nlm_lck_blocked;\n}\n\nstruct rpc_clnt *nlmclnt_rpc_clnt(struct nlm_host *host)\n{\n\treturn host->h_rpcclnt;\n}\nEXPORT_SYMBOL_GPL(nlmclnt_rpc_clnt);\n\n \nvoid nlmclnt_queue_block(struct nlm_wait *block)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tlist_add(&block->b_list, &nlm_blocked);\n\tspin_unlock(&nlm_blocked_lock);\n}\n\n \n__be32 nlmclnt_dequeue_block(struct nlm_wait *block)\n{\n\t__be32 status;\n\n\tspin_lock(&nlm_blocked_lock);\n\tlist_del(&block->b_list);\n\tstatus = block->b_status;\n\tspin_unlock(&nlm_blocked_lock);\n\treturn status;\n}\n\n \nint nlmclnt_wait(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\n{\n\tlong ret;\n\n\t \n\tif (block == NULL)\n\t\treturn -EAGAIN;\n\n\t \n\tret = wait_event_interruptible_timeout(block->b_wait,\n\t\t\tblock->b_status != nlm_lck_blocked,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\t \n\tif (block->b_status == nlm_lck_denied_grace_period)\n\t\tblock->b_status = nlm_lck_blocked;\n\treturn 0;\n}\n\n \n__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\tconst struct nfs_fh *fh = &lock->fh;\n\tstruct nlm_wait\t*block;\n\t__be32 res = nlm_lck_denied;\n\n\t \n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tstruct file_lock *fl_blocked = block->b_lock;\n\n\t\tif (fl_blocked->fl_start != fl->fl_start)\n\t\t\tcontinue;\n\t\tif (fl_blocked->fl_end != fl->fl_end)\n\t\t\tcontinue;\n\t\t \n\t\tif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\n\t\t\tcontinue;\n\t\tif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\n\t\t\tcontinue;\n\t\tif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)), fh) != 0)\n\t\t\tcontinue;\n\t\t \n\t\tblock->b_status = nlm_granted;\n\t\twake_up(&block->b_wait);\n\t\tres = nlm_granted;\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\ttrace_nlmclnt_grant(lock, addr, svc_addr_len(addr), res);\n\treturn res;\n}\n\n \n\n \nvoid\nnlmclnt_recovery(struct nlm_host *host)\n{\n\tstruct task_struct *task;\n\n\tif (!host->h_reclaiming++) {\n\t\tnlm_get_host(host);\n\t\ttask = kthread_run(reclaimer, host, \"%s-reclaim\", host->h_name);\n\t\tif (IS_ERR(task))\n\t\t\tprintk(KERN_ERR \"lockd: unable to spawn reclaimer \"\n\t\t\t\t\"thread. Locks for %s won't be reclaimed! \"\n\t\t\t\t\"(%ld)\\n\", host->h_name, PTR_ERR(task));\n\t}\n}\n\nstatic int\nreclaimer(void *ptr)\n{\n\tstruct nlm_host\t  *host = (struct nlm_host *) ptr;\n\tstruct nlm_wait\t  *block;\n\tstruct nlm_rqst   *req;\n\tstruct file_lock *fl, *next;\n\tu32 nsmstate;\n\tstruct net *net = host->net;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn 0;\n\n\tallow_signal(SIGKILL);\n\n\tdown_write(&host->h_rwsem);\n\tlockd_up(net, NULL);\t \n\n\tdprintk(\"lockd: reclaiming locks for host %s\\n\", host->h_name);\n\nrestart:\n\tnsmstate = host->h_nsmstate;\n\n\t \n\thost->h_nextrebind = jiffies;\n\tnlm_rebind_host(host);\n\n\t \n\tlist_splice_init(&host->h_granted, &host->h_reclaim);\n\tlist_for_each_entry_safe(fl, next, &host->h_reclaim, fl_u.nfs_fl.list) {\n\t\tlist_del_init(&fl->fl_u.nfs_fl.list);\n\n\t\t \n\t\tif (signalled())\n\t\t\tcontinue;\n\t\tif (nlmclnt_reclaim(host, fl, req) != 0)\n\t\t\tcontinue;\n\t\tlist_add_tail(&fl->fl_u.nfs_fl.list, &host->h_granted);\n\t\tif (host->h_nsmstate != nsmstate) {\n\t\t\t \n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\thost->h_reclaiming = 0;\n\tup_write(&host->h_rwsem);\n\tdprintk(\"NLM: done reclaiming locks for host %s\\n\", host->h_name);\n\n\t \n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (block->b_host == host) {\n\t\t\tblock->b_status = nlm_lck_denied_grace_period;\n\t\t\twake_up(&block->b_wait);\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\t \n\tnlmclnt_release_host(host);\n\tlockd_down(net);\n\tkfree(req);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}