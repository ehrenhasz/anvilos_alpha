{
  "module_name": "xdr4.c",
  "hash_id": "fb7f0907d3be16f3e6d6958b6ae358330773dd53282eb1f4a6c54b80e73a56ed",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/xdr4.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/nfs.h>\n\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/lockd/lockd.h>\n\n#include \"svcxdr.h\"\n\nstatic inline s64\nloff_t_to_s64(loff_t offset)\n{\n\ts64 res;\n\tif (offset > NLM4_OFFSET_MAX)\n\t\tres = NLM4_OFFSET_MAX;\n\telse if (offset < -NLM4_OFFSET_MAX)\n\t\tres = -NLM4_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}\n\nvoid nlm4svc_set_file_lock_range(struct file_lock *fl, u64 off, u64 len)\n{\n\ts64 end = off + len - 1;\n\n\tfl->fl_start = off;\n\tif (len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = end;\n}\n\n \nstatic bool\nsvcxdr_decode_fhandle(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn false;\n\tif (len > NFS_MAXFHSIZE)\n\t\treturn false;\n\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p)\n\t\treturn false;\n\tfh->size = len;\n\tmemcpy(fh->data, p, len);\n\tmemset(fh->data + len, 0, sizeof(fh->data) - len);\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_decode_lock(struct xdr_stream *xdr, struct nlm_lock *lock)\n{\n\tstruct file_lock *fl = &lock->fl;\n\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (!svcxdr_decode_fhandle(xdr, &lock->fh))\n\t\treturn false;\n\tif (!svcxdr_decode_owner(xdr, &lock->oh))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &lock->svid) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &lock->lock_start) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u64(xdr, &lock->lock_len) < 0)\n\t\treturn false;\n\n\tlocks_init_lock(fl);\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = F_RDLCK;\n\tnlm4svc_set_file_lock_range(fl, lock->lock_start, lock->lock_len);\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_holder(struct xdr_stream *xdr, const struct nlm_lock *lock)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\ts64 start, len;\n\n\t \n\tif (xdr_stream_encode_bool(xdr, fl->fl_type != F_RDLCK) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, lock->svid) < 0)\n\t\treturn false;\n\tif (!svcxdr_encode_owner(xdr, &lock->oh))\n\t\treturn false;\n\tstart = loff_t_to_s64(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\tlen = 0;\n\telse\n\t\tlen = loff_t_to_s64(fl->fl_end - fl->fl_start + 1);\n\tif (xdr_stream_encode_u64(xdr, start) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u64(xdr, len) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nsvcxdr_encode_testrply(struct xdr_stream *xdr, const struct nlm_res *resp)\n{\n\tif (!svcxdr_encode_stats(xdr, resp->status))\n\t\treturn false;\n\tswitch (resp->status) {\n\tcase nlm_lck_denied:\n\t\tif (!svcxdr_encode_holder(xdr, &resp->lock))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n \n\nbool\nnlm4svc_decode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nbool\nnlm4svc_decode_testargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_lockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &argp->block) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\tif (xdr_stream_decode_bool(xdr, &argp->reclaim) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\targp->monitor = 1;\t\t \n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_cancargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tu32 exclusive;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &argp->block) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_bool(xdr, &exclusive) < 0)\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\tif (exclusive)\n\t\targp->lock.fl.fl_type = F_WRLCK;\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_unlockargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_lock(xdr, &argp->lock))\n\t\treturn false;\n\targp->lock.fl.fl_type = F_UNLCK;\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_argp;\n\n\tif (!svcxdr_decode_cookie(xdr, &resp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_stats(xdr, &resp->status))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_reboot(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_reboot *argp = rqstp->rq_argp;\n\t__be32 *p;\n\tu32 len;\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn false;\n\tif (len > SM_MAXSTRLEN)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p)\n\t\treturn false;\n\targp->len = len;\n\targp->mon = (char *)p;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\tp = xdr_inline_decode(xdr, SM_PRIV_SIZE);\n\tif (!p)\n\t\treturn false;\n\tmemcpy(&argp->priv.data, p, sizeof(argp->priv.data));\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_shareargs(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(&lock->fl);\n\tlock->svid = ~(u32)0;\n\n\tif (!svcxdr_decode_cookie(xdr, &argp->cookie))\n\t\treturn false;\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (!svcxdr_decode_fhandle(xdr, &lock->fh))\n\t\treturn false;\n\tif (!svcxdr_decode_owner(xdr, &lock->oh))\n\t\treturn false;\n\t \n\tif (xdr_stream_decode_u32(xdr, &argp->fsm_mode) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->fsm_access) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnlm4svc_decode_notify(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_lock\t*lock = &argp->lock;\n\n\tif (!svcxdr_decode_string(xdr, &lock->caller, &lock->len))\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &argp->state) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n\n \n\nbool\nnlm4svc_encode_void(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\treturn true;\n}\n\nbool\nnlm4svc_encode_testres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_cookie(xdr, &resp->cookie) &&\n\t\tsvcxdr_encode_testrply(xdr, resp);\n}\n\nbool\nnlm4svc_encode_res(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\treturn svcxdr_encode_cookie(xdr, &resp->cookie) &&\n\t\tsvcxdr_encode_stats(xdr, resp->status);\n}\n\nbool\nnlm4svc_encode_shareres(struct svc_rqst *rqstp, struct xdr_stream *xdr)\n{\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\n\tif (!svcxdr_encode_cookie(xdr, &resp->cookie))\n\t\treturn false;\n\tif (!svcxdr_encode_stats(xdr, resp->status))\n\t\treturn false;\n\t \n\tif (xdr_stream_encode_u32(xdr, 0) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}