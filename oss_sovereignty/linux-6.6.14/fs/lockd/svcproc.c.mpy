{
  "module_name": "svcproc.c",
  "hash_id": "fd11dae358cbc86c177e5febce0e8700075c39f3d3b018b473bbbf31e9b1a0d0",
  "original_prompt": "Ingested from linux-6.6.14/fs/lockd/svcproc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/share.h>\n#include <linux/sunrpc/svc_xprt.h>\n\n#define NLMDBG_FACILITY\t\tNLMDBG_CLIENT\n\n#ifdef CONFIG_LOCKD_V4\nstatic __be32\ncast_to_nlm(__be32 status, u32 vers)\n{\n\t \n\tif (vers != 4){\n\t\tswitch (status) {\n\t\tcase nlm_granted:\n\t\tcase nlm_lck_denied:\n\t\tcase nlm_lck_denied_nolocks:\n\t\tcase nlm_lck_blocked:\n\t\tcase nlm_lck_denied_grace_period:\n\t\tcase nlm_drop_reply:\n\t\t\tbreak;\n\t\tcase nlm4_deadlock:\n\t\t\tstatus = nlm_lck_denied;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nlm_lck_denied_nolocks;\n\t\t}\n\t}\n\n\treturn (status);\n}\n#define\tcast_status(status) (cast_to_nlm(status, rqstp->rq_vers))\n#else\n#define cast_status(status) (status)\n#endif\n\n \nstatic __be32\nnlmsvc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\tstruct nlm_host **hostp, struct nlm_file **filp)\n{\n\tstruct nlm_host\t\t*host = NULL;\n\tstruct nlm_file\t\t*file = NULL;\n\tstruct nlm_lock\t\t*lock = &argp->lock;\n\tint\t\t\tmode;\n\t__be32\t\t\terror = 0;\n\n\t \n\tif (!nlmsvc_ops)\n\t\treturn nlm_lck_denied_nolocks;\n\n\t \n\tif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\n\t || (argp->monitor && nsm_monitor(host) < 0))\n\t\tgoto no_locks;\n\t*hostp = host;\n\n\t \n\tif (filp != NULL) {\n\t\terror = cast_status(nlm_lookup_file(rqstp, &file, lock));\n\t\tif (error != 0)\n\t\t\tgoto no_locks;\n\t\t*filp = file;\n\n\t\t \n\t\tmode = lock_to_openmode(&lock->fl);\n\t\tlock->fl.fl_flags = FL_POSIX;\n\t\tlock->fl.fl_file  = file->f_file[mode];\n\t\tlock->fl.fl_pid = current->tgid;\n\t\tlock->fl.fl_lmops = &nlmsvc_lock_operations;\n\t\tnlmsvc_locks_init_private(&lock->fl, host, (pid_t)lock->svid);\n\t\tif (!lock->fl.fl_owner) {\n\t\t\t \n\t\t\tnlmsvc_release_host(host);\n\t\t\treturn nlm_lck_denied_nolocks;\n\t\t}\n\t}\n\n\treturn 0;\n\nno_locks:\n\tnlmsvc_release_host(host);\n\tif (error)\n\t\treturn error;\n\treturn nlm_lck_denied_nolocks;\n}\n\n \nstatic __be32\nnlmsvc_proc_null(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: NULL          called\\n\");\n\treturn rpc_success;\n}\n\n \nstatic __be32\n__nlmsvc_proc_test(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\tstruct nlm_lockowner *test_owner;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: TEST          called\\n\");\n\tresp->cookie = argp->cookie;\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\ttest_owner = argp->lock.fl.fl_owner;\n\n\t \n\tresp->status = cast_status(nlmsvc_testlock(rqstp, file, host, &argp->lock, &resp->lock, &resp->cookie));\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: TEST          status %d vers %d\\n\",\n\t\t\tntohl(resp->status), rqstp->rq_vers);\n\n\tnlmsvc_put_lockowner(test_owner);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}\n\nstatic __be32\nnlmsvc_proc_test(struct svc_rqst *rqstp)\n{\n\treturn __nlmsvc_proc_test(rqstp, rqstp->rq_resp);\n}\n\nstatic __be32\n__nlmsvc_proc_lock(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\t__be32 rc = rpc_success;\n\n\tdprintk(\"lockd: LOCK          called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n#if 0\n\t \n\tif (host->h_nsmstate && host->h_nsmstate != argp->state) {\n\t\tresp->status = nlm_lck_denied_nolocks;\n\t} else\n#endif\n\n\t \n\tresp->status = cast_status(nlmsvc_lock(rqstp, file, host, &argp->lock,\n\t\t\t\t\t       argp->block, &argp->cookie,\n\t\t\t\t\t       argp->reclaim));\n\tif (resp->status == nlm_drop_reply)\n\t\trc = rpc_drop_reply;\n\telse\n\t\tdprintk(\"lockd: LOCK         status %d\\n\", ntohl(resp->status));\n\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rc;\n}\n\nstatic __be32\nnlmsvc_proc_lock(struct svc_rqst *rqstp)\n{\n\treturn __nlmsvc_proc_lock(rqstp, rqstp->rq_resp);\n}\n\nstatic __be32\n__nlmsvc_proc_cancel(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tdprintk(\"lockd: CANCEL        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(net)) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = cast_status(nlmsvc_cancel_blocked(net, file, &argp->lock));\n\n\tdprintk(\"lockd: CANCEL        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\nstatic __be32\nnlmsvc_proc_cancel(struct svc_rqst *rqstp)\n{\n\treturn __nlmsvc_proc_cancel(rqstp, rqstp->rq_resp);\n}\n\n \nstatic __be32\n__nlmsvc_proc_unlock(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tdprintk(\"lockd: UNLOCK        called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(net)) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = cast_status(nlmsvc_unlock(net, file, &argp->lock));\n\n\tdprintk(\"lockd: UNLOCK        status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\nstatic __be32\nnlmsvc_proc_unlock(struct svc_rqst *rqstp)\n{\n\treturn __nlmsvc_proc_unlock(rqstp, rqstp->rq_resp);\n}\n\n \nstatic __be32\n__nlmsvc_proc_granted(struct svc_rqst *rqstp, struct nlm_res *resp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tresp->cookie = argp->cookie;\n\n\tdprintk(\"lockd: GRANTED       called\\n\");\n\tresp->status = nlmclnt_grant(svc_addr(rqstp), &argp->lock);\n\tdprintk(\"lockd: GRANTED       status %d\\n\", ntohl(resp->status));\n\treturn rpc_success;\n}\n\nstatic __be32\nnlmsvc_proc_granted(struct svc_rqst *rqstp)\n{\n\treturn __nlmsvc_proc_granted(rqstp, rqstp->rq_resp);\n}\n\n \nstatic void nlmsvc_callback_exit(struct rpc_task *task, void *data)\n{\n}\n\nvoid nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!refcount_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}\n\nstatic void nlmsvc_callback_release(void *data)\n{\n\tnlmsvc_release_call(data);\n}\n\nstatic const struct rpc_call_ops nlmsvc_callback_ops = {\n\t.rpc_call_done = nlmsvc_callback_exit,\n\t.rpc_release = nlmsvc_callback_release,\n};\n\n \nstatic __be32 nlmsvc_callback(struct svc_rqst *rqstp, u32 proc,\n\t\t__be32 (*func)(struct svc_rqst *, struct nlm_res *))\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_rqst\t*call;\n\t__be32 stat;\n\n\thost = nlmsvc_lookup_host(rqstp,\n\t\t\t\t  argp->lock.caller,\n\t\t\t\t  argp->lock.len);\n\tif (host == NULL)\n\t\treturn rpc_system_err;\n\n\tcall = nlm_alloc_call(host);\n\tnlmsvc_release_host(host);\n\tif (call == NULL)\n\t\treturn rpc_system_err;\n\n\tstat = func(rqstp, &call->a_res);\n\tif (stat != 0) {\n\t\tnlmsvc_release_call(call);\n\t\treturn stat;\n\t}\n\n\tcall->a_flags = RPC_TASK_ASYNC;\n\tif (nlm_async_reply(call, proc, &nlmsvc_callback_ops) < 0)\n\t\treturn rpc_system_err;\n\treturn rpc_success;\n}\n\nstatic __be32 nlmsvc_proc_test_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlmsvc_callback(rqstp, NLMPROC_TEST_RES, __nlmsvc_proc_test);\n}\n\nstatic __be32 nlmsvc_proc_lock_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: LOCK_MSG      called\\n\");\n\treturn nlmsvc_callback(rqstp, NLMPROC_LOCK_RES, __nlmsvc_proc_lock);\n}\n\nstatic __be32 nlmsvc_proc_cancel_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: CANCEL_MSG    called\\n\");\n\treturn nlmsvc_callback(rqstp, NLMPROC_CANCEL_RES, __nlmsvc_proc_cancel);\n}\n\nstatic __be32\nnlmsvc_proc_unlock_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: UNLOCK_MSG    called\\n\");\n\treturn nlmsvc_callback(rqstp, NLMPROC_UNLOCK_RES, __nlmsvc_proc_unlock);\n}\n\nstatic __be32\nnlmsvc_proc_granted_msg(struct svc_rqst *rqstp)\n{\n\tdprintk(\"lockd: GRANTED_MSG   called\\n\");\n\treturn nlmsvc_callback(rqstp, NLMPROC_GRANTED_RES, __nlmsvc_proc_granted);\n}\n\n \nstatic __be32\nnlmsvc_proc_share(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: SHARE         called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp)) && !argp->reclaim) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = cast_status(nlmsvc_share_file(host, file, argp));\n\n\tdprintk(\"lockd: SHARE         status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlmsvc_proc_unshare(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_res *resp = rqstp->rq_resp;\n\tstruct nlm_host\t*host;\n\tstruct nlm_file\t*file;\n\n\tdprintk(\"lockd: UNSHARE       called\\n\");\n\n\tresp->cookie = argp->cookie;\n\n\t \n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tresp->status = nlm_lck_denied_grace_period;\n\t\treturn rpc_success;\n\t}\n\n\t \n\tif ((resp->status = nlmsvc_retrieve_args(rqstp, argp, &host, &file)))\n\t\treturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\n\n\t \n\tresp->status = cast_status(nlmsvc_unshare_file(host, file, argp));\n\n\tdprintk(\"lockd: UNSHARE       status %d\\n\", ntohl(resp->status));\n\tnlmsvc_release_lockowner(&argp->lock);\n\tnlmsvc_release_host(host);\n\tnlm_release_file(file);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlmsvc_proc_nm_lock(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\n\tdprintk(\"lockd: NM_LOCK       called\\n\");\n\n\targp->monitor = 0;\t\t \n\treturn nlmsvc_proc_lock(rqstp);\n}\n\n \nstatic __be32\nnlmsvc_proc_free_all(struct svc_rqst *rqstp)\n{\n\tstruct nlm_args *argp = rqstp->rq_argp;\n\tstruct nlm_host\t*host;\n\n\t \n\tif (nlmsvc_retrieve_args(rqstp, argp, &host, NULL))\n\t\treturn rpc_success;\n\n\tnlmsvc_free_host_resources(host);\n\tnlmsvc_release_host(host);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlmsvc_proc_sm_notify(struct svc_rqst *rqstp)\n{\n\tstruct nlm_reboot *argp = rqstp->rq_argp;\n\n\tdprintk(\"lockd: SM_NOTIFY     called\\n\");\n\n\tif (!nlm_privileged_requester(rqstp)) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_WARNING \"lockd: rejected NSM callback from %s\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn rpc_system_err;\n\t}\n\n\tnlm_host_rebooted(SVC_NET(rqstp), argp);\n\treturn rpc_success;\n}\n\n \nstatic __be32\nnlmsvc_proc_granted_res(struct svc_rqst *rqstp)\n{\n\tstruct nlm_res *argp = rqstp->rq_argp;\n\n\tif (!nlmsvc_ops)\n\t\treturn rpc_success;\n\n\tdprintk(\"lockd: GRANTED_RES   called\\n\");\n\n\tnlmsvc_grant_reply(&argp->cookie, argp->status);\n\treturn rpc_success;\n}\n\nstatic __be32\nnlmsvc_proc_unused(struct svc_rqst *rqstp)\n{\n\treturn rpc_proc_unavail;\n}\n\n \n\nstruct nlm_void\t\t\t{ int dummy; };\n\n#define\tCk\t(1+XDR_QUADLEN(NLM_MAXCOOKIELEN))\t \n#define\tSt\t1\t\t\t\t \n#define\tNo\t(1+1024/4)\t\t\t \n#define\tRg\t2\t\t\t\t \n\nconst struct svc_procedure nlmsvc_procedures[24] = {\n\t[NLMPROC_NULL] = {\n\t\t.pc_func = nlmsvc_proc_null,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"NULL\",\n\t},\n\t[NLMPROC_TEST] = {\n\t\t.pc_func = nlmsvc_proc_test,\n\t\t.pc_decode = nlmsvc_decode_testargs,\n\t\t.pc_encode = nlmsvc_encode_testres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+2+No+Rg,\n\t\t.pc_name = \"TEST\",\n\t},\n\t[NLMPROC_LOCK] = {\n\t\t.pc_func = nlmsvc_proc_lock,\n\t\t.pc_decode = nlmsvc_decode_lockargs,\n\t\t.pc_encode = nlmsvc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"LOCK\",\n\t},\n\t[NLMPROC_CANCEL] = {\n\t\t.pc_func = nlmsvc_proc_cancel,\n\t\t.pc_decode = nlmsvc_decode_cancargs,\n\t\t.pc_encode = nlmsvc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"CANCEL\",\n\t},\n\t[NLMPROC_UNLOCK] = {\n\t\t.pc_func = nlmsvc_proc_unlock,\n\t\t.pc_decode = nlmsvc_decode_unlockargs,\n\t\t.pc_encode = nlmsvc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"UNLOCK\",\n\t},\n\t[NLMPROC_GRANTED] = {\n\t\t.pc_func = nlmsvc_proc_granted,\n\t\t.pc_decode = nlmsvc_decode_testargs,\n\t\t.pc_encode = nlmsvc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"GRANTED\",\n\t},\n\t[NLMPROC_TEST_MSG] = {\n\t\t.pc_func = nlmsvc_proc_test_msg,\n\t\t.pc_decode = nlmsvc_decode_testargs,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"TEST_MSG\",\n\t},\n\t[NLMPROC_LOCK_MSG] = {\n\t\t.pc_func = nlmsvc_proc_lock_msg,\n\t\t.pc_decode = nlmsvc_decode_lockargs,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"LOCK_MSG\",\n\t},\n\t[NLMPROC_CANCEL_MSG] = {\n\t\t.pc_func = nlmsvc_proc_cancel_msg,\n\t\t.pc_decode = nlmsvc_decode_cancargs,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"CANCEL_MSG\",\n\t},\n\t[NLMPROC_UNLOCK_MSG] = {\n\t\t.pc_func = nlmsvc_proc_unlock_msg,\n\t\t.pc_decode = nlmsvc_decode_unlockargs,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNLOCK_MSG\",\n\t},\n\t[NLMPROC_GRANTED_MSG] = {\n\t\t.pc_func = nlmsvc_proc_granted_msg,\n\t\t.pc_decode = nlmsvc_decode_testargs,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"GRANTED_MSG\",\n\t},\n\t[NLMPROC_TEST_RES] = {\n\t\t.pc_func = nlmsvc_proc_null,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"TEST_RES\",\n\t},\n\t[NLMPROC_LOCK_RES] = {\n\t\t.pc_func = nlmsvc_proc_null,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"LOCK_RES\",\n\t},\n\t[NLMPROC_CANCEL_RES] = {\n\t\t.pc_func = nlmsvc_proc_null,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"CANCEL_RES\",\n\t},\n\t[NLMPROC_UNLOCK_RES] = {\n\t\t.pc_func = nlmsvc_proc_null,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNLOCK_RES\",\n\t},\n\t[NLMPROC_GRANTED_RES] = {\n\t\t.pc_func = nlmsvc_proc_granted_res,\n\t\t.pc_decode = nlmsvc_decode_res,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_res),\n\t\t.pc_argzero = sizeof(struct nlm_res),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"GRANTED_RES\",\n\t},\n\t[NLMPROC_NSM_NOTIFY] = {\n\t\t.pc_func = nlmsvc_proc_sm_notify,\n\t\t.pc_decode = nlmsvc_decode_reboot,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_reboot),\n\t\t.pc_argzero = sizeof(struct nlm_reboot),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"SM_NOTIFY\",\n\t},\n\t[17] = {\n\t\t.pc_func = nlmsvc_proc_unused,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[18] = {\n\t\t.pc_func = nlmsvc_proc_unused,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[19] = {\n\t\t.pc_func = nlmsvc_proc_unused,\n\t\t.pc_decode = nlmsvc_decode_void,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_void),\n\t\t.pc_argzero = sizeof(struct nlm_void),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = St,\n\t\t.pc_name = \"UNUSED\",\n\t},\n\t[NLMPROC_SHARE] = {\n\t\t.pc_func = nlmsvc_proc_share,\n\t\t.pc_decode = nlmsvc_decode_shareargs,\n\t\t.pc_encode = nlmsvc_encode_shareres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+1,\n\t\t.pc_name = \"SHARE\",\n\t},\n\t[NLMPROC_UNSHARE] = {\n\t\t.pc_func = nlmsvc_proc_unshare,\n\t\t.pc_decode = nlmsvc_decode_shareargs,\n\t\t.pc_encode = nlmsvc_encode_shareres,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St+1,\n\t\t.pc_name = \"UNSHARE\",\n\t},\n\t[NLMPROC_NM_LOCK] = {\n\t\t.pc_func = nlmsvc_proc_nm_lock,\n\t\t.pc_decode = nlmsvc_decode_lockargs,\n\t\t.pc_encode = nlmsvc_encode_res,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_res),\n\t\t.pc_xdrressize = Ck+St,\n\t\t.pc_name = \"NM_LOCK\",\n\t},\n\t[NLMPROC_FREE_ALL] = {\n\t\t.pc_func = nlmsvc_proc_free_all,\n\t\t.pc_decode = nlmsvc_decode_notify,\n\t\t.pc_encode = nlmsvc_encode_void,\n\t\t.pc_argsize = sizeof(struct nlm_args),\n\t\t.pc_argzero = sizeof(struct nlm_args),\n\t\t.pc_ressize = sizeof(struct nlm_void),\n\t\t.pc_xdrressize = 0,\n\t\t.pc_name = \"FREE_ALL\",\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}