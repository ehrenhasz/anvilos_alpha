{
  "module_name": "remap_range.c",
  "hash_id": "46debb81a9750bbb0c1e9d7994df1bb6eeed8e02befa762498cca3d1fe7b624b",
  "original_prompt": "Ingested from linux-6.6.14/fs/remap_range.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/sched/xacct.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/uio.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/splice.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/overflow.h>\n#include \"internal.h\"\n\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n\n \nstatic int generic_remap_checks(struct file *file_in, loff_t pos_in,\n\t\t\t\tstruct file *file_out, loff_t pos_out,\n\t\t\t\tloff_t *req_count, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_in->f_mapping->host;\n\tstruct inode *inode_out = file_out->f_mapping->host;\n\tuint64_t count = *req_count;\n\tuint64_t bcount;\n\tloff_t size_in, size_out;\n\tloff_t bs = inode_out->i_sb->s_blocksize;\n\tint ret;\n\n\t \n\tif (!IS_ALIGNED(pos_in, bs) || !IS_ALIGNED(pos_out, bs))\n\t\treturn -EINVAL;\n\n\t \n\tif (pos_in + count < pos_in || pos_out + count < pos_out)\n\t\treturn -EINVAL;\n\n\tsize_in = i_size_read(inode_in);\n\tsize_out = i_size_read(inode_out);\n\n\t \n\tif ((remap_flags & REMAP_FILE_DEDUP) &&\n\t    (pos_in >= size_in || pos_in + count > size_in ||\n\t     pos_out >= size_out || pos_out + count > size_out))\n\t\treturn -EINVAL;\n\n\t \n\tif (pos_in >= size_in)\n\t\treturn -EINVAL;\n\tcount = min(count, size_in - (uint64_t)pos_in);\n\n\tret = generic_write_check_limits(file_out, pos_out, &count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pos_in + count == size_in &&\n\t    (!(remap_flags & REMAP_FILE_DEDUP) || pos_out + count == size_out)) {\n\t\tbcount = ALIGN(size_in, bs) - pos_in;\n\t} else {\n\t\tif (!IS_ALIGNED(count, bs))\n\t\t\tcount = ALIGN_DOWN(count, bs);\n\t\tbcount = count;\n\t}\n\n\t \n\tif (inode_in == inode_out &&\n\t    pos_out + bcount > pos_in &&\n\t    pos_out < pos_in + bcount)\n\t\treturn -EINVAL;\n\n\t \n\tif (*req_count != count && !(remap_flags & REMAP_FILE_CAN_SHORTEN))\n\t\treturn -EINVAL;\n\n\t*req_count = count;\n\treturn 0;\n}\n\nstatic int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tloff_t tmp;\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(check_add_overflow(pos, len, &tmp)))\n\t\treturn -EINVAL;\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}\n\n \nstatic int generic_remap_check_len(struct inode *inode_in,\n\t\t\t\t   struct inode *inode_out,\n\t\t\t\t   loff_t pos_out,\n\t\t\t\t   loff_t *len,\n\t\t\t\t   unsigned int remap_flags)\n{\n\tu64 blkmask = i_blocksize(inode_in) - 1;\n\tloff_t new_len = *len;\n\n\tif ((*len & blkmask) == 0)\n\t\treturn 0;\n\n\tif (pos_out + *len < i_size_read(inode_out))\n\t\tnew_len &= ~blkmask;\n\n\tif (new_len == *len)\n\t\treturn 0;\n\n\tif (remap_flags & REMAP_FILE_CAN_SHORTEN) {\n\t\t*len = new_len;\n\t\treturn 0;\n\t}\n\n\treturn (remap_flags & REMAP_FILE_DEDUP) ? -EBADE : -EINVAL;\n}\n\n \nstatic struct folio *vfs_dedupe_get_folio(struct file *file, loff_t pos)\n{\n\treturn read_mapping_folio(file->f_mapping, pos >> PAGE_SHIFT, file);\n}\n\n \nstatic void vfs_lock_two_folios(struct folio *folio1, struct folio *folio2)\n{\n\t \n\tif (folio1->index > folio2->index)\n\t\tswap(folio1, folio2);\n\n\tfolio_lock(folio1);\n\tif (folio1 != folio2)\n\t\tfolio_lock(folio2);\n}\n\n \nstatic void vfs_unlock_two_folios(struct folio *folio1, struct folio *folio2)\n{\n\tfolio_unlock(folio1);\n\tif (folio1 != folio2)\n\t\tfolio_unlock(folio2);\n}\n\n \nstatic int vfs_dedupe_file_range_compare(struct file *src, loff_t srcoff,\n\t\t\t\t\t struct file *dest, loff_t dstoff,\n\t\t\t\t\t loff_t len, bool *is_same)\n{\n\tbool same = true;\n\tint error = -EINVAL;\n\n\twhile (len) {\n\t\tstruct folio *src_folio, *dst_folio;\n\t\tvoid *src_addr, *dst_addr;\n\t\tloff_t cmp_len = min(PAGE_SIZE - offset_in_page(srcoff),\n\t\t\t\t     PAGE_SIZE - offset_in_page(dstoff));\n\n\t\tcmp_len = min(cmp_len, len);\n\t\tif (cmp_len <= 0)\n\t\t\tgoto out_error;\n\n\t\tsrc_folio = vfs_dedupe_get_folio(src, srcoff);\n\t\tif (IS_ERR(src_folio)) {\n\t\t\terror = PTR_ERR(src_folio);\n\t\t\tgoto out_error;\n\t\t}\n\t\tdst_folio = vfs_dedupe_get_folio(dest, dstoff);\n\t\tif (IS_ERR(dst_folio)) {\n\t\t\terror = PTR_ERR(dst_folio);\n\t\t\tfolio_put(src_folio);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tvfs_lock_two_folios(src_folio, dst_folio);\n\n\t\t \n\t\tif (!folio_test_uptodate(src_folio) || !folio_test_uptodate(dst_folio) ||\n\t\t    src_folio->mapping != src->f_mapping ||\n\t\t    dst_folio->mapping != dest->f_mapping) {\n\t\t\tsame = false;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tsrc_addr = kmap_local_folio(src_folio,\n\t\t\t\t\toffset_in_folio(src_folio, srcoff));\n\t\tdst_addr = kmap_local_folio(dst_folio,\n\t\t\t\t\toffset_in_folio(dst_folio, dstoff));\n\n\t\tflush_dcache_folio(src_folio);\n\t\tflush_dcache_folio(dst_folio);\n\n\t\tif (memcmp(src_addr, dst_addr, cmp_len))\n\t\t\tsame = false;\n\n\t\tkunmap_local(dst_addr);\n\t\tkunmap_local(src_addr);\nunlock:\n\t\tvfs_unlock_two_folios(src_folio, dst_folio);\n\t\tfolio_put(dst_folio);\n\t\tfolio_put(src_folio);\n\n\t\tif (!same)\n\t\t\tbreak;\n\n\t\tsrcoff += cmp_len;\n\t\tdstoff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\t*is_same = same;\n\treturn 0;\n\nout_error:\n\treturn error;\n}\n\n \nint\n__generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\tstruct file *file_out, loff_t pos_out,\n\t\t\t\tloff_t *len, unsigned int remap_flags,\n\t\t\t\tconst struct iomap_ops *dax_read_ops)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tbool same_inode = (inode_in == inode_out);\n\tint ret;\n\n\t \n\tif (IS_IMMUTABLE(inode_out))\n\t\treturn -EPERM;\n\n\tif (IS_SWAPFILE(inode_in) || IS_SWAPFILE(inode_out))\n\t\treturn -ETXTBSY;\n\n\t \n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t \n\tif (*len == 0) {\n\t\tloff_t isize = i_size_read(inode_in);\n\n\t\tif ((remap_flags & REMAP_FILE_DEDUP) || pos_in == isize)\n\t\t\treturn 0;\n\t\tif (pos_in > isize)\n\t\t\treturn -EINVAL;\n\t\t*len = isize - pos_in;\n\t\tif (*len == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = generic_remap_checks(file_in, pos_in, file_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret || *len == 0)\n\t\treturn ret;\n\n\t \n\tinode_dio_wait(inode_in);\n\tif (!same_inode)\n\t\tinode_dio_wait(inode_out);\n\n\tret = filemap_write_and_wait_range(inode_in->i_mapping,\n\t\t\tpos_in, pos_in + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_write_and_wait_range(inode_out->i_mapping,\n\t\t\tpos_out, pos_out + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (remap_flags & REMAP_FILE_DEDUP) {\n\t\tbool\t\tis_same = false;\n\n\t\tif (!IS_DAX(inode_in))\n\t\t\tret = vfs_dedupe_file_range_compare(file_in, pos_in,\n\t\t\t\t\tfile_out, pos_out, *len, &is_same);\n\t\telse if (dax_read_ops)\n\t\t\tret = dax_dedupe_file_range_compare(inode_in, pos_in,\n\t\t\t\t\tinode_out, pos_out, *len, &is_same,\n\t\t\t\t\tdax_read_ops);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!is_same)\n\t\t\treturn -EBADE;\n\t}\n\n\tret = generic_remap_check_len(inode_in, inode_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret || *len == 0)\n\t\treturn ret;\n\n\t \n\tif (!(remap_flags & REMAP_FILE_DEDUP))\n\t\tret = file_modified(file_out);\n\n\treturn ret;\n}\n\nint generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t *len, unsigned int remap_flags)\n{\n\treturn __generic_remap_file_range_prep(file_in, pos_in, file_out,\n\t\t\t\t\t       pos_out, len, remap_flags, NULL);\n}\nEXPORT_SYMBOL(generic_remap_file_range_prep);\n\nloff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & REMAP_FILE_DEDUP);\n\n\tif (file_inode(file_in)->i_sb != file_inode(file_out)->i_sb)\n\t\treturn -EXDEV;\n\n\tret = generic_file_rw_checks(file_in, file_out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!file_in->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len, remap_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsnotify_access(file_in);\n\tfsnotify_modify(file_out);\n\treturn ret;\n}\nEXPORT_SYMBOL(do_clone_file_range);\n\nloff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tfile_start_write(file_out);\n\tret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t  remap_flags);\n\tfile_end_write(file_out);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_clone_file_range);\n\n \nstatic bool allow_file_dedupe(struct file *file)\n{\n\tstruct mnt_idmap *idmap = file_mnt_idmap(file);\n\tstruct inode *inode = file_inode(file);\n\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn true;\n\tif (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid()))\n\t\treturn true;\n\tif (!inode_permission(idmap, inode, MAY_WRITE))\n\t\treturn true;\n\treturn false;\n}\n\nloff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t struct file *dst_file, loff_t dst_pos,\n\t\t\t\t loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN));\n\n\tret = mnt_want_write_file(dst_file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = remap_verify_area(src_file, src_pos, len, false);\n\tif (ret)\n\t\tgoto out_drop_write;\n\n\tret = remap_verify_area(dst_file, dst_pos, len, true);\n\tif (ret)\n\t\tgoto out_drop_write;\n\n\tret = -EPERM;\n\tif (!allow_file_dedupe(dst_file))\n\t\tgoto out_drop_write;\n\n\tret = -EXDEV;\n\tif (file_inode(src_file)->i_sb != file_inode(dst_file)->i_sb)\n\t\tgoto out_drop_write;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(file_inode(dst_file)->i_mode))\n\t\tgoto out_drop_write;\n\n\tret = -EINVAL;\n\tif (!dst_file->f_op->remap_file_range)\n\t\tgoto out_drop_write;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = dst_file->f_op->remap_file_range(src_file, src_pos, dst_file,\n\t\t\tdst_pos, len, remap_flags | REMAP_FILE_DEDUP);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_dedupe_file_range_one);\n\nint vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)\n{\n\tstruct file_dedupe_range_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tu16 count = same->dest_count;\n\tloff_t deduped;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tif (same->reserved1 || same->reserved2)\n\t\treturn -EINVAL;\n\n\toff = same->src_offset;\n\tlen = same->src_length;\n\n\tif (S_ISDIR(src->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(src->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!file->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file, off, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tif (off + len > i_size_read(src))\n\t\treturn -EINVAL;\n\n\t \n\tlen = min_t(u64, len, 1 << 30);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = FILE_DEDUPE_RANGE_SAME;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct fd dst_fd = fdget(info->dest_fd);\n\t\tstruct file *dst_file = dst_fd.file;\n\n\t\tif (!dst_file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tgoto next_loop;\n\t\t}\n\n\t\tif (info->reserved) {\n\t\t\tinfo->status = -EINVAL;\n\t\t\tgoto next_fdput;\n\t\t}\n\n\t\tdeduped = vfs_dedupe_file_range_one(file, off, dst_file,\n\t\t\t\t\t\t    info->dest_offset, len,\n\t\t\t\t\t\t    REMAP_FILE_CAN_SHORTEN);\n\t\tif (deduped == -EBADE)\n\t\t\tinfo->status = FILE_DEDUPE_RANGE_DIFFERS;\n\t\telse if (deduped < 0)\n\t\t\tinfo->status = deduped;\n\t\telse\n\t\t\tinfo->bytes_deduped = len;\n\nnext_fdput:\n\t\tfdput(dst_fd);\nnext_loop:\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(vfs_dedupe_file_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}