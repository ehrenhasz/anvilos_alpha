{
  "module_name": "cache.c",
  "hash_id": "3349383a647ea23505a1a7c8bc76650c8ed12c70703642d52ac2a6d7ed45c892",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/cache.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include \"internal.h\"\n\n \nint cachefiles_add_cache(struct cachefiles_cache *cache)\n{\n\tstruct fscache_cache *cache_cookie;\n\tstruct path path;\n\tstruct kstatfs stats;\n\tstruct dentry *graveyard, *cachedir, *root;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"\");\n\n\tcache_cookie = fscache_acquire_cache(cache->tag);\n\tif (IS_ERR(cache_cookie))\n\t\treturn PTR_ERR(cache_cookie);\n\n\t \n\tret = cachefiles_get_security_ID(cache);\n\tif (ret < 0)\n\t\tgoto error_getsec;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\n\t \n\tret = kern_path(cache->rootdirname, LOOKUP_DIRECTORY, &path);\n\tif (ret < 0)\n\t\tgoto error_open_root;\n\n\tcache->mnt = path.mnt;\n\troot = path.dentry;\n\n\tret = -EINVAL;\n\tif (is_idmapped_mnt(path.mnt)) {\n\t\tpr_warn(\"File cache on idmapped mounts not supported\");\n\t\tgoto error_unsupported;\n\t}\n\n\t \n\tret = -EOPNOTSUPP;\n\tif (d_is_negative(root) ||\n\t    !d_backing_inode(root)->i_op->lookup ||\n\t    !d_backing_inode(root)->i_op->mkdir ||\n\t    !d_backing_inode(root)->i_op->tmpfile ||\n\t    !(d_backing_inode(root)->i_opflags & IOP_XATTR) ||\n\t    !root->d_sb->s_op->statfs ||\n\t    !root->d_sb->s_op->sync_fs ||\n\t    root->d_sb->s_blocksize > PAGE_SIZE)\n\t\tgoto error_unsupported;\n\n\tret = -EROFS;\n\tif (sb_rdonly(root->d_sb))\n\t\tgoto error_unsupported;\n\n\t \n\tret = cachefiles_determine_cache_security(cache, root, &saved_cred);\n\tif (ret < 0)\n\t\tgoto error_unsupported;\n\n\t \n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0)\n\t\tgoto error_unsupported;\n\n\tret = -ERANGE;\n\tif (stats.f_bsize <= 0)\n\t\tgoto error_unsupported;\n\n\tret = -EOPNOTSUPP;\n\tif (stats.f_bsize > PAGE_SIZE)\n\t\tgoto error_unsupported;\n\n\tcache->bsize = stats.f_bsize;\n\tcache->bshift = ilog2(stats.f_bsize);\n\n\t_debug(\"blksize %u (shift %u)\",\n\t       cache->bsize, cache->bshift);\n\n\t_debug(\"size %llu, avail %llu\",\n\t       (unsigned long long) stats.f_blocks,\n\t       (unsigned long long) stats.f_bavail);\n\n\t \n\tdo_div(stats.f_files, 100);\n\tcache->fstop = stats.f_files * cache->fstop_percent;\n\tcache->fcull = stats.f_files * cache->fcull_percent;\n\tcache->frun  = stats.f_files * cache->frun_percent;\n\n\t_debug(\"limits {%llu,%llu,%llu} files\",\n\t       (unsigned long long) cache->frun,\n\t       (unsigned long long) cache->fcull,\n\t       (unsigned long long) cache->fstop);\n\n\tdo_div(stats.f_blocks, 100);\n\tcache->bstop = stats.f_blocks * cache->bstop_percent;\n\tcache->bcull = stats.f_blocks * cache->bcull_percent;\n\tcache->brun  = stats.f_blocks * cache->brun_percent;\n\n\t_debug(\"limits {%llu,%llu,%llu} blocks\",\n\t       (unsigned long long) cache->brun,\n\t       (unsigned long long) cache->bcull,\n\t       (unsigned long long) cache->bstop);\n\n\t \n\tcachedir = cachefiles_get_directory(cache, root, \"cache\", NULL);\n\tif (IS_ERR(cachedir)) {\n\t\tret = PTR_ERR(cachedir);\n\t\tgoto error_unsupported;\n\t}\n\n\tcache->store = cachedir;\n\n\t \n\tgraveyard = cachefiles_get_directory(cache, root, \"graveyard\", NULL);\n\tif (IS_ERR(graveyard)) {\n\t\tret = PTR_ERR(graveyard);\n\t\tgoto error_unsupported;\n\t}\n\n\tcache->graveyard = graveyard;\n\tcache->cache = cache_cookie;\n\n\tret = fscache_add_cache(cache_cookie, &cachefiles_cache_ops, cache);\n\tif (ret < 0)\n\t\tgoto error_add_cache;\n\n\t \n\tset_bit(CACHEFILES_READY, &cache->flags);\n\tdput(root);\n\n\tpr_info(\"File cache on %s registered\\n\", cache_cookie->name);\n\n\t \n\tcachefiles_has_space(cache, 0, 0, cachefiles_has_space_check);\n\tcachefiles_end_secure(cache, saved_cred);\n\t_leave(\" = 0 [%px]\", cache->cache);\n\treturn 0;\n\nerror_add_cache:\n\tcachefiles_put_directory(cache->graveyard);\n\tcache->graveyard = NULL;\nerror_unsupported:\n\tcachefiles_put_directory(cache->store);\n\tcache->store = NULL;\n\tmntput(cache->mnt);\n\tcache->mnt = NULL;\n\tdput(root);\nerror_open_root:\n\tcachefiles_end_secure(cache, saved_cred);\nerror_getsec:\n\tfscache_relinquish_cache(cache_cookie);\n\tcache->cache = NULL;\n\tpr_err(\"Failed to register: %d\\n\", ret);\n\treturn ret;\n}\n\n \nint cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t unsigned fnr, unsigned bnr,\n\t\t\t enum cachefiles_has_space_for reason)\n{\n\tstruct kstatfs stats;\n\tu64 b_avail, b_writing;\n\tint ret;\n\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= cache->mnt->mnt_root,\n\t};\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\t \n\tmemset(&stats, 0, sizeof(stats));\n\n\tret = vfs_statfs(&path, &stats);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(NULL, d_inode(path.dentry), ret,\n\t\t\t\t\t   cachefiles_trace_statfs_error);\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"statfs failed\");\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\tb_avail = stats.f_bavail;\n\tb_writing = atomic_long_read(&cache->b_writing);\n\tif (b_avail > b_writing)\n\t\tb_avail -= b_writing;\n\telse\n\t\tb_avail = 0;\n\n\t\n\t\n\t\n\n\t \n\tif (stats.f_ffree > fnr)\n\t\tstats.f_ffree -= fnr;\n\telse\n\t\tstats.f_ffree = 0;\n\n\tif (b_avail > bnr)\n\t\tb_avail -= bnr;\n\telse\n\t\tb_avail = 0;\n\n\tret = -ENOBUFS;\n\tif (stats.f_ffree < cache->fstop ||\n\t    b_avail < cache->bstop)\n\t\tgoto stop_and_begin_cull;\n\n\tret = 0;\n\tif (stats.f_ffree < cache->fcull ||\n\t    b_avail < cache->bcull)\n\t\tgoto begin_cull;\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags) &&\n\t    stats.f_ffree >= cache->frun &&\n\t    b_avail >= cache->brun &&\n\t    test_and_clear_bit(CACHEFILES_CULLING, &cache->flags)\n\t    ) {\n\t\t_debug(\"cease culling\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t\n\treturn 0;\n\nstop_and_begin_cull:\n\tswitch (reason) {\n\tcase cachefiles_has_space_for_write:\n\t\tfscache_count_no_write_space();\n\t\tbreak;\n\tcase cachefiles_has_space_for_create:\n\t\tfscache_count_no_create_space();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nbegin_cull:\n\tif (!test_and_set_bit(CACHEFILES_CULLING, &cache->flags)) {\n\t\t_debug(\"### CULL CACHE ###\");\n\t\tcachefiles_state_changed(cache);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic void cachefiles_withdraw_objects(struct cachefiles_cache *cache)\n{\n\tstruct cachefiles_object *object;\n\tunsigned int count = 0;\n\n\t_enter(\"\");\n\n\tspin_lock(&cache->object_list_lock);\n\n\twhile (!list_empty(&cache->object_list)) {\n\t\tobject = list_first_entry(&cache->object_list,\n\t\t\t\t\t  struct cachefiles_object, cache_link);\n\t\tcachefiles_see_object(object, cachefiles_obj_see_withdrawal);\n\t\tlist_del_init(&object->cache_link);\n\t\tfscache_withdraw_cookie(object->cookie);\n\t\tcount++;\n\t\tif ((count & 63) == 0) {\n\t\t\tspin_unlock(&cache->object_list_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&cache->object_list_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&cache->object_list_lock);\n\t_leave(\" [%u objs]\", count);\n}\n\n \nstatic void cachefiles_withdraw_volumes(struct cachefiles_cache *cache)\n{\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tstruct cachefiles_volume *volume = NULL;\n\n\t\tspin_lock(&cache->object_list_lock);\n\t\tif (!list_empty(&cache->volumes)) {\n\t\t\tvolume = list_first_entry(&cache->volumes,\n\t\t\t\t\t\t  struct cachefiles_volume, cache_link);\n\t\t\tlist_del_init(&volume->cache_link);\n\t\t}\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tif (!volume)\n\t\t\tbreak;\n\n\t\tcachefiles_withdraw_volume(volume);\n\t}\n\n\t_leave(\"\");\n}\n\n \nstatic void cachefiles_sync_cache(struct cachefiles_cache *cache)\n{\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"%s\", cache->cache->name);\n\n\t \n\tcachefiles_begin_secure(cache, &saved_cred);\n\tdown_read(&cache->mnt->mnt_sb->s_umount);\n\tret = sync_filesystem(cache->mnt->mnt_sb);\n\tup_read(&cache->mnt->mnt_sb->s_umount);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache,\n\t\t\t\t    \"Attempt to sync backing fs superblock returned error %d\",\n\t\t\t\t    ret);\n}\n\n \nvoid cachefiles_withdraw_cache(struct cachefiles_cache *cache)\n{\n\tstruct fscache_cache *fscache = cache->cache;\n\n\tpr_info(\"File cache on %s unregistering\\n\", fscache->name);\n\n\tfscache_withdraw_cache(fscache);\n\n\t \n\tcachefiles_withdraw_objects(cache);\n\tfscache_wait_for_objects(fscache);\n\n\tcachefiles_withdraw_volumes(cache);\n\tcachefiles_sync_cache(cache);\n\tcache->cache = NULL;\n\tfscache_relinquish_cache(fscache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}