{
  "module_name": "namei.c",
  "hash_id": "92b04149d195054850b879423a95bfff5d84176b66e2a3c1b781d7765e1180df",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/namei.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include \"internal.h\"\n\n \nstatic bool __cachefiles_mark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t\t   struct inode *inode)\n{\n\tbool can_use = false;\n\n\tif (!(inode->i_flags & S_KERNEL_FILE)) {\n\t\tinode->i_flags |= S_KERNEL_FILE;\n\t\ttrace_cachefiles_mark_active(object, inode);\n\t\tcan_use = true;\n\t} else {\n\t\ttrace_cachefiles_mark_failed(object, inode);\n\t}\n\n\treturn can_use;\n}\n\nstatic bool cachefiles_mark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t\t struct inode *inode)\n{\n\tbool can_use;\n\n\tinode_lock(inode);\n\tcan_use = __cachefiles_mark_inode_in_use(object, inode);\n\tinode_unlock(inode);\n\treturn can_use;\n}\n\n \nstatic void __cachefiles_unmark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t\t     struct inode *inode)\n{\n\tinode->i_flags &= ~S_KERNEL_FILE;\n\ttrace_cachefiles_mark_inactive(object, inode);\n}\n\nstatic void cachefiles_do_unmark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t\t      struct inode *inode)\n{\n\tinode_lock(inode);\n\t__cachefiles_unmark_inode_in_use(object, inode);\n\tinode_unlock(inode);\n}\n\n \nvoid cachefiles_unmark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t    struct file *file)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct inode *inode = file_inode(file);\n\n\tcachefiles_do_unmark_inode_in_use(object, inode);\n\n\tif (!test_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags)) {\n\t\tatomic_long_add(inode->i_blocks, &cache->b_released);\n\t\tif (atomic_inc_return(&cache->f_released))\n\t\t\tcachefiles_state_changed(cache);\n\t}\n}\n\n \nstruct dentry *cachefiles_get_directory(struct cachefiles_cache *cache,\n\t\t\t\t\tstruct dentry *dir,\n\t\t\t\t\tconst char *dirname,\n\t\t\t\t\tbool *_is_new)\n{\n\tstruct dentry *subdir;\n\tstruct path path;\n\tint ret;\n\n\t_enter(\",,%s\", dirname);\n\n\t \n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\nretry:\n\tret = cachefiles_inject_read_error();\n\tif (ret == 0)\n\t\tsubdir = lookup_one_len(dirname, dir, strlen(dirname));\n\telse\n\t\tsubdir = ERR_PTR(ret);\n\ttrace_cachefiles_lookup(NULL, dir, subdir);\n\tif (IS_ERR(subdir)) {\n\t\ttrace_cachefiles_vfs_error(NULL, d_backing_inode(dir),\n\t\t\t\t\t   PTR_ERR(subdir),\n\t\t\t\t\t   cachefiles_trace_lookup_error);\n\t\tif (PTR_ERR(subdir) == -ENOMEM)\n\t\t\tgoto nomem_d_alloc;\n\t\tgoto lookup_error;\n\t}\n\n\t_debug(\"subdir -> %pd %s\",\n\t       subdir, d_backing_inode(subdir) ? \"positive\" : \"negative\");\n\n\t \n\tif (d_is_negative(subdir)) {\n\t\tret = cachefiles_has_space(cache, 1, 0,\n\t\t\t\t\t   cachefiles_has_space_for_create);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\n\t\t_debug(\"attempt mkdir\");\n\n\t\tpath.mnt = cache->mnt;\n\t\tpath.dentry = dir;\n\t\tret = security_path_mkdir(&path, subdir, 0700);\n\t\tif (ret < 0)\n\t\t\tgoto mkdir_error;\n\t\tret = cachefiles_inject_write_error();\n\t\tif (ret == 0)\n\t\t\tret = vfs_mkdir(&nop_mnt_idmap, d_inode(dir), subdir, 0700);\n\t\tif (ret < 0) {\n\t\t\ttrace_cachefiles_vfs_error(NULL, d_inode(dir), ret,\n\t\t\t\t\t\t   cachefiles_trace_mkdir_error);\n\t\t\tgoto mkdir_error;\n\t\t}\n\t\ttrace_cachefiles_mkdir(dir, subdir);\n\n\t\tif (unlikely(d_unhashed(subdir))) {\n\t\t\tcachefiles_put_directory(subdir);\n\t\t\tgoto retry;\n\t\t}\n\t\tASSERT(d_backing_inode(subdir));\n\n\t\t_debug(\"mkdir -> %pd{ino=%lu}\",\n\t\t       subdir, d_backing_inode(subdir)->i_ino);\n\t\tif (_is_new)\n\t\t\t*_is_new = true;\n\t}\n\n\t \n\tinode_lock(d_inode(subdir));\n\tinode_unlock(d_inode(dir));\n\n\tif (!__cachefiles_mark_inode_in_use(NULL, d_inode(subdir))) {\n\t\tpr_notice(\"cachefiles: Inode already in use: %pd (B=%lx)\\n\",\n\t\t\t  subdir, d_inode(subdir)->i_ino);\n\t\tgoto mark_error;\n\t}\n\n\tinode_unlock(d_inode(subdir));\n\n\t \n\tASSERT(d_backing_inode(subdir));\n\n\tif (!d_can_lookup(subdir)) {\n\t\tpr_err(\"%s is not a directory\\n\", dirname);\n\t\tret = -EIO;\n\t\tgoto check_error;\n\t}\n\n\tret = -EPERM;\n\tif (!(d_backing_inode(subdir)->i_opflags & IOP_XATTR) ||\n\t    !d_backing_inode(subdir)->i_op->lookup ||\n\t    !d_backing_inode(subdir)->i_op->mkdir ||\n\t    !d_backing_inode(subdir)->i_op->rename ||\n\t    !d_backing_inode(subdir)->i_op->rmdir ||\n\t    !d_backing_inode(subdir)->i_op->unlink)\n\t\tgoto check_error;\n\n\t_leave(\" = [%lu]\", d_backing_inode(subdir)->i_ino);\n\treturn subdir;\n\ncheck_error:\n\tcachefiles_put_directory(subdir);\n\t_leave(\" = %d [check]\", ret);\n\treturn ERR_PTR(ret);\n\nmark_error:\n\tinode_unlock(d_inode(subdir));\n\tdput(subdir);\n\treturn ERR_PTR(-EBUSY);\n\nmkdir_error:\n\tinode_unlock(d_inode(dir));\n\tdput(subdir);\n\tpr_err(\"mkdir %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nlookup_error:\n\tinode_unlock(d_inode(dir));\n\tret = PTR_ERR(subdir);\n\tpr_err(\"Lookup %s failed with error %d\\n\", dirname, ret);\n\treturn ERR_PTR(ret);\n\nnomem_d_alloc:\n\tinode_unlock(d_inode(dir));\n\t_leave(\" = -ENOMEM\");\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nvoid cachefiles_put_directory(struct dentry *dir)\n{\n\tif (dir) {\n\t\tcachefiles_do_unmark_inode_in_use(NULL, d_inode(dir));\n\t\tdput(dir);\n\t}\n}\n\n \nstatic int cachefiles_unlink(struct cachefiles_cache *cache,\n\t\t\t     struct cachefiles_object *object,\n\t\t\t     struct dentry *dir, struct dentry *dentry,\n\t\t\t     enum fscache_why_object_killed why)\n{\n\tstruct path path = {\n\t\t.mnt\t= cache->mnt,\n\t\t.dentry\t= dir,\n\t};\n\tint ret;\n\n\ttrace_cachefiles_unlink(object, d_inode(dentry)->i_ino, why);\n\tret = security_path_unlink(&path, dentry);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Unlink security error\");\n\t\treturn ret;\n\t}\n\n\tret = cachefiles_inject_remove_error();\n\tif (ret == 0) {\n\t\tret = vfs_unlink(&nop_mnt_idmap, d_backing_inode(dir), dentry, NULL);\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error(cache, \"Unlink failed\");\n\t}\n\tif (ret != 0)\n\t\ttrace_cachefiles_vfs_error(object, d_backing_inode(dir), ret,\n\t\t\t\t\t   cachefiles_trace_unlink_error);\n\treturn ret;\n}\n\n \nint cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t   struct cachefiles_object *object,\n\t\t\t   struct dentry *dir,\n\t\t\t   struct dentry *rep,\n\t\t\t   enum fscache_why_object_killed why)\n{\n\tstruct dentry *grave, *trap;\n\tstruct path path, path_to_graveyard;\n\tchar nbuffer[8 + 8 + 1];\n\tint ret;\n\n\t_enter(\",'%pd','%pd'\", dir, rep);\n\n\tif (rep->d_parent != dir) {\n\t\tinode_unlock(d_inode(dir));\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t \n\tif (!d_is_dir(rep)) {\n\t\tdget(rep);  \n\t\tret = cachefiles_unlink(cache, object, dir, rep, why);\n\t\tdput(rep);\n\n\t\tinode_unlock(d_inode(dir));\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\t_debug(\"move stale object to graveyard\");\n\tinode_unlock(d_inode(dir));\n\ntry_again:\n\t \n\tsprintf(nbuffer, \"%08x%08x\",\n\t\t(uint32_t) ktime_get_real_seconds(),\n\t\t(uint32_t) atomic_inc_return(&cache->gravecounter));\n\n\t \n\ttrap = lock_rename(cache->graveyard, dir);\n\n\t \n\tif (rep->d_parent != dir || IS_DEADDIR(d_inode(rep))) {\n\t\t \n\t\tunlock_rename(cache->graveyard, dir);\n\t\t_leave(\" = 0 [culled?]\");\n\t\treturn 0;\n\t}\n\n\tif (!d_can_lookup(cache->graveyard)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Graveyard no longer a directory\");\n\t\treturn -EIO;\n\t}\n\n\tif (trap == rep) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\tif (d_mountpoint(rep)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tcachefiles_io_error(cache, \"Mountpoint in cache\");\n\t\treturn -EIO;\n\t}\n\n\tgrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\n\tif (IS_ERR(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\ttrace_cachefiles_vfs_error(object, d_inode(cache->graveyard),\n\t\t\t\t\t   PTR_ERR(grave),\n\t\t\t\t\t   cachefiles_trace_lookup_error);\n\n\t\tif (PTR_ERR(grave) == -ENOMEM) {\n\t\t\t_leave(\" = -ENOMEM\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcachefiles_io_error(cache, \"Lookup error %ld\", PTR_ERR(grave));\n\t\treturn -EIO;\n\t}\n\n\tif (d_is_positive(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tgrave = NULL;\n\t\tcond_resched();\n\t\tgoto try_again;\n\t}\n\n\tif (d_mountpoint(grave)) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"Mountpoint in graveyard\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (trap == grave) {\n\t\tunlock_rename(cache->graveyard, dir);\n\t\tdput(grave);\n\t\tcachefiles_io_error(cache, \"May not make directory loop\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tpath.mnt = cache->mnt;\n\tpath.dentry = dir;\n\tpath_to_graveyard.mnt = cache->mnt;\n\tpath_to_graveyard.dentry = cache->graveyard;\n\tret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\n\tif (ret < 0) {\n\t\tcachefiles_io_error(cache, \"Rename security error %d\", ret);\n\t} else {\n\t\tstruct renamedata rd = {\n\t\t\t.old_mnt_idmap\t= &nop_mnt_idmap,\n\t\t\t.old_dir\t= d_inode(dir),\n\t\t\t.old_dentry\t= rep,\n\t\t\t.new_mnt_idmap\t= &nop_mnt_idmap,\n\t\t\t.new_dir\t= d_inode(cache->graveyard),\n\t\t\t.new_dentry\t= grave,\n\t\t};\n\t\ttrace_cachefiles_rename(object, d_inode(rep)->i_ino, why);\n\t\tret = cachefiles_inject_read_error();\n\t\tif (ret == 0)\n\t\t\tret = vfs_rename(&rd);\n\t\tif (ret != 0)\n\t\t\ttrace_cachefiles_vfs_error(object, d_inode(dir), ret,\n\t\t\t\t\t\t   cachefiles_trace_rename_error);\n\t\tif (ret != 0 && ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Rename failed with error %d\", ret);\n\t}\n\n\t__cachefiles_unmark_inode_in_use(object, d_inode(rep));\n\tunlock_rename(cache->graveyard, dir);\n\tdput(grave);\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nint cachefiles_delete_object(struct cachefiles_object *object,\n\t\t\t     enum fscache_why_object_killed why)\n{\n\tstruct cachefiles_volume *volume = object->volume;\n\tstruct dentry *dentry = object->file->f_path.dentry;\n\tstruct dentry *fan = volume->fanout[(u8)object->cookie->key_hash];\n\tint ret;\n\n\t_enter(\",OBJ%x{%pD}\", object->debug_id, object->file);\n\n\t \n\tdget(dentry);\n\n\tinode_lock_nested(d_backing_inode(fan), I_MUTEX_PARENT);\n\tret = cachefiles_unlink(volume->cache, object, fan, dentry, why);\n\tinode_unlock(d_backing_inode(fan));\n\tdput(dentry);\n\treturn ret;\n}\n\n \nstruct file *cachefiles_create_tmpfile(struct cachefiles_object *object)\n{\n\tstruct cachefiles_volume *volume = object->volume;\n\tstruct cachefiles_cache *cache = volume->cache;\n\tconst struct cred *saved_cred;\n\tstruct dentry *fan = volume->fanout[(u8)object->cookie->key_hash];\n\tstruct file *file;\n\tconst struct path parentpath = { .mnt = cache->mnt, .dentry = fan };\n\tuint64_t ni_size;\n\tlong ret;\n\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0) {\n\t\tfile = kernel_tmpfile_open(&nop_mnt_idmap, &parentpath,\n\t\t\t\t\t   S_IFREG | 0600,\n\t\t\t\t\t   O_RDWR | O_LARGEFILE | O_DIRECT,\n\t\t\t\t\t   cache->cache_cred);\n\t\tret = PTR_ERR_OR_ZERO(file);\n\t}\n\tif (ret) {\n\t\ttrace_cachefiles_vfs_error(object, d_inode(fan), ret,\n\t\t\t\t\t   cachefiles_trace_tmpfile_error);\n\t\tif (ret == -EIO)\n\t\t\tcachefiles_io_error_obj(object, \"Failed to create tmpfile\");\n\t\tgoto err;\n\t}\n\n\ttrace_cachefiles_tmpfile(object, file_inode(file));\n\n\t \n\tif (!cachefiles_mark_inode_in_use(object, file_inode(file)))\n\t\tWARN_ON(1);\n\n\tret = cachefiles_ondemand_init_object(object);\n\tif (ret < 0)\n\t\tgoto err_unuse;\n\n\tni_size = object->cookie->object_size;\n\tni_size = round_up(ni_size, CACHEFILES_DIO_BLOCK_SIZE);\n\n\tif (ni_size > 0) {\n\t\ttrace_cachefiles_trunc(object, file_inode(file), 0, ni_size,\n\t\t\t\t       cachefiles_trunc_expand_tmpfile);\n\t\tret = cachefiles_inject_write_error();\n\t\tif (ret == 0)\n\t\t\tret = vfs_truncate(&file->f_path, ni_size);\n\t\tif (ret < 0) {\n\t\t\ttrace_cachefiles_vfs_error(\n\t\t\t\tobject, file_inode(file), ret,\n\t\t\t\tcachefiles_trace_trunc_error);\n\t\t\tgoto err_unuse;\n\t\t}\n\t}\n\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->read_iter) ||\n\t    unlikely(!file->f_op->write_iter)) {\n\t\tfput(file);\n\t\tpr_notice(\"Cache does not support read_iter and write_iter\\n\");\n\t\tgoto err_unuse;\n\t}\nout:\n\tcachefiles_end_secure(cache, saved_cred);\n\treturn file;\n\nerr_unuse:\n\tcachefiles_do_unmark_inode_in_use(object, file_inode(file));\n\tfput(file);\nerr:\n\tfile = ERR_PTR(ret);\n\tgoto out;\n}\n\n \nstatic bool cachefiles_create_file(struct cachefiles_object *object)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = cachefiles_has_space(object->volume->cache, 1, 0,\n\t\t\t\t   cachefiles_has_space_for_create);\n\tif (ret < 0)\n\t\treturn false;\n\n\tfile = cachefiles_create_tmpfile(object);\n\tif (IS_ERR(file))\n\t\treturn false;\n\n\tset_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &object->cookie->flags);\n\tset_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags);\n\t_debug(\"create -> %pD{ino=%lu}\", file, file_inode(file)->i_ino);\n\tobject->file = file;\n\treturn true;\n}\n\n \nstatic bool cachefiles_open_file(struct cachefiles_object *object,\n\t\t\t\t struct dentry *dentry)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct file *file;\n\tstruct path path;\n\tint ret;\n\n\t_enter(\"%pd\", dentry);\n\n\tif (!cachefiles_mark_inode_in_use(object, d_inode(dentry))) {\n\t\tpr_notice(\"cachefiles: Inode already in use: %pd (B=%lx)\\n\",\n\t\t\t  dentry, d_inode(dentry)->i_ino);\n\t\treturn false;\n\t}\n\n\t \n\tpath.mnt = cache->mnt;\n\tpath.dentry = dentry;\n\tfile = kernel_file_open(&path, O_RDWR | O_LARGEFILE | O_DIRECT,\n\t\t\t\td_backing_inode(dentry), cache->cache_cred);\n\tif (IS_ERR(file)) {\n\t\ttrace_cachefiles_vfs_error(object, d_backing_inode(dentry),\n\t\t\t\t\t   PTR_ERR(file),\n\t\t\t\t\t   cachefiles_trace_open_error);\n\t\tgoto error;\n\t}\n\n\tif (unlikely(!file->f_op->read_iter) ||\n\t    unlikely(!file->f_op->write_iter)) {\n\t\tpr_notice(\"Cache does not support read_iter and write_iter\\n\");\n\t\tgoto error_fput;\n\t}\n\t_debug(\"file -> %pd positive\", dentry);\n\n\tret = cachefiles_ondemand_init_object(object);\n\tif (ret < 0)\n\t\tgoto error_fput;\n\n\tret = cachefiles_check_auxdata(object, file);\n\tif (ret < 0)\n\t\tgoto check_failed;\n\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &object->cookie->flags);\n\n\tobject->file = file;\n\n\t \n\ttouch_atime(&file->f_path);\n\tdput(dentry);\n\treturn true;\n\ncheck_failed:\n\tfscache_cookie_lookup_negative(object->cookie);\n\tcachefiles_unmark_inode_in_use(object, file);\n\tfput(file);\n\tdput(dentry);\n\tif (ret == -ESTALE)\n\t\treturn cachefiles_create_file(object);\n\treturn false;\n\nerror_fput:\n\tfput(file);\nerror:\n\tcachefiles_do_unmark_inode_in_use(object, d_inode(dentry));\n\tdput(dentry);\n\treturn false;\n}\n\n \nbool cachefiles_look_up_object(struct cachefiles_object *object)\n{\n\tstruct cachefiles_volume *volume = object->volume;\n\tstruct dentry *dentry, *fan = volume->fanout[(u8)object->cookie->key_hash];\n\tint ret;\n\n\t_enter(\"OBJ%x,%s,\", object->debug_id, object->d_name);\n\n\t \n\tret = cachefiles_inject_read_error();\n\tif (ret == 0)\n\t\tdentry = lookup_positive_unlocked(object->d_name, fan,\n\t\t\t\t\t\t  object->d_name_len);\n\telse\n\t\tdentry = ERR_PTR(ret);\n\ttrace_cachefiles_lookup(object, fan, dentry);\n\tif (IS_ERR(dentry)) {\n\t\tif (dentry == ERR_PTR(-ENOENT))\n\t\t\tgoto new_file;\n\t\tif (dentry == ERR_PTR(-EIO))\n\t\t\tcachefiles_io_error_obj(object, \"Lookup failed\");\n\t\treturn false;\n\t}\n\n\tif (!d_is_reg(dentry)) {\n\t\tpr_err(\"%pd is not a file\\n\", dentry);\n\t\tinode_lock_nested(d_inode(fan), I_MUTEX_PARENT);\n\t\tret = cachefiles_bury_object(volume->cache, object, fan, dentry,\n\t\t\t\t\t     FSCACHE_OBJECT_IS_WEIRD);\n\t\tdput(dentry);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\t\tgoto new_file;\n\t}\n\n\tif (!cachefiles_open_file(object, dentry))\n\t\treturn false;\n\n\t_leave(\" = t [%lu]\", file_inode(object->file)->i_ino);\n\treturn true;\n\nnew_file:\n\tfscache_cookie_lookup_negative(object->cookie);\n\treturn cachefiles_create_file(object);\n}\n\n \nbool cachefiles_commit_tmpfile(struct cachefiles_cache *cache,\n\t\t\t       struct cachefiles_object *object)\n{\n\tstruct cachefiles_volume *volume = object->volume;\n\tstruct dentry *dentry, *fan = volume->fanout[(u8)object->cookie->key_hash];\n\tbool success = false;\n\tint ret;\n\n\t_enter(\",%pD\", object->file);\n\n\tinode_lock_nested(d_inode(fan), I_MUTEX_PARENT);\n\tret = cachefiles_inject_read_error();\n\tif (ret == 0)\n\t\tdentry = lookup_one_len(object->d_name, fan, object->d_name_len);\n\telse\n\t\tdentry = ERR_PTR(ret);\n\tif (IS_ERR(dentry)) {\n\t\ttrace_cachefiles_vfs_error(object, d_inode(fan), PTR_ERR(dentry),\n\t\t\t\t\t   cachefiles_trace_lookup_error);\n\t\t_debug(\"lookup fail %ld\", PTR_ERR(dentry));\n\t\tgoto out_unlock;\n\t}\n\n\tif (!d_is_negative(dentry)) {\n\t\tif (d_backing_inode(dentry) == file_inode(object->file)) {\n\t\t\tsuccess = true;\n\t\t\tgoto out_dput;\n\t\t}\n\n\t\tret = cachefiles_unlink(volume->cache, object, fan, dentry,\n\t\t\t\t\tFSCACHE_OBJECT_IS_STALE);\n\t\tif (ret < 0)\n\t\t\tgoto out_dput;\n\n\t\tdput(dentry);\n\t\tret = cachefiles_inject_read_error();\n\t\tif (ret == 0)\n\t\t\tdentry = lookup_one_len(object->d_name, fan, object->d_name_len);\n\t\telse\n\t\t\tdentry = ERR_PTR(ret);\n\t\tif (IS_ERR(dentry)) {\n\t\t\ttrace_cachefiles_vfs_error(object, d_inode(fan), PTR_ERR(dentry),\n\t\t\t\t\t\t   cachefiles_trace_lookup_error);\n\t\t\t_debug(\"lookup fail %ld\", PTR_ERR(dentry));\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tret = cachefiles_inject_read_error();\n\tif (ret == 0)\n\t\tret = vfs_link(object->file->f_path.dentry, &nop_mnt_idmap,\n\t\t\t       d_inode(fan), dentry, NULL);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(object, d_inode(fan), ret,\n\t\t\t\t\t   cachefiles_trace_link_error);\n\t\t_debug(\"link fail %d\", ret);\n\t} else {\n\t\ttrace_cachefiles_link(object, file_inode(object->file));\n\t\tspin_lock(&object->lock);\n\t\t \n\t\tclear_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags);\n\t\tspin_unlock(&object->lock);\n\t\tsuccess = true;\n\t}\n\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(fan));\n\t_leave(\" = %u\", success);\n\treturn success;\n}\n\n \nstatic struct dentry *cachefiles_lookup_for_cull(struct cachefiles_cache *cache,\n\t\t\t\t\t\t struct dentry *dir,\n\t\t\t\t\t\t char *filename)\n{\n\tstruct dentry *victim;\n\tint ret = -ENOENT;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tvictim = lookup_one_len(filename, dir, strlen(filename));\n\tif (IS_ERR(victim))\n\t\tgoto lookup_error;\n\tif (d_is_negative(victim))\n\t\tgoto lookup_put;\n\tif (d_inode(victim)->i_flags & S_KERNEL_FILE)\n\t\tgoto lookup_busy;\n\treturn victim;\n\nlookup_busy:\n\tret = -EBUSY;\nlookup_put:\n\tinode_unlock(d_inode(dir));\n\tdput(victim);\n\treturn ERR_PTR(ret);\n\nlookup_error:\n\tinode_unlock(d_inode(dir));\n\tret = PTR_ERR(victim);\n\tif (ret == -ENOENT)\n\t\treturn ERR_PTR(-ESTALE);  \n\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\t} else if (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ERR_PTR(ret);\n}\n\n \nint cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",%pd/,%s\", dir, filename);\n\n\tvictim = cachefiles_lookup_for_cull(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\t \n\tinode = d_inode(victim);\n\tinode_lock(inode);\n\tif (inode->i_flags & S_KERNEL_FILE) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t \n\t\tinode->i_flags |= S_KERNEL_FILE;\n\t\tret = 0;\n\t}\n\tinode_unlock(inode);\n\tif (ret < 0)\n\t\tgoto error_unlock;\n\n\tret = cachefiles_bury_object(cache, NULL, dir, victim,\n\t\t\t\t     FSCACHE_OBJECT_WAS_CULLED);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tfscache_count_culled();\n\tdput(victim);\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tinode_unlock(d_inode(dir));\nerror:\n\tdput(victim);\n\tif (ret == -ENOENT)\n\t\treturn -ESTALE;  \n\n\tif (ret != -ENOMEM) {\n\t\tpr_err(\"Internal error: %d\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t    char *filename)\n{\n\tstruct dentry *victim;\n\tint ret = 0;\n\n\tvictim = cachefiles_lookup_for_cull(cache, dir, filename);\n\tif (IS_ERR(victim))\n\t\treturn PTR_ERR(victim);\n\n\tinode_unlock(d_inode(dir));\n\tdput(victim);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}