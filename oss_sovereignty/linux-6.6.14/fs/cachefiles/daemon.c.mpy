{
  "module_name": "daemon.c",
  "hash_id": "268def0c251471cdb73066c9a677d919f6e7d19f45ed4bb449a1fcf1c6aab462",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/daemon.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/poll.h>\n#include <linux/mount.h>\n#include <linux/statfs.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs_struct.h>\n#include \"internal.h\"\n\nstatic int cachefiles_daemon_open(struct inode *, struct file *);\nstatic int cachefiles_daemon_release(struct inode *, struct file *);\nstatic ssize_t cachefiles_daemon_read(struct file *, char __user *, size_t,\n\t\t\t\t      loff_t *);\nstatic ssize_t cachefiles_daemon_write(struct file *, const char __user *,\n\t\t\t\t       size_t, loff_t *);\nstatic __poll_t cachefiles_daemon_poll(struct file *,\n\t\t\t\t\t   struct poll_table_struct *);\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bind(struct cachefiles_cache *, char *);\nstatic void cachefiles_daemon_unbind(struct cachefiles_cache *);\n\nstatic unsigned long cachefiles_open;\n\nconst struct file_operations cachefiles_daemon_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= cachefiles_daemon_open,\n\t.release\t= cachefiles_daemon_release,\n\t.read\t\t= cachefiles_daemon_read,\n\t.write\t\t= cachefiles_daemon_write,\n\t.poll\t\t= cachefiles_daemon_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct cachefiles_daemon_cmd {\n\tchar name[8];\n\tint (*handler)(struct cachefiles_cache *cache, char *args);\n};\n\nstatic const struct cachefiles_daemon_cmd cachefiles_daemon_cmds[] = {\n\t{ \"bind\",\tcachefiles_daemon_bind\t\t},\n\t{ \"brun\",\tcachefiles_daemon_brun\t\t},\n\t{ \"bcull\",\tcachefiles_daemon_bcull\t\t},\n\t{ \"bstop\",\tcachefiles_daemon_bstop\t\t},\n\t{ \"cull\",\tcachefiles_daemon_cull\t\t},\n\t{ \"debug\",\tcachefiles_daemon_debug\t\t},\n\t{ \"dir\",\tcachefiles_daemon_dir\t\t},\n\t{ \"frun\",\tcachefiles_daemon_frun\t\t},\n\t{ \"fcull\",\tcachefiles_daemon_fcull\t\t},\n\t{ \"fstop\",\tcachefiles_daemon_fstop\t\t},\n\t{ \"inuse\",\tcachefiles_daemon_inuse\t\t},\n\t{ \"secctx\",\tcachefiles_daemon_secctx\t},\n\t{ \"tag\",\tcachefiles_daemon_tag\t\t},\n#ifdef CONFIG_CACHEFILES_ONDEMAND\n\t{ \"copen\",\tcachefiles_ondemand_copen\t},\n#endif\n\t{ \"\",\t\tNULL\t\t\t\t}\n};\n\n\n \nstatic int cachefiles_daemon_open(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache;\n\n\t_enter(\"\");\n\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (xchg(&cachefiles_open, 1) == 1)\n\t\treturn -EBUSY;\n\n\t \n\tcache = kzalloc(sizeof(struct cachefiles_cache), GFP_KERNEL);\n\tif (!cache) {\n\t\tcachefiles_open = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&cache->daemon_mutex);\n\tinit_waitqueue_head(&cache->daemon_pollwq);\n\tINIT_LIST_HEAD(&cache->volumes);\n\tINIT_LIST_HEAD(&cache->object_list);\n\tspin_lock_init(&cache->object_list_lock);\n\trefcount_set(&cache->unbind_pincount, 1);\n\txa_init_flags(&cache->reqs, XA_FLAGS_ALLOC);\n\txa_init_flags(&cache->ondemand_ids, XA_FLAGS_ALLOC1);\n\n\t \n\tcache->frun_percent = 7;\n\tcache->fcull_percent = 5;\n\tcache->fstop_percent = 1;\n\tcache->brun_percent = 7;\n\tcache->bcull_percent = 5;\n\tcache->bstop_percent = 1;\n\n\tfile->private_data = cache;\n\tcache->cachefilesd = file;\n\treturn 0;\n}\n\nstatic void cachefiles_flush_reqs(struct cachefiles_cache *cache)\n{\n\tstruct xarray *xa = &cache->reqs;\n\tstruct cachefiles_req *req;\n\tunsigned long index;\n\n\t \n\tsmp_mb();\n\n\txa_lock(xa);\n\txa_for_each(xa, index, req) {\n\t\treq->error = -EIO;\n\t\tcomplete(&req->done);\n\t}\n\txa_unlock(xa);\n\n\txa_destroy(&cache->reqs);\n\txa_destroy(&cache->ondemand_ids);\n}\n\nvoid cachefiles_put_unbind_pincount(struct cachefiles_cache *cache)\n{\n\tif (refcount_dec_and_test(&cache->unbind_pincount)) {\n\t\tcachefiles_daemon_unbind(cache);\n\t\tcachefiles_open = 0;\n\t\tkfree(cache);\n\t}\n}\n\nvoid cachefiles_get_unbind_pincount(struct cachefiles_cache *cache)\n{\n\trefcount_inc(&cache->unbind_pincount);\n}\n\n \nstatic int cachefiles_daemon_release(struct inode *inode, struct file *file)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\n\t_enter(\"\");\n\n\tASSERT(cache);\n\n\tset_bit(CACHEFILES_DEAD, &cache->flags);\n\n\tif (cachefiles_in_ondemand_mode(cache))\n\t\tcachefiles_flush_reqs(cache);\n\n\t \n\tcache->cachefilesd = NULL;\n\tfile->private_data = NULL;\n\n\tcachefiles_put_unbind_pincount(cache);\n\n\t_leave(\"\");\n\treturn 0;\n}\n\nstatic ssize_t cachefiles_do_daemon_read(struct cachefiles_cache *cache,\n\t\t\t\t\t char __user *_buffer, size_t buflen)\n{\n\tunsigned long long b_released;\n\tunsigned f_released;\n\tchar buffer[256];\n\tint n;\n\n\t \n\tcachefiles_has_space(cache, 0, 0, cachefiles_has_space_check);\n\n\t \n\tf_released = atomic_xchg(&cache->f_released, 0);\n\tb_released = atomic_long_xchg(&cache->b_released, 0);\n\tclear_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\n\tn = snprintf(buffer, sizeof(buffer),\n\t\t     \"cull=%c\"\n\t\t     \" frun=%llx\"\n\t\t     \" fcull=%llx\"\n\t\t     \" fstop=%llx\"\n\t\t     \" brun=%llx\"\n\t\t     \" bcull=%llx\"\n\t\t     \" bstop=%llx\"\n\t\t     \" freleased=%x\"\n\t\t     \" breleased=%llx\",\n\t\t     test_bit(CACHEFILES_CULLING, &cache->flags) ? '1' : '0',\n\t\t     (unsigned long long) cache->frun,\n\t\t     (unsigned long long) cache->fcull,\n\t\t     (unsigned long long) cache->fstop,\n\t\t     (unsigned long long) cache->brun,\n\t\t     (unsigned long long) cache->bcull,\n\t\t     (unsigned long long) cache->bstop,\n\t\t     f_released,\n\t\t     b_released);\n\n\tif (n > buflen)\n\t\treturn -EMSGSIZE;\n\n\tif (copy_to_user(_buffer, buffer, n) != 0)\n\t\treturn -EFAULT;\n\n\treturn n;\n}\n\n \nstatic ssize_t cachefiles_daemon_read(struct file *file, char __user *_buffer,\n\t\t\t\t      size_t buflen, loff_t *pos)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\n\t \n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags))\n\t\treturn 0;\n\n\tif (cachefiles_in_ondemand_mode(cache))\n\t\treturn cachefiles_ondemand_daemon_read(cache, _buffer, buflen);\n\telse\n\t\treturn cachefiles_do_daemon_read(cache, _buffer, buflen);\n}\n\n \nstatic ssize_t cachefiles_daemon_write(struct file *file,\n\t\t\t\t       const char __user *_data,\n\t\t\t\t       size_t datalen,\n\t\t\t\t       loff_t *pos)\n{\n\tconst struct cachefiles_daemon_cmd *cmd;\n\tstruct cachefiles_cache *cache = file->private_data;\n\tssize_t ret;\n\tchar *data, *args, *cp;\n\n\t \n\n\tASSERT(cache);\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\treturn -EIO;\n\n\tif (datalen > PAGE_SIZE - 1)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdata = memdup_user_nul(_data, datalen);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tret = -EINVAL;\n\tif (memchr(data, '\\0', datalen))\n\t\tgoto error;\n\n\t \n\tcp = memchr(data, '\\n', datalen);\n\tif (cp) {\n\t\tif (cp == data)\n\t\t\tgoto error;\n\n\t\t*cp = '\\0';\n\t}\n\n\t \n\tret = -EOPNOTSUPP;\n\n\tfor (args = data; *args; args++)\n\t\tif (isspace(*args))\n\t\t\tbreak;\n\tif (*args) {\n\t\tif (args == data)\n\t\t\tgoto error;\n\t\t*args = '\\0';\n\t\targs = skip_spaces(++args);\n\t}\n\n\t \n\tfor (cmd = cachefiles_daemon_cmds; cmd->name[0]; cmd++)\n\t\tif (strcmp(cmd->name, data) == 0)\n\t\t\tgoto found_command;\n\nerror:\n\tkfree(data);\n\t \n\treturn ret;\n\nfound_command:\n\tmutex_lock(&cache->daemon_mutex);\n\n\tret = -EIO;\n\tif (!test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\tret = cmd->handler(cache, args);\n\n\tmutex_unlock(&cache->daemon_mutex);\n\n\tif (ret == 0)\n\t\tret = datalen;\n\tgoto error;\n}\n\n \nstatic __poll_t cachefiles_daemon_poll(struct file *file,\n\t\t\t\t\t   struct poll_table_struct *poll)\n{\n\tstruct cachefiles_cache *cache = file->private_data;\n\t__poll_t mask;\n\n\tpoll_wait(file, &cache->daemon_pollwq, poll);\n\tmask = 0;\n\n\tif (cachefiles_in_ondemand_mode(cache)) {\n\t\tif (!xa_empty(&cache->reqs))\n\t\t\tmask |= EPOLLIN;\n\t} else {\n\t\tif (test_bit(CACHEFILES_STATE_CHANGED, &cache->flags))\n\t\t\tmask |= EPOLLIN;\n\t}\n\n\tif (test_bit(CACHEFILES_CULLING, &cache->flags))\n\t\tmask |= EPOLLOUT;\n\n\treturn mask;\n}\n\n \nstatic int cachefiles_daemon_range_error(struct cachefiles_cache *cache,\n\t\t\t\t\t char *args)\n{\n\tpr_err(\"Free space limits must be in range 0%%<=stop<cull<run<100%%\\n\");\n\n\treturn -EINVAL;\n}\n\n \nstatic int cachefiles_daemon_frun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long frun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (frun <= cache->fcull_percent || frun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->frun_percent = frun;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fcull <= cache->fstop_percent || fcull >= cache->frun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fcull_percent = fcull;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long fstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tfstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (fstop >= cache->fcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->fstop_percent = fstop;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_brun(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long brun;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbrun = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (brun <= cache->bcull_percent || brun >= 100)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->brun_percent = brun;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bcull;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbcull = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bcull <= cache->bstop_percent || bcull >= cache->brun_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bcull_percent = bcull;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long bstop;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\tbstop = simple_strtoul(args, &args, 10);\n\tif (args[0] != '%' || args[1] != '\\0')\n\t\treturn -EINVAL;\n\n\tif (bstop >= cache->bcull_percent)\n\t\treturn cachefiles_daemon_range_error(cache, args);\n\n\tcache->bstop_percent = bstop;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_dir(struct cachefiles_cache *cache, char *args)\n{\n\tchar *dir;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty directory specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->rootdirname) {\n\t\tpr_err(\"Second cache directory specified\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tdir = kstrdup(args, GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tcache->rootdirname = dir;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *cache, char *args)\n{\n\tchar *secctx;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->secctx) {\n\t\tpr_err(\"Second security context specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsecctx = kstrdup(args, GFP_KERNEL);\n\tif (!secctx)\n\t\treturn -ENOMEM;\n\n\tcache->secctx = secctx;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_tag(struct cachefiles_cache *cache, char *args)\n{\n\tchar *tag;\n\n\t_enter(\",%s\", args);\n\n\tif (!*args) {\n\t\tpr_err(\"Empty tag specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache->tag)\n\t\treturn -EEXIST;\n\n\ttag = kstrdup(args, GFP_KERNEL);\n\tif (!tag)\n\t\treturn -ENOMEM;\n\n\tcache->tag = tag;\n\treturn 0;\n}\n\n \nstatic int cachefiles_daemon_cull(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\",%s\", args);\n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"cull applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"cull applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_cull(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"cull command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"cull command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *cache, char *args)\n{\n\tstruct path path;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t \n\n\tif (strchr(args, '/'))\n\t\tgoto inval;\n\n\tif (!test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"inuse applied to unready cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tpr_err(\"inuse applied to dead cache\\n\");\n\t\treturn -EIO;\n\t}\n\n\tget_fs_pwd(current->fs, &path);\n\n\tif (!d_can_lookup(path.dentry))\n\t\tgoto notdir;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_in_use(cache, path.dentry, args);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tpath_put(&path);\n\t \n\treturn ret;\n\nnotdir:\n\tpath_put(&path);\n\tpr_err(\"inuse command requires dirfd to be a directory\\n\");\n\treturn -ENOTDIR;\n\ninval:\n\tpr_err(\"inuse command requires dirfd and filename\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int cachefiles_daemon_bind(struct cachefiles_cache *cache, char *args)\n{\n\t_enter(\"{%u,%u,%u,%u,%u,%u},%s\",\n\t       cache->frun_percent,\n\t       cache->fcull_percent,\n\t       cache->fstop_percent,\n\t       cache->brun_percent,\n\t       cache->bcull_percent,\n\t       cache->bstop_percent,\n\t       args);\n\n\tif (cache->fstop_percent >= cache->fcull_percent ||\n\t    cache->fcull_percent >= cache->frun_percent ||\n\t    cache->frun_percent  >= 100)\n\t\treturn -ERANGE;\n\n\tif (cache->bstop_percent >= cache->bcull_percent ||\n\t    cache->bcull_percent >= cache->brun_percent ||\n\t    cache->brun_percent  >= 100)\n\t\treturn -ERANGE;\n\n\tif (!cache->rootdirname) {\n\t\tpr_err(\"No cache directory specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (test_bit(CACHEFILES_READY, &cache->flags)) {\n\t\tpr_err(\"Cache already bound\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (IS_ENABLED(CONFIG_CACHEFILES_ONDEMAND)) {\n\t\tif (!strcmp(args, \"ondemand\")) {\n\t\t\tset_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags);\n\t\t} else if (*args) {\n\t\t\tpr_err(\"Invalid argument to the 'bind' command\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (*args) {\n\t\tpr_err(\"'bind' command doesn't take an argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!cache->tag) {\n\t\t \n\t\tcache->tag = kstrdup(\"CacheFiles\", GFP_KERNEL);\n\t\tif (!cache->tag)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn cachefiles_add_cache(cache);\n}\n\n \nstatic void cachefiles_daemon_unbind(struct cachefiles_cache *cache)\n{\n\t_enter(\"\");\n\n\tif (test_bit(CACHEFILES_READY, &cache->flags))\n\t\tcachefiles_withdraw_cache(cache);\n\n\tcachefiles_put_directory(cache->graveyard);\n\tcachefiles_put_directory(cache->store);\n\tmntput(cache->mnt);\n\n\tkfree(cache->rootdirname);\n\tkfree(cache->secctx);\n\tkfree(cache->tag);\n\n\t_leave(\"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}