{
  "module_name": "volume.c",
  "hash_id": "b67fce8715601767fa2d3149aa7dc97af4a3108e2a114c86c7694da7f7c691d5",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/volume.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n#include <trace/events/fscache.h>\n\n \nvoid cachefiles_acquire_volume(struct fscache_volume *vcookie)\n{\n\tstruct cachefiles_volume *volume;\n\tstruct cachefiles_cache *cache = vcookie->cache->cache_priv;\n\tconst struct cred *saved_cred;\n\tstruct dentry *vdentry, *fan;\n\tsize_t len;\n\tchar *name;\n\tbool is_new = false;\n\tint ret, n_accesses, i;\n\n\t_enter(\"\");\n\n\tvolume = kzalloc(sizeof(struct cachefiles_volume), GFP_KERNEL);\n\tif (!volume)\n\t\treturn;\n\tvolume->vcookie = vcookie;\n\tvolume->cache = cache;\n\tINIT_LIST_HEAD(&volume->cache_link);\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\n\tlen = vcookie->key[0];\n\tname = kmalloc(len + 3, GFP_NOFS);\n\tif (!name)\n\t\tgoto error_vol;\n\tname[0] = 'I';\n\tmemcpy(name + 1, vcookie->key + 1, len);\n\tname[len + 1] = 0;\n\nretry:\n\tvdentry = cachefiles_get_directory(cache, cache->store, name, &is_new);\n\tif (IS_ERR(vdentry))\n\t\tgoto error_name;\n\tvolume->dentry = vdentry;\n\n\tif (is_new) {\n\t\tif (!cachefiles_set_volume_xattr(volume))\n\t\t\tgoto error_dir;\n\t} else {\n\t\tret = cachefiles_check_volume_xattr(volume);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ESTALE)\n\t\t\t\tgoto error_dir;\n\t\t\tinode_lock_nested(d_inode(cache->store), I_MUTEX_PARENT);\n\t\t\tcachefiles_bury_object(cache, NULL, cache->store, vdentry,\n\t\t\t\t\t       FSCACHE_VOLUME_IS_WEIRD);\n\t\t\tcachefiles_put_directory(volume->dentry);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 256; i++) {\n\t\tsprintf(name, \"@%02x\", i);\n\t\tfan = cachefiles_get_directory(cache, vdentry, name, NULL);\n\t\tif (IS_ERR(fan))\n\t\t\tgoto error_fan;\n\t\tvolume->fanout[i] = fan;\n\t}\n\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tvcookie->cache_priv = volume;\n\tn_accesses = atomic_inc_return(&vcookie->n_accesses);  \n\ttrace_fscache_access_volume(vcookie->debug_id, 0,\n\t\t\t\t    refcount_read(&vcookie->ref),\n\t\t\t\t    n_accesses, fscache_access_cache_pin);\n\n\tspin_lock(&cache->object_list_lock);\n\tlist_add(&volume->cache_link, &volume->cache->volumes);\n\tspin_unlock(&cache->object_list_lock);\n\n\tkfree(name);\n\treturn;\n\nerror_fan:\n\tfor (i = 0; i < 256; i++)\n\t\tcachefiles_put_directory(volume->fanout[i]);\nerror_dir:\n\tcachefiles_put_directory(volume->dentry);\nerror_name:\n\tkfree(name);\nerror_vol:\n\tkfree(volume);\n\tcachefiles_end_secure(cache, saved_cred);\n}\n\n \nstatic void __cachefiles_free_volume(struct cachefiles_volume *volume)\n{\n\tint i;\n\n\t_enter(\"\");\n\n\tvolume->vcookie->cache_priv = NULL;\n\n\tfor (i = 0; i < 256; i++)\n\t\tcachefiles_put_directory(volume->fanout[i]);\n\tcachefiles_put_directory(volume->dentry);\n\tkfree(volume);\n}\n\nvoid cachefiles_free_volume(struct fscache_volume *vcookie)\n{\n\tstruct cachefiles_volume *volume = vcookie->cache_priv;\n\n\tif (volume) {\n\t\tspin_lock(&volume->cache->object_list_lock);\n\t\tlist_del_init(&volume->cache_link);\n\t\tspin_unlock(&volume->cache->object_list_lock);\n\t\t__cachefiles_free_volume(volume);\n\t}\n}\n\nvoid cachefiles_withdraw_volume(struct cachefiles_volume *volume)\n{\n\tfscache_withdraw_volume(volume->vcookie);\n\tcachefiles_set_volume_xattr(volume);\n\t__cachefiles_free_volume(volume);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}