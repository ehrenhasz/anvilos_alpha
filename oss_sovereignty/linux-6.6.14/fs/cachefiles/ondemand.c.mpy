{
  "module_name": "ondemand.c",
  "hash_id": "3900bd83f6acbb2c4abcfd1d9953b65d5138e24dde12caf6e9ac3f0e1dfec8a7",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/ondemand.c",
  "human_readable_source": "\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/uio.h>\n#include \"internal.h\"\n\nstatic int cachefiles_ondemand_fd_release(struct inode *inode,\n\t\t\t\t\t  struct file *file)\n{\n\tstruct cachefiles_object *object = file->private_data;\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tint object_id = object->ondemand_id;\n\tstruct cachefiles_req *req;\n\tXA_STATE(xas, &cache->reqs, 0);\n\n\txa_lock(&cache->reqs);\n\tobject->ondemand_id = CACHEFILES_ONDEMAND_ID_CLOSED;\n\n\t \n\txas_for_each(&xas, req, ULONG_MAX) {\n\t\tif (req->msg.object_id == object_id &&\n\t\t    req->msg.opcode == CACHEFILES_OP_READ) {\n\t\t\treq->error = -EIO;\n\t\t\tcomplete(&req->done);\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txa_unlock(&cache->reqs);\n\n\txa_erase(&cache->ondemand_ids, object_id);\n\ttrace_cachefiles_ondemand_fd_release(object, object_id);\n\tcachefiles_put_object(object, cachefiles_obj_put_ondemand_fd);\n\tcachefiles_put_unbind_pincount(cache);\n\treturn 0;\n}\n\nstatic ssize_t cachefiles_ondemand_fd_write_iter(struct kiocb *kiocb,\n\t\t\t\t\t\t struct iov_iter *iter)\n{\n\tstruct cachefiles_object *object = kiocb->ki_filp->private_data;\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct file *file = object->file;\n\tsize_t len = iter->count;\n\tloff_t pos = kiocb->ki_pos;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\tif (!file)\n\t\treturn -ENOBUFS;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = __cachefiles_prepare_write(object, file, &pos, &len, true);\n\tcachefiles_end_secure(cache, saved_cred);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_cachefiles_ondemand_fd_write(object, file_inode(file), pos, len);\n\tret = __cachefiles_write(object, file, pos, iter, NULL, NULL);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n\nstatic loff_t cachefiles_ondemand_fd_llseek(struct file *filp, loff_t pos,\n\t\t\t\t\t    int whence)\n{\n\tstruct cachefiles_object *object = filp->private_data;\n\tstruct file *file = object->file;\n\n\tif (!file)\n\t\treturn -ENOBUFS;\n\n\treturn vfs_llseek(file, pos, whence);\n}\n\nstatic long cachefiles_ondemand_fd_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\t\t\t unsigned long arg)\n{\n\tstruct cachefiles_object *object = filp->private_data;\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct cachefiles_req *req;\n\tunsigned long id;\n\n\tif (ioctl != CACHEFILES_IOC_READ_COMPLETE)\n\t\treturn -EINVAL;\n\n\tif (!test_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags))\n\t\treturn -EOPNOTSUPP;\n\n\tid = arg;\n\treq = xa_erase(&cache->reqs, id);\n\tif (!req)\n\t\treturn -EINVAL;\n\n\ttrace_cachefiles_ondemand_cread(object, id);\n\tcomplete(&req->done);\n\treturn 0;\n}\n\nstatic const struct file_operations cachefiles_ondemand_fd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= cachefiles_ondemand_fd_release,\n\t.write_iter\t= cachefiles_ondemand_fd_write_iter,\n\t.llseek\t\t= cachefiles_ondemand_fd_llseek,\n\t.unlocked_ioctl\t= cachefiles_ondemand_fd_ioctl,\n};\n\n \nint cachefiles_ondemand_copen(struct cachefiles_cache *cache, char *args)\n{\n\tstruct cachefiles_req *req;\n\tstruct fscache_cookie *cookie;\n\tchar *pid, *psize;\n\tunsigned long id;\n\tlong size;\n\tint ret;\n\n\tif (!test_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!*args) {\n\t\tpr_err(\"Empty id specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpid = args;\n\tpsize = strchr(args, ',');\n\tif (!psize) {\n\t\tpr_err(\"Cache size is not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*psize = 0;\n\tpsize++;\n\n\tret = kstrtoul(pid, 0, &id);\n\tif (ret)\n\t\treturn ret;\n\n\treq = xa_erase(&cache->reqs, id);\n\tif (!req)\n\t\treturn -EINVAL;\n\n\t \n\tret = kstrtol(psize, 0, &size);\n\tif (ret) {\n\t\treq->error = ret;\n\t\tgoto out;\n\t}\n\n\t \n\tif (size < 0) {\n\t\tif (!IS_ERR_VALUE(size)) {\n\t\t\treq->error = -EINVAL;\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\treq->error = size;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcookie = req->object->cookie;\n\tcookie->object_size = size;\n\tif (size)\n\t\tclear_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\telse\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\ttrace_cachefiles_ondemand_copen(req->object, id, size);\n\nout:\n\tcomplete(&req->done);\n\treturn ret;\n}\n\nstatic int cachefiles_ondemand_get_fd(struct cachefiles_req *req)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct cachefiles_open *load;\n\tstruct file *file;\n\tu32 object_id;\n\tint ret, fd;\n\n\tobject = cachefiles_grab_object(req->object,\n\t\t\tcachefiles_obj_get_ondemand_fd);\n\tcache = object->volume->cache;\n\n\tret = xa_alloc_cyclic(&cache->ondemand_ids, &object_id, NULL,\n\t\t\t      XA_LIMIT(1, INT_MAX),\n\t\t\t      &cache->ondemand_id_next, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tfd = get_unused_fd_flags(O_WRONLY);\n\tif (fd < 0) {\n\t\tret = fd;\n\t\tgoto err_free_id;\n\t}\n\n\tfile = anon_inode_getfile(\"[cachefiles]\", &cachefiles_ondemand_fd_fops,\n\t\t\t\t  object, O_WRONLY);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto err_put_fd;\n\t}\n\n\tfile->f_mode |= FMODE_PWRITE | FMODE_LSEEK;\n\tfd_install(fd, file);\n\n\tload = (void *)req->msg.data;\n\tload->fd = fd;\n\treq->msg.object_id = object_id;\n\tobject->ondemand_id = object_id;\n\n\tcachefiles_get_unbind_pincount(cache);\n\ttrace_cachefiles_ondemand_open(object, &req->msg, load);\n\treturn 0;\n\nerr_put_fd:\n\tput_unused_fd(fd);\nerr_free_id:\n\txa_erase(&cache->ondemand_ids, object_id);\nerr:\n\tcachefiles_put_object(object, cachefiles_obj_put_ondemand_fd);\n\treturn ret;\n}\n\nssize_t cachefiles_ondemand_daemon_read(struct cachefiles_cache *cache,\n\t\t\t\t\tchar __user *_buffer, size_t buflen)\n{\n\tstruct cachefiles_req *req;\n\tstruct cachefiles_msg *msg;\n\tunsigned long id = 0;\n\tsize_t n;\n\tint ret = 0;\n\tXA_STATE(xas, &cache->reqs, cache->req_id_next);\n\n\t \n\txa_lock(&cache->reqs);\n\treq = xas_find_marked(&xas, UINT_MAX, CACHEFILES_REQ_NEW);\n\tif (!req && cache->req_id_next > 0) {\n\t\txas_set(&xas, 0);\n\t\treq = xas_find_marked(&xas, cache->req_id_next - 1, CACHEFILES_REQ_NEW);\n\t}\n\tif (!req) {\n\t\txa_unlock(&cache->reqs);\n\t\treturn 0;\n\t}\n\n\tmsg = &req->msg;\n\tn = msg->len;\n\n\tif (n > buflen) {\n\t\txa_unlock(&cache->reqs);\n\t\treturn -EMSGSIZE;\n\t}\n\n\txas_clear_mark(&xas, CACHEFILES_REQ_NEW);\n\tcache->req_id_next = xas.xa_index + 1;\n\txa_unlock(&cache->reqs);\n\n\tid = xas.xa_index;\n\tmsg->msg_id = id;\n\n\tif (msg->opcode == CACHEFILES_OP_OPEN) {\n\t\tret = cachefiles_ondemand_get_fd(req);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (copy_to_user(_buffer, msg, n) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto err_put_fd;\n\t}\n\n\t \n\tif (msg->opcode == CACHEFILES_OP_CLOSE) {\n\t\txa_erase(&cache->reqs, id);\n\t\tcomplete(&req->done);\n\t}\n\n\treturn n;\n\nerr_put_fd:\n\tif (msg->opcode == CACHEFILES_OP_OPEN)\n\t\tclose_fd(((struct cachefiles_open *)msg->data)->fd);\nerror:\n\txa_erase(&cache->reqs, id);\n\treq->error = ret;\n\tcomplete(&req->done);\n\treturn ret;\n}\n\ntypedef int (*init_req_fn)(struct cachefiles_req *req, void *private);\n\nstatic int cachefiles_ondemand_send_req(struct cachefiles_object *object,\n\t\t\t\t\tenum cachefiles_opcode opcode,\n\t\t\t\t\tsize_t data_len,\n\t\t\t\t\tinit_req_fn init_req,\n\t\t\t\t\tvoid *private)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct cachefiles_req *req;\n\tXA_STATE(xas, &cache->reqs, 0);\n\tint ret;\n\n\tif (!test_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags))\n\t\treturn 0;\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags))\n\t\treturn -EIO;\n\n\treq = kzalloc(sizeof(*req) + data_len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->object = object;\n\tinit_completion(&req->done);\n\treq->msg.opcode = opcode;\n\treq->msg.len = sizeof(struct cachefiles_msg) + data_len;\n\n\tret = init_req(req, private);\n\tif (ret)\n\t\tgoto out;\n\n\tdo {\n\t\t \n\t\txas_lock(&xas);\n\n\t\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\t\txas_unlock(&xas);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tsmp_mb();\n\n\t\tif (opcode != CACHEFILES_OP_OPEN && object->ondemand_id <= 0) {\n\t\t\tWARN_ON_ONCE(object->ondemand_id == 0);\n\t\t\txas_unlock(&xas);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\txas.xa_index = 0;\n\t\txas_find_marked(&xas, UINT_MAX, XA_FREE_MARK);\n\t\tif (xas.xa_node == XAS_RESTART)\n\t\t\txas_set_err(&xas, -EBUSY);\n\t\txas_store(&xas, req);\n\t\txas_clear_mark(&xas, XA_FREE_MARK);\n\t\txas_set_mark(&xas, CACHEFILES_REQ_NEW);\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tret = xas_error(&xas);\n\tif (ret)\n\t\tgoto out;\n\n\twake_up_all(&cache->daemon_pollwq);\n\twait_for_completion(&req->done);\n\tret = req->error;\nout:\n\tkfree(req);\n\treturn ret;\n}\n\nstatic int cachefiles_ondemand_init_open_req(struct cachefiles_req *req,\n\t\t\t\t\t     void *private)\n{\n\tstruct cachefiles_object *object = req->object;\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_volume *volume = object->volume->vcookie;\n\tstruct cachefiles_open *load = (void *)req->msg.data;\n\tsize_t volume_key_size, cookie_key_size;\n\tvoid *volume_key, *cookie_key;\n\n\t \n\tvolume_key_size = volume->key[0] + 1;\n\tvolume_key = volume->key + 1;\n\n\t \n\tcookie_key_size = cookie->key_len;\n\tcookie_key = fscache_get_key(cookie);\n\n\tif (!(object->cookie->advice & FSCACHE_ADV_WANT_CACHE_SIZE)) {\n\t\tpr_err(\"WANT_CACHE_SIZE is needed for on-demand mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tload->volume_key_size = volume_key_size;\n\tload->cookie_key_size = cookie_key_size;\n\tmemcpy(load->data, volume_key, volume_key_size);\n\tmemcpy(load->data + volume_key_size, cookie_key, cookie_key_size);\n\n\treturn 0;\n}\n\nstatic int cachefiles_ondemand_init_close_req(struct cachefiles_req *req,\n\t\t\t\t\t      void *private)\n{\n\tstruct cachefiles_object *object = req->object;\n\tint object_id = object->ondemand_id;\n\n\t \n\tif (object_id <= 0)\n\t\treturn -ENOENT;\n\n\treq->msg.object_id = object_id;\n\ttrace_cachefiles_ondemand_close(object, &req->msg);\n\treturn 0;\n}\n\nstruct cachefiles_read_ctx {\n\tloff_t off;\n\tsize_t len;\n};\n\nstatic int cachefiles_ondemand_init_read_req(struct cachefiles_req *req,\n\t\t\t\t\t     void *private)\n{\n\tstruct cachefiles_object *object = req->object;\n\tstruct cachefiles_read *load = (void *)req->msg.data;\n\tstruct cachefiles_read_ctx *read_ctx = private;\n\tint object_id = object->ondemand_id;\n\n\t \n\tif (object_id <= 0) {\n\t\tWARN_ON_ONCE(object_id == 0);\n\t\tpr_info_once(\"READ: anonymous fd closed prematurely.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq->msg.object_id = object_id;\n\tload->off = read_ctx->off;\n\tload->len = read_ctx->len;\n\ttrace_cachefiles_ondemand_read(object, &req->msg, load);\n\treturn 0;\n}\n\nint cachefiles_ondemand_init_object(struct cachefiles_object *object)\n{\n\tstruct fscache_cookie *cookie = object->cookie;\n\tstruct fscache_volume *volume = object->volume->vcookie;\n\tsize_t volume_key_size, cookie_key_size, data_len;\n\n\t \n\tif (object->ondemand_id > 0)\n\t\treturn 0;\n\n\tvolume_key_size = volume->key[0] + 1;\n\tcookie_key_size = cookie->key_len;\n\tdata_len = sizeof(struct cachefiles_open) +\n\t\t   volume_key_size + cookie_key_size;\n\n\treturn cachefiles_ondemand_send_req(object, CACHEFILES_OP_OPEN,\n\t\t\tdata_len, cachefiles_ondemand_init_open_req, NULL);\n}\n\nvoid cachefiles_ondemand_clean_object(struct cachefiles_object *object)\n{\n\tcachefiles_ondemand_send_req(object, CACHEFILES_OP_CLOSE, 0,\n\t\t\tcachefiles_ondemand_init_close_req, NULL);\n}\n\nint cachefiles_ondemand_read(struct cachefiles_object *object,\n\t\t\t     loff_t pos, size_t len)\n{\n\tstruct cachefiles_read_ctx read_ctx = {pos, len};\n\n\treturn cachefiles_ondemand_send_req(object, CACHEFILES_OP_READ,\n\t\t\tsizeof(struct cachefiles_read),\n\t\t\tcachefiles_ondemand_init_read_req, &read_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}