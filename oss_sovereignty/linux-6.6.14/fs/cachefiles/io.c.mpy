{
  "module_name": "io.c",
  "hash_id": "f95484f50b9e3a674d785a885ec92b3f699a60a3eb1700b6fd199a6443bf1d97",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/io.c",
  "human_readable_source": "\n \n\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/uio.h>\n#include <linux/falloc.h>\n#include <linux/sched/mm.h>\n#include <trace/events/fscache.h>\n#include \"internal.h\"\n\nstruct cachefiles_kiocb {\n\tstruct kiocb\t\tiocb;\n\trefcount_t\t\tki_refcnt;\n\tloff_t\t\t\tstart;\n\tunion {\n\t\tsize_t\t\tskipped;\n\t\tsize_t\t\tlen;\n\t};\n\tstruct cachefiles_object *object;\n\tnetfs_io_terminated_t\tterm_func;\n\tvoid\t\t\t*term_func_priv;\n\tbool\t\t\twas_async;\n\tunsigned int\t\tinval_counter;\t \n\tu64\t\t\tb_writing;\n};\n\nstatic inline void cachefiles_put_kiocb(struct cachefiles_kiocb *ki)\n{\n\tif (refcount_dec_and_test(&ki->ki_refcnt)) {\n\t\tcachefiles_put_object(ki->object, cachefiles_obj_put_ioreq);\n\t\tfput(ki->iocb.ki_filp);\n\t\tkfree(ki);\n\t}\n}\n\n \nstatic void cachefiles_read_complete(struct kiocb *iocb, long ret)\n{\n\tstruct cachefiles_kiocb *ki = container_of(iocb, struct cachefiles_kiocb, iocb);\n\tstruct inode *inode = file_inode(ki->iocb.ki_filp);\n\n\t_enter(\"%ld\", ret);\n\n\tif (ret < 0)\n\t\ttrace_cachefiles_io_error(ki->object, inode, ret,\n\t\t\t\t\t  cachefiles_trace_read_error);\n\n\tif (ki->term_func) {\n\t\tif (ret >= 0) {\n\t\t\tif (ki->object->cookie->inval_counter == ki->inval_counter)\n\t\t\t\tki->skipped += ret;\n\t\t\telse\n\t\t\t\tret = -ESTALE;\n\t\t}\n\n\t\tki->term_func(ki->term_func_priv, ret, ki->was_async);\n\t}\n\n\tcachefiles_put_kiocb(ki);\n}\n\n \nstatic int cachefiles_read(struct netfs_cache_resources *cres,\n\t\t\t   loff_t start_pos,\n\t\t\t   struct iov_iter *iter,\n\t\t\t   enum netfs_read_from_hole read_hole,\n\t\t\t   netfs_io_terminated_t term_func,\n\t\t\t   void *term_func_priv)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_kiocb *ki;\n\tstruct file *file;\n\tunsigned int old_nofs;\n\tssize_t ret = -ENOBUFS;\n\tsize_t len = iov_iter_count(iter), skipped = 0;\n\n\tif (!fscache_wait_for_operation(cres, FSCACHE_WANT_READ))\n\t\tgoto presubmission_error;\n\n\tfscache_count_read();\n\tobject = cachefiles_cres_object(cres);\n\tfile = cachefiles_cres_file(cres);\n\n\t_enter(\"%pD,%li,%llx,%zx/%llx\",\n\t       file, file_inode(file)->i_ino, start_pos, len,\n\t       i_size_read(file_inode(file)));\n\n\t \n\tif (read_hole != NETFS_READ_HOLE_IGNORE) {\n\t\tloff_t off = start_pos, off2;\n\n\t\toff2 = cachefiles_inject_read_error();\n\t\tif (off2 == 0)\n\t\t\toff2 = vfs_llseek(file, off, SEEK_DATA);\n\t\tif (off2 < 0 && off2 >= (loff_t)-MAX_ERRNO && off2 != -ENXIO) {\n\t\t\tskipped = 0;\n\t\t\tret = off2;\n\t\t\tgoto presubmission_error;\n\t\t}\n\n\t\tif (off2 == -ENXIO || off2 >= start_pos + len) {\n\t\t\t \n\t\t\tret = -ENODATA;\n\t\t\tif (read_hole == NETFS_READ_HOLE_FAIL)\n\t\t\t\tgoto presubmission_error;\n\n\t\t\tiov_iter_zero(len, iter);\n\t\t\tskipped = len;\n\t\t\tret = 0;\n\t\t\tgoto presubmission_error;\n\t\t}\n\n\t\tskipped = off2 - off;\n\t\tiov_iter_zero(skipped, iter);\n\t}\n\n\tret = -ENOMEM;\n\tki = kzalloc(sizeof(struct cachefiles_kiocb), GFP_KERNEL);\n\tif (!ki)\n\t\tgoto presubmission_error;\n\n\trefcount_set(&ki->ki_refcnt, 2);\n\tki->iocb.ki_filp\t= file;\n\tki->iocb.ki_pos\t\t= start_pos + skipped;\n\tki->iocb.ki_flags\t= IOCB_DIRECT;\n\tki->iocb.ki_ioprio\t= get_current_ioprio();\n\tki->skipped\t\t= skipped;\n\tki->object\t\t= object;\n\tki->inval_counter\t= cres->inval_counter;\n\tki->term_func\t\t= term_func;\n\tki->term_func_priv\t= term_func_priv;\n\tki->was_async\t\t= true;\n\n\tif (ki->term_func)\n\t\tki->iocb.ki_complete = cachefiles_read_complete;\n\n\tget_file(ki->iocb.ki_filp);\n\tcachefiles_grab_object(object, cachefiles_obj_get_ioreq);\n\n\ttrace_cachefiles_read(object, file_inode(file), ki->iocb.ki_pos, len - skipped);\n\told_nofs = memalloc_nofs_save();\n\tret = cachefiles_inject_read_error();\n\tif (ret == 0)\n\t\tret = vfs_iocb_iter_read(file, &ki->iocb, iter);\n\tmemalloc_nofs_restore(old_nofs);\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tgoto in_progress;\n\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t \n\t\tret = -EINTR;\n\t\tfallthrough;\n\tdefault:\n\t\tki->was_async = false;\n\t\tcachefiles_read_complete(&ki->iocb, ret);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nin_progress:\n\tcachefiles_put_kiocb(ki);\n\t_leave(\" = %zd\", ret);\n\treturn ret;\n\npresubmission_error:\n\tif (term_func)\n\t\tterm_func(term_func_priv, ret < 0 ? ret : skipped, false);\n\treturn ret;\n}\n\n \nstatic int cachefiles_query_occupancy(struct netfs_cache_resources *cres,\n\t\t\t\t      loff_t start, size_t len, size_t granularity,\n\t\t\t\t      loff_t *_data_start, size_t *_data_len)\n{\n\tstruct cachefiles_object *object;\n\tstruct file *file;\n\tloff_t off, off2;\n\n\t*_data_start = -1;\n\t*_data_len = 0;\n\n\tif (!fscache_wait_for_operation(cres, FSCACHE_WANT_READ))\n\t\treturn -ENOBUFS;\n\n\tobject = cachefiles_cres_object(cres);\n\tfile = cachefiles_cres_file(cres);\n\tgranularity = max_t(size_t, object->volume->cache->bsize, granularity);\n\n\t_enter(\"%pD,%li,%llx,%zx/%llx\",\n\t       file, file_inode(file)->i_ino, start, len,\n\t       i_size_read(file_inode(file)));\n\n\toff = cachefiles_inject_read_error();\n\tif (off == 0)\n\t\toff = vfs_llseek(file, start, SEEK_DATA);\n\tif (off == -ENXIO)\n\t\treturn -ENODATA;  \n\tif (off < 0 && off >= (loff_t)-MAX_ERRNO)\n\t\treturn -ENOBUFS;  \n\tif (round_up(off, granularity) >= start + len)\n\t\treturn -ENODATA;  \n\n\toff2 = cachefiles_inject_read_error();\n\tif (off2 == 0)\n\t\toff2 = vfs_llseek(file, off, SEEK_HOLE);\n\tif (off2 == -ENXIO)\n\t\treturn -ENODATA;  \n\tif (off2 < 0 && off2 >= (loff_t)-MAX_ERRNO)\n\t\treturn -ENOBUFS;  \n\n\t \n\toff = round_up(off, granularity);\n\toff2 = round_down(off2, granularity);\n\tif (off2 <= off)\n\t\treturn -ENODATA;\n\n\t*_data_start = off;\n\tif (off2 > start + len)\n\t\t*_data_len = len;\n\telse\n\t\t*_data_len = off2 - off;\n\treturn 0;\n}\n\n \nstatic void cachefiles_write_complete(struct kiocb *iocb, long ret)\n{\n\tstruct cachefiles_kiocb *ki = container_of(iocb, struct cachefiles_kiocb, iocb);\n\tstruct cachefiles_object *object = ki->object;\n\tstruct inode *inode = file_inode(ki->iocb.ki_filp);\n\n\t_enter(\"%ld\", ret);\n\n\tkiocb_end_write(iocb);\n\n\tif (ret < 0)\n\t\ttrace_cachefiles_io_error(object, inode, ret,\n\t\t\t\t\t  cachefiles_trace_write_error);\n\n\tatomic_long_sub(ki->b_writing, &object->volume->cache->b_writing);\n\tset_bit(FSCACHE_COOKIE_HAVE_DATA, &object->cookie->flags);\n\tif (ki->term_func)\n\t\tki->term_func(ki->term_func_priv, ret, ki->was_async);\n\tcachefiles_put_kiocb(ki);\n}\n\n \nint __cachefiles_write(struct cachefiles_object *object,\n\t\t       struct file *file,\n\t\t       loff_t start_pos,\n\t\t       struct iov_iter *iter,\n\t\t       netfs_io_terminated_t term_func,\n\t\t       void *term_func_priv)\n{\n\tstruct cachefiles_cache *cache;\n\tstruct cachefiles_kiocb *ki;\n\tunsigned int old_nofs;\n\tssize_t ret;\n\tsize_t len = iov_iter_count(iter);\n\n\tfscache_count_write();\n\tcache = object->volume->cache;\n\n\t_enter(\"%pD,%li,%llx,%zx/%llx\",\n\t       file, file_inode(file)->i_ino, start_pos, len,\n\t       i_size_read(file_inode(file)));\n\n\tki = kzalloc(sizeof(struct cachefiles_kiocb), GFP_KERNEL);\n\tif (!ki) {\n\t\tif (term_func)\n\t\t\tterm_func(term_func_priv, -ENOMEM, false);\n\t\treturn -ENOMEM;\n\t}\n\n\trefcount_set(&ki->ki_refcnt, 2);\n\tki->iocb.ki_filp\t= file;\n\tki->iocb.ki_pos\t\t= start_pos;\n\tki->iocb.ki_flags\t= IOCB_DIRECT | IOCB_WRITE;\n\tki->iocb.ki_ioprio\t= get_current_ioprio();\n\tki->object\t\t= object;\n\tki->start\t\t= start_pos;\n\tki->len\t\t\t= len;\n\tki->term_func\t\t= term_func;\n\tki->term_func_priv\t= term_func_priv;\n\tki->was_async\t\t= true;\n\tki->b_writing\t\t= (len + (1 << cache->bshift) - 1) >> cache->bshift;\n\n\tif (ki->term_func)\n\t\tki->iocb.ki_complete = cachefiles_write_complete;\n\tatomic_long_add(ki->b_writing, &cache->b_writing);\n\n\tkiocb_start_write(&ki->iocb);\n\n\tget_file(ki->iocb.ki_filp);\n\tcachefiles_grab_object(object, cachefiles_obj_get_ioreq);\n\n\ttrace_cachefiles_write(object, file_inode(file), ki->iocb.ki_pos, len);\n\told_nofs = memalloc_nofs_save();\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0)\n\t\tret = vfs_iocb_iter_write(file, &ki->iocb, iter);\n\tmemalloc_nofs_restore(old_nofs);\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tgoto in_progress;\n\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t \n\t\tret = -EINTR;\n\t\tfallthrough;\n\tdefault:\n\t\tki->was_async = false;\n\t\tcachefiles_write_complete(&ki->iocb, ret);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nin_progress:\n\tcachefiles_put_kiocb(ki);\n\t_leave(\" = %zd\", ret);\n\treturn ret;\n}\n\nstatic int cachefiles_write(struct netfs_cache_resources *cres,\n\t\t\t    loff_t start_pos,\n\t\t\t    struct iov_iter *iter,\n\t\t\t    netfs_io_terminated_t term_func,\n\t\t\t    void *term_func_priv)\n{\n\tif (!fscache_wait_for_operation(cres, FSCACHE_WANT_WRITE)) {\n\t\tif (term_func)\n\t\t\tterm_func(term_func_priv, -ENOBUFS, false);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn __cachefiles_write(cachefiles_cres_object(cres),\n\t\t\t\t  cachefiles_cres_file(cres),\n\t\t\t\t  start_pos, iter,\n\t\t\t\t  term_func, term_func_priv);\n}\n\nstatic inline enum netfs_io_source\ncachefiles_do_prepare_read(struct netfs_cache_resources *cres,\n\t\t\t   loff_t start, size_t *_len, loff_t i_size,\n\t\t\t   unsigned long *_flags, ino_t netfs_ino)\n{\n\tenum cachefiles_prepare_read_trace why;\n\tstruct cachefiles_object *object = NULL;\n\tstruct cachefiles_cache *cache;\n\tstruct fscache_cookie *cookie = fscache_cres_cookie(cres);\n\tconst struct cred *saved_cred;\n\tstruct file *file = cachefiles_cres_file(cres);\n\tenum netfs_io_source ret = NETFS_DOWNLOAD_FROM_SERVER;\n\tsize_t len = *_len;\n\tloff_t off, to;\n\tino_t ino = file ? file_inode(file)->i_ino : 0;\n\tint rc;\n\n\t_enter(\"%zx @%llx/%llx\", len, start, i_size);\n\n\tif (start >= i_size) {\n\t\tret = NETFS_FILL_WITH_ZEROES;\n\t\twhy = cachefiles_trace_read_after_eof;\n\t\tgoto out_no_object;\n\t}\n\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags)) {\n\t\t__set_bit(NETFS_SREQ_COPY_TO_CACHE, _flags);\n\t\twhy = cachefiles_trace_read_no_data;\n\t\tif (!test_bit(NETFS_SREQ_ONDEMAND, _flags))\n\t\t\tgoto out_no_object;\n\t}\n\n\t \n\tif (!file) {\n\t\twhy = cachefiles_trace_read_no_file;\n\t\tif (!fscache_wait_for_operation(cres, FSCACHE_WANT_READ))\n\t\t\tgoto out_no_object;\n\t\tfile = cachefiles_cres_file(cres);\n\t\tif (!file)\n\t\t\tgoto out_no_object;\n\t\tino = file_inode(file)->i_ino;\n\t}\n\n\tobject = cachefiles_cres_object(cres);\n\tcache = object->volume->cache;\n\tcachefiles_begin_secure(cache, &saved_cred);\nretry:\n\toff = cachefiles_inject_read_error();\n\tif (off == 0)\n\t\toff = vfs_llseek(file, start, SEEK_DATA);\n\tif (off < 0 && off >= (loff_t)-MAX_ERRNO) {\n\t\tif (off == (loff_t)-ENXIO) {\n\t\t\twhy = cachefiles_trace_read_seek_nxio;\n\t\t\tgoto download_and_store;\n\t\t}\n\t\ttrace_cachefiles_io_error(object, file_inode(file), off,\n\t\t\t\t\t  cachefiles_trace_seek_error);\n\t\twhy = cachefiles_trace_read_seek_error;\n\t\tgoto out;\n\t}\n\n\tif (off >= start + len) {\n\t\twhy = cachefiles_trace_read_found_hole;\n\t\tgoto download_and_store;\n\t}\n\n\tif (off > start) {\n\t\toff = round_up(off, cache->bsize);\n\t\tlen = off - start;\n\t\t*_len = len;\n\t\twhy = cachefiles_trace_read_found_part;\n\t\tgoto download_and_store;\n\t}\n\n\tto = cachefiles_inject_read_error();\n\tif (to == 0)\n\t\tto = vfs_llseek(file, start, SEEK_HOLE);\n\tif (to < 0 && to >= (loff_t)-MAX_ERRNO) {\n\t\ttrace_cachefiles_io_error(object, file_inode(file), to,\n\t\t\t\t\t  cachefiles_trace_seek_error);\n\t\twhy = cachefiles_trace_read_seek_error;\n\t\tgoto out;\n\t}\n\n\tif (to < start + len) {\n\t\tif (start + len >= i_size)\n\t\t\tto = round_up(to, cache->bsize);\n\t\telse\n\t\t\tto = round_down(to, cache->bsize);\n\t\tlen = to - start;\n\t\t*_len = len;\n\t}\n\n\twhy = cachefiles_trace_read_have_data;\n\tret = NETFS_READ_FROM_CACHE;\n\tgoto out;\n\ndownload_and_store:\n\t__set_bit(NETFS_SREQ_COPY_TO_CACHE, _flags);\n\tif (test_bit(NETFS_SREQ_ONDEMAND, _flags)) {\n\t\trc = cachefiles_ondemand_read(object, start, len);\n\t\tif (!rc) {\n\t\t\t__clear_bit(NETFS_SREQ_ONDEMAND, _flags);\n\t\t\tgoto retry;\n\t\t}\n\t\tret = NETFS_INVALID_READ;\n\t}\nout:\n\tcachefiles_end_secure(cache, saved_cred);\nout_no_object:\n\ttrace_cachefiles_prep_read(object, start, len, *_flags, ret, why, ino, netfs_ino);\n\treturn ret;\n}\n\n \nstatic enum netfs_io_source cachefiles_prepare_read(struct netfs_io_subrequest *subreq,\n\t\t\t\t\t\t    loff_t i_size)\n{\n\treturn cachefiles_do_prepare_read(&subreq->rreq->cache_resources,\n\t\t\t\t\t  subreq->start, &subreq->len, i_size,\n\t\t\t\t\t  &subreq->flags, subreq->rreq->inode->i_ino);\n}\n\n \nstatic enum netfs_io_source\ncachefiles_prepare_ondemand_read(struct netfs_cache_resources *cres,\n\t\t\t\t loff_t start, size_t *_len, loff_t i_size,\n\t\t\t\t unsigned long *_flags, ino_t ino)\n{\n\treturn cachefiles_do_prepare_read(cres, start, _len, i_size, _flags, ino);\n}\n\n \nint __cachefiles_prepare_write(struct cachefiles_object *object,\n\t\t\t       struct file *file,\n\t\t\t       loff_t *_start, size_t *_len,\n\t\t\t       bool no_space_allocated_yet)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tloff_t start = *_start, pos;\n\tsize_t len = *_len, down;\n\tint ret;\n\n\t \n\tdown = start - round_down(start, PAGE_SIZE);\n\t*_start = start - down;\n\t*_len = round_up(down + len, PAGE_SIZE);\n\n\t \n\tif (no_space_allocated_yet)\n\t\tgoto check_space;\n\n\tpos = cachefiles_inject_read_error();\n\tif (pos == 0)\n\t\tpos = vfs_llseek(file, *_start, SEEK_DATA);\n\tif (pos < 0 && pos >= (loff_t)-MAX_ERRNO) {\n\t\tif (pos == -ENXIO)\n\t\t\tgoto check_space;  \n\t\ttrace_cachefiles_io_error(object, file_inode(file), pos,\n\t\t\t\t\t  cachefiles_trace_seek_error);\n\t\treturn pos;\n\t}\n\tif ((u64)pos >= (u64)*_start + *_len)\n\t\tgoto check_space;  \n\n\t \n\tif (cachefiles_has_space(cache, 0, *_len / PAGE_SIZE,\n\t\t\t\t cachefiles_has_space_check) == 0)\n\t\treturn 0;  \n\n\tpos = cachefiles_inject_read_error();\n\tif (pos == 0)\n\t\tpos = vfs_llseek(file, *_start, SEEK_HOLE);\n\tif (pos < 0 && pos >= (loff_t)-MAX_ERRNO) {\n\t\ttrace_cachefiles_io_error(object, file_inode(file), pos,\n\t\t\t\t\t  cachefiles_trace_seek_error);\n\t\treturn pos;\n\t}\n\tif ((u64)pos >= (u64)*_start + *_len)\n\t\treturn 0;  \n\n\t \n\tfscache_count_no_write_space();\n\tret = cachefiles_inject_remove_error();\n\tif (ret == 0)\n\t\tret = vfs_fallocate(file, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\t    *_start, *_len);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_io_error(object, file_inode(file), ret,\n\t\t\t\t\t  cachefiles_trace_fallocate_error);\n\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\"CacheFiles: fallocate failed (%d)\\n\", ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\ncheck_space:\n\treturn cachefiles_has_space(cache, 0, *_len / PAGE_SIZE,\n\t\t\t\t    cachefiles_has_space_for_write);\n}\n\nstatic int cachefiles_prepare_write(struct netfs_cache_resources *cres,\n\t\t\t\t    loff_t *_start, size_t *_len, loff_t i_size,\n\t\t\t\t    bool no_space_allocated_yet)\n{\n\tstruct cachefiles_object *object = cachefiles_cres_object(cres);\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\tif (!cachefiles_cres_file(cres)) {\n\t\tif (!fscache_wait_for_operation(cres, FSCACHE_WANT_WRITE))\n\t\t\treturn -ENOBUFS;\n\t\tif (!cachefiles_cres_file(cres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = __cachefiles_prepare_write(object, cachefiles_cres_file(cres),\n\t\t\t\t\t _start, _len,\n\t\t\t\t\t no_space_allocated_yet);\n\tcachefiles_end_secure(cache, saved_cred);\n\treturn ret;\n}\n\n \nstatic void cachefiles_end_operation(struct netfs_cache_resources *cres)\n{\n\tstruct file *file = cachefiles_cres_file(cres);\n\n\tif (file)\n\t\tfput(file);\n\tfscache_end_cookie_access(fscache_cres_cookie(cres), fscache_access_io_end);\n}\n\nstatic const struct netfs_cache_ops cachefiles_netfs_cache_ops = {\n\t.end_operation\t\t= cachefiles_end_operation,\n\t.read\t\t\t= cachefiles_read,\n\t.write\t\t\t= cachefiles_write,\n\t.prepare_read\t\t= cachefiles_prepare_read,\n\t.prepare_write\t\t= cachefiles_prepare_write,\n\t.prepare_ondemand_read\t= cachefiles_prepare_ondemand_read,\n\t.query_occupancy\t= cachefiles_query_occupancy,\n};\n\n \nbool cachefiles_begin_operation(struct netfs_cache_resources *cres,\n\t\t\t\tenum fscache_want_state want_state)\n{\n\tstruct cachefiles_object *object = cachefiles_cres_object(cres);\n\n\tif (!cachefiles_cres_file(cres)) {\n\t\tcres->ops = &cachefiles_netfs_cache_ops;\n\t\tif (object->file) {\n\t\t\tspin_lock(&object->lock);\n\t\t\tif (!cres->cache_priv2 && object->file)\n\t\t\t\tcres->cache_priv2 = get_file(object->file);\n\t\t\tspin_unlock(&object->lock);\n\t\t}\n\t}\n\n\tif (!cachefiles_cres_file(cres) && want_state != FSCACHE_WANT_PARAMS) {\n\t\tpr_err(\"failed to get cres->file\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}