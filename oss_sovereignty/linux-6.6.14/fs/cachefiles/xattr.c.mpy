{
  "module_name": "xattr.c",
  "hash_id": "0a84db34ac9f59e3814de042292e5c1d66c62fdc1f42ec4b961a5ead48d96207",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/quotaops.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define CACHEFILES_COOKIE_TYPE_DATA 1\n\nstruct cachefiles_xattr {\n\t__be64\tobject_size;\t \n\t__be64\tzero_point;\t \n\t__u8\ttype;\t\t \n\t__u8\tcontent;\t \n\t__u8\tdata[];\t\t \n} __packed;\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nstruct cachefiles_vol_xattr {\n\t__be32\treserved;\t \n\t__u8\tdata[];\t\t \n} __packed;\n\n \nint cachefiles_set_object_xattr(struct cachefiles_object *object)\n{\n\tstruct cachefiles_xattr *buf;\n\tstruct dentry *dentry;\n\tstruct file *file = object->file;\n\tunsigned int len = object->cookie->aux_len;\n\tint ret;\n\n\tif (!file)\n\t\treturn -ESTALE;\n\tdentry = file->f_path.dentry;\n\n\t_enter(\"%x,#%d\", object->debug_id, len);\n\n\tbuf = kmalloc(sizeof(struct cachefiles_xattr) + len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->object_size\t= cpu_to_be64(object->cookie->object_size);\n\tbuf->zero_point\t\t= 0;\n\tbuf->type\t\t= CACHEFILES_COOKIE_TYPE_DATA;\n\tbuf->content\t\t= object->content_info;\n\tif (test_bit(FSCACHE_COOKIE_LOCAL_WRITE, &object->cookie->flags))\n\t\tbuf->content\t= CACHEFILES_CONTENT_DIRTY;\n\tif (len > 0)\n\t\tmemcpy(buf->data, fscache_get_aux(object->cookie), len);\n\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0)\n\t\tret = vfs_setxattr(&nop_mnt_idmap, dentry, cachefiles_xattr_cache,\n\t\t\t\t   buf, sizeof(struct cachefiles_xattr) + len, 0);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(object, file_inode(file), ret,\n\t\t\t\t\t   cachefiles_trace_setxattr_error);\n\t\ttrace_cachefiles_coherency(object, file_inode(file)->i_ino,\n\t\t\t\t\t   buf->content,\n\t\t\t\t\t   cachefiles_coherency_set_fail);\n\t\tif (ret != -ENOMEM)\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject,\n\t\t\t\t\"Failed to set xattr with error %d\", ret);\n\t} else {\n\t\ttrace_cachefiles_coherency(object, file_inode(file)->i_ino,\n\t\t\t\t\t   buf->content,\n\t\t\t\t\t   cachefiles_coherency_set_ok);\n\t}\n\n\tkfree(buf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nint cachefiles_check_auxdata(struct cachefiles_object *object, struct file *file)\n{\n\tstruct cachefiles_xattr *buf;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tunsigned int len = object->cookie->aux_len, tlen;\n\tconst void *p = fscache_get_aux(object->cookie);\n\tenum cachefiles_coherency_trace why;\n\tssize_t xlen;\n\tint ret = -ESTALE;\n\n\ttlen = sizeof(struct cachefiles_xattr) + len;\n\tbuf = kmalloc(tlen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\txlen = cachefiles_inject_read_error();\n\tif (xlen == 0)\n\t\txlen = vfs_getxattr(&nop_mnt_idmap, dentry, cachefiles_xattr_cache, buf, tlen);\n\tif (xlen != tlen) {\n\t\tif (xlen < 0)\n\t\t\ttrace_cachefiles_vfs_error(object, file_inode(file), xlen,\n\t\t\t\t\t\t   cachefiles_trace_getxattr_error);\n\t\tif (xlen == -EIO)\n\t\t\tcachefiles_io_error_obj(\n\t\t\t\tobject,\n\t\t\t\t\"Failed to read aux with error %zd\", xlen);\n\t\twhy = cachefiles_coherency_check_xattr;\n\t} else if (buf->type != CACHEFILES_COOKIE_TYPE_DATA) {\n\t\twhy = cachefiles_coherency_check_type;\n\t} else if (memcmp(buf->data, p, len) != 0) {\n\t\twhy = cachefiles_coherency_check_aux;\n\t} else if (be64_to_cpu(buf->object_size) != object->cookie->object_size) {\n\t\twhy = cachefiles_coherency_check_objsize;\n\t} else if (buf->content == CACHEFILES_CONTENT_DIRTY) {\n\t\t\n\t\tpr_warn(\"Dirty object in cache\\n\");\n\t\twhy = cachefiles_coherency_check_dirty;\n\t} else {\n\t\twhy = cachefiles_coherency_check_ok;\n\t\tret = 0;\n\t}\n\n\ttrace_cachefiles_coherency(object, file_inode(file)->i_ino,\n\t\t\t\t   buf->content, why);\n\tkfree(buf);\n\treturn ret;\n}\n\n \nint cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t   struct cachefiles_object *object,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint ret;\n\n\tret = cachefiles_inject_remove_error();\n\tif (ret == 0)\n\t\tret = vfs_removexattr(&nop_mnt_idmap, dentry, cachefiles_xattr_cache);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(object, d_inode(dentry), ret,\n\t\t\t\t\t   cachefiles_trace_remxattr_error);\n\t\tif (ret == -ENOENT || ret == -ENODATA)\n\t\t\tret = 0;\n\t\telse if (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(cache,\n\t\t\t\t\t    \"Can't remove xattr from %lu\"\n\t\t\t\t\t    \" (error %d)\",\n\t\t\t\t\t    d_backing_inode(dentry)->i_ino, -ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nvoid cachefiles_prepare_to_write(struct fscache_cookie *cookie)\n{\n\tconst struct cred *saved_cred;\n\tstruct cachefiles_object *object = cookie->cache_priv;\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\n\t_enter(\"c=%08x\", object->cookie->debug_id);\n\n\tif (!test_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags)) {\n\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\tcachefiles_set_object_xattr(object);\n\t\tcachefiles_end_secure(cache, saved_cred);\n\t}\n}\n\n \nbool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)\n{\n\tstruct cachefiles_vol_xattr *buf;\n\tunsigned int len = volume->vcookie->coherency_len;\n\tconst void *p = volume->vcookie->coherency;\n\tstruct dentry *dentry = volume->dentry;\n\tint ret;\n\n\t_enter(\"%x,#%d\", volume->vcookie->debug_id, len);\n\n\tlen += sizeof(*buf);\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\tbuf->reserved = cpu_to_be32(0);\n\tmemcpy(buf->data, p, volume->vcookie->coherency_len);\n\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0)\n\t\tret = vfs_setxattr(&nop_mnt_idmap, dentry, cachefiles_xattr_cache,\n\t\t\t\t   buf, len, 0);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(NULL, d_inode(dentry), ret,\n\t\t\t\t\t   cachefiles_trace_setxattr_error);\n\t\ttrace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino,\n\t\t\t\t\t       cachefiles_coherency_vol_set_fail);\n\t\tif (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(\n\t\t\t\tvolume->cache, \"Failed to set xattr with error %d\", ret);\n\t} else {\n\t\ttrace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino,\n\t\t\t\t\t       cachefiles_coherency_vol_set_ok);\n\t}\n\n\tkfree(buf);\n\t_leave(\" = %d\", ret);\n\treturn ret == 0;\n}\n\n \nint cachefiles_check_volume_xattr(struct cachefiles_volume *volume)\n{\n\tstruct cachefiles_vol_xattr *buf;\n\tstruct dentry *dentry = volume->dentry;\n\tunsigned int len = volume->vcookie->coherency_len;\n\tconst void *p = volume->vcookie->coherency;\n\tenum cachefiles_coherency_trace why;\n\tssize_t xlen;\n\tint ret = -ESTALE;\n\n\t_enter(\"\");\n\n\tlen += sizeof(*buf);\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\txlen = cachefiles_inject_read_error();\n\tif (xlen == 0)\n\t\txlen = vfs_getxattr(&nop_mnt_idmap, dentry, cachefiles_xattr_cache, buf, len);\n\tif (xlen != len) {\n\t\tif (xlen < 0) {\n\t\t\ttrace_cachefiles_vfs_error(NULL, d_inode(dentry), xlen,\n\t\t\t\t\t\t   cachefiles_trace_getxattr_error);\n\t\t\tif (xlen == -EIO)\n\t\t\t\tcachefiles_io_error(\n\t\t\t\t\tvolume->cache,\n\t\t\t\t\t\"Failed to read xattr with error %zd\", xlen);\n\t\t}\n\t\twhy = cachefiles_coherency_vol_check_xattr;\n\t} else if (buf->reserved != cpu_to_be32(0)) {\n\t\twhy = cachefiles_coherency_vol_check_resv;\n\t} else if (memcmp(buf->data, p, len - sizeof(*buf)) != 0) {\n\t\twhy = cachefiles_coherency_vol_check_cmp;\n\t} else {\n\t\twhy = cachefiles_coherency_vol_check_ok;\n\t\tret = 0;\n\t}\n\n\ttrace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino, why);\n\tkfree(buf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}