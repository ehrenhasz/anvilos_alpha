{
  "module_name": "interface.c",
  "hash_id": "8cbf876abe92663f75936231af200d3b5b73337e687d6f18f84daf777923ef44",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/interface.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <trace/events/fscache.h>\n#include \"internal.h\"\n\nstatic atomic_t cachefiles_object_debug_id;\n\n \nstatic\nstruct cachefiles_object *cachefiles_alloc_object(struct fscache_cookie *cookie)\n{\n\tstruct fscache_volume *vcookie = cookie->volume;\n\tstruct cachefiles_volume *volume = vcookie->cache_priv;\n\tstruct cachefiles_object *object;\n\n\t_enter(\"{%s},%x,\", vcookie->key, cookie->debug_id);\n\n\tobject = kmem_cache_zalloc(cachefiles_object_jar, GFP_KERNEL);\n\tif (!object)\n\t\treturn NULL;\n\n\trefcount_set(&object->ref, 1);\n\n\tspin_lock_init(&object->lock);\n\tINIT_LIST_HEAD(&object->cache_link);\n\tobject->volume = volume;\n\tobject->debug_id = atomic_inc_return(&cachefiles_object_debug_id);\n\tobject->cookie = fscache_get_cookie(cookie, fscache_cookie_get_attach_object);\n\n\tfscache_count_object(vcookie->cache);\n\ttrace_cachefiles_ref(object->debug_id, cookie->debug_id, 1,\n\t\t\t     cachefiles_obj_new);\n\treturn object;\n}\n\n \nvoid cachefiles_see_object(struct cachefiles_object *object,\n\t\t\t   enum cachefiles_obj_ref_trace why)\n{\n\ttrace_cachefiles_ref(object->debug_id, object->cookie->debug_id,\n\t\t\t     refcount_read(&object->ref), why);\n}\n\n \nstruct cachefiles_object *cachefiles_grab_object(struct cachefiles_object *object,\n\t\t\t\t\t\t enum cachefiles_obj_ref_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&object->ref, &r);\n\ttrace_cachefiles_ref(object->debug_id, object->cookie->debug_id, r, why);\n\treturn object;\n}\n\n \nvoid cachefiles_put_object(struct cachefiles_object *object,\n\t\t\t   enum cachefiles_obj_ref_trace why)\n{\n\tunsigned int object_debug_id = object->debug_id;\n\tunsigned int cookie_debug_id = object->cookie->debug_id;\n\tstruct fscache_cache *cache;\n\tbool done;\n\tint r;\n\n\tdone = __refcount_dec_and_test(&object->ref, &r);\n\ttrace_cachefiles_ref(object_debug_id, cookie_debug_id, r, why);\n\tif (done) {\n\t\t_debug(\"- kill object OBJ%x\", object_debug_id);\n\n\t\tASSERTCMP(object->file, ==, NULL);\n\n\t\tkfree(object->d_name);\n\n\t\tcache = object->volume->cache->cache;\n\t\tfscache_put_cookie(object->cookie, fscache_cookie_put_object);\n\t\tobject->cookie = NULL;\n\t\tkmem_cache_free(cachefiles_object_jar, object);\n\t\tfscache_uncount_object(cache);\n\t}\n\n\t_leave(\"\");\n}\n\n \nstatic int cachefiles_adjust_size(struct cachefiles_object *object)\n{\n\tstruct iattr newattrs;\n\tstruct file *file = object->file;\n\tuint64_t ni_size;\n\tloff_t oi_size;\n\tint ret;\n\n\tni_size = object->cookie->object_size;\n\tni_size = round_up(ni_size, CACHEFILES_DIO_BLOCK_SIZE);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       object->debug_id, (unsigned long long) ni_size);\n\n\tif (!file)\n\t\treturn -ENOBUFS;\n\n\toi_size = i_size_read(file_inode(file));\n\tif (oi_size == ni_size)\n\t\treturn 0;\n\n\tinode_lock(file_inode(file));\n\n\t \n\tif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\n\t\t_debug(\"discard tail %llx\", oi_size);\n\t\tnewattrs.ia_valid = ATTR_SIZE;\n\t\tnewattrs.ia_size = oi_size & PAGE_MASK;\n\t\tret = cachefiles_inject_remove_error();\n\t\tif (ret == 0)\n\t\t\tret = notify_change(&nop_mnt_idmap, file->f_path.dentry,\n\t\t\t\t\t    &newattrs, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto truncate_failed;\n\t}\n\n\tnewattrs.ia_valid = ATTR_SIZE;\n\tnewattrs.ia_size = ni_size;\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0)\n\t\tret = notify_change(&nop_mnt_idmap, file->f_path.dentry,\n\t\t\t\t    &newattrs, NULL);\n\ntruncate_failed:\n\tinode_unlock(file_inode(file));\n\n\tif (ret < 0)\n\t\ttrace_cachefiles_io_error(NULL, file_inode(file), ret,\n\t\t\t\t\t  cachefiles_trace_notify_change_error);\n\tif (ret == -EIO) {\n\t\tcachefiles_io_error_obj(object, \"Size set failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic bool cachefiles_lookup_cookie(struct fscache_cookie *cookie)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache = cookie->volume->cache->cache_priv;\n\tconst struct cred *saved_cred;\n\tbool success;\n\n\tobject = cachefiles_alloc_object(cookie);\n\tif (!object)\n\t\tgoto fail;\n\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tif (!cachefiles_cook_key(object))\n\t\tgoto fail_put;\n\n\tcookie->cache_priv = object;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\n\tsuccess = cachefiles_look_up_object(object);\n\tif (!success)\n\t\tgoto fail_withdraw;\n\n\tcachefiles_see_object(object, cachefiles_obj_see_lookup_cookie);\n\n\tspin_lock(&cache->object_list_lock);\n\tlist_add(&object->cache_link, &cache->object_list);\n\tspin_unlock(&cache->object_list_lock);\n\tcachefiles_adjust_size(object);\n\n\tcachefiles_end_secure(cache, saved_cred);\n\t_leave(\" = t\");\n\treturn true;\n\nfail_withdraw:\n\tcachefiles_end_secure(cache, saved_cred);\n\tcachefiles_see_object(object, cachefiles_obj_see_lookup_failed);\n\tfscache_caching_failed(cookie);\n\t_debug(\"failed c=%08x o=%08x\", cookie->debug_id, object->debug_id);\n\t \n\treturn false;\n\nfail_put:\n\tcachefiles_put_object(object, cachefiles_obj_put_alloc_fail);\nfail:\n\treturn false;\n}\n\n \nstatic bool cachefiles_shorten_object(struct cachefiles_object *object,\n\t\t\t\t      struct file *file, loff_t new_size)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct inode *inode = file_inode(file);\n\tloff_t i_size, dio_size;\n\tint ret;\n\n\tdio_size = round_up(new_size, CACHEFILES_DIO_BLOCK_SIZE);\n\ti_size = i_size_read(inode);\n\n\ttrace_cachefiles_trunc(object, inode, i_size, dio_size,\n\t\t\t       cachefiles_trunc_shrink);\n\tret = cachefiles_inject_remove_error();\n\tif (ret == 0)\n\t\tret = vfs_truncate(&file->f_path, dio_size);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_io_error(object, file_inode(file), ret,\n\t\t\t\t\t  cachefiles_trace_trunc_error);\n\t\tcachefiles_io_error_obj(object, \"Trunc-to-size failed %d\", ret);\n\t\tcachefiles_remove_object_xattr(cache, object, file->f_path.dentry);\n\t\treturn false;\n\t}\n\n\tif (new_size < dio_size) {\n\t\ttrace_cachefiles_trunc(object, inode, dio_size, new_size,\n\t\t\t\t       cachefiles_trunc_dio_adjust);\n\t\tret = cachefiles_inject_write_error();\n\t\tif (ret == 0)\n\t\t\tret = vfs_fallocate(file, FALLOC_FL_ZERO_RANGE,\n\t\t\t\t\t    new_size, dio_size - new_size);\n\t\tif (ret < 0) {\n\t\t\ttrace_cachefiles_io_error(object, file_inode(file), ret,\n\t\t\t\t\t\t  cachefiles_trace_fallocate_error);\n\t\t\tcachefiles_io_error_obj(object, \"Trunc-to-dio-size failed %d\", ret);\n\t\t\tcachefiles_remove_object_xattr(cache, object, file->f_path.dentry);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void cachefiles_resize_cookie(struct netfs_cache_resources *cres,\n\t\t\t\t     loff_t new_size)\n{\n\tstruct cachefiles_object *object = cachefiles_cres_object(cres);\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct fscache_cookie *cookie = object->cookie;\n\tconst struct cred *saved_cred;\n\tstruct file *file = cachefiles_cres_file(cres);\n\tloff_t old_size = cookie->object_size;\n\n\t_enter(\"%llu->%llu\", old_size, new_size);\n\n\tif (new_size < old_size) {\n\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\tcachefiles_shorten_object(object, file, new_size);\n\t\tcachefiles_end_secure(cache, saved_cred);\n\t\tobject->cookie->object_size = new_size;\n\t\treturn;\n\t}\n\n\t \n\tcookie->object_size = new_size;\n}\n\n \nstatic void cachefiles_commit_object(struct cachefiles_object *object,\n\t\t\t\t     struct cachefiles_cache *cache)\n{\n\tbool update = false;\n\n\tif (test_and_clear_bit(FSCACHE_COOKIE_LOCAL_WRITE, &object->cookie->flags))\n\t\tupdate = true;\n\tif (test_and_clear_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &object->cookie->flags))\n\t\tupdate = true;\n\tif (update)\n\t\tcachefiles_set_object_xattr(object);\n\n\tif (test_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags))\n\t\tcachefiles_commit_tmpfile(cache, object);\n}\n\n \nstatic void cachefiles_clean_up_object(struct cachefiles_object *object,\n\t\t\t\t       struct cachefiles_cache *cache)\n{\n\tif (test_bit(FSCACHE_COOKIE_RETIRED, &object->cookie->flags)) {\n\t\tif (!test_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags)) {\n\t\t\tcachefiles_see_object(object, cachefiles_obj_see_clean_delete);\n\t\t\t_debug(\"- inval object OBJ%x\", object->debug_id);\n\t\t\tcachefiles_delete_object(object, FSCACHE_OBJECT_WAS_RETIRED);\n\t\t} else {\n\t\t\tcachefiles_see_object(object, cachefiles_obj_see_clean_drop_tmp);\n\t\t\t_debug(\"- inval object OBJ%x tmpfile\", object->debug_id);\n\t\t}\n\t} else {\n\t\tcachefiles_see_object(object, cachefiles_obj_see_clean_commit);\n\t\tcachefiles_commit_object(object, cache);\n\t}\n\n\tcachefiles_unmark_inode_in_use(object, object->file);\n\tif (object->file) {\n\t\tfput(object->file);\n\t\tobject->file = NULL;\n\t}\n}\n\n \nstatic void cachefiles_withdraw_cookie(struct fscache_cookie *cookie)\n{\n\tstruct cachefiles_object *object = cookie->cache_priv;\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tconst struct cred *saved_cred;\n\n\t_enter(\"o=%x\", object->debug_id);\n\tcachefiles_see_object(object, cachefiles_obj_see_withdraw_cookie);\n\n\tif (!list_empty(&object->cache_link)) {\n\t\tspin_lock(&cache->object_list_lock);\n\t\tcachefiles_see_object(object, cachefiles_obj_see_withdrawal);\n\t\tlist_del_init(&object->cache_link);\n\t\tspin_unlock(&cache->object_list_lock);\n\t}\n\n\tcachefiles_ondemand_clean_object(object);\n\n\tif (object->file) {\n\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\tcachefiles_clean_up_object(object, cache);\n\t\tcachefiles_end_secure(cache, saved_cred);\n\t}\n\n\tcookie->cache_priv = NULL;\n\tcachefiles_put_object(object, cachefiles_obj_put_detach);\n}\n\n \nstatic bool cachefiles_invalidate_cookie(struct fscache_cookie *cookie)\n{\n\tstruct cachefiles_object *object = cookie->cache_priv;\n\tstruct file *new_file, *old_file;\n\tbool old_tmpfile;\n\n\t_enter(\"o=%x,[%llu]\", object->debug_id, object->cookie->object_size);\n\n\told_tmpfile = test_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags);\n\n\tif (!object->file) {\n\t\tfscache_resume_after_invalidation(cookie);\n\t\t_leave(\" = t [light]\");\n\t\treturn true;\n\t}\n\n\tnew_file = cachefiles_create_tmpfile(object);\n\tif (IS_ERR(new_file))\n\t\tgoto failed;\n\n\t \n\t_debug(\"sub\");\n\tspin_lock(&object->lock);\n\n\told_file = object->file;\n\tobject->file = new_file;\n\tobject->content_info = CACHEFILES_CONTENT_NO_DATA;\n\tset_bit(CACHEFILES_OBJECT_USING_TMPFILE, &object->flags);\n\tset_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &object->cookie->flags);\n\n\tspin_unlock(&object->lock);\n\t_debug(\"subbed\");\n\n\t \n\tfscache_resume_after_invalidation(cookie);\n\n\tif (old_file) {\n\t\tif (!old_tmpfile) {\n\t\t\tstruct cachefiles_volume *volume = object->volume;\n\t\t\tstruct dentry *fan = volume->fanout[(u8)cookie->key_hash];\n\n\t\t\tinode_lock_nested(d_inode(fan), I_MUTEX_PARENT);\n\t\t\tcachefiles_bury_object(volume->cache, object, fan,\n\t\t\t\t\t       old_file->f_path.dentry,\n\t\t\t\t\t       FSCACHE_OBJECT_INVALIDATED);\n\t\t}\n\t\tfput(old_file);\n\t}\n\n\t_leave(\" = t\");\n\treturn true;\n\nfailed:\n\t_leave(\" = f\");\n\treturn false;\n}\n\nconst struct fscache_cache_ops cachefiles_cache_ops = {\n\t.name\t\t\t= \"cachefiles\",\n\t.acquire_volume\t\t= cachefiles_acquire_volume,\n\t.free_volume\t\t= cachefiles_free_volume,\n\t.lookup_cookie\t\t= cachefiles_lookup_cookie,\n\t.withdraw_cookie\t= cachefiles_withdraw_cookie,\n\t.invalidate_cookie\t= cachefiles_invalidate_cookie,\n\t.begin_operation\t= cachefiles_begin_operation,\n\t.resize_cookie\t\t= cachefiles_resize_cookie,\n\t.prepare_to_write\t= cachefiles_prepare_to_write,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}