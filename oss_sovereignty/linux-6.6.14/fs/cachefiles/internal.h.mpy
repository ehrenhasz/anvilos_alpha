{
  "module_name": "internal.h",
  "hash_id": "5a893476b18ad531f048341ed6f03262b3ca3fe3170655c5934232a7eb40f4d2",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/internal.h",
  "human_readable_source": " \n \n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) \"CacheFiles: \" fmt\n\n\n#include <linux/fscache-cache.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xarray.h>\n#include <linux/cachefiles.h>\n\n#define CACHEFILES_DIO_BLOCK_SIZE 4096\n\nstruct cachefiles_cache;\nstruct cachefiles_object;\n\nenum cachefiles_content {\n\t \n\tCACHEFILES_CONTENT_NO_DATA\t= 0,  \n\tCACHEFILES_CONTENT_SINGLE\t= 1,  \n\tCACHEFILES_CONTENT_ALL\t\t= 2,  \n\tCACHEFILES_CONTENT_BACKFS_MAP\t= 3,  \n\tCACHEFILES_CONTENT_DIRTY\t= 4,  \n\tnr__cachefiles_content\n};\n\n \nstruct cachefiles_volume {\n\tstruct cachefiles_cache\t\t*cache;\n\tstruct list_head\t\tcache_link;\t \n\tstruct fscache_volume\t\t*vcookie;\t \n\tstruct dentry\t\t\t*dentry;\t \n\tstruct dentry\t\t\t*fanout[256];\t \n};\n\n \nstruct cachefiles_object {\n\tstruct fscache_cookie\t\t*cookie;\t \n\tstruct cachefiles_volume\t*volume;\t \n\tstruct list_head\t\tcache_link;\t \n\tstruct file\t\t\t*file;\t\t \n\tchar\t\t\t\t*d_name;\t \n\tint\t\t\t\tdebug_id;\n\tspinlock_t\t\t\tlock;\n\trefcount_t\t\t\tref;\n\tu8\t\t\t\td_name_len;\t \n\tenum cachefiles_content\t\tcontent_info:8;\t \n\tunsigned long\t\t\tflags;\n#define CACHEFILES_OBJECT_USING_TMPFILE\t0\t\t \n#ifdef CONFIG_CACHEFILES_ONDEMAND\n\tint\t\t\t\tondemand_id;\n#endif\n};\n\n#define CACHEFILES_ONDEMAND_ID_CLOSED\t-1\n\n \nstruct cachefiles_cache {\n\tstruct fscache_cache\t\t*cache;\t\t \n\tstruct vfsmount\t\t\t*mnt;\t\t \n\tstruct dentry\t\t\t*store;\t\t \n\tstruct dentry\t\t\t*graveyard;\t \n\tstruct file\t\t\t*cachefilesd;\t \n\tstruct list_head\t\tvolumes;\t \n\tstruct list_head\t\tobject_list;\t \n\tspinlock_t\t\t\tobject_list_lock;  \n\tconst struct cred\t\t*cache_cred;\t \n\tstruct mutex\t\t\tdaemon_mutex;\t \n\twait_queue_head_t\t\tdaemon_pollwq;\t \n\tatomic_t\t\t\tgravecounter;\t \n\tatomic_t\t\t\tf_released;\t \n\tatomic_long_t\t\t\tb_released;\t \n\tatomic_long_t\t\t\tb_writing;\t \n\tunsigned\t\t\tfrun_percent;\t \n\tunsigned\t\t\tfcull_percent;\t \n\tunsigned\t\t\tfstop_percent;\t \n\tunsigned\t\t\tbrun_percent;\t \n\tunsigned\t\t\tbcull_percent;\t \n\tunsigned\t\t\tbstop_percent;\t \n\tunsigned\t\t\tbsize;\t\t \n\tunsigned\t\t\tbshift;\t\t \n\tuint64_t\t\t\tfrun;\t\t \n\tuint64_t\t\t\tfcull;\t\t \n\tuint64_t\t\t\tfstop;\t\t \n\tsector_t\t\t\tbrun;\t\t \n\tsector_t\t\t\tbcull;\t\t \n\tsector_t\t\t\tbstop;\t\t \n\tunsigned long\t\t\tflags;\n#define CACHEFILES_READY\t\t0\t \n#define CACHEFILES_DEAD\t\t\t1\t \n#define CACHEFILES_CULLING\t\t2\t \n#define CACHEFILES_STATE_CHANGED\t3\t \n#define CACHEFILES_ONDEMAND_MODE\t4\t \n\tchar\t\t\t\t*rootdirname;\t \n\tchar\t\t\t\t*secctx;\t \n\tchar\t\t\t\t*tag;\t\t \n\trefcount_t\t\t\tunbind_pincount; \n\tstruct xarray\t\t\treqs;\t\t \n\tunsigned long\t\t\treq_id_next;\n\tstruct xarray\t\t\tondemand_ids;\t \n\tu32\t\t\t\tondemand_id_next;\n};\n\nstatic inline bool cachefiles_in_ondemand_mode(struct cachefiles_cache *cache)\n{\n\treturn IS_ENABLED(CONFIG_CACHEFILES_ONDEMAND) &&\n\t\ttest_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags);\n}\n\nstruct cachefiles_req {\n\tstruct cachefiles_object *object;\n\tstruct completion done;\n\tint error;\n\tstruct cachefiles_msg msg;\n};\n\n#define CACHEFILES_REQ_NEW\tXA_MARK_1\n\n#include <trace/events/cachefiles.h>\n\nstatic inline\nstruct file *cachefiles_cres_file(struct netfs_cache_resources *cres)\n{\n\treturn cres->cache_priv2;\n}\n\nstatic inline\nstruct cachefiles_object *cachefiles_cres_object(struct netfs_cache_resources *cres)\n{\n\treturn fscache_cres_cookie(cres)->cache_priv;\n}\n\n \nstatic inline void cachefiles_state_changed(struct cachefiles_cache *cache)\n{\n\tset_bit(CACHEFILES_STATE_CHANGED, &cache->flags);\n\twake_up_all(&cache->daemon_pollwq);\n}\n\n \nextern int cachefiles_add_cache(struct cachefiles_cache *cache);\nextern void cachefiles_withdraw_cache(struct cachefiles_cache *cache);\n\nenum cachefiles_has_space_for {\n\tcachefiles_has_space_check,\n\tcachefiles_has_space_for_write,\n\tcachefiles_has_space_for_create,\n};\nextern int cachefiles_has_space(struct cachefiles_cache *cache,\n\t\t\t\tunsigned fnr, unsigned bnr,\n\t\t\t\tenum cachefiles_has_space_for reason);\n\n \nextern const struct file_operations cachefiles_daemon_fops;\nextern void cachefiles_get_unbind_pincount(struct cachefiles_cache *cache);\nextern void cachefiles_put_unbind_pincount(struct cachefiles_cache *cache);\n\n \n#ifdef CONFIG_CACHEFILES_ERROR_INJECTION\nextern unsigned int cachefiles_error_injection_state;\nextern int cachefiles_register_error_injection(void);\nextern void cachefiles_unregister_error_injection(void);\n\n#else\n#define cachefiles_error_injection_state 0\n\nstatic inline int cachefiles_register_error_injection(void)\n{\n\treturn 0;\n}\n\nstatic inline void cachefiles_unregister_error_injection(void)\n{\n}\n#endif\n\n\nstatic inline int cachefiles_inject_read_error(void)\n{\n\treturn cachefiles_error_injection_state & 2 ? -EIO : 0;\n}\n\nstatic inline int cachefiles_inject_write_error(void)\n{\n\treturn cachefiles_error_injection_state & 2 ? -EIO :\n\t\tcachefiles_error_injection_state & 1 ? -ENOSPC :\n\t\t0;\n}\n\nstatic inline int cachefiles_inject_remove_error(void)\n{\n\treturn cachefiles_error_injection_state & 2 ? -EIO : 0;\n}\n\n \nextern const struct fscache_cache_ops cachefiles_cache_ops;\nextern void cachefiles_see_object(struct cachefiles_object *object,\n\t\t\t\t  enum cachefiles_obj_ref_trace why);\nextern struct cachefiles_object *cachefiles_grab_object(struct cachefiles_object *object,\n\t\t\t\t\t\t\tenum cachefiles_obj_ref_trace why);\nextern void cachefiles_put_object(struct cachefiles_object *object,\n\t\t\t\t  enum cachefiles_obj_ref_trace why);\n\n \nextern bool cachefiles_begin_operation(struct netfs_cache_resources *cres,\n\t\t\t\t       enum fscache_want_state want_state);\nextern int __cachefiles_prepare_write(struct cachefiles_object *object,\n\t\t\t\t      struct file *file,\n\t\t\t\t      loff_t *_start, size_t *_len,\n\t\t\t\t      bool no_space_allocated_yet);\nextern int __cachefiles_write(struct cachefiles_object *object,\n\t\t\t      struct file *file,\n\t\t\t      loff_t start_pos,\n\t\t\t      struct iov_iter *iter,\n\t\t\t      netfs_io_terminated_t term_func,\n\t\t\t      void *term_func_priv);\n\n \nextern bool cachefiles_cook_key(struct cachefiles_object *object);\n\n \nextern struct kmem_cache *cachefiles_object_jar;\n\n \nextern void cachefiles_unmark_inode_in_use(struct cachefiles_object *object,\n\t\t\t\t\t   struct file *file);\nextern int cachefiles_bury_object(struct cachefiles_cache *cache,\n\t\t\t\t  struct cachefiles_object *object,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  struct dentry *rep,\n\t\t\t\t  enum fscache_why_object_killed why);\nextern int cachefiles_delete_object(struct cachefiles_object *object,\n\t\t\t\t    enum fscache_why_object_killed why);\nextern bool cachefiles_look_up_object(struct cachefiles_object *object);\nextern struct dentry *cachefiles_get_directory(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *dir,\n\t\t\t\t\t       const char *name,\n\t\t\t\t\t       bool *_is_new);\nextern void cachefiles_put_directory(struct dentry *dir);\n\nextern int cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\n\t\t\t   char *filename);\n\nextern int cachefiles_check_in_use(struct cachefiles_cache *cache,\n\t\t\t\t   struct dentry *dir, char *filename);\nextern struct file *cachefiles_create_tmpfile(struct cachefiles_object *object);\nextern bool cachefiles_commit_tmpfile(struct cachefiles_cache *cache,\n\t\t\t\t      struct cachefiles_object *object);\n\n \n#ifdef CONFIG_CACHEFILES_ONDEMAND\nextern ssize_t cachefiles_ondemand_daemon_read(struct cachefiles_cache *cache,\n\t\t\t\t\tchar __user *_buffer, size_t buflen);\n\nextern int cachefiles_ondemand_copen(struct cachefiles_cache *cache,\n\t\t\t\t     char *args);\n\nextern int cachefiles_ondemand_init_object(struct cachefiles_object *object);\nextern void cachefiles_ondemand_clean_object(struct cachefiles_object *object);\n\nextern int cachefiles_ondemand_read(struct cachefiles_object *object,\n\t\t\t\t    loff_t pos, size_t len);\n\n#else\nstatic inline ssize_t cachefiles_ondemand_daemon_read(struct cachefiles_cache *cache,\n\t\t\t\t\tchar __user *_buffer, size_t buflen)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int cachefiles_ondemand_init_object(struct cachefiles_object *object)\n{\n\treturn 0;\n}\n\nstatic inline void cachefiles_ondemand_clean_object(struct cachefiles_object *object)\n{\n}\n\nstatic inline int cachefiles_ondemand_read(struct cachefiles_object *object,\n\t\t\t\t\t   loff_t pos, size_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n \nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}\n\n \nvoid cachefiles_acquire_volume(struct fscache_volume *volume);\nvoid cachefiles_free_volume(struct fscache_volume *volume);\nvoid cachefiles_withdraw_volume(struct cachefiles_volume *volume);\n\n \nextern int cachefiles_set_object_xattr(struct cachefiles_object *object);\nextern int cachefiles_check_auxdata(struct cachefiles_object *object,\n\t\t\t\t    struct file *file);\nextern int cachefiles_remove_object_xattr(struct cachefiles_cache *cache,\n\t\t\t\t\t  struct cachefiles_object *object,\n\t\t\t\t\t  struct dentry *dentry);\nextern void cachefiles_prepare_to_write(struct fscache_cookie *cookie);\nextern bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume);\nextern int cachefiles_check_volume_xattr(struct cachefiles_volume *volume);\n\n \n#define cachefiles_io_error(___cache, FMT, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tpr_err(\"I/O Error: \" FMT\"\\n\", ##__VA_ARGS__);\t\\\n\tfscache_io_error((___cache)->cache);\t\t\\\n\tset_bit(CACHEFILES_DEAD, &(___cache)->flags);\t\\\n} while (0)\n\n#define cachefiles_io_error_obj(object, FMT, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstruct cachefiles_cache *___cache;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t___cache = (object)->volume->cache;\t\t\t\t\\\n\tcachefiles_io_error(___cache, FMT \" [o=%08x]\", ##__VA_ARGS__,\t\\\n\t\t\t    (object)->debug_id);\t\t\t\\\n} while (0)\n\n\n \nextern unsigned cachefiles_debug;\n#define CACHEFILES_DEBUG_KENTER\t1\n#define CACHEFILES_DEBUG_KLEAVE\t2\n#define CACHEFILES_DEBUG_KDEBUG\t4\n\n#define dbgprintk(FMT, ...) \\\n\tprintk(KERN_DEBUG \"[%-6.6s] \"FMT\"\\n\", current->comm, ##__VA_ARGS__)\n\n#define kenter(FMT, ...) dbgprintk(\"==> %s(\"FMT\")\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) dbgprintk(\"<== %s()\"FMT\"\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) dbgprintk(FMT, ##__VA_ARGS__)\n\n\n#if defined(__KDEBUG)\n#define _enter(FMT, ...) kenter(FMT, ##__VA_ARGS__)\n#define _leave(FMT, ...) kleave(FMT, ##__VA_ARGS__)\n#define _debug(FMT, ...) kdebug(FMT, ##__VA_ARGS__)\n\n#elif defined(CONFIG_CACHEFILES_DEBUG)\n#define _enter(FMT, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (cachefiles_debug & CACHEFILES_DEBUG_KENTER)\t\\\n\t\tkenter(FMT, ##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _leave(FMT, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (cachefiles_debug & CACHEFILES_DEBUG_KLEAVE)\t\\\n\t\tkleave(FMT, ##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _debug(FMT, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (cachefiles_debug & CACHEFILES_DEBUG_KDEBUG)\t\\\n\t\tkdebug(FMT, ##__VA_ARGS__);\t\t\\\n} while (0)\n\n#else\n#define _enter(FMT, ...) no_printk(\"==> %s(\"FMT\")\", __func__, ##__VA_ARGS__)\n#define _leave(FMT, ...) no_printk(\"<== %s()\"FMT\"\", __func__, ##__VA_ARGS__)\n#define _debug(FMT, ...) no_printk(FMT, ##__VA_ARGS__)\n#endif\n\n#if 1  \n\n#define ASSERT(X)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!(X))) {\t\t\t\t\t\t\\\n\t\tpr_err(\"\\n\");\t\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTCMP(X, OP, Y)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!((X) OP (Y)))) {\t\t\t\t\t\\\n\t\tpr_err(\"\\n\");\t\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\\\n\t\tpr_err(\"%lx \" #OP \" %lx is false\\n\",\t\t\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIF(C, X)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((C) && !(X))) {\t\t\t\t\t\\\n\t\tpr_err(\"\\n\");\t\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIFCMP(C, X, OP, Y)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((C) && !((X) OP (Y)))) {\t\t\t\t\\\n\t\tpr_err(\"\\n\");\t\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\\\n\t\tpr_err(\"%lx \" #OP \" %lx is false\\n\",\t\t\t\\\n\t\t       (unsigned long)(X), (unsigned long)(Y));\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#else\n\n#define ASSERT(X)\t\t\tdo {} while (0)\n#define ASSERTCMP(X, OP, Y)\t\tdo {} while (0)\n#define ASSERTIF(C, X)\t\t\tdo {} while (0)\n#define ASSERTIFCMP(C, X, OP, Y)\tdo {} while (0)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}