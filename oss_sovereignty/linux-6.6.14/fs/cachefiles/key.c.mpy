{
  "module_name": "key.c",
  "hash_id": "52344c09df3d14fcecb7f7f4005a589953cfb22ef41472d853a3ce71d691e9ef",
  "original_prompt": "Ingested from linux-6.6.14/fs/cachefiles/key.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"internal.h\"\n\nstatic const char cachefiles_charmap[64] =\n\t\"0123456789\"\t\t\t \n\t\"abcdefghijklmnopqrstuvwxyz\"\t \n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t \n\t\"_-\"\t\t\t\t \n\t;\n\nstatic const char cachefiles_filecharmap[256] = {\n\t \n\t[33 ... 46] = 1,\t\t \n\t \n\t[48 ... 127] = 1,\t\t \n};\n\nstatic inline unsigned int how_many_hex_digits(unsigned int x)\n{\n\treturn x ? round_up(ilog2(x) + 1, 4) / 4 : 0;\n}\n\n \nbool cachefiles_cook_key(struct cachefiles_object *object)\n{\n\tconst u8 *key = fscache_get_key(object->cookie), *kend;\n\tunsigned char ch;\n\tunsigned int acc, i, n, nle, nbe, keylen = object->cookie->key_len;\n\tunsigned int b64len, len, print, pad;\n\tchar *name, sep;\n\n\t_enter(\",%u,%*phN\", keylen, keylen, key);\n\n\tBUG_ON(keylen > NAME_MAX - 3);\n\n\tprint = 1;\n\tfor (i = 0; i < keylen; i++) {\n\t\tch = key[i];\n\t\tprint &= cachefiles_filecharmap[ch];\n\t}\n\n\t \n\tif (print) {\n\t\tlen = 1 + keylen;\n\t\tname = kmalloc(len + 1, GFP_KERNEL);\n\t\tif (!name)\n\t\t\treturn false;\n\n\t\tname[0] = 'D';  \n\t\tmemcpy(name + 1, key, keylen);\n\t\tgoto success;\n\t}\n\n\t \n\tn = round_up(keylen, 4);\n\tnbe = nle = 0;\n\tfor (i = 0; i < n; i += 4) {\n\t\tu32 be = be32_to_cpu(*(__be32 *)(key + i));\n\t\tu32 le = le32_to_cpu(*(__le32 *)(key + i));\n\n\t\tnbe += 1 + how_many_hex_digits(be);\n\t\tnle += 1 + how_many_hex_digits(le);\n\t}\n\n\tb64len = DIV_ROUND_UP(keylen, 3);\n\tpad = b64len * 3 - keylen;\n\tb64len = 2 + b64len * 4;  \n\t_debug(\"len=%u nbe=%u nle=%u b64=%u\", keylen, nbe, nle, b64len);\n\tif (nbe < b64len || nle < b64len) {\n\t\tunsigned int nlen = min(nbe, nle) + 1;\n\t\tname = kmalloc(nlen, GFP_KERNEL);\n\t\tif (!name)\n\t\t\treturn false;\n\t\tsep = (nbe <= nle) ? 'S' : 'T';  \n\t\tlen = 0;\n\t\tfor (i = 0; i < n; i += 4) {\n\t\t\tu32 x;\n\t\t\tif (nbe <= nle)\n\t\t\t\tx = be32_to_cpu(*(__be32 *)(key + i));\n\t\t\telse\n\t\t\t\tx = le32_to_cpu(*(__le32 *)(key + i));\n\t\t\tname[len++] = sep;\n\t\t\tif (x != 0)\n\t\t\t\tlen += snprintf(name + len, nlen - len, \"%x\", x);\n\t\t\tsep = ',';\n\t\t}\n\t\tgoto success;\n\t}\n\n\t \n\tname = kmalloc(b64len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn false;\n\n\tname[0] = 'E';\n\tname[1] = '0' + pad;\n\tlen = 2;\n\tkend = key + keylen;\n\tdo {\n\t\tacc  = *key++;\n\t\tif (key < kend) {\n\t\t\tacc |= *key++ << 8;\n\t\t\tif (key < kend)\n\t\t\t\tacc |= *key++ << 16;\n\t\t}\n\n\t\tname[len++] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tname[len++] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tname[len++] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tname[len++] = cachefiles_charmap[acc & 63];\n\t} while (key < kend);\n\nsuccess:\n\tname[len] = 0;\n\tobject->d_name = name;\n\tobject->d_name_len = len;\n\t_leave(\" = %s\", object->d_name);\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}