{
  "module_name": "super.c",
  "hash_id": "c0a1269b92b162c0cdc890381712c9d519b49f0e5aff4ef7806e38a469dbb490",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/super.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/nls.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\nstatic struct kmem_cache *hfs_inode_cachep;\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int hfs_sync_fs(struct super_block *sb, int wait)\n{\n\thfs_mdb_commit(sb);\n\treturn 0;\n}\n\n \nstatic void hfs_put_super(struct super_block *sb)\n{\n\tcancel_delayed_work_sync(&HFS_SB(sb)->mdb_work);\n\thfs_mdb_close(sb);\n\t \n\thfs_mdb_put(sb);\n}\n\nstatic void flush_mdb(struct work_struct *work)\n{\n\tstruct hfs_sb_info *sbi;\n\tstruct super_block *sb;\n\n\tsbi = container_of(work, struct hfs_sb_info, mdb_work.work);\n\tsb = sbi->sb;\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\thfs_mdb_commit(sb);\n}\n\nvoid hfs_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->mdb_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}\n\n \nstatic int hfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = HFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (u32)HFS_SB(sb)->fs_ablocks * HFS_SB(sb)->fs_div;\n\tbuf->f_bfree = (u32)HFS_SB(sb)->free_ablocks * HFS_SB(sb)->fs_div;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = HFS_SB(sb)->fs_ablocks;\n\tbuf->f_ffree = HFS_SB(sb)->free_ablocks;\n\tbuf->f_fsid = u64_to_fsid(id);\n\tbuf->f_namelen = HFS_NAMELEN;\n\n\treturn 0;\n}\n\nstatic int hfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= SB_NODIRATIME;\n\tif ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))\n\t\treturn 0;\n\tif (!(*flags & SB_RDONLY)) {\n\t\tif (!(HFS_SB(sb)->mdb->drAtrb & cpu_to_be16(HFS_SB_ATTRIB_UNMNT))) {\n\t\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfs is recommended.  leaving read-only.\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t*flags |= SB_RDONLY;\n\t\t} else if (HFS_SB(sb)->mdb->drAtrb & cpu_to_be16(HFS_SB_ATTRIB_SLOCK)) {\n\t\t\tpr_warn(\"filesystem is marked locked, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= SB_RDONLY;\n\t\t\t*flags |= SB_RDONLY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int hfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct hfs_sb_info *sbi = HFS_SB(root->d_sb);\n\n\tif (sbi->s_creator != cpu_to_be32(0x3f3f3f3f))\n\t\tseq_show_option_n(seq, \"creator\", (char *)&sbi->s_creator, 4);\n\tif (sbi->s_type != cpu_to_be32(0x3f3f3f3f))\n\t\tseq_show_option_n(seq, \"type\", (char *)&sbi->s_type, 4);\n\tseq_printf(seq, \",uid=%u,gid=%u\",\n\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_uid),\n\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_gid));\n\tif (sbi->s_file_umask != 0133)\n\t\tseq_printf(seq, \",file_umask=%o\", sbi->s_file_umask);\n\tif (sbi->s_dir_umask != 0022)\n\t\tseq_printf(seq, \",dir_umask=%o\", sbi->s_dir_umask);\n\tif (sbi->part >= 0)\n\t\tseq_printf(seq, \",part=%u\", sbi->part);\n\tif (sbi->session >= 0)\n\t\tseq_printf(seq, \",session=%u\", sbi->session);\n\tif (sbi->nls_disk)\n\t\tseq_printf(seq, \",codepage=%s\", sbi->nls_disk->charset);\n\tif (sbi->nls_io)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->nls_io->charset);\n\tif (sbi->s_quiet)\n\t\tseq_printf(seq, \",quiet\");\n\treturn 0;\n}\n\nstatic struct inode *hfs_alloc_inode(struct super_block *sb)\n{\n\tstruct hfs_inode_info *i;\n\n\ti = alloc_inode_sb(sb, hfs_inode_cachep, GFP_KERNEL);\n\treturn i ? &i->vfs_inode : NULL;\n}\n\nstatic void hfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(hfs_inode_cachep, HFS_I(inode));\n}\n\nstatic const struct super_operations hfs_super_operations = {\n\t.alloc_inode\t= hfs_alloc_inode,\n\t.free_inode\t= hfs_free_inode,\n\t.write_inode\t= hfs_write_inode,\n\t.evict_inode\t= hfs_evict_inode,\n\t.put_super\t= hfs_put_super,\n\t.sync_fs\t= hfs_sync_fs,\n\t.statfs\t\t= hfs_statfs,\n\t.remount_fs     = hfs_remount,\n\t.show_options\t= hfs_show_options,\n};\n\nenum {\n\topt_uid, opt_gid, opt_umask, opt_file_umask, opt_dir_umask,\n\topt_part, opt_session, opt_type, opt_creator, opt_quiet,\n\topt_codepage, opt_iocharset,\n\topt_err\n};\n\nstatic const match_table_t tokens = {\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_file_umask, \"file_umask=%o\" },\n\t{ opt_dir_umask, \"dir_umask=%o\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_quiet, \"quiet\" },\n\t{ opt_codepage, \"codepage=%s\" },\n\t{ opt_iocharset, \"iocharset=%s\" },\n\t{ opt_err, NULL }\n};\n\nstatic inline int match_fourchar(substring_t *arg, u32 *result)\n{\n\tif (arg->to - arg->from != 4)\n\t\treturn -EINVAL;\n\tmemcpy(result, arg->from, 4);\n\treturn 0;\n}\n\n \nstatic int parse_options(char *options, struct hfs_sb_info *hsb)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint tmp, token;\n\n\t \n\thsb->s_uid = current_uid();\n\thsb->s_gid = current_gid();\n\thsb->s_file_umask = 0133;\n\thsb->s_dir_umask = 0022;\n\thsb->s_type = hsb->s_creator = cpu_to_be32(0x3f3f3f3f);\t \n\thsb->s_quiet = 0;\n\thsb->part = -1;\n\thsb->session = -1;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_uid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"uid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thsb->s_uid = make_kuid(current_user_ns(), (uid_t)tmp);\n\t\t\tif (!uid_valid(hsb->s_uid)) {\n\t\t\t\tpr_err(\"invalid uid %d\\n\", tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_gid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"gid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thsb->s_gid = make_kgid(current_user_ns(), (gid_t)tmp);\n\t\t\tif (!gid_valid(hsb->s_gid)) {\n\t\t\t\tpr_err(\"invalid gid %d\\n\", tmp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thsb->s_file_umask = (umode_t)tmp;\n\t\t\thsb->s_dir_umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_file_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"file_umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thsb->s_file_umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_dir_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"dir_umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\thsb->s_dir_umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_part:\n\t\t\tif (match_int(&args[0], &hsb->part)) {\n\t\t\t\tpr_err(\"part requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_session:\n\t\t\tif (match_int(&args[0], &hsb->session)) {\n\t\t\t\tpr_err(\"session requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_type:\n\t\t\tif (match_fourchar(&args[0], &hsb->s_type)) {\n\t\t\t\tpr_err(\"type requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_creator:\n\t\t\tif (match_fourchar(&args[0], &hsb->s_creator)) {\n\t\t\t\tpr_err(\"creator requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_quiet:\n\t\t\thsb->s_quiet = 1;\n\t\t\tbreak;\n\t\tcase opt_codepage:\n\t\t\tif (hsb->nls_disk) {\n\t\t\t\tpr_err(\"unable to change codepage\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = match_strdup(&args[0]);\n\t\t\tif (p)\n\t\t\t\thsb->nls_disk = load_nls(p);\n\t\t\tif (!hsb->nls_disk) {\n\t\t\t\tpr_err(\"unable to load codepage \\\"%s\\\"\\n\", p);\n\t\t\t\tkfree(p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase opt_iocharset:\n\t\t\tif (hsb->nls_io) {\n\t\t\t\tpr_err(\"unable to change iocharset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = match_strdup(&args[0]);\n\t\t\tif (p)\n\t\t\t\thsb->nls_io = load_nls(p);\n\t\t\tif (!hsb->nls_io) {\n\t\t\t\tpr_err(\"unable to load iocharset \\\"%s\\\"\\n\", p);\n\t\t\t\tkfree(p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (hsb->nls_disk && !hsb->nls_io) {\n\t\thsb->nls_io = load_nls_default();\n\t\tif (!hsb->nls_io) {\n\t\t\tpr_err(\"unable to load default iocharset\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\thsb->s_dir_umask &= 0777;\n\thsb->s_file_umask &= 0577;\n\n\treturn 1;\n}\n\n \nstatic int hfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct hfs_sb_info *sbi;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tstruct inode *root_inode;\n\tint res;\n\n\tsbi = kzalloc(sizeof(struct hfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->sb = sb;\n\tsb->s_fs_info = sbi;\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->mdb_work, flush_mdb);\n\n\tres = -EINVAL;\n\tif (!parse_options((char *)data, sbi)) {\n\t\tpr_err(\"unable to parse mount options\\n\");\n\t\tgoto bail;\n\t}\n\n\tsb->s_op = &hfs_super_operations;\n\tsb->s_xattr = hfs_xattr_handlers;\n\tsb->s_flags |= SB_NODIRATIME;\n\tmutex_init(&sbi->bitmap_lock);\n\n\tres = hfs_mdb_get(sb);\n\tif (res) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"can't find a HFS filesystem on dev %s\\n\",\n\t\t\t\thfs_mdb_name(sb));\n\t\tres = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\tgoto bail_no_root;\n\tres = hfs_cat_find_brec(sb, HFS_ROOT_CNID, &fd);\n\tif (!res) {\n\t\tif (fd.entrylength > sizeof(rec) || fd.entrylength < 0) {\n\t\t\tres =  -EIO;\n\t\t\tgoto bail_hfs_find;\n\t\t}\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset, fd.entrylength);\n\t}\n\tif (res)\n\t\tgoto bail_hfs_find;\n\tres = -EINVAL;\n\troot_inode = hfs_iget(sb, &fd.search_key->cat, &rec);\n\thfs_find_exit(&fd);\n\tif (!root_inode)\n\t\tgoto bail_no_root;\n\n\tsb->s_d_op = &hfs_dentry_operations;\n\tres = -ENOMEM;\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root)\n\t\tgoto bail_no_root;\n\n\t \n\treturn 0;\n\nbail_hfs_find:\n\thfs_find_exit(&fd);\nbail_no_root:\n\tpr_err(\"get root inode failed\\n\");\nbail:\n\thfs_mdb_put(sb);\n\treturn res;\n}\n\nstatic struct dentry *hfs_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hfs_fill_super);\n}\n\nstatic struct file_system_type hfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfs\",\n\t.mount\t\t= hfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"hfs\");\n\nstatic void hfs_init_once(void *p)\n{\n\tstruct hfs_inode_info *i = p;\n\n\tinode_init_once(&i->vfs_inode);\n}\n\nstatic int __init init_hfs_fs(void)\n{\n\tint err;\n\n\thfs_inode_cachep = kmem_cache_create(\"hfs_inode_cache\",\n\t\tsizeof(struct hfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_ACCOUNT, hfs_init_once);\n\tif (!hfs_inode_cachep)\n\t\treturn -ENOMEM;\n\terr = register_filesystem(&hfs_fs_type);\n\tif (err)\n\t\tkmem_cache_destroy(hfs_inode_cachep);\n\treturn err;\n}\n\nstatic void __exit exit_hfs_fs(void)\n{\n\tunregister_filesystem(&hfs_fs_type);\n\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(hfs_inode_cachep);\n}\n\nmodule_init(init_hfs_fs)\nmodule_exit(exit_hfs_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}