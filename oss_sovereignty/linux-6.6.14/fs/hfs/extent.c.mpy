{
  "module_name": "extent.c",
  "hash_id": "bd47053dcab6d1cdf9c887bee807b5b52a0064012ca62f3b91497a393b810ca0",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/extent.c",
  "human_readable_source": " \n\n#include <linux/pagemap.h>\n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\n \n\n \nstatic void hfs_ext_build_key(hfs_btree_key *key, u32 cnid, u16 block, u8 type)\n{\n\tkey->key_len = 7;\n\tkey->ext.FkType = type;\n\tkey->ext.FNum = cpu_to_be32(cnid);\n\tkey->ext.FABN = cpu_to_be16(block);\n}\n\n \nint hfs_ext_keycmp(const btree_key *key1, const btree_key *key2)\n{\n\t__be32 fnum1, fnum2;\n\t__be16 block1, block2;\n\n\tfnum1 = key1->ext.FNum;\n\tfnum2 = key2->ext.FNum;\n\tif (fnum1 != fnum2)\n\t\treturn be32_to_cpu(fnum1) < be32_to_cpu(fnum2) ? -1 : 1;\n\tif (key1->ext.FkType != key2->ext.FkType)\n\t\treturn key1->ext.FkType < key2->ext.FkType ? -1 : 1;\n\n\tblock1 = key1->ext.FABN;\n\tblock2 = key2->ext.FABN;\n\tif (block1 == block2)\n\t\treturn 0;\n\treturn be16_to_cpu(block1) < be16_to_cpu(block2) ? -1 : 1;\n}\n\n \nstatic u16 hfs_ext_find_block(struct hfs_extent *ext, u16 off)\n{\n\tint i;\n\tu16 count;\n\n\tfor (i = 0; i < 3; ext++, i++) {\n\t\tcount = be16_to_cpu(ext->count);\n\t\tif (off < count)\n\t\t\treturn be16_to_cpu(ext->block) + off;\n\t\toff -= count;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int hfs_ext_block_count(struct hfs_extent *ext)\n{\n\tint i;\n\tu16 count = 0;\n\n\tfor (i = 0; i < 3; ext++, i++)\n\t\tcount += be16_to_cpu(ext->count);\n\treturn count;\n}\n\nstatic u16 hfs_ext_lastblock(struct hfs_extent *ext)\n{\n\tint i;\n\n\text += 2;\n\tfor (i = 0; i < 2; ext--, i++)\n\t\tif (ext->count)\n\t\t\tbreak;\n\treturn be16_to_cpu(ext->block) + be16_to_cpu(ext->count);\n}\n\nstatic int __hfs_ext_write_extent(struct inode *inode, struct hfs_find_data *fd)\n{\n\tint res;\n\n\thfs_ext_build_key(fd->search_key, inode->i_ino, HFS_I(inode)->cached_start,\n\t\t\t  HFS_IS_RSRC(inode) ?  HFS_FK_RSRC : HFS_FK_DATA);\n\tres = hfs_brec_find(fd);\n\tif (HFS_I(inode)->flags & HFS_FLG_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\t \n\t\tres = hfs_bmap_reserve(fd->tree, fd->tree->depth + 1);\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, HFS_I(inode)->cached_extents, sizeof(hfs_extent_rec));\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, HFS_I(inode)->cached_extents, fd->entryoffset, fd->entrylength);\n\t\tHFS_I(inode)->flags &= ~HFS_FLG_EXT_DIRTY;\n\t}\n\treturn 0;\n}\n\nint hfs_ext_write_extent(struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tint res = 0;\n\n\tif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\n\t\tres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfs_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}\n\nstatic inline int __hfs_ext_read_extent(struct hfs_find_data *fd, struct hfs_extent *extent,\n\t\t\t\t\tu32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfs_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.FNum = 0;\n\tres = hfs_brec_find(fd);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.FNum != fd->search_key->ext.FNum ||\n\t    fd->key->ext.FkType != fd->search_key->ext.FkType)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfs_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfs_extent_rec));\n\treturn 0;\n}\n\nstatic inline int __hfs_ext_cache_extent(struct hfs_find_data *fd, struct inode *inode, u32 block)\n{\n\tint res;\n\n\tif (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {\n\t\tres = __hfs_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfs_ext_read_extent(fd, HFS_I(inode)->cached_extents, inode->i_ino,\n\t\t\t\t    block, HFS_IS_RSRC(inode) ? HFS_FK_RSRC : HFS_FK_DATA);\n\tif (!res) {\n\t\tHFS_I(inode)->cached_start = be16_to_cpu(fd->key->ext.FABN);\n\t\tHFS_I(inode)->cached_blocks = hfs_ext_block_count(HFS_I(inode)->cached_extents);\n\t} else {\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t}\n\treturn res;\n}\n\nstatic int hfs_ext_read_extent(struct inode *inode, u16 block)\n{\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= HFS_I(inode)->cached_start &&\n\t    block < HFS_I(inode)->cached_start + HFS_I(inode)->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfs_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}\n\nstatic void hfs_dump_extent(struct hfs_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 3; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be16_to_cpu(extent[i].block),\n\t\t\t     be16_to_cpu(extent[i].count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}\n\nstatic int hfs_add_extent(struct hfs_extent *extent, u16 offset,\n\t\t\t  u16 alloc_block, u16 block_count)\n{\n\tu16 count, start;\n\tint i;\n\n\thfs_dump_extent(extent);\n\tfor (i = 0; i < 3; extent++, i++) {\n\t\tcount = be16_to_cpu(extent->count);\n\t\tif (offset == count) {\n\t\t\tstart = be16_to_cpu(extent->block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 3)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->block = cpu_to_be16(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->count = cpu_to_be16(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t \n\treturn -EIO;\n}\n\nstatic int hfs_free_extents(struct super_block *sb, struct hfs_extent *extent,\n\t\t\t    u16 offset, u16 block_nr)\n{\n\tu16 count, start;\n\tint i;\n\n\thfs_dump_extent(extent);\n\tfor (i = 0; i < 3; extent++, i++) {\n\t\tcount = be16_to_cpu(extent->count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t \n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be16_to_cpu(extent->block);\n\t\tif (count <= block_nr) {\n\t\t\thfs_clear_vbm_bits(sb, start, count);\n\t\t\textent->block = 0;\n\t\t\textent->count = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\thfs_clear_vbm_bits(sb, start + count, block_nr);\n\t\t\textent->count = cpu_to_be16(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i)\n\t\t\treturn 0;\n\t\ti--;\n\t\textent--;\n\t\tcount = be16_to_cpu(extent->count);\n\t}\n}\n\nint hfs_free_fork(struct super_block *sb, struct hfs_cat_file *file, int type)\n{\n\tstruct hfs_find_data fd;\n\tu32 total_blocks, blocks, start;\n\tu32 cnid = be32_to_cpu(file->FlNum);\n\tstruct hfs_extent *extent;\n\tint res, i;\n\n\tif (type == HFS_FK_DATA) {\n\t\ttotal_blocks = be32_to_cpu(file->PyLen);\n\t\textent = file->ExtRec;\n\t} else {\n\t\ttotal_blocks = be32_to_cpu(file->RPyLen);\n\t\textent = file->RExtRec;\n\t}\n\ttotal_blocks /= HFS_SB(sb)->alloc_blksz;\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 3; i++)\n\t\tblocks += be16_to_cpu(extent[i].count);\n\n\tres = hfs_free_extents(sb, extent, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be16_to_cpu(fd.key->ext.FABN);\n\t\thfs_free_extents(sb, extent, total_blocks - start, total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}\n\n \nint hfs_get_block(struct inode *inode, sector_t block,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb;\n\tu16 dblock, ablock;\n\tint res;\n\n\tsb = inode->i_sb;\n\t \n\tablock = (u32)block / HFS_SB(sb)->fs_div;\n\n\tif (block >= HFS_I(inode)->fs_blocks) {\n\t\tif (!create)\n\t\t\treturn 0;\n\t\tif (block > HFS_I(inode)->fs_blocks)\n\t\t\treturn -EIO;\n\t\tif (ablock >= HFS_I(inode)->alloc_blocks) {\n\t\t\tres = hfs_extend_file(inode);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} else\n\t\tcreate = 0;\n\n\tif (ablock < HFS_I(inode)->first_blocks) {\n\t\tdblock = hfs_ext_find_block(HFS_I(inode)->first_extents, ablock);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_ext_read_extent(inode, ablock);\n\tif (!res)\n\t\tdblock = hfs_ext_find_block(HFS_I(inode)->cached_extents,\n\t\t\t\t\t    ablock - HFS_I(inode)->cached_start);\n\telse {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\treturn -EIO;\n\t}\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\ndone:\n\tmap_bh(bh_result, sb, HFS_SB(sb)->fs_start +\n\t       dblock * HFS_SB(sb)->fs_div +\n\t       (u32)block % HFS_SB(sb)->fs_div);\n\n\tif (create) {\n\t\tset_buffer_new(bh_result);\n\t\tHFS_I(inode)->phys_size += sb->s_blocksize;\n\t\tHFS_I(inode)->fs_blocks++;\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\t\tmark_inode_dirty(inode);\n\t}\n\treturn 0;\n}\n\nint hfs_extend_file(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 start, len, goal;\n\tint res;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tif (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks)\n\t\tgoal = hfs_ext_lastblock(HFS_I(inode)->first_extents);\n\telse {\n\t\tres = hfs_ext_read_extent(inode, HFS_I(inode)->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfs_ext_lastblock(HFS_I(inode)->cached_extents);\n\t}\n\n\tlen = HFS_I(inode)->clump_blocks;\n\tstart = hfs_vbm_search_free(sb, goal, &len);\n\tif (!len) {\n\t\tres = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\tif (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks) {\n\t\tif (!HFS_I(inode)->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t \n\t\t\tHFS_I(inode)->first_extents[0].block = cpu_to_be16(start);\n\t\t\tHFS_I(inode)->first_extents[0].count = cpu_to_be16(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t \n\t\t\tres = hfs_add_extent(HFS_I(inode)->first_extents,\n\t\t\t\t\t     HFS_I(inode)->alloc_blocks,\n\t\t\t\t\t     start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfs_add_extent(HFS_I(inode)->cached_extents,\n\t\t\t\t     HFS_I(inode)->alloc_blocks -\n\t\t\t\t     HFS_I(inode)->cached_start,\n\t\t\t\t     start, len);\n\t\tif (!res) {\n\t\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tHFS_I(inode)->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\tif (!res) {\n\t\tHFS_I(inode)->alloc_blocks += len;\n\t\tmark_inode_dirty(inode);\n\t\tif (inode->i_ino < HFS_FIRSTUSER_CNID)\n\t\t\tset_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t}\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfs_ext_write_extent(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\tHFS_I(inode)->cached_extents[0].block = cpu_to_be16(start);\n\tHFS_I(inode)->cached_extents[0].count = cpu_to_be16(len);\n\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW;\n\tHFS_I(inode)->cached_start = HFS_I(inode)->alloc_blocks;\n\tHFS_I(inode)->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}\n\nvoid hfs_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_find_data fd;\n\tu16 blk_cnt, alloc_cnt, start;\n\tu32 size;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %Lu -> %Lu\\n\",\n\t\tinode->i_ino, (long long)HFS_I(inode)->phys_size,\n\t\tinode->i_size);\n\tif (inode->i_size > HFS_I(inode)->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tvoid *fsdata = NULL;\n\t\tstruct page *page;\n\n\t\t \n\t\tsize = inode->i_size - 1;\n\t\tres = hfs_write_begin(NULL, mapping, size + 1, 0, &page,\n\t\t\t\t&fsdata);\n\t\tif (!res) {\n\t\t\tres = generic_write_end(NULL, mapping, size + 1, 0, 0,\n\t\t\t\t\tpage, fsdata);\n\t\t}\n\t\tif (res)\n\t\t\tinode->i_size = HFS_I(inode)->phys_size;\n\t\treturn;\n\t} else if (inode->i_size == HFS_I(inode)->phys_size)\n\t\treturn;\n\tsize = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;\n\tblk_cnt = size / HFS_SB(sb)->alloc_blksz;\n\talloc_cnt = HFS_I(inode)->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out;\n\n\tmutex_lock(&HFS_I(inode)->extents_lock);\n\tres = hfs_find_init(HFS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\t\t \n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == HFS_I(inode)->first_blocks) {\n\t\t\thfs_free_extents(sb, HFS_I(inode)->first_extents,\n\t\t\t\t\t alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfs_dump_extent(HFS_I(inode)->first_extents);\n\t\t\tHFS_I(inode)->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = HFS_I(inode)->cached_start;\n\t\thfs_free_extents(sb, HFS_I(inode)->cached_extents,\n\t\t\t\t alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfs_dump_extent(HFS_I(inode)->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\tHFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\tHFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;\n\t\tHFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\tmutex_unlock(&HFS_I(inode)->extents_lock);\n\n\tHFS_I(inode)->alloc_blocks = blk_cnt;\nout:\n\tHFS_I(inode)->phys_size = inode->i_size;\n\tHFS_I(inode)->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tmark_inode_dirty(inode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}