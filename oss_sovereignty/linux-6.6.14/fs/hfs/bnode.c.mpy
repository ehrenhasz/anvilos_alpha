{
  "module_name": "bnode.c",
  "hash_id": "fe169587a06e5bde178fc3f76a9e9eaef8b8f3943bd3676dcf0b803b9e23328b",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/bnode.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n\n#include \"btree.h\"\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\tint pagenum;\n\tint bytes_read;\n\tint bytes_to_read;\n\n\toff += node->page_offset;\n\tpagenum = off >> PAGE_SHIFT;\n\toff &= ~PAGE_MASK;  \n\n\tfor (bytes_read = 0; bytes_read < len; bytes_read += bytes_to_read) {\n\t\tif (pagenum >= node->tree->pages_per_bnode)\n\t\t\tbreak;\n\t\tpage = node->page[pagenum];\n\t\tbytes_to_read = min_t(int, len - bytes_read, PAGE_SIZE - off);\n\n\t\tmemcpy_from_page(buf + bytes_read, page, off, bytes_to_read);\n\n\t\tpagenum++;\n\t\toff = 0;  \n\t}\n}\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}\n\nu8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t\n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}\n\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\tkey_len = hfs_bnode_read_u8(node, off) + 1;\n\telse\n\t\tkey_len = tree->max_key_len + 1;\n\n\thfs_bnode_read(node, key, off, key_len);\n}\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy_to_page(page, off, buf, len);\n\tset_page_dirty(page);\n}\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t\n\thfs_bnode_write(node, &v, off, 2);\n}\n\nvoid hfs_bnode_write_u8(struct hfs_bnode *node, int off, u8 data)\n{\n\t\n\thfs_bnode_write(node, &data, off, 1);\n}\n\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemzero_page(page, off, len);\n\tset_page_dirty(page);\n}\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\tstruct hfs_bnode *src_node, int src, int len)\n{\n\tstruct page *src_page, *dst_page;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page[0];\n\tdst_page = dst_node->page[0];\n\n\tmemcpy_page(dst_page, dst, src_page, src, len);\n\tset_page_dirty(dst_page);\n}\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page *page;\n\tvoid *ptr;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tpage = node->page[0];\n\tptr = kmap_local_page(page);\n\tmemmove(ptr + dst, ptr + src, len);\n\tkunmap_local(ptr);\n\tset_page_dirty(page);\n}\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg_cont(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\t\ttmp = (hfs_bnode_read_u8(node, key_off) | 1) + 1;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 1;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d,%d\",\n\t\t\t\t     tmp, hfs_bnode_read_u8(node, key_off));\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u8(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}\n\nvoid hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t\n\tif (!node->prev && !node->next) {\n\t\tprintk(KERN_DEBUG \"hfs_btree_del_level\\n\");\n\t}\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\", cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t     node; node = node->next_hash) {\n\t\tif (node->this == cnid) {\n\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\", cnid);\n\t\treturn NULL;\n\t}\n\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\thfs_bnode_get(node2);\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq, !test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid * tree->node_size;\n\tblock = off >> PAGE_SHIFT;\n\tnode->page_offset = off & ~PAGE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\tpage = read_mapping_page(mapping, block++, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}\n\n \nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq, !test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap_local_page(node->page[0]) +\n\t\t\t\t\t node->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap_local(desc);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u8(node, off) + 1;\n\t\tif (key_size >= entry_size  )\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tput_page(node->page[i]);\n\tkfree(node);\n}\n\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemzero_page(*pagep, node->page_offset,\n\t\t     min((int)PAGE_SIZE, (int)tree->node_size));\n\tset_page_dirty(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemzero_page(*++pagep, 0, PAGE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}\n\nvoid hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}\n\n \nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}