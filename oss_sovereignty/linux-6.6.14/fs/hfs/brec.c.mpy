{
  "module_name": "brec.c",
  "hash_id": "2bc2ebef6f5ce86e5b344bf2fef48b2795fdba25bd49772ca21365a8b5ad147c",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/brec.c",
  "human_readable_source": "\n \n\n#include \"btree.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *tree);\n\n \nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}\n\n \nu16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\tif (node->tree->attributes & HFS_TREE_BIGKEYS)\n\t\t\tretval = node->tree->max_key_len + 2;\n\t\telse\n\t\t\tretval = node->tree->max_key_len + 1;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node, node->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (node->tree->attributes & HFS_TREE_BIGKEYS) {\n\t\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\t\tpr_err(\"keylen %d too large\\n\", retval);\n\t\t\t\tretval = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tretval = (hfs_bnode_read_u8(node, recoff) | 1) + 1;\n\t\t\tif (retval > node->tree->max_key_len + 1) {\n\t\t\t\tpr_err(\"keylen %d too large\\n\", retval);\n\t\t\t\tretval = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t\tfd->bnode = node;\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = (fd->search_key->key_len | 1) + 1;\nagain:\n\t \n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t \n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t \n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t \n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t \n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t \n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t \n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t \n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_len = fd->search_key->key_len + 1;\n\t\telse {\n\t\t\tfd->search_key->key_len = tree->max_key_len;\n\t\t\tkey_len = tree->max_key_len + 1;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t \n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t \n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t \n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t \n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t \n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t \n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t \n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}\n\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t \n\tif (tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\tnewkeylen = (hfs_bnode_read_u8(node, 14) | 1) + 1;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 1;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\tprintk(KERN_DEBUG \"splitting index node...\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t \n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS))\n\t\thfs_bnode_write_u8(parent, fd->keyoffset, newkeylen - 1);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t \n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t\tnew_node = NULL;\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}\n\nstatic int hfs_btree_inc_height(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *new_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint key_size, rec;\n\t__be32 cnid;\n\n\tnode = NULL;\n\tif (tree->root) {\n\t\tnode = hfs_bnode_find(tree, tree->root);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t}\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node)) {\n\t\thfs_bnode_put(node);\n\t\treturn PTR_ERR(new_node);\n\t}\n\n\ttree->root = new_node->this;\n\tif (!tree->depth) {\n\t\ttree->leaf_head = tree->leaf_tail = new_node->this;\n\t\tnew_node->type = HFS_NODE_LEAF;\n\t\tnew_node->num_recs = 0;\n\t} else {\n\t\tnew_node->type = HFS_NODE_INDEX;\n\t\tnew_node->num_recs = 1;\n\t}\n\tnew_node->parent = 0;\n\tnew_node->next = 0;\n\tnew_node->prev = 0;\n\tnew_node->height = ++tree->depth;\n\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\trec = tree->node_size - 2;\n\thfs_bnode_write_u16(new_node, rec, 14);\n\n\tif (node) {\n\t\t \n\t\tnode->parent = tree->root;\n\t\tif (node->type == HFS_NODE_LEAF ||\n\t\t    tree->attributes & HFS_TREE_VARIDXKEYS)\n\t\t\tkey_size = hfs_bnode_read_u8(node, 14) + 1;\n\t\telse\n\t\t\tkey_size = tree->max_key_len + 1;\n\t\thfs_bnode_copy(new_node, 14, node, 14, key_size);\n\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tkey_size = tree->max_key_len + 1;\n\t\t\thfs_bnode_write_u8(new_node, 14, tree->max_key_len);\n\t\t}\n\t\tkey_size = (key_size + 1) & -2;\n\t\tcnid = cpu_to_be32(node->this);\n\t\thfs_bnode_write(new_node, &cnid, 14 + key_size, 4);\n\n\t\trec -= 2;\n\t\thfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);\n\n\t\thfs_bnode_put(node);\n\t}\n\thfs_bnode_put(new_node);\n\tmark_inode_dirty(tree->inode);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}