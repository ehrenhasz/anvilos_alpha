{
  "module_name": "dir.c",
  "hash_id": "e7624afee2d29587dcdd4e75aa81d0a7b895c235ca4b424500f4771b5f3a3a15",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/dir.c",
  "human_readable_source": " \n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\n \nstatic struct dentry *hfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tstruct inode *inode = NULL;\n\tint res;\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\thfs_cat_build_key(dir->i_sb, fd.search_key, dir->i_ino, &dentry->d_name);\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (res) {\n\t\tif (res != -ENOENT)\n\t\t\tinode = ERR_PTR(res);\n\t} else {\n\t\tinode = hfs_iget(dir->i_sb, &fd.search_key->cat, &rec);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-EACCES);\n\t}\n\thfs_find_exit(&fd);\n\treturn d_splice_alias(inode, dentry);\n}\n\n \nstatic int hfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFS_MAX_NAMELEN];\n\tunion hfs_cat_rec entry;\n\tstruct hfs_find_data fd;\n\tstruct hfs_readdir_data *rd;\n\tu16 type;\n\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfs_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t \n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\tif (entry.type != HFS_CDR_THD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.ParID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.ParID) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\ttype = entry.type;\n\t\tlen = hfs_mac2asc(sb, strbuf, &fd.key->cat.CName);\n\t\tif (type == HFS_CDR_DIR) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.dir.DirID), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFS_CDR_FIL) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.file.FlNum), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type %d\\n\", type);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfs_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tspin_lock(&HFS_I(inode)->open_dir_lock);\n\t\tlist_add(&rd->list, &HFS_I(inode)->open_dir_list);\n\t\tspin_unlock(&HFS_I(inode)->open_dir_lock);\n\t}\n\t \n\tmemcpy(&rd->key, &fd.key->cat, sizeof(struct hfs_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n\nstatic int hfs_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfs_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tspin_lock(&HFS_I(inode)->open_dir_lock);\n\t\tlist_del(&rd->list);\n\t\tspin_unlock(&HFS_I(inode)->open_dir_lock);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}\n\n \nstatic int hfs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, mode);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n \nstatic int hfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, S_IFDIR | mode);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n \nstatic int hfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint res;\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\tres = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\treturn res;\n\tclear_nlink(inode);\n\tinode_set_ctime_current(inode);\n\thfs_delete_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\n \nstatic int hfs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t      struct dentry *old_dentry, struct inode *new_dir,\n\t\t      struct dentry *new_dentry, unsigned int flags)\n{\n\tint res;\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\t \n\tif (d_really_is_positive(new_dentry)) {\n\t\tres = hfs_remove(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfs_cat_move(d_inode(old_dentry)->i_ino,\n\t\t\t   old_dir, &old_dentry->d_name,\n\t\t\t   new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\thfs_cat_build_key(old_dir->i_sb,\n\t\t\t\t  (btree_key *)&HFS_I(d_inode(old_dentry))->cat_key,\n\t\t\t\t  new_dir->i_ino, &new_dentry->d_name);\n\treturn res;\n}\n\nconst struct file_operations hfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= hfs_readdir,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= hfs_dir_release,\n};\n\nconst struct inode_operations hfs_dir_inode_operations = {\n\t.create\t\t= hfs_create,\n\t.lookup\t\t= hfs_lookup,\n\t.unlink\t\t= hfs_remove,\n\t.mkdir\t\t= hfs_mkdir,\n\t.rmdir\t\t= hfs_remove,\n\t.rename\t\t= hfs_rename,\n\t.setattr\t= hfs_inode_setattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}