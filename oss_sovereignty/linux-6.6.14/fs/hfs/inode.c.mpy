{
  "module_name": "inode.c",
  "hash_id": "01ff03390dccdd0b21f92129e8c57c114d250345d3a29481c79b5ea635fa57d5",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/inode.c",
  "human_readable_source": " \n\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <linux/blkdev.h>\n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\n\n \n\n#define HFS_VALID_MODE_BITS  (S_IFREG | S_IFDIR | S_IRWXUGO)\n\nstatic int hfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, hfs_get_block, wbc);\n}\n\nstatic int hfs_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, hfs_get_block);\n}\n\nstatic void hfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\thfs_file_truncate(inode);\n\t}\n}\n\nint hfs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\t*pagep = NULL;\n\tret = cont_write_begin(file, mapping, pos, len, pagep, fsdata,\n\t\t\t\thfs_get_block,\n\t\t\t\t&HFS_I(mapping->host)->phys_size);\n\tif (unlikely(ret))\n\t\thfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}\n\nstatic sector_t hfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, hfs_get_block);\n}\n\nstatic bool hfs_release_folio(struct folio *folio, gfp_t mask)\n{\n\tstruct inode *inode = folio->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node;\n\tu32 nidx;\n\tint i;\n\tbool res = true;\n\n\tswitch (inode->i_ino) {\n\tcase HFS_EXT_CNID:\n\t\ttree = HFS_SB(sb)->ext_tree;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\ttree = HFS_SB(sb)->cat_tree;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n\n\tif (!tree)\n\t\treturn false;\n\n\tif (tree->node_size >= PAGE_SIZE) {\n\t\tnidx = folio->index >> (tree->node_size_shift - PAGE_SHIFT);\n\t\tspin_lock(&tree->hash_lock);\n\t\tnode = hfs_bnode_findhash(tree, nidx);\n\t\tif (!node)\n\t\t\t;\n\t\telse if (atomic_read(&node->refcnt))\n\t\t\tres = false;\n\t\tif (res && node) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t} else {\n\t\tnidx = folio->index << (PAGE_SHIFT - tree->node_size_shift);\n\t\ti = 1 << (PAGE_SHIFT - tree->node_size_shift);\n\t\tspin_lock(&tree->hash_lock);\n\t\tdo {\n\t\t\tnode = hfs_bnode_findhash(tree, nidx++);\n\t\t\tif (!node)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&node->refcnt)) {\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thfs_bnode_unhash(node);\n\t\t\thfs_bnode_free(node);\n\t\t} while (--i && nidx < tree->node_count);\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n\treturn res ? try_to_free_buffers(folio) : false;\n}\n\nstatic ssize_t hfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(iocb, inode, iter, hfs_get_block);\n\n\t \n\tif (unlikely(iov_iter_rw(iter) == WRITE && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = iocb->ki_pos + count;\n\n\t\tif (end > isize)\n\t\t\thfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}\n\nstatic int hfs_writepages(struct address_space *mapping,\n\t\t\t  struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, hfs_get_block);\n}\n\nconst struct address_space_operations hfs_btree_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= hfs_read_folio,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.release_folio\t= hfs_release_folio,\n};\n\nconst struct address_space_operations hfs_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= hfs_read_folio,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n\t.migrate_folio\t= buffer_migrate_folio,\n};\n\n \nstruct inode *hfs_new_inode(struct inode *dir, const struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\tspin_lock_init(&HFS_I(inode)->open_dir_lock);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}\n\nvoid hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}\n\nvoid hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t __be32 __log_size, __be32 phys_size, u32 clump_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tu32 log_size = be32_to_cpu(__log_size);\n\tu16 count;\n\tint i;\n\n\tmemcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));\n\tfor (count = 0, i = 0; i < 3; i++)\n\t\tcount += be16_to_cpu(ext[i].count);\n\tHFS_I(inode)->first_blocks = count;\n\n\tinode->i_size = HFS_I(inode)->phys_size = log_size;\n\tHFS_I(inode)->fs_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, HFS_I(inode)->fs_blocks << sb->s_blocksize_bits);\n\tHFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /\n\t\t\t\t     HFS_SB(sb)->alloc_blksz;\n\tHFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_I(inode)->clump_blocks)\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n}\n\nstruct hfs_iget_data {\n\tstruct hfs_cat_key *key;\n\thfs_cat_rec *rec;\n};\n\nstatic int hfs_test_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\thfs_cat_rec *rec;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\treturn inode->i_ino == be32_to_cpu(rec->dir.DirID);\n\tcase HFS_CDR_FIL:\n\t\treturn inode->i_ino == be32_to_cpu(rec->file.FlNum);\n\tdefault:\n\t\tBUG();\n\t\treturn 1;\n\t}\n}\n\n \nstatic int hfs_read_inode(struct inode *inode, void *data)\n{\n\tstruct hfs_iget_data *idata = data;\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\thfs_cat_rec *rec;\n\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\tspin_lock_init(&HFS_I(inode)->open_dir_lock);\n\n\t \n\tinode->i_uid = hsb->s_uid;\n\tinode->i_gid = hsb->s_gid;\n\tset_nlink(inode, 1);\n\n\tif (idata->key)\n\t\tHFS_I(inode)->cat_key = *idata->key;\n\telse\n\t\tHFS_I(inode)->flags |= HFS_FLG_RSRC;\n\tHFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;\n\n\trec = idata->rec;\n\tswitch (rec->type) {\n\tcase HFS_CDR_FIL:\n\t\tif (!HFS_IS_RSRC(inode)) {\n\t\t\thfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,\n\t\t\t\t\t    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t} else {\n\t\t\thfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,\n\t\t\t\t\t    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));\n\t\t}\n\n\t\tinode->i_ino = be32_to_cpu(rec->file.FlNum);\n\t\tinode->i_mode = S_IRUGO | S_IXUGO;\n\t\tif (!(rec->file.Flags & HFS_FIL_LOCK))\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~hsb->s_file_umask;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t\t\thfs_m_to_utime(rec->file.MdDat));\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tbreak;\n\tcase HFS_CDR_DIR:\n\t\tinode->i_ino = be32_to_cpu(rec->dir.DirID);\n\t\tinode->i_size = be16_to_cpu(rec->dir.Val) + 2;\n\t\tHFS_I(inode)->fs_blocks = 0;\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~hsb->s_dir_umask);\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_to_ts(inode,\n\t\t\t\t\t\t\t\t\thfs_m_to_utime(rec->dir.MdDat));\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tbreak;\n\tdefault:\n\t\tmake_bad_inode(inode);\n\t}\n\treturn 0;\n}\n\n \nstruct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)\n{\n\tstruct hfs_iget_data data = { key, rec };\n\tstruct inode *inode;\n\tu32 cnid;\n\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\tcnid = be32_to_cpu(rec->dir.DirID);\n\t\tbreak;\n\tcase HFS_CDR_FIL:\n\t\tcnid = be32_to_cpu(rec->file.FlNum);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tinode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\treturn inode;\n}\n\nvoid hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}\n\nint hfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfs_cat_rec rec;\n\tint res;\n\n\thfs_dbg(INODE, \"hfs_write_inode: %lu\\n\", inode->i_ino);\n\tres = hfs_ext_write_extent(inode);\n\tif (res)\n\t\treturn res;\n\n\tif (inode->i_ino < HFS_FIRSTUSER_CNID) {\n\t\tswitch (inode->i_ino) {\n\t\tcase HFS_ROOT_CNID:\n\t\t\tbreak;\n\t\tcase HFS_EXT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->ext_tree);\n\t\t\treturn 0;\n\t\tcase HFS_CAT_CNID:\n\t\t\thfs_btree_write(HFS_SB(inode->i_sb)->cat_tree);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (HFS_IS_RSRC(inode))\n\t\tmain_inode = HFS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t \n\t\treturn -EIO;\n\n\tres = -EIO;\n\tif (HFS_I(main_inode)->cat_key.CName.len > HFS_NAMELEN)\n\t\tgoto out;\n\tfd.search_key->cat = HFS_I(main_inode)->cat_key;\n\tif (hfs_brec_find(&fd))\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir))\n\t\t\tgoto out;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_dir));\n\t\tif (rec.type != HFS_CDR_DIR ||\n\t\t    be32_to_cpu(rec.dir.DirID) != inode->i_ino) {\n\t\t}\n\n\t\trec.dir.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\t\trec.dir.Val = cpu_to_be16(inode->i_size - 2);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_dir));\n\t} else if (HFS_IS_RSRC(inode)) {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_file))\n\t\t\tgoto out;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t       sizeof(struct hfs_cat_file));\n\t\thfs_inode_write_fork(inode, rec.file.RExtRec,\n\t\t\t\t     &rec.file.RLgLen, &rec.file.RPyLen);\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t\tsizeof(struct hfs_cat_file));\n\t} else {\n\t\tif (fd.entrylength < sizeof(struct hfs_cat_file))\n\t\t\tgoto out;\n\t\thfs_bnode_read(fd.bnode, &rec, fd.entryoffset,\n\t\t\t   sizeof(struct hfs_cat_file));\n\t\tif (rec.type != HFS_CDR_FIL ||\n\t\t    be32_to_cpu(rec.file.FlNum) != inode->i_ino) {\n\t\t}\n\n\t\tif (inode->i_mode & S_IWUSR)\n\t\t\trec.file.Flags &= ~HFS_FIL_LOCK;\n\t\telse\n\t\t\trec.file.Flags |= HFS_FIL_LOCK;\n\t\thfs_inode_write_fork(inode, rec.file.ExtRec, &rec.file.LgLen, &rec.file.PyLen);\n\t\trec.file.MdDat = hfs_u_to_mtime(inode->i_mtime);\n\n\t\thfs_bnode_write(fd.bnode, &rec, fd.entryoffset,\n\t\t\t    sizeof(struct hfs_cat_file));\n\t}\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\treturn res;\n}\n\nstatic struct dentry *hfs_file_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (HFS_IS_RSRC(dir) || strcmp(dentry->d_name.name, \"rsrc\"))\n\t\tgoto out;\n\n\tinode = HFS_I(dir)->rsrc_inode;\n\tif (inode)\n\t\tgoto out;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tfd.search_key->cat = HFS_I(dir)->cat_key;\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (!res) {\n\t\tstruct hfs_iget_data idata = { NULL, &rec };\n\t\thfs_read_inode(inode, &idata);\n\t}\n\thfs_find_exit(&fd);\n\tif (res) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(res);\n\t}\n\tHFS_I(inode)->rsrc_inode = dir;\n\tHFS_I(dir)->rsrc_inode = inode;\n\tigrab(dir);\n\tinode_fake_hash(inode);\n\tmark_inode_dirty(inode);\n\tdont_mount(dentry);\nout:\n\treturn d_splice_alias(inode, dentry);\n}\n\nvoid hfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFS_IS_RSRC(inode) && HFS_I(inode)->rsrc_inode) {\n\t\tHFS_I(HFS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFS_I(inode)->rsrc_inode);\n\t}\n}\n\nstatic int hfs_file_open(struct inode *inode, struct file *file)\n{\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tatomic_inc(&HFS_I(inode)->opencnt);\n\treturn 0;\n}\n\nstatic int hfs_file_release(struct inode *inode, struct file *file)\n{\n\t\n\n\tif (HFS_IS_RSRC(inode))\n\t\tinode = HFS_I(inode)->rsrc_inode;\n\tif (atomic_dec_and_test(&HFS_I(inode)->opencnt)) {\n\t\tinode_lock(inode);\n\t\thfs_file_truncate(inode);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tinode_unlock(inode);\n\t}\n\treturn 0;\n}\n\n \n\nint hfs_inode_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t      struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct hfs_sb_info *hsb = HFS_SB(inode->i_sb);\n\tint error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry,\n\t\t\t\tattr);  \n\tif (error)\n\t\treturn error;\n\n\t \n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, hsb->s_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, hsb->s_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     ((S_ISDIR(inode->i_mode) &&\n\t       (attr->ia_mode != inode->i_mode)) ||\n\t      (attr->ia_mode & ~HFS_VALID_MODE_BITS)))) {\n\t\treturn hsb->s_quiet ? 0 : error;\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\t \n\t\tif (attr->ia_mode & S_IWUSR)\n\t\t\tattr->ia_mode = inode->i_mode | S_IWUGO;\n\t\telse\n\t\t\tattr->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\tattr->ia_mode &= S_ISDIR(inode->i_mode) ? ~hsb->s_dir_umask: ~hsb->s_file_umask;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\tinode_dio_wait(inode);\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thfs_file_truncate(inode);\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic int hfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct super_block * sb;\n\tint ret, err;\n\n\tret = file_write_and_wait_range(filp, start, end);\n\tif (ret)\n\t\treturn ret;\n\tinode_lock(inode);\n\n\t \n\tret = write_inode_now(inode, 0);\n\n\t \n\tsb = inode->i_sb;\n\tflush_delayed_work(&HFS_SB(sb)->mdb_work);\n\t \n\terr = sync_blockdev(sb->s_bdev);\n\tif (!ret)\n\t\tret = err;\n\tinode_unlock(inode);\n\treturn ret;\n}\n\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read_iter\t= generic_file_read_iter,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= filemap_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\n\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.listxattr\t= generic_listxattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}