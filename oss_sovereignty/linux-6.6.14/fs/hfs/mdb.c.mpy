{
  "module_name": "mdb.c",
  "hash_id": "f22cc1caf16587c6553218d1700c362c83e792182cebb2f7b36dcec98908dc9a",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/mdb.c",
  "human_readable_source": " \n\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/nls.h>\n#include <linux/slab.h>\n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\n \n\n \n\nstatic int hfs_get_last_session(struct super_block *sb,\n\t\t\t\tsector_t *start, sector_t *size)\n{\n\tstruct cdrom_device_info *cdi = disk_to_cdi(sb->s_bdev->bd_disk);\n\n\t \n\t*start = 0;\n\t*size = bdev_nr_sectors(sb->s_bdev);\n\n\tif (HFS_SB(sb)->session >= 0) {\n\t\tstruct cdrom_tocentry te;\n\t\n\t\tif (!cdi)\n\t\t\treturn -EINVAL;\n\n\t\tte.cdte_track = HFS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tif (cdrom_read_tocentry(cdi, &te) ||\n\t\t    (te.cdte_ctrl & CDROM_DATA_TRACK) != 4) {\n\t\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t} else if (cdi) {\n\t\tstruct cdrom_multisession ms_info;\n\n\t\tms_info.addr_format = CDROM_LBA;\n\t\tif (cdrom_multisession(cdi, &ms_info) == 0 && ms_info.xa_flag)\n\t\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\t}\n\n\treturn 0;\n}\n\n \nint hfs_mdb_get(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct hfs_mdb *mdb, *mdb2;\n\tunsigned int block;\n\tchar *ptr;\n\tint off2, len, size, sect;\n\tsector_t part_start, part_size;\n\tloff_t off;\n\t__be16 attrib;\n\n\t \n\tsize = sb_min_blocksize(sb, HFS_SECTOR_SIZE);\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (hfs_get_last_session(sb, &part_start, &part_size))\n\t\treturn -EINVAL;\n\twhile (1) {\n\t\t \n\t\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tif (mdb->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC))\n\t\t\tbreak;\n\t\tbrelse(bh);\n\n\t\t \n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out;\n\t}\n\n\tHFS_SB(sb)->alloc_blksz = size = be32_to_cpu(mdb->drAlBlkSiz);\n\tif (!size || (size & (HFS_SECTOR_SIZE - 1))) {\n\t\tpr_err(\"bad allocation block size %d\\n\", size);\n\t\tgoto out_bh;\n\t}\n\n\tsize = min(HFS_SB(sb)->alloc_blksz, (u32)PAGE_SIZE);\n\t \n\twhile (size & (size - 1))\n\t\tsize -= HFS_SECTOR_SIZE;\n\tsect = be16_to_cpu(mdb->drAlBlSt) + part_start;\n\t \n\twhile (sect & ((size - 1) >> HFS_SECTOR_SIZE_BITS))\n\t\tsize >>= 1;\n\t \n\twhile (HFS_SB(sb)->alloc_blksz & (size - 1))\n\t\tsize >>= 1;\n\tbrelse(bh);\n\tif (!sb_set_blocksize(sb, size)) {\n\t\tpr_err(\"unable to set blocksize to %u\\n\", size);\n\t\tgoto out;\n\t}\n\n\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\tif (!bh)\n\t\tgoto out;\n\tif (mdb->drSigWord != cpu_to_be16(HFS_SUPER_MAGIC))\n\t\tgoto out_bh;\n\n\tHFS_SB(sb)->mdb_bh = bh;\n\tHFS_SB(sb)->mdb = mdb;\n\n\t \n\tHFS_SB(sb)->part_start = part_start;\n\tHFS_SB(sb)->fs_ablocks = be16_to_cpu(mdb->drNmAlBlks);\n\tHFS_SB(sb)->fs_div = HFS_SB(sb)->alloc_blksz >> sb->s_blocksize_bits;\n\tHFS_SB(sb)->clumpablks = be32_to_cpu(mdb->drClpSiz) /\n\t\t\t\t HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_SB(sb)->clumpablks)\n\t\tHFS_SB(sb)->clumpablks = 1;\n\tHFS_SB(sb)->fs_start = (be16_to_cpu(mdb->drAlBlSt) + part_start) >>\n\t\t\t       (sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS);\n\n\t \n\tHFS_SB(sb)->free_ablocks = be16_to_cpu(mdb->drFreeBks);\n\tHFS_SB(sb)->next_id = be32_to_cpu(mdb->drNxtCNID);\n\tHFS_SB(sb)->root_files = be16_to_cpu(mdb->drNmFls);\n\tHFS_SB(sb)->root_dirs = be16_to_cpu(mdb->drNmRtDirs);\n\tHFS_SB(sb)->file_count = be32_to_cpu(mdb->drFilCnt);\n\tHFS_SB(sb)->folder_count = be32_to_cpu(mdb->drDirCnt);\n\n\t \n\tsect = part_start + part_size - 2;\n\tbh = sb_bread512(sb, sect, mdb2);\n\tif (bh) {\n\t\tif (mdb2->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC)) {\n\t\t\tHFS_SB(sb)->alt_mdb_bh = bh;\n\t\t\tHFS_SB(sb)->alt_mdb = mdb2;\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (!HFS_SB(sb)->alt_mdb) {\n\t\tpr_warn(\"unable to locate alternate MDB\\n\");\n\t\tpr_warn(\"continuing without an alternate MDB\\n\");\n\t}\n\n\tHFS_SB(sb)->bitmap = kmalloc(8192, GFP_KERNEL);\n\tif (!HFS_SB(sb)->bitmap)\n\t\tgoto out;\n\n\t \n\tblock = be16_to_cpu(mdb->drVBMSt) + part_start;\n\toff = (loff_t)block << HFS_SECTOR_SIZE_BITS;\n\tsize = (HFS_SB(sb)->fs_ablocks + 8) / 8;\n\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\twhile (size) {\n\t\tbh = sb_bread(sb, off >> sb->s_blocksize_bits);\n\t\tif (!bh) {\n\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\toff2 = off & (sb->s_blocksize - 1);\n\t\tlen = min((int)sb->s_blocksize - off2, size);\n\t\tmemcpy(ptr, bh->b_data + off2, len);\n\t\tbrelse(bh);\n\t\tptr += len;\n\t\toff += len;\n\t\tsize -= len;\n\t}\n\n\tHFS_SB(sb)->ext_tree = hfs_btree_open(sb, HFS_EXT_CNID, hfs_ext_keycmp);\n\tif (!HFS_SB(sb)->ext_tree) {\n\t\tpr_err(\"unable to open extent tree\\n\");\n\t\tgoto out;\n\t}\n\tHFS_SB(sb)->cat_tree = hfs_btree_open(sb, HFS_CAT_CNID, hfs_cat_keycmp);\n\tif (!HFS_SB(sb)->cat_tree) {\n\t\tpr_err(\"unable to open catalog tree\\n\");\n\t\tgoto out;\n\t}\n\n\tattrib = mdb->drAtrb;\n\tif (!(attrib & cpu_to_be16(HFS_SB_ATTRIB_UNMNT))) {\n\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfs is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\tif ((attrib & cpu_to_be16(HFS_SB_ATTRIB_SLOCK))) {\n\t\tpr_warn(\"filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\tif (!sb_rdonly(sb)) {\n\t\t \n\t\tattrib &= cpu_to_be16(~HFS_SB_ATTRIB_UNMNT);\n\t\tattrib |= cpu_to_be16(HFS_SB_ATTRIB_INCNSTNT);\n\t\tmdb->drAtrb = attrib;\n\t\tbe32_add_cpu(&mdb->drWrCnt, 1);\n\t\tmdb->drLsMod = hfs_mtime();\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->mdb_bh);\n\t}\n\n\treturn 0;\n\nout_bh:\n\tbrelse(bh);\nout:\n\thfs_mdb_put(sb);\n\treturn -EIO;\n}\n\n \nvoid hfs_mdb_commit(struct super_block *sb)\n{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\n\tif (sb_rdonly(sb))\n\t\treturn;\n\n\tlock_buffer(HFS_SB(sb)->mdb_bh);\n\tif (test_and_clear_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags)) {\n\t\t \n\t\tmdb->drLsMod = hfs_mtime();\n\t\tmdb->drFreeBks = cpu_to_be16(HFS_SB(sb)->free_ablocks);\n\t\tmdb->drNxtCNID = cpu_to_be32(HFS_SB(sb)->next_id);\n\t\tmdb->drNmFls = cpu_to_be16(HFS_SB(sb)->root_files);\n\t\tmdb->drNmRtDirs = cpu_to_be16(HFS_SB(sb)->root_dirs);\n\t\tmdb->drFilCnt = cpu_to_be32(HFS_SB(sb)->file_count);\n\t\tmdb->drDirCnt = cpu_to_be32(HFS_SB(sb)->folder_count);\n\n\t\t \n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t}\n\n\t \n\tif (test_and_clear_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags) &&\n\t    HFS_SB(sb)->alt_mdb) {\n\t\thfs_inode_write_fork(HFS_SB(sb)->ext_tree->inode, mdb->drXTExtRec,\n\t\t\t\t     &mdb->drXTFlSize, NULL);\n\t\thfs_inode_write_fork(HFS_SB(sb)->cat_tree->inode, mdb->drCTExtRec,\n\t\t\t\t     &mdb->drCTFlSize, NULL);\n\n\t\tlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t\tmemcpy(HFS_SB(sb)->alt_mdb, HFS_SB(sb)->mdb, HFS_SECTOR_SIZE);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\t\tunlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->alt_mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t}\n\n\tif (test_and_clear_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags)) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t block;\n\t\tchar *ptr;\n\t\tint off, size, len;\n\n\t\tblock = be16_to_cpu(HFS_SB(sb)->mdb->drVBMSt) + HFS_SB(sb)->part_start;\n\t\toff = (block << HFS_SECTOR_SIZE_BITS) & (sb->s_blocksize - 1);\n\t\tblock >>= sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS;\n\t\tsize = (HFS_SB(sb)->fs_ablocks + 7) / 8;\n\t\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\t\twhile (size) {\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = min((int)sb->s_blocksize - off, size);\n\n\t\t\tlock_buffer(bh);\n\t\t\tmemcpy(bh->b_data + off, ptr, len);\n\t\t\tunlock_buffer(bh);\n\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tblock++;\n\t\t\toff = 0;\n\t\t\tptr += len;\n\t\t\tsize -= len;\n\t\t}\n\t}\n\tunlock_buffer(HFS_SB(sb)->mdb_bh);\n}\n\nvoid hfs_mdb_close(struct super_block *sb)\n{\n\t \n\tif (sb_rdonly(sb))\n\t\treturn;\n\tHFS_SB(sb)->mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\tHFS_SB(sb)->mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n}\n\n \nvoid hfs_mdb_put(struct super_block *sb)\n{\n\tif (!HFS_SB(sb))\n\t\treturn;\n\t \n\thfs_btree_close(HFS_SB(sb)->ext_tree);\n\thfs_btree_close(HFS_SB(sb)->cat_tree);\n\n\t \n\tbrelse(HFS_SB(sb)->mdb_bh);\n\tbrelse(HFS_SB(sb)->alt_mdb_bh);\n\n\tunload_nls(HFS_SB(sb)->nls_io);\n\tunload_nls(HFS_SB(sb)->nls_disk);\n\n\tkfree(HFS_SB(sb)->bitmap);\n\tkfree(HFS_SB(sb));\n\tsb->s_fs_info = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}