{
  "module_name": "bitmap.c",
  "hash_id": "189b3604f23469670ad52681f7ec64ab41cf16221dd97fe7cb2a15e2e621ad47",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/bitmap.c",
  "human_readable_source": " \n\n#include \"hfs_fs.h\"\n\n \nstatic u32 hfs_find_set_zero_bits(__be32 *bitmap, u32 size, u32 offset, u32 *max)\n{\n\t__be32 *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tcurr = bitmap + (offset / 32);\n\tend = bitmap + ((size + 31) / 32);\n\n\t \n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\ti = offset % 32;\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\twhile (++curr < end) {\n\t\tval = *curr;\n\t\tif (~val) {\n\t\t\tn = be32_to_cpu(val);\n\t\t\tmask = 1 << 31;\n\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\tif (!(n & mask))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n\nfound:\n\tstart = (curr - bitmap) * 32 + i;\n\tif (start >= size)\n\t\treturn start;\n\t \n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t \n\twhile (1) {\n\t\tn = be32_to_cpu(*curr);\n\t\tif (len < 32)\n\t\t\tbreak;\n\t\tif (n) {\n\t\t\tlen = 32;\n\t\t\tbreak;\n\t\t}\n\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\tlen -= 32;\n\t}\n\t \n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\t*max = (curr - bitmap) * 32 + i - start;\n\treturn start;\n}\n\n \nu32 hfs_vbm_search_free(struct super_block *sb, u32 goal, u32 *num_bits)\n{\n\tvoid *bitmap;\n\tu32 pos;\n\n\t \n\tif (!*num_bits)\n\t\treturn 0;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\tbitmap = HFS_SB(sb)->bitmap;\n\n\tpos = hfs_find_set_zero_bits(bitmap, HFS_SB(sb)->fs_ablocks, goal, num_bits);\n\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\tif (goal)\n\t\t\tpos = hfs_find_set_zero_bits(bitmap, goal, 0, num_bits);\n\t\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\t\t*num_bits = pos = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thfs_dbg(BITMAP, \"alloc_bits: %u,%u\\n\", pos, *num_bits);\n\tHFS_SB(sb)->free_ablocks -= *num_bits;\n\thfs_bitmap_dirty(sb);\nout:\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\treturn pos;\n}\n\n\n \nint hfs_clear_vbm_bits(struct super_block *sb, u16 start, u16 count)\n{\n\t__be32 *curr;\n\tu32 mask;\n\tint i, len;\n\n\t \n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"clear_bits: %u,%u\\n\", start, count);\n\t \n\tif ((start + count) > HFS_SB(sb)->fs_ablocks)\n\t\treturn -2;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\t \n\tcurr = HFS_SB(sb)->bitmap + (start / 32);\n\tlen = count;\n\n\t \n\ti = start % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t \n\twhile (count >= 32) {\n\t\t*curr++ = 0;\n\t\tcount -= 32;\n\t}\n\t \n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tHFS_SB(sb)->free_ablocks += len;\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\thfs_bitmap_dirty(sb);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}