{
  "module_name": "hfs_fs.h",
  "hash_id": "ac71307c9cb482b76487302e4e5f8ffd881b0e3b81bd7ed18713c287fe18b2e7",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/hfs_fs.h",
  "human_readable_source": " \n\n#ifndef _LINUX_HFS_FS_H\n#define _LINUX_HFS_FS_H\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/workqueue.h>\n\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#include \"hfs.h\"\n\n#define DBG_BNODE_REFS\t0x00000001\n#define DBG_BNODE_MOD\t0x00000002\n#define DBG_CAT_MOD\t0x00000004\n#define DBG_INODE\t0x00000008\n#define DBG_SUPER\t0x00000010\n#define DBG_EXTENT\t0x00000020\n#define DBG_BITMAP\t0x00000040\n\n\n\n\n#define DBG_MASK\t(0)\n\n#define hfs_dbg(flg, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (DBG_##flg & DBG_MASK)\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);\t\\\n} while (0)\n\n#define hfs_dbg_cont(flg, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (DBG_##flg & DBG_MASK)\t\t\t\t\\\n\t\tpr_cont(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n\n \nstruct hfs_inode_info {\n\tatomic_t opencnt;\n\n\tunsigned int flags;\n\n\t \n\tint tz_secondswest;\n\n\tstruct hfs_cat_key cat_key;\n\n\tstruct list_head open_dir_list;\n\tspinlock_t open_dir_lock;\n\tstruct inode *rsrc_inode;\n\n\tstruct mutex extents_lock;\n\n\tu16 alloc_blocks, clump_blocks;\n\tsector_t fs_blocks;\n\t \n\thfs_extent_rec first_extents;\n\tu16 first_blocks;\n\thfs_extent_rec cached_extents;\n\tu16 cached_start, cached_blocks;\n\n\tloff_t phys_size;\n\tstruct inode vfs_inode;\n};\n\n#define HFS_FLG_RSRC\t\t0x0001\n#define HFS_FLG_EXT_DIRTY\t0x0002\n#define HFS_FLG_EXT_NEW\t\t0x0004\n\n#define HFS_IS_RSRC(inode)\t(HFS_I(inode)->flags & HFS_FLG_RSRC)\n\n \nstruct hfs_sb_info {\n\tstruct buffer_head *mdb_bh;\t\t \n\tstruct hfs_mdb *mdb;\n\tstruct buffer_head *alt_mdb_bh;\t\t \n\tstruct hfs_mdb *alt_mdb;\n\t__be32 *bitmap;\t\t\t\t \n\tstruct hfs_btree *ext_tree;\t\t\t \n\tstruct hfs_btree *cat_tree;\t\t\t \n\tu32 file_count;\t\t\t\t \n\tu32 folder_count;\t\t\t \n\tu32 next_id;\t\t\t\t \n\tu32 clumpablks;\t\t\t\t \n\tu32 fs_start;\t\t\t\t \n\tu32 part_start;\n\tu16 root_files;\t\t\t\t \n\tu16 root_dirs;\t\t\t\t \n\tu16 fs_ablocks;\t\t\t\t \n\tu16 free_ablocks;\t\t\t \n\tu32 alloc_blksz;\t\t\t \n\tint s_quiet;\t\t\t\t \n\t__be32 s_type;\t\t\t\t \n\t__be32 s_creator;\t\t\t \n\tumode_t s_file_umask;\t\t\t \n\tumode_t s_dir_umask;\t\t\t \n\tkuid_t s_uid;\t\t\t\t \n\tkgid_t s_gid;\t\t\t\t \n\n\tint session, part;\n\tstruct nls_table *nls_io, *nls_disk;\n\tstruct mutex bitmap_lock;\n\tunsigned long flags;\n\tu16 blockoffset;\n\tint fs_div;\n\tstruct super_block *sb;\n\tint work_queued;\t\t \n\tstruct delayed_work mdb_work;\t \n\tspinlock_t work_lock;\t\t \n};\n\n#define HFS_FLG_BITMAP_DIRTY\t0\n#define HFS_FLG_MDB_DIRTY\t1\n#define HFS_FLG_ALT_MDB_DIRTY\t2\n\n \nextern u32 hfs_vbm_search_free(struct super_block *, u32, u32 *);\nextern int hfs_clear_vbm_bits(struct super_block *, u16, u16);\n\n \nextern int hfs_cat_keycmp(const btree_key *, const btree_key *);\nstruct hfs_find_data;\nextern int hfs_cat_find_brec(struct super_block *, u32, struct hfs_find_data *);\nextern int hfs_cat_create(u32, struct inode *, const struct qstr *, struct inode *);\nextern int hfs_cat_delete(u32, struct inode *, const struct qstr *);\nextern int hfs_cat_move(u32, struct inode *, const struct qstr *,\n\t\t\tstruct inode *, const struct qstr *);\nextern void hfs_cat_build_key(struct super_block *, btree_key *, u32, const struct qstr *);\n\n \nextern const struct file_operations hfs_dir_operations;\nextern const struct inode_operations hfs_dir_inode_operations;\n\n \nextern int hfs_ext_keycmp(const btree_key *, const btree_key *);\nextern int hfs_free_fork(struct super_block *, struct hfs_cat_file *, int);\nextern int hfs_ext_write_extent(struct inode *);\nextern int hfs_extend_file(struct inode *);\nextern void hfs_file_truncate(struct inode *);\n\nextern int hfs_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\n \nextern const struct address_space_operations hfs_aops;\nextern const struct address_space_operations hfs_btree_aops;\n\nint hfs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata);\nextern struct inode *hfs_new_inode(struct inode *, const struct qstr *, umode_t);\nextern void hfs_inode_write_fork(struct inode *, struct hfs_extent *, __be32 *, __be32 *);\nextern int hfs_write_inode(struct inode *, struct writeback_control *);\nextern int hfs_inode_setattr(struct mnt_idmap *, struct dentry *,\n\t\t\t     struct iattr *);\nextern void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t__be32 log_size, __be32 phys_size, u32 clump_size);\nextern struct inode *hfs_iget(struct super_block *, struct hfs_cat_key *, hfs_cat_rec *);\nextern void hfs_evict_inode(struct inode *);\nextern void hfs_delete_inode(struct inode *);\n\n \nextern const struct xattr_handler *hfs_xattr_handlers[];\n\n \nextern int hfs_mdb_get(struct super_block *);\nextern void hfs_mdb_commit(struct super_block *);\nextern void hfs_mdb_close(struct super_block *);\nextern void hfs_mdb_put(struct super_block *);\n\n \nextern int hfs_part_find(struct super_block *, sector_t *, sector_t *);\n\n \nextern const struct dentry_operations hfs_dentry_operations;\n\nextern int hfs_hash_dentry(const struct dentry *, struct qstr *);\nextern int hfs_strcmp(const unsigned char *, unsigned int,\n\t\t      const unsigned char *, unsigned int);\nextern int hfs_compare_dentry(const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\n \nextern void hfs_asc2mac(struct super_block *, struct hfs_name *, const struct qstr *);\nextern int hfs_mac2asc(struct super_block *, char *, const struct hfs_name *);\n\n \nextern void hfs_mark_mdb_dirty(struct super_block *sb);\n\n \n#define HFS_UTC_OFFSET 2082844800U\n\nstatic inline time64_t __hfs_m_to_utime(__be32 mt)\n{\n\ttime64_t ut = (u32)(be32_to_cpu(mt) - HFS_UTC_OFFSET);\n\n\treturn ut + sys_tz.tz_minuteswest * 60;\n}\n\nstatic inline __be32 __hfs_u_to_mtime(time64_t ut)\n{\n\tut -= sys_tz.tz_minuteswest * 60;\n\n\treturn cpu_to_be32(lower_32_bits(ut) + HFS_UTC_OFFSET);\n}\n#define HFS_I(inode)\t(container_of(inode, struct hfs_inode_info, vfs_inode))\n#define HFS_SB(sb)\t((struct hfs_sb_info *)(sb)->s_fs_info)\n\n#define hfs_m_to_utime(time)   (struct timespec64){ .tv_sec = __hfs_m_to_utime(time) }\n#define hfs_u_to_mtime(time)   __hfs_u_to_mtime((time).tv_sec)\n#define hfs_mtime()\t\t__hfs_u_to_mtime(ktime_get_real_seconds())\n\nstatic inline const char *hfs_mdb_name(struct super_block *sb)\n{\n\treturn sb->s_id;\n}\n\nstatic inline void hfs_bitmap_dirty(struct super_block *sb)\n{\n\tset_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}\n\n#define sb_bread512(sb, sec, data) ({\t\t\t\\\n\tstruct buffer_head *__bh;\t\t\t\\\n\tsector_t __block;\t\t\t\t\\\n\tloff_t __start;\t\t\t\t\t\\\n\tint __offset;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\t__start = (loff_t)(sec) << HFS_SECTOR_SIZE_BITS;\\\n\t__block = __start >> (sb)->s_blocksize_bits;\t\\\n\t__offset = __start & ((sb)->s_blocksize - 1);\t\\\n\t__bh = sb_bread((sb), __block);\t\t\t\\\n\tif (likely(__bh != NULL))\t\t\t\\\n\t\tdata = (void *)(__bh->b_data + __offset);\\\n\telse\t\t\t\t\t\t\\\n\t\tdata = NULL;\t\t\t\t\\\n\t__bh;\t\t\t\t\t\t\\\n})\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}