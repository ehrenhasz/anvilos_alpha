{
  "module_name": "catalog.c",
  "hash_id": "3fa15f6efe042d92273014d1c8f5225c07a2a074cf7679e2eb0f9df828db32cb",
  "original_prompt": "Ingested from linux-6.6.14/fs/hfs/catalog.c",
  "human_readable_source": " \n\n#include \"hfs_fs.h\"\n#include \"btree.h\"\n\n \nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, const struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}\n\nstatic int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)\n{\n\t__be32 mtime = hfs_mtime();\n\n\tmemset(rec, 0, sizeof(*rec));\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trec->type = HFS_CDR_DIR;\n\t\trec->dir.DirID = cpu_to_be32(cnid);\n\t\trec->dir.CrDat = mtime;\n\t\trec->dir.MdDat = mtime;\n\t\trec->dir.BkDat = 0;\n\t\trec->dir.UsrInfo.frView = cpu_to_be16(0xff);\n\t\treturn sizeof(struct hfs_cat_dir);\n\t} else {\n\t\t \n\t\trec->type = HFS_CDR_FIL;\n\t\trec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;\n\t\tif (!(inode->i_mode & S_IWUSR))\n\t\t\trec->file.Flags |= HFS_FIL_LOCK;\n\t\trec->file.FlNum = cpu_to_be32(cnid);\n\t\trec->file.CrDat = mtime;\n\t\trec->file.MdDat = mtime;\n\t\trec->file.BkDat = 0;\n\t\trec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;\n\t\trec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;\n\t\treturn sizeof(struct hfs_cat_file);\n\t}\n}\n\nstatic int hfs_cat_build_thread(struct super_block *sb,\n\t\t\t\thfs_cat_rec *rec, int type,\n\t\t\t\tu32 parentid, const struct qstr *name)\n{\n\trec->type = type;\n\tmemset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));\n\trec->thread.ParID = cpu_to_be32(parentid);\n\thfs_asc2mac(sb, &rec->thread.CName, name);\n\treturn sizeof(struct hfs_cat_thread);\n}\n\n \nint hfs_cat_create(u32 cnid, struct inode *dir, const struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = hfs_bmap_reserve(fd.tree, 2 * fd.tree->depth);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t \n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n\n \nint hfs_cat_keycmp(const btree_key *key1, const btree_key *key2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = key1->cat.ParID;\n\tk2p = key2->cat.ParID;\n\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfs_strcmp(key1->cat.CName.name, key1->cat.CName.len,\n\t\t\t  key2->cat.CName.name, key2->cat.CName.len);\n}\n\n \n\nint hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tif (len > HFS_NAMELEN) {\n\t\tpr_err(\"bad catalog namelength\\n\");\n\t\treturn -EIO;\n\t}\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}\n\n\n \nint hfs_cat_delete(u32 cnid, struct inode *dir, const struct qstr *str)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data fd;\n\tstruct hfs_readdir_data *rd;\n\tint res, type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\tsb = dir->i_sb;\n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);\n\tif (type == HFS_CDR_FIL) {\n\t\tstruct hfs_cat_file file;\n\t\thfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));\n\t\tif (be32_to_cpu(file.FlNum) == cnid) {\n#if 0\n\t\t\thfs_free_fork(sb, &file, HFS_FK_DATA);\n#endif\n\t\t\thfs_free_fork(sb, &file, HFS_FK_RSRC);\n\t\t}\n\t}\n\n\t \n\tspin_lock(&HFS_I(dir)->open_dir_lock);\n\tlist_for_each_entry(rd, &HFS_I(dir)->open_dir_list, list) {\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\tspin_unlock(&HFS_I(dir)->open_dir_lock);\n\n\tres = hfs_brec_remove(&fd);\n\tif (res)\n\t\tgoto out;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tres = hfs_brec_find(&fd);\n\tif (!res) {\n\t\tres = hfs_brec_remove(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tdir->i_size--;\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tmark_inode_dirty(dir);\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}\n\n \nint hfs_cat_move(u32 cnid, struct inode *src_dir, const struct qstr *src_name,\n\t\t struct inode *dst_dir, const struct qstr *dst_name)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t \n\terr = hfs_bmap_reserve(src_fd.tree, 2 * src_fd.tree->depth);\n\tif (err)\n\t\tgoto out;\n\n\t \n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t \n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = inode_set_ctime_current(dst_dir);\n\tmark_inode_dirty(dst_dir);\n\n\t \n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = inode_set_ctime_current(src_dir);\n\tmark_inode_dirty(src_dir);\n\n\ttype = entry.type;\n\tif (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))\n\t\tgoto out;\n\n\t \n\thfs_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t \n\thfs_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,\n\t\t\t\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}