{
  "module_name": "file.c",
  "hash_id": "817183ba4ca178d16094311a80b43dbd0af2d7db373e8eda05bf8366c386a38c",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/file.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/compat.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/falloc.h>\n#include <linux/swap.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/dlm.h>\n#include <linux/dlm_plock.h>\n#include <linux/delay.h>\n#include <linux/backing-dev.h>\n#include <linux/fileattr.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n\n \n\nstatic loff_t gfs2_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_holder i_gh;\n\tloff_t error;\n\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (!error) {\n\t\t\terror = generic_file_llseek(file, offset, whence);\n\t\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\t}\n\t\tbreak;\n\n\tcase SEEK_DATA:\n\t\terror = gfs2_seek_data(file, offset);\n\t\tbreak;\n\n\tcase SEEK_HOLE:\n\t\terror = gfs2_seek_hole(file, offset);\n\t\tbreak;\n\n\tcase SEEK_CUR:\n\tcase SEEK_SET:\n\t\t \n\t\terror = generic_file_llseek(file, offset, whence);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int gfs2_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file->f_mapping->host;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dir_read(dir, ctx, &file->f_ra);\n\n\tgfs2_glock_dq_uninit(&d_gh);\n\n\treturn error;\n}\n\n \nstatic struct {\n\tu32 fsflag;\n\tu32 gfsflag;\n} fsflag_gfs2flag[] = {\n\t{FS_SYNC_FL, GFS2_DIF_SYNC},\n\t{FS_IMMUTABLE_FL, GFS2_DIF_IMMUTABLE},\n\t{FS_APPEND_FL, GFS2_DIF_APPENDONLY},\n\t{FS_NOATIME_FL, GFS2_DIF_NOATIME},\n\t{FS_INDEX_FL, GFS2_DIF_EXHASH},\n\t{FS_TOPDIR_FL, GFS2_DIF_TOPDIR},\n\t{FS_JOURNAL_DATA_FL, GFS2_DIF_JDATA | GFS2_DIF_INHERIT_JDATA},\n};\n\nstatic inline u32 gfs2_gfsflags_to_fsflags(struct inode *inode, u32 gfsflags)\n{\n\tint i;\n\tu32 fsflags = 0;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tgfsflags &= ~GFS2_DIF_JDATA;\n\telse\n\t\tgfsflags &= ~GFS2_DIF_INHERIT_JDATA;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsflag_gfs2flag); i++)\n\t\tif (gfsflags & fsflag_gfs2flag[i].gfsflag)\n\t\t\tfsflags |= fsflag_gfs2flag[i].fsflag;\n\treturn fsflags;\n}\n\nint gfs2_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\tgoto out_uninit;\n\n\tfsflags = gfs2_gfsflags_to_fsflags(inode, ip->i_diskflags);\n\n\tfileattr_fill_flags(fa, fsflags);\n\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}\n\nvoid gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tflags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}\n\n \n#define GFS2_FLAGS_USER_SET (GFS2_DIF_JDATA|\t\t\t\\\n\t\t\t     GFS2_DIF_IMMUTABLE|\t\t\\\n\t\t\t     GFS2_DIF_APPENDONLY|\t\t\\\n\t\t\t     GFS2_DIF_NOATIME|\t\t\t\\\n\t\t\t     GFS2_DIF_SYNC|\t\t\t\\\n\t\t\t     GFS2_DIF_TOPDIR|\t\t\t\\\n\t\t\t     GFS2_DIF_INHERIT_JDATA)\n\n \nstatic int do_gfs2_set_flags(struct inode *inode, u32 reqflags, u32 mask)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 new_flags, flags;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tflags = ip->i_diskflags;\n\tnew_flags = (flags & ~mask) | (reqflags & mask);\n\tif ((new_flags ^ flags) == 0)\n\t\tgoto out;\n\n\tif (!IS_IMMUTABLE(inode)) {\n\t\terror = gfs2_permission(&nop_mnt_idmap, inode, MAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif ((flags ^ new_flags) & GFS2_DIF_JDATA) {\n\t\tif (new_flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_log_flush(sdp, ip->i_gl,\n\t\t\t\t       GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t\t       GFS2_LFC_SET_FLAGS);\n\t\terror = filemap_fdatawrite(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = filemap_fdatawait(inode->i_mapping);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tif (new_flags & GFS2_DIF_JDATA)\n\t\t\tgfs2_ordered_del_inode(ip);\n\t}\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\tgoto out;\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out_trans_end;\n\tinode_set_ctime_current(inode);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tip->i_diskflags = new_flags;\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\tgfs2_set_inode_flags(inode);\n\tgfs2_set_aops(inode);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}\n\nint gfs2_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tu32 fsflags = fa->flags, gfsflags = 0;\n\tu32 mask;\n\tint i;\n\n\tif (d_is_special(dentry))\n\t\treturn -ENOTTY;\n\n\tif (fileattr_has_fsx(fa))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsflag_gfs2flag); i++) {\n\t\tif (fsflags & fsflag_gfs2flag[i].fsflag) {\n\t\t\tfsflags &= ~fsflag_gfs2flag[i].fsflag;\n\t\t\tgfsflags |= fsflag_gfs2flag[i].gfsflag;\n\t\t}\n\t}\n\tif (fsflags || gfsflags & ~GFS2_FLAGS_USER_SET)\n\t\treturn -EINVAL;\n\n\tmask = GFS2_FLAGS_USER_SET;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tmask &= ~GFS2_DIF_JDATA;\n\t} else {\n\t\t \n\t\tif (gfsflags & GFS2_DIF_TOPDIR)\n\t\t\treturn -EINVAL;\n\t\tmask &= ~(GFS2_DIF_TOPDIR | GFS2_DIF_INHERIT_JDATA);\n\t}\n\n\treturn do_gfs2_set_flags(inode, gfsflags, mask);\n}\n\nstatic int gfs2_getlabel(struct file *filp, char __user *label)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (copy_to_user(label, sdp->sd_sb.sb_locktable, GFS2_LOCKNAME_LEN))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long gfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch(cmd) {\n\tcase FITRIM:\n\t\treturn gfs2_fitrim(filp, (void __user *)arg);\n\tcase FS_IOC_GETFSLABEL:\n\t\treturn gfs2_getlabel(filp, (char __user *)arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long gfs2_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch(cmd) {\n\t \n\tcase FITRIM:\n\tcase FS_IOC_GETFSLABEL:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn gfs2_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}\n#else\n#define gfs2_compat_ioctl NULL\n#endif\n\n \n\nstatic void gfs2_size_hint(struct file *filep, loff_t offset, size_t size)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t blks = (size + sdp->sd_sb.sb_bsize - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tint hint = min_t(size_t, INT_MAX, blks);\n\n\tif (hint > atomic_read(&ip->i_sizehint))\n\t\tatomic_set(&ip->i_sizehint, hint);\n}\n\n \nstatic int gfs2_allocate_page_backing(struct page *page, unsigned int length)\n{\n\tu64 pos = page_offset(page);\n\n\tdo {\n\t\tstruct iomap iomap = { };\n\n\t\tif (gfs2_iomap_alloc(page->mapping->host, pos, length, &iomap))\n\t\t\treturn -EIO;\n\n\t\tif (length < iomap.length)\n\t\t\tiomap.length = length;\n\t\tlength -= iomap.length;\n\t\tpos += iomap.length;\n\t} while (length > 0);\n\n\treturn 0;\n}\n\n \n\nstatic vm_fault_t gfs2_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tu64 offset = page_offset(page);\n\tunsigned int data_blocks, ind_blocks, rblocks;\n\tvm_fault_t ret = VM_FAULT_LOCKED;\n\tstruct gfs2_holder gh;\n\tunsigned int length;\n\tloff_t size;\n\tint err;\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\terr = gfs2_glock_nq(&gh);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_uninit;\n\t}\n\n\t \n\tsize = i_size_read(inode);\n\tif (offset >= size) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tfile_update_time(vmf->vma->vm_file);\n\n\t \n\tif (size - offset < PAGE_SIZE)\n\t\tlength = size - offset;\n\telse\n\t\tlength = PAGE_SIZE;\n\n\tgfs2_size_hint(vmf->vma->vm_file, offset, length);\n\n\tset_bit(GLF_DIRTY, &ip->i_gl->gl_flags);\n\tset_bit(GIF_SW_PAGED, &ip->i_flags);\n\n\t \n\n\tif (!gfs2_is_stuffed(ip) &&\n\t    !gfs2_write_alloc_required(ip, offset, length)) {\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page) || page->mapping != inode->i_mapping) {\n\t\t\tret = VM_FAULT_NOPAGE;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\terr = gfs2_rindex_update(sdp);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_unlock;\n\t}\n\n\tgfs2_write_calc_reserv(ip, length, &data_blocks, &ind_blocks);\n\tap.target = data_blocks + ind_blocks;\n\terr = gfs2_quota_lock_check(ip, &ap);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_unlock;\n\t}\n\terr = gfs2_inplace_reserve(ip, &ap);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_quota_unlock;\n\t}\n\n\trblocks = RES_DINODE + ind_blocks;\n\tif (gfs2_is_jdata(ip))\n\t\trblocks += data_blocks ? data_blocks : 1;\n\tif (ind_blocks || data_blocks) {\n\t\trblocks += RES_STATFS + RES_QUOTA;\n\t\trblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t}\n\terr = gfs2_trans_begin(sdp, rblocks, 0);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_trans_fail;\n\t}\n\n\t \n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip);\n\t\tif (err) {\n\t\t\tret = vmf_fs_error(err);\n\t\t\tgoto out_trans_end;\n\t\t}\n\t}\n\n\tlock_page(page);\n\t \n\tif (!PageUptodate(page) || page->mapping != inode->i_mapping) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out_page_locked;\n\t}\n\n\terr = gfs2_allocate_page_backing(page, length);\n\tif (err)\n\t\tret = vmf_fs_error(err);\n\nout_page_locked:\n\tif (ret != VM_FAULT_LOCKED)\n\t\tunlock_page(page);\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_quota_unlock:\n\tgfs2_quota_unlock(ip);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tif (ret == VM_FAULT_LOCKED) {\n\t\tset_page_dirty(page);\n\t\twait_for_stable_page(page);\n\t}\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nstatic vm_fault_t gfs2_fault(struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tvm_fault_t ret;\n\tint err;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terr = gfs2_glock_nq(&gh);\n\tif (err) {\n\t\tret = vmf_fs_error(err);\n\t\tgoto out_uninit;\n\t}\n\tret = filemap_fault(vmf);\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct gfs2_vm_ops = {\n\t.fault = gfs2_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = gfs2_page_mkwrite,\n};\n\n \n\nstatic int gfs2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\n\tif (!(file->f_flags & O_NOATIME) &&\n\t    !IS_NOATIME(&ip->i_inode)) {\n\t\tstruct gfs2_holder i_gh;\n\t\tint error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tfile_accessed(file);\n\t}\n\tvma->vm_ops = &gfs2_vm_ops;\n\n\treturn 0;\n}\n\n \n\nint gfs2_open_common(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_file *fp;\n\tint ret;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tret = generic_file_open(inode, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!gfs2_is_jdata(GFS2_I(inode)))\n\t\t\tfile->f_mode |= FMODE_CAN_ODIRECT;\n\t}\n\n\tfp = kzalloc(sizeof(struct gfs2_file), GFP_NOFS);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fp->f_fl_mutex);\n\n\tgfs2_assert_warn(GFS2_SB(inode), !file->private_data);\n\tfile->private_data = fp;\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = gfs2_qa_get(GFS2_I(inode));\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail:\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn ret;\n}\n\n \n\nstatic int gfs2_open(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\tbool need_unlock = false;\n\n\tif (S_ISREG(ip->i_inode.i_mode)) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY,\n\t\t\t\t\t   &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tneed_unlock = true;\n\t}\n\n\terror = gfs2_open_common(inode, file);\n\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}\n\n \n\nstatic int gfs2_release(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (gfs2_rs_active(&ip->i_res))\n\t\t\tgfs2_rs_delete(ip);\n\t\tgfs2_qa_put(ip);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int gfs2_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tint sync_state = inode->i_state & I_DIRTY;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret = 0, ret1 = 0;\n\n\tif (mapping->nrpages) {\n\t\tret1 = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (ret1 == -EIO)\n\t\t\treturn ret1;\n\t}\n\n\tif (!gfs2_is_jdata(ip))\n\t\tsync_state &= ~I_DIRTY_PAGES;\n\tif (datasync)\n\t\tsync_state &= ~I_DIRTY_SYNC;\n\n\tif (sync_state) {\n\t\tret = sync_inode_metadata(inode, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tret = file_write_and_wait(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgfs2_ail_flush(ip->i_gl, 1);\n\t}\n\n\tif (mapping->nrpages)\n\t\tret = file_fdatawait_range(file, start, end);\n\n\treturn ret ? ret : ret1;\n}\n\nstatic inline bool should_fault_in_pages(struct iov_iter *i,\n\t\t\t\t\t struct kiocb *iocb,\n\t\t\t\t\t size_t *prev_count,\n\t\t\t\t\t size_t *window_size)\n{\n\tsize_t count = iov_iter_count(i);\n\tsize_t size, offs;\n\n\tif (!count)\n\t\treturn false;\n\tif (!user_backed_iter(i))\n\t\treturn false;\n\n\t \n\tsize = PAGE_SIZE;\n\toffs = offset_in_page(iocb->ki_pos);\n\tif (*prev_count != count) {\n\t\tsize_t nr_dirtied;\n\n\t\tnr_dirtied = max(current->nr_dirtied_pause -\n\t\t\t\t current->nr_dirtied, 8);\n\t\tsize = min_t(size_t, SZ_1M, nr_dirtied << PAGE_SHIFT);\n\t}\n\n\t*prev_count = count;\n\t*window_size = size - offs;\n\treturn true;\n}\n\nstatic ssize_t gfs2_file_direct_read(struct kiocb *iocb, struct iov_iter *to,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tsize_t prev_count = 0, window_size = 0;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\t \n\n\tif (!iov_iter_count(to))\n\t\treturn 0;  \n\n\tgfs2_holder_init(ip->i_gl, LM_ST_DEFERRED, 0, gh);\nretry:\n\tret = gfs2_glock_nq(gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\tpagefault_disable();\n\tto->nofault = true;\n\tret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL,\n\t\t\t   IOMAP_DIO_PARTIAL, NULL, read);\n\tto->nofault = false;\n\tpagefault_enable();\n\tif (ret <= 0 && ret != -EFAULT)\n\t\tgoto out_unlock;\n\t \n\tif (ret > 0)\n\t\tread = ret;\n\n\tif (should_fault_in_pages(to, iocb, &prev_count, &window_size)) {\n\t\tgfs2_glock_dq(gh);\n\t\twindow_size -= fault_in_iov_iter_writeable(to, window_size);\n\t\tif (window_size)\n\t\t\tgoto retry;\n\t}\nout_unlock:\n\tif (gfs2_holder_queued(gh))\n\t\tgfs2_glock_dq(gh);\nout_uninit:\n\tgfs2_holder_uninit(gh);\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\treturn read;\n}\n\nstatic ssize_t gfs2_file_direct_write(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t\t      struct gfs2_holder *gh)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tsize_t prev_count = 0, window_size = 0;\n\tsize_t written = 0;\n\tbool enough_retries;\n\tssize_t ret;\n\n\t \n\n\t \n\tgfs2_holder_init(ip->i_gl, LM_ST_DEFERRED, 0, gh);\nretry:\n\tret = gfs2_glock_nq(gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\t \n\tif (iocb->ki_pos + iov_iter_count(from) > i_size_read(&ip->i_inode))\n\t\tgoto out_unlock;\n\n\tfrom->nofault = true;\n\tret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL,\n\t\t\t   IOMAP_DIO_PARTIAL, NULL, written);\n\tfrom->nofault = false;\n\tif (ret <= 0) {\n\t\tif (ret == -ENOTBLK)\n\t\t\tret = 0;\n\t\tif (ret != -EFAULT)\n\t\t\tgoto out_unlock;\n\t}\n\t \n\tif (ret > 0)\n\t\twritten = ret;\n\n\tenough_retries = prev_count == iov_iter_count(from) &&\n\t\t\t window_size <= PAGE_SIZE;\n\tif (should_fault_in_pages(from, iocb, &prev_count, &window_size)) {\n\t\tgfs2_glock_dq(gh);\n\t\twindow_size -= fault_in_iov_iter_readable(from, window_size);\n\t\tif (window_size) {\n\t\t\tif (!enough_retries)\n\t\t\t\tgoto retry;\n\t\t\t \n\t\t\tret = 0;\n\t\t}\n\t}\nout_unlock:\n\tif (gfs2_holder_queued(gh))\n\t\tgfs2_glock_dq(gh);\nout_uninit:\n\tgfs2_holder_uninit(gh);\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\treturn written;\n}\n\nstatic ssize_t gfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder gh;\n\tsize_t prev_count = 0, window_size = 0;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\t \n\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn gfs2_file_direct_read(iocb, to, &gh);\n\n\tpagefault_disable();\n\tiocb->ki_flags |= IOCB_NOIO;\n\tret = generic_file_read_iter(iocb, to);\n\tiocb->ki_flags &= ~IOCB_NOIO;\n\tpagefault_enable();\n\tif (ret >= 0) {\n\t\tif (!iov_iter_count(to))\n\t\t\treturn ret;\n\t\tread = ret;\n\t} else if (ret != -EFAULT) {\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\treturn ret;\n\t}\n\tip = GFS2_I(iocb->ki_filp->f_mapping->host);\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\nretry:\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\tpagefault_disable();\n\tret = generic_file_read_iter(iocb, to);\n\tpagefault_enable();\n\tif (ret <= 0 && ret != -EFAULT)\n\t\tgoto out_unlock;\n\tif (ret > 0)\n\t\tread += ret;\n\n\tif (should_fault_in_pages(to, iocb, &prev_count, &window_size)) {\n\t\tgfs2_glock_dq(&gh);\n\t\twindow_size -= fault_in_iov_iter_writeable(to, window_size);\n\t\tif (window_size)\n\t\t\tgoto retry;\n\t}\nout_unlock:\n\tif (gfs2_holder_queued(&gh))\n\t\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\treturn read ? read : ret;\n}\n\nstatic ssize_t gfs2_file_buffered_write(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from,\n\t\t\t\t\tstruct gfs2_holder *gh)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_holder *statfs_gh = NULL;\n\tsize_t prev_count = 0, window_size = 0;\n\tsize_t orig_count = iov_iter_count(from);\n\tsize_t written = 0;\n\tssize_t ret;\n\n\t \n\n\tif (inode == sdp->sd_rindex) {\n\t\tstatfs_gh = kmalloc(sizeof(*statfs_gh), GFP_NOFS);\n\t\tif (!statfs_gh)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, gh);\n\tif (should_fault_in_pages(from, iocb, &prev_count, &window_size)) {\nretry:\n\t\twindow_size -= fault_in_iov_iter_readable(from, window_size);\n\t\tif (!window_size) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_uninit;\n\t\t}\n\t\tfrom->count = min(from->count, window_size);\n\t}\n\tret = gfs2_glock_nq(gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tif (inode == sdp->sd_rindex) {\n\t\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\n\t\tret = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t GL_NOCACHE, statfs_gh);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tpagefault_disable();\n\tret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);\n\tpagefault_enable();\n\tif (ret > 0)\n\t\twritten += ret;\n\n\tif (inode == sdp->sd_rindex)\n\t\tgfs2_glock_dq_uninit(statfs_gh);\n\n\tif (ret <= 0 && ret != -EFAULT)\n\t\tgoto out_unlock;\n\n\tfrom->count = orig_count - written;\n\tif (should_fault_in_pages(from, iocb, &prev_count, &window_size)) {\n\t\tgfs2_glock_dq(gh);\n\t\tgoto retry;\n\t}\nout_unlock:\n\tif (gfs2_holder_queued(gh))\n\t\tgfs2_glock_dq(gh);\nout_uninit:\n\tgfs2_holder_uninit(gh);\n\tkfree(statfs_gh);\n\tfrom->count = orig_count - written;\n\treturn written ? written : ret;\n}\n\n \n\nstatic ssize_t gfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tssize_t ret;\n\n\tgfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));\n\n\tif (iocb->ki_flags & IOCB_APPEND) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgfs2_glock_dq_uninit(&gh);\n\t}\n\n\tinode_lock(inode);\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out_unlock;\n\n\tret = file_remove_privs(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = file_update_time(file);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\tssize_t buffered, ret2;\n\n\t\tret = gfs2_file_direct_write(iocb, from, &gh);\n\t\tif (ret < 0 || !iov_iter_count(from))\n\t\t\tgoto out_unlock;\n\n\t\tiocb->ki_flags |= IOCB_DSYNC;\n\t\tbuffered = gfs2_file_buffered_write(iocb, from, &gh);\n\t\tif (unlikely(buffered <= 0)) {\n\t\t\tif (!ret)\n\t\t\t\tret = buffered;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tret2 = generic_write_sync(iocb, buffered);\n\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t(iocb->ki_pos - buffered) >> PAGE_SHIFT,\n\t\t\t\t(iocb->ki_pos - 1) >> PAGE_SHIFT);\n\t\tif (!ret || ret2 > 0)\n\t\t\tret += ret2;\n\t} else {\n\t\tret = gfs2_file_buffered_write(iocb, from, &gh);\n\t\tif (likely(ret > 0))\n\t\t\tret = generic_write_sync(iocb, ret);\n\t}\n\nout_unlock:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\nstatic int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tloff_t end = offset + len;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (offset < end) {\n\t\tstruct iomap iomap = { };\n\n\t\terror = gfs2_iomap_alloc(inode, offset, end - offset, &iomap);\n\t\tif (error)\n\t\t\tgoto out;\n\t\toffset = iomap.offset + iomap.length;\n\t\tif (!(iomap.flags & IOMAP_F_NEW))\n\t\t\tcontinue;\n\t\terror = sb_issue_zeroout(sb, iomap.addr >> inode->i_blkbits,\n\t\t\t\t\t iomap.length >> inode->i_blkbits,\n\t\t\t\t\t GFP_NOFS);\n\t\tif (error) {\n\t\t\tfs_err(GFS2_SB(inode), \"Failed to zero data buffers\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrelse(dibh);\n\treturn error;\n}\n\n \nstatic void calc_max_reserv(struct gfs2_inode *ip, loff_t *len,\n\t\t\t    unsigned int *data_blocks, unsigned int *ind_blocks,\n\t\t\t    unsigned int max_blocks)\n{\n\tloff_t max = *len;\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = max_data; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\tmax_data -= tmp;\n\t}\n\n\t*data_blocks = max_data;\n\t*ind_blocks = max_blocks - max_data;\n\t*len = ((loff_t)max_data - 3) << sdp->sd_sb.sb_bsize_shift;\n\tif (*len > max) {\n\t\t*len = max;\n\t\tgfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);\n\t}\n}\n\nstatic long __gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes, max_blks;\n\tint error;\n\tconst loff_t pos = offset;\n\tconst loff_t count = len;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_size_hint(file, offset, len);\n\n\tgfs2_write_calc_reserv(ip, PAGE_SIZE, &data_blocks, &ind_blocks);\n\tap.min_target = data_blocks + ind_blocks;\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tif (!gfs2_write_alloc_required(ip, offset, bytes)) {\n\t\t\tlen -= bytes;\n\t\t\toffset += bytes;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmax_bytes = (len > max_chunk_size) ? max_chunk_size : len;\n\n\t\t \n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\t\tap.target = data_blocks + ind_blocks;\n\n\t\terror = gfs2_quota_lock_check(ip, &ap);\n\t\tif (error)\n\t\t\treturn error;\n\t\t \n\t\tmax_blks = UINT_MAX;\n\t\tif (ap.allowed)\n\t\t\tmax_blks = ap.allowed;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_qunlock;\n\n\t\t \n\t\tif (ip->i_res.rs_reserved < max_blks)\n\t\t\tmax_blks = ip->i_res.rs_reserved;\n\n\t\t \n\t\tcalc_max_reserv(ip, &max_bytes, &data_blocks,\n\t\t\t\t&ind_blocks, max_blks);\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_SIZE >> inode->i_blkbits);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) && (pos + count) > inode->i_size)\n\t\ti_size_write(inode, pos + count);\n\tfile_update_time(file);\n\tmark_inode_dirty(inode);\n\n\tif ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))\n\t\treturn vfs_fsync_range(file, pos, pos + count - 1,\n\t\t\t       (file->f_flags & __O_SYNC) ? 0 : 1);\n\treturn 0;\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}\n\nstatic long gfs2_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tif (mode & ~(FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (gfs2_is_jdata(ip) && inode != sdp->sd_rindex)\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (ret)\n\t\tgoto out_uninit;\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t    (offset + len) > inode->i_size) {\n\t\tret = inode_newsize_ok(inode, offset + len);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = get_write_access(inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tret = __gfs2_punch_hole(file, offset, len);\n\t} else {\n\t\tret = __gfs2_fallocate(file, mode, offset, len);\n\t\tif (ret)\n\t\t\tgfs2_rs_deltree(&ip->i_res);\n\t}\n\n\tput_write_access(inode);\nout_unlock:\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tinode_unlock(inode);\n\treturn ret;\n}\n\nstatic ssize_t gfs2_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t      struct file *out, loff_t *ppos,\n\t\t\t\t      size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tgfs2_size_hint(out, *ppos, len);\n\n\tret = iter_file_splice_write(pipe, out, ppos, len, flags);\n\treturn ret;\n}\n\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\n \n\nstatic int gfs2_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_inode *ip = GFS2_I(file->f_mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(file->f_mapping->host);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\tif (unlikely(gfs2_withdrawn(sdp))) {\n\t\tif (fl->fl_type == F_UNLCK)\n\t\t\tlocks_lock_file_wait(file, fl);\n\t\treturn -EIO;\n\t}\n\tif (cmd == F_CANCELLK)\n\t\treturn dlm_posix_cancel(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse if (IS_GETLK(cmd))\n\t\treturn dlm_posix_get(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse if (fl->fl_type == F_UNLCK)\n\t\treturn dlm_posix_unlock(ls->ls_dlm, ip->i_no_addr, file, fl);\n\telse\n\t\treturn dlm_posix_lock(ls->ls_dlm, ip->i_no_addr, file, cmd, fl);\n}\n\nstatic void __flock_holder_uninit(struct file *file, struct gfs2_holder *fl_gh)\n{\n\tstruct gfs2_glock *gl = gfs2_glock_hold(fl_gh->gh_gl);\n\n\t \n\n\tspin_lock(&file->f_lock);\n\tgfs2_holder_uninit(fl_gh);\n\tspin_unlock(&file->f_lock);\n\tgfs2_glock_put(gl);\n}\n\nstatic int do_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct gfs2_inode *ip = GFS2_I(file_inode(file));\n\tstruct gfs2_glock *gl;\n\tunsigned int state;\n\tu16 flags;\n\tint error = 0;\n\tint sleeptime;\n\n\tstate = (fl->fl_type == F_WRLCK) ? LM_ST_EXCLUSIVE : LM_ST_SHARED;\n\tflags = GL_EXACT | GL_NOPID;\n\tif (!IS_SETLKW(cmd))\n\t\tflags |= LM_FLAG_TRY_1CB;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\n\tif (gfs2_holder_initialized(fl_gh)) {\n\t\tstruct file_lock request;\n\t\tif (fl_gh->gh_state == state)\n\t\t\tgoto out;\n\t\tlocks_init_lock(&request);\n\t\trequest.fl_type = F_UNLCK;\n\t\trequest.fl_flags = FL_FLOCK;\n\t\tlocks_lock_file_wait(file, &request);\n\t\tgfs2_glock_dq(fl_gh);\n\t\tgfs2_holder_reinit(state, flags, fl_gh);\n\t} else {\n\t\terror = gfs2_glock_get(GFS2_SB(&ip->i_inode), ip->i_no_addr,\n\t\t\t\t       &gfs2_flock_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tspin_lock(&file->f_lock);\n\t\tgfs2_holder_init(gl, state, flags, fl_gh);\n\t\tspin_unlock(&file->f_lock);\n\t\tgfs2_glock_put(gl);\n\t}\n\tfor (sleeptime = 1; sleeptime <= 4; sleeptime <<= 1) {\n\t\terror = gfs2_glock_nq(fl_gh);\n\t\tif (error != GLR_TRYFAILED)\n\t\t\tbreak;\n\t\tfl_gh->gh_flags &= ~LM_FLAG_TRY_1CB;\n\t\tfl_gh->gh_flags |= LM_FLAG_TRY;\n\t\tmsleep(sleeptime);\n\t}\n\tif (error) {\n\t\t__flock_holder_uninit(file, fl_gh);\n\t\tif (error == GLR_TRYFAILED)\n\t\t\terror = -EAGAIN;\n\t} else {\n\t\terror = locks_lock_file_wait(file, fl);\n\t\tgfs2_assert_warn(GFS2_SB(&ip->i_inode), !error);\n\t}\n\nout:\n\tmutex_unlock(&fp->f_fl_mutex);\n\treturn error;\n}\n\nstatic void do_unflock(struct file *file, struct file_lock *fl)\n{\n\tstruct gfs2_file *fp = file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\n\tmutex_lock(&fp->f_fl_mutex);\n\tlocks_lock_file_wait(file, fl);\n\tif (gfs2_holder_initialized(fl_gh)) {\n\t\tgfs2_glock_dq(fl_gh);\n\t\t__flock_holder_uninit(file, fl_gh);\n\t}\n\tmutex_unlock(&fp->f_fl_mutex);\n}\n\n \n\nstatic int gfs2_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\tif (fl->fl_type == F_UNLCK) {\n\t\tdo_unflock(file, fl);\n\t\treturn 0;\n\t} else {\n\t\treturn do_flock(file, cmd, fl);\n\t}\n}\n\nconst struct file_operations gfs2_file_fops = {\n\t.llseek\t\t= gfs2_llseek,\n\t.read_iter\t= gfs2_file_read_iter,\n\t.write_iter\t= gfs2_file_write_iter,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.unlocked_ioctl\t= gfs2_ioctl,\n\t.compat_ioctl\t= gfs2_compat_ioctl,\n\t.mmap\t\t= gfs2_mmap,\n\t.open\t\t= gfs2_open,\n\t.release\t= gfs2_release,\n\t.fsync\t\t= gfs2_fsync,\n\t.lock\t\t= gfs2_lock,\n\t.flock\t\t= gfs2_flock,\n\t.splice_read\t= copy_splice_read,\n\t.splice_write\t= gfs2_file_splice_write,\n\t.setlease\t= simple_nosetlease,\n\t.fallocate\t= gfs2_fallocate,\n};\n\nconst struct file_operations gfs2_dir_fops = {\n\t.iterate_shared\t= gfs2_readdir,\n\t.unlocked_ioctl\t= gfs2_ioctl,\n\t.compat_ioctl\t= gfs2_compat_ioctl,\n\t.open\t\t= gfs2_open,\n\t.release\t= gfs2_release,\n\t.fsync\t\t= gfs2_fsync,\n\t.lock\t\t= gfs2_lock,\n\t.flock\t\t= gfs2_flock,\n\t.llseek\t\t= default_llseek,\n};\n\n#endif  \n\nconst struct file_operations gfs2_file_fops_nolock = {\n\t.llseek\t\t= gfs2_llseek,\n\t.read_iter\t= gfs2_file_read_iter,\n\t.write_iter\t= gfs2_file_write_iter,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.unlocked_ioctl\t= gfs2_ioctl,\n\t.compat_ioctl\t= gfs2_compat_ioctl,\n\t.mmap\t\t= gfs2_mmap,\n\t.open\t\t= gfs2_open,\n\t.release\t= gfs2_release,\n\t.fsync\t\t= gfs2_fsync,\n\t.splice_read\t= copy_splice_read,\n\t.splice_write\t= gfs2_file_splice_write,\n\t.setlease\t= generic_setlease,\n\t.fallocate\t= gfs2_fallocate,\n};\n\nconst struct file_operations gfs2_dir_fops_nolock = {\n\t.iterate_shared\t= gfs2_readdir,\n\t.unlocked_ioctl\t= gfs2_ioctl,\n\t.compat_ioctl\t= gfs2_compat_ioctl,\n\t.open\t\t= gfs2_open,\n\t.release\t= gfs2_release,\n\t.fsync\t\t= gfs2_fsync,\n\t.llseek\t\t= default_llseek,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}