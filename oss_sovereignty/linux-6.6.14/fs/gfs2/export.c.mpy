{
  "module_name": "export.c",
  "hash_id": "6895ad467f6458ef71c740af64d9d241c1a7bf3fc415618b033e635a40dd6647",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/export.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"dir.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"util.h\"\n\n#define GFS2_SMALL_FH_SIZE 4\n#define GFS2_LARGE_FH_SIZE 8\n#define GFS2_OLD_FH_SIZE 10\n\nstatic int gfs2_encode_fh(struct inode *inode, __u32 *p, int *len,\n\t\t\t  struct inode *parent)\n{\n\t__be32 *fh = (__force __be32 *)p;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (parent && (*len < GFS2_LARGE_FH_SIZE)) {\n\t\t*len = GFS2_LARGE_FH_SIZE;\n\t\treturn FILEID_INVALID;\n\t} else if (*len < GFS2_SMALL_FH_SIZE) {\n\t\t*len = GFS2_SMALL_FH_SIZE;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tfh[0] = cpu_to_be32(ip->i_no_formal_ino >> 32);\n\tfh[1] = cpu_to_be32(ip->i_no_formal_ino & 0xFFFFFFFF);\n\tfh[2] = cpu_to_be32(ip->i_no_addr >> 32);\n\tfh[3] = cpu_to_be32(ip->i_no_addr & 0xFFFFFFFF);\n\t*len = GFS2_SMALL_FH_SIZE;\n\n\tif (!parent || inode == d_inode(sb->s_root))\n\t\treturn *len;\n\n\tip = GFS2_I(parent);\n\n\tfh[4] = cpu_to_be32(ip->i_no_formal_ino >> 32);\n\tfh[5] = cpu_to_be32(ip->i_no_formal_ino & 0xFFFFFFFF);\n\tfh[6] = cpu_to_be32(ip->i_no_addr >> 32);\n\tfh[7] = cpu_to_be32(ip->i_no_addr & 0xFFFFFFFF);\n\t*len = GFS2_LARGE_FH_SIZE;\n\n\treturn *len;\n}\n\nstruct get_name_filldir {\n\tstruct dir_context ctx;\n\tstruct gfs2_inum_host inum;\n\tchar *name;\n};\n\nstatic bool get_name_filldir(struct dir_context *ctx, const char *name,\n\t\t\t    int length, loff_t offset, u64 inum,\n\t\t\t    unsigned int type)\n{\n\tstruct get_name_filldir *gnfd =\n\t\tcontainer_of(ctx, struct get_name_filldir, ctx);\n\n\tif (inum != gnfd->inum.no_addr)\n\t\treturn true;\n\n\tmemcpy(gnfd->name, name, length);\n\tgnfd->name[length] = 0;\n\n\treturn false;\n}\n\nstatic int gfs2_get_name(struct dentry *parent, char *name,\n\t\t\t struct dentry *child)\n{\n\tstruct inode *dir = d_inode(parent);\n\tstruct inode *inode = d_inode(child);\n\tstruct gfs2_inode *dip, *ip;\n\tstruct get_name_filldir gnfd = {\n\t\t.ctx.actor = get_name_filldir,\n\t\t.name = name\n\t};\n\tstruct gfs2_holder gh;\n\tint error;\n\tstruct file_ra_state f_ra = { .start = 0 };\n\n\tif (!dir)\n\t\treturn -EINVAL;\n\n\tif (!S_ISDIR(dir->i_mode) || !inode)\n\t\treturn -EINVAL;\n\n\tdip = GFS2_I(dir);\n\tip = GFS2_I(inode);\n\n\t*name = 0;\n\tgnfd.inum.no_addr = ip->i_no_addr;\n\tgnfd.inum.no_formal_ino = ip->i_no_formal_ino;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dir_read(dir, &gnfd.ctx, &f_ra);\n\n\tgfs2_glock_dq_uninit(&gh);\n\n\tif (!error && !*name)\n\t\terror = -ENOENT;\n\n\treturn error;\n}\n\nstatic struct dentry *gfs2_get_parent(struct dentry *child)\n{\n\treturn d_obtain_alias(gfs2_lookupi(d_inode(child), &gfs2_qdotdot, 1));\n}\n\nstatic struct dentry *gfs2_get_dentry(struct super_block *sb,\n\t\t\t\t      struct gfs2_inum_host *inum)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct inode *inode;\n\n\tif (!inum->no_formal_ino)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = gfs2_lookup_by_inum(sdp, inum->no_addr, inum->no_formal_ino,\n\t\t\t\t    GFS2_BLKST_DINODE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\treturn d_obtain_alias(inode);\n}\n\nstatic struct dentry *gfs2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\tstruct gfs2_inum_host this;\n\t__be32 *fh = (__force __be32 *)fid->raw;\n\n\tswitch (fh_type) {\n\tcase GFS2_SMALL_FH_SIZE:\n\tcase GFS2_LARGE_FH_SIZE:\n\tcase GFS2_OLD_FH_SIZE:\n\t\tif (fh_len < GFS2_SMALL_FH_SIZE)\n\t\t\treturn NULL;\n\t\tthis.no_formal_ino = ((u64)be32_to_cpu(fh[0])) << 32;\n\t\tthis.no_formal_ino |= be32_to_cpu(fh[1]);\n\t\tthis.no_addr = ((u64)be32_to_cpu(fh[2])) << 32;\n\t\tthis.no_addr |= be32_to_cpu(fh[3]);\n\t\treturn gfs2_get_dentry(sb, &this);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic struct dentry *gfs2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\tstruct gfs2_inum_host parent;\n\t__be32 *fh = (__force __be32 *)fid->raw;\n\n\tswitch (fh_type) {\n\tcase GFS2_LARGE_FH_SIZE:\n\tcase GFS2_OLD_FH_SIZE:\n\t\tif (fh_len < GFS2_LARGE_FH_SIZE)\n\t\t\treturn NULL;\n\t\tparent.no_formal_ino = ((u64)be32_to_cpu(fh[4])) << 32;\n\t\tparent.no_formal_ino |= be32_to_cpu(fh[5]);\n\t\tparent.no_addr = ((u64)be32_to_cpu(fh[6])) << 32;\n\t\tparent.no_addr |= be32_to_cpu(fh[7]);\n\t\treturn gfs2_get_dentry(sb, &parent);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nconst struct export_operations gfs2_export_ops = {\n\t.encode_fh = gfs2_encode_fh,\n\t.fh_to_dentry = gfs2_fh_to_dentry,\n\t.fh_to_parent = gfs2_fh_to_parent,\n\t.get_name = gfs2_get_name,\n\t.get_parent = gfs2_get_parent,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}