{
  "module_name": "bmap.c",
  "hash_id": "ceeccd368dea3f0926f125b00eb484f545d49739b529792a6d0377d7e760c7df",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/bmap.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/iomap.h>\n#include <linux/ktime.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"log.h\"\n#include \"super.h\"\n#include \"trans.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"aops.h\"\n#include \"trace_gfs2.h\"\n\n \nstruct metapath {\n\tstruct buffer_head *mp_bh[GFS2_MAX_META_HEIGHT];\n\t__u16 mp_list[GFS2_MAX_META_HEIGHT];\n\tint mp_fheight;  \n\tint mp_aheight;  \n};\n\nstatic int punch_hole(struct gfs2_inode *ip, u64 offset, u64 length);\n\n \n\nstatic int gfs2_unstuffer_page(struct gfs2_inode *ip, struct buffer_head *dibh,\n\t\t\t       u64 block, struct page *page)\n{\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (!PageUptodate(page)) {\n\t\tvoid *kaddr = kmap(page);\n\t\tu64 dsize = i_size_read(inode);\n \n\t\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\t\tmemset(kaddr + dsize, 0, PAGE_SIZE - dsize);\n\t\tkunmap(page);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tif (gfs2_is_jdata(ip)) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, BIT(inode->i_blkbits),\n\t\t\t\t\t     BIT(BH_Uptodate));\n\n\t\tbh = page_buffers(page);\n\t\tif (!buffer_mapped(bh))\n\t\t\tmap_bh(bh, inode->i_sb, block);\n\n\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t} else {\n\t\tset_page_dirty(page);\n\t\tgfs2_ordered_add_inode(ip);\n\t}\n\n\treturn 0;\n}\n\nstatic int __gfs2_unstuff_inode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t \n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_remove_revoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t \n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\n\treturn error;\n}\n\n \n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct page *page;\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\terror = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\terror = __gfs2_unstuff_inode(ip, page);\n\tunlock_page(page);\n\tput_page(page);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}\n\n \n\nstatic void find_metapath(const struct gfs2_sbd *sdp, u64 block,\n\t\t\t  struct metapath *mp, unsigned int height)\n{\n\tunsigned int i;\n\n\tmp->mp_fheight = height;\n\tfor (i = height; i--;)\n\t\tmp->mp_list[i] = do_div(block, sdp->sd_inptrs);\n}\n\nstatic inline unsigned int metapath_branch_start(const struct metapath *mp)\n{\n\tif (mp->mp_list[0] == 0)\n\t\treturn 2;\n\treturn 1;\n}\n\n \nstatic inline __be64 *metaptr1(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tif (height == 0)\n\t\treturn ((__be64 *)(bh->b_data + sizeof(struct gfs2_dinode)));\n\treturn ((__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header)));\n}\n\n \n\nstatic inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\t__be64 *p = metaptr1(height, mp);\n\treturn p + mp->mp_list[height];\n}\n\nstatic inline const __be64 *metaend(unsigned int height, const struct metapath *mp)\n{\n\tconst struct buffer_head *bh = mp->mp_bh[height];\n\treturn (const __be64 *)(bh->b_data + bh->b_size);\n}\n\nstatic void clone_metapath(struct metapath *clone, struct metapath *mp)\n{\n\tunsigned int hgt;\n\n\t*clone = *mp;\n\tfor (hgt = 0; hgt < mp->mp_aheight; hgt++)\n\t\tget_bh(clone->mp_bh[hgt]);\n}\n\nstatic void gfs2_metapath_ra(struct gfs2_glock *gl, __be64 *start, __be64 *end)\n{\n\tconst __be64 *t;\n\n\tfor (t = start; t < end; t++) {\n\t\tstruct buffer_head *rabh;\n\n\t\tif (!*t)\n\t\t\tcontinue;\n\n\t\trabh = gfs2_getbuf(gl, be64_to_cpu(*t), CREATE);\n\t\tif (trylock_buffer(rabh)) {\n\t\t\tif (!buffer_uptodate(rabh)) {\n\t\t\t\trabh->b_end_io = end_buffer_read_sync;\n\t\t\t\tsubmit_bh(REQ_OP_READ | REQ_RAHEAD | REQ_META |\n\t\t\t\t\t  REQ_PRIO, rabh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_buffer(rabh);\n\t\t}\n\t\tbrelse(rabh);\n\t}\n}\n\nstatic int __fillup_metapath(struct gfs2_inode *ip, struct metapath *mp,\n\t\t\t     unsigned int x, unsigned int h)\n{\n\tfor (; x < h; x++) {\n\t\t__be64 *ptr = metapointer(x, mp);\n\t\tu64 dblock = be64_to_cpu(*ptr);\n\t\tint ret;\n\n\t\tif (!dblock)\n\t\t\tbreak;\n\t\tret = gfs2_meta_buffer(ip, GFS2_METATYPE_IN, dblock, &mp->mp_bh[x + 1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tmp->mp_aheight = x + 1;\n\treturn 0;\n}\n\n \n\nstatic int lookup_metapath(struct gfs2_inode *ip, struct metapath *mp)\n{\n\treturn __fillup_metapath(ip, mp, 0, ip->i_height - 1);\n}\n\n \n\nstatic int fillup_metapath(struct gfs2_inode *ip, struct metapath *mp, int h)\n{\n\tunsigned int x = 0;\n\tint ret;\n\n\tif (h) {\n\t\t \n\t\tfor (x = h - 1; x > 0; x--) {\n\t\t\tif (mp->mp_bh[x])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = __fillup_metapath(ip, mp, x, h);\n\tif (ret)\n\t\treturn ret;\n\treturn mp->mp_aheight - x - 1;\n}\n\nstatic sector_t metapath_to_block(struct gfs2_sbd *sdp, struct metapath *mp)\n{\n\tsector_t factor = 1, block = 0;\n\tint hgt;\n\n\tfor (hgt = mp->mp_fheight - 1; hgt >= 0; hgt--) {\n\t\tif (hgt < mp->mp_aheight)\n\t\t\tblock += mp->mp_list[hgt] * factor;\n\t\tfactor *= sdp->sd_inptrs;\n\t}\n\treturn block;\n}\n\nstatic void release_metapath(struct metapath *mp)\n{\n\tint i;\n\n\tfor (i = 0; i < GFS2_MAX_META_HEIGHT; i++) {\n\t\tif (mp->mp_bh[i] == NULL)\n\t\t\tbreak;\n\t\tbrelse(mp->mp_bh[i]);\n\t\tmp->mp_bh[i] = NULL;\n\t}\n}\n\n \n\nstatic inline unsigned int gfs2_extent_length(struct buffer_head *bh, __be64 *ptr, size_t limit, int *eob)\n{\n\tconst __be64 *end = (__be64 *)(bh->b_data + bh->b_size);\n\tconst __be64 *first = ptr;\n\tu64 d = be64_to_cpu(*ptr);\n\n\t*eob = 0;\n\tdo {\n\t\tptr++;\n\t\tif (ptr >= end)\n\t\t\tbreak;\n\t\td++;\n\t} while(be64_to_cpu(*ptr) == d);\n\tif (ptr >= end)\n\t\t*eob = 1;\n\treturn ptr - first;\n}\n\nenum walker_status { WALK_STOP, WALK_FOLLOW, WALK_CONTINUE };\n\n \ntypedef enum walker_status (*gfs2_metadata_walker)(struct metapath *mp,\n\t\t\t\t\t\t   unsigned int ptrs);\n\n \n\nstatic int gfs2_walk_metadata(struct inode *inode, struct metapath *mp,\n\t\tu64 max_len, gfs2_metadata_walker walker)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 factor = 1;\n\tunsigned int hgt;\n\tint ret;\n\n\t \n\tfor (hgt = mp->mp_fheight - 1; hgt >= mp->mp_aheight; hgt--) {\n\t\tmax_len += mp->mp_list[hgt] * factor;\n\t\tmp->mp_list[hgt] = 0;\n\t\tfactor *= sdp->sd_inptrs;\n\t}\n\n\tfor (;;) {\n\t\tu16 start = mp->mp_list[hgt];\n\t\tenum walker_status status;\n\t\tunsigned int ptrs;\n\t\tu64 len;\n\n\t\t \n\t\tptrs = (hgt >= 1 ? sdp->sd_inptrs : sdp->sd_diptrs) - start;\n\t\tlen = ptrs * factor;\n\t\tif (len > max_len)\n\t\t\tptrs = DIV_ROUND_UP_ULL(max_len, factor);\n\t\tstatus = walker(mp, ptrs);\n\t\tswitch (status) {\n\t\tcase WALK_STOP:\n\t\t\treturn 1;\n\t\tcase WALK_FOLLOW:\n\t\t\tBUG_ON(mp->mp_aheight == mp->mp_fheight);\n\t\t\tptrs = mp->mp_list[hgt] - start;\n\t\t\tlen = ptrs * factor;\n\t\t\tbreak;\n\t\tcase WALK_CONTINUE:\n\t\t\tbreak;\n\t\t}\n\t\tif (len >= max_len)\n\t\t\tbreak;\n\t\tmax_len -= len;\n\t\tif (status == WALK_FOLLOW)\n\t\t\tgoto fill_up_metapath;\n\nlower_metapath:\n\t\t \n\t\tbrelse(mp->mp_bh[hgt]);\n\t\tmp->mp_bh[hgt] = NULL;\n\t\tmp->mp_list[hgt] = 0;\n\t\tif (!hgt)\n\t\t\tbreak;\n\t\thgt--;\n\t\tfactor *= sdp->sd_inptrs;\n\n\t\t \n\t\t(mp->mp_list[hgt])++;\n\t\tif (hgt) {\n\t\t\tif (mp->mp_list[hgt] >= sdp->sd_inptrs)\n\t\t\t\tgoto lower_metapath;\n\t\t} else {\n\t\t\tif (mp->mp_list[hgt] >= sdp->sd_diptrs)\n\t\t\t\tbreak;\n\t\t}\n\nfill_up_metapath:\n\t\t \n\t\tret = fillup_metapath(ip, mp, ip->i_height - 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\thgt += ret;\n\t\tfor (; ret; ret--)\n\t\t\tdo_div(factor, sdp->sd_inptrs);\n\t\tmp->mp_aheight = hgt + 1;\n\t}\n\treturn 0;\n}\n\nstatic enum walker_status gfs2_hole_walker(struct metapath *mp,\n\t\t\t\t\t   unsigned int ptrs)\n{\n\tconst __be64 *start, *ptr, *end;\n\tunsigned int hgt;\n\n\thgt = mp->mp_aheight - 1;\n\tstart = metapointer(hgt, mp);\n\tend = start + ptrs;\n\n\tfor (ptr = start; ptr < end; ptr++) {\n\t\tif (*ptr) {\n\t\t\tmp->mp_list[hgt] += ptr - start;\n\t\t\tif (mp->mp_aheight == mp->mp_fheight)\n\t\t\t\treturn WALK_STOP;\n\t\t\treturn WALK_FOLLOW;\n\t\t}\n\t}\n\treturn WALK_CONTINUE;\n}\n\n \nstatic int gfs2_hole_size(struct inode *inode, sector_t lblock, u64 len,\n\t\t\t  struct metapath *mp, struct iomap *iomap)\n{\n\tstruct metapath clone;\n\tu64 hole_size;\n\tint ret;\n\n\tclone_metapath(&clone, mp);\n\tret = gfs2_walk_metadata(inode, &clone, len, gfs2_hole_walker);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == 1)\n\t\thole_size = metapath_to_block(GFS2_SB(inode), &clone) - lblock;\n\telse\n\t\thole_size = len;\n\tiomap->length = hole_size << inode->i_blkbits;\n\tret = 0;\n\nout:\n\trelease_metapath(&clone);\n\treturn ret;\n}\n\nstatic inline void gfs2_indirect_init(struct metapath *mp,\n\t\t\t\t      struct gfs2_glock *gl, unsigned int i,\n\t\t\t\t      unsigned offset, u64 bn)\n{\n\t__be64 *ptr = (__be64 *)(mp->mp_bh[i - 1]->b_data +\n\t\t       ((i > 1) ? sizeof(struct gfs2_meta_header) :\n\t\t\t\t sizeof(struct gfs2_dinode)));\n\tBUG_ON(i < 1);\n\tBUG_ON(mp->mp_bh[i] != NULL);\n\tmp->mp_bh[i] = gfs2_meta_new(gl, bn);\n\tgfs2_trans_add_meta(gl, mp->mp_bh[i]);\n\tgfs2_metatype_set(mp->mp_bh[i], GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\tgfs2_buffer_clear_tail(mp->mp_bh[i], sizeof(struct gfs2_meta_header));\n\tptr += offset;\n\t*ptr = cpu_to_be64(bn);\n}\n\nenum alloc_state {\n\tALLOC_DATA = 0,\n\tALLOC_GROW_DEPTH = 1,\n\tALLOC_GROW_HEIGHT = 2,\n\t \n};\n\n \n\nstatic int __gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,\n\t\t\t      struct metapath *mp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tsize_t dblks = iomap->length >> inode->i_blkbits;\n\tconst unsigned end_of_metadata = mp->mp_fheight - 1;\n\tint ret;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(mp->mp_aheight < 1);\n\tBUG_ON(dibh == NULL);\n\tBUG_ON(dblks < 1);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tdown_write(&ip->i_rw_mutex);\n\n\tif (mp->mp_fheight == mp->mp_aheight) {\n\t\t \n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t \n\t\tif (mp->mp_fheight == ip->i_height) {\n\t\t\t \n\t\t\tiblks = mp->mp_fheight - mp->mp_aheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t \n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = mp->mp_fheight - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (mp->mp_fheight - branch_start);\n\t\t}\n\t}\n\n\t \n\n\tblks = dblks + iblks;\n\ti = mp->mp_aheight;\n\tdo {\n\t\tn = blks - alloced;\n\t\tret = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_remove_revoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t \n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < mp->mp_fheight - ip->i_height && n > 0;\n\t\t\t     i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == mp->mp_fheight - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < mp->mp_fheight; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t \n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < mp->mp_fheight)\n\t\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);\n\t\t\tfor (; i < mp->mp_fheight && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == mp->mp_fheight)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t \n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, mp->mp_bh[end_of_metadata]);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tiomap->addr = bn << inode->i_blkbits;\n\t\t\tiomap->flags |= IOMAP_F_MERGED | IOMAP_F_NEW;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tbreak;\n\t\t}\n\t} while (iomap->addr == IOMAP_NULL_ADDR);\n\n\tiomap->type = IOMAP_MAPPED;\n\tiomap->length = (u64)dblks << inode->i_blkbits;\n\tip->i_height = mp->mp_fheight;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, dibh->b_data);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn ret;\n}\n\n#define IOMAP_F_GFS2_BOUNDARY IOMAP_F_PRIVATE\n\n \nstatic u64 gfs2_alloc_size(struct inode *inode, struct metapath *mp, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst __be64 *first, *ptr, *end;\n\n\t \n\n\tif (gfs2_is_stuffed(ip) || mp->mp_fheight != mp->mp_aheight) {\n\t\tunsigned int maxsize = mp->mp_fheight > 1 ?\n\t\t\tsdp->sd_inptrs : sdp->sd_diptrs;\n\t\tmaxsize -= mp->mp_list[mp->mp_fheight - 1];\n\t\tif (size > maxsize)\n\t\t\tsize = maxsize;\n\t\treturn size;\n\t}\n\n\tfirst = metapointer(ip->i_height - 1, mp);\n\tend = metaend(ip->i_height - 1, mp);\n\tif (end - first > size)\n\t\tend = first + size;\n\tfor (ptr = first; ptr < end; ptr++) {\n\t\tif (*ptr)\n\t\t\tbreak;\n\t}\n\treturn ptr - first;\n}\n\n \nstatic int __gfs2_iomap_get(struct inode *inode, loff_t pos, loff_t length,\n\t\t\t    unsigned flags, struct iomap *iomap,\n\t\t\t    struct metapath *mp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t size = i_size_read(inode);\n\t__be64 *ptr;\n\tsector_t lblock;\n\tsector_t lblock_stop;\n\tint ret;\n\tint eob;\n\tu64 len;\n\tstruct buffer_head *dibh = NULL, *bh;\n\tu8 height;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\tdown_read(&ip->i_rw_mutex);\n\n\tret = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (ret)\n\t\tgoto unlock;\n\tmp->mp_bh[0] = dibh;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (flags & IOMAP_WRITE) {\n\t\t\tloff_t max_size = gfs2_max_stuffed_size(ip);\n\n\t\t\tif (pos + length > max_size)\n\t\t\t\tgoto unstuff;\n\t\t\tiomap->length = max_size;\n\t\t} else {\n\t\t\tif (pos >= size) {\n\t\t\t\tif (flags & IOMAP_REPORT) {\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t} else {\n\t\t\t\t\tiomap->offset = pos;\n\t\t\t\t\tiomap->length = length;\n\t\t\t\t\tgoto hole_found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tiomap->length = size;\n\t\t}\n\t\tiomap->addr = (ip->i_no_addr << inode->i_blkbits) +\n\t\t\t      sizeof(struct gfs2_dinode);\n\t\tiomap->type = IOMAP_INLINE;\n\t\tiomap->inline_data = dibh->b_data + sizeof(struct gfs2_dinode);\n\t\tgoto out;\n\t}\n\nunstuff:\n\tlblock = pos >> inode->i_blkbits;\n\tiomap->offset = lblock << inode->i_blkbits;\n\tlblock_stop = (pos + length - 1) >> inode->i_blkbits;\n\tlen = lblock_stop - lblock + 1;\n\tiomap->length = len << inode->i_blkbits;\n\n\theight = ip->i_height;\n\twhile ((lblock + 1) * sdp->sd_sb.sb_bsize > sdp->sd_heightsize[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, mp, height);\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\n\tret = lookup_metapath(ip, mp);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (mp->mp_aheight != ip->i_height)\n\t\tgoto do_alloc;\n\n\tptr = metapointer(ip->i_height - 1, mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\n\tbh = mp->mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh, ptr, len, &eob);\n\n\tiomap->addr = be64_to_cpu(*ptr) << inode->i_blkbits;\n\tiomap->length = len << inode->i_blkbits;\n\tiomap->type = IOMAP_MAPPED;\n\tiomap->flags |= IOMAP_F_MERGED;\n\tif (eob)\n\t\tiomap->flags |= IOMAP_F_GFS2_BOUNDARY;\n\nout:\n\tiomap->bdev = inode->i_sb->s_bdev;\nunlock:\n\tup_read(&ip->i_rw_mutex);\n\treturn ret;\n\ndo_alloc:\n\tif (flags & IOMAP_REPORT) {\n\t\tif (pos >= size)\n\t\t\tret = -ENOENT;\n\t\telse if (height == ip->i_height)\n\t\t\tret = gfs2_hole_size(inode, lblock, len, mp, iomap);\n\t\telse\n\t\t\tiomap->length = size - iomap->offset;\n\t} else if (flags & IOMAP_WRITE) {\n\t\tu64 alloc_size;\n\n\t\tif (flags & IOMAP_DIRECT)\n\t\t\tgoto out;   \n\n\t\tlen = gfs2_alloc_size(inode, mp, len);\n\t\talloc_size = len << inode->i_blkbits;\n\t\tif (alloc_size < iomap->length)\n\t\t\tiomap->length = alloc_size;\n\t} else {\n\t\tif (pos < size && height == ip->i_height)\n\t\t\tret = gfs2_hole_size(inode, lblock, len, mp, iomap);\n\t}\nhole_found:\n\tiomap->addr = IOMAP_NULL_ADDR;\n\tiomap->type = IOMAP_HOLE;\n\tgoto out;\n}\n\nstatic struct folio *\ngfs2_iomap_get_folio(struct iomap_iter *iter, loff_t pos, unsigned len)\n{\n\tstruct inode *inode = iter->inode;\n\tunsigned int blockmask = i_blocksize(inode) - 1;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int blocks;\n\tstruct folio *folio;\n\tint status;\n\n\tblocks = ((pos & blockmask) + len + blockmask) >> inode->i_blkbits;\n\tstatus = gfs2_trans_begin(sdp, RES_DINODE + blocks, 0);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tfolio = iomap_get_folio(iter, pos, len);\n\tif (IS_ERR(folio))\n\t\tgfs2_trans_end(sdp);\n\treturn folio;\n}\n\nstatic void gfs2_iomap_put_folio(struct inode *inode, loff_t pos,\n\t\t\t\t unsigned copied, struct folio *folio)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (!gfs2_is_stuffed(ip))\n\t\tgfs2_trans_add_databufs(ip, folio, offset_in_folio(folio, pos),\n\t\t\t\t\tcopied);\n\n\tfolio_unlock(folio);\n\tfolio_put(folio);\n\n\tif (tr->tr_num_buf_new)\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\n\tgfs2_trans_end(sdp);\n}\n\nstatic const struct iomap_folio_ops gfs2_iomap_folio_ops = {\n\t.get_folio = gfs2_iomap_get_folio,\n\t.put_folio = gfs2_iomap_put_folio,\n};\n\nstatic int gfs2_iomap_begin_write(struct inode *inode, loff_t pos,\n\t\t\t\t  loff_t length, unsigned flags,\n\t\t\t\t  struct iomap *iomap,\n\t\t\t\t  struct metapath *mp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tbool unstuff;\n\tint ret;\n\n\tunstuff = gfs2_is_stuffed(ip) &&\n\t\t  pos + length > gfs2_max_stuffed_size(ip);\n\n\tif (unstuff || iomap->type == IOMAP_HOLE) {\n\t\tunsigned int data_blocks, ind_blocks;\n\t\tstruct gfs2_alloc_parms ap = {};\n\t\tunsigned int rblocks;\n\t\tstruct gfs2_trans *tr;\n\n\t\tgfs2_write_calc_reserv(ip, iomap->length, &data_blocks,\n\t\t\t\t       &ind_blocks);\n\t\tap.target = data_blocks + ind_blocks;\n\t\tret = gfs2_quota_lock_check(ip, &ap);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = gfs2_inplace_reserve(ip, &ap);\n\t\tif (ret)\n\t\t\tgoto out_qunlock;\n\n\t\trblocks = RES_DINODE + ind_blocks;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks;\n\t\tif (ind_blocks || data_blocks)\n\t\t\trblocks += RES_STATFS + RES_QUOTA;\n\t\tif (inode == sdp->sd_rindex)\n\t\t\trblocks += 2 * RES_STATFS;\n\t\trblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);\n\n\t\tret = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t       iomap->length >> inode->i_blkbits);\n\t\tif (ret)\n\t\t\tgoto out_trans_fail;\n\n\t\tif (unstuff) {\n\t\t\tret = gfs2_unstuff_dinode(ip);\n\t\t\tif (ret)\n\t\t\t\tgoto out_trans_end;\n\t\t\trelease_metapath(mp);\n\t\t\tret = __gfs2_iomap_get(inode, iomap->offset,\n\t\t\t\t\t       iomap->length, flags, iomap, mp);\n\t\t\tif (ret)\n\t\t\t\tgoto out_trans_end;\n\t\t}\n\n\t\tif (iomap->type == IOMAP_HOLE) {\n\t\t\tret = __gfs2_iomap_alloc(inode, iomap, mp);\n\t\t\tif (ret) {\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t\tgfs2_inplace_release(ip);\n\t\t\t\tpunch_hole(ip, iomap->offset, iomap->length);\n\t\t\t\tgoto out_qunlock;\n\t\t\t}\n\t\t}\n\n\t\ttr = current->journal_info;\n\t\tif (tr->tr_num_buf_new)\n\t\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\n\t\tgfs2_trans_end(sdp);\n\t}\n\n\tif (gfs2_is_stuffed(ip) || gfs2_is_jdata(ip))\n\t\tiomap->folio_ops = &gfs2_iomap_folio_ops;\n\treturn 0;\n\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\n\treturn ret;\n}\n\nstatic int gfs2_iomap_begin(struct inode *inode, loff_t pos, loff_t length,\n\t\t\t    unsigned flags, struct iomap *iomap,\n\t\t\t    struct iomap *srcmap)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct metapath mp = { .mp_aheight = 1, };\n\tint ret;\n\n\tif (gfs2_is_jdata(ip))\n\t\tiomap->flags |= IOMAP_F_BUFFER_HEAD;\n\n\ttrace_gfs2_iomap_start(ip, pos, length, flags);\n\tret = __gfs2_iomap_get(inode, pos, length, flags, iomap, &mp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tswitch(flags & (IOMAP_WRITE | IOMAP_ZERO)) {\n\tcase IOMAP_WRITE:\n\t\tif (flags & IOMAP_DIRECT) {\n\t\t\t \n\t\t\tif (iomap->type != IOMAP_MAPPED)\n\t\t\t\tret = -ENOTBLK;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tcase IOMAP_ZERO:\n\t\tif (iomap->type == IOMAP_HOLE)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tdefault:\n\t\tgoto out_unlock;\n\t}\n\n\tret = gfs2_iomap_begin_write(inode, pos, length, flags, iomap, &mp);\n\nout_unlock:\n\trelease_metapath(&mp);\n\ttrace_gfs2_iomap_end(ip, iomap, ret);\n\treturn ret;\n}\n\nstatic int gfs2_iomap_end(struct inode *inode, loff_t pos, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tswitch (flags & (IOMAP_WRITE | IOMAP_ZERO)) {\n\tcase IOMAP_WRITE:\n\t\tif (flags & IOMAP_DIRECT)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IOMAP_ZERO:\n\t\t if (iomap->type == IOMAP_HOLE)\n\t\t\t return 0;\n\t\t break;\n\tdefault:\n\t\t return 0;\n\t}\n\n\tif (!gfs2_is_stuffed(ip))\n\t\tgfs2_ordered_add_inode(ip);\n\n\tif (inode == sdp->sd_rindex)\n\t\tadjust_fs_space(inode);\n\n\tgfs2_inplace_release(ip);\n\n\tif (ip->i_qadata && ip->i_qadata->qa_qd_num)\n\t\tgfs2_quota_unlock(ip);\n\n\tif (length != written && (iomap->flags & IOMAP_F_NEW)) {\n\t\t \n\t\tloff_t hstart = round_up(pos + written, i_blocksize(inode));\n\t\tloff_t hend = iomap->offset + iomap->length;\n\n\t\tif (hstart < hend) {\n\t\t\ttruncate_pagecache_range(inode, hstart, hend - 1);\n\t\t\tpunch_hole(ip, hstart, hend - hstart);\n\t\t}\n\t}\n\n\tif (unlikely(!written))\n\t\treturn 0;\n\n\tif (iomap->flags & IOMAP_F_SIZE_CHANGED)\n\t\tmark_inode_dirty(inode);\n\tset_bit(GLF_DIRTY, &ip->i_gl->gl_flags);\n\treturn 0;\n}\n\nconst struct iomap_ops gfs2_iomap_ops = {\n\t.iomap_begin = gfs2_iomap_begin,\n\t.iomap_end = gfs2_iomap_end,\n};\n\n \n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tloff_t pos = (loff_t)lblock << inode->i_blkbits;\n\tloff_t length = bh_map->b_size;\n\tstruct iomap iomap = { };\n\tint ret;\n\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\n\tif (!create)\n\t\tret = gfs2_iomap_get(inode, pos, length, &iomap);\n\telse\n\t\tret = gfs2_iomap_alloc(inode, pos, length, &iomap);\n\tif (ret)\n\t\tgoto out;\n\n\tif (iomap.length > bh_map->b_size) {\n\t\tiomap.length = bh_map->b_size;\n\t\tiomap.flags &= ~IOMAP_F_GFS2_BOUNDARY;\n\t}\n\tif (iomap.addr != IOMAP_NULL_ADDR)\n\t\tmap_bh(bh_map, inode->i_sb, iomap.addr >> inode->i_blkbits);\n\tbh_map->b_size = iomap.length;\n\tif (iomap.flags & IOMAP_F_GFS2_BOUNDARY)\n\t\tset_buffer_boundary(bh_map);\n\tif (iomap.flags & IOMAP_F_NEW)\n\t\tset_buffer_new(bh_map);\n\nout:\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\treturn ret;\n}\n\nint gfs2_get_extent(struct inode *inode, u64 lblock, u64 *dblock,\n\t\t    unsigned int *extlen)\n{\n\tunsigned int blkbits = inode->i_blkbits;\n\tstruct iomap iomap = { };\n\tunsigned int len;\n\tint ret;\n\n\tret = gfs2_iomap_get(inode, lblock << blkbits, *extlen << blkbits,\n\t\t\t     &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (iomap.type != IOMAP_MAPPED)\n\t\treturn -EIO;\n\t*dblock = iomap.addr >> blkbits;\n\tlen = iomap.length >> blkbits;\n\tif (len < *extlen)\n\t\t*extlen = len;\n\treturn 0;\n}\n\nint gfs2_alloc_extent(struct inode *inode, u64 lblock, u64 *dblock,\n\t\t      unsigned int *extlen, bool *new)\n{\n\tunsigned int blkbits = inode->i_blkbits;\n\tstruct iomap iomap = { };\n\tunsigned int len;\n\tint ret;\n\n\tret = gfs2_iomap_alloc(inode, lblock << blkbits, *extlen << blkbits,\n\t\t\t       &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (iomap.type != IOMAP_MAPPED)\n\t\treturn -EIO;\n\t*dblock = iomap.addr >> blkbits;\n\tlen = iomap.length >> blkbits;\n\tif (len < *extlen)\n\t\t*extlen = len;\n\t*new = iomap.flags & IOMAP_F_NEW;\n\treturn 0;\n}\n\n \nstatic int gfs2_block_zero_range(struct inode *inode, loff_t from,\n\t\t\t\t unsigned int length)\n{\n\tBUG_ON(current->journal_info);\n\treturn iomap_zero_range(inode, from, length, NULL, &gfs2_iomap_ops);\n}\n\n#define GFS2_JTRUNC_REVOKES 8192\n\n \n\nstatic int gfs2_journaled_truncate(struct inode *inode, u64 oldsize, u64 newsize)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tu64 max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tu64 chunk;\n\tint error;\n\n\twhile (oldsize != newsize) {\n\t\tstruct gfs2_trans *tr;\n\t\tunsigned int offs;\n\n\t\tchunk = oldsize - newsize;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\n\t\toffs = oldsize & ~PAGE_MASK;\n\t\tif (offs && chunk > PAGE_SIZE)\n\t\t\tchunk = offs + ((chunk - offs) & PAGE_MASK);\n\n\t\ttruncate_pagecache(inode, oldsize - chunk);\n\t\toldsize -= chunk;\n\n\t\ttr = current->journal_info;\n\t\tif (!test_bit(TR_TOUCHED, &tr->tr_flags))\n\t\t\tcontinue;\n\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int trunc_start(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *dibh = NULL;\n\tint journaled = gfs2_is_jdata(ip);\n\tu64 oldsize = inode->i_size;\n\tint error;\n\n\tif (!gfs2_is_stuffed(ip)) {\n\t\tunsigned int blocksize = i_blocksize(inode);\n\t\tunsigned int offs = newsize & (blocksize - 1);\n\t\tif (offs) {\n\t\t\terror = gfs2_block_zero_range(inode, newsize,\n\t\t\t\t\t\t      blocksize - offs);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\tif (journaled)\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_JDATA, GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\tif (gfs2_is_stuffed(ip))\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode) + newsize);\n\telse\n\t\tip->i_diskflags |= GFS2_DIF_TRUNC_IN_PROG;\n\n\ti_size_write(inode, newsize);\n\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tif (journaled)\n\t\terror = gfs2_journaled_truncate(inode, oldsize, newsize);\n\telse\n\t\ttruncate_pagecache(inode, newsize);\n\nout:\n\tbrelse(dibh);\n\tif (current->journal_info)\n\t\tgfs2_trans_end(sdp);\n\treturn error;\n}\n\nint gfs2_iomap_get(struct inode *inode, loff_t pos, loff_t length,\n\t\t   struct iomap *iomap)\n{\n\tstruct metapath mp = { .mp_aheight = 1, };\n\tint ret;\n\n\tret = __gfs2_iomap_get(inode, pos, length, 0, iomap, &mp);\n\trelease_metapath(&mp);\n\treturn ret;\n}\n\nint gfs2_iomap_alloc(struct inode *inode, loff_t pos, loff_t length,\n\t\t     struct iomap *iomap)\n{\n\tstruct metapath mp = { .mp_aheight = 1, };\n\tint ret;\n\n\tret = __gfs2_iomap_get(inode, pos, length, IOMAP_WRITE, iomap, &mp);\n\tif (!ret && iomap->type == IOMAP_HOLE)\n\t\tret = __gfs2_iomap_alloc(inode, iomap, &mp);\n\trelease_metapath(&mp);\n\treturn ret;\n}\n\n \nstatic int sweep_bh_for_rgrps(struct gfs2_inode *ip, struct gfs2_holder *rd_gh,\n\t\t\t      struct buffer_head *bh, __be64 *start, __be64 *end,\n\t\t\t      bool meta, u32 *btotal)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_trans *tr;\n\t__be64 *p;\n\tint blks_outside_rgrp;\n\tu64 bn, bstart, isize_blks;\n\ts64 blen;  \n\tint ret = 0;\n\tbool buf_in_tr = false;  \n\nmore_rgrps:\n\trgd = NULL;\n\tif (gfs2_holder_initialized(rd_gh)) {\n\t\trgd = gfs2_glock2rgrp(rd_gh->gh_gl);\n\t\tgfs2_assert_withdraw(sdp,\n\t\t\t     gfs2_glock_is_locked_by_me(rd_gh->gh_gl));\n\t}\n\tblks_outside_rgrp = 0;\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (p = start; p < end; p++) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\tbn = be64_to_cpu(*p);\n\n\t\tif (rgd) {\n\t\t\tif (!rgrp_contains_block(rgd, bn)) {\n\t\t\t\tblks_outside_rgrp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\trgd = gfs2_blk2rgrpd(sdp, bn, true);\n\t\t\tif (unlikely(!rgd)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t\t LM_FLAG_NODE_SCOPE, rd_gh);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (gfs2_rs_active(&ip->i_res) &&\n\t\t\t    rgd == ip->i_res.rs_rgd)\n\t\t\t\tgfs2_rs_deltree(&ip->i_res);\n\t\t}\n\n\t\t \n\t\tif (current->journal_info == NULL) {\n\t\t\tunsigned int jblocks_rqsted, revokes;\n\n\t\t\tjblocks_rqsted = rgd->rd_length + RES_DINODE +\n\t\t\t\tRES_INDIRECT;\n\t\t\tisize_blks = gfs2_get_inode_blocks(&ip->i_inode);\n\t\t\tif (isize_blks > atomic_read(&sdp->sd_log_thresh2))\n\t\t\t\tjblocks_rqsted +=\n\t\t\t\t\tatomic_read(&sdp->sd_log_thresh2);\n\t\t\telse\n\t\t\t\tjblocks_rqsted += isize_blks;\n\t\t\trevokes = jblocks_rqsted;\n\t\t\tif (meta)\n\t\t\t\trevokes += end - start;\n\t\t\telse if (ip->i_depth)\n\t\t\t\trevokes += sdp->sd_inptrs;\n\t\t\tret = gfs2_trans_begin(sdp, jblocks_rqsted, revokes);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t\tdown_write(&ip->i_rw_mutex);\n\t\t}\n\t\t \n\t\ttr = current->journal_info;\n\t\tif (tr->tr_num_buf_new + RES_STATFS +\n\t\t    RES_QUOTA >= atomic_read(&sdp->sd_log_thresh2)) {\n\t\t\t \n\t\t\tblks_outside_rgrp++;\n\t\t\t \n\n\t\t\tif (buf_in_tr)\n\t\t\t\tbreak;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tbuf_in_tr = true;\n\t\t*p = 0;\n\t\tif (bstart + blen == bn) {\n\t\t\tblen++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bstart) {\n\t\t\t__gfs2_free_blocks(ip, rgd, bstart, (u32)blen, meta);\n\t\t\t(*btotal) += blen;\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, -blen);\n\t\t}\n\t\tbstart = bn;\n\t\tblen = 1;\n\t}\n\tif (bstart) {\n\t\t__gfs2_free_blocks(ip, rgd, bstart, (u32)blen, meta);\n\t\t(*btotal) += blen;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -blen);\n\t}\nout_unlock:\n\tif (!ret && blks_outside_rgrp) {  \n\t\tif (current->journal_info) {\n\t\t\tstruct buffer_head *dibh;\n\n\t\t\tret = gfs2_meta_inode_buffer(ip, &dibh);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\t\tbrelse(dibh);\n\t\t\tup_write(&ip->i_rw_mutex);\n\t\t\tgfs2_trans_end(sdp);\n\t\t\tbuf_in_tr = false;\n\t\t}\n\t\tgfs2_glock_dq_uninit(rd_gh);\n\t\tcond_resched();\n\t\tgoto more_rgrps;\n\t}\nout:\n\treturn ret;\n}\n\nstatic bool mp_eq_to_hgt(struct metapath *mp, __u16 *list, unsigned int h)\n{\n\tif (memcmp(mp->mp_list, list, h * sizeof(mp->mp_list[0])))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool find_nonnull_ptr(struct gfs2_sbd *sdp, struct metapath *mp,\n\t\t\t     unsigned int h,\n\t\t\t     __u16 *end_list, unsigned int end_aligned)\n{\n\tstruct buffer_head *bh = mp->mp_bh[h];\n\t__be64 *first, *ptr, *end;\n\n\tfirst = metaptr1(h, mp);\n\tptr = first + mp->mp_list[h];\n\tend = (__be64 *)(bh->b_data + bh->b_size);\n\tif (end_list && mp_eq_to_hgt(mp, end_list, h)) {\n\t\tbool keep_end = h < end_aligned;\n\t\tend = first + end_list[h] + keep_end;\n\t}\n\n\twhile (ptr < end) {\n\t\tif (*ptr) {  \n\t\t\tmp->mp_list[h] = ptr - first;\n\t\t\th++;\n\t\t\tif (h < GFS2_MAX_META_HEIGHT)\n\t\t\t\tmp->mp_list[h] = 0;\n\t\t\treturn true;\n\t\t}\n\t\tptr++;\n\t}\n\treturn false;\n}\n\nenum dealloc_states {\n\tDEALLOC_MP_FULL = 0,     \n\tDEALLOC_MP_LOWER = 1,    \n\tDEALLOC_FILL_MP = 2,   \n\tDEALLOC_DONE = 3,        \n};\n\nstatic inline void\nmetapointer_range(struct metapath *mp, int height,\n\t\t  __u16 *start_list, unsigned int start_aligned,\n\t\t  __u16 *end_list, unsigned int end_aligned,\n\t\t  __be64 **start, __be64 **end)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\t__be64 *first;\n\n\tfirst = metaptr1(height, mp);\n\t*start = first;\n\tif (mp_eq_to_hgt(mp, start_list, height)) {\n\t\tbool keep_start = height < start_aligned;\n\t\t*start = first + start_list[height] + keep_start;\n\t}\n\t*end = (__be64 *)(bh->b_data + bh->b_size);\n\tif (end_list && mp_eq_to_hgt(mp, end_list, height)) {\n\t\tbool keep_end = height < end_aligned;\n\t\t*end = first + end_list[height] + keep_end;\n\t}\n}\n\nstatic inline bool walk_done(struct gfs2_sbd *sdp,\n\t\t\t     struct metapath *mp, int height,\n\t\t\t     __u16 *end_list, unsigned int end_aligned)\n{\n\t__u16 end;\n\n\tif (end_list) {\n\t\tbool keep_end = height < end_aligned;\n\t\tif (!mp_eq_to_hgt(mp, end_list, height))\n\t\t\treturn false;\n\t\tend = end_list[height] + keep_end;\n\t} else\n\t\tend = (height > 0) ? sdp->sd_inptrs : sdp->sd_diptrs;\n\treturn mp->mp_list[height] >= end;\n}\n\n \nstatic int punch_hole(struct gfs2_inode *ip, u64 offset, u64 length)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 maxsize = sdp->sd_heightsize[ip->i_height];\n\tstruct metapath mp = {};\n\tstruct buffer_head *dibh, *bh;\n\tstruct gfs2_holder rd_gh;\n\tunsigned int bsize_shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 lblock = (offset + (1 << bsize_shift) - 1) >> bsize_shift;\n\t__u16 start_list[GFS2_MAX_META_HEIGHT];\n\t__u16 __end_list[GFS2_MAX_META_HEIGHT], *end_list = NULL;\n\tunsigned int start_aligned, end_aligned;\n\tunsigned int strip_h = ip->i_height - 1;\n\tu32 btotal = 0;\n\tint ret, state;\n\tint mp_h;  \n\tu64 prev_bnr = 0;\n\t__be64 *start, *end;\n\n\tif (offset >= maxsize) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\n\tif (length) {\n\t\tu64 end_offset = offset + length;\n\t\tu64 lend;\n\n\t\t \n\t\tif (end_offset > maxsize)\n\t\t\tend_offset = maxsize;\n\t\tlend = end_offset >> bsize_shift;\n\n\t\tif (lblock >= lend)\n\t\t\treturn 0;\n\n\t\tfind_metapath(sdp, lend, &mp, ip->i_height);\n\t\tend_list = __end_list;\n\t\tmemcpy(end_list, mp.mp_list, sizeof(mp.mp_list));\n\n\t\tfor (mp_h = ip->i_height - 1; mp_h > 0; mp_h--) {\n\t\t\tif (end_list[mp_h])\n\t\t\t\tbreak;\n\t\t}\n\t\tend_aligned = mp_h;\n\t}\n\n\tfind_metapath(sdp, lblock, &mp, ip->i_height);\n\tmemcpy(start_list, mp.mp_list, sizeof(start_list));\n\n\tfor (mp_h = ip->i_height - 1; mp_h > 0; mp_h--) {\n\t\tif (start_list[mp_h])\n\t\t\tbreak;\n\t}\n\tstart_aligned = mp_h;\n\n\tret = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (ret)\n\t\treturn ret;\n\n\tmp.mp_bh[0] = dibh;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret)\n\t\tgoto out_metapath;\n\n\t \n\tfor (mp_h = 0; mp_h < mp.mp_aheight - 1; mp_h++) {\n\t\tmetapointer_range(&mp, mp_h, start_list, start_aligned,\n\t\t\t\t  end_list, end_aligned, &start, &end);\n\t\tgfs2_metapath_ra(ip->i_gl, start, end);\n\t}\n\n\tif (mp.mp_aheight == ip->i_height)\n\t\tstate = DEALLOC_MP_FULL;  \n\telse\n\t\tstate = DEALLOC_FILL_MP;  \n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\tgoto out_metapath;\n\n\tret = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\tgoto out_metapath;\n\tgfs2_holder_mark_uninitialized(&rd_gh);\n\n\tmp_h = strip_h;\n\n\twhile (state != DEALLOC_DONE) {\n\t\tswitch (state) {\n\t\t \n\t\tcase DEALLOC_MP_FULL:\n\t\t\tbh = mp.mp_bh[mp_h];\n\t\t\tgfs2_assert_withdraw(sdp, bh);\n\t\t\tif (gfs2_assert_withdraw(sdp,\n\t\t\t\t\t\t prev_bnr != bh->b_blocknr)) {\n\t\t\t\tfs_emerg(sdp, \"inode %llu, block:%llu, i_h:%u,\"\n\t\t\t\t\t \"s_h:%u, mp_h:%u\\n\",\n\t\t\t\t       (unsigned long long)ip->i_no_addr,\n\t\t\t\t       prev_bnr, ip->i_height, strip_h, mp_h);\n\t\t\t}\n\t\t\tprev_bnr = bh->b_blocknr;\n\n\t\t\tif (gfs2_metatype_check(sdp, bh,\n\t\t\t\t\t\t(mp_h ? GFS2_METATYPE_IN :\n\t\t\t\t\t\t\tGFS2_METATYPE_DI))) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tmetapointer_range(&mp, mp_h, start_list, start_aligned,\n\t\t\t\t\t  end_list, 0  ,\n\t\t\t\t\t  &start, &end);\n\t\t\tret = sweep_bh_for_rgrps(ip, &rd_gh, mp.mp_bh[mp_h],\n\t\t\t\t\t\t start, end,\n\t\t\t\t\t\t mp_h != ip->i_height - 1,\n\t\t\t\t\t\t &btotal);\n\n\t\t\t \n\t\t\tif (ret || !mp_h) {\n\t\t\t\tstate = DEALLOC_DONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DEALLOC_MP_LOWER;\n\t\t\tbreak;\n\n\t\t \n\t\tcase DEALLOC_MP_LOWER:\n\t\t\t \n\t\t\tif (mp_h) {\n\t\t\t\tbrelse(mp.mp_bh[mp_h]);\n\t\t\t\tmp.mp_bh[mp_h] = NULL;\n\t\t\t}\n\t\t\t \n\t\t\tif (mp_h == 0) {\n\t\t\t\tstrip_h--;\n\t\t\t\tmemcpy(mp.mp_list, start_list, sizeof(start_list));\n\t\t\t\tmp_h = strip_h;\n\t\t\t\tstate = DEALLOC_FILL_MP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp.mp_list[mp_h] = 0;\n\t\t\tmp_h--;  \n\t\t\tmp.mp_list[mp_h]++;\n\t\t\tif (walk_done(sdp, &mp, mp_h, end_list, end_aligned))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (find_nonnull_ptr(sdp, &mp, mp_h, end_list, end_aligned)) {\n\t\t\t\tstate = DEALLOC_FILL_MP;\n\t\t\t\tmp_h++;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;  \n\n\t\t \n\t\tcase DEALLOC_FILL_MP:\n\t\t\t \n\t\t\tret = fillup_metapath(ip, &mp, mp_h);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (mp.mp_aheight > 1 && strip_h == ip->i_height - 1) {\n\t\t\t\tunsigned int height = mp.mp_aheight - 1;\n\n\t\t\t\t \n\t\t\t\tif (mp.mp_aheight - 1 == strip_h)\n\t\t\t\t\theight--;\n\n\t\t\t\tfor (; height >= mp.mp_aheight - ret; height--) {\n\t\t\t\t\tmetapointer_range(&mp, height,\n\t\t\t\t\t\t\t  start_list, start_aligned,\n\t\t\t\t\t\t\t  end_list, end_aligned,\n\t\t\t\t\t\t\t  &start, &end);\n\t\t\t\t\tgfs2_metapath_ra(ip->i_gl, start, end);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mp.mp_aheight - 1 == strip_h) {\n\t\t\t\tstate = DEALLOC_MP_FULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mp.mp_aheight < ip->i_height)  \n\t\t\t\tmp_h = mp.mp_aheight - 1;\n\n\t\t\t \n\t\t\tif (find_nonnull_ptr(sdp, &mp, mp_h, end_list, end_aligned))\n\t\t\t\tmp_h++;\n\t\t\telse\n\t\t\t\tstate = DEALLOC_MP_LOWER;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (btotal) {\n\t\tif (current->journal_info == NULL) {\n\t\t\tret = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS +\n\t\t\t\t\t       RES_QUOTA, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tdown_write(&ip->i_rw_mutex);\n\t\t}\n\t\tgfs2_statfs_change(sdp, 0, +btotal, 0);\n\t\tgfs2_quota_change(ip, -(s64)btotal, ip->i_inode.i_uid,\n\t\t\t\t  ip->i_inode.i_gid);\n\t\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tup_write(&ip->i_rw_mutex);\n\t\tgfs2_trans_end(sdp);\n\t}\n\nout:\n\tif (gfs2_holder_initialized(&rd_gh))\n\t\tgfs2_glock_dq_uninit(&rd_gh);\n\tif (current->journal_info) {\n\t\tup_write(&ip->i_rw_mutex);\n\t\tgfs2_trans_end(sdp);\n\t\tcond_resched();\n\t}\n\tgfs2_quota_unhold(ip);\nout_metapath:\n\trelease_metapath(&mp);\n\treturn ret;\n}\n\nstatic int trunc_end(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (!i_size_read(&ip->i_inode)) {\n\t\tip->i_height = 0;\n\t\tip->i_goal = ip->i_no_addr;\n\t\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\t\tgfs2_ordered_del_inode(ip);\n\t}\n\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\tip->i_diskflags &= ~GFS2_DIF_TRUNC_IN_PROG;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\nout:\n\tup_write(&ip->i_rw_mutex);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}\n\n \n\nstatic int do_shrink(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = trunc_start(inode, newsize);\n\tif (error < 0)\n\t\treturn error;\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\terror = punch_hole(ip, newsize, 0);\n\tif (error == 0)\n\t\terror = trunc_end(ip);\n\n\treturn error;\n}\n\n \n\nstatic int do_grow(struct inode *inode, u64 size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_alloc_parms ap = { .target = 1, };\n\tstruct buffer_head *dibh;\n\tint error;\n\tint unstuff = 0;\n\n\tif (gfs2_is_stuffed(ip) && size > gfs2_max_stuffed_size(ip)) {\n\t\terror = gfs2_quota_lock_check(ip, &ap);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto do_grow_qunlock;\n\t\tunstuff = 1;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_STATFS + RES_RG_BIT +\n\t\t\t\t (unstuff &&\n\t\t\t\t  gfs2_is_jdata(ip) ? RES_JDATA : 0) +\n\t\t\t\t (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF ?\n\t\t\t\t  0 : RES_QUOTA), 0);\n\tif (error)\n\t\tgoto do_grow_release;\n\n\tif (unstuff) {\n\t\terror = gfs2_unstuff_dinode(ip);\n\t\tif (error)\n\t\t\tgoto do_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto do_end_trans;\n\n\ttruncate_setsize(inode, size);\n\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\ndo_end_trans:\n\tgfs2_trans_end(sdp);\ndo_grow_release:\n\tif (unstuff) {\n\t\tgfs2_inplace_release(ip);\ndo_grow_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\n\treturn error;\n}\n\n \n\nint gfs2_setattr_size(struct inode *inode, u64 newsize)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint ret;\n\n\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\tret = inode_newsize_ok(inode, newsize);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_dio_wait(inode);\n\n\tret = gfs2_qa_get(ip);\n\tif (ret)\n\t\tgoto out;\n\n\tif (newsize >= inode->i_size) {\n\t\tret = do_grow(inode, newsize);\n\t\tgoto out;\n\t}\n\n\tret = do_shrink(inode, newsize);\nout:\n\tgfs2_rs_delete(ip);\n\tgfs2_qa_put(ip);\n\treturn ret;\n}\n\nint gfs2_truncatei_resume(struct gfs2_inode *ip)\n{\n\tint error;\n\terror = punch_hole(ip, i_size_read(&ip->i_inode), 0);\n\tif (!error)\n\t\terror = trunc_end(ip);\n\treturn error;\n}\n\nint gfs2_file_dealloc(struct gfs2_inode *ip)\n{\n\treturn punch_hole(ip, 0, 0);\n}\n\n \n\nvoid gfs2_free_journal_extents(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\twhile(!list_empty(&jd->extent_list)) {\n\t\tjext = list_first_entry(&jd->extent_list, struct gfs2_journal_extent, list);\n\t\tlist_del(&jext->list);\n\t\tkfree(jext);\n\t}\n}\n\n \n\nstatic int gfs2_add_jextent(struct gfs2_jdesc *jd, u64 lblock, u64 dblock, u64 blocks)\n{\n\tstruct gfs2_journal_extent *jext;\n\n\tif (!list_empty(&jd->extent_list)) {\n\t\tjext = list_last_entry(&jd->extent_list, struct gfs2_journal_extent, list);\n\t\tif ((jext->dblock + jext->blocks) == dblock) {\n\t\t\tjext->blocks += blocks;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tjext = kzalloc(sizeof(struct gfs2_journal_extent), GFP_NOFS);\n\tif (jext == NULL)\n\t\treturn -ENOMEM;\n\tjext->dblock = dblock;\n\tjext->lblock = lblock;\n\tjext->blocks = blocks;\n\tlist_add_tail(&jext->list, &jd->extent_list);\n\tjd->nr_extents++;\n\treturn 0;\n}\n\n \n\nint gfs2_map_journal_extents(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\n{\n\tu64 lblock = 0;\n\tu64 lblock_stop;\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift = sdp->sd_sb.sb_bsize_shift;\n\tu64 size;\n\tint rc;\n\tktime_t start, end;\n\n\tstart = ktime_get();\n\tlblock_stop = i_size_read(jd->jd_inode) >> shift;\n\tsize = (lblock_stop - lblock) << shift;\n\tjd->nr_extents = 0;\n\tWARN_ON(!list_empty(&jd->extent_list));\n\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_blocknr = 0;\n\t\tbh.b_size = size;\n\t\trc = gfs2_block_map(jd->jd_inode, lblock, &bh, 0);\n\t\tif (rc || !buffer_mapped(&bh))\n\t\t\tgoto fail;\n\t\trc = gfs2_add_jextent(jd, lblock, bh.b_blocknr, bh.b_size >> shift);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\tend = ktime_get();\n\tfs_info(sdp, \"journal %d mapped with %u extents in %lldms\\n\", jd->jd_jid,\n\t\tjd->nr_extents, ktime_ms_delta(end, start));\n\treturn 0;\n\nfail:\n\tfs_warn(sdp, \"error %d mapping journal %u at offset %llu (extent %u)\\n\",\n\t\trc, jd->jd_jid,\n\t\t(unsigned long long)(i_size_read(jd->jd_inode) - size),\n\t\tjd->nr_extents);\n\tfs_warn(sdp, \"bmap=%d lblock=%llu block=%llu, state=0x%08lx, size=%llu\\n\",\n\t\trc, (unsigned long long)lblock, (unsigned long long)bh.b_blocknr,\n\t\tbh.b_state, (unsigned long long)bh.b_size);\n\tgfs2_free_journal_extents(jd);\n\treturn rc;\n}\n\n \n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len > gfs2_max_stuffed_size(ip))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file && ip != GFS2_I(sdp->sd_rindex))\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}\n\nstatic int stuffed_zero_range(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\n\tif (offset >= inode->i_size)\n\t\treturn 0;\n\tif (offset + length > inode->i_size)\n\t\tlength = inode->i_size - offset;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemset(dibh->b_data + sizeof(struct gfs2_dinode) + offset, 0,\n\t       length);\n\tbrelse(dibh);\n\treturn 0;\n}\n\nstatic int gfs2_journaled_truncate_range(struct inode *inode, loff_t offset,\n\t\t\t\t\t loff_t length)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t max_chunk = GFS2_JTRUNC_REVOKES * sdp->sd_vfs->s_blocksize;\n\tint error;\n\n\twhile (length) {\n\t\tstruct gfs2_trans *tr;\n\t\tloff_t chunk;\n\t\tunsigned int offs;\n\n\t\tchunk = length;\n\t\tif (chunk > max_chunk)\n\t\t\tchunk = max_chunk;\n\n\t\toffs = offset & ~PAGE_MASK;\n\t\tif (offs && chunk > PAGE_SIZE)\n\t\t\tchunk = offs + ((chunk - offs) & PAGE_MASK);\n\n\t\ttruncate_pagecache_range(inode, offset, chunk);\n\t\toffset += chunk;\n\t\tlength -= chunk;\n\n\t\ttr = current->journal_info;\n\t\tif (!test_bit(TR_TOUCHED, &tr->tr_flags))\n\t\t\tcontinue;\n\n\t\tgfs2_trans_end(sdp);\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, GFS2_JTRUNC_REVOKES);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\nint __gfs2_punch_hole(struct file *file, loff_t offset, loff_t length)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int blocksize = i_blocksize(inode);\n\tloff_t start, end;\n\tint error;\n\n\tif (!gfs2_is_stuffed(ip)) {\n\t\tunsigned int start_off, end_len;\n\n\t\tstart_off = offset & (blocksize - 1);\n\t\tend_len = (offset + length) & (blocksize - 1);\n\t\tif (start_off) {\n\t\t\tunsigned int len = length;\n\t\t\tif (length > blocksize - start_off)\n\t\t\t\tlen = blocksize - start_off;\n\t\t\terror = gfs2_block_zero_range(inode, offset, len);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tif (start_off + length < blocksize)\n\t\t\t\tend_len = 0;\n\t\t}\n\t\tif (end_len) {\n\t\t\terror = gfs2_block_zero_range(inode,\n\t\t\t\toffset + length - end_len, end_len);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tstart = round_down(offset, blocksize);\n\tend = round_up(offset + length, blocksize) - 1;\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_is_jdata(ip))\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_JDATA,\n\t\t\t\t\t GFS2_JTRUNC_REVOKES);\n\telse\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = stuffed_zero_range(inode, offset, length);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (gfs2_is_jdata(ip)) {\n\t\tBUG_ON(!current->journal_info);\n\t\tgfs2_journaled_truncate_range(inode, offset, length);\n\t} else\n\t\ttruncate_pagecache_range(inode, offset, offset + length - 1);\n\n\tfile_update_time(file);\n\tmark_inode_dirty(inode);\n\n\tif (current->journal_info)\n\t\tgfs2_trans_end(sdp);\n\n\tif (!gfs2_is_stuffed(ip))\n\t\terror = punch_hole(ip, offset, length);\n\nout:\n\tif (current->journal_info)\n\t\tgfs2_trans_end(sdp);\n\treturn error;\n}\n\nstatic int gfs2_map_blocks(struct iomap_writepage_ctx *wpc, struct inode *inode,\n\t\tloff_t offset)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(gfs2_is_stuffed(GFS2_I(inode))))\n\t\treturn -EIO;\n\n\tif (offset >= wpc->iomap.offset &&\n\t    offset < wpc->iomap.offset + wpc->iomap.length)\n\t\treturn 0;\n\n\tmemset(&wpc->iomap, 0, sizeof(wpc->iomap));\n\tret = gfs2_iomap_get(inode, offset, INT_MAX, &wpc->iomap);\n\treturn ret;\n}\n\nconst struct iomap_writeback_ops gfs2_writeback_ops = {\n\t.map_blocks\t\t= gfs2_map_blocks,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}