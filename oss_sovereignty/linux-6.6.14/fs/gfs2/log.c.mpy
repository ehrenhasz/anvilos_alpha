{
  "module_name": "log.c",
  "hash_id": "f93e0c71271095901672f4f927e3844809b04890b74a5b94f3d289013f3f3916",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/log.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/crc32c.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/list_sort.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"log.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trace_gfs2.h\"\n#include \"trans.h\"\n\nstatic void gfs2_log_shutdown(struct gfs2_sbd *sdp);\n\n \n\nunsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct)\n{\n\tunsigned int blks;\n\tunsigned int first, second;\n\n\t \n\tblks = 1;\n\tfirst = sdp->sd_ldptrs;\n\n\tif (nstruct > first) {\n\t\t \n\t\tsecond = sdp->sd_inptrs;\n\t\tblks += DIV_ROUND_UP(nstruct - first, second);\n\t}\n\n\treturn blks;\n}\n\n \n\nvoid gfs2_remove_from_ail(struct gfs2_bufdata *bd)\n{\n\tbd->bd_tr = NULL;\n\tlist_del_init(&bd->bd_ail_st_list);\n\tlist_del_init(&bd->bd_ail_gl_list);\n\tatomic_dec(&bd->bd_gl->gl_ail_count);\n\tbrelse(bd->bd_bh);\n}\n\nstatic int __gfs2_writepage(struct folio *folio, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(&folio->page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}\n\n \n\nstatic int gfs2_ail1_start_one(struct gfs2_sbd *sdp,\n\t\t\t       struct writeback_control *wbc,\n\t\t\t       struct gfs2_trans *tr, struct blk_plug *plug)\n__releases(&sdp->sd_ail_lock)\n__acquires(&sdp->sd_ail_lock)\n{\n\tstruct gfs2_glock *gl = NULL;\n\tstruct address_space *mapping;\n\tstruct gfs2_bufdata *bd, *s;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe_reverse(bd, s, &tr->tr_ail1_list, bd_ail_st_list) {\n\t\tbh = bd->bd_bh;\n\n\t\tgfs2_assert(sdp, bd->bd_tr == tr);\n\n\t\tif (!buffer_busy(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tlist_move(&bd->bd_ail_st_list,\n\t\t\t\t\t  &tr->tr_ail2_list);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cmpxchg(&sdp->sd_log_error, 0, -EIO)) {\n\t\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\t\t\tgfs2_withdraw_delayed(sdp);\n\t\t\t}\n\t\t}\n\n\t\tif (gfs2_withdrawn(sdp)) {\n\t\t\tgfs2_remove_from_ail(bd);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_dirty(bh))\n\t\t\tcontinue;\n\t\tif (gl == bd->bd_gl)\n\t\t\tcontinue;\n\t\tgl = bd->bd_gl;\n\t\tlist_move(&bd->bd_ail_st_list, &tr->tr_ail1_list);\n\t\tmapping = bh->b_folio->mapping;\n\t\tif (!mapping)\n\t\t\tcontinue;\n\t\tspin_unlock(&sdp->sd_ail_lock);\n\t\tret = write_cache_pages(mapping, wbc, __gfs2_writepage, mapping);\n\t\tif (need_resched()) {\n\t\t\tblk_finish_plug(plug);\n\t\t\tcond_resched();\n\t\t\tblk_start_plug(plug);\n\t\t}\n\t\tspin_lock(&sdp->sd_ail_lock);\n\t\tif (ret == -ENODATA)  \n\t\t\tret = 0;  \n\t\tif (ret || wbc->nr_to_write <= 0)\n\t\t\tbreak;\n\t\treturn -EBUSY;\n\t}\n\n\treturn ret;\n}\n\nstatic void dump_ail_list(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr;\n\tstruct gfs2_bufdata *bd;\n\tstruct buffer_head *bh;\n\n\tlist_for_each_entry_reverse(tr, &sdp->sd_ail1_list, tr_list) {\n\t\tlist_for_each_entry_reverse(bd, &tr->tr_ail1_list,\n\t\t\t\t\t    bd_ail_st_list) {\n\t\t\tbh = bd->bd_bh;\n\t\t\tfs_err(sdp, \"bd %p: blk:0x%llx bh=%p \", bd,\n\t\t\t       (unsigned long long)bd->bd_blkno, bh);\n\t\t\tif (!bh) {\n\t\t\t\tfs_err(sdp, \"\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfs_err(sdp, \"0x%llx up2:%d dirt:%d lkd:%d req:%d \"\n\t\t\t       \"map:%d new:%d ar:%d aw:%d delay:%d \"\n\t\t\t       \"io err:%d unwritten:%d dfr:%d pin:%d esc:%d\\n\",\n\t\t\t       (unsigned long long)bh->b_blocknr,\n\t\t\t       buffer_uptodate(bh), buffer_dirty(bh),\n\t\t\t       buffer_locked(bh), buffer_req(bh),\n\t\t\t       buffer_mapped(bh), buffer_new(bh),\n\t\t\t       buffer_async_read(bh), buffer_async_write(bh),\n\t\t\t       buffer_delay(bh), buffer_write_io_error(bh),\n\t\t\t       buffer_unwritten(bh),\n\t\t\t       buffer_defer_completion(bh),\n\t\t\t       buffer_pinned(bh), buffer_escaped(bh));\n\t\t}\n\t}\n}\n\n \n\nvoid gfs2_ail1_flush(struct gfs2_sbd *sdp, struct writeback_control *wbc)\n{\n\tstruct list_head *head = &sdp->sd_ail1_list;\n\tstruct gfs2_trans *tr;\n\tstruct blk_plug plug;\n\tint ret;\n\tunsigned long flush_start = jiffies;\n\n\ttrace_gfs2_ail_flush(sdp, wbc, 1);\n\tblk_start_plug(&plug);\n\tspin_lock(&sdp->sd_ail_lock);\nrestart:\n\tret = 0;\n\tif (time_after(jiffies, flush_start + (HZ * 600))) {\n\t\tfs_err(sdp, \"Error: In %s for ten minutes! t=%d\\n\",\n\t\t       __func__, current->journal_info ? 1 : 0);\n\t\tdump_ail_list(sdp);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_reverse(tr, head, tr_list) {\n\t\tif (wbc->nr_to_write <= 0)\n\t\t\tbreak;\n\t\tret = gfs2_ail1_start_one(sdp, wbc, tr, &plug);\n\t\tif (ret) {\n\t\t\tif (ret == -EBUSY)\n\t\t\t\tgoto restart;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tspin_unlock(&sdp->sd_ail_lock);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tgfs2_lm(sdp, \"gfs2_ail1_start_one returned: %d\\n\", ret);\n\t\tgfs2_withdraw(sdp);\n\t}\n\ttrace_gfs2_ail_flush(sdp, wbc, 0);\n}\n\n \n\nstatic void gfs2_ail1_start(struct gfs2_sbd *sdp)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\treturn gfs2_ail1_flush(sdp, &wbc);\n}\n\nstatic void gfs2_log_update_flush_tail(struct gfs2_sbd *sdp)\n{\n\tunsigned int new_flush_tail = sdp->sd_log_head;\n\tstruct gfs2_trans *tr;\n\n\tif (!list_empty(&sdp->sd_ail1_list)) {\n\t\ttr = list_last_entry(&sdp->sd_ail1_list,\n\t\t\t\t     struct gfs2_trans, tr_list);\n\t\tnew_flush_tail = tr->tr_first;\n\t}\n\tsdp->sd_log_flush_tail = new_flush_tail;\n}\n\nstatic void gfs2_log_update_head(struct gfs2_sbd *sdp)\n{\n\tunsigned int new_head = sdp->sd_log_flush_head;\n\n\tif (sdp->sd_log_flush_tail == sdp->sd_log_head)\n\t\tsdp->sd_log_flush_tail = new_head;\n\tsdp->sd_log_head = new_head;\n}\n\n \n\nstatic void gfs2_ail_empty_tr(struct gfs2_sbd *sdp, struct gfs2_trans *tr,\n\t\t\t      struct list_head *head)\n{\n\tstruct gfs2_bufdata *bd;\n\n\twhile (!list_empty(head)) {\n\t\tbd = list_first_entry(head, struct gfs2_bufdata,\n\t\t\t\t      bd_ail_st_list);\n\t\tgfs2_assert(sdp, bd->bd_tr == tr);\n\t\tgfs2_remove_from_ail(bd);\n\t}\n}\n\n \n\nstatic int gfs2_ail1_empty_one(struct gfs2_sbd *sdp, struct gfs2_trans *tr,\n\t\t\t\tint *max_revokes)\n{\n\tstruct gfs2_bufdata *bd, *s;\n\tstruct buffer_head *bh;\n\tint active_count = 0;\n\n\tlist_for_each_entry_safe_reverse(bd, s, &tr->tr_ail1_list,\n\t\t\t\t\t bd_ail_st_list) {\n\t\tbh = bd->bd_bh;\n\t\tgfs2_assert(sdp, bd->bd_tr == tr);\n\t\t \n\t\tif (!sdp->sd_log_error && buffer_busy(bh)) {\n\t\t\tactive_count++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_uptodate(bh) &&\n\t\t    !cmpxchg(&sdp->sd_log_error, 0, -EIO)) {\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\t\tgfs2_withdraw_delayed(sdp);\n\t\t}\n\t\t \n\t\tif (*max_revokes && list_empty(&bd->bd_list)) {\n\t\t\tgfs2_add_revoke(sdp, bd);\n\t\t\t(*max_revokes)--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_move(&bd->bd_ail_st_list, &tr->tr_ail2_list);\n\t}\n\treturn active_count;\n}\n\n \n\nstatic int gfs2_ail1_empty(struct gfs2_sbd *sdp, int max_revokes)\n{\n\tstruct gfs2_trans *tr, *s;\n\tint oldest_tr = 1;\n\tint ret;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(tr, s, &sdp->sd_ail1_list, tr_list) {\n\t\tif (!gfs2_ail1_empty_one(sdp, tr, &max_revokes) && oldest_tr)\n\t\t\tlist_move(&tr->tr_list, &sdp->sd_ail2_list);\n\t\telse\n\t\t\toldest_tr = 0;\n\t}\n\tgfs2_log_update_flush_tail(sdp);\n\tret = list_empty(&sdp->sd_ail1_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\n\tif (test_bit(SDF_WITHDRAWING, &sdp->sd_flags)) {\n\t\tgfs2_lm(sdp, \"fatal: I/O error(s)\\n\");\n\t\tgfs2_withdraw(sdp);\n\t}\n\n\treturn ret;\n}\n\nstatic void gfs2_ail1_wait(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr;\n\tstruct gfs2_bufdata *bd;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_reverse(tr, &sdp->sd_ail1_list, tr_list) {\n\t\tlist_for_each_entry(bd, &tr->tr_ail1_list, bd_ail_st_list) {\n\t\t\tbh = bd->bd_bh;\n\t\t\tif (!buffer_locked(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(&sdp->sd_ail_lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n}\n\nstatic void __ail2_empty(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tgfs2_ail_empty_tr(sdp, tr, &tr->tr_ail2_list);\n\tlist_del(&tr->tr_list);\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_ail1_list));\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_ail2_list));\n\tgfs2_trans_free(sdp, tr);\n}\n\nstatic void ail2_empty(struct gfs2_sbd *sdp, unsigned int new_tail)\n{\n\tstruct list_head *ail2_list = &sdp->sd_ail2_list;\n\tunsigned int old_tail = sdp->sd_log_tail;\n\tstruct gfs2_trans *tr, *safe;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (old_tail <= new_tail) {\n\t\tlist_for_each_entry_safe(tr, safe, ail2_list, tr_list) {\n\t\t\tif (old_tail <= tr->tr_first && tr->tr_first < new_tail)\n\t\t\t\t__ail2_empty(sdp, tr);\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_safe(tr, safe, ail2_list, tr_list) {\n\t\t\tif (old_tail <= tr->tr_first || tr->tr_first < new_tail)\n\t\t\t\t__ail2_empty(sdp, tr);\n\t\t}\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n}\n\n \n\nbool gfs2_log_is_empty(struct gfs2_sbd *sdp) {\n\treturn atomic_read(&sdp->sd_log_blks_free) == sdp->sd_jdesc->jd_blocks;\n}\n\nstatic bool __gfs2_log_try_reserve_revokes(struct gfs2_sbd *sdp, unsigned int revokes)\n{\n\tunsigned int available;\n\n\tavailable = atomic_read(&sdp->sd_log_revokes_available);\n\twhile (available >= revokes) {\n\t\tif (atomic_try_cmpxchg(&sdp->sd_log_revokes_available,\n\t\t\t\t       &available, available - revokes))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid gfs2_log_release_revokes(struct gfs2_sbd *sdp, unsigned int revokes)\n{\n\tif (revokes)\n\t\tatomic_add(revokes, &sdp->sd_log_revokes_available);\n}\n\n \n\nvoid gfs2_log_release(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\tatomic_add(blks, &sdp->sd_log_blks_free);\n\ttrace_gfs2_log_blocks(sdp, blks);\n\tgfs2_assert_withdraw(sdp, atomic_read(&sdp->sd_log_blks_free) <=\n\t\t\t\t  sdp->sd_jdesc->jd_blocks);\n\tif (atomic_read(&sdp->sd_log_blks_needed))\n\t\twake_up(&sdp->sd_log_waitq);\n}\n\n \nstatic bool __gfs2_log_try_reserve(struct gfs2_sbd *sdp, unsigned int blks,\n\t\t\t\t   unsigned int taboo_blks)\n{\n\tunsigned wanted = blks + taboo_blks;\n\tunsigned int free_blocks;\n\n\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\twhile (free_blocks >= wanted) {\n\t\tif (atomic_try_cmpxchg(&sdp->sd_log_blks_free, &free_blocks,\n\t\t\t\t       free_blocks - blks)) {\n\t\t\ttrace_gfs2_log_blocks(sdp, -blks);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \n\nstatic void __gfs2_log_reserve(struct gfs2_sbd *sdp, unsigned int blks,\n\t\t\t       unsigned int taboo_blks)\n{\n\tunsigned wanted = blks + taboo_blks;\n\tunsigned int free_blocks;\n\n\tatomic_add(blks, &sdp->sd_log_blks_needed);\n\tfor (;;) {\n\t\tif (current != sdp->sd_logd_process)\n\t\t\twake_up(&sdp->sd_logd_waitq);\n\t\tio_wait_event(sdp->sd_log_waitq,\n\t\t\t(free_blocks = atomic_read(&sdp->sd_log_blks_free),\n\t\t\t free_blocks >= wanted));\n\t\tdo {\n\t\t\tif (atomic_try_cmpxchg(&sdp->sd_log_blks_free,\n\t\t\t\t\t       &free_blocks,\n\t\t\t\t\t       free_blocks - blks))\n\t\t\t\tgoto reserved;\n\t\t} while (free_blocks >= wanted);\n\t}\n\nreserved:\n\ttrace_gfs2_log_blocks(sdp, -blks);\n\tif (atomic_sub_return(blks, &sdp->sd_log_blks_needed))\n\t\twake_up(&sdp->sd_log_waitq);\n}\n\n \n\nbool gfs2_log_try_reserve(struct gfs2_sbd *sdp, struct gfs2_trans *tr,\n\t\t\t  unsigned int *extra_revokes)\n{\n\tunsigned int blks = tr->tr_reserved;\n\tunsigned int revokes = tr->tr_revokes;\n\tunsigned int revoke_blks = 0;\n\n\t*extra_revokes = 0;\n\tif (revokes && !__gfs2_log_try_reserve_revokes(sdp, revokes)) {\n\t\trevoke_blks = DIV_ROUND_UP(revokes, sdp->sd_inptrs);\n\t\t*extra_revokes = revoke_blks * sdp->sd_inptrs - revokes;\n\t\tblks += revoke_blks;\n\t}\n\tif (!blks)\n\t\treturn true;\n\tif (__gfs2_log_try_reserve(sdp, blks, GFS2_LOG_FLUSH_MIN_BLOCKS))\n\t\treturn true;\n\tif (!revoke_blks)\n\t\tgfs2_log_release_revokes(sdp, revokes);\n\treturn false;\n}\n\n \n\nvoid gfs2_log_reserve(struct gfs2_sbd *sdp, struct gfs2_trans *tr,\n\t\t      unsigned int *extra_revokes)\n{\n\tunsigned int blks = tr->tr_reserved;\n\tunsigned int revokes = tr->tr_revokes;\n\tunsigned int revoke_blks;\n\n\t*extra_revokes = 0;\n\tif (revokes) {\n\t\trevoke_blks = DIV_ROUND_UP(revokes, sdp->sd_inptrs);\n\t\t*extra_revokes = revoke_blks * sdp->sd_inptrs - revokes;\n\t\tblks += revoke_blks;\n\t}\n\t__gfs2_log_reserve(sdp, blks, GFS2_LOG_FLUSH_MIN_BLOCKS);\n}\n\n \n\nstatic inline unsigned int log_distance(struct gfs2_sbd *sdp, unsigned int newer,\n\t\t\t\t\tunsigned int older)\n{\n\tint dist;\n\n\tdist = newer - older;\n\tif (dist < 0)\n\t\tdist += sdp->sd_jdesc->jd_blocks;\n\n\treturn dist;\n}\n\n \nstatic unsigned int calc_reserved(struct gfs2_sbd *sdp)\n{\n\tunsigned int reserved = GFS2_LOG_FLUSH_MIN_BLOCKS;\n\tunsigned int blocks;\n\tstruct gfs2_trans *tr = sdp->sd_log_tr;\n\n\tif (tr) {\n\t\tblocks = tr->tr_num_buf_new - tr->tr_num_buf_rm;\n\t\treserved += blocks + DIV_ROUND_UP(blocks, buf_limit(sdp));\n\t\tblocks = tr->tr_num_databuf_new - tr->tr_num_databuf_rm;\n\t\treserved += blocks + DIV_ROUND_UP(blocks, databuf_limit(sdp));\n\t}\n\treturn reserved;\n}\n\nstatic void log_pull_tail(struct gfs2_sbd *sdp)\n{\n\tunsigned int new_tail = sdp->sd_log_flush_tail;\n\tunsigned int dist;\n\n\tif (new_tail == sdp->sd_log_tail)\n\t\treturn;\n\tdist = log_distance(sdp, new_tail, sdp->sd_log_tail);\n\tail2_empty(sdp, new_tail);\n\tgfs2_log_release(sdp, dist);\n\tsdp->sd_log_tail = new_tail;\n}\n\n\nvoid log_flush_wait(struct gfs2_sbd *sdp)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (atomic_read(&sdp->sd_log_in_flight)) {\n\t\tdo {\n\t\t\tprepare_to_wait(&sdp->sd_log_flush_wait, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\tif (atomic_read(&sdp->sd_log_in_flight))\n\t\t\t\tio_schedule();\n\t\t} while(atomic_read(&sdp->sd_log_in_flight));\n\t\tfinish_wait(&sdp->sd_log_flush_wait, &wait);\n\t}\n}\n\nstatic int ip_cmp(void *priv, const struct list_head *a, const struct list_head *b)\n{\n\tstruct gfs2_inode *ipa, *ipb;\n\n\tipa = list_entry(a, struct gfs2_inode, i_ordered);\n\tipb = list_entry(b, struct gfs2_inode, i_ordered);\n\n\tif (ipa->i_no_addr < ipb->i_no_addr)\n\t\treturn -1;\n\tif (ipa->i_no_addr > ipb->i_no_addr)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void __ordered_del_inode(struct gfs2_inode *ip)\n{\n\tif (!list_empty(&ip->i_ordered))\n\t\tlist_del_init(&ip->i_ordered);\n}\n\nstatic void gfs2_ordered_write(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\tLIST_HEAD(written);\n\n\tspin_lock(&sdp->sd_ordered_lock);\n\tlist_sort(NULL, &sdp->sd_log_ordered, &ip_cmp);\n\twhile (!list_empty(&sdp->sd_log_ordered)) {\n\t\tip = list_first_entry(&sdp->sd_log_ordered, struct gfs2_inode, i_ordered);\n\t\tif (ip->i_inode.i_mapping->nrpages == 0) {\n\t\t\t__ordered_del_inode(ip);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_move(&ip->i_ordered, &written);\n\t\tspin_unlock(&sdp->sd_ordered_lock);\n\t\tfilemap_fdatawrite(ip->i_inode.i_mapping);\n\t\tspin_lock(&sdp->sd_ordered_lock);\n\t}\n\tlist_splice(&written, &sdp->sd_log_ordered);\n\tspin_unlock(&sdp->sd_ordered_lock);\n}\n\nstatic void gfs2_ordered_wait(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\n\tspin_lock(&sdp->sd_ordered_lock);\n\twhile (!list_empty(&sdp->sd_log_ordered)) {\n\t\tip = list_first_entry(&sdp->sd_log_ordered, struct gfs2_inode, i_ordered);\n\t\t__ordered_del_inode(ip);\n\t\tif (ip->i_inode.i_mapping->nrpages == 0)\n\t\t\tcontinue;\n\t\tspin_unlock(&sdp->sd_ordered_lock);\n\t\tfilemap_fdatawait(ip->i_inode.i_mapping);\n\t\tspin_lock(&sdp->sd_ordered_lock);\n\t}\n\tspin_unlock(&sdp->sd_ordered_lock);\n}\n\nvoid gfs2_ordered_del_inode(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tspin_lock(&sdp->sd_ordered_lock);\n\t__ordered_del_inode(ip);\n\tspin_unlock(&sdp->sd_ordered_lock);\n}\n\nvoid gfs2_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct buffer_head *bh = bd->bd_bh;\n\tstruct gfs2_glock *gl = bd->bd_gl;\n\n\tsdp->sd_log_num_revoke++;\n\tif (atomic_inc_return(&gl->gl_revokes) == 1)\n\t\tgfs2_glock_hold(gl);\n\tbh->b_private = NULL;\n\tbd->bd_blkno = bh->b_blocknr;\n\tgfs2_remove_from_ail(bd);  \n\tbd->bd_bh = NULL;\n\tset_bit(GLF_LFLUSH, &gl->gl_flags);\n\tlist_add(&bd->bd_list, &sdp->sd_log_revokes);\n}\n\nvoid gfs2_glock_remove_revoke(struct gfs2_glock *gl)\n{\n\tif (atomic_dec_return(&gl->gl_revokes) == 0) {\n\t\tclear_bit(GLF_LFLUSH, &gl->gl_flags);\n\t\tgfs2_glock_queue_put(gl);\n\t}\n}\n\n \nvoid gfs2_flush_revokes(struct gfs2_sbd *sdp)\n{\n\t \n\tunsigned int max_revokes = atomic_read(&sdp->sd_log_revokes_available);\n\n\tgfs2_log_lock(sdp);\n\tgfs2_ail1_empty(sdp, max_revokes);\n\tgfs2_log_unlock(sdp);\n}\n\n \n\nvoid gfs2_write_log_header(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd,\n\t\t\t   u64 seq, u32 tail, u32 lblock, u32 flags,\n\t\t\t   blk_opf_t op_flags)\n{\n\tstruct gfs2_log_header *lh;\n\tu32 hash, crc;\n\tstruct page *page;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct timespec64 tv;\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 dblock;\n\n\tif (gfs2_withdrawn(sdp))\n\t\treturn;\n\n\tpage = mempool_alloc(gfs2_page_pool, GFP_NOIO);\n\tlh = page_address(page);\n\tclear_page(lh);\n\n\tlh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tlh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);\n\tlh->lh_header.__pad0 = cpu_to_be64(0);\n\tlh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);\n\tlh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlh->lh_sequence = cpu_to_be64(seq);\n\tlh->lh_flags = cpu_to_be32(flags);\n\tlh->lh_tail = cpu_to_be32(tail);\n\tlh->lh_blkno = cpu_to_be32(lblock);\n\thash = ~crc32(~0, lh, LH_V1_SIZE);\n\tlh->lh_hash = cpu_to_be32(hash);\n\n\tktime_get_coarse_real_ts64(&tv);\n\tlh->lh_nsec = cpu_to_be32(tv.tv_nsec);\n\tlh->lh_sec = cpu_to_be64(tv.tv_sec);\n\tif (!list_empty(&jd->extent_list))\n\t\tdblock = gfs2_log_bmap(jd, lblock);\n\telse {\n\t\tunsigned int extlen;\n\t\tint ret;\n\n\t\textlen = 1;\n\t\tret = gfs2_get_extent(jd->jd_inode, lblock, &dblock, &extlen);\n\t\tif (gfs2_assert_withdraw(sdp, ret == 0))\n\t\t\treturn;\n\t}\n\tlh->lh_addr = cpu_to_be64(dblock);\n\tlh->lh_jinode = cpu_to_be64(GFS2_I(jd->jd_inode)->i_no_addr);\n\n\t \n\tif (!(flags & GFS2_LOG_HEAD_RECOVERY)) {\n\t\tlh->lh_statfs_addr =\n\t\t\tcpu_to_be64(GFS2_I(sdp->sd_sc_inode)->i_no_addr);\n\t\tlh->lh_quota_addr =\n\t\t\tcpu_to_be64(GFS2_I(sdp->sd_qc_inode)->i_no_addr);\n\n\t\tspin_lock(&sdp->sd_statfs_spin);\n\t\tlh->lh_local_total = cpu_to_be64(l_sc->sc_total);\n\t\tlh->lh_local_free = cpu_to_be64(l_sc->sc_free);\n\t\tlh->lh_local_dinodes = cpu_to_be64(l_sc->sc_dinodes);\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct gfs2_log_header, lh_crc) != LH_V1_SIZE);\n\n\tcrc = crc32c(~0, (void *)lh + LH_V1_SIZE + 4,\n\t\t     sb->s_blocksize - LH_V1_SIZE - 4);\n\tlh->lh_crc = cpu_to_be32(crc);\n\n\tgfs2_log_write(sdp, jd, page, sb->s_blocksize, 0, dblock);\n\tgfs2_log_submit_bio(&jd->jd_log_bio, REQ_OP_WRITE | op_flags);\n}\n\n \n\nstatic void log_write_header(struct gfs2_sbd *sdp, u32 flags)\n{\n\tblk_opf_t op_flags = REQ_PREFLUSH | REQ_FUA | REQ_META | REQ_SYNC;\n\n\tgfs2_assert_withdraw(sdp, !test_bit(SDF_FROZEN, &sdp->sd_flags));\n\n\tif (test_bit(SDF_NOBARRIERS, &sdp->sd_flags)) {\n\t\tgfs2_ordered_wait(sdp);\n\t\tlog_flush_wait(sdp);\n\t\top_flags = REQ_SYNC | REQ_META | REQ_PRIO;\n\t}\n\tsdp->sd_log_idle = (sdp->sd_log_flush_tail == sdp->sd_log_flush_head);\n\tgfs2_write_log_header(sdp, sdp->sd_jdesc, sdp->sd_log_sequence++,\n\t\t\t      sdp->sd_log_flush_tail, sdp->sd_log_flush_head,\n\t\t\t      flags, op_flags);\n\tgfs2_log_incr_head(sdp);\n\tlog_flush_wait(sdp);\n\tlog_pull_tail(sdp);\n\tgfs2_log_update_head(sdp);\n}\n\n \nvoid gfs2_ail_drain(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\t \n\twhile (!list_empty(&sdp->sd_ail1_list)) {\n\t\ttr = list_first_entry(&sdp->sd_ail1_list, struct gfs2_trans,\n\t\t\t\t      tr_list);\n\t\tgfs2_ail_empty_tr(sdp, tr, &tr->tr_ail1_list);\n\t\tgfs2_ail_empty_tr(sdp, tr, &tr->tr_ail2_list);\n\t\tlist_del(&tr->tr_list);\n\t\tgfs2_trans_free(sdp, tr);\n\t}\n\twhile (!list_empty(&sdp->sd_ail2_list)) {\n\t\ttr = list_first_entry(&sdp->sd_ail2_list, struct gfs2_trans,\n\t\t\t\t      tr_list);\n\t\tgfs2_ail_empty_tr(sdp, tr, &tr->tr_ail2_list);\n\t\tlist_del(&tr->tr_list);\n\t\tgfs2_trans_free(sdp, tr);\n\t}\n\tgfs2_drain_revokes(sdp);\n\tspin_unlock(&sdp->sd_ail_lock);\n}\n\n \nstatic void empty_ail1_list(struct gfs2_sbd *sdp)\n{\n\tunsigned long start = jiffies;\n\n\tfor (;;) {\n\t\tif (time_after(jiffies, start + (HZ * 600))) {\n\t\t\tfs_err(sdp, \"Error: In %s for 10 minutes! t=%d\\n\",\n\t\t\t       __func__, current->journal_info ? 1 : 0);\n\t\t\tdump_ail_list(sdp);\n\t\t\treturn;\n\t\t}\n\t\tgfs2_ail1_start(sdp);\n\t\tgfs2_ail1_wait(sdp);\n\t\tif (gfs2_ail1_empty(sdp, 0))\n\t\t\treturn;\n\t}\n}\n\n \nstatic void trans_drain(struct gfs2_trans *tr)\n{\n\tstruct gfs2_bufdata *bd;\n\tstruct list_head *head;\n\n\tif (!tr)\n\t\treturn;\n\n\thead = &tr->tr_buf;\n\twhile (!list_empty(head)) {\n\t\tbd = list_first_entry(head, struct gfs2_bufdata, bd_list);\n\t\tlist_del_init(&bd->bd_list);\n\t\tif (!list_empty(&bd->bd_ail_st_list))\n\t\t\tgfs2_remove_from_ail(bd);\n\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t}\n\thead = &tr->tr_databuf;\n\twhile (!list_empty(head)) {\n\t\tbd = list_first_entry(head, struct gfs2_bufdata, bd_list);\n\t\tlist_del_init(&bd->bd_list);\n\t\tif (!list_empty(&bd->bd_ail_st_list))\n\t\t\tgfs2_remove_from_ail(bd);\n\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t}\n}\n\n \n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl, u32 flags)\n{\n\tstruct gfs2_trans *tr = NULL;\n\tunsigned int reserved_blocks = 0, used_blocks = 0;\n\tbool frozen = test_bit(SDF_FROZEN, &sdp->sd_flags);\n\tunsigned int first_log_head;\n\tunsigned int reserved_revokes = 0;\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\ttrace_gfs2_log_flush(sdp, 1, flags);\n\nrepeat:\n\t \n\tif (gfs2_withdrawn(sdp) || !test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\tgoto out;\n\n\t \n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags))\n\t\tgoto out;\n\n\tfirst_log_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_head = first_log_head;\n\n\ttr = sdp->sd_log_tr;\n\tif (tr || sdp->sd_log_num_revoke) {\n\t\tif (reserved_blocks)\n\t\t\tgfs2_log_release(sdp, reserved_blocks);\n\t\treserved_blocks = sdp->sd_log_blks_reserved;\n\t\treserved_revokes = sdp->sd_log_num_revoke;\n\t\tif (tr) {\n\t\t\tsdp->sd_log_tr = NULL;\n\t\t\ttr->tr_first = first_log_head;\n\t\t\tif (unlikely(frozen)) {\n\t\t\t\tif (gfs2_assert_withdraw_delayed(sdp,\n\t\t\t\t       !tr->tr_num_buf_new && !tr->tr_num_databuf_new))\n\t\t\t\t\tgoto out_withdraw;\n\t\t\t}\n\t\t}\n\t} else if (!reserved_blocks) {\n\t\tunsigned int taboo_blocks = GFS2_LOG_FLUSH_MIN_BLOCKS;\n\n\t\treserved_blocks = GFS2_LOG_FLUSH_MIN_BLOCKS;\n\t\tif (current == sdp->sd_logd_process)\n\t\t\ttaboo_blocks = 0;\n\n\t\tif (!__gfs2_log_try_reserve(sdp, reserved_blocks, taboo_blocks)) {\n\t\t\tup_write(&sdp->sd_log_flush_lock);\n\t\t\t__gfs2_log_reserve(sdp, reserved_blocks, taboo_blocks);\n\t\t\tdown_write(&sdp->sd_log_flush_lock);\n\t\t\tgoto repeat;\n\t\t}\n\t\tBUG_ON(sdp->sd_log_num_revoke);\n\t}\n\n\tif (flags & GFS2_LOG_HEAD_FLUSH_SHUTDOWN)\n\t\tclear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);\n\n\tif (unlikely(frozen))\n\t\tif (gfs2_assert_withdraw_delayed(sdp, !reserved_revokes))\n\t\t\tgoto out_withdraw;\n\n\tgfs2_ordered_write(sdp);\n\tif (gfs2_withdrawn(sdp))\n\t\tgoto out_withdraw;\n\tlops_before_commit(sdp, tr);\n\tif (gfs2_withdrawn(sdp))\n\t\tgoto out_withdraw;\n\tgfs2_log_submit_bio(&sdp->sd_jdesc->jd_log_bio, REQ_OP_WRITE);\n\tif (gfs2_withdrawn(sdp))\n\t\tgoto out_withdraw;\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_write_header(sdp, flags);\n\t} else if (sdp->sd_log_tail != sdp->sd_log_flush_tail && !sdp->sd_log_idle) {\n\t\tlog_write_header(sdp, flags);\n\t}\n\tif (gfs2_withdrawn(sdp))\n\t\tgoto out_withdraw;\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_blks_reserved = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (!(flags & GFS2_LOG_HEAD_FLUSH_NORMAL)) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tempty_ail1_list(sdp);\n\t\t\tif (gfs2_withdrawn(sdp))\n\t\t\t\tgoto out_withdraw;\n\t\t\tlog_write_header(sdp, flags);\n\t\t}\n\t\tif (flags & (GFS2_LOG_HEAD_FLUSH_SHUTDOWN |\n\t\t\t     GFS2_LOG_HEAD_FLUSH_FREEZE))\n\t\t\tgfs2_log_shutdown(sdp);\n\t}\n\nout_end:\n\tused_blocks = log_distance(sdp, sdp->sd_log_flush_head, first_log_head);\n\treserved_revokes += atomic_read(&sdp->sd_log_revokes_available);\n\tatomic_set(&sdp->sd_log_revokes_available, sdp->sd_ldptrs);\n\tgfs2_assert_withdraw(sdp, reserved_revokes % sdp->sd_inptrs == sdp->sd_ldptrs);\n\tif (reserved_revokes > sdp->sd_ldptrs)\n\t\treserved_blocks += (reserved_revokes - sdp->sd_ldptrs) / sdp->sd_inptrs;\nout:\n\tif (used_blocks != reserved_blocks) {\n\t\tgfs2_assert_withdraw_delayed(sdp, used_blocks < reserved_blocks);\n\t\tgfs2_log_release(sdp, reserved_blocks - used_blocks);\n\t}\n\tup_write(&sdp->sd_log_flush_lock);\n\tgfs2_trans_free(sdp, tr);\n\tif (gfs2_withdrawing(sdp))\n\t\tgfs2_withdraw(sdp);\n\ttrace_gfs2_log_flush(sdp, 0, flags);\n\treturn;\n\nout_withdraw:\n\ttrans_drain(tr);\n\t \n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && list_empty(&tr->tr_list))\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\ttr = NULL;\n\tgoto out_end;\n}\n\n \n\nstatic void gfs2_merge_trans(struct gfs2_sbd *sdp, struct gfs2_trans *new)\n{\n\tstruct gfs2_trans *old = sdp->sd_log_tr;\n\n\tWARN_ON_ONCE(!test_bit(TR_ATTACHED, &old->tr_flags));\n\n\told->tr_num_buf_new\t+= new->tr_num_buf_new;\n\told->tr_num_databuf_new\t+= new->tr_num_databuf_new;\n\told->tr_num_buf_rm\t+= new->tr_num_buf_rm;\n\told->tr_num_databuf_rm\t+= new->tr_num_databuf_rm;\n\told->tr_revokes\t\t+= new->tr_revokes;\n\told->tr_num_revoke\t+= new->tr_num_revoke;\n\n\tlist_splice_tail_init(&new->tr_databuf, &old->tr_databuf);\n\tlist_splice_tail_init(&new->tr_buf, &old->tr_buf);\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_splice_tail_init(&new->tr_ail1_list, &old->tr_ail1_list);\n\tlist_splice_tail_init(&new->tr_ail2_list, &old->tr_ail2_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n}\n\nstatic void log_refund(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tunsigned int reserved;\n\tunsigned int unused;\n\tunsigned int maxres;\n\n\tgfs2_log_lock(sdp);\n\n\tif (sdp->sd_log_tr) {\n\t\tgfs2_merge_trans(sdp, tr);\n\t} else if (tr->tr_num_buf_new || tr->tr_num_databuf_new) {\n\t\tgfs2_assert_withdraw(sdp, !test_bit(TR_ONSTACK, &tr->tr_flags));\n\t\tsdp->sd_log_tr = tr;\n\t\tset_bit(TR_ATTACHED, &tr->tr_flags);\n\t}\n\n\treserved = calc_reserved(sdp);\n\tmaxres = sdp->sd_log_blks_reserved + tr->tr_reserved;\n\tgfs2_assert_withdraw(sdp, maxres >= reserved);\n\tunused = maxres - reserved;\n\tif (unused)\n\t\tgfs2_log_release(sdp, unused);\n\tsdp->sd_log_blks_reserved = reserved;\n\n\tgfs2_log_unlock(sdp);\n}\n\nstatic inline int gfs2_jrnl_flush_reqd(struct gfs2_sbd *sdp)\n{\n\treturn atomic_read(&sdp->sd_log_pinned) +\n\t       atomic_read(&sdp->sd_log_blks_needed) >=\n\t       atomic_read(&sdp->sd_log_thresh1);\n}\n\nstatic inline int gfs2_ail_flush_reqd(struct gfs2_sbd *sdp)\n{\n\treturn sdp->sd_jdesc->jd_blocks -\n\t       atomic_read(&sdp->sd_log_blks_free) +\n\t       atomic_read(&sdp->sd_log_blks_needed) >=\n\t       atomic_read(&sdp->sd_log_thresh2);\n}\n\n \n\nvoid gfs2_log_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tlog_refund(sdp, tr);\n\n\tif (gfs2_ail_flush_reqd(sdp) || gfs2_jrnl_flush_reqd(sdp))\n\t\twake_up(&sdp->sd_logd_waitq);\n}\n\n \n\nstatic void gfs2_log_shutdown(struct gfs2_sbd *sdp)\n{\n\tgfs2_assert_withdraw(sdp, !sdp->sd_log_blks_reserved);\n\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp, list_empty(&sdp->sd_ail1_list));\n\n\tlog_write_header(sdp, GFS2_LOG_HEAD_UNMOUNT | GFS2_LFC_SHUTDOWN);\n\tlog_pull_tail(sdp);\n\n\tgfs2_assert_warn(sdp, sdp->sd_log_head == sdp->sd_log_tail);\n\tgfs2_assert_warn(sdp, list_empty(&sdp->sd_ail2_list));\n}\n\n \n\nint gfs2_logd(void *data)\n{\n\tstruct gfs2_sbd *sdp = data;\n\tunsigned long t = 1;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (gfs2_withdrawn(sdp))\n\t\t\tbreak;\n\n\t\t \n\t\tif (sdp->sd_log_error) {\n\t\t\tgfs2_lm(sdp,\n\t\t\t\t\"GFS2: fsid=%s: error %d: \"\n\t\t\t\t\"withdrawing the file system to \"\n\t\t\t\t\"prevent further damage.\\n\",\n\t\t\t\tsdp->sd_fsname, sdp->sd_log_error);\n\t\t\tgfs2_withdraw(sdp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gfs2_jrnl_flush_reqd(sdp) || t == 0) {\n\t\t\tgfs2_ail1_empty(sdp, 0);\n\t\t\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t\t\t\t  GFS2_LFC_LOGD_JFLUSH_REQD);\n\t\t}\n\n\t\tif (test_bit(SDF_FORCE_AIL_FLUSH, &sdp->sd_flags) ||\n\t\t    gfs2_ail_flush_reqd(sdp)) {\n\t\t\tclear_bit(SDF_FORCE_AIL_FLUSH, &sdp->sd_flags);\n\t\t\tgfs2_ail1_start(sdp);\n\t\t\tgfs2_ail1_wait(sdp);\n\t\t\tgfs2_ail1_empty(sdp, 0);\n\t\t\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t\t\t\t  GFS2_LFC_LOGD_AIL_FLUSH_REQD);\n\t\t}\n\n\t\tt = gfs2_tune_get(sdp, gt_logd_secs) * HZ;\n\n\t\ttry_to_freeze();\n\n\t\tt = wait_event_interruptible_timeout(sdp->sd_logd_waitq,\n\t\t\t\ttest_bit(SDF_FORCE_AIL_FLUSH, &sdp->sd_flags) ||\n\t\t\t\tgfs2_ail_flush_reqd(sdp) ||\n\t\t\t\tgfs2_jrnl_flush_reqd(sdp) ||\n\t\t\t\tsdp->sd_log_error ||\n\t\t\t\tgfs2_withdrawn(sdp) ||\n\t\t\t\tkthread_should_stop(),\n\t\t\t\tt);\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}