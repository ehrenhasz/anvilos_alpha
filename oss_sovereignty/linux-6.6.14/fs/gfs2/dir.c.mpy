{
  "module_name": "dir.c",
  "hash_id": "d04140ca164f7a43309d0dd6cc2e9f0ff71abab6008ca92c5c2624d672728fa8",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/dir.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/sort.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/vmalloc.h>\n#include <linux/bio.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"dir.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n\n#define MAX_RA_BLOCKS 32  \n\n#define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)\n#define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))\n#define GFS2_HASH_INDEX_MASK 0xffffc000\n#define GFS2_USE_HASH_FLAG 0x2000\n\nstruct qstr gfs2_qdot __read_mostly;\nstruct qstr gfs2_qdotdot __read_mostly;\n\ntypedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name, void *opaque);\n\nint gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t    struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\t*bhp = bh;\n\treturn 0;\n}\n\nstatic int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,\n\t\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, 0, &bh);\n\tif (error)\n\t\treturn error;\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\t*bhp = bh;\n\treturn 0;\n}\n\nstatic int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,\n\t\t\t\t  unsigned int offset, unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tmemcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);\n\tif (ip->i_inode.i_size < offset + size)\n\t\ti_size_write(&ip->i_inode, offset + size);\n\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn size;\n}\n\n\n\n \nstatic int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,\n\t\t\t       u64 offset, unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\tbool new = false;\n\n\tif (!size)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip) && offset + size <= gfs2_max_stuffed_size(ip))\n\t\treturn gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,\n\t\t\t\t\t      size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tlblock = offset;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\textlen = 1;\n\t\t\terror = gfs2_alloc_extent(&ip->i_inode, lblock, &dblock,\n\t\t\t\t\t\t  &extlen, &new);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t\terror = -EIO;\n\t\t\tif (gfs2_assert_withdraw(sdp, dblock))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amount == sdp->sd_jbsize || new)\n\t\t\terror = gfs2_dir_get_new_buffer(ip, dblock, &bh);\n\t\telse\n\t\t\terror = gfs2_dir_get_existing_buffer(ip, dblock, &bh);\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\tmemcpy(bh->b_data + o, buf, amount);\n\t\tbrelse(bh);\n\n\t\tbuf += amount;\n\t\tcopied += amount;\n\t\tlblock++;\n\t\tdblock++;\n\t\textlen--;\n\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\nout:\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_inode.i_size < offset + copied)\n\t\ti_size_write(&ip->i_inode, offset + copied);\n\tip->i_inode.i_mtime = inode_set_ctime_current(&ip->i_inode);\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\n\treturn copied;\nfail:\n\tif (copied)\n\t\tgoto out;\n\treturn error;\n}\n\nstatic int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t\t unsigned int size)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\t\tbrelse(dibh);\n\t}\n\n\treturn (error) ? error : size;\n}\n\n\n \nstatic int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,\n\t\t\t      unsigned int size)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu64 lblock, dblock;\n\tu32 extlen = 0;\n\tunsigned int o;\n\tint copied = 0;\n\tint error = 0;\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_dir_read_stuffed(ip, buf, size);\n\n\tif (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))\n\t\treturn -EINVAL;\n\n\tlblock = 0;\n\to = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);\n\n\twhile (copied < size) {\n\t\tunsigned int amount;\n\t\tstruct buffer_head *bh;\n\n\t\tamount = size - copied;\n\t\tif (amount > sdp->sd_sb.sb_bsize - o)\n\t\t\tamount = sdp->sd_sb.sb_bsize - o;\n\n\t\tif (!extlen) {\n\t\t\textlen = 32;\n\t\t\terror = gfs2_get_extent(&ip->i_inode, lblock,\n\t\t\t\t\t\t&dblock, &extlen);\n\t\t\tif (error || !dblock)\n\t\t\t\tgoto fail;\n\t\t\tBUG_ON(extlen < 1);\n\t\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\t} else {\n\t\t\terror = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, 0, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\t\tdblock++;\n\t\textlen--;\n\t\tmemcpy(buf, bh->b_data + o, amount);\n\t\tbrelse(bh);\n\t\tbuf += (amount/sizeof(__be64));\n\t\tcopied += amount;\n\t\tlblock++;\n\t\to = sizeof(struct gfs2_meta_header);\n\t}\n\n\treturn copied;\nfail:\n\treturn (copied) ? copied : error;\n}\n\n \n\nstatic __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tint ret;\n\tu32 hsize;\n\t__be64 *hc;\n\n\tBUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));\n\n\thc = ip->i_hash_cache;\n\tif (hc)\n\t\treturn hc;\n\n\thsize = BIT(ip->i_depth);\n\thsize *= sizeof(__be64);\n\tif (hsize != i_size_read(&ip->i_inode)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\thc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);\n\tif (hc == NULL)\n\t\thc = __vmalloc(hsize, GFP_NOFS);\n\n\tif (hc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = gfs2_dir_read_data(ip, hc, hsize);\n\tif (ret < 0) {\n\t\tkvfree(hc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(!ip->i_hash_cache)) {\n\t\tip->i_hash_cache = hc;\n\t\thc = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkvfree(hc);\n\n\treturn ip->i_hash_cache;\n}\n\n \nvoid gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc;\n\n\tspin_lock(&ip->i_inode.i_lock);\n\thc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tspin_unlock(&ip->i_inode.i_lock);\n\n\tkvfree(hc);\n}\n\nstatic inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)\n{\n\treturn dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;\n}\n\nstatic inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t\t     const struct qstr *name, int ret)\n{\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    be32_to_cpu(dent->de_hash) == name->hash &&\n\t    be16_to_cpu(dent->de_name_len) == name->len &&\n\t    memcmp(dent+1, name->name, name->len) == 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int gfs2_dirent_find(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 1);\n}\n\nstatic int gfs2_dirent_prev(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\treturn __gfs2_dirent_find(dent, name, 2);\n}\n\n \nstatic int gfs2_dirent_last(const struct gfs2_dirent *dent,\n\t\t\t    const struct qstr *name,\n\t\t\t    void *opaque)\n{\n\tconst char *start = name->name;\n\tconst char *end = (const char *)dent + be16_to_cpu(dent->de_rec_len);\n\tif (name->len == (end - start))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int gfs2_dirent_find_offset(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *ptr)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (ptr < (void *)dent || ptr >= (void *)dent + totlen)\n\t\treturn 0;\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (ptr < (void *)dent + actual)\n\t\treturn -1;\n\tif ((void *)dent + totlen >= ptr + required)\n\t\treturn 1;\n\treturn -1;\n}\n\nstatic int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n\t\t\t\t  const struct qstr *name,\n\t\t\t\t  void *opaque)\n{\n\tunsigned required = GFS2_DIRENT_SIZE(name->len);\n\tunsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n\n\tif (gfs2_dirent_sentinel(dent))\n\t\tactual = 0;\n\tif (totlen - actual >= required)\n\t\treturn 1;\n\treturn 0;\n}\n\nstruct dirent_gather {\n\tconst struct gfs2_dirent **pdent;\n\tunsigned offset;\n};\n\nstatic int gfs2_dirent_gather(const struct gfs2_dirent *dent,\n\t\t\t      const struct qstr *name,\n\t\t\t      void *opaque)\n{\n\tstruct dirent_gather *g = opaque;\n\tif (!gfs2_dirent_sentinel(dent)) {\n\t\tg->pdent[g->offset++] = dent;\n\t}\n\treturn 0;\n}\n\n \nstatic int gfs2_check_dirent(struct gfs2_sbd *sdp,\n\t\t\t     struct gfs2_dirent *dent, unsigned int offset,\n\t\t\t     unsigned int size, unsigned int len, int first)\n{\n\tconst char *msg = \"gfs2_dirent too small\";\n\tif (unlikely(size < sizeof(struct gfs2_dirent)))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent misaligned\";\n\tif (unlikely(offset & 0x7))\n\t\tgoto error;\n\tmsg = \"gfs2_dirent points beyond end of block\";\n\tif (unlikely(offset + size > len))\n\t\tgoto error;\n\tmsg = \"zero inode number\";\n\tif (unlikely(!first && gfs2_dirent_sentinel(dent)))\n\t\tgoto error;\n\tmsg = \"name length is greater than space in dirent\";\n\tif (!gfs2_dirent_sentinel(dent) &&\n\t    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >\n\t\t     size))\n\t\tgoto error;\n\treturn 0;\nerror:\n\tfs_warn(sdp, \"%s: %s (%s)\\n\",\n\t\t__func__, msg, first ? \"first in block\" : \"not first in block\");\n\treturn -EIO;\n}\n\nstatic int gfs2_dirent_offset(struct gfs2_sbd *sdp, const void *buf)\n{\n\tconst struct gfs2_meta_header *h = buf;\n\tint offset;\n\n\tBUG_ON(buf == NULL);\n\n\tswitch(be32_to_cpu(h->mh_type)) {\n\tcase GFS2_METATYPE_LF:\n\t\toffset = sizeof(struct gfs2_leaf);\n\t\tbreak;\n\tcase GFS2_METATYPE_DI:\n\t\toffset = sizeof(struct gfs2_dinode);\n\t\tbreak;\n\tdefault:\n\t\tgoto wrong_type;\n\t}\n\treturn offset;\nwrong_type:\n\tfs_warn(sdp, \"%s: wrong block type %u\\n\", __func__,\n\t\tbe32_to_cpu(h->mh_type));\n\treturn -1;\n}\n\nstatic struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,\n\t\t\t\t\t    unsigned int len, gfs2_dscan_t scan,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    void *opaque)\n{\n\tstruct gfs2_dirent *dent, *prev;\n\tunsigned offset;\n\tunsigned size;\n\tint ret = 0;\n\n\tret = gfs2_dirent_offset(GFS2_SB(inode), buf);\n\tif (ret < 0)\n\t\tgoto consist_inode;\n\n\toffset = ret;\n\tprev = NULL;\n\tdent = buf + offset;\n\tsize = be16_to_cpu(dent->de_rec_len);\n\tif (gfs2_check_dirent(GFS2_SB(inode), dent, offset, size, len, 1))\n\t\tgoto consist_inode;\n\tdo {\n\t\tret = scan(dent, name, opaque);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += size;\n\t\tif (offset == len)\n\t\t\tbreak;\n\t\tprev = dent;\n\t\tdent = buf + offset;\n\t\tsize = be16_to_cpu(dent->de_rec_len);\n\t\tif (gfs2_check_dirent(GFS2_SB(inode), dent, offset, size,\n\t\t\t\t      len, 0))\n\t\t\tgoto consist_inode;\n\t} while(1);\n\n\tswitch(ret) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn dent;\n\tcase 2:\n\t\treturn prev ? prev : dent;\n\tdefault:\n\t\tBUG_ON(ret > 0);\n\t\treturn ERR_PTR(ret);\n\t}\n\nconsist_inode:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn ERR_PTR(-EIO);\n}\n\nstatic int dirent_check_reclen(struct gfs2_inode *dip,\n\t\t\t       const struct gfs2_dirent *d, const void *end_p)\n{\n\tconst void *ptr = d;\n\tu16 rec_len = be16_to_cpu(d->de_rec_len);\n\n\tif (unlikely(rec_len < sizeof(struct gfs2_dirent)))\n\t\tgoto broken;\n\tptr += rec_len;\n\tif (ptr < end_p)\n\t\treturn rec_len;\n\tif (ptr == end_p)\n\t\treturn -ENOENT;\nbroken:\n\tgfs2_consist_inode(dip);\n\treturn -EIO;\n}\n\n \n\nstatic int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent **dent)\n{\n\tstruct gfs2_dirent *cur = *dent, *tmp;\n\tchar *bh_end = bh->b_data + bh->b_size;\n\tint ret;\n\n\tret = dirent_check_reclen(dip, cur, bh_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = (void *)cur + ret;\n\tret = dirent_check_reclen(dip, tmp, bh_end);\n\tif (ret == -EIO)\n\t\treturn ret;\n\n         \n\tif (gfs2_dirent_sentinel(tmp)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\t*dent = tmp;\n\treturn 0;\n}\n\n \n\nstatic void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,\n\t\t       struct gfs2_dirent *prev, struct gfs2_dirent *cur)\n{\n\tu16 cur_rec_len, prev_rec_len;\n\n\tif (gfs2_dirent_sentinel(cur)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn;\n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\n\t \n\n\tif (!prev) {\n\t\tcur->de_inum.no_addr = 0;\n\t\tcur->de_inum.no_formal_ino = 0;\n\t\treturn;\n\t}\n\n\t \n\n\tprev_rec_len = be16_to_cpu(prev->de_rec_len);\n\tcur_rec_len = be16_to_cpu(cur->de_rec_len);\n\n\tif ((char *)prev + prev_rec_len != (char *)cur)\n\t\tgfs2_consist_inode(dip);\n\tif ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)\n\t\tgfs2_consist_inode(dip);\n\n\tprev_rec_len += cur_rec_len;\n\tprev->de_rec_len = cpu_to_be16(prev_rec_len);\n}\n\n\nstatic struct gfs2_dirent *do_init_dirent(struct inode *inode,\n\t\t\t\t\t  struct gfs2_dirent *dent,\n\t\t\t\t\t  const struct qstr *name,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  unsigned offset)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_dirent *ndent;\n\tunsigned totlen;\n\n\ttotlen = be16_to_cpu(dent->de_rec_len);\n\tBUG_ON(offset + name->len > totlen);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tndent = (struct gfs2_dirent *)((char *)dent + offset);\n\tdent->de_rec_len = cpu_to_be16(offset);\n\tgfs2_qstr2dirent(name, totlen - offset, ndent);\n\treturn ndent;\n}\n\n\n \nstatic struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,\n\t\t\t\t\t    struct gfs2_dirent *dent,\n\t\t\t\t\t    const struct qstr *name,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tunsigned offset = 0;\n\n\tif (!gfs2_dirent_sentinel(dent))\n\t\toffset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));\n\treturn do_init_dirent(inode, dent, name, bh, offset);\n}\n\nstatic struct gfs2_dirent *gfs2_dirent_split_alloc(struct inode *inode,\n\t\t\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t\t\t   const struct qstr *name,\n\t\t\t\t\t\t   void *ptr)\n{\n\tstruct gfs2_dirent *dent;\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_find_offset, name, ptr);\n\tif (IS_ERR_OR_NULL(dent))\n\t\treturn dent;\n\treturn do_init_dirent(inode, dent, name, bh,\n\t\t\t      (unsigned)(ptr - (void *)dent));\n}\n\nstatic int get_leaf(struct gfs2_inode *dip, u64 leaf_no,\n\t\t    struct buffer_head **bhp)\n{\n\tint error;\n\n\terror = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, 0, bhp);\n\tif (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {\n\t\t \n\t\terror = -EIO;\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int get_leaf_nr(struct gfs2_inode *dip, u32 index, u64 *leaf_out)\n{\n\t__be64 *hash;\n\tint error;\n\n\thash = gfs2_dir_get_hash_table(dip);\n\terror = PTR_ERR_OR_ZERO(hash);\n\n\tif (!error)\n\t\t*leaf_out = be64_to_cpu(*(hash + index));\n\n\treturn error;\n}\n\nstatic int get_first_leaf(struct gfs2_inode *dip, u32 index,\n\t\t\t  struct buffer_head **bh_out)\n{\n\tu64 leaf_no;\n\tint error;\n\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (!error)\n\t\terror = get_leaf(dip, leaf_no, bh_out);\n\n\treturn error;\n}\n\nstatic struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,\n\t\t\t\t\t      const struct qstr *name,\n\t\t\t\t\t      gfs2_dscan_t scan,\n\t\t\t\t\t      struct buffer_head **pbh)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf;\n\t\tunsigned int hsize = BIT(ip->i_depth);\n\t\tunsigned int index;\n\t\tu64 ln;\n\t\tif (hsize * sizeof(u64) != i_size_read(inode)) {\n\t\t\tgfs2_consist_inode(ip);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tindex = name->hash >> (32 - ip->i_depth);\n\t\terror = get_first_leaf(ip, index, &bh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tdo {\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tscan, name, NULL);\n\t\t\tif (dent)\n\t\t\t\tgoto got_dent;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tln = be64_to_cpu(leaf->lf_next);\n\t\t\tbrelse(bh);\n\t\t\tif (!ln)\n\t\t\t\tbreak;\n\n\t\t\terror = get_leaf(ip, ln, &bh);\n\t\t} while(!error);\n\n\t\treturn error ? ERR_PTR(error) : NULL;\n\t}\n\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);\ngot_dent:\n\tif (IS_ERR_OR_NULL(dent)) {\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t*pbh = bh;\n\treturn dent;\n}\n\nstatic struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int n = 1;\n\tu64 bn;\n\tint error;\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tstruct gfs2_dirent *dent;\n\tstruct timespec64 tv = current_time(inode);\n\n\terror = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);\n\tif (error)\n\t\treturn NULL;\n\tbh = gfs2_meta_new(ip->i_gl, bn);\n\tif (!bh)\n\t\treturn NULL;\n\n\tgfs2_trans_remove_revoke(GFS2_SB(inode), bn, 1);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);\n\tleaf = (struct gfs2_leaf *)bh->b_data;\n\tleaf->lf_depth = cpu_to_be16(depth);\n\tleaf->lf_entries = 0;\n\tleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);\n\tleaf->lf_next = 0;\n\tleaf->lf_inode = cpu_to_be64(ip->i_no_addr);\n\tleaf->lf_dist = cpu_to_be32(1);\n\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\tmemset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));\n\tdent = (struct gfs2_dirent *)(leaf+1);\n\tgfs2_qstr2dirent(&empty_name, bh->b_size - sizeof(struct gfs2_leaf), dent);\n\t*pbh = bh;\n\treturn leaf;\n}\n\n \n\nstatic int dir_make_exhash(struct inode *inode)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_dirent *dent;\n\tstruct qstr args;\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_leaf *leaf;\n\tint y;\n\tu32 x;\n\t__be64 *lp;\n\tu64 bn;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\t \n\n\tleaf = new_leaf(inode, &bh, 0);\n\tif (!leaf)\n\t\treturn -ENOSPC;\n\tbn = bh->b_blocknr;\n\n\tgfs2_assert(sdp, dip->i_entries < BIT(16));\n\tleaf->lf_entries = cpu_to_be16(dip->i_entries);\n\n\t \n\n\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,\n\t\t\t     sizeof(struct gfs2_dinode));\n\n\t \n\n\tx = 0;\n\targs.len = bh->b_size - sizeof(struct gfs2_dinode) +\n\t\t   sizeof(struct gfs2_leaf);\n\targs.name = bh->b_data;\n\tdent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,\n\t\t\t\tgfs2_dirent_last, &args, NULL);\n\tif (!dent) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tbrelse(bh);\n\t\tbrelse(dibh);\n\t\treturn PTR_ERR(dent);\n\t}\n\n\t \n\n\tdent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +\n\t\tsizeof(struct gfs2_dinode) -\n\t\tsizeof(struct gfs2_leaf));\n\n\tbrelse(bh);\n\n\t \n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tlp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));\n\n\tfor (x = sdp->sd_hash_ptrs; x--; lp++)\n\t\t*lp = cpu_to_be64(bn);\n\n\ti_size_write(inode, sdp->sd_sb.sb_bsize / 2);\n\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\tdip->i_diskflags |= GFS2_DIF_EXHASH;\n\n\tfor (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;\n\tdip->i_depth = y;\n\n\tgfs2_dinode_out(dip, dibh->b_data);\n\n\tbrelse(dibh);\n\n\treturn 0;\n}\n\n \n\nstatic int dir_split_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct buffer_head *nbh, *obh, *dibh;\n\tstruct gfs2_leaf *nleaf, *oleaf;\n\tstruct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;\n\tu32 start, len, half_len, divider;\n\tu64 bn, leaf_no;\n\t__be64 *lp;\n\tu32 index;\n\tint x;\n\tint error;\n\n\tindex = name->hash >> (32 - dip->i_depth);\n\terror = get_leaf_nr(dip, index, &leaf_no);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = get_leaf(dip, leaf_no, &obh);\n\tif (error)\n\t\treturn error;\n\n\toleaf = (struct gfs2_leaf *)obh->b_data;\n\tif (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {\n\t\tbrelse(obh);\n\t\treturn 1;  \n\t}\n\n\tgfs2_trans_add_meta(dip->i_gl, obh);\n\n\tnleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);\n\tif (!nleaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tbn = nbh->b_blocknr;\n\n\t \n\tlen = BIT(dip->i_depth - be16_to_cpu(oleaf->lf_depth));\n\thalf_len = len >> 1;\n\tif (!half_len) {\n\t\tfs_warn(GFS2_SB(inode), \"i_depth %u lf_depth %u index %u\\n\",\n\t\t\tdip->i_depth, be16_to_cpu(oleaf->lf_depth), index);\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t\tgoto fail_brelse;\n\t}\n\n\tstart = (index & ~(len - 1));\n\n\t \n\tlp = kmalloc_array(half_len, sizeof(__be64), GFP_NOFS);\n\tif (!lp) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_brelse;\n\t}\n\n\t \n\tfor (x = 0; x < half_len; x++)\n\t\tlp[x] = cpu_to_be64(bn);\n\n\tgfs2_dir_hash_inval(dip);\n\n\terror = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),\n\t\t\t\t    half_len * sizeof(u64));\n\tif (error != half_len * sizeof(u64)) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto fail_lpfree;\n\t}\n\n\tkfree(lp);\n\n\t \n\tdivider = (start + half_len) << (32 - dip->i_depth);\n\n\t \n\tdent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));\n\n\tdo {\n\t\tnext = dent;\n\t\tif (dirent_next(dip, obh, &next))\n\t\t\tnext = NULL;\n\n\t\tif (!gfs2_dirent_sentinel(dent) &&\n\t\t    be32_to_cpu(dent->de_hash) < divider) {\n\t\t\tstruct qstr str;\n\t\t\tvoid *ptr = ((char *)dent - obh->b_data) + nbh->b_data;\n\t\t\tstr.name = (char*)(dent+1);\n\t\t\tstr.len = be16_to_cpu(dent->de_name_len);\n\t\t\tstr.hash = be32_to_cpu(dent->de_hash);\n\t\t\tnew = gfs2_dirent_split_alloc(inode, nbh, &str, ptr);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terror = PTR_ERR(new);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew->de_inum = dent->de_inum;  \n\t\t\tnew->de_type = dent->de_type;  \n\t\t\tbe16_add_cpu(&nleaf->lf_entries, 1);\n\n\t\t\tdirent_del(dip, obh, prev, dent);\n\n\t\t\tif (!oleaf->lf_entries)\n\t\t\t\tgfs2_consist_inode(dip);\n\t\t\tbe16_add_cpu(&oleaf->lf_entries, -1);\n\n\t\t\tif (!prev)\n\t\t\t\tprev = dent;\n\t\t} else {\n\t\t\tprev = dent;\n\t\t}\n\t\tdent = next;\n\t} while (dent);\n\n\toleaf->lf_depth = nleaf->lf_depth;\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {\n\t\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, 1);\n\t\tgfs2_dinode_out(dip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tbrelse(obh);\n\tbrelse(nbh);\n\n\treturn error;\n\nfail_lpfree:\n\tkfree(lp);\n\nfail_brelse:\n\tbrelse(obh);\n\tbrelse(nbh);\n\treturn error;\n}\n\n \n\nstatic int dir_double_exhash(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *dibh;\n\tu32 hsize;\n\tu32 hsize_bytes;\n\t__be64 *hc;\n\t__be64 *hc2, *h;\n\tint x;\n\tint error = 0;\n\n\thsize = BIT(dip->i_depth);\n\thsize_bytes = hsize * sizeof(__be64);\n\n\thc = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(hc))\n\t\treturn PTR_ERR(hc);\n\n\thc2 = kmalloc_array(hsize_bytes, 2, GFP_NOFS | __GFP_NOWARN);\n\tif (hc2 == NULL)\n\t\thc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS);\n\n\tif (!hc2)\n\t\treturn -ENOMEM;\n\n\th = hc2;\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tfor (x = 0; x < hsize; x++) {\n\t\t*h++ = *hc;\n\t\t*h++ = *hc;\n\t\thc++;\n\t}\n\n\terror = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);\n\tif (error != (hsize_bytes * 2))\n\t\tgoto fail;\n\n\tgfs2_dir_hash_inval(dip);\n\tdip->i_hash_cache = hc2;\n\tdip->i_depth++;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\treturn 0;\n\nfail:\n\t \n\tgfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);\n\ti_size_write(&dip->i_inode, hsize_bytes);\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\nout_kfree:\n\tkvfree(hc2);\n\treturn error;\n}\n\n \n\nstatic int compare_dents(const void *a, const void *b)\n{\n\tconst struct gfs2_dirent *dent_a, *dent_b;\n\tu32 hash_a, hash_b;\n\tint ret = 0;\n\n\tdent_a = *(const struct gfs2_dirent **)a;\n\thash_a = dent_a->de_cookie;\n\n\tdent_b = *(const struct gfs2_dirent **)b;\n\thash_b = dent_b->de_cookie;\n\n\tif (hash_a > hash_b)\n\t\tret = 1;\n\telse if (hash_a < hash_b)\n\t\tret = -1;\n\telse {\n\t\tunsigned int len_a = be16_to_cpu(dent_a->de_name_len);\n\t\tunsigned int len_b = be16_to_cpu(dent_b->de_name_len);\n\n\t\tif (len_a > len_b)\n\t\t\tret = 1;\n\t\telse if (len_a < len_b)\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = memcmp(dent_a + 1, dent_b + 1, len_a);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,\n\t\t\t   struct gfs2_dirent **darr, u32 entries,\n\t\t\t   u32 sort_start, int *copied)\n{\n\tconst struct gfs2_dirent *dent, *dent_next;\n\tu64 off, off_next;\n\tunsigned int x, y;\n\tint run = 0;\n\n\tif (sort_start < entries)\n\t\tsort(&darr[sort_start], entries - sort_start,\n\t\t     sizeof(struct gfs2_dirent *), compare_dents, NULL);\n\n\tdent_next = darr[0];\n\toff_next = dent_next->de_cookie;\n\n\tfor (x = 0, y = 1; x < entries; x++, y++) {\n\t\tdent = dent_next;\n\t\toff = off_next;\n\n\t\tif (y < entries) {\n\t\t\tdent_next = darr[y];\n\t\t\toff_next = dent_next->de_cookie;\n\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\n\t\t\tif (off_next == off) {\n\t\t\t\tif (*copied && !run)\n\t\t\t\t\treturn 1;\n\t\t\t\trun = 1;\n\t\t\t} else\n\t\t\t\trun = 0;\n\t\t} else {\n\t\t\tif (off < ctx->pos)\n\t\t\t\tcontinue;\n\t\t\tctx->pos = off;\n\t\t}\n\n\t\tif (!dir_emit(ctx, (const char *)(dent + 1),\n\t\t\t\tbe16_to_cpu(dent->de_name_len),\n\t\t\t\tbe64_to_cpu(dent->de_inum.no_addr),\n\t\t\t\tbe16_to_cpu(dent->de_type)))\n\t\t\treturn 1;\n\n\t\t*copied = 1;\n\t}\n\n\t \n\n\tctx->pos++;\n\n\treturn 0;\n}\n\nstatic void *gfs2_alloc_sort_buffer(unsigned size)\n{\n\tvoid *ptr = NULL;\n\n\tif (size < KMALLOC_MAX_SIZE)\n\t\tptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (!ptr)\n\t\tptr = __vmalloc(size, GFP_NOFS);\n\treturn ptr;\n}\n\n\nstatic int gfs2_set_cookies(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t\t    unsigned leaf_nr, struct gfs2_dirent **darr,\n\t\t\t    unsigned entries)\n{\n\tint sort_id = -1;\n\tint i;\n\t\n\tfor (i = 0; i < entries; i++) {\n\t\tunsigned offset;\n\n\t\tdarr[i]->de_cookie = be32_to_cpu(darr[i]->de_hash);\n\t\tdarr[i]->de_cookie = gfs2_disk_hash2offset(darr[i]->de_cookie);\n\n\t\tif (!sdp->sd_args.ar_loccookie)\n\t\t\tcontinue;\n\t\toffset = (char *)(darr[i]) -\n\t\t\t(bh->b_data + gfs2_dirent_offset(sdp, bh->b_data));\n\t\toffset /= GFS2_MIN_DIRENT_SIZE;\n\t\toffset += leaf_nr * sdp->sd_max_dents_per_leaf;\n\t\tif (offset >= GFS2_USE_HASH_FLAG ||\n\t\t    leaf_nr >= GFS2_USE_HASH_FLAG) {\n\t\t\tdarr[i]->de_cookie |= GFS2_USE_HASH_FLAG;\n\t\t\tif (sort_id < 0)\n\t\t\t\tsort_id = i;\n\t\t\tcontinue;\n\t\t}\n\t\tdarr[i]->de_cookie &= GFS2_HASH_INDEX_MASK;\n\t\tdarr[i]->de_cookie |= offset;\n\t}\n\treturn sort_id;\n}\t\n\n\nstatic int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,\n\t\t\t      int *copied, unsigned *depth,\n\t\t\t      u64 leaf_no)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *lf;\n\tunsigned entries = 0, entries2 = 0;\n\tunsigned leaves = 0, leaf = 0, offset, sort_offset;\n\tstruct gfs2_dirent **darr, *dent;\n\tstruct dirent_gather g;\n\tstruct buffer_head **larr;\n\tint error, i, need_sort = 0, sort_id;\n\tu64 lfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tif (leaves == 0)\n\t\t\t*depth = be16_to_cpu(lf->lf_depth);\n\t\tentries += be16_to_cpu(lf->lf_entries);\n\t\tleaves++;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tbrelse(bh);\n\t} while(lfn);\n\n\tif (*depth < GFS2_DIR_MAX_DEPTH || !sdp->sd_args.ar_loccookie) {\n\t\tneed_sort = 1;\n\t\tsort_offset = 0;\n\t}\n\n\tif (!entries)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\t \n\tlarr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));\n\tif (!larr)\n\t\tgoto out;\n\tdarr = (struct gfs2_dirent **)(larr + leaves);\n\tg.pdent = (const struct gfs2_dirent **)darr;\n\tg.offset = 0;\n\tlfn = leaf_no;\n\n\tdo {\n\t\terror = get_leaf(ip, lfn, &bh);\n\t\tif (error)\n\t\t\tgoto out_free;\n\t\tlf = (struct gfs2_leaf *)bh->b_data;\n\t\tlfn = be64_to_cpu(lf->lf_next);\n\t\tif (lf->lf_entries) {\n\t\t\toffset = g.offset;\n\t\t\tentries2 += be16_to_cpu(lf->lf_entries);\n\t\t\tdent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,\n\t\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\t\terror = PTR_ERR(dent);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto out_free;\n\t\t\tif (entries2 != g.offset) {\n\t\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir \"\n\t\t\t\t\t\t\"leaf %llu, entries2 (%u) != \"\n\t\t\t\t\t\t\"g.offset (%u)\\n\",\n\t\t\t\t\t(unsigned long long)bh->b_blocknr,\n\t\t\t\t\tentries2, g.offset);\n\t\t\t\tgfs2_consist_inode(ip);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\terror = 0;\n\t\t\tsort_id = gfs2_set_cookies(sdp, bh, leaf, &darr[offset],\n\t\t\t\t\t\t   be16_to_cpu(lf->lf_entries));\n\t\t\tif (!need_sort && sort_id >= 0) {\n\t\t\t\tneed_sort = 1;\n\t\t\t\tsort_offset = offset + sort_id;\n\t\t\t}\n\t\t\tlarr[leaf++] = bh;\n\t\t} else {\n\t\t\tlarr[leaf++] = NULL;\n\t\t\tbrelse(bh);\n\t\t}\n\t} while(lfn);\n\n\tBUG_ON(entries2 != entries);\n\terror = do_filldir_main(ip, ctx, darr, entries, need_sort ?\n\t\t\t\tsort_offset : entries, copied);\nout_free:\n\tfor(i = 0; i < leaf; i++)\n\t\tbrelse(larr[i]);\n\tkvfree(larr);\nout:\n\treturn error;\n}\n\n \nstatic void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,\n\t\t\t       struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tu64 blocknr = 0, last;\n\tunsigned count;\n\n\t \n\tif (index + MAX_RA_BLOCKS < f_ra->start)\n\t\treturn;\n\n\tf_ra->start = max((pgoff_t)index, f_ra->start);\n\tfor (count = 0; count < MAX_RA_BLOCKS; count++) {\n\t\tif (f_ra->start >= hsize)  \n\t\t\tbreak;\n\n\t\tlast = blocknr;\n\t\tblocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);\n\t\tf_ra->start++;\n\t\tif (blocknr == last)\n\t\t\tcontinue;\n\n\t\tbh = gfs2_getbuf(gl, blocknr, 1);\n\t\tif (trylock_buffer(bh)) {\n\t\t\tif (buffer_uptodate(bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(REQ_OP_READ | REQ_RAHEAD | REQ_META |\n\t\t\t\t  REQ_PRIO, bh);\n\t\t\tcontinue;\n\t\t}\n\t\tbrelse(bh);\n\t}\n}\n\n \n\nstatic int dir_e_read(struct inode *inode, struct dir_context *ctx,\n\t\t      struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tu32 hsize, len = 0;\n\tu32 hash, index;\n\t__be64 *lp;\n\tint copied = 0;\n\tint error = 0;\n\tunsigned depth = 0;\n\n\thsize = BIT(dip->i_depth);\n\thash = gfs2_dir_offset2hash(ctx->pos);\n\tindex = hash >> (32 - dip->i_depth);\n\n\tif (dip->i_hash_cache == NULL)\n\t\tf_ra->start = 0;\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\tgfs2_dir_readahead(inode, hsize, index, f_ra);\n\n\twhile (index < hsize) {\n\t\terror = gfs2_dir_read_leaf(inode, ctx,\n\t\t\t\t\t   &copied, &depth,\n\t\t\t\t\t   be64_to_cpu(lp[index]));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tlen = BIT(dip->i_depth - depth);\n\t\tindex = (index & ~(len - 1)) + len;\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}\n\nint gfs2_dir_read(struct inode *inode, struct dir_context *ctx,\n\t\t  struct file_ra_state *f_ra)\n{\n\tstruct gfs2_inode *dip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct dirent_gather g;\n\tstruct gfs2_dirent **darr, *dent;\n\tstruct buffer_head *dibh;\n\tint copied = 0;\n\tint error;\n\n\tif (!dip->i_entries)\n\t\treturn 0;\n\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH)\n\t\treturn dir_e_read(inode, ctx, f_ra);\n\n\tif (!gfs2_is_stuffed(dip)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = -ENOMEM;\n\t \n\tdarr = kmalloc_array(96, sizeof(struct gfs2_dirent *), GFP_NOFS);\n\tif (darr) {\n\t\tg.pdent = (const struct gfs2_dirent **)darr;\n\t\tg.offset = 0;\n\t\tdent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,\n\t\t\t\t\tgfs2_dirent_gather, NULL, &g);\n\t\tif (IS_ERR(dent)) {\n\t\t\terror = PTR_ERR(dent);\n\t\t\tgoto out;\n\t\t}\n\t\tif (dip->i_entries != g.offset) {\n\t\t\tfs_warn(sdp, \"Number of entries corrupt in dir %llu, \"\n\t\t\t\t\"ip->i_entries (%u) != g.offset (%u)\\n\",\n\t\t\t\t(unsigned long long)dip->i_no_addr,\n\t\t\t\tdip->i_entries,\n\t\t\t\tg.offset);\n\t\t\tgfs2_consist_inode(dip);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgfs2_set_cookies(sdp, dibh, 0, darr, dip->i_entries);\n\t\terror = do_filldir_main(dip, ctx, darr,\n\t\t\t\t\tdip->i_entries, 0, &copied);\nout:\n\t\tkfree(darr);\n\t}\n\n\tif (error > 0)\n\t\terror = 0;\n\n\tbrelse(dibh);\n\n\treturn error;\n}\n\n \n\nstruct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,\n\t\t\t      bool fail_on_exist)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tu64 addr, formal_ino;\n\tu16 dtype;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tstruct inode *inode;\n\t\tu16 rahead;\n\n\t\tif (IS_ERR(dent))\n\t\t\treturn ERR_CAST(dent);\n\t\tdtype = be16_to_cpu(dent->de_type);\n\t\trahead = be16_to_cpu(dent->de_rahead);\n\t\taddr = be64_to_cpu(dent->de_inum.no_addr);\n\t\tformal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);\n\t\tbrelse(bh);\n\t\tif (fail_on_exist)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\tinode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino,\n\t\t\t\t\t  GFS2_BLKST_FREE  );\n\t\tif (!IS_ERR(inode))\n\t\t\tGFS2_I(inode)->i_rahead = rahead;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}\n\nint gfs2_dir_check(struct inode *dir, const struct qstr *name,\n\t\t   const struct gfs2_inode *ip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\tint ret = -ENOENT;\n\n\tdent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);\n\tif (dent) {\n\t\tif (IS_ERR(dent))\n\t\t\treturn PTR_ERR(dent);\n\t\tif (ip) {\n\t\t\tif (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)\n\t\t\t\tgoto out;\n\t\t\tif (be64_to_cpu(dent->de_inum.no_formal_ino) !=\n\t\t\t    ip->i_no_formal_ino)\n\t\t\t\tgoto out;\n\t\t\tif (unlikely(IF2DT(ip->i_inode.i_mode) !=\n\t\t\t    be16_to_cpu(dent->de_type))) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(dir));\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = 0;\nout:\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}\n\n \n\nstatic int dir_new_leaf(struct inode *inode, const struct qstr *name)\n{\n\tstruct buffer_head *bh, *obh;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_leaf *leaf, *oleaf;\n\tu32 dist = 1;\n\tint error;\n\tu32 index;\n\tu64 bn;\n\n\tindex = name->hash >> (32 - ip->i_depth);\n\terror = get_first_leaf(ip, index, &obh);\n\tif (error)\n\t\treturn error;\n\tdo {\n\t\tdist++;\n\t\toleaf = (struct gfs2_leaf *)obh->b_data;\n\t\tbn = be64_to_cpu(oleaf->lf_next);\n\t\tif (!bn)\n\t\t\tbreak;\n\t\tbrelse(obh);\n\t\terror = get_leaf(ip, bn, &obh);\n\t\tif (error)\n\t\t\treturn error;\n\t} while(1);\n\n\tgfs2_trans_add_meta(ip->i_gl, obh);\n\n\tleaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));\n\tif (!leaf) {\n\t\tbrelse(obh);\n\t\treturn -ENOSPC;\n\t}\n\tleaf->lf_dist = cpu_to_be32(dist);\n\toleaf->lf_next = cpu_to_be64(bh->b_blocknr);\n\tbrelse(bh);\n\tbrelse(obh);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\tgfs2_dinode_out(ip, bh->b_data);\n\tbrelse(bh);\n\treturn 0;\n}\n\nstatic u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)\n{\n\tu64 where = ip->i_no_addr + 1;\n\tif (ip->i_eattr == where)\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\nint gfs2_dir_add(struct inode *inode, const struct qstr *name,\n\t\t const struct gfs2_inode *nip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh = da->bh;\n\tstruct gfs2_dirent *dent = da->dent;\n\tstruct timespec64 tv;\n\tstruct gfs2_leaf *leaf;\n\tint error;\n\n\twhile(1) {\n\t\tif (da->bh == NULL) {\n\t\t\tdent = gfs2_dirent_search(inode, name,\n\t\t\t\t\t\t  gfs2_dirent_find_space, &bh);\n\t\t}\n\t\tif (dent) {\n\t\t\tif (IS_ERR(dent))\n\t\t\t\treturn PTR_ERR(dent);\n\t\t\tdent = gfs2_init_dirent(inode, dent, name, bh);\n\t\t\tgfs2_inum_out(nip, dent);\n\t\t\tdent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));\n\t\t\tdent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));\n\t\t\ttv = inode_set_ctime_current(&ip->i_inode);\n\t\t\tif (ip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\t\tbe16_add_cpu(&leaf->lf_entries, 1);\n\t\t\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\t\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t\t\t}\n\t\t\tda->dent = NULL;\n\t\t\tda->bh = NULL;\n\t\t\tbrelse(bh);\n\t\t\tip->i_entries++;\n\t\t\tip->i_inode.i_mtime = tv;\n\t\t\tif (S_ISDIR(nip->i_inode.i_mode))\n\t\t\t\tinc_nlink(&ip->i_inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {\n\t\t\terror = dir_make_exhash(inode);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\terror = dir_split_leaf(inode, name);\n\t\tif (error == 0)\n\t\t\tcontinue;\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (ip->i_depth < GFS2_DIR_MAX_DEPTH) {\n\t\t\terror = dir_double_exhash(ip);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\terror = dir_split_leaf(inode, name);\n\t\t\tif (error < 0)\n\t\t\t\tbreak;\n\t\t\tif (error == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\terror = dir_new_leaf(inode, name);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\terror = -ENOSPC;\n\t\tbreak;\n\t}\n\treturn error;\n}\n\n\n \n\nint gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct gfs2_dirent *dent, *prev = NULL;\n\tstruct buffer_head *bh;\n\tstruct timespec64 tv;\n\n\t \n\tdent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent)) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn PTR_ERR(dent);\n\t}\n\t \n\tif (gfs2_dirent_find(dent, name, NULL) == 0) {\n\t\tprev = dent;\n\t\tdent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));\n\t}\n\n\tdirent_del(dip, bh, prev, dent);\n\ttv = inode_set_ctime_current(&dip->i_inode);\n\tif (dip->i_diskflags & GFS2_DIF_EXHASH) {\n\t\tstruct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tu16 entries = be16_to_cpu(leaf->lf_entries);\n\t\tif (!entries)\n\t\t\tgfs2_consist_inode(dip);\n\t\tleaf->lf_entries = cpu_to_be16(--entries);\n\t\tleaf->lf_nsec = cpu_to_be32(tv.tv_nsec);\n\t\tleaf->lf_sec = cpu_to_be64(tv.tv_sec);\n\t}\n\tbrelse(bh);\n\n\tif (!dip->i_entries)\n\t\tgfs2_consist_inode(dip);\n\tdip->i_entries--;\n\tdip->i_inode.i_mtime =  tv;\n\tif (d_is_dir(dentry))\n\t\tdrop_nlink(&dip->i_inode);\n\tmark_inode_dirty(&dip->i_inode);\n\n\treturn 0;\n}\n\n \n\nint gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,\n\t\t   const struct gfs2_inode *nip, unsigned int new_type)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_dirent *dent;\n\n\tdent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);\n\tif (!dent) {\n\t\tgfs2_consist_inode(dip);\n\t\treturn -EIO;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tgfs2_trans_add_meta(dip->i_gl, bh);\n\tgfs2_inum_out(nip, dent);\n\tdent->de_type = cpu_to_be16(new_type);\n\tbrelse(bh);\n\n\tdip->i_inode.i_mtime = inode_set_ctime_current(&dip->i_inode);\n\tmark_inode_dirty_sync(&dip->i_inode);\n\treturn 0;\n}\n\n \n\nstatic int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,\n\t\t\tu64 leaf_no, struct buffer_head *leaf_bh,\n\t\t\tint last_dealloc)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_leaf *tmp_leaf;\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *bh, *dibh;\n\tu64 blk, nblk;\n\tunsigned int rg_blocks = 0, l_blocks = 0;\n\tchar *ht;\n\tunsigned int x, size = len * sizeof(u64);\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\tht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);\n\tif (ht == NULL)\n\t\tht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO);\n\tif (!ht)\n\t\treturn -ENOMEM;\n\n\terror = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_rlist;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\tgfs2_rlist_add(dip, &rlist, blk);\n\t\tl_blocks++;\n\t}\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE, LM_FLAG_NODE_SCOPE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);\n\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist;\n\n\terror = gfs2_trans_begin(sdp,\n\t\t\trg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +\n\t\t\tRES_DINODE + RES_STATFS + RES_QUOTA, RES_DINODE +\n\t\t\t\t l_blocks);\n\tif (error)\n\t\tgoto out_rg_gunlock;\n\n\tbh = leaf_bh;\n\n\tfor (blk = leaf_no; blk; blk = nblk) {\n\t\tstruct gfs2_rgrpd *rgd;\n\n\t\tif (blk != leaf_no) {\n\t\t\terror = get_leaf(dip, blk, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_end_trans;\n\t\t}\n\t\ttmp_leaf = (struct gfs2_leaf *)bh->b_data;\n\t\tnblk = be64_to_cpu(tmp_leaf->lf_next);\n\t\tif (blk != leaf_no)\n\t\t\tbrelse(bh);\n\n\t\trgd = gfs2_blk2rgrpd(sdp, blk, true);\n\t\tgfs2_free_meta(dip, rgd, blk, 1);\n\t\tgfs2_add_inode_blocks(&dip->i_inode, -1);\n\t}\n\n\terror = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);\n\tif (error != size) {\n\t\tif (error >= 0)\n\t\t\terror = -EIO;\n\t\tgoto out_end_trans;\n\t}\n\n\terror = gfs2_meta_inode_buffer(dip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tgfs2_trans_add_meta(dip->i_gl, dibh);\n\t \n\tif (last_dealloc)\n\t\tdip->i_inode.i_mode = S_IFREG;\n\tgfs2_dinode_out(dip, dibh->b_data);\n\tbrelse(dibh);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_rg_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist:\n\tgfs2_rlist_free(&rlist);\n\tgfs2_quota_unhold(dip);\nout:\n\tkvfree(ht);\n\treturn error;\n}\n\n \n\nint gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_leaf *leaf;\n\tu32 hsize, len;\n\tu32 index = 0, next_index;\n\t__be64 *lp;\n\tu64 leaf_no;\n\tint error = 0, last;\n\n\thsize = BIT(dip->i_depth);\n\n\tlp = gfs2_dir_get_hash_table(dip);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\n\twhile (index < hsize) {\n\t\tleaf_no = be64_to_cpu(lp[index]);\n\t\tif (leaf_no) {\n\t\t\terror = get_leaf(dip, leaf_no, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tleaf = (struct gfs2_leaf *)bh->b_data;\n\t\t\tlen = BIT(dip->i_depth - be16_to_cpu(leaf->lf_depth));\n\n\t\t\tnext_index = (index & ~(len - 1)) + len;\n\t\t\tlast = ((next_index >= hsize) ? 1 : 0);\n\t\t\terror = leaf_dealloc(dip, index, len, leaf_no, bh,\n\t\t\t\t\t     last);\n\t\t\tbrelse(bh);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tindex = next_index;\n\t\t} else\n\t\t\tindex++;\n\t}\n\n\tif (index != hsize) {\n\t\tgfs2_consist_inode(dip);\n\t\terror = -EIO;\n\t}\n\nout:\n\n\treturn error;\n}\n\n \n\nint gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,\n\t\t\t       struct gfs2_diradd *da)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tconst unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);\n\tstruct gfs2_dirent *dent;\n\tstruct buffer_head *bh;\n\n\tda->nr_blocks = 0;\n\tda->bh = NULL;\n\tda->dent = NULL;\n\n\tdent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);\n\tif (!dent) {\n\t\tda->nr_blocks = sdp->sd_max_dirres;\n\t\tif (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&\n\t\t    (GFS2_DIRENT_SIZE(name->len) < extra))\n\t\t\tda->nr_blocks = 1;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\n\tif (da->save_loc) {\n\t\tda->bh = bh;\n\t\tda->dent = dent;\n\t} else {\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}