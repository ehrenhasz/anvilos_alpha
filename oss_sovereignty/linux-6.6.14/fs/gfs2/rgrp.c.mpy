{
  "module_name": "rgrp.c",
  "hash_id": "382321773ae9c3d8011f091b67988a8bb2b99b49a451310f06901dc927f4248a",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/rgrp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/rbtree.h>\n#include <linux/random.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"super.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"trace_gfs2.h\"\n#include \"dir.h\"\n\n#define BFITNOENT ((u32)~0)\n#define NO_BLOCK ((u64)~0)\n\nstruct gfs2_rbm {\n\tstruct gfs2_rgrpd *rgd;\n\tu32 offset;\t\t \n\tint bii;\t\t \n};\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\tBUG_ON(rbm->offset >= rbm->rgd->rd_data);\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}\n\n \n\nstruct gfs2_extent {\n\tstruct gfs2_rbm rbm;\n\tu32 len;\n};\n\nstatic const char valid_change[16] = {\n\t         \n\t  0, 1, 1, 1,\n\t  1, 0, 0, 0,\n\t  0, 0, 0, 1,\n\t        1, 0, 0, 0\n};\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t struct gfs2_blkreserv *rs, bool nowrap);\n\n\n \n\nstatic inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_bytes;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tstruct gfs2_sbd *sdp = rbm->rgd->rd_sbd;\n\n\t\tfs_warn(sdp, \"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tfs_warn(sdp, \"rgrp=0x%llx bi_start=0x%x biblk: 0x%llx\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start,\n\t\t\t(unsigned long long)bi->bi_bh->b_blocknr);\n\t\tfs_warn(sdp, \"bi_offset=0x%x bi_bytes=0x%x block=0x%llx\\n\",\n\t\t\tbi->bi_offset, bi->bi_bytes,\n\t\t\t(unsigned long long)gfs2_rbm_to_block(rbm));\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}\n\n \n\nstatic inline u8 gfs2_testbit(const struct gfs2_rbm *rbm, bool use_clone)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tif (use_clone && bi->bi_clone)\n\t\tbuffer = bi->bi_clone;\n\telse\n\t\tbuffer = bi->bi_bh->b_data;\n\tbuffer += bi->bi_offset;\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}\n\n \n\nstatic inline u64 gfs2_bit_search(const __le64 *ptr, u64 mask, u8 state)\n{\n\tu64 tmp;\n\tstatic const u64 search[] = {\n\t\t[0] = 0xffffffffffffffffULL,\n\t\t[1] = 0xaaaaaaaaaaaaaaaaULL,\n\t\t[2] = 0x5555555555555555ULL,\n\t\t[3] = 0x0000000000000000ULL,\n\t};\n\ttmp = le64_to_cpu(*ptr) ^ search[state];\n\ttmp &= (tmp >> 1);\n\ttmp &= mask;\n\treturn tmp;\n}\n\n \nstatic inline int rs_cmp(u64 start, u32 len, struct gfs2_blkreserv *rs)\n{\n\tif (start >= rs->rs_start + rs->rs_requested)\n\t\treturn 1;\n\tif (rs->rs_start >= start + len)\n\t\treturn -1;\n\treturn 0;\n}\n\n \n\nstatic u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t \n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t \n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t \n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t \n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}\n\n \n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tif (!rgrp_contains_block(rbm->rgd, block))\n\t\treturn -E2BIG;\n\trbm->bii = 0;\n\trbm->offset = block - rbm->rgd->rd_data0;\n\t \n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t \n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}\n\n \n\nstatic bool gfs2_rbm_add(struct gfs2_rbm *rbm, u32 blocks)\n{\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\tstruct gfs2_bitmap *bi = rgd->rd_bits + rbm->bii;\n\n\tif (rbm->offset + blocks < bi->bi_blocks) {\n\t\trbm->offset += blocks;\n\t\treturn false;\n\t}\n\tblocks -= bi->bi_blocks - rbm->offset;\n\n\tfor(;;) {\n\t\tbi++;\n\t\tif (bi == rgd->rd_bits + rgd->rd_length)\n\t\t\treturn true;\n\t\tif (blocks < bi->bi_blocks) {\n\t\t\trbm->offset = blocks;\n\t\t\trbm->bii = bi - rgd->rd_bits;\n\t\t\treturn false;\n\t\t}\n\t\tblocks -= bi->bi_blocks;\n\t}\n}\n\n \n\nstatic bool gfs2_unaligned_extlen(struct gfs2_rbm *rbm, u32 n_unaligned, u32 *len)\n{\n\tu32 n;\n\tu8 res;\n\n\tfor (n = 0; n < n_unaligned; n++) {\n\t\tres = gfs2_testbit(rbm, true);\n\t\tif (res != GFS2_BLKST_FREE)\n\t\t\treturn true;\n\t\t(*len)--;\n\t\tif (*len == 0)\n\t\t\treturn true;\n\t\tif (gfs2_rbm_add(rbm, 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\nstatic u32 gfs2_free_extlen(const struct gfs2_rbm *rrbm, u32 len)\n{\n\tstruct gfs2_rbm rbm = *rrbm;\n\tu32 n_unaligned = rbm.offset & 3;\n\tu32 size = len;\n\tu32 bytes;\n\tu32 chunk_size;\n\tu8 *ptr, *start, *end;\n\tu64 block;\n\tstruct gfs2_bitmap *bi;\n\n\tif (n_unaligned &&\n\t    gfs2_unaligned_extlen(&rbm, 4 - n_unaligned, &len))\n\t\tgoto out;\n\n\tn_unaligned = len & 3;\n\t \n\twhile (len > 3) {\n\t\tbi = rbm_bi(&rbm);\n\t\tstart = bi->bi_bh->b_data;\n\t\tif (bi->bi_clone)\n\t\t\tstart = bi->bi_clone;\n\t\tstart += bi->bi_offset;\n\t\tend = start + bi->bi_bytes;\n\t\tBUG_ON(rbm.offset & 3);\n\t\tstart += (rbm.offset / GFS2_NBBY);\n\t\tbytes = min_t(u32, len / GFS2_NBBY, (end - start));\n\t\tptr = memchr_inv(start, 0, bytes);\n\t\tchunk_size = ((ptr == NULL) ? bytes : (ptr - start));\n\t\tchunk_size *= GFS2_NBBY;\n\t\tBUG_ON(len < chunk_size);\n\t\tlen -= chunk_size;\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + chunk_size)) {\n\t\t\tn_unaligned = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ptr) {\n\t\t\tn_unaligned = 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_unaligned = len & 3;\n\t}\n\n\t \n\tif (n_unaligned)\n\t\tgfs2_unaligned_extlen(&rbm, n_unaligned, &len);\nout:\n\treturn size - len;\n}\n\n \n\nstatic u32 gfs2_bitcount(struct gfs2_rgrpd *rgd, const u8 *buffer,\n\t\t\t unsigned int buflen, u8 state)\n{\n\tconst u8 *byte = buffer;\n\tconst u8 *end = buffer + buflen;\n\tconst u8 state1 = state << 2;\n\tconst u8 state2 = state << 4;\n\tconst u8 state3 = state << 6;\n\tu32 count = 0;\n\n\tfor (; byte < end; byte++) {\n\t\tif (((*byte) & 0x03) == state)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x0C) == state1)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x30) == state2)\n\t\t\tcount++;\n\t\tif (((*byte) & 0xC0) == state3)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \n\nvoid gfs2_rgrp_verify(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi = NULL;\n\tu32 length = rgd->rd_length;\n\tu32 count[4], tmp;\n\tint buf, x;\n\n\tmemset(count, 0, 4 * sizeof(u32));\n\n\t \n\tfor (buf = 0; buf < length; buf++) {\n\t\tbi = rgd->rd_bits + buf;\n\t\tfor (x = 0; x < 4; x++)\n\t\t\tcount[x] += gfs2_bitcount(rgd,\n\t\t\t\t\t\t  bi->bi_bh->b_data +\n\t\t\t\t\t\t  bi->bi_offset,\n\t\t\t\t\t\t  bi->bi_bytes, x);\n\t}\n\n\tif (count[0] != rgd->rd_free) {\n\t\tgfs2_lm(sdp, \"free data mismatch:  %u != %u\\n\",\n\t\t\tcount[0], rgd->rd_free);\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn;\n\t}\n\n\ttmp = rgd->rd_data - rgd->rd_free - rgd->rd_dinodes;\n\tif (count[1] != tmp) {\n\t\tgfs2_lm(sdp, \"used data mismatch:  %u != %u\\n\",\n\t\t\tcount[1], tmp);\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn;\n\t}\n\n\tif (count[2] + count[3] != rgd->rd_dinodes) {\n\t\tgfs2_lm(sdp, \"used metadata mismatch:  %u != %u\\n\",\n\t\t\tcount[2] + count[3], rgd->rd_dinodes);\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn;\n\t}\n}\n\n \n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}\n\n \n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}\n\n \n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}\n\nvoid check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}\n\nvoid gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}\n\nstatic void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs,\n\t\t    const char *fs_id_buf)\n{\n\tstruct gfs2_inode *ip = container_of(rs, struct gfs2_inode, i_res);\n\n\tgfs2_print_dbg(seq, \"%s  B: n:%llu s:%llu f:%u\\n\",\n\t\t       fs_id_buf,\n\t\t       (unsigned long long)ip->i_no_addr,\n\t\t       (unsigned long long)rs->rs_start,\n\t\t       rs->rs_requested);\n}\n\n \nstatic void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_requested) {\n\t\t \n\t\tBUG_ON(rs->rs_rgd->rd_requested < rs->rs_requested);\n\t\trs->rs_rgd->rd_requested -= rs->rs_requested;\n\n\t\t \n\t\trgd->rd_extfail_pt += rs->rs_requested;\n\t\trs->rs_requested = 0;\n\t}\n}\n\n \nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tBUG_ON(rs->rs_requested);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}\n\n \nvoid gfs2_rs_delete(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (atomic_read(&inode->i_writecount) <= 1)\n\t\tgfs2_rs_deltree(&ip->i_res);\n\tup_write(&ip->i_rw_mutex);\n}\n\n \nstatic void return_all_reservations(struct gfs2_rgrpd *rgd)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_blkreserv *rs;\n\n\tspin_lock(&rgd->rd_rsspin);\n\twhile ((n = rb_first(&rgd->rd_rstree))) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t__rs_deltree(rs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}\n\nvoid gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tif (gl->gl_state != LM_ST_UNLOCKED) {\n\t\t\t\tgfs2_glock_cb(gl, LM_ST_UNLOCKED);\n\t\t\t\tflush_delayed_work(&gl->gl_work);\n\t\t\t}\n\t\t\tgfs2_rgrp_brelse(rgd);\n\t\t\tglock_clear_object(gl, rgd);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\treturn_all_reservations(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\trgd->rd_bits = NULL;\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}\n\n \n\nstatic int compute_bitstructs(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi;\n\tu32 length = rgd->rd_length;  \n\tu32 bytes_left, bytes;\n\tint x;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trgd->rd_bits = kcalloc(length, sizeof(struct gfs2_bitmap), GFP_NOFS);\n\tif (!rgd->rd_bits)\n\t\treturn -ENOMEM;\n\n\tbytes_left = rgd->rd_bitbytes;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\n\t\tbi->bi_flags = 0;\n\t\t \n\t\tif (length == 1) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_bytes = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t \n\t\t} else if (x == 0) {\n\t\t\tbytes = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_bytes = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t \n\t\t} else if (x + 1 == length) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_bytes = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t \n\t\t} else {\n\t\t\tbytes = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_bytes = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t}\n\n\t\tbytes_left -= bytes;\n\t}\n\n\tif (bytes_left) {\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\tbi = rgd->rd_bits + (length - 1);\n\tif ((bi->bi_start + bi->bi_bytes) * GFS2_NBBY != rgd->rd_data) {\n\t\tgfs2_lm(sdp,\n\t\t\t\"ri_addr = %llu\\n\"\n\t\t\t\"ri_length = %u\\n\"\n\t\t\t\"ri_data0 = %llu\\n\"\n\t\t\t\"ri_data = %u\\n\"\n\t\t\t\"ri_bitbytes = %u\\n\"\n\t\t\t\"start=%u len=%u offset=%u\\n\",\n\t\t\t(unsigned long long)rgd->rd_addr,\n\t\t\trgd->rd_length,\n\t\t\t(unsigned long long)rgd->rd_data0,\n\t\t\trgd->rd_data,\n\t\t\trgd->rd_bitbytes,\n\t\t\tbi->bi_start, bi->bi_bytes, bi->bi_offset);\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nu64 gfs2_ri_total(struct gfs2_sbd *sdp)\n{\n\tu64 total_data = 0;\t\n\tstruct inode *inode = sdp->sd_rindex;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tchar buf[sizeof(struct gfs2_rindex)];\n\tint error, rgrps;\n\n\tfor (rgrps = 0;; rgrps++) {\n\t\tloff_t pos = rgrps * sizeof(struct gfs2_rindex);\n\n\t\tif (pos + sizeof(struct gfs2_rindex) > i_size_read(inode))\n\t\t\tbreak;\n\t\terror = gfs2_internal_read(ip, buf, &pos,\n\t\t\t\t\t   sizeof(struct gfs2_rindex));\n\t\tif (error != sizeof(struct gfs2_rindex))\n\t\t\tbreak;\n\t\ttotal_data += be32_to_cpu(((struct gfs2_rindex *)buf)->ri_data);\n\t}\n\treturn total_data;\n}\n\nstatic int rgd_insert(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct rb_node **newn = &sdp->sd_rindex_tree.rb_node, *parent = NULL;\n\n\t \n\twhile (*newn) {\n\t\tstruct gfs2_rgrpd *cur = rb_entry(*newn, struct gfs2_rgrpd,\n\t\t\t\t\t\t  rd_node);\n\n\t\tparent = *newn;\n\t\tif (rgd->rd_addr < cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse if (rgd->rd_addr > cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&rgd->rd_node, parent, newn);\n\trb_insert_color(&rgd->rd_node, &sdp->sd_rindex_tree);\n\tsdp->sd_rgrps++;\n\treturn 0;\n}\n\n \n\nstatic int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\tmutex_init(&rgd->rd_mutex);\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail_glock;\n\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~GFS2_RDF_PREFERRED;\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error) {\n\t\tglock_set_object(rgd->rd_gl, rgd);\n\t\treturn 0;\n\t}\n\n\terror = 0;  \nfail_glock:\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\trgd->rd_bits = NULL;\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}\n\n \nstatic void set_rgrp_preferences(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_rgrpd *rgd, *first;\n\tint i;\n\n\t \n\trgd = gfs2_rgrpd_get_first(sdp);\n\tfor (i = 0; i < sdp->sd_lockstruct.ls_jid; i++)\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\tfirst = rgd;\n\n\tdo {\n\t\trgd->rd_flags |= GFS2_RDF_PREFERRED;\n\t\tfor (i = 0; i < sdp->sd_journals; i++) {\n\t\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t\t\tif (!rgd || rgd == first)\n\t\t\t\tbreak;\n\t\t}\n\t} while (rgd && rgd != first);\n}\n\n \n\nstatic int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (RB_EMPTY_ROOT(&sdp->sd_rindex_tree)) {\n\t\tfs_err(sdp, \"no resource groups found in the file system.\\n\");\n\t\treturn -ENOENT;\n\t}\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}\n\n \n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t \n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}\n\nstatic void gfs2_rgrp_in(struct gfs2_rgrpd *rgd, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\tu32 rg_flags;\n\n\trg_flags = be32_to_cpu(str->rg_flags);\n\trg_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= rg_flags;\n\trgd->rd_free = be32_to_cpu(str->rg_free);\n\trgd->rd_dinodes = be32_to_cpu(str->rg_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(str->rg_igeneration);\n\t \n}\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrpd *next = gfs2_rgrpd_get_next(rgd);\n\tstruct gfs2_rgrp *str = buf;\n\tu32 crc;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tif (next == NULL)\n\t\tstr->rg_skip = 0;\n\telse if (next->rd_addr > rgd->rd_addr)\n\t\tstr->rg_skip = cpu_to_be32(next->rd_addr - rgd->rd_addr);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tstr->rg_data0 = cpu_to_be64(rgd->rd_data0);\n\tstr->rg_data = cpu_to_be32(rgd->rd_data);\n\tstr->rg_bitbytes = cpu_to_be32(rgd->rd_bitbytes);\n\tstr->rg_crc = 0;\n\tcrc = gfs2_disk_hash(buf, sizeof(struct gfs2_rgrp));\n\tstr->rg_crc = cpu_to_be32(crc);\n\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, buf);\n}\n\nstatic int gfs2_rgrp_lvb_valid(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tstruct gfs2_rgrp *str = (struct gfs2_rgrp *)rgd->rd_bits[0].bi_bh->b_data;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tint valid = 1;\n\n\tif (rgl->rl_flags != str->rg_flags) {\n\t\tfs_warn(sdp, \"GFS2: rgd: %llu lvb flag mismatch %u/%u\",\n\t\t\t(unsigned long long)rgd->rd_addr,\n\t\t       be32_to_cpu(rgl->rl_flags), be32_to_cpu(str->rg_flags));\n\t\tvalid = 0;\n\t}\n\tif (rgl->rl_free != str->rg_free) {\n\t\tfs_warn(sdp, \"GFS2: rgd: %llu lvb free mismatch %u/%u\",\n\t\t\t(unsigned long long)rgd->rd_addr,\n\t\t\tbe32_to_cpu(rgl->rl_free), be32_to_cpu(str->rg_free));\n\t\tvalid = 0;\n\t}\n\tif (rgl->rl_dinodes != str->rg_dinodes) {\n\t\tfs_warn(sdp, \"GFS2: rgd: %llu lvb dinode mismatch %u/%u\",\n\t\t\t(unsigned long long)rgd->rd_addr,\n\t\t\tbe32_to_cpu(rgl->rl_dinodes),\n\t\t\tbe32_to_cpu(str->rg_dinodes));\n\t\tvalid = 0;\n\t}\n\tif (rgl->rl_igeneration != str->rg_igeneration) {\n\t\tfs_warn(sdp, \"GFS2: rgd: %llu lvb igen mismatch %llu/%llu\",\n\t\t\t(unsigned long long)rgd->rd_addr,\n\t\t\t(unsigned long long)be64_to_cpu(rgl->rl_igeneration),\n\t\t\t(unsigned long long)be64_to_cpu(str->rg_igeneration));\n\t\tvalid = 0;\n\t}\n\treturn valid;\n}\n\nstatic u32 count_unlinked(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tconst u32 length = rgd->rd_length;\n\tconst u8 *buffer = NULL;\n\tu32 i, goal, count = 0;\n\n\tfor (i = 0, bi = rgd->rd_bits; i < length; i++, bi++) {\n\t\tgoal = 0;\n\t\tbuffer = bi->bi_bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bi->bi_bh));\n\t\twhile (goal < bi->bi_blocks) {\n\t\t\tgoal = gfs2_bitfit(buffer, bi->bi_bytes, goal,\n\t\t\t\t\t   GFS2_BLKST_UNLINKED);\n\t\t\tif (goal == BFITNOENT)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tgoal++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic void rgrp_set_bitmap_flags(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tint x;\n\n\tif (rgd->rd_free) {\n\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\tbi = rgd->rd_bits + x;\n\t\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\t} else {\n\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\tbi = rgd->rd_bits + x;\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\t}\n}\n\n \n\nint gfs2_rgrp_go_instantiate(struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\trgrp_set_bitmap_flags(rgd);\n\trgd->rd_flags |= GFS2_RDF_CHECK;\n\trgd->rd_free_clone = rgd->rd_free;\n\tGLOCK_BUG_ON(rgd->rd_gl, rgd->rd_reserved);\n\t \n\trgd->rd_extfail_pt = rgd->rd_free;\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t} else if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\treturn error;\n}\n\nstatic int update_rgrp_lvb(struct gfs2_rgrpd *rgd, struct gfs2_holder *gh)\n{\n\tu32 rl_flags;\n\n\tif (!test_bit(GLF_INSTANTIATE_NEEDED, &gh->gh_gl->gl_flags))\n\t\treturn 0;\n\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic)\n\t\treturn gfs2_instantiate(gh);\n\n\trl_flags = be32_to_cpu(rgd->rd_rgl->rl_flags);\n\trl_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= (rl_flags | GFS2_RDF_CHECK);\n\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\trgd->rd_free = be32_to_cpu(rgd->rd_rgl->rl_free);\n\trgrp_set_bitmap_flags(rgd);\n\trgd->rd_free_clone = rgd->rd_free;\n\tGLOCK_BUG_ON(rgd->rd_gl, rgd->rd_reserved);\n\t \n\trgd->rd_extfail_pt = rgd->rd_free;\n\trgd->rd_dinodes = be32_to_cpu(rgd->rd_rgl->rl_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(rgd->rd_rgl->rl_igeneration);\n\treturn 0;\n}\n\n \n\nvoid gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd)\n{\n\tint x, length = rgd->rd_length;\n\n\tfor (x = 0; x < length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tif (bi->bi_bh) {\n\t\t\tbrelse(bi->bi_bh);\n\t\t\tbi->bi_bh = NULL;\n\t\t}\n\t}\n\tset_bit(GLF_INSTANTIATE_NEEDED, &rgd->rd_gl->gl_flags);\n}\n\nint gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 blk;\n\tsector_t start = 0;\n\tsector_t nr_blks = 0;\n\tint rv = -EIO;\n\tunsigned int x;\n\tu32 trimmed = 0;\n\tu8 diff;\n\n\tfor (x = 0; x < bi->bi_bytes; x++) {\n\t\tconst u8 *clone = bi->bi_clone ? bi->bi_clone : bi->bi_bh->b_data;\n\t\tclone += bi->bi_offset;\n\t\tclone += x;\n\t\tif (bh) {\n\t\t\tconst u8 *orig = bh->b_data + bi->bi_offset + x;\n\t\t\tdiff = ~(*orig | (*orig >> 1)) & (*clone | (*clone >> 1));\n\t\t} else {\n\t\t\tdiff = ~(*clone | (*clone >> 1));\n\t\t}\n\t\tdiff &= 0x55;\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\t\tblk = offset + ((bi->bi_start + x) * GFS2_NBBY);\n\t\twhile(diff) {\n\t\t\tif (diff & 1) {\n\t\t\t\tif (nr_blks == 0)\n\t\t\t\t\tgoto start_new_extent;\n\t\t\t\tif ((start + nr_blks) != blk) {\n\t\t\t\t\tif (nr_blks >= minlen) {\n\t\t\t\t\t\trv = sb_issue_discard(sb,\n\t\t\t\t\t\t\tstart, nr_blks,\n\t\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\t\t\tif (rv)\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\ttrimmed += nr_blks;\n\t\t\t\t\t}\n\t\t\t\t\tnr_blks = 0;\nstart_new_extent:\n\t\t\t\t\tstart = blk;\n\t\t\t\t}\n\t\t\t\tnr_blks++;\n\t\t\t}\n\t\t\tdiff >>= 2;\n\t\t\tblk++;\n\t\t}\n\t}\n\tif (nr_blks >= minlen) {\n\t\trv = sb_issue_discard(sb, start, nr_blks, GFP_NOFS, 0);\n\t\tif (rv)\n\t\t\tgoto fail;\n\t\ttrimmed += nr_blks;\n\t}\n\tif (ptrimmed)\n\t\t*ptrimmed = trimmed;\n\treturn 0;\n\nfail:\n\tif (sdp->sd_args.ar_discard)\n\t\tfs_warn(sdp, \"error %d on discard request, turning discards off for this filesystem\\n\", rv);\n\tsdp->sd_args.ar_discard = 0;\n\treturn rv;\n}\n\n \n\nint gfs2_fitrim(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct block_device *bdev = sdp->sd_vfs->s_bdev;\n\tstruct buffer_head *bh;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd *rgd_end;\n\tstruct gfs2_holder gh;\n\tstruct fstrim_range r;\n\tint ret = 0;\n\tu64 amt;\n\tu64 trimmed = 0;\n\tu64 start, end, minlen;\n\tunsigned int x;\n\tunsigned bs_shift = sdp->sd_sb.sb_bsize_shift;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\tif (!bdev_max_discard_sectors(bdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\treturn -EFAULT;\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\treturn ret;\n\n\tstart = r.start >> bs_shift;\n\tend = start + (r.len >> bs_shift);\n\tminlen = max_t(u64, r.minlen, sdp->sd_sb.sb_bsize);\n\tminlen = max_t(u64, minlen, bdev_discard_granularity(bdev)) >> bs_shift;\n\n\tif (end <= start || minlen > sdp->sd_max_rg_data)\n\t\treturn -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, start, 0);\n\trgd_end = gfs2_blk2rgrpd(sdp, end, 0);\n\n\tif ((gfs2_rgrpd_get_first(sdp) == gfs2_rgrpd_get_next(rgd_end))\n\t    && (start > rgd_end->rd_data0 + rgd_end->rd_data))\n\t\treturn -EINVAL;  \n\n\twhile (1) {\n\n\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t LM_FLAG_NODE_SCOPE, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(rgd->rd_flags & GFS2_RGF_TRIMMED)) {\n\t\t\t \n\t\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\t\t\trgrp_lock_local(rgd);\n\t\t\t\tret = gfs2_rgrp_send_discards(sdp,\n\t\t\t\t\t\trgd->rd_data0, NULL, bi, minlen,\n\t\t\t\t\t\t&amt);\n\t\t\t\trgrp_unlock_local(rgd);\n\t\t\t\tif (ret) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&gh);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttrimmed += amt;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = gfs2_trans_begin(sdp, RES_RG_HDR, 0);\n\t\t\tif (ret == 0) {\n\t\t\t\tbh = rgd->rd_bits[0].bi_bh;\n\t\t\t\trgrp_lock_local(rgd);\n\t\t\t\trgd->rd_flags |= GFS2_RGF_TRIMMED;\n\t\t\t\tgfs2_trans_add_meta(rgd->rd_gl, bh);\n\t\t\t\tgfs2_rgrp_out(rgd, bh->b_data);\n\t\t\t\trgrp_unlock_local(rgd);\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t}\n\t\t}\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\t\tif (rgd == rgd_end)\n\t\t\tbreak;\n\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t}\n\nout:\n\tr.len = trimmed << bs_shift;\n\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\n \nstatic void rs_insert(struct gfs2_inode *ip)\n{\n\tstruct rb_node **newn, *parent = NULL;\n\tint rc;\n\tstruct gfs2_blkreserv *rs = &ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rs->rs_rgd;\n\n\tBUG_ON(gfs2_rs_active(rs));\n\n\tspin_lock(&rgd->rd_rsspin);\n\tnewn = &rgd->rd_rstree.rb_node;\n\twhile (*newn) {\n\t\tstruct gfs2_blkreserv *cur =\n\t\t\trb_entry(*newn, struct gfs2_blkreserv, rs_node);\n\n\t\tparent = *newn;\n\t\trc = rs_cmp(rs->rs_start, rs->rs_requested, cur);\n\t\tif (rc > 0)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse if (rc < 0)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&rs->rs_node, parent, newn);\n\trb_insert_color(&rs->rs_node, &rgd->rd_rstree);\n\n\t \n\trgd->rd_requested += rs->rs_requested;  \n\tspin_unlock(&rgd->rd_rsspin);\n\ttrace_gfs2_rs(rs, TRACE_RS_INSERT);\n}\n\n \nstatic inline u32 rgd_free(struct gfs2_rgrpd *rgd, struct gfs2_blkreserv *rs)\n{\n\tu32 tot_reserved, tot_free;\n\n\tif (WARN_ON_ONCE(rgd->rd_requested < rs->rs_requested))\n\t\treturn 0;\n\ttot_reserved = rgd->rd_requested - rs->rs_requested;\n\n\tif (rgd->rd_free_clone < tot_reserved)\n\t\ttot_reserved = 0;\n\n\ttot_free = rgd->rd_free_clone - tot_reserved;\n\n\treturn tot_free;\n}\n\n \n\nstatic void rg_mblk_search(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip,\n\t\t\t   const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tu64 goal;\n\tstruct gfs2_blkreserv *rs = &ip->i_res;\n\tu32 extlen;\n\tu32 free_blocks, blocks_available;\n\tint ret;\n\tstruct inode *inode = &ip->i_inode;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tfree_blocks = rgd_free(rgd, rs);\n\tif (rgd->rd_free_clone < rgd->rd_requested)\n\t\tfree_blocks = 0;\n\tblocks_available = rgd->rd_free_clone - rgd->rd_reserved;\n\tif (rgd == rs->rs_rgd)\n\t\tblocks_available += rs->rs_reserved;\n\tspin_unlock(&rgd->rd_rsspin);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\textlen = 1;\n\telse {\n\t\textlen = max_t(u32, atomic_read(&ip->i_sizehint), ap->target);\n\t\textlen = clamp(extlen, (u32)RGRP_RSRV_MINBLKS, free_blocks);\n\t}\n\tif (free_blocks < extlen || blocks_available < extlen)\n\t\treturn;\n\n\t \n\tif (rgrp_contains_block(rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rgd->rd_last_alloc + rgd->rd_data0;\n\n\tif (WARN_ON(gfs2_rbm_from_block(&rbm, goal)))\n\t\treturn;\n\n\tret = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &extlen, &ip->i_res, true);\n\tif (ret == 0) {\n\t\trs->rs_start = gfs2_rbm_to_block(&rbm);\n\t\trs->rs_requested = extlen;\n\t\trs_insert(ip);\n\t} else {\n\t\tif (goal == rgd->rd_last_alloc + rgd->rd_data0)\n\t\t\trgd->rd_last_alloc = 0;\n\t}\n}\n\n \n\nstatic u64 gfs2_next_unreserved_block(struct gfs2_rgrpd *rgd, u64 block,\n\t\t\t\t      u32 length,\n\t\t\t\t      struct gfs2_blkreserv *ignore_rs)\n{\n\tstruct gfs2_blkreserv *rs;\n\tstruct rb_node *n;\n\tint rc;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tn = rgd->rd_rstree.rb_node;\n\twhile (n) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\trc = rs_cmp(block, length, rs);\n\t\tif (rc < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (rc > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (n) {\n\t\twhile (rs_cmp(block, length, rs) == 0 && rs != ignore_rs) {\n\t\t\tblock = rs->rs_start + rs->rs_requested;\n\t\t\tn = n->rb_right;\n\t\t\tif (n == NULL)\n\t\t\t\tbreak;\n\t\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t}\n\t}\n\n\tspin_unlock(&rgd->rd_rsspin);\n\treturn block;\n}\n\n \n\nstatic int gfs2_reservation_check_and_update(struct gfs2_rbm *rbm,\n\t\t\t\t\t     struct gfs2_blkreserv *rs,\n\t\t\t\t\t     u32 minext,\n\t\t\t\t\t     struct gfs2_extent *maxext)\n{\n\tu64 block = gfs2_rbm_to_block(rbm);\n\tu32 extlen = 1;\n\tu64 nblock;\n\n\t \n\tif (minext > 1) {\n\t\textlen = gfs2_free_extlen(rbm, minext);\n\t\tif (extlen <= maxext->len)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tnblock = gfs2_next_unreserved_block(rbm->rgd, block, extlen, rs);\n\tif (nblock == block) {\n\t\tif (!minext || extlen >= minext)\n\t\t\treturn 0;\n\n\t\tif (extlen > maxext->len) {\n\t\t\tmaxext->len = extlen;\n\t\t\tmaxext->rbm = *rbm;\n\t\t}\n\t} else {\n\t\tu64 len = nblock - block;\n\t\tif (len >= (u64)1 << 32)\n\t\t\treturn -E2BIG;\n\t\textlen = len;\n\t}\nfail:\n\tif (gfs2_rbm_add(rbm, extlen))\n\t\treturn -E2BIG;\n\treturn 1;\n}\n\n \n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t struct gfs2_blkreserv *rs, bool nowrap)\n{\n\tbool scan_from_start = rbm->bii == 0 && rbm->offset == 0;\n\tstruct buffer_head *bh;\n\tint last_bii;\n\tu32 offset;\n\tu8 *buffer;\n\tbool wrapped = false;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t \n\tlast_bii = rbm->bii - (rbm->offset == 0);\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_bytes, rbm->offset, state);\n\t\tif (offset == BFITNOENT) {\n\t\t\tif (state == GFS2_BLKST_FREE && rbm->offset == 0)\n\t\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t\tgoto next_bitmap;\n\t\t}\n\t\trbm->offset = offset;\n\t\tif (!rs || !minext)\n\t\t\treturn 0;\n\n\t\tret = gfs2_reservation_check_and_update(rbm, rs, *minext,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0)\n\t\t\tgoto next_iter;\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nnext_bitmap:\t \n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif (rbm->bii == 0) {\n\t\t\tif (wrapped)\n\t\t\t\tbreak;\n\t\t\twrapped = true;\n\t\t\tif (nowrap)\n\t\t\t\tbreak;\n\t\t}\nnext_iter:\n\t\t \n\t\tif (wrapped && rbm->bii > last_bii)\n\t\t\tbreak;\n\t}\n\n\tif (state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t \n\tif (wrapped && (scan_from_start || rbm->bii > last_bii) &&\n\t    *minext < rbm->rgd->rd_extfail_pt)\n\t\trbm->rgd->rd_extfail_pt = *minext - 1;\n\n\t \n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\n \n\nstatic void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip)\n{\n\tu64 block;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl;\n\tstruct gfs2_inode *ip;\n\tint error;\n\tint found = 0;\n\tstruct gfs2_rbm rbm = { .rgd = rgd, .bii = 0, .offset = 0 };\n\n\twhile (1) {\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_UNLINKED, NULL, NULL,\n\t\t\t\t      true);\n\t\tif (error == -ENOSPC)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(error))\n\t\t\tbreak;\n\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + 1))\n\t\t\tbreak;\n\t\tif (*last_unlinked != NO_BLOCK && block <= *last_unlinked)\n\t\t\tcontinue;\n\t\tif (block == skip)\n\t\t\tcontinue;\n\t\t*last_unlinked = block;\n\n\t\terror = gfs2_glock_get(sdp, block, &gfs2_iopen_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t \n\t\tip = gl->gl_object;\n\n\t\tif (ip || !gfs2_queue_try_to_evict(gl))\n\t\t\tgfs2_glock_put(gl);\n\t\telse\n\t\t\tfound++;\n\n\t\t \n\t\tif (found > NR_CPUS)\n\t\t\treturn;\n\t}\n\n\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\treturn;\n}\n\n \n\nstatic bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)\n{\n\tconst struct gfs2_glock *gl = rgd->rd_gl;\n\tconst struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_lkstats *st;\n\tu64 r_dcount, l_dcount;\n\tu64 l_srttb, a_srttb = 0;\n\ts64 srttb_diff;\n\tu64 sqr_diff;\n\tu64 var;\n\tint cpu, nonzero = 0;\n\n\tpreempt_disable();\n\tfor_each_present_cpu(cpu) {\n\t\tst = &per_cpu_ptr(sdp->sd_lkstats, cpu)->lkstats[LM_TYPE_RGRP];\n\t\tif (st->stats[GFS2_LKS_SRTTB]) {\n\t\t\ta_srttb += st->stats[GFS2_LKS_SRTTB];\n\t\t\tnonzero++;\n\t\t}\n\t}\n\tst = &this_cpu_ptr(sdp->sd_lkstats)->lkstats[LM_TYPE_RGRP];\n\tif (nonzero)\n\t\tdo_div(a_srttb, nonzero);\n\tr_dcount = st->stats[GFS2_LKS_DCOUNT];\n\tvar = st->stats[GFS2_LKS_SRTTVARB] +\n\t      gl->gl_stats.stats[GFS2_LKS_SRTTVARB];\n\tpreempt_enable();\n\n\tl_srttb = gl->gl_stats.stats[GFS2_LKS_SRTTB];\n\tl_dcount = gl->gl_stats.stats[GFS2_LKS_DCOUNT];\n\n\tif ((l_dcount < 1) || (r_dcount < 1) || (a_srttb == 0))\n\t\treturn false;\n\n\tsrttb_diff = a_srttb - l_srttb;\n\tsqr_diff = srttb_diff * srttb_diff;\n\n\tvar *= 2;\n\tif (l_dcount < 8 || r_dcount < 8)\n\t\tvar *= 2;\n\tif (loops == 1)\n\t\tvar *= 2;\n\n\treturn ((srttb_diff < 0) && (sqr_diff > var));\n}\n\n \nstatic bool gfs2_rgrp_used_recently(const struct gfs2_blkreserv *rs,\n\t\t\t\t    u64 msecs)\n{\n\tu64 tdiff;\n\n\ttdiff = ktime_to_ns(ktime_sub(ktime_get_real(),\n                            rs->rs_rgd->rd_gl->gl_dstamp));\n\n\treturn tdiff > (msecs * 1000 * 1000);\n}\n\nstatic u32 gfs2_orlov_skip(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 skip;\n\n\tget_random_bytes(&skip, sizeof(skip));\n\treturn skip % sdp->sd_rgrps;\n}\n\nstatic bool gfs2_select_rgrp(struct gfs2_rgrpd **pos, const struct gfs2_rgrpd *begin)\n{\n\tstruct gfs2_rgrpd *rgd = *pos;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgd = gfs2_rgrpd_get_next(rgd);\n\tif (rgd == NULL)\n\t\trgd = gfs2_rgrpd_get_first(sdp);\n\t*pos = rgd;\n\tif (rgd != begin)  \n\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = &ip->i_res;\n\tint error = 0, flags = LM_FLAG_NODE_SCOPE;\n\tbool rg_locked;\n\tu64 last_unlinked = NO_BLOCK;\n\tu32 target = ap->target;\n\tint loops = 0;\n\tu32 free_blocks, blocks_available, skip = 0;\n\n\tBUG_ON(rs->rs_reserved);\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rgd;\n\t} else if (rs->rs_rgd &&\n\t\t   rgrp_contains_block(rs->rs_rgd, ip->i_goal)) {\n\t\tbegin = rs->rs_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\tstruct gfs2_rgrpd *rgd;\n\n\t\trg_locked = gfs2_glock_is_locked_by_me(rs->rs_rgd->rd_gl);\n\t\tif (rg_locked) {\n\t\t\trgrp_lock_local(rs->rs_rgd);\n\t\t} else {\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &ip->i_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\trgrp_lock_local(rs->rs_rgd);\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rgd,\n\t\t\t\t\t\t\t&ip->i_rgd_gh);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\trgrp_unlock_local(rs->rs_rgd);\n\t\t\t\t\tgfs2_glock_dq_uninit(&ip->i_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((rs->rs_rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (loops == 0 && target > rs->rs_rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\terror = gfs2_instantiate(&ip->i_rgd_gh);\n\t\t\tif (error)\n\t\t\t\tgoto skip_rgrp;\n\t\t}\n\n\t\t \n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rgd, ip, ap);\n\n\t\t \n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t \n\t\trgd = rs->rs_rgd;\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\tfree_blocks = rgd_free(rgd, rs);\n\t\tblocks_available = rgd->rd_free_clone - rgd->rd_reserved;\n\t\tif (free_blocks < target || blocks_available < target) {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tgoto check_rgrp;\n\t\t}\n\t\trs->rs_reserved = ap->target;\n\t\tif (rs->rs_reserved > blocks_available)\n\t\t\trs->rs_reserved = blocks_available;\n\t\trgd->rd_reserved += rs->rs_reserved;\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t\trgrp_unlock_local(rs->rs_rgd);\n\t\treturn 0;\ncheck_rgrp:\n\t\t \n\t\tif (rs->rs_rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\trgrp_unlock_local(rs->rs_rgd);\n\n\t\t \n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t \n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_rgd_gh);\nnext_rgrp:\n\t\t \n\t\tif (gfs2_select_rgrp(&rs->rs_rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t \n\t\tloops++;\n\t\t \n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t \n\t\tif (loops == 2) {\n\t\t\tif (ap->min_target)\n\t\t\t\ttarget = ap->min_target;\n\t\t\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t\t       GFS2_LFC_INPLACE_RESERVE);\n\t\t}\n\t}\n\n\treturn -ENOSPC;\n}\n\n \n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = &ip->i_res;\n\n\tif (rs->rs_reserved) {\n\t\tstruct gfs2_rgrpd *rgd = rs->rs_rgd;\n\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\tGLOCK_BUG_ON(rgd->rd_gl, rgd->rd_reserved < rs->rs_reserved);\n\t\trgd->rd_reserved -= rs->rs_reserved;\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t\trs->rs_reserved = 0;\n\t}\n\tif (gfs2_holder_initialized(&ip->i_rgd_gh))\n\t\tgfs2_glock_dq_uninit(&ip->i_rgd_gh);\n}\n\n \nstatic void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,\n\t\t\t     unsigned int *n)\n{\n\tstruct gfs2_rbm pos = { .rgd = rbm->rgd, };\n\tconst unsigned int elen = *n;\n\tu64 block;\n\tint ret;\n\n\t*n = 1;\n\tblock = gfs2_rbm_to_block(rbm);\n\tgfs2_trans_add_meta(rbm->rgd->rd_gl, rbm_bi(rbm)->bi_bh);\n\tgfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\tblock++;\n\twhile (*n < elen) {\n\t\tret = gfs2_rbm_from_block(&pos, block);\n\t\tif (ret || gfs2_testbit(&pos, true) != GFS2_BLKST_FREE)\n\t\t\tbreak;\n\t\tgfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);\n\t\tgfs2_setbit(&pos, true, GFS2_BLKST_USED);\n\t\t(*n)++;\n\t\tblock++;\n\t}\n}\n\n \n\nstatic void rgblk_free(struct gfs2_sbd *sdp, struct gfs2_rgrpd *rgd,\n\t\t       u64 bstart, u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = rgd;\n\tif (WARN_ON_ONCE(gfs2_rbm_from_block(&rbm, bstart)))\n\t\treturn;\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_bytes);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_add(&rbm, 1);\n\t}\n}\n\n \n\nvoid gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_rgrpd *rgd,\n\t\t    const char *fs_id_buf)\n{\n\tstruct gfs2_blkreserv *trs;\n\tconst struct rb_node *n;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tgfs2_print_dbg(seq, \"%s R: n:%llu f:%02x b:%u/%u i:%u q:%u r:%u e:%u\\n\",\n\t\t       fs_id_buf,\n\t\t       (unsigned long long)rgd->rd_addr, rgd->rd_flags,\n\t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\t\t       rgd->rd_requested, rgd->rd_reserved, rgd->rd_extfail_pt);\n\tif (rgd->rd_sbd->sd_args.ar_rgrplvb && rgd->rd_rgl) {\n\t\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\n\t\tgfs2_print_dbg(seq, \"%s  L: f:%02x b:%u i:%u\\n\", fs_id_buf,\n\t\t\t       be32_to_cpu(rgl->rl_flags),\n\t\t\t       be32_to_cpu(rgl->rl_free),\n\t\t\t       be32_to_cpu(rgl->rl_dinodes));\n\t}\n\tfor (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {\n\t\ttrs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\tdump_rs(seq, trs, fs_id_buf);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}\n\nstatic void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tchar fs_id_buf[sizeof(sdp->sd_fsname) + 7];\n\n\tfs_warn(sdp, \"rgrp %llu has an error, marking it readonly until umount\\n\",\n\t\t(unsigned long long)rgd->rd_addr);\n\tfs_warn(sdp, \"umount on all nodes and run fsck.gfs2 to fix the error\\n\");\n\tsprintf(fs_id_buf, \"fsid=%s: \", sdp->sd_fsname);\n\tgfs2_rgrp_dump(NULL, rgd, fs_id_buf);\n\trgd->rd_flags |= GFS2_RDF_ERROR;\n}\n\n \n\nstatic void gfs2_adjust_reservation(struct gfs2_inode *ip,\n\t\t\t\t    const struct gfs2_rbm *rbm, unsigned len)\n{\n\tstruct gfs2_blkreserv *rs = &ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\n\tBUG_ON(rs->rs_reserved < len);\n\trs->rs_reserved -= len;\n\tif (gfs2_rs_active(rs)) {\n\t\tu64 start = gfs2_rbm_to_block(rbm);\n\n\t\tif (rs->rs_start == start) {\n\t\t\tunsigned int rlen;\n\n\t\t\trs->rs_start += len;\n\t\t\trlen = min(rs->rs_requested, len);\n\t\t\trs->rs_requested -= rlen;\n\t\t\trgd->rd_requested -= rlen;\n\t\t\ttrace_gfs2_rs(rs, TRACE_RS_CLAIM);\n\t\t\tif (rs->rs_start < rgd->rd_data0 + rgd->rd_data &&\n\t\t\t    rs->rs_requested)\n\t\t\t\treturn;\n\t\t\t \n\t\t\tatomic_add(RGRP_RSRV_ADDBLKS, &ip->i_sizehint);\n\t\t}\n\t\t__rs_deltree(rs);\n\t}\n}\n\n \n\nstatic void gfs2_set_alloc_start(struct gfs2_rbm *rbm,\n\t\t\t\t const struct gfs2_inode *ip, bool dinode)\n{\n\tu64 goal;\n\n\tif (gfs2_rs_active(&ip->i_res)) {\n\t\tgoal = ip->i_res.rs_start;\n\t} else {\n\t\tif (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))\n\t\t\tgoal = ip->i_goal;\n\t\telse\n\t\t\tgoal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;\n\t}\n\tif (WARN_ON_ONCE(gfs2_rbm_from_block(rbm, goal))) {\n\t\trbm->bii = 0;\n\t\trbm->offset = 0;\n\t}\n}\n\n \n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_res.rs_rgd, };\n\tu64 block;  \n\tu32 minext = 1;\n\tint error = -ENOSPC;\n\n\tBUG_ON(ip->i_res.rs_reserved < *nblocks);\n\n\trgrp_lock_local(rbm.rgd);\n\tif (gfs2_rs_active(&ip->i_res)) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &minext, &ip->i_res, false);\n\t}\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &minext, NULL, false);\n\t}\n\n\t \n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (!dinode) {\n\t\tip->i_goal = block + *nblocks - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tspin_lock(&rbm.rgd->rd_rsspin);\n\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tif (rbm.rgd->rd_free < *nblocks || rbm.rgd->rd_reserved < *nblocks) {\n\t\tfs_warn(sdp, \"nblocks=%u\\n\", *nblocks);\n\t\tspin_unlock(&rbm.rgd->rd_rsspin);\n\t\tgoto rgrp_error;\n\t}\n\tGLOCK_BUG_ON(rbm.rgd->rd_gl, rbm.rgd->rd_reserved < *nblocks);\n\tGLOCK_BUG_ON(rbm.rgd->rd_gl, rbm.rgd->rd_free_clone < *nblocks);\n\tGLOCK_BUG_ON(rbm.rgd->rd_gl, rbm.rgd->rd_free < *nblocks);\n\trbm.rgd->rd_reserved -= *nblocks;\n\trbm.rgd->rd_free_clone -= *nblocks;\n\trbm.rgd->rd_free -= *nblocks;\n\tspin_unlock(&rbm.rgd->rd_rsspin);\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\trgrp_unlock_local(rbm.rgd);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_remove_revoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\trgrp_unlock_local(rbm.rgd);\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}\n\n \n\nvoid __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,\n\t\t\tu64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\trgrp_lock_local(rgd);\n\trgblk_free(sdp, rgd, bstart, blen, GFS2_BLKST_FREE);\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\trgrp_unlock_local(rgd);\n\n\t \n\tif (meta || ip->i_depth || gfs2_is_jdata(ip))\n\t\tgfs2_journal_wipe(ip, bstart, blen);\n}\n\n \n\nvoid gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,\n\t\t    u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, rgd, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}\n\nvoid gfs2_unlink_di(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_rgrpd *rgd;\n\tu64 blkno = ip->i_no_addr;\n\n\trgd = gfs2_blk2rgrpd(sdp, blkno, true);\n\tif (!rgd)\n\t\treturn;\n\trgrp_lock_local(rgd);\n\trgblk_free(sdp, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\ttrace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tbe32_add_cpu(&rgd->rd_rgl->rl_unlinked, 1);\n\trgrp_unlock_local(rgd);\n}\n\nvoid gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgrp_lock_local(rgd);\n\trgblk_free(sdp, rgd, ip->i_no_addr, 1, GFS2_BLKST_FREE);\n\tif (!rgd->rd_dinodes)\n\t\tgfs2_consist_rgrpd(rgd);\n\trgd->rd_dinodes--;\n\trgd->rd_free++;\n\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tbe32_add_cpu(&rgd->rd_rgl->rl_unlinked, -1);\n\trgrp_unlock_local(rgd);\n\n\tgfs2_statfs_change(sdp, 0, +1, -1);\n\ttrace_gfs2_block_alloc(ip, rgd, ip->i_no_addr, 1, GFS2_BLKST_FREE);\n\tgfs2_quota_change(ip, -1, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tgfs2_journal_wipe(ip, ip->i_no_addr, 1);\n}\n\n \n\nint gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr, unsigned int type)\n{\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rgd_gh;\n\tstruct gfs2_rbm rbm;\n\tint error = -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, no_addr, 1);\n\tif (!rgd)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_SHARED, 0, &rgd_gh);\n\tif (error)\n\t\tgoto fail;\n\n\trbm.rgd = rgd;\n\terror = gfs2_rbm_from_block(&rbm, no_addr);\n\tif (!WARN_ON_ONCE(error)) {\n\t\t \n\t\tif (gfs2_testbit(&rbm, false) != type)\n\t\t\terror = -ESTALE;\n\t}\n\n\tgfs2_glock_dq_uninit(&rgd_gh);\n\nfail:\n\treturn error;\n}\n\n \n\nvoid gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\t \n\n\tif (rlist->rl_rgrps) {\n\t\trgd = rlist->rl_rgd[rlist->rl_rgrps - 1];\n\t\tif (rgrp_contains_block(rgd, block))\n\t\t\treturn;\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\t} else {\n\t\trgd = ip->i_res.rs_rgd;\n\t\tif (!rgd || !rgrp_contains_block(rgd, block))\n\t\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\t}\n\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\",\n\t\t       (unsigned long long)block);\n\t\treturn;\n\t}\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++) {\n\t\tif (rlist->rl_rgd[x] == rgd) {\n\t\t\tswap(rlist->rl_rgd[x],\n\t\t\t     rlist->rl_rgd[rlist->rl_rgrps - 1]);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}\n\n \n\nvoid gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist,\n\t\t      unsigned int state, u16 flags)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kmalloc_array(rlist->rl_rgrps,\n\t\t\t\t      sizeof(struct gfs2_holder),\n\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl, state, flags,\n\t\t\t\t &rlist->rl_ghs[x]);\n}\n\n \n\nvoid gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}\n\nvoid rgrp_lock_local(struct gfs2_rgrpd *rgd)\n{\n\tmutex_lock(&rgd->rd_mutex);\n}\n\nvoid rgrp_unlock_local(struct gfs2_rgrpd *rgd)\n{\n\tmutex_unlock(&rgd->rd_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}