{
  "module_name": "inode.c",
  "hash_id": "49cfc4537eb13c3e6de745f9673177ff31474882784570d416fc1d768841cd30",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/inode.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/iomap.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/uaccess.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"acl.h\"\n#include \"bmap.h\"\n#include \"dir.h\"\n#include \"xattr.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"glops.h\"\n\nstatic const struct inode_operations gfs2_file_iops;\nstatic const struct inode_operations gfs2_dir_iops;\nstatic const struct inode_operations gfs2_symlink_iops;\n\n \n\nstatic void gfs2_set_iop(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tumode_t mode = inode->i_mode;\n\n\tif (S_ISREG(mode)) {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_file_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_file_fops;\n\t} else if (S_ISDIR(mode)) {\n\t\tinode->i_op = &gfs2_dir_iops;\n\t\tif (gfs2_localflocks(sdp))\n\t\t\tinode->i_fop = &gfs2_dir_fops_nolock;\n\t\telse\n\t\t\tinode->i_fop = &gfs2_dir_fops;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &gfs2_symlink_iops;\n\t} else {\n\t\tinode->i_op = &gfs2_file_iops;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n}\n\nstatic int iget_test(struct inode *inode, void *opaque)\n{\n\tu64 no_addr = *(u64 *)opaque;\n\n\treturn GFS2_I(inode)->i_no_addr == no_addr;\n}\n\nstatic int iget_set(struct inode *inode, void *opaque)\n{\n\tu64 no_addr = *(u64 *)opaque;\n\n\tGFS2_I(inode)->i_no_addr = no_addr;\n\tinode->i_ino = no_addr;\n\treturn 0;\n}\n\n \n\nstruct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,\n\t\t\t\tu64 no_addr, u64 no_formal_ino,\n\t\t\t\tunsigned int blktype)\n{\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\tgfs2_holder_mark_uninitialized(&i_gh);\n\tinode = iget5_locked(sb, no_addr, iget_test, iget_set, &no_addr);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tip = GFS2_I(inode);\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\t\tstruct gfs2_glock *io_gl;\n\t\tint extra_flags = 0;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_inode_glops, CREATE,\n\t\t\t\t       &ip->i_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\n\t\terror = gfs2_glock_get(sdp, no_addr, &gfs2_iopen_glops, CREATE,\n\t\t\t\t       &io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (blktype == GFS2_BLKST_UNLINKED)\n\t\t\textra_flags |= LM_FLAG_TRY;\n\t\telse\n\t\t\tgfs2_cancel_delete_work(io_gl);\n\t\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED,\n\t\t\t\t\t   GL_EXACT | GL_NOPID | extra_flags,\n\t\t\t\t\t   &ip->i_iopen_gh);\n\t\tgfs2_glock_put(io_gl);\n\t\tif (unlikely(error))\n\t\t\tgoto fail;\n\n\t\tif (type == DT_UNKNOWN || blktype != GFS2_BLKST_FREE) {\n\t\t\t \n\t\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t\t   GL_SKIP, &i_gh);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\n\t\t\terror = -ESTALE;\n\t\t\tif (no_formal_ino &&\n\t\t\t    gfs2_inode_already_deleted(ip->i_gl, no_formal_ino))\n\t\t\t\tgoto fail;\n\n\t\t\tif (blktype != GFS2_BLKST_FREE) {\n\t\t\t\terror = gfs2_check_blk_type(sdp, no_addr,\n\t\t\t\t\t\t\t    blktype);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tset_bit(GLF_INSTANTIATE_NEEDED, &ip->i_gl->gl_flags);\n\n\t\t \n\t\tinode->i_atime.tv_sec = 1LL << (8 * sizeof(inode->i_atime.tv_sec) - 1);\n\t\tinode->i_atime.tv_nsec = 0;\n\n\t\tglock_set_object(ip->i_gl, ip);\n\n\t\tif (type == DT_UNKNOWN) {\n\t\t\t \n\t\t\terror = gfs2_instantiate(&i_gh);\n\t\t\tif (error) {\n\t\t\t\tglock_clear_object(ip->i_gl, ip);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tip->i_no_formal_ino = no_formal_ino;\n\t\t\tinode->i_mode = DT2IF(type);\n\t\t}\n\n\t\tif (gfs2_holder_initialized(&i_gh))\n\t\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tglock_set_object(ip->i_iopen_gh.gh_gl, ip);\n\n\t\tgfs2_set_iop(inode);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (no_formal_ino && ip->i_no_formal_ino &&\n\t    no_formal_ino != ip->i_no_formal_ino) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n\nfail:\n\tif (error == GLR_TRYFAILED)\n\t\terror = -EAGAIN;\n\tif (gfs2_holder_initialized(&ip->i_iopen_gh))\n\t\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\n\tif (gfs2_holder_initialized(&i_gh))\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\tif (ip->i_gl) {\n\t\tgfs2_glock_put(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n\tiget_failed(inode);\n\treturn ERR_PTR(error);\n}\n\n \nstruct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,\n\t\t\t\t  u64 no_formal_ino, unsigned int blktype)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct inode *inode;\n\tint error;\n\n\tinode = gfs2_inode_lookup(sb, DT_UNKNOWN, no_addr, no_formal_ino,\n\t\t\t\t  blktype);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tif (no_formal_ino) {\n\t\terror = -EIO;\n\t\tif (GFS2_I(inode)->i_diskflags & GFS2_DIF_SYSTEM)\n\t\t\tgoto fail_iput;\n\t}\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\treturn ERR_PTR(error);\n}\n\n\nstruct inode *gfs2_lookup_simple(struct inode *dip, const char *name)\n{\n\tstruct qstr qstr;\n\tstruct inode *inode;\n\tgfs2_str2qstr(&qstr, name);\n\tinode = gfs2_lookupi(dip, &qstr, 1);\n\t \n\tif (IS_ERR_OR_NULL(inode))\n\t\treturn inode ? inode : ERR_PTR(-ENOENT);\n\n\t \n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\n\treturn inode;\n}\n\n\n \n\nstruct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,\n\t\t\t   int is_root)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_holder d_gh;\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\n\tgfs2_holder_mark_uninitialized(&d_gh);\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tif ((name->len == 1 && memcmp(name->name, \".\", 1) == 0) ||\n\t    (name->len == 2 && memcmp(name->name, \"..\", 2) == 0 &&\n\t     dir == d_inode(sb->s_root))) {\n\t\tigrab(dir);\n\t\treturn dir;\n\t}\n\n\tif (gfs2_glock_is_locked_by_me(dip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tif (!is_root) {\n\t\terror = gfs2_permission(&nop_mnt_idmap, dir, MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tinode = gfs2_dir_search(dir, name, false);\n\tif (IS_ERR(inode))\n\t\terror = PTR_ERR(inode);\nout:\n\tif (gfs2_holder_initialized(&d_gh))\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\tif (error == -ENOENT)\n\t\treturn NULL;\n\treturn inode ? inode : ERR_PTR(error);\n}\n\n \n\nstatic int create_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t     umode_t mode)\n{\n\tint error;\n\n\terror = gfs2_permission(&nop_mnt_idmap, &dip->i_inode,\n\t\t\t\tMAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!dip->i_inode.i_nlink)\n\t\treturn -ENOENT;\n\n\tif (dip->i_entries == (u32)-1)\n\t\treturn -EFBIG;\n\tif (S_ISDIR(mode) && dip->i_inode.i_nlink == (u32)-1)\n\t\treturn -EMLINK;\n\n\treturn 0;\n}\n\nstatic void munge_mode_uid_gid(const struct gfs2_inode *dip,\n\t\t\t       struct inode *inode)\n{\n\tif (GFS2_SB(&dip->i_inode)->sd_args.ar_suiddir &&\n\t    (dip->i_inode.i_mode & S_ISUID) &&\n\t    !uid_eq(dip->i_inode.i_uid, GLOBAL_ROOT_UID)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISUID;\n\t\telse if (!uid_eq(dip->i_inode.i_uid, current_fsuid()))\n\t\t\tinode->i_mode &= ~07111;\n\t\tinode->i_uid = dip->i_inode.i_uid;\n\t} else\n\t\tinode->i_uid = current_fsuid();\n\n\tif (dip->i_inode.i_mode & S_ISGID) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t\tinode->i_gid = dip->i_inode.i_gid;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n}\n\nstatic int alloc_dinode(struct gfs2_inode *ip, u32 flags, unsigned *dblocks)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = *dblocks, .aflags = flags, };\n\tint error;\n\n\terror = gfs2_quota_lock_check(ip, &ap);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_quota;\n\n\terror = gfs2_trans_begin(sdp, (*dblocks * RES_RG_BIT) + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipreserv;\n\n\terror = gfs2_alloc_blocks(ip, &ip->i_no_addr, dblocks, 1, &ip->i_generation);\n\tif (error)\n\t\tgoto out_trans_end;\n\n\tip->i_no_formal_ino = ip->i_generation;\n\tip->i_inode.i_ino = ip->i_no_addr;\n\tip->i_goal = ip->i_no_addr;\n\tif (*dblocks > 1)\n\t\tip->i_eattr = ip->i_no_addr + 1;\n\nout_trans_end:\n\tgfs2_trans_end(sdp);\nout_ipreserv:\n\tgfs2_inplace_release(ip);\nout_quota:\n\tgfs2_quota_unlock(ip);\nout:\n\treturn error;\n}\n\nstatic void gfs2_init_dir(struct buffer_head *dibh,\n\t\t\t  const struct gfs2_inode *parent)\n{\n\tstruct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;\n\tstruct gfs2_dirent *dent = (struct gfs2_dirent *)(di+1);\n\n\tgfs2_qstr2dirent(&gfs2_qdot, GFS2_DIRENT_SIZE(gfs2_qdot.len), dent);\n\tdent->de_inum = di->di_num;  \n\tdent->de_type = cpu_to_be16(DT_DIR);\n\n\tdent = (struct gfs2_dirent *)((char*)dent + GFS2_DIRENT_SIZE(1));\n\tgfs2_qstr2dirent(&gfs2_qdotdot, dibh->b_size - GFS2_DIRENT_SIZE(1) - sizeof(struct gfs2_dinode), dent);\n\tgfs2_inum_out(parent, dent);\n\tdent->de_type = cpu_to_be16(DT_DIR);\n\t\n}\n\n \n\nstatic void gfs2_init_xattr(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_ea_header *ea;\n\n\tbh = gfs2_meta_new(ip->i_gl, ip->i_eattr);\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\tgfs2_metatype_set(bh, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(bh);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\n\tbrelse(bh);\n}\n\n \n\nstatic void init_dinode(struct gfs2_inode *dip, struct gfs2_inode *ip,\n\t\t\tconst char *symname)\n{\n\tstruct gfs2_dinode *di;\n\tstruct buffer_head *dibh;\n\n\tdibh = gfs2_meta_new(ip->i_gl, ip->i_no_addr);\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_dinode_out(ip, di);\n\n\tdi->di_major = cpu_to_be32(imajor(&ip->i_inode));\n\tdi->di_minor = cpu_to_be32(iminor(&ip->i_inode));\n\tdi->__pad1 = 0;\n\tdi->__pad2 = 0;\n\tdi->__pad3 = 0;\n\tmemset(&di->__pad4, 0, sizeof(di->__pad4));\n\tmemset(&di->di_reserved, 0, sizeof(di->di_reserved));\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tswitch(ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tgfs2_init_dir(dibh, dip);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tmemcpy(dibh->b_data + sizeof(struct gfs2_dinode), symname, ip->i_inode.i_size);\n\t\tbreak;\n\t}\n\n\tset_buffer_uptodate(dibh);\n\tbrelse(dibh);\n}\n\n \n\nstatic unsigned gfs2_trans_da_blks(const struct gfs2_inode *dip,\n\t\t\t\t   const struct gfs2_diradd *da,\n\t\t\t\t   unsigned nr_inodes)\n{\n\treturn da->nr_blocks + gfs2_rg_blocks(dip, da->nr_blocks) +\n\t       (nr_inodes * RES_DINODE) + RES_QUOTA + RES_STATFS;\n}\n\nstatic int link_dinode(struct gfs2_inode *dip, const struct qstr *name,\n\t\t       struct gfs2_inode *ip, struct gfs2_diradd *da)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_alloc_parms ap = { .target = da->nr_blocks, };\n\tint error;\n\n\tif (da->nr_blocks) {\n\t\terror = gfs2_quota_lock_check(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, da, 2), 0);\n\t\tif (error)\n\t\t\tgoto fail_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, RES_LEAF + 2 * RES_DINODE, 0);\n\t\tif (error)\n\t\t\tgoto fail_quota_locks;\n\t}\n\n\terror = gfs2_dir_add(&dip->i_inode, name, ip, da);\n\n\tgfs2_trans_end(sdp);\nfail_ipreserv:\n\tgfs2_inplace_release(dip);\nfail_quota_locks:\n\tgfs2_quota_unlock(dip);\n\treturn error;\n}\n\nstatic int gfs2_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\t    void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = __gfs2_xattr_set(inode, xattr->name, xattr->value,\n\t\t\t\t       xattr->value_len, 0,\n\t\t\t\t       GFS2_EATYPE_SECURITY);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \n\nstatic int gfs2_create_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t     struct file *file,\n\t\t\t     umode_t mode, dev_t dev, const char *symname,\n\t\t\t     unsigned int size, int excl)\n{\n\tconst struct qstr *name = &dentry->d_name;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct gfs2_holder d_gh, gh;\n\tstruct inode *inode = NULL;\n\tstruct gfs2_inode *dip = GFS2_I(dir), *ip;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);\n\tstruct gfs2_glock *io_gl;\n\tint error;\n\tu32 aflags = 0;\n\tunsigned blocks = 1;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\n\tif (!name->len || name->len > GFS2_FNAMESIZE)\n\t\treturn -ENAMETOOLONG;\n\n\terror = gfs2_qa_get(dip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, &d_gh);\n\tif (error)\n\t\tgoto fail;\n\tgfs2_holder_mark_uninitialized(&gh);\n\n\terror = create_ok(dip, name, mode);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\tinode = gfs2_dir_search(dir, &dentry->d_name, !S_ISREG(mode) || excl);\n\terror = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-EISDIR);\n\t\t\tgoto fail_gunlock;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t\terror = 0;\n\t\tif (file) {\n\t\t\tif (S_ISREG(inode->i_mode))\n\t\t\t\terror = finish_open(file, dentry, gfs2_open_common);\n\t\t\telse\n\t\t\t\terror = finish_no_open(file, NULL);\n\t\t}\n\t\tgfs2_glock_dq_uninit(&d_gh);\n\t\tgoto fail;\n\t} else if (error != -ENOENT) {\n\t\tgoto fail_gunlock;\n\t}\n\n\terror = gfs2_diradd_alloc_required(dir, name, &da);\n\tif (error < 0)\n\t\tgoto fail_gunlock;\n\n\tinode = new_inode(sdp->sd_vfs);\n\terror = -ENOMEM;\n\tif (!inode)\n\t\tgoto fail_gunlock;\n\tip = GFS2_I(inode);\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\tgoto fail_gunlock;\n\n\terror = gfs2_qa_get(ip);\n\tif (error)\n\t\tgoto fail_free_acls;\n\n\tinode->i_mode = mode;\n\tset_nlink(inode, S_ISDIR(mode) ? 2 : 1);\n\tinode->i_rdev = dev;\n\tinode->i_size = size;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tmunge_mode_uid_gid(dip, inode);\n\tcheck_and_update_goal(dip);\n\tip->i_goal = dip->i_goal;\n\tip->i_diskflags = 0;\n\tip->i_eattr = 0;\n\tip->i_height = 0;\n\tip->i_depth = 0;\n\tip->i_entries = 0;\n\tip->i_no_addr = 0;  \n\n\tswitch(mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tif ((dip->i_diskflags & GFS2_DIF_INHERIT_JDATA) ||\n\t\t    gfs2_tune_get(sdp, gt_new_files_jdata))\n\t\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tgfs2_set_aops(inode);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tip->i_diskflags |= (dip->i_diskflags & GFS2_DIF_INHERIT_JDATA);\n\t\tip->i_diskflags |= GFS2_DIF_JDATA;\n\t\tip->i_entries = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (dip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\tip->i_diskflags |= GFS2_DIF_SYSTEM;\n\n\tgfs2_set_inode_flags(inode);\n\n\tif ((GFS2_I(d_inode(sdp->sd_root_dir)) == dip) ||\n\t    (dip->i_diskflags & GFS2_DIF_TOPDIR))\n\t\taflags |= GFS2_AF_ORLOV;\n\n\tif (default_acl || acl)\n\t\tblocks++;\n\n\terror = alloc_dinode(ip, aflags, &blocks);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\tgfs2_set_inode_blocks(inode, blocks);\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_inode_glops, CREATE, &ip->i_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\n\terror = gfs2_glock_get(sdp, ip->i_no_addr, &gfs2_iopen_glops, CREATE, &io_gl);\n\tif (error)\n\t\tgoto fail_free_inode;\n\tgfs2_cancel_delete_work(io_gl);\n\nretry:\n\terror = insert_inode_locked4(inode, ip->i_no_addr, iget_test, &ip->i_no_addr);\n\tif (error == -EBUSY)\n\t\tgoto retry;\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT | GL_NOPID,\n\t\t\t\t   &ip->i_iopen_gh);\n\tif (error)\n\t\tgoto fail_gunlock2;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_SKIP, &gh);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto fail_gunlock3;\n\n\tif (blocks > 1)\n\t\tgfs2_init_xattr(ip);\n\tinit_dinode(dip, ip, symname);\n\tgfs2_trans_end(sdp);\n\n\tglock_set_object(ip->i_gl, ip);\n\tglock_set_object(io_gl, ip);\n\tgfs2_set_iop(inode);\n\n\tif (default_acl) {\n\t\terror = __gfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto fail_gunlock4;\n\t\tposix_acl_release(default_acl);\n\t\tdefault_acl = NULL;\n\t}\n\tif (acl) {\n\t\terror = __gfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto fail_gunlock4;\n\t\tposix_acl_release(acl);\n\t\tacl = NULL;\n\t}\n\n\terror = security_inode_init_security(&ip->i_inode, &dip->i_inode, name,\n\t\t\t\t\t     &gfs2_initxattrs, NULL);\n\tif (error)\n\t\tgoto fail_gunlock4;\n\n\terror = link_dinode(dip, name, ip, &da);\n\tif (error)\n\t\tgoto fail_gunlock4;\n\n\tmark_inode_dirty(inode);\n\td_instantiate(dentry, inode);\n\t \n\tif (file) {\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\terror = finish_open(file, dentry, gfs2_open_common);\n\t}\n\tgfs2_glock_dq_uninit(&d_gh);\n\tgfs2_qa_put(ip);\n\tgfs2_glock_dq_uninit(&gh);\n\tgfs2_glock_put(io_gl);\n\tgfs2_qa_put(dip);\n\tunlock_new_inode(inode);\n\treturn error;\n\nfail_gunlock4:\n\tglock_clear_object(ip->i_gl, ip);\n\tglock_clear_object(io_gl, ip);\nfail_gunlock3:\n\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\nfail_gunlock2:\n\tgfs2_glock_put(io_gl);\nfail_free_inode:\n\tif (ip->i_gl) {\n\t\tgfs2_glock_put(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n\tgfs2_rs_deltree(&ip->i_res);\n\tgfs2_qa_put(ip);\nfail_free_acls:\n\tposix_acl_release(default_acl);\n\tposix_acl_release(acl);\nfail_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq_uninit(&d_gh);\n\tif (!IS_ERR_OR_NULL(inode)) {\n\t\tset_bit(GIF_ALLOC_FAILED, &ip->i_flags);\n\t\tclear_nlink(inode);\n\t\tif (ip->i_no_addr)\n\t\t\tmark_inode_dirty(inode);\n\t\tif (inode->i_state & I_NEW)\n\t\t\tiget_failed(inode);\n\t\telse\n\t\t\tiput(inode);\n\t}\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\nfail:\n\tgfs2_qa_put(dip);\n\treturn error;\n}\n\n \n\nstatic int gfs2_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFREG | mode, 0, NULL, 0, excl);\n}\n\n \n\nstatic struct dentry *__gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct file *file)\n{\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tstruct gfs2_holder gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tinode = gfs2_lookupi(dir, &dentry->d_name, 0);\n\tif (inode == NULL) {\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tgl = GFS2_I(inode)->i_gl;\n\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\tif (error) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(error);\n\t}\n\n\td = d_splice_alias(inode, dentry);\n\tif (IS_ERR(d)) {\n\t\tgfs2_glock_dq_uninit(&gh);\n\t\treturn d;\n\t}\n\tif (file && S_ISREG(inode->i_mode))\n\t\terror = finish_open(file, dentry, gfs2_open_common);\n\n\tgfs2_glock_dq_uninit(&gh);\n\tif (error) {\n\t\tdput(d);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn d;\n}\n\nstatic struct dentry *gfs2_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned flags)\n{\n\treturn __gfs2_lookup(dir, dentry, NULL);\n}\n\n \n\nstatic int gfs2_link(struct dentry *old_dentry, struct inode *dir,\n\t\t     struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder d_gh, gh;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_diradd da = { .bh = NULL, .save_loc = 1, };\n\tint error;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = gfs2_qa_get(dip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, &d_gh);\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\n\terror = gfs2_glock_nq(&d_gh);\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_permission(&nop_mnt_idmap, dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_dir_check(dir, &dentry->d_name, NULL);\n\tswitch (error) {\n\tcase -ENOENT:\n\t\tbreak;\n\tcase 0:\n\t\terror = -EEXIST;\n\t\tgoto out_gunlock;\n\tdefault:\n\t\tgoto out_gunlock;\n\t}\n\n\terror = -EINVAL;\n\tif (!dip->i_inode.i_nlink)\n\t\tgoto out_gunlock;\n\terror = -EFBIG;\n\tif (dip->i_entries == (u32)-1)\n\t\tgoto out_gunlock;\n\terror = -EPERM;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\tgoto out_gunlock;\n\terror = -EMLINK;\n\tif (ip->i_inode.i_nlink == (u32)-1)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_diradd_alloc_required(dir, &dentry->d_name, &da);\n\tif (error < 0)\n\t\tgoto out_gunlock;\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(dip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(dip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(dip, &da, 2), 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 2 * RES_DINODE + RES_LEAF, 0);\n\t\tif (error)\n\t\t\tgoto out_ipres;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(dir, &dentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_brelse;\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tinc_nlink(&ip->i_inode);\n\tinode_set_ctime_current(&ip->i_inode);\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\nout_brelse:\n\tbrelse(dibh);\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(dip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(dip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\tgfs2_glock_dq(&gh);\nout_child:\n\tgfs2_glock_dq(&d_gh);\nout_parent:\n\tgfs2_qa_put(dip);\n\tgfs2_holder_uninit(&d_gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}\n\n \n\nstatic int gfs2_unlink_ok(struct gfs2_inode *dip, const struct qstr *name,\n\t\t\t  const struct gfs2_inode *ip)\n{\n\tint error;\n\n\tif (IS_IMMUTABLE(&ip->i_inode) || IS_APPEND(&ip->i_inode))\n\t\treturn -EPERM;\n\n\tif ((dip->i_inode.i_mode & S_ISVTX) &&\n\t    !uid_eq(dip->i_inode.i_uid, current_fsuid()) &&\n\t    !uid_eq(ip->i_inode.i_uid, current_fsuid()) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (IS_APPEND(&dip->i_inode))\n\t\treturn -EPERM;\n\n\terror = gfs2_permission(&nop_mnt_idmap, &dip->i_inode,\n\t\t\t\tMAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn gfs2_dir_check(&dip->i_inode, name, ip);\n}\n\n \n\nstatic int gfs2_unlink_inode(struct gfs2_inode *dip,\n\t\t\t     const struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tint error;\n\n\terror = gfs2_dir_del(dip, dentry);\n\tif (error)\n\t\treturn error;\n\n\tip->i_entries = 0;\n\tinode_set_ctime_current(inode);\n\tif (S_ISDIR(inode->i_mode))\n\t\tclear_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tmark_inode_dirty(inode);\n\tif (inode->i_nlink == 0)\n\t\tgfs2_unlink_di(inode);\n\treturn 0;\n}\n\n\n \n\nstatic int gfs2_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct gfs2_inode *dip = GFS2_I(dir);\n\tstruct gfs2_sbd *sdp = GFS2_SB(dir);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder d_gh, r_gh, gh;\n\tstruct gfs2_rgrpd *rgd;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = -EROFS;\n\n\tgfs2_holder_init(dip->i_gl, LM_ST_EXCLUSIVE, 0, &d_gh);\n\tgfs2_holder_init(ip->i_gl,  LM_ST_EXCLUSIVE, 0, &gh);\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_no_addr, 1);\n\tif (!rgd)\n\t\tgoto out_inodes;\n\n\tgfs2_holder_init(rgd->rd_gl, LM_ST_EXCLUSIVE, LM_FLAG_NODE_SCOPE, &r_gh);\n\n\n\terror = gfs2_glock_nq(&d_gh);\n\tif (error)\n\t\tgoto out_parent;\n\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\tgoto out_child;\n\n\terror = -ENOENT;\n\tif (inode->i_nlink == 0)\n\t\tgoto out_rgrp;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = -ENOTEMPTY;\n\t\tif (ip->i_entries > 2 || inode->i_nlink > 2)\n\t\t\tgoto out_rgrp;\n\t}\n\n\terror = gfs2_glock_nq(&r_gh);  \n\tif (error)\n\t\tgoto out_rgrp;\n\n\terror = gfs2_unlink_ok(dip, &dentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_trans_begin(sdp, 2*RES_DINODE + 3*RES_LEAF + RES_RG_BIT, 0);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_unlink_inode(dip, dentry);\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq(&r_gh);\nout_rgrp:\n\tgfs2_glock_dq(&gh);\nout_child:\n\tgfs2_glock_dq(&d_gh);\nout_parent:\n\tgfs2_holder_uninit(&r_gh);\nout_inodes:\n\tgfs2_holder_uninit(&gh);\n\tgfs2_holder_uninit(&d_gh);\n\treturn error;\n}\n\n \n\nstatic int gfs2_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\tunsigned int size;\n\n\tsize = strlen(symname);\n\tif (size >= gfs2_max_stuffed_size(GFS2_I(dir)))\n\t\treturn -ENAMETOOLONG;\n\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFLNK | S_IRWXUGO, 0, symname, size, 0);\n}\n\n \n\nstatic int gfs2_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tunsigned dsize = gfs2_max_stuffed_size(GFS2_I(dir));\n\treturn gfs2_create_inode(dir, dentry, NULL, S_IFDIR | mode, 0, NULL, dsize, 0);\n}\n\n \n\nstatic int gfs2_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\treturn gfs2_create_inode(dir, dentry, NULL, mode, dev, NULL, 0, 0);\n}\n\n \n\nstatic int gfs2_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode)\n{\n\tstruct dentry *d;\n\tbool excl = !!(flags & O_EXCL);\n\n\tif (!d_in_lookup(dentry))\n\t\tgoto skip_lookup;\n\n\td = __gfs2_lookup(dir, dentry, file);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d != NULL)\n\t\tdentry = d;\n\tif (d_really_is_positive(dentry)) {\n\t\tif (!(file->f_mode & FMODE_OPENED))\n\t\t\treturn finish_no_open(file, d);\n\t\tdput(d);\n\t\treturn excl && (flags & O_CREAT) ? -EEXIST : 0;\n\t}\n\n\tBUG_ON(d != NULL);\n\nskip_lookup:\n\tif (!(flags & O_CREAT))\n\t\treturn -ENOENT;\n\n\treturn gfs2_create_inode(dir, dentry, file, S_IFREG | mode, 0, NULL, 0, excl);\n}\n\n \n\nstatic int gfs2_ok_to_move(struct gfs2_inode *this, struct gfs2_inode *to)\n{\n\tstruct inode *dir = &to->i_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *tmp;\n\tint error = 0;\n\n\tigrab(dir);\n\n\tfor (;;) {\n\t\tif (dir == &this->i_inode) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dir == d_inode(sb->s_root)) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = gfs2_lookupi(dir, &gfs2_qdotdot, 1);\n\t\tif (!tmp) {\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(tmp)) {\n\t\t\terror = PTR_ERR(tmp);\n\t\t\tbreak;\n\t\t}\n\n\t\tiput(dir);\n\t\tdir = tmp;\n\t}\n\n\tiput(dir);\n\n\treturn error;\n}\n\n \n\nstatic int update_moved_ino(struct gfs2_inode *ip, struct gfs2_inode *ndip,\n\t\t\t    int dir_rename)\n{\n\tif (dir_rename)\n\t\treturn gfs2_dir_mvino(ip, &gfs2_qdotdot, ndip, DT_DIR);\n\n\tinode_set_ctime_current(&ip->i_inode);\n\tmark_inode_dirty_sync(&ip->i_inode);\n\treturn 0;\n}\n\n\n \n\nstatic int gfs2_rename(struct inode *odir, struct dentry *odentry,\n\t\t       struct inode *ndir, struct dentry *ndentry)\n{\n\tstruct gfs2_inode *odip = GFS2_I(odir);\n\tstruct gfs2_inode *ndip = GFS2_I(ndir);\n\tstruct gfs2_inode *ip = GFS2_I(d_inode(odentry));\n\tstruct gfs2_inode *nip = NULL;\n\tstruct gfs2_sbd *sdp = GFS2_SB(odir);\n\tstruct gfs2_holder ghs[4], r_gh, rd_gh;\n\tstruct gfs2_rgrpd *nrgd;\n\tunsigned int num_gh;\n\tint dir_rename = 0;\n\tstruct gfs2_diradd da = { .nr_blocks = 0, .save_loc = 0, };\n\tunsigned int x;\n\tint error;\n\n\tgfs2_holder_mark_uninitialized(&r_gh);\n\tgfs2_holder_mark_uninitialized(&rd_gh);\n\tif (d_really_is_positive(ndentry)) {\n\t\tnip = GFS2_I(d_inode(ndentry));\n\t\tif (ip == nip)\n\t\t\treturn 0;\n\t}\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_qa_get(ndip);\n\tif (error)\n\t\treturn error;\n\n\tif (odip != ndip) {\n\t\terror = gfs2_glock_nq_init(sdp->sd_rename_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   0, &r_gh);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (S_ISDIR(ip->i_inode.i_mode)) {\n\t\t\tdir_rename = 1;\n\t\t\t \n\t\t\terror = gfs2_ok_to_move(ip, ndip);\n\t\t\tif (error)\n\t\t\t\tgoto out_gunlock_r;\n\t\t}\n\t}\n\n\tnum_gh = 1;\n\tgfs2_holder_init(odip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC, ghs);\n\tif (odip != ndip) {\n\t\tgfs2_holder_init(ndip->i_gl, LM_ST_EXCLUSIVE,GL_ASYNC,\n\t\t\t\t ghs + num_gh);\n\t\tnum_gh++;\n\t}\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC, ghs + num_gh);\n\tnum_gh++;\n\n\tif (nip) {\n\t\tgfs2_holder_init(nip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC,\n\t\t\t\t ghs + num_gh);\n\t\tnum_gh++;\n\t}\n\n\tfor (x = 0; x < num_gh; x++) {\n\t\terror = gfs2_glock_nq(ghs + x);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\terror = gfs2_glock_async_wait(num_gh, ghs);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tif (nip) {\n\t\t \n\t\tnrgd = gfs2_blk2rgrpd(sdp, nip->i_no_addr, 1);\n\t\tif (!nrgd) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out_gunlock;\n\t\t}\n\t\terror = gfs2_glock_nq_init(nrgd->rd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   LM_FLAG_NODE_SCOPE, &rd_gh);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\terror = -ENOENT;\n\tif (ip->i_inode.i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\t \n\n\terror = gfs2_unlink_ok(odip, &odentry->d_name, ip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\t \n\n\tif (nip) {\n\t\terror = gfs2_unlink_ok(ndip, &ndentry->d_name, nip);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\tif (nip->i_inode.i_nlink == 0) {\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out_gunlock;\n\t\t}\n\n\t\tif (S_ISDIR(nip->i_inode.i_mode)) {\n\t\t\tif (nip->i_entries < 2) {\n\t\t\t\tgfs2_consist_inode(nip);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (nip->i_entries > 2) {\n\t\t\t\terror = -ENOTEMPTY;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t} else {\n\t\terror = gfs2_permission(&nop_mnt_idmap, ndir,\n\t\t\t\t\tMAY_WRITE | MAY_EXEC);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_dir_check(ndir, &ndentry->d_name, NULL);\n\t\tswitch (error) {\n\t\tcase -ENOENT:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\terror = -EEXIST;\n\t\t\tgoto out_gunlock;\n\t\tdefault:\n\t\t\tgoto out_gunlock;\n\t\t}\n\n\t\tif (odip != ndip) {\n\t\t\tif (!ndip->i_inode.i_nlink) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (ndip->i_entries == (u32)-1) {\n\t\t\t\terror = -EFBIG;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t\tif (S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t    ndip->i_inode.i_nlink == (u32)-1) {\n\t\t\t\terror = -EMLINK;\n\t\t\t\tgoto out_gunlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (dir_rename) {\n\t\terror = gfs2_permission(&nop_mnt_idmap, d_inode(odentry),\n\t\t\t\t\tMAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (nip == NULL) {\n\t\terror = gfs2_diradd_alloc_required(ndir, &ndentry->d_name, &da);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\tif (da.nr_blocks) {\n\t\tstruct gfs2_alloc_parms ap = { .target = da.nr_blocks, };\n\t\terror = gfs2_quota_lock_check(ndip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\n\t\terror = gfs2_inplace_reserve(ndip, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\n\t\terror = gfs2_trans_begin(sdp, gfs2_trans_da_blks(ndip, &da, 4) +\n\t\t\t\t\t 4 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_ipreserv;\n\t} else {\n\t\terror = gfs2_trans_begin(sdp, 4 * RES_DINODE +\n\t\t\t\t\t 5 * RES_LEAF + 4, 0);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\t \n\n\tif (nip)\n\t\terror = gfs2_unlink_inode(ndip, ndentry);\n\n\terror = update_moved_ino(ip, ndip, dir_rename);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_del(odip, odentry);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_add(ndir, &ndentry->d_name, ip, &da);\n\tif (error)\n\t\tgoto out_end_trans;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipreserv:\n\tif (da.nr_blocks)\n\t\tgfs2_inplace_release(ndip);\nout_gunlock_q:\n\tif (da.nr_blocks)\n\t\tgfs2_quota_unlock(ndip);\nout_gunlock:\n\tgfs2_dir_no_add(&da);\n\tif (gfs2_holder_initialized(&rd_gh))\n\t\tgfs2_glock_dq_uninit(&rd_gh);\n\n\twhile (x--) {\n\t\tif (gfs2_holder_queued(ghs + x))\n\t\t\tgfs2_glock_dq(ghs + x);\n\t\tgfs2_holder_uninit(ghs + x);\n\t}\nout_gunlock_r:\n\tif (gfs2_holder_initialized(&r_gh))\n\t\tgfs2_glock_dq_uninit(&r_gh);\nout:\n\tgfs2_qa_put(ndip);\n\treturn error;\n}\n\n \n\nstatic int gfs2_exchange(struct inode *odir, struct dentry *odentry,\n\t\t\t struct inode *ndir, struct dentry *ndentry,\n\t\t\t unsigned int flags)\n{\n\tstruct gfs2_inode *odip = GFS2_I(odir);\n\tstruct gfs2_inode *ndip = GFS2_I(ndir);\n\tstruct gfs2_inode *oip = GFS2_I(odentry->d_inode);\n\tstruct gfs2_inode *nip = GFS2_I(ndentry->d_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(odir);\n\tstruct gfs2_holder ghs[4], r_gh;\n\tunsigned int num_gh;\n\tunsigned int x;\n\tumode_t old_mode = oip->i_inode.i_mode;\n\tumode_t new_mode = nip->i_inode.i_mode;\n\tint error;\n\n\tgfs2_holder_mark_uninitialized(&r_gh);\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (odip != ndip) {\n\t\terror = gfs2_glock_nq_init(sdp->sd_rename_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   0, &r_gh);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (S_ISDIR(old_mode)) {\n\t\t\t \n\t\t\terror = gfs2_ok_to_move(oip, ndip);\n\t\t\tif (error)\n\t\t\t\tgoto out_gunlock_r;\n\t\t}\n\n\t\tif (S_ISDIR(new_mode)) {\n\t\t\t \n\t\t\terror = gfs2_ok_to_move(nip, odip);\n\t\t\tif (error)\n\t\t\t\tgoto out_gunlock_r;\n\t\t}\n\t}\n\n\tnum_gh = 1;\n\tgfs2_holder_init(odip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC, ghs);\n\tif (odip != ndip) {\n\t\tgfs2_holder_init(ndip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC,\n\t\t\t\t ghs + num_gh);\n\t\tnum_gh++;\n\t}\n\tgfs2_holder_init(oip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC, ghs + num_gh);\n\tnum_gh++;\n\n\tgfs2_holder_init(nip->i_gl, LM_ST_EXCLUSIVE, GL_ASYNC, ghs + num_gh);\n\tnum_gh++;\n\n\tfor (x = 0; x < num_gh; x++) {\n\t\terror = gfs2_glock_nq(ghs + x);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\n\terror = gfs2_glock_async_wait(num_gh, ghs);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = -ENOENT;\n\tif (oip->i_inode.i_nlink == 0 || nip->i_inode.i_nlink == 0)\n\t\tgoto out_gunlock;\n\n\terror = gfs2_unlink_ok(odip, &odentry->d_name, oip);\n\tif (error)\n\t\tgoto out_gunlock;\n\terror = gfs2_unlink_ok(ndip, &ndentry->d_name, nip);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tif (S_ISDIR(old_mode)) {\n\t\terror = gfs2_permission(&nop_mnt_idmap, odentry->d_inode,\n\t\t\t\t\tMAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\tif (S_ISDIR(new_mode)) {\n\t\terror = gfs2_permission(&nop_mnt_idmap, ndentry->d_inode,\n\t\t\t\t\tMAY_WRITE);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t}\n\terror = gfs2_trans_begin(sdp, 4 * RES_DINODE + 4 * RES_LEAF, 0);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\terror = update_moved_ino(oip, ndip, S_ISDIR(old_mode));\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = update_moved_ino(nip, odip, S_ISDIR(new_mode));\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_mvino(ndip, &ndentry->d_name, oip,\n\t\t\t       IF2DT(old_mode));\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_dir_mvino(odip, &odentry->d_name, nip,\n\t\t\t       IF2DT(new_mode));\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (odip != ndip) {\n\t\tif (S_ISDIR(new_mode) && !S_ISDIR(old_mode)) {\n\t\t\tinc_nlink(&odip->i_inode);\n\t\t\tdrop_nlink(&ndip->i_inode);\n\t\t} else if (S_ISDIR(old_mode) && !S_ISDIR(new_mode)) {\n\t\t\tinc_nlink(&ndip->i_inode);\n\t\t\tdrop_nlink(&odip->i_inode);\n\t\t}\n\t}\n\tmark_inode_dirty(&ndip->i_inode);\n\tif (odip != ndip)\n\t\tmark_inode_dirty(&odip->i_inode);\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock:\n\twhile (x--) {\n\t\tif (gfs2_holder_queued(ghs + x))\n\t\t\tgfs2_glock_dq(ghs + x);\n\t\tgfs2_holder_uninit(ghs + x);\n\t}\nout_gunlock_r:\n\tif (gfs2_holder_initialized(&r_gh))\n\t\tgfs2_glock_dq_uninit(&r_gh);\nout:\n\treturn error;\n}\n\nstatic int gfs2_rename2(struct mnt_idmap *idmap, struct inode *odir,\n\t\t\tstruct dentry *odentry, struct inode *ndir,\n\t\t\tstruct dentry *ndentry, unsigned int flags)\n{\n\tflags &= ~RENAME_NOREPLACE;\n\n\tif (flags & ~RENAME_EXCHANGE)\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\treturn gfs2_exchange(odir, odentry, ndir, ndentry, flags);\n\n\treturn gfs2_rename(odir, odentry, ndir, ndentry);\n}\n\n \n\nstatic const char *gfs2_get_link(struct dentry *dentry,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct delayed_call *done)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tstruct buffer_head *dibh;\n\tunsigned int size;\n\tchar *buf;\n\tint error;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\terror = gfs2_glock_nq(&i_gh);\n\tif (error) {\n\t\tgfs2_holder_uninit(&i_gh);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tsize = (unsigned int)i_size_read(&ip->i_inode);\n\tif (size == 0) {\n\t\tgfs2_consist_inode(ip);\n\t\tbuf = ERR_PTR(-EIO);\n\t\tgoto out;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error) {\n\t\tbuf = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tbuf = kzalloc(size + 1, GFP_NOFS);\n\tif (!buf)\n\t\tbuf = ERR_PTR(-ENOMEM);\n\telse\n\t\tmemcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);\n\tbrelse(dibh);\nout:\n\tgfs2_glock_dq_uninit(&i_gh);\n\tif (!IS_ERR(buf))\n\t\tset_delayed_call(done, kfree_link, buf);\n\treturn buf;\n}\n\n \n\nint gfs2_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t    int mask)\n{\n\tint may_not_block = mask & MAY_NOT_BLOCK;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_holder i_gh;\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\tgfs2_holder_mark_uninitialized(&i_gh);\n\tip = GFS2_I(inode);\n\tgl = rcu_dereference_check(ip->i_gl, !may_not_block);\n\tif (unlikely(!gl)) {\n\t\t \n\t\tWARN_ON_ONCE(!may_not_block);\n\t\treturn -ECHILD;\n        }\n\tif (gfs2_glock_is_locked_by_me(gl) == NULL) {\n\t\tif (may_not_block)\n\t\t\treturn -ECHILD;\n\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n\t\terror = -EPERM;\n\telse\n\t\terror = generic_permission(&nop_mnt_idmap, inode, mask);\n\tif (gfs2_holder_initialized(&i_gh))\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}\n\nstatic int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tsetattr_copy(&nop_mnt_idmap, inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}\n\nstatic int setattr_chown(struct inode *inode, struct iattr *attr)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tkuid_t ouid, nuid;\n\tkgid_t ogid, ngid;\n\tint error;\n\tstruct gfs2_alloc_parms ap;\n\n\touid = inode->i_uid;\n\togid = inode->i_gid;\n\tnuid = attr->ia_uid;\n\tngid = attr->ia_gid;\n\n\tif (!(attr->ia_valid & ATTR_UID) || uid_eq(ouid, nuid))\n\t\touid = nuid = NO_UID_QUOTA_CHANGE;\n\tif (!(attr->ia_valid & ATTR_GID) || gid_eq(ogid, ngid))\n\t\togid = ngid = NO_GID_QUOTA_CHANGE;\n\terror = gfs2_qa_get(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_quota_lock(ip, nuid, ngid);\n\tif (error)\n\t\tgoto out;\n\n\tap.target = gfs2_get_inode_blocks(&ip->i_inode);\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\terror = gfs2_quota_check(ip, nuid, ngid, &ap);\n\t\tif (error)\n\t\t\tgoto out_gunlock_q;\n\t}\n\n\terror = gfs2_trans_begin(sdp, RES_DINODE + 2 * RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tif (!uid_eq(ouid, NO_UID_QUOTA_CHANGE) ||\n\t    !gid_eq(ogid, NO_GID_QUOTA_CHANGE)) {\n\t\tgfs2_quota_change(ip, -(s64)ap.target, ouid, ogid);\n\t\tgfs2_quota_change(ip, ap.target, nuid, ngid);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\nout:\n\tgfs2_qa_put(ip);\n\treturn error;\n}\n\n \n\nstatic int gfs2_setattr(struct mnt_idmap *idmap,\n\t\t\tstruct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\terror = gfs2_qa_get(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\terror = may_setattr(&nop_mnt_idmap, inode, attr->ia_valid);\n\tif (error)\n\t\tgoto error;\n\n\terror = setattr_prepare(&nop_mnt_idmap, dentry, attr);\n\tif (error)\n\t\tgoto error;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\terror = gfs2_setattr_size(inode, attr->ia_size);\n\telse if (attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\terror = setattr_chown(inode, attr);\n\telse {\n\t\terror = gfs2_setattr_simple(inode, attr);\n\t\tif (!error && attr->ia_valid & ATTR_MODE)\n\t\t\terror = posix_acl_chmod(&nop_mnt_idmap, dentry,\n\t\t\t\t\t\tinode->i_mode);\n\t}\n\nerror:\n\tif (!error)\n\t\tmark_inode_dirty(inode);\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\tgfs2_qa_put(ip);\n\treturn error;\n}\n\n \n\nstatic int gfs2_getattr(struct mnt_idmap *idmap,\n\t\t\tconst struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tu32 gfsflags;\n\tint error;\n\n\tgfs2_holder_mark_uninitialized(&gh);\n\tif (gfs2_glock_is_locked_by_me(ip->i_gl) == NULL) {\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tgfsflags = ip->i_diskflags;\n\tif (gfsflags & GFS2_DIF_APPENDONLY)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (gfsflags & GFS2_DIF_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\n\tstat->attributes_mask |= (STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_COMPRESSED |\n\t\t\t\t  STATX_ATTR_ENCRYPTED |\n\t\t\t\t  STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_NODUMP);\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\treturn 0;\n}\n\nstatic int gfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tinode_lock_shared(inode);\n\n\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = iomap_fiemap(inode, fieinfo, start, len, &gfs2_iomap_ops);\n\n\tgfs2_glock_dq_uninit(&gh);\n\nout:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}\n\nloff_t gfs2_seek_data(struct file *file, loff_t offset)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tloff_t ret;\n\n\tinode_lock_shared(inode);\n\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (!ret)\n\t\tret = iomap_seek_data(inode, offset, &gfs2_iomap_ops);\n\tgfs2_glock_dq_uninit(&gh);\n\tinode_unlock_shared(inode);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn vfs_setpos(file, ret, inode->i_sb->s_maxbytes);\n}\n\nloff_t gfs2_seek_hole(struct file *file, loff_t offset)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tloff_t ret;\n\n\tinode_lock_shared(inode);\n\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tif (!ret)\n\t\tret = iomap_seek_hole(inode, offset, &gfs2_iomap_ops);\n\tgfs2_glock_dq_uninit(&gh);\n\tinode_unlock_shared(inode);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn vfs_setpos(file, ret, inode->i_sb->s_maxbytes);\n}\n\nstatic int gfs2_update_time(struct inode *inode, int flags)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder *gh;\n\tint error;\n\n\tgh = gfs2_glock_is_locked_by_me(gl);\n\tif (gh && !gfs2_glock_is_held_excl(gl)) {\n\t\tgfs2_glock_dq(gh);\n\t\tgfs2_holder_reinit(LM_ST_EXCLUSIVE, 0, gh);\n\t\terror = gfs2_glock_nq(gh);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tgeneric_update_time(inode, flags);\n\treturn 0;\n}\n\nstatic const struct inode_operations gfs2_file_iops = {\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.listxattr = gfs2_listxattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_inode_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.update_time = gfs2_update_time,\n\t.fileattr_get = gfs2_fileattr_get,\n\t.fileattr_set = gfs2_fileattr_set,\n};\n\nstatic const struct inode_operations gfs2_dir_iops = {\n\t.create = gfs2_create,\n\t.lookup = gfs2_lookup,\n\t.link = gfs2_link,\n\t.unlink = gfs2_unlink,\n\t.symlink = gfs2_symlink,\n\t.mkdir = gfs2_mkdir,\n\t.rmdir = gfs2_unlink,\n\t.mknod = gfs2_mknod,\n\t.rename = gfs2_rename2,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.listxattr = gfs2_listxattr,\n\t.fiemap = gfs2_fiemap,\n\t.get_inode_acl = gfs2_get_acl,\n\t.set_acl = gfs2_set_acl,\n\t.update_time = gfs2_update_time,\n\t.atomic_open = gfs2_atomic_open,\n\t.fileattr_get = gfs2_fileattr_get,\n\t.fileattr_set = gfs2_fileattr_set,\n};\n\nstatic const struct inode_operations gfs2_symlink_iops = {\n\t.get_link = gfs2_get_link,\n\t.permission = gfs2_permission,\n\t.setattr = gfs2_setattr,\n\t.getattr = gfs2_getattr,\n\t.listxattr = gfs2_listxattr,\n\t.fiemap = gfs2_fiemap,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}