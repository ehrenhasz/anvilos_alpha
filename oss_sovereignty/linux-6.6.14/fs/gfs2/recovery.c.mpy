{
  "module_name": "recovery.c",
  "hash_id": "5cbef5ffd000b47907f4f866857d80ae413ca6abb26f3fd678062cf94583a02c",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/recovery.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/crc32c.h>\n#include <linux/ktime.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"log.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"recovery.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"dir.h\"\n\nstruct workqueue_struct *gfs2_recovery_wq;\n\nint gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\textlen = 32;\n\terror = gfs2_get_extent(&ip->i_inode, blk, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}\n\nint gfs2_revoke_add(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr = NULL, *iter;\n\n\tlist_for_each_entry(iter, head, rr_list) {\n\t\tif (iter->rr_blkno == blkno) {\n\t\t\trr = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rr) {\n\t\trr->rr_where = where;\n\t\treturn 0;\n\t}\n\n\trr = kmalloc(sizeof(struct gfs2_revoke_replay), GFP_NOFS);\n\tif (!rr)\n\t\treturn -ENOMEM;\n\n\trr->rr_blkno = blkno;\n\trr->rr_where = where;\n\tlist_add(&rr->rr_list, head);\n\n\treturn 1;\n}\n\nint gfs2_revoke_check(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct gfs2_revoke_replay *rr = NULL, *iter;\n\tint wrap, a, b, revoke;\n\n\tlist_for_each_entry(iter, &jd->jd_revoke_list, rr_list) {\n\t\tif (iter->rr_blkno == blkno) {\n\t\t\trr = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rr)\n\t\treturn 0;\n\n\twrap = (rr->rr_where < jd->jd_replay_tail);\n\ta = (jd->jd_replay_tail < where);\n\tb = (where < rr->rr_where);\n\trevoke = (wrap) ? (a || b) : (a && b);\n\n\treturn revoke;\n}\n\nvoid gfs2_revoke_clean(struct gfs2_jdesc *jd)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr;\n\n\twhile (!list_empty(head)) {\n\t\trr = list_first_entry(head, struct gfs2_revoke_replay, rr_list);\n\t\tlist_del(&rr->rr_list);\n\t\tkfree(rr);\n\t}\n}\n\nint __get_log_header(struct gfs2_sbd *sdp, const struct gfs2_log_header *lh,\n\t\t     unsigned int blkno, struct gfs2_log_header_host *head)\n{\n\tu32 hash, crc;\n\n\tif (lh->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||\n\t    lh->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH) ||\n\t    (blkno && be32_to_cpu(lh->lh_blkno) != blkno))\n\t\treturn 1;\n\n\thash = crc32(~0, lh, LH_V1_SIZE - 4);\n\thash = ~crc32_le_shift(hash, 4);  \n\n\tif (be32_to_cpu(lh->lh_hash) != hash)\n\t\treturn 1;\n\n\tcrc = crc32c(~0, (void *)lh + LH_V1_SIZE + 4,\n\t\t     sdp->sd_sb.sb_bsize - LH_V1_SIZE - 4);\n\n\tif ((lh->lh_crc != 0 && be32_to_cpu(lh->lh_crc) != crc))\n\t\treturn 1;\n\n\thead->lh_sequence = be64_to_cpu(lh->lh_sequence);\n\thead->lh_flags = be32_to_cpu(lh->lh_flags);\n\thead->lh_tail = be32_to_cpu(lh->lh_tail);\n\thead->lh_blkno = be32_to_cpu(lh->lh_blkno);\n\n\thead->lh_local_total = be64_to_cpu(lh->lh_local_total);\n\thead->lh_local_free = be64_to_cpu(lh->lh_local_free);\n\thead->lh_local_dinodes = be64_to_cpu(lh->lh_local_dinodes);\n\n\treturn 0;\n}\n \n\nstatic int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\terror = __get_log_header(sdp, (const struct gfs2_log_header *)bh->b_data,\n\t\t\t\t blk, head);\n\tbrelse(bh);\n\n\treturn error;\n}\n\n \n\nstatic int foreach_descriptor(struct gfs2_jdesc *jd, u32 start,\n\t\t\t      unsigned int end, int pass)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_descriptor *ld;\n\tint error = 0;\n\tu32 length;\n\t__be64 *ptr;\n\tunsigned int offset = sizeof(struct gfs2_log_descriptor);\n\toffset += sizeof(__be64) - 1;\n\toffset &= ~(sizeof(__be64) - 1);\n\n\twhile (start != end) {\n\t\terror = gfs2_replay_read_block(jd, start, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (gfs2_meta_check(sdp, bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tld = (struct gfs2_log_descriptor *)bh->b_data;\n\t\tlength = be32_to_cpu(ld->ld_length);\n\n\t\tif (be32_to_cpu(ld->ld_header.mh_type) == GFS2_METATYPE_LH) {\n\t\t\tstruct gfs2_log_header_host lh;\n\t\t\terror = get_log_header(jd, start, &lh);\n\t\t\tif (!error) {\n\t\t\t\tgfs2_replay_incr_blk(jd, &start);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 1) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\t\terror = -EIO;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t} else if (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_LD)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tptr = (__be64 *)(bh->b_data + offset);\n\t\terror = lops_scan_elements(jd, start, ld, ptr, pass);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (length--)\n\t\t\tgfs2_replay_incr_blk(jd, &start);\n\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void clean_journal(struct gfs2_jdesc *jd,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu32 lblock = head->lh_blkno;\n\n\tgfs2_replay_incr_blk(jd, &lblock);\n\tgfs2_write_log_header(sdp, jd, head->lh_sequence + 1, 0, lblock,\n\t\t\t      GFS2_LOG_HEAD_UNMOUNT | GFS2_LOG_HEAD_RECOVERY,\n\t\t\t      REQ_PREFLUSH | REQ_FUA | REQ_META | REQ_SYNC);\n\tif (jd->jd_jid == sdp->sd_lockstruct.ls_jid) {\n\t\tsdp->sd_log_flush_head = lblock;\n\t\tgfs2_log_incr_head(sdp);\n\t}\n}\n\n\nstatic void gfs2_recovery_done(struct gfs2_sbd *sdp, unsigned int jid,\n                               unsigned int message)\n{\n\tchar env_jid[20];\n\tchar env_status[20];\n\tchar *envp[] = { env_jid, env_status, NULL };\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n        ls->ls_recover_jid_done = jid;\n        ls->ls_recover_jid_status = message;\n\tsprintf(env_jid, \"JID=%u\", jid);\n\tsprintf(env_status, \"RECOVERY=%s\",\n\t\tmessage == LM_RD_SUCCESS ? \"Done\" : \"Failed\");\n        kobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_recovery_result)\n\t\tsdp->sd_lockstruct.ls_ops->lm_recovery_result(sdp, jid, message);\n}\n\n \nstatic int update_statfs_inode(struct gfs2_jdesc *jd,\n\t\t\t       struct gfs2_log_header_host *head,\n\t\t\t       struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct gfs2_inode *ip;\n\tstruct buffer_head *bh;\n\tstruct gfs2_statfs_change_host sc;\n\tint error = 0;\n\n\tBUG_ON(!inode);\n\tip = GFS2_I(inode);\n\n\terror = gfs2_meta_inode_buffer(ip, &bh);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\n\tif (head) {  \n\t\tgfs2_statfs_change_in(&sc, bh->b_data + sizeof(struct gfs2_dinode));\n\t\tsc.sc_total += head->lh_local_total;\n\t\tsc.sc_free += head->lh_local_free;\n\t\tsc.sc_dinodes += head->lh_local_dinodes;\n\t\tgfs2_statfs_change_out(&sc, bh->b_data + sizeof(struct gfs2_dinode));\n\n\t\tfs_info(sdp, \"jid=%u: Updated master statfs Total:%lld, \"\n\t\t\t\"Free:%lld, Dinodes:%lld after change \"\n\t\t\t\"[%+lld,%+lld,%+lld]\\n\", jd->jd_jid, sc.sc_total,\n\t\t\tsc.sc_free, sc.sc_dinodes, head->lh_local_total,\n\t\t\thead->lh_local_free, head->lh_local_dinodes);\n\t} else {  \n\t\tmemset(bh->b_data + sizeof(struct gfs2_dinode), 0,\n\t\t       sizeof(struct gfs2_statfs_change));\n\t\t \n\t\tif (jd->jd_jid == sdp->sd_lockstruct.ls_jid) {\n\t\t\tmemset(&sdp->sd_statfs_local, 0,\n\t\t\t       sizeof(struct gfs2_statfs_change_host));\n\t\t}\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tgfs2_inode_metasync(ip->i_gl);\n\nout:\n\treturn error;\n}\n\n \nstatic void recover_local_statfs(struct gfs2_jdesc *jd,\n\t\t\t\t struct gfs2_log_header_host *head)\n{\n\tint error;\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\n\tif (!head->lh_local_total && !head->lh_local_free\n\t    && !head->lh_local_dinodes)  \n\t\tgoto zero_local;\n\n\t  \n\terror = update_statfs_inode(jd, head, sdp->sd_statfs_inode);\n\tif (error)\n\t\tgoto out;\n\nzero_local:\n\t \n\terror = update_statfs_inode(jd, NULL,\n\t\t\t\t    find_local_statfs_inode(sdp, jd->jd_jid));\nout:\n\treturn;\n}\n\nvoid gfs2_recover_func(struct work_struct *work)\n{\n\tstruct gfs2_jdesc *jd = container_of(work, struct gfs2_jdesc, jd_work);\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_holder j_gh, ji_gh;\n\tktime_t t_start, t_jlck, t_jhd, t_tlck, t_rep;\n\tint ro = 0;\n\tunsigned int pass;\n\tint error = 0;\n\tint jlocked = 0;\n\n\tif (gfs2_withdrawn(sdp)) {\n\t\tfs_err(sdp, \"jid=%u: Recovery not attempted due to withdraw.\\n\",\n\t\t       jd->jd_jid);\n\t\tgoto fail;\n\t}\n\tt_start = ktime_get();\n\tif (sdp->sd_args.ar_spectator)\n\t\tgoto fail;\n\tif (jd->jd_jid != sdp->sd_lockstruct.ls_jid) {\n\t\tfs_info(sdp, \"jid=%u: Trying to acquire journal glock...\\n\",\n\t\t\tjd->jd_jid);\n\t\tjlocked = 1;\n\t\t \n\n\t\terror = gfs2_glock_nq_num(sdp, jd->jd_jid, &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t\t  LM_FLAG_NOEXP | LM_FLAG_TRY | GL_NOCACHE,\n\t\t\t\t\t  &j_gh);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase GLR_TRYFAILED:\n\t\t\tfs_info(sdp, \"jid=%u: Busy\\n\", jd->jd_jid);\n\t\t\terror = 0;\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_NOCACHE, &ji_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_j;\n\t} else {\n\t\tfs_info(sdp, \"jid=%u, already locked for use\\n\", jd->jd_jid);\n\t}\n\n\tt_jlck = ktime_get();\n\tfs_info(sdp, \"jid=%u: Looking at journal...\\n\", jd->jd_jid);\n\n\terror = gfs2_jdesc_check(jd);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\terror = gfs2_find_jhead(jd, &head, true);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\tt_jhd = ktime_get();\n\tfs_info(sdp, \"jid=%u: Journal head lookup took %lldms\\n\", jd->jd_jid,\n\t\tktime_ms_delta(t_jhd, t_jlck));\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tmutex_lock(&sdp->sd_freeze_mutex);\n\n\t\tif (test_bit(SDF_FROZEN, &sdp->sd_flags)) {\n\t\t\tmutex_unlock(&sdp->sd_freeze_mutex);\n\t\t\tfs_warn(sdp, \"jid=%u: Can't replay: filesystem \"\n\t\t\t\t\"is frozen\\n\", jd->jd_jid);\n\t\t\tgoto fail_gunlock_ji;\n\t\t}\n\n\t\tif (test_bit(SDF_RORECOVERY, &sdp->sd_flags)) {\n\t\t\tro = 1;\n\t\t} else if (test_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags)) {\n\t\t\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\t\t\tro = 1;\n\t\t} else {\n\t\t\tif (sb_rdonly(sdp->sd_vfs)) {\n\t\t\t\t \n\t\t\t\tro = bdev_read_only(sdp->sd_vfs->s_bdev);\n\t\t\t\tif (!ro) {\n\t\t\t\t\tfs_info(sdp, \"recovery required on \"\n\t\t\t\t\t\t\"read-only filesystem.\\n\");\n\t\t\t\t\tfs_info(sdp, \"write access will be \"\n\t\t\t\t\t\t\"enabled during recovery.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ro) {\n\t\t\tfs_warn(sdp, \"jid=%u: Can't replay: read-only block \"\n\t\t\t\t\"device\\n\", jd->jd_jid);\n\t\t\terror = -EROFS;\n\t\t\tgoto fail_gunlock_nofreeze;\n\t\t}\n\n\t\tt_tlck = ktime_get();\n\t\tfs_info(sdp, \"jid=%u: Replaying journal...0x%x to 0x%x\\n\",\n\t\t\tjd->jd_jid, head.lh_tail, head.lh_blkno);\n\n\t\t \n\t\tdown_read(&sdp->sd_log_flush_lock);\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlops_before_scan(jd, &head, pass);\n\t\t\terror = foreach_descriptor(jd, head.lh_tail,\n\t\t\t\t\t\t   head.lh_blkno, pass);\n\t\t\tlops_after_scan(jd, error, pass);\n\t\t\tif (error) {\n\t\t\t\tup_read(&sdp->sd_log_flush_lock);\n\t\t\t\tgoto fail_gunlock_nofreeze;\n\t\t\t}\n\t\t}\n\n\t\trecover_local_statfs(jd, &head);\n\t\tclean_journal(jd, &head);\n\t\tup_read(&sdp->sd_log_flush_lock);\n\n\t\tmutex_unlock(&sdp->sd_freeze_mutex);\n\t\tt_rep = ktime_get();\n\t\tfs_info(sdp, \"jid=%u: Journal replayed in %lldms [jlck:%lldms, \"\n\t\t\t\"jhead:%lldms, tlck:%lldms, replay:%lldms]\\n\",\n\t\t\tjd->jd_jid, ktime_ms_delta(t_rep, t_start),\n\t\t\tktime_ms_delta(t_jlck, t_start),\n\t\t\tktime_ms_delta(t_jhd, t_jlck),\n\t\t\tktime_ms_delta(t_tlck, t_jhd),\n\t\t\tktime_ms_delta(t_rep, t_tlck));\n\t}\n\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_SUCCESS);\n\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: Done\\n\", jd->jd_jid);\n\tgoto done;\n\nfail_gunlock_nofreeze:\n\tmutex_unlock(&sdp->sd_freeze_mutex);\nfail_gunlock_ji:\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail_gunlock_j:\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: %s\\n\", jd->jd_jid, (error) ? \"Failed\" : \"Done\");\nfail:\n\tjd->jd_recover_error = error;\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_GAVEUP);\ndone:\n\tclear_bit(JDF_RECOVERY, &jd->jd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&jd->jd_flags, JDF_RECOVERY);\n}\n\nint gfs2_recover_journal(struct gfs2_jdesc *jd, bool wait)\n{\n\tint rv;\n\n\tif (test_and_set_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\treturn -EBUSY;\n\n\t \n\trv = queue_work(gfs2_recovery_wq, &jd->jd_work);\n\tBUG_ON(!rv);\n\n\tif (wait)\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\treturn wait ? jd->jd_recover_error : 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}