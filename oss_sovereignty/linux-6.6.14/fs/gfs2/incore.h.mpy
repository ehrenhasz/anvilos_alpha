{
  "module_name": "incore.h",
  "hash_id": "e6e12118eca107e89646ed7488f1ea7ca87a73c81de1a75d29f32e6eeb3ddafc",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/incore.h",
  "human_readable_source": " \n \n\n#ifndef __INCORE_DOT_H__\n#define __INCORE_DOT_H__\n\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/workqueue.h>\n#include <linux/dlm.h>\n#include <linux/buffer_head.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist_bl.h>\n#include <linux/completion.h>\n#include <linux/rbtree.h>\n#include <linux/ktime.h>\n#include <linux/percpu.h>\n#include <linux/lockref.h>\n#include <linux/rhashtable.h>\n#include <linux/mutex.h>\n\n#define DIO_WAIT\t0x00000010\n#define DIO_METADATA\t0x00000020\n\nstruct gfs2_log_operations;\nstruct gfs2_bufdata;\nstruct gfs2_holder;\nstruct gfs2_glock;\nstruct gfs2_quota_data;\nstruct gfs2_trans;\nstruct gfs2_jdesc;\nstruct gfs2_sbd;\nstruct lm_lockops;\n\ntypedef void (*gfs2_glop_bh_t) (struct gfs2_glock *gl, unsigned int ret);\n\nstruct gfs2_log_header_host {\n\tu64 lh_sequence;\t \n\tu32 lh_flags;\t\t \n\tu32 lh_tail;\t\t \n\tu32 lh_blkno;\n\n\ts64 lh_local_total;\n\ts64 lh_local_free;\n\ts64 lh_local_dinodes;\n};\n\n \n\nstruct gfs2_log_operations {\n\tvoid (*lo_before_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);\n\tvoid (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);\n\tvoid (*lo_before_scan) (struct gfs2_jdesc *jd,\n\t\t\t\tstruct gfs2_log_header_host *head, int pass);\n\tint (*lo_scan_elements) (struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t\t struct gfs2_log_descriptor *ld, __be64 *ptr,\n\t\t\t\t int pass);\n\tvoid (*lo_after_scan) (struct gfs2_jdesc *jd, int error, int pass);\n\tconst char *lo_name;\n};\n\n#define GBF_FULL 1\n\n \nstruct gfs2_bitmap {\n\tstruct buffer_head *bi_bh;\n\tchar *bi_clone;\n\tunsigned long bi_flags;\n\tu32 bi_offset;\n\tu32 bi_start;\n\tu32 bi_bytes;\n\tu32 bi_blocks;\n};\n\nstruct gfs2_rgrpd {\n\tstruct rb_node rd_node;\t\t \n\tstruct gfs2_glock *rd_gl;\t \n\tu64 rd_addr;\t\t\t \n\tu64 rd_data0;\t\t\t \n\tu32 rd_length;\t\t\t \n\tu32 rd_data;\t\t\t \n\tu32 rd_bitbytes;\t\t \n\tu32 rd_free;\n\tu32 rd_requested;\t\t \n\tu32 rd_reserved;\t\t \n\tu32 rd_free_clone;\n\tu32 rd_dinodes;\n\tu64 rd_igeneration;\n\tstruct gfs2_bitmap *rd_bits;\n\tstruct gfs2_sbd *rd_sbd;\n\tstruct gfs2_rgrp_lvb *rd_rgl;\n\tu32 rd_last_alloc;\n\tu32 rd_flags;\n\tu32 rd_extfail_pt;\t\t \n#define GFS2_RDF_CHECK\t\t0x10000000  \n#define GFS2_RDF_ERROR\t\t0x40000000  \n#define GFS2_RDF_PREFERRED\t0x80000000  \n#define GFS2_RDF_MASK\t\t0xf0000000  \n\tspinlock_t rd_rsspin;            \n\tstruct mutex rd_mutex;\n\tstruct rb_root rd_rstree;        \n};\n\nenum gfs2_state_bits {\n\tBH_Pinned = BH_PrivateStart,\n\tBH_Escaped = BH_PrivateStart + 1,\n};\n\nBUFFER_FNS(Pinned, pinned)\nTAS_BUFFER_FNS(Pinned, pinned)\nBUFFER_FNS(Escaped, escaped)\nTAS_BUFFER_FNS(Escaped, escaped)\n\nstruct gfs2_bufdata {\n\tstruct buffer_head *bd_bh;\n\tstruct gfs2_glock *bd_gl;\n\tu64 bd_blkno;\n\n\tstruct list_head bd_list;\n\n\tstruct gfs2_trans *bd_tr;\n\tstruct list_head bd_ail_st_list;\n\tstruct list_head bd_ail_gl_list;\n};\n\n \n\n#define GDLM_STRNAME_BYTES\t25\n#define GDLM_LVB_SIZE\t\t32\n\n \n\nenum {\n\tDFL_BLOCK_LOCKS\t\t= 0,\n\tDFL_NO_DLM_OPS\t\t= 1,\n\tDFL_FIRST_MOUNT\t\t= 2,\n\tDFL_FIRST_MOUNT_DONE\t= 3,\n\tDFL_MOUNT_DONE\t\t= 4,\n\tDFL_UNMOUNT\t\t= 5,\n\tDFL_DLM_RECOVERY\t= 6,\n};\n\n \nstruct lm_lockname {\n\tu64 ln_number;\n\tstruct gfs2_sbd *ln_sbd;\n\tunsigned int ln_type;\n};\n\n#define lm_name_equal(name1, name2) \\\n        (((name1)->ln_number == (name2)->ln_number) &&\t\\\n\t ((name1)->ln_type == (name2)->ln_type) &&\t\\\n\t ((name1)->ln_sbd == (name2)->ln_sbd))\n\n\nstruct gfs2_glock_operations {\n\tint (*go_sync) (struct gfs2_glock *gl);\n\tint (*go_xmote_bh)(struct gfs2_glock *gl);\n\tvoid (*go_inval) (struct gfs2_glock *gl, int flags);\n\tint (*go_demote_ok) (const struct gfs2_glock *gl);\n\tint (*go_instantiate) (struct gfs2_glock *gl);\n\tint (*go_held)(struct gfs2_holder *gh);\n\tvoid (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl,\n\t\t\tconst char *fs_id_buf);\n\tvoid (*go_callback)(struct gfs2_glock *gl, bool remote);\n\tvoid (*go_free)(struct gfs2_glock *gl);\n\tconst int go_subclass;\n\tconst int go_type;\n\tconst unsigned long go_flags;\n#define GLOF_ASPACE 1  \n#define GLOF_LVB    2  \n#define GLOF_LRU    4  \n#define GLOF_NONDISK   8  \n};\n\nenum {\n\tGFS2_LKS_SRTT = 0,\t \n\tGFS2_LKS_SRTTVAR = 1,\t \n\tGFS2_LKS_SRTTB = 2,\t \n\tGFS2_LKS_SRTTVARB = 3,\t \n\tGFS2_LKS_SIRT = 4,\t \n\tGFS2_LKS_SIRTVAR = 5,\t \n\tGFS2_LKS_DCOUNT = 6,\t \n\tGFS2_LKS_QCOUNT = 7,\t \n\tGFS2_NR_LKSTATS\n};\n\nstruct gfs2_lkstats {\n\tu64 stats[GFS2_NR_LKSTATS];\n};\n\nenum {\n\t \n\tHIF_HOLDER\t\t= 6,   \n\tHIF_WAIT\t\t= 10,\n};\n\nstruct gfs2_holder {\n\tstruct list_head gh_list;\n\n\tstruct gfs2_glock *gh_gl;\n\tstruct pid *gh_owner_pid;\n\tu16 gh_flags;\n\tu16 gh_state;\n\n\tint gh_error;\n\tunsigned long gh_iflags;  \n\tunsigned long gh_ip;\n};\n\n \n#define GFS2_MAXQUOTAS 2\n\nstruct gfs2_qadata {  \n\t \n\tstruct gfs2_quota_data *qa_qd[2 * GFS2_MAXQUOTAS];\n\tstruct gfs2_holder qa_qd_ghs[2 * GFS2_MAXQUOTAS];\n\tunsigned int qa_qd_num;\n\tint qa_ref;\n};\n\n \n\nstruct gfs2_blkreserv {\n\tstruct rb_node rs_node;        \n\tstruct gfs2_rgrpd *rs_rgd;\n\tu64 rs_start;\n\tu32 rs_requested;\n\tu32 rs_reserved;               \n};\n\n \nstruct gfs2_alloc_parms {\n\tu64 target;\n\tu32 min_target;\n\tu32 aflags;\n\tu64 allowed;\n};\n\nenum {\n\tGLF_LOCK\t\t\t= 1,\n\tGLF_INSTANTIATE_NEEDED\t\t= 2,  \n\tGLF_DEMOTE\t\t\t= 3,\n\tGLF_PENDING_DEMOTE\t\t= 4,\n\tGLF_DEMOTE_IN_PROGRESS\t\t= 5,\n\tGLF_DIRTY\t\t\t= 6,\n\tGLF_LFLUSH\t\t\t= 7,\n\tGLF_INVALIDATE_IN_PROGRESS\t= 8,\n\tGLF_REPLY_PENDING\t\t= 9,\n\tGLF_INITIAL\t\t\t= 10,\n\tGLF_FROZEN\t\t\t= 11,\n\tGLF_INSTANTIATE_IN_PROG\t\t= 12,  \n\tGLF_LRU\t\t\t\t= 13,\n\tGLF_OBJECT\t\t\t= 14,  \n\tGLF_BLOCKING\t\t\t= 15,\n\tGLF_FREEING\t\t\t= 16,  \n\tGLF_TRY_TO_EVICT\t\t= 17,  \n\tGLF_VERIFY_EVICT\t\t= 18,  \n};\n\nstruct gfs2_glock {\n\tunsigned long gl_flags;\t\t \n\tstruct lm_lockname gl_name;\n\n\tstruct lockref gl_lockref;\n\n\t \n\tunsigned int gl_state:2,\t \n\t\t     gl_target:2,\t \n\t\t     gl_demote_state:2,\t \n\t\t     gl_req:2,\t\t \n\t\t     gl_reply:8;\t \n\n\tunsigned long gl_demote_time;  \n\tlong gl_hold_time;\n\tstruct list_head gl_holders;\n\n\tconst struct gfs2_glock_operations *gl_ops;\n\tktime_t gl_dstamp;\n\tstruct gfs2_lkstats gl_stats;\n\tstruct dlm_lksb gl_lksb;\n\tunsigned long gl_tchange;\n\tvoid *gl_object;\n\n\tstruct list_head gl_lru;\n\tstruct list_head gl_ail_list;\n\tatomic_t gl_ail_count;\n\tatomic_t gl_revokes;\n\tstruct delayed_work gl_work;\n\t \n\tstruct {\n\t\tstruct delayed_work gl_delete;\n\t\tu64 gl_no_formal_ino;\n\t};\n\tstruct rcu_head gl_rcu;\n\tstruct rhash_head gl_node;\n};\n\nenum {\n\tGIF_QD_LOCKED\t\t= 1,\n\tGIF_ALLOC_FAILED\t= 2,\n\tGIF_SW_PAGED\t\t= 3,\n\tGIF_FREE_VFS_INODE      = 5,\n\tGIF_GLOP_PENDING\t= 6,\n\tGIF_DEFERRED_DELETE\t= 7,\n};\n\nstruct gfs2_inode {\n\tstruct inode i_inode;\n\tu64 i_no_addr;\n\tu64 i_no_formal_ino;\n\tu64 i_generation;\n\tu64 i_eattr;\n\tunsigned long i_flags;\t\t \n\tstruct gfs2_glock *i_gl;\n\tstruct gfs2_holder i_iopen_gh;\n\tstruct gfs2_qadata *i_qadata;  \n\tstruct gfs2_holder i_rgd_gh;\n\tstruct gfs2_blkreserv i_res;  \n\tu64 i_goal;\t \n\tatomic_t i_sizehint;   \n\tstruct rw_semaphore i_rw_mutex;\n\tstruct list_head i_ordered;\n\t__be64 *i_hash_cache;\n\tu32 i_entries;\n\tu32 i_diskflags;\n\tu8 i_height;\n\tu8 i_depth;\n\tu16 i_rahead;\n};\n\n \nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}\n\nstruct gfs2_file {\n\tstruct mutex f_fl_mutex;\n\tstruct gfs2_holder f_fl_gh;\n};\n\nstruct gfs2_revoke_replay {\n\tstruct list_head rr_list;\n\tu64 rr_blkno;\n\tunsigned int rr_where;\n};\n\nenum {\n\tQDF_CHANGE\t\t= 1,\n\tQDF_LOCKED\t\t= 2,\n\tQDF_REFRESH\t\t= 3,\n\tQDF_QMSG_QUIET          = 4,\n};\n\nstruct gfs2_quota_data {\n\tstruct hlist_bl_node qd_hlist;\n\tstruct list_head qd_list;\n\tstruct kqid qd_id;\n\tstruct gfs2_sbd *qd_sbd;\n\tstruct lockref qd_lockref;\n\tstruct list_head qd_lru;\n\tunsigned qd_hash;\n\n\tunsigned long qd_flags;\t\t \n\n\ts64 qd_change;\n\ts64 qd_change_sync;\n\n\tunsigned int qd_slot;\n\tunsigned int qd_slot_ref;\n\n\tstruct buffer_head *qd_bh;\n\tstruct gfs2_quota_change *qd_bh_qc;\n\tunsigned int qd_bh_count;\n\n\tstruct gfs2_glock *qd_gl;\n\tstruct gfs2_quota_lvb qd_qb;\n\n\tu64 qd_sync_gen;\n\tunsigned long qd_last_warn;\n\tstruct rcu_head qd_rcu;\n};\n\nenum {\n\tTR_TOUCHED = 1,\n\tTR_ATTACHED = 2,\n\tTR_ONSTACK = 3,\n};\n\nstruct gfs2_trans {\n\tunsigned long tr_ip;\n\n\tunsigned int tr_blocks;\n\tunsigned int tr_revokes;\n\tunsigned int tr_reserved;\n\tunsigned long tr_flags;\n\n\tunsigned int tr_num_buf_new;\n\tunsigned int tr_num_databuf_new;\n\tunsigned int tr_num_buf_rm;\n\tunsigned int tr_num_databuf_rm;\n\tunsigned int tr_num_revoke;\n\n\tstruct list_head tr_list;\n\tstruct list_head tr_databuf;\n\tstruct list_head tr_buf;\n\n\tunsigned int tr_first;\n\tstruct list_head tr_ail1_list;\n\tstruct list_head tr_ail2_list;\n};\n\nstruct gfs2_journal_extent {\n\tstruct list_head list;\n\n\tunsigned int lblock;  \n\tu64 dblock;  \n\tu64 blocks;\n};\n\nstruct gfs2_jdesc {\n\tstruct list_head jd_list;\n\tstruct list_head extent_list;\n\tunsigned int nr_extents;\n\tstruct work_struct jd_work;\n\tstruct inode *jd_inode;\n\tstruct bio *jd_log_bio;\n\tunsigned long jd_flags;\n#define JDF_RECOVERY 1\n\tunsigned int jd_jid;\n\tu32 jd_blocks;\n\tint jd_recover_error;\n\t \n\n\tunsigned int jd_found_blocks;\n\tunsigned int jd_found_revokes;\n\tunsigned int jd_replayed_blocks;\n\n\tstruct list_head jd_revoke_list;\n\tunsigned int jd_replay_tail;\n\n\tu64 jd_no_addr;\n};\n\nstruct gfs2_statfs_change_host {\n\ts64 sc_total;\n\ts64 sc_free;\n\ts64 sc_dinodes;\n};\n\n#define GFS2_QUOTA_DEFAULT\tGFS2_QUOTA_OFF\n#define GFS2_QUOTA_OFF\t\t0\n#define GFS2_QUOTA_ACCOUNT\t1\n#define GFS2_QUOTA_ON\t\t2\n#define GFS2_QUOTA_QUIET\t3  \n\n#define GFS2_DATA_DEFAULT\tGFS2_DATA_ORDERED\n#define GFS2_DATA_WRITEBACK\t1\n#define GFS2_DATA_ORDERED\t2\n\n#define GFS2_ERRORS_DEFAULT     GFS2_ERRORS_WITHDRAW\n#define GFS2_ERRORS_WITHDRAW    0\n#define GFS2_ERRORS_CONTINUE    1  \n#define GFS2_ERRORS_RO          2  \n#define GFS2_ERRORS_PANIC       3\n\nstruct gfs2_args {\n\tchar ar_lockproto[GFS2_LOCKNAME_LEN];\t \n\tchar ar_locktable[GFS2_LOCKNAME_LEN];\t \n\tchar ar_hostdata[GFS2_LOCKNAME_LEN];\t \n\tunsigned int ar_spectator:1;\t\t \n\tunsigned int ar_localflocks:1;\t\t \n\tunsigned int ar_debug:1;\t\t \n\tunsigned int ar_posix_acl:1;\t\t \n\tunsigned int ar_quota:2;\t\t \n\tunsigned int ar_suiddir:1;\t\t \n\tunsigned int ar_data:2;\t\t\t \n\tunsigned int ar_meta:1;\t\t\t \n\tunsigned int ar_discard:1;\t\t \n\tunsigned int ar_errors:2;                \n\tunsigned int ar_nobarrier:1;             \n\tunsigned int ar_rgrplvb:1;\t\t \n\tunsigned int ar_got_rgrplvb:1;\t\t \n\tunsigned int ar_loccookie:1;\t\t \n\ts32 ar_commit;\t\t\t\t \n\ts32 ar_statfs_quantum;\t\t\t \n\ts32 ar_quota_quantum;\t\t\t \n\ts32 ar_statfs_percent;\t\t\t \n};\n\nstruct gfs2_tune {\n\tspinlock_t gt_spin;\n\n\tunsigned int gt_logd_secs;\n\n\tunsigned int gt_quota_warn_period;  \n\tunsigned int gt_quota_scale_num;  \n\tunsigned int gt_quota_scale_den;  \n\tunsigned int gt_quota_quantum;  \n\tunsigned int gt_new_files_jdata;\n\tunsigned int gt_max_readahead;  \n\tunsigned int gt_complain_secs;\n\tunsigned int gt_statfs_quantum;\n\tunsigned int gt_statfs_slow;\n};\n\nenum {\n\tSDF_JOURNAL_CHECKED\t= 0,\n\tSDF_JOURNAL_LIVE\t= 1,\n\tSDF_WITHDRAWN\t\t= 2,\n\tSDF_NOBARRIERS\t\t= 3,\n\tSDF_NORECOVERY\t\t= 4,\n\tSDF_DEMOTE\t\t= 5,\n\tSDF_NOJOURNALID\t\t= 6,\n\tSDF_RORECOVERY\t\t= 7,  \n\tSDF_SKIP_DLM_UNLOCK\t= 8,\n\tSDF_FORCE_AIL_FLUSH     = 9,\n\tSDF_FREEZE_INITIATOR\t= 10,\n\tSDF_WITHDRAWING\t\t= 11,  \n\tSDF_WITHDRAW_IN_PROG\t= 12,  \n\tSDF_REMOTE_WITHDRAW\t= 13,  \n\tSDF_WITHDRAW_RECOVERY\t= 14,  \n\tSDF_KILL\t\t= 15,\n\tSDF_EVICTING\t\t= 16,\n\tSDF_FROZEN\t\t= 17,\n};\n\n#define GFS2_FSNAME_LEN\t\t256\n\nstruct gfs2_inum_host {\n\tu64 no_formal_ino;\n\tu64 no_addr;\n};\n\nstruct gfs2_sb_host {\n\tu32 sb_magic;\n\tu32 sb_type;\n\n\tu32 sb_fs_format;\n\tu32 sb_multihost_format;\n\tu32 sb_bsize;\n\tu32 sb_bsize_shift;\n\n\tstruct gfs2_inum_host sb_master_dir;\n\tstruct gfs2_inum_host sb_root_dir;\n\n\tchar sb_lockproto[GFS2_LOCKNAME_LEN];\n\tchar sb_locktable[GFS2_LOCKNAME_LEN];\n};\n\n \n\nstruct lm_lockstruct {\n\tint ls_jid;\n\tunsigned int ls_first;\n\tconst struct lm_lockops *ls_ops;\n\tdlm_lockspace_t *ls_dlm;\n\n\tint ls_recover_jid_done;    \n\tint ls_recover_jid_status;  \n\n\tstruct dlm_lksb ls_mounted_lksb;  \n\tstruct dlm_lksb ls_control_lksb;  \n\tchar ls_control_lvb[GDLM_LVB_SIZE];  \n\tstruct completion ls_sync_wait;  \n\tchar *ls_lvb_bits;\n\n\tspinlock_t ls_recover_spin;  \n\tunsigned long ls_recover_flags;  \n\tuint32_t ls_recover_mount;  \n\tuint32_t ls_recover_start;  \n\tuint32_t ls_recover_block;  \n\tuint32_t ls_recover_size;  \n\tuint32_t *ls_recover_submit;  \n\tuint32_t *ls_recover_result;  \n};\n\nstruct gfs2_pcpu_lkstats {\n\t \n\tstruct gfs2_lkstats lkstats[10];\n};\n\n \nstruct local_statfs_inode {\n\tstruct list_head si_list;\n\tstruct inode *si_sc_inode;\n\tunsigned int si_jid;  \n};\n\nstruct gfs2_sbd {\n\tstruct super_block *sd_vfs;\n\tstruct gfs2_pcpu_lkstats __percpu *sd_lkstats;\n\tstruct kobject sd_kobj;\n\tstruct completion sd_kobj_unregister;\n\tunsigned long sd_flags;\t \n\tstruct gfs2_sb_host sd_sb;\n\n\t \n\n\tu32 sd_fsb2bb;\n\tu32 sd_fsb2bb_shift;\n\tu32 sd_diptrs;\t \n\tu32 sd_inptrs;\t \n\tu32 sd_ldptrs;   \n\tu32 sd_jbsize;\t \n\tu32 sd_hash_bsize;\t \n\tu32 sd_hash_bsize_shift;\n\tu32 sd_hash_ptrs;\t \n\tu32 sd_qc_per_block;\n\tu32 sd_blocks_per_bitmap;\n\tu32 sd_max_dirres;\t \n\tu32 sd_max_height;\t \n\tu64 sd_heightsize[GFS2_MAX_META_HEIGHT + 1];\n\tu32 sd_max_dents_per_leaf;  \n\n\tstruct gfs2_args sd_args;\t \n\tstruct gfs2_tune sd_tune;\t \n\n\t \n\n\tstruct lm_lockstruct sd_lockstruct;\n\tstruct gfs2_holder sd_live_gh;\n\tstruct gfs2_glock *sd_rename_gl;\n\tstruct gfs2_glock *sd_freeze_gl;\n\tstruct work_struct sd_freeze_work;\n\twait_queue_head_t sd_kill_wait;\n\twait_queue_head_t sd_async_glock_wait;\n\tatomic_t sd_glock_disposal;\n\tstruct completion sd_locking_init;\n\tstruct completion sd_wdack;\n\tstruct delayed_work sd_control_work;\n\n\t \n\n\tstruct dentry *sd_master_dir;\n\tstruct dentry *sd_root_dir;\n\n\tstruct inode *sd_jindex;\n\tstruct inode *sd_statfs_inode;\n\tstruct inode *sd_sc_inode;\n\tstruct list_head sd_sc_inodes_list;\n\tstruct inode *sd_qc_inode;\n\tstruct inode *sd_rindex;\n\tstruct inode *sd_quota_inode;\n\n\t \n\n\tspinlock_t sd_statfs_spin;\n\tstruct gfs2_statfs_change_host sd_statfs_master;\n\tstruct gfs2_statfs_change_host sd_statfs_local;\n\tint sd_statfs_force_sync;\n\n\t \n\n\tint sd_rindex_uptodate;\n\tspinlock_t sd_rindex_spin;\n\tstruct rb_root sd_rindex_tree;\n\tunsigned int sd_rgrps;\n\tunsigned int sd_max_rg_data;\n\n\t \n\n\tstruct list_head sd_jindex_list;\n\tspinlock_t sd_jindex_spin;\n\tstruct mutex sd_jindex_mutex;\n\tunsigned int sd_journals;\n\n\tstruct gfs2_jdesc *sd_jdesc;\n\tstruct gfs2_holder sd_journal_gh;\n\tstruct gfs2_holder sd_jinode_gh;\n\tstruct gfs2_glock *sd_jinode_gl;\n\n\tstruct gfs2_holder sd_sc_gh;\n\tstruct buffer_head *sd_sc_bh;\n\tstruct gfs2_holder sd_qc_gh;\n\n\tstruct completion sd_journal_ready;\n\n\t \n\n\tstruct workqueue_struct *sd_delete_wq;\n\n\t \n\n\tstruct task_struct *sd_logd_process;\n\tstruct task_struct *sd_quotad_process;\n\n\t \n\n\tstruct list_head sd_quota_list;\n\tatomic_t sd_quota_count;\n\tstruct mutex sd_quota_mutex;\n\tstruct mutex sd_quota_sync_mutex;\n\twait_queue_head_t sd_quota_wait;\n\n\tunsigned int sd_quota_slots;\n\tunsigned long *sd_quota_bitmap;\n\tspinlock_t sd_bitmap_lock;\n\n\tu64 sd_quota_sync_gen;\n\n\t \n\n\tstruct address_space sd_aspace;\n\n\tspinlock_t sd_log_lock;\n\n\tstruct gfs2_trans *sd_log_tr;\n\tunsigned int sd_log_blks_reserved;\n\n\tatomic_t sd_log_pinned;\n\tunsigned int sd_log_num_revoke;\n\n\tstruct list_head sd_log_revokes;\n\tstruct list_head sd_log_ordered;\n\tspinlock_t sd_ordered_lock;\n\n\tatomic_t sd_log_thresh1;\n\tatomic_t sd_log_thresh2;\n\tatomic_t sd_log_blks_free;\n\tatomic_t sd_log_blks_needed;\n\tatomic_t sd_log_revokes_available;\n\twait_queue_head_t sd_log_waitq;\n\twait_queue_head_t sd_logd_waitq;\n\n\tu64 sd_log_sequence;\n\tint sd_log_idle;\n\n\tstruct rw_semaphore sd_log_flush_lock;\n\tatomic_t sd_log_in_flight;\n\twait_queue_head_t sd_log_flush_wait;\n\tint sd_log_error;  \n\twait_queue_head_t sd_withdraw_wait;\n\n\tunsigned int sd_log_tail;\n\tunsigned int sd_log_flush_tail;\n\tunsigned int sd_log_head;\n\tunsigned int sd_log_flush_head;\n\n\tspinlock_t sd_ail_lock;\n\tstruct list_head sd_ail1_list;\n\tstruct list_head sd_ail2_list;\n\n\t \n\tstruct gfs2_holder sd_freeze_gh;\n\tstruct mutex sd_freeze_mutex;\n\n\tchar sd_fsname[GFS2_FSNAME_LEN + 3 * sizeof(int) + 2];\n\tchar sd_table_name[GFS2_FSNAME_LEN];\n\tchar sd_proto_name[GFS2_FSNAME_LEN];\n\n\t \n\n\tunsigned long sd_last_warning;\n\tstruct dentry *debugfs_dir;     \n\tunsigned long sd_glock_dqs_held;\n};\n\nstatic inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)\n{\n\tgl->gl_stats.stats[which]++;\n}\n\nstatic inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)\n{\n\tconst struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tpreempt_disable();\n\tthis_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;\n\tpreempt_enable();\n}\n\nextern struct gfs2_rgrpd *gfs2_glock2rgrp(struct gfs2_glock *gl);\n\nstatic inline unsigned gfs2_max_stuffed_size(const struct gfs2_inode *ip)\n{\n\treturn GFS2_SB(&ip->i_inode)->sd_sb.sb_bsize - sizeof(struct gfs2_dinode);\n}\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}