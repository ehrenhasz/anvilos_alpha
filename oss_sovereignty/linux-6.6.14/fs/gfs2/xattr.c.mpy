{
  "module_name": "xattr.c",
  "hash_id": "03412143f57f57609b8c34e9bab0bcf6592569b1f72e0b6714dfe7fd58626e33",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/uaccess.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"super.h\"\n#include \"trans.h\"\n#include \"util.h\"\n\n \n\nstatic int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t \n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t \n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}\n\nstatic int ea_check_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize)\n{\n\tunsigned int size;\n\n\tif (dsize > GFS2_EA_MAX_DATA_LEN)\n\t\treturn -ERANGE;\n\n\tea_calc_size(sdp, nsize, dsize, &size);\n\n\t \n\tif (size > sdp->sd_jbsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic bool gfs2_eatype_valid(struct gfs2_sbd *sdp, u8 type)\n{\n\tswitch(sdp->sd_sb.sb_fs_format) {\n\tcase GFS2_FS_FORMAT_MAX:\n\t\treturn true;\n\n\tcase GFS2_FS_FORMAT_MIN:\n\t\treturn type <= GFS2_EATYPE_SECURITY;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\ntypedef int (*ea_call_t) (struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t  struct gfs2_ea_header *ea,\n\t\t\t  struct gfs2_ea_header *prev, void *private);\n\nstatic int ea_foreach_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\tea_call_t ea_call, void *data)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea, *prev = NULL;\n\tint error = 0;\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_EA))\n\t\treturn -EIO;\n\n\tfor (ea = GFS2_EA_BH2FIRST(bh);; prev = ea, ea = GFS2_EA2NEXT(ea)) {\n\t\tif (!GFS2_EA_REC_LEN(ea))\n\t\t\tgoto fail;\n\t\tif (!(bh->b_data <= (char *)ea && (char *)GFS2_EA2NEXT(ea) <=\n\t\t\t\t\t\t  bh->b_data + bh->b_size))\n\t\t\tgoto fail;\n\t\tif (!gfs2_eatype_valid(sdp, ea->ea_type))\n\t\t\tgoto fail;\n\t\terror = ea_call(ip, bh, ea, prev, data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (GFS2_EA_IS_LAST(ea)) {\n\t\t\tif ((char *)GFS2_EA2NEXT(ea) !=\n\t\t\t    bh->b_data + bh->b_size)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n\nfail:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, 0, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, 0, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}\n\nstruct ea_find {\n\tint type;\n\tconst char *name;\n\tsize_t namel;\n\tstruct gfs2_ea_location *ef_el;\n};\n\nstatic int ea_find_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct ea_find *ef = private;\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tif (ea->ea_type == ef->type) {\n\t\tif (ea->ea_name_len == ef->namel &&\n\t\t    !memcmp(GFS2_EA2NAME(ea), ef->name, ea->ea_name_len)) {\n\t\t\tstruct gfs2_ea_location *el = ef->ef_el;\n\t\t\tget_bh(bh);\n\t\t\tel->el_bh = bh;\n\t\t\tel->el_ea = ea;\n\t\t\tel->el_prev = prev;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}\n\n \n\nstatic int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\tstruct gfs2_ea_header *ea,\n\t\t\t\tstruct gfs2_ea_header *prev, void *private)\n{\n\tint *leave = private;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rg_gh;\n\t__be64 *dataptrs;\n\tu64 bn = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(ea))\n\t\treturn 0;\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (*dataptrs) {\n\t\t\tblks++;\n\t\t\tbn = be64_to_cpu(*dataptrs);\n\t\t}\n\t}\n\tif (!blks)\n\t\treturn 0;\n\n\trgd = gfs2_blk2rgrpd(sdp, bn, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t   LM_FLAG_NODE_SCOPE, &rg_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (!*dataptrs)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*dataptrs);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, rgd, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*dataptrs = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, rgd, bstart, blen);\n\n\tif (prev && !leave) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\tea->ea_num_ptrs = 0;\n\t}\n\n\tinode_set_ctime_current(&ip->i_inode);\n\t__mark_inode_dirty(&ip->i_inode, I_DIRTY_DATASYNC);\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&rg_gh);\n\treturn error;\n}\n\nstatic int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}\n\nstruct ea_list {\n\tstruct gfs2_ea_request *ei_er;\n\tunsigned int ei_size;\n};\n\nstatic int ea_list_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct ea_list *ei = private;\n\tstruct gfs2_ea_request *er = ei->ei_er;\n\tunsigned int ea_size;\n\tchar *prefix;\n\tunsigned int l;\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tBUG_ON(ea->ea_type > GFS2_EATYPE_SECURITY &&\n\t       sdp->sd_sb.sb_fs_format == GFS2_FS_FORMAT_MIN);\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\tprefix = \"user.\";\n\t\tl = 5;\n\t\tbreak;\n\tcase GFS2_EATYPE_SYS:\n\t\tprefix = \"system.\";\n\t\tl = 7;\n\t\tbreak;\n\tcase GFS2_EATYPE_SECURITY:\n\t\tprefix = \"security.\";\n\t\tl = 9;\n\t\tbreak;\n\tcase GFS2_EATYPE_TRUSTED:\n\t\tprefix = \"trusted.\";\n\t\tl = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tea_size = l + ea->ea_name_len + 1;\n\tif (er->er_data_len) {\n\t\tif (ei->ei_size + ea_size > er->er_data_len)\n\t\t\treturn -ERANGE;\n\n\t\tmemcpy(er->er_data + ei->ei_size, prefix, l);\n\t\tmemcpy(er->er_data + ei->ei_size + l, GFS2_EA2NAME(ea),\n\t\t       ea->ea_name_len);\n\t\ter->er_data[ei->ei_size + ea_size - 1] = 0;\n\t}\n\n\tei->ei_size += ea_size;\n\n\treturn 0;\n}\n\n \n\nssize_t gfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(d_inode(dentry));\n\tstruct gfs2_ea_request er;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\tmemset(&er, 0, sizeof(struct gfs2_ea_request));\n\tif (size) {\n\t\ter.er_data = buffer;\n\t\ter.er_data_len = size;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_eattr) {\n\t\tstruct ea_list ei = { .ei_er = &er, .ei_size = 0 };\n\n\t\terror = ea_foreach(ip, ea_list_i, &ei);\n\t\tif (!error)\n\t\t\terror = ei.ei_size;\n\t}\n\n\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}\n\n \n\nstatic int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0, 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}\n\nstatic int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nint gfs2_xattr_acl_get(struct gfs2_inode *ip, const char *name, char **ppdata)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\tint len;\n\tchar *data;\n\n\terror = gfs2_ea_find(ip, GFS2_EATYPE_SYS, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\tgoto out;\n\tif (!GFS2_EA_DATA_LEN(el.el_ea))\n\t\tgoto out;\n\n\tlen = GFS2_EA_DATA_LEN(el.el_ea);\n\tdata = kmalloc(len, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (data == NULL)\n\t\tgoto out;\n\n\terror = gfs2_ea_get_copy(ip, &el, data, len);\n\tif (error < 0)\n\t\tkfree(data);\n\telse\n\t\t*ppdata = data;\nout:\n\tbrelse(el.el_bh);\n\treturn error;\n}\n\n \nstatic int __gfs2_xattr_get(struct inode *inode, const char *name,\n\t\t\t    void *buffer, size_t size, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\tif (strlen(name) > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -EINVAL;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\tif (size)\n\t\terror = gfs2_ea_get_copy(ip, &el, buffer, size);\n\telse\n\t\terror = GFS2_EA_DATA_LEN(el.el_ea);\n\tbrelse(el.el_bh);\n\n\treturn error;\n}\n\nstatic int gfs2_xattr_get(const struct xattr_handler *handler,\n\t\t\t  struct dentry *unused, struct inode *inode,\n\t\t\t  const char *name, void *buffer, size_t size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\t \n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tgfs2_holder_mark_uninitialized(&gh);\n\t}\n\tret = __gfs2_xattr_get(inode, name, buffer, size, handler->flags);\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn ret;\n}\n\n \n\nstatic int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_remove_revoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}\n\n \n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_remove_revoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}\n\ntypedef int (*ea_skeleton_call_t) (struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_request *er, void *private);\n\nstatic int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip, &ap);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\tinode_set_ctime_current(&ip->i_inode);\n\t__mark_inode_dirty(&ip->i_inode, I_DIRTY_DATASYNC);\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}\n\nstatic int ea_init_i(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t     void *private)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = ea_alloc_blk(ip, &bh);\n\tif (error)\n\t\treturn error;\n\n\tip->i_eattr = bh->b_blocknr;\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(bh), er);\n\n\tbrelse(bh);\n\n\treturn error;\n}\n\n \nstatic int ea_init(struct gfs2_inode *ip, int type, const char *name,\n\t\t   const void *data, size_t size)\n{\n\tstruct gfs2_ea_request er;\n\tunsigned int jbsize = GFS2_SB(&ip->i_inode)->sd_jbsize;\n\tunsigned int blks = 1;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_name_len = strlen(name);\n\ter.er_data = (void *)data;\n\ter.er_data_len = size;\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_init_i, NULL);\n}\n\nstatic struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}\n\nstatic void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}\n\nstruct ea_set {\n\tint ea_split;\n\n\tstruct gfs2_ea_request *es_er;\n\tstruct gfs2_ea_location *es_el;\n\n\tstruct buffer_head *es_bh;\n\tstruct gfs2_ea_header *es_ea;\n};\n\nstatic int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\t struct gfs2_ea_header *ea, struct ea_set *es)\n{\n\tstruct gfs2_ea_request *er = es->es_er;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + 2 * RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\tea_write(ip, ea, er);\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\tinode_set_ctime_current(&ip->i_inode);\n\t__mark_inode_dirty(&ip->i_inode, I_DIRTY_DATASYNC);\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\treturn error;\n}\n\nstatic int ea_set_simple_alloc(struct gfs2_inode *ip,\n\t\t\t       struct gfs2_ea_request *er, void *private)\n{\n\tstruct ea_set *es = private;\n\tstruct gfs2_ea_header *ea = es->es_ea;\n\tint error;\n\n\tgfs2_trans_add_meta(ip->i_gl, es->es_bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\terror = ea_write(ip, ea, er);\n\tif (error)\n\t\treturn error;\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\treturn 0;\n}\n\nstatic int ea_set_simple(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t\t void *private)\n{\n\tstruct ea_set *es = private;\n\tunsigned int size;\n\tint stuffed;\n\tint error;\n\n\tstuffed = ea_calc_size(GFS2_SB(&ip->i_inode), es->es_er->er_name_len,\n\t\t\t       es->es_er->er_data_len, &size);\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED) {\n\t\tif (GFS2_EA_REC_LEN(ea) < size)\n\t\t\treturn 0;\n\t\tif (!GFS2_EA_IS_STUFFED(ea)) {\n\t\t\terror = ea_remove_unstuffed(ip, bh, ea, prev, 1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tes->ea_split = 0;\n\t} else if (GFS2_EA_REC_LEN(ea) - GFS2_EA_SIZE(ea) >= size)\n\t\tes->ea_split = 1;\n\telse\n\t\treturn 0;\n\n\tif (stuffed) {\n\t\terror = ea_set_simple_noalloc(ip, bh, ea, es);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tunsigned int blks;\n\n\t\tes->es_bh = bh;\n\t\tes->es_ea = ea;\n\t\tblks = 2 + DIV_ROUND_UP(es->es_er->er_data_len,\n\t\t\t\t\tGFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\t\terror = ea_alloc_skeleton(ip, es->es_er, blks,\n\t\t\t\t\t  ea_set_simple_alloc, es);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 1;\n}\n\nstatic int ea_set_block(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\tvoid *private)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *indbh, *newbh;\n\t__be64 *eablk;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\t__be64 *end;\n\n\t\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, 0,\n\t\t\t\t       &indbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\tend = eablk + sdp->sd_inptrs;\n\n\t\tfor (; eablk < end; eablk++)\n\t\t\tif (!*eablk)\n\t\t\t\tbreak;\n\n\t\tif (eablk == end) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t} else {\n\t\tu64 blk;\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &blk, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_remove_revoke(sdp, blk, 1);\n\t\tindbh = gfs2_meta_new(ip->i_gl, blk);\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t\tgfs2_metatype_set(indbh, GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\t\tgfs2_buffer_clear_tail(indbh, mh_size);\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\t*eablk = cpu_to_be64(ip->i_eattr);\n\t\tip->i_eattr = blk;\n\t\tip->i_diskflags |= GFS2_DIF_EA_INDIRECT;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\teablk++;\n\t}\n\n\terror = ea_alloc_blk(ip, &newbh);\n\tif (error)\n\t\tgoto out;\n\n\t*eablk = cpu_to_be64((u64)newbh->b_blocknr);\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(newbh), er);\n\tbrelse(newbh);\n\tif (error)\n\t\tgoto out;\n\n\tif (private)\n\t\tea_set_remove_stuffed(ip, private);\n\nout:\n\tbrelse(indbh);\n\treturn error;\n}\n\nstatic int ea_set_i(struct gfs2_inode *ip, int type, const char *name,\n\t\t    const void *value, size_t size, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_request er;\n\tstruct ea_set es;\n\tunsigned int blks = 2;\n\tint error;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_data = (void *)value;\n\ter.er_name_len = strlen(name);\n\ter.er_data_len = size;\n\n\tmemset(&es, 0, sizeof(struct ea_set));\n\tes.es_er = &er;\n\tes.es_el = el;\n\n\terror = ea_foreach(ip, ea_set_simple, &es);\n\tif (error > 0)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT))\n\t\tblks++;\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > GFS2_SB(&ip->i_inode)->sd_jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, GFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_set_block, el);\n}\n\nstatic int ea_set_remove_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_location *el)\n{\n\tif (el->el_prev && GFS2_EA2NEXT(el->el_prev) != el->el_ea) {\n\t\tel->el_prev = GFS2_EA2NEXT(el->el_prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode),\n\t\t\t\t     GFS2_EA2NEXT(el->el_prev) == el->el_ea);\n\t}\n\n\treturn ea_remove_unstuffed(ip, el->el_bh, el->el_ea, el->el_prev, 0);\n}\n\nstatic int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (prev) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t}\n\n\tinode_set_ctime_current(&ip->i_inode);\n\t__mark_inode_dirty(&ip->i_inode, I_DIRTY_DATASYNC);\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\n\treturn error;\n}\n\n \n\nstatic int gfs2_xattr_remove(struct gfs2_inode *ip, int type, const char *name)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea))\n\t\terror = ea_remove_stuffed(ip, &el);\n\telse\n\t\terror = ea_remove_unstuffed(ip, el.el_bh, el.el_ea, el.el_prev, 0);\n\n\tbrelse(el.el_bh);\n\n\treturn error;\n}\n\n \n\nint __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL) {\n\t\terror = gfs2_xattr_remove(ip, type, name);\n\t\tif (error == -ENODATA && !(flags & XATTR_REPLACE))\n\t\t\terror = 0;\n\t\treturn error;\n\t}\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}\n\nstatic int gfs2_xattr_set(const struct xattr_handler *handler,\n\t\t\t  struct mnt_idmap *idmap,\n\t\t\t  struct dentry *unused, struct inode *inode,\n\t\t\t  const char *name, const void *value,\n\t\t\t  size_t size, int flags)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tret = gfs2_qa_get(ip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tif (WARN_ON_ONCE(ip->i_gl->gl_state != LM_ST_EXCLUSIVE)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tgfs2_holder_mark_uninitialized(&gh);\n\t}\n\tret = __gfs2_xattr_set(inode, name, value, size, flags, handler->flags);\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\nout:\n\tgfs2_qa_put(ip);\n\treturn ret;\n}\n\nstatic int ea_dealloc_indirect(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, 0, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE, LM_FLAG_NODE_SCOPE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\trgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\trgd = NULL;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, rgd, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\trgd = gfs2_blk2rgrpd(sdp, bstart, true);\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, rgd, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist_free:\n\tgfs2_rlist_free(&rlist);\nout:\n\tbrelse(indbh);\n\treturn error;\n}\n\nstatic int ea_dealloc_block(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_eattr, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t   LM_FLAG_NODE_SCOPE, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA, 1);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_free_meta(ip, rgd, ip->i_eattr, 1);\n\n\tip->i_eattr = 0;\n\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\n\tif (likely(!test_bit(GIF_ALLOC_FAILED, &ip->i_flags))) {\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (!error) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}\n\n \n\nint gfs2_ea_dealloc(struct gfs2_inode *ip)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\tif (likely(!test_bit(GIF_ALLOC_FAILED, &ip->i_flags))) {\n\t\terror = ea_foreach(ip, ea_dealloc_unstuffed, NULL);\n\t\tif (error)\n\t\t\tgoto out_quota;\n\n\t\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\t\terror = ea_dealloc_indirect(ip);\n\t\t\tif (error)\n\t\t\t\tgoto out_quota;\n\t\t}\n\t}\n\n\terror = ea_dealloc_block(ip);\n\nout_quota:\n\tgfs2_quota_unhold(ip);\n\treturn error;\n}\n\nstatic const struct xattr_handler gfs2_xattr_user_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.flags  = GFS2_EATYPE_USR,\n\t.get    = gfs2_xattr_get,\n\t.set    = gfs2_xattr_set,\n};\n\nstatic const struct xattr_handler gfs2_xattr_security_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.flags  = GFS2_EATYPE_SECURITY,\n\t.get    = gfs2_xattr_get,\n\t.set    = gfs2_xattr_set,\n};\n\nstatic bool\ngfs2_xattr_trusted_list(struct dentry *dentry)\n{\n\treturn capable(CAP_SYS_ADMIN);\n}\n\nstatic const struct xattr_handler gfs2_xattr_trusted_handler = {\n\t.prefix = XATTR_TRUSTED_PREFIX,\n\t.flags  = GFS2_EATYPE_TRUSTED,\n\t.list\t= gfs2_xattr_trusted_list,\n\t.get    = gfs2_xattr_get,\n\t.set    = gfs2_xattr_set,\n};\n\nconst struct xattr_handler *gfs2_xattr_handlers_max[] = {\n\t \n\t&gfs2_xattr_trusted_handler,\n\n\t \n\t&gfs2_xattr_user_handler,\n\t&gfs2_xattr_security_handler,\n\tNULL,\n};\n\nconst struct xattr_handler **gfs2_xattr_handlers_min = gfs2_xattr_handlers_max + 1;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}