{
  "module_name": "ops_fstype.c",
  "hash_id": "85d17a8710158326e747f35d7d252da2a8e5125e61561778788eb8d91f895100",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/ops_fstype.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/quotaops.h>\n#include <linux/lockdep.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/fs_parser.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"recovery.h\"\n#include \"rgrp.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"log.h\"\n#include \"quota.h\"\n#include \"dir.h\"\n#include \"meta_io.h\"\n#include \"trace_gfs2.h\"\n#include \"lops.h\"\n\n#define DO 0\n#define UNDO 1\n\n \n\nstatic void gfs2_tune_init(struct gfs2_tune *gt)\n{\n\tspin_lock_init(&gt->gt_spin);\n\n\tgt->gt_quota_warn_period = 10;\n\tgt->gt_quota_scale_num = 1;\n\tgt->gt_quota_scale_den = 1;\n\tgt->gt_new_files_jdata = 0;\n\tgt->gt_max_readahead = BIT(18);\n\tgt->gt_complain_secs = 10;\n}\n\nvoid free_sbd(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lkstats)\n\t\tfree_percpu(sdp->sd_lkstats);\n\tkfree(sdp);\n}\n\nstatic struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats)\n\t\tgoto fail;\n\tsb->s_fs_info = sdp;\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_kill_wait);\n\tinit_waitqueue_head(&sdp->sd_async_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tINIT_LIST_HEAD(&sdp->sd_sc_inodes_list);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_revokes);\n\tINIT_LIST_HEAD(&sdp->sd_log_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\n\treturn sdp;\n\nfail:\n\tfree_sbd(sdp);\n\treturn NULL;\n}\n\n \n\nstatic int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\n\tif (sb->sb_magic != GFS2_MAGIC ||\n\t    sb->sb_type != GFS2_METATYPE_SB) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"not a GFS2 filesystem\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb->sb_fs_format < GFS2_FS_FORMAT_MIN ||\n\t    sb->sb_fs_format > GFS2_FS_FORMAT_MAX ||\n\t    sb->sb_multihost_format != GFS2_FORMAT_MULTI) {\n\t\tfs_warn(sdp, \"Unknown on-disk format, unable to mount\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb->sb_bsize < 512 || sb->sb_bsize > PAGE_SIZE ||\n\t    (sb->sb_bsize & (sb->sb_bsize - 1))) {\n\t\tpr_warn(\"Invalid block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (sb->sb_bsize_shift != ffs(sb->sb_bsize) - 1) {\n\t\tpr_warn(\"Invalid block size shift\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void end_bio_io_page(struct bio *bio)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (!bio->bi_status)\n\t\tSetPageUptodate(page);\n\telse\n\t\tpr_warn(\"error %d reading superblock\\n\", bio->bi_status);\n\tunlock_page(page);\n}\n\nstatic void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\n{\n\tstruct gfs2_sb_host *sb = &sdp->sd_sb;\n\tstruct super_block *s = sdp->sd_vfs;\n\tconst struct gfs2_sb *str = buf;\n\n\tsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\n\tsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\n\tsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\n\tsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\n\tsb->sb_bsize = be32_to_cpu(str->sb_bsize);\n\tsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\n\tsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\n\tsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\n\tsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\n\tsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\n\n\tmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\n\tmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\n\tmemcpy(&s->s_uuid, str->sb_uuid, 16);\n}\n\n \n\nstatic int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_sb *p;\n\tstruct page *page;\n\tstruct bio *bio;\n\n\tpage = alloc_page(GFP_NOFS);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tClearPageUptodate(page);\n\tClearPageDirty(page);\n\tlock_page(page);\n\n\tbio = bio_alloc(sb->s_bdev, 1, REQ_OP_READ | REQ_META, GFP_NOFS);\n\tbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\n\t__bio_add_page(bio, page, PAGE_SIZE, 0);\n\n\tbio->bi_end_io = end_bio_io_page;\n\tbio->bi_private = page;\n\tsubmit_bio(bio);\n\twait_on_page_locked(page);\n\tbio_put(bio);\n\tif (!PageUptodate(page)) {\n\t\t__free_page(page);\n\t\treturn -EIO;\n\t}\n\tp = kmap(page);\n\tgfs2_sb_in(sdp, p);\n\tkunmap(page);\n\t__free_page(page);\n\treturn gfs2_check_sb(sdp, silent);\n}\n\n \n\nstatic int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tu32 hash_blocks, ind_blocks, leaf_blocks;\n\tu32 tmp_blocks;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\tif (error) {\n\t\tif (!silent)\n\t\t\tfs_err(sdp, \"can't read superblock\\n\");\n\t\treturn error;\n\t}\n\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n\t\t\t       GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);\n\tsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_dinode)) / sizeof(u64);\n\tsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\tsdp->sd_ldptrs = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_log_descriptor)) / sizeof(u64);\n\tsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\n\tsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\n\tsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\n\tsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\n\tsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header)) /\n\t\t\t        sizeof(struct gfs2_quota_change);\n\tsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\n\t\t\t\t     sizeof(struct gfs2_meta_header))\n\t\t* GFS2_NBBY;  \n\n\t \n\tatomic_set(&sdp->sd_log_revokes_available, sdp->sd_ldptrs);\n\n\t \n\n\thash_blocks = DIV_ROUND_UP(sizeof(u64) * BIT(GFS2_DIR_MAX_DEPTH),\n\t\t\t     sdp->sd_jbsize);\n\n\tind_blocks = 0;\n\tfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\n\t\ttmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\n\t\tind_blocks += tmp_blocks;\n\t}\n\n\tleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\n\n\tsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\n\n\tsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_dinode);\n\tsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\n\tfor (x = 2;; x++) {\n\t\tu64 space, d;\n\t\tu32 m;\n\n\t\tspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\n\t\td = space;\n\t\tm = do_div(d, sdp->sd_inptrs);\n\n\t\tif (d != sdp->sd_heightsize[x - 1] || m)\n\t\t\tbreak;\n\t\tsdp->sd_heightsize[x] = space;\n\t}\n\tsdp->sd_max_height = x;\n\tsdp->sd_heightsize[x] = ~0;\n\tgfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\n\n\tsdp->sd_max_dents_per_leaf = (sdp->sd_sb.sb_bsize -\n\t\t\t\t      sizeof(struct gfs2_leaf)) /\n\t\t\t\t     GFS2_MIN_DIRENT_SIZE;\n\treturn 0;\n}\n\nstatic int init_names(struct gfs2_sbd *sdp, int silent)\n{\n\tchar *proto, *table;\n\tint error = 0;\n\n\tproto = sdp->sd_args.ar_lockproto;\n\ttable = sdp->sd_args.ar_locktable;\n\n\t \n\n\tif (!proto[0] || !table[0]) {\n\t\terror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!proto[0])\n\t\t\tproto = sdp->sd_sb.sb_lockproto;\n\t\tif (!table[0])\n\t\t\ttable = sdp->sd_sb.sb_locktable;\n\t}\n\n\tif (!table[0])\n\t\ttable = sdp->sd_vfs->s_id;\n\n\tBUILD_BUG_ON(GFS2_LOCKNAME_LEN > GFS2_FSNAME_LEN);\n\n\tstrscpy(sdp->sd_proto_name, proto, GFS2_LOCKNAME_LEN);\n\tstrscpy(sdp->sd_table_name, table, GFS2_LOCKNAME_LEN);\n\n\ttable = sdp->sd_table_name;\n\twhile ((table = strchr(table, '/')))\n\t\t*table = '_';\n\n\treturn error;\n}\n\nstatic int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\n\t\t\tint undo)\n{\n\tint error = 0;\n\n\tif (undo)\n\t\tgoto fail_trans;\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t  LM_FLAG_NOEXP | GL_NOCACHE | GL_NOPID,\n\t\t\t\t  mount_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire mount glock: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = gfs2_glock_nq_num(sdp,\n\t\t\t\t  GFS2_LIVE_LOCK, &gfs2_nondisk_glops,\n\t\t\t\t  LM_ST_SHARED,\n\t\t\t\t  LM_FLAG_NOEXP | GL_EXACT | GL_NOPID,\n\t\t\t\t  &sdp->sd_live_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't acquire live glock: %d\\n\", error);\n\t\tgoto fail_mount;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\n\t\t\t       CREATE, &sdp->sd_rename_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create rename glock: %d\\n\", error);\n\t\tgoto fail_live;\n\t}\n\n\terror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\n\t\t\t       CREATE, &sdp->sd_freeze_gl);\n\tif (error) {\n\t\tfs_err(sdp, \"can't create freeze glock: %d\\n\", error);\n\t\tgoto fail_rename;\n\t}\n\n\treturn 0;\n\nfail_trans:\n\tgfs2_glock_put(sdp->sd_freeze_gl);\nfail_rename:\n\tgfs2_glock_put(sdp->sd_rename_gl);\nfail_live:\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\nfail_mount:\n\tgfs2_glock_dq_uninit(mount_gh);\nfail:\n\treturn error;\n}\n\nstatic int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\n\t\t\t    u64 no_addr, const char *name)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tinode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0,\n\t\t\t\t  GFS2_BLKST_FREE  );\n\tif (IS_ERR(inode)) {\n\t\tfs_err(sdp, \"can't read in %s inode: %ld\\n\", name, PTR_ERR(inode));\n\t\treturn PTR_ERR(inode);\n\t}\n\tdentry = d_make_root(inode);\n\tif (!dentry) {\n\t\tfs_err(sdp, \"can't alloc %s dentry\\n\", name);\n\t\treturn -ENOMEM;\n\t}\n\t*dptr = dentry;\n\treturn 0;\n}\n\nstatic int init_sb(struct gfs2_sbd *sdp, int silent)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_holder sb_gh;\n\tu64 no_addr;\n\tint ret;\n\n\tret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\n\t\t\t\tLM_ST_SHARED, 0, &sb_gh);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't acquire superblock glock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gfs2_read_sb(sdp, silent);\n\tif (ret) {\n\t\tfs_err(sdp, \"can't read superblock: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tswitch(sdp->sd_sb.sb_fs_format) {\n\tcase GFS2_FS_FORMAT_MAX:\n\t\tsb->s_xattr = gfs2_xattr_handlers_max;\n\t\tbreak;\n\n\tcase GFS2_FS_FORMAT_MIN:\n\t\tsb->s_xattr = gfs2_xattr_handlers_min;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\tif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too small for device \"\n\t\t       \"block size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\n\t\tgoto out;\n\t}\n\tif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\n\t\tret = -EINVAL;\n\t\tfs_err(sdp, \"FS block size (%u) is too big for machine \"\n\t\t       \"page size (%u)\\n\",\n\t\t       sdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\n\t\tgoto out;\n\t}\n\tsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\n\n\t \n\tno_addr = sdp->sd_sb.sb_root_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, \"root\");\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tno_addr = sdp->sd_sb.sb_master_dir.no_addr;\n\tret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, \"master\");\n\tif (ret) {\n\t\tdput(sdp->sd_root_dir);\n\t\tgoto out;\n\t}\n\tsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\nout:\n\tgfs2_glock_dq_uninit(&sb_gh);\n\treturn ret;\n}\n\nstatic void gfs2_others_may_mount(struct gfs2_sbd *sdp)\n{\n\tchar *message = \"FIRSTMOUNT=Done\";\n\tchar *envp[] = { message, NULL };\n\n\tfs_info(sdp, \"first mount done, others may mount\\n\");\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_first_done)\n\t\tsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n}\n\n \n\nstatic int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\n{\n\tstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\n\tstruct qstr name;\n\tchar buf[20];\n\tstruct gfs2_jdesc *jd;\n\tint error;\n\n\tname.name = buf;\n\n\tmutex_lock(&sdp->sd_jindex_mutex);\n\n\tfor (;;) {\n\t\tstruct gfs2_inode *jip;\n\n\t\terror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tname.len = sprintf(buf, \"journal%u\", sdp->sd_journals);\n\t\tname.hash = gfs2_disk_hash(name.name, name.len);\n\n\t\terror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\n\t\tif (error == -ENOENT) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tgfs2_glock_dq_uninit(ji_gh);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = -ENOMEM;\n\t\tjd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\n\t\tif (!jd)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&jd->extent_list);\n\t\tINIT_LIST_HEAD(&jd->jd_revoke_list);\n\n\t\tINIT_WORK(&jd->jd_work, gfs2_recover_func);\n\t\tjd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\n\t\tif (IS_ERR_OR_NULL(jd->jd_inode)) {\n\t\t\tif (!jd->jd_inode)\n\t\t\t\terror = -ENOENT;\n\t\t\telse\n\t\t\t\terror = PTR_ERR(jd->jd_inode);\n\t\t\tkfree(jd);\n\t\t\tbreak;\n\t\t}\n\n\t\td_mark_dontcache(jd->jd_inode);\n\t\tspin_lock(&sdp->sd_jindex_spin);\n\t\tjd->jd_jid = sdp->sd_journals++;\n\t\tjip = GFS2_I(jd->jd_inode);\n\t\tjd->jd_no_addr = jip->i_no_addr;\n\t\tlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t}\n\n\tmutex_unlock(&sdp->sd_jindex_mutex);\n\n\treturn error;\n}\n\n \nstatic int init_statfs(struct gfs2_sbd *sdp)\n{\n\tint error = 0;\n\tstruct inode *master = d_inode(sdp->sd_master_dir);\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tstruct gfs2_jdesc *jd;\n\tstruct gfs2_inode *ip;\n\n\tsdp->sd_statfs_inode = gfs2_lookup_simple(master, \"statfs\");\n\tif (IS_ERR(sdp->sd_statfs_inode)) {\n\t\terror = PTR_ERR(sdp->sd_statfs_inode);\n\t\tfs_err(sdp, \"can't read in statfs inode: %d\\n\", error);\n\t\tgoto out;\n\t}\n\tif (sdp->sd_args.ar_spectator)\n\t\tgoto out;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\tgoto put_statfs;\n\t}\n\n\t \n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tstruct local_statfs_inode *lsi =\n\t\t\tkmalloc(sizeof(struct local_statfs_inode), GFP_NOFS);\n\t\tif (!lsi) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto free_local;\n\t\t}\n\t\tsprintf(buf, \"statfs_change%u\", jd->jd_jid);\n\t\tlsi->si_sc_inode = gfs2_lookup_simple(pn, buf);\n\t\tif (IS_ERR(lsi->si_sc_inode)) {\n\t\t\terror = PTR_ERR(lsi->si_sc_inode);\n\t\t\tfs_err(sdp, \"can't find local \\\"sc\\\" file#%u: %d\\n\",\n\t\t\t       jd->jd_jid, error);\n\t\t\tkfree(lsi);\n\t\t\tgoto free_local;\n\t\t}\n\t\tlsi->si_jid = jd->jd_jid;\n\t\tif (jd->jd_jid == sdp->sd_jdesc->jd_jid)\n\t\t\tsdp->sd_sc_inode = lsi->si_sc_inode;\n\n\t\tlist_add_tail(&lsi->si_list, &sdp->sd_sc_inodes_list);\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\tip = GFS2_I(sdp->sd_sc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_NOPID,\n\t\t\t\t   &sdp->sd_sc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"sc\\\" file: %d\\n\", error);\n\t\tgoto free_local;\n\t}\n\t \n\terror = gfs2_meta_inode_buffer(ip, &sdp->sd_sc_bh);\n\tif (error) {\n\t\tfs_err(sdp, \"Cannot read in local statfs: %d\\n\", error);\n\t\tgoto unlock_sd_gh;\n\t}\n\treturn 0;\n\nunlock_sd_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\nfree_local:\n\tfree_local_statfs_inodes(sdp);\n\tiput(pn);\nput_statfs:\n\tiput(sdp->sd_statfs_inode);\nout:\n\treturn error;\n}\n\n \nstatic void uninit_statfs(struct gfs2_sbd *sdp)\n{\n\tif (!sdp->sd_args.ar_spectator) {\n\t\tbrelse(sdp->sd_sc_bh);\n\t\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\n\t\tfree_local_statfs_inodes(sdp);\n\t}\n\tiput(sdp->sd_statfs_inode);\n}\n\nstatic int init_journal(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *master = d_inode(sdp->sd_master_dir);\n\tstruct gfs2_holder ji_gh;\n\tstruct gfs2_inode *ip;\n\tint error = 0;\n\n\tgfs2_holder_mark_uninitialized(&ji_gh);\n\tif (undo)\n\t\tgoto fail_statfs;\n\n\tsdp->sd_jindex = gfs2_lookup_simple(master, \"jindex\");\n\tif (IS_ERR(sdp->sd_jindex)) {\n\t\tfs_err(sdp, \"can't lookup journal index: %d\\n\", error);\n\t\treturn PTR_ERR(sdp->sd_jindex);\n\t}\n\n\t \n\n\terror = gfs2_jindex_hold(sdp, &ji_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't read journal index: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = -EUSERS;\n\tif (!gfs2_jindex_size(sdp)) {\n\t\tfs_err(sdp, \"no journals!\\n\");\n\t\tgoto fail_jindex;\n\t}\n\n\tatomic_set(&sdp->sd_log_blks_needed, 0);\n\tif (sdp->sd_args.ar_spectator) {\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\t} else {\n\t\tif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\n\t\t\tfs_err(sdp, \"can't mount journal #%u\\n\",\n\t\t\t       sdp->sd_lockstruct.ls_jid);\n\t\t\tfs_err(sdp, \"there are only %u journals (0 - %u)\\n\",\n\t\t\t       gfs2_jindex_size(sdp),\n\t\t\t       gfs2_jindex_size(sdp) - 1);\n\t\t\tgoto fail_jindex;\n\t\t}\n\t\tsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\n\n\t\terror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\n\t\t\t\t\t  &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t\t  LM_FLAG_NOEXP | GL_NOCACHE | GL_NOPID,\n\t\t\t\t\t  &sdp->sd_journal_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal glock: %d\\n\", error);\n\t\t\tgoto fail_jindex;\n\t\t}\n\n\t\tip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\t\tsdp->sd_jinode_gl = ip->i_gl;\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT |\n\t\t\t\t\t   GL_NOCACHE | GL_NOPID,\n\t\t\t\t\t   &sdp->sd_jinode_gh);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"can't acquire journal inode glock: %d\\n\",\n\t\t\t       error);\n\t\t\tgoto fail_journal_gh;\n\t\t}\n\n\t\terror = gfs2_jdesc_check(sdp->sd_jdesc);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"my journal (%u) is bad: %d\\n\",\n\t\t\t       sdp->sd_jdesc->jd_jid, error);\n\t\t\tgoto fail_jinode_gh;\n\t\t}\n\t\tatomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\n\t\tatomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\n\t\tatomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\n\n\t\t \n\t\tgfs2_map_journal_extents(sdp, sdp->sd_jdesc);\n\t}\n\ttrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\n\n\t \n\terror = init_statfs(sdp);\n\tif (error)\n\t\tgoto fail_jinode_gh;\n\n\tif (sdp->sd_lockstruct.ls_first) {\n\t\tunsigned int x;\n\t\tfor (x = 0; x < sdp->sd_journals; x++) {\n\t\t\tstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\n\n\t\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\t\terror = check_journal_clean(sdp, jd, true);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto fail_statfs;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror = gfs2_recover_journal(jd, true);\n\t\t\tif (error) {\n\t\t\t\tfs_err(sdp, \"error recovering journal %u: %d\\n\",\n\t\t\t\t       x, error);\n\t\t\t\tgoto fail_statfs;\n\t\t\t}\n\t\t}\n\n\t\tgfs2_others_may_mount(sdp);\n\t} else if (!sdp->sd_args.ar_spectator) {\n\t\terror = gfs2_recover_journal(sdp->sd_jdesc, true);\n\t\tif (error) {\n\t\t\tfs_err(sdp, \"error recovering my journal: %d\\n\", error);\n\t\t\tgoto fail_statfs;\n\t\t}\n\t}\n\n\tsdp->sd_log_idle = 1;\n\tset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\n\tgfs2_glock_dq_uninit(&ji_gh);\n\tINIT_WORK(&sdp->sd_freeze_work, gfs2_freeze_func);\n\treturn 0;\n\nfail_statfs:\n\tuninit_statfs(sdp);\nfail_jinode_gh:\n\t \n\tif (!sdp->sd_args.ar_spectator &&\n\t    gfs2_holder_initialized(&sdp->sd_jinode_gh))\n\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\nfail_journal_gh:\n\tif (!sdp->sd_args.ar_spectator &&\n\t    gfs2_holder_initialized(&sdp->sd_journal_gh))\n\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\nfail_jindex:\n\tgfs2_jindex_free(sdp);\n\tif (gfs2_holder_initialized(&ji_gh))\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail:\n\tiput(sdp->sd_jindex);\n\treturn error;\n}\n\nstatic struct lock_class_key gfs2_quota_imutex_key;\n\nstatic int init_inodes(struct gfs2_sbd *sdp, int undo)\n{\n\tint error = 0;\n\tstruct inode *master = d_inode(sdp->sd_master_dir);\n\n\tif (undo)\n\t\tgoto fail_qinode;\n\n\terror = init_journal(sdp, undo);\n\tcomplete_all(&sdp->sd_journal_ready);\n\tif (error)\n\t\tgoto fail;\n\n\t \n\tsdp->sd_rindex = gfs2_lookup_simple(master, \"rindex\");\n\tif (IS_ERR(sdp->sd_rindex)) {\n\t\terror = PTR_ERR(sdp->sd_rindex);\n\t\tfs_err(sdp, \"can't get resource index inode: %d\\n\", error);\n\t\tgoto fail_journal;\n\t}\n\tsdp->sd_rindex_uptodate = 0;\n\n\t \n\tsdp->sd_quota_inode = gfs2_lookup_simple(master, \"quota\");\n\tif (IS_ERR(sdp->sd_quota_inode)) {\n\t\terror = PTR_ERR(sdp->sd_quota_inode);\n\t\tfs_err(sdp, \"can't get quota file inode: %d\\n\", error);\n\t\tgoto fail_rindex;\n\t}\n\t \n\tlockdep_set_class(&sdp->sd_quota_inode->i_rwsem,\n\t\t\t  &gfs2_quota_imutex_key);\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\tgoto fail_qinode;\n\n\treturn 0;\n\nfail_qinode:\n\tiput(sdp->sd_quota_inode);\nfail_rindex:\n\tgfs2_clear_rgrpd(sdp);\n\tiput(sdp->sd_rindex);\nfail_journal:\n\tinit_journal(sdp, UNDO);\nfail:\n\treturn error;\n}\n\nstatic int init_per_node(struct gfs2_sbd *sdp, int undo)\n{\n\tstruct inode *pn = NULL;\n\tchar buf[30];\n\tint error = 0;\n\tstruct gfs2_inode *ip;\n\tstruct inode *master = d_inode(sdp->sd_master_dir);\n\n\tif (sdp->sd_args.ar_spectator)\n\t\treturn 0;\n\n\tif (undo)\n\t\tgoto fail_qc_gh;\n\n\tpn = gfs2_lookup_simple(master, \"per_node\");\n\tif (IS_ERR(pn)) {\n\t\terror = PTR_ERR(pn);\n\t\tfs_err(sdp, \"can't find per_node directory: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsprintf(buf, \"quota_change%u\", sdp->sd_jdesc->jd_jid);\n\tsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\n\tif (IS_ERR(sdp->sd_qc_inode)) {\n\t\terror = PTR_ERR(sdp->sd_qc_inode);\n\t\tfs_err(sdp, \"can't find local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_ut_i;\n\t}\n\n\tiput(pn);\n\tpn = NULL;\n\n\tip = GFS2_I(sdp->sd_qc_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, GL_NOPID,\n\t\t\t\t   &sdp->sd_qc_gh);\n\tif (error) {\n\t\tfs_err(sdp, \"can't lock local \\\"qc\\\" file: %d\\n\", error);\n\t\tgoto fail_qc_i;\n\t}\n\n\treturn 0;\n\nfail_qc_gh:\n\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\nfail_qc_i:\n\tiput(sdp->sd_qc_inode);\nfail_ut_i:\n\tiput(pn);\n\treturn error;\n}\n\nstatic const match_table_t nolock_tokens = {\n\t{ Opt_jid, \"jid=%d\", },\n\t{ Opt_err, NULL },\n};\n\nstatic const struct lm_lockops nolock_ops = {\n\t.lm_proto_name = \"lock_nolock\",\n\t.lm_put_lock = gfs2_glock_free,\n\t.lm_tokens = &nolock_tokens,\n};\n\n \n\nstatic int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\n{\n\tconst struct lm_lockops *lm;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tstruct gfs2_args *args = &sdp->sd_args;\n\tconst char *proto = sdp->sd_proto_name;\n\tconst char *table = sdp->sd_table_name;\n\tchar *o, *options;\n\tint ret;\n\n\tif (!strcmp(\"lock_nolock\", proto)) {\n\t\tlm = &nolock_ops;\n\t\tsdp->sd_args.ar_localflocks = 1;\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\n\t} else if (!strcmp(\"lock_dlm\", proto)) {\n\t\tlm = &gfs2_dlm_ops;\n#endif\n\t} else {\n\t\tpr_info(\"can't find protocol %s\\n\", proto);\n\t\treturn -ENOENT;\n\t}\n\n\tfs_info(sdp, \"Trying to join cluster \\\"%s\\\", \\\"%s\\\"\\n\", proto, table);\n\n\tls->ls_ops = lm;\n\tls->ls_first = 1;\n\n\tfor (options = args->ar_hostdata; (o = strsep(&options, \":\")); ) {\n\t\tsubstring_t tmp[MAX_OPT_ARGS];\n\t\tint token, option;\n\n\t\tif (!o || !*o)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(o, *lm->lm_tokens, tmp);\n\t\tswitch (token) {\n\t\tcase Opt_jid:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || option < 0) \n\t\t\t\tgoto hostdata_error;\n\t\t\tif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\t\t\tls->ls_jid = option;\n\t\t\tbreak;\n\t\tcase Opt_id:\n\t\tcase Opt_nodir:\n\t\t\t \n\t\t\tbreak;\n\t\tcase Opt_first:\n\t\t\tret = match_int(&tmp[0], &option);\n\t\t\tif (ret || (option != 0 && option != 1))\n\t\t\t\tgoto hostdata_error;\n\t\t\tls->ls_first = option;\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\tdefault:\nhostdata_error:\n\t\t\tfs_info(sdp, \"unknown hostdata (%s)\\n\", o);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (lm->lm_mount == NULL) {\n\t\tfs_info(sdp, \"Now mounting FS (format %u)...\\n\", sdp->sd_sb.sb_fs_format);\n\t\tcomplete_all(&sdp->sd_locking_init);\n\t\treturn 0;\n\t}\n\tret = lm->lm_mount(sdp, table);\n\tif (ret == 0)\n\t\tfs_info(sdp, \"Joined cluster. Now mounting FS (format %u)...\\n\",\n\t\t        sdp->sd_sb.sb_fs_format);\n\tcomplete_all(&sdp->sd_locking_init);\n\treturn ret;\n}\n\nvoid gfs2_lm_unmount(struct gfs2_sbd *sdp)\n{\n\tconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\n\tif (likely(!gfs2_withdrawn(sdp)) && lm->lm_unmount)\n\t\tlm->lm_unmount(sdp);\n}\n\nstatic int wait_on_journal(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\treturn 0;\n\n\treturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\n\t\t? -EINTR : 0;\n}\n\nvoid gfs2_online_uevent(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\tsprintf(ro, \"RDONLY=%d\", sb_rdonly(sb));\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\n}\n\nstatic int init_threads(struct gfs2_sbd *sdp)\n{\n\tstruct task_struct *p;\n\tint error = 0;\n\n\tp = kthread_create(gfs2_logd, sdp, \"gfs2_logd/%s\", sdp->sd_fsname);\n\tif (IS_ERR(p)) {\n\t\terror = PTR_ERR(p);\n\t\tfs_err(sdp, \"can't create logd thread: %d\\n\", error);\n\t\treturn error;\n\t}\n\tget_task_struct(p);\n\tsdp->sd_logd_process = p;\n\n\tp = kthread_create(gfs2_quotad, sdp, \"gfs2_quotad/%s\", sdp->sd_fsname);\n\tif (IS_ERR(p)) {\n\t\terror = PTR_ERR(p);\n\t\tfs_err(sdp, \"can't create quotad thread: %d\\n\", error);\n\t\tgoto fail;\n\t}\n\tget_task_struct(p);\n\tsdp->sd_quotad_process = p;\n\n\twake_up_process(sdp->sd_logd_process);\n\twake_up_process(sdp->sd_quotad_process);\n\treturn 0;\n\nfail:\n\tkthread_stop(sdp->sd_logd_process);\n\tput_task_struct(sdp->sd_logd_process);\n\tsdp->sd_logd_process = NULL;\n\treturn error;\n}\n\nvoid gfs2_destroy_threads(struct gfs2_sbd *sdp)\n{\n\tif (sdp->sd_logd_process) {\n\t\tkthread_stop(sdp->sd_logd_process);\n\t\tput_task_struct(sdp->sd_logd_process);\n\t\tsdp->sd_logd_process = NULL;\n\t}\n\tif (sdp->sd_quotad_process) {\n\t\tkthread_stop(sdp->sd_quotad_process);\n\t\tput_task_struct(sdp->sd_quotad_process);\n\t\tsdp->sd_quotad_process = NULL;\n\t}\n}\n\n \nstatic int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct gfs2_args *args = fc->fs_private;\n\tint silent = fc->sb_flags & SB_SILENT;\n\tstruct gfs2_sbd *sdp;\n\tstruct gfs2_holder mount_gh;\n\tint error;\n\n\tsdp = init_sbd(sb);\n\tif (!sdp) {\n\t\tpr_warn(\"can't alloc struct gfs2_sbd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsdp->sd_args = *args;\n\n\tif (sdp->sd_args.ar_spectator) {\n                sb->s_flags |= SB_RDONLY;\n\t\tset_bit(SDF_RORECOVERY, &sdp->sd_flags);\n\t}\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= SB_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\n\tsb->s_flags |= SB_NOSEC;\n\tsb->s_magic = GFS2_MAGIC;\n\tsb->s_op = &gfs2_super_ops;\n\tsb->s_d_op = &gfs2_dops;\n\tsb->s_export_op = &gfs2_export_ops;\n\tsb->s_qcop = &gfs2_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tsb->s_time_gran = 1;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\t \n\tsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\n\tsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\n\tsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\n                               GFS2_BASIC_BLOCK_SHIFT;\n\tsdp->sd_fsb2bb = BIT(sdp->sd_fsb2bb_shift);\n\n\tsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\n\tsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\n\tif (sdp->sd_args.ar_statfs_quantum) {\n\t\tsdp->sd_tune.gt_statfs_slow = 0;\n\t\tsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\n\t} else {\n\t\tsdp->sd_tune.gt_statfs_slow = 1;\n\t\tsdp->sd_tune.gt_statfs_quantum = 30;\n\t}\n\n\terror = init_names(sdp, silent);\n\tif (error)\n\t\tgoto fail_free;\n\n\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s\", sdp->sd_table_name);\n\n\tsdp->sd_delete_wq = alloc_workqueue(\"gfs2-delete/%s\",\n\t\t\tWQ_MEM_RECLAIM | WQ_FREEZABLE, 0, sdp->sd_fsname);\n\terror = -ENOMEM;\n\tif (!sdp->sd_delete_wq)\n\t\tgoto fail_free;\n\n\terror = gfs2_sys_fs_add(sdp);\n\tif (error)\n\t\tgoto fail_delete_wq;\n\n\tgfs2_create_debugfs_file(sdp);\n\n\terror = gfs2_lm_mount(sdp, silent);\n\tif (error)\n\t\tgoto fail_debug;\n\n\terror = init_locking(sdp, &mount_gh, DO);\n\tif (error)\n\t\tgoto fail_lm;\n\n\terror = init_sb(sdp, silent);\n\tif (error)\n\t\tgoto fail_locking;\n\n\t \n\tif (!sdp->sd_args.ar_got_rgrplvb && sdp->sd_sb.sb_fs_format > 1801)\n\t\tsdp->sd_args.ar_rgrplvb = 1;\n\n\terror = wait_on_journal(sdp);\n\tif (error)\n\t\tgoto fail_sb;\n\n\t \n\tif (sdp->sd_lockstruct.ls_jid < 0) {\n\t\terror = sdp->sd_lockstruct.ls_jid;\n\t\tsdp->sd_lockstruct.ls_jid = 0;\n\t\tgoto fail_sb;\n\t}\n\n\tif (sdp->sd_args.ar_spectator)\n\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.s\",\n\t\t\t sdp->sd_table_name);\n\telse\n\t\tsnprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), \"%s.%u\",\n\t\t\t sdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\n\n\terror = init_inodes(sdp, DO);\n\tif (error)\n\t\tgoto fail_sb;\n\n\terror = init_per_node(sdp, DO);\n\tif (error)\n\t\tgoto fail_inodes;\n\n\terror = gfs2_statfs_init(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"can't initialize statfs subsystem: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\n\tif (!sb_rdonly(sb)) {\n\t\terror = init_threads(sdp);\n\t\tif (error)\n\t\t\tgoto fail_per_node;\n\t}\n\n\terror = gfs2_freeze_lock_shared(sdp);\n\tif (error)\n\t\tgoto fail_per_node;\n\n\tif (!sb_rdonly(sb))\n\t\terror = gfs2_make_fs_rw(sdp);\n\n\tif (error) {\n\t\tgfs2_freeze_unlock(&sdp->sd_freeze_gh);\n\t\tgfs2_destroy_threads(sdp);\n\t\tfs_err(sdp, \"can't make FS RW: %d\\n\", error);\n\t\tgoto fail_per_node;\n\t}\n\tgfs2_glock_dq_uninit(&mount_gh);\n\tgfs2_online_uevent(sdp);\n\treturn 0;\n\nfail_per_node:\n\tinit_per_node(sdp, UNDO);\nfail_inodes:\n\tinit_inodes(sdp, UNDO);\nfail_sb:\n\tif (sdp->sd_root_dir)\n\t\tdput(sdp->sd_root_dir);\n\tif (sdp->sd_master_dir)\n\t\tdput(sdp->sd_master_dir);\n\tif (sb->s_root)\n\t\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfail_locking:\n\tinit_locking(sdp, &mount_gh, UNDO);\nfail_lm:\n\tcomplete_all(&sdp->sd_journal_ready);\n\tgfs2_gl_hash_clear(sdp);\n\tgfs2_lm_unmount(sdp);\nfail_debug:\n\tgfs2_delete_debugfs_file(sdp);\n\tgfs2_sys_fs_del(sdp);\nfail_delete_wq:\n\tdestroy_workqueue(sdp->sd_delete_wq);\nfail_free:\n\tfree_sbd(sdp);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}\n\n \nstatic int gfs2_get_tree(struct fs_context *fc)\n{\n\tstruct gfs2_args *args = fc->fs_private;\n\tstruct gfs2_sbd *sdp;\n\tint error;\n\n\terror = get_tree_bdev(fc, gfs2_fill_super);\n\tif (error)\n\t\treturn error;\n\n\tsdp = fc->root->d_sb->s_fs_info;\n\tdput(fc->root);\n\tif (args->ar_meta)\n\t\tfc->root = dget(sdp->sd_master_dir);\n\telse\n\t\tfc->root = dget(sdp->sd_root_dir);\n\treturn 0;\n}\n\nstatic void gfs2_fc_free(struct fs_context *fc)\n{\n\tstruct gfs2_args *args = fc->fs_private;\n\n\tkfree(args);\n}\n\nenum gfs2_param {\n\tOpt_lockproto,\n\tOpt_locktable,\n\tOpt_hostdata,\n\tOpt_spectator,\n\tOpt_ignore_local_fs,\n\tOpt_localflocks,\n\tOpt_localcaching,\n\tOpt_debug,\n\tOpt_upgrade,\n\tOpt_acl,\n\tOpt_quota,\n\tOpt_quota_flag,\n\tOpt_suiddir,\n\tOpt_data,\n\tOpt_meta,\n\tOpt_discard,\n\tOpt_commit,\n\tOpt_errors,\n\tOpt_statfs_quantum,\n\tOpt_statfs_percent,\n\tOpt_quota_quantum,\n\tOpt_barrier,\n\tOpt_rgrplvb,\n\tOpt_loccookie,\n};\n\nstatic const struct constant_table gfs2_param_quota[] = {\n\t{\"off\",        GFS2_QUOTA_OFF},\n\t{\"account\",    GFS2_QUOTA_ACCOUNT},\n\t{\"on\",         GFS2_QUOTA_ON},\n\t{\"quiet\",      GFS2_QUOTA_QUIET},\n\t{}\n};\n\nenum opt_data {\n\tOpt_data_writeback = GFS2_DATA_WRITEBACK,\n\tOpt_data_ordered   = GFS2_DATA_ORDERED,\n};\n\nstatic const struct constant_table gfs2_param_data[] = {\n\t{\"writeback\",  Opt_data_writeback },\n\t{\"ordered\",    Opt_data_ordered },\n\t{}\n};\n\nenum opt_errors {\n\tOpt_errors_withdraw = GFS2_ERRORS_WITHDRAW,\n\tOpt_errors_panic    = GFS2_ERRORS_PANIC,\n};\n\nstatic const struct constant_table gfs2_param_errors[] = {\n\t{\"withdraw\",   Opt_errors_withdraw },\n\t{\"panic\",      Opt_errors_panic },\n\t{}\n};\n\nstatic const struct fs_parameter_spec gfs2_fs_parameters[] = {\n\tfsparam_string (\"lockproto\",          Opt_lockproto),\n\tfsparam_string (\"locktable\",          Opt_locktable),\n\tfsparam_string (\"hostdata\",           Opt_hostdata),\n\tfsparam_flag   (\"spectator\",          Opt_spectator),\n\tfsparam_flag   (\"norecovery\",         Opt_spectator),\n\tfsparam_flag   (\"ignore_local_fs\",    Opt_ignore_local_fs),\n\tfsparam_flag   (\"localflocks\",        Opt_localflocks),\n\tfsparam_flag   (\"localcaching\",       Opt_localcaching),\n\tfsparam_flag_no(\"debug\",              Opt_debug),\n\tfsparam_flag   (\"upgrade\",            Opt_upgrade),\n\tfsparam_flag_no(\"acl\",                Opt_acl),\n\tfsparam_flag_no(\"suiddir\",            Opt_suiddir),\n\tfsparam_enum   (\"data\",               Opt_data, gfs2_param_data),\n\tfsparam_flag   (\"meta\",               Opt_meta),\n\tfsparam_flag_no(\"discard\",            Opt_discard),\n\tfsparam_s32    (\"commit\",             Opt_commit),\n\tfsparam_enum   (\"errors\",             Opt_errors, gfs2_param_errors),\n\tfsparam_s32    (\"statfs_quantum\",     Opt_statfs_quantum),\n\tfsparam_s32    (\"statfs_percent\",     Opt_statfs_percent),\n\tfsparam_s32    (\"quota_quantum\",      Opt_quota_quantum),\n\tfsparam_flag_no(\"barrier\",            Opt_barrier),\n\tfsparam_flag_no(\"rgrplvb\",            Opt_rgrplvb),\n\tfsparam_flag_no(\"loccookie\",          Opt_loccookie),\n\t \n\tfsparam_flag_no(\"quota\",\t      Opt_quota_flag),\n\tfsparam_enum(\"quota\",\t\t      Opt_quota, gfs2_param_quota),\n\t{}\n};\n\n \nstatic int gfs2_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct gfs2_args *args = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint o;\n\n\to = fs_parse(fc, gfs2_fs_parameters, param, &result);\n\tif (o < 0)\n\t\treturn o;\n\n\tswitch (o) {\n\tcase Opt_lockproto:\n\t\tstrscpy(args->ar_lockproto, param->string, GFS2_LOCKNAME_LEN);\n\t\tbreak;\n\tcase Opt_locktable:\n\t\tstrscpy(args->ar_locktable, param->string, GFS2_LOCKNAME_LEN);\n\t\tbreak;\n\tcase Opt_hostdata:\n\t\tstrscpy(args->ar_hostdata, param->string, GFS2_LOCKNAME_LEN);\n\t\tbreak;\n\tcase Opt_spectator:\n\t\targs->ar_spectator = 1;\n\t\tbreak;\n\tcase Opt_ignore_local_fs:\n\t\t \n\t\tbreak;\n\tcase Opt_localflocks:\n\t\targs->ar_localflocks = 1;\n\t\tbreak;\n\tcase Opt_localcaching:\n\t\t \n\t\tbreak;\n\tcase Opt_debug:\n\t\tif (result.boolean && args->ar_errors == GFS2_ERRORS_PANIC)\n\t\t\treturn invalfc(fc, \"-o debug and -o errors=panic are mutually exclusive\");\n\t\targs->ar_debug = result.boolean;\n\t\tbreak;\n\tcase Opt_upgrade:\n\t\t \n\t\tbreak;\n\tcase Opt_acl:\n\t\targs->ar_posix_acl = result.boolean;\n\t\tbreak;\n\tcase Opt_quota_flag:\n\t\targs->ar_quota = result.negated ? GFS2_QUOTA_OFF : GFS2_QUOTA_ON;\n\t\tbreak;\n\tcase Opt_quota:\n\t\targs->ar_quota = result.int_32;\n\t\tbreak;\n\tcase Opt_suiddir:\n\t\targs->ar_suiddir = result.boolean;\n\t\tbreak;\n\tcase Opt_data:\n\t\t \n\t\targs->ar_data = result.uint_32;\n\t\tbreak;\n\tcase Opt_meta:\n\t\targs->ar_meta = 1;\n\t\tbreak;\n\tcase Opt_discard:\n\t\targs->ar_discard = result.boolean;\n\t\tbreak;\n\tcase Opt_commit:\n\t\tif (result.int_32 <= 0)\n\t\t\treturn invalfc(fc, \"commit mount option requires a positive numeric argument\");\n\t\targs->ar_commit = result.int_32;\n\t\tbreak;\n\tcase Opt_statfs_quantum:\n\t\tif (result.int_32 < 0)\n\t\t\treturn invalfc(fc, \"statfs_quantum mount option requires a non-negative numeric argument\");\n\t\targs->ar_statfs_quantum = result.int_32;\n\t\tbreak;\n\tcase Opt_quota_quantum:\n\t\tif (result.int_32 <= 0)\n\t\t\treturn invalfc(fc, \"quota_quantum mount option requires a positive numeric argument\");\n\t\targs->ar_quota_quantum = result.int_32;\n\t\tbreak;\n\tcase Opt_statfs_percent:\n\t\tif (result.int_32 < 0 || result.int_32 > 100)\n\t\t\treturn invalfc(fc, \"statfs_percent mount option requires a numeric argument between 0 and 100\");\n\t\targs->ar_statfs_percent = result.int_32;\n\t\tbreak;\n\tcase Opt_errors:\n\t\tif (args->ar_debug && result.uint_32 == GFS2_ERRORS_PANIC)\n\t\t\treturn invalfc(fc, \"-o debug and -o errors=panic are mutually exclusive\");\n\t\targs->ar_errors = result.uint_32;\n\t\tbreak;\n\tcase Opt_barrier:\n\t\targs->ar_nobarrier = result.boolean;\n\t\tbreak;\n\tcase Opt_rgrplvb:\n\t\targs->ar_rgrplvb = result.boolean;\n\t\targs->ar_got_rgrplvb = 1;\n\t\tbreak;\n\tcase Opt_loccookie:\n\t\targs->ar_loccookie = result.boolean;\n\t\tbreak;\n\tdefault:\n\t\treturn invalfc(fc, \"invalid mount option: %s\", param->key);\n\t}\n\treturn 0;\n}\n\nstatic int gfs2_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_args *oldargs = &sdp->sd_args;\n\tstruct gfs2_args *newargs = fc->fs_private;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\tint error = 0;\n\n\tsync_filesystem(sb);\n\n\tspin_lock(&gt->gt_spin);\n\toldargs->ar_commit = gt->gt_logd_secs;\n\toldargs->ar_quota_quantum = gt->gt_quota_quantum;\n\tif (gt->gt_statfs_slow)\n\t\toldargs->ar_statfs_quantum = 0;\n\telse\n\t\toldargs->ar_statfs_quantum = gt->gt_statfs_quantum;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (strcmp(newargs->ar_lockproto, oldargs->ar_lockproto)) {\n\t\terrorfc(fc, \"reconfiguration of locking protocol not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(newargs->ar_locktable, oldargs->ar_locktable)) {\n\t\terrorfc(fc, \"reconfiguration of lock table not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(newargs->ar_hostdata, oldargs->ar_hostdata)) {\n\t\terrorfc(fc, \"reconfiguration of host data not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (newargs->ar_spectator != oldargs->ar_spectator) {\n\t\terrorfc(fc, \"reconfiguration of spectator mode not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (newargs->ar_localflocks != oldargs->ar_localflocks) {\n\t\terrorfc(fc, \"reconfiguration of localflocks not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (newargs->ar_meta != oldargs->ar_meta) {\n\t\terrorfc(fc, \"switching between gfs2 and gfs2meta not allowed\");\n\t\treturn -EINVAL;\n\t}\n\tif (oldargs->ar_spectator)\n\t\tfc->sb_flags |= SB_RDONLY;\n\n\tif ((sb->s_flags ^ fc->sb_flags) & SB_RDONLY) {\n\t\tif (fc->sb_flags & SB_RDONLY) {\n\t\t\tgfs2_make_fs_ro(sdp);\n\t\t} else {\n\t\t\terror = gfs2_make_fs_rw(sdp);\n\t\t\tif (error)\n\t\t\t\terrorfc(fc, \"unable to remount read-write\");\n\t\t}\n\t}\n\tsdp->sd_args = *newargs;\n\n\tif (sdp->sd_args.ar_posix_acl)\n\t\tsb->s_flags |= SB_POSIXACL;\n\telse\n\t\tsb->s_flags &= ~SB_POSIXACL;\n\tif (sdp->sd_args.ar_nobarrier)\n\t\tset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\telse\n\t\tclear_bit(SDF_NOBARRIERS, &sdp->sd_flags);\n\tspin_lock(&gt->gt_spin);\n\tgt->gt_logd_secs = newargs->ar_commit;\n\tgt->gt_quota_quantum = newargs->ar_quota_quantum;\n\tif (newargs->ar_statfs_quantum) {\n\t\tgt->gt_statfs_slow = 0;\n\t\tgt->gt_statfs_quantum = newargs->ar_statfs_quantum;\n\t}\n\telse {\n\t\tgt->gt_statfs_slow = 1;\n\t\tgt->gt_statfs_quantum = 30;\n\t}\n\tspin_unlock(&gt->gt_spin);\n\n\tgfs2_online_uevent(sdp);\n\treturn error;\n}\n\nstatic const struct fs_context_operations gfs2_context_ops = {\n\t.free        = gfs2_fc_free,\n\t.parse_param = gfs2_parse_param,\n\t.get_tree    = gfs2_get_tree,\n\t.reconfigure = gfs2_reconfigure,\n};\n\n \nstatic int gfs2_init_fs_context(struct fs_context *fc)\n{\n\tstruct gfs2_args *args;\n\n\targs = kmalloc(sizeof(*args), GFP_KERNEL);\n\tif (args == NULL)\n\t\treturn -ENOMEM;\n\n\tif (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {\n\t\tstruct gfs2_sbd *sdp = fc->root->d_sb->s_fs_info;\n\n\t\t*args = sdp->sd_args;\n\t} else {\n\t\tmemset(args, 0, sizeof(*args));\n\t\targs->ar_quota = GFS2_QUOTA_DEFAULT;\n\t\targs->ar_data = GFS2_DATA_DEFAULT;\n\t\targs->ar_commit = 30;\n\t\targs->ar_statfs_quantum = 30;\n\t\targs->ar_quota_quantum = 60;\n\t\targs->ar_errors = GFS2_ERRORS_DEFAULT;\n\t}\n\tfc->fs_private = args;\n\tfc->ops = &gfs2_context_ops;\n\treturn 0;\n}\n\nstatic int set_meta_super(struct super_block *s, struct fs_context *fc)\n{\n\treturn -EINVAL;\n}\n\nstatic int test_meta_super(struct super_block *s, struct fs_context *fc)\n{\n\treturn (fc->sget_key == s->s_bdev);\n}\n\nstatic int gfs2_meta_get_tree(struct fs_context *fc)\n{\n\tstruct super_block *s;\n\tstruct gfs2_sbd *sdp;\n\tstruct path path;\n\tint error;\n\n\tif (!fc->source || !*fc->source)\n\t\treturn -EINVAL;\n\n\terror = kern_path(fc->source, LOOKUP_FOLLOW, &path);\n\tif (error) {\n\t\tpr_warn(\"path_lookup on %s returned error %d\\n\",\n\t\t        fc->source, error);\n\t\treturn error;\n\t}\n\tfc->fs_type = &gfs2_fs_type;\n\tfc->sget_key = path.dentry->d_sb->s_bdev;\n\ts = sget_fc(fc, test_meta_super, set_meta_super);\n\tpath_put(&path);\n\tif (IS_ERR(s)) {\n\t\tpr_warn(\"gfs2 mount does not exist\\n\");\n\t\treturn PTR_ERR(s);\n\t}\n\tif ((fc->sb_flags ^ s->s_flags) & SB_RDONLY) {\n\t\tdeactivate_locked_super(s);\n\t\treturn -EBUSY;\n\t}\n\tsdp = s->s_fs_info;\n\tfc->root = dget(sdp->sd_master_dir);\n\treturn 0;\n}\n\nstatic const struct fs_context_operations gfs2_meta_context_ops = {\n\t.free        = gfs2_fc_free,\n\t.get_tree    = gfs2_meta_get_tree,\n};\n\nstatic int gfs2_meta_init_fs_context(struct fs_context *fc)\n{\n\tint ret = gfs2_init_fs_context(fc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tfc->ops = &gfs2_meta_context_ops;\n\treturn 0;\n}\n\n \nstatic void gfs2_evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *toput_inode = NULL;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tset_bit(SDF_EVICTING, &sdp->sd_flags);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) &&\n\t\t    !need_resched()) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tatomic_inc(&inode->i_count);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&sb->s_inode_list_lock);\n\n\t\tiput(toput_inode);\n\t\ttoput_inode = inode;\n\n\t\tcond_resched();\n\t\tspin_lock(&sb->s_inode_list_lock);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\tiput(toput_inode);\n}\n\nstatic void gfs2_kill_sb(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tif (sdp == NULL) {\n\t\tkill_block_super(sb);\n\t\treturn;\n\t}\n\n\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_SYNC | GFS2_LFC_KILL_SB);\n\tdput(sdp->sd_root_dir);\n\tdput(sdp->sd_master_dir);\n\tsdp->sd_root_dir = NULL;\n\tsdp->sd_master_dir = NULL;\n\tshrink_dcache_sb(sb);\n\n\tgfs2_evict_inodes(sb);\n\n\t \n\tset_bit(SDF_KILL, &sdp->sd_flags);\n\tgfs2_flush_delete_work(sdp);\n\tdestroy_workqueue(sdp->sd_delete_wq);\n\n\tkill_block_super(sb);\n}\n\nstruct file_system_type gfs2_fs_type = {\n\t.name = \"gfs2\",\n\t.fs_flags = FS_REQUIRES_DEV,\n\t.init_fs_context = gfs2_init_fs_context,\n\t.parameters = gfs2_fs_parameters,\n\t.kill_sb = gfs2_kill_sb,\n\t.owner = THIS_MODULE,\n};\nMODULE_ALIAS_FS(\"gfs2\");\n\nstruct file_system_type gfs2meta_fs_type = {\n\t.name = \"gfs2meta\",\n\t.fs_flags = FS_REQUIRES_DEV,\n\t.init_fs_context = gfs2_meta_init_fs_context,\n\t.owner = THIS_MODULE,\n};\nMODULE_ALIAS_FS(\"gfs2meta\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}