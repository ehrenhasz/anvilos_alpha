{
  "module_name": "lock_dlm.c",
  "hash_id": "508bbb2f57fc7c2fe785ac6d2584a8a7d47c3eb402a79519925380570e85d08e",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/lock_dlm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/dlm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sched/signal.h>\n\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"recovery.h\"\n#include \"util.h\"\n#include \"sys.h\"\n#include \"trace_gfs2.h\"\n\n \nstatic inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\t \n\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += (s64)(abs(delta) - s->stats[index]) >> 2;\n}\n\n \nstatic inline void gfs2_update_reply_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tunsigned index = test_bit(GLF_BLOCKING, &gl->gl_flags) ?\n\t\t\t GFS2_LKS_SRTTB : GFS2_LKS_SRTT;\n\ts64 rtt;\n\n\tpreempt_disable();\n\trtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));\n\tlks = this_cpu_ptr(gl->gl_name.ln_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, index, rtt);\t\t \n\tgfs2_update_stats(&lks->lkstats[gltype], index, rtt);\t \n\tpreempt_enable();\n\n\ttrace_gfs2_glock_lock_time(gl, rtt);\n}\n\n \n\nstatic inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_name.ln_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t \n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t \n\tpreempt_enable();\n}\n \nstatic void gdlm_ast(void *arg)\n{\n\tstruct gfs2_glock *gl = arg;\n\tunsigned ret = gl->gl_state;\n\n\tgfs2_update_reply_times(gl);\n\tBUG_ON(gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED);\n\n\tif ((gl->gl_lksb.sb_flags & DLM_SBF_VALNOTVALID) && gl->gl_lksb.sb_lvbptr)\n\t\tmemset(gl->gl_lksb.sb_lvbptr, 0, GDLM_LVB_SIZE);\n\n\tswitch (gl->gl_lksb.sb_status) {\n\tcase -DLM_EUNLOCK:  \n\t\tif (gl->gl_ops->go_free)\n\t\t\tgl->gl_ops->go_free(gl);\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\tcase -DLM_ECANCEL:  \n\t\tret |= LM_OUT_CANCELED;\n\t\tgoto out;\n\tcase -EAGAIN:  \n\tcase -EDEADLK:  \n\t\tgoto out;\n\tcase -ETIMEDOUT:  \n\t\tret |= LM_OUT_ERROR;\n\t\tgoto out;\n\tcase 0:  \n\t\tbreak;\n\tdefault:  \n\t\tBUG();\n\t}\n\n\tret = gl->gl_req;\n\tif (gl->gl_lksb.sb_flags & DLM_SBF_ALTMODE) {\n\t\tif (gl->gl_req == LM_ST_SHARED)\n\t\t\tret = LM_ST_DEFERRED;\n\t\telse if (gl->gl_req == LM_ST_DEFERRED)\n\t\t\tret = LM_ST_SHARED;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tset_bit(GLF_INITIAL, &gl->gl_flags);\n\tgfs2_glock_complete(gl, ret);\n\treturn;\nout:\n\tif (!test_bit(GLF_INITIAL, &gl->gl_flags))\n\t\tgl->gl_lksb.sb_lkid = 0;\n\tgfs2_glock_complete(gl, ret);\n}\n\nstatic void gdlm_bast(void *arg, int mode)\n{\n\tstruct gfs2_glock *gl = arg;\n\n\tswitch (mode) {\n\tcase DLM_LOCK_EX:\n\t\tgfs2_glock_cb(gl, LM_ST_UNLOCKED);\n\t\tbreak;\n\tcase DLM_LOCK_CW:\n\t\tgfs2_glock_cb(gl, LM_ST_DEFERRED);\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tgfs2_glock_cb(gl, LM_ST_SHARED);\n\t\tbreak;\n\tdefault:\n\t\tfs_err(gl->gl_name.ln_sbd, \"unknown bast mode %d\\n\", mode);\n\t\tBUG();\n\t}\n}\n\n \n\nstatic int make_mode(struct gfs2_sbd *sdp, const unsigned int lmstate)\n{\n\tswitch (lmstate) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn DLM_LOCK_NL;\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn DLM_LOCK_EX;\n\tcase LM_ST_DEFERRED:\n\t\treturn DLM_LOCK_CW;\n\tcase LM_ST_SHARED:\n\t\treturn DLM_LOCK_PR;\n\t}\n\tfs_err(sdp, \"unknown LM state %d\\n\", lmstate);\n\tBUG();\n\treturn -1;\n}\n\nstatic u32 make_flags(struct gfs2_glock *gl, const unsigned int gfs_flags,\n\t\t      const int req)\n{\n\tu32 lkf = 0;\n\n\tif (gl->gl_lksb.sb_lvbptr)\n\t\tlkf |= DLM_LKF_VALBLK;\n\n\tif (gfs_flags & LM_FLAG_TRY)\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\n\tif (gfs_flags & LM_FLAG_TRY_1CB) {\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\t\tlkf |= DLM_LKF_NOQUEUEBAST;\n\t}\n\n\tif (gfs_flags & LM_FLAG_ANY) {\n\t\tif (req == DLM_LOCK_PR)\n\t\t\tlkf |= DLM_LKF_ALTCW;\n\t\telse if (req == DLM_LOCK_CW)\n\t\t\tlkf |= DLM_LKF_ALTPR;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tif (gl->gl_lksb.sb_lkid != 0) {\n\t\tlkf |= DLM_LKF_CONVERT;\n\t\tif (test_bit(GLF_BLOCKING, &gl->gl_flags))\n\t\t\tlkf |= DLM_LKF_QUECVT;\n\t}\n\n\treturn lkf;\n}\n\nstatic void gfs2_reverse_hex(char *c, u64 value)\n{\n\t*c = '0';\n\twhile (value) {\n\t\t*c-- = hex_asc[value & 0x0f];\n\t\tvalue >>= 4;\n\t}\n}\n\nstatic int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,\n\t\t     unsigned int flags)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;\n\tint req;\n\tu32 lkf;\n\tchar strname[GDLM_STRNAME_BYTES] = \"\";\n\tint error;\n\n\treq = make_mode(gl->gl_name.ln_sbd, req_state);\n\tlkf = make_flags(gl, flags, req);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tif (gl->gl_lksb.sb_lkid) {\n\t\tgfs2_update_request_times(gl);\n\t} else {\n\t\tmemset(strname, ' ', GDLM_STRNAME_BYTES - 1);\n\t\tstrname[GDLM_STRNAME_BYTES - 1] = '\\0';\n\t\tgfs2_reverse_hex(strname + 7, gl->gl_name.ln_type);\n\t\tgfs2_reverse_hex(strname + 23, gl->gl_name.ln_number);\n\t\tgl->gl_dstamp = ktime_get_real();\n\t}\n\t \n\nagain:\n\terror = dlm_lock(ls->ls_dlm, req, &gl->gl_lksb, lkf, strname,\n\t\t\tGDLM_STRNAME_BYTES - 1, 0, gdlm_ast, gl, gdlm_bast);\n\tif (error == -EBUSY) {\n\t\tmsleep(20);\n\t\tgoto again;\n\t}\n\treturn error;\n}\n\nstatic void gdlm_put_lock(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\tif (gl->gl_lksb.sb_lkid == 0)\n\t\tgoto out_free;\n\n\tclear_bit(GLF_BLOCKING, &gl->gl_flags);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_update_request_times(gl);\n\n\t \n\tif (test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tgoto out_free;\n\t \n\n\tif (test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags) &&\n\t    !gl->gl_lksb.sb_lvbptr)\n\t\tgoto out_free;\n\nagain:\n\terror = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,\n\t\t\t   NULL, gl);\n\tif (error == -EBUSY) {\n\t\tmsleep(20);\n\t\tgoto again;\n\t}\n\n\tif (error) {\n\t\tfs_err(sdp, \"gdlm_unlock %x,%llx err=%d\\n\",\n\t\t       gl->gl_name.ln_type,\n\t\t       (unsigned long long)gl->gl_name.ln_number, error);\n\t}\n\treturn;\n\nout_free:\n\tgfs2_glock_free(gl);\n}\n\nstatic void gdlm_cancel(struct gfs2_glock *gl)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;\n\tdlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_CANCEL, NULL, gl);\n}\n\n \n\n#define JID_BITMAP_OFFSET 8  \n\nstatic void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}\n\nstatic void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}\n\nstatic int all_jid_bits_clear(char *lvb)\n{\n\treturn !memchr_inv(lvb + JID_BITMAP_OFFSET, 0,\n\t\t\tGDLM_LVB_SIZE - JID_BITMAP_OFFSET);\n}\n\nstatic void sync_wait_cb(void *arg)\n{\n\tstruct lm_lockstruct *ls = arg;\n\tcomplete(&ls->ls_sync_wait);\n}\n\nstatic int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}\n\nstatic int mounted_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_mounted_lksb, \"mounted_lock\");\n}\n\nstatic int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}\n\nstatic int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}\n\nstatic int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}\n\n \nstatic void remote_withdraw(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_jdesc *jd;\n\tint ret = 0, count = 0;\n\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (jd->jd_jid == sdp->sd_lockstruct.ls_jid)\n\t\t\tcontinue;\n\t\tret = gfs2_recover_journal(jd, true);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\n\t \n\tfs_err(sdp, \"Journals checked: %d, ret = %d.\\n\", count, ret);\n}\n\nstatic void gfs2_control_func(struct work_struct *work)\n{\n\tstruct gfs2_sbd *sdp = container_of(work, struct gfs2_sbd, sd_control_work.work);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t block_gen, start_gen, lvb_gen, flags;\n\tint recover_set = 0;\n\tint write_lvb = 0;\n\tint recover_size;\n\tint i, error;\n\n\t \n\tif (test_bit(SDF_REMOTE_WITHDRAW, &sdp->sd_flags)) {\n\t\tremote_withdraw(sdp);\n\t\tclear_bit(SDF_REMOTE_WITHDRAW, &sdp->sd_flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\t \n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tspin_unlock(&ls->ls_recover_spin);\n\n\t \n\n\tif (block_gen == start_gen)\n\t\treturn;\n\n\t \n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock EX error %d\\n\", error);\n\t\treturn;\n\t}\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (block_gen != ls->ls_recover_block ||\n\t    start_gen != ls->ls_recover_start) {\n\t\tfs_info(sdp, \"recover generation %u block1 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\treturn;\n\t}\n\n\trecover_size = ls->ls_recover_size;\n\n\tif (lvb_gen <= start_gen) {\n\t\t \n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (ls->ls_recover_result[i] != LM_RD_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tls->ls_recover_result[i] = 0;\n\n\t\t\tif (!test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET))\n\t\t\t\tcontinue;\n\n\t\t\t__clear_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\twrite_lvb = 1;\n\t\t}\n\t}\n\n\tif (lvb_gen == start_gen) {\n\t\t \n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < lvb_gen)\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t}\n\t} else if (lvb_gen < start_gen) {\n\t\t \n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < start_gen) {\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t\t\t__set_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\t}\n\t\t}\n\t\t \n\t\twrite_lvb = 1;\n\t} else {\n\t\t \n\t}\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tif (write_lvb) {\n\t\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\t\tflags = DLM_LKF_CONVERT | DLM_LKF_VALBLK;\n\t} else {\n\t\tflags = DLM_LKF_CONVERT;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, flags);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock NL error %d\\n\", error);\n\t\treturn;\n\t}\n\n\t \n\n\tfor (i = 0; i < recover_size; i++) {\n\t\tif (test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET)) {\n\t\t\tfs_info(sdp, \"recover generation %u jid %d\\n\",\n\t\t\t\tstart_gen, i);\n\t\t\tgfs2_recover_set(sdp, i);\n\t\t\trecover_set++;\n\t\t}\n\t}\n\tif (recover_set)\n\t\treturn;\n\n\t \n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_block == block_gen &&\n\t    ls->ls_recover_start == start_gen) {\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"recover generation %u done\\n\", start_gen);\n\t\tgfs2_glock_thaw(sdp);\n\t} else {\n\t\tfs_info(sdp, \"recover generation %u block2 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t}\n}\n\nstatic int control_mount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen, mount_gen, lvb_gen;\n\tint mounted_mode;\n\tint retries = 0;\n\tint error;\n\n\tmemset(&ls->ls_mounted_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lvb, 0, GDLM_LVB_SIZE);\n\tls->ls_control_lksb.sb_lvbptr = ls->ls_control_lvb;\n\tinit_completion(&ls->ls_sync_wait);\n\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount control_lock NL error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_NL, 0);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount mounted_lock NL error %d\\n\", error);\n\t\tcontrol_unlock(sdp);\n\t\treturn error;\n\t}\n\tmounted_mode = DLM_LOCK_NL;\n\nrestart:\n\tif (retries++ && signal_pending(current)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\t \n\n\tif (mounted_mode != DLM_LOCK_NL) {\n\t\terror = mounted_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tmounted_mode = DLM_LOCK_NL;\n\t}\n\n\t \n\n\tmsleep_interruptible(500);\n\n\t \n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE|DLM_LKF_VALBLK);\n\tif (error == -EAGAIN) {\n\t\tgoto restart;\n\t} else if (error) {\n\t\tfs_err(sdp, \"control_mount control_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (sdp->sd_args.ar_spectator)\n\t\tgoto locks_done;\n\n\terror = mounted_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_EX;\n\t\tgoto locks_done;\n\t} else if (error != -EAGAIN) {\n\t\tfs_err(sdp, \"control_mount mounted_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_PR;\n\t\tgoto locks_done;\n\t} else {\n\t\t \n\t\tfs_err(sdp, \"control_mount mounted_lock PR error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\nlocks_done:\n\t \n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tif (lvb_gen == 0xFFFFFFFF) {\n\t\t \n\t\tfs_err(sdp, \"control_mount control_lock disabled\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (mounted_mode == DLM_LOCK_EX) {\n\t\t \n\t\tspin_lock(&ls->ls_recover_spin);\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\t\tset_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"first mounter control generation %u\\n\", lvb_gen);\n\t\treturn 0;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\tif (error)\n\t\tgoto fail;\n\n\t \n\n\tif (!all_jid_bits_clear(ls->ls_lvb_bits)) {\n\t\t \n\t\tfs_info(sdp, \"control_mount wait for journal recovery\\n\");\n\t\tgoto restart;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tmount_gen = ls->ls_recover_mount;\n\n\tif (lvb_gen < mount_gen) {\n\t\t \n\t\tif (sdp->sd_args.ar_spectator) {\n\t\t\tfs_info(sdp, \"Recovery is required. Waiting for a \"\n\t\t\t\t\"non-spectator to mount.\\n\");\n\t\t\tmsleep_interruptible(1000);\n\t\t} else {\n\t\t\tfs_info(sdp, \"control_mount wait1 block %u start %u \"\n\t\t\t\t\"mount %u lvb %u flags %lx\\n\", block_gen,\n\t\t\t\tstart_gen, mount_gen, lvb_gen,\n\t\t\t\tls->ls_recover_flags);\n\t\t}\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (lvb_gen != start_gen) {\n\t\t \n\t\tfs_info(sdp, \"control_mount wait2 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (block_gen == start_gen) {\n\t\t \n\t\tfs_info(sdp, \"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n\nfail:\n\tmounted_unlock(sdp);\n\tcontrol_unlock(sdp);\n\treturn error;\n}\n\nstatic int control_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen;\n\tint error;\n\nrestart:\n\tspin_lock(&ls->ls_recover_spin);\n\tstart_gen = ls->ls_recover_start;\n\tblock_gen = ls->ls_recover_block;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\t \n\t\tfs_err(sdp, \"control_first_done start %u block %u flags %lx\\n\",\n\t\t       start_gen, block_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_unlock(sdp);\n\t\treturn -1;\n\t}\n\n\tif (start_gen == block_gen) {\n\t\t \n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"control_first_done wait gen %u\\n\", start_gen);\n\n\t\twait_on_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tset_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tmemset(ls->ls_lvb_bits, 0, GDLM_LVB_SIZE);\n\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done mounted PR error %d\\n\", error);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done control NL error %d\\n\", error);\n\n\treturn error;\n}\n\n \n\n#define RECOVER_SIZE_INC 16\n\nstatic int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\tnew_size = old_size;\n\twhile (new_size < max_jid + 1)\n\t\tnew_size += RECOVER_SIZE_INC;\n\tif (new_size == old_size)\n\t\treturn 0;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}\n\nstatic void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n\tls->ls_lvb_bits = NULL;\n}\n\n \n\nstatic void gdlm_recover_prep(void *arg)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (gfs2_withdrawn(sdp)) {\n\t\tfs_err(sdp, \"recover_prep ignored due to withdraw.\\n\");\n\t\treturn;\n\t}\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_block = ls->ls_recover_start;\n\tset_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n}\n\n \n\nstatic void gdlm_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint jid = slot->slot - 1;\n\n\tif (gfs2_withdrawn(sdp)) {\n\t\tfs_err(sdp, \"recover_slot jid %d ignored due to withdraw.\\n\",\n\t\t       jid);\n\t\treturn;\n\t}\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recover_slot jid %d gen %u short size %d\\n\",\n\t\t       jid, ls->ls_recover_block, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tif (ls->ls_recover_submit[jid]) {\n\t\tfs_info(sdp, \"recover_slot jid %d gen %u prev %u\\n\",\n\t\t\tjid, ls->ls_recover_block, ls->ls_recover_submit[jid]);\n\t}\n\tls->ls_recover_submit[jid] = ls->ls_recover_block;\n\tspin_unlock(&ls->ls_recover_spin);\n}\n\n \n\nstatic void gdlm_recover_done(void *arg, struct dlm_slot *slots, int num_slots,\n\t\t\t      int our_slot, uint32_t generation)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (gfs2_withdrawn(sdp)) {\n\t\tfs_err(sdp, \"recover_done ignored due to withdraw.\\n\");\n\t\treturn;\n\t}\n\t \n\tset_recover_size(sdp, slots, num_slots);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_start = generation;\n\n\tif (!ls->ls_recover_mount) {\n\t\tls->ls_recover_mount = generation;\n\t\tls->ls_jid = our_slot - 1;\n\t}\n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work, 0);\n\n\tclear_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY);\n\tspin_unlock(&ls->ls_recover_spin);\n}\n\n \n\nstatic void gdlm_recovery_result(struct gfs2_sbd *sdp, unsigned int jid,\n\t\t\t\t unsigned int result)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (gfs2_withdrawn(sdp)) {\n\t\tfs_err(sdp, \"recovery_result jid %d ignored due to withdraw.\\n\",\n\t\t       jid);\n\t\treturn;\n\t}\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\t \n\tif (jid == ls->ls_jid)\n\t\treturn;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recovery_result jid %d short size %d\\n\",\n\t\t       jid, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tfs_info(sdp, \"recover jid %d result %s\\n\", jid,\n\t\tresult == LM_RD_GAVEUP ? \"busy\" : \"success\");\n\n\tls->ls_recover_result[jid] = result;\n\n\t \n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work,\n\t\t\t\t   result == LM_RD_GAVEUP ? HZ : 0);\n\tspin_unlock(&ls->ls_recover_spin);\n}\n\nstatic const struct dlm_lockspace_ops gdlm_lockspace_ops = {\n\t.recover_prep = gdlm_recover_prep,\n\t.recover_slot = gdlm_recover_slot,\n\t.recover_done = gdlm_recover_done,\n};\n\nstatic int gdlm_mount(struct gfs2_sbd *sdp, const char *table)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar cluster[GFS2_LOCKNAME_LEN];\n\tconst char *fsname;\n\tuint32_t flags;\n\tint error, ops_result;\n\n\t \n\n\tINIT_DELAYED_WORK(&sdp->sd_control_work, gfs2_control_func);\n\tspin_lock_init(&ls->ls_recover_spin);\n\tls->ls_recover_flags = 0;\n\tls->ls_recover_mount = 0;\n\tls->ls_recover_start = 0;\n\tls->ls_recover_block = 0;\n\tls->ls_recover_size = 0;\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_lvb_bits = NULL;\n\n\terror = set_recover_size(sdp, NULL, 0);\n\tif (error)\n\t\tgoto fail;\n\n\t \n\n\tfsname = strchr(table, ':');\n\tif (!fsname) {\n\t\tfs_info(sdp, \"no fsname found\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_free;\n\t}\n\tmemset(cluster, 0, sizeof(cluster));\n\tmemcpy(cluster, table, strlen(table) - strlen(fsname));\n\tfsname++;\n\n\tflags = DLM_LSFL_NEWEXCL;\n\n\t \n\n\terror = dlm_new_lockspace(fsname, cluster, flags, GDLM_LVB_SIZE,\n\t\t\t\t  &gdlm_lockspace_ops, sdp, &ops_result,\n\t\t\t\t  &ls->ls_dlm);\n\tif (error) {\n\t\tfs_err(sdp, \"dlm_new_lockspace error %d\\n\", error);\n\t\tgoto fail_free;\n\t}\n\n\tif (ops_result < 0) {\n\t\t \n\t\tfs_info(sdp, \"dlm lockspace ops not used\\n\");\n\t\tfree_recover_size(ls);\n\t\tset_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags);\n\t\treturn 0;\n\t}\n\n\tif (!test_bit(SDF_NOJOURNALID, &sdp->sd_flags)) {\n\t\tfs_err(sdp, \"dlm lockspace ops disallow jid preset\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_release;\n\t}\n\n\t \n\n\terror = control_mount(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"mount control error %d\\n\", error);\n\t\tgoto fail_release;\n\t}\n\n\tls->ls_first = !!test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tclear_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&sdp->sd_flags, SDF_NOJOURNALID);\n\treturn 0;\n\nfail_release:\n\tdlm_release_lockspace(ls->ls_dlm, 2);\nfail_free:\n\tfree_recover_size(ls);\nfail:\n\treturn error;\n}\n\nstatic void gdlm_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\terror = control_first_done(sdp);\n\tif (error)\n\t\tfs_err(sdp, \"mount first_done error %d\\n\", error);\n}\n\nstatic void gdlm_unmount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\tgoto release;\n\n\t \n\n\tspin_lock(&ls->ls_recover_spin);\n\tset_bit(DFL_UNMOUNT, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n\tflush_delayed_work(&sdp->sd_control_work);\n\n\t \nrelease:\n\tif (ls->ls_dlm) {\n\t\tdlm_release_lockspace(ls->ls_dlm, 2);\n\t\tls->ls_dlm = NULL;\n\t}\n\n\tfree_recover_size(ls);\n}\n\nstatic const match_table_t dlm_tokens = {\n\t{ Opt_jid, \"jid=%d\"},\n\t{ Opt_id, \"id=%d\"},\n\t{ Opt_first, \"first=%d\"},\n\t{ Opt_nodir, \"nodir=%d\"},\n\t{ Opt_err, NULL },\n};\n\nconst struct lm_lockops gfs2_dlm_ops = {\n\t.lm_proto_name = \"lock_dlm\",\n\t.lm_mount = gdlm_mount,\n\t.lm_first_done = gdlm_first_done,\n\t.lm_recovery_result = gdlm_recovery_result,\n\t.lm_unmount = gdlm_unmount,\n\t.lm_put_lock = gdlm_put_lock,\n\t.lm_lock = gdlm_lock,\n\t.lm_cancel = gdlm_cancel,\n\t.lm_tokens = &dlm_tokens,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}