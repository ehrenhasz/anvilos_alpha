{
  "module_name": "trans.c",
  "hash_id": "fd1c50a76391482164762ae2a027b6ab202bf80df55b6459276bcf37c2fa00a7",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/trans.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/kallsyms.h>\n#include <linux/gfs2_ondisk.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"trace_gfs2.h\"\n\nstatic void gfs2_print_trans(struct gfs2_sbd *sdp, const struct gfs2_trans *tr)\n{\n\tfs_warn(sdp, \"Transaction created at: %pSR\\n\", (void *)tr->tr_ip);\n\tfs_warn(sdp, \"blocks=%u revokes=%u reserved=%u touched=%u\\n\",\n\t\ttr->tr_blocks, tr->tr_revokes, tr->tr_reserved,\n\t\ttest_bit(TR_TOUCHED, &tr->tr_flags));\n\tfs_warn(sdp, \"Buf %u/%u Databuf %u/%u Revoke %u\\n\",\n\t\ttr->tr_num_buf_new, tr->tr_num_buf_rm,\n\t\ttr->tr_num_databuf_new, tr->tr_num_databuf_rm,\n\t\ttr->tr_num_revoke);\n}\n\nint __gfs2_trans_begin(struct gfs2_trans *tr, struct gfs2_sbd *sdp,\n\t\t       unsigned int blocks, unsigned int revokes,\n\t\t       unsigned long ip)\n{\n\tunsigned int extra_revokes;\n\n\tif (current->journal_info) {\n\t\tgfs2_print_trans(sdp, current->journal_info);\n\t\tBUG();\n\t}\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr->tr_ip = ip;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = GFS2_LOG_FLUSH_MIN_BLOCKS;\n\tif (blocks) {\n\t\t \n\t\ttr->tr_reserved += blocks + 1 + DIV_ROUND_UP(blocks - 1, databuf_limit(sdp));\n\t}\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\tINIT_LIST_HEAD(&tr->tr_list);\n\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\n\tif (gfs2_assert_warn(sdp, tr->tr_reserved <= sdp->sd_jdesc->jd_blocks))\n\t\treturn -EINVAL;\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\t \n\n\tdown_read(&sdp->sd_log_flush_lock);\n\tif (gfs2_log_try_reserve(sdp, tr, &extra_revokes))\n\t\tgoto reserved;\n\tup_read(&sdp->sd_log_flush_lock);\n\tgfs2_log_reserve(sdp, tr, &extra_revokes);\n\tdown_read(&sdp->sd_log_flush_lock);\n\nreserved:\n\tgfs2_log_release_revokes(sdp, extra_revokes);\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tgfs2_log_release_revokes(sdp, tr->tr_revokes);\n\t\tup_read(&sdp->sd_log_flush_lock);\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\treturn -EROFS;\n\t}\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n}\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\ttr = kmem_cache_zalloc(gfs2_trans_cachep, GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\terror = __gfs2_trans_begin(tr, sdp, blocks, revokes, _RET_IP_);\n\tif (error)\n\t\tkmem_cache_free(gfs2_trans_cachep, tr);\n\treturn error;\n}\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\n\tcurrent->journal_info = NULL;\n\n\tif (!test_bit(TR_TOUCHED, &tr->tr_flags)) {\n\t\tgfs2_log_release_revokes(sdp, tr->tr_revokes);\n\t\tup_read(&sdp->sd_log_flush_lock);\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (!test_bit(TR_ONSTACK, &tr->tr_flags))\n\t\t\tgfs2_trans_free(sdp, tr);\n\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\treturn;\n\t}\n\n\tgfs2_log_release_revokes(sdp, tr->tr_revokes - tr->tr_num_revoke);\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, nbuf <= tr->tr_blocks) ||\n\t    gfs2_assert_withdraw(sdp, tr->tr_num_revoke <= tr->tr_revokes))\n\t\tgfs2_print_trans(sdp, tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (!test_bit(TR_ONSTACK, &tr->tr_flags) &&\n\t    !test_bit(TR_ATTACHED, &tr->tr_flags))\n\t\tgfs2_trans_free(sdp, tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & SB_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t       GFS2_LFC_TRANS_END);\n\tsb_end_intwrite(sdp->sd_vfs);\n}\n\nstatic struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tINIT_LIST_HEAD(&bd->bd_ail_st_list);\n\tINIT_LIST_HEAD(&bd->bd_ail_gl_list);\n\tbh->b_private = bd;\n\treturn bd;\n}\n\n \nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tif (buffer_pinned(bh)) {\n\t\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\t\tgoto out;\n\t}\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh);\n\t\telse\n\t\t\tbd = bh->b_private;\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\nout:\n\tunlock_buffer(bh);\n}\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct gfs2_bufdata *bd;\n\tstruct gfs2_meta_header *mh;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tbool withdraw = false;\n\n\tlock_buffer(bh);\n\tif (buffer_pinned(bh)) {\n\t\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\t\tgoto out;\n\t}\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh);\n\t\telse\n\t\t\tbd = bh->b_private;\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\tif (!list_empty(&bd->bd_list))\n\t\tgoto out_unlock;\n\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\tmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\n\tif (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {\n\t\tfs_err(sdp, \"Attempting to add uninitialised block to \"\n\t\t       \"journal (inplace block=%lld)\\n\",\n\t\t       (unsigned long long)bd->bd_bh->b_blocknr);\n\t\tBUG();\n\t}\n\tif (unlikely(gfs2_withdrawn(sdp))) {\n\t\tfs_info(sdp, \"GFS2:adding buf while withdrawn! 0x%llx\\n\",\n\t\t\t(unsigned long long)bd->bd_bh->b_blocknr);\n\t\tgoto out_unlock;\n\t}\n\tif (unlikely(sb->s_writers.frozen == SB_FREEZE_COMPLETE)) {\n\t\tfs_info(sdp, \"GFS2:adding buf while frozen\\n\");\n\t\twithdraw = true;\n\t\tgoto out_unlock;\n\t}\n\tgfs2_pin(sdp, bd->bd_bh);\n\tmh->__pad0 = cpu_to_be64(0);\n\tmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlist_add(&bd->bd_list, &tr->tr_buf);\n\ttr->tr_num_buf_new++;\nout_unlock:\n\tgfs2_log_unlock(sdp);\n\tif (withdraw)\n\t\tgfs2_assert_withdraw(sdp, 0);\nout:\n\tunlock_buffer(bh);\n}\n\nvoid gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\n\tBUG_ON(!list_empty(&bd->bd_list));\n\tgfs2_add_revoke(sdp, bd);\n\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\ttr->tr_num_revoke++;\n}\n\nvoid gfs2_trans_remove_revoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_revokes, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tif (bd->bd_gl)\n\t\t\t\tgfs2_glock_remove_revoke(bd->bd_gl);\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\tgfs2_log_release_revokes(sdp, 1);\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}\n\nvoid gfs2_trans_free(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tif (tr == NULL)\n\t\treturn;\n\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_ail1_list));\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_ail2_list));\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_databuf));\n\tgfs2_assert_warn(sdp, list_empty(&tr->tr_buf));\n\tkmem_cache_free(gfs2_trans_cachep, tr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}