{
  "module_name": "sys.c",
  "hash_id": "3054389cc8978e63d27bf417b75a80a2a1a3138a442f6fe105cdfb8cac8b604a",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/sys.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"sys.h\"\n#include \"super.h\"\n#include \"glock.h\"\n#include \"quota.h\"\n#include \"util.h\"\n#include \"glops.h\"\n#include \"recovery.h\"\n\nstruct gfs2_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct gfs2_sbd *, char *);\n\tssize_t (*store)(struct gfs2_sbd *, const char *, size_t);\n};\n\nstatic ssize_t gfs2_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct gfs2_sbd *sdp = container_of(kobj, struct gfs2_sbd, sd_kobj);\n\tstruct gfs2_attr *a = container_of(attr, struct gfs2_attr, attr);\n\treturn a->show ? a->show(sdp, buf) : 0;\n}\n\nstatic ssize_t gfs2_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t       const char *buf, size_t len)\n{\n\tstruct gfs2_sbd *sdp = container_of(kobj, struct gfs2_sbd, sd_kobj);\n\tstruct gfs2_attr *a = container_of(attr, struct gfs2_attr, attr);\n\treturn a->store ? a->store(sdp, buf, len) : len;\n}\n\nstatic const struct sysfs_ops gfs2_attr_ops = {\n\t.show  = gfs2_attr_show,\n\t.store = gfs2_attr_store,\n};\n\n\nstatic struct kset *gfs2_kset;\n\nstatic ssize_t id_show(struct gfs2_sbd *sdp, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u:%u\\n\",\n\t\t\tMAJOR(sdp->sd_vfs->s_dev), MINOR(sdp->sd_vfs->s_dev));\n}\n\nstatic ssize_t status_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tunsigned long f = sdp->sd_flags;\n\tssize_t s;\n\n\ts = snprintf(buf, PAGE_SIZE,\n\t\t     \"Journal Checked:          %d\\n\"\n\t\t     \"Journal Live:             %d\\n\"\n\t\t     \"Journal ID:               %d\\n\"\n\t\t     \"Spectator:                %d\\n\"\n\t\t     \"Withdrawn:                %d\\n\"\n\t\t     \"No barriers:              %d\\n\"\n\t\t     \"No recovery:              %d\\n\"\n\t\t     \"Demote:                   %d\\n\"\n\t\t     \"No Journal ID:            %d\\n\"\n\t\t     \"Mounted RO:               %d\\n\"\n\t\t     \"RO Recovery:              %d\\n\"\n\t\t     \"Skip DLM Unlock:          %d\\n\"\n\t\t     \"Force AIL Flush:          %d\\n\"\n\t\t     \"FS Freeze Initiator:      %d\\n\"\n\t\t     \"FS Frozen:                %d\\n\"\n\t\t     \"Withdrawing:              %d\\n\"\n\t\t     \"Withdraw In Prog:         %d\\n\"\n\t\t     \"Remote Withdraw:          %d\\n\"\n\t\t     \"Withdraw Recovery:        %d\\n\"\n\t\t     \"Deactivating:             %d\\n\"\n\t\t     \"sd_log_error:             %d\\n\"\n\t\t     \"sd_log_flush_lock:        %d\\n\"\n\t\t     \"sd_log_num_revoke:        %u\\n\"\n\t\t     \"sd_log_in_flight:         %d\\n\"\n\t\t     \"sd_log_blks_needed:       %d\\n\"\n\t\t     \"sd_log_blks_free:         %d\\n\"\n\t\t     \"sd_log_flush_head:        %d\\n\"\n\t\t     \"sd_log_flush_tail:        %d\\n\"\n\t\t     \"sd_log_blks_reserved:     %d\\n\"\n\t\t     \"sd_log_revokes_available: %d\\n\"\n\t\t     \"sd_log_pinned:            %d\\n\"\n\t\t     \"sd_log_thresh1:           %d\\n\"\n\t\t     \"sd_log_thresh2:           %d\\n\",\n\t\t     test_bit(SDF_JOURNAL_CHECKED, &f),\n\t\t     test_bit(SDF_JOURNAL_LIVE, &f),\n\t\t     (sdp->sd_jdesc ? sdp->sd_jdesc->jd_jid : 0),\n\t\t     (sdp->sd_args.ar_spectator ? 1 : 0),\n\t\t     test_bit(SDF_WITHDRAWN, &f),\n\t\t     test_bit(SDF_NOBARRIERS, &f),\n\t\t     test_bit(SDF_NORECOVERY, &f),\n\t\t     test_bit(SDF_DEMOTE, &f),\n\t\t     test_bit(SDF_NOJOURNALID, &f),\n\t\t     (sb_rdonly(sdp->sd_vfs) ? 1 : 0),\n\t\t     test_bit(SDF_RORECOVERY, &f),\n\t\t     test_bit(SDF_SKIP_DLM_UNLOCK, &f),\n\t\t     test_bit(SDF_FORCE_AIL_FLUSH, &f),\n\t\t     test_bit(SDF_FREEZE_INITIATOR, &f),\n\t\t     test_bit(SDF_FROZEN, &f),\n\t\t     test_bit(SDF_WITHDRAWING, &f),\n\t\t     test_bit(SDF_WITHDRAW_IN_PROG, &f),\n\t\t     test_bit(SDF_REMOTE_WITHDRAW, &f),\n\t\t     test_bit(SDF_WITHDRAW_RECOVERY, &f),\n\t\t     test_bit(SDF_KILL, &f),\n\t\t     sdp->sd_log_error,\n\t\t     rwsem_is_locked(&sdp->sd_log_flush_lock),\n\t\t     sdp->sd_log_num_revoke,\n\t\t     atomic_read(&sdp->sd_log_in_flight),\n\t\t     atomic_read(&sdp->sd_log_blks_needed),\n\t\t     atomic_read(&sdp->sd_log_blks_free),\n\t\t     sdp->sd_log_flush_head,\n\t\t     sdp->sd_log_flush_tail,\n\t\t     sdp->sd_log_blks_reserved,\n\t\t     atomic_read(&sdp->sd_log_revokes_available),\n\t\t     atomic_read(&sdp->sd_log_pinned),\n\t\t     atomic_read(&sdp->sd_log_thresh1),\n\t\t     atomic_read(&sdp->sd_log_thresh2));\n\treturn s;\n}\n\nstatic ssize_t fsname_show(struct gfs2_sbd *sdp, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", sdp->sd_fsname);\n}\n\nstatic ssize_t uuid_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\n\tbuf[0] = '\\0';\n\tif (uuid_is_null(&s->s_uuid))\n\t\treturn 0;\n\treturn snprintf(buf, PAGE_SIZE, \"%pUB\\n\", &s->s_uuid);\n}\n\nstatic ssize_t freeze_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tint frozen = (sb->s_writers.frozen == SB_UNFROZEN) ? 0 : 1;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", frozen);\n}\n\nstatic ssize_t freeze_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tint error, n;\n\n\terror = kstrtoint(buf, 0, &n);\n\tif (error)\n\t\treturn error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (n) {\n\tcase 0:\n\t\terror = thaw_super(sdp->sd_vfs, FREEZE_HOLDER_USERSPACE);\n\t\tbreak;\n\tcase 1:\n\t\terror = freeze_super(sdp->sd_vfs, FREEZE_HOLDER_USERSPACE);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (error) {\n\t\tfs_warn(sdp, \"freeze %d error %d\\n\", n, error);\n\t\treturn error;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t withdraw_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tunsigned int b = gfs2_withdrawn(sdp);\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", b);\n}\n\nstatic ssize_t withdraw_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tint error, val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtoint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tgfs2_lm(sdp, \"withdrawing from cluster at user's request\\n\");\n\tgfs2_withdraw(sdp);\n\n\treturn len;\n}\n\nstatic ssize_t statfs_sync_store(struct gfs2_sbd *sdp, const char *buf,\n\t\t\t\t size_t len)\n{\n\tint error, val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtoint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tgfs2_statfs_sync(sdp->sd_vfs, 0);\n\treturn len;\n}\n\nstatic ssize_t quota_sync_store(struct gfs2_sbd *sdp, const char *buf,\n\t\t\t\tsize_t len)\n{\n\tint error, val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtoint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tgfs2_quota_sync(sdp->sd_vfs, 0);\n\treturn len;\n}\n\nstatic ssize_t quota_refresh_user_store(struct gfs2_sbd *sdp, const char *buf,\n\t\t\t\t\tsize_t len)\n{\n\tstruct kqid qid;\n\tint error;\n\tu32 id;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtou32(buf, 0, &id);\n\tif (error)\n\t\treturn error;\n\n\tqid = make_kqid(current_user_ns(), USRQUOTA, id);\n\tif (!qid_valid(qid))\n\t\treturn -EINVAL;\n\n\terror = gfs2_quota_refresh(sdp, qid);\n\treturn error ? error : len;\n}\n\nstatic ssize_t quota_refresh_group_store(struct gfs2_sbd *sdp, const char *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct kqid qid;\n\tint error;\n\tu32 id;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtou32(buf, 0, &id);\n\tif (error)\n\t\treturn error;\n\n\tqid = make_kqid(current_user_ns(), GRPQUOTA, id);\n\tif (!qid_valid(qid))\n\t\treturn -EINVAL;\n\n\terror = gfs2_quota_refresh(sdp, qid);\n\treturn error ? error : len;\n}\n\nstatic ssize_t demote_rq_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tstruct gfs2_glock *gl;\n\tconst struct gfs2_glock_operations *glops;\n\tunsigned int glmode;\n\tunsigned int gltype;\n\tunsigned long long glnum;\n\tchar mode[16];\n\tint rv;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trv = sscanf(buf, \"%u:%llu %15s\", &gltype, &glnum,\n\t\t    mode);\n\tif (rv != 3)\n\t\treturn -EINVAL;\n\n\tif (strcmp(mode, \"EX\") == 0)\n\t\tglmode = LM_ST_UNLOCKED;\n\telse if ((strcmp(mode, \"CW\") == 0) || (strcmp(mode, \"DF\") == 0))\n\t\tglmode = LM_ST_DEFERRED;\n\telse if ((strcmp(mode, \"PR\") == 0) || (strcmp(mode, \"SH\") == 0))\n\t\tglmode = LM_ST_SHARED;\n\telse\n\t\treturn -EINVAL;\n\n\tif (gltype > LM_TYPE_JOURNAL)\n\t\treturn -EINVAL;\n\tif (gltype == LM_TYPE_NONDISK && glnum == GFS2_FREEZE_LOCK)\n\t\tglops = &gfs2_freeze_glops;\n\telse\n\t\tglops = gfs2_glops_list[gltype];\n\tif (glops == NULL)\n\t\treturn -EINVAL;\n\tif (!test_and_set_bit(SDF_DEMOTE, &sdp->sd_flags))\n\t\tfs_info(sdp, \"demote interface used\\n\");\n\trv = gfs2_glock_get(sdp, glnum, glops, 0, &gl);\n\tif (rv)\n\t\treturn rv;\n\tgfs2_glock_cb(gl, glmode);\n\tgfs2_glock_put(gl);\n\treturn len;\n}\n\n\n#define GFS2_ATTR(name, mode, show, store) \\\nstatic struct gfs2_attr gfs2_attr_##name = __ATTR(name, mode, show, store)\n\nGFS2_ATTR(id,                  0444, id_show,       NULL);\nGFS2_ATTR(fsname,              0444, fsname_show,   NULL);\nGFS2_ATTR(uuid,                0444, uuid_show,     NULL);\nGFS2_ATTR(freeze,              0644, freeze_show,   freeze_store);\nGFS2_ATTR(withdraw,            0644, withdraw_show, withdraw_store);\nGFS2_ATTR(statfs_sync,         0200, NULL,          statfs_sync_store);\nGFS2_ATTR(quota_sync,          0200, NULL,          quota_sync_store);\nGFS2_ATTR(quota_refresh_user,  0200, NULL,          quota_refresh_user_store);\nGFS2_ATTR(quota_refresh_group, 0200, NULL,          quota_refresh_group_store);\nGFS2_ATTR(demote_rq,           0200, NULL,\t    demote_rq_store);\nGFS2_ATTR(status,              0400, status_show,   NULL);\n\nstatic struct attribute *gfs2_attrs[] = {\n\t&gfs2_attr_id.attr,\n\t&gfs2_attr_fsname.attr,\n\t&gfs2_attr_uuid.attr,\n\t&gfs2_attr_freeze.attr,\n\t&gfs2_attr_withdraw.attr,\n\t&gfs2_attr_statfs_sync.attr,\n\t&gfs2_attr_quota_sync.attr,\n\t&gfs2_attr_quota_refresh_user.attr,\n\t&gfs2_attr_quota_refresh_group.attr,\n\t&gfs2_attr_demote_rq.attr,\n\t&gfs2_attr_status.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gfs2);\n\nstatic void gfs2_sbd_release(struct kobject *kobj)\n{\n\tstruct gfs2_sbd *sdp = container_of(kobj, struct gfs2_sbd, sd_kobj);\n\n\tcomplete(&sdp->sd_kobj_unregister);\n}\n\nstatic struct kobj_type gfs2_ktype = {\n\t.release = gfs2_sbd_release,\n\t.default_groups = gfs2_groups,\n\t.sysfs_ops     = &gfs2_attr_ops,\n};\n\n\n \n\nstatic ssize_t proto_name_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tconst struct lm_lockops *ops = sdp->sd_lockstruct.ls_ops;\n\treturn sprintf(buf, \"%s\\n\", ops->lm_proto_name);\n}\n\nstatic ssize_t block_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tssize_t ret;\n\tint val = 0;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags))\n\t\tval = 1;\n\tret = sprintf(buf, \"%d\\n\", val);\n\treturn ret;\n}\n\nstatic ssize_t block_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint ret, val;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val == 1)\n\t\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\telse if (val == 0) {\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tsmp_mb__after_atomic();\n\t\tgfs2_glock_thaw(sdp);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn len;\n}\n\nstatic ssize_t wdack_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tint val = completion_done(&sdp->sd_wdack) ? 1 : 0;\n\n\treturn sprintf(buf, \"%d\\n\", val);\n}\n\nstatic ssize_t wdack_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tint ret, val;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((val == 1) &&\n\t    !strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\tcomplete(&sdp->sd_wdack);\n\telse\n\t\treturn -EINVAL;\n\treturn len;\n}\n\nstatic ssize_t lkfirst_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sprintf(buf, \"%d\\n\", ls->ls_first);\n}\n\nstatic ssize_t lkfirst_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tunsigned first;\n\tint rv;\n\n\trv = sscanf(buf, \"%u\", &first);\n\tif (rv != 1 || first > 1)\n\t\treturn -EINVAL;\n\trv = wait_for_completion_killable(&sdp->sd_locking_init);\n\tif (rv)\n\t\treturn rv;\n\tspin_lock(&sdp->sd_jindex_spin);\n\trv = -EBUSY;\n\tif (test_bit(SDF_NOJOURNALID, &sdp->sd_flags) == 0)\n\t\tgoto out;\n\trv = -EINVAL;\n\tif (sdp->sd_args.ar_spectator)\n\t\tgoto out;\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\tgoto out;\n\tsdp->sd_lockstruct.ls_first = first;\n\trv = 0;\nout:\n        spin_unlock(&sdp->sd_jindex_spin);\n        return rv ? rv : len;\n}\n\nstatic ssize_t first_done_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sprintf(buf, \"%d\\n\", !!test_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags));\n}\n\nint gfs2_recover_set(struct gfs2_sbd *sdp, unsigned jid)\n{\n\tstruct gfs2_jdesc *jd;\n\tint rv;\n\n\t \n\twait_for_completion(&sdp->sd_journal_ready);\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\trv = -EBUSY;\n\t \n\tif (!sdp->sd_jdesc)\n\t\tgoto out;\n\tif (sdp->sd_jdesc->jd_jid == jid && !sdp->sd_args.ar_spectator)\n\t\tgoto out;\n\trv = -ENOENT;\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (jd->jd_jid != jid && !sdp->sd_args.ar_spectator)\n\t\t\tcontinue;\n\t\trv = gfs2_recover_journal(jd, false);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn rv;\n}\n\nstatic ssize_t recover_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n\tunsigned jid;\n\tint rv;\n\n\trv = sscanf(buf, \"%u\", &jid);\n\tif (rv != 1)\n\t\treturn -EINVAL;\n\n\tif (test_bit(SDF_NORECOVERY, &sdp->sd_flags)) {\n\t\trv = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\trv = gfs2_recover_set(sdp, jid);\nout:\n\treturn rv ? rv : len;\n}\n\nstatic ssize_t recover_done_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sprintf(buf, \"%d\\n\", ls->ls_recover_jid_done);\n}\n\nstatic ssize_t recover_status_show(struct gfs2_sbd *sdp, char *buf)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sprintf(buf, \"%d\\n\", ls->ls_recover_jid_status);\n}\n\nstatic ssize_t jid_show(struct gfs2_sbd *sdp, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", sdp->sd_lockstruct.ls_jid);\n}\n\nstatic ssize_t jid_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\n{\n        int jid;\n\tint rv;\n\n\trv = sscanf(buf, \"%d\", &jid);\n\tif (rv != 1)\n\t\treturn -EINVAL;\n\trv = wait_for_completion_killable(&sdp->sd_locking_init);\n\tif (rv)\n\t\treturn rv;\n\tspin_lock(&sdp->sd_jindex_spin);\n\trv = -EINVAL;\n\tif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\n\t\tgoto out;\n\trv = -EBUSY;\n\tif (test_bit(SDF_NOJOURNALID, &sdp->sd_flags) == 0)\n\t\tgoto out;\n\trv = 0;\n\tif (sdp->sd_args.ar_spectator && jid > 0)\n\t\trv = jid = -EINVAL;\n\tsdp->sd_lockstruct.ls_jid = jid;\n\tclear_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&sdp->sd_flags, SDF_NOJOURNALID);\nout:\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn rv ? rv : len;\n}\n\n#define GDLM_ATTR(_name,_mode,_show,_store) \\\nstatic struct gfs2_attr gdlm_attr_##_name = __ATTR(_name,_mode,_show,_store)\n\nGDLM_ATTR(proto_name,\t\t0444, proto_name_show,\t\tNULL);\nGDLM_ATTR(block,\t\t0644, block_show,\t\tblock_store);\nGDLM_ATTR(withdraw,\t\t0644, wdack_show,\t\twdack_store);\nGDLM_ATTR(jid,\t\t\t0644, jid_show,\t\t\tjid_store);\nGDLM_ATTR(first,\t\t0644, lkfirst_show,\t\tlkfirst_store);\nGDLM_ATTR(first_done,\t\t0444, first_done_show,\t\tNULL);\nGDLM_ATTR(recover,\t\t0600, NULL,\t\t\trecover_store);\nGDLM_ATTR(recover_done,\t\t0444, recover_done_show,\tNULL);\nGDLM_ATTR(recover_status,\t0444, recover_status_show,\tNULL);\n\nstatic struct attribute *lock_module_attrs[] = {\n\t&gdlm_attr_proto_name.attr,\n\t&gdlm_attr_block.attr,\n\t&gdlm_attr_withdraw.attr,\n\t&gdlm_attr_jid.attr,\n\t&gdlm_attr_first.attr,\n\t&gdlm_attr_first_done.attr,\n\t&gdlm_attr_recover.attr,\n\t&gdlm_attr_recover_done.attr,\n\t&gdlm_attr_recover_status.attr,\n\tNULL,\n};\n\n \n\nstatic ssize_t quota_scale_show(struct gfs2_sbd *sdp, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u %u\\n\",\n\t\t\tsdp->sd_tune.gt_quota_scale_num,\n\t\t\tsdp->sd_tune.gt_quota_scale_den);\n}\n\nstatic ssize_t quota_scale_store(struct gfs2_sbd *sdp, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\tunsigned int x, y;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (sscanf(buf, \"%u %u\", &x, &y) != 2 || !y)\n\t\treturn -EINVAL;\n\n\tspin_lock(&gt->gt_spin);\n\tgt->gt_quota_scale_num = x;\n\tgt->gt_quota_scale_den = y;\n\tspin_unlock(&gt->gt_spin);\n\treturn len;\n}\n\nstatic ssize_t tune_set(struct gfs2_sbd *sdp, unsigned int *field,\n\t\t\tint check_zero, const char *buf, size_t len)\n{\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\tunsigned int x;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = kstrtouint(buf, 0, &x);\n\tif (error)\n\t\treturn error;\n\n\tif (check_zero && !x)\n\t\treturn -EINVAL;\n\n\tspin_lock(&gt->gt_spin);\n\t*field = x;\n\tspin_unlock(&gt->gt_spin);\n\treturn len;\n}\n\n#define TUNE_ATTR_3(name, show, store)                                        \\\nstatic struct gfs2_attr tune_attr_##name = __ATTR(name, 0644, show, store)\n\n#define TUNE_ATTR_2(name, store)                                              \\\nstatic ssize_t name##_show(struct gfs2_sbd *sdp, char *buf)                   \\\n{                                                                             \\\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", sdp->sd_tune.gt_##name);      \\\n}                                                                             \\\nTUNE_ATTR_3(name, name##_show, store)\n\n#define TUNE_ATTR(name, check_zero)                                           \\\nstatic ssize_t name##_store(struct gfs2_sbd *sdp, const char *buf, size_t len)\\\n{                                                                             \\\n\treturn tune_set(sdp, &sdp->sd_tune.gt_##name, check_zero, buf, len);  \\\n}                                                                             \\\nTUNE_ATTR_2(name, name##_store)\n\nTUNE_ATTR(quota_warn_period, 0);\nTUNE_ATTR(quota_quantum, 0);\nTUNE_ATTR(max_readahead, 0);\nTUNE_ATTR(complain_secs, 0);\nTUNE_ATTR(statfs_slow, 0);\nTUNE_ATTR(new_files_jdata, 0);\nTUNE_ATTR(statfs_quantum, 1);\nTUNE_ATTR_3(quota_scale, quota_scale_show, quota_scale_store);\n\nstatic struct attribute *tune_attrs[] = {\n\t&tune_attr_quota_warn_period.attr,\n\t&tune_attr_quota_quantum.attr,\n\t&tune_attr_max_readahead.attr,\n\t&tune_attr_complain_secs.attr,\n\t&tune_attr_statfs_slow.attr,\n\t&tune_attr_statfs_quantum.attr,\n\t&tune_attr_quota_scale.attr,\n\t&tune_attr_new_files_jdata.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group tune_group = {\n\t.name = \"tune\",\n\t.attrs = tune_attrs,\n};\n\nstatic const struct attribute_group lock_module_group = {\n\t.name = \"lock_module\",\n\t.attrs = lock_module_attrs,\n};\n\nint gfs2_sys_fs_add(struct gfs2_sbd *sdp)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tint error;\n\tchar ro[20];\n\tchar spectator[20];\n\tchar *envp[] = { ro, spectator, NULL };\n\n\tsprintf(ro, \"RDONLY=%d\", sb_rdonly(sb));\n\tsprintf(spectator, \"SPECTATOR=%d\", sdp->sd_args.ar_spectator ? 1 : 0);\n\n\tinit_completion(&sdp->sd_kobj_unregister);\n\tsdp->sd_kobj.kset = gfs2_kset;\n\terror = kobject_init_and_add(&sdp->sd_kobj, &gfs2_ktype, NULL,\n\t\t\t\t     \"%s\", sdp->sd_table_name);\n\tif (error)\n\t\tgoto fail_reg;\n\n\terror = sysfs_create_group(&sdp->sd_kobj, &tune_group);\n\tif (error)\n\t\tgoto fail_reg;\n\n\terror = sysfs_create_group(&sdp->sd_kobj, &lock_module_group);\n\tif (error)\n\t\tgoto fail_tune;\n\n\terror = sysfs_create_link(&sdp->sd_kobj,\n\t\t\t\t  &disk_to_dev(sb->s_bdev->bd_disk)->kobj,\n\t\t\t\t  \"device\");\n\tif (error)\n\t\tgoto fail_lock_module;\n\n\tkobject_uevent_env(&sdp->sd_kobj, KOBJ_ADD, envp);\n\treturn 0;\n\nfail_lock_module:\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\nfail_tune:\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\nfail_reg:\n\tfs_err(sdp, \"error %d adding sysfs files\\n\", error);\n\tkobject_put(&sdp->sd_kobj);\n\twait_for_completion(&sdp->sd_kobj_unregister);\n\tsb->s_fs_info = NULL;\n\treturn error;\n}\n\nvoid gfs2_sys_fs_del(struct gfs2_sbd *sdp)\n{\n\tsysfs_remove_link(&sdp->sd_kobj, \"device\");\n\tsysfs_remove_group(&sdp->sd_kobj, &tune_group);\n\tsysfs_remove_group(&sdp->sd_kobj, &lock_module_group);\n\tkobject_put(&sdp->sd_kobj);\n\twait_for_completion(&sdp->sd_kobj_unregister);\n}\n\nstatic int gfs2_uevent(const struct kobject *kobj, struct kobj_uevent_env *env)\n{\n\tconst struct gfs2_sbd *sdp = container_of(kobj, struct gfs2_sbd, sd_kobj);\n\tconst struct super_block *s = sdp->sd_vfs;\n\n\tadd_uevent_var(env, \"LOCKTABLE=%s\", sdp->sd_table_name);\n\tadd_uevent_var(env, \"LOCKPROTO=%s\", sdp->sd_proto_name);\n\tif (!test_bit(SDF_NOJOURNALID, &sdp->sd_flags))\n\t\tadd_uevent_var(env, \"JOURNALID=%d\", sdp->sd_lockstruct.ls_jid);\n\tif (!uuid_is_null(&s->s_uuid))\n\t\tadd_uevent_var(env, \"UUID=%pUB\", &s->s_uuid);\n\treturn 0;\n}\n\nstatic const struct kset_uevent_ops gfs2_uevent_ops = {\n\t.uevent = gfs2_uevent,\n};\n\nint gfs2_sys_init(void)\n{\n\tgfs2_kset = kset_create_and_add(\"gfs2\", &gfs2_uevent_ops, fs_kobj);\n\tif (!gfs2_kset)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid gfs2_sys_uninit(void)\n{\n\tkset_unregister(gfs2_kset);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}