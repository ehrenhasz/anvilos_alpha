{
  "module_name": "acl.c",
  "hash_id": "bed2801fa3b8ce067d886b0c474f0a4b5bfbf1648b4834acb70c78339a1dfb79",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/acl.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n\nstatic const char *gfs2_acl_name(int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn XATTR_POSIX_ACL_ACCESS;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn XATTR_POSIX_ACL_DEFAULT;\n\t}\n\treturn NULL;\n}\n\nstatic struct posix_acl *__gfs2_get_acl(struct inode *inode, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct posix_acl *acl;\n\tconst char *name;\n\tchar *data;\n\tint len;\n\n\tif (!ip->i_eattr)\n\t\treturn NULL;\n\n\tname = gfs2_acl_name(type);\n\tlen = gfs2_xattr_acl_get(ip, name, &data);\n\tif (len <= 0)\n\t\treturn ERR_PTR(len);\n\tacl = posix_acl_from_xattr(&init_user_ns, data, len);\n\tkfree(data);\n\treturn acl;\n}\n\nstruct posix_acl *gfs2_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tstruct posix_acl *acl;\n\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tint ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t     LM_FLAG_ANY, &gh);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tneed_unlock = true;\n\t}\n\tacl = __gfs2_get_acl(inode, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn acl;\n}\n\nint __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tsize_t len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\n\tif (acl) {\n\t\tlen = posix_acl_xattr_size(acl->a_count);\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}\n\nint gfs2_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tint ret;\n\tumode_t mode;\n\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\n\tret = gfs2_qa_get(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tneed_unlock = true;\n\t}\n\n\tmode = inode->i_mode;\n\tif (type == ACL_TYPE_ACCESS && acl) {\n\t\tret = posix_acl_update_mode(&nop_mnt_idmap, inode, &mode, &acl);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tret = __gfs2_set_acl(inode, acl, type);\n\tif (!ret && mode != inode->i_mode) {\n\t\tinode_set_ctime_current(inode);\n\t\tinode->i_mode = mode;\n\t\tmark_inode_dirty(inode);\n\t}\nunlock:\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\nout:\n\tgfs2_qa_put(ip);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}