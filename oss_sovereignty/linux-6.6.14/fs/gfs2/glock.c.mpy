{
  "module_name": "glock.c",
  "hash_id": "e59e711e24f892ddc35addd3437d7616c75e52c61b3fd032cfd9eab518d95b80",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/glock.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/hash.h>\n#include <linux/jhash.h>\n#include <linux/kallsyms.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/percpu.h>\n#include <linux/list_sort.h>\n#include <linux/lockref.h>\n#include <linux/rhashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"bmap.h\"\n#define CREATE_TRACE_POINTS\n#include \"trace_gfs2.h\"\n\nstruct gfs2_glock_iter {\n\tstruct gfs2_sbd *sdp;\t\t \n\tstruct rhashtable_iter hti;\t \n\tstruct gfs2_glock *gl;\t\t \n\tloff_t last_pos;\t\t \n};\n\ntypedef void (*glock_examiner) (struct gfs2_glock * gl);\n\nstatic void do_xmote(struct gfs2_glock *gl, struct gfs2_holder *gh, unsigned int target);\nstatic void __gfs2_glock_dq(struct gfs2_holder *gh);\nstatic void handle_callback(struct gfs2_glock *gl, unsigned int state,\n\t\t\t    unsigned long delay, bool remote);\n\nstatic struct dentry *gfs2_root;\nstatic struct workqueue_struct *glock_workqueue;\nstatic LIST_HEAD(lru_list);\nstatic atomic_t lru_count = ATOMIC_INIT(0);\nstatic DEFINE_SPINLOCK(lru_lock);\n\n#define GFS2_GL_HASH_SHIFT      15\n#define GFS2_GL_HASH_SIZE       BIT(GFS2_GL_HASH_SHIFT)\n\nstatic const struct rhashtable_params ht_parms = {\n\t.nelem_hint = GFS2_GL_HASH_SIZE * 3 / 4,\n\t.key_len = offsetofend(struct lm_lockname, ln_type),\n\t.key_offset = offsetof(struct gfs2_glock, gl_name),\n\t.head_offset = offsetof(struct gfs2_glock, gl_node),\n};\n\nstatic struct rhashtable gl_hash_table;\n\n#define GLOCK_WAIT_TABLE_BITS 12\n#define GLOCK_WAIT_TABLE_SIZE (1 << GLOCK_WAIT_TABLE_BITS)\nstatic wait_queue_head_t glock_wait_table[GLOCK_WAIT_TABLE_SIZE] __cacheline_aligned;\n\nstruct wait_glock_queue {\n\tstruct lm_lockname *name;\n\twait_queue_entry_t wait;\n};\n\nstatic int glock_wake_function(wait_queue_entry_t *wait, unsigned int mode,\n\t\t\t       int sync, void *key)\n{\n\tstruct wait_glock_queue *wait_glock =\n\t\tcontainer_of(wait, struct wait_glock_queue, wait);\n\tstruct lm_lockname *wait_name = wait_glock->name;\n\tstruct lm_lockname *wake_name = key;\n\n\tif (wake_name->ln_sbd != wait_name->ln_sbd ||\n\t    wake_name->ln_number != wait_name->ln_number ||\n\t    wake_name->ln_type != wait_name->ln_type)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}\n\nstatic wait_queue_head_t *glock_waitqueue(struct lm_lockname *name)\n{\n\tu32 hash = jhash2((u32 *)name, ht_parms.key_len / 4, 0);\n\n\treturn glock_wait_table + hash_32(hash, GLOCK_WAIT_TABLE_BITS);\n}\n\n \nstatic void wake_up_glock(struct gfs2_glock *gl)\n{\n\twait_queue_head_t *wq = glock_waitqueue(&gl->gl_name);\n\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, 1, &gl->gl_name);\n}\n\nstatic void gfs2_glock_dealloc(struct rcu_head *rcu)\n{\n\tstruct gfs2_glock *gl = container_of(rcu, struct gfs2_glock, gl_rcu);\n\n\tkfree(gl->gl_lksb.sb_lvbptr);\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE) {\n\t\tstruct gfs2_glock_aspace *gla =\n\t\t\tcontainer_of(gl, struct gfs2_glock_aspace, glock);\n\t\tkmem_cache_free(gfs2_glock_aspace_cachep, gla);\n\t} else\n\t\tkmem_cache_free(gfs2_glock_cachep, gl);\n}\n\n \nstatic bool glock_blocked_by_withdraw(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tif (likely(!gfs2_withdrawn(sdp)))\n\t\treturn false;\n\tif (gl->gl_ops->go_flags & GLOF_NONDISK)\n\t\treturn false;\n\tif (!sdp->sd_jdesc ||\n\t    gl->gl_name.ln_number == sdp->sd_jdesc->jd_no_addr)\n\t\treturn false;\n\treturn true;\n}\n\nvoid gfs2_glock_free(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tgfs2_glock_assert_withdraw(gl, atomic_read(&gl->gl_revokes) == 0);\n\trhashtable_remove_fast(&gl_hash_table, &gl->gl_node, ht_parms);\n\tsmp_mb();\n\twake_up_glock(gl);\n\tcall_rcu(&gl->gl_rcu, gfs2_glock_dealloc);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_kill_wait);\n}\n\n \n\nstruct gfs2_glock *gfs2_glock_hold(struct gfs2_glock *gl)\n{\n\tGLOCK_BUG_ON(gl, __lockref_is_dead(&gl->gl_lockref));\n\tlockref_get(&gl->gl_lockref);\n\treturn gl;\n}\n\n \n\nstatic int demote_ok(const struct gfs2_glock *gl)\n{\n\tconst struct gfs2_glock_operations *glops = gl->gl_ops;\n\n\tif (gl->gl_state == LM_ST_UNLOCKED)\n\t\treturn 0;\n\tif (!list_empty(&gl->gl_holders))\n\t\treturn 0;\n\tif (glops->go_demote_ok)\n\t\treturn glops->go_demote_ok(gl);\n\treturn 1;\n}\n\n\nvoid gfs2_glock_add_to_lru(struct gfs2_glock *gl)\n{\n\tif (!(gl->gl_ops->go_flags & GLOF_LRU))\n\t\treturn;\n\n\tspin_lock(&lru_lock);\n\n\tlist_move_tail(&gl->gl_lru, &lru_list);\n\n\tif (!test_bit(GLF_LRU, &gl->gl_flags)) {\n\t\tset_bit(GLF_LRU, &gl->gl_flags);\n\t\tatomic_inc(&lru_count);\n\t}\n\n\tspin_unlock(&lru_lock);\n}\n\nstatic void gfs2_glock_remove_from_lru(struct gfs2_glock *gl)\n{\n\tif (!(gl->gl_ops->go_flags & GLOF_LRU))\n\t\treturn;\n\n\tspin_lock(&lru_lock);\n\tif (test_bit(GLF_LRU, &gl->gl_flags)) {\n\t\tlist_del_init(&gl->gl_lru);\n\t\tatomic_dec(&lru_count);\n\t\tclear_bit(GLF_LRU, &gl->gl_flags);\n\t}\n\tspin_unlock(&lru_lock);\n}\n\n \nstatic void __gfs2_glock_queue_work(struct gfs2_glock *gl, unsigned long delay) {\n\tif (!queue_delayed_work(glock_workqueue, &gl->gl_work, delay)) {\n\t\t \n\t\tGLOCK_BUG_ON(gl, gl->gl_lockref.count < 2);\n\t\tgl->gl_lockref.count--;\n\t}\n}\n\nstatic void gfs2_glock_queue_work(struct gfs2_glock *gl, unsigned long delay) {\n\tspin_lock(&gl->gl_lockref.lock);\n\t__gfs2_glock_queue_work(gl, delay);\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nstatic void __gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tgfs2_glock_remove_from_lru(gl);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tif (mapping) {\n\t\ttruncate_inode_pages_final(mapping);\n\t\tif (!gfs2_withdrawn(sdp))\n\t\t\tGLOCK_BUG_ON(gl, !mapping_empty(mapping));\n\t}\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}\n\n \nvoid gfs2_glock_queue_put(struct gfs2_glock *gl)\n{\n\tgfs2_glock_queue_work(gl, 0);\n}\n\n \n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\t__gfs2_glock_put(gl);\n}\n\n \n\nstatic inline bool may_grant(struct gfs2_glock *gl,\n\t\t\t     struct gfs2_holder *current_gh,\n\t\t\t     struct gfs2_holder *gh)\n{\n\tif (current_gh) {\n\t\tGLOCK_BUG_ON(gl, !test_bit(HIF_HOLDER, &current_gh->gh_iflags));\n\n\t\tswitch(current_gh->gh_state) {\n\t\tcase LM_ST_EXCLUSIVE:\n\t\t\t \n\t\t\treturn gh->gh_state == LM_ST_EXCLUSIVE &&\n\t\t\t       (current_gh->gh_flags & LM_FLAG_NODE_SCOPE) &&\n\t\t\t       (gh->gh_flags & LM_FLAG_NODE_SCOPE);\n\n\t\tcase LM_ST_SHARED:\n\t\tcase LM_ST_DEFERRED:\n\t\t\treturn gh->gh_state == current_gh->gh_state;\n\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (gl->gl_state == gh->gh_state)\n\t\treturn true;\n\tif (gh->gh_flags & GL_EXACT)\n\t\treturn false;\n\tif (gl->gl_state == LM_ST_EXCLUSIVE) {\n\t\treturn gh->gh_state == LM_ST_SHARED ||\n\t\t       gh->gh_state == LM_ST_DEFERRED;\n\t}\n\tif (gh->gh_flags & LM_FLAG_ANY)\n\t\treturn gl->gl_state != LM_ST_UNLOCKED;\n\treturn false;\n}\n\nstatic void gfs2_holder_wake(struct gfs2_holder *gh)\n{\n\tclear_bit(HIF_WAIT, &gh->gh_iflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&gh->gh_iflags, HIF_WAIT);\n\tif (gh->gh_flags & GL_ASYNC) {\n\t\tstruct gfs2_sbd *sdp = gh->gh_gl->gl_name.ln_sbd;\n\n\t\twake_up(&sdp->sd_async_glock_wait);\n\t}\n}\n\n \n\nstatic void do_error(struct gfs2_glock *gl, const int ret)\n{\n\tstruct gfs2_holder *gh, *tmp;\n\n\tlist_for_each_entry_safe(gh, tmp, &gl->gl_holders, gh_list) {\n\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tcontinue;\n\t\tif (ret & LM_OUT_ERROR)\n\t\t\tgh->gh_error = -EIO;\n\t\telse if (gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB))\n\t\t\tgh->gh_error = GLR_TRYFAILED;\n\t\telse\n\t\t\tcontinue;\n\t\tlist_del_init(&gh->gh_list);\n\t\ttrace_gfs2_glock_queue(gh, 0);\n\t\tgfs2_holder_wake(gh);\n\t}\n}\n\n \n\nstatic inline struct gfs2_holder *find_first_holder(const struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\n\tif (!list_empty(&gl->gl_holders)) {\n\t\tgh = list_first_entry(&gl->gl_holders, struct gfs2_holder,\n\t\t\t\t      gh_list);\n\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\treturn gh;\n\t}\n\treturn NULL;\n}\n\n \nint gfs2_instantiate(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tconst struct gfs2_glock_operations *glops = gl->gl_ops;\n\tint ret;\n\nagain:\n\tif (!test_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags))\n\t\tgoto done;\n\n\t \n\tif (test_and_set_bit(GLF_INSTANTIATE_IN_PROG, &gl->gl_flags)) {\n\t\twait_on_bit(&gl->gl_flags, GLF_INSTANTIATE_IN_PROG,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t \n\t\tgoto again;\n\t}\n\n\tret = glops->go_instantiate(gl);\n\tif (!ret)\n\t\tclear_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags);\n\tclear_and_wake_up_bit(GLF_INSTANTIATE_IN_PROG, &gl->gl_flags);\n\tif (ret)\n\t\treturn ret;\n\ndone:\n\tif (glops->go_held)\n\t\treturn glops->go_held(gh);\n\treturn 0;\n}\n\n \n\nstatic bool do_promote(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh, *current_gh;\n\n\tcurrent_gh = find_first_holder(gl);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tcontinue;\n\t\tif (!may_grant(gl, current_gh, gh)) {\n\t\t\t \n\t\t\tif (list_is_first(&gh->gh_list, &gl->gl_holders))\n\t\t\t\treturn false;\n\t\t\tdo_error(gl, 0);\n\t\t\tbreak;\n\t\t}\n\t\tset_bit(HIF_HOLDER, &gh->gh_iflags);\n\t\ttrace_gfs2_promote(gh);\n\t\tgfs2_holder_wake(gh);\n\t\tif (!current_gh)\n\t\t\tcurrent_gh = gh;\n\t}\n\treturn true;\n}\n\n \n\nstatic inline struct gfs2_holder *find_first_waiter(const struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\treturn gh;\n\t}\n\treturn NULL;\n}\n\n \n\nstatic void state_change(struct gfs2_glock *gl, unsigned int new_state)\n{\n\tint held1, held2;\n\n\theld1 = (gl->gl_state != LM_ST_UNLOCKED);\n\theld2 = (new_state != LM_ST_UNLOCKED);\n\n\tif (held1 != held2) {\n\t\tGLOCK_BUG_ON(gl, __lockref_is_dead(&gl->gl_lockref));\n\t\tif (held2)\n\t\t\tgl->gl_lockref.count++;\n\t\telse\n\t\t\tgl->gl_lockref.count--;\n\t}\n\tif (new_state != gl->gl_target)\n\t\t \n\t\tgl->gl_hold_time = max(gl->gl_hold_time - GL_GLOCK_HOLD_DECR,\n\t\t\t\t       GL_GLOCK_MIN_HOLD);\n\tgl->gl_state = new_state;\n\tgl->gl_tchange = jiffies;\n}\n\nstatic void gfs2_set_demote(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tset_bit(GLF_DEMOTE, &gl->gl_flags);\n\tsmp_mb();\n\twake_up(&sdp->sd_async_glock_wait);\n}\n\nstatic void gfs2_demote_wake(struct gfs2_glock *gl)\n{\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tclear_bit(GLF_DEMOTE, &gl->gl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&gl->gl_flags, GLF_DEMOTE);\n}\n\n \n\nstatic void finish_xmote(struct gfs2_glock *gl, unsigned int ret)\n{\n\tconst struct gfs2_glock_operations *glops = gl->gl_ops;\n\tstruct gfs2_holder *gh;\n\tunsigned state = ret & LM_OUT_ST_MASK;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\ttrace_gfs2_glock_state_change(gl, state);\n\tstate_change(gl, state);\n\tgh = find_first_waiter(gl);\n\n\t \n\tif (test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    state != LM_ST_UNLOCKED && gl->gl_demote_state == LM_ST_UNLOCKED)\n\t\tgl->gl_target = LM_ST_UNLOCKED;\n\n\t \n\tif (unlikely(state != gl->gl_target)) {\n\t\tif (gh && (ret & LM_OUT_CANCELED))\n\t\t\tgfs2_holder_wake(gh);\n\t\tif (gh && !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags)) {\n\t\t\t \n\t\t\tif (ret & LM_OUT_CANCELED) {\n\t\t\t\tlist_move_tail(&gh->gh_list, &gl->gl_holders);\n\t\t\t\tgh = find_first_waiter(gl);\n\t\t\t\tgl->gl_target = gh->gh_state;\n\t\t\t\tif (do_promote(gl))\n\t\t\t\t\tgoto out;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\t \n\t\t\tif ((ret & LM_OUT_ERROR) ||\n\t\t\t    (gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB))) {\n\t\t\t\tgl->gl_target = gl->gl_state;\n\t\t\t\tdo_error(gl, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch(state) {\n\t\t \n\t\tcase LM_ST_UNLOCKED:\nretry:\n\t\t\tdo_xmote(gl, gh, gl->gl_target);\n\t\t\tbreak;\n\t\t \n\t\tcase LM_ST_SHARED:\n\t\tcase LM_ST_DEFERRED:\n\t\t\tdo_xmote(gl, gh, LM_ST_UNLOCKED);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tfs_err(gl->gl_name.ln_sbd, \"wanted %u got %u\\n\",\n\t\t\t       gl->gl_target, state);\n\t\t\tGLOCK_BUG_ON(gl, 1);\n\t\t}\n\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_clear_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags))\n\t\tgfs2_demote_wake(gl);\n\tif (state != LM_ST_UNLOCKED) {\n\t\tif (glops->go_xmote_bh) {\n\t\t\tint rv;\n\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\trv = glops->go_xmote_bh(gl);\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tif (rv) {\n\t\t\t\tdo_error(gl, rv);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tdo_promote(gl);\n\t}\nout:\n\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nstatic bool is_system_glock(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\n\tif (gl == m_ip->i_gl)\n\t\treturn true;\n\treturn false;\n}\n\n \n\nstatic void do_xmote(struct gfs2_glock *gl, struct gfs2_holder *gh,\n\t\t\t\t\t unsigned int target)\n__releases(&gl->gl_lockref.lock)\n__acquires(&gl->gl_lockref.lock)\n{\n\tconst struct gfs2_glock_operations *glops = gl->gl_ops;\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tunsigned int lck_flags = (unsigned int)(gh ? gh->gh_flags : 0);\n\tint ret;\n\n\tif (target != LM_ST_UNLOCKED && glock_blocked_by_withdraw(gl) &&\n\t    gh && !(gh->gh_flags & LM_FLAG_NOEXP))\n\t\tgoto skip_inval;\n\n\tlck_flags &= (LM_FLAG_TRY | LM_FLAG_TRY_1CB | LM_FLAG_NOEXP);\n\tGLOCK_BUG_ON(gl, gl->gl_state == target);\n\tGLOCK_BUG_ON(gl, gl->gl_state == gl->gl_target);\n\tif ((target == LM_ST_UNLOCKED || target == LM_ST_DEFERRED) &&\n\t    glops->go_inval) {\n\t\t \n\t\tif (test_and_set_bit(GLF_INVALIDATE_IN_PROGRESS,\n\t\t\t\t     &gl->gl_flags))\n\t\t\treturn;\n\t\tdo_error(gl, 0);  \n\t}\n\tgl->gl_req = target;\n\tset_bit(GLF_BLOCKING, &gl->gl_flags);\n\tif ((gl->gl_req == LM_ST_UNLOCKED) ||\n\t    (gl->gl_state == LM_ST_EXCLUSIVE) ||\n\t    (lck_flags & (LM_FLAG_TRY|LM_FLAG_TRY_1CB)))\n\t\tclear_bit(GLF_BLOCKING, &gl->gl_flags);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tif (glops->go_sync) {\n\t\tret = glops->go_sync(gl);\n\t\t \n\t\tif (ret) {\n\t\t\tif (cmpxchg(&sdp->sd_log_error, 0, ret)) {\n\t\t\t\tfs_err(sdp, \"Error %d syncing glock \\n\", ret);\n\t\t\t\tgfs2_dump_glock(NULL, gl, true);\n\t\t\t}\n\t\t\tgoto skip_inval;\n\t\t}\n\t}\n\tif (test_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags)) {\n\t\t \n\t\tif ((atomic_read(&gl->gl_ail_count) != 0) &&\n\t\t    (!cmpxchg(&sdp->sd_log_error, 0, -EIO))) {\n\t\t\tgfs2_glock_assert_warn(gl,\n\t\t\t\t\t       !atomic_read(&gl->gl_ail_count));\n\t\t\tgfs2_dump_glock(NULL, gl, true);\n\t\t}\n\t\tglops->go_inval(gl, target == LM_ST_DEFERRED ? 0 : DIO_METADATA);\n\t\tclear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);\n\t}\n\nskip_inval:\n\tgfs2_glock_hold(gl);\n\t \n\tif (unlikely(sdp->sd_log_error && !gfs2_withdrawn(sdp)))\n\t\tgfs2_withdraw_delayed(sdp);\n\tif (glock_blocked_by_withdraw(gl) &&\n\t    (target != LM_ST_UNLOCKED ||\n\t     test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags))) {\n\t\tif (!is_system_glock(gl)) {\n\t\t\thandle_callback(gl, LM_ST_UNLOCKED, 0, false);  \n\t\t\t \n\t\t\tstate_change(gl, LM_ST_UNLOCKED);\n\t\t\t \n\t\t\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\t\t\tclear_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags);\n\t\t\tgfs2_glock_queue_work(gl, GL_GLOCK_DFT_HOLD);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tclear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);\n\t\t}\n\t}\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_lock)\t{\n\t\t \n\t\tret = sdp->sd_lockstruct.ls_ops->lm_lock(gl, target, lck_flags);\n\t\tif (ret == -EINVAL && gl->gl_target == LM_ST_UNLOCKED &&\n\t\t    target == LM_ST_UNLOCKED &&\n\t\t    test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags)) {\n\t\t\tfinish_xmote(gl, target);\n\t\t\tgfs2_glock_queue_work(gl, 0);\n\t\t} else if (ret) {\n\t\t\tfs_err(sdp, \"lm_lock ret %d\\n\", ret);\n\t\t\tGLOCK_BUG_ON(gl, !gfs2_withdrawn(sdp));\n\t\t}\n\t} else {  \n\t\tfinish_xmote(gl, target);\n\t\tgfs2_glock_queue_work(gl, 0);\n\t}\nout:\n\tspin_lock(&gl->gl_lockref.lock);\n}\n\n \n\nstatic void run_queue(struct gfs2_glock *gl, const int nonblock)\n__releases(&gl->gl_lockref.lock)\n__acquires(&gl->gl_lockref.lock)\n{\n\tstruct gfs2_holder *gh = NULL;\n\n\tif (test_and_set_bit(GLF_LOCK, &gl->gl_flags))\n\t\treturn;\n\n\tGLOCK_BUG_ON(gl, test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags));\n\n\tif (test_bit(GLF_DEMOTE, &gl->gl_flags) &&\n\t    gl->gl_demote_state != gl->gl_state) {\n\t\tif (find_first_holder(gl))\n\t\t\tgoto out_unlock;\n\t\tif (nonblock)\n\t\t\tgoto out_sched;\n\t\tset_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags);\n\t\tGLOCK_BUG_ON(gl, gl->gl_demote_state == LM_ST_EXCLUSIVE);\n\t\tgl->gl_target = gl->gl_demote_state;\n\t} else {\n\t\tif (test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\t\tgfs2_demote_wake(gl);\n\t\tif (do_promote(gl))\n\t\t\tgoto out_unlock;\n\t\tgh = find_first_waiter(gl);\n\t\tgl->gl_target = gh->gh_state;\n\t\tif (!(gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB)))\n\t\t\tdo_error(gl, 0);  \n\t}\n\tdo_xmote(gl, gh, gl->gl_target);\n\treturn;\n\nout_sched:\n\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\tsmp_mb__after_atomic();\n\tgl->gl_lockref.count++;\n\t__gfs2_glock_queue_work(gl, 0);\n\treturn;\n\nout_unlock:\n\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\tsmp_mb__after_atomic();\n\treturn;\n}\n\n \nvoid glock_set_object(struct gfs2_glock *gl, void *object)\n{\n\tvoid *prev_object;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tprev_object = gl->gl_object;\n\tgl->gl_object = object;\n\tspin_unlock(&gl->gl_lockref.lock);\n\tif (gfs2_assert_warn(gl->gl_name.ln_sbd, prev_object == NULL)) {\n\t\tpr_warn(\"glock=%u/%llx\\n\",\n\t\t\tgl->gl_name.ln_type,\n\t\t\t(unsigned long long)gl->gl_name.ln_number);\n\t\tgfs2_dump_glock(NULL, gl, true);\n\t}\n}\n\n \nvoid glock_clear_object(struct gfs2_glock *gl, void *object)\n{\n\tvoid *prev_object;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tprev_object = gl->gl_object;\n\tgl->gl_object = NULL;\n\tspin_unlock(&gl->gl_lockref.lock);\n\tif (gfs2_assert_warn(gl->gl_name.ln_sbd, prev_object == object)) {\n\t\tpr_warn(\"glock=%u/%llx\\n\",\n\t\t\tgl->gl_name.ln_type,\n\t\t\t(unsigned long long)gl->gl_name.ln_number);\n\t\tgfs2_dump_glock(NULL, gl, true);\n\t}\n}\n\nvoid gfs2_inode_remember_delete(struct gfs2_glock *gl, u64 generation)\n{\n\tstruct gfs2_inode_lvb *ri = (void *)gl->gl_lksb.sb_lvbptr;\n\n\tif (ri->ri_magic == 0)\n\t\tri->ri_magic = cpu_to_be32(GFS2_MAGIC);\n\tif (ri->ri_magic == cpu_to_be32(GFS2_MAGIC))\n\t\tri->ri_generation_deleted = cpu_to_be64(generation);\n}\n\nbool gfs2_inode_already_deleted(struct gfs2_glock *gl, u64 generation)\n{\n\tstruct gfs2_inode_lvb *ri = (void *)gl->gl_lksb.sb_lvbptr;\n\n\tif (ri->ri_magic != cpu_to_be32(GFS2_MAGIC))\n\t\treturn false;\n\treturn generation <= be64_to_cpu(ri->ri_generation_deleted);\n}\n\nstatic void gfs2_glock_poke(struct gfs2_glock *gl)\n{\n\tint flags = LM_FLAG_TRY_1CB | LM_FLAG_ANY | GL_SKIP;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\t__gfs2_holder_init(gl, LM_ST_SHARED, flags, &gh, _RET_IP_);\n\terror = gfs2_glock_nq(&gh);\n\tif (!error)\n\t\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n}\n\nstatic bool gfs2_try_evict(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip;\n\tbool evicted = false;\n\n\t \n\tspin_lock(&gl->gl_lockref.lock);\n\tip = gl->gl_object;\n\tif (ip && !igrab(&ip->i_inode))\n\t\tip = NULL;\n\tspin_unlock(&gl->gl_lockref.lock);\n\tif (ip) {\n\t\tgl->gl_no_formal_ino = ip->i_no_formal_ino;\n\t\tset_bit(GIF_DEFERRED_DELETE, &ip->i_flags);\n\t\td_prune_aliases(&ip->i_inode);\n\t\tiput(&ip->i_inode);\n\n\t\t \n\t\tspin_lock(&gl->gl_lockref.lock);\n\t\tip = gl->gl_object;\n\t\tif (ip) {\n\t\t\tclear_bit(GIF_DEFERRED_DELETE, &ip->i_flags);\n\t\t\tif (!igrab(&ip->i_inode))\n\t\t\t\tip = NULL;\n\t\t}\n\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\tif (ip) {\n\t\t\tgfs2_glock_poke(ip->i_gl);\n\t\t\tiput(&ip->i_inode);\n\t\t}\n\t\tevicted = !ip;\n\t}\n\treturn evicted;\n}\n\nbool gfs2_queue_try_to_evict(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tif (test_and_set_bit(GLF_TRY_TO_EVICT, &gl->gl_flags))\n\t\treturn false;\n\treturn queue_delayed_work(sdp->sd_delete_wq,\n\t\t\t\t  &gl->gl_delete, 0);\n}\n\nstatic bool gfs2_queue_verify_evict(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tif (test_and_set_bit(GLF_VERIFY_EVICT, &gl->gl_flags))\n\t\treturn false;\n\treturn queue_delayed_work(sdp->sd_delete_wq,\n\t\t\t\t  &gl->gl_delete, 5 * HZ);\n}\n\nstatic void delete_work_func(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct gfs2_glock *gl = container_of(dwork, struct gfs2_glock, gl_delete);\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct inode *inode;\n\tu64 no_addr = gl->gl_name.ln_number;\n\n\tif (test_and_clear_bit(GLF_TRY_TO_EVICT, &gl->gl_flags)) {\n\t\t \n\t\tif (gfs2_try_evict(gl)) {\n\t\t\tif (test_bit(SDF_KILL, &sdp->sd_flags))\n\t\t\t\tgoto out;\n\t\t\tif (gfs2_queue_verify_evict(gl))\n\t\t\t\treturn;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (test_and_clear_bit(GLF_VERIFY_EVICT, &gl->gl_flags)) {\n\t\tinode = gfs2_lookup_by_inum(sdp, no_addr, gl->gl_no_formal_ino,\n\t\t\t\t\t    GFS2_BLKST_UNLINKED);\n\t\tif (IS_ERR(inode)) {\n\t\t\tif (PTR_ERR(inode) == -EAGAIN &&\n\t\t\t    !test_bit(SDF_KILL, &sdp->sd_flags) &&\n\t\t\t    gfs2_queue_verify_evict(gl))\n\t\t\t\treturn;\n\t\t} else {\n\t\t\td_prune_aliases(inode);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\nout:\n\tgfs2_glock_put(gl);\n}\n\nstatic void glock_work_func(struct work_struct *work)\n{\n\tunsigned long delay = 0;\n\tstruct gfs2_glock *gl = container_of(work, struct gfs2_glock, gl_work.work);\n\tunsigned int drop_refs = 1;\n\n\tif (test_and_clear_bit(GLF_REPLY_PENDING, &gl->gl_flags)) {\n\t\tfinish_xmote(gl, gl->gl_reply);\n\t\tdrop_refs++;\n\t}\n\tspin_lock(&gl->gl_lockref.lock);\n\tif (test_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&\n\t    gl->gl_state != LM_ST_UNLOCKED &&\n\t    gl->gl_demote_state != LM_ST_EXCLUSIVE) {\n\t\tunsigned long holdtime, now = jiffies;\n\n\t\tholdtime = gl->gl_tchange + gl->gl_hold_time;\n\t\tif (time_before(now, holdtime))\n\t\t\tdelay = holdtime - now;\n\n\t\tif (!delay) {\n\t\t\tclear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags);\n\t\t\tgfs2_set_demote(gl);\n\t\t}\n\t}\n\trun_queue(gl, 0);\n\tif (delay) {\n\t\t \n\t\tdrop_refs--;\n\t\tif (gl->gl_name.ln_type != LM_TYPE_INODE)\n\t\t\tdelay = 0;\n\t\t__gfs2_glock_queue_work(gl, delay);\n\t}\n\n\t \n\tgl->gl_lockref.count -= drop_refs;\n\tif (!gl->gl_lockref.count) {\n\t\t__gfs2_glock_put(gl);\n\t\treturn;\n\t}\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nstatic struct gfs2_glock *find_insert_glock(struct lm_lockname *name,\n\t\t\t\t\t    struct gfs2_glock *new)\n{\n\tstruct wait_glock_queue wait;\n\twait_queue_head_t *wq = glock_waitqueue(name);\n\tstruct gfs2_glock *gl;\n\n\twait.name = name;\n\tinit_wait(&wait.wait);\n\twait.wait.func = glock_wake_function;\n\nagain:\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\trcu_read_lock();\n\tif (new) {\n\t\tgl = rhashtable_lookup_get_insert_fast(&gl_hash_table,\n\t\t\t&new->gl_node, ht_parms);\n\t\tif (IS_ERR(gl))\n\t\t\tgoto out;\n\t} else {\n\t\tgl = rhashtable_lookup_fast(&gl_hash_table,\n\t\t\tname, ht_parms);\n\t}\n\tif (gl && !lockref_get_not_dead(&gl->gl_lockref)) {\n\t\trcu_read_unlock();\n\t\tschedule();\n\t\tgoto again;\n\t}\nout:\n\trcu_read_unlock();\n\tfinish_wait(wq, &wait.wait);\n\treturn gl;\n}\n\n \n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number,\n\t\t\t\t    .ln_type = glops->go_type,\n\t\t\t\t    .ln_sbd = sdp };\n\tstruct gfs2_glock *gl, *tmp;\n\tstruct address_space *mapping;\n\tint ret = 0;\n\n\tgl = find_insert_glock(&name, NULL);\n\tif (gl) {\n\t\t*glp = gl;\n\t\treturn 0;\n\t}\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE) {\n\t\tstruct gfs2_glock_aspace *gla =\n\t\t\tkmem_cache_alloc(gfs2_glock_aspace_cachep, GFP_NOFS);\n\t\tif (!gla)\n\t\t\treturn -ENOMEM;\n\t\tgl = &gla->glock;\n\t} else {\n\t\tgl = kmem_cache_alloc(gfs2_glock_cachep, GFP_NOFS);\n\t\tif (!gl)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\tgl->gl_ops = glops;\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tgfs2_glock_dealloc(&gl->gl_rcu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_node.next = NULL;\n\tgl->gl_flags = glops->go_instantiate ? BIT(GLF_INSTANTIATE_NEEDED) : 0;\n\tgl->gl_name = name;\n\tlockdep_set_subclass(&gl->gl_lockref.lock, glops->go_subclass);\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_dstamp = 0;\n\tpreempt_disable();\n\t \n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tif (gl->gl_name.ln_type == LM_TYPE_IOPEN)\n\t\tINIT_DELAYED_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\ttmp = find_insert_glock(&name, gl);\n\tif (!tmp) {\n\t\t*glp = gl;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(tmp)) {\n\t\tret = PTR_ERR(tmp);\n\t\tgoto out_free;\n\t}\n\t*glp = tmp;\n\nout_free:\n\tgfs2_glock_dealloc(&gl->gl_rcu);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_kill_wait);\n\nout:\n\treturn ret;\n}\n\n \n\nvoid __gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, u16 flags,\n\t\t\tstruct gfs2_holder *gh, unsigned long ip)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gfs2_glock_hold(gl);\n\tgh->gh_ip = ip;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_iflags = 0;\n}\n\n \n\nvoid gfs2_holder_reinit(unsigned int state, u16 flags, struct gfs2_holder *gh)\n{\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_iflags = 0;\n\tgh->gh_ip = _RET_IP_;\n\tput_pid(gh->gh_owner_pid);\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n}\n\n \n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgfs2_holder_mark_uninitialized(gh);\n\tgh->gh_ip = 0;\n}\n\nstatic void gfs2_glock_update_hold_time(struct gfs2_glock *gl,\n\t\t\t\t\tunsigned long start_time)\n{\n\t \n\tif (time_after(jiffies, start_time + HZ)) {\n\t\t \n\t\tgl->gl_hold_time = min(gl->gl_hold_time + GL_GLOCK_HOLD_INCR,\n\t\t\t\t       GL_GLOCK_MAX_HOLD);\n\t}\n}\n\n \n\nint gfs2_glock_holder_ready(struct gfs2_holder *gh)\n{\n\tif (gh->gh_error || (gh->gh_flags & GL_SKIP))\n\t\treturn gh->gh_error;\n\tgh->gh_error = gfs2_instantiate(gh);\n\tif (gh->gh_error)\n\t\tgfs2_glock_dq(gh);\n\treturn gh->gh_error;\n}\n\n \n\nint gfs2_glock_wait(struct gfs2_holder *gh)\n{\n\tunsigned long start_time = jiffies;\n\n\tmight_sleep();\n\twait_on_bit(&gh->gh_iflags, HIF_WAIT, TASK_UNINTERRUPTIBLE);\n\tgfs2_glock_update_hold_time(gh->gh_gl, start_time);\n\treturn gfs2_glock_holder_ready(gh);\n}\n\nstatic int glocks_pending(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tint i;\n\n\tfor (i = 0; i < num_gh; i++)\n\t\tif (test_bit(HIF_WAIT, &ghs[i].gh_iflags))\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \n\nint gfs2_glock_async_wait(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_sbd *sdp = ghs[0].gh_gl->gl_name.ln_sbd;\n\tint i, ret = 0, timeout = 0;\n\tunsigned long start_time = jiffies;\n\n\tmight_sleep();\n\t \n\tfor (i = 0; i < num_gh; i++)\n\t\ttimeout += ghs[i].gh_gl->gl_hold_time << 1;\n\n\tif (!wait_event_timeout(sdp->sd_async_glock_wait,\n\t\t\t\t!glocks_pending(num_gh, ghs), timeout)) {\n\t\tret = -ESTALE;  \n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_gh; i++) {\n\t\tstruct gfs2_holder *gh = &ghs[i];\n\t\tint ret2;\n\n\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags)) {\n\t\t\tgfs2_glock_update_hold_time(gh->gh_gl,\n\t\t\t\t\t\t    start_time);\n\t\t}\n\t\tret2 = gfs2_glock_holder_ready(gh);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\nout:\n\tif (ret) {\n\t\tfor (i = 0; i < num_gh; i++) {\n\t\t\tstruct gfs2_holder *gh = &ghs[i];\n\n\t\t\tgfs2_glock_dq(gh);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n\nstatic void handle_callback(struct gfs2_glock *gl, unsigned int state,\n\t\t\t    unsigned long delay, bool remote)\n{\n\tif (delay)\n\t\tset_bit(GLF_PENDING_DEMOTE, &gl->gl_flags);\n\telse\n\t\tgfs2_set_demote(gl);\n\tif (gl->gl_demote_state == LM_ST_EXCLUSIVE) {\n\t\tgl->gl_demote_state = state;\n\t\tgl->gl_demote_time = jiffies;\n\t} else if (gl->gl_demote_state != LM_ST_UNLOCKED &&\n\t\t\tgl->gl_demote_state != state) {\n\t\tgl->gl_demote_state = LM_ST_UNLOCKED;\n\t}\n\tif (gl->gl_ops->go_callback)\n\t\tgl->gl_ops->go_callback(gl, remote);\n\ttrace_gfs2_demote_rq(gl, remote);\n}\n\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}\n\nstatic inline bool pid_is_meaningful(const struct gfs2_holder *gh)\n{\n        if (!(gh->gh_flags & GL_NOPID))\n                return true;\n        if (gh->gh_state == LM_ST_UNLOCKED)\n                return true;\n        return false;\n}\n\n \n\nstatic inline void add_to_queue(struct gfs2_holder *gh)\n__releases(&gl->gl_lockref.lock)\n__acquires(&gl->gl_lockref.lock)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct list_head *insert_pt = NULL;\n\tstruct gfs2_holder *gh2;\n\tint try_futile = 0;\n\n\tGLOCK_BUG_ON(gl, gh->gh_owner_pid == NULL);\n\tif (test_and_set_bit(HIF_WAIT, &gh->gh_iflags))\n\t\tGLOCK_BUG_ON(gl, true);\n\n\tif (gh->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB)) {\n\t\tif (test_bit(GLF_LOCK, &gl->gl_flags)) {\n\t\t\tstruct gfs2_holder *current_gh;\n\n\t\t\tcurrent_gh = find_first_holder(gl);\n\t\t\ttry_futile = !may_grant(gl, current_gh, gh);\n\t\t}\n\t\tif (test_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags))\n\t\t\tgoto fail;\n\t}\n\n\tlist_for_each_entry(gh2, &gl->gl_holders, gh_list) {\n\t\tif (likely(gh2->gh_owner_pid != gh->gh_owner_pid))\n\t\t\tcontinue;\n\t\tif (gh->gh_gl->gl_ops->go_type == LM_TYPE_FLOCK)\n\t\t\tcontinue;\n\t\tif (!pid_is_meaningful(gh2))\n\t\t\tcontinue;\n\t\tgoto trap_recursive;\n\t}\n\tlist_for_each_entry(gh2, &gl->gl_holders, gh_list) {\n\t\tif (try_futile &&\n\t\t    !(gh2->gh_flags & (LM_FLAG_TRY | LM_FLAG_TRY_1CB))) {\nfail:\n\t\t\tgh->gh_error = GLR_TRYFAILED;\n\t\t\tgfs2_holder_wake(gh);\n\t\t\treturn;\n\t\t}\n\t\tif (test_bit(HIF_HOLDER, &gh2->gh_iflags))\n\t\t\tcontinue;\n\t}\n\ttrace_gfs2_glock_queue(gh, 1);\n\tgfs2_glstats_inc(gl, GFS2_LKS_QCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_QCOUNT);\n\tif (likely(insert_pt == NULL)) {\n\t\tlist_add_tail(&gh->gh_list, &gl->gl_holders);\n\t\treturn;\n\t}\n\tlist_add_tail(&gh->gh_list, insert_pt);\n\tgh = list_first_entry(&gl->gl_holders, struct gfs2_holder, gh_list);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tif (sdp->sd_lockstruct.ls_ops->lm_cancel)\n\t\tsdp->sd_lockstruct.ls_ops->lm_cancel(gl);\n\tspin_lock(&gl->gl_lockref.lock);\n\treturn;\n\ntrap_recursive:\n\tfs_err(sdp, \"original: %pSR\\n\", (void *)gh2->gh_ip);\n\tfs_err(sdp, \"pid: %d\\n\", pid_nr(gh2->gh_owner_pid));\n\tfs_err(sdp, \"lock type: %d req lock state : %d\\n\",\n\t       gh2->gh_gl->gl_name.ln_type, gh2->gh_state);\n\tfs_err(sdp, \"new: %pSR\\n\", (void *)gh->gh_ip);\n\tfs_err(sdp, \"pid: %d\\n\", pid_nr(gh->gh_owner_pid));\n\tfs_err(sdp, \"lock type: %d req lock state : %d\\n\",\n\t       gh->gh_gl->gl_name.ln_type, gh->gh_state);\n\tgfs2_dump_glock(NULL, gl, true);\n\tBUG();\n}\n\n \n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tint error = 0;\n\n\tif (glock_blocked_by_withdraw(gl) && !(gh->gh_flags & LM_FLAG_NOEXP))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tgh->gh_error = 0;\n\tspin_lock(&gl->gl_lockref.lock);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\t__gfs2_glock_queue_work(gl, 0);\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_lockref.lock);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}\n\n \n\nint gfs2_glock_poll(struct gfs2_holder *gh)\n{\n\treturn test_bit(HIF_WAIT, &gh->gh_iflags) ? 0 : 1;\n}\n\nstatic inline bool needs_demote(struct gfs2_glock *gl)\n{\n\treturn (test_bit(GLF_DEMOTE, &gl->gl_flags) ||\n\t\ttest_bit(GLF_PENDING_DEMOTE, &gl->gl_flags));\n}\n\nstatic void __gfs2_glock_dq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tunsigned delay = 0;\n\tint fast_path = 0;\n\n\t \n\tif (gh->gh_flags & GL_NOCACHE)\n\t\thandle_callback(gl, LM_ST_UNLOCKED, 0, false);\n\n\tlist_del_init(&gh->gh_list);\n\tclear_bit(HIF_HOLDER, &gh->gh_iflags);\n\ttrace_gfs2_glock_queue(gh, 0);\n\n\t \n\tif (!needs_demote(gl)) {\n\t\tif (list_empty(&gl->gl_holders))\n\t\t\tfast_path = 1;\n\t}\n\n\tif (!test_bit(GLF_LFLUSH, &gl->gl_flags) && demote_ok(gl))\n\t\tgfs2_glock_add_to_lru(gl);\n\n\tif (unlikely(!fast_path)) {\n\t\tgl->gl_lockref.count++;\n\t\tif (test_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&\n\t\t    !test_bit(GLF_DEMOTE, &gl->gl_flags) &&\n\t\t    gl->gl_name.ln_type == LM_TYPE_INODE)\n\t\t\tdelay = gl->gl_hold_time;\n\t\t__gfs2_glock_queue_work(gl, delay);\n\t}\n}\n\n \nvoid gfs2_glock_dq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tif (!gfs2_holder_queued(gh)) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (list_is_first(&gh->gh_list, &gl->gl_holders) &&\n\t    !test_bit(HIF_HOLDER, &gh->gh_iflags)) {\n\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\tgl->gl_name.ln_sbd->sd_lockstruct.ls_ops->lm_cancel(gl);\n\t\twait_on_bit(&gh->gh_iflags, HIF_WAIT, TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&gl->gl_lockref.lock);\n\t}\n\n\t \n\tif (test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags) &&\n\t    glock_blocked_by_withdraw(gl) &&\n\t    gh->gh_gl != sdp->sd_jinode_gl) {\n\t\tsdp->sd_glock_dqs_held++;\n\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\tmight_sleep();\n\t\twait_on_bit(&sdp->sd_flags, SDF_WITHDRAW_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&gl->gl_lockref.lock);\n\t}\n\n\t__gfs2_glock_dq(gh);\nout:\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nvoid gfs2_glock_dq_wait(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tgfs2_glock_dq(gh);\n\tmight_sleep();\n\twait_on_bit(&gl->gl_flags, GLF_DEMOTE, TASK_UNINTERRUPTIBLE);\n}\n\n \n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}\n\n \n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, u16 flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}\n\n \n\nstatic int glock_compare(const void *arg_a, const void *arg_b)\n{\n\tconst struct gfs2_holder *gh_a = *(const struct gfs2_holder **)arg_a;\n\tconst struct gfs2_holder *gh_b = *(const struct gfs2_holder **)arg_b;\n\tconst struct lm_lockname *a = &gh_a->gh_gl->gl_name;\n\tconst struct lm_lockname *b = &gh_b->gh_gl->gl_name;\n\n\tif (a->ln_number > b->ln_number)\n\t\treturn 1;\n\tif (a->ln_number < b->ln_number)\n\t\treturn -1;\n\tBUG_ON(gh_a->gh_gl->gl_ops->go_type == gh_b->gh_gl->gl_ops->go_type);\n\treturn 0;\n}\n\n \n\nstatic int nq_m_sync(unsigned int num_gh, struct gfs2_holder *ghs,\n\t\t     struct gfs2_holder **p)\n{\n\tunsigned int x;\n\tint error = 0;\n\n\tfor (x = 0; x < num_gh; x++)\n\t\tp[x] = &ghs[x];\n\n\tsort(p, num_gh, sizeof(struct gfs2_holder *), glock_compare, NULL);\n\n\tfor (x = 0; x < num_gh; x++) {\n\t\terror = gfs2_glock_nq(p[x]);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tgfs2_glock_dq(p[x]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}\n\n \n\nint gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc_array(num_gh, sizeof(struct gfs2_holder *),\n\t\t\t\t    GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}\n\n \n\nvoid gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}\n\nvoid gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state)\n{\n\tunsigned long delay = 0;\n\tunsigned long holdtime;\n\tunsigned long now = jiffies;\n\n\tgfs2_glock_hold(gl);\n\tspin_lock(&gl->gl_lockref.lock);\n\tholdtime = gl->gl_tchange + gl->gl_hold_time;\n\tif (!list_empty(&gl->gl_holders) &&\n\t    gl->gl_name.ln_type == LM_TYPE_INODE) {\n\t\tif (time_before(now, holdtime))\n\t\t\tdelay = holdtime - now;\n\t\tif (test_bit(GLF_REPLY_PENDING, &gl->gl_flags))\n\t\t\tdelay = gl->gl_hold_time;\n\t}\n\thandle_callback(gl, state, delay, true);\n\t__gfs2_glock_queue_work(gl, delay);\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\n \n\nstatic int gfs2_should_freeze(const struct gfs2_glock *gl)\n{\n\tconst struct gfs2_holder *gh;\n\n\tif (gl->gl_reply & ~LM_OUT_ST_MASK)\n\t\treturn 0;\n\tif (gl->gl_target == LM_ST_UNLOCKED)\n\t\treturn 0;\n\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tcontinue;\n\t\tif (LM_FLAG_NOEXP & gh->gh_flags)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \n\nvoid gfs2_glock_complete(struct gfs2_glock *gl, int ret)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_name.ln_sbd->sd_lockstruct;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tgl->gl_reply = ret;\n\n\tif (unlikely(test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags))) {\n\t\tif (gfs2_should_freeze(gl)) {\n\t\t\tset_bit(GLF_FROZEN, &gl->gl_flags);\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgl->gl_lockref.count++;\n\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t__gfs2_glock_queue_work(gl, 0);\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nstatic int glock_cmp(void *priv, const struct list_head *a,\n\t\t     const struct list_head *b)\n{\n\tstruct gfs2_glock *gla, *glb;\n\n\tgla = list_entry(a, struct gfs2_glock, gl_lru);\n\tglb = list_entry(b, struct gfs2_glock, gl_lru);\n\n\tif (gla->gl_name.ln_number > glb->gl_name.ln_number)\n\t\treturn 1;\n\tif (gla->gl_name.ln_number < glb->gl_name.ln_number)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n\nstatic void gfs2_dispose_glock_lru(struct list_head *list)\n__releases(&lru_lock)\n__acquires(&lru_lock)\n{\n\tstruct gfs2_glock *gl;\n\n\tlist_sort(NULL, list, glock_cmp);\n\n\twhile(!list_empty(list)) {\n\t\tgl = list_first_entry(list, struct gfs2_glock, gl_lru);\n\t\tlist_del_init(&gl->gl_lru);\n\t\tclear_bit(GLF_LRU, &gl->gl_flags);\n\t\tif (!spin_trylock(&gl->gl_lockref.lock)) {\nadd_back_to_lru:\n\t\t\tlist_add(&gl->gl_lru, &lru_list);\n\t\t\tset_bit(GLF_LRU, &gl->gl_flags);\n\t\t\tatomic_inc(&lru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_and_set_bit(GLF_LOCK, &gl->gl_flags)) {\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgoto add_back_to_lru;\n\t\t}\n\t\tgl->gl_lockref.count++;\n\t\tif (demote_ok(gl))\n\t\t\thandle_callback(gl, LM_ST_UNLOCKED, 0, false);\n\t\tWARN_ON(!test_and_clear_bit(GLF_LOCK, &gl->gl_flags));\n\t\t__gfs2_glock_queue_work(gl, 0);\n\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\tcond_resched_lock(&lru_lock);\n\t}\n}\n\n \n\nstatic long gfs2_scan_glock_lru(int nr)\n{\n\tstruct gfs2_glock *gl, *next;\n\tLIST_HEAD(dispose);\n\tlong freed = 0;\n\n\tspin_lock(&lru_lock);\n\tlist_for_each_entry_safe(gl, next, &lru_list, gl_lru) {\n\t\tif (nr-- <= 0)\n\t\t\tbreak;\n\t\t \n\t\tif (!test_bit(GLF_LOCK, &gl->gl_flags)) {\n\t\t\tif (!spin_trylock(&gl->gl_lockref.lock))\n\t\t\t\tcontinue;\n\t\t\tif (gl->gl_lockref.count <= 1 &&\n\t\t\t    (gl->gl_state == LM_ST_UNLOCKED ||\n\t\t\t     demote_ok(gl))) {\n\t\t\t\tlist_move(&gl->gl_lru, &dispose);\n\t\t\t\tatomic_dec(&lru_count);\n\t\t\t\tfreed++;\n\t\t\t}\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t}\n\t}\n\tif (!list_empty(&dispose))\n\t\tgfs2_dispose_glock_lru(&dispose);\n\tspin_unlock(&lru_lock);\n\n\treturn freed;\n}\n\nstatic unsigned long gfs2_glock_shrink_scan(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc)\n{\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\treturn gfs2_scan_glock_lru(sc->nr_to_scan);\n}\n\nstatic unsigned long gfs2_glock_shrink_count(struct shrinker *shrink,\n\t\t\t\t\t     struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(atomic_read(&lru_count));\n}\n\nstatic struct shrinker glock_shrinker = {\n\t.seeks = DEFAULT_SEEKS,\n\t.count_objects = gfs2_glock_shrink_count,\n\t.scan_objects = gfs2_glock_shrink_scan,\n};\n\n \n\nstatic void glock_hash_walk(glock_examiner examiner, const struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_glock *gl;\n\tstruct rhashtable_iter iter;\n\n\trhashtable_walk_enter(&gl_hash_table, &iter);\n\n\tdo {\n\t\trhashtable_walk_start(&iter);\n\n\t\twhile ((gl = rhashtable_walk_next(&iter)) && !IS_ERR(gl)) {\n\t\t\tif (gl->gl_name.ln_sbd == sdp)\n\t\t\t\texaminer(gl);\n\t\t}\n\n\t\trhashtable_walk_stop(&iter);\n\t} while (cond_resched(), gl == ERR_PTR(-EAGAIN));\n\n\trhashtable_walk_exit(&iter);\n}\n\nvoid gfs2_cancel_delete_work(struct gfs2_glock *gl)\n{\n\tclear_bit(GLF_TRY_TO_EVICT, &gl->gl_flags);\n\tclear_bit(GLF_VERIFY_EVICT, &gl->gl_flags);\n\tif (cancel_delayed_work(&gl->gl_delete))\n\t\tgfs2_glock_put(gl);\n}\n\nstatic void flush_delete_work(struct gfs2_glock *gl)\n{\n\tif (gl->gl_name.ln_type == LM_TYPE_IOPEN) {\n\t\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\t\tif (cancel_delayed_work(&gl->gl_delete)) {\n\t\t\tqueue_delayed_work(sdp->sd_delete_wq,\n\t\t\t\t\t   &gl->gl_delete, 0);\n\t\t}\n\t}\n}\n\nvoid gfs2_flush_delete_work(struct gfs2_sbd *sdp)\n{\n\tglock_hash_walk(flush_delete_work, sdp);\n\tflush_workqueue(sdp->sd_delete_wq);\n}\n\n \n\nstatic void thaw_glock(struct gfs2_glock *gl)\n{\n\tif (!test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))\n\t\treturn;\n\tif (!lockref_get_not_dead(&gl->gl_lockref))\n\t\treturn;\n\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\tgfs2_glock_queue_work(gl, 0);\n}\n\n \n\nstatic void clear_glock(struct gfs2_glock *gl)\n{\n\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tif (!__lockref_is_dead(&gl->gl_lockref)) {\n\t\tgl->gl_lockref.count++;\n\t\tif (gl->gl_state != LM_ST_UNLOCKED)\n\t\t\thandle_callback(gl, LM_ST_UNLOCKED, 0, false);\n\t\t__gfs2_glock_queue_work(gl, 0);\n\t}\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\n \n\nvoid gfs2_glock_thaw(struct gfs2_sbd *sdp)\n{\n\tglock_hash_walk(thaw_glock, sdp);\n}\n\nstatic void dump_glock(struct seq_file *seq, struct gfs2_glock *gl, bool fsid)\n{\n\tspin_lock(&gl->gl_lockref.lock);\n\tgfs2_dump_glock(seq, gl, fsid);\n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nstatic void dump_glock_func(struct gfs2_glock *gl)\n{\n\tdump_glock(NULL, gl, true);\n}\n\nstatic void withdraw_dq(struct gfs2_glock *gl)\n{\n\tspin_lock(&gl->gl_lockref.lock);\n\tif (!__lockref_is_dead(&gl->gl_lockref) &&\n\t    glock_blocked_by_withdraw(gl))\n\t\tdo_error(gl, LM_OUT_ERROR);  \n\tspin_unlock(&gl->gl_lockref.lock);\n}\n\nvoid gfs2_gl_dq_holders(struct gfs2_sbd *sdp)\n{\n\tglock_hash_walk(withdraw_dq, sdp);\n}\n\n \n\nvoid gfs2_gl_hash_clear(struct gfs2_sbd *sdp)\n{\n\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);\n\tflush_workqueue(glock_workqueue);\n\tglock_hash_walk(clear_glock, sdp);\n\tflush_workqueue(glock_workqueue);\n\twait_event_timeout(sdp->sd_kill_wait,\n\t\t\t   atomic_read(&sdp->sd_glock_disposal) == 0,\n\t\t\t   HZ * 600);\n\tglock_hash_walk(dump_glock_func, sdp);\n}\n\nstatic const char *state2str(unsigned state)\n{\n\tswitch(state) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn \"UN\";\n\tcase LM_ST_SHARED:\n\t\treturn \"SH\";\n\tcase LM_ST_DEFERRED:\n\t\treturn \"DF\";\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn \"EX\";\n\t}\n\treturn \"??\";\n}\n\nstatic const char *hflags2str(char *buf, u16 flags, unsigned long iflags)\n{\n\tchar *p = buf;\n\tif (flags & LM_FLAG_TRY)\n\t\t*p++ = 't';\n\tif (flags & LM_FLAG_TRY_1CB)\n\t\t*p++ = 'T';\n\tif (flags & LM_FLAG_NOEXP)\n\t\t*p++ = 'e';\n\tif (flags & LM_FLAG_ANY)\n\t\t*p++ = 'A';\n\tif (flags & LM_FLAG_NODE_SCOPE)\n\t\t*p++ = 'n';\n\tif (flags & GL_ASYNC)\n\t\t*p++ = 'a';\n\tif (flags & GL_EXACT)\n\t\t*p++ = 'E';\n\tif (flags & GL_NOCACHE)\n\t\t*p++ = 'c';\n\tif (test_bit(HIF_HOLDER, &iflags))\n\t\t*p++ = 'H';\n\tif (test_bit(HIF_WAIT, &iflags))\n\t\t*p++ = 'W';\n\tif (flags & GL_SKIP)\n\t\t*p++ = 's';\n\t*p = 0;\n\treturn buf;\n}\n\n \n\nstatic void dump_holder(struct seq_file *seq, const struct gfs2_holder *gh,\n\t\t\tconst char *fs_id_buf)\n{\n\tconst char *comm = \"(none)\";\n\tpid_t owner_pid = 0;\n\tchar flags_buf[32];\n\n\trcu_read_lock();\n\tif (pid_is_meaningful(gh)) {\n\t\tstruct task_struct *gh_owner;\n\n\t\tcomm = \"(ended)\";\n\t\towner_pid = pid_nr(gh->gh_owner_pid);\n\t\tgh_owner = pid_task(gh->gh_owner_pid, PIDTYPE_PID);\n\t\tif (gh_owner)\n\t\t\tcomm = gh_owner->comm;\n\t}\n\tgfs2_print_dbg(seq, \"%s H: s:%s f:%s e:%d p:%ld [%s] %pS\\n\",\n\t\t       fs_id_buf, state2str(gh->gh_state),\n\t\t       hflags2str(flags_buf, gh->gh_flags, gh->gh_iflags),\n\t\t       gh->gh_error, (long)owner_pid, comm, (void *)gh->gh_ip);\n\trcu_read_unlock();\n}\n\nstatic const char *gflags2str(char *buf, const struct gfs2_glock *gl)\n{\n\tconst unsigned long *gflags = &gl->gl_flags;\n\tchar *p = buf;\n\n\tif (test_bit(GLF_LOCK, gflags))\n\t\t*p++ = 'l';\n\tif (test_bit(GLF_DEMOTE, gflags))\n\t\t*p++ = 'D';\n\tif (test_bit(GLF_PENDING_DEMOTE, gflags))\n\t\t*p++ = 'd';\n\tif (test_bit(GLF_DEMOTE_IN_PROGRESS, gflags))\n\t\t*p++ = 'p';\n\tif (test_bit(GLF_DIRTY, gflags))\n\t\t*p++ = 'y';\n\tif (test_bit(GLF_LFLUSH, gflags))\n\t\t*p++ = 'f';\n\tif (test_bit(GLF_INVALIDATE_IN_PROGRESS, gflags))\n\t\t*p++ = 'i';\n\tif (test_bit(GLF_REPLY_PENDING, gflags))\n\t\t*p++ = 'r';\n\tif (test_bit(GLF_INITIAL, gflags))\n\t\t*p++ = 'I';\n\tif (test_bit(GLF_FROZEN, gflags))\n\t\t*p++ = 'F';\n\tif (!list_empty(&gl->gl_holders))\n\t\t*p++ = 'q';\n\tif (test_bit(GLF_LRU, gflags))\n\t\t*p++ = 'L';\n\tif (gl->gl_object)\n\t\t*p++ = 'o';\n\tif (test_bit(GLF_BLOCKING, gflags))\n\t\t*p++ = 'b';\n\tif (test_bit(GLF_FREEING, gflags))\n\t\t*p++ = 'x';\n\tif (test_bit(GLF_INSTANTIATE_NEEDED, gflags))\n\t\t*p++ = 'n';\n\tif (test_bit(GLF_INSTANTIATE_IN_PROG, gflags))\n\t\t*p++ = 'N';\n\tif (test_bit(GLF_TRY_TO_EVICT, gflags))\n\t\t*p++ = 'e';\n\tif (test_bit(GLF_VERIFY_EVICT, gflags))\n\t\t*p++ = 'E';\n\t*p = 0;\n\treturn buf;\n}\n\n \n\nvoid gfs2_dump_glock(struct seq_file *seq, struct gfs2_glock *gl, bool fsid)\n{\n\tconst struct gfs2_glock_operations *glops = gl->gl_ops;\n\tunsigned long long dtime;\n\tconst struct gfs2_holder *gh;\n\tchar gflags_buf[32];\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tchar fs_id_buf[sizeof(sdp->sd_fsname) + 7];\n\tunsigned long nrpages = 0;\n\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE) {\n\t\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\t\tnrpages = mapping->nrpages;\n\t}\n\tmemset(fs_id_buf, 0, sizeof(fs_id_buf));\n\tif (fsid && sdp)  \n\t\tsprintf(fs_id_buf, \"fsid=%s: \", sdp->sd_fsname);\n\tdtime = jiffies - gl->gl_demote_time;\n\tdtime *= 1000000/HZ;  \n\tif (!test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\tdtime = 0;\n\tgfs2_print_dbg(seq, \"%sG:  s:%s n:%u/%llx f:%s t:%s d:%s/%llu a:%d \"\n\t\t       \"v:%d r:%d m:%ld p:%lu\\n\",\n\t\t       fs_id_buf, state2str(gl->gl_state),\n\t\t       gl->gl_name.ln_type,\n\t\t       (unsigned long long)gl->gl_name.ln_number,\n\t\t       gflags2str(gflags_buf, gl),\n\t\t       state2str(gl->gl_target),\n\t\t       state2str(gl->gl_demote_state), dtime,\n\t\t       atomic_read(&gl->gl_ail_count),\n\t\t       atomic_read(&gl->gl_revokes),\n\t\t       (int)gl->gl_lockref.count, gl->gl_hold_time, nrpages);\n\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list)\n\t\tdump_holder(seq, gh, fs_id_buf);\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && glops->go_dump)\n\t\tglops->go_dump(seq, gl, fs_id_buf);\n}\n\nstatic int gfs2_glstats_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct gfs2_glock *gl = iter_ptr;\n\n\tseq_printf(seq, \"G: n:%u/%llx rtt:%llu/%llu rttb:%llu/%llu irt:%llu/%llu dcnt: %llu qcnt: %llu\\n\",\n\t\t   gl->gl_name.ln_type,\n\t\t   (unsigned long long)gl->gl_name.ln_number,\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SRTT],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SRTTVAR],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SRTTB],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SRTTVARB],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SIRT],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_SIRTVAR],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_DCOUNT],\n\t\t   (unsigned long long)gl->gl_stats.stats[GFS2_LKS_QCOUNT]);\n\treturn 0;\n}\n\nstatic const char *gfs2_gltype[] = {\n\t\"type\",\n\t\"reserved\",\n\t\"nondisk\",\n\t\"inode\",\n\t\"rgrp\",\n\t\"meta\",\n\t\"iopen\",\n\t\"flock\",\n\t\"plock\",\n\t\"quota\",\n\t\"journal\",\n};\n\nstatic const char *gfs2_stype[] = {\n\t[GFS2_LKS_SRTT]\t\t= \"srtt\",\n\t[GFS2_LKS_SRTTVAR]\t= \"srttvar\",\n\t[GFS2_LKS_SRTTB]\t= \"srttb\",\n\t[GFS2_LKS_SRTTVARB]\t= \"srttvarb\",\n\t[GFS2_LKS_SIRT]\t\t= \"sirt\",\n\t[GFS2_LKS_SIRTVAR]\t= \"sirtvar\",\n\t[GFS2_LKS_DCOUNT]\t= \"dlm\",\n\t[GFS2_LKS_QCOUNT]\t= \"queue\",\n};\n\n#define GFS2_NR_SBSTATS (ARRAY_SIZE(gfs2_gltype) * ARRAY_SIZE(gfs2_stype))\n\nstatic int gfs2_sbstats_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct gfs2_sbd *sdp = seq->private;\n\tloff_t pos = *(loff_t *)iter_ptr;\n\tunsigned index = pos >> 3;\n\tunsigned subindex = pos & 0x07;\n\tint i;\n\n\tif (index == 0 && subindex != 0)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%-10s %8s:\", gfs2_gltype[index],\n\t\t   (index == 0) ? \"cpu\": gfs2_stype[subindex]);\n\n\tfor_each_possible_cpu(i) {\n                const struct gfs2_pcpu_lkstats *lkstats = per_cpu_ptr(sdp->sd_lkstats, i);\n\n\t\tif (index == 0)\n\t\t\tseq_printf(seq, \" %15u\", i);\n\t\telse\n\t\t\tseq_printf(seq, \" %15llu\", (unsigned long long)lkstats->\n\t\t\t\t   lkstats[index - 1].stats[subindex]);\n\t}\n\tseq_putc(seq, '\\n');\n\treturn 0;\n}\n\nint __init gfs2_glock_init(void)\n{\n\tint i, ret;\n\n\tret = rhashtable_init(&gl_hash_table, &ht_parms);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tglock_workqueue = alloc_workqueue(\"glock_workqueue\", WQ_MEM_RECLAIM |\n\t\t\t\t\t  WQ_HIGHPRI | WQ_FREEZABLE, 0);\n\tif (!glock_workqueue) {\n\t\trhashtable_destroy(&gl_hash_table);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = register_shrinker(&glock_shrinker, \"gfs2-glock\");\n\tif (ret) {\n\t\tdestroy_workqueue(glock_workqueue);\n\t\trhashtable_destroy(&gl_hash_table);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < GLOCK_WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(glock_wait_table + i);\n\n\treturn 0;\n}\n\nvoid gfs2_glock_exit(void)\n{\n\tunregister_shrinker(&glock_shrinker);\n\trhashtable_destroy(&gl_hash_table);\n\tdestroy_workqueue(glock_workqueue);\n}\n\nstatic void gfs2_glock_iter_next(struct gfs2_glock_iter *gi, loff_t n)\n{\n\tstruct gfs2_glock *gl = gi->gl;\n\n\tif (gl) {\n\t\tif (n == 0)\n\t\t\treturn;\n\t\tif (!lockref_put_not_zero(&gl->gl_lockref))\n\t\t\tgfs2_glock_queue_put(gl);\n\t}\n\tfor (;;) {\n\t\tgl = rhashtable_walk_next(&gi->hti);\n\t\tif (IS_ERR_OR_NULL(gl)) {\n\t\t\tif (gl == ERR_PTR(-EAGAIN)) {\n\t\t\t\tn = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgl = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (gl->gl_name.ln_sbd != gi->sdp)\n\t\t\tcontinue;\n\t\tif (n <= 1) {\n\t\t\tif (!lockref_get_not_dead(&gl->gl_lockref))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (__lockref_is_dead(&gl->gl_lockref))\n\t\t\t\tcontinue;\n\t\t\tn--;\n\t\t}\n\t}\n\tgi->gl = gl;\n}\n\nstatic void *gfs2_glock_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct gfs2_glock_iter *gi = seq->private;\n\tloff_t n;\n\n\t \n\tif (*pos < gi->last_pos) {\n\t\trhashtable_walk_exit(&gi->hti);\n\t\trhashtable_walk_enter(&gl_hash_table, &gi->hti);\n\t\tn = *pos + 1;\n\t} else {\n\t\tn = *pos - gi->last_pos;\n\t}\n\n\trhashtable_walk_start(&gi->hti);\n\n\tgfs2_glock_iter_next(gi, n);\n\tgi->last_pos = *pos;\n\treturn gi->gl;\n}\n\nstatic void *gfs2_glock_seq_next(struct seq_file *seq, void *iter_ptr,\n\t\t\t\t loff_t *pos)\n{\n\tstruct gfs2_glock_iter *gi = seq->private;\n\n\t(*pos)++;\n\tgi->last_pos = *pos;\n\tgfs2_glock_iter_next(gi, 1);\n\treturn gi->gl;\n}\n\nstatic void gfs2_glock_seq_stop(struct seq_file *seq, void *iter_ptr)\n\t__releases(RCU)\n{\n\tstruct gfs2_glock_iter *gi = seq->private;\n\n\trhashtable_walk_stop(&gi->hti);\n}\n\nstatic int gfs2_glock_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tdump_glock(seq, iter_ptr, false);\n\treturn 0;\n}\n\nstatic void *gfs2_sbstats_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tpreempt_disable();\n\tif (*pos >= GFS2_NR_SBSTATS)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *gfs2_sbstats_seq_next(struct seq_file *seq, void *iter_ptr,\n\t\t\t\t   loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= GFS2_NR_SBSTATS)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void gfs2_sbstats_seq_stop(struct seq_file *seq, void *iter_ptr)\n{\n\tpreempt_enable();\n}\n\nstatic const struct seq_operations gfs2_glock_seq_ops = {\n\t.start = gfs2_glock_seq_start,\n\t.next  = gfs2_glock_seq_next,\n\t.stop  = gfs2_glock_seq_stop,\n\t.show  = gfs2_glock_seq_show,\n};\n\nstatic const struct seq_operations gfs2_glstats_seq_ops = {\n\t.start = gfs2_glock_seq_start,\n\t.next  = gfs2_glock_seq_next,\n\t.stop  = gfs2_glock_seq_stop,\n\t.show  = gfs2_glstats_seq_show,\n};\n\nstatic const struct seq_operations gfs2_sbstats_sops = {\n\t.start = gfs2_sbstats_seq_start,\n\t.next  = gfs2_sbstats_seq_next,\n\t.stop  = gfs2_sbstats_seq_stop,\n\t.show  = gfs2_sbstats_seq_show,\n};\n\n#define GFS2_SEQ_GOODSIZE min(PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER, 65536UL)\n\nstatic int __gfs2_glocks_open(struct inode *inode, struct file *file,\n\t\t\t      const struct seq_operations *ops)\n{\n\tint ret = seq_open_private(file, ops, sizeof(struct gfs2_glock_iter));\n\tif (ret == 0) {\n\t\tstruct seq_file *seq = file->private_data;\n\t\tstruct gfs2_glock_iter *gi = seq->private;\n\n\t\tgi->sdp = inode->i_private;\n\t\tseq->buf = kmalloc(GFS2_SEQ_GOODSIZE, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (seq->buf)\n\t\t\tseq->size = GFS2_SEQ_GOODSIZE;\n\t\t \n\t\tgi->last_pos = -1;\n\t\tgi->gl = NULL;\n\t\trhashtable_walk_enter(&gl_hash_table, &gi->hti);\n\t}\n\treturn ret;\n}\n\nstatic int gfs2_glocks_open(struct inode *inode, struct file *file)\n{\n\treturn __gfs2_glocks_open(inode, file, &gfs2_glock_seq_ops);\n}\n\nstatic int gfs2_glocks_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct gfs2_glock_iter *gi = seq->private;\n\n\tif (gi->gl)\n\t\tgfs2_glock_put(gi->gl);\n\trhashtable_walk_exit(&gi->hti);\n\treturn seq_release_private(inode, file);\n}\n\nstatic int gfs2_glstats_open(struct inode *inode, struct file *file)\n{\n\treturn __gfs2_glocks_open(inode, file, &gfs2_glstats_seq_ops);\n}\n\nstatic const struct file_operations gfs2_glocks_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glocks_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = gfs2_glocks_release,\n};\n\nstatic const struct file_operations gfs2_glstats_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glstats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = gfs2_glocks_release,\n};\n\nstruct gfs2_glockfd_iter {\n\tstruct super_block *sb;\n\tunsigned int tgid;\n\tstruct task_struct *task;\n\tunsigned int fd;\n\tstruct file *file;\n};\n\nstatic struct task_struct *gfs2_glockfd_next_task(struct gfs2_glockfd_iter *i)\n{\n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\tstruct pid *pid;\n\n\tif (i->task)\n\t\tput_task_struct(i->task);\n\n\trcu_read_lock();\nretry:\n\ti->task = NULL;\n\tpid = find_ge_pid(i->tgid, ns);\n\tif (pid) {\n\t\ti->tgid = pid_nr_ns(pid, ns);\n\t\ti->task = pid_task(pid, PIDTYPE_TGID);\n\t\tif (!i->task) {\n\t\t\ti->tgid++;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(i->task);\n\t}\n\trcu_read_unlock();\n\treturn i->task;\n}\n\nstatic struct file *gfs2_glockfd_next_file(struct gfs2_glockfd_iter *i)\n{\n\tif (i->file) {\n\t\tfput(i->file);\n\t\ti->file = NULL;\n\t}\n\n\trcu_read_lock();\n\tfor(;; i->fd++) {\n\t\tstruct inode *inode;\n\n\t\ti->file = task_lookup_next_fd_rcu(i->task, &i->fd);\n\t\tif (!i->file) {\n\t\t\ti->fd = 0;\n\t\t\tbreak;\n\t\t}\n\t\tinode = file_inode(i->file);\n\t\tif (inode->i_sb != i->sb)\n\t\t\tcontinue;\n\t\tif (get_file_rcu(i->file))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn i->file;\n}\n\nstatic void *gfs2_glockfd_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct gfs2_glockfd_iter *i = seq->private;\n\n\tif (*pos)\n\t\treturn NULL;\n\twhile (gfs2_glockfd_next_task(i)) {\n\t\tif (gfs2_glockfd_next_file(i))\n\t\t\treturn i;\n\t\ti->tgid++;\n\t}\n\treturn NULL;\n}\n\nstatic void *gfs2_glockfd_seq_next(struct seq_file *seq, void *iter_ptr,\n\t\t\t\t   loff_t *pos)\n{\n\tstruct gfs2_glockfd_iter *i = seq->private;\n\n\t(*pos)++;\n\ti->fd++;\n\tdo {\n\t\tif (gfs2_glockfd_next_file(i))\n\t\t\treturn i;\n\t\ti->tgid++;\n\t} while (gfs2_glockfd_next_task(i));\n\treturn NULL;\n}\n\nstatic void gfs2_glockfd_seq_stop(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct gfs2_glockfd_iter *i = seq->private;\n\n\tif (i->file)\n\t\tfput(i->file);\n\tif (i->task)\n\t\tput_task_struct(i->task);\n}\n\nstatic void gfs2_glockfd_seq_show_flock(struct seq_file *seq,\n\t\t\t\t\tstruct gfs2_glockfd_iter *i)\n{\n\tstruct gfs2_file *fp = i->file->private_data;\n\tstruct gfs2_holder *fl_gh = &fp->f_fl_gh;\n\tstruct lm_lockname gl_name = { .ln_type = LM_TYPE_RESERVED };\n\n\tif (!READ_ONCE(fl_gh->gh_gl))\n\t\treturn;\n\n\tspin_lock(&i->file->f_lock);\n\tif (gfs2_holder_initialized(fl_gh))\n\t\tgl_name = fl_gh->gh_gl->gl_name;\n\tspin_unlock(&i->file->f_lock);\n\n\tif (gl_name.ln_type != LM_TYPE_RESERVED) {\n\t\tseq_printf(seq, \"%d %u %u/%llx\\n\",\n\t\t\t   i->tgid, i->fd, gl_name.ln_type,\n\t\t\t   (unsigned long long)gl_name.ln_number);\n\t}\n}\n\nstatic int gfs2_glockfd_seq_show(struct seq_file *seq, void *iter_ptr)\n{\n\tstruct gfs2_glockfd_iter *i = seq->private;\n\tstruct inode *inode = file_inode(i->file);\n\tstruct gfs2_glock *gl;\n\n\tinode_lock_shared(inode);\n\tgl = GFS2_I(inode)->i_iopen_gh.gh_gl;\n\tif (gl) {\n\t\tseq_printf(seq, \"%d %u %u/%llx\\n\",\n\t\t\t   i->tgid, i->fd, gl->gl_name.ln_type,\n\t\t\t   (unsigned long long)gl->gl_name.ln_number);\n\t}\n\tgfs2_glockfd_seq_show_flock(seq, i);\n\tinode_unlock_shared(inode);\n\treturn 0;\n}\n\nstatic const struct seq_operations gfs2_glockfd_seq_ops = {\n\t.start = gfs2_glockfd_seq_start,\n\t.next  = gfs2_glockfd_seq_next,\n\t.stop  = gfs2_glockfd_seq_stop,\n\t.show  = gfs2_glockfd_seq_show,\n};\n\nstatic int gfs2_glockfd_open(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_glockfd_iter *i;\n\tstruct gfs2_sbd *sdp = inode->i_private;\n\n\ti = __seq_open_private(file, &gfs2_glockfd_seq_ops,\n\t\t\t       sizeof(struct gfs2_glockfd_iter));\n\tif (!i)\n\t\treturn -ENOMEM;\n\ti->sb = sdp->sd_vfs;\n\treturn 0;\n}\n\nstatic const struct file_operations gfs2_glockfd_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = gfs2_glockfd_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n};\n\nDEFINE_SEQ_ATTRIBUTE(gfs2_sbstats);\n\nvoid gfs2_create_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tsdp->debugfs_dir = debugfs_create_dir(sdp->sd_table_name, gfs2_root);\n\n\tdebugfs_create_file(\"glocks\", S_IFREG | S_IRUGO, sdp->debugfs_dir, sdp,\n\t\t\t    &gfs2_glocks_fops);\n\n\tdebugfs_create_file(\"glockfd\", S_IFREG | S_IRUGO, sdp->debugfs_dir, sdp,\n\t\t\t    &gfs2_glockfd_fops);\n\n\tdebugfs_create_file(\"glstats\", S_IFREG | S_IRUGO, sdp->debugfs_dir, sdp,\n\t\t\t    &gfs2_glstats_fops);\n\n\tdebugfs_create_file(\"sbstats\", S_IFREG | S_IRUGO, sdp->debugfs_dir, sdp,\n\t\t\t    &gfs2_sbstats_fops);\n}\n\nvoid gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)\n{\n\tdebugfs_remove_recursive(sdp->debugfs_dir);\n\tsdp->debugfs_dir = NULL;\n}\n\nvoid gfs2_register_debugfs(void)\n{\n\tgfs2_root = debugfs_create_dir(\"gfs2\", NULL);\n}\n\nvoid gfs2_unregister_debugfs(void)\n{\n\tdebugfs_remove(gfs2_root);\n\tgfs2_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}