{
  "module_name": "rgrp.h",
  "hash_id": "47e5029b14924474087ec705b7f91c0a22daf1add938bba232de4254f1c70218",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/rgrp.h",
  "human_readable_source": " \n \n\n#ifndef __RGRP_DOT_H__\n#define __RGRP_DOT_H__\n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n \n#define RGRP_RSRV_MINBLKS 32\n#define RGRP_RSRV_ADDBLKS 64\n\nstruct gfs2_rgrpd;\nstruct gfs2_sbd;\nstruct gfs2_holder;\n\nextern void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);\n\nextern struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact);\nextern struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);\nextern struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);\n\nextern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);\nextern int gfs2_rindex_update(struct gfs2_sbd *sdp);\nextern void gfs2_free_clones(struct gfs2_rgrpd *rgd);\nextern int gfs2_rgrp_go_instantiate(struct gfs2_glock *gl);\nextern void gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd);\n\nextern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);\n\n#define GFS2_AF_ORLOV 1\nextern int gfs2_inplace_reserve(struct gfs2_inode *ip,\n\t\t\t\tstruct gfs2_alloc_parms *ap);\nextern void gfs2_inplace_release(struct gfs2_inode *ip);\n\nextern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,\n\t\t\t     bool dinode, u64 *generation);\n\nextern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);\nextern void gfs2_rs_delete(struct gfs2_inode *ip);\nextern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,\n\t\t\t       u64 bstart, u32 blen, int meta);\nextern void gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,\n\t\t\t   u64 bstart, u32 blen);\nextern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);\nextern void gfs2_unlink_di(struct inode *inode);\nextern int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr,\n\t\t\t       unsigned int type);\n\nstruct gfs2_rgrp_list {\n\tunsigned int rl_rgrps;\n\tunsigned int rl_space;\n\tstruct gfs2_rgrpd **rl_rgd;\n\tstruct gfs2_holder *rl_ghs;\n};\n\nextern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t\t   u64 block);\nextern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist,\n\t\t\t     unsigned int state, u16 flags);\nextern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);\nextern u64 gfs2_ri_total(struct gfs2_sbd *sdp);\nextern void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_rgrpd *rgd,\n\t\t\t   const char *fs_id_buf);\nextern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);\nextern int gfs2_fitrim(struct file *filp, void __user *argp);\n\n \nstatic inline bool gfs2_rs_active(const struct gfs2_blkreserv *rs)\n{\n\treturn !RB_EMPTY_NODE(&rs->rs_node);\n}\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}\n\nextern void check_and_update_goal(struct gfs2_inode *ip);\n\nextern void rgrp_lock_local(struct gfs2_rgrpd *rgd);\nextern void rgrp_unlock_local(struct gfs2_rgrpd *rgd);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}