{
  "module_name": "quota.c",
  "hash_id": "167f07619ac384716b2252fac0880bdc6add68088a51aace641677507b4a1cbb",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/quota.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/sort.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/quota.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/lockref.h>\n#include <linux/list_lru.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"log.h\"\n#include \"meta_io.h\"\n#include \"quota.h\"\n#include \"rgrp.h\"\n#include \"super.h\"\n#include \"trans.h\"\n#include \"inode.h\"\n#include \"util.h\"\n\n#define GFS2_QD_HASH_SHIFT      12\n#define GFS2_QD_HASH_SIZE       BIT(GFS2_QD_HASH_SHIFT)\n#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)\n\n#define QC_CHANGE 0\n#define QC_SYNC 1\n\n \n \nstatic DEFINE_SPINLOCK(qd_lock);\nstruct list_lru gfs2_qd_lru;\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}\n\nstatic void gfs2_qd_dealloc(struct rcu_head *rcu)\n{\n\tstruct gfs2_quota_data *qd = container_of(rcu, struct gfs2_quota_data, qd_rcu);\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\tif (atomic_dec_and_test(&sdp->sd_quota_count))\n\t\twake_up(&sdp->sd_kill_wait);\n}\n\nstatic void gfs2_qd_dispose(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&qd_lock);\n\tlist_del(&qd->qd_list);\n\tspin_unlock(&qd_lock);\n\n\tspin_lock_bucket(qd->qd_hash);\n\thlist_bl_del_rcu(&qd->qd_hlist);\n\tspin_unlock_bucket(qd->qd_hash);\n\n\tif (!gfs2_withdrawn(sdp)) {\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_ref);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\t}\n\n\tgfs2_glock_put(qd->qd_gl);\n\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n}\n\nstatic void gfs2_qd_list_dispose(struct list_head *list)\n{\n\tstruct gfs2_quota_data *qd;\n\n\twhile (!list_empty(list)) {\n\t\tqd = list_first_entry(list, struct gfs2_quota_data, qd_lru);\n\t\tlist_del(&qd->qd_lru);\n\n\t\tgfs2_qd_dispose(qd);\n\t}\n}\n\n\nstatic enum lru_status gfs2_qd_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *dispose = arg;\n\tstruct gfs2_quota_data *qd =\n\t\tlist_entry(item, struct gfs2_quota_data, qd_lru);\n\tenum lru_status status;\n\n\tif (!spin_trylock(&qd->qd_lockref.lock))\n\t\treturn LRU_SKIP;\n\n\tstatus = LRU_SKIP;\n\tif (qd->qd_lockref.count == 0) {\n\t\tlockref_mark_dead(&qd->qd_lockref);\n\t\tlist_lru_isolate_move(lru, &qd->qd_lru, dispose);\n\t\tstatus = LRU_REMOVED;\n\t}\n\n\tspin_unlock(&qd->qd_lockref.lock);\n\treturn status;\n}\n\nstatic unsigned long gfs2_qd_shrink_scan(struct shrinker *shrink,\n\t\t\t\t\t struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tunsigned long freed;\n\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tfreed = list_lru_shrink_walk(&gfs2_qd_lru, sc,\n\t\t\t\t     gfs2_qd_isolate, &dispose);\n\n\tgfs2_qd_list_dispose(&dispose);\n\n\treturn freed;\n}\n\nstatic unsigned long gfs2_qd_shrink_count(struct shrinker *shrink,\n\t\t\t\t\t  struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(list_lru_shrink_count(&gfs2_qd_lru, sc));\n}\n\nstruct shrinker gfs2_qd_shrinker = {\n\t.count_objects = gfs2_qd_shrink_count,\n\t.scan_objects = gfs2_qd_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n\t.flags = SHRINKER_NUMA_AWARE,\n};\n\n\nstatic u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}\n\nstatic u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\treturn qd2index(qd) * sizeof(struct gfs2_quota);\n}\n\nstatic struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 0;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}\n\nstatic struct gfs2_quota_data *gfs2_qd_search_bucket(unsigned int hash,\n\t\t\t\t\t\t     const struct gfs2_sbd *sdp,\n\t\t\t\t\t\t     struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct hlist_bl_node *h;\n\n\thlist_bl_for_each_entry_rcu(qd, h, &qd_hash_table[hash], qd_hlist) {\n\t\tif (!qid_eq(qd->qd_id, qid))\n\t\t\tcontinue;\n\t\tif (qd->qd_sbd != sdp)\n\t\t\tcontinue;\n\t\tif (lockref_get_not_dead(&qd->qd_lockref)) {\n\t\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\t\treturn qd;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\tnew_qd->qd_lockref.count++;\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void qd_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tgfs2_assert(sdp, !__lockref_is_dead(&qd->qd_lockref));\n\tlockref_get(&qd->qd_lockref);\n}\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp;\n\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tBUG_ON(__lockref_is_dead(&qd->qd_lockref));\n\tsdp = qd->qd_sbd;\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tlockref_mark_dead(&qd->qd_lockref);\n\t\tspin_unlock(&qd->qd_lockref.lock);\n\n\t\tgfs2_qd_dispose(qd);\n\t\treturn;\n\t}\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n}\n\nstatic int slot_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tunsigned int bit;\n\tint error = 0;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tif (qd->qd_slot_ref == 0) {\n\t\tbit = find_first_zero_bit(sdp->sd_quota_bitmap,\n\t\t\t\t\t  sdp->sd_quota_slots);\n\t\tif (bit >= sdp->sd_quota_slots) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\tset_bit(bit, sdp->sd_quota_bitmap);\n\t\tqd->qd_slot = bit;\n\t}\n\tqd->qd_slot_ref++;\nout:\n\tspin_unlock(&sdp->sd_bitmap_lock);\n\treturn error;\n}\n\nstatic void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_ref);\n\tqd->qd_slot_ref++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_ref);\n\tif (!--qd->qd_slot_ref) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}\n\nstatic int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tstruct inode *inode = sdp->sd_qc_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tstruct iomap iomap = { };\n\tint error;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\terror = gfs2_iomap_get(inode,\n\t\t\t       (loff_t)block << inode->i_blkbits,\n\t\t\t       i_blocksize(inode), &iomap);\n\tif (error)\n\t\tgoto fail;\n\terror = -ENOENT;\n\tif (iomap.type != IOMAP_MAPPED)\n\t\tgoto fail;\n\n\terror = gfs2_meta_read(ip->i_gl, iomap.addr >> inode->i_blkbits,\n\t\t\t       DIO_WAIT, 0, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}\n\nstatic void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}\n\nstatic int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\t \n\tif (!qd->qd_change && test_and_clear_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t\treturn 0;\n\t}\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}\n\nstatic int qd_bh_get_or_undo(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tint error;\n\n\terror = bh_get(qd);\n\tif (!error)\n\t\treturn 0;\n\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tslot_put(qd);\n\tqd_put(qd);\n\treturn error;\n}\n\nstatic int qd_fish(struct gfs2_sbd *sdp, struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd = NULL, *iter;\n\tint error;\n\n\t*qdp = NULL;\n\n\tif (sb_rdonly(sdp->sd_vfs))\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\n\tlist_for_each_entry(iter, &sdp->sd_quota_list, qd_list) {\n\t\tif (qd_check_sync(sdp, iter, &sdp->sd_quota_sync_gen)) {\n\t\t\tqd = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\terror = qd_bh_get_or_undo(sdp, qd);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*qdp = qd;\n\t}\n\n\treturn 0;\n}\n\nstatic void qdsb_put(struct gfs2_quota_data *qd)\n{\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}\n\nstatic void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_sbd, test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tqdsb_put(qd);\n}\n\nstatic int qdsb_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t    struct gfs2_quota_data **qdp)\n{\n\tint error;\n\n\terror = qd_get(sdp, qid, qdp);\n\tif (error)\n\t\treturn error;\n\n\terror = slot_get(*qdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = bh_get(*qdp);\n\tif (error)\n\t\tgoto fail_slot;\n\n\treturn 0;\n\nfail_slot:\n\tslot_put(*qdp);\nfail:\n\tqd_put(*qdp);\n\treturn error;\n}\n\n \nint gfs2_qa_get(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (ip->i_qadata == NULL) {\n\t\tstruct gfs2_qadata *tmp;\n\n\t\tspin_unlock(&inode->i_lock);\n\t\ttmp = kmem_cache_zalloc(gfs2_qadata_cachep, GFP_NOFS);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (ip->i_qadata == NULL)\n\t\t\tip->i_qadata = tmp;\n\t\telse\n\t\t\tkmem_cache_free(gfs2_qadata_cachep, tmp);\n\t}\n\tip->i_qadata->qa_ref++;\n\tspin_unlock(&inode->i_lock);\n\treturn 0;\n}\n\nvoid gfs2_qa_put(struct gfs2_inode *ip)\n{\n\tstruct inode *inode = &ip->i_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (ip->i_qadata && --ip->i_qadata->qa_ref == 0) {\n\t\tkmem_cache_free(gfs2_qadata_cachep, ip->i_qadata);\n\t\tip->i_qadata = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n}\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = gfs2_qa_get(ip);\n\tif (error)\n\t\treturn error;\n\n\tqd = ip->i_qadata->qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_qadata->qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags))) {\n\t\terror = -EIO;\n\t\tgfs2_qa_put(ip);\n\t\tgoto out;\n\t}\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out_unhold;\n\tip->i_qadata->qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out_unhold;\n\tip->i_qadata->qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out_unhold;\n\t\tip->i_qadata->qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out_unhold;\n\t\tip->i_qadata->qa_qd_num++;\n\t\tqd++;\n\t}\n\nout_unhold:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\nout:\n\treturn error;\n}\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 x;\n\n\tif (ip->i_qadata == NULL)\n\t\treturn;\n\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_qadata->qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_qadata->qa_qd[x]);\n\t\tip->i_qadata->qa_qd[x] = NULL;\n\t}\n\tip->i_qadata->qa_qd_num = 0;\n\tgfs2_qa_put(ip);\n}\n\nstatic int sort_qd(const void *a, const void *b)\n{\n\tconst struct gfs2_quota_data *qd_a = *(const struct gfs2_quota_data **)a;\n\tconst struct gfs2_quota_data *qd_b = *(const struct gfs2_quota_data **)b;\n\n\tif (qid_lt(qd_a->qd_id, qd_b->qd_id))\n\t\treturn -1;\n\tif (qid_lt(qd_b->qd_id, qd_a->qd_id))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void do_qc(struct gfs2_quota_data *qd, s64 change, int qc_type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (qc_type == QC_CHANGE) {\n\t\tif (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\t\tqd_hold(qd);\n\t\t\tslot_hold(qd);\n\t\t}\n\t} else {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t}\n\n\tif (change < 0)  \n\t\tclear_bit(QDF_QMSG_QUIET, &qd->qd_flags);\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}\n\nstatic int gfs2_write_buf_to_page(struct gfs2_sbd *sdp, unsigned long index,\n\t\t\t\t  unsigned off, void *buf, unsigned bytes)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct inode *inode = &ip->i_inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tu64 blk;\n\tunsigned bsize = sdp->sd_sb.sb_bsize, bnum = 0, boff = 0;\n\tunsigned to_write = bytes, pg_off = off;\n\n\tblk = index << (PAGE_SHIFT - sdp->sd_sb.sb_bsize_shift);\n\tboff = off % bsize;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\tbh = page_buffers(page);\n\tfor(;;) {\n\t\t \n\t\tif (pg_off >= ((bnum * bsize) + bsize)) {\n\t\t\tbh = bh->b_this_page;\n\t\t\tbnum++;\n\t\t\tblk++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tgfs2_block_map(inode, blk, bh, 1);\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\tgoto unlock_out;\n\t\t\t \n\t\t\tif (buffer_new(bh))\n\t\t\t\tzero_user(page, bnum * bsize, bh->b_size);\n\t\t}\n\t\tif (PageUptodate(page))\n\t\t\tset_buffer_uptodate(bh);\n\t\tif (bh_read(bh, REQ_META | REQ_PRIO) < 0)\n\t\t\tgoto unlock_out;\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\t\t \n\t\tif (to_write > (bsize - boff)) {\n\t\t\tpg_off += (bsize - boff);\n\t\t\tto_write -= (bsize - boff);\n\t\t\tboff = pg_off % bsize;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tmemcpy_to_page(page, off, buf, bytes);\n\tflush_dcache_page(page);\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tput_page(page);\n\treturn -EIO;\n}\n\nstatic int gfs2_write_disk_quota(struct gfs2_sbd *sdp, struct gfs2_quota *qp,\n\t\t\t\t loff_t loc)\n{\n\tunsigned long pg_beg;\n\tunsigned pg_off, nbytes, overflow = 0;\n\tint error;\n\tvoid *ptr;\n\n\tnbytes = sizeof(struct gfs2_quota);\n\n\tpg_beg = loc >> PAGE_SHIFT;\n\tpg_off = offset_in_page(loc);\n\n\t \n\tif ((pg_off + nbytes) > PAGE_SIZE)\n\t\toverflow = (pg_off + nbytes) - PAGE_SIZE;\n\n\tptr = qp;\n\terror = gfs2_write_buf_to_page(sdp, pg_beg, pg_off, ptr,\n\t\t\t\t       nbytes - overflow);\n\t \n\tif (!error && overflow)\n\t\terror = gfs2_write_buf_to_page(sdp, pg_beg + 1, 0,\n\t\t\t\t\t       ptr + nbytes - overflow,\n\t\t\t\t\t       overflow);\n\treturn error;\n}\n\n \n\nstatic int gfs2_adjust_quota(struct gfs2_sbd *sdp, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_quota q;\n\tint err;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\tloc -= sizeof(q);  \n\tbe64_add_cpu(&q.qu_value, change);\n\tif (((s64)be64_to_cpu(q.qu_value)) < 0)\n\t\tq.qu_value = 0;  \n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\terr = gfs2_write_disk_quota(sdp, &q, loc);\n\tif (!err) {\n\t\tsize = loc + sizeof(struct gfs2_quota);\n\t\tif (size > inode->i_size)\n\t\t\ti_size_write(inode, size);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tmark_inode_dirty(inode);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\treturn err;\n}\n\nstatic int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kmalloc_array(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tinode_lock(&ip->i_inode);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out_dq;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out_dq;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t \n\t \n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(sdp, offset, qd->qd_change_sync, qd,\n\t\t\t\t\t\t\tNULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync, QC_SYNC);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout_dq:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tinode_unlock(&ip->i_inode);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_name.ln_sbd, ip->i_gl,\n\t\t       GFS2_LOG_HEAD_FLUSH_NORMAL | GFS2_LFC_DO_SYNC);\n\tif (!error) {\n\t\tfor (x = 0; x < num_qd; x++)\n\t\t\tqda[x]->qd_sync_gen = sdp->sd_quota_sync_gen;\n\t}\n\treturn error;\n}\n\nstatic int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}\n\nstatic int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\tgfs2_assert_warn(sdp, sdp == qd->qd_gl->gl_name.ln_sbd);\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\tforce_refresh = FORCE;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}\n\nint gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tu32 x;\n\tint error;\n\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON &&\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_QUIET)\n\t\treturn 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tsort(ip->i_qadata->qa_qd, ip->i_qadata->qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_qadata->qa_qd_num; x++) {\n\t\tqd = ip->i_qadata->qa_qd[x];\n\t\terror = do_glock(qd, NO_FORCE, &ip->i_qadata->qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_qadata->qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}\n\nstatic bool need_sync(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\ts64 value;\n\tunsigned int num, den;\n\n\tif (!qd->qd_qb.qb_limit)\n\t\treturn false;\n\n\tspin_lock(&qd_lock);\n\tvalue = qd->qd_change;\n\tspin_unlock(&qd_lock);\n\n\tspin_lock(&gt->gt_spin);\n\tnum = gt->gt_quota_scale_num;\n\tden = gt->gt_quota_scale_den;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (value <= 0)\n\t\treturn false;\n\telse if ((s64)be64_to_cpu(qd->qd_qb.qb_value) >=\n\t\t (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\treturn false;\n\telse {\n\t\tvalue *= gfs2_jindex_size(sdp) * num;\n\t\tvalue = div_s64(value, den);\n\t\tvalue += (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tif (value < (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[2 * GFS2_MAXQUOTAS];\n\tunsigned int count = 0;\n\tu32 x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_qadata->qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tbool sync;\n\n\t\tqd = ip->i_qadata->qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_qadata->qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tif (!qd_bh_get_or_undo(sdp, qd))\n\t\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\n\tgfs2_quota_unhold(ip);\n}\n\n#define MAX_LINE 256\n\nstatic int print_message(struct gfs2_quota_data *qd, char *type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_QUIET)\n\t\tfs_info(sdp, \"quota %s for %s %u\\n\",\n\t\t\ttype,\n\t\t\t(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\",\n\t\t\tfrom_kqid(&init_user_ns, qd->qd_id));\n\n\treturn 0;\n}\n\n \nint gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid,\n\t\t     struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value, warn, limit;\n\tu32 x;\n\tint error = 0;\n\n\tap->allowed = UINT_MAX;  \n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n\tfor (x = 0; x < ip->i_qadata->qa_qd_num; x++) {\n\t\tqd = ip->i_qadata->qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\twarn = (s64)be64_to_cpu(qd->qd_qb.qb_warn);\n\t\tlimit = (s64)be64_to_cpu(qd->qd_qb.qb_limit);\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (limit > 0 && (limit - value) < ap->allowed)\n\t\t\tap->allowed = limit - value;\n\t\t \n\t\tif (limit && limit < (value + (s64)ap->target)) {\n\t\t\t \n\t\t\tif (!ap->min_target || ap->min_target > ap->allowed) {\n\t\t\t\tif (!test_and_set_bit(QDF_QMSG_QUIET,\n\t\t\t\t\t\t      &qd->qd_flags)) {\n\t\t\t\t\tprint_message(qd, \"exceeded\");\n\t\t\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t\t\t   sdp->sd_vfs->s_dev,\n\t\t\t\t\t\t\t   QUOTA_NL_BHARDWARN);\n\t\t\t\t}\n\t\t\t\terror = -EDQUOT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (warn && warn < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp, gt_quota_warn_period)\n\t\t\t\t\t * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\treturn error;\n}\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tu32 x;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tif ((sdp->sd_args.ar_quota != GFS2_QUOTA_ON &&\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_QUIET) ||\n\t    gfs2_assert_warn(sdp, change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tif (gfs2_assert_withdraw(sdp, ip->i_qadata &&\n\t\t\t\t ip->i_qadata->qa_ref > 0))\n\t\treturn;\n\tfor (x = 0; x < ip->i_qadata->qa_qd_num; x++) {\n\t\tqd = ip->i_qadata->qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change, QC_CHANGE);\n\t\t}\n\t}\n}\n\nstatic bool qd_changed(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_quota_data *qd;\n\tbool changed = false;\n\n\tspin_lock(&qd_lock);\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t\t    !test_bit(QDF_CHANGE, &qd->qd_flags))\n\t\t\tcontinue;\n\n\t\tchanged = true;\n\t\tbreak;\n\t}\n\tspin_unlock(&qd_lock);\n\treturn changed;\n}\n\nint gfs2_quota_sync(struct super_block *sb, int type)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_data **qda;\n\tunsigned int max_qd = PAGE_SIZE / sizeof(struct gfs2_holder);\n\tunsigned int num_qd;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!qd_changed(sdp))\n\t\treturn 0;\n\n\tqda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);\n\tif (!qda)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&sdp->sd_quota_sync_mutex);\n\tsdp->sd_quota_sync_gen++;\n\n\tdo {\n\t\tnum_qd = 0;\n\n\t\tfor (;;) {\n\t\t\terror = qd_fish(sdp, qda + num_qd);\n\t\t\tif (error || !qda[num_qd])\n\t\t\t\tbreak;\n\t\t\tif (++num_qd == max_qd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (num_qd) {\n\t\t\tif (!error)\n\t\t\t\terror = do_sync(num_qd, qda);\n\n\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\tqd_unlock(qda[x]);\n\t\t}\n\t} while (!error && num_qd == max_qd);\n\n\tmutex_unlock(&sdp->sd_quota_sync_mutex);\n\tkfree(qda);\n\n\treturn error;\n}\n\nint gfs2_quota_refresh(struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (!error)\n\t\tgfs2_glock_dq_uninit(&q_gh);\n\n\tqd_put(qd);\n\treturn error;\n}\n\nint gfs2_quota_init(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tu64 size = i_size_read(sdp->sd_qc_inode);\n\tunsigned int blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\tunsigned int x, slot = 0;\n\tunsigned int found = 0;\n\tunsigned int hash;\n\tunsigned int bm_size;\n\tu64 dblock;\n\tu32 extlen = 0;\n\tint error;\n\n\tif (gfs2_check_internal_file_size(sdp->sd_qc_inode, 1, 64 << 20))\n\t\treturn -EIO;\n\n\tsdp->sd_quota_slots = blocks * sdp->sd_qc_per_block;\n\tbm_size = DIV_ROUND_UP(sdp->sd_quota_slots, 8 * sizeof(unsigned long));\n\tbm_size *= sizeof(unsigned long);\n\terror = -ENOMEM;\n\tsdp->sd_quota_bitmap = kzalloc(bm_size, GFP_NOFS | __GFP_NOWARN);\n\tif (sdp->sd_quota_bitmap == NULL)\n\t\tsdp->sd_quota_bitmap = __vmalloc(bm_size, GFP_NOFS |\n\t\t\t\t\t\t __GFP_ZERO);\n\tif (!sdp->sd_quota_bitmap)\n\t\treturn error;\n\n\tfor (x = 0; x < blocks; x++) {\n\t\tstruct buffer_head *bh;\n\t\tconst struct gfs2_quota_change *qc;\n\t\tunsigned int y;\n\n\t\tif (!extlen) {\n\t\t\textlen = 32;\n\t\t\terror = gfs2_get_extent(&ip->i_inode, x, &dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = -EIO;\n\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\tif (!bh)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tqc = (const struct gfs2_quota_change *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\t\tfor (y = 0; y < sdp->sd_qc_per_block && slot < sdp->sd_quota_slots;\n\t\t     y++, slot++) {\n\t\t\tstruct gfs2_quota_data *qd;\n\t\t\ts64 qc_change = be64_to_cpu(qc->qc_change);\n\t\t\tu32 qc_flags = be32_to_cpu(qc->qc_flags);\n\t\t\tenum quota_type qtype = (qc_flags & GFS2_QCF_USER) ?\n\t\t\t\t\t\tUSRQUOTA : GRPQUOTA;\n\t\t\tstruct kqid qc_id = make_kqid(&init_user_ns, qtype,\n\t\t\t\t\t\t      be32_to_cpu(qc->qc_id));\n\t\t\tqc++;\n\t\t\tif (!qc_change)\n\t\t\t\tcontinue;\n\n\t\t\thash = gfs2_qd_hash(sdp, qc_id);\n\t\t\tqd = qd_alloc(hash, sdp, qc_id);\n\t\t\tif (qd == NULL) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tset_bit(QDF_CHANGE, &qd->qd_flags);\n\t\t\tqd->qd_change = qc_change;\n\t\t\tqd->qd_slot = slot;\n\t\t\tqd->qd_slot_ref = 1;\n\n\t\t\tspin_lock(&qd_lock);\n\t\t\tBUG_ON(test_and_set_bit(slot, sdp->sd_quota_bitmap));\n\t\t\tlist_add(&qd->qd_list, &sdp->sd_quota_list);\n\t\t\tatomic_inc(&sdp->sd_quota_count);\n\t\t\tspin_unlock(&qd_lock);\n\n\t\t\tspin_lock_bucket(hash);\n\t\t\thlist_bl_add_head_rcu(&qd->qd_hlist, &qd_hash_table[hash]);\n\t\t\tspin_unlock_bucket(hash);\n\n\t\t\tfound++;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t}\n\n\tif (found)\n\t\tfs_info(sdp, \"found %u quota changes\\n\", found);\n\n\treturn 0;\n\nfail:\n\tgfs2_quota_cleanup(sdp);\n\treturn error;\n}\n\nvoid gfs2_quota_cleanup(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_quota_data *qd;\n\tLIST_HEAD(dispose);\n\tint count;\n\n\tBUG_ON(!test_bit(SDF_NORECOVERY, &sdp->sd_flags) &&\n\t\ttest_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags));\n\n\tspin_lock(&qd_lock);\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tspin_lock(&qd->qd_lockref.lock);\n\t\tif (qd->qd_lockref.count != 0) {\n\t\t\tspin_unlock(&qd->qd_lockref.lock);\n\t\t\tcontinue;\n\t\t}\n\t\tlockref_mark_dead(&qd->qd_lockref);\n\t\tspin_unlock(&qd->qd_lockref.lock);\n\n\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\tlist_add(&qd->qd_lru, &dispose);\n\t}\n\tspin_unlock(&qd_lock);\n\n\tgfs2_qd_list_dispose(&dispose);\n\n\twait_event_timeout(sdp->sd_kill_wait,\n\t\t(count = atomic_read(&sdp->sd_quota_count)) == 0,\n\t\tHZ * 60);\n\n\tif (count != 0)\n\t\tfs_err(sdp, \"%d left-over quota data objects\\n\", count);\n\n\tkvfree(sdp->sd_quota_bitmap);\n\tsdp->sd_quota_bitmap = NULL;\n}\n\nstatic void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!gfs2_withdrawn(sdp)) {\n\t\tif (!cmpxchg(&sdp->sd_log_error, 0, error))\n\t\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n\t\twake_up(&sdp->sd_logd_waitq);\n\t}\n}\n\nstatic void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,\n\t\t\t       int (*fxn)(struct super_block *sb, int type),\n\t\t\t       unsigned long t, unsigned long *timeo,\n\t\t\t       unsigned int *new_timeo)\n{\n\tif (t >= *timeo) {\n\t\tint error = fxn(sdp->sd_vfs, 0);\n\t\tquotad_error(sdp, msg, error);\n\t\t*timeo = gfs2_tune_get_i(&sdp->sd_tune, new_timeo) * HZ;\n\t} else {\n\t\t*timeo -= t;\n\t}\n}\n\nvoid gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}\n\n\n \n\nint gfs2_quotad(void *data)\n{\n\tstruct gfs2_sbd *sdp = data;\n\tstruct gfs2_tune *tune = &sdp->sd_tune;\n\tunsigned long statfs_timeo = 0;\n\tunsigned long quotad_timeo = 0;\n\tunsigned long t = 0;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (gfs2_withdrawn(sdp))\n\t\t\tbreak;\n\n\t\t \n\t\tif (sdp->sd_statfs_force_sync) {\n\t\t\tint error = gfs2_statfs_sync(sdp->sd_vfs, 0);\n\t\t\tquotad_error(sdp, \"statfs\", error);\n\t\t\tstatfs_timeo = gfs2_tune_get(sdp, gt_statfs_quantum) * HZ;\n\t\t}\n\t\telse\n\t\t\tquotad_check_timeo(sdp, \"statfs\", gfs2_statfs_sync, t,\n\t\t\t\t   \t   &statfs_timeo,\n\t\t\t\t\t   &tune->gt_statfs_quantum);\n\n\t\t \n\t\tquotad_check_timeo(sdp, \"sync\", gfs2_quota_sync, t,\n\t\t\t\t   &quotad_timeo, &tune->gt_quota_quantum);\n\n\t\ttry_to_freeze();\n\n\t\tt = min(quotad_timeo, statfs_timeo);\n\n\t\tt = wait_event_interruptible_timeout(sdp->sd_quota_wait,\n\t\t\t\tsdp->sd_statfs_force_sync ||\n\t\t\t\tgfs2_withdrawn(sdp) ||\n\t\t\t\tkthread_should_stop(),\n\t\t\t\tt);\n\n\t\tif (sdp->sd_statfs_force_sync)\n\t\t\tt = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int gfs2_quota_get_state(struct super_block *sb, struct qc_state *state)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tmemset(state, 0, sizeof(*state));\n\n\tswitch (sdp->sd_args.ar_quota) {\n\tcase GFS2_QUOTA_QUIET:\n\t\tfallthrough;\n\tcase GFS2_QUOTA_ON:\n\t\tstate->s_state[USRQUOTA].flags |= QCI_LIMITS_ENFORCED;\n\t\tstate->s_state[GRPQUOTA].flags |= QCI_LIMITS_ENFORCED;\n\t\tfallthrough;\n\tcase GFS2_QUOTA_ACCOUNT:\n\t\tstate->s_state[USRQUOTA].flags |= QCI_ACCT_ENABLED |\n\t\t\t\t\t\t  QCI_SYSFILE;\n\t\tstate->s_state[GRPQUOTA].flags |= QCI_ACCT_ENABLED |\n\t\t\t\t\t\t  QCI_SYSFILE;\n\t\tbreak;\n\tcase GFS2_QUOTA_OFF:\n\t\tbreak;\n\t}\n\tif (sdp->sd_quota_inode) {\n\t\tstate->s_state[USRQUOTA].ino =\n\t\t\t\t\tGFS2_I(sdp->sd_quota_inode)->i_no_addr;\n\t\tstate->s_state[USRQUOTA].blocks = sdp->sd_quota_inode->i_blocks;\n\t}\n\tstate->s_state[USRQUOTA].nextents = 1;\t \n\tstate->s_state[GRPQUOTA] = state->s_state[USRQUOTA];\n\tstate->s_incoredqs = list_lru_count(&gfs2_qd_lru);\n\treturn 0;\n}\n\nstatic int gfs2_get_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_lvb *qlvb;\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\tmemset(fdq, 0, sizeof(*fdq));\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH;  \n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (error)\n\t\tgoto out;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tfdq->d_spc_hardlimit = be64_to_cpu(qlvb->qb_limit) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_spc_softlimit = be64_to_cpu(qlvb->qb_warn) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_space = be64_to_cpu(qlvb->qb_value) << sdp->sd_sb.sb_bsize_shift;\n\n\tgfs2_glock_dq_uninit(&q_gh);\nout:\n\tqd_put(qd);\n\treturn error;\n}\n\n \n#define GFS2_FIELDMASK (QC_SPC_SOFT|QC_SPC_HARD|QC_SPACE)\n\nstatic int gfs2_set_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh, i_gh;\n\tunsigned int data_blocks, ind_blocks;\n\tunsigned int blocks = 0;\n\tint alloc_required;\n\tloff_t offset;\n\tint error;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH;  \n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\tif (fdq->d_fieldmask & ~GFS2_FIELDMASK)\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_qa_get(ip);\n\tif (error)\n\t\tgoto out_put;\n\n\tinode_lock(&ip->i_inode);\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE, 0, &q_gh);\n\tif (error)\n\t\tgoto out_unlockput;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out_q;\n\n\t \n\terror = update_qd(sdp, qd);\n\tif (error)\n\t\tgoto out_i;\n\n\t \n\tif ((fdq->d_fieldmask & QC_SPC_SOFT) &&\n\t    ((fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_warn)))\n\t\tfdq->d_fieldmask ^= QC_SPC_SOFT;\n\n\tif ((fdq->d_fieldmask & QC_SPC_HARD) &&\n\t    ((fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_limit)))\n\t\tfdq->d_fieldmask ^= QC_SPC_HARD;\n\n\tif ((fdq->d_fieldmask & QC_SPACE) &&\n\t    ((fdq->d_space >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_value)))\n\t\tfdq->d_fieldmask ^= QC_SPACE;\n\n\tif (fdq->d_fieldmask == 0)\n\t\tgoto out_i;\n\n\toffset = qd2offset(qd);\n\talloc_required = gfs2_write_alloc_required(ip, offset, sizeof(struct gfs2_quota));\n\tif (gfs2_is_stuffed(ip))\n\t\talloc_required = 1;\n\tif (alloc_required) {\n\t\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\t\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t\t       &data_blocks, &ind_blocks);\n\t\tblocks = 1 + data_blocks + ind_blocks;\n\t\tap.target = blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_i;\n\t\tblocks += gfs2_rg_blocks(ip, blocks);\n\t}\n\n\t \n\terror = gfs2_trans_begin(sdp, blocks + RES_DINODE + 2, 0);\n\tif (error)\n\t\tgoto out_release;\n\n\t \n\terror = gfs2_adjust_quota(sdp, offset, 0, qd, fdq);\n\tif (!error)\n\t\tclear_bit(QDF_QMSG_QUIET, &qd->qd_flags);\n\n\tgfs2_trans_end(sdp);\nout_release:\n\tif (alloc_required)\n\t\tgfs2_inplace_release(ip);\nout_i:\n\tgfs2_glock_dq_uninit(&i_gh);\nout_q:\n\tgfs2_glock_dq_uninit(&q_gh);\nout_unlockput:\n\tgfs2_qa_put(ip);\n\tinode_unlock(&ip->i_inode);\nout_put:\n\tqd_put(qd);\n\treturn error;\n}\n\nconst struct quotactl_ops gfs2_quotactl_ops = {\n\t.quota_sync     = gfs2_quota_sync,\n\t.get_state\t= gfs2_quota_get_state,\n\t.get_dqblk\t= gfs2_get_dqblk,\n\t.set_dqblk\t= gfs2_set_dqblk,\n};\n\nvoid __init gfs2_quota_hash_init(void)\n{\n\tunsigned i;\n\n\tfor(i = 0; i < GFS2_QD_HASH_SIZE; i++)\n\t\tINIT_HLIST_BL_HEAD(&qd_hash_table[i]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}