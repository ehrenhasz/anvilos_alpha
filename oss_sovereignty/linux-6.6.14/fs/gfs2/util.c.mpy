{
  "module_name": "util.c",
  "hash_id": "81b0c5bd7b4d2534352ce1cce1f8d27a58a2014d2bbd79b48aba09b6a27f540c",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/util.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/kthread.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"log.h\"\n#include \"lops.h\"\n#include \"recovery.h\"\n#include \"rgrp.h\"\n#include \"super.h\"\n#include \"util.h\"\n\nstruct kmem_cache *gfs2_glock_cachep __read_mostly;\nstruct kmem_cache *gfs2_glock_aspace_cachep __read_mostly;\nstruct kmem_cache *gfs2_inode_cachep __read_mostly;\nstruct kmem_cache *gfs2_bufdata_cachep __read_mostly;\nstruct kmem_cache *gfs2_rgrpd_cachep __read_mostly;\nstruct kmem_cache *gfs2_quotad_cachep __read_mostly;\nstruct kmem_cache *gfs2_qadata_cachep __read_mostly;\nstruct kmem_cache *gfs2_trans_cachep __read_mostly;\nmempool_t *gfs2_page_pool __read_mostly;\n\nvoid gfs2_assert_i(struct gfs2_sbd *sdp)\n{\n\tfs_emerg(sdp, \"fatal assertion failed\\n\");\n}\n\n \nint check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd,\n\t\t\tbool verbose)\n{\n\tint error;\n\tstruct gfs2_holder j_gh;\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_inode *ip;\n\n\tip = GFS2_I(jd->jd_inode);\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\n\t\t\t\t   GL_EXACT | GL_NOCACHE, &j_gh);\n\tif (error) {\n\t\tif (verbose)\n\t\t\tfs_err(sdp, \"Error %d locking journal for spectator \"\n\t\t\t       \"mount.\\n\", error);\n\t\treturn -EPERM;\n\t}\n\terror = gfs2_jdesc_check(jd);\n\tif (error) {\n\t\tif (verbose)\n\t\t\tfs_err(sdp, \"Error checking journal for spectator \"\n\t\t\t       \"mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\terror = gfs2_find_jhead(jd, &head, false);\n\tif (error) {\n\t\tif (verbose)\n\t\t\tfs_err(sdp, \"Error parsing journal for spectator \"\n\t\t\t       \"mount.\\n\");\n\t\tgoto out_unlock;\n\t}\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\terror = -EPERM;\n\t\tif (verbose)\n\t\t\tfs_err(sdp, \"jid=%u: Journal is dirty, so the first \"\n\t\t\t       \"mounter must not be a spectator.\\n\",\n\t\t\t       jd->jd_jid);\n\t}\n\nout_unlock:\n\tgfs2_glock_dq_uninit(&j_gh);\n\treturn error;\n}\n\n \nint gfs2_freeze_lock_shared(struct gfs2_sbd *sdp)\n{\n\tint error;\n\n\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,\n\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT,\n\t\t\t\t   &sdp->sd_freeze_gh);\n\tif (error)\n\t\tfs_err(sdp, \"can't lock the freeze glock: %d\\n\", error);\n\treturn error;\n}\n\nvoid gfs2_freeze_unlock(struct gfs2_holder *freeze_gh)\n{\n\tif (gfs2_holder_initialized(freeze_gh))\n\t\tgfs2_glock_dq_uninit(freeze_gh);\n}\n\nstatic void signal_our_withdraw(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_glock *live_gl = sdp->sd_live_gh.gh_gl;\n\tstruct inode *inode;\n\tstruct gfs2_inode *ip;\n\tstruct gfs2_glock *i_gl;\n\tu64 no_formal_ino;\n\tint ret = 0;\n\tint tries;\n\n\tif (test_bit(SDF_NORECOVERY, &sdp->sd_flags) || !sdp->sd_jdesc)\n\t\treturn;\n\n\tgfs2_ail_drain(sdp);  \n\tinode = sdp->sd_jdesc->jd_inode;\n\tip = GFS2_I(inode);\n\ti_gl = ip->i_gl;\n\tno_formal_ino = ip->i_no_formal_ino;\n\n\t \n\tset_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);\n\t \n\tclear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);\n\tif (!sb_rdonly(sdp->sd_vfs)) {\n\t\tbool locked = mutex_trylock(&sdp->sd_freeze_mutex);\n\n\t\twake_up(&sdp->sd_logd_waitq);\n\t\twake_up(&sdp->sd_quota_wait);\n\n\t\twait_event_timeout(sdp->sd_log_waitq,\n\t\t\t\t   gfs2_log_is_empty(sdp),\n\t\t\t\t   HZ * 5);\n\n\t\tsdp->sd_vfs->s_flags |= SB_RDONLY;\n\n\t\tif (locked)\n\t\t\tmutex_unlock(&sdp->sd_freeze_mutex);\n\n\t\t \n\t\tgfs2_gl_dq_holders(sdp);\n\t}\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_lock == NULL) {  \n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);\n\t\tgoto skip_recovery;\n\t}\n\t \n\tif (gfs2_holder_initialized(&sdp->sd_journal_gh)) {\n\t\tgfs2_glock_dq_wait(&sdp->sd_journal_gh);\n\t\tgfs2_holder_uninit(&sdp->sd_journal_gh);\n\t}\n\tsdp->sd_jinode_gh.gh_flags |= GL_NOCACHE;\n\tgfs2_glock_dq(&sdp->sd_jinode_gh);\n\tgfs2_thaw_freeze_initiator(sdp->sd_vfs);\n\twait_on_bit(&i_gl->gl_flags, GLF_DEMOTE, TASK_UNINTERRUPTIBLE);\n\n\t \n\tgfs2_holder_uninit(&sdp->sd_jinode_gh);\n\n\t \n\tiput(inode);\n\tsdp->sd_jdesc->jd_inode = NULL;\n\t \n\tif (i_gl->gl_ops->go_free) {\n\t\tset_bit(GLF_FREEING, &i_gl->gl_flags);\n\t\twait_on_bit(&i_gl->gl_flags, GLF_FREEING, TASK_UNINTERRUPTIBLE);\n\t}\n\n\t \n\tgfs2_glock_hold(live_gl);\n\tgfs2_glock_dq_wait(&sdp->sd_live_gh);\n\t \n\tfs_warn(sdp, \"Requesting recovery of jid %d.\\n\",\n\t\tsdp->sd_lockstruct.ls_jid);\n\tgfs2_holder_reinit(LM_ST_EXCLUSIVE,\n\t\t\t   LM_FLAG_TRY_1CB | LM_FLAG_NOEXP | GL_NOPID,\n\t\t\t   &sdp->sd_live_gh);\n\tmsleep(GL_GLOCK_MAX_HOLD);\n\t \n\tret = gfs2_glock_nq(&sdp->sd_live_gh);\n\n\t \n\tif (ret == 0) {\n\t\tfs_warn(sdp, \"No other mounters found. Trying to recover our \"\n\t\t\t\"own journal jid %d.\\n\", sdp->sd_lockstruct.ls_jid);\n\t\tif (gfs2_recover_journal(sdp->sd_jdesc, 1))\n\t\t\tfs_warn(sdp, \"Unable to recover our journal jid %d.\\n\",\n\t\t\t\tsdp->sd_lockstruct.ls_jid);\n\t\tgfs2_glock_dq_wait(&sdp->sd_live_gh);\n\t\tgfs2_holder_reinit(LM_ST_SHARED,\n\t\t\t\t   LM_FLAG_NOEXP | GL_EXACT | GL_NOPID,\n\t\t\t\t   &sdp->sd_live_gh);\n\t\tgfs2_glock_nq(&sdp->sd_live_gh);\n\t}\n\n\tgfs2_glock_queue_put(live_gl);  \n\tclear_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags);\n\n\t \n\tinode = gfs2_inode_lookup(sdp->sd_vfs, DT_UNKNOWN,\n\t\t\t\t  sdp->sd_jdesc->jd_no_addr, no_formal_ino,\n\t\t\t\t  GFS2_BLKST_FREE);\n\tif (IS_ERR(inode)) {\n\t\tfs_warn(sdp, \"Reprocessing of jid %d failed with %ld.\\n\",\n\t\t\tsdp->sd_lockstruct.ls_jid, PTR_ERR(inode));\n\t\tgoto skip_recovery;\n\t}\n\tsdp->sd_jdesc->jd_inode = inode;\n\td_mark_dontcache(inode);\n\n\t \n\tfor (tries = 0; tries < 10; tries++) {\n\t\tret = check_journal_clean(sdp, sdp->sd_jdesc, false);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tmsleep(HZ);\n\t\tfs_warn(sdp, \"Waiting for journal recovery jid %d.\\n\",\n\t\t\tsdp->sd_lockstruct.ls_jid);\n\t}\nskip_recovery:\n\tif (!ret)\n\t\tfs_warn(sdp, \"Journal recovery complete for jid %d.\\n\",\n\t\t\tsdp->sd_lockstruct.ls_jid);\n\telse\n\t\tfs_warn(sdp, \"Journal recovery skipped for jid %d until next \"\n\t\t\t\"mount.\\n\", sdp->sd_lockstruct.ls_jid);\n\tfs_warn(sdp, \"Glock dequeues delayed: %lu\\n\", sdp->sd_glock_dqs_held);\n\tsdp->sd_glock_dqs_held = 0;\n\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_RECOVERY);\n}\n\nvoid gfs2_lm(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_bit(SDF_WITHDRAWN, &sdp->sd_flags))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tfs_err(sdp, \"%pV\", &vaf);\n\tva_end(args);\n}\n\nint gfs2_withdraw(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tunsigned long old = READ_ONCE(sdp->sd_flags), new;\n\n\t\tdo {\n\t\t\tif (old & BIT(SDF_WITHDRAWN)) {\n\t\t\t\twait_on_bit(&sdp->sd_flags,\n\t\t\t\t\t    SDF_WITHDRAW_IN_PROG,\n\t\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnew = old | BIT(SDF_WITHDRAWN) | BIT(SDF_WITHDRAW_IN_PROG);\n\t\t} while (unlikely(!try_cmpxchg(&sdp->sd_flags, &old, new)));\n\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tsignal_our_withdraw(sdp);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tset_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags);\n\t\tfs_err(sdp, \"File system withdrawn\\n\");\n\t\tdump_stack();\n\t\tclear_bit(SDF_WITHDRAW_IN_PROG, &sdp->sd_flags);\n\t\tsmp_mb__after_atomic();\n\t\twake_up_bit(&sdp->sd_flags, SDF_WITHDRAW_IN_PROG);\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}\n\n \n\nvoid gfs2_assert_withdraw_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t\t    const char *function, char *file, unsigned int line,\n\t\t\t    bool delayed)\n{\n\tif (gfs2_withdrawn(sdp))\n\t\treturn;\n\n\tfs_err(sdp,\n\t       \"fatal: assertion \\\"%s\\\" failed\\n\"\n\t       \"   function = %s, file = %s, line = %u\\n\",\n\t       assertion, function, file, line);\n\n\t \n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tdelayed = false;\n\n\tif (delayed)\n\t\tgfs2_withdraw_delayed(sdp);\n\telse\n\t\tgfs2_withdraw(sdp);\n\tdump_stack();\n}\n\n \n\nvoid gfs2_assert_warn_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t\tconst char *function, char *file, unsigned int line)\n{\n\tif (time_before(jiffies,\n\t\t\tsdp->sd_last_warning +\n\t\t\tgfs2_tune_get(sdp, gt_complain_secs) * HZ))\n\t\treturn;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW)\n\t\tfs_warn(sdp, \"warning: assertion \\\"%s\\\" failed at function = %s, file = %s, line = %u\\n\",\n\t\t\tassertion, function, file, line);\n\n\tif (sdp->sd_args.ar_debug)\n\t\tBUG();\n\telse\n\t\tdump_stack();\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: warning: assertion \\\"%s\\\" failed\\n\"\n\t\t      \"GFS2: fsid=%s:   function = %s, file = %s, line = %u\\n\",\n\t\t      sdp->sd_fsname, assertion,\n\t\t      sdp->sd_fsname, function, file, line);\n\n\tsdp->sd_last_warning = jiffies;\n}\n\n \n\nvoid gfs2_consist_i(struct gfs2_sbd *sdp, const char *function,\n\t\t    char *file, unsigned int line)\n{\n\tgfs2_lm(sdp,\n\t\t\"fatal: filesystem consistency error - function = %s, file = %s, line = %u\\n\",\n\t\tfunction, file, line);\n\tgfs2_withdraw(sdp);\n}\n\n \n\nvoid gfs2_consist_inode_i(struct gfs2_inode *ip,\n\t\t\t  const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tgfs2_lm(sdp,\n\t\t\"fatal: filesystem consistency error\\n\"\n\t\t\"  inode = %llu %llu\\n\"\n\t\t\"  function = %s, file = %s, line = %u\\n\",\n\t\t(unsigned long long)ip->i_no_formal_ino,\n\t\t(unsigned long long)ip->i_no_addr,\n\t\tfunction, file, line);\n\tgfs2_dump_glock(NULL, ip->i_gl, 1);\n\tgfs2_withdraw(sdp);\n}\n\n \n\nvoid gfs2_consist_rgrpd_i(struct gfs2_rgrpd *rgd,\n\t\t\t  const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tchar fs_id_buf[sizeof(sdp->sd_fsname) + 7];\n\n\tsprintf(fs_id_buf, \"fsid=%s: \", sdp->sd_fsname);\n\tgfs2_rgrp_dump(NULL, rgd, fs_id_buf);\n\tgfs2_lm(sdp,\n\t\t\"fatal: filesystem consistency error\\n\"\n\t\t\"  RG = %llu\\n\"\n\t\t\"  function = %s, file = %s, line = %u\\n\",\n\t\t(unsigned long long)rgd->rd_addr,\n\t\tfunction, file, line);\n\tgfs2_dump_glock(NULL, rgd->rd_gl, 1);\n\tgfs2_withdraw(sdp);\n}\n\n \n\nint gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t       const char *type, const char *function, char *file,\n\t\t       unsigned int line)\n{\n\tint me;\n\n\tgfs2_lm(sdp,\n\t\t\"fatal: invalid metadata block\\n\"\n\t\t\"  bh = %llu (%s)\\n\"\n\t\t\"  function = %s, file = %s, line = %u\\n\",\n\t\t(unsigned long long)bh->b_blocknr, type,\n\t\tfunction, file, line);\n\tme = gfs2_withdraw(sdp);\n\treturn (me) ? -1 : -2;\n}\n\n \n\nint gfs2_metatype_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t\t   u16 type, u16 t, const char *function,\n\t\t\t   char *file, unsigned int line)\n{\n\tint me;\n\n\tgfs2_lm(sdp,\n\t\t\"fatal: invalid metadata block\\n\"\n\t\t\"  bh = %llu (type: exp=%u, found=%u)\\n\"\n\t\t\"  function = %s, file = %s, line = %u\\n\",\n\t\t(unsigned long long)bh->b_blocknr, type, t,\n\t\tfunction, file, line);\n\tme = gfs2_withdraw(sdp);\n\treturn (me) ? -1 : -2;\n}\n\n \n\nint gfs2_io_error_i(struct gfs2_sbd *sdp, const char *function, char *file,\n\t\t    unsigned int line)\n{\n\tgfs2_lm(sdp,\n\t\t\"fatal: I/O error\\n\"\n\t\t\"  function = %s, file = %s, line = %u\\n\",\n\t\tfunction, file, line);\n\treturn gfs2_withdraw(sdp);\n}\n\n \n\nvoid gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t\tconst char *function, char *file, unsigned int line,\n\t\t\tbool withdraw)\n{\n\tif (gfs2_withdrawn(sdp))\n\t\treturn;\n\n\tfs_err(sdp, \"fatal: I/O error\\n\"\n\t       \"  block = %llu\\n\"\n\t       \"  function = %s, file = %s, line = %u\\n\",\n\t       (unsigned long long)bh->b_blocknr, function, file, line);\n\tif (withdraw)\n\t\tgfs2_withdraw(sdp);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}