{
  "module_name": "glops.c",
  "hash_id": "709be41a5f3cf6bbb2ab632b194a11eec9fefd5f542907cf82f1fbbaed4a5dea",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/glops.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/posix_acl.h>\n#include <linux/security.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"bmap.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"meta_io.h\"\n#include \"recovery.h\"\n#include \"rgrp.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"dir.h\"\n#include \"lops.h\"\n\nstruct workqueue_struct *gfs2_freeze_wq;\n\nextern struct workqueue_struct *gfs2_control_wq;\n\nstatic void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tfs_err(sdp,\n\t       \"AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page \"\n\t       \"state 0x%lx\\n\",\n\t       bh, (unsigned long long)bh->b_blocknr, bh->b_state,\n\t       bh->b_folio->mapping, bh->b_folio->flags);\n\tfs_err(sdp, \"AIL glock %u:%llu mapping %p\\n\",\n\t       gl->gl_name.ln_type, gl->gl_name.ln_number,\n\t       gfs2_glock2aspace(gl));\n\tgfs2_lm(sdp, \"AIL error\\n\");\n\tgfs2_withdraw_delayed(sdp);\n}\n\n \n\nstatic void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}\n\n\nstatic int gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_trans tr;\n\tunsigned int revokes;\n\tint ret = 0;\n\n\trevokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!revokes) {\n\t\tbool have_revokes;\n\t\tbool log_in_flight;\n\n\t\t \n\t\tgfs2_log_lock(sdp);\n\t\thave_revokes = !list_empty(&sdp->sd_log_revokes);\n\t\tlog_in_flight = atomic_read(&sdp->sd_log_in_flight);\n\t\tgfs2_log_unlock(sdp);\n\t\tif (have_revokes)\n\t\t\tgoto flush;\n\t\tif (log_in_flight)\n\t\t\tlog_flush_wait(sdp);\n\t\treturn 0;\n\t}\n\n\tmemset(&tr, 0, sizeof(tr));\n\tset_bit(TR_ONSTACK, &tr.tr_flags);\n\tret = __gfs2_trans_begin(&tr, sdp, 0, revokes, _RET_IP_);\n\tif (ret) {\n\t\tfs_err(sdp, \"Transaction error %d: Unable to write revokes.\", ret);\n\t\tgoto flush;\n\t}\n\t__gfs2_ail_flush(gl, 0, revokes);\n\tgfs2_trans_end(sdp);\n\nflush:\n\tif (!ret)\n\t\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t\tGFS2_LFC_AIL_EMPTY_GL);\n\treturn ret;\n}\n\nvoid gfs2_ail_flush(struct gfs2_glock *gl, bool fsync)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tunsigned int revokes = atomic_read(&gl->gl_ail_count);\n\tint ret;\n\n\tif (!revokes)\n\t\treturn;\n\n\tret = gfs2_trans_begin(sdp, 0, revokes);\n\tif (ret)\n\t\treturn;\n\t__gfs2_ail_flush(gl, fsync, revokes);\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t       GFS2_LFC_AIL_FLUSH);\n}\n\n \n\nstatic int gfs2_rgrp_metasync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct address_space *metamapping = &sdp->sd_aspace;\n\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(gl);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t start = (rgd->rd_addr * bsize) & PAGE_MASK;\n\tloff_t end = PAGE_ALIGN((rgd->rd_addr + rgd->rd_length) * bsize) - 1;\n\tint error;\n\n\tfilemap_fdatawrite_range(metamapping, start, end);\n\terror = filemap_fdatawait_range(metamapping, start, end);\n\tWARN_ON_ONCE(error && !gfs2_withdrawn(sdp));\n\tmapping_set_error(metamapping, error);\n\tif (error)\n\t\tgfs2_io_error(sdp);\n\treturn error;\n}\n\n \n\nstatic int rgrp_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(gl);\n\tint error;\n\n\tif (!rgd || !test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\treturn 0;\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(sdp, gl, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t       GFS2_LFC_RGRP_GO_SYNC);\n\terror = gfs2_rgrp_metasync(gl);\n\tif (!error)\n\t\terror = gfs2_ail_empty_gl(gl);\n\tgfs2_free_clones(rgd);\n\treturn error;\n}\n\n \n\nstatic void rgrp_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct address_space *mapping = &sdp->sd_aspace;\n\tstruct gfs2_rgrpd *rgd = gfs2_glock2rgrp(gl);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t start, end;\n\n\tif (!rgd)\n\t\treturn;\n\tstart = (rgd->rd_addr * bsize) & PAGE_MASK;\n\tend = PAGE_ALIGN((rgd->rd_addr + rgd->rd_length) * bsize) - 1;\n\tgfs2_rgrp_brelse(rgd);\n\tWARN_ON_ONCE(!(flags & DIO_METADATA));\n\ttruncate_inode_pages_range(mapping, start, end);\n}\n\nstatic void gfs2_rgrp_go_dump(struct seq_file *seq, const struct gfs2_glock *gl,\n\t\t\t      const char *fs_id_buf)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\n\tif (rgd)\n\t\tgfs2_rgrp_dump(seq, rgd, fs_id_buf);\n}\n\nstatic struct gfs2_inode *gfs2_glock2inode(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\tip = gl->gl_object;\n\tif (ip)\n\t\tset_bit(GIF_GLOP_PENDING, &ip->i_flags);\n\tspin_unlock(&gl->gl_lockref.lock);\n\treturn ip;\n}\n\nstruct gfs2_rgrpd *gfs2_glock2rgrp(struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&gl->gl_lockref.lock);\n\trgd = gl->gl_object;\n\tspin_unlock(&gl->gl_lockref.lock);\n\n\treturn rgd;\n}\n\nstatic void gfs2_clear_glop_pending(struct gfs2_inode *ip)\n{\n\tif (!ip)\n\t\treturn;\n\n\tclear_bit_unlock(GIF_GLOP_PENDING, &ip->i_flags);\n\twake_up_bit(&ip->i_flags, GIF_GLOP_PENDING);\n}\n\n \nint gfs2_inode_metasync(struct gfs2_glock *gl)\n{\n\tstruct address_space *metamapping = gfs2_glock2aspace(gl);\n\tint error;\n\n\tfilemap_fdatawrite(metamapping);\n\terror = filemap_fdatawait(metamapping);\n\tif (error)\n\t\tgfs2_io_error(gl->gl_name.ln_sbd);\n\treturn error;\n}\n\n \n\nstatic int inode_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip = gfs2_glock2inode(gl);\n\tint isreg = ip && S_ISREG(ip->i_inode.i_mode);\n\tstruct address_space *metamapping = gfs2_glock2aspace(gl);\n\tint error = 0, ret;\n\n\tif (isreg) {\n\t\tif (test_and_clear_bit(GIF_SW_PAGED, &ip->i_flags))\n\t\t\tunmap_shared_mapping_range(ip->i_inode.i_mapping, 0, 0);\n\t\tinode_dio_wait(&ip->i_inode);\n\t}\n\tif (!test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\tgoto out;\n\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(gl->gl_name.ln_sbd, gl, GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t       GFS2_LFC_INODE_GO_SYNC);\n\tfilemap_fdatawrite(metamapping);\n\tif (isreg) {\n\t\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\t\tfilemap_fdatawrite(mapping);\n\t\terror = filemap_fdatawait(mapping);\n\t\tmapping_set_error(mapping, error);\n\t}\n\tret = gfs2_inode_metasync(gl);\n\tif (!error)\n\t\terror = ret;\n\tret = gfs2_ail_empty_gl(gl);\n\tif (!error)\n\t\terror = ret;\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(GLF_DIRTY, &gl->gl_flags);\n\nout:\n\tgfs2_clear_glop_pending(ip);\n\treturn error;\n}\n\n \n\nstatic void inode_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_inode *ip = gfs2_glock2inode(gl);\n\n\tif (flags & DIO_METADATA) {\n\t\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tif (ip) {\n\t\t\tset_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags);\n\t\t\tforget_all_cached_acls(&ip->i_inode);\n\t\t\tsecurity_inode_invalidate_secctx(&ip->i_inode);\n\t\t\tgfs2_dir_hash_inval(ip);\n\t\t}\n\t}\n\n\tif (ip == GFS2_I(gl->gl_name.ln_sbd->sd_rindex)) {\n\t\tgfs2_log_flush(gl->gl_name.ln_sbd, NULL,\n\t\t\t       GFS2_LOG_HEAD_FLUSH_NORMAL |\n\t\t\t       GFS2_LFC_INODE_GO_INVAL);\n\t\tgl->gl_name.ln_sbd->sd_rindex_uptodate = 0;\n\t}\n\tif (ip && S_ISREG(ip->i_inode.i_mode))\n\t\ttruncate_inode_pages(ip->i_inode.i_mapping, 0);\n\n\tgfs2_clear_glop_pending(ip);\n}\n\n \n\nstatic int inode_go_demote_ok(const struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tif (sdp->sd_jindex == gl->gl_object || sdp->sd_rindex == gl->gl_object)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst struct gfs2_dinode *str = buf;\n\tstruct timespec64 atime;\n\tu16 height, depth;\n\tumode_t mode = be32_to_cpu(str->di_mode);\n\tstruct inode *inode = &ip->i_inode;\n\tbool is_new = inode->i_state & I_NEW;\n\n\tif (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))\n\t\tgoto corrupt;\n\tif (unlikely(!is_new && inode_wrong_type(inode, mode)))\n\t\tgoto corrupt;\n\tip->i_no_formal_ino = be64_to_cpu(str->di_num.no_formal_ino);\n\tinode->i_mode = mode;\n\tif (is_new) {\n\t\tinode->i_rdev = 0;\n\t\tswitch (mode & S_IFMT) {\n\t\tcase S_IFBLK:\n\t\tcase S_IFCHR:\n\t\t\tinode->i_rdev = MKDEV(be32_to_cpu(str->di_major),\n\t\t\t\t\t      be32_to_cpu(str->di_minor));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti_uid_write(inode, be32_to_cpu(str->di_uid));\n\ti_gid_write(inode, be32_to_cpu(str->di_gid));\n\tset_nlink(inode, be32_to_cpu(str->di_nlink));\n\ti_size_write(inode, be64_to_cpu(str->di_size));\n\tgfs2_set_inode_blocks(inode, be64_to_cpu(str->di_blocks));\n\tatime.tv_sec = be64_to_cpu(str->di_atime);\n\tatime.tv_nsec = be32_to_cpu(str->di_atime_nsec);\n\tif (timespec64_compare(&inode->i_atime, &atime) < 0)\n\t\tinode->i_atime = atime;\n\tinode->i_mtime.tv_sec = be64_to_cpu(str->di_mtime);\n\tinode->i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);\n\tinode_set_ctime(inode, be64_to_cpu(str->di_ctime),\n\t\t\tbe32_to_cpu(str->di_ctime_nsec));\n\n\tip->i_goal = be64_to_cpu(str->di_goal_meta);\n\tip->i_generation = be64_to_cpu(str->di_generation);\n\n\tip->i_diskflags = be32_to_cpu(str->di_flags);\n\tip->i_eattr = be64_to_cpu(str->di_eattr);\n\t \n\tgfs2_set_inode_flags(inode);\n\theight = be16_to_cpu(str->di_height);\n\tif (unlikely(height > sdp->sd_max_height))\n\t\tgoto corrupt;\n\tip->i_height = (u8)height;\n\n\tdepth = be16_to_cpu(str->di_depth);\n\tif (unlikely(depth > GFS2_DIR_MAX_DEPTH))\n\t\tgoto corrupt;\n\tip->i_depth = (u8)depth;\n\tip->i_entries = be32_to_cpu(str->di_entries);\n\n\tif (gfs2_is_stuffed(ip) && inode->i_size > gfs2_max_stuffed_size(ip))\n\t\tgoto corrupt;\n\n\tif (S_ISREG(inode->i_mode))\n\t\tgfs2_set_aops(inode);\n\n\treturn 0;\ncorrupt:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}\n\n \n\nint gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\treturn error;\n}\n\n \n\nstatic int inode_go_instantiate(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\n\tif (!ip)  \n\t\treturn 0;\n\n\treturn gfs2_inode_refresh(ip);\n}\n\nstatic int inode_go_held(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tint error = 0;\n\n\tif (!ip)  \n\t\treturn 0;\n\n\tif (gh->gh_state != LM_ST_DEFERRED)\n\t\tinode_dio_wait(&ip->i_inode);\n\n\tif ((ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG) &&\n\t    (gl->gl_state == LM_ST_EXCLUSIVE) &&\n\t    (gh->gh_state == LM_ST_EXCLUSIVE))\n\t\terror = gfs2_truncatei_resume(ip);\n\n\treturn error;\n}\n\n \n\nstatic void inode_go_dump(struct seq_file *seq, const struct gfs2_glock *gl,\n\t\t\t  const char *fs_id_buf)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tconst struct inode *inode = &ip->i_inode;\n\n\tif (ip == NULL)\n\t\treturn;\n\n\tgfs2_print_dbg(seq, \"%s I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu \"\n\t\t       \"p:%lu\\n\", fs_id_buf,\n\t\t  (unsigned long long)ip->i_no_formal_ino,\n\t\t  (unsigned long long)ip->i_no_addr,\n\t\t  IF2DT(inode->i_mode), ip->i_flags,\n\t\t  (unsigned int)ip->i_diskflags,\n\t\t  (unsigned long long)i_size_read(inode),\n\t\t  inode->i_data.nrpages);\n}\n\n \n\nstatic void freeze_go_callback(struct gfs2_glock *gl, bool remote)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct super_block *sb = sdp->sd_vfs;\n\n\tif (!remote ||\n\t    (gl->gl_state != LM_ST_SHARED &&\n\t     gl->gl_state != LM_ST_UNLOCKED) ||\n\t    gl->gl_demote_state != LM_ST_UNLOCKED)\n\t\treturn;\n\n\t \n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tatomic_inc(&sb->s_active);\n\t\tup_read(&sb->s_umount);\n\t\tif (!queue_work(gfs2_freeze_wq, &sdp->sd_freeze_work))\n\t\t\tdeactivate_super(sb);\n\t}\n}\n\n \nstatic int freeze_go_xmote_bh(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\tstruct gfs2_glock *j_gl = ip->i_gl;\n\tstruct gfs2_log_header_host head;\n\tint error;\n\n\tif (test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {\n\t\tj_gl->gl_ops->go_inval(j_gl, DIO_METADATA);\n\n\t\terror = gfs2_find_jhead(sdp->sd_jdesc, &head, false);\n\t\tif (gfs2_assert_withdraw_delayed(sdp, !error))\n\t\t\treturn error;\n\t\tif (gfs2_assert_withdraw_delayed(sdp, head.lh_flags &\n\t\t\t\t\t\t GFS2_LOG_HEAD_UNMOUNT))\n\t\t\treturn -EIO;\n\t\tsdp->sd_log_sequence = head.lh_sequence + 1;\n\t\tgfs2_log_pointers_init(sdp, head.lh_blkno);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int freeze_go_demote_ok(const struct gfs2_glock *gl)\n{\n\treturn 0;\n}\n\n \nstatic void iopen_go_callback(struct gfs2_glock *gl, bool remote)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\tif (!remote || sb_rdonly(sdp->sd_vfs) ||\n\t    test_bit(SDF_KILL, &sdp->sd_flags))\n\t\treturn;\n\n\tif (gl->gl_demote_state == LM_ST_UNLOCKED &&\n\t    gl->gl_state == LM_ST_SHARED && ip) {\n\t\tgl->gl_lockref.count++;\n\t\tif (!gfs2_queue_try_to_evict(gl))\n\t\t\tgl->gl_lockref.count--;\n\t}\n}\n\n \nstatic void inode_go_free(struct gfs2_glock *gl)\n{\n\t \n\tif (!test_bit(GLF_FREEING, &gl->gl_flags))\n\t\treturn;\n\tclear_bit_unlock(GLF_FREEING, &gl->gl_flags);\n\twake_up_bit(&gl->gl_flags, GLF_FREEING);\n}\n\n \nstatic void nondisk_go_callback(struct gfs2_glock *gl, bool remote)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\n\t \n\tif (!remote || gl->gl_name.ln_number != GFS2_LIVE_LOCK)\n\t\treturn;\n\n\t \n\tclear_bit(GLF_DEMOTE, &gl->gl_flags);\n\tclear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags);\n\n\t \n\tif (test_bit(SDF_NORECOVERY, &sdp->sd_flags) ||\n\t    test_bit(SDF_WITHDRAWN, &sdp->sd_flags) ||\n\t    test_bit(SDF_REMOTE_WITHDRAW, &sdp->sd_flags))\n\t\treturn;\n\n\t \n\tif (gl->gl_demote_state != LM_ST_UNLOCKED)\n\t\treturn;\n\n\tif (sdp->sd_args.ar_spectator) {\n\t\tfs_warn(sdp, \"Spectator node cannot recover journals.\\n\");\n\t\treturn;\n\t}\n\n\tfs_warn(sdp, \"Some node has withdrawn; checking for recovery.\\n\");\n\tset_bit(SDF_REMOTE_WITHDRAW, &sdp->sd_flags);\n\t \n\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work, 0);\n}\n\nconst struct gfs2_glock_operations gfs2_meta_glops = {\n\t.go_type = LM_TYPE_META,\n\t.go_flags = GLOF_NONDISK,\n};\n\nconst struct gfs2_glock_operations gfs2_inode_glops = {\n\t.go_sync = inode_go_sync,\n\t.go_inval = inode_go_inval,\n\t.go_demote_ok = inode_go_demote_ok,\n\t.go_instantiate = inode_go_instantiate,\n\t.go_held = inode_go_held,\n\t.go_dump = inode_go_dump,\n\t.go_type = LM_TYPE_INODE,\n\t.go_flags = GLOF_ASPACE | GLOF_LRU | GLOF_LVB,\n\t.go_free = inode_go_free,\n};\n\nconst struct gfs2_glock_operations gfs2_rgrp_glops = {\n\t.go_sync = rgrp_go_sync,\n\t.go_inval = rgrp_go_inval,\n\t.go_instantiate = gfs2_rgrp_go_instantiate,\n\t.go_dump = gfs2_rgrp_go_dump,\n\t.go_type = LM_TYPE_RGRP,\n\t.go_flags = GLOF_LVB,\n};\n\nconst struct gfs2_glock_operations gfs2_freeze_glops = {\n\t.go_xmote_bh = freeze_go_xmote_bh,\n\t.go_demote_ok = freeze_go_demote_ok,\n\t.go_callback = freeze_go_callback,\n\t.go_type = LM_TYPE_NONDISK,\n\t.go_flags = GLOF_NONDISK,\n};\n\nconst struct gfs2_glock_operations gfs2_iopen_glops = {\n\t.go_type = LM_TYPE_IOPEN,\n\t.go_callback = iopen_go_callback,\n\t.go_dump = inode_go_dump,\n\t.go_flags = GLOF_LRU | GLOF_NONDISK,\n\t.go_subclass = 1,\n};\n\nconst struct gfs2_glock_operations gfs2_flock_glops = {\n\t.go_type = LM_TYPE_FLOCK,\n\t.go_flags = GLOF_LRU | GLOF_NONDISK,\n};\n\nconst struct gfs2_glock_operations gfs2_nondisk_glops = {\n\t.go_type = LM_TYPE_NONDISK,\n\t.go_flags = GLOF_NONDISK,\n\t.go_callback = nondisk_go_callback,\n};\n\nconst struct gfs2_glock_operations gfs2_quota_glops = {\n\t.go_type = LM_TYPE_QUOTA,\n\t.go_flags = GLOF_LVB | GLOF_LRU | GLOF_NONDISK,\n};\n\nconst struct gfs2_glock_operations gfs2_journal_glops = {\n\t.go_type = LM_TYPE_JOURNAL,\n\t.go_flags = GLOF_NONDISK,\n};\n\nconst struct gfs2_glock_operations *gfs2_glops_list[] = {\n\t[LM_TYPE_META] = &gfs2_meta_glops,\n\t[LM_TYPE_INODE] = &gfs2_inode_glops,\n\t[LM_TYPE_RGRP] = &gfs2_rgrp_glops,\n\t[LM_TYPE_IOPEN] = &gfs2_iopen_glops,\n\t[LM_TYPE_FLOCK] = &gfs2_flock_glops,\n\t[LM_TYPE_NONDISK] = &gfs2_nondisk_glops,\n\t[LM_TYPE_QUOTA] = &gfs2_quota_glops,\n\t[LM_TYPE_JOURNAL] = &gfs2_journal_glops,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}