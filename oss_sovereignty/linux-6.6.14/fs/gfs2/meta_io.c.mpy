{
  "module_name": "meta_io.c",
  "hash_id": "89c753c21328f09a91ecb93bea67aca5983b85a339c1680f8395dfd92c761a0d",
  "original_prompt": "Ingested from linux-6.6.14/fs/gfs2/meta_io.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/delay.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n\n#include \"gfs2.h\"\n#include \"incore.h\"\n#include \"glock.h\"\n#include \"glops.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"lops.h\"\n#include \"meta_io.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"trace_gfs2.h\"\n\nstatic int gfs2_aspace_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct buffer_head *bh, *head;\n\tint nr_underway = 0;\n\tblk_opf_t write_flags = REQ_META | REQ_PRIO | wbc_to_write_flags(wbc);\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!page_has_buffers(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t \n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write(bh);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t \n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(REQ_OP_WRITE | write_flags, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\tif (nr_underway == 0)\n\t\tend_page_writeback(page);\n\n\treturn 0;\n}\n\nconst struct address_space_operations gfs2_meta_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.writepage = gfs2_aspace_writepage,\n\t.release_folio = gfs2_release_folio,\n};\n\nconst struct address_space_operations gfs2_rgrp_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.writepage = gfs2_aspace_writepage,\n\t.release_folio = gfs2_release_folio,\n};\n\n \n\nstruct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\n{\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift;\n\tunsigned long index;\n\tunsigned int bufnum;\n\n\tif (mapping == NULL)\n\t\tmapping = &sdp->sd_aspace;\n\n\tshift = PAGE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tindex = blkno >> shift;              \n\tbufnum = blkno - (index << shift);   \n\n\tif (create) {\n\t\tfor (;;) {\n\t\t\tpage = grab_cache_page(mapping, index);\n\t\t\tif (page)\n\t\t\t\tbreak;\n\t\t\tyield();\n\t\t}\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\n\t} else {\n\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\tFGP_LOCK|FGP_ACCESSED);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tif (!page_has_buffers(page)) {\n\t\t\tbh = NULL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t ;\n\tget_bh(bh);\n\n\tif (!buffer_mapped(bh))\n\t\tmap_bh(bh, sdp->sd_vfs, blkno);\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn bh;\n}\n\nstatic void meta_prep_new(struct buffer_head *bh)\n{\n\tstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\tmh->mh_magic = cpu_to_be32(GFS2_MAGIC);\n}\n\n \n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}\n\nstatic void gfs2_meta_read_endio(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tstruct page *page = bvec->bv_page;\n\t\tstruct buffer_head *bh = page_buffers(page);\n\t\tunsigned int len = bvec->bv_len;\n\n\t\twhile (bh_offset(bh) < bvec->bv_offset)\n\t\t\tbh = bh->b_this_page;\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tlen -= bh->b_size;\n\t\t\tbh->b_end_io(bh, !bio->bi_status);\n\t\t\tbh = next;\n\t\t} while (bh && len);\n\t}\n\tbio_put(bio);\n}\n\n \nstatic void gfs2_submit_bhs(blk_opf_t opf, struct buffer_head *bhs[], int num)\n{\n\twhile (num > 0) {\n\t\tstruct buffer_head *bh = *bhs;\n\t\tstruct bio *bio;\n\n\t\tbio = bio_alloc(bh->b_bdev, num, opf, GFP_NOIO);\n\t\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\t\twhile (num > 0) {\n\t\t\tbh = *bhs;\n\t\t\tif (!bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh))) {\n\t\t\t\tBUG_ON(bio->bi_iter.bi_size == 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbhs++;\n\t\t\tnum--;\n\t\t}\n\t\tbio->bi_end_io = gfs2_meta_read_endio;\n\t\tsubmit_bio(bio);\n\t}\n}\n\n \n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   int rahead, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct buffer_head *bh, *bhs[2];\n\tint num = 0;\n\n\tif (unlikely(gfs2_withdrawn(sdp)) && !gfs2_withdraw_in_prog(sdp)) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tflags &= ~DIO_WAIT;\n\t} else {\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tget_bh(bh);\n\t\tbhs[num++] = bh;\n\t}\n\n\tif (rahead) {\n\t\tbh = gfs2_getbuf(gl, blkno + 1, CREATE);\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tbhs[num++] = bh;\n\t\t}\n\t}\n\n\tgfs2_submit_bhs(REQ_OP_READ | REQ_META | REQ_PRIO, bhs, num);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\tbh = *bhp;\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && test_bit(TR_TOUCHED, &tr->tr_flags))\n\t\t\tgfs2_io_error_bh_wd(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \n\nint gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tif (unlikely(gfs2_withdrawn(sdp)) && !gfs2_withdraw_in_prog(sdp))\n\t\treturn -EIO;\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && test_bit(TR_TOUCHED, &tr->tr_flags))\n\t\t\tgfs2_io_error_bh_wd(sdp, bh);\n\t\treturn -EIO;\n\t}\n\tif (unlikely(gfs2_withdrawn(sdp)) && !gfs2_withdraw_in_prog(sdp))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nvoid gfs2_remove_from_journal(struct buffer_head *bh, int meta)\n{\n\tstruct address_space *mapping = bh->b_folio->mapping;\n\tstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\n\tstruct gfs2_bufdata *bd = bh->b_private;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tint was_pinned = 0;\n\n\tif (test_clear_buffer_pinned(bh)) {\n\t\ttrace_gfs2_pin(bd, 0);\n\t\tatomic_dec(&sdp->sd_log_pinned);\n\t\tlist_del_init(&bd->bd_list);\n\t\tif (meta == REMOVE_META)\n\t\t\ttr->tr_num_buf_rm++;\n\t\telse\n\t\t\ttr->tr_num_databuf_rm++;\n\t\tset_bit(TR_TOUCHED, &tr->tr_flags);\n\t\twas_pinned = 1;\n\t\tbrelse(bh);\n\t}\n\tif (bd) {\n\t\tif (bd->bd_tr) {\n\t\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\t} else if (was_pinned) {\n\t\t\tbh->b_private = NULL;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t} else if (!list_empty(&bd->bd_ail_st_list) &&\n\t\t\t\t\t!list_empty(&bd->bd_ail_gl_list)) {\n\t\t\tgfs2_remove_from_ail(bd);\n\t\t}\n\t}\n\tclear_buffer_dirty(bh);\n\tclear_buffer_uptodate(bh);\n}\n\n \nstatic void gfs2_ail1_wipe(struct gfs2_sbd *sdp, u64 bstart, u32 blen)\n{\n\tstruct gfs2_trans *tr, *s;\n\tstruct gfs2_bufdata *bd, *bs;\n\tstruct buffer_head *bh;\n\tu64 end = bstart + blen;\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe(tr, s, &sdp->sd_ail1_list, tr_list) {\n\t\tlist_for_each_entry_safe(bd, bs, &tr->tr_ail1_list,\n\t\t\t\t\t bd_ail_st_list) {\n\t\t\tbh = bd->bd_bh;\n\t\t\tif (bh->b_blocknr < bstart || bh->b_blocknr >= end)\n\t\t\t\tcontinue;\n\n\t\t\tgfs2_remove_from_journal(bh, REMOVE_JDATA);\n\t\t}\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}\n\nstatic struct buffer_head *gfs2_getjdatabuf(struct gfs2_inode *ip, u64 blkno)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tunsigned int shift = PAGE_SHIFT - sdp->sd_sb.sb_bsize_shift;\n\tunsigned long index = blkno >> shift;  \n\tunsigned int bufnum = blkno - (index << shift);\n\n\tpage = find_get_page_flags(mapping, index, FGP_LOCK|FGP_ACCESSED);\n\tif (!page)\n\t\treturn NULL;\n\tif (!page_has_buffers(page)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\t \n\tfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\n\t\t ;\n\tget_bh(bh);\n\tunlock_page(page);\n\tput_page(page);\n\treturn bh;\n}\n\n \n\nvoid gfs2_journal_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\tint ty;\n\n\tif (!ip->i_gl) {\n\t\t \n\t\tBUG_ON(!test_bit(GIF_ALLOC_FAILED, &ip->i_flags));\n\t\treturn;\n\t}\n\n\tgfs2_ail1_wipe(sdp, bstart, blen);\n\twhile (blen) {\n\t\tty = REMOVE_META;\n\t\tbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\n\t\tif (!bh && gfs2_is_jdata(ip)) {\n\t\t\tbh = gfs2_getjdatabuf(ip, bstart);\n\t\t\tty = REMOVE_JDATA;\n\t\t}\n\t\tif (bh) {\n\t\t\tlock_buffer(bh);\n\t\t\tgfs2_log_lock(sdp);\n\t\t\tspin_lock(&sdp->sd_ail_lock);\n\t\t\tgfs2_remove_from_journal(bh, ty);\n\t\t\tspin_unlock(&sdp->sd_ail_lock);\n\t\t\tgfs2_log_unlock(sdp);\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tbstart++;\n\t\tblen--;\n\t}\n}\n\n \n\nint gfs2_meta_buffer(struct gfs2_inode *ip, u32 mtype, u64 num,\n\t\t     struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\tint rahead = 0;\n\n\tif (num == ip->i_no_addr)\n\t\trahead = ip->i_rahead;\n\n\tret = gfs2_meta_read(gl, num, DIO_WAIT, rahead, &bh);\n\tif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\n\t\tbrelse(bh);\n\t\tret = -EIO;\n\t} else {\n\t\t*bhp = bh;\n\t}\n\treturn ret;\n}\n\n \n\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tbh_read_nowait(first_bh, REQ_META | REQ_PRIO);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tbh_readahead(bh, REQ_RAHEAD | REQ_META | REQ_PRIO);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}