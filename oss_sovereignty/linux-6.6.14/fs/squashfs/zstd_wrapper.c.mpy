{
  "module_name": "zstd_wrapper.c",
  "hash_id": "80115192ce3dffb4333d7b0967ad32908402cc9e5cb0256c8685492cbb25c9ca",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/zstd_wrapper.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/zstd.h>\n#include <linux/vmalloc.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\nstruct workspace {\n\tvoid *mem;\n\tsize_t mem_size;\n\tsize_t window_size;\n};\n\nstatic void *zstd_init(struct squashfs_sb_info *msblk, void *buff)\n{\n\tstruct workspace *wksp = kmalloc(sizeof(*wksp), GFP_KERNEL);\n\n\tif (wksp == NULL)\n\t\tgoto failed;\n\twksp->window_size = max_t(size_t,\n\t\t\tmsblk->block_size, SQUASHFS_METADATA_SIZE);\n\twksp->mem_size = zstd_dstream_workspace_bound(wksp->window_size);\n\twksp->mem = vmalloc(wksp->mem_size);\n\tif (wksp->mem == NULL)\n\t\tgoto failed;\n\n\treturn wksp;\n\nfailed:\n\tERROR(\"Failed to allocate zstd workspace\\n\");\n\tkfree(wksp);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n\nstatic void zstd_free(void *strm)\n{\n\tstruct workspace *wksp = strm;\n\n\tif (wksp)\n\t\tvfree(wksp->mem);\n\tkfree(wksp);\n}\n\n\nstatic int zstd_uncompress(struct squashfs_sb_info *msblk, void *strm,\n\tstruct bio *bio, int offset, int length,\n\tstruct squashfs_page_actor *output)\n{\n\tstruct workspace *wksp = strm;\n\tzstd_dstream *stream;\n\tsize_t total_out = 0;\n\tint error = 0;\n\tzstd_in_buffer in_buf = { NULL, 0, 0 };\n\tzstd_out_buffer out_buf = { NULL, 0, 0 };\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\n\tstream = zstd_init_dstream(wksp->window_size, wksp->mem, wksp->mem_size);\n\n\tif (!stream) {\n\t\tERROR(\"Failed to initialize zstd decompressor\\n\");\n\t\treturn -EIO;\n\t}\n\n\tout_buf.size = PAGE_SIZE;\n\tout_buf.dst = squashfs_first_page(output);\n\tif (IS_ERR(out_buf.dst)) {\n\t\terror = PTR_ERR(out_buf.dst);\n\t\tgoto finish;\n\t}\n\n\tfor (;;) {\n\t\tsize_t zstd_err;\n\n\t\tif (in_buf.pos == in_buf.size) {\n\t\t\tconst void *data;\n\t\t\tint avail;\n\n\t\t\tif (!bio_next_segment(bio, &iter_all)) {\n\t\t\t\terror = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tavail = min(length, ((int)bvec->bv_len) - offset);\n\t\t\tdata = bvec_virt(bvec);\n\t\t\tlength -= avail;\n\t\t\tin_buf.src = data + offset;\n\t\t\tin_buf.size = avail;\n\t\t\tin_buf.pos = 0;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (out_buf.pos == out_buf.size) {\n\t\t\tout_buf.dst = squashfs_next_page(output);\n\t\t\tif (IS_ERR(out_buf.dst)) {\n\t\t\t\terror = PTR_ERR(out_buf.dst);\n\t\t\t\tbreak;\n\t\t\t} else if (out_buf.dst == NULL) {\n\t\t\t\t \n\t\t\t\terror = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tout_buf.pos = 0;\n\t\t\tout_buf.size = PAGE_SIZE;\n\t\t}\n\n\t\ttotal_out -= out_buf.pos;\n\t\tzstd_err = zstd_decompress_stream(stream, &out_buf, &in_buf);\n\t\ttotal_out += out_buf.pos;  \n\t\tif (zstd_err == 0)\n\t\t\tbreak;\n\n\t\tif (zstd_is_error(zstd_err)) {\n\t\t\tERROR(\"zstd decompression error: %d\\n\",\n\t\t\t\t\t(int)zstd_get_error_code(zstd_err));\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfinish:\n\n\tsquashfs_finish_page(output);\n\n\treturn error ? error : total_out;\n}\n\nconst struct squashfs_decompressor squashfs_zstd_comp_ops = {\n\t.init = zstd_init,\n\t.free = zstd_free,\n\t.decompress = zstd_uncompress,\n\t.id = ZSTD_COMPRESSION,\n\t.name = \"zstd\",\n\t.alloc_buffer = 1,\n\t.supported = 1\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}