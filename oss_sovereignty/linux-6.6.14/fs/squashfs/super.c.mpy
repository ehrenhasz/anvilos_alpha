{
  "module_name": "super.c",
  "hash_id": "cecff150f1df4efc5a6ea6951fd39a99513bfccd4294bd0a71d7972e84b5ddbd",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/super.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"xattr.h\"\n\nstatic struct file_system_type squashfs_fs_type;\nstatic const struct super_operations squashfs_super_ops;\n\nenum Opt_errors {\n\tOpt_errors_continue,\n\tOpt_errors_panic,\n};\n\nenum squashfs_param {\n\tOpt_errors,\n\tOpt_threads,\n};\n\nstruct squashfs_mount_opts {\n\tenum Opt_errors errors;\n\tconst struct squashfs_decompressor_thread_ops *thread_ops;\n\tint thread_num;\n};\n\nstatic const struct constant_table squashfs_param_errors[] = {\n\t{\"continue\",   Opt_errors_continue },\n\t{\"panic\",      Opt_errors_panic },\n\t{}\n};\n\nstatic const struct fs_parameter_spec squashfs_fs_parameters[] = {\n\tfsparam_enum(\"errors\", Opt_errors, squashfs_param_errors),\n\tfsparam_string(\"threads\", Opt_threads),\n\t{}\n};\n\n\nstatic int squashfs_parse_param_threads_str(const char *str, struct squashfs_mount_opts *opts)\n{\n#ifdef CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT\n\tif (strcmp(str, \"single\") == 0) {\n\t\topts->thread_ops = &squashfs_decompressor_single;\n\t\treturn 0;\n\t}\n\tif (strcmp(str, \"multi\") == 0) {\n\t\topts->thread_ops = &squashfs_decompressor_multi;\n\t\treturn 0;\n\t}\n\tif (strcmp(str, \"percpu\") == 0) {\n\t\topts->thread_ops = &squashfs_decompressor_percpu;\n\t\treturn 0;\n\t}\n#endif\n\treturn -EINVAL;\n}\n\nstatic int squashfs_parse_param_threads_num(const char *str, struct squashfs_mount_opts *opts)\n{\n#ifdef CONFIG_SQUASHFS_MOUNT_DECOMP_THREADS\n\tint ret;\n\tunsigned long num;\n\n\tret = kstrtoul(str, 0, &num);\n\tif (ret != 0)\n\t\treturn -EINVAL;\n\tif (num > 1) {\n\t\topts->thread_ops = &squashfs_decompressor_multi;\n\t\tif (num > opts->thread_ops->max_decompressors())\n\t\t\treturn -EINVAL;\n\t\topts->thread_num = (int)num;\n\t\treturn 0;\n\t}\n#ifdef CONFIG_SQUASHFS_DECOMP_SINGLE\n\tif (num == 1) {\n\t\topts->thread_ops = &squashfs_decompressor_single;\n\t\topts->thread_num = 1;\n\t\treturn 0;\n\t}\n#endif\n#endif  \n\treturn -EINVAL;\n}\n\nstatic int squashfs_parse_param_threads(const char *str, struct squashfs_mount_opts *opts)\n{\n\tint ret = squashfs_parse_param_threads_str(str, opts);\n\n\tif (ret == 0)\n\t\treturn ret;\n\treturn squashfs_parse_param_threads_num(str, opts);\n}\n\nstatic int squashfs_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct squashfs_mount_opts *opts = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, squashfs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_errors:\n\t\topts->errors = result.uint_32;\n\t\tbreak;\n\tcase Opt_threads:\n\t\tif (squashfs_parse_param_threads(param->string, opts) != 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct squashfs_decompressor *supported_squashfs_filesystem(\n\tstruct fs_context *fc,\n\tshort major, short minor, short id)\n{\n\tconst struct squashfs_decompressor *decompressor;\n\n\tif (major < SQUASHFS_MAJOR) {\n\t\terrorf(fc, \"Major/Minor mismatch, older Squashfs %d.%d \"\n\t\t       \"filesystems are unsupported\", major, minor);\n\t\treturn NULL;\n\t} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {\n\t\terrorf(fc, \"Major/Minor mismatch, trying to mount newer \"\n\t\t       \"%d.%d filesystem\", major, minor);\n\t\terrorf(fc, \"Please update your kernel\");\n\t\treturn NULL;\n\t}\n\n\tdecompressor = squashfs_lookup_decompressor(id);\n\tif (!decompressor->supported) {\n\t\terrorf(fc, \"Filesystem uses \\\"%s\\\" compression. This is not supported\",\n\t\t       decompressor->name);\n\t\treturn NULL;\n\t}\n\n\treturn decompressor;\n}\n\n\nstatic int squashfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct squashfs_mount_opts *opts = fc->fs_private;\n\tstruct squashfs_sb_info *msblk;\n\tstruct squashfs_super_block *sblk = NULL;\n\tstruct inode *root;\n\tlong long root_inode;\n\tunsigned short flags;\n\tunsigned int fragments;\n\tu64 lookup_table_start, xattr_id_table_start, next_table;\n\tint err;\n\n\tTRACE(\"Entered squashfs_fill_superblock\\n\");\n\n\tsb->s_fs_info = kzalloc(sizeof(*msblk), GFP_KERNEL);\n\tif (sb->s_fs_info == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_sb_info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmsblk = sb->s_fs_info;\n\tmsblk->thread_ops = opts->thread_ops;\n\n\tmsblk->panic_on_errors = (opts->errors == Opt_errors_panic);\n\n\tmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);\n\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n\n\tmutex_init(&msblk->meta_index_mutex);\n\n\t \n\tmsblk->bytes_used = sizeof(*sblk);\n\tsblk = squashfs_read_table(sb, SQUASHFS_START, sizeof(*sblk));\n\n\tif (IS_ERR(sblk)) {\n\t\terrorf(fc, \"unable to read squashfs_super_block\");\n\t\terr = PTR_ERR(sblk);\n\t\tsblk = NULL;\n\t\tgoto failed_mount;\n\t}\n\n\terr = -EINVAL;\n\n\t \n\tsb->s_magic = le32_to_cpu(sblk->s_magic);\n\tif (sb->s_magic != SQUASHFS_MAGIC) {\n\t\tif (!(fc->sb_flags & SB_SILENT))\n\t\t\terrorf(fc, \"Can't find a SQUASHFS superblock on %pg\",\n\t\t\t       sb->s_bdev);\n\t\tgoto failed_mount;\n\t}\n\n\tif (opts->thread_num == 0) {\n\t\tmsblk->max_thread_num = msblk->thread_ops->max_decompressors();\n\t} else {\n\t\tmsblk->max_thread_num = opts->thread_num;\n\t}\n\n\t \n\tmsblk->decompressor = supported_squashfs_filesystem(\n\t\t\tfc,\n\t\t\tle16_to_cpu(sblk->s_major),\n\t\t\tle16_to_cpu(sblk->s_minor),\n\t\t\tle16_to_cpu(sblk->compression));\n\tif (msblk->decompressor == NULL)\n\t\tgoto failed_mount;\n\n\t \n\tmsblk->bytes_used = le64_to_cpu(sblk->bytes_used);\n\tif (msblk->bytes_used < 0 ||\n\t    msblk->bytes_used > bdev_nr_bytes(sb->s_bdev))\n\t\tgoto failed_mount;\n\n\t \n\tmsblk->block_size = le32_to_cpu(sblk->block_size);\n\tif (msblk->block_size > SQUASHFS_FILE_MAX_SIZE)\n\t\tgoto insanity;\n\n\t \n\tif (PAGE_SIZE > msblk->block_size) {\n\t\terrorf(fc, \"Page size > filesystem block size (%d).  This is \"\n\t\t       \"currently not supported!\", msblk->block_size);\n\t\tgoto failed_mount;\n\t}\n\n\t \n\tmsblk->block_log = le16_to_cpu(sblk->block_log);\n\tif (msblk->block_log > SQUASHFS_FILE_MAX_LOG)\n\t\tgoto failed_mount;\n\n\t \n\tif (msblk->block_size != (1 << msblk->block_log))\n\t\tgoto insanity;\n\n\t \n\troot_inode = le64_to_cpu(sblk->root_inode);\n\tif (SQUASHFS_INODE_OFFSET(root_inode) > SQUASHFS_METADATA_SIZE)\n\t\tgoto insanity;\n\n\tmsblk->inode_table = le64_to_cpu(sblk->inode_table_start);\n\tmsblk->directory_table = le64_to_cpu(sblk->directory_table_start);\n\tmsblk->inodes = le32_to_cpu(sblk->inodes);\n\tmsblk->fragments = le32_to_cpu(sblk->fragments);\n\tmsblk->ids = le16_to_cpu(sblk->no_ids);\n\tflags = le16_to_cpu(sblk->flags);\n\n\tTRACE(\"Found valid superblock on %pg\\n\", sb->s_bdev);\n\tTRACE(\"Inodes are %scompressed\\n\", SQUASHFS_UNCOMPRESSED_INODES(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Data is %scompressed\\n\", SQUASHFS_UNCOMPRESSED_DATA(flags)\n\t\t\t\t? \"un\" : \"\");\n\tTRACE(\"Filesystem size %lld bytes\\n\", msblk->bytes_used);\n\tTRACE(\"Block size %d\\n\", msblk->block_size);\n\tTRACE(\"Number of inodes %d\\n\", msblk->inodes);\n\tTRACE(\"Number of fragments %d\\n\", msblk->fragments);\n\tTRACE(\"Number of ids %d\\n\", msblk->ids);\n\tTRACE(\"sblk->inode_table_start %llx\\n\", msblk->inode_table);\n\tTRACE(\"sblk->directory_table_start %llx\\n\", msblk->directory_table);\n\tTRACE(\"sblk->fragment_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->fragment_table_start));\n\tTRACE(\"sblk->id_table_start %llx\\n\",\n\t\t(u64) le64_to_cpu(sblk->id_table_start));\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_time_min = 0;\n\tsb->s_time_max = U32_MAX;\n\tsb->s_flags |= SB_RDONLY;\n\tsb->s_op = &squashfs_super_ops;\n\n\terr = -ENOMEM;\n\n\tmsblk->block_cache = squashfs_cache_init(\"metadata\",\n\t\t\tSQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);\n\tif (msblk->block_cache == NULL)\n\t\tgoto failed_mount;\n\n\t \n\tmsblk->read_page = squashfs_cache_init(\"data\",\n\t\tmsblk->max_thread_num, msblk->block_size);\n\tif (msblk->read_page == NULL) {\n\t\terrorf(fc, \"Failed to allocate read_page block\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (msblk->devblksize == PAGE_SIZE) {\n\t\tstruct inode *cache = new_inode(sb);\n\n\t\tif (cache == NULL)\n\t\t\tgoto failed_mount;\n\n\t\tset_nlink(cache, 1);\n\t\tcache->i_size = OFFSET_MAX;\n\t\tmapping_set_gfp_mask(cache->i_mapping, GFP_NOFS);\n\n\t\tmsblk->cache_mapping = cache->i_mapping;\n\t}\n\n\tmsblk->stream = squashfs_decompressor_setup(sb, flags);\n\tif (IS_ERR(msblk->stream)) {\n\t\terr = PTR_ERR(msblk->stream);\n\t\tmsblk->stream = NULL;\n\t\tgoto insanity;\n\t}\n\n\t \n\tsb->s_xattr = squashfs_xattr_handlers;\n\txattr_id_table_start = le64_to_cpu(sblk->xattr_id_table_start);\n\tif (xattr_id_table_start == SQUASHFS_INVALID_BLK) {\n\t\tnext_table = msblk->bytes_used;\n\t\tgoto allocate_id_index_table;\n\t}\n\n\t \n\tmsblk->xattr_id_table = squashfs_read_xattr_id_table(sb,\n\t\txattr_id_table_start, &msblk->xattr_table, &msblk->xattr_ids);\n\tif (IS_ERR(msblk->xattr_id_table)) {\n\t\terrorf(fc, \"unable to read xattr id index table\");\n\t\terr = PTR_ERR(msblk->xattr_id_table);\n\t\tmsblk->xattr_id_table = NULL;\n\t\tif (err != -ENOTSUPP)\n\t\t\tgoto failed_mount;\n\t}\n\tnext_table = msblk->xattr_table;\n\nallocate_id_index_table:\n\t \n\tmsblk->id_table = squashfs_read_id_index_table(sb,\n\t\tle64_to_cpu(sblk->id_table_start), next_table, msblk->ids);\n\tif (IS_ERR(msblk->id_table)) {\n\t\terrorf(fc, \"unable to read id index table\");\n\t\terr = PTR_ERR(msblk->id_table);\n\t\tmsblk->id_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->id_table[0]);\n\n\t \n\tlookup_table_start = le64_to_cpu(sblk->lookup_table_start);\n\tif (lookup_table_start == SQUASHFS_INVALID_BLK)\n\t\tgoto handle_fragments;\n\n\t \n\tmsblk->inode_lookup_table = squashfs_read_inode_lookup_table(sb,\n\t\tlookup_table_start, next_table, msblk->inodes);\n\tif (IS_ERR(msblk->inode_lookup_table)) {\n\t\terrorf(fc, \"unable to read inode lookup table\");\n\t\terr = PTR_ERR(msblk->inode_lookup_table);\n\t\tmsblk->inode_lookup_table = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->inode_lookup_table[0]);\n\n\tsb->s_export_op = &squashfs_export_ops;\n\nhandle_fragments:\n\tfragments = msblk->fragments;\n\tif (fragments == 0)\n\t\tgoto check_directory_table;\n\n\tmsblk->fragment_cache = squashfs_cache_init(\"fragment\",\n\t\tSQUASHFS_CACHED_FRAGMENTS, msblk->block_size);\n\tif (msblk->fragment_cache == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\t \n\tmsblk->fragment_index = squashfs_read_fragment_index_table(sb,\n\t\tle64_to_cpu(sblk->fragment_table_start), next_table, fragments);\n\tif (IS_ERR(msblk->fragment_index)) {\n\t\terrorf(fc, \"unable to read fragment index table\");\n\t\terr = PTR_ERR(msblk->fragment_index);\n\t\tmsblk->fragment_index = NULL;\n\t\tgoto failed_mount;\n\t}\n\tnext_table = le64_to_cpu(msblk->fragment_index[0]);\n\ncheck_directory_table:\n\t \n\tif (msblk->directory_table > next_table) {\n\t\terr = -EINVAL;\n\t\tgoto insanity;\n\t}\n\n\t \n\tif (msblk->inode_table >= msblk->directory_table) {\n\t\terr = -EINVAL;\n\t\tgoto insanity;\n\t}\n\n\t \n\troot = new_inode(sb);\n\tif (!root) {\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\terr = squashfs_read_inode(root, root_inode);\n\tif (err) {\n\t\tmake_bad_inode(root);\n\t\tiput(root);\n\t\tgoto failed_mount;\n\t}\n\tinsert_inode_hash(root);\n\n\tsb->s_root = d_make_root(root);\n\tif (sb->s_root == NULL) {\n\t\tERROR(\"Root inode create failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tTRACE(\"Leaving squashfs_fill_super\\n\");\n\tkfree(sblk);\n\treturn 0;\n\ninsanity:\n\terrorf(fc, \"squashfs image failed sanity check\");\nfailed_mount:\n\tsquashfs_cache_delete(msblk->block_cache);\n\tsquashfs_cache_delete(msblk->fragment_cache);\n\tsquashfs_cache_delete(msblk->read_page);\n\tif (msblk->cache_mapping)\n\t\tiput(msblk->cache_mapping->host);\n\tmsblk->thread_ops->destroy(msblk);\n\tkfree(msblk->inode_lookup_table);\n\tkfree(msblk->fragment_index);\n\tkfree(msblk->id_table);\n\tkfree(msblk->xattr_id_table);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n\tkfree(sblk);\n\treturn err;\n}\n\nstatic int squashfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_bdev(fc, squashfs_fill_super);\n}\n\nstatic int squashfs_reconfigure(struct fs_context *fc)\n{\n\tstruct super_block *sb = fc->root->d_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct squashfs_mount_opts *opts = fc->fs_private;\n\n\tsync_filesystem(fc->root->d_sb);\n\tfc->sb_flags |= SB_RDONLY;\n\n\tmsblk->panic_on_errors = (opts->errors == Opt_errors_panic);\n\n\treturn 0;\n}\n\nstatic void squashfs_free_fs_context(struct fs_context *fc)\n{\n\tkfree(fc->fs_private);\n}\n\nstatic const struct fs_context_operations squashfs_context_ops = {\n\t.get_tree\t= squashfs_get_tree,\n\t.free\t\t= squashfs_free_fs_context,\n\t.parse_param\t= squashfs_parse_param,\n\t.reconfigure\t= squashfs_reconfigure,\n};\n\nstatic int squashfs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\tif (msblk->panic_on_errors)\n\t\tseq_puts(s, \",errors=panic\");\n\telse\n\t\tseq_puts(s, \",errors=continue\");\n\n#ifdef CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT\n\tif (msblk->thread_ops == &squashfs_decompressor_single) {\n\t\tseq_puts(s, \",threads=single\");\n\t\treturn 0;\n\t}\n\tif (msblk->thread_ops == &squashfs_decompressor_percpu) {\n\t\tseq_puts(s, \",threads=percpu\");\n\t\treturn 0;\n\t}\n#endif\n#ifdef CONFIG_SQUASHFS_MOUNT_DECOMP_THREADS\n\tseq_printf(s, \",threads=%d\", msblk->max_thread_num);\n#endif\n\treturn 0;\n}\n\nstatic int squashfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct squashfs_mount_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SQUASHFS_DECOMP_SINGLE\n\topts->thread_ops = &squashfs_decompressor_single;\n#elif defined(CONFIG_SQUASHFS_DECOMP_MULTI)\n\topts->thread_ops = &squashfs_decompressor_multi;\n#elif defined(CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU)\n\topts->thread_ops = &squashfs_decompressor_percpu;\n#else\n#error \"fail: unknown squashfs decompression thread mode?\"\n#endif\n\topts->thread_num = 0;\n\tfc->fs_private = opts;\n\tfc->ops = &squashfs_context_ops;\n\treturn 0;\n}\n\nstatic int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;\n\tu64 id = huge_encode_dev(dentry->d_sb->s_bdev->bd_dev);\n\n\tTRACE(\"Entered squashfs_statfs\\n\");\n\n\tbuf->f_type = SQUASHFS_MAGIC;\n\tbuf->f_bsize = msblk->block_size;\n\tbuf->f_blocks = ((msblk->bytes_used - 1) >> msblk->block_log) + 1;\n\tbuf->f_bfree = buf->f_bavail = 0;\n\tbuf->f_files = msblk->inodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = SQUASHFS_NAME_LEN;\n\tbuf->f_fsid = u64_to_fsid(id);\n\n\treturn 0;\n}\n\n\nstatic void squashfs_put_super(struct super_block *sb)\n{\n\tif (sb->s_fs_info) {\n\t\tstruct squashfs_sb_info *sbi = sb->s_fs_info;\n\t\tsquashfs_cache_delete(sbi->block_cache);\n\t\tsquashfs_cache_delete(sbi->fragment_cache);\n\t\tsquashfs_cache_delete(sbi->read_page);\n\t\tif (sbi->cache_mapping)\n\t\t\tiput(sbi->cache_mapping->host);\n\t\tsbi->thread_ops->destroy(sbi);\n\t\tkfree(sbi->id_table);\n\t\tkfree(sbi->fragment_index);\n\t\tkfree(sbi->meta_index);\n\t\tkfree(sbi->inode_lookup_table);\n\t\tkfree(sbi->xattr_id_table);\n\t\tkfree(sb->s_fs_info);\n\t\tsb->s_fs_info = NULL;\n\t}\n}\n\nstatic struct kmem_cache *squashfs_inode_cachep;\n\n\nstatic void init_once(void *foo)\n{\n\tstruct squashfs_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\n\nstatic int __init init_inodecache(void)\n{\n\tsquashfs_inode_cachep = kmem_cache_create(\"squashfs_inode_cache\",\n\t\tsizeof(struct squashfs_inode_info), 0,\n\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|SLAB_ACCOUNT,\n\t\tinit_once);\n\n\treturn squashfs_inode_cachep ? 0 : -ENOMEM;\n}\n\n\nstatic void destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(squashfs_inode_cachep);\n}\n\n\nstatic int __init init_squashfs_fs(void)\n{\n\tint err = init_inodecache();\n\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&squashfs_fs_type);\n\tif (err) {\n\t\tdestroy_inodecache();\n\t\treturn err;\n\t}\n\n\tpr_info(\"version 4.0 (2009/01/31) Phillip Lougher\\n\");\n\n\treturn 0;\n}\n\n\nstatic void __exit exit_squashfs_fs(void)\n{\n\tunregister_filesystem(&squashfs_fs_type);\n\tdestroy_inodecache();\n}\n\n\nstatic struct inode *squashfs_alloc_inode(struct super_block *sb)\n{\n\tstruct squashfs_inode_info *ei =\n\t\talloc_inode_sb(sb, squashfs_inode_cachep, GFP_KERNEL);\n\n\treturn ei ? &ei->vfs_inode : NULL;\n}\n\n\nstatic void squashfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(squashfs_inode_cachep, squashfs_i(inode));\n}\n\nstatic struct file_system_type squashfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"squashfs\",\n\t.init_fs_context = squashfs_init_fs_context,\n\t.parameters = squashfs_fs_parameters,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV | FS_ALLOW_IDMAP,\n};\nMODULE_ALIAS_FS(\"squashfs\");\n\nstatic const struct super_operations squashfs_super_ops = {\n\t.alloc_inode = squashfs_alloc_inode,\n\t.free_inode = squashfs_free_inode,\n\t.statfs = squashfs_statfs,\n\t.put_super = squashfs_put_super,\n\t.show_options = squashfs_show_options,\n};\n\nmodule_init(init_squashfs_fs);\nmodule_exit(exit_squashfs_fs);\nMODULE_DESCRIPTION(\"squashfs 4.0, a compressed read-only filesystem\");\nMODULE_AUTHOR(\"Phillip Lougher <phillip@squashfs.org.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}