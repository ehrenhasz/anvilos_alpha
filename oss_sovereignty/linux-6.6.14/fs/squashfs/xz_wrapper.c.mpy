{
  "module_name": "xz_wrapper.c",
  "hash_id": "84305063a7a0baf467a1ad6741fb663472be8a675c555a89abc10c28cdfeb322",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/xz_wrapper.c",
  "human_readable_source": "\n \n\n\n#include <linux/mutex.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/xz.h>\n#include <linux/bitops.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\nstruct squashfs_xz {\n\tstruct xz_dec *state;\n\tstruct xz_buf buf;\n};\n\nstruct disk_comp_opts {\n\t__le32 dictionary_size;\n\t__le32 flags;\n};\n\nstruct comp_opts {\n\tint dict_size;\n};\n\nstatic void *squashfs_xz_comp_opts(struct squashfs_sb_info *msblk,\n\tvoid *buff, int len)\n{\n\tstruct disk_comp_opts *comp_opts = buff;\n\tstruct comp_opts *opts;\n\tint err = 0, n;\n\n\topts = kmalloc(sizeof(*opts), GFP_KERNEL);\n\tif (opts == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tif (comp_opts) {\n\t\t \n\t\tif (len < sizeof(*comp_opts)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\topts->dict_size = le32_to_cpu(comp_opts->dictionary_size);\n\n\t\t \n\t\tn = ffs(opts->dict_size) - 1;\n\t\tif (opts->dict_size != (1 << n) && opts->dict_size != (1 << n) +\n\t\t\t\t\t\t(1 << (n + 1))) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\t \n\t\topts->dict_size = max_t(int, msblk->block_size,\n\t\t\t\t\t\t\tSQUASHFS_METADATA_SIZE);\n\n\treturn opts;\n\nout:\n\tkfree(opts);\nout2:\n\treturn ERR_PTR(err);\n}\n\n\nstatic void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff)\n{\n\tstruct comp_opts *comp_opts = buff;\n\tstruct squashfs_xz *stream;\n\tint err;\n\n\tstream = kmalloc(sizeof(*stream), GFP_KERNEL);\n\tif (stream == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tstream->state = xz_dec_init(XZ_PREALLOC, comp_opts->dict_size);\n\tif (stream->state == NULL) {\n\t\tkfree(stream);\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\treturn stream;\n\nfailed:\n\tERROR(\"Failed to initialise xz decompressor\\n\");\n\treturn ERR_PTR(err);\n}\n\n\nstatic void squashfs_xz_free(void *strm)\n{\n\tstruct squashfs_xz *stream = strm;\n\n\tif (stream) {\n\t\txz_dec_end(stream->state);\n\t\tkfree(stream);\n\t}\n}\n\n\nstatic int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void *strm,\n\tstruct bio *bio, int offset, int length,\n\tstruct squashfs_page_actor *output)\n{\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\tint total = 0, error = 0;\n\tstruct squashfs_xz *stream = strm;\n\n\txz_dec_reset(stream->state);\n\tstream->buf.in_pos = 0;\n\tstream->buf.in_size = 0;\n\tstream->buf.out_pos = 0;\n\tstream->buf.out_size = PAGE_SIZE;\n\tstream->buf.out = squashfs_first_page(output);\n\tif (IS_ERR(stream->buf.out)) {\n\t\terror = PTR_ERR(stream->buf.out);\n\t\tgoto finish;\n\t}\n\n\tfor (;;) {\n\t\tenum xz_ret xz_err;\n\n\t\tif (stream->buf.in_pos == stream->buf.in_size) {\n\t\t\tconst void *data;\n\t\t\tint avail;\n\n\t\t\tif (!bio_next_segment(bio, &iter_all)) {\n\t\t\t\t \n\t\t\t\terror = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tavail = min(length, ((int)bvec->bv_len) - offset);\n\t\t\tdata = bvec_virt(bvec);\n\t\t\tlength -= avail;\n\t\t\tstream->buf.in = data + offset;\n\t\t\tstream->buf.in_size = avail;\n\t\t\tstream->buf.in_pos = 0;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (stream->buf.out_pos == stream->buf.out_size) {\n\t\t\tstream->buf.out = squashfs_next_page(output);\n\t\t\tif (IS_ERR(stream->buf.out)) {\n\t\t\t\terror = PTR_ERR(stream->buf.out);\n\t\t\t\tbreak;\n\t\t\t} else if (stream->buf.out != NULL) {\n\t\t\t\tstream->buf.out_pos = 0;\n\t\t\t\ttotal += PAGE_SIZE;\n\t\t\t}\n\t\t}\n\n\t\txz_err = xz_dec_run(stream->state, &stream->buf);\n\t\tif (xz_err == XZ_STREAM_END)\n\t\t\tbreak;\n\t\tif (xz_err != XZ_OK) {\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfinish:\n\tsquashfs_finish_page(output);\n\n\treturn error ? error : total + stream->buf.out_pos;\n}\n\nconst struct squashfs_decompressor squashfs_xz_comp_ops = {\n\t.init = squashfs_xz_init,\n\t.comp_opts = squashfs_xz_comp_opts,\n\t.free = squashfs_xz_free,\n\t.decompress = squashfs_xz_uncompress,\n\t.id = XZ_COMPRESSION,\n\t.name = \"xz\",\n\t.alloc_buffer = 1,\n\t.supported = 1\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}