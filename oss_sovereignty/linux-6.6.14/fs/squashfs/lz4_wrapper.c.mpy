{
  "module_name": "lz4_wrapper.c",
  "hash_id": "58aedbd43b3c897c0fcd99d2c94b38484ec9278c14517fde40a95742ac9fef8b",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/lz4_wrapper.c",
  "human_readable_source": "\n \n\n#include <linux/bio.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/lz4.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\n#define LZ4_LEGACY\t1\n\nstruct lz4_comp_opts {\n\t__le32 version;\n\t__le32 flags;\n};\n\nstruct squashfs_lz4 {\n\tvoid *input;\n\tvoid *output;\n};\n\n\nstatic void *lz4_comp_opts(struct squashfs_sb_info *msblk,\n\tvoid *buff, int len)\n{\n\tstruct lz4_comp_opts *comp_opts = buff;\n\n\t \n\tif (comp_opts == NULL || len < sizeof(*comp_opts))\n\t\treturn ERR_PTR(-EIO);\n\n\tif (le32_to_cpu(comp_opts->version) != LZ4_LEGACY) {\n\t\t \n\t\tERROR(\"Unknown LZ4 version\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn NULL;\n}\n\n\nstatic void *lz4_init(struct squashfs_sb_info *msblk, void *buff)\n{\n\tint block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);\n\tstruct squashfs_lz4 *stream;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (stream == NULL)\n\t\tgoto failed;\n\tstream->input = vmalloc(block_size);\n\tif (stream->input == NULL)\n\t\tgoto failed2;\n\tstream->output = vmalloc(block_size);\n\tif (stream->output == NULL)\n\t\tgoto failed3;\n\n\treturn stream;\n\nfailed3:\n\tvfree(stream->input);\nfailed2:\n\tkfree(stream);\nfailed:\n\tERROR(\"Failed to initialise LZ4 decompressor\\n\");\n\treturn ERR_PTR(-ENOMEM);\n}\n\n\nstatic void lz4_free(void *strm)\n{\n\tstruct squashfs_lz4 *stream = strm;\n\n\tif (stream) {\n\t\tvfree(stream->input);\n\t\tvfree(stream->output);\n\t}\n\tkfree(stream);\n}\n\n\nstatic int lz4_uncompress(struct squashfs_sb_info *msblk, void *strm,\n\tstruct bio *bio, int offset, int length,\n\tstruct squashfs_page_actor *output)\n{\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\tstruct squashfs_lz4 *stream = strm;\n\tvoid *buff = stream->input, *data;\n\tint bytes = length, res;\n\n\twhile (bio_next_segment(bio, &iter_all)) {\n\t\tint avail = min(bytes, ((int)bvec->bv_len) - offset);\n\n\t\tdata = bvec_virt(bvec);\n\t\tmemcpy(buff, data + offset, avail);\n\t\tbuff += avail;\n\t\tbytes -= avail;\n\t\toffset = 0;\n\t}\n\n\tres = LZ4_decompress_safe(stream->input, stream->output,\n\t\tlength, output->length);\n\n\tif (res < 0)\n\t\treturn -EIO;\n\n\tbytes = res;\n\tdata = squashfs_first_page(output);\n\tbuff = stream->output;\n\twhile (data) {\n\t\tif (bytes <= PAGE_SIZE) {\n\t\t\tif (!IS_ERR(data))\n\t\t\t\tmemcpy(data, buff, bytes);\n\t\t\tbreak;\n\t\t}\n\t\tif (!IS_ERR(data))\n\t\t\tmemcpy(data, buff, PAGE_SIZE);\n\t\tbuff += PAGE_SIZE;\n\t\tbytes -= PAGE_SIZE;\n\t\tdata = squashfs_next_page(output);\n\t}\n\tsquashfs_finish_page(output);\n\n\treturn res;\n}\n\nconst struct squashfs_decompressor squashfs_lz4_comp_ops = {\n\t.init = lz4_init,\n\t.comp_opts = lz4_comp_opts,\n\t.free = lz4_free,\n\t.decompress = lz4_uncompress,\n\t.id = LZ4_COMPRESSION,\n\t.name = \"lz4\",\n\t.alloc_buffer = 0,\n\t.supported = 1\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}