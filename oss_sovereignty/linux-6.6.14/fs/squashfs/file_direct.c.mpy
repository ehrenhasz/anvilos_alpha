{
  "module_name": "file_direct.c",
  "hash_id": "1c51bece4d313e8ee6c697b96f328a62df386fc0b8b147d6f7b0c4aac972213c",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/file_direct.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n#include \"page_actor.h\"\n\n \nint squashfs_readpage_block(struct page *target_page, u64 block, int bsize,\n\tint expected)\n\n{\n\tstruct inode *inode = target_page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\n\tint file_end = (i_size_read(inode) - 1) >> PAGE_SHIFT;\n\tint mask = (1 << (msblk->block_log - PAGE_SHIFT)) - 1;\n\tint start_index = target_page->index & ~mask;\n\tint end_index = start_index | mask;\n\tint i, n, pages, bytes, res = -ENOMEM;\n\tstruct page **page;\n\tstruct squashfs_page_actor *actor;\n\tvoid *pageaddr;\n\n\tif (end_index > file_end)\n\t\tend_index = file_end;\n\n\tpages = end_index - start_index + 1;\n\n\tpage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn res;\n\n\t \n\tfor (i = 0, n = start_index; n <= end_index; n++) {\n\t\tpage[i] = (n == target_page->index) ? target_page :\n\t\t\tgrab_cache_page_nowait(target_page->mapping, n);\n\n\t\tif (page[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(page[i])) {\n\t\t\tunlock_page(page[i]);\n\t\t\tput_page(page[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tpages = i;\n\n\t \n\tactor = squashfs_page_actor_init_special(msblk, page, pages, expected);\n\tif (actor == NULL)\n\t\tgoto out;\n\n\t \n\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\n\tsquashfs_page_actor_free(actor);\n\n\tif (res < 0)\n\t\tgoto mark_errored;\n\n\tif (res != expected) {\n\t\tres = -EIO;\n\t\tgoto mark_errored;\n\t}\n\n\t \n\tbytes = res % PAGE_SIZE;\n\tif (page[pages - 1]->index == end_index && bytes) {\n\t\tpageaddr = kmap_local_page(page[pages - 1]);\n\t\tmemset(pageaddr + bytes, 0, PAGE_SIZE - bytes);\n\t\tkunmap_local(pageaddr);\n\t}\n\n\t \n\tfor (i = 0; i < pages; i++) {\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageUptodate(page[i]);\n\t\tunlock_page(page[i]);\n\t\tif (page[i] != target_page)\n\t\t\tput_page(page[i]);\n\t}\n\n\tkfree(page);\n\n\treturn 0;\n\nmark_errored:\n\t \n\tfor (i = 0; i < pages; i++) {\n\t\tif (page[i] == NULL || page[i] == target_page)\n\t\t\tcontinue;\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageError(page[i]);\n\t\tunlock_page(page[i]);\n\t\tput_page(page[i]);\n\t}\n\nout:\n\tkfree(page);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}