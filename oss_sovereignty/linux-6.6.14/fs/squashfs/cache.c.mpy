{
  "module_name": "cache.c",
  "hash_id": "204d1d4c55a5b99e1be6fdbf324c896ad1150acad4a0d8d49a57bf25eaa92dbd",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/cache.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"page_actor.h\"\n\n \nstruct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,\n\tstruct squashfs_cache *cache, u64 block, int length)\n{\n\tint i, n;\n\tstruct squashfs_cache_entry *entry;\n\n\tspin_lock(&cache->lock);\n\n\twhile (1) {\n\t\tfor (i = cache->curr_blk, n = 0; n < cache->entries; n++) {\n\t\t\tif (cache->entry[i].block == block) {\n\t\t\t\tcache->curr_blk = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = (i + 1) % cache->entries;\n\t\t}\n\n\t\tif (n == cache->entries) {\n\t\t\t \n\t\t\tif (cache->unused == 0) {\n\t\t\t\tcache->num_waiters++;\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twait_event(cache->wait_queue, cache->unused);\n\t\t\t\tspin_lock(&cache->lock);\n\t\t\t\tcache->num_waiters--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\ti = cache->next_blk;\n\t\t\tfor (n = 0; n < cache->entries; n++) {\n\t\t\t\tif (cache->entry[i].refcount == 0)\n\t\t\t\t\tbreak;\n\t\t\t\ti = (i + 1) % cache->entries;\n\t\t\t}\n\n\t\t\tcache->next_blk = (i + 1) % cache->entries;\n\t\t\tentry = &cache->entry[i];\n\n\t\t\t \n\t\t\tcache->unused--;\n\t\t\tentry->block = block;\n\t\t\tentry->refcount = 1;\n\t\t\tentry->pending = 1;\n\t\t\tentry->num_waiters = 0;\n\t\t\tentry->error = 0;\n\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tentry->length = squashfs_read_data(sb, block, length,\n\t\t\t\t&entry->next_index, entry->actor);\n\n\t\t\tspin_lock(&cache->lock);\n\n\t\t\tif (entry->length < 0)\n\t\t\t\tentry->error = entry->length;\n\n\t\t\tentry->pending = 0;\n\n\t\t\t \n\t\t\tif (entry->num_waiters) {\n\t\t\t\tspin_unlock(&cache->lock);\n\t\t\t\twake_up_all(&entry->wait_queue);\n\t\t\t} else\n\t\t\t\tspin_unlock(&cache->lock);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tentry = &cache->entry[i];\n\t\tif (entry->refcount == 0)\n\t\t\tcache->unused--;\n\t\tentry->refcount++;\n\n\t\t \n\t\tif (entry->pending) {\n\t\t\tentry->num_waiters++;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twait_event(entry->wait_queue, !entry->pending);\n\t\t} else\n\t\t\tspin_unlock(&cache->lock);\n\n\t\tgoto out;\n\t}\n\nout:\n\tTRACE(\"Got %s %d, start block %lld, refcount %d, error %d\\n\",\n\t\tcache->name, i, entry->block, entry->refcount, entry->error);\n\n\tif (entry->error)\n\t\tERROR(\"Unable to read %s cache entry [%llx]\\n\", cache->name,\n\t\t\t\t\t\t\tblock);\n\treturn entry;\n}\n\n\n \nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t \n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}\n\n \nvoid squashfs_cache_delete(struct squashfs_cache *cache)\n{\n\tint i, j;\n\n\tif (cache == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < cache->entries; i++) {\n\t\tif (cache->entry[i].data) {\n\t\t\tfor (j = 0; j < cache->pages; j++)\n\t\t\t\tkfree(cache->entry[i].data[j]);\n\t\t\tkfree(cache->entry[i].data);\n\t\t}\n\t\tkfree(cache->entry[i].actor);\n\t}\n\n\tkfree(cache->entry);\n\tkfree(cache);\n}\n\n\n \nstruct squashfs_cache *squashfs_cache_init(char *name, int entries,\n\tint block_size)\n{\n\tint i, j;\n\tstruct squashfs_cache *cache = kzalloc(sizeof(*cache), GFP_KERNEL);\n\n\tif (cache == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\treturn NULL;\n\t}\n\n\tcache->entry = kcalloc(entries, sizeof(*(cache->entry)), GFP_KERNEL);\n\tif (cache->entry == NULL) {\n\t\tERROR(\"Failed to allocate %s cache\\n\", name);\n\t\tgoto cleanup;\n\t}\n\n\tcache->curr_blk = 0;\n\tcache->next_blk = 0;\n\tcache->unused = entries;\n\tcache->entries = entries;\n\tcache->block_size = block_size;\n\tcache->pages = block_size >> PAGE_SHIFT;\n\tcache->pages = cache->pages ? cache->pages : 1;\n\tcache->name = name;\n\tcache->num_waiters = 0;\n\tspin_lock_init(&cache->lock);\n\tinit_waitqueue_head(&cache->wait_queue);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct squashfs_cache_entry *entry = &cache->entry[i];\n\n\t\tinit_waitqueue_head(&cache->entry[i].wait_queue);\n\t\tentry->cache = cache;\n\t\tentry->block = SQUASHFS_INVALID_BLK;\n\t\tentry->data = kcalloc(cache->pages, sizeof(void *), GFP_KERNEL);\n\t\tif (entry->data == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tfor (j = 0; j < cache->pages; j++) {\n\t\t\tentry->data[j] = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\t\tif (entry->data[j] == NULL) {\n\t\t\t\tERROR(\"Failed to allocate %s buffer\\n\", name);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tentry->actor = squashfs_page_actor_init(entry->data,\n\t\t\t\t\t\tcache->pages, 0);\n\t\tif (entry->actor == NULL) {\n\t\t\tERROR(\"Failed to allocate %s cache entry\\n\", name);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\treturn cache;\n\ncleanup:\n\tsquashfs_cache_delete(cache);\n\treturn NULL;\n}\n\n\n \nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_SIZE]\n\t\t\t\t+ (offset % PAGE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_SIZE - (offset % PAGE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}\n\n\n \nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\tif (unlikely(length < 0))\n\t\treturn -EIO;\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}\n\n\n \nstruct squashfs_cache_entry *squashfs_get_fragment(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->fragment_cache, start_block,\n\t\tlength);\n}\n\n\n \nstruct squashfs_cache_entry *squashfs_get_datablock(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->read_page, start_block, length);\n}\n\n\n \nvoid *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}