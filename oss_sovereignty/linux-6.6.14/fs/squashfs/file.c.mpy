{
  "module_name": "file.c",
  "hash_id": "d8d00b108596a2b3b1eaaa7548752429af73ffc152c1cb8af5dbc8183c1aa21d",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/file.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n#include \"page_actor.h\"\n\n \nstatic struct meta_index *locate_meta_index(struct inode *inode, int offset,\n\t\t\t\tint index)\n{\n\tstruct meta_index *meta = NULL;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"locate_meta_index: index %d, offset %d\\n\", index, offset);\n\n\tif (msblk->meta_index == NULL)\n\t\tgoto not_allocated;\n\n\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n\t\t\t\tmsblk->meta_index[i].offset <= index &&\n\t\t\t\tmsblk->meta_index[i].locked == 0) {\n\t\t\tTRACE(\"locate_meta_index: entry %d, offset %d\\n\", i,\n\t\t\t\t\tmsblk->meta_index[i].offset);\n\t\t\tmeta = &msblk->meta_index[i];\n\t\t\toffset = meta->offset;\n\t\t}\n\t}\n\n\tif (meta)\n\t\tmeta->locked = 1;\n\nnot_allocated:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\n\treturn meta;\n}\n\n\n \nstatic struct meta_index *empty_meta_index(struct inode *inode, int offset,\n\t\t\t\tint skip)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct meta_index *meta = NULL;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"empty_meta_index: offset %d, skip %d\\n\", offset, skip);\n\n\tif (msblk->meta_index == NULL) {\n\t\t \n\t\tmsblk->meta_index = kcalloc(SQUASHFS_META_SLOTS,\n\t\t\tsizeof(*(msblk->meta_index)), GFP_KERNEL);\n\t\tif (msblk->meta_index == NULL) {\n\t\t\tERROR(\"Failed to allocate meta_index\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\t\tmsblk->meta_index[i].inode_number = 0;\n\t\t\tmsblk->meta_index[i].locked = 0;\n\t\t}\n\t\tmsblk->next_meta_index = 0;\n\t}\n\n\tfor (i = SQUASHFS_META_SLOTS; i &&\n\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i--)\n\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tif (i == 0) {\n\t\tTRACE(\"empty_meta_index: failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tTRACE(\"empty_meta_index: returned meta entry %d, %p\\n\",\n\t\t\tmsblk->next_meta_index,\n\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n\n\tmeta = &msblk->meta_index[msblk->next_meta_index];\n\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tmeta->inode_number = inode->i_ino;\n\tmeta->offset = offset;\n\tmeta->skip = skip;\n\tmeta->entries = 0;\n\tmeta->locked = 1;\n\nfailed:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\treturn meta;\n}\n\n\nstatic void release_meta_index(struct inode *inode, struct meta_index *meta)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tmutex_lock(&msblk->meta_index_mutex);\n\tmeta->locked = 0;\n\tmutex_unlock(&msblk->meta_index_mutex);\n}\n\n\n \nstatic long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = squashfs_block_size(blist[i]);\n\t\t\tif (size < 0) {\n\t\t\t\terr = size;\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}\n\n\n \nstatic inline int calculate_skip(u64 blocks)\n{\n\tu64 skip = blocks / ((SQUASHFS_META_ENTRIES + 1)\n\t\t * SQUASHFS_META_INDEXES);\n\treturn min((u64) SQUASHFS_CACHED_BLKS - 1, skip + 1);\n}\n\n\n \nstatic int fill_meta_index(struct inode *inode, int index,\n\t\tu64 *index_block, int *index_offset, u64 *data_block)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint skip = calculate_skip(i_size_read(inode) >> msblk->block_log);\n\tint offset = 0;\n\tstruct meta_index *meta;\n\tstruct meta_entry *meta_entry;\n\tu64 cur_index_block = squashfs_i(inode)->block_list_start;\n\tint cur_offset = squashfs_i(inode)->offset;\n\tu64 cur_data_block = squashfs_i(inode)->start;\n\tint err, i;\n\n\t \n\tindex /= SQUASHFS_META_INDEXES * skip;\n\n\twhile (offset < index) {\n\t\tmeta = locate_meta_index(inode, offset + 1, index);\n\n\t\tif (meta == NULL) {\n\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n\t\t\tif (meta == NULL)\n\t\t\t\tgoto all_done;\n\t\t} else {\n\t\t\toffset = index < meta->offset + meta->entries ? index :\n\t\t\t\tmeta->offset + meta->entries - 1;\n\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n\t\t\tcur_index_block = meta_entry->index_block +\n\t\t\t\tmsblk->inode_table;\n\t\t\tcur_offset = meta_entry->offset;\n\t\t\tcur_data_block = meta_entry->data_block;\n\t\t\tTRACE(\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\", offset, meta->offset,\n\t\t\t\tmeta->entries);\n\t\t\tTRACE(\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\", cur_index_block,\n\t\t\t\tcur_offset, cur_data_block);\n\t\t}\n\n\t\t \n\t\tfor (i = meta->offset + meta->entries; i <= index &&\n\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n\t\t\tlong long res = read_indexes(inode->i_sb, blocks,\n\t\t\t\t\t&cur_index_block, &cur_offset);\n\n\t\t\tif (res < 0) {\n\t\t\t\tif (meta->entries == 0)\n\t\t\t\t\t \n\t\t\t\t\tmeta->inode_number = 0;\n\t\t\t\terr = res;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tcur_data_block += res;\n\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n\t\t\tmeta_entry->index_block = cur_index_block -\n\t\t\t\tmsblk->inode_table;\n\t\t\tmeta_entry->offset = cur_offset;\n\t\t\tmeta_entry->data_block = cur_data_block;\n\t\t\tmeta->entries++;\n\t\t\toffset++;\n\t\t}\n\n\t\tTRACE(\"get_meta_index: meta->offset %d, meta->entries %d\\n\",\n\t\t\t\tmeta->offset, meta->entries);\n\n\t\trelease_meta_index(inode, meta);\n\t}\n\nall_done:\n\t*index_block = cur_index_block;\n\t*index_offset = cur_offset;\n\t*data_block = cur_data_block;\n\n\t \n\treturn offset * SQUASHFS_META_INDEXES * skip;\n\nfailed:\n\trelease_meta_index(inode, meta);\n\treturn err;\n}\n\n\n \nstatic int read_blocklist(struct inode *inode, int index, u64 *block)\n{\n\tu64 start;\n\tlong long blks;\n\tint offset;\n\t__le32 size;\n\tint res = fill_meta_index(inode, index, &start, &offset, block);\n\n\tTRACE(\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\", res, index, start, offset,\n\t\t\t*block);\n\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\tif (res < index) {\n\t\tblks = read_indexes(inode->i_sb, index - res, &start, &offset);\n\t\tif (blks < 0)\n\t\t\treturn (int) blks;\n\t\t*block += blks;\n\t}\n\n\t \n\tres = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,\n\t\t\tsizeof(size));\n\tif (res < 0)\n\t\treturn res;\n\treturn squashfs_block_size(size);\n}\n\nvoid squashfs_fill_page(struct page *page, struct squashfs_cache_entry *buffer, int offset, int avail)\n{\n\tint copied;\n\tvoid *pageaddr;\n\n\tpageaddr = kmap_atomic(page);\n\tcopied = squashfs_copy_data(pageaddr, buffer, offset, avail);\n\tmemset(pageaddr + copied, 0, PAGE_SIZE - copied);\n\tkunmap_atomic(pageaddr);\n\n\tflush_dcache_page(page);\n\tif (copied == avail)\n\t\tSetPageUptodate(page);\n\telse\n\t\tSetPageError(page);\n}\n\n \nvoid squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i, mask = (1 << (msblk->block_log - PAGE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t \n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_SIZE, offset += PAGE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tsquashfs_fill_page(push_page, buffer, offset, avail);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tput_page(push_page);\n\t}\n}\n\n \nstatic int squashfs_readpage_fragment(struct page *page, int expected)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\",\n\t\t\tsquashfs_i(inode)->fragment_block,\n\t\t\tsquashfs_i(inode)->fragment_size);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, expected,\n\t\t\tsquashfs_i(inode)->fragment_offset);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}\n\nstatic int squashfs_readpage_sparse(struct page *page, int expected)\n{\n\tsquashfs_copy_cache(page, NULL, expected, 0);\n\treturn 0;\n}\n\nstatic int squashfs_read_folio(struct file *file, struct folio *folio)\n{\n\tstruct page *page = &folio->page;\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint index = page->index >> (msblk->block_log - PAGE_SHIFT);\n\tint file_end = i_size_read(inode) >> msblk->block_log;\n\tint expected = index == file_end ?\n\t\t\t(i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t msblk->block_size;\n\tint res = 0;\n\tvoid *pageaddr;\n\n\tTRACE(\"Entered squashfs_readpage, page index %lx, start block %llx\\n\",\n\t\t\t\tpage->index, squashfs_i(inode)->start);\n\n\tif (page->index >= ((i_size_read(inode) + PAGE_SIZE - 1) >>\n\t\t\t\t\tPAGE_SHIFT))\n\t\tgoto out;\n\n\tif (index < file_end || squashfs_i(inode)->fragment_block ==\n\t\t\t\t\tSQUASHFS_INVALID_BLK) {\n\t\tu64 block = 0;\n\n\t\tres = read_blocklist(inode, index, &block);\n\t\tif (res < 0)\n\t\t\tgoto error_out;\n\n\t\tif (res == 0)\n\t\t\tres = squashfs_readpage_sparse(page, expected);\n\t\telse\n\t\t\tres = squashfs_readpage_block(page, block, res, expected);\n\t} else\n\t\tres = squashfs_readpage_fragment(page, expected);\n\n\tif (!res)\n\t\treturn 0;\n\nerror_out:\n\tSetPageError(page);\nout:\n\tpageaddr = kmap_atomic(page);\n\tmemset(pageaddr, 0, PAGE_SIZE);\n\tkunmap_atomic(pageaddr);\n\tflush_dcache_page(page);\n\tif (res == 0)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\n\treturn res;\n}\n\nstatic int squashfs_readahead_fragment(struct page **page,\n\tunsigned int pages, unsigned int expected)\n{\n\tstruct inode *inode = page[0]->mapping->host;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tunsigned int n, mask = (1 << (msblk->block_log - PAGE_SHIFT)) - 1;\n\tint error = buffer->error;\n\n\tif (error)\n\t\tgoto out;\n\n\texpected += squashfs_i(inode)->fragment_offset;\n\n\tfor (n = 0; n < pages; n++) {\n\t\tunsigned int base = (page[n]->index & mask) << PAGE_SHIFT;\n\t\tunsigned int offset = base + squashfs_i(inode)->fragment_offset;\n\n\t\tif (expected > offset) {\n\t\t\tunsigned int avail = min_t(unsigned int, expected -\n\t\t\t\toffset, PAGE_SIZE);\n\n\t\t\tsquashfs_fill_page(page[n], buffer, offset, avail);\n\t\t}\n\n\t\tunlock_page(page[n]);\n\t\tput_page(page[n]);\n\t}\n\nout:\n\tsquashfs_cache_put(buffer);\n\treturn error;\n}\n\nstatic void squashfs_readahead(struct readahead_control *ractl)\n{\n\tstruct inode *inode = ractl->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tsize_t mask = (1UL << msblk->block_log) - 1;\n\tunsigned short shift = msblk->block_log - PAGE_SHIFT;\n\tloff_t start = readahead_pos(ractl) & ~mask;\n\tsize_t len = readahead_length(ractl) + readahead_pos(ractl) - start;\n\tstruct squashfs_page_actor *actor;\n\tunsigned int nr_pages = 0;\n\tstruct page **pages;\n\tint i, file_end = i_size_read(inode) >> msblk->block_log;\n\tunsigned int max_pages = 1UL << shift;\n\n\treadahead_expand(ractl, start, (len | mask) + 1);\n\n\tpages = kmalloc_array(max_pages, sizeof(void *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn;\n\n\tfor (;;) {\n\t\tpgoff_t index;\n\t\tint res, bsize;\n\t\tu64 block = 0;\n\t\tunsigned int expected;\n\t\tstruct page *last_page;\n\n\t\texpected = start >> msblk->block_log == file_end ?\n\t\t\t   (i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t    msblk->block_size;\n\n\t\tmax_pages = (expected + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tnr_pages = __readahead_batch(ractl, pages, max_pages);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tif (readahead_pos(ractl) >= i_size_read(inode))\n\t\t\tgoto skip_pages;\n\n\t\tindex = pages[0]->index >> shift;\n\n\t\tif ((pages[nr_pages - 1]->index >> shift) != index)\n\t\t\tgoto skip_pages;\n\n\t\tif (index == file_end && squashfs_i(inode)->fragment_block !=\n\t\t\t\t\t\tSQUASHFS_INVALID_BLK) {\n\t\t\tres = squashfs_readahead_fragment(pages, nr_pages,\n\t\t\t\t\t\t\t  expected);\n\t\t\tif (res)\n\t\t\t\tgoto skip_pages;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbsize = read_blocklist(inode, index, &block);\n\t\tif (bsize == 0)\n\t\t\tgoto skip_pages;\n\n\t\tactor = squashfs_page_actor_init_special(msblk, pages, nr_pages,\n\t\t\t\t\t\t\t expected);\n\t\tif (!actor)\n\t\t\tgoto skip_pages;\n\n\t\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\n\t\tlast_page = squashfs_page_actor_free(actor);\n\n\t\tif (res == expected) {\n\t\t\tint bytes;\n\n\t\t\t \n\t\t\tbytes = res % PAGE_SIZE;\n\t\t\tif (index == file_end && bytes && last_page)\n\t\t\t\tmemzero_page(last_page, bytes,\n\t\t\t\t\t     PAGE_SIZE - bytes);\n\n\t\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\t\tflush_dcache_page(pages[i]);\n\t\t\t\tSetPageUptodate(pages[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n\n\tkfree(pages);\n\treturn;\n\nskip_pages:\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunlock_page(pages[i]);\n\t\tput_page(pages[i]);\n\t}\n\tkfree(pages);\n}\n\nconst struct address_space_operations squashfs_aops = {\n\t.read_folio = squashfs_read_folio,\n\t.readahead = squashfs_readahead\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}