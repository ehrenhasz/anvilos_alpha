{
  "module_name": "xattr.c",
  "hash_id": "30e1cc6346cab64888bd58ee7c7ba63e05a3a49e53ec71ffa1c3cda071c7bc72",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int);\n\nssize_t squashfs_listxattr(struct dentry *d, char *buffer,\n\tsize_t buffer_size)\n{\n\tstruct inode *inode = d_inode(d);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tsize_t rest = buffer_size;\n\tint err;\n\n\t \n\tif (msblk->xattr_id_table == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\twhile (count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tconst struct xattr_handler *handler;\n\t\tint name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\thandler = squashfs_xattr_handler(le16_to_cpu(entry.type));\n\t\tif (handler && (!handler->list || handler->list(d))) {\n\t\t\tconst char *prefix = handler->prefix ?: handler->name;\n\t\t\tsize_t prefix_size = strlen(prefix);\n\n\t\t\tif (buffer) {\n\t\t\t\tif (prefix_size + name_size + 1 > rest) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tmemcpy(buffer, prefix, prefix_size);\n\t\t\t\tbuffer += prefix_size;\n\t\t\t}\n\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t\tif (buffer) {\n\t\t\t\tbuffer[name_size] = '\\0';\n\t\t\t\tbuffer += name_size + 1;\n\t\t\t}\n\t\t\trest -= prefix_size + name_size + 1;\n\t\t} else  {\n\t\t\t \n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t&offset, name_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\n\n\t\t \n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = buffer_size - rest;\n\nfailed:\n\treturn err;\n}\n\n\nstatic int squashfs_xattr_get(struct inode *inode, int name_index,\n\tconst char *name, void *buffer, size_t buffer_size)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)\n\t\t\t\t\t\t + msblk->xattr_table;\n\tint offset = SQUASHFS_XATTR_OFFSET(squashfs_i(inode)->xattr);\n\tint count = squashfs_i(inode)->xattr_count;\n\tint name_len = strlen(name);\n\tint err, vsize;\n\tchar *target = kmalloc(name_len, GFP_KERNEL);\n\n\tif (target == NULL)\n\t\treturn  -ENOMEM;\n\n\t \n\tfor (; count; count--) {\n\t\tstruct squashfs_xattr_entry entry;\n\t\tstruct squashfs_xattr_val val;\n\t\tint type, prefix, name_size;\n\n\t\terr = squashfs_read_metadata(sb, &entry, &start, &offset,\n\t\t\t\t\t\t\tsizeof(entry));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tname_size = le16_to_cpu(entry.size);\n\t\ttype = le16_to_cpu(entry.type);\n\t\tprefix = type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif (prefix == name_index && name_size == name_len)\n\t\t\terr = squashfs_read_metadata(sb, target, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\telse\n\t\t\terr = squashfs_read_metadata(sb, NULL, &start,\n\t\t\t\t\t\t&offset, name_size);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\n\t\tif (prefix == name_index && name_size == name_len &&\n\t\t\t\t\tstrncmp(target, name, name_size) == 0) {\n\t\t\t \n\t\t\tif (type & SQUASHFS_XATTR_VALUE_OOL) {\n\t\t\t\t__le64 xattr_val;\n\t\t\t\tu64 xattr;\n\t\t\t\t \n\t\t\t\terr = squashfs_read_metadata(sb, &val, &start,\n\t\t\t\t\t\t&offset, sizeof(val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\terr = squashfs_read_metadata(sb, &xattr_val,\n\t\t\t\t\t&start, &offset, sizeof(xattr_val));\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t\txattr = le64_to_cpu(xattr_val);\n\t\t\t\tstart = SQUASHFS_XATTR_BLK(xattr) +\n\t\t\t\t\t\t\tmsblk->xattr_table;\n\t\t\t\toffset = SQUASHFS_XATTR_OFFSET(xattr);\n\t\t\t}\n\t\t\t \n\t\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed;\n\n\t\t\tvsize = le32_to_cpu(val.vsize);\n\t\t\tif (buffer) {\n\t\t\t\tif (vsize > buffer_size) {\n\t\t\t\t\terr = -ERANGE;\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\terr = squashfs_read_metadata(sb, buffer, &start,\n\t\t\t\t\t &offset, vsize);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = squashfs_read_metadata(sb, &val, &start, &offset,\n\t\t\t\t\t\t\tsizeof(val));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t\terr = squashfs_read_metadata(sb, NULL, &start, &offset,\n\t\t\t\t\t\tle32_to_cpu(val.vsize));\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\terr = count ? vsize : -ENODATA;\n\nfailed:\n\tkfree(target);\n\treturn err;\n}\n\n\nstatic int squashfs_xattr_handler_get(const struct xattr_handler *handler,\n\t\t\t\t      struct dentry *unused,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      const char *name,\n\t\t\t\t      void *buffer, size_t size)\n{\n\treturn squashfs_xattr_get(inode, handler->flags, name,\n\t\tbuffer, size);\n}\n\n \nstatic const struct xattr_handler squashfs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= SQUASHFS_XATTR_USER,\n\t.get\t= squashfs_xattr_handler_get\n};\n\n \nstatic bool squashfs_trusted_xattr_handler_list(struct dentry *d)\n{\n\treturn capable(CAP_SYS_ADMIN);\n}\n\nstatic const struct xattr_handler squashfs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= SQUASHFS_XATTR_TRUSTED,\n\t.list\t= squashfs_trusted_xattr_handler_list,\n\t.get\t= squashfs_xattr_handler_get\n};\n\n \nstatic const struct xattr_handler squashfs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= SQUASHFS_XATTR_SECURITY,\n\t.get\t= squashfs_xattr_handler_get\n};\n\nstatic const struct xattr_handler *squashfs_xattr_handler(int type)\n{\n\tif (type & ~(SQUASHFS_XATTR_PREFIX_MASK | SQUASHFS_XATTR_VALUE_OOL))\n\t\t \n\t\treturn NULL;\n\n\tswitch (type & SQUASHFS_XATTR_PREFIX_MASK) {\n\tcase SQUASHFS_XATTR_USER:\n\t\treturn &squashfs_xattr_user_handler;\n\tcase SQUASHFS_XATTR_TRUSTED:\n\t\treturn &squashfs_xattr_trusted_handler;\n\tcase SQUASHFS_XATTR_SECURITY:\n\t\treturn &squashfs_xattr_security_handler;\n\tdefault:\n\t\t \n\t\treturn NULL;\n\t}\n}\n\nconst struct xattr_handler *squashfs_xattr_handlers[] = {\n\t&squashfs_xattr_user_handler,\n\t&squashfs_xattr_trusted_handler,\n\t&squashfs_xattr_security_handler,\n\tNULL\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}