{
  "module_name": "block.c",
  "hash_id": "b467a66b10e52d60d4d54b2ead1f6bffbf47765080e8ebf26c1ded3815f8b9a5",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/block.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/bio.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\n \nstatic int copy_bio_to_actor(struct bio *bio,\n\t\t\t     struct squashfs_page_actor *actor,\n\t\t\t     int offset, int req_length)\n{\n\tvoid *actor_addr;\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\tint copied_bytes = 0;\n\tint actor_offset = 0;\n\n\tsquashfs_actor_nobuff(actor);\n\tactor_addr = squashfs_first_page(actor);\n\n\tif (WARN_ON_ONCE(!bio_next_segment(bio, &iter_all)))\n\t\treturn 0;\n\n\twhile (copied_bytes < req_length) {\n\t\tint bytes_to_copy = min_t(int, bvec->bv_len - offset,\n\t\t\t\t\t  PAGE_SIZE - actor_offset);\n\n\t\tbytes_to_copy = min_t(int, bytes_to_copy,\n\t\t\t\t      req_length - copied_bytes);\n\t\tif (!IS_ERR(actor_addr))\n\t\t\tmemcpy(actor_addr + actor_offset, bvec_virt(bvec) +\n\t\t\t\t\toffset, bytes_to_copy);\n\n\t\tactor_offset += bytes_to_copy;\n\t\tcopied_bytes += bytes_to_copy;\n\t\toffset += bytes_to_copy;\n\n\t\tif (actor_offset >= PAGE_SIZE) {\n\t\t\tactor_addr = squashfs_next_page(actor);\n\t\t\tif (!actor_addr)\n\t\t\t\tbreak;\n\t\t\tactor_offset = 0;\n\t\t}\n\t\tif (offset >= bvec->bv_len) {\n\t\t\tif (!bio_next_segment(bio, &iter_all))\n\t\t\t\tbreak;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tsquashfs_finish_page(actor);\n\treturn copied_bytes;\n}\n\nstatic int squashfs_bio_read_cached(struct bio *fullbio,\n\t\tstruct address_space *cache_mapping, u64 index, int length,\n\t\tu64 read_start, u64 read_end, int page_count)\n{\n\tstruct page *head_to_cache = NULL, *tail_to_cache = NULL;\n\tstruct block_device *bdev = fullbio->bi_bdev;\n\tint start_idx = 0, end_idx = 0;\n\tstruct bvec_iter_all iter_all;\n\tstruct bio *bio = NULL;\n\tstruct bio_vec *bv;\n\tint idx = 0;\n\tint err = 0;\n\n\tbio_for_each_segment_all(bv, fullbio, iter_all) {\n\t\tstruct page *page = bv->bv_page;\n\n\t\tif (page->mapping == cache_mapping) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (idx == 0 && index != read_start)\n\t\t\thead_to_cache = page;\n\t\telse if (idx == page_count - 1 && index + length != read_end)\n\t\t\ttail_to_cache = page;\n\n\t\tif (!bio || idx != end_idx) {\n\t\t\tstruct bio *new = bio_alloc_clone(bdev, fullbio,\n\t\t\t\t\t\t\t  GFP_NOIO, &fs_bio_set);\n\n\t\t\tif (bio) {\n\t\t\t\tbio_trim(bio, start_idx * PAGE_SECTORS,\n\t\t\t\t\t (end_idx - start_idx) * PAGE_SECTORS);\n\t\t\t\tbio_chain(bio, new);\n\t\t\t\tsubmit_bio(bio);\n\t\t\t}\n\n\t\t\tbio = new;\n\t\t\tstart_idx = idx;\n\t\t}\n\n\t\tidx++;\n\t\tend_idx = idx;\n\t}\n\n\tif (bio) {\n\t\tbio_trim(bio, start_idx * PAGE_SECTORS,\n\t\t\t (end_idx - start_idx) * PAGE_SECTORS);\n\t\terr = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tif (head_to_cache) {\n\t\tint ret = add_to_page_cache_lru(head_to_cache, cache_mapping,\n\t\t\t\t\t\tread_start >> PAGE_SHIFT,\n\t\t\t\t\t\tGFP_NOIO);\n\n\t\tif (!ret) {\n\t\t\tSetPageUptodate(head_to_cache);\n\t\t\tunlock_page(head_to_cache);\n\t\t}\n\n\t}\n\n\tif (tail_to_cache) {\n\t\tint ret = add_to_page_cache_lru(tail_to_cache, cache_mapping,\n\t\t\t\t\t\t(read_end >> PAGE_SHIFT) - 1,\n\t\t\t\t\t\tGFP_NOIO);\n\n\t\tif (!ret) {\n\t\t\tSetPageUptodate(tail_to_cache);\n\t\t\tunlock_page(tail_to_cache);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct page *squashfs_get_cache_page(struct address_space *mapping,\n\t\t\t\t\t    pgoff_t index)\n{\n\tstruct page *page;\n\n\tif (!mapping)\n\t\treturn NULL;\n\n\tpage = find_get_page(mapping, index);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}\n\nstatic int squashfs_bio_read(struct super_block *sb, u64 index, int length,\n\t\t\t     struct bio **biop, int *block_offset)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct address_space *cache_mapping = msblk->cache_mapping;\n\tconst u64 read_start = round_down(index, msblk->devblksize);\n\tconst sector_t block = read_start >> msblk->devblksize_log2;\n\tconst u64 read_end = round_up(index + length, msblk->devblksize);\n\tconst sector_t block_end = read_end >> msblk->devblksize_log2;\n\tint offset = read_start - round_down(index, PAGE_SIZE);\n\tint total_len = (block_end - block) << msblk->devblksize_log2;\n\tconst int page_count = DIV_ROUND_UP(total_len + offset, PAGE_SIZE);\n\tint error, i;\n\tstruct bio *bio;\n\n\tbio = bio_kmalloc(page_count, GFP_NOIO);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\tbio_init(bio, sb->s_bdev, bio->bi_inline_vecs, page_count, REQ_OP_READ);\n\tbio->bi_iter.bi_sector = block * (msblk->devblksize >> SECTOR_SHIFT);\n\n\tfor (i = 0; i < page_count; ++i) {\n\t\tunsigned int len =\n\t\t\tmin_t(unsigned int, PAGE_SIZE - offset, total_len);\n\t\tpgoff_t index = (read_start >> PAGE_SHIFT) + i;\n\t\tstruct page *page;\n\n\t\tpage = squashfs_get_cache_page(cache_mapping, index);\n\t\tif (!page)\n\t\t\tpage = alloc_page(GFP_NOIO);\n\n\t\tif (!page) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_free_bio;\n\t\t}\n\n\t\t \n\t\t__bio_add_page(bio, page, len, offset);\n\t\toffset = 0;\n\t\ttotal_len -= len;\n\t}\n\n\tif (cache_mapping)\n\t\terror = squashfs_bio_read_cached(bio, cache_mapping, index,\n\t\t\t\t\t\t length, read_start, read_end,\n\t\t\t\t\t\t page_count);\n\telse\n\t\terror = submit_bio_wait(bio);\n\tif (error)\n\t\tgoto out_free_bio;\n\n\t*biop = bio;\n\t*block_offset = index & ((1 << msblk->devblksize_log2) - 1);\n\treturn 0;\n\nout_free_bio:\n\tbio_free_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\n\treturn error;\n}\n\n \nint squashfs_read_data(struct super_block *sb, u64 index, int length,\n\t\t       u64 *next_index, struct squashfs_page_actor *output)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tstruct bio *bio = NULL;\n\tint compressed;\n\tint res;\n\tint offset;\n\n\tif (length) {\n\t\t \n\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d, src size %d\\n\",\n\t\t\tindex, compressed ? \"\" : \"un\", length, output->length);\n\t} else {\n\t\t \n\t\tconst u8 *data;\n\t\tstruct bvec_iter_all iter_all = {};\n\t\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\n\t\tif (index + 2 > msblk->bytes_used) {\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tres = squashfs_bio_read(sb, index, 2, &bio, &offset);\n\t\tif (res)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON_ONCE(!bio_next_segment(bio, &iter_all))) {\n\t\t\tres = -EIO;\n\t\t\tgoto out_free_bio;\n\t\t}\n\t\t \n\t\tdata = bvec_virt(bvec);\n\t\tlength = data[offset];\n\t\tif (offset < bvec->bv_len - 1) {\n\t\t\tlength |= data[offset + 1] << 8;\n\t\t} else {\n\t\t\tif (WARN_ON_ONCE(!bio_next_segment(bio, &iter_all))) {\n\t\t\t\tres = -EIO;\n\t\t\t\tgoto out_free_bio;\n\t\t\t}\n\t\t\tdata = bvec_virt(bvec);\n\t\t\tlength |= data[0] << 8;\n\t\t}\n\t\tbio_free_pages(bio);\n\t\tbio_uninit(bio);\n\t\tkfree(bio);\n\n\t\tcompressed = SQUASHFS_COMPRESSED(length);\n\t\tlength = SQUASHFS_COMPRESSED_SIZE(length);\n\t\tindex += 2;\n\n\t\tTRACE(\"Block @ 0x%llx, %scompressed size %d\\n\", index - 2,\n\t\t      compressed ? \"\" : \"un\", length);\n\t}\n\tif (length < 0 || length > output->length ||\n\t\t\t(index + length) > msblk->bytes_used) {\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (next_index)\n\t\t*next_index = index + length;\n\n\tres = squashfs_bio_read(sb, index, length, &bio, &offset);\n\tif (res)\n\t\tgoto out;\n\n\tif (compressed) {\n\t\tif (!msblk->stream) {\n\t\t\tres = -EIO;\n\t\t\tgoto out_free_bio;\n\t\t}\n\t\tres = msblk->thread_ops->decompress(msblk, bio, offset, length, output);\n\t} else {\n\t\tres = copy_bio_to_actor(bio, output, offset, length);\n\t}\n\nout_free_bio:\n\tbio_free_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\nout:\n\tif (res < 0) {\n\t\tERROR(\"Failed to read block 0x%llx: %d\\n\", index, res);\n\t\tif (msblk->panic_on_errors)\n\t\t\tpanic(\"squashfs read failed\");\n\t}\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}