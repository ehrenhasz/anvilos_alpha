{
  "module_name": "lzo_wrapper.c",
  "hash_id": "989e1f556b9aa8850677ff5cc52a9700064e0abec4c1bbe48b5d84f891be109f",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/lzo_wrapper.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\nstruct squashfs_lzo {\n\tvoid\t*input;\n\tvoid\t*output;\n};\n\nstatic void *lzo_init(struct squashfs_sb_info *msblk, void *buff)\n{\n\tint block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);\n\n\tstruct squashfs_lzo *stream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (stream == NULL)\n\t\tgoto failed;\n\tstream->input = vmalloc(block_size);\n\tif (stream->input == NULL)\n\t\tgoto failed;\n\tstream->output = vmalloc(block_size);\n\tif (stream->output == NULL)\n\t\tgoto failed2;\n\n\treturn stream;\n\nfailed2:\n\tvfree(stream->input);\nfailed:\n\tERROR(\"Failed to allocate lzo workspace\\n\");\n\tkfree(stream);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n\nstatic void lzo_free(void *strm)\n{\n\tstruct squashfs_lzo *stream = strm;\n\n\tif (stream) {\n\t\tvfree(stream->input);\n\t\tvfree(stream->output);\n\t}\n\tkfree(stream);\n}\n\n\nstatic int lzo_uncompress(struct squashfs_sb_info *msblk, void *strm,\n\tstruct bio *bio, int offset, int length,\n\tstruct squashfs_page_actor *output)\n{\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\tstruct squashfs_lzo *stream = strm;\n\tvoid *buff = stream->input, *data;\n\tint bytes = length, res;\n\tsize_t out_len = output->length;\n\n\twhile (bio_next_segment(bio, &iter_all)) {\n\t\tint avail = min(bytes, ((int)bvec->bv_len) - offset);\n\n\t\tdata = bvec_virt(bvec);\n\t\tmemcpy(buff, data + offset, avail);\n\t\tbuff += avail;\n\t\tbytes -= avail;\n\t\toffset = 0;\n\t}\n\n\tres = lzo1x_decompress_safe(stream->input, (size_t)length,\n\t\t\t\t\tstream->output, &out_len);\n\tif (res != LZO_E_OK)\n\t\tgoto failed;\n\n\tres = bytes = (int)out_len;\n\tdata = squashfs_first_page(output);\n\tbuff = stream->output;\n\twhile (data) {\n\t\tif (bytes <= PAGE_SIZE) {\n\t\t\tif (!IS_ERR(data))\n\t\t\t\tmemcpy(data, buff, bytes);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!IS_ERR(data))\n\t\t\t\tmemcpy(data, buff, PAGE_SIZE);\n\t\t\tbuff += PAGE_SIZE;\n\t\t\tbytes -= PAGE_SIZE;\n\t\t\tdata = squashfs_next_page(output);\n\t\t}\n\t}\n\tsquashfs_finish_page(output);\n\n\treturn res;\n\nfailed:\n\treturn -EIO;\n}\n\nconst struct squashfs_decompressor squashfs_lzo_comp_ops = {\n\t.init = lzo_init,\n\t.free = lzo_free,\n\t.decompress = lzo_uncompress,\n\t.id = LZO_COMPRESSION,\n\t.name = \"lzo\",\n\t.alloc_buffer = 0,\n\t.supported = 1\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}