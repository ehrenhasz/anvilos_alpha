{
  "module_name": "export.c",
  "hash_id": "2b4c9e13085e5213ca5876948eb57e966f204e62cec2cf011c0584304b1036ba",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/export.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/dcache.h>\n#include <linux/exportfs.h>\n#include <linux/slab.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n\n \nstatic long long squashfs_inode_lookup(struct super_block *sb, int ino_num)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint blk = SQUASHFS_LOOKUP_BLOCK(ino_num - 1);\n\tint offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino_num - 1);\n\tu64 start;\n\t__le64 ino;\n\tint err;\n\n\tTRACE(\"Entered squashfs_inode_lookup, inode_number = %d\\n\", ino_num);\n\n\tif (ino_num == 0 || (ino_num - 1) >= msblk->inodes)\n\t\treturn -EINVAL;\n\n\tstart = le64_to_cpu(msblk->inode_lookup_table[blk]);\n\n\terr = squashfs_read_metadata(sb, &ino, &start, &offset, sizeof(ino));\n\tif (err < 0)\n\t\treturn err;\n\n\tTRACE(\"squashfs_inode_lookup, inode = 0x%llx\\n\",\n\t\t(u64) le64_to_cpu(ino));\n\n\treturn le64_to_cpu(ino);\n}\n\n\nstatic struct dentry *squashfs_export_iget(struct super_block *sb,\n\tunsigned int ino_num)\n{\n\tlong long ino;\n\tstruct dentry *dentry = ERR_PTR(-ENOENT);\n\n\tTRACE(\"Entered squashfs_export_iget\\n\");\n\n\tino = squashfs_inode_lookup(sb, ino_num);\n\tif (ino >= 0)\n\t\tdentry = d_obtain_alias(squashfs_iget(sb, ino, ino_num));\n\n\treturn dentry;\n}\n\n\nstatic struct dentry *squashfs_fh_to_dentry(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tif ((fh_type != FILEID_INO32_GEN && fh_type != FILEID_INO32_GEN_PARENT)\n\t\t\t|| fh_len < 2)\n\t\treturn NULL;\n\n\treturn squashfs_export_iget(sb, fid->i32.ino);\n}\n\n\nstatic struct dentry *squashfs_fh_to_parent(struct super_block *sb,\n\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_type != FILEID_INO32_GEN_PARENT || fh_len < 4)\n\t\treturn NULL;\n\n\treturn squashfs_export_iget(sb, fid->i32.parent_ino);\n}\n\n\nstatic struct dentry *squashfs_get_parent(struct dentry *child)\n{\n\tstruct inode *inode = d_inode(child);\n\tunsigned int parent_ino = squashfs_i(inode)->parent;\n\n\treturn squashfs_export_iget(inode->i_sb, parent_ino);\n}\n\n\n \n__le64 *squashfs_read_inode_lookup_table(struct super_block *sb,\n\t\tu64 lookup_table_start, u64 next_table, unsigned int inodes)\n{\n\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(inodes);\n\tunsigned int indexes = SQUASHFS_LOOKUP_BLOCKS(inodes);\n\tint n;\n\t__le64 *table;\n\tu64 start, end;\n\n\tTRACE(\"In read_inode_lookup_table, length %d\\n\", length);\n\n\t \n\n\t \n\tif (inodes == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (length != (next_table - lookup_table_start))\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = squashfs_read_table(sb, lookup_table_start, length);\n\tif (IS_ERR(table))\n\t\treturn table;\n\n\t \n\tfor (n = 0; n < (indexes - 1); n++) {\n\t\tstart = le64_to_cpu(table[n]);\n\t\tend = le64_to_cpu(table[n + 1]);\n\n\t\tif (start >= end\n\t\t    || (end - start) >\n\t\t    (SQUASHFS_METADATA_SIZE + SQUASHFS_BLOCK_OFFSET)) {\n\t\t\tkfree(table);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tstart = le64_to_cpu(table[indexes - 1]);\n\tif (start >= lookup_table_start ||\n\t    (lookup_table_start - start) >\n\t    (SQUASHFS_METADATA_SIZE + SQUASHFS_BLOCK_OFFSET)) {\n\t\tkfree(table);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn table;\n}\n\n\nconst struct export_operations squashfs_export_ops = {\n\t.fh_to_dentry = squashfs_fh_to_dentry,\n\t.fh_to_parent = squashfs_fh_to_parent,\n\t.get_parent = squashfs_get_parent\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}