{
  "module_name": "zlib_wrapper.c",
  "hash_id": "97928afac0d05b5434c29b49251d0ea37f260862bc6068ffe21b6526fed560ad",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/zlib_wrapper.c",
  "human_readable_source": "\n \n\n\n#include <linux/mutex.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"page_actor.h\"\n\nstatic void *zlib_init(struct squashfs_sb_info *dummy, void *buff)\n{\n\tz_stream *stream = kmalloc(sizeof(z_stream), GFP_KERNEL);\n\tif (stream == NULL)\n\t\tgoto failed;\n\tstream->workspace = vmalloc(zlib_inflate_workspacesize());\n\tif (stream->workspace == NULL)\n\t\tgoto failed;\n\n\treturn stream;\n\nfailed:\n\tERROR(\"Failed to allocate zlib workspace\\n\");\n\tkfree(stream);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n\nstatic void zlib_free(void *strm)\n{\n\tz_stream *stream = strm;\n\n\tif (stream)\n\t\tvfree(stream->workspace);\n\tkfree(stream);\n}\n\n\nstatic int zlib_uncompress(struct squashfs_sb_info *msblk, void *strm,\n\tstruct bio *bio, int offset, int length,\n\tstruct squashfs_page_actor *output)\n{\n\tstruct bvec_iter_all iter_all = {};\n\tstruct bio_vec *bvec = bvec_init_iter_all(&iter_all);\n\tint zlib_init = 0, error = 0;\n\tz_stream *stream = strm;\n\n\tstream->avail_out = PAGE_SIZE;\n\tstream->next_out = squashfs_first_page(output);\n\tstream->avail_in = 0;\n\n\tif (IS_ERR(stream->next_out)) {\n\t\terror = PTR_ERR(stream->next_out);\n\t\tgoto finish;\n\t}\n\n\tfor (;;) {\n\t\tint zlib_err;\n\n\t\tif (stream->avail_in == 0) {\n\t\t\tconst void *data;\n\t\t\tint avail;\n\n\t\t\tif (!bio_next_segment(bio, &iter_all)) {\n\t\t\t\t \n\t\t\t\terror = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tavail = min(length, ((int)bvec->bv_len) - offset);\n\t\t\tdata = bvec_virt(bvec);\n\t\t\tlength -= avail;\n\t\t\tstream->next_in = data + offset;\n\t\t\tstream->avail_in = avail;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (stream->avail_out == 0) {\n\t\t\tstream->next_out = squashfs_next_page(output);\n\t\t\tif (IS_ERR(stream->next_out)) {\n\t\t\t\terror = PTR_ERR(stream->next_out);\n\t\t\t\tbreak;\n\t\t\t} else if (stream->next_out != NULL)\n\t\t\t\tstream->avail_out = PAGE_SIZE;\n\t\t}\n\n\t\tif (!zlib_init) {\n\t\t\tzlib_err = zlib_inflateInit(stream);\n\t\t\tif (zlib_err != Z_OK) {\n\t\t\t\terror = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzlib_init = 1;\n\t\t}\n\n\t\tzlib_err = zlib_inflate(stream, Z_SYNC_FLUSH);\n\t\tif (zlib_err == Z_STREAM_END)\n\t\t\tbreak;\n\t\tif (zlib_err != Z_OK) {\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfinish:\n\tsquashfs_finish_page(output);\n\n\tif (!error)\n\t\tif (zlib_inflateEnd(stream) != Z_OK)\n\t\t\terror = -EIO;\n\n\treturn error ? error : stream->total_out;\n}\n\nconst struct squashfs_decompressor squashfs_zlib_comp_ops = {\n\t.init = zlib_init,\n\t.free = zlib_free,\n\t.decompress = zlib_uncompress,\n\t.id = ZLIB_COMPRESSION,\n\t.name = \"zlib\",\n\t.alloc_buffer = 1,\n\t.supported = 1\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}