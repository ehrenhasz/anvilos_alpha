{
  "module_name": "namei.c",
  "hash_id": "6c494308419fc3c48534ec70708b43445a35ea331ef642b654a543fdf4085479",
  "original_prompt": "Ingested from linux-6.6.14/fs/squashfs/namei.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/dcache.h>\n#include <linux/xattr.h>\n\n#include \"squashfs_fs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs.h\"\n#include \"xattr.h\"\n\n \nstatic int get_dir_index_using_name(struct super_block *sb,\n\t\t\tu64 *next_block, int *next_offset, u64 index_start,\n\t\t\tint index_offset, int i_count, const char *name,\n\t\t\tint len)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint i, length = 0, err;\n\tunsigned int size;\n\tstruct squashfs_dir_index *index;\n\tchar *str;\n\n\tTRACE(\"Entered get_dir_index_using_name, i_count %d\\n\", i_count);\n\n\tindex = kmalloc(sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2, GFP_KERNEL);\n\tif (index == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_index\\n\");\n\t\tgoto out;\n\t}\n\n\tstr = &index->name[SQUASHFS_NAME_LEN + 1];\n\tstrncpy(str, name, len);\n\tstr[len] = '\\0';\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, index, &index_start,\n\t\t\t\t\t&index_offset, sizeof(*index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\n\t\tsize = le32_to_cpu(index->size) + 1;\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, index->name, &index_start,\n\t\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex->name[size] = '\\0';\n\n\t\tif (strcmp(index->name, str) > 0)\n\t\t\tbreak;\n\n\t\tlength = le32_to_cpu(index->index);\n\t\t*next_block = le32_to_cpu(index->start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\tkfree(index);\n\nout:\n\t \n\treturn length + 3;\n}\n\n\nstatic struct dentry *squashfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tstruct inode *inode = NULL;\n\tstruct squashfs_sb_info *msblk = dir->i_sb->s_fs_info;\n\tstruct squashfs_dir_header dirh;\n\tstruct squashfs_dir_entry *dire;\n\tu64 block = squashfs_i(dir)->start + msblk->directory_table;\n\tint offset = squashfs_i(dir)->offset;\n\tint err, length;\n\tunsigned int dir_count, size;\n\n\tTRACE(\"Entered squashfs_lookup [%llx:%x]\\n\", block, offset);\n\n\tdire = kmalloc(sizeof(*dire) + SQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n\tif (dire == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_entry\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (len > SQUASHFS_NAME_LEN) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto failed;\n\t}\n\n\tlength = get_dir_index_using_name(dir->i_sb, &block, &offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_start,\n\t\t\t\tsquashfs_i(dir)->dir_idx_offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_cnt, name, len);\n\n\twhile (length < i_size_read(dir)) {\n\t\t \n\t\terr = squashfs_read_metadata(dir->i_sb, &dirh, &block,\n\t\t\t\t&offset, sizeof(dirh));\n\t\tif (err < 0)\n\t\t\tgoto read_failure;\n\n\t\tlength += sizeof(dirh);\n\n\t\tdir_count = le32_to_cpu(dirh.count) + 1;\n\n\t\tif (dir_count > SQUASHFS_DIR_COUNT)\n\t\t\tgoto data_error;\n\n\t\twhile (dir_count--) {\n\t\t\t \n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire, &block,\n\t\t\t\t\t&offset, sizeof(*dire));\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tsize = le16_to_cpu(dire->size) + 1;\n\n\t\t\t \n\t\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\t\tgoto data_error;\n\n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire->name,\n\t\t\t\t\t&block, &offset, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tlength += sizeof(*dire) + size;\n\n\t\t\tif (name[0] < dire->name[0])\n\t\t\t\tgoto exit_lookup;\n\n\t\t\tif (len == size && !strncmp(name, dire->name, len)) {\n\t\t\t\tunsigned int blk, off, ino_num;\n\t\t\t\tlong long ino;\n\t\t\t\tblk = le32_to_cpu(dirh.start_block);\n\t\t\t\toff = le16_to_cpu(dire->offset);\n\t\t\t\tino_num = le32_to_cpu(dirh.inode_number) +\n\t\t\t\t\t(short) le16_to_cpu(dire->inode_number);\n\t\t\t\tino = SQUASHFS_MKINODE(blk, off);\n\n\t\t\t\tTRACE(\"calling squashfs_iget for directory \"\n\t\t\t\t\t\"entry %s, inode  %x:%x, %d\\n\", name,\n\t\t\t\t\tblk, off, ino_num);\n\n\t\t\t\tinode = squashfs_iget(dir->i_sb, ino, ino_num);\n\t\t\t\tgoto exit_lookup;\n\t\t\t}\n\t\t}\n\t}\n\nexit_lookup:\n\tkfree(dire);\n\treturn d_splice_alias(inode, dentry);\n\ndata_error:\n\terr = -EIO;\n\nread_failure:\n\tERROR(\"Unable to read directory block [%llx:%x]\\n\",\n\t\tsquashfs_i(dir)->start + msblk->directory_table,\n\t\tsquashfs_i(dir)->offset);\nfailed:\n\tkfree(dire);\n\treturn ERR_PTR(err);\n}\n\n\nconst struct inode_operations squashfs_dir_inode_ops = {\n\t.lookup = squashfs_lookup,\n\t.listxattr = squashfs_listxattr\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}