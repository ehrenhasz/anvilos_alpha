{
  "module_name": "posix_acl.c",
  "hash_id": "703cd2829a2ada0e1e2ceb9ef2fcf1ce7a59ebd49d9635db2ab335ac5a6d8cb5",
  "original_prompt": "Ingested from linux-6.6.14/fs/posix_acl.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n#include <linux/namei.h>\n#include <linux/mnt_idmapping.h>\n#include <linux/iversion.h>\n#include <linux/security.h>\n#include <linux/evm.h>\n#include <linux/fsnotify.h>\n#include <linux/filelock.h>\n\n#include \"internal.h\"\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    refcount_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl);\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl = rcu_dereference(*acl_by_type(inode, type));\n\n\tif (acl == ACL_DONT_CACHE) {\n\t\tstruct posix_acl *ret;\n\n\t\tret = inode->i_op->get_inode_acl(inode, type, LOOKUP_RCU);\n\t\tif (!IS_ERR(ret))\n\t\t\tacl = ret;\n\t}\n\n\treturn acl;\n}\nEXPORT_SYMBOL(get_cached_acl_rcu);\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\nEXPORT_SYMBOL(set_cached_acl);\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}\nEXPORT_SYMBOL(forget_cached_acl);\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}\nEXPORT_SYMBOL(forget_all_cached_acls);\n\nstatic struct posix_acl *__get_acl(struct mnt_idmap *idmap,\n\t\t\t\t   struct dentry *dentry, struct inode *inode,\n\t\t\t\t   int type)\n{\n\tstruct posix_acl *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t \n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t \n\tcmpxchg(p, ACL_NOT_CACHED, sentinel);\n\n\t \n\tif (dentry && inode->i_op->get_acl) {\n\t\tacl = inode->i_op->get_acl(idmap, dentry, type);\n\t} else if (inode->i_op->get_inode_acl) {\n\t\tacl = inode->i_op->get_inode_acl(inode, type, false);\n\t} else {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(acl)) {\n\t\t \n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t \n\tposix_acl_dup(acl);\n\tif (unlikely(!try_cmpxchg(p, &sentinel, acl)))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}\n\nstruct posix_acl *get_inode_acl(struct inode *inode, int type)\n{\n\treturn __get_acl(&nop_mnt_idmap, NULL, inode, type);\n}\nEXPORT_SYMBOL(get_inode_acl);\n\n \nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\trefcount_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}\nEXPORT_SYMBOL(posix_acl_init);\n\n \nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_alloc);\n\n \nstruct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\nEXPORT_SYMBOL_GPL(posix_acl_clone);\n\n \nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(posix_acl_valid);\n\n \nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t \n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\nEXPORT_SYMBOL(posix_acl_equiv_mode);\n\n \nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}\nEXPORT_SYMBOL(posix_acl_from_mode);\n\n \nint\nposix_acl_permission(struct mnt_idmap *idmap, struct inode *inode,\n\t\t     const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tstruct user_namespace *fs_userns = i_user_ns(inode);\n\tint found = 0;\n\tvfsuid_t vfsuid;\n\tvfsgid_t vfsgid;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t \n\t\t\t\tvfsuid = i_uid_into_vfsuid(idmap, inode);\n\t\t\t\tif (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tvfsuid = make_vfsuid(idmap, fs_userns,\n\t\t\t\t\t\t     pa->e_uid);\n\t\t\t\tif (vfsuid_eq_kuid(vfsuid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n\t\t\t\tvfsgid = i_gid_into_vfsgid(idmap, inode);\n\t\t\t\tif (vfsgid_in_group_p(vfsgid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tvfsgid = make_vfsgid(idmap, fs_userns,\n\t\t\t\t\t\t     pa->e_gid);\n\t\t\t\tif (vfsgid_in_group_p(vfsgid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n \nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t \n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}\n\n \nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t \n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_create);\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}\nEXPORT_SYMBOL(__posix_acl_chmod);\n\n \nint\n posix_acl_chmod(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t    umode_t mode)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_inode_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(idmap, dentry, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}\nEXPORT_SYMBOL(posix_acl_chmod);\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_inode_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(posix_acl_create);\n\n \nint posix_acl_update_mode(struct mnt_idmap *idmap,\n\t\t\t  struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!vfsgid_in_group_p(i_gid_into_vfsgid(idmap, inode)) &&\n\t    !capable_wrt_inode_uidgid(idmap, inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}\nEXPORT_SYMBOL(posix_acl_update_mode);\n\n \nstatic int posix_acl_fix_xattr_common(const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tint count;\n\n\tif (!header)\n\t\treturn -EINVAL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn -EINVAL;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn -EOPNOTSUPP;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn -EINVAL;\n\tif (count == 0)\n\t\treturn 0;\n\n\treturn count;\n}\n\n \nstruct posix_acl *posix_acl_from_xattr(struct user_namespace *userns,\n\t\t\t\t       const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tcount = posix_acl_fix_xattr_common(value, size);\n\tif (count < 0)\n\t\treturn ERR_PTR(count);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid = make_kuid(userns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid = make_kgid(userns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL (posix_acl_from_xattr);\n\n \nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\nEXPORT_SYMBOL (posix_acl_to_xattr);\n\n \nstatic ssize_t vfs_posix_acl_to_xattr(struct mnt_idmap *idmap,\n\t\t\t\t      struct inode *inode,\n\t\t\t\t      const struct posix_acl *acl, void *buffer,\n\t\t\t\t      size_t size)\n\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tstruct user_namespace *fs_userns, *caller_userns;\n\tssize_t real_size, n;\n\tvfsuid_t vfsuid;\n\tvfsgid_t vfsgid;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfs_userns = i_user_ns(inode);\n\tcaller_userns = current_user_ns();\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tvfsuid = make_vfsuid(idmap, fs_userns, acl_e->e_uid);\n\t\t\text_entry->e_id = cpu_to_le32(from_kuid(\n\t\t\t\tcaller_userns, vfsuid_into_kuid(vfsuid)));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvfsgid = make_vfsgid(idmap, fs_userns, acl_e->e_gid);\n\t\t\text_entry->e_id = cpu_to_le32(from_kgid(\n\t\t\t\tcaller_userns, vfsgid_into_kgid(vfsgid)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\n\nint\nset_posix_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t      int type, struct posix_acl *acl)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(idmap, dentry, acl, type);\n}\nEXPORT_SYMBOL(set_posix_acl);\n\nint posix_acl_listxattr(struct inode *inode, char **buffer,\n\t\t\tssize_t *remaining_size)\n{\n\tint err;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\n\tif (inode->i_acl) {\n\t\terr = xattr_list_one(buffer, remaining_size,\n\t\t\t\t     XATTR_NAME_POSIX_ACL_ACCESS);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (inode->i_default_acl) {\n\t\terr = xattr_list_one(buffer, remaining_size,\n\t\t\t\t     XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}\n\n \nconst struct xattr_handler nop_posix_acl_access = {\n\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t.list = posix_acl_xattr_list,\n};\nEXPORT_SYMBOL_GPL(nop_posix_acl_access);\n\n \nconst struct xattr_handler nop_posix_acl_default = {\n\t.name = XATTR_NAME_POSIX_ACL_DEFAULT,\n\t.list = posix_acl_xattr_list,\n};\nEXPORT_SYMBOL_GPL(nop_posix_acl_default);\n\nint simple_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   struct posix_acl *acl, int type)\n{\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(idmap, inode,\n\t\t\t\t&inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode_set_ctime_current(inode);\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}\n\nstatic int vfs_set_acl_idmapped_mnt(struct mnt_idmap *idmap,\n\t\t\t\t    struct user_namespace *fs_userns,\n\t\t\t\t    struct posix_acl *acl)\n{\n\tfor (int n = 0; n < acl->a_count; n++) {\n\t\tstruct posix_acl_entry *acl_e = &acl->a_entries[n];\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = from_vfsuid(idmap, fs_userns,\n\t\t\t\t\t\t   VFSUIDT_INIT(acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = from_vfsgid(idmap, fs_userns,\n\t\t\t\t\t\t   VFSGIDT_INIT(acl_e->e_gid));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint vfs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\tconst char *acl_name, struct posix_acl *kacl)\n{\n\tint acl_type;\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct inode *delegated_inode = NULL;\n\n\tacl_type = posix_acl_type(acl_name);\n\tif (acl_type < 0)\n\t\treturn -EINVAL;\n\n\tif (kacl) {\n\t\t \n\t\terror = vfs_set_acl_idmapped_mnt(idmap, i_user_ns(inode), kacl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\nretry_deleg:\n\tinode_lock(inode);\n\n\t \n\terror = may_write_xattr(idmap, inode);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\terror = security_inode_set_acl(idmap, dentry, acl_name, kacl);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\terror = try_break_deleg(inode, &delegated_inode);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\tif (likely(!is_bad_inode(inode)))\n\t\terror = set_posix_acl(idmap, dentry, acl_type, kacl);\n\telse\n\t\terror = -EIO;\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_set_acl(dentry, acl_name, kacl);\n\t}\n\nout_inode_unlock:\n\tinode_unlock(inode);\n\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_set_acl);\n\n \nstruct posix_acl *vfs_get_acl(struct mnt_idmap *idmap,\n\t\t\t      struct dentry *dentry, const char *acl_name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct posix_acl *acl;\n\tint acl_type, error;\n\n\tacl_type = posix_acl_type(acl_name);\n\tif (acl_type < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\terror = security_inode_get_acl(idmap, dentry, acl_name);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tacl = __get_acl(idmap, dentry, inode, acl_type);\n\tif (IS_ERR(acl))\n\t\treturn acl;\n\tif (!acl)\n\t\treturn ERR_PTR(-ENODATA);\n\n\treturn acl;\n}\nEXPORT_SYMBOL_GPL(vfs_get_acl);\n\n \nint vfs_remove_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   const char *acl_name)\n{\n\tint acl_type;\n\tint error;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct inode *delegated_inode = NULL;\n\n\tacl_type = posix_acl_type(acl_name);\n\tif (acl_type < 0)\n\t\treturn -EINVAL;\n\nretry_deleg:\n\tinode_lock(inode);\n\n\t \n\terror = may_write_xattr(idmap, inode);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\terror = security_inode_remove_acl(idmap, dentry, acl_name);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\terror = try_break_deleg(inode, &delegated_inode);\n\tif (error)\n\t\tgoto out_inode_unlock;\n\n\tif (likely(!is_bad_inode(inode)))\n\t\terror = set_posix_acl(idmap, dentry, acl_type, NULL);\n\telse\n\t\terror = -EIO;\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_remove_acl(idmap, dentry, acl_name);\n\t}\n\nout_inode_unlock:\n\tinode_unlock(inode);\n\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(vfs_remove_acl);\n\nint do_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t       const char *acl_name, const void *kvalue, size_t size)\n{\n\tint error;\n\tstruct posix_acl *acl = NULL;\n\n\tif (size) {\n\t\t \n\t\tacl = posix_acl_from_xattr(current_user_ns(), kvalue, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\n\terror = vfs_set_acl(idmap, dentry, acl_name, acl);\n\tposix_acl_release(acl);\n\treturn error;\n}\n\nssize_t do_get_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t   const char *acl_name, void *kvalue, size_t size)\n{\n\tssize_t error;\n\tstruct posix_acl *acl;\n\n\tacl = vfs_get_acl(idmap, dentry, acl_name);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terror = vfs_posix_acl_to_xattr(idmap, d_inode(dentry),\n\t\t\t\t       acl, kvalue, size);\n\tposix_acl_release(acl);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}