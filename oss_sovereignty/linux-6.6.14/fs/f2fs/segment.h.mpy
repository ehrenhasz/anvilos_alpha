{
  "module_name": "segment.h",
  "hash_id": "77931f7af1b1f848c45a32f6e3a321fcb2a208e9fe07c45874908810bcee361e",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/segment.h",
  "human_readable_source": " \n \n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n\n \n#define NULL_SEGNO\t\t\t((unsigned int)(~0))\n#define NULL_SECNO\t\t\t((unsigned int)(~0))\n\n#define DEF_RECLAIM_PREFREE_SEGMENTS\t5\t \n#define DEF_MAX_RECLAIM_PREFREE_SEGMENTS\t4096\t \n\n#define F2FS_MIN_SEGMENTS\t9  \n#define F2FS_MIN_META_SEGMENTS\t8  \n\n \n#define GET_L2R_SEGNO(free_i, segno)\t((segno) - (free_i)->start_segno)\n#define GET_R2L_SEGNO(free_i, segno)\t((segno) + (free_i)->start_segno)\n\n#define IS_DATASEG(t)\t((t) <= CURSEG_COLD_DATA)\n#define IS_NODESEG(t)\t((t) >= CURSEG_HOT_NODE && (t) <= CURSEG_COLD_NODE)\n#define SE_PAGETYPE(se)\t((IS_NODESEG((se)->type) ? NODE : DATA))\n\nstatic inline void sanity_check_seg_type(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned short seg_type)\n{\n\tf2fs_bug_on(sbi, seg_type >= NR_PERSISTENT_LOG);\n}\n\n#define IS_HOT(t)\t((t) == CURSEG_HOT_NODE || (t) == CURSEG_HOT_DATA)\n#define IS_WARM(t)\t((t) == CURSEG_WARM_NODE || (t) == CURSEG_WARM_DATA)\n#define IS_COLD(t)\t((t) == CURSEG_COLD_NODE || (t) == CURSEG_COLD_DATA)\n\n#define IS_CURSEG(sbi, seg)\t\t\t\t\t\t\\\n\t(((seg) == CURSEG_I(sbi, CURSEG_HOT_DATA)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_WARM_DATA)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_COLD_DATA)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_HOT_NODE)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_WARM_NODE)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_COLD_NODE)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_COLD_DATA_PINNED)->segno) ||\t\\\n\t ((seg) == CURSEG_I(sbi, CURSEG_ALL_DATA_ATGC)->segno))\n\n#define IS_CURSEC(sbi, secno)\t\t\t\t\t\t\\\n\t(((secno) == CURSEG_I(sbi, CURSEG_HOT_DATA)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_WARM_DATA)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_COLD_DATA)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_HOT_NODE)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_WARM_NODE)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_COLD_NODE)->segno /\t\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_COLD_DATA_PINNED)->segno /\t\\\n\t  (sbi)->segs_per_sec) ||\t\\\n\t ((secno) == CURSEG_I(sbi, CURSEG_ALL_DATA_ATGC)->segno /\t\\\n\t  (sbi)->segs_per_sec))\n\n#define MAIN_BLKADDR(sbi)\t\t\t\t\t\t\\\n\t(SM_I(sbi) ? SM_I(sbi)->main_blkaddr : \t\t\t\t\\\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->main_blkaddr))\n#define SEG0_BLKADDR(sbi)\t\t\t\t\t\t\\\n\t(SM_I(sbi) ? SM_I(sbi)->seg0_blkaddr : \t\t\t\t\\\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->segment0_blkaddr))\n\n#define MAIN_SEGS(sbi)\t(SM_I(sbi)->main_segments)\n#define MAIN_SECS(sbi)\t((sbi)->total_sections)\n\n#define TOTAL_SEGS(sbi)\t\t\t\t\t\t\t\\\n\t(SM_I(sbi) ? SM_I(sbi)->segment_count : \t\t\t\t\\\n\t\tle32_to_cpu(F2FS_RAW_SUPER(sbi)->segment_count))\n#define TOTAL_BLKS(sbi)\t(TOTAL_SEGS(sbi) << (sbi)->log_blocks_per_seg)\n\n#define MAX_BLKADDR(sbi)\t(SEG0_BLKADDR(sbi) + TOTAL_BLKS(sbi))\n#define SEGMENT_SIZE(sbi)\t(1ULL << ((sbi)->log_blocksize +\t\\\n\t\t\t\t\t(sbi)->log_blocks_per_seg))\n\n#define START_BLOCK(sbi, segno)\t(SEG0_BLKADDR(sbi) +\t\t\t\\\n\t (GET_R2L_SEGNO(FREE_I(sbi), segno) << (sbi)->log_blocks_per_seg))\n\n#define NEXT_FREE_BLKADDR(sbi, curseg)\t\t\t\t\t\\\n\t(START_BLOCK(sbi, (curseg)->segno) + (curseg)->next_blkoff)\n\n#define GET_SEGOFF_FROM_SEG0(sbi, blk_addr)\t((blk_addr) - SEG0_BLKADDR(sbi))\n#define GET_SEGNO_FROM_SEG0(sbi, blk_addr)\t\t\t\t\\\n\t(GET_SEGOFF_FROM_SEG0(sbi, blk_addr) >> (sbi)->log_blocks_per_seg)\n#define GET_BLKOFF_FROM_SEG0(sbi, blk_addr)\t\t\t\t\\\n\t(GET_SEGOFF_FROM_SEG0(sbi, blk_addr) & ((sbi)->blocks_per_seg - 1))\n\n#define GET_SEGNO(sbi, blk_addr)\t\t\t\t\t\\\n\t((!__is_valid_data_blkaddr(blk_addr)) ?\t\t\t\\\n\tNULL_SEGNO : GET_L2R_SEGNO(FREE_I(sbi),\t\t\t\\\n\t\tGET_SEGNO_FROM_SEG0(sbi, blk_addr)))\n#define BLKS_PER_SEC(sbi)\t\t\t\t\t\\\n\t((sbi)->segs_per_sec * (sbi)->blocks_per_seg)\n#define CAP_BLKS_PER_SEC(sbi)\t\t\t\t\t\\\n\t((sbi)->segs_per_sec * (sbi)->blocks_per_seg -\t\t\\\n\t (sbi)->unusable_blocks_per_sec)\n#define CAP_SEGS_PER_SEC(sbi)\t\t\t\t\t\\\n\t((sbi)->segs_per_sec - ((sbi)->unusable_blocks_per_sec >>\\\n\t(sbi)->log_blocks_per_seg))\n#define GET_SEC_FROM_SEG(sbi, segno)\t\t\t\t\\\n\t(((segno) == -1) ? -1: (segno) / (sbi)->segs_per_sec)\n#define GET_SEG_FROM_SEC(sbi, secno)\t\t\t\t\\\n\t((secno) * (sbi)->segs_per_sec)\n#define GET_ZONE_FROM_SEC(sbi, secno)\t\t\t\t\\\n\t(((secno) == -1) ? -1: (secno) / (sbi)->secs_per_zone)\n#define GET_ZONE_FROM_SEG(sbi, segno)\t\t\t\t\\\n\tGET_ZONE_FROM_SEC(sbi, GET_SEC_FROM_SEG(sbi, segno))\n\n#define GET_SUM_BLOCK(sbi, segno)\t\t\t\t\\\n\t((sbi)->sm_info->ssa_blkaddr + (segno))\n\n#define GET_SUM_TYPE(footer) ((footer)->entry_type)\n#define SET_SUM_TYPE(footer, type) ((footer)->entry_type = (type))\n\n#define SIT_ENTRY_OFFSET(sit_i, segno)\t\t\t\t\t\\\n\t((segno) % (sit_i)->sents_per_block)\n#define SIT_BLOCK_OFFSET(segno)\t\t\t\t\t\\\n\t((segno) / SIT_ENTRY_PER_BLOCK)\n#define\tSTART_SEGNO(segno)\t\t\\\n\t(SIT_BLOCK_OFFSET(segno) * SIT_ENTRY_PER_BLOCK)\n#define SIT_BLK_CNT(sbi)\t\t\t\\\n\tDIV_ROUND_UP(MAIN_SEGS(sbi), SIT_ENTRY_PER_BLOCK)\n#define f2fs_bitmap_size(nr)\t\t\t\\\n\t(BITS_TO_LONGS(nr) * sizeof(unsigned long))\n\n#define SECTOR_FROM_BLOCK(blk_addr)\t\t\t\t\t\\\n\t(((sector_t)blk_addr) << F2FS_LOG_SECTORS_PER_BLOCK)\n#define SECTOR_TO_BLOCK(sectors)\t\t\t\t\t\\\n\t((sectors) >> F2FS_LOG_SECTORS_PER_BLOCK)\n\n \nenum {\n\tALLOC_RIGHT = 0,\n\tALLOC_LEFT\n};\n\n \nenum {\n\tLFS = 0,\n\tSSR,\n\tAT_SSR,\n};\n\n \nenum {\n\tGC_CB = 0,\n\tGC_GREEDY,\n\tGC_AT,\n\tALLOC_NEXT,\n\tFLUSH_DEVICE,\n\tMAX_GC_POLICY,\n};\n\n \nenum {\n\tBG_GC = 0,\n\tFG_GC,\n};\n\n \nstruct victim_sel_policy {\n\tint alloc_mode;\t\t\t \n\tint gc_mode;\t\t\t \n\tunsigned long *dirty_bitmap;\t \n\tunsigned int max_search;\t \n\tunsigned int offset;\t\t \n\tunsigned int ofs_unit;\t\t \n\tunsigned int min_cost;\t\t \n\tunsigned long long oldest_age;\t \n\tunsigned int min_segno;\t\t \n\tunsigned long long age;\t\t \n\tunsigned long long age_threshold; \n};\n\nstruct seg_entry {\n\tunsigned int type:6;\t\t \n\tunsigned int valid_blocks:10;\t \n\tunsigned int ckpt_valid_blocks:10;\t \n\tunsigned int padding:6;\t\t \n\tunsigned char *cur_valid_map;\t \n#ifdef CONFIG_F2FS_CHECK_FS\n\tunsigned char *cur_valid_map_mir;\t \n#endif\n\t \n\tunsigned char *ckpt_valid_map;\t \n\tunsigned char *discard_map;\n\tunsigned long long mtime;\t \n};\n\nstruct sec_entry {\n\tunsigned int valid_blocks;\t \n};\n\n#define MAX_SKIP_GC_COUNT\t\t\t16\n\nstruct revoke_entry {\n\tstruct list_head list;\n\tblock_t old_addr;\t\t \n\tpgoff_t index;\n};\n\nstruct sit_info {\n\tblock_t sit_base_addr;\t\t \n\tblock_t sit_blocks;\t\t \n\tblock_t written_valid_blocks;\t \n\tchar *bitmap;\t\t\t \n\tchar *sit_bitmap;\t\t \n#ifdef CONFIG_F2FS_CHECK_FS\n\tchar *sit_bitmap_mir;\t\t \n\n\t \n\tunsigned long *invalid_segmap;\n#endif\n\tunsigned int bitmap_size;\t \n\n\tunsigned long *tmp_map;\t\t\t \n\tunsigned long *dirty_sentries_bitmap;\t \n\tunsigned int dirty_sentries;\t\t \n\tunsigned int sents_per_block;\t\t \n\tstruct rw_semaphore sentry_lock;\t \n\tstruct seg_entry *sentries;\t\t \n\tstruct sec_entry *sec_entries;\t\t \n\n\t \n\tunsigned long long elapsed_time;\t \n\tunsigned long long mounted_time;\t \n\tunsigned long long min_mtime;\t\t \n\tunsigned long long max_mtime;\t\t \n\tunsigned long long dirty_min_mtime;\t \n\tunsigned long long dirty_max_mtime;\t \n\n\tunsigned int last_victim[MAX_GC_POLICY];  \n};\n\nstruct free_segmap_info {\n\tunsigned int start_segno;\t \n\tunsigned int free_segments;\t \n\tunsigned int free_sections;\t \n\tspinlock_t segmap_lock;\t\t \n\tunsigned long *free_segmap;\t \n\tunsigned long *free_secmap;\t \n};\n\n \nenum dirty_type {\n\tDIRTY_HOT_DATA,\t\t \n\tDIRTY_WARM_DATA,\t \n\tDIRTY_COLD_DATA,\t \n\tDIRTY_HOT_NODE,\t\t \n\tDIRTY_WARM_NODE,\t \n\tDIRTY_COLD_NODE,\t \n\tDIRTY,\t\t\t \n\tPRE,\t\t\t \n\tNR_DIRTY_TYPE\n};\n\nstruct dirty_seglist_info {\n\tunsigned long *dirty_segmap[NR_DIRTY_TYPE];\n\tunsigned long *dirty_secmap;\n\tstruct mutex seglist_lock;\t\t \n\tint nr_dirty[NR_DIRTY_TYPE];\t\t \n\tunsigned long *victim_secmap;\t\t \n\tunsigned long *pinned_secmap;\t\t \n\tunsigned int pinned_secmap_cnt;\t\t \n\tbool enable_pin_section;\t\t \n};\n\n \nstruct curseg_info {\n\tstruct mutex curseg_mutex;\t\t \n\tstruct f2fs_summary_block *sum_blk;\t \n\tstruct rw_semaphore journal_rwsem;\t \n\tstruct f2fs_journal *journal;\t\t \n\tunsigned char alloc_type;\t\t \n\tunsigned short seg_type;\t\t \n\tunsigned int segno;\t\t\t \n\tunsigned short next_blkoff;\t\t \n\tunsigned int zone;\t\t\t \n\tunsigned int next_segno;\t\t \n\tint fragment_remained_chunk;\t\t \n\tbool inited;\t\t\t\t \n};\n\nstruct sit_entry_set {\n\tstruct list_head set_list;\t \n\tunsigned int start_segno;\t \n\tunsigned int entry_cnt;\t\t \n};\n\n \nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}\n\nstatic inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sec_entries[GET_SEC_FROM_SEG(sbi, segno)];\n}\n\nstatic inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, bool use_section)\n{\n\t \n\tif (use_section && __is_large_section(sbi))\n\t\treturn get_sec_entry(sbi, segno)->valid_blocks;\n\telse\n\t\treturn get_seg_entry(sbi, segno)->valid_blocks;\n}\n\nstatic inline unsigned int get_ckpt_valid_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, bool use_section)\n{\n\tif (use_section && __is_large_section(sbi)) {\n\t\tunsigned int start_segno = START_SEGNO(segno);\n\t\tunsigned int blocks = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++, start_segno++) {\n\t\t\tstruct seg_entry *se = get_seg_entry(sbi, start_segno);\n\n\t\t\tblocks += se->ckpt_valid_blocks;\n\t\t}\n\t\treturn blocks;\n\t}\n\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n}\n\nstatic inline void seg_info_from_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tse->valid_blocks = GET_SIT_VBLOCKS(rs);\n\tse->ckpt_valid_blocks = GET_SIT_VBLOCKS(rs);\n\tmemcpy(se->cur_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tmemcpy(se->cur_valid_map_mir, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n#endif\n\tse->type = GET_SIT_TYPE(rs);\n\tse->mtime = le64_to_cpu(rs->mtime);\n}\n\nstatic inline void __seg_info_to_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\tunsigned short raw_vblocks = (se->type << SIT_VBLOCKS_SHIFT) |\n\t\t\t\t\tse->valid_blocks;\n\trs->vblocks = cpu_to_le16(raw_vblocks);\n\tmemcpy(rs->valid_map, se->cur_valid_map, SIT_VBLOCK_MAP_SIZE);\n\trs->mtime = cpu_to_le64(se->mtime);\n}\n\nstatic inline void seg_info_to_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct page *page, unsigned int start)\n{\n\tstruct f2fs_sit_block *raw_sit;\n\tstruct seg_entry *se;\n\tstruct f2fs_sit_entry *rs;\n\tunsigned int end = min(start + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\tint i;\n\n\traw_sit = (struct f2fs_sit_block *)page_address(page);\n\tmemset(raw_sit, 0, PAGE_SIZE);\n\tfor (i = 0; i < end - start; i++) {\n\t\trs = &raw_sit->entries[i];\n\t\tse = get_seg_entry(sbi, start + i);\n\t\t__seg_info_to_raw_sit(se, rs);\n\t}\n}\n\nstatic inline void seg_info_to_raw_sit(struct seg_entry *se,\n\t\t\t\t\tstruct f2fs_sit_entry *rs)\n{\n\t__seg_info_to_raw_sit(se, rs);\n\n\tmemcpy(se->ckpt_valid_map, rs->valid_map, SIT_VBLOCK_MAP_SIZE);\n\tse->ckpt_valid_blocks = se->valid_blocks;\n}\n\nstatic inline unsigned int find_next_inuse(struct free_segmap_info *free_i,\n\t\tunsigned int max, unsigned int segno)\n{\n\tunsigned int ret;\n\tspin_lock(&free_i->segmap_lock);\n\tret = find_next_bit(free_i->free_segmap, max, segno);\n\tspin_unlock(&free_i->segmap_lock);\n\treturn ret;\n}\n\nstatic inline void __set_free(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\tunsigned int start_segno = GET_SEG_FROM_SEC(sbi, secno);\n\tunsigned int next;\n\tunsigned int usable_segs = f2fs_usable_segs_in_sec(sbi, segno);\n\n\tspin_lock(&free_i->segmap_lock);\n\tclear_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments++;\n\n\tnext = find_next_bit(free_i->free_segmap,\n\t\t\tstart_segno + sbi->segs_per_sec, start_segno);\n\tif (next >= start_segno + usable_segs) {\n\t\tclear_bit(secno, free_i->free_secmap);\n\t\tfree_i->free_sections++;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}\n\nstatic inline void __set_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\n\tset_bit(segno, free_i->free_segmap);\n\tfree_i->free_segments--;\n\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\tfree_i->free_sections--;\n}\n\nstatic inline void __set_test_and_free(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno, bool inmem)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\tunsigned int start_segno = GET_SEG_FROM_SEC(sbi, secno);\n\tunsigned int next;\n\tunsigned int usable_segs = f2fs_usable_segs_in_sec(sbi, segno);\n\n\tspin_lock(&free_i->segmap_lock);\n\tif (test_and_clear_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments++;\n\n\t\tif (!inmem && IS_CURSEC(sbi, secno))\n\t\t\tgoto skip_free;\n\t\tnext = find_next_bit(free_i->free_segmap,\n\t\t\t\tstart_segno + sbi->segs_per_sec, start_segno);\n\t\tif (next >= start_segno + usable_segs) {\n\t\t\tif (test_and_clear_bit(secno, free_i->free_secmap))\n\t\t\t\tfree_i->free_sections++;\n\t\t}\n\t}\nskip_free:\n\tspin_unlock(&free_i->segmap_lock);\n}\n\nstatic inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\n\tspin_lock(&free_i->segmap_lock);\n\tif (!test_and_set_bit(segno, free_i->free_segmap)) {\n\t\tfree_i->free_segments--;\n\t\tif (!test_and_set_bit(secno, free_i->free_secmap))\n\t\t\tfree_i->free_sections--;\n\t}\n\tspin_unlock(&free_i->segmap_lock);\n}\n\nstatic inline void get_sit_bitmap(struct f2fs_sb_info *sbi,\n\t\tvoid *dst_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tif (memcmp(sit_i->sit_bitmap, sit_i->sit_bitmap_mir,\n\t\t\t\t\t\tsit_i->bitmap_size))\n\t\tf2fs_bug_on(sbi, 1);\n#endif\n\tmemcpy(dst_addr, sit_i->sit_bitmap, sit_i->bitmap_size);\n}\n\nstatic inline block_t written_block_count(struct f2fs_sb_info *sbi)\n{\n\treturn SIT_I(sbi)->written_valid_blocks;\n}\n\nstatic inline unsigned int free_segments(struct f2fs_sb_info *sbi)\n{\n\treturn FREE_I(sbi)->free_segments;\n}\n\nstatic inline unsigned int reserved_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->reserved_segments +\n\t\t\tSM_I(sbi)->additional_reserved_segments;\n}\n\nstatic inline unsigned int free_sections(struct f2fs_sb_info *sbi)\n{\n\treturn FREE_I(sbi)->free_sections;\n}\n\nstatic inline unsigned int prefree_segments(struct f2fs_sb_info *sbi)\n{\n\treturn DIRTY_I(sbi)->nr_dirty[PRE];\n}\n\nstatic inline unsigned int dirty_segments(struct f2fs_sb_info *sbi)\n{\n\treturn DIRTY_I(sbi)->nr_dirty[DIRTY_HOT_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_DATA] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_HOT_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_WARM_NODE] +\n\t\tDIRTY_I(sbi)->nr_dirty[DIRTY_COLD_NODE];\n}\n\nstatic inline int overprovision_segments(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->ovp_segments;\n}\n\nstatic inline int reserved_sections(struct f2fs_sb_info *sbi)\n{\n\treturn GET_SEC_FROM_SEG(sbi, reserved_segments(sbi));\n}\n\nstatic inline bool has_curseg_enough_space(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int node_blocks, unsigned int dent_blocks)\n{\n\n\tunsigned int segno, left_blocks;\n\tint i;\n\n\t \n\tfor (i = CURSEG_HOT_NODE; i <= CURSEG_COLD_NODE; i++) {\n\t\tsegno = CURSEG_I(sbi, i)->segno;\n\t\tleft_blocks = f2fs_usable_blks_in_seg(sbi, segno) -\n\t\t\t\tget_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t\tif (node_blocks > left_blocks)\n\t\t\treturn false;\n\t}\n\n\t \n\tsegno = CURSEG_I(sbi, CURSEG_HOT_DATA)->segno;\n\tleft_blocks = f2fs_usable_blks_in_seg(sbi, segno) -\n\t\t\tget_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\tif (dent_blocks > left_blocks)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic inline void __get_secs_required(struct f2fs_sb_info *sbi,\n\t\tunsigned int *lower_p, unsigned int *upper_p, bool *curseg_p)\n{\n\tunsigned int total_node_blocks = get_pages(sbi, F2FS_DIRTY_NODES) +\n\t\t\t\t\tget_pages(sbi, F2FS_DIRTY_DENTS) +\n\t\t\t\t\tget_pages(sbi, F2FS_DIRTY_IMETA);\n\tunsigned int total_dent_blocks = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tunsigned int node_secs = total_node_blocks / CAP_BLKS_PER_SEC(sbi);\n\tunsigned int dent_secs = total_dent_blocks / CAP_BLKS_PER_SEC(sbi);\n\tunsigned int node_blocks = total_node_blocks % CAP_BLKS_PER_SEC(sbi);\n\tunsigned int dent_blocks = total_dent_blocks % CAP_BLKS_PER_SEC(sbi);\n\n\tif (lower_p)\n\t\t*lower_p = node_secs + dent_secs;\n\tif (upper_p)\n\t\t*upper_p = node_secs + dent_secs +\n\t\t\t(node_blocks ? 1 : 0) + (dent_blocks ? 1 : 0);\n\tif (curseg_p)\n\t\t*curseg_p = has_curseg_enough_space(sbi,\n\t\t\t\tnode_blocks, dent_blocks);\n}\n\nstatic inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi,\n\t\t\t\t\tint freed, int needed)\n{\n\tunsigned int free_secs, lower_secs, upper_secs;\n\tbool curseg_space;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn false;\n\n\t__get_secs_required(sbi, &lower_secs, &upper_secs, &curseg_space);\n\n\tfree_secs = free_sections(sbi) + freed;\n\tlower_secs += needed + reserved_sections(sbi);\n\tupper_secs += needed + reserved_sections(sbi);\n\n\tif (free_secs > upper_secs)\n\t\treturn false;\n\telse if (free_secs <= lower_secs)\n\t\treturn true;\n\treturn !curseg_space;\n}\n\nstatic inline bool has_enough_free_secs(struct f2fs_sb_info *sbi,\n\t\t\t\t\tint freed, int needed)\n{\n\treturn !has_not_enough_free_secs(sbi, freed, needed);\n}\n\nstatic inline bool f2fs_is_checkpoint_ready(struct f2fs_sb_info *sbi)\n{\n\tif (likely(!is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\treturn true;\n\tif (likely(has_enough_free_secs(sbi, 0, 0)))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool excess_prefree_segs(struct f2fs_sb_info *sbi)\n{\n\treturn prefree_segments(sbi) > SM_I(sbi)->rec_prefree_segments;\n}\n\nstatic inline int utilization(struct f2fs_sb_info *sbi)\n{\n\treturn div_u64((u64)valid_user_blocks(sbi) * 100,\n\t\t\t\t\tsbi->user_block_count);\n}\n\n \n#define DEF_MIN_IPU_UTIL\t70\n#define DEF_MIN_FSYNC_BLOCKS\t8\n#define DEF_MIN_HOT_BLOCKS\t16\n\n#define SMALL_VOLUME_SEGMENTS\t(16 * 512)\t \n\n#define F2FS_IPU_DISABLE\t0\n\n \nenum {\n\tF2FS_IPU_FORCE,\n\tF2FS_IPU_SSR,\n\tF2FS_IPU_UTIL,\n\tF2FS_IPU_SSR_UTIL,\n\tF2FS_IPU_FSYNC,\n\tF2FS_IPU_ASYNC,\n\tF2FS_IPU_NOCACHE,\n\tF2FS_IPU_HONOR_OPU_WRITE,\n\tF2FS_IPU_MAX,\n};\n\nstatic inline bool IS_F2FS_IPU_DISABLE(struct f2fs_sb_info *sbi)\n{\n\treturn SM_I(sbi)->ipu_policy == F2FS_IPU_DISABLE;\n}\n\n#define F2FS_IPU_POLICY(name)\t\t\t\t\t\\\nstatic inline bool IS_##name(struct f2fs_sb_info *sbi)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn SM_I(sbi)->ipu_policy & BIT(name);\t\t\\\n}\n\nF2FS_IPU_POLICY(F2FS_IPU_FORCE);\nF2FS_IPU_POLICY(F2FS_IPU_SSR);\nF2FS_IPU_POLICY(F2FS_IPU_UTIL);\nF2FS_IPU_POLICY(F2FS_IPU_SSR_UTIL);\nF2FS_IPU_POLICY(F2FS_IPU_FSYNC);\nF2FS_IPU_POLICY(F2FS_IPU_ASYNC);\nF2FS_IPU_POLICY(F2FS_IPU_NOCACHE);\nF2FS_IPU_POLICY(F2FS_IPU_HONOR_OPU_WRITE);\n\nstatic inline unsigned int curseg_segno(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->segno;\n}\n\nstatic inline unsigned char curseg_alloc_type(struct f2fs_sb_info *sbi,\n\t\tint type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\treturn curseg->alloc_type;\n}\n\nstatic inline bool valid_main_segno(struct f2fs_sb_info *sbi,\n\t\tunsigned int segno)\n{\n\treturn segno <= (MAIN_SEGS(sbi) - 1);\n}\n\nstatic inline void verify_fio_blkaddr(struct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\n\tif (__is_valid_data_blkaddr(fio->old_blkaddr))\n\t\tverify_blkaddr(sbi, fio->old_blkaddr, __is_meta_io(fio) ?\n\t\t\t\t\tMETA_GENERIC : DATA_GENERIC);\n\tverify_blkaddr(sbi, fio->new_blkaddr, __is_meta_io(fio) ?\n\t\t\t\t\tMETA_GENERIC : DATA_GENERIC_ENHANCE);\n}\n\n \nstatic inline int check_block_count(struct f2fs_sb_info *sbi,\n\t\tint segno, struct f2fs_sit_entry *raw_sit)\n{\n\tbool is_valid  = test_bit_le(0, raw_sit->valid_map) ? true : false;\n\tint valid_blocks = 0;\n\tint cur_pos = 0, next_pos;\n\tunsigned int usable_blks_per_seg = f2fs_usable_blks_in_seg(sbi, segno);\n\n\t \n\tdo {\n\t\tif (is_valid) {\n\t\t\tnext_pos = find_next_zero_bit_le(&raw_sit->valid_map,\n\t\t\t\t\tusable_blks_per_seg,\n\t\t\t\t\tcur_pos);\n\t\t\tvalid_blocks += next_pos - cur_pos;\n\t\t} else\n\t\t\tnext_pos = find_next_bit_le(&raw_sit->valid_map,\n\t\t\t\t\tusable_blks_per_seg,\n\t\t\t\t\tcur_pos);\n\t\tcur_pos = next_pos;\n\t\tis_valid = !is_valid;\n\t} while (cur_pos < usable_blks_per_seg);\n\n\tif (unlikely(GET_SIT_VBLOCKS(raw_sit) != valid_blocks)) {\n\t\tf2fs_err(sbi, \"Mismatch valid blocks %d vs. %d\",\n\t\t\t GET_SIT_VBLOCKS(raw_sit), valid_blocks);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_SIT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (usable_blks_per_seg < sbi->blocks_per_seg)\n\t\tf2fs_bug_on(sbi, find_next_bit_le(&raw_sit->valid_map,\n\t\t\t\tsbi->blocks_per_seg,\n\t\t\t\tusable_blks_per_seg) != sbi->blocks_per_seg);\n\n\t \n\tif (unlikely(GET_SIT_VBLOCKS(raw_sit) > usable_blks_per_seg\n\t\t\t\t\t|| !valid_main_segno(sbi, segno))) {\n\t\tf2fs_err(sbi, \"Wrong valid blocks %d or segno %u\",\n\t\t\t GET_SIT_VBLOCKS(raw_sit), segno);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_SIT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nstatic inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int offset = SIT_BLOCK_OFFSET(start);\n\tblock_t blk_addr = sit_i->sit_base_addr + offset;\n\n\tf2fs_bug_on(sbi, !valid_main_segno(sbi, start));\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap) !=\n\t\t\tf2fs_test_bit(offset, sit_i->sit_bitmap_mir))\n\t\tf2fs_bug_on(sbi, 1);\n#endif\n\n\t \n\tif (f2fs_test_bit(offset, sit_i->sit_bitmap))\n\t\tblk_addr += sit_i->sit_blocks;\n\n\treturn blk_addr;\n}\n\nstatic inline pgoff_t next_sit_addr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tpgoff_t block_addr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tblock_addr -= sit_i->sit_base_addr;\n\tif (block_addr < sit_i->sit_blocks)\n\t\tblock_addr += sit_i->sit_blocks;\n\telse\n\t\tblock_addr -= sit_i->sit_blocks;\n\n\treturn block_addr + sit_i->sit_base_addr;\n}\n\nstatic inline void set_to_next_sit(struct sit_info *sit_i, unsigned int start)\n{\n\tunsigned int block_off = SIT_BLOCK_OFFSET(start);\n\n\tf2fs_change_bit(block_off, sit_i->sit_bitmap);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tf2fs_change_bit(block_off, sit_i->sit_bitmap_mir);\n#endif\n}\n\nstatic inline unsigned long long get_mtime(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tbool base_time)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\ttime64_t diff, now = ktime_get_boottime_seconds();\n\n\tif (now >= sit_i->mounted_time)\n\t\treturn sit_i->elapsed_time + now - sit_i->mounted_time;\n\n\t \n\tif (!base_time) {\n\t\tdiff = sit_i->mounted_time - now;\n\t\tif (sit_i->elapsed_time >= diff)\n\t\t\treturn sit_i->elapsed_time - diff;\n\t\treturn 0;\n\t}\n\treturn sit_i->elapsed_time;\n}\n\nstatic inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}\n\nstatic inline block_t start_sum_block(struct f2fs_sb_info *sbi)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}\n\nstatic inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)\n{\n\treturn __start_cp_addr(sbi) +\n\t\tle32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)\n\t\t\t\t- (base + 1) + type;\n}\n\nstatic inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)\n{\n\tif (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\treturn 0;\n\n\tif (type == DATA)\n\t\treturn sbi->blocks_per_seg;\n\telse if (type == NODE)\n\t\treturn 8 * sbi->blocks_per_seg;\n\telse if (type == META)\n\t\treturn 8 * BIO_MAX_VECS;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct writeback_control *wbc)\n{\n\tlong nr_to_write, desired;\n\n\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\treturn 0;\n\n\tnr_to_write = wbc->nr_to_write;\n\tdesired = BIO_MAX_VECS;\n\tif (type == NODE)\n\t\tdesired <<= 1;\n\n\twbc->nr_to_write = desired;\n\treturn desired - nr_to_write;\n}\n\nstatic inline void wake_up_discard_thread(struct f2fs_sb_info *sbi, bool force)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tbool wakeup = false;\n\tint i;\n\n\tif (force)\n\t\tgoto wake_up;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tfor (i = MAX_PLIST_NUM - 1; i >= 0; i--) {\n\t\tif (i + 1 < dcc->discard_granularity)\n\t\t\tbreak;\n\t\tif (!list_empty(&dcc->pend_list[i])) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dcc->cmd_lock);\n\tif (!wakeup || !is_idle(sbi, DISCARD_TIME))\n\t\treturn;\nwake_up:\n\tdcc->discard_wake = true;\n\twake_up_interruptible_all(&dcc->discard_wait_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}