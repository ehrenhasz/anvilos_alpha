{
  "module_name": "dir.c",
  "hash_id": "50cb79649892ac6e4faf3319c324fee35d43d6b829e4b0883f43c7dc835103a3",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/dir.c",
  "human_readable_source": "\n \n#include <asm/unaligned.h>\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/sched/signal.h>\n#include <linux/unicode.h>\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <trace/events/f2fs.h>\n\n#if IS_ENABLED(CONFIG_UNICODE)\nextern struct kmem_cache *f2fs_cf_name_slab;\n#endif\n\nstatic unsigned long dir_blocks(struct inode *inode)\n{\n\treturn ((unsigned long long) (i_size_read(inode) + PAGE_SIZE - 1))\n\t\t\t\t\t\t\t>> PAGE_SHIFT;\n}\n\nstatic unsigned int dir_buckets(unsigned int level, int dir_level)\n{\n\tif (level + dir_level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn BIT(level + dir_level);\n\telse\n\t\treturn MAX_DIR_BUCKETS;\n}\n\nstatic unsigned int bucket_blocks(unsigned int level)\n{\n\tif (level < MAX_DIR_HASH_DEPTH / 2)\n\t\treturn 2;\n\telse\n\t\treturn 4;\n}\n\n \nint f2fs_init_casefolded_name(const struct inode *dir,\n\t\t\t      struct f2fs_filename *fname)\n{\n#if IS_ENABLED(CONFIG_UNICODE)\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (IS_CASEFOLDED(dir) &&\n\t    !is_dot_dotdot(fname->usr_fname->name, fname->usr_fname->len)) {\n\t\tfname->cf_name.name = f2fs_kmem_cache_alloc(f2fs_cf_name_slab,\n\t\t\t\t\tGFP_NOFS, false, F2FS_SB(sb));\n\t\tif (!fname->cf_name.name)\n\t\t\treturn -ENOMEM;\n\t\tfname->cf_name.len = utf8_casefold(sb->s_encoding,\n\t\t\t\t\t\t   fname->usr_fname,\n\t\t\t\t\t\t   fname->cf_name.name,\n\t\t\t\t\t\t   F2FS_NAME_LEN);\n\t\tif ((int)fname->cf_name.len <= 0) {\n\t\t\tkmem_cache_free(f2fs_cf_name_slab, fname->cf_name.name);\n\t\t\tfname->cf_name.name = NULL;\n\t\t\tif (sb_has_strict_encoding(sb))\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __f2fs_setup_filename(const struct inode *dir,\n\t\t\t\t const struct fscrypt_name *crypt_name,\n\t\t\t\t struct f2fs_filename *fname)\n{\n\tint err;\n\n\tmemset(fname, 0, sizeof(*fname));\n\n\tfname->usr_fname = crypt_name->usr_fname;\n\tfname->disk_name = crypt_name->disk_name;\n#ifdef CONFIG_FS_ENCRYPTION\n\tfname->crypto_buf = crypt_name->crypto_buf;\n#endif\n\tif (crypt_name->is_nokey_name) {\n\t\t \n\t\tfname->hash = cpu_to_le32(crypt_name->hash);\n\t} else {\n\t\terr = f2fs_init_casefolded_name(dir, fname);\n\t\tif (err) {\n\t\t\tf2fs_free_filename(fname);\n\t\t\treturn err;\n\t\t}\n\t\tf2fs_hash_filename(dir, fname);\n\t}\n\treturn 0;\n}\n\n \nint f2fs_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\tint lookup, struct f2fs_filename *fname)\n{\n\tstruct fscrypt_name crypt_name;\n\tint err;\n\n\terr = fscrypt_setup_filename(dir, iname, lookup, &crypt_name);\n\tif (err)\n\t\treturn err;\n\n\treturn __f2fs_setup_filename(dir, &crypt_name, fname);\n}\n\n \nint f2fs_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct f2fs_filename *fname)\n{\n\tstruct fscrypt_name crypt_name;\n\tint err;\n\n\terr = fscrypt_prepare_lookup(dir, dentry, &crypt_name);\n\tif (err)\n\t\treturn err;\n\n\treturn __f2fs_setup_filename(dir, &crypt_name, fname);\n}\n\nvoid f2fs_free_filename(struct f2fs_filename *fname)\n{\n#ifdef CONFIG_FS_ENCRYPTION\n\tkfree(fname->crypto_buf.name);\n\tfname->crypto_buf.name = NULL;\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (fname->cf_name.name) {\n\t\tkmem_cache_free(f2fs_cf_name_slab, fname->cf_name.name);\n\t\tfname->cf_name.name = NULL;\n\t}\n#endif\n}\n\nstatic unsigned long dir_block_index(unsigned int level,\n\t\t\t\tint dir_level, unsigned int idx)\n{\n\tunsigned long i;\n\tunsigned long bidx = 0;\n\n\tfor (i = 0; i < level; i++)\n\t\tbidx += dir_buckets(i, dir_level) * bucket_blocks(i);\n\tbidx += idx * bucket_blocks(level);\n\treturn bidx;\n}\n\nstatic struct f2fs_dir_entry *find_in_block(struct inode *dir,\n\t\t\t\tstruct page *dentry_page,\n\t\t\t\tconst struct f2fs_filename *fname,\n\t\t\t\tint *max_slots)\n{\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = (struct f2fs_dentry_block *)page_address(dentry_page);\n\n\tmake_dentry_ptr_block(dir, &d, dentry_blk);\n\treturn f2fs_find_target_dentry(&d, fname, max_slots);\n}\n\n#if IS_ENABLED(CONFIG_UNICODE)\n \nstatic int f2fs_match_ci_name(const struct inode *dir, const struct qstr *name,\n\t\t\t       const u8 *de_name, u32 de_name_len)\n{\n\tconst struct super_block *sb = dir->i_sb;\n\tconst struct unicode_map *um = sb->s_encoding;\n\tstruct fscrypt_str decrypted_name = FSTR_INIT(NULL, de_name_len);\n\tstruct qstr entry = QSTR_INIT(de_name, de_name_len);\n\tint res;\n\n\tif (IS_ENCRYPTED(dir)) {\n\t\tconst struct fscrypt_str encrypted_name =\n\t\t\tFSTR_INIT((u8 *)de_name, de_name_len);\n\n\t\tif (WARN_ON_ONCE(!fscrypt_has_encryption_key(dir)))\n\t\t\treturn -EINVAL;\n\n\t\tdecrypted_name.name = kmalloc(de_name_len, GFP_KERNEL);\n\t\tif (!decrypted_name.name)\n\t\t\treturn -ENOMEM;\n\t\tres = fscrypt_fname_disk_to_usr(dir, 0, 0, &encrypted_name,\n\t\t\t\t\t\t&decrypted_name);\n\t\tif (res < 0)\n\t\t\tgoto out;\n\t\tentry.name = decrypted_name.name;\n\t\tentry.len = decrypted_name.len;\n\t}\n\n\tres = utf8_strncasecmp_folded(um, name, &entry);\n\t \n\tif (res < 0 && !sb_has_strict_encoding(sb)) {\n\t\tres = name->len == entry.len &&\n\t\t\t\tmemcmp(name->name, entry.name, name->len) == 0;\n\t} else {\n\t\t \n\t\tres = (res == 0);\n\t}\nout:\n\tkfree(decrypted_name.name);\n\treturn res;\n}\n#endif  \n\nstatic inline int f2fs_match_name(const struct inode *dir,\n\t\t\t\t   const struct f2fs_filename *fname,\n\t\t\t\t   const u8 *de_name, u32 de_name_len)\n{\n\tstruct fscrypt_name f;\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (fname->cf_name.name) {\n\t\tstruct qstr cf = FSTR_TO_QSTR(&fname->cf_name);\n\n\t\treturn f2fs_match_ci_name(dir, &cf, de_name, de_name_len);\n\t}\n#endif\n\tf.usr_fname = fname->usr_fname;\n\tf.disk_name = fname->disk_name;\n#ifdef CONFIG_FS_ENCRYPTION\n\tf.crypto_buf = fname->crypto_buf;\n#endif\n\treturn fscrypt_match_name(&f, de_name, de_name_len);\n}\n\nstruct f2fs_dir_entry *f2fs_find_target_dentry(const struct f2fs_dentry_ptr *d,\n\t\t\tconst struct f2fs_filename *fname, int *max_slots)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tint max_len = 0;\n\tint res = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tbit_pos++;\n\t\t\tmax_len++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = &d->dentry[bit_pos];\n\n\t\tif (unlikely(!de->name_len)) {\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (de->hash_code == fname->hash) {\n\t\t\tres = f2fs_match_name(d->inode, fname,\n\t\t\t\t\t      d->filename[bit_pos],\n\t\t\t\t\t      le16_to_cpu(de->name_len));\n\t\t\tif (res < 0)\n\t\t\t\treturn ERR_PTR(res);\n\t\t\tif (res)\n\t\t\t\tgoto found;\n\t\t}\n\n\t\tif (max_slots && max_len > *max_slots)\n\t\t\t*max_slots = max_len;\n\t\tmax_len = 0;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}\n\nstatic struct f2fs_dir_entry *find_in_level(struct inode *dir,\n\t\t\t\t\tunsigned int level,\n\t\t\t\t\tconst struct f2fs_filename *fname,\n\t\t\t\t\tstruct page **res_page)\n{\n\tint s = GET_DENTRY_SLOTS(fname->disk_name.len);\n\tunsigned int nbucket, nblock;\n\tunsigned int bidx, end_block;\n\tstruct page *dentry_page;\n\tstruct f2fs_dir_entry *de = NULL;\n\tpgoff_t next_pgofs;\n\tbool room = false;\n\tint max_slots;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t       le32_to_cpu(fname->hash) % nbucket);\n\tend_block = bidx + nblock;\n\n\twhile (bidx < end_block) {\n\t\t \n\t\tdentry_page = f2fs_find_data_page(dir, bidx, &next_pgofs);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT) {\n\t\t\t\troom = true;\n\t\t\t\tbidx = next_pgofs;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*res_page = dentry_page;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tde = find_in_block(dir, dentry_page, fname, &max_slots);\n\t\tif (IS_ERR(de)) {\n\t\t\t*res_page = ERR_CAST(de);\n\t\t\tde = NULL;\n\t\t\tbreak;\n\t\t} else if (de) {\n\t\t\t*res_page = dentry_page;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (max_slots >= s)\n\t\t\troom = true;\n\t\tf2fs_put_page(dentry_page, 0);\n\n\t\tbidx++;\n\t}\n\n\tif (!de && room && F2FS_I(dir)->chash != fname->hash) {\n\t\tF2FS_I(dir)->chash = fname->hash;\n\t\tF2FS_I(dir)->clevel = level;\n\t}\n\n\treturn de;\n}\n\nstruct f2fs_dir_entry *__f2fs_find_entry(struct inode *dir,\n\t\t\t\t\t const struct f2fs_filename *fname,\n\t\t\t\t\t struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\t*res_page = NULL;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\tde = f2fs_find_in_inline_dir(dir, fname, res_page);\n\t\tgoto out;\n\t}\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\tif (unlikely(max_depth > MAX_DIR_HASH_DEPTH)) {\n\t\tf2fs_warn(F2FS_I_SB(dir), \"Corrupted max_depth of %lu: %u\",\n\t\t\t  dir->i_ino, max_depth);\n\t\tmax_depth = MAX_DIR_HASH_DEPTH;\n\t\tf2fs_i_depth_write(dir, max_depth);\n\t}\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, fname, res_page);\n\t\tif (de || IS_ERR(*res_page))\n\t\t\tbreak;\n\t}\nout:\n\t \n\tif (!de)\n\t\tF2FS_I(dir)->task = current;\n\treturn de;\n}\n\n \nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tconst struct qstr *child, struct page **res_page)\n{\n\tstruct f2fs_dir_entry *de = NULL;\n\tstruct f2fs_filename fname;\n\tint err;\n\n\terr = f2fs_setup_filename(dir, child, 1, &fname);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\t*res_page = NULL;\n\t\telse\n\t\t\t*res_page = ERR_PTR(err);\n\t\treturn NULL;\n\t}\n\n\tde = __f2fs_find_entry(dir, &fname, res_page);\n\n\tf2fs_free_filename(&fname);\n\treturn de;\n}\n\nstruct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\treturn f2fs_find_entry(dir, &dotdot_name, p);\n}\n\nino_t f2fs_inode_by_name(struct inode *dir, const struct qstr *qstr,\n\t\t\t\t\t\t\tstruct page **page)\n{\n\tino_t res = 0;\n\tstruct f2fs_dir_entry *de;\n\n\tde = f2fs_find_entry(dir, qstr, page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->ino);\n\t\tf2fs_put_page(*page, 0);\n\t}\n\n\treturn res;\n}\n\nvoid f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type, true, true);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tde->file_type = fs_umode_to_ftype(inode->i_mode);\n\tset_page_dirty(page);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tf2fs_mark_inode_dirty_sync(dir, false);\n\tf2fs_put_page(page, 1);\n}\n\nstatic void init_dent_inode(struct inode *dir, struct inode *inode,\n\t\t\t    const struct f2fs_filename *fname,\n\t\t\t    struct page *ipage)\n{\n\tstruct f2fs_inode *ri;\n\n\tif (!fname)  \n\t\treturn;\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\n\t \n\tri = F2FS_INODE(ipage);\n\tri->i_namelen = cpu_to_le32(fname->disk_name.len);\n\tmemcpy(ri->i_name, fname->disk_name.name, fname->disk_name.len);\n\tif (IS_ENCRYPTED(dir)) {\n\t\tfile_set_enc_name(inode);\n\t\t \n\t\tif (IS_CASEFOLDED(dir)) {\n\t\t\tif (fname->disk_name.len + sizeof(f2fs_hash_t) <=\n\t\t\t    F2FS_NAME_LEN)\n\t\t\t\tput_unaligned(fname->hash, (f2fs_hash_t *)\n\t\t\t\t\t&ri->i_name[fname->disk_name.len]);\n\t\t\telse\n\t\t\t\tfile_lost_pino(inode);\n\t\t}\n\t}\n\tset_page_dirty(ipage);\n}\n\nvoid f2fs_do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct fscrypt_str dot = FSTR_INIT(\".\", 1);\n\tstruct fscrypt_str dotdot = FSTR_INIT(\"..\", 2);\n\n\t \n\tf2fs_update_dentry(inode->i_ino, inode->i_mode, d, &dot, 0, 0);\n\n\t \n\tf2fs_update_dentry(parent->i_ino, parent->i_mode, d, &dotdot, 0, 1);\n}\n\nstatic int make_empty_dir(struct inode *inode,\n\t\tstruct inode *parent, struct page *page)\n{\n\tstruct page *dentry_page;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (f2fs_has_inline_dentry(inode))\n\t\treturn f2fs_make_empty_inline_dir(inode, parent, page);\n\n\tdentry_page = f2fs_get_new_data_page(inode, page, 0, true);\n\tif (IS_ERR(dentry_page))\n\t\treturn PTR_ERR(dentry_page);\n\n\tdentry_blk = page_address(dentry_page);\n\n\tmake_dentry_ptr_block(NULL, &d, dentry_blk);\n\tf2fs_do_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn 0;\n}\n\nstruct page *f2fs_init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct f2fs_filename *fname, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(inode, FI_NEW_INODE)) {\n\t\tpage = f2fs_new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\t \n\t\t\tget_page(page);\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err) {\n\t\t\t\tlock_page(page);\n\t\t\t\tgoto put_error;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir,\n\t\t\t\t\t fname ? fname->usr_fname : NULL, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\tif (IS_ENCRYPTED(inode)) {\n\t\t\terr = fscrypt_set_context(inode, page);\n\t\t\tif (err)\n\t\t\t\tgoto put_error;\n\t\t}\n\t} else {\n\t\tpage = f2fs_get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t}\n\n\tinit_dent_inode(dir, inode, fname, page);\n\n\t \n\tif (is_inode_flag_set(inode, FI_INC_LINK)) {\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tfile_lost_pino(inode);\n\t\t \n\t\tif (inode->i_nlink == 0)\n\t\t\tf2fs_remove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tf2fs_i_links_write(inode, true);\n\t}\n\treturn page;\n\nput_error:\n\tclear_nlink(inode);\n\tf2fs_update_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}\n\nvoid f2fs_update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (inode && is_inode_flag_set(inode, FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tf2fs_i_links_write(dir, true);\n\t\tclear_inode_flag(inode, FI_NEW_INODE);\n\t}\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tf2fs_mark_inode_dirty_sync(dir, false);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth)\n\t\tf2fs_i_depth_write(dir, current_depth);\n\n\tif (inode && is_inode_flag_set(inode, FI_INC_LINK))\n\t\tclear_inode_flag(inode, FI_INC_LINK);\n}\n\nint f2fs_room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}\n\nbool f2fs_has_enough_room(struct inode *dir, struct page *ipage,\n\t\t\t  const struct f2fs_filename *fname)\n{\n\tstruct f2fs_dentry_ptr d;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(fname->disk_name.len);\n\n\tmake_dentry_ptr_inline(dir, &d, inline_data_addr(dir, ipage));\n\n\tbit_pos = f2fs_room_for_filename(d.bitmap, slots, d.max);\n\n\treturn bit_pos < d.max;\n}\n\nvoid f2fs_update_dentry(nid_t ino, umode_t mode, struct f2fs_dentry_ptr *d,\n\t\t\tconst struct fscrypt_str *name, f2fs_hash_t name_hash,\n\t\t\tunsigned int bit_pos)\n{\n\tstruct f2fs_dir_entry *de;\n\tint slots = GET_DENTRY_SLOTS(name->len);\n\tint i;\n\n\tde = &d->dentry[bit_pos];\n\tde->hash_code = name_hash;\n\tde->name_len = cpu_to_le16(name->len);\n\tmemcpy(d->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(ino);\n\tde->file_type = fs_umode_to_ftype(mode);\n\tfor (i = 0; i < slots; i++) {\n\t\t__set_bit_le(bit_pos + i, (void *)d->bitmap);\n\t\t \n\t\tif (i)\n\t\t\t(de + i)->name_len = 0;\n\t}\n}\n\nint f2fs_add_regular_entry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t\t   struct inode *inode, nid_t ino, umode_t mode)\n{\n\tunsigned int bit_pos;\n\tunsigned int level;\n\tunsigned int current_depth;\n\tunsigned long bidx, block;\n\tunsigned int nbucket, nblock;\n\tstruct page *dentry_page = NULL;\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *page = NULL;\n\tint slots, err = 0;\n\n\tlevel = 0;\n\tslots = GET_DENTRY_SLOTS(fname->disk_name.len);\n\n\tcurrent_depth = F2FS_I(dir)->i_current_depth;\n\tif (F2FS_I(dir)->chash == fname->hash) {\n\t\tlevel = F2FS_I(dir)->clevel;\n\t\tF2FS_I(dir)->chash = 0;\n\t}\n\nstart:\n\tif (time_to_inject(F2FS_I_SB(dir), FAULT_DIR_DEPTH))\n\t\treturn -ENOSPC;\n\n\tif (unlikely(current_depth == MAX_DIR_HASH_DEPTH))\n\t\treturn -ENOSPC;\n\n\t \n\tif (level == current_depth)\n\t\t++current_depth;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t(le32_to_cpu(fname->hash) % nbucket));\n\n\tfor (block = bidx; block <= (bidx + nblock - 1); block++) {\n\t\tdentry_page = f2fs_get_new_data_page(dir, NULL, block, true);\n\t\tif (IS_ERR(dentry_page))\n\t\t\treturn PTR_ERR(dentry_page);\n\n\t\tdentry_blk = page_address(dentry_page);\n\t\tbit_pos = f2fs_room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_DENTRY_IN_BLOCK);\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\tgoto add_dentry;\n\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\t \n\t++level;\n\tgoto start;\nadd_dentry:\n\tf2fs_wait_on_page_writeback(dentry_page, DATA, true, true);\n\n\tif (inode) {\n\t\tf2fs_down_write(&F2FS_I(inode)->i_sem);\n\t\tpage = f2fs_init_inode_metadata(inode, dir, fname, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmake_dentry_ptr_block(NULL, &d, dentry_blk);\n\tf2fs_update_dentry(ino, mode, &d, &fname->disk_name, fname->hash,\n\t\t\t   bit_pos);\n\n\tset_page_dirty(dentry_page);\n\n\tif (inode) {\n\t\tf2fs_i_pino_write(inode, dir->i_ino);\n\n\t\t \n\t\tif (is_inode_flag_set(inode, FI_NEW_INODE))\n\t\t\tf2fs_update_inode(inode, page);\n\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tf2fs_update_parent_metadata(dir, inode, current_depth);\nfail:\n\tif (inode)\n\t\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\n\tf2fs_put_page(dentry_page, 1);\n\n\treturn err;\n}\n\nint f2fs_add_dentry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t    struct inode *inode, nid_t ino, umode_t mode)\n{\n\tint err = -EAGAIN;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\t \n\t\tf2fs_down_read(&F2FS_I(dir)->i_xattr_sem);\n\t\terr = f2fs_add_inline_entry(dir, fname, inode, ino, mode);\n\t\tf2fs_up_read(&F2FS_I(dir)->i_xattr_sem);\n\t}\n\tif (err == -EAGAIN)\n\t\terr = f2fs_add_regular_entry(dir, fname, inode, ino, mode);\n\n\tf2fs_update_time(F2FS_I_SB(dir), REQ_TIME);\n\treturn err;\n}\n\n \nint f2fs_do_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\tstruct inode *inode, nid_t ino, umode_t mode)\n{\n\tstruct f2fs_filename fname;\n\tstruct page *page = NULL;\n\tstruct f2fs_dir_entry *de = NULL;\n\tint err;\n\n\terr = f2fs_setup_filename(dir, name, 0, &fname);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (current != F2FS_I(dir)->task) {\n\t\tde = __f2fs_find_entry(dir, &fname, &page);\n\t\tF2FS_I(dir)->task = NULL;\n\t}\n\tif (de) {\n\t\tf2fs_put_page(page, 0);\n\t\terr = -EEXIST;\n\t} else if (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t} else {\n\t\terr = f2fs_add_dentry(dir, &fname, inode, ino, mode);\n\t}\n\tf2fs_free_filename(&fname);\n\treturn err;\n}\n\nint f2fs_do_tmpfile(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tf2fs_down_write(&F2FS_I(inode)->i_sem);\n\tpage = f2fs_init_inode_metadata(inode, dir, NULL, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\tf2fs_put_page(page, 1);\n\n\tclear_inode_flag(inode, FI_NEW_INODE);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\nfail:\n\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\treturn err;\n}\n\nvoid f2fs_drop_nlink(struct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tf2fs_down_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tf2fs_i_links_write(dir, false);\n\tinode_set_ctime_current(inode);\n\n\tf2fs_i_links_write(inode, false);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tf2fs_i_links_write(inode, false);\n\t\tf2fs_i_size_write(inode, 0);\n\t}\n\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\n\tif (inode->i_nlink == 0)\n\t\tf2fs_add_orphan_inode(inode);\n\telse\n\t\tf2fs_release_orphan_inode(sbi);\n}\n\n \nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tf2fs_update_time(F2FS_I_SB(dir), REQ_TIME);\n\n\tif (F2FS_OPTION(F2FS_I_SB(dir)).fsync_mode == FSYNC_MODE_STRICT)\n\t\tf2fs_add_ino_entry(F2FS_I_SB(dir), dir->i_ino, TRANS_DIR_INO);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\t__clear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t \n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tset_page_dirty(page);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK &&\n\t\t!f2fs_truncate_hole(dir, page->index, page->index + 1)) {\n\t\tf2fs_clear_page_cache_dirty_tag(page);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tclear_page_private_all(page);\n\n\t\tinode_dec_dirty_pages(dir);\n\t\tf2fs_remove_dirty_inode(dir);\n\t}\n\tf2fs_put_page(page, 1);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tf2fs_mark_inode_dirty_sync(dir, false);\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode);\n}\n\nbool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx = 0;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\twhile (bidx < nblock) {\n\t\tpgoff_t next_pgofs;\n\n\t\tdentry_page = f2fs_find_data_page(dir, bidx, &next_pgofs);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT) {\n\t\t\t\tbidx = next_pgofs;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tdentry_blk = page_address(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\n\t\tf2fs_put_page(dentry_page, 0);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\n\t\tbidx++;\n\t}\n\treturn true;\n}\n\nint f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\tunsigned int start_pos, struct fscrypt_str *fstr)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\tstruct fscrypt_str de_name = FSTR_INIT(NULL, 0);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(d->inode);\n\tstruct blk_plug plug;\n\tbool readdir_ra = sbi->readdir_ra;\n\tbool found_valid_dirent = false;\n\tint err = 0;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\tif (readdir_ra)\n\t\tblk_start_plug(&plug);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->name_len == 0) {\n\t\t\tif (found_valid_dirent || !bit_pos) {\n\t\t\t\tprintk_ratelimited(\n\t\t\t\t\t\"%sF2FS-fs (%s): invalid namelen(0), ino:%u, run fsck to fix.\",\n\t\t\t\t\tKERN_WARNING, sbi->sb->s_id,\n\t\t\t\t\tle32_to_cpu(de->ino));\n\t\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\t}\n\t\t\tbit_pos++;\n\t\t\tctx->pos = start_pos + bit_pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\td_type = fs_ftype_to_dtype(de->file_type);\n\n\t\tde_name.name = d->filename[bit_pos];\n\t\tde_name.len = le16_to_cpu(de->name_len);\n\n\t\t \n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tif (unlikely(bit_pos > d->max ||\n\t\t\t\tle16_to_cpu(de->name_len) > F2FS_NAME_LEN)) {\n\t\t\tf2fs_warn(sbi, \"%s: corrupted namelen=%d, run fsck to fix.\",\n\t\t\t\t  __func__, le16_to_cpu(de->name_len));\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_DIRENT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (IS_ENCRYPTED(d->inode)) {\n\t\t\tint save_len = fstr->len;\n\n\t\t\terr = fscrypt_fname_disk_to_usr(d->inode,\n\t\t\t\t\t\t(u32)le32_to_cpu(de->hash_code),\n\t\t\t\t\t\t0, &de_name, fstr);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tde_name = *fstr;\n\t\t\tfstr->len = save_len;\n\t\t}\n\n\t\tif (!dir_emit(ctx, de_name.name, de_name.len,\n\t\t\t\t\tle32_to_cpu(de->ino), d_type)) {\n\t\t\terr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (readdir_ra)\n\t\t\tf2fs_ra_node_page(sbi, le32_to_cpu(de->ino));\n\n\t\tctx->pos = start_pos + bit_pos;\n\t\tfound_valid_dirent = true;\n\t}\nout:\n\tif (readdir_ra)\n\t\tblk_finish_plug(&plug);\n\treturn err;\n}\n\nstatic int f2fs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned long npages = dir_blocks(inode);\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tstruct page *dentry_page = NULL;\n\tstruct file_ra_state *ra = &file->f_ra;\n\tloff_t start_pos = ctx->pos;\n\tunsigned int n = ((unsigned long)ctx->pos / NR_DENTRY_IN_BLOCK);\n\tstruct f2fs_dentry_ptr d;\n\tstruct fscrypt_str fstr = FSTR_INIT(NULL, 0);\n\tint err = 0;\n\n\tif (IS_ENCRYPTED(inode)) {\n\t\terr = fscrypt_prepare_readdir(inode);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fscrypt_fname_alloc_buffer(F2FS_NAME_LEN, &fstr);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode)) {\n\t\terr = f2fs_read_inline_dir(file, ctx, &fstr);\n\t\tgoto out_free;\n\t}\n\n\tfor (; n < npages; ctx->pos = n * NR_DENTRY_IN_BLOCK) {\n\t\tpgoff_t next_pgofs;\n\n\t\t \n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto out_free;\n\t\t}\n\t\tcond_resched();\n\n\t\t \n\t\tif (npages - n > 1 && !ra_has_index(ra, n))\n\t\t\tpage_cache_sync_readahead(inode->i_mapping, ra, file, n,\n\t\t\t\tmin(npages - n, (pgoff_t)MAX_DIR_RA_PAGES));\n\n\t\tdentry_page = f2fs_find_data_page(inode, n, &next_pgofs);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\terr = PTR_ERR(dentry_page);\n\t\t\tif (err == -ENOENT) {\n\t\t\t\terr = 0;\n\t\t\t\tn = next_pgofs;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\n\t\tdentry_blk = page_address(dentry_page);\n\n\t\tmake_dentry_ptr_block(inode, &d, dentry_blk);\n\n\t\terr = f2fs_fill_dentries(ctx, &d,\n\t\t\t\tn * NR_DENTRY_IN_BLOCK, &fstr);\n\t\tif (err) {\n\t\t\tf2fs_put_page(dentry_page, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tf2fs_put_page(dentry_page, 0);\n\n\t\tn++;\n\t}\nout_free:\n\tfscrypt_fname_free_buffer(&fstr);\nout:\n\ttrace_f2fs_readdir(inode, start_pos, ctx->pos, err);\n\treturn err < 0 ? err : 0;\n}\n\nconst struct file_operations f2fs_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= f2fs_readdir,\n\t.fsync\t\t= f2fs_sync_file,\n\t.unlocked_ioctl\t= f2fs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = f2fs_compat_ioctl,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}