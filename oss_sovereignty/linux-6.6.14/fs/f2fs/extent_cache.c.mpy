{
  "module_name": "extent_cache.c",
  "hash_id": "f360e756a2e0e23c2210062e159d156afc4d2bf4e09581ad5f4f4a68803b2eb2",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/extent_cache.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include <trace/events/f2fs.h>\n\nbool sanity_check_extent_cache(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct extent_tree *et = fi->extent_tree[EX_READ];\n\tstruct extent_info *ei;\n\n\tif (!et)\n\t\treturn true;\n\n\tei = &et->largest;\n\tif (!ei->len)\n\t\treturn true;\n\n\t \n\tif (is_set_ckpt_flags(sbi, CP_ERROR_FLAG)) {\n\t\tei->len = 0;\n\t\tet->largest_updated = true;\n\t\treturn true;\n\t}\n\n\tif (!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC_ENHANCE) ||\n\t    !f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, \"%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix\",\n\t\t\t  __func__, inode->i_ino,\n\t\t\t  ei->blk, ei->fofs, ei->len);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void __set_extent_info(struct extent_info *ei,\n\t\t\t\tunsigned int fofs, unsigned int len,\n\t\t\t\tblock_t blk, bool keep_clen,\n\t\t\t\tunsigned long age, unsigned long last_blocks,\n\t\t\t\tenum extent_type type)\n{\n\tei->fofs = fofs;\n\tei->len = len;\n\n\tif (type == EX_READ) {\n\t\tei->blk = blk;\n\t\tif (keep_clen)\n\t\t\treturn;\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t\tei->c_len = 0;\n#endif\n\t} else if (type == EX_BLOCK_AGE) {\n\t\tei->age = age;\n\t\tei->last_blocks = last_blocks;\n\t}\n}\n\nstatic bool __init_may_extent_tree(struct inode *inode, enum extent_type type)\n{\n\tif (type == EX_READ)\n\t\treturn test_opt(F2FS_I_SB(inode), READ_EXTENT_CACHE) &&\n\t\t\tS_ISREG(inode->i_mode);\n\tif (type == EX_BLOCK_AGE)\n\t\treturn test_opt(F2FS_I_SB(inode), AGE_EXTENT_CACHE) &&\n\t\t\t(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode));\n\treturn false;\n}\n\nstatic bool __may_extent_tree(struct inode *inode, enum extent_type type)\n{\n\t \n\tif (list_empty(&F2FS_I_SB(inode)->s_list))\n\t\treturn false;\n\n\tif (!__init_may_extent_tree(inode, type))\n\t\treturn false;\n\n\tif (type == EX_READ) {\n\t\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\t\treturn false;\n\t\tif (is_inode_flag_set(inode, FI_COMPRESSED_FILE) &&\n\t\t\t\t !f2fs_sb_has_readonly(F2FS_I_SB(inode)))\n\t\t\treturn false;\n\t} else if (type == EX_BLOCK_AGE) {\n\t\tif (is_inode_flag_set(inode, FI_COMPRESSED_FILE))\n\t\t\treturn false;\n\t\tif (file_is_cold(inode))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void __try_update_largest_extent(struct extent_tree *et,\n\t\t\t\t\t\tstruct extent_node *en)\n{\n\tif (et->type != EX_READ)\n\t\treturn;\n\tif (en->ei.len <= et->largest.len)\n\t\treturn;\n\n\tet->largest = en->ei;\n\tet->largest_updated = true;\n}\n\nstatic bool __is_extent_mergeable(struct extent_info *back,\n\t\tstruct extent_info *front, enum extent_type type)\n{\n\tif (type == EX_READ) {\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t\tif (back->c_len && back->len != back->c_len)\n\t\t\treturn false;\n\t\tif (front->c_len && front->len != front->c_len)\n\t\t\treturn false;\n#endif\n\t\treturn (back->fofs + back->len == front->fofs &&\n\t\t\t\tback->blk + back->len == front->blk);\n\t} else if (type == EX_BLOCK_AGE) {\n\t\treturn (back->fofs + back->len == front->fofs &&\n\t\t\tabs(back->age - front->age) <= SAME_AGE_REGION &&\n\t\t\tabs(back->last_blocks - front->last_blocks) <=\n\t\t\t\t\t\t\tSAME_AGE_REGION);\n\t}\n\treturn false;\n}\n\nstatic bool __is_back_mergeable(struct extent_info *cur,\n\t\tstruct extent_info *back, enum extent_type type)\n{\n\treturn __is_extent_mergeable(back, cur, type);\n}\n\nstatic bool __is_front_mergeable(struct extent_info *cur,\n\t\tstruct extent_info *front, enum extent_type type)\n{\n\treturn __is_extent_mergeable(cur, front, type);\n}\n\nstatic struct extent_node *__lookup_extent_node(struct rb_root_cached *root,\n\t\t\tstruct extent_node *cached_en, unsigned int fofs)\n{\n\tstruct rb_node *node = root->rb_root.rb_node;\n\tstruct extent_node *en;\n\n\t \n\tif (cached_en && cached_en->ei.fofs <= fofs &&\n\t\t\tcached_en->ei.fofs + cached_en->ei.len > fofs)\n\t\treturn cached_en;\n\n\t \n\twhile (node) {\n\t\ten = rb_entry(node, struct extent_node, rb_node);\n\n\t\tif (fofs < en->ei.fofs)\n\t\t\tnode = node->rb_left;\n\t\telse if (fofs >= en->ei.fofs + en->ei.len)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn en;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct extent_node *__lookup_extent_node_ret(struct rb_root_cached *root,\n\t\t\t\tstruct extent_node *cached_en,\n\t\t\t\tunsigned int fofs,\n\t\t\t\tstruct extent_node **prev_entry,\n\t\t\t\tstruct extent_node **next_entry,\n\t\t\t\tstruct rb_node ***insert_p,\n\t\t\t\tstruct rb_node **insert_parent,\n\t\t\t\tbool *leftmost)\n{\n\tstruct rb_node **pnode = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL, *tmp_node;\n\tstruct extent_node *en = cached_en;\n\n\t*insert_p = NULL;\n\t*insert_parent = NULL;\n\t*prev_entry = NULL;\n\t*next_entry = NULL;\n\n\tif (RB_EMPTY_ROOT(&root->rb_root))\n\t\treturn NULL;\n\n\tif (en && en->ei.fofs <= fofs && en->ei.fofs + en->ei.len > fofs)\n\t\tgoto lookup_neighbors;\n\n\t*leftmost = true;\n\n\twhile (*pnode) {\n\t\tparent = *pnode;\n\t\ten = rb_entry(*pnode, struct extent_node, rb_node);\n\n\t\tif (fofs < en->ei.fofs) {\n\t\t\tpnode = &(*pnode)->rb_left;\n\t\t} else if (fofs >= en->ei.fofs + en->ei.len) {\n\t\t\tpnode = &(*pnode)->rb_right;\n\t\t\t*leftmost = false;\n\t\t} else {\n\t\t\tgoto lookup_neighbors;\n\t\t}\n\t}\n\n\t*insert_p = pnode;\n\t*insert_parent = parent;\n\n\ten = rb_entry(parent, struct extent_node, rb_node);\n\ttmp_node = parent;\n\tif (parent && fofs > en->ei.fofs)\n\t\ttmp_node = rb_next(parent);\n\t*next_entry = rb_entry_safe(tmp_node, struct extent_node, rb_node);\n\n\ttmp_node = parent;\n\tif (parent && fofs < en->ei.fofs)\n\t\ttmp_node = rb_prev(parent);\n\t*prev_entry = rb_entry_safe(tmp_node, struct extent_node, rb_node);\n\treturn NULL;\n\nlookup_neighbors:\n\tif (fofs == en->ei.fofs) {\n\t\t \n\t\ttmp_node = rb_prev(&en->rb_node);\n\t\t*prev_entry = rb_entry_safe(tmp_node,\n\t\t\t\t\tstruct extent_node, rb_node);\n\t}\n\tif (fofs == en->ei.fofs + en->ei.len - 1) {\n\t\t \n\t\ttmp_node = rb_next(&en->rb_node);\n\t\t*next_entry = rb_entry_safe(tmp_node,\n\t\t\t\t\tstruct extent_node, rb_node);\n\t}\n\treturn en;\n}\n\nstatic struct kmem_cache *extent_tree_slab;\nstatic struct kmem_cache *extent_node_slab;\n\nstatic struct extent_node *__attach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node *parent, struct rb_node **p,\n\t\t\t\tbool leftmost)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[et->type];\n\tstruct extent_node *en;\n\n\ten = f2fs_kmem_cache_alloc(extent_node_slab, GFP_ATOMIC, false, sbi);\n\tif (!en)\n\t\treturn NULL;\n\n\ten->ei = *ei;\n\tINIT_LIST_HEAD(&en->list);\n\ten->et = et;\n\n\trb_link_node(&en->rb_node, parent, p);\n\trb_insert_color_cached(&en->rb_node, &et->root, leftmost);\n\tatomic_inc(&et->node_cnt);\n\tatomic_inc(&eti->total_ext_node);\n\treturn en;\n}\n\nstatic void __detach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[et->type];\n\n\trb_erase_cached(&en->rb_node, &et->root);\n\tatomic_dec(&et->node_cnt);\n\tatomic_dec(&eti->total_ext_node);\n\n\tif (et->cached_en == en)\n\t\tet->cached_en = NULL;\n\tkmem_cache_free(extent_node_slab, en);\n}\n\n \nstatic void __release_extent_node(struct f2fs_sb_info *sbi,\n\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[et->type];\n\n\tspin_lock(&eti->extent_lock);\n\tf2fs_bug_on(sbi, list_empty(&en->list));\n\tlist_del_init(&en->list);\n\tspin_unlock(&eti->extent_lock);\n\n\t__detach_extent_node(sbi, et, en);\n}\n\nstatic struct extent_tree *__grab_extent_tree(struct inode *inode,\n\t\t\t\t\t\tenum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree_info *eti = &sbi->extent_tree[type];\n\tstruct extent_tree *et;\n\tnid_t ino = inode->i_ino;\n\n\tmutex_lock(&eti->extent_tree_lock);\n\tet = radix_tree_lookup(&eti->extent_tree_root, ino);\n\tif (!et) {\n\t\tet = f2fs_kmem_cache_alloc(extent_tree_slab,\n\t\t\t\t\tGFP_NOFS, true, NULL);\n\t\tf2fs_radix_tree_insert(&eti->extent_tree_root, ino, et);\n\t\tmemset(et, 0, sizeof(struct extent_tree));\n\t\tet->ino = ino;\n\t\tet->type = type;\n\t\tet->root = RB_ROOT_CACHED;\n\t\tet->cached_en = NULL;\n\t\trwlock_init(&et->lock);\n\t\tINIT_LIST_HEAD(&et->list);\n\t\tatomic_set(&et->node_cnt, 0);\n\t\tatomic_inc(&eti->total_ext_tree);\n\t} else {\n\t\tatomic_dec(&eti->total_zombie_tree);\n\t\tlist_del_init(&et->list);\n\t}\n\tmutex_unlock(&eti->extent_tree_lock);\n\n\t \n\tF2FS_I(inode)->extent_tree[type] = et;\n\n\treturn et;\n}\n\nstatic unsigned int __free_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct extent_tree *et)\n{\n\tstruct rb_node *node, *next;\n\tstruct extent_node *en;\n\tunsigned int count = atomic_read(&et->node_cnt);\n\n\tnode = rb_first_cached(&et->root);\n\twhile (node) {\n\t\tnext = rb_next(node);\n\t\ten = rb_entry(node, struct extent_node, rb_node);\n\t\t__release_extent_node(sbi, et, en);\n\t\tnode = next;\n\t}\n\n\treturn count - atomic_read(&et->node_cnt);\n}\n\nstatic void __drop_largest_extent(struct extent_tree *et,\n\t\t\t\t\tpgoff_t fofs, unsigned int len)\n{\n\tif (fofs < et->largest.fofs + et->largest.len &&\n\t\t\tfofs + len > et->largest.fofs) {\n\t\tet->largest.len = 0;\n\t\tet->largest_updated = true;\n\t}\n}\n\nvoid f2fs_init_read_extent_tree(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree_info *eti = &sbi->extent_tree[EX_READ];\n\tstruct f2fs_extent *i_ext = &F2FS_INODE(ipage)->i_ext;\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!__may_extent_tree(inode, EX_READ)) {\n\t\t \n\t\tif (i_ext && i_ext->len) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\t\t\ti_ext->len = 0;\n\t\t\tset_page_dirty(ipage);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tet = __grab_extent_tree(inode, EX_READ);\n\n\tif (!i_ext || !i_ext->len)\n\t\tgoto out;\n\n\tget_read_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto unlock_out;\n\n\ten = __attach_extent_node(sbi, et, &ei, NULL,\n\t\t\t\t&et->root.rb_root.rb_node, true);\n\tif (en) {\n\t\tet->largest = en->ei;\n\t\tet->cached_en = en;\n\n\t\tspin_lock(&eti->extent_lock);\n\t\tlist_add_tail(&en->list, &eti->extent_list);\n\t\tspin_unlock(&eti->extent_lock);\n\t}\nunlock_out:\n\twrite_unlock(&et->lock);\nout:\n\tif (!F2FS_I(inode)->extent_tree[EX_READ])\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n}\n\nvoid f2fs_init_age_extent_tree(struct inode *inode)\n{\n\tif (!__init_may_extent_tree(inode, EX_BLOCK_AGE))\n\t\treturn;\n\t__grab_extent_tree(inode, EX_BLOCK_AGE);\n}\n\nvoid f2fs_init_extent_tree(struct inode *inode)\n{\n\t \n\tif (__init_may_extent_tree(inode, EX_READ))\n\t\t__grab_extent_tree(inode, EX_READ);\n\n\t \n\tif (__init_may_extent_tree(inode, EX_BLOCK_AGE))\n\t\t__grab_extent_tree(inode, EX_BLOCK_AGE);\n}\n\nstatic bool __lookup_extent_tree(struct inode *inode, pgoff_t pgofs,\n\t\t\tstruct extent_info *ei, enum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree_info *eti = &sbi->extent_tree[type];\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[type];\n\tstruct extent_node *en;\n\tbool ret = false;\n\n\tif (!et)\n\t\treturn false;\n\n\ttrace_f2fs_lookup_extent_tree_start(inode, pgofs, type);\n\n\tread_lock(&et->lock);\n\n\tif (type == EX_READ &&\n\t\t\tet->largest.fofs <= pgofs &&\n\t\t\tet->largest.fofs + et->largest.len > pgofs) {\n\t\t*ei = et->largest;\n\t\tret = true;\n\t\tstat_inc_largest_node_hit(sbi);\n\t\tgoto out;\n\t}\n\n\ten = __lookup_extent_node(&et->root, et->cached_en, pgofs);\n\tif (!en)\n\t\tgoto out;\n\n\tif (en == et->cached_en)\n\t\tstat_inc_cached_node_hit(sbi, type);\n\telse\n\t\tstat_inc_rbtree_node_hit(sbi, type);\n\n\t*ei = en->ei;\n\tspin_lock(&eti->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &eti->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&eti->extent_lock);\n\tret = true;\nout:\n\tstat_inc_total_hit(sbi, type);\n\tread_unlock(&et->lock);\n\n\tif (type == EX_READ)\n\t\ttrace_f2fs_lookup_read_extent_tree_end(inode, pgofs, ei);\n\telse if (type == EX_BLOCK_AGE)\n\t\ttrace_f2fs_lookup_age_extent_tree_end(inode, pgofs, ei);\n\treturn ret;\n}\n\nstatic struct extent_node *__try_merge_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct extent_node *prev_ex,\n\t\t\t\tstruct extent_node *next_ex)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[et->type];\n\tstruct extent_node *en = NULL;\n\n\tif (prev_ex && __is_back_mergeable(ei, &prev_ex->ei, et->type)) {\n\t\tprev_ex->ei.len += ei->len;\n\t\tei = &prev_ex->ei;\n\t\ten = prev_ex;\n\t}\n\n\tif (next_ex && __is_front_mergeable(ei, &next_ex->ei, et->type)) {\n\t\tnext_ex->ei.fofs = ei->fofs;\n\t\tnext_ex->ei.len += ei->len;\n\t\tif (et->type == EX_READ)\n\t\t\tnext_ex->ei.blk = ei->blk;\n\t\tif (en)\n\t\t\t__release_extent_node(sbi, et, prev_ex);\n\n\t\ten = next_ex;\n\t}\n\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(et, en);\n\n\tspin_lock(&eti->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &eti->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&eti->extent_lock);\n\treturn en;\n}\n\nstatic struct extent_node *__insert_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node **insert_p,\n\t\t\t\tstruct rb_node *insert_parent,\n\t\t\t\tbool leftmost)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[et->type];\n\tstruct rb_node **p = &et->root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_node *en = NULL;\n\n\tif (insert_p && insert_parent) {\n\t\tparent = insert_parent;\n\t\tp = insert_p;\n\t\tgoto do_insert;\n\t}\n\n\tleftmost = true;\n\n\t \n\twhile (*p) {\n\t\tparent = *p;\n\t\ten = rb_entry(parent, struct extent_node, rb_node);\n\n\t\tif (ei->fofs < en->ei.fofs) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ei->fofs >= en->ei.fofs + en->ei.len) {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t} else {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t}\n\t}\n\ndo_insert:\n\ten = __attach_extent_node(sbi, et, ei, parent, p, leftmost);\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(et, en);\n\n\t \n\tspin_lock(&eti->extent_lock);\n\tlist_add_tail(&en->list, &eti->extent_list);\n\tet->cached_en = en;\n\tspin_unlock(&eti->extent_lock);\n\treturn en;\n}\n\nstatic void __update_extent_tree_range(struct inode *inode,\n\t\t\tstruct extent_info *tei, enum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[type];\n\tstruct extent_node *en = NULL, *en1 = NULL;\n\tstruct extent_node *prev_en = NULL, *next_en = NULL;\n\tstruct extent_info ei, dei, prev;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tunsigned int fofs = tei->fofs, len = tei->len;\n\tunsigned int end = fofs + len;\n\tbool updated = false;\n\tbool leftmost = false;\n\n\tif (!et)\n\t\treturn;\n\n\tif (type == EX_READ)\n\t\ttrace_f2fs_update_read_extent_tree_range(inode, fofs, len,\n\t\t\t\t\t\ttei->blk, 0);\n\telse if (type == EX_BLOCK_AGE)\n\t\ttrace_f2fs_update_age_extent_tree_range(inode, fofs, len,\n\t\t\t\t\t\ttei->age, tei->last_blocks);\n\n\twrite_lock(&et->lock);\n\n\tif (type == EX_READ) {\n\t\tif (is_inode_flag_set(inode, FI_NO_EXTENT)) {\n\t\t\twrite_unlock(&et->lock);\n\t\t\treturn;\n\t\t}\n\n\t\tprev = et->largest;\n\t\tdei.len = 0;\n\n\t\t \n\t\t__drop_largest_extent(et, fofs, len);\n\t}\n\n\t \n\ten = __lookup_extent_node_ret(&et->root,\n\t\t\t\t\tet->cached_en, fofs,\n\t\t\t\t\t&prev_en, &next_en,\n\t\t\t\t\t&insert_p, &insert_parent,\n\t\t\t\t\t&leftmost);\n\tif (!en)\n\t\ten = next_en;\n\n\t \n\twhile (en && en->ei.fofs < end) {\n\t\tunsigned int org_end;\n\t\tint parts = 0;\t \n\n\t\tnext_en = en1 = NULL;\n\n\t\tdei = en->ei;\n\t\torg_end = dei.fofs + dei.len;\n\t\tf2fs_bug_on(sbi, fofs >= org_end);\n\n\t\tif (fofs > dei.fofs && (type != EX_READ ||\n\t\t\t\tfofs - dei.fofs >= F2FS_MIN_EXTENT_LEN)) {\n\t\t\ten->ei.len = fofs - en->ei.fofs;\n\t\t\tprev_en = en;\n\t\t\tparts = 1;\n\t\t}\n\n\t\tif (end < org_end && (type != EX_READ ||\n\t\t\t\torg_end - end >= F2FS_MIN_EXTENT_LEN)) {\n\t\t\tif (parts) {\n\t\t\t\t__set_extent_info(&ei,\n\t\t\t\t\tend, org_end - end,\n\t\t\t\t\tend - dei.fofs + dei.blk, false,\n\t\t\t\t\tdei.age, dei.last_blocks,\n\t\t\t\t\ttype);\n\t\t\t\ten1 = __insert_extent_tree(sbi, et, &ei,\n\t\t\t\t\t\t\tNULL, NULL, true);\n\t\t\t\tnext_en = en1;\n\t\t\t} else {\n\t\t\t\t__set_extent_info(&en->ei,\n\t\t\t\t\tend, en->ei.len - (end - dei.fofs),\n\t\t\t\t\ten->ei.blk + (end - dei.fofs), true,\n\t\t\t\t\tdei.age, dei.last_blocks,\n\t\t\t\t\ttype);\n\t\t\t\tnext_en = en;\n\t\t\t}\n\t\t\tparts++;\n\t\t}\n\n\t\tif (!next_en) {\n\t\t\tstruct rb_node *node = rb_next(&en->rb_node);\n\n\t\t\tnext_en = rb_entry_safe(node, struct extent_node,\n\t\t\t\t\t\trb_node);\n\t\t}\n\n\t\tif (parts)\n\t\t\t__try_update_largest_extent(et, en);\n\t\telse\n\t\t\t__release_extent_node(sbi, et, en);\n\n\t\t \n\t\tif (parts != 1) {\n\t\t\tinsert_p = NULL;\n\t\t\tinsert_parent = NULL;\n\t\t}\n\t\ten = next_en;\n\t}\n\n\tif (type == EX_BLOCK_AGE)\n\t\tgoto update_age_extent_cache;\n\n\t \n\tBUG_ON(type != EX_READ);\n\n\tif (tei->blk) {\n\t\t__set_extent_info(&ei, fofs, len, tei->blk, false,\n\t\t\t\t  0, 0, EX_READ);\n\t\tif (!__try_merge_extent_node(sbi, et, &ei, prev_en, next_en))\n\t\t\t__insert_extent_tree(sbi, et, &ei,\n\t\t\t\t\tinsert_p, insert_parent, leftmost);\n\n\t\t \n\t\tif (dei.len >= 1 &&\n\t\t\t\tprev.len < F2FS_MIN_EXTENT_LEN &&\n\t\t\t\tet->largest.len < F2FS_MIN_EXTENT_LEN) {\n\t\t\tet->largest.len = 0;\n\t\t\tet->largest_updated = true;\n\t\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\t\t}\n\t}\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\t__free_extent_tree(sbi, et);\n\n\tif (et->largest_updated) {\n\t\tet->largest_updated = false;\n\t\tupdated = true;\n\t}\n\tgoto out_read_extent_cache;\nupdate_age_extent_cache:\n\tif (!tei->last_blocks)\n\t\tgoto out_read_extent_cache;\n\n\t__set_extent_info(&ei, fofs, len, 0, false,\n\t\t\ttei->age, tei->last_blocks, EX_BLOCK_AGE);\n\tif (!__try_merge_extent_node(sbi, et, &ei, prev_en, next_en))\n\t\t__insert_extent_tree(sbi, et, &ei,\n\t\t\t\t\tinsert_p, insert_parent, leftmost);\nout_read_extent_cache:\n\twrite_unlock(&et->lock);\n\n\tif (updated)\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\nvoid f2fs_update_read_extent_tree_range_compressed(struct inode *inode,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int llen,\n\t\t\t\tunsigned int c_len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[EX_READ];\n\tstruct extent_node *en = NULL;\n\tstruct extent_node *prev_en = NULL, *next_en = NULL;\n\tstruct extent_info ei;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tbool leftmost = false;\n\n\ttrace_f2fs_update_read_extent_tree_range(inode, fofs, llen,\n\t\t\t\t\t\tblkaddr, c_len);\n\n\t \n\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\treturn;\n\n\twrite_lock(&et->lock);\n\n\ten = __lookup_extent_node_ret(&et->root,\n\t\t\t\t\tet->cached_en, fofs,\n\t\t\t\t\t&prev_en, &next_en,\n\t\t\t\t\t&insert_p, &insert_parent,\n\t\t\t\t\t&leftmost);\n\tif (en)\n\t\tgoto unlock_out;\n\n\t__set_extent_info(&ei, fofs, llen, blkaddr, true, 0, 0, EX_READ);\n\tei.c_len = c_len;\n\n\tif (!__try_merge_extent_node(sbi, et, &ei, prev_en, next_en))\n\t\t__insert_extent_tree(sbi, et, &ei,\n\t\t\t\tinsert_p, insert_parent, leftmost);\nunlock_out:\n\twrite_unlock(&et->lock);\n}\n#endif\n\nstatic unsigned long long __calculate_block_age(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned long long new,\n\t\t\t\t\t\tunsigned long long old)\n{\n\tunsigned int rem_old, rem_new;\n\tunsigned long long res;\n\tunsigned int weight = sbi->last_age_weight;\n\n\tres = div_u64_rem(new, 100, &rem_new) * (100 - weight)\n\t\t+ div_u64_rem(old, 100, &rem_old) * weight;\n\n\tif (rem_new)\n\t\tres += rem_new * (100 - weight) / 100;\n\tif (rem_old)\n\t\tres += rem_old * weight / 100;\n\n\treturn res;\n}\n\n \nstatic int __get_new_block_age(struct inode *inode, struct extent_info *ei,\n\t\t\t\t\t\tblock_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tloff_t f_size = i_size_read(inode);\n\tunsigned long long cur_blocks =\n\t\t\t\tatomic64_read(&sbi->allocated_data_blocks);\n\tstruct extent_info tei = *ei;\t \n\n\t \n\tif ((f_size >> PAGE_SHIFT) == ei->fofs && f_size & (PAGE_SIZE - 1) &&\n\t\t\tblkaddr == NEW_ADDR)\n\t\treturn -EINVAL;\n\n\tif (__lookup_extent_tree(inode, ei->fofs, &tei, EX_BLOCK_AGE)) {\n\t\tunsigned long long cur_age;\n\n\t\tif (cur_blocks >= tei.last_blocks)\n\t\t\tcur_age = cur_blocks - tei.last_blocks;\n\t\telse\n\t\t\t \n\t\t\tcur_age = ULLONG_MAX - tei.last_blocks + cur_blocks;\n\n\t\tif (tei.age)\n\t\t\tei->age = __calculate_block_age(sbi, cur_age, tei.age);\n\t\telse\n\t\t\tei->age = cur_age;\n\t\tei->last_blocks = cur_blocks;\n\t\tWARN_ON(ei->age > cur_blocks);\n\t\treturn 0;\n\t}\n\n\tf2fs_bug_on(sbi, blkaddr == NULL_ADDR);\n\n\t \n\tif (blkaddr == NEW_ADDR)\n\t\tgoto out;\n\n\tif (__is_valid_data_blkaddr(blkaddr) &&\n\t    !f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC_ENHANCE)) {\n\t\tf2fs_bug_on(sbi, 1);\n\t\treturn -EINVAL;\n\t}\nout:\n\t \n\tei->age = 0;\n\tei->last_blocks = cur_blocks;\n\treturn 0;\n}\n\nstatic void __update_extent_cache(struct dnode_of_data *dn, enum extent_type type)\n{\n\tstruct extent_info ei = {};\n\n\tif (!__may_extent_tree(dn->inode, type))\n\t\treturn;\n\n\tei.fofs = f2fs_start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +\n\t\t\t\t\t\t\t\tdn->ofs_in_node;\n\tei.len = 1;\n\n\tif (type == EX_READ) {\n\t\tif (dn->data_blkaddr == NEW_ADDR)\n\t\t\tei.blk = NULL_ADDR;\n\t\telse\n\t\t\tei.blk = dn->data_blkaddr;\n\t} else if (type == EX_BLOCK_AGE) {\n\t\tif (__get_new_block_age(dn->inode, &ei, dn->data_blkaddr))\n\t\t\treturn;\n\t}\n\t__update_extent_tree_range(dn->inode, &ei, type);\n}\n\nstatic unsigned int __shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink,\n\t\t\t\t\tenum extent_type type)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[type];\n\tstruct extent_tree *et, *next;\n\tstruct extent_node *en;\n\tunsigned int node_cnt = 0, tree_cnt = 0;\n\tint remained;\n\n\tif (!atomic_read(&eti->total_zombie_tree))\n\t\tgoto free_node;\n\n\tif (!mutex_trylock(&eti->extent_tree_lock))\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry_safe(et, next, &eti->zombie_list, list) {\n\t\tif (atomic_read(&et->node_cnt)) {\n\t\t\twrite_lock(&et->lock);\n\t\t\tnode_cnt += __free_extent_tree(sbi, et);\n\t\t\twrite_unlock(&et->lock);\n\t\t}\n\t\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\t\tlist_del_init(&et->list);\n\t\tradix_tree_delete(&eti->extent_tree_root, et->ino);\n\t\tkmem_cache_free(extent_tree_slab, et);\n\t\tatomic_dec(&eti->total_ext_tree);\n\t\tatomic_dec(&eti->total_zombie_tree);\n\t\ttree_cnt++;\n\n\t\tif (node_cnt + tree_cnt >= nr_shrink)\n\t\t\tgoto unlock_out;\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&eti->extent_tree_lock);\n\nfree_node:\n\t \n\tif (!mutex_trylock(&eti->extent_tree_lock))\n\t\tgoto out;\n\n\tremained = nr_shrink - (node_cnt + tree_cnt);\n\n\tspin_lock(&eti->extent_lock);\n\tfor (; remained > 0; remained--) {\n\t\tif (list_empty(&eti->extent_list))\n\t\t\tbreak;\n\t\ten = list_first_entry(&eti->extent_list,\n\t\t\t\t\tstruct extent_node, list);\n\t\tet = en->et;\n\t\tif (!write_trylock(&et->lock)) {\n\t\t\t \n\t\t\tlist_move_tail(&en->list, &eti->extent_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del_init(&en->list);\n\t\tspin_unlock(&eti->extent_lock);\n\n\t\t__detach_extent_node(sbi, et, en);\n\n\t\twrite_unlock(&et->lock);\n\t\tnode_cnt++;\n\t\tspin_lock(&eti->extent_lock);\n\t}\n\tspin_unlock(&eti->extent_lock);\n\nunlock_out:\n\tmutex_unlock(&eti->extent_tree_lock);\nout:\n\ttrace_f2fs_shrink_extent_tree(sbi, node_cnt, tree_cnt, type);\n\n\treturn node_cnt + tree_cnt;\n}\n\n \nbool f2fs_lookup_read_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\tstruct extent_info *ei)\n{\n\tif (!__may_extent_tree(inode, EX_READ))\n\t\treturn false;\n\n\treturn __lookup_extent_tree(inode, pgofs, ei, EX_READ);\n}\n\nbool f2fs_lookup_read_extent_cache_block(struct inode *inode, pgoff_t index,\n\t\t\t\tblock_t *blkaddr)\n{\n\tstruct extent_info ei = {};\n\n\tif (!f2fs_lookup_read_extent_cache(inode, index, &ei))\n\t\treturn false;\n\t*blkaddr = ei.blk + index - ei.fofs;\n\treturn true;\n}\n\nvoid f2fs_update_read_extent_cache(struct dnode_of_data *dn)\n{\n\treturn __update_extent_cache(dn, EX_READ);\n}\n\nvoid f2fs_update_read_extent_cache_range(struct dnode_of_data *dn,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len)\n{\n\tstruct extent_info ei = {\n\t\t.fofs = fofs,\n\t\t.len = len,\n\t\t.blk = blkaddr,\n\t};\n\n\tif (!__may_extent_tree(dn->inode, EX_READ))\n\t\treturn;\n\n\t__update_extent_tree_range(dn->inode, &ei, EX_READ);\n}\n\nunsigned int f2fs_shrink_read_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tif (!test_opt(sbi, READ_EXTENT_CACHE))\n\t\treturn 0;\n\n\treturn __shrink_extent_tree(sbi, nr_shrink, EX_READ);\n}\n\n \nbool f2fs_lookup_age_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\tstruct extent_info *ei)\n{\n\tif (!__may_extent_tree(inode, EX_BLOCK_AGE))\n\t\treturn false;\n\n\treturn __lookup_extent_tree(inode, pgofs, ei, EX_BLOCK_AGE);\n}\n\nvoid f2fs_update_age_extent_cache(struct dnode_of_data *dn)\n{\n\treturn __update_extent_cache(dn, EX_BLOCK_AGE);\n}\n\nvoid f2fs_update_age_extent_cache_range(struct dnode_of_data *dn,\n\t\t\t\tpgoff_t fofs, unsigned int len)\n{\n\tstruct extent_info ei = {\n\t\t.fofs = fofs,\n\t\t.len = len,\n\t};\n\n\tif (!__may_extent_tree(dn->inode, EX_BLOCK_AGE))\n\t\treturn;\n\n\t__update_extent_tree_range(dn->inode, &ei, EX_BLOCK_AGE);\n}\n\nunsigned int f2fs_shrink_age_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tif (!test_opt(sbi, AGE_EXTENT_CACHE))\n\t\treturn 0;\n\n\treturn __shrink_extent_tree(sbi, nr_shrink, EX_BLOCK_AGE);\n}\n\nstatic unsigned int __destroy_extent_node(struct inode *inode,\n\t\t\t\t\tenum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[type];\n\tunsigned int node_cnt = 0;\n\n\tif (!et || !atomic_read(&et->node_cnt))\n\t\treturn 0;\n\n\twrite_lock(&et->lock);\n\tnode_cnt = __free_extent_tree(sbi, et);\n\twrite_unlock(&et->lock);\n\n\treturn node_cnt;\n}\n\nvoid f2fs_destroy_extent_node(struct inode *inode)\n{\n\t__destroy_extent_node(inode, EX_READ);\n\t__destroy_extent_node(inode, EX_BLOCK_AGE);\n}\n\nstatic void __drop_extent_tree(struct inode *inode, enum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[type];\n\tbool updated = false;\n\n\tif (!__may_extent_tree(inode, type))\n\t\treturn;\n\n\twrite_lock(&et->lock);\n\t__free_extent_tree(sbi, et);\n\tif (type == EX_READ) {\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\t\tif (et->largest.len) {\n\t\t\tet->largest.len = 0;\n\t\t\tupdated = true;\n\t\t}\n\t}\n\twrite_unlock(&et->lock);\n\tif (updated)\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nvoid f2fs_drop_extent_tree(struct inode *inode)\n{\n\t__drop_extent_tree(inode, EX_READ);\n\t__drop_extent_tree(inode, EX_BLOCK_AGE);\n}\n\nstatic void __destroy_extent_tree(struct inode *inode, enum extent_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree_info *eti = &sbi->extent_tree[type];\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree[type];\n\tunsigned int node_cnt = 0;\n\n\tif (!et)\n\t\treturn;\n\n\tif (inode->i_nlink && !is_bad_inode(inode) &&\n\t\t\t\t\tatomic_read(&et->node_cnt)) {\n\t\tmutex_lock(&eti->extent_tree_lock);\n\t\tlist_add_tail(&et->list, &eti->zombie_list);\n\t\tatomic_inc(&eti->total_zombie_tree);\n\t\tmutex_unlock(&eti->extent_tree_lock);\n\t\treturn;\n\t}\n\n\t \n\tnode_cnt = __destroy_extent_node(inode, type);\n\n\t \n\tmutex_lock(&eti->extent_tree_lock);\n\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\tradix_tree_delete(&eti->extent_tree_root, inode->i_ino);\n\tkmem_cache_free(extent_tree_slab, et);\n\tatomic_dec(&eti->total_ext_tree);\n\tmutex_unlock(&eti->extent_tree_lock);\n\n\tF2FS_I(inode)->extent_tree[type] = NULL;\n\n\ttrace_f2fs_destroy_extent_tree(inode, node_cnt, type);\n}\n\nvoid f2fs_destroy_extent_tree(struct inode *inode)\n{\n\t__destroy_extent_tree(inode, EX_READ);\n\t__destroy_extent_tree(inode, EX_BLOCK_AGE);\n}\n\nstatic void __init_extent_tree_info(struct extent_tree_info *eti)\n{\n\tINIT_RADIX_TREE(&eti->extent_tree_root, GFP_NOIO);\n\tmutex_init(&eti->extent_tree_lock);\n\tINIT_LIST_HEAD(&eti->extent_list);\n\tspin_lock_init(&eti->extent_lock);\n\tatomic_set(&eti->total_ext_tree, 0);\n\tINIT_LIST_HEAD(&eti->zombie_list);\n\tatomic_set(&eti->total_zombie_tree, 0);\n\tatomic_set(&eti->total_ext_node, 0);\n}\n\nvoid f2fs_init_extent_cache_info(struct f2fs_sb_info *sbi)\n{\n\t__init_extent_tree_info(&sbi->extent_tree[EX_READ]);\n\t__init_extent_tree_info(&sbi->extent_tree[EX_BLOCK_AGE]);\n\n\t \n\tatomic64_set(&sbi->allocated_data_blocks, 0);\n\tsbi->hot_data_age_threshold = DEF_HOT_DATA_AGE_THRESHOLD;\n\tsbi->warm_data_age_threshold = DEF_WARM_DATA_AGE_THRESHOLD;\n\tsbi->last_age_weight = LAST_AGE_WEIGHT;\n}\n\nint __init f2fs_create_extent_cache(void)\n{\n\textent_tree_slab = f2fs_kmem_cache_create(\"f2fs_extent_tree\",\n\t\t\tsizeof(struct extent_tree));\n\tif (!extent_tree_slab)\n\t\treturn -ENOMEM;\n\textent_node_slab = f2fs_kmem_cache_create(\"f2fs_extent_node\",\n\t\t\tsizeof(struct extent_node));\n\tif (!extent_node_slab) {\n\t\tkmem_cache_destroy(extent_tree_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid f2fs_destroy_extent_cache(void)\n{\n\tkmem_cache_destroy(extent_node_slab);\n\tkmem_cache_destroy(extent_tree_slab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}