{
  "module_name": "shrinker.c",
  "hash_id": "f006cf781c08179d10a58a08f85f098d1e33c0fcf80a4dc58c69d7de49f89ae4",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/shrinker.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n\nstatic LIST_HEAD(f2fs_list);\nstatic DEFINE_SPINLOCK(f2fs_list_lock);\nstatic unsigned int shrinker_run_no;\n\nstatic unsigned long __count_nat_entries(struct f2fs_sb_info *sbi)\n{\n\treturn NM_I(sbi)->nat_cnt[RECLAIMABLE_NAT];\n}\n\nstatic unsigned long __count_free_nids(struct f2fs_sb_info *sbi)\n{\n\tlong count = NM_I(sbi)->nid_cnt[FREE_NID] - MAX_FREE_NIDS;\n\n\treturn count > 0 ? count : 0;\n}\n\nstatic unsigned long __count_extent_cache(struct f2fs_sb_info *sbi,\n\t\t\t\t\tenum extent_type type)\n{\n\tstruct extent_tree_info *eti = &sbi->extent_tree[type];\n\n\treturn atomic_read(&eti->total_zombie_tree) +\n\t\t\t\tatomic_read(&eti->total_ext_node);\n}\n\nunsigned long f2fs_shrink_count(struct shrinker *shrink,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tstruct f2fs_sb_info *sbi;\n\tstruct list_head *p;\n\tunsigned long count = 0;\n\n\tspin_lock(&f2fs_list_lock);\n\tp = f2fs_list.next;\n\twhile (p != &f2fs_list) {\n\t\tsbi = list_entry(p, struct f2fs_sb_info, s_list);\n\n\t\t \n\t\tif (!mutex_trylock(&sbi->umount_mutex)) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&f2fs_list_lock);\n\n\t\t \n\t\tcount += __count_extent_cache(sbi, EX_READ);\n\n\t\t \n\t\tcount += __count_extent_cache(sbi, EX_BLOCK_AGE);\n\n\t\t \n\t\tcount += __count_nat_entries(sbi);\n\n\t\t \n\t\tcount += __count_free_nids(sbi);\n\n\t\tspin_lock(&f2fs_list_lock);\n\t\tp = p->next;\n\t\tmutex_unlock(&sbi->umount_mutex);\n\t}\n\tspin_unlock(&f2fs_list_lock);\n\treturn count;\n}\n\nunsigned long f2fs_shrink_scan(struct shrinker *shrink,\n\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long nr = sc->nr_to_scan;\n\tstruct f2fs_sb_info *sbi;\n\tstruct list_head *p;\n\tunsigned int run_no;\n\tunsigned long freed = 0;\n\n\tspin_lock(&f2fs_list_lock);\n\tdo {\n\t\trun_no = ++shrinker_run_no;\n\t} while (run_no == 0);\n\tp = f2fs_list.next;\n\twhile (p != &f2fs_list) {\n\t\tsbi = list_entry(p, struct f2fs_sb_info, s_list);\n\n\t\tif (sbi->shrinker_run_no == run_no)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!mutex_trylock(&sbi->umount_mutex)) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&f2fs_list_lock);\n\n\t\tsbi->shrinker_run_no = run_no;\n\n\t\t \n\t\tfreed += f2fs_shrink_age_extent_tree(sbi, nr >> 2);\n\n\t\t \n\t\tfreed += f2fs_shrink_read_extent_tree(sbi, nr >> 2);\n\n\t\t \n\t\tif (freed < nr)\n\t\t\tfreed += f2fs_try_to_free_nats(sbi, nr - freed);\n\n\t\t \n\t\tif (freed < nr)\n\t\t\tfreed += f2fs_try_to_free_nids(sbi, nr - freed);\n\n\t\tspin_lock(&f2fs_list_lock);\n\t\tp = p->next;\n\t\tlist_move_tail(&sbi->s_list, &f2fs_list);\n\t\tmutex_unlock(&sbi->umount_mutex);\n\t\tif (freed >= nr)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&f2fs_list_lock);\n\treturn freed;\n}\n\nvoid f2fs_join_shrinker(struct f2fs_sb_info *sbi)\n{\n\tspin_lock(&f2fs_list_lock);\n\tlist_add_tail(&sbi->s_list, &f2fs_list);\n\tspin_unlock(&f2fs_list_lock);\n}\n\nvoid f2fs_leave_shrinker(struct f2fs_sb_info *sbi)\n{\n\tf2fs_shrink_read_extent_tree(sbi, __count_extent_cache(sbi, EX_READ));\n\tf2fs_shrink_age_extent_tree(sbi,\n\t\t\t\t__count_extent_cache(sbi, EX_BLOCK_AGE));\n\n\tspin_lock(&f2fs_list_lock);\n\tlist_del_init(&sbi->s_list);\n\tspin_unlock(&f2fs_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}