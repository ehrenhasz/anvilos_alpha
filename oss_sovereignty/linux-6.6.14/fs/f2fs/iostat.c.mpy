{
  "module_name": "iostat.c",
  "hash_id": "dcc8e3a6dd5277287dc71ad26696a88155b32a0767e40cd38a1515bd9c8f4a95",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/iostat.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/seq_file.h>\n\n#include \"f2fs.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n\nstatic struct kmem_cache *bio_iostat_ctx_cache;\nstatic mempool_t *bio_iostat_ctx_pool;\n\nstatic inline unsigned long long iostat_get_avg_bytes(struct f2fs_sb_info *sbi,\n\tenum iostat_type type)\n{\n\treturn sbi->iostat_count[type] ? div64_u64(sbi->iostat_bytes[type],\n\t\tsbi->iostat_count[type]) : 0;\n}\n\n#define IOSTAT_INFO_SHOW(name, type)\t\t\t\t\t\\\n\tseq_printf(seq, \"%-23s %-16llu %-16llu %-16llu\\n\",\t\t\\\n\t\t\tname\":\", sbi->iostat_bytes[type],\t\t\\\n\t\t\tsbi->iostat_count[type],\t\t\t\\\n\t\t\tiostat_get_avg_bytes(sbi, type))\n\nint __maybe_unused iostat_info_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\tif (!sbi->iostat_enable)\n\t\treturn 0;\n\n\tseq_printf(seq, \"time:\t\t%-16llu\\n\", ktime_get_real_seconds());\n\tseq_printf(seq, \"\\t\\t\\t%-16s %-16s %-16s\\n\",\n\t\t\t\t\"io_bytes\", \"count\", \"avg_bytes\");\n\n\t \n\tseq_puts(seq, \"[WRITE]\\n\");\n\tIOSTAT_INFO_SHOW(\"app buffered data\", APP_BUFFERED_IO);\n\tIOSTAT_INFO_SHOW(\"app direct data\", APP_DIRECT_IO);\n\tIOSTAT_INFO_SHOW(\"app mapped data\", APP_MAPPED_IO);\n\tIOSTAT_INFO_SHOW(\"app buffered cdata\", APP_BUFFERED_CDATA_IO);\n\tIOSTAT_INFO_SHOW(\"app mapped cdata\", APP_MAPPED_CDATA_IO);\n\n\t \n\tIOSTAT_INFO_SHOW(\"fs data\", FS_DATA_IO);\n\tIOSTAT_INFO_SHOW(\"fs cdata\", FS_CDATA_IO);\n\tIOSTAT_INFO_SHOW(\"fs node\", FS_NODE_IO);\n\tIOSTAT_INFO_SHOW(\"fs meta\", FS_META_IO);\n\tIOSTAT_INFO_SHOW(\"fs gc data\", FS_GC_DATA_IO);\n\tIOSTAT_INFO_SHOW(\"fs gc node\", FS_GC_NODE_IO);\n\tIOSTAT_INFO_SHOW(\"fs cp data\", FS_CP_DATA_IO);\n\tIOSTAT_INFO_SHOW(\"fs cp node\", FS_CP_NODE_IO);\n\tIOSTAT_INFO_SHOW(\"fs cp meta\", FS_CP_META_IO);\n\n\t \n\tseq_puts(seq, \"[READ]\\n\");\n\tIOSTAT_INFO_SHOW(\"app buffered data\", APP_BUFFERED_READ_IO);\n\tIOSTAT_INFO_SHOW(\"app direct data\", APP_DIRECT_READ_IO);\n\tIOSTAT_INFO_SHOW(\"app mapped data\", APP_MAPPED_READ_IO);\n\tIOSTAT_INFO_SHOW(\"app buffered cdata\", APP_BUFFERED_CDATA_READ_IO);\n\tIOSTAT_INFO_SHOW(\"app mapped cdata\", APP_MAPPED_CDATA_READ_IO);\n\n\t \n\tIOSTAT_INFO_SHOW(\"fs data\", FS_DATA_READ_IO);\n\tIOSTAT_INFO_SHOW(\"fs gc data\", FS_GDATA_READ_IO);\n\tIOSTAT_INFO_SHOW(\"fs cdata\", FS_CDATA_READ_IO);\n\tIOSTAT_INFO_SHOW(\"fs node\", FS_NODE_READ_IO);\n\tIOSTAT_INFO_SHOW(\"fs meta\", FS_META_READ_IO);\n\n\t \n\tseq_puts(seq, \"[OTHER]\\n\");\n\tIOSTAT_INFO_SHOW(\"fs discard\", FS_DISCARD_IO);\n\tIOSTAT_INFO_SHOW(\"fs flush\", FS_FLUSH_IO);\n\tIOSTAT_INFO_SHOW(\"fs zone reset\", FS_ZONE_RESET_IO);\n\n\treturn 0;\n}\n\nstatic inline void __record_iostat_latency(struct f2fs_sb_info *sbi)\n{\n\tint io, idx;\n\tstruct f2fs_iostat_latency iostat_lat[MAX_IO_TYPE][NR_PAGE_TYPE];\n\tstruct iostat_lat_info *io_lat = sbi->iostat_io_lat;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->iostat_lat_lock, flags);\n\tfor (idx = 0; idx < MAX_IO_TYPE; idx++) {\n\t\tfor (io = 0; io < NR_PAGE_TYPE; io++) {\n\t\t\tiostat_lat[idx][io].peak_lat =\n\t\t\t   jiffies_to_msecs(io_lat->peak_lat[idx][io]);\n\t\t\tiostat_lat[idx][io].cnt = io_lat->bio_cnt[idx][io];\n\t\t\tiostat_lat[idx][io].avg_lat = iostat_lat[idx][io].cnt ?\n\t\t\t   jiffies_to_msecs(io_lat->sum_lat[idx][io]) / iostat_lat[idx][io].cnt : 0;\n\t\t\tio_lat->sum_lat[idx][io] = 0;\n\t\t\tio_lat->peak_lat[idx][io] = 0;\n\t\t\tio_lat->bio_cnt[idx][io] = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sbi->iostat_lat_lock, flags);\n\n\ttrace_f2fs_iostat_latency(sbi, iostat_lat);\n}\n\nstatic inline void f2fs_record_iostat(struct f2fs_sb_info *sbi)\n{\n\tunsigned long long iostat_diff[NR_IO_TYPE];\n\tint i;\n\tunsigned long flags;\n\n\tif (time_is_after_jiffies(sbi->iostat_next_period))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&sbi->iostat_lock, flags);\n\tif (time_is_after_jiffies(sbi->iostat_next_period)) {\n\t\tspin_unlock_irqrestore(&sbi->iostat_lock, flags);\n\t\treturn;\n\t}\n\tsbi->iostat_next_period = jiffies +\n\t\t\t\tmsecs_to_jiffies(sbi->iostat_period_ms);\n\n\tfor (i = 0; i < NR_IO_TYPE; i++) {\n\t\tiostat_diff[i] = sbi->iostat_bytes[i] -\n\t\t\t\tsbi->prev_iostat_bytes[i];\n\t\tsbi->prev_iostat_bytes[i] = sbi->iostat_bytes[i];\n\t}\n\tspin_unlock_irqrestore(&sbi->iostat_lock, flags);\n\n\ttrace_f2fs_iostat(sbi, iostat_diff);\n\n\t__record_iostat_latency(sbi);\n}\n\nvoid f2fs_reset_iostat(struct f2fs_sb_info *sbi)\n{\n\tstruct iostat_lat_info *io_lat = sbi->iostat_io_lat;\n\tint i;\n\n\tspin_lock_irq(&sbi->iostat_lock);\n\tfor (i = 0; i < NR_IO_TYPE; i++) {\n\t\tsbi->iostat_count[i] = 0;\n\t\tsbi->iostat_bytes[i] = 0;\n\t\tsbi->prev_iostat_bytes[i] = 0;\n\t}\n\tspin_unlock_irq(&sbi->iostat_lock);\n\n\tspin_lock_irq(&sbi->iostat_lat_lock);\n\tmemset(io_lat, 0, sizeof(struct iostat_lat_info));\n\tspin_unlock_irq(&sbi->iostat_lat_lock);\n}\n\nstatic inline void __f2fs_update_iostat(struct f2fs_sb_info *sbi,\n\t\t\tenum iostat_type type, unsigned long long io_bytes)\n{\n\tsbi->iostat_bytes[type] += io_bytes;\n\tsbi->iostat_count[type]++;\n}\n\nvoid f2fs_update_iostat(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\tenum iostat_type type, unsigned long long io_bytes)\n{\n\tunsigned long flags;\n\n\tif (!sbi->iostat_enable)\n\t\treturn;\n\n\tspin_lock_irqsave(&sbi->iostat_lock, flags);\n\t__f2fs_update_iostat(sbi, type, io_bytes);\n\n\tif (type == APP_BUFFERED_IO || type == APP_DIRECT_IO)\n\t\t__f2fs_update_iostat(sbi, APP_WRITE_IO, io_bytes);\n\n\tif (type == APP_BUFFERED_READ_IO || type == APP_DIRECT_READ_IO)\n\t\t__f2fs_update_iostat(sbi, APP_READ_IO, io_bytes);\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (inode && f2fs_compressed_file(inode)) {\n\t\tif (type == APP_BUFFERED_IO)\n\t\t\t__f2fs_update_iostat(sbi, APP_BUFFERED_CDATA_IO, io_bytes);\n\n\t\tif (type == APP_BUFFERED_READ_IO)\n\t\t\t__f2fs_update_iostat(sbi, APP_BUFFERED_CDATA_READ_IO, io_bytes);\n\n\t\tif (type == APP_MAPPED_READ_IO)\n\t\t\t__f2fs_update_iostat(sbi, APP_MAPPED_CDATA_READ_IO, io_bytes);\n\n\t\tif (type == APP_MAPPED_IO)\n\t\t\t__f2fs_update_iostat(sbi, APP_MAPPED_CDATA_IO, io_bytes);\n\n\t\tif (type == FS_DATA_READ_IO)\n\t\t\t__f2fs_update_iostat(sbi, FS_CDATA_READ_IO, io_bytes);\n\n\t\tif (type == FS_DATA_IO)\n\t\t\t__f2fs_update_iostat(sbi, FS_CDATA_IO, io_bytes);\n\t}\n#endif\n\n\tspin_unlock_irqrestore(&sbi->iostat_lock, flags);\n\n\tf2fs_record_iostat(sbi);\n}\n\nstatic inline void __update_iostat_latency(struct bio_iostat_ctx *iostat_ctx,\n\t\t\t\tenum iostat_lat_type lat_type)\n{\n\tunsigned long ts_diff;\n\tunsigned int page_type = iostat_ctx->type;\n\tstruct f2fs_sb_info *sbi = iostat_ctx->sbi;\n\tstruct iostat_lat_info *io_lat = sbi->iostat_io_lat;\n\tunsigned long flags;\n\n\tif (!sbi->iostat_enable)\n\t\treturn;\n\n\tts_diff = jiffies - iostat_ctx->submit_ts;\n\tif (page_type == META_FLUSH) {\n\t\tpage_type = META;\n\t} else if (page_type >= NR_PAGE_TYPE) {\n\t\tf2fs_warn(sbi, \"%s: %d over NR_PAGE_TYPE\", __func__, page_type);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&sbi->iostat_lat_lock, flags);\n\tio_lat->sum_lat[lat_type][page_type] += ts_diff;\n\tio_lat->bio_cnt[lat_type][page_type]++;\n\tif (ts_diff > io_lat->peak_lat[lat_type][page_type])\n\t\tio_lat->peak_lat[lat_type][page_type] = ts_diff;\n\tspin_unlock_irqrestore(&sbi->iostat_lat_lock, flags);\n}\n\nvoid iostat_update_and_unbind_ctx(struct bio *bio)\n{\n\tstruct bio_iostat_ctx *iostat_ctx = bio->bi_private;\n\tenum iostat_lat_type lat_type;\n\n\tif (op_is_write(bio_op(bio))) {\n\t\tlat_type = bio->bi_opf & REQ_SYNC ?\n\t\t\t\tWRITE_SYNC_IO : WRITE_ASYNC_IO;\n\t\tbio->bi_private = iostat_ctx->sbi;\n\t} else {\n\t\tlat_type = READ_IO;\n\t\tbio->bi_private = iostat_ctx->post_read_ctx;\n\t}\n\n\t__update_iostat_latency(iostat_ctx, lat_type);\n\tmempool_free(iostat_ctx, bio_iostat_ctx_pool);\n}\n\nvoid iostat_alloc_and_bind_ctx(struct f2fs_sb_info *sbi,\n\t\tstruct bio *bio, struct bio_post_read_ctx *ctx)\n{\n\tstruct bio_iostat_ctx *iostat_ctx;\n\t \n\tiostat_ctx = mempool_alloc(bio_iostat_ctx_pool, GFP_NOFS);\n\tiostat_ctx->sbi = sbi;\n\tiostat_ctx->submit_ts = 0;\n\tiostat_ctx->type = 0;\n\tiostat_ctx->post_read_ctx = ctx;\n\tbio->bi_private = iostat_ctx;\n}\n\nint __init f2fs_init_iostat_processing(void)\n{\n\tbio_iostat_ctx_cache =\n\t\tkmem_cache_create(\"f2fs_bio_iostat_ctx\",\n\t\t\t\t  sizeof(struct bio_iostat_ctx), 0, 0, NULL);\n\tif (!bio_iostat_ctx_cache)\n\t\tgoto fail;\n\tbio_iostat_ctx_pool =\n\t\tmempool_create_slab_pool(NUM_PREALLOC_IOSTAT_CTXS,\n\t\t\t\t\t bio_iostat_ctx_cache);\n\tif (!bio_iostat_ctx_pool)\n\t\tgoto fail_free_cache;\n\treturn 0;\n\nfail_free_cache:\n\tkmem_cache_destroy(bio_iostat_ctx_cache);\nfail:\n\treturn -ENOMEM;\n}\n\nvoid f2fs_destroy_iostat_processing(void)\n{\n\tmempool_destroy(bio_iostat_ctx_pool);\n\tkmem_cache_destroy(bio_iostat_ctx_cache);\n}\n\nint f2fs_init_iostat(struct f2fs_sb_info *sbi)\n{\n\t \n\tspin_lock_init(&sbi->iostat_lock);\n\tspin_lock_init(&sbi->iostat_lat_lock);\n\tsbi->iostat_enable = false;\n\tsbi->iostat_period_ms = DEFAULT_IOSTAT_PERIOD_MS;\n\tsbi->iostat_io_lat = f2fs_kzalloc(sbi, sizeof(struct iostat_lat_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!sbi->iostat_io_lat)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid f2fs_destroy_iostat(struct f2fs_sb_info *sbi)\n{\n\tkfree(sbi->iostat_io_lat);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}