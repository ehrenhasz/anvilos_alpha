{
  "module_name": "inline.c",
  "hash_id": "b81e06c2da4b62b50c7f4d08483650e5d3a59d4e0ad2ab7ce2b2028bdea3df9e",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/inline.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fiemap.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include <trace/events/f2fs.h>\n\nstatic bool support_inline_data(struct inode *inode)\n{\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\tif (!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))\n\t\treturn false;\n\tif (i_size_read(inode) > MAX_INLINE_DATA(inode))\n\t\treturn false;\n\treturn true;\n}\n\nbool f2fs_may_inline_data(struct inode *inode)\n{\n\tif (!support_inline_data(inode))\n\t\treturn false;\n\n\treturn !f2fs_post_read_required(inode);\n}\n\nbool f2fs_sanity_check_inline_data(struct inode *inode)\n{\n\tif (!f2fs_has_inline_data(inode))\n\t\treturn false;\n\n\tif (!support_inline_data(inode))\n\t\treturn true;\n\n\t \n\treturn (S_ISREG(inode->i_mode) &&\n\t\t(file_is_encrypt(inode) || file_is_verity(inode) ||\n\t\t(F2FS_I(inode)->i_flags & F2FS_COMPR_FL)));\n}\n\nbool f2fs_may_inline_dentry(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DENTRY))\n\t\treturn false;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid f2fs_do_read_inline_data(struct page *page, struct page *ipage)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tf2fs_bug_on(F2FS_P_SB(page), page->index);\n\n\tzero_user_segment(page, MAX_INLINE_DATA(inode), PAGE_SIZE);\n\n\t \n\tmemcpy_to_page(page, 0, inline_data_addr(inode, ipage),\n\t\t       MAX_INLINE_DATA(inode));\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n}\n\nvoid f2fs_truncate_inline_inode(struct inode *inode,\n\t\t\t\t\tstruct page *ipage, u64 from)\n{\n\tvoid *addr;\n\n\tif (from >= MAX_INLINE_DATA(inode))\n\t\treturn;\n\n\taddr = inline_data_addr(inode, ipage);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\tmemset(addr + from, 0, MAX_INLINE_DATA(inode) - from);\n\tset_page_dirty(ipage);\n\n\tif (from == 0)\n\t\tclear_inode_flag(inode, FI_DATA_EXIST);\n}\n\nint f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = f2fs_get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\telse\n\t\tf2fs_do_read_inline_data(page, ipage);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}\n\nint f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = F2FS_I_SB(dn->inode),\n\t\t.ino = dn->inode->i_ino,\n\t\t.type = DATA,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = REQ_SYNC | REQ_PRIO,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t\t.io_type = FS_DATA_IO,\n\t};\n\tstruct node_info ni;\n\tint dirty, err;\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_get_node_info(fio.sbi, dn->nid, &ni, false);\n\tif (err) {\n\t\tf2fs_truncate_data_blocks_range(dn, 1);\n\t\tf2fs_put_dnode(dn);\n\t\treturn err;\n\t}\n\n\tfio.version = ni.version;\n\n\tif (unlikely(dn->data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(dn);\n\t\tset_sbi_flag(fio.sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(fio.sbi, \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, run fsck to fix.\",\n\t\t\t  __func__, dn->inode->i_ino, dn->data_blkaddr);\n\t\tf2fs_handle_error(fio.sbi, ERROR_INVALID_BLKADDR);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tf2fs_bug_on(F2FS_P_SB(page), PageWriteback(page));\n\n\tf2fs_do_read_inline_data(page, dn->inode_page);\n\tset_page_dirty(page);\n\n\t \n\tdirty = clear_page_dirty_for_io(page);\n\n\t \n\tset_page_writeback(page);\n\tfio.old_blkaddr = dn->data_blkaddr;\n\tset_inode_flag(dn->inode, FI_HOT_DATA);\n\tf2fs_outplace_write_data(dn, &fio);\n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\tif (dirty) {\n\t\tinode_dec_dirty_pages(dn->inode);\n\t\tf2fs_remove_dirty_inode(dn->inode);\n\t}\n\n\t \n\tset_inode_flag(dn->inode, FI_APPEND_WRITE);\n\n\t \n\tf2fs_truncate_inline_inode(dn->inode, dn->inode_page, 0);\n\tclear_page_private_inline(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tclear_inode_flag(dn->inode, FI_INLINE_DATA);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tif (!f2fs_has_inline_data(inode) ||\n\t\t\tf2fs_hw_is_readonly(sbi) || f2fs_readonly(sbi->sb))\n\t\treturn 0;\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\tpage = f2fs_grab_cache_page(inode->i_mapping, 0, false);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\n\tif (!err)\n\t\tf2fs_balance_fs(sbi, dn.node_changed);\n\n\treturn err;\n}\n\nint f2fs_write_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EAGAIN;\n\t}\n\n\tf2fs_bug_on(F2FS_I_SB(inode), page->index);\n\n\tf2fs_wait_on_page_writeback(dn.inode_page, NODE, true, true);\n\tmemcpy_from_page(inline_data_addr(inode, dn.inode_page),\n\t\t\t page, 0, MAX_INLINE_DATA(inode));\n\tset_page_dirty(dn.inode_page);\n\n\tf2fs_clear_page_cache_dirty_tag(page);\n\n\tset_inode_flag(inode, FI_APPEND_WRITE);\n\tset_inode_flag(inode, FI_DATA_EXIST);\n\n\tclear_page_private_inline(dn.inode_page);\n\tf2fs_put_dnode(&dn);\n\treturn 0;\n}\n\nint f2fs_recover_inline_data(struct inode *inode, struct page *npage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tvoid *src_addr, *dst_addr;\n\tstruct page *ipage;\n\n\t \n\tif (IS_INODE(npage))\n\t\tri = F2FS_INODE(npage);\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\tri && (ri->i_inline & F2FS_INLINE_DATA)) {\nprocess_inline:\n\t\tipage = f2fs_get_node_page(sbi, inode->i_ino);\n\t\tif (IS_ERR(ipage))\n\t\t\treturn PTR_ERR(ipage);\n\n\t\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\n\t\tsrc_addr = inline_data_addr(inode, npage);\n\t\tdst_addr = inline_data_addr(inode, ipage);\n\t\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA(inode));\n\n\t\tset_inode_flag(inode, FI_INLINE_DATA);\n\t\tset_inode_flag(inode, FI_DATA_EXIST);\n\n\t\tset_page_dirty(ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn 1;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tipage = f2fs_get_node_page(sbi, inode->i_ino);\n\t\tif (IS_ERR(ipage))\n\t\t\treturn PTR_ERR(ipage);\n\t\tf2fs_truncate_inline_inode(inode, ipage, 0);\n\t\tstat_dec_inline_inode(inode);\n\t\tclear_inode_flag(inode, FI_INLINE_DATA);\n\t\tf2fs_put_page(ipage, 1);\n\t} else if (ri && (ri->i_inline & F2FS_INLINE_DATA)) {\n\t\tint ret;\n\n\t\tret = f2fs_truncate_blocks(inode, 0, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tstat_inc_inline_inode(inode);\n\t\tgoto process_inline;\n\t}\n\treturn 0;\n}\n\nstruct f2fs_dir_entry *f2fs_find_in_inline_dir(struct inode *dir,\n\t\t\t\t\tconst struct f2fs_filename *fname,\n\t\t\t\t\tstruct page **res_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *ipage;\n\tvoid *inline_dentry;\n\n\tipage = f2fs_get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\t*res_page = ipage;\n\t\treturn NULL;\n\t}\n\n\tinline_dentry = inline_data_addr(dir, ipage);\n\n\tmake_dentry_ptr_inline(dir, &d, inline_dentry);\n\tde = f2fs_find_target_dentry(&d, fname, NULL);\n\tunlock_page(ipage);\n\tif (IS_ERR(de)) {\n\t\t*res_page = ERR_CAST(de);\n\t\tde = NULL;\n\t}\n\tif (de)\n\t\t*res_page = ipage;\n\telse\n\t\tf2fs_put_page(ipage, 0);\n\n\treturn de;\n}\n\nint f2fs_make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\t\t\tstruct page *ipage)\n{\n\tstruct f2fs_dentry_ptr d;\n\tvoid *inline_dentry;\n\n\tinline_dentry = inline_data_addr(inode, ipage);\n\n\tmake_dentry_ptr_inline(inode, &d, inline_dentry);\n\tf2fs_do_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(ipage);\n\n\t \n\tif (i_size_read(inode) < MAX_INLINE_DATA(inode))\n\t\tf2fs_i_size_write(inode, MAX_INLINE_DATA(inode));\n\treturn 0;\n}\n\n \nstatic int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, true);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_warn(F2FS_P_SB(page), \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, run fsck to fix.\",\n\t\t\t  __func__, dir->i_ino, dn.data_blkaddr);\n\t\tf2fs_handle_error(F2FS_P_SB(page), ERROR_INVALID_BLKADDR);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\tdentry_blk = page_address(page);\n\n\t \n\tmemset(dentry_blk, 0, F2FS_BLKSIZE);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t \n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t \n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\t \n\tif (!f2fs_sb_has_flexible_inline_xattr(F2FS_I_SB(dir)) &&\n\t\t\t!f2fs_has_inline_xattr(dir))\n\t\tF2FS_I(dir)->i_inline_xattr_size = 0;\n\n\tf2fs_i_depth_write(dir, 1);\n\tif (i_size_read(dir) < PAGE_SIZE)\n\t\tf2fs_i_size_write(dir, PAGE_SIZE);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n\nstatic int f2fs_add_inline_entries(struct inode *dir, void *inline_dentry)\n{\n\tstruct f2fs_dentry_ptr d;\n\tunsigned long bit_pos = 0;\n\tint err = 0;\n\n\tmake_dentry_ptr_inline(dir, &d, inline_dentry);\n\n\twhile (bit_pos < d.max) {\n\t\tstruct f2fs_dir_entry *de;\n\t\tstruct f2fs_filename fname;\n\t\tnid_t ino;\n\t\tumode_t fake_mode;\n\n\t\tif (!test_bit_le(bit_pos, d.bitmap)) {\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = &d.dentry[bit_pos];\n\n\t\tif (unlikely(!de->name_len)) {\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemset(&fname, 0, sizeof(fname));\n\t\tfname.disk_name.name = d.filename[bit_pos];\n\t\tfname.disk_name.len = le16_to_cpu(de->name_len);\n\t\tfname.hash = de->hash_code;\n\n\t\tino = le32_to_cpu(de->ino);\n\t\tfake_mode = fs_ftype_to_dtype(de->file_type) << S_DT_SHIFT;\n\n\t\terr = f2fs_add_regular_entry(dir, &fname, NULL, ino, fake_mode);\n\t\tif (err)\n\t\t\tgoto punch_dentry_pages;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\treturn 0;\npunch_dentry_pages:\n\ttruncate_inode_pages(&dir->i_data, 0);\n\tf2fs_truncate_blocks(dir, 0, false);\n\tf2fs_remove_dirty_inode(dir);\n\treturn err;\n}\n\nstatic int f2fs_move_rehashed_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tvoid *backup_dentry;\n\tint err;\n\n\tbackup_dentry = f2fs_kmalloc(F2FS_I_SB(dir),\n\t\t\t\tMAX_INLINE_DATA(dir), GFP_F2FS_ZERO);\n\tif (!backup_dentry) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(backup_dentry, inline_dentry, MAX_INLINE_DATA(dir));\n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tunlock_page(ipage);\n\n\terr = f2fs_add_inline_entries(dir, backup_dentry);\n\tif (err)\n\t\tgoto recover;\n\n\tlock_page(ipage);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\t \n\tif (!f2fs_sb_has_flexible_inline_xattr(F2FS_I_SB(dir)) &&\n\t\t\t!f2fs_has_inline_xattr(dir))\n\t\tF2FS_I(dir)->i_inline_xattr_size = 0;\n\n\tkfree(backup_dentry);\n\treturn 0;\nrecover:\n\tlock_page(ipage);\n\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\tmemcpy(inline_dentry, backup_dentry, MAX_INLINE_DATA(dir));\n\tf2fs_i_depth_write(dir, 0);\n\tf2fs_i_size_write(dir, MAX_INLINE_DATA(dir));\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\n\tkfree(backup_dentry);\n\treturn err;\n}\n\nstatic int do_convert_inline_dir(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tif (!F2FS_I(dir)->i_dir_level)\n\t\treturn f2fs_move_inline_dirents(dir, ipage, inline_dentry);\n\telse\n\t\treturn f2fs_move_rehashed_dirents(dir, ipage, inline_dentry);\n}\n\nint f2fs_try_convert_inline_dir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tstruct f2fs_filename fname;\n\tvoid *inline_dentry = NULL;\n\tint err = 0;\n\n\tif (!f2fs_has_inline_dentry(dir))\n\t\treturn 0;\n\n\tf2fs_lock_op(sbi);\n\n\terr = f2fs_setup_filename(dir, &dentry->d_name, 0, &fname);\n\tif (err)\n\t\tgoto out;\n\n\tipage = f2fs_get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out_fname;\n\t}\n\n\tif (f2fs_has_enough_room(dir, ipage, &fname)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out_fname;\n\t}\n\n\tinline_dentry = inline_data_addr(dir, ipage);\n\n\terr = do_convert_inline_dir(dir, ipage, inline_dentry);\n\tif (!err)\n\t\tf2fs_put_page(ipage, 1);\nout_fname:\n\tf2fs_free_filename(&fname);\nout:\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}\n\nint f2fs_add_inline_entry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t\t  struct inode *inode, nid_t ino, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos;\n\tvoid *inline_dentry = NULL;\n\tstruct f2fs_dentry_ptr d;\n\tint slots = GET_DENTRY_SLOTS(fname->disk_name.len);\n\tstruct page *page = NULL;\n\tint err = 0;\n\n\tipage = f2fs_get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tinline_dentry = inline_data_addr(dir, ipage);\n\tmake_dentry_ptr_inline(dir, &d, inline_dentry);\n\n\tbit_pos = f2fs_room_for_filename(d.bitmap, slots, d.max);\n\tif (bit_pos >= d.max) {\n\t\terr = do_convert_inline_dir(dir, ipage, inline_dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (inode) {\n\t\tf2fs_down_write_nested(&F2FS_I(inode)->i_sem,\n\t\t\t\t\t\tSINGLE_DEPTH_NESTING);\n\t\tpage = f2fs_init_inode_metadata(inode, dir, fname, ipage);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\n\tf2fs_update_dentry(ino, mode, &d, &fname->disk_name, fname->hash,\n\t\t\t   bit_pos);\n\n\tset_page_dirty(ipage);\n\n\t \n\tif (inode) {\n\t\tf2fs_i_pino_write(inode, dir->i_ino);\n\n\t\t \n\t\tif (is_inode_flag_set(inode, FI_NEW_INODE))\n\t\t\tf2fs_update_inode(inode, page);\n\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tf2fs_update_parent_metadata(dir, inode, 0);\nfail:\n\tif (inode)\n\t\tf2fs_up_write(&F2FS_I(inode)->i_sem);\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}\n\nvoid f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_dentry_ptr d;\n\tvoid *inline_dentry;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tunsigned int bit_pos;\n\tint i;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, NODE, true, true);\n\n\tinline_dentry = inline_data_addr(dir, page);\n\tmake_dentry_ptr_inline(dir, &d, inline_dentry);\n\n\tbit_pos = dentry - d.dentry;\n\tfor (i = 0; i < slots; i++)\n\t\t__clear_bit_le(bit_pos + i, d.bitmap);\n\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\n\tdir->i_mtime = inode_set_ctime_current(dir);\n\tf2fs_mark_inode_dirty_sync(dir, false);\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode);\n}\n\nbool f2fs_empty_inline_dir(struct inode *dir)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos = 2;\n\tvoid *inline_dentry;\n\tstruct f2fs_dentry_ptr d;\n\n\tipage = f2fs_get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn false;\n\n\tinline_dentry = inline_data_addr(dir, ipage);\n\tmake_dentry_ptr_inline(dir, &d, inline_dentry);\n\n\tbit_pos = find_next_bit_le(d.bitmap, d.max, bit_pos);\n\n\tf2fs_put_page(ipage, 1);\n\n\tif (bit_pos < d.max)\n\t\treturn false;\n\n\treturn true;\n}\n\nint f2fs_read_inline_dir(struct file *file, struct dir_context *ctx,\n\t\t\t\tstruct fscrypt_str *fstr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct page *ipage = NULL;\n\tstruct f2fs_dentry_ptr d;\n\tvoid *inline_dentry = NULL;\n\tint err;\n\n\tmake_dentry_ptr_inline(inode, &d, inline_dentry);\n\n\tif (ctx->pos == d.max)\n\t\treturn 0;\n\n\tipage = f2fs_get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\t \n\tunlock_page(ipage);\n\n\tinline_dentry = inline_data_addr(inode, ipage);\n\n\tmake_dentry_ptr_inline(inode, &d, inline_dentry);\n\n\terr = f2fs_fill_dentries(ctx, &d, 0, fstr);\n\tif (!err)\n\t\tctx->pos = d.max;\n\n\tf2fs_put_page(ipage, 0);\n\treturn err < 0 ? err : 0;\n}\n\nint f2fs_inline_data_fiemap(struct inode *inode,\n\t\tstruct fiemap_extent_info *fieinfo, __u64 start, __u64 len)\n{\n\t__u64 byteaddr, ilen;\n\t__u32 flags = FIEMAP_EXTENT_DATA_INLINE | FIEMAP_EXTENT_NOT_ALIGNED |\n\t\tFIEMAP_EXTENT_LAST;\n\tstruct node_info ni;\n\tstruct page *ipage;\n\tint err = 0;\n\n\tipage = f2fs_get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tif ((S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) &&\n\t\t\t\t!f2fs_has_inline_data(inode)) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(inode->i_mode) && !f2fs_has_inline_dentry(inode)) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tilen = min_t(size_t, MAX_INLINE_DATA(inode), i_size_read(inode));\n\tif (start >= ilen)\n\t\tgoto out;\n\tif (start + len < ilen)\n\t\tilen = start + len;\n\tilen -= start;\n\n\terr = f2fs_get_node_info(F2FS_I_SB(inode), inode->i_ino, &ni, false);\n\tif (err)\n\t\tgoto out;\n\n\tbyteaddr = (__u64)ni.blk_addr << inode->i_sb->s_blocksize_bits;\n\tbyteaddr += (char *)inline_data_addr(inode, ipage) -\n\t\t\t\t\t(char *)F2FS_INODE(ipage);\n\terr = fiemap_fill_next_extent(fieinfo, start, byteaddr, ilen, flags);\n\ttrace_f2fs_fiemap(inode, start, byteaddr, ilen, flags, err);\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}