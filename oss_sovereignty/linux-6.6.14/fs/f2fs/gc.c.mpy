{
  "module_name": "gc.c",
  "hash_id": "5ab5afcec01b943cecd4644dd0c3fdb8df1c1d1f70629c75541126d19fce19af",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/gc.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/f2fs_fs.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/sched/mm.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"gc.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n\nstatic struct kmem_cache *victim_entry_slab;\n\nstatic unsigned int count_bits(const unsigned long *addr,\n\t\t\t\tunsigned int offset, unsigned int len);\n\nstatic int gc_thread_func(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\twait_queue_head_t *wq = &sbi->gc_thread->gc_wait_queue_head;\n\twait_queue_head_t *fggc_wq = &sbi->gc_thread->fggc_wq;\n\tunsigned int wait_ms;\n\tstruct f2fs_gc_control gc_control = {\n\t\t.victim_segno = NULL_SEGNO,\n\t\t.should_migrate_blocks = false,\n\t\t.err_gc_skipped = false };\n\n\twait_ms = gc_th->min_sleep_time;\n\n\tset_freezable();\n\tdo {\n\t\tbool sync_mode, foreground = false;\n\n\t\twait_event_interruptible_timeout(*wq,\n\t\t\t\tkthread_should_stop() || freezing(current) ||\n\t\t\t\twaitqueue_active(fggc_wq) ||\n\t\t\t\tgc_th->gc_wake,\n\t\t\t\tmsecs_to_jiffies(wait_ms));\n\n\t\tif (test_opt(sbi, GC_MERGE) && waitqueue_active(fggc_wq))\n\t\t\tforeground = true;\n\n\t\t \n\t\tif (gc_th->gc_wake)\n\t\t\tgc_th->gc_wake = false;\n\n\t\tif (try_to_freeze() || f2fs_readonly(sbi->sb)) {\n\t\t\tstat_other_skip_bggc_count(sbi);\n\t\t\tcontinue;\n\t\t}\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif (sbi->sb->s_writers.frozen >= SB_FREEZE_WRITE) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tstat_other_skip_bggc_count(sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (time_to_inject(sbi, FAULT_CHECKPOINT))\n\t\t\tf2fs_stop_checkpoint(sbi, false,\n\t\t\t\t\tSTOP_CP_REASON_FAULT_INJECT);\n\n\t\tif (!sb_start_write_trylock(sbi->sb)) {\n\t\t\tstat_other_skip_bggc_count(sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (sbi->gc_mode == GC_URGENT_HIGH ||\n\t\t\t\tsbi->gc_mode == GC_URGENT_MID) {\n\t\t\twait_ms = gc_th->urgent_sleep_time;\n\t\t\tf2fs_down_write(&sbi->gc_lock);\n\t\t\tgoto do_gc;\n\t\t}\n\n\t\tif (foreground) {\n\t\t\tf2fs_down_write(&sbi->gc_lock);\n\t\t\tgoto do_gc;\n\t\t} else if (!f2fs_down_write_trylock(&sbi->gc_lock)) {\n\t\t\tstat_other_skip_bggc_count(sbi);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!is_idle(sbi, GC_TIME)) {\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\n\t\t\tf2fs_up_write(&sbi->gc_lock);\n\t\t\tstat_io_skip_bggc_count(sbi);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (has_enough_invalid_blocks(sbi))\n\t\t\tdecrease_sleep_time(gc_th, &wait_ms);\n\t\telse\n\t\t\tincrease_sleep_time(gc_th, &wait_ms);\ndo_gc:\n\t\tstat_inc_gc_call_count(sbi, foreground ?\n\t\t\t\t\tFOREGROUND : BACKGROUND);\n\n\t\tsync_mode = F2FS_OPTION(sbi).bggc_mode == BGGC_MODE_SYNC;\n\n\t\t \n\t\tif (foreground)\n\t\t\tsync_mode = false;\n\n\t\tgc_control.init_gc_type = sync_mode ? FG_GC : BG_GC;\n\t\tgc_control.no_bg_gc = foreground;\n\t\tgc_control.nr_free_secs = foreground ? 1 : 0;\n\n\t\t \n\t\tif (f2fs_gc(sbi, &gc_control)) {\n\t\t\t \n\t\t\tif (!foreground)\n\t\t\t\twait_ms = gc_th->no_gc_sleep_time;\n\t\t} else {\n\t\t\t \n\t\t\tif (wait_ms == gc_th->no_gc_sleep_time)\n\t\t\t\twait_ms = gc_th->min_sleep_time;\n\t\t}\n\n\t\tif (foreground)\n\t\t\twake_up_all(&gc_th->fggc_wq);\n\n\t\ttrace_f2fs_background_gc(sbi->sb, wait_ms,\n\t\t\t\tprefree_segments(sbi), free_segments(sbi));\n\n\t\t \n\t\tf2fs_balance_fs_bg(sbi, true);\nnext:\n\t\tif (sbi->gc_mode != GC_NORMAL) {\n\t\t\tspin_lock(&sbi->gc_remaining_trials_lock);\n\t\t\tif (sbi->gc_remaining_trials) {\n\t\t\t\tsbi->gc_remaining_trials--;\n\t\t\t\tif (!sbi->gc_remaining_trials)\n\t\t\t\t\tsbi->gc_mode = GC_NORMAL;\n\t\t\t}\n\t\t\tspin_unlock(&sbi->gc_remaining_trials_lock);\n\t\t}\n\t\tsb_end_write(sbi->sb);\n\n\t} while (!kthread_should_stop());\n\treturn 0;\n}\n\nint f2fs_start_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th;\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\n\tgc_th = f2fs_kmalloc(sbi, sizeof(struct f2fs_gc_kthread), GFP_KERNEL);\n\tif (!gc_th)\n\t\treturn -ENOMEM;\n\n\tgc_th->urgent_sleep_time = DEF_GC_THREAD_URGENT_SLEEP_TIME;\n\tgc_th->min_sleep_time = DEF_GC_THREAD_MIN_SLEEP_TIME;\n\tgc_th->max_sleep_time = DEF_GC_THREAD_MAX_SLEEP_TIME;\n\tgc_th->no_gc_sleep_time = DEF_GC_THREAD_NOGC_SLEEP_TIME;\n\n\tgc_th->gc_wake = false;\n\n\tsbi->gc_thread = gc_th;\n\tinit_waitqueue_head(&sbi->gc_thread->gc_wait_queue_head);\n\tinit_waitqueue_head(&sbi->gc_thread->fggc_wq);\n\tsbi->gc_thread->f2fs_gc_task = kthread_run(gc_thread_func, sbi,\n\t\t\t\"f2fs_gc-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(gc_th->f2fs_gc_task)) {\n\t\tint err = PTR_ERR(gc_th->f2fs_gc_task);\n\n\t\tkfree(gc_th);\n\t\tsbi->gc_thread = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid f2fs_stop_gc_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_gc_kthread *gc_th = sbi->gc_thread;\n\n\tif (!gc_th)\n\t\treturn;\n\tkthread_stop(gc_th->f2fs_gc_task);\n\twake_up_all(&gc_th->fggc_wq);\n\tkfree(gc_th);\n\tsbi->gc_thread = NULL;\n}\n\nstatic int select_gc_type(struct f2fs_sb_info *sbi, int gc_type)\n{\n\tint gc_mode;\n\n\tif (gc_type == BG_GC) {\n\t\tif (sbi->am.atgc_enabled)\n\t\t\tgc_mode = GC_AT;\n\t\telse\n\t\t\tgc_mode = GC_CB;\n\t} else {\n\t\tgc_mode = GC_GREEDY;\n\t}\n\n\tswitch (sbi->gc_mode) {\n\tcase GC_IDLE_CB:\n\t\tgc_mode = GC_CB;\n\t\tbreak;\n\tcase GC_IDLE_GREEDY:\n\tcase GC_URGENT_HIGH:\n\t\tgc_mode = GC_GREEDY;\n\t\tbreak;\n\tcase GC_IDLE_AT:\n\t\tgc_mode = GC_AT;\n\t\tbreak;\n\t}\n\n\treturn gc_mode;\n}\n\nstatic void select_policy(struct f2fs_sb_info *sbi, int gc_type,\n\t\t\tint type, struct victim_sel_policy *p)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tif (p->alloc_mode == SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_bitmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else if (p->alloc_mode == AT_SSR) {\n\t\tp->gc_mode = GC_GREEDY;\n\t\tp->dirty_bitmap = dirty_i->dirty_segmap[type];\n\t\tp->max_search = dirty_i->nr_dirty[type];\n\t\tp->ofs_unit = 1;\n\t} else {\n\t\tp->gc_mode = select_gc_type(sbi, gc_type);\n\t\tp->ofs_unit = sbi->segs_per_sec;\n\t\tif (__is_large_section(sbi)) {\n\t\t\tp->dirty_bitmap = dirty_i->dirty_secmap;\n\t\t\tp->max_search = count_bits(p->dirty_bitmap,\n\t\t\t\t\t\t0, MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tp->dirty_bitmap = dirty_i->dirty_segmap[DIRTY];\n\t\t\tp->max_search = dirty_i->nr_dirty[DIRTY];\n\t\t}\n\t}\n\n\t \n\tif (gc_type != FG_GC &&\n\t\t\t(sbi->gc_mode != GC_URGENT_HIGH) &&\n\t\t\t(p->gc_mode != GC_AT && p->alloc_mode != AT_SSR) &&\n\t\t\tp->max_search > sbi->max_victim_search)\n\t\tp->max_search = sbi->max_victim_search;\n\n\t \n\tif (f2fs_need_rand_seg(sbi))\n\t\tp->offset = get_random_u32_below(MAIN_SECS(sbi) * sbi->segs_per_sec);\n\telse if (test_opt(sbi, NOHEAP) &&\n\t\t(type == CURSEG_HOT_DATA || IS_NODESEG(type)))\n\t\tp->offset = 0;\n\telse\n\t\tp->offset = SIT_I(sbi)->last_victim[p->gc_mode];\n}\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t \n\tif (p->alloc_mode == SSR)\n\t\treturn sbi->blocks_per_seg;\n\telse if (p->alloc_mode == AT_SSR)\n\t\treturn UINT_MAX;\n\n\t \n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn 2 * sbi->blocks_per_seg * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse if (p->gc_mode == GC_AT)\n\t\treturn UINT_MAX;\n\telse  \n\t\treturn 0;\n}\n\nstatic unsigned int check_bg_victims(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno;\n\n\t \n\tfor_each_set_bit(secno, dirty_i->victim_secmap, MAIN_SECS(sbi)) {\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tcontinue;\n\t\tclear_bit(secno, dirty_i->victim_secmap);\n\t\treturn GET_SEG_FROM_SEC(sbi, secno);\n\t}\n\treturn NULL_SEGNO;\n}\n\nstatic unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\tunsigned int start = GET_SEG_FROM_SEC(sbi, secno);\n\tunsigned long long mtime = 0;\n\tunsigned int vblocks;\n\tunsigned char age = 0;\n\tunsigned char u;\n\tunsigned int i;\n\tunsigned int usable_segs_per_sec = f2fs_usable_segs_in_sec(sbi, segno);\n\n\tfor (i = 0; i < usable_segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tvblocks = get_valid_blocks(sbi, segno, true);\n\n\tmtime = div_u64(mtime, usable_segs_per_sec);\n\tvblocks = div_u64(vblocks, usable_segs_per_sec);\n\n\tu = (vblocks * 100) >> sbi->log_blocks_per_seg;\n\n\t \n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (sit_i->max_mtime != sit_i->min_mtime)\n\t\tage = 100 - div64_u64(100 * (mtime - sit_i->min_mtime),\n\t\t\t\tsit_i->max_mtime - sit_i->min_mtime);\n\n\treturn UINT_MAX - ((100 * (100 - u) * age) / (100 + u));\n}\n\nstatic inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct victim_sel_policy *p)\n{\n\tif (p->alloc_mode == SSR)\n\t\treturn get_seg_entry(sbi, segno)->ckpt_valid_blocks;\n\n\t \n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn get_valid_blocks(sbi, segno, true);\n\telse if (p->gc_mode == GC_CB)\n\t\treturn get_cb_cost(sbi, segno);\n\n\tf2fs_bug_on(sbi, 1);\n\treturn 0;\n}\n\nstatic unsigned int count_bits(const unsigned long *addr,\n\t\t\t\tunsigned int offset, unsigned int len)\n{\n\tunsigned int end = offset + len, sum = 0;\n\n\twhile (offset < end) {\n\t\tif (test_bit(offset++, addr))\n\t\t\t++sum;\n\t}\n\treturn sum;\n}\n\nstatic bool f2fs_check_victim_tree(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct rb_root_cached *root)\n{\n#ifdef CONFIG_F2FS_CHECK_FS\n\tstruct rb_node *cur = rb_first_cached(root), *next;\n\tstruct victim_entry *cur_ve, *next_ve;\n\n\twhile (cur) {\n\t\tnext = rb_next(cur);\n\t\tif (!next)\n\t\t\treturn true;\n\n\t\tcur_ve = rb_entry(cur, struct victim_entry, rb_node);\n\t\tnext_ve = rb_entry(next, struct victim_entry, rb_node);\n\n\t\tif (cur_ve->mtime > next_ve->mtime) {\n\t\t\tf2fs_info(sbi, \"broken victim_rbtree, \"\n\t\t\t\t\"cur_mtime(%llu) next_mtime(%llu)\",\n\t\t\t\tcur_ve->mtime, next_ve->mtime);\n\t\t\treturn false;\n\t\t}\n\t\tcur = next;\n\t}\n#endif\n\treturn true;\n}\n\nstatic struct victim_entry *__lookup_victim_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned long long mtime)\n{\n\tstruct atgc_management *am = &sbi->am;\n\tstruct rb_node *node = am->root.rb_root.rb_node;\n\tstruct victim_entry *ve = NULL;\n\n\twhile (node) {\n\t\tve = rb_entry(node, struct victim_entry, rb_node);\n\n\t\tif (mtime < ve->mtime)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\tnode = node->rb_right;\n\t}\n\treturn ve;\n}\n\nstatic struct victim_entry *__create_victim_entry(struct f2fs_sb_info *sbi,\n\t\tunsigned long long mtime, unsigned int segno)\n{\n\tstruct atgc_management *am = &sbi->am;\n\tstruct victim_entry *ve;\n\n\tve =  f2fs_kmem_cache_alloc(victim_entry_slab, GFP_NOFS, true, NULL);\n\n\tve->mtime = mtime;\n\tve->segno = segno;\n\n\tlist_add_tail(&ve->list, &am->victim_list);\n\tam->victim_count++;\n\n\treturn ve;\n}\n\nstatic void __insert_victim_entry(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned long long mtime, unsigned int segno)\n{\n\tstruct atgc_management *am = &sbi->am;\n\tstruct rb_root_cached *root = &am->root;\n\tstruct rb_node **p = &root->rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct victim_entry *ve;\n\tbool left_most = true;\n\n\t \n\twhile (*p) {\n\t\tparent = *p;\n\t\tve = rb_entry(parent, struct victim_entry, rb_node);\n\n\t\tif (mtime < ve->mtime) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleft_most = false;\n\t\t}\n\t}\n\n\tve = __create_victim_entry(sbi, mtime, segno);\n\n\trb_link_node(&ve->rb_node, parent, p);\n\trb_insert_color_cached(&ve->rb_node, root, left_most);\n}\n\nstatic void add_victim_entry(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\tunsigned int start = GET_SEG_FROM_SEC(sbi, secno);\n\tunsigned long long mtime = 0;\n\tunsigned int i;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\tif (p->gc_mode == GC_AT &&\n\t\t\tget_valid_blocks(sbi, segno, true) == 0)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\tmtime += get_seg_entry(sbi, start + i)->mtime;\n\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t \n\tif (mtime < sit_i->min_mtime)\n\t\tsit_i->min_mtime = mtime;\n\tif (mtime > sit_i->max_mtime)\n\t\tsit_i->max_mtime = mtime;\n\tif (mtime < sit_i->dirty_min_mtime)\n\t\tsit_i->dirty_min_mtime = mtime;\n\tif (mtime > sit_i->dirty_max_mtime)\n\t\tsit_i->dirty_max_mtime = mtime;\n\n\t \n\tif (sit_i->dirty_max_mtime - mtime < p->age_threshold)\n\t\treturn;\n\n\t__insert_victim_entry(sbi, mtime, segno);\n}\n\nstatic void atgc_lookup_victim(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct victim_sel_policy *p)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct atgc_management *am = &sbi->am;\n\tstruct rb_root_cached *root = &am->root;\n\tstruct rb_node *node;\n\tstruct victim_entry *ve;\n\tunsigned long long total_time;\n\tunsigned long long age, u, accu;\n\tunsigned long long max_mtime = sit_i->dirty_max_mtime;\n\tunsigned long long min_mtime = sit_i->dirty_min_mtime;\n\tunsigned int sec_blocks = CAP_BLKS_PER_SEC(sbi);\n\tunsigned int vblocks;\n\tunsigned int dirty_threshold = max(am->max_candidate_count,\n\t\t\t\t\tam->candidate_ratio *\n\t\t\t\t\tam->victim_count / 100);\n\tunsigned int age_weight = am->age_weight;\n\tunsigned int cost;\n\tunsigned int iter = 0;\n\n\tif (max_mtime < min_mtime)\n\t\treturn;\n\n\tmax_mtime += 1;\n\ttotal_time = max_mtime - min_mtime;\n\n\taccu = div64_u64(ULLONG_MAX, total_time);\n\taccu = min_t(unsigned long long, div_u64(accu, 100),\n\t\t\t\t\tDEFAULT_ACCURACY_CLASS);\n\n\tnode = rb_first_cached(root);\nnext:\n\tve = rb_entry_safe(node, struct victim_entry, rb_node);\n\tif (!ve)\n\t\treturn;\n\n\tif (ve->mtime >= max_mtime || ve->mtime < min_mtime)\n\t\tgoto skip;\n\n\t \n\tage = div64_u64(accu * (max_mtime - ve->mtime), total_time) *\n\t\t\t\t\t\t\t\tage_weight;\n\n\tvblocks = get_valid_blocks(sbi, ve->segno, true);\n\tf2fs_bug_on(sbi, !vblocks || vblocks == sec_blocks);\n\n\t \n\tu = div64_u64(accu * (sec_blocks - vblocks), sec_blocks) *\n\t\t\t\t\t\t\t(100 - age_weight);\n\n\tf2fs_bug_on(sbi, age + u >= UINT_MAX);\n\n\tcost = UINT_MAX - (age + u);\n\titer++;\n\n\tif (cost < p->min_cost ||\n\t\t\t(cost == p->min_cost && age > p->oldest_age)) {\n\t\tp->min_cost = cost;\n\t\tp->oldest_age = age;\n\t\tp->min_segno = ve->segno;\n\t}\nskip:\n\tif (iter < dirty_threshold) {\n\t\tnode = rb_next(node);\n\t\tgoto next;\n\t}\n}\n\n \nstatic void atssr_lookup_victim(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct victim_sel_policy *p)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct atgc_management *am = &sbi->am;\n\tstruct victim_entry *ve;\n\tunsigned long long age;\n\tunsigned long long max_mtime = sit_i->dirty_max_mtime;\n\tunsigned long long min_mtime = sit_i->dirty_min_mtime;\n\tunsigned int seg_blocks = sbi->blocks_per_seg;\n\tunsigned int vblocks;\n\tunsigned int dirty_threshold = max(am->max_candidate_count,\n\t\t\t\t\tam->candidate_ratio *\n\t\t\t\t\tam->victim_count / 100);\n\tunsigned int cost, iter;\n\tint stage = 0;\n\n\tif (max_mtime < min_mtime)\n\t\treturn;\n\tmax_mtime += 1;\nnext_stage:\n\titer = 0;\n\tve = __lookup_victim_entry(sbi, p->age);\nnext_node:\n\tif (!ve) {\n\t\tif (stage++ == 0)\n\t\t\tgoto next_stage;\n\t\treturn;\n\t}\n\n\tif (ve->mtime >= max_mtime || ve->mtime < min_mtime)\n\t\tgoto skip_node;\n\n\tage = max_mtime - ve->mtime;\n\n\tvblocks = get_seg_entry(sbi, ve->segno)->ckpt_valid_blocks;\n\tf2fs_bug_on(sbi, !vblocks);\n\n\t \n\tif (vblocks == seg_blocks)\n\t\tgoto skip_node;\n\n\titer++;\n\n\tage = max_mtime - abs(p->age - age);\n\tcost = UINT_MAX - vblocks;\n\n\tif (cost < p->min_cost ||\n\t\t\t(cost == p->min_cost && age > p->oldest_age)) {\n\t\tp->min_cost = cost;\n\t\tp->oldest_age = age;\n\t\tp->min_segno = ve->segno;\n\t}\nskip_node:\n\tif (iter < dirty_threshold) {\n\t\tve = rb_entry(stage == 0 ? rb_prev(&ve->rb_node) :\n\t\t\t\t\trb_next(&ve->rb_node),\n\t\t\t\t\tstruct victim_entry, rb_node);\n\t\tgoto next_node;\n\t}\n\n\tif (stage++ == 0)\n\t\tgoto next_stage;\n}\n\nstatic void lookup_victim_by_age(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct victim_sel_policy *p)\n{\n\tf2fs_bug_on(sbi, !f2fs_check_victim_tree(sbi, &sbi->am.root));\n\n\tif (p->gc_mode == GC_AT)\n\t\tatgc_lookup_victim(sbi, p);\n\telse if (p->alloc_mode == AT_SSR)\n\t\tatssr_lookup_victim(sbi, p);\n\telse\n\t\tf2fs_bug_on(sbi, 1);\n}\n\nstatic void release_victim_entry(struct f2fs_sb_info *sbi)\n{\n\tstruct atgc_management *am = &sbi->am;\n\tstruct victim_entry *ve, *tmp;\n\n\tlist_for_each_entry_safe(ve, tmp, &am->victim_list, list) {\n\t\tlist_del(&ve->list);\n\t\tkmem_cache_free(victim_entry_slab, ve);\n\t\tam->victim_count--;\n\t}\n\n\tam->root = RB_ROOT_CACHED;\n\n\tf2fs_bug_on(sbi, am->victim_count);\n\tf2fs_bug_on(sbi, !list_empty(&am->victim_list));\n}\n\nstatic bool f2fs_pin_section(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\n\tif (!dirty_i->enable_pin_section)\n\t\treturn false;\n\tif (!test_and_set_bit(secno, dirty_i->pinned_secmap))\n\t\tdirty_i->pinned_secmap_cnt++;\n\treturn true;\n}\n\nstatic bool f2fs_pinned_section_exists(struct dirty_seglist_info *dirty_i)\n{\n\treturn dirty_i->pinned_secmap_cnt;\n}\n\nstatic bool f2fs_section_is_pinned(struct dirty_seglist_info *dirty_i,\n\t\t\t\t\t\tunsigned int secno)\n{\n\treturn dirty_i->enable_pin_section &&\n\t\tf2fs_pinned_section_exists(dirty_i) &&\n\t\ttest_bit(secno, dirty_i->pinned_secmap);\n}\n\nstatic void f2fs_unpin_all_sections(struct f2fs_sb_info *sbi, bool enable)\n{\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tif (f2fs_pinned_section_exists(DIRTY_I(sbi))) {\n\t\tmemset(DIRTY_I(sbi)->pinned_secmap, 0, bitmap_size);\n\t\tDIRTY_I(sbi)->pinned_secmap_cnt = 0;\n\t}\n\tDIRTY_I(sbi)->enable_pin_section = enable;\n}\n\nstatic int f2fs_gc_pinned_control(struct inode *inode, int gc_type,\n\t\t\t\t\t\t\tunsigned int segno)\n{\n\tif (!f2fs_is_pinned_file(inode))\n\t\treturn 0;\n\tif (gc_type != FG_GC)\n\t\treturn -EBUSY;\n\tif (!f2fs_pin_section(F2FS_I_SB(inode), segno))\n\t\tf2fs_pin_file_control(inode, true);\n\treturn -EAGAIN;\n}\n\n \nint f2fs_get_victim(struct f2fs_sb_info *sbi, unsigned int *result,\n\t\t\tint gc_type, int type, char alloc_mode,\n\t\t\tunsigned long long age)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct sit_info *sm = SIT_I(sbi);\n\tstruct victim_sel_policy p;\n\tunsigned int secno, last_victim;\n\tunsigned int last_segment;\n\tunsigned int nsearched;\n\tbool is_atgc;\n\tint ret = 0;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tlast_segment = MAIN_SECS(sbi) * sbi->segs_per_sec;\n\n\tp.alloc_mode = alloc_mode;\n\tp.age = age;\n\tp.age_threshold = sbi->am.age_threshold;\n\nretry:\n\tselect_policy(sbi, gc_type, type, &p);\n\tp.min_segno = NULL_SEGNO;\n\tp.oldest_age = 0;\n\tp.min_cost = get_max_cost(sbi, &p);\n\n\tis_atgc = (p.gc_mode == GC_AT || p.alloc_mode == AT_SSR);\n\tnsearched = 0;\n\n\tif (is_atgc)\n\t\tSIT_I(sbi)->dirty_min_mtime = ULLONG_MAX;\n\n\tif (*result != NULL_SEGNO) {\n\t\tif (!get_valid_blocks(sbi, *result, false)) {\n\t\t\tret = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (sec_usage_check(sbi, GET_SEC_FROM_SEG(sbi, *result)))\n\t\t\tret = -EBUSY;\n\t\telse\n\t\t\tp.min_segno = *result;\n\t\tgoto out;\n\t}\n\n\tret = -ENODATA;\n\tif (p.max_search == 0)\n\t\tgoto out;\n\n\tif (__is_large_section(sbi) && p.alloc_mode == LFS) {\n\t\tif (sbi->next_victim_seg[BG_GC] != NULL_SEGNO) {\n\t\t\tp.min_segno = sbi->next_victim_seg[BG_GC];\n\t\t\t*result = p.min_segno;\n\t\t\tsbi->next_victim_seg[BG_GC] = NULL_SEGNO;\n\t\t\tgoto got_result;\n\t\t}\n\t\tif (gc_type == FG_GC &&\n\t\t\t\tsbi->next_victim_seg[FG_GC] != NULL_SEGNO) {\n\t\t\tp.min_segno = sbi->next_victim_seg[FG_GC];\n\t\t\t*result = p.min_segno;\n\t\t\tsbi->next_victim_seg[FG_GC] = NULL_SEGNO;\n\t\t\tgoto got_result;\n\t\t}\n\t}\n\n\tlast_victim = sm->last_victim[p.gc_mode];\n\tif (p.alloc_mode == LFS && gc_type == FG_GC) {\n\t\tp.min_segno = check_bg_victims(sbi);\n\t\tif (p.min_segno != NULL_SEGNO)\n\t\t\tgoto got_it;\n\t}\n\n\twhile (1) {\n\t\tunsigned long cost, *dirty_bitmap;\n\t\tunsigned int unit_no, segno;\n\n\t\tdirty_bitmap = p.dirty_bitmap;\n\t\tunit_no = find_next_bit(dirty_bitmap,\n\t\t\t\tlast_segment / p.ofs_unit,\n\t\t\t\tp.offset / p.ofs_unit);\n\t\tsegno = unit_no * p.ofs_unit;\n\t\tif (segno >= last_segment) {\n\t\t\tif (sm->last_victim[p.gc_mode]) {\n\t\t\t\tlast_segment =\n\t\t\t\t\tsm->last_victim[p.gc_mode];\n\t\t\t\tsm->last_victim[p.gc_mode] = 0;\n\t\t\t\tp.offset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tp.offset = segno + p.ofs_unit;\n\t\tnsearched++;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\t \n\t\tif (test_bit(segno, sm->invalid_segmap))\n\t\t\tgoto next;\n#endif\n\n\t\tsecno = GET_SEC_FROM_SEG(sbi, segno);\n\n\t\tif (sec_usage_check(sbi, secno))\n\t\t\tgoto next;\n\n\t\t \n\t\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\t\tif (p.alloc_mode == LFS) {\n\t\t\t\t \n\t\t\t\tif (get_ckpt_valid_blocks(sbi, segno, true))\n\t\t\t\t\tgoto next;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!f2fs_segment_has_free_slot(sbi, segno))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_type == BG_GC && test_bit(secno, dirty_i->victim_secmap))\n\t\t\tgoto next;\n\n\t\tif (gc_type == FG_GC && f2fs_section_is_pinned(dirty_i, secno))\n\t\t\tgoto next;\n\n\t\tif (is_atgc) {\n\t\t\tadd_victim_entry(sbi, &p, segno);\n\t\t\tgoto next;\n\t\t}\n\n\t\tcost = get_gc_cost(sbi, segno, &p);\n\n\t\tif (p.min_cost > cost) {\n\t\t\tp.min_segno = segno;\n\t\t\tp.min_cost = cost;\n\t\t}\nnext:\n\t\tif (nsearched >= p.max_search) {\n\t\t\tif (!sm->last_victim[p.gc_mode] && segno <= last_victim)\n\t\t\t\tsm->last_victim[p.gc_mode] =\n\t\t\t\t\tlast_victim + p.ofs_unit;\n\t\t\telse\n\t\t\t\tsm->last_victim[p.gc_mode] = segno + p.ofs_unit;\n\t\t\tsm->last_victim[p.gc_mode] %=\n\t\t\t\t(MAIN_SECS(sbi) * sbi->segs_per_sec);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (is_atgc) {\n\t\tlookup_victim_by_age(sbi, &p);\n\t\trelease_victim_entry(sbi);\n\t}\n\n\tif (is_atgc && p.min_segno == NULL_SEGNO &&\n\t\t\tsm->elapsed_time < p.age_threshold) {\n\t\tp.age_threshold = 0;\n\t\tgoto retry;\n\t}\n\n\tif (p.min_segno != NULL_SEGNO) {\ngot_it:\n\t\t*result = (p.min_segno / p.ofs_unit) * p.ofs_unit;\ngot_result:\n\t\tif (p.alloc_mode == LFS) {\n\t\t\tsecno = GET_SEC_FROM_SEG(sbi, p.min_segno);\n\t\t\tif (gc_type == FG_GC)\n\t\t\t\tsbi->cur_victim_sec = secno;\n\t\t\telse\n\t\t\t\tset_bit(secno, dirty_i->victim_secmap);\n\t\t}\n\t\tret = 0;\n\n\t}\nout:\n\tif (p.min_segno != NULL_SEGNO)\n\t\ttrace_f2fs_get_victim(sbi->sb, type, gc_type, &p,\n\t\t\t\tsbi->cur_victim_sec,\n\t\t\t\tprefree_segments(sbi), free_segments(sbi));\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treturn ret;\n}\n\nstatic struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)\n{\n\tstruct inode_entry *ie;\n\n\tie = radix_tree_lookup(&gc_list->iroot, ino);\n\tif (ie)\n\t\treturn ie->inode;\n\treturn NULL;\n}\n\nstatic void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)\n{\n\tstruct inode_entry *new_ie;\n\n\tif (inode == find_gc_inode(gc_list, inode->i_ino)) {\n\t\tiput(inode);\n\t\treturn;\n\t}\n\tnew_ie = f2fs_kmem_cache_alloc(f2fs_inode_entry_slab,\n\t\t\t\t\tGFP_NOFS, true, NULL);\n\tnew_ie->inode = inode;\n\n\tf2fs_radix_tree_insert(&gc_list->iroot, inode->i_ino, new_ie);\n\tlist_add_tail(&new_ie->list, &gc_list->ilist);\n}\n\nstatic void put_gc_inode(struct gc_inode_list *gc_list)\n{\n\tstruct inode_entry *ie, *next_ie;\n\n\tlist_for_each_entry_safe(ie, next_ie, &gc_list->ilist, list) {\n\t\tradix_tree_delete(&gc_list->iroot, ie->inode->i_ino);\n\t\tiput(ie->inode);\n\t\tlist_del(&ie->list);\n\t\tkmem_cache_free(f2fs_inode_entry_slab, ie);\n\t}\n}\n\nstatic int check_valid_map(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int segno, int offset)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct seg_entry *sentry;\n\tint ret;\n\n\tdown_read(&sit_i->sentry_lock);\n\tsentry = get_seg_entry(sbi, segno);\n\tret = f2fs_test_bit(offset, sentry->cur_valid_map);\n\tup_read(&sit_i->sentry_lock);\n\treturn ret;\n}\n\n \nstatic int gc_node_segment(struct f2fs_sb_info *sbi,\n\t\tstruct f2fs_summary *sum, unsigned int segno, int gc_type)\n{\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\tbool fggc = (gc_type == FG_GC);\n\tint submitted = 0;\n\tunsigned int usable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tif (fggc && phase == 2)\n\t\tatomic_inc(&sbi->wb_sync_req[NODE]);\n\n\tfor (off = 0; off < usable_blks_in_seg; off++, entry++) {\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\t\tstruct page *node_page;\n\t\tstruct node_info ni;\n\t\tint err;\n\n\t\t \n\t\tif (gc_type == BG_GC && has_not_enough_free_secs(sbi, 0, 0))\n\t\t\treturn submitted;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tf2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), 1,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (phase == 1) {\n\t\t\tf2fs_ra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnode_page = f2fs_get_node_page(sbi, nid);\n\t\tif (IS_ERR(node_page))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (check_valid_map(sbi, segno, off) == 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (f2fs_get_node_info(sbi, nid, &ni, false)) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ni.blk_addr != start_addr + off) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = f2fs_move_node_page(node_page, gc_type);\n\t\tif (!err && gc_type == FG_GC)\n\t\t\tsubmitted++;\n\t\tstat_inc_node_blk_count(sbi, 1, gc_type);\n\t}\n\n\tif (++phase < 3)\n\t\tgoto next_step;\n\n\tif (fggc)\n\t\tatomic_dec(&sbi->wb_sync_req[NODE]);\n\treturn submitted;\n}\n\n \nblock_t f2fs_start_bidx_of_node(unsigned int node_ofs, struct inode *inode)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK(inode) + ADDRS_PER_INODE(inode);\n}\n\nstatic bool is_alive(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct node_info *dni, block_t blkaddr, unsigned int *nofs)\n{\n\tstruct page *node_page;\n\tnid_t nid;\n\tunsigned int ofs_in_node, max_addrs, base;\n\tblock_t source_blkaddr;\n\n\tnid = le32_to_cpu(sum->nid);\n\tofs_in_node = le16_to_cpu(sum->ofs_in_node);\n\n\tnode_page = f2fs_get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn false;\n\n\tif (f2fs_get_node_info(sbi, nid, dni, false)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn false;\n\t}\n\n\tif (sum->version != dni->version) {\n\t\tf2fs_warn(sbi, \"%s: valid data with mismatched node version.\",\n\t\t\t  __func__);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t}\n\n\tif (f2fs_check_nid_range(sbi, dni->ino)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn false;\n\t}\n\n\tif (IS_INODE(node_page)) {\n\t\tbase = offset_in_addr(F2FS_INODE(node_page));\n\t\tmax_addrs = DEF_ADDRS_PER_INODE;\n\t} else {\n\t\tbase = 0;\n\t\tmax_addrs = DEF_ADDRS_PER_BLOCK;\n\t}\n\n\tif (base + ofs_in_node >= max_addrs) {\n\t\tf2fs_err(sbi, \"Inconsistent blkaddr offset: base:%u, ofs_in_node:%u, max:%u, ino:%u, nid:%u\",\n\t\t\tbase, ofs_in_node, max_addrs, dni->ino, dni->nid);\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn false;\n\t}\n\n\t*nofs = ofs_of_node(node_page);\n\tsource_blkaddr = data_blkaddr(NULL, node_page, ofs_in_node);\n\tf2fs_put_page(node_page, 1);\n\n\tif (source_blkaddr != blkaddr) {\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\t\tunsigned long offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\t\tif (unlikely(check_valid_map(sbi, segno, offset))) {\n\t\t\tif (!test_and_set_bit(segno, SIT_I(sbi)->invalid_segmap)) {\n\t\t\t\tf2fs_err(sbi, \"mismatched blkaddr %u (source_blkaddr %u) in seg %u\",\n\t\t\t\t\t blkaddr, source_blkaddr, segno);\n\t\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int ra_data_block(struct inode *inode, pgoff_t index)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.ino = inode->i_ino,\n\t\t.type = DATA,\n\t\t.temp = COLD,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = 0,\n\t\t.encrypted_page = NULL,\n\t\t.in_list = 0,\n\t\t.retry = 0,\n\t};\n\tint err;\n\n\tpage = f2fs_grab_cache_page(mapping, index, true);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (f2fs_lookup_read_extent_cache_block(inode, index,\n\t\t\t\t\t\t&dn.data_blkaddr)) {\n\t\tif (unlikely(!f2fs_is_valid_blkaddr(sbi, dn.data_blkaddr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ))) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\t\tgoto put_page;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\tgoto put_page;\n\tf2fs_put_dnode(&dn);\n\n\tif (!__is_valid_data_blkaddr(dn.data_blkaddr)) {\n\t\terr = -ENOENT;\n\t\tgoto put_page;\n\t}\n\tif (unlikely(!f2fs_is_valid_blkaddr(sbi, dn.data_blkaddr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\terr = -EFSCORRUPTED;\n\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\tgoto put_page;\n\t}\ngot_it:\n\t \n\tfio.page = page;\n\tfio.new_blkaddr = fio.old_blkaddr = dn.data_blkaddr;\n\n\t \n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\tf2fs_wait_on_block_writeback(inode, dn.data_blkaddr);\n\n\tfio.encrypted_page = f2fs_pagecache_get_page(META_MAPPING(sbi),\n\t\t\t\t\tdn.data_blkaddr,\n\t\t\t\t\tFGP_LOCK | FGP_CREAT, GFP_NOFS);\n\tif (!fio.encrypted_page) {\n\t\terr = -ENOMEM;\n\t\tgoto put_page;\n\t}\n\n\terr = f2fs_submit_page_bio(&fio);\n\tif (err)\n\t\tgoto put_encrypted_page;\n\tf2fs_put_page(fio.encrypted_page, 0);\n\tf2fs_put_page(page, 1);\n\n\tf2fs_update_iostat(sbi, inode, FS_DATA_READ_IO, F2FS_BLKSIZE);\n\tf2fs_update_iostat(sbi, NULL, FS_GDATA_READ_IO, F2FS_BLKSIZE);\n\n\treturn 0;\nput_encrypted_page:\n\tf2fs_put_page(fio.encrypted_page, 1);\nput_page:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n\n \nstatic int move_data_block(struct inode *inode, block_t bidx,\n\t\t\t\tint gc_type, unsigned int segno, int off)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = F2FS_I_SB(inode),\n\t\t.ino = inode->i_ino,\n\t\t.type = DATA,\n\t\t.temp = COLD,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = 0,\n\t\t.encrypted_page = NULL,\n\t\t.in_list = 0,\n\t\t.retry = 0,\n\t};\n\tstruct dnode_of_data dn;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tstruct page *page, *mpage;\n\tblock_t newaddr;\n\tint err = 0;\n\tbool lfs_mode = f2fs_lfs_mode(fio.sbi);\n\tint type = fio.sbi->am.atgc_enabled && (gc_type == BG_GC) &&\n\t\t\t\t(fio.sbi->gc_mode != GC_URGENT_HIGH) ?\n\t\t\t\tCURSEG_ALL_DATA_ATGC : CURSEG_COLD_DATA;\n\n\t \n\tpage = f2fs_grab_cache_page(inode->i_mapping, bidx, false);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!check_valid_map(F2FS_I_SB(inode), segno, off)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = f2fs_gc_pinned_control(inode, gc_type, segno);\n\tif (err)\n\t\tgoto out;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, bidx, LOOKUP_NODE);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\terr = -ENOENT;\n\t\tgoto put_out;\n\t}\n\n\t \n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\tf2fs_wait_on_block_writeback(inode, dn.data_blkaddr);\n\n\terr = f2fs_get_node_info(fio.sbi, dn.nid, &ni, false);\n\tif (err)\n\t\tgoto put_out;\n\n\t \n\tfio.page = page;\n\tfio.new_blkaddr = fio.old_blkaddr = dn.data_blkaddr;\n\n\tif (lfs_mode)\n\t\tf2fs_down_write(&fio.sbi->io_order_lock);\n\n\tmpage = f2fs_grab_cache_page(META_MAPPING(fio.sbi),\n\t\t\t\t\tfio.old_blkaddr, false);\n\tif (!mpage) {\n\t\terr = -ENOMEM;\n\t\tgoto up_out;\n\t}\n\n\tfio.encrypted_page = mpage;\n\n\t \n\tif (!PageUptodate(mpage)) {\n\t\terr = f2fs_submit_page_bio(&fio);\n\t\tif (err) {\n\t\t\tf2fs_put_page(mpage, 1);\n\t\t\tgoto up_out;\n\t\t}\n\n\t\tf2fs_update_iostat(fio.sbi, inode, FS_DATA_READ_IO,\n\t\t\t\t\t\t\tF2FS_BLKSIZE);\n\t\tf2fs_update_iostat(fio.sbi, NULL, FS_GDATA_READ_IO,\n\t\t\t\t\t\t\tF2FS_BLKSIZE);\n\n\t\tlock_page(mpage);\n\t\tif (unlikely(mpage->mapping != META_MAPPING(fio.sbi) ||\n\t\t\t\t\t\t!PageUptodate(mpage))) {\n\t\t\terr = -EIO;\n\t\t\tf2fs_put_page(mpage, 1);\n\t\t\tgoto up_out;\n\t\t}\n\t}\n\n\tset_summary(&sum, dn.nid, dn.ofs_in_node, ni.version);\n\n\t \n\tf2fs_allocate_data_block(fio.sbi, NULL, fio.old_blkaddr, &newaddr,\n\t\t\t\t&sum, type, NULL);\n\n\tfio.encrypted_page = f2fs_pagecache_get_page(META_MAPPING(fio.sbi),\n\t\t\t\tnewaddr, FGP_LOCK | FGP_CREAT, GFP_NOFS);\n\tif (!fio.encrypted_page) {\n\t\terr = -ENOMEM;\n\t\tf2fs_put_page(mpage, 1);\n\t\tgoto recover_block;\n\t}\n\n\t \n\tf2fs_wait_on_page_writeback(fio.encrypted_page, DATA, true, true);\n\tmemcpy(page_address(fio.encrypted_page),\n\t\t\t\tpage_address(mpage), PAGE_SIZE);\n\tf2fs_put_page(mpage, 1);\n\tinvalidate_mapping_pages(META_MAPPING(fio.sbi),\n\t\t\t\tfio.old_blkaddr, fio.old_blkaddr);\n\tf2fs_invalidate_compress_page(fio.sbi, fio.old_blkaddr);\n\n\tset_page_dirty(fio.encrypted_page);\n\tif (clear_page_dirty_for_io(fio.encrypted_page))\n\t\tdec_page_count(fio.sbi, F2FS_DIRTY_META);\n\n\tset_page_writeback(fio.encrypted_page);\n\n\tfio.op = REQ_OP_WRITE;\n\tfio.op_flags = REQ_SYNC;\n\tfio.new_blkaddr = newaddr;\n\tf2fs_submit_page_write(&fio);\n\tif (fio.retry) {\n\t\terr = -EAGAIN;\n\t\tif (PageWriteback(fio.encrypted_page))\n\t\t\tend_page_writeback(fio.encrypted_page);\n\t\tgoto put_page_out;\n\t}\n\n\tf2fs_update_iostat(fio.sbi, NULL, FS_GC_DATA_IO, F2FS_BLKSIZE);\n\n\tf2fs_update_data_blkaddr(&dn, newaddr);\n\tset_inode_flag(inode, FI_APPEND_WRITE);\n\tif (page->index == 0)\n\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\nput_page_out:\n\tf2fs_put_page(fio.encrypted_page, 1);\nrecover_block:\n\tif (err)\n\t\tf2fs_do_replace_block(fio.sbi, &sum, newaddr, fio.old_blkaddr,\n\t\t\t\t\t\t\ttrue, true, true);\nup_out:\n\tif (lfs_mode)\n\t\tf2fs_up_write(&fio.sbi->io_order_lock);\nput_out:\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n\nstatic int move_data_page(struct inode *inode, block_t bidx, int gc_type,\n\t\t\t\t\t\t\tunsigned int segno, int off)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = f2fs_get_lock_data_page(inode, bidx, true);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tif (!check_valid_map(F2FS_I_SB(inode), segno, off)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = f2fs_gc_pinned_control(inode, gc_type, segno);\n\tif (err)\n\t\tgoto out;\n\n\tif (gc_type == BG_GC) {\n\t\tif (PageWriteback(page)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tset_page_private_gcing(page);\n\t} else {\n\t\tstruct f2fs_io_info fio = {\n\t\t\t.sbi = F2FS_I_SB(inode),\n\t\t\t.ino = inode->i_ino,\n\t\t\t.type = DATA,\n\t\t\t.temp = COLD,\n\t\t\t.op = REQ_OP_WRITE,\n\t\t\t.op_flags = REQ_SYNC,\n\t\t\t.old_blkaddr = NULL_ADDR,\n\t\t\t.page = page,\n\t\t\t.encrypted_page = NULL,\n\t\t\t.need_lock = LOCK_REQ,\n\t\t\t.io_type = FS_GC_DATA_IO,\n\t\t};\n\t\tbool is_dirty = PageDirty(page);\n\nretry:\n\t\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\t\tset_page_dirty(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tinode_dec_dirty_pages(inode);\n\t\t\tf2fs_remove_dirty_inode(inode);\n\t\t}\n\n\t\tset_page_private_gcing(page);\n\n\t\terr = f2fs_do_write_data_page(&fio);\n\t\tif (err) {\n\t\t\tclear_page_private_gcing(page);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tmemalloc_retry_wait(GFP_NOFS);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (is_dirty)\n\t\t\t\tset_page_dirty(page);\n\t\t}\n\t}\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n\n \nstatic int gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\tstruct gc_inode_list *gc_list, unsigned int segno, int gc_type,\n\t\tbool force_migrate)\n{\n\tstruct super_block *sb = sbi->sb;\n\tstruct f2fs_summary *entry;\n\tblock_t start_addr;\n\tint off;\n\tint phase = 0;\n\tint submitted = 0;\n\tunsigned int usable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);\n\n\tstart_addr = START_BLOCK(sbi, segno);\n\nnext_step:\n\tentry = sum;\n\n\tfor (off = 0; off < usable_blks_in_seg; off++, entry++) {\n\t\tstruct page *data_page;\n\t\tstruct inode *inode;\n\t\tstruct node_info dni;  \n\t\tunsigned int ofs_in_node, nofs;\n\t\tblock_t start_bidx;\n\t\tnid_t nid = le32_to_cpu(entry->nid);\n\n\t\t \n\t\tif ((gc_type == BG_GC && has_not_enough_free_secs(sbi, 0, 0)) ||\n\t\t\t(!force_migrate && get_valid_blocks(sbi, segno, true) ==\n\t\t\t\t\t\t\tCAP_BLKS_PER_SEC(sbi)))\n\t\t\treturn submitted;\n\n\t\tif (check_valid_map(sbi, segno, off) == 0)\n\t\t\tcontinue;\n\n\t\tif (phase == 0) {\n\t\t\tf2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), 1,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (phase == 1) {\n\t\t\tf2fs_ra_node_page(sbi, nid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!is_alive(sbi, entry, &dni, start_addr + off, &nofs))\n\t\t\tcontinue;\n\n\t\tif (phase == 2) {\n\t\t\tf2fs_ra_node_page(sbi, dni.ino);\n\t\t\tcontinue;\n\t\t}\n\n\t\tofs_in_node = le16_to_cpu(entry->ofs_in_node);\n\n\t\tif (phase == 3) {\n\t\t\tint err;\n\n\t\t\tinode = f2fs_iget(sb, dni.ino);\n\t\t\tif (IS_ERR(inode) || is_bad_inode(inode) ||\n\t\t\t\t\tspecial_file(inode->i_mode))\n\t\t\t\tcontinue;\n\n\t\t\terr = f2fs_gc_pinned_control(inode, gc_type, segno);\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tiput(inode);\n\t\t\t\treturn submitted;\n\t\t\t}\n\n\t\t\tif (!f2fs_down_write_trylock(\n\t\t\t\t&F2FS_I(inode)->i_gc_rwsem[WRITE])) {\n\t\t\t\tiput(inode);\n\t\t\t\tsbi->skipped_gc_rwsem++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstart_bidx = f2fs_start_bidx_of_node(nofs, inode) +\n\t\t\t\t\t\t\t\tofs_in_node;\n\n\t\t\tif (f2fs_post_read_required(inode)) {\n\t\t\t\tint err = ra_data_block(inode, start_bidx);\n\n\t\t\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t\t\tif (err) {\n\t\t\t\t\tiput(inode);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata_page = f2fs_get_read_data_page(inode, start_bidx,\n\t\t\t\t\t\t\tREQ_RAHEAD, true, NULL);\n\t\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t\tif (IS_ERR(data_page)) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf2fs_put_page(data_page, 0);\n\t\t\tadd_gc_inode(gc_list, inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tinode = find_gc_inode(gc_list, dni.ino);\n\t\tif (inode) {\n\t\t\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\t\t\tbool locked = false;\n\t\t\tint err;\n\n\t\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\t\tif (!f2fs_down_write_trylock(&fi->i_gc_rwsem[WRITE])) {\n\t\t\t\t\tsbi->skipped_gc_rwsem++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!f2fs_down_write_trylock(\n\t\t\t\t\t\t&fi->i_gc_rwsem[READ])) {\n\t\t\t\t\tsbi->skipped_gc_rwsem++;\n\t\t\t\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlocked = true;\n\n\t\t\t\t \n\t\t\t\tinode_dio_wait(inode);\n\t\t\t}\n\n\t\t\tstart_bidx = f2fs_start_bidx_of_node(nofs, inode)\n\t\t\t\t\t\t\t\t+ ofs_in_node;\n\t\t\tif (f2fs_post_read_required(inode))\n\t\t\t\terr = move_data_block(inode, start_bidx,\n\t\t\t\t\t\t\tgc_type, segno, off);\n\t\t\telse\n\t\t\t\terr = move_data_page(inode, start_bidx, gc_type,\n\t\t\t\t\t\t\t\tsegno, off);\n\n\t\t\tif (!err && (gc_type == FG_GC ||\n\t\t\t\t\tf2fs_post_read_required(inode)))\n\t\t\t\tsubmitted++;\n\n\t\t\tif (locked) {\n\t\t\t\tf2fs_up_write(&fi->i_gc_rwsem[READ]);\n\t\t\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\t\t}\n\n\t\t\tstat_inc_data_blk_count(sbi, 1, gc_type);\n\t\t}\n\t}\n\n\tif (++phase < 5)\n\t\tgoto next_step;\n\n\treturn submitted;\n}\n\nstatic int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,\n\t\t\tint gc_type)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tint ret;\n\n\tdown_write(&sit_i->sentry_lock);\n\tret = f2fs_get_victim(sbi, victim, gc_type, NO_CHECK_TYPE, LFS, 0);\n\tup_write(&sit_i->sentry_lock);\n\treturn ret;\n}\n\nstatic int do_garbage_collect(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int start_segno,\n\t\t\t\tstruct gc_inode_list *gc_list, int gc_type,\n\t\t\t\tbool force_migrate)\n{\n\tstruct page *sum_page;\n\tstruct f2fs_summary_block *sum;\n\tstruct blk_plug plug;\n\tunsigned int segno = start_segno;\n\tunsigned int end_segno = start_segno + sbi->segs_per_sec;\n\tint seg_freed = 0, migrated = 0;\n\tunsigned char type = IS_DATASEG(get_seg_entry(sbi, segno)->type) ?\n\t\t\t\t\t\tSUM_TYPE_DATA : SUM_TYPE_NODE;\n\tunsigned char data_type = (type == SUM_TYPE_DATA) ? DATA : NODE;\n\tint submitted = 0;\n\n\tif (__is_large_section(sbi))\n\t\tend_segno = rounddown(end_segno, sbi->segs_per_sec);\n\n\t \n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\tend_segno -= sbi->segs_per_sec -\n\t\t\t\t\tf2fs_usable_segs_in_sec(sbi, segno);\n\n\tsanity_check_seg_type(sbi, get_seg_entry(sbi, segno)->type);\n\n\t \n\tif (__is_large_section(sbi))\n\t\tf2fs_ra_meta_pages(sbi, GET_SUM_BLOCK(sbi, segno),\n\t\t\t\t\tend_segno - segno, META_SSA, true);\n\n\t \n\twhile (segno < end_segno) {\n\t\tsum_page = f2fs_get_sum_page(sbi, segno++);\n\t\tif (IS_ERR(sum_page)) {\n\t\t\tint err = PTR_ERR(sum_page);\n\n\t\t\tend_segno = segno - 1;\n\t\t\tfor (segno = start_segno; segno < end_segno; segno++) {\n\t\t\t\tsum_page = find_get_page(META_MAPPING(sbi),\n\t\t\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\t\t\t\tf2fs_put_page(sum_page, 0);\n\t\t\t\tf2fs_put_page(sum_page, 0);\n\t\t\t}\n\t\t\treturn err;\n\t\t}\n\t\tunlock_page(sum_page);\n\t}\n\n\tblk_start_plug(&plug);\n\n\tfor (segno = start_segno; segno < end_segno; segno++) {\n\n\t\t \n\t\tsum_page = find_get_page(META_MAPPING(sbi),\n\t\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\t\tf2fs_put_page(sum_page, 0);\n\n\t\tif (get_valid_blocks(sbi, segno, false) == 0)\n\t\t\tgoto freed;\n\t\tif (gc_type == BG_GC && __is_large_section(sbi) &&\n\t\t\t\tmigrated >= sbi->migration_granularity)\n\t\t\tgoto skip;\n\t\tif (!PageUptodate(sum_page) || unlikely(f2fs_cp_error(sbi)))\n\t\t\tgoto skip;\n\n\t\tsum = page_address(sum_page);\n\t\tif (type != GET_SUM_TYPE((&sum->footer))) {\n\t\t\tf2fs_err(sbi, \"Inconsistent segment (%u) type [%d, %d] in SSA and SIT\",\n\t\t\t\t segno, type, GET_SUM_TYPE((&sum->footer)));\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_stop_checkpoint(sbi, false,\n\t\t\t\tSTOP_CP_REASON_CORRUPTED_SUMMARY);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t \n\t\tif (type == SUM_TYPE_NODE)\n\t\t\tsubmitted += gc_node_segment(sbi, sum->entries, segno,\n\t\t\t\t\t\t\t\tgc_type);\n\t\telse\n\t\t\tsubmitted += gc_data_segment(sbi, sum->entries, gc_list,\n\t\t\t\t\t\t\tsegno, gc_type,\n\t\t\t\t\t\t\tforce_migrate);\n\n\t\tstat_inc_gc_seg_count(sbi, data_type, gc_type);\n\t\tsbi->gc_reclaimed_segs[sbi->gc_mode]++;\n\t\tmigrated++;\n\nfreed:\n\t\tif (gc_type == FG_GC &&\n\t\t\t\tget_valid_blocks(sbi, segno, false) == 0)\n\t\t\tseg_freed++;\n\n\t\tif (__is_large_section(sbi))\n\t\t\tsbi->next_victim_seg[gc_type] =\n\t\t\t\t(segno + 1 < end_segno) ? segno + 1 : NULL_SEGNO;\nskip:\n\t\tf2fs_put_page(sum_page, 0);\n\t}\n\n\tif (submitted)\n\t\tf2fs_submit_merged_write(sbi, data_type);\n\n\tblk_finish_plug(&plug);\n\n\tif (migrated)\n\t\tstat_inc_gc_sec_count(sbi, data_type, gc_type);\n\n\treturn seg_freed;\n}\n\nint f2fs_gc(struct f2fs_sb_info *sbi, struct f2fs_gc_control *gc_control)\n{\n\tint gc_type = gc_control->init_gc_type;\n\tunsigned int segno = gc_control->victim_segno;\n\tint sec_freed = 0, seg_freed = 0, total_freed = 0, total_sec_freed = 0;\n\tint ret = 0;\n\tstruct cp_control cpc;\n\tstruct gc_inode_list gc_list = {\n\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t.iroot = RADIX_TREE_INIT(gc_list.iroot, GFP_NOFS),\n\t};\n\tunsigned int skipped_round = 0, round = 0;\n\tunsigned int upper_secs;\n\n\ttrace_f2fs_gc_begin(sbi->sb, gc_type, gc_control->no_bg_gc,\n\t\t\t\tgc_control->nr_free_secs,\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_NODES),\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_DENTS),\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_IMETA),\n\t\t\t\tfree_sections(sbi),\n\t\t\t\tfree_segments(sbi),\n\t\t\t\treserved_segments(sbi),\n\t\t\t\tprefree_segments(sbi));\n\n\tcpc.reason = __get_cp_reason(sbi);\ngc_more:\n\tsbi->skipped_gc_rwsem = 0;\n\tif (unlikely(!(sbi->sb->s_flags & SB_ACTIVE))) {\n\t\tret = -EINVAL;\n\t\tgoto stop;\n\t}\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tret = -EIO;\n\t\tgoto stop;\n\t}\n\n\t \n\tif (has_not_enough_free_secs(sbi, 0, 0)) {\n\t\tgc_type = FG_GC;\n\n\t\t \n\t\tif (prefree_segments(sbi)) {\n\t\t\tstat_inc_cp_call_count(sbi, TOTAL_CALL);\n\t\t\tret = f2fs_write_checkpoint(sbi, &cpc);\n\t\t\tif (ret)\n\t\t\t\tgoto stop;\n\t\t\t \n\t\t\tsec_freed = 0;\n\t\t}\n\t}\n\n\t \n\tif (gc_type == BG_GC && gc_control->no_bg_gc) {\n\t\tret = -EINVAL;\n\t\tgoto stop;\n\t}\nretry:\n\tret = __get_victim(sbi, &segno, gc_type);\n\tif (ret) {\n\t\t \n\t\tif (ret == -ENODATA && gc_type == FG_GC &&\n\t\t\t\tf2fs_pinned_section_exists(DIRTY_I(sbi))) {\n\t\t\tf2fs_unpin_all_sections(sbi, false);\n\t\t\tgoto retry;\n\t\t}\n\t\tgoto stop;\n\t}\n\n\tseg_freed = do_garbage_collect(sbi, segno, &gc_list, gc_type,\n\t\t\t\tgc_control->should_migrate_blocks);\n\ttotal_freed += seg_freed;\n\n\tif (seg_freed == f2fs_usable_segs_in_sec(sbi, segno)) {\n\t\tsec_freed++;\n\t\ttotal_sec_freed++;\n\t}\n\n\tif (gc_type == FG_GC) {\n\t\tsbi->cur_victim_sec = NULL_SEGNO;\n\n\t\tif (has_enough_free_secs(sbi, sec_freed, 0)) {\n\t\t\tif (!gc_control->no_bg_gc &&\n\t\t\t    total_sec_freed < gc_control->nr_free_secs)\n\t\t\t\tgoto go_gc_more;\n\t\t\tgoto stop;\n\t\t}\n\t\tif (sbi->skipped_gc_rwsem)\n\t\t\tskipped_round++;\n\t\tround++;\n\t\tif (skipped_round > MAX_SKIP_GC_COUNT &&\n\t\t\t\tskipped_round * 2 >= round) {\n\t\t\tstat_inc_cp_call_count(sbi, TOTAL_CALL);\n\t\t\tret = f2fs_write_checkpoint(sbi, &cpc);\n\t\t\tgoto stop;\n\t\t}\n\t} else if (has_enough_free_secs(sbi, 0, 0)) {\n\t\tgoto stop;\n\t}\n\n\t__get_secs_required(sbi, NULL, &upper_secs, NULL);\n\n\t \n\tif (free_sections(sbi) <= upper_secs + NR_GC_CHECKPOINT_SECS &&\n\t\t\t\tprefree_segments(sbi)) {\n\t\tstat_inc_cp_call_count(sbi, TOTAL_CALL);\n\t\tret = f2fs_write_checkpoint(sbi, &cpc);\n\t\tif (ret)\n\t\t\tgoto stop;\n\t\t \n\t\tsec_freed = 0;\n\t}\ngo_gc_more:\n\tsegno = NULL_SEGNO;\n\tgoto gc_more;\n\nstop:\n\tSIT_I(sbi)->last_victim[ALLOC_NEXT] = 0;\n\tSIT_I(sbi)->last_victim[FLUSH_DEVICE] = gc_control->victim_segno;\n\n\tif (gc_type == FG_GC)\n\t\tf2fs_unpin_all_sections(sbi, true);\n\n\ttrace_f2fs_gc_end(sbi->sb, ret, total_freed, total_sec_freed,\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_NODES),\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_DENTS),\n\t\t\t\tget_pages(sbi, F2FS_DIRTY_IMETA),\n\t\t\t\tfree_sections(sbi),\n\t\t\t\tfree_segments(sbi),\n\t\t\t\treserved_segments(sbi),\n\t\t\t\tprefree_segments(sbi));\n\n\tf2fs_up_write(&sbi->gc_lock);\n\n\tput_gc_inode(&gc_list);\n\n\tif (gc_control->err_gc_skipped && !ret)\n\t\tret = total_sec_freed ? 0 : -EAGAIN;\n\treturn ret;\n}\n\nint __init f2fs_create_garbage_collection_cache(void)\n{\n\tvictim_entry_slab = f2fs_kmem_cache_create(\"f2fs_victim_entry\",\n\t\t\t\t\tsizeof(struct victim_entry));\n\treturn victim_entry_slab ? 0 : -ENOMEM;\n}\n\nvoid f2fs_destroy_garbage_collection_cache(void)\n{\n\tkmem_cache_destroy(victim_entry_slab);\n}\n\nstatic void init_atgc_management(struct f2fs_sb_info *sbi)\n{\n\tstruct atgc_management *am = &sbi->am;\n\n\tif (test_opt(sbi, ATGC) &&\n\t\tSIT_I(sbi)->elapsed_time >= DEF_GC_THREAD_AGE_THRESHOLD)\n\t\tam->atgc_enabled = true;\n\n\tam->root = RB_ROOT_CACHED;\n\tINIT_LIST_HEAD(&am->victim_list);\n\tam->victim_count = 0;\n\n\tam->candidate_ratio = DEF_GC_THREAD_CANDIDATE_RATIO;\n\tam->max_candidate_count = DEF_GC_THREAD_MAX_CANDIDATE_COUNT;\n\tam->age_weight = DEF_GC_THREAD_AGE_WEIGHT;\n\tam->age_threshold = DEF_GC_THREAD_AGE_THRESHOLD;\n}\n\nvoid f2fs_build_gc_manager(struct f2fs_sb_info *sbi)\n{\n\tsbi->gc_pin_file_threshold = DEF_GC_FAILED_PINNED_FILES;\n\n\t \n\tif (f2fs_is_multi_device(sbi) && !__is_large_section(sbi))\n\t\tSIT_I(sbi)->last_victim[ALLOC_NEXT] =\n\t\t\t\tGET_SEGNO(sbi, FDEV(0).end_blk) + 1;\n\n\tinit_atgc_management(sbi);\n}\n\nstatic int free_segment_range(struct f2fs_sb_info *sbi,\n\t\t\t\tunsigned int secs, bool gc_only)\n{\n\tunsigned int segno, next_inuse, start, end;\n\tstruct cp_control cpc = { CP_RESIZE, 0, 0, 0 };\n\tint gc_mode, gc_type;\n\tint err = 0;\n\tint type;\n\n\t \n\tMAIN_SECS(sbi) -= secs;\n\tstart = MAIN_SECS(sbi) * sbi->segs_per_sec;\n\tend = MAIN_SEGS(sbi) - 1;\n\n\tmutex_lock(&DIRTY_I(sbi)->seglist_lock);\n\tfor (gc_mode = 0; gc_mode < MAX_GC_POLICY; gc_mode++)\n\t\tif (SIT_I(sbi)->last_victim[gc_mode] >= start)\n\t\t\tSIT_I(sbi)->last_victim[gc_mode] = 0;\n\n\tfor (gc_type = BG_GC; gc_type <= FG_GC; gc_type++)\n\t\tif (sbi->next_victim_seg[gc_type] >= start)\n\t\t\tsbi->next_victim_seg[gc_type] = NULL_SEGNO;\n\tmutex_unlock(&DIRTY_I(sbi)->seglist_lock);\n\n\t \n\tfor (type = CURSEG_HOT_DATA; type < NR_CURSEG_PERSIST_TYPE; type++)\n\t\tf2fs_allocate_segment_for_resize(sbi, type, start, end);\n\n\t \n\tfor (segno = start; segno <= end; segno += sbi->segs_per_sec) {\n\t\tstruct gc_inode_list gc_list = {\n\t\t\t.ilist = LIST_HEAD_INIT(gc_list.ilist),\n\t\t\t.iroot = RADIX_TREE_INIT(gc_list.iroot, GFP_NOFS),\n\t\t};\n\n\t\tdo_garbage_collect(sbi, segno, &gc_list, FG_GC, true);\n\t\tput_gc_inode(&gc_list);\n\n\t\tif (!gc_only && get_valid_blocks(sbi, segno, true)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (gc_only)\n\t\tgoto out;\n\n\tstat_inc_cp_call_count(sbi, TOTAL_CALL);\n\terr = f2fs_write_checkpoint(sbi, &cpc);\n\tif (err)\n\t\tgoto out;\n\n\tnext_inuse = find_next_inuse(FREE_I(sbi), end + 1, start);\n\tif (next_inuse <= end) {\n\t\tf2fs_err(sbi, \"segno %u should be free but still inuse!\",\n\t\t\t next_inuse);\n\t\tf2fs_bug_on(sbi, 1);\n\t}\nout:\n\tMAIN_SECS(sbi) += secs;\n\treturn err;\n}\n\nstatic void update_sb_metadata(struct f2fs_sb_info *sbi, int secs)\n{\n\tstruct f2fs_super_block *raw_sb = F2FS_RAW_SUPER(sbi);\n\tint section_count;\n\tint segment_count;\n\tint segment_count_main;\n\tlong long block_count;\n\tint segs = secs * sbi->segs_per_sec;\n\n\tf2fs_down_write(&sbi->sb_lock);\n\n\tsection_count = le32_to_cpu(raw_sb->section_count);\n\tsegment_count = le32_to_cpu(raw_sb->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_sb->segment_count_main);\n\tblock_count = le64_to_cpu(raw_sb->block_count);\n\n\traw_sb->section_count = cpu_to_le32(section_count + secs);\n\traw_sb->segment_count = cpu_to_le32(segment_count + segs);\n\traw_sb->segment_count_main = cpu_to_le32(segment_count_main + segs);\n\traw_sb->block_count = cpu_to_le64(block_count +\n\t\t\t\t\t(long long)segs * sbi->blocks_per_seg);\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tint last_dev = sbi->s_ndevs - 1;\n\t\tint dev_segs =\n\t\t\tle32_to_cpu(raw_sb->devs[last_dev].total_segments);\n\n\t\traw_sb->devs[last_dev].total_segments =\n\t\t\t\t\t\tcpu_to_le32(dev_segs + segs);\n\t}\n\n\tf2fs_up_write(&sbi->sb_lock);\n}\n\nstatic void update_fs_metadata(struct f2fs_sb_info *sbi, int secs)\n{\n\tint segs = secs * sbi->segs_per_sec;\n\tlong long blks = (long long)segs * sbi->blocks_per_seg;\n\tlong long user_block_count =\n\t\t\t\tle64_to_cpu(F2FS_CKPT(sbi)->user_block_count);\n\n\tSM_I(sbi)->segment_count = (int)SM_I(sbi)->segment_count + segs;\n\tMAIN_SEGS(sbi) = (int)MAIN_SEGS(sbi) + segs;\n\tMAIN_SECS(sbi) += secs;\n\tFREE_I(sbi)->free_sections = (int)FREE_I(sbi)->free_sections + secs;\n\tFREE_I(sbi)->free_segments = (int)FREE_I(sbi)->free_segments + segs;\n\tF2FS_CKPT(sbi)->user_block_count = cpu_to_le64(user_block_count + blks);\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tint last_dev = sbi->s_ndevs - 1;\n\n\t\tFDEV(last_dev).total_segments =\n\t\t\t\t(int)FDEV(last_dev).total_segments + segs;\n\t\tFDEV(last_dev).end_blk =\n\t\t\t\t(long long)FDEV(last_dev).end_blk + blks;\n#ifdef CONFIG_BLK_DEV_ZONED\n\t\tFDEV(last_dev).nr_blkz = FDEV(last_dev).nr_blkz +\n\t\t\t\t\tdiv_u64(blks, sbi->blocks_per_blkz);\n#endif\n\t}\n}\n\nint f2fs_resize_fs(struct file *filp, __u64 block_count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(file_inode(filp));\n\t__u64 old_block_count, shrunk_blocks;\n\tstruct cp_control cpc = { CP_RESIZE, 0, 0, 0 };\n\tunsigned int secs;\n\tint err = 0;\n\t__u32 rem;\n\n\told_block_count = le64_to_cpu(F2FS_RAW_SUPER(sbi)->block_count);\n\tif (block_count > old_block_count)\n\t\treturn -EINVAL;\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tint last_dev = sbi->s_ndevs - 1;\n\t\t__u64 last_segs = FDEV(last_dev).total_segments;\n\n\t\tif (block_count + last_segs * sbi->blocks_per_seg <=\n\t\t\t\t\t\t\t\told_block_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tdiv_u64_rem(block_count, BLKS_PER_SEC(sbi), &rem);\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tif (block_count == old_block_count)\n\t\treturn 0;\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_err(sbi, \"Should run fsck to repair first.\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (test_opt(sbi, DISABLE_CHECKPOINT)) {\n\t\tf2fs_err(sbi, \"Checkpoint should be enabled.\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mnt_want_write_file(filp);\n\tif (err)\n\t\treturn err;\n\n\tshrunk_blocks = old_block_count - block_count;\n\tsecs = div_u64(shrunk_blocks, BLKS_PER_SEC(sbi));\n\n\t \n\tif (!f2fs_down_write_trylock(&sbi->gc_lock)) {\n\t\terr = -EAGAIN;\n\t\tgoto out_drop_write;\n\t}\n\n\t \n\tf2fs_lock_op(sbi);\n\n\tspin_lock(&sbi->stat_lock);\n\tif (shrunk_blocks + valid_user_blocks(sbi) +\n\t\tsbi->current_reserved_blocks + sbi->unusable_block_count +\n\t\tF2FS_OPTION(sbi).root_reserved_blocks > sbi->user_block_count)\n\t\terr = -ENOSPC;\n\tspin_unlock(&sbi->stat_lock);\n\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = free_segment_range(sbi, secs, true);\n\nout_unlock:\n\tf2fs_unlock_op(sbi);\n\tf2fs_up_write(&sbi->gc_lock);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\tif (err)\n\t\treturn err;\n\n\terr = freeze_super(sbi->sb, FREEZE_HOLDER_USERSPACE);\n\tif (err)\n\t\treturn err;\n\n\tif (f2fs_readonly(sbi->sb)) {\n\t\terr = thaw_super(sbi->sb, FREEZE_HOLDER_USERSPACE);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn -EROFS;\n\t}\n\n\tf2fs_down_write(&sbi->gc_lock);\n\tf2fs_down_write(&sbi->cp_global_sem);\n\n\tspin_lock(&sbi->stat_lock);\n\tif (shrunk_blocks + valid_user_blocks(sbi) +\n\t\tsbi->current_reserved_blocks + sbi->unusable_block_count +\n\t\tF2FS_OPTION(sbi).root_reserved_blocks > sbi->user_block_count)\n\t\terr = -ENOSPC;\n\telse\n\t\tsbi->user_block_count -= shrunk_blocks;\n\tspin_unlock(&sbi->stat_lock);\n\tif (err)\n\t\tgoto out_err;\n\n\tset_sbi_flag(sbi, SBI_IS_RESIZEFS);\n\terr = free_segment_range(sbi, secs, false);\n\tif (err)\n\t\tgoto recover_out;\n\n\tupdate_sb_metadata(sbi, -secs);\n\n\terr = f2fs_commit_super(sbi, false);\n\tif (err) {\n\t\tupdate_sb_metadata(sbi, secs);\n\t\tgoto recover_out;\n\t}\n\n\tupdate_fs_metadata(sbi, -secs);\n\tclear_sbi_flag(sbi, SBI_IS_RESIZEFS);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tstat_inc_cp_call_count(sbi, TOTAL_CALL);\n\terr = f2fs_write_checkpoint(sbi, &cpc);\n\tif (err) {\n\t\tupdate_fs_metadata(sbi, secs);\n\t\tupdate_sb_metadata(sbi, secs);\n\t\tf2fs_commit_super(sbi, false);\n\t}\nrecover_out:\n\tclear_sbi_flag(sbi, SBI_IS_RESIZEFS);\n\tif (err) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_err(sbi, \"resize_fs failed, should run fsck to repair!\");\n\n\t\tspin_lock(&sbi->stat_lock);\n\t\tsbi->user_block_count += shrunk_blocks;\n\t\tspin_unlock(&sbi->stat_lock);\n\t}\nout_err:\n\tf2fs_up_write(&sbi->cp_global_sem);\n\tf2fs_up_write(&sbi->gc_lock);\n\tthaw_super(sbi->sb, FREEZE_HOLDER_USERSPACE);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}