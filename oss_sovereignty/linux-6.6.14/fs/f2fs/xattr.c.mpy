{
  "module_name": "xattr.c",
  "hash_id": "b9ebc25b87d125f429768f8ec6423c97041ca83fe7977edbe2e731fdc3250321",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/xattr.c",
  "human_readable_source": "\n \n#include <linux/rwsem.h>\n#include <linux/f2fs_fs.h>\n#include <linux/security.h>\n#include <linux/posix_acl_xattr.h>\n#include \"f2fs.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n\nstatic void *xattr_alloc(struct f2fs_sb_info *sbi, int size, bool *is_inline)\n{\n\tif (likely(size == sbi->inline_xattr_slab_size)) {\n\t\t*is_inline = true;\n\t\treturn f2fs_kmem_cache_alloc(sbi->inline_xattr_slab,\n\t\t\t\t\tGFP_F2FS_ZERO, false, sbi);\n\t}\n\t*is_inline = false;\n\treturn f2fs_kzalloc(sbi, size, GFP_NOFS);\n}\n\nstatic void xattr_free(struct f2fs_sb_info *sbi, void *xattr_addr,\n\t\t\t\t\t\t\tbool is_inline)\n{\n\tif (is_inline)\n\t\tkmem_cache_free(sbi->inline_xattr_slab, xattr_addr);\n\telse\n\t\tkfree(xattr_addr);\n}\n\nstatic int f2fs_xattr_generic_get(const struct xattr_handler *handler,\n\t\tstruct dentry *unused, struct inode *inode,\n\t\tconst char *name, void *buffer, size_t size)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);\n\n\tswitch (handler->flags) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn f2fs_getxattr(inode, handler->flags, name,\n\t\t\t     buffer, size, NULL);\n}\n\nstatic int f2fs_xattr_generic_set(const struct xattr_handler *handler,\n\t\tstruct mnt_idmap *idmap,\n\t\tstruct dentry *unused, struct inode *inode,\n\t\tconst char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(inode->i_sb);\n\n\tswitch (handler->flags) {\n\tcase F2FS_XATTR_INDEX_USER:\n\t\tif (!test_opt(sbi, XATTR_USER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase F2FS_XATTR_INDEX_TRUSTED:\n\tcase F2FS_XATTR_INDEX_SECURITY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn f2fs_setxattr(inode, handler->flags, name,\n\t\t\t\t\tvalue, size, NULL, flags);\n}\n\nstatic bool f2fs_xattr_user_list(struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dentry->d_sb);\n\n\treturn test_opt(sbi, XATTR_USER);\n}\n\nstatic bool f2fs_xattr_trusted_list(struct dentry *dentry)\n{\n\treturn capable(CAP_SYS_ADMIN);\n}\n\nstatic int f2fs_xattr_advise_get(const struct xattr_handler *handler,\n\t\tstruct dentry *unused, struct inode *inode,\n\t\tconst char *name, void *buffer, size_t size)\n{\n\tif (buffer)\n\t\t*((char *)buffer) = F2FS_I(inode)->i_advise;\n\treturn sizeof(char);\n}\n\nstatic int f2fs_xattr_advise_set(const struct xattr_handler *handler,\n\t\tstruct mnt_idmap *idmap,\n\t\tstruct dentry *unused, struct inode *inode,\n\t\tconst char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tunsigned char old_advise = F2FS_I(inode)->i_advise;\n\tunsigned char new_advise;\n\n\tif (!inode_owner_or_capable(&nop_mnt_idmap, inode))\n\t\treturn -EPERM;\n\tif (value == NULL)\n\t\treturn -EINVAL;\n\n\tnew_advise = *(char *)value;\n\tif (new_advise & ~FADVISE_MODIFIABLE_BITS)\n\t\treturn -EINVAL;\n\n\tnew_advise = new_advise & FADVISE_MODIFIABLE_BITS;\n\tnew_advise |= old_advise & ~FADVISE_MODIFIABLE_BITS;\n\n\tF2FS_I(inode)->i_advise = new_advise;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\treturn 0;\n}\n\n#ifdef CONFIG_F2FS_FS_SECURITY\nstatic int f2fs_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\tvoid *page)\n{\n\tconst struct xattr *xattr;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = f2fs_setxattr(inode, F2FS_XATTR_INDEX_SECURITY,\n\t\t\t\txattr->name, xattr->value,\n\t\t\t\txattr->value_len, (struct page *)page, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nint f2fs_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr, struct page *ipage)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t&f2fs_initxattrs, ipage);\n}\n#endif\n\nconst struct xattr_handler f2fs_xattr_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.flags\t= F2FS_XATTR_INDEX_USER,\n\t.list\t= f2fs_xattr_user_list,\n\t.get\t= f2fs_xattr_generic_get,\n\t.set\t= f2fs_xattr_generic_set,\n};\n\nconst struct xattr_handler f2fs_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.flags\t= F2FS_XATTR_INDEX_TRUSTED,\n\t.list\t= f2fs_xattr_trusted_list,\n\t.get\t= f2fs_xattr_generic_get,\n\t.set\t= f2fs_xattr_generic_set,\n};\n\nconst struct xattr_handler f2fs_xattr_advise_handler = {\n\t.name\t= F2FS_SYSTEM_ADVISE_NAME,\n\t.flags\t= F2FS_XATTR_INDEX_ADVISE,\n\t.get\t= f2fs_xattr_advise_get,\n\t.set\t= f2fs_xattr_advise_set,\n};\n\nconst struct xattr_handler f2fs_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.flags\t= F2FS_XATTR_INDEX_SECURITY,\n\t.get\t= f2fs_xattr_generic_get,\n\t.set\t= f2fs_xattr_generic_set,\n};\n\nstatic const struct xattr_handler *f2fs_xattr_handler_map[] = {\n\t[F2FS_XATTR_INDEX_USER] = &f2fs_xattr_user_handler,\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\n\t[F2FS_XATTR_INDEX_POSIX_ACL_ACCESS] = &nop_posix_acl_access,\n\t[F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT] = &nop_posix_acl_default,\n#endif\n\t[F2FS_XATTR_INDEX_TRUSTED] = &f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t[F2FS_XATTR_INDEX_SECURITY] = &f2fs_xattr_security_handler,\n#endif\n\t[F2FS_XATTR_INDEX_ADVISE] = &f2fs_xattr_advise_handler,\n};\n\nconst struct xattr_handler *f2fs_xattr_handlers[] = {\n\t&f2fs_xattr_user_handler,\n\t&f2fs_xattr_trusted_handler,\n#ifdef CONFIG_F2FS_FS_SECURITY\n\t&f2fs_xattr_security_handler,\n#endif\n\t&f2fs_xattr_advise_handler,\n\tNULL,\n};\n\nstatic inline const char *f2fs_xattr_prefix(int index,\n\t\t\t\t\t    struct dentry *dentry)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (index > 0 && index < ARRAY_SIZE(f2fs_xattr_handler_map))\n\t\thandler = f2fs_xattr_handler_map[index];\n\n\tif (!xattr_handler_can_list(handler, dentry))\n\t\treturn NULL;\n\n\treturn xattr_prefix(handler);\n}\n\nstatic struct f2fs_xattr_entry *__find_xattr(void *base_addr,\n\t\t\t\tvoid *last_base_addr, void **last_addr,\n\t\t\t\tint index, size_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr) {\n\t\t\tif (last_addr)\n\t\t\t\t*last_addr = entry;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}\n\nstatic struct f2fs_xattr_entry *__find_inline_xattr(struct inode *inode,\n\t\t\t\tvoid *base_addr, void **last_addr, int index,\n\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tvoid *max_addr = base_addr + inline_size;\n\n\tentry = __find_xattr(base_addr, max_addr, last_addr, index, len, name);\n\tif (!entry)\n\t\treturn NULL;\n\n\t \n\tif (IS_XATTR_LAST_ENTRY(entry) &&\n\t\t(void *)entry + sizeof(__u32) > max_addr) {\n\t\t*last_addr = entry;\n\t\treturn NULL;\n\t}\n\treturn entry;\n}\n\nstatic int read_inline_xattr(struct inode *inode, struct page *ipage,\n\t\t\t\t\t\t\tvoid *txattr_addr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tstruct page *page = NULL;\n\tvoid *inline_addr;\n\n\tif (ipage) {\n\t\tinline_addr = inline_xattr_addr(inode, ipage);\n\t} else {\n\t\tpage = f2fs_get_node_page(sbi, inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tinline_addr = inline_xattr_addr(inode, page);\n\t}\n\tmemcpy(txattr_addr, inline_addr, inline_size);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}\n\nstatic int read_xattr_block(struct inode *inode, void *txattr_addr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tstruct page *xpage;\n\tvoid *xattr_addr;\n\n\t \n\txpage = f2fs_get_node_page(sbi, xnid);\n\tif (IS_ERR(xpage))\n\t\treturn PTR_ERR(xpage);\n\n\txattr_addr = page_address(xpage);\n\tmemcpy(txattr_addr + inline_size, xattr_addr, VALID_XATTR_BLOCK_SIZE);\n\tf2fs_put_page(xpage, 1);\n\n\treturn 0;\n}\n\nstatic int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size,\n\t\t\t\tbool *is_inline)\n{\n\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;\n\tvoid *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err;\n\n\tif (!xnid && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = XATTR_SIZE(inode) + XATTR_PADDING_SIZE;\n\ttxattr_addr = xattr_alloc(F2FS_I_SB(inode), *base_size, is_inline);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(inode);\n\n\t \n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t \n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, last_txattr_addr, NULL, index, len, name);\n\tif (!*xe) {\n\t\tf2fs_err(F2FS_I_SB(inode), \"lookup inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terr = -ENODATA;\n\t\tf2fs_handle_error(F2FS_I_SB(inode),\n\t\t\t\t\tERROR_CORRUPTED_XATTR);\n\t\tgoto out;\n\t}\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\txattr_free(F2FS_I_SB(inode), txattr_addr, *is_inline);\n\treturn err;\n}\n\nstatic int read_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\t\t\t\tvoid **base_addr)\n{\n\tstruct f2fs_xattr_header *header;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int size = VALID_XATTR_BLOCK_SIZE;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tvoid *txattr_addr;\n\tint err;\n\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode),\n\t\t\tinline_size + size + XATTR_PADDING_SIZE, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\t \n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\theader = XATTR_HDR(txattr_addr);\n\n\t \n\tif (le32_to_cpu(header->h_magic) != F2FS_XATTR_MAGIC) {\n\t\theader->h_magic = cpu_to_le32(F2FS_XATTR_MAGIC);\n\t\theader->h_refcount = cpu_to_le32(1);\n\t}\n\t*base_addr = txattr_addr;\n\treturn 0;\nfail:\n\tkfree(txattr_addr);\n\treturn err;\n}\n\nstatic inline int write_all_xattrs(struct inode *inode, __u32 hsize,\n\t\t\t\tvoid *txattr_addr, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tsize_t inline_size = inline_xattr_size(inode);\n\tstruct page *in_page = NULL;\n\tvoid *xattr_addr;\n\tvoid *inline_addr = NULL;\n\tstruct page *xpage;\n\tnid_t new_nid = 0;\n\tint err = 0;\n\n\tif (hsize > inline_size && !F2FS_I(inode)->i_xattr_nid)\n\t\tif (!f2fs_alloc_nid(sbi, &new_nid))\n\t\t\treturn -ENOSPC;\n\n\t \n\tif (inline_size) {\n\t\tif (ipage) {\n\t\t\tinline_addr = inline_xattr_addr(inode, ipage);\n\t\t} else {\n\t\t\tin_page = f2fs_get_node_page(sbi, inode->i_ino);\n\t\t\tif (IS_ERR(in_page)) {\n\t\t\t\tf2fs_alloc_nid_failed(sbi, new_nid);\n\t\t\t\treturn PTR_ERR(in_page);\n\t\t\t}\n\t\t\tinline_addr = inline_xattr_addr(inode, in_page);\n\t\t}\n\n\t\tf2fs_wait_on_page_writeback(ipage ? ipage : in_page,\n\t\t\t\t\t\t\tNODE, true, true);\n\t\t \n\t\tif (hsize <= inline_size) {\n\t\t\terr = f2fs_truncate_xattr_node(inode);\n\t\t\tf2fs_alloc_nid_failed(sbi, new_nid);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(in_page, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\t\t\tset_page_dirty(ipage ? ipage : in_page);\n\t\t\tgoto in_page_out;\n\t\t}\n\t}\n\n\t \n\tif (F2FS_I(inode)->i_xattr_nid) {\n\t\txpage = f2fs_get_node_page(sbi, F2FS_I(inode)->i_xattr_nid);\n\t\tif (IS_ERR(xpage)) {\n\t\t\terr = PTR_ERR(xpage);\n\t\t\tf2fs_alloc_nid_failed(sbi, new_nid);\n\t\t\tgoto in_page_out;\n\t\t}\n\t\tf2fs_bug_on(sbi, new_nid);\n\t\tf2fs_wait_on_page_writeback(xpage, NODE, true, true);\n\t} else {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, new_nid);\n\t\txpage = f2fs_new_node_page(&dn, XATTR_NODE_OFFSET);\n\t\tif (IS_ERR(xpage)) {\n\t\t\terr = PTR_ERR(xpage);\n\t\t\tf2fs_alloc_nid_failed(sbi, new_nid);\n\t\t\tgoto in_page_out;\n\t\t}\n\t\tf2fs_alloc_nid_done(sbi, new_nid);\n\t}\n\txattr_addr = page_address(xpage);\n\n\tif (inline_size)\n\t\tmemcpy(inline_addr, txattr_addr, inline_size);\n\tmemcpy(xattr_addr, txattr_addr + inline_size, VALID_XATTR_BLOCK_SIZE);\n\n\tif (inline_size)\n\t\tset_page_dirty(ipage ? ipage : in_page);\n\tset_page_dirty(xpage);\n\n\tf2fs_put_page(xpage, 1);\nin_page_out:\n\tf2fs_put_page(in_page, 1);\n\treturn err;\n}\n\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\tbool is_inline;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (!ipage)\n\t\tf2fs_down_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size, &is_inline);\n\tif (!ipage)\n\t\tf2fs_up_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\txattr_free(F2FS_I_SB(inode), base_addr, is_inline);\n\treturn error;\n}\n\nssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr, *last_base_addr;\n\tint error;\n\tsize_t rest = buffer_size;\n\n\tf2fs_down_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tf2fs_up_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst char *prefix;\n\t\tsize_t prefix_len;\n\t\tsize_t size;\n\n\t\tprefix = f2fs_xattr_prefix(entry->e_name_index, dentry);\n\n\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"list inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\tinode->i_ino);\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\tf2fs_handle_error(F2FS_I_SB(inode),\n\t\t\t\t\t\tERROR_CORRUPTED_XATTR);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!prefix)\n\t\t\tcontinue;\n\n\t\tprefix_len = strlen(prefix);\n\t\tsize = prefix_len + entry->e_name_len + 1;\n\t\tif (buffer) {\n\t\t\tif (size > rest) {\n\t\t\t\terror = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\tbuffer += entry->e_name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkfree(base_addr);\n\treturn error;\n}\n\nstatic bool f2fs_xattr_value_same(struct f2fs_xattr_entry *entry,\n\t\t\t\t\tconst void *value, size_t size)\n{\n\tvoid *pval = entry->e_name + entry->e_name_len;\n\n\treturn (le16_to_cpu(entry->e_value_size) == size) &&\n\t\t\t\t\t!memcmp(pval, value, size);\n}\n\nstatic int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\nretry:\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\t \n\there = __find_xattr(base_addr, last_base_addr, NULL, index, len, name);\n\tif (!here) {\n\t\tif (!F2FS_I(inode)->i_xattr_nid) {\n\t\t\terror = f2fs_recover_xattr_data(inode, NULL);\n\t\t\tf2fs_notice(F2FS_I_SB(inode),\n\t\t\t\t\"recover xattr in inode (%lu), error(%d)\",\n\t\t\t\t\tinode->i_ino, error);\n\t\t\tif (!error) {\n\t\t\t\tkfree(base_addr);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\tf2fs_err(F2FS_I_SB(inode), \"set inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tf2fs_handle_error(F2FS_I_SB(inode),\n\t\t\t\t\tERROR_CORRUPTED_XATTR);\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto same;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last)) {\n\t\tif ((void *)(last) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(last) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has invalid last xattr entry, entry_size: %zu\",\n\t\t\t\t\tinode->i_ino, ENTRY_SIZE(last));\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(F2FS_I_SB(inode),\n\t\t\t\t\t\tERROR_CORRUPTED_XATTR);\n\t\t\tgoto exit;\n\t\t}\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\t}\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t \n\tif (value) {\n\t\tint free;\n\t\t \n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (found) {\n\t\t \n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t \n\tif (value) {\n\t\tchar *pval;\n\t\t \n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t\t \n\t\t*(u32 *)((u8 *)last + newsize) = 0;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\n\nsame:\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\n\tinode_set_ctime_current(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\nexit:\n\tkfree(base_addr);\n\treturn error;\n}\n\nint f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_lock_op(sbi);\n\tf2fs_down_write(&F2FS_I(inode)->i_xattr_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tf2fs_up_write(&F2FS_I(inode)->i_xattr_sem);\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\treturn err;\n}\n\nint f2fs_init_xattr_caches(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tchar slab_name[32];\n\n\tsprintf(slab_name, \"f2fs_xattr_entry-%u:%u\", MAJOR(dev), MINOR(dev));\n\n\tsbi->inline_xattr_slab_size = F2FS_OPTION(sbi).inline_xattr_size *\n\t\t\t\t\tsizeof(__le32) + XATTR_PADDING_SIZE;\n\n\tsbi->inline_xattr_slab = f2fs_kmem_cache_create(slab_name,\n\t\t\t\t\tsbi->inline_xattr_slab_size);\n\tif (!sbi->inline_xattr_slab)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid f2fs_destroy_xattr_caches(struct f2fs_sb_info *sbi)\n{\n\tkmem_cache_destroy(sbi->inline_xattr_slab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}