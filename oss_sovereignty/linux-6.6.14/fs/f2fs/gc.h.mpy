{
  "module_name": "gc.h",
  "hash_id": "1ffb1e6a321ff717488bb1536a993a30ffbd80107f3e5cf90fb02069d65ed4bb",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/gc.h",
  "human_readable_source": " \n \n#define GC_THREAD_MIN_WB_PAGES\t\t1\t \n#define DEF_GC_THREAD_URGENT_SLEEP_TIME\t500\t \n#define DEF_GC_THREAD_MIN_SLEEP_TIME\t30000\t \n#define DEF_GC_THREAD_MAX_SLEEP_TIME\t60000\n#define DEF_GC_THREAD_NOGC_SLEEP_TIME\t300000\t \n\n \n#define DEF_GC_THREAD_AGE_THRESHOLD\t\t(60 * 60 * 24 * 7)\n#define DEF_GC_THREAD_CANDIDATE_RATIO\t\t20\t \n#define DEF_GC_THREAD_MAX_CANDIDATE_COUNT\t10\t \n#define DEF_GC_THREAD_AGE_WEIGHT\t\t60\t \n#define DEFAULT_ACCURACY_CLASS\t\t\t10000\t \n\n#define LIMIT_INVALID_BLOCK\t40  \n#define LIMIT_FREE_BLOCK\t40  \n\n#define DEF_GC_FAILED_PINNED_FILES\t2048\n\n \n#define DEF_MAX_VICTIM_SEARCH 4096  \n\n#define NR_GC_CHECKPOINT_SECS (3)\t \n\nstruct f2fs_gc_kthread {\n\tstruct task_struct *f2fs_gc_task;\n\twait_queue_head_t gc_wait_queue_head;\n\n\t \n\tunsigned int urgent_sleep_time;\n\tunsigned int min_sleep_time;\n\tunsigned int max_sleep_time;\n\tunsigned int no_gc_sleep_time;\n\n\t \n\tbool gc_wake;\n\n\t \n\twait_queue_head_t fggc_wq;\t\t \n};\n\nstruct gc_inode_list {\n\tstruct list_head ilist;\n\tstruct radix_tree_root iroot;\n};\n\nstruct victim_entry {\n\tstruct rb_node rb_node;\t\t \n\tunsigned long long mtime;\t \n\tunsigned int segno;\t\t \n\tstruct list_head list;\n};\n\n \n\n \nstatic inline block_t free_segs_blk_count_zoned(struct f2fs_sb_info *sbi)\n{\n\tblock_t free_seg_blks = 0;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tint j;\n\n\tspin_lock(&free_i->segmap_lock);\n\tfor (j = 0; j < MAIN_SEGS(sbi); j++)\n\t\tif (!test_bit(j, free_i->free_segmap))\n\t\t\tfree_seg_blks += f2fs_usable_blks_in_seg(sbi, j);\n\tspin_unlock(&free_i->segmap_lock);\n\n\treturn free_seg_blks;\n}\n\nstatic inline block_t free_segs_blk_count(struct f2fs_sb_info *sbi)\n{\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn free_segs_blk_count_zoned(sbi);\n\n\treturn free_segments(sbi) << sbi->log_blocks_per_seg;\n}\n\nstatic inline block_t free_user_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t free_blks, ovp_blks;\n\n\tfree_blks = free_segs_blk_count(sbi);\n\tovp_blks = overprovision_segments(sbi) << sbi->log_blocks_per_seg;\n\n\tif (free_blks < ovp_blks)\n\t\treturn 0;\n\n\treturn free_blks - ovp_blks;\n}\n\nstatic inline block_t limit_invalid_user_blocks(block_t user_block_count)\n{\n\treturn (long)(user_block_count * LIMIT_INVALID_BLOCK) / 100;\n}\n\nstatic inline block_t limit_free_user_blocks(block_t reclaimable_user_blocks)\n{\n\treturn (long)(reclaimable_user_blocks * LIMIT_FREE_BLOCK) / 100;\n}\n\nstatic inline void increase_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\tunsigned int *wait)\n{\n\tunsigned int min_time = gc_th->min_sleep_time;\n\tunsigned int max_time = gc_th->max_sleep_time;\n\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\treturn;\n\n\tif ((long long)*wait + (long long)min_time > (long long)max_time)\n\t\t*wait = max_time;\n\telse\n\t\t*wait += min_time;\n}\n\nstatic inline void decrease_sleep_time(struct f2fs_gc_kthread *gc_th,\n\t\t\t\t\t\t\tunsigned int *wait)\n{\n\tunsigned int min_time = gc_th->min_sleep_time;\n\n\tif (*wait == gc_th->no_gc_sleep_time)\n\t\t*wait = gc_th->max_sleep_time;\n\n\tif ((long long)*wait - (long long)min_time < (long long)min_time)\n\t\t*wait = min_time;\n\telse\n\t\t*wait -= min_time;\n}\n\nstatic inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)\n{\n\tblock_t user_block_count = sbi->user_block_count;\n\tblock_t invalid_user_blocks = user_block_count -\n\t\twritten_block_count(sbi);\n\t \n\treturn (invalid_user_blocks >\n\t\t\tlimit_invalid_user_blocks(user_block_count) &&\n\t\tfree_user_blocks(sbi) <\n\t\t\tlimit_free_user_blocks(invalid_user_blocks));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}