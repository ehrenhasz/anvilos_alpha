{
  "module_name": "debug.c",
  "hash_id": "81c61ea89b5d2c43e1f6c977a815468221db4c6e318eb006d50f8c604a542862",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/debug.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"gc.h\"\n\nstatic LIST_HEAD(f2fs_stat_list);\nstatic DEFINE_RAW_SPINLOCK(f2fs_stat_lock);\n#ifdef CONFIG_DEBUG_FS\nstatic struct dentry *f2fs_debugfs_root;\n#endif\n\n \nvoid f2fs_update_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned long long blks_per_sec, hblks_per_sec, total_vblocks;\n\tunsigned long long bimodal, dist;\n\tunsigned int segno, vblocks;\n\tint ndirty = 0;\n\n\tbimodal = 0;\n\ttotal_vblocks = 0;\n\tblks_per_sec = CAP_BLKS_PER_SEC(sbi);\n\thblks_per_sec = blks_per_sec / 2;\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvblocks = get_valid_blocks(sbi, segno, true);\n\t\tdist = abs(vblocks - hblks_per_sec);\n\t\tbimodal += dist * dist;\n\n\t\tif (vblocks > 0 && vblocks < blks_per_sec) {\n\t\t\ttotal_vblocks += vblocks;\n\t\t\tndirty++;\n\t\t}\n\t}\n\tdist = div_u64(MAIN_SECS(sbi) * hblks_per_sec * hblks_per_sec, 100);\n\tsi->bimodal = div64_u64(bimodal, dist);\n\tif (si->dirty_count)\n\t\tsi->avg_vblocks = div_u64(total_vblocks, ndirty);\n\telse\n\t\tsi->avg_vblocks = 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void update_general_status(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tint i;\n\n\t \n\tsi->main_area_segs = le32_to_cpu(raw_super->segment_count_main);\n\tsi->main_area_sections = le32_to_cpu(raw_super->section_count);\n\tsi->main_area_zones = si->main_area_sections /\n\t\t\t\tle32_to_cpu(raw_super->secs_per_zone);\n\n\t \n\tfor (i = 0; i < NR_EXTENT_CACHES; i++) {\n\t\tstruct extent_tree_info *eti = &sbi->extent_tree[i];\n\n\t\tsi->hit_cached[i] = atomic64_read(&sbi->read_hit_cached[i]);\n\t\tsi->hit_rbtree[i] = atomic64_read(&sbi->read_hit_rbtree[i]);\n\t\tsi->total_ext[i] = atomic64_read(&sbi->total_hit_ext[i]);\n\t\tsi->hit_total[i] = si->hit_cached[i] + si->hit_rbtree[i];\n\t\tsi->ext_tree[i] = atomic_read(&eti->total_ext_tree);\n\t\tsi->zombie_tree[i] = atomic_read(&eti->total_zombie_tree);\n\t\tsi->ext_node[i] = atomic_read(&eti->total_ext_node);\n\t}\n\t \n\tsi->hit_largest = atomic64_read(&sbi->read_hit_largest);\n\tsi->hit_total[EX_READ] += si->hit_largest;\n\n\t \n\tsi->allocated_data_blocks = atomic64_read(&sbi->allocated_data_blocks);\n\n\t \n\tsi->ndirty_node = get_pages(sbi, F2FS_DIRTY_NODES);\n\tsi->ndirty_dent = get_pages(sbi, F2FS_DIRTY_DENTS);\n\tsi->ndirty_meta = get_pages(sbi, F2FS_DIRTY_META);\n\tsi->ndirty_data = get_pages(sbi, F2FS_DIRTY_DATA);\n\tsi->ndirty_qdata = get_pages(sbi, F2FS_DIRTY_QDATA);\n\tsi->ndirty_imeta = get_pages(sbi, F2FS_DIRTY_IMETA);\n\tsi->ndirty_dirs = sbi->ndirty_inode[DIR_INODE];\n\tsi->ndirty_files = sbi->ndirty_inode[FILE_INODE];\n\tsi->nquota_files = sbi->nquota_files;\n\tsi->ndirty_all = sbi->ndirty_inode[DIRTY_META];\n\tsi->aw_cnt = atomic_read(&sbi->atomic_files);\n\tsi->max_aw_cnt = atomic_read(&sbi->max_aw_cnt);\n\tsi->nr_dio_read = get_pages(sbi, F2FS_DIO_READ);\n\tsi->nr_dio_write = get_pages(sbi, F2FS_DIO_WRITE);\n\tsi->nr_wb_cp_data = get_pages(sbi, F2FS_WB_CP_DATA);\n\tsi->nr_wb_data = get_pages(sbi, F2FS_WB_DATA);\n\tsi->nr_rd_data = get_pages(sbi, F2FS_RD_DATA);\n\tsi->nr_rd_node = get_pages(sbi, F2FS_RD_NODE);\n\tsi->nr_rd_meta = get_pages(sbi, F2FS_RD_META);\n\tif (SM_I(sbi)->fcc_info) {\n\t\tsi->nr_flushed =\n\t\t\tatomic_read(&SM_I(sbi)->fcc_info->issued_flush);\n\t\tsi->nr_flushing =\n\t\t\tatomic_read(&SM_I(sbi)->fcc_info->queued_flush);\n\t\tsi->flush_list_empty =\n\t\t\tllist_empty(&SM_I(sbi)->fcc_info->issue_list);\n\t}\n\tif (SM_I(sbi)->dcc_info) {\n\t\tsi->nr_discarded =\n\t\t\tatomic_read(&SM_I(sbi)->dcc_info->issued_discard);\n\t\tsi->nr_discarding =\n\t\t\tatomic_read(&SM_I(sbi)->dcc_info->queued_discard);\n\t\tsi->nr_discard_cmd =\n\t\t\tatomic_read(&SM_I(sbi)->dcc_info->discard_cmd_cnt);\n\t\tsi->undiscard_blks = SM_I(sbi)->dcc_info->undiscard_blks;\n\t}\n\tsi->nr_issued_ckpt = atomic_read(&sbi->cprc_info.issued_ckpt);\n\tsi->nr_total_ckpt = atomic_read(&sbi->cprc_info.total_ckpt);\n\tsi->nr_queued_ckpt = atomic_read(&sbi->cprc_info.queued_ckpt);\n\tspin_lock(&sbi->cprc_info.stat_lock);\n\tsi->cur_ckpt_time = sbi->cprc_info.cur_time;\n\tsi->peak_ckpt_time = sbi->cprc_info.peak_time;\n\tspin_unlock(&sbi->cprc_info.stat_lock);\n\tsi->total_count = (int)sbi->user_block_count / sbi->blocks_per_seg;\n\tsi->rsvd_segs = reserved_segments(sbi);\n\tsi->overp_segs = overprovision_segments(sbi);\n\tsi->valid_count = valid_user_blocks(sbi);\n\tsi->discard_blks = discard_blocks(sbi);\n\tsi->valid_node_count = valid_node_count(sbi);\n\tsi->valid_inode_count = valid_inode_count(sbi);\n\tsi->inline_xattr = atomic_read(&sbi->inline_xattr);\n\tsi->inline_inode = atomic_read(&sbi->inline_inode);\n\tsi->inline_dir = atomic_read(&sbi->inline_dir);\n\tsi->compr_inode = atomic_read(&sbi->compr_inode);\n\tsi->swapfile_inode = atomic_read(&sbi->swapfile_inode);\n\tsi->compr_blocks = atomic64_read(&sbi->compr_blocks);\n\tsi->append = sbi->im[APPEND_INO].ino_num;\n\tsi->update = sbi->im[UPDATE_INO].ino_num;\n\tsi->orphans = sbi->im[ORPHAN_INO].ino_num;\n\tsi->utilization = utilization(sbi);\n\n\tsi->free_segs = free_segments(sbi);\n\tsi->free_secs = free_sections(sbi);\n\tsi->prefree_count = prefree_segments(sbi);\n\tsi->dirty_count = dirty_segments(sbi);\n\tif (sbi->node_inode)\n\t\tsi->node_pages = NODE_MAPPING(sbi)->nrpages;\n\tif (sbi->meta_inode)\n\t\tsi->meta_pages = META_MAPPING(sbi)->nrpages;\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (sbi->compress_inode) {\n\t\tsi->compress_pages = COMPRESS_MAPPING(sbi)->nrpages;\n\t\tsi->compress_page_hit = atomic_read(&sbi->compress_page_hit);\n\t}\n#endif\n\tsi->nats = NM_I(sbi)->nat_cnt[TOTAL_NAT];\n\tsi->dirty_nats = NM_I(sbi)->nat_cnt[DIRTY_NAT];\n\tsi->sits = MAIN_SEGS(sbi);\n\tsi->dirty_sits = SIT_I(sbi)->dirty_sentries;\n\tsi->free_nids = NM_I(sbi)->nid_cnt[FREE_NID];\n\tsi->avail_nids = NM_I(sbi)->available_nids;\n\tsi->alloc_nids = NM_I(sbi)->nid_cnt[PREALLOC_NID];\n\tsi->io_skip_bggc = sbi->io_skip_bggc;\n\tsi->other_skip_bggc = sbi->other_skip_bggc;\n\tsi->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_valid = (int)(written_block_count(sbi) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg)\n\t\t* 100 / (int)(sbi->user_block_count >> sbi->log_blocks_per_seg)\n\t\t/ 2;\n\tsi->util_invalid = 50 - si->util_free - si->util_valid;\n\tfor (i = CURSEG_HOT_DATA; i < NO_CHECK_TYPE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\n\t\tsi->curseg[i] = curseg->segno;\n\t\tsi->cursec[i] = GET_SEC_FROM_SEG(sbi, curseg->segno);\n\t\tsi->curzone[i] = GET_ZONE_FROM_SEC(sbi, si->cursec[i]);\n\t}\n\n\tfor (i = META_CP; i < META_MAX; i++)\n\t\tsi->meta_count[i] = atomic_read(&sbi->meta_count[i]);\n\n\tfor (i = 0; i < NO_CHECK_TYPE; i++) {\n\t\tsi->dirty_seg[i] = 0;\n\t\tsi->full_seg[i] = 0;\n\t\tsi->valid_blks[i] = 0;\n\t}\n\n\tfor (i = 0; i < MAIN_SEGS(sbi); i++) {\n\t\tint blks = get_seg_entry(sbi, i)->valid_blocks;\n\t\tint type = get_seg_entry(sbi, i)->type;\n\n\t\tif (!blks)\n\t\t\tcontinue;\n\n\t\tif (blks == sbi->blocks_per_seg)\n\t\t\tsi->full_seg[type]++;\n\t\telse\n\t\t\tsi->dirty_seg[type]++;\n\t\tsi->valid_blks[type] += blks;\n\t}\n\n\tfor (i = 0; i < MAX_CALL_TYPE; i++)\n\t\tsi->cp_call_count[i] = atomic_read(&sbi->cp_call_count[i]);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsi->segment_count[i] = sbi->segment_count[i];\n\t\tsi->block_count[i] = sbi->block_count[i];\n\t}\n\n\tsi->inplace_count = atomic_read(&sbi->inplace_count);\n}\n\n \nstatic void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\t \n\tsi->base_mem = sizeof(struct f2fs_stat_info);\n\n\t \n\tsi->base_mem += sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t \n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t \n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (__is_large_section(sbi))\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t \n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t \n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_SIZE * NR_CURSEG_TYPE;\n\n\t \n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t \n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\tsi->base_mem += (NM_I(sbi)->nat_bits_blocks << F2FS_BLKSIZE_BITS);\n\tsi->base_mem += NM_I(sbi)->nat_blocks *\n\t\t\t\tf2fs_bitmap_size(NAT_ENTRY_PER_BLOCK);\n\tsi->base_mem += NM_I(sbi)->nat_blocks / 8;\n\tsi->base_mem += NM_I(sbi)->nat_blocks * sizeof(unsigned short);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t \n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t \n\tif (SM_I(sbi)->fcc_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\tif (SM_I(sbi)->dcc_info) {\n\t\tsi->cache_mem += sizeof(struct discard_cmd_control);\n\t\tsi->cache_mem += sizeof(struct discard_cmd) *\n\t\t\tatomic_read(&SM_I(sbi)->dcc_info->discard_cmd_cnt);\n\t}\n\n\t \n\tsi->cache_mem += (NM_I(sbi)->nid_cnt[FREE_NID] +\n\t\t\t\tNM_I(sbi)->nid_cnt[PREALLOC_NID]) *\n\t\t\t\tsizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt[TOTAL_NAT] *\n\t\t\t\tsizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt[DIRTY_NAT] *\n\t\t\t\tsizeof(struct nat_entry_set);\n\tfor (i = 0; i < MAX_INO_ENTRY; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tfor (i = 0; i < NR_EXTENT_CACHES; i++) {\n\t\tstruct extent_tree_info *eti = &sbi->extent_tree[i];\n\n\t\tsi->ext_mem[i] = atomic_read(&eti->total_ext_tree) *\n\t\t\t\t\t\tsizeof(struct extent_tree);\n\t\tsi->ext_mem[i] += atomic_read(&eti->total_ext_node) *\n\t\t\t\t\t\tsizeof(struct extent_node);\n\t\tsi->cache_mem += si->ext_mem[i];\n\t}\n\n\tsi->page_mem = 0;\n\tif (sbi->node_inode) {\n\t\tunsigned long npages = NODE_MAPPING(sbi)->nrpages;\n\n\t\tsi->page_mem += (unsigned long long)npages << PAGE_SHIFT;\n\t}\n\tif (sbi->meta_inode) {\n\t\tunsigned long npages = META_MAPPING(sbi)->nrpages;\n\n\t\tsi->page_mem += (unsigned long long)npages << PAGE_SHIFT;\n\t}\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (sbi->compress_inode) {\n\t\tunsigned long npages = COMPRESS_MAPPING(sbi)->nrpages;\n\n\t\tsi->page_mem += (unsigned long long)npages << PAGE_SHIFT;\n\t}\n#endif\n}\n\nstatic const char *s_flag[MAX_SBI_FLAG] = {\n\t[SBI_IS_DIRTY]\t\t= \"fs_dirty\",\n\t[SBI_IS_CLOSE]\t\t= \"closing\",\n\t[SBI_NEED_FSCK]\t\t= \"need_fsck\",\n\t[SBI_POR_DOING]\t\t= \"recovering\",\n\t[SBI_NEED_SB_WRITE]\t= \"sb_dirty\",\n\t[SBI_NEED_CP]\t\t= \"need_cp\",\n\t[SBI_IS_SHUTDOWN]\t= \"shutdown\",\n\t[SBI_IS_RECOVERED]\t= \"recovered\",\n\t[SBI_CP_DISABLED]\t= \"cp_disabled\",\n\t[SBI_CP_DISABLED_QUICK]\t= \"cp_disabled_quick\",\n\t[SBI_QUOTA_NEED_FLUSH]\t= \"quota_need_flush\",\n\t[SBI_QUOTA_SKIP_FLUSH]\t= \"quota_skip_flush\",\n\t[SBI_QUOTA_NEED_REPAIR]\t= \"quota_need_repair\",\n\t[SBI_IS_RESIZEFS]\t= \"resizefs\",\n\t[SBI_IS_FREEZING]\t= \"freezefs\",\n\t[SBI_IS_WRITABLE]\t= \"writable\",\n};\n\nstatic const char *ipu_mode_names[F2FS_IPU_MAX] = {\n\t[F2FS_IPU_FORCE]\t= \"FORCE\",\n\t[F2FS_IPU_SSR]\t\t= \"SSR\",\n\t[F2FS_IPU_UTIL]\t\t= \"UTIL\",\n\t[F2FS_IPU_SSR_UTIL]\t= \"SSR_UTIL\",\n\t[F2FS_IPU_FSYNC]\t= \"FSYNC\",\n\t[F2FS_IPU_ASYNC]\t= \"ASYNC\",\n\t[F2FS_IPU_NOCACHE]\t= \"NOCACHE\",\n\t[F2FS_IPU_HONOR_OPU_WRITE]\t= \"HONOR_OPU_WRITE\",\n};\n\nstatic int stat_show(struct seq_file *s, void *v)\n{\n\tstruct f2fs_stat_info *si;\n\tint i = 0, j = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&f2fs_stat_lock, flags);\n\tlist_for_each_entry(si, &f2fs_stat_list, stat_list) {\n\t\tstruct f2fs_sb_info *sbi = si->sbi;\n\n\t\tupdate_general_status(sbi);\n\n\t\tseq_printf(s, \"\\n=====[ partition info(%pg). #%d, %s, CP: %s]=====\\n\",\n\t\t\tsbi->sb->s_bdev, i++,\n\t\t\tf2fs_readonly(sbi->sb) ? \"RO\" : \"RW\",\n\t\t\tis_set_ckpt_flags(sbi, CP_DISABLED_FLAG) ?\n\t\t\t\"Disabled\" : (f2fs_cp_error(sbi) ? \"Error\" : \"Good\"));\n\t\tif (sbi->s_flag) {\n\t\t\tseq_puts(s, \"[SBI:\");\n\t\t\tfor_each_set_bit(j, &sbi->s_flag, MAX_SBI_FLAG)\n\t\t\t\tseq_printf(s, \" %s\", s_flag[j]);\n\t\t\tseq_puts(s, \"]\\n\");\n\t\t}\n\t\tseq_printf(s, \"[SB: 1] [CP: 2] [SIT: %d] [NAT: %d] \",\n\t\t\t   si->sit_area_segs, si->nat_area_segs);\n\t\tseq_printf(s, \"[SSA: %d] [MAIN: %d\",\n\t\t\t   si->ssa_area_segs, si->main_area_segs);\n\t\tseq_printf(s, \"(OverProv:%d Resv:%d)]\\n\\n\",\n\t\t\t   si->overp_segs, si->rsvd_segs);\n\t\tseq_printf(s, \"Current Time Sec: %llu / Mounted Time Sec: %llu\\n\\n\",\n\t\t\t\t\tktime_get_boottime_seconds(),\n\t\t\t\t\tSIT_I(sbi)->mounted_time);\n\n\t\tseq_puts(s, \"Policy:\\n\");\n\t\tseq_puts(s, \"  - IPU: [\");\n\t\tif (IS_F2FS_IPU_DISABLE(sbi)) {\n\t\t\tseq_puts(s, \" DISABLE\");\n\t\t} else {\n\t\t\tunsigned long policy = SM_I(sbi)->ipu_policy;\n\n\t\t\tfor_each_set_bit(j, &policy, F2FS_IPU_MAX)\n\t\t\t\tseq_printf(s, \" %s\", ipu_mode_names[j]);\n\t\t}\n\t\tseq_puts(s, \" ]\\n\\n\");\n\n\t\tif (test_opt(sbi, DISCARD))\n\t\t\tseq_printf(s, \"Utilization: %u%% (%u valid blocks, %u discard blocks)\\n\",\n\t\t\t\tsi->utilization, si->valid_count, si->discard_blks);\n\t\telse\n\t\t\tseq_printf(s, \"Utilization: %u%% (%u valid blocks)\\n\",\n\t\t\t\tsi->utilization, si->valid_count);\n\n\t\tseq_printf(s, \"  - Node: %u (Inode: %u, \",\n\t\t\t   si->valid_node_count, si->valid_inode_count);\n\t\tseq_printf(s, \"Other: %u)\\n  - Data: %u\\n\",\n\t\t\t   si->valid_node_count - si->valid_inode_count,\n\t\t\t   si->valid_count - si->valid_node_count);\n\t\tseq_printf(s, \"  - Inline_xattr Inode: %u\\n\",\n\t\t\t   si->inline_xattr);\n\t\tseq_printf(s, \"  - Inline_data Inode: %u\\n\",\n\t\t\t   si->inline_inode);\n\t\tseq_printf(s, \"  - Inline_dentry Inode: %u\\n\",\n\t\t\t   si->inline_dir);\n\t\tseq_printf(s, \"  - Compressed Inode: %u, Blocks: %llu\\n\",\n\t\t\t   si->compr_inode, si->compr_blocks);\n\t\tseq_printf(s, \"  - Swapfile Inode: %u\\n\",\n\t\t\t   si->swapfile_inode);\n\t\tseq_printf(s, \"  - Orphan/Append/Update Inode: %u, %u, %u\\n\",\n\t\t\t   si->orphans, si->append, si->update);\n\t\tseq_printf(s, \"\\nMain area: %d segs, %d secs %d zones\\n\",\n\t\t\t   si->main_area_segs, si->main_area_sections,\n\t\t\t   si->main_area_zones);\n\t\tseq_printf(s, \"    TYPE         %8s %8s %8s %10s %10s %10s\\n\",\n\t\t\t   \"segno\", \"secno\", \"zoneno\", \"dirty_seg\", \"full_seg\", \"valid_blk\");\n\t\tseq_printf(s, \"  - COLD   data: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_DATA],\n\t\t\t   si->cursec[CURSEG_COLD_DATA],\n\t\t\t   si->curzone[CURSEG_COLD_DATA],\n\t\t\t   si->dirty_seg[CURSEG_COLD_DATA],\n\t\t\t   si->full_seg[CURSEG_COLD_DATA],\n\t\t\t   si->valid_blks[CURSEG_COLD_DATA]);\n\t\tseq_printf(s, \"  - WARM   data: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_DATA],\n\t\t\t   si->cursec[CURSEG_WARM_DATA],\n\t\t\t   si->curzone[CURSEG_WARM_DATA],\n\t\t\t   si->dirty_seg[CURSEG_WARM_DATA],\n\t\t\t   si->full_seg[CURSEG_WARM_DATA],\n\t\t\t   si->valid_blks[CURSEG_WARM_DATA]);\n\t\tseq_printf(s, \"  - HOT    data: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_DATA],\n\t\t\t   si->cursec[CURSEG_HOT_DATA],\n\t\t\t   si->curzone[CURSEG_HOT_DATA],\n\t\t\t   si->dirty_seg[CURSEG_HOT_DATA],\n\t\t\t   si->full_seg[CURSEG_HOT_DATA],\n\t\t\t   si->valid_blks[CURSEG_HOT_DATA]);\n\t\tseq_printf(s, \"  - Dir   dnode: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_HOT_NODE],\n\t\t\t   si->cursec[CURSEG_HOT_NODE],\n\t\t\t   si->curzone[CURSEG_HOT_NODE],\n\t\t\t   si->dirty_seg[CURSEG_HOT_NODE],\n\t\t\t   si->full_seg[CURSEG_HOT_NODE],\n\t\t\t   si->valid_blks[CURSEG_HOT_NODE]);\n\t\tseq_printf(s, \"  - File  dnode: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_WARM_NODE],\n\t\t\t   si->cursec[CURSEG_WARM_NODE],\n\t\t\t   si->curzone[CURSEG_WARM_NODE],\n\t\t\t   si->dirty_seg[CURSEG_WARM_NODE],\n\t\t\t   si->full_seg[CURSEG_WARM_NODE],\n\t\t\t   si->valid_blks[CURSEG_WARM_NODE]);\n\t\tseq_printf(s, \"  - Indir nodes: %8d %8d %8d %10u %10u %10u\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_NODE],\n\t\t\t   si->cursec[CURSEG_COLD_NODE],\n\t\t\t   si->curzone[CURSEG_COLD_NODE],\n\t\t\t   si->dirty_seg[CURSEG_COLD_NODE],\n\t\t\t   si->full_seg[CURSEG_COLD_NODE],\n\t\t\t   si->valid_blks[CURSEG_COLD_NODE]);\n\t\tseq_printf(s, \"  - Pinned file: %8d %8d %8d\\n\",\n\t\t\t   si->curseg[CURSEG_COLD_DATA_PINNED],\n\t\t\t   si->cursec[CURSEG_COLD_DATA_PINNED],\n\t\t\t   si->curzone[CURSEG_COLD_DATA_PINNED]);\n\t\tseq_printf(s, \"  - ATGC   data: %8d %8d %8d\\n\",\n\t\t\t   si->curseg[CURSEG_ALL_DATA_ATGC],\n\t\t\t   si->cursec[CURSEG_ALL_DATA_ATGC],\n\t\t\t   si->curzone[CURSEG_ALL_DATA_ATGC]);\n\t\tseq_printf(s, \"\\n  - Valid: %d\\n  - Dirty: %d\\n\",\n\t\t\t   si->main_area_segs - si->dirty_count -\n\t\t\t   si->prefree_count - si->free_segs,\n\t\t\t   si->dirty_count);\n\t\tseq_printf(s, \"  - Prefree: %d\\n  - Free: %d (%d)\\n\\n\",\n\t\t\t   si->prefree_count, si->free_segs, si->free_secs);\n\t\tseq_printf(s, \"CP calls: %d (BG: %d)\\n\",\n\t\t\t   si->cp_call_count[TOTAL_CALL],\n\t\t\t   si->cp_call_count[BACKGROUND]);\n\t\tseq_printf(s, \"CP count: %d\\n\", si->cp_count);\n\t\tseq_printf(s, \"  - cp blocks : %u\\n\", si->meta_count[META_CP]);\n\t\tseq_printf(s, \"  - sit blocks : %u\\n\",\n\t\t\t\tsi->meta_count[META_SIT]);\n\t\tseq_printf(s, \"  - nat blocks : %u\\n\",\n\t\t\t\tsi->meta_count[META_NAT]);\n\t\tseq_printf(s, \"  - ssa blocks : %u\\n\",\n\t\t\t\tsi->meta_count[META_SSA]);\n\t\tseq_puts(s, \"CP merge:\\n\");\n\t\tseq_printf(s, \"  - Queued : %4d\\n\", si->nr_queued_ckpt);\n\t\tseq_printf(s, \"  - Issued : %4d\\n\", si->nr_issued_ckpt);\n\t\tseq_printf(s, \"  - Total : %4d\\n\", si->nr_total_ckpt);\n\t\tseq_printf(s, \"  - Cur time : %4d(ms)\\n\", si->cur_ckpt_time);\n\t\tseq_printf(s, \"  - Peak time : %4d(ms)\\n\", si->peak_ckpt_time);\n\t\tseq_printf(s, \"GC calls: %d (gc_thread: %d)\\n\",\n\t\t\t   si->gc_call_count[BACKGROUND] +\n\t\t\t   si->gc_call_count[FOREGROUND],\n\t\t\t   si->gc_call_count[BACKGROUND]);\n\t\tif (__is_large_section(sbi)) {\n\t\t\tseq_printf(s, \"  - data sections : %d (BG: %d)\\n\",\n\t\t\t\t\tsi->gc_secs[DATA][BG_GC] + si->gc_secs[DATA][FG_GC],\n\t\t\t\t\tsi->gc_secs[DATA][BG_GC]);\n\t\t\tseq_printf(s, \"  - node sections : %d (BG: %d)\\n\",\n\t\t\t\t\tsi->gc_secs[NODE][BG_GC] + si->gc_secs[NODE][FG_GC],\n\t\t\t\t\tsi->gc_secs[NODE][BG_GC]);\n\t\t}\n\t\tseq_printf(s, \"  - data segments : %d (BG: %d)\\n\",\n\t\t\t\tsi->gc_segs[DATA][BG_GC] + si->gc_segs[DATA][FG_GC],\n\t\t\t\tsi->gc_segs[DATA][BG_GC]);\n\t\tseq_printf(s, \"  - node segments : %d (BG: %d)\\n\",\n\t\t\t\tsi->gc_segs[NODE][BG_GC] + si->gc_segs[NODE][FG_GC],\n\t\t\t\tsi->gc_segs[NODE][BG_GC]);\n\t\tseq_puts(s, \"  - Reclaimed segs :\\n\");\n\t\tseq_printf(s, \"    - Normal : %d\\n\", sbi->gc_reclaimed_segs[GC_NORMAL]);\n\t\tseq_printf(s, \"    - Idle CB : %d\\n\", sbi->gc_reclaimed_segs[GC_IDLE_CB]);\n\t\tseq_printf(s, \"    - Idle Greedy : %d\\n\",\n\t\t\t\tsbi->gc_reclaimed_segs[GC_IDLE_GREEDY]);\n\t\tseq_printf(s, \"    - Idle AT : %d\\n\", sbi->gc_reclaimed_segs[GC_IDLE_AT]);\n\t\tseq_printf(s, \"    - Urgent High : %d\\n\",\n\t\t\t\tsbi->gc_reclaimed_segs[GC_URGENT_HIGH]);\n\t\tseq_printf(s, \"    - Urgent Mid : %d\\n\", sbi->gc_reclaimed_segs[GC_URGENT_MID]);\n\t\tseq_printf(s, \"    - Urgent Low : %d\\n\", sbi->gc_reclaimed_segs[GC_URGENT_LOW]);\n\t\tseq_printf(s, \"Try to move %d blocks (BG: %d)\\n\", si->tot_blks,\n\t\t\t\tsi->bg_data_blks + si->bg_node_blks);\n\t\tseq_printf(s, \"  - data blocks : %d (%d)\\n\", si->data_blks,\n\t\t\t\tsi->bg_data_blks);\n\t\tseq_printf(s, \"  - node blocks : %d (%d)\\n\", si->node_blks,\n\t\t\t\tsi->bg_node_blks);\n\t\tseq_printf(s, \"BG skip : IO: %u, Other: %u\\n\",\n\t\t\t\tsi->io_skip_bggc, si->other_skip_bggc);\n\t\tseq_puts(s, \"\\nExtent Cache (Read):\\n\");\n\t\tseq_printf(s, \"  - Hit Count: L1-1:%llu L1-2:%llu L2:%llu\\n\",\n\t\t\t\tsi->hit_largest, si->hit_cached[EX_READ],\n\t\t\t\tsi->hit_rbtree[EX_READ]);\n\t\tseq_printf(s, \"  - Hit Ratio: %llu%% (%llu / %llu)\\n\",\n\t\t\t\t!si->total_ext[EX_READ] ? 0 :\n\t\t\t\tdiv64_u64(si->hit_total[EX_READ] * 100,\n\t\t\t\tsi->total_ext[EX_READ]),\n\t\t\t\tsi->hit_total[EX_READ], si->total_ext[EX_READ]);\n\t\tseq_printf(s, \"  - Inner Struct Count: tree: %d(%d), node: %d\\n\",\n\t\t\t\tsi->ext_tree[EX_READ], si->zombie_tree[EX_READ],\n\t\t\t\tsi->ext_node[EX_READ]);\n\t\tseq_puts(s, \"\\nExtent Cache (Block Age):\\n\");\n\t\tseq_printf(s, \"  - Allocated Data Blocks: %llu\\n\",\n\t\t\t\tsi->allocated_data_blocks);\n\t\tseq_printf(s, \"  - Hit Count: L1:%llu L2:%llu\\n\",\n\t\t\t\tsi->hit_cached[EX_BLOCK_AGE],\n\t\t\t\tsi->hit_rbtree[EX_BLOCK_AGE]);\n\t\tseq_printf(s, \"  - Hit Ratio: %llu%% (%llu / %llu)\\n\",\n\t\t\t\t!si->total_ext[EX_BLOCK_AGE] ? 0 :\n\t\t\t\tdiv64_u64(si->hit_total[EX_BLOCK_AGE] * 100,\n\t\t\t\tsi->total_ext[EX_BLOCK_AGE]),\n\t\t\t\tsi->hit_total[EX_BLOCK_AGE],\n\t\t\t\tsi->total_ext[EX_BLOCK_AGE]);\n\t\tseq_printf(s, \"  - Inner Struct Count: tree: %d(%d), node: %d\\n\",\n\t\t\t\tsi->ext_tree[EX_BLOCK_AGE],\n\t\t\t\tsi->zombie_tree[EX_BLOCK_AGE],\n\t\t\t\tsi->ext_node[EX_BLOCK_AGE]);\n\t\tseq_puts(s, \"\\nBalancing F2FS Async:\\n\");\n\t\tseq_printf(s, \"  - DIO (R: %4d, W: %4d)\\n\",\n\t\t\t   si->nr_dio_read, si->nr_dio_write);\n\t\tseq_printf(s, \"  - IO_R (Data: %4d, Node: %4d, Meta: %4d\\n\",\n\t\t\t   si->nr_rd_data, si->nr_rd_node, si->nr_rd_meta);\n\t\tseq_printf(s, \"  - IO_W (CP: %4d, Data: %4d, Flush: (%4d %4d %4d), \",\n\t\t\t   si->nr_wb_cp_data, si->nr_wb_data,\n\t\t\t   si->nr_flushing, si->nr_flushed,\n\t\t\t   si->flush_list_empty);\n\t\tseq_printf(s, \"Discard: (%4d %4d)) cmd: %4d undiscard:%4u\\n\",\n\t\t\t   si->nr_discarding, si->nr_discarded,\n\t\t\t   si->nr_discard_cmd, si->undiscard_blks);\n\t\tseq_printf(s, \"  - atomic IO: %4d (Max. %4d)\\n\",\n\t\t\t   si->aw_cnt, si->max_aw_cnt);\n\t\tseq_printf(s, \"  - compress: %4d, hit:%8d\\n\", si->compress_pages, si->compress_page_hit);\n\t\tseq_printf(s, \"  - nodes: %4d in %4d\\n\",\n\t\t\t   si->ndirty_node, si->node_pages);\n\t\tseq_printf(s, \"  - dents: %4d in dirs:%4d (%4d)\\n\",\n\t\t\t   si->ndirty_dent, si->ndirty_dirs, si->ndirty_all);\n\t\tseq_printf(s, \"  - datas: %4d in files:%4d\\n\",\n\t\t\t   si->ndirty_data, si->ndirty_files);\n\t\tseq_printf(s, \"  - quota datas: %4d in quota files:%4d\\n\",\n\t\t\t   si->ndirty_qdata, si->nquota_files);\n\t\tseq_printf(s, \"  - meta: %4d in %4d\\n\",\n\t\t\t   si->ndirty_meta, si->meta_pages);\n\t\tseq_printf(s, \"  - imeta: %4d\\n\",\n\t\t\t   si->ndirty_imeta);\n\t\tseq_printf(s, \"  - fsync mark: %4lld\\n\",\n\t\t\t   percpu_counter_sum_positive(\n\t\t\t\t\t&sbi->rf_node_block_count));\n\t\tseq_printf(s, \"  - NATs: %9d/%9d\\n  - SITs: %9d/%9d\\n\",\n\t\t\t   si->dirty_nats, si->nats, si->dirty_sits, si->sits);\n\t\tseq_printf(s, \"  - free_nids: %9d/%9d\\n  - alloc_nids: %9d\\n\",\n\t\t\t   si->free_nids, si->avail_nids, si->alloc_nids);\n\t\tseq_puts(s, \"\\nDistribution of User Blocks:\");\n\t\tseq_puts(s, \" [ valid | invalid | free ]\\n\");\n\t\tseq_puts(s, \"  [\");\n\n\t\tfor (j = 0; j < si->util_valid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_invalid; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_putc(s, '|');\n\n\t\tfor (j = 0; j < si->util_free; j++)\n\t\t\tseq_putc(s, '-');\n\t\tseq_puts(s, \"]\\n\\n\");\n\t\tseq_printf(s, \"IPU: %u blocks\\n\", si->inplace_count);\n\t\tseq_printf(s, \"SSR: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[SSR], si->segment_count[SSR]);\n\t\tseq_printf(s, \"LFS: %u blocks in %u segments\\n\",\n\t\t\t   si->block_count[LFS], si->segment_count[LFS]);\n\n\t\t \n\t\tf2fs_update_sit_info(sbi);\n\t\tseq_printf(s, \"\\nBDF: %u, avg. vblocks: %u\\n\",\n\t\t\t   si->bimodal, si->avg_vblocks);\n\n\t\t \n\t\tupdate_mem_info(sbi);\n\t\tseq_printf(s, \"\\nMemory: %llu KB\\n\",\n\t\t\t(si->base_mem + si->cache_mem + si->page_mem) >> 10);\n\t\tseq_printf(s, \"  - static: %llu KB\\n\",\n\t\t\t\tsi->base_mem >> 10);\n\t\tseq_printf(s, \"  - cached all: %llu KB\\n\",\n\t\t\t\tsi->cache_mem >> 10);\n\t\tseq_printf(s, \"  - read extent cache: %llu KB\\n\",\n\t\t\t\tsi->ext_mem[EX_READ] >> 10);\n\t\tseq_printf(s, \"  - block age extent cache: %llu KB\\n\",\n\t\t\t\tsi->ext_mem[EX_BLOCK_AGE] >> 10);\n\t\tseq_printf(s, \"  - paged : %llu KB\\n\",\n\t\t\t\tsi->page_mem >> 10);\n\t}\n\traw_spin_unlock_irqrestore(&f2fs_stat_lock, flags);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(stat);\n#endif\n\nint f2fs_build_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_stat_info *si;\n\tunsigned long flags;\n\tint i;\n\n\tsi = f2fs_kzalloc(sbi, sizeof(struct f2fs_stat_info), GFP_KERNEL);\n\tif (!si)\n\t\treturn -ENOMEM;\n\n\tsi->all_area_segs = le32_to_cpu(raw_super->segment_count);\n\tsi->sit_area_segs = le32_to_cpu(raw_super->segment_count_sit);\n\tsi->nat_area_segs = le32_to_cpu(raw_super->segment_count_nat);\n\tsi->ssa_area_segs = le32_to_cpu(raw_super->segment_count_ssa);\n\tsi->main_area_segs = le32_to_cpu(raw_super->segment_count_main);\n\tsi->main_area_sections = le32_to_cpu(raw_super->section_count);\n\tsi->main_area_zones = si->main_area_sections /\n\t\t\t\tle32_to_cpu(raw_super->secs_per_zone);\n\tsi->sbi = sbi;\n\tsbi->stat_info = si;\n\n\t \n\tfor (i = 0; i < NR_EXTENT_CACHES; i++) {\n\t\tatomic64_set(&sbi->total_hit_ext[i], 0);\n\t\tatomic64_set(&sbi->read_hit_rbtree[i], 0);\n\t\tatomic64_set(&sbi->read_hit_cached[i], 0);\n\t}\n\n\t \n\tatomic64_set(&sbi->read_hit_largest, 0);\n\n\tatomic_set(&sbi->inline_xattr, 0);\n\tatomic_set(&sbi->inline_inode, 0);\n\tatomic_set(&sbi->inline_dir, 0);\n\tatomic_set(&sbi->compr_inode, 0);\n\tatomic64_set(&sbi->compr_blocks, 0);\n\tatomic_set(&sbi->swapfile_inode, 0);\n\tatomic_set(&sbi->atomic_files, 0);\n\tatomic_set(&sbi->inplace_count, 0);\n\tfor (i = META_CP; i < META_MAX; i++)\n\t\tatomic_set(&sbi->meta_count[i], 0);\n\tfor (i = 0; i < MAX_CALL_TYPE; i++)\n\t\tatomic_set(&sbi->cp_call_count[i], 0);\n\n\tatomic_set(&sbi->max_aw_cnt, 0);\n\n\traw_spin_lock_irqsave(&f2fs_stat_lock, flags);\n\tlist_add_tail(&si->stat_list, &f2fs_stat_list);\n\traw_spin_unlock_irqrestore(&f2fs_stat_lock, flags);\n\n\treturn 0;\n}\n\nvoid f2fs_destroy_stats(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&f2fs_stat_lock, flags);\n\tlist_del(&si->stat_list);\n\traw_spin_unlock_irqrestore(&f2fs_stat_lock, flags);\n\n\tkfree(si);\n}\n\nvoid __init f2fs_create_root_stats(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tf2fs_debugfs_root = debugfs_create_dir(\"f2fs\", NULL);\n\n\tdebugfs_create_file(\"status\", 0444, f2fs_debugfs_root, NULL,\n\t\t\t    &stat_fops);\n#endif\n}\n\nvoid f2fs_destroy_root_stats(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_remove_recursive(f2fs_debugfs_root);\n\tf2fs_debugfs_root = NULL;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}