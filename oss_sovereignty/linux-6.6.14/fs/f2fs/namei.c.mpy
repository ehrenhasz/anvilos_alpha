{
  "module_name": "namei.c",
  "hash_id": "63c656e7229966589e3aebef416bc721d1bf4c22de0d400296f1a52acca9f04d",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/namei.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include <trace/events/f2fs.h>\n\nstatic inline bool is_extension_exist(const unsigned char *s, const char *sub,\n\t\t\t\t\t\tbool tmp_ext, bool tmp_dot)\n{\n\tsize_t slen = strlen(s);\n\tsize_t sublen = strlen(sub);\n\tint i;\n\n\tif (sublen == 1 && *sub == '*')\n\t\treturn true;\n\n\t \n\tif (slen < sublen + 2)\n\t\treturn false;\n\n\tif (!tmp_ext) {\n\t\t \n\t\tif (s[slen - sublen - 1] != '.')\n\t\t\treturn false;\n\t\treturn !strncasecmp(s + slen - sublen, sub, sublen);\n\t}\n\n\tfor (i = 1; i < slen - sublen; i++) {\n\t\tif (s[i] != '.')\n\t\t\tcontinue;\n\t\tif (!strncasecmp(s + i + 1, sub, sublen)) {\n\t\t\tif (!tmp_dot)\n\t\t\t\treturn true;\n\t\t\tif (i == slen - sublen - 1 || s[i + 1 + sublen] == '.')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic inline bool is_temperature_extension(const unsigned char *s, const char *sub)\n{\n\treturn is_extension_exist(s, sub, true, false);\n}\n\nstatic inline bool is_compress_extension(const unsigned char *s, const char *sub)\n{\n\treturn is_extension_exist(s, sub, true, true);\n}\n\nint f2fs_update_extension_list(struct f2fs_sb_info *sbi, const char *name,\n\t\t\t\t\t\t\tbool hot, bool set)\n{\n\t__u8 (*extlist)[F2FS_EXTENSION_LEN] = sbi->raw_super->extension_list;\n\tint cold_count = le32_to_cpu(sbi->raw_super->extension_count);\n\tint hot_count = sbi->raw_super->hot_ext_count;\n\tint total_count = cold_count + hot_count;\n\tint start, count;\n\tint i;\n\n\tif (set) {\n\t\tif (total_count == F2FS_MAX_EXTENSION)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!hot && !cold_count)\n\t\t\treturn -EINVAL;\n\t\tif (hot && !hot_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (hot) {\n\t\tstart = cold_count;\n\t\tcount = total_count;\n\t} else {\n\t\tstart = 0;\n\t\tcount = cold_count;\n\t}\n\n\tfor (i = start; i < count; i++) {\n\t\tif (strcmp(name, extlist[i]))\n\t\t\tcontinue;\n\n\t\tif (set)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(extlist[i], extlist[i + 1],\n\t\t\t\tF2FS_EXTENSION_LEN * (total_count - i - 1));\n\t\tmemset(extlist[total_count - 1], 0, F2FS_EXTENSION_LEN);\n\t\tif (hot)\n\t\t\tsbi->raw_super->hot_ext_count = hot_count - 1;\n\t\telse\n\t\t\tsbi->raw_super->extension_count =\n\t\t\t\t\t\tcpu_to_le32(cold_count - 1);\n\t\treturn 0;\n\t}\n\n\tif (!set)\n\t\treturn -EINVAL;\n\n\tif (hot) {\n\t\tmemcpy(extlist[count], name, strlen(name));\n\t\tsbi->raw_super->hot_ext_count = hot_count + 1;\n\t} else {\n\t\tchar buf[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN];\n\n\t\tmemcpy(buf, &extlist[cold_count],\n\t\t\t\tF2FS_EXTENSION_LEN * hot_count);\n\t\tmemset(extlist[cold_count], 0, F2FS_EXTENSION_LEN);\n\t\tmemcpy(extlist[cold_count], name, strlen(name));\n\t\tmemcpy(&extlist[cold_count + 1], buf,\n\t\t\t\tF2FS_EXTENSION_LEN * hot_count);\n\t\tsbi->raw_super->extension_count = cpu_to_le32(cold_count + 1);\n\t}\n\treturn 0;\n}\n\nstatic void set_compress_new_inode(struct f2fs_sb_info *sbi, struct inode *dir,\n\t\t\t\tstruct inode *inode, const unsigned char *name)\n{\n\t__u8 (*extlist)[F2FS_EXTENSION_LEN] = sbi->raw_super->extension_list;\n\tunsigned char (*noext)[F2FS_EXTENSION_LEN] =\n\t\t\t\t\t\tF2FS_OPTION(sbi).noextensions;\n\tunsigned char (*ext)[F2FS_EXTENSION_LEN] = F2FS_OPTION(sbi).extensions;\n\tunsigned char ext_cnt = F2FS_OPTION(sbi).compress_ext_cnt;\n\tunsigned char noext_cnt = F2FS_OPTION(sbi).nocompress_ext_cnt;\n\tint i, cold_count, hot_count;\n\n\tif (!f2fs_sb_has_compression(sbi))\n\t\treturn;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tgoto inherit_comp;\n\n\t \n\tif (!name)\n\t\treturn;\n\n\t \n\tf2fs_down_read(&sbi->sb_lock);\n\tcold_count = le32_to_cpu(sbi->raw_super->extension_count);\n\thot_count = sbi->raw_super->hot_ext_count;\n\tfor (i = cold_count; i < cold_count + hot_count; i++)\n\t\tif (is_temperature_extension(name, extlist[i]))\n\t\t\tbreak;\n\tf2fs_up_read(&sbi->sb_lock);\n\tif (i < (cold_count + hot_count))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < noext_cnt; i++)\n\t\tif (is_compress_extension(name, noext[i]))\n\t\t\treturn;\n\n\t \n\tfor (i = 0; i < ext_cnt; i++) {\n\t\tif (is_compress_extension(name, ext[i])) {\n\t\t\tset_compress_context(inode);\n\t\t\treturn;\n\t\t}\n\t}\ninherit_comp:\n\t \n\tif (F2FS_I(dir)->i_flags & F2FS_NOCOMP_FL) {\n\t\tF2FS_I(inode)->i_flags |= F2FS_NOCOMP_FL;\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t} else if (F2FS_I(dir)->i_flags & F2FS_COMPR_FL) {\n\t\tset_compress_context(inode);\n\t}\n}\n\n \nstatic void set_file_temperature(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\tconst unsigned char *name)\n{\n\t__u8 (*extlist)[F2FS_EXTENSION_LEN] = sbi->raw_super->extension_list;\n\tint i, cold_count, hot_count;\n\n\tf2fs_down_read(&sbi->sb_lock);\n\tcold_count = le32_to_cpu(sbi->raw_super->extension_count);\n\thot_count = sbi->raw_super->hot_ext_count;\n\tfor (i = 0; i < cold_count + hot_count; i++)\n\t\tif (is_temperature_extension(name, extlist[i]))\n\t\t\tbreak;\n\tf2fs_up_read(&sbi->sb_lock);\n\n\tif (i == cold_count + hot_count)\n\t\treturn;\n\n\tif (i < cold_count)\n\t\tfile_set_cold(inode);\n\telse\n\t\tfile_set_hot(inode);\n}\n\nstatic struct inode *f2fs_new_inode(struct mnt_idmap *idmap,\n\t\t\t\t\t\tstruct inode *dir, umode_t mode,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tbool encrypt = false;\n\tint xattr_size = 0;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!f2fs_alloc_nid(sbi, &ino)) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tnid_free = true;\n\n\tinode_init_owner(idmap, inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tF2FS_I(inode)->i_crtime = inode->i_mtime;\n\tinode->i_generation = get_random_u32();\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tF2FS_I(inode)->i_current_depth = 1;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (f2fs_sb_has_project_quota(sbi) &&\n\t\t(F2FS_I(dir)->i_flags & F2FS_PROJINHERIT_FL))\n\t\tF2FS_I(inode)->i_projid = F2FS_I(dir)->i_projid;\n\telse\n\t\tF2FS_I(inode)->i_projid = make_kprojid(&init_user_ns,\n\t\t\t\t\t\t\tF2FS_DEF_PROJID);\n\n\terr = fscrypt_prepare_new_inode(dir, inode, &encrypt);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\tset_inode_flag(inode, FI_NEW_INODE);\n\n\tif (encrypt)\n\t\tf2fs_set_encrypted_inode(inode);\n\n\tif (f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_inode_flag(inode, FI_EXTRA_ATTR);\n\t\tF2FS_I(inode)->i_extra_isize = F2FS_TOTAL_EXTRA_ATTR_SIZE;\n\t}\n\n\tif (test_opt(sbi, INLINE_XATTR))\n\t\tset_inode_flag(inode, FI_INLINE_XATTR);\n\n\tif (f2fs_may_inline_dentry(inode))\n\t\tset_inode_flag(inode, FI_INLINE_DENTRY);\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tf2fs_bug_on(sbi, !f2fs_has_extra_attr(inode));\n\t\tif (f2fs_has_inline_xattr(inode))\n\t\t\txattr_size = F2FS_OPTION(sbi).inline_xattr_size;\n\t\t \n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\txattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t}\n\tF2FS_I(inode)->i_inline_xattr_size = xattr_size;\n\n\tF2FS_I(inode)->i_flags =\n\t\tf2fs_mask_flags(mode, F2FS_I(dir)->i_flags & F2FS_FL_INHERITED);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tF2FS_I(inode)->i_flags |= F2FS_INDEX_FL;\n\n\tif (F2FS_I(inode)->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\t \n\tset_compress_new_inode(sbi, dir, inode, name);\n\n\t \n\tif (test_opt(sbi, INLINE_DATA) && f2fs_may_inline_data(inode))\n\t\tset_inode_flag(inode, FI_INLINE_DATA);\n\n\tif (name && !test_opt(sbi, DISABLE_EXT_IDENTIFY))\n\t\tset_file_temperature(sbi, inode, name);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\tf2fs_set_inode_flags(inode);\n\n\tf2fs_init_extent_tree(inode);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\treturn inode;\n\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tif (nid_free)\n\t\tset_inode_flag(inode, FI_FREE_NID);\n\tiput(inode);\n\treturn ERR_PTR(err);\nfail_drop:\n\ttrace_f2fs_new_inode(inode, err);\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tif (nid_free)\n\t\tset_inode_flag(inode, FI_FREE_NID);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}\n\nstatic int f2fs_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t       struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tnid_t ino = 0;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(idmap, dir, mode, dentry->d_name.name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_file_inode_operations;\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tino = inode->i_ino;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_alloc_nid_done(sbi, ino);\n\n\td_instantiate_new(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\n\tf2fs_balance_fs(sbi, true);\n\treturn 0;\nout:\n\tf2fs_handle_failed_inode(inode);\n\treturn err;\n}\n\nstatic int f2fs_link(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = fscrypt_prepare_link(old_dentry, dir, dentry);\n\tif (err)\n\t\treturn err;\n\n\tif (is_inode_flag_set(dir, FI_PROJ_INHERIT) &&\n\t\t\t(!projid_eq(F2FS_I(dir)->i_projid,\n\t\t\tF2FS_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tinode_set_ctime_current(inode);\n\tihold(inode);\n\n\tset_inode_flag(inode, FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\td_instantiate(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\tclear_inode_flag(inode, FI_INC_LINK);\n\tiput(inode);\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}\n\nstruct dentry *f2fs_get_parent(struct dentry *child)\n{\n\tstruct page *page;\n\tunsigned long ino = f2fs_inode_by_name(d_inode(child), &dotdot_name, &page);\n\n\tif (!ino) {\n\t\tif (IS_ERR(page))\n\t\t\treturn ERR_CAST(page);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn d_obtain_alias(f2fs_iget(child->d_sb, ino));\n}\n\nstatic int __recover_dot_dentries(struct inode *dir, nid_t pino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct qstr dot = QSTR_INIT(\".\", 1);\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err = 0;\n\n\tif (f2fs_readonly(sbi->sb)) {\n\t\tf2fs_info(sbi, \"skip recovering inline_dots inode (ino:%lu, pino:%u) in readonly mountpoint\",\n\t\t\t  dir->i_ino, pino);\n\t\treturn 0;\n\t}\n\n\tif (!S_ISDIR(dir->i_mode)) {\n\t\tf2fs_err(sbi, \"inconsistent inode status, skip recovering inline_dots inode (ino:%lu, i_mode:%u, pino:%u)\",\n\t\t\t  dir->i_ino, dir->i_mode, pino);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\treturn -ENOTDIR;\n\t}\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_lock_op(sbi);\n\n\tde = f2fs_find_entry(dir, &dot, &page);\n\tif (de) {\n\t\tf2fs_put_page(page, 0);\n\t} else if (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto out;\n\t} else {\n\t\terr = f2fs_do_add_link(dir, &dot, NULL, dir->i_ino, S_IFDIR);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tde = f2fs_find_entry(dir, &dotdot, &page);\n\tif (de)\n\t\tf2fs_put_page(page, 0);\n\telse if (IS_ERR(page))\n\t\terr = PTR_ERR(page);\n\telse\n\t\terr = f2fs_do_add_link(dir, &dotdot, NULL, pino, S_IFDIR);\nout:\n\tif (!err)\n\t\tclear_inode_flag(dir, FI_INLINE_DOTS);\n\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}\n\nstatic struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tstruct dentry *new;\n\tnid_t ino = -1;\n\tint err = 0;\n\tunsigned int root_ino = F2FS_ROOT_INO(F2FS_I_SB(dir));\n\tstruct f2fs_filename fname;\n\n\ttrace_f2fs_lookup_start(dir, dentry, flags);\n\n\tif (dentry->d_name.len > F2FS_NAME_LEN) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = f2fs_prepare_lookup(dir, dentry, &fname);\n\tgeneric_set_encrypted_ci_d_ops(dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_splice;\n\tif (err)\n\t\tgoto out;\n\tde = __f2fs_find_entry(dir, &fname, &page);\n\tf2fs_free_filename(&fname);\n\n\tif (!de) {\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\t\terr = -ENOENT;\n\t\tgoto out_splice;\n\t}\n\n\tino = le32_to_cpu(de->ino);\n\tf2fs_put_page(page, 0);\n\n\tinode = f2fs_iget(dir->i_sb, ino);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\tif ((dir->i_ino == root_ino) && f2fs_has_inline_dots(dir)) {\n\t\terr = __recover_dot_dentries(dir, root_ino);\n\t\tif (err)\n\t\t\tgoto out_iput;\n\t}\n\n\tif (f2fs_has_inline_dots(inode)) {\n\t\terr = __recover_dot_dentries(inode, dir->i_ino);\n\t\tif (err)\n\t\t\tgoto out_iput;\n\t}\n\tif (IS_ENCRYPTED(dir) &&\n\t    (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&\n\t    !fscrypt_has_permitted_context(dir, inode)) {\n\t\tf2fs_warn(F2FS_I_SB(inode), \"Inconsistent encryption contexts: %lu/%lu\",\n\t\t\t  dir->i_ino, inode->i_ino);\n\t\terr = -EPERM;\n\t\tgoto out_iput;\n\t}\nout_splice:\n#if IS_ENABLED(CONFIG_UNICODE)\n\tif (!inode && IS_CASEFOLDED(dir)) {\n\t\t \n\t\ttrace_f2fs_lookup_end(dir, dentry, ino, err);\n\t\treturn NULL;\n\t}\n#endif\n\tnew = d_splice_alias(inode, dentry);\n\ttrace_f2fs_lookup_end(dir, !IS_ERR_OR_NULL(new) ? new : dentry,\n\t\t\t\tino, IS_ERR(new) ? PTR_ERR(new) : err);\n\treturn new;\nout_iput:\n\tiput(inode);\nout:\n\ttrace_f2fs_lookup_end(dir, dentry, ino, err);\n\treturn ERR_PTR(err);\n}\n\nstatic int f2fs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err;\n\n\ttrace_f2fs_unlink_enter(dir, dentry);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\tgoto fail;\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\tgoto fail;\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de) {\n\t\tif (IS_ERR(page))\n\t\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_acquire_orphan_inode(sbi);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tf2fs_put_page(page, 0);\n\t\tgoto fail;\n\t}\n\tf2fs_delete_entry(de, page, dir, inode);\n\tf2fs_unlock_op(sbi);\n\n#if IS_ENABLED(CONFIG_UNICODE)\n\t \n\tif (IS_CASEFOLDED(dir))\n\t\td_invalidate(dentry);\n#endif\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\nfail:\n\ttrace_f2fs_unlink_exit(inode, err);\n\treturn err;\n}\n\nstatic const char *f2fs_get_link(struct dentry *dentry,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct delayed_call *done)\n{\n\tconst char *link = page_get_link(dentry, inode, done);\n\n\tif (!IS_ERR(link) && !*link) {\n\t\t \n\t\tdo_delayed_call(done);\n\t\tclear_delayed_call(done);\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\treturn link;\n}\n\nstatic int f2fs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct dentry *dentry, const char *symname)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tsize_t len = strlen(symname);\n\tstruct fscrypt_str disk_link;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = fscrypt_prepare_symlink(dir, symname, len, dir->i_sb->s_blocksize,\n\t\t\t\t      &disk_link);\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(idmap, dir, S_IFLNK | S_IRWXUGO, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (IS_ENCRYPTED(inode))\n\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\telse\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\tinode_nohighmem(inode);\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_f2fs_handle_failed_inode;\n\tf2fs_unlock_op(sbi);\n\tf2fs_alloc_nid_done(sbi, inode->i_ino);\n\n\terr = fscrypt_encrypt_symlink(inode, symname, len, &disk_link);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = page_symlink(inode, disk_link.name, disk_link.len);\n\nerr_out:\n\td_instantiate_new(dentry, inode);\n\n\t \n\tif (!err) {\n\t\tfilemap_write_and_wait_range(inode->i_mapping, 0,\n\t\t\t\t\t\t\tdisk_link.len - 1);\n\n\t\tif (IS_DIRSYNC(dir))\n\t\t\tf2fs_sync_fs(sbi->sb, 1);\n\t} else {\n\t\tf2fs_unlink(dir, dentry);\n\t}\n\n\tf2fs_balance_fs(sbi, true);\n\tgoto out_free_encrypted_link;\n\nout_f2fs_handle_failed_inode:\n\tf2fs_handle_failed_inode(inode);\nout_free_encrypted_link:\n\tif (disk_link.name != (unsigned char *)symname)\n\t\tkfree(disk_link.name);\n\treturn err;\n}\n\nstatic int f2fs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(idmap, dir, S_IFDIR | mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_dir_inode_operations;\n\tinode->i_fop = &f2fs_dir_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\n\tset_inode_flag(inode, FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_alloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate_new(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\n\tf2fs_balance_fs(sbi, true);\n\treturn 0;\n\nout_fail:\n\tclear_inode_flag(inode, FI_INC_LINK);\n\tf2fs_handle_failed_inode(inode);\n\treturn err;\n}\n\nstatic int f2fs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (f2fs_empty_dir(inode))\n\t\treturn f2fs_unlink(dir, dentry);\n\treturn -ENOTEMPTY;\n}\n\nstatic int f2fs_mknod(struct mnt_idmap *idmap, struct inode *dir,\n\t\t      struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err = 0;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(idmap, dir, mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_op = &f2fs_special_inode_operations;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_alloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate_new(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\n\tf2fs_balance_fs(sbi, true);\n\treturn 0;\nout:\n\tf2fs_handle_failed_inode(inode);\n\treturn err;\n}\n\nstatic int __f2fs_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct file *file, umode_t mode, bool is_whiteout,\n\t\t\t  struct inode **new_inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\terr = f2fs_dquot_initialize(dir);\n\tif (err)\n\t\treturn err;\n\n\tinode = f2fs_new_inode(idmap, dir, mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (is_whiteout) {\n\t\tinit_special_inode(inode, inode->i_mode, WHITEOUT_DEV);\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t} else {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t}\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_acquire_orphan_inode(sbi);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_do_tmpfile(inode, dir);\n\tif (err)\n\t\tgoto release_out;\n\n\t \n\tf2fs_add_orphan_inode(inode);\n\tf2fs_alloc_nid_done(sbi, inode->i_ino);\n\n\tif (is_whiteout) {\n\t\tf2fs_i_links_write(inode, false);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tif (file)\n\t\t\td_tmpfile(file, inode);\n\t\telse\n\t\t\tf2fs_i_links_write(inode, false);\n\t}\n\t \n\tf2fs_unlock_op(sbi);\n\tunlock_new_inode(inode);\n\n\tif (new_inode)\n\t\t*new_inode = inode;\n\n\tf2fs_balance_fs(sbi, true);\n\treturn 0;\n\nrelease_out:\n\tf2fs_release_orphan_inode(sbi);\nout:\n\tf2fs_handle_failed_inode(inode);\n\treturn err;\n}\n\nstatic int f2fs_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\tstruct file *file, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\terr = __f2fs_tmpfile(idmap, dir, file, mode, false, NULL);\n\n\treturn finish_open_simple(file, err);\n}\n\nstatic int f2fs_create_whiteout(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *dir, struct inode **whiteout)\n{\n\treturn __f2fs_tmpfile(idmap, dir, NULL,\n\t\t\t\tS_IFCHR | WHITEOUT_MODE, true, whiteout);\n}\n\nint f2fs_get_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct inode **new_inode)\n{\n\treturn __f2fs_tmpfile(idmap, dir, NULL, S_IFREG, false, new_inode);\n}\n\nstatic int f2fs_rename(struct mnt_idmap *idmap, struct inode *old_dir,\n\t\t\tstruct dentry *old_dentry, struct inode *new_dir,\n\t\t\tstruct dentry *new_dentry, unsigned int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *whiteout = NULL;\n\tstruct page *old_dir_page = NULL;\n\tstruct page *old_page, *new_page = NULL;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\tif (is_inode_flag_set(new_dir, FI_PROJ_INHERIT) &&\n\t\t\t(!projid_eq(F2FS_I(new_dir)->i_projid,\n\t\t\tF2FS_I(old_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\t \n\tif (old_dir == new_dir && !new_inode) {\n\t\terr = f2fs_try_convert_inline_dir(old_dir, new_dentry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (flags & RENAME_WHITEOUT) {\n\t\terr = f2fs_create_whiteout(idmap, old_dir, &whiteout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = f2fs_dquot_initialize(old_dir);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_dquot_initialize(new_dir);\n\tif (err)\n\t\tgoto out;\n\n\tif (new_inode) {\n\t\terr = f2fs_dquot_initialize(new_inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry) {\n\t\tif (IS_ERR(old_page))\n\t\t\terr = PTR_ERR(old_page);\n\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\told_dir_entry = f2fs_parent_dir(old_inode, &old_dir_page);\n\t\tif (!old_dir_entry) {\n\t\t\tif (IS_ERR(old_dir_page))\n\t\t\t\terr = PTR_ERR(old_dir_page);\n\t\t\tgoto out_old;\n\t\t}\n\t}\n\n\tif (new_inode) {\n\n\t\terr = -ENOTEMPTY;\n\t\tif (old_dir_entry && !f2fs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\t\tif (!new_entry) {\n\t\t\tif (IS_ERR(new_page))\n\t\t\t\terr = PTR_ERR(new_page);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tf2fs_balance_fs(sbi, true);\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_acquire_orphan_inode(sbi);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\t\tnew_page = NULL;\n\n\t\tinode_set_ctime_current(new_inode);\n\t\tf2fs_down_write(&F2FS_I(new_inode)->i_sem);\n\t\tif (old_dir_entry)\n\t\t\tf2fs_i_links_write(new_inode, false);\n\t\tf2fs_i_links_write(new_inode, false);\n\t\tf2fs_up_write(&F2FS_I(new_inode)->i_sem);\n\n\t\tif (!new_inode->i_nlink)\n\t\t\tf2fs_add_orphan_inode(new_inode);\n\t\telse\n\t\t\tf2fs_release_orphan_inode(sbi);\n\t} else {\n\t\tf2fs_balance_fs(sbi, true);\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\t\tif (err) {\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tif (old_dir_entry)\n\t\t\tf2fs_i_links_write(new_dir, true);\n\t}\n\n\tf2fs_down_write(&F2FS_I(old_inode)->i_sem);\n\tif (!old_dir_entry || whiteout)\n\t\tfile_lost_pino(old_inode);\n\telse\n\t\t \n\t\tf2fs_i_pino_write(old_inode, new_dir->i_ino);\n\tf2fs_up_write(&F2FS_I(old_inode)->i_sem);\n\n\tinode_set_ctime_current(old_inode);\n\tf2fs_mark_inode_dirty_sync(old_inode, false);\n\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\told_page = NULL;\n\n\tif (whiteout) {\n\t\tset_inode_flag(whiteout, FI_INC_LINK);\n\t\terr = f2fs_add_link(old_dentry, whiteout);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tspin_lock(&whiteout->i_lock);\n\t\twhiteout->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&whiteout->i_lock);\n\n\t\tiput(whiteout);\n\t}\n\n\tif (old_dir_entry) {\n\t\tif (old_dir != new_dir)\n\t\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\t\told_dir_page, new_dir);\n\t\telse\n\t\t\tf2fs_put_page(old_dir_page, 0);\n\t\tf2fs_i_links_write(old_dir, false);\n\t}\n\tif (F2FS_OPTION(sbi).fsync_mode == FSYNC_MODE_STRICT) {\n\t\tf2fs_add_ino_entry(sbi, new_dir->i_ino, TRANS_DIR_INO);\n\t\tif (S_ISDIR(old_inode->i_mode))\n\t\t\tf2fs_add_ino_entry(sbi, old_inode->i_ino,\n\t\t\t\t\t\t\tTRANS_DIR_INO);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\treturn 0;\n\nput_out_dir:\n\tf2fs_unlock_op(sbi);\n\tf2fs_put_page(new_page, 0);\nout_dir:\n\tif (old_dir_entry)\n\t\tf2fs_put_page(old_dir_page, 0);\nout_old:\n\tf2fs_put_page(old_page, 0);\nout:\n\tiput(whiteout);\n\treturn err;\n}\n\nstatic int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct page *old_dir_page, *new_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry, *new_entry;\n\tint old_nlink = 0, new_nlink = 0;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn -ENOSPC;\n\n\tif ((is_inode_flag_set(new_dir, FI_PROJ_INHERIT) &&\n\t\t\t!projid_eq(F2FS_I(new_dir)->i_projid,\n\t\t\tF2FS_I(old_dentry->d_inode)->i_projid)) ||\n\t    (is_inode_flag_set(new_dir, FI_PROJ_INHERIT) &&\n\t\t\t!projid_eq(F2FS_I(old_dir)->i_projid,\n\t\t\tF2FS_I(new_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\terr = f2fs_dquot_initialize(old_dir);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_dquot_initialize(new_dir);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry) {\n\t\tif (IS_ERR(old_page))\n\t\t\terr = PTR_ERR(old_page);\n\t\tgoto out;\n\t}\n\n\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\tif (!new_entry) {\n\t\tif (IS_ERR(new_page))\n\t\t\terr = PTR_ERR(new_page);\n\t\tgoto out_old;\n\t}\n\n\t \n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\told_dir_entry = f2fs_parent_dir(old_inode,\n\t\t\t\t\t\t\t&old_dir_page);\n\t\t\tif (!old_dir_entry) {\n\t\t\t\tif (IS_ERR(old_dir_page))\n\t\t\t\t\terr = PTR_ERR(old_dir_page);\n\t\t\t\tgoto out_new;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\tnew_dir_entry = f2fs_parent_dir(new_inode,\n\t\t\t\t\t\t\t&new_dir_page);\n\t\t\tif (!new_dir_entry) {\n\t\t\t\tif (IS_ERR(new_dir_page))\n\t\t\t\t\terr = PTR_ERR(new_dir_page);\n\t\t\t\tgoto out_old_dir;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((!old_dir_entry || !new_dir_entry) &&\n\t\t\t\told_dir_entry != new_dir_entry) {\n\t\told_nlink = old_dir_entry ? -1 : 1;\n\t\tnew_nlink = -old_nlink;\n\t\terr = -EMLINK;\n\t\tif ((old_nlink > 0 && old_dir->i_nlink >= F2FS_LINK_MAX) ||\n\t\t\t(new_nlink > 0 && new_dir->i_nlink >= F2FS_LINK_MAX))\n\t\t\tgoto out_new_dir;\n\t}\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_lock_op(sbi);\n\n\t \n\tif (old_dir_entry)\n\t\tf2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);\n\n\t \n\tif (new_dir_entry)\n\t\tf2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);\n\n\t \n\tf2fs_set_link(old_dir, old_entry, old_page, new_inode);\n\n\tf2fs_down_write(&F2FS_I(old_inode)->i_sem);\n\tif (!old_dir_entry)\n\t\tfile_lost_pino(old_inode);\n\telse\n\t\t \n\t\tf2fs_i_pino_write(old_inode, new_dir->i_ino);\n\tf2fs_up_write(&F2FS_I(old_inode)->i_sem);\n\n\tinode_set_ctime_current(old_dir);\n\tif (old_nlink) {\n\t\tf2fs_down_write(&F2FS_I(old_dir)->i_sem);\n\t\tf2fs_i_links_write(old_dir, old_nlink > 0);\n\t\tf2fs_up_write(&F2FS_I(old_dir)->i_sem);\n\t}\n\tf2fs_mark_inode_dirty_sync(old_dir, false);\n\n\t \n\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\tf2fs_down_write(&F2FS_I(new_inode)->i_sem);\n\tif (!new_dir_entry)\n\t\tfile_lost_pino(new_inode);\n\telse\n\t\t \n\t\tf2fs_i_pino_write(new_inode, old_dir->i_ino);\n\tf2fs_up_write(&F2FS_I(new_inode)->i_sem);\n\n\tinode_set_ctime_current(new_dir);\n\tif (new_nlink) {\n\t\tf2fs_down_write(&F2FS_I(new_dir)->i_sem);\n\t\tf2fs_i_links_write(new_dir, new_nlink > 0);\n\t\tf2fs_up_write(&F2FS_I(new_dir)->i_sem);\n\t}\n\tf2fs_mark_inode_dirty_sync(new_dir, false);\n\n\tif (F2FS_OPTION(sbi).fsync_mode == FSYNC_MODE_STRICT) {\n\t\tf2fs_add_ino_entry(sbi, old_dir->i_ino, TRANS_DIR_INO);\n\t\tf2fs_add_ino_entry(sbi, new_dir->i_ino, TRANS_DIR_INO);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\treturn 0;\nout_new_dir:\n\tif (new_dir_entry) {\n\t\tf2fs_put_page(new_dir_page, 0);\n\t}\nout_old_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_new:\n\tf2fs_put_page(new_page, 0);\nout_old:\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}\n\nstatic int f2fs_rename2(struct mnt_idmap *idmap,\n\t\t\tstruct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn f2fs_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\t \n\treturn f2fs_rename(idmap, old_dir, old_dentry,\n\t\t\t\t\tnew_dir, new_dentry, flags);\n}\n\nstatic const char *f2fs_encrypted_get_link(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   struct delayed_call *done)\n{\n\tstruct page *page;\n\tconst char *target;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tpage = read_mapping_page(inode->i_mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn ERR_CAST(page);\n\n\ttarget = fscrypt_get_symlink(inode, page_address(page),\n\t\t\t\t     inode->i_sb->s_blocksize, done);\n\tput_page(page);\n\treturn target;\n}\n\nstatic int f2fs_encrypted_symlink_getattr(struct mnt_idmap *idmap,\n\t\t\t\t\t  const struct path *path,\n\t\t\t\t\t  struct kstat *stat, u32 request_mask,\n\t\t\t\t\t  unsigned int query_flags)\n{\n\tf2fs_getattr(idmap, path, stat, request_mask, query_flags);\n\n\treturn fscrypt_symlink_getattr(path, stat);\n}\n\nconst struct inode_operations f2fs_encrypted_symlink_inode_operations = {\n\t.get_link\t= f2fs_encrypted_get_link,\n\t.getattr\t= f2fs_encrypted_symlink_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.listxattr\t= f2fs_listxattr,\n};\n\nconst struct inode_operations f2fs_dir_inode_operations = {\n\t.create\t\t= f2fs_create,\n\t.lookup\t\t= f2fs_lookup,\n\t.link\t\t= f2fs_link,\n\t.unlink\t\t= f2fs_unlink,\n\t.symlink\t= f2fs_symlink,\n\t.mkdir\t\t= f2fs_mkdir,\n\t.rmdir\t\t= f2fs_rmdir,\n\t.mknod\t\t= f2fs_mknod,\n\t.rename\t\t= f2fs_rename2,\n\t.tmpfile\t= f2fs_tmpfile,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.get_inode_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n\t.listxattr\t= f2fs_listxattr,\n\t.fiemap\t\t= f2fs_fiemap,\n\t.fileattr_get\t= f2fs_fileattr_get,\n\t.fileattr_set\t= f2fs_fileattr_set,\n};\n\nconst struct inode_operations f2fs_symlink_inode_operations = {\n\t.get_link\t= f2fs_get_link,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.listxattr\t= f2fs_listxattr,\n};\n\nconst struct inode_operations f2fs_special_inode_operations = {\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.get_inode_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n\t.listxattr\t= f2fs_listxattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}