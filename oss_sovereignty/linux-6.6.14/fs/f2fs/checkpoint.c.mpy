{
  "module_name": "checkpoint.c",
  "hash_id": "cc34f460c12b81af002c73dc2e6eba287fbe2f517434d80c8cf8258a0f822f9e",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/checkpoint.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/kthread.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n\n#define DEFAULT_CHECKPOINT_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))\n\nstatic struct kmem_cache *ino_entry_slab;\nstruct kmem_cache *f2fs_inode_entry_slab;\n\nvoid f2fs_stop_checkpoint(struct f2fs_sb_info *sbi, bool end_io,\n\t\t\t\t\t\tunsigned char reason)\n{\n\tf2fs_build_fault_attr(sbi, 0, 0);\n\tif (!end_io)\n\t\tf2fs_flush_merged_writes(sbi);\n\tf2fs_handle_critical_error(sbi, reason, end_io);\n}\n\n \nstruct page *f2fs_grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\nrepeat:\n\tpage = f2fs_grab_cache_page(mapping, index, false);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tf2fs_wait_on_page_writeback(page, META, true, true);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\treturn page;\n}\n\nstatic struct page *__get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index,\n\t\t\t\t\t\t\tbool is_meta)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = META,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = REQ_META | REQ_PRIO,\n\t\t.old_blkaddr = index,\n\t\t.new_blkaddr = index,\n\t\t.encrypted_page = NULL,\n\t\t.is_por = !is_meta ? 1 : 0,\n\t};\n\tint err;\n\n\tif (unlikely(!is_meta))\n\t\tfio.op_flags &= ~REQ_META;\nrepeat:\n\tpage = f2fs_grab_cache_page(mapping, index, false);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tfio.page = page;\n\n\terr = f2fs_submit_page_bio(&fio);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tf2fs_update_iostat(sbi, NULL, FS_META_READ_IO, F2FS_BLKSIZE);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_handle_page_eio(sbi, page->index, META);\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\nout:\n\treturn page;\n}\n\nstruct page *f2fs_get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\treturn __get_meta_page(sbi, index, true);\n}\n\nstruct page *f2fs_get_meta_page_retry(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tint count = 0;\n\nretry:\n\tpage = __get_meta_page(sbi, index, true);\n\tif (IS_ERR(page)) {\n\t\tif (PTR_ERR(page) == -EIO &&\n\t\t\t\t++count <= DEFAULT_RETRY_IO_COUNT)\n\t\t\tgoto retry;\n\t\tf2fs_stop_checkpoint(sbi, false, STOP_CP_REASON_META_PAGE);\n\t}\n\treturn page;\n}\n\n \nstruct page *f2fs_get_tmp_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\treturn __get_meta_page(sbi, index, false);\n}\n\nstatic bool __is_bitmap_valid(struct f2fs_sb_info *sbi, block_t blkaddr,\n\t\t\t\t\t\t\tint type)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tbool exist;\n\n\tif (type == DATA_GENERIC)\n\t\treturn true;\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\n\texist = f2fs_test_bit(offset, se->cur_valid_map);\n\n\t \n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn exist;\n\n\tif (exist && type == DATA_GENERIC_ENHANCE_UPDATE) {\n\t\tf2fs_err(sbi, \"Inconsistent error blkaddr:%u, sit bitmap:%d\",\n\t\t\t blkaddr, exist);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\treturn exist;\n\t}\n\n\tif (!exist && type == DATA_GENERIC_ENHANCE) {\n\t\tf2fs_err(sbi, \"Inconsistent error blkaddr:%u, sit bitmap:%d\",\n\t\t\t blkaddr, exist);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tdump_stack();\n\t}\n\treturn exist;\n}\n\nbool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tif (time_to_inject(sbi, FAULT_BLKADDR))\n\t\treturn false;\n\n\tswitch (type) {\n\tcase META_NAT:\n\t\tbreak;\n\tcase META_SIT:\n\t\tif (unlikely(blkaddr >= SIT_BLK_CNT(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_SSA:\n\t\tif (unlikely(blkaddr >= MAIN_BLKADDR(sbi) ||\n\t\t\tblkaddr < SM_I(sbi)->ssa_blkaddr))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_CP:\n\t\tif (unlikely(blkaddr >= SIT_I(sbi)->sit_base_addr ||\n\t\t\tblkaddr < __start_cp_addr(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase META_POR:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\tblkaddr < MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase DATA_GENERIC:\n\tcase DATA_GENERIC_ENHANCE:\n\tcase DATA_GENERIC_ENHANCE_READ:\n\tcase DATA_GENERIC_ENHANCE_UPDATE:\n\t\tif (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||\n\t\t\t\tblkaddr < MAIN_BLKADDR(sbi))) {\n\n\t\t\t \n\t\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\t\treturn false;\n\n\t\t\tf2fs_warn(sbi, \"access invalid blkaddr:%u\",\n\t\t\t\t  blkaddr);\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tdump_stack();\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn __is_bitmap_valid(sbi, blkaddr, type);\n\t\t}\n\t\tbreak;\n\tcase META_GENERIC:\n\t\tif (unlikely(blkaddr < SEG0_BLKADDR(sbi) ||\n\t\t\tblkaddr >= MAIN_BLKADDR(sbi)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn true;\n}\n\n \nint f2fs_ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages,\n\t\t\t\t\t\t\tint type, bool sync)\n{\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = META,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = sync ? (REQ_META | REQ_PRIO) : REQ_RAHEAD,\n\t\t.encrypted_page = NULL,\n\t\t.in_list = 0,\n\t\t.is_por = (type == META_POR) ? 1 : 0,\n\t};\n\tstruct blk_plug plug;\n\tint err;\n\n\tif (unlikely(type == META_POR))\n\t\tfio.op_flags &= ~REQ_META;\n\n\tblk_start_plug(&plug);\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!f2fs_is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t \n\t\t\tfio.new_blkaddr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\tif (unlikely(blkno >= TOTAL_SEGS(sbi)))\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\tfio.new_blkaddr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.new_blkaddr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = f2fs_grab_cache_page(META_MAPPING(sbi),\n\t\t\t\t\t\tfio.new_blkaddr, false);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfio.page = page;\n\t\terr = f2fs_submit_page_bio(&fio);\n\t\tf2fs_put_page(page, err ? 1 : 0);\n\n\t\tif (!err)\n\t\t\tf2fs_update_iostat(sbi, NULL, FS_META_READ_IO,\n\t\t\t\t\t\t\tF2FS_BLKSIZE);\n\t}\nout:\n\tblk_finish_plug(&plug);\n\treturn blkno - start;\n}\n\nvoid f2fs_ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index,\n\t\t\t\t\t\t\tunsigned int ra_blocks)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tif (ra_blocks == RECOVERY_MIN_RA_BLOCKS)\n\t\treturn;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || !PageUptodate(page))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tf2fs_ra_meta_pages(sbi, index, ra_blocks, META_POR, true);\n}\n\nstatic int __f2fs_write_meta_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\tenum iostat_type io_type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\ttrace_f2fs_writepage(page, META);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE)) {\n\t\t\tClearPageUptodate(page);\n\t\t\tdec_page_count(sbi, F2FS_DIRTY_META);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto redirty_out;\n\t}\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (wbc->for_reclaim && page->index < GET_SUM_BLOCK(sbi, 0))\n\t\tgoto redirty_out;\n\n\tf2fs_do_write_meta_page(sbi, page, io_type);\n\tdec_page_count(sbi, F2FS_DIRTY_META);\n\n\tif (wbc->for_reclaim)\n\t\tf2fs_submit_merged_write_cond(sbi, NULL, page, 0, META);\n\n\tunlock_page(page);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tf2fs_submit_merged_write(sbi, META);\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}\n\nstatic int f2fs_write_meta_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\treturn __f2fs_write_meta_page(page, wbc, FS_META_IO);\n}\n\nstatic int f2fs_write_meta_pages(struct address_space *mapping,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tlong diff, written;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto skip_write;\n\n\t \n\tif (wbc->sync_mode != WB_SYNC_ALL &&\n\t\t\tget_pages(sbi, F2FS_DIRTY_META) <\n\t\t\t\t\tnr_pages_to_skip(sbi, META))\n\t\tgoto skip_write;\n\n\t \n\tif (!f2fs_down_write_trylock(&sbi->cp_global_sem))\n\t\tgoto skip_write;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\tdiff = nr_pages_to_write(sbi, META, wbc);\n\twritten = f2fs_sync_meta_pages(sbi, META, wbc->nr_to_write, FS_META_IO);\n\tf2fs_up_write(&sbi->cp_global_sem);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - written - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_META);\n\ttrace_f2fs_writepages(mapping->host, wbc, META);\n\treturn 0;\n}\n\nlong f2fs_sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\tlong nr_to_write, enum iostat_type io_type)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, prev = ULONG_MAX;\n\tstruct folio_batch fbatch;\n\tlong nwritten = 0;\n\tint nr_folios;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\tstruct blk_plug plug;\n\n\tfolio_batch_init(&fbatch);\n\n\tblk_start_plug(&plug);\n\n\twhile ((nr_folios = filemap_get_folios_tag(mapping, &index,\n\t\t\t\t\t(pgoff_t)-1,\n\t\t\t\t\tPAGECACHE_TAG_DIRTY, &fbatch))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct folio *folio = fbatch.folios[i];\n\n\t\t\tif (nr_to_write != LONG_MAX && i != 0 &&\n\t\t\t\t\tfolio->index != prev +\n\t\t\t\t\tfolio_nr_pages(fbatch.folios[i-1])) {\n\t\t\t\tfolio_batch_release(&fbatch);\n\t\t\t\tgoto stop;\n\t\t\t}\n\n\t\t\tfolio_lock(folio);\n\n\t\t\tif (unlikely(folio->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!folio_test_dirty(folio)) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(&folio->page, META,\n\t\t\t\t\ttrue, true);\n\n\t\t\tif (!folio_clear_dirty_for_io(folio))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (__f2fs_write_meta_page(&folio->page, &wbc,\n\t\t\t\t\t\tio_type)) {\n\t\t\t\tfolio_unlock(folio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten += folio_nr_pages(folio);\n\t\t\tprev = folio->index;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\t}\nstop:\n\tif (nwritten)\n\t\tf2fs_submit_merged_write(sbi, type);\n\n\tblk_finish_plug(&plug);\n\n\treturn nwritten;\n}\n\nstatic bool f2fs_dirty_meta_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\ttrace_f2fs_set_page_dirty(&folio->page, META);\n\n\tif (!folio_test_uptodate(folio))\n\t\tfolio_mark_uptodate(folio);\n\tif (filemap_dirty_folio(mapping, folio)) {\n\t\tinc_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_META);\n\t\tset_page_private_reference(&folio->page);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nconst struct address_space_operations f2fs_meta_aops = {\n\t.writepage\t= f2fs_write_meta_page,\n\t.writepages\t= f2fs_write_meta_pages,\n\t.dirty_folio\t= f2fs_dirty_meta_folio,\n\t.invalidate_folio = f2fs_invalidate_folio,\n\t.release_folio\t= f2fs_release_folio,\n\t.migrate_folio\t= filemap_migrate_folio,\n};\n\nstatic void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\t\tunsigned int devidx, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e = NULL, *new = NULL;\n\n\tif (type == FLUSH_INO) {\n\t\trcu_read_lock();\n\t\te = radix_tree_lookup(&im->ino_root, ino);\n\t\trcu_read_unlock();\n\t}\n\nretry:\n\tif (!e)\n\t\tnew = f2fs_kmem_cache_alloc(ino_entry_slab,\n\t\t\t\t\t\tGFP_NOFS, true, NULL);\n\n\tradix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (!e) {\n\t\tif (!new) {\n\t\t\tspin_unlock(&im->ino_lock);\n\t\t\tradix_tree_preload_end();\n\t\t\tgoto retry;\n\t\t}\n\t\te = new;\n\t\tif (unlikely(radix_tree_insert(&im->ino_root, ino, e)))\n\t\t\tf2fs_bug_on(sbi, 1);\n\n\t\tmemset(e, 0, sizeof(struct ino_entry));\n\t\te->ino = ino;\n\n\t\tlist_add_tail(&e->list, &im->ino_list);\n\t\tif (type != ORPHAN_INO)\n\t\t\tim->ino_num++;\n\t}\n\n\tif (type == FLUSH_INO)\n\t\tf2fs_set_bit(devidx, (char *)&e->dirty_device);\n\n\tspin_unlock(&im->ino_lock);\n\tradix_tree_preload_end();\n\n\tif (new && e != new)\n\t\tkmem_cache_free(ino_entry_slab, new);\n}\n\nstatic void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e) {\n\t\tlist_del(&e->list);\n\t\tradix_tree_delete(&im->ino_root, ino);\n\t\tim->ino_num--;\n\t\tspin_unlock(&im->ino_lock);\n\t\tkmem_cache_free(ino_entry_slab, e);\n\t\treturn;\n\t}\n\tspin_unlock(&im->ino_lock);\n}\n\nvoid f2fs_add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t \n\t__add_ino_entry(sbi, ino, 0, type);\n}\n\nvoid f2fs_remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t \n\t__remove_ino_entry(sbi, ino, type);\n}\n\n \nbool f2fs_exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)\n{\n\tstruct inode_management *im = &sbi->im[mode];\n\tstruct ino_entry *e;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tspin_unlock(&im->ino_lock);\n\treturn e ? true : false;\n}\n\nvoid f2fs_release_ino_entry(struct f2fs_sb_info *sbi, bool all)\n{\n\tstruct ino_entry *e, *tmp;\n\tint i;\n\n\tfor (i = all ? ORPHAN_INO : APPEND_INO; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tspin_lock(&im->ino_lock);\n\t\tlist_for_each_entry_safe(e, tmp, &im->ino_list, list) {\n\t\t\tlist_del(&e->list);\n\t\t\tradix_tree_delete(&im->ino_root, e->ino);\n\t\t\tkmem_cache_free(ino_entry_slab, e);\n\t\t\tim->ino_num--;\n\t\t}\n\t\tspin_unlock(&im->ino_lock);\n\t}\n}\n\nvoid f2fs_set_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tunsigned int devidx, int type)\n{\n\t__add_ino_entry(sbi, ino, devidx, type);\n}\n\nbool f2fs_is_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tunsigned int devidx, int type)\n{\n\tstruct inode_management *im = &sbi->im[type];\n\tstruct ino_entry *e;\n\tbool is_dirty = false;\n\n\tspin_lock(&im->ino_lock);\n\te = radix_tree_lookup(&im->ino_root, ino);\n\tif (e && f2fs_test_bit(devidx, (char *)&e->dirty_device))\n\t\tis_dirty = true;\n\tspin_unlock(&im->ino_lock);\n\treturn is_dirty;\n}\n\nint f2fs_acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\n\tif (time_to_inject(sbi, FAULT_ORPHAN)) {\n\t\tspin_unlock(&im->ino_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}\n\nvoid f2fs_release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}\n\nvoid f2fs_add_orphan_inode(struct inode *inode)\n{\n\t \n\t__add_ino_entry(F2FS_I_SB(inode), inode->i_ino, 0, ORPHAN_INO);\n\tf2fs_update_inode_page(inode);\n}\n\nvoid f2fs_remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t \n\t__remove_ino_entry(sbi, ino, ORPHAN_INO);\n}\n\nstatic int recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode;\n\tstruct node_info ni;\n\tint err;\n\n\tinode = f2fs_iget_retry(sbi->sb, ino);\n\tif (IS_ERR(inode)) {\n\t\t \n\t\tf2fs_bug_on(sbi, PTR_ERR(inode) == -ENOENT);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err) {\n\t\tiput(inode);\n\t\tgoto err_out;\n\t}\n\n\tclear_nlink(inode);\n\n\t \n\tiput(inode);\n\n\terr = f2fs_get_node_info(sbi, ino, &ni, false);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tif (ni.blk_addr != NULL_ADDR) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\treturn 0;\n\nerr_out:\n\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\tf2fs_warn(sbi, \"%s: orphan failed (ino=%x), run fsck to fix.\",\n\t\t  __func__, ino);\n\treturn err;\n}\n\nint f2fs_recover_orphan_inodes(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_blk, orphan_blocks, i, j;\n\tint err = 0;\n\n\tif (!is_set_ckpt_flags(sbi, CP_ORPHAN_PRESENT_FLAG))\n\t\treturn 0;\n\n\tif (f2fs_hw_is_readonly(sbi)) {\n\t\tf2fs_info(sbi, \"write access unavailable, skipping orphan cleanup\");\n\t\treturn 0;\n\t}\n\n\tif (is_sbi_flag_set(sbi, SBI_IS_WRITABLE))\n\t\tf2fs_info(sbi, \"orphan cleanup on readonly fs\");\n\n\tstart_blk = __start_cp_addr(sbi) + 1 + __cp_payload(sbi);\n\torphan_blocks = __start_sum_addr(sbi) - 1 - __cp_payload(sbi);\n\n\tf2fs_ra_meta_pages(sbi, start_blk, orphan_blocks, META_CP, true);\n\n\tfor (i = 0; i < orphan_blocks; i++) {\n\t\tstruct page *page;\n\t\tstruct f2fs_orphan_block *orphan_blk;\n\n\t\tpage = f2fs_get_meta_page(sbi, start_blk + i);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\torphan_blk = (struct f2fs_orphan_block *)page_address(page);\n\t\tfor (j = 0; j < le32_to_cpu(orphan_blk->entry_count); j++) {\n\t\t\tnid_t ino = le32_to_cpu(orphan_blk->ino[j]);\n\n\t\t\terr = recover_orphan_inode(sbi, ino);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_page(page, 1);\n\t}\n\t \n\tclear_ckpt_flags(sbi, CP_ORPHAN_PRESENT_FLAG);\nout:\n\tset_sbi_flag(sbi, SBI_IS_RECOVERED);\n\n\treturn err;\n}\n\nstatic void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tstruct list_head *head;\n\tstruct f2fs_orphan_block *orphan_blk = NULL;\n\tunsigned int nentries = 0;\n\tunsigned short index = 1;\n\tunsigned short orphan_blocks;\n\tstruct page *page = NULL;\n\tstruct ino_entry *orphan = NULL;\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(im->ino_num);\n\n\t \n\thead = &im->ino_list;\n\n\t \n\tlist_for_each_entry(orphan, head, list) {\n\t\tif (!page) {\n\t\t\tpage = f2fs_grab_meta_page(sbi, start_blk++);\n\t\t\torphan_blk =\n\t\t\t\t(struct f2fs_orphan_block *)page_address(page);\n\t\t\tmemset(orphan_blk, 0, sizeof(*orphan_blk));\n\t\t}\n\n\t\torphan_blk->ino[nentries++] = cpu_to_le32(orphan->ino);\n\n\t\tif (nentries == F2FS_ORPHANS_PER_BLOCK) {\n\t\t\t \n\t\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tindex++;\n\t\t\tnentries = 0;\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\torphan_blk->blk_addr = cpu_to_le16(index);\n\t\torphan_blk->blk_count = cpu_to_le16(orphan_blocks);\n\t\torphan_blk->entry_count = cpu_to_le32(nentries);\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}\n\nstatic __u32 f2fs_checkpoint_chksum(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct f2fs_checkpoint *ckpt)\n{\n\tunsigned int chksum_ofs = le32_to_cpu(ckpt->checksum_offset);\n\t__u32 chksum;\n\n\tchksum = f2fs_crc32(sbi, ckpt, chksum_ofs);\n\tif (chksum_ofs < CP_CHKSUM_OFFSET) {\n\t\tchksum_ofs += sizeof(chksum);\n\t\tchksum = f2fs_chksum(sbi, chksum, (__u8 *)ckpt + chksum_ofs,\n\t\t\t\t\t\tF2FS_BLKSIZE - chksum_ofs);\n\t}\n\treturn chksum;\n}\n\nstatic int get_checkpoint_version(struct f2fs_sb_info *sbi, block_t cp_addr,\n\t\tstruct f2fs_checkpoint **cp_block, struct page **cp_page,\n\t\tunsigned long long *version)\n{\n\tsize_t crc_offset = 0;\n\t__u32 crc;\n\n\t*cp_page = f2fs_get_meta_page(sbi, cp_addr);\n\tif (IS_ERR(*cp_page))\n\t\treturn PTR_ERR(*cp_page);\n\n\t*cp_block = (struct f2fs_checkpoint *)page_address(*cp_page);\n\n\tcrc_offset = le32_to_cpu((*cp_block)->checksum_offset);\n\tif (crc_offset < CP_MIN_CHKSUM_OFFSET ||\n\t\t\tcrc_offset > CP_CHKSUM_OFFSET) {\n\t\tf2fs_put_page(*cp_page, 1);\n\t\tf2fs_warn(sbi, \"invalid crc_offset: %zu\", crc_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tcrc = f2fs_checkpoint_chksum(sbi, *cp_block);\n\tif (crc != cur_cp_crc(*cp_block)) {\n\t\tf2fs_put_page(*cp_page, 1);\n\t\tf2fs_warn(sbi, \"invalid crc value\");\n\t\treturn -EINVAL;\n\t}\n\n\t*version = cur_cp_version(*cp_block);\n\treturn 0;\n}\n\nstatic struct page *validate_checkpoint(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t cp_addr, unsigned long long *version)\n{\n\tstruct page *cp_page_1 = NULL, *cp_page_2 = NULL;\n\tstruct f2fs_checkpoint *cp_block = NULL;\n\tunsigned long long cur_version = 0, pre_version = 0;\n\tunsigned int cp_blocks;\n\tint err;\n\n\terr = get_checkpoint_version(sbi, cp_addr, &cp_block,\n\t\t\t\t\t&cp_page_1, version);\n\tif (err)\n\t\treturn NULL;\n\n\tcp_blocks = le32_to_cpu(cp_block->cp_pack_total_block_count);\n\n\tif (cp_blocks > sbi->blocks_per_seg || cp_blocks <= F2FS_CP_PACKS) {\n\t\tf2fs_warn(sbi, \"invalid cp_pack_total_block_count:%u\",\n\t\t\t  le32_to_cpu(cp_block->cp_pack_total_block_count));\n\t\tgoto invalid_cp;\n\t}\n\tpre_version = *version;\n\n\tcp_addr += cp_blocks - 1;\n\terr = get_checkpoint_version(sbi, cp_addr, &cp_block,\n\t\t\t\t\t&cp_page_2, version);\n\tif (err)\n\t\tgoto invalid_cp;\n\tcur_version = *version;\n\n\tif (cur_version == pre_version) {\n\t\t*version = cur_version;\n\t\tf2fs_put_page(cp_page_2, 1);\n\t\treturn cp_page_1;\n\t}\n\tf2fs_put_page(cp_page_2, 1);\ninvalid_cp:\n\tf2fs_put_page(cp_page_1, 1);\n\treturn NULL;\n}\n\nint f2fs_get_valid_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *cp_block;\n\tstruct f2fs_super_block *fsb = sbi->raw_super;\n\tstruct page *cp1, *cp2, *cur_page;\n\tunsigned long blk_size = sbi->blocksize;\n\tunsigned long long cp1_version = 0, cp2_version = 0;\n\tunsigned long long cp_start_blk_no;\n\tunsigned int cp_blks = 1 + __cp_payload(sbi);\n\tblock_t cp_blk_no;\n\tint i;\n\tint err;\n\n\tsbi->ckpt = f2fs_kvzalloc(sbi, array_size(blk_size, cp_blks),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sbi->ckpt)\n\t\treturn -ENOMEM;\n\t \n\tcp_start_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tcp1 = validate_checkpoint(sbi, cp_start_blk_no, &cp1_version);\n\n\t \n\tcp_start_blk_no += ((unsigned long long)1) <<\n\t\t\t\tle32_to_cpu(fsb->log_blocks_per_seg);\n\tcp2 = validate_checkpoint(sbi, cp_start_blk_no, &cp2_version);\n\n\tif (cp1 && cp2) {\n\t\tif (ver_after(cp2_version, cp1_version))\n\t\t\tcur_page = cp2;\n\t\telse\n\t\t\tcur_page = cp1;\n\t} else if (cp1) {\n\t\tcur_page = cp1;\n\t} else if (cp2) {\n\t\tcur_page = cp2;\n\t} else {\n\t\terr = -EFSCORRUPTED;\n\t\tgoto fail_no_cp;\n\t}\n\n\tcp_block = (struct f2fs_checkpoint *)page_address(cur_page);\n\tmemcpy(sbi->ckpt, cp_block, blk_size);\n\n\tif (cur_page == cp1)\n\t\tsbi->cur_cp_pack = 1;\n\telse\n\t\tsbi->cur_cp_pack = 2;\n\n\t \n\tif (f2fs_sanity_check_ckpt(sbi)) {\n\t\terr = -EFSCORRUPTED;\n\t\tgoto free_fail_no_cp;\n\t}\n\n\tif (cp_blks <= 1)\n\t\tgoto done;\n\n\tcp_blk_no = le32_to_cpu(fsb->cp_blkaddr);\n\tif (cur_page == cp2)\n\t\tcp_blk_no += BIT(le32_to_cpu(fsb->log_blocks_per_seg));\n\n\tfor (i = 1; i < cp_blks; i++) {\n\t\tvoid *sit_bitmap_ptr;\n\t\tunsigned char *ckpt = (unsigned char *)sbi->ckpt;\n\n\t\tcur_page = f2fs_get_meta_page(sbi, cp_blk_no + i);\n\t\tif (IS_ERR(cur_page)) {\n\t\t\terr = PTR_ERR(cur_page);\n\t\t\tgoto free_fail_no_cp;\n\t\t}\n\t\tsit_bitmap_ptr = page_address(cur_page);\n\t\tmemcpy(ckpt + i * blk_size, sit_bitmap_ptr, blk_size);\n\t\tf2fs_put_page(cur_page, 1);\n\t}\ndone:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\n\treturn 0;\n\nfree_fail_no_cp:\n\tf2fs_put_page(cp1, 1);\n\tf2fs_put_page(cp2, 1);\nfail_no_cp:\n\tkvfree(sbi->ckpt);\n\treturn err;\n}\n\nstatic void __add_dirty_inode(struct inode *inode, enum inode_type type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint flag = (type == DIR_INODE) ? FI_DIRTY_DIR : FI_DIRTY_FILE;\n\n\tif (is_inode_flag_set(inode, flag))\n\t\treturn;\n\n\tset_inode_flag(inode, flag);\n\tlist_add_tail(&F2FS_I(inode)->dirty_list, &sbi->inode_list[type]);\n\tstat_inc_dirty_inode(sbi, type);\n}\n\nstatic void __remove_dirty_inode(struct inode *inode, enum inode_type type)\n{\n\tint flag = (type == DIR_INODE) ? FI_DIRTY_DIR : FI_DIRTY_FILE;\n\n\tif (get_dirty_pages(inode) || !is_inode_flag_set(inode, flag))\n\t\treturn;\n\n\tlist_del_init(&F2FS_I(inode)->dirty_list);\n\tclear_inode_flag(inode, flag);\n\tstat_dec_dirty_inode(F2FS_I_SB(inode), type);\n}\n\nvoid f2fs_update_dirty_folio(struct inode *inode, struct folio *folio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tenum inode_type type = S_ISDIR(inode->i_mode) ? DIR_INODE : FILE_INODE;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISLNK(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->inode_lock[type]);\n\tif (type != FILE_INODE || test_opt(sbi, DATA_FLUSH))\n\t\t__add_dirty_inode(inode, type);\n\tinode_inc_dirty_pages(inode);\n\tspin_unlock(&sbi->inode_lock[type]);\n\n\tset_page_private_reference(&folio->page);\n}\n\nvoid f2fs_remove_dirty_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tenum inode_type type = S_ISDIR(inode->i_mode) ? DIR_INODE : FILE_INODE;\n\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISLNK(inode->i_mode))\n\t\treturn;\n\n\tif (type == FILE_INODE && !test_opt(sbi, DATA_FLUSH))\n\t\treturn;\n\n\tspin_lock(&sbi->inode_lock[type]);\n\t__remove_dirty_inode(inode, type);\n\tspin_unlock(&sbi->inode_lock[type]);\n}\n\nint f2fs_sync_dirty_inodes(struct f2fs_sb_info *sbi, enum inode_type type,\n\t\t\t\t\t\tbool from_cp)\n{\n\tstruct list_head *head;\n\tstruct inode *inode;\n\tstruct f2fs_inode_info *fi;\n\tbool is_dir = (type == DIR_INODE);\n\tunsigned long ino = 0;\n\n\ttrace_f2fs_sync_dirty_inodes_enter(sbi->sb, is_dir,\n\t\t\t\tget_pages(sbi, is_dir ?\n\t\t\t\tF2FS_DIRTY_DENTS : F2FS_DIRTY_DATA));\nretry:\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\ttrace_f2fs_sync_dirty_inodes_exit(sbi->sb, is_dir,\n\t\t\t\tget_pages(sbi, is_dir ?\n\t\t\t\tF2FS_DIRTY_DENTS : F2FS_DIRTY_DATA));\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&sbi->inode_lock[type]);\n\n\thead = &sbi->inode_list[type];\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->inode_lock[type]);\n\t\ttrace_f2fs_sync_dirty_inodes_exit(sbi->sb, is_dir,\n\t\t\t\tget_pages(sbi, is_dir ?\n\t\t\t\tF2FS_DIRTY_DENTS : F2FS_DIRTY_DATA));\n\t\treturn 0;\n\t}\n\tfi = list_first_entry(head, struct f2fs_inode_info, dirty_list);\n\tinode = igrab(&fi->vfs_inode);\n\tspin_unlock(&sbi->inode_lock[type]);\n\tif (inode) {\n\t\tunsigned long cur_ino = inode->i_ino;\n\n\t\tif (from_cp)\n\t\t\tF2FS_I(inode)->cp_task = current;\n\t\tF2FS_I(inode)->wb_task = current;\n\n\t\tfilemap_fdatawrite(inode->i_mapping);\n\n\t\tF2FS_I(inode)->wb_task = NULL;\n\t\tif (from_cp)\n\t\t\tF2FS_I(inode)->cp_task = NULL;\n\n\t\tiput(inode);\n\t\t \n\t\tif (ino == cur_ino)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tino = cur_ino;\n\t} else {\n\t\t \n\t\tf2fs_submit_merged_write(sbi, DATA);\n\t\tcond_resched();\n\t}\n\tgoto retry;\n}\n\nstatic int f2fs_sync_inode_meta(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &sbi->inode_list[DIRTY_META];\n\tstruct inode *inode;\n\tstruct f2fs_inode_info *fi;\n\ts64 total = get_pages(sbi, F2FS_DIRTY_IMETA);\n\n\twhile (total--) {\n\t\tif (unlikely(f2fs_cp_error(sbi)))\n\t\t\treturn -EIO;\n\n\t\tspin_lock(&sbi->inode_lock[DIRTY_META]);\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n\t\t\treturn 0;\n\t\t}\n\t\tfi = list_first_entry(head, struct f2fs_inode_info,\n\t\t\t\t\t\t\tgdirty_list);\n\t\tinode = igrab(&fi->vfs_inode);\n\t\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n\t\tif (inode) {\n\t\t\tsync_inode_metadata(inode, 0);\n\n\t\t\t \n\t\t\tif (is_inode_flag_set(inode, FI_DIRTY_INODE))\n\t\t\t\tf2fs_update_inode_page(inode);\n\t\t\tiput(inode);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void __prepare_cp_block(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tnid_t last_nid = nm_i->next_scan_nid;\n\n\tnext_free_nid(sbi, &last_nid);\n\tckpt->valid_block_count = cpu_to_le64(valid_user_blocks(sbi));\n\tckpt->valid_node_count = cpu_to_le32(valid_node_count(sbi));\n\tckpt->valid_inode_count = cpu_to_le32(valid_inode_count(sbi));\n\tckpt->next_free_nid = cpu_to_le32(last_nid);\n}\n\nstatic bool __need_flush_quota(struct f2fs_sb_info *sbi)\n{\n\tbool ret = false;\n\n\tif (!is_journalled_quota(sbi))\n\t\treturn false;\n\n\tif (!f2fs_down_write_trylock(&sbi->quota_sem))\n\t\treturn true;\n\tif (is_sbi_flag_set(sbi, SBI_QUOTA_SKIP_FLUSH)) {\n\t\tret = false;\n\t} else if (is_sbi_flag_set(sbi, SBI_QUOTA_NEED_REPAIR)) {\n\t\tret = false;\n\t} else if (is_sbi_flag_set(sbi, SBI_QUOTA_NEED_FLUSH)) {\n\t\tclear_sbi_flag(sbi, SBI_QUOTA_NEED_FLUSH);\n\t\tret = true;\n\t} else if (get_pages(sbi, F2FS_DIRTY_QDATA)) {\n\t\tret = true;\n\t}\n\tf2fs_up_write(&sbi->quota_sem);\n\treturn ret;\n}\n\n \nstatic int block_operations(struct f2fs_sb_info *sbi)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\tint err = 0, cnt = 0;\n\n\t \n\tf2fs_flush_inline_data(sbi);\n\nretry_flush_quotas:\n\tf2fs_lock_all(sbi);\n\tif (__need_flush_quota(sbi)) {\n\t\tint locked;\n\n\t\tif (++cnt > DEFAULT_RETRY_QUOTA_FLUSH_COUNT) {\n\t\t\tset_sbi_flag(sbi, SBI_QUOTA_SKIP_FLUSH);\n\t\t\tset_sbi_flag(sbi, SBI_QUOTA_NEED_FLUSH);\n\t\t\tgoto retry_flush_dents;\n\t\t}\n\t\tf2fs_unlock_all(sbi);\n\n\t\t \n\t\tlocked = down_read_trylock(&sbi->sb->s_umount);\n\t\tf2fs_quota_sync(sbi->sb, -1);\n\t\tif (locked)\n\t\t\tup_read(&sbi->sb->s_umount);\n\t\tcond_resched();\n\t\tgoto retry_flush_quotas;\n\t}\n\nretry_flush_dents:\n\t \n\tif (get_pages(sbi, F2FS_DIRTY_DENTS)) {\n\t\tf2fs_unlock_all(sbi);\n\t\terr = f2fs_sync_dirty_inodes(sbi, DIR_INODE, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t\tgoto retry_flush_quotas;\n\t}\n\n\t \n\tf2fs_down_write(&sbi->node_change);\n\n\tif (get_pages(sbi, F2FS_DIRTY_IMETA)) {\n\t\tf2fs_up_write(&sbi->node_change);\n\t\tf2fs_unlock_all(sbi);\n\t\terr = f2fs_sync_inode_meta(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcond_resched();\n\t\tgoto retry_flush_quotas;\n\t}\n\nretry_flush_nodes:\n\tf2fs_down_write(&sbi->node_write);\n\n\tif (get_pages(sbi, F2FS_DIRTY_NODES)) {\n\t\tf2fs_up_write(&sbi->node_write);\n\t\tatomic_inc(&sbi->wb_sync_req[NODE]);\n\t\terr = f2fs_sync_node_pages(sbi, &wbc, false, FS_CP_NODE_IO);\n\t\tatomic_dec(&sbi->wb_sync_req[NODE]);\n\t\tif (err) {\n\t\t\tf2fs_up_write(&sbi->node_change);\n\t\t\tf2fs_unlock_all(sbi);\n\t\t\treturn err;\n\t\t}\n\t\tcond_resched();\n\t\tgoto retry_flush_nodes;\n\t}\n\n\t \n\t__prepare_cp_block(sbi);\n\tf2fs_up_write(&sbi->node_change);\n\treturn err;\n}\n\nstatic void unblock_operations(struct f2fs_sb_info *sbi)\n{\n\tf2fs_up_write(&sbi->node_write);\n\tf2fs_unlock_all(sbi);\n}\n\nvoid f2fs_wait_on_all_pages(struct f2fs_sb_info *sbi, int type)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tif (!get_pages(sbi, type))\n\t\t\tbreak;\n\n\t\tif (unlikely(f2fs_cp_error(sbi) &&\n\t\t\t!is_sbi_flag_set(sbi, SBI_IS_CLOSE)))\n\t\t\tbreak;\n\n\t\tif (type == F2FS_DIRTY_META)\n\t\t\tf2fs_sync_meta_pages(sbi, META, LONG_MAX,\n\t\t\t\t\t\t\tFS_CP_META_IO);\n\t\telse if (type == F2FS_WB_CP_DATA)\n\t\t\tf2fs_submit_merged_write(sbi, DATA);\n\n\t\tprepare_to_wait(&sbi->cp_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tio_schedule_timeout(DEFAULT_IO_TIMEOUT);\n\t}\n\tfinish_wait(&sbi->cp_wait, &wait);\n}\n\nstatic void update_ckpt_flags(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num;\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long flags;\n\n\tif (cpc->reason & CP_UMOUNT) {\n\t\tif (le32_to_cpu(ckpt->cp_pack_total_block_count) +\n\t\t\tNM_I(sbi)->nat_bits_blocks > sbi->blocks_per_seg) {\n\t\t\tclear_ckpt_flags(sbi, CP_NAT_BITS_FLAG);\n\t\t\tf2fs_notice(sbi, \"Disable nat_bits due to no space\");\n\t\t} else if (!is_set_ckpt_flags(sbi, CP_NAT_BITS_FLAG) &&\n\t\t\t\t\t\tf2fs_nat_bitmap_enabled(sbi)) {\n\t\t\tf2fs_enable_nat_bits(sbi);\n\t\t\tset_ckpt_flags(sbi, CP_NAT_BITS_FLAG);\n\t\t\tf2fs_notice(sbi, \"Rebuild and enable nat_bits\");\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&sbi->cp_lock, flags);\n\n\tif (cpc->reason & CP_TRIMMED)\n\t\t__set_ckpt_flags(ckpt, CP_TRIMMED_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_TRIMMED_FLAG);\n\n\tif (cpc->reason & CP_UMOUNT)\n\t\t__set_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);\n\n\tif (cpc->reason & CP_FASTBOOT)\n\t\t__set_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_FASTBOOT_FLAG);\n\n\tif (orphan_num)\n\t\t__set_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\t__set_ckpt_flags(ckpt, CP_FSCK_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_IS_RESIZEFS))\n\t\t__set_ckpt_flags(ckpt, CP_RESIZEFS_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_RESIZEFS_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_CP_DISABLED))\n\t\t__set_ckpt_flags(ckpt, CP_DISABLED_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_DISABLED_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_CP_DISABLED_QUICK))\n\t\t__set_ckpt_flags(ckpt, CP_DISABLED_QUICK_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_DISABLED_QUICK_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_QUOTA_SKIP_FLUSH))\n\t\t__set_ckpt_flags(ckpt, CP_QUOTA_NEED_FSCK_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_QUOTA_NEED_FSCK_FLAG);\n\n\tif (is_sbi_flag_set(sbi, SBI_QUOTA_NEED_REPAIR))\n\t\t__set_ckpt_flags(ckpt, CP_QUOTA_NEED_FSCK_FLAG);\n\n\t \n\t__set_ckpt_flags(ckpt, CP_CRC_RECOVERY_FLAG);\n\t__clear_ckpt_flags(ckpt, CP_NOCRC_RECOVERY_FLAG);\n\n\tspin_unlock_irqrestore(&sbi->cp_lock, flags);\n}\n\nstatic void commit_checkpoint(struct f2fs_sb_info *sbi,\n\tvoid *src, block_t blk_addr)\n{\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\t \n\tstruct page *page = f2fs_grab_meta_page(sbi, blk_addr);\n\tint err;\n\n\tf2fs_wait_on_page_writeback(page, META, true, true);\n\n\tmemcpy(page_address(page), src, PAGE_SIZE);\n\n\tset_page_dirty(page);\n\tif (unlikely(!clear_page_dirty_for_io(page)))\n\t\tf2fs_bug_on(sbi, 1);\n\n\t \n\terr = __f2fs_write_meta_page(page, &wbc, FS_CP_META_IO);\n\tif (unlikely(err && f2fs_cp_error(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn;\n\t}\n\n\tf2fs_bug_on(sbi, err);\n\tf2fs_put_page(page, 0);\n\n\t \n\tf2fs_submit_merged_write(sbi, META_FLUSH);\n}\n\nstatic inline u64 get_sectors_written(struct block_device *bdev)\n{\n\treturn (u64)part_stat_read(bdev, sectors[STAT_WRITE]);\n}\n\nu64 f2fs_get_sectors_written(struct f2fs_sb_info *sbi)\n{\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tu64 sectors = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < sbi->s_ndevs; i++)\n\t\t\tsectors += get_sectors_written(FDEV(i).bdev);\n\n\t\treturn sectors;\n\t}\n\n\treturn get_sectors_written(sbi->sb->s_bdev);\n}\n\nstatic int do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned long orphan_num = sbi->im[ORPHAN_INO].ino_num, flags;\n\tblock_t start_blk;\n\tunsigned int data_sum_blocks, orphan_blocks;\n\t__u32 crc32 = 0;\n\tint i;\n\tint cp_payload_blks = __cp_payload(sbi);\n\tstruct curseg_info *seg_i = CURSEG_I(sbi, CURSEG_HOT_NODE);\n\tu64 kbytes_written;\n\tint err;\n\n\t \n\tf2fs_sync_meta_pages(sbi, META, LONG_MAX, FS_CP_META_IO);\n\n\t \n\tckpt->elapsed_time = cpu_to_le64(get_mtime(sbi, true));\n\tckpt->free_segment_count = cpu_to_le32(free_segments(sbi));\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i + CURSEG_HOT_NODE);\n\n\t\tckpt->cur_node_segno[i] = cpu_to_le32(curseg->segno);\n\t\tckpt->cur_node_blkoff[i] = cpu_to_le16(curseg->next_blkoff);\n\t\tckpt->alloc_type[i + CURSEG_HOT_NODE] = curseg->alloc_type;\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i + CURSEG_HOT_DATA);\n\n\t\tckpt->cur_data_segno[i] = cpu_to_le32(curseg->segno);\n\t\tckpt->cur_data_blkoff[i] = cpu_to_le16(curseg->next_blkoff);\n\t\tckpt->alloc_type[i + CURSEG_HOT_DATA] = curseg->alloc_type;\n\t}\n\n\t \n\tdata_sum_blocks = f2fs_npages_for_summary_flush(sbi, false);\n\tspin_lock_irqsave(&sbi->cp_lock, flags);\n\tif (data_sum_blocks < NR_CURSEG_DATA_TYPE)\n\t\t__set_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\telse\n\t\t__clear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);\n\tspin_unlock_irqrestore(&sbi->cp_lock, flags);\n\n\torphan_blocks = GET_ORPHAN_BLOCKS(orphan_num);\n\tckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n\t\t\torphan_blocks);\n\n\tif (__remain_node_summaries(cpc->reason))\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks + NR_CURSEG_NODE_TYPE);\n\telse\n\t\tckpt->cp_pack_total_block_count = cpu_to_le32(F2FS_CP_PACKS +\n\t\t\t\tcp_payload_blks + data_sum_blocks +\n\t\t\t\torphan_blocks);\n\n\t \n\tupdate_ckpt_flags(sbi, cpc);\n\n\t \n\tget_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));\n\tget_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));\n\n\tcrc32 = f2fs_checkpoint_chksum(sbi, ckpt);\n\t*((__le32 *)((unsigned char *)ckpt +\n\t\t\t\tle32_to_cpu(ckpt->checksum_offset)))\n\t\t\t\t= cpu_to_le32(crc32);\n\n\tstart_blk = __start_cp_next_addr(sbi);\n\n\t \n\tif ((cpc->reason & CP_UMOUNT) &&\n\t\t\tis_set_ckpt_flags(sbi, CP_NAT_BITS_FLAG)) {\n\t\t__u64 cp_ver = cur_cp_version(ckpt);\n\t\tblock_t blk;\n\n\t\tcp_ver |= ((__u64)crc32 << 32);\n\t\t*(__le64 *)nm_i->nat_bits = cpu_to_le64(cp_ver);\n\n\t\tblk = start_blk + sbi->blocks_per_seg - nm_i->nat_bits_blocks;\n\t\tfor (i = 0; i < nm_i->nat_bits_blocks; i++)\n\t\t\tf2fs_update_meta_page(sbi, nm_i->nat_bits +\n\t\t\t\t\t(i << F2FS_BLKSIZE_BITS), blk + i);\n\t}\n\n\t \n\tf2fs_update_meta_page(sbi, ckpt, start_blk++);\n\n\tfor (i = 1; i < 1 + cp_payload_blks; i++)\n\t\tf2fs_update_meta_page(sbi, (char *)ckpt + i * F2FS_BLKSIZE,\n\t\t\t\t\t\t\tstart_blk++);\n\n\tif (orphan_num) {\n\t\twrite_orphan_inodes(sbi, start_blk);\n\t\tstart_blk += orphan_blocks;\n\t}\n\n\tf2fs_write_data_summaries(sbi, start_blk);\n\tstart_blk += data_sum_blocks;\n\n\t \n\tkbytes_written = sbi->kbytes_written;\n\tkbytes_written += (f2fs_get_sectors_written(sbi) -\n\t\t\t\tsbi->sectors_written_start) >> 1;\n\tseg_i->journal->info.kbytes_written = cpu_to_le64(kbytes_written);\n\n\tif (__remain_node_summaries(cpc->reason)) {\n\t\tf2fs_write_node_summaries(sbi, start_blk);\n\t\tstart_blk += NR_CURSEG_NODE_TYPE;\n\t}\n\n\t \n\tsbi->last_valid_block_count = sbi->total_valid_block_count;\n\tpercpu_counter_set(&sbi->alloc_valid_block_count, 0);\n\tpercpu_counter_set(&sbi->rf_node_block_count, 0);\n\n\t \n\tf2fs_sync_meta_pages(sbi, META, LONG_MAX, FS_CP_META_IO);\n\t \n\tf2fs_wait_on_all_pages(sbi, F2FS_DIRTY_META);\n\n\t \n\tf2fs_wait_on_all_pages(sbi, F2FS_WB_CP_DATA);\n\n\t \n\terr = f2fs_flush_device_cache(sbi);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcommit_checkpoint(sbi, ckpt, start_blk);\n\tf2fs_wait_on_all_pages(sbi, F2FS_WB_CP_DATA);\n\n\t \n\tif (f2fs_sb_has_encrypt(sbi) || f2fs_sb_has_verity(sbi) ||\n\t\tf2fs_sb_has_compression(sbi))\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi),\n\t\t\t\tMAIN_BLKADDR(sbi), MAX_BLKADDR(sbi) - 1);\n\n\tf2fs_release_ino_entry(sbi, false);\n\n\tf2fs_reset_fsync_node_info(sbi);\n\n\tclear_sbi_flag(sbi, SBI_IS_DIRTY);\n\tclear_sbi_flag(sbi, SBI_NEED_CP);\n\tclear_sbi_flag(sbi, SBI_QUOTA_SKIP_FLUSH);\n\n\tspin_lock(&sbi->stat_lock);\n\tsbi->unusable_block_count = 0;\n\tspin_unlock(&sbi->stat_lock);\n\n\t__set_cp_next_pack(sbi);\n\n\t \n\tif (get_pages(sbi, F2FS_DIRTY_NODES) ||\n\t\t\tget_pages(sbi, F2FS_DIRTY_IMETA))\n\t\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_bug_on(sbi, get_pages(sbi, F2FS_DIRTY_DENTS));\n\n\treturn unlikely(f2fs_cp_error(sbi)) ? -EIO : 0;\n}\n\nint f2fs_write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\tint err = 0;\n\n\tif (f2fs_readonly(sbi->sb) || f2fs_hw_is_readonly(sbi))\n\t\treturn -EROFS;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\tif (cpc->reason != CP_PAUSE)\n\t\t\treturn 0;\n\t\tf2fs_warn(sbi, \"Start checkpoint disabled!\");\n\t}\n\tif (cpc->reason != CP_RESIZE)\n\t\tf2fs_down_write(&sbi->cp_global_sem);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t((cpc->reason & CP_FASTBOOT) || (cpc->reason & CP_SYNC) ||\n\t\t((cpc->reason & CP_DISCARD) && !sbi->discard_blks)))\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\terr = block_operations(sbi);\n\tif (err)\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_flush_merged_writes(sbi);\n\n\t \n\tif (cpc->reason & CP_DISCARD) {\n\t\tif (!f2fs_exist_trim_candidates(sbi, cpc)) {\n\t\t\tunblock_operations(sbi);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (NM_I(sbi)->nat_cnt[DIRTY_NAT] == 0 &&\n\t\t\t\tSIT_I(sbi)->dirty_sentries == 0 &&\n\t\t\t\tprefree_segments(sbi) == 0) {\n\t\t\tf2fs_flush_sit_entries(sbi, cpc);\n\t\t\tf2fs_clear_prefree_segments(sbi, cpc);\n\t\t\tunblock_operations(sbi);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t \n\terr = f2fs_flush_nat_entries(sbi, cpc);\n\tif (err) {\n\t\tf2fs_err(sbi, \"f2fs_flush_nat_entries failed err:%d, stop checkpoint\", err);\n\t\tf2fs_bug_on(sbi, !f2fs_cp_error(sbi));\n\t\tgoto stop;\n\t}\n\n\tf2fs_flush_sit_entries(sbi, cpc);\n\n\t \n\tf2fs_save_inmem_curseg(sbi);\n\n\terr = do_checkpoint(sbi, cpc);\n\tif (err) {\n\t\tf2fs_err(sbi, \"do_checkpoint failed err:%d, stop checkpoint\", err);\n\t\tf2fs_bug_on(sbi, !f2fs_cp_error(sbi));\n\t\tf2fs_release_discard_addrs(sbi);\n\t} else {\n\t\tf2fs_clear_prefree_segments(sbi, cpc);\n\t}\n\n\tf2fs_restore_inmem_curseg(sbi);\n\tstat_inc_cp_count(sbi);\nstop:\n\tunblock_operations(sbi);\n\n\tif (cpc->reason & CP_RECOVERY)\n\t\tf2fs_notice(sbi, \"checkpoint: version = %llx\", ckpt_ver);\n\n\t \n\tf2fs_update_time(sbi, CP_TIME);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\nout:\n\tif (cpc->reason != CP_RESIZE)\n\t\tf2fs_up_write(&sbi->cp_global_sem);\n\treturn err;\n}\n\nvoid f2fs_init_ino_entry_info(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INO_ENTRY; i++) {\n\t\tstruct inode_management *im = &sbi->im[i];\n\n\t\tINIT_RADIX_TREE(&im->ino_root, GFP_ATOMIC);\n\t\tspin_lock_init(&im->ino_lock);\n\t\tINIT_LIST_HEAD(&im->ino_list);\n\t\tim->ino_num = 0;\n\t}\n\n\tsbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n\t\t\tNR_CURSEG_PERSIST_TYPE - __cp_payload(sbi)) *\n\t\t\t\tF2FS_ORPHANS_PER_BLOCK;\n}\n\nint __init f2fs_create_checkpoint_caches(void)\n{\n\tino_entry_slab = f2fs_kmem_cache_create(\"f2fs_ino_entry\",\n\t\t\tsizeof(struct ino_entry));\n\tif (!ino_entry_slab)\n\t\treturn -ENOMEM;\n\tf2fs_inode_entry_slab = f2fs_kmem_cache_create(\"f2fs_inode_entry\",\n\t\t\tsizeof(struct inode_entry));\n\tif (!f2fs_inode_entry_slab) {\n\t\tkmem_cache_destroy(ino_entry_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid f2fs_destroy_checkpoint_caches(void)\n{\n\tkmem_cache_destroy(ino_entry_slab);\n\tkmem_cache_destroy(f2fs_inode_entry_slab);\n}\n\nstatic int __write_checkpoint_sync(struct f2fs_sb_info *sbi)\n{\n\tstruct cp_control cpc = { .reason = CP_SYNC, };\n\tint err;\n\n\tf2fs_down_write(&sbi->gc_lock);\n\terr = f2fs_write_checkpoint(sbi, &cpc);\n\tf2fs_up_write(&sbi->gc_lock);\n\n\treturn err;\n}\n\nstatic void __checkpoint_and_complete_reqs(struct f2fs_sb_info *sbi)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\tstruct ckpt_req *req, *next;\n\tstruct llist_node *dispatch_list;\n\tu64 sum_diff = 0, diff, count = 0;\n\tint ret;\n\n\tdispatch_list = llist_del_all(&cprc->issue_list);\n\tif (!dispatch_list)\n\t\treturn;\n\tdispatch_list = llist_reverse_order(dispatch_list);\n\n\tret = __write_checkpoint_sync(sbi);\n\tatomic_inc(&cprc->issued_ckpt);\n\n\tllist_for_each_entry_safe(req, next, dispatch_list, llnode) {\n\t\tdiff = (u64)ktime_ms_delta(ktime_get(), req->queue_time);\n\t\treq->ret = ret;\n\t\tcomplete(&req->wait);\n\n\t\tsum_diff += diff;\n\t\tcount++;\n\t}\n\tatomic_sub(count, &cprc->queued_ckpt);\n\tatomic_add(count, &cprc->total_ckpt);\n\n\tspin_lock(&cprc->stat_lock);\n\tcprc->cur_time = (unsigned int)div64_u64(sum_diff, count);\n\tif (cprc->peak_time < cprc->cur_time)\n\t\tcprc->peak_time = cprc->cur_time;\n\tspin_unlock(&cprc->stat_lock);\n}\n\nstatic int issue_checkpoint_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\twait_queue_head_t *q = &cprc->ckpt_wait_queue;\nrepeat:\n\tif (kthread_should_stop())\n\t\treturn 0;\n\n\tif (!llist_empty(&cprc->issue_list))\n\t\t__checkpoint_and_complete_reqs(sbi);\n\n\twait_event_interruptible(*q,\n\t\tkthread_should_stop() || !llist_empty(&cprc->issue_list));\n\tgoto repeat;\n}\n\nstatic void flush_remained_ckpt_reqs(struct f2fs_sb_info *sbi,\n\t\tstruct ckpt_req *wait_req)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\n\tif (!llist_empty(&cprc->issue_list)) {\n\t\t__checkpoint_and_complete_reqs(sbi);\n\t} else {\n\t\t \n\t\tif (wait_req)\n\t\t\twait_for_completion(&wait_req->wait);\n\t}\n}\n\nstatic void init_ckpt_req(struct ckpt_req *req)\n{\n\tmemset(req, 0, sizeof(struct ckpt_req));\n\n\tinit_completion(&req->wait);\n\treq->queue_time = ktime_get();\n}\n\nint f2fs_issue_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\tstruct ckpt_req req;\n\tstruct cp_control cpc;\n\n\tcpc.reason = __get_cp_reason(sbi);\n\tif (!test_opt(sbi, MERGE_CHECKPOINT) || cpc.reason != CP_SYNC) {\n\t\tint ret;\n\n\t\tf2fs_down_write(&sbi->gc_lock);\n\t\tret = f2fs_write_checkpoint(sbi, &cpc);\n\t\tf2fs_up_write(&sbi->gc_lock);\n\n\t\treturn ret;\n\t}\n\n\tif (!cprc->f2fs_issue_ckpt)\n\t\treturn __write_checkpoint_sync(sbi);\n\n\tinit_ckpt_req(&req);\n\n\tllist_add(&req.llnode, &cprc->issue_list);\n\tatomic_inc(&cprc->queued_ckpt);\n\n\t \n\tsmp_mb();\n\n\tif (waitqueue_active(&cprc->ckpt_wait_queue))\n\t\twake_up(&cprc->ckpt_wait_queue);\n\n\tif (cprc->f2fs_issue_ckpt)\n\t\twait_for_completion(&req.wait);\n\telse\n\t\tflush_remained_ckpt_reqs(sbi, &req);\n\n\treturn req.ret;\n}\n\nint f2fs_start_ckpt_thread(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\n\tif (cprc->f2fs_issue_ckpt)\n\t\treturn 0;\n\n\tcprc->f2fs_issue_ckpt = kthread_run(issue_checkpoint_thread, sbi,\n\t\t\t\"f2fs_ckpt-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(cprc->f2fs_issue_ckpt)) {\n\t\tint err = PTR_ERR(cprc->f2fs_issue_ckpt);\n\n\t\tcprc->f2fs_issue_ckpt = NULL;\n\t\treturn err;\n\t}\n\n\tset_task_ioprio(cprc->f2fs_issue_ckpt, cprc->ckpt_thread_ioprio);\n\n\treturn 0;\n}\n\nvoid f2fs_stop_ckpt_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\tstruct task_struct *ckpt_task;\n\n\tif (!cprc->f2fs_issue_ckpt)\n\t\treturn;\n\n\tckpt_task = cprc->f2fs_issue_ckpt;\n\tcprc->f2fs_issue_ckpt = NULL;\n\tkthread_stop(ckpt_task);\n\n\tf2fs_flush_ckpt_thread(sbi);\n}\n\nvoid f2fs_flush_ckpt_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\n\tflush_remained_ckpt_reqs(sbi, NULL);\n\n\t \n\twhile (atomic_read(&cprc->queued_ckpt))\n\t\tio_schedule_timeout(DEFAULT_IO_TIMEOUT);\n}\n\nvoid f2fs_init_ckpt_req_control(struct f2fs_sb_info *sbi)\n{\n\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\n\tatomic_set(&cprc->issued_ckpt, 0);\n\tatomic_set(&cprc->total_ckpt, 0);\n\tatomic_set(&cprc->queued_ckpt, 0);\n\tcprc->ckpt_thread_ioprio = DEFAULT_CHECKPOINT_IOPRIO;\n\tinit_waitqueue_head(&cprc->ckpt_wait_queue);\n\tinit_llist_head(&cprc->issue_list);\n\tspin_lock_init(&cprc->stat_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}