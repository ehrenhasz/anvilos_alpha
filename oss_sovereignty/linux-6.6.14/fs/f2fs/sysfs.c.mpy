{
  "module_name": "sysfs.c",
  "hash_id": "81bf9bf15eb7cdc85c55f37d92979e73f6bccd593f1cdf8736f3be4e021e89d7",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/sysfs.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/proc_fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/seq_file.h>\n#include <linux/unicode.h>\n#include <linux/ioprio.h>\n#include <linux/sysfs.h>\n\n#include \"f2fs.h\"\n#include \"segment.h\"\n#include \"gc.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n\nstatic struct proc_dir_entry *f2fs_proc_root;\n\n \nenum {\n\tGC_THREAD,\t \n\tSM_INFO,\t \n\tDCC_INFO,\t \n\tNM_INFO,\t \n\tF2FS_SBI,\t \n#ifdef CONFIG_F2FS_STAT_FS\n\tSTAT_INFO,\t \n#endif\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tFAULT_INFO_RATE,\t \n\tFAULT_INFO_TYPE,\t \n#endif\n\tRESERVED_BLOCKS,\t \n\tCPRC_INFO,\t \n\tATGC_INFO,\t \n};\n\nstatic const char *gc_mode_names[MAX_GC_MODE] = {\n\t\"GC_NORMAL\",\n\t\"GC_IDLE_CB\",\n\t\"GC_IDLE_GREEDY\",\n\t\"GC_IDLE_AT\",\n\t\"GC_URGENT_HIGH\",\n\t\"GC_URGENT_LOW\",\n\t\"GC_URGENT_MID\"\n};\n\nstruct f2fs_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct f2fs_attr *a, struct f2fs_sb_info *sbi, char *buf);\n\tssize_t (*store)(struct f2fs_attr *a, struct f2fs_sb_info *sbi,\n\t\t\t const char *buf, size_t len);\n\tint struct_type;\n\tint offset;\n\tint id;\n};\n\nstatic ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\t     struct f2fs_sb_info *sbi, char *buf);\n\nstatic unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)\n{\n\tif (struct_type == GC_THREAD)\n\t\treturn (unsigned char *)sbi->gc_thread;\n\telse if (struct_type == SM_INFO)\n\t\treturn (unsigned char *)SM_I(sbi);\n\telse if (struct_type == DCC_INFO)\n\t\treturn (unsigned char *)SM_I(sbi)->dcc_info;\n\telse if (struct_type == NM_INFO)\n\t\treturn (unsigned char *)NM_I(sbi);\n\telse if (struct_type == F2FS_SBI || struct_type == RESERVED_BLOCKS)\n\t\treturn (unsigned char *)sbi;\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\telse if (struct_type == FAULT_INFO_RATE ||\n\t\t\t\t\tstruct_type == FAULT_INFO_TYPE)\n\t\treturn (unsigned char *)&F2FS_OPTION(sbi).fault_info;\n#endif\n#ifdef CONFIG_F2FS_STAT_FS\n\telse if (struct_type == STAT_INFO)\n\t\treturn (unsigned char *)F2FS_STAT(sbi);\n#endif\n\telse if (struct_type == CPRC_INFO)\n\t\treturn (unsigned char *)&sbi->cprc_info;\n\telse if (struct_type == ATGC_INFO)\n\t\treturn (unsigned char *)&sbi->am;\n\treturn NULL;\n}\n\nstatic ssize_t dirty_segments_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)(dirty_segments(sbi)));\n}\n\nstatic ssize_t free_segments_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)(free_segments(sbi)));\n}\n\nstatic ssize_t ovp_segments_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)(overprovision_segments(sbi)));\n}\n\nstatic ssize_t lifetime_write_kbytes_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)(sbi->kbytes_written +\n\t\t\t((f2fs_get_sectors_written(sbi) -\n\t\t\t\tsbi->sectors_written_start) >> 1)));\n}\n\nstatic ssize_t sb_status_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%lx\\n\", sbi->s_flag);\n}\n\nstatic ssize_t cp_status_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%x\\n\", le32_to_cpu(F2FS_CKPT(sbi)->ckpt_flags));\n}\n\nstatic ssize_t pending_discard_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tif (!SM_I(sbi)->dcc_info)\n\t\treturn -EINVAL;\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)atomic_read(\n\t\t\t\t&SM_I(sbi)->dcc_info->discard_cmd_cnt));\n}\n\nstatic ssize_t gc_mode_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", gc_mode_names[sbi->gc_mode]);\n}\n\nstatic ssize_t features_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tint len = 0;\n\n\tif (f2fs_sb_has_encrypt(sbi))\n\t\tlen += scnprintf(buf, PAGE_SIZE - len, \"%s\",\n\t\t\t\t\t\t\"encryption\");\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"blkzoned\");\n\tif (f2fs_sb_has_extra_attr(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"extra_attr\");\n\tif (f2fs_sb_has_project_quota(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"projquota\");\n\tif (f2fs_sb_has_inode_chksum(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"inode_checksum\");\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"flexible_inline_xattr\");\n\tif (f2fs_sb_has_quota_ino(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"quota_ino\");\n\tif (f2fs_sb_has_inode_crtime(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"inode_crtime\");\n\tif (f2fs_sb_has_lost_found(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"lost_found\");\n\tif (f2fs_sb_has_verity(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"verity\");\n\tif (f2fs_sb_has_sb_chksum(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"sb_checksum\");\n\tif (f2fs_sb_has_casefold(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"casefold\");\n\tif (f2fs_sb_has_readonly(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"readonly\");\n\tif (f2fs_sb_has_compression(sbi))\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"compression\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s%s\",\n\t\t\t\tlen ? \", \" : \"\", \"pin_file\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t current_reserved_blocks_show(struct f2fs_attr *a,\n\t\t\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", sbi->current_reserved_blocks);\n}\n\nstatic ssize_t unusable_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tblock_t unusable;\n\n\tif (test_opt(sbi, DISABLE_CHECKPOINT))\n\t\tunusable = sbi->unusable_block_count;\n\telse\n\t\tunusable = f2fs_get_unusable_blocks(sbi);\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)unusable);\n}\n\nstatic ssize_t encoding_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n#if IS_ENABLED(CONFIG_UNICODE)\n\tstruct super_block *sb = sbi->sb;\n\n\tif (f2fs_sb_has_casefold(sbi))\n\t\treturn sysfs_emit(buf, \"UTF-8 (%d.%d.%d)\\n\",\n\t\t\t(sb->s_encoding->version >> 16) & 0xff,\n\t\t\t(sb->s_encoding->version >> 8) & 0xff,\n\t\t\tsb->s_encoding->version & 0xff);\n#endif\n\treturn sysfs_emit(buf, \"(none)\\n\");\n}\n\nstatic ssize_t mounted_time_sec_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\", SIT_I(sbi)->mounted_time);\n}\n\n#ifdef CONFIG_F2FS_STAT_FS\nstatic ssize_t moved_blocks_foreground_show(struct f2fs_attr *a,\n\t\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t(unsigned long long)(si->tot_blks -\n\t\t\t(si->bg_data_blks + si->bg_node_blks)));\n}\n\nstatic ssize_t moved_blocks_background_show(struct f2fs_attr *a,\n\t\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t(unsigned long long)(si->bg_data_blks + si->bg_node_blks));\n}\n\nstatic ssize_t avg_vblocks_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\n\tsi->dirty_count = dirty_segments(sbi);\n\tf2fs_update_sit_info(sbi);\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)(si->avg_vblocks));\n}\n#endif\n\nstatic ssize_t main_blkaddr_show(struct f2fs_attr *a,\n\t\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t(unsigned long long)MAIN_BLKADDR(sbi));\n}\n\nstatic ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(a->attr.name, \"extension_list\")) {\n\t\t__u8 (*extlist)[F2FS_EXTENSION_LEN] =\n\t\t\t\t\tsbi->raw_super->extension_list;\n\t\tint cold_count = le32_to_cpu(sbi->raw_super->extension_count);\n\t\tint hot_count = sbi->raw_super->hot_ext_count;\n\t\tint len = 0, i;\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\t\"cold file extension:\\n\");\n\t\tfor (i = 0; i < cold_count; i++)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s\\n\",\n\t\t\t\t\t\t\t\textlist[i]);\n\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\t\"hot file extension:\\n\");\n\t\tfor (i = cold_count; i < cold_count + hot_count; i++)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%s\\n\",\n\t\t\t\t\t\t\t\textlist[i]);\n\t\treturn len;\n\t}\n\n\tif (!strcmp(a->attr.name, \"ckpt_thread_ioprio\")) {\n\t\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\t\tint class = IOPRIO_PRIO_CLASS(cprc->ckpt_thread_ioprio);\n\t\tint data = IOPRIO_PRIO_DATA(cprc->ckpt_thread_ioprio);\n\n\t\tif (class != IOPRIO_CLASS_RT && class != IOPRIO_CLASS_BE)\n\t\t\treturn -EINVAL;\n\n\t\treturn sysfs_emit(buf, \"%s,%d\\n\",\n\t\t\tclass == IOPRIO_CLASS_RT ? \"rt\" : \"be\", data);\n\t}\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (!strcmp(a->attr.name, \"compr_written_block\"))\n\t\treturn sysfs_emit(buf, \"%llu\\n\", sbi->compr_written_block);\n\n\tif (!strcmp(a->attr.name, \"compr_saved_block\"))\n\t\treturn sysfs_emit(buf, \"%llu\\n\", sbi->compr_saved_block);\n\n\tif (!strcmp(a->attr.name, \"compr_new_inode\"))\n\t\treturn sysfs_emit(buf, \"%u\\n\", sbi->compr_new_inode);\n#endif\n\n\tif (!strcmp(a->attr.name, \"gc_segment_mode\"))\n\t\treturn sysfs_emit(buf, \"%u\\n\", sbi->gc_segment_mode);\n\n\tif (!strcmp(a->attr.name, \"gc_reclaimed_segments\")) {\n\t\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tsbi->gc_reclaimed_segs[sbi->gc_segment_mode]);\n\t}\n\n\tif (!strcmp(a->attr.name, \"current_atomic_write\")) {\n\t\ts64 current_write = atomic64_read(&sbi->current_atomic_write);\n\n\t\treturn sysfs_emit(buf, \"%lld\\n\", current_write);\n\t}\n\n\tif (!strcmp(a->attr.name, \"peak_atomic_write\"))\n\t\treturn sysfs_emit(buf, \"%lld\\n\", sbi->peak_atomic_write);\n\n\tif (!strcmp(a->attr.name, \"committed_atomic_block\"))\n\t\treturn sysfs_emit(buf, \"%llu\\n\", sbi->committed_atomic_block);\n\n\tif (!strcmp(a->attr.name, \"revoked_atomic_block\"))\n\t\treturn sysfs_emit(buf, \"%llu\\n\", sbi->revoked_atomic_block);\n\n#ifdef CONFIG_F2FS_STAT_FS\n\tif (!strcmp(a->attr.name, \"cp_foreground_calls\"))\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t\tatomic_read(&sbi->cp_call_count[TOTAL_CALL]) -\n\t\t\t\tatomic_read(&sbi->cp_call_count[BACKGROUND]));\n\tif (!strcmp(a->attr.name, \"cp_background_calls\"))\n\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t\tatomic_read(&sbi->cp_call_count[BACKGROUND]));\n#endif\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\treturn sysfs_emit(buf, \"%u\\n\", *ui);\n}\n\nstatic ssize_t __sbi_store(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi,\n\t\t\tconst char *buf, size_t count)\n{\n\tunsigned char *ptr;\n\tunsigned long t;\n\tunsigned int *ui;\n\tssize_t ret;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(a->attr.name, \"extension_list\")) {\n\t\tconst char *name = strim((char *)buf);\n\t\tbool set = true, hot;\n\n\t\tif (!strncmp(name, \"[h]\", 3))\n\t\t\thot = true;\n\t\telse if (!strncmp(name, \"[c]\", 3))\n\t\t\thot = false;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tname += 3;\n\n\t\tif (*name == '!') {\n\t\t\tname++;\n\t\t\tset = false;\n\t\t}\n\n\t\tif (!strlen(name) || strlen(name) >= F2FS_EXTENSION_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tf2fs_down_write(&sbi->sb_lock);\n\n\t\tret = f2fs_update_extension_list(sbi, name, hot, set);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = f2fs_commit_super(sbi, false);\n\t\tif (ret)\n\t\t\tf2fs_update_extension_list(sbi, name, hot, !set);\nout:\n\t\tf2fs_up_write(&sbi->sb_lock);\n\t\treturn ret ? ret : count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"ckpt_thread_ioprio\")) {\n\t\tconst char *name = strim((char *)buf);\n\t\tstruct ckpt_req_control *cprc = &sbi->cprc_info;\n\t\tint class;\n\t\tlong data;\n\t\tint ret;\n\n\t\tif (!strncmp(name, \"rt,\", 3))\n\t\t\tclass = IOPRIO_CLASS_RT;\n\t\telse if (!strncmp(name, \"be,\", 3))\n\t\t\tclass = IOPRIO_CLASS_BE;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tname += 3;\n\t\tret = kstrtol(name, 10, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (data >= IOPRIO_NR_LEVELS || data < 0)\n\t\t\treturn -EINVAL;\n\n\t\tcprc->ckpt_thread_ioprio = IOPRIO_PRIO_VALUE(class, data);\n\t\tif (test_opt(sbi, MERGE_CHECKPOINT)) {\n\t\t\tret = set_task_ioprio(cprc->f2fs_issue_ckpt,\n\t\t\t\t\tcprc->ckpt_thread_ioprio);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\tret = kstrtoul(skip_spaces(buf), 0, &t);\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tif (a->struct_type == FAULT_INFO_TYPE && t >= BIT(FAULT_MAX))\n\t\treturn -EINVAL;\n\tif (a->struct_type == FAULT_INFO_RATE && t >= UINT_MAX)\n\t\treturn -EINVAL;\n#endif\n\tif (a->struct_type == RESERVED_BLOCKS) {\n\t\tspin_lock(&sbi->stat_lock);\n\t\tif (t > (unsigned long)(sbi->user_block_count -\n\t\t\t\tF2FS_OPTION(sbi).root_reserved_blocks -\n\t\t\t\tsbi->blocks_per_seg *\n\t\t\t\tSM_I(sbi)->additional_reserved_segments)) {\n\t\t\tspin_unlock(&sbi->stat_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*ui = t;\n\t\tsbi->current_reserved_blocks = min(sbi->reserved_blocks,\n\t\t\t\tsbi->user_block_count - valid_user_blocks(sbi));\n\t\tspin_unlock(&sbi->stat_lock);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"discard_io_aware_gran\")) {\n\t\tif (t > MAX_PLIST_NUM)\n\t\t\treturn -EINVAL;\n\t\tif (!f2fs_block_unit_discard(sbi))\n\t\t\treturn -EINVAL;\n\t\tif (t == *ui)\n\t\t\treturn count;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"discard_granularity\")) {\n\t\tif (t == 0 || t > MAX_PLIST_NUM)\n\t\t\treturn -EINVAL;\n\t\tif (!f2fs_block_unit_discard(sbi))\n\t\t\treturn -EINVAL;\n\t\tif (t == *ui)\n\t\t\treturn count;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"max_ordered_discard\")) {\n\t\tif (t == 0 || t > MAX_PLIST_NUM)\n\t\t\treturn -EINVAL;\n\t\tif (!f2fs_block_unit_discard(sbi))\n\t\t\treturn -EINVAL;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"discard_urgent_util\")) {\n\t\tif (t > 100)\n\t\t\treturn -EINVAL;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"migration_granularity\")) {\n\t\tif (t == 0 || t > sbi->segs_per_sec)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(a->attr.name, \"gc_urgent\")) {\n\t\tif (t == 0) {\n\t\t\tsbi->gc_mode = GC_NORMAL;\n\t\t} else if (t == 1) {\n\t\t\tsbi->gc_mode = GC_URGENT_HIGH;\n\t\t\tif (sbi->gc_thread) {\n\t\t\t\tsbi->gc_thread->gc_wake = true;\n\t\t\t\twake_up_interruptible_all(\n\t\t\t\t\t&sbi->gc_thread->gc_wait_queue_head);\n\t\t\t\twake_up_discard_thread(sbi, true);\n\t\t\t}\n\t\t} else if (t == 2) {\n\t\t\tsbi->gc_mode = GC_URGENT_LOW;\n\t\t} else if (t == 3) {\n\t\t\tsbi->gc_mode = GC_URGENT_MID;\n\t\t\tif (sbi->gc_thread) {\n\t\t\t\tsbi->gc_thread->gc_wake = true;\n\t\t\t\twake_up_interruptible_all(\n\t\t\t\t\t&sbi->gc_thread->gc_wait_queue_head);\n\t\t\t}\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn count;\n\t}\n\tif (!strcmp(a->attr.name, \"gc_idle\")) {\n\t\tif (t == GC_IDLE_CB) {\n\t\t\tsbi->gc_mode = GC_IDLE_CB;\n\t\t} else if (t == GC_IDLE_GREEDY) {\n\t\t\tsbi->gc_mode = GC_IDLE_GREEDY;\n\t\t} else if (t == GC_IDLE_AT) {\n\t\t\tif (!sbi->am.atgc_enabled)\n\t\t\t\treturn -EINVAL;\n\t\t\tsbi->gc_mode = GC_IDLE_AT;\n\t\t} else {\n\t\t\tsbi->gc_mode = GC_NORMAL;\n\t\t}\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"gc_remaining_trials\")) {\n\t\tspin_lock(&sbi->gc_remaining_trials_lock);\n\t\tsbi->gc_remaining_trials = t;\n\t\tspin_unlock(&sbi->gc_remaining_trials_lock);\n\n\t\treturn count;\n\t}\n\n#ifdef CONFIG_F2FS_IOSTAT\n\tif (!strcmp(a->attr.name, \"iostat_enable\")) {\n\t\tsbi->iostat_enable = !!t;\n\t\tif (!sbi->iostat_enable)\n\t\t\tf2fs_reset_iostat(sbi);\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"iostat_period_ms\")) {\n\t\tif (t < MIN_IOSTAT_PERIOD_MS || t > MAX_IOSTAT_PERIOD_MS)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_irq(&sbi->iostat_lock);\n\t\tsbi->iostat_period_ms = (unsigned int)t;\n\t\tspin_unlock_irq(&sbi->iostat_lock);\n\t\treturn count;\n\t}\n#endif\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (!strcmp(a->attr.name, \"compr_written_block\") ||\n\t\t!strcmp(a->attr.name, \"compr_saved_block\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->compr_written_block = 0;\n\t\tsbi->compr_saved_block = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"compr_new_inode\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->compr_new_inode = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"compress_percent\")) {\n\t\tif (t == 0 || t > 100)\n\t\t\treturn -EINVAL;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"compress_watermark\")) {\n\t\tif (t == 0 || t > 100)\n\t\t\treturn -EINVAL;\n\t\t*ui = t;\n\t\treturn count;\n\t}\n#endif\n\n\tif (!strcmp(a->attr.name, \"atgc_candidate_ratio\")) {\n\t\tif (t > 100)\n\t\t\treturn -EINVAL;\n\t\tsbi->am.candidate_ratio = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"atgc_age_weight\")) {\n\t\tif (t > 100)\n\t\t\treturn -EINVAL;\n\t\tsbi->am.age_weight = t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"gc_segment_mode\")) {\n\t\tif (t < MAX_GC_MODE)\n\t\t\tsbi->gc_segment_mode = t;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"gc_reclaimed_segments\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->gc_reclaimed_segs[sbi->gc_segment_mode] = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"seq_file_ra_mul\")) {\n\t\tif (t >= MIN_RA_MUL && t <= MAX_RA_MUL)\n\t\t\tsbi->seq_file_ra_mul = t;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"max_fragment_chunk\")) {\n\t\tif (t >= MIN_FRAGMENT_SIZE && t <= MAX_FRAGMENT_SIZE)\n\t\t\tsbi->max_fragment_chunk = t;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"max_fragment_hole\")) {\n\t\tif (t >= MIN_FRAGMENT_SIZE && t <= MAX_FRAGMENT_SIZE)\n\t\t\tsbi->max_fragment_hole = t;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"peak_atomic_write\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->peak_atomic_write = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"committed_atomic_block\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->committed_atomic_block = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"revoked_atomic_block\")) {\n\t\tif (t != 0)\n\t\t\treturn -EINVAL;\n\t\tsbi->revoked_atomic_block = 0;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"readdir_ra\")) {\n\t\tsbi->readdir_ra = !!t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"hot_data_age_threshold\")) {\n\t\tif (t == 0 || t >= sbi->warm_data_age_threshold)\n\t\t\treturn -EINVAL;\n\t\tif (t == *ui)\n\t\t\treturn count;\n\t\t*ui = (unsigned int)t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"warm_data_age_threshold\")) {\n\t\tif (t <= sbi->hot_data_age_threshold)\n\t\t\treturn -EINVAL;\n\t\tif (t == *ui)\n\t\t\treturn count;\n\t\t*ui = (unsigned int)t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"last_age_weight\")) {\n\t\tif (t > 100)\n\t\t\treturn -EINVAL;\n\t\tif (t == *ui)\n\t\t\treturn count;\n\t\t*ui = (unsigned int)t;\n\t\treturn count;\n\t}\n\n\tif (!strcmp(a->attr.name, \"ipu_policy\")) {\n\t\tif (t >= BIT(F2FS_IPU_MAX))\n\t\t\treturn -EINVAL;\n\t\tif (t && f2fs_lfs_mode(sbi))\n\t\t\treturn -EINVAL;\n\t\tSM_I(sbi)->ipu_policy = (unsigned int)t;\n\t\treturn count;\n\t}\n\n\t*ui = (unsigned int)t;\n\n\treturn count;\n}\n\nstatic ssize_t f2fs_sbi_store(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi,\n\t\t\tconst char *buf, size_t count)\n{\n\tssize_t ret;\n\tbool gc_entry = (!strcmp(a->attr.name, \"gc_urgent\") ||\n\t\t\t\t\ta->struct_type == GC_THREAD);\n\n\tif (gc_entry) {\n\t\tif (!down_read_trylock(&sbi->sb->s_umount))\n\t\t\treturn -EAGAIN;\n\t}\n\tret = __sbi_store(a, sbi, buf, count);\n\tif (gc_entry)\n\t\tup_read(&sbi->sb->s_umount);\n\n\treturn ret;\n}\n\nstatic ssize_t f2fs_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}\n\nstatic ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}\n\nstatic void f2fs_sb_release(struct kobject *kobj)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tcomplete(&sbi->s_kobj_unregister);\n}\n\n \nstatic ssize_t f2fs_feature_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\treturn sysfs_emit(buf, \"supported\\n\");\n}\n\n#define F2FS_FEATURE_RO_ATTR(_name)\t\t\t\t\\\nstatic struct f2fs_attr f2fs_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = 0444 },\t\\\n\t.show\t= f2fs_feature_show,\t\t\t\t\\\n}\n\nstatic ssize_t f2fs_sb_feature_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tif (F2FS_HAS_FEATURE(sbi, a->id))\n\t\treturn sysfs_emit(buf, \"supported\\n\");\n\treturn sysfs_emit(buf, \"unsupported\\n\");\n}\n\n#define F2FS_SB_FEATURE_RO_ATTR(_name, _feat)\t\t\t\\\nstatic struct f2fs_attr f2fs_attr_sb_##_name = {\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = 0444 },\t\\\n\t.show\t= f2fs_sb_feature_show,\t\t\t\t\\\n\t.id\t= F2FS_FEATURE_##_feat,\t\t\t\t\\\n}\n\n#define F2FS_ATTR_OFFSET(_struct_type, _name, _mode, _show, _store, _offset) \\\nstatic struct f2fs_attr f2fs_attr_##_name = {\t\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n\t.struct_type = _struct_type,\t\t\t\t\\\n\t.offset = _offset\t\t\t\t\t\\\n}\n\n#define F2FS_RO_ATTR(struct_type, struct_name, name, elname)\t\\\n\tF2FS_ATTR_OFFSET(struct_type, name, 0444,\t\t\\\n\t\tf2fs_sbi_show, NULL,\t\t\t\t\\\n\t\toffsetof(struct struct_name, elname))\n\n#define F2FS_RW_ATTR(struct_type, struct_name, name, elname)\t\\\n\tF2FS_ATTR_OFFSET(struct_type, name, 0644,\t\t\\\n\t\tf2fs_sbi_show, f2fs_sbi_store,\t\t\t\\\n\t\toffsetof(struct struct_name, elname))\n\n#define F2FS_GENERAL_RO_ATTR(name) \\\nstatic struct f2fs_attr f2fs_attr_##name = __ATTR(name, 0444, name##_show, NULL)\n\n#ifdef CONFIG_F2FS_STAT_FS\n#define STAT_INFO_RO_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RO_ATTR(STAT_INFO, f2fs_stat_info, name, elname)\n#endif\n\n#define GC_THREAD_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(GC_THREAD, f2fs_gc_kthread, name, elname)\n\n#define SM_INFO_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(SM_INFO, f2fs_sm_info, name, elname)\n\n#define SM_INFO_GENERAL_RW_ATTR(elname)\t\t\t\t\\\n\tSM_INFO_RW_ATTR(elname, elname)\n\n#define DCC_INFO_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(DCC_INFO, discard_cmd_control, name, elname)\n\n#define DCC_INFO_GENERAL_RW_ATTR(elname)\t\t\t\\\n\tDCC_INFO_RW_ATTR(elname, elname)\n\n#define NM_INFO_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(NM_INFO, f2fs_nm_info, name, elname)\n\n#define NM_INFO_GENERAL_RW_ATTR(elname)\t\t\t\t\\\n\tNM_INFO_RW_ATTR(elname, elname)\n\n#define F2FS_SBI_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(F2FS_SBI, f2fs_sb_info, name, elname)\n\n#define F2FS_SBI_GENERAL_RW_ATTR(elname)\t\t\t\\\n\tF2FS_SBI_RW_ATTR(elname, elname)\n\n#define F2FS_SBI_GENERAL_RO_ATTR(elname)\t\t\t\\\n\tF2FS_RO_ATTR(F2FS_SBI, f2fs_sb_info, elname, elname)\n\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n#define FAULT_INFO_GENERAL_RW_ATTR(type, elname)\t\t\\\n\tF2FS_RW_ATTR(type, f2fs_fault_info, elname, elname)\n#endif\n\n#define RESERVED_BLOCKS_GENERAL_RW_ATTR(elname)\t\t\t\\\n\tF2FS_RW_ATTR(RESERVED_BLOCKS, f2fs_sb_info, elname, elname)\n\n#define CPRC_INFO_GENERAL_RW_ATTR(elname)\t\t\t\\\n\tF2FS_RW_ATTR(CPRC_INFO, ckpt_req_control, elname, elname)\n\n#define ATGC_INFO_RW_ATTR(name, elname)\t\t\t\t\\\n\tF2FS_RW_ATTR(ATGC_INFO, atgc_management, name, elname)\n\n \nGC_THREAD_RW_ATTR(gc_urgent_sleep_time, urgent_sleep_time);\nGC_THREAD_RW_ATTR(gc_min_sleep_time, min_sleep_time);\nGC_THREAD_RW_ATTR(gc_max_sleep_time, max_sleep_time);\nGC_THREAD_RW_ATTR(gc_no_gc_sleep_time, no_gc_sleep_time);\n\n \nSM_INFO_RW_ATTR(reclaim_segments, rec_prefree_segments);\nSM_INFO_GENERAL_RW_ATTR(ipu_policy);\nSM_INFO_GENERAL_RW_ATTR(min_ipu_util);\nSM_INFO_GENERAL_RW_ATTR(min_fsync_blocks);\nSM_INFO_GENERAL_RW_ATTR(min_seq_blocks);\nSM_INFO_GENERAL_RW_ATTR(min_hot_blocks);\nSM_INFO_GENERAL_RW_ATTR(min_ssr_sections);\n\n \nDCC_INFO_RW_ATTR(max_small_discards, max_discards);\nDCC_INFO_GENERAL_RW_ATTR(max_discard_request);\nDCC_INFO_GENERAL_RW_ATTR(min_discard_issue_time);\nDCC_INFO_GENERAL_RW_ATTR(mid_discard_issue_time);\nDCC_INFO_GENERAL_RW_ATTR(max_discard_issue_time);\nDCC_INFO_GENERAL_RW_ATTR(discard_io_aware_gran);\nDCC_INFO_GENERAL_RW_ATTR(discard_urgent_util);\nDCC_INFO_GENERAL_RW_ATTR(discard_granularity);\nDCC_INFO_GENERAL_RW_ATTR(max_ordered_discard);\n\n \nNM_INFO_RW_ATTR(max_roll_forward_node_blocks, max_rf_node_blocks);\nNM_INFO_GENERAL_RW_ATTR(ram_thresh);\nNM_INFO_GENERAL_RW_ATTR(ra_nid_pages);\nNM_INFO_GENERAL_RW_ATTR(dirty_nats_ratio);\n\n \nF2FS_RW_ATTR(F2FS_SBI, f2fs_super_block, extension_list, extension_list);\nF2FS_SBI_RW_ATTR(gc_idle, gc_mode);\nF2FS_SBI_RW_ATTR(gc_urgent, gc_mode);\nF2FS_SBI_RW_ATTR(cp_interval, interval_time[CP_TIME]);\nF2FS_SBI_RW_ATTR(idle_interval, interval_time[REQ_TIME]);\nF2FS_SBI_RW_ATTR(discard_idle_interval, interval_time[DISCARD_TIME]);\nF2FS_SBI_RW_ATTR(gc_idle_interval, interval_time[GC_TIME]);\nF2FS_SBI_RW_ATTR(umount_discard_timeout, interval_time[UMOUNT_DISCARD_TIMEOUT]);\nF2FS_SBI_RW_ATTR(gc_pin_file_thresh, gc_pin_file_threshold);\nF2FS_SBI_RW_ATTR(gc_reclaimed_segments, gc_reclaimed_segs);\nF2FS_SBI_GENERAL_RW_ATTR(max_victim_search);\nF2FS_SBI_GENERAL_RW_ATTR(migration_granularity);\nF2FS_SBI_GENERAL_RW_ATTR(dir_level);\n#ifdef CONFIG_F2FS_IOSTAT\nF2FS_SBI_GENERAL_RW_ATTR(iostat_enable);\nF2FS_SBI_GENERAL_RW_ATTR(iostat_period_ms);\n#endif\nF2FS_SBI_GENERAL_RW_ATTR(readdir_ra);\nF2FS_SBI_GENERAL_RW_ATTR(max_io_bytes);\nF2FS_SBI_GENERAL_RW_ATTR(data_io_flag);\nF2FS_SBI_GENERAL_RW_ATTR(node_io_flag);\nF2FS_SBI_GENERAL_RW_ATTR(gc_remaining_trials);\nF2FS_SBI_GENERAL_RW_ATTR(seq_file_ra_mul);\nF2FS_SBI_GENERAL_RW_ATTR(gc_segment_mode);\nF2FS_SBI_GENERAL_RW_ATTR(max_fragment_chunk);\nF2FS_SBI_GENERAL_RW_ATTR(max_fragment_hole);\n#ifdef CONFIG_F2FS_FS_COMPRESSION\nF2FS_SBI_GENERAL_RW_ATTR(compr_written_block);\nF2FS_SBI_GENERAL_RW_ATTR(compr_saved_block);\nF2FS_SBI_GENERAL_RW_ATTR(compr_new_inode);\nF2FS_SBI_GENERAL_RW_ATTR(compress_percent);\nF2FS_SBI_GENERAL_RW_ATTR(compress_watermark);\n#endif\n \nF2FS_SBI_GENERAL_RO_ATTR(current_atomic_write);\nF2FS_SBI_GENERAL_RW_ATTR(peak_atomic_write);\nF2FS_SBI_GENERAL_RW_ATTR(committed_atomic_block);\nF2FS_SBI_GENERAL_RW_ATTR(revoked_atomic_block);\n \nF2FS_SBI_GENERAL_RW_ATTR(hot_data_age_threshold);\nF2FS_SBI_GENERAL_RW_ATTR(warm_data_age_threshold);\nF2FS_SBI_GENERAL_RW_ATTR(last_age_weight);\n#ifdef CONFIG_BLK_DEV_ZONED\nF2FS_SBI_GENERAL_RO_ATTR(unusable_blocks_per_sec);\n#endif\n\n \n#ifdef CONFIG_F2FS_STAT_FS\nSTAT_INFO_RO_ATTR(cp_foreground_calls, cp_call_count[FOREGROUND]);\nSTAT_INFO_RO_ATTR(cp_background_calls, cp_call_count[BACKGROUND]);\nSTAT_INFO_RO_ATTR(gc_foreground_calls, gc_call_count[FOREGROUND]);\nSTAT_INFO_RO_ATTR(gc_background_calls, gc_call_count[BACKGROUND]);\n#endif\n\n \n#ifdef CONFIG_F2FS_FAULT_INJECTION\nFAULT_INFO_GENERAL_RW_ATTR(FAULT_INFO_RATE, inject_rate);\nFAULT_INFO_GENERAL_RW_ATTR(FAULT_INFO_TYPE, inject_type);\n#endif\n\n \nRESERVED_BLOCKS_GENERAL_RW_ATTR(reserved_blocks);\n\n \nCPRC_INFO_GENERAL_RW_ATTR(ckpt_thread_ioprio);\n\n \nATGC_INFO_RW_ATTR(atgc_candidate_ratio, candidate_ratio);\nATGC_INFO_RW_ATTR(atgc_candidate_count, max_candidate_count);\nATGC_INFO_RW_ATTR(atgc_age_weight, age_weight);\nATGC_INFO_RW_ATTR(atgc_age_threshold, age_threshold);\n\nF2FS_GENERAL_RO_ATTR(dirty_segments);\nF2FS_GENERAL_RO_ATTR(free_segments);\nF2FS_GENERAL_RO_ATTR(ovp_segments);\nF2FS_GENERAL_RO_ATTR(lifetime_write_kbytes);\nF2FS_GENERAL_RO_ATTR(features);\nF2FS_GENERAL_RO_ATTR(current_reserved_blocks);\nF2FS_GENERAL_RO_ATTR(unusable);\nF2FS_GENERAL_RO_ATTR(encoding);\nF2FS_GENERAL_RO_ATTR(mounted_time_sec);\nF2FS_GENERAL_RO_ATTR(main_blkaddr);\nF2FS_GENERAL_RO_ATTR(pending_discard);\nF2FS_GENERAL_RO_ATTR(gc_mode);\n#ifdef CONFIG_F2FS_STAT_FS\nF2FS_GENERAL_RO_ATTR(moved_blocks_background);\nF2FS_GENERAL_RO_ATTR(moved_blocks_foreground);\nF2FS_GENERAL_RO_ATTR(avg_vblocks);\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\nF2FS_FEATURE_RO_ATTR(encryption);\nF2FS_FEATURE_RO_ATTR(test_dummy_encryption_v2);\n#if IS_ENABLED(CONFIG_UNICODE)\nF2FS_FEATURE_RO_ATTR(encrypted_casefold);\n#endif\n#endif  \n#ifdef CONFIG_BLK_DEV_ZONED\nF2FS_FEATURE_RO_ATTR(block_zoned);\n#endif\nF2FS_FEATURE_RO_ATTR(atomic_write);\nF2FS_FEATURE_RO_ATTR(extra_attr);\nF2FS_FEATURE_RO_ATTR(project_quota);\nF2FS_FEATURE_RO_ATTR(inode_checksum);\nF2FS_FEATURE_RO_ATTR(flexible_inline_xattr);\nF2FS_FEATURE_RO_ATTR(quota_ino);\nF2FS_FEATURE_RO_ATTR(inode_crtime);\nF2FS_FEATURE_RO_ATTR(lost_found);\n#ifdef CONFIG_FS_VERITY\nF2FS_FEATURE_RO_ATTR(verity);\n#endif\nF2FS_FEATURE_RO_ATTR(sb_checksum);\n#if IS_ENABLED(CONFIG_UNICODE)\nF2FS_FEATURE_RO_ATTR(casefold);\n#endif\nF2FS_FEATURE_RO_ATTR(readonly);\n#ifdef CONFIG_F2FS_FS_COMPRESSION\nF2FS_FEATURE_RO_ATTR(compression);\n#endif\nF2FS_FEATURE_RO_ATTR(pin_file);\n\n#define ATTR_LIST(name) (&f2fs_attr_##name.attr)\nstatic struct attribute *f2fs_attrs[] = {\n\tATTR_LIST(gc_urgent_sleep_time),\n\tATTR_LIST(gc_min_sleep_time),\n\tATTR_LIST(gc_max_sleep_time),\n\tATTR_LIST(gc_no_gc_sleep_time),\n\tATTR_LIST(gc_idle),\n\tATTR_LIST(gc_urgent),\n\tATTR_LIST(reclaim_segments),\n\tATTR_LIST(main_blkaddr),\n\tATTR_LIST(max_small_discards),\n\tATTR_LIST(max_discard_request),\n\tATTR_LIST(min_discard_issue_time),\n\tATTR_LIST(mid_discard_issue_time),\n\tATTR_LIST(max_discard_issue_time),\n\tATTR_LIST(discard_io_aware_gran),\n\tATTR_LIST(discard_urgent_util),\n\tATTR_LIST(discard_granularity),\n\tATTR_LIST(max_ordered_discard),\n\tATTR_LIST(pending_discard),\n\tATTR_LIST(gc_mode),\n\tATTR_LIST(ipu_policy),\n\tATTR_LIST(min_ipu_util),\n\tATTR_LIST(min_fsync_blocks),\n\tATTR_LIST(min_seq_blocks),\n\tATTR_LIST(min_hot_blocks),\n\tATTR_LIST(min_ssr_sections),\n\tATTR_LIST(max_victim_search),\n\tATTR_LIST(migration_granularity),\n\tATTR_LIST(dir_level),\n\tATTR_LIST(ram_thresh),\n\tATTR_LIST(ra_nid_pages),\n\tATTR_LIST(dirty_nats_ratio),\n\tATTR_LIST(max_roll_forward_node_blocks),\n\tATTR_LIST(cp_interval),\n\tATTR_LIST(idle_interval),\n\tATTR_LIST(discard_idle_interval),\n\tATTR_LIST(gc_idle_interval),\n\tATTR_LIST(umount_discard_timeout),\n#ifdef CONFIG_F2FS_IOSTAT\n\tATTR_LIST(iostat_enable),\n\tATTR_LIST(iostat_period_ms),\n#endif\n\tATTR_LIST(readdir_ra),\n\tATTR_LIST(max_io_bytes),\n\tATTR_LIST(gc_pin_file_thresh),\n\tATTR_LIST(extension_list),\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tATTR_LIST(inject_rate),\n\tATTR_LIST(inject_type),\n#endif\n\tATTR_LIST(data_io_flag),\n\tATTR_LIST(node_io_flag),\n\tATTR_LIST(gc_remaining_trials),\n\tATTR_LIST(ckpt_thread_ioprio),\n\tATTR_LIST(dirty_segments),\n\tATTR_LIST(free_segments),\n\tATTR_LIST(ovp_segments),\n\tATTR_LIST(unusable),\n\tATTR_LIST(lifetime_write_kbytes),\n\tATTR_LIST(features),\n\tATTR_LIST(reserved_blocks),\n\tATTR_LIST(current_reserved_blocks),\n\tATTR_LIST(encoding),\n\tATTR_LIST(mounted_time_sec),\n#ifdef CONFIG_F2FS_STAT_FS\n\tATTR_LIST(cp_foreground_calls),\n\tATTR_LIST(cp_background_calls),\n\tATTR_LIST(gc_foreground_calls),\n\tATTR_LIST(gc_background_calls),\n\tATTR_LIST(moved_blocks_foreground),\n\tATTR_LIST(moved_blocks_background),\n\tATTR_LIST(avg_vblocks),\n#endif\n#ifdef CONFIG_BLK_DEV_ZONED\n\tATTR_LIST(unusable_blocks_per_sec),\n#endif\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tATTR_LIST(compr_written_block),\n\tATTR_LIST(compr_saved_block),\n\tATTR_LIST(compr_new_inode),\n\tATTR_LIST(compress_percent),\n\tATTR_LIST(compress_watermark),\n#endif\n\t \n\tATTR_LIST(atgc_candidate_ratio),\n\tATTR_LIST(atgc_candidate_count),\n\tATTR_LIST(atgc_age_weight),\n\tATTR_LIST(atgc_age_threshold),\n\tATTR_LIST(seq_file_ra_mul),\n\tATTR_LIST(gc_segment_mode),\n\tATTR_LIST(gc_reclaimed_segments),\n\tATTR_LIST(max_fragment_chunk),\n\tATTR_LIST(max_fragment_hole),\n\tATTR_LIST(current_atomic_write),\n\tATTR_LIST(peak_atomic_write),\n\tATTR_LIST(committed_atomic_block),\n\tATTR_LIST(revoked_atomic_block),\n\tATTR_LIST(hot_data_age_threshold),\n\tATTR_LIST(warm_data_age_threshold),\n\tATTR_LIST(last_age_weight),\n\tNULL,\n};\nATTRIBUTE_GROUPS(f2fs);\n\nstatic struct attribute *f2fs_feat_attrs[] = {\n#ifdef CONFIG_FS_ENCRYPTION\n\tATTR_LIST(encryption),\n\tATTR_LIST(test_dummy_encryption_v2),\n#if IS_ENABLED(CONFIG_UNICODE)\n\tATTR_LIST(encrypted_casefold),\n#endif\n#endif  \n#ifdef CONFIG_BLK_DEV_ZONED\n\tATTR_LIST(block_zoned),\n#endif\n\tATTR_LIST(atomic_write),\n\tATTR_LIST(extra_attr),\n\tATTR_LIST(project_quota),\n\tATTR_LIST(inode_checksum),\n\tATTR_LIST(flexible_inline_xattr),\n\tATTR_LIST(quota_ino),\n\tATTR_LIST(inode_crtime),\n\tATTR_LIST(lost_found),\n#ifdef CONFIG_FS_VERITY\n\tATTR_LIST(verity),\n#endif\n\tATTR_LIST(sb_checksum),\n#if IS_ENABLED(CONFIG_UNICODE)\n\tATTR_LIST(casefold),\n#endif\n\tATTR_LIST(readonly),\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tATTR_LIST(compression),\n#endif\n\tATTR_LIST(pin_file),\n\tNULL,\n};\nATTRIBUTE_GROUPS(f2fs_feat);\n\nF2FS_GENERAL_RO_ATTR(sb_status);\nF2FS_GENERAL_RO_ATTR(cp_status);\nstatic struct attribute *f2fs_stat_attrs[] = {\n\tATTR_LIST(sb_status),\n\tATTR_LIST(cp_status),\n\tNULL,\n};\nATTRIBUTE_GROUPS(f2fs_stat);\n\nF2FS_SB_FEATURE_RO_ATTR(encryption, ENCRYPT);\nF2FS_SB_FEATURE_RO_ATTR(block_zoned, BLKZONED);\nF2FS_SB_FEATURE_RO_ATTR(extra_attr, EXTRA_ATTR);\nF2FS_SB_FEATURE_RO_ATTR(project_quota, PRJQUOTA);\nF2FS_SB_FEATURE_RO_ATTR(inode_checksum, INODE_CHKSUM);\nF2FS_SB_FEATURE_RO_ATTR(flexible_inline_xattr, FLEXIBLE_INLINE_XATTR);\nF2FS_SB_FEATURE_RO_ATTR(quota_ino, QUOTA_INO);\nF2FS_SB_FEATURE_RO_ATTR(inode_crtime, INODE_CRTIME);\nF2FS_SB_FEATURE_RO_ATTR(lost_found, LOST_FOUND);\nF2FS_SB_FEATURE_RO_ATTR(verity, VERITY);\nF2FS_SB_FEATURE_RO_ATTR(sb_checksum, SB_CHKSUM);\nF2FS_SB_FEATURE_RO_ATTR(casefold, CASEFOLD);\nF2FS_SB_FEATURE_RO_ATTR(compression, COMPRESSION);\nF2FS_SB_FEATURE_RO_ATTR(readonly, RO);\n\nstatic struct attribute *f2fs_sb_feat_attrs[] = {\n\tATTR_LIST(sb_encryption),\n\tATTR_LIST(sb_block_zoned),\n\tATTR_LIST(sb_extra_attr),\n\tATTR_LIST(sb_project_quota),\n\tATTR_LIST(sb_inode_checksum),\n\tATTR_LIST(sb_flexible_inline_xattr),\n\tATTR_LIST(sb_quota_ino),\n\tATTR_LIST(sb_inode_crtime),\n\tATTR_LIST(sb_lost_found),\n\tATTR_LIST(sb_verity),\n\tATTR_LIST(sb_sb_checksum),\n\tATTR_LIST(sb_casefold),\n\tATTR_LIST(sb_compression),\n\tATTR_LIST(sb_readonly),\n\tNULL,\n};\nATTRIBUTE_GROUPS(f2fs_sb_feat);\n\nstatic const struct sysfs_ops f2fs_attr_ops = {\n\t.show\t= f2fs_attr_show,\n\t.store\t= f2fs_attr_store,\n};\n\nstatic const struct kobj_type f2fs_sb_ktype = {\n\t.default_groups = f2fs_groups,\n\t.sysfs_ops\t= &f2fs_attr_ops,\n\t.release\t= f2fs_sb_release,\n};\n\nstatic const struct kobj_type f2fs_ktype = {\n\t.sysfs_ops\t= &f2fs_attr_ops,\n};\n\nstatic struct kset f2fs_kset = {\n\t.kobj\t= {.ktype = &f2fs_ktype},\n};\n\nstatic const struct kobj_type f2fs_feat_ktype = {\n\t.default_groups = f2fs_feat_groups,\n\t.sysfs_ops\t= &f2fs_attr_ops,\n};\n\nstatic struct kobject f2fs_feat = {\n\t.kset\t= &f2fs_kset,\n};\n\nstatic ssize_t f2fs_stat_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_stat_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}\n\nstatic ssize_t f2fs_stat_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_stat_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}\n\nstatic void f2fs_stat_kobj_release(struct kobject *kobj)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_stat_kobj);\n\tcomplete(&sbi->s_stat_kobj_unregister);\n}\n\nstatic const struct sysfs_ops f2fs_stat_attr_ops = {\n\t.show\t= f2fs_stat_attr_show,\n\t.store\t= f2fs_stat_attr_store,\n};\n\nstatic const struct kobj_type f2fs_stat_ktype = {\n\t.default_groups = f2fs_stat_groups,\n\t.sysfs_ops\t= &f2fs_stat_attr_ops,\n\t.release\t= f2fs_stat_kobj_release,\n};\n\nstatic ssize_t f2fs_sb_feat_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\ts_feature_list_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}\n\nstatic void f2fs_feature_list_kobj_release(struct kobject *kobj)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\ts_feature_list_kobj);\n\tcomplete(&sbi->s_feature_list_kobj_unregister);\n}\n\nstatic const struct sysfs_ops f2fs_feature_list_attr_ops = {\n\t.show\t= f2fs_sb_feat_attr_show,\n};\n\nstatic const struct kobj_type f2fs_feature_list_ktype = {\n\t.default_groups = f2fs_sb_feat_groups,\n\t.sysfs_ops\t= &f2fs_feature_list_attr_ops,\n\t.release\t= f2fs_feature_list_kobj_release,\n};\n\nstatic int __maybe_unused segment_info_seq_show(struct seq_file *seq,\n\t\t\t\t\t\tvoid *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tif ((i % 10) == 0)\n\t\t\tseq_printf(seq, \"%-10d\", i);\n\t\tseq_printf(seq, \"%d|%-3u\", se->type, se->valid_blocks);\n\t\tif ((i % 10) == 9 || i == (total_segs - 1))\n\t\t\tseq_putc(seq, '\\n');\n\t\telse\n\t\t\tseq_putc(seq, ' ');\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused segment_bits_seq_show(struct seq_file *seq,\n\t\t\t\t\t\tvoid *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i, j;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks|bitmaps\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tseq_printf(seq, \"%-10d\", i);\n\t\tseq_printf(seq, \"%d|%-3u|\", se->type, se->valid_blocks);\n\t\tfor (j = 0; j < SIT_VBLOCK_MAP_SIZE; j++)\n\t\t\tseq_printf(seq, \" %.2x\", se->cur_valid_map[j]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused victim_bits_seq_show(struct seq_file *seq,\n\t\t\t\t\t\tvoid *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tseq_puts(seq, \"format: victim_secmap bitmaps\\n\");\n\n\tfor (i = 0; i < MAIN_SECS(sbi); i++) {\n\t\tif ((i % 10) == 0)\n\t\t\tseq_printf(seq, \"%-10d\", i);\n\t\tseq_printf(seq, \"%d\", test_bit(i, dirty_i->victim_secmap) ? 1 : 0);\n\t\tif ((i % 10) == 9 || i == (MAIN_SECS(sbi) - 1))\n\t\t\tseq_putc(seq, '\\n');\n\t\telse\n\t\t\tseq_putc(seq, ' ');\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused discard_plist_seq_show(struct seq_file *seq,\n\t\t\t\t\t\tvoid *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tint i, count;\n\n\tseq_puts(seq, \"Discard pend list(Show diacrd_cmd count on each entry, .:not exist):\\n\");\n\tif (!f2fs_realtime_discard_enable(sbi))\n\t\treturn 0;\n\n\tif (dcc) {\n\t\tmutex_lock(&dcc->cmd_lock);\n\t\tfor (i = 0; i < MAX_PLIST_NUM; i++) {\n\t\t\tstruct list_head *pend_list;\n\t\t\tstruct discard_cmd *dc, *tmp;\n\n\t\t\tif (i % 8 == 0)\n\t\t\t\tseq_printf(seq, \"  %-3d\", i);\n\t\t\tcount = 0;\n\t\t\tpend_list = &dcc->pend_list[i];\n\t\t\tlist_for_each_entry_safe(dc, tmp, pend_list, list)\n\t\t\t\tcount++;\n\t\t\tif (count)\n\t\t\t\tseq_printf(seq, \" %7d\", count);\n\t\t\telse\n\t\t\t\tseq_puts(seq, \"       .\");\n\t\t\tif (i % 8 == 7)\n\t\t\t\tseq_putc(seq, '\\n');\n\t\t}\n\t\tseq_putc(seq, '\\n');\n\t\tmutex_unlock(&dcc->cmd_lock);\n\t}\n\n\treturn 0;\n}\n\nint __init f2fs_init_sysfs(void)\n{\n\tint ret;\n\n\tkobject_set_name(&f2fs_kset.kobj, \"f2fs\");\n\tf2fs_kset.kobj.parent = fs_kobj;\n\tret = kset_register(&f2fs_kset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kobject_init_and_add(&f2fs_feat, &f2fs_feat_ktype,\n\t\t\t\t   NULL, \"features\");\n\tif (ret)\n\t\tgoto put_kobject;\n\n\tf2fs_proc_root = proc_mkdir(\"fs/f2fs\", NULL);\n\tif (!f2fs_proc_root) {\n\t\tret = -ENOMEM;\n\t\tgoto put_kobject;\n\t}\n\n\treturn 0;\nput_kobject:\n\tkobject_put(&f2fs_feat);\n\tkset_unregister(&f2fs_kset);\n\treturn ret;\n}\n\nvoid f2fs_exit_sysfs(void)\n{\n\tkobject_put(&f2fs_feat);\n\tkset_unregister(&f2fs_kset);\n\tremove_proc_entry(\"fs/f2fs\", NULL);\n\tf2fs_proc_root = NULL;\n}\n\nint f2fs_register_sysfs(struct f2fs_sb_info *sbi)\n{\n\tstruct super_block *sb = sbi->sb;\n\tint err;\n\n\tsbi->s_kobj.kset = &f2fs_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &f2fs_sb_ktype, NULL,\n\t\t\t\t\"%s\", sb->s_id);\n\tif (err)\n\t\tgoto put_sb_kobj;\n\n\tsbi->s_stat_kobj.kset = &f2fs_kset;\n\tinit_completion(&sbi->s_stat_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_stat_kobj, &f2fs_stat_ktype,\n\t\t\t\t\t\t&sbi->s_kobj, \"stat\");\n\tif (err)\n\t\tgoto put_stat_kobj;\n\n\tsbi->s_feature_list_kobj.kset = &f2fs_kset;\n\tinit_completion(&sbi->s_feature_list_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_feature_list_kobj,\n\t\t\t\t\t&f2fs_feature_list_ktype,\n\t\t\t\t\t&sbi->s_kobj, \"feature_list\");\n\tif (err)\n\t\tgoto put_feature_list_kobj;\n\n\tsbi->s_proc = proc_mkdir(sb->s_id, f2fs_proc_root);\n\tif (!sbi->s_proc) {\n\t\terr = -ENOMEM;\n\t\tgoto put_feature_list_kobj;\n\t}\n\n\tproc_create_single_data(\"segment_info\", 0444, sbi->s_proc,\n\t\t\t\tsegment_info_seq_show, sb);\n\tproc_create_single_data(\"segment_bits\", 0444, sbi->s_proc,\n\t\t\t\tsegment_bits_seq_show, sb);\n#ifdef CONFIG_F2FS_IOSTAT\n\tproc_create_single_data(\"iostat_info\", 0444, sbi->s_proc,\n\t\t\t\tiostat_info_seq_show, sb);\n#endif\n\tproc_create_single_data(\"victim_bits\", 0444, sbi->s_proc,\n\t\t\t\tvictim_bits_seq_show, sb);\n\tproc_create_single_data(\"discard_plist_info\", 0444, sbi->s_proc,\n\t\t\t\tdiscard_plist_seq_show, sb);\n\treturn 0;\nput_feature_list_kobj:\n\tkobject_put(&sbi->s_feature_list_kobj);\n\twait_for_completion(&sbi->s_feature_list_kobj_unregister);\nput_stat_kobj:\n\tkobject_put(&sbi->s_stat_kobj);\n\twait_for_completion(&sbi->s_stat_kobj_unregister);\nput_sb_kobj:\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\treturn err;\n}\n\nvoid f2fs_unregister_sysfs(struct f2fs_sb_info *sbi)\n{\n\tremove_proc_subtree(sbi->sb->s_id, f2fs_proc_root);\n\n\tkobject_put(&sbi->s_stat_kobj);\n\twait_for_completion(&sbi->s_stat_kobj_unregister);\n\tkobject_put(&sbi->s_feature_list_kobj);\n\twait_for_completion(&sbi->s_feature_list_kobj_unregister);\n\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}