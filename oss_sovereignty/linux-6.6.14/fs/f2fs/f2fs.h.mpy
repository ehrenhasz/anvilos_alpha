{
  "module_name": "f2fs.h",
  "hash_id": "e7606cfaa9678b8ea09b3f99ef02e51fc24ef6fd8b6793505b82dcf0fe90503d",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/f2fs.h",
  "human_readable_source": " \n \n#ifndef _LINUX_F2FS_H\n#define _LINUX_F2FS_H\n\n#include <linux/uio.h>\n#include <linux/types.h>\n#include <linux/page-flags.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/magic.h>\n#include <linux/kobject.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/sched/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/part_stat.h>\n#include <crypto/hash.h>\n\n#include <linux/fscrypt.h>\n#include <linux/fsverity.h>\n\nstruct pagevec;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n#define f2fs_bug_on(sbi, condition)\tBUG_ON(condition)\n#else\n#define f2fs_bug_on(sbi, condition)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (WARN_ON(condition))\t\t\t\t\t\\\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\t\t\\\n\t} while (0)\n#endif\n\nenum {\n\tFAULT_KMALLOC,\n\tFAULT_KVMALLOC,\n\tFAULT_PAGE_ALLOC,\n\tFAULT_PAGE_GET,\n\tFAULT_ALLOC_BIO,\t \n\tFAULT_ALLOC_NID,\n\tFAULT_ORPHAN,\n\tFAULT_BLOCK,\n\tFAULT_DIR_DEPTH,\n\tFAULT_EVICT_INODE,\n\tFAULT_TRUNCATE,\n\tFAULT_READ_IO,\n\tFAULT_CHECKPOINT,\n\tFAULT_DISCARD,\n\tFAULT_WRITE_IO,\n\tFAULT_SLAB_ALLOC,\n\tFAULT_DQUOT_INIT,\n\tFAULT_LOCK_OP,\n\tFAULT_BLKADDR,\n\tFAULT_MAX,\n};\n\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n#define F2FS_ALL_FAULT_TYPE\t\t(GENMASK(FAULT_MAX - 1, 0))\n\nstruct f2fs_fault_info {\n\tatomic_t inject_ops;\n\tunsigned int inject_rate;\n\tunsigned int inject_type;\n};\n\nextern const char *f2fs_fault_name[FAULT_MAX];\n#define IS_FAULT_SET(fi, type) ((fi)->inject_type & BIT(type))\n#endif\n\n \n#define F2FS_MOUNT_DISABLE_ROLL_FORWARD\t0x00000001\n#define F2FS_MOUNT_DISCARD\t\t0x00000002\n#define F2FS_MOUNT_NOHEAP\t\t0x00000004\n#define F2FS_MOUNT_XATTR_USER\t\t0x00000008\n#define F2FS_MOUNT_POSIX_ACL\t\t0x00000010\n#define F2FS_MOUNT_DISABLE_EXT_IDENTIFY\t0x00000020\n#define F2FS_MOUNT_INLINE_XATTR\t\t0x00000040\n#define F2FS_MOUNT_INLINE_DATA\t\t0x00000080\n#define F2FS_MOUNT_INLINE_DENTRY\t0x00000100\n#define F2FS_MOUNT_FLUSH_MERGE\t\t0x00000200\n#define F2FS_MOUNT_NOBARRIER\t\t0x00000400\n#define F2FS_MOUNT_FASTBOOT\t\t0x00000800\n#define F2FS_MOUNT_READ_EXTENT_CACHE\t0x00001000\n#define F2FS_MOUNT_DATA_FLUSH\t\t0x00002000\n#define F2FS_MOUNT_FAULT_INJECTION\t0x00004000\n#define F2FS_MOUNT_USRQUOTA\t\t0x00008000\n#define F2FS_MOUNT_GRPQUOTA\t\t0x00010000\n#define F2FS_MOUNT_PRJQUOTA\t\t0x00020000\n#define F2FS_MOUNT_QUOTA\t\t0x00040000\n#define F2FS_MOUNT_INLINE_XATTR_SIZE\t0x00080000\n#define F2FS_MOUNT_RESERVE_ROOT\t\t0x00100000\n#define F2FS_MOUNT_DISABLE_CHECKPOINT\t0x00200000\n#define F2FS_MOUNT_NORECOVERY\t\t0x00400000\n#define F2FS_MOUNT_ATGC\t\t\t0x00800000\n#define F2FS_MOUNT_MERGE_CHECKPOINT\t0x01000000\n#define\tF2FS_MOUNT_GC_MERGE\t\t0x02000000\n#define F2FS_MOUNT_COMPRESS_CACHE\t0x04000000\n#define F2FS_MOUNT_AGE_EXTENT_CACHE\t0x08000000\n\n#define F2FS_OPTION(sbi)\t((sbi)->mount_opt)\n#define clear_opt(sbi, option)\t(F2FS_OPTION(sbi).opt &= ~F2FS_MOUNT_##option)\n#define set_opt(sbi, option)\t(F2FS_OPTION(sbi).opt |= F2FS_MOUNT_##option)\n#define test_opt(sbi, option)\t(F2FS_OPTION(sbi).opt & F2FS_MOUNT_##option)\n\n#define ver_after(a, b)\t(typecheck(unsigned long long, a) &&\t\t\\\n\t\ttypecheck(unsigned long long, b) &&\t\t\t\\\n\t\t((long long)((a) - (b)) > 0))\n\ntypedef u32 block_t;\t \ntypedef u32 nid_t;\n\n#define COMPRESS_EXT_NUM\t\t16\n\n \n\nstruct f2fs_rwsem {\n        struct rw_semaphore internal_rwsem;\n#ifdef CONFIG_F2FS_UNFAIR_RWSEM\n        wait_queue_head_t read_waiters;\n#endif\n};\n\nstruct f2fs_mount_info {\n\tunsigned int opt;\n\tint write_io_size_bits;\t\t \n\tblock_t root_reserved_blocks;\t \n\tkuid_t s_resuid;\t\t \n\tkgid_t s_resgid;\t\t \n\tint active_logs;\t\t \n\tint inline_xattr_size;\t\t \n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tstruct f2fs_fault_info fault_info;\t \n#endif\n#ifdef CONFIG_QUOTA\n\t \n\tchar *s_qf_names[MAXQUOTAS];\n\tint s_jquota_fmt;\t\t\t \n#endif\n\t \n\tint alloc_mode;\t\t\t \n\tint fsync_mode;\t\t\t \n\tint fs_mode;\t\t\t \n\tint bggc_mode;\t\t\t \n\tint memory_mode;\t\t \n\tint errors;\t\t\t \n\tint discard_unit;\t\t \n\tstruct fscrypt_dummy_policy dummy_enc_policy;  \n\tblock_t unusable_cap_perc;\t \n\tblock_t unusable_cap;\t\t \n\n\t \n\tunsigned char compress_algorithm;\t \n\tunsigned char compress_log_size;\t \n\tunsigned char compress_level;\t\t \n\tbool compress_chksum;\t\t\t \n\tunsigned char compress_ext_cnt;\t\t \n\tunsigned char nocompress_ext_cnt;\t\t \n\tint compress_mode;\t\t\t \n\tunsigned char extensions[COMPRESS_EXT_NUM][F2FS_EXTENSION_LEN];\t \n\tunsigned char noextensions[COMPRESS_EXT_NUM][F2FS_EXTENSION_LEN];  \n};\n\n#define F2FS_FEATURE_ENCRYPT\t\t\t0x00000001\n#define F2FS_FEATURE_BLKZONED\t\t\t0x00000002\n#define F2FS_FEATURE_ATOMIC_WRITE\t\t0x00000004\n#define F2FS_FEATURE_EXTRA_ATTR\t\t\t0x00000008\n#define F2FS_FEATURE_PRJQUOTA\t\t\t0x00000010\n#define F2FS_FEATURE_INODE_CHKSUM\t\t0x00000020\n#define F2FS_FEATURE_FLEXIBLE_INLINE_XATTR\t0x00000040\n#define F2FS_FEATURE_QUOTA_INO\t\t\t0x00000080\n#define F2FS_FEATURE_INODE_CRTIME\t\t0x00000100\n#define F2FS_FEATURE_LOST_FOUND\t\t\t0x00000200\n#define F2FS_FEATURE_VERITY\t\t\t0x00000400\n#define F2FS_FEATURE_SB_CHKSUM\t\t\t0x00000800\n#define F2FS_FEATURE_CASEFOLD\t\t\t0x00001000\n#define F2FS_FEATURE_COMPRESSION\t\t0x00002000\n#define F2FS_FEATURE_RO\t\t\t\t0x00004000\n\n#define __F2FS_HAS_FEATURE(raw_super, mask)\t\t\t\t\\\n\t((raw_super->feature & cpu_to_le32(mask)) != 0)\n#define F2FS_HAS_FEATURE(sbi, mask)\t__F2FS_HAS_FEATURE(sbi->raw_super, mask)\n\n \n#define\tF2FS_DEF_RESUID\t\t0\n#define\tF2FS_DEF_RESGID\t\t0\n\n \nenum {\n\tNAT_BITMAP,\n\tSIT_BITMAP\n};\n\n#define\tCP_UMOUNT\t0x00000001\n#define\tCP_FASTBOOT\t0x00000002\n#define\tCP_SYNC\t\t0x00000004\n#define\tCP_RECOVERY\t0x00000008\n#define\tCP_DISCARD\t0x00000010\n#define CP_TRIMMED\t0x00000020\n#define CP_PAUSE\t0x00000040\n#define CP_RESIZE \t0x00000080\n\n#define DEF_MAX_DISCARD_REQUEST\t\t8\t \n#define DEF_MIN_DISCARD_ISSUE_TIME\t50\t \n#define DEF_MID_DISCARD_ISSUE_TIME\t500\t \n#define DEF_MAX_DISCARD_ISSUE_TIME\t60000\t \n#define DEF_DISCARD_URGENT_UTIL\t\t80\t \n#define DEF_CP_INTERVAL\t\t\t60\t \n#define DEF_IDLE_INTERVAL\t\t5\t \n#define DEF_DISABLE_INTERVAL\t\t5\t \n#define DEF_DISABLE_QUICK_INTERVAL\t1\t \n#define DEF_UMOUNT_DISCARD_TIMEOUT\t5\t \n\nstruct cp_control {\n\tint reason;\n\t__u64 trim_start;\n\t__u64 trim_end;\n\t__u64 trim_minlen;\n};\n\n \nenum {\n\tMETA_CP,\n\tMETA_NAT,\n\tMETA_SIT,\n\tMETA_SSA,\n\tMETA_MAX,\n\tMETA_POR,\n\tDATA_GENERIC,\t\t \n\tDATA_GENERIC_ENHANCE,\t \n\tDATA_GENERIC_ENHANCE_READ,\t \n\tDATA_GENERIC_ENHANCE_UPDATE,\t \n\tMETA_GENERIC,\n};\n\n \nenum {\n\tORPHAN_INO,\t\t \n\tAPPEND_INO,\t\t \n\tUPDATE_INO,\t\t \n\tTRANS_DIR_INO,\t\t \n\tFLUSH_INO,\t\t \n\tMAX_INO_ENTRY,\t\t \n};\n\nstruct ino_entry {\n\tstruct list_head list;\t\t \n\tnid_t ino;\t\t\t \n\tunsigned int dirty_device;\t \n};\n\n \nstruct inode_entry {\n\tstruct list_head list;\t \n\tstruct inode *inode;\t \n};\n\nstruct fsync_node_entry {\n\tstruct list_head list;\t \n\tstruct page *page;\t \n\tunsigned int seq_id;\t \n};\n\nstruct ckpt_req {\n\tstruct completion wait;\t\t \n\tstruct llist_node llnode;\t \n\tint ret;\t\t\t \n\tktime_t queue_time;\t\t \n};\n\nstruct ckpt_req_control {\n\tstruct task_struct *f2fs_issue_ckpt;\t \n\tint ckpt_thread_ioprio;\t\t\t \n\twait_queue_head_t ckpt_wait_queue;\t \n\tatomic_t issued_ckpt;\t\t \n\tatomic_t total_ckpt;\t\t \n\tatomic_t queued_ckpt;\t\t \n\tstruct llist_head issue_list;\t \n\tspinlock_t stat_lock;\t\t \n\tunsigned int cur_time;\t\t \n\tunsigned int peak_time;\t\t \n};\n\n \nstruct discard_entry {\n\tstruct list_head list;\t \n\tblock_t start_blkaddr;\t \n\tunsigned char discard_map[SIT_VBLOCK_MAP_SIZE];\t \n};\n\n \n#define MIN_DISCARD_GRANULARITY\t\t1\n \n#define DEFAULT_DISCARD_GRANULARITY\t\t16\n \n#define DEFAULT_MAX_ORDERED_DISCARD_GRANULARITY\t16\n\n \n#define MAX_PLIST_NUM\t\t512\n#define plist_idx(blk_num)\t((blk_num) >= MAX_PLIST_NUM ?\t\t\\\n\t\t\t\t\t(MAX_PLIST_NUM - 1) : ((blk_num) - 1))\n\nenum {\n\tD_PREP,\t\t\t \n\tD_PARTIAL,\t\t \n\tD_SUBMIT,\t\t \n\tD_DONE,\t\t\t \n};\n\nstruct discard_info {\n\tblock_t lstart;\t\t\t \n\tblock_t len;\t\t\t \n\tblock_t start;\t\t\t \n};\n\nstruct discard_cmd {\n\tstruct rb_node rb_node;\t\t \n\tstruct discard_info di;\t\t \n\tstruct list_head list;\t\t \n\tstruct completion wait;\t\t \n\tstruct block_device *bdev;\t \n\tunsigned short ref;\t\t \n\tunsigned char state;\t\t \n\tunsigned char queued;\t\t \n\tint error;\t\t\t \n\tspinlock_t lock;\t\t \n\tunsigned short bio_ref;\t\t \n};\n\nenum {\n\tDPOLICY_BG,\n\tDPOLICY_FORCE,\n\tDPOLICY_FSTRIM,\n\tDPOLICY_UMOUNT,\n\tMAX_DPOLICY,\n};\n\nstruct discard_policy {\n\tint type;\t\t\t \n\tunsigned int min_interval;\t \n\tunsigned int mid_interval;\t \n\tunsigned int max_interval;\t \n\tunsigned int max_requests;\t \n\tunsigned int io_aware_gran;\t \n\tbool io_aware;\t\t\t \n\tbool sync;\t\t\t \n\tbool ordered;\t\t\t \n\tbool timeout;\t\t\t \n\tunsigned int granularity;\t \n};\n\nstruct discard_cmd_control {\n\tstruct task_struct *f2fs_issue_discard;\t \n\tstruct list_head entry_list;\t\t \n\tstruct list_head pend_list[MAX_PLIST_NUM]; \n\tstruct list_head wait_list;\t\t \n\tstruct list_head fstrim_list;\t\t \n\twait_queue_head_t discard_wait_queue;\t \n\tstruct mutex cmd_lock;\n\tunsigned int nr_discards;\t\t \n\tunsigned int max_discards;\t\t \n\tunsigned int max_discard_request;\t \n\tunsigned int min_discard_issue_time;\t \n\tunsigned int mid_discard_issue_time;\t \n\tunsigned int max_discard_issue_time;\t \n\tunsigned int discard_io_aware_gran;  \n\tunsigned int discard_urgent_util;\t \n\tunsigned int discard_granularity;\t \n\tunsigned int max_ordered_discard;\t \n\tunsigned int undiscard_blks;\t\t \n\tunsigned int next_pos;\t\t\t \n\tatomic_t issued_discard;\t\t \n\tatomic_t queued_discard;\t\t \n\tatomic_t discard_cmd_cnt;\t\t \n\tstruct rb_root_cached root;\t\t \n\tbool rbtree_check;\t\t\t \n\tbool discard_wake;\t\t\t \n};\n\n \nstruct fsync_inode_entry {\n\tstruct list_head list;\t \n\tstruct inode *inode;\t \n\tblock_t blkaddr;\t \n\tblock_t last_dentry;\t \n};\n\n#define nats_in_cursum(jnl)\t\t(le16_to_cpu((jnl)->n_nats))\n#define sits_in_cursum(jnl)\t\t(le16_to_cpu((jnl)->n_sits))\n\n#define nat_in_journal(jnl, i)\t\t((jnl)->nat_j.entries[i].ne)\n#define nid_in_journal(jnl, i)\t\t((jnl)->nat_j.entries[i].nid)\n#define sit_in_journal(jnl, i)\t\t((jnl)->sit_j.entries[i].se)\n#define segno_in_journal(jnl, i)\t((jnl)->sit_j.entries[i].segno)\n\n#define MAX_NAT_JENTRIES(jnl)\t(NAT_JOURNAL_ENTRIES - nats_in_cursum(jnl))\n#define MAX_SIT_JENTRIES(jnl)\t(SIT_JOURNAL_ENTRIES - sits_in_cursum(jnl))\n\nstatic inline int update_nats_in_cursum(struct f2fs_journal *journal, int i)\n{\n\tint before = nats_in_cursum(journal);\n\n\tjournal->n_nats = cpu_to_le16(before + i);\n\treturn before;\n}\n\nstatic inline int update_sits_in_cursum(struct f2fs_journal *journal, int i)\n{\n\tint before = sits_in_cursum(journal);\n\n\tjournal->n_sits = cpu_to_le16(before + i);\n\treturn before;\n}\n\nstatic inline bool __has_cursum_space(struct f2fs_journal *journal,\n\t\t\t\t\t\t\tint size, int type)\n{\n\tif (type == NAT_JOURNAL)\n\t\treturn size <= MAX_NAT_JENTRIES(journal);\n\treturn size <= MAX_SIT_JENTRIES(journal);\n}\n\n \n#define DEF_INLINE_RESERVED_SIZE\t1\nstatic inline int get_extra_isize(struct inode *inode);\nstatic inline int get_inline_xattr_addrs(struct inode *inode);\n#define MAX_INLINE_DATA(inode)\t(sizeof(__le32) *\t\t\t\\\n\t\t\t\t(CUR_ADDRS_PER_INODE(inode) -\t\t\\\n\t\t\t\tget_inline_xattr_addrs(inode) -\t\\\n\t\t\t\tDEF_INLINE_RESERVED_SIZE))\n\n \n#define NR_INLINE_DENTRY(inode)\t(MAX_INLINE_DATA(inode) * BITS_PER_BYTE / \\\n\t\t\t\t((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \\\n\t\t\t\tBITS_PER_BYTE + 1))\n#define INLINE_DENTRY_BITMAP_SIZE(inode) \\\n\tDIV_ROUND_UP(NR_INLINE_DENTRY(inode), BITS_PER_BYTE)\n#define INLINE_RESERVED_SIZE(inode)\t(MAX_INLINE_DATA(inode) - \\\n\t\t\t\t((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \\\n\t\t\t\tNR_INLINE_DENTRY(inode) + \\\n\t\t\t\tINLINE_DENTRY_BITMAP_SIZE(inode)))\n\n \n \n\nstruct f2fs_filename {\n\t \n\tconst struct qstr *usr_fname;\n\n\t \n\tstruct fscrypt_str disk_name;\n\n\t \n\tf2fs_hash_t hash;\n\n#ifdef CONFIG_FS_ENCRYPTION\n\t \n\tstruct fscrypt_str crypto_buf;\n#endif\n#if IS_ENABLED(CONFIG_UNICODE)\n\t \n\tstruct fscrypt_str cf_name;\n#endif\n};\n\nstruct f2fs_dentry_ptr {\n\tstruct inode *inode;\n\tvoid *bitmap;\n\tstruct f2fs_dir_entry *dentry;\n\t__u8 (*filename)[F2FS_SLOT_LEN];\n\tint max;\n\tint nr_bitmap;\n};\n\nstatic inline void make_dentry_ptr_block(struct inode *inode,\n\t\tstruct f2fs_dentry_ptr *d, struct f2fs_dentry_block *t)\n{\n\td->inode = inode;\n\td->max = NR_DENTRY_IN_BLOCK;\n\td->nr_bitmap = SIZE_OF_DENTRY_BITMAP;\n\td->bitmap = t->dentry_bitmap;\n\td->dentry = t->dentry;\n\td->filename = t->filename;\n}\n\nstatic inline void make_dentry_ptr_inline(struct inode *inode,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d, void *t)\n{\n\tint entry_cnt = NR_INLINE_DENTRY(inode);\n\tint bitmap_size = INLINE_DENTRY_BITMAP_SIZE(inode);\n\tint reserved_size = INLINE_RESERVED_SIZE(inode);\n\n\td->inode = inode;\n\td->max = entry_cnt;\n\td->nr_bitmap = bitmap_size;\n\td->bitmap = t;\n\td->dentry = t + bitmap_size + reserved_size;\n\td->filename = t + bitmap_size + reserved_size +\n\t\t\t\t\tSIZE_OF_DIR_ENTRY * entry_cnt;\n}\n\n \n#define XATTR_NODE_OFFSET\t((((unsigned int)-1) << OFFSET_BIT_SHIFT) \\\n\t\t\t\t>> OFFSET_BIT_SHIFT)\nenum {\n\tALLOC_NODE,\t\t\t \n\tLOOKUP_NODE,\t\t\t \n\tLOOKUP_NODE_RA,\t\t\t \n};\n\n#define DEFAULT_RETRY_IO_COUNT\t8\t \n\n \n#define\tDEFAULT_IO_TIMEOUT\t(msecs_to_jiffies(20))\n\n \n#define DEFAULT_RETRY_QUOTA_FLUSH_COUNT\t\t8\n\n \n#define MAX_RETRY_PAGE_EIO\t\t\t100\n\n#define F2FS_LINK_MAX\t0xffffffff\t \n\n#define MAX_DIR_RA_PAGES\t4\t \n\n \n#define DEFAULT_DIRTY_THRESHOLD\t\t4\n\n#define RECOVERY_MAX_RA_BLOCKS\t\tBIO_MAX_VECS\n#define RECOVERY_MIN_RA_BLOCKS\t\t1\n\n#define F2FS_ONSTACK_PAGES\t16\t \n\n \n#define F2FS_MIN_EXTENT_LEN\t64\t \n\n \n#define READ_EXTENT_CACHE_SHRINK_NUMBER\t128\n\n \n#define AGE_EXTENT_CACHE_SHRINK_NUMBER\t128\n#define LAST_AGE_WEIGHT\t\t\t30\n#define SAME_AGE_REGION\t\t\t1024\n\n \n#define DEF_HOT_DATA_AGE_THRESHOLD\t262144\n#define DEF_WARM_DATA_AGE_THRESHOLD\t2621440\n\n \nenum extent_type {\n\tEX_READ,\n\tEX_BLOCK_AGE,\n\tNR_EXTENT_CACHES,\n};\n\nstruct extent_info {\n\tunsigned int fofs;\t\t \n\tunsigned int len;\t\t \n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tblock_t blk;\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t\t\t \n\t\t\tunsigned int c_len;\n#endif\n\t\t};\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tunsigned long long age;\n\t\t\t \n\t\t\tunsigned long long last_blocks;\n\t\t};\n\t};\n};\n\nstruct extent_node {\n\tstruct rb_node rb_node;\t\t \n\tstruct extent_info ei;\t\t \n\tstruct list_head list;\t\t \n\tstruct extent_tree *et;\t\t \n};\n\nstruct extent_tree {\n\tnid_t ino;\t\t\t \n\tenum extent_type type;\t\t \n\tstruct rb_root_cached root;\t \n\tstruct extent_node *cached_en;\t \n\tstruct list_head list;\t\t \n\trwlock_t lock;\t\t\t \n\tatomic_t node_cnt;\t\t \n\tbool largest_updated;\t\t \n\tstruct extent_info largest;\t \n};\n\nstruct extent_tree_info {\n\tstruct radix_tree_root extent_tree_root; \n\tstruct mutex extent_tree_lock;\t \n\tstruct list_head extent_list;\t\t \n\tspinlock_t extent_lock;\t\t\t \n\tatomic_t total_ext_tree;\t\t \n\tstruct list_head zombie_list;\t\t \n\tatomic_t total_zombie_tree;\t\t \n\tatomic_t total_ext_node;\t\t \n};\n\n \n#define F2FS_MAP_NEW\t\t(1U << 0)\n#define F2FS_MAP_MAPPED\t\t(1U << 1)\n#define F2FS_MAP_DELALLOC\t(1U << 2)\n#define F2FS_MAP_FLAGS\t\t(F2FS_MAP_NEW | F2FS_MAP_MAPPED |\\\n\t\t\t\tF2FS_MAP_DELALLOC)\n\nstruct f2fs_map_blocks {\n\tstruct block_device *m_bdev;\t \n\tblock_t m_pblk;\n\tblock_t m_lblk;\n\tunsigned int m_len;\n\tunsigned int m_flags;\n\tpgoff_t *m_next_pgofs;\t\t \n\tpgoff_t *m_next_extent;\t\t \n\tint m_seg_type;\n\tbool m_may_create;\t\t \n\tbool m_multidev_dio;\t\t \n};\n\n \nenum {\n\tF2FS_GET_BLOCK_DEFAULT,\n\tF2FS_GET_BLOCK_FIEMAP,\n\tF2FS_GET_BLOCK_BMAP,\n\tF2FS_GET_BLOCK_DIO,\n\tF2FS_GET_BLOCK_PRE_DIO,\n\tF2FS_GET_BLOCK_PRE_AIO,\n\tF2FS_GET_BLOCK_PRECACHE,\n};\n\n \n#define FADVISE_COLD_BIT\t0x01\n#define FADVISE_LOST_PINO_BIT\t0x02\n#define FADVISE_ENCRYPT_BIT\t0x04\n#define FADVISE_ENC_NAME_BIT\t0x08\n#define FADVISE_KEEP_SIZE_BIT\t0x10\n#define FADVISE_HOT_BIT\t\t0x20\n#define FADVISE_VERITY_BIT\t0x40\n#define FADVISE_TRUNC_BIT\t0x80\n\n#define FADVISE_MODIFIABLE_BITS\t(FADVISE_COLD_BIT | FADVISE_HOT_BIT)\n\n#define file_is_cold(inode)\tis_file(inode, FADVISE_COLD_BIT)\n#define file_set_cold(inode)\tset_file(inode, FADVISE_COLD_BIT)\n#define file_clear_cold(inode)\tclear_file(inode, FADVISE_COLD_BIT)\n\n#define file_wrong_pino(inode)\tis_file(inode, FADVISE_LOST_PINO_BIT)\n#define file_lost_pino(inode)\tset_file(inode, FADVISE_LOST_PINO_BIT)\n#define file_got_pino(inode)\tclear_file(inode, FADVISE_LOST_PINO_BIT)\n\n#define file_is_encrypt(inode)\tis_file(inode, FADVISE_ENCRYPT_BIT)\n#define file_set_encrypt(inode)\tset_file(inode, FADVISE_ENCRYPT_BIT)\n\n#define file_enc_name(inode)\tis_file(inode, FADVISE_ENC_NAME_BIT)\n#define file_set_enc_name(inode) set_file(inode, FADVISE_ENC_NAME_BIT)\n\n#define file_keep_isize(inode)\tis_file(inode, FADVISE_KEEP_SIZE_BIT)\n#define file_set_keep_isize(inode) set_file(inode, FADVISE_KEEP_SIZE_BIT)\n\n#define file_is_hot(inode)\tis_file(inode, FADVISE_HOT_BIT)\n#define file_set_hot(inode)\tset_file(inode, FADVISE_HOT_BIT)\n#define file_clear_hot(inode)\tclear_file(inode, FADVISE_HOT_BIT)\n\n#define file_is_verity(inode)\tis_file(inode, FADVISE_VERITY_BIT)\n#define file_set_verity(inode)\tset_file(inode, FADVISE_VERITY_BIT)\n\n#define file_should_truncate(inode)\tis_file(inode, FADVISE_TRUNC_BIT)\n#define file_need_truncate(inode)\tset_file(inode, FADVISE_TRUNC_BIT)\n#define file_dont_truncate(inode)\tclear_file(inode, FADVISE_TRUNC_BIT)\n\n#define DEF_DIR_LEVEL\t\t0\n\nenum {\n\tGC_FAILURE_PIN,\n\tMAX_GC_FAILURE\n};\n\n \nenum {\n\tFI_NEW_INODE,\t\t \n\tFI_DIRTY_INODE,\t\t \n\tFI_AUTO_RECOVER,\t \n\tFI_DIRTY_DIR,\t\t \n\tFI_INC_LINK,\t\t \n\tFI_ACL_MODE,\t\t \n\tFI_NO_ALLOC,\t\t \n\tFI_FREE_NID,\t\t \n\tFI_NO_EXTENT,\t\t \n\tFI_INLINE_XATTR,\t \n\tFI_INLINE_DATA,\t\t \n\tFI_INLINE_DENTRY,\t \n\tFI_APPEND_WRITE,\t \n\tFI_UPDATE_WRITE,\t \n\tFI_NEED_IPU,\t\t \n\tFI_ATOMIC_FILE,\t\t \n\tFI_FIRST_BLOCK_WRITTEN,\t \n\tFI_DROP_CACHE,\t\t \n\tFI_DATA_EXIST,\t\t \n\tFI_INLINE_DOTS,\t\t \n\tFI_SKIP_WRITES,\t\t \n\tFI_OPU_WRITE,\t\t \n\tFI_DIRTY_FILE,\t\t \n\tFI_PREALLOCATED_ALL,\t \n\tFI_HOT_DATA,\t\t \n\tFI_EXTRA_ATTR,\t\t \n\tFI_PROJ_INHERIT,\t \n\tFI_PIN_FILE,\t\t \n\tFI_VERITY_IN_PROGRESS,\t \n\tFI_COMPRESSED_FILE,\t \n\tFI_COMPRESS_CORRUPT,\t \n\tFI_MMAP_FILE,\t\t \n\tFI_ENABLE_COMPRESS,\t \n\tFI_COMPRESS_RELEASED,\t \n\tFI_ALIGNED_WRITE,\t \n\tFI_COW_FILE,\t\t \n\tFI_ATOMIC_COMMITTED,\t \n\tFI_ATOMIC_REPLACE,\t \n\tFI_MAX,\t\t\t \n};\n\nstruct f2fs_inode_info {\n\tstruct inode vfs_inode;\t\t \n\tunsigned long i_flags;\t\t \n\tunsigned char i_advise;\t\t \n\tunsigned char i_dir_level;\t \n\tunsigned int i_current_depth;\t \n\t \n\tunsigned int i_gc_failures[MAX_GC_FAILURE];\n\tunsigned int i_pino;\t\t \n\tumode_t i_acl_mode;\t\t \n\n\t \n\tunsigned long flags[BITS_TO_LONGS(FI_MAX)];\t \n\tstruct f2fs_rwsem i_sem;\t \n\tatomic_t dirty_pages;\t\t \n\tf2fs_hash_t chash;\t\t \n\tunsigned int clevel;\t\t \n\tstruct task_struct *task;\t \n\tstruct task_struct *cp_task;\t \n\tstruct task_struct *wb_task;\t \n\tnid_t i_xattr_nid;\t\t \n\tloff_t\tlast_disk_size;\t\t \n\tspinlock_t i_size_lock;\t\t \n\n#ifdef CONFIG_QUOTA\n\tstruct dquot *i_dquot[MAXQUOTAS];\n\n\t \n\tqsize_t i_reserved_quota;\n#endif\n\tstruct list_head dirty_list;\t \n\tstruct list_head gdirty_list;\t \n\tstruct task_struct *atomic_write_task;\t \n\tstruct extent_tree *extent_tree[NR_EXTENT_CACHES];\n\t\t\t\t\t \n\tstruct inode *cow_inode;\t \n\n\t \n\tstruct f2fs_rwsem i_gc_rwsem[2];\n\tstruct f2fs_rwsem i_xattr_sem;  \n\n\tint i_extra_isize;\t\t \n\tkprojid_t i_projid;\t\t \n\tint i_inline_xattr_size;\t \n\tstruct timespec64 i_crtime;\t \n\tstruct timespec64 i_disk_time[3]; \n\n\t \n\tatomic_t i_compr_blocks;\t\t \n\tunsigned char i_compress_algorithm;\t \n\tunsigned char i_log_cluster_size;\t \n\tunsigned char i_compress_level;\t\t \n\tunsigned char i_compress_flag;\t\t \n\tunsigned int i_cluster_size;\t\t \n\n\tunsigned int atomic_write_cnt;\n\tloff_t original_i_size;\t\t \n};\n\nstatic inline void get_read_extent_info(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent *i_ext)\n{\n\text->fofs = le32_to_cpu(i_ext->fofs);\n\text->blk = le32_to_cpu(i_ext->blk);\n\text->len = le32_to_cpu(i_ext->len);\n}\n\nstatic inline void set_raw_read_extent(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent *i_ext)\n{\n\ti_ext->fofs = cpu_to_le32(ext->fofs);\n\ti_ext->blk = cpu_to_le32(ext->blk);\n\ti_ext->len = cpu_to_le32(ext->len);\n}\n\nstatic inline bool __is_discard_mergeable(struct discard_info *back,\n\t\t\tstruct discard_info *front, unsigned int max_len)\n{\n\treturn (back->lstart + back->len == front->lstart) &&\n\t\t(back->len + front->len <= max_len);\n}\n\nstatic inline bool __is_discard_back_mergeable(struct discard_info *cur,\n\t\t\tstruct discard_info *back, unsigned int max_len)\n{\n\treturn __is_discard_mergeable(back, cur, max_len);\n}\n\nstatic inline bool __is_discard_front_mergeable(struct discard_info *cur,\n\t\t\tstruct discard_info *front, unsigned int max_len)\n{\n\treturn __is_discard_mergeable(cur, front, max_len);\n}\n\n \nenum nid_state {\n\tFREE_NID,\t\t \n\tPREALLOC_NID,\t\t \n\tMAX_NID_STATE,\n};\n\nenum nat_state {\n\tTOTAL_NAT,\n\tDIRTY_NAT,\n\tRECLAIMABLE_NAT,\n\tMAX_NAT_STATE,\n};\n\nstruct f2fs_nm_info {\n\tblock_t nat_blkaddr;\t\t \n\tnid_t max_nid;\t\t\t \n\tnid_t available_nids;\t\t \n\tnid_t next_scan_nid;\t\t \n\tnid_t max_rf_node_blocks;\t \n\tunsigned int ram_thresh;\t \n\tunsigned int ra_nid_pages;\t \n\tunsigned int dirty_nats_ratio;\t \n\n\t \n\tstruct radix_tree_root nat_root; \n\tstruct radix_tree_root nat_set_root; \n\tstruct f2fs_rwsem nat_tree_lock;\t \n\tstruct list_head nat_entries;\t \n\tspinlock_t nat_list_lock;\t \n\tunsigned int nat_cnt[MAX_NAT_STATE];  \n\tunsigned int nat_blocks;\t \n\n\t \n\tstruct radix_tree_root free_nid_root; \n\tstruct list_head free_nid_list;\t\t \n\tunsigned int nid_cnt[MAX_NID_STATE];\t \n\tspinlock_t nid_list_lock;\t \n\tstruct mutex build_lock;\t \n\tunsigned char **free_nid_bitmap;\n\tunsigned char *nat_block_bitmap;\n\tunsigned short *free_nid_count;\t \n\n\t \n\tchar *nat_bitmap;\t\t \n\n\tunsigned int nat_bits_blocks;\t \n\tunsigned char *nat_bits;\t \n\tunsigned char *full_nat_bits;\t \n\tunsigned char *empty_nat_bits;\t \n#ifdef CONFIG_F2FS_CHECK_FS\n\tchar *nat_bitmap_mir;\t\t \n#endif\n\tint bitmap_size;\t\t \n};\n\n \nstruct dnode_of_data {\n\tstruct inode *inode;\t\t \n\tstruct page *inode_page;\t \n\tstruct page *node_page;\t\t \n\tnid_t nid;\t\t\t \n\tunsigned int ofs_in_node;\t \n\tbool inode_page_locked;\t\t \n\tbool node_changed;\t\t \n\tchar cur_level;\t\t\t \n\tchar max_level;\t\t\t \n\tblock_t\tdata_blkaddr;\t\t \n};\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}\n\n \n#define\tNR_CURSEG_DATA_TYPE\t(3)\n#define NR_CURSEG_NODE_TYPE\t(3)\n#define NR_CURSEG_INMEM_TYPE\t(2)\n#define NR_CURSEG_RO_TYPE\t(2)\n#define NR_CURSEG_PERSIST_TYPE\t(NR_CURSEG_DATA_TYPE + NR_CURSEG_NODE_TYPE)\n#define NR_CURSEG_TYPE\t\t(NR_CURSEG_INMEM_TYPE + NR_CURSEG_PERSIST_TYPE)\n\nenum {\n\tCURSEG_HOT_DATA\t= 0,\t \n\tCURSEG_WARM_DATA,\t \n\tCURSEG_COLD_DATA,\t \n\tCURSEG_HOT_NODE,\t \n\tCURSEG_WARM_NODE,\t \n\tCURSEG_COLD_NODE,\t \n\tNR_PERSISTENT_LOG,\t \n\tCURSEG_COLD_DATA_PINNED = NR_PERSISTENT_LOG,\n\t\t\t\t \n\tCURSEG_ALL_DATA_ATGC,\t \n\tNO_CHECK_TYPE,\t\t \n};\n\nstruct flush_cmd {\n\tstruct completion wait;\n\tstruct llist_node llnode;\n\tnid_t ino;\n\tint ret;\n};\n\nstruct flush_cmd_control {\n\tstruct task_struct *f2fs_issue_flush;\t \n\twait_queue_head_t flush_wait_queue;\t \n\tatomic_t issued_flush;\t\t\t \n\tatomic_t queued_flush;\t\t\t \n\tstruct llist_head issue_list;\t\t \n\tstruct llist_node *dispatch_list;\t \n};\n\nstruct f2fs_sm_info {\n\tstruct sit_info *sit_info;\t\t \n\tstruct free_segmap_info *free_info;\t \n\tstruct dirty_seglist_info *dirty_info;\t \n\tstruct curseg_info *curseg_array;\t \n\n\tstruct f2fs_rwsem curseg_lock;\t \n\n\tblock_t seg0_blkaddr;\t\t \n\tblock_t main_blkaddr;\t\t \n\tblock_t ssa_blkaddr;\t\t \n\n\tunsigned int segment_count;\t \n\tunsigned int main_segments;\t \n\tunsigned int reserved_segments;\t \n\tunsigned int additional_reserved_segments; \n\tunsigned int ovp_segments;\t \n\n\t \n\tunsigned int rec_prefree_segments;\n\n\tstruct list_head sit_entry_set;\t \n\n\tunsigned int ipu_policy;\t \n\tunsigned int min_ipu_util;\t \n\tunsigned int min_fsync_blocks;\t \n\tunsigned int min_seq_blocks;\t \n\tunsigned int min_hot_blocks;\t \n\tunsigned int min_ssr_sections;\t \n\n\t \n\tstruct flush_cmd_control *fcc_info;\n\n\t \n\tstruct discard_cmd_control *dcc_info;\n};\n\n \n \n#define WB_DATA_TYPE(p)\t(__is_cp_guaranteed(p) ? F2FS_WB_CP_DATA : F2FS_WB_DATA)\nenum count_type {\n\tF2FS_DIRTY_DENTS,\n\tF2FS_DIRTY_DATA,\n\tF2FS_DIRTY_QDATA,\n\tF2FS_DIRTY_NODES,\n\tF2FS_DIRTY_META,\n\tF2FS_DIRTY_IMETA,\n\tF2FS_WB_CP_DATA,\n\tF2FS_WB_DATA,\n\tF2FS_RD_DATA,\n\tF2FS_RD_NODE,\n\tF2FS_RD_META,\n\tF2FS_DIO_WRITE,\n\tF2FS_DIO_READ,\n\tNR_COUNT_TYPE,\n};\n\n \n#define PAGE_TYPE_OF_BIO(type)\t((type) > META ? META : (type))\nenum page_type {\n\tDATA = 0,\n\tNODE = 1,\t \n\tMETA,\n\tNR_PAGE_TYPE,\n\tMETA_FLUSH,\n\tIPU,\t\t \n\tOPU,\n};\n\nenum temp_type {\n\tHOT = 0,\t \n\tWARM,\n\tCOLD,\n\tNR_TEMP_TYPE,\n};\n\nenum need_lock_type {\n\tLOCK_REQ = 0,\n\tLOCK_DONE,\n\tLOCK_RETRY,\n};\n\nenum cp_reason_type {\n\tCP_NO_NEEDED,\n\tCP_NON_REGULAR,\n\tCP_COMPRESSED,\n\tCP_HARDLINK,\n\tCP_SB_NEED_CP,\n\tCP_WRONG_PINO,\n\tCP_NO_SPC_ROLL,\n\tCP_NODE_NEED_CP,\n\tCP_FASTBOOT_MODE,\n\tCP_SPEC_LOG_NUM,\n\tCP_RECOVER_DIR,\n};\n\nenum iostat_type {\n\t \n\tAPP_DIRECT_IO,\t\t\t \n\tAPP_BUFFERED_IO,\t\t \n\tAPP_WRITE_IO,\t\t\t \n\tAPP_MAPPED_IO,\t\t\t \n\tAPP_BUFFERED_CDATA_IO,\t\t \n\tAPP_MAPPED_CDATA_IO,\t\t \n\tFS_DATA_IO,\t\t\t \n\tFS_CDATA_IO,\t\t\t \n\tFS_NODE_IO,\t\t\t \n\tFS_META_IO,\t\t\t \n\tFS_GC_DATA_IO,\t\t\t \n\tFS_GC_NODE_IO,\t\t\t \n\tFS_CP_DATA_IO,\t\t\t \n\tFS_CP_NODE_IO,\t\t\t \n\tFS_CP_META_IO,\t\t\t \n\n\t \n\tAPP_DIRECT_READ_IO,\t\t \n\tAPP_BUFFERED_READ_IO,\t\t \n\tAPP_READ_IO,\t\t\t \n\tAPP_MAPPED_READ_IO,\t\t \n\tAPP_BUFFERED_CDATA_READ_IO,\t \n\tAPP_MAPPED_CDATA_READ_IO,\t \n\tFS_DATA_READ_IO,\t\t \n\tFS_GDATA_READ_IO,\t\t \n\tFS_CDATA_READ_IO,\t\t \n\tFS_NODE_READ_IO,\t\t \n\tFS_META_READ_IO,\t\t \n\n\t \n\tFS_DISCARD_IO,\t\t\t \n\tFS_FLUSH_IO,\t\t\t \n\tFS_ZONE_RESET_IO,\t\t \n\tNR_IO_TYPE,\n};\n\nstruct f2fs_io_info {\n\tstruct f2fs_sb_info *sbi;\t \n\tnid_t ino;\t\t \n\tenum page_type type;\t \n\tenum temp_type temp;\t \n\tenum req_op op;\t\t \n\tblk_opf_t op_flags;\t \n\tblock_t new_blkaddr;\t \n\tblock_t old_blkaddr;\t \n\tstruct page *page;\t \n\tstruct page *encrypted_page;\t \n\tstruct page *compressed_page;\t \n\tstruct list_head list;\t\t \n\tunsigned int compr_blocks;\t \n\tunsigned int need_lock:8;\t \n\tunsigned int version:8;\t\t \n\tunsigned int submitted:1;\t \n\tunsigned int in_list:1;\t\t \n\tunsigned int is_por:1;\t\t \n\tunsigned int retry:1;\t\t \n\tunsigned int encrypted:1;\t \n\tunsigned int post_read:1;\t \n\tenum iostat_type io_type;\t \n\tstruct writeback_control *io_wbc;  \n\tstruct bio **bio;\t\t \n\tsector_t *last_block;\t\t \n};\n\nstruct bio_entry {\n\tstruct bio *bio;\n\tstruct list_head list;\n};\n\n#define is_read_io(rw) ((rw) == READ)\nstruct f2fs_bio_info {\n\tstruct f2fs_sb_info *sbi;\t \n\tstruct bio *bio;\t\t \n\tsector_t last_block_in_bio;\t \n\tstruct f2fs_io_info fio;\t \n#ifdef CONFIG_BLK_DEV_ZONED\n\tstruct completion zone_wait;\t \n\tstruct bio *zone_pending_bio;\t \n\tvoid *bi_private;\t\t \n#endif\n\tstruct f2fs_rwsem io_rwsem;\t \n\tspinlock_t io_lock;\t\t \n\tstruct list_head io_list;\t \n\tstruct list_head bio_list;\t \n\tstruct f2fs_rwsem bio_list_lock;\t \n};\n\n#define FDEV(i)\t\t\t\t(sbi->devs[i])\n#define RDEV(i)\t\t\t\t(raw_super->devs[i])\nstruct f2fs_dev_info {\n\tstruct block_device *bdev;\n\tchar path[MAX_PATH_LEN];\n\tunsigned int total_segments;\n\tblock_t start_blk;\n\tblock_t end_blk;\n#ifdef CONFIG_BLK_DEV_ZONED\n\tunsigned int nr_blkz;\t\t \n\tunsigned long *blkz_seq;\t \n#endif\n};\n\nenum inode_type {\n\tDIR_INODE,\t\t\t \n\tFILE_INODE,\t\t\t \n\tDIRTY_META,\t\t\t \n\tNR_INODE_TYPE,\n};\n\n \nstruct inode_management {\n\tstruct radix_tree_root ino_root;\t \n\tspinlock_t ino_lock;\t\t\t \n\tstruct list_head ino_list;\t\t \n\tunsigned long ino_num;\t\t\t \n};\n\n \nstruct atgc_management {\n\tbool atgc_enabled;\t\t\t \n\tstruct rb_root_cached root;\t\t \n\tstruct list_head victim_list;\t\t \n\tunsigned int victim_count;\t\t \n\tunsigned int candidate_ratio;\t\t \n\tunsigned int max_candidate_count;\t \n\tunsigned int age_weight;\t\t \n\tunsigned long long age_threshold;\t \n};\n\nstruct f2fs_gc_control {\n\tunsigned int victim_segno;\t \n\tint init_gc_type;\t\t \n\tbool no_bg_gc;\t\t\t \n\tbool should_migrate_blocks;\t \n\tbool err_gc_skipped;\t\t \n\tunsigned int nr_free_secs;\t \n};\n\n \nenum {\n\tSBI_IS_DIRTY,\t\t\t\t \n\tSBI_IS_CLOSE,\t\t\t\t \n\tSBI_NEED_FSCK,\t\t\t\t \n\tSBI_POR_DOING,\t\t\t\t \n\tSBI_NEED_SB_WRITE,\t\t\t \n\tSBI_NEED_CP,\t\t\t\t \n\tSBI_IS_SHUTDOWN,\t\t\t \n\tSBI_IS_RECOVERED,\t\t\t \n\tSBI_CP_DISABLED,\t\t\t \n\tSBI_CP_DISABLED_QUICK,\t\t\t \n\tSBI_QUOTA_NEED_FLUSH,\t\t\t \n\tSBI_QUOTA_SKIP_FLUSH,\t\t\t \n\tSBI_QUOTA_NEED_REPAIR,\t\t\t \n\tSBI_IS_RESIZEFS,\t\t\t \n\tSBI_IS_FREEZING,\t\t\t \n\tSBI_IS_WRITABLE,\t\t\t \n\tMAX_SBI_FLAG,\n};\n\nenum {\n\tCP_TIME,\n\tREQ_TIME,\n\tDISCARD_TIME,\n\tGC_TIME,\n\tDISABLE_TIME,\n\tUMOUNT_DISCARD_TIMEOUT,\n\tMAX_TIME,\n};\n\n \nenum {\n\tGC_NORMAL,\n\tGC_IDLE_CB,\n\tGC_IDLE_GREEDY,\n\tGC_IDLE_AT,\n\tGC_URGENT_HIGH,\n\tGC_URGENT_LOW,\n\tGC_URGENT_MID,\n\tMAX_GC_MODE,\n};\n\nenum {\n\tBGGC_MODE_ON,\t\t \n\tBGGC_MODE_OFF,\t\t \n\tBGGC_MODE_SYNC,\t\t \n};\n\nenum {\n\tFS_MODE_ADAPTIVE,\t\t \n\tFS_MODE_LFS,\t\t\t \n\tFS_MODE_FRAGMENT_SEG,\t\t \n\tFS_MODE_FRAGMENT_BLK,\t\t \n};\n\nenum {\n\tALLOC_MODE_DEFAULT,\t \n\tALLOC_MODE_REUSE,\t \n};\n\nenum fsync_mode {\n\tFSYNC_MODE_POSIX,\t \n\tFSYNC_MODE_STRICT,\t \n\tFSYNC_MODE_NOBARRIER,\t \n};\n\nenum {\n\tCOMPR_MODE_FS,\t\t \n\tCOMPR_MODE_USER,\t \n};\n\nenum {\n\tDISCARD_UNIT_BLOCK,\t \n\tDISCARD_UNIT_SEGMENT,\t \n\tDISCARD_UNIT_SECTION,\t \n};\n\nenum {\n\tMEMORY_MODE_NORMAL,\t \n\tMEMORY_MODE_LOW,\t \n};\n\nenum errors_option {\n\tMOUNT_ERRORS_READONLY,\t \n\tMOUNT_ERRORS_CONTINUE,\t \n\tMOUNT_ERRORS_PANIC,\t \n};\n\nenum {\n\tBACKGROUND,\n\tFOREGROUND,\n\tMAX_CALL_TYPE,\n\tTOTAL_CALL = FOREGROUND,\n};\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr);\nstatic inline void f2fs_set_bit(unsigned int nr, char *addr);\nstatic inline void f2fs_clear_bit(unsigned int nr, char *addr);\n\n \nenum {\n\tPAGE_PRIVATE_NOT_POINTER,\t\t \n\tPAGE_PRIVATE_DUMMY_WRITE,\t\t \n\tPAGE_PRIVATE_ONGOING_MIGRATION,\t\t \n\tPAGE_PRIVATE_INLINE_INODE,\t\t \n\tPAGE_PRIVATE_REF_RESOURCE,\t\t \n\tPAGE_PRIVATE_MAX\n};\n\n \nenum compress_algorithm_type {\n\tCOMPRESS_LZO,\n\tCOMPRESS_LZ4,\n\tCOMPRESS_ZSTD,\n\tCOMPRESS_LZORLE,\n\tCOMPRESS_MAX,\n};\n\nenum compress_flag {\n\tCOMPRESS_CHKSUM,\n\tCOMPRESS_MAX_FLAG,\n};\n\n#define\tCOMPRESS_WATERMARK\t\t\t20\n#define\tCOMPRESS_PERCENT\t\t\t20\n\n#define COMPRESS_DATA_RESERVED_SIZE\t\t4\nstruct compress_data {\n\t__le32 clen;\t\t\t \n\t__le32 chksum;\t\t\t \n\t__le32 reserved[COMPRESS_DATA_RESERVED_SIZE];\t \n\tu8 cdata[];\t\t\t \n};\n\n#define COMPRESS_HEADER_SIZE\t(sizeof(struct compress_data))\n\n#define F2FS_COMPRESSED_PAGE_MAGIC\t0xF5F2C000\n\n#define F2FS_ZSTD_DEFAULT_CLEVEL\t1\n\n#define\tCOMPRESS_LEVEL_OFFSET\t8\n\n \nstruct compress_ctx {\n\tstruct inode *inode;\t\t \n\tpgoff_t cluster_idx;\t\t \n\tunsigned int cluster_size;\t \n\tunsigned int log_cluster_size;\t \n\tstruct page **rpages;\t\t \n\tunsigned int nr_rpages;\t\t \n\tstruct page **cpages;\t\t \n\tunsigned int nr_cpages;\t\t \n\tunsigned int valid_nr_cpages;\t \n\tvoid *rbuf;\t\t\t \n\tstruct compress_data *cbuf;\t \n\tsize_t rlen;\t\t\t \n\tsize_t clen;\t\t\t \n\tvoid *private;\t\t\t \n\tvoid *private2;\t\t\t \n};\n\n \nstruct compress_io_ctx {\n\tu32 magic;\t\t\t \n\tstruct inode *inode;\t\t \n\tstruct page **rpages;\t\t \n\tunsigned int nr_rpages;\t\t \n\tatomic_t pending_pages;\t\t \n};\n\n \nstruct decompress_io_ctx {\n\tu32 magic;\t\t\t \n\tstruct inode *inode;\t\t \n\tpgoff_t cluster_idx;\t\t \n\tunsigned int cluster_size;\t \n\tunsigned int log_cluster_size;\t \n\tstruct page **rpages;\t\t \n\tunsigned int nr_rpages;\t\t \n\tstruct page **cpages;\t\t \n\tunsigned int nr_cpages;\t\t \n\tstruct page **tpages;\t\t \n\tvoid *rbuf;\t\t\t \n\tstruct compress_data *cbuf;\t \n\tsize_t rlen;\t\t\t \n\tsize_t clen;\t\t\t \n\n\t \n\tatomic_t remaining_pages;\n\n\t \n\trefcount_t refcnt;\n\n\tbool failed;\t\t\t \n\tbool need_verity;\t\t \n\tvoid *private;\t\t\t \n\tvoid *private2;\t\t\t \n\tstruct work_struct verity_work;\t \n\tstruct work_struct free_work;\t \n};\n\n#define NULL_CLUSTER\t\t\t((unsigned int)(~0))\n#define MIN_COMPRESS_LOG_SIZE\t\t2\n#define MAX_COMPRESS_LOG_SIZE\t\t8\n#define MAX_COMPRESS_WINDOW_SIZE(log_size)\t((PAGE_SIZE) << (log_size))\n\nstruct f2fs_sb_info {\n\tstruct super_block *sb;\t\t\t \n\tstruct proc_dir_entry *s_proc;\t\t \n\tstruct f2fs_super_block *raw_super;\t \n\tstruct f2fs_rwsem sb_lock;\t\t \n\tint valid_super_block;\t\t\t \n\tunsigned long s_flag;\t\t\t\t \n\tstruct mutex writepages;\t\t \n\n#ifdef CONFIG_BLK_DEV_ZONED\n\tunsigned int blocks_per_blkz;\t\t \n#endif\n\n\t \n\tstruct f2fs_nm_info *nm_info;\t\t \n\tstruct inode *node_inode;\t\t \n\n\t \n\tstruct f2fs_sm_info *sm_info;\t\t \n\n\t \n\tstruct f2fs_bio_info *write_io[NR_PAGE_TYPE];\t \n\t \n\tstruct f2fs_rwsem io_order_lock;\n\tmempool_t *write_io_dummy;\t\t \n\tpgoff_t page_eio_ofs[NR_PAGE_TYPE];\t \n\tint page_eio_cnt[NR_PAGE_TYPE];\t\t \n\n\t \n\tstruct f2fs_checkpoint *ckpt;\t\t \n\tint cur_cp_pack;\t\t\t \n\tspinlock_t cp_lock;\t\t\t \n\tstruct inode *meta_inode;\t\t \n\tstruct f2fs_rwsem cp_global_sem;\t \n\tstruct f2fs_rwsem cp_rwsem;\t\t \n\tstruct f2fs_rwsem node_write;\t\t \n\tstruct f2fs_rwsem node_change;\t \n\twait_queue_head_t cp_wait;\n\tunsigned long last_time[MAX_TIME];\t \n\tlong interval_time[MAX_TIME];\t\t \n\tstruct ckpt_req_control cprc_info;\t \n\n\tstruct inode_management im[MAX_INO_ENTRY];\t \n\n\tspinlock_t fsync_node_lock;\t\t \n\tstruct list_head fsync_node_list;\t \n\tunsigned int fsync_seg_id;\t\t \n\tunsigned int fsync_node_num;\t\t \n\n\t \n\tunsigned int max_orphans;\t\t \n\n\t \n\tstruct list_head inode_list[NR_INODE_TYPE];\t \n\tspinlock_t inode_lock[NR_INODE_TYPE];\t \n\tstruct mutex flush_lock;\t\t \n\n\t \n\tstruct extent_tree_info extent_tree[NR_EXTENT_CACHES];\n\tatomic64_t allocated_data_blocks;\t \n\n\t \n\tunsigned int hot_data_age_threshold;\n\tunsigned int warm_data_age_threshold;\n\tunsigned int last_age_weight;\n\n\t \n\tunsigned int log_sectors_per_block;\t \n\tunsigned int log_blocksize;\t\t \n\tunsigned int blocksize;\t\t\t \n\tunsigned int root_ino_num;\t\t \n\tunsigned int node_ino_num;\t\t \n\tunsigned int meta_ino_num;\t\t \n\tunsigned int log_blocks_per_seg;\t \n\tunsigned int blocks_per_seg;\t\t \n\tunsigned int unusable_blocks_per_sec;\t \n\tunsigned int segs_per_sec;\t\t \n\tunsigned int secs_per_zone;\t\t \n\tunsigned int total_sections;\t\t \n\tunsigned int total_node_count;\t\t \n\tunsigned int total_valid_node_count;\t \n\tint dir_level;\t\t\t\t \n\tbool readdir_ra;\t\t\t \n\tu64 max_io_bytes;\t\t\t \n\n\tblock_t user_block_count;\t\t \n\tblock_t total_valid_block_count;\t \n\tblock_t discard_blks;\t\t\t \n\tblock_t last_valid_block_count;\t\t \n\tblock_t reserved_blocks;\t\t \n\tblock_t current_reserved_blocks;\t \n\n\t \n\tblock_t unusable_block_count;\t\t \n\n\tunsigned int nquota_files;\t\t \n\tstruct f2fs_rwsem quota_sem;\t\t \n\n\t \n\tatomic_t nr_pages[NR_COUNT_TYPE];\n\t \n\tstruct percpu_counter alloc_valid_block_count;\n\t \n\tstruct percpu_counter rf_node_block_count;\n\n\t \n\tatomic_t wb_sync_req[META];\t \n\n\t \n\tstruct percpu_counter total_valid_inode_count;\n\n\tstruct f2fs_mount_info mount_opt;\t \n\n\t \n\tstruct f2fs_rwsem gc_lock;\t\t \n\tstruct f2fs_gc_kthread\t*gc_thread;\t \n\tstruct atgc_management am;\t\t \n\tunsigned int cur_victim_sec;\t\t \n\tunsigned int gc_mode;\t\t\t \n\tunsigned int next_victim_seg[2];\t \n\tspinlock_t gc_remaining_trials_lock;\n\t \n\tunsigned int gc_remaining_trials;\n\n\t \n\tunsigned long long skipped_gc_rwsem;\t\t \n\n\t \n\tu64 gc_pin_file_threshold;\n\tstruct f2fs_rwsem pin_sem;\n\n\t \n\tunsigned int max_victim_search;\n\t \n\tunsigned int migration_granularity;\n\n\t \n#ifdef CONFIG_F2FS_STAT_FS\n\tstruct f2fs_stat_info *stat_info;\t \n\tatomic_t meta_count[META_MAX];\t\t \n\tunsigned int segment_count[2];\t\t \n\tunsigned int block_count[2];\t\t \n\tatomic_t inplace_count;\t\t \n\t \n\tatomic64_t total_hit_ext[NR_EXTENT_CACHES];\n\t \n\tatomic64_t read_hit_rbtree[NR_EXTENT_CACHES];\n\t \n\tatomic64_t read_hit_cached[NR_EXTENT_CACHES];\n\t \n\tatomic64_t read_hit_largest;\n\tatomic_t inline_xattr;\t\t\t \n\tatomic_t inline_inode;\t\t\t \n\tatomic_t inline_dir;\t\t\t \n\tatomic_t compr_inode;\t\t\t \n\tatomic64_t compr_blocks;\t\t \n\tatomic_t swapfile_inode;\t\t \n\tatomic_t atomic_files;\t\t\t \n\tatomic_t max_aw_cnt;\t\t\t \n\tunsigned int io_skip_bggc;\t\t \n\tunsigned int other_skip_bggc;\t\t \n\tunsigned int ndirty_inode[NR_INODE_TYPE];\t \n\tatomic_t cp_call_count[MAX_CALL_TYPE];\t \n#endif\n\tspinlock_t stat_lock;\t\t\t \n\n\t \n\tunsigned int data_io_flag;\n\tunsigned int node_io_flag;\n\n\t \n\tstruct kobject s_kobj;\t\t\t \n\tstruct completion s_kobj_unregister;\n\n\tstruct kobject s_stat_kobj;\t\t \n\tstruct completion s_stat_kobj_unregister;\n\n\tstruct kobject s_feature_list_kobj;\t\t \n\tstruct completion s_feature_list_kobj_unregister;\n\n\t \n\tstruct list_head s_list;\n\tstruct mutex umount_mutex;\n\tunsigned int shrinker_run_no;\n\n\t \n\tint s_ndevs;\t\t\t\t \n\tstruct f2fs_dev_info *devs;\t\t \n\tunsigned int dirty_device;\t\t \n\tspinlock_t dev_lock;\t\t\t \n\tbool aligned_blksize;\t\t\t \n\n\t \n\tu64 sectors_written_start;\n\tu64 kbytes_written;\n\n\t \n\tstruct crypto_shash *s_chksum_driver;\n\n\t \n\t__u32 s_chksum_seed;\n\n\tstruct workqueue_struct *post_read_wq;\t \n\n\t \n\tstruct work_struct s_error_work;\n\tunsigned char errors[MAX_F2FS_ERRORS];\t\t \n\tunsigned char stop_reason[MAX_STOP_REASON];\t \n\tspinlock_t error_lock;\t\t\t \n\tbool error_dirty;\t\t\t \n\n\tstruct kmem_cache *inline_xattr_slab;\t \n\tunsigned int inline_xattr_slab_size;\t \n\n\t \n\tunsigned int gc_segment_mode;\t\t \n\tunsigned int gc_reclaimed_segs[MAX_GC_MODE];\t \n\n\tunsigned long seq_file_ra_mul;\t\t \n\n\tint max_fragment_chunk;\t\t\t \n\tint max_fragment_hole;\t\t\t \n\n\t \n\tatomic64_t current_atomic_write;\n\ts64 peak_atomic_write;\n\tu64 committed_atomic_block;\n\tu64 revoked_atomic_block;\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tstruct kmem_cache *page_array_slab;\t \n\tunsigned int page_array_slab_size;\t \n\n\t \n\tu64 compr_written_block;\n\tu64 compr_saved_block;\n\tu32 compr_new_inode;\n\n\t \n\tstruct inode *compress_inode;\t\t \n\tunsigned int compress_percent;\t\t \n\tunsigned int compress_watermark;\t \n\tatomic_t compress_page_hit;\t\t \n#endif\n\n#ifdef CONFIG_F2FS_IOSTAT\n\t \n\tspinlock_t iostat_lock;\n\tunsigned long long iostat_count[NR_IO_TYPE];\n\tunsigned long long iostat_bytes[NR_IO_TYPE];\n\tunsigned long long prev_iostat_bytes[NR_IO_TYPE];\n\tbool iostat_enable;\n\tunsigned long iostat_next_period;\n\tunsigned int iostat_period_ms;\n\n\t \n\tspinlock_t iostat_lat_lock;\n\tstruct iostat_lat_info *iostat_io_lat;\n#endif\n};\n\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n#define time_to_inject(sbi, type) __time_to_inject(sbi, type, __func__,\t\\\n\t\t\t\t\t\t\t\t\t__builtin_return_address(0))\nstatic inline bool __time_to_inject(struct f2fs_sb_info *sbi, int type,\n\t\t\t\tconst char *func, const char *parent_func)\n{\n\tstruct f2fs_fault_info *ffi = &F2FS_OPTION(sbi).fault_info;\n\n\tif (!ffi->inject_rate)\n\t\treturn false;\n\n\tif (!IS_FAULT_SET(ffi, type))\n\t\treturn false;\n\n\tatomic_inc(&ffi->inject_ops);\n\tif (atomic_read(&ffi->inject_ops) >= ffi->inject_rate) {\n\t\tatomic_set(&ffi->inject_ops, 0);\n\t\tprintk_ratelimited(\"%sF2FS-fs (%s) : inject %s in %s of %pS\\n\",\n\t\t\tKERN_INFO, sbi->sb->s_id, f2fs_fault_name[type],\n\t\t\tfunc, parent_func);\n\t\treturn true;\n\t}\n\treturn false;\n}\n#else\nstatic inline bool time_to_inject(struct f2fs_sb_info *sbi, int type)\n{\n\treturn false;\n}\n#endif\n\n \nstatic inline bool f2fs_is_multi_device(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->s_ndevs > 1;\n}\n\nstatic inline void f2fs_update_time(struct f2fs_sb_info *sbi, int type)\n{\n\tunsigned long now = jiffies;\n\n\tsbi->last_time[type] = now;\n\n\t \n\tif (type == REQ_TIME) {\n\t\tsbi->last_time[DISCARD_TIME] = now;\n\t\tsbi->last_time[GC_TIME] = now;\n\t}\n}\n\nstatic inline bool f2fs_time_over(struct f2fs_sb_info *sbi, int type)\n{\n\tunsigned long interval = sbi->interval_time[type] * HZ;\n\n\treturn time_after(jiffies, sbi->last_time[type] + interval);\n}\n\nstatic inline unsigned int f2fs_time_to_wait(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tint type)\n{\n\tunsigned long interval = sbi->interval_time[type] * HZ;\n\tunsigned int wait_ms = 0;\n\tlong delta;\n\n\tdelta = (sbi->last_time[type] + interval) - jiffies;\n\tif (delta > 0)\n\t\twait_ms = jiffies_to_msecs(delta);\n\n\treturn wait_ms;\n}\n\n \nstatic inline u32 __f2fs_crc32(struct f2fs_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver) != sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}\n\nstatic inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,\n\t\t\t   unsigned int length)\n{\n\treturn __f2fs_crc32(sbi, F2FS_SUPER_MAGIC, address, length);\n}\n\nstatic inline bool f2fs_crc_valid(struct f2fs_sb_info *sbi, __u32 blk_crc,\n\t\t\t\t  void *buf, size_t buf_size)\n{\n\treturn f2fs_crc32(sbi, buf, buf_size) == blk_crc;\n}\n\nstatic inline u32 f2fs_chksum(struct f2fs_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\treturn __f2fs_crc32(sbi, crc, address, length);\n}\n\nstatic inline struct f2fs_inode_info *F2FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct f2fs_inode_info, vfs_inode);\n}\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}\n\nstatic inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)\n{\n\treturn F2FS_I_SB(mapping->host);\n}\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page_file_mapping(page));\n}\n\nstatic inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_super_block *)(sbi->raw_super);\n}\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}\n\nstatic inline struct f2fs_node *F2FS_NODE(struct page *page)\n{\n\treturn (struct f2fs_node *)page_address(page);\n}\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}\n\nstatic inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_nm_info *)(sbi->nm_info);\n}\n\nstatic inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_sm_info *)(sbi->sm_info);\n}\n\nstatic inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct sit_info *)(SM_I(sbi)->sit_info);\n}\n\nstatic inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct free_segmap_info *)(SM_I(sbi)->free_info);\n}\n\nstatic inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)\n{\n\treturn (struct dirty_seglist_info *)(SM_I(sbi)->dirty_info);\n}\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}\n\nstatic inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\treturn test_bit(type, &sbi->s_flag);\n}\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tset_bit(type, &sbi->s_flag);\n}\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tclear_bit(type, &sbi->s_flag);\n}\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}\n\nstatic inline unsigned long f2fs_qf_ino(struct super_block *sb, int type)\n{\n\tif (type < F2FS_MAX_QUOTAS)\n\t\treturn le32_to_cpu(F2FS_SB(sb)->raw_super->qf_ino[type]);\n\treturn 0;\n}\n\nstatic inline __u64 cur_cp_crc(struct f2fs_checkpoint *cp)\n{\n\tsize_t crc_offset = le32_to_cpu(cp->checksum_offset);\n\treturn le32_to_cpu(*((__le32 *)((unsigned char *)cp + crc_offset)));\n}\n\nstatic inline bool __is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\n\treturn ckpt_flags & f;\n}\n\nstatic inline bool is_set_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)\n{\n\treturn __is_set_ckpt_flags(F2FS_CKPT(sbi), f);\n}\n\nstatic inline void __set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags;\n\n\tckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags |= f;\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}\n\nstatic inline void set_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->cp_lock, flags);\n\t__set_ckpt_flags(F2FS_CKPT(sbi), f);\n\tspin_unlock_irqrestore(&sbi->cp_lock, flags);\n}\n\nstatic inline void __clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags;\n\n\tckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags &= (~f);\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}\n\nstatic inline void clear_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->cp_lock, flags);\n\t__clear_ckpt_flags(F2FS_CKPT(sbi), f);\n\tspin_unlock_irqrestore(&sbi->cp_lock, flags);\n}\n\n#define init_f2fs_rwsem(sem)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__init_f2fs_rwsem((sem), #sem, &__key);\t\t\t\\\n} while (0)\n\nstatic inline void __init_f2fs_rwsem(struct f2fs_rwsem *sem,\n\t\tconst char *sem_name, struct lock_class_key *key)\n{\n\t__init_rwsem(&sem->internal_rwsem, sem_name, key);\n#ifdef CONFIG_F2FS_UNFAIR_RWSEM\n\tinit_waitqueue_head(&sem->read_waiters);\n#endif\n}\n\nstatic inline int f2fs_rwsem_is_locked(struct f2fs_rwsem *sem)\n{\n\treturn rwsem_is_locked(&sem->internal_rwsem);\n}\n\nstatic inline int f2fs_rwsem_is_contended(struct f2fs_rwsem *sem)\n{\n\treturn rwsem_is_contended(&sem->internal_rwsem);\n}\n\nstatic inline void f2fs_down_read(struct f2fs_rwsem *sem)\n{\n#ifdef CONFIG_F2FS_UNFAIR_RWSEM\n\twait_event(sem->read_waiters, down_read_trylock(&sem->internal_rwsem));\n#else\n\tdown_read(&sem->internal_rwsem);\n#endif\n}\n\nstatic inline int f2fs_down_read_trylock(struct f2fs_rwsem *sem)\n{\n\treturn down_read_trylock(&sem->internal_rwsem);\n}\n\nstatic inline void f2fs_up_read(struct f2fs_rwsem *sem)\n{\n\tup_read(&sem->internal_rwsem);\n}\n\nstatic inline void f2fs_down_write(struct f2fs_rwsem *sem)\n{\n\tdown_write(&sem->internal_rwsem);\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic inline void f2fs_down_read_nested(struct f2fs_rwsem *sem, int subclass)\n{\n\tdown_read_nested(&sem->internal_rwsem, subclass);\n}\n\nstatic inline void f2fs_down_write_nested(struct f2fs_rwsem *sem, int subclass)\n{\n\tdown_write_nested(&sem->internal_rwsem, subclass);\n}\n#else\n#define f2fs_down_read_nested(sem, subclass) f2fs_down_read(sem)\n#define f2fs_down_write_nested(sem, subclass) f2fs_down_write(sem)\n#endif\n\nstatic inline int f2fs_down_write_trylock(struct f2fs_rwsem *sem)\n{\n\treturn down_write_trylock(&sem->internal_rwsem);\n}\n\nstatic inline void f2fs_up_write(struct f2fs_rwsem *sem)\n{\n\tup_write(&sem->internal_rwsem);\n#ifdef CONFIG_F2FS_UNFAIR_RWSEM\n\twake_up_all(&sem->read_waiters);\n#endif\n}\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tf2fs_down_read(&sbi->cp_rwsem);\n}\n\nstatic inline int f2fs_trylock_op(struct f2fs_sb_info *sbi)\n{\n\tif (time_to_inject(sbi, FAULT_LOCK_OP))\n\t\treturn 0;\n\treturn f2fs_down_read_trylock(&sbi->cp_rwsem);\n}\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tf2fs_up_read(&sbi->cp_rwsem);\n}\n\nstatic inline void f2fs_lock_all(struct f2fs_sb_info *sbi)\n{\n\tf2fs_down_write(&sbi->cp_rwsem);\n}\n\nstatic inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)\n{\n\tf2fs_up_write(&sbi->cp_rwsem);\n}\n\nstatic inline int __get_cp_reason(struct f2fs_sb_info *sbi)\n{\n\tint reason = CP_SYNC;\n\n\tif (test_opt(sbi, FASTBOOT))\n\t\treason = CP_FASTBOOT;\n\tif (is_sbi_flag_set(sbi, SBI_IS_CLOSE))\n\t\treason = CP_UMOUNT;\n\treturn reason;\n}\n\nstatic inline bool __remain_node_summaries(int reason)\n{\n\treturn (reason & (CP_UMOUNT | CP_FASTBOOT));\n}\n\nstatic inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)\n{\n\treturn (is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG) ||\n\t\t\tis_set_ckpt_flags(sbi, CP_FASTBOOT_FLAG));\n}\n\n \nstatic inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tblock_t xattr_block = F2FS_I(inode)->i_xattr_nid ? 1 : 0;\n\n\treturn (inode->i_blocks >> F2FS_LOG_SECTORS_PER_BLOCK) > xattr_block;\n}\n\nstatic inline bool f2fs_has_xattr_block(unsigned int ofs)\n{\n\treturn ofs == XATTR_NODE_OFFSET;\n}\n\nstatic inline bool __allow_reserved_blocks(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode, bool cap)\n{\n\tif (!inode)\n\t\treturn true;\n\tif (!test_opt(sbi, RESERVE_ROOT))\n\t\treturn false;\n\tif (IS_NOQUOTA(inode))\n\t\treturn true;\n\tif (uid_eq(F2FS_OPTION(sbi).s_resuid, current_fsuid()))\n\t\treturn true;\n\tif (!gid_eq(F2FS_OPTION(sbi).s_resgid, GLOBAL_ROOT_GID) &&\n\t\t\t\t\tin_group_p(F2FS_OPTION(sbi).s_resgid))\n\t\treturn true;\n\tif (cap && capable(CAP_SYS_RESOURCE))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline void f2fs_i_blocks_write(struct inode *, block_t, bool, bool);\nstatic inline int inc_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t struct inode *inode, blkcnt_t *count)\n{\n\tblkcnt_t diff = 0, release = 0;\n\tblock_t avail_user_block_count;\n\tint ret;\n\n\tret = dquot_reserve_block(inode, *count);\n\tif (ret)\n\t\treturn ret;\n\n\tif (time_to_inject(sbi, FAULT_BLOCK)) {\n\t\trelease = *count;\n\t\tgoto release_quota;\n\t}\n\n\t \n\tpercpu_counter_add(&sbi->alloc_valid_block_count, (*count));\n\n\tspin_lock(&sbi->stat_lock);\n\tsbi->total_valid_block_count += (block_t)(*count);\n\tavail_user_block_count = sbi->user_block_count -\n\t\t\t\t\tsbi->current_reserved_blocks;\n\n\tif (!__allow_reserved_blocks(sbi, inode, true))\n\t\tavail_user_block_count -= F2FS_OPTION(sbi).root_reserved_blocks;\n\n\tif (F2FS_IO_ALIGNED(sbi))\n\t\tavail_user_block_count -= sbi->blocks_per_seg *\n\t\t\t\tSM_I(sbi)->additional_reserved_segments;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\tif (avail_user_block_count > sbi->unusable_block_count)\n\t\t\tavail_user_block_count -= sbi->unusable_block_count;\n\t\telse\n\t\t\tavail_user_block_count = 0;\n\t}\n\tif (unlikely(sbi->total_valid_block_count > avail_user_block_count)) {\n\t\tdiff = sbi->total_valid_block_count - avail_user_block_count;\n\t\tif (diff > *count)\n\t\t\tdiff = *count;\n\t\t*count -= diff;\n\t\trelease = diff;\n\t\tsbi->total_valid_block_count -= diff;\n\t\tif (!*count) {\n\t\t\tspin_unlock(&sbi->stat_lock);\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\tspin_unlock(&sbi->stat_lock);\n\n\tif (unlikely(release)) {\n\t\tpercpu_counter_sub(&sbi->alloc_valid_block_count, release);\n\t\tdquot_release_reservation_block(inode, release);\n\t}\n\tf2fs_i_blocks_write(inode, *count, true, true);\n\treturn 0;\n\nenospc:\n\tpercpu_counter_sub(&sbi->alloc_valid_block_count, release);\nrelease_quota:\n\tdquot_release_reservation_block(inode, release);\n\treturn -ENOSPC;\n}\n\n__printf(2, 3)\nvoid f2fs_printk(struct f2fs_sb_info *sbi, const char *fmt, ...);\n\n#define f2fs_err(sbi, fmt, ...)\t\t\t\t\t\t\\\n\tf2fs_printk(sbi, KERN_ERR fmt, ##__VA_ARGS__)\n#define f2fs_warn(sbi, fmt, ...)\t\t\t\t\t\\\n\tf2fs_printk(sbi, KERN_WARNING fmt, ##__VA_ARGS__)\n#define f2fs_notice(sbi, fmt, ...)\t\t\t\t\t\\\n\tf2fs_printk(sbi, KERN_NOTICE fmt, ##__VA_ARGS__)\n#define f2fs_info(sbi, fmt, ...)\t\t\t\t\t\\\n\tf2fs_printk(sbi, KERN_INFO fmt, ##__VA_ARGS__)\n#define f2fs_debug(sbi, fmt, ...)\t\t\t\t\t\\\n\tf2fs_printk(sbi, KERN_DEBUG fmt, ##__VA_ARGS__)\n\n#define PAGE_PRIVATE_GET_FUNC(name, flagname) \\\nstatic inline bool page_private_##name(struct page *page) \\\n{ \\\n\treturn PagePrivate(page) && \\\n\t\ttest_bit(PAGE_PRIVATE_NOT_POINTER, &page_private(page)) && \\\n\t\ttest_bit(PAGE_PRIVATE_##flagname, &page_private(page)); \\\n}\n\n#define PAGE_PRIVATE_SET_FUNC(name, flagname) \\\nstatic inline void set_page_private_##name(struct page *page) \\\n{ \\\n\tif (!PagePrivate(page)) \\\n\t\tattach_page_private(page, (void *)0); \\\n\tset_bit(PAGE_PRIVATE_NOT_POINTER, &page_private(page)); \\\n\tset_bit(PAGE_PRIVATE_##flagname, &page_private(page)); \\\n}\n\n#define PAGE_PRIVATE_CLEAR_FUNC(name, flagname) \\\nstatic inline void clear_page_private_##name(struct page *page) \\\n{ \\\n\tclear_bit(PAGE_PRIVATE_##flagname, &page_private(page)); \\\n\tif (page_private(page) == BIT(PAGE_PRIVATE_NOT_POINTER)) \\\n\t\tdetach_page_private(page); \\\n}\n\nPAGE_PRIVATE_GET_FUNC(nonpointer, NOT_POINTER);\nPAGE_PRIVATE_GET_FUNC(inline, INLINE_INODE);\nPAGE_PRIVATE_GET_FUNC(gcing, ONGOING_MIGRATION);\nPAGE_PRIVATE_GET_FUNC(dummy, DUMMY_WRITE);\n\nPAGE_PRIVATE_SET_FUNC(reference, REF_RESOURCE);\nPAGE_PRIVATE_SET_FUNC(inline, INLINE_INODE);\nPAGE_PRIVATE_SET_FUNC(gcing, ONGOING_MIGRATION);\nPAGE_PRIVATE_SET_FUNC(dummy, DUMMY_WRITE);\n\nPAGE_PRIVATE_CLEAR_FUNC(reference, REF_RESOURCE);\nPAGE_PRIVATE_CLEAR_FUNC(inline, INLINE_INODE);\nPAGE_PRIVATE_CLEAR_FUNC(gcing, ONGOING_MIGRATION);\nPAGE_PRIVATE_CLEAR_FUNC(dummy, DUMMY_WRITE);\n\nstatic inline unsigned long get_page_private_data(struct page *page)\n{\n\tunsigned long data = page_private(page);\n\n\tif (!test_bit(PAGE_PRIVATE_NOT_POINTER, &data))\n\t\treturn 0;\n\treturn data >> PAGE_PRIVATE_MAX;\n}\n\nstatic inline void set_page_private_data(struct page *page, unsigned long data)\n{\n\tif (!PagePrivate(page))\n\t\tattach_page_private(page, (void *)0);\n\tset_bit(PAGE_PRIVATE_NOT_POINTER, &page_private(page));\n\tpage_private(page) |= data << PAGE_PRIVATE_MAX;\n}\n\nstatic inline void clear_page_private_data(struct page *page)\n{\n\tpage_private(page) &= GENMASK(PAGE_PRIVATE_MAX - 1, 0);\n\tif (page_private(page) == BIT(PAGE_PRIVATE_NOT_POINTER))\n\t\tdetach_page_private(page);\n}\n\nstatic inline void clear_page_private_all(struct page *page)\n{\n\tclear_page_private_data(page);\n\tclear_page_private_reference(page);\n\tclear_page_private_gcing(page);\n\tclear_page_private_inline(page);\n\n\tf2fs_bug_on(F2FS_P_SB(page), page_private(page));\n}\n\nstatic inline void dec_valid_block_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tblock_t count)\n{\n\tblkcnt_t sectors = count << F2FS_LOG_SECTORS_PER_BLOCK;\n\n\tspin_lock(&sbi->stat_lock);\n\tf2fs_bug_on(sbi, sbi->total_valid_block_count < (block_t) count);\n\tsbi->total_valid_block_count -= (block_t)count;\n\tif (sbi->reserved_blocks &&\n\t\tsbi->current_reserved_blocks < sbi->reserved_blocks)\n\t\tsbi->current_reserved_blocks = min(sbi->reserved_blocks,\n\t\t\t\t\tsbi->current_reserved_blocks + count);\n\tspin_unlock(&sbi->stat_lock);\n\tif (unlikely(inode->i_blocks < sectors)) {\n\t\tf2fs_warn(sbi, \"Inconsistent i_blocks, ino:%lu, iblocks:%llu, sectors:%llu\",\n\t\t\t  inode->i_ino,\n\t\t\t  (unsigned long long)inode->i_blocks,\n\t\t\t  (unsigned long long)sectors);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\treturn;\n\t}\n\tf2fs_i_blocks_write(inode, count, false, true);\n}\n\nstatic inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_inc(&sbi->nr_pages[count_type]);\n\n\tif (count_type == F2FS_DIRTY_DENTS ||\n\t\t\tcount_type == F2FS_DIRTY_NODES ||\n\t\t\tcount_type == F2FS_DIRTY_META ||\n\t\t\tcount_type == F2FS_DIRTY_QDATA ||\n\t\t\tcount_type == F2FS_DIRTY_IMETA)\n\t\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n}\n\nstatic inline void inode_inc_dirty_pages(struct inode *inode)\n{\n\tatomic_inc(&F2FS_I(inode)->dirty_pages);\n\tinc_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?\n\t\t\t\tF2FS_DIRTY_DENTS : F2FS_DIRTY_DATA);\n\tif (IS_NOQUOTA(inode))\n\t\tinc_page_count(F2FS_I_SB(inode), F2FS_DIRTY_QDATA);\n}\n\nstatic inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)\n{\n\tatomic_dec(&sbi->nr_pages[count_type]);\n}\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISLNK(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\tdec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?\n\t\t\t\tF2FS_DIRTY_DENTS : F2FS_DIRTY_DATA);\n\tif (IS_NOQUOTA(inode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_QDATA);\n}\n\nstatic inline void inc_atomic_write_cnt(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tu64 current_write;\n\n\tfi->atomic_write_cnt++;\n\tatomic64_inc(&sbi->current_atomic_write);\n\tcurrent_write = atomic64_read(&sbi->current_atomic_write);\n\tif (current_write > sbi->peak_atomic_write)\n\t\tsbi->peak_atomic_write = current_write;\n}\n\nstatic inline void release_atomic_write_cnt(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\n\tatomic64_sub(fi->atomic_write_cnt, &sbi->current_atomic_write);\n\tfi->atomic_write_cnt = 0;\n}\n\nstatic inline s64 get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}\n\nstatic inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}\n\nstatic inline int get_blocktype_secs(struct f2fs_sb_info *sbi, int block_type)\n{\n\tunsigned int pages_per_sec = sbi->segs_per_sec * sbi->blocks_per_seg;\n\tunsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>\n\t\t\t\t\t\tsbi->log_blocks_per_seg;\n\n\treturn segs / sbi->segs_per_sec;\n}\n\nstatic inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_block_count;\n}\n\nstatic inline block_t discard_blocks(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->discard_blks;\n}\n\nstatic inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\n\t \n\tif (flag == NAT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->nat_ver_bitmap_bytesize);\n\telse if (flag == SIT_BITMAP)\n\t\treturn le32_to_cpu(ckpt->sit_ver_bitmap_bytesize);\n\n\treturn 0;\n}\n\nstatic inline block_t __cp_payload(struct f2fs_sb_info *sbi)\n{\n\treturn le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n}\n\nstatic inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tvoid *tmp_ptr = &ckpt->sit_nat_version_bitmap;\n\tint offset;\n\n\tif (is_set_ckpt_flags(sbi, CP_LARGE_NAT_BITMAP_FLAG)) {\n\t\toffset = (flag == SIT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->nat_ver_bitmap_bytesize) : 0;\n\t\t \n\t\treturn tmp_ptr + offset + sizeof(__le32);\n\t}\n\n\tif (__cp_payload(sbi) > 0) {\n\t\tif (flag == NAT_BITMAP)\n\t\t\treturn tmp_ptr;\n\t\telse\n\t\t\treturn (unsigned char *)ckpt + F2FS_BLKSIZE;\n\t} else {\n\t\toffset = (flag == NAT_BITMAP) ?\n\t\t\tle32_to_cpu(ckpt->sit_ver_bitmap_bytesize) : 0;\n\t\treturn tmp_ptr + offset;\n\t}\n}\n\nstatic inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\tif (sbi->cur_cp_pack == 2)\n\t\tstart_addr += sbi->blocks_per_seg;\n\treturn start_addr;\n}\n\nstatic inline block_t __start_cp_next_addr(struct f2fs_sb_info *sbi)\n{\n\tblock_t start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_blkaddr);\n\n\tif (sbi->cur_cp_pack == 1)\n\t\tstart_addr += sbi->blocks_per_seg;\n\treturn start_addr;\n}\n\nstatic inline void __set_cp_next_pack(struct f2fs_sb_info *sbi)\n{\n\tsbi->cur_cp_pack = (sbi->cur_cp_pack == 1) ? 2 : 1;\n}\n\nstatic inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)\n{\n\treturn le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);\n}\n\nextern void f2fs_mark_inode_dirty_sync(struct inode *inode, bool sync);\nstatic inline int inc_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode, bool is_inode)\n{\n\tblock_t\tvalid_block_count;\n\tunsigned int valid_node_count, user_block_count;\n\tint err;\n\n\tif (is_inode) {\n\t\tif (inode) {\n\t\t\terr = dquot_alloc_inode(inode);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\terr = dquot_reserve_block(inode, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (time_to_inject(sbi, FAULT_BLOCK))\n\t\tgoto enospc;\n\n\tspin_lock(&sbi->stat_lock);\n\n\tvalid_block_count = sbi->total_valid_block_count +\n\t\t\t\t\tsbi->current_reserved_blocks + 1;\n\n\tif (!__allow_reserved_blocks(sbi, inode, false))\n\t\tvalid_block_count += F2FS_OPTION(sbi).root_reserved_blocks;\n\n\tif (F2FS_IO_ALIGNED(sbi))\n\t\tvalid_block_count += sbi->blocks_per_seg *\n\t\t\t\tSM_I(sbi)->additional_reserved_segments;\n\n\tuser_block_count = sbi->user_block_count;\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\tuser_block_count -= sbi->unusable_block_count;\n\n\tif (unlikely(valid_block_count > user_block_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\tgoto enospc;\n\t}\n\n\tvalid_node_count = sbi->total_valid_node_count + 1;\n\tif (unlikely(valid_node_count > sbi->total_node_count)) {\n\t\tspin_unlock(&sbi->stat_lock);\n\t\tgoto enospc;\n\t}\n\n\tsbi->total_valid_node_count++;\n\tsbi->total_valid_block_count++;\n\tspin_unlock(&sbi->stat_lock);\n\n\tif (inode) {\n\t\tif (is_inode)\n\t\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t\telse\n\t\t\tf2fs_i_blocks_write(inode, 1, true, true);\n\t}\n\n\tpercpu_counter_inc(&sbi->alloc_valid_block_count);\n\treturn 0;\n\nenospc:\n\tif (is_inode) {\n\t\tif (inode)\n\t\t\tdquot_free_inode(inode);\n\t} else {\n\t\tdquot_release_reservation_block(inode, 1);\n\t}\n\treturn -ENOSPC;\n}\n\nstatic inline void dec_valid_node_count(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode, bool is_inode)\n{\n\tspin_lock(&sbi->stat_lock);\n\n\tif (unlikely(!sbi->total_valid_block_count ||\n\t\t\t!sbi->total_valid_node_count)) {\n\t\tf2fs_warn(sbi, \"dec_valid_node_count: inconsistent block counts, total_valid_block:%u, total_valid_node:%u\",\n\t\t\t  sbi->total_valid_block_count,\n\t\t\t  sbi->total_valid_node_count);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t} else {\n\t\tsbi->total_valid_block_count--;\n\t\tsbi->total_valid_node_count--;\n\t}\n\n\tif (sbi->reserved_blocks &&\n\t\tsbi->current_reserved_blocks < sbi->reserved_blocks)\n\t\tsbi->current_reserved_blocks++;\n\n\tspin_unlock(&sbi->stat_lock);\n\n\tif (is_inode) {\n\t\tdquot_free_inode(inode);\n\t} else {\n\t\tif (unlikely(inode->i_blocks == 0)) {\n\t\t\tf2fs_warn(sbi, \"dec_valid_node_count: inconsistent i_blocks, ino:%lu, iblocks:%llu\",\n\t\t\t\t  inode->i_ino,\n\t\t\t\t  (unsigned long long)inode->i_blocks);\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\treturn;\n\t\t}\n\t\tf2fs_i_blocks_write(inode, 1, false, true);\n\t}\n}\n\nstatic inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->total_valid_node_count;\n}\n\nstatic inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tpercpu_counter_inc(&sbi->total_valid_inode_count);\n}\n\nstatic inline void dec_valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\tpercpu_counter_dec(&sbi->total_valid_inode_count);\n}\n\nstatic inline s64 valid_inode_count(struct f2fs_sb_info *sbi)\n{\n\treturn percpu_counter_sum_positive(&sbi->total_valid_inode_count);\n}\n\nstatic inline struct page *f2fs_grab_cache_page(struct address_space *mapping,\n\t\t\t\t\t\tpgoff_t index, bool for_write)\n{\n\tstruct page *page;\n\tunsigned int flags;\n\n\tif (IS_ENABLED(CONFIG_F2FS_FAULT_INJECTION)) {\n\t\tif (!for_write)\n\t\t\tpage = find_get_page_flags(mapping, index,\n\t\t\t\t\t\t\tFGP_LOCK | FGP_ACCESSED);\n\t\telse\n\t\t\tpage = find_lock_page(mapping, index);\n\t\tif (page)\n\t\t\treturn page;\n\n\t\tif (time_to_inject(F2FS_M_SB(mapping), FAULT_PAGE_ALLOC))\n\t\t\treturn NULL;\n\t}\n\n\tif (!for_write)\n\t\treturn grab_cache_page(mapping, index);\n\n\tflags = memalloc_nofs_save();\n\tpage = grab_cache_page_write_begin(mapping, index);\n\tmemalloc_nofs_restore(flags);\n\n\treturn page;\n}\n\nstatic inline struct page *f2fs_pagecache_get_page(\n\t\t\t\tstruct address_space *mapping, pgoff_t index,\n\t\t\t\tfgf_t fgp_flags, gfp_t gfp_mask)\n{\n\tif (time_to_inject(F2FS_M_SB(mapping), FAULT_PAGE_GET))\n\t\treturn NULL;\n\n\treturn pagecache_get_page(mapping, index, fgp_flags, gfp_mask);\n}\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n}\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}\n\nstatic inline void *f2fs_kmem_cache_alloc_nofail(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\tgfp_t flags, bool nofail, struct f2fs_sb_info *sbi)\n{\n\tif (nofail)\n\t\treturn f2fs_kmem_cache_alloc_nofail(cachep, flags);\n\n\tif (time_to_inject(sbi, FAULT_SLAB_ALLOC))\n\t\treturn NULL;\n\n\treturn kmem_cache_alloc(cachep, flags);\n}\n\nstatic inline bool is_inflight_io(struct f2fs_sb_info *sbi, int type)\n{\n\tif (get_pages(sbi, F2FS_RD_DATA) || get_pages(sbi, F2FS_RD_NODE) ||\n\t\tget_pages(sbi, F2FS_RD_META) || get_pages(sbi, F2FS_WB_DATA) ||\n\t\tget_pages(sbi, F2FS_WB_CP_DATA) ||\n\t\tget_pages(sbi, F2FS_DIO_READ) ||\n\t\tget_pages(sbi, F2FS_DIO_WRITE))\n\t\treturn true;\n\n\tif (type != DISCARD_TIME && SM_I(sbi) && SM_I(sbi)->dcc_info &&\n\t\t\tatomic_read(&SM_I(sbi)->dcc_info->queued_discard))\n\t\treturn true;\n\n\tif (SM_I(sbi) && SM_I(sbi)->fcc_info &&\n\t\t\tatomic_read(&SM_I(sbi)->fcc_info->queued_flush))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool is_idle(struct f2fs_sb_info *sbi, int type)\n{\n\tif (sbi->gc_mode == GC_URGENT_HIGH)\n\t\treturn true;\n\n\tif (is_inflight_io(sbi, type))\n\t\treturn false;\n\n\tif (sbi->gc_mode == GC_URGENT_MID)\n\t\treturn true;\n\n\tif (sbi->gc_mode == GC_URGENT_LOW &&\n\t\t\t(type == DISCARD_TIME || type == GC_TIME))\n\t\treturn true;\n\n\treturn f2fs_time_over(sbi, type);\n}\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}\n\n#define RAW_IS_INODE(p)\t((p)->footer.nid == (p)->footer.ino)\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\n\treturn RAW_IS_INODE(p);\n}\n\nstatic inline int offset_in_addr(struct f2fs_inode *i)\n{\n\treturn (i->i_inline & F2FS_EXTRA_ATTR) ?\n\t\t\t(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;\n}\n\nstatic inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}\n\nstatic inline int f2fs_has_extra_attr(struct inode *inode);\nstatic inline block_t data_blkaddr(struct inode *inode,\n\t\t\tstruct page *node_page, unsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\tint base = 0;\n\tbool is_inode = IS_INODE(node_page);\n\n\traw_node = F2FS_NODE(node_page);\n\n\tif (is_inode) {\n\t\tif (!inode)\n\t\t\t \n\t\t\tbase = offset_in_addr(&raw_node->i);\n\t\telse if (f2fs_has_extra_attr(inode))\n\t\t\tbase = get_extra_isize(inode);\n\t}\n\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[base + offset]);\n}\n\nstatic inline block_t f2fs_data_blkaddr(struct dnode_of_data *dn)\n{\n\treturn data_blkaddr(dn->inode, dn->node_page, dn->ofs_in_node);\n}\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\treturn mask & *addr;\n}\n\nstatic inline void f2fs_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\t*addr |= mask;\n}\n\nstatic inline void f2fs_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\t*addr &= ~mask;\n}\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}\n\nstatic inline void f2fs_change_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = BIT(7 - (nr & 0x07));\n\t*addr ^= mask;\n}\n\n \n#define F2FS_COMPR_FL\t\t\t0x00000004  \n#define F2FS_SYNC_FL\t\t\t0x00000008  \n#define F2FS_IMMUTABLE_FL\t\t0x00000010  \n#define F2FS_APPEND_FL\t\t\t0x00000020  \n#define F2FS_NODUMP_FL\t\t\t0x00000040  \n#define F2FS_NOATIME_FL\t\t\t0x00000080  \n#define F2FS_NOCOMP_FL\t\t\t0x00000400  \n#define F2FS_INDEX_FL\t\t\t0x00001000  \n#define F2FS_DIRSYNC_FL\t\t\t0x00010000  \n#define F2FS_PROJINHERIT_FL\t\t0x20000000  \n#define F2FS_CASEFOLD_FL\t\t0x40000000  \n\n#define F2FS_QUOTA_DEFAULT_FL\t\t(F2FS_NOATIME_FL | F2FS_IMMUTABLE_FL)\n\n \n#define F2FS_FL_INHERITED (F2FS_SYNC_FL | F2FS_NODUMP_FL | F2FS_NOATIME_FL | \\\n\t\t\t   F2FS_DIRSYNC_FL | F2FS_PROJINHERIT_FL | \\\n\t\t\t   F2FS_CASEFOLD_FL)\n\n \n#define F2FS_REG_FLMASK\t\t(~(F2FS_DIRSYNC_FL | F2FS_PROJINHERIT_FL | \\\n\t\t\t\tF2FS_CASEFOLD_FL))\n\n \n#define F2FS_OTHER_FLMASK\t(F2FS_NODUMP_FL | F2FS_NOATIME_FL)\n\nstatic inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & F2FS_REG_FLMASK;\n\telse\n\t\treturn flags & F2FS_OTHER_FLMASK;\n}\n\nstatic inline void __mark_inode_dirty_flag(struct inode *inode,\n\t\t\t\t\t\tint flag, bool set)\n{\n\tswitch (flag) {\n\tcase FI_INLINE_XATTR:\n\tcase FI_INLINE_DATA:\n\tcase FI_INLINE_DENTRY:\n\tcase FI_NEW_INODE:\n\t\tif (set)\n\t\t\treturn;\n\t\tfallthrough;\n\tcase FI_DATA_EXIST:\n\tcase FI_INLINE_DOTS:\n\tcase FI_PIN_FILE:\n\tcase FI_COMPRESS_RELEASED:\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t}\n}\n\nstatic inline void set_inode_flag(struct inode *inode, int flag)\n{\n\tset_bit(flag, F2FS_I(inode)->flags);\n\t__mark_inode_dirty_flag(inode, flag, true);\n}\n\nstatic inline int is_inode_flag_set(struct inode *inode, int flag)\n{\n\treturn test_bit(flag, F2FS_I(inode)->flags);\n}\n\nstatic inline void clear_inode_flag(struct inode *inode, int flag)\n{\n\tclear_bit(flag, F2FS_I(inode)->flags);\n\t__mark_inode_dirty_flag(inode, flag, false);\n}\n\nstatic inline bool f2fs_verity_in_progress(struct inode *inode)\n{\n\treturn IS_ENABLED(CONFIG_FS_VERITY) &&\n\t       is_inode_flag_set(inode, FI_VERITY_IN_PROGRESS);\n}\n\nstatic inline void set_acl_inode(struct inode *inode, umode_t mode)\n{\n\tF2FS_I(inode)->i_acl_mode = mode;\n\tset_inode_flag(inode, FI_ACL_MODE);\n\tf2fs_mark_inode_dirty_sync(inode, false);\n}\n\nstatic inline void f2fs_i_links_write(struct inode *inode, bool inc)\n{\n\tif (inc)\n\t\tinc_nlink(inode);\n\telse\n\t\tdrop_nlink(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void f2fs_i_blocks_write(struct inode *inode,\n\t\t\t\t\tblock_t diff, bool add, bool claim)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\t \n\tif (add) {\n\t\tif (claim)\n\t\t\tdquot_claim_block(inode, diff);\n\t\telse\n\t\t\tdquot_alloc_block_nofail(inode, diff);\n\t} else {\n\t\tdquot_free_block(inode, diff);\n\t}\n\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode);\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn;\n\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}\n\nstatic inline void f2fs_i_depth_write(struct inode *inode, unsigned int depth)\n{\n\tF2FS_I(inode)->i_current_depth = depth;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void f2fs_i_gc_failures_write(struct inode *inode,\n\t\t\t\t\tunsigned int count)\n{\n\tF2FS_I(inode)->i_gc_failures[GC_FAILURE_PIN] = count;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void f2fs_i_xnid_write(struct inode *inode, nid_t xnid)\n{\n\tF2FS_I(inode)->i_xattr_nid = xnid;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void f2fs_i_pino_write(struct inode *inode, nid_t pino)\n{\n\tF2FS_I(inode)->i_pino = pino;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void get_inline_info(struct inode *inode, struct f2fs_inode *ri)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\n\tif (ri->i_inline & F2FS_INLINE_XATTR)\n\t\tset_bit(FI_INLINE_XATTR, fi->flags);\n\tif (ri->i_inline & F2FS_INLINE_DATA)\n\t\tset_bit(FI_INLINE_DATA, fi->flags);\n\tif (ri->i_inline & F2FS_INLINE_DENTRY)\n\t\tset_bit(FI_INLINE_DENTRY, fi->flags);\n\tif (ri->i_inline & F2FS_DATA_EXIST)\n\t\tset_bit(FI_DATA_EXIST, fi->flags);\n\tif (ri->i_inline & F2FS_INLINE_DOTS)\n\t\tset_bit(FI_INLINE_DOTS, fi->flags);\n\tif (ri->i_inline & F2FS_EXTRA_ATTR)\n\t\tset_bit(FI_EXTRA_ATTR, fi->flags);\n\tif (ri->i_inline & F2FS_PIN_FILE)\n\t\tset_bit(FI_PIN_FILE, fi->flags);\n\tif (ri->i_inline & F2FS_COMPRESS_RELEASED)\n\t\tset_bit(FI_COMPRESS_RELEASED, fi->flags);\n}\n\nstatic inline void set_raw_inline(struct inode *inode, struct f2fs_inode *ri)\n{\n\tri->i_inline = 0;\n\n\tif (is_inode_flag_set(inode, FI_INLINE_XATTR))\n\t\tri->i_inline |= F2FS_INLINE_XATTR;\n\tif (is_inode_flag_set(inode, FI_INLINE_DATA))\n\t\tri->i_inline |= F2FS_INLINE_DATA;\n\tif (is_inode_flag_set(inode, FI_INLINE_DENTRY))\n\t\tri->i_inline |= F2FS_INLINE_DENTRY;\n\tif (is_inode_flag_set(inode, FI_DATA_EXIST))\n\t\tri->i_inline |= F2FS_DATA_EXIST;\n\tif (is_inode_flag_set(inode, FI_INLINE_DOTS))\n\t\tri->i_inline |= F2FS_INLINE_DOTS;\n\tif (is_inode_flag_set(inode, FI_EXTRA_ATTR))\n\t\tri->i_inline |= F2FS_EXTRA_ATTR;\n\tif (is_inode_flag_set(inode, FI_PIN_FILE))\n\t\tri->i_inline |= F2FS_PIN_FILE;\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED))\n\t\tri->i_inline |= F2FS_COMPRESS_RELEASED;\n}\n\nstatic inline int f2fs_has_extra_attr(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_EXTRA_ATTR);\n}\n\nstatic inline int f2fs_has_inline_xattr(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_INLINE_XATTR);\n}\n\nstatic inline int f2fs_compressed_file(struct inode *inode)\n{\n\treturn S_ISREG(inode->i_mode) &&\n\t\tis_inode_flag_set(inode, FI_COMPRESSED_FILE);\n}\n\nstatic inline bool f2fs_need_compress_data(struct inode *inode)\n{\n\tint compress_mode = F2FS_OPTION(F2FS_I_SB(inode)).compress_mode;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn false;\n\n\tif (compress_mode == COMPR_MODE_FS)\n\t\treturn true;\n\telse if (compress_mode == COMPR_MODE_USER &&\n\t\t\tis_inode_flag_set(inode, FI_ENABLE_COMPRESS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline unsigned int addrs_per_inode(struct inode *inode)\n{\n\tunsigned int addrs = CUR_ADDRS_PER_INODE(inode) -\n\t\t\t\tget_inline_xattr_addrs(inode);\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn addrs;\n\treturn ALIGN_DOWN(addrs, F2FS_I(inode)->i_cluster_size);\n}\n\nstatic inline unsigned int addrs_per_block(struct inode *inode)\n{\n\tif (!f2fs_compressed_file(inode))\n\t\treturn DEF_ADDRS_PER_BLOCK;\n\treturn ALIGN_DOWN(DEF_ADDRS_PER_BLOCK, F2FS_I(inode)->i_cluster_size);\n}\n\nstatic inline void *inline_xattr_addr(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\n\treturn (void *)&(ri->i_addr[DEF_ADDRS_PER_INODE -\n\t\t\t\t\tget_inline_xattr_addrs(inode)]);\n}\n\nstatic inline int inline_xattr_size(struct inode *inode)\n{\n\tif (f2fs_has_inline_xattr(inode))\n\t\treturn get_inline_xattr_addrs(inode) * sizeof(__le32);\n\treturn 0;\n}\n\n \nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_INLINE_DATA);\n}\n\nstatic inline int f2fs_exist_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_DATA_EXIST);\n}\n\nstatic inline int f2fs_has_inline_dots(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_INLINE_DOTS);\n}\n\nstatic inline int f2fs_is_mmap_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_MMAP_FILE);\n}\n\nstatic inline bool f2fs_is_pinned_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_PIN_FILE);\n}\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_ATOMIC_FILE);\n}\n\nstatic inline bool f2fs_is_cow_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_COW_FILE);\n}\n\nstatic inline bool f2fs_is_first_block_written(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_FIRST_BLOCK_WRITTEN);\n}\n\nstatic inline bool f2fs_is_drop_cache(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_DROP_CACHE);\n}\n\nstatic inline void *inline_data_addr(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\tint extra_size = get_extra_isize(inode);\n\n\treturn (void *)&(ri->i_addr[extra_size + DEF_INLINE_RESERVED_SIZE]);\n}\n\nstatic inline int f2fs_has_inline_dentry(struct inode *inode)\n{\n\treturn is_inode_flag_set(inode, FI_INLINE_DENTRY);\n}\n\nstatic inline int is_file(struct inode *inode, int type)\n{\n\treturn F2FS_I(inode)->i_advise & type;\n}\n\nstatic inline void set_file(struct inode *inode, int type)\n{\n\tif (is_file(inode, type))\n\t\treturn;\n\tF2FS_I(inode)->i_advise |= type;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline void clear_file(struct inode *inode, int type)\n{\n\tif (!is_file(inode, type))\n\t\treturn;\n\tF2FS_I(inode)->i_advise &= ~type;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline bool f2fs_is_time_consistent(struct inode *inode)\n{\n\tstruct timespec64 ctime = inode_get_ctime(inode);\n\n\tif (!timespec64_equal(F2FS_I(inode)->i_disk_time, &inode->i_atime))\n\t\treturn false;\n\tif (!timespec64_equal(F2FS_I(inode)->i_disk_time + 1, &ctime))\n\t\treturn false;\n\tif (!timespec64_equal(F2FS_I(inode)->i_disk_time + 2, &inode->i_mtime))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool f2fs_skip_inode_update(struct inode *inode, int dsync)\n{\n\tbool ret;\n\n\tif (dsync) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\tspin_lock(&sbi->inode_lock[DIRTY_META]);\n\t\tret = list_empty(&F2FS_I(inode)->gdirty_list);\n\t\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n\t\treturn ret;\n\t}\n\tif (!is_inode_flag_set(inode, FI_AUTO_RECOVER) ||\n\t\t\tfile_keep_isize(inode) ||\n\t\t\ti_size_read(inode) & ~PAGE_MASK)\n\t\treturn false;\n\n\tif (!f2fs_is_time_consistent(inode))\n\t\treturn false;\n\n\tspin_lock(&F2FS_I(inode)->i_size_lock);\n\tret = F2FS_I(inode)->last_disk_size == i_size_read(inode);\n\tspin_unlock(&F2FS_I(inode)->i_size_lock);\n\n\treturn ret;\n}\n\nstatic inline bool f2fs_readonly(struct super_block *sb)\n{\n\treturn sb_rdonly(sb);\n}\n\nstatic inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)\n{\n\treturn is_set_ckpt_flags(sbi, CP_ERROR_FLAG);\n}\n\nstatic inline bool is_dot_dotdot(const u8 *name, size_t len)\n{\n\tif (len == 1 && name[0] == '.')\n\t\treturn true;\n\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void *f2fs_kmalloc(struct f2fs_sb_info *sbi,\n\t\t\t\t\tsize_t size, gfp_t flags)\n{\n\tif (time_to_inject(sbi, FAULT_KMALLOC))\n\t\treturn NULL;\n\n\treturn kmalloc(size, flags);\n}\n\nstatic inline void *f2fs_getname(struct f2fs_sb_info *sbi)\n{\n\tif (time_to_inject(sbi, FAULT_KMALLOC))\n\t\treturn NULL;\n\n\treturn __getname();\n}\n\nstatic inline void f2fs_putname(char *buf)\n{\n\t__putname(buf);\n}\n\nstatic inline void *f2fs_kzalloc(struct f2fs_sb_info *sbi,\n\t\t\t\t\tsize_t size, gfp_t flags)\n{\n\treturn f2fs_kmalloc(sbi, size, flags | __GFP_ZERO);\n}\n\nstatic inline void *f2fs_kvmalloc(struct f2fs_sb_info *sbi,\n\t\t\t\t\tsize_t size, gfp_t flags)\n{\n\tif (time_to_inject(sbi, FAULT_KVMALLOC))\n\t\treturn NULL;\n\n\treturn kvmalloc(size, flags);\n}\n\nstatic inline void *f2fs_kvzalloc(struct f2fs_sb_info *sbi,\n\t\t\t\t\tsize_t size, gfp_t flags)\n{\n\treturn f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);\n}\n\nstatic inline int get_extra_isize(struct inode *inode)\n{\n\treturn F2FS_I(inode)->i_extra_isize / sizeof(__le32);\n}\n\nstatic inline int get_inline_xattr_addrs(struct inode *inode)\n{\n\treturn F2FS_I(inode)->i_inline_xattr_size;\n}\n\n#define f2fs_get_inode_mode(i) \\\n\t((is_inode_flag_set(i, FI_ACL_MODE)) ? \\\n\t (F2FS_I(i)->i_acl_mode) : ((i)->i_mode))\n\n#define F2FS_MIN_EXTRA_ATTR_SIZE\t\t(sizeof(__le32))\n\n#define F2FS_TOTAL_EXTRA_ATTR_SIZE\t\t\t\\\n\t(offsetof(struct f2fs_inode, i_extra_end) -\t\\\n\toffsetof(struct f2fs_inode, i_extra_isize))\t\\\n\n#define F2FS_OLD_ATTRIBUTE_SIZE\t(offsetof(struct f2fs_inode, i_addr))\n#define F2FS_FITS_IN_INODE(f2fs_inode, extra_isize, field)\t\t\\\n\t\t((offsetof(typeof(*(f2fs_inode)), field) +\t\\\n\t\tsizeof((f2fs_inode)->field))\t\t\t\\\n\t\t<= (F2FS_OLD_ATTRIBUTE_SIZE + (extra_isize)))\t\\\n\n#define __is_large_section(sbi)\t\t((sbi)->segs_per_sec > 1)\n\n#define __is_meta_io(fio) (PAGE_TYPE_OF_BIO((fio)->type) == META)\n\nbool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type);\nstatic inline void verify_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr, type)) {\n\t\tf2fs_err(sbi, \"invalid blkaddr: %u, type: %d, run fsck to fix.\",\n\t\t\t blkaddr, type);\n\t\tf2fs_bug_on(sbi, 1);\n\t}\n}\n\nstatic inline bool __is_valid_data_blkaddr(block_t blkaddr)\n{\n\tif (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR ||\n\t\t\tblkaddr == COMPRESS_ADDR)\n\t\treturn false;\n\treturn true;\n}\n\n \nint f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync);\nint f2fs_do_truncate_blocks(struct inode *inode, u64 from, bool lock);\nint f2fs_truncate_blocks(struct inode *inode, u64 from, bool lock);\nint f2fs_truncate(struct inode *inode);\nint f2fs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags);\nint f2fs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr);\nint f2fs_truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end);\nvoid f2fs_truncate_data_blocks_range(struct dnode_of_data *dn, int count);\nint f2fs_precache_extents(struct inode *inode);\nint f2fs_fileattr_get(struct dentry *dentry, struct fileattr *fa);\nint f2fs_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa);\nlong f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\nlong f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nint f2fs_transfer_project_quota(struct inode *inode, kprojid_t kprojid);\nint f2fs_pin_file_control(struct inode *inode, bool inc);\n\n \nvoid f2fs_set_inode_flags(struct inode *inode);\nbool f2fs_inode_chksum_verify(struct f2fs_sb_info *sbi, struct page *page);\nvoid f2fs_inode_chksum_set(struct f2fs_sb_info *sbi, struct page *page);\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino);\nstruct inode *f2fs_iget_retry(struct super_block *sb, unsigned long ino);\nint f2fs_try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink);\nvoid f2fs_update_inode(struct inode *inode, struct page *node_page);\nvoid f2fs_update_inode_page(struct inode *inode);\nint f2fs_write_inode(struct inode *inode, struct writeback_control *wbc);\nvoid f2fs_evict_inode(struct inode *inode);\nvoid f2fs_handle_failed_inode(struct inode *inode);\n\n \nint f2fs_update_extension_list(struct f2fs_sb_info *sbi, const char *name,\n\t\t\t\t\t\t\tbool hot, bool set);\nstruct dentry *f2fs_get_parent(struct dentry *child);\nint f2fs_get_tmpfile(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct inode **new_inode);\n\n \nint f2fs_init_casefolded_name(const struct inode *dir,\n\t\t\t      struct f2fs_filename *fname);\nint f2fs_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\tint lookup, struct f2fs_filename *fname);\nint f2fs_prepare_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct f2fs_filename *fname);\nvoid f2fs_free_filename(struct f2fs_filename *fname);\nstruct f2fs_dir_entry *f2fs_find_target_dentry(const struct f2fs_dentry_ptr *d,\n\t\t\tconst struct f2fs_filename *fname, int *max_slots);\nint f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\tunsigned int start_pos, struct fscrypt_str *fstr);\nvoid f2fs_do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\tstruct f2fs_dentry_ptr *d);\nstruct page *f2fs_init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct f2fs_filename *fname, struct page *dpage);\nvoid f2fs_update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\tunsigned int current_depth);\nint f2fs_room_for_filename(const void *bitmap, int slots, int max_slots);\nvoid f2fs_drop_nlink(struct inode *dir, struct inode *inode);\nstruct f2fs_dir_entry *__f2fs_find_entry(struct inode *dir,\n\t\t\t\t\t const struct f2fs_filename *fname,\n\t\t\t\t\t struct page **res_page);\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tconst struct qstr *child, struct page **res_page);\nstruct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p);\nino_t f2fs_inode_by_name(struct inode *dir, const struct qstr *qstr,\n\t\t\tstruct page **page);\nvoid f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\t\tstruct page *page, struct inode *inode);\nbool f2fs_has_enough_room(struct inode *dir, struct page *ipage,\n\t\t\t  const struct f2fs_filename *fname);\nvoid f2fs_update_dentry(nid_t ino, umode_t mode, struct f2fs_dentry_ptr *d,\n\t\t\tconst struct fscrypt_str *name, f2fs_hash_t name_hash,\n\t\t\tunsigned int bit_pos);\nint f2fs_add_regular_entry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t\tstruct inode *inode, nid_t ino, umode_t mode);\nint f2fs_add_dentry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t\tstruct inode *inode, nid_t ino, umode_t mode);\nint f2fs_do_add_link(struct inode *dir, const struct qstr *name,\n\t\t\tstruct inode *inode, nid_t ino, umode_t mode);\nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\tstruct inode *dir, struct inode *inode);\nint f2fs_do_tmpfile(struct inode *inode, struct inode *dir);\nbool f2fs_empty_dir(struct inode *dir);\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tif (fscrypt_is_nokey_name(dentry))\n\t\treturn -ENOKEY;\n\treturn f2fs_do_add_link(d_inode(dentry->d_parent), &dentry->d_name,\n\t\t\t\tinode, inode->i_ino, inode->i_mode);\n}\n\n \nint f2fs_inode_dirtied(struct inode *inode, bool sync);\nvoid f2fs_inode_synced(struct inode *inode);\nint f2fs_dquot_initialize(struct inode *inode);\nint f2fs_enable_quota_files(struct f2fs_sb_info *sbi, bool rdonly);\nint f2fs_quota_sync(struct super_block *sb, int type);\nloff_t max_file_blocks(struct inode *inode);\nvoid f2fs_quota_off_umount(struct super_block *sb);\nvoid f2fs_save_errors(struct f2fs_sb_info *sbi, unsigned char flag);\nvoid f2fs_handle_critical_error(struct f2fs_sb_info *sbi, unsigned char reason,\n\t\t\t\t\t\t\tbool irq_context);\nvoid f2fs_handle_error(struct f2fs_sb_info *sbi, unsigned char error);\nvoid f2fs_handle_error_async(struct f2fs_sb_info *sbi, unsigned char error);\nint f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover);\nint f2fs_sync_fs(struct super_block *sb, int sync);\nint f2fs_sanity_check_ckpt(struct f2fs_sb_info *sbi);\n\n \nvoid f2fs_hash_filename(const struct inode *dir, struct f2fs_filename *fname);\n\n \nstruct node_info;\n\nint f2fs_check_nid_range(struct f2fs_sb_info *sbi, nid_t nid);\nbool f2fs_available_free_memory(struct f2fs_sb_info *sbi, int type);\nbool f2fs_in_warm_node_list(struct f2fs_sb_info *sbi, struct page *page);\nvoid f2fs_init_fsync_node_info(struct f2fs_sb_info *sbi);\nvoid f2fs_del_fsync_node_entry(struct f2fs_sb_info *sbi, struct page *page);\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi);\nint f2fs_need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid);\nbool f2fs_is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid);\nbool f2fs_need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino);\nint f2fs_get_node_info(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\tstruct node_info *ni, bool checkpoint_context);\npgoff_t f2fs_get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs);\nint f2fs_get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode);\nint f2fs_truncate_inode_blocks(struct inode *inode, pgoff_t from);\nint f2fs_truncate_xattr_node(struct inode *inode);\nint f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int seq_id);\nbool f2fs_nat_bitmap_enabled(struct f2fs_sb_info *sbi);\nint f2fs_remove_inode_page(struct inode *inode);\nstruct page *f2fs_new_inode_page(struct inode *inode);\nstruct page *f2fs_new_node_page(struct dnode_of_data *dn, unsigned int ofs);\nvoid f2fs_ra_node_page(struct f2fs_sb_info *sbi, nid_t nid);\nstruct page *f2fs_get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid);\nstruct page *f2fs_get_node_page_ra(struct page *parent, int start);\nint f2fs_move_node_page(struct page *node_page, int gc_type);\nvoid f2fs_flush_inline_data(struct f2fs_sb_info *sbi);\nint f2fs_fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\tstruct writeback_control *wbc, bool atomic,\n\t\t\tunsigned int *seq_id);\nint f2fs_sync_node_pages(struct f2fs_sb_info *sbi,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tbool do_balance, enum iostat_type io_type);\nint f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount);\nbool f2fs_alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid);\nvoid f2fs_alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid);\nvoid f2fs_alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid);\nint f2fs_try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink);\nint f2fs_recover_inline_xattr(struct inode *inode, struct page *page);\nint f2fs_recover_xattr_data(struct inode *inode, struct page *page);\nint f2fs_recover_inode_page(struct f2fs_sb_info *sbi, struct page *page);\nint f2fs_restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum);\nvoid f2fs_enable_nat_bits(struct f2fs_sb_info *sbi);\nint f2fs_flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc);\nint f2fs_build_node_manager(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_node_manager(struct f2fs_sb_info *sbi);\nint __init f2fs_create_node_manager_caches(void);\nvoid f2fs_destroy_node_manager_caches(void);\n\n \nbool f2fs_need_SSR(struct f2fs_sb_info *sbi);\nint f2fs_commit_atomic_write(struct inode *inode);\nvoid f2fs_abort_atomic_write(struct inode *inode, bool clean);\nvoid f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need);\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi, bool from_bg);\nint f2fs_issue_flush(struct f2fs_sb_info *sbi, nid_t ino);\nint f2fs_create_flush_cmd_control(struct f2fs_sb_info *sbi);\nint f2fs_flush_device_cache(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free);\nvoid f2fs_invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);\nbool f2fs_is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);\nint f2fs_start_discard_thread(struct f2fs_sb_info *sbi);\nvoid f2fs_drop_discard_cmd(struct f2fs_sb_info *sbi);\nvoid f2fs_stop_discard_thread(struct f2fs_sb_info *sbi);\nbool f2fs_issue_discard_timeout(struct f2fs_sb_info *sbi);\nvoid f2fs_clear_prefree_segments(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct cp_control *cpc);\nvoid f2fs_dirty_to_prefree(struct f2fs_sb_info *sbi);\nblock_t f2fs_get_unusable_blocks(struct f2fs_sb_info *sbi);\nint f2fs_disable_cp_again(struct f2fs_sb_info *sbi, block_t unusable);\nvoid f2fs_release_discard_addrs(struct f2fs_sb_info *sbi);\nint f2fs_npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);\nbool f2fs_segment_has_free_slot(struct f2fs_sb_info *sbi, int segno);\nvoid f2fs_init_inmem_curseg(struct f2fs_sb_info *sbi);\nvoid f2fs_save_inmem_curseg(struct f2fs_sb_info *sbi);\nvoid f2fs_restore_inmem_curseg(struct f2fs_sb_info *sbi);\nvoid f2fs_get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir);\nvoid f2fs_allocate_segment_for_resize(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int start, unsigned int end);\nvoid f2fs_allocate_new_section(struct f2fs_sb_info *sbi, int type, bool force);\nvoid f2fs_allocate_new_segments(struct f2fs_sb_info *sbi);\nint f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range);\nbool f2fs_exist_trim_candidates(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct cp_control *cpc);\nstruct page *f2fs_get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno);\nvoid f2fs_update_meta_page(struct f2fs_sb_info *sbi, void *src,\n\t\t\t\t\tblock_t blk_addr);\nvoid f2fs_do_write_meta_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\t\tenum iostat_type io_type);\nvoid f2fs_do_write_node_page(unsigned int nid, struct f2fs_io_info *fio);\nvoid f2fs_outplace_write_data(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_io_info *fio);\nint f2fs_inplace_write_data(struct f2fs_io_info *fio);\nvoid f2fs_do_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\t\tblock_t old_blkaddr, block_t new_blkaddr,\n\t\t\tbool recover_curseg, bool recover_newaddr,\n\t\t\tbool from_gc);\nvoid f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,\n\t\t\tblock_t old_addr, block_t new_addr,\n\t\t\tunsigned char version, bool recover_curseg,\n\t\t\tbool recover_newaddr);\nvoid f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\t\tstruct f2fs_summary *sum, int type,\n\t\t\tstruct f2fs_io_info *fio);\nvoid f2fs_update_device_state(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tblock_t blkaddr, unsigned int blkcnt);\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\tenum page_type type, bool ordered, bool locked);\nvoid f2fs_wait_on_block_writeback(struct inode *inode, block_t blkaddr);\nvoid f2fs_wait_on_block_writeback_range(struct inode *inode, block_t blkaddr,\n\t\t\t\t\t\t\t\tblock_t len);\nvoid f2fs_write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk);\nvoid f2fs_write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk);\nint f2fs_lookup_journal_in_cursum(struct f2fs_journal *journal, int type,\n\t\t\tunsigned int val, int alloc);\nvoid f2fs_flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc);\nint f2fs_fix_curseg_write_pointer(struct f2fs_sb_info *sbi);\nint f2fs_check_write_pointer(struct f2fs_sb_info *sbi);\nint f2fs_build_segment_manager(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_segment_manager(struct f2fs_sb_info *sbi);\nint __init f2fs_create_segment_manager_caches(void);\nvoid f2fs_destroy_segment_manager_caches(void);\nint f2fs_rw_hint_to_seg_type(enum rw_hint hint);\nunsigned int f2fs_usable_segs_in_sec(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno);\nunsigned int f2fs_usable_blks_in_seg(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno);\n\n#define DEF_FRAGMENT_SIZE\t4\n#define MIN_FRAGMENT_SIZE\t1\n#define MAX_FRAGMENT_SIZE\t512\n\nstatic inline bool f2fs_need_rand_seg(struct f2fs_sb_info *sbi)\n{\n\treturn F2FS_OPTION(sbi).fs_mode == FS_MODE_FRAGMENT_SEG ||\n\t\tF2FS_OPTION(sbi).fs_mode == FS_MODE_FRAGMENT_BLK;\n}\n\n \nvoid f2fs_stop_checkpoint(struct f2fs_sb_info *sbi, bool end_io,\n\t\t\t\t\t\t\tunsigned char reason);\nvoid f2fs_flush_ckpt_thread(struct f2fs_sb_info *sbi);\nstruct page *f2fs_grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index);\nstruct page *f2fs_get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index);\nstruct page *f2fs_get_meta_page_retry(struct f2fs_sb_info *sbi, pgoff_t index);\nstruct page *f2fs_get_tmp_page(struct f2fs_sb_info *sbi, pgoff_t index);\nbool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type);\nint f2fs_ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages,\n\t\t\tint type, bool sync);\nvoid f2fs_ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index,\n\t\t\t\t\t\t\tunsigned int ra_blocks);\nlong f2fs_sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\tlong nr_to_write, enum iostat_type io_type);\nvoid f2fs_add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type);\nvoid f2fs_remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type);\nvoid f2fs_release_ino_entry(struct f2fs_sb_info *sbi, bool all);\nbool f2fs_exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode);\nvoid f2fs_set_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tunsigned int devidx, int type);\nbool f2fs_is_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,\n\t\t\t\t\tunsigned int devidx, int type);\nint f2fs_acquire_orphan_inode(struct f2fs_sb_info *sbi);\nvoid f2fs_release_orphan_inode(struct f2fs_sb_info *sbi);\nvoid f2fs_add_orphan_inode(struct inode *inode);\nvoid f2fs_remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino);\nint f2fs_recover_orphan_inodes(struct f2fs_sb_info *sbi);\nint f2fs_get_valid_checkpoint(struct f2fs_sb_info *sbi);\nvoid f2fs_update_dirty_folio(struct inode *inode, struct folio *folio);\nvoid f2fs_remove_dirty_inode(struct inode *inode);\nint f2fs_sync_dirty_inodes(struct f2fs_sb_info *sbi, enum inode_type type,\n\t\t\t\t\t\t\t\tbool from_cp);\nvoid f2fs_wait_on_all_pages(struct f2fs_sb_info *sbi, int type);\nu64 f2fs_get_sectors_written(struct f2fs_sb_info *sbi);\nint f2fs_write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc);\nvoid f2fs_init_ino_entry_info(struct f2fs_sb_info *sbi);\nint __init f2fs_create_checkpoint_caches(void);\nvoid f2fs_destroy_checkpoint_caches(void);\nint f2fs_issue_checkpoint(struct f2fs_sb_info *sbi);\nint f2fs_start_ckpt_thread(struct f2fs_sb_info *sbi);\nvoid f2fs_stop_ckpt_thread(struct f2fs_sb_info *sbi);\nvoid f2fs_init_ckpt_req_control(struct f2fs_sb_info *sbi);\n\n \nint __init f2fs_init_bioset(void);\nvoid f2fs_destroy_bioset(void);\nint f2fs_init_bio_entry_cache(void);\nvoid f2fs_destroy_bio_entry_cache(void);\nvoid f2fs_submit_read_bio(struct f2fs_sb_info *sbi, struct bio *bio,\n\t\t\t  enum page_type type);\nint f2fs_init_write_merge_io(struct f2fs_sb_info *sbi);\nvoid f2fs_submit_merged_write(struct f2fs_sb_info *sbi, enum page_type type);\nvoid f2fs_submit_merged_write_cond(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct inode *inode, struct page *page,\n\t\t\t\tnid_t ino, enum page_type type);\nvoid f2fs_submit_merged_ipu_write(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct bio **bio, struct page *page);\nvoid f2fs_flush_merged_writes(struct f2fs_sb_info *sbi);\nint f2fs_submit_page_bio(struct f2fs_io_info *fio);\nint f2fs_merge_page_bio(struct f2fs_io_info *fio);\nvoid f2fs_submit_page_write(struct f2fs_io_info *fio);\nstruct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,\n\t\tblock_t blk_addr, sector_t *sector);\nint f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr);\nvoid f2fs_set_data_blkaddr(struct dnode_of_data *dn);\nvoid f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr);\nint f2fs_reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count);\nint f2fs_reserve_new_block(struct dnode_of_data *dn);\nint f2fs_get_block_locked(struct dnode_of_data *dn, pgoff_t index);\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index);\nstruct page *f2fs_get_read_data_page(struct inode *inode, pgoff_t index,\n\t\t\tblk_opf_t op_flags, bool for_write, pgoff_t *next_pgofs);\nstruct page *f2fs_find_data_page(struct inode *inode, pgoff_t index,\n\t\t\t\t\t\t\tpgoff_t *next_pgofs);\nstruct page *f2fs_get_lock_data_page(struct inode *inode, pgoff_t index,\n\t\t\tbool for_write);\nstruct page *f2fs_get_new_data_page(struct inode *inode,\n\t\t\tstruct page *ipage, pgoff_t index, bool new_i_size);\nint f2fs_do_write_data_page(struct f2fs_io_info *fio);\nint f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map, int flag);\nint f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t\tu64 start, u64 len);\nint f2fs_encrypt_one_page(struct f2fs_io_info *fio);\nbool f2fs_should_update_inplace(struct inode *inode, struct f2fs_io_info *fio);\nbool f2fs_should_update_outplace(struct inode *inode, struct f2fs_io_info *fio);\nint f2fs_write_single_data_page(struct page *page, int *submitted,\n\t\t\t\tstruct bio **bio, sector_t *last_block,\n\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\tenum iostat_type io_type,\n\t\t\t\tint compr_blocks, bool allow_balance);\nvoid f2fs_write_failed(struct inode *inode, loff_t to);\nvoid f2fs_invalidate_folio(struct folio *folio, size_t offset, size_t length);\nbool f2fs_release_folio(struct folio *folio, gfp_t wait);\nbool f2fs_overwrite_io(struct inode *inode, loff_t pos, size_t len);\nvoid f2fs_clear_page_cache_dirty_tag(struct page *page);\nint f2fs_init_post_read_processing(void);\nvoid f2fs_destroy_post_read_processing(void);\nint f2fs_init_post_read_wq(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_post_read_wq(struct f2fs_sb_info *sbi);\nextern const struct iomap_ops f2fs_iomap_ops;\n\n \nint f2fs_start_gc_thread(struct f2fs_sb_info *sbi);\nvoid f2fs_stop_gc_thread(struct f2fs_sb_info *sbi);\nblock_t f2fs_start_bidx_of_node(unsigned int node_ofs, struct inode *inode);\nint f2fs_gc(struct f2fs_sb_info *sbi, struct f2fs_gc_control *gc_control);\nvoid f2fs_build_gc_manager(struct f2fs_sb_info *sbi);\nint f2fs_resize_fs(struct file *filp, __u64 block_count);\nint __init f2fs_create_garbage_collection_cache(void);\nvoid f2fs_destroy_garbage_collection_cache(void);\n \nint f2fs_get_victim(struct f2fs_sb_info *sbi, unsigned int *result,\n\t\t\tint gc_type, int type, char alloc_mode,\n\t\t\tunsigned long long age);\n\n \nint f2fs_recover_fsync_data(struct f2fs_sb_info *sbi, bool check_only);\nbool f2fs_space_for_roll_forward(struct f2fs_sb_info *sbi);\nint __init f2fs_create_recovery_cache(void);\nvoid f2fs_destroy_recovery_cache(void);\n\n \n#ifdef CONFIG_F2FS_STAT_FS\nstruct f2fs_stat_info {\n\tstruct list_head stat_list;\n\tstruct f2fs_sb_info *sbi;\n\tint all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;\n\tint main_area_segs, main_area_sections, main_area_zones;\n\tunsigned long long hit_cached[NR_EXTENT_CACHES];\n\tunsigned long long hit_rbtree[NR_EXTENT_CACHES];\n\tunsigned long long total_ext[NR_EXTENT_CACHES];\n\tunsigned long long hit_total[NR_EXTENT_CACHES];\n\tint ext_tree[NR_EXTENT_CACHES];\n\tint zombie_tree[NR_EXTENT_CACHES];\n\tint ext_node[NR_EXTENT_CACHES];\n\t \n\tunsigned long long ext_mem[NR_EXTENT_CACHES];\n\t \n\tunsigned long long hit_largest;\n\t \n\tunsigned long long allocated_data_blocks;\n\tint ndirty_node, ndirty_dent, ndirty_meta, ndirty_imeta;\n\tint ndirty_data, ndirty_qdata;\n\tunsigned int ndirty_dirs, ndirty_files, nquota_files, ndirty_all;\n\tint nats, dirty_nats, sits, dirty_sits;\n\tint free_nids, avail_nids, alloc_nids;\n\tint total_count, utilization;\n\tint nr_wb_cp_data, nr_wb_data;\n\tint nr_rd_data, nr_rd_node, nr_rd_meta;\n\tint nr_dio_read, nr_dio_write;\n\tunsigned int io_skip_bggc, other_skip_bggc;\n\tint nr_flushing, nr_flushed, flush_list_empty;\n\tint nr_discarding, nr_discarded;\n\tint nr_discard_cmd;\n\tunsigned int undiscard_blks;\n\tint nr_issued_ckpt, nr_total_ckpt, nr_queued_ckpt;\n\tunsigned int cur_ckpt_time, peak_ckpt_time;\n\tint inline_xattr, inline_inode, inline_dir, append, update, orphans;\n\tint compr_inode, swapfile_inode;\n\tunsigned long long compr_blocks;\n\tint aw_cnt, max_aw_cnt;\n\tunsigned int valid_count, valid_node_count, valid_inode_count, discard_blks;\n\tunsigned int bimodal, avg_vblocks;\n\tint util_free, util_valid, util_invalid;\n\tint rsvd_segs, overp_segs;\n\tint dirty_count, node_pages, meta_pages, compress_pages;\n\tint compress_page_hit;\n\tint prefree_count, free_segs, free_secs;\n\tint cp_call_count[MAX_CALL_TYPE], cp_count;\n\tint gc_call_count[MAX_CALL_TYPE];\n\tint gc_segs[2][2];\n\tint gc_secs[2][2];\n\tint tot_blks, data_blks, node_blks;\n\tint bg_data_blks, bg_node_blks;\n\tint curseg[NR_CURSEG_TYPE];\n\tint cursec[NR_CURSEG_TYPE];\n\tint curzone[NR_CURSEG_TYPE];\n\tunsigned int dirty_seg[NR_CURSEG_TYPE];\n\tunsigned int full_seg[NR_CURSEG_TYPE];\n\tunsigned int valid_blks[NR_CURSEG_TYPE];\n\n\tunsigned int meta_count[META_MAX];\n\tunsigned int segment_count[2];\n\tunsigned int block_count[2];\n\tunsigned int inplace_count;\n\tunsigned long long base_mem, cache_mem, page_mem;\n};\n\nstatic inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_stat_info *)sbi->stat_info;\n}\n\n#define stat_inc_cp_call_count(sbi, foreground)\t\t\t\t\\\n\t\tatomic_inc(&sbi->cp_call_count[(foreground)])\n#define stat_inc_cp_count(si)\t\t(F2FS_STAT(sbi)->cp_count++)\n#define stat_io_skip_bggc_count(sbi)\t((sbi)->io_skip_bggc++)\n#define stat_other_skip_bggc_count(sbi)\t((sbi)->other_skip_bggc++)\n#define stat_inc_dirty_inode(sbi, type)\t((sbi)->ndirty_inode[type]++)\n#define stat_dec_dirty_inode(sbi, type)\t((sbi)->ndirty_inode[type]--)\n#define stat_inc_total_hit(sbi, type)\t\t(atomic64_inc(&(sbi)->total_hit_ext[type]))\n#define stat_inc_rbtree_node_hit(sbi, type)\t(atomic64_inc(&(sbi)->read_hit_rbtree[type]))\n#define stat_inc_largest_node_hit(sbi)\t(atomic64_inc(&(sbi)->read_hit_largest))\n#define stat_inc_cached_node_hit(sbi, type)\t(atomic64_inc(&(sbi)->read_hit_cached[type]))\n#define stat_inc_inline_xattr(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_xattr(inode))\t\t\t\\\n\t\t\t(atomic_inc(&F2FS_I_SB(inode)->inline_xattr));\t\\\n\t} while (0)\n#define stat_dec_inline_xattr(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_xattr(inode))\t\t\t\\\n\t\t\t(atomic_dec(&F2FS_I_SB(inode)->inline_xattr));\t\\\n\t} while (0)\n#define stat_inc_inline_inode(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_data(inode))\t\t\t\\\n\t\t\t(atomic_inc(&F2FS_I_SB(inode)->inline_inode));\t\\\n\t} while (0)\n#define stat_dec_inline_inode(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_data(inode))\t\t\t\\\n\t\t\t(atomic_dec(&F2FS_I_SB(inode)->inline_inode));\t\\\n\t} while (0)\n#define stat_inc_inline_dir(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_dentry(inode))\t\t\t\\\n\t\t\t(atomic_inc(&F2FS_I_SB(inode)->inline_dir));\t\\\n\t} while (0)\n#define stat_dec_inline_dir(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_has_inline_dentry(inode))\t\t\t\\\n\t\t\t(atomic_dec(&F2FS_I_SB(inode)->inline_dir));\t\\\n\t} while (0)\n#define stat_inc_compr_inode(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_compressed_file(inode))\t\t\t\\\n\t\t\t(atomic_inc(&F2FS_I_SB(inode)->compr_inode));\t\\\n\t} while (0)\n#define stat_dec_compr_inode(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (f2fs_compressed_file(inode))\t\t\t\\\n\t\t\t(atomic_dec(&F2FS_I_SB(inode)->compr_inode));\t\\\n\t} while (0)\n#define stat_add_compr_blocks(inode, blocks)\t\t\t\t\\\n\t\t(atomic64_add(blocks, &F2FS_I_SB(inode)->compr_blocks))\n#define stat_sub_compr_blocks(inode, blocks)\t\t\t\t\\\n\t\t(atomic64_sub(blocks, &F2FS_I_SB(inode)->compr_blocks))\n#define stat_inc_swapfile_inode(inode)\t\t\t\t\t\\\n\t\t(atomic_inc(&F2FS_I_SB(inode)->swapfile_inode))\n#define stat_dec_swapfile_inode(inode)\t\t\t\t\t\\\n\t\t(atomic_dec(&F2FS_I_SB(inode)->swapfile_inode))\n#define stat_inc_atomic_inode(inode)\t\t\t\t\t\\\n\t\t\t(atomic_inc(&F2FS_I_SB(inode)->atomic_files))\n#define stat_dec_atomic_inode(inode)\t\t\t\t\t\\\n\t\t\t(atomic_dec(&F2FS_I_SB(inode)->atomic_files))\n#define stat_inc_meta_count(sbi, blkaddr)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (blkaddr < SIT_I(sbi)->sit_base_addr)\t\t\\\n\t\t\tatomic_inc(&(sbi)->meta_count[META_CP]);\t\\\n\t\telse if (blkaddr < NM_I(sbi)->nat_blkaddr)\t\t\\\n\t\t\tatomic_inc(&(sbi)->meta_count[META_SIT]);\t\\\n\t\telse if (blkaddr < SM_I(sbi)->ssa_blkaddr)\t\t\\\n\t\t\tatomic_inc(&(sbi)->meta_count[META_NAT]);\t\\\n\t\telse if (blkaddr < SM_I(sbi)->main_blkaddr)\t\t\\\n\t\t\tatomic_inc(&(sbi)->meta_count[META_SSA]);\t\\\n\t} while (0)\n#define stat_inc_seg_type(sbi, curseg)\t\t\t\t\t\\\n\t\t((sbi)->segment_count[(curseg)->alloc_type]++)\n#define stat_inc_block_count(sbi, curseg)\t\t\t\t\\\n\t\t((sbi)->block_count[(curseg)->alloc_type]++)\n#define stat_inc_inplace_blocks(sbi)\t\t\t\t\t\\\n\t\t(atomic_inc(&(sbi)->inplace_count))\n#define stat_update_max_atomic_write(inode)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint cur = atomic_read(&F2FS_I_SB(inode)->atomic_files);\t\\\n\t\tint max = atomic_read(&F2FS_I_SB(inode)->max_aw_cnt);\t\\\n\t\tif (cur > max)\t\t\t\t\t\t\\\n\t\t\tatomic_set(&F2FS_I_SB(inode)->max_aw_cnt, cur);\t\\\n\t} while (0)\n#define stat_inc_gc_call_count(sbi, foreground)\t\t\t\t\\\n\t\t(F2FS_STAT(sbi)->gc_call_count[(foreground)]++)\n#define stat_inc_gc_sec_count(sbi, type, gc_type)\t\t\t\\\n\t\t(F2FS_STAT(sbi)->gc_secs[(type)][(gc_type)]++)\n#define stat_inc_gc_seg_count(sbi, type, gc_type)\t\t\t\\\n\t\t(F2FS_STAT(sbi)->gc_segs[(type)][(gc_type)]++)\n\n#define stat_inc_tot_blk_count(si, blks)\t\t\t\t\\\n\t((si)->tot_blks += (blks))\n\n#define stat_inc_data_blk_count(sbi, blks, gc_type)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\t\t\\\n\t\tstat_inc_tot_blk_count(si, blks);\t\t\t\\\n\t\tsi->data_blks += (blks);\t\t\t\t\\\n\t\tsi->bg_data_blks += ((gc_type) == BG_GC) ? (blks) : 0;\t\\\n\t} while (0)\n\n#define stat_inc_node_blk_count(sbi, blks, gc_type)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\t\t\\\n\t\tstat_inc_tot_blk_count(si, blks);\t\t\t\\\n\t\tsi->node_blks += (blks);\t\t\t\t\\\n\t\tsi->bg_node_blks += ((gc_type) == BG_GC) ? (blks) : 0;\t\\\n\t} while (0)\n\nint f2fs_build_stats(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_stats(struct f2fs_sb_info *sbi);\nvoid __init f2fs_create_root_stats(void);\nvoid f2fs_destroy_root_stats(void);\nvoid f2fs_update_sit_info(struct f2fs_sb_info *sbi);\n#else\n#define stat_inc_cp_call_count(sbi, foreground)\t\tdo { } while (0)\n#define stat_inc_cp_count(sbi)\t\t\t\tdo { } while (0)\n#define stat_io_skip_bggc_count(sbi)\t\t\tdo { } while (0)\n#define stat_other_skip_bggc_count(sbi)\t\t\tdo { } while (0)\n#define stat_inc_dirty_inode(sbi, type)\t\t\tdo { } while (0)\n#define stat_dec_dirty_inode(sbi, type)\t\t\tdo { } while (0)\n#define stat_inc_total_hit(sbi, type)\t\t\tdo { } while (0)\n#define stat_inc_rbtree_node_hit(sbi, type)\t\tdo { } while (0)\n#define stat_inc_largest_node_hit(sbi)\t\t\tdo { } while (0)\n#define stat_inc_cached_node_hit(sbi, type)\t\tdo { } while (0)\n#define stat_inc_inline_xattr(inode)\t\t\tdo { } while (0)\n#define stat_dec_inline_xattr(inode)\t\t\tdo { } while (0)\n#define stat_inc_inline_inode(inode)\t\t\tdo { } while (0)\n#define stat_dec_inline_inode(inode)\t\t\tdo { } while (0)\n#define stat_inc_inline_dir(inode)\t\t\tdo { } while (0)\n#define stat_dec_inline_dir(inode)\t\t\tdo { } while (0)\n#define stat_inc_compr_inode(inode)\t\t\tdo { } while (0)\n#define stat_dec_compr_inode(inode)\t\t\tdo { } while (0)\n#define stat_add_compr_blocks(inode, blocks)\t\tdo { } while (0)\n#define stat_sub_compr_blocks(inode, blocks)\t\tdo { } while (0)\n#define stat_inc_swapfile_inode(inode)\t\t\tdo { } while (0)\n#define stat_dec_swapfile_inode(inode)\t\t\tdo { } while (0)\n#define stat_inc_atomic_inode(inode)\t\t\tdo { } while (0)\n#define stat_dec_atomic_inode(inode)\t\t\tdo { } while (0)\n#define stat_update_max_atomic_write(inode)\t\tdo { } while (0)\n#define stat_inc_meta_count(sbi, blkaddr)\t\tdo { } while (0)\n#define stat_inc_seg_type(sbi, curseg)\t\t\tdo { } while (0)\n#define stat_inc_block_count(sbi, curseg)\t\tdo { } while (0)\n#define stat_inc_inplace_blocks(sbi)\t\t\tdo { } while (0)\n#define stat_inc_gc_call_count(sbi, foreground)\t\tdo { } while (0)\n#define stat_inc_gc_sec_count(sbi, type, gc_type)\tdo { } while (0)\n#define stat_inc_gc_seg_count(sbi, type, gc_type)\tdo { } while (0)\n#define stat_inc_tot_blk_count(si, blks)\t\tdo { } while (0)\n#define stat_inc_data_blk_count(sbi, blks, gc_type)\tdo { } while (0)\n#define stat_inc_node_blk_count(sbi, blks, gc_type)\tdo { } while (0)\n\nstatic inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }\nstatic inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }\nstatic inline void __init f2fs_create_root_stats(void) { }\nstatic inline void f2fs_destroy_root_stats(void) { }\nstatic inline void f2fs_update_sit_info(struct f2fs_sb_info *sbi) {}\n#endif\n\nextern const struct file_operations f2fs_dir_operations;\nextern const struct file_operations f2fs_file_operations;\nextern const struct inode_operations f2fs_file_inode_operations;\nextern const struct address_space_operations f2fs_dblock_aops;\nextern const struct address_space_operations f2fs_node_aops;\nextern const struct address_space_operations f2fs_meta_aops;\nextern const struct inode_operations f2fs_dir_inode_operations;\nextern const struct inode_operations f2fs_symlink_inode_operations;\nextern const struct inode_operations f2fs_encrypted_symlink_inode_operations;\nextern const struct inode_operations f2fs_special_inode_operations;\nextern struct kmem_cache *f2fs_inode_entry_slab;\n\n \nbool f2fs_may_inline_data(struct inode *inode);\nbool f2fs_sanity_check_inline_data(struct inode *inode);\nbool f2fs_may_inline_dentry(struct inode *inode);\nvoid f2fs_do_read_inline_data(struct page *page, struct page *ipage);\nvoid f2fs_truncate_inline_inode(struct inode *inode,\n\t\t\t\t\t\tstruct page *ipage, u64 from);\nint f2fs_read_inline_data(struct inode *inode, struct page *page);\nint f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page);\nint f2fs_convert_inline_inode(struct inode *inode);\nint f2fs_try_convert_inline_dir(struct inode *dir, struct dentry *dentry);\nint f2fs_write_inline_data(struct inode *inode, struct page *page);\nint f2fs_recover_inline_data(struct inode *inode, struct page *npage);\nstruct f2fs_dir_entry *f2fs_find_in_inline_dir(struct inode *dir,\n\t\t\t\t\tconst struct f2fs_filename *fname,\n\t\t\t\t\tstruct page **res_page);\nint f2fs_make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\tstruct page *ipage);\nint f2fs_add_inline_entry(struct inode *dir, const struct f2fs_filename *fname,\n\t\t\tstruct inode *inode, nid_t ino, umode_t mode);\nvoid f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry,\n\t\t\t\tstruct page *page, struct inode *dir,\n\t\t\t\tstruct inode *inode);\nbool f2fs_empty_inline_dir(struct inode *dir);\nint f2fs_read_inline_dir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fscrypt_str *fstr);\nint f2fs_inline_data_fiemap(struct inode *inode,\n\t\t\tstruct fiemap_extent_info *fieinfo,\n\t\t\t__u64 start, __u64 len);\n\n \nunsigned long f2fs_shrink_count(struct shrinker *shrink,\n\t\t\tstruct shrink_control *sc);\nunsigned long f2fs_shrink_scan(struct shrinker *shrink,\n\t\t\tstruct shrink_control *sc);\nvoid f2fs_join_shrinker(struct f2fs_sb_info *sbi);\nvoid f2fs_leave_shrinker(struct f2fs_sb_info *sbi);\n\n \nbool sanity_check_extent_cache(struct inode *inode);\nvoid f2fs_init_extent_tree(struct inode *inode);\nvoid f2fs_drop_extent_tree(struct inode *inode);\nvoid f2fs_destroy_extent_node(struct inode *inode);\nvoid f2fs_destroy_extent_tree(struct inode *inode);\nvoid f2fs_init_extent_cache_info(struct f2fs_sb_info *sbi);\nint __init f2fs_create_extent_cache(void);\nvoid f2fs_destroy_extent_cache(void);\n\n \nvoid f2fs_init_read_extent_tree(struct inode *inode, struct page *ipage);\nbool f2fs_lookup_read_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\tstruct extent_info *ei);\nbool f2fs_lookup_read_extent_cache_block(struct inode *inode, pgoff_t index,\n\t\t\tblock_t *blkaddr);\nvoid f2fs_update_read_extent_cache(struct dnode_of_data *dn);\nvoid f2fs_update_read_extent_cache_range(struct dnode_of_data *dn,\n\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len);\nunsigned int f2fs_shrink_read_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\tint nr_shrink);\n\n \nvoid f2fs_init_age_extent_tree(struct inode *inode);\nbool f2fs_lookup_age_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\tstruct extent_info *ei);\nvoid f2fs_update_age_extent_cache(struct dnode_of_data *dn);\nvoid f2fs_update_age_extent_cache_range(struct dnode_of_data *dn,\n\t\t\tpgoff_t fofs, unsigned int len);\nunsigned int f2fs_shrink_age_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\tint nr_shrink);\n\n \n#define MIN_RA_MUL\t2\n#define MAX_RA_MUL\t256\n\nint __init f2fs_init_sysfs(void);\nvoid f2fs_exit_sysfs(void);\nint f2fs_register_sysfs(struct f2fs_sb_info *sbi);\nvoid f2fs_unregister_sysfs(struct f2fs_sb_info *sbi);\n\n \nextern const struct fsverity_operations f2fs_verityops;\n\n \nstatic inline bool f2fs_encrypted_file(struct inode *inode)\n{\n\treturn IS_ENCRYPTED(inode) && S_ISREG(inode->i_mode);\n}\n\nstatic inline void f2fs_set_encrypted_inode(struct inode *inode)\n{\n#ifdef CONFIG_FS_ENCRYPTION\n\tfile_set_encrypt(inode);\n\tf2fs_set_inode_flags(inode);\n#endif\n}\n\n \nstatic inline bool f2fs_post_read_required(struct inode *inode)\n{\n\treturn f2fs_encrypted_file(inode) || fsverity_active(inode) ||\n\t\tf2fs_compressed_file(inode);\n}\n\n \n#ifdef CONFIG_F2FS_FS_COMPRESSION\nbool f2fs_is_compressed_page(struct page *page);\nstruct page *f2fs_compress_control_page(struct page *page);\nint f2fs_prepare_compress_overwrite(struct inode *inode,\n\t\t\tstruct page **pagep, pgoff_t index, void **fsdata);\nbool f2fs_compress_write_end(struct inode *inode, void *fsdata,\n\t\t\t\t\tpgoff_t index, unsigned copied);\nint f2fs_truncate_partial_cluster(struct inode *inode, u64 from, bool lock);\nvoid f2fs_compress_write_end_io(struct bio *bio, struct page *page);\nbool f2fs_is_compress_backend_ready(struct inode *inode);\nbool f2fs_is_compress_level_valid(int alg, int lvl);\nint __init f2fs_init_compress_mempool(void);\nvoid f2fs_destroy_compress_mempool(void);\nvoid f2fs_decompress_cluster(struct decompress_io_ctx *dic, bool in_task);\nvoid f2fs_end_read_compressed_page(struct page *page, bool failed,\n\t\t\t\tblock_t blkaddr, bool in_task);\nbool f2fs_cluster_is_empty(struct compress_ctx *cc);\nbool f2fs_cluster_can_merge_page(struct compress_ctx *cc, pgoff_t index);\nbool f2fs_all_cluster_page_ready(struct compress_ctx *cc, struct page **pages,\n\t\t\t\tint index, int nr_pages, bool uptodate);\nbool f2fs_sanity_check_cluster(struct dnode_of_data *dn);\nvoid f2fs_compress_ctx_add_page(struct compress_ctx *cc, struct page *page);\nint f2fs_write_multi_pages(struct compress_ctx *cc,\n\t\t\t\t\t\tint *submitted,\n\t\t\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\t\t\tenum iostat_type io_type);\nint f2fs_is_compressed_cluster(struct inode *inode, pgoff_t index);\nvoid f2fs_update_read_extent_tree_range_compressed(struct inode *inode,\n\t\t\t\tpgoff_t fofs, block_t blkaddr,\n\t\t\t\tunsigned int llen, unsigned int c_len);\nint f2fs_read_multi_pages(struct compress_ctx *cc, struct bio **bio_ret,\n\t\t\t\tunsigned nr_pages, sector_t *last_block_in_bio,\n\t\t\t\tbool is_readahead, bool for_write);\nstruct decompress_io_ctx *f2fs_alloc_dic(struct compress_ctx *cc);\nvoid f2fs_decompress_end_io(struct decompress_io_ctx *dic, bool failed,\n\t\t\t\tbool in_task);\nvoid f2fs_put_page_dic(struct page *page, bool in_task);\nunsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn);\nint f2fs_init_compress_ctx(struct compress_ctx *cc);\nvoid f2fs_destroy_compress_ctx(struct compress_ctx *cc, bool reuse);\nvoid f2fs_init_compress_info(struct f2fs_sb_info *sbi);\nint f2fs_init_compress_inode(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_compress_inode(struct f2fs_sb_info *sbi);\nint f2fs_init_page_array_cache(struct f2fs_sb_info *sbi);\nvoid f2fs_destroy_page_array_cache(struct f2fs_sb_info *sbi);\nint __init f2fs_init_compress_cache(void);\nvoid f2fs_destroy_compress_cache(void);\nstruct address_space *COMPRESS_MAPPING(struct f2fs_sb_info *sbi);\nvoid f2fs_invalidate_compress_page(struct f2fs_sb_info *sbi, block_t blkaddr);\nvoid f2fs_cache_compressed_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\t\tnid_t ino, block_t blkaddr);\nbool f2fs_load_compressed_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\t\t\t\tblock_t blkaddr);\nvoid f2fs_invalidate_compress_pages(struct f2fs_sb_info *sbi, nid_t ino);\n#define inc_compr_inode_stat(inode)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\t\t\\\n\t\tsbi->compr_new_inode++;\t\t\t\t\t\\\n\t} while (0)\n#define add_compr_block_stat(inode, blocks)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\t\t\\\n\t\tint diff = F2FS_I(inode)->i_cluster_size - blocks;\t\\\n\t\tsbi->compr_written_block += blocks;\t\t\t\\\n\t\tsbi->compr_saved_block += diff;\t\t\t\t\\\n\t} while (0)\n#else\nstatic inline bool f2fs_is_compressed_page(struct page *page) { return false; }\nstatic inline bool f2fs_is_compress_backend_ready(struct inode *inode)\n{\n\tif (!f2fs_compressed_file(inode))\n\t\treturn true;\n\t \n\treturn false;\n}\nstatic inline bool f2fs_is_compress_level_valid(int alg, int lvl) { return false; }\nstatic inline struct page *f2fs_compress_control_page(struct page *page)\n{\n\tWARN_ON_ONCE(1);\n\treturn ERR_PTR(-EINVAL);\n}\nstatic inline int __init f2fs_init_compress_mempool(void) { return 0; }\nstatic inline void f2fs_destroy_compress_mempool(void) { }\nstatic inline void f2fs_decompress_cluster(struct decompress_io_ctx *dic,\n\t\t\t\tbool in_task) { }\nstatic inline void f2fs_end_read_compressed_page(struct page *page,\n\t\t\t\tbool failed, block_t blkaddr, bool in_task)\n{\n\tWARN_ON_ONCE(1);\n}\nstatic inline void f2fs_put_page_dic(struct page *page, bool in_task)\n{\n\tWARN_ON_ONCE(1);\n}\nstatic inline unsigned int f2fs_cluster_blocks_are_contiguous(struct dnode_of_data *dn) { return 0; }\nstatic inline bool f2fs_sanity_check_cluster(struct dnode_of_data *dn) { return false; }\nstatic inline int f2fs_init_compress_inode(struct f2fs_sb_info *sbi) { return 0; }\nstatic inline void f2fs_destroy_compress_inode(struct f2fs_sb_info *sbi) { }\nstatic inline int f2fs_init_page_array_cache(struct f2fs_sb_info *sbi) { return 0; }\nstatic inline void f2fs_destroy_page_array_cache(struct f2fs_sb_info *sbi) { }\nstatic inline int __init f2fs_init_compress_cache(void) { return 0; }\nstatic inline void f2fs_destroy_compress_cache(void) { }\nstatic inline void f2fs_invalidate_compress_page(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkaddr) { }\nstatic inline void f2fs_cache_compressed_page(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct page *page, nid_t ino, block_t blkaddr) { }\nstatic inline bool f2fs_load_compressed_page(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct page *page, block_t blkaddr) { return false; }\nstatic inline void f2fs_invalidate_compress_pages(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tnid_t ino) { }\n#define inc_compr_inode_stat(inode)\t\tdo { } while (0)\nstatic inline void f2fs_update_read_extent_tree_range_compressed(\n\t\t\t\tstruct inode *inode,\n\t\t\t\tpgoff_t fofs, block_t blkaddr,\n\t\t\t\tunsigned int llen, unsigned int c_len) { }\n#endif\n\nstatic inline int set_compress_context(struct inode *inode)\n{\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tF2FS_I(inode)->i_compress_algorithm =\n\t\t\tF2FS_OPTION(sbi).compress_algorithm;\n\tF2FS_I(inode)->i_log_cluster_size =\n\t\t\tF2FS_OPTION(sbi).compress_log_size;\n\tF2FS_I(inode)->i_compress_flag =\n\t\t\tF2FS_OPTION(sbi).compress_chksum ?\n\t\t\t\tBIT(COMPRESS_CHKSUM) : 0;\n\tF2FS_I(inode)->i_cluster_size =\n\t\t\tBIT(F2FS_I(inode)->i_log_cluster_size);\n\tif ((F2FS_I(inode)->i_compress_algorithm == COMPRESS_LZ4 ||\n\t\tF2FS_I(inode)->i_compress_algorithm == COMPRESS_ZSTD) &&\n\t\t\tF2FS_OPTION(sbi).compress_level)\n\t\tF2FS_I(inode)->i_compress_level =\n\t\t\t\tF2FS_OPTION(sbi).compress_level;\n\tF2FS_I(inode)->i_flags |= F2FS_COMPR_FL;\n\tset_inode_flag(inode, FI_COMPRESSED_FILE);\n\tstat_inc_compr_inode(inode);\n\tinc_compr_inode_stat(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic inline bool f2fs_disable_compressed_file(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn true;\n\tif (S_ISREG(inode->i_mode) && F2FS_HAS_BLOCKS(inode))\n\t\treturn false;\n\n\tfi->i_flags &= ~F2FS_COMPR_FL;\n\tstat_dec_compr_inode(inode);\n\tclear_inode_flag(inode, FI_COMPRESSED_FILE);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\treturn true;\n}\n\n#define F2FS_FEATURE_FUNCS(name, flagname) \\\nstatic inline bool f2fs_sb_has_##name(struct f2fs_sb_info *sbi) \\\n{ \\\n\treturn F2FS_HAS_FEATURE(sbi, F2FS_FEATURE_##flagname); \\\n}\n\nF2FS_FEATURE_FUNCS(encrypt, ENCRYPT);\nF2FS_FEATURE_FUNCS(blkzoned, BLKZONED);\nF2FS_FEATURE_FUNCS(extra_attr, EXTRA_ATTR);\nF2FS_FEATURE_FUNCS(project_quota, PRJQUOTA);\nF2FS_FEATURE_FUNCS(inode_chksum, INODE_CHKSUM);\nF2FS_FEATURE_FUNCS(flexible_inline_xattr, FLEXIBLE_INLINE_XATTR);\nF2FS_FEATURE_FUNCS(quota_ino, QUOTA_INO);\nF2FS_FEATURE_FUNCS(inode_crtime, INODE_CRTIME);\nF2FS_FEATURE_FUNCS(lost_found, LOST_FOUND);\nF2FS_FEATURE_FUNCS(verity, VERITY);\nF2FS_FEATURE_FUNCS(sb_chksum, SB_CHKSUM);\nF2FS_FEATURE_FUNCS(casefold, CASEFOLD);\nF2FS_FEATURE_FUNCS(compression, COMPRESSION);\nF2FS_FEATURE_FUNCS(readonly, RO);\n\n#ifdef CONFIG_BLK_DEV_ZONED\nstatic inline bool f2fs_blkz_is_seq(struct f2fs_sb_info *sbi, int devi,\n\t\t\t\t    block_t blkaddr)\n{\n\tunsigned int zno = blkaddr / sbi->blocks_per_blkz;\n\n\treturn test_bit(zno, FDEV(devi).blkz_seq);\n}\n#endif\n\nstatic inline int f2fs_bdev_index(struct f2fs_sb_info *sbi,\n\t\t\t\t  struct block_device *bdev)\n{\n\tint i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn 0;\n\n\tfor (i = 0; i < sbi->s_ndevs; i++)\n\t\tif (FDEV(i).bdev == bdev)\n\t\t\treturn i;\n\n\tWARN_ON(1);\n\treturn -1;\n}\n\nstatic inline bool f2fs_hw_should_discard(struct f2fs_sb_info *sbi)\n{\n\treturn f2fs_sb_has_blkzoned(sbi);\n}\n\nstatic inline bool f2fs_bdev_support_discard(struct block_device *bdev)\n{\n\treturn bdev_max_discard_sectors(bdev) || bdev_is_zoned(bdev);\n}\n\nstatic inline bool f2fs_hw_support_discard(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn f2fs_bdev_support_discard(sbi->sb->s_bdev);\n\n\tfor (i = 0; i < sbi->s_ndevs; i++)\n\t\tif (f2fs_bdev_support_discard(FDEV(i).bdev))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool f2fs_realtime_discard_enable(struct f2fs_sb_info *sbi)\n{\n\treturn (test_opt(sbi, DISCARD) && f2fs_hw_support_discard(sbi)) ||\n\t\t\t\t\tf2fs_hw_should_discard(sbi);\n}\n\nstatic inline bool f2fs_hw_is_readonly(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn bdev_read_only(sbi->sb->s_bdev);\n\n\tfor (i = 0; i < sbi->s_ndevs; i++)\n\t\tif (bdev_read_only(FDEV(i).bdev))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool f2fs_dev_is_readonly(struct f2fs_sb_info *sbi)\n{\n\treturn f2fs_sb_has_readonly(sbi) || f2fs_hw_is_readonly(sbi);\n}\n\nstatic inline bool f2fs_lfs_mode(struct f2fs_sb_info *sbi)\n{\n\treturn F2FS_OPTION(sbi).fs_mode == FS_MODE_LFS;\n}\n\nstatic inline bool f2fs_low_mem_mode(struct f2fs_sb_info *sbi)\n{\n\treturn F2FS_OPTION(sbi).memory_mode == MEMORY_MODE_LOW;\n}\n\nstatic inline bool f2fs_may_compress(struct inode *inode)\n{\n\tif (IS_SWAPFILE(inode) || f2fs_is_pinned_file(inode) ||\n\t\tf2fs_is_atomic_file(inode) || f2fs_has_inline_data(inode) ||\n\t\tf2fs_is_mmap_file(inode))\n\t\treturn false;\n\treturn S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode);\n}\n\nstatic inline void f2fs_i_compr_blocks_update(struct inode *inode,\n\t\t\t\t\t\tu64 blocks, bool add)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint diff = fi->i_cluster_size - blocks;\n\n\t \n\tif (!add && !atomic_read(&fi->i_compr_blocks))\n\t\treturn;\n\n\tif (add) {\n\t\tatomic_add(diff, &fi->i_compr_blocks);\n\t\tstat_add_compr_blocks(inode, diff);\n\t} else {\n\t\tatomic_sub(diff, &fi->i_compr_blocks);\n\t\tstat_sub_compr_blocks(inode, diff);\n\t}\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}\n\nstatic inline bool f2fs_allow_multi_device_dio(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\t\tint flag)\n{\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn false;\n\tif (flag != F2FS_GET_BLOCK_DIO)\n\t\treturn false;\n\treturn sbi->aligned_blksize;\n}\n\nstatic inline bool f2fs_need_verity(const struct inode *inode, pgoff_t idx)\n{\n\treturn fsverity_active(inode) &&\n\t       idx < DIV_ROUND_UP(inode->i_size, PAGE_SIZE);\n}\n\n#ifdef CONFIG_F2FS_FAULT_INJECTION\nextern void f2fs_build_fault_attr(struct f2fs_sb_info *sbi, unsigned int rate,\n\t\t\t\t\t\t\tunsigned int type);\n#else\n#define f2fs_build_fault_attr(sbi, rate, type)\t\tdo { } while (0)\n#endif\n\nstatic inline bool is_journalled_quota(struct f2fs_sb_info *sbi)\n{\n#ifdef CONFIG_QUOTA\n\tif (f2fs_sb_has_quota_ino(sbi))\n\t\treturn true;\n\tif (F2FS_OPTION(sbi).s_qf_names[USRQUOTA] ||\n\t\tF2FS_OPTION(sbi).s_qf_names[GRPQUOTA] ||\n\t\tF2FS_OPTION(sbi).s_qf_names[PRJQUOTA])\n\t\treturn true;\n#endif\n\treturn false;\n}\n\nstatic inline bool f2fs_block_unit_discard(struct f2fs_sb_info *sbi)\n{\n\treturn F2FS_OPTION(sbi).discard_unit == DISCARD_UNIT_BLOCK;\n}\n\nstatic inline void f2fs_io_schedule_timeout(long timeout)\n{\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tio_schedule_timeout(timeout);\n}\n\nstatic inline void f2fs_handle_page_eio(struct f2fs_sb_info *sbi, pgoff_t ofs,\n\t\t\t\t\tenum page_type type)\n{\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn;\n\n\tif (ofs == sbi->page_eio_ofs[type]) {\n\t\tif (sbi->page_eio_cnt[type]++ == MAX_RETRY_PAGE_EIO)\n\t\t\tset_ckpt_flags(sbi, CP_ERROR_FLAG);\n\t} else {\n\t\tsbi->page_eio_ofs[type] = ofs;\n\t\tsbi->page_eio_cnt[type] = 0;\n\t}\n}\n\nstatic inline bool f2fs_is_readonly(struct f2fs_sb_info *sbi)\n{\n\treturn f2fs_sb_has_readonly(sbi) || f2fs_readonly(sbi->sb);\n}\n\n#define EFSBADCRC\tEBADMSG\t\t \n#define EFSCORRUPTED\tEUCLEAN\t\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}