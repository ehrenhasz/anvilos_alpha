{
  "module_name": "verity.c",
  "hash_id": "efab72f0bda95e23dfda9d46cb8d7fe23fcc65859cadf9d535d26aa179d7770b",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/verity.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/f2fs_fs.h>\n\n#include \"f2fs.h\"\n#include \"xattr.h\"\n\n#define F2FS_VERIFY_VER\t(1)\n\nstatic inline loff_t f2fs_verity_metadata_pos(const struct inode *inode)\n{\n\treturn round_up(inode->i_size, 65536);\n}\n\n \nstatic int pagecache_read(struct inode *inode, void *buf, size_t count,\n\t\t\t  loff_t pos)\n{\n\twhile (count) {\n\t\tsize_t n = min_t(size_t, count,\n\t\t\t\t PAGE_SIZE - offset_in_page(pos));\n\t\tstruct page *page;\n\n\t\tpage = read_mapping_page(inode->i_mapping, pos >> PAGE_SHIFT,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tmemcpy_from_page(buf, page, offset_in_page(pos), n);\n\n\t\tput_page(page);\n\n\t\tbuf += n;\n\t\tpos += n;\n\t\tcount -= n;\n\t}\n\treturn 0;\n}\n\n \nstatic int pagecache_write(struct inode *inode, const void *buf, size_t count,\n\t\t\t   loff_t pos)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\tif (pos + count > inode->i_sb->s_maxbytes)\n\t\treturn -EFBIG;\n\n\twhile (count) {\n\t\tsize_t n = min_t(size_t, count,\n\t\t\t\t PAGE_SIZE - offset_in_page(pos));\n\t\tstruct page *page;\n\t\tvoid *fsdata = NULL;\n\t\tint res;\n\n\t\tres = aops->write_begin(NULL, mapping, pos, n, &page, &fsdata);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tmemcpy_to_page(page, offset_in_page(pos), buf, n);\n\n\t\tres = aops->write_end(NULL, mapping, pos, n, n, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tif (res != n)\n\t\t\treturn -EIO;\n\n\t\tbuf += n;\n\t\tpos += n;\n\t\tcount -= n;\n\t}\n\treturn 0;\n}\n\n \nstruct fsverity_descriptor_location {\n\t__le32 version;\n\t__le32 size;\n\t__le64 pos;\n};\n\nstatic int f2fs_begin_enable_verity(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint err;\n\n\tif (f2fs_verity_in_progress(inode))\n\t\treturn -EBUSY;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_convert_inline_inode(inode);\n\tif (err)\n\t\treturn err;\n\n\tset_inode_flag(inode, FI_VERITY_IN_PROGRESS);\n\treturn 0;\n}\n\nstatic int f2fs_end_enable_verity(struct file *filp, const void *desc,\n\t\t\t\t  size_t desc_size, u64 merkle_tree_size)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tu64 desc_pos = f2fs_verity_metadata_pos(inode) + merkle_tree_size;\n\tstruct fsverity_descriptor_location dloc = {\n\t\t.version = cpu_to_le32(F2FS_VERIFY_VER),\n\t\t.size = cpu_to_le32(desc_size),\n\t\t.pos = cpu_to_le64(desc_pos),\n\t};\n\tint err = 0, err2 = 0;\n\n\t \n\tif (desc == NULL)\n\t\tgoto cleanup;\n\n\t \n\terr = pagecache_write(inode, desc, desc_size, desc_pos);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\terr = filemap_write_and_wait(inode->i_mapping);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\terr = f2fs_setxattr(inode, F2FS_XATTR_INDEX_VERITY,\n\t\t\t    F2FS_XATTR_NAME_VERITY, &dloc, sizeof(dloc),\n\t\t\t    NULL, XATTR_CREATE);\n\tif (err)\n\t\tgoto cleanup;\n\n\t \n\tfile_set_verity(inode);\n\tf2fs_set_inode_flags(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\n\tclear_inode_flag(inode, FI_VERITY_IN_PROGRESS);\n\treturn 0;\n\ncleanup:\n\t \n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\terr2 = f2fs_truncate(inode);\n\tif (err2) {\n\t\tf2fs_err(sbi, \"Truncating verity metadata failed (errno=%d)\",\n\t\t\t err2);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t}\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tclear_inode_flag(inode, FI_VERITY_IN_PROGRESS);\n\treturn err ?: err2;\n}\n\nstatic int f2fs_get_verity_descriptor(struct inode *inode, void *buf,\n\t\t\t\t      size_t buf_size)\n{\n\tstruct fsverity_descriptor_location dloc;\n\tint res;\n\tu32 size;\n\tu64 pos;\n\n\t \n\tres = f2fs_getxattr(inode, F2FS_XATTR_INDEX_VERITY,\n\t\t\t    F2FS_XATTR_NAME_VERITY, &dloc, sizeof(dloc), NULL);\n\tif (res < 0 && res != -ERANGE)\n\t\treturn res;\n\tif (res != sizeof(dloc) || dloc.version != cpu_to_le32(F2FS_VERIFY_VER)) {\n\t\tf2fs_warn(F2FS_I_SB(inode), \"unknown verity xattr format\");\n\t\treturn -EINVAL;\n\t}\n\tsize = le32_to_cpu(dloc.size);\n\tpos = le64_to_cpu(dloc.pos);\n\n\t \n\tif (pos + size < pos || pos + size > inode->i_sb->s_maxbytes ||\n\t    pos < f2fs_verity_metadata_pos(inode) || size > INT_MAX) {\n\t\tf2fs_warn(F2FS_I_SB(inode), \"invalid verity xattr\");\n\t\tf2fs_handle_error(F2FS_I_SB(inode),\n\t\t\t\tERROR_CORRUPTED_VERITY_XATTR);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (buf_size) {\n\t\tif (size > buf_size)\n\t\t\treturn -ERANGE;\n\t\tres = pagecache_read(inode, buf, size, pos);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn size;\n}\n\nstatic struct page *f2fs_read_merkle_tree_page(struct inode *inode,\n\t\t\t\t\t       pgoff_t index,\n\t\t\t\t\t       unsigned long num_ra_pages)\n{\n\tstruct page *page;\n\n\tindex += f2fs_verity_metadata_pos(inode) >> PAGE_SHIFT;\n\n\tpage = find_get_page_flags(inode->i_mapping, index, FGP_ACCESSED);\n\tif (!page || !PageUptodate(page)) {\n\t\tDEFINE_READAHEAD(ractl, NULL, NULL, inode->i_mapping, index);\n\n\t\tif (page)\n\t\t\tput_page(page);\n\t\telse if (num_ra_pages > 1)\n\t\t\tpage_cache_ra_unbounded(&ractl, num_ra_pages, 0);\n\t\tpage = read_mapping_page(inode->i_mapping, index, NULL);\n\t}\n\treturn page;\n}\n\nstatic int f2fs_write_merkle_tree_block(struct inode *inode, const void *buf,\n\t\t\t\t\tu64 pos, unsigned int size)\n{\n\tpos += f2fs_verity_metadata_pos(inode);\n\n\treturn pagecache_write(inode, buf, size, pos);\n}\n\nconst struct fsverity_operations f2fs_verityops = {\n\t.begin_enable_verity\t= f2fs_begin_enable_verity,\n\t.end_enable_verity\t= f2fs_end_enable_verity,\n\t.get_verity_descriptor\t= f2fs_get_verity_descriptor,\n\t.read_merkle_tree_page\t= f2fs_read_merkle_tree_page,\n\t.write_merkle_tree_block = f2fs_write_merkle_tree_block,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}