{
  "module_name": "acl.c",
  "hash_id": "57802fe3205dfac6e4ed49ac1e35bb7eae9b7ccb047bebf36ac8305b056f6540",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/acl.c",
  "human_readable_source": "\n \n#include <linux/f2fs_fs.h>\n#include \"f2fs.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n\nstatic inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}\n\nstatic inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}\n\nstatic struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (size < sizeof(struct f2fs_acl_header))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic void *f2fs_acl_to_disk(struct f2fs_sb_info *sbi,\n\t\t\t\tconst struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = f2fs_kmalloc(sbi, sizeof(struct f2fs_acl_header) +\n\t\t\tacl->a_count * sizeof(struct f2fs_acl_entry),\n\t\t\tGFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = f2fs_kmalloc(F2FS_I_SB(inode), retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\treturn acl;\n}\n\nstruct posix_acl *f2fs_get_acl(struct inode *inode, int type, bool rcu)\n{\n\tif (rcu)\n\t\treturn ERR_PTR(-ECHILD);\n\n\treturn __f2fs_get_acl(inode, type, NULL);\n}\n\nstatic int f2fs_acl_update_mode(struct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode, umode_t *mode_p,\n\t\t\t\tstruct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\tif (is_inode_flag_set(inode, FI_ACL_MODE))\n\t\tmode = F2FS_I(inode)->i_acl_mode;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!vfsgid_in_group_p(i_gid_into_vfsgid(idmap, inode)) &&\n\t    !capable_wrt_inode_uidgid(idmap, inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}\n\nstatic int __f2fs_set_acl(struct mnt_idmap *idmap,\n\t\t\tstruct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tumode_t mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl && !ipage) {\n\t\t\terror = f2fs_acl_update_mode(idmap, inode,\n\t\t\t\t\t\t\t\t&mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, mode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(F2FS_I_SB(inode), acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}\n\nint f2fs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\n\treturn __f2fs_set_acl(idmap, inode, type, acl, NULL);\n}\n\n \nstatic struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}\n\nstatic int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t \n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n\treturn not_equiv;\n}\n\nstatic int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tclone = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!clone) {\n\t\tret = -ENOMEM;\n\t\tgoto release_acl;\n\t}\n\n\tret = f2fs_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nrelease_clone:\n\tposix_acl_release(clone);\nrelease_acl:\n\tposix_acl_release(p);\n\treturn ret;\n}\n\nint f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(NULL, inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t} else {\n\t\tinode->i_default_acl = NULL;\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(NULL, inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t} else {\n\t\tinode->i_acl = NULL;\n\t}\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}