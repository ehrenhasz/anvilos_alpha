{
  "module_name": "node.c",
  "hash_id": "057e2ea1f0e000040423775e99b77392c7f6f3b44ac1f8dabdcc1ce6e932e1d0",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/node.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/mpage.h>\n#include <linux/sched/mm.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"xattr.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n\n#define on_f2fs_build_free_nids(nmi) mutex_is_locked(&(nm_i)->build_lock)\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\nstatic struct kmem_cache *fsync_node_entry_slab;\n\n \nint f2fs_check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tif (unlikely(nid < F2FS_ROOT_INO(sbi) || nid >= NM_I(sbi)->max_nid)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, \"%s: out-of-range nid=%x, run fsck to fix.\",\n\t\t\t  __func__, nid);\n\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_INODE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nbool f2fs_available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tif (!nm_i)\n\t\treturn true;\n\n\tsi_meminfo(&val);\n\n\t \n\tavail_ram = val.totalram - val.totalhigh;\n\n\t \n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->nid_cnt[FREE_NID] *\n\t\t\t\tsizeof(struct free_nid)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt[TOTAL_NAT] *\n\t\t\t\tsizeof(struct nat_entry)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t\tif (excess_cached_nats(sbi))\n\t\t\tres = false;\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_INO_ENTRY; i++)\n\t\t\tmem_size += sbi->im[i].ino_num *\n\t\t\t\t\t\tsizeof(struct ino_entry);\n\t\tmem_size >>= PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == READ_EXTENT_CACHE || type == AGE_EXTENT_CACHE) {\n\t\tenum extent_type etype = type == READ_EXTENT_CACHE ?\n\t\t\t\t\t\tEX_READ : EX_BLOCK_AGE;\n\t\tstruct extent_tree_info *eti = &sbi->extent_tree[etype];\n\n\t\tmem_size = (atomic_read(&eti->total_ext_tree) *\n\t\t\t\tsizeof(struct extent_tree) +\n\t\t\t\tatomic_read(&eti->total_ext_node) *\n\t\t\t\tsizeof(struct extent_node)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == DISCARD_CACHE) {\n\t\tmem_size = (atomic_read(&dcc->discard_cmd_cnt) *\n\t\t\t\tsizeof(struct discard_cmd)) >> PAGE_SHIFT;\n\t\tres = mem_size < (avail_ram * nm_i->ram_thresh / 100);\n\t} else if (type == COMPRESS_PAGE) {\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t\tunsigned long free_ram = val.freeram;\n\n\t\t \n\t\tres = (free_ram > avail_ram * sbi->compress_watermark / 100) &&\n\t\t\t(COMPRESS_MAPPING(sbi)->nrpages <\n\t\t\t free_ram * sbi->compress_percent / 100);\n#else\n\t\tres = false;\n#endif\n\t} else {\n\t\tif (!sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn true;\n\t}\n\treturn res;\n}\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tif (PageDirty(page)) {\n\t\tf2fs_clear_page_cache_dirty_tag(page);\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_P_SB(page), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\treturn f2fs_get_meta_page_retry(sbi, current_nat_addr(sbi, nid));\n}\n\nstatic struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tdst_off = next_nat_addr(sbi, current_nat_addr(sbi, nid));\n\n\t \n\tsrc_page = get_current_nat_page(sbi, nid);\n\tif (IS_ERR(src_page))\n\t\treturn src_page;\n\tdst_page = f2fs_grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}\n\nstatic struct nat_entry *__alloc_nat_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tnid_t nid, bool no_fail)\n{\n\tstruct nat_entry *new;\n\n\tnew = f2fs_kmem_cache_alloc(nat_entry_slab,\n\t\t\t\t\tGFP_F2FS_ZERO, no_fail, sbi);\n\tif (new) {\n\t\tnat_set_nid(new, nid);\n\t\tnat_reset_flag(new);\n\t}\n\treturn new;\n}\n\nstatic void __free_nat_entry(struct nat_entry *e)\n{\n\tkmem_cache_free(nat_entry_slab, e);\n}\n\n \nstatic struct nat_entry *__init_nat_entry(struct f2fs_nm_info *nm_i,\n\tstruct nat_entry *ne, struct f2fs_nat_entry *raw_ne, bool no_fail)\n{\n\tif (no_fail)\n\t\tf2fs_radix_tree_insert(&nm_i->nat_root, nat_get_nid(ne), ne);\n\telse if (radix_tree_insert(&nm_i->nat_root, nat_get_nid(ne), ne))\n\t\treturn NULL;\n\n\tif (raw_ne)\n\t\tnode_info_from_raw_nat(&ne->ni, raw_ne);\n\n\tspin_lock(&nm_i->nat_list_lock);\n\tlist_add_tail(&ne->list, &nm_i->nat_entries);\n\tspin_unlock(&nm_i->nat_list_lock);\n\n\tnm_i->nat_cnt[TOTAL_NAT]++;\n\tnm_i->nat_cnt[RECLAIMABLE_NAT]++;\n\treturn ne;\n}\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\tstruct nat_entry *ne;\n\n\tne = radix_tree_lookup(&nm_i->nat_root, n);\n\n\t \n\tif (ne && !get_nat_flag(ne, IS_DIRTY)) {\n\t\tspin_lock(&nm_i->nat_list_lock);\n\t\tif (!list_empty(&ne->list))\n\t\t\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\t\tspin_unlock(&nm_i->nat_list_lock);\n\t}\n\n\treturn ne;\n}\n\nstatic unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt[TOTAL_NAT]--;\n\tnm_i->nat_cnt[RECLAIMABLE_NAT]--;\n\t__free_nat_entry(e);\n}\n\nstatic struct nat_entry_set *__grab_nat_entry_set(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab,\n\t\t\t\t\t\tGFP_NOFS, true, NULL);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\treturn head;\n}\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tstruct nat_entry_set *head;\n\tbool new_ne = nat_get_blkaddr(ne) == NEW_ADDR;\n\n\tif (!new_ne)\n\t\thead = __grab_nat_entry_set(nm_i, ne);\n\n\t \n\tif (!new_ne && (get_nat_flag(ne, IS_PREALLOC) ||\n\t\t\t\t!get_nat_flag(ne, IS_DIRTY)))\n\t\thead->entry_cnt++;\n\n\tset_nat_flag(ne, IS_PREALLOC, new_ne);\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\tgoto refresh_list;\n\n\tnm_i->nat_cnt[DIRTY_NAT]++;\n\tnm_i->nat_cnt[RECLAIMABLE_NAT]--;\n\tset_nat_flag(ne, IS_DIRTY, true);\nrefresh_list:\n\tspin_lock(&nm_i->nat_list_lock);\n\tif (new_ne)\n\t\tlist_del_init(&ne->list);\n\telse\n\t\tlist_move_tail(&ne->list, &head->entry_list);\n\tspin_unlock(&nm_i->nat_list_lock);\n}\n\nstatic void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\tstruct nat_entry_set *set, struct nat_entry *ne)\n{\n\tspin_lock(&nm_i->nat_list_lock);\n\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\tspin_unlock(&nm_i->nat_list_lock);\n\n\tset_nat_flag(ne, IS_DIRTY, false);\n\tset->entry_cnt--;\n\tnm_i->nat_cnt[DIRTY_NAT]--;\n\tnm_i->nat_cnt[RECLAIMABLE_NAT]++;\n}\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}\n\nbool f2fs_in_warm_node_list(struct f2fs_sb_info *sbi, struct page *page)\n{\n\treturn NODE_MAPPING(sbi) == page->mapping &&\n\t\t\tIS_DNODE(page) && is_cold_node(page);\n}\n\nvoid f2fs_init_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tspin_lock_init(&sbi->fsync_node_lock);\n\tINIT_LIST_HEAD(&sbi->fsync_node_list);\n\tsbi->fsync_seg_id = 0;\n\tsbi->fsync_node_num = 0;\n}\n\nstatic unsigned int f2fs_add_fsync_node_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\tstruct fsync_node_entry *fn;\n\tunsigned long flags;\n\tunsigned int seq_id;\n\n\tfn = f2fs_kmem_cache_alloc(fsync_node_entry_slab,\n\t\t\t\t\tGFP_NOFS, true, NULL);\n\n\tget_page(page);\n\tfn->page = page;\n\tINIT_LIST_HEAD(&fn->list);\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tlist_add_tail(&fn->list, &sbi->fsync_node_list);\n\tfn->seq_id = sbi->fsync_seg_id++;\n\tseq_id = fn->seq_id;\n\tsbi->fsync_node_num++;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\n\treturn seq_id;\n}\n\nvoid f2fs_del_fsync_node_entry(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct fsync_node_entry *fn;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tlist_for_each_entry(fn, &sbi->fsync_node_list, list) {\n\t\tif (fn->page == page) {\n\t\t\tlist_del(&fn->list);\n\t\t\tsbi->fsync_node_num--;\n\t\t\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\t\t\tkmem_cache_free(fsync_node_entry_slab, fn);\n\t\t\tput_page(page);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\tf2fs_bug_on(sbi, 1);\n}\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}\n\nint f2fs_need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need = false;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tif (!get_nat_flag(e, IS_CHECKPOINTED) &&\n\t\t\t\t!get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\t\tneed = true;\n\t}\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\treturn need;\n}\n\nbool f2fs_is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}\n\nbool f2fs_need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}\n\n \nstatic void cache_nat_entry(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *new, *e;\n\n\t \n\tif (f2fs_rwsem_is_locked(&sbi->cp_global_sem))\n\t\treturn;\n\n\tnew = __alloc_nat_entry(sbi, nid, false);\n\tif (!new)\n\t\treturn;\n\n\tf2fs_down_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e)\n\t\te = __init_nat_entry(nm_i, new, ne, false);\n\telse\n\t\tf2fs_bug_on(sbi, nat_get_ino(e) != le32_to_cpu(ne->ino) ||\n\t\t\t\tnat_get_blkaddr(e) !=\n\t\t\t\t\tle32_to_cpu(ne->block_addr) ||\n\t\t\t\tnat_get_version(e) != ne->version);\n\tf2fs_up_write(&nm_i->nat_tree_lock);\n\tif (e != new)\n\t\t__free_nat_entry(new);\n}\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tstruct nat_entry *new = __alloc_nat_entry(sbi, ni->nid, true);\n\n\tf2fs_down_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = __init_nat_entry(nm_i, new, NULL, true);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t \n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\t \n\tif (e != new)\n\t\t__free_nat_entry(new);\n\n\t \n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, __is_valid_data_blkaddr(nat_get_blkaddr(e)) &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t \n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\n\t\tnat_set_version(e, inc_node_version(version));\n\t}\n\n\t \n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (!__is_valid_data_blkaddr(new_blkaddr))\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t \n\tif (ni->nid != ni->ino)\n\t\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tf2fs_up_write(&nm_i->nat_tree_lock);\n}\n\nint f2fs_try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (!f2fs_down_write_trylock(&nm_i->nat_tree_lock))\n\t\treturn 0;\n\n\tspin_lock(&nm_i->nat_list_lock);\n\twhile (nr_shrink) {\n\t\tstruct nat_entry *ne;\n\n\t\tif (list_empty(&nm_i->nat_entries))\n\t\t\tbreak;\n\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\tlist_del(&ne->list);\n\t\tspin_unlock(&nm_i->nat_list_lock);\n\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\n\t\tspin_lock(&nm_i->nat_list_lock);\n\t}\n\tspin_unlock(&nm_i->nat_list_lock);\n\n\tf2fs_up_write(&nm_i->nat_tree_lock);\n\treturn nr - nr_shrink;\n}\n\nint f2fs_get_node_info(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\tstruct node_info *ni, bool checkpoint_context)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tpgoff_t index;\n\tblock_t blkaddr;\n\tint i;\n\n\tni->nid = nid;\nretry:\n\t \n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tf2fs_up_read(&nm_i->nat_tree_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!f2fs_rwsem_is_locked(&sbi->cp_global_sem) || checkpoint_context) {\n\t\tdown_read(&curseg->journal_rwsem);\n\t} else if (f2fs_rwsem_is_contended(&nm_i->nat_tree_lock) ||\n\t\t\t\t!down_read_trylock(&curseg->journal_rwsem)) {\n\t\tf2fs_up_read(&nm_i->nat_tree_lock);\n\t\tgoto retry;\n\t}\n\n\ti = f2fs_lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0) {\n\t\tf2fs_up_read(&nm_i->nat_tree_lock);\n\t\tgoto cache;\n\t}\n\n\t \n\tindex = current_nat_addr(sbi, nid);\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\n\tpage = f2fs_get_meta_page(sbi, index);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\tblkaddr = le32_to_cpu(ne.block_addr);\n\tif (__is_valid_data_blkaddr(blkaddr) &&\n\t\t!f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC_ENHANCE))\n\t\treturn -EFAULT;\n\n\t \n\tcache_nat_entry(sbi, nid, &ne);\n\treturn 0;\n}\n\n \nstatic void f2fs_ra_node_pages(struct page *parent, int start, int n)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tint i, end;\n\tnid_t nid;\n\n\tblk_start_plug(&plug);\n\n\t \n\tend = start + n;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tf2fs_ra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n}\n\npgoff_t f2fs_get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)\n{\n\tconst long direct_index = ADDRS_PER_INODE(dn->inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK(dn->inode);\n\tconst long indirect_blks = ADDRS_PER_BLOCK(dn->inode) * NIDS_PER_BLOCK;\n\tunsigned int skipped_unit = ADDRS_PER_BLOCK(dn->inode);\n\tint cur_level = dn->cur_level;\n\tint max_level = dn->max_level;\n\tpgoff_t base = 0;\n\n\tif (!dn->max_level)\n\t\treturn pgofs + 1;\n\n\twhile (max_level-- > cur_level)\n\t\tskipped_unit *= NIDS_PER_BLOCK;\n\n\tswitch (dn->max_level) {\n\tcase 3:\n\t\tbase += 2 * indirect_blks;\n\t\tfallthrough;\n\tcase 2:\n\t\tbase += 2 * direct_blks;\n\t\tfallthrough;\n\tcase 1:\n\t\tbase += direct_index;\n\t\tbreak;\n\tdefault:\n\t\tf2fs_bug_on(F2FS_I_SB(dn->inode), 1);\n\t}\n\n\treturn ((pgofs - base) / skipped_unit + 1) * skipped_unit + base;\n}\n\n \nstatic int get_node_path(struct inode *inode, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK(inode);\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK(inode) * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\treturn -E2BIG;\n\t}\ngot:\n\treturn level;\n}\n\n \nint f2fs_get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i = 0;\n\tint err = 0;\n\n\tlevel = get_node_path(dn->inode, index, offset, noffset);\n\tif (level < 0)\n\t\treturn level;\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = f2fs_get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t \n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -ENOENT;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t \n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t \n\t\t\tif (!f2fs_alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = f2fs_new_node_page(dn, noffset[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\tf2fs_alloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\tf2fs_alloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = f2fs_get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = f2fs_get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = f2fs_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(dn->inode, FI_COMPRESSED_FILE) &&\n\t\t\t\t\tf2fs_sb_has_readonly(sbi)) {\n\t\tunsigned int c_len = f2fs_cluster_blocks_are_contiguous(dn);\n\t\tblock_t blkaddr;\n\n\t\tif (!c_len)\n\t\t\tgoto out;\n\n\t\tblkaddr = f2fs_data_blkaddr(dn);\n\t\tif (blkaddr == COMPRESS_ADDR)\n\t\t\tblkaddr = data_blkaddr(dn->inode, dn->node_page,\n\t\t\t\t\t\tdn->ofs_in_node + 1);\n\n\t\tf2fs_update_read_extent_tree_range_compressed(dn->inode,\n\t\t\t\t\tindex, blkaddr,\n\t\t\t\t\tF2FS_I(dn->inode)->i_cluster_size,\n\t\t\t\t\tc_len);\n\t}\nout:\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\tif (err == -ENOENT) {\n\t\tdn->cur_level = i;\n\t\tdn->max_level = level;\n\t\tdn->ofs_in_node = offset[level];\n\t}\n\treturn err;\n}\n\nstatic int truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\tint err;\n\tpgoff_t index;\n\n\terr = f2fs_get_node_info(sbi, dn->nid, &ni, false);\n\tif (err)\n\t\treturn err;\n\n\t \n\tf2fs_invalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode, dn->nid == dn->inode->i_ino);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tf2fs_remove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t\tf2fs_inode_synced(dn->inode);\n\t}\n\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tindex = dn->node_page->index;\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tindex, index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n\n\treturn 0;\n}\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *page;\n\tint err;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t \n\tpage = f2fs_get_node_page(sbi, dn->nid);\n\tif (PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tif (IS_INODE(page) || ino_of_node(page) != dn->inode->i_ino) {\n\t\tf2fs_err(sbi, \"incorrect node reference, ino: %lu, nid: %u, ino_of_node: %u\",\n\t\t\t\tdn->inode->i_ino, dn->nid, ino_of_node(page));\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_handle_error(sbi, ERROR_INVALID_NODE_REFERENCE);\n\t\tf2fs_put_page(page, 1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t \n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\tf2fs_truncate_data_blocks_range(dn, ADDRS_PER_BLOCK(dn->inode));\n\terr = truncate_node(dn);\n\tif (err) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn err;\n\t}\n\n\treturn 1;\n}\n\nstatic int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = f2fs_get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tf2fs_ra_node_pages(page, ofs, NIDS_PER_BLOCK);\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\tdn->node_changed = true;\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\t\tdn->node_changed = true;\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t \n\t\tdn->node_page = page;\n\t\tret = truncate_node(dn);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}\n\nstatic int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < idx + 1; i++) {\n\t\t \n\t\tpages[i] = f2fs_get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\tf2fs_ra_node_pages(pages[idx], offset[idx + 1], NIDS_PER_BLOCK);\n\n\t \n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tif (set_nid(pages[idx], i, 0, false))\n\t\t\tdn->node_changed = true;\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\terr = truncate_node(dn);\n\t\tif (err)\n\t\t\tgoto fail;\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}\n\n \nint f2fs_truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(inode, from, offset, noffset);\n\tif (level < 0) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, level);\n\t\treturn level;\n\t}\n\n\tpage = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tBUG_ON(page->mapping != NODE_MAPPING(sbi));\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true, true);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}\n\n \nint f2fs_truncate_xattr_node(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\tint err;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = f2fs_get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tset_new_dnode(&dn, inode, NULL, npage, nid);\n\terr = truncate_node(&dn);\n\tif (err) {\n\t\tf2fs_put_page(npage, 1);\n\t\treturn err;\n\t}\n\n\tf2fs_i_xnid_write(inode, 0);\n\n\treturn 0;\n}\n\n \nint f2fs_remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\terr = f2fs_get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_truncate_xattr_node(inode);\n\tif (err) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn err;\n\t}\n\n\t \n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\tf2fs_truncate_data_blocks_range(&dn, 1);\n\n\t \n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode)))) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EIO;\n\t}\n\n\tif (unlikely(inode->i_blocks != 0 && inode->i_blocks != 8)) {\n\t\tf2fs_warn(F2FS_I_SB(inode),\n\t\t\t\"f2fs_remove_inode_page: inconsistent i_blocks, ino:%lu, iblocks:%llu\",\n\t\t\tinode->i_ino, (unsigned long long)inode->i_blocks);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t}\n\n\t \n\terr = truncate_node(&dn);\n\tif (err) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstruct page *f2fs_new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t \n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t \n\treturn f2fs_new_node_page(&dn, 0);\n}\n\nstruct page *f2fs_new_node_page(struct dnode_of_data *dn, unsigned int ofs)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), dn->nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely((err = inc_valid_node_count(sbi, dn->inode, !ofs))))\n\t\tgoto fail;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\terr = f2fs_get_node_info(sbi, dn->nid, &new_ni, false);\n\tif (err) {\n\t\tdec_valid_node_count(sbi, dn->inode, !ofs);\n\t\tgoto fail;\n\t}\n\tif (unlikely(new_ni.blk_addr != NULL_ADDR)) {\n\t\terr = -EFSCORRUPTED;\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\tgoto fail;\n\t}\n#endif\n\tnew_ni.nid = dn->nid;\n\tnew_ni.ino = dn->inode->i_ino;\n\tnew_ni.blk_addr = NULL_ADDR;\n\tnew_ni.flag = 0;\n\tnew_ni.version = 0;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE, true, true);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(page, S_ISDIR(dn->inode->i_mode));\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (set_page_dirty(page))\n\t\tdn->node_changed = true;\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tf2fs_i_xnid_write(dn->inode, dn->nid);\n\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int read_node_page(struct page *page, blk_opf_t op_flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = op_flags,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t};\n\tint err;\n\n\tif (PageUptodate(page)) {\n\t\tif (!f2fs_inode_chksum_verify(sbi, page)) {\n\t\t\tClearPageUptodate(page);\n\t\t\treturn -EFSBADCRC;\n\t\t}\n\t\treturn LOCKED_PAGE;\n\t}\n\n\terr = f2fs_get_node_info(sbi, page->index, &ni, false);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (unlikely(ni.blk_addr == NULL_ADDR || ni.blk_addr == NEW_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\treturn -ENOENT;\n\t}\n\n\tfio.new_blkaddr = fio.old_blkaddr = ni.blk_addr;\n\n\terr = f2fs_submit_page_bio(&fio);\n\n\tif (!err)\n\t\tf2fs_update_iostat(sbi, NULL, FS_NODE_READ_IO, F2FS_BLKSIZE);\n\n\treturn err;\n}\n\n \nvoid f2fs_ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tif (!nid)\n\t\treturn;\n\tif (f2fs_check_nid_range(sbi, nid))\n\t\treturn;\n\n\tapage = xa_load(&NODE_MAPPING(sbi)->i_pages, nid);\n\tif (apage)\n\t\treturn;\n\n\tapage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, REQ_RAHEAD);\n\tf2fs_put_page(apage, err ? 1 : 0);\n}\n\nstatic struct page *__get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid,\n\t\t\t\t\tstruct page *parent, int start)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (f2fs_check_nid_range(sbi, nid))\n\t\treturn ERR_PTR(-EINVAL);\nrepeat:\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, 0);\n\tif (err < 0) {\n\t\tgoto out_put_err;\n\t} else if (err == LOCKED_PAGE) {\n\t\terr = 0;\n\t\tgoto page_hit;\n\t}\n\n\tif (parent)\n\t\tf2fs_ra_node_pages(parent, start + 1, MAX_RA_NODE);\n\n\tlock_page(page);\n\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\terr = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tif (!f2fs_inode_chksum_verify(sbi, page)) {\n\t\terr = -EFSBADCRC;\n\t\tgoto out_err;\n\t}\npage_hit:\n\tif (likely(nid == nid_of_node(page)))\n\t\treturn page;\n\n\tf2fs_warn(sbi, \"inconsistent node block, nid:%lu, node_footer[nid:%u,ino:%u,ofs:%u,cpver:%llu,blkaddr:%u]\",\n\t\t\t  nid, nid_of_node(page), ino_of_node(page),\n\t\t\t  ofs_of_node(page), cpver_of_node(page),\n\t\t\t  next_blkaddr_of_node(page));\n\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_FOOTER);\n\terr = -EFSCORRUPTED;\nout_err:\n\tClearPageUptodate(page);\nout_put_err:\n\t \n\tif (err != -ENOENT)\n\t\tf2fs_handle_page_eio(sbi, page->index, NODE);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}\n\nstruct page *f2fs_get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)\n{\n\treturn __get_node_page(sbi, nid, NULL, 0);\n}\n\nstruct page *f2fs_get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tnid_t nid = get_nid(parent, start, false);\n\n\treturn __get_node_page(sbi, nid, parent, start);\n}\n\nstatic void flush_inline_data(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tint ret;\n\n\t \n\tinode = ilookup(sbi->sb, ino);\n\tif (!inode)\n\t\treturn;\n\n\tpage = f2fs_pagecache_get_page(inode->i_mapping, 0,\n\t\t\t\t\tFGP_LOCK|FGP_NOWAIT, 0);\n\tif (!page)\n\t\tgoto iput_out;\n\n\tif (!PageUptodate(page))\n\t\tgoto page_out;\n\n\tif (!PageDirty(page))\n\t\tgoto page_out;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\tgoto page_out;\n\n\tret = f2fs_write_inline_data(inode, page);\n\tinode_dec_dirty_pages(inode);\n\tf2fs_remove_dirty_inode(inode);\n\tif (ret)\n\t\tset_page_dirty(page);\npage_out:\n\tf2fs_put_page(page, 1);\niput_out:\n\tiput(inode);\n}\n\nstatic struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index;\n\tstruct folio_batch fbatch;\n\tstruct page *last_page = NULL;\n\tint nr_folios;\n\n\tfolio_batch_init(&fbatch);\n\tindex = 0;\n\n\twhile ((nr_folios = filemap_get_folios_tag(NODE_MAPPING(sbi), &index,\n\t\t\t\t\t(pgoff_t)-1, PAGECACHE_TAG_DIRTY,\n\t\t\t\t\t&fbatch))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct page *page = &fbatch.folios[i]->page;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tfolio_batch_release(&fbatch);\n\t\t\t\treturn ERR_PTR(-EIO);\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (last_page)\n\t\t\t\tf2fs_put_page(last_page, 0);\n\n\t\t\tget_page(page);\n\t\t\tlast_page = page;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\t}\n\treturn last_page;\n}\n\nstatic int __write_node_page(struct page *page, bool atomic, bool *submitted,\n\t\t\t\tstruct writeback_control *wbc, bool do_balance,\n\t\t\t\tenum iostat_type io_type, unsigned int *seq_id)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tnid_t nid;\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.ino = ino_of_node(page),\n\t\t.type = NODE,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = wbc_to_write_flags(wbc),\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t\t.submitted = 0,\n\t\t.io_type = io_type,\n\t\t.io_wbc = wbc,\n\t};\n\tunsigned int seq;\n\n\ttrace_f2fs_writepage(page, NODE);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t \n\t\tif (F2FS_OPTION(sbi).errors == MOUNT_ERRORS_READONLY)\n\t\t\tgoto redirty_out;\n\t\tClearPageUptodate(page);\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\n\tif (!is_sbi_flag_set(sbi, SBI_CP_DISABLED) &&\n\t\t\twbc->sync_mode == WB_SYNC_NONE &&\n\t\t\tIS_DNODE(page) && is_cold_node(page))\n\t\tgoto redirty_out;\n\n\t \n\tnid = nid_of_node(page);\n\tf2fs_bug_on(sbi, page->index != nid);\n\n\tif (f2fs_get_node_info(sbi, nid, &ni, !do_balance))\n\t\tgoto redirty_out;\n\n\tif (wbc->for_reclaim) {\n\t\tif (!f2fs_down_read_trylock(&sbi->node_write))\n\t\t\tgoto redirty_out;\n\t} else {\n\t\tf2fs_down_read(&sbi->node_write);\n\t}\n\n\t \n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tf2fs_up_read(&sbi->node_write);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (__is_valid_data_blkaddr(ni.blk_addr) &&\n\t\t!f2fs_is_valid_blkaddr(sbi, ni.blk_addr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\tf2fs_up_read(&sbi->node_write);\n\t\tgoto redirty_out;\n\t}\n\n\tif (atomic && !test_opt(sbi, NOBARRIER) && !f2fs_sb_has_blkzoned(sbi))\n\t\tfio.op_flags |= REQ_PREFLUSH | REQ_FUA;\n\n\t \n\tif (f2fs_in_warm_node_list(sbi, page)) {\n\t\tseq = f2fs_add_fsync_node_entry(sbi, page);\n\t\tif (seq_id)\n\t\t\t*seq_id = seq;\n\t}\n\n\tset_page_writeback(page);\n\n\tfio.old_blkaddr = ni.blk_addr;\n\tf2fs_do_write_node_page(nid, &fio);\n\tset_node_addr(sbi, &ni, fio.new_blkaddr, is_fsync_dnode(page));\n\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\tf2fs_up_read(&sbi->node_write);\n\n\tif (wbc->for_reclaim) {\n\t\tf2fs_submit_merged_write_cond(sbi, NULL, page, 0, NODE);\n\t\tsubmitted = NULL;\n\t}\n\n\tunlock_page(page);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_submit_merged_write(sbi, NODE);\n\t\tsubmitted = NULL;\n\t}\n\tif (submitted)\n\t\t*submitted = fio.submitted;\n\n\tif (do_balance)\n\t\tf2fs_balance_fs(sbi, false);\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}\n\nint f2fs_move_node_page(struct page *node_page, int gc_type)\n{\n\tint err = 0;\n\n\tif (gc_type == FG_GC) {\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = 1,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\n\t\tf2fs_wait_on_page_writeback(node_page, NODE, true, true);\n\n\t\tset_page_dirty(node_page);\n\n\t\tif (!clear_page_dirty_for_io(node_page)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_page;\n\t\t}\n\n\t\tif (__write_node_page(node_page, false, NULL,\n\t\t\t\t\t&wbc, false, FS_GC_NODE_IO, NULL)) {\n\t\t\terr = -EAGAIN;\n\t\t\tunlock_page(node_page);\n\t\t}\n\t\tgoto release_page;\n\t} else {\n\t\t \n\t\tif (!PageWriteback(node_page))\n\t\t\tset_page_dirty(node_page);\n\t}\nout_page:\n\tunlock_page(node_page);\nrelease_page:\n\tf2fs_put_page(node_page, 0);\n\treturn err;\n}\n\nstatic int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\treturn __write_node_page(page, false, NULL, wbc, false,\n\t\t\t\t\t\tFS_NODE_IO, NULL);\n}\n\nint f2fs_fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\tstruct writeback_control *wbc, bool atomic,\n\t\t\tunsigned int *seq_id)\n{\n\tpgoff_t index;\n\tstruct folio_batch fbatch;\n\tint ret = 0;\n\tstruct page *last_page = NULL;\n\tbool marked = false;\n\tnid_t ino = inode->i_ino;\n\tint nr_folios;\n\tint nwritten = 0;\n\n\tif (atomic) {\n\t\tlast_page = last_fsync_dnode(sbi, ino);\n\t\tif (IS_ERR_OR_NULL(last_page))\n\t\t\treturn PTR_ERR_OR_ZERO(last_page);\n\t}\nretry:\n\tfolio_batch_init(&fbatch);\n\tindex = 0;\n\n\twhile ((nr_folios = filemap_get_folios_tag(NODE_MAPPING(sbi), &index,\n\t\t\t\t\t(pgoff_t)-1, PAGECACHE_TAG_DIRTY,\n\t\t\t\t\t&fbatch))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct page *page = &fbatch.folios[i]->page;\n\t\t\tbool submitted = false;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tfolio_batch_release(&fbatch);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page) && page != last_page) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true, true);\n\n\t\t\tset_fsync_mark(page, 0);\n\t\t\tset_dentry_mark(page, 0);\n\n\t\t\tif (!atomic || page == last_page) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tpercpu_counter_inc(&sbi->rf_node_block_count);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (is_inode_flag_set(inode,\n\t\t\t\t\t\t\t\tFI_DIRTY_INODE))\n\t\t\t\t\t\tf2fs_update_inode(inode, page);\n\t\t\t\t\tset_dentry_mark(page,\n\t\t\t\t\t\tf2fs_need_dentry_mark(sbi, ino));\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (!PageDirty(page))\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tret = __write_node_page(page, atomic &&\n\t\t\t\t\t\tpage == last_page,\n\t\t\t\t\t\t&submitted, wbc, true,\n\t\t\t\t\t\tFS_NODE_IO, seq_id);\n\t\t\tif (ret) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tbreak;\n\t\t\t} else if (submitted) {\n\t\t\t\tnwritten++;\n\t\t\t}\n\n\t\t\tif (page == last_page) {\n\t\t\t\tf2fs_put_page(page, 0);\n\t\t\t\tmarked = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\n\t\tif (ret || marked)\n\t\t\tbreak;\n\t}\n\tif (!ret && atomic && !marked) {\n\t\tf2fs_debug(sbi, \"Retry to write fsync mark: ino=%u, idx=%lx\",\n\t\t\t   ino, last_page->index);\n\t\tlock_page(last_page);\n\t\tf2fs_wait_on_page_writeback(last_page, NODE, true, true);\n\t\tset_page_dirty(last_page);\n\t\tunlock_page(last_page);\n\t\tgoto retry;\n\t}\nout:\n\tif (nwritten)\n\t\tf2fs_submit_merged_write_cond(sbi, NULL, NULL, ino, NODE);\n\treturn ret ? -EIO : 0;\n}\n\nstatic int f2fs_match_ino(struct inode *inode, unsigned long ino, void *data)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tbool clean;\n\n\tif (inode->i_ino != ino)\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(inode, FI_DIRTY_INODE))\n\t\treturn 0;\n\n\tspin_lock(&sbi->inode_lock[DIRTY_META]);\n\tclean = list_empty(&F2FS_I(inode)->gdirty_list);\n\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n\n\tif (clean)\n\t\treturn 0;\n\n\tinode = igrab(inode);\n\tif (!inode)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic bool flush_dirty_inode(struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct inode *inode;\n\tnid_t ino = ino_of_node(page);\n\n\tinode = find_inode_nowait(sbi->sb, ino, f2fs_match_ino, NULL);\n\tif (!inode)\n\t\treturn false;\n\n\tf2fs_update_inode(inode, page);\n\tunlock_page(page);\n\n\tiput(inode);\n\treturn true;\n}\n\nvoid f2fs_flush_inline_data(struct f2fs_sb_info *sbi)\n{\n\tpgoff_t index = 0;\n\tstruct folio_batch fbatch;\n\tint nr_folios;\n\n\tfolio_batch_init(&fbatch);\n\n\twhile ((nr_folios = filemap_get_folios_tag(NODE_MAPPING(sbi), &index,\n\t\t\t\t\t(pgoff_t)-1, PAGECACHE_TAG_DIRTY,\n\t\t\t\t\t&fbatch))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct page *page = &fbatch.folios[i]->page;\n\n\t\t\tif (!IS_DNODE(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (page_private_inline(page)) {\n\t\t\t\tclear_page_private_inline(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tflush_inline_data(sbi, ino_of_node(page));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\t}\n}\n\nint f2fs_sync_node_pages(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\tbool do_balance, enum iostat_type io_type)\n{\n\tpgoff_t index;\n\tstruct folio_batch fbatch;\n\tint step = 0;\n\tint nwritten = 0;\n\tint ret = 0;\n\tint nr_folios, done = 0;\n\n\tfolio_batch_init(&fbatch);\n\nnext_step:\n\tindex = 0;\n\n\twhile (!done && (nr_folios = filemap_get_folios_tag(NODE_MAPPING(sbi),\n\t\t\t\t&index, (pgoff_t)-1, PAGECACHE_TAG_DIRTY,\n\t\t\t\t&fbatch))) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_folios; i++) {\n\t\t\tstruct page *page = &fbatch.folios[i]->page;\n\t\t\tbool submitted = false;\n\n\t\t\t \n\t\t\tif (atomic_read(&sbi->wb_sync_req[NODE]) &&\n\t\t\t\t\twbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\nlock_node:\n\t\t\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\t\t\tlock_page(page);\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t \n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!do_balance)\n\t\t\t\tgoto write_node;\n\n\t\t\t \n\t\t\tif (page_private_inline(page)) {\n\t\t\t\tclear_page_private_inline(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tflush_inline_data(sbi, ino_of_node(page));\n\t\t\t\tgoto lock_node;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (IS_INODE(page) && flush_dirty_inode(page))\n\t\t\t\tgoto lock_node;\nwrite_node:\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true, true);\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tset_fsync_mark(page, 0);\n\t\t\tset_dentry_mark(page, 0);\n\n\t\t\tret = __write_node_page(page, false, &submitted,\n\t\t\t\t\t\twbc, do_balance, io_type, NULL);\n\t\t\tif (ret)\n\t\t\t\tunlock_page(page);\n\t\t\telse if (submitted)\n\t\t\t\tnwritten++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tfolio_batch_release(&fbatch);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tif (!is_sbi_flag_set(sbi, SBI_CP_DISABLED) &&\n\t\t\t\twbc->sync_mode == WB_SYNC_NONE && step == 1)\n\t\t\tgoto out;\n\t\tstep++;\n\t\tgoto next_step;\n\t}\nout:\n\tif (nwritten)\n\t\tf2fs_submit_merged_write(sbi, NODE);\n\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn -EIO;\n\treturn ret;\n}\n\nint f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int seq_id)\n{\n\tstruct fsync_node_entry *fn;\n\tstruct page *page;\n\tstruct list_head *head = &sbi->fsync_node_list;\n\tunsigned long flags;\n\tunsigned int cur_seq_id = 0;\n\n\twhile (seq_id && cur_seq_id < seq_id) {\n\t\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tfn = list_first_entry(head, struct fsync_node_entry, list);\n\t\tif (fn->seq_id > seq_id) {\n\t\t\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tcur_seq_id = fn->seq_id;\n\t\tpage = fn->page;\n\t\tget_page(page);\n\t\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n\n\t\tf2fs_wait_on_page_writeback(page, NODE, true, false);\n\n\t\tput_page(page);\n\t}\n\n\treturn filemap_check_errors(NODE_MAPPING(sbi));\n}\n\nstatic int f2fs_write_node_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tstruct blk_plug plug;\n\tlong diff;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto skip_write;\n\n\t \n\tf2fs_balance_fs_bg(sbi, true);\n\n\t \n\tif (wbc->sync_mode != WB_SYNC_ALL &&\n\t\t\tget_pages(sbi, F2FS_DIRTY_NODES) <\n\t\t\t\t\tnr_pages_to_skip(sbi, NODE))\n\t\tgoto skip_write;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tatomic_inc(&sbi->wb_sync_req[NODE]);\n\telse if (atomic_read(&sbi->wb_sync_req[NODE])) {\n\t\t \n\t\tif (current->plug)\n\t\t\tblk_finish_plug(current->plug);\n\t\tgoto skip_write;\n\t}\n\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\n\tdiff = nr_pages_to_write(sbi, NODE, wbc);\n\tblk_start_plug(&plug);\n\tf2fs_sync_node_pages(sbi, wbc, true, FS_NODE_IO);\n\tblk_finish_plug(&plug);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tatomic_dec(&sbi->wb_sync_req[NODE]);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_NODES);\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\treturn 0;\n}\n\nstatic bool f2fs_dirty_node_folio(struct address_space *mapping,\n\t\tstruct folio *folio)\n{\n\ttrace_f2fs_set_page_dirty(&folio->page, NODE);\n\n\tif (!folio_test_uptodate(folio))\n\t\tfolio_mark_uptodate(folio);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tif (IS_INODE(&folio->page))\n\t\tf2fs_inode_chksum_set(F2FS_M_SB(mapping), &folio->page);\n#endif\n\tif (filemap_dirty_folio(mapping, folio)) {\n\t\tinc_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t\tset_page_private_reference(&folio->page);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nconst struct address_space_operations f2fs_node_aops = {\n\t.writepage\t= f2fs_write_node_page,\n\t.writepages\t= f2fs_write_node_pages,\n\t.dirty_folio\t= f2fs_dirty_node_folio,\n\t.invalidate_folio = f2fs_invalidate_folio,\n\t.release_folio\t= f2fs_release_folio,\n\t.migrate_folio\t= filemap_migrate_folio,\n};\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}\n\nstatic int __insert_free_nid(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct free_nid *i)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint err = radix_tree_insert(&nm_i->free_nid_root, i->nid, i);\n\n\tif (err)\n\t\treturn err;\n\n\tnm_i->nid_cnt[FREE_NID]++;\n\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\treturn 0;\n}\n\nstatic void __remove_free_nid(struct f2fs_sb_info *sbi,\n\t\t\tstruct free_nid *i, enum nid_state state)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tf2fs_bug_on(sbi, state != i->state);\n\tnm_i->nid_cnt[state]--;\n\tif (state == FREE_NID)\n\t\tlist_del(&i->list);\n\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}\n\nstatic void __move_free_nid(struct f2fs_sb_info *sbi, struct free_nid *i,\n\t\t\tenum nid_state org_state, enum nid_state dst_state)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tf2fs_bug_on(sbi, org_state != i->state);\n\ti->state = dst_state;\n\tnm_i->nid_cnt[org_state]--;\n\tnm_i->nid_cnt[dst_state]++;\n\n\tswitch (dst_state) {\n\tcase PREALLOC_NID:\n\t\tlist_del(&i->list);\n\t\tbreak;\n\tcase FREE_NID:\n\t\tlist_add_tail(&i->list, &nm_i->free_nid_list);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n}\n\nbool f2fs_nat_bitmap_enabled(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int i;\n\tbool ret = true;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\tif (!test_bit_le(i, nm_i->nat_block_bitmap)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\n\treturn ret;\n}\n\nstatic void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\t\tbool set, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);\n\tunsigned int nid_ofs = nid - START_NID(nid);\n\n\tif (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))\n\t\treturn;\n\n\tif (set) {\n\t\tif (test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))\n\t\t\treturn;\n\t\t__set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\t\tnm_i->free_nid_count[nat_ofs]++;\n\t} else {\n\t\tif (!test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))\n\t\t\treturn;\n\t\t__clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\t\tif (!build)\n\t\t\tnm_i->free_nid_count[nat_ofs]--;\n\t}\n}\n\n \nstatic bool add_free_nid(struct f2fs_sb_info *sbi,\n\t\t\t\tnid_t nid, bool build, bool update)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *e;\n\tstruct nat_entry *ne;\n\tint err = -EINVAL;\n\tbool ret = false;\n\n\t \n\tif (unlikely(nid == 0))\n\t\treturn false;\n\n\tif (unlikely(f2fs_check_nid_range(sbi, nid)))\n\t\treturn false;\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS, true, NULL);\n\ti->nid = nid;\n\ti->state = FREE_NID;\n\n\tradix_tree_preload(GFP_NOFS | __GFP_NOFAIL);\n\n\tspin_lock(&nm_i->nid_list_lock);\n\n\tif (build) {\n\t\t \n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tgoto err_out;\n\n\t\te = __lookup_free_nid_list(nm_i, nid);\n\t\tif (e) {\n\t\t\tif (e->state == FREE_NID)\n\t\t\t\tret = true;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tret = true;\n\terr = __insert_free_nid(sbi, i);\nerr_out:\n\tif (update) {\n\t\tupdate_free_nid_bitmap(sbi, nid, ret, build);\n\t\tif (!build)\n\t\t\tnm_i->available_nids++;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\n\tif (err)\n\t\tkmem_cache_free(free_nid_slab, i);\n\treturn ret;\n}\n\nstatic void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == FREE_NID) {\n\t\t__remove_free_nid(sbi, i, FREE_NID);\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nstatic int scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);\n\tint i;\n\n\t__set_bit_le(nat_ofs, nm_i->nat_block_bitmap);\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\n\t\tif (blk_addr == NEW_ADDR)\n\t\t\treturn -EFSCORRUPTED;\n\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tadd_free_nid(sbi, start_nid, true, true);\n\t\t} else {\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tupdate_free_nid_bitmap(sbi, start_nid, false, true);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void scan_curseg_cache(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\t\tnid_t nid;\n\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(journal, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true, false);\n\t\telse\n\t\t\tremove_free_nid(sbi, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n}\n\nstatic void scan_free_nid_bits(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int i, idx;\n\tnid_t nid;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\tif (!test_bit_le(i, nm_i->nat_block_bitmap))\n\t\t\tcontinue;\n\t\tif (!nm_i->free_nid_count[i])\n\t\t\tcontinue;\n\t\tfor (idx = 0; idx < NAT_ENTRY_PER_BLOCK; idx++) {\n\t\t\tidx = find_next_bit_le(nm_i->free_nid_bitmap[i],\n\t\t\t\t\t\tNAT_ENTRY_PER_BLOCK, idx);\n\t\t\tif (idx >= NAT_ENTRY_PER_BLOCK)\n\t\t\t\tbreak;\n\n\t\t\tnid = i * NAT_ENTRY_PER_BLOCK + idx;\n\t\t\tadd_free_nid(sbi, nid, true, false);\n\n\t\t\tif (nm_i->nid_cnt[FREE_NID] >= MAX_FREE_NIDS)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tscan_curseg_cache(sbi);\n\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n}\n\nstatic int __f2fs_build_free_nids(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tbool sync, bool mount)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint i = 0, ret;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\tif (unlikely(nid >= nm_i->max_nid))\n\t\tnid = 0;\n\n\tif (unlikely(nid % NAT_ENTRY_PER_BLOCK))\n\t\tnid = NAT_BLOCK_OFFSET(nid) * NAT_ENTRY_PER_BLOCK;\n\n\t \n\tif (nm_i->nid_cnt[FREE_NID] >= NAT_ENTRY_PER_BLOCK)\n\t\treturn 0;\n\n\tif (!sync && !f2fs_available_free_memory(sbi, FREE_NIDS))\n\t\treturn 0;\n\n\tif (!mount) {\n\t\t \n\t\tscan_free_nid_bits(sbi);\n\n\t\tif (nm_i->nid_cnt[FREE_NID] >= NAT_ENTRY_PER_BLOCK)\n\t\t\treturn 0;\n\t}\n\n\t \n\tf2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\n\twhile (1) {\n\t\tif (!test_bit_le(NAT_BLOCK_OFFSET(nid),\n\t\t\t\t\t\tnm_i->nat_block_bitmap)) {\n\t\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tret = PTR_ERR(page);\n\t\t\t} else {\n\t\t\t\tret = scan_nat_page(sbi, page, nid);\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t}\n\n\t\t\tif (ret) {\n\t\t\t\tf2fs_up_read(&nm_i->nat_tree_lock);\n\n\t\t\t\tif (ret == -EFSCORRUPTED) {\n\t\t\t\t\tf2fs_err(sbi, \"NAT is corrupt, run fsck to fix it\");\n\t\t\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\t\t\tf2fs_handle_error(sbi,\n\t\t\t\t\t\tERROR_INCONSISTENT_NAT);\n\t\t\t\t}\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (++i >= FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t \n\tnm_i->next_scan_nid = nid;\n\n\t \n\tscan_curseg_cache(sbi);\n\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n\n\tf2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i->next_scan_nid),\n\t\t\t\t\tnm_i->ra_nid_pages, META_NAT, false);\n\n\treturn 0;\n}\n\nint f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)\n{\n\tint ret;\n\n\tmutex_lock(&NM_I(sbi)->build_lock);\n\tret = __f2fs_build_free_nids(sbi, sync, mount);\n\tmutex_unlock(&NM_I(sbi)->build_lock);\n\n\treturn ret;\n}\n\n \nbool f2fs_alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i = NULL;\nretry:\n\tif (time_to_inject(sbi, FAULT_ALLOC_NID))\n\t\treturn false;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\n\tif (unlikely(nm_i->available_nids == 0)) {\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn false;\n\t}\n\n\t \n\tif (nm_i->nid_cnt[FREE_NID] && !on_f2fs_build_free_nids(nm_i)) {\n\t\tf2fs_bug_on(sbi, list_empty(&nm_i->free_nid_list));\n\t\ti = list_first_entry(&nm_i->free_nid_list,\n\t\t\t\t\tstruct free_nid, list);\n\t\t*nid = i->nid;\n\n\t\t__move_free_nid(sbi, i, FREE_NID, PREALLOC_NID);\n\t\tnm_i->available_nids--;\n\n\t\tupdate_free_nid_bitmap(sbi, *nid, false, false);\n\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t \n\tif (!f2fs_build_free_nids(sbi, true, false))\n\t\tgoto retry;\n\treturn false;\n}\n\n \nvoid f2fs_alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\t__remove_free_nid(sbi, i, PREALLOC_NID);\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}\n\n \nvoid f2fs_alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\n\tif (!f2fs_available_free_memory(sbi, FREE_NIDS)) {\n\t\t__remove_free_nid(sbi, i, PREALLOC_NID);\n\t\tneed_free = true;\n\t} else {\n\t\t__move_free_nid(sbi, i, PREALLOC_NID, FREE_NID);\n\t}\n\n\tnm_i->available_nids++;\n\n\tupdate_free_nid_bitmap(sbi, nid, true, false);\n\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nint f2fs_try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (nm_i->nid_cnt[FREE_NID] <= MAX_FREE_NIDS)\n\t\treturn 0;\n\n\tif (!mutex_trylock(&nm_i->build_lock))\n\t\treturn 0;\n\n\twhile (nr_shrink && nm_i->nid_cnt[FREE_NID] > MAX_FREE_NIDS) {\n\t\tstruct free_nid *i, *next;\n\t\tunsigned int batch = SHRINK_NID_BATCH_SIZE;\n\n\t\tspin_lock(&nm_i->nid_list_lock);\n\t\tlist_for_each_entry_safe(i, next, &nm_i->free_nid_list, list) {\n\t\t\tif (!nr_shrink || !batch ||\n\t\t\t\tnm_i->nid_cnt[FREE_NID] <= MAX_FREE_NIDS)\n\t\t\t\tbreak;\n\t\t\t__remove_free_nid(sbi, i, FREE_NID);\n\t\t\tkmem_cache_free(free_nid_slab, i);\n\t\t\tnr_shrink--;\n\t\t\tbatch--;\n\t\t}\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t}\n\n\tmutex_unlock(&nm_i->build_lock);\n\n\treturn nr - nr_shrink;\n}\n\nint f2fs_recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = f2fs_get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tri = F2FS_INODE(page);\n\tif (ri->i_inline & F2FS_INLINE_XATTR) {\n\t\tif (!f2fs_has_inline_xattr(inode)) {\n\t\t\tset_inode_flag(inode, FI_INLINE_XATTR);\n\t\t\tstat_inc_inline_xattr(inode);\n\t\t}\n\t} else {\n\t\tif (f2fs_has_inline_xattr(inode)) {\n\t\t\tstat_dec_inline_xattr(inode);\n\t\t\tclear_inode_flag(inode, FI_INLINE_XATTR);\n\t\t}\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(inode, ipage);\n\tsrc_addr = inline_xattr_addr(inode, page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tf2fs_update_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}\n\nint f2fs_recover_xattr_data(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid;\n\tstruct dnode_of_data dn;\n\tstruct node_info ni;\n\tstruct page *xpage;\n\tint err;\n\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t \n\terr = f2fs_get_node_info(sbi, prev_xnid, &ni, false);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_invalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode, false);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t \n\tif (!f2fs_alloc_nid(sbi, &new_xnid))\n\t\treturn -ENOSPC;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, new_xnid);\n\txpage = f2fs_new_node_page(&dn, XATTR_NODE_OFFSET);\n\tif (IS_ERR(xpage)) {\n\t\tf2fs_alloc_nid_failed(sbi, new_xnid);\n\t\treturn PTR_ERR(xpage);\n\t}\n\n\tf2fs_alloc_nid_done(sbi, new_xnid);\n\tf2fs_update_inode_page(inode);\n\n\t \n\tif (page) {\n\t\tmemcpy(F2FS_NODE(xpage), F2FS_NODE(page),\n\t\t\t\tVALID_XATTR_BLOCK_SIZE);\n\t\tset_page_dirty(xpage);\n\t}\n\tf2fs_put_page(xpage, 1);\n\n\treturn 0;\n}\n\nint f2fs_recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\tint err;\n\n\terr = f2fs_get_node_info(sbi, ino, &old_ni, false);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\nretry:\n\tipage = f2fs_grab_cache_page(NODE_MAPPING(sbi), ino, false);\n\tif (!ipage) {\n\t\tmemalloc_retry_wait(GFP_NOFS);\n\t\tgoto retry;\n\t}\n\n\t \n\tremove_free_nid(sbi, ino);\n\n\tif (!PageUptodate(ipage))\n\t\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\tset_cold_node(ipage, false);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, offsetof(struct f2fs_inode, i_ext));\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & (F2FS_INLINE_XATTR | F2FS_EXTRA_ATTR);\n\tif (dst->i_inline & F2FS_EXTRA_ATTR) {\n\t\tdst->i_extra_isize = src->i_extra_isize;\n\n\t\tif (f2fs_sb_has_flexible_inline_xattr(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(src, le16_to_cpu(src->i_extra_isize),\n\t\t\t\t\t\t\ti_inline_xattr_size))\n\t\t\tdst->i_inline_xattr_size = src->i_inline_xattr_size;\n\n\t\tif (f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(src, le16_to_cpu(src->i_extra_isize),\n\t\t\t\t\t\t\t\ti_projid))\n\t\t\tdst->i_projid = src->i_projid;\n\n\t\tif (f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(src, le16_to_cpu(src->i_extra_isize),\n\t\t\t\t\t\t\ti_crtime_nsec)) {\n\t\t\tdst->i_crtime = src->i_crtime;\n\t\t\tdst->i_crtime_nsec = src->i_crtime_nsec;\n\t\t}\n\t}\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(inc_valid_node_count(sbi, NULL, true)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}\n\nint f2fs_restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint i, idx, last_offset, nrpages;\n\n\t \n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = bio_max_segs(last_offset - i);\n\n\t\t \n\t\tf2fs_ra_meta_pages(sbi, addr, nrpages, META_POR, true);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = f2fs_get_tmp_page(sbi, idx);\n\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn PTR_ERR(page);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}\n\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\tif (f2fs_check_nid_range(sbi, nid))\n\t\t\tcontinue;\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(sbi, nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t \n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n\nstatic void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}\n\nstatic void __update_nat_bits(struct f2fs_nm_info *nm_i, unsigned int nat_ofs,\n\t\t\t\t\t\t\tunsigned int valid)\n{\n\tif (valid == 0) {\n\t\t__set_bit_le(nat_ofs, nm_i->empty_nat_bits);\n\t\t__clear_bit_le(nat_ofs, nm_i->full_nat_bits);\n\t\treturn;\n\t}\n\n\t__clear_bit_le(nat_ofs, nm_i->empty_nat_bits);\n\tif (valid == NAT_ENTRY_PER_BLOCK)\n\t\t__set_bit_le(nat_ofs, nm_i->full_nat_bits);\n\telse\n\t\t__clear_bit_le(nat_ofs, nm_i->full_nat_bits);\n}\n\nstatic void update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;\n\tstruct f2fs_nat_block *nat_blk = page_address(page);\n\tint valid = 0;\n\tint i = 0;\n\n\tif (!is_set_ckpt_flags(sbi, CP_NAT_BITS_FLAG))\n\t\treturn;\n\n\tif (nat_index == 0) {\n\t\tvalid = 1;\n\t\ti = 1;\n\t}\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++) {\n\t\tif (le32_to_cpu(nat_blk->entries[i].block_addr) != NULL_ADDR)\n\t\t\tvalid++;\n\t}\n\n\t__update_nat_bits(nm_i, nat_index, valid);\n}\n\nvoid f2fs_enable_nat_bits(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_ofs;\n\n\tf2fs_down_read(&nm_i->nat_tree_lock);\n\n\tfor (nat_ofs = 0; nat_ofs < nm_i->nat_blocks; nat_ofs++) {\n\t\tunsigned int valid = 0, nid_ofs = 0;\n\n\t\t \n\t\tif (unlikely(nat_ofs == 0)) {\n\t\t\tvalid = 1;\n\t\t\tnid_ofs = 1;\n\t\t}\n\n\t\tfor (; nid_ofs < NAT_ENTRY_PER_BLOCK; nid_ofs++) {\n\t\t\tif (!test_bit_le(nid_ofs,\n\t\t\t\t\tnm_i->free_nid_bitmap[nat_ofs]))\n\t\t\t\tvalid++;\n\t\t}\n\n\t\t__update_nat_bits(nm_i, nat_ofs, valid);\n\t}\n\n\tf2fs_up_read(&nm_i->nat_tree_lock);\n}\n\nstatic int __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\tstruct nat_entry_set *set, struct cp_control *cpc)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t \n\tif ((cpc->reason & CP_UMOUNT) ||\n\t\t!__has_cursum_space(journal, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tdown_write(&curseg->journal_rwsem);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t \n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tf2fs_bug_on(sbi, nat_get_blkaddr(ne) == NEW_ADDR);\n\n\t\tif (to_journal) {\n\t\t\toffset = f2fs_lookup_journal_in_cursum(journal,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(journal, offset);\n\t\t\tnid_in_journal(journal, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), set, ne);\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR) {\n\t\t\tadd_free_nid(sbi, nid, false, true);\n\t\t} else {\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tupdate_free_nid_bitmap(sbi, nid, false, false);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t}\n\t}\n\n\tif (to_journal) {\n\t\tup_write(&curseg->journal_rwsem);\n\t} else {\n\t\tupdate_nat_bits(sbi, start_nid, page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\t \n\tif (!set->entry_cnt) {\n\t\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\t\tkmem_cache_free(nat_entry_set_slab, set);\n\t}\n\treturn 0;\n}\n\n \nint f2fs_flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct nat_entry_set *setvec[NAT_VEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\tint err = 0;\n\n\t \n\tif (cpc->reason & CP_UMOUNT) {\n\t\tf2fs_down_write(&nm_i->nat_tree_lock);\n\t\tremove_nats_in_journal(sbi);\n\t\tf2fs_up_write(&nm_i->nat_tree_lock);\n\t}\n\n\tif (!nm_i->nat_cnt[DIRTY_NAT])\n\t\treturn 0;\n\n\tf2fs_down_write(&nm_i->nat_tree_lock);\n\n\t \n\tif (cpc->reason & CP_UMOUNT ||\n\t\t!__has_cursum_space(journal,\n\t\t\tnm_i->nat_cnt[DIRTY_NAT], NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, NAT_VEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\tMAX_NAT_JENTRIES(journal));\n\t}\n\n\t \n\tlist_for_each_entry_safe(set, tmp, &sets, set_list) {\n\t\terr = __flush_nat_entry_set(sbi, set, cpc);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tf2fs_up_write(&nm_i->nat_tree_lock);\n\t \n\n\treturn err;\n}\n\nstatic int __get_nat_bitmaps(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_bits_bytes = nm_i->nat_blocks / BITS_PER_BYTE;\n\tunsigned int i;\n\t__u64 cp_ver = cur_cp_version(ckpt);\n\tblock_t nat_bits_addr;\n\n\tnm_i->nat_bits_blocks = F2FS_BLK_ALIGN((nat_bits_bytes << 1) + 8);\n\tnm_i->nat_bits = f2fs_kvzalloc(sbi,\n\t\t\tnm_i->nat_bits_blocks << F2FS_BLKSIZE_BITS, GFP_KERNEL);\n\tif (!nm_i->nat_bits)\n\t\treturn -ENOMEM;\n\n\tnm_i->full_nat_bits = nm_i->nat_bits + 8;\n\tnm_i->empty_nat_bits = nm_i->full_nat_bits + nat_bits_bytes;\n\n\tif (!is_set_ckpt_flags(sbi, CP_NAT_BITS_FLAG))\n\t\treturn 0;\n\n\tnat_bits_addr = __start_cp_addr(sbi) + sbi->blocks_per_seg -\n\t\t\t\t\t\tnm_i->nat_bits_blocks;\n\tfor (i = 0; i < nm_i->nat_bits_blocks; i++) {\n\t\tstruct page *page;\n\n\t\tpage = f2fs_get_meta_page(sbi, nat_bits_addr++);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tmemcpy(nm_i->nat_bits + (i << F2FS_BLKSIZE_BITS),\n\t\t\t\t\tpage_address(page), F2FS_BLKSIZE);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tcp_ver |= (cur_cp_crc(ckpt) << 32);\n\tif (cpu_to_le64(cp_ver) != *(__le64 *)nm_i->nat_bits) {\n\t\tclear_ckpt_flags(sbi, CP_NAT_BITS_FLAG);\n\t\tf2fs_notice(sbi, \"Disable nat_bits due to incorrect cp_ver (%llu, %llu)\",\n\t\t\tcp_ver, le64_to_cpu(*(__le64 *)nm_i->nat_bits));\n\t\treturn 0;\n\t}\n\n\tf2fs_notice(sbi, \"Found nat_bits in checkpoint\");\n\treturn 0;\n}\n\nstatic inline void load_free_nid_bitmap(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int i = 0;\n\tnid_t nid, last_nid;\n\n\tif (!is_set_ckpt_flags(sbi, CP_NAT_BITS_FLAG))\n\t\treturn;\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->empty_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\n\t\tnid = i * NAT_ENTRY_PER_BLOCK;\n\t\tlast_nid = nid + NAT_ENTRY_PER_BLOCK;\n\n\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\tfor (; nid < last_nid; nid++)\n\t\t\tupdate_free_nid_bitmap(sbi, nid, true, true);\n\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t}\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->full_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\t}\n}\n\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs;\n\tint err;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t \n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnm_i->nat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nm_i->nat_blocks;\n\n\t \n\tnm_i->available_nids = nm_i->max_nid - sbi->total_valid_node_count -\n\t\t\t\t\t\tF2FS_RESERVED_NODE_NUM;\n\tnm_i->nid_cnt[FREE_NID] = 0;\n\tnm_i->nid_cnt[PREALLOC_NID] = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\tnm_i->ra_nid_pages = DEF_RA_NID_PAGES;\n\tnm_i->dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;\n\tnm_i->max_rf_node_blocks = DEF_RF_NODE_BLOCKS;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\tspin_lock_init(&nm_i->nat_list_lock);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->nid_list_lock);\n\tinit_f2fs_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\n\terr = __get_nat_bitmaps(sbi);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tnm_i->nat_bitmap_mir = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap_mir)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n\nstatic int init_free_nid_cache(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint i;\n\n\tnm_i->free_nid_bitmap =\n\t\tf2fs_kvzalloc(sbi, array_size(sizeof(unsigned char *),\n\t\t\t\t\t      nm_i->nat_blocks),\n\t\t\t      GFP_KERNEL);\n\tif (!nm_i->free_nid_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\tnm_i->free_nid_bitmap[i] = f2fs_kvzalloc(sbi,\n\t\t\tf2fs_bitmap_size(NAT_ENTRY_PER_BLOCK), GFP_KERNEL);\n\t\tif (!nm_i->free_nid_bitmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnm_i->nat_block_bitmap = f2fs_kvzalloc(sbi, nm_i->nat_blocks / 8,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_block_bitmap)\n\t\treturn -ENOMEM;\n\n\tnm_i->free_nid_count =\n\t\tf2fs_kvzalloc(sbi, array_size(sizeof(unsigned short),\n\t\t\t\t\t      nm_i->nat_blocks),\n\t\t\t      GFP_KERNEL);\n\tif (!nm_i->free_nid_count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint f2fs_build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_nm_info),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = init_free_nid_cache(sbi);\n\tif (err)\n\t\treturn err;\n\n\t \n\tload_free_nid_bitmap(sbi);\n\n\treturn f2fs_build_free_nids(sbi, true, true);\n}\n\nvoid f2fs_destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tvoid *vec[NAT_VEC_SIZE];\n\tstruct nat_entry **natvec = (struct nat_entry **)vec;\n\tstruct nat_entry_set **setvec = (struct nat_entry_set **)vec;\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t \n\tspin_lock(&nm_i->nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {\n\t\t__remove_free_nid(sbi, i, FREE_NID);\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[FREE_NID]);\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[PREALLOC_NID]);\n\tf2fs_bug_on(sbi, !list_empty(&nm_i->free_nid_list));\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t \n\tf2fs_down_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NAT_VEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\tspin_lock(&nm_i->nat_list_lock);\n\t\t\tlist_del(&natvec[idx]->list);\n\t\t\tspin_unlock(&nm_i->nat_list_lock);\n\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t\t}\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt[TOTAL_NAT]);\n\n\t \n\tnid = 0;\n\tmemset(vec, 0, sizeof(void *) * NAT_VEC_SIZE);\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, NAT_VEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t \n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tf2fs_up_write(&nm_i->nat_tree_lock);\n\n\tkvfree(nm_i->nat_block_bitmap);\n\tif (nm_i->free_nid_bitmap) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nm_i->nat_blocks; i++)\n\t\t\tkvfree(nm_i->free_nid_bitmap[i]);\n\t\tkvfree(nm_i->free_nid_bitmap);\n\t}\n\tkvfree(nm_i->free_nid_count);\n\n\tkvfree(nm_i->nat_bitmap);\n\tkvfree(nm_i->nat_bits);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tkvfree(nm_i->nat_bitmap_mir);\n#endif\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}\n\nint __init f2fs_create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"f2fs_nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"f2fs_free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"f2fs_nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\n\tfsync_node_entry_slab = f2fs_kmem_cache_create(\"f2fs_fsync_node_entry\",\n\t\t\tsizeof(struct fsync_node_entry));\n\tif (!fsync_node_entry_slab)\n\t\tgoto destroy_nat_entry_set;\n\treturn 0;\n\ndestroy_nat_entry_set:\n\tkmem_cache_destroy(nat_entry_set_slab);\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}\n\nvoid f2fs_destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(fsync_node_entry_slab);\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}