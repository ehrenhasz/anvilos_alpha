{
  "module_name": "file.c",
  "hash_id": "61829f44378cedfdbf4f10f7ab775783335046e9613d0dc11f1b66a334d1e462",
  "original_prompt": "Ingested from linux-6.6.14/fs/f2fs/file.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/stat.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/falloc.h>\n#include <linux/types.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/pagevec.h>\n#include <linux/uio.h>\n#include <linux/uuid.h>\n#include <linux/file.h>\n#include <linux/nls.h>\n#include <linux/sched/signal.h>\n#include <linux/fileattr.h>\n#include <linux/fadvise.h>\n#include <linux/iomap.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"gc.h\"\n#include \"iostat.h\"\n#include <trace/events/f2fs.h>\n#include <uapi/linux/f2fs.h>\n\nstatic vm_fault_t f2fs_filemap_fault(struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tvm_fault_t ret;\n\n\tret = filemap_fault(vmf);\n\tif (ret & VM_FAULT_LOCKED)\n\t\tf2fs_update_iostat(F2FS_I_SB(inode), inode,\n\t\t\t\t\tAPP_MAPPED_READ_IO, F2FS_BLKSIZE);\n\n\ttrace_f2fs_filemap_fault(inode, vmf->pgoff, (unsigned long)ret);\n\n\treturn ret;\n}\n\nstatic vm_fault_t f2fs_vm_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tbool need_alloc = true;\n\tint err = 0;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\terr = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (!f2fs_is_checkpoint_ready(sbi)) {\n\t\terr = -ENOSPC;\n\t\tgoto err;\n\t}\n\n\terr = f2fs_convert_inline_inode(inode);\n\tif (err)\n\t\tgoto err;\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (f2fs_compressed_file(inode)) {\n\t\tint ret = f2fs_is_compressed_cluster(inode, page->index);\n\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto err;\n\t\t} else if (ret) {\n\t\t\tneed_alloc = false;\n\t\t}\n\t}\n#endif\n\t \n\tif (need_alloc)\n\t\tf2fs_balance_fs(sbi, true);\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tf2fs_bug_on(sbi, f2fs_has_inline_data(inode));\n\n\tfile_update_time(vmf->vma->vm_file);\n\tfilemap_invalidate_lock_shared(inode->i_mapping);\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t\tpage_offset(page) > i_size_read(inode) ||\n\t\t\t!PageUptodate(page))) {\n\t\tunlock_page(page);\n\t\terr = -EFAULT;\n\t\tgoto out_sem;\n\t}\n\n\tif (need_alloc) {\n\t\t \n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = f2fs_get_block_locked(&dn, page->index);\n\t}\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tif (!need_alloc) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = f2fs_get_dnode_of_data(&dn, page->index, LOOKUP_NODE);\n\t\tf2fs_put_dnode(&dn);\n\t}\n#endif\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto out_sem;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, false, true);\n\n\t \n\tf2fs_wait_on_block_writeback(inode, dn.data_blkaddr);\n\n\t \n\tif (PageMappedToDisk(page))\n\t\tgoto out_sem;\n\n\t \n\tif (((loff_t)(page->index + 1) << PAGE_SHIFT) >\n\t\t\t\t\t\ti_size_read(inode)) {\n\t\tloff_t offset;\n\n\t\toffset = i_size_read(inode) & ~PAGE_MASK;\n\t\tzero_user_segment(page, offset, PAGE_SIZE);\n\t}\n\tset_page_dirty(page);\n\n\tf2fs_update_iostat(sbi, inode, APP_MAPPED_IO, F2FS_BLKSIZE);\n\tf2fs_update_time(sbi, REQ_TIME);\n\n\ttrace_f2fs_vm_page_mkwrite(page, DATA);\nout_sem:\n\tfilemap_invalidate_unlock_shared(inode->i_mapping);\n\n\tsb_end_pagefault(inode->i_sb);\nerr:\n\treturn vmf_fs_error(err);\n}\n\nstatic const struct vm_operations_struct f2fs_file_vm_ops = {\n\t.fault\t\t= f2fs_filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= f2fs_vm_page_mkwrite,\n};\n\nstatic int get_parent_ino(struct inode *inode, nid_t *pino)\n{\n\tstruct dentry *dentry;\n\n\t \n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\treturn 0;\n\n\t*pino = parent_ino(dentry);\n\tdput(dentry);\n\treturn 1;\n}\n\nstatic inline enum cp_reason_type need_do_checkpoint(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tenum cp_reason_type cp_reason = CP_NO_NEEDED;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\tcp_reason = CP_NON_REGULAR;\n\telse if (f2fs_compressed_file(inode))\n\t\tcp_reason = CP_COMPRESSED;\n\telse if (inode->i_nlink != 1)\n\t\tcp_reason = CP_HARDLINK;\n\telse if (is_sbi_flag_set(sbi, SBI_NEED_CP))\n\t\tcp_reason = CP_SB_NEED_CP;\n\telse if (file_wrong_pino(inode))\n\t\tcp_reason = CP_WRONG_PINO;\n\telse if (!f2fs_space_for_roll_forward(sbi))\n\t\tcp_reason = CP_NO_SPC_ROLL;\n\telse if (!f2fs_is_checkpointed_node(sbi, F2FS_I(inode)->i_pino))\n\t\tcp_reason = CP_NODE_NEED_CP;\n\telse if (test_opt(sbi, FASTBOOT))\n\t\tcp_reason = CP_FASTBOOT_MODE;\n\telse if (F2FS_OPTION(sbi).active_logs == 2)\n\t\tcp_reason = CP_SPEC_LOG_NUM;\n\telse if (F2FS_OPTION(sbi).fsync_mode == FSYNC_MODE_STRICT &&\n\t\tf2fs_need_dentry_mark(sbi, inode->i_ino) &&\n\t\tf2fs_exist_written_data(sbi, F2FS_I(inode)->i_pino,\n\t\t\t\t\t\t\tTRANS_DIR_INO))\n\t\tcp_reason = CP_RECOVER_DIR;\n\n\treturn cp_reason;\n}\n\nstatic bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct page *i = find_get_page(NODE_MAPPING(sbi), ino);\n\tbool ret = false;\n\t \n\tif ((i && PageDirty(i)) || f2fs_need_inode_block_update(sbi, ino))\n\t\tret = true;\n\tf2fs_put_page(i, 0);\n\treturn ret;\n}\n\nstatic void try_to_fix_pino(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tnid_t pino;\n\n\tf2fs_down_write(&fi->i_sem);\n\tif (file_wrong_pino(inode) && inode->i_nlink == 1 &&\n\t\t\tget_parent_ino(inode, &pino)) {\n\t\tf2fs_i_pino_write(inode, pino);\n\t\tfile_got_pino(inode);\n\t}\n\tf2fs_up_write(&fi->i_sem);\n}\n\nstatic int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,\n\t\t\t\t\t\tint datasync, bool atomic)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t ino = inode->i_ino;\n\tint ret = 0;\n\tenum cp_reason_type cp_reason = 0;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.for_reclaim = 0,\n\t};\n\tunsigned int seq_id = 0;\n\n\tif (unlikely(f2fs_readonly(inode->i_sb)))\n\t\treturn 0;\n\n\ttrace_f2fs_sync_file_enter(inode);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tgoto go_write;\n\n\t \n\tif (datasync || get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)\n\t\tset_inode_flag(inode, FI_NEED_IPU);\n\tret = file_write_and_wait_range(file, start, end);\n\tclear_inode_flag(inode, FI_NEED_IPU);\n\n\tif (ret || is_sbi_flag_set(sbi, SBI_CP_DISABLED)) {\n\t\ttrace_f2fs_sync_file_exit(inode, cp_reason, datasync, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!f2fs_skip_inode_update(inode, datasync)) {\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto go_write;\n\t}\n\n\t \n\tif (!is_inode_flag_set(inode, FI_APPEND_WRITE) &&\n\t\t\t!f2fs_exist_written_data(sbi, ino, APPEND_INO)) {\n\n\t\t \n\t\tif (need_inode_page_update(sbi, ino))\n\t\t\tgoto go_write;\n\n\t\tif (is_inode_flag_set(inode, FI_UPDATE_WRITE) ||\n\t\t\t\tf2fs_exist_written_data(sbi, ino, UPDATE_INO))\n\t\t\tgoto flush_out;\n\t\tgoto out;\n\t} else {\n\t\t \n\t\tif (F2FS_OPTION(sbi).fsync_mode ==\n\t\t\t\tFSYNC_MODE_STRICT && !atomic)\n\t\t\tatomic = true;\n\t}\ngo_write:\n\t \n\tf2fs_down_read(&F2FS_I(inode)->i_sem);\n\tcp_reason = need_do_checkpoint(inode);\n\tf2fs_up_read(&F2FS_I(inode)->i_sem);\n\n\tif (cp_reason) {\n\t\t \n\t\tret = f2fs_sync_fs(inode->i_sb, 1);\n\n\t\t \n\t\ttry_to_fix_pino(inode);\n\t\tclear_inode_flag(inode, FI_APPEND_WRITE);\n\t\tclear_inode_flag(inode, FI_UPDATE_WRITE);\n\t\tgoto out;\n\t}\nsync_nodes:\n\tatomic_inc(&sbi->wb_sync_req[NODE]);\n\tret = f2fs_fsync_node_pages(sbi, inode, &wbc, atomic, &seq_id);\n\tatomic_dec(&sbi->wb_sync_req[NODE]);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_need_inode_block_update(sbi, ino)) {\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t\tf2fs_write_inode(inode, NULL);\n\t\tgoto sync_nodes;\n\t}\n\n\t \n\tif (!atomic) {\n\t\tret = f2fs_wait_on_node_pages_writeback(sbi, seq_id);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tf2fs_remove_ino_entry(sbi, ino, APPEND_INO);\n\tclear_inode_flag(inode, FI_APPEND_WRITE);\nflush_out:\n\tif ((!atomic && F2FS_OPTION(sbi).fsync_mode != FSYNC_MODE_NOBARRIER) ||\n\t    (atomic && !test_opt(sbi, NOBARRIER) && f2fs_sb_has_blkzoned(sbi)))\n\t\tret = f2fs_issue_flush(sbi, inode->i_ino);\n\tif (!ret) {\n\t\tf2fs_remove_ino_entry(sbi, ino, UPDATE_INO);\n\t\tclear_inode_flag(inode, FI_UPDATE_WRITE);\n\t\tf2fs_remove_ino_entry(sbi, ino, FLUSH_INO);\n\t}\n\tf2fs_update_time(sbi, REQ_TIME);\nout:\n\ttrace_f2fs_sync_file_exit(inode, cp_reason, datasync, ret);\n\treturn ret;\n}\n\nint f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(file_inode(file)))))\n\t\treturn -EIO;\n\treturn f2fs_do_sync_file(file, start, end, datasync, false);\n}\n\nstatic bool __found_offset(struct address_space *mapping, block_t blkaddr,\n\t\t\t\tpgoff_t index, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_DATA:\n\t\tif (__is_valid_data_blkaddr(blkaddr))\n\t\t\treturn true;\n\t\tif (blkaddr == NEW_ADDR &&\n\t\t    xa_get_mark(&mapping->i_pages, index, PAGECACHE_TAG_DIRTY))\n\t\t\treturn true;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\tstruct dnode_of_data dn;\n\tpgoff_t pgofs, end_offset;\n\tloff_t data_ofs = offset;\n\tloff_t isize;\n\tint err = 0;\n\n\tinode_lock(inode);\n\n\tisize = i_size_read(inode);\n\tif (offset >= isize)\n\t\tgoto fail;\n\n\t \n\tif (f2fs_has_inline_data(inode)) {\n\t\tif (whence == SEEK_HOLE) {\n\t\t\tdata_ofs = isize;\n\t\t\tgoto found;\n\t\t} else if (whence == SEEK_DATA) {\n\t\t\tdata_ofs = offset;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tpgofs = (pgoff_t)(offset >> PAGE_SHIFT);\n\n\tfor (; data_ofs < isize; data_ofs = (loff_t)pgofs << PAGE_SHIFT) {\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = f2fs_get_dnode_of_data(&dn, pgofs, LOOKUP_NODE);\n\t\tif (err && err != -ENOENT) {\n\t\t\tgoto fail;\n\t\t} else if (err == -ENOENT) {\n\t\t\t \n\t\t\tif (whence == SEEK_DATA) {\n\t\t\t\tpgofs = f2fs_get_next_page_offset(&dn, pgofs);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\n\t\t \n\t\tfor (; dn.ofs_in_node < end_offset;\n\t\t\t\tdn.ofs_in_node++, pgofs++,\n\t\t\t\tdata_ofs = (loff_t)pgofs << PAGE_SHIFT) {\n\t\t\tblock_t blkaddr;\n\n\t\t\tblkaddr = f2fs_data_blkaddr(&dn);\n\n\t\t\tif (__is_valid_data_blkaddr(blkaddr) &&\n\t\t\t\t!f2fs_is_valid_blkaddr(F2FS_I_SB(inode),\n\t\t\t\t\tblkaddr, DATA_GENERIC_ENHANCE)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (__found_offset(file->f_mapping, blkaddr,\n\t\t\t\t\t\t\tpgofs, whence)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\n\tif (whence == SEEK_DATA)\n\t\tgoto fail;\nfound:\n\tif (whence == SEEK_HOLE && data_ofs > isize)\n\t\tdata_ofs = isize;\n\tinode_unlock(inode);\n\treturn vfs_setpos(file, data_ofs, maxbytes);\nfail:\n\tinode_unlock(inode);\n\treturn -ENXIO;\n}\n\nstatic loff_t f2fs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes = inode->i_sb->s_maxbytes;\n\n\tif (f2fs_compressed_file(inode))\n\t\tmaxbytes = max_file_blocks(inode) << F2FS_BLKSIZE_BITS;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tif (offset < 0)\n\t\t\treturn -ENXIO;\n\t\treturn f2fs_seek_block(file, offset, whence);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tfile_accessed(file);\n\tvma->vm_ops = &f2fs_file_vm_ops;\n\n\tf2fs_down_read(&F2FS_I(inode)->i_sem);\n\tset_inode_flag(inode, FI_MMAP_FILE);\n\tf2fs_up_read(&F2FS_I(inode)->i_sem);\n\n\treturn 0;\n}\n\nstatic int f2fs_file_open(struct inode *inode, struct file *filp)\n{\n\tint err = fscrypt_file_open(inode, filp);\n\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\terr = fsverity_file_open(inode, filp);\n\tif (err)\n\t\treturn err;\n\n\tfilp->f_mode |= FMODE_NOWAIT | FMODE_BUF_RASYNC;\n\tfilp->f_mode |= FMODE_CAN_ODIRECT;\n\n\treturn dquot_file_open(inode, filp);\n}\n\nvoid f2fs_truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\tint nr_free = 0, ofs = dn->ofs_in_node, len = count;\n\t__le32 *addr;\n\tint base = 0;\n\tbool compressed_cluster = false;\n\tint cluster_index = 0, valid_blocks = 0;\n\tint cluster_size = F2FS_I(dn->inode)->i_cluster_size;\n\tbool released = !atomic_read(&F2FS_I(dn->inode)->i_compr_blocks);\n\n\tif (IS_INODE(dn->node_page) && f2fs_has_extra_attr(dn->inode))\n\t\tbase = get_extra_isize(dn->inode);\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + base + ofs;\n\n\t \n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++, cluster_index++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\n\t\tif (f2fs_compressed_file(dn->inode) &&\n\t\t\t\t\t!(cluster_index & (cluster_size - 1))) {\n\t\t\tif (compressed_cluster)\n\t\t\t\tf2fs_i_compr_blocks_update(dn->inode,\n\t\t\t\t\t\t\tvalid_blocks, false);\n\t\t\tcompressed_cluster = (blkaddr == COMPRESS_ADDR);\n\t\t\tvalid_blocks = 0;\n\t\t}\n\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tf2fs_set_data_blkaddr(dn);\n\n\t\tif (__is_valid_data_blkaddr(blkaddr)) {\n\t\t\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE))\n\t\t\t\tcontinue;\n\t\t\tif (compressed_cluster)\n\t\t\t\tvalid_blocks++;\n\t\t}\n\n\t\tif (dn->ofs_in_node == 0 && IS_INODE(dn->node_page))\n\t\t\tclear_inode_flag(dn->inode, FI_FIRST_BLOCK_WRITTEN);\n\n\t\tf2fs_invalidate_blocks(sbi, blkaddr);\n\n\t\tif (!released || blkaddr != COMPRESS_ADDR)\n\t\t\tnr_free++;\n\t}\n\n\tif (compressed_cluster)\n\t\tf2fs_i_compr_blocks_update(dn->inode, valid_blocks, false);\n\n\tif (nr_free) {\n\t\tpgoff_t fofs;\n\t\t \n\t\tfofs = f2fs_start_bidx_of_node(ofs_of_node(dn->node_page),\n\t\t\t\t\t\t\tdn->inode) + ofs;\n\t\tf2fs_update_read_extent_cache_range(dn, fofs, 0, len);\n\t\tf2fs_update_age_extent_cache_range(dn, fofs, len);\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n}\n\nstatic int truncate_partial_data_page(struct inode *inode, u64 from,\n\t\t\t\t\t\t\t\tbool cache_only)\n{\n\tloff_t offset = from & (PAGE_SIZE - 1);\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (!offset && !cache_only)\n\t\treturn 0;\n\n\tif (cache_only) {\n\t\tpage = find_lock_page(mapping, index);\n\t\tif (page && PageUptodate(page))\n\t\t\tgoto truncate_out;\n\t\tf2fs_put_page(page, 1);\n\t\treturn 0;\n\t}\n\n\tpage = f2fs_get_lock_data_page(inode, index, true);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page) == -ENOENT ? 0 : PTR_ERR(page);\ntruncate_out:\n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\tzero_user(page, offset, PAGE_SIZE - offset);\n\n\t \n\tf2fs_bug_on(F2FS_I_SB(inode), cache_only && IS_ENCRYPTED(inode));\n\tif (!cache_only)\n\t\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}\n\nint f2fs_do_truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\tbool truncate_page = false;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BLK_ALIGN(from);\n\n\tif (free_from >= max_file_blocks(inode))\n\t\tgoto free_partial;\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_truncate_inline_inode(inode, ipage, from);\n\t\tf2fs_put_page(ipage, 1);\n\t\ttruncate_page = true;\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, free_from, LOOKUP_NODE_RA);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, inode);\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\tf2fs_truncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = f2fs_truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\nfree_partial:\n\t \n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from, truncate_page);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}\n\nint f2fs_truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tu64 free_from = from;\n\tint err;\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t \n\tif (f2fs_compressed_file(inode))\n\t\tfree_from = round_up(from,\n\t\t\t\tF2FS_I(inode)->i_cluster_size << PAGE_SHIFT);\n#endif\n\n\terr = f2fs_do_truncate_blocks(inode, free_from, lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\t \n\tif (f2fs_compressed_file(inode) && !free_from\n\t\t\t&& is_inode_flag_set(inode, FI_COMPRESS_RELEASED))\n\t\tclear_inode_flag(inode, FI_COMPRESS_RELEASED);\n\n\tif (from != free_from) {\n\t\terr = f2fs_truncate_partial_cluster(inode, from, lock);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\n\treturn 0;\n}\n\nint f2fs_truncate(struct inode *inode)\n{\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn 0;\n\n\ttrace_f2fs_truncate(inode);\n\n\tif (time_to_inject(F2FS_I_SB(inode), FAULT_TRUNCATE))\n\t\treturn -EIO;\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!f2fs_may_inline_data(inode)) {\n\t\terr = f2fs_convert_inline_inode(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = f2fs_truncate_blocks(inode, i_size_read(inode), true);\n\tif (err)\n\t\treturn err;\n\n\tinode->i_mtime = inode_set_ctime_current(inode);\n\tf2fs_mark_inode_dirty_sync(inode, false);\n\treturn 0;\n}\n\nstatic bool f2fs_force_buffered_io(struct inode *inode, int rw)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (!fscrypt_dio_supported(inode))\n\t\treturn true;\n\tif (fsverity_active(inode))\n\t\treturn true;\n\tif (f2fs_compressed_file(inode))\n\t\treturn true;\n\n\t \n\tif (f2fs_is_multi_device(sbi) && !sbi->aligned_blksize)\n\t\treturn true;\n\t \n\tif (f2fs_sb_has_blkzoned(sbi) && (rw == WRITE))\n\t\treturn true;\n\tif (f2fs_lfs_mode(sbi) && rw == WRITE && F2FS_IO_ALIGNED(sbi))\n\t\treturn true;\n\tif (is_sbi_flag_set(sbi, SBI_CP_DISABLED))\n\t\treturn true;\n\n\treturn false;\n}\n\nint f2fs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tunsigned int flags;\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\tf2fs_sb_has_inode_crtime(F2FS_I_SB(inode)) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tstat->result_mask |= STATX_BTIME;\n\t\tstat->btime.tv_sec = fi->i_crtime.tv_sec;\n\t\tstat->btime.tv_nsec = fi->i_crtime.tv_nsec;\n\t}\n\n\t \n\tif ((request_mask & STATX_DIOALIGN) && S_ISREG(inode->i_mode)) {\n\t\tunsigned int bsize = i_blocksize(inode);\n\n\t\tstat->result_mask |= STATX_DIOALIGN;\n\t\tif (!f2fs_force_buffered_io(inode, WRITE)) {\n\t\t\tstat->dio_mem_align = bsize;\n\t\t\tstat->dio_offset_align = bsize;\n\t\t}\n\t}\n\n\tflags = fi->i_flags;\n\tif (flags & F2FS_COMPR_FL)\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\tif (flags & F2FS_APPEND_FL)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (IS_ENCRYPTED(inode))\n\t\tstat->attributes |= STATX_ATTR_ENCRYPTED;\n\tif (flags & F2FS_IMMUTABLE_FL)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (flags & F2FS_NODUMP_FL)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\tif (IS_VERITY(inode))\n\t\tstat->attributes |= STATX_ATTR_VERITY;\n\n\tstat->attributes_mask |= (STATX_ATTR_COMPRESSED |\n\t\t\t\t  STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_ENCRYPTED |\n\t\t\t\t  STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_NODUMP |\n\t\t\t\t  STATX_ATTR_VERITY);\n\n\tgeneric_fillattr(idmap, request_mask, inode, stat);\n\n\t \n\tif ((S_ISREG(inode->i_mode) && f2fs_has_inline_data(inode)) ||\n\t\t\t\t\tf2fs_has_inline_dentry(inode))\n\t\tstat->blocks += (stat->size + 511) >> 9;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_F2FS_FS_POSIX_ACL\nstatic void __setattr_copy(struct mnt_idmap *idmap,\n\t\t\t   struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\ti_uid_update(idmap, attr, inode);\n\ti_gid_update(idmap, attr, inode);\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = attr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = attr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode_set_ctime_to_ts(inode, attr->ia_ctime);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tvfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);\n\n\t\tif (!vfsgid_in_group_p(vfsgid) &&\n\t\t    !capable_wrt_inode_uidgid(idmap, inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(inode, mode);\n\t}\n}\n#else\n#define __setattr_copy setattr_copy\n#endif\n\nint f2fs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\n\tif (unlikely(IS_IMMUTABLE(inode)))\n\t\treturn -EPERM;\n\n\tif (unlikely(IS_APPEND(inode) &&\n\t\t\t(attr->ia_valid & (ATTR_MODE | ATTR_UID |\n\t\t\t\t  ATTR_GID | ATTR_TIMES_SET))))\n\t\treturn -EPERM;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t\t!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\terr = setattr_prepare(idmap, dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = fscrypt_prepare_setattr(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = fsverity_prepare_setattr(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (is_quota_modification(idmap, inode, attr)) {\n\t\terr = f2fs_dquot_initialize(inode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (i_uid_needs_update(idmap, attr, inode) ||\n\t    i_gid_needs_update(idmap, attr, inode)) {\n\t\tf2fs_lock_op(F2FS_I_SB(inode));\n\t\terr = dquot_transfer(idmap, inode, attr);\n\t\tif (err) {\n\t\t\tset_sbi_flag(F2FS_I_SB(inode),\n\t\t\t\t\tSBI_QUOTA_NEED_REPAIR);\n\t\t\tf2fs_unlock_op(F2FS_I_SB(inode));\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\ti_uid_update(idmap, attr, inode);\n\t\ti_gid_update(idmap, attr, inode);\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t\tf2fs_unlock_op(F2FS_I_SB(inode));\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tloff_t old_size = i_size_read(inode);\n\n\t\tif (attr->ia_size > MAX_INLINE_DATA(inode)) {\n\t\t\t \n\t\t\terr = f2fs_convert_inline_inode(inode);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\tfilemap_invalidate_lock(inode->i_mapping);\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\n\t\tif (attr->ia_size <= old_size)\n\t\t\terr = f2fs_truncate(inode);\n\t\t \n\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tspin_lock(&F2FS_I(inode)->i_size_lock);\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tF2FS_I(inode)->last_disk_size = i_size_read(inode);\n\t\tspin_unlock(&F2FS_I(inode)->i_size_lock);\n\t}\n\n\t__setattr_copy(idmap, inode, attr);\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(idmap, dentry, f2fs_get_inode_mode(inode));\n\n\t\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\t\tif (!err)\n\t\t\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t}\n\t}\n\n\t \n\tf2fs_mark_inode_dirty_sync(inode, true);\n\n\t \n\tf2fs_balance_fs(F2FS_I_SB(inode), true);\n\n\treturn err;\n}\n\nconst struct inode_operations f2fs_file_inode_operations = {\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.get_inode_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n\t.listxattr\t= f2fs_listxattr,\n\t.fiemap\t\t= f2fs_fiemap,\n\t.fileattr_get\t= f2fs_fileattr_get,\n\t.fileattr_set\t= f2fs_fileattr_set,\n};\n\nstatic int fill_zero(struct inode *inode, pgoff_t index,\n\t\t\t\t\tloff_t start, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page;\n\n\tif (!len)\n\t\treturn 0;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_lock_op(sbi);\n\tpage = f2fs_get_new_data_page(inode, NULL, index, false);\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\tzero_user(page, start, len);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}\n\nint f2fs_truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tint err;\n\n\twhile (pg_start < pg_end) {\n\t\tstruct dnode_of_data dn;\n\t\tpgoff_t end_offset, count;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = f2fs_get_dnode_of_data(&dn, pg_start, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\tpg_start = f2fs_get_next_page_offset(&dn,\n\t\t\t\t\t\t\t\tpg_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn err;\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\t\tcount = min(end_offset - dn.ofs_in_node, pg_end - pg_start);\n\n\t\tf2fs_bug_on(F2FS_I_SB(inode), count == 0 || count > end_offset);\n\n\t\tf2fs_truncate_data_blocks_range(&dn, count);\n\t\tf2fs_put_dnode(&dn);\n\n\t\tpg_start += count;\n\t}\n\treturn 0;\n}\n\nstatic int f2fs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tpgoff_t pg_start, pg_end;\n\tloff_t off_start, off_end;\n\tint ret;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_SHIFT;\n\n\toff_start = offset & (PAGE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tret = fill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (off_start) {\n\t\t\tret = fill_zero(inode, pg_start++, off_start,\n\t\t\t\t\t\tPAGE_SIZE - off_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (off_end) {\n\t\t\tret = fill_zero(inode, pg_end, 0, off_end);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (pg_start < pg_end) {\n\t\t\tloff_t blk_start, blk_end;\n\t\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\t\tf2fs_balance_fs(sbi, true);\n\n\t\t\tblk_start = (loff_t)pg_start << PAGE_SHIFT;\n\t\t\tblk_end = (loff_t)pg_end << PAGE_SHIFT;\n\n\t\t\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t\tfilemap_invalidate_lock(inode->i_mapping);\n\n\t\t\ttruncate_pagecache_range(inode, blk_start, blk_end - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\t\t\tret = f2fs_truncate_hole(inode, pg_start, pg_end);\n\t\t\tf2fs_unlock_op(sbi);\n\n\t\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\t\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int __read_out_blkaddrs(struct inode *inode, block_t *blkaddr,\n\t\t\t\tint *do_replace, pgoff_t off, pgoff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tint ret, done, i;\n\nnext_dnode:\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\tret = f2fs_get_dnode_of_data(&dn, off, LOOKUP_NODE_RA);\n\tif (ret && ret != -ENOENT) {\n\t\treturn ret;\n\t} else if (ret == -ENOENT) {\n\t\tif (dn.max_level == 0)\n\t\t\treturn -ENOENT;\n\t\tdone = min((pgoff_t)ADDRS_PER_BLOCK(inode) -\n\t\t\t\t\t\tdn.ofs_in_node, len);\n\t\tblkaddr += done;\n\t\tdo_replace += done;\n\t\tgoto next;\n\t}\n\n\tdone = min((pgoff_t)ADDRS_PER_PAGE(dn.node_page, inode) -\n\t\t\t\t\t\t\tdn.ofs_in_node, len);\n\tfor (i = 0; i < done; i++, blkaddr++, do_replace++, dn.ofs_in_node++) {\n\t\t*blkaddr = f2fs_data_blkaddr(&dn);\n\n\t\tif (__is_valid_data_blkaddr(*blkaddr) &&\n\t\t\t!f2fs_is_valid_blkaddr(sbi, *blkaddr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\t\tf2fs_put_dnode(&dn);\n\t\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (!f2fs_is_checkpointed_data(sbi, *blkaddr)) {\n\n\t\t\tif (f2fs_lfs_mode(sbi)) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\t \n\t\t\tf2fs_update_data_blkaddr(&dn, NULL_ADDR);\n\t\t\t*do_replace = 1;\n\t\t}\n\t}\n\tf2fs_put_dnode(&dn);\nnext:\n\tlen -= done;\n\toff += done;\n\tif (len)\n\t\tgoto next_dnode;\n\treturn 0;\n}\n\nstatic int __roll_back_blkaddrs(struct inode *inode, block_t *blkaddr,\n\t\t\t\tint *do_replace, pgoff_t off, int len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tint ret, i;\n\n\tfor (i = 0; i < len; i++, do_replace++, blkaddr++) {\n\t\tif (*do_replace == 0)\n\t\t\tcontinue;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_get_dnode_of_data(&dn, off + i, LOOKUP_NODE_RA);\n\t\tif (ret) {\n\t\t\tdec_valid_block_count(sbi, inode, 1);\n\t\t\tf2fs_invalidate_blocks(sbi, *blkaddr);\n\t\t} else {\n\t\t\tf2fs_update_data_blkaddr(&dn, *blkaddr);\n\t\t}\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}\n\nstatic int __clone_blkaddrs(struct inode *src_inode, struct inode *dst_inode,\n\t\t\tblock_t *blkaddr, int *do_replace,\n\t\t\tpgoff_t src, pgoff_t dst, pgoff_t len, bool full)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(src_inode);\n\tpgoff_t i = 0;\n\tint ret;\n\n\twhile (i < len) {\n\t\tif (blkaddr[i] == NULL_ADDR && !full) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (do_replace[i] || blkaddr[i] == NULL_ADDR) {\n\t\t\tstruct dnode_of_data dn;\n\t\t\tstruct node_info ni;\n\t\t\tsize_t new_size;\n\t\t\tpgoff_t ilen;\n\n\t\t\tset_new_dnode(&dn, dst_inode, NULL, NULL, 0);\n\t\t\tret = f2fs_get_dnode_of_data(&dn, dst + i, ALLOC_NODE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = f2fs_get_node_info(sbi, dn.nid, &ni, false);\n\t\t\tif (ret) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tilen = min((pgoff_t)\n\t\t\t\tADDRS_PER_PAGE(dn.node_page, dst_inode) -\n\t\t\t\t\t\tdn.ofs_in_node, len - i);\n\t\t\tdo {\n\t\t\t\tdn.data_blkaddr = f2fs_data_blkaddr(&dn);\n\t\t\t\tf2fs_truncate_data_blocks_range(&dn, 1);\n\n\t\t\t\tif (do_replace[i]) {\n\t\t\t\t\tf2fs_i_blocks_write(src_inode,\n\t\t\t\t\t\t\t1, false, false);\n\t\t\t\t\tf2fs_i_blocks_write(dst_inode,\n\t\t\t\t\t\t\t1, true, false);\n\t\t\t\t\tf2fs_replace_block(sbi, &dn, dn.data_blkaddr,\n\t\t\t\t\tblkaddr[i], ni.version, true, false);\n\n\t\t\t\t\tdo_replace[i] = 0;\n\t\t\t\t}\n\t\t\t\tdn.ofs_in_node++;\n\t\t\t\ti++;\n\t\t\t\tnew_size = (loff_t)(dst + i) << PAGE_SHIFT;\n\t\t\t\tif (dst_inode->i_size < new_size)\n\t\t\t\t\tf2fs_i_size_write(dst_inode, new_size);\n\t\t\t} while (--ilen && (do_replace[i] || blkaddr[i] == NULL_ADDR));\n\n\t\t\tf2fs_put_dnode(&dn);\n\t\t} else {\n\t\t\tstruct page *psrc, *pdst;\n\n\t\t\tpsrc = f2fs_get_lock_data_page(src_inode,\n\t\t\t\t\t\t\tsrc + i, true);\n\t\t\tif (IS_ERR(psrc))\n\t\t\t\treturn PTR_ERR(psrc);\n\t\t\tpdst = f2fs_get_new_data_page(dst_inode, NULL, dst + i,\n\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (IS_ERR(pdst)) {\n\t\t\t\tf2fs_put_page(psrc, 1);\n\t\t\t\treturn PTR_ERR(pdst);\n\t\t\t}\n\t\t\tmemcpy_page(pdst, 0, psrc, 0, PAGE_SIZE);\n\t\t\tset_page_dirty(pdst);\n\t\t\tf2fs_put_page(pdst, 1);\n\t\t\tf2fs_put_page(psrc, 1);\n\n\t\t\tret = f2fs_truncate_hole(src_inode,\n\t\t\t\t\t\tsrc + i, src + i + 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __exchange_data_block(struct inode *src_inode,\n\t\t\tstruct inode *dst_inode, pgoff_t src, pgoff_t dst,\n\t\t\tpgoff_t len, bool full)\n{\n\tblock_t *src_blkaddr;\n\tint *do_replace;\n\tpgoff_t olen;\n\tint ret;\n\n\twhile (len) {\n\t\tolen = min((pgoff_t)4 * ADDRS_PER_BLOCK(src_inode), len);\n\n\t\tsrc_blkaddr = f2fs_kvzalloc(F2FS_I_SB(src_inode),\n\t\t\t\t\tarray_size(olen, sizeof(block_t)),\n\t\t\t\t\tGFP_NOFS);\n\t\tif (!src_blkaddr)\n\t\t\treturn -ENOMEM;\n\n\t\tdo_replace = f2fs_kvzalloc(F2FS_I_SB(src_inode),\n\t\t\t\t\tarray_size(olen, sizeof(int)),\n\t\t\t\t\tGFP_NOFS);\n\t\tif (!do_replace) {\n\t\t\tkvfree(src_blkaddr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = __read_out_blkaddrs(src_inode, src_blkaddr,\n\t\t\t\t\tdo_replace, src, olen);\n\t\tif (ret)\n\t\t\tgoto roll_back;\n\n\t\tret = __clone_blkaddrs(src_inode, dst_inode, src_blkaddr,\n\t\t\t\t\tdo_replace, src, dst, olen, full);\n\t\tif (ret)\n\t\t\tgoto roll_back;\n\n\t\tsrc += olen;\n\t\tdst += olen;\n\t\tlen -= olen;\n\n\t\tkvfree(src_blkaddr);\n\t\tkvfree(do_replace);\n\t}\n\treturn 0;\n\nroll_back:\n\t__roll_back_blkaddrs(src_inode, src_blkaddr, do_replace, src, olen);\n\tkvfree(src_blkaddr);\n\tkvfree(do_replace);\n\treturn ret;\n}\n\nstatic int f2fs_do_collapse(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t nrpages = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\tpgoff_t start = offset >> PAGE_SHIFT;\n\tpgoff_t end = (offset + len) >> PAGE_SHIFT;\n\tint ret;\n\n\tf2fs_balance_fs(sbi, true);\n\n\t \n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\tf2fs_lock_op(sbi);\n\tf2fs_drop_extent_tree(inode);\n\ttruncate_pagecache(inode, offset);\n\tret = __exchange_data_block(inode, inode, end, start, nrpages - end, true);\n\tf2fs_unlock_op(sbi);\n\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\treturn ret;\n}\n\nstatic int f2fs_collapse_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tloff_t new_size;\n\tint ret;\n\n\tif (offset + len >= i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t \n\tif (offset & (F2FS_BLKSIZE - 1) || len & (F2FS_BLKSIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = filemap_write_and_wait_range(inode->i_mapping, offset, LLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f2fs_do_collapse(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfilemap_invalidate_lock(inode->i_mapping);\n\tfilemap_write_and_wait_range(inode->i_mapping, offset, LLONG_MAX);\n\ttruncate_pagecache(inode, offset);\n\n\tnew_size = i_size_read(inode) - len;\n\tret = f2fs_truncate_blocks(inode, new_size, true);\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\tif (!ret)\n\t\tf2fs_i_size_write(inode, new_size);\n\treturn ret;\n}\n\nstatic int f2fs_do_zero_range(struct dnode_of_data *dn, pgoff_t start,\n\t\t\t\t\t\t\t\tpgoff_t end)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tpgoff_t index = start;\n\tunsigned int ofs_in_node = dn->ofs_in_node;\n\tblkcnt_t count = 0;\n\tint ret;\n\n\tfor (; index < end; index++, dn->ofs_in_node++) {\n\t\tif (f2fs_data_blkaddr(dn) == NULL_ADDR)\n\t\t\tcount++;\n\t}\n\n\tdn->ofs_in_node = ofs_in_node;\n\tret = f2fs_reserve_new_blocks(dn, count);\n\tif (ret)\n\t\treturn ret;\n\n\tdn->ofs_in_node = ofs_in_node;\n\tfor (index = start; index < end; index++, dn->ofs_in_node++) {\n\t\tdn->data_blkaddr = f2fs_data_blkaddr(dn);\n\t\t \n\t\tif (dn->data_blkaddr == NULL_ADDR) {\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dn->data_blkaddr == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (!f2fs_is_valid_blkaddr(sbi, dn->data_blkaddr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\t\tbreak;\n\t\t}\n\n\t\tf2fs_invalidate_blocks(sbi, dn->data_blkaddr);\n\t\tdn->data_blkaddr = NEW_ADDR;\n\t\tf2fs_set_data_blkaddr(dn);\n\t}\n\n\tf2fs_update_read_extent_cache_range(dn, start, 0, index - start);\n\tf2fs_update_age_extent_cache_range(dn, start, index - start);\n\n\treturn ret;\n}\n\nstatic int f2fs_zero_range(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t\t\t\t\t\tint mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t index, pg_start, pg_end;\n\tloff_t new_size = i_size_read(inode);\n\tloff_t off_start, off_end;\n\tint ret = 0;\n\n\tret = inode_newsize_ok(inode, (len + offset));\n\tif (ret)\n\t\treturn ret;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_write_and_wait_range(mapping, offset, offset + len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_start = ((unsigned long long) offset) >> PAGE_SHIFT;\n\tpg_end = ((unsigned long long) offset + len) >> PAGE_SHIFT;\n\n\toff_start = offset & (PAGE_SIZE - 1);\n\toff_end = (offset + len) & (PAGE_SIZE - 1);\n\n\tif (pg_start == pg_end) {\n\t\tret = fill_zero(inode, pg_start, off_start,\n\t\t\t\t\t\toff_end - off_start);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnew_size = max_t(loff_t, new_size, offset + len);\n\t} else {\n\t\tif (off_start) {\n\t\t\tret = fill_zero(inode, pg_start++, off_start,\n\t\t\t\t\t\tPAGE_SIZE - off_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tnew_size = max_t(loff_t, new_size,\n\t\t\t\t\t(loff_t)pg_start << PAGE_SHIFT);\n\t\t}\n\n\t\tfor (index = pg_start; index < pg_end;) {\n\t\t\tstruct dnode_of_data dn;\n\t\t\tunsigned int end_offset;\n\t\t\tpgoff_t end;\n\n\t\t\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t\tfilemap_invalidate_lock(mapping);\n\n\t\t\ttruncate_pagecache_range(inode,\n\t\t\t\t(loff_t)index << PAGE_SHIFT,\n\t\t\t\t((loff_t)pg_end << PAGE_SHIFT) - 1);\n\n\t\t\tf2fs_lock_op(sbi);\n\n\t\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\t\tret = f2fs_get_dnode_of_data(&dn, index, ALLOC_NODE);\n\t\t\tif (ret) {\n\t\t\t\tf2fs_unlock_op(sbi);\n\t\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\t\t\tend = min(pg_end, end_offset - dn.ofs_in_node + index);\n\n\t\t\tret = f2fs_do_zero_range(&dn, index, end);\n\t\t\tf2fs_put_dnode(&dn);\n\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tfilemap_invalidate_unlock(mapping);\n\t\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\n\t\t\tf2fs_balance_fs(sbi, dn.node_changed);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tindex = end;\n\t\t\tnew_size = max_t(loff_t, new_size,\n\t\t\t\t\t(loff_t)index << PAGE_SHIFT);\n\t\t}\n\n\t\tif (off_end) {\n\t\t\tret = fill_zero(inode, pg_end, 0, off_end);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tnew_size = max_t(loff_t, new_size, offset + len);\n\t\t}\n\t}\n\nout:\n\tif (new_size > i_size_read(inode)) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\tfile_set_keep_isize(inode);\n\t\telse\n\t\t\tf2fs_i_size_write(inode, new_size);\n\t}\n\treturn ret;\n}\n\nstatic int f2fs_insert_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t nr, pg_start, pg_end, delta, idx;\n\tloff_t new_size;\n\tint ret = 0;\n\n\tnew_size = i_size_read(inode) + len;\n\tret = inode_newsize_ok(inode, new_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (offset >= i_size_read(inode))\n\t\treturn -EINVAL;\n\n\t \n\tif (offset & (F2FS_BLKSIZE - 1) || len & (F2FS_BLKSIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tfilemap_invalidate_lock(mapping);\n\tret = f2fs_truncate_blocks(inode, i_size_read(inode), true);\n\tfilemap_invalidate_unlock(mapping);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = filemap_write_and_wait_range(mapping, offset, LLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\tpg_start = offset >> PAGE_SHIFT;\n\tpg_end = (offset + len) >> PAGE_SHIFT;\n\tdelta = pg_end - pg_start;\n\tidx = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\t \n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tfilemap_invalidate_lock(mapping);\n\ttruncate_pagecache(inode, offset);\n\n\twhile (!ret && idx > pg_start) {\n\t\tnr = idx - pg_start;\n\t\tif (nr > delta)\n\t\t\tnr = delta;\n\t\tidx -= nr;\n\n\t\tf2fs_lock_op(sbi);\n\t\tf2fs_drop_extent_tree(inode);\n\n\t\tret = __exchange_data_block(inode, inode, idx,\n\t\t\t\t\tidx + delta, nr, false);\n\t\tf2fs_unlock_op(sbi);\n\t}\n\tfilemap_invalidate_unlock(mapping);\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\n\t \n\tfilemap_invalidate_lock(mapping);\n\tfilemap_write_and_wait_range(mapping, offset, LLONG_MAX);\n\ttruncate_pagecache(inode, offset);\n\tfilemap_invalidate_unlock(mapping);\n\n\tif (!ret)\n\t\tf2fs_i_size_write(inode, new_size);\n\treturn ret;\n}\n\nstatic int f2fs_expand_inode_data(struct inode *inode, loff_t offset,\n\t\t\t\t\tloff_t len, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_map_blocks map = { .m_next_pgofs = NULL,\n\t\t\t.m_next_extent = NULL, .m_seg_type = NO_CHECK_TYPE,\n\t\t\t.m_may_create = true };\n\tstruct f2fs_gc_control gc_control = { .victim_segno = NULL_SEGNO,\n\t\t\t.init_gc_type = FG_GC,\n\t\t\t.should_migrate_blocks = false,\n\t\t\t.err_gc_skipped = true,\n\t\t\t.nr_free_secs = 0 };\n\tpgoff_t pg_start, pg_end;\n\tloff_t new_size;\n\tloff_t off_end;\n\tblock_t expanded = 0;\n\tint err;\n\n\terr = inode_newsize_ok(inode, (len + offset));\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_convert_inline_inode(inode);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tpg_start = ((unsigned long long)offset) >> PAGE_SHIFT;\n\tpg_end = ((unsigned long long)offset + len) >> PAGE_SHIFT;\n\toff_end = (offset + len) & (PAGE_SIZE - 1);\n\n\tmap.m_lblk = pg_start;\n\tmap.m_len = pg_end - pg_start;\n\tif (off_end)\n\t\tmap.m_len++;\n\n\tif (!map.m_len)\n\t\treturn 0;\n\n\tif (f2fs_is_pinned_file(inode)) {\n\t\tblock_t sec_blks = CAP_BLKS_PER_SEC(sbi);\n\t\tblock_t sec_len = roundup(map.m_len, sec_blks);\n\n\t\tmap.m_len = sec_blks;\nnext_alloc:\n\t\tif (has_not_enough_free_secs(sbi, 0,\n\t\t\tGET_SEC_FROM_SEG(sbi, overprovision_segments(sbi)))) {\n\t\t\tf2fs_down_write(&sbi->gc_lock);\n\t\t\tstat_inc_gc_call_count(sbi, FOREGROUND);\n\t\t\terr = f2fs_gc(sbi, &gc_control);\n\t\t\tif (err && err != -ENODATA)\n\t\t\t\tgoto out_err;\n\t\t}\n\n\t\tf2fs_down_write(&sbi->pin_sem);\n\n\t\tf2fs_lock_op(sbi);\n\t\tf2fs_allocate_new_section(sbi, CURSEG_COLD_DATA_PINNED, false);\n\t\tf2fs_unlock_op(sbi);\n\n\t\tmap.m_seg_type = CURSEG_COLD_DATA_PINNED;\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_PRE_DIO);\n\t\tfile_dont_truncate(inode);\n\n\t\tf2fs_up_write(&sbi->pin_sem);\n\n\t\texpanded += map.m_len;\n\t\tsec_len -= map.m_len;\n\t\tmap.m_lblk += map.m_len;\n\t\tif (!err && sec_len)\n\t\t\tgoto next_alloc;\n\n\t\tmap.m_len = expanded;\n\t} else {\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_PRE_AIO);\n\t\texpanded = map.m_len;\n\t}\nout_err:\n\tif (err) {\n\t\tpgoff_t last_off;\n\n\t\tif (!expanded)\n\t\t\treturn err;\n\n\t\tlast_off = pg_start + expanded - 1;\n\n\t\t \n\t\tnew_size = (last_off == pg_end) ? offset + len :\n\t\t\t\t\t(loff_t)(last_off + 1) << PAGE_SHIFT;\n\t} else {\n\t\tnew_size = ((loff_t)pg_end << PAGE_SHIFT) + off_end;\n\t}\n\n\tif (new_size > i_size_read(inode)) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\tfile_set_keep_isize(inode);\n\t\telse\n\t\t\tf2fs_i_size_write(inode, new_size);\n\t}\n\n\treturn err;\n}\n\nstatic long f2fs_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret = 0;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(F2FS_I_SB(inode)))\n\t\treturn -ENOSPC;\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (IS_ENCRYPTED(inode) &&\n\t\t(mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)) &&\n\t\t(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE |\n\t\t\tFALLOC_FL_ZERO_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t\tFALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |\n\t\t\tFALLOC_FL_INSERT_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tif (offset >= inode->i_size)\n\t\t\tgoto out;\n\n\t\tret = f2fs_punch_hole(inode, offset, len);\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tret = f2fs_collapse_range(inode, offset, len);\n\t} else if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tret = f2fs_zero_range(inode, offset, len, mode);\n\t} else if (mode & FALLOC_FL_INSERT_RANGE) {\n\t\tret = f2fs_insert_range(inode, offset, len);\n\t} else {\n\t\tret = f2fs_expand_inode_data(inode, offset, len, mode);\n\t}\n\n\tif (!ret) {\n\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tf2fs_mark_inode_dirty_sync(inode, false);\n\t\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\t}\n\nout:\n\tinode_unlock(inode);\n\n\ttrace_f2fs_fallocate(inode, mode, offset, len, ret);\n\treturn ret;\n}\n\nstatic int f2fs_release_file(struct inode *inode, struct file *filp)\n{\n\t \n\tif (!(filp->f_mode & FMODE_WRITE) ||\n\t\t\tatomic_read(&inode->i_writecount) != 1)\n\t\treturn 0;\n\n\tinode_lock(inode);\n\tf2fs_abort_atomic_write(inode, true);\n\tinode_unlock(inode);\n\n\treturn 0;\n}\n\nstatic int f2fs_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\n\t \n\tif (F2FS_I(inode)->atomic_write_task == current &&\n\t\t\t\t(current->flags & PF_EXITING)) {\n\t\tinode_lock(inode);\n\t\tf2fs_abort_atomic_write(inode, true);\n\t\tinode_unlock(inode);\n\t}\n\n\treturn 0;\n}\n\nstatic int f2fs_setflags_common(struct inode *inode, u32 iflags, u32 mask)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tu32 masked_flags = fi->i_flags & mask;\n\n\t \n\tiflags &= mask;\n\n\t \n\tif (IS_NOQUOTA(inode))\n\t\treturn -EPERM;\n\n\tif ((iflags ^ masked_flags) & F2FS_CASEFOLD_FL) {\n\t\tif (!f2fs_sb_has_casefold(F2FS_I_SB(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!f2fs_empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t}\n\n\tif (iflags & (F2FS_COMPR_FL | F2FS_NOCOMP_FL)) {\n\t\tif (!f2fs_sb_has_compression(F2FS_I_SB(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((iflags & F2FS_COMPR_FL) && (iflags & F2FS_NOCOMP_FL))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((iflags ^ masked_flags) & F2FS_COMPR_FL) {\n\t\tif (masked_flags & F2FS_COMPR_FL) {\n\t\t\tif (!f2fs_disable_compressed_file(inode))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tint err = f2fs_convert_inline_inode(inode);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tf2fs_down_write(&F2FS_I(inode)->i_sem);\n\t\t\tif (!f2fs_may_compress(inode) ||\n\t\t\t\t\t(S_ISREG(inode->i_mode) &&\n\t\t\t\t\tF2FS_HAS_BLOCKS(inode))) {\n\t\t\t\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = set_compress_context(inode);\n\t\t\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfi->i_flags = iflags | (fi->i_flags & ~mask);\n\tf2fs_bug_on(F2FS_I_SB(inode), (fi->i_flags & F2FS_COMPR_FL) &&\n\t\t\t\t\t(fi->i_flags & F2FS_NOCOMP_FL));\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\telse\n\t\tclear_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tinode_set_ctime_current(inode);\n\tf2fs_set_inode_flags(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\treturn 0;\n}\n\n \n\n \n\nstatic const struct {\n\tu32 iflag;\n\tu32 fsflag;\n} f2fs_fsflags_map[] = {\n\t{ F2FS_COMPR_FL,\tFS_COMPR_FL },\n\t{ F2FS_SYNC_FL,\t\tFS_SYNC_FL },\n\t{ F2FS_IMMUTABLE_FL,\tFS_IMMUTABLE_FL },\n\t{ F2FS_APPEND_FL,\tFS_APPEND_FL },\n\t{ F2FS_NODUMP_FL,\tFS_NODUMP_FL },\n\t{ F2FS_NOATIME_FL,\tFS_NOATIME_FL },\n\t{ F2FS_NOCOMP_FL,\tFS_NOCOMP_FL },\n\t{ F2FS_INDEX_FL,\tFS_INDEX_FL },\n\t{ F2FS_DIRSYNC_FL,\tFS_DIRSYNC_FL },\n\t{ F2FS_PROJINHERIT_FL,\tFS_PROJINHERIT_FL },\n\t{ F2FS_CASEFOLD_FL,\tFS_CASEFOLD_FL },\n};\n\n#define F2FS_GETTABLE_FS_FL (\t\t\\\n\t\tFS_COMPR_FL |\t\t\\\n\t\tFS_SYNC_FL |\t\t\\\n\t\tFS_IMMUTABLE_FL |\t\\\n\t\tFS_APPEND_FL |\t\t\\\n\t\tFS_NODUMP_FL |\t\t\\\n\t\tFS_NOATIME_FL |\t\t\\\n\t\tFS_NOCOMP_FL |\t\t\\\n\t\tFS_INDEX_FL |\t\t\\\n\t\tFS_DIRSYNC_FL |\t\t\\\n\t\tFS_PROJINHERIT_FL |\t\\\n\t\tFS_ENCRYPT_FL |\t\t\\\n\t\tFS_INLINE_DATA_FL |\t\\\n\t\tFS_NOCOW_FL |\t\t\\\n\t\tFS_VERITY_FL |\t\t\\\n\t\tFS_CASEFOLD_FL)\n\n#define F2FS_SETTABLE_FS_FL (\t\t\\\n\t\tFS_COMPR_FL |\t\t\\\n\t\tFS_SYNC_FL |\t\t\\\n\t\tFS_IMMUTABLE_FL |\t\\\n\t\tFS_APPEND_FL |\t\t\\\n\t\tFS_NODUMP_FL |\t\t\\\n\t\tFS_NOATIME_FL |\t\t\\\n\t\tFS_NOCOMP_FL |\t\t\\\n\t\tFS_DIRSYNC_FL |\t\t\\\n\t\tFS_PROJINHERIT_FL |\t\\\n\t\tFS_CASEFOLD_FL)\n\n \nstatic inline u32 f2fs_iflags_to_fsflags(u32 iflags)\n{\n\tu32 fsflags = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(f2fs_fsflags_map); i++)\n\t\tif (iflags & f2fs_fsflags_map[i].iflag)\n\t\t\tfsflags |= f2fs_fsflags_map[i].fsflag;\n\n\treturn fsflags;\n}\n\n \nstatic inline u32 f2fs_fsflags_to_iflags(u32 fsflags)\n{\n\tu32 iflags = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(f2fs_fsflags_map); i++)\n\t\tif (fsflags & f2fs_fsflags_map[i].fsflag)\n\t\t\tiflags |= f2fs_fsflags_map[i].iflag;\n\n\treturn iflags;\n}\n\nstatic int f2fs_ioc_getversion(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\treturn put_user(inode->i_generation, (int __user *)arg);\n}\n\nstatic int f2fs_ioc_start_atomic_write(struct file *filp, bool truncate)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct mnt_idmap *idmap = file_mnt_idmap(filp);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode *pinode;\n\tloff_t isize;\n\tint ret;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EACCES;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tif (!f2fs_disable_compressed_file(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_is_atomic_file(inode))\n\t\tgoto out;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tf2fs_down_write(&fi->i_gc_rwsem[WRITE]);\n\n\t \n\tif (get_dirty_pages(inode))\n\t\tf2fs_warn(sbi, \"Unexpected flush for atomic writes: ino=%lu, npages=%u\",\n\t\t\t  inode->i_ino, get_dirty_pages(inode));\n\tret = filemap_write_and_wait_range(inode->i_mapping, 0, LLONG_MAX);\n\tif (ret) {\n\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\tgoto out;\n\t}\n\n\t \n\tif (fi->cow_inode == NULL) {\n\t\t \n\t\tpinode = f2fs_iget(inode->i_sb, fi->i_pino);\n\t\tif (IS_ERR(pinode)) {\n\t\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\t\tret = PTR_ERR(pinode);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = f2fs_get_tmpfile(idmap, pinode, &fi->cow_inode);\n\t\tiput(pinode);\n\t\tif (ret) {\n\t\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_inode_flag(fi->cow_inode, FI_COW_FILE);\n\t\tclear_inode_flag(fi->cow_inode, FI_INLINE_DATA);\n\t} else {\n\t\t \n\t\tret = f2fs_do_truncate_blocks(fi->cow_inode, 0, true);\n\t\tif (ret) {\n\t\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tf2fs_write_inode(inode, NULL);\n\n\tstat_inc_atomic_inode(inode);\n\n\tset_inode_flag(inode, FI_ATOMIC_FILE);\n\n\tisize = i_size_read(inode);\n\tfi->original_i_size = isize;\n\tif (truncate) {\n\t\tset_inode_flag(inode, FI_ATOMIC_REPLACE);\n\t\ttruncate_inode_pages_final(inode->i_mapping);\n\t\tf2fs_i_size_write(inode, 0);\n\t\tisize = 0;\n\t}\n\tf2fs_i_size_write(fi->cow_inode, isize);\n\n\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\tfi->atomic_write_task = current;\n\tstat_update_max_atomic_write(inode);\n\tfi->atomic_write_cnt = 0;\nout:\n\tinode_unlock(inode);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_commit_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct mnt_idmap *idmap = file_mnt_idmap(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(F2FS_I_SB(inode), true);\n\n\tinode_lock(inode);\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tret = f2fs_commit_atomic_write(inode);\n\t\tif (!ret)\n\t\t\tret = f2fs_do_sync_file(filp, 0, LLONG_MAX, 0, true);\n\n\t\tf2fs_abort_atomic_write(inode, ret);\n\t} else {\n\t\tret = f2fs_do_sync_file(filp, 0, LLONG_MAX, 1, false);\n\t}\n\n\tinode_unlock(inode);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_abort_atomic_write(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct mnt_idmap *idmap = file_mnt_idmap(filp);\n\tint ret;\n\n\tif (!inode_owner_or_capable(idmap, inode))\n\t\treturn -EACCES;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tf2fs_abort_atomic_write(inode, true);\n\n\tinode_unlock(inode);\n\n\tmnt_drop_write_file(filp);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_shutdown(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct super_block *sb = sbi->sb;\n\t__u32 in;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (get_user(in, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (in != F2FS_GOING_DOWN_FULLSYNC) {\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret) {\n\t\t\tif (ret == -EROFS) {\n\t\t\t\tret = 0;\n\t\t\t\tf2fs_stop_checkpoint(sbi, false,\n\t\t\t\t\t\tSTOP_CP_REASON_SHUTDOWN);\n\t\t\t\ttrace_f2fs_shutdown(sbi, in, ret);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tswitch (in) {\n\tcase F2FS_GOING_DOWN_FULLSYNC:\n\t\tret = freeze_bdev(sb->s_bdev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tf2fs_stop_checkpoint(sbi, false, STOP_CP_REASON_SHUTDOWN);\n\t\tthaw_bdev(sb->s_bdev);\n\t\tbreak;\n\tcase F2FS_GOING_DOWN_METASYNC:\n\t\t \n\t\tret = f2fs_sync_fs(sb, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tf2fs_stop_checkpoint(sbi, false, STOP_CP_REASON_SHUTDOWN);\n\t\tbreak;\n\tcase F2FS_GOING_DOWN_NOSYNC:\n\t\tf2fs_stop_checkpoint(sbi, false, STOP_CP_REASON_SHUTDOWN);\n\t\tbreak;\n\tcase F2FS_GOING_DOWN_METAFLUSH:\n\t\tf2fs_sync_meta_pages(sbi, META, LONG_MAX, FS_META_IO);\n\t\tf2fs_stop_checkpoint(sbi, false, STOP_CP_REASON_SHUTDOWN);\n\t\tbreak;\n\tcase F2FS_GOING_DOWN_NEED_FSCK:\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tset_sbi_flag(sbi, SBI_CP_DISABLED_QUICK);\n\t\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\t\t \n\t\tret = f2fs_sync_fs(sb, 1);\n\t\tgoto out;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_stop_gc_thread(sbi);\n\tf2fs_stop_discard_thread(sbi);\n\n\tf2fs_drop_discard_cmd(sbi);\n\tclear_opt(sbi, DISCARD);\n\n\tf2fs_update_time(sbi, REQ_TIME);\nout:\n\tif (in != F2FS_GOING_DOWN_FULLSYNC)\n\t\tmnt_drop_write_file(filp);\n\n\ttrace_f2fs_shutdown(sbi, in, ret);\n\n\treturn ret;\n}\n\nstatic int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fstrim_range range;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!f2fs_hw_support_discard(F2FS_SB(sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\trange.minlen = max((unsigned int)range.minlen,\n\t\t\t   bdev_discard_granularity(sb->s_bdev));\n\tret = f2fs_trim_fs(F2FS_SB(sb), &range);\n\tmnt_drop_write_file(filp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}\n\nstatic bool uuid_is_nonzero(__u8 u[16])\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (u[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int f2fs_ioc_set_encryption_policy(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(inode)))\n\t\treturn -EOPNOTSUPP;\n\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\n\treturn fscrypt_ioctl_set_policy(filp, (const void __user *)arg);\n}\n\nstatic int f2fs_ioc_get_encryption_policy(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\treturn fscrypt_ioctl_get_policy(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_get_encryption_pwsalt(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tu8 encrypt_pw_salt[16];\n\tint err;\n\n\tif (!f2fs_sb_has_encrypt(sbi))\n\t\treturn -EOPNOTSUPP;\n\n\terr = mnt_want_write_file(filp);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_down_write(&sbi->sb_lock);\n\n\tif (uuid_is_nonzero(sbi->raw_super->encrypt_pw_salt))\n\t\tgoto got_it;\n\n\t \n\tgenerate_random_uuid(sbi->raw_super->encrypt_pw_salt);\n\n\terr = f2fs_commit_super(sbi, false);\n\tif (err) {\n\t\t \n\t\tmemset(sbi->raw_super->encrypt_pw_salt, 0, 16);\n\t\tgoto out_err;\n\t}\ngot_it:\n\tmemcpy(encrypt_pw_salt, sbi->raw_super->encrypt_pw_salt, 16);\nout_err:\n\tf2fs_up_write(&sbi->sb_lock);\n\tmnt_drop_write_file(filp);\n\n\tif (!err && copy_to_user((__u8 __user *)arg, encrypt_pw_salt, 16))\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\nstatic int f2fs_ioc_get_encryption_policy_ex(struct file *filp,\n\t\t\t\t\t     unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_get_policy_ex(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_add_encryption_key(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_add_key(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_remove_encryption_key(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_remove_key(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_remove_encryption_key_all_users(struct file *filp,\n\t\t\t\t\t\t    unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_remove_key_all_users(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_get_encryption_key_status(struct file *filp,\n\t\t\t\t\t      unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_get_key_status(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_get_encryption_nonce(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_encrypt(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fscrypt_ioctl_get_nonce(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_gc(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_gc_control gc_control = { .victim_segno = NULL_SEGNO,\n\t\t\t.no_bg_gc = false,\n\t\t\t.should_migrate_blocks = false,\n\t\t\t.nr_free_secs = 0 };\n\t__u32 sync;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (get_user(sync, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!sync) {\n\t\tif (!f2fs_down_write_trylock(&sbi->gc_lock)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tf2fs_down_write(&sbi->gc_lock);\n\t}\n\n\tgc_control.init_gc_type = sync ? FG_GC : BG_GC;\n\tgc_control.err_gc_skipped = sync;\n\tstat_inc_gc_call_count(sbi, FOREGROUND);\n\tret = f2fs_gc(sbi, &gc_control);\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int __f2fs_ioc_gc_range(struct file *filp, struct f2fs_gc_range *range)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(file_inode(filp));\n\tstruct f2fs_gc_control gc_control = {\n\t\t\t.init_gc_type = range->sync ? FG_GC : BG_GC,\n\t\t\t.no_bg_gc = false,\n\t\t\t.should_migrate_blocks = false,\n\t\t\t.err_gc_skipped = range->sync,\n\t\t\t.nr_free_secs = 0 };\n\tu64 end;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tend = range->start + range->len;\n\tif (end < range->start || range->start < MAIN_BLKADDR(sbi) ||\n\t\t\t\t\tend >= MAX_BLKADDR(sbi))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\ndo_more:\n\tif (!range->sync) {\n\t\tif (!f2fs_down_write_trylock(&sbi->gc_lock)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tf2fs_down_write(&sbi->gc_lock);\n\t}\n\n\tgc_control.victim_segno = GET_SEGNO(sbi, range->start);\n\tstat_inc_gc_call_count(sbi, FOREGROUND);\n\tret = f2fs_gc(sbi, &gc_control);\n\tif (ret) {\n\t\tif (ret == -EBUSY)\n\t\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\trange->start += CAP_BLKS_PER_SEC(sbi);\n\tif (range->start <= end)\n\t\tgoto do_more;\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_gc_range(struct file *filp, unsigned long arg)\n{\n\tstruct f2fs_gc_range range;\n\n\tif (copy_from_user(&range, (struct f2fs_gc_range __user *)arg,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn __f2fs_ioc_gc_range(filp, &range);\n}\n\nstatic int f2fs_ioc_write_checkpoint(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\tf2fs_info(sbi, \"Skipping Checkpoint. Checkpoints currently disabled.\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f2fs_sync_fs(sbi->sb, 1);\n\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_defragment_range(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct file *filp,\n\t\t\t\t\tstruct f2fs_defragment *range)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_map_blocks map = { .m_next_extent = NULL,\n\t\t\t\t\t.m_seg_type = NO_CHECK_TYPE,\n\t\t\t\t\t.m_may_create = false };\n\tstruct extent_info ei = {};\n\tpgoff_t pg_start, pg_end, next_pgofs;\n\tunsigned int blk_per_seg = sbi->blocks_per_seg;\n\tunsigned int total = 0, sec_num;\n\tblock_t blk_end = 0;\n\tbool fragmented = false;\n\tint err;\n\n\tpg_start = range->start >> PAGE_SHIFT;\n\tpg_end = (range->start + range->len) >> PAGE_SHIFT;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tinode_lock(inode);\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\t \n\tset_inode_flag(inode, FI_OPU_WRITE);\n\tif (f2fs_should_update_inplace(inode, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = filemap_write_and_wait_range(inode->i_mapping, range->start,\n\t\t\t\t\t\trange->start + range->len - 1);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (f2fs_lookup_read_extent_cache(inode, pg_start, &ei)) {\n\t\tif (ei.fofs + ei.len >= pg_end)\n\t\t\tgoto out;\n\t}\n\n\tmap.m_lblk = pg_start;\n\tmap.m_next_pgofs = &next_pgofs;\n\n\t \n\twhile (map.m_lblk < pg_end) {\n\t\tmap.m_len = pg_end - map.m_lblk;\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_DEFAULT);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!(map.m_flags & F2FS_MAP_FLAGS)) {\n\t\t\tmap.m_lblk = next_pgofs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (blk_end && blk_end != map.m_pblk)\n\t\t\tfragmented = true;\n\n\t\t \n\t\ttotal += map.m_len;\n\n\t\tblk_end = map.m_pblk + map.m_len;\n\n\t\tmap.m_lblk += map.m_len;\n\t}\n\n\tif (!fragmented) {\n\t\ttotal = 0;\n\t\tgoto out;\n\t}\n\n\tsec_num = DIV_ROUND_UP(total, CAP_BLKS_PER_SEC(sbi));\n\n\t \n\tif (has_not_enough_free_secs(sbi, 0, sec_num)) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmap.m_lblk = pg_start;\n\tmap.m_len = pg_end - pg_start;\n\ttotal = 0;\n\n\twhile (map.m_lblk < pg_end) {\n\t\tpgoff_t idx;\n\t\tint cnt = 0;\n\ndo_map:\n\t\tmap.m_len = pg_end - map.m_lblk;\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_DEFAULT);\n\t\tif (err)\n\t\t\tgoto clear_out;\n\n\t\tif (!(map.m_flags & F2FS_MAP_FLAGS)) {\n\t\t\tmap.m_lblk = next_pgofs;\n\t\t\tgoto check;\n\t\t}\n\n\t\tset_inode_flag(inode, FI_SKIP_WRITES);\n\n\t\tidx = map.m_lblk;\n\t\twhile (idx < map.m_lblk + map.m_len && cnt < blk_per_seg) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = f2fs_get_lock_data_page(inode, idx, true);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tgoto clear_out;\n\t\t\t}\n\n\t\t\tset_page_dirty(page);\n\t\t\tset_page_private_gcing(page);\n\t\t\tf2fs_put_page(page, 1);\n\n\t\t\tidx++;\n\t\t\tcnt++;\n\t\t\ttotal++;\n\t\t}\n\n\t\tmap.m_lblk = idx;\ncheck:\n\t\tif (map.m_lblk < pg_end && cnt < blk_per_seg)\n\t\t\tgoto do_map;\n\n\t\tclear_inode_flag(inode, FI_SKIP_WRITES);\n\n\t\terr = filemap_fdatawrite(inode->i_mapping);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nclear_out:\n\tclear_inode_flag(inode, FI_SKIP_WRITES);\nout:\n\tclear_inode_flag(inode, FI_OPU_WRITE);\nunlock_out:\n\tinode_unlock(inode);\n\tif (!err)\n\t\trange->len = (u64)total << PAGE_SHIFT;\n\treturn err;\n}\n\nstatic int f2fs_ioc_defragment(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_defragment range;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!S_ISREG(inode->i_mode) || f2fs_is_atomic_file(inode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&range, (struct f2fs_defragment __user *)arg,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\t \n\tif (range.start & (F2FS_BLKSIZE - 1) || range.len & (F2FS_BLKSIZE - 1))\n\t\treturn -EINVAL;\n\n\tif (unlikely((range.start + range.len) >> PAGE_SHIFT >\n\t\t\t\t\tmax_file_blocks(inode)))\n\t\treturn -EINVAL;\n\n\terr = mnt_want_write_file(filp);\n\tif (err)\n\t\treturn err;\n\n\terr = f2fs_defragment_range(sbi, filp, &range);\n\tmnt_drop_write_file(filp);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (copy_to_user((struct f2fs_defragment __user *)arg, &range,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int f2fs_move_file_range(struct file *file_in, loff_t pos_in,\n\t\t\tstruct file *file_out, loff_t pos_out, size_t len)\n{\n\tstruct inode *src = file_inode(file_in);\n\tstruct inode *dst = file_inode(file_out);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(src);\n\tsize_t olen = len, dst_max_i_size = 0;\n\tsize_t dst_osize;\n\tint ret;\n\n\tif (file_in->f_path.mnt != file_out->f_path.mnt ||\n\t\t\t\tsrc->i_sb != dst->i_sb)\n\t\treturn -EXDEV;\n\n\tif (unlikely(f2fs_readonly(src->i_sb)))\n\t\treturn -EROFS;\n\n\tif (!S_ISREG(src->i_mode) || !S_ISREG(dst->i_mode))\n\t\treturn -EINVAL;\n\n\tif (IS_ENCRYPTED(src) || IS_ENCRYPTED(dst))\n\t\treturn -EOPNOTSUPP;\n\n\tif (pos_out < 0 || pos_in < 0)\n\t\treturn -EINVAL;\n\n\tif (src == dst) {\n\t\tif (pos_in == pos_out)\n\t\t\treturn 0;\n\t\tif (pos_out > pos_in && pos_out < pos_in + len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tinode_lock(src);\n\tif (src != dst) {\n\t\tret = -EBUSY;\n\t\tif (!inode_trylock(dst))\n\t\t\tgoto out;\n\t}\n\n\tif (f2fs_compressed_file(src) || f2fs_compressed_file(dst)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -EINVAL;\n\tif (pos_in + len > src->i_size || pos_in + len < pos_in)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - pos_in;\n\tif (pos_in + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, F2FS_BLKSIZE) - pos_in;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tdst_osize = dst->i_size;\n\tif (pos_out + olen > dst->i_size)\n\t\tdst_max_i_size = pos_out + olen;\n\n\t \n\tif (!IS_ALIGNED(pos_in, F2FS_BLKSIZE) ||\n\t\t\t!IS_ALIGNED(pos_in + len, F2FS_BLKSIZE) ||\n\t\t\t!IS_ALIGNED(pos_out, F2FS_BLKSIZE))\n\t\tgoto out_unlock;\n\n\tret = f2fs_convert_inline_inode(src);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = f2fs_convert_inline_inode(dst);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = filemap_write_and_wait_range(src->i_mapping,\n\t\t\t\t\tpos_in, pos_in + len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = filemap_write_and_wait_range(dst->i_mapping,\n\t\t\t\t\tpos_out, pos_out + len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_down_write(&F2FS_I(src)->i_gc_rwsem[WRITE]);\n\tif (src != dst) {\n\t\tret = -EBUSY;\n\t\tif (!f2fs_down_write_trylock(&F2FS_I(dst)->i_gc_rwsem[WRITE]))\n\t\t\tgoto out_src;\n\t}\n\n\tf2fs_lock_op(sbi);\n\tret = __exchange_data_block(src, dst, pos_in >> F2FS_BLKSIZE_BITS,\n\t\t\t\tpos_out >> F2FS_BLKSIZE_BITS,\n\t\t\t\tlen >> F2FS_BLKSIZE_BITS, false);\n\n\tif (!ret) {\n\t\tif (dst_max_i_size)\n\t\t\tf2fs_i_size_write(dst, dst_max_i_size);\n\t\telse if (dst_osize != dst->i_size)\n\t\t\tf2fs_i_size_write(dst, dst_osize);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tif (src != dst)\n\t\tf2fs_up_write(&F2FS_I(dst)->i_gc_rwsem[WRITE]);\nout_src:\n\tf2fs_up_write(&F2FS_I(src)->i_gc_rwsem[WRITE]);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tsrc->i_mtime = inode_set_ctime_current(src);\n\tf2fs_mark_inode_dirty_sync(src, false);\n\tif (src != dst) {\n\t\tdst->i_mtime = inode_set_ctime_current(dst);\n\t\tf2fs_mark_inode_dirty_sync(dst, false);\n\t}\n\tf2fs_update_time(sbi, REQ_TIME);\n\nout_unlock:\n\tif (src != dst)\n\t\tinode_unlock(dst);\nout:\n\tinode_unlock(src);\n\treturn ret;\n}\n\nstatic int __f2fs_ioc_move_range(struct file *filp,\n\t\t\t\tstruct f2fs_move_range *range)\n{\n\tstruct fd dst;\n\tint err;\n\n\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t\t!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tdst = fdget(range->dst_fd);\n\tif (!dst.file)\n\t\treturn -EBADF;\n\n\tif (!(dst.file->f_mode & FMODE_WRITE)) {\n\t\terr = -EBADF;\n\t\tgoto err_out;\n\t}\n\n\terr = mnt_want_write_file(filp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = f2fs_move_file_range(filp, range->pos_in, dst.file,\n\t\t\t\t\trange->pos_out, range->len);\n\n\tmnt_drop_write_file(filp);\nerr_out:\n\tfdput(dst);\n\treturn err;\n}\n\nstatic int f2fs_ioc_move_range(struct file *filp, unsigned long arg)\n{\n\tstruct f2fs_move_range range;\n\n\tif (copy_from_user(&range, (struct f2fs_move_range __user *)arg,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\treturn __f2fs_ioc_move_range(filp, &range);\n}\n\nstatic int f2fs_ioc_flush_device(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct sit_info *sm = SIT_I(sbi);\n\tunsigned int start_segno = 0, end_segno = 0;\n\tunsigned int dev_start_segno = 0, dev_end_segno = 0;\n\tstruct f2fs_flush_device range;\n\tstruct f2fs_gc_control gc_control = {\n\t\t\t.init_gc_type = FG_GC,\n\t\t\t.should_migrate_blocks = true,\n\t\t\t.err_gc_skipped = true,\n\t\t\t.nr_free_secs = 0 };\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&range, (struct f2fs_flush_device __user *)arg,\n\t\t\t\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\tif (!f2fs_is_multi_device(sbi) || sbi->s_ndevs - 1 <= range.dev_num ||\n\t\t\t__is_large_section(sbi)) {\n\t\tf2fs_warn(sbi, \"Can't flush %u in %d for segs_per_sec %u != 1\",\n\t\t\t  range.dev_num, sbi->s_ndevs, sbi->segs_per_sec);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (range.dev_num != 0)\n\t\tdev_start_segno = GET_SEGNO(sbi, FDEV(range.dev_num).start_blk);\n\tdev_end_segno = GET_SEGNO(sbi, FDEV(range.dev_num).end_blk);\n\n\tstart_segno = sm->last_victim[FLUSH_DEVICE];\n\tif (start_segno < dev_start_segno || start_segno >= dev_end_segno)\n\t\tstart_segno = dev_start_segno;\n\tend_segno = min(start_segno + range.segments, dev_end_segno);\n\n\twhile (start_segno < end_segno) {\n\t\tif (!f2fs_down_write_trylock(&sbi->gc_lock)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tsm->last_victim[GC_CB] = end_segno + 1;\n\t\tsm->last_victim[GC_GREEDY] = end_segno + 1;\n\t\tsm->last_victim[ALLOC_NEXT] = end_segno + 1;\n\n\t\tgc_control.victim_segno = start_segno;\n\t\tstat_inc_gc_call_count(sbi, FOREGROUND);\n\t\tret = f2fs_gc(sbi, &gc_control);\n\t\tif (ret == -EAGAIN)\n\t\t\tret = 0;\n\t\telse if (ret < 0)\n\t\t\tbreak;\n\t\tstart_segno++;\n\t}\nout:\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_get_features(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 sb_feature = le32_to_cpu(F2FS_I_SB(inode)->raw_super->feature);\n\n\t \n\tsb_feature |= F2FS_FEATURE_ATOMIC_WRITE;\n\n\treturn put_user(sb_feature, (u32 __user *)arg);\n}\n\n#ifdef CONFIG_QUOTA\nint f2fs_transfer_project_quota(struct inode *inode, kprojid_t kprojid)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct super_block *sb = sbi->sb;\n\tint err;\n\n\ttransfer_to[PRJQUOTA] = dqget(sb, make_kqid_projid(kprojid));\n\tif (IS_ERR(transfer_to[PRJQUOTA]))\n\t\treturn PTR_ERR(transfer_to[PRJQUOTA]);\n\n\terr = __dquot_transfer(inode, transfer_to);\n\tif (err)\n\t\tset_sbi_flag(sbi, SBI_QUOTA_NEED_REPAIR);\n\tdqput(transfer_to[PRJQUOTA]);\n\treturn err;\n}\n\nstatic int f2fs_ioc_setproject(struct inode *inode, __u32 projid)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tkprojid_t kprojid;\n\tint err;\n\n\tif (!f2fs_sb_has_project_quota(sbi)) {\n\t\tif (projid != F2FS_DEF_PROJID)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (!f2fs_has_extra_attr(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tkprojid = make_kprojid(&init_user_ns, (projid_t)projid);\n\n\tif (projid_eq(kprojid, fi->i_projid))\n\t\treturn 0;\n\n\terr = -EPERM;\n\t \n\tif (IS_NOQUOTA(inode))\n\t\treturn err;\n\n\tif (!F2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\treturn -EOVERFLOW;\n\n\terr = f2fs_dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_transfer_project_quota(inode, kprojid);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tfi->i_projid = kprojid;\n\tinode_set_ctime_current(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\nout_unlock:\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}\n#else\nint f2fs_transfer_project_quota(struct inode *inode, kprojid_t kprojid)\n{\n\treturn 0;\n}\n\nstatic int f2fs_ioc_setproject(struct inode *inode, __u32 projid)\n{\n\tif (projid != F2FS_DEF_PROJID)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n#endif\n\nint f2fs_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tu32 fsflags = f2fs_iflags_to_fsflags(fi->i_flags);\n\n\tif (IS_ENCRYPTED(inode))\n\t\tfsflags |= FS_ENCRYPT_FL;\n\tif (IS_VERITY(inode))\n\t\tfsflags |= FS_VERITY_FL;\n\tif (f2fs_has_inline_data(inode) || f2fs_has_inline_dentry(inode))\n\t\tfsflags |= FS_INLINE_DATA_FL;\n\tif (is_inode_flag_set(inode, FI_PIN_FILE))\n\t\tfsflags |= FS_NOCOW_FL;\n\n\tfileattr_fill_flags(fa, fsflags & F2FS_GETTABLE_FS_FL);\n\n\tif (f2fs_sb_has_project_quota(F2FS_I_SB(inode)))\n\t\tfa->fsx_projid = from_kprojid(&init_user_ns, fi->i_projid);\n\n\treturn 0;\n}\n\nint f2fs_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tu32 fsflags = fa->flags, mask = F2FS_SETTABLE_FS_FL;\n\tu32 iflags;\n\tint err;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(F2FS_I_SB(inode)))\n\t\treturn -ENOSPC;\n\tif (fsflags & ~F2FS_GETTABLE_FS_FL)\n\t\treturn -EOPNOTSUPP;\n\tfsflags &= F2FS_SETTABLE_FS_FL;\n\tif (!fa->flags_valid)\n\t\tmask &= FS_COMMON_FL;\n\n\tiflags = f2fs_fsflags_to_iflags(fsflags);\n\tif (f2fs_mask_flags(inode->i_mode, iflags) != iflags)\n\t\treturn -EOPNOTSUPP;\n\n\terr = f2fs_setflags_common(inode, iflags, f2fs_fsflags_to_iflags(mask));\n\tif (!err)\n\t\terr = f2fs_ioc_setproject(inode, fa->fsx_projid);\n\n\treturn err;\n}\n\nint f2fs_pin_file_control(struct inode *inode, bool inc)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t \n\tif (inc)\n\t\tf2fs_i_gc_failures_write(inode,\n\t\t\t\tfi->i_gc_failures[GC_FAILURE_PIN] + 1);\n\n\tif (fi->i_gc_failures[GC_FAILURE_PIN] > sbi->gc_pin_file_threshold) {\n\t\tf2fs_warn(sbi, \"%s: Enable GC = ino %lx after %x GC trials\",\n\t\t\t  __func__, inode->i_ino,\n\t\t\t  fi->i_gc_failures[GC_FAILURE_PIN]);\n\t\tclear_inode_flag(inode, FI_PIN_FILE);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int f2fs_ioc_set_pin_file(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\t__u32 pin;\n\tint ret = 0;\n\n\tif (get_user(pin, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tif (!pin) {\n\t\tclear_inode_flag(inode, FI_PIN_FILE);\n\t\tf2fs_i_gc_failures_write(inode, 0);\n\t\tgoto done;\n\t}\n\n\tif (f2fs_should_update_outplace(inode, NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_pin_file_control(inode, false)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!f2fs_disable_compressed_file(inode)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tret = F2FS_I(inode)->i_gc_failures[GC_FAILURE_PIN];\ndone:\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\nout:\n\tinode_unlock(inode);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int f2fs_ioc_get_pin_file(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\t__u32 pin = 0;\n\n\tif (is_inode_flag_set(inode, FI_PIN_FILE))\n\t\tpin = F2FS_I(inode)->i_gc_failures[GC_FAILURE_PIN];\n\treturn put_user(pin, (u32 __user *)arg);\n}\n\nint f2fs_precache_extents(struct inode *inode)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_map_blocks map;\n\tpgoff_t m_next_extent;\n\tloff_t end;\n\tint err;\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tmap.m_lblk = 0;\n\tmap.m_pblk = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = &m_next_extent;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tend = max_file_blocks(inode);\n\n\twhile (map.m_lblk < end) {\n\t\tmap.m_len = end - map.m_lblk;\n\n\t\tf2fs_down_write(&fi->i_gc_rwsem[WRITE]);\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_PRECACHE);\n\t\tf2fs_up_write(&fi->i_gc_rwsem[WRITE]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmap.m_lblk = m_next_extent;\n\t}\n\n\treturn 0;\n}\n\nstatic int f2fs_ioc_precache_extents(struct file *filp)\n{\n\treturn f2fs_precache_extents(file_inode(filp));\n}\n\nstatic int f2fs_ioc_resize_fs(struct file *filp, unsigned long arg)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(file_inode(filp));\n\t__u64 block_count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&block_count, (void __user *)arg,\n\t\t\t   sizeof(block_count)))\n\t\treturn -EFAULT;\n\n\treturn f2fs_resize_fs(filp, block_count);\n}\n\nstatic int f2fs_ioc_enable_verity(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\n\tif (!f2fs_sb_has_verity(F2FS_I_SB(inode))) {\n\t\tf2fs_warn(F2FS_I_SB(inode),\n\t\t\t  \"Can't enable fs-verity on inode %lu: the verity feature is not enabled on this filesystem\",\n\t\t\t  inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn fsverity_ioctl_enable(filp, (const void __user *)arg);\n}\n\nstatic int f2fs_ioc_measure_verity(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_verity(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fsverity_ioctl_measure(filp, (void __user *)arg);\n}\n\nstatic int f2fs_ioc_read_verity_metadata(struct file *filp, unsigned long arg)\n{\n\tif (!f2fs_sb_has_verity(F2FS_I_SB(file_inode(filp))))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fsverity_ioctl_read_metadata(filp, (const void __user *)arg);\n}\n\nstatic int f2fs_ioc_getfslabel(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tchar *vbuf;\n\tint count;\n\tint err = 0;\n\n\tvbuf = f2fs_kzalloc(sbi, MAX_VOLUME_NAME, GFP_KERNEL);\n\tif (!vbuf)\n\t\treturn -ENOMEM;\n\n\tf2fs_down_read(&sbi->sb_lock);\n\tcount = utf16s_to_utf8s(sbi->raw_super->volume_name,\n\t\t\tARRAY_SIZE(sbi->raw_super->volume_name),\n\t\t\tUTF16_LITTLE_ENDIAN, vbuf, MAX_VOLUME_NAME);\n\tf2fs_up_read(&sbi->sb_lock);\n\n\tif (copy_to_user((char __user *)arg, vbuf,\n\t\t\t\tmin(FSLABEL_MAX, count)))\n\t\terr = -EFAULT;\n\n\tkfree(vbuf);\n\treturn err;\n}\n\nstatic int f2fs_ioc_setfslabel(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tchar *vbuf;\n\tint err = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvbuf = strndup_user((const char __user *)arg, FSLABEL_MAX);\n\tif (IS_ERR(vbuf))\n\t\treturn PTR_ERR(vbuf);\n\n\terr = mnt_want_write_file(filp);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_down_write(&sbi->sb_lock);\n\n\tmemset(sbi->raw_super->volume_name, 0,\n\t\t\tsizeof(sbi->raw_super->volume_name));\n\tutf8s_to_utf16s(vbuf, strlen(vbuf), UTF16_LITTLE_ENDIAN,\n\t\t\tsbi->raw_super->volume_name,\n\t\t\tARRAY_SIZE(sbi->raw_super->volume_name));\n\n\terr = f2fs_commit_super(sbi, false);\n\n\tf2fs_up_write(&sbi->sb_lock);\n\n\tmnt_drop_write_file(filp);\nout:\n\tkfree(vbuf);\n\treturn err;\n}\n\nstatic int f2fs_get_compress_blocks(struct inode *inode, __u64 *blocks)\n{\n\tif (!f2fs_sb_has_compression(F2FS_I_SB(inode)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn -EINVAL;\n\n\t*blocks = atomic_read(&F2FS_I(inode)->i_compr_blocks);\n\n\treturn 0;\n}\n\nstatic int f2fs_ioc_get_compress_blocks(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\t__u64 blocks;\n\tint ret;\n\n\tret = f2fs_get_compress_blocks(inode, &blocks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn put_user(blocks, (u64 __user *)arg);\n}\n\nstatic int release_compress_blocks(struct dnode_of_data *dn, pgoff_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tunsigned int released_blocks = 0;\n\tint cluster_size = F2FS_I(dn->inode)->i_cluster_size;\n\tblock_t blkaddr;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tblkaddr = data_blkaddr(dn->inode, dn->node_page,\n\t\t\t\t\t\tdn->ofs_in_node + i);\n\n\t\tif (!__is_valid_data_blkaddr(blkaddr))\n\t\t\tcontinue;\n\t\tif (unlikely(!f2fs_is_valid_blkaddr(sbi, blkaddr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\twhile (count) {\n\t\tint compr_blocks = 0;\n\n\t\tfor (i = 0; i < cluster_size; i++, dn->ofs_in_node++) {\n\t\t\tblkaddr = f2fs_data_blkaddr(dn);\n\n\t\t\tif (i == 0) {\n\t\t\t\tif (blkaddr == COMPRESS_ADDR)\n\t\t\t\t\tcontinue;\n\t\t\t\tdn->ofs_in_node += cluster_size;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (__is_valid_data_blkaddr(blkaddr))\n\t\t\t\tcompr_blocks++;\n\n\t\t\tif (blkaddr != NEW_ADDR)\n\t\t\t\tcontinue;\n\n\t\t\tdn->data_blkaddr = NULL_ADDR;\n\t\t\tf2fs_set_data_blkaddr(dn);\n\t\t}\n\n\t\tf2fs_i_compr_blocks_update(dn->inode, compr_blocks, false);\n\t\tdec_valid_block_count(sbi, dn->inode,\n\t\t\t\t\tcluster_size - compr_blocks);\n\n\t\treleased_blocks += cluster_size - compr_blocks;\nnext:\n\t\tcount -= cluster_size;\n\t}\n\n\treturn released_blocks;\n}\n\nstatic int f2fs_release_compress_blocks(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t page_idx = 0, last_idx;\n\tunsigned int released_blocks = 0;\n\tint ret;\n\tint writecount;\n\n\tif (!f2fs_sb_has_compression(sbi))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tinode_lock(inode);\n\n\twritecount = atomic_read(&inode->i_writecount);\n\tif ((filp->f_mode & FMODE_WRITE && writecount != 1) ||\n\t\t\t(!(filp->f_mode & FMODE_WRITE) && writecount)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, 0, LLONG_MAX);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!atomic_read(&F2FS_I(inode)->i_compr_blocks)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tset_inode_flag(inode, FI_COMPRESS_RELEASED);\n\tinode_set_ctime_current(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\tlast_idx = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\twhile (page_idx < last_idx) {\n\t\tstruct dnode_of_data dn;\n\t\tpgoff_t end_offset, count;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_get_dnode_of_data(&dn, page_idx, LOOKUP_NODE);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tpage_idx = f2fs_get_next_page_offset(&dn,\n\t\t\t\t\t\t\t\tpage_idx);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\t\tcount = min(end_offset - dn.ofs_in_node, last_idx - page_idx);\n\t\tcount = round_up(count, F2FS_I(inode)->i_cluster_size);\n\n\t\tret = release_compress_blocks(&dn, count);\n\n\t\tf2fs_put_dnode(&dn);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tpage_idx += count;\n\t\treleased_blocks += ret;\n\t}\n\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\nout:\n\tinode_unlock(inode);\n\n\tmnt_drop_write_file(filp);\n\n\tif (ret >= 0) {\n\t\tret = put_user(released_blocks, (u64 __user *)arg);\n\t} else if (released_blocks &&\n\t\t\tatomic_read(&F2FS_I(inode)->i_compr_blocks)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, \"%s: partial blocks were released i_ino=%lx \"\n\t\t\t\"iblocks=%llu, released=%u, compr_blocks=%u, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, inode->i_ino, inode->i_blocks,\n\t\t\treleased_blocks,\n\t\t\tatomic_read(&F2FS_I(inode)->i_compr_blocks));\n\t}\n\n\treturn ret;\n}\n\nstatic int reserve_compress_blocks(struct dnode_of_data *dn, pgoff_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tunsigned int reserved_blocks = 0;\n\tint cluster_size = F2FS_I(dn->inode)->i_cluster_size;\n\tblock_t blkaddr;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tblkaddr = data_blkaddr(dn->inode, dn->node_page,\n\t\t\t\t\t\tdn->ofs_in_node + i);\n\n\t\tif (!__is_valid_data_blkaddr(blkaddr))\n\t\t\tcontinue;\n\t\tif (unlikely(!f2fs_is_valid_blkaddr(sbi, blkaddr,\n\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tf2fs_handle_error(sbi, ERROR_INVALID_BLKADDR);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\twhile (count) {\n\t\tint compr_blocks = 0;\n\t\tblkcnt_t reserved;\n\t\tint ret;\n\n\t\tfor (i = 0; i < cluster_size; i++, dn->ofs_in_node++) {\n\t\t\tblkaddr = f2fs_data_blkaddr(dn);\n\n\t\t\tif (i == 0) {\n\t\t\t\tif (blkaddr == COMPRESS_ADDR)\n\t\t\t\t\tcontinue;\n\t\t\t\tdn->ofs_in_node += cluster_size;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (__is_valid_data_blkaddr(blkaddr)) {\n\t\t\t\tcompr_blocks++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdn->data_blkaddr = NEW_ADDR;\n\t\t\tf2fs_set_data_blkaddr(dn);\n\t\t}\n\n\t\treserved = cluster_size - compr_blocks;\n\t\tret = inc_valid_block_count(sbi, dn->inode, &reserved);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reserved != cluster_size - compr_blocks)\n\t\t\treturn -ENOSPC;\n\n\t\tf2fs_i_compr_blocks_update(dn->inode, compr_blocks, true);\n\n\t\treserved_blocks += reserved;\nnext:\n\t\tcount -= cluster_size;\n\t}\n\n\treturn reserved_blocks;\n}\n\nstatic int f2fs_reserve_compress_blocks(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t page_idx = 0, last_idx;\n\tunsigned int reserved_blocks = 0;\n\tint ret;\n\n\tif (!f2fs_sb_has_compression(sbi))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_read(&F2FS_I(inode)->i_compr_blocks))\n\t\tgoto out;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tinode_lock(inode);\n\n\tif (!is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_inode;\n\t}\n\n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\tlast_idx = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\twhile (page_idx < last_idx) {\n\t\tstruct dnode_of_data dn;\n\t\tpgoff_t end_offset, count;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_get_dnode_of_data(&dn, page_idx, LOOKUP_NODE);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tpage_idx = f2fs_get_next_page_offset(&dn,\n\t\t\t\t\t\t\t\tpage_idx);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\t\tcount = min(end_offset - dn.ofs_in_node, last_idx - page_idx);\n\t\tcount = round_up(count, F2FS_I(inode)->i_cluster_size);\n\n\t\tret = reserve_compress_blocks(&dn, count);\n\n\t\tf2fs_put_dnode(&dn);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tpage_idx += count;\n\t\treserved_blocks += ret;\n\t}\n\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\n\tif (ret >= 0) {\n\t\tclear_inode_flag(inode, FI_COMPRESS_RELEASED);\n\t\tinode_set_ctime_current(inode);\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t}\nunlock_inode:\n\tinode_unlock(inode);\nout:\n\tmnt_drop_write_file(filp);\n\n\tif (ret >= 0) {\n\t\tret = put_user(reserved_blocks, (u64 __user *)arg);\n\t} else if (reserved_blocks &&\n\t\t\tatomic_read(&F2FS_I(inode)->i_compr_blocks)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, \"%s: partial blocks were released i_ino=%lx \"\n\t\t\t\"iblocks=%llu, reserved=%u, compr_blocks=%u, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, inode->i_ino, inode->i_blocks,\n\t\t\treserved_blocks,\n\t\t\tatomic_read(&F2FS_I(inode)->i_compr_blocks));\n\t}\n\n\treturn ret;\n}\n\nstatic int f2fs_secure_erase(struct block_device *bdev, struct inode *inode,\n\t\tpgoff_t off, block_t block, block_t len, u32 flags)\n{\n\tsector_t sector = SECTOR_FROM_BLOCK(block);\n\tsector_t nr_sects = SECTOR_FROM_BLOCK(len);\n\tint ret = 0;\n\n\tif (flags & F2FS_TRIM_FILE_DISCARD) {\n\t\tif (bdev_max_secure_erase_sectors(bdev))\n\t\t\tret = blkdev_issue_secure_erase(bdev, sector, nr_sects,\n\t\t\t\t\tGFP_NOFS);\n\t\telse\n\t\t\tret = blkdev_issue_discard(bdev, sector, nr_sects,\n\t\t\t\t\tGFP_NOFS);\n\t}\n\n\tif (!ret && (flags & F2FS_TRIM_FILE_ZEROOUT)) {\n\t\tif (IS_ENCRYPTED(inode))\n\t\t\tret = fscrypt_zeroout_range(inode, off, block, len);\n\t\telse\n\t\t\tret = blkdev_issue_zeroout(bdev, sector, nr_sects,\n\t\t\t\t\tGFP_NOFS, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int f2fs_sec_trim_file(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct block_device *prev_bdev = NULL;\n\tstruct f2fs_sectrim_range range;\n\tpgoff_t index, pg_end, prev_index = 0;\n\tblock_t prev_block = 0, len = 0;\n\tloff_t end_addr;\n\tbool to_end = false;\n\tint ret = 0;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (copy_from_user(&range, (struct f2fs_sectrim_range __user *)arg,\n\t\t\t\tsizeof(range)))\n\t\treturn -EFAULT;\n\n\tif (range.flags == 0 || (range.flags & ~F2FS_TRIM_FILE_MASK) ||\n\t\t\t!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (((range.flags & F2FS_TRIM_FILE_DISCARD) &&\n\t\t\t!f2fs_hw_support_discard(sbi)) ||\n\t\t\t((range.flags & F2FS_TRIM_FILE_ZEROOUT) &&\n\t\t\t IS_ENCRYPTED(inode) && f2fs_is_multi_device(sbi)))\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(filp);\n\tinode_lock(inode);\n\n\tif (f2fs_is_atomic_file(inode) || f2fs_compressed_file(inode) ||\n\t\t\trange.start >= inode->i_size) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (range.len == 0)\n\t\tgoto err;\n\n\tif (inode->i_size - range.start > range.len) {\n\t\tend_addr = range.start + range.len;\n\t} else {\n\t\tend_addr = range.len == (u64)-1 ?\n\t\t\tsbi->sb->s_maxbytes : inode->i_size;\n\t\tto_end = true;\n\t}\n\n\tif (!IS_ALIGNED(range.start, F2FS_BLKSIZE) ||\n\t\t\t(!to_end && !IS_ALIGNED(end_addr, F2FS_BLKSIZE))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tindex = F2FS_BYTES_TO_BLK(range.start);\n\tpg_end = DIV_ROUND_UP(end_addr, F2FS_BLKSIZE);\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\tgoto err;\n\n\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\tfilemap_invalidate_lock(mapping);\n\n\tret = filemap_write_and_wait_range(mapping, range.start,\n\t\t\tto_end ? LLONG_MAX : end_addr - 1);\n\tif (ret)\n\t\tgoto out;\n\n\ttruncate_inode_pages_range(mapping, range.start,\n\t\t\tto_end ? -1 : end_addr - 1);\n\n\twhile (index < pg_end) {\n\t\tstruct dnode_of_data dn;\n\t\tpgoff_t end_offset, count;\n\t\tint i;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\tret = f2fs_get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tindex = f2fs_get_next_page_offset(&dn, index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\t\tcount = min(end_offset - dn.ofs_in_node, pg_end - index);\n\t\tfor (i = 0; i < count; i++, index++, dn.ofs_in_node++) {\n\t\t\tstruct block_device *cur_bdev;\n\t\t\tblock_t blkaddr = f2fs_data_blkaddr(&dn);\n\n\t\t\tif (!__is_valid_data_blkaddr(blkaddr))\n\t\t\t\tcontinue;\n\n\t\t\tif (!f2fs_is_valid_blkaddr(sbi, blkaddr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\t\t\tret = -EFSCORRUPTED;\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\tf2fs_handle_error(sbi,\n\t\t\t\t\t\tERROR_INVALID_BLKADDR);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcur_bdev = f2fs_target_device(sbi, blkaddr, NULL);\n\t\t\tif (f2fs_is_multi_device(sbi)) {\n\t\t\t\tint di = f2fs_target_device_index(sbi, blkaddr);\n\n\t\t\t\tblkaddr -= FDEV(di).start_blk;\n\t\t\t}\n\n\t\t\tif (len) {\n\t\t\t\tif (prev_bdev == cur_bdev &&\n\t\t\t\t\t\tindex == prev_index + len &&\n\t\t\t\t\t\tblkaddr == prev_block + len) {\n\t\t\t\t\tlen++;\n\t\t\t\t} else {\n\t\t\t\t\tret = f2fs_secure_erase(prev_bdev,\n\t\t\t\t\t\tinode, prev_index, prev_block,\n\t\t\t\t\t\tlen, range.flags);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!len) {\n\t\t\t\tprev_bdev = cur_bdev;\n\t\t\t\tprev_index = index;\n\t\t\t\tprev_block = blkaddr;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t}\n\n\t\tf2fs_put_dnode(&dn);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tif (len)\n\t\tret = f2fs_secure_erase(prev_bdev, inode, prev_index,\n\t\t\t\tprev_block, len, range.flags);\nout:\n\tfilemap_invalidate_unlock(mapping);\n\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\nerr:\n\tinode_unlock(inode);\n\tfile_end_write(filp);\n\n\treturn ret;\n}\n\nstatic int f2fs_ioc_get_compress_option(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_comp_option option;\n\n\tif (!f2fs_sb_has_compression(F2FS_I_SB(inode)))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock_shared(inode);\n\n\tif (!f2fs_compressed_file(inode)) {\n\t\tinode_unlock_shared(inode);\n\t\treturn -ENODATA;\n\t}\n\n\toption.algorithm = F2FS_I(inode)->i_compress_algorithm;\n\toption.log_cluster_size = F2FS_I(inode)->i_log_cluster_size;\n\n\tinode_unlock_shared(inode);\n\n\tif (copy_to_user((struct f2fs_comp_option __user *)arg, &option,\n\t\t\t\tsizeof(option)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int f2fs_ioc_set_compress_option(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_comp_option option;\n\tint ret = 0;\n\n\tif (!f2fs_sb_has_compression(sbi))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (copy_from_user(&option, (struct f2fs_comp_option __user *)arg,\n\t\t\t\tsizeof(option)))\n\t\treturn -EFAULT;\n\n\tif (!f2fs_compressed_file(inode) ||\n\t\t\toption.log_cluster_size < MIN_COMPRESS_LOG_SIZE ||\n\t\t\toption.log_cluster_size > MAX_COMPRESS_LOG_SIZE ||\n\t\t\toption.algorithm >= COMPRESS_MAX)\n\t\treturn -EINVAL;\n\n\tfile_start_write(filp);\n\tinode_lock(inode);\n\n\tf2fs_down_write(&F2FS_I(inode)->i_sem);\n\tif (f2fs_is_mmap_file(inode) || get_dirty_pages(inode)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (F2FS_HAS_BLOCKS(inode)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tF2FS_I(inode)->i_compress_algorithm = option.algorithm;\n\tF2FS_I(inode)->i_log_cluster_size = option.log_cluster_size;\n\tF2FS_I(inode)->i_cluster_size = BIT(option.log_cluster_size);\n\t \n\tif (F2FS_I(inode)->i_compress_algorithm == COMPRESS_ZSTD)\n\t\tF2FS_I(inode)->i_compress_level = F2FS_ZSTD_DEFAULT_CLEVEL;\n\telse\n\t\tF2FS_I(inode)->i_compress_level = 0;\n\t \n\tif (option.algorithm == F2FS_OPTION(sbi).compress_algorithm &&\n\t    F2FS_OPTION(sbi).compress_level)\n\t\tF2FS_I(inode)->i_compress_level = F2FS_OPTION(sbi).compress_level;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\tf2fs_warn(sbi, \"compression algorithm is successfully set, \"\n\t\t\t\"but current kernel doesn't support this algorithm.\");\nout:\n\tf2fs_up_write(&F2FS_I(inode)->i_sem);\n\tinode_unlock(inode);\n\tfile_end_write(filp);\n\n\treturn ret;\n}\n\nstatic int redirty_blocks(struct inode *inode, pgoff_t page_idx, int len)\n{\n\tDEFINE_READAHEAD(ractl, NULL, NULL, inode->i_mapping, page_idx);\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t redirty_idx = page_idx;\n\tint i, page_len = 0, ret = 0;\n\n\tpage_cache_ra_unbounded(&ractl, len, 0);\n\n\tfor (i = 0; i < len; i++, page_idx++) {\n\t\tpage = read_cache_page(mapping, page_idx, NULL, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\t\tpage_len++;\n\t}\n\n\tfor (i = 0; i < page_len; i++, redirty_idx++) {\n\t\tpage = find_lock_page(mapping, redirty_idx);\n\n\t\t \n\t\tf2fs_bug_on(F2FS_I_SB(inode), !page);\n\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t\tf2fs_put_page(page, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int f2fs_ioc_decompress_file(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tpgoff_t page_idx = 0, last_idx;\n\tunsigned int blk_per_seg = sbi->blocks_per_seg;\n\tint cluster_size = fi->i_cluster_size;\n\tint count, ret;\n\n\tif (!f2fs_sb_has_compression(sbi) ||\n\t\t\tF2FS_OPTION(sbi).compress_mode != COMPR_MODE_USER)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn -EINVAL;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tfile_start_write(filp);\n\tinode_lock(inode);\n\n\tif (!f2fs_is_compress_backend_ready(inode)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, 0, LLONG_MAX);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!atomic_read(&fi->i_compr_blocks))\n\t\tgoto out;\n\n\tlast_idx = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\tcount = last_idx - page_idx;\n\twhile (count && count >= cluster_size) {\n\t\tret = redirty_blocks(inode, page_idx, cluster_size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (get_dirty_pages(inode) >= blk_per_seg) {\n\t\t\tret = filemap_fdatawrite(inode->i_mapping);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcount -= cluster_size;\n\t\tpage_idx += cluster_size;\n\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, 0,\n\t\t\t\t\t\t\tLLONG_MAX);\n\n\tif (ret)\n\t\tf2fs_warn(sbi, \"%s: The file might be partially decompressed (errno=%d). Please delete the file.\",\n\t\t\t  __func__, ret);\nout:\n\tinode_unlock(inode);\n\tfile_end_write(filp);\n\n\treturn ret;\n}\n\nstatic int f2fs_ioc_compress_file(struct file *filp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tpgoff_t page_idx = 0, last_idx;\n\tunsigned int blk_per_seg = sbi->blocks_per_seg;\n\tint cluster_size = F2FS_I(inode)->i_cluster_size;\n\tint count, ret;\n\n\tif (!f2fs_sb_has_compression(sbi) ||\n\t\t\tF2FS_OPTION(sbi).compress_mode != COMPR_MODE_USER)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!f2fs_compressed_file(inode))\n\t\treturn -EINVAL;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tfile_start_write(filp);\n\tinode_lock(inode);\n\n\tif (!f2fs_is_compress_backend_ready(inode)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, 0, LLONG_MAX);\n\tif (ret)\n\t\tgoto out;\n\n\tset_inode_flag(inode, FI_ENABLE_COMPRESS);\n\n\tlast_idx = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\tcount = last_idx - page_idx;\n\twhile (count && count >= cluster_size) {\n\t\tret = redirty_blocks(inode, page_idx, cluster_size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (get_dirty_pages(inode) >= blk_per_seg) {\n\t\t\tret = filemap_fdatawrite(inode->i_mapping);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcount -= cluster_size;\n\t\tpage_idx += cluster_size;\n\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, 0,\n\t\t\t\t\t\t\tLLONG_MAX);\n\n\tclear_inode_flag(inode, FI_ENABLE_COMPRESS);\n\n\tif (ret)\n\t\tf2fs_warn(sbi, \"%s: The file might be partially compressed (errno=%d). Please delete the file.\",\n\t\t\t  __func__, ret);\nout:\n\tinode_unlock(inode);\n\tfile_end_write(filp);\n\n\treturn ret;\n}\n\nstatic long __f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC_GETVERSION:\n\t\treturn f2fs_ioc_getversion(filp, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_start_atomic_write(filp, false);\n\tcase F2FS_IOC_START_ATOMIC_REPLACE:\n\t\treturn f2fs_ioc_start_atomic_write(filp, true);\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_commit_atomic_write(filp);\n\tcase F2FS_IOC_ABORT_ATOMIC_WRITE:\n\t\treturn f2fs_ioc_abort_atomic_write(filp);\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\t\treturn -EOPNOTSUPP;\n\tcase F2FS_IOC_SHUTDOWN:\n\t\treturn f2fs_ioc_shutdown(filp, arg);\n\tcase FITRIM:\n\t\treturn f2fs_ioc_fitrim(filp, arg);\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\t\treturn f2fs_ioc_set_encryption_policy(filp, arg);\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\t\treturn f2fs_ioc_get_encryption_policy(filp, arg);\n\tcase FS_IOC_GET_ENCRYPTION_PWSALT:\n\t\treturn f2fs_ioc_get_encryption_pwsalt(filp, arg);\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\t\treturn f2fs_ioc_get_encryption_policy_ex(filp, arg);\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\t\treturn f2fs_ioc_add_encryption_key(filp, arg);\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\t\treturn f2fs_ioc_remove_encryption_key(filp, arg);\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\t\treturn f2fs_ioc_remove_encryption_key_all_users(filp, arg);\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\t\treturn f2fs_ioc_get_encryption_key_status(filp, arg);\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\treturn f2fs_ioc_get_encryption_nonce(filp, arg);\n\tcase F2FS_IOC_GARBAGE_COLLECT:\n\t\treturn f2fs_ioc_gc(filp, arg);\n\tcase F2FS_IOC_GARBAGE_COLLECT_RANGE:\n\t\treturn f2fs_ioc_gc_range(filp, arg);\n\tcase F2FS_IOC_WRITE_CHECKPOINT:\n\t\treturn f2fs_ioc_write_checkpoint(filp);\n\tcase F2FS_IOC_DEFRAGMENT:\n\t\treturn f2fs_ioc_defragment(filp, arg);\n\tcase F2FS_IOC_MOVE_RANGE:\n\t\treturn f2fs_ioc_move_range(filp, arg);\n\tcase F2FS_IOC_FLUSH_DEVICE:\n\t\treturn f2fs_ioc_flush_device(filp, arg);\n\tcase F2FS_IOC_GET_FEATURES:\n\t\treturn f2fs_ioc_get_features(filp, arg);\n\tcase F2FS_IOC_GET_PIN_FILE:\n\t\treturn f2fs_ioc_get_pin_file(filp, arg);\n\tcase F2FS_IOC_SET_PIN_FILE:\n\t\treturn f2fs_ioc_set_pin_file(filp, arg);\n\tcase F2FS_IOC_PRECACHE_EXTENTS:\n\t\treturn f2fs_ioc_precache_extents(filp);\n\tcase F2FS_IOC_RESIZE_FS:\n\t\treturn f2fs_ioc_resize_fs(filp, arg);\n\tcase FS_IOC_ENABLE_VERITY:\n\t\treturn f2fs_ioc_enable_verity(filp, arg);\n\tcase FS_IOC_MEASURE_VERITY:\n\t\treturn f2fs_ioc_measure_verity(filp, arg);\n\tcase FS_IOC_READ_VERITY_METADATA:\n\t\treturn f2fs_ioc_read_verity_metadata(filp, arg);\n\tcase FS_IOC_GETFSLABEL:\n\t\treturn f2fs_ioc_getfslabel(filp, arg);\n\tcase FS_IOC_SETFSLABEL:\n\t\treturn f2fs_ioc_setfslabel(filp, arg);\n\tcase F2FS_IOC_GET_COMPRESS_BLOCKS:\n\t\treturn f2fs_ioc_get_compress_blocks(filp, arg);\n\tcase F2FS_IOC_RELEASE_COMPRESS_BLOCKS:\n\t\treturn f2fs_release_compress_blocks(filp, arg);\n\tcase F2FS_IOC_RESERVE_COMPRESS_BLOCKS:\n\t\treturn f2fs_reserve_compress_blocks(filp, arg);\n\tcase F2FS_IOC_SEC_TRIM_FILE:\n\t\treturn f2fs_sec_trim_file(filp, arg);\n\tcase F2FS_IOC_GET_COMPRESS_OPTION:\n\t\treturn f2fs_ioc_get_compress_option(filp, arg);\n\tcase F2FS_IOC_SET_COMPRESS_OPTION:\n\t\treturn f2fs_ioc_set_compress_option(filp, arg);\n\tcase F2FS_IOC_DECOMPRESS_FILE:\n\t\treturn f2fs_ioc_decompress_file(filp);\n\tcase F2FS_IOC_COMPRESS_FILE:\n\t\treturn f2fs_ioc_compress_file(filp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nlong f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(file_inode(filp)))))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(F2FS_I_SB(file_inode(filp))))\n\t\treturn -ENOSPC;\n\n\treturn __f2fs_ioctl(filp, cmd, arg);\n}\n\n \nstatic bool f2fs_should_use_dio(struct inode *inode, struct kiocb *iocb,\n\t\t\t\tstruct iov_iter *iter)\n{\n\tunsigned int align;\n\n\tif (!(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn false;\n\n\tif (f2fs_force_buffered_io(inode, iov_iter_rw(iter)))\n\t\treturn false;\n\n\t \n\talign = iocb->ki_pos | iov_iter_alignment(iter);\n\tif (!IS_ALIGNED(align, i_blocksize(inode)) &&\n\t    IS_ALIGNED(align, bdev_logical_block_size(inode->i_sb->s_bdev)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int f2fs_dio_read_end_io(struct kiocb *iocb, ssize_t size, int error,\n\t\t\t\tunsigned int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(file_inode(iocb->ki_filp));\n\n\tdec_page_count(sbi, F2FS_DIO_READ);\n\tif (error)\n\t\treturn error;\n\tf2fs_update_iostat(sbi, NULL, APP_DIRECT_READ_IO, size);\n\treturn 0;\n}\n\nstatic const struct iomap_dio_ops f2fs_iomap_dio_read_ops = {\n\t.end_io = f2fs_dio_read_end_io,\n};\n\nstatic ssize_t f2fs_dio_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tconst loff_t pos = iocb->ki_pos;\n\tconst size_t count = iov_iter_count(to);\n\tstruct iomap_dio *dio;\n\tssize_t ret;\n\n\tif (count == 0)\n\t\treturn 0;  \n\n\ttrace_f2fs_direct_IO_enter(inode, iocb, count, READ);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!f2fs_down_read_trylock(&fi->i_gc_rwsem[READ])) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tf2fs_down_read(&fi->i_gc_rwsem[READ]);\n\t}\n\n\t \n\tinc_page_count(sbi, F2FS_DIO_READ);\n\tdio = __iomap_dio_rw(iocb, to, &f2fs_iomap_ops,\n\t\t\t     &f2fs_iomap_dio_read_ops, 0, NULL, 0);\n\tif (IS_ERR_OR_NULL(dio)) {\n\t\tret = PTR_ERR_OR_ZERO(dio);\n\t\tif (ret != -EIOCBQUEUED)\n\t\t\tdec_page_count(sbi, F2FS_DIO_READ);\n\t} else {\n\t\tret = iomap_dio_complete(dio);\n\t}\n\n\tf2fs_up_read(&fi->i_gc_rwsem[READ]);\n\n\tfile_accessed(file);\nout:\n\ttrace_f2fs_direct_IO_exit(inode, pos, count, READ, ret);\n\treturn ret;\n}\n\nstatic void f2fs_trace_rw_file_path(struct file *file, loff_t pos, size_t count,\n\t\t\t\t    int rw)\n{\n\tstruct inode *inode = file_inode(file);\n\tchar *buf, *path;\n\n\tbuf = f2fs_getname(F2FS_I_SB(inode));\n\tif (!buf)\n\t\treturn;\n\tpath = dentry_path_raw(file_dentry(file), buf, PATH_MAX);\n\tif (IS_ERR(path))\n\t\tgoto free_buf;\n\tif (rw == WRITE)\n\t\ttrace_f2fs_datawrite_start(inode, pos, count,\n\t\t\t\tcurrent->pid, path, current->comm);\n\telse\n\t\ttrace_f2fs_dataread_start(inode, pos, count,\n\t\t\t\tcurrent->pid, path, current->comm);\nfree_buf:\n\tf2fs_putname(buf);\n}\n\nstatic ssize_t f2fs_file_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tconst loff_t pos = iocb->ki_pos;\n\tssize_t ret;\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (trace_f2fs_dataread_start_enabled())\n\t\tf2fs_trace_rw_file_path(iocb->ki_filp, iocb->ki_pos,\n\t\t\t\t\tiov_iter_count(to), READ);\n\n\tif (f2fs_should_use_dio(inode, iocb, to)) {\n\t\tret = f2fs_dio_read_iter(iocb, to);\n\t} else {\n\t\tret = filemap_read(iocb, to, 0);\n\t\tif (ret > 0)\n\t\t\tf2fs_update_iostat(F2FS_I_SB(inode), inode,\n\t\t\t\t\t\tAPP_BUFFERED_READ_IO, ret);\n\t}\n\tif (trace_f2fs_dataread_end_enabled())\n\t\ttrace_f2fs_dataread_end(inode, pos, ret);\n\treturn ret;\n}\n\nstatic ssize_t f2fs_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t     struct pipe_inode_info *pipe,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(in);\n\tconst loff_t pos = *ppos;\n\tssize_t ret;\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (trace_f2fs_dataread_start_enabled())\n\t\tf2fs_trace_rw_file_path(in, pos, len, READ);\n\n\tret = filemap_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0)\n\t\tf2fs_update_iostat(F2FS_I_SB(inode), inode,\n\t\t\t\t   APP_BUFFERED_READ_IO, ret);\n\n\tif (trace_f2fs_dataread_end_enabled())\n\t\ttrace_f2fs_dataread_end(inode, pos, ret);\n\treturn ret;\n}\n\nstatic ssize_t f2fs_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t count;\n\tint err;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED))\n\t\treturn -EPERM;\n\n\tcount = generic_write_checks(iocb, from);\n\tif (count <= 0)\n\t\treturn count;\n\n\terr = file_modified(file);\n\tif (err)\n\t\treturn err;\n\treturn count;\n}\n\n \nstatic int f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\t   bool dio)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tconst loff_t pos = iocb->ki_pos;\n\tconst size_t count = iov_iter_count(iter);\n\tstruct f2fs_map_blocks map = {};\n\tint flag;\n\tint ret;\n\n\t \n\tif (dio && f2fs_lfs_mode(sbi))\n\t\treturn 0;\n\t \n\tif (dio && i_size_read(inode) &&\n\t\t(F2FS_BYTES_TO_BLK(pos) < F2FS_BLK_ALIGN(i_size_read(inode))))\n\t\treturn 0;\n\n\t \n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\treturn 0;\n\n\t \n\tif (fault_in_iov_iter_readable(iter, count))\n\t\treturn 0;\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\t \n\t\tif (pos + count <= MAX_INLINE_DATA(inode))\n\t\t\treturn 0;\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmap.m_lblk = F2FS_BLK_ALIGN(pos);\n\tmap.m_len = F2FS_BYTES_TO_BLK(pos + count);\n\tif (map.m_len > map.m_lblk)\n\t\tmap.m_len -= map.m_lblk;\n\telse\n\t\tmap.m_len = 0;\n\tmap.m_may_create = true;\n\tif (dio) {\n\t\tmap.m_seg_type = f2fs_rw_hint_to_seg_type(inode->i_write_hint);\n\t\tflag = F2FS_GET_BLOCK_PRE_DIO;\n\t} else {\n\t\tmap.m_seg_type = NO_CHECK_TYPE;\n\t\tflag = F2FS_GET_BLOCK_PRE_AIO;\n\t}\n\n\tret = f2fs_map_blocks(inode, &map, flag);\n\t \n\tif (ret < 0 && !((ret == -ENOSPC || ret == -EDQUOT) && map.m_len > 0))\n\t\treturn ret;\n\tif (ret == 0)\n\t\tset_inode_flag(inode, FI_PREALLOCATED_ALL);\n\treturn map.m_len;\n}\n\nstatic ssize_t f2fs_buffered_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t ret;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tret = generic_perform_write(iocb, from);\n\n\tif (ret > 0) {\n\t\tf2fs_update_iostat(F2FS_I_SB(inode), inode,\n\t\t\t\t\t\tAPP_BUFFERED_IO, ret);\n\t}\n\treturn ret;\n}\n\nstatic int f2fs_dio_write_end_io(struct kiocb *iocb, ssize_t size, int error,\n\t\t\t\t unsigned int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(file_inode(iocb->ki_filp));\n\n\tdec_page_count(sbi, F2FS_DIO_WRITE);\n\tif (error)\n\t\treturn error;\n\tf2fs_update_time(sbi, REQ_TIME);\n\tf2fs_update_iostat(sbi, NULL, APP_DIRECT_IO, size);\n\treturn 0;\n}\n\nstatic const struct iomap_dio_ops f2fs_iomap_dio_write_ops = {\n\t.end_io = f2fs_dio_write_end_io,\n};\n\nstatic void f2fs_flush_buffered_write(struct address_space *mapping,\n\t\t\t\t      loff_t start_pos, loff_t end_pos)\n{\n\tint ret;\n\n\tret = filemap_write_and_wait_range(mapping, start_pos, end_pos);\n\tif (ret < 0)\n\t\treturn;\n\tinvalidate_mapping_pages(mapping,\n\t\t\t\t start_pos >> PAGE_SHIFT,\n\t\t\t\t end_pos >> PAGE_SHIFT);\n}\n\nstatic ssize_t f2fs_dio_write_iter(struct kiocb *iocb, struct iov_iter *from,\n\t\t\t\t   bool *may_need_sync)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tconst bool do_opu = f2fs_lfs_mode(sbi);\n\tconst loff_t pos = iocb->ki_pos;\n\tconst ssize_t count = iov_iter_count(from);\n\tunsigned int dio_flags;\n\tstruct iomap_dio *dio;\n\tssize_t ret;\n\n\ttrace_f2fs_direct_IO_enter(inode, iocb, count, WRITE);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t \n\t\tif (f2fs_has_inline_data(inode) ||\n\t\t    !f2fs_overwrite_io(inode, pos, count)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!f2fs_down_read_trylock(&fi->i_gc_rwsem[WRITE])) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (do_opu && !f2fs_down_read_trylock(&fi->i_gc_rwsem[READ])) {\n\t\t\tf2fs_up_read(&fi->i_gc_rwsem[WRITE]);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = f2fs_convert_inline_inode(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tf2fs_down_read(&fi->i_gc_rwsem[WRITE]);\n\t\tif (do_opu)\n\t\t\tf2fs_down_read(&fi->i_gc_rwsem[READ]);\n\t}\n\n\t \n\tinc_page_count(sbi, F2FS_DIO_WRITE);\n\tdio_flags = 0;\n\tif (pos + count > inode->i_size)\n\t\tdio_flags |= IOMAP_DIO_FORCE_WAIT;\n\tdio = __iomap_dio_rw(iocb, from, &f2fs_iomap_ops,\n\t\t\t     &f2fs_iomap_dio_write_ops, dio_flags, NULL, 0);\n\tif (IS_ERR_OR_NULL(dio)) {\n\t\tret = PTR_ERR_OR_ZERO(dio);\n\t\tif (ret == -ENOTBLK)\n\t\t\tret = 0;\n\t\tif (ret != -EIOCBQUEUED)\n\t\t\tdec_page_count(sbi, F2FS_DIO_WRITE);\n\t} else {\n\t\tret = iomap_dio_complete(dio);\n\t}\n\n\tif (do_opu)\n\t\tf2fs_up_read(&fi->i_gc_rwsem[READ]);\n\tf2fs_up_read(&fi->i_gc_rwsem[WRITE]);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (pos + ret > inode->i_size)\n\t\tf2fs_i_size_write(inode, pos + ret);\n\tif (!do_opu)\n\t\tset_inode_flag(inode, FI_UPDATE_WRITE);\n\n\tif (iov_iter_count(from)) {\n\t\tssize_t ret2;\n\t\tloff_t bufio_start_pos = iocb->ki_pos;\n\n\t\t \n\n\t\tret2 = f2fs_buffered_write_iter(iocb, from);\n\t\tif (iov_iter_count(from))\n\t\t\tf2fs_write_failed(inode, iocb->ki_pos);\n\t\tif (ret2 < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (ret2 > 0) {\n\t\t\tloff_t bufio_end_pos = bufio_start_pos + ret2 - 1;\n\n\t\t\tret += ret2;\n\n\t\t\tf2fs_flush_buffered_write(file->f_mapping,\n\t\t\t\t\t\t  bufio_start_pos,\n\t\t\t\t\t\t  bufio_end_pos);\n\t\t}\n\t} else {\n\t\t \n\t\t*may_need_sync = false;\n\t}\nout:\n\ttrace_f2fs_direct_IO_exit(inode, pos, count, WRITE, ret);\n\treturn ret;\n}\n\nstatic ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tconst loff_t orig_pos = iocb->ki_pos;\n\tconst size_t orig_count = iov_iter_count(from);\n\tloff_t target_size;\n\tbool dio;\n\tbool may_need_sync = true;\n\tint preallocated;\n\tssize_t ret;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode)))) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!f2fs_is_compress_backend_ready(inode)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (!inode_trylock(inode)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tinode_lock(inode);\n\t}\n\n\tret = f2fs_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out_unlock;\n\n\t \n\tdio = f2fs_should_use_dio(inode, iocb, from);\n\n\t \n\ttarget_size = iocb->ki_pos + iov_iter_count(from);\n\tpreallocated = f2fs_preallocate_blocks(iocb, from, dio);\n\tif (preallocated < 0) {\n\t\tret = preallocated;\n\t} else {\n\t\tif (trace_f2fs_datawrite_start_enabled())\n\t\t\tf2fs_trace_rw_file_path(iocb->ki_filp, iocb->ki_pos,\n\t\t\t\t\t\torig_count, WRITE);\n\n\t\t \n\t\tret = dio ?\n\t\t\tf2fs_dio_write_iter(iocb, from, &may_need_sync) :\n\t\t\tf2fs_buffered_write_iter(iocb, from);\n\n\t\tif (trace_f2fs_datawrite_end_enabled())\n\t\t\ttrace_f2fs_datawrite_end(inode, orig_pos, ret);\n\t}\n\n\t \n\tif (preallocated && i_size_read(inode) < target_size) {\n\t\tf2fs_down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t\tfilemap_invalidate_lock(inode->i_mapping);\n\t\tif (!f2fs_truncate(inode))\n\t\t\tfile_dont_truncate(inode);\n\t\tfilemap_invalidate_unlock(inode->i_mapping);\n\t\tf2fs_up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);\n\t} else {\n\t\tfile_dont_truncate(inode);\n\t}\n\n\tclear_inode_flag(inode, FI_PREALLOCATED_ALL);\nout_unlock:\n\tinode_unlock(inode);\nout:\n\ttrace_f2fs_file_write_iter(inode, orig_pos, orig_count, ret);\n\n\tif (ret > 0 && may_need_sync)\n\t\tret = generic_write_sync(iocb, ret);\n\n\t \n\tif (ret > 0 && !dio && (iocb->ki_flags & IOCB_DIRECT))\n\t\tf2fs_flush_buffered_write(iocb->ki_filp->f_mapping,\n\t\t\t\t\t  orig_pos,\n\t\t\t\t\t  orig_pos + ret - 1);\n\n\treturn ret;\n}\n\nstatic int f2fs_file_fadvise(struct file *filp, loff_t offset, loff_t len,\n\t\tint advice)\n{\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tstruct inode *inode = file_inode(filp);\n\tint err;\n\n\tif (advice == POSIX_FADV_SEQUENTIAL) {\n\t\tif (S_ISFIFO(inode->i_mode))\n\t\t\treturn -ESPIPE;\n\n\t\tmapping = filp->f_mapping;\n\t\tif (!mapping || len < 0)\n\t\t\treturn -EINVAL;\n\n\t\tbdi = inode_to_bdi(mapping->host);\n\t\tfilp->f_ra.ra_pages = bdi->ra_pages *\n\t\t\tF2FS_I_SB(inode)->seq_file_ra_mul;\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t\treturn 0;\n\t}\n\n\terr = generic_fadvise(filp, offset, len, advice);\n\tif (!err && advice == POSIX_FADV_DONTNEED &&\n\t\ttest_opt(F2FS_I_SB(inode), COMPRESS_CACHE) &&\n\t\tf2fs_compressed_file(inode))\n\t\tf2fs_invalidate_compress_pages(F2FS_I_SB(inode), inode->i_ino);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_f2fs_gc_range {\n\tu32 sync;\n\tcompat_u64 start;\n\tcompat_u64 len;\n};\n#define F2FS_IOC32_GARBAGE_COLLECT_RANGE\t_IOW(F2FS_IOCTL_MAGIC, 11,\\\n\t\t\t\t\t\tstruct compat_f2fs_gc_range)\n\nstatic int f2fs_compat_ioc_gc_range(struct file *file, unsigned long arg)\n{\n\tstruct compat_f2fs_gc_range __user *urange;\n\tstruct f2fs_gc_range range;\n\tint err;\n\n\turange = compat_ptr(arg);\n\terr = get_user(range.sync, &urange->sync);\n\terr |= get_user(range.start, &urange->start);\n\terr |= get_user(range.len, &urange->len);\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn __f2fs_ioc_gc_range(file, &range);\n}\n\nstruct compat_f2fs_move_range {\n\tu32 dst_fd;\n\tcompat_u64 pos_in;\n\tcompat_u64 pos_out;\n\tcompat_u64 len;\n};\n#define F2FS_IOC32_MOVE_RANGE\t\t_IOWR(F2FS_IOCTL_MAGIC, 9,\t\\\n\t\t\t\t\tstruct compat_f2fs_move_range)\n\nstatic int f2fs_compat_ioc_move_range(struct file *file, unsigned long arg)\n{\n\tstruct compat_f2fs_move_range __user *urange;\n\tstruct f2fs_move_range range;\n\tint err;\n\n\turange = compat_ptr(arg);\n\terr = get_user(range.dst_fd, &urange->dst_fd);\n\terr |= get_user(range.pos_in, &urange->pos_in);\n\terr |= get_user(range.pos_out, &urange->pos_out);\n\terr |= get_user(range.len, &urange->len);\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn __f2fs_ioc_move_range(file, &range);\n}\n\nlong f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(file_inode(file)))))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(F2FS_I_SB(file_inode(file))))\n\t\treturn -ENOSPC;\n\n\tswitch (cmd) {\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\tcase F2FS_IOC32_GARBAGE_COLLECT_RANGE:\n\t\treturn f2fs_compat_ioc_gc_range(file, arg);\n\tcase F2FS_IOC32_MOVE_RANGE:\n\t\treturn f2fs_compat_ioc_move_range(file, arg);\n\tcase F2FS_IOC_START_ATOMIC_WRITE:\n\tcase F2FS_IOC_START_ATOMIC_REPLACE:\n\tcase F2FS_IOC_COMMIT_ATOMIC_WRITE:\n\tcase F2FS_IOC_START_VOLATILE_WRITE:\n\tcase F2FS_IOC_RELEASE_VOLATILE_WRITE:\n\tcase F2FS_IOC_ABORT_ATOMIC_WRITE:\n\tcase F2FS_IOC_SHUTDOWN:\n\tcase FITRIM:\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_PWSALT:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\tcase F2FS_IOC_GARBAGE_COLLECT:\n\tcase F2FS_IOC_WRITE_CHECKPOINT:\n\tcase F2FS_IOC_DEFRAGMENT:\n\tcase F2FS_IOC_FLUSH_DEVICE:\n\tcase F2FS_IOC_GET_FEATURES:\n\tcase F2FS_IOC_GET_PIN_FILE:\n\tcase F2FS_IOC_SET_PIN_FILE:\n\tcase F2FS_IOC_PRECACHE_EXTENTS:\n\tcase F2FS_IOC_RESIZE_FS:\n\tcase FS_IOC_ENABLE_VERITY:\n\tcase FS_IOC_MEASURE_VERITY:\n\tcase FS_IOC_READ_VERITY_METADATA:\n\tcase FS_IOC_GETFSLABEL:\n\tcase FS_IOC_SETFSLABEL:\n\tcase F2FS_IOC_GET_COMPRESS_BLOCKS:\n\tcase F2FS_IOC_RELEASE_COMPRESS_BLOCKS:\n\tcase F2FS_IOC_RESERVE_COMPRESS_BLOCKS:\n\tcase F2FS_IOC_SEC_TRIM_FILE:\n\tcase F2FS_IOC_GET_COMPRESS_OPTION:\n\tcase F2FS_IOC_SET_COMPRESS_OPTION:\n\tcase F2FS_IOC_DECOMPRESS_FILE:\n\tcase F2FS_IOC_COMPRESS_FILE:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn __f2fs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}\n#endif\n\nconst struct file_operations f2fs_file_operations = {\n\t.llseek\t\t= f2fs_llseek,\n\t.read_iter\t= f2fs_file_read_iter,\n\t.write_iter\t= f2fs_file_write_iter,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.open\t\t= f2fs_file_open,\n\t.release\t= f2fs_release_file,\n\t.mmap\t\t= f2fs_file_mmap,\n\t.flush\t\t= f2fs_file_flush,\n\t.fsync\t\t= f2fs_sync_file,\n\t.fallocate\t= f2fs_fallocate,\n\t.unlocked_ioctl\t= f2fs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= f2fs_compat_ioctl,\n#endif\n\t.splice_read\t= f2fs_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fadvise\t= f2fs_file_fadvise,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}