{
  "module_name": "init.c",
  "hash_id": "bdeb8deda860a22b019a578e9debb1c5347048611aa0b865ae815b4eb0c61c93",
  "original_prompt": "Ingested from linux-6.6.14/fs/init.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/file.h>\n#include <linux/init_syscalls.h>\n#include <linux/security.h>\n#include \"internal.h\"\n\nint __init init_mount(const char *dev_name, const char *dir_name,\n\t\tconst char *type_page, unsigned long flags, void *data_page)\n{\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(dir_name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ret;\n\tret = path_mount(dev_name, &path, type_page, flags, data_page);\n\tpath_put(&path);\n\treturn ret;\n}\n\nint __init init_umount(const char *name, int flags)\n{\n\tint lookup_flags = LOOKUP_MOUNTPOINT;\n\tstruct path path;\n\tint ret;\n\n\tif (!(flags & UMOUNT_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\tret = kern_path(name, lookup_flags, &path);\n\tif (ret)\n\t\treturn ret;\n\treturn path_umount(&path, flags);\n}\n\nint __init init_chdir(const char *filename)\n{\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (error)\n\t\treturn error;\n\terror = path_permission(&path, MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &path);\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_chroot(const char *filename)\n{\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (error)\n\t\treturn error;\n\terror = path_permission(&path, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\tset_fs_root(current->fs, &path);\ndput_and_out:\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_chown(const char *filename, uid_t user, gid_t group, int flags)\n{\n\tint lookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = chown_common(&path, user, group);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_chmod(const char *filename, umode_t mode)\n{\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn error;\n\terror = chmod_common(&path, mode);\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_eaccess(const char *filename)\n{\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn error;\n\terror = path_permission(&path, MAY_ACCESS);\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_stat(const char *filename, struct kstat *stat, int flags)\n{\n\tint lookup_flags = (flags & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = vfs_getattr(&path, stat, STATX_BASIC_STATS,\n\t\t\t    flags | AT_NO_AUTOMOUNT);\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_mknod(const char *filename, umode_t mode, unsigned int dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\n\tif (S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tdev = 0;\n\telse if (!(S_ISBLK(mode) || S_ISCHR(mode)))\n\t\treturn -EINVAL;\n\n\tdentry = kern_path_create(AT_FDCWD, filename, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (!error)\n\t\terror = vfs_mknod(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t  dentry, mode, new_decode_dev(dev));\n\tdone_path_create(&path, dentry);\n\treturn error;\n}\n\nint __init init_link(const char *oldname, const char *newname)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct mnt_idmap *idmap;\n\tint error;\n\n\terror = kern_path(oldname, 0, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = kern_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\tidmap = mnt_idmap(new_path.mnt);\n\terror = may_linkat(idmap, &old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,\n\t\t\t new_dentry, NULL);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\treturn error;\n}\n\nint __init init_symlink(const char *oldname, const char *newname)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\n\tdentry = kern_path_create(AT_FDCWD, newname, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\terror = security_path_symlink(&path, dentry, oldname);\n\tif (!error)\n\t\terror = vfs_symlink(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t    dentry, oldname);\n\tdone_path_create(&path, dentry);\n\treturn error;\n}\n\nint __init init_unlink(const char *pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, getname_kernel(pathname));\n}\n\nint __init init_mkdir(const char *pathname, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\n\tdentry = kern_path_create(AT_FDCWD, pathname, &path, LOOKUP_DIRECTORY);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,\n\t\t\t\t  dentry, mode);\n\tdone_path_create(&path, dentry);\n\treturn error;\n}\n\nint __init init_rmdir(const char *pathname)\n{\n\treturn do_rmdir(AT_FDCWD, getname_kernel(pathname));\n}\n\nint __init init_utimes(char *filename, struct timespec64 *ts)\n{\n\tstruct path path;\n\tint error;\n\n\terror = kern_path(filename, 0, &path);\n\tif (error)\n\t\treturn error;\n\terror = vfs_utimes(&path, ts);\n\tpath_put(&path);\n\treturn error;\n}\n\nint __init init_dup(struct file *file)\n{\n\tint fd;\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0)\n\t\treturn fd;\n\tfd_install(fd, get_file(file));\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}