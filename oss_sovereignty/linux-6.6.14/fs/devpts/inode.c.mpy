{
  "module_name": "inode.c",
  "hash_id": "417821183207b3eb5b420b78a580a9889813aa42d5eb7384b1c3ce47158e5334",
  "original_prompt": "Ingested from linux-6.6.14/fs/devpts/inode.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/tty.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/idr.h>\n#include <linux/devpts_fs.h>\n#include <linux/parser.h>\n#include <linux/fsnotify.h>\n#include <linux/seq_file.h>\n\n#define DEVPTS_DEFAULT_MODE 0600\n \n#define DEVPTS_DEFAULT_PTMX_MODE 0000\n#define PTMX_MINOR\t2\n\n \nstatic int pty_limit = NR_UNIX98_PTY_DEFAULT;\nstatic int pty_reserve = NR_UNIX98_PTY_RESERVE;\nstatic int pty_limit_min;\nstatic int pty_limit_max = INT_MAX;\nstatic atomic_t pty_count = ATOMIC_INIT(0);\n\nstatic struct ctl_table pty_table[] = {\n\t{\n\t\t.procname\t= \"max\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.data\t\t= &pty_limit,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &pty_limit_min,\n\t\t.extra2\t\t= &pty_limit_max,\n\t}, {\n\t\t.procname\t= \"reserve\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.data\t\t= &pty_reserve,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &pty_limit_min,\n\t\t.extra2\t\t= &pty_limit_max,\n\t}, {\n\t\t.procname\t= \"nr\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.data\t\t= &pty_count,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{}\n};\n\nstruct pts_mount_opts {\n\tint setuid;\n\tint setgid;\n\tkuid_t   uid;\n\tkgid_t   gid;\n\tumode_t mode;\n\tumode_t ptmxmode;\n\tint reserve;\n\tint max;\n};\n\nenum {\n\tOpt_uid, Opt_gid, Opt_mode, Opt_ptmxmode, Opt_newinstance,  Opt_max,\n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_ptmxmode, \"ptmxmode=%o\"},\n\t{Opt_newinstance, \"newinstance\"},\n\t{Opt_max, \"max=%d\"},\n\t{Opt_err, NULL}\n};\n\nstruct pts_fs_info {\n\tstruct ida allocated_ptys;\n\tstruct pts_mount_opts mount_opts;\n\tstruct super_block *sb;\n\tstruct dentry *ptmx_dentry;\n};\n\nstatic inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic int devpts_ptmx_path(struct path *path)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\t \n\terr = path_pts(path);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsb = path->mnt->mnt_sb;\n\tif ((sb->s_magic != DEVPTS_SUPER_MAGIC) ||\n\t    (path->mnt->mnt_root != sb->s_root))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstruct vfsmount *devpts_mntget(struct file *filp, struct pts_fs_info *fsi)\n{\n\tstruct path path;\n\tint err = 0;\n\n\tpath = filp->f_path;\n\tpath_get(&path);\n\n\t \n\twhile (path.mnt->mnt_root == path.dentry)\n\t\tif (follow_up(&path) == 0)\n\t\t\tbreak;\n\n\t \n\tif ((path.mnt->mnt_sb->s_magic != DEVPTS_SUPER_MAGIC) ||\n\t    (DEVPTS_SB(path.mnt->mnt_sb) != fsi))\n\t\terr = devpts_ptmx_path(&path);\n\tdput(path.dentry);\n\tif (!err) {\n\t\tif (DEVPTS_SB(path.mnt->mnt_sb) == fsi)\n\t\t\treturn path.mnt;\n\n\t\terr = -ENODEV;\n\t}\n\n\tmntput(path.mnt);\n\treturn ERR_PTR(err);\n}\n\nstruct pts_fs_info *devpts_acquire(struct file *filp)\n{\n\tstruct pts_fs_info *result;\n\tstruct path path;\n\tstruct super_block *sb;\n\n\tpath = filp->f_path;\n\tpath_get(&path);\n\n\t \n\tif (path.mnt->mnt_sb->s_magic != DEVPTS_SUPER_MAGIC) {\n\t\tint err;\n\n\t\terr = devpts_ptmx_path(&path);\n\t\tif (err) {\n\t\t\tresult = ERR_PTR(err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tsb = path.mnt->mnt_sb;\n\tatomic_inc(&sb->s_active);\n\tresult = DEVPTS_SB(sb);\n\nout:\n\tpath_put(&path);\n\treturn result;\n}\n\nvoid devpts_release(struct pts_fs_info *fsi)\n{\n\tdeactivate_super(fsi->sb);\n}\n\n#define PARSE_MOUNT\t0\n#define PARSE_REMOUNT\t1\n\n \nstatic int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)\n{\n\tchar *p;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\topts->setuid  = 0;\n\topts->setgid  = 0;\n\topts->uid     = GLOBAL_ROOT_UID;\n\topts->gid     = GLOBAL_ROOT_GID;\n\topts->mode    = DEVPTS_DEFAULT_MODE;\n\topts->ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\topts->max     = NR_UNIX98_PTY_MAX;\n\n\t \n\tif (op == PARSE_MOUNT)\n\t\topts->reserve =\n\t\t\t(current->nsproxy->mnt_ns == init_task.nsproxy->mnt_ns);\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tint option;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\topts->setuid = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\topts->setgid = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_ptmxmode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->ptmxmode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_newinstance:\n\t\t\tbreak;\n\t\tcase Opt_max:\n\t\t\tif (match_int(&args[0], &option) ||\n\t\t\t    option < 0 || option > NR_UNIX98_PTY_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\topts->max = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"called with bogus options\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mknod_ptmx(struct super_block *sb)\n{\n\tint mode;\n\tint rc = -ENOMEM;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct dentry *root = sb->s_root;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\tkuid_t ptmx_uid = current_fsuid();\n\tkgid_t ptmx_gid = current_fsgid();\n\n\tinode_lock(d_inode(root));\n\n\t \n\tif (fsi->ptmx_dentry) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tdentry = d_alloc_name(root, \"ptmx\");\n\tif (!dentry) {\n\t\tpr_err(\"Unable to alloc dentry for ptmx node\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_err(\"Unable to alloc inode for ptmx node\\n\");\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = 2;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\n\tmode = S_IFCHR|opts->ptmxmode;\n\tinit_special_inode(inode, mode, MKDEV(TTYAUX_MAJOR, 2));\n\tinode->i_uid = ptmx_uid;\n\tinode->i_gid = ptmx_gid;\n\n\td_add(dentry, inode);\n\n\tfsi->ptmx_dentry = dentry;\n\trc = 0;\nout:\n\tinode_unlock(d_inode(root));\n\treturn rc;\n}\n\nstatic void update_ptmx_mode(struct pts_fs_info *fsi)\n{\n\tstruct inode *inode;\n\tif (fsi->ptmx_dentry) {\n\t\tinode = d_inode(fsi->ptmx_dentry);\n\t\tinode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;\n\t}\n}\n\nstatic int devpts_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\terr = parse_mount_options(data, PARSE_REMOUNT, opts);\n\n\t \n\tupdate_ptmx_mode(fsi);\n\n\treturn err;\n}\n\nstatic int devpts_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(root->d_sb);\n\tstruct pts_mount_opts *opts = &fsi->mount_opts;\n\n\tif (opts->setuid)\n\t\tseq_printf(seq, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (opts->setgid)\n\t\tseq_printf(seq, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tseq_printf(seq, \",mode=%03o\", opts->mode);\n\tseq_printf(seq, \",ptmxmode=%03o\", opts->ptmxmode);\n\tif (opts->max < NR_UNIX98_PTY_MAX)\n\t\tseq_printf(seq, \",max=%d\", opts->max);\n\n\treturn 0;\n}\n\nstatic const struct super_operations devpts_sops = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= devpts_remount,\n\t.show_options\t= devpts_show_options,\n};\n\nstatic void *new_pts_fs_info(struct super_block *sb)\n{\n\tstruct pts_fs_info *fsi;\n\n\tfsi = kzalloc(sizeof(struct pts_fs_info), GFP_KERNEL);\n\tif (!fsi)\n\t\treturn NULL;\n\n\tida_init(&fsi->allocated_ptys);\n\tfsi->mount_opts.mode = DEVPTS_DEFAULT_MODE;\n\tfsi->mount_opts.ptmxmode = DEVPTS_DEFAULT_PTMX_MODE;\n\tfsi->sb = sb;\n\n\treturn fsi;\n}\n\nstatic int\ndevpts_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct inode *inode;\n\tint error;\n\n\ts->s_iflags &= ~SB_I_NODEV;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = DEVPTS_SUPER_MAGIC;\n\ts->s_op = &devpts_sops;\n\ts->s_d_op = &simple_dentry_operations;\n\ts->s_time_gran = 1;\n\n\terror = -ENOMEM;\n\ts->s_fs_info = new_pts_fs_info(s);\n\tif (!s->s_fs_info)\n\t\tgoto fail;\n\n\terror = parse_mount_options(data, PARSE_MOUNT, &DEVPTS_SB(s)->mount_opts);\n\tif (error)\n\t\tgoto fail;\n\n\terror = -ENOMEM;\n\tinode = new_inode(s);\n\tif (!inode)\n\t\tgoto fail;\n\tinode->i_ino = 1;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\tpr_err(\"get root dentry failed\\n\");\n\t\tgoto fail;\n\t}\n\n\terror = mknod_ptmx(s);\n\tif (error)\n\t\tgoto fail_dput;\n\n\treturn 0;\nfail_dput:\n\tdput(s->s_root);\n\ts->s_root = NULL;\nfail:\n\treturn error;\n}\n\n \nstatic struct dentry *devpts_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, devpts_fill_super);\n}\n\nstatic void devpts_kill_sb(struct super_block *sb)\n{\n\tstruct pts_fs_info *fsi = DEVPTS_SB(sb);\n\n\tif (fsi)\n\t\tida_destroy(&fsi->allocated_ptys);\n\tkfree(fsi);\n\tkill_litter_super(sb);\n}\n\nstatic struct file_system_type devpts_fs_type = {\n\t.name\t\t= \"devpts\",\n\t.mount\t\t= devpts_mount,\n\t.kill_sb\t= devpts_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\n \n\nint devpts_new_index(struct pts_fs_info *fsi)\n{\n\tint index = -ENOSPC;\n\n\tif (atomic_inc_return(&pty_count) >= (pty_limit -\n\t\t\t  (fsi->mount_opts.reserve ? 0 : pty_reserve)))\n\t\tgoto out;\n\n\tindex = ida_alloc_max(&fsi->allocated_ptys, fsi->mount_opts.max - 1,\n\t\t\tGFP_KERNEL);\n\nout:\n\tif (index < 0)\n\t\tatomic_dec(&pty_count);\n\treturn index;\n}\n\nvoid devpts_kill_index(struct pts_fs_info *fsi, int idx)\n{\n\tida_free(&fsi->allocated_ptys, idx);\n\tatomic_dec(&pty_count);\n}\n\n \nstruct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)\n{\n\tstruct dentry *dentry;\n\tstruct super_block *sb = fsi->sb;\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct pts_mount_opts *opts;\n\tchar s[12];\n\n\troot = sb->s_root;\n\topts = &fsi->mount_opts;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = index + 3;\n\tinode->i_uid = opts->setuid ? opts->uid : current_fsuid();\n\tinode->i_gid = opts->setgid ? opts->gid : current_fsgid();\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinit_special_inode(inode, S_IFCHR|opts->mode, MKDEV(UNIX98_PTY_SLAVE_MAJOR, index));\n\n\tsprintf(s, \"%d\", index);\n\n\tdentry = d_alloc_name(root, s);\n\tif (dentry) {\n\t\tdentry->d_fsdata = priv;\n\t\td_add(dentry, inode);\n\t\tfsnotify_create(d_inode(root), dentry);\n\t} else {\n\t\tiput(inode);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn dentry;\n}\n\n \nvoid *devpts_get_priv(struct dentry *dentry)\n{\n\tif (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)\n\t\treturn NULL;\n\treturn dentry->d_fsdata;\n}\n\n \nvoid devpts_pty_kill(struct dentry *dentry)\n{\n\tWARN_ON_ONCE(dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC);\n\n\tdentry->d_fsdata = NULL;\n\tdrop_nlink(dentry->d_inode);\n\td_drop(dentry);\n\tfsnotify_unlink(d_inode(dentry->d_parent), dentry);\n\tdput(dentry);\t \n}\n\nstatic int __init init_devpts_fs(void)\n{\n\tint err = register_filesystem(&devpts_fs_type);\n\tif (!err) {\n\t\tregister_sysctl(\"kernel/pty\", pty_table);\n\t}\n\treturn err;\n}\nmodule_init(init_devpts_fs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}