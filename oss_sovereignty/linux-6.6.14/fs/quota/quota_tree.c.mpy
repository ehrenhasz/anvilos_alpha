{
  "module_name": "quota_tree.c",
  "hash_id": "efab3186b433d71e194e40f1d9d0dc959564e2c4df317e9655a74b587ee503b0",
  "original_prompt": "Ingested from linux-6.6.14/fs/quota/quota_tree.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/dqblk_v2.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n\n#include <asm/byteorder.h>\n\n#include \"quota_tree.h\"\n\nMODULE_AUTHOR(\"Jan Kara\");\nMODULE_DESCRIPTION(\"Quota trie support\");\nMODULE_LICENSE(\"GPL\");\n\n#define __QUOTA_QT_PARANOIA\n\nstatic int __get_index(struct qtree_mem_dqinfo *info, qid_t id, int depth)\n{\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\n\tdepth = info->dqi_qtree_depth - depth - 1;\n\twhile (depth--)\n\t\tid /= epb;\n\treturn id % epb;\n}\n\nstatic int get_index(struct qtree_mem_dqinfo *info, struct kqid qid, int depth)\n{\n\tqid_t id = from_kqid(&init_user_ns, qid);\n\n\treturn __get_index(info, id, depth);\n}\n\n \nstatic int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)\n{\n\treturn (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))\n\t       / info->dqi_entry_size;\n}\n\nstatic ssize_t read_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\n\tmemset(buf, 0, info->dqi_usable_bs);\n\treturn sb->s_op->quota_read(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, (loff_t)blk << info->dqi_blocksize_bits);\n}\n\nstatic ssize_t write_blk(struct qtree_mem_dqinfo *info, uint blk, char *buf)\n{\n\tstruct super_block *sb = info->dqi_sb;\n\tssize_t ret;\n\n\tret = sb->s_op->quota_write(sb, info->dqi_type, buf,\n\t       info->dqi_usable_bs, (loff_t)blk << info->dqi_blocksize_bits);\n\tif (ret != info->dqi_usable_bs) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nstatic inline int do_check_range(struct super_block *sb, const char *val_name,\n\t\t\t\t uint val, uint min_val, uint max_val)\n{\n\tif (val < min_val || val > max_val) {\n\t\tquota_error(sb, \"Getting %s %u out of range %u-%u\",\n\t\t\t    val_name, val, min_val, max_val);\n\t\treturn -EUCLEAN;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_dquot_block_header(struct qtree_mem_dqinfo *info,\n\t\t\t\t    struct qt_disk_dqdbheader *dh)\n{\n\tint err = 0;\n\n\terr = do_check_range(info->dqi_sb, \"dqdh_next_free\",\n\t\t\t     le32_to_cpu(dh->dqdh_next_free), 0,\n\t\t\t     info->dqi_blocks - 1);\n\tif (err)\n\t\treturn err;\n\terr = do_check_range(info->dqi_sb, \"dqdh_prev_free\",\n\t\t\t     le32_to_cpu(dh->dqdh_prev_free), 0,\n\t\t\t     info->dqi_blocks - 1);\n\tif (err)\n\t\treturn err;\n\terr = do_check_range(info->dqi_sb, \"dqdh_entries\",\n\t\t\t     le16_to_cpu(dh->dqdh_entries), 0,\n\t\t\t     qtree_dqstr_in_blk(info));\n\n\treturn err;\n}\n\n \nstatic int get_free_dqblk(struct qtree_mem_dqinfo *info)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint ret, blk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (info->dqi_free_blk) {\n\t\tblk = info->dqi_free_blk;\n\t\tret = read_blk(info, blk, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tret = check_dquot_block_header(info, dh);\n\t\tif (ret)\n\t\t\tgoto out_buf;\n\t\tinfo->dqi_free_blk = le32_to_cpu(dh->dqdh_next_free);\n\t}\n\telse {\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t \n\t\tret = write_blk(info, info->dqi_blocks, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\tblk = info->dqi_blocks++;\n\t}\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\tret = blk;\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int put_free_dqblk(struct qtree_mem_dqinfo *info, char *buf, uint blk)\n{\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_blk);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\tdh->dqdh_entries = cpu_to_le16(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\treturn err;\n\tinfo->dqi_free_blk = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\n}\n\n \nstatic int remove_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tuint nextblk = le32_to_cpu(dh->dqdh_next_free);\n\tuint prevblk = le32_to_cpu(dh->dqdh_prev_free);\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tif (nextblk) {\n\t\terr = read_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tdh->dqdh_prev_free;\n\t\terr = write_blk(info, nextblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tif (prevblk) {\n\t\terr = read_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =\n\t\t\t\t\t\t\tdh->dqdh_next_free;\n\t\terr = write_blk(info, prevblk, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tinfo->dqi_free_entry = nextblk;\n\t\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\t}\n\tkfree(tmpbuf);\n\tdh->dqdh_next_free = dh->dqdh_prev_free = cpu_to_le32(0);\n\t \n\tif (write_blk(info, blk, buf) < 0)\n\t\tquota_error(info->dqi_sb, \"Can't write block (%u) \"\n\t\t\t    \"with free entries\", blk);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}\n\n \nstatic int insert_free_dqentry(struct qtree_mem_dqinfo *info, char *buf,\n\t\t\t       uint blk)\n{\n\tchar *tmpbuf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tstruct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;\n\tint err;\n\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tdh->dqdh_next_free = cpu_to_le32(info->dqi_free_entry);\n\tdh->dqdh_prev_free = cpu_to_le32(0);\n\terr = write_blk(info, blk, buf);\n\tif (err < 0)\n\t\tgoto out_buf;\n\tif (info->dqi_free_entry) {\n\t\terr = read_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t\t((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =\n\t\t\t\t\t\t\tcpu_to_le32(blk);\n\t\terr = write_blk(info, info->dqi_free_entry, tmpbuf);\n\t\tif (err < 0)\n\t\t\tgoto out_buf;\n\t}\n\tkfree(tmpbuf);\n\tinfo->dqi_free_entry = blk;\n\tmark_info_dirty(info->dqi_sb, info->dqi_type);\n\treturn 0;\nout_buf:\n\tkfree(tmpbuf);\n\treturn err;\n}\n\n \nint qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}\nEXPORT_SYMBOL(qtree_entry_unused);\n\n \nstatic uint find_free_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t      struct dquot *dquot, int *err)\n{\n\tuint blk, i;\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tchar *ddquot;\n\n\t*err = 0;\n\tif (!buf) {\n\t\t*err = -ENOMEM;\n\t\treturn 0;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tif (info->dqi_free_entry) {\n\t\tblk = info->dqi_free_entry;\n\t\t*err = read_blk(info, blk, buf);\n\t\tif (*err < 0)\n\t\t\tgoto out_buf;\n\t\t*err = check_dquot_block_header(info, dh);\n\t\tif (*err)\n\t\t\tgoto out_buf;\n\t} else {\n\t\tblk = get_free_dqblk(info);\n\t\tif ((int)blk < 0) {\n\t\t\t*err = blk;\n\t\t\tkfree(buf);\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\t \n\t\tinfo->dqi_free_entry = blk;\n\t\tmark_info_dirty(dquot->dq_sb, dquot->dq_id.type);\n\t}\n\t \n\tif (le16_to_cpu(dh->dqdh_entries) + 1 >= qtree_dqstr_in_blk(info)) {\n\t\t*err = remove_free_dqentry(info, buf, blk);\n\t\tif (*err < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't remove block (%u) \"\n\t\t\t\t    \"from entry free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tle16_add_cpu(&dh->dqdh_entries, 1);\n\t \n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (qtree_entry_unused(info, ddquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n#ifdef __QUOTA_QT_PARANOIA\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb, \"Data block full but it shouldn't\");\n\t\t*err = -EIO;\n\t\tgoto out_buf;\n\t}\n#endif\n\t*err = write_blk(info, blk, buf);\n\tif (*err < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdquot->dq_off = ((loff_t)blk << info->dqi_blocksize_bits) +\n\t\t\tsizeof(struct qt_disk_dqdbheader) +\n\t\t\ti * info->dqi_entry_size;\n\tkfree(buf);\n\treturn blk;\nout_buf:\n\tkfree(buf);\n\treturn 0;\n}\n\n \nstatic int do_insert_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\t  uint *treeblk, int depth)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tint ret = 0, newson = 0, newact = 0;\n\t__le32 *ref;\n\tuint newblk;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (!*treeblk) {\n\t\tret = get_free_dqblk(info);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t\t*treeblk = ret;\n\t\tmemset(buf, 0, info->dqi_usable_bs);\n\t\tnewact = 1;\n\t} else {\n\t\tret = read_blk(info, *treeblk, buf);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't read tree quota \"\n\t\t\t\t    \"block %u\", *treeblk);\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\tref = (__le32 *)buf;\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tret = do_check_range(dquot->dq_sb, \"block\", newblk, 0,\n\t\t\t     info->dqi_blocks - 1);\n\tif (ret)\n\t\tgoto out_buf;\n\tif (!newblk)\n\t\tnewson = 1;\n\tif (depth == info->dqi_qtree_depth - 1) {\n#ifdef __QUOTA_QT_PARANOIA\n\t\tif (newblk) {\n\t\t\tquota_error(dquot->dq_sb, \"Inserting already present \"\n\t\t\t\t    \"quota entry (block %u)\",\n\t\t\t\t    le32_to_cpu(ref[get_index(info,\n\t\t\t\t\t\tdquot->dq_id, depth)]));\n\t\t\tret = -EIO;\n\t\t\tgoto out_buf;\n\t\t}\n#endif\n\t\tnewblk = find_free_dqentry(info, dquot, &ret);\n\t} else {\n\t\tret = do_insert_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (newson && ret >= 0) {\n\t\tref[get_index(info, dquot->dq_id, depth)] =\n\t\t\t\t\t\t\tcpu_to_le32(newblk);\n\t\tret = write_blk(info, *treeblk, buf);\n\t} else if (newact && ret < 0) {\n\t\tput_free_dqblk(info, buf, *treeblk);\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic inline int dq_insert_tree(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot)\n{\n\tint tmp = QT_TREEOFF;\n\n#ifdef __QUOTA_QT_PARANOIA\n\tif (info->dqi_blocks <= QT_TREEOFF) {\n\t\tquota_error(dquot->dq_sb, \"Quota tree root isn't allocated!\");\n\t\treturn -EIO;\n\t}\n#endif\n\treturn do_insert_tree(info, dquot, &tmp, 0);\n}\n\n \nint qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = kmalloc(info->dqi_entry_size, GFP_NOFS);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dquot->dq_dqb_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qtree_write_dquot);\n\n \nstatic int free_dqentry(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t\tuint blk)\n{\n\tstruct qt_disk_dqdbheader *dh;\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (dquot->dq_off >> info->dqi_blocksize_bits != blk) {\n\t\tquota_error(dquot->dq_sb, \"Quota structure has offset to \"\n\t\t\t\"other block (%u) than it should (%u)\", blk,\n\t\t\t(uint)(dquot->dq_off >> info->dqi_blocksize_bits));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t}\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tdh = (struct qt_disk_dqdbheader *)buf;\n\tret = check_dquot_block_header(info, dh);\n\tif (ret)\n\t\tgoto out_buf;\n\tle16_add_cpu(&dh->dqdh_entries, -1);\n\tif (!le16_to_cpu(dh->dqdh_entries)) {\t \n\t\tret = remove_free_dqentry(info, buf, blk);\n\t\tif (ret >= 0)\n\t\t\tret = put_free_dqblk(info, buf, blk);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't move quota data block \"\n\t\t\t\t    \"(%u) to free list\", blk);\n\t\t\tgoto out_buf;\n\t\t}\n\t} else {\n\t\tmemset(buf +\n\t\t       (dquot->dq_off & ((1 << info->dqi_blocksize_bits) - 1)),\n\t\t       0, info->dqi_entry_size);\n\t\tif (le16_to_cpu(dh->dqdh_entries) ==\n\t\t    qtree_dqstr_in_blk(info) - 1) {\n\t\t\t \n\t\t\tret = insert_free_dqentry(info, buf, blk);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't insert quota \"\n\t\t\t\t    \"data block (%u) to free entry list\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t} else {\n\t\t\tret = write_blk(info, blk, buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tquota_error(dquot->dq_sb, \"Can't write quota \"\n\t\t\t\t\t    \"data block %u\", blk);\n\t\t\t\tgoto out_buf;\n\t\t\t}\n\t\t}\n\t}\n\tdquot->dq_off = 0;\t \nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot,\n\t\t       uint *blk, int depth)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tint ret = 0;\n\tuint newblk;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, *blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota data block %u\",\n\t\t\t    *blk);\n\t\tgoto out_buf;\n\t}\n\tnewblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tret = do_check_range(dquot->dq_sb, \"block\", newblk, QT_TREEOFF,\n\t\t\t     info->dqi_blocks - 1);\n\tif (ret)\n\t\tgoto out_buf;\n\n\tif (depth == info->dqi_qtree_depth - 1) {\n\t\tret = free_dqentry(info, dquot, newblk);\n\t\tnewblk = 0;\n\t} else {\n\t\tret = remove_tree(info, dquot, &newblk, depth+1);\n\t}\n\tif (ret >= 0 && !newblk) {\n\t\tint i;\n\t\tref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0);\n\t\t \n\t\tfor (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++)\n\t\t\t;\n\t\t \n\t\tif (i == (info->dqi_usable_bs >> 2)\n\t\t    && *blk != QT_TREEOFF) {\n\t\t\tput_free_dqblk(info, buf, *blk);\n\t\t\t*blk = 0;\n\t\t} else {\n\t\t\tret = write_blk(info, *blk, buf);\n\t\t\tif (ret < 0)\n\t\t\t\tquota_error(dquot->dq_sb,\n\t\t\t\t\t    \"Can't write quota tree block %u\",\n\t\t\t\t\t    *blk);\n\t\t}\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nint qtree_delete_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tuint tmp = QT_TREEOFF;\n\n\tif (!dquot->dq_off)\t \n\t\treturn 0;\n\treturn remove_tree(info, dquot, &tmp, 0);\n}\nEXPORT_SYMBOL(qtree_delete_dquot);\n\n \nstatic loff_t find_block_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t struct dquot *dquot, uint blk)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tloff_t ret = 0;\n\tint i;\n\tchar *ddquot;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree \"\n\t\t\t    \"block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tddquot = buf + sizeof(struct qt_disk_dqdbheader);\n\tfor (i = 0; i < qtree_dqstr_in_blk(info); i++) {\n\t\tif (info->dqi_ops->is_id(ddquot, dquot))\n\t\t\tbreak;\n\t\tddquot += info->dqi_entry_size;\n\t}\n\tif (i == qtree_dqstr_in_blk(info)) {\n\t\tquota_error(dquot->dq_sb,\n\t\t\t    \"Quota for id %u referenced but not present\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tret = -EIO;\n\t\tgoto out_buf;\n\t} else {\n\t\tret = ((loff_t)blk << info->dqi_blocksize_bits) + sizeof(struct\n\t\t  qt_disk_dqdbheader) + i * info->dqi_entry_size;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\tstruct dquot *dquot, uint blk, int depth)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\tloff_t ret = 0;\n\t__le32 *ref = (__le32 *)buf;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't read quota tree block %u\",\n\t\t\t    blk);\n\t\tgoto out_buf;\n\t}\n\tret = 0;\n\tblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);\n\tif (!blk)\t \n\t\tgoto out_buf;\n\tret = do_check_range(dquot->dq_sb, \"block\", blk, QT_TREEOFF,\n\t\t\t     info->dqi_blocks - 1);\n\tif (ret)\n\t\tgoto out_buf;\n\n\tif (depth < info->dqi_qtree_depth - 1)\n\t\tret = find_tree_dqentry(info, dquot, blk, depth+1);\n\telse\n\t\tret = find_block_dqentry(info, dquot, blk);\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,\n\t\t\t\t  struct dquot *dquot)\n{\n\treturn find_tree_dqentry(info, dquot, QT_TREEOFF, 0);\n}\n\nint qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tloff_t offset;\n\tchar *ddquot;\n\tint ret = 0;\n\n#ifdef __QUOTA_QT_PARANOIA\n\t \n\tif (!sb_dqopt(dquot->dq_sb)->files[type]) {\n\t\tquota_error(sb, \"Quota invalidated while reading!\");\n\t\treturn -EIO;\n\t}\n#endif\n\t \n\tif (!dquot->dq_off) {\n\t\toffset = find_dqentry(info, dquot);\n\t\tif (offset <= 0) {\t \n\t\t\tif (offset < 0)\n\t\t\t\tquota_error(sb,\"Can't read quota structure \"\n\t\t\t\t\t    \"for id %u\",\n\t\t\t\t\t    from_kqid(&init_user_ns,\n\t\t\t\t\t\t      dquot->dq_id));\n\t\t\tdquot->dq_off = 0;\n\t\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\t\tret = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tdquot->dq_off = offset;\n\t}\n\tddquot = kmalloc(info->dqi_entry_size, GFP_NOFS);\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\tret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t   dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tquota_error(sb, \"Error while reading quota structure for id %u\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\tkfree(ddquot);\n\t\tgoto out;\n\t}\n\tspin_lock(&dquot->dq_dqb_lock);\n\tinfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tkfree(ddquot);\nout:\n\tdqstats_inc(DQST_READS);\n\treturn ret;\n}\nEXPORT_SYMBOL(qtree_read_dquot);\n\n \nint qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\n\t    !(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\n\t\treturn qtree_delete_dquot(info, dquot);\n\treturn 0;\n}\nEXPORT_SYMBOL(qtree_release_dquot);\n\nstatic int find_next_id(struct qtree_mem_dqinfo *info, qid_t *id,\n\t\t\tunsigned int blk, int depth)\n{\n\tchar *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);\n\t__le32 *ref = (__le32 *)buf;\n\tssize_t ret;\n\tunsigned int epb = info->dqi_usable_bs >> 2;\n\tunsigned int level_inc = 1;\n\tint i;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = depth; i < info->dqi_qtree_depth - 1; i++)\n\t\tlevel_inc *= epb;\n\n\tret = read_blk(info, blk, buf);\n\tif (ret < 0) {\n\t\tquota_error(info->dqi_sb,\n\t\t\t    \"Can't read quota tree block %u\", blk);\n\t\tgoto out_buf;\n\t}\n\tfor (i = __get_index(info, *id, depth); i < epb; i++) {\n\t\tuint blk_no = le32_to_cpu(ref[i]);\n\n\t\tif (blk_no == 0) {\n\t\t\t*id += level_inc;\n\t\t\tcontinue;\n\t\t}\n\t\tret = do_check_range(info->dqi_sb, \"block\", blk_no, 0,\n\t\t\t\t     info->dqi_blocks - 1);\n\t\tif (ret)\n\t\t\tgoto out_buf;\n\t\tif (depth == info->dqi_qtree_depth - 1) {\n\t\t\tret = 0;\n\t\t\tgoto out_buf;\n\t\t}\n\t\tret = find_next_id(info, id, blk_no, depth + 1);\n\t\tif (ret != -ENOENT)\n\t\t\tbreak;\n\t}\n\tif (i == epb) {\n\t\tret = -ENOENT;\n\t\tgoto out_buf;\n\t}\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nint qtree_get_next_id(struct qtree_mem_dqinfo *info, struct kqid *qid)\n{\n\tqid_t id = from_kqid(&init_user_ns, *qid);\n\tint ret;\n\n\tret = find_next_id(info, &id, QT_TREEOFF, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\t*qid = make_kqid(&init_user_ns, qid->type, id);\n\treturn 0;\n}\nEXPORT_SYMBOL(qtree_get_next_id);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}