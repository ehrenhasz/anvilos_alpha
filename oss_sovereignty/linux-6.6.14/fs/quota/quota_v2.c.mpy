{
  "module_name": "quota_v2.c",
  "hash_id": "69dde76948f7ef0462d5020ccbd9e74acb4f95cd0563677297c2abf327ebe7e6",
  "original_prompt": "Ingested from linux-6.6.14/fs/quota/quota_v2.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/dqblk_v2.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n\n#include <asm/byteorder.h>\n\n#include \"quota_tree.h\"\n#include \"quotaio_v2.h\"\n\nMODULE_AUTHOR(\"Jan Kara\");\nMODULE_DESCRIPTION(\"Quota format v2 support\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void v2r0_mem2diskdqb(void *dp, struct dquot *dquot);\nstatic void v2r0_disk2memdqb(struct dquot *dquot, void *dp);\nstatic int v2r0_is_id(void *dp, struct dquot *dquot);\nstatic void v2r1_mem2diskdqb(void *dp, struct dquot *dquot);\nstatic void v2r1_disk2memdqb(struct dquot *dquot, void *dp);\nstatic int v2r1_is_id(void *dp, struct dquot *dquot);\n\nstatic const struct qtree_fmt_operations v2r0_qtree_ops = {\n\t.mem2disk_dqblk = v2r0_mem2diskdqb,\n\t.disk2mem_dqblk = v2r0_disk2memdqb,\n\t.is_id = v2r0_is_id,\n};\n\nstatic const struct qtree_fmt_operations v2r1_qtree_ops = {\n\t.mem2disk_dqblk = v2r1_mem2diskdqb,\n\t.disk2mem_dqblk = v2r1_disk2memdqb,\n\t.is_id = v2r1_is_id,\n};\n\n#define QUOTABLOCK_BITS 10\n#define QUOTABLOCK_SIZE (1 << QUOTABLOCK_BITS)\n\nstatic inline qsize_t v2_stoqb(qsize_t space)\n{\n\treturn (space + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS;\n}\n\nstatic inline qsize_t v2_qbtos(qsize_t blocks)\n{\n\treturn blocks << QUOTABLOCK_BITS;\n}\n\nstatic int v2_read_header(struct super_block *sb, int type,\n\t\t\t  struct v2_disk_dqheader *dqhead)\n{\n\tssize_t size;\n\n\tsize = sb->s_op->quota_read(sb, type, (char *)dqhead,\n\t\t\t\t    sizeof(struct v2_disk_dqheader), 0);\n\tif (size != sizeof(struct v2_disk_dqheader)) {\n\t\tquota_error(sb, \"Failed header read: expected=%zd got=%zd\",\n\t\t\t    sizeof(struct v2_disk_dqheader), size);\n\t\tif (size < 0)\n\t\t\treturn size;\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int v2_check_quota_file(struct super_block *sb, int type)\n{\n\tstruct v2_disk_dqheader dqhead;\n\tstatic const uint quota_magics[] = V2_INITQMAGICS;\n\tstatic const uint quota_versions[] = V2_INITQVERSIONS;\n\n\tif (v2_read_header(sb, type, &dqhead))\n\t\treturn 0;\n\tif (le32_to_cpu(dqhead.dqh_magic) != quota_magics[type] ||\n\t    le32_to_cpu(dqhead.dqh_version) > quota_versions[type])\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int v2_read_file_info(struct super_block *sb, int type)\n{\n\tstruct v2_disk_dqinfo dinfo;\n\tstruct v2_disk_dqheader dqhead;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct mem_dqinfo *info = &dqopt->info[type];\n\tstruct qtree_mem_dqinfo *qinfo;\n\tssize_t size;\n\tunsigned int version;\n\tint ret;\n\n\tdown_read(&dqopt->dqio_sem);\n\tret = v2_read_header(sb, type, &dqhead);\n\tif (ret < 0)\n\t\tgoto out;\n\tversion = le32_to_cpu(dqhead.dqh_version);\n\tif ((info->dqi_fmt_id == QFMT_VFS_V0 && version != 0) ||\n\t    (info->dqi_fmt_id == QFMT_VFS_V1 && version != 1)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t       sizeof(struct v2_disk_dqinfo), V2_DQINFOOFF);\n\tif (size != sizeof(struct v2_disk_dqinfo)) {\n\t\tquota_error(sb, \"Can't read info structure\");\n\t\tif (size < 0)\n\t\t\tret = size;\n\t\telse\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tinfo->dqi_priv = kmalloc(sizeof(struct qtree_mem_dqinfo), GFP_NOFS);\n\tif (!info->dqi_priv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tqinfo = info->dqi_priv;\n\tif (version == 0) {\n\t\t \n\t\tinfo->dqi_max_spc_limit = 0xffffffffLL << QUOTABLOCK_BITS;\n\t\tinfo->dqi_max_ino_limit = 0xffffffff;\n\t} else {\n\t\t \n\t\tinfo->dqi_max_spc_limit = 0x7fffffffffffffffLL;  \n\t\tinfo->dqi_max_ino_limit = 0x7fffffffffffffffLL;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\t \n\tinfo->dqi_flags = 0;\n\tqinfo->dqi_sb = sb;\n\tqinfo->dqi_type = type;\n\tqinfo->dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\tqinfo->dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\tqinfo->dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\tqinfo->dqi_blocksize_bits = V2_DQBLKSIZE_BITS;\n\tqinfo->dqi_usable_bs = 1 << V2_DQBLKSIZE_BITS;\n\tqinfo->dqi_qtree_depth = qtree_depth(qinfo);\n\tif (version == 0) {\n\t\tqinfo->dqi_entry_size = sizeof(struct v2r0_disk_dqblk);\n\t\tqinfo->dqi_ops = &v2r0_qtree_ops;\n\t} else {\n\t\tqinfo->dqi_entry_size = sizeof(struct v2r1_disk_dqblk);\n\t\tqinfo->dqi_ops = &v2r1_qtree_ops;\n\t}\n\tret = -EUCLEAN;\n\t \n\tif ((loff_t)qinfo->dqi_blocks << qinfo->dqi_blocksize_bits >\n\t    i_size_read(sb_dqopt(sb)->files[type])) {\n\t\tquota_error(sb, \"Number of blocks too big for quota file size (%llu > %llu).\",\n\t\t    (loff_t)qinfo->dqi_blocks << qinfo->dqi_blocksize_bits,\n\t\t    i_size_read(sb_dqopt(sb)->files[type]));\n\t\tgoto out_free;\n\t}\n\tif (qinfo->dqi_free_blk >= qinfo->dqi_blocks) {\n\t\tquota_error(sb, \"Free block number too big (%u >= %u).\",\n\t\t\t    qinfo->dqi_free_blk, qinfo->dqi_blocks);\n\t\tgoto out_free;\n\t}\n\tif (qinfo->dqi_free_entry >= qinfo->dqi_blocks) {\n\t\tquota_error(sb, \"Block with free entry too big (%u >= %u).\",\n\t\t\t    qinfo->dqi_free_entry, qinfo->dqi_blocks);\n\t\tgoto out_free;\n\t}\n\tret = 0;\nout_free:\n\tif (ret) {\n\t\tkfree(info->dqi_priv);\n\t\tinfo->dqi_priv = NULL;\n\t}\nout:\n\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\n \nstatic int v2_write_file_info(struct super_block *sb, int type)\n{\n\tstruct v2_disk_dqinfo dinfo;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct mem_dqinfo *info = &dqopt->info[type];\n\tstruct qtree_mem_dqinfo *qinfo = info->dqi_priv;\n\tssize_t size;\n\n\tdown_write(&dqopt->dqio_sem);\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\t \n\tdinfo.dqi_flags = cpu_to_le32(0);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_blocks = cpu_to_le32(qinfo->dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(qinfo->dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(qinfo->dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t       sizeof(struct v2_disk_dqinfo), V2_DQINFOOFF);\n\tup_write(&dqopt->dqio_sem);\n\tif (size != sizeof(struct v2_disk_dqinfo)) {\n\t\tquota_error(sb, \"Can't write info structure\");\n\t\treturn size < 0 ? size : -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void v2r0_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct v2r0_disk_dqblk *d = dp, empty;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\tm->dqb_ihardlimit = le32_to_cpu(d->dqb_ihardlimit);\n\tm->dqb_isoftlimit = le32_to_cpu(d->dqb_isoftlimit);\n\tm->dqb_curinodes = le32_to_cpu(d->dqb_curinodes);\n\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tm->dqb_bhardlimit = v2_qbtos(le32_to_cpu(d->dqb_bhardlimit));\n\tm->dqb_bsoftlimit = v2_qbtos(le32_to_cpu(d->dqb_bsoftlimit));\n\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\t \n\tmemset(&empty, 0, sizeof(struct v2r0_disk_dqblk));\n\tempty.dqb_itime = cpu_to_le64(1);\n\tif (!memcmp(&empty, dp, sizeof(struct v2r0_disk_dqblk)))\n\t\tm->dqb_itime = 0;\n}\n\nstatic void v2r0_mem2diskdqb(void *dp, struct dquot *dquot)\n{\n\tstruct v2r0_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\tstruct qtree_mem_dqinfo *info =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\td->dqb_ihardlimit = cpu_to_le32(m->dqb_ihardlimit);\n\td->dqb_isoftlimit = cpu_to_le32(m->dqb_isoftlimit);\n\td->dqb_curinodes = cpu_to_le32(m->dqb_curinodes);\n\td->dqb_itime = cpu_to_le64(m->dqb_itime);\n\td->dqb_bhardlimit = cpu_to_le32(v2_stoqb(m->dqb_bhardlimit));\n\td->dqb_bsoftlimit = cpu_to_le32(v2_stoqb(m->dqb_bsoftlimit));\n\td->dqb_curspace = cpu_to_le64(m->dqb_curspace);\n\td->dqb_btime = cpu_to_le64(m->dqb_btime);\n\td->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\n\tif (qtree_entry_unused(info, dp))\n\t\td->dqb_itime = cpu_to_le64(1);\n}\n\nstatic int v2r0_is_id(void *dp, struct dquot *dquot)\n{\n\tstruct v2r0_disk_dqblk *d = dp;\n\tstruct qtree_mem_dqinfo *info =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\tif (qtree_entry_unused(info, dp))\n\t\treturn 0;\n\treturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id)),\n\t\t      dquot->dq_id);\n}\n\nstatic void v2r1_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct v2r1_disk_dqblk *d = dp, empty;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tm->dqb_bhardlimit = v2_qbtos(le64_to_cpu(d->dqb_bhardlimit));\n\tm->dqb_bsoftlimit = v2_qbtos(le64_to_cpu(d->dqb_bsoftlimit));\n\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\t \n\tmemset(&empty, 0, sizeof(struct v2r1_disk_dqblk));\n\tempty.dqb_itime = cpu_to_le64(1);\n\tif (!memcmp(&empty, dp, sizeof(struct v2r1_disk_dqblk)))\n\t\tm->dqb_itime = 0;\n}\n\nstatic void v2r1_mem2diskdqb(void *dp, struct dquot *dquot)\n{\n\tstruct v2r1_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\tstruct qtree_mem_dqinfo *info =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\td->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\n\td->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\n\td->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\n\td->dqb_itime = cpu_to_le64(m->dqb_itime);\n\td->dqb_bhardlimit = cpu_to_le64(v2_stoqb(m->dqb_bhardlimit));\n\td->dqb_bsoftlimit = cpu_to_le64(v2_stoqb(m->dqb_bsoftlimit));\n\td->dqb_curspace = cpu_to_le64(m->dqb_curspace);\n\td->dqb_btime = cpu_to_le64(m->dqb_btime);\n\td->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\n\td->dqb_pad = 0;\n\tif (qtree_entry_unused(info, dp))\n\t\td->dqb_itime = cpu_to_le64(1);\n}\n\nstatic int v2r1_is_id(void *dp, struct dquot *dquot)\n{\n\tstruct v2r1_disk_dqblk *d = dp;\n\tstruct qtree_mem_dqinfo *info =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\tif (qtree_entry_unused(info, dp))\n\t\treturn 0;\n\treturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id)),\n\t\t      dquot->dq_id);\n}\n\nstatic int v2_read_dquot(struct dquot *dquot)\n{\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\tint ret;\n\n\tdown_read(&dqopt->dqio_sem);\n\tret = qtree_read_dquot(\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv,\n\t\t\tdquot);\n\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\nstatic int v2_write_dquot(struct dquot *dquot)\n{\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\tint ret;\n\tbool alloc = false;\n\n\t \n\tif (!dquot->dq_off) {\n\t\talloc = true;\n\t\tdown_write(&dqopt->dqio_sem);\n\t} else {\n\t\tdown_read(&dqopt->dqio_sem);\n\t}\n\tret = qtree_write_dquot(\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv,\n\t\t\tdquot);\n\tif (alloc)\n\t\tup_write(&dqopt->dqio_sem);\n\telse\n\t\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\nstatic int v2_release_dquot(struct dquot *dquot)\n{\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\tint ret;\n\n\tdown_write(&dqopt->dqio_sem);\n\tret = qtree_release_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv, dquot);\n\tup_write(&dqopt->dqio_sem);\n\n\treturn ret;\n}\n\nstatic int v2_free_file_info(struct super_block *sb, int type)\n{\n\tkfree(sb_dqinfo(sb, type)->dqi_priv);\n\treturn 0;\n}\n\nstatic int v2_get_next_id(struct super_block *sb, struct kqid *qid)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint ret;\n\n\tdown_read(&dqopt->dqio_sem);\n\tret = qtree_get_next_id(sb_dqinfo(sb, qid->type)->dqi_priv, qid);\n\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\nstatic const struct quota_format_ops v2_format_ops = {\n\t.check_quota_file\t= v2_check_quota_file,\n\t.read_file_info\t\t= v2_read_file_info,\n\t.write_file_info\t= v2_write_file_info,\n\t.free_file_info\t\t= v2_free_file_info,\n\t.read_dqblk\t\t= v2_read_dquot,\n\t.commit_dqblk\t\t= v2_write_dquot,\n\t.release_dqblk\t\t= v2_release_dquot,\n\t.get_next_id\t\t= v2_get_next_id,\n};\n\nstatic struct quota_format_type v2r0_quota_format = {\n\t.qf_fmt_id\t= QFMT_VFS_V0,\n\t.qf_ops\t\t= &v2_format_ops,\n\t.qf_owner\t= THIS_MODULE\n};\n\nstatic struct quota_format_type v2r1_quota_format = {\n\t.qf_fmt_id\t= QFMT_VFS_V1,\n\t.qf_ops\t\t= &v2_format_ops,\n\t.qf_owner\t= THIS_MODULE\n};\n\nstatic int __init init_v2_quota_format(void)\n{\n\tint ret;\n\n\tret = register_quota_format(&v2r0_quota_format);\n\tif (ret)\n\t\treturn ret;\n\treturn register_quota_format(&v2r1_quota_format);\n}\n\nstatic void __exit exit_v2_quota_format(void)\n{\n\tunregister_quota_format(&v2r0_quota_format);\n\tunregister_quota_format(&v2r1_quota_format);\n}\n\nmodule_init(init_v2_quota_format);\nmodule_exit(exit_v2_quota_format);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}