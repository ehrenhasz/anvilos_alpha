{
  "module_name": "dquot.c",
  "hash_id": "e6e9590f6a47b33d46d25eded26b192d7967a46d2588d03476986e68d4fb1f35",
  "original_prompt": "Ingested from linux-6.6.14/fs/quota/dquot.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/security.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/kmod.h>\n#include <linux/namei.h>\n#include <linux/capability.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/sched/mm.h>\n#include \"../internal.h\"  \n\n#include <linux/uaccess.h>\n\n \n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nEXPORT_SYMBOL(dq_data_lock);\nDEFINE_STATIC_SRCU(dquot_srcu);\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dquot_ref_wq);\n\nvoid __quota_error(struct super_block *sb, const char *func,\n\t\t   const char *fmt, ...)\n{\n\tif (printk_ratelimit()) {\n\t\tva_list args;\n\t\tstruct va_format vaf;\n\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_ERR \"Quota error (device %s): %s: %pV\\n\",\n\t\t       sb->s_id, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}\nEXPORT_SYMBOL(__quota_error);\n\n#if defined(CONFIG_QUOTA_DEBUG) || defined(CONFIG_PRINT_QUOTA_WARNING)\nstatic char *quotatypes[] = INITQFNAMES;\n#endif\nstatic struct quota_format_type *quota_formats;\t \nstatic struct quota_module_name module_names[] = INIT_QUOTA_MODULE_NAMES;\n\n \nstatic struct kmem_cache *dquot_cachep;\n\nint register_quota_format(struct quota_format_type *fmt)\n{\n\tspin_lock(&dq_list_lock);\n\tfmt->qf_next = quota_formats;\n\tquota_formats = fmt;\n\tspin_unlock(&dq_list_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(register_quota_format);\n\nvoid unregister_quota_format(struct quota_format_type *fmt)\n{\n\tstruct quota_format_type **actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = &quota_formats; *actqf && *actqf != fmt;\n\t     actqf = &(*actqf)->qf_next)\n\t\t;\n\tif (*actqf)\n\t\t*actqf = (*actqf)->qf_next;\n\tspin_unlock(&dq_list_lock);\n}\nEXPORT_SYMBOL(unregister_quota_format);\n\nstatic struct quota_format_type *find_quota_format(int id)\n{\n\tstruct quota_format_type *actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\n\t     actqf = actqf->qf_next)\n\t\t;\n\tif (!actqf || !try_module_get(actqf->qf_owner)) {\n\t\tint qm;\n\n\t\tspin_unlock(&dq_list_lock);\n\n\t\tfor (qm = 0; module_names[qm].qm_fmt_id &&\n\t\t\t     module_names[qm].qm_fmt_id != id; qm++)\n\t\t\t;\n\t\tif (!module_names[qm].qm_fmt_id ||\n\t\t    request_module(module_names[qm].qm_mod_name))\n\t\t\treturn NULL;\n\n\t\tspin_lock(&dq_list_lock);\n\t\tfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\n\t\t     actqf = actqf->qf_next)\n\t\t\t;\n\t\tif (actqf && !try_module_get(actqf->qf_owner))\n\t\t\tactqf = NULL;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn actqf;\n}\n\nstatic void put_quota_format(struct quota_format_type *fmt)\n{\n\tmodule_put(fmt->qf_owner);\n}\n\n \n\nstatic LIST_HEAD(inuse_list);\nstatic LIST_HEAD(free_dquots);\nstatic LIST_HEAD(releasing_dquots);\nstatic unsigned int dq_hash_bits, dq_hash_mask;\nstatic struct hlist_head *dquot_hash;\n\nstruct dqstats dqstats;\nEXPORT_SYMBOL(dqstats);\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic qsize_t __inode_get_rsv_space(struct inode *inode);\nstatic int __dquot_initialize(struct inode *inode, int type);\n\nstatic void quota_release_workfn(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(quota_release_work, quota_release_workfn);\n\nstatic inline unsigned int\nhashfn(const struct super_block *sb, struct kqid qid)\n{\n\tunsigned int id = from_kqid(&init_user_ns, qid);\n\tint type = qid.type;\n\tunsigned long tmp;\n\n\ttmp = (((unsigned long)sb>>L1_CACHE_SHIFT) ^ id) * (MAXQUOTAS - type);\n\treturn (tmp + (tmp >> dq_hash_bits)) & dq_hash_mask;\n}\n\n \nstatic inline void insert_dquot_hash(struct dquot *dquot)\n{\n\tstruct hlist_head *head;\n\thead = dquot_hash + hashfn(dquot->dq_sb, dquot->dq_id);\n\thlist_add_head(&dquot->dq_hash, head);\n}\n\nstatic inline void remove_dquot_hash(struct dquot *dquot)\n{\n\thlist_del_init(&dquot->dq_hash);\n}\n\nstatic struct dquot *find_dquot(unsigned int hashent, struct super_block *sb,\n\t\t\t\tstruct kqid qid)\n{\n\tstruct dquot *dquot;\n\n\thlist_for_each_entry(dquot, dquot_hash+hashent, dq_hash)\n\t\tif (dquot->dq_sb == sb && qid_eq(dquot->dq_id, qid))\n\t\t\treturn dquot;\n\n\treturn NULL;\n}\n\n \nstatic inline void put_dquot_last(struct dquot *dquot)\n{\n\tlist_add_tail(&dquot->dq_free, &free_dquots);\n\tdqstats_inc(DQST_FREE_DQUOTS);\n}\n\nstatic inline void put_releasing_dquots(struct dquot *dquot)\n{\n\tlist_add_tail(&dquot->dq_free, &releasing_dquots);\n\tset_bit(DQ_RELEASING_B, &dquot->dq_flags);\n}\n\nstatic inline void remove_free_dquot(struct dquot *dquot)\n{\n\tif (list_empty(&dquot->dq_free))\n\t\treturn;\n\tlist_del_init(&dquot->dq_free);\n\tif (!test_bit(DQ_RELEASING_B, &dquot->dq_flags))\n\t\tdqstats_dec(DQST_FREE_DQUOTS);\n\telse\n\t\tclear_bit(DQ_RELEASING_B, &dquot->dq_flags);\n}\n\nstatic inline void put_inuse(struct dquot *dquot)\n{\n\t \n\tlist_add_tail(&dquot->dq_inuse, &inuse_list);\n\tdqstats_inc(DQST_ALLOC_DQUOTS);\n}\n\nstatic inline void remove_inuse(struct dquot *dquot)\n{\n\tdqstats_dec(DQST_ALLOC_DQUOTS);\n\tlist_del(&dquot->dq_inuse);\n}\n \n\nstatic void wait_on_dquot(struct dquot *dquot)\n{\n\tmutex_lock(&dquot->dq_lock);\n\tmutex_unlock(&dquot->dq_lock);\n}\n\nstatic inline int dquot_active(struct dquot *dquot)\n{\n\treturn test_bit(DQ_ACTIVE_B, &dquot->dq_flags);\n}\n\nstatic inline int dquot_dirty(struct dquot *dquot)\n{\n\treturn test_bit(DQ_MOD_B, &dquot->dq_flags);\n}\n\nstatic inline int mark_dquot_dirty(struct dquot *dquot)\n{\n\treturn dquot->dq_sb->dq_op->mark_dirty(dquot);\n}\n\n \nint dquot_mark_dquot_dirty(struct dquot *dquot)\n{\n\tint ret = 1;\n\n\tif (!dquot_active(dquot))\n\t\treturn 0;\n\n\tif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NOLIST_DIRTY)\n\t\treturn test_and_set_bit(DQ_MOD_B, &dquot->dq_flags);\n\n\t \n\tif (dquot_dirty(dquot))\n\t\treturn 1;\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\n\t\t\t\tinfo[dquot->dq_id.type].dqi_dirty_list);\n\t\tret = 0;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_mark_dquot_dirty);\n\n \nstatic inline int mark_all_dquot_dirty(struct dquot * const *dquot)\n{\n\tint ret, err, cnt;\n\n\tret = err = 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (dquot[cnt])\n\t\t\t \n\t\t\tret = mark_dquot_dirty(dquot[cnt]);\n\t\tif (!err)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}\n\nstatic inline void dqput_all(struct dquot **dquot)\n{\n\tunsigned int cnt;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tdqput(dquot[cnt]);\n}\n\nstatic inline int clear_dquot_dirty(struct dquot *dquot)\n{\n\tif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NOLIST_DIRTY)\n\t\treturn test_and_clear_bit(DQ_MOD_B, &dquot->dq_flags);\n\n\tspin_lock(&dq_list_lock);\n\tif (!test_and_clear_bit(DQ_MOD_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn 0;\n\t}\n\tlist_del_init(&dquot->dq_dirty);\n\tspin_unlock(&dq_list_lock);\n\treturn 1;\n}\n\nvoid mark_info_dirty(struct super_block *sb, int type)\n{\n\tspin_lock(&dq_data_lock);\n\tsb_dqopt(sb)->info[type].dqi_flags |= DQF_INFO_DIRTY;\n\tspin_unlock(&dq_data_lock);\n}\nEXPORT_SYMBOL(mark_info_dirty);\n\n \n\nint dquot_acquire(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tunsigned int memalloc;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmemalloc = memalloc_nofs_save();\n\tif (!test_bit(DQ_READ_B, &dquot->dq_flags)) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t}\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(DQ_READ_B, &dquot->dq_flags);\n\t \n\tif (!dquot_active(dquot) && !dquot->dq_off) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\t\t \n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_iolock;\n\t\tif (ret2 < 0) {\n\t\t\tret = ret2;\n\t\t\tgoto out_iolock;\n\t\t}\n\t}\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_iolock:\n\tmemalloc_nofs_restore(memalloc);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_acquire);\n\n \nint dquot_commit(struct dquot *dquot)\n{\n\tint ret = 0;\n\tunsigned int memalloc;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmemalloc = memalloc_nofs_save();\n\tif (!clear_dquot_dirty(dquot))\n\t\tgoto out_lock;\n\t \n\tif (dquot_active(dquot))\n\t\tret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\n\telse\n\t\tret = -EIO;\nout_lock:\n\tmemalloc_nofs_restore(memalloc);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_commit);\n\n \nint dquot_release(struct dquot *dquot)\n{\n\tint ret = 0, ret2 = 0;\n\tunsigned int memalloc;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tmutex_lock(&dquot->dq_lock);\n\tmemalloc = memalloc_nofs_save();\n\t \n\tif (dquot_is_busy(dquot))\n\t\tgoto out_dqlock;\n\tif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\n\t\tret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\n\t\t \n\t\tif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\n\t\t\tret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\n\t\t\t\t\t\tdquot->dq_sb, dquot->dq_id.type);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = ret2;\n\t}\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_dqlock:\n\tmemalloc_nofs_restore(memalloc);\n\tmutex_unlock(&dquot->dq_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_release);\n\nvoid dquot_destroy(struct dquot *dquot)\n{\n\tkmem_cache_free(dquot_cachep, dquot);\n}\nEXPORT_SYMBOL(dquot_destroy);\n\nstatic inline void do_destroy_dquot(struct dquot *dquot)\n{\n\tdquot->dq_sb->dq_op->destroy_dquot(dquot);\n}\n\n \nstatic void invalidate_dquots(struct super_block *sb, int type)\n{\n\tstruct dquot *dquot, *tmp;\n\nrestart:\n\tflush_delayed_work(&quota_release_work);\n\n\tspin_lock(&dq_list_lock);\n\tlist_for_each_entry_safe(dquot, tmp, &inuse_list, dq_inuse) {\n\t\tif (dquot->dq_sb != sb)\n\t\t\tcontinue;\n\t\tif (dquot->dq_id.type != type)\n\t\t\tcontinue;\n\t\t \n\t\tif (atomic_read(&dquot->dq_count)) {\n\t\t\tatomic_inc(&dquot->dq_count);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\t \n\t\t\twait_event(dquot_ref_wq,\n\t\t\t\t   atomic_read(&dquot->dq_count) == 1);\n\t\t\tdqput(dquot);\n\t\t\t \n\t\t\tgoto restart;\n\t\t}\n\t\t \n\t\tif (test_bit(DQ_RELEASING_B, &dquot->dq_flags)) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t \n\t\tremove_dquot_hash(dquot);\n\t\tremove_free_dquot(dquot);\n\t\tremove_inuse(dquot);\n\t\tdo_destroy_dquot(dquot);\n\t}\n\tspin_unlock(&dq_list_lock);\n}\n\n \nint dquot_scan_active(struct super_block *sb,\n\t\t      int (*fn)(struct dquot *dquot, unsigned long priv),\n\t\t      unsigned long priv)\n{\n\tstruct dquot *dquot, *old_dquot = NULL;\n\tint ret = 0;\n\n\tWARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount));\n\n\tspin_lock(&dq_list_lock);\n\tlist_for_each_entry(dquot, &inuse_list, dq_inuse) {\n\t\tif (!dquot_active(dquot))\n\t\t\tcontinue;\n\t\tif (dquot->dq_sb != sb)\n\t\t\tcontinue;\n\t\t \n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqput(old_dquot);\n\t\told_dquot = dquot;\n\t\t \n\t\twait_on_dquot(dquot);\n\t\tif (dquot_active(dquot)) {\n\t\t\tret = fn(dquot, priv);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&dq_list_lock);\n\t\t \n\t}\n\tspin_unlock(&dq_list_lock);\nout:\n\tdqput(old_dquot);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_scan_active);\n\nstatic inline int dquot_write_dquot(struct dquot *dquot)\n{\n\tint ret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\tif (ret < 0) {\n\t\tquota_error(dquot->dq_sb, \"Can't write quota structure \"\n\t\t\t    \"(error %d). Quota may get out of sync!\", ret);\n\t\t \n\t\tclear_dquot_dirty(dquot);\n\t}\n\treturn ret;\n}\n\n \nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tWARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount));\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\t \n\t\tlist_replace_init(&dqopt->info[cnt].dqi_dirty_list, &dirty);\n\t\twhile (!list_empty(&dirty)) {\n\t\t\tdquot = list_first_entry(&dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\n\t\t\tWARN_ON(!dquot_active(dquot));\n\t\t\t \n\t\t\tif (test_bit(DQ_RELEASING_B, &dquot->dq_flags)) {\n\t\t\t\tspin_unlock(&dq_list_lock);\n\t\t\t\tflush_delayed_work(&quota_release_work);\n\t\t\t\tspin_lock(&dq_list_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\terr = dquot_write_dquot(dquot);\n\t\t\tif (err && !ret)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_writeback_dquots);\n\n \nint dquot_quota_sync(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint ret;\n\n\tret = dquot_writeback_dquots(sb, type);\n\tif (ret)\n\t\treturn ret;\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\treturn 0;\n\n\t \n\tif (sb->s_op->sync_fs) {\n\t\tret = sb->s_op->sync_fs(sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = sync_blockdev(sb->s_bdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tinode_lock(dqopt->files[cnt]);\n\t\ttruncate_inode_pages(&dqopt->files[cnt]->i_data, 0);\n\t\tinode_unlock(dqopt->files[cnt]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_quota_sync);\n\nstatic unsigned long\ndqcache_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tstruct dquot *dquot;\n\tunsigned long freed = 0;\n\n\tspin_lock(&dq_list_lock);\n\twhile (!list_empty(&free_dquots) && sc->nr_to_scan) {\n\t\tdquot = list_first_entry(&free_dquots, struct dquot, dq_free);\n\t\tremove_dquot_hash(dquot);\n\t\tremove_free_dquot(dquot);\n\t\tremove_inuse(dquot);\n\t\tdo_destroy_dquot(dquot);\n\t\tsc->nr_to_scan--;\n\t\tfreed++;\n\t}\n\tspin_unlock(&dq_list_lock);\n\treturn freed;\n}\n\nstatic unsigned long\ndqcache_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(\n\tpercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS]));\n}\n\nstatic struct shrinker dqcache_shrinker = {\n\t.count_objects = dqcache_shrink_count,\n\t.scan_objects = dqcache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\n\n \nstatic void quota_release_workfn(struct work_struct *work)\n{\n\tstruct dquot *dquot;\n\tstruct list_head rls_head;\n\n\tspin_lock(&dq_list_lock);\n\t \n\tlist_replace_init(&releasing_dquots, &rls_head);\n\tspin_unlock(&dq_list_lock);\n\tsynchronize_srcu(&dquot_srcu);\n\nrestart:\n\tspin_lock(&dq_list_lock);\n\twhile (!list_empty(&rls_head)) {\n\t\tdquot = list_first_entry(&rls_head, struct dquot, dq_free);\n\t\tWARN_ON_ONCE(atomic_read(&dquot->dq_count));\n\t\t \n\t\tif (dquot_dirty(dquot)) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\t \n\t\t\tdquot_write_dquot(dquot);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (dquot_active(dquot)) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\t\tgoto restart;\n\t\t}\n\t\t \n\t\tremove_free_dquot(dquot);\n\t\tput_dquot_last(dquot);\n\t}\n\tspin_unlock(&dq_list_lock);\n}\n\n \nvoid dqput(struct dquot *dquot)\n{\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\n\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t \n\t\tatomic_dec(&dquot->dq_count);\n\t\t \n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot_ref_wq);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\n\t \n#ifdef CONFIG_QUOTA_DEBUG\n\t \n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_releasing_dquots(dquot);\n\tatomic_dec(&dquot->dq_count);\n\tspin_unlock(&dq_list_lock);\n\tqueue_delayed_work(system_unbound_wq, &quota_release_work, 1);\n}\nEXPORT_SYMBOL(dqput);\n\nstruct dquot *dquot_alloc(struct super_block *sb, int type)\n{\n\treturn kmem_cache_zalloc(dquot_cachep, GFP_NOFS);\n}\nEXPORT_SYMBOL(dquot_alloc);\n\nstatic struct dquot *get_empty_dquot(struct super_block *sb, int type)\n{\n\tstruct dquot *dquot;\n\n\tdquot = sb->dq_op->alloc_dquot(sb, type);\n\tif(!dquot)\n\t\treturn NULL;\n\n\tmutex_init(&dquot->dq_lock);\n\tINIT_LIST_HEAD(&dquot->dq_free);\n\tINIT_LIST_HEAD(&dquot->dq_inuse);\n\tINIT_HLIST_NODE(&dquot->dq_hash);\n\tINIT_LIST_HEAD(&dquot->dq_dirty);\n\tdquot->dq_sb = sb;\n\tdquot->dq_id = make_kqid_invalid(type);\n\tatomic_set(&dquot->dq_count, 1);\n\tspin_lock_init(&dquot->dq_dqb_lock);\n\n\treturn dquot;\n}\n\n \nstruct dquot *dqget(struct super_block *sb, struct kqid qid)\n{\n\tunsigned int hashent = hashfn(sb, qid);\n\tstruct dquot *dquot, *empty = NULL;\n\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn ERR_PTR(-EINVAL);\n\n        if (!sb_has_quota_active(sb, qid.type))\n\t\treturn ERR_PTR(-ESRCH);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tspin_lock(&dq_state_lock);\n\tif (!sb_has_quota_active(sb, qid.type)) {\n\t\tspin_unlock(&dq_state_lock);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot = ERR_PTR(-ESRCH);\n\t\tgoto out;\n\t}\n\tspin_unlock(&dq_state_lock);\n\n\tdquot = find_dquot(hashent, sb, qid);\n\tif (!dquot) {\n\t\tif (!empty) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tempty = get_empty_dquot(sb, qid.type);\n\t\t\tif (!empty)\n\t\t\t\tschedule();\t \n\t\t\tgoto we_slept;\n\t\t}\n\t\tdquot = empty;\n\t\tempty = NULL;\n\t\tdquot->dq_id = qid;\n\t\t \n\t\tput_inuse(dquot);\n\t\t \n\t\tinsert_dquot_hash(dquot);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t} else {\n\t\tif (!atomic_read(&dquot->dq_count))\n\t\t\tremove_free_dquot(dquot);\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_CACHE_HITS);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t}\n\t \n\twait_on_dquot(dquot);\n\t \n\tif (!dquot_active(dquot)) {\n\t\tint err;\n\n\t\terr = sb->dq_op->acquire_dquot(dquot);\n\t\tif (err < 0) {\n\t\t\tdqput(dquot);\n\t\t\tdquot = ERR_PTR(err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tsmp_rmb();\n#ifdef CONFIG_QUOTA_DEBUG\n\tBUG_ON(!dquot->dq_sb);\t \n#endif\nout:\n\tif (empty)\n\t\tdo_destroy_dquot(empty);\n\n\treturn dquot;\n}\nEXPORT_SYMBOL(dqget);\n\nstatic inline struct dquot **i_dquot(struct inode *inode)\n{\n\treturn inode->i_sb->s_op->get_dquots(inode);\n}\n\nstatic int dqinit_needed(struct inode *inode, int type)\n{\n\tstruct dquot * const *dquots;\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn 0;\n\n\tdquots = i_dquot(inode);\n\tif (type != -1)\n\t\treturn !dquots[type];\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (!dquots[cnt])\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int add_dquot_ref(struct super_block *sb, int type)\n{\n\tstruct inode *inode, *old_inode = NULL;\n#ifdef CONFIG_QUOTA_DEBUG\n\tint reserved = 0;\n#endif\n\tint err = 0;\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\n\t\t    !atomic_read(&inode->i_writecount) ||\n\t\t    !dqinit_needed(inode, type)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&sb->s_inode_list_lock);\n\n#ifdef CONFIG_QUOTA_DEBUG\n\t\tif (unlikely(inode_get_rsv_space(inode) > 0))\n\t\t\treserved = 1;\n#endif\n\t\tiput(old_inode);\n\t\terr = __dquot_initialize(inode, type);\n\t\tif (err) {\n\t\t\tiput(inode);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\told_inode = inode;\n\t\tcond_resched();\n\t\tspin_lock(&sb->s_inode_list_lock);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\tiput(old_inode);\nout:\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (reserved) {\n\t\tquota_error(sb, \"Writes happened before quota was turned on \"\n\t\t\t\"thus quota information is probably inconsistent. \"\n\t\t\t\"Please run quotacheck(8)\");\n\t}\n#endif\n\treturn err;\n}\n\nstatic void remove_dquot_ref(struct super_block *sb, int type)\n{\n\tstruct inode *inode;\n#ifdef CONFIG_QUOTA_DEBUG\n\tint reserved = 0;\n#endif\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\n\t\t \n\t\tspin_lock(&dq_data_lock);\n\t\tif (!IS_NOQUOTA(inode)) {\n\t\t\tstruct dquot **dquots = i_dquot(inode);\n\t\t\tstruct dquot *dquot = dquots[type];\n\n#ifdef CONFIG_QUOTA_DEBUG\n\t\t\tif (unlikely(inode_get_rsv_space(inode) > 0))\n\t\t\t\treserved = 1;\n#endif\n\t\t\tdquots[type] = NULL;\n\t\t\tif (dquot)\n\t\t\t\tdqput(dquot);\n\t\t}\n\t\tspin_unlock(&dq_data_lock);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (reserved) {\n\t\tprintk(KERN_WARNING \"VFS (%s): Writes happened after quota\"\n\t\t\t\" was disabled thus quota information is probably \"\n\t\t\t\"inconsistent. Please run quotacheck(8).\\n\", sb->s_id);\n\t}\n#endif\n}\n\n \nstatic void drop_dquot_ref(struct super_block *sb, int type)\n{\n\tif (sb->dq_op)\n\t\tremove_dquot_ref(sb, type);\n}\n\nstatic inline\nvoid dquot_free_reserved_space(struct dquot *dquot, qsize_t number)\n{\n\tif (dquot->dq_dqb.dqb_rsvspace >= number)\n\t\tdquot->dq_dqb.dqb_rsvspace -= number;\n\telse {\n\t\tWARN_ON_ONCE(1);\n\t\tdquot->dq_dqb.dqb_rsvspace = 0;\n\t}\n\tif (dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace <=\n\t    dquot->dq_dqb.dqb_bsoftlimit)\n\t\tdquot->dq_dqb.dqb_btime = (time64_t) 0;\n\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n}\n\nstatic void dquot_decr_inodes(struct dquot *dquot, qsize_t number)\n{\n\tif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\n\t    dquot->dq_dqb.dqb_curinodes >= number)\n\t\tdquot->dq_dqb.dqb_curinodes -= number;\n\telse\n\t\tdquot->dq_dqb.dqb_curinodes = 0;\n\tif (dquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit)\n\t\tdquot->dq_dqb.dqb_itime = (time64_t) 0;\n\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n}\n\nstatic void dquot_decr_space(struct dquot *dquot, qsize_t number)\n{\n\tif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\n\t    dquot->dq_dqb.dqb_curspace >= number)\n\t\tdquot->dq_dqb.dqb_curspace -= number;\n\telse\n\t\tdquot->dq_dqb.dqb_curspace = 0;\n\tif (dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace <=\n\t    dquot->dq_dqb.dqb_bsoftlimit)\n\t\tdquot->dq_dqb.dqb_btime = (time64_t) 0;\n\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n}\n\nstruct dquot_warn {\n\tstruct super_block *w_sb;\n\tstruct kqid w_dq_id;\n\tshort w_type;\n};\n\nstatic int warning_issued(struct dquot *dquot, const int warntype)\n{\n\tint flag = (warntype == QUOTA_NL_BHARDWARN ||\n\t\twarntype == QUOTA_NL_BSOFTLONGWARN) ? DQ_BLKS_B :\n\t\t((warntype == QUOTA_NL_IHARDWARN ||\n\t\twarntype == QUOTA_NL_ISOFTLONGWARN) ? DQ_INODES_B : 0);\n\n\tif (!flag)\n\t\treturn 0;\n\treturn test_and_set_bit(flag, &dquot->dq_flags);\n}\n\n#ifdef CONFIG_PRINT_QUOTA_WARNING\nstatic int flag_print_warnings = 1;\n\nstatic int need_print_warning(struct dquot_warn *warn)\n{\n\tif (!flag_print_warnings)\n\t\treturn 0;\n\n\tswitch (warn->w_dq_id.type) {\n\t\tcase USRQUOTA:\n\t\t\treturn uid_eq(current_fsuid(), warn->w_dq_id.uid);\n\t\tcase GRPQUOTA:\n\t\t\treturn in_group_p(warn->w_dq_id.gid);\n\t\tcase PRJQUOTA:\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void print_warning(struct dquot_warn *warn)\n{\n\tchar *msg = NULL;\n\tstruct tty_struct *tty;\n\tint warntype = warn->w_type;\n\n\tif (warntype == QUOTA_NL_IHARDBELOW ||\n\t    warntype == QUOTA_NL_ISOFTBELOW ||\n\t    warntype == QUOTA_NL_BHARDBELOW ||\n\t    warntype == QUOTA_NL_BSOFTBELOW || !need_print_warning(warn))\n\t\treturn;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\ttty_write_message(tty, warn->w_sb->s_id);\n\tif (warntype == QUOTA_NL_ISOFTWARN || warntype == QUOTA_NL_BSOFTWARN)\n\t\ttty_write_message(tty, \": warning, \");\n\telse\n\t\ttty_write_message(tty, \": write failed, \");\n\ttty_write_message(tty, quotatypes[warn->w_dq_id.type]);\n\tswitch (warntype) {\n\t\tcase QUOTA_NL_IHARDWARN:\n\t\t\tmsg = \" file limit reached.\\r\\n\";\n\t\t\tbreak;\n\t\tcase QUOTA_NL_ISOFTLONGWARN:\n\t\t\tmsg = \" file quota exceeded too long.\\r\\n\";\n\t\t\tbreak;\n\t\tcase QUOTA_NL_ISOFTWARN:\n\t\t\tmsg = \" file quota exceeded.\\r\\n\";\n\t\t\tbreak;\n\t\tcase QUOTA_NL_BHARDWARN:\n\t\t\tmsg = \" block limit reached.\\r\\n\";\n\t\t\tbreak;\n\t\tcase QUOTA_NL_BSOFTLONGWARN:\n\t\t\tmsg = \" block quota exceeded too long.\\r\\n\";\n\t\t\tbreak;\n\t\tcase QUOTA_NL_BSOFTWARN:\n\t\t\tmsg = \" block quota exceeded.\\r\\n\";\n\t\t\tbreak;\n\t}\n\ttty_write_message(tty, msg);\n\ttty_kref_put(tty);\n}\n#endif\n\nstatic void prepare_warning(struct dquot_warn *warn, struct dquot *dquot,\n\t\t\t    int warntype)\n{\n\tif (warning_issued(dquot, warntype))\n\t\treturn;\n\twarn->w_type = warntype;\n\twarn->w_sb = dquot->dq_sb;\n\twarn->w_dq_id = dquot->dq_id;\n}\n\n \nstatic void flush_warnings(struct dquot_warn *warn)\n{\n\tint i;\n\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (warn[i].w_type == QUOTA_NL_NOWARN)\n\t\t\tcontinue;\n#ifdef CONFIG_PRINT_QUOTA_WARNING\n\t\tprint_warning(&warn[i]);\n#endif\n\t\tquota_send_warning(warn[i].w_dq_id,\n\t\t\t\t   warn[i].w_sb->s_dev, warn[i].w_type);\n\t}\n}\n\nstatic int ignore_hardlimit(struct dquot *dquot)\n{\n\tstruct mem_dqinfo *info = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\n\n\treturn capable(CAP_SYS_RESOURCE) &&\n\t       (info->dqi_format->qf_fmt_id != QFMT_VFS_OLD ||\n\t\t!(info->dqi_flags & DQF_ROOT_SQUASH));\n}\n\nstatic int dquot_add_inodes(struct dquot *dquot, qsize_t inodes,\n\t\t\t    struct dquot_warn *warn)\n{\n\tqsize_t newinodes;\n\tint ret = 0;\n\n\tspin_lock(&dquot->dq_dqb_lock);\n\tnewinodes = dquot->dq_dqb.dqb_curinodes + inodes;\n\tif (!sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type) ||\n\t    test_bit(DQ_FAKE_B, &dquot->dq_flags))\n\t\tgoto add;\n\n\tif (dquot->dq_dqb.dqb_ihardlimit &&\n\t    newinodes > dquot->dq_dqb.dqb_ihardlimit &&\n            !ignore_hardlimit(dquot)) {\n\t\tprepare_warning(warn, dquot, QUOTA_NL_IHARDWARN);\n\t\tret = -EDQUOT;\n\t\tgoto out;\n\t}\n\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    newinodes > dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_itime &&\n\t    ktime_get_real_seconds() >= dquot->dq_dqb.dqb_itime &&\n            !ignore_hardlimit(dquot)) {\n\t\tprepare_warning(warn, dquot, QUOTA_NL_ISOFTLONGWARN);\n\t\tret = -EDQUOT;\n\t\tgoto out;\n\t}\n\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    newinodes > dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_itime == 0) {\n\t\tprepare_warning(warn, dquot, QUOTA_NL_ISOFTWARN);\n\t\tdquot->dq_dqb.dqb_itime = ktime_get_real_seconds() +\n\t\t    sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type].dqi_igrace;\n\t}\nadd:\n\tdquot->dq_dqb.dqb_curinodes = newinodes;\n\nout:\n\tspin_unlock(&dquot->dq_dqb_lock);\n\treturn ret;\n}\n\nstatic int dquot_add_space(struct dquot *dquot, qsize_t space,\n\t\t\t   qsize_t rsv_space, unsigned int flags,\n\t\t\t   struct dquot_warn *warn)\n{\n\tqsize_t tspace;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint ret = 0;\n\n\tspin_lock(&dquot->dq_dqb_lock);\n\tif (!sb_has_quota_limits_enabled(sb, dquot->dq_id.type) ||\n\t    test_bit(DQ_FAKE_B, &dquot->dq_flags))\n\t\tgoto finish;\n\n\ttspace = dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace\n\t\t+ space + rsv_space;\n\n\tif (dquot->dq_dqb.dqb_bhardlimit &&\n\t    tspace > dquot->dq_dqb.dqb_bhardlimit &&\n            !ignore_hardlimit(dquot)) {\n\t\tif (flags & DQUOT_SPACE_WARN)\n\t\t\tprepare_warning(warn, dquot, QUOTA_NL_BHARDWARN);\n\t\tret = -EDQUOT;\n\t\tgoto finish;\n\t}\n\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    tspace > dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_btime &&\n\t    ktime_get_real_seconds() >= dquot->dq_dqb.dqb_btime &&\n            !ignore_hardlimit(dquot)) {\n\t\tif (flags & DQUOT_SPACE_WARN)\n\t\t\tprepare_warning(warn, dquot, QUOTA_NL_BSOFTLONGWARN);\n\t\tret = -EDQUOT;\n\t\tgoto finish;\n\t}\n\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    tspace > dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_btime == 0) {\n\t\tif (flags & DQUOT_SPACE_WARN) {\n\t\t\tprepare_warning(warn, dquot, QUOTA_NL_BSOFTWARN);\n\t\t\tdquot->dq_dqb.dqb_btime = ktime_get_real_seconds() +\n\t\t\t    sb_dqopt(sb)->info[dquot->dq_id.type].dqi_bgrace;\n\t\t} else {\n\t\t\t \n\t\t\tret = -EDQUOT;\n\t\t\tgoto finish;\n\t\t}\n\t}\nfinish:\n\t \n\tif (flags & DQUOT_SPACE_NOFAIL)\n\t\tret = 0;\n\tif (!ret) {\n\t\tdquot->dq_dqb.dqb_rsvspace += rsv_space;\n\t\tdquot->dq_dqb.dqb_curspace += space;\n\t}\n\tspin_unlock(&dquot->dq_dqb_lock);\n\treturn ret;\n}\n\nstatic int info_idq_free(struct dquot *dquot, qsize_t inodes)\n{\n\tqsize_t newinodes;\n\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\n\t    dquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit ||\n\t    !sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type))\n\t\treturn QUOTA_NL_NOWARN;\n\n\tnewinodes = dquot->dq_dqb.dqb_curinodes - inodes;\n\tif (newinodes <= dquot->dq_dqb.dqb_isoftlimit)\n\t\treturn QUOTA_NL_ISOFTBELOW;\n\tif (dquot->dq_dqb.dqb_curinodes >= dquot->dq_dqb.dqb_ihardlimit &&\n\t    newinodes < dquot->dq_dqb.dqb_ihardlimit)\n\t\treturn QUOTA_NL_IHARDBELOW;\n\treturn QUOTA_NL_NOWARN;\n}\n\nstatic int info_bdq_free(struct dquot *dquot, qsize_t space)\n{\n\tqsize_t tspace;\n\n\ttspace = dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace;\n\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\n\t    tspace <= dquot->dq_dqb.dqb_bsoftlimit)\n\t\treturn QUOTA_NL_NOWARN;\n\n\tif (tspace - space <= dquot->dq_dqb.dqb_bsoftlimit)\n\t\treturn QUOTA_NL_BSOFTBELOW;\n\tif (tspace >= dquot->dq_dqb.dqb_bhardlimit &&\n\t    tspace - space < dquot->dq_dqb.dqb_bhardlimit)\n\t\treturn QUOTA_NL_BHARDBELOW;\n\treturn QUOTA_NL_NOWARN;\n}\n\nstatic int inode_quota_active(const struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn 0;\n\treturn sb_any_quota_loaded(sb) & ~sb_any_quota_suspended(sb);\n}\n\n \nstatic int __dquot_initialize(struct inode *inode, int type)\n{\n\tint cnt, init_needed = 0;\n\tstruct dquot **dquots, *got[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tqsize_t rsv;\n\tint ret = 0;\n\n\tif (!inode_quota_active(inode))\n\t\treturn 0;\n\n\tdquots = i_dquot(inode);\n\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tstruct kqid qid;\n\t\tkprojid_t projid;\n\t\tint rc;\n\t\tstruct dquot *dquot;\n\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\t \n\t\tif (dquots[cnt])\n\t\t\tcontinue;\n\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\n\t\tinit_needed = 1;\n\n\t\tswitch (cnt) {\n\t\tcase USRQUOTA:\n\t\t\tqid = make_kqid_uid(inode->i_uid);\n\t\t\tbreak;\n\t\tcase GRPQUOTA:\n\t\t\tqid = make_kqid_gid(inode->i_gid);\n\t\t\tbreak;\n\t\tcase PRJQUOTA:\n\t\t\trc = inode->i_sb->dq_op->get_projid(inode, &projid);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\tqid = make_kqid_projid(projid);\n\t\t\tbreak;\n\t\t}\n\t\tdquot = dqget(sb, qid);\n\t\tif (IS_ERR(dquot)) {\n\t\t\t \n\t\t\tif (PTR_ERR(dquot) != -ESRCH) {\n\t\t\t\tret = PTR_ERR(dquot);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tdquot = NULL;\n\t\t}\n\t\tgot[cnt] = dquot;\n\t}\n\n\t \n\tif (!init_needed)\n\t\treturn 0;\n\n\tspin_lock(&dq_data_lock);\n\tif (IS_NOQUOTA(inode))\n\t\tgoto out_lock;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\t \n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\t \n\t\tif (!got[cnt])\n\t\t\tcontinue;\n\t\tif (!dquots[cnt]) {\n\t\t\tdquots[cnt] = got[cnt];\n\t\t\tgot[cnt] = NULL;\n\t\t\t \n\t\t\trsv = inode_get_rsv_space(inode);\n\t\t\tif (unlikely(rsv)) {\n\t\t\t\tspin_lock(&inode->i_lock);\n\t\t\t\t \n\t\t\t\trsv = __inode_get_rsv_space(inode);\n\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t\tdquots[cnt]->dq_dqb.dqb_rsvspace += rsv;\n\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t}\n\t\t}\n\t}\nout_lock:\n\tspin_unlock(&dq_data_lock);\nout_put:\n\t \n\tdqput_all(got);\n\n\treturn ret;\n}\n\nint dquot_initialize(struct inode *inode)\n{\n\treturn __dquot_initialize(inode, -1);\n}\nEXPORT_SYMBOL(dquot_initialize);\n\nbool dquot_initialize_needed(struct inode *inode)\n{\n\tstruct dquot **dquots;\n\tint i;\n\n\tif (!inode_quota_active(inode))\n\t\treturn false;\n\n\tdquots = i_dquot(inode);\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tif (!dquots[i] && sb_has_quota_active(inode->i_sb, i))\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(dquot_initialize_needed);\n\n \nstatic void __dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\tstruct dquot **dquots = i_dquot(inode);\n\tstruct dquot *put[MAXQUOTAS];\n\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tput[cnt] = dquots[cnt];\n\t\tdquots[cnt] = NULL;\n\t}\n\tspin_unlock(&dq_data_lock);\n\tdqput_all(put);\n}\n\nvoid dquot_drop(struct inode *inode)\n{\n\tstruct dquot * const *dquots;\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t \n\tdquots = i_dquot(inode);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (dquots[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}\nEXPORT_SYMBOL(dquot_drop);\n\n \nstatic qsize_t *inode_reserved_space(struct inode * inode)\n{\n\t \n\tBUG_ON(!inode->i_sb->dq_op->get_reserved_space);\n\treturn inode->i_sb->dq_op->get_reserved_space(inode);\n}\n\nstatic qsize_t __inode_get_rsv_space(struct inode *inode)\n{\n\tif (!inode->i_sb->dq_op->get_reserved_space)\n\t\treturn 0;\n\treturn *inode_reserved_space(inode);\n}\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode)\n{\n\tqsize_t ret;\n\n\tif (!inode->i_sb->dq_op->get_reserved_space)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tret = __inode_get_rsv_space(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\n \n\n \nint __dquot_alloc_space(struct inode *inode, qsize_t number, int flags)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tint reserve = flags & DQUOT_SPACE_RESERVE;\n\tstruct dquot **dquots;\n\n\tif (!inode_quota_active(inode)) {\n\t\tif (reserve) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\t*inode_reserved_space(inode) += number;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t} else {\n\t\t\tinode_add_bytes(inode, number);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tif (reserve) {\n\t\t\tret = dquot_add_space(dquots[cnt], 0, number, flags,\n\t\t\t\t\t      &warn[cnt]);\n\t\t} else {\n\t\t\tret = dquot_add_space(dquots[cnt], number, 0, flags,\n\t\t\t\t\t      &warn[cnt]);\n\t\t}\n\t\tif (ret) {\n\t\t\t \n\t\t\tfor (cnt--; cnt >= 0; cnt--) {\n\t\t\t\tif (!dquots[cnt])\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t\tif (reserve)\n\t\t\t\t\tdquot_free_reserved_space(dquots[cnt],\n\t\t\t\t\t\t\t\t  number);\n\t\t\t\telse\n\t\t\t\t\tdquot_decr_space(dquots[cnt], number);\n\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t}\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tgoto out_flush_warn;\n\t\t}\n\t}\n\tif (reserve)\n\t\t*inode_reserved_space(inode) += number;\n\telse\n\t\t__inode_add_bytes(inode, number);\n\tspin_unlock(&inode->i_lock);\n\n\tif (reserve)\n\t\tgoto out_flush_warn;\n\tmark_all_dquot_dirty(dquots);\nout_flush_warn:\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(__dquot_alloc_space);\n\n \nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots;\n\n\tif (!inode_quota_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = dquot_add_inodes(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret) {\n\t\t\tfor (cnt--; cnt >= 0; cnt--) {\n\t\t\t\tif (!dquots[cnt])\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t\t\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);\n\t\t\t}\n\t\t\tgoto warn_put_all;\n\t\t}\n\t}\n\nwarn_put_all:\n\tspin_unlock(&inode->i_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_alloc_inode);\n\n \nint dquot_claim_space_nodirty(struct inode *inode, qsize_t number)\n{\n\tstruct dquot **dquots;\n\tint cnt, index;\n\n\tif (!inode_quota_active(inode)) {\n\t\tspin_lock(&inode->i_lock);\n\t\t*inode_reserved_space(inode) -= number;\n\t\t__inode_add_bytes(inode, number);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn 0;\n\t}\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (dquots[cnt]) {\n\t\t\tstruct dquot *dquot = dquots[cnt];\n\n\t\t\tspin_lock(&dquot->dq_dqb_lock);\n\t\t\tif (WARN_ON_ONCE(dquot->dq_dqb.dqb_rsvspace < number))\n\t\t\t\tnumber = dquot->dq_dqb.dqb_rsvspace;\n\t\t\tdquot->dq_dqb.dqb_curspace += number;\n\t\t\tdquot->dq_dqb.dqb_rsvspace -= number;\n\t\t\tspin_unlock(&dquot->dq_dqb_lock);\n\t\t}\n\t}\n\t \n\t*inode_reserved_space(inode) -= number;\n\t__inode_add_bytes(inode, number);\n\tspin_unlock(&inode->i_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_claim_space_nodirty);\n\n \nvoid dquot_reclaim_space_nodirty(struct inode *inode, qsize_t number)\n{\n\tstruct dquot **dquots;\n\tint cnt, index;\n\n\tif (!inode_quota_active(inode)) {\n\t\tspin_lock(&inode->i_lock);\n\t\t*inode_reserved_space(inode) += number;\n\t\t__inode_sub_bytes(inode, number);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (dquots[cnt]) {\n\t\t\tstruct dquot *dquot = dquots[cnt];\n\n\t\t\tspin_lock(&dquot->dq_dqb_lock);\n\t\t\tif (WARN_ON_ONCE(dquot->dq_dqb.dqb_curspace < number))\n\t\t\t\tnumber = dquot->dq_dqb.dqb_curspace;\n\t\t\tdquot->dq_dqb.dqb_rsvspace += number;\n\t\t\tdquot->dq_dqb.dqb_curspace -= number;\n\t\t\tspin_unlock(&dquot->dq_dqb_lock);\n\t\t}\n\t}\n\t \n\t*inode_reserved_space(inode) += number;\n\t__inode_sub_bytes(inode, number);\n\tspin_unlock(&inode->i_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\treturn;\n}\nEXPORT_SYMBOL(dquot_reclaim_space_nodirty);\n\n \nvoid __dquot_free_space(struct inode *inode, qsize_t number, int flags)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot **dquots;\n\tint reserve = flags & DQUOT_SPACE_RESERVE, index;\n\n\tif (!inode_quota_active(inode)) {\n\t\tif (reserve) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\t*inode_reserved_space(inode) -= number;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t} else {\n\t\t\tinode_sub_bytes(inode, number);\n\t\t}\n\t\treturn;\n\t}\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);\n\t\twtype = info_bdq_free(dquots[cnt], number);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tif (reserve)\n\t\t\tdquot_free_reserved_space(dquots[cnt], number);\n\t\telse\n\t\t\tdquot_decr_space(dquots[cnt], number);\n\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);\n\t}\n\tif (reserve)\n\t\t*inode_reserved_space(inode) -= number;\n\telse\n\t\t__inode_sub_bytes(inode, number);\n\tspin_unlock(&inode->i_lock);\n\n\tif (reserve)\n\t\tgoto out_unlock;\n\tmark_all_dquot_dirty(dquots);\nout_unlock:\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}\nEXPORT_SYMBOL(__dquot_free_space);\n\n \nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots;\n\tint index;\n\n\tif (!inode_quota_active(inode))\n\t\treturn;\n\n\tdquots = i_dquot(inode);\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&inode->i_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tspin_lock(&dquots[cnt]->dq_dqb_lock);\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t\tspin_unlock(&dquots[cnt]->dq_dqb_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}\nEXPORT_SYMBOL(dquot_free_inode);\n\n \nint __dquot_transfer(struct inode *inode, struct dquot **transfer_to)\n{\n\tqsize_t cur_space;\n\tqsize_t rsv_space = 0;\n\tqsize_t inode_usage = 1;\n\tstruct dquot *transfer_from[MAXQUOTAS] = {};\n\tint cnt, ret = 0;\n\tchar is_valid[MAXQUOTAS] = {};\n\tstruct dquot_warn warn_to[MAXQUOTAS];\n\tstruct dquot_warn warn_from_inodes[MAXQUOTAS];\n\tstruct dquot_warn warn_from_space[MAXQUOTAS];\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn 0;\n\n\tif (inode->i_sb->dq_op->get_inode_usage) {\n\t\tret = inode->i_sb->dq_op->get_inode_usage(inode, &inode_usage);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\twarn_to[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_inodes[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_space[cnt].w_type = QUOTA_NL_NOWARN;\n\t}\n\n\tspin_lock(&dq_data_lock);\n\tspin_lock(&inode->i_lock);\n\tif (IS_NOQUOTA(inode)) {\t \n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&dq_data_lock);\n\t\treturn 0;\n\t}\n\tcur_space = __inode_get_bytes(inode);\n\trsv_space = __inode_get_rsv_space(inode);\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\t \n\t\tif (!transfer_to[cnt])\n\t\t\tcontinue;\n\t\t \n\t\tif (!sb_has_quota_active(inode->i_sb, cnt))\n\t\t\tcontinue;\n\t\tis_valid[cnt] = 1;\n\t\ttransfer_from[cnt] = i_dquot(inode)[cnt];\n\t\tret = dquot_add_inodes(transfer_to[cnt], inode_usage,\n\t\t\t\t       &warn_to[cnt]);\n\t\tif (ret)\n\t\t\tgoto over_quota;\n\t\tret = dquot_add_space(transfer_to[cnt], cur_space, rsv_space,\n\t\t\t\t      DQUOT_SPACE_WARN, &warn_to[cnt]);\n\t\tif (ret) {\n\t\t\tspin_lock(&transfer_to[cnt]->dq_dqb_lock);\n\t\t\tdquot_decr_inodes(transfer_to[cnt], inode_usage);\n\t\t\tspin_unlock(&transfer_to[cnt]->dq_dqb_lock);\n\t\t\tgoto over_quota;\n\t\t}\n\t}\n\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!is_valid[cnt])\n\t\t\tcontinue;\n\t\t \n\t\tif (transfer_from[cnt]) {\n\t\t\tint wtype;\n\n\t\t\tspin_lock(&transfer_from[cnt]->dq_dqb_lock);\n\t\t\twtype = info_idq_free(transfer_from[cnt], inode_usage);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_inodes[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\twtype = info_bdq_free(transfer_from[cnt],\n\t\t\t\t\t      cur_space + rsv_space);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_space[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\tdquot_decr_inodes(transfer_from[cnt], inode_usage);\n\t\t\tdquot_decr_space(transfer_from[cnt], cur_space);\n\t\t\tdquot_free_reserved_space(transfer_from[cnt],\n\t\t\t\t\t\t  rsv_space);\n\t\t\tspin_unlock(&transfer_from[cnt]->dq_dqb_lock);\n\t\t}\n\t\ti_dquot(inode)[cnt] = transfer_to[cnt];\n\t}\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&dq_data_lock);\n\n\tmark_all_dquot_dirty(transfer_from);\n\tmark_all_dquot_dirty(transfer_to);\n\tflush_warnings(warn_to);\n\tflush_warnings(warn_from_inodes);\n\tflush_warnings(warn_from_space);\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (is_valid[cnt])\n\t\t\ttransfer_to[cnt] = transfer_from[cnt];\n\treturn 0;\nover_quota:\n\t \n\tfor (cnt--; cnt >= 0; cnt--) {\n\t\tif (!is_valid[cnt])\n\t\t\tcontinue;\n\t\tspin_lock(&transfer_to[cnt]->dq_dqb_lock);\n\t\tdquot_decr_inodes(transfer_to[cnt], inode_usage);\n\t\tdquot_decr_space(transfer_to[cnt], cur_space);\n\t\tdquot_free_reserved_space(transfer_to[cnt], rsv_space);\n\t\tspin_unlock(&transfer_to[cnt]->dq_dqb_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&dq_data_lock);\n\tflush_warnings(warn_to);\n\treturn ret;\n}\nEXPORT_SYMBOL(__dquot_transfer);\n\n \nint dquot_transfer(struct mnt_idmap *idmap, struct inode *inode,\n\t\t   struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct dquot *dquot;\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!inode_quota_active(inode))\n\t\treturn 0;\n\n\tif (i_uid_needs_update(idmap, iattr, inode)) {\n\t\tkuid_t kuid = from_vfsuid(idmap, i_user_ns(inode),\n\t\t\t\t\t  iattr->ia_vfsuid);\n\n\t\tdquot = dqget(sb, make_kqid_uid(kuid));\n\t\tif (IS_ERR(dquot)) {\n\t\t\tif (PTR_ERR(dquot) != -ESRCH) {\n\t\t\t\tret = PTR_ERR(dquot);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tdquot = NULL;\n\t\t}\n\t\ttransfer_to[USRQUOTA] = dquot;\n\t}\n\tif (i_gid_needs_update(idmap, iattr, inode)) {\n\t\tkgid_t kgid = from_vfsgid(idmap, i_user_ns(inode),\n\t\t\t\t\t  iattr->ia_vfsgid);\n\n\t\tdquot = dqget(sb, make_kqid_gid(kgid));\n\t\tif (IS_ERR(dquot)) {\n\t\t\tif (PTR_ERR(dquot) != -ESRCH) {\n\t\t\t\tret = PTR_ERR(dquot);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tdquot = NULL;\n\t\t}\n\t\ttransfer_to[GRPQUOTA] = dquot;\n\t}\n\tret = __dquot_transfer(inode, transfer_to);\nout_put:\n\tdqput_all(transfer_to);\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_transfer);\n\n \nint dquot_commit_info(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\treturn dqopt->ops[type]->write_file_info(sb, type);\n}\nEXPORT_SYMBOL(dquot_commit_info);\n\nint dquot_get_next_id(struct super_block *sb, struct kqid *qid)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tif (!sb_has_quota_active(sb, qid->type))\n\t\treturn -ESRCH;\n\tif (!dqopt->ops[qid->type]->get_next_id)\n\t\treturn -ENOSYS;\n\treturn dqopt->ops[qid->type]->get_next_id(sb, qid);\n}\nEXPORT_SYMBOL(dquot_get_next_id);\n\n \nconst struct dquot_operations dquot_operations = {\n\t.write_dquot\t= dquot_commit,\n\t.acquire_dquot\t= dquot_acquire,\n\t.release_dquot\t= dquot_release,\n\t.mark_dirty\t= dquot_mark_dquot_dirty,\n\t.write_info\t= dquot_commit_info,\n\t.alloc_dquot\t= dquot_alloc,\n\t.destroy_dquot\t= dquot_destroy,\n\t.get_next_id\t= dquot_get_next_id,\n};\nEXPORT_SYMBOL(dquot_operations);\n\n \nint dquot_file_open(struct inode *inode, struct file *file)\n{\n\tint error;\n\n\terror = generic_file_open(inode, file);\n\tif (!error && (file->f_mode & FMODE_WRITE))\n\t\terror = dquot_initialize(inode);\n\treturn error;\n}\nEXPORT_SYMBOL(dquot_file_open);\n\nstatic void vfs_cleanup_quota_inode(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode = dqopt->files[type];\n\n\tif (!inode)\n\t\treturn;\n\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\n\t\tinode_lock(inode);\n\t\tinode->i_flags &= ~S_NOQUOTA;\n\t\tinode_unlock(inode);\n\t}\n\tdqopt->files[type] = NULL;\n\tiput(inode);\n}\n\n \nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\t \n\tif (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))\n\t\tup_read(&sb->s_umount);\n\n\t \n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t \n\tif (!sb_any_quota_loaded(sb))\n\t\treturn 0;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t \n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tvfs_cleanup_quota_inode(sb, cnt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t \n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t \n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t \n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\n\t \n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t \n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t \n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (!sb_has_quota_loaded(sb, cnt) && dqopt->files[cnt]) {\n\t\t\tinode_lock(dqopt->files[cnt]);\n\t\t\ttruncate_inode_pages(&dqopt->files[cnt]->i_data, 0);\n\t\t\tinode_unlock(dqopt->files[cnt]);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\t \n\tif (flags & DQUOT_SUSPENDED)\n\t\treturn 0;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tvfs_cleanup_quota_inode(sb, cnt);\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_disable);\n\nint dquot_quota_off(struct super_block *sb, int type)\n{\n\treturn dquot_disable(sb, type,\n\t\t\t     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n}\nEXPORT_SYMBOL(dquot_quota_off);\n\n \n\nstatic int vfs_setup_quota_inode(struct inode *inode, int type)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tif (is_bad_inode(inode))\n\t\treturn -EUCLEAN;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\tif (IS_RDONLY(inode))\n\t\treturn -EROFS;\n\tif (sb_has_quota_loaded(sb, type))\n\t\treturn -EBUSY;\n\n\t \n\tif (IS_ENCRYPTED(inode))\n\t\treturn -EINVAL;\n\n\tdqopt->files[type] = igrab(inode);\n\tif (!dqopt->files[type])\n\t\treturn -EIO;\n\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\n\t\t \n\t\tinode_lock(inode);\n\t\tinode->i_flags |= S_NOQUOTA;\n\t\tinode_unlock(inode);\n\t\t \n\t\t__dquot_drop(inode);\n\t}\n\treturn 0;\n}\n\nint dquot_load_quota_sb(struct super_block *sb, int type, int format_id,\n\tunsigned int flags)\n{\n\tstruct quota_format_type *fmt = find_quota_format(format_id);\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint error;\n\n\tlockdep_assert_held_write(&sb->s_umount);\n\n\t \n\tBUG_ON(flags & DQUOT_SUSPENDED);\n\n\tif (!fmt)\n\t\treturn -ESRCH;\n\tif (!sb->dq_op || !sb->s_qcop ||\n\t    (type == PRJQUOTA && sb->dq_op->get_projid == NULL)) {\n\t\terror = -EINVAL;\n\t\tgoto out_fmt;\n\t}\n\t \n\tif (sb->s_user_ns != &init_user_ns) {\n\t\terror = -EINVAL;\n\t\tgoto out_fmt;\n\t}\n\t \n\tif (!(flags & DQUOT_USAGE_ENABLED)) {\n\t\terror = -EINVAL;\n\t\tgoto out_fmt;\n\t}\n\tif (sb_has_quota_loaded(sb, type)) {\n\t\terror = -EBUSY;\n\t\tgoto out_fmt;\n\t}\n\n\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\n\t\t \n\t\tsync_filesystem(sb);\n\t\tinvalidate_bdev(sb->s_bdev);\n\t}\n\n\terror = -EINVAL;\n\tif (!fmt->qf_ops->check_quota_file(sb, type))\n\t\tgoto out_fmt;\n\n\tdqopt->ops[type] = fmt->qf_ops;\n\tdqopt->info[type].dqi_format = fmt;\n\tdqopt->info[type].dqi_fmt_id = format_id;\n\tINIT_LIST_HEAD(&dqopt->info[type].dqi_dirty_list);\n\terror = dqopt->ops[type]->read_file_info(sb, type);\n\tif (error < 0)\n\t\tgoto out_fmt;\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE) {\n\t\tspin_lock(&dq_data_lock);\n\t\tdqopt->info[type].dqi_flags |= DQF_SYS_FILE;\n\t\tspin_unlock(&dq_data_lock);\n\t}\n\tspin_lock(&dq_state_lock);\n\tdqopt->flags |= dquot_state_flag(flags, type);\n\tspin_unlock(&dq_state_lock);\n\n\terror = add_dquot_ref(sb, type);\n\tif (error)\n\t\tdquot_disable(sb, type,\n\t\t\t      DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\treturn error;\nout_fmt:\n\tput_quota_format(fmt);\n\n\treturn error;\n}\nEXPORT_SYMBOL(dquot_load_quota_sb);\n\n \nint dquot_load_quota_inode(struct inode *inode, int type, int format_id,\n\tunsigned int flags)\n{\n\tint err;\n\n\terr = vfs_setup_quota_inode(inode, type);\n\tif (err < 0)\n\t\treturn err;\n\terr = dquot_load_quota_sb(inode->i_sb, type, format_id, flags);\n\tif (err < 0)\n\t\tvfs_cleanup_quota_inode(inode->i_sb, type);\n\treturn err;\n}\nEXPORT_SYMBOL(dquot_load_quota_inode);\n\n \nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\t \n\tif (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))\n\t\tup_read(&sb->s_umount);\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_suspended(sb, cnt))\n\t\t\tcontinue;\n\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = dquot_load_quota_sb(sb, cnt, dqopt->info[cnt].dqi_fmt_id,\n\t\t\t\t\t  flags);\n\t\tif (ret < 0)\n\t\t\tvfs_cleanup_quota_inode(sb, cnt);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dquot_resume);\n\nint dquot_quota_on(struct super_block *sb, int type, int format_id,\n\t\t   const struct path *path)\n{\n\tint error = security_quota_on(path->dentry);\n\tif (error)\n\t\treturn error;\n\t \n\tif (path->dentry->d_sb != sb)\n\t\terror = -EXDEV;\n\telse\n\t\terror = dquot_load_quota_inode(d_inode(path->dentry), type,\n\t\t\t\t\t     format_id, DQUOT_USAGE_ENABLED |\n\t\t\t\t\t     DQUOT_LIMITS_ENABLED);\n\treturn error;\n}\nEXPORT_SYMBOL(dquot_quota_on);\n\n \nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\n\t\tint format_id, int type)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tdentry = lookup_positive_unlocked(qf_name, sb->s_root, strlen(qf_name));\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = security_quota_on(dentry);\n\tif (!error)\n\t\terror = dquot_load_quota_inode(d_inode(dentry), type, format_id,\n\t\t\t\tDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tdput(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(dquot_quota_on_mount);\n\nstatic int dquot_quota_enable(struct super_block *sb, unsigned int flags)\n{\n\tint ret;\n\tint type;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE))\n\t\treturn -ENOSYS;\n\t \n\tflags &= ~(FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT | FS_QUOTA_PDQ_ACCT);\n\tif (!flags)\n\t\treturn -EINVAL;\n\tfor (type = 0; type < MAXQUOTAS; type++) {\n\t\tif (!(flags & qtype_enforce_flag(type)))\n\t\t\tcontinue;\n\t\t \n\t\tif (!sb_has_quota_usage_enabled(sb, type)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (sb_has_quota_limits_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\t\tspin_lock(&dq_state_lock);\n\t\tdqopt->flags |= dquot_state_flag(DQUOT_LIMITS_ENABLED, type);\n\t\tspin_unlock(&dq_state_lock);\n\t}\n\treturn 0;\nout_err:\n\t \n\tfor (type--; type >= 0; type--)  {\n\t\tif (flags & qtype_enforce_flag(type))\n\t\t\tdquot_disable(sb, type, DQUOT_LIMITS_ENABLED);\n\t}\n\t \n\tif (ret == -EBUSY)\n\t\tret = -EEXIST;\n\treturn ret;\n}\n\nstatic int dquot_quota_disable(struct super_block *sb, unsigned int flags)\n{\n\tint ret;\n\tint type;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE))\n\t\treturn -ENOSYS;\n\t \n\tif (flags &\n\t\t  (FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT | FS_QUOTA_PDQ_ACCT))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tfor (type = 0; type < MAXQUOTAS; type++)\n\t\tif (!sb_has_quota_limits_enabled(sb, type))\n\t\t\tflags &= ~qtype_enforce_flag(type);\n\t \n\tif (!flags)\n\t\treturn -EEXIST;\n\tfor (type = 0; type < MAXQUOTAS; type++) {\n\t\tif (flags & qtype_enforce_flag(type)) {\n\t\t\tret = dquot_disable(sb, type, DQUOT_LIMITS_ENABLED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\t \n\tfor (type--; type >= 0; type--)  {\n\t\tif (flags & qtype_enforce_flag(type)) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_LIMITS_ENABLED, type);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic void do_get_dqblk(struct dquot *dquot, struct qc_dqblk *di)\n{\n\tstruct mem_dqblk *dm = &dquot->dq_dqb;\n\n\tmemset(di, 0, sizeof(*di));\n\tspin_lock(&dquot->dq_dqb_lock);\n\tdi->d_spc_hardlimit = dm->dqb_bhardlimit;\n\tdi->d_spc_softlimit = dm->dqb_bsoftlimit;\n\tdi->d_ino_hardlimit = dm->dqb_ihardlimit;\n\tdi->d_ino_softlimit = dm->dqb_isoftlimit;\n\tdi->d_space = dm->dqb_curspace + dm->dqb_rsvspace;\n\tdi->d_ino_count = dm->dqb_curinodes;\n\tdi->d_spc_timer = dm->dqb_btime;\n\tdi->d_ino_timer = dm->dqb_itime;\n\tspin_unlock(&dquot->dq_dqb_lock);\n}\n\nint dquot_get_dqblk(struct super_block *sb, struct kqid qid,\n\t\t    struct qc_dqblk *di)\n{\n\tstruct dquot *dquot;\n\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tdo_get_dqblk(dquot, di);\n\tdqput(dquot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_get_dqblk);\n\nint dquot_get_next_dqblk(struct super_block *sb, struct kqid *qid,\n\t\t\t struct qc_dqblk *di)\n{\n\tstruct dquot *dquot;\n\tint err;\n\n\tif (!sb->dq_op->get_next_id)\n\t\treturn -ENOSYS;\n\terr = sb->dq_op->get_next_id(sb, qid);\n\tif (err < 0)\n\t\treturn err;\n\tdquot = dqget(sb, *qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tdo_get_dqblk(dquot, di);\n\tdqput(dquot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_get_next_dqblk);\n\n#define VFS_QC_MASK \\\n\t(QC_SPACE | QC_SPC_SOFT | QC_SPC_HARD | \\\n\t QC_INO_COUNT | QC_INO_SOFT | QC_INO_HARD | \\\n\t QC_SPC_TIMER | QC_INO_TIMER)\n\n \nstatic int do_set_dqblk(struct dquot *dquot, struct qc_dqblk *di)\n{\n\tstruct mem_dqblk *dm = &dquot->dq_dqb;\n\tint check_blim = 0, check_ilim = 0;\n\tstruct mem_dqinfo *dqi = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\n\n\tif (di->d_fieldmask & ~VFS_QC_MASK)\n\t\treturn -EINVAL;\n\n\tif (((di->d_fieldmask & QC_SPC_SOFT) &&\n\t     di->d_spc_softlimit > dqi->dqi_max_spc_limit) ||\n\t    ((di->d_fieldmask & QC_SPC_HARD) &&\n\t     di->d_spc_hardlimit > dqi->dqi_max_spc_limit) ||\n\t    ((di->d_fieldmask & QC_INO_SOFT) &&\n\t     (di->d_ino_softlimit > dqi->dqi_max_ino_limit)) ||\n\t    ((di->d_fieldmask & QC_INO_HARD) &&\n\t     (di->d_ino_hardlimit > dqi->dqi_max_ino_limit)))\n\t\treturn -ERANGE;\n\n\tspin_lock(&dquot->dq_dqb_lock);\n\tif (di->d_fieldmask & QC_SPACE) {\n\t\tdm->dqb_curspace = di->d_space - dm->dqb_rsvspace;\n\t\tcheck_blim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t}\n\n\tif (di->d_fieldmask & QC_SPC_SOFT)\n\t\tdm->dqb_bsoftlimit = di->d_spc_softlimit;\n\tif (di->d_fieldmask & QC_SPC_HARD)\n\t\tdm->dqb_bhardlimit = di->d_spc_hardlimit;\n\tif (di->d_fieldmask & (QC_SPC_SOFT | QC_SPC_HARD)) {\n\t\tcheck_blim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t}\n\n\tif (di->d_fieldmask & QC_INO_COUNT) {\n\t\tdm->dqb_curinodes = di->d_ino_count;\n\t\tcheck_ilim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t}\n\n\tif (di->d_fieldmask & QC_INO_SOFT)\n\t\tdm->dqb_isoftlimit = di->d_ino_softlimit;\n\tif (di->d_fieldmask & QC_INO_HARD)\n\t\tdm->dqb_ihardlimit = di->d_ino_hardlimit;\n\tif (di->d_fieldmask & (QC_INO_SOFT | QC_INO_HARD)) {\n\t\tcheck_ilim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t}\n\n\tif (di->d_fieldmask & QC_SPC_TIMER) {\n\t\tdm->dqb_btime = di->d_spc_timer;\n\t\tcheck_blim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t}\n\n\tif (di->d_fieldmask & QC_INO_TIMER) {\n\t\tdm->dqb_itime = di->d_ino_timer;\n\t\tcheck_ilim = 1;\n\t\tset_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\t}\n\n\tif (check_blim) {\n\t\tif (!dm->dqb_bsoftlimit ||\n\t\t    dm->dqb_curspace + dm->dqb_rsvspace <= dm->dqb_bsoftlimit) {\n\t\t\tdm->dqb_btime = 0;\n\t\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t\t} else if (!(di->d_fieldmask & QC_SPC_TIMER))\n\t\t\t \n\t\t\tdm->dqb_btime = ktime_get_real_seconds() + dqi->dqi_bgrace;\n\t}\n\tif (check_ilim) {\n\t\tif (!dm->dqb_isoftlimit ||\n\t\t    dm->dqb_curinodes <= dm->dqb_isoftlimit) {\n\t\t\tdm->dqb_itime = 0;\n\t\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t\t} else if (!(di->d_fieldmask & QC_INO_TIMER))\n\t\t\t \n\t\t\tdm->dqb_itime = ktime_get_real_seconds() + dqi->dqi_igrace;\n\t}\n\tif (dm->dqb_bhardlimit || dm->dqb_bsoftlimit || dm->dqb_ihardlimit ||\n\t    dm->dqb_isoftlimit)\n\t\tclear_bit(DQ_FAKE_B, &dquot->dq_flags);\n\telse\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tmark_dquot_dirty(dquot);\n\n\treturn 0;\n}\n\nint dquot_set_dqblk(struct super_block *sb, struct kqid qid,\n\t\t  struct qc_dqblk *di)\n{\n\tstruct dquot *dquot;\n\tint rc;\n\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot)) {\n\t\trc = PTR_ERR(dquot);\n\t\tgoto out;\n\t}\n\trc = do_set_dqblk(dquot, di);\n\tdqput(dquot);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(dquot_set_dqblk);\n\n \nint dquot_get_state(struct super_block *sb, struct qc_state *state)\n{\n\tstruct mem_dqinfo *mi;\n\tstruct qc_type_state *tstate;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint type;\n\n\tmemset(state, 0, sizeof(*state));\n\tfor (type = 0; type < MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_active(sb, type))\n\t\t\tcontinue;\n\t\ttstate = state->s_state + type;\n\t\tmi = sb_dqopt(sb)->info + type;\n\t\ttstate->flags = QCI_ACCT_ENABLED;\n\t\tspin_lock(&dq_data_lock);\n\t\tif (mi->dqi_flags & DQF_SYS_FILE)\n\t\t\ttstate->flags |= QCI_SYSFILE;\n\t\tif (mi->dqi_flags & DQF_ROOT_SQUASH)\n\t\t\ttstate->flags |= QCI_ROOT_SQUASH;\n\t\tif (sb_has_quota_limits_enabled(sb, type))\n\t\t\ttstate->flags |= QCI_LIMITS_ENFORCED;\n\t\ttstate->spc_timelimit = mi->dqi_bgrace;\n\t\ttstate->ino_timelimit = mi->dqi_igrace;\n\t\tif (dqopt->files[type]) {\n\t\t\ttstate->ino = dqopt->files[type]->i_ino;\n\t\t\ttstate->blocks = dqopt->files[type]->i_blocks;\n\t\t}\n\t\ttstate->nextents = 1;\t \n\t\tspin_unlock(&dq_data_lock);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(dquot_get_state);\n\n \nint dquot_set_dqinfo(struct super_block *sb, int type, struct qc_info *ii)\n{\n\tstruct mem_dqinfo *mi;\n\n\tif ((ii->i_fieldmask & QC_WARNS_MASK) ||\n\t    (ii->i_fieldmask & QC_RT_SPC_TIMER))\n\t\treturn -EINVAL;\n\tif (!sb_has_quota_active(sb, type))\n\t\treturn -ESRCH;\n\tmi = sb_dqopt(sb)->info + type;\n\tif (ii->i_fieldmask & QC_FLAGS) {\n\t\tif ((ii->i_flags & QCI_ROOT_SQUASH &&\n\t\t     mi->dqi_format->qf_fmt_id != QFMT_VFS_OLD))\n\t\t\treturn -EINVAL;\n\t}\n\tspin_lock(&dq_data_lock);\n\tif (ii->i_fieldmask & QC_SPC_TIMER)\n\t\tmi->dqi_bgrace = ii->i_spc_timelimit;\n\tif (ii->i_fieldmask & QC_INO_TIMER)\n\t\tmi->dqi_igrace = ii->i_ino_timelimit;\n\tif (ii->i_fieldmask & QC_FLAGS) {\n\t\tif (ii->i_flags & QCI_ROOT_SQUASH)\n\t\t\tmi->dqi_flags |= DQF_ROOT_SQUASH;\n\t\telse\n\t\t\tmi->dqi_flags &= ~DQF_ROOT_SQUASH;\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_info_dirty(sb, type);\n\t \n\treturn sb->dq_op->write_info(sb, type);\n}\nEXPORT_SYMBOL(dquot_set_dqinfo);\n\nconst struct quotactl_ops dquot_quotactl_sysfile_ops = {\n\t.quota_enable\t= dquot_quota_enable,\n\t.quota_disable\t= dquot_quota_disable,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_state\t= dquot_get_state,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.get_nextdqblk\t= dquot_get_next_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk\n};\nEXPORT_SYMBOL(dquot_quotactl_sysfile_ops);\n\nstatic int do_proc_dqstats(struct ctl_table *table, int write,\n\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tunsigned int type = (unsigned long *)table->data - dqstats.stat;\n\ts64 value = percpu_counter_sum(&dqstats.counter[type]);\n\n\t \n\tif (value < 0 && (type == DQST_ALLOC_DQUOTS ||\n\t\t\t  type == DQST_FREE_DQUOTS))\n\t\tvalue = 0;\n\n\t \n\tdqstats.stat[type] = value;\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n\nstatic struct ctl_table fs_dqstats_table[] = {\n\t{\n\t\t.procname\t= \"lookups\",\n\t\t.data\t\t= &dqstats.stat[DQST_LOOKUPS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"drops\",\n\t\t.data\t\t= &dqstats.stat[DQST_DROPS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"reads\",\n\t\t.data\t\t= &dqstats.stat[DQST_READS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"writes\",\n\t\t.data\t\t= &dqstats.stat[DQST_WRITES],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"cache_hits\",\n\t\t.data\t\t= &dqstats.stat[DQST_CACHE_HITS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"allocated_dquots\",\n\t\t.data\t\t= &dqstats.stat[DQST_ALLOC_DQUOTS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"free_dquots\",\n\t\t.data\t\t= &dqstats.stat[DQST_FREE_DQUOTS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n\t{\n\t\t.procname\t= \"syncs\",\n\t\t.data\t\t= &dqstats.stat[DQST_SYNCS],\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= do_proc_dqstats,\n\t},\n#ifdef CONFIG_PRINT_QUOTA_WARNING\n\t{\n\t\t.procname\t= \"warnings\",\n\t\t.data\t\t= &flag_print_warnings,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{ },\n};\n\nstatic int __init dquot_init(void)\n{\n\tint i, ret;\n\tunsigned long nr_hash, order;\n\n\tprintk(KERN_NOTICE \"VFS: Disk quotas %s\\n\", __DQUOT_VERSION__);\n\n\tregister_sysctl_init(\"fs/quota\", fs_dqstats_table);\n\n\tdquot_cachep = kmem_cache_create(\"dquot\",\n\t\t\tsizeof(struct dquot), sizeof(unsigned long) * 4,\n\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tNULL);\n\n\torder = 0;\n\tdquot_hash = (struct hlist_head *)__get_free_pages(GFP_KERNEL, order);\n\tif (!dquot_hash)\n\t\tpanic(\"Cannot create dquot hash table\");\n\n\tfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\n\t\tret = percpu_counter_init(&dqstats.counter[i], 0, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tpanic(\"Cannot create dquot stat counters\");\n\t}\n\n\t \n\tnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\n\tdq_hash_bits = ilog2(nr_hash);\n\n\tnr_hash = 1UL << dq_hash_bits;\n\tdq_hash_mask = nr_hash - 1;\n\tfor (i = 0; i < nr_hash; i++)\n\t\tINIT_HLIST_HEAD(dquot_hash + i);\n\n\tpr_info(\"VFS: Dquot-cache hash table entries: %ld (order %ld,\"\n\t\t\" %ld bytes)\\n\", nr_hash, order, (PAGE_SIZE << order));\n\n\tif (register_shrinker(&dqcache_shrinker, \"dquota-cache\"))\n\t\tpanic(\"Cannot register dquot shrinker\");\n\n\treturn 0;\n}\nfs_initcall(dquot_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}