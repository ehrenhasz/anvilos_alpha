{
  "module_name": "quota_v1.c",
  "hash_id": "fea0ee6aaa1db7e7304c5abf6654b586f4ac7dfef9ce15b497f816e7437c3b83",
  "original_prompt": "Ingested from linux-6.6.14/fs/quota/quota_v1.c",
  "human_readable_source": "\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/quota.h>\n#include <linux/quotaops.h>\n#include <linux/dqblk_v1.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <asm/byteorder.h>\n\n#include \"quotaio_v1.h\"\n\nMODULE_AUTHOR(\"Jan Kara\");\nMODULE_DESCRIPTION(\"Old quota format support\");\nMODULE_LICENSE(\"GPL\");\n\n#define QUOTABLOCK_BITS 10\n#define QUOTABLOCK_SIZE (1 << QUOTABLOCK_BITS)\n\nstatic inline qsize_t v1_stoqb(qsize_t space)\n{\n\treturn (space + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS;\n}\n\nstatic inline qsize_t v1_qbtos(qsize_t blocks)\n{\n\treturn blocks << QUOTABLOCK_BITS;\n}\n\nstatic void v1_disk2mem_dqblk(struct mem_dqblk *m, struct v1_disk_dqblk *d)\n{\n\tm->dqb_ihardlimit = d->dqb_ihardlimit;\n\tm->dqb_isoftlimit = d->dqb_isoftlimit;\n\tm->dqb_curinodes = d->dqb_curinodes;\n\tm->dqb_bhardlimit = v1_qbtos(d->dqb_bhardlimit);\n\tm->dqb_bsoftlimit = v1_qbtos(d->dqb_bsoftlimit);\n\tm->dqb_curspace = v1_qbtos(d->dqb_curblocks);\n\tm->dqb_itime = d->dqb_itime;\n\tm->dqb_btime = d->dqb_btime;\n}\n\nstatic void v1_mem2disk_dqblk(struct v1_disk_dqblk *d, struct mem_dqblk *m)\n{\n\td->dqb_ihardlimit = m->dqb_ihardlimit;\n\td->dqb_isoftlimit = m->dqb_isoftlimit;\n\td->dqb_curinodes = m->dqb_curinodes;\n\td->dqb_bhardlimit = v1_stoqb(m->dqb_bhardlimit);\n\td->dqb_bsoftlimit = v1_stoqb(m->dqb_bsoftlimit);\n\td->dqb_curblocks = v1_stoqb(m->dqb_curspace);\n\td->dqb_itime = m->dqb_itime;\n\td->dqb_btime = m->dqb_btime;\n}\n\nstatic int v1_read_dqblk(struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct v1_disk_dqblk dqblk;\n\tstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\n\n\tif (!dqopt->files[type])\n\t\treturn -EINVAL;\n\n\t \n\tmemset(&dqblk, 0, sizeof(struct v1_disk_dqblk));\n\tdquot->dq_sb->s_op->quota_read(dquot->dq_sb, type, (char *)&dqblk,\n\t\t\tsizeof(struct v1_disk_dqblk),\n\t\t\tv1_dqoff(from_kqid(&init_user_ns, dquot->dq_id)));\n\n\tv1_disk2mem_dqblk(&dquot->dq_dqb, &dqblk);\n\tif (dquot->dq_dqb.dqb_bhardlimit == 0 &&\n\t    dquot->dq_dqb.dqb_bsoftlimit == 0 &&\n\t    dquot->dq_dqb.dqb_ihardlimit == 0 &&\n\t    dquot->dq_dqb.dqb_isoftlimit == 0)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tdqstats_inc(DQST_READS);\n\n\treturn 0;\n}\n\nstatic int v1_commit_dqblk(struct dquot *dquot)\n{\n\tshort type = dquot->dq_id.type;\n\tssize_t ret;\n\tstruct v1_disk_dqblk dqblk;\n\n\tv1_mem2disk_dqblk(&dqblk, &dquot->dq_dqb);\n\tif (((type == USRQUOTA) && uid_eq(dquot->dq_id.uid, GLOBAL_ROOT_UID)) ||\n\t    ((type == GRPQUOTA) && gid_eq(dquot->dq_id.gid, GLOBAL_ROOT_GID))) {\n\t\tdqblk.dqb_btime =\n\t\t\tsb_dqopt(dquot->dq_sb)->info[type].dqi_bgrace;\n\t\tdqblk.dqb_itime =\n\t\t\tsb_dqopt(dquot->dq_sb)->info[type].dqi_igrace;\n\t}\n\tret = 0;\n\tif (sb_dqopt(dquot->dq_sb)->files[type])\n\t\tret = dquot->dq_sb->s_op->quota_write(dquot->dq_sb, type,\n\t\t\t(char *)&dqblk, sizeof(struct v1_disk_dqblk),\n\t\t\tv1_dqoff(from_kqid(&init_user_ns, dquot->dq_id)));\n\tif (ret != sizeof(struct v1_disk_dqblk)) {\n\t\tquota_error(dquot->dq_sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\tdqstats_inc(DQST_WRITES);\n\n\treturn ret;\n}\n\n \n#define V2_INITQMAGICS {\\\n\t0xd9c01f11,      \\\n\t0xd9c01927       \\\n}\n\n \nstruct v2_disk_dqheader {\n\t__le32 dqh_magic;         \n\t__le32 dqh_version;       \n};\n\nstatic int v1_check_quota_file(struct super_block *sb, int type)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tulong blocks;\n\tsize_t off;\n\tstruct v2_disk_dqheader dqhead;\n\tssize_t size;\n\tloff_t isize;\n\tstatic const uint quota_magics[] = V2_INITQMAGICS;\n\n\tisize = i_size_read(inode);\n\tif (!isize)\n\t\treturn 0;\n\tblocks = isize >> BLOCK_SIZE_BITS;\n\toff = isize & (BLOCK_SIZE - 1);\n\tif ((blocks % sizeof(struct v1_disk_dqblk) * BLOCK_SIZE + off) %\n\t    sizeof(struct v1_disk_dqblk))\n\t\treturn 0;\n\t \n\tsize = sb->s_op->quota_read(sb, type, (char *)&dqhead,\n\t\t\t\t    sizeof(struct v2_disk_dqheader), 0);\n\tif (size != sizeof(struct v2_disk_dqheader))\n\t\treturn 1;\t \n\tif (le32_to_cpu(dqhead.dqh_magic) != quota_magics[type])\n\t\treturn 1;\t \n\tprintk(KERN_INFO\n\t       \"VFS: %s: Refusing to turn on old quota format on given file.\"\n\t       \" It probably contains newer quota format.\\n\", sb->s_id);\n        return 0;\t\t \n}\n\nstatic int v1_read_file_info(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct v1_disk_dqblk dqblk;\n\tint ret;\n\n\tdown_read(&dqopt->dqio_sem);\n\tret = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\tsizeof(struct v1_disk_dqblk), v1_dqoff(0));\n\tif (ret != sizeof(struct v1_disk_dqblk)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = 0;\n\t \n\tdqopt->info[type].dqi_max_spc_limit = 0xffffffffULL << QUOTABLOCK_BITS;\n\tdqopt->info[type].dqi_max_ino_limit = 0xffffffff;\n\tdqopt->info[type].dqi_igrace =\n\t\t\tdqblk.dqb_itime ? dqblk.dqb_itime : MAX_IQ_TIME;\n\tdqopt->info[type].dqi_bgrace =\n\t\t\tdqblk.dqb_btime ? dqblk.dqb_btime : MAX_DQ_TIME;\nout:\n\tup_read(&dqopt->dqio_sem);\n\treturn ret;\n}\n\nstatic int v1_write_file_info(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct v1_disk_dqblk dqblk;\n\tint ret;\n\n\tdown_write(&dqopt->dqio_sem);\n\tret = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\tsizeof(struct v1_disk_dqblk), v1_dqoff(0));\n\tif (ret != sizeof(struct v1_disk_dqblk)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tspin_lock(&dq_data_lock);\n\tdqopt->info[type].dqi_flags &= ~DQF_INFO_DIRTY;\n\tdqblk.dqb_itime = dqopt->info[type].dqi_igrace;\n\tdqblk.dqb_btime = dqopt->info[type].dqi_bgrace;\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, (char *)&dqblk,\n\t      sizeof(struct v1_disk_dqblk), v1_dqoff(0));\n\tif (ret == sizeof(struct v1_disk_dqblk))\n\t\tret = 0;\n\telse if (ret >= 0)\n\t\tret = -EIO;\nout:\n\tup_write(&dqopt->dqio_sem);\n\treturn ret;\n}\n\nstatic const struct quota_format_ops v1_format_ops = {\n\t.check_quota_file\t= v1_check_quota_file,\n\t.read_file_info\t\t= v1_read_file_info,\n\t.write_file_info\t= v1_write_file_info,\n\t.read_dqblk\t\t= v1_read_dqblk,\n\t.commit_dqblk\t\t= v1_commit_dqblk,\n};\n\nstatic struct quota_format_type v1_quota_format = {\n\t.qf_fmt_id\t= QFMT_VFS_OLD,\n\t.qf_ops\t\t= &v1_format_ops,\n\t.qf_owner\t= THIS_MODULE\n};\n\nstatic int __init init_v1_quota_format(void)\n{\n        return register_quota_format(&v1_quota_format);\n}\n\nstatic void __exit exit_v1_quota_format(void)\n{\n        unregister_quota_format(&v1_quota_format);\n}\n\nmodule_init(init_v1_quota_format);\nmodule_exit(exit_v1_quota_format);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}