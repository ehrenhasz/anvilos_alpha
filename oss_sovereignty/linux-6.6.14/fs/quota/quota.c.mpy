{
  "module_name": "quota.c",
  "hash_id": "c7ddb0e2030f4ee3b351ad4f060ca254ca4604d5dd46104b5ad5c2c258bda5fe",
  "original_prompt": "Ingested from linux-6.6.14/fs/quota/quota.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <asm/current.h>\n#include <linux/blkdev.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/quotaops.h>\n#include <linux/types.h>\n#include <linux/mount.h>\n#include <linux/writeback.h>\n#include <linux/nospec.h>\n#include \"compat.h\"\n#include \"../internal.h\"\n\nstatic int check_quotactl_permission(struct super_block *sb, int type, int cmd,\n\t\t\t\t     qid_t id)\n{\n\tswitch (cmd) {\n\t \n\tcase Q_GETFMT:\n\tcase Q_SYNC:\n\tcase Q_GETINFO:\n\tcase Q_XGETQSTAT:\n\tcase Q_XGETQSTATV:\n\tcase Q_XQUOTASYNC:\n\t\tbreak;\n\t \n\tcase Q_GETQUOTA:\n\tcase Q_XGETQUOTA:\n\t\tif ((type == USRQUOTA && uid_eq(current_euid(), make_kuid(current_user_ns(), id))) ||\n\t\t    (type == GRPQUOTA && in_egroup_p(make_kgid(current_user_ns(), id))))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn security_quotactl(cmd, type, id, sb);\n}\n\nstatic void quota_sync_one(struct super_block *sb, void *arg)\n{\n\tint type = *(int *)arg;\n\n\tif (sb->s_qcop && sb->s_qcop->quota_sync &&\n\t    (sb->s_quota_types & (1 << type)))\n\t\tsb->s_qcop->quota_sync(sb, type);\n}\n\nstatic int quota_sync_all(int type)\n{\n\tint ret;\n\n\tret = security_quotactl(Q_SYNC, type, 0, NULL);\n\tif (!ret)\n\t\titerate_supers(quota_sync_one, &type);\n\treturn ret;\n}\n\nunsigned int qtype_enforce_flag(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn FS_QUOTA_UDQ_ENFD;\n\tcase GRPQUOTA:\n\t\treturn FS_QUOTA_GDQ_ENFD;\n\tcase PRJQUOTA:\n\t\treturn FS_QUOTA_PDQ_ENFD;\n\t}\n\treturn 0;\n}\n\nstatic int quota_quotaon(struct super_block *sb, int type, qid_t id,\n\t\t         const struct path *path)\n{\n\tif (!sb->s_qcop->quota_on && !sb->s_qcop->quota_enable)\n\t\treturn -ENOSYS;\n\tif (sb->s_qcop->quota_enable)\n\t\treturn sb->s_qcop->quota_enable(sb, qtype_enforce_flag(type));\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\treturn sb->s_qcop->quota_on(sb, type, id, path);\n}\n\nstatic int quota_quotaoff(struct super_block *sb, int type)\n{\n\tif (!sb->s_qcop->quota_off && !sb->s_qcop->quota_disable)\n\t\treturn -ENOSYS;\n\tif (sb->s_qcop->quota_disable)\n\t\treturn sb->s_qcop->quota_disable(sb, qtype_enforce_flag(type));\n\treturn sb->s_qcop->quota_off(sb, type);\n}\n\nstatic int quota_getfmt(struct super_block *sb, int type, void __user *addr)\n{\n\t__u32 fmt;\n\n\tif (!sb_has_quota_active(sb, type))\n\t\treturn -ESRCH;\n\tfmt = sb_dqopt(sb)->info[type].dqi_format->qf_fmt_id;\n\tif (copy_to_user(addr, &fmt, sizeof(fmt)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int quota_getinfo(struct super_block *sb, int type, void __user *addr)\n{\n\tstruct qc_state state;\n\tstruct qc_type_state *tstate;\n\tstruct if_dqinfo uinfo;\n\tint ret;\n\n\tif (!sb->s_qcop->get_state)\n\t\treturn -ENOSYS;\n\tret = sb->s_qcop->get_state(sb, &state);\n\tif (ret)\n\t\treturn ret;\n\ttstate = state.s_state + type;\n\tif (!(tstate->flags & QCI_ACCT_ENABLED))\n\t\treturn -ESRCH;\n\tmemset(&uinfo, 0, sizeof(uinfo));\n\tuinfo.dqi_bgrace = tstate->spc_timelimit;\n\tuinfo.dqi_igrace = tstate->ino_timelimit;\n\tif (tstate->flags & QCI_SYSFILE)\n\t\tuinfo.dqi_flags |= DQF_SYS_FILE;\n\tif (tstate->flags & QCI_ROOT_SQUASH)\n\t\tuinfo.dqi_flags |= DQF_ROOT_SQUASH;\n\tuinfo.dqi_valid = IIF_ALL;\n\tif (copy_to_user(addr, &uinfo, sizeof(uinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int quota_setinfo(struct super_block *sb, int type, void __user *addr)\n{\n\tstruct if_dqinfo info;\n\tstruct qc_info qinfo;\n\n\tif (copy_from_user(&info, addr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (!sb->s_qcop->set_info)\n\t\treturn -ENOSYS;\n\tif (info.dqi_valid & ~(IIF_FLAGS | IIF_BGRACE | IIF_IGRACE))\n\t\treturn -EINVAL;\n\tmemset(&qinfo, 0, sizeof(qinfo));\n\tif (info.dqi_valid & IIF_FLAGS) {\n\t\tif (info.dqi_flags & ~DQF_SETINFO_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (info.dqi_flags & DQF_ROOT_SQUASH)\n\t\t\tqinfo.i_flags |= QCI_ROOT_SQUASH;\n\t\tqinfo.i_fieldmask |= QC_FLAGS;\n\t}\n\tif (info.dqi_valid & IIF_BGRACE) {\n\t\tqinfo.i_spc_timelimit = info.dqi_bgrace;\n\t\tqinfo.i_fieldmask |= QC_SPC_TIMER;\n\t}\n\tif (info.dqi_valid & IIF_IGRACE) {\n\t\tqinfo.i_ino_timelimit = info.dqi_igrace;\n\t\tqinfo.i_fieldmask |= QC_INO_TIMER;\n\t}\n\treturn sb->s_qcop->set_info(sb, type, &qinfo);\n}\n\nstatic inline qsize_t qbtos(qsize_t blocks)\n{\n\treturn blocks << QIF_DQBLKSIZE_BITS;\n}\n\nstatic inline qsize_t stoqb(qsize_t space)\n{\n\treturn (space + QIF_DQBLKSIZE - 1) >> QIF_DQBLKSIZE_BITS;\n}\n\nstatic void copy_to_if_dqblk(struct if_dqblk *dst, struct qc_dqblk *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->dqb_bhardlimit = stoqb(src->d_spc_hardlimit);\n\tdst->dqb_bsoftlimit = stoqb(src->d_spc_softlimit);\n\tdst->dqb_curspace = src->d_space;\n\tdst->dqb_ihardlimit = src->d_ino_hardlimit;\n\tdst->dqb_isoftlimit = src->d_ino_softlimit;\n\tdst->dqb_curinodes = src->d_ino_count;\n\tdst->dqb_btime = src->d_spc_timer;\n\tdst->dqb_itime = src->d_ino_timer;\n\tdst->dqb_valid = QIF_ALL;\n}\n\nstatic int quota_getquota(struct super_block *sb, int type, qid_t id,\n\t\t\t  void __user *addr)\n{\n\tstruct kqid qid;\n\tstruct qc_dqblk fdq;\n\tstruct if_dqblk idq;\n\tint ret;\n\n\tif (!sb->s_qcop->get_dqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\tret = sb->s_qcop->get_dqblk(sb, qid, &fdq);\n\tif (ret)\n\t\treturn ret;\n\tcopy_to_if_dqblk(&idq, &fdq);\n\n\tif (compat_need_64bit_alignment_fixup()) {\n\t\tstruct compat_if_dqblk __user *compat_dqblk = addr;\n\n\t\tif (copy_to_user(compat_dqblk, &idq, sizeof(*compat_dqblk)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(idq.dqb_valid, &compat_dqblk->dqb_valid))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(addr, &idq, sizeof(idq)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic int quota_getnextquota(struct super_block *sb, int type, qid_t id,\n\t\t\t  void __user *addr)\n{\n\tstruct kqid qid;\n\tstruct qc_dqblk fdq;\n\tstruct if_nextdqblk idq;\n\tint ret;\n\n\tif (!sb->s_qcop->get_nextdqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\tret = sb->s_qcop->get_nextdqblk(sb, &qid, &fdq);\n\tif (ret)\n\t\treturn ret;\n\t \n\tcopy_to_if_dqblk((struct if_dqblk *)&idq, &fdq);\n\tidq.dqb_id = from_kqid(current_user_ns(), qid);\n\tif (copy_to_user(addr, &idq, sizeof(idq)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void copy_from_if_dqblk(struct qc_dqblk *dst, struct if_dqblk *src)\n{\n\tdst->d_spc_hardlimit = qbtos(src->dqb_bhardlimit);\n\tdst->d_spc_softlimit = qbtos(src->dqb_bsoftlimit);\n\tdst->d_space = src->dqb_curspace;\n\tdst->d_ino_hardlimit = src->dqb_ihardlimit;\n\tdst->d_ino_softlimit = src->dqb_isoftlimit;\n\tdst->d_ino_count = src->dqb_curinodes;\n\tdst->d_spc_timer = src->dqb_btime;\n\tdst->d_ino_timer = src->dqb_itime;\n\n\tdst->d_fieldmask = 0;\n\tif (src->dqb_valid & QIF_BLIMITS)\n\t\tdst->d_fieldmask |= QC_SPC_SOFT | QC_SPC_HARD;\n\tif (src->dqb_valid & QIF_SPACE)\n\t\tdst->d_fieldmask |= QC_SPACE;\n\tif (src->dqb_valid & QIF_ILIMITS)\n\t\tdst->d_fieldmask |= QC_INO_SOFT | QC_INO_HARD;\n\tif (src->dqb_valid & QIF_INODES)\n\t\tdst->d_fieldmask |= QC_INO_COUNT;\n\tif (src->dqb_valid & QIF_BTIME)\n\t\tdst->d_fieldmask |= QC_SPC_TIMER;\n\tif (src->dqb_valid & QIF_ITIME)\n\t\tdst->d_fieldmask |= QC_INO_TIMER;\n}\n\nstatic int quota_setquota(struct super_block *sb, int type, qid_t id,\n\t\t\t  void __user *addr)\n{\n\tstruct qc_dqblk fdq;\n\tstruct if_dqblk idq;\n\tstruct kqid qid;\n\n\tif (compat_need_64bit_alignment_fixup()) {\n\t\tstruct compat_if_dqblk __user *compat_dqblk = addr;\n\n\t\tif (copy_from_user(&idq, compat_dqblk, sizeof(*compat_dqblk)) ||\n\t\t    get_user(idq.dqb_valid, &compat_dqblk->dqb_valid))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_from_user(&idq, addr, sizeof(idq)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!sb->s_qcop->set_dqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\tcopy_from_if_dqblk(&fdq, &idq);\n\treturn sb->s_qcop->set_dqblk(sb, qid, &fdq);\n}\n\nstatic int quota_enable(struct super_block *sb, void __user *addr)\n{\n\t__u32 flags;\n\n\tif (copy_from_user(&flags, addr, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (!sb->s_qcop->quota_enable)\n\t\treturn -ENOSYS;\n\treturn sb->s_qcop->quota_enable(sb, flags);\n}\n\nstatic int quota_disable(struct super_block *sb, void __user *addr)\n{\n\t__u32 flags;\n\n\tif (copy_from_user(&flags, addr, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (!sb->s_qcop->quota_disable)\n\t\treturn -ENOSYS;\n\treturn sb->s_qcop->quota_disable(sb, flags);\n}\n\nstatic int quota_state_to_flags(struct qc_state *state)\n{\n\tint flags = 0;\n\n\tif (state->s_state[USRQUOTA].flags & QCI_ACCT_ENABLED)\n\t\tflags |= FS_QUOTA_UDQ_ACCT;\n\tif (state->s_state[USRQUOTA].flags & QCI_LIMITS_ENFORCED)\n\t\tflags |= FS_QUOTA_UDQ_ENFD;\n\tif (state->s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED)\n\t\tflags |= FS_QUOTA_GDQ_ACCT;\n\tif (state->s_state[GRPQUOTA].flags & QCI_LIMITS_ENFORCED)\n\t\tflags |= FS_QUOTA_GDQ_ENFD;\n\tif (state->s_state[PRJQUOTA].flags & QCI_ACCT_ENABLED)\n\t\tflags |= FS_QUOTA_PDQ_ACCT;\n\tif (state->s_state[PRJQUOTA].flags & QCI_LIMITS_ENFORCED)\n\t\tflags |= FS_QUOTA_PDQ_ENFD;\n\treturn flags;\n}\n\nstatic int quota_getstate(struct super_block *sb, int type,\n\t\t\t  struct fs_quota_stat *fqs)\n{\n\tstruct qc_state state;\n\tint ret;\n\n\tmemset(&state, 0, sizeof (struct qc_state));\n\tret = sb->s_qcop->get_state(sb, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(fqs, 0, sizeof(*fqs));\n\tfqs->qs_version = FS_QSTAT_VERSION;\n\tfqs->qs_flags = quota_state_to_flags(&state);\n\t \n\tif (!fqs->qs_flags)\n\t\treturn -ENOSYS;\n\tfqs->qs_incoredqs = state.s_incoredqs;\n\n\tfqs->qs_btimelimit = state.s_state[type].spc_timelimit;\n\tfqs->qs_itimelimit = state.s_state[type].ino_timelimit;\n\tfqs->qs_rtbtimelimit = state.s_state[type].rt_spc_timelimit;\n\tfqs->qs_bwarnlimit = state.s_state[type].spc_warnlimit;\n\tfqs->qs_iwarnlimit = state.s_state[type].ino_warnlimit;\n\n\t \n\tif (state.s_state[USRQUOTA].ino) {\n\t\tfqs->qs_uquota.qfs_ino = state.s_state[USRQUOTA].ino;\n\t\tfqs->qs_uquota.qfs_nblks = state.s_state[USRQUOTA].blocks;\n\t\tfqs->qs_uquota.qfs_nextents = state.s_state[USRQUOTA].nextents;\n\t}\n\tif (state.s_state[GRPQUOTA].ino) {\n\t\tfqs->qs_gquota.qfs_ino = state.s_state[GRPQUOTA].ino;\n\t\tfqs->qs_gquota.qfs_nblks = state.s_state[GRPQUOTA].blocks;\n\t\tfqs->qs_gquota.qfs_nextents = state.s_state[GRPQUOTA].nextents;\n\t}\n\tif (state.s_state[PRJQUOTA].ino) {\n\t\t \n\t\tif (!(state.s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED)) {\n\t\t\tfqs->qs_gquota.qfs_ino = state.s_state[PRJQUOTA].ino;\n\t\t\tfqs->qs_gquota.qfs_nblks =\n\t\t\t\t\tstate.s_state[PRJQUOTA].blocks;\n\t\t\tfqs->qs_gquota.qfs_nextents =\n\t\t\t\t\tstate.s_state[PRJQUOTA].nextents;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int compat_copy_fs_qfilestat(struct compat_fs_qfilestat __user *to,\n\t\tstruct fs_qfilestat *from)\n{\n\tif (copy_to_user(to, from, sizeof(*to)) ||\n\t    put_user(from->qfs_nextents, &to->qfs_nextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_copy_fs_quota_stat(struct compat_fs_quota_stat __user *to,\n\t\tstruct fs_quota_stat *from)\n{\n\tif (put_user(from->qs_version, &to->qs_version) ||\n\t    put_user(from->qs_flags, &to->qs_flags) ||\n\t    put_user(from->qs_pad, &to->qs_pad) ||\n\t    compat_copy_fs_qfilestat(&to->qs_uquota, &from->qs_uquota) ||\n\t    compat_copy_fs_qfilestat(&to->qs_gquota, &from->qs_gquota) ||\n\t    put_user(from->qs_incoredqs, &to->qs_incoredqs) ||\n\t    put_user(from->qs_btimelimit, &to->qs_btimelimit) ||\n\t    put_user(from->qs_itimelimit, &to->qs_itimelimit) ||\n\t    put_user(from->qs_rtbtimelimit, &to->qs_rtbtimelimit) ||\n\t    put_user(from->qs_bwarnlimit, &to->qs_bwarnlimit) ||\n\t    put_user(from->qs_iwarnlimit, &to->qs_iwarnlimit))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int quota_getxstate(struct super_block *sb, int type, void __user *addr)\n{\n\tstruct fs_quota_stat fqs;\n\tint ret;\n\n\tif (!sb->s_qcop->get_state)\n\t\treturn -ENOSYS;\n\tret = quota_getstate(sb, type, &fqs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (compat_need_64bit_alignment_fixup())\n\t\treturn compat_copy_fs_quota_stat(addr, &fqs);\n\tif (copy_to_user(addr, &fqs, sizeof(fqs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int quota_getstatev(struct super_block *sb, int type,\n\t\t\t   struct fs_quota_statv *fqs)\n{\n\tstruct qc_state state;\n\tint ret;\n\n\tmemset(&state, 0, sizeof (struct qc_state));\n\tret = sb->s_qcop->get_state(sb, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(fqs, 0, sizeof(*fqs));\n\tfqs->qs_version = FS_QSTAT_VERSION;\n\tfqs->qs_flags = quota_state_to_flags(&state);\n\t \n\tif (!fqs->qs_flags)\n\t\treturn -ENOSYS;\n\tfqs->qs_incoredqs = state.s_incoredqs;\n\n\tfqs->qs_btimelimit = state.s_state[type].spc_timelimit;\n\tfqs->qs_itimelimit = state.s_state[type].ino_timelimit;\n\tfqs->qs_rtbtimelimit = state.s_state[type].rt_spc_timelimit;\n\tfqs->qs_bwarnlimit = state.s_state[type].spc_warnlimit;\n\tfqs->qs_iwarnlimit = state.s_state[type].ino_warnlimit;\n\tfqs->qs_rtbwarnlimit = state.s_state[type].rt_spc_warnlimit;\n\n\t \n\tif (state.s_state[USRQUOTA].ino) {\n\t\tfqs->qs_uquota.qfs_ino = state.s_state[USRQUOTA].ino;\n\t\tfqs->qs_uquota.qfs_nblks = state.s_state[USRQUOTA].blocks;\n\t\tfqs->qs_uquota.qfs_nextents = state.s_state[USRQUOTA].nextents;\n\t}\n\tif (state.s_state[GRPQUOTA].ino) {\n\t\tfqs->qs_gquota.qfs_ino = state.s_state[GRPQUOTA].ino;\n\t\tfqs->qs_gquota.qfs_nblks = state.s_state[GRPQUOTA].blocks;\n\t\tfqs->qs_gquota.qfs_nextents = state.s_state[GRPQUOTA].nextents;\n\t}\n\tif (state.s_state[PRJQUOTA].ino) {\n\t\tfqs->qs_pquota.qfs_ino = state.s_state[PRJQUOTA].ino;\n\t\tfqs->qs_pquota.qfs_nblks = state.s_state[PRJQUOTA].blocks;\n\t\tfqs->qs_pquota.qfs_nextents = state.s_state[PRJQUOTA].nextents;\n\t}\n\treturn 0;\n}\n\nstatic int quota_getxstatev(struct super_block *sb, int type, void __user *addr)\n{\n\tstruct fs_quota_statv fqs;\n\tint ret;\n\n\tif (!sb->s_qcop->get_state)\n\t\treturn -ENOSYS;\n\n\tmemset(&fqs, 0, sizeof(fqs));\n\tif (copy_from_user(&fqs, addr, 1))  \n\t\treturn -EFAULT;\n\n\t \n\tswitch (fqs.qs_version) {\n\tcase FS_QSTATV_VERSION1:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = quota_getstatev(sb, type, &fqs);\n\tif (!ret && copy_to_user(addr, &fqs, sizeof(fqs)))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\n \n#define XFS_BB_SHIFT 9\n\nstatic inline u64 quota_bbtob(u64 blocks)\n{\n\treturn blocks << XFS_BB_SHIFT;\n}\n\nstatic inline u64 quota_btobb(u64 bytes)\n{\n\treturn (bytes + (1 << XFS_BB_SHIFT) - 1) >> XFS_BB_SHIFT;\n}\n\nstatic inline s64 copy_from_xfs_dqblk_ts(const struct fs_disk_quota *d,\n\t\t__s32 timer, __s8 timer_hi)\n{\n\tif (d->d_fieldmask & FS_DQ_BIGTIME)\n\t\treturn (u32)timer | (s64)timer_hi << 32;\n\treturn timer;\n}\n\nstatic void copy_from_xfs_dqblk(struct qc_dqblk *dst, struct fs_disk_quota *src)\n{\n\tdst->d_spc_hardlimit = quota_bbtob(src->d_blk_hardlimit);\n\tdst->d_spc_softlimit = quota_bbtob(src->d_blk_softlimit);\n\tdst->d_ino_hardlimit = src->d_ino_hardlimit;\n\tdst->d_ino_softlimit = src->d_ino_softlimit;\n\tdst->d_space = quota_bbtob(src->d_bcount);\n\tdst->d_ino_count = src->d_icount;\n\tdst->d_ino_timer = copy_from_xfs_dqblk_ts(src, src->d_itimer,\n\t\t\t\t\t\t  src->d_itimer_hi);\n\tdst->d_spc_timer = copy_from_xfs_dqblk_ts(src, src->d_btimer,\n\t\t\t\t\t\t  src->d_btimer_hi);\n\tdst->d_ino_warns = src->d_iwarns;\n\tdst->d_spc_warns = src->d_bwarns;\n\tdst->d_rt_spc_hardlimit = quota_bbtob(src->d_rtb_hardlimit);\n\tdst->d_rt_spc_softlimit = quota_bbtob(src->d_rtb_softlimit);\n\tdst->d_rt_space = quota_bbtob(src->d_rtbcount);\n\tdst->d_rt_spc_timer = copy_from_xfs_dqblk_ts(src, src->d_rtbtimer,\n\t\t\t\t\t\t     src->d_rtbtimer_hi);\n\tdst->d_rt_spc_warns = src->d_rtbwarns;\n\tdst->d_fieldmask = 0;\n\tif (src->d_fieldmask & FS_DQ_ISOFT)\n\t\tdst->d_fieldmask |= QC_INO_SOFT;\n\tif (src->d_fieldmask & FS_DQ_IHARD)\n\t\tdst->d_fieldmask |= QC_INO_HARD;\n\tif (src->d_fieldmask & FS_DQ_BSOFT)\n\t\tdst->d_fieldmask |= QC_SPC_SOFT;\n\tif (src->d_fieldmask & FS_DQ_BHARD)\n\t\tdst->d_fieldmask |= QC_SPC_HARD;\n\tif (src->d_fieldmask & FS_DQ_RTBSOFT)\n\t\tdst->d_fieldmask |= QC_RT_SPC_SOFT;\n\tif (src->d_fieldmask & FS_DQ_RTBHARD)\n\t\tdst->d_fieldmask |= QC_RT_SPC_HARD;\n\tif (src->d_fieldmask & FS_DQ_BTIMER)\n\t\tdst->d_fieldmask |= QC_SPC_TIMER;\n\tif (src->d_fieldmask & FS_DQ_ITIMER)\n\t\tdst->d_fieldmask |= QC_INO_TIMER;\n\tif (src->d_fieldmask & FS_DQ_RTBTIMER)\n\t\tdst->d_fieldmask |= QC_RT_SPC_TIMER;\n\tif (src->d_fieldmask & FS_DQ_BWARNS)\n\t\tdst->d_fieldmask |= QC_SPC_WARNS;\n\tif (src->d_fieldmask & FS_DQ_IWARNS)\n\t\tdst->d_fieldmask |= QC_INO_WARNS;\n\tif (src->d_fieldmask & FS_DQ_RTBWARNS)\n\t\tdst->d_fieldmask |= QC_RT_SPC_WARNS;\n\tif (src->d_fieldmask & FS_DQ_BCOUNT)\n\t\tdst->d_fieldmask |= QC_SPACE;\n\tif (src->d_fieldmask & FS_DQ_ICOUNT)\n\t\tdst->d_fieldmask |= QC_INO_COUNT;\n\tif (src->d_fieldmask & FS_DQ_RTBCOUNT)\n\t\tdst->d_fieldmask |= QC_RT_SPACE;\n}\n\nstatic void copy_qcinfo_from_xfs_dqblk(struct qc_info *dst,\n\t\t\t\t       struct fs_disk_quota *src)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->i_spc_timelimit = src->d_btimer;\n\tdst->i_ino_timelimit = src->d_itimer;\n\tdst->i_rt_spc_timelimit = src->d_rtbtimer;\n\tdst->i_ino_warnlimit = src->d_iwarns;\n\tdst->i_spc_warnlimit = src->d_bwarns;\n\tdst->i_rt_spc_warnlimit = src->d_rtbwarns;\n\tif (src->d_fieldmask & FS_DQ_BWARNS)\n\t\tdst->i_fieldmask |= QC_SPC_WARNS;\n\tif (src->d_fieldmask & FS_DQ_IWARNS)\n\t\tdst->i_fieldmask |= QC_INO_WARNS;\n\tif (src->d_fieldmask & FS_DQ_RTBWARNS)\n\t\tdst->i_fieldmask |= QC_RT_SPC_WARNS;\n\tif (src->d_fieldmask & FS_DQ_BTIMER)\n\t\tdst->i_fieldmask |= QC_SPC_TIMER;\n\tif (src->d_fieldmask & FS_DQ_ITIMER)\n\t\tdst->i_fieldmask |= QC_INO_TIMER;\n\tif (src->d_fieldmask & FS_DQ_RTBTIMER)\n\t\tdst->i_fieldmask |= QC_RT_SPC_TIMER;\n}\n\nstatic int quota_setxquota(struct super_block *sb, int type, qid_t id,\n\t\t\t   void __user *addr)\n{\n\tstruct fs_disk_quota fdq;\n\tstruct qc_dqblk qdq;\n\tstruct kqid qid;\n\n\tif (copy_from_user(&fdq, addr, sizeof(fdq)))\n\t\treturn -EFAULT;\n\tif (!sb->s_qcop->set_dqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\t \n\tif (from_kqid(sb->s_user_ns, qid) == 0 &&\n\t    fdq.d_fieldmask & (FS_DQ_WARNS_MASK | FS_DQ_TIMER_MASK)) {\n\t\tstruct qc_info qinfo;\n\t\tint ret;\n\n\t\tif (!sb->s_qcop->set_info)\n\t\t\treturn -EINVAL;\n\t\tcopy_qcinfo_from_xfs_dqblk(&qinfo, &fdq);\n\t\tret = sb->s_qcop->set_info(sb, type, &qinfo);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tfdq.d_fieldmask &= ~(FS_DQ_WARNS_MASK | FS_DQ_TIMER_MASK);\n\t}\n\tcopy_from_xfs_dqblk(&qdq, &fdq);\n\treturn sb->s_qcop->set_dqblk(sb, qid, &qdq);\n}\n\nstatic inline void copy_to_xfs_dqblk_ts(const struct fs_disk_quota *d,\n\t\t__s32 *timer_lo, __s8 *timer_hi, s64 timer)\n{\n\t*timer_lo = timer;\n\tif (d->d_fieldmask & FS_DQ_BIGTIME)\n\t\t*timer_hi = timer >> 32;\n}\n\nstatic inline bool want_bigtime(s64 timer)\n{\n\treturn timer > S32_MAX || timer < S32_MIN;\n}\n\nstatic void copy_to_xfs_dqblk(struct fs_disk_quota *dst, struct qc_dqblk *src,\n\t\t\t      int type, qid_t id)\n{\n\tmemset(dst, 0, sizeof(*dst));\n\tif (want_bigtime(src->d_ino_timer) || want_bigtime(src->d_spc_timer) ||\n\t    want_bigtime(src->d_rt_spc_timer))\n\t\tdst->d_fieldmask |= FS_DQ_BIGTIME;\n\tdst->d_version = FS_DQUOT_VERSION;\n\tdst->d_id = id;\n\tif (type == USRQUOTA)\n\t\tdst->d_flags = FS_USER_QUOTA;\n\telse if (type == PRJQUOTA)\n\t\tdst->d_flags = FS_PROJ_QUOTA;\n\telse\n\t\tdst->d_flags = FS_GROUP_QUOTA;\n\tdst->d_blk_hardlimit = quota_btobb(src->d_spc_hardlimit);\n\tdst->d_blk_softlimit = quota_btobb(src->d_spc_softlimit);\n\tdst->d_ino_hardlimit = src->d_ino_hardlimit;\n\tdst->d_ino_softlimit = src->d_ino_softlimit;\n\tdst->d_bcount = quota_btobb(src->d_space);\n\tdst->d_icount = src->d_ino_count;\n\tcopy_to_xfs_dqblk_ts(dst, &dst->d_itimer, &dst->d_itimer_hi,\n\t\t\t     src->d_ino_timer);\n\tcopy_to_xfs_dqblk_ts(dst, &dst->d_btimer, &dst->d_btimer_hi,\n\t\t\t     src->d_spc_timer);\n\tdst->d_iwarns = src->d_ino_warns;\n\tdst->d_bwarns = src->d_spc_warns;\n\tdst->d_rtb_hardlimit = quota_btobb(src->d_rt_spc_hardlimit);\n\tdst->d_rtb_softlimit = quota_btobb(src->d_rt_spc_softlimit);\n\tdst->d_rtbcount = quota_btobb(src->d_rt_space);\n\tcopy_to_xfs_dqblk_ts(dst, &dst->d_rtbtimer, &dst->d_rtbtimer_hi,\n\t\t\t     src->d_rt_spc_timer);\n\tdst->d_rtbwarns = src->d_rt_spc_warns;\n}\n\nstatic int quota_getxquota(struct super_block *sb, int type, qid_t id,\n\t\t\t   void __user *addr)\n{\n\tstruct fs_disk_quota fdq;\n\tstruct qc_dqblk qdq;\n\tstruct kqid qid;\n\tint ret;\n\n\tif (!sb->s_qcop->get_dqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\tret = sb->s_qcop->get_dqblk(sb, qid, &qdq);\n\tif (ret)\n\t\treturn ret;\n\tcopy_to_xfs_dqblk(&fdq, &qdq, type, id);\n\tif (copy_to_user(addr, &fdq, sizeof(fdq)))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\n \nstatic int quota_getnextxquota(struct super_block *sb, int type, qid_t id,\n\t\t\t    void __user *addr)\n{\n\tstruct fs_disk_quota fdq;\n\tstruct qc_dqblk qdq;\n\tstruct kqid qid;\n\tqid_t id_out;\n\tint ret;\n\n\tif (!sb->s_qcop->get_nextdqblk)\n\t\treturn -ENOSYS;\n\tqid = make_kqid(current_user_ns(), type, id);\n\tif (!qid_has_mapping(sb->s_user_ns, qid))\n\t\treturn -EINVAL;\n\tret = sb->s_qcop->get_nextdqblk(sb, &qid, &qdq);\n\tif (ret)\n\t\treturn ret;\n\tid_out = from_kqid(current_user_ns(), qid);\n\tcopy_to_xfs_dqblk(&fdq, &qdq, type, id_out);\n\tif (copy_to_user(addr, &fdq, sizeof(fdq)))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nstatic int quota_rmxquota(struct super_block *sb, void __user *addr)\n{\n\t__u32 flags;\n\n\tif (copy_from_user(&flags, addr, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (!sb->s_qcop->rm_xquota)\n\t\treturn -ENOSYS;\n\treturn sb->s_qcop->rm_xquota(sb, flags);\n}\n\n \nstatic int do_quotactl(struct super_block *sb, int type, int cmd, qid_t id,\n\t\t       void __user *addr, const struct path *path)\n{\n\tint ret;\n\n\ttype = array_index_nospec(type, MAXQUOTAS);\n\t \n\tif (!sb->s_qcop)\n\t\treturn -ENOSYS;\n\tif (!(sb->s_quota_types & (1 << type)))\n\t\treturn -EINVAL;\n\n\tret = check_quotactl_permission(sb, type, cmd, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase Q_QUOTAON:\n\t\treturn quota_quotaon(sb, type, id, path);\n\tcase Q_QUOTAOFF:\n\t\treturn quota_quotaoff(sb, type);\n\tcase Q_GETFMT:\n\t\treturn quota_getfmt(sb, type, addr);\n\tcase Q_GETINFO:\n\t\treturn quota_getinfo(sb, type, addr);\n\tcase Q_SETINFO:\n\t\treturn quota_setinfo(sb, type, addr);\n\tcase Q_GETQUOTA:\n\t\treturn quota_getquota(sb, type, id, addr);\n\tcase Q_GETNEXTQUOTA:\n\t\treturn quota_getnextquota(sb, type, id, addr);\n\tcase Q_SETQUOTA:\n\t\treturn quota_setquota(sb, type, id, addr);\n\tcase Q_SYNC:\n\t\tif (!sb->s_qcop->quota_sync)\n\t\t\treturn -ENOSYS;\n\t\treturn sb->s_qcop->quota_sync(sb, type);\n\tcase Q_XQUOTAON:\n\t\treturn quota_enable(sb, addr);\n\tcase Q_XQUOTAOFF:\n\t\treturn quota_disable(sb, addr);\n\tcase Q_XQUOTARM:\n\t\treturn quota_rmxquota(sb, addr);\n\tcase Q_XGETQSTAT:\n\t\treturn quota_getxstate(sb, type, addr);\n\tcase Q_XGETQSTATV:\n\t\treturn quota_getxstatev(sb, type, addr);\n\tcase Q_XSETQLIM:\n\t\treturn quota_setxquota(sb, type, id, addr);\n\tcase Q_XGETQUOTA:\n\t\treturn quota_getxquota(sb, type, id, addr);\n\tcase Q_XGETNEXTQUOTA:\n\t\treturn quota_getnextxquota(sb, type, id, addr);\n\tcase Q_XQUOTASYNC:\n\t\tif (sb_rdonly(sb))\n\t\t\treturn -EROFS;\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int quotactl_cmd_write(int cmd)\n{\n\t \n\tswitch (cmd) {\n\tcase Q_GETFMT:\n\tcase Q_GETINFO:\n\tcase Q_SYNC:\n\tcase Q_XGETQSTAT:\n\tcase Q_XGETQSTATV:\n\tcase Q_XGETQUOTA:\n\tcase Q_XGETNEXTQUOTA:\n\tcase Q_XQUOTASYNC:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic bool quotactl_cmd_onoff(int cmd)\n{\n\treturn (cmd == Q_QUOTAON) || (cmd == Q_QUOTAOFF) ||\n\t\t (cmd == Q_XQUOTAON) || (cmd == Q_XQUOTAOFF);\n}\n\n \nstatic struct super_block *quotactl_block(const char __user *special, int cmd)\n{\n#ifdef CONFIG_BLOCK\n\tstruct super_block *sb;\n\tstruct filename *tmp = getname(special);\n\tbool excl = false, thawed = false;\n\tint error;\n\tdev_t dev;\n\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\terror = lookup_bdev(tmp->name, &dev);\n\tputname(tmp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (quotactl_cmd_onoff(cmd)) {\n\t\texcl = true;\n\t\tthawed = true;\n\t} else if (quotactl_cmd_write(cmd)) {\n\t\tthawed = true;\n\t}\n\nretry:\n\tsb = user_get_super(dev, excl);\n\tif (!sb)\n\t\treturn ERR_PTR(-ENODEV);\n\tif (thawed && sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tif (excl)\n\t\t\tup_write(&sb->s_umount);\n\t\telse\n\t\t\tup_read(&sb->s_umount);\n\t\t \n\t\tsb_start_write(sb);\n\t\tsb_end_write(sb);\n\t\tput_super(sb);\n\t\tgoto retry;\n\t}\n\treturn sb;\n\n#else\n\treturn ERR_PTR(-ENODEV);\n#endif\n}\n\n \nSYSCALL_DEFINE4(quotactl, unsigned int, cmd, const char __user *, special,\n\t\tqid_t, id, void __user *, addr)\n{\n\tuint cmds, type;\n\tstruct super_block *sb = NULL;\n\tstruct path path, *pathp = NULL;\n\tint ret;\n\n\tcmds = cmd >> SUBCMDSHIFT;\n\ttype = cmd & SUBCMDMASK;\n\n\tif (type >= MAXQUOTAS)\n\t\treturn -EINVAL;\n\n\t \n\tif (!special) {\n\t\tif (cmds == Q_SYNC)\n\t\t\treturn quota_sync_all(type);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (cmds == Q_QUOTAON) {\n\t\tret = user_path_at(AT_FDCWD, addr, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);\n\t\tif (ret)\n\t\t\tpathp = ERR_PTR(ret);\n\t\telse\n\t\t\tpathp = &path;\n\t}\n\n\tsb = quotactl_block(special, cmds);\n\tif (IS_ERR(sb)) {\n\t\tret = PTR_ERR(sb);\n\t\tgoto out;\n\t}\n\n\tret = do_quotactl(sb, type, cmds, id, addr, pathp);\n\n\tif (!quotactl_cmd_onoff(cmds))\n\t\tdrop_super(sb);\n\telse\n\t\tdrop_super_exclusive(sb);\nout:\n\tif (pathp && !IS_ERR(pathp))\n\t\tpath_put(pathp);\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(quotactl_fd, unsigned int, fd, unsigned int, cmd,\n\t\tqid_t, id, void __user *, addr)\n{\n\tstruct super_block *sb;\n\tunsigned int cmds = cmd >> SUBCMDSHIFT;\n\tunsigned int type = cmd & SUBCMDMASK;\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget_raw(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -EINVAL;\n\tif (type >= MAXQUOTAS)\n\t\tgoto out;\n\n\tif (quotactl_cmd_write(cmds)) {\n\t\tret = mnt_want_write(f.file->f_path.mnt);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tsb = f.file->f_path.mnt->mnt_sb;\n\tif (quotactl_cmd_onoff(cmds))\n\t\tdown_write(&sb->s_umount);\n\telse\n\t\tdown_read(&sb->s_umount);\n\n\tret = do_quotactl(sb, type, cmds, id, addr, ERR_PTR(-EINVAL));\n\n\tif (quotactl_cmd_onoff(cmds))\n\t\tup_write(&sb->s_umount);\n\telse\n\t\tup_read(&sb->s_umount);\n\n\tif (quotactl_cmd_write(cmds))\n\t\tmnt_drop_write(f.file->f_path.mnt);\nout:\n\tfdput(f);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}