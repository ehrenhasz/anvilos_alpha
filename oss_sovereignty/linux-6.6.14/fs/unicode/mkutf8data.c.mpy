{
  "module_name": "mkutf8data.c",
  "hash_id": "5b4e61023c0c1a908623f6d64eec50b38100add9d0233ef8d53e5b90a6b8da90",
  "original_prompt": "Ingested from linux-6.6.14/fs/unicode/mkutf8data.c",
  "human_readable_source": " \n\n \n\n#include <sys/types.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n\n \n\n#define AGE_NAME\t\"DerivedAge.txt\"\n#define CCC_NAME\t\"DerivedCombiningClass.txt\"\n#define PROP_NAME\t\"DerivedCoreProperties.txt\"\n#define DATA_NAME\t\"UnicodeData.txt\"\n#define FOLD_NAME\t\"CaseFolding.txt\"\n#define NORM_NAME\t\"NormalizationCorrections.txt\"\n#define TEST_NAME\t\"NormalizationTest.txt\"\n#define UTF8_NAME\t\"utf8data.h\"\n\nconst char\t*age_name  = AGE_NAME;\nconst char\t*ccc_name  = CCC_NAME;\nconst char\t*prop_name = PROP_NAME;\nconst char\t*data_name = DATA_NAME;\nconst char\t*fold_name = FOLD_NAME;\nconst char\t*norm_name = NORM_NAME;\nconst char\t*test_name = TEST_NAME;\nconst char\t*utf8_name = UTF8_NAME;\n\nint verbose = 0;\n\n \n\n#define LINESIZE\t1024\nchar line[LINESIZE];\nchar buf0[LINESIZE];\nchar buf1[LINESIZE];\nchar buf2[LINESIZE];\nchar buf3[LINESIZE];\n\nconst char *argv0;\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n\n \n\n \n#define UNICODE_MAJ_SHIFT\t\t(16)\n#define UNICODE_MIN_SHIFT\t\t(8)\n\n#define UNICODE_MAJ_MAX\t\t\t((unsigned short)-1)\n#define UNICODE_MIN_MAX\t\t\t((unsigned char)-1)\n#define UNICODE_REV_MAX\t\t\t((unsigned char)-1)\n\n#define UNICODE_AGE(MAJ,MIN,REV)\t\t\t\\\n\t(((unsigned int)(MAJ) << UNICODE_MAJ_SHIFT) |\t\\\n\t ((unsigned int)(MIN) << UNICODE_MIN_SHIFT) |\t\\\n\t ((unsigned int)(REV)))\n\nunsigned int *ages;\nint ages_count;\n\nunsigned int unicode_maxage;\n\nstatic int age_valid(unsigned int major, unsigned int minor,\n\t\t     unsigned int revision)\n{\n\tif (major > UNICODE_MAJ_MAX)\n\t\treturn 0;\n\tif (minor > UNICODE_MIN_MAX)\n\t\treturn 0;\n\tif (revision > UNICODE_REV_MAX)\n\t\treturn 0;\n\treturn 1;\n}\n\n \n\n \ntypedef unsigned char utf8trie_t;\n#define BITNUM\t\t0x07\n#define NEXTBYTE\t0x08\n#define OFFLEN\t\t0x30\n#define OFFLEN_SHIFT\t4\n#define RIGHTPATH\t0x40\n#define TRIENODE\t0x80\n#define RIGHTNODE\t0x40\n#define LEFTNODE\t0x80\n\n \ntypedef unsigned char utf8leaf_t;\n\n#define LEAF_GEN(LEAF)\t((LEAF)[0])\n#define LEAF_CCC(LEAF)\t((LEAF)[1])\n#define LEAF_STR(LEAF)\t((const char*)((LEAF) + 2))\n\n#define MAXGEN\t\t(255)\n\n#define MINCCC\t\t(0)\n#define MAXCCC\t\t(254)\n#define STOPPER\t\t(0)\n#define DECOMPOSE\t(255)\n#define HANGUL\t\t((char)(255))\n\n#define UTF8HANGULLEAF\t(12)\n\nstruct tree;\nstatic utf8leaf_t *utf8nlookup(struct tree *, unsigned char *,\n\t\t\t       const char *, size_t);\nstatic utf8leaf_t *utf8lookup(struct tree *, unsigned char *, const char *);\n\nunsigned char *utf8data;\nsize_t utf8data_size;\n\nutf8trie_t *nfdi;\nutf8trie_t *nfdicf;\n\n \n\n \n\n#define UTF8_2_BITS     0xC0\n#define UTF8_3_BITS     0xE0\n#define UTF8_4_BITS     0xF0\n#define UTF8_N_BITS     0x80\n#define UTF8_2_MASK     0xE0\n#define UTF8_3_MASK     0xF0\n#define UTF8_4_MASK     0xF8\n#define UTF8_N_MASK     0xC0\n#define UTF8_V_MASK     0x3F\n#define UTF8_V_SHIFT    6\n\nstatic int utf8encode(char *str, unsigned int val)\n{\n\tint len;\n\n\tif (val < 0x80) {\n\t\tstr[0] = val;\n\t\tlen = 1;\n\t} else if (val < 0x800) {\n\t\tstr[1] = val & UTF8_V_MASK;\n\t\tstr[1] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[0] = val;\n\t\tstr[0] |= UTF8_2_BITS;\n\t\tlen = 2;\n\t} else if (val < 0x10000) {\n\t\tstr[2] = val & UTF8_V_MASK;\n\t\tstr[2] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[1] = val & UTF8_V_MASK;\n\t\tstr[1] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[0] = val;\n\t\tstr[0] |= UTF8_3_BITS;\n\t\tlen = 3;\n\t} else if (val < 0x110000) {\n\t\tstr[3] = val & UTF8_V_MASK;\n\t\tstr[3] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[2] = val & UTF8_V_MASK;\n\t\tstr[2] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[1] = val & UTF8_V_MASK;\n\t\tstr[1] |= UTF8_N_BITS;\n\t\tval >>= UTF8_V_SHIFT;\n\t\tstr[0] = val;\n\t\tstr[0] |= UTF8_4_BITS;\n\t\tlen = 4;\n\t} else {\n\t\tprintf(\"%#x: illegal val\\n\", val);\n\t\tlen = 0;\n\t}\n\treturn len;\n}\n\nstatic unsigned int utf8decode(const char *str)\n{\n\tconst unsigned char *s = (const unsigned char*)str;\n\tunsigned int unichar = 0;\n\n\tif (*s < 0x80) {\n\t\tunichar = *s;\n\t} else if (*s < UTF8_3_BITS) {\n\t\tunichar = *s++ & 0x1F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s & 0x3F;\n\t} else if (*s < UTF8_4_BITS) {\n\t\tunichar = *s++ & 0x0F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s++ & 0x3F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s & 0x3F;\n\t} else {\n\t\tunichar = *s++ & 0x0F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s++ & 0x3F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s++ & 0x3F;\n\t\tunichar <<= UTF8_V_SHIFT;\n\t\tunichar |= *s & 0x3F;\n\t}\n\treturn unichar;\n}\n\nstatic int utf32valid(unsigned int unichar)\n{\n\treturn unichar < 0x110000;\n}\n\n#define HANGUL_SYLLABLE(U)\t((U) >= 0xAC00 && (U) <= 0xD7A3)\n\n#define NODE 1\n#define LEAF 0\n\nstruct tree {\n\tvoid *root;\n\tint childnode;\n\tconst char *type;\n\tunsigned int maxage;\n\tstruct tree *next;\n\tint (*leaf_equal)(void *, void *);\n\tvoid (*leaf_print)(void *, int);\n\tint (*leaf_mark)(void *);\n\tint (*leaf_size)(void *);\n\tint *(*leaf_index)(struct tree *, void *);\n\tunsigned char *(*leaf_emit)(void *, unsigned char *);\n\tint leafindex[0x110000];\n\tint index;\n};\n\nstruct node {\n\tint index;\n\tint offset;\n\tint mark;\n\tint size;\n\tstruct node *parent;\n\tvoid *left;\n\tvoid *right;\n\tunsigned char bitnum;\n\tunsigned char nextbyte;\n\tunsigned char leftnode;\n\tunsigned char rightnode;\n\tunsigned int keybits;\n\tunsigned int keymask;\n};\n\n \nstatic void *lookup(struct tree *tree, const char *key)\n{\n\tstruct node *node;\n\tvoid *leaf = NULL;\n\n\tnode = tree->root;\n\twhile (!leaf && node) {\n\t\tif (node->nextbyte)\n\t\t\tkey++;\n\t\tif (*key & (1 << (node->bitnum & 7))) {\n\t\t\t \n\t\t\tif (node->rightnode == NODE) {\n\t\t\t\tnode = node->right;\n\t\t\t} else if (node->rightnode == LEAF) {\n\t\t\t\tleaf = node->right;\n\t\t\t} else {\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (node->leftnode == NODE) {\n\t\t\t\tnode = node->left;\n\t\t\t} else if (node->leftnode == LEAF) {\n\t\t\t\tleaf = node->left;\n\t\t\t} else {\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn leaf;\n}\n\n \nstatic void tree_walk(struct tree *tree)\n{\n\tstruct node *node;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tint indent = 1;\n\tint nodes, singletons, leaves;\n\n\tnodes = singletons = leaves = 0;\n\n\tprintf(\"%s_%x root %p\\n\", tree->type, tree->maxage, tree->root);\n\tif (tree->childnode == LEAF) {\n\t\tassert(tree->root);\n\t\ttree->leaf_print(tree->root, indent);\n\t\tleaves = 1;\n\t} else {\n\t\tassert(tree->childnode == NODE);\n\t\tnode = tree->root;\n\t\tleftmask = rightmask = 0;\n\t\twhile (node) {\n\t\t\tprintf(\"%*snode @ %p bitnum %d nextbyte %d\"\n\t\t\t       \" left %p right %p mask %x bits %x\\n\",\n\t\t\t\tindent, \"\", node,\n\t\t\t\tnode->bitnum, node->nextbyte,\n\t\t\t\tnode->left, node->right,\n\t\t\t\tnode->keymask, node->keybits);\n\t\t\tnodes += 1;\n\t\t\tif (!(node->left && node->right))\n\t\t\t\tsingletons += 1;\n\n\t\t\twhile (node) {\n\t\t\t\tbitmask = 1 << node->bitnum;\n\t\t\t\tif ((leftmask & bitmask) == 0) {\n\t\t\t\t\tleftmask |= bitmask;\n\t\t\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\t\t\tassert(node->left);\n\t\t\t\t\t\ttree->leaf_print(node->left,\n\t\t\t\t\t\t\t\t indent+1);\n\t\t\t\t\t\tleaves += 1;\n\t\t\t\t\t} else if (node->left) {\n\t\t\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\t\t\tindent += 1;\n\t\t\t\t\t\tnode = node->left;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((rightmask & bitmask) == 0) {\n\t\t\t\t\trightmask |= bitmask;\n\t\t\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\t\t\tassert(node->right);\n\t\t\t\t\t\ttree->leaf_print(node->right,\n\t\t\t\t\t\t\t\t indent+1);\n\t\t\t\t\t\tleaves += 1;\n\t\t\t\t\t} else if (node->right) {\n\t\t\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\t\t\tindent += 1;\n\t\t\t\t\t\tnode = node->right;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tleftmask &= ~bitmask;\n\t\t\t\trightmask &= ~bitmask;\n\t\t\t\tnode = node->parent;\n\t\t\t\tindent -= 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"nodes %d leaves %d singletons %d\\n\",\n\t       nodes, leaves, singletons);\n}\n\n \nstatic struct node *alloc_node(struct node *parent)\n{\n\tstruct node *node;\n\tint bitnum;\n\n\tnode = malloc(sizeof(*node));\n\tnode->left = node->right = NULL;\n\tnode->parent = parent;\n\tnode->leftnode = NODE;\n\tnode->rightnode = NODE;\n\tnode->keybits = 0;\n\tnode->keymask = 0;\n\tnode->mark = 0;\n\tnode->index = 0;\n\tnode->offset = -1;\n\tnode->size = 4;\n\n\tif (node->parent) {\n\t\tbitnum = parent->bitnum;\n\t\tif ((bitnum & 7) == 0) {\n\t\t\tnode->bitnum = bitnum + 7 + 8;\n\t\t\tnode->nextbyte = 1;\n\t\t} else {\n\t\t\tnode->bitnum = bitnum - 1;\n\t\t\tnode->nextbyte = 0;\n\t\t}\n\t} else {\n\t\tnode->bitnum = 7;\n\t\tnode->nextbyte = 0;\n\t}\n\n\treturn node;\n}\n\n \nstatic int insert(struct tree *tree, char *key, int keylen, void *leaf)\n{\n\tstruct node *node;\n\tstruct node *parent;\n\tvoid **cursor;\n\tint keybits;\n\n\tassert(keylen >= 1 && keylen <= 4);\n\n\tnode = NULL;\n\tcursor = &tree->root;\n\tkeybits = 8 * keylen;\n\n\t \n\twhile (keybits) {\n\t\tif (!*cursor)\n\t\t\t*cursor = alloc_node(node);\n\t\tnode = *cursor;\n\t\tif (node->nextbyte)\n\t\t\tkey++;\n\t\tif (*key & (1 << (node->bitnum & 7)))\n\t\t\tcursor = &node->right;\n\t\telse\n\t\t\tcursor = &node->left;\n\t\tkeybits--;\n\t}\n\t*cursor = leaf;\n\n\t \n\twhile (node) {\n\t\tif (*key & (1 << (node->bitnum & 7)))\n\t\t\tnode->rightnode = LEAF;\n\t\telse\n\t\t\tnode->leftnode = LEAF;\n\t\tif (node->nextbyte)\n\t\t\tbreak;\n\t\tif (node->leftnode == NODE || node->rightnode == NODE)\n\t\t\tbreak;\n\t\tassert(node->left);\n\t\tassert(node->right);\n\t\t \n\t\tif (! tree->leaf_equal(node->left, node->right))\n\t\t\tbreak;\n\t\t \n\t\tleaf = node->left;\n\t\t \n\t\tparent = node->parent;\n\t\tif (!parent) {\n\t\t\t \n\t\t\ttree->root = leaf;\n\t\t\ttree->childnode = LEAF;\n\t\t} else if (parent->left == node) {\n\t\t\tparent->left = leaf;\n\t\t\tparent->leftnode = LEAF;\n\t\t\tif (parent->right) {\n\t\t\t\tparent->keymask = 0;\n\t\t\t\tparent->keybits = 0;\n\t\t\t} else {\n\t\t\t\tparent->keymask |= (1 << node->bitnum);\n\t\t\t}\n\t\t} else if (parent->right == node) {\n\t\t\tparent->right = leaf;\n\t\t\tparent->rightnode = LEAF;\n\t\t\tif (parent->left) {\n\t\t\t\tparent->keymask = 0;\n\t\t\t\tparent->keybits = 0;\n\t\t\t} else {\n\t\t\t\tparent->keymask |= (1 << node->bitnum);\n\t\t\t\tparent->keybits |= (1 << node->bitnum);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tassert(0);\n\t\t}\n\t\tfree(node);\n\t\tnode = parent;\n\t}\n\n\t \n\twhile (node) {\n\t\tparent = node->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\t\t \n\t\tif (node->keymask == 0) {\n\t\t\tparent->keymask = 0;\n\t\t\tparent->keybits = 0;\n\t\t} else if (parent->left && parent->right) {\n\t\t\tparent->keymask = 0;\n\t\t\tparent->keybits = 0;\n\t\t} else {\n\t\t\tassert((parent->keymask & node->keymask) == 0);\n\t\t\tparent->keymask |= node->keymask;\n\t\t\tparent->keymask |= (1 << parent->bitnum);\n\t\t\tparent->keybits |= node->keybits;\n\t\t\tif (parent->right)\n\t\t\t\tparent->keybits |= (1 << parent->bitnum);\n\t\t}\n\t\tnode = parent;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void prune(struct tree *tree)\n{\n\tstruct node *node;\n\tstruct node *left;\n\tstruct node *right;\n\tstruct node *parent;\n\tvoid *leftleaf;\n\tvoid *rightleaf;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tint count;\n\n\tif (verbose > 0)\n\t\tprintf(\"Pruning %s_%x\\n\", tree->type, tree->maxage);\n\n\tcount = 0;\n\tif (tree->childnode == LEAF)\n\t\treturn;\n\tif (!tree->root)\n\t\treturn;\n\n\tleftmask = rightmask = 0;\n\tnode = tree->root;\n\twhile (node) {\n\t\tif (node->nextbyte)\n\t\t\tgoto advance;\n\t\tif (node->leftnode == LEAF)\n\t\t\tgoto advance;\n\t\tif (node->rightnode == LEAF)\n\t\t\tgoto advance;\n\t\tif (!node->left)\n\t\t\tgoto advance;\n\t\tif (!node->right)\n\t\t\tgoto advance;\n\t\tleft = node->left;\n\t\tright = node->right;\n\t\tif (left->keymask == 0)\n\t\t\tgoto advance;\n\t\tif (right->keymask == 0)\n\t\t\tgoto advance;\n\t\tif (left->keymask != right->keymask)\n\t\t\tgoto advance;\n\t\tif (left->keybits != right->keybits)\n\t\t\tgoto advance;\n\t\tleftleaf = NULL;\n\t\twhile (!leftleaf) {\n\t\t\tassert(left->left || left->right);\n\t\t\tif (left->leftnode == LEAF)\n\t\t\t\tleftleaf = left->left;\n\t\t\telse if (left->rightnode == LEAF)\n\t\t\t\tleftleaf = left->right;\n\t\t\telse if (left->left)\n\t\t\t\tleft = left->left;\n\t\t\telse if (left->right)\n\t\t\t\tleft = left->right;\n\t\t\telse\n\t\t\t\tassert(0);\n\t\t}\n\t\trightleaf = NULL;\n\t\twhile (!rightleaf) {\n\t\t\tassert(right->left || right->right);\n\t\t\tif (right->leftnode == LEAF)\n\t\t\t\trightleaf = right->left;\n\t\t\telse if (right->rightnode == LEAF)\n\t\t\t\trightleaf = right->right;\n\t\t\telse if (right->left)\n\t\t\t\tright = right->left;\n\t\t\telse if (right->right)\n\t\t\t\tright = right->right;\n\t\t\telse\n\t\t\t\tassert(0);\n\t\t}\n\t\tif (! tree->leaf_equal(leftleaf, rightleaf))\n\t\t\tgoto advance;\n\t\t \n\t\tparent = node->parent;\n\t\tleft = node->left;\n\t\tright = node->right;\n\t\tif (parent->left == node)\n\t\t\tparent->left = left;\n\t\telse if (parent->right == node)\n\t\t\tparent->right = left;\n\t\telse\n\t\t\tassert(0);\n\t\tleft->parent = parent;\n\t\tleft->keymask |= (1 << node->bitnum);\n\t\tnode->left = NULL;\n\t\twhile (node) {\n\t\t\tbitmask = 1 << node->bitnum;\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t\tif (node->leftnode == NODE && node->left) {\n\t\t\t\tleft = node->left;\n\t\t\t\tfree(node);\n\t\t\t\tcount++;\n\t\t\t\tnode = left;\n\t\t\t} else if (node->rightnode == NODE && node->right) {\n\t\t\t\tright = node->right;\n\t\t\t\tfree(node);\n\t\t\t\tcount++;\n\t\t\t\tnode = right;\n\t\t\t} else {\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t}\n\t\t \n\t\tnode = parent;\n\t\t \n\t\tbitmask = 1 << node->bitnum;\n\t\tleftmask &= ~bitmask;\n\t\trightmask &= ~bitmask;\n\t\tfor (;;) {\n\t\t\tif (node->left && node->right)\n\t\t\t\tbreak;\n\t\t\tif (node->left) {\n\t\t\t\tleft = node->left;\n\t\t\t\tnode->keymask |= left->keymask;\n\t\t\t\tnode->keybits |= left->keybits;\n\t\t\t}\n\t\t\tif (node->right) {\n\t\t\t\tright = node->right;\n\t\t\t\tnode->keymask |= right->keymask;\n\t\t\t\tnode->keybits |= right->keybits;\n\t\t\t}\n\t\t\tnode->keymask |= (1 << node->bitnum);\n\t\t\tnode = node->parent;\n\t\t\t \n\t\t\tbitmask = 1 << node->bitnum;\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t}\n\tadvance:\n\t\tbitmask = 1 << node->bitnum;\n\t\tif ((leftmask & bitmask) == 0 &&\n\t\t    node->leftnode == NODE &&\n\t\t    node->left) {\n\t\t\tleftmask |= bitmask;\n\t\t\tnode = node->left;\n\t\t} else if ((rightmask & bitmask) == 0 &&\n\t\t\t   node->rightnode == NODE &&\n\t\t\t   node->right) {\n\t\t\trightmask |= bitmask;\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t\tnode = node->parent;\n\t\t}\n\t}\n\tif (verbose > 0)\n\t\tprintf(\"Pruned %d nodes\\n\", count);\n}\n\n \nstatic void mark_nodes(struct tree *tree)\n{\n\tstruct node *node;\n\tstruct node *n;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tint marked;\n\n\tmarked = 0;\n\tif (verbose > 0)\n\t\tprintf(\"Marking %s_%x\\n\", tree->type, tree->maxage);\n\tif (tree->childnode == LEAF)\n\t\tgoto done;\n\n\tassert(tree->childnode == NODE);\n\tnode = tree->root;\n\tleftmask = rightmask = 0;\n\twhile (node) {\n\t\tbitmask = 1 << node->bitnum;\n\t\tif ((leftmask & bitmask) == 0) {\n\t\t\tleftmask |= bitmask;\n\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\tassert(node->left);\n\t\t\t\tif (tree->leaf_mark(node->left)) {\n\t\t\t\t\tn = node;\n\t\t\t\t\twhile (n && !n->mark) {\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t\tn->mark = 1;\n\t\t\t\t\t\tn = n->parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node->left) {\n\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\tnode = node->left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((rightmask & bitmask) == 0) {\n\t\t\trightmask |= bitmask;\n\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\tassert(node->right);\n\t\t\t\tif (tree->leaf_mark(node->right)) {\n\t\t\t\t\tn = node;\n\t\t\t\t\twhile (n && !n->mark) {\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t\tn->mark = 1;\n\t\t\t\t\t\tn = n->parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node->right) {\n\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\tnode = node->right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tleftmask &= ~bitmask;\n\t\trightmask &= ~bitmask;\n\t\tnode = node->parent;\n\t}\n\n\t \n\n\tassert(tree->childnode == NODE);\n\tnode = tree->root;\n\tleftmask = rightmask = 0;\n\twhile (node) {\n\t\tbitmask = 1 << node->bitnum;\n\t\tif ((leftmask & bitmask) == 0) {\n\t\t\tleftmask |= bitmask;\n\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\tassert(node->left);\n\t\t\t\tif (tree->leaf_mark(node->left)) {\n\t\t\t\t\tn = node;\n\t\t\t\t\twhile (n && !n->mark) {\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t\tn->mark = 1;\n\t\t\t\t\t\tn = n->parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node->left) {\n\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\tnode = node->left;\n\t\t\t\tif (!node->mark && node->parent->mark) {\n\t\t\t\t\tmarked++;\n\t\t\t\t\tnode->mark = 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((rightmask & bitmask) == 0) {\n\t\t\trightmask |= bitmask;\n\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\tassert(node->right);\n\t\t\t\tif (tree->leaf_mark(node->right)) {\n\t\t\t\t\tn = node;\n\t\t\t\t\twhile (n && !n->mark) {\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t\tn->mark = 1;\n\t\t\t\t\t\tn = n->parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node->right) {\n\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\tnode = node->right;\n\t\t\t\tif (!node->mark && node->parent->mark &&\n\t\t\t\t    !node->parent->left) {\n\t\t\t\t\tmarked++;\n\t\t\t\t\tnode->mark = 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tleftmask &= ~bitmask;\n\t\trightmask &= ~bitmask;\n\t\tnode = node->parent;\n\t}\ndone:\n\tif (verbose > 0)\n\t\tprintf(\"Marked %d nodes\\n\", marked);\n}\n\n \nstatic int index_nodes(struct tree *tree, int index)\n{\n\tstruct node *node;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tint count;\n\tint indent;\n\n\t \n\twhile (index % 64)\n\t\tindex++;\n\ttree->index = index;\n\tindent = 1;\n\tcount = 0;\n\n\tif (verbose > 0)\n\t\tprintf(\"Indexing %s_%x: %d\\n\", tree->type, tree->maxage, index);\n\tif (tree->childnode == LEAF) {\n\t\tindex += tree->leaf_size(tree->root);\n\t\tgoto done;\n\t}\n\n\tassert(tree->childnode == NODE);\n\tnode = tree->root;\n\tleftmask = rightmask = 0;\n\twhile (node) {\n\t\tif (!node->mark)\n\t\t\tgoto skip;\n\t\tcount++;\n\t\tif (node->index != index)\n\t\t\tnode->index = index;\n\t\tindex += node->size;\nskip:\n\t\twhile (node) {\n\t\t\tbitmask = 1 << node->bitnum;\n\t\t\tif (node->mark && (leftmask & bitmask) == 0) {\n\t\t\t\tleftmask |= bitmask;\n\t\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\t\tassert(node->left);\n\t\t\t\t\t*tree->leaf_index(tree, node->left) =\n\t\t\t\t\t\t\t\t\tindex;\n\t\t\t\t\tindex += tree->leaf_size(node->left);\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (node->left) {\n\t\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->left;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node->mark && (rightmask & bitmask) == 0) {\n\t\t\t\trightmask |= bitmask;\n\t\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\t\tassert(node->right);\n\t\t\t\t\t*tree->leaf_index(tree, node->right) = index;\n\t\t\t\t\tindex += tree->leaf_size(node->right);\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (node->right) {\n\t\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->right;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t\tnode = node->parent;\n\t\t\tindent -= 1;\n\t\t}\n\t}\ndone:\n\t \n\twhile (index % 16)\n\t\tindex++;\n\tif (verbose > 0)\n\t\tprintf(\"Final index %d\\n\", index);\n\treturn index;\n}\n\n \nstatic int mark_subtree(struct node *node)\n{\n\tint changed;\n\n\tif (!node || node->mark)\n\t\treturn 0;\n\tnode->mark = 1;\n\tnode->index = node->parent->index;\n\tchanged = 1;\n\tif (node->leftnode == NODE)\n\t\tchanged += mark_subtree(node->left);\n\tif (node->rightnode == NODE)\n\t\tchanged += mark_subtree(node->right);\n\treturn changed;\n}\n\n \nstatic int size_nodes(struct tree *tree)\n{\n\tstruct tree *next;\n\tstruct node *node;\n\tstruct node *right;\n\tstruct node *n;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tunsigned int pathbits;\n\tunsigned int pathmask;\n\tunsigned int nbit;\n\tint changed;\n\tint offset;\n\tint size;\n\tint indent;\n\n\tindent = 1;\n\tchanged = 0;\n\tsize = 0;\n\n\tif (verbose > 0)\n\t\tprintf(\"Sizing %s_%x\\n\", tree->type, tree->maxage);\n\tif (tree->childnode == LEAF)\n\t\tgoto done;\n\n\tassert(tree->childnode == NODE);\n\tpathbits = 0;\n\tpathmask = 0;\n\tnode = tree->root;\n\tleftmask = rightmask = 0;\n\twhile (node) {\n\t\tif (!node->mark)\n\t\t\tgoto skip;\n\t\toffset = 0;\n\t\tif (!node->left || !node->right) {\n\t\t\tsize = 1;\n\t\t} else {\n\t\t\tif (node->rightnode == NODE) {\n\t\t\t\t \n\t\t\t\tright = node->right;\n\t\t\t\tnext = tree->next;\n\t\t\t\twhile (!right->mark) {\n\t\t\t\t\tassert(next);\n\t\t\t\t\tn = next->root;\n\t\t\t\t\twhile (n->bitnum != node->bitnum) {\n\t\t\t\t\t\tnbit = 1 << n->bitnum;\n\t\t\t\t\t\tif (!(pathmask & nbit))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (pathbits & nbit) {\n\t\t\t\t\t\t\tif (n->rightnode == LEAF)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tn = n->right;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (n->leftnode == LEAF)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tn = n->left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n->bitnum != node->bitnum)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = n->right;\n\t\t\t\t\tright = n;\n\t\t\t\t\tnext = next->next;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (!right->mark)\n\t\t\t\t\tchanged += mark_subtree(right);\n\t\t\t\toffset = right->index - node->index;\n\t\t\t} else {\n\t\t\t\toffset = *tree->leaf_index(tree, node->right);\n\t\t\t\toffset -= node->index;\n\t\t\t}\n\t\t\tassert(offset >= 0);\n\t\t\tassert(offset <= 0xffffff);\n\t\t\tif (offset <= 0xff) {\n\t\t\t\tsize = 2;\n\t\t\t} else if (offset <= 0xffff) {\n\t\t\t\tsize = 3;\n\t\t\t} else {  \n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t}\n\t\tif (node->size != size || node->offset != offset) {\n\t\t\tnode->size = size;\n\t\t\tnode->offset = offset;\n\t\t\tchanged++;\n\t\t}\nskip:\n\t\twhile (node) {\n\t\t\tbitmask = 1 << node->bitnum;\n\t\t\tpathmask |= bitmask;\n\t\t\tif (node->mark && (leftmask & bitmask) == 0) {\n\t\t\t\tleftmask |= bitmask;\n\t\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\t\tassert(node->left);\n\t\t\t\t} else if (node->left) {\n\t\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->left;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node->mark && (rightmask & bitmask) == 0) {\n\t\t\t\trightmask |= bitmask;\n\t\t\t\tpathbits |= bitmask;\n\t\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\t\tassert(node->right);\n\t\t\t\t} else if (node->right) {\n\t\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->right;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t\tpathmask &= ~bitmask;\n\t\t\tpathbits &= ~bitmask;\n\t\t\tnode = node->parent;\n\t\t\tindent -= 1;\n\t\t}\n\t}\ndone:\n\tif (verbose > 0)\n\t\tprintf(\"Found %d changes\\n\", changed);\n\treturn changed;\n}\n\n \nstatic void emit(struct tree *tree, unsigned char *data)\n{\n\tstruct node *node;\n\tunsigned int leftmask;\n\tunsigned int rightmask;\n\tunsigned int bitmask;\n\tint offlen;\n\tint offset;\n\tint index;\n\tint indent;\n\tint size;\n\tint bytes;\n\tint leaves;\n\tint nodes[4];\n\tunsigned char byte;\n\n\tnodes[0] = nodes[1] = nodes[2] = nodes[3] = 0;\n\tleaves = 0;\n\tbytes = 0;\n\tindex = tree->index;\n\tdata += index;\n\tindent = 1;\n\tif (verbose > 0)\n\t\tprintf(\"Emitting %s_%x\\n\", tree->type, tree->maxage);\n\tif (tree->childnode == LEAF) {\n\t\tassert(tree->root);\n\t\ttree->leaf_emit(tree->root, data);\n\t\tsize = tree->leaf_size(tree->root);\n\t\tindex += size;\n\t\tleaves++;\n\t\tgoto done;\n\t}\n\n\tassert(tree->childnode == NODE);\n\tnode = tree->root;\n\tleftmask = rightmask = 0;\n\twhile (node) {\n\t\tif (!node->mark)\n\t\t\tgoto skip;\n\t\tassert(node->offset != -1);\n\t\tassert(node->index == index);\n\n\t\tbyte = 0;\n\t\tif (node->nextbyte)\n\t\t\tbyte |= NEXTBYTE;\n\t\tbyte |= (node->bitnum & BITNUM);\n\t\tif (node->left && node->right) {\n\t\t\tif (node->leftnode == NODE)\n\t\t\t\tbyte |= LEFTNODE;\n\t\t\tif (node->rightnode == NODE)\n\t\t\t\tbyte |= RIGHTNODE;\n\t\t\tif (node->offset <= 0xff)\n\t\t\t\tofflen = 1;\n\t\t\telse if (node->offset <= 0xffff)\n\t\t\t\tofflen = 2;\n\t\t\telse\n\t\t\t\tofflen = 3;\n\t\t\tnodes[offlen]++;\n\t\t\toffset = node->offset;\n\t\t\tbyte |= offlen << OFFLEN_SHIFT;\n\t\t\t*data++ = byte;\n\t\t\tindex++;\n\t\t\twhile (offlen--) {\n\t\t\t\t*data++ = offset & 0xff;\n\t\t\t\tindex++;\n\t\t\t\toffset >>= 8;\n\t\t\t}\n\t\t} else if (node->left) {\n\t\t\tif (node->leftnode == NODE)\n\t\t\t\tbyte |= TRIENODE;\n\t\t\tnodes[0]++;\n\t\t\t*data++ = byte;\n\t\t\tindex++;\n\t\t} else if (node->right) {\n\t\t\tbyte |= RIGHTNODE;\n\t\t\tif (node->rightnode == NODE)\n\t\t\t\tbyte |= TRIENODE;\n\t\t\tnodes[0]++;\n\t\t\t*data++ = byte;\n\t\t\tindex++;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\nskip:\n\t\twhile (node) {\n\t\t\tbitmask = 1 << node->bitnum;\n\t\t\tif (node->mark && (leftmask & bitmask) == 0) {\n\t\t\t\tleftmask |= bitmask;\n\t\t\t\tif (node->leftnode == LEAF) {\n\t\t\t\t\tassert(node->left);\n\t\t\t\t\tdata = tree->leaf_emit(node->left,\n\t\t\t\t\t\t\t       data);\n\t\t\t\t\tsize = tree->leaf_size(node->left);\n\t\t\t\t\tindex += size;\n\t\t\t\t\tbytes += size;\n\t\t\t\t\tleaves++;\n\t\t\t\t} else if (node->left) {\n\t\t\t\t\tassert(node->leftnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->left;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node->mark && (rightmask & bitmask) == 0) {\n\t\t\t\trightmask |= bitmask;\n\t\t\t\tif (node->rightnode == LEAF) {\n\t\t\t\t\tassert(node->right);\n\t\t\t\t\tdata = tree->leaf_emit(node->right,\n\t\t\t\t\t\t\t       data);\n\t\t\t\t\tsize = tree->leaf_size(node->right);\n\t\t\t\t\tindex += size;\n\t\t\t\t\tbytes += size;\n\t\t\t\t\tleaves++;\n\t\t\t\t} else if (node->right) {\n\t\t\t\t\tassert(node->rightnode == NODE);\n\t\t\t\t\tindent += 1;\n\t\t\t\t\tnode = node->right;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleftmask &= ~bitmask;\n\t\t\trightmask &= ~bitmask;\n\t\t\tnode = node->parent;\n\t\t\tindent -= 1;\n\t\t}\n\t}\ndone:\n\tif (verbose > 0) {\n\t\tprintf(\"Emitted %d (%d) leaves\",\n\t\t\tleaves, bytes);\n\t\tprintf(\" %d (%d+%d+%d+%d) nodes\",\n\t\t\tnodes[0] + nodes[1] + nodes[2] + nodes[3],\n\t\t\tnodes[0], nodes[1], nodes[2], nodes[3]);\n\t\tprintf(\" %d total\\n\", index - tree->index);\n\t}\n}\n\n \n\n \nstruct unicode_data {\n\tunsigned int code;\n\tint ccc;\n\tint gen;\n\tint correction;\n\tunsigned int *utf32nfdi;\n\tunsigned int *utf32nfdicf;\n\tchar *utf8nfdi;\n\tchar *utf8nfdicf;\n};\n\nstruct unicode_data unicode_data[0x110000];\nstruct unicode_data *corrections;\nint    corrections_count;\n\nstruct tree *nfdi_tree;\nstruct tree *nfdicf_tree;\n\nstruct tree *trees;\nint          trees_count;\n\n \nstatic struct unicode_data *corrections_lookup(struct unicode_data *u)\n{\n\tint i;\n\n\tfor (i = 0; i != corrections_count; i++)\n\t\tif (u->code == corrections[i].code)\n\t\t\treturn &corrections[i];\n\treturn u;\n}\n\nstatic int nfdi_equal(void *l, void *r)\n{\n\tstruct unicode_data *left = l;\n\tstruct unicode_data *right = r;\n\n\tif (left->gen != right->gen)\n\t\treturn 0;\n\tif (left->ccc != right->ccc)\n\t\treturn 0;\n\tif (left->utf8nfdi && right->utf8nfdi &&\n\t    strcmp(left->utf8nfdi, right->utf8nfdi) == 0)\n\t\treturn 1;\n\tif (left->utf8nfdi || right->utf8nfdi)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int nfdicf_equal(void *l, void *r)\n{\n\tstruct unicode_data *left = l;\n\tstruct unicode_data *right = r;\n\n\tif (left->gen != right->gen)\n\t\treturn 0;\n\tif (left->ccc != right->ccc)\n\t\treturn 0;\n\tif (left->utf8nfdicf && right->utf8nfdicf &&\n\t    strcmp(left->utf8nfdicf, right->utf8nfdicf) == 0)\n\t\treturn 1;\n\tif (left->utf8nfdicf && right->utf8nfdicf)\n\t\treturn 0;\n\tif (left->utf8nfdicf || right->utf8nfdicf)\n\t\treturn 0;\n\tif (left->utf8nfdi && right->utf8nfdi &&\n\t    strcmp(left->utf8nfdi, right->utf8nfdi) == 0)\n\t\treturn 1;\n\tif (left->utf8nfdi || right->utf8nfdi)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void nfdi_print(void *l, int indent)\n{\n\tstruct unicode_data *leaf = l;\n\n\tprintf(\"%*sleaf @ %p code %X ccc %d gen %d\", indent, \"\", leaf,\n\t\tleaf->code, leaf->ccc, leaf->gen);\n\n\tif (leaf->utf8nfdi && leaf->utf8nfdi[0] == HANGUL)\n\t\tprintf(\" nfdi \\\"%s\\\"\", \"HANGUL SYLLABLE\");\n\telse if (leaf->utf8nfdi)\n\t\tprintf(\" nfdi \\\"%s\\\"\", (const char*)leaf->utf8nfdi);\n\n\tprintf(\"\\n\");\n}\n\nstatic void nfdicf_print(void *l, int indent)\n{\n\tstruct unicode_data *leaf = l;\n\n\tprintf(\"%*sleaf @ %p code %X ccc %d gen %d\", indent, \"\", leaf,\n\t\tleaf->code, leaf->ccc, leaf->gen);\n\n\tif (leaf->utf8nfdicf)\n\t\tprintf(\" nfdicf \\\"%s\\\"\", (const char*)leaf->utf8nfdicf);\n\telse if (leaf->utf8nfdi && leaf->utf8nfdi[0] == HANGUL)\n\t\tprintf(\" nfdi \\\"%s\\\"\", \"HANGUL SYLLABLE\");\n\telse if (leaf->utf8nfdi)\n\t\tprintf(\" nfdi \\\"%s\\\"\", (const char*)leaf->utf8nfdi);\n\tprintf(\"\\n\");\n}\n\nstatic int nfdi_mark(void *l)\n{\n\treturn 1;\n}\n\nstatic int nfdicf_mark(void *l)\n{\n\tstruct unicode_data *leaf = l;\n\n\tif (leaf->utf8nfdicf)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int correction_mark(void *l)\n{\n\tstruct unicode_data *leaf = l;\n\n\treturn leaf->correction;\n}\n\nstatic int nfdi_size(void *l)\n{\n\tstruct unicode_data *leaf = l;\n\tint size = 2;\n\n\tif (HANGUL_SYLLABLE(leaf->code))\n\t\tsize += 1;\n\telse if (leaf->utf8nfdi)\n\t\tsize += strlen(leaf->utf8nfdi) + 1;\n\treturn size;\n}\n\nstatic int nfdicf_size(void *l)\n{\n\tstruct unicode_data *leaf = l;\n\tint size = 2;\n\n\tif (HANGUL_SYLLABLE(leaf->code))\n\t\tsize += 1;\n\telse if (leaf->utf8nfdicf)\n\t\tsize += strlen(leaf->utf8nfdicf) + 1;\n\telse if (leaf->utf8nfdi)\n\t\tsize += strlen(leaf->utf8nfdi) + 1;\n\treturn size;\n}\n\nstatic int *nfdi_index(struct tree *tree, void *l)\n{\n\tstruct unicode_data *leaf = l;\n\n\treturn &tree->leafindex[leaf->code];\n}\n\nstatic int *nfdicf_index(struct tree *tree, void *l)\n{\n\tstruct unicode_data *leaf = l;\n\n\treturn &tree->leafindex[leaf->code];\n}\n\nstatic unsigned char *nfdi_emit(void *l, unsigned char *data)\n{\n\tstruct unicode_data *leaf = l;\n\tunsigned char *s;\n\n\t*data++ = leaf->gen;\n\n\tif (HANGUL_SYLLABLE(leaf->code)) {\n\t\t*data++ = DECOMPOSE;\n\t\t*data++ = HANGUL;\n\t} else if (leaf->utf8nfdi) {\n\t\t*data++ = DECOMPOSE;\n\t\ts = (unsigned char*)leaf->utf8nfdi;\n\t\twhile ((*data++ = *s++) != 0)\n\t\t\t;\n\t} else {\n\t\t*data++ = leaf->ccc;\n\t}\n\treturn data;\n}\n\nstatic unsigned char *nfdicf_emit(void *l, unsigned char *data)\n{\n\tstruct unicode_data *leaf = l;\n\tunsigned char *s;\n\n\t*data++ = leaf->gen;\n\n\tif (HANGUL_SYLLABLE(leaf->code)) {\n\t\t*data++ = DECOMPOSE;\n\t\t*data++ = HANGUL;\n\t} else if (leaf->utf8nfdicf) {\n\t\t*data++ = DECOMPOSE;\n\t\ts = (unsigned char*)leaf->utf8nfdicf;\n\t\twhile ((*data++ = *s++) != 0)\n\t\t\t;\n\t} else if (leaf->utf8nfdi) {\n\t\t*data++ = DECOMPOSE;\n\t\ts = (unsigned char*)leaf->utf8nfdi;\n\t\twhile ((*data++ = *s++) != 0)\n\t\t\t;\n\t} else {\n\t\t*data++ = leaf->ccc;\n\t}\n\treturn data;\n}\n\nstatic void utf8_create(struct unicode_data *data)\n{\n\tchar utf[18*4+1];\n\tchar *u;\n\tunsigned int *um;\n\tint i;\n\n\tif (data->utf8nfdi) {\n\t\tassert(data->utf8nfdi[0] == HANGUL);\n\t\treturn;\n\t}\n\n\tu = utf;\n\tum = data->utf32nfdi;\n\tif (um) {\n\t\tfor (i = 0; um[i]; i++)\n\t\t\tu += utf8encode(u, um[i]);\n\t\t*u = '\\0';\n\t\tdata->utf8nfdi = strdup(utf);\n\t}\n\tu = utf;\n\tum = data->utf32nfdicf;\n\tif (um) {\n\t\tfor (i = 0; um[i]; i++)\n\t\t\tu += utf8encode(u, um[i]);\n\t\t*u = '\\0';\n\t\tif (!data->utf8nfdi || strcmp(data->utf8nfdi, utf))\n\t\t\tdata->utf8nfdicf = strdup(utf);\n\t}\n}\n\nstatic void utf8_init(void)\n{\n\tunsigned int unichar;\n\tint i;\n\n\tfor (unichar = 0; unichar != 0x110000; unichar++)\n\t\tutf8_create(&unicode_data[unichar]);\n\n\tfor (i = 0; i != corrections_count; i++)\n\t\tutf8_create(&corrections[i]);\n}\n\nstatic void trees_init(void)\n{\n\tstruct unicode_data *data;\n\tunsigned int maxage;\n\tunsigned int nextage;\n\tint count;\n\tint i;\n\tint j;\n\n\t \n\tcount = 0;\n\tnextage = (unsigned int)-1;\n\tdo {\n\t\tmaxage = nextage;\n\t\tnextage = 0;\n\t\tfor (i = 0; i <= corrections_count; i++) {\n\t\t\tdata = &corrections[i];\n\t\t\tif (nextage < data->correction &&\n\t\t\t    data->correction < maxage)\n\t\t\t\tnextage = data->correction;\n\t\t}\n\t\tcount++;\n\t} while (nextage);\n\n\t \n\ttrees_count = count * 2;\n\ttrees = calloc(trees_count, sizeof(struct tree));\n\n\t \n\tcount = trees_count;\n\tnextage = (unsigned int)-1;\n\tdo {\n\t\tmaxage = nextage;\n\t\ttrees[--count].maxage = maxage;\n\t\ttrees[--count].maxage = maxage;\n\t\tnextage = 0;\n\t\tfor (i = 0; i <= corrections_count; i++) {\n\t\t\tdata = &corrections[i];\n\t\t\tif (nextage < data->correction &&\n\t\t\t    data->correction < maxage)\n\t\t\t\tnextage = data->correction;\n\t\t}\n\t} while (nextage);\n\n\t \n\tfor (i = 0; i != trees_count; i++) {\n\t\tj = 0;\n\t\twhile (ages[j] < trees[i].maxage)\n\t\t\tj++;\n\t\ttrees[i].maxage = ages[j-1];\n\t}\n\n\t \n\ttrees[trees_count-2].next = &trees[trees_count-1];\n\ttrees[trees_count-1].leaf_mark = nfdi_mark;\n\ttrees[trees_count-2].leaf_mark = nfdicf_mark;\n\tfor (i = 0; i != trees_count-2; i += 2) {\n\t\ttrees[i].next = &trees[trees_count-2];\n\t\ttrees[i].leaf_mark = correction_mark;\n\t\ttrees[i+1].next = &trees[trees_count-1];\n\t\ttrees[i+1].leaf_mark = correction_mark;\n\t}\n\n\t \n\tfor (i = 0; i != trees_count; i += 2) {\n\t\ttrees[i].type = \"nfdicf\";\n\t\ttrees[i].leaf_equal = nfdicf_equal;\n\t\ttrees[i].leaf_print = nfdicf_print;\n\t\ttrees[i].leaf_size = nfdicf_size;\n\t\ttrees[i].leaf_index = nfdicf_index;\n\t\ttrees[i].leaf_emit = nfdicf_emit;\n\n\t\ttrees[i+1].type = \"nfdi\";\n\t\ttrees[i+1].leaf_equal = nfdi_equal;\n\t\ttrees[i+1].leaf_print = nfdi_print;\n\t\ttrees[i+1].leaf_size = nfdi_size;\n\t\ttrees[i+1].leaf_index = nfdi_index;\n\t\ttrees[i+1].leaf_emit = nfdi_emit;\n\t}\n\n\t \n\tfor (i = 0; i != trees_count; i++)\n\t\ttrees[i].childnode = NODE;\n}\n\nstatic void trees_populate(void)\n{\n\tstruct unicode_data *data;\n\tunsigned int unichar;\n\tchar keyval[4];\n\tint keylen;\n\tint i;\n\n\tfor (i = 0; i != trees_count; i++) {\n\t\tif (verbose > 0) {\n\t\t\tprintf(\"Populating %s_%x\\n\",\n\t\t\t\ttrees[i].type, trees[i].maxage);\n\t\t}\n\t\tfor (unichar = 0; unichar != 0x110000; unichar++) {\n\t\t\tif (unicode_data[unichar].gen < 0)\n\t\t\t\tcontinue;\n\t\t\tkeylen = utf8encode(keyval, unichar);\n\t\t\tdata = corrections_lookup(&unicode_data[unichar]);\n\t\t\tif (data->correction <= trees[i].maxage)\n\t\t\t\tdata = &unicode_data[unichar];\n\t\t\tinsert(&trees[i], keyval, keylen, data);\n\t\t}\n\t}\n}\n\nstatic void trees_reduce(void)\n{\n\tint i;\n\tint size;\n\tint changed;\n\n\tfor (i = 0; i != trees_count; i++)\n\t\tprune(&trees[i]);\n\tfor (i = 0; i != trees_count; i++)\n\t\tmark_nodes(&trees[i]);\n\tdo {\n\t\tsize = 0;\n\t\tfor (i = 0; i != trees_count; i++)\n\t\t\tsize = index_nodes(&trees[i], size);\n\t\tchanged = 0;\n\t\tfor (i = 0; i != trees_count; i++)\n\t\t\tchanged += size_nodes(&trees[i]);\n\t} while (changed);\n\n\tutf8data = calloc(size, 1);\n\tutf8data_size = size;\n\tfor (i = 0; i != trees_count; i++)\n\t\temit(&trees[i], utf8data);\n\n\tif (verbose > 0) {\n\t\tfor (i = 0; i != trees_count; i++) {\n\t\t\tprintf(\"%s_%x idx %d\\n\",\n\t\t\t\ttrees[i].type, trees[i].maxage, trees[i].index);\n\t\t}\n\t}\n\n\tnfdi = utf8data + trees[trees_count-1].index;\n\tnfdicf = utf8data + trees[trees_count-2].index;\n\n\tnfdi_tree = &trees[trees_count-1];\n\tnfdicf_tree = &trees[trees_count-2];\n}\n\nstatic void verify(struct tree *tree)\n{\n\tstruct unicode_data *data;\n\tutf8leaf_t\t*leaf;\n\tunsigned int\tunichar;\n\tchar\t\tkey[4];\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\tint\t\treport;\n\tint\t\tnocf;\n\n\tif (verbose > 0)\n\t\tprintf(\"Verifying %s_%x\\n\", tree->type, tree->maxage);\n\tnocf = strcmp(tree->type, \"nfdicf\");\n\n\tfor (unichar = 0; unichar != 0x110000; unichar++) {\n\t\treport = 0;\n\t\tdata = corrections_lookup(&unicode_data[unichar]);\n\t\tif (data->correction <= tree->maxage)\n\t\t\tdata = &unicode_data[unichar];\n\t\tutf8encode(key,unichar);\n\t\tleaf = utf8lookup(tree, hangul, key);\n\n\t\tif (!leaf) {\n\t\t\tif (data->gen != -1)\n\t\t\t\treport++;\n\t\t\tif (unichar < 0xd800 || unichar > 0xdfff)\n\t\t\t\treport++;\n\t\t} else {\n\t\t\tif (unichar >= 0xd800 && unichar <= 0xdfff)\n\t\t\t\treport++;\n\t\t\tif (data->gen == -1)\n\t\t\t\treport++;\n\t\t\tif (data->gen != LEAF_GEN(leaf))\n\t\t\t\treport++;\n\t\t\tif (LEAF_CCC(leaf) == DECOMPOSE) {\n\t\t\t\tif (HANGUL_SYLLABLE(data->code)) {\n\t\t\t\t\tif (data->utf8nfdi[0] != HANGUL)\n\t\t\t\t\t\treport++;\n\t\t\t\t} else if (nocf) {\n\t\t\t\t\tif (!data->utf8nfdi) {\n\t\t\t\t\t\treport++;\n\t\t\t\t\t} else if (strcmp(data->utf8nfdi,\n\t\t\t\t\t\t\t  LEAF_STR(leaf))) {\n\t\t\t\t\t\treport++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!data->utf8nfdicf &&\n\t\t\t\t\t    !data->utf8nfdi) {\n\t\t\t\t\t\treport++;\n\t\t\t\t\t} else if (data->utf8nfdicf) {\n\t\t\t\t\t\tif (strcmp(data->utf8nfdicf,\n\t\t\t\t\t\t\t   LEAF_STR(leaf)))\n\t\t\t\t\t\t\treport++;\n\t\t\t\t\t} else if (strcmp(data->utf8nfdi,\n\t\t\t\t\t\t\t  LEAF_STR(leaf))) {\n\t\t\t\t\t\treport++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (data->ccc != LEAF_CCC(leaf)) {\n\t\t\t\treport++;\n\t\t\t}\n\t\t}\n\t\tif (report) {\n\t\t\tprintf(\"%X code %X gen %d ccc %d\"\n\t\t\t\t\" nfdi -> \\\"%s\\\"\",\n\t\t\t\tunichar, data->code, data->gen,\n\t\t\t\tdata->ccc,\n\t\t\t\tdata->utf8nfdi);\n\t\t\tif (leaf) {\n\t\t\t\tprintf(\" gen %d ccc %d\"\n\t\t\t\t\t\" nfdi -> \\\"%s\\\"\",\n\t\t\t\t\tLEAF_GEN(leaf),\n\t\t\t\t\tLEAF_CCC(leaf),\n\t\t\t\t\tLEAF_CCC(leaf) == DECOMPOSE ?\n\t\t\t\t\t\tLEAF_STR(leaf) : \"\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nstatic void trees_verify(void)\n{\n\tint i;\n\n\tfor (i = 0; i != trees_count; i++)\n\t\tverify(&trees[i]);\n}\n\n \n\nstatic void help(void)\n{\n\tprintf(\"Usage: %s [options]\\n\", argv0);\n\tprintf(\"\\n\");\n\tprintf(\"This program creates an a data trie used for parsing and\\n\");\n\tprintf(\"normalization of UTF-8 strings. The trie is derived from\\n\");\n\tprintf(\"a set of input files from the Unicode character database\\n\");\n\tprintf(\"found at: http://www.unicode.org/Public/UCD/latest/ucd/\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"The generated tree supports two normalization forms:\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"\\tnfdi:\\n\");\n\tprintf(\"\\t- Apply unicode normalization form NFD.\\n\");\n\tprintf(\"\\t- Remove any Default_Ignorable_Code_Point.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"\\tnfdicf:\\n\");\n\tprintf(\"\\t- Apply unicode normalization form NFD.\\n\");\n\tprintf(\"\\t- Remove any Default_Ignorable_Code_Point.\\n\");\n\tprintf(\"\\t- Apply a full casefold (C + F).\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"These forms were chosen as being most useful when dealing\\n\");\n\tprintf(\"with file names: NFD catches most cases where characters\\n\");\n\tprintf(\"should be considered equivalent. The ignorables are mostly\\n\");\n\tprintf(\"invisible, making names hard to type.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"The options to specify the files to be used are listed\\n\");\n\tprintf(\"below with their default values, which are the names used\\n\");\n\tprintf(\"by version 11.0.0 of the Unicode Character Database.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"The input files:\\n\");\n\tprintf(\"\\t-a %s\\n\", AGE_NAME);\n\tprintf(\"\\t-c %s\\n\", CCC_NAME);\n\tprintf(\"\\t-p %s\\n\", PROP_NAME);\n\tprintf(\"\\t-d %s\\n\", DATA_NAME);\n\tprintf(\"\\t-f %s\\n\", FOLD_NAME);\n\tprintf(\"\\t-n %s\\n\", NORM_NAME);\n\tprintf(\"\\n\");\n\tprintf(\"Additionally, the generated tables are tested using:\\n\");\n\tprintf(\"\\t-t %s\\n\", TEST_NAME);\n\tprintf(\"\\n\");\n\tprintf(\"Finally, the output file:\\n\");\n\tprintf(\"\\t-o %s\\n\", UTF8_NAME);\n\tprintf(\"\\n\");\n}\n\nstatic void usage(void)\n{\n\thelp();\n\texit(1);\n}\n\nstatic void open_fail(const char *name, int error)\n{\n\tprintf(\"Error %d opening %s: %s\\n\", error, name, strerror(error));\n\texit(1);\n}\n\nstatic void file_fail(const char *filename)\n{\n\tprintf(\"Error parsing %s\\n\", filename);\n\texit(1);\n}\n\nstatic void line_fail(const char *filename, const char *line)\n{\n\tprintf(\"Error parsing %s:%s\\n\", filename, line);\n\texit(1);\n}\n\n \n\nstatic void print_utf32(unsigned int *utf32str)\n{\n\tint\ti;\n\n\tfor (i = 0; utf32str[i]; i++)\n\t\tprintf(\" %X\", utf32str[i]);\n}\n\nstatic void print_utf32nfdi(unsigned int unichar)\n{\n\tprintf(\" %X ->\", unichar);\n\tprint_utf32(unicode_data[unichar].utf32nfdi);\n\tprintf(\"\\n\");\n}\n\nstatic void print_utf32nfdicf(unsigned int unichar)\n{\n\tprintf(\" %X ->\", unichar);\n\tprint_utf32(unicode_data[unichar].utf32nfdicf);\n\tprintf(\"\\n\");\n}\n\n \n\nstatic void age_init(void)\n{\n\tFILE *file;\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int unichar;\n\tunsigned int major;\n\tunsigned int minor;\n\tunsigned int revision;\n\tint gen;\n\tint count;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", age_name);\n\n\tfile = fopen(age_name, \"r\");\n\tif (!file)\n\t\topen_fail(age_name, errno);\n\tcount = 0;\n\n\tgen = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"# Age=V%d_%d_%d\",\n\t\t\t\t&major, &minor, &revision);\n\t\tif (ret == 3) {\n\t\t\tages_count++;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" Age V%d_%d_%d\\n\",\n\t\t\t\t\tmajor, minor, revision);\n\t\t\tif (!age_valid(major, minor, revision))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"# Age=V%d_%d\", &major, &minor);\n\t\tif (ret == 2) {\n\t\t\tages_count++;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" Age V%d_%d\\n\", major, minor);\n\t\t\tif (!age_valid(major, minor, 0))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tif (verbose > 1)\n\t\tprintf(\"%d age entries\\n\", ages_count);\n\tif (ages_count == 0 || ages_count > MAXGEN)\n\t\tfile_fail(age_name);\n\n\t \n\tages_count++;\n\tages = calloc(ages_count + 1, sizeof(*ages));\n\t \n\tages[ages_count] = (unsigned int)-1;\n\n\trewind(file);\n\tcount = 0;\n\tgen = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"# Age=V%d_%d_%d\",\n\t\t\t\t&major, &minor, &revision);\n\t\tif (ret == 3) {\n\t\t\tages[++gen] =\n\t\t\t\tUNICODE_AGE(major, minor, revision);\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" Age V%d_%d_%d = gen %d\\n\",\n\t\t\t\t\tmajor, minor, revision, gen);\n\t\t\tif (!age_valid(major, minor, revision))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"# Age=V%d_%d\", &major, &minor);\n\t\tif (ret == 2) {\n\t\t\tages[++gen] = UNICODE_AGE(major, minor, 0);\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" Age V%d_%d = %d\\n\",\n\t\t\t\t\tmajor, minor, gen);\n\t\t\tif (!age_valid(major, minor, 0))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"%X..%X ; %d.%d #\",\n\t\t\t     &first, &last, &major, &minor);\n\t\tif (ret == 4) {\n\t\t\tfor (unichar = first; unichar <= last; unichar++)\n\t\t\t\tunicode_data[unichar].gen = gen;\n\t\t\tcount += 1 + last - first;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\"  %X..%X gen %d\\n\", first, last, gen);\n\t\t\tif (!utf32valid(first) || !utf32valid(last))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"%X ; %d.%d #\", &unichar, &major, &minor);\n\t\tif (ret == 3) {\n\t\t\tunicode_data[unichar].gen = gen;\n\t\t\tcount++;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\"  %X gen %d\\n\", unichar, gen);\n\t\t\tif (!utf32valid(unichar))\n\t\t\t\tline_fail(age_name, line);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tunicode_maxage = ages[gen];\n\tfclose(file);\n\n\t \n\tif (verbose > 1)\n\t\tprintf(\" Removing surrogate block D800..DFFF\\n\");\n\tfor (unichar = 0xd800; unichar <= 0xdfff; unichar++)\n\t\tunicode_data[unichar].gen = -1;\n\n\tif (verbose > 0)\n\t        printf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(age_name);\n}\n\nstatic void ccc_init(void)\n{\n\tFILE *file;\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int unichar;\n\tunsigned int value;\n\tint count;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", ccc_name);\n\n\tfile = fopen(ccc_name, \"r\");\n\tif (!file)\n\t\topen_fail(ccc_name, errno);\n\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X..%X ; %d #\", &first, &last, &value);\n\t\tif (ret == 3) {\n\t\t\tfor (unichar = first; unichar <= last; unichar++) {\n\t\t\t\tunicode_data[unichar].ccc = value;\n                                count++;\n\t\t\t}\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" %X..%X ccc %d\\n\", first, last, value);\n\t\t\tif (!utf32valid(first) || !utf32valid(last))\n\t\t\t\tline_fail(ccc_name, line);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"%X ; %d #\", &unichar, &value);\n\t\tif (ret == 2) {\n\t\t\tunicode_data[unichar].ccc = value;\n                        count++;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" %X ccc %d\\n\", unichar, value);\n\t\t\tif (!utf32valid(unichar))\n\t\t\t\tline_fail(ccc_name, line);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfclose(file);\n\n\tif (verbose > 0)\n\t\tprintf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(ccc_name);\n}\n\nstatic int ignore_compatibility_form(char *type)\n{\n\tint i;\n\tchar *ignored_types[] = {\"font\", \"noBreak\", \"initial\", \"medial\",\n\t\t\t\t \"final\", \"isolated\", \"circle\", \"super\",\n\t\t\t\t \"sub\", \"vertical\", \"wide\", \"narrow\",\n\t\t\t\t \"small\", \"square\", \"fraction\", \"compat\"};\n\n\tfor (i = 0 ; i < ARRAY_SIZE(ignored_types); i++)\n\t\tif (strcmp(type, ignored_types[i]) == 0)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void nfdi_init(void)\n{\n\tFILE *file;\n\tunsigned int unichar;\n\tunsigned int mapping[19];  \n\tchar *s;\n\tchar *type;\n\tunsigned int *um;\n\tint count;\n\tint i;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", data_name);\n\tfile = fopen(data_name, \"r\");\n\tif (!file)\n\t\topen_fail(data_name, errno);\n\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X;%*[^;];%*[^;];%*[^;];%*[^;];%[^;];\",\n\t\t\t     &unichar, buf0);\n\t\tif (ret != 2)\n\t\t\tcontinue;\n\t\tif (!utf32valid(unichar))\n\t\t\tline_fail(data_name, line);\n\n\t\ts = buf0;\n\t\t \n\t\tif (*s == '<') {\n\t\t\ttype = ++s;\n\t\t\twhile (*++s != '>');\n\t\t\t*s++ = '\\0';\n\t\t\tif(ignore_compatibility_form(type))\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\ti = 0;\n\t\twhile (*s) {\n\t\t\tmapping[i] = strtoul(s, &s, 16);\n\t\t\tif (!utf32valid(mapping[i]))\n\t\t\t\tline_fail(data_name, line);\n\t\t\ti++;\n\t\t}\n\t\tmapping[i++] = 0;\n\n\t\tum = malloc(i * sizeof(unsigned int));\n\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\tunicode_data[unichar].utf32nfdi = um;\n\n\t\tif (verbose > 1)\n\t\t\tprint_utf32nfdi(unichar);\n\t\tcount++;\n\t}\n\tfclose(file);\n\tif (verbose > 0)\n\t\tprintf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(data_name);\n}\n\nstatic void nfdicf_init(void)\n{\n\tFILE *file;\n\tunsigned int unichar;\n\tunsigned int mapping[19];  \n\tchar status;\n\tchar *s;\n\tunsigned int *um;\n\tint i;\n\tint count;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", fold_name);\n\tfile = fopen(fold_name, \"r\");\n\tif (!file)\n\t\topen_fail(fold_name, errno);\n\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X; %c; %[^;];\", &unichar, &status, buf0);\n\t\tif (ret != 3)\n\t\t\tcontinue;\n\t\tif (!utf32valid(unichar))\n\t\t\tline_fail(fold_name, line);\n\t\t \n\t\tif (status != 'C' && status != 'F')\n\t\t\tcontinue;\n\t\ts = buf0;\n\t\tif (*s == '<')\n\t\t\twhile (*s++ != ' ')\n\t\t\t\t;\n\t\ti = 0;\n\t\twhile (*s) {\n\t\t\tmapping[i] = strtoul(s, &s, 16);\n\t\t\tif (!utf32valid(mapping[i]))\n\t\t\t\tline_fail(fold_name, line);\n\t\t\ti++;\n\t\t}\n\t\tmapping[i++] = 0;\n\n\t\tum = malloc(i * sizeof(unsigned int));\n\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\tunicode_data[unichar].utf32nfdicf = um;\n\n\t\tif (verbose > 1)\n\t\t\tprint_utf32nfdicf(unichar);\n\t\tcount++;\n\t}\n\tfclose(file);\n\tif (verbose > 0)\n\t\tprintf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(fold_name);\n}\n\nstatic void ignore_init(void)\n{\n\tFILE *file;\n\tunsigned int unichar;\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int *um;\n\tint count;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", prop_name);\n\tfile = fopen(prop_name, \"r\");\n\tif (!file)\n\t\topen_fail(prop_name, errno);\n\tassert(file);\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X..%X ; %s # \", &first, &last, buf0);\n\t\tif (ret == 3) {\n\t\t\tif (strcmp(buf0, \"Default_Ignorable_Code_Point\"))\n\t\t\t\tcontinue;\n\t\t\tif (!utf32valid(first) || !utf32valid(last))\n\t\t\t\tline_fail(prop_name, line);\n\t\t\tfor (unichar = first; unichar <= last; unichar++) {\n\t\t\t\tfree(unicode_data[unichar].utf32nfdi);\n\t\t\t\tum = malloc(sizeof(unsigned int));\n\t\t\t\t*um = 0;\n\t\t\t\tunicode_data[unichar].utf32nfdi = um;\n\t\t\t\tfree(unicode_data[unichar].utf32nfdicf);\n\t\t\t\tum = malloc(sizeof(unsigned int));\n\t\t\t\t*um = 0;\n\t\t\t\tunicode_data[unichar].utf32nfdicf = um;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" %X..%X Default_Ignorable_Code_Point\\n\",\n\t\t\t\t\tfirst, last);\n\t\t\tcontinue;\n\t\t}\n\t\tret = sscanf(line, \"%X ; %s # \", &unichar, buf0);\n\t\tif (ret == 2) {\n\t\t\tif (strcmp(buf0, \"Default_Ignorable_Code_Point\"))\n\t\t\t\tcontinue;\n\t\t\tif (!utf32valid(unichar))\n\t\t\t\tline_fail(prop_name, line);\n\t\t\tfree(unicode_data[unichar].utf32nfdi);\n\t\t\tum = malloc(sizeof(unsigned int));\n\t\t\t*um = 0;\n\t\t\tunicode_data[unichar].utf32nfdi = um;\n\t\t\tfree(unicode_data[unichar].utf32nfdicf);\n\t\t\tum = malloc(sizeof(unsigned int));\n\t\t\t*um = 0;\n\t\t\tunicode_data[unichar].utf32nfdicf = um;\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\" %X Default_Ignorable_Code_Point\\n\",\n\t\t\t\t\tunichar);\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfclose(file);\n\n\tif (verbose > 0)\n\t\tprintf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(prop_name);\n}\n\nstatic void corrections_init(void)\n{\n\tFILE *file;\n\tunsigned int unichar;\n\tunsigned int major;\n\tunsigned int minor;\n\tunsigned int revision;\n\tunsigned int age;\n\tunsigned int *um;\n\tunsigned int mapping[19];  \n\tchar *s;\n\tint i;\n\tint count;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", norm_name);\n\tfile = fopen(norm_name, \"r\");\n\tif (!file)\n\t\topen_fail(norm_name, errno);\n\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X;%[^;];%[^;];%d.%d.%d #\",\n\t\t\t\t&unichar, buf0, buf1,\n\t\t\t\t&major, &minor, &revision);\n\t\tif (ret != 6)\n\t\t\tcontinue;\n\t\tif (!utf32valid(unichar) || !age_valid(major, minor, revision))\n\t\t\tline_fail(norm_name, line);\n\t\tcount++;\n\t}\n\tcorrections = calloc(count, sizeof(struct unicode_data));\n\tcorrections_count = count;\n\trewind(file);\n\n\tcount = 0;\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%X;%[^;];%[^;];%d.%d.%d #\",\n\t\t\t\t&unichar, buf0, buf1,\n\t\t\t\t&major, &minor, &revision);\n\t\tif (ret != 6)\n\t\t\tcontinue;\n\t\tif (!utf32valid(unichar) || !age_valid(major, minor, revision))\n\t\t\tline_fail(norm_name, line);\n\t\tcorrections[count] = unicode_data[unichar];\n\t\tassert(corrections[count].code == unichar);\n\t\tage = UNICODE_AGE(major, minor, revision);\n\t\tcorrections[count].correction = age;\n\n\t\ti = 0;\n\t\ts = buf0;\n\t\twhile (*s) {\n\t\t\tmapping[i] = strtoul(s, &s, 16);\n\t\t\tif (!utf32valid(mapping[i]))\n\t\t\t\tline_fail(norm_name, line);\n\t\t\ti++;\n\t\t}\n\t\tmapping[i++] = 0;\n\n\t\tum = malloc(i * sizeof(unsigned int));\n\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\tcorrections[count].utf32nfdi = um;\n\n\t\tif (verbose > 1)\n\t\t\tprintf(\" %X -> %s -> %s V%d_%d_%d\\n\",\n\t\t\t\tunichar, buf0, buf1, major, minor, revision);\n\t\tcount++;\n\t}\n\tfclose(file);\n\n\tif (verbose > 0)\n\t        printf(\"Found %d entries\\n\", count);\n\tif (count == 0)\n\t\tfile_fail(norm_name);\n}\n\n \n\n \n\nstatic void hangul_decompose(void)\n{\n\tunsigned int sb = 0xAC00;\n\tunsigned int lb = 0x1100;\n\tunsigned int vb = 0x1161;\n\tunsigned int tb = 0x11a7;\n\t \n\tunsigned int vc = 21;\n\tunsigned int tc = 28;\n\tunsigned int nc = (vc * tc);\n\t \n\tunsigned int unichar;\n\tunsigned int mapping[4];\n\tunsigned int *um;\n        int count;\n\tint i;\n\n\tif (verbose > 0)\n\t\tprintf(\"Decomposing hangul\\n\");\n\t \n\tcount = 0;\n\tfor (unichar = 0xAC00; unichar <= 0xD7A3; unichar++) {\n\t\tunsigned int si = unichar - sb;\n\t\tunsigned int li = si / nc;\n\t\tunsigned int vi = (si % nc) / tc;\n\t\tunsigned int ti = si % tc;\n\n\t\ti = 0;\n\t\tmapping[i++] = lb + li;\n\t\tmapping[i++] = vb + vi;\n\t\tif (ti)\n\t\t\tmapping[i++] = tb + ti;\n\t\tmapping[i++] = 0;\n\n\t\tassert(!unicode_data[unichar].utf32nfdi);\n\t\tum = malloc(i * sizeof(unsigned int));\n\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\tunicode_data[unichar].utf32nfdi = um;\n\n\t\tassert(!unicode_data[unichar].utf32nfdicf);\n\t\tum = malloc(i * sizeof(unsigned int));\n\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\tunicode_data[unichar].utf32nfdicf = um;\n\n\t\t \n\t\tunicode_data[unichar].utf8nfdi = malloc(2);\n\t\tunicode_data[unichar].utf8nfdi[0] = HANGUL;\n\t\tunicode_data[unichar].utf8nfdi[1] = '\\0';\n\n\t\tif (verbose > 1)\n\t\t\tprint_utf32nfdi(unichar);\n\n\t\tcount++;\n\t}\n\tif (verbose > 0)\n\t\tprintf(\"Created %d entries\\n\", count);\n}\n\nstatic void nfdi_decompose(void)\n{\n\tunsigned int unichar;\n\tunsigned int mapping[19];  \n\tunsigned int *um;\n\tunsigned int *dc;\n\tint count;\n\tint i;\n\tint j;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Decomposing nfdi\\n\");\n\n\tcount = 0;\n\tfor (unichar = 0; unichar != 0x110000; unichar++) {\n\t\tif (!unicode_data[unichar].utf32nfdi)\n\t\t\tcontinue;\n\t\tfor (;;) {\n\t\t\tret = 1;\n\t\t\ti = 0;\n\t\t\tum = unicode_data[unichar].utf32nfdi;\n\t\t\twhile (*um) {\n\t\t\t\tdc = unicode_data[*um].utf32nfdi;\n\t\t\t\tif (dc) {\n\t\t\t\t\tfor (j = 0; dc[j]; j++)\n\t\t\t\t\t\tmapping[i++] = dc[j];\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmapping[i++] = *um;\n\t\t\t\t}\n\t\t\t\tum++;\n\t\t\t}\n\t\t\tmapping[i++] = 0;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tfree(unicode_data[unichar].utf32nfdi);\n\t\t\tum = malloc(i * sizeof(unsigned int));\n\t\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\t\tunicode_data[unichar].utf32nfdi = um;\n\t\t}\n\t\t \n\t\tif (!unicode_data[unichar].utf32nfdicf) {\n\t\t\tum = malloc(i * sizeof(unsigned int));\n\t\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\t\tunicode_data[unichar].utf32nfdicf = um;\n\t\t}\n\t\tif (verbose > 1)\n\t\t\tprint_utf32nfdi(unichar);\n\t\tcount++;\n\t}\n\tif (verbose > 0)\n\t\tprintf(\"Processed %d entries\\n\", count);\n}\n\nstatic void nfdicf_decompose(void)\n{\n\tunsigned int unichar;\n\tunsigned int mapping[19];  \n\tunsigned int *um;\n\tunsigned int *dc;\n\tint count;\n\tint i;\n\tint j;\n\tint ret;\n\n\tif (verbose > 0)\n\t\tprintf(\"Decomposing nfdicf\\n\");\n\tcount = 0;\n\tfor (unichar = 0; unichar != 0x110000; unichar++) {\n\t\tif (!unicode_data[unichar].utf32nfdicf)\n\t\t\tcontinue;\n\t\tfor (;;) {\n\t\t\tret = 1;\n\t\t\ti = 0;\n\t\t\tum = unicode_data[unichar].utf32nfdicf;\n\t\t\twhile (*um) {\n\t\t\t\tdc = unicode_data[*um].utf32nfdicf;\n\t\t\t\tif (dc) {\n\t\t\t\t\tfor (j = 0; dc[j]; j++)\n\t\t\t\t\t\tmapping[i++] = dc[j];\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmapping[i++] = *um;\n\t\t\t\t}\n\t\t\t\tum++;\n\t\t\t}\n\t\t\tmapping[i++] = 0;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tfree(unicode_data[unichar].utf32nfdicf);\n\t\t\tum = malloc(i * sizeof(unsigned int));\n\t\t\tmemcpy(um, mapping, i * sizeof(unsigned int));\n\t\t\tunicode_data[unichar].utf32nfdicf = um;\n\t\t}\n\t\tif (verbose > 1)\n\t\t\tprint_utf32nfdicf(unichar);\n\t\tcount++;\n\t}\n\tif (verbose > 0)\n\t\tprintf(\"Processed %d entries\\n\", count);\n}\n\n \n\nint utf8agemax(struct tree *, const char *);\nint utf8nagemax(struct tree *, const char *, size_t);\nint utf8agemin(struct tree *, const char *);\nint utf8nagemin(struct tree *, const char *, size_t);\nssize_t utf8len(struct tree *, const char *);\nssize_t utf8nlen(struct tree *, const char *, size_t);\nstruct utf8cursor;\nint utf8cursor(struct utf8cursor *, struct tree *, const char *);\nint utf8ncursor(struct utf8cursor *, struct tree *, const char *, size_t);\nint utf8byte(struct utf8cursor *);\n\n \n\n \n#define SB\t(0xAC00)\n#define LB\t(0x1100)\n#define VB\t(0x1161)\n#define TB\t(0x11A7)\n#define LC\t(19)\n#define VC\t(21)\n#define TC\t(28)\n#define NC\t(VC * TC)\n#define SC\t(LC * NC)\n\n \nstatic utf8leaf_t *utf8hangul(const char *str, unsigned char *hangul)\n{\n\tunsigned int\tsi;\n\tunsigned int\tli;\n\tunsigned int\tvi;\n\tunsigned int\tti;\n\tunsigned char\t*h;\n\n\t \n\tsi = utf8decode(str) - SB;\n\tli = si / NC;\n\tvi = (si % NC) / TC;\n\tti = si % TC;\n\n\t \n\th = hangul;\n\tLEAF_GEN(h) = 2;\n\tLEAF_CCC(h) = DECOMPOSE;\n\th += 2;\n\n\t \n\th += utf8encode((char *)h, li + LB);\n\n\t \n\th += utf8encode((char *)h, vi + VB);\n\n\t \n\tif (ti)\n\t\th += utf8encode((char *)h, ti + TB);\n\n\t \n\th[0] = '\\0';\n\n\treturn hangul;\n}\n\n \nstatic utf8leaf_t *utf8nlookup(struct tree *tree, unsigned char *hangul,\n\t\t\t       const char *s, size_t len)\n{\n\tutf8trie_t\t*trie;\n\tint\t\tofflen;\n\tint\t\toffset;\n\tint\t\tmask;\n\tint\t\tnode;\n\n\tif (!tree)\n\t\treturn NULL;\n\tif (len == 0)\n\t\treturn NULL;\n\tnode = 1;\n\ttrie = utf8data + tree->index;\n\twhile (node) {\n\t\tofflen = (*trie & OFFLEN) >> OFFLEN_SHIFT;\n\t\tif (*trie & NEXTBYTE) {\n\t\t\tif (--len == 0)\n\t\t\t\treturn NULL;\n\t\t\ts++;\n\t\t}\n\t\tmask = 1 << (*trie & BITNUM);\n\t\tif (*s & mask) {\n\t\t\t \n\t\t\tif (offlen) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & RIGHTNODE);\n\t\t\t\toffset = trie[offlen];\n\t\t\t\twhile (--offlen) {\n\t\t\t\t\toffset <<= 8;\n\t\t\t\t\toffset |= trie[offlen];\n\t\t\t\t}\n\t\t\t\ttrie += offset;\n\t\t\t} else if (*trie & RIGHTPATH) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & TRIENODE);\n\t\t\t\ttrie++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (offlen) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & LEFTNODE);\n\t\t\t\ttrie += offlen + 1;\n\t\t\t} else if (*trie & RIGHTPATH) {\n\t\t\t\t \n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnode = (*trie & TRIENODE);\n\t\t\t\ttrie++;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (LEAF_CCC(trie) == DECOMPOSE && LEAF_STR(trie)[0] == HANGUL)\n\t\ttrie = utf8hangul(s - 2, hangul);\n\treturn trie;\n}\n\n \nstatic utf8leaf_t *utf8lookup(struct tree *tree, unsigned char *hangul,\n\t\t\t      const char *s)\n{\n\treturn utf8nlookup(tree, hangul, s, (size_t)-1);\n}\n\n \nstatic inline int utf8clen(const char *s)\n{\n\tunsigned char c = *s;\n\treturn 1 + (c >= 0xC0) + (c >= 0xE0) + (c >= 0xF0);\n}\n\n \nint utf8agemax(struct tree *tree, const char *s)\n{\n\tutf8leaf_t\t*leaf;\n\tint\t\tage = 0;\n\tint\t\tleaf_age;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\n\twhile (*s) {\n\t\tleaf = utf8lookup(tree, hangul, s);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tleaf_age = ages[LEAF_GEN(leaf)];\n\t\tif (leaf_age <= tree->maxage && leaf_age > age)\n\t\t\tage = leaf_age;\n\t\ts += utf8clen(s);\n\t}\n\treturn age;\n}\n\n \nint utf8agemin(struct tree *tree, const char *s)\n{\n\tutf8leaf_t\t*leaf;\n\tint\t\tage;\n\tint\t\tleaf_age;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\tage = tree->maxage;\n\twhile (*s) {\n\t\tleaf = utf8lookup(tree, hangul, s);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tleaf_age = ages[LEAF_GEN(leaf)];\n\t\tif (leaf_age <= tree->maxage && leaf_age < age)\n\t\t\tage = leaf_age;\n\t\ts += utf8clen(s);\n\t}\n\treturn age;\n}\n\n \nint utf8nagemax(struct tree *tree, const char *s, size_t len)\n{\n\tutf8leaf_t\t*leaf;\n\tint\t\tage = 0;\n\tint\t\tleaf_age;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\n        while (len && *s) {\n\t\tleaf = utf8nlookup(tree, hangul, s, len);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tleaf_age = ages[LEAF_GEN(leaf)];\n\t\tif (leaf_age <= tree->maxage && leaf_age > age)\n\t\t\tage = leaf_age;\n\t\tlen -= utf8clen(s);\n\t\ts += utf8clen(s);\n\t}\n\treturn age;\n}\n\n \nint utf8nagemin(struct tree *tree, const char *s, size_t len)\n{\n\tutf8leaf_t\t*leaf;\n\tint\t\tleaf_age;\n\tint\t\tage;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\tage = tree->maxage;\n        while (len && *s) {\n\t\tleaf = utf8nlookup(tree, hangul, s, len);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tleaf_age = ages[LEAF_GEN(leaf)];\n\t\tif (leaf_age <= tree->maxage && leaf_age < age)\n\t\t\tage = leaf_age;\n\t\tlen -= utf8clen(s);\n\t\ts += utf8clen(s);\n\t}\n\treturn age;\n}\n\n \nssize_t utf8len(struct tree *tree, const char *s)\n{\n\tutf8leaf_t\t*leaf;\n\tsize_t\t\tret = 0;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\twhile (*s) {\n\t\tleaf = utf8lookup(tree, hangul, s);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tif (ages[LEAF_GEN(leaf)] > tree->maxage)\n\t\t\tret += utf8clen(s);\n\t\telse if (LEAF_CCC(leaf) == DECOMPOSE)\n\t\t\tret += strlen(LEAF_STR(leaf));\n\t\telse\n\t\t\tret += utf8clen(s);\n\t\ts += utf8clen(s);\n\t}\n\treturn ret;\n}\n\n \nssize_t utf8nlen(struct tree *tree, const char *s, size_t len)\n{\n\tutf8leaf_t\t*leaf;\n\tsize_t\t\tret = 0;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\tif (!tree)\n\t\treturn -1;\n\twhile (len && *s) {\n\t\tleaf = utf8nlookup(tree, hangul, s, len);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tif (ages[LEAF_GEN(leaf)] > tree->maxage)\n\t\t\tret += utf8clen(s);\n\t\telse if (LEAF_CCC(leaf) == DECOMPOSE)\n\t\t\tret += strlen(LEAF_STR(leaf));\n\t\telse\n\t\t\tret += utf8clen(s);\n\t\tlen -= utf8clen(s);\n\t\ts += utf8clen(s);\n\t}\n\treturn ret;\n}\n\n \nstruct utf8cursor {\n\tstruct tree\t*tree;\n\tconst char\t*s;\n\tconst char\t*p;\n\tconst char\t*ss;\n\tconst char\t*sp;\n\tunsigned int\tlen;\n\tunsigned int\tslen;\n\tshort int\tccc;\n\tshort int\tnccc;\n\tunsigned int\tunichar;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n};\n\n \nint utf8ncursor(struct utf8cursor *u8c, struct tree *tree, const char *s,\n\t\tsize_t len)\n{\n\tif (!tree)\n\t\treturn -1;\n\tif (!s)\n\t\treturn -1;\n\tu8c->tree = tree;\n\tu8c->s = s;\n\tu8c->p = NULL;\n\tu8c->ss = NULL;\n\tu8c->sp = NULL;\n\tu8c->len = len;\n\tu8c->slen = 0;\n\tu8c->ccc = STOPPER;\n\tu8c->nccc = STOPPER;\n\tu8c->unichar = 0;\n\t \n\tif (u8c->len != len)\n\t\treturn -1;\n\t \n\tif (len > 0 && (*s & 0xC0) == 0x80)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nint utf8cursor(struct utf8cursor *u8c, struct tree *tree, const char *s)\n{\n\treturn utf8ncursor(u8c, tree, s, (unsigned int)-1);\n}\n\n \nint utf8byte(struct utf8cursor *u8c)\n{\n\tutf8leaf_t *leaf;\n\tint ccc;\n\n\tfor (;;) {\n\t\t \n\t\tif (u8c->p && *u8c->s == '\\0') {\n\t\t\tu8c->s = u8c->p;\n\t\t\tu8c->p = NULL;\n\t\t}\n\n\t\t \n\t\tif (!u8c->p && (u8c->len == 0 || *u8c->s == '\\0')) {\n\t\t\t \n\t\t\tif (u8c->ccc == STOPPER)\n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tccc = STOPPER;\n\t\t\tgoto ccc_mismatch;\n\t\t} else if ((*u8c->s & 0xC0) == 0x80) {\n\t\t\t \n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len--;\n\t\t\treturn (unsigned char)*u8c->s++;\n\t\t}\n\n\t\t \n\t\tif (u8c->p) {\n\t\t\tleaf = utf8lookup(u8c->tree, u8c->hangul, u8c->s);\n\t\t} else {\n\t\t\tleaf = utf8nlookup(u8c->tree, u8c->hangul,\n\t\t\t\t\t   u8c->s, u8c->len);\n\t\t}\n\n\t\t \n\t\tif (!leaf)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (ages[LEAF_GEN(leaf)] > u8c->tree->maxage) {\n\t\t\tccc = STOPPER;\n\t\t} else if ((ccc = LEAF_CCC(leaf)) == DECOMPOSE) {\n\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->p = u8c->s + utf8clen(u8c->s);\n\t\t\tu8c->s = LEAF_STR(leaf);\n\t\t\t \n\t\t\tif (*u8c->s == '\\0') {\n\t\t\t\tif (u8c->ccc == STOPPER)\n\t\t\t\t\tcontinue;\n\t\t\t\tccc = STOPPER;\n\t\t\t\tgoto ccc_mismatch;\n\t\t\t}\n\t\t\tleaf = utf8lookup(u8c->tree, u8c->hangul, u8c->s);\n\t\t\tccc = LEAF_CCC(leaf);\n\t\t}\n\t\tu8c->unichar = utf8decode(u8c->s);\n\n\t\t \n\t\tif (ccc != STOPPER && u8c->ccc < ccc && ccc < u8c->nccc)\n\t\t\tu8c->nccc = ccc;\n\n\t\t \n\t\tif (ccc == u8c->ccc) {\n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len--;\n\t\t\treturn (unsigned char)*u8c->s++;\n\t\t}\n\n\t\t \n\tccc_mismatch:\n\t\tif (u8c->nccc == STOPPER) {\n\t\t\t \n\t\t\tassert(u8c->ccc == STOPPER);\n\t\t\tu8c->ccc = MINCCC - 1;\n\t\t\tu8c->nccc = ccc;\n\t\t\tu8c->sp = u8c->p;\n\t\t\tu8c->ss = u8c->s;\n\t\t\tu8c->slen = u8c->len;\n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->s += utf8clen(u8c->s);\n\t\t} else if (ccc != STOPPER) {\n\t\t\t \n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->s += utf8clen(u8c->s);\n\t\t} else if (u8c->nccc != MAXCCC + 1) {\n\t\t\t \n\t\t\tu8c->ccc = u8c->nccc;\n\t\t\tu8c->nccc = MAXCCC + 1;\n\t\t\tu8c->s = u8c->ss;\n\t\t\tu8c->p = u8c->sp;\n\t\t\tu8c->len = u8c->slen;\n\t\t} else {\n\t\t\t \n\t\t\tu8c->ccc = STOPPER;\n\t\t\tu8c->nccc = STOPPER;\n\t\t\tu8c->sp = NULL;\n\t\t\tu8c->ss = NULL;\n\t\t\tu8c->slen = 0;\n\t\t}\n\t}\n}\n\n \n\nstatic int normalize_line(struct tree *tree)\n{\n\tchar *s;\n\tchar *t;\n\tint c;\n\tstruct utf8cursor u8c;\n\n\t \n\ts = buf2;\n\tt = buf3;\n\tif (utf8cursor(&u8c, tree, s))\n\t\treturn -1;\n\twhile ((c = utf8byte(&u8c)) > 0)\n\t\tif (c != (unsigned char)*t++)\n\t\t\treturn -1;\n\tif (c < 0)\n\t\treturn -1;\n\tif (*t != 0)\n\t\treturn -1;\n\n\t \n\ts = buf2;\n\t \n\ts[strlen(s) + 1] = -1;\n\tt = buf3;\n\tif (utf8cursor(&u8c, tree, s))\n\t\treturn -1;\n\twhile ((c = utf8byte(&u8c)) > 0)\n\t\tif (c != (unsigned char)*t++)\n\t\t\treturn -1;\n\tif (c < 0)\n\t\treturn -1;\n\tif (*t != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void normalization_test(void)\n{\n\tFILE *file;\n\tunsigned int unichar;\n\tstruct unicode_data *data;\n\tchar *s;\n\tchar *t;\n\tint ret;\n\tint ignorables;\n\tint tests = 0;\n\tint failures = 0;\n\n\tif (verbose > 0)\n\t\tprintf(\"Parsing %s\\n\", test_name);\n\t \n\tfile = fopen(test_name, \"r\");\n\tif (!file)\n\t\topen_fail(test_name, errno);\n\n\twhile (fgets(line, LINESIZE, file)) {\n\t\tret = sscanf(line, \"%[^;];%*[^;];%[^;];%*[^;];%*[^;];\",\n\t\t\t     buf0, buf1);\n\t\tif (ret != 2 || *line == '#')\n\t\t\tcontinue;\n\t\ts = buf0;\n\t\tt = buf2;\n\t\twhile (*s) {\n\t\t\tunichar = strtoul(s, &s, 16);\n\t\t\tt += utf8encode(t, unichar);\n\t\t}\n\t\t*t = '\\0';\n\n\t\tignorables = 0;\n\t\ts = buf1;\n\t\tt = buf3;\n\t\twhile (*s) {\n\t\t\tunichar = strtoul(s, &s, 16);\n\t\t\tdata = &unicode_data[unichar];\n\t\t\tif (data->utf8nfdi && !*data->utf8nfdi)\n\t\t\t\tignorables = 1;\n\t\t\telse\n\t\t\t\tt += utf8encode(t, unichar);\n\t\t}\n\t\t*t = '\\0';\n\n\t\ttests++;\n\t\tif (normalize_line(nfdi_tree) < 0) {\n\t\t\tprintf(\"Line %s -> %s\", buf0, buf1);\n\t\t\tif (ignorables)\n\t\t\t\tprintf(\" (ignorables removed)\");\n\t\t\tprintf(\" failure\\n\");\n\t\t\tfailures++;\n\t\t}\n\t}\n\tfclose(file);\n\tif (verbose > 0)\n\t\tprintf(\"Ran %d tests with %d failures\\n\", tests, failures);\n\tif (failures)\n\t\tfile_fail(test_name);\n}\n\n \n\nstatic void write_file(void)\n{\n\tFILE *file;\n\tint i;\n\tint j;\n\tint t;\n\tint gen;\n\n\tif (verbose > 0)\n\t\tprintf(\"Writing %s\\n\", utf8_name);\n\tfile = fopen(utf8_name, \"w\");\n\tif (!file)\n\t\topen_fail(utf8_name, errno);\n\n\tfprintf(file, \"/* This file is generated code, do not edit. */\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"#include <linux/module.h>\\n\");\n\tfprintf(file, \"#include <linux/kernel.h>\\n\");\n\tfprintf(file, \"#include \\\"utf8n.h\\\"\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"static const unsigned int utf8agetab[] = {\\n\");\n\tfor (i = 0; i != ages_count; i++)\n\t\tfprintf(file, \"\\t%#x%s\\n\", ages[i],\n\t\t\tages[i] == unicode_maxage ? \"\" : \",\");\n\tfprintf(file, \"};\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"static const struct utf8data utf8nfdicfdata[] = {\\n\");\n\tt = 0;\n\tfor (gen = 0; gen < ages_count; gen++) {\n\t\tfprintf(file, \"\\t{ %#x, %d }%s\\n\",\n\t\t\tages[gen], trees[t].index,\n\t\t\tages[gen] == unicode_maxage ? \"\" : \",\");\n\t\tif (trees[t].maxage == ages[gen])\n\t\t\tt += 2;\n\t}\n\tfprintf(file, \"};\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"static const struct utf8data utf8nfdidata[] = {\\n\");\n\tt = 1;\n\tfor (gen = 0; gen < ages_count; gen++) {\n\t\tfprintf(file, \"\\t{ %#x, %d }%s\\n\",\n\t\t\tages[gen], trees[t].index,\n\t\t\tages[gen] == unicode_maxage ? \"\" : \",\");\n\t\tif (trees[t].maxage == ages[gen])\n\t\t\tt += 2;\n\t}\n\tfprintf(file, \"};\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"static const unsigned char utf8data[%zd] = {\\n\",\n\t\tutf8data_size);\n\tt = 0;\n\tfor (i = 0; i != utf8data_size; i += 16) {\n\t\tif (i == trees[t].index) {\n\t\t\tfprintf(file, \"\\t/* %s_%x */\\n\",\n\t\t\t\ttrees[t].type, trees[t].maxage);\n\t\t\tif (t < trees_count-1)\n\t\t\t\tt++;\n\t\t}\n\t\tfprintf(file, \"\\t\");\n\t\tfor (j = i; j != i + 16; j++)\n\t\t\tfprintf(file, \"0x%.2x%s\", utf8data[j],\n\t\t\t\t(j < utf8data_size -1 ? \",\" : \"\"));\n\t\tfprintf(file, \"\\n\");\n\t}\n\tfprintf(file, \"};\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"struct utf8data_table utf8_data_table = {\\n\");\n\tfprintf(file, \"\\t.utf8agetab = utf8agetab,\\n\");\n\tfprintf(file, \"\\t.utf8agetab_size = ARRAY_SIZE(utf8agetab),\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"\\t.utf8nfdicfdata = utf8nfdicfdata,\\n\");\n\tfprintf(file, \"\\t.utf8nfdicfdata_size = ARRAY_SIZE(utf8nfdicfdata),\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"\\t.utf8nfdidata = utf8nfdidata,\\n\");\n\tfprintf(file, \"\\t.utf8nfdidata_size = ARRAY_SIZE(utf8nfdidata),\\n\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"\\t.utf8data = utf8data,\\n\");\n\tfprintf(file, \"};\\n\");\n\tfprintf(file, \"EXPORT_SYMBOL_GPL(utf8_data_table);\");\n\tfprintf(file, \"\\n\");\n\tfprintf(file, \"MODULE_LICENSE(\\\"GPL v2\\\");\\n\");\n\tfclose(file);\n}\n\n \n\nint main(int argc, char *argv[])\n{\n\tunsigned int unichar;\n\tint opt;\n\n\targv0 = argv[0];\n\n\twhile ((opt = getopt(argc, argv, \"a:c:d:f:hn:o:p:t:v\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tage_name = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tccc_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdata_name = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfold_name = optarg;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnorm_name = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tutf8_name = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tprop_name = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttest_name = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp();\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (verbose > 1)\n\t\thelp();\n\tfor (unichar = 0; unichar != 0x110000; unichar++)\n\t\tunicode_data[unichar].code = unichar;\n\tage_init();\n\tccc_init();\n\tnfdi_init();\n\tnfdicf_init();\n\tignore_init();\n\tcorrections_init();\n\thangul_decompose();\n\tnfdi_decompose();\n\tnfdicf_decompose();\n\tutf8_init();\n\ttrees_init();\n\ttrees_populate();\n\ttrees_reduce();\n\ttrees_verify();\n\t \n\t(void)lookup(nfdi_tree, \" \");\n\tif (verbose > 2)\n\t\ttree_walk(nfdi_tree);\n\tif (verbose > 2)\n\t\ttree_walk(nfdicf_tree);\n\tnormalization_test();\n\twrite_file();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}