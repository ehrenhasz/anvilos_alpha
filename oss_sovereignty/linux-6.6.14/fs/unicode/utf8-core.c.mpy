{
  "module_name": "utf8-core.c",
  "hash_id": "d6613dea0717819e4b09a7d5a3a94b7cfd1b89ef2fced524a0c852a91ad1c1c2",
  "original_prompt": "Ingested from linux-6.6.14/fs/unicode/utf8-core.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/errno.h>\n#include <linux/stringhash.h>\n\n#include \"utf8n.h\"\n\nint utf8_validate(const struct unicode_map *um, const struct qstr *str)\n{\n\tif (utf8nlen(um, UTF8_NFDI, str->name, str->len) < 0)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL(utf8_validate);\n\nint utf8_strncmp(const struct unicode_map *um,\n\t\t const struct qstr *s1, const struct qstr *s2)\n{\n\tstruct utf8cursor cur1, cur2;\n\tint c1, c2;\n\n\tif (utf8ncursor(&cur1, um, UTF8_NFDI, s1->name, s1->len) < 0)\n\t\treturn -EINVAL;\n\n\tif (utf8ncursor(&cur2, um, UTF8_NFDI, s2->name, s2->len) < 0)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tc1 = utf8byte(&cur1);\n\t\tc2 = utf8byte(&cur2);\n\n\t\tif (c1 < 0 || c2 < 0)\n\t\t\treturn -EINVAL;\n\t\tif (c1 != c2)\n\t\t\treturn 1;\n\t} while (c1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(utf8_strncmp);\n\nint utf8_strncasecmp(const struct unicode_map *um,\n\t\t     const struct qstr *s1, const struct qstr *s2)\n{\n\tstruct utf8cursor cur1, cur2;\n\tint c1, c2;\n\n\tif (utf8ncursor(&cur1, um, UTF8_NFDICF, s1->name, s1->len) < 0)\n\t\treturn -EINVAL;\n\n\tif (utf8ncursor(&cur2, um, UTF8_NFDICF, s2->name, s2->len) < 0)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tc1 = utf8byte(&cur1);\n\t\tc2 = utf8byte(&cur2);\n\n\t\tif (c1 < 0 || c2 < 0)\n\t\t\treturn -EINVAL;\n\t\tif (c1 != c2)\n\t\t\treturn 1;\n\t} while (c1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(utf8_strncasecmp);\n\n \nint utf8_strncasecmp_folded(const struct unicode_map *um,\n\t\t\t    const struct qstr *cf,\n\t\t\t    const struct qstr *s1)\n{\n\tstruct utf8cursor cur1;\n\tint c1, c2;\n\tint i = 0;\n\n\tif (utf8ncursor(&cur1, um, UTF8_NFDICF, s1->name, s1->len) < 0)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tc1 = utf8byte(&cur1);\n\t\tc2 = cf->name[i++];\n\t\tif (c1 < 0)\n\t\t\treturn -EINVAL;\n\t\tif (c1 != c2)\n\t\t\treturn 1;\n\t} while (c1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(utf8_strncasecmp_folded);\n\nint utf8_casefold(const struct unicode_map *um, const struct qstr *str,\n\t\t  unsigned char *dest, size_t dlen)\n{\n\tstruct utf8cursor cur;\n\tsize_t nlen = 0;\n\n\tif (utf8ncursor(&cur, um, UTF8_NFDICF, str->name, str->len) < 0)\n\t\treturn -EINVAL;\n\n\tfor (nlen = 0; nlen < dlen; nlen++) {\n\t\tint c = utf8byte(&cur);\n\n\t\tdest[nlen] = c;\n\t\tif (!c)\n\t\t\treturn nlen;\n\t\tif (c == -1)\n\t\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(utf8_casefold);\n\nint utf8_casefold_hash(const struct unicode_map *um, const void *salt,\n\t\t       struct qstr *str)\n{\n\tstruct utf8cursor cur;\n\tint c;\n\tunsigned long hash = init_name_hash(salt);\n\n\tif (utf8ncursor(&cur, um, UTF8_NFDICF, str->name, str->len) < 0)\n\t\treturn -EINVAL;\n\n\twhile ((c = utf8byte(&cur))) {\n\t\tif (c < 0)\n\t\t\treturn -EINVAL;\n\t\thash = partial_name_hash((unsigned char)c, hash);\n\t}\n\tstr->hash = end_name_hash(hash);\n\treturn 0;\n}\nEXPORT_SYMBOL(utf8_casefold_hash);\n\nint utf8_normalize(const struct unicode_map *um, const struct qstr *str,\n\t\t   unsigned char *dest, size_t dlen)\n{\n\tstruct utf8cursor cur;\n\tssize_t nlen = 0;\n\n\tif (utf8ncursor(&cur, um, UTF8_NFDI, str->name, str->len) < 0)\n\t\treturn -EINVAL;\n\n\tfor (nlen = 0; nlen < dlen; nlen++) {\n\t\tint c = utf8byte(&cur);\n\n\t\tdest[nlen] = c;\n\t\tif (!c)\n\t\t\treturn nlen;\n\t\tif (c == -1)\n\t\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(utf8_normalize);\n\nstatic const struct utf8data *find_table_version(const struct utf8data *table,\n\t\tsize_t nr_entries, unsigned int version)\n{\n\tsize_t i = nr_entries - 1;\n\n\twhile (version < table[i].maxage)\n\t\ti--;\n\tif (version > table[i].maxage)\n\t\treturn NULL;\n\treturn &table[i];\n}\n\nstruct unicode_map *utf8_load(unsigned int version)\n{\n\tstruct unicode_map *um;\n\n\tum = kzalloc(sizeof(struct unicode_map), GFP_KERNEL);\n\tif (!um)\n\t\treturn ERR_PTR(-ENOMEM);\n\tum->version = version;\n\n\tum->tables = symbol_request(utf8_data_table);\n\tif (!um->tables)\n\t\tgoto out_free_um;\n\n\tif (!utf8version_is_supported(um, version))\n\t\tgoto out_symbol_put;\n\tum->ntab[UTF8_NFDI] = find_table_version(um->tables->utf8nfdidata,\n\t\t\tum->tables->utf8nfdidata_size, um->version);\n\tif (!um->ntab[UTF8_NFDI])\n\t\tgoto out_symbol_put;\n\tum->ntab[UTF8_NFDICF] = find_table_version(um->tables->utf8nfdicfdata,\n\t\t\tum->tables->utf8nfdicfdata_size, um->version);\n\tif (!um->ntab[UTF8_NFDICF])\n\t\tgoto out_symbol_put;\n\treturn um;\n\nout_symbol_put:\n\tsymbol_put(um->tables);\nout_free_um:\n\tkfree(um);\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL(utf8_load);\n\nvoid utf8_unload(struct unicode_map *um)\n{\n\tif (um) {\n\t\tsymbol_put(utf8_data_table);\n\t\tkfree(um);\n\t}\n}\nEXPORT_SYMBOL(utf8_unload);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}