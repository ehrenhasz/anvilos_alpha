{
  "module_name": "utf8-selftest.c",
  "hash_id": "8943616e95c074b77f26a341426c99a35f8f0b495065c009d0ff10970874216f",
  "original_prompt": "Ingested from linux-6.6.14/fs/unicode/utf8-selftest.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/unicode.h>\n#include <linux/dcache.h>\n\n#include \"utf8n.h\"\n\nunsigned int failed_tests;\nunsigned int total_tests;\n\n \n#define UTF8_LATEST\tUNICODE_AGE(12, 1, 0)\n\n#define _test(cond, func, line, fmt, ...) do {\t\t\t\t\\\n\t\ttotal_tests++;\t\t\t\t\t\t\\\n\t\tif (!cond) {\t\t\t\t\t\t\\\n\t\t\tfailed_tests++;\t\t\t\t\t\\\n\t\t\tpr_err(\"test %s:%d Failed: %s%s\",\t\t\\\n\t\t\t       func, line, #cond, (fmt?\":\":\".\"));\t\\\n\t\t\tif (fmt)\t\t\t\t\t\\\n\t\t\t\tpr_err(fmt, ##__VA_ARGS__);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#define test_f(cond, fmt, ...) _test(cond, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define test(cond) _test(cond, __func__, __LINE__, \"\")\n\nstatic const struct {\n\t \n\tunsigned char str[10];\n\tunsigned char dec[10];\n} nfdi_test_data[] = {\n\t \n\t{\n\t\t \n\t\t.str = \"aBba\",\n\t\t.dec = \"aBba\",\n\t},\n\t \n\t{\n                \n               .str = {0xc2, 0xbc, 0x00},\n\t       .dec = {0xc2, 0xbc, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xc3, 0xa4, 0x00},\n\t\t.dec = {0x61, 0xcc, 0x88, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xC7, 0x89, 0x00},\n\t\t.dec = {0xC7, 0x89, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xCE, 0x87, 0x00},\n\t\t.dec = {0xC2, 0xB7, 0x00}\n\t},\n\t \n\t{\n\t\t \n\t\t.str = {0x41, 0xcc, 0x81, 0xcc, 0xa8, 0x0},\n\t\t.dec = {0x41, 0xcc, 0xa8, 0xcc, 0x81, 0x0},\n\t},\n\t{\n\t\t \n\t\t.str = {0xc3, 0xa4, 0xCC, 0xA8, 0x00},\n\n\t\t.dec = {0x61, 0xCC, 0xA8, 0xcc, 0x88, 0x00},\n\t},\n\n};\n\nstatic const struct {\n\t \n\tunsigned char str[30];\n\tunsigned char ncf[30];\n} nfdicf_test_data[] = {\n\t \n\t{\n\t\t \n\t\t.str = {0x41, 0x42, 0x62, 0x61, 0x00},\n\t\t.ncf = {0x61, 0x62, 0x62, 0x61, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0.1\",\n\t\t.ncf = \"abcdefghijklmnopqrstuvwxyz0.1\",\n\t},\n\t{\n\t\t \n\t\t.str = {0xc3, 0x9f, 0x00},\n\t\t.ncf = {0x73, 0x73, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xC3, 0x85, 0x00},\n\t\t.ncf = {0x61, 0xcc, 0x8a, 0x00},\n\t},\n\t \n\t \n\t{\n\t\t \n\t\t.str = {0xea, 0xad, 0xb0, 0x00},\n\t\t.ncf = {0xe1, 0x8e, 0xa0, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xe1, 0x8f, 0xb8, 0x00},\n\t\t.ncf = {0xe1, 0x8f, 0xb0, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xf0, 0x90, 0xb2, 0x83, 0x00},\n\t\t.ncf = {0xf0, 0x90, 0xb3, 0x83, 0x00},\n\t},\n\t \n\t{\n\t\t \n\t\t.str = {0xf0, 0x90, 0x92, 0xb5, 0x00},\n\t\t.ncf = {0xf0, 0x90, 0x93, 0x9d, 0x00},\n\t},\n\t{\n\t\t \n\t\t.str = {0xea, 0x9e, 0xae, 0x00},\n\t\t.ncf = {0xc9, 0xaa, 0x00},\n\t},\n\t \n\t{\n\t\t \n\t\t.str = {0xe1, 0xb2, 0x90, 0x00},\n\t\t.ncf = {0xe1, 0x83, 0x90, 0x00},\n\t}\n};\n\nstatic ssize_t utf8len(const struct unicode_map *um, enum utf8_normalization n,\n\t\tconst char *s)\n{\n\treturn utf8nlen(um, n, s, (size_t)-1);\n}\n\nstatic int utf8cursor(struct utf8cursor *u8c, const struct unicode_map *um,\n\t\tenum utf8_normalization n, const char *s)\n{\n\treturn utf8ncursor(u8c, um, n, s, (unsigned int)-1);\n}\n\nstatic void check_utf8_nfdi(struct unicode_map *um)\n{\n\tint i;\n\tstruct utf8cursor u8c;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfdi_test_data); i++) {\n\t\tint len = strlen(nfdi_test_data[i].str);\n\t\tint nlen = strlen(nfdi_test_data[i].dec);\n\t\tint j = 0;\n\t\tunsigned char c;\n\n\t\ttest((utf8len(um, UTF8_NFDI, nfdi_test_data[i].str) == nlen));\n\t\ttest((utf8nlen(um, UTF8_NFDI, nfdi_test_data[i].str, len) ==\n\t\t\tnlen));\n\n\t\tif (utf8cursor(&u8c, um, UTF8_NFDI, nfdi_test_data[i].str) < 0)\n\t\t\tpr_err(\"can't create cursor\\n\");\n\n\t\twhile ((c = utf8byte(&u8c)) > 0) {\n\t\t\ttest_f((c == nfdi_test_data[i].dec[j]),\n\t\t\t       \"Unexpected byte 0x%x should be 0x%x\\n\",\n\t\t\t       c, nfdi_test_data[i].dec[j]);\n\t\t\tj++;\n\t\t}\n\n\t\ttest((j == nlen));\n\t}\n}\n\nstatic void check_utf8_nfdicf(struct unicode_map *um)\n{\n\tint i;\n\tstruct utf8cursor u8c;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfdicf_test_data); i++) {\n\t\tint len = strlen(nfdicf_test_data[i].str);\n\t\tint nlen = strlen(nfdicf_test_data[i].ncf);\n\t\tint j = 0;\n\t\tunsigned char c;\n\n\t\ttest((utf8len(um, UTF8_NFDICF, nfdicf_test_data[i].str) ==\n\t\t\t\tnlen));\n\t\ttest((utf8nlen(um, UTF8_NFDICF, nfdicf_test_data[i].str, len) ==\n\t\t\t\tnlen));\n\n\t\tif (utf8cursor(&u8c, um, UTF8_NFDICF,\n\t\t\t\tnfdicf_test_data[i].str) < 0)\n\t\t\tpr_err(\"can't create cursor\\n\");\n\n\t\twhile ((c = utf8byte(&u8c)) > 0) {\n\t\t\ttest_f((c == nfdicf_test_data[i].ncf[j]),\n\t\t\t       \"Unexpected byte 0x%x should be 0x%x\\n\",\n\t\t\t       c, nfdicf_test_data[i].ncf[j]);\n\t\t\tj++;\n\t\t}\n\n\t\ttest((j == nlen));\n\t}\n}\n\nstatic void check_utf8_comparisons(struct unicode_map *table)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfdi_test_data); i++) {\n\t\tconst struct qstr s1 = {.name = nfdi_test_data[i].str,\n\t\t\t\t\t.len = sizeof(nfdi_test_data[i].str)};\n\t\tconst struct qstr s2 = {.name = nfdi_test_data[i].dec,\n\t\t\t\t\t.len = sizeof(nfdi_test_data[i].dec)};\n\n\t\ttest_f(!utf8_strncmp(table, &s1, &s2),\n\t\t       \"%s %s comparison mismatch\\n\", s1.name, s2.name);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(nfdicf_test_data); i++) {\n\t\tconst struct qstr s1 = {.name = nfdicf_test_data[i].str,\n\t\t\t\t\t.len = sizeof(nfdicf_test_data[i].str)};\n\t\tconst struct qstr s2 = {.name = nfdicf_test_data[i].ncf,\n\t\t\t\t\t.len = sizeof(nfdicf_test_data[i].ncf)};\n\n\t\ttest_f(!utf8_strncasecmp(table, &s1, &s2),\n\t\t       \"%s %s comparison mismatch\\n\", s1.name, s2.name);\n\t}\n}\n\nstatic void check_supported_versions(struct unicode_map *um)\n{\n\t \n\ttest(utf8version_is_supported(um, UNICODE_AGE(7, 0, 0)));\n\n\t \n\ttest(utf8version_is_supported(um, UNICODE_AGE(9, 0, 0)));\n\n\t \n\ttest(utf8version_is_supported(um, UTF8_LATEST));\n\n\t \n\ttest(!utf8version_is_supported(um, UNICODE_AGE(13, 0, 0)));\n\ttest(!utf8version_is_supported(um, UNICODE_AGE(0, 0, 0)));\n\ttest(!utf8version_is_supported(um, UNICODE_AGE(-1, -1, -1)));\n}\n\nstatic int __init init_test_ucd(void)\n{\n\tstruct unicode_map *um;\n\n\tfailed_tests = 0;\n\ttotal_tests = 0;\n\n\tum = utf8_load(UTF8_LATEST);\n\tif (IS_ERR(um)) {\n\t\tpr_err(\"%s: Unable to load utf8 table.\\n\", __func__);\n\t\treturn PTR_ERR(um);\n\t}\n\n\tcheck_supported_versions(um);\n\tcheck_utf8_nfdi(um);\n\tcheck_utf8_nfdicf(um);\n\tcheck_utf8_comparisons(um);\n\n\tif (!failed_tests)\n\t\tpr_info(\"All %u tests passed\\n\", total_tests);\n\telse\n\t\tpr_err(\"%u out of %u tests failed\\n\", failed_tests,\n\t\t       total_tests);\n\tutf8_unload(um);\n\treturn 0;\n}\n\nstatic void __exit exit_test_ucd(void)\n{\n}\n\nmodule_init(init_test_ucd);\nmodule_exit(exit_test_ucd);\n\nMODULE_AUTHOR(\"Gabriel Krisman Bertazi <krisman@collabora.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}