{
  "module_name": "utf8-norm.c",
  "hash_id": "f88332ca9403d640eca86f4a38c8c9aa60bda9bea064e774244d049c66edd2ea",
  "original_prompt": "Ingested from linux-6.6.14/fs/unicode/utf8-norm.c",
  "human_readable_source": "\n \n\n#include \"utf8n.h\"\n\nint utf8version_is_supported(const struct unicode_map *um, unsigned int version)\n{\n\tint i = um->tables->utf8agetab_size - 1;\n\n\twhile (i >= 0 && um->tables->utf8agetab[i] != 0) {\n\t\tif (version == um->tables->utf8agetab[i])\n\t\t\treturn 1;\n\t\ti--;\n\t}\n\treturn 0;\n}\n\n \n\n \nstatic inline int utf8clen(const char *s)\n{\n\tunsigned char c = *s;\n\n\treturn 1 + (c >= 0xC0) + (c >= 0xE0) + (c >= 0xF0);\n}\n\n \nstatic unsigned int\nutf8decode3(const char *str)\n{\n\tunsigned int\t\tuc;\n\n\tuc = *str++ & 0x0F;\n\tuc <<= 6;\n\tuc |= *str++ & 0x3F;\n\tuc <<= 6;\n\tuc |= *str++ & 0x3F;\n\n\treturn uc;\n}\n\n \nstatic int\nutf8encode3(char *str, unsigned int val)\n{\n\tstr[2] = (val & 0x3F) | 0x80;\n\tval >>= 6;\n\tstr[1] = (val & 0x3F) | 0x80;\n\tval >>= 6;\n\tstr[0] = val | 0xE0;\n\n\treturn 3;\n}\n\n \ntypedef const unsigned char utf8trie_t;\n#define BITNUM\t\t0x07\n#define NEXTBYTE\t0x08\n#define OFFLEN\t\t0x30\n#define OFFLEN_SHIFT\t4\n#define RIGHTPATH\t0x40\n#define TRIENODE\t0x80\n#define RIGHTNODE\t0x40\n#define LEFTNODE\t0x80\n\n \ntypedef const unsigned char utf8leaf_t;\n\n#define LEAF_GEN(LEAF)\t((LEAF)[0])\n#define LEAF_CCC(LEAF)\t((LEAF)[1])\n#define LEAF_STR(LEAF)\t((const char *)((LEAF) + 2))\n\n#define MINCCC\t\t(0)\n#define MAXCCC\t\t(254)\n#define STOPPER\t\t(0)\n#define\tDECOMPOSE\t(255)\n\n \n#define HANGUL\t\t((char)(255))\n \n#define UTF8HANGULLEAF\t(12)\n\n \n\n \n#define SB\t(0xAC00)\n#define LB\t(0x1100)\n#define VB\t(0x1161)\n#define TB\t(0x11A7)\n#define LC\t(19)\n#define VC\t(21)\n#define TC\t(28)\n#define NC\t(VC * TC)\n#define SC\t(LC * NC)\n\n \nstatic utf8leaf_t *\nutf8hangul(const char *str, unsigned char *hangul)\n{\n\tunsigned int\tsi;\n\tunsigned int\tli;\n\tunsigned int\tvi;\n\tunsigned int\tti;\n\tunsigned char\t*h;\n\n\t \n\tsi = utf8decode3(str) - SB;\n\tli = si / NC;\n\tvi = (si % NC) / TC;\n\tti = si % TC;\n\n\t \n\th = hangul;\n\tLEAF_GEN(h) = 2;\n\tLEAF_CCC(h) = DECOMPOSE;\n\th += 2;\n\n\t \n\th += utf8encode3((char *)h, li + LB);\n\n\t \n\th += utf8encode3((char *)h, vi + VB);\n\n\t \n\tif (ti)\n\t\th += utf8encode3((char *)h, ti + TB);\n\n\t \n\th[0] = '\\0';\n\n\treturn hangul;\n}\n\n \nstatic utf8leaf_t *utf8nlookup(const struct unicode_map *um,\n\t\tenum utf8_normalization n, unsigned char *hangul, const char *s,\n\t\tsize_t len)\n{\n\tutf8trie_t\t*trie = um->tables->utf8data + um->ntab[n]->offset;\n\tint\t\tofflen;\n\tint\t\toffset;\n\tint\t\tmask;\n\tint\t\tnode;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\tnode = 1;\n\twhile (node) {\n\t\tofflen = (*trie & OFFLEN) >> OFFLEN_SHIFT;\n\t\tif (*trie & NEXTBYTE) {\n\t\t\tif (--len == 0)\n\t\t\t\treturn NULL;\n\t\t\ts++;\n\t\t}\n\t\tmask = 1 << (*trie & BITNUM);\n\t\tif (*s & mask) {\n\t\t\t \n\t\t\tif (offlen) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & RIGHTNODE);\n\t\t\t\toffset = trie[offlen];\n\t\t\t\twhile (--offlen) {\n\t\t\t\t\toffset <<= 8;\n\t\t\t\t\toffset |= trie[offlen];\n\t\t\t\t}\n\t\t\t\ttrie += offset;\n\t\t\t} else if (*trie & RIGHTPATH) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & TRIENODE);\n\t\t\t\ttrie++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (offlen) {\n\t\t\t\t \n\t\t\t\tnode = (*trie & LEFTNODE);\n\t\t\t\ttrie += offlen + 1;\n\t\t\t} else if (*trie & RIGHTPATH) {\n\t\t\t\t \n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnode = (*trie & TRIENODE);\n\t\t\t\ttrie++;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (LEAF_CCC(trie) == DECOMPOSE && LEAF_STR(trie)[0] == HANGUL)\n\t\ttrie = utf8hangul(s - 2, hangul);\n\treturn trie;\n}\n\n \nstatic utf8leaf_t *utf8lookup(const struct unicode_map *um,\n\t\tenum utf8_normalization n, unsigned char *hangul, const char *s)\n{\n\treturn utf8nlookup(um, n, hangul, s, (size_t)-1);\n}\n\n \nssize_t utf8nlen(const struct unicode_map *um, enum utf8_normalization n,\n\t\tconst char *s, size_t len)\n{\n\tutf8leaf_t\t*leaf;\n\tsize_t\t\tret = 0;\n\tunsigned char\thangul[UTF8HANGULLEAF];\n\n\twhile (len && *s) {\n\t\tleaf = utf8nlookup(um, n, hangul, s, len);\n\t\tif (!leaf)\n\t\t\treturn -1;\n\t\tif (um->tables->utf8agetab[LEAF_GEN(leaf)] >\n\t\t    um->ntab[n]->maxage)\n\t\t\tret += utf8clen(s);\n\t\telse if (LEAF_CCC(leaf) == DECOMPOSE)\n\t\t\tret += strlen(LEAF_STR(leaf));\n\t\telse\n\t\t\tret += utf8clen(s);\n\t\tlen -= utf8clen(s);\n\t\ts += utf8clen(s);\n\t}\n\treturn ret;\n}\n\n \nint utf8ncursor(struct utf8cursor *u8c, const struct unicode_map *um,\n\t\tenum utf8_normalization n, const char *s, size_t len)\n{\n\tif (!s)\n\t\treturn -1;\n\tu8c->um = um;\n\tu8c->n = n;\n\tu8c->s = s;\n\tu8c->p = NULL;\n\tu8c->ss = NULL;\n\tu8c->sp = NULL;\n\tu8c->len = len;\n\tu8c->slen = 0;\n\tu8c->ccc = STOPPER;\n\tu8c->nccc = STOPPER;\n\t \n\tif (u8c->len != len)\n\t\treturn -1;\n\t \n\tif (len > 0 && (*s & 0xC0) == 0x80)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nint utf8byte(struct utf8cursor *u8c)\n{\n\tutf8leaf_t *leaf;\n\tint ccc;\n\n\tfor (;;) {\n\t\t \n\t\tif (u8c->p && *u8c->s == '\\0') {\n\t\t\tu8c->s = u8c->p;\n\t\t\tu8c->p = NULL;\n\t\t}\n\n\t\t \n\t\tif (!u8c->p && (u8c->len == 0 || *u8c->s == '\\0')) {\n\t\t\t \n\t\t\tif (u8c->ccc == STOPPER)\n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tccc = STOPPER;\n\t\t\tgoto ccc_mismatch;\n\t\t} else if ((*u8c->s & 0xC0) == 0x80) {\n\t\t\t \n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len--;\n\t\t\treturn (unsigned char)*u8c->s++;\n\t\t}\n\n\t\t \n\t\tif (u8c->p) {\n\t\t\tleaf = utf8lookup(u8c->um, u8c->n, u8c->hangul, u8c->s);\n\t\t} else {\n\t\t\tleaf = utf8nlookup(u8c->um, u8c->n, u8c->hangul,\n\t\t\t\t\t   u8c->s, u8c->len);\n\t\t}\n\n\t\t \n\t\tif (!leaf)\n\t\t\treturn -1;\n\n\t\tccc = LEAF_CCC(leaf);\n\t\t \n\t\tif (u8c->um->tables->utf8agetab[LEAF_GEN(leaf)] >\n\t\t    u8c->um->ntab[u8c->n]->maxage) {\n\t\t\tccc = STOPPER;\n\t\t} else if (ccc == DECOMPOSE) {\n\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->p = u8c->s + utf8clen(u8c->s);\n\t\t\tu8c->s = LEAF_STR(leaf);\n\t\t\t \n\t\t\tif (*u8c->s == '\\0') {\n\t\t\t\tif (u8c->ccc == STOPPER)\n\t\t\t\t\tcontinue;\n\t\t\t\tccc = STOPPER;\n\t\t\t\tgoto ccc_mismatch;\n\t\t\t}\n\n\t\t\tleaf = utf8lookup(u8c->um, u8c->n, u8c->hangul, u8c->s);\n\t\t\tif (!leaf)\n\t\t\t\treturn -1;\n\t\t\tccc = LEAF_CCC(leaf);\n\t\t}\n\n\t\t \n\t\tif (ccc != STOPPER && u8c->ccc < ccc && ccc < u8c->nccc)\n\t\t\tu8c->nccc = ccc;\n\n\t\t \n\t\tif (ccc == u8c->ccc) {\n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len--;\n\t\t\treturn (unsigned char)*u8c->s++;\n\t\t}\n\n\t\t \nccc_mismatch:\n\t\tif (u8c->nccc == STOPPER) {\n\t\t\t \n\t\t\tu8c->ccc = MINCCC - 1;\n\t\t\tu8c->nccc = ccc;\n\t\t\tu8c->sp = u8c->p;\n\t\t\tu8c->ss = u8c->s;\n\t\t\tu8c->slen = u8c->len;\n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->s += utf8clen(u8c->s);\n\t\t} else if (ccc != STOPPER) {\n\t\t\t \n\t\t\tif (!u8c->p)\n\t\t\t\tu8c->len -= utf8clen(u8c->s);\n\t\t\tu8c->s += utf8clen(u8c->s);\n\t\t} else if (u8c->nccc != MAXCCC + 1) {\n\t\t\t \n\t\t\tu8c->ccc = u8c->nccc;\n\t\t\tu8c->nccc = MAXCCC + 1;\n\t\t\tu8c->s = u8c->ss;\n\t\t\tu8c->p = u8c->sp;\n\t\t\tu8c->len = u8c->slen;\n\t\t} else {\n\t\t\t \n\t\t\tu8c->ccc = STOPPER;\n\t\t\tu8c->nccc = STOPPER;\n\t\t\tu8c->sp = NULL;\n\t\t\tu8c->ss = NULL;\n\t\t\tu8c->slen = 0;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_UNICODE_NORMALIZATION_SELFTEST_MODULE\nEXPORT_SYMBOL_GPL(utf8version_is_supported);\nEXPORT_SYMBOL_GPL(utf8nlen);\nEXPORT_SYMBOL_GPL(utf8ncursor);\nEXPORT_SYMBOL_GPL(utf8byte);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}