{
  "module_name": "file.c",
  "hash_id": "5669090e743a76c2914b3172eac7c85214038d5bbfc4be19441a060a0c4c58e8",
  "original_prompt": "Ingested from linux-6.6.14/fs/debugfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/poll.h>\n#include <linux/security.h>\n\n#include \"internal.h\"\n\nstruct poll_table_struct;\n\nstatic ssize_t default_read_file(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\nstatic ssize_t default_write_file(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nconst struct file_operations debugfs_noop_file_operations = {\n\t.read =\t\tdefault_read_file,\n\t.write =\tdefault_write_file,\n\t.open =\t\tsimple_open,\n\t.llseek =\tnoop_llseek,\n};\n\n#define F_DENTRY(filp) ((filp)->f_path.dentry)\n\nconst struct file_operations *debugfs_real_fops(const struct file *filp)\n{\n\tstruct debugfs_fsdata *fsd = F_DENTRY(filp)->d_fsdata;\n\n\tif ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT) {\n\t\t \n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn fsd->real_fops;\n}\nEXPORT_SYMBOL_GPL(debugfs_real_fops);\n\n \nint debugfs_file_get(struct dentry *dentry)\n{\n\tstruct debugfs_fsdata *fsd;\n\tvoid *d_fsd;\n\n\t \n\tif (WARN_ON(!d_is_reg(dentry)))\n\t\treturn -EINVAL;\n\n\td_fsd = READ_ONCE(dentry->d_fsdata);\n\tif (!((unsigned long)d_fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)) {\n\t\tfsd = d_fsd;\n\t} else {\n\t\tfsd = kmalloc(sizeof(*fsd), GFP_KERNEL);\n\t\tif (!fsd)\n\t\t\treturn -ENOMEM;\n\n\t\tfsd->real_fops = (void *)((unsigned long)d_fsd &\n\t\t\t\t\t~DEBUGFS_FSDATA_IS_REAL_FOPS_BIT);\n\t\trefcount_set(&fsd->active_users, 1);\n\t\tinit_completion(&fsd->active_users_drained);\n\t\tif (cmpxchg(&dentry->d_fsdata, d_fsd, fsd) != d_fsd) {\n\t\t\tkfree(fsd);\n\t\t\tfsd = READ_ONCE(dentry->d_fsdata);\n\t\t}\n\t}\n\n\t \n\tif (d_unlinked(dentry))\n\t\treturn -EIO;\n\n\tif (!refcount_inc_not_zero(&fsd->active_users))\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(debugfs_file_get);\n\n \nvoid debugfs_file_put(struct dentry *dentry)\n{\n\tstruct debugfs_fsdata *fsd = READ_ONCE(dentry->d_fsdata);\n\n\tif (refcount_dec_and_test(&fsd->active_users))\n\t\tcomplete(&fsd->active_users_drained);\n}\nEXPORT_SYMBOL_GPL(debugfs_file_put);\n\n \nstatic int debugfs_locked_down(struct inode *inode,\n\t\t\t       struct file *filp,\n\t\t\t       const struct file_operations *real_fops)\n{\n\tif ((inode->i_mode & 07777 & ~0444) == 0 &&\n\t    !(filp->f_mode & FMODE_WRITE) &&\n\t    !real_fops->unlocked_ioctl &&\n\t    !real_fops->compat_ioctl &&\n\t    !real_fops->mmap)\n\t\treturn 0;\n\n\tif (security_locked_down(LOCKDOWN_DEBUGFS))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int open_proxy_open(struct inode *inode, struct file *filp)\n{\n\tstruct dentry *dentry = F_DENTRY(filp);\n\tconst struct file_operations *real_fops = NULL;\n\tint r;\n\n\tr = debugfs_file_get(dentry);\n\tif (r)\n\t\treturn r == -EIO ? -ENOENT : r;\n\n\treal_fops = debugfs_real_fops(filp);\n\n\tr = debugfs_locked_down(inode, filp, real_fops);\n\tif (r)\n\t\tgoto out;\n\n\tif (!fops_get(real_fops)) {\n#ifdef CONFIG_MODULES\n\t\tif (real_fops->owner &&\n\t\t    real_fops->owner->state == MODULE_STATE_GOING) {\n\t\t\tr = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n#endif\n\n\t\t \n\t\tWARN(1, \"debugfs file owner did not clean up at exit: %pd\",\n\t\t\tdentry);\n\t\tr = -ENXIO;\n\t\tgoto out;\n\t}\n\treplace_fops(filp, real_fops);\n\n\tif (real_fops->open)\n\t\tr = real_fops->open(inode, filp);\n\nout:\n\tdebugfs_file_put(dentry);\n\treturn r;\n}\n\nconst struct file_operations debugfs_open_proxy_file_operations = {\n\t.open = open_proxy_open,\n};\n\n#define PROTO(args...) args\n#define ARGS(args...) args\n\n#define FULL_PROXY_FUNC(name, ret_type, filp, proto, args)\t\t\\\nstatic ret_type full_proxy_ ## name(proto)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct dentry *dentry = F_DENTRY(filp);\t\t\t\\\n\tconst struct file_operations *real_fops;\t\t\t\\\n\tret_type r;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tr = debugfs_file_get(dentry);\t\t\t\t\t\\\n\tif (unlikely(r))\t\t\t\t\t\t\\\n\t\treturn r;\t\t\t\t\t\t\\\n\treal_fops = debugfs_real_fops(filp);\t\t\t\t\\\n\tr = real_fops->name(args);\t\t\t\t\t\\\n\tdebugfs_file_put(dentry);\t\t\t\t\t\\\n\treturn r;\t\t\t\t\t\t\t\\\n}\n\nFULL_PROXY_FUNC(llseek, loff_t, filp,\n\t\tPROTO(struct file *filp, loff_t offset, int whence),\n\t\tARGS(filp, offset, whence));\n\nFULL_PROXY_FUNC(read, ssize_t, filp,\n\t\tPROTO(struct file *filp, char __user *buf, size_t size,\n\t\t\tloff_t *ppos),\n\t\tARGS(filp, buf, size, ppos));\n\nFULL_PROXY_FUNC(write, ssize_t, filp,\n\t\tPROTO(struct file *filp, const char __user *buf, size_t size,\n\t\t\tloff_t *ppos),\n\t\tARGS(filp, buf, size, ppos));\n\nFULL_PROXY_FUNC(unlocked_ioctl, long, filp,\n\t\tPROTO(struct file *filp, unsigned int cmd, unsigned long arg),\n\t\tARGS(filp, cmd, arg));\n\nstatic __poll_t full_proxy_poll(struct file *filp,\n\t\t\t\tstruct poll_table_struct *wait)\n{\n\tstruct dentry *dentry = F_DENTRY(filp);\n\t__poll_t r = 0;\n\tconst struct file_operations *real_fops;\n\n\tif (debugfs_file_get(dentry))\n\t\treturn EPOLLHUP;\n\n\treal_fops = debugfs_real_fops(filp);\n\tr = real_fops->poll(filp, wait);\n\tdebugfs_file_put(dentry);\n\treturn r;\n}\n\nstatic int full_proxy_release(struct inode *inode, struct file *filp)\n{\n\tconst struct dentry *dentry = F_DENTRY(filp);\n\tconst struct file_operations *real_fops = debugfs_real_fops(filp);\n\tconst struct file_operations *proxy_fops = filp->f_op;\n\tint r = 0;\n\n\t \n\tif (real_fops->release)\n\t\tr = real_fops->release(inode, filp);\n\n\treplace_fops(filp, d_inode(dentry)->i_fop);\n\tkfree(proxy_fops);\n\tfops_put(real_fops);\n\treturn r;\n}\n\nstatic void __full_proxy_fops_init(struct file_operations *proxy_fops,\n\t\t\t\tconst struct file_operations *real_fops)\n{\n\tproxy_fops->release = full_proxy_release;\n\tif (real_fops->llseek)\n\t\tproxy_fops->llseek = full_proxy_llseek;\n\tif (real_fops->read)\n\t\tproxy_fops->read = full_proxy_read;\n\tif (real_fops->write)\n\t\tproxy_fops->write = full_proxy_write;\n\tif (real_fops->poll)\n\t\tproxy_fops->poll = full_proxy_poll;\n\tif (real_fops->unlocked_ioctl)\n\t\tproxy_fops->unlocked_ioctl = full_proxy_unlocked_ioctl;\n}\n\nstatic int full_proxy_open(struct inode *inode, struct file *filp)\n{\n\tstruct dentry *dentry = F_DENTRY(filp);\n\tconst struct file_operations *real_fops = NULL;\n\tstruct file_operations *proxy_fops = NULL;\n\tint r;\n\n\tr = debugfs_file_get(dentry);\n\tif (r)\n\t\treturn r == -EIO ? -ENOENT : r;\n\n\treal_fops = debugfs_real_fops(filp);\n\n\tr = debugfs_locked_down(inode, filp, real_fops);\n\tif (r)\n\t\tgoto out;\n\n\tif (!fops_get(real_fops)) {\n#ifdef CONFIG_MODULES\n\t\tif (real_fops->owner &&\n\t\t    real_fops->owner->state == MODULE_STATE_GOING) {\n\t\t\tr = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n#endif\n\n\t\t \n\t\tWARN(1, \"debugfs file owner did not clean up at exit: %pd\",\n\t\t\tdentry);\n\t\tr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tproxy_fops = kzalloc(sizeof(*proxy_fops), GFP_KERNEL);\n\tif (!proxy_fops) {\n\t\tr = -ENOMEM;\n\t\tgoto free_proxy;\n\t}\n\t__full_proxy_fops_init(proxy_fops, real_fops);\n\treplace_fops(filp, proxy_fops);\n\n\tif (real_fops->open) {\n\t\tr = real_fops->open(inode, filp);\n\t\tif (r) {\n\t\t\treplace_fops(filp, d_inode(dentry)->i_fop);\n\t\t\tgoto free_proxy;\n\t\t} else if (filp->f_op != proxy_fops) {\n\t\t\t \n\t\t\tWARN(1, \"debugfs file owner replaced proxy fops: %pd\",\n\t\t\t\tdentry);\n\t\t\tgoto free_proxy;\n\t\t}\n\t}\n\n\tgoto out;\nfree_proxy:\n\tkfree(proxy_fops);\n\tfops_put(real_fops);\nout:\n\tdebugfs_file_put(dentry);\n\treturn r;\n}\n\nconst struct file_operations debugfs_full_proxy_file_operations = {\n\t.open = full_proxy_open,\n};\n\nssize_t debugfs_attr_read(struct file *file, char __user *buf,\n\t\t\tsize_t len, loff_t *ppos)\n{\n\tstruct dentry *dentry = F_DENTRY(file);\n\tssize_t ret;\n\n\tret = debugfs_file_get(dentry);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = simple_attr_read(file, buf, len, ppos);\n\tdebugfs_file_put(dentry);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(debugfs_attr_read);\n\nstatic ssize_t debugfs_attr_write_xsigned(struct file *file, const char __user *buf,\n\t\t\t size_t len, loff_t *ppos, bool is_signed)\n{\n\tstruct dentry *dentry = F_DENTRY(file);\n\tssize_t ret;\n\n\tret = debugfs_file_get(dentry);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif (is_signed)\n\t\tret = simple_attr_write_signed(file, buf, len, ppos);\n\telse\n\t\tret = simple_attr_write(file, buf, len, ppos);\n\tdebugfs_file_put(dentry);\n\treturn ret;\n}\n\nssize_t debugfs_attr_write(struct file *file, const char __user *buf,\n\t\t\t size_t len, loff_t *ppos)\n{\n\treturn debugfs_attr_write_xsigned(file, buf, len, ppos, false);\n}\nEXPORT_SYMBOL_GPL(debugfs_attr_write);\n\nssize_t debugfs_attr_write_signed(struct file *file, const char __user *buf,\n\t\t\t size_t len, loff_t *ppos)\n{\n\treturn debugfs_attr_write_xsigned(file, buf, len, ppos, true);\n}\nEXPORT_SYMBOL_GPL(debugfs_attr_write_signed);\n\nstatic struct dentry *debugfs_create_mode_unsafe(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *value,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct file_operations *fops_ro,\n\t\t\t\t\tconst struct file_operations *fops_wo)\n{\n\t \n\tif (!(mode & S_IWUGO))\n\t\treturn debugfs_create_file_unsafe(name, mode, parent, value,\n\t\t\t\t\t\tfops_ro);\n\t \n\tif (!(mode & S_IRUGO))\n\t\treturn debugfs_create_file_unsafe(name, mode, parent, value,\n\t\t\t\t\t\tfops_wo);\n\n\treturn debugfs_create_file_unsafe(name, mode, parent, value, fops);\n}\n\nstatic int debugfs_u8_set(void *data, u64 val)\n{\n\t*(u8 *)data = val;\n\treturn 0;\n}\nstatic int debugfs_u8_get(void *data, u64 *val)\n{\n\t*val = *(u8 *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u8, debugfs_u8_get, debugfs_u8_set, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u8_ro, debugfs_u8_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u8_wo, NULL, debugfs_u8_set, \"%llu\\n\");\n\n \nvoid debugfs_create_u8(const char *name, umode_t mode, struct dentry *parent,\n\t\t       u8 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_u8,\n\t\t\t\t   &fops_u8_ro, &fops_u8_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_u8);\n\nstatic int debugfs_u16_set(void *data, u64 val)\n{\n\t*(u16 *)data = val;\n\treturn 0;\n}\nstatic int debugfs_u16_get(void *data, u64 *val)\n{\n\t*val = *(u16 *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u16, debugfs_u16_get, debugfs_u16_set, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u16_ro, debugfs_u16_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u16_wo, NULL, debugfs_u16_set, \"%llu\\n\");\n\n \nvoid debugfs_create_u16(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu16 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_u16,\n\t\t\t\t   &fops_u16_ro, &fops_u16_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_u16);\n\nstatic int debugfs_u32_set(void *data, u64 val)\n{\n\t*(u32 *)data = val;\n\treturn 0;\n}\nstatic int debugfs_u32_get(void *data, u64 *val)\n{\n\t*val = *(u32 *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u32, debugfs_u32_get, debugfs_u32_set, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u32_ro, debugfs_u32_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u32_wo, NULL, debugfs_u32_set, \"%llu\\n\");\n\n \nvoid debugfs_create_u32(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu32 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_u32,\n\t\t\t\t   &fops_u32_ro, &fops_u32_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_u32);\n\nstatic int debugfs_u64_set(void *data, u64 val)\n{\n\t*(u64 *)data = val;\n\treturn 0;\n}\n\nstatic int debugfs_u64_get(void *data, u64 *val)\n{\n\t*val = *(u64 *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u64, debugfs_u64_get, debugfs_u64_set, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u64_ro, debugfs_u64_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, \"%llu\\n\");\n\n \nvoid debugfs_create_u64(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu64 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_u64,\n\t\t\t\t   &fops_u64_ro, &fops_u64_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_u64);\n\nstatic int debugfs_ulong_set(void *data, u64 val)\n{\n\t*(unsigned long *)data = val;\n\treturn 0;\n}\n\nstatic int debugfs_ulong_get(void *data, u64 *val)\n{\n\t*val = *(unsigned long *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_ulong, debugfs_ulong_get, debugfs_ulong_set,\n\t\t\t\"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_ulong_ro, debugfs_ulong_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_ulong_wo, NULL, debugfs_ulong_set, \"%llu\\n\");\n\n \nvoid debugfs_create_ulong(const char *name, umode_t mode, struct dentry *parent,\n\t\t\t  unsigned long *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_ulong,\n\t\t\t\t   &fops_ulong_ro, &fops_ulong_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_ulong);\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x8, debugfs_u8_get, debugfs_u8_set, \"0x%02llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x8_ro, debugfs_u8_get, NULL, \"0x%02llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x8_wo, NULL, debugfs_u8_set, \"0x%02llx\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x16, debugfs_u16_get, debugfs_u16_set,\n\t\t\t\"0x%04llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x16_ro, debugfs_u16_get, NULL, \"0x%04llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x16_wo, NULL, debugfs_u16_set, \"0x%04llx\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32, debugfs_u32_get, debugfs_u32_set,\n\t\t\t\"0x%08llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32_ro, debugfs_u32_get, NULL, \"0x%08llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x32_wo, NULL, debugfs_u32_set, \"0x%08llx\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x64, debugfs_u64_get, debugfs_u64_set,\n\t\t\t\"0x%016llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x64_ro, debugfs_u64_get, NULL, \"0x%016llx\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_x64_wo, NULL, debugfs_u64_set, \"0x%016llx\\n\");\n\n \n\n \nvoid debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent,\n\t\t       u8 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_x8,\n\t\t\t\t   &fops_x8_ro, &fops_x8_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_x8);\n\n \nvoid debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu16 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_x16,\n\t\t\t\t   &fops_x16_ro, &fops_x16_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_x16);\n\n \nvoid debugfs_create_x32(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu32 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_x32,\n\t\t\t\t   &fops_x32_ro, &fops_x32_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_x32);\n\n \nvoid debugfs_create_x64(const char *name, umode_t mode, struct dentry *parent,\n\t\t\tu64 *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_x64,\n\t\t\t\t   &fops_x64_ro, &fops_x64_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_x64);\n\n\nstatic int debugfs_size_t_set(void *data, u64 val)\n{\n\t*(size_t *)data = val;\n\treturn 0;\n}\nstatic int debugfs_size_t_get(void *data, u64 *val)\n{\n\t*val = *(size_t *)data;\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_size_t, debugfs_size_t_get, debugfs_size_t_set,\n\t\t\t\"%llu\\n\");  \nDEFINE_DEBUGFS_ATTRIBUTE(fops_size_t_ro, debugfs_size_t_get, NULL, \"%llu\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE(fops_size_t_wo, NULL, debugfs_size_t_set, \"%llu\\n\");\n\n \nvoid debugfs_create_size_t(const char *name, umode_t mode,\n\t\t\t   struct dentry *parent, size_t *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_size_t,\n\t\t\t\t   &fops_size_t_ro, &fops_size_t_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_size_t);\n\nstatic int debugfs_atomic_t_set(void *data, u64 val)\n{\n\tatomic_set((atomic_t *)data, val);\n\treturn 0;\n}\nstatic int debugfs_atomic_t_get(void *data, u64 *val)\n{\n\t*val = atomic_read((atomic_t *)data);\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE_SIGNED(fops_atomic_t, debugfs_atomic_t_get,\n\t\t\tdebugfs_atomic_t_set, \"%lld\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE_SIGNED(fops_atomic_t_ro, debugfs_atomic_t_get, NULL,\n\t\t\t\"%lld\\n\");\nDEFINE_DEBUGFS_ATTRIBUTE_SIGNED(fops_atomic_t_wo, NULL, debugfs_atomic_t_set,\n\t\t\t\"%lld\\n\");\n\n \nvoid debugfs_create_atomic_t(const char *name, umode_t mode,\n\t\t\t     struct dentry *parent, atomic_t *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_atomic_t,\n\t\t\t\t   &fops_atomic_t_ro, &fops_atomic_t_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_atomic_t);\n\nssize_t debugfs_read_file_bool(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar buf[2];\n\tbool val;\n\tint r;\n\tstruct dentry *dentry = F_DENTRY(file);\n\n\tr = debugfs_file_get(dentry);\n\tif (unlikely(r))\n\t\treturn r;\n\tval = *(bool *)file->private_data;\n\tdebugfs_file_put(dentry);\n\n\tif (val)\n\t\tbuf[0] = 'Y';\n\telse\n\t\tbuf[0] = 'N';\n\tbuf[1] = '\\n';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\nEXPORT_SYMBOL_GPL(debugfs_read_file_bool);\n\nssize_t debugfs_write_file_bool(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tbool bv;\n\tint r;\n\tbool *val = file->private_data;\n\tstruct dentry *dentry = F_DENTRY(file);\n\n\tr = kstrtobool_from_user(user_buf, count, &bv);\n\tif (!r) {\n\t\tr = debugfs_file_get(dentry);\n\t\tif (unlikely(r))\n\t\t\treturn r;\n\t\t*val = bv;\n\t\tdebugfs_file_put(dentry);\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(debugfs_write_file_bool);\n\nstatic const struct file_operations fops_bool = {\n\t.read =\t\tdebugfs_read_file_bool,\n\t.write =\tdebugfs_write_file_bool,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic const struct file_operations fops_bool_ro = {\n\t.read =\t\tdebugfs_read_file_bool,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic const struct file_operations fops_bool_wo = {\n\t.write =\tdebugfs_write_file_bool,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\n \nvoid debugfs_create_bool(const char *name, umode_t mode, struct dentry *parent,\n\t\t\t bool *value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_bool,\n\t\t\t\t   &fops_bool_ro, &fops_bool_wo);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_bool);\n\nssize_t debugfs_read_file_str(struct file *file, char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct dentry *dentry = F_DENTRY(file);\n\tchar *str, *copy = NULL;\n\tint copy_len, len;\n\tssize_t ret;\n\n\tret = debugfs_file_get(dentry);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tstr = *(char **)file->private_data;\n\tlen = strlen(str) + 1;\n\tcopy = kmalloc(len, GFP_KERNEL);\n\tif (!copy) {\n\t\tdebugfs_file_put(dentry);\n\t\treturn -ENOMEM;\n\t}\n\n\tcopy_len = strscpy(copy, str, len);\n\tdebugfs_file_put(dentry);\n\tif (copy_len < 0) {\n\t\tkfree(copy);\n\t\treturn copy_len;\n\t}\n\n\tcopy[copy_len] = '\\n';\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, copy, len);\n\tkfree(copy);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(debugfs_create_str);\n\nstatic ssize_t debugfs_write_file_str(struct file *file, const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct dentry *dentry = F_DENTRY(file);\n\tchar *old, *new = NULL;\n\tint pos = *ppos;\n\tint r;\n\n\tr = debugfs_file_get(dentry);\n\tif (unlikely(r))\n\t\treturn r;\n\n\told = *(char **)file->private_data;\n\n\t \n\tr = -EINVAL;\n\tif (pos && pos != strlen(old))\n\t\tgoto error;\n\n\tr = -E2BIG;\n\tif (pos + count + 1 > PAGE_SIZE)\n\t\tgoto error;\n\n\tr = -ENOMEM;\n\tnew = kmalloc(pos + count + 1, GFP_KERNEL);\n\tif (!new)\n\t\tgoto error;\n\n\tif (pos)\n\t\tmemcpy(new, old, pos);\n\n\tr = -EFAULT;\n\tif (copy_from_user(new + pos, user_buf, count))\n\t\tgoto error;\n\n\tnew[pos + count] = '\\0';\n\tstrim(new);\n\n\trcu_assign_pointer(*(char __rcu **)file->private_data, new);\n\tsynchronize_rcu();\n\tkfree(old);\n\n\tdebugfs_file_put(dentry);\n\treturn count;\n\nerror:\n\tkfree(new);\n\tdebugfs_file_put(dentry);\n\treturn r;\n}\n\nstatic const struct file_operations fops_str = {\n\t.read =\t\tdebugfs_read_file_str,\n\t.write =\tdebugfs_write_file_str,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic const struct file_operations fops_str_ro = {\n\t.read =\t\tdebugfs_read_file_str,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic const struct file_operations fops_str_wo = {\n\t.write =\tdebugfs_write_file_str,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\n \nvoid debugfs_create_str(const char *name, umode_t mode,\n\t\t\tstruct dentry *parent, char **value)\n{\n\tdebugfs_create_mode_unsafe(name, mode, parent, value, &fops_str,\n\t\t\t\t   &fops_str_ro, &fops_str_wo);\n}\n\nstatic ssize_t read_file_blob(struct file *file, char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct debugfs_blob_wrapper *blob = file->private_data;\n\tstruct dentry *dentry = F_DENTRY(file);\n\tssize_t r;\n\n\tr = debugfs_file_get(dentry);\n\tif (unlikely(r))\n\t\treturn r;\n\tr = simple_read_from_buffer(user_buf, count, ppos, blob->data,\n\t\t\t\tblob->size);\n\tdebugfs_file_put(dentry);\n\treturn r;\n}\n\nstatic const struct file_operations fops_blob = {\n\t.read =\t\tread_file_blob,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\n \nstruct dentry *debugfs_create_blob(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent,\n\t\t\t\t   struct debugfs_blob_wrapper *blob)\n{\n\treturn debugfs_create_file_unsafe(name, mode & 0444, parent, blob, &fops_blob);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_blob);\n\nstatic size_t u32_format_array(char *buf, size_t bufsize,\n\t\t\t       u32 *array, int array_size)\n{\n\tsize_t ret = 0;\n\n\twhile (--array_size >= 0) {\n\t\tsize_t len;\n\t\tchar term = array_size ? ' ' : '\\n';\n\n\t\tlen = snprintf(buf, bufsize, \"%u%c\", *array++, term);\n\t\tret += len;\n\n\t\tbuf += len;\n\t\tbufsize -= len;\n\t}\n\treturn ret;\n}\n\nstatic int u32_array_open(struct inode *inode, struct file *file)\n{\n\tstruct debugfs_u32_array *data = inode->i_private;\n\tint size, elements = data->n_elements;\n\tchar *buf;\n\n\t \n\tsize = elements*11;\n\tbuf = kmalloc(size+1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[size] = 0;\n\n\tfile->private_data = buf;\n\tu32_format_array(buf, size, data->array, data->n_elements);\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t u32_array_read(struct file *file, char __user *buf, size_t len,\n\t\t\t      loff_t *ppos)\n{\n\tsize_t size = strlen(file->private_data);\n\n\treturn simple_read_from_buffer(buf, len, ppos,\n\t\t\t\t\tfile->private_data, size);\n}\n\nstatic int u32_array_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic const struct file_operations u32_array_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = u32_array_open,\n\t.release = u32_array_release,\n\t.read\t = u32_array_read,\n\t.llseek  = no_llseek,\n};\n\n \nvoid debugfs_create_u32_array(const char *name, umode_t mode,\n\t\t\t      struct dentry *parent,\n\t\t\t      struct debugfs_u32_array *array)\n{\n\tdebugfs_create_file_unsafe(name, mode, parent, array, &u32_array_fops);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_u32_array);\n\n#ifdef CONFIG_HAS_IOMEM\n\n \n\n \nvoid debugfs_print_regs32(struct seq_file *s, const struct debugfs_reg32 *regs,\n\t\t\t  int nregs, void __iomem *base, char *prefix)\n{\n\tint i;\n\n\tfor (i = 0; i < nregs; i++, regs++) {\n\t\tif (prefix)\n\t\t\tseq_printf(s, \"%s\", prefix);\n\t\tseq_printf(s, \"%s = 0x%08x\\n\", regs->name,\n\t\t\t   readl(base + regs->offset));\n\t\tif (seq_has_overflowed(s))\n\t\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(debugfs_print_regs32);\n\nstatic int debugfs_regset32_show(struct seq_file *s, void *data)\n{\n\tstruct debugfs_regset32 *regset = s->private;\n\n\tif (regset->dev)\n\t\tpm_runtime_get_sync(regset->dev);\n\n\tdebugfs_print_regs32(s, regset->regs, regset->nregs, regset->base, \"\");\n\n\tif (regset->dev)\n\t\tpm_runtime_put(regset->dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(debugfs_regset32);\n\n \nvoid debugfs_create_regset32(const char *name, umode_t mode,\n\t\t\t     struct dentry *parent,\n\t\t\t     struct debugfs_regset32 *regset)\n{\n\tdebugfs_create_file(name, mode, parent, regset, &debugfs_regset32_fops);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_regset32);\n\n#endif  \n\nstruct debugfs_devm_entry {\n\tint (*read)(struct seq_file *seq, void *data);\n\tstruct device *dev;\n};\n\nstatic int debugfs_devm_entry_open(struct inode *inode, struct file *f)\n{\n\tstruct debugfs_devm_entry *entry = inode->i_private;\n\n\treturn single_open(f, entry->read, entry->dev);\n}\n\nstatic const struct file_operations debugfs_devm_entry_ops = {\n\t.owner = THIS_MODULE,\n\t.open = debugfs_devm_entry_open,\n\t.release = single_release,\n\t.read = seq_read,\n\t.llseek = seq_lseek\n};\n\n \nvoid debugfs_create_devm_seqfile(struct device *dev, const char *name,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t int (*read_fn)(struct seq_file *s, void *data))\n{\n\tstruct debugfs_devm_entry *entry;\n\n\tif (IS_ERR(parent))\n\t\treturn;\n\n\tentry = devm_kzalloc(dev, sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn;\n\n\tentry->read = read_fn;\n\tentry->dev = dev;\n\n\tdebugfs_create_file(name, S_IRUGO, parent, entry,\n\t\t\t    &debugfs_devm_entry_ops);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_devm_seqfile);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}