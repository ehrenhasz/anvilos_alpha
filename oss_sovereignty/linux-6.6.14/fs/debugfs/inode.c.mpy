{
  "module_name": "inode.c",
  "hash_id": "05d9153927808149ed55edb76299295c5d35e0bad785dc037f4f5b756b99a14f",
  "original_prompt": "Ingested from linux-6.6.14/fs/debugfs/inode.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"debugfs: \" fmt\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/kobject.h>\n#include <linux/namei.h>\n#include <linux/debugfs.h>\n#include <linux/fsnotify.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n\n#include \"internal.h\"\n\n#define DEBUGFS_DEFAULT_MODE\t0700\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic bool debugfs_registered;\nstatic unsigned int debugfs_allow __ro_after_init = DEFAULT_DEBUGFS_ALLOW_BITS;\n\n \nstatic int debugfs_setattr(struct mnt_idmap *idmap,\n\t\t\t   struct dentry *dentry, struct iattr *ia)\n{\n\tint ret;\n\n\tif (ia->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)) {\n\t\tret = security_locked_down(LOCKDOWN_DEBUGFS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn simple_setattr(&nop_mnt_idmap, dentry, ia);\n}\n\nstatic const struct inode_operations debugfs_file_inode_operations = {\n\t.setattr\t= debugfs_setattr,\n};\nstatic const struct inode_operations debugfs_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.setattr\t= debugfs_setattr,\n};\nstatic const struct inode_operations debugfs_symlink_inode_operations = {\n\t.get_link\t= simple_get_link,\n\t.setattr\t= debugfs_setattr,\n};\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\n\treturn inode;\n}\n\nstruct debugfs_mount_opts {\n\tkuid_t uid;\n\tkgid_t gid;\n\tumode_t mode;\n\t \n\tunsigned int opts;\n};\n\nenum {\n\tOpt_uid,\n\tOpt_gid,\n\tOpt_mode,\n\tOpt_err\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstruct debugfs_fs_info {\n\tstruct debugfs_mount_opts mount_opts;\n};\n\nstatic int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->opts = 0;\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t \n\t\t}\n\n\t\topts->opts |= BIT(token);\n\t}\n\n\treturn 0;\n}\n\nstatic void _debugfs_apply_options(struct super_block *sb, bool remount)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = d_inode(sb->s_root);\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\t \n\n\tif (!remount || opts->opts & BIT(Opt_mode)) {\n\t\tinode->i_mode &= ~S_IALLUGO;\n\t\tinode->i_mode |= opts->mode;\n\t}\n\n\tif (!remount || opts->opts & BIT(Opt_uid))\n\t\tinode->i_uid = opts->uid;\n\n\tif (!remount || opts->opts & BIT(Opt_gid))\n\t\tinode->i_gid = opts->gid;\n}\n\nstatic void debugfs_apply_options(struct super_block *sb)\n{\n\t_debugfs_apply_options(sb, false);\n}\n\nstatic void debugfs_apply_options_remount(struct super_block *sb)\n{\n\t_debugfs_apply_options(sb, true);\n}\n\nstatic int debugfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\tdebugfs_apply_options_remount(sb);\n\nfail:\n\treturn err;\n}\n\nstatic int debugfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct debugfs_fs_info *fsi = root->d_sb->s_fs_info;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tif (!uid_eq(opts->uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (!gid_eq(opts->gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tif (opts->mode != DEBUGFS_DEFAULT_MODE)\n\t\tseq_printf(m, \",mode=%o\", opts->mode);\n\n\treturn 0;\n}\n\nstatic void debugfs_free_inode(struct inode *inode)\n{\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tfree_inode_nonrcu(inode);\n}\n\nstatic const struct super_operations debugfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= debugfs_remount,\n\t.show_options\t= debugfs_show_options,\n\t.free_inode\t= debugfs_free_inode,\n};\n\nstatic void debugfs_release_dentry(struct dentry *dentry)\n{\n\tstruct debugfs_fsdata *fsd = dentry->d_fsdata;\n\n\tif ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)\n\t\treturn;\n\n\tkfree(fsd);\n}\n\nstatic struct vfsmount *debugfs_automount(struct path *path)\n{\n\tstruct debugfs_fsdata *fsd = path->dentry->d_fsdata;\n\n\treturn fsd->automount(path->dentry, d_inode(path->dentry)->i_private);\n}\n\nstatic const struct dentry_operations debugfs_dops = {\n\t.d_delete = always_delete_dentry,\n\t.d_release = debugfs_release_dentry,\n\t.d_automount = debugfs_automount,\n};\n\nstatic int debug_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic const struct tree_descr debug_files[] = {{\"\"}};\n\tstruct debugfs_fs_info *fsi;\n\tint err;\n\n\tfsi = kzalloc(sizeof(struct debugfs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\terr  =  simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);\n\tif (err)\n\t\tgoto fail;\n\n\tsb->s_op = &debugfs_super_operations;\n\tsb->s_d_op = &debugfs_dops;\n\n\tdebugfs_apply_options(sb);\n\n\treturn 0;\n\nfail:\n\tkfree(fsi);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}\n\nstatic struct dentry *debug_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_API))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn mount_single(fs_type, flags, data, debug_fill_super);\n}\n\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\nMODULE_ALIAS_FS(\"debugfs\");\n\n \nstruct dentry *debugfs_lookup(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\n\tif (!debugfs_initialized() || IS_ERR_OR_NULL(name) || IS_ERR(parent))\n\t\treturn NULL;\n\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tdentry = lookup_positive_unlocked(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\treturn dentry;\n}\nEXPORT_SYMBOL_GPL(debugfs_lookup);\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_API))\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (!debugfs_initialized())\n\t\treturn ERR_PTR(-ENOENT);\n\n\tpr_debug(\"creating file '%s'\\n\", name);\n\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error) {\n\t\tpr_err(\"Unable to pin filesystem for file '%s'\\n\", name);\n\t\treturn ERR_PTR(error);\n\t}\n\n\t \n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tinode_lock(d_inode(parent));\n\tif (unlikely(IS_DEADDIR(d_inode(parent))))\n\t\tdentry = ERR_PTR(-ENOENT);\n\telse\n\t\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && d_really_is_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tpr_err(\"Directory '%s' with parent '%s' already present!\\n\",\n\t\t\t       name, parent->d_name.name);\n\t\telse\n\t\t\tpr_err(\"File '%s' in directory '%s' already present!\\n\",\n\t\t\t       name, parent->d_name.name);\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(d_inode(parent));\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\t}\n\n\treturn dentry;\n}\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tinode_unlock(d_inode(dentry->d_parent));\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tinode_unlock(d_inode(dentry->d_parent));\n\treturn dentry;\n}\n\nstatic struct dentry *__debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\tconst struct file_operations *proxy_fops,\n\t\t\t\tconst struct file_operations *real_fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_API)) {\n\t\tfailed_creating(dentry);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tpr_err(\"out of free dentries, can not create file '%s'\\n\",\n\t\t       name);\n\t\treturn failed_creating(dentry);\n\t}\n\n\tinode->i_mode = mode;\n\tinode->i_private = data;\n\n\tinode->i_op = &debugfs_file_inode_operations;\n\tinode->i_fop = proxy_fops;\n\tdentry->d_fsdata = (void *)((unsigned long)real_fops |\n\t\t\t\tDEBUGFS_FSDATA_IS_REAL_FOPS_BIT);\n\n\td_instantiate(dentry, inode);\n\tfsnotify_create(d_inode(dentry->d_parent), dentry);\n\treturn end_creating(dentry);\n}\n\n \nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\n\treturn __debugfs_create_file(name, mode, parent, data,\n\t\t\t\tfops ? &debugfs_full_proxy_file_operations :\n\t\t\t\t\t&debugfs_noop_file_operations,\n\t\t\t\tfops);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_file);\n\n \nstruct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\n\treturn __debugfs_create_file(name, mode, parent, data,\n\t\t\t\tfops ? &debugfs_open_proxy_file_operations :\n\t\t\t\t\t&debugfs_noop_file_operations,\n\t\t\t\tfops);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_file_unsafe);\n\n \nvoid debugfs_create_file_size(const char *name, umode_t mode,\n\t\t\t      struct dentry *parent, void *data,\n\t\t\t      const struct file_operations *fops,\n\t\t\t      loff_t file_size)\n{\n\tstruct dentry *de = debugfs_create_file(name, mode, parent, data, fops);\n\n\tif (!IS_ERR(de))\n\t\td_inode(de)->i_size = file_size;\n}\nEXPORT_SYMBOL_GPL(debugfs_create_file_size);\n\n \nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_API)) {\n\t\tfailed_creating(dentry);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tpr_err(\"out of free dentries, can not create directory '%s'\\n\",\n\t\t       name);\n\t\treturn failed_creating(dentry);\n\t}\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &debugfs_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t \n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(d_inode(dentry->d_parent));\n\tfsnotify_mkdir(d_inode(dentry->d_parent), dentry);\n\treturn end_creating(dentry);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_dir);\n\n \nstruct dentry *debugfs_create_automount(const char *name,\n\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\tdebugfs_automount_t f,\n\t\t\t\t\tvoid *data)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct debugfs_fsdata *fsd;\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\tfsd = kzalloc(sizeof(*fsd), GFP_KERNEL);\n\tif (!fsd) {\n\t\tfailed_creating(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfsd->automount = f;\n\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_API)) {\n\t\tfailed_creating(dentry);\n\t\tkfree(fsd);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tpr_err(\"out of free dentries, can not create automount '%s'\\n\",\n\t\t       name);\n\t\tkfree(fsd);\n\t\treturn failed_creating(dentry);\n\t}\n\n\tmake_empty_dir_inode(inode);\n\tinode->i_flags |= S_AUTOMOUNT;\n\tinode->i_private = data;\n\tdentry->d_fsdata = fsd;\n\t \n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(d_inode(dentry->d_parent));\n\tfsnotify_mkdir(d_inode(dentry->d_parent), dentry);\n\treturn end_creating(dentry);\n}\nEXPORT_SYMBOL(debugfs_create_automount);\n\n \nstruct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,\n\t\t\t\t      const char *target)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tchar *link = kstrdup(target, GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdentry = start_creating(name, parent);\n\tif (IS_ERR(dentry)) {\n\t\tkfree(link);\n\t\treturn dentry;\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tpr_err(\"out of free dentries, can not create symlink '%s'\\n\",\n\t\t       name);\n\t\tkfree(link);\n\t\treturn failed_creating(dentry);\n\t}\n\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\tinode->i_op = &debugfs_symlink_inode_operations;\n\tinode->i_link = link;\n\td_instantiate(dentry, inode);\n\treturn end_creating(dentry);\n}\nEXPORT_SYMBOL_GPL(debugfs_create_symlink);\n\nstatic void __debugfs_file_removed(struct dentry *dentry)\n{\n\tstruct debugfs_fsdata *fsd;\n\n\t \n\tsmp_mb();\n\tfsd = READ_ONCE(dentry->d_fsdata);\n\tif ((unsigned long)fsd & DEBUGFS_FSDATA_IS_REAL_FOPS_BIT)\n\t\treturn;\n\tif (!refcount_dec_and_test(&fsd->active_users))\n\t\twait_for_completion(&fsd->active_users_drained);\n}\n\nstatic void remove_one(struct dentry *victim)\n{\n        if (d_is_reg(victim))\n\t\t__debugfs_file_removed(victim);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n}\n\n \nvoid debugfs_remove(struct dentry *dentry)\n{\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tsimple_pin_fs(&debug_fs_type, &debugfs_mount, &debugfs_mount_count);\n\tsimple_recursive_removal(dentry, remove_one);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n}\nEXPORT_SYMBOL_GPL(debugfs_remove);\n\n \nvoid debugfs_lookup_and_remove(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\n\tdentry = debugfs_lookup(name, parent);\n\tif (!dentry)\n\t\treturn;\n\n\tdebugfs_remove(dentry);\n\tdput(dentry);\n}\nEXPORT_SYMBOL_GPL(debugfs_lookup_and_remove);\n\n \nstruct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\tif (IS_ERR(old_dir))\n\t\treturn old_dir;\n\tif (IS_ERR(new_dir))\n\t\treturn new_dir;\n\tif (IS_ERR_OR_NULL(old_dentry))\n\t\treturn old_dentry;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t \n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t \n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t \n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(&nop_mnt_idmap, d_inode(old_dir), old_dentry,\n\t\t\t      d_inode(new_dir), dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), &old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\treturn ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(debugfs_rename);\n\n \nbool debugfs_initialized(void)\n{\n\treturn debugfs_registered;\n}\nEXPORT_SYMBOL_GPL(debugfs_initialized);\n\nstatic int __init debugfs_kernel(char *str)\n{\n\tif (str) {\n\t\tif (!strcmp(str, \"on\"))\n\t\t\tdebugfs_allow = DEBUGFS_ALLOW_API | DEBUGFS_ALLOW_MOUNT;\n\t\telse if (!strcmp(str, \"no-mount\"))\n\t\t\tdebugfs_allow = DEBUGFS_ALLOW_API;\n\t\telse if (!strcmp(str, \"off\"))\n\t\t\tdebugfs_allow = 0;\n\t}\n\n\treturn 0;\n}\nearly_param(\"debugfs\", debugfs_kernel);\nstatic int __init debugfs_init(void)\n{\n\tint retval;\n\n\tif (!(debugfs_allow & DEBUGFS_ALLOW_MOUNT))\n\t\treturn -EPERM;\n\n\tretval = sysfs_create_mount_point(kernel_kobj, \"debug\");\n\tif (retval)\n\t\treturn retval;\n\n\tretval = register_filesystem(&debug_fs_type);\n\tif (retval)\n\t\tsysfs_remove_mount_point(kernel_kobj, \"debug\");\n\telse\n\t\tdebugfs_registered = true;\n\n\treturn retval;\n}\ncore_initcall(debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}