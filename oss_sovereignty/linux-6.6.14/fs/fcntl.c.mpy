{
  "module_name": "fcntl.c",
  "hash_id": "3ab12b21da53a31c2009907ae872837853cba71ac6d62ce2ad7147348eb8ccad",
  "original_prompt": "Ingested from linux-6.6.14/fs/fcntl.c",
  "human_readable_source": "\n \n\n#include <linux/syscalls.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/capability.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/rcupdate.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/memfd.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n\n#include <linux/poll.h>\n#include <asm/siginfo.h>\n#include <linux/uaccess.h>\n\n#define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | O_DIRECT | O_NOATIME)\n\nstatic int setfl(int fd, struct file * filp, unsigned int arg)\n{\n\tstruct inode * inode = file_inode(filp);\n\tint error = 0;\n\n\t \n\tif (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\t \n\tif ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))\n\t\tif (!inode_owner_or_capable(file_mnt_idmap(filp), inode))\n\t\t\treturn -EPERM;\n\n\t \n\tif (O_NONBLOCK != O_NDELAY)\n\t       if (arg & O_NDELAY)\n\t\t   arg |= O_NONBLOCK;\n\n\t \n\tif (!S_ISFIFO(inode->i_mode) &&\n\t    (arg & O_DIRECT) &&\n\t    !(filp->f_mode & FMODE_CAN_ODIRECT))\n\t\treturn -EINVAL;\n\n\tif (filp->f_op->check_flags)\n\t\terror = filp->f_op->check_flags(arg);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (((arg ^ filp->f_flags) & FASYNC) && filp->f_op->fasync) {\n\t\terror = filp->f_op->fasync(fd, filp, (arg & FASYNC) != 0);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t\tif (error > 0)\n\t\t\terror = 0;\n\t}\n\tspin_lock(&filp->f_lock);\n\tfilp->f_flags = (arg & SETFL_MASK) | (filp->f_flags & ~SETFL_MASK);\n\tfilp->f_iocb_flags = iocb_flags(filp);\n\tspin_unlock(&filp->f_lock);\n\n out:\n\treturn error;\n}\n\nstatic void f_modown(struct file *filp, struct pid *pid, enum pid_type type,\n                     int force)\n{\n\twrite_lock_irq(&filp->f_owner.lock);\n\tif (force || !filp->f_owner.pid) {\n\t\tput_pid(filp->f_owner.pid);\n\t\tfilp->f_owner.pid = get_pid(pid);\n\t\tfilp->f_owner.pid_type = type;\n\n\t\tif (pid) {\n\t\t\tconst struct cred *cred = current_cred();\n\t\t\tfilp->f_owner.uid = cred->uid;\n\t\t\tfilp->f_owner.euid = cred->euid;\n\t\t}\n\t}\n\twrite_unlock_irq(&filp->f_owner.lock);\n}\n\nvoid __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\n\t\tint force)\n{\n\tsecurity_file_set_fowner(filp);\n\tf_modown(filp, pid, type, force);\n}\nEXPORT_SYMBOL(__f_setown);\n\nint f_setown(struct file *filp, int who, int force)\n{\n\tenum pid_type type;\n\tstruct pid *pid = NULL;\n\tint ret = 0;\n\n\ttype = PIDTYPE_TGID;\n\tif (who < 0) {\n\t\t \n\t\tif (who == INT_MIN)\n\t\t\treturn -EINVAL;\n\n\t\ttype = PIDTYPE_PGID;\n\t\twho = -who;\n\t}\n\n\trcu_read_lock();\n\tif (who) {\n\t\tpid = find_vpid(who);\n\t\tif (!pid)\n\t\t\tret = -ESRCH;\n\t}\n\n\tif (!ret)\n\t\t__f_setown(filp, pid, type, force);\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(f_setown);\n\nvoid f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_TGID, 1);\n}\n\npid_t f_getown(struct file *filp)\n{\n\tpid_t pid = 0;\n\n\tread_lock_irq(&filp->f_owner.lock);\n\trcu_read_lock();\n\tif (pid_task(filp->f_owner.pid, filp->f_owner.pid_type)) {\n\t\tpid = pid_vnr(filp->f_owner.pid);\n\t\tif (filp->f_owner.pid_type == PIDTYPE_PGID)\n\t\t\tpid = -pid;\n\t}\n\trcu_read_unlock();\n\tread_unlock_irq(&filp->f_owner.lock);\n\treturn pid;\n}\n\nstatic int f_setown_ex(struct file *filp, unsigned long arg)\n{\n\tstruct f_owner_ex __user *owner_p = (void __user *)arg;\n\tstruct f_owner_ex owner;\n\tstruct pid *pid;\n\tint type;\n\tint ret;\n\n\tret = copy_from_user(&owner, owner_p, sizeof(owner));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tswitch (owner.type) {\n\tcase F_OWNER_TID:\n\t\ttype = PIDTYPE_PID;\n\t\tbreak;\n\n\tcase F_OWNER_PID:\n\t\ttype = PIDTYPE_TGID;\n\t\tbreak;\n\n\tcase F_OWNER_PGRP:\n\t\ttype = PIDTYPE_PGID;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tpid = find_vpid(owner.pid);\n\tif (owner.pid && !pid)\n\t\tret = -ESRCH;\n\telse\n\t\t __f_setown(filp, pid, type, 1);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int f_getown_ex(struct file *filp, unsigned long arg)\n{\n\tstruct f_owner_ex __user *owner_p = (void __user *)arg;\n\tstruct f_owner_ex owner = {};\n\tint ret = 0;\n\n\tread_lock_irq(&filp->f_owner.lock);\n\trcu_read_lock();\n\tif (pid_task(filp->f_owner.pid, filp->f_owner.pid_type))\n\t\towner.pid = pid_vnr(filp->f_owner.pid);\n\trcu_read_unlock();\n\tswitch (filp->f_owner.pid_type) {\n\tcase PIDTYPE_PID:\n\t\towner.type = F_OWNER_TID;\n\t\tbreak;\n\n\tcase PIDTYPE_TGID:\n\t\towner.type = F_OWNER_PID;\n\t\tbreak;\n\n\tcase PIDTYPE_PGID:\n\t\towner.type = F_OWNER_PGRP;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tread_unlock_irq(&filp->f_owner.lock);\n\n\tif (!ret) {\n\t\tret = copy_to_user(owner_p, &owner, sizeof(owner));\n\t\tif (ret)\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int f_getowner_uids(struct file *filp, unsigned long arg)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tuid_t __user *dst = (void __user *)arg;\n\tuid_t src[2];\n\tint err;\n\n\tread_lock_irq(&filp->f_owner.lock);\n\tsrc[0] = from_kuid(user_ns, filp->f_owner.uid);\n\tsrc[1] = from_kuid(user_ns, filp->f_owner.euid);\n\tread_unlock_irq(&filp->f_owner.lock);\n\n\terr  = put_user(src[0], &dst[0]);\n\terr |= put_user(src[1], &dst[1]);\n\n\treturn err;\n}\n#else\nstatic int f_getowner_uids(struct file *filp, unsigned long arg)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic bool rw_hint_valid(enum rw_hint hint)\n{\n\tswitch (hint) {\n\tcase RWH_WRITE_LIFE_NOT_SET:\n\tcase RWH_WRITE_LIFE_NONE:\n\tcase RWH_WRITE_LIFE_SHORT:\n\tcase RWH_WRITE_LIFE_MEDIUM:\n\tcase RWH_WRITE_LIFE_LONG:\n\tcase RWH_WRITE_LIFE_EXTREME:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic long fcntl_rw_hint(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tu64 __user *argp = (u64 __user *)arg;\n\tenum rw_hint hint;\n\tu64 h;\n\n\tswitch (cmd) {\n\tcase F_GET_RW_HINT:\n\t\th = inode->i_write_hint;\n\t\tif (copy_to_user(argp, &h, sizeof(*argp)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase F_SET_RW_HINT:\n\t\tif (copy_from_user(&h, argp, sizeof(h)))\n\t\t\treturn -EFAULT;\n\t\thint = (enum rw_hint) h;\n\t\tif (!rw_hint_valid(hint))\n\t\t\treturn -EINVAL;\n\n\t\tinode_lock(inode);\n\t\tinode->i_write_hint = hint;\n\t\tinode_unlock(inode);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long do_fcntl(int fd, unsigned int cmd, unsigned long arg,\n\t\tstruct file *filp)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint argi = (int)arg;\n\tstruct flock flock;\n\tlong err = -EINVAL;\n\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\t\terr = f_dupfd(argi, filp, 0);\n\t\tbreak;\n\tcase F_DUPFD_CLOEXEC:\n\t\terr = f_dupfd(argi, filp, O_CLOEXEC);\n\t\tbreak;\n\tcase F_GETFD:\n\t\terr = get_close_on_exec(fd) ? FD_CLOEXEC : 0;\n\t\tbreak;\n\tcase F_SETFD:\n\t\terr = 0;\n\t\tset_close_on_exec(fd, argi & FD_CLOEXEC);\n\t\tbreak;\n\tcase F_GETFL:\n\t\terr = filp->f_flags;\n\t\tbreak;\n\tcase F_SETFL:\n\t\terr = setfl(fd, filp, argi);\n\t\tbreak;\n#if BITS_PER_LONG != 32\n\t \n\tcase F_OFD_GETLK:\n#endif\n\tcase F_GETLK:\n\t\tif (copy_from_user(&flock, argp, sizeof(flock)))\n\t\t\treturn -EFAULT;\n\t\terr = fcntl_getlk(filp, cmd, &flock);\n\t\tif (!err && copy_to_user(argp, &flock, sizeof(flock)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#if BITS_PER_LONG != 32\n\t \n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\t\tfallthrough;\n#endif\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\t\tif (copy_from_user(&flock, argp, sizeof(flock)))\n\t\t\treturn -EFAULT;\n\t\terr = fcntl_setlk(fd, filp, cmd, &flock);\n\t\tbreak;\n\tcase F_GETOWN:\n\t\t \n\t\terr = f_getown(filp);\n\t\tforce_successful_syscall_return();\n\t\tbreak;\n\tcase F_SETOWN:\n\t\terr = f_setown(filp, argi, 1);\n\t\tbreak;\n\tcase F_GETOWN_EX:\n\t\terr = f_getown_ex(filp, arg);\n\t\tbreak;\n\tcase F_SETOWN_EX:\n\t\terr = f_setown_ex(filp, arg);\n\t\tbreak;\n\tcase F_GETOWNER_UIDS:\n\t\terr = f_getowner_uids(filp, arg);\n\t\tbreak;\n\tcase F_GETSIG:\n\t\terr = filp->f_owner.signum;\n\t\tbreak;\n\tcase F_SETSIG:\n\t\t \n\t\tif (!valid_signal(argi)) {\n\t\t\tbreak;\n\t\t}\n\t\terr = 0;\n\t\tfilp->f_owner.signum = argi;\n\t\tbreak;\n\tcase F_GETLEASE:\n\t\terr = fcntl_getlease(filp);\n\t\tbreak;\n\tcase F_SETLEASE:\n\t\terr = fcntl_setlease(fd, filp, argi);\n\t\tbreak;\n\tcase F_NOTIFY:\n\t\terr = fcntl_dirnotify(fd, filp, argi);\n\t\tbreak;\n\tcase F_SETPIPE_SZ:\n\tcase F_GETPIPE_SZ:\n\t\terr = pipe_fcntl(filp, cmd, argi);\n\t\tbreak;\n\tcase F_ADD_SEALS:\n\tcase F_GET_SEALS:\n\t\terr = memfd_fcntl(filp, cmd, argi);\n\t\tbreak;\n\tcase F_GET_RW_HINT:\n\tcase F_SET_RW_HINT:\n\t\terr = fcntl_rw_hint(filp, cmd, arg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int check_fcntl_cmd(unsigned cmd)\n{\n\tswitch (cmd) {\n\tcase F_DUPFD:\n\tcase F_DUPFD_CLOEXEC:\n\tcase F_GETFD:\n\tcase F_SETFD:\n\tcase F_GETFL:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\t\n\tstruct fd f = fdget_raw(fd);\n\tlong err = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tif (unlikely(f.file->f_mode & FMODE_PATH)) {\n\t\tif (!check_fcntl_cmd(cmd))\n\t\t\tgoto out1;\n\t}\n\n\terr = security_file_fcntl(f.file, cmd, arg);\n\tif (!err)\n\t\terr = do_fcntl(fd, cmd, arg, f.file);\n\nout1:\n \tfdput(f);\nout:\n\treturn err;\n}\n\n#if BITS_PER_LONG == 32\nSYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,\n\t\tunsigned long, arg)\n{\t\n\tvoid __user *argp = (void __user *)arg;\n\tstruct fd f = fdget_raw(fd);\n\tstruct flock64 flock;\n\tlong err = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tif (unlikely(f.file->f_mode & FMODE_PATH)) {\n\t\tif (!check_fcntl_cmd(cmd))\n\t\t\tgoto out1;\n\t}\n\n\terr = security_file_fcntl(f.file, cmd, arg);\n\tif (err)\n\t\tgoto out1;\n\t\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\tcase F_OFD_GETLK:\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&flock, argp, sizeof(flock)))\n\t\t\tbreak;\n\t\terr = fcntl_getlk64(f.file, cmd, &flock);\n\t\tif (!err && copy_to_user(argp, &flock, sizeof(flock)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&flock, argp, sizeof(flock)))\n\t\t\tbreak;\n\t\terr = fcntl_setlk64(fd, f.file, cmd, &flock);\n\t\tbreak;\n\tdefault:\n\t\terr = do_fcntl(fd, cmd, arg, f.file);\n\t\tbreak;\n\t}\nout1:\n\tfdput(f);\nout:\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n \n#define copy_flock_fields(dst, src)\t\t\\\n\t(dst)->l_type = (src)->l_type;\t\t\\\n\t(dst)->l_whence = (src)->l_whence;\t\\\n\t(dst)->l_start = (src)->l_start;\t\\\n\t(dst)->l_len = (src)->l_len;\t\t\\\n\t(dst)->l_pid = (src)->l_pid;\n\nstatic int get_compat_flock(struct flock *kfl, const struct compat_flock __user *ufl)\n{\n\tstruct compat_flock fl;\n\n\tif (copy_from_user(&fl, ufl, sizeof(struct compat_flock)))\n\t\treturn -EFAULT;\n\tcopy_flock_fields(kfl, &fl);\n\treturn 0;\n}\n\nstatic int get_compat_flock64(struct flock *kfl, const struct compat_flock64 __user *ufl)\n{\n\tstruct compat_flock64 fl;\n\n\tif (copy_from_user(&fl, ufl, sizeof(struct compat_flock64)))\n\t\treturn -EFAULT;\n\tcopy_flock_fields(kfl, &fl);\n\treturn 0;\n}\n\nstatic int put_compat_flock(const struct flock *kfl, struct compat_flock __user *ufl)\n{\n\tstruct compat_flock fl;\n\n\tmemset(&fl, 0, sizeof(struct compat_flock));\n\tcopy_flock_fields(&fl, kfl);\n\tif (copy_to_user(ufl, &fl, sizeof(struct compat_flock)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int put_compat_flock64(const struct flock *kfl, struct compat_flock64 __user *ufl)\n{\n\tstruct compat_flock64 fl;\n\n\tBUILD_BUG_ON(sizeof(kfl->l_start) > sizeof(ufl->l_start));\n\tBUILD_BUG_ON(sizeof(kfl->l_len) > sizeof(ufl->l_len));\n\n\tmemset(&fl, 0, sizeof(struct compat_flock64));\n\tcopy_flock_fields(&fl, kfl);\n\tif (copy_to_user(ufl, &fl, sizeof(struct compat_flock64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#undef copy_flock_fields\n\nstatic unsigned int\nconvert_fcntl_cmd(unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\treturn F_GETLK;\n\tcase F_SETLK64:\n\t\treturn F_SETLK;\n\tcase F_SETLKW64:\n\t\treturn F_SETLKW;\n\t}\n\n\treturn cmd;\n}\n\n \nstatic int fixup_compat_flock(struct flock *flock)\n{\n\tif (flock->l_start > COMPAT_OFF_T_MAX)\n\t\treturn -EOVERFLOW;\n\tif (flock->l_len > COMPAT_OFF_T_MAX)\n\t\tflock->l_len = COMPAT_OFF_T_MAX;\n\treturn 0;\n}\n\nstatic long do_compat_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t     compat_ulong_t arg)\n{\n\tstruct fd f = fdget_raw(fd);\n\tstruct flock flock;\n\tlong err = -EBADF;\n\n\tif (!f.file)\n\t\treturn err;\n\n\tif (unlikely(f.file->f_mode & FMODE_PATH)) {\n\t\tif (!check_fcntl_cmd(cmd))\n\t\t\tgoto out_put;\n\t}\n\n\terr = security_file_fcntl(f.file, cmd, arg);\n\tif (err)\n\t\tgoto out_put;\n\n\tswitch (cmd) {\n\tcase F_GETLK:\n\t\terr = get_compat_flock(&flock, compat_ptr(arg));\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fcntl_getlk(f.file, convert_fcntl_cmd(cmd), &flock);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fixup_compat_flock(&flock);\n\t\tif (!err)\n\t\t\terr = put_compat_flock(&flock, compat_ptr(arg));\n\t\tbreak;\n\tcase F_GETLK64:\n\tcase F_OFD_GETLK:\n\t\terr = get_compat_flock64(&flock, compat_ptr(arg));\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fcntl_getlk(f.file, convert_fcntl_cmd(cmd), &flock);\n\t\tif (!err)\n\t\t\terr = put_compat_flock64(&flock, compat_ptr(arg));\n\t\tbreak;\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\t\terr = get_compat_flock(&flock, compat_ptr(arg));\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fcntl_setlk(fd, f.file, convert_fcntl_cmd(cmd), &flock);\n\t\tbreak;\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\t\terr = get_compat_flock64(&flock, compat_ptr(arg));\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = fcntl_setlk(fd, f.file, convert_fcntl_cmd(cmd), &flock);\n\t\tbreak;\n\tdefault:\n\t\terr = do_fcntl(fd, cmd, arg, f.file);\n\t\tbreak;\n\t}\nout_put:\n\tfdput(f);\n\treturn err;\n}\n\nCOMPAT_SYSCALL_DEFINE3(fcntl64, unsigned int, fd, unsigned int, cmd,\n\t\t       compat_ulong_t, arg)\n{\n\treturn do_compat_fcntl64(fd, cmd, arg);\n}\n\nCOMPAT_SYSCALL_DEFINE3(fcntl, unsigned int, fd, unsigned int, cmd,\n\t\t       compat_ulong_t, arg)\n{\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\t\treturn -EINVAL;\n\t}\n\treturn do_compat_fcntl64(fd, cmd, arg);\n}\n#endif\n\n \n\nstatic const __poll_t band_table[NSIGPOLL] = {\n\tEPOLLIN | EPOLLRDNORM,\t\t\t \n\tEPOLLOUT | EPOLLWRNORM | EPOLLWRBAND,\t \n\tEPOLLIN | EPOLLRDNORM | EPOLLMSG,\t\t \n\tEPOLLERR,\t\t\t\t \n\tEPOLLPRI | EPOLLRDBAND,\t\t\t \n\tEPOLLHUP | EPOLLERR\t\t\t \n};\n\nstatic inline int sigio_perm(struct task_struct *p,\n                             struct fown_struct *fown, int sig)\n{\n\tconst struct cred *cred;\n\tint ret;\n\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tret = ((uid_eq(fown->euid, GLOBAL_ROOT_UID) ||\n\t\tuid_eq(fown->euid, cred->suid) || uid_eq(fown->euid, cred->uid) ||\n\t\tuid_eq(fown->uid,  cred->suid) || uid_eq(fown->uid,  cred->uid)) &&\n\t       !security_file_send_sigiotask(p, fown, sig));\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic void send_sigio_to_task(struct task_struct *p,\n\t\t\t       struct fown_struct *fown,\n\t\t\t       int fd, int reason, enum pid_type type)\n{\n\t \n\tint signum = READ_ONCE(fown->signum);\n\n\tif (!sigio_perm(p, fown, signum))\n\t\treturn;\n\n\tswitch (signum) {\n\t\tdefault: {\n\t\t\tkernel_siginfo_t si;\n\n\t\t\t \n\t\t\tclear_siginfo(&si);\n\t\t\tsi.si_signo = signum;\n\t\t\tsi.si_errno = 0;\n\t\t        si.si_code  = reason;\n\t\t\t \n\t\t\tif ((signum != SIGPOLL) && sig_specific_sicodes(signum))\n\t\t\t\tsi.si_code = SI_SIGIO;\n\n\t\t\t \n\t\t\tBUG_ON((reason < POLL_IN) || ((reason - POLL_IN) >= NSIGPOLL));\n\t\t\tif (reason - POLL_IN >= NSIGPOLL)\n\t\t\t\tsi.si_band  = ~0L;\n\t\t\telse\n\t\t\t\tsi.si_band = mangle_poll(band_table[reason - POLL_IN]);\n\t\t\tsi.si_fd    = fd;\n\t\t\tif (!do_send_sig_info(signum, &si, p, type))\n\t\t\t\tbreak;\n\t\t}\n\t\t\tfallthrough;\t \n\t\tcase 0:\n\t\t\tdo_send_sig_info(SIGIO, SEND_SIG_PRIV, p, type);\n\t}\n}\n\nvoid send_sigio(struct fown_struct *fown, int fd, int band)\n{\n\tstruct task_struct *p;\n\tenum pid_type type;\n\tunsigned long flags;\n\tstruct pid *pid;\n\t\n\tread_lock_irqsave(&fown->lock, flags);\n\n\ttype = fown->pid_type;\n\tpid = fown->pid;\n\tif (!pid)\n\t\tgoto out_unlock_fown;\n\n\tif (type <= PIDTYPE_TGID) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\tsend_sigio_to_task(p, fown, fd, band, type);\n\t\trcu_read_unlock();\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_pid_task(pid, type, p) {\n\t\t\tsend_sigio_to_task(p, fown, fd, band, type);\n\t\t} while_each_pid_task(pid, type, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n out_unlock_fown:\n\tread_unlock_irqrestore(&fown->lock, flags);\n}\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}\n\nint send_sigurg(struct fown_struct *fown)\n{\n\tstruct task_struct *p;\n\tenum pid_type type;\n\tstruct pid *pid;\n\tunsigned long flags;\n\tint ret = 0;\n\t\n\tread_lock_irqsave(&fown->lock, flags);\n\n\ttype = fown->pid_type;\n\tpid = fown->pid;\n\tif (!pid)\n\t\tgoto out_unlock_fown;\n\n\tret = 1;\n\n\tif (type <= PIDTYPE_TGID) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\tsend_sigurg_to_task(p, fown, type);\n\t\trcu_read_unlock();\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_pid_task(pid, type, p) {\n\t\t\tsend_sigurg_to_task(p, fown, type);\n\t\t} while_each_pid_task(pid, type, p);\n\t\tread_unlock(&tasklist_lock);\n\t}\n out_unlock_fown:\n\tread_unlock_irqrestore(&fown->lock, flags);\n\treturn ret;\n}\n\nstatic DEFINE_SPINLOCK(fasync_lock);\nstatic struct kmem_cache *fasync_cache __read_mostly;\n\nstatic void fasync_free_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(fasync_cache,\n\t\t\tcontainer_of(head, struct fasync_struct, fa_rcu));\n}\n\n \nint fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)\n{\n\tstruct fasync_struct *fa, **fp;\n\tint result = 0;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\twrite_lock_irq(&fa->fa_lock);\n\t\tfa->fa_file = NULL;\n\t\twrite_unlock_irq(&fa->fa_lock);\n\n\t\t*fp = fa->fa_next;\n\t\tcall_rcu(&fa->fa_rcu, fasync_free_rcu);\n\t\tfilp->f_flags &= ~FASYNC;\n\t\tresult = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn result;\n}\n\nstruct fasync_struct *fasync_alloc(void)\n{\n\treturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n}\n\n \nvoid fasync_free(struct fasync_struct *new)\n{\n\tkmem_cache_free(fasync_cache, new);\n}\n\n \nstruct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\n{\n        struct fasync_struct *fa, **fp;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\twrite_lock_irq(&fa->fa_lock);\n\t\tfa->fa_fd = fd;\n\t\twrite_unlock_irq(&fa->fa_lock);\n\t\tgoto out;\n\t}\n\n\trwlock_init(&new->fa_lock);\n\tnew->magic = FASYNC_MAGIC;\n\tnew->fa_file = filp;\n\tnew->fa_fd = fd;\n\tnew->fa_next = *fapp;\n\trcu_assign_pointer(*fapp, new);\n\tfilp->f_flags |= FASYNC;\n\nout:\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn fa;\n}\n\n \nstatic int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)\n{\n\tstruct fasync_struct *new;\n\n\tnew = fasync_alloc();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t \n\tif (fasync_insert_entry(fd, filp, fapp, new)) {\n\t\tfasync_free(new);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}\n\nEXPORT_SYMBOL(fasync_helper);\n\n \nstatic void kill_fasync_rcu(struct fasync_struct *fa, int sig, int band)\n{\n\twhile (fa) {\n\t\tstruct fown_struct *fown;\n\t\tunsigned long flags;\n\n\t\tif (fa->magic != FASYNC_MAGIC) {\n\t\t\tprintk(KERN_ERR \"kill_fasync: bad magic number in \"\n\t\t\t       \"fasync_struct!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tread_lock_irqsave(&fa->fa_lock, flags);\n\t\tif (fa->fa_file) {\n\t\t\tfown = &fa->fa_file->f_owner;\n\t\t\t \n\t\t\tif (!(sig == SIGURG && fown->signum == 0))\n\t\t\t\tsend_sigio(fown, fa->fa_fd, band);\n\t\t}\n\t\tread_unlock_irqrestore(&fa->fa_lock, flags);\n\t\tfa = rcu_dereference(fa->fa_next);\n\t}\n}\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t \n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL(kill_fasync);\n\nstatic int __init fcntl_init(void)\n{\n\t \n\tBUILD_BUG_ON(21 - 1   !=\n\t\tHWEIGHT32(\n\t\t\t(VALID_OPEN_FLAGS & ~(O_NONBLOCK | O_NDELAY)) |\n\t\t\t__FMODE_EXEC | __FMODE_NONOTIFY));\n\n\tfasync_cache = kmem_cache_create(\"fasync_cache\",\n\t\t\t\t\t sizeof(struct fasync_struct), 0,\n\t\t\t\t\t SLAB_PANIC | SLAB_ACCOUNT, NULL);\n\treturn 0;\n}\n\nmodule_init(fcntl_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}