{
  "module_name": "readdir.c",
  "hash_id": "0eb553eeb6ebb8508017ee99f03095287f26909de178f9942464812c9bdec500",
  "original_prompt": "Ingested from linux-6.6.14/fs/readdir.c",
  "human_readable_source": "\n \n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n\n#include <asm/unaligned.h>\n\n \nint wrap_directory_iterator(struct file *file,\n\t\t\t    struct dir_context *ctx,\n\t\t\t    int (*iter)(struct file *, struct dir_context *))\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\n\t \n\tup_read(&inode->i_rwsem);\n\tdown_write(&inode->i_rwsem);\n\n\t \n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode))\n\t\tret = iter(file, ctx);\n\n\tdowngrade_write(&inode->i_rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL(wrap_directory_iterator);\n\n \n#define unsafe_copy_dirent_name(_dst, _src, _len, label) do {\t\\\n\tchar __user *dst = (_dst);\t\t\t\t\\\n\tconst char *src = (_src);\t\t\t\t\\\n\tsize_t len = (_len);\t\t\t\t\t\\\n\tunsafe_put_user(0, dst+len, label);\t\t\t\\\n\tunsafe_copy_to_user(dst, src, len, label);\t\t\\\n} while (0)\n\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\n\tif (!file->f_op->iterate_shared)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = down_read_killable(&inode->i_rwsem);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate_shared(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tinode_unlock_shared(inode);\nout:\n\treturn res;\n}\nEXPORT_SYMBOL(iterate_dir);\n\n \nstatic int verify_dirent_name(const char *name, int len)\n{\n\tif (len <= 0 || len >= PATH_MAX)\n\t\treturn -EIO;\n\tif (memchr(name, '/', len))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \n\n#ifdef __ARCH_WANT_OLD_READDIR\n\nstruct old_linux_dirent {\n\tunsigned long\td_ino;\n\tunsigned long\td_offset;\n\tunsigned short\td_namlen;\n\tchar\t\td_name[];\n};\n\nstruct readdir_callback {\n\tstruct dir_context ctx;\n\tstruct old_linux_dirent __user * dirent;\n\tint result;\n};\n\nstatic bool fillonedir(struct dir_context *ctx, const char *name, int namlen,\n\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_callback *buf =\n\t\tcontainer_of(ctx, struct readdir_callback, ctx);\n\tstruct old_linux_dirent __user * dirent;\n\tunsigned long d_ino;\n\n\tif (buf->result)\n\t\treturn false;\n\tbuf->result = verify_dirent_name(name, namlen);\n\tif (buf->result)\n\t\treturn false;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn false;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!user_write_access_begin(dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tunsafe_put_user(d_ino, &dirent->d_ino, efault_end);\n\tunsafe_put_user(offset, &dirent->d_offset, efault_end);\n\tunsafe_put_user(namlen, &dirent->d_namlen, efault_end);\n\tunsafe_copy_dirent_name(dirent->d_name, name, namlen, efault_end);\n\tuser_write_access_end();\n\treturn true;\nefault_end:\n\tuser_write_access_end();\nefault:\n\tbuf->result = -EFAULT;\n\treturn false;\n}\n\nSYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct readdir_callback buf = {\n\t\t.ctx.actor = fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}\n\n#endif  \n\n \nstruct linux_dirent {\n\tunsigned long\td_ino;\n\tunsigned long\td_off;\n\tunsigned short\td_reclen;\n\tchar\t\td_name[];\n};\n\nstruct getdents_callback {\n\tstruct dir_context ctx;\n\tstruct linux_dirent __user * current_dir;\n\tint prev_reclen;\n\tint count;\n\tint error;\n};\n\nstatic bool filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent __user *dirent, *prev;\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tunsigned long d_ino;\n\tint reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,\n\t\tsizeof(long));\n\tint prev_reclen;\n\n\tbuf->error = verify_dirent_name(name, namlen);\n\tif (unlikely(buf->error))\n\t\treturn false;\n\tbuf->error = -EINVAL;\t \n\tif (reclen > buf->count)\n\t\treturn false;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn false;\n\t}\n\tprev_reclen = buf->prev_reclen;\n\tif (prev_reclen && signal_pending(current))\n\t\treturn false;\n\tdirent = buf->current_dir;\n\tprev = (void __user *) dirent - prev_reclen;\n\tif (!user_write_access_begin(prev, reclen + prev_reclen))\n\t\tgoto efault;\n\n\t \n\tunsafe_put_user(offset, &prev->d_off, efault_end);\n\tunsafe_put_user(d_ino, &dirent->d_ino, efault_end);\n\tunsafe_put_user(reclen, &dirent->d_reclen, efault_end);\n\tunsafe_put_user(d_type, (char __user *) dirent + reclen - 1, efault_end);\n\tunsafe_copy_dirent_name(dirent->d_name, name, namlen, efault_end);\n\tuser_write_access_end();\n\n\tbuf->current_dir = (void __user *)dirent + reclen;\n\tbuf->prev_reclen = reclen;\n\tbuf->count -= reclen;\n\treturn true;\nefault_end:\n\tuser_write_access_end();\nefault:\n\tbuf->error = -EFAULT;\n\treturn false;\n}\n\nSYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct getdents_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tif (buf.prev_reclen) {\n\t\tstruct linux_dirent __user * lastdirent;\n\t\tlastdirent = (void __user *)buf.current_dir - buf.prev_reclen;\n\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}\n\nstruct getdents_callback64 {\n\tstruct dir_context ctx;\n\tstruct linux_dirent64 __user * current_dir;\n\tint prev_reclen;\n\tint count;\n\tint error;\n};\n\nstatic bool filldir64(struct dir_context *ctx, const char *name, int namlen,\n\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent64 __user *dirent, *prev;\n\tstruct getdents_callback64 *buf =\n\t\tcontainer_of(ctx, struct getdents_callback64, ctx);\n\tint reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,\n\t\tsizeof(u64));\n\tint prev_reclen;\n\n\tbuf->error = verify_dirent_name(name, namlen);\n\tif (unlikely(buf->error))\n\t\treturn false;\n\tbuf->error = -EINVAL;\t \n\tif (reclen > buf->count)\n\t\treturn false;\n\tprev_reclen = buf->prev_reclen;\n\tif (prev_reclen && signal_pending(current))\n\t\treturn false;\n\tdirent = buf->current_dir;\n\tprev = (void __user *)dirent - prev_reclen;\n\tif (!user_write_access_begin(prev, reclen + prev_reclen))\n\t\tgoto efault;\n\n\t \n\tunsafe_put_user(offset, &prev->d_off, efault_end);\n\tunsafe_put_user(ino, &dirent->d_ino, efault_end);\n\tunsafe_put_user(reclen, &dirent->d_reclen, efault_end);\n\tunsafe_put_user(d_type, &dirent->d_type, efault_end);\n\tunsafe_copy_dirent_name(dirent->d_name, name, namlen, efault_end);\n\tuser_write_access_end();\n\n\tbuf->prev_reclen = reclen;\n\tbuf->current_dir = (void __user *)dirent + reclen;\n\tbuf->count -= reclen;\n\treturn true;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\tbuf->error = -EFAULT;\n\treturn false;\n}\n\nSYSCALL_DEFINE3(getdents64, unsigned int, fd,\n\t\tstruct linux_dirent64 __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct getdents_callback64 buf = {\n\t\t.ctx.actor = filldir64,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tif (buf.prev_reclen) {\n\t\tstruct linux_dirent64 __user * lastdirent;\n\t\ttypeof(lastdirent->d_off) d_off = buf.ctx.pos;\n\n\t\tlastdirent = (void __user *) buf.current_dir - buf.prev_reclen;\n\t\tif (put_user(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_old_linux_dirent {\n\tcompat_ulong_t\td_ino;\n\tcompat_ulong_t\td_offset;\n\tunsigned short\td_namlen;\n\tchar\t\td_name[];\n};\n\nstruct compat_readdir_callback {\n\tstruct dir_context ctx;\n\tstruct compat_old_linux_dirent __user *dirent;\n\tint result;\n};\n\nstatic bool compat_fillonedir(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct compat_readdir_callback *buf =\n\t\tcontainer_of(ctx, struct compat_readdir_callback, ctx);\n\tstruct compat_old_linux_dirent __user *dirent;\n\tcompat_ulong_t d_ino;\n\n\tif (buf->result)\n\t\treturn false;\n\tbuf->result = verify_dirent_name(name, namlen);\n\tif (buf->result)\n\t\treturn false;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn false;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!user_write_access_begin(dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tunsafe_put_user(d_ino, &dirent->d_ino, efault_end);\n\tunsafe_put_user(offset, &dirent->d_offset, efault_end);\n\tunsafe_put_user(namlen, &dirent->d_namlen, efault_end);\n\tunsafe_copy_dirent_name(dirent->d_name, name, namlen, efault_end);\n\tuser_write_access_end();\n\treturn true;\nefault_end:\n\tuser_write_access_end();\nefault:\n\tbuf->result = -EFAULT;\n\treturn false;\n}\n\nCOMPAT_SYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct compat_old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct compat_readdir_callback buf = {\n\t\t.ctx.actor = compat_fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}\n\nstruct compat_linux_dirent {\n\tcompat_ulong_t\td_ino;\n\tcompat_ulong_t\td_off;\n\tunsigned short\td_reclen;\n\tchar\t\td_name[];\n};\n\nstruct compat_getdents_callback {\n\tstruct dir_context ctx;\n\tstruct compat_linux_dirent __user *current_dir;\n\tint prev_reclen;\n\tint count;\n\tint error;\n};\n\nstatic bool compat_filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct compat_linux_dirent __user *dirent, *prev;\n\tstruct compat_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct compat_getdents_callback, ctx);\n\tcompat_ulong_t d_ino;\n\tint reclen = ALIGN(offsetof(struct compat_linux_dirent, d_name) +\n\t\tnamlen + 2, sizeof(compat_long_t));\n\tint prev_reclen;\n\n\tbuf->error = verify_dirent_name(name, namlen);\n\tif (unlikely(buf->error))\n\t\treturn false;\n\tbuf->error = -EINVAL;\t \n\tif (reclen > buf->count)\n\t\treturn false;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn false;\n\t}\n\tprev_reclen = buf->prev_reclen;\n\tif (prev_reclen && signal_pending(current))\n\t\treturn false;\n\tdirent = buf->current_dir;\n\tprev = (void __user *) dirent - prev_reclen;\n\tif (!user_write_access_begin(prev, reclen + prev_reclen))\n\t\tgoto efault;\n\n\tunsafe_put_user(offset, &prev->d_off, efault_end);\n\tunsafe_put_user(d_ino, &dirent->d_ino, efault_end);\n\tunsafe_put_user(reclen, &dirent->d_reclen, efault_end);\n\tunsafe_put_user(d_type, (char __user *) dirent + reclen - 1, efault_end);\n\tunsafe_copy_dirent_name(dirent->d_name, name, namlen, efault_end);\n\tuser_write_access_end();\n\n\tbuf->prev_reclen = reclen;\n\tbuf->current_dir = (void __user *)dirent + reclen;\n\tbuf->count -= reclen;\n\treturn true;\nefault_end:\n\tuser_write_access_end();\nefault:\n\tbuf->error = -EFAULT;\n\treturn false;\n}\n\nCOMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct compat_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct compat_getdents_callback buf = {\n\t\t.ctx.actor = compat_filldir,\n\t\t.current_dir = dirent,\n\t\t.count = count\n\t};\n\tint error;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tif (buf.prev_reclen) {\n\t\tstruct compat_linux_dirent __user * lastdirent;\n\t\tlastdirent = (void __user *)buf.current_dir - buf.prev_reclen;\n\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}