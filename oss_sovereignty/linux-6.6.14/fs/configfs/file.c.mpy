{
  "module_name": "file.c",
  "hash_id": "f48ddc8da8a6d8d7aaeb52edb122dde5d7d818be03bfa981cd3947aa23b62590",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/file.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/configfs.h>\n#include \"configfs_internal.h\"\n\n \n#define SIMPLE_ATTR_SIZE 4096\n\nstruct configfs_buffer {\n\tsize_t\t\t\tcount;\n\tloff_t\t\t\tpos;\n\tchar\t\t\t* page;\n\tstruct configfs_item_operations\t* ops;\n\tstruct mutex\t\tmutex;\n\tint\t\t\tneeds_read_fill;\n\tbool\t\t\tread_in_progress;\n\tbool\t\t\twrite_in_progress;\n\tchar\t\t\t*bin_buffer;\n\tint\t\t\tbin_buffer_size;\n\tint\t\t\tcb_max_size;\n\tstruct config_item\t*item;\n\tstruct module\t\t*owner;\n\tunion {\n\t\tstruct configfs_attribute\t*attr;\n\t\tstruct configfs_bin_attribute\t*bin_attr;\n\t};\n};\n\nstatic inline struct configfs_fragment *to_frag(struct file *file)\n{\n\tstruct configfs_dirent *sd = file->f_path.dentry->d_fsdata;\n\n\treturn sd->s_frag;\n}\n\nstatic int fill_read_buffer(struct file *file, struct configfs_buffer *buffer)\n{\n\tstruct configfs_fragment *frag = to_frag(file);\n\tssize_t count = -ENOENT;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *) get_zeroed_page(GFP_KERNEL);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tdown_read(&frag->frag_sem);\n\tif (!frag->frag_dead)\n\t\tcount = buffer->attr->show(buffer->item, buffer->page);\n\tup_read(&frag->frag_sem);\n\n\tif (count < 0)\n\t\treturn count;\n\tif (WARN_ON_ONCE(count > (ssize_t)SIMPLE_ATTR_SIZE))\n\t\treturn -EIO;\n\tbuffer->needs_read_fill = 0;\n\tbuffer->count = count;\n\treturn 0;\n}\n\nstatic ssize_t configfs_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct configfs_buffer *buffer = file->private_data;\n\tssize_t retval = 0;\n\n\tmutex_lock(&buffer->mutex);\n\tif (buffer->needs_read_fill) {\n\t\tretval = fill_read_buffer(file, buffer);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tpr_debug(\"%s: count = %zd, pos = %lld, buf = %s\\n\",\n\t\t __func__, iov_iter_count(to), iocb->ki_pos, buffer->page);\n\tif (iocb->ki_pos >= buffer->count)\n\t\tgoto out;\n\tretval = copy_to_iter(buffer->page + iocb->ki_pos,\n\t\t\t      buffer->count - iocb->ki_pos, to);\n\tiocb->ki_pos += retval;\n\tif (retval == 0)\n\t\tretval = -EFAULT;\nout:\n\tmutex_unlock(&buffer->mutex);\n\treturn retval;\n}\n\nstatic ssize_t configfs_bin_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct configfs_fragment *frag = to_frag(file);\n\tstruct configfs_buffer *buffer = file->private_data;\n\tssize_t retval = 0;\n\tssize_t len;\n\n\tmutex_lock(&buffer->mutex);\n\n\t \n\tif (buffer->write_in_progress) {\n\t\tretval = -ETXTBSY;\n\t\tgoto out;\n\t}\n\tbuffer->read_in_progress = true;\n\n\tif (buffer->needs_read_fill) {\n\t\t \n\t\tdown_read(&frag->frag_sem);\n\t\tif (!frag->frag_dead)\n\t\t\tlen = buffer->bin_attr->read(buffer->item, NULL, 0);\n\t\telse\n\t\t\tlen = -ENOENT;\n\t\tup_read(&frag->frag_sem);\n\t\tif (len <= 0) {\n\t\t\tretval = len;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (buffer->cb_max_size && len > buffer->cb_max_size) {\n\t\t\tretval = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuffer->bin_buffer = vmalloc(len);\n\t\tif (buffer->bin_buffer == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbuffer->bin_buffer_size = len;\n\n\t\t \n\t\tdown_read(&frag->frag_sem);\n\t\tif (!frag->frag_dead)\n\t\t\tlen = buffer->bin_attr->read(buffer->item,\n\t\t\t\t\t\t     buffer->bin_buffer, len);\n\t\telse\n\t\t\tlen = -ENOENT;\n\t\tup_read(&frag->frag_sem);\n\t\tif (len < 0) {\n\t\t\tretval = len;\n\t\t\tvfree(buffer->bin_buffer);\n\t\t\tbuffer->bin_buffer_size = 0;\n\t\t\tbuffer->bin_buffer = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuffer->needs_read_fill = 0;\n\t}\n\n\tif (iocb->ki_pos >= buffer->bin_buffer_size)\n\t\tgoto out;\n\tretval = copy_to_iter(buffer->bin_buffer + iocb->ki_pos,\n\t\t\t      buffer->bin_buffer_size - iocb->ki_pos, to);\n\tiocb->ki_pos += retval;\n\tif (retval == 0)\n\t\tretval = -EFAULT;\nout:\n\tmutex_unlock(&buffer->mutex);\n\treturn retval;\n}\n\n \nstatic int fill_write_buffer(struct configfs_buffer *buffer,\n\t\t\t     struct iov_iter *from)\n{\n\tint copied;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *)__get_free_pages(GFP_KERNEL, 0);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tcopied = copy_from_iter(buffer->page, SIMPLE_ATTR_SIZE - 1, from);\n\tbuffer->needs_read_fill = 1;\n\t \n\tbuffer->page[copied] = 0;\n\treturn copied ? : -EFAULT;\n}\n\nstatic int\nflush_write_buffer(struct file *file, struct configfs_buffer *buffer, size_t count)\n{\n\tstruct configfs_fragment *frag = to_frag(file);\n\tint res = -ENOENT;\n\n\tdown_read(&frag->frag_sem);\n\tif (!frag->frag_dead)\n\t\tres = buffer->attr->store(buffer->item, buffer->page, count);\n\tup_read(&frag->frag_sem);\n\treturn res;\n}\n\n\n \nstatic ssize_t configfs_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct configfs_buffer *buffer = file->private_data;\n\tint len;\n\n\tmutex_lock(&buffer->mutex);\n\tlen = fill_write_buffer(buffer, from);\n\tif (len > 0)\n\t\tlen = flush_write_buffer(file, buffer, len);\n\tif (len > 0)\n\t\tiocb->ki_pos += len;\n\tmutex_unlock(&buffer->mutex);\n\treturn len;\n}\n\nstatic ssize_t configfs_bin_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct configfs_buffer *buffer = file->private_data;\n\tvoid *tbuf = NULL;\n\tsize_t end_offset;\n\tssize_t len;\n\n\tmutex_lock(&buffer->mutex);\n\n\t \n\tif (buffer->read_in_progress) {\n\t\tlen = -ETXTBSY;\n\t\tgoto out;\n\t}\n\tbuffer->write_in_progress = true;\n\n\t \n\tend_offset = iocb->ki_pos + iov_iter_count(from);\n\tif (end_offset > buffer->bin_buffer_size) {\n\t\tif (buffer->cb_max_size && end_offset > buffer->cb_max_size) {\n\t\t\tlen = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttbuf = vmalloc(end_offset);\n\t\tif (tbuf == NULL) {\n\t\t\tlen = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (buffer->bin_buffer) {\n\t\t\tmemcpy(tbuf, buffer->bin_buffer,\n\t\t\t\tbuffer->bin_buffer_size);\n\t\t\tvfree(buffer->bin_buffer);\n\t\t}\n\n\t\t \n\t\tmemset(tbuf + buffer->bin_buffer_size, 0,\n\t\t\tend_offset - buffer->bin_buffer_size);\n\t\tbuffer->bin_buffer = tbuf;\n\t\tbuffer->bin_buffer_size = end_offset;\n\t}\n\n\tlen = copy_from_iter(buffer->bin_buffer + iocb->ki_pos,\n\t\t\t     buffer->bin_buffer_size - iocb->ki_pos, from);\n\tiocb->ki_pos += len;\nout:\n\tmutex_unlock(&buffer->mutex);\n\treturn len ? : -EFAULT;\n}\n\nstatic int __configfs_open_file(struct inode *inode, struct file *file, int type)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct configfs_fragment *frag = to_frag(file);\n\tstruct configfs_attribute *attr;\n\tstruct configfs_buffer *buffer;\n\tint error;\n\n\terror = -ENOMEM;\n\tbuffer = kzalloc(sizeof(struct configfs_buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\tgoto out;\n\n\terror = -ENOENT;\n\tdown_read(&frag->frag_sem);\n\tif (unlikely(frag->frag_dead))\n\t\tgoto out_free_buffer;\n\n\terror = -EINVAL;\n\tbuffer->item = to_item(dentry->d_parent);\n\tif (!buffer->item)\n\t\tgoto out_free_buffer;\n\n\tattr = to_attr(dentry);\n\tif (!attr)\n\t\tgoto out_free_buffer;\n\n\tif (type & CONFIGFS_ITEM_BIN_ATTR) {\n\t\tbuffer->bin_attr = to_bin_attr(dentry);\n\t\tbuffer->cb_max_size = buffer->bin_attr->cb_max_size;\n\t} else {\n\t\tbuffer->attr = attr;\n\t}\n\n\tbuffer->owner = attr->ca_owner;\n\t \n\terror = -ENODEV;\n\tif (!try_module_get(buffer->owner))\n\t\tgoto out_free_buffer;\n\n\terror = -EACCES;\n\tif (!buffer->item->ci_type)\n\t\tgoto out_put_module;\n\n\tbuffer->ops = buffer->item->ci_type->ct_item_ops;\n\n\t \n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(inode->i_mode & S_IWUGO))\n\t\t\tgoto out_put_module;\n\t\tif ((type & CONFIGFS_ITEM_ATTR) && !attr->store)\n\t\t\tgoto out_put_module;\n\t\tif ((type & CONFIGFS_ITEM_BIN_ATTR) && !buffer->bin_attr->write)\n\t\t\tgoto out_put_module;\n\t}\n\n\t \n\tif (file->f_mode & FMODE_READ) {\n\t\tif (!(inode->i_mode & S_IRUGO))\n\t\t\tgoto out_put_module;\n\t\tif ((type & CONFIGFS_ITEM_ATTR) && !attr->show)\n\t\t\tgoto out_put_module;\n\t\tif ((type & CONFIGFS_ITEM_BIN_ATTR) && !buffer->bin_attr->read)\n\t\t\tgoto out_put_module;\n\t}\n\n\tmutex_init(&buffer->mutex);\n\tbuffer->needs_read_fill = 1;\n\tbuffer->read_in_progress = false;\n\tbuffer->write_in_progress = false;\n\tfile->private_data = buffer;\n\tup_read(&frag->frag_sem);\n\treturn 0;\n\nout_put_module:\n\tmodule_put(buffer->owner);\nout_free_buffer:\n\tup_read(&frag->frag_sem);\n\tkfree(buffer);\nout:\n\treturn error;\n}\n\nstatic int configfs_release(struct inode *inode, struct file *filp)\n{\n\tstruct configfs_buffer *buffer = filp->private_data;\n\n\tmodule_put(buffer->owner);\n\tif (buffer->page)\n\t\tfree_page((unsigned long)buffer->page);\n\tmutex_destroy(&buffer->mutex);\n\tkfree(buffer);\n\treturn 0;\n}\n\nstatic int configfs_open_file(struct inode *inode, struct file *filp)\n{\n\treturn __configfs_open_file(inode, filp, CONFIGFS_ITEM_ATTR);\n}\n\nstatic int configfs_open_bin_file(struct inode *inode, struct file *filp)\n{\n\treturn __configfs_open_file(inode, filp, CONFIGFS_ITEM_BIN_ATTR);\n}\n\nstatic int configfs_release_bin_file(struct inode *inode, struct file *file)\n{\n\tstruct configfs_buffer *buffer = file->private_data;\n\n\tif (buffer->write_in_progress) {\n\t\tstruct configfs_fragment *frag = to_frag(file);\n\n\t\tdown_read(&frag->frag_sem);\n\t\tif (!frag->frag_dead) {\n\t\t\t \n\t\t\tbuffer->bin_attr->write(buffer->item,\n\t\t\t\t\tbuffer->bin_buffer,\n\t\t\t\t\tbuffer->bin_buffer_size);\n\t\t}\n\t\tup_read(&frag->frag_sem);\n\t}\n\n\tvfree(buffer->bin_buffer);\n\n\tconfigfs_release(inode, file);\n\treturn 0;\n}\n\n\nconst struct file_operations configfs_file_operations = {\n\t.read_iter\t= configfs_read_iter,\n\t.write_iter\t= configfs_write_iter,\n\t.llseek\t\t= generic_file_llseek,\n\t.open\t\t= configfs_open_file,\n\t.release\t= configfs_release,\n};\n\nconst struct file_operations configfs_bin_file_operations = {\n\t.read_iter\t= configfs_bin_read_iter,\n\t.write_iter\t= configfs_bin_write_iter,\n\t.llseek\t\t= NULL,\t\t \n\t.open\t\t= configfs_open_bin_file,\n\t.release\t= configfs_release_bin_file,\n};\n\n \n\nint configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_ATTR, parent_sd->s_frag);\n\tinode_unlock(d_inode(dir));\n\n\treturn error;\n}\n\n \n\nint configfs_create_bin_file(struct config_item *item,\n\t\tconst struct configfs_bin_attribute *bin_attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (bin_attr->cb_attr.ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tinode_lock_nested(dir->d_inode, I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) bin_attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_BIN_ATTR, parent_sd->s_frag);\n\tinode_unlock(dir->d_inode);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}