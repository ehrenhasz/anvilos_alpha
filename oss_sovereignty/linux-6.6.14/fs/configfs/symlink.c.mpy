{
  "module_name": "symlink.c",
  "hash_id": "8f6670d76fd4ae16ad73ef5d21481c885296ac59c00aae3a1ed9e76ba6187294",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/symlink.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#include <linux/configfs.h>\n#include \"configfs_internal.h\"\n\n \nDEFINE_MUTEX(configfs_symlink_mutex);\n\nstatic int item_depth(struct config_item * item)\n{\n\tstruct config_item * p = item;\n\tint depth = 0;\n\tdo { depth++; } while ((p = p->ci_parent) && !configfs_is_root(p));\n\treturn depth;\n}\n\nstatic int item_path_length(struct config_item * item)\n{\n\tstruct config_item * p = item;\n\tint length = 1;\n\tdo {\n\t\tlength += strlen(config_item_name(p)) + 1;\n\t\tp = p->ci_parent;\n\t} while (p && !configfs_is_root(p));\n\treturn length;\n}\n\nstatic void fill_item_path(struct config_item * item, char * buffer, int length)\n{\n\tstruct config_item * p;\n\n\t--length;\n\tfor (p = item; p && !configfs_is_root(p); p = p->ci_parent) {\n\t\tint cur = strlen(config_item_name(p));\n\n\t\t \n\t\tlength -= cur;\n\t\tmemcpy(buffer + length, config_item_name(p), cur);\n\t\t*(buffer + --length) = '/';\n\t}\n}\n\nstatic int configfs_get_target_path(struct config_item *item,\n\t\tstruct config_item *target, char *path)\n{\n\tint depth, size;\n\tchar *s;\n\n\tdepth = item_depth(item);\n\tsize = item_path_length(target) + depth * 3 - 1;\n\tif (size > PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tpr_debug(\"%s: depth = %d, size = %d\\n\", __func__, depth, size);\n\n\tfor (s = path; depth--; s += 3)\n\t\tstrcpy(s,\"../\");\n\n\tfill_item_path(target, path, size);\n\tpr_debug(\"%s: path = '%s'\\n\", __func__, path);\n\treturn 0;\n}\n\nstatic int create_link(struct config_item *parent_item,\n\t\t       struct config_item *item,\n\t\t       struct dentry *dentry)\n{\n\tstruct configfs_dirent *target_sd = item->ci_dentry->d_fsdata;\n\tchar *body;\n\tint ret;\n\n\tif (!configfs_dirent_is_ready(target_sd))\n\t\treturn -ENOENT;\n\n\tbody = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!body)\n\t\treturn -ENOMEM;\n\n\tconfigfs_get(target_sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (target_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_put(target_sd);\n\t\tkfree(body);\n\t\treturn -ENOENT;\n\t}\n\ttarget_sd->s_links++;\n\tspin_unlock(&configfs_dirent_lock);\n\tret = configfs_get_target_path(parent_item, item, body);\n\tif (!ret)\n\t\tret = configfs_create_link(target_sd, parent_item->ci_dentry,\n\t\t\t\t\t   dentry, body);\n\tif (ret) {\n\t\tspin_lock(&configfs_dirent_lock);\n\t\ttarget_sd->s_links--;\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_put(target_sd);\n\t\tkfree(body);\n\t}\n\treturn ret;\n}\n\n\nstatic int get_target(const char *symname, struct path *path,\n\t\t      struct config_item **target, struct super_block *sb)\n{\n\tint ret;\n\n\tret = kern_path(symname, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, path);\n\tif (!ret) {\n\t\tif (path->dentry->d_sb == sb) {\n\t\t\t*target = configfs_get_config_item(path->dentry);\n\t\t\tif (!*target) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tpath_put(path);\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t\tpath_put(path);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint configfs_symlink(struct mnt_idmap *idmap, struct inode *dir,\n\t\t     struct dentry *dentry, const char *symname)\n{\n\tint ret;\n\tstruct path path;\n\tstruct configfs_dirent *sd;\n\tstruct config_item *parent_item;\n\tstruct config_item *target_item = NULL;\n\tconst struct config_item_type *type;\n\n\tsd = dentry->d_parent->d_fsdata;\n\t \n\tif (!configfs_dirent_is_ready(sd))\n\t\treturn -ENOENT;\n\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\n\tret = -EPERM;\n\tif (!type || !type->ct_item_ops ||\n\t    !type->ct_item_ops->allow_link)\n\t\tgoto out_put;\n\n\t \n\tinode_unlock(dir);\n\tret = get_target(symname, &path, &target_item, dentry->d_sb);\n\tinode_lock(dir);\n\tif (ret)\n\t\tgoto out_put;\n\n\tif (dentry->d_inode || d_unhashed(dentry))\n\t\tret = -EEXIST;\n\telse\n\t\tret = inode_permission(&nop_mnt_idmap, dir,\n\t\t\t\t       MAY_WRITE | MAY_EXEC);\n\tif (!ret)\n\t\tret = type->ct_item_ops->allow_link(parent_item, target_item);\n\tif (!ret) {\n\t\tmutex_lock(&configfs_symlink_mutex);\n\t\tret = create_link(parent_item, target_item, dentry);\n\t\tmutex_unlock(&configfs_symlink_mutex);\n\t\tif (ret && type->ct_item_ops->drop_link)\n\t\t\ttype->ct_item_ops->drop_link(parent_item,\n\t\t\t\t\t\t     target_item);\n\t}\n\n\tconfig_item_put(target_item);\n\tpath_put(&path);\n\nout_put:\n\tconfig_item_put(parent_item);\n\treturn ret;\n}\n\nint configfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct configfs_dirent *sd = dentry->d_fsdata, *target_sd;\n\tstruct config_item *parent_item;\n\tconst struct config_item_type *type;\n\tint ret;\n\n\tret = -EPERM;   \n\tif (!(sd->s_type & CONFIGFS_ITEM_LINK))\n\t\tgoto out;\n\n\ttarget_sd = sd->s_element;\n\n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&sd->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tconfigfs_drop_dentry(sd, dentry->d_parent);\n\tdput(dentry);\n\tconfigfs_put(sd);\n\n\t \n\tif (type && type->ct_item_ops &&\n\t    type->ct_item_ops->drop_link)\n\t\ttype->ct_item_ops->drop_link(parent_item,\n\t\t\t\t\t       target_sd->s_element);\n\n\tspin_lock(&configfs_dirent_lock);\n\ttarget_sd->s_links--;\n\tspin_unlock(&configfs_dirent_lock);\n\tconfigfs_put(target_sd);\n\n\tconfig_item_put(parent_item);\n\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nconst struct inode_operations configfs_symlink_inode_operations = {\n\t.get_link = simple_get_link,\n\t.setattr = configfs_setattr,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}