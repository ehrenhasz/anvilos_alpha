{
  "module_name": "item.c",
  "hash_id": "c407230e2627d15f96fa3f259cede4b1cc158c4242139ed907c214f410218a46",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/item.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\n#include <linux/configfs.h>\n\n\nstatic inline struct config_item *to_item(struct list_head *entry)\n{\n\treturn container_of(entry, struct config_item, ci_entry);\n}\n\n \nstatic void config_item_release(struct kref *kref);\n\n \nstatic void config_item_init(struct config_item *item)\n{\n\tkref_init(&item->ci_kref);\n\tINIT_LIST_HEAD(&item->ci_entry);\n}\n\n \nint config_item_set_name(struct config_item *item, const char *fmt, ...)\n{\n\tint limit = CONFIGFS_ITEM_NAME_LEN;\n\tint need;\n\tva_list args;\n\tchar *name;\n\n\t \n\tva_start(args, fmt);\n\tneed = vsnprintf(item->ci_namebuf, limit, fmt, args);\n\tva_end(args);\n\tif (need < limit)\n\t\tname = item->ci_namebuf;\n\telse {\n\t\tva_start(args, fmt);\n\t\tname = kvasprintf(GFP_KERNEL, fmt, args);\n\t\tva_end(args);\n\t\tif (!name)\n\t\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (item->ci_name && item->ci_name != item->ci_namebuf)\n\t\tkfree(item->ci_name);\n\n\t \n\titem->ci_name = name;\n\treturn 0;\n}\nEXPORT_SYMBOL(config_item_set_name);\n\nvoid config_item_init_type_name(struct config_item *item,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct config_item_type *type)\n{\n\tconfig_item_set_name(item, \"%s\", name);\n\titem->ci_type = type;\n\tconfig_item_init(item);\n}\nEXPORT_SYMBOL(config_item_init_type_name);\n\nvoid config_group_init_type_name(struct config_group *group, const char *name,\n\t\t\t const struct config_item_type *type)\n{\n\tconfig_item_set_name(&group->cg_item, \"%s\", name);\n\tgroup->cg_item.ci_type = type;\n\tconfig_group_init(group);\n}\nEXPORT_SYMBOL(config_group_init_type_name);\n\nstruct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}\nEXPORT_SYMBOL(config_item_get);\n\nstruct config_item *config_item_get_unless_zero(struct config_item *item)\n{\n\tif (item && kref_get_unless_zero(&item->ci_kref))\n\t\treturn item;\n\treturn NULL;\n}\nEXPORT_SYMBOL(config_item_get_unless_zero);\n\nstatic void config_item_cleanup(struct config_item *item)\n{\n\tconst struct config_item_type *t = item->ci_type;\n\tstruct config_group *s = item->ci_group;\n\tstruct config_item *parent = item->ci_parent;\n\n\tpr_debug(\"config_item %s: cleaning up\\n\", config_item_name(item));\n\tif (item->ci_name != item->ci_namebuf)\n\t\tkfree(item->ci_name);\n\titem->ci_name = NULL;\n\tif (t && t->ct_item_ops && t->ct_item_ops->release)\n\t\tt->ct_item_ops->release(item);\n\tif (s)\n\t\tconfig_group_put(s);\n\tif (parent)\n\t\tconfig_item_put(parent);\n}\n\nstatic void config_item_release(struct kref *kref)\n{\n\tconfig_item_cleanup(container_of(kref, struct config_item, ci_kref));\n}\n\n \nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}\nEXPORT_SYMBOL(config_item_put);\n\n \nvoid config_group_init(struct config_group *group)\n{\n\tconfig_item_init(&group->cg_item);\n\tINIT_LIST_HEAD(&group->cg_children);\n\tINIT_LIST_HEAD(&group->default_groups);\n}\nEXPORT_SYMBOL(config_group_init);\n\n \nstruct config_item *config_group_find_item(struct config_group *group,\n\t\t\t\t\t   const char *name)\n{\n\tstruct list_head *entry;\n\tstruct config_item *ret = NULL;\n\n\tlist_for_each(entry, &group->cg_children) {\n\t\tstruct config_item *item = to_item(entry);\n\t\tif (config_item_name(item) &&\n\t\t    !strcmp(config_item_name(item), name)) {\n\t\t\tret = config_item_get(item);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(config_group_find_item);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}