{
  "module_name": "dir.c",
  "hash_id": "1e186ef91d6caf00d8b65e7c3eb169b27f29bf0f3a8a72eae3839c070e3badd7",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/dir.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\n#include <linux/configfs.h>\n#include \"configfs_internal.h\"\n\n \nDEFINE_SPINLOCK(configfs_dirent_lock);\n\n \nstatic DEFINE_MUTEX(configfs_subsystem_mutex);\n\nstatic void configfs_d_iput(struct dentry * dentry,\n\t\t\t    struct inode * inode)\n{\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\n\tif (sd) {\n\t\t \n\t\tspin_lock(&configfs_dirent_lock);\n\t\t \n\t\tif (sd->s_dentry == dentry)\n\t\t\tsd->s_dentry = NULL;\n\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_put(sd);\n\t}\n\tiput(inode);\n}\n\nconst struct dentry_operations configfs_dentry_ops = {\n\t.d_iput\t\t= configfs_d_iput,\n\t.d_delete\t= always_delete_dentry,\n};\n\n#ifdef CONFIG_LOCKDEP\n\n \n\nstatic void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n\tsd->s_depth = -1;\n}\n\nstatic void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n\tint parent_depth = parent_sd->s_depth;\n\n\tif (parent_depth >= 0)\n\t\tsd->s_depth = parent_depth + 1;\n}\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n\t \n\t \n\tif (sd->s_depth == -1)\n\t\t \n\t\tsd->s_depth = 0;\n}\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n\t \n\tsd->s_depth = -1;\n}\n\n#else  \n\nstatic void configfs_init_dirent_depth(struct configfs_dirent *sd)\n{\n}\n\nstatic void configfs_set_dir_dirent_depth(struct configfs_dirent *parent_sd,\n\t\t\t\t\t  struct configfs_dirent *sd)\n{\n}\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_before_populate(struct configfs_dirent *sd)\n{\n}\n\nstatic void\nconfigfs_adjust_dir_dirent_depth_after_populate(struct configfs_dirent *sd)\n{\n}\n\n#endif  \n\nstatic struct configfs_fragment *new_fragment(void)\n{\n\tstruct configfs_fragment *p;\n\n\tp = kmalloc(sizeof(struct configfs_fragment), GFP_KERNEL);\n\tif (p) {\n\t\tatomic_set(&p->frag_count, 1);\n\t\tinit_rwsem(&p->frag_sem);\n\t\tp->frag_dead = false;\n\t}\n\treturn p;\n}\n\nvoid put_fragment(struct configfs_fragment *frag)\n{\n\tif (frag && atomic_dec_and_test(&frag->frag_count))\n\t\tkfree(frag);\n}\n\nstruct configfs_fragment *get_fragment(struct configfs_fragment *frag)\n{\n\tif (likely(frag))\n\t\tatomic_inc(&frag->frag_count);\n\treturn frag;\n}\n\n \nstatic struct configfs_dirent *configfs_new_dirent(struct configfs_dirent *parent_sd,\n\t\t\t\t\t\t   void *element, int type,\n\t\t\t\t\t\t   struct configfs_fragment *frag)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = kmem_cache_zalloc(configfs_dir_cachep, GFP_KERNEL);\n\tif (!sd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic_set(&sd->s_count, 1);\n\tINIT_LIST_HEAD(&sd->s_children);\n\tsd->s_element = element;\n\tsd->s_type = type;\n\tconfigfs_init_dirent_depth(sd);\n\tspin_lock(&configfs_dirent_lock);\n\tif (parent_sd->s_type & CONFIGFS_USET_DROPPING) {\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tkmem_cache_free(configfs_dir_cachep, sd);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tsd->s_frag = get_fragment(frag);\n\tlist_add(&sd->s_sibling, &parent_sd->s_children);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn sd;\n}\n\n \nstatic int configfs_dirent_exists(struct configfs_dirent *parent_sd,\n\t\t\t\t  const unsigned char *new)\n{\n\tstruct configfs_dirent * sd;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (sd->s_element) {\n\t\t\tconst unsigned char *existing = configfs_get_name(sd);\n\t\t\tif (strcmp(existing, new))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type, struct configfs_fragment *frag)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type, frag);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}\n\nstatic void configfs_remove_dirent(struct dentry *dentry)\n{\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\n\tif (!sd)\n\t\treturn;\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&sd->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tconfigfs_put(sd);\n}\n\n \n\nstatic int configfs_create_dir(struct config_item *item, struct dentry *dentry,\n\t\t\t\tstruct configfs_fragment *frag)\n{\n\tint error;\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct dentry *p = dentry->d_parent;\n\tstruct inode *inode;\n\n\tBUG_ON(!item);\n\n\terror = configfs_dirent_exists(p->d_fsdata, dentry->d_name.name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = configfs_make_dirent(p->d_fsdata, dentry, item, mode,\n\t\t\t\t     CONFIGFS_DIR | CONFIGFS_USET_CREATING,\n\t\t\t\t     frag);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tconfigfs_set_dir_dirent_depth(p->d_fsdata, dentry->d_fsdata);\n\tinode = configfs_create(dentry, mode);\n\tif (IS_ERR(inode))\n\t\tgoto out_remove;\n\n\tinode->i_op = &configfs_dir_inode_operations;\n\tinode->i_fop = &configfs_dir_operations;\n\t \n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\t \n\tdget(dentry);   \n\tinc_nlink(d_inode(p));\n\titem->ci_dentry = dentry;\n\treturn 0;\n\nout_remove:\n\tconfigfs_put(dentry->d_fsdata);\n\tconfigfs_remove_dirent(dentry);\n\treturn PTR_ERR(inode);\n}\n\n \nstatic void configfs_dir_set_ready(struct configfs_dirent *sd)\n{\n\tstruct configfs_dirent *child_sd;\n\n\tsd->s_type &= ~CONFIGFS_USET_CREATING;\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling)\n\t\tif (child_sd->s_type & CONFIGFS_USET_CREATING)\n\t\t\tconfigfs_dir_set_ready(child_sd);\n}\n\n \nint configfs_dirent_is_ready(struct configfs_dirent *sd)\n{\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\tret = !(sd->s_type & CONFIGFS_USET_CREATING);\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}\n\nint configfs_create_link(struct configfs_dirent *target, struct dentry *parent,\n\t\tstruct dentry *dentry, char *body)\n{\n\tint err = 0;\n\tumode_t mode = S_IFLNK | S_IRWXUGO;\n\tstruct configfs_dirent *p = parent->d_fsdata;\n\tstruct inode *inode;\n\n\terr = configfs_make_dirent(p, dentry, target, mode, CONFIGFS_ITEM_LINK,\n\t\t\tp->s_frag);\n\tif (err)\n\t\treturn err;\n\n\tinode = configfs_create(dentry, mode);\n\tif (IS_ERR(inode))\n\t\tgoto out_remove;\n\n\tinode->i_link = body;\n\tinode->i_op = &configfs_symlink_inode_operations;\n\td_instantiate(dentry, inode);\n\tdget(dentry);   \n\treturn 0;\n\nout_remove:\n\tconfigfs_put(dentry->d_fsdata);\n\tconfigfs_remove_dirent(dentry);\n\treturn PTR_ERR(inode);\n}\n\nstatic void remove_dir(struct dentry * d)\n{\n\tstruct dentry * parent = dget(d->d_parent);\n\n\tconfigfs_remove_dirent(d);\n\n\tif (d_really_is_positive(d))\n\t\tsimple_rmdir(d_inode(parent),d);\n\n\tpr_debug(\" o %pd removing done (%d)\\n\", d, d_count(d));\n\n\tdput(parent);\n}\n\n \n\nstatic void configfs_remove_dir(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\n\tif (!dentry)\n\t\treturn;\n\n\tremove_dir(dentry);\n\t \n\tdput(dentry);\n}\n\nstatic struct dentry * configfs_lookup(struct inode *dir,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       unsigned int flags)\n{\n\tstruct configfs_dirent * parent_sd = dentry->d_parent->d_fsdata;\n\tstruct configfs_dirent * sd;\n\tstruct inode *inode = NULL;\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\t \n\tif (!configfs_dirent_is_ready(parent_sd))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock(&configfs_dirent_lock);\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif ((sd->s_type & CONFIGFS_NOT_PINNED) &&\n\t\t    !strcmp(configfs_get_name(sd), dentry->d_name.name)) {\n\t\t\tstruct configfs_attribute *attr = sd->s_element;\n\t\t\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\n\t\t\tdentry->d_fsdata = configfs_get(sd);\n\t\t\tsd->s_dentry = dentry;\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\n\t\t\tinode = configfs_create(dentry, mode);\n\t\t\tif (IS_ERR(inode)) {\n\t\t\t\tconfigfs_put(sd);\n\t\t\t\treturn ERR_CAST(inode);\n\t\t\t}\n\t\t\tif (sd->s_type & CONFIGFS_ITEM_BIN_ATTR) {\n\t\t\t\tinode->i_size = 0;\n\t\t\t\tinode->i_fop = &configfs_bin_file_operations;\n\t\t\t} else {\n\t\t\t\tinode->i_size = PAGE_SIZE;\n\t\t\t\tinode->i_fop = &configfs_file_operations;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\tspin_unlock(&configfs_dirent_lock);\ndone:\n\td_add(dentry, inode);\n\treturn NULL;\n}\n\n \nstatic int configfs_detach_prep(struct dentry *dentry, struct dentry **wait)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\tint ret;\n\n\t \n\tparent_sd->s_type |= CONFIGFS_USET_DROPPING;\n\n\tret = -EBUSY;\n\tif (parent_sd->s_links)\n\t\tgoto out;\n\n\tret = 0;\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    (sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT) {\n\t\t\t \n\t\t\tif (sd->s_type & CONFIGFS_USET_IN_MKDIR) {\n\t\t\t\tif (wait)\n\t\t\t\t\t*wait= dget(sd->s_dentry);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = configfs_detach_prep(sd->s_dentry, wait);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\tret = -ENOTEMPTY;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic void configfs_detach_rollback(struct dentry *dentry)\n{\n\tstruct configfs_dirent *parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *sd;\n\n\tparent_sd->s_type &= ~CONFIGFS_USET_DROPPING;\n\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling)\n\t\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\t\tconfigfs_detach_rollback(sd->s_dentry);\n}\n\nstatic void detach_attrs(struct config_item * item)\n{\n\tstruct dentry * dentry = dget(item->ci_dentry);\n\tstruct configfs_dirent * parent_sd;\n\tstruct configfs_dirent * sd, * tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tpr_debug(\"configfs %s: dropping attrs for  dir\\n\",\n\t\t dentry->d_name.name);\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element || !(sd->s_type & CONFIGFS_NOT_PINNED))\n\t\t\tcontinue;\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_del_init(&sd->s_sibling);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfigfs_drop_dentry(sd, dentry);\n\t\tconfigfs_put(sd);\n\t}\n\n\t \n\tdput(dentry);\n}\n\nstatic int populate_attrs(struct config_item *item)\n{\n\tconst struct config_item_type *t = item->ci_type;\n\tstruct configfs_attribute *attr;\n\tstruct configfs_bin_attribute *bin_attr;\n\tint error = 0;\n\tint i;\n\n\tif (!t)\n\t\treturn -EINVAL;\n\tif (t->ct_attrs) {\n\t\tfor (i = 0; (attr = t->ct_attrs[i]) != NULL; i++) {\n\t\t\tif ((error = configfs_create_file(item, attr)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (t->ct_bin_attrs) {\n\t\tfor (i = 0; (bin_attr = t->ct_bin_attrs[i]) != NULL; i++) {\n\t\t\terror = configfs_create_bin_file(item, bin_attr);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tdetach_attrs(item);\n\n\treturn error;\n}\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry,\n\t\t\t\t struct configfs_fragment *frag);\nstatic void configfs_detach_group(struct config_item *item);\n\nstatic void detach_groups(struct config_group *group)\n{\n\tstruct dentry * dentry = dget(group->cg_item.ci_dentry);\n\tstruct dentry *child;\n\tstruct configfs_dirent *parent_sd;\n\tstruct configfs_dirent *sd, *tmp;\n\n\tif (!dentry)\n\t\treturn;\n\n\tparent_sd = dentry->d_fsdata;\n\tlist_for_each_entry_safe(sd, tmp, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element ||\n\t\t    !(sd->s_type & CONFIGFS_USET_DEFAULT))\n\t\t\tcontinue;\n\n\t\tchild = sd->s_dentry;\n\n\t\tinode_lock(d_inode(child));\n\n\t\tconfigfs_detach_group(sd->s_element);\n\t\td_inode(child)->i_flags |= S_DEAD;\n\t\tdont_mount(child);\n\n\t\tinode_unlock(d_inode(child));\n\n\t\td_delete(child);\n\t\tdput(child);\n\t}\n\n\t \n\tdput(dentry);\n}\n\n \nstatic int create_default_group(struct config_group *parent_group,\n\t\t\t\tstruct config_group *group,\n\t\t\t\tstruct configfs_fragment *frag)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\t \n\tstruct dentry *child, *parent = parent_group->cg_item.ci_dentry;\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tret = -ENOMEM;\n\tchild = d_alloc_name(parent, group->cg_item.ci_name);\n\tif (child) {\n\t\td_add(child, NULL);\n\n\t\tret = configfs_attach_group(&parent_group->cg_item,\n\t\t\t\t\t    &group->cg_item, child, frag);\n\t\tif (!ret) {\n\t\t\tsd = child->d_fsdata;\n\t\t\tsd->s_type |= CONFIGFS_USET_DEFAULT;\n\t\t} else {\n\t\t\tBUG_ON(d_inode(child));\n\t\t\td_drop(child);\n\t\t\tdput(child);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int populate_groups(struct config_group *group,\n\t\t\t   struct configfs_fragment *frag)\n{\n\tstruct config_group *new_group;\n\tint ret = 0;\n\n\tlist_for_each_entry(new_group, &group->default_groups, group_entry) {\n\t\tret = create_default_group(group, new_group, frag);\n\t\tif (ret) {\n\t\t\tdetach_groups(group);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid configfs_remove_default_groups(struct config_group *group)\n{\n\tstruct config_group *g, *n;\n\n\tlist_for_each_entry_safe(g, n, &group->default_groups, group_entry) {\n\t\tlist_del(&g->group_entry);\n\t\tconfig_item_put(&g->cg_item);\n\t}\n}\nEXPORT_SYMBOL(configfs_remove_default_groups);\n\n \n\nstatic void unlink_obj(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tgroup = item->ci_group;\n\tif (group) {\n\t\tlist_del_init(&item->ci_entry);\n\n\t\titem->ci_group = NULL;\n\t\titem->ci_parent = NULL;\n\n\t\t \n\t\tconfig_item_put(item);\n\n\t\t \n\t\tconfig_group_put(group);\n\t}\n}\n\nstatic void link_obj(struct config_item *parent_item, struct config_item *item)\n{\n\t \n\titem->ci_parent = parent_item;\n\n\t \n\titem->ci_group = config_group_get(to_config_group(parent_item));\n\tlist_add_tail(&item->ci_entry, &item->ci_group->cg_children);\n\n\t \n\tconfig_item_get(item);\n}\n\nstatic void unlink_group(struct config_group *group)\n{\n\tstruct config_group *new_group;\n\n\tlist_for_each_entry(new_group, &group->default_groups, group_entry)\n\t\tunlink_group(new_group);\n\n\tgroup->cg_subsys = NULL;\n\tunlink_obj(&group->cg_item);\n}\n\nstatic void link_group(struct config_group *parent_group, struct config_group *group)\n{\n\tstruct config_group *new_group;\n\tstruct configfs_subsystem *subsys = NULL;  \n\n\tlink_obj(&parent_group->cg_item, &group->cg_item);\n\n\tif (parent_group->cg_subsys)\n\t\tsubsys = parent_group->cg_subsys;\n\telse if (configfs_is_root(&parent_group->cg_item))\n\t\tsubsys = to_configfs_subsystem(group);\n\telse\n\t\tBUG();\n\tgroup->cg_subsys = subsys;\n\n\tlist_for_each_entry(new_group, &group->default_groups, group_entry)\n\t\tlink_group(group, new_group);\n}\n\n \nstatic int configfs_attach_item(struct config_item *parent_item,\n\t\t\t\tstruct config_item *item,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tstruct configfs_fragment *frag)\n{\n\tint ret;\n\n\tret = configfs_create_dir(item, dentry, frag);\n\tif (!ret) {\n\t\tret = populate_attrs(item);\n\t\tif (ret) {\n\t\t\t \n\t\t\tinode_lock(d_inode(dentry));\n\t\t\tconfigfs_remove_dir(item);\n\t\t\td_inode(dentry)->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t\tinode_unlock(d_inode(dentry));\n\t\t\td_delete(dentry);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic void configfs_detach_item(struct config_item *item)\n{\n\tdetach_attrs(item);\n\tconfigfs_remove_dir(item);\n}\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry,\n\t\t\t\t struct configfs_fragment *frag)\n{\n\tint ret;\n\tstruct configfs_dirent *sd;\n\n\tret = configfs_attach_item(parent_item, item, dentry, frag);\n\tif (!ret) {\n\t\tsd = dentry->d_fsdata;\n\t\tsd->s_type |= CONFIGFS_USET_DIR;\n\n\t\t \n\t\tinode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);\n\t\tconfigfs_adjust_dir_dirent_depth_before_populate(sd);\n\t\tret = populate_groups(to_config_group(item), frag);\n\t\tif (ret) {\n\t\t\tconfigfs_detach_item(item);\n\t\t\td_inode(dentry)->i_flags |= S_DEAD;\n\t\t\tdont_mount(dentry);\n\t\t}\n\t\tconfigfs_adjust_dir_dirent_depth_after_populate(sd);\n\t\tinode_unlock(d_inode(dentry));\n\t\tif (ret)\n\t\t\td_delete(dentry);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void configfs_detach_group(struct config_item *item)\n{\n\tdetach_groups(to_config_group(item));\n\tconfigfs_detach_item(item);\n}\n\n \nstatic void client_disconnect_notify(struct config_item *parent_item,\n\t\t\t\t     struct config_item *item)\n{\n\tconst struct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\tif (type->ct_group_ops && type->ct_group_ops->disconnect_notify)\n\t\ttype->ct_group_ops->disconnect_notify(to_config_group(parent_item),\n\t\t\t\t\t\t      item);\n}\n\n \nstatic void client_drop_item(struct config_item *parent_item,\n\t\t\t     struct config_item *item)\n{\n\tconst struct config_item_type *type;\n\n\ttype = parent_item->ci_type;\n\tBUG_ON(!type);\n\n\t \n\tif (type->ct_group_ops && type->ct_group_ops->drop_item)\n\t\ttype->ct_group_ops->drop_item(to_config_group(parent_item),\n\t\t\t\t\t      item);\n\telse\n\t\tconfig_item_put(item);\n}\n\n#ifdef DEBUG\nstatic void configfs_dump_one(struct configfs_dirent *sd, int level)\n{\n\tpr_info(\"%*s\\\"%s\\\":\\n\", level, \" \", configfs_get_name(sd));\n\n#define type_print(_type) if (sd->s_type & _type) pr_info(\"%*s %s\\n\", level, \" \", #_type);\n\ttype_print(CONFIGFS_ROOT);\n\ttype_print(CONFIGFS_DIR);\n\ttype_print(CONFIGFS_ITEM_ATTR);\n\ttype_print(CONFIGFS_ITEM_LINK);\n\ttype_print(CONFIGFS_USET_DIR);\n\ttype_print(CONFIGFS_USET_DEFAULT);\n\ttype_print(CONFIGFS_USET_DROPPING);\n#undef type_print\n}\n\nstatic int configfs_dump(struct configfs_dirent *sd, int level)\n{\n\tstruct configfs_dirent *child_sd;\n\tint ret = 0;\n\n\tconfigfs_dump_one(sd, level);\n\n\tif (!(sd->s_type & (CONFIGFS_DIR|CONFIGFS_ROOT)))\n\t\treturn 0;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tret = configfs_dump(child_sd, level + 2);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#endif\n\n\n \n\n \nstatic int configfs_depend_prep(struct dentry *origin,\n\t\t\t\tstruct config_item *target)\n{\n\tstruct configfs_dirent *child_sd, *sd;\n\tint ret = 0;\n\n\tBUG_ON(!origin || !origin->d_fsdata);\n\tsd = origin->d_fsdata;\n\n\tif (sd->s_element == target)   \n\t\tgoto out;\n\n\tlist_for_each_entry(child_sd, &sd->s_children, s_sibling) {\n\t\tif ((child_sd->s_type & CONFIGFS_DIR) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_DROPPING) &&\n\t\t    !(child_sd->s_type & CONFIGFS_USET_CREATING)) {\n\t\t\tret = configfs_depend_prep(child_sd->s_dentry,\n\t\t\t\t\t\t   target);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;   \n\t\t}\n\t}\n\n\t \n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}\n\nstatic int configfs_do_depend_item(struct dentry *subsys_dentry,\n\t\t\t\t   struct config_item *target)\n{\n\tstruct configfs_dirent *p;\n\tint ret;\n\n\tspin_lock(&configfs_dirent_lock);\n\t \n\tret = configfs_depend_prep(subsys_dentry, target);\n\tif (ret)\n\t\tgoto out_unlock_dirent_lock;\n\n\t \n\tp = target->ci_dentry->d_fsdata;\n\tp->s_dependent_count += 1;\n\nout_unlock_dirent_lock:\n\tspin_unlock(&configfs_dirent_lock);\n\n\treturn ret;\n}\n\nstatic inline struct configfs_dirent *\nconfigfs_find_subsys_dentry(struct configfs_dirent *root_sd,\n\t\t\t    struct config_item *subsys_item)\n{\n\tstruct configfs_dirent *p;\n\tstruct configfs_dirent *ret = NULL;\n\n\tlist_for_each_entry(p, &root_sd->s_children, s_sibling) {\n\t\tif (p->s_type & CONFIGFS_DIR &&\n\t\t    p->s_element == subsys_item) {\n\t\t\tret = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint configfs_depend_item(struct configfs_subsystem *subsys,\n\t\t\t struct config_item *target)\n{\n\tint ret;\n\tstruct configfs_dirent *subsys_sd;\n\tstruct config_item *s_item = &subsys->su_group.cg_item;\n\tstruct dentry *root;\n\n\t \n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\t \n\tinode_lock(d_inode(root));\n\n\tsubsys_sd = configfs_find_subsys_dentry(root->d_fsdata, s_item);\n\tif (!subsys_sd) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock_fs;\n\t}\n\n\t \n\tret = configfs_do_depend_item(subsys_sd->s_dentry, target);\n\nout_unlock_fs:\n\tinode_unlock(d_inode(root));\n\n\t \n\tconfigfs_release_fs();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(configfs_depend_item);\n\n \nvoid configfs_undepend_item(struct config_item *target)\n{\n\tstruct configfs_dirent *sd;\n\n\t \n\tspin_lock(&configfs_dirent_lock);\n\n\tsd = target->ci_dentry->d_fsdata;\n\tBUG_ON(sd->s_dependent_count < 1);\n\n\tsd->s_dependent_count -= 1;\n\n\t \n\tspin_unlock(&configfs_dirent_lock);\n}\nEXPORT_SYMBOL(configfs_undepend_item);\n\n \nint configfs_depend_item_unlocked(struct configfs_subsystem *caller_subsys,\n\t\t\t\t  struct config_item *target)\n{\n\tstruct configfs_subsystem *target_subsys;\n\tstruct config_group *root, *parent;\n\tstruct configfs_dirent *subsys_sd;\n\tint ret = -ENOENT;\n\n\t \n\tif (configfs_is_root(target))\n\t\treturn -EINVAL;\n\n\tparent = target->ci_group;\n\t \n\tif (configfs_is_root(&parent->cg_item)) {\n\t\ttarget_subsys = to_configfs_subsystem(to_config_group(target));\n\t\troot = parent;\n\t} else {\n\t\ttarget_subsys = parent->cg_subsys;\n\t\t \n\t\tfor (root = parent; !configfs_is_root(&root->cg_item);\n\t\t     root = root->cg_item.ci_group)\n\t\t\t;\n\t}\n\n\tif (target_subsys != caller_subsys) {\n\t\t \n\t\tinode_lock(d_inode(root->cg_item.ci_dentry));\n\n\t\t \n\t\tsubsys_sd = configfs_find_subsys_dentry(\n\t\t\t\troot->cg_item.ci_dentry->d_fsdata,\n\t\t\t\t&target_subsys->su_group.cg_item);\n\t\tif (!subsys_sd)\n\t\t\tgoto out_root_unlock;\n\t} else {\n\t\tsubsys_sd = target_subsys->su_group.cg_item.ci_dentry->d_fsdata;\n\t}\n\n\t \n\tret = configfs_do_depend_item(subsys_sd->s_dentry, target);\n\n\tif (target_subsys != caller_subsys)\nout_root_unlock:\n\t\t \n\t\tinode_unlock(d_inode(root->cg_item.ci_dentry));\n\n\treturn ret;\n}\nEXPORT_SYMBOL(configfs_depend_item_unlocked);\n\nstatic int configfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t  struct dentry *dentry, umode_t mode)\n{\n\tint ret = 0;\n\tint module_got = 0;\n\tstruct config_group *group = NULL;\n\tstruct config_item *item = NULL;\n\tstruct config_item *parent_item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tconst struct config_item_type *type;\n\tstruct module *subsys_owner = NULL, *new_item_owner = NULL;\n\tstruct configfs_fragment *frag;\n\tchar *name;\n\n\tsd = dentry->d_parent->d_fsdata;\n\n\t \n\tif (!configfs_dirent_is_ready(sd)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(sd->s_type & CONFIGFS_USET_DIR)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tfrag = new_fragment();\n\tif (!frag) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\ttype = parent_item->ci_type;\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!type || !type->ct_group_ops ||\n\t    (!type->ct_group_ops->make_group &&\n\t     !type->ct_group_ops->make_item)) {\n\t\tret = -EPERM;   \n\t\tgoto out_put;\n\t}\n\n\t \n\tif (!subsys->su_group.cg_item.ci_type) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\tif (!try_module_get(subsys_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tname = kmalloc(dentry->d_name.len + 1, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_subsys_put;\n\t}\n\n\tsnprintf(name, dentry->d_name.len + 1, \"%s\", dentry->d_name.name);\n\n\tmutex_lock(&subsys->su_mutex);\n\tif (type->ct_group_ops->make_group) {\n\t\tgroup = type->ct_group_ops->make_group(to_config_group(parent_item), name);\n\t\tif (!group)\n\t\t\tgroup = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(group)) {\n\t\t\tlink_group(to_config_group(parent_item), group);\n\t\t\titem = &group->cg_item;\n\t\t} else\n\t\t\tret = PTR_ERR(group);\n\t} else {\n\t\titem = type->ct_group_ops->make_item(to_config_group(parent_item), name);\n\t\tif (!item)\n\t\t\titem = ERR_PTR(-ENOMEM);\n\t\tif (!IS_ERR(item))\n\t\t\tlink_obj(parent_item, item);\n\t\telse\n\t\t\tret = PTR_ERR(item);\n\t}\n\tmutex_unlock(&subsys->su_mutex);\n\n\tkfree(name);\n\tif (ret) {\n\t\t \n\t\tgoto out_subsys_put;\n\t}\n\n\t \n\n\ttype = item->ci_type;\n\tif (!type) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\tnew_item_owner = type->ct_owner;\n\tif (!try_module_get(new_item_owner)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlink;\n\t}\n\n\t \n\tmodule_got = 1;\n\n\t \n\tspin_lock(&configfs_dirent_lock);\n\t \n\tsd->s_type |= CONFIGFS_USET_IN_MKDIR;\n\tspin_unlock(&configfs_dirent_lock);\n\n\tif (group)\n\t\tret = configfs_attach_group(parent_item, item, dentry, frag);\n\telse\n\t\tret = configfs_attach_item(parent_item, item, dentry, frag);\n\n\tspin_lock(&configfs_dirent_lock);\n\tsd->s_type &= ~CONFIGFS_USET_IN_MKDIR;\n\tif (!ret)\n\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\tspin_unlock(&configfs_dirent_lock);\n\nout_unlink:\n\tif (ret) {\n\t\t \n\t\tmutex_lock(&subsys->su_mutex);\n\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tif (group)\n\t\t\tunlink_group(group);\n\t\telse\n\t\t\tunlink_obj(item);\n\t\tclient_drop_item(parent_item, item);\n\n\t\tmutex_unlock(&subsys->su_mutex);\n\n\t\tif (module_got)\n\t\t\tmodule_put(new_item_owner);\n\t}\n\nout_subsys_put:\n\tif (ret)\n\t\tmodule_put(subsys_owner);\n\nout_put:\n\t \n\tconfig_item_put(parent_item);\n\tput_fragment(frag);\n\nout:\n\treturn ret;\n}\n\nstatic int configfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct config_item *parent_item;\n\tstruct config_item *item;\n\tstruct configfs_subsystem *subsys;\n\tstruct configfs_dirent *sd;\n\tstruct configfs_fragment *frag;\n\tstruct module *subsys_owner = NULL, *dead_item_owner = NULL;\n\tint ret;\n\n\tsd = dentry->d_fsdata;\n\tif (sd->s_type & CONFIGFS_USET_DEFAULT)\n\t\treturn -EPERM;\n\n\t \n\tparent_item = configfs_get_config_item(dentry->d_parent);\n\tsubsys = to_config_group(parent_item)->cg_subsys;\n\tBUG_ON(!subsys);\n\n\tif (!parent_item->ci_type) {\n\t\tconfig_item_put(parent_item);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tBUG_ON(!subsys->su_group.cg_item.ci_type);\n\tsubsys_owner = subsys->su_group.cg_item.ci_type->ct_owner;\n\n\t \n\tdo {\n\t\tstruct dentry *wait;\n\n\t\tmutex_lock(&configfs_symlink_mutex);\n\t\tspin_lock(&configfs_dirent_lock);\n\t\t \n\t\tret = sd->s_dependent_count ? -EBUSY : 0;\n\t\tif (!ret) {\n\t\t\tret = configfs_detach_prep(dentry, &wait);\n\t\t\tif (ret)\n\t\t\t\tconfigfs_detach_rollback(dentry);\n\t\t}\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tmutex_unlock(&configfs_symlink_mutex);\n\n\t\tif (ret) {\n\t\t\tif (ret != -EAGAIN) {\n\t\t\t\tconfig_item_put(parent_item);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tinode_lock(d_inode(wait));\n\t\t\tinode_unlock(d_inode(wait));\n\t\t\tdput(wait);\n\t\t}\n\t} while (ret == -EAGAIN);\n\n\tfrag = sd->s_frag;\n\tif (down_write_killable(&frag->frag_sem)) {\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tconfigfs_detach_rollback(dentry);\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tconfig_item_put(parent_item);\n\t\treturn -EINTR;\n\t}\n\tfrag->frag_dead = true;\n\tup_write(&frag->frag_sem);\n\n\t \n\titem = configfs_get_config_item(dentry);\n\n\t \n\tconfig_item_put(parent_item);\n\n\tif (item->ci_type)\n\t\tdead_item_owner = item->ci_type->ct_owner;\n\n\tif (sd->s_type & CONFIGFS_USET_DIR) {\n\t\tconfigfs_detach_group(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_group(to_config_group(item));\n\t} else {\n\t\tconfigfs_detach_item(item);\n\n\t\tmutex_lock(&subsys->su_mutex);\n\t\tclient_disconnect_notify(parent_item, item);\n\t\tunlink_obj(item);\n\t}\n\n\tclient_drop_item(parent_item, item);\n\tmutex_unlock(&subsys->su_mutex);\n\n\t \n\tconfig_item_put(item);\n\n\tmodule_put(dead_item_owner);\n\tmodule_put(subsys_owner);\n\n\treturn 0;\n}\n\nconst struct inode_operations configfs_dir_inode_operations = {\n\t.mkdir\t\t= configfs_mkdir,\n\t.rmdir\t\t= configfs_rmdir,\n\t.symlink\t= configfs_symlink,\n\t.unlink\t\t= configfs_unlink,\n\t.lookup\t\t= configfs_lookup,\n\t.setattr\t= configfs_setattr,\n};\n\nconst struct inode_operations configfs_root_inode_operations = {\n\t.lookup\t\t= configfs_lookup,\n\t.setattr\t= configfs_setattr,\n};\n\nstatic int configfs_dir_open(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tint err;\n\n\tinode_lock(d_inode(dentry));\n\t \n\terr = -ENOENT;\n\tif (configfs_dirent_is_ready(parent_sd)) {\n\t\tfile->private_data = configfs_new_dirent(parent_sd, NULL, 0, NULL);\n\t\tif (IS_ERR(file->private_data))\n\t\t\terr = PTR_ERR(file->private_data);\n\t\telse\n\t\t\terr = 0;\n\t}\n\tinode_unlock(d_inode(dentry));\n\n\treturn err;\n}\n\nstatic int configfs_dir_close(struct inode *inode, struct file *file)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\tstruct configfs_dirent * cursor = file->private_data;\n\n\tinode_lock(d_inode(dentry));\n\tspin_lock(&configfs_dirent_lock);\n\tlist_del_init(&cursor->s_sibling);\n\tspin_unlock(&configfs_dirent_lock);\n\tinode_unlock(d_inode(dentry));\n\n\trelease_configfs_dirent(cursor);\n\n\treturn 0;\n}\n\nstatic int configfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct configfs_dirent * parent_sd = dentry->d_fsdata;\n\tstruct configfs_dirent *cursor = file->private_data;\n\tstruct list_head *p, *q = &cursor->s_sibling;\n\tino_t ino = 0;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tspin_lock(&configfs_dirent_lock);\n\tif (ctx->pos == 2)\n\t\tlist_move(q, &parent_sd->s_children);\n\tfor (p = q->next; p != &parent_sd->s_children; p = p->next) {\n\t\tstruct configfs_dirent *next;\n\t\tconst char *name;\n\t\tint len;\n\t\tstruct inode *inode = NULL;\n\n\t\tnext = list_entry(p, struct configfs_dirent, s_sibling);\n\t\tif (!next->s_element)\n\t\t\tcontinue;\n\n\t\t \n\t\tdentry = next->s_dentry;\n\t\tif (dentry)\n\t\t\tinode = d_inode(dentry);\n\t\tif (inode)\n\t\t\tino = inode->i_ino;\n\t\tspin_unlock(&configfs_dirent_lock);\n\t\tif (!inode)\n\t\t\tino = iunique(sb, 2);\n\n\t\tname = configfs_get_name(next);\n\t\tlen = strlen(name);\n\n\t\tif (!dir_emit(ctx, name, len, ino,\n\t\t\t      fs_umode_to_dtype(next->s_mode)))\n\t\t\treturn 0;\n\n\t\tspin_lock(&configfs_dirent_lock);\n\t\tlist_move(q, p);\n\t\tp = q;\n\t\tctx->pos++;\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\treturn 0;\n}\n\nstatic loff_t configfs_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry * dentry = file->f_path.dentry;\n\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tif (file->f_pos >= 2) {\n\t\t\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\t\t\tstruct configfs_dirent *cursor = file->private_data;\n\t\t\tstruct list_head *p;\n\t\t\tloff_t n = file->f_pos - 2;\n\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del(&cursor->s_sibling);\n\t\t\tp = sd->s_children.next;\n\t\t\twhile (n && p != &sd->s_children) {\n\t\t\t\tstruct configfs_dirent *next;\n\t\t\t\tnext = list_entry(p, struct configfs_dirent,\n\t\t\t\t\t\t   s_sibling);\n\t\t\t\tif (next->s_element)\n\t\t\t\t\tn--;\n\t\t\t\tp = p->next;\n\t\t\t}\n\t\t\tlist_add_tail(&cursor->s_sibling, p);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\treturn offset;\n}\n\nconst struct file_operations configfs_dir_operations = {\n\t.open\t\t= configfs_dir_open,\n\t.release\t= configfs_dir_close,\n\t.llseek\t\t= configfs_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= configfs_readdir,\n};\n\n \nint configfs_register_group(struct config_group *parent_group,\n\t\t\t    struct config_group *group)\n{\n\tstruct configfs_subsystem *subsys = parent_group->cg_subsys;\n\tstruct dentry *parent;\n\tstruct configfs_fragment *frag;\n\tint ret;\n\n\tfrag = new_fragment();\n\tif (!frag)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&subsys->su_mutex);\n\tlink_group(parent_group, group);\n\tmutex_unlock(&subsys->su_mutex);\n\n\tparent = parent_group->cg_item.ci_dentry;\n\n\tinode_lock_nested(d_inode(parent), I_MUTEX_PARENT);\n\tret = create_default_group(parent_group, group, frag);\n\tif (ret)\n\t\tgoto err_out;\n\n\tspin_lock(&configfs_dirent_lock);\n\tconfigfs_dir_set_ready(group->cg_item.ci_dentry->d_fsdata);\n\tspin_unlock(&configfs_dirent_lock);\n\tinode_unlock(d_inode(parent));\n\tput_fragment(frag);\n\treturn 0;\nerr_out:\n\tinode_unlock(d_inode(parent));\n\tmutex_lock(&subsys->su_mutex);\n\tunlink_group(group);\n\tmutex_unlock(&subsys->su_mutex);\n\tput_fragment(frag);\n\treturn ret;\n}\nEXPORT_SYMBOL(configfs_register_group);\n\n \nvoid configfs_unregister_group(struct config_group *group)\n{\n\tstruct configfs_subsystem *subsys = group->cg_subsys;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *parent = group->cg_item.ci_parent->ci_dentry;\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\tstruct configfs_fragment *frag = sd->s_frag;\n\n\tdown_write(&frag->frag_sem);\n\tfrag->frag_dead = true;\n\tup_write(&frag->frag_sem);\n\n\tinode_lock_nested(d_inode(parent), I_MUTEX_PARENT);\n\tspin_lock(&configfs_dirent_lock);\n\tconfigfs_detach_prep(dentry, NULL);\n\tspin_unlock(&configfs_dirent_lock);\n\n\tconfigfs_detach_group(&group->cg_item);\n\td_inode(dentry)->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\td_drop(dentry);\n\tfsnotify_rmdir(d_inode(parent), dentry);\n\tinode_unlock(d_inode(parent));\n\n\tdput(dentry);\n\n\tmutex_lock(&subsys->su_mutex);\n\tunlink_group(group);\n\tmutex_unlock(&subsys->su_mutex);\n}\nEXPORT_SYMBOL(configfs_unregister_group);\n\n \nstruct config_group *\nconfigfs_register_default_group(struct config_group *parent_group,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct config_item_type *item_type)\n{\n\tint ret;\n\tstruct config_group *group;\n\n\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\tif (!group)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconfig_group_init_type_name(group, name, item_type);\n\n\tret = configfs_register_group(parent_group, group);\n\tif (ret) {\n\t\tkfree(group);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn group;\n}\nEXPORT_SYMBOL(configfs_register_default_group);\n\n \nvoid configfs_unregister_default_group(struct config_group *group)\n{\n\tconfigfs_unregister_group(group);\n\tkfree(group);\n}\nEXPORT_SYMBOL(configfs_unregister_default_group);\n\nint configfs_register_subsystem(struct configfs_subsystem *subsys)\n{\n\tint err;\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry;\n\tstruct dentry *root;\n\tstruct configfs_dirent *sd;\n\tstruct configfs_fragment *frag;\n\n\tfrag = new_fragment();\n\tif (!frag)\n\t\treturn -ENOMEM;\n\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root)) {\n\t\tput_fragment(frag);\n\t\treturn PTR_ERR(root);\n\t}\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tsd = root->d_fsdata;\n\tmutex_lock(&configfs_subsystem_mutex);\n\tlink_group(to_config_group(sd->s_element), group);\n\tmutex_unlock(&configfs_subsystem_mutex);\n\n\tinode_lock_nested(d_inode(root), I_MUTEX_PARENT);\n\n\terr = -ENOMEM;\n\tdentry = d_alloc_name(root, group->cg_item.ci_name);\n\tif (dentry) {\n\t\td_add(dentry, NULL);\n\n\t\terr = configfs_attach_group(sd->s_element, &group->cg_item,\n\t\t\t\t\t    dentry, frag);\n\t\tif (err) {\n\t\t\tBUG_ON(d_inode(dentry));\n\t\t\td_drop(dentry);\n\t\t\tdput(dentry);\n\t\t} else {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\n\tinode_unlock(d_inode(root));\n\n\tif (err) {\n\t\tmutex_lock(&configfs_subsystem_mutex);\n\t\tunlink_group(group);\n\t\tmutex_unlock(&configfs_subsystem_mutex);\n\t\tconfigfs_release_fs();\n\t}\n\tput_fragment(frag);\n\n\treturn err;\n}\n\nvoid configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\tstruct configfs_dirent *sd = dentry->d_fsdata;\n\tstruct configfs_fragment *frag = sd->s_frag;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tdown_write(&frag->frag_sem);\n\tfrag->frag_dead = true;\n\tup_write(&frag->frag_sem);\n\n\tinode_lock_nested(d_inode(root),\n\t\t\t  I_MUTEX_PARENT);\n\tinode_lock_nested(d_inode(dentry), I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\td_inode(dentry)->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tinode_unlock(d_inode(dentry));\n\n\td_drop(dentry);\n\tfsnotify_rmdir(d_inode(root), dentry);\n\n\tinode_unlock(d_inode(root));\n\n\tdput(dentry);\n\n\tmutex_lock(&configfs_subsystem_mutex);\n\tunlink_group(group);\n\tmutex_unlock(&configfs_subsystem_mutex);\n\tconfigfs_release_fs();\n}\n\nEXPORT_SYMBOL(configfs_register_subsystem);\nEXPORT_SYMBOL(configfs_unregister_subsystem);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}