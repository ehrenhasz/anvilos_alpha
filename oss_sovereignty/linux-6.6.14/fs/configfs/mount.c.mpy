{
  "module_name": "mount.c",
  "hash_id": "8d960ec4fbfdb3247c10ff4e033a7ad20359d9a6547adec4353266086b510719",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/mount.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#include <linux/configfs.h>\n#include \"configfs_internal.h\"\n\n \n#define CONFIGFS_MAGIC 0x62656570\n\nstatic struct vfsmount *configfs_mount = NULL;\nstruct kmem_cache *configfs_dir_cachep;\nstatic int configfs_mnt_count = 0;\n\n\nstatic void configfs_free_inode(struct inode *inode)\n{\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tfree_inode_nonrcu(inode);\n}\n\nstatic const struct super_operations configfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.free_inode\t= configfs_free_inode,\n};\n\nstatic struct config_group configfs_root_group = {\n\t.cg_item = {\n\t\t.ci_namebuf\t= \"root\",\n\t\t.ci_name\t= configfs_root_group.cg_item.ci_namebuf,\n\t},\n};\n\nint configfs_is_root(struct config_item *item)\n{\n\treturn item == &configfs_root_group.cg_item;\n}\n\nstatic struct configfs_dirent configfs_root = {\n\t.s_sibling\t= LIST_HEAD_INIT(configfs_root.s_sibling),\n\t.s_children\t= LIST_HEAD_INIT(configfs_root.s_children),\n\t.s_element\t= &configfs_root_group.cg_item,\n\t.s_type\t\t= CONFIGFS_ROOT,\n\t.s_iattr\t= NULL,\n};\n\nstatic int configfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = CONFIGFS_MAGIC;\n\tsb->s_op = &configfs_ops;\n\tsb->s_time_gran = 1;\n\n\tinode = configfs_new_inode(S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,\n\t\t\t\t   &configfs_root, sb);\n\tif (inode) {\n\t\tinode->i_op = &configfs_root_inode_operations;\n\t\tinode->i_fop = &configfs_dir_operations;\n\t\t \n\t\tinc_nlink(inode);\n\t} else {\n\t\tpr_debug(\"could not get root inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tpr_debug(\"%s: could not get root dentry!\\n\",__func__);\n\t\treturn -ENOMEM;\n\t}\n\tconfig_group_init(&configfs_root_group);\n\tconfigfs_root_group.cg_item.ci_dentry = root;\n\troot->d_fsdata = &configfs_root;\n\tsb->s_root = root;\n\tsb->s_d_op = &configfs_dentry_ops;  \n\treturn 0;\n}\n\nstatic int configfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, configfs_fill_super);\n}\n\nstatic const struct fs_context_operations configfs_context_ops = {\n\t.get_tree\t= configfs_get_tree,\n};\n\nstatic int configfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &configfs_context_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type configfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"configfs\",\n\t.init_fs_context = configfs_init_fs_context,\n\t.kill_sb\t= kill_litter_super,\n};\nMODULE_ALIAS_FS(\"configfs\");\n\nstruct dentry *configfs_pin_fs(void)\n{\n\tint err = simple_pin_fs(&configfs_fs_type, &configfs_mount,\n\t\t\t     &configfs_mnt_count);\n\treturn err ? ERR_PTR(err) : configfs_mount->mnt_root;\n}\n\nvoid configfs_release_fs(void)\n{\n\tsimple_release_fs(&configfs_mount, &configfs_mnt_count);\n}\n\n\nstatic int __init configfs_init(void)\n{\n\tint err = -ENOMEM;\n\n\tconfigfs_dir_cachep = kmem_cache_create(\"configfs_dir_cache\",\n\t\t\t\t\t\tsizeof(struct configfs_dirent),\n\t\t\t\t\t\t0, 0, NULL);\n\tif (!configfs_dir_cachep)\n\t\tgoto out;\n\n\terr = sysfs_create_mount_point(kernel_kobj, \"config\");\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_filesystem(&configfs_fs_type);\n\tif (err)\n\t\tgoto out3;\n\n\treturn 0;\nout3:\n\tpr_err(\"Unable to register filesystem!\\n\");\n\tsysfs_remove_mount_point(kernel_kobj, \"config\");\nout2:\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\nout:\n\treturn err;\n}\n\nstatic void __exit configfs_exit(void)\n{\n\tunregister_filesystem(&configfs_fs_type);\n\tsysfs_remove_mount_point(kernel_kobj, \"config\");\n\tkmem_cache_destroy(configfs_dir_cachep);\n\tconfigfs_dir_cachep = NULL;\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.0.2\");\nMODULE_DESCRIPTION(\"Simple RAM filesystem for user driven kernel subsystem configuration.\");\n\ncore_initcall(configfs_init);\nmodule_exit(configfs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}