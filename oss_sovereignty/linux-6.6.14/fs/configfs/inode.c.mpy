{
  "module_name": "inode.c",
  "hash_id": "96b7275f569e6c36c1886c47a6ecf402df6a63de2df5c94b6cf3491fdceb9fad",
  "original_prompt": "Ingested from linux-6.6.14/fs/configfs/inode.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/backing-dev.h>\n#include <linux/capability.h>\n#include <linux/sched.h>\n#include <linux/lockdep.h>\n#include <linux/slab.h>\n\n#include <linux/configfs.h>\n#include \"configfs_internal.h\"\n\n#ifdef CONFIG_LOCKDEP\nstatic struct lock_class_key default_group_class[MAX_LOCK_DEPTH];\n#endif\n\nstatic const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};\n\nint configfs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t     struct iattr *iattr)\n{\n\tstruct inode * inode = d_inode(dentry);\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\tstruct iattr * sd_iattr;\n\tunsigned int ia_valid = iattr->ia_valid;\n\tint error;\n\n\tif (!sd)\n\t\treturn -EINVAL;\n\n\tsd_iattr = sd->s_iattr;\n\tif (!sd_iattr) {\n\t\t \n\t\tsd_iattr = kzalloc(sizeof(struct iattr), GFP_KERNEL);\n\t\tif (!sd_iattr)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tsd_iattr->ia_mode = sd->s_mode;\n\t\tsd_iattr->ia_uid = GLOBAL_ROOT_UID;\n\t\tsd_iattr->ia_gid = GLOBAL_ROOT_GID;\n\t\tsd_iattr->ia_atime = sd_iattr->ia_mtime =\n\t\t\tsd_iattr->ia_ctime = current_time(inode);\n\t\tsd->s_iattr = sd_iattr;\n\t}\n\t \n\n\terror = simple_setattr(idmap, dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_UID)\n\t\tsd_iattr->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tsd_iattr->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tsd_iattr->ia_atime = iattr->ia_atime;\n\tif (ia_valid & ATTR_MTIME)\n\t\tsd_iattr->ia_mtime = iattr->ia_mtime;\n\tif (ia_valid & ATTR_CTIME)\n\t\tsd_iattr->ia_ctime = iattr->ia_ctime;\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tsd_iattr->ia_mode = sd->s_mode = mode;\n\t}\n\n\treturn error;\n}\n\nstatic inline void set_default_inode_attr(struct inode * inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n}\n\nstatic inline void set_inode_attr(struct inode * inode, struct iattr * iattr)\n{\n\tinode->i_mode = iattr->ia_mode;\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode_set_ctime_to_ts(inode, iattr->ia_ctime);\n}\n\nstruct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &ram_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t \n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}\n\n#ifdef CONFIG_LOCKDEP\n\nstatic void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n\tint depth = sd->s_depth;\n\n\tif (depth > 0) {\n\t\tif (depth <= ARRAY_SIZE(default_group_class)) {\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &default_group_class[depth - 1]);\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"Too many levels of inodes for the locking correctness validator.\\n\");\n\t\t\tpr_info(\"Spurious warnings may appear.\\n\");\n\t\t}\n\t}\n}\n\n#else  \n\nstatic void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n}\n\n#endif  \n\nstruct inode *configfs_create(struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode = NULL;\n\tstruct configfs_dirent *sd;\n\tstruct inode *p_inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (d_really_is_positive(dentry))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tsd = dentry->d_fsdata;\n\tinode = configfs_new_inode(mode, sd, dentry->d_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tp_inode = d_inode(dentry->d_parent);\n\tp_inode->i_mtime = inode_set_ctime_current(p_inode);\n\tconfigfs_set_inode_lock_class(sd, inode);\n\treturn inode;\n}\n\n \nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t \n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & (CONFIGFS_ITEM_ATTR | CONFIGFS_ITEM_BIN_ATTR)) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}\n\n\n \nvoid configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (simple_positive(dentry)) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(d_inode(parent), dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}\n\nvoid configfs_hash_and_remove(struct dentry * dir, const char * name)\n{\n\tstruct configfs_dirent * sd;\n\tstruct configfs_dirent * parent_sd = dir->d_fsdata;\n\n\tif (d_really_is_negative(dir))\n\t\t \n\t\treturn;\n\n\tinode_lock(d_inode(dir));\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element)\n\t\t\tcontinue;\n\t\tif (!strcmp(configfs_get_name(sd), name)) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_drop_dentry(sd, dir);\n\t\t\tconfigfs_put(sd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tinode_unlock(d_inode(dir));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}