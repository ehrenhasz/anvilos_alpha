{
  "module_name": "smb2inode.c",
  "hash_id": "56395acf73cc4629701273e7be29281d6cb38720a50211e82f81d789fc8a98a8",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2inode.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <asm/div64.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"fscache.h\"\n#include \"smb2glob.h\"\n#include \"smb2pdu.h\"\n#include \"smb2proto.h\"\n#include \"cached_dir.h\"\n#include \"smb2status.h\"\n\nstatic void\nfree_set_inf_compound(struct smb_rqst *rqst)\n{\n\tif (rqst[1].rq_iov)\n\t\tSMB2_set_info_free(&rqst[1]);\n\tif (rqst[2].rq_iov)\n\t\tSMB2_close_free(&rqst[2]);\n}\n\n \nstatic int smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t    struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t\t    __u32 desired_access, __u32 create_disposition, __u32 create_options,\n\t\t\t    umode_t mode, void *ptr, int command, struct cifsFileInfo *cfile,\n\t\t\t    __u8 **extbuf, size_t *extbuflen,\n\t\t\t    struct kvec *out_iov, int *out_buftype)\n{\n\tstruct smb2_compound_vars *vars = NULL;\n\tstruct kvec *rsp_iov;\n\tstruct smb_rqst *rqst;\n\tint rc;\n\t__le16 *utf16_path = NULL;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_fid fid;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server;\n\tint num_rqst = 0;\n\tint resp_buftype[3];\n\tstruct smb2_query_info_rsp *qi_rsp = NULL;\n\tstruct cifs_open_info_data *idata;\n\tint flags = 0;\n\t__u8 delete_pending[8] = {1, 0, 0, 0, 0, 0, 0, 0};\n\tunsigned int size[2];\n\tvoid *data[2];\n\tint len;\n\n\tvars = kzalloc(sizeof(*vars), GFP_ATOMIC);\n\tif (vars == NULL)\n\t\treturn -ENOMEM;\n\trqst = &vars->rqst[0];\n\trsp_iov = &vars->rsp_iov[0];\n\n\tserver = cifs_pick_channel(ses);\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\n\t \n\tif (cfile)\n\t\tgoto after_open;\n\n\t \n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tgoto finished;\n\t}\n\n\tvars->oparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = full_path,\n\t\t.desired_access = desired_access,\n\t\t.disposition = create_disposition,\n\t\t.create_options = cifs_create_options(cifs_sb, create_options),\n\t\t.fid = &fid,\n\t\t.mode = mode,\n\t\t.cifs_sb = cifs_sb,\n\t};\n\n\trqst[num_rqst].rq_iov = &vars->open_iov[0];\n\trqst[num_rqst].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[num_rqst], &oplock, &vars->oparms,\n\t\t\t    utf16_path);\n\tkfree(utf16_path);\n\tif (rc)\n\t\tgoto finished;\n\n\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n after_open:\n\tnum_rqst++;\n\trc = 0;\n\n\t \n\tswitch (command) {\n\tcase SMB2_OP_QUERY_INFO:\n\t\trqst[num_rqst].rq_iov = &vars->qi_iov;\n\t\trqst[num_rqst].rq_nvec = 1;\n\n\t\tif (cfile)\n\t\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\tcfile->fid.volatile_fid,\n\t\t\t\tFILE_ALL_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\tsizeof(struct smb2_file_all_info) +\n\t\t\t\t\t  PATH_MAX * 2, 0, NULL);\n\t\telse {\n\t\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tCOMPOUND_FID,\n\t\t\t\tCOMPOUND_FID,\n\t\t\t\tFILE_ALL_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\tsizeof(struct smb2_file_all_info) +\n\t\t\t\t\t  PATH_MAX * 2, 0, NULL);\n\t\t\tif (!rc) {\n\t\t\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\t\t\tsmb2_set_related(&rqst[num_rqst]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tnum_rqst++;\n\t\ttrace_smb3_query_info_compound_enter(xid, ses->Suid, tcon->tid,\n\t\t\t\t\t\t     full_path);\n\t\tbreak;\n\tcase SMB2_OP_POSIX_QUERY_INFO:\n\t\trqst[num_rqst].rq_iov = &vars->qi_iov;\n\t\trqst[num_rqst].rq_nvec = 1;\n\n\t\tif (cfile)\n\t\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\tcfile->fid.volatile_fid,\n\t\t\t\tSMB_FIND_FILE_POSIX_INFO,\n\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\t \n\t\t\t\tsizeof(struct smb311_posix_qinfo *) + (PATH_MAX * 2) +\n\t\t\t\t(sizeof(struct cifs_sid) * 2), 0, NULL);\n\t\telse {\n\t\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tCOMPOUND_FID,\n\t\t\t\tCOMPOUND_FID,\n\t\t\t\tSMB_FIND_FILE_POSIX_INFO,\n\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\tsizeof(struct smb311_posix_qinfo *) + (PATH_MAX * 2) +\n\t\t\t\t(sizeof(struct cifs_sid) * 2), 0, NULL);\n\t\t\tif (!rc) {\n\t\t\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\t\t\tsmb2_set_related(&rqst[num_rqst]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tnum_rqst++;\n\t\ttrace_smb3_posix_query_info_compound_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_DELETE:\n\t\ttrace_smb3_delete_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\t \n\t\ttrace_smb3_mkdir_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_RMDIR:\n\t\trqst[num_rqst].rq_iov = &vars->si_iov[0];\n\t\trqst[num_rqst].rq_nvec = 1;\n\n\t\tsize[0] = 1;  \n\t\tdata[0] = &delete_pending[0];\n\n\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t&rqst[num_rqst], COMPOUND_FID,\n\t\t\t\t\tCOMPOUND_FID, current->tgid,\n\t\t\t\t\tFILE_DISPOSITION_INFORMATION,\n\t\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\tsmb2_set_related(&rqst[num_rqst++]);\n\t\ttrace_smb3_rmdir_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\trqst[num_rqst].rq_iov = &vars->si_iov[0];\n\t\trqst[num_rqst].rq_nvec = 1;\n\n\t\tsize[0] = 8;  \n\t\tdata[0] = ptr;\n\n\t\tif (cfile) {\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t\t&rqst[num_rqst],\n\t\t\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\t\t\tcfile->fid.volatile_fid,\n\t\t\t\t\t\tcurrent->tgid,\n\t\t\t\t\t\tFILE_END_OF_FILE_INFORMATION,\n\t\t\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\t\t\tdata, size);\n\t\t} else {\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t\t&rqst[num_rqst],\n\t\t\t\t\t\tCOMPOUND_FID,\n\t\t\t\t\t\tCOMPOUND_FID,\n\t\t\t\t\t\tcurrent->tgid,\n\t\t\t\t\t\tFILE_END_OF_FILE_INFORMATION,\n\t\t\t\t\t\tSMB2_O_INFO_FILE, 0,\n\t\t\t\t\t\tdata, size);\n\t\t\tif (!rc) {\n\t\t\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\t\t\tsmb2_set_related(&rqst[num_rqst]);\n\t\t\t}\n\t\t}\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tnum_rqst++;\n\t\ttrace_smb3_set_eof_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\trqst[num_rqst].rq_iov = &vars->si_iov[0];\n\t\trqst[num_rqst].rq_nvec = 1;\n\n\n\t\tsize[0] = sizeof(FILE_BASIC_INFO);\n\t\tdata[0] = ptr;\n\n\t\tif (cfile)\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\tcfile->fid.volatile_fid, current->tgid,\n\t\t\t\tFILE_BASIC_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\telse {\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t&rqst[num_rqst],\n\t\t\t\tCOMPOUND_FID,\n\t\t\t\tCOMPOUND_FID, current->tgid,\n\t\t\t\tFILE_BASIC_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\t\tif (!rc) {\n\t\t\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\t\t\tsmb2_set_related(&rqst[num_rqst]);\n\t\t\t}\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tnum_rqst++;\n\t\ttrace_smb3_set_info_compound_enter(xid, ses->Suid, tcon->tid,\n\t\t\t\t\t\t   full_path);\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\trqst[num_rqst].rq_iov = &vars->si_iov[0];\n\t\trqst[num_rqst].rq_nvec = 2;\n\n\t\tlen = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));\n\n\t\tvars->rename_info.ReplaceIfExists = 1;\n\t\tvars->rename_info.RootDirectory = 0;\n\t\tvars->rename_info.FileNameLength = cpu_to_le32(len);\n\n\t\tsize[0] = sizeof(struct smb2_file_rename_info);\n\t\tdata[0] = &vars->rename_info;\n\n\t\tsize[1] = len + 2  ;\n\t\tdata[1] = (__le16 *)ptr;\n\n\t\tif (cfile)\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t\t&rqst[num_rqst],\n\t\t\t\t\t\tcfile->fid.persistent_fid,\n\t\t\t\t\t\tcfile->fid.volatile_fid,\n\t\t\t\t\tcurrent->tgid, FILE_RENAME_INFORMATION,\n\t\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\telse {\n\t\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t&rqst[num_rqst],\n\t\t\t\t\tCOMPOUND_FID, COMPOUND_FID,\n\t\t\t\t\tcurrent->tgid, FILE_RENAME_INFORMATION,\n\t\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\t\tif (!rc) {\n\t\t\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\t\t\tsmb2_set_related(&rqst[num_rqst]);\n\t\t\t}\n\t\t}\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tnum_rqst++;\n\t\ttrace_smb3_rename_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\trqst[num_rqst].rq_iov = &vars->si_iov[0];\n\t\trqst[num_rqst].rq_nvec = 2;\n\n\t\tlen = (2 * UniStrnlen((wchar_t *)ptr, PATH_MAX));\n\n\t\tvars->link_info.ReplaceIfExists = 0;\n\t\tvars->link_info.RootDirectory = 0;\n\t\tvars->link_info.FileNameLength = cpu_to_le32(len);\n\n\t\tsize[0] = sizeof(struct smb2_file_link_info);\n\t\tdata[0] = &vars->link_info;\n\n\t\tsize[1] = len + 2  ;\n\t\tdata[1] = (__le16 *)ptr;\n\n\t\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t\t&rqst[num_rqst], COMPOUND_FID,\n\t\t\t\t\tCOMPOUND_FID, current->tgid,\n\t\t\t\t\tFILE_LINK_INFORMATION,\n\t\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\tif (rc)\n\t\t\tgoto finished;\n\t\tsmb2_set_next_command(tcon, &rqst[num_rqst]);\n\t\tsmb2_set_related(&rqst[num_rqst++]);\n\t\ttrace_smb3_hardlink_enter(xid, ses->Suid, tcon->tid, full_path);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Invalid command\\n\");\n\t\trc = -EINVAL;\n\t}\n\tif (rc)\n\t\tgoto finished;\n\n\t \n\tif (cfile)\n\t\tgoto after_close;\n\t \n\tflags |= CIFS_CP_CREATE_CLOSE_OP;\n\trqst[num_rqst].rq_iov = &vars->close_iov;\n\trqst[num_rqst].rq_nvec = 1;\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[num_rqst], COMPOUND_FID,\n\t\t\t     COMPOUND_FID, false);\n\tsmb2_set_related(&rqst[num_rqst]);\n\tif (rc)\n\t\tgoto finished;\n after_close:\n\tnum_rqst++;\n\n\tif (cfile) {\n\t\trc = compound_send_recv(xid, ses, server,\n\t\t\t\t\tflags, num_rqst - 2,\n\t\t\t\t\t&rqst[1], &resp_buftype[1],\n\t\t\t\t\t&rsp_iov[1]);\n\t} else\n\t\trc = compound_send_recv(xid, ses, server,\n\t\t\t\t\tflags, num_rqst,\n\t\t\t\t\trqst, resp_buftype,\n\t\t\t\t\trsp_iov);\n\n finished:\n\tSMB2_open_free(&rqst[0]);\n\tif (rc == -EREMCHG) {\n\t\tpr_warn_once(\"server share %s deleted\\n\", tcon->tree_name);\n\t\ttcon->need_reconnect = true;\n\t}\n\n\tswitch (command) {\n\tcase SMB2_OP_QUERY_INFO:\n\t\tidata = ptr;\n\t\tif (rc == 0 && cfile && cfile->symlink_target) {\n\t\t\tidata->symlink_target = kstrdup(cfile->symlink_target, GFP_KERNEL);\n\t\t\tif (!idata->symlink_target)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tqi_rsp = (struct smb2_query_info_rsp *)\n\t\t\t\trsp_iov[1].iov_base;\n\t\t\trc = smb2_validate_and_copy_iov(\n\t\t\t\tle16_to_cpu(qi_rsp->OutputBufferOffset),\n\t\t\t\tle32_to_cpu(qi_rsp->OutputBufferLength),\n\t\t\t\t&rsp_iov[1], sizeof(idata->fi), (char *)&idata->fi);\n\t\t}\n\t\tif (rqst[1].rq_iov)\n\t\t\tSMB2_query_info_free(&rqst[1]);\n\t\tif (rqst[2].rq_iov)\n\t\t\tSMB2_close_free(&rqst[2]);\n\t\tif (rc)\n\t\t\ttrace_smb3_query_info_compound_err(xid,  ses->Suid,\n\t\t\t\t\t\ttcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_query_info_compound_done(xid, ses->Suid,\n\t\t\t\t\t\ttcon->tid);\n\t\tbreak;\n\tcase SMB2_OP_POSIX_QUERY_INFO:\n\t\tidata = ptr;\n\t\tif (rc == 0 && cfile && cfile->symlink_target) {\n\t\t\tidata->symlink_target = kstrdup(cfile->symlink_target, GFP_KERNEL);\n\t\t\tif (!idata->symlink_target)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tqi_rsp = (struct smb2_query_info_rsp *)\n\t\t\t\trsp_iov[1].iov_base;\n\t\t\trc = smb2_validate_and_copy_iov(\n\t\t\t\tle16_to_cpu(qi_rsp->OutputBufferOffset),\n\t\t\t\tle32_to_cpu(qi_rsp->OutputBufferLength),\n\t\t\t\t&rsp_iov[1], sizeof(idata->posix_fi)  ,\n\t\t\t\t(char *)&idata->posix_fi);\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tunsigned int length = le32_to_cpu(qi_rsp->OutputBufferLength);\n\n\t\t\tif (length > sizeof(idata->posix_fi)) {\n\t\t\t\tchar *base = (char *)rsp_iov[1].iov_base +\n\t\t\t\t\tle16_to_cpu(qi_rsp->OutputBufferOffset) +\n\t\t\t\t\tsizeof(idata->posix_fi);\n\t\t\t\t*extbuflen = length - sizeof(idata->posix_fi);\n\t\t\t\t*extbuf = kmemdup(base, *extbuflen, GFP_KERNEL);\n\t\t\t\tif (!*extbuf)\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t} else {\n\t\t\t\trc = -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (rqst[1].rq_iov)\n\t\t\tSMB2_query_info_free(&rqst[1]);\n\t\tif (rqst[2].rq_iov)\n\t\t\tSMB2_close_free(&rqst[2]);\n\t\tif (rc)\n\t\t\ttrace_smb3_posix_query_info_compound_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_posix_query_info_compound_done(xid, ses->Suid, tcon->tid);\n\t\tbreak;\n\tcase SMB2_OP_DELETE:\n\t\tif (rc)\n\t\t\ttrace_smb3_delete_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_delete_done(xid, ses->Suid, tcon->tid);\n\t\tif (rqst[1].rq_iov)\n\t\t\tSMB2_close_free(&rqst[1]);\n\t\tbreak;\n\tcase SMB2_OP_MKDIR:\n\t\tif (rc)\n\t\t\ttrace_smb3_mkdir_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_mkdir_done(xid, ses->Suid, tcon->tid);\n\t\tif (rqst[1].rq_iov)\n\t\t\tSMB2_close_free(&rqst[1]);\n\t\tbreak;\n\tcase SMB2_OP_HARDLINK:\n\t\tif (rc)\n\t\t\ttrace_smb3_hardlink_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_hardlink_done(xid, ses->Suid, tcon->tid);\n\t\tfree_set_inf_compound(rqst);\n\t\tbreak;\n\tcase SMB2_OP_RENAME:\n\t\tif (rc)\n\t\t\ttrace_smb3_rename_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_rename_done(xid, ses->Suid, tcon->tid);\n\t\tfree_set_inf_compound(rqst);\n\t\tbreak;\n\tcase SMB2_OP_RMDIR:\n\t\tif (rc)\n\t\t\ttrace_smb3_rmdir_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_rmdir_done(xid, ses->Suid, tcon->tid);\n\t\tfree_set_inf_compound(rqst);\n\t\tbreak;\n\tcase SMB2_OP_SET_EOF:\n\t\tif (rc)\n\t\t\ttrace_smb3_set_eof_err(xid,  ses->Suid, tcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_set_eof_done(xid, ses->Suid, tcon->tid);\n\t\tfree_set_inf_compound(rqst);\n\t\tbreak;\n\tcase SMB2_OP_SET_INFO:\n\t\tif (rc)\n\t\t\ttrace_smb3_set_info_compound_err(xid,  ses->Suid,\n\t\t\t\t\t\ttcon->tid, rc);\n\t\telse\n\t\t\ttrace_smb3_set_info_compound_done(xid, ses->Suid,\n\t\t\t\t\t\ttcon->tid);\n\t\tfree_set_inf_compound(rqst);\n\t\tbreak;\n\t}\n\n\tif (cfile)\n\t\tcifsFileInfo_put(cfile);\n\n\tif (out_iov && out_buftype) {\n\t\tmemcpy(out_iov, rsp_iov, 3 * sizeof(*out_iov));\n\t\tmemcpy(out_buftype, resp_buftype, 3 * sizeof(*out_buftype));\n\t} else {\n\t\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\t\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\t\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\t}\n\tkfree(vars);\n\treturn rc;\n}\n\nstatic int parse_create_response(struct cifs_open_info_data *data,\n\t\t\t\t struct cifs_sb_info *cifs_sb,\n\t\t\t\t const struct kvec *iov)\n{\n\tstruct smb2_create_rsp *rsp = iov->iov_base;\n\tbool reparse_point = false;\n\tu32 tag = 0;\n\tint rc = 0;\n\n\tswitch (rsp->hdr.Status) {\n\tcase STATUS_IO_REPARSE_TAG_NOT_HANDLED:\n\t\treparse_point = true;\n\t\tbreak;\n\tcase STATUS_STOPPED_ON_SYMLINK:\n\t\trc = smb2_parse_symlink_response(cifs_sb, iov,\n\t\t\t\t\t\t &data->symlink_target);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\ttag = IO_REPARSE_TAG_SYMLINK;\n\t\treparse_point = true;\n\t\tbreak;\n\tcase STATUS_SUCCESS:\n\t\treparse_point = !!(rsp->Flags & SMB2_CREATE_FLAG_REPARSEPOINT);\n\t\tbreak;\n\t}\n\tdata->reparse_point = reparse_point;\n\tdata->reparse.tag = tag;\n\treturn rc;\n}\n\nint smb2_query_path_info(const unsigned int xid,\n\t\t\t struct cifs_tcon *tcon,\n\t\t\t struct cifs_sb_info *cifs_sb,\n\t\t\t const char *full_path,\n\t\t\t struct cifs_open_info_data *data)\n{\n\t__u32 create_options = 0;\n\tstruct cifsFileInfo *cfile;\n\tstruct cached_fid *cfid = NULL;\n\tstruct smb2_hdr *hdr;\n\tstruct kvec out_iov[3] = {};\n\tint out_buftype[3] = {};\n\tbool islink;\n\tint rc, rc2;\n\n\tdata->adjust_tz = false;\n\tdata->reparse_point = false;\n\n\tif (strcmp(full_path, \"\"))\n\t\trc = -ENOENT;\n\telse\n\t\trc = open_cached_dir(xid, tcon, full_path, cifs_sb, false, &cfid);\n\t \n\tif (!rc) {\n\t\tif (cfid->file_all_info_is_valid) {\n\t\t\tmemcpy(&data->fi, &cfid->file_all_info, sizeof(data->fi));\n\t\t} else {\n\t\t\trc = SMB2_query_info(xid, tcon, cfid->fid.persistent_fid,\n\t\t\t\t\t     cfid->fid.volatile_fid, &data->fi);\n\t\t}\n\t\tclose_cached_dir(cfid);\n\t\treturn rc;\n\t}\n\n\tcifs_get_readable_path(tcon, full_path, &cfile);\n\trc = smb2_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES, FILE_OPEN,\n\t\t\t      create_options, ACL_NO_MODE, data, SMB2_OP_QUERY_INFO, cfile,\n\t\t\t      NULL, NULL, out_iov, out_buftype);\n\thdr = out_iov[0].iov_base;\n\t \n\tif (!hdr || out_buftype[0] == CIFS_NO_BUFFER)\n\t\tgoto out;\n\n\tswitch (rc) {\n\tcase 0:\n\tcase -EOPNOTSUPP:\n\t\trc = parse_create_response(data, cifs_sb, &out_iov[0]);\n\t\tif (rc || !data->reparse_point)\n\t\t\tgoto out;\n\n\t\tcreate_options |= OPEN_REPARSE_POINT;\n\t\t \n\t\tcifs_get_readable_path(tcon, full_path, &cfile);\n\t\trc = smb2_compound_op(xid, tcon, cifs_sb, full_path,\n\t\t\t\t      FILE_READ_ATTRIBUTES, FILE_OPEN,\n\t\t\t\t      create_options, ACL_NO_MODE, data,\n\t\t\t\t      SMB2_OP_QUERY_INFO, cfile, NULL, NULL,\n\t\t\t\t      NULL, NULL);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\tbreak;\n\tdefault:\n\t\tif (hdr->Status != STATUS_OBJECT_NAME_INVALID)\n\t\t\tbreak;\n\t\trc2 = cifs_inval_name_dfs_link_error(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path, &islink);\n\t\tif (rc2) {\n\t\t\trc = rc2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (islink)\n\t\t\trc = -EREMOTE;\n\t}\n\nout:\n\tfree_rsp_buf(out_buftype[0], out_iov[0].iov_base);\n\tfree_rsp_buf(out_buftype[1], out_iov[1].iov_base);\n\tfree_rsp_buf(out_buftype[2], out_iov[2].iov_base);\n\treturn rc;\n}\n\nint smb311_posix_query_path_info(const unsigned int xid,\n\t\t\t\t struct cifs_tcon *tcon,\n\t\t\t\t struct cifs_sb_info *cifs_sb,\n\t\t\t\t const char *full_path,\n\t\t\t\t struct cifs_open_info_data *data,\n\t\t\t\t struct cifs_sid *owner,\n\t\t\t\t struct cifs_sid *group)\n{\n\tint rc;\n\t__u32 create_options = 0;\n\tstruct cifsFileInfo *cfile;\n\tstruct kvec out_iov[3] = {};\n\tint out_buftype[3] = {};\n\t__u8 *sidsbuf = NULL;\n\t__u8 *sidsbuf_end = NULL;\n\tsize_t sidsbuflen = 0;\n\tsize_t owner_len, group_len;\n\n\tdata->adjust_tz = false;\n\tdata->reparse_point = false;\n\n\t \n\n\tcifs_get_readable_path(tcon, full_path, &cfile);\n\trc = smb2_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES, FILE_OPEN,\n\t\t\t      create_options, ACL_NO_MODE, data, SMB2_OP_POSIX_QUERY_INFO, cfile,\n\t\t\t      &sidsbuf, &sidsbuflen, out_iov, out_buftype);\n\t \n\tif (!out_iov[0].iov_base || out_buftype[0] == CIFS_NO_BUFFER)\n\t\tgoto out;\n\n\tswitch (rc) {\n\tcase 0:\n\tcase -EOPNOTSUPP:\n\t\t \n\t\trc = parse_create_response(data, cifs_sb, &out_iov[0]);\n\t\tif (rc || !data->reparse_point)\n\t\t\tgoto out;\n\n\t\tcreate_options |= OPEN_REPARSE_POINT;\n\t\t \n\t\tcifs_get_readable_path(tcon, full_path, &cfile);\n\t\trc = smb2_compound_op(xid, tcon, cifs_sb, full_path, FILE_READ_ATTRIBUTES,\n\t\t\t\t      FILE_OPEN, create_options, ACL_NO_MODE, data,\n\t\t\t\t      SMB2_OP_POSIX_QUERY_INFO, cfile,\n\t\t\t\t      &sidsbuf, &sidsbuflen, NULL, NULL);\n\t\tbreak;\n\t}\n\nout:\n\tif (rc == 0) {\n\t\tsidsbuf_end = sidsbuf + sidsbuflen;\n\n\t\towner_len = posix_info_sid_size(sidsbuf, sidsbuf_end);\n\t\tif (owner_len == -1) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(owner, sidsbuf, owner_len);\n\n\t\tgroup_len = posix_info_sid_size(\n\t\t\tsidsbuf + owner_len, sidsbuf_end);\n\t\tif (group_len == -1) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(group, sidsbuf + owner_len, group_len);\n\t}\n\n\tkfree(sidsbuf);\n\tfree_rsp_buf(out_buftype[0], out_iov[0].iov_base);\n\tfree_rsp_buf(out_buftype[1], out_iov[1].iov_base);\n\tfree_rsp_buf(out_buftype[2], out_iov[2].iov_base);\n\treturn rc;\n}\n\nint\nsmb2_mkdir(const unsigned int xid, struct inode *parent_inode, umode_t mode,\n\t   struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_compound_op(xid, tcon, cifs_sb, name,\n\t\t\t\tFILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\tCREATE_NOT_FILE, mode, NULL, SMB2_OP_MKDIR,\n\t\t\t\tNULL, NULL, NULL, NULL, NULL);\n}\n\nvoid\nsmb2_mkdir_setinfo(struct inode *inode, const char *name,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO data;\n\tstruct cifsInodeInfo *cifs_i;\n\tstruct cifsFileInfo *cfile;\n\tu32 dosattrs;\n\tint tmprc;\n\n\tmemset(&data, 0, sizeof(data));\n\tcifs_i = CIFS_I(inode);\n\tdosattrs = cifs_i->cifsAttrs | ATTR_READONLY;\n\tdata.Attributes = cpu_to_le32(dosattrs);\n\tcifs_get_writable_path(tcon, name, FIND_WR_ANY, &cfile);\n\ttmprc = smb2_compound_op(xid, tcon, cifs_sb, name,\n\t\t\t\t FILE_WRITE_ATTRIBUTES, FILE_CREATE,\n\t\t\t\t CREATE_NOT_FILE, ACL_NO_MODE,\n\t\t\t\t &data, SMB2_OP_SET_INFO, cfile, NULL, NULL, NULL, NULL);\n\tif (tmprc == 0)\n\t\tcifs_i->cifsAttrs = dosattrs;\n}\n\nint\nsmb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t   struct cifs_sb_info *cifs_sb)\n{\n\tdrop_cached_dir_by_name(xid, tcon, name, cifs_sb);\n\treturn smb2_compound_op(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\tCREATE_NOT_FILE, ACL_NO_MODE,\n\t\t\t\tNULL, SMB2_OP_RMDIR, NULL, NULL, NULL, NULL, NULL);\n}\n\nint\nsmb2_unlink(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_compound_op(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,\n\t\t\t\tCREATE_DELETE_ON_CLOSE | OPEN_REPARSE_POINT,\n\t\t\t\tACL_NO_MODE, NULL, SMB2_OP_DELETE, NULL, NULL, NULL, NULL, NULL);\n}\n\nstatic int\nsmb2_set_path_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb, __u32 access, int command,\n\t\t   struct cifsFileInfo *cfile)\n{\n\t__le16 *smb2_to_name = NULL;\n\tint rc;\n\n\tsmb2_to_name = cifs_convert_path_to_utf16(to_name, cifs_sb);\n\tif (smb2_to_name == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto smb2_rename_path;\n\t}\n\trc = smb2_compound_op(xid, tcon, cifs_sb, from_name, access,\n\t\t\t      FILE_OPEN, 0, ACL_NO_MODE, smb2_to_name,\n\t\t\t      command, cfile, NULL, NULL, NULL, NULL);\nsmb2_rename_path:\n\tkfree(smb2_to_name);\n\treturn rc;\n}\n\nint\nsmb2_rename_path(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *from_name, const char *to_name,\n\t\t struct cifs_sb_info *cifs_sb)\n{\n\tstruct cifsFileInfo *cfile;\n\n\tdrop_cached_dir_by_name(xid, tcon, from_name, cifs_sb);\n\tcifs_get_writable_path(tcon, from_name, FIND_WR_WITH_DELETE, &cfile);\n\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name,\n\t\t\t\t  cifs_sb, DELETE, SMB2_OP_RENAME, cfile);\n}\n\nint\nsmb2_create_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *from_name, const char *to_name,\n\t\t     struct cifs_sb_info *cifs_sb)\n{\n\treturn smb2_set_path_attr(xid, tcon, from_name, to_name, cifs_sb,\n\t\t\t\t  FILE_READ_ATTRIBUTES, SMB2_OP_HARDLINK,\n\t\t\t\t  NULL);\n}\n\nint\nsmb2_set_path_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, __u64 size,\n\t\t   struct cifs_sb_info *cifs_sb, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\tstruct cifsFileInfo *cfile;\n\n\tcifs_get_writable_path(tcon, full_path, FIND_WR_ANY, &cfile);\n\treturn smb2_compound_op(xid, tcon, cifs_sb, full_path,\n\t\t\t\tFILE_WRITE_DATA, FILE_OPEN, 0, ACL_NO_MODE,\n\t\t\t\t&eof, SMB2_OP_SET_EOF, cfile, NULL, NULL, NULL, NULL);\n}\n\nint\nsmb2_set_file_info(struct inode *inode, const char *full_path,\n\t\t   FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cfile;\n\tint rc;\n\n\tif ((buf->CreationTime == 0) && (buf->LastAccessTime == 0) &&\n\t    (buf->LastWriteTime == 0) && (buf->ChangeTime == 0) &&\n\t    (buf->Attributes == 0))\n\t\treturn 0;  \n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_get_writable_path(tcon, full_path, FIND_WR_ANY, &cfile);\n\trc = smb2_compound_op(xid, tcon, cifs_sb, full_path,\n\t\t\t      FILE_WRITE_ATTRIBUTES, FILE_OPEN,\n\t\t\t      0, ACL_NO_MODE, buf, SMB2_OP_SET_INFO, cfile,\n\t\t\t      NULL, NULL, NULL, NULL);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}