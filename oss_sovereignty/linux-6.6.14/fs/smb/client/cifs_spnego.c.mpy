{
  "module_name": "cifs_spnego.c",
  "hash_id": "238986928662f6a8146e97280c39243a48e8998c921cbecd846ac4dd1e7c1296",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifs_spnego.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/inet.h>\n#include \"cifsglob.h\"\n#include \"cifs_spnego.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\nstatic const struct cred *spnego_cred;\n\n \nstatic int\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\tgoto error;\n\n\t \n\tkey->payload.data[0] = payload;\n\tret = 0;\n\nerror:\n\treturn ret;\n}\n\nstatic void\ncifs_spnego_key_destroy(struct key *key)\n{\n\tkfree(key->payload.data[0]);\n}\n\n\n \nstruct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};\n\n \n#define MAX_VER_STR_LEN\t\t8\n\n \n#define MAX_MECH_STR_LEN\t13\n\n \n#define HOST_KEY_LEN\t\t6\n\n \n#define IP_KEY_LEN\t\t5\n\n \n#define UID_KEY_LEN\t\t7\n\n \n#define CREDUID_KEY_LEN\t\t11\n\n \n#define USER_KEY_LEN\t\t6\n\n \n#define PID_KEY_LEN\t\t7\n\n \nstruct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo,\n\t\t    struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\tconst struct cred *saved_cred;\n\n\t \n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t \n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t \n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t \n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse {\n\t\tcifs_dbg(VFS, \"unknown or missing server auth type, use krb5\\n\");\n\t\tsprintf(dp, \";sec=krb5\");\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tsaved_cred = override_creds(spnego_cred);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\trevert_creds(saved_cred);\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data[0];\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif  \n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}\n\nint\ninit_cifs_spnego(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_spnego_key_type.name);\n\n\t \n\n\tcred = prepare_kernel_cred(&init_task);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_spnego\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_spnego_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t \n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tspnego_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs spnego keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nvoid\nexit_cifs_spnego(void)\n{\n\tkey_revoke(spnego_cred->thread_keyring);\n\tunregister_key_type(&cifs_spnego_key_type);\n\tput_cred(spnego_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_spnego_key_type.name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}