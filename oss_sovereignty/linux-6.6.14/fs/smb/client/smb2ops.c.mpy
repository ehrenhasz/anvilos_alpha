{
  "module_name": "smb2ops.c",
  "hash_id": "7cde95c1bf6548c57be2b87998a545f8a8b57315d09d3914688c4b2ced2baa29",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2ops.c",
  "human_readable_source": "\n \n\n#include <linux/pagemap.h>\n#include <linux/vfs.h>\n#include <linux/falloc.h>\n#include <linux/scatterlist.h>\n#include <linux/uuid.h>\n#include <linux/sort.h>\n#include <crypto/aead.h>\n#include <linux/fiemap.h>\n#include <uapi/linux/magic.h>\n#include \"cifsfs.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"cifs_ioctl.h\"\n#include \"smbdirect.h\"\n#include \"fscache.h\"\n#include \"fs_context.h\"\n#include \"cached_dir.h\"\n\n \nstatic int\nchange_conf(struct TCP_Server_Info *server)\n{\n\tserver->credits += server->echo_credits + server->oplock_credits;\n\tif (server->credits > server->max_credits)\n\t\tserver->credits = server->max_credits;\n\tserver->oplock_credits = server->echo_credits = 0;\n\tswitch (server->credits) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tserver->echoes = false;\n\t\tserver->oplocks = false;\n\t\tbreak;\n\tcase 2:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = false;\n\t\tserver->echo_credits = 1;\n\t\tbreak;\n\tdefault:\n\t\tserver->echoes = true;\n\t\tif (enable_oplocks) {\n\t\t\tserver->oplocks = true;\n\t\t\tserver->oplock_credits = 1;\n\t\t} else\n\t\t\tserver->oplocks = false;\n\n\t\tserver->echo_credits = 1;\n\t}\n\tserver->credits -= server->echo_credits + server->oplock_credits;\n\treturn server->credits + server->echo_credits + server->oplock_credits;\n}\n\nstatic void\nsmb2_add_credits(struct TCP_Server_Info *server,\n\t\t const struct cifs_credits *credits, const int optype)\n{\n\tint *val, rc = -1;\n\tint scredits, in_flight;\n\tunsigned int add = credits->value;\n\tunsigned int instance = credits->instance;\n\tbool reconnect_detected = false;\n\tbool reconnect_with_invalid_credits = false;\n\n\tspin_lock(&server->req_lock);\n\tval = server->ops->get_credits_field(server, optype);\n\n\t \n\tif (((optype & CIFS_OP_MASK) == CIFS_NEG_OP) && (*val != 0))\n\t\treconnect_with_invalid_credits = true;\n\n\tif ((instance == 0) || (instance == server->reconnect_instance))\n\t\t*val += add;\n\telse\n\t\treconnect_detected = true;\n\n\tif (*val > 65000) {\n\t\t*val = 65000;  \n\t\tpr_warn_once(\"server overflowed SMB3 credits\\n\");\n\t\ttrace_smb3_overflow_credits(server->CurrentMid,\n\t\t\t\t\t    server->conn_id, server->hostname, *val,\n\t\t\t\t\t    add, server->in_flight);\n\t}\n\tWARN_ON_ONCE(server->in_flight == 0);\n\tserver->in_flight--;\n\tif (server->in_flight == 0 &&\n\t   ((optype & CIFS_OP_MASK) != CIFS_NEG_OP) &&\n\t   ((optype & CIFS_OP_MASK) != CIFS_SESS_OP))\n\t\trc = change_conf(server);\n\t \n\telse if (server->in_flight > 0 && server->oplock_credits == 0 &&\n\t\t server->oplocks) {\n\t\tif (server->credits > 1) {\n\t\t\tserver->credits--;\n\t\t\tserver->oplock_credits++;\n\t\t}\n\t} else if ((server->in_flight > 0) && (server->oplock_credits > 3) &&\n\t\t   ((optype & CIFS_OP_MASK) == CIFS_OBREAK_OP))\n\t\t \n\t\tchange_conf(server);\n\n\tscredits = *val;\n\tin_flight = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n\n\tif (reconnect_detected) {\n\t\ttrace_smb3_reconnect_detected(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, add, in_flight);\n\n\t\tcifs_dbg(FYI, \"trying to put %d credits from the old server instance %d\\n\",\n\t\t\t add, instance);\n\t}\n\n\tif (reconnect_with_invalid_credits) {\n\t\ttrace_smb3_reconnect_with_invalid_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, add, in_flight);\n\t\tcifs_dbg(FYI, \"Negotiate operation when server credits is non-zero. Optype: %d, server credits: %d, credits added: %d\\n\",\n\t\t\t optype, scredits, add);\n\t}\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedReconnect\n\t    || server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tswitch (rc) {\n\tcase -1:\n\t\t \n\t\tbreak;\n\tcase 0:\n\t\tcifs_server_dbg(VFS, \"Possible client or server bug - zero credits\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tcifs_server_dbg(VFS, \"disabling echoes and oplocks\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tcifs_dbg(FYI, \"disabling oplocks\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\ttrace_smb3_add_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, add, in_flight);\n\tcifs_dbg(FYI, \"%s: added %u credits total=%d\\n\", __func__, add, scredits);\n}\n\nstatic void\nsmb2_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tint scredits, in_flight;\n\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tif (val == 1) {\n\t\tserver->reconnect_instance++;\n\t\t \n\t\tif (SERVER_IS_CHAN(server))\n\t\t\tserver->primary_server->channel_sequence_num++;\n\t\telse\n\t\t\tserver->channel_sequence_num++;\n\t}\n\tscredits = server->credits;\n\tin_flight = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\n\ttrace_smb3_set_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, val, in_flight);\n\tcifs_dbg(FYI, \"%s: set %u credits\\n\", __func__, val);\n\n\t \n\tif (val == 1)\n\t\tcifs_dbg(FYI, \"set credits to 1 due to smb2 reconnect\\n\");\n}\n\nstatic int *\nsmb2_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\tswitch (optype) {\n\tcase CIFS_ECHO_OP:\n\t\treturn &server->echo_credits;\n\tcase CIFS_OBREAK_OP:\n\t\treturn &server->oplock_credits;\n\tdefault:\n\t\treturn &server->credits;\n\t}\n}\n\nstatic unsigned int\nsmb2_get_credits(struct mid_q_entry *mid)\n{\n\treturn mid->credits_received;\n}\n\nstatic int\nsmb2_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, struct cifs_credits *credits)\n{\n\tint rc = 0;\n\tunsigned int scredits, in_flight;\n\n\tspin_lock(&server->req_lock);\n\twhile (1) {\n\t\tspin_unlock(&server->req_lock);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tspin_lock(&server->req_lock);\n\t\tif (server->credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\thas_credits(server, &server->credits, 1));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tscredits = server->credits;\n\t\t\t \n\t\t\tif (scredits <= 8) {\n\t\t\t\t*num = SMB2_MAX_BUFFER_SIZE;\n\t\t\t\tcredits->value = 0;\n\t\t\t\tcredits->instance = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tscredits -= 8;\n\t\t\t*num = min_t(unsigned int, size,\n\t\t\t\t     scredits * SMB2_MAX_BUFFER_SIZE);\n\n\t\t\tcredits->value =\n\t\t\t\tDIV_ROUND_UP(*num, SMB2_MAX_BUFFER_SIZE);\n\t\t\tcredits->instance = server->reconnect_instance;\n\t\t\tserver->credits -= credits->value;\n\t\t\tserver->in_flight++;\n\t\t\tif (server->in_flight > server->max_in_flight)\n\t\t\t\tserver->max_in_flight = server->in_flight;\n\t\t\tbreak;\n\t\t}\n\t}\n\tscredits = server->credits;\n\tin_flight = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\n\ttrace_smb3_wait_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, -(credits->value), in_flight);\n\tcifs_dbg(FYI, \"%s: removed %u credits total=%d\\n\",\n\t\t\t__func__, credits->value, scredits);\n\n\treturn rc;\n}\n\nstatic int\nsmb2_adjust_credits(struct TCP_Server_Info *server,\n\t\t    struct cifs_credits *credits,\n\t\t    const unsigned int payload_size)\n{\n\tint new_val = DIV_ROUND_UP(payload_size, SMB2_MAX_BUFFER_SIZE);\n\tint scredits, in_flight;\n\n\tif (!credits->value || credits->value == new_val)\n\t\treturn 0;\n\n\tif (credits->value < new_val) {\n\t\ttrace_smb3_too_many_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, 0, credits->value - new_val, 0);\n\t\tcifs_server_dbg(VFS, \"request has less credits (%d) than required (%d)\",\n\t\t\t\tcredits->value, new_val);\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock(&server->req_lock);\n\n\tif (server->reconnect_instance != credits->instance) {\n\t\tscredits = server->credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\n\t\ttrace_smb3_reconnect_detected(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\tcredits->value - new_val, in_flight);\n\t\tcifs_server_dbg(VFS, \"trying to return %d credits to old session\\n\",\n\t\t\t credits->value - new_val);\n\t\treturn -EAGAIN;\n\t}\n\n\tserver->credits += credits->value - new_val;\n\tscredits = server->credits;\n\tin_flight = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n\n\ttrace_smb3_adj_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\tcredits->value - new_val, in_flight);\n\tcifs_dbg(FYI, \"%s: adjust added %u credits total=%d\\n\",\n\t\t\t__func__, credits->value - new_val, scredits);\n\n\tcredits->value = new_val;\n\n\treturn 0;\n}\n\nstatic __u64\nsmb2_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid;\n\t \n\tspin_lock(&server->mid_lock);\n\tmid = server->CurrentMid++;\n\tspin_unlock(&server->mid_lock);\n\treturn mid;\n}\n\nstatic void\nsmb2_revert_current_mid(struct TCP_Server_Info *server, const unsigned int val)\n{\n\tspin_lock(&server->mid_lock);\n\tif (server->CurrentMid >= val)\n\t\tserver->CurrentMid -= val;\n\tspin_unlock(&server->mid_lock);\n}\n\nstatic struct mid_q_entry *\n__smb2_find_mid(struct TCP_Server_Info *server, char *buf, bool dequeue)\n{\n\tstruct mid_q_entry *mid;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\t__u64 wire_mid = le64_to_cpu(shdr->MessageId);\n\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tcifs_server_dbg(VFS, \"Encrypted frame parsing not supported yet\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&server->mid_lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif ((mid->mid == wire_mid) &&\n\t\t    (mid->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t    (mid->command == shdr->Command)) {\n\t\t\tkref_get(&mid->refcount);\n\t\t\tif (dequeue) {\n\t\t\t\tlist_del_init(&mid->qhead);\n\t\t\t\tmid->mid_flags |= MID_DELETED;\n\t\t\t}\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&server->mid_lock);\n\treturn NULL;\n}\n\nstatic struct mid_q_entry *\nsmb2_find_mid(struct TCP_Server_Info *server, char *buf)\n{\n\treturn __smb2_find_mid(server, buf, false);\n}\n\nstatic struct mid_q_entry *\nsmb2_find_dequeue_mid(struct TCP_Server_Info *server, char *buf)\n{\n\treturn __smb2_find_mid(server, buf, true);\n}\n\nstatic void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tif (!server->ops->check_message(buf, server->total_read, server)) {\n\t\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t\t\tserver->ops->calc_smb_size(buf));\n\t}\n#endif\n}\n\nstatic bool\nsmb2_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->max_read == 0;\n}\n\nstatic int\nsmb2_negotiate(const unsigned int xid,\n\t       struct cifs_ses *ses,\n\t       struct TCP_Server_Info *server)\n{\n\tint rc;\n\n\tspin_lock(&server->mid_lock);\n\tserver->CurrentMid = 0;\n\tspin_unlock(&server->mid_lock);\n\trc = SMB2_negotiate(xid, ses, server);\n\t \n\tif (rc == -EAGAIN)\n\t\trc = -EHOSTDOWN;\n\treturn rc;\n}\n\nstatic unsigned int\nsmb2_negotiate_wsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t \n\twsize = ctx->wsize ? ctx->wsize : CIFS_DEFAULT_IOSIZE;\n\twsize = min_t(unsigned int, wsize, server->max_write);\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\twsize = min_t(unsigned int, wsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn wsize;\n}\n\nstatic unsigned int\nsmb3_negotiate_wsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t \n\twsize = ctx->wsize ? ctx->wsize : SMB3_DEFAULT_IOSIZE;\n\twsize = min_t(unsigned int, wsize, server->max_write);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (server->rdma) {\n\t\tif (server->sign)\n\t\t\t \n\t\t\twsize = min_t(unsigned int,\n\t\t\t\twsize,\n\t\t\t\tserver->smbd_conn->max_fragmented_send_size -\n\t\t\t\t\tSMB2_READWRITE_PDU_HEADER_SIZE -\n\t\t\t\t\tsizeof(struct smb2_transform_hdr));\n\t\telse\n\t\t\twsize = min_t(unsigned int,\n\t\t\t\twsize, server->smbd_conn->max_readwrite_size);\n\t}\n#endif\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\twsize = min_t(unsigned int, wsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn wsize;\n}\n\nstatic unsigned int\nsmb2_negotiate_rsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize;\n\n\t \n\trsize = ctx->rsize ? ctx->rsize : CIFS_DEFAULT_IOSIZE;\n\trsize = min_t(unsigned int, rsize, server->max_read);\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\trsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn rsize;\n}\n\nstatic unsigned int\nsmb3_negotiate_rsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize;\n\n\t \n\trsize = ctx->rsize ? ctx->rsize : SMB3_DEFAULT_IOSIZE;\n\trsize = min_t(unsigned int, rsize, server->max_read);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (server->rdma) {\n\t\tif (server->sign)\n\t\t\t \n\t\t\trsize = min_t(unsigned int,\n\t\t\t\trsize,\n\t\t\t\tserver->smbd_conn->max_fragmented_recv_size -\n\t\t\t\t\tSMB2_READWRITE_PDU_HEADER_SIZE -\n\t\t\t\t\tsizeof(struct smb2_transform_hdr));\n\t\telse\n\t\t\trsize = min_t(unsigned int,\n\t\t\t\trsize, server->smbd_conn->max_readwrite_size);\n\t}\n#endif\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\trsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn rsize;\n}\n\n \nstatic int\niface_cmp(struct cifs_server_iface *a, struct cifs_server_iface *b)\n{\n\tint cmp_ret = 0;\n\n\tWARN_ON(!a || !b);\n\tif (a->rdma_capable == b->rdma_capable) {\n\t\tif (a->rss_capable == b->rss_capable) {\n\t\t\tif (a->speed == b->speed) {\n\t\t\t\tcmp_ret = cifs_ipaddr_cmp((struct sockaddr *) &a->sockaddr,\n\t\t\t\t\t\t\t  (struct sockaddr *) &b->sockaddr);\n\t\t\t\tif (!cmp_ret)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if (cmp_ret > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t} else if (a->speed > b->speed)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t} else if (a->rss_capable > b->rss_capable)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t} else if (a->rdma_capable > b->rdma_capable)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}\n\nstatic int\nparse_server_interfaces(struct network_interface_info_ioctl_rsp *buf,\n\t\t\tsize_t buf_len, struct cifs_ses *ses, bool in_mount)\n{\n\tstruct network_interface_info_ioctl_rsp *p;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tstruct iface_info_ipv4 *p4;\n\tstruct iface_info_ipv6 *p6;\n\tstruct cifs_server_iface *info = NULL, *iface = NULL, *niface = NULL;\n\tstruct cifs_server_iface tmp_iface;\n\tssize_t bytes_left;\n\tsize_t next = 0;\n\tint nb_iface = 0;\n\tint rc = 0, ret = 0;\n\n\tbytes_left = buf_len;\n\tp = buf;\n\n\tspin_lock(&ses->iface_lock);\n\t \n\tif (ses->iface_last_update &&\n\t    time_before(jiffies, ses->iface_last_update +\n\t\t\t(SMB_INTERFACE_POLL_INTERVAL * HZ))) {\n\t\tspin_unlock(&ses->iface_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry_safe(iface, niface, &ses->iface_list,\n\t\t\t\t iface_head)\n\t\tiface->is_active = 0;\n\n\tspin_unlock(&ses->iface_lock);\n\n\t \n\tif (bytes_left == 0) {\n\t\t \n\t\tif ((ses->chan_max > 1) && in_mount)\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t \"multichannel not available\\n\"\n\t\t\t\t \"Empty network interface list returned by server %s\\n\",\n\t\t\t\t ses->server->hostname);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twhile (bytes_left >= sizeof(*p)) {\n\t\tmemset(&tmp_iface, 0, sizeof(tmp_iface));\n\t\ttmp_iface.speed = le64_to_cpu(p->LinkSpeed);\n\t\ttmp_iface.rdma_capable = le32_to_cpu(p->Capability & RDMA_CAPABLE) ? 1 : 0;\n\t\ttmp_iface.rss_capable = le32_to_cpu(p->Capability & RSS_CAPABLE) ? 1 : 0;\n\n\t\tswitch (p->Family) {\n\t\t \n\t\tcase INTERNETWORK:\n\t\t\taddr4 = (struct sockaddr_in *)&tmp_iface.sockaddr;\n\t\t\tp4 = (struct iface_info_ipv4 *)p->Buffer;\n\t\t\taddr4->sin_family = AF_INET;\n\t\t\tmemcpy(&addr4->sin_addr, &p4->IPv4Address, 4);\n\n\t\t\t \n\t\t\taddr4->sin_port = cpu_to_be16(CIFS_PORT);\n\n\t\t\tcifs_dbg(FYI, \"%s: ipv4 %pI4\\n\", __func__,\n\t\t\t\t &addr4->sin_addr);\n\t\t\tbreak;\n\t\tcase INTERNETWORKV6:\n\t\t\taddr6 =\t(struct sockaddr_in6 *)&tmp_iface.sockaddr;\n\t\t\tp6 = (struct iface_info_ipv6 *)p->Buffer;\n\t\t\taddr6->sin6_family = AF_INET6;\n\t\t\tmemcpy(&addr6->sin6_addr, &p6->IPv6Address, 16);\n\n\t\t\t \n\t\t\taddr6->sin6_flowinfo = 0;\n\t\t\taddr6->sin6_scope_id = 0;\n\t\t\taddr6->sin6_port = cpu_to_be16(CIFS_PORT);\n\n\t\t\tcifs_dbg(FYI, \"%s: ipv6 %pI6\\n\", __func__,\n\t\t\t\t &addr6->sin6_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t \"%s: skipping unsupported socket family\\n\",\n\t\t\t\t __func__);\n\t\t\tgoto next_iface;\n\t\t}\n\n\t\t \n\t\tspin_lock(&ses->iface_lock);\n\t\tlist_for_each_entry_safe(iface, niface, &ses->iface_list,\n\t\t\t\t\t iface_head) {\n\t\t\tret = iface_cmp(iface, &tmp_iface);\n\t\t\tif (!ret) {\n\t\t\t\tiface->is_active = 1;\n\t\t\t\tspin_unlock(&ses->iface_lock);\n\t\t\t\tgoto next_iface;\n\t\t\t} else if (ret < 0) {\n\t\t\t\t \n\t\t\t\tkref_get(&iface->refcount);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&ses->iface_lock);\n\n\t\t \n\t\tinfo = kmalloc(sizeof(struct cifs_server_iface),\n\t\t\t       GFP_KERNEL);\n\t\tif (!info) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(info, &tmp_iface, sizeof(tmp_iface));\n\n\t\t \n\t\tkref_init(&info->refcount);\n\t\tinfo->is_active = 1;\n\n\t\tcifs_dbg(FYI, \"%s: adding iface %zu\\n\", __func__, ses->iface_count);\n\t\tcifs_dbg(FYI, \"%s: speed %zu bps\\n\", __func__, info->speed);\n\t\tcifs_dbg(FYI, \"%s: capabilities 0x%08x\\n\", __func__,\n\t\t\t le32_to_cpu(p->Capability));\n\n\t\tspin_lock(&ses->iface_lock);\n\t\tif (!list_entry_is_head(iface, &ses->iface_list, iface_head)) {\n\t\t\tlist_add_tail(&info->iface_head, &iface->iface_head);\n\t\t\tkref_put(&iface->refcount, release_iface);\n\t\t} else\n\t\t\tlist_add_tail(&info->iface_head, &ses->iface_list);\n\n\t\tses->iface_count++;\n\t\tspin_unlock(&ses->iface_lock);\n\t\tses->iface_last_update = jiffies;\nnext_iface:\n\t\tnb_iface++;\n\t\tnext = le32_to_cpu(p->Next);\n\t\tif (!next) {\n\t\t\tbytes_left -= sizeof(*p);\n\t\t\tbreak;\n\t\t}\n\t\tp = (struct network_interface_info_ioctl_rsp *)((u8 *)p+next);\n\t\tbytes_left -= next;\n\t}\n\n\tif (!nb_iface) {\n\t\tcifs_dbg(VFS, \"%s: malformed interface info\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((bytes_left > 8) || p->Next)\n\t\tcifs_dbg(VFS, \"%s: incomplete interface info\\n\", __func__);\n\n\n\tif (!ses->iface_count) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\t \n\tspin_lock(&ses->iface_lock);\n\tlist_for_each_entry_safe(iface, niface, &ses->iface_list,\n\t\t\t\t iface_head) {\n\t\tif (!iface->is_active) {\n\t\t\tlist_del(&iface->iface_head);\n\t\t\tkref_put(&iface->refcount, release_iface);\n\t\t\tses->iface_count--;\n\t\t}\n\t}\n\tspin_unlock(&ses->iface_lock);\n\n\treturn rc;\n}\n\nint\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon, bool in_mount)\n{\n\tint rc;\n\tunsigned int ret_data_len = 0;\n\tstruct network_interface_info_ioctl_rsp *out_buf = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *pserver;\n\n\t \n\tif (ses->iface_last_update &&\n\t    time_before(jiffies, ses->iface_last_update +\n\t\t\t(SMB_INTERFACE_POLL_INTERVAL * HZ)))\n\t\treturn 0;\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\tFSCTL_QUERY_NETWORK_INTERFACE_INFO,\n\t\t\tNULL  , 0  ,\n\t\t\tCIFSMaxBufSize, (char **)&out_buf, &ret_data_len);\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_dbg(FYI,\n\t\t\t \"server does not support query network interfaces\\n\");\n\t\tret_data_len = 0;\n\t} else if (rc != 0) {\n\t\tcifs_tcon_dbg(VFS, \"error %d on ioctl to get interface list\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = parse_server_interfaces(out_buf, ret_data_len, ses, in_mount);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tspin_lock(&ses->chan_lock);\n\tpserver = ses->chans[0].server;\n\tif (pserver && !cifs_chan_is_iface_active(ses, pserver)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tcifs_chan_update_iface(ses, pserver);\n\t\tspin_lock(&ses->chan_lock);\n\t}\n\tspin_unlock(&ses->chan_lock);\n\nout:\n\tkfree(out_buf);\n\treturn rc;\n}\n\nstatic void\nsmb3_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\t__le16 srch_path = 0;  \n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tstruct cached_fid *cfid = NULL;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = \"\",\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = open_cached_dir(xid, tcon, \"\", cifs_sb, false, &cfid);\n\tif (rc == 0)\n\t\tmemcpy(&fid, &cfid->fid, sizeof(struct cifs_fid));\n\telse\n\t\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL,\n\t\t\t       NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n\tSMB3_request_interfaces(xid, tcon, true  );\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_VOLUME_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_SECTOR_SIZE_INFORMATION);  \n\tif (cfid == NULL)\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\telse\n\t\tclose_cached_dir(cfid);\n}\n\nstatic void\nsmb2_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\t__le16 srch_path = 0;  \n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = \"\",\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL,\n\t\t       NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n}\n\nstatic int\nsmb2_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tint err_buftype = CIFS_NO_BUFFER;\n\tstruct cifs_open_parms oparms;\n\tstruct kvec err_iov = {};\n\tstruct cifs_fid fid;\n\tstruct cached_fid *cfid;\n\tbool islink;\n\tint rc, rc2;\n\n\trc = open_cached_dir(xid, tcon, full_path, cifs_sb, true, &cfid);\n\tif (!rc) {\n\t\tif (cfid->has_lease) {\n\t\t\tclose_cached_dir(cfid);\n\t\t\treturn 0;\n\t\t}\n\t\tclose_cached_dir(cfid);\n\t}\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = full_path,\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,\n\t\t       &err_iov, &err_buftype);\n\tif (rc) {\n\t\tstruct smb2_hdr *hdr = err_iov.iov_base;\n\n\t\tif (unlikely(!hdr || err_buftype == CIFS_NO_BUFFER))\n\t\t\tgoto out;\n\n\t\tif (rc != -EREMOTE && hdr->Status == STATUS_OBJECT_NAME_INVALID) {\n\t\t\trc2 = cifs_inval_name_dfs_link_error(xid, tcon, cifs_sb,\n\t\t\t\t\t\t\t     full_path, &islink);\n\t\t\tif (rc2) {\n\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (islink)\n\t\t\t\trc = -EREMOTE;\n\t\t}\n\t\tif (rc == -EREMOTE && IS_ENABLED(CONFIG_CIFS_DFS_UPCALL) && cifs_sb &&\n\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS))\n\t\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\nout:\n\tfree_rsp_buf(err_buftype, err_iov.iov_base);\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nstatic int smb2_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t\t     u64 *uniqueid, struct cifs_open_info_data *data)\n{\n\t*uniqueid = le64_to_cpu(data->fi.IndexNumber);\n\treturn 0;\n}\n\nstatic int smb2_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\tstruct cifsFileInfo *cfile, struct cifs_open_info_data *data)\n{\n\tstruct cifs_fid *fid = &cfile->fid;\n\n\tif (cfile->symlink_target) {\n\t\tdata->symlink_target = kstrdup(cfile->symlink_target, GFP_KERNEL);\n\t\tif (!data->symlink_target)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn SMB2_query_info(xid, tcon, fid->persistent_fid, fid->volatile_fid, &data->fi);\n}\n\n#ifdef CONFIG_CIFS_XATTR\nstatic ssize_t\nmove_smb2_ea_to_cifs(char *dst, size_t dst_size,\n\t\t     struct smb2_file_full_ea_info *src, size_t src_size,\n\t\t     const unsigned char *ea_name)\n{\n\tint rc = 0;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\tchar *name, *value;\n\tsize_t buf_size = dst_size;\n\tsize_t name_len, value_len, user_name_len;\n\n\twhile (src_size > 0) {\n\t\tname_len = (size_t)src->ea_name_length;\n\t\tvalue_len = (size_t)le16_to_cpu(src->ea_value_length);\n\n\t\tif (name_len == 0)\n\t\t\tbreak;\n\n\t\tif (src_size < 8 + name_len + 1 + value_len) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname = &src->ea_data[0];\n\t\tvalue = &src->ea_data[src->ea_name_length + 1];\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    memcmp(ea_name, name, name_len) == 0) {\n\t\t\t\trc = value_len;\n\t\t\t\tif (dst_size == 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (dst_size < value_len) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, value, value_len);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tuser_name_len = 5 + 1 + name_len;\n\n\t\t\tif (buf_size == 0) {\n\t\t\t\t \n\t\t\t\trc += user_name_len;\n\t\t\t} else if (dst_size >= user_name_len) {\n\t\t\t\tdst_size -= user_name_len;\n\t\t\t\tmemcpy(dst, \"user.\", 5);\n\t\t\t\tdst += 5;\n\t\t\t\tmemcpy(dst, src->ea_data, name_len);\n\t\t\t\tdst += name_len;\n\t\t\t\t*dst = 0;\n\t\t\t\t++dst;\n\t\t\t\trc += user_name_len;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!src->next_entry_offset)\n\t\t\tbreak;\n\n\t\tif (src_size < le32_to_cpu(src->next_entry_offset)) {\n\t\t\t \n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_size -= le32_to_cpu(src->next_entry_offset);\n\t\tsrc = (void *)((char *)src +\n\t\t\t       le32_to_cpu(src->next_entry_offset));\n\t}\n\n\t \n\tif (ea_name)\n\t\trc = -ENODATA;\n\nout:\n\treturn (ssize_t)rc;\n}\n\nstatic ssize_t\nsmb2_query_eas(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const unsigned char *path, const unsigned char *ea_name,\n\t       char *ea_data, size_t buf_size,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_file_full_ea_info *info = NULL;\n\n\trc = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t      CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc) {\n\t\t \n\t\tif (!ea_name && rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto qeas_exit;\n\t}\n\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_file_full_ea_info));\n\tif (rc)\n\t\tgoto qeas_exit;\n\n\tinfo = (struct smb2_file_full_ea_info *)(\n\t\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = move_smb2_ea_to_cifs(ea_data, buf_size, info,\n\t\t\tle32_to_cpu(rsp->OutputBufferLength), ea_name);\n\n qeas_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nstatic int\nsmb2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *path, const char *ea_name, const void *ea_value,\n\t    const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb2_compound_vars *vars;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct smb_rqst *rqst;\n\tstruct kvec *rsp_iov;\n\t__le16 *utf16_path = NULL;\n\tint ea_name_len = strlen(ea_name);\n\tint flags = CIFS_CP_CREATE_CLOSE_OP;\n\tint len;\n\tint resp_buftype[3];\n\tstruct cifs_open_parms oparms;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_fid fid;\n\tunsigned int size[1];\n\tvoid *data[1];\n\tstruct smb2_file_full_ea_info *ea = NULL;\n\tstruct smb2_query_info_rsp *rsp;\n\tint rc, used_len = 0;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (ea_name_len > 255)\n\t\treturn -EINVAL;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n\tif (!vars) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_path;\n\t}\n\trqst = vars->rqst;\n\trsp_iov = vars->rsp_iov;\n\n\tif (ses->server->ops->query_all_EAs) {\n\t\tif (!ea_value) {\n\t\t\trc = ses->server->ops->query_all_EAs(xid, tcon, path,\n\t\t\t\t\t\t\t     ea_name, NULL, 0,\n\t\t\t\t\t\t\t     cifs_sb);\n\t\t\tif (rc == -ENODATA)\n\t\t\t\tgoto sea_exit;\n\t\t} else {\n\t\t\t \n\t\t\trc = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t      CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov[1], &resp_buftype[1], cifs_sb);\n\t\t\tif (rc == 0) {\n\t\t\t\trsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;\n\t\t\t\tused_len = le32_to_cpu(rsp->OutputBufferLength);\n\t\t\t}\n\t\t\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\t\t\tresp_buftype[1] = CIFS_NO_BUFFER;\n\t\t\tmemset(&rsp_iov[1], 0, sizeof(rsp_iov[1]));\n\t\t\trc = 0;\n\n\t\t\t \n\t\t\tif (CIFSMaxBufSize - MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t   MAX_SMB2_CLOSE_RESPONSE_SIZE - 256 <\n\t\t\t   used_len + ea_name_len + ea_value_len + 1) {\n\t\t\t\trc = -ENOSPC;\n\t\t\t\tgoto sea_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trqst[0].rq_iov = vars->open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access = FILE_WRITE_EA,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\n\t \n\trqst[1].rq_iov = vars->si_iov;\n\trqst[1].rq_nvec = 1;\n\n\tlen = sizeof(*ea) + ea_name_len + ea_value_len + 1;\n\tea = kzalloc(len, GFP_KERNEL);\n\tif (ea == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto sea_exit;\n\t}\n\n\tea->ea_name_length = ea_name_len;\n\tea->ea_value_length = cpu_to_le16(ea_value_len);\n\tmemcpy(ea->ea_data, ea_name, ea_name_len + 1);\n\tmemcpy(ea->ea_data + ea_name_len + 1, ea_value, ea_value_len);\n\n\tsize[0] = len;\n\tdata[0] = ea;\n\n\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t&rqst[1], COMPOUND_FID,\n\t\t\t\tCOMPOUND_FID, current->tgid,\n\t\t\t\tFILE_FULL_EA_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\tif (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[1]);\n\tsmb2_set_related(&rqst[1]);\n\n\t \n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID, false);\n\tif (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_related(&rqst[2]);\n\n\trc = compound_send_recv(xid, ses, server,\n\t\t\t\tflags, 3, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\t \n\n sea_exit:\n\tkfree(ea);\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_set_info_free(&rqst[1]);\n\tSMB2_close_free(&rqst[2]);\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\tkfree(vars);\nout_free_path:\n\tkfree(utf16_path);\n\treturn rc;\n}\n#endif\n\nstatic bool\nsmb2_can_echo(struct TCP_Server_Info *server)\n{\n\treturn server->echoes;\n}\n\nstatic void\nsmb2_clear_stats(struct cifs_tcon *tcon)\n{\n\tint i;\n\n\tfor (i = 0; i < NUMBER_OF_SMB2_COMMANDS; i++) {\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_sent[i], 0);\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_failed[i], 0);\n\t}\n}\n\nstatic void\nsmb2_dump_share_caps(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tseq_puts(m, \"\\n\\tShare Capabilities:\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_DFS)\n\t\tseq_puts(m, \" DFS,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t\tseq_puts(m, \" CONTINUOUS AVAILABILITY,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT)\n\t\tseq_puts(m, \" SCALEOUT,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER)\n\t\tseq_puts(m, \" CLUSTER,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_ASYMMETRIC)\n\t\tseq_puts(m, \" ASYMMETRIC,\");\n\tif (tcon->capabilities == 0)\n\t\tseq_puts(m, \" None\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_ALIGNED_DEVICE)\n\t\tseq_puts(m, \" Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE)\n\t\tseq_puts(m, \" Partition Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_NO_SEEK_PENALTY)\n\t\tseq_puts(m, \" SSD,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_TRIM_ENABLED)\n\t\tseq_puts(m, \" TRIM-support,\");\n\n\tseq_printf(m, \"\\tShare Flags: 0x%x\", tcon->share_flags);\n\tseq_printf(m, \"\\n\\ttid: 0x%x\", tcon->tid);\n\tif (tcon->perf_sector_size)\n\t\tseq_printf(m, \"\\tOptimal sector size: 0x%x\",\n\t\t\t   tcon->perf_sector_size);\n\tseq_printf(m, \"\\tMaximal Access: 0x%x\", tcon->maximal_access);\n}\n\nstatic void\nsmb2_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tatomic_t *sent = tcon->stats.smb2_stats.smb2_com_sent;\n\tatomic_t *failed = tcon->stats.smb2_stats.smb2_com_failed;\n\n\t \n\tseq_printf(m, \"\\nBytes read: %llu  Bytes written: %llu\",\n\t\t   (long long)(tcon->bytes_read),\n\t\t   (long long)(tcon->bytes_written));\n\tseq_printf(m, \"\\nOpen files: %d total (local), %d open on server\",\n\t\t   atomic_read(&tcon->num_local_opens),\n\t\t   atomic_read(&tcon->num_remote_opens));\n\tseq_printf(m, \"\\nTreeConnects: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_CONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_CONNECT_HE]));\n\tseq_printf(m, \"\\nTreeDisconnects: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_DISCONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_DISCONNECT_HE]));\n\tseq_printf(m, \"\\nCreates: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_CREATE_HE]),\n\t\t   atomic_read(&failed[SMB2_CREATE_HE]));\n\tseq_printf(m, \"\\nCloses: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_CLOSE_HE]),\n\t\t   atomic_read(&failed[SMB2_CLOSE_HE]));\n\tseq_printf(m, \"\\nFlushes: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_FLUSH_HE]),\n\t\t   atomic_read(&failed[SMB2_FLUSH_HE]));\n\tseq_printf(m, \"\\nReads: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_READ_HE]),\n\t\t   atomic_read(&failed[SMB2_READ_HE]));\n\tseq_printf(m, \"\\nWrites: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_WRITE_HE]),\n\t\t   atomic_read(&failed[SMB2_WRITE_HE]));\n\tseq_printf(m, \"\\nLocks: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_LOCK_HE]),\n\t\t   atomic_read(&failed[SMB2_LOCK_HE]));\n\tseq_printf(m, \"\\nIOCTLs: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_IOCTL_HE]),\n\t\t   atomic_read(&failed[SMB2_IOCTL_HE]));\n\tseq_printf(m, \"\\nQueryDirectories: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_DIRECTORY_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_DIRECTORY_HE]));\n\tseq_printf(m, \"\\nChangeNotifies: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_CHANGE_NOTIFY_HE]),\n\t\t   atomic_read(&failed[SMB2_CHANGE_NOTIFY_HE]));\n\tseq_printf(m, \"\\nQueryInfos: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_INFO_HE]));\n\tseq_printf(m, \"\\nSetInfos: %d total %d failed\",\n\t\t   atomic_read(&sent[SMB2_SET_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_SET_INFO_HE]));\n\tseq_printf(m, \"\\nOplockBreaks: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_OPLOCK_BREAK_HE]),\n\t\t   atomic_read(&failed[SMB2_OPLOCK_BREAK_HE]));\n}\n\nstatic void\nsmb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tcfile->fid.persistent_fid = fid->persistent_fid;\n\tcfile->fid.volatile_fid = fid->volatile_fid;\n\tcfile->fid.access = fid->access;\n#ifdef CONFIG_CIFS_DEBUG2\n\tcfile->fid.mid = fid->mid;\n#endif  \n\tserver->ops->set_oplock_level(cinode, oplock, fid->epoch,\n\t\t\t\t      &fid->purge_cache);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n\tmemcpy(cfile->fid.create_guid, fid->create_guid, 16);\n}\n\nstatic void\nsmb2_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}\n\nstatic void\nsmb2_close_getattr(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\tstruct smb2_file_network_open_info file_inf;\n\tstruct inode *inode;\n\tint rc;\n\n\trc = __SMB2_close(xid, tcon, cfile->fid.persistent_fid,\n\t\t   cfile->fid.volatile_fid, &file_inf);\n\tif (rc)\n\t\treturn;\n\n\tinode = d_inode(cfile->dentry);\n\n\tspin_lock(&inode->i_lock);\n\tCIFS_I(inode)->time = jiffies;\n\n\t \n\tif (file_inf.LastWriteTime)\n\t\tinode_set_mtime_to_ts(inode,\n\t\t\t\t      cifs_NTtimeToUnix(file_inf.LastWriteTime));\n\tif (file_inf.ChangeTime)\n\t\tinode_set_ctime_to_ts(inode,\n\t\t\t\t      cifs_NTtimeToUnix(file_inf.ChangeTime));\n\tif (file_inf.LastAccessTime)\n\t\tinode_set_atime_to_ts(inode,\n\t\t\t\t      cifs_NTtimeToUnix(file_inf.LastAccessTime));\n\n\t \n\tif (le64_to_cpu(file_inf.AllocationSize) > 4096)\n\t\tinode->i_blocks =\n\t\t\t(512 - 1 + le64_to_cpu(file_inf.AllocationSize)) >> 9;\n\n\t \n\tspin_unlock(&inode->i_lock);\n}\n\nstatic int\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, NULL, 0  ,\n\t\t\tCIFSMaxBufSize, (char **)&res_key, &ret_data_len);\n\n\tif (rc == -EOPNOTSUPP) {\n\t\tpr_warn_once(\"Server share %s does not support copy range\\n\", tcon->tree_name);\n\t\tgoto req_res_key_exit;\n\t} else if (rc) {\n\t\tcifs_tcon_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_tcon_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\n\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}\n\nstatic int\nsmb2_ioctl_query_info(const unsigned int xid,\n\t\t      struct cifs_tcon *tcon,\n\t\t      struct cifs_sb_info *cifs_sb,\n\t\t      __le16 *path, int is_dir,\n\t\t      unsigned long p)\n{\n\tstruct smb2_compound_vars *vars;\n\tstruct smb_rqst *rqst;\n\tstruct kvec *rsp_iov;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tchar __user *arg = (char __user *)p;\n\tstruct smb_query_info qi;\n\tstruct smb_query_info __user *pqi;\n\tint rc = 0;\n\tint flags = CIFS_CP_CREATE_CLOSE_OP;\n\tstruct smb2_query_info_rsp *qi_rsp = NULL;\n\tstruct smb2_ioctl_rsp *io_rsp = NULL;\n\tvoid *buffer = NULL;\n\tint resp_buftype[3];\n\tstruct cifs_open_parms oparms;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_fid fid;\n\tunsigned int size[2];\n\tvoid *data[2];\n\tint create_options = is_dir ? CREATE_NOT_FILE : CREATE_NOT_DIR;\n\tvoid (*free_req1_func)(struct smb_rqst *r);\n\n\tvars = kzalloc(sizeof(*vars), GFP_ATOMIC);\n\tif (vars == NULL)\n\t\treturn -ENOMEM;\n\trqst = &vars->rqst[0];\n\trsp_iov = &vars->rsp_iov[0];\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\n\tif (copy_from_user(&qi, arg, sizeof(struct smb_query_info))) {\n\t\trc = -EFAULT;\n\t\tgoto free_vars;\n\t}\n\tif (qi.output_buffer_length > 1024) {\n\t\trc = -EINVAL;\n\t\tgoto free_vars;\n\t}\n\n\tif (!ses || !server) {\n\t\trc = -EIO;\n\t\tgoto free_vars;\n\t}\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (qi.output_buffer_length) {\n\t\tbuffer = memdup_user(arg + sizeof(struct smb_query_info), qi.output_buffer_length);\n\t\tif (IS_ERR(buffer)) {\n\t\t\trc = PTR_ERR(buffer);\n\t\t\tgoto free_vars;\n\t\t}\n\t}\n\n\t \n\trqst[0].rq_iov = &vars->open_iov[0];\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, create_options),\n\t\t.fid = &fid,\n\t};\n\n\tif (qi.flags & PASSTHRU_FSCTL) {\n\t\tswitch (qi.info_type & FSCTL_DEVICE_ACCESS_MASK) {\n\t\tcase FSCTL_DEVICE_ACCESS_FILE_READ_WRITE_ACCESS:\n\t\t\toparms.desired_access = FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE;\n\t\t\tbreak;\n\t\tcase FSCTL_DEVICE_ACCESS_FILE_ANY_ACCESS:\n\t\t\toparms.desired_access = GENERIC_ALL;\n\t\t\tbreak;\n\t\tcase FSCTL_DEVICE_ACCESS_FILE_READ_ACCESS:\n\t\t\toparms.desired_access = GENERIC_READ;\n\t\t\tbreak;\n\t\tcase FSCTL_DEVICE_ACCESS_FILE_WRITE_ACCESS:\n\t\t\toparms.desired_access = GENERIC_WRITE;\n\t\t\tbreak;\n\t\t}\n\t} else if (qi.flags & PASSTHRU_SET_INFO) {\n\t\toparms.desired_access = GENERIC_WRITE;\n\t} else {\n\t\toparms.desired_access = FILE_READ_ATTRIBUTES | READ_CONTROL;\n\t}\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, path);\n\tif (rc)\n\t\tgoto free_output_buffer;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\t \n\tif (qi.flags & PASSTHRU_FSCTL) {\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tgoto free_open_req;\n\t\t}\n\t\trqst[1].rq_iov = &vars->io_iov[0];\n\t\trqst[1].rq_nvec = SMB2_IOCTL_IOV_SIZE;\n\n\t\trc = SMB2_ioctl_init(tcon, server, &rqst[1], COMPOUND_FID, COMPOUND_FID,\n\t\t\t\t     qi.info_type, buffer, qi.output_buffer_length,\n\t\t\t\t     CIFSMaxBufSize - MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t     MAX_SMB2_CLOSE_RESPONSE_SIZE);\n\t\tfree_req1_func = SMB2_ioctl_free;\n\t} else if (qi.flags == PASSTHRU_SET_INFO) {\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tgoto free_open_req;\n\t\t}\n\t\tif (qi.output_buffer_length < 8) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_open_req;\n\t\t}\n\t\trqst[1].rq_iov = vars->si_iov;\n\t\trqst[1].rq_nvec = 1;\n\n\t\t \n\t\tsize[0] = 8;\n\t\tdata[0] = buffer;\n\n\t\trc = SMB2_set_info_init(tcon, server, &rqst[1], COMPOUND_FID, COMPOUND_FID,\n\t\t\t\t\tcurrent->tgid, FILE_END_OF_FILE_INFORMATION,\n\t\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\tfree_req1_func = SMB2_set_info_free;\n\t} else if (qi.flags == PASSTHRU_QUERY_INFO) {\n\t\trqst[1].rq_iov = &vars->qi_iov;\n\t\trqst[1].rq_nvec = 1;\n\n\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t  &rqst[1], COMPOUND_FID,\n\t\t\t\t  COMPOUND_FID, qi.file_info_class,\n\t\t\t\t  qi.info_type, qi.additional_information,\n\t\t\t\t  qi.input_buffer_length,\n\t\t\t\t  qi.output_buffer_length, buffer);\n\t\tfree_req1_func = SMB2_query_info_free;\n\t} else {  \n\t\tcifs_tcon_dbg(VFS, \"Invalid passthru query flags: 0x%x\\n\",\n\t\t\t      qi.flags);\n\t\trc = -EINVAL;\n\t}\n\n\tif (rc)\n\t\tgoto free_open_req;\n\tsmb2_set_next_command(tcon, &rqst[1]);\n\tsmb2_set_related(&rqst[1]);\n\n\t \n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID, false);\n\tif (rc)\n\t\tgoto free_req_1;\n\tsmb2_set_related(&rqst[2]);\n\n\trc = compound_send_recv(xid, ses, server,\n\t\t\t\tflags, 3, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (qi.flags & PASSTHRU_FSCTL) {\n\t\tpqi = (struct smb_query_info __user *)arg;\n\t\tio_rsp = (struct smb2_ioctl_rsp *)rsp_iov[1].iov_base;\n\t\tif (le32_to_cpu(io_rsp->OutputCount) < qi.input_buffer_length)\n\t\t\tqi.input_buffer_length = le32_to_cpu(io_rsp->OutputCount);\n\t\tif (qi.input_buffer_length > 0 &&\n\t\t    le32_to_cpu(io_rsp->OutputOffset) + qi.input_buffer_length\n\t\t    > rsp_iov[1].iov_len) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(&pqi->input_buffer_length,\n\t\t\t\t &qi.input_buffer_length,\n\t\t\t\t sizeof(qi.input_buffer_length))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user((void __user *)pqi + sizeof(struct smb_query_info),\n\t\t\t\t (const void *)io_rsp + le32_to_cpu(io_rsp->OutputOffset),\n\t\t\t\t qi.input_buffer_length))\n\t\t\trc = -EFAULT;\n\t} else {\n\t\tpqi = (struct smb_query_info __user *)arg;\n\t\tqi_rsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;\n\t\tif (le32_to_cpu(qi_rsp->OutputBufferLength) < qi.input_buffer_length)\n\t\t\tqi.input_buffer_length = le32_to_cpu(qi_rsp->OutputBufferLength);\n\t\tif (copy_to_user(&pqi->input_buffer_length,\n\t\t\t\t &qi.input_buffer_length,\n\t\t\t\t sizeof(qi.input_buffer_length))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(pqi + 1, qi_rsp->Buffer,\n\t\t\t\t qi.input_buffer_length))\n\t\t\trc = -EFAULT;\n\t}\n\nout:\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\tSMB2_close_free(&rqst[2]);\nfree_req_1:\n\tfree_req1_func(&rqst[1]);\nfree_open_req:\n\tSMB2_open_free(&rqst[0]);\nfree_output_buffer:\n\tkfree(buffer);\nfree_vars:\n\tkfree(vars);\n\treturn rc;\n}\n\nstatic ssize_t\nsmb2_copychunk_range(const unsigned int xid,\n\t\t\tstruct cifsFileInfo *srcfile,\n\t\t\tstruct cifsFileInfo *trgtfile, u64 src_off,\n\t\t\tu64 len, u64 dest_off)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct copychunk_ioctl *pcchunk;\n\tstruct copychunk_ioctl_rsp *retbuf = NULL;\n\tstruct cifs_tcon *tcon;\n\tint chunks_copied = 0;\n\tbool chunk_sizes_updated = false;\n\tssize_t bytes_written, total_bytes_written = 0;\n\n\tpcchunk = kmalloc(sizeof(struct copychunk_ioctl), GFP_KERNEL);\n\tif (pcchunk == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"%s: about to call request res key\\n\", __func__);\n\t \n\trc = SMB2_request_res_key(xid, tlink_tcon(srcfile->tlink),\n\t\t\t\tsrcfile->fid.persistent_fid,\n\t\t\t\tsrcfile->fid.volatile_fid, pcchunk);\n\n\t \n\tif (rc)\n\t\tgoto cchunk_out;\n\n\t \n\tpcchunk->ChunkCount = cpu_to_le32(1);\n\tpcchunk->Reserved = 0;\n\tpcchunk->Reserved2 = 0;\n\n\ttcon = tlink_tcon(trgtfile->tlink);\n\n\twhile (len > 0) {\n\t\tpcchunk->SourceOffset = cpu_to_le64(src_off);\n\t\tpcchunk->TargetOffset = cpu_to_le64(dest_off);\n\t\tpcchunk->Length =\n\t\t\tcpu_to_le32(min_t(u64, len, tcon->max_bytes_chunk));\n\n\t\t \n\t\tkfree(retbuf);\n\t\tretbuf = NULL;\n\t\trc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\n\t\t\ttrgtfile->fid.volatile_fid, FSCTL_SRV_COPYCHUNK_WRITE,\n\t\t\t(char *)pcchunk, sizeof(struct copychunk_ioctl),\n\t\t\tCIFSMaxBufSize, (char **)&retbuf, &ret_data_len);\n\t\tif (rc == 0) {\n\t\t\tif (ret_data_len !=\n\t\t\t\t\tsizeof(struct copychunk_ioctl_rsp)) {\n\t\t\t\tcifs_tcon_dbg(VFS, \"Invalid cchunk response size\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (retbuf->TotalBytesWritten == 0) {\n\t\t\t\tcifs_dbg(FYI, \"no bytes copied\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\t \n\t\t\tif (le32_to_cpu(retbuf->TotalBytesWritten) >\n\t\t\t    le32_to_cpu(pcchunk->Length)) {\n\t\t\t\tcifs_tcon_dbg(VFS, \"Invalid copy chunk response\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (le32_to_cpu(retbuf->ChunksWritten) != 1) {\n\t\t\t\tcifs_tcon_dbg(VFS, \"Invalid num chunks written\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tchunks_copied++;\n\n\t\t\tbytes_written = le32_to_cpu(retbuf->TotalBytesWritten);\n\t\t\tsrc_off += bytes_written;\n\t\t\tdest_off += bytes_written;\n\t\t\tlen -= bytes_written;\n\t\t\ttotal_bytes_written += bytes_written;\n\n\t\t\tcifs_dbg(FYI, \"Chunks %d PartialChunk %d Total %zu\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tbytes_written);\n\t\t} else if (rc == -EINVAL) {\n\t\t\tif (ret_data_len != sizeof(struct copychunk_ioctl_rsp))\n\t\t\t\tgoto cchunk_out;\n\n\t\t\tcifs_dbg(FYI, \"MaxChunks %d BytesChunk %d MaxCopy %d\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tle32_to_cpu(retbuf->TotalBytesWritten));\n\n\t\t\t \n\t\t\tif ((chunks_copied != 0) || chunk_sizes_updated)\n\t\t\t\tgoto cchunk_out;\n\n\t\t\t \n\t\t\tif (le32_to_cpu(retbuf->ChunkBytesWritten) <\n\t\t\t\t\ttcon->max_bytes_chunk)\n\t\t\t\ttcon->max_bytes_chunk =\n\t\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten);\n\t\t\telse\n\t\t\t\tgoto cchunk_out;  \n\n\t\t\t \n\t\t\tchunk_sizes_updated = true;\n\t\t} else\n\t\t\tgoto cchunk_out;\n\t}\n\ncchunk_out:\n\tkfree(pcchunk);\n\tkfree(retbuf);\n\tif (rc)\n\t\treturn rc;\n\telse\n\t\treturn total_bytes_written;\n}\n\nstatic int\nsmb2_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn SMB2_flush(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}\n\nstatic unsigned int\nsmb2_read_data_offset(char *buf)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\n\treturn rsp->DataOffset;\n}\n\nstatic unsigned int\nsmb2_read_data_length(char *buf, bool in_remaining)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\n\tif (in_remaining)\n\t\treturn le32_to_cpu(rsp->DataRemaining);\n\n\treturn le32_to_cpu(rsp->DataLength);\n}\n\n\nstatic int\nsmb2_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_read(xid, parms, bytes_read, buf, buf_type);\n}\n\nstatic int\nsmb2_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_write(xid, parms, written, iov, nr_segs);\n}\n\n \nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t \n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true;  \n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true;  \n\n\t \n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\t&setsparse, 1, CIFSMaxBufSize, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}\n\nstatic int\nsmb2_set_file_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\tstruct inode *inode;\n\n\t \n\tinode = d_inode(cfile->dentry);\n\n\tif (!set_alloc && (size > inode->i_size + 8192)) {\n\t\t__u8 set_sparse = 1;\n\n\t\t \n\t\tsmb2_set_sparse(xid, tcon, cfile, inode, set_sparse);\n\t}\n\n\treturn SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid, cfile->pid, &eof);\n}\n\nstatic int\nsmb2_duplicate_extents(const unsigned int xid,\n\t\t\tstruct cifsFileInfo *srcfile,\n\t\t\tstruct cifsFileInfo *trgtfile, u64 src_off,\n\t\t\tu64 len, u64 dest_off)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct inode *inode;\n\tstruct duplicate_extents_to_file dup_ext_buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(trgtfile->tlink);\n\n\t \n\tif ((le32_to_cpu(tcon->fsAttrInfo.Attributes) &\n\t     FILE_SUPPORTS_BLOCK_REFCOUNTING) == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tdup_ext_buf.VolatileFileHandle = srcfile->fid.volatile_fid;\n\tdup_ext_buf.PersistentFileHandle = srcfile->fid.persistent_fid;\n\tdup_ext_buf.SourceFileOffset = cpu_to_le64(src_off);\n\tdup_ext_buf.TargetFileOffset = cpu_to_le64(dest_off);\n\tdup_ext_buf.ByteCount = cpu_to_le64(len);\n\tcifs_dbg(FYI, \"Duplicate extents: src off %lld dst off %lld len %lld\\n\",\n\t\tsrc_off, dest_off, len);\n\n\tinode = d_inode(trgtfile->dentry);\n\tif (inode->i_size < dest_off + len) {\n\t\trc = smb2_set_file_size(xid, tcon, trgtfile, dest_off + len, false);\n\t\tif (rc)\n\t\t\tgoto duplicate_extents_out;\n\n\t\t \n\t\tcifs_setsize(inode, dest_off + len);\n\t}\n\trc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\n\t\t\ttrgtfile->fid.volatile_fid,\n\t\t\tFSCTL_DUPLICATE_EXTENTS_TO_FILE,\n\t\t\t(char *)&dup_ext_buf,\n\t\t\tsizeof(struct duplicate_extents_to_file),\n\t\t\tCIFSMaxBufSize, NULL,\n\t\t\t&ret_data_len);\n\n\tif (ret_data_len > 0)\n\t\tcifs_dbg(FYI, \"Non-zero response length in duplicate extents\\n\");\n\nduplicate_extents_out:\n\treturn rc;\n}\n\nstatic int\nsmb2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn SMB2_set_compression(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid);\n}\n\nstatic int\nsmb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\tstruct fsctl_set_integrity_information_req integr_info;\n\tunsigned int ret_data_len;\n\n\tintegr_info.ChecksumAlgorithm = cpu_to_le16(CHECKSUM_TYPE_UNCHANGED);\n\tintegr_info.Flags = 0;\n\tintegr_info.Reserved = 0;\n\n\treturn SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid,\n\t\t\tFSCTL_SET_INTEGRITY_INFORMATION,\n\t\t\t(char *)&integr_info,\n\t\t\tsizeof(struct fsctl_set_integrity_information_req),\n\t\t\tCIFSMaxBufSize, NULL,\n\t\t\t&ret_data_len);\n\n}\n\n \n#define GMT_TOKEN_SIZE 50\n\n#define MIN_SNAPSHOT_ARRAY_SIZE 16  \n\n \nstatic int\nsmb3_enum_snapshots(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, void __user *ioc_buf)\n{\n\tchar *retbuf = NULL;\n\tunsigned int ret_data_len = 0;\n\tint rc;\n\tu32 max_response_size;\n\tstruct smb_snapshot_array snapshot_in;\n\n\t \n\tif (get_user(ret_data_len, (unsigned int __user *)ioc_buf))\n\t\treturn -EFAULT;\n\n\t \n\tif (ret_data_len == 0)\n\t\tmax_response_size = MIN_SNAPSHOT_ARRAY_SIZE;\n\telse\n\t\tmax_response_size = CIFSMaxBufSize;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid,\n\t\t\tFSCTL_SRV_ENUMERATE_SNAPSHOTS,\n\t\t\tNULL, 0  , max_response_size,\n\t\t\t(char **)&retbuf,\n\t\t\t&ret_data_len);\n\tcifs_dbg(FYI, \"enum snaphots ioctl returned %d and ret buflen is %d\\n\",\n\t\t\trc, ret_data_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ret_data_len && (ioc_buf != NULL) && (retbuf != NULL)) {\n\t\t \n\t\tif (copy_from_user(&snapshot_in, ioc_buf,\n\t\t    sizeof(struct smb_snapshot_array))) {\n\t\t\trc = -EFAULT;\n\t\t\tkfree(retbuf);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tif (snapshot_in.snapshot_array_size < GMT_TOKEN_SIZE)\n\t\t\tret_data_len = sizeof(struct smb_snapshot_array);\n\n\t\t \n\t\tif (ret_data_len > (snapshot_in.snapshot_array_size +\n\t\t\t\t\tsizeof(struct smb_snapshot_array)))\n\t\t\tret_data_len = snapshot_in.snapshot_array_size +\n\t\t\t\t\tsizeof(struct smb_snapshot_array);\n\n\t\tif (copy_to_user(ioc_buf, retbuf, ret_data_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(retbuf);\n\treturn rc;\n}\n\n\n\nstatic int\nsmb3_notify(const unsigned int xid, struct file *pfile,\n\t    void __user *ioc_buf, bool return_changes)\n{\n\tstruct smb3_notify_info notify;\n\tstruct smb3_notify_info __user *pnotify_buf;\n\tstruct dentry *dentry = pfile->f_path.dentry;\n\tstruct inode *inode = file_inode(pfile);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tstruct cifs_tcon *tcon;\n\tconst unsigned char *path;\n\tchar *returned_ioctl_info = NULL;\n\tvoid *page = alloc_dentry_path();\n\t__le16 *utf16_path = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tint rc = 0;\n\t__u32 ret_len = 0;\n\n\tpath = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(path)) {\n\t\trc = PTR_ERR(path);\n\t\tgoto notify_exit;\n\t}\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (utf16_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto notify_exit;\n\t}\n\n\tif (return_changes) {\n\t\tif (copy_from_user(&notify, ioc_buf, sizeof(struct smb3_notify_info))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto notify_exit;\n\t\t}\n\t} else {\n\t\tif (copy_from_user(&notify, ioc_buf, sizeof(struct smb3_notify))) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto notify_exit;\n\t\t}\n\t\tnotify.data_len = 0;\n\t}\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access = FILE_READ_ATTRIBUTES | FILE_READ_DATA,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tif (rc)\n\t\tgoto notify_exit;\n\n\trc = SMB2_change_notify(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\t\tnotify.watch_tree, notify.completion_filter,\n\t\t\t\tnotify.data_len, &returned_ioctl_info, &ret_len);\n\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\n\tcifs_dbg(FYI, \"change notify for path %s rc %d\\n\", path, rc);\n\tif (return_changes && (ret_len > 0) && (notify.data_len > 0)) {\n\t\tif (ret_len > notify.data_len)\n\t\t\tret_len = notify.data_len;\n\t\tpnotify_buf = (struct smb3_notify_info __user *)ioc_buf;\n\t\tif (copy_to_user(pnotify_buf->notify_data, returned_ioctl_info, ret_len))\n\t\t\trc = -EFAULT;\n\t\telse if (copy_to_user(&pnotify_buf->data_len, &ret_len, sizeof(ret_len)))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(returned_ioctl_info);\nnotify_exit:\n\tfree_dentry_path(page);\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nstatic int\nsmb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\t__le16 *utf16_path;\n\tstruct smb_rqst rqst[2];\n\tstruct kvec rsp_iov[2];\n\tint resp_buftype[2];\n\tstruct kvec open_iov[SMB2_CREATE_IOV_SIZE];\n\tstruct kvec qd_iov[SMB2_QUERY_DIRECTORY_IOV_SIZE];\n\tint rc, flags = 0;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct smb2_query_directory_rsp *qd_rsp = NULL;\n\tstruct smb2_create_rsp *op_rsp = NULL;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\tint retry_count = 0;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(rqst, 0, sizeof(rqst));\n\tresp_buftype[0] = resp_buftype[1] = CIFS_NO_BUFFER;\n\tmemset(rsp_iov, 0, sizeof(rsp_iov));\n\n\t \n\tmemset(&open_iov, 0, sizeof(open_iov));\n\trqst[0].rq_iov = open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access = FILE_READ_ATTRIBUTES | FILE_READ_DATA,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = fid,\n\t};\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto qdf_free;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\t \n\tsrch_inf->entries_in_buffer = 0;\n\tsrch_inf->index_of_last_entry = 2;\n\n\tmemset(&qd_iov, 0, sizeof(qd_iov));\n\trqst[1].rq_iov = qd_iov;\n\trqst[1].rq_nvec = SMB2_QUERY_DIRECTORY_IOV_SIZE;\n\n\trc = SMB2_query_directory_init(xid, tcon, server,\n\t\t\t\t       &rqst[1],\n\t\t\t\t       COMPOUND_FID, COMPOUND_FID,\n\t\t\t\t       0, srch_inf->info_level);\n\tif (rc)\n\t\tgoto qdf_free;\n\n\tsmb2_set_related(&rqst[1]);\n\nagain:\n\trc = compound_send_recv(xid, tcon->ses, server,\n\t\t\t\tflags, 2, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\n\tif (rc == -EAGAIN && retry_count++ < 10)\n\t\tgoto again;\n\n\t \n\top_rsp = (struct smb2_create_rsp *)rsp_iov[0].iov_base;\n\tif (op_rsp == NULL || op_rsp->hdr.Status != STATUS_SUCCESS) {\n\t\tcifs_dbg(FYI, \"query_dir_first: open failed rc=%d\\n\", rc);\n\t\tgoto qdf_free;\n\t}\n\tfid->persistent_fid = op_rsp->PersistentFileId;\n\tfid->volatile_fid = op_rsp->VolatileFileId;\n\n\t \n\tif (rc && rc != -ENODATA) {\n\t\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n\t\tcifs_dbg(FYI, \"query_dir_first: query directory failed rc=%d\\n\", rc);\n\t\ttrace_smb3_query_dir_err(xid, fid->persistent_fid,\n\t\t\t\t\t tcon->tid, tcon->ses->Suid, 0, 0, rc);\n\t\tgoto qdf_free;\n\t}\n\n\tatomic_inc(&tcon->num_remote_opens);\n\n\tqd_rsp = (struct smb2_query_directory_rsp *)rsp_iov[1].iov_base;\n\tif (qd_rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\ttrace_smb3_query_dir_done(xid, fid->persistent_fid,\n\t\t\t\t\t  tcon->tid, tcon->ses->Suid, 0, 0);\n\t\tsrch_inf->endOfSearch = true;\n\t\trc = 0;\n\t\tgoto qdf_free;\n\t}\n\n\trc = smb2_parse_query_directory(tcon, &rsp_iov[1], resp_buftype[1],\n\t\t\t\t\tsrch_inf);\n\tif (rc) {\n\t\ttrace_smb3_query_dir_err(xid, fid->persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, 0, 0, rc);\n\t\tgoto qdf_free;\n\t}\n\tresp_buftype[1] = CIFS_NO_BUFFER;\n\n\ttrace_smb3_query_dir_done(xid, fid->persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, 0, srch_inf->entries_in_buffer);\n\n qdf_free:\n\tkfree(utf16_path);\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_query_directory_free(&rqst[1]);\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\treturn rc;\n}\n\nstatic int\nsmb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t    fid->volatile_fid, 0, srch_inf);\n}\n\nstatic int\nsmb2_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn SMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}\n\n \nstatic bool\nsmb2_is_status_pending(char *buf, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tint scredits, in_flight;\n\n\tif (shdr->Status != STATUS_PENDING)\n\t\treturn false;\n\n\tif (shdr->CreditRequest) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(shdr->CreditRequest);\n\t\tscredits = server->credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\n\t\ttrace_smb3_pend_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\tle16_to_cpu(shdr->CreditRequest), in_flight);\n\t\tcifs_dbg(FYI, \"%s: status pending add %u credits total=%d\\n\",\n\t\t\t\t__func__, le16_to_cpu(shdr->CreditRequest), scredits);\n\t}\n\n\treturn true;\n}\n\nstatic bool\nsmb2_is_session_expired(char *buf)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tif (shdr->Status != STATUS_NETWORK_SESSION_EXPIRED &&\n\t    shdr->Status != STATUS_USER_SESSION_DELETED)\n\t\treturn false;\n\n\ttrace_smb3_ses_expired(le32_to_cpu(shdr->Id.SyncId.TreeId),\n\t\t\t       le64_to_cpu(shdr->SessionId),\n\t\t\t       le16_to_cpu(shdr->Command),\n\t\t\t       le64_to_cpu(shdr->MessageId));\n\tcifs_dbg(FYI, \"Session expired or deleted\\n\");\n\n\treturn true;\n}\n\nstatic bool\nsmb2_is_status_io_timeout(char *buf)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tif (shdr->Status == STATUS_IO_TIMEOUT)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool\nsmb2_is_network_name_deleted(char *buf, struct TCP_Server_Info *server)\n{\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\n\tif (shdr->Status != STATUS_NETWORK_NAME_DELETED)\n\t\treturn false;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->tid == le32_to_cpu(shdr->Id.SyncId.TreeId)) {\n\t\t\t\tspin_lock(&tcon->tc_lock);\n\t\t\t\ttcon->need_reconnect = true;\n\t\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\tpr_warn_once(\"Server share %s deleted.\\n\",\n\t\t\t\t\t     tcon->tree_name);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\treturn false;\n}\n\nstatic int\nsmb2_oplock_response(struct cifs_tcon *tcon, __u64 persistent_fid,\n\t\t__u64 volatile_fid, __u16 net_fid, struct cifsInodeInfo *cinode)\n{\n\tif (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\n\t\treturn SMB2_lease_break(0, tcon, cinode->lease_key,\n\t\t\t\t\tsmb2_get_lease_state(cinode));\n\n\treturn SMB2_oplock_break(0, tcon, persistent_fid, volatile_fid,\n\t\t\t\t CIFS_CACHE_READ(cinode) ? 1 : 0);\n}\n\nvoid\nsmb2_set_related(struct smb_rqst *rqst)\n{\n\tstruct smb2_hdr *shdr;\n\n\tshdr = (struct smb2_hdr *)(rqst->rq_iov[0].iov_base);\n\tif (shdr == NULL) {\n\t\tcifs_dbg(FYI, \"shdr NULL in smb2_set_related\\n\");\n\t\treturn;\n\t}\n\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n}\n\nchar smb2_padding[7] = {0, 0, 0, 0, 0, 0, 0};\n\nvoid\nsmb2_set_next_command(struct cifs_tcon *tcon, struct smb_rqst *rqst)\n{\n\tstruct smb2_hdr *shdr;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = ses->server;\n\tunsigned long len = smb_rqst_len(server, rqst);\n\tint i, num_padding;\n\n\tshdr = (struct smb2_hdr *)(rqst->rq_iov[0].iov_base);\n\tif (shdr == NULL) {\n\t\tcifs_dbg(FYI, \"shdr NULL in smb2_set_next_command\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (!(len & 7))\n\t\tgoto finished;\n\n\tnum_padding = 8 - (len & 7);\n\tif (!smb3_encryption_required(tcon)) {\n\t\t \n\t\trqst->rq_iov[rqst->rq_nvec].iov_base = smb2_padding;\n\t\trqst->rq_iov[rqst->rq_nvec].iov_len = num_padding;\n\t\trqst->rq_nvec++;\n\t\tlen += num_padding;\n\t} else {\n\t\t \n\t\tfor (i = 1; i < rqst->rq_nvec; i++) {\n\t\t\tmemcpy(rqst->rq_iov[0].iov_base +\n\t\t\t       rqst->rq_iov[0].iov_len,\n\t\t\t       rqst->rq_iov[i].iov_base,\n\t\t\t       rqst->rq_iov[i].iov_len);\n\t\t\trqst->rq_iov[0].iov_len += rqst->rq_iov[i].iov_len;\n\t\t}\n\t\tmemset(rqst->rq_iov[0].iov_base + rqst->rq_iov[0].iov_len,\n\t\t       0, num_padding);\n\t\trqst->rq_iov[0].iov_len += num_padding;\n\t\tlen += num_padding;\n\t\trqst->rq_nvec = 1;\n\t}\n\n finished:\n\tshdr->NextCommand = cpu_to_le32(len);\n}\n\n \nint\nsmb2_query_info_compound(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t const char *path, u32 desired_access,\n\t\t\t u32 class, u32 type, u32 output_len,\n\t\t\t struct kvec *rsp, int *buftype,\n\t\t\t struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb2_compound_vars *vars;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = CIFS_CP_CREATE_CLOSE_OP;\n\tstruct smb_rqst *rqst;\n\tint resp_buftype[3];\n\tstruct kvec *rsp_iov;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tint rc;\n\t__le16 *utf16_path;\n\tstruct cached_fid *cfid = NULL;\n\n\tif (!path)\n\t\tpath = \"\";\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n\tif (!vars) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_path;\n\t}\n\trqst = vars->rqst;\n\trsp_iov = vars->rsp_iov;\n\n\t \n\tif (!strcmp(path, \"\"))\n\t\topen_cached_dir(xid, tcon, path, cifs_sb, false,\n\t\t\t\t&cfid);  \n\n\trqst[0].rq_iov = vars->open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access = desired_access,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto qic_exit;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\trqst[1].rq_iov = &vars->qi_iov;\n\trqst[1].rq_nvec = 1;\n\n\tif (cfid) {\n\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t\t  &rqst[1],\n\t\t\t\t\t  cfid->fid.persistent_fid,\n\t\t\t\t\t  cfid->fid.volatile_fid,\n\t\t\t\t\t  class, type, 0,\n\t\t\t\t\t  output_len, 0,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t\t  &rqst[1],\n\t\t\t\t\t  COMPOUND_FID,\n\t\t\t\t\t  COMPOUND_FID,\n\t\t\t\t\t  class, type, 0,\n\t\t\t\t\t  output_len, 0,\n\t\t\t\t\t  NULL);\n\t}\n\tif (rc)\n\t\tgoto qic_exit;\n\tif (!cfid) {\n\t\tsmb2_set_next_command(tcon, &rqst[1]);\n\t\tsmb2_set_related(&rqst[1]);\n\t}\n\n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID, false);\n\tif (rc)\n\t\tgoto qic_exit;\n\tsmb2_set_related(&rqst[2]);\n\n\tif (cfid) {\n\t\trc = compound_send_recv(xid, ses, server,\n\t\t\t\t\tflags, 1, &rqst[1],\n\t\t\t\t\t&resp_buftype[1], &rsp_iov[1]);\n\t} else {\n\t\trc = compound_send_recv(xid, ses, server,\n\t\t\t\t\tflags, 3, rqst,\n\t\t\t\t\tresp_buftype, rsp_iov);\n\t}\n\tif (rc) {\n\t\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\t\tif (rc == -EREMCHG) {\n\t\t\ttcon->need_reconnect = true;\n\t\t\tpr_warn_once(\"server share %s deleted\\n\",\n\t\t\t\t     tcon->tree_name);\n\t\t}\n\t\tgoto qic_exit;\n\t}\n\t*rsp = rsp_iov[1];\n\t*buftype = resp_buftype[1];\n\n qic_exit:\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_query_info_free(&rqst[1]);\n\tSMB2_close_free(&rqst[2]);\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\tif (cfid)\n\t\tclose_cached_dir(cfid);\n\tkfree(vars);\nout_free_path:\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nstatic int\nsmb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tint rc;\n\n\n\trc = smb2_query_info_compound(xid, tcon, \"\",\n\t\t\t\t      FILE_READ_ATTRIBUTES,\n\t\t\t\t      FS_FULL_SIZE_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILESYSTEM,\n\t\t\t\t      sizeof(struct smb2_fs_full_size_info),\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc)\n\t\tgoto qfs_exit;\n\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, buf);\n\nqfs_exit:\n\ttrace_smb3_qfs_done(xid, tcon->tid, tcon->ses->Suid, tcon->tree_name, rc);\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nstatic int\nsmb311_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tint rc;\n\t__le16 srch_path = 0;  \n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tif (!tcon->posix_extensions)\n\t\treturn smb2_queryfs(xid, tcon, cifs_sb, buf);\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = \"\",\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL,\n\t\t       NULL, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SMB311_posix_qfs_info(xid, tcon, fid.persistent_fid,\n\t\t\t\t   fid.volatile_fid, buf);\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn rc;\n}\n\nstatic bool\nsmb2_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.persistent_fid == ob2->fid.persistent_fid &&\n\t       ob1->fid.volatile_fid == ob2->fid.volatile_fid;\n}\n\nstatic int\nsmb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\tif (unlock && !lock)\n\t\ttype = SMB2_LOCKFLAG_UNLOCK;\n\treturn SMB2_lock(xid, tlink_tcon(cfile->tlink),\n\t\t\t cfile->fid.persistent_fid, cfile->fid.volatile_fid,\n\t\t\t current->tgid, length, offset, type, wait);\n}\n\nstatic void\nsmb2_get_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(fid->lease_key, CIFS_I(inode)->lease_key, SMB2_LEASE_KEY_SIZE);\n}\n\nstatic void\nsmb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(CIFS_I(inode)->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n}\n\nstatic void\nsmb2_new_lease_key(struct cifs_fid *fid)\n{\n\tgenerate_random_uuid(fid->lease_key);\n}\n\nstatic int\nsmb2_get_dfs_refer(const unsigned int xid, struct cifs_ses *ses,\n\t\t   const char *search_name,\n\t\t   struct dfs_info3_param **target_nodes,\n\t\t   unsigned int *num_of_nodes,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tint rc;\n\t__le16 *utf16_path = NULL;\n\tint utf16_path_len = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct fsctl_get_dfs_referral_req *dfs_req = NULL;\n\tstruct get_dfs_referral_rsp *dfs_rsp = NULL;\n\tu32 dfs_req_size = 0, dfs_rsp_size = 0;\n\tint retry_count = 0;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, search_name);\n\n\t \n\ttcon = ses->tcon_ipc;\n\tif (tcon == NULL) {\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\ttcon = list_first_entry_or_null(&ses->tcon_list,\n\t\t\t\t\t\tstruct cifs_tcon,\n\t\t\t\t\t\ttcon_list);\n\t\tif (tcon)\n\t\t\ttcon->tc_count++;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t}\n\n\tif (tcon == NULL) {\n\t\tcifs_dbg(VFS, \"session %p has no tcon available for a dfs referral request\\n\",\n\t\t\t ses);\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tutf16_path = cifs_strndup_to_utf16(search_name, PATH_MAX,\n\t\t\t\t\t   &utf16_path_len,\n\t\t\t\t\t   nls_codepage, remap);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdfs_req_size = sizeof(*dfs_req) + utf16_path_len;\n\tdfs_req = kzalloc(dfs_req_size, GFP_KERNEL);\n\tif (!dfs_req) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tdfs_req->MaxReferralLevel = DFS_VERSION;\n\n\t \n\tmemcpy(dfs_req->RequestFileName, utf16_path, utf16_path_len);\n\n\tdo {\n\t\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\t\tFSCTL_DFS_GET_REFERRALS,\n\t\t\t\t(char *)dfs_req, dfs_req_size, CIFSMaxBufSize,\n\t\t\t\t(char **)&dfs_rsp, &dfs_rsp_size);\n\t\tif (!is_retryable_error(rc))\n\t\t\tbreak;\n\t\tusleep_range(512, 2048);\n\t} while (++retry_count < 5);\n\n\tif (!rc && !dfs_rsp)\n\t\trc = -EIO;\n\tif (rc) {\n\t\tif (!is_retryable_error(rc) && rc != -ENOENT && rc != -EOPNOTSUPP)\n\t\t\tcifs_tcon_dbg(VFS, \"%s: ioctl error: rc=%d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\trc = parse_dfs_referrals(dfs_rsp, dfs_rsp_size,\n\t\t\t\t num_of_nodes, target_nodes,\n\t\t\t\t nls_codepage, remap, search_name,\n\t\t\t\t true  );\n\tif (rc) {\n\t\tcifs_tcon_dbg(VFS, \"parse error in %s rc=%d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n out:\n\tif (tcon && !tcon->ipc) {\n\t\t \n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\ttcon->tc_count--;\n\t\t \n\t\tWARN_ON(tcon->tc_count < 0);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t}\n\tkfree(utf16_path);\n\tkfree(dfs_req);\n\tkfree(dfs_rsp);\n\treturn rc;\n}\n\n \nstatic int parse_reparse_posix(struct reparse_posix_data *buf,\n\t\t\t       struct cifs_sb_info *cifs_sb,\n\t\t\t       struct cifs_open_info_data *data)\n{\n\tunsigned int len;\n\tu64 type;\n\n\tswitch ((type = le64_to_cpu(buf->InodeType))) {\n\tcase NFS_SPECFILE_LNK:\n\t\tlen = le16_to_cpu(buf->ReparseDataLength);\n\t\tdata->symlink_target = cifs_strndup_from_utf16(buf->DataBuffer,\n\t\t\t\t\t\t\t       len, true,\n\t\t\t\t\t\t\t       cifs_sb->local_nls);\n\t\tif (!data->symlink_target)\n\t\t\treturn -ENOMEM;\n\t\tconvert_delimiter(data->symlink_target, '/');\n\t\tcifs_dbg(FYI, \"%s: target path: %s\\n\",\n\t\t\t __func__, data->symlink_target);\n\t\tbreak;\n\tcase NFS_SPECFILE_CHR:\n\tcase NFS_SPECFILE_BLK:\n\tcase NFS_SPECFILE_FIFO:\n\tcase NFS_SPECFILE_SOCK:\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"%s: unhandled inode type: 0x%llx\\n\",\n\t\t\t __func__, type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int parse_reparse_symlink(struct reparse_symlink_data_buffer *sym,\n\t\t\t\t u32 plen, bool unicode,\n\t\t\t\t struct cifs_sb_info *cifs_sb,\n\t\t\t\t struct cifs_open_info_data *data)\n{\n\tunsigned int len;\n\tunsigned int offs;\n\n\t \n\n\toffs = le16_to_cpu(sym->SubstituteNameOffset);\n\tlen = le16_to_cpu(sym->SubstituteNameLength);\n\tif (offs + 20 > plen || offs + len + 20 > plen) {\n\t\tcifs_dbg(VFS, \"srv returned malformed symlink buffer\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdata->symlink_target = cifs_strndup_from_utf16(sym->PathBuffer + offs,\n\t\t\t\t\t\t       len, unicode,\n\t\t\t\t\t\t       cifs_sb->local_nls);\n\tif (!data->symlink_target)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(data->symlink_target, '/');\n\tcifs_dbg(FYI, \"%s: target path: %s\\n\", __func__, data->symlink_target);\n\n\treturn 0;\n}\n\nint parse_reparse_point(struct reparse_data_buffer *buf,\n\t\t\tu32 plen, struct cifs_sb_info *cifs_sb,\n\t\t\tbool unicode, struct cifs_open_info_data *data)\n{\n\tif (plen < sizeof(*buf)) {\n\t\tcifs_dbg(VFS, \"%s: reparse buffer is too small. Must be at least 8 bytes but was %d\\n\",\n\t\t\t __func__, plen);\n\t\treturn -EIO;\n\t}\n\n\tif (plen < le16_to_cpu(buf->ReparseDataLength) + sizeof(*buf)) {\n\t\tcifs_dbg(VFS, \"%s: invalid reparse buf length: %d\\n\",\n\t\t\t __func__, plen);\n\t\treturn -EIO;\n\t}\n\n\tdata->reparse.buf = buf;\n\n\t \n\tswitch (le32_to_cpu(buf->ReparseTag)) {\n\tcase IO_REPARSE_TAG_NFS:\n\t\treturn parse_reparse_posix((struct reparse_posix_data *)buf,\n\t\t\t\t\t   cifs_sb, data);\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\treturn parse_reparse_symlink(\n\t\t\t(struct reparse_symlink_data_buffer *)buf,\n\t\t\tplen, unicode, cifs_sb, data);\n\tcase IO_REPARSE_TAG_LX_SYMLINK:\n\tcase IO_REPARSE_TAG_AF_UNIX:\n\tcase IO_REPARSE_TAG_LX_FIFO:\n\tcase IO_REPARSE_TAG_LX_CHR:\n\tcase IO_REPARSE_TAG_LX_BLK:\n\t\treturn 0;\n\tdefault:\n\t\tcifs_dbg(VFS, \"%s: unhandled reparse tag: 0x%08x\\n\",\n\t\t\t __func__, le32_to_cpu(buf->ReparseTag));\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int smb2_parse_reparse_point(struct cifs_sb_info *cifs_sb,\n\t\t\t\t    struct kvec *rsp_iov,\n\t\t\t\t    struct cifs_open_info_data *data)\n{\n\tstruct reparse_data_buffer *buf;\n\tstruct smb2_ioctl_rsp *io = rsp_iov->iov_base;\n\tu32 plen = le32_to_cpu(io->OutputCount);\n\n\tbuf = (struct reparse_data_buffer *)((u8 *)io +\n\t\t\t\t\t     le32_to_cpu(io->OutputOffset));\n\treturn parse_reparse_point(buf, plen, cifs_sb, true, data);\n}\n\nstatic int smb2_query_reparse_point(const unsigned int xid,\n\t\t\t\t    struct cifs_tcon *tcon,\n\t\t\t\t    struct cifs_sb_info *cifs_sb,\n\t\t\t\t    const char *full_path,\n\t\t\t\t    u32 *tag, struct kvec *rsp,\n\t\t\t\t    int *rsp_buftype)\n{\n\tstruct smb2_compound_vars *vars;\n\tint rc;\n\t__le16 *utf16_path = NULL;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\tint flags = CIFS_CP_CREATE_CLOSE_OP;\n\tstruct smb_rqst *rqst;\n\tint resp_buftype[3];\n\tstruct kvec *rsp_iov;\n\tstruct smb2_ioctl_rsp *ioctl_rsp;\n\tstruct reparse_data_buffer *reparse_buf;\n\tu32 off, count, len;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, full_path);\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n\tif (!vars) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_path;\n\t}\n\trqst = vars->rqst;\n\trsp_iov = vars->rsp_iov;\n\n\t \n\trqst[0].rq_iov = vars->open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = full_path,\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb, OPEN_REPARSE_POINT),\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto query_rp_exit;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\n\t \n\trqst[1].rq_iov = vars->io_iov;\n\trqst[1].rq_nvec = SMB2_IOCTL_IOV_SIZE;\n\n\trc = SMB2_ioctl_init(tcon, server,\n\t\t\t     &rqst[1], COMPOUND_FID,\n\t\t\t     COMPOUND_FID, FSCTL_GET_REPARSE_POINT, NULL, 0,\n\t\t\t     CIFSMaxBufSize -\n\t\t\t     MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t     MAX_SMB2_CLOSE_RESPONSE_SIZE);\n\tif (rc)\n\t\tgoto query_rp_exit;\n\n\tsmb2_set_next_command(tcon, &rqst[1]);\n\tsmb2_set_related(&rqst[1]);\n\n\t \n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID, false);\n\tif (rc)\n\t\tgoto query_rp_exit;\n\n\tsmb2_set_related(&rqst[2]);\n\n\trc = compound_send_recv(xid, tcon->ses, server,\n\t\t\t\tflags, 3, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\n\tioctl_rsp = rsp_iov[1].iov_base;\n\n\t \n\tif (rc == 0) {\n\t\t \n\t\toff = le32_to_cpu(ioctl_rsp->OutputOffset);\n\t\tcount = le32_to_cpu(ioctl_rsp->OutputCount);\n\t\tif (check_add_overflow(off, count, &len) ||\n\t\t    len > rsp_iov[1].iov_len) {\n\t\t\tcifs_tcon_dbg(VFS, \"%s: invalid ioctl: off=%d count=%d\\n\",\n\t\t\t\t      __func__, off, count);\n\t\t\trc = -EIO;\n\t\t\tgoto query_rp_exit;\n\t\t}\n\n\t\treparse_buf = (void *)((u8 *)ioctl_rsp + off);\n\t\tlen = sizeof(*reparse_buf);\n\t\tif (count < len ||\n\t\t    count < le16_to_cpu(reparse_buf->ReparseDataLength) + len) {\n\t\t\tcifs_tcon_dbg(VFS, \"%s: invalid ioctl: off=%d count=%d\\n\",\n\t\t\t\t      __func__, off, count);\n\t\t\trc = -EIO;\n\t\t\tgoto query_rp_exit;\n\t\t}\n\t\t*tag = le32_to_cpu(reparse_buf->ReparseTag);\n\t\t*rsp = rsp_iov[1];\n\t\t*rsp_buftype = resp_buftype[1];\n\t\tresp_buftype[1] = CIFS_NO_BUFFER;\n\t}\n\n query_rp_exit:\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_ioctl_free(&rqst[1]);\n\tSMB2_close_free(&rqst[2]);\n\tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1], rsp_iov[1].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\tkfree(vars);\nout_free_path:\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nstatic struct cifs_ntsd *\nget_smb2_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\t    const struct cifs_fid *cifsfid, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc = -EOPNOTSUPP;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\tcifs_dbg(FYI, \"trying to get acl\\n\");\n\n\trc = SMB2_query_acl(xid, tlink_tcon(tlink), cifsfid->persistent_fid,\n\t\t\t    cifsfid->volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t    info);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n\n}\n\nstatic struct cifs_ntsd *\nget_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access = READ_CONTROL,\n\t\t.disposition = FILE_OPEN,\n\t\t \n\t\t.create_options = cifs_create_options(cifs_sb, 0) |\n\t\t\t\t  OPEN_REPARSE_POINT,\n\t\t.fid = &fid,\n\t};\n\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\nstatic int\nset_smb2_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc, access_flags = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\n\tcifs_dbg(FYI, \"set smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (aclflag & CIFS_ACL_OWNER || aclflag & CIFS_ACL_GROUP)\n\t\taccess_flags |= WRITE_OWNER;\n\tif (aclflag & CIFS_ACL_SACL)\n\t\taccess_flags |= SYSTEM_SECURITY;\n\tif (aclflag & CIFS_ACL_DACL)\n\t\taccess_flags |= WRITE_DAC;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.desired_access = access_flags,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,\n\t\t       NULL, NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_set_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t    fid.volatile_fid, pnntsd, acllen, aclflag);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn rc;\n}\n\n \nstatic struct cifs_ntsd *\nget_smb2_acl(struct cifs_sb_info *cifs_sb,\n\t     struct inode *inode, const char *path,\n\t     u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode && !(info & SACL_SECINFO))\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file || (info & SACL_SECINFO))\n\t\treturn get_smb2_acl_by_path(cifs_sb, path, pacllen, info);\n\n\tpntsd = get_smb2_acl_by_fid(cifs_sb, &open_file->fid, pacllen, info);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}\n\nstatic long smb3_zero_data(struct file *file, struct cifs_tcon *tcon,\n\t\t\t     loff_t offset, loff_t len, unsigned int xid)\n{\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\n\tcifs_dbg(FYI, \"Offset %lld len %lld\\n\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\treturn SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t  cfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\t  (char *)&fsctl_buf,\n\t\t\t  sizeof(struct file_zero_data_information),\n\t\t\t  0, NULL, NULL);\n}\n\nstatic long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len, bool keep_size)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tunsigned long long new_size;\n\tlong rc;\n\tunsigned int xid;\n\t__le64 eof;\n\n\txid = get_xid();\n\n\ttrace_smb3_zero_enter(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t      ses->Suid, offset, len);\n\n\tinode_lock(inode);\n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\t \n\ttruncate_pagecache_range(inode, offset, offset + len - 1);\n\n\t \n\trc = -EOPNOTSUPP;\n\tif (keep_size == false && !CIFS_CACHE_READ(cifsi))\n\t\tgoto zero_range_exit;\n\n\trc = smb3_zero_data(file, tcon, offset, len, xid);\n\tif (rc < 0)\n\t\tgoto zero_range_exit;\n\n\t \n\tnew_size = offset + len;\n\tif (keep_size == false && (unsigned long long)i_size_read(inode) < new_size) {\n\t\teof = cpu_to_le64(new_size);\n\t\trc = SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t\t  cfile->fid.volatile_fid, cfile->pid, &eof);\n\t\tif (rc >= 0) {\n\t\t\ttruncate_setsize(inode, new_size);\n\t\t\tfscache_resize_cookie(cifs_inode_cookie(inode), new_size);\n\t\t}\n\t}\n\n zero_range_exit:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\tinode_unlock(inode);\n\tfree_xid(xid);\n\tif (rc)\n\t\ttrace_smb3_zero_err(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t      ses->Suid, offset, len, rc);\n\telse\n\t\ttrace_smb3_zero_done(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t      ses->Suid, offset, len);\n\treturn rc;\n}\n\nstatic long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\t__u8 set_sparse = 1;\n\n\txid = get_xid();\n\n\tinode_lock(inode);\n\t \n\t \n\tif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\t \n\ttruncate_pagecache_range(inode, offset, offset + len - 1);\n\n\tcifs_dbg(FYI, \"Offset %lld len %lld\\n\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\t(char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information),\n\t\t\tCIFSMaxBufSize, NULL, NULL);\n\tfilemap_invalidate_unlock(inode->i_mapping);\nout:\n\tinode_unlock(inode);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int smb3_simple_fallocate_write_range(unsigned int xid,\n\t\t\t\t\t     struct cifs_tcon *tcon,\n\t\t\t\t\t     struct cifsFileInfo *cfile,\n\t\t\t\t\t     loff_t off, loff_t len,\n\t\t\t\t\t     char *buf)\n{\n\tstruct cifs_io_parms io_parms = {0};\n\tint nbytes;\n\tint rc = 0;\n\tstruct kvec iov[2];\n\n\tio_parms.netfid = cfile->fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.persistent_fid = cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = cfile->fid.volatile_fid;\n\n\twhile (len) {\n\t\tio_parms.offset = off;\n\t\tio_parms.length = len;\n\t\tif (io_parms.length > SMB2_MAX_BUFFER_SIZE)\n\t\t\tio_parms.length = SMB2_MAX_BUFFER_SIZE;\n\t\t \n\t\tiov[1].iov_base = buf;\n\t\tiov[1].iov_len = io_parms.length;\n\t\trc = SMB2_write(xid, &io_parms, &nbytes, iov, 1);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (nbytes > len)\n\t\t\treturn -EINVAL;\n\t\tbuf += nbytes;\n\t\toff += nbytes;\n\t\tlen -= nbytes;\n\t}\n\treturn rc;\n}\n\nstatic int smb3_simple_fallocate_range(unsigned int xid,\n\t\t\t\t       struct cifs_tcon *tcon,\n\t\t\t\t       struct cifsFileInfo *cfile,\n\t\t\t\t       loff_t off, loff_t len)\n{\n\tstruct file_allocated_range_buffer in_data, *out_data = NULL, *tmp_data;\n\tu32 out_data_len;\n\tchar *buf = NULL;\n\tloff_t l;\n\tint rc;\n\n\tin_data.file_offset = cpu_to_le64(off);\n\tin_data.length = cpu_to_le64(len);\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid,\n\t\t\tFSCTL_QUERY_ALLOCATED_RANGES,\n\t\t\t(char *)&in_data, sizeof(in_data),\n\t\t\t1024 * sizeof(struct file_allocated_range_buffer),\n\t\t\t(char **)&out_data, &out_data_len);\n\tif (rc)\n\t\tgoto out;\n\n\tbuf = kzalloc(1024 * 1024, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_data = out_data;\n\twhile (len) {\n\t\t \n\t\tif (out_data_len == 0) {\n\t\t\trc = smb3_simple_fallocate_write_range(xid, tcon,\n\t\t\t\t\t       cfile, off, len, buf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (out_data_len < sizeof(struct file_allocated_range_buffer)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (off < le64_to_cpu(tmp_data->file_offset)) {\n\t\t\t \n\t\t\tl = le64_to_cpu(tmp_data->file_offset) - off;\n\t\t\tif (len < l)\n\t\t\t\tl = len;\n\t\t\trc = smb3_simple_fallocate_write_range(xid, tcon,\n\t\t\t\t\t       cfile, off, l, buf);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\toff = off + l;\n\t\t\tlen = len - l;\n\t\t\tif (len == 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tl = le64_to_cpu(tmp_data->length);\n\t\tif (len < l)\n\t\t\tl = len;\n\t\toff += l;\n\t\tlen -= l;\n\n\t\ttmp_data = &tmp_data[1];\n\t\tout_data_len -= sizeof(struct file_allocated_range_buffer);\n\t}\n\n out:\n\tkfree(out_data);\n\tkfree(buf);\n\treturn rc;\n}\n\n\nstatic long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tlong rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\t__le64 eof;\n\n\txid = get_xid();\n\n\tinode = d_inode(cfile->dentry);\n\tcifsi = CIFS_I(inode);\n\n\ttrace_smb3_falloc_enter(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t\ttcon->ses->Suid, off, len);\n\t \n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false) {\n\t\t\ttrace_smb3_falloc_err(xid, cfile->fid.persistent_fid,\n\t\t\t\ttcon->tid, tcon->ses->Suid, off, len, rc);\n\t\t\tfree_xid(xid);\n\t\t\treturn rc;\n\t\t}\n\n\t \n\tif ((keep_size == false) && i_size_read(inode) < off + len) {\n\t\trc = inode_newsize_ok(inode, off + len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tsmb2_set_sparse(xid, tcon, cfile, inode, false);\n\n\t\teof = cpu_to_le64(off + len);\n\t\trc = SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t\t  cfile->fid.volatile_fid, cfile->pid, &eof);\n\t\tif (rc == 0) {\n\t\t\tcifsi->server_eof = off + len;\n\t\t\tcifs_setsize(inode, off + len);\n\t\t\tcifs_truncate_page(inode->i_mapping, inode->i_size);\n\t\t\ttruncate_setsize(inode, off + len);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (keep_size == true) {\n\t\t \n\t\tif (off >= i_size_read(inode)) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (off + len > i_size_read(inode)) {\n\t\t\tlen = i_size_read(inode) - off;\n\t\t}\n\t}\n\n\tif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\n\t\t \n\t\t \n\t\tif (len <= 1024 * 1024) {\n\t\t\trc = smb3_simple_fallocate_range(xid, tcon, cfile,\n\t\t\t\t\t\t\t off, len);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((off > 8192) || (off + len + 8192 < i_size_read(inode))) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsmb2_set_sparse(xid, tcon, cfile, inode, false);\n\trc = 0;\n\nout:\n\tif (rc)\n\t\ttrace_smb3_falloc_err(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t\ttcon->ses->Suid, off, len, rc);\n\telse\n\t\ttrace_smb3_falloc_done(xid, cfile->fid.persistent_fid, tcon->tid,\n\t\t\t\ttcon->ses->Suid, off, len);\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic long smb3_collapse_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\t__le64 eof;\n\tloff_t old_eof;\n\n\txid = get_xid();\n\n\tinode_lock(inode);\n\n\told_eof = i_size_read(inode);\n\tif ((off >= old_eof) ||\n\t    off + len >= old_eof) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\trc = filemap_write_and_wait_range(inode->i_mapping, off, old_eof - 1);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\ttruncate_pagecache_range(inode, off, old_eof);\n\n\trc = smb2_copychunk_range(xid, cfile, cfile, off + len,\n\t\t\t\t  old_eof - off - len, off);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\teof = cpu_to_le64(old_eof - len);\n\trc = SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t  cfile->fid.volatile_fid, cfile->pid, &eof);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\trc = 0;\n\n\tcifsi->server_eof = i_size_read(inode) - len;\n\ttruncate_setsize(inode, cifsi->server_eof);\n\tfscache_resize_cookie(cifs_inode_cookie(inode), cifsi->server_eof);\nout_2:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n out:\n\tinode_unlock(inode);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic long smb3_insert_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t      loff_t off, loff_t len)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\t__le64 eof;\n\t__u64  count, old_eof;\n\n\txid = get_xid();\n\n\tinode_lock(inode);\n\n\told_eof = i_size_read(inode);\n\tif (off >= old_eof) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcount = old_eof - off;\n\teof = cpu_to_le64(old_eof + len);\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\trc = filemap_write_and_wait_range(inode->i_mapping, off, old_eof + len - 1);\n\tif (rc < 0)\n\t\tgoto out_2;\n\ttruncate_pagecache_range(inode, off, old_eof);\n\n\trc = SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t  cfile->fid.volatile_fid, cfile->pid, &eof);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\ttruncate_setsize(inode, old_eof + len);\n\tfscache_resize_cookie(cifs_inode_cookie(inode), i_size_read(inode));\n\n\trc = smb2_copychunk_range(xid, cfile, cfile, off, count, off + len);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\trc = smb3_zero_data(file, tcon, off, len, xid);\n\tif (rc < 0)\n\t\tgoto out_2;\n\n\trc = 0;\nout_2:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n out:\n\tinode_unlock(inode);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic loff_t smb3_llseek(struct file *file, struct cifs_tcon *tcon, loff_t offset, int whence)\n{\n\tstruct cifsFileInfo *wrcfile, *cfile = file->private_data;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct inode *inode;\n\tint rc = 0;\n\tstruct file_allocated_range_buffer in_data, *out_data = NULL;\n\tu32 out_data_len;\n\tunsigned int xid;\n\n\tif (whence != SEEK_HOLE && whence != SEEK_DATA)\n\t\treturn generic_file_llseek(file, offset, whence);\n\n\tinode = d_inode(cfile->dentry);\n\tcifsi = CIFS_I(inode);\n\n\tif (offset < 0 || offset >= i_size_read(inode))\n\t\treturn -ENXIO;\n\n\txid = get_xid();\n\t \n\twrcfile = find_writable_file(cifsi, FIND_WR_ANY);\n\tif (wrcfile) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tsmb2_flush_file(xid, tcon, &wrcfile->fid);\n\t\tcifsFileInfo_put(wrcfile);\n\t}\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE)) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\toffset = i_size_read(inode);\n\t\tgoto lseek_exit;\n\t}\n\n\tin_data.file_offset = cpu_to_le64(offset);\n\tin_data.length = cpu_to_le64(i_size_read(inode));\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid,\n\t\t\tFSCTL_QUERY_ALLOCATED_RANGES,\n\t\t\t(char *)&in_data, sizeof(in_data),\n\t\t\tsizeof(struct file_allocated_range_buffer),\n\t\t\t(char **)&out_data, &out_data_len);\n\tif (rc == -E2BIG)\n\t\trc = 0;\n\tif (rc)\n\t\tgoto lseek_exit;\n\n\tif (whence == SEEK_HOLE && out_data_len == 0)\n\t\tgoto lseek_exit;\n\n\tif (whence == SEEK_DATA && out_data_len == 0) {\n\t\trc = -ENXIO;\n\t\tgoto lseek_exit;\n\t}\n\n\tif (out_data_len < sizeof(struct file_allocated_range_buffer)) {\n\t\trc = -EINVAL;\n\t\tgoto lseek_exit;\n\t}\n\tif (whence == SEEK_DATA) {\n\t\toffset = le64_to_cpu(out_data->file_offset);\n\t\tgoto lseek_exit;\n\t}\n\tif (offset < le64_to_cpu(out_data->file_offset))\n\t\tgoto lseek_exit;\n\n\toffset = le64_to_cpu(out_data->file_offset) + le64_to_cpu(out_data->length);\n\n lseek_exit:\n\tfree_xid(xid);\n\tkfree(out_data);\n\tif (!rc)\n\t\treturn vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\telse\n\t\treturn rc;\n}\n\nstatic int smb3_fiemap(struct cifs_tcon *tcon,\n\t\t       struct cifsFileInfo *cfile,\n\t\t       struct fiemap_extent_info *fei, u64 start, u64 len)\n{\n\tunsigned int xid;\n\tstruct file_allocated_range_buffer in_data, *out_data;\n\tu32 out_data_len;\n\tint i, num, rc, flags, last_blob;\n\tu64 next;\n\n\trc = fiemap_prep(d_inode(cfile->dentry), fei, start, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\txid = get_xid();\n again:\n\tin_data.file_offset = cpu_to_le64(start);\n\tin_data.length = cpu_to_le64(len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid,\n\t\t\tFSCTL_QUERY_ALLOCATED_RANGES,\n\t\t\t(char *)&in_data, sizeof(in_data),\n\t\t\t1024 * sizeof(struct file_allocated_range_buffer),\n\t\t\t(char **)&out_data, &out_data_len);\n\tif (rc == -E2BIG) {\n\t\tlast_blob = 0;\n\t\trc = 0;\n\t} else\n\t\tlast_blob = 1;\n\tif (rc)\n\t\tgoto out;\n\n\tif (out_data_len && out_data_len < sizeof(struct file_allocated_range_buffer)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (out_data_len % sizeof(struct file_allocated_range_buffer)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnum = out_data_len / sizeof(struct file_allocated_range_buffer);\n\tfor (i = 0; i < num; i++) {\n\t\tflags = 0;\n\t\tif (i == num - 1 && last_blob)\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\n\t\trc = fiemap_fill_next_extent(fei,\n\t\t\t\tle64_to_cpu(out_data[i].file_offset),\n\t\t\t\tle64_to_cpu(out_data[i].file_offset),\n\t\t\t\tle64_to_cpu(out_data[i].length),\n\t\t\t\tflags);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tif (rc == 1) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!last_blob) {\n\t\tnext = le64_to_cpu(out_data[num - 1].file_offset) +\n\t\t  le64_to_cpu(out_data[num - 1].length);\n\t\tlen = len - (next - start);\n\t\tstart = next;\n\t\tgoto again;\n\t}\n\n out:\n\tfree_xid(xid);\n\tkfree(out_data);\n\treturn rc;\n}\n\nstatic long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,\n\t\t\t   loff_t off, loff_t len)\n{\n\t \n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn smb3_punch_hole(file, tcon, off, len);\n\telse if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\treturn smb3_zero_range(file, tcon, off, len, true);\n\t\treturn smb3_zero_range(file, tcon, off, len, false);\n\t} else if (mode == FALLOC_FL_KEEP_SIZE)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, true);\n\telse if (mode == FALLOC_FL_COLLAPSE_RANGE)\n\t\treturn smb3_collapse_range(file, tcon, off, len);\n\telse if (mode == FALLOC_FL_INSERT_RANGE)\n\t\treturn smb3_insert_range(file, tcon, off, len);\n\telse if (mode == 0)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, false);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nsmb2_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t      struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tserver->ops->set_oplock_level(cinode, oplock, 0, NULL);\n}\n\nstatic void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache);\n\nstatic void\nsmb3_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t       struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tunsigned int old_state = cinode->oplock;\n\tunsigned int old_epoch = cinode->epoch;\n\tunsigned int new_state;\n\n\tif (epoch > old_epoch) {\n\t\tsmb21_set_oplock_level(cinode, oplock, 0, NULL);\n\t\tcinode->epoch = epoch;\n\t}\n\n\tnew_state = cinode->oplock;\n\t*purge_cache = false;\n\n\tif ((old_state & CIFS_CACHE_READ_FLG) != 0 &&\n\t    (new_state & CIFS_CACHE_READ_FLG) == 0)\n\t\t*purge_cache = true;\n\telse if (old_state == new_state && (epoch - old_epoch > 1))\n\t\t*purge_cache = true;\n}\n\nstatic void\nsmb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\toplock &= 0xFF;\n\tcinode->lease_granted = false;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\tif (oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\tcinode->oplock = CIFS_CACHE_RHW_FLG;\n\t\tcifs_dbg(FYI, \"Batch Oplock granted on inode %p\\n\",\n\t\t\t &cinode->netfs.inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_RW_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->netfs.inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_II) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->netfs.inode);\n\t} else\n\t\tcinode->oplock = 0;\n}\n\nstatic void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\tunsigned int new_oplock = 0;\n\n\toplock &= 0xFF;\n\tcinode->lease_granted = true;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\n\t \n\tif (oplock & SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn smb2_set_oplock_level(cinode, oplock, epoch,\n\t\t\t\t\t     purge_cache);\n\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!new_oplock)\n\t\tstrncpy(message, \"None\", sizeof(message));\n\n\tcinode->oplock = new_oplock;\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->netfs.inode);\n}\n\nstatic void\nsmb3_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tunsigned int old_oplock = cinode->oplock;\n\n\tsmb21_set_oplock_level(cinode, oplock, epoch, purge_cache);\n\n\tif (purge_cache) {\n\t\t*purge_cache = false;\n\t\tif (old_oplock == CIFS_CACHE_READ_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_READ_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == 0 &&\n\t\t\t\t (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t} else if (old_oplock == CIFS_CACHE_RH_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t}\n\t\tcinode->epoch = epoch;\n\t}\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic bool\nsmb2_is_read_op(__u32 oplock)\n{\n\treturn oplock == SMB2_OPLOCK_LEVEL_II;\n}\n#endif  \n\nstatic bool\nsmb21_is_read_op(__u32 oplock)\n{\n\treturn (oplock & SMB2_LEASE_READ_CACHING_HE) &&\n\t       !(oplock & SMB2_LEASE_WRITE_CACHING_HE);\n}\n\nstatic __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING_LE;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING_LE | SMB2_LEASE_READ_CACHING_LE |\n\t\t       SMB2_LEASE_WRITE_CACHING_LE;\n\treturn 0;\n}\n\nstatic char *\nsmb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}\n\nstatic char *\nsmb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}\n\nstatic __u8\nsmb2_parse_lease_buf(void *buf, unsigned int *epoch, char *lease_key)\n{\n\tstruct create_lease *lc = (struct create_lease *)buf;\n\n\t*epoch = 0;  \n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS_LE)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}\n\nstatic __u8\nsmb3_parse_lease_buf(void *buf, unsigned int *epoch, char *lease_key)\n{\n\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)buf;\n\n\t*epoch = le16_to_cpu(lc->lcontext.Epoch);\n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS_LE)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\tif (lease_key)\n\t\tmemcpy(lease_key, &lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}\n\nstatic unsigned int\nsmb2_wp_retry_size(struct inode *inode)\n{\n\treturn min_t(unsigned int, CIFS_SB(inode->i_sb)->ctx->wsize,\n\t\t     SMB2_MAX_BUFFER_SIZE);\n}\n\nstatic bool\nsmb2_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->invalidHandle;\n}\n\nstatic void\nfill_transform_hdr(struct smb2_transform_hdr *tr_hdr, unsigned int orig_len,\n\t\t   struct smb_rqst *old_rq, __le16 cipher_type)\n{\n\tstruct smb2_hdr *shdr =\n\t\t\t(struct smb2_hdr *)old_rq->rq_iov[0].iov_base;\n\n\tmemset(tr_hdr, 0, sizeof(struct smb2_transform_hdr));\n\ttr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;\n\ttr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);\n\ttr_hdr->Flags = cpu_to_le16(0x01);\n\tif ((cipher_type == SMB2_ENCRYPTION_AES128_GCM) ||\n\t    (cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\tmemcpy(&tr_hdr->SessionId, &shdr->SessionId, 8);\n}\n\nstatic void *smb2_aead_req_alloc(struct crypto_aead *tfm, const struct smb_rqst *rqst,\n\t\t\t\t int num_rqst, const u8 *sig, u8 **iv,\n\t\t\t\t struct aead_request **req, struct sg_table *sgt,\n\t\t\t\t unsigned int *num_sgs, size_t *sensitive_size)\n{\n\tunsigned int req_size = sizeof(**req) + crypto_aead_reqsize(tfm);\n\tunsigned int iv_size = crypto_aead_ivsize(tfm);\n\tunsigned int len;\n\tu8 *p;\n\n\t*num_sgs = cifs_get_num_sgs(rqst, num_rqst, sig);\n\tif (IS_ERR_VALUE((long)(int)*num_sgs))\n\t\treturn ERR_PTR(*num_sgs);\n\n\tlen = iv_size;\n\tlen += crypto_aead_alignmask(tfm) & ~(crypto_tfm_ctx_alignment() - 1);\n\tlen = ALIGN(len, crypto_tfm_ctx_alignment());\n\tlen += req_size;\n\tlen = ALIGN(len, __alignof__(struct scatterlist));\n\tlen += array_size(*num_sgs, sizeof(struct scatterlist));\n\t*sensitive_size = len;\n\n\tp = kvzalloc(len, GFP_NOFS);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*iv = (u8 *)PTR_ALIGN(p, crypto_aead_alignmask(tfm) + 1);\n\t*req = (struct aead_request *)PTR_ALIGN(*iv + iv_size,\n\t\t\t\t\t\tcrypto_tfm_ctx_alignment());\n\tsgt->sgl = (struct scatterlist *)PTR_ALIGN((u8 *)*req + req_size,\n\t\t\t\t\t\t   __alignof__(struct scatterlist));\n\treturn p;\n}\n\nstatic void *smb2_get_aead_req(struct crypto_aead *tfm, struct smb_rqst *rqst,\n\t\t\t       int num_rqst, const u8 *sig, u8 **iv,\n\t\t\t       struct aead_request **req, struct scatterlist **sgl,\n\t\t\t       size_t *sensitive_size)\n{\n\tstruct sg_table sgtable = {};\n\tunsigned int skip, num_sgs, i, j;\n\tssize_t rc;\n\tvoid *p;\n\n\tp = smb2_aead_req_alloc(tfm, rqst, num_rqst, sig, iv, req, &sgtable,\n\t\t\t\t&num_sgs, sensitive_size);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\n\tsg_init_marker(sgtable.sgl, num_sgs);\n\n\t \n\tskip = 20;\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tstruct iov_iter *iter = &rqst[i].rq_iter;\n\t\tsize_t count = iov_iter_count(iter);\n\n\t\tfor (j = 0; j < rqst[i].rq_nvec; j++) {\n\t\t\tcifs_sg_set_buf(&sgtable,\n\t\t\t\t\trqst[i].rq_iov[j].iov_base + skip,\n\t\t\t\t\trqst[i].rq_iov[j].iov_len - skip);\n\n\t\t\t \n\t\t\tskip = 0;\n\t\t}\n\t\tsgtable.orig_nents = sgtable.nents;\n\n\t\trc = extract_iter_to_sg(iter, count, &sgtable,\n\t\t\t\t\tnum_sgs - sgtable.nents, 0);\n\t\tiov_iter_revert(iter, rc);\n\t\tsgtable.orig_nents = sgtable.nents;\n\t}\n\n\tcifs_sg_set_buf(&sgtable, sig, SMB2_SIGNATURE_SIZE);\n\tsg_mark_end(&sgtable.sgl[sgtable.nents - 1]);\n\t*sgl = sgtable.sgl;\n\treturn p;\n}\n\nstatic int\nsmb2_get_enc_key(struct TCP_Server_Info *server, __u64 ses_id, int enc, u8 *key)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses;\n\tu8 *ses_enc_key;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tif (ses->Suid == ses_id) {\n\t\t\tspin_lock(&ses->ses_lock);\n\t\t\tses_enc_key = enc ? ses->smb3encryptionkey :\n\t\t\t\tses->smb3decryptionkey;\n\t\t\tmemcpy(key, ses_enc_key, SMB3_ENC_DEC_KEY_SIZE);\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\ttrace_smb3_ses_not_found(ses_id);\n\n\treturn -EAGAIN;\n}\n \nstatic int\ncrypt_message(struct TCP_Server_Info *server, int num_rqst,\n\t      struct smb_rqst *rqst, int enc)\n{\n\tstruct smb2_transform_hdr *tr_hdr =\n\t\t(struct smb2_transform_hdr *)rqst[0].rq_iov[0].iov_base;\n\tunsigned int assoc_data_len = sizeof(struct smb2_transform_hdr) - 20;\n\tint rc = 0;\n\tstruct scatterlist *sg;\n\tu8 sign[SMB2_SIGNATURE_SIZE] = {};\n\tu8 key[SMB3_ENC_DEC_KEY_SIZE];\n\tstruct aead_request *req;\n\tu8 *iv;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tstruct crypto_aead *tfm;\n\tunsigned int crypt_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tvoid *creq;\n\tsize_t sensitive_size;\n\n\trc = smb2_get_enc_key(server, le64_to_cpu(tr_hdr->SessionId), enc, key);\n\tif (rc) {\n\t\tcifs_server_dbg(FYI, \"%s: Could not get %scryption key. sid: 0x%llx\\n\", __func__,\n\t\t\t enc ? \"en\" : \"de\", le64_to_cpu(tr_hdr->SessionId));\n\t\treturn rc;\n\t}\n\n\trc = smb3_crypto_aead_allocate(server);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: crypto alloc failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\ttfm = enc ? server->secmech.enc : server->secmech.dec;\n\n\tif ((server->cipher_type == SMB2_ENCRYPTION_AES256_CCM) ||\n\t\t(server->cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\trc = crypto_aead_setkey(tfm, key, SMB3_GCM256_CRYPTKEY_SIZE);\n\telse\n\t\trc = crypto_aead_setkey(tfm, key, SMB3_GCM128_CRYPTKEY_SIZE);\n\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Failed to set aead key %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = crypto_aead_setauthsize(tfm, SMB2_SIGNATURE_SIZE);\n\tif (rc) {\n\t\tcifs_server_dbg(VFS, \"%s: Failed to set authsize %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tcreq = smb2_get_aead_req(tfm, rqst, num_rqst, sign, &iv, &req, &sg,\n\t\t\t\t &sensitive_size);\n\tif (IS_ERR(creq))\n\t\treturn PTR_ERR(creq);\n\n\tif (!enc) {\n\t\tmemcpy(sign, &tr_hdr->Signature, SMB2_SIGNATURE_SIZE);\n\t\tcrypt_len += SMB2_SIGNATURE_SIZE;\n\t}\n\n\tif ((server->cipher_type == SMB2_ENCRYPTION_AES128_GCM) ||\n\t    (server->cipher_type == SMB2_ENCRYPTION_AES256_GCM))\n\t\tmemcpy(iv, (char *)tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse {\n\t\tiv[0] = 3;\n\t\tmemcpy(iv + 1, (char *)tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\t}\n\n\taead_request_set_tfm(req, tfm);\n\taead_request_set_crypt(req, sg, sg, crypt_len, iv);\n\taead_request_set_ad(req, assoc_data_len);\n\n\taead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t  crypto_req_done, &wait);\n\n\trc = crypto_wait_req(enc ? crypto_aead_encrypt(req)\n\t\t\t\t: crypto_aead_decrypt(req), &wait);\n\n\tif (!rc && enc)\n\t\tmemcpy(&tr_hdr->Signature, sign, SMB2_SIGNATURE_SIZE);\n\n\tkvfree_sensitive(creq, sensitive_size);\n\treturn rc;\n}\n\n \nstatic void cifs_clear_xarray_buffer(struct xarray *buffer)\n{\n\tstruct folio *folio;\n\n\tXA_STATE(xas, buffer, 0);\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, folio, ULONG_MAX, XA_MARK_0) {\n\t\tfolio_put(folio);\n\t}\n\trcu_read_unlock();\n\txa_destroy(buffer);\n}\n\nvoid\nsmb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst)\n{\n\tint i;\n\n\tfor (i = 0; i < num_rqst; i++)\n\t\tif (!xa_empty(&rqst[i].rq_buffer))\n\t\t\tcifs_clear_xarray_buffer(&rqst[i].rq_buffer);\n}\n\n \nstatic int\nsmb3_init_transform_rq(struct TCP_Server_Info *server, int num_rqst,\n\t\t       struct smb_rqst *new_rq, struct smb_rqst *old_rq)\n{\n\tstruct smb2_transform_hdr *tr_hdr = new_rq[0].rq_iov[0].iov_base;\n\tstruct page *page;\n\tunsigned int orig_len = 0;\n\tint i, j;\n\tint rc = -ENOMEM;\n\n\tfor (i = 1; i < num_rqst; i++) {\n\t\tstruct smb_rqst *old = &old_rq[i - 1];\n\t\tstruct smb_rqst *new = &new_rq[i];\n\t\tstruct xarray *buffer = &new->rq_buffer;\n\t\tsize_t size = iov_iter_count(&old->rq_iter), seg, copied = 0;\n\n\t\torig_len += smb_rqst_len(server, old);\n\t\tnew->rq_iov = old->rq_iov;\n\t\tnew->rq_nvec = old->rq_nvec;\n\n\t\txa_init(buffer);\n\n\t\tif (size > 0) {\n\t\t\tunsigned int npages = DIV_ROUND_UP(size, PAGE_SIZE);\n\n\t\t\tfor (j = 0; j < npages; j++) {\n\t\t\t\tvoid *o;\n\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\t\t\tif (!page)\n\t\t\t\t\tgoto err_free;\n\t\t\t\tpage->index = j;\n\t\t\t\to = xa_store(buffer, j, page, GFP_KERNEL);\n\t\t\t\tif (xa_is_err(o)) {\n\t\t\t\t\trc = xa_err(o);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto err_free;\n\t\t\t\t}\n\n\t\t\t\txa_set_mark(buffer, j, XA_MARK_0);\n\n\t\t\t\tseg = min_t(size_t, size - copied, PAGE_SIZE);\n\t\t\t\tif (copy_page_from_iter(page, 0, seg, &old->rq_iter) != seg) {\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\t\tgoto err_free;\n\t\t\t\t}\n\t\t\t\tcopied += seg;\n\t\t\t}\n\t\t\tiov_iter_xarray(&new->rq_iter, ITER_SOURCE,\n\t\t\t\t\tbuffer, 0, size);\n\t\t\tnew->rq_iter_size = size;\n\t\t}\n\t}\n\n\t \n\tfill_transform_hdr(tr_hdr, orig_len, old_rq, server->cipher_type);\n\n\trc = crypt_message(server, num_rqst, new_rq, 1);\n\tcifs_dbg(FYI, \"Encrypt message returned %d\\n\", rc);\n\tif (rc)\n\t\tgoto err_free;\n\n\treturn rc;\n\nerr_free:\n\tsmb3_free_compound_rqst(num_rqst - 1, &new_rq[1]);\n\treturn rc;\n}\n\nstatic int\nsmb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = buf;\n\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}\n\nstatic int\ndecrypt_raw_data(struct TCP_Server_Info *server, char *buf,\n\t\t unsigned int buf_data_size, struct iov_iter *iter,\n\t\t bool is_offloaded)\n{\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = {NULL};\n\tsize_t iter_size = 0;\n\tint rc;\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr);\n\tiov[1].iov_base = buf + sizeof(struct smb2_transform_hdr);\n\tiov[1].iov_len = buf_data_size;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\tif (iter) {\n\t\trqst.rq_iter = *iter;\n\t\trqst.rq_iter_size = iov_iter_count(iter);\n\t\titer_size = iov_iter_count(iter);\n\t}\n\n\trc = crypt_message(server, 1, &rqst, 0);\n\tcifs_dbg(FYI, \"Decrypt message returned %d\\n\", rc);\n\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf, iov[1].iov_base, buf_data_size);\n\n\tif (!is_offloaded)\n\t\tserver->total_read = buf_data_size + iter_size;\n\n\treturn rc;\n}\n\nstatic int\ncifs_copy_pages_to_iter(struct xarray *pages, unsigned int data_size,\n\t\t\tunsigned int skip, struct iov_iter *iter)\n{\n\tstruct page *page;\n\tunsigned long index;\n\n\txa_for_each(pages, index, page) {\n\t\tsize_t n, len = min_t(unsigned int, PAGE_SIZE - skip, data_size);\n\n\t\tn = copy_page_to_iter(page, skip, len, iter);\n\t\tif (n != len) {\n\t\t\tcifs_dbg(VFS, \"%s: something went wrong\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdata_size -= n;\n\t\tskip = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhandle_read_data(struct TCP_Server_Info *server, struct mid_q_entry *mid,\n\t\t char *buf, unsigned int buf_len, struct xarray *pages,\n\t\t unsigned int pages_len, bool is_offloaded)\n{\n\tunsigned int data_offset;\n\tunsigned int data_len;\n\tunsigned int cur_off;\n\tunsigned int cur_page_idx;\n\tunsigned int pad_len;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tint length;\n\tbool use_rdma_mr = false;\n\n\tif (shdr->Command != SMB2_READ) {\n\t\tcifs_server_dbg(VFS, \"only big read responses are supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (server->ops->is_session_expired &&\n\t    server->ops->is_session_expired(buf)) {\n\t\tif (!is_offloaded)\n\t\t\tcifs_reconnect(server, true);\n\t\treturn -1;\n\t}\n\n\tif (server->ops->is_status_pending &&\n\t\t\tserver->ops->is_status_pending(buf, server))\n\t\treturn -1;\n\n\t \n\trdata->iov[0].iov_base = buf;\n\trdata->iov[0].iov_len = 0;\n\trdata->iov[1].iov_base = buf;\n\trdata->iov[1].iov_len =\n\t\tmin_t(unsigned int, buf_len, server->vals->read_rsp_size);\n\tcifs_dbg(FYI, \"0: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov[0].iov_base, rdata->iov[0].iov_len);\n\tcifs_dbg(FYI, \"1: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov[1].iov_base, rdata->iov[1].iov_len);\n\n\trdata->result = server->ops->map_error(buf, true);\n\tif (rdata->result != 0) {\n\t\tcifs_dbg(FYI, \"%s: server returned error %d\\n\",\n\t\t\t __func__, rdata->result);\n\t\t \n\t\tif (is_offloaded)\n\t\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\t\telse\n\t\t\tdequeue_mid(mid, false);\n\t\treturn 0;\n\t}\n\n\tdata_offset = server->ops->read_data_offset(buf);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tuse_rdma_mr = rdata->mr;\n#endif\n\tdata_len = server->ops->read_data_length(buf, use_rdma_mr);\n\n\tif (data_offset < server->vals->read_rsp_size) {\n\t\t \n\t\tcifs_dbg(FYI, \"%s: data offset (%u) inside read response header\\n\",\n\t\t\t __func__, data_offset);\n\t\tdata_offset = server->vals->read_rsp_size;\n\t} else if (data_offset > MAX_CIFS_SMALL_BUFFER_SIZE) {\n\t\t \n\t\tcifs_dbg(FYI, \"%s: data offset (%u) beyond end of smallbuf\\n\",\n\t\t\t __func__, data_offset);\n\t\trdata->result = -EIO;\n\t\tif (is_offloaded)\n\t\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t\telse\n\t\t\tdequeue_mid(mid, rdata->result);\n\t\treturn 0;\n\t}\n\n\tpad_len = data_offset - server->vals->read_rsp_size;\n\n\tif (buf_len <= data_offset) {\n\t\t \n\t\tcur_page_idx = pad_len / PAGE_SIZE;\n\t\tcur_off = pad_len % PAGE_SIZE;\n\n\t\tif (cur_page_idx != 0) {\n\t\t\t \n\t\t\tcifs_dbg(FYI, \"%s: data offset (%u) beyond 1st page of response\\n\",\n\t\t\t\t __func__, data_offset);\n\t\t\trdata->result = -EIO;\n\t\t\tif (is_offloaded)\n\t\t\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t\t\telse\n\t\t\t\tdequeue_mid(mid, rdata->result);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (data_len > pages_len - pad_len) {\n\t\t\t \n\t\t\trdata->result = -EIO;\n\t\t\tif (is_offloaded)\n\t\t\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t\t\telse\n\t\t\t\tdequeue_mid(mid, rdata->result);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\trdata->result = cifs_copy_pages_to_iter(pages, pages_len,\n\t\t\t\t\t\t\tcur_off, &rdata->iter);\n\t\tif (rdata->result != 0) {\n\t\t\tif (is_offloaded)\n\t\t\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t\t\telse\n\t\t\t\tdequeue_mid(mid, rdata->result);\n\t\t\treturn 0;\n\t\t}\n\t\trdata->got_bytes = pages_len;\n\n\t} else if (buf_len >= data_offset + data_len) {\n\t\t \n\t\tWARN_ONCE(pages && !xa_empty(pages),\n\t\t\t  \"read data can be either in buf or in pages\");\n\t\tlength = copy_to_iter(buf + data_offset, data_len, &rdata->iter);\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\trdata->got_bytes = data_len;\n\t} else {\n\t\t \n\t\tWARN_ONCE(1, \"buf can not contain only a part of read data\");\n\t\trdata->result = -EIO;\n\t\tif (is_offloaded)\n\t\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\t\telse\n\t\t\tdequeue_mid(mid, rdata->result);\n\t\treturn 0;\n\t}\n\n\tif (is_offloaded)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tdequeue_mid(mid, false);\n\treturn 0;\n}\n\nstruct smb2_decrypt_work {\n\tstruct work_struct decrypt;\n\tstruct TCP_Server_Info *server;\n\tstruct xarray buffer;\n\tchar *buf;\n\tunsigned int len;\n};\n\n\nstatic void smb2_decrypt_offload(struct work_struct *work)\n{\n\tstruct smb2_decrypt_work *dw = container_of(work,\n\t\t\t\tstruct smb2_decrypt_work, decrypt);\n\tint rc;\n\tstruct mid_q_entry *mid;\n\tstruct iov_iter iter;\n\n\tiov_iter_xarray(&iter, ITER_DEST, &dw->buffer, 0, dw->len);\n\trc = decrypt_raw_data(dw->server, dw->buf, dw->server->vals->read_rsp_size,\n\t\t\t      &iter, true);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"error decrypting rc=%d\\n\", rc);\n\t\tgoto free_pages;\n\t}\n\n\tdw->server->lstrp = jiffies;\n\tmid = smb2_find_dequeue_mid(dw->server, dw->buf);\n\tif (mid == NULL)\n\t\tcifs_dbg(FYI, \"mid not found\\n\");\n\telse {\n\t\tmid->decrypted = true;\n\t\trc = handle_read_data(dw->server, mid, dw->buf,\n\t\t\t\t      dw->server->vals->read_rsp_size,\n\t\t\t\t      &dw->buffer, dw->len,\n\t\t\t\t      true);\n\t\tif (rc >= 0) {\n#ifdef CONFIG_CIFS_STATS2\n\t\t\tmid->when_received = jiffies;\n#endif\n\t\t\tif (dw->server->ops->is_network_name_deleted)\n\t\t\t\tdw->server->ops->is_network_name_deleted(dw->buf,\n\t\t\t\t\t\t\t\t\t dw->server);\n\n\t\t\tmid->callback(mid);\n\t\t} else {\n\t\t\tspin_lock(&dw->server->srv_lock);\n\t\t\tif (dw->server->tcpStatus == CifsNeedReconnect) {\n\t\t\t\tspin_lock(&dw->server->mid_lock);\n\t\t\t\tmid->mid_state = MID_RETRY_NEEDED;\n\t\t\t\tspin_unlock(&dw->server->mid_lock);\n\t\t\t\tspin_unlock(&dw->server->srv_lock);\n\t\t\t\tmid->callback(mid);\n\t\t\t} else {\n\t\t\t\tspin_lock(&dw->server->mid_lock);\n\t\t\t\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\t\t\t\tmid->mid_flags &= ~(MID_DELETED);\n\t\t\t\tlist_add_tail(&mid->qhead,\n\t\t\t\t\t&dw->server->pending_mid_q);\n\t\t\t\tspin_unlock(&dw->server->mid_lock);\n\t\t\t\tspin_unlock(&dw->server->srv_lock);\n\t\t\t}\n\t\t}\n\t\trelease_mid(mid);\n\t}\n\nfree_pages:\n\tcifs_clear_xarray_buffer(&dw->buffer);\n\tcifs_small_buf_release(dw->buf);\n\tkfree(dw);\n}\n\n\nstatic int\nreceive_encrypted_read(struct TCP_Server_Info *server, struct mid_q_entry **mid,\n\t\t       int *num_mids)\n{\n\tstruct page *page;\n\tchar *buf = server->smallbuf;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tstruct iov_iter iter;\n\tunsigned int len, npages;\n\tunsigned int buflen = server->pdu_size;\n\tint rc;\n\tint i = 0;\n\tstruct smb2_decrypt_work *dw;\n\n\tdw = kzalloc(sizeof(struct smb2_decrypt_work), GFP_KERNEL);\n\tif (!dw)\n\t\treturn -ENOMEM;\n\txa_init(&dw->buffer);\n\tINIT_WORK(&dw->decrypt, smb2_decrypt_offload);\n\tdw->server = server;\n\n\t*num_mids = 1;\n\tlen = min_t(unsigned int, buflen, server->vals->read_rsp_size +\n\t\tsizeof(struct smb2_transform_hdr)) - HEADER_SIZE(server) + 1;\n\n\trc = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1, len);\n\tif (rc < 0)\n\t\tgoto free_dw;\n\tserver->total_read += rc;\n\n\tlen = le32_to_cpu(tr_hdr->OriginalMessageSize) -\n\t\tserver->vals->read_rsp_size;\n\tdw->len = len;\n\tnpages = DIV_ROUND_UP(len, PAGE_SIZE);\n\n\trc = -ENOMEM;\n\tfor (; i < npages; i++) {\n\t\tvoid *old;\n\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page)\n\t\t\tgoto discard_data;\n\t\tpage->index = i;\n\t\told = xa_store(&dw->buffer, i, page, GFP_KERNEL);\n\t\tif (xa_is_err(old)) {\n\t\t\trc = xa_err(old);\n\t\t\tput_page(page);\n\t\t\tgoto discard_data;\n\t\t}\n\t\txa_set_mark(&dw->buffer, i, XA_MARK_0);\n\t}\n\n\tiov_iter_xarray(&iter, ITER_DEST, &dw->buffer, 0, npages * PAGE_SIZE);\n\n\t \n\trc = cifs_read_iter_from_socket(server, &iter, dw->len);\n\tif (rc < 0)\n\t\tgoto discard_data;\n\n\tserver->total_read += rc;\n\tif (rc < npages * PAGE_SIZE)\n\t\tiov_iter_zero(npages * PAGE_SIZE - rc, &iter);\n\tiov_iter_revert(&iter, npages * PAGE_SIZE);\n\tiov_iter_truncate(&iter, dw->len);\n\n\trc = cifs_discard_remaining_data(server);\n\tif (rc)\n\t\tgoto free_pages;\n\n\t \n\n\tif ((server->min_offload) && (server->in_flight > 1) &&\n\t    (server->pdu_size >= server->min_offload)) {\n\t\tdw->buf = server->smallbuf;\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\n\t\tqueue_work(decrypt_wq, &dw->decrypt);\n\t\t*num_mids = 0;  \n\t\treturn -1;\n\t}\n\n\trc = decrypt_raw_data(server, buf, server->vals->read_rsp_size,\n\t\t\t      &iter, false);\n\tif (rc)\n\t\tgoto free_pages;\n\n\t*mid = smb2_find_mid(server, buf);\n\tif (*mid == NULL) {\n\t\tcifs_dbg(FYI, \"mid not found\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"mid found\\n\");\n\t\t(*mid)->decrypted = true;\n\t\trc = handle_read_data(server, *mid, buf,\n\t\t\t\t      server->vals->read_rsp_size,\n\t\t\t\t      &dw->buffer, dw->len, false);\n\t\tif (rc >= 0) {\n\t\t\tif (server->ops->is_network_name_deleted) {\n\t\t\t\tserver->ops->is_network_name_deleted(buf,\n\t\t\t\t\t\t\t\tserver);\n\t\t\t}\n\t\t}\n\t}\n\nfree_pages:\n\tcifs_clear_xarray_buffer(&dw->buffer);\nfree_dw:\n\tkfree(dw);\n\treturn rc;\ndiscard_data:\n\tcifs_discard_remaining_data(server);\n\tgoto free_pages;\n}\n\nstatic int\nreceive_encrypted_standard(struct TCP_Server_Info *server,\n\t\t\t   struct mid_q_entry **mids, char **bufs,\n\t\t\t   int *num_mids)\n{\n\tint ret, length;\n\tchar *buf = server->smallbuf;\n\tstruct smb2_hdr *shdr;\n\tunsigned int pdu_length = server->pdu_size;\n\tunsigned int buf_size;\n\tunsigned int next_cmd;\n\tstruct mid_q_entry *mid_entry;\n\tint next_is_large;\n\tchar *next_buffer = NULL;\n\n\t*num_mids = 0;\n\n\t \n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t \n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tbuf_size = pdu_length - sizeof(struct smb2_transform_hdr);\n\tlength = decrypt_raw_data(server, buf, buf_size, NULL, false);\n\tif (length)\n\t\treturn length;\n\n\tnext_is_large = server->large_buf;\none_more:\n\tshdr = (struct smb2_hdr *)buf;\n\tnext_cmd = le32_to_cpu(shdr->NextCommand);\n\tif (next_cmd) {\n\t\tif (WARN_ON_ONCE(next_cmd > pdu_length))\n\t\t\treturn -1;\n\t\tif (next_is_large)\n\t\t\tnext_buffer = (char *)cifs_buf_get();\n\t\telse\n\t\t\tnext_buffer = (char *)cifs_small_buf_get();\n\t\tmemcpy(next_buffer, buf + next_cmd, pdu_length - next_cmd);\n\t}\n\n\tmid_entry = smb2_find_mid(server, buf);\n\tif (mid_entry == NULL)\n\t\tcifs_dbg(FYI, \"mid not found\\n\");\n\telse {\n\t\tcifs_dbg(FYI, \"mid found\\n\");\n\t\tmid_entry->decrypted = true;\n\t\tmid_entry->resp_buf_size = server->pdu_size;\n\t}\n\n\tif (*num_mids >= MAX_COMPOUND) {\n\t\tcifs_server_dbg(VFS, \"too many PDUs in compound\\n\");\n\t\treturn -1;\n\t}\n\tbufs[*num_mids] = buf;\n\tmids[(*num_mids)++] = mid_entry;\n\n\tif (mid_entry && mid_entry->handle)\n\t\tret = mid_entry->handle(server, mid_entry);\n\telse\n\t\tret = cifs_handle_standard(server, mid_entry);\n\n\tif (ret == 0 && next_cmd) {\n\t\tpdu_length -= next_cmd;\n\t\tserver->large_buf = next_is_large;\n\t\tif (next_is_large)\n\t\t\tserver->bigbuf = buf = next_buffer;\n\t\telse\n\t\t\tserver->smallbuf = buf = next_buffer;\n\t\tgoto one_more;\n\t} else if (ret != 0) {\n\t\t \n\t\tif (next_is_large)\n\t\t\tfree_rsp_buf(CIFS_LARGE_BUFFER, next_buffer);\n\t\telse\n\t\t\tfree_rsp_buf(CIFS_SMALL_BUFFER, next_buffer);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nsmb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\n\t \n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}\n\nint\nsmb3_handle_read_data(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tchar *buf = server->large_buf ? server->bigbuf : server->smallbuf;\n\n\treturn handle_read_data(server, mid, buf, server->pdu_size,\n\t\t\t\tNULL, 0, false);\n}\n\nstatic int smb2_next_header(struct TCP_Server_Info *server, char *buf,\n\t\t\t    unsigned int *noff)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_transform_hdr *t_hdr = (struct smb2_transform_hdr *)buf;\n\n\tif (hdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\t*noff = le32_to_cpu(t_hdr->OriginalMessageSize);\n\t\tif (unlikely(check_add_overflow(*noff, sizeof(*t_hdr), noff)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t*noff = le32_to_cpu(hdr->NextCommand);\n\t}\n\tif (unlikely(*noff && *noff < MID_HEADER_SIZE(server)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int\nsmb2_make_node(unsigned int xid, struct inode *inode,\n\t       struct dentry *dentry, struct cifs_tcon *tcon,\n\t       const char *full_path, umode_t mode, dev_t dev)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tint rc = -EPERM;\n\tstruct cifs_open_info_data buf = {};\n\tstruct cifs_io_parms io_parms = {0};\n\t__u32 oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\tstruct kvec iov[2];\n\n\t \n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\treturn rc;\n\n\t \n\n\tif (!S_ISCHR(mode) && !S_ISBLK(mode) && !S_ISFIFO(mode))\n\t\treturn rc;\n\n\tcifs_dbg(FYI, \"sfu compat create special file\\n\");\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_WRITE,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |\n\t\t\t\t\t\t      CREATE_OPTION_SPECIAL),\n\t\t.disposition = FILE_CREATE,\n\t\t.path = full_path,\n\t\t.fid = &fid,\n\t};\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, &buf);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tpdev = (struct win_dev *)&buf.fi;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tiov[1].iov_base = &buf.fi;\n\tiov[1].iov_len = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(dev));\n\t\tpdev->minor = cpu_to_le64(MINOR(dev));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(dev));\n\t\tpdev->minor = cpu_to_le64(MINOR(dev));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} else if (S_ISFIFO(mode)) {\n\t\tmemcpy(pdev->type, \"LnxFIFO\", 8);\n\t\tpdev->major = 0;\n\t\tpdev->minor = 0;\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t}\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\td_drop(dentry);\n\n\t \n\n\tcifs_free_open_info(&buf);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstruct smb_version_operations smb20_operations = {\n\t.compare_fids = smb2_compare_fids,\n\t.setup_request = smb2_setup_request,\n\t.setup_async_request = smb2_setup_async_request,\n\t.check_receive = smb2_check_receive,\n\t.add_credits = smb2_add_credits,\n\t.set_credits = smb2_set_credits,\n\t.get_credits_field = smb2_get_credits_field,\n\t.get_credits = smb2_get_credits,\n\t.wait_mtu_credits = cifs_wait_mtu_credits,\n\t.get_next_mid = smb2_get_next_mid,\n\t.revert_current_mid = smb2_revert_current_mid,\n\t.read_data_offset = smb2_read_data_offset,\n\t.read_data_length = smb2_read_data_length,\n\t.map_error = map_smb2_to_linux_error,\n\t.find_mid = smb2_find_mid,\n\t.check_message = smb2_check_message,\n\t.dump_detail = smb2_dump_detail,\n\t.clear_stats = smb2_clear_stats,\n\t.print_stats = smb2_print_stats,\n\t.is_oplock_break = smb2_is_valid_oplock_break,\n\t.handle_cancelled_mid = smb2_handle_cancelled_mid,\n\t.downgrade_oplock = smb2_downgrade_oplock,\n\t.need_neg = smb2_need_neg,\n\t.negotiate = smb2_negotiate,\n\t.negotiate_wsize = smb2_negotiate_wsize,\n\t.negotiate_rsize = smb2_negotiate_rsize,\n\t.sess_setup = SMB2_sess_setup,\n\t.logoff = SMB2_logoff,\n\t.tree_connect = SMB2_tcon,\n\t.tree_disconnect = SMB2_tdis,\n\t.qfs_tcon = smb2_qfs_tcon,\n\t.is_path_accessible = smb2_is_path_accessible,\n\t.can_echo = smb2_can_echo,\n\t.echo = SMB2_echo,\n\t.query_path_info = smb2_query_path_info,\n\t.query_reparse_point = smb2_query_reparse_point,\n\t.get_srv_inum = smb2_get_srv_inum,\n\t.query_file_info = smb2_query_file_info,\n\t.set_path_size = smb2_set_path_size,\n\t.set_file_size = smb2_set_file_size,\n\t.set_file_info = smb2_set_file_info,\n\t.set_compression = smb2_set_compression,\n\t.mkdir = smb2_mkdir,\n\t.mkdir_setinfo = smb2_mkdir_setinfo,\n\t.rmdir = smb2_rmdir,\n\t.unlink = smb2_unlink,\n\t.rename = smb2_rename_path,\n\t.create_hardlink = smb2_create_hardlink,\n\t.parse_reparse_point = smb2_parse_reparse_point,\n\t.query_mf_symlink = smb3_query_mf_symlink,\n\t.create_mf_symlink = smb3_create_mf_symlink,\n\t.open = smb2_open_file,\n\t.set_fid = smb2_set_fid,\n\t.close = smb2_close_file,\n\t.flush = smb2_flush_file,\n\t.async_readv = smb2_async_readv,\n\t.async_writev = smb2_async_writev,\n\t.sync_read = smb2_sync_read,\n\t.sync_write = smb2_sync_write,\n\t.query_dir_first = smb2_query_dir_first,\n\t.query_dir_next = smb2_query_dir_next,\n\t.close_dir = smb2_close_dir,\n\t.calc_smb_size = smb2_calc_size,\n\t.is_status_pending = smb2_is_status_pending,\n\t.is_session_expired = smb2_is_session_expired,\n\t.oplock_response = smb2_oplock_response,\n\t.queryfs = smb2_queryfs,\n\t.mand_lock = smb2_mand_lock,\n\t.mand_unlock_range = smb2_unlock_range,\n\t.push_mand_locks = smb2_push_mandatory_locks,\n\t.get_lease_key = smb2_get_lease_key,\n\t.set_lease_key = smb2_set_lease_key,\n\t.new_lease_key = smb2_new_lease_key,\n\t.calc_signature = smb2_calc_signature,\n\t.is_read_op = smb2_is_read_op,\n\t.set_oplock_level = smb2_set_oplock_level,\n\t.create_lease_buf = smb2_create_lease_buf,\n\t.parse_lease_buf = smb2_parse_lease_buf,\n\t.copychunk_range = smb2_copychunk_range,\n\t.wp_retry_size = smb2_wp_retry_size,\n\t.dir_needs_close = smb2_dir_needs_close,\n\t.get_dfs_refer = smb2_get_dfs_refer,\n\t.select_sectype = smb2_select_sectype,\n#ifdef CONFIG_CIFS_XATTR\n\t.query_all_EAs = smb2_query_eas,\n\t.set_EA = smb2_set_ea,\n#endif  \n\t.get_acl = get_smb2_acl,\n\t.get_acl_by_fid = get_smb2_acl_by_fid,\n\t.set_acl = set_smb2_acl,\n\t.next_header = smb2_next_header,\n\t.ioctl_query_info = smb2_ioctl_query_info,\n\t.make_node = smb2_make_node,\n\t.fiemap = smb3_fiemap,\n\t.llseek = smb3_llseek,\n\t.is_status_io_timeout = smb2_is_status_io_timeout,\n\t.is_network_name_deleted = smb2_is_network_name_deleted,\n};\n#endif  \n\nstruct smb_version_operations smb21_operations = {\n\t.compare_fids = smb2_compare_fids,\n\t.setup_request = smb2_setup_request,\n\t.setup_async_request = smb2_setup_async_request,\n\t.check_receive = smb2_check_receive,\n\t.add_credits = smb2_add_credits,\n\t.set_credits = smb2_set_credits,\n\t.get_credits_field = smb2_get_credits_field,\n\t.get_credits = smb2_get_credits,\n\t.wait_mtu_credits = smb2_wait_mtu_credits,\n\t.adjust_credits = smb2_adjust_credits,\n\t.get_next_mid = smb2_get_next_mid,\n\t.revert_current_mid = smb2_revert_current_mid,\n\t.read_data_offset = smb2_read_data_offset,\n\t.read_data_length = smb2_read_data_length,\n\t.map_error = map_smb2_to_linux_error,\n\t.find_mid = smb2_find_mid,\n\t.check_message = smb2_check_message,\n\t.dump_detail = smb2_dump_detail,\n\t.clear_stats = smb2_clear_stats,\n\t.print_stats = smb2_print_stats,\n\t.is_oplock_break = smb2_is_valid_oplock_break,\n\t.handle_cancelled_mid = smb2_handle_cancelled_mid,\n\t.downgrade_oplock = smb2_downgrade_oplock,\n\t.need_neg = smb2_need_neg,\n\t.negotiate = smb2_negotiate,\n\t.negotiate_wsize = smb2_negotiate_wsize,\n\t.negotiate_rsize = smb2_negotiate_rsize,\n\t.sess_setup = SMB2_sess_setup,\n\t.logoff = SMB2_logoff,\n\t.tree_connect = SMB2_tcon,\n\t.tree_disconnect = SMB2_tdis,\n\t.qfs_tcon = smb2_qfs_tcon,\n\t.is_path_accessible = smb2_is_path_accessible,\n\t.can_echo = smb2_can_echo,\n\t.echo = SMB2_echo,\n\t.query_path_info = smb2_query_path_info,\n\t.query_reparse_point = smb2_query_reparse_point,\n\t.get_srv_inum = smb2_get_srv_inum,\n\t.query_file_info = smb2_query_file_info,\n\t.set_path_size = smb2_set_path_size,\n\t.set_file_size = smb2_set_file_size,\n\t.set_file_info = smb2_set_file_info,\n\t.set_compression = smb2_set_compression,\n\t.mkdir = smb2_mkdir,\n\t.mkdir_setinfo = smb2_mkdir_setinfo,\n\t.rmdir = smb2_rmdir,\n\t.unlink = smb2_unlink,\n\t.rename = smb2_rename_path,\n\t.create_hardlink = smb2_create_hardlink,\n\t.parse_reparse_point = smb2_parse_reparse_point,\n\t.query_mf_symlink = smb3_query_mf_symlink,\n\t.create_mf_symlink = smb3_create_mf_symlink,\n\t.open = smb2_open_file,\n\t.set_fid = smb2_set_fid,\n\t.close = smb2_close_file,\n\t.flush = smb2_flush_file,\n\t.async_readv = smb2_async_readv,\n\t.async_writev = smb2_async_writev,\n\t.sync_read = smb2_sync_read,\n\t.sync_write = smb2_sync_write,\n\t.query_dir_first = smb2_query_dir_first,\n\t.query_dir_next = smb2_query_dir_next,\n\t.close_dir = smb2_close_dir,\n\t.calc_smb_size = smb2_calc_size,\n\t.is_status_pending = smb2_is_status_pending,\n\t.is_session_expired = smb2_is_session_expired,\n\t.oplock_response = smb2_oplock_response,\n\t.queryfs = smb2_queryfs,\n\t.mand_lock = smb2_mand_lock,\n\t.mand_unlock_range = smb2_unlock_range,\n\t.push_mand_locks = smb2_push_mandatory_locks,\n\t.get_lease_key = smb2_get_lease_key,\n\t.set_lease_key = smb2_set_lease_key,\n\t.new_lease_key = smb2_new_lease_key,\n\t.calc_signature = smb2_calc_signature,\n\t.is_read_op = smb21_is_read_op,\n\t.set_oplock_level = smb21_set_oplock_level,\n\t.create_lease_buf = smb2_create_lease_buf,\n\t.parse_lease_buf = smb2_parse_lease_buf,\n\t.copychunk_range = smb2_copychunk_range,\n\t.wp_retry_size = smb2_wp_retry_size,\n\t.dir_needs_close = smb2_dir_needs_close,\n\t.enum_snapshots = smb3_enum_snapshots,\n\t.notify = smb3_notify,\n\t.get_dfs_refer = smb2_get_dfs_refer,\n\t.select_sectype = smb2_select_sectype,\n#ifdef CONFIG_CIFS_XATTR\n\t.query_all_EAs = smb2_query_eas,\n\t.set_EA = smb2_set_ea,\n#endif  \n\t.get_acl = get_smb2_acl,\n\t.get_acl_by_fid = get_smb2_acl_by_fid,\n\t.set_acl = set_smb2_acl,\n\t.next_header = smb2_next_header,\n\t.ioctl_query_info = smb2_ioctl_query_info,\n\t.make_node = smb2_make_node,\n\t.fiemap = smb3_fiemap,\n\t.llseek = smb3_llseek,\n\t.is_status_io_timeout = smb2_is_status_io_timeout,\n\t.is_network_name_deleted = smb2_is_network_name_deleted,\n};\n\nstruct smb_version_operations smb30_operations = {\n\t.compare_fids = smb2_compare_fids,\n\t.setup_request = smb2_setup_request,\n\t.setup_async_request = smb2_setup_async_request,\n\t.check_receive = smb2_check_receive,\n\t.add_credits = smb2_add_credits,\n\t.set_credits = smb2_set_credits,\n\t.get_credits_field = smb2_get_credits_field,\n\t.get_credits = smb2_get_credits,\n\t.wait_mtu_credits = smb2_wait_mtu_credits,\n\t.adjust_credits = smb2_adjust_credits,\n\t.get_next_mid = smb2_get_next_mid,\n\t.revert_current_mid = smb2_revert_current_mid,\n\t.read_data_offset = smb2_read_data_offset,\n\t.read_data_length = smb2_read_data_length,\n\t.map_error = map_smb2_to_linux_error,\n\t.find_mid = smb2_find_mid,\n\t.check_message = smb2_check_message,\n\t.dump_detail = smb2_dump_detail,\n\t.clear_stats = smb2_clear_stats,\n\t.print_stats = smb2_print_stats,\n\t.dump_share_caps = smb2_dump_share_caps,\n\t.is_oplock_break = smb2_is_valid_oplock_break,\n\t.handle_cancelled_mid = smb2_handle_cancelled_mid,\n\t.downgrade_oplock = smb3_downgrade_oplock,\n\t.need_neg = smb2_need_neg,\n\t.negotiate = smb2_negotiate,\n\t.negotiate_wsize = smb3_negotiate_wsize,\n\t.negotiate_rsize = smb3_negotiate_rsize,\n\t.sess_setup = SMB2_sess_setup,\n\t.logoff = SMB2_logoff,\n\t.tree_connect = SMB2_tcon,\n\t.tree_disconnect = SMB2_tdis,\n\t.qfs_tcon = smb3_qfs_tcon,\n\t.is_path_accessible = smb2_is_path_accessible,\n\t.can_echo = smb2_can_echo,\n\t.echo = SMB2_echo,\n\t.query_path_info = smb2_query_path_info,\n\t \n\t.query_reparse_point = smb2_query_reparse_point,\n\t.get_srv_inum = smb2_get_srv_inum,\n\t.query_file_info = smb2_query_file_info,\n\t.set_path_size = smb2_set_path_size,\n\t.set_file_size = smb2_set_file_size,\n\t.set_file_info = smb2_set_file_info,\n\t.set_compression = smb2_set_compression,\n\t.mkdir = smb2_mkdir,\n\t.mkdir_setinfo = smb2_mkdir_setinfo,\n\t.rmdir = smb2_rmdir,\n\t.unlink = smb2_unlink,\n\t.rename = smb2_rename_path,\n\t.create_hardlink = smb2_create_hardlink,\n\t.parse_reparse_point = smb2_parse_reparse_point,\n\t.query_mf_symlink = smb3_query_mf_symlink,\n\t.create_mf_symlink = smb3_create_mf_symlink,\n\t.open = smb2_open_file,\n\t.set_fid = smb2_set_fid,\n\t.close = smb2_close_file,\n\t.close_getattr = smb2_close_getattr,\n\t.flush = smb2_flush_file,\n\t.async_readv = smb2_async_readv,\n\t.async_writev = smb2_async_writev,\n\t.sync_read = smb2_sync_read,\n\t.sync_write = smb2_sync_write,\n\t.query_dir_first = smb2_query_dir_first,\n\t.query_dir_next = smb2_query_dir_next,\n\t.close_dir = smb2_close_dir,\n\t.calc_smb_size = smb2_calc_size,\n\t.is_status_pending = smb2_is_status_pending,\n\t.is_session_expired = smb2_is_session_expired,\n\t.oplock_response = smb2_oplock_response,\n\t.queryfs = smb2_queryfs,\n\t.mand_lock = smb2_mand_lock,\n\t.mand_unlock_range = smb2_unlock_range,\n\t.push_mand_locks = smb2_push_mandatory_locks,\n\t.get_lease_key = smb2_get_lease_key,\n\t.set_lease_key = smb2_set_lease_key,\n\t.new_lease_key = smb2_new_lease_key,\n\t.generate_signingkey = generate_smb30signingkey,\n\t.calc_signature = smb3_calc_signature,\n\t.set_integrity  = smb3_set_integrity,\n\t.is_read_op = smb21_is_read_op,\n\t.set_oplock_level = smb3_set_oplock_level,\n\t.create_lease_buf = smb3_create_lease_buf,\n\t.parse_lease_buf = smb3_parse_lease_buf,\n\t.copychunk_range = smb2_copychunk_range,\n\t.duplicate_extents = smb2_duplicate_extents,\n\t.validate_negotiate = smb3_validate_negotiate,\n\t.wp_retry_size = smb2_wp_retry_size,\n\t.dir_needs_close = smb2_dir_needs_close,\n\t.fallocate = smb3_fallocate,\n\t.enum_snapshots = smb3_enum_snapshots,\n\t.notify = smb3_notify,\n\t.init_transform_rq = smb3_init_transform_rq,\n\t.is_transform_hdr = smb3_is_transform_hdr,\n\t.receive_transform = smb3_receive_transform,\n\t.get_dfs_refer = smb2_get_dfs_refer,\n\t.select_sectype = smb2_select_sectype,\n#ifdef CONFIG_CIFS_XATTR\n\t.query_all_EAs = smb2_query_eas,\n\t.set_EA = smb2_set_ea,\n#endif  \n\t.get_acl = get_smb2_acl,\n\t.get_acl_by_fid = get_smb2_acl_by_fid,\n\t.set_acl = set_smb2_acl,\n\t.next_header = smb2_next_header,\n\t.ioctl_query_info = smb2_ioctl_query_info,\n\t.make_node = smb2_make_node,\n\t.fiemap = smb3_fiemap,\n\t.llseek = smb3_llseek,\n\t.is_status_io_timeout = smb2_is_status_io_timeout,\n\t.is_network_name_deleted = smb2_is_network_name_deleted,\n};\n\nstruct smb_version_operations smb311_operations = {\n\t.compare_fids = smb2_compare_fids,\n\t.setup_request = smb2_setup_request,\n\t.setup_async_request = smb2_setup_async_request,\n\t.check_receive = smb2_check_receive,\n\t.add_credits = smb2_add_credits,\n\t.set_credits = smb2_set_credits,\n\t.get_credits_field = smb2_get_credits_field,\n\t.get_credits = smb2_get_credits,\n\t.wait_mtu_credits = smb2_wait_mtu_credits,\n\t.adjust_credits = smb2_adjust_credits,\n\t.get_next_mid = smb2_get_next_mid,\n\t.revert_current_mid = smb2_revert_current_mid,\n\t.read_data_offset = smb2_read_data_offset,\n\t.read_data_length = smb2_read_data_length,\n\t.map_error = map_smb2_to_linux_error,\n\t.find_mid = smb2_find_mid,\n\t.check_message = smb2_check_message,\n\t.dump_detail = smb2_dump_detail,\n\t.clear_stats = smb2_clear_stats,\n\t.print_stats = smb2_print_stats,\n\t.dump_share_caps = smb2_dump_share_caps,\n\t.is_oplock_break = smb2_is_valid_oplock_break,\n\t.handle_cancelled_mid = smb2_handle_cancelled_mid,\n\t.downgrade_oplock = smb3_downgrade_oplock,\n\t.need_neg = smb2_need_neg,\n\t.negotiate = smb2_negotiate,\n\t.negotiate_wsize = smb3_negotiate_wsize,\n\t.negotiate_rsize = smb3_negotiate_rsize,\n\t.sess_setup = SMB2_sess_setup,\n\t.logoff = SMB2_logoff,\n\t.tree_connect = SMB2_tcon,\n\t.tree_disconnect = SMB2_tdis,\n\t.qfs_tcon = smb3_qfs_tcon,\n\t.is_path_accessible = smb2_is_path_accessible,\n\t.can_echo = smb2_can_echo,\n\t.echo = SMB2_echo,\n\t.query_path_info = smb2_query_path_info,\n\t.query_reparse_point = smb2_query_reparse_point,\n\t.get_srv_inum = smb2_get_srv_inum,\n\t.query_file_info = smb2_query_file_info,\n\t.set_path_size = smb2_set_path_size,\n\t.set_file_size = smb2_set_file_size,\n\t.set_file_info = smb2_set_file_info,\n\t.set_compression = smb2_set_compression,\n\t.mkdir = smb2_mkdir,\n\t.mkdir_setinfo = smb2_mkdir_setinfo,\n\t.posix_mkdir = smb311_posix_mkdir,\n\t.rmdir = smb2_rmdir,\n\t.unlink = smb2_unlink,\n\t.rename = smb2_rename_path,\n\t.create_hardlink = smb2_create_hardlink,\n\t.parse_reparse_point = smb2_parse_reparse_point,\n\t.query_mf_symlink = smb3_query_mf_symlink,\n\t.create_mf_symlink = smb3_create_mf_symlink,\n\t.open = smb2_open_file,\n\t.set_fid = smb2_set_fid,\n\t.close = smb2_close_file,\n\t.close_getattr = smb2_close_getattr,\n\t.flush = smb2_flush_file,\n\t.async_readv = smb2_async_readv,\n\t.async_writev = smb2_async_writev,\n\t.sync_read = smb2_sync_read,\n\t.sync_write = smb2_sync_write,\n\t.query_dir_first = smb2_query_dir_first,\n\t.query_dir_next = smb2_query_dir_next,\n\t.close_dir = smb2_close_dir,\n\t.calc_smb_size = smb2_calc_size,\n\t.is_status_pending = smb2_is_status_pending,\n\t.is_session_expired = smb2_is_session_expired,\n\t.oplock_response = smb2_oplock_response,\n\t.queryfs = smb311_queryfs,\n\t.mand_lock = smb2_mand_lock,\n\t.mand_unlock_range = smb2_unlock_range,\n\t.push_mand_locks = smb2_push_mandatory_locks,\n\t.get_lease_key = smb2_get_lease_key,\n\t.set_lease_key = smb2_set_lease_key,\n\t.new_lease_key = smb2_new_lease_key,\n\t.generate_signingkey = generate_smb311signingkey,\n\t.calc_signature = smb3_calc_signature,\n\t.set_integrity  = smb3_set_integrity,\n\t.is_read_op = smb21_is_read_op,\n\t.set_oplock_level = smb3_set_oplock_level,\n\t.create_lease_buf = smb3_create_lease_buf,\n\t.parse_lease_buf = smb3_parse_lease_buf,\n\t.copychunk_range = smb2_copychunk_range,\n\t.duplicate_extents = smb2_duplicate_extents,\n   \n\t.wp_retry_size = smb2_wp_retry_size,\n\t.dir_needs_close = smb2_dir_needs_close,\n\t.fallocate = smb3_fallocate,\n\t.enum_snapshots = smb3_enum_snapshots,\n\t.notify = smb3_notify,\n\t.init_transform_rq = smb3_init_transform_rq,\n\t.is_transform_hdr = smb3_is_transform_hdr,\n\t.receive_transform = smb3_receive_transform,\n\t.get_dfs_refer = smb2_get_dfs_refer,\n\t.select_sectype = smb2_select_sectype,\n#ifdef CONFIG_CIFS_XATTR\n\t.query_all_EAs = smb2_query_eas,\n\t.set_EA = smb2_set_ea,\n#endif  \n\t.get_acl = get_smb2_acl,\n\t.get_acl_by_fid = get_smb2_acl_by_fid,\n\t.set_acl = set_smb2_acl,\n\t.next_header = smb2_next_header,\n\t.ioctl_query_info = smb2_ioctl_query_info,\n\t.make_node = smb2_make_node,\n\t.fiemap = smb3_fiemap,\n\t.llseek = smb3_llseek,\n\t.is_status_io_timeout = smb2_is_status_io_timeout,\n\t.is_network_name_deleted = smb2_is_network_name_deleted,\n};\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstruct smb_version_values smb20_values = {\n\t.version_string = SMB20_VERSION_STRING,\n\t.protocol_id = SMB20_PROT_ID,\n\t.req_capabilities = 0,  \n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease),\n};\n#endif  \n\nstruct smb_version_values smb21_values = {\n\t.version_string = SMB21_VERSION_STRING,\n\t.protocol_id = SMB21_PROT_ID,\n\t.req_capabilities = 0,  \n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease),\n};\n\nstruct smb_version_values smb3any_values = {\n\t.version_string = SMB3ANY_VERSION_STRING,\n\t.protocol_id = SMB302_PROT_ID,  \n\t.req_capabilities = SMB2_GLOBAL_CAP_DFS | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_PERSISTENT_HANDLES | SMB2_GLOBAL_CAP_ENCRYPTION | SMB2_GLOBAL_CAP_DIRECTORY_LEASING,\n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease_v2),\n};\n\nstruct smb_version_values smbdefault_values = {\n\t.version_string = SMBDEFAULT_VERSION_STRING,\n\t.protocol_id = SMB302_PROT_ID,  \n\t.req_capabilities = SMB2_GLOBAL_CAP_DFS | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_PERSISTENT_HANDLES | SMB2_GLOBAL_CAP_ENCRYPTION | SMB2_GLOBAL_CAP_DIRECTORY_LEASING,\n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease_v2),\n};\n\nstruct smb_version_values smb30_values = {\n\t.version_string = SMB30_VERSION_STRING,\n\t.protocol_id = SMB30_PROT_ID,\n\t.req_capabilities = SMB2_GLOBAL_CAP_DFS | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_PERSISTENT_HANDLES | SMB2_GLOBAL_CAP_ENCRYPTION | SMB2_GLOBAL_CAP_DIRECTORY_LEASING,\n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease_v2),\n};\n\nstruct smb_version_values smb302_values = {\n\t.version_string = SMB302_VERSION_STRING,\n\t.protocol_id = SMB302_PROT_ID,\n\t.req_capabilities = SMB2_GLOBAL_CAP_DFS | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_PERSISTENT_HANDLES | SMB2_GLOBAL_CAP_ENCRYPTION | SMB2_GLOBAL_CAP_DIRECTORY_LEASING,\n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease_v2),\n};\n\nstruct smb_version_values smb311_values = {\n\t.version_string = SMB311_VERSION_STRING,\n\t.protocol_id = SMB311_PROT_ID,\n\t.req_capabilities = SMB2_GLOBAL_CAP_DFS | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_PERSISTENT_HANDLES | SMB2_GLOBAL_CAP_ENCRYPTION | SMB2_GLOBAL_CAP_DIRECTORY_LEASING,\n\t.large_lock_type = 0,\n\t.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,\n\t.shared_lock_type = SMB2_LOCKFLAG_SHARED,\n\t.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,\n\t.header_size = sizeof(struct smb2_hdr),\n\t.header_preamble_size = 0,\n\t.max_header_size = MAX_SMB2_HDR_SIZE,\n\t.read_rsp_size = sizeof(struct smb2_read_rsp),\n\t.lock_cmd = SMB2_LOCK,\n\t.cap_unix = 0,\n\t.cap_nt_find = SMB2_NT_FIND,\n\t.cap_large_files = SMB2_LARGE_FILES,\n\t.signing_enabled = SMB2_NEGOTIATE_SIGNING_ENABLED | SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.signing_required = SMB2_NEGOTIATE_SIGNING_REQUIRED,\n\t.create_lease_size = sizeof(struct create_lease_v2),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}