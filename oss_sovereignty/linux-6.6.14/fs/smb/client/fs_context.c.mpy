{
  "module_name": "fs_context.c",
  "hash_id": "02472ad0ec1020c80ff2a47fec8bb4b2ea68dbe8ac2e68b6cb6aebcd6f177264",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/fs_context.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ctype.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/utsname.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fs_context.h\"\n\nstatic DEFINE_MUTEX(cifs_mount_mutex);\n\nstatic const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n\t{ Smb_302, SMB302_VERSION_STRING },\n\t{ Smb_302, ALT_SMB302_VERSION_STRING },\n\t{ Smb_311, SMB311_VERSION_STRING },\n\t{ Smb_311, ALT_SMB311_VERSION_STRING },\n\t{ Smb_3any, SMB3ANY_VERSION_STRING },\n\t{ Smb_default, SMBDEFAULT_VERSION_STRING },\n\t{ Smb_version_err, NULL }\n};\n\nstatic const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};\n\nconst struct fs_parameter_spec smb3_fs_parameters[] = {\n\t \n\tfsparam_flag_no(\"user_xattr\", Opt_user_xattr),\n\tfsparam_flag_no(\"forceuid\", Opt_forceuid),\n\tfsparam_flag_no(\"multichannel\", Opt_multichannel),\n\tfsparam_flag_no(\"forcegid\", Opt_forcegid),\n\tfsparam_flag(\"noblocksend\", Opt_noblocksend),\n\tfsparam_flag(\"noautotune\", Opt_noautotune),\n\tfsparam_flag(\"nolease\", Opt_nolease),\n\tfsparam_flag_no(\"hard\", Opt_hard),\n\tfsparam_flag_no(\"soft\", Opt_soft),\n\tfsparam_flag_no(\"perm\", Opt_perm),\n\tfsparam_flag(\"nodelete\", Opt_nodelete),\n\tfsparam_flag_no(\"mapposix\", Opt_mapposix),\n\tfsparam_flag(\"mapchars\", Opt_mapchars),\n\tfsparam_flag(\"nomapchars\", Opt_nomapchars),\n\tfsparam_flag_no(\"sfu\", Opt_sfu),\n\tfsparam_flag(\"nodfs\", Opt_nodfs),\n\tfsparam_flag_no(\"posixpaths\", Opt_posixpaths),\n\tfsparam_flag_no(\"unix\", Opt_unix),\n\tfsparam_flag_no(\"linux\", Opt_unix),\n\tfsparam_flag_no(\"posix\", Opt_unix),\n\tfsparam_flag(\"nocase\", Opt_nocase),\n\tfsparam_flag(\"ignorecase\", Opt_nocase),\n\tfsparam_flag_no(\"brl\", Opt_brl),\n\tfsparam_flag_no(\"handlecache\", Opt_handlecache),\n\tfsparam_flag(\"forcemandatorylock\", Opt_forcemandatorylock),\n\tfsparam_flag(\"forcemand\", Opt_forcemandatorylock),\n\tfsparam_flag(\"setuidfromacl\", Opt_setuidfromacl),\n\tfsparam_flag(\"idsfromsid\", Opt_setuidfromacl),\n\tfsparam_flag_no(\"setuids\", Opt_setuids),\n\tfsparam_flag_no(\"dynperm\", Opt_dynperm),\n\tfsparam_flag_no(\"intr\", Opt_intr),\n\tfsparam_flag_no(\"strictsync\", Opt_strictsync),\n\tfsparam_flag_no(\"serverino\", Opt_serverino),\n\tfsparam_flag(\"rwpidforward\", Opt_rwpidforward),\n\tfsparam_flag(\"cifsacl\", Opt_cifsacl),\n\tfsparam_flag_no(\"acl\", Opt_acl),\n\tfsparam_flag(\"locallease\", Opt_locallease),\n\tfsparam_flag(\"sign\", Opt_sign),\n\tfsparam_flag(\"ignore_signature\", Opt_ignore_signature),\n\tfsparam_flag(\"signloosely\", Opt_ignore_signature),\n\tfsparam_flag(\"seal\", Opt_seal),\n\tfsparam_flag(\"noac\", Opt_noac),\n\tfsparam_flag(\"fsc\", Opt_fsc),\n\tfsparam_flag(\"mfsymlinks\", Opt_mfsymlinks),\n\tfsparam_flag(\"multiuser\", Opt_multiuser),\n\tfsparam_flag(\"sloppy\", Opt_sloppy),\n\tfsparam_flag(\"nosharesock\", Opt_nosharesock),\n\tfsparam_flag_no(\"persistenthandles\", Opt_persistent),\n\tfsparam_flag_no(\"resilienthandles\", Opt_resilient),\n\tfsparam_flag_no(\"tcpnodelay\", Opt_tcp_nodelay),\n\tfsparam_flag(\"nosparse\", Opt_nosparse),\n\tfsparam_flag(\"domainauto\", Opt_domainauto),\n\tfsparam_flag(\"rdma\", Opt_rdma),\n\tfsparam_flag(\"modesid\", Opt_modesid),\n\tfsparam_flag(\"modefromsid\", Opt_modesid),\n\tfsparam_flag(\"rootfs\", Opt_rootfs),\n\tfsparam_flag(\"compress\", Opt_compress),\n\tfsparam_flag(\"witness\", Opt_witness),\n\n\t \n\tfsparam_u32(\"backupuid\", Opt_backupuid),\n\tfsparam_u32(\"backupgid\", Opt_backupgid),\n\tfsparam_u32(\"uid\", Opt_uid),\n\tfsparam_u32(\"cruid\", Opt_cruid),\n\tfsparam_u32(\"gid\", Opt_gid),\n\tfsparam_u32(\"file_mode\", Opt_file_mode),\n\tfsparam_u32(\"dirmode\", Opt_dirmode),\n\tfsparam_u32(\"dir_mode\", Opt_dirmode),\n\tfsparam_u32(\"port\", Opt_port),\n\tfsparam_u32(\"min_enc_offload\", Opt_min_enc_offload),\n\tfsparam_u32(\"esize\", Opt_min_enc_offload),\n\tfsparam_u32(\"bsize\", Opt_blocksize),\n\tfsparam_u32(\"rasize\", Opt_rasize),\n\tfsparam_u32(\"rsize\", Opt_rsize),\n\tfsparam_u32(\"wsize\", Opt_wsize),\n\tfsparam_u32(\"actimeo\", Opt_actimeo),\n\tfsparam_u32(\"acdirmax\", Opt_acdirmax),\n\tfsparam_u32(\"acregmax\", Opt_acregmax),\n\tfsparam_u32(\"closetimeo\", Opt_closetimeo),\n\tfsparam_u32(\"echo_interval\", Opt_echo_interval),\n\tfsparam_u32(\"max_credits\", Opt_max_credits),\n\tfsparam_u32(\"max_cached_dirs\", Opt_max_cached_dirs),\n\tfsparam_u32(\"handletimeout\", Opt_handletimeout),\n\tfsparam_u64(\"snapshot\", Opt_snapshot),\n\tfsparam_u32(\"max_channels\", Opt_max_channels),\n\n\t \n\tfsparam_string(\"source\", Opt_source),\n\tfsparam_string(\"user\", Opt_user),\n\tfsparam_string(\"username\", Opt_user),\n\tfsparam_string(\"pass\", Opt_pass),\n\tfsparam_string(\"password\", Opt_pass),\n\tfsparam_string(\"ip\", Opt_ip),\n\tfsparam_string(\"addr\", Opt_ip),\n\tfsparam_string(\"domain\", Opt_domain),\n\tfsparam_string(\"dom\", Opt_domain),\n\tfsparam_string(\"srcaddr\", Opt_srcaddr),\n\tfsparam_string(\"iocharset\", Opt_iocharset),\n\tfsparam_string(\"netbiosname\", Opt_netbiosname),\n\tfsparam_string(\"servern\", Opt_servern),\n\tfsparam_string(\"ver\", Opt_ver),\n\tfsparam_string(\"vers\", Opt_vers),\n\tfsparam_string(\"sec\", Opt_sec),\n\tfsparam_string(\"cache\", Opt_cache),\n\n\t \n\tfsparam_flag(\"guest\", Opt_ignore),\n\tfsparam_flag(\"noatime\", Opt_ignore),\n\tfsparam_flag(\"relatime\", Opt_ignore),\n\tfsparam_flag(\"_netdev\", Opt_ignore),\n\tfsparam_flag_no(\"suid\", Opt_ignore),\n\tfsparam_flag_no(\"exec\", Opt_ignore),\n\tfsparam_flag_no(\"dev\", Opt_ignore),\n\tfsparam_flag_no(\"mand\", Opt_ignore),\n\tfsparam_flag_no(\"auto\", Opt_ignore),\n\tfsparam_string(\"cred\", Opt_ignore),\n\tfsparam_string(\"credentials\", Opt_ignore),\n\t \n\tfsparam_string(\"unc\", Opt_ignore),\n\tfsparam_string(\"prefixpath\", Opt_ignore),\n\t{}\n};\n\nstatic int\ncifs_parse_security_flavors(struct fs_context *fc, char *value, struct smb3_fs_context *ctx)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t \n\tctx->sectype = Unspecified;\n\tctx->sign = false;\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5p:\n\t\tcifs_errorf(fc, \"sec=krb5p is not supported!\\n\");\n\t\treturn 1;\n\tcase Opt_sec_krb5i:\n\t\tctx->sign = true;\n\t\tfallthrough;\n\tcase Opt_sec_krb5:\n\t\tctx->sectype = Kerberos;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tctx->sign = true;\n\t\tfallthrough;\n\tcase Opt_sec_ntlmssp:\n\t\tctx->sectype = RawNTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tctx->sign = true;\n\t\tfallthrough;\n\tcase Opt_sec_ntlmv2:\n\t\tctx->sectype = NTLMv2;\n\t\tbreak;\n\tcase Opt_sec_none:\n\t\tctx->nullauth = 1;\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tbreak;\n\tdefault:\n\t\tcifs_errorf(fc, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_ro, \"ro\" },\n\t{ Opt_cache_rw, \"singleclient\" },\n\t{ Opt_cache_err, NULL }\n};\n\nstatic int\ncifs_parse_cache_flavor(struct fs_context *fc, char *value, struct smb3_fs_context *ctx)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tctx->direct_io = false;\n\t\tctx->strict_io = false;\n\t\tctx->cache_ro = false;\n\t\tctx->cache_rw = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tctx->direct_io = false;\n\t\tctx->strict_io = true;\n\t\tctx->cache_ro = false;\n\t\tctx->cache_rw = false;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tctx->direct_io = true;\n\t\tctx->strict_io = false;\n\t\tctx->cache_ro = false;\n\t\tctx->cache_rw = false;\n\t\tbreak;\n\tcase Opt_cache_ro:\n\t\tctx->direct_io = false;\n\t\tctx->strict_io = false;\n\t\tctx->cache_ro = true;\n\t\tctx->cache_rw = false;\n\t\tbreak;\n\tcase Opt_cache_rw:\n\t\tctx->direct_io = false;\n\t\tctx->strict_io = false;\n\t\tctx->cache_ro = false;\n\t\tctx->cache_rw = true;\n\t\tbreak;\n\tdefault:\n\t\tcifs_errorf(fc, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define DUP_CTX_STR(field)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (ctx->field) {\t\t\t\t\t\t\\\n\t\tnew_ctx->field = kstrdup(ctx->field, GFP_ATOMIC);\t\\\n\t\tif (new_ctx->field == NULL) {\t\t\t\t\\\n\t\t\tsmb3_cleanup_fs_context_contents(new_ctx);\t\\\n\t\t\treturn -ENOMEM;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nint\nsmb3_fs_context_dup(struct smb3_fs_context *new_ctx, struct smb3_fs_context *ctx)\n{\n\tmemcpy(new_ctx, ctx, sizeof(*ctx));\n\tnew_ctx->prepath = NULL;\n\tnew_ctx->nodename = NULL;\n\tnew_ctx->username = NULL;\n\tnew_ctx->password = NULL;\n\tnew_ctx->server_hostname = NULL;\n\tnew_ctx->domainname = NULL;\n\tnew_ctx->UNC = NULL;\n\tnew_ctx->source = NULL;\n\tnew_ctx->iocharset = NULL;\n\tnew_ctx->leaf_fullpath = NULL;\n\t \n\tDUP_CTX_STR(prepath);\n\tDUP_CTX_STR(username);\n\tDUP_CTX_STR(password);\n\tDUP_CTX_STR(server_hostname);\n\tDUP_CTX_STR(UNC);\n\tDUP_CTX_STR(source);\n\tDUP_CTX_STR(domainname);\n\tDUP_CTX_STR(nodename);\n\tDUP_CTX_STR(iocharset);\n\tDUP_CTX_STR(leaf_fullpath);\n\n\treturn 0;\n}\n\nstatic int\ncifs_parse_smb_version(struct fs_context *fc, char *value, struct smb3_fs_context *ctx, bool is_smb3)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tcase Smb_1:\n\t\tif (disable_legacy_dialects) {\n\t\t\tcifs_errorf(fc, \"mount with legacy dialect disabled\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (is_smb3) {\n\t\t\tcifs_errorf(fc, \"vers=1.0 (cifs) not permitted when mounting with smb3\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tcifs_errorf(fc, \"Use of the less secure dialect vers=1.0 is not recommended unless required for access to very old servers\\n\");\n\t\tctx->ops = &smb1_operations;\n\t\tctx->vals = &smb1_values;\n\t\tbreak;\n\tcase Smb_20:\n\t\tif (disable_legacy_dialects) {\n\t\t\tcifs_errorf(fc, \"mount with legacy dialect disabled\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (is_smb3) {\n\t\t\tcifs_errorf(fc, \"vers=2.0 not permitted when mounting with smb3\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tctx->ops = &smb20_operations;\n\t\tctx->vals = &smb20_values;\n\t\tbreak;\n#else\n\tcase Smb_1:\n\t\tcifs_errorf(fc, \"vers=1.0 (cifs) mount not permitted when legacy dialects disabled\\n\");\n\t\treturn 1;\n\tcase Smb_20:\n\t\tcifs_errorf(fc, \"vers=2.0 mount not permitted when legacy dialects disabled\\n\");\n\t\treturn 1;\n#endif  \n\tcase Smb_21:\n\t\tctx->ops = &smb21_operations;\n\t\tctx->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tctx->ops = &smb30_operations;\n\t\tctx->vals = &smb30_values;\n\t\tbreak;\n\tcase Smb_302:\n\t\tctx->ops = &smb30_operations;  \n\t\tctx->vals = &smb302_values;\n\t\tbreak;\n\tcase Smb_311:\n\t\tctx->ops = &smb311_operations;\n\t\tctx->vals = &smb311_values;\n\t\tbreak;\n\tcase Smb_3any:\n\t\tctx->ops = &smb30_operations;  \n\t\tctx->vals = &smb3any_values;\n\t\tbreak;\n\tcase Smb_default:\n\t\tctx->ops = &smb30_operations;\n\t\tctx->vals = &smbdefault_values;\n\t\tbreak;\n\tdefault:\n\t\tcifs_errorf(fc, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint smb3_parse_opt(const char *options, const char *key, char **val)\n{\n\tint rc = -ENOENT;\n\tchar *opts, *orig, *p;\n\n\torig = opts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\twhile ((p = strsep(&opts, \",\"))) {\n\t\tchar *nval;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\tif (strncasecmp(p, key, strlen(key)))\n\t\t\tcontinue;\n\t\tnval = strchr(p, '=');\n\t\tif (nval) {\n\t\t\tif (nval == p)\n\t\t\t\tcontinue;\n\t\t\t*nval++ = 0;\n\t\t\t*val = kstrdup(nval, GFP_KERNEL);\n\t\t\trc = !*val ? -ENOMEM : 0;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree(orig);\n\treturn rc;\n}\n\n \n#define IS_DELIM(c) ((c) == '/' || (c) == '\\\\')\nchar *cifs_sanitize_prepath(char *prepath, gfp_t gfp)\n{\n\tchar *cursor1 = prepath, *cursor2 = prepath;\n\tchar *s;\n\n\t \n\twhile (IS_DELIM(*cursor1))\n\t\tcursor1++;\n\n\t \n\t*cursor2 = *cursor1;\n\n\t \n\twhile (*(cursor1++)) {\n\t\t \n\t\tif (IS_DELIM(*cursor1) && IS_DELIM(*cursor2))\n\t\t\tcontinue;\n\t\t*(++cursor2) = *cursor1;\n\t}\n\n\t \n\tif (IS_DELIM(*(cursor2 - 1)))\n\t\tcursor2--;\n\n\t*cursor2 = '\\0';\n\tif (!*prepath)\n\t\treturn NULL;\n\ts = kstrdup(prepath, gfp);\n\tif (!s)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn s;\n}\n\n \nchar *smb3_fs_context_fullpath(const struct smb3_fs_context *ctx, char dirsep)\n{\n\tsize_t ulen, plen;\n\tchar *s;\n\n\tulen = strlen(ctx->UNC);\n\tplen = ctx->prepath ? strlen(ctx->prepath) + 1 : 0;\n\n\ts = kmalloc(ulen + plen + 1, GFP_KERNEL);\n\tif (!s)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemcpy(s, ctx->UNC, ulen);\n\tif (plen) {\n\t\ts[ulen] = dirsep;\n\t\tmemcpy(s + ulen + 1, ctx->prepath, plen);\n\t}\n\ts[ulen + plen] = '\\0';\n\tconvert_delimiter(s, dirsep);\n\treturn s;\n}\n\n \nint\nsmb3_parse_devname(const char *devname, struct smb3_fs_context *ctx)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\tint rc;\n\n\tif (unlikely(!devname || !*devname)) {\n\t\tcifs_dbg(VFS, \"Device name not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t \n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t \n\tkfree(ctx->server_hostname);\n\tctx->server_hostname = kstrndup(devname + 2, pos - devname - 2, GFP_KERNEL);\n\tif (!ctx->server_hostname)\n\t\treturn -ENOMEM;\n\n\t \n\t++pos;\n\n\t \n\tlen = strcspn(pos, delims);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t \n\tpos += len;\n\tkfree(ctx->UNC);\n\tctx->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!ctx->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(ctx->UNC, '\\\\');\n\n\t \n\tif (*pos == '/' || *pos == '\\\\')\n\t\tpos++;\n\n\tkfree(ctx->prepath);\n\tctx->prepath = NULL;\n\n\t \n\tif (!*pos)\n\t\treturn 0;\n\n\tctx->prepath = cifs_sanitize_prepath(pos, GFP_KERNEL);\n\tif (IS_ERR(ctx->prepath)) {\n\t\trc = PTR_ERR(ctx->prepath);\n\t\tctx->prepath = NULL;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void smb3_fs_context_free(struct fs_context *fc);\nstatic int smb3_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t       struct fs_parameter *param);\nstatic int smb3_fs_context_parse_monolithic(struct fs_context *fc,\n\t\t\t\t\t    void *data);\nstatic int smb3_get_tree(struct fs_context *fc);\nstatic int smb3_reconfigure(struct fs_context *fc);\n\nstatic const struct fs_context_operations smb3_fs_context_ops = {\n\t.free\t\t\t= smb3_fs_context_free,\n\t.parse_param\t\t= smb3_fs_context_parse_param,\n\t.parse_monolithic\t= smb3_fs_context_parse_monolithic,\n\t.get_tree\t\t= smb3_get_tree,\n\t.reconfigure\t\t= smb3_reconfigure,\n};\n\n \nstatic int smb3_fs_context_parse_monolithic(struct fs_context *fc,\n\t\t\t\t\t   void *data)\n{\n\tchar *options = data, *key;\n\tint ret = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\tret = security_sb_eat_lsm_opts(options, &fc->security);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twhile ((key = strsep(&options, \",\")) != NULL) {\n\t\tsize_t len;\n\t\tchar *value;\n\n\t\tif (*key == 0)\n\t\t\tbreak;\n\n\t\t \n\t\twhile (options && options[0] == ',') {\n\t\t\tlen = strlen(key);\n\t\t\tstrcpy(key + len, options);\n\t\t\toptions = strchr(options, ',');\n\t\t\tif (options)\n\t\t\t\t*options++ = 0;\n\t\t}\n\n\n\t\tlen = 0;\n\t\tvalue = strchr(key, '=');\n\t\tif (value) {\n\t\t\tif (value == key)\n\t\t\t\tcontinue;\n\t\t\t*value++ = 0;\n\t\t\tlen = strlen(value);\n\t\t}\n\n\t\tret = vfs_parse_fs_string(fc, key, value, len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int smb3_fs_context_validate(struct fs_context *fc)\n{\n\tstruct smb3_fs_context *ctx = smb3_fc2context(fc);\n\n\tif (ctx->rdma && ctx->vals->protocol_id < SMB30_PROT_ID) {\n\t\tcifs_errorf(fc, \"SMB Direct requires Version >=3.0\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n#ifndef CONFIG_KEYS\n\t \n\tif (ctx->multiuser) {\n\t\tcifs_errorf(fc, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\treturn -1;\n\t}\n#endif\n\n\tif (ctx->got_version == false)\n\t\tpr_warn_once(\"No dialect specified on mount. Default has changed to a more secure dialect, SMB2.1 or later (e.g. SMB3.1.1), from CIFS (SMB1). To use the less secure SMB1 dialect to access old servers which do not support SMB3.1.1 (or even SMB3 or SMB2.1) specify vers=1.0 on mount.\\n\");\n\n\n\tif (!ctx->UNC) {\n\t\tcifs_errorf(fc, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (strlen(ctx->UNC) < 3 || !strchr(ctx->UNC + 3, '\\\\')) {\n\t\tcifs_errorf(fc, \"Malformed UNC. Unable to find share name.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!ctx->got_ip) {\n\t\tint len;\n\t\tconst char *slash;\n\n\t\t \n\t\t \n\t\tslash = strchr(&ctx->UNC[2], '\\\\');\n\t\tlen = slash - &ctx->UNC[2];\n\t\tif (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,\n\t\t\t\t\t  &ctx->UNC[2], len)) {\n\t\t\tpr_err(\"Unable to determine destination address\\n\");\n\t\t\treturn -EHOSTUNREACH;\n\t\t}\n\t}\n\n\t \n\tcifs_set_port((struct sockaddr *)&ctx->dstaddr, ctx->port);\n\n\tif (ctx->override_uid && !ctx->uid_specified) {\n\t\tctx->override_uid = 0;\n\t\tpr_notice(\"ignoring forceuid mount option specified with no uid= option\\n\");\n\t}\n\n\tif (ctx->override_gid && !ctx->gid_specified) {\n\t\tctx->override_gid = 0;\n\t\tpr_notice(\"ignoring forcegid mount option specified with no gid= option\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int smb3_get_tree_common(struct fs_context *fc)\n{\n\tstruct smb3_fs_context *ctx = smb3_fc2context(fc);\n\tstruct dentry *root;\n\tint rc = 0;\n\n\troot = cifs_smb3_do_mount(fc->fs_type, 0, ctx);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tfc->root = root;\n\n\treturn rc;\n}\n\n \nstatic int smb3_get_tree(struct fs_context *fc)\n{\n\tint err = smb3_fs_context_validate(fc);\n\tint ret;\n\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&cifs_mount_mutex);\n\tret = smb3_get_tree_common(fc);\n\tmutex_unlock(&cifs_mount_mutex);\n\treturn ret;\n}\n\nstatic void smb3_fs_context_free(struct fs_context *fc)\n{\n\tstruct smb3_fs_context *ctx = smb3_fc2context(fc);\n\n\tsmb3_cleanup_fs_context(ctx);\n}\n\n \nstatic int smb3_verify_reconfigure_ctx(struct fs_context *fc,\n\t\t\t\t       struct smb3_fs_context *new_ctx,\n\t\t\t\t       struct smb3_fs_context *old_ctx)\n{\n\tif (new_ctx->posix_paths != old_ctx->posix_paths) {\n\t\tcifs_errorf(fc, \"can not change posixpaths during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->sectype != old_ctx->sectype) {\n\t\tcifs_errorf(fc, \"can not change sec during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->multiuser != old_ctx->multiuser) {\n\t\tcifs_errorf(fc, \"can not change multiuser during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->UNC &&\n\t    (!old_ctx->UNC || strcmp(new_ctx->UNC, old_ctx->UNC))) {\n\t\tcifs_errorf(fc, \"can not change UNC during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->username &&\n\t    (!old_ctx->username || strcmp(new_ctx->username, old_ctx->username))) {\n\t\tcifs_errorf(fc, \"can not change username during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->password &&\n\t    (!old_ctx->password || strcmp(new_ctx->password, old_ctx->password))) {\n\t\tcifs_errorf(fc, \"can not change password during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->domainname &&\n\t    (!old_ctx->domainname || strcmp(new_ctx->domainname, old_ctx->domainname))) {\n\t\tcifs_errorf(fc, \"can not change domainname during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(new_ctx->workstation_name, old_ctx->workstation_name)) {\n\t\tcifs_errorf(fc, \"can not change workstation_name during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->nodename &&\n\t    (!old_ctx->nodename || strcmp(new_ctx->nodename, old_ctx->nodename))) {\n\t\tcifs_errorf(fc, \"can not change nodename during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (new_ctx->iocharset &&\n\t    (!old_ctx->iocharset || strcmp(new_ctx->iocharset, old_ctx->iocharset))) {\n\t\tcifs_errorf(fc, \"can not change iocharset during remount\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define STEAL_STRING(cifs_sb, ctx, field)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tkfree(ctx->field);\t\t\t\t\t\t\\\n\tctx->field = cifs_sb->ctx->field;\t\t\t\t\\\n\tcifs_sb->ctx->field = NULL;\t\t\t\t\t\\\n} while (0)\n\n#define STEAL_STRING_SENSITIVE(cifs_sb, ctx, field)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tkfree_sensitive(ctx->field);\t\t\t\t\t\\\n\tctx->field = cifs_sb->ctx->field;\t\t\t\t\\\n\tcifs_sb->ctx->field = NULL;\t\t\t\t\t\\\n} while (0)\n\nstatic int smb3_reconfigure(struct fs_context *fc)\n{\n\tstruct smb3_fs_context *ctx = smb3_fc2context(fc);\n\tstruct dentry *root = fc->root;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\n\tint rc;\n\n\trc = smb3_verify_reconfigure_ctx(fc, ctx, cifs_sb->ctx);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tSTEAL_STRING(cifs_sb, ctx, UNC);\n\tSTEAL_STRING(cifs_sb, ctx, source);\n\tSTEAL_STRING(cifs_sb, ctx, username);\n\tSTEAL_STRING_SENSITIVE(cifs_sb, ctx, password);\n\tSTEAL_STRING(cifs_sb, ctx, domainname);\n\tSTEAL_STRING(cifs_sb, ctx, nodename);\n\tSTEAL_STRING(cifs_sb, ctx, iocharset);\n\n\t \n\tif (ctx->rsize == 0)\n\t\tctx->rsize = cifs_sb->ctx->rsize;\n\tif (ctx->wsize == 0)\n\t\tctx->wsize = cifs_sb->ctx->wsize;\n\n\n\tsmb3_cleanup_fs_context_contents(cifs_sb->ctx);\n\trc = smb3_fs_context_dup(cifs_sb->ctx, ctx);\n\tsmb3_update_mnt_flags(cifs_sb);\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tif (!rc)\n\t\trc = dfs_cache_remount_fs(cifs_sb);\n#endif\n\n\treturn rc;\n}\n\nstatic int smb3_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t      struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tstruct smb3_fs_context *ctx = smb3_fc2context(fc);\n\tint i, opt;\n\tbool is_smb3 = !strcmp(fc->fs_type->name, \"smb3\");\n\tbool skip_parsing = false;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tcifs_dbg(FYI, \"CIFS: parsing cifs mount option '%s'\\n\", param->key);\n\n\t \n\tif (param->type == fs_value_is_string && param->string[0] == 0) {\n\t\tif (!strcmp(\"pass\", param->key) || !strcmp(\"password\", param->key)) {\n\t\t\tskip_parsing = true;\n\t\t\topt = Opt_pass;\n\t\t} else if (!strcmp(\"user\", param->key) || !strcmp(\"username\", param->key)) {\n\t\t\tskip_parsing = true;\n\t\t\topt = Opt_user;\n\t\t}\n\t}\n\n\tif (!skip_parsing) {\n\t\topt = fs_parse(fc, smb3_fs_parameters, param, &result);\n\t\tif (opt < 0)\n\t\t\treturn ctx->sloppy ? 1 : opt;\n\t}\n\n\tswitch (opt) {\n\tcase Opt_compress:\n\t\tctx->compression = UNKNOWN_TYPE;\n\t\tcifs_dbg(VFS,\n\t\t\t\"SMB3 compression support is experimental\\n\");\n\t\tbreak;\n\tcase Opt_nodfs:\n\t\tctx->nodfs = 1;\n\t\tbreak;\n\tcase Opt_hard:\n\t\tif (result.negated) {\n\t\t\tif (ctx->retry == 1)\n\t\t\t\tcifs_dbg(VFS, \"conflicting hard vs. soft mount options\\n\");\n\t\t\tctx->retry = 0;\n\t\t} else\n\t\t\tctx->retry = 1;\n\t\tbreak;\n\tcase Opt_soft:\n\t\tif (result.negated)\n\t\t\tctx->retry = 1;\n\t\telse {\n\t\t\tif (ctx->retry == 1)\n\t\t\t\tcifs_dbg(VFS, \"conflicting hard vs soft mount options\\n\");\n\t\t\tctx->retry = 0;\n\t\t}\n\t\tbreak;\n\tcase Opt_mapposix:\n\t\tif (result.negated)\n\t\t\tctx->remap = false;\n\t\telse {\n\t\t\tctx->remap = true;\n\t\t\tctx->sfu_remap = false;  \n\t\t}\n\t\tbreak;\n\tcase Opt_mapchars:\n\t\tif (result.negated)\n\t\t\tctx->sfu_remap = false;\n\t\telse {\n\t\t\tctx->sfu_remap = true;\n\t\t\tctx->remap = false;  \n\t\t}\n\t\tbreak;\n\tcase Opt_user_xattr:\n\t\tif (result.negated)\n\t\t\tctx->no_xattr = 1;\n\t\telse\n\t\t\tctx->no_xattr = 0;\n\t\tbreak;\n\tcase Opt_forceuid:\n\t\tif (result.negated)\n\t\t\tctx->override_uid = 0;\n\t\telse\n\t\t\tctx->override_uid = 1;\n\t\tbreak;\n\tcase Opt_forcegid:\n\t\tif (result.negated)\n\t\t\tctx->override_gid = 0;\n\t\telse\n\t\t\tctx->override_gid = 1;\n\t\tbreak;\n\tcase Opt_perm:\n\t\tif (result.negated)\n\t\t\tctx->noperm = 1;\n\t\telse\n\t\t\tctx->noperm = 0;\n\t\tbreak;\n\tcase Opt_dynperm:\n\t\tif (result.negated)\n\t\t\tctx->dynperm = 0;\n\t\telse\n\t\t\tctx->dynperm = 1;\n\t\tbreak;\n\tcase Opt_sfu:\n\t\tif (result.negated)\n\t\t\tctx->sfu_emul = 0;\n\t\telse\n\t\t\tctx->sfu_emul = 1;\n\t\tbreak;\n\tcase Opt_noblocksend:\n\t\tctx->noblocksnd = 1;\n\t\tbreak;\n\tcase Opt_noautotune:\n\t\tctx->noautotune = 1;\n\t\tbreak;\n\tcase Opt_nolease:\n\t\tctx->no_lease = 1;\n\t\tbreak;\n\tcase Opt_nosparse:\n\t\tctx->no_sparse = 1;\n\t\tbreak;\n\tcase Opt_nodelete:\n\t\tctx->nodelete = 1;\n\t\tbreak;\n\tcase Opt_multichannel:\n\t\tif (result.negated) {\n\t\t\tctx->multichannel = false;\n\t\t\tctx->max_channels = 1;\n\t\t} else {\n\t\t\tctx->multichannel = true;\n\t\t\t \n\t\t\tif (ctx->max_channels < 2)\n\t\t\t\tctx->max_channels = 2;\n\t\t}\n\t\tbreak;\n\tcase Opt_uid:\n\t\tuid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(uid))\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->linux_uid = uid;\n\t\tctx->uid_specified = true;\n\t\tbreak;\n\tcase Opt_cruid:\n\t\tuid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(uid))\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->cred_uid = uid;\n\t\tctx->cruid_specified = true;\n\t\tbreak;\n\tcase Opt_backupuid:\n\t\tuid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(uid))\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->backupuid = uid;\n\t\tctx->backupuid_specified = true;\n\t\tbreak;\n\tcase Opt_backupgid:\n\t\tgid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(gid))\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->backupgid = gid;\n\t\tctx->backupgid_specified = true;\n\t\tbreak;\n\tcase Opt_gid:\n\t\tgid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(gid))\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->linux_gid = gid;\n\t\tctx->gid_specified = true;\n\t\tbreak;\n\tcase Opt_port:\n\t\tctx->port = result.uint_32;\n\t\tbreak;\n\tcase Opt_file_mode:\n\t\tctx->file_mode = result.uint_32;\n\t\tbreak;\n\tcase Opt_dirmode:\n\t\tctx->dir_mode = result.uint_32;\n\t\tbreak;\n\tcase Opt_min_enc_offload:\n\t\tctx->min_offload = result.uint_32;\n\t\tbreak;\n\tcase Opt_blocksize:\n\t\t \n\t\tif ((result.uint_32 < CIFS_MAX_MSGSIZE) ||\n\t\t   (result.uint_32 > (4 * SMB3_DEFAULT_IOSIZE))) {\n\t\t\tcifs_errorf(fc, \"%s: Invalid blocksize\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->bsize = result.uint_32;\n\t\tctx->got_bsize = true;\n\t\tbreak;\n\tcase Opt_rasize:\n\t\t \n\t\tif ((result.uint_32 > (8 * SMB3_DEFAULT_IOSIZE)) ||\n\t\t    (result.uint_32 < CIFS_DEFAULT_IOSIZE)) {\n\t\t\tcifs_errorf(fc, \"%s: Invalid rasize %d vs. %d\\n\",\n\t\t\t\t__func__, result.uint_32, SMB3_DEFAULT_IOSIZE);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->rasize = result.uint_32;\n\t\tbreak;\n\tcase Opt_rsize:\n\t\tctx->rsize = result.uint_32;\n\t\tctx->got_rsize = true;\n\t\tbreak;\n\tcase Opt_wsize:\n\t\tctx->wsize = result.uint_32;\n\t\tctx->got_wsize = true;\n\t\tbreak;\n\tcase Opt_acregmax:\n\t\tctx->acregmax = HZ * result.uint_32;\n\t\tif (ctx->acregmax > CIFS_MAX_ACTIMEO) {\n\t\t\tcifs_errorf(fc, \"acregmax too large\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_acdirmax:\n\t\tctx->acdirmax = HZ * result.uint_32;\n\t\tif (ctx->acdirmax > CIFS_MAX_ACTIMEO) {\n\t\t\tcifs_errorf(fc, \"acdirmax too large\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_actimeo:\n\t\tif (HZ * result.uint_32 > CIFS_MAX_ACTIMEO) {\n\t\t\tcifs_errorf(fc, \"timeout too large\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tif ((ctx->acdirmax != CIFS_DEF_ACTIMEO) ||\n\t\t    (ctx->acregmax != CIFS_DEF_ACTIMEO)) {\n\t\t\tcifs_errorf(fc, \"actimeo ignored since acregmax or acdirmax specified\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tctx->acdirmax = ctx->acregmax = HZ * result.uint_32;\n\t\tbreak;\n\tcase Opt_closetimeo:\n\t\tctx->closetimeo = HZ * result.uint_32;\n\t\tif (ctx->closetimeo > SMB3_MAX_DCLOSETIMEO) {\n\t\t\tcifs_errorf(fc, \"closetimeo too large\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_echo_interval:\n\t\tctx->echo_interval = result.uint_32;\n\t\tbreak;\n\tcase Opt_snapshot:\n\t\tctx->snapshot_time = result.uint_64;\n\t\tbreak;\n\tcase Opt_max_credits:\n\t\tif (result.uint_32 < 20 || result.uint_32 > 60000) {\n\t\t\tcifs_errorf(fc, \"%s: Invalid max_credits value\\n\",\n\t\t\t\t __func__);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->max_credits = result.uint_32;\n\t\tbreak;\n\tcase Opt_max_channels:\n\t\tif (result.uint_32 < 1 || result.uint_32 > CIFS_MAX_CHANNELS) {\n\t\t\tcifs_errorf(fc, \"%s: Invalid max_channels value, needs to be 1-%d\\n\",\n\t\t\t\t __func__, CIFS_MAX_CHANNELS);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->max_channels = result.uint_32;\n\t\t \n\t\tif (result.uint_32 > 1)\n\t\t\tctx->multichannel = true;\n\t\tbreak;\n\tcase Opt_max_cached_dirs:\n\t\tif (result.uint_32 < 1) {\n\t\t\tcifs_errorf(fc, \"%s: Invalid max_cached_dirs, needs to be 1 or more\\n\",\n\t\t\t\t    __func__);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->max_cached_dirs = result.uint_32;\n\t\tbreak;\n\tcase Opt_handletimeout:\n\t\tctx->handle_timeout = result.uint_32;\n\t\tif (ctx->handle_timeout > SMB3_MAX_HANDLE_TIMEOUT) {\n\t\t\tcifs_errorf(fc, \"Invalid handle cache timeout, longer than 16 minutes\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_source:\n\t\tkfree(ctx->UNC);\n\t\tctx->UNC = NULL;\n\t\tswitch (smb3_parse_devname(param->string, ctx)) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\t\tcifs_errorf(fc, \"Unable to allocate memory for devname\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase -EINVAL:\n\t\t\tcifs_errorf(fc, \"Malformed UNC in devname\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tdefault:\n\t\t\tcifs_errorf(fc, \"Unknown error parsing devname\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->source = smb3_fs_context_fullpath(ctx, '/');\n\t\tif (IS_ERR(ctx->source)) {\n\t\t\tctx->source = NULL;\n\t\t\tcifs_errorf(fc, \"OOM when copying UNC string\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tfc->source = kstrdup(ctx->source, GFP_KERNEL);\n\t\tif (fc->source == NULL) {\n\t\t\tcifs_errorf(fc, \"OOM when copying UNC string\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_user:\n\t\tkfree(ctx->username);\n\t\tctx->username = NULL;\n\t\tif (ctx->nullauth)\n\t\t\tbreak;\n\t\tif (strlen(param->string) == 0) {\n\t\t\t \n\t\t\tctx->nullauth = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strnlen(param->string, CIFS_MAX_USERNAME_LEN) >\n\t\t    CIFS_MAX_USERNAME_LEN) {\n\t\t\tpr_warn(\"username too long\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->username = kstrdup(param->string, GFP_KERNEL);\n\t\tif (ctx->username == NULL) {\n\t\t\tcifs_errorf(fc, \"OOM when copying username string\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_pass:\n\t\tkfree_sensitive(ctx->password);\n\t\tctx->password = NULL;\n\t\tif (strlen(param->string) == 0)\n\t\t\tbreak;\n\n\t\tctx->password = kstrdup(param->string, GFP_KERNEL);\n\t\tif (ctx->password == NULL) {\n\t\t\tcifs_errorf(fc, \"OOM when copying password string\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_ip:\n\t\tif (strlen(param->string) == 0) {\n\t\t\tctx->got_ip = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,\n\t\t\t\t\t  param->string,\n\t\t\t\t\t  strlen(param->string))) {\n\t\t\tpr_err(\"bad ip= option (%s)\\n\", param->string);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tctx->got_ip = true;\n\t\tbreak;\n\tcase Opt_domain:\n\t\tif (strnlen(param->string, CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\t== CIFS_MAX_DOMAINNAME_LEN) {\n\t\t\tpr_warn(\"domain name too long\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\n\t\tkfree(ctx->domainname);\n\t\tctx->domainname = kstrdup(param->string, GFP_KERNEL);\n\t\tif (ctx->domainname == NULL) {\n\t\t\tcifs_errorf(fc, \"OOM when copying domainname string\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\tbreak;\n\tcase Opt_srcaddr:\n\t\tif (!cifs_convert_address(\n\t\t\t\t(struct sockaddr *)&ctx->srcaddr,\n\t\t\t\tparam->string, strlen(param->string))) {\n\t\t\tpr_warn(\"Could not parse srcaddr: %s\\n\",\n\t\t\t\tparam->string);\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t\tbreak;\n\tcase Opt_iocharset:\n\t\tif (strnlen(param->string, 1024) >= 65) {\n\t\t\tpr_warn(\"iocharset name too long\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\n\t\tif (strncasecmp(param->string, \"default\", 7) != 0) {\n\t\t\tkfree(ctx->iocharset);\n\t\t\tctx->iocharset = kstrdup(param->string, GFP_KERNEL);\n\t\t\tif (ctx->iocharset == NULL) {\n\t\t\t\tcifs_errorf(fc, \"OOM when copying iocharset string\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t}\n\t\t \n\t\tcifs_dbg(FYI, \"iocharset set to %s\\n\", ctx->iocharset);\n\t\tbreak;\n\tcase Opt_netbiosname:\n\t\tmemset(ctx->source_rfc1001_name, 0x20,\n\t\t\tRFC1001_NAME_LEN);\n\t\t \n\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t \n\t\t\tif (param->string[i] == 0)\n\t\t\t\tbreak;\n\t\t\tctx->source_rfc1001_name[i] = param->string[i];\n\t\t}\n\t\t \n\t\tif (i == RFC1001_NAME_LEN && param->string[i] != 0)\n\t\t\tpr_warn(\"netbiosname longer than 15 truncated\\n\");\n\t\tbreak;\n\tcase Opt_servern:\n\t\t \n\t\tmemset(ctx->target_rfc1001_name, 0x20,\n\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\t\t \n\n\t\t \n\t\tfor (i = 0; i < 15; i++) {\n\t\t\tif (param->string[i] == 0)\n\t\t\t\tbreak;\n\t\t\tctx->target_rfc1001_name[i] = param->string[i];\n\t\t}\n\n\t\t \n\t\tif (i == RFC1001_NAME_LEN && param->string[i] != 0)\n\t\t\tpr_warn(\"server netbiosname longer than 15 truncated\\n\");\n\t\tbreak;\n\tcase Opt_ver:\n\t\t \n\t\t \n\t\tif (strncasecmp(param->string, \"1\", 1) == 0) {\n\t\t\tif (strlen(param->string) > 1) {\n\t\t\t\tpr_warn(\"Bad mount helper ver=%s. Did you want SMB1 (CIFS) dialect and mean to type vers=1.0 instead?\\n\",\n\t\t\t\t\tparam->string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tpr_warn(\"Invalid mount helper version specified\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase Opt_vers:\n\t\t \n\t\tif (cifs_parse_smb_version(fc, param->string, ctx, is_smb3) != 0)\n\t\t\tgoto cifs_parse_mount_err;\n\t\tctx->got_version = true;\n\t\tbreak;\n\tcase Opt_sec:\n\t\tif (cifs_parse_security_flavors(fc, param->string, ctx) != 0)\n\t\t\tgoto cifs_parse_mount_err;\n\t\tbreak;\n\tcase Opt_cache:\n\t\tif (cifs_parse_cache_flavor(fc, param->string, ctx) != 0)\n\t\t\tgoto cifs_parse_mount_err;\n\t\tbreak;\n\tcase Opt_witness:\n#ifndef CONFIG_CIFS_SWN_UPCALL\n\t\tcifs_errorf(fc, \"Witness support needs CONFIG_CIFS_SWN_UPCALL config option\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\tctx->witness = true;\n\t\tpr_warn_once(\"Witness protocol support is experimental\\n\");\n\t\tbreak;\n\tcase Opt_rootfs:\n#ifndef CONFIG_CIFS_ROOT\n\t\tcifs_dbg(VFS, \"rootfs support requires CONFIG_CIFS_ROOT config option\\n\");\n\t\tgoto cifs_parse_mount_err;\n#endif\n\t\tctx->rootfs = true;\n\t\tbreak;\n\tcase Opt_posixpaths:\n\t\tif (result.negated)\n\t\t\tctx->posix_paths = 0;\n\t\telse\n\t\t\tctx->posix_paths = 1;\n\t\tbreak;\n\tcase Opt_unix:\n\t\tif (result.negated) {\n\t\t\tif (ctx->linux_ext == 1)\n\t\t\t\tpr_warn_once(\"conflicting posix mount options specified\\n\");\n\t\t\tctx->linux_ext = 0;\n\t\t\tctx->no_linux_ext = 1;\n\t\t} else {\n\t\t\tif (ctx->no_linux_ext == 1)\n\t\t\t\tpr_warn_once(\"conflicting posix mount options specified\\n\");\n\t\t\tctx->linux_ext = 1;\n\t\t\tctx->no_linux_ext = 0;\n\t\t}\n\t\tbreak;\n\tcase Opt_nocase:\n\t\tctx->nocase = 1;\n\t\tbreak;\n\tcase Opt_brl:\n\t\tif (result.negated) {\n\t\t\t \n\t\t\tif (ctx->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tctx->file_mode = S_IALLUGO;\n\t\t\tctx->nobrl =  1;\n\t\t} else\n\t\t\tctx->nobrl =  0;\n\t\tbreak;\n\tcase Opt_handlecache:\n\t\tif (result.negated)\n\t\t\tctx->nohandlecache = 1;\n\t\telse\n\t\t\tctx->nohandlecache = 0;\n\t\tbreak;\n\tcase Opt_forcemandatorylock:\n\t\tctx->mand_lock = 1;\n\t\tbreak;\n\tcase Opt_setuids:\n\t\tctx->setuids = result.negated;\n\t\tbreak;\n\tcase Opt_intr:\n\t\tctx->intr = !result.negated;\n\t\tbreak;\n\tcase Opt_setuidfromacl:\n\t\tctx->setuidfromacl = 1;\n\t\tbreak;\n\tcase Opt_strictsync:\n\t\tctx->nostrictsync = result.negated;\n\t\tbreak;\n\tcase Opt_serverino:\n\t\tctx->server_ino = !result.negated;\n\t\tbreak;\n\tcase Opt_rwpidforward:\n\t\tctx->rwpidforward = 1;\n\t\tbreak;\n\tcase Opt_modesid:\n\t\tctx->mode_ace = 1;\n\t\tbreak;\n\tcase Opt_cifsacl:\n\t\tctx->cifs_acl = !result.negated;\n\t\tbreak;\n\tcase Opt_acl:\n\t\tctx->no_psx_acl = result.negated;\n\t\tbreak;\n\tcase Opt_locallease:\n\t\tctx->local_lease = 1;\n\t\tbreak;\n\tcase Opt_sign:\n\t\tctx->sign = true;\n\t\tbreak;\n\tcase Opt_ignore_signature:\n\t\tctx->sign = true;\n\t\tctx->ignore_signature = true;\n\t\tbreak;\n\tcase Opt_seal:\n\t\t \n\t\tctx->seal = 1;\n\t\tbreak;\n\tcase Opt_noac:\n\t\tpr_warn(\"Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\tbreak;\n\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\tcifs_errorf(fc, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\tgoto cifs_parse_mount_err;\n#endif\n\t\tctx->fsc = true;\n\t\tbreak;\n\tcase Opt_mfsymlinks:\n\t\tctx->mfsymlinks = true;\n\t\tbreak;\n\tcase Opt_multiuser:\n\t\tctx->multiuser = true;\n\t\tbreak;\n\tcase Opt_sloppy:\n\t\tctx->sloppy = true;\n\t\tbreak;\n\tcase Opt_nosharesock:\n\t\tctx->nosharesock = true;\n\t\tbreak;\n\tcase Opt_persistent:\n\t\tif (result.negated) {\n\t\t\tctx->nopersistent = true;\n\t\t\tif (ctx->persistent) {\n\t\t\t\tcifs_errorf(fc, \"persistenthandles mount options conflict\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->persistent = true;\n\t\t\tif ((ctx->nopersistent) || (ctx->resilient)) {\n\t\t\t\tcifs_errorf(fc, \"persistenthandles mount options conflict\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase Opt_resilient:\n\t\tif (result.negated) {\n\t\t\tctx->resilient = false;  \n\t\t} else {\n\t\t\tctx->resilient = true;\n\t\t\tif (ctx->persistent) {\n\t\t\t\tcifs_errorf(fc, \"persistenthandles mount options conflict\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase Opt_tcp_nodelay:\n\t\t \n\t\tif (result.negated)\n\t\t\tctx->sockopt_tcp_nodelay = false;\n\t\telse\n\t\t\tctx->sockopt_tcp_nodelay = true;\n\t\tbreak;\n\tcase Opt_domainauto:\n\t\tctx->domainauto = true;\n\t\tbreak;\n\tcase Opt_rdma:\n\t\tctx->rdma = true;\n\t\tbreak;\n\t}\n\t \n\n\treturn 0;\n\n cifs_parse_mount_err:\n\tkfree_sensitive(ctx->password);\n\tctx->password = NULL;\n\treturn -EINVAL;\n}\n\nint smb3_init_fs_context(struct fs_context *fc)\n{\n\tstruct smb3_fs_context *ctx;\n\tchar *nodename = utsname()->nodename;\n\tint i;\n\n\tctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);\n\tif (unlikely(!ctx))\n\t\treturn -ENOMEM;\n\n\tstrscpy(ctx->workstation_name, nodename, sizeof(ctx->workstation_name));\n\n\t \n\tmemset(ctx->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tctx->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tctx->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t \n\tctx->target_rfc1001_name[0] = 0;\n\tctx->cred_uid = current_uid();\n\tctx->linux_uid = current_uid();\n\tctx->linux_gid = current_gid();\n\t \n\tctx->bsize = CIFS_DEFAULT_IOSIZE;  \n\tctx->rasize = 0;  \n\n\t \n\tctx->remap = true;\n\n\t \n\tctx->dir_mode = ctx->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t \n\t \n\tctx->posix_paths = 1;\n\t \n\tctx->server_ino = 1;\n\n\t \n\tctx->strict_io = true;\n\n\tctx->acregmax = CIFS_DEF_ACTIMEO;\n\tctx->acdirmax = CIFS_DEF_ACTIMEO;\n\tctx->closetimeo = SMB3_DEF_DCLOSETIMEO;\n\tctx->max_cached_dirs = MAX_CACHED_FIDS;\n\t \n\tctx->handle_timeout = 0;  \n\n\t \n\tctx->ops = &smb30_operations;\n\tctx->vals = &smbdefault_values;\n\n\tctx->echo_interval = SMB_ECHO_INTERVAL_DEFAULT;\n\n\t \n\tctx->multichannel = false;\n\tctx->max_channels = 1;\n\n\tctx->backupuid_specified = false;  \n\tctx->backupgid_specified = false;  \n\n \n\n\tfc->fs_private = ctx;\n\tfc->ops = &smb3_fs_context_ops;\n\treturn 0;\n}\n\nvoid\nsmb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\n\t \n\tkfree(ctx->username);\n\tctx->username = NULL;\n\tkfree_sensitive(ctx->password);\n\tctx->password = NULL;\n\tkfree(ctx->server_hostname);\n\tctx->server_hostname = NULL;\n\tkfree(ctx->UNC);\n\tctx->UNC = NULL;\n\tkfree(ctx->source);\n\tctx->source = NULL;\n\tkfree(ctx->domainname);\n\tctx->domainname = NULL;\n\tkfree(ctx->nodename);\n\tctx->nodename = NULL;\n\tkfree(ctx->iocharset);\n\tctx->iocharset = NULL;\n\tkfree(ctx->prepath);\n\tctx->prepath = NULL;\n\tkfree(ctx->leaf_fullpath);\n\tctx->leaf_fullpath = NULL;\n}\n\nvoid\nsmb3_cleanup_fs_context(struct smb3_fs_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\tsmb3_cleanup_fs_context_contents(ctx);\n\tkfree(ctx);\n}\n\nvoid smb3_update_mnt_flags(struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb3_fs_context *ctx = cifs_sb->ctx;\n\n\tif (ctx->nodfs)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_DFS;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NO_DFS;\n\n\tif (ctx->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NO_PERM;\n\n\tif (ctx->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SET_UID;\n\n\tif (ctx->setuidfromacl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UID_FROM_ACL;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_UID_FROM_ACL;\n\n\tif (ctx->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\n\tif (ctx->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_MAP_SFM_CHR;\n\n\tif (ctx->sfu_remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_MAP_SPECIAL_CHR;\n\n\tif (ctx->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NO_XATTR;\n\n\tif (ctx->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_UNX_EMUL;\n\n\tif (ctx->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NO_BRL;\n\n\tif (ctx->nohandlecache)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_HANDLE_CACHE;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NO_HANDLE_CACHE;\n\n\tif (ctx->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NOSSYNC;\n\n\tif (ctx->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_NOPOSIXBRL;\n\n\tif (ctx->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_RWPIDFORWARD;\n\n\tif (ctx->mode_ace)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MODE_FROM_SID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_MODE_FROM_SID;\n\n\tif (ctx->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_CIFS_ACL;\n\n\tif (ctx->backupuid_specified)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_CIFS_BACKUPUID;\n\n\tif (ctx->backupgid_specified)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_CIFS_BACKUPGID;\n\n\tif (ctx->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_OVERR_UID;\n\n\tif (ctx->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_OVERR_GID;\n\n\tif (ctx->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_DYNPERM;\n\n\tif (ctx->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_FSCACHE;\n\n\tif (ctx->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_MULTIUSER;\n\n\n\tif (ctx->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_STRICT_IO;\n\n\tif (ctx->direct_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_DIRECT_IO;\n\n\tif (ctx->mfsymlinks)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\telse\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_MF_SYMLINKS;\n\tif (ctx->mfsymlinks) {\n\t\tif (ctx->sfu_emul) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"mount options mfsymlinks and sfu both enabled\\n\");\n\t\t}\n\t}\n\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SHUTDOWN;\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}