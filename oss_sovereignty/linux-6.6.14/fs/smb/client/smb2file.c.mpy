{
  "module_name": "smb2file.c",
  "hash_id": "b2fb715c5e3b9e46d3f65d22ea15a0ffabd858fbdb17db9c4b105d9ff06b4f61",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2file.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <asm/div64.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"fscache.h\"\n#include \"smb2proto.h\"\n#include \"smb2status.h\"\n\nstatic struct smb2_symlink_err_rsp *symlink_data(const struct kvec *iov)\n{\n\tstruct smb2_err_rsp *err = iov->iov_base;\n\tstruct smb2_symlink_err_rsp *sym = ERR_PTR(-EINVAL);\n\tu32 len;\n\n\tif (err->ErrorContextCount) {\n\t\tstruct smb2_error_context_rsp *p, *end;\n\n\t\tlen = (u32)err->ErrorContextCount * (offsetof(struct smb2_error_context_rsp,\n\t\t\t\t\t\t\t      ErrorContextData) +\n\t\t\t\t\t\t     sizeof(struct smb2_symlink_err_rsp));\n\t\tif (le32_to_cpu(err->ByteCount) < len || iov->iov_len < len + sizeof(*err) + 1)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tp = (struct smb2_error_context_rsp *)err->ErrorData;\n\t\tend = (struct smb2_error_context_rsp *)((u8 *)err + iov->iov_len);\n\t\tdo {\n\t\t\tif (le32_to_cpu(p->ErrorId) == SMB2_ERROR_ID_DEFAULT) {\n\t\t\t\tsym = (struct smb2_symlink_err_rsp *)&p->ErrorContextData;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"%s: skipping unhandled error context: 0x%x\\n\",\n\t\t\t\t __func__, le32_to_cpu(p->ErrorId));\n\n\t\t\tlen = ALIGN(le32_to_cpu(p->ErrorDataLength), 8);\n\t\t\tp = (struct smb2_error_context_rsp *)((u8 *)&p->ErrorContextData + len);\n\t\t} while (p < end);\n\t} else if (le32_to_cpu(err->ByteCount) >= sizeof(*sym) &&\n\t\t   iov->iov_len >= SMB2_SYMLINK_STRUCT_SIZE) {\n\t\tsym = (struct smb2_symlink_err_rsp *)err->ErrorData;\n\t}\n\n\tif (!IS_ERR(sym) && (le32_to_cpu(sym->SymLinkErrorTag) != SYMLINK_ERROR_TAG ||\n\t\t\t     le32_to_cpu(sym->ReparseTag) != IO_REPARSE_TAG_SYMLINK))\n\t\tsym = ERR_PTR(-EINVAL);\n\n\treturn sym;\n}\n\nint smb2_parse_symlink_response(struct cifs_sb_info *cifs_sb, const struct kvec *iov, char **path)\n{\n\tstruct smb2_symlink_err_rsp *sym;\n\tunsigned int sub_offs, sub_len;\n\tunsigned int print_offs, print_len;\n\tchar *s;\n\n\tif (!cifs_sb || !iov || !iov->iov_base || !iov->iov_len || !path)\n\t\treturn -EINVAL;\n\n\tsym = symlink_data(iov);\n\tif (IS_ERR(sym))\n\t\treturn PTR_ERR(sym);\n\n\tsub_len = le16_to_cpu(sym->SubstituteNameLength);\n\tsub_offs = le16_to_cpu(sym->SubstituteNameOffset);\n\tprint_len = le16_to_cpu(sym->PrintNameLength);\n\tprint_offs = le16_to_cpu(sym->PrintNameOffset);\n\n\tif (iov->iov_len < SMB2_SYMLINK_STRUCT_SIZE + sub_offs + sub_len ||\n\t    iov->iov_len < SMB2_SYMLINK_STRUCT_SIZE + print_offs + print_len)\n\t\treturn -EINVAL;\n\n\ts = cifs_strndup_from_utf16((char *)sym->PathBuffer + sub_offs, sub_len, true,\n\t\t\t\t    cifs_sb->local_nls);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tconvert_delimiter(s, '/');\n\tcifs_dbg(FYI, \"%s: symlink target: %s\\n\", __func__, s);\n\n\t*path = s;\n\treturn 0;\n}\n\nint smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms, __u32 *oplock, void *buf)\n{\n\tint rc;\n\t__le16 *smb2_path;\n\t__u8 smb2_oplock;\n\tstruct cifs_open_info_data *data = buf;\n\tstruct smb2_file_all_info file_info = {};\n\tstruct smb2_file_all_info *smb2_data = data ? &file_info : NULL;\n\tstruct kvec err_iov = {};\n\tint err_buftype = CIFS_NO_BUFFER;\n\tstruct cifs_fid *fid = oparms->fid;\n\tstruct network_resiliency_req nr_ioctl_req;\n\n\tsmb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);\n\tif (smb2_path == NULL)\n\t\treturn -ENOMEM;\n\n\toparms->desired_access |= FILE_READ_ATTRIBUTES;\n\tsmb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;\n\n\trc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data, NULL, &err_iov,\n\t\t       &err_buftype);\n\tif (rc && data) {\n\t\tstruct smb2_hdr *hdr = err_iov.iov_base;\n\n\t\tif (unlikely(!err_iov.iov_base || err_buftype == CIFS_NO_BUFFER))\n\t\t\tgoto out;\n\t\tif (hdr->Status == STATUS_STOPPED_ON_SYMLINK) {\n\t\t\trc = smb2_parse_symlink_response(oparms->cifs_sb, &err_iov,\n\t\t\t\t\t\t\t &data->symlink_target);\n\t\t\tif (!rc) {\n\t\t\t\tmemset(smb2_data, 0, sizeof(*smb2_data));\n\t\t\t\toparms->create_options |= OPEN_REPARSE_POINT;\n\t\t\t\trc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data,\n\t\t\t\t\t       NULL, NULL, NULL);\n\t\t\t\toparms->create_options &= ~OPEN_REPARSE_POINT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (oparms->tcon->use_resilient) {\n\t\t \n\t\tnr_ioctl_req.Timeout =\n\t\t\tcpu_to_le32(oparms->tcon->handle_timeout);\n\t\tnr_ioctl_req.Reserved = 0;\n\t\trc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,\n\t\t\tfid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,\n\t\t\t(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),\n\t\t\tCIFSMaxBufSize, NULL, NULL  );\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t     \"resiliency not supported by server, disabling\\n\");\n\t\t\toparms->tcon->use_resilient = false;\n\t\t} else if (rc)\n\t\t\tcifs_dbg(FYI, \"error %d setting resiliency\\n\", rc);\n\n\t\trc = 0;\n\t}\n\n\tif (smb2_data) {\n\t\t \n\t\tif (smb2_data->IndexNumber == 0) {\n\t\t\trc = SMB2_get_srv_num(xid, oparms->tcon,\n\t\t\t\t      fid->persistent_fid,\n\t\t\t\t      fid->volatile_fid,\n\t\t\t\t      &smb2_data->IndexNumber);\n\t\t\tif (rc) {\n\t\t\t\t \n\t\t\t\tsmb2_data->IndexNumber = 0;\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t}\n\t\tmemcpy(&data->fi, smb2_data, sizeof(data->fi));\n\t}\n\n\t*oplock = smb2_oplock;\nout:\n\tfree_rsp_buf(err_buftype, err_iov.iov_base);\n\tkfree(smb2_path);\n\treturn rc;\n}\n\nint\nsmb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  const unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int max_num, num = 0, max_buf;\n\tstruct smb2_lock_element *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t \n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (max_buf < sizeof(struct smb2_lock_element))\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(sizeof(struct smb2_lock_element) > PAGE_SIZE);\n\tmax_buf = min_t(unsigned int, max_buf, PAGE_SIZE);\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcur = buf;\n\n\tcifs_down_write(&cinode->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\tif (flock->fl_start > li->offset ||\n\t\t    (flock->fl_start + length) <\n\t\t    (li->offset + li->length))\n\t\t\tcontinue;\n\t\tif (current->tgid != li->pid)\n\t\t\t \n\t\t\tif (!(flock->fl_flags & (FL_FLOCK | FL_OFDLCK)))\n\t\t\t\tcontinue;\n\t\tif (cinode->can_cache_brlcks) {\n\t\t\t \n\t\t\tlist_del(&li->llist);\n\t\t\tcifs_del_lock_waiters(li);\n\t\t\tkfree(li);\n\t\t\tcontinue;\n\t\t}\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(SMB2_LOCKFLAG_UNLOCK);\n\t\t \n\t\tlist_move(&li->llist, &tmp_llist);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\t \n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid, current->tgid,\n\t\t\t\t       num, buf);\n\t\tif (stored_rc) {\n\t\t\tcifs_move_llist(&tmp_llist, &cfile->llist->locks);\n\t\t\trc = stored_rc;\n\t\t} else\n\t\t\tcifs_free_llist(&tmp_llist);\n\t}\n\tup_write(&cinode->lock_sem);\n\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic int\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\n\t\t       struct smb2_lock_element *buf, unsigned int max_num)\n{\n\tint rc = 0, stored_rc;\n\tstruct cifsFileInfo *cfile = fdlocks->cfile;\n\tstruct cifsLockInfo *li;\n\tunsigned int num = 0;\n\tstruct smb2_lock_element *cur = buf;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tcur->Length = cpu_to_le64(li->length);\n\t\tcur->Offset = cpu_to_le64(li->offset);\n\t\tcur->Flags = cpu_to_le32(li->type |\n\t\t\t\t\t\tSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\t\tif (++num == max_num) {\n\t\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t\t       current->tgid, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t\tcur = buf;\n\t\t\tnum = 0;\n\t\t} else\n\t\t\tcur++;\n\t}\n\tif (num) {\n\t\tstored_rc = smb2_lockv(xid, tcon,\n\t\t\t\t       cfile->fid.persistent_fid,\n\t\t\t\t       cfile->fid.volatile_fid,\n\t\t\t\t       current->tgid, num, buf);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\treturn rc;\n}\n\nint\nsmb2_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tint rc = 0, stored_rc;\n\tunsigned int xid;\n\tunsigned int max_num, max_buf;\n\tstruct smb2_lock_element *buf;\n\tstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\n\tstruct cifs_fid_locks *fdlocks;\n\n\txid = get_xid();\n\n\t \n\tmax_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;\n\tif (max_buf < sizeof(struct smb2_lock_element)) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(struct smb2_lock_element) > PAGE_SIZE);\n\tmax_buf = min_t(unsigned int, max_buf, PAGE_SIZE);\n\tmax_num = max_buf / sizeof(struct smb2_lock_element);\n\tbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tlist_for_each_entry(fdlocks, &cinode->llist, llist) {\n\t\tstored_rc = smb2_push_mand_fdlocks(fdlocks, xid, buf, max_num);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}