{
  "module_name": "ioctl.c",
  "hash_id": "683bb3fc5a7d9a34eb612105d77647c97515356a2c447b3e0e920da3dc9c5261",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsfs.h\"\n#include \"cifs_ioctl.h\"\n#include \"smb2proto.h\"\n#include \"smb2glob.h\"\n#include <linux/btrfs.h>\n\nstatic long cifs_ioctl_query_info(unsigned int xid, struct file *filep,\n\t\t\t\t  unsigned long p)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct dentry *dentry = filep->f_path.dentry;\n\tconst unsigned char *path;\n\tvoid *page = alloc_dentry_path();\n\t__le16 *utf16_path = NULL, root_path;\n\tint rc = 0;\n\n\tpath = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(path)) {\n\t\tfree_dentry_path(page);\n\t\treturn PTR_ERR(path);\n\t}\n\n\tcifs_dbg(FYI, \"%s %s\\n\", __func__, path);\n\n\tif (!path[0]) {\n\t\troot_path = 0;\n\t\tutf16_path = &root_path;\n\t} else {\n\t\tutf16_path = cifs_convert_path_to_utf16(path + 1, cifs_sb);\n\t\tif (!utf16_path) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto ici_exit;\n\t\t}\n\t}\n\n\tif (tcon->ses->server->ops->ioctl_query_info)\n\t\trc = tcon->ses->server->ops->ioctl_query_info(\n\t\t\t\txid, tcon, cifs_sb, utf16_path,\n\t\t\t\tfilep->private_data ? 0 : 1, p);\n\telse\n\t\trc = -EOPNOTSUPP;\n\n ici_exit:\n\tif (utf16_path != &root_path)\n\t\tkfree(utf16_path);\n\tfree_dentry_path(page);\n\treturn rc;\n}\n\nstatic long cifs_ioctl_copychunk(unsigned int xid, struct file *dst_file,\n\t\t\tunsigned long srcfd)\n{\n\tint rc;\n\tstruct fd src_file;\n\tstruct inode *src_inode;\n\n\tcifs_dbg(FYI, \"ioctl copychunk range\\n\");\n\t \n\tif (!(dst_file->f_mode & FMODE_WRITE)) {\n\t\tcifs_dbg(FYI, \"file target not open for write\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = mnt_want_write_file(dst_file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"mnt_want_write failed with rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\trc = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (src_file.file->f_op->unlocked_ioctl != cifs_ioctl) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"src file seems to be from a different filesystem type\\n\");\n\t\tgoto out_fput;\n\t}\n\n\tsrc_inode = file_inode(src_file.file);\n\trc = -EINVAL;\n\tif (S_ISDIR(src_inode->i_mode))\n\t\tgoto out_fput;\n\n\trc = cifs_file_copychunk_range(xid, src_file.file, 0, dst_file, 0,\n\t\t\t\t\tsrc_inode->i_size, 0);\n\tif (rc > 0)\n\t\trc = 0;\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\treturn rc;\n}\n\nstatic long smb_mnt_get_tcon_info(struct cifs_tcon *tcon, void __user *arg)\n{\n\tint rc = 0;\n\tstruct smb_mnt_tcon_info tcon_inf;\n\n\ttcon_inf.tid = tcon->tid;\n\ttcon_inf.session_id = tcon->ses->Suid;\n\n\tif (copy_to_user(arg, &tcon_inf, sizeof(struct smb_mnt_tcon_info)))\n\t\trc = -EFAULT;\n\n\treturn rc;\n}\n\nstatic long smb_mnt_get_fsinfo(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\tvoid __user *arg)\n{\n\tint rc = 0;\n\tstruct smb_mnt_fs_info *fsinf;\n\n\tfsinf = kzalloc(sizeof(struct smb_mnt_fs_info), GFP_KERNEL);\n\tif (fsinf == NULL)\n\t\treturn -ENOMEM;\n\n\tfsinf->version = 1;\n\tfsinf->protocol_id = tcon->ses->server->vals->protocol_id;\n\tfsinf->device_characteristics =\n\t\t\tle32_to_cpu(tcon->fsDevInfo.DeviceCharacteristics);\n\tfsinf->device_type = le32_to_cpu(tcon->fsDevInfo.DeviceType);\n\tfsinf->fs_attributes = le32_to_cpu(tcon->fsAttrInfo.Attributes);\n\tfsinf->max_path_component =\n\t\tle32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength);\n\tfsinf->vol_serial_number = tcon->vol_serial_number;\n\tfsinf->vol_create_time = le64_to_cpu(tcon->vol_create_time);\n\tfsinf->share_flags = tcon->share_flags;\n\tfsinf->share_caps = le32_to_cpu(tcon->capabilities);\n\tfsinf->sector_flags = tcon->ss_flags;\n\tfsinf->optimal_sector_size = tcon->perf_sector_size;\n\tfsinf->max_bytes_chunk = tcon->max_bytes_chunk;\n\tfsinf->maximal_access = tcon->maximal_access;\n\tfsinf->cifs_posix_caps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (copy_to_user(arg, fsinf, sizeof(struct smb_mnt_fs_info)))\n\t\trc = -EFAULT;\n\n\tkfree(fsinf);\n\treturn rc;\n}\n\nstatic int cifs_shutdown(struct super_block *sb, unsigned long arg)\n{\n\tstruct cifs_sb_info *sbi = CIFS_SB(sb);\n\t__u32 flags;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (get_user(flags, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (flags > CIFS_GOING_FLAGS_NOLOGFLUSH)\n\t\treturn -EINVAL;\n\n\tif (cifs_forced_shutdown(sbi))\n\t\treturn 0;\n\n\tcifs_dbg(VFS, \"shut down requested (%d)\", flags);\n \n\n\t \n\tswitch (flags) {\n\t \n\tcase CIFS_GOING_FLAGS_DEFAULT:\n\t\tcifs_dbg(FYI, \"shutdown with default flag not supported\\n\");\n\t\treturn -EINVAL;\n\t \n\tcase CIFS_GOING_FLAGS_LOGFLUSH:\n\tcase CIFS_GOING_FLAGS_NOLOGFLUSH:\n\t\tsbi->mnt_cifs_flags |= CIFS_MOUNT_SHUTDOWN;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cifs_dump_full_key(struct cifs_tcon *tcon, struct smb3_full_key_debug_info __user *in)\n{\n\tstruct smb3_full_key_debug_info out;\n\tstruct cifs_ses *ses;\n\tint rc = 0;\n\tbool found = false;\n\tu8 __user *end;\n\n\tif (!smb3_encryption_required(tcon)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (copy_from_user(&out, in, sizeof(out))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!out.session_id) {\n\t\t \n\t\tses = tcon->ses;\n\t} else {\n\t\t \n\t\tstruct cifs_ses *ses_it = NULL;\n\t\tstruct TCP_Server_Info *server_it = NULL;\n\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(server_it, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t\tlist_for_each_entry(ses_it, &server_it->smb_ses_list, smb_ses_list) {\n\t\t\t\tif (ses_it->Suid == out.session_id) {\n\t\t\t\t\tses = ses_it;\n\t\t\t\t\t \n\t\t\t\t\tcifs_smb_ses_inc_refcount(ses);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tgoto search_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nsearch_end:\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!found) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (ses->server->cipher_type) {\n\tcase SMB2_ENCRYPTION_AES128_CCM:\n\tcase SMB2_ENCRYPTION_AES128_GCM:\n\t\tout.session_key_length = CIFS_SESS_KEY_SIZE;\n\t\tout.server_in_key_length = out.server_out_key_length = SMB3_GCM128_CRYPTKEY_SIZE;\n\t\tbreak;\n\tcase SMB2_ENCRYPTION_AES256_CCM:\n\tcase SMB2_ENCRYPTION_AES256_GCM:\n\t\tout.session_key_length = CIFS_SESS_KEY_SIZE;\n\t\tout.server_in_key_length = out.server_out_key_length = SMB3_GCM256_CRYPTKEY_SIZE;\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (out.in_size < sizeof(out) + out.session_key_length + out.server_in_key_length\n\t    + out.server_out_key_length) {\n\t\trc = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tout.session_id = ses->Suid;\n\tout.cipher_type = le16_to_cpu(ses->server->cipher_type);\n\n\t \n\tif (copy_to_user(in, &out, sizeof(out))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tend = in->data;\n\tif (copy_to_user(end, ses->auth_key.response, out.session_key_length)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tend += out.session_key_length;\n\n\tif (copy_to_user(end, ses->smb3encryptionkey, out.server_in_key_length)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tend += out.server_in_key_length;\n\n\tif (copy_to_user(end, ses->smb3decryptionkey, out.server_out_key_length)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tif (found)\n\t\tcifs_put_smb_ses(ses);\n\treturn rc;\n}\n\nlong cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct smb3_key_debug_info pkey_inf;\n\tint rc = -ENOTTY;  \n\tunsigned int xid;\n\tstruct cifsFileInfo *pSMBFile = filep->private_data;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb;\n\t__u64\tExtAttrBits = 0;\n#ifdef CONFIG_CIFS_POSIX\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t__u64   caps;\n#endif  \n#endif  \n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"cifs ioctl 0x%x\\n\", command);\n\tswitch (command) {\n\t\tcase FS_IOC_GETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n#ifdef CONFIG_CIFS_POSIX\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t\t\tcaps = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\t\tif (CIFS_UNIX_EXTATTR_CAP & caps) {\n\t\t\t\t__u64\tExtAttrMask = 0;\n\t\t\t\trc = CIFSGetExtAttr(xid, tcon,\n\t\t\t\t\t\t    pSMBFile->fid.netfid,\n\t\t\t\t\t\t    &ExtAttrBits, &ExtAttrMask);\n\t\t\t\tif (rc == 0)\n\t\t\t\t\trc = put_user(ExtAttrBits &\n\t\t\t\t\t\tFS_FL_USER_VISIBLE,\n\t\t\t\t\t\t(int __user *)arg);\n\t\t\t\tif (rc != -EOPNOTSUPP)\n\t\t\t\t\tbreak;\n\t\t\t}\n#endif  \n#endif  \n\t\t\trc = 0;\n\t\t\tif (CIFS_I(inode)->cifsAttrs & ATTR_COMPRESSED) {\n\t\t\t\t \n\t\t\t\tExtAttrBits = FS_COMPR_FL;\n\t\t\t\trc = put_user(ExtAttrBits & FS_FL_USER_VISIBLE,\n\t\t\t\t\t      (int __user *)arg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FS_IOC_SETFLAGS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\t \n\n\t\t\tif (get_user(ExtAttrBits, (int __user *)arg)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tif ((ExtAttrBits & FS_COMPR_FL) == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (tcon->ses->server->ops->set_compression) {\n\t\t\t\trc = tcon->ses->server->ops->set_compression(\n\t\t\t\t\t\t\txid, tcon, pSMBFile);\n\t\t\t\tcifs_dbg(FYI, \"set compress flag rc %d\\n\", rc);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIFS_IOC_COPYCHUNK_FILE:\n\t\t\trc = cifs_ioctl_copychunk(xid, filep, arg);\n\t\t\tbreak;\n\t\tcase CIFS_QUERY_INFO:\n\t\t\trc = cifs_ioctl_query_info(xid, filep, arg);\n\t\t\tbreak;\n\t\tcase CIFS_IOC_SET_INTEGRITY:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tif (tcon->ses->server->ops->set_integrity)\n\t\t\t\trc = tcon->ses->server->ops->set_integrity(xid,\n\t\t\t\t\t\ttcon, pSMBFile);\n\t\t\telse\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase CIFS_IOC_GET_MNT_INFO:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\trc = smb_mnt_get_fsinfo(xid, tcon, (void __user *)arg);\n\t\t\tbreak;\n\t\tcase CIFS_IOC_GET_TCON_INFO:\n\t\t\tcifs_sb = CIFS_SB(inode->i_sb);\n\t\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\t\tif (IS_ERR(tlink)) {\n\t\t\t\trc = PTR_ERR(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttcon = tlink_tcon(tlink);\n\t\t\trc = smb_mnt_get_tcon_info(tcon, (void __user *)arg);\n\t\t\tcifs_put_tlink(tlink);\n\t\t\tbreak;\n\t\tcase CIFS_ENUMERATE_SNAPSHOTS:\n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\tif (arg == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto cifs_ioc_exit;\n\t\t\t}\n\t\t\ttcon = tlink_tcon(pSMBFile->tlink);\n\t\t\tif (tcon->ses->server->ops->enum_snapshots)\n\t\t\t\trc = tcon->ses->server->ops->enum_snapshots(xid, tcon,\n\t\t\t\t\t\tpSMBFile, (void __user *)arg);\n\t\t\telse\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase CIFS_DUMP_KEY:\n\t\t\t \n\t\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcifs_sb = CIFS_SB(inode->i_sb);\n\t\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\t\tif (IS_ERR(tlink)) {\n\t\t\t\trc = PTR_ERR(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttcon = tlink_tcon(tlink);\n\t\t\tif (!smb3_encryption_required(tcon)) {\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tcifs_put_tlink(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpkey_inf.cipher_type =\n\t\t\t\tle16_to_cpu(tcon->ses->server->cipher_type);\n\t\t\tpkey_inf.Suid = tcon->ses->Suid;\n\t\t\tmemcpy(pkey_inf.auth_key, tcon->ses->auth_key.response,\n\t\t\t\t\t16  );\n\t\t\tmemcpy(pkey_inf.smb3decryptionkey,\n\t\t\t      tcon->ses->smb3decryptionkey, SMB3_SIGN_KEY_SIZE);\n\t\t\tmemcpy(pkey_inf.smb3encryptionkey,\n\t\t\t      tcon->ses->smb3encryptionkey, SMB3_SIGN_KEY_SIZE);\n\t\t\tif (copy_to_user((void __user *)arg, &pkey_inf,\n\t\t\t\t\tsizeof(struct smb3_key_debug_info)))\n\t\t\t\trc = -EFAULT;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t\tcifs_put_tlink(tlink);\n\t\t\tbreak;\n\t\tcase CIFS_DUMP_FULL_KEY:\n\t\t\t \n\t\t\tif (pSMBFile == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcifs_sb = CIFS_SB(inode->i_sb);\n\t\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\t\tif (IS_ERR(tlink)) {\n\t\t\t\trc = PTR_ERR(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttcon = tlink_tcon(tlink);\n\t\t\trc = cifs_dump_full_key(tcon, (void __user *)arg);\n\t\t\tcifs_put_tlink(tlink);\n\t\t\tbreak;\n\t\tcase CIFS_IOC_NOTIFY:\n\t\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\t\t \n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcifs_sb = CIFS_SB(inode->i_sb);\n\t\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\t\tif (IS_ERR(tlink)) {\n\t\t\t\trc = PTR_ERR(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttcon = tlink_tcon(tlink);\n\t\t\tif (tcon && tcon->ses->server->ops->notify) {\n\t\t\t\trc = tcon->ses->server->ops->notify(xid,\n\t\t\t\t\t\tfilep, (void __user *)arg,\n\t\t\t\t\t\tfalse  );\n\t\t\t\tcifs_dbg(FYI, \"ioctl notify rc %d\\n\", rc);\n\t\t\t} else\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\tcifs_put_tlink(tlink);\n\t\t\tbreak;\n\t\tcase CIFS_IOC_NOTIFY_INFO:\n\t\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\t\t \n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcifs_sb = CIFS_SB(inode->i_sb);\n\t\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\t\tif (IS_ERR(tlink)) {\n\t\t\t\trc = PTR_ERR(tlink);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttcon = tlink_tcon(tlink);\n\t\t\tif (tcon && tcon->ses->server->ops->notify) {\n\t\t\t\trc = tcon->ses->server->ops->notify(xid,\n\t\t\t\t\t\tfilep, (void __user *)arg,\n\t\t\t\t\t\ttrue  );\n\t\t\t\tcifs_dbg(FYI, \"ioctl notify info rc %d\\n\", rc);\n\t\t\t} else\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\tcifs_put_tlink(tlink);\n\t\t\tbreak;\n\t\tcase CIFS_IOC_SHUTDOWN:\n\t\t\trc = cifs_shutdown(inode->i_sb, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unsupported ioctl\\n\");\n\t\t\tbreak;\n\t}\ncifs_ioc_exit:\n\tfree_xid(xid);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}