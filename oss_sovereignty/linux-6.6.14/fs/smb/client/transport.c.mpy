{
  "module_name": "transport.c",
  "hash_id": "aea0c6ba5d917d5d3f982b0110d36b9863eb61f48d19616520145f19e9c30cbf",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/transport.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/gfp.h>\n#include <linux/wait.h>\n#include <linux/net.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/tcp.h>\n#include <linux/bvec.h>\n#include <linux/highmem.h>\n#include <linux/uaccess.h>\n#include <linux/processor.h>\n#include <linux/mempool.h>\n#include <linux/sched/signal.h>\n#include <linux/task_io_accounting_ops.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"smbdirect.h\"\n\n \n#define CIFS_MAX_IOV_SIZE 8\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tmid->mid_state = MID_RESPONSE_READY;\n\twake_up_process(mid->callback_data);\n}\n\nstatic struct mid_q_entry *\nalloc_mid(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"%s: null TCP session\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\tkref_init(&temp->refcount);\n\ttemp->mid = get_mid(smb_buffer);\n\ttemp->pid = current->pid;\n\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t \n\t \n\ttemp->when_alloc = jiffies;\n\ttemp->server = server;\n\n\t \n\tget_task_struct(current);\n\ttemp->creator = current;\n\ttemp->callback = cifs_wake_up_task;\n\ttemp->callback_data = current;\n\n\tatomic_inc(&mid_count);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}\n\nvoid __release_mid(struct kref *refcount)\n{\n\tstruct mid_q_entry *midEntry =\n\t\t\tcontainer_of(refcount, struct mid_q_entry, refcount);\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\t__u16 smb_cmd = le16_to_cpu(midEntry->command);\n\tunsigned long now;\n\tunsigned long roundtrip_time;\n#endif\n\tstruct TCP_Server_Info *server = midEntry->server;\n\n\tif (midEntry->resp_buf && (midEntry->mid_flags & MID_WAIT_CANCELLED) &&\n\t    (midEntry->mid_state == MID_RESPONSE_RECEIVED ||\n\t     midEntry->mid_state == MID_RESPONSE_READY) &&\n\t    server->ops->handle_cancelled_mid)\n\t\tserver->ops->handle_cancelled_mid(midEntry, server);\n\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&mid_count);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\tif (now < midEntry->when_alloc)\n\t\tcifs_server_dbg(VFS, \"Invalid mid allocation time\\n\");\n\troundtrip_time = now - midEntry->when_alloc;\n\n\tif (smb_cmd < NUMBER_OF_SMB2_COMMANDS) {\n\t\tif (atomic_read(&server->num_cmds[smb_cmd]) == 0) {\n\t\t\tserver->slowest_cmd[smb_cmd] = roundtrip_time;\n\t\t\tserver->fastest_cmd[smb_cmd] = roundtrip_time;\n\t\t} else {\n\t\t\tif (server->slowest_cmd[smb_cmd] < roundtrip_time)\n\t\t\t\tserver->slowest_cmd[smb_cmd] = roundtrip_time;\n\t\t\telse if (server->fastest_cmd[smb_cmd] > roundtrip_time)\n\t\t\t\tserver->fastest_cmd[smb_cmd] = roundtrip_time;\n\t\t}\n\t\tcifs_stats_inc(&server->num_cmds[smb_cmd]);\n\t\tserver->time_per_cmd[smb_cmd] += roundtrip_time;\n\t}\n\t \n\tif ((slow_rsp_threshold != 0) &&\n\t    time_after(now, midEntry->when_alloc + (slow_rsp_threshold * HZ)) &&\n\t    (midEntry->command != command)) {\n\t\t \n\t\tif (smb_cmd < NUMBER_OF_SMB2_COMMANDS)\n\t\t\tcifs_stats_inc(&server->smb2slowcmd[smb_cmd]);\n\n\t\ttrace_smb3_slow_rsp(smb_cmd, midEntry->mid, midEntry->pid,\n\t\t\t       midEntry->when_sent, midEntry->when_received);\n\t\tif (cifsFYI & CIFS_TIMER) {\n\t\t\tpr_debug(\"slow rsp: cmd %d mid %llu\",\n\t\t\t\t midEntry->command, midEntry->mid);\n\t\t\tcifs_info(\"A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t\t  now - midEntry->when_alloc,\n\t\t\t\t  now - midEntry->when_sent,\n\t\t\t\t  now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tput_task_struct(midEntry->creator);\n\n\tmempool_free(midEntry, cifs_mid_poolp);\n}\n\nvoid\ndelete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&mid->server->mid_lock);\n\tif (!(mid->mid_flags & MID_DELETED)) {\n\t\tlist_del_init(&mid->qhead);\n\t\tmid->mid_flags |= MID_DELETED;\n\t}\n\tspin_unlock(&mid->server->mid_lock);\n\n\trelease_mid(mid);\n}\n\n \nstatic int\nsmb_send_kvec(struct TCP_Server_Info *server, struct msghdr *smb_msg,\n\t      size_t *sent)\n{\n\tint rc = 0;\n\tint retries = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tif (server->noblocksnd)\n\t\tsmb_msg->msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg->msg_flags = MSG_NOSIGNAL;\n\n\twhile (msg_data_left(smb_msg)) {\n\t\t \n\t\trc = sock_sendmsg(ssocket, smb_msg);\n\t\tif (rc == -EAGAIN) {\n\t\t\tretries++;\n\t\t\tif (retries >= 14 ||\n\t\t\t    (!server->noblocksnd && (retries > 2))) {\n\t\t\t\tcifs_server_dbg(VFS, \"sends on sock %p stuck for 15 seconds\\n\",\n\t\t\t\t\t ssocket);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tmsleep(1 << retries);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc == 0) {\n\t\t\t \n\t\t\tcifs_server_dbg(VFS, \"tcp sent no data\\n\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t*sent += rc;\n\t\tretries = 0;  \n\t}\n\treturn 0;\n}\n\nunsigned long\nsmb_rqst_len(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tunsigned int i;\n\tstruct kvec *iov;\n\tint nvec;\n\tunsigned long buflen = 0;\n\n\tif (!is_smb1(server) && rqst->rq_nvec >= 2 &&\n\t    rqst->rq_iov[0].iov_len == 4) {\n\t\tiov = &rqst->rq_iov[1];\n\t\tnvec = rqst->rq_nvec - 1;\n\t} else {\n\t\tiov = rqst->rq_iov;\n\t\tnvec = rqst->rq_nvec;\n\t}\n\n\t \n\tfor (i = 0; i < nvec; i++)\n\t\tbuflen += iov[i].iov_len;\n\n\tbuflen += iov_iter_count(&rqst->rq_iter);\n\treturn buflen;\n}\n\nstatic int\n__smb_send_rqst(struct TCP_Server_Info *server, int num_rqst,\n\t\tstruct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov;\n\tint n_vec;\n\tunsigned int send_length = 0;\n\tunsigned int i, j;\n\tsigset_t mask, oldmask;\n\tsize_t total_len = 0, sent, size;\n\tstruct socket *ssocket = server->ssocket;\n\tstruct msghdr smb_msg = {};\n\t__be32 rfc1002_marker;\n\n\tcifs_in_send_inc(server);\n\tif (cifs_rdma_enabled(server)) {\n\t\t \n\t\trc = -EAGAIN;\n\t\tif (server->smbd_conn)\n\t\t\trc = smbd_send(server, num_rqst, rqst);\n\t\tgoto smbd_done;\n\t}\n\n\trc = -EAGAIN;\n\tif (ssocket == NULL)\n\t\tgoto out;\n\n\trc = -ERESTARTSYS;\n\tif (fatal_signal_pending(current)) {\n\t\tcifs_dbg(FYI, \"signal pending before send request\\n\");\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t \n\ttcp_sock_set_cork(ssocket->sk, true);\n\n\tfor (j = 0; j < num_rqst; j++)\n\t\tsend_length += smb_rqst_len(server, &rqst[j]);\n\trfc1002_marker = cpu_to_be32(send_length);\n\n\t \n\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &oldmask);\n\n\t \n\tif (!is_smb1(server)) {\n\t\tstruct kvec hiov = {\n\t\t\t.iov_base = &rfc1002_marker,\n\t\t\t.iov_len  = 4\n\t\t};\n\t\tiov_iter_kvec(&smb_msg.msg_iter, ITER_SOURCE, &hiov, 1, 4);\n\t\trc = smb_send_kvec(server, &smb_msg, &sent);\n\t\tif (rc < 0)\n\t\t\tgoto unmask;\n\n\t\ttotal_len += sent;\n\t\tsend_length += 4;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", send_length);\n\n\tfor (j = 0; j < num_rqst; j++) {\n\t\tiov = rqst[j].rq_iov;\n\t\tn_vec = rqst[j].rq_nvec;\n\n\t\tsize = 0;\n\t\tfor (i = 0; i < n_vec; i++) {\n\t\t\tdump_smb(iov[i].iov_base, iov[i].iov_len);\n\t\t\tsize += iov[i].iov_len;\n\t\t}\n\n\t\tiov_iter_kvec(&smb_msg.msg_iter, ITER_SOURCE, iov, n_vec, size);\n\n\t\trc = smb_send_kvec(server, &smb_msg, &sent);\n\t\tif (rc < 0)\n\t\t\tgoto unmask;\n\n\t\ttotal_len += sent;\n\n\t\tif (iov_iter_count(&rqst[j].rq_iter) > 0) {\n\t\t\tsmb_msg.msg_iter = rqst[j].rq_iter;\n\t\t\trc = smb_send_kvec(server, &smb_msg, &sent);\n\t\t\tif (rc < 0)\n\t\t\t\tbreak;\n\t\t\ttotal_len += sent;\n\t\t}\n\n}\n\nunmask:\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t \n\n\tif (signal_pending(current) && (total_len != send_length)) {\n\t\tcifs_dbg(FYI, \"signal is pending after attempt to send\\n\");\n\t\trc = -ERESTARTSYS;\n\t}\n\n\t \n\ttcp_sock_set_cork(ssocket->sk, false);\n\n\tif ((total_len > 0) && (total_len != send_length)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t send_length, total_len);\n\t\t \n\t\tcifs_signal_cifsd_for_reconnect(server, false);\n\t\ttrace_smb3_partial_send_reconnect(server->CurrentMid,\n\t\t\t\t\t\t  server->conn_id, server->hostname);\n\t}\nsmbd_done:\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_server_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse if (rc > 0)\n\t\trc = 0;\nout:\n\tcifs_in_send_dec(server);\n\treturn rc;\n}\n\nstruct send_req_vars {\n\tstruct smb2_transform_hdr tr_hdr;\n\tstruct smb_rqst rqst[MAX_COMPOUND];\n\tstruct kvec iov;\n};\n\nstatic int\nsmb_send_rqst(struct TCP_Server_Info *server, int num_rqst,\n\t      struct smb_rqst *rqst, int flags)\n{\n\tstruct send_req_vars *vars;\n\tstruct smb_rqst *cur_rqst;\n\tstruct kvec *iov;\n\tint rc;\n\n\tif (!(flags & CIFS_TRANSFORM_REQ))\n\t\treturn __smb_send_rqst(server, num_rqst, rqst);\n\n\tif (num_rqst > MAX_COMPOUND - 1)\n\t\treturn -ENOMEM;\n\n\tif (!server->ops->init_transform_rq) {\n\t\tcifs_server_dbg(VFS, \"Encryption requested but transform callback is missing\\n\");\n\t\treturn -EIO;\n\t}\n\n\tvars = kzalloc(sizeof(*vars), GFP_NOFS);\n\tif (!vars)\n\t\treturn -ENOMEM;\n\tcur_rqst = vars->rqst;\n\tiov = &vars->iov;\n\n\tiov->iov_base = &vars->tr_hdr;\n\tiov->iov_len = sizeof(vars->tr_hdr);\n\tcur_rqst[0].rq_iov = iov;\n\tcur_rqst[0].rq_nvec = 1;\n\n\trc = server->ops->init_transform_rq(server, num_rqst + 1,\n\t\t\t\t\t    &cur_rqst[0], rqst);\n\tif (rc)\n\t\tgoto out;\n\n\trc = __smb_send_rqst(server, num_rqst + 1, &cur_rqst[0]);\n\tsmb3_free_compound_rqst(num_rqst, &cur_rqst[1]);\nout:\n\tkfree(vars);\n\treturn rc;\n}\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\n\tiov[0].iov_base = smb_buffer;\n\tiov[0].iov_len = 4;\n\tiov[1].iov_base = (char *)smb_buffer + 4;\n\tiov[1].iov_len = smb_buf_length;\n\n\treturn __smb_send_rqst(server, 1, &rqst);\n}\n\nstatic int\nwait_for_free_credits(struct TCP_Server_Info *server, const int num_credits,\n\t\t      const int timeout, const int flags,\n\t\t      unsigned int *instance)\n{\n\tlong rc;\n\tint *credits;\n\tint optype;\n\tlong int t;\n\tint scredits, in_flight;\n\n\tif (timeout < 0)\n\t\tt = MAX_JIFFY_OFFSET;\n\telse\n\t\tt = msecs_to_jiffies(timeout);\n\n\toptype = flags & CIFS_OP_MASK;\n\n\t*instance = 0;\n\n\tcredits = server->ops->get_credits_field(server, optype);\n\t \n\tif (*credits <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\n\tspin_lock(&server->req_lock);\n\tif ((flags & CIFS_TIMEOUT_MASK) == CIFS_NON_BLOCKING) {\n\t\t \n\t\tserver->in_flight++;\n\t\tif (server->in_flight > server->max_in_flight)\n\t\t\tserver->max_in_flight = server->in_flight;\n\t\t*credits -= 1;\n\t\t*instance = server->reconnect_instance;\n\t\tscredits = *credits;\n\t\tin_flight = server->in_flight;\n\t\tspin_unlock(&server->req_lock);\n\n\t\ttrace_smb3_nblk_credits(server->CurrentMid,\n\t\t\t\tserver->conn_id, server->hostname, scredits, -1, in_flight);\n\t\tcifs_dbg(FYI, \"%s: remove %u credits total=%d\\n\",\n\t\t\t\t__func__, 1, scredits);\n\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tspin_unlock(&server->req_lock);\n\n\t\tspin_lock(&server->srv_lock);\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tspin_lock(&server->req_lock);\n\t\tif (*credits < num_credits) {\n\t\t\tscredits = *credits;\n\t\t\tspin_unlock(&server->req_lock);\n\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable_timeout(server->request_q,\n\t\t\t\thas_credits(server, credits, num_credits), t);\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (!rc) {\n\t\t\t\tspin_lock(&server->req_lock);\n\t\t\t\tscredits = *credits;\n\t\t\t\tin_flight = server->in_flight;\n\t\t\t\tspin_unlock(&server->req_lock);\n\n\t\t\t\ttrace_smb3_credit_timeout(server->CurrentMid,\n\t\t\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\t\t\tnum_credits, in_flight);\n\t\t\t\tcifs_server_dbg(VFS, \"wait timed out after %d ms\\n\",\n\t\t\t\t\t\ttimeout);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tif (rc == -ERESTARTSYS)\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\t \n\t\t\tif (!optype && num_credits == 1 &&\n\t\t\t    server->in_flight > 2 * MAX_COMPOUND &&\n\t\t\t    *credits <= MAX_COMPOUND) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\n\t\t\t\tcifs_num_waiters_inc(server);\n\t\t\t\trc = wait_event_killable_timeout(\n\t\t\t\t\tserver->request_q,\n\t\t\t\t\thas_credits(server, credits,\n\t\t\t\t\t\t    MAX_COMPOUND + 1),\n\t\t\t\t\tt);\n\t\t\t\tcifs_num_waiters_dec(server);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tspin_lock(&server->req_lock);\n\t\t\t\t\tscredits = *credits;\n\t\t\t\t\tin_flight = server->in_flight;\n\t\t\t\t\tspin_unlock(&server->req_lock);\n\n\t\t\t\t\ttrace_smb3_credit_timeout(\n\t\t\t\t\t\t\tserver->CurrentMid,\n\t\t\t\t\t\t\tserver->conn_id, server->hostname,\n\t\t\t\t\t\t\tscredits, num_credits, in_flight);\n\t\t\t\t\tcifs_server_dbg(VFS, \"wait timed out after %d ms\\n\",\n\t\t\t\t\t\t\ttimeout);\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tif (rc == -ERESTARTSYS)\n\t\t\t\t\treturn -ERESTARTSYS;\n\t\t\t\tspin_lock(&server->req_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tif ((flags & CIFS_TIMEOUT_MASK) != CIFS_BLOCKING_OP) {\n\t\t\t\t*credits -= num_credits;\n\t\t\t\tserver->in_flight += num_credits;\n\t\t\t\tif (server->in_flight > server->max_in_flight)\n\t\t\t\t\tserver->max_in_flight = server->in_flight;\n\t\t\t\t*instance = server->reconnect_instance;\n\t\t\t}\n\t\t\tscredits = *credits;\n\t\t\tin_flight = server->in_flight;\n\t\t\tspin_unlock(&server->req_lock);\n\n\t\t\ttrace_smb3_waitff_credits(server->CurrentMid,\n\t\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\t\t-(num_credits), in_flight);\n\t\t\tcifs_dbg(FYI, \"%s: remove %u credits total=%d\\n\",\n\t\t\t\t\t__func__, num_credits, scredits);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int flags,\n\t\t      unsigned int *instance)\n{\n\treturn wait_for_free_credits(server, 1, -1, flags,\n\t\t\t\t     instance);\n}\n\nstatic int\nwait_for_compound_request(struct TCP_Server_Info *server, int num,\n\t\t\t  const int flags, unsigned int *instance)\n{\n\tint *credits;\n\tint scredits, in_flight;\n\n\tcredits = server->ops->get_credits_field(server, flags & CIFS_OP_MASK);\n\n\tspin_lock(&server->req_lock);\n\tscredits = *credits;\n\tin_flight = server->in_flight;\n\n\tif (*credits < num) {\n\t\t \n\t\tif (server->in_flight == 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\ttrace_smb3_insufficient_credits(server->CurrentMid,\n\t\t\t\t\tserver->conn_id, server->hostname, scredits,\n\t\t\t\t\tnum, in_flight);\n\t\t\tcifs_dbg(FYI, \"%s: %d requests in flight, needed %d total=%d\\n\",\n\t\t\t\t\t__func__, in_flight, num, scredits);\n\t\t\treturn -EDEADLK;\n\t\t}\n\t}\n\tspin_unlock(&server->req_lock);\n\n\treturn wait_for_free_credits(server, num, 60000, flags,\n\t\t\t\t     instance);\n}\n\nint\ncifs_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, struct cifs_credits *credits)\n{\n\t*num = size;\n\tcredits->value = 0;\n\tcredits->instance = server->reconnect_instance;\n\treturn 0;\n}\n\nstatic int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_NEW) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE)) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t}\n\n\tif (ses->ses_status == SES_EXITING) {\n\t\t \n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\t*ppmidQ = alloc_mid(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&ses->server->mid_lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&ses->server->mid_lock);\n\treturn 0;\n}\n\nstatic int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_state(server->response_q,\n\t\t\t\t midQ->mid_state != MID_REQUEST_SUBMITTED &&\n\t\t\t\t midQ->mid_state != MID_RESPONSE_RECEIVED,\n\t\t\t\t (TASK_KILLABLE|TASK_FREEZABLE_UNSAFE));\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}\n\nstruct mid_q_entry *\ncifs_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\tif (rqst->rq_iov[0].iov_len != 4 ||\n\t    rqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\n\t\treturn ERR_PTR(-EIO);\n\n\t \n\tif (server->sign)\n\t\thdr->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tmid = alloc_mid(hdr, server);\n\tif (mid == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_sign_rqst(rqst, server, &mid->sequence_number);\n\tif (rc) {\n\t\trelease_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn mid;\n}\n\n \nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tmid_handle_t *handle, void *cbdata, const int flags,\n\t\tconst struct cifs_credits *exist_credits)\n{\n\tint rc;\n\tstruct mid_q_entry *mid;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\tunsigned int instance;\n\tint optype;\n\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, flags, &instance);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits.value = 1;\n\t\tcredits.instance = instance;\n\t} else\n\t\tinstance = exist_credits->instance;\n\n\tcifs_server_lock(server);\n\n\t \n\tif (instance != server->reconnect_instance) {\n\t\tcifs_server_unlock(server);\n\t\tadd_credits_and_wake_if(server, &credits, optype);\n\t\treturn -EAGAIN;\n\t}\n\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tcifs_server_unlock(server);\n\t\tadd_credits_and_wake_if(server, &credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->handle = handle;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t \n\tspin_lock(&server->mid_lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&server->mid_lock);\n\n\t \n\tcifs_save_when_sent(mid);\n\trc = smb_send_rqst(server, 1, rqst, flags);\n\n\tif (rc < 0) {\n\t\trevert_current_mid(server, mid->credits);\n\t\tserver->sequence_number -= 2;\n\t\tdelete_mid(mid);\n\t}\n\n\tcifs_server_unlock(server);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tadd_credits_and_wake_if(server, &credits, optype);\n\treturn rc;\n}\n\n \nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RSP_BUF;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags, &rsp_iov);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}\n\nstatic int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&server->mid_lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_READY:\n\t\tspin_unlock(&server->mid_lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tif (!(mid->mid_flags & MID_DELETED)) {\n\t\t\tlist_del_init(&mid->qhead);\n\t\t\tmid->mid_flags |= MID_DELETED;\n\t\t}\n\t\tcifs_server_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&server->mid_lock);\n\n\trelease_mid(mid);\n\treturn rc;\n}\n\nstatic inline int\nsend_cancel(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t    struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, rqst, mid) : 0;\n}\n\nint\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t \n\tif (server->sign) {\n\t\tstruct kvec iov[2];\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t\t .rq_nvec = 2 };\n\n\t\tiov[0].iov_base = mid->resp_buf;\n\t\tiov[0].iov_len = 4;\n\t\tiov[1].iov_base = (char *)mid->resp_buf + 4;\n\t\tiov[1].iov_len = len - 4;\n\t\t \n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_server_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t \n\treturn map_and_check_smb_error(mid, log_error);\n}\n\nstruct mid_q_entry *\ncifs_setup_request(struct cifs_ses *ses, struct TCP_Server_Info *ignored,\n\t\t   struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\tif (rqst->rq_iov[0].iov_len != 4 ||\n\t    rqst->rq_iov[0].iov_base + 4 != rqst->rq_iov[1].iov_base)\n\t\treturn ERR_PTR(-EIO);\n\n\trc = allocate_mid(ses, hdr, &mid);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\trc = cifs_sign_rqst(rqst, ses->server, &mid->sequence_number);\n\tif (rc) {\n\t\tdelete_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn mid;\n}\n\nstatic void\ncifs_compound_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->server;\n\tstruct cifs_credits credits;\n\n\tcredits.value = server->ops->get_credits(mid);\n\tcredits.instance = server->reconnect_instance;\n\n\tadd_credits(server, &credits, mid->optype);\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tmid->mid_state = MID_RESPONSE_READY;\n}\n\nstatic void\ncifs_compound_last_callback(struct mid_q_entry *mid)\n{\n\tcifs_compound_callback(mid);\n\tcifs_wake_up_task(mid);\n}\n\nstatic void\ncifs_cancelled_callback(struct mid_q_entry *mid)\n{\n\tcifs_compound_callback(mid);\n\trelease_mid(mid);\n}\n\n \nstruct TCP_Server_Info *cifs_pick_channel(struct cifs_ses *ses)\n{\n\tuint index = 0;\n\tunsigned int min_in_flight = UINT_MAX, max_in_flight = 0;\n\tstruct TCP_Server_Info *server = NULL;\n\tint i;\n\n\tif (!ses)\n\t\treturn NULL;\n\n\tspin_lock(&ses->chan_lock);\n\tfor (i = 0; i < ses->chan_count; i++) {\n\t\tserver = ses->chans[i].server;\n\t\tif (!server)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (server->in_flight < min_in_flight) {\n\t\t\tmin_in_flight = server->in_flight;\n\t\t\tindex = i;\n\t\t}\n\t\tif (server->in_flight > max_in_flight)\n\t\t\tmax_in_flight = server->in_flight;\n\t}\n\n\t \n\tif (min_in_flight == max_in_flight) {\n\t\tindex = (uint)atomic_inc_return(&ses->chan_seq);\n\t\tindex %= ses->chan_count;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\treturn ses->chans[index].server;\n}\n\nint\ncompound_send_recv(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   const int flags, const int num_rqst, struct smb_rqst *rqst,\n\t\t   int *resp_buf_type, struct kvec *resp_iov)\n{\n\tint i, j, optype, rc = 0;\n\tstruct mid_q_entry *midQ[MAX_COMPOUND];\n\tbool cancelled_mid[MAX_COMPOUND] = {false};\n\tstruct cifs_credits credits[MAX_COMPOUND] = {\n\t\t{ .value = 0, .instance = 0 }\n\t};\n\tunsigned int instance;\n\tchar *buf;\n\n\toptype = flags & CIFS_OP_MASK;\n\n\tfor (i = 0; i < num_rqst; i++)\n\t\tresp_buf_type[i] = CIFS_NO_BUFFER;   \n\n\tif (!ses || !ses->server || !server) {\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\t \n\trc = wait_for_compound_request(server, num_rqst, flags,\n\t\t\t\t       &instance);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tcredits[i].value = 1;\n\t\tcredits[i].instance = instance;\n\t}\n\n\t \n\n\tcifs_server_lock(server);\n\n\t \n\tif (instance != server->reconnect_instance) {\n\t\tcifs_server_unlock(server);\n\t\tfor (j = 0; j < num_rqst; j++)\n\t\t\tadd_credits(server, &credits[j], optype);\n\t\treturn -EAGAIN;\n\t}\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tmidQ[i] = server->ops->setup_request(ses, server, &rqst[i]);\n\t\tif (IS_ERR(midQ[i])) {\n\t\t\trevert_current_mid(server, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdelete_mid(midQ[j]);\n\t\t\tcifs_server_unlock(server);\n\n\t\t\t \n\t\t\tfor (j = 0; j < num_rqst; j++)\n\t\t\t\tadd_credits(server, &credits[j], optype);\n\t\t\treturn PTR_ERR(midQ[i]);\n\t\t}\n\n\t\tmidQ[i]->mid_state = MID_REQUEST_SUBMITTED;\n\t\tmidQ[i]->optype = optype;\n\t\t \n\t\tif (i < num_rqst - 1)\n\t\t\tmidQ[i]->callback = cifs_compound_callback;\n\t\telse\n\t\t\tmidQ[i]->callback = cifs_compound_last_callback;\n\t}\n\trc = smb_send_rqst(server, num_rqst, rqst, flags);\n\n\tfor (i = 0; i < num_rqst; i++)\n\t\tcifs_save_when_sent(midQ[i]);\n\n\tif (rc < 0) {\n\t\trevert_current_mid(server, num_rqst);\n\t\tserver->sequence_number -= 2;\n\t}\n\n\tcifs_server_unlock(server);\n\n\t \n\tif (rc < 0 || (flags & CIFS_NO_SRV_RSP)) {\n\t\tfor (i = 0; i < num_rqst; i++)\n\t\t\tadd_credits(server, &credits[i], optype);\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tspin_lock(&ses->ses_lock);\n\tif ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\tcifs_server_lock(server);\n\t\tsmb311_update_preauth_hash(ses, server, rqst[0].rq_iov, rqst[0].rq_nvec);\n\t\tcifs_server_unlock(server);\n\n\t\tspin_lock(&ses->ses_lock);\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\trc = wait_for_response(server, midQ[i]);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t}\n\tif (rc != 0) {\n\t\tfor (; i < num_rqst; i++) {\n\t\t\tcifs_server_dbg(FYI, \"Cancelling wait for mid %llu cmd: %d\\n\",\n\t\t\t\t midQ[i]->mid, le16_to_cpu(midQ[i]->command));\n\t\t\tsend_cancel(server, &rqst[i], midQ[i]);\n\t\t\tspin_lock(&server->mid_lock);\n\t\t\tmidQ[i]->mid_flags |= MID_WAIT_CANCELLED;\n\t\t\tif (midQ[i]->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t\t    midQ[i]->mid_state == MID_RESPONSE_RECEIVED) {\n\t\t\t\tmidQ[i]->callback = cifs_cancelled_callback;\n\t\t\t\tcancelled_mid[i] = true;\n\t\t\t\tcredits[i].value = 0;\n\t\t\t}\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\trc = cifs_sync_mid_result(midQ[i], server);\n\t\tif (rc != 0) {\n\t\t\t \n\t\t\tcancelled_mid[i] = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!midQ[i]->resp_buf ||\n\t\t    midQ[i]->mid_state != MID_RESPONSE_READY) {\n\t\t\trc = -EIO;\n\t\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf = (char *)midQ[i]->resp_buf;\n\t\tresp_iov[i].iov_base = buf;\n\t\tresp_iov[i].iov_len = midQ[i]->resp_buf_size +\n\t\t\tHEADER_PREAMBLE_SIZE(server);\n\n\t\tif (midQ[i]->large_buf)\n\t\t\tresp_buf_type[i] = CIFS_LARGE_BUFFER;\n\t\telse\n\t\t\tresp_buf_type[i] = CIFS_SMALL_BUFFER;\n\n\t\trc = server->ops->check_receive(midQ[i], server,\n\t\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t\t \n\t\tif ((flags & CIFS_NO_RSP_BUF) == 0)\n\t\t\tmidQ[i]->resp_buf = NULL;\n\n\t}\n\n\t \n\tspin_lock(&ses->ses_lock);\n\tif ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {\n\t\tstruct kvec iov = {\n\t\t\t.iov_base = resp_iov[0].iov_base,\n\t\t\t.iov_len = resp_iov[0].iov_len\n\t\t};\n\t\tspin_unlock(&ses->ses_lock);\n\t\tcifs_server_lock(server);\n\t\tsmb311_update_preauth_hash(ses, server, &iov, 1);\n\t\tcifs_server_unlock(server);\n\t\tspin_lock(&ses->ses_lock);\n\t}\n\tspin_unlock(&ses->ses_lock);\n\nout:\n\t \n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (!cancelled_mid[i])\n\t\t\tdelete_mid(midQ[i]);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_send_recv(const unsigned int xid, struct cifs_ses *ses,\n\t       struct TCP_Server_Info *server,\n\t       struct smb_rqst *rqst, int *resp_buf_type, const int flags,\n\t       struct kvec *resp_iov)\n{\n\treturn compound_send_recv(xid, ses, server, flags, 1,\n\t\t\t\t  rqst, resp_buf_type, resp_iov);\n}\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type  ,\n\t     const int flags, struct kvec *resp_iov)\n{\n\tstruct smb_rqst rqst;\n\tstruct kvec s_iov[CIFS_MAX_IOV_SIZE], *new_iov;\n\tint rc;\n\n\tif (n_vec + 1 > CIFS_MAX_IOV_SIZE) {\n\t\tnew_iov = kmalloc_array(n_vec + 1, sizeof(struct kvec),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_iov) {\n\t\t\t \n\t\t\t*resp_buf_type = CIFS_NO_BUFFER;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\tnew_iov = s_iov;\n\n\t \n\tmemcpy(new_iov + 1, iov, (sizeof(struct kvec) * n_vec));\n\n\tnew_iov[0].iov_base = new_iov[1].iov_base;\n\tnew_iov[0].iov_len = 4;\n\tnew_iov[1].iov_base += 4;\n\tnew_iov[1].iov_len -= 4;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = new_iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, ses, ses->server,\n\t\t\t    &rqst, resp_buf_type, flags, resp_iov);\n\tif (n_vec + 1 > CIFS_MAX_IOV_SIZE)\n\t\tkfree(new_iov);\n\treturn rc;\n}\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int flags)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\tunsigned int len = be32_to_cpu(in_buf->smb_buf_length);\n\tstruct kvec iov = { .iov_base = in_buf, .iov_len = len };\n\tstruct smb_rqst rqst = { .rq_iov = &iov, .rq_nvec = 1 };\n\tstruct cifs_credits credits = { .value = 1, .instance = 0 };\n\tstruct TCP_Server_Info *server;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tserver = ses->server;\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\t \n\n\tif (len > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_server_dbg(VFS, \"Invalid length, greater than maximum frame, %d\\n\",\n\t\t\t\tlen);\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(server, flags, &credits.instance);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tcifs_server_lock(server);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tcifs_server_unlock(server);\n\t\t \n\t\tadd_credits(server, &credits, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_server_unlock(server);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\trc = smb_send(server, in_buf, len);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\n\tcifs_server_unlock(server);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = wait_for_response(server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(server, &rqst, midQ);\n\t\tspin_lock(&server->mid_lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t    midQ->mid_state == MID_RESPONSE_RECEIVED) {\n\t\t\t \n\t\t\tmidQ->callback = release_mid;\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t\tadd_credits(server, &credits, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&server->mid_lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, server);\n\tif (rc != 0) {\n\t\tadd_credits(server, &credits, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_READY) {\n\t\trc = -EIO;\n\t\tcifs_server_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, server, 0);\nout:\n\tdelete_mid(midQ);\n\tadd_credits(server, &credits, 0);\n\n\treturn rc;\n}\n\n \n\nstatic int\nsend_lock_cancel(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf)\n{\n\tint bytes_returned;\n\tstruct cifs_ses *ses = tcon->ses;\n\tLOCK_REQ *pSMB = (LOCK_REQ *)in_buf;\n\n\t \n\n\tpSMB->LockType = LOCKING_ANDX_CANCEL_LOCK|LOCKING_ANDX_LARGE_FILES;\n\tpSMB->Timeout = 0;\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\treturn SendReceive(xid, ses, in_buf, out_buf,\n\t\t\t&bytes_returned, 0);\n}\n\nint\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\tunsigned int len = be32_to_cpu(in_buf->smb_buf_length);\n\tstruct kvec iov = { .iov_base = in_buf, .iov_len = len };\n\tstruct smb_rqst rqst = { .rq_iov = &iov, .rq_nvec = 1 };\n\tunsigned int instance;\n\tstruct TCP_Server_Info *server;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\t \n\n\tif (len > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_tcon_dbg(VFS, \"Invalid length, greater than maximum frame, %d\\n\",\n\t\t\t      len);\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(server, CIFS_BLOCKING_OP, &instance);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tcifs_server_lock(server);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tcifs_server_unlock(server);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, server, &midQ->sequence_number);\n\tif (rc) {\n\t\tdelete_mid(midQ);\n\t\tcifs_server_unlock(server);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\trc = smb_send(server, in_buf, len);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\n\tcifs_server_unlock(server);\n\n\tif (rc < 0) {\n\t\tdelete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t \n\trc = wait_event_interruptible(server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t   midQ->mid_state == MID_RESPONSE_RECEIVED)) ||\n\t\t((server->tcpStatus != CifsGood) &&\n\t\t (server->tcpStatus != CifsNew)));\n\n\t \n\tspin_lock(&server->srv_lock);\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t midQ->mid_state == MID_RESPONSE_RECEIVED) &&\n\t\t((server->tcpStatus == CifsGood) ||\n\t\t (server->tcpStatus == CifsNew))) {\n\t\tspin_unlock(&server->srv_lock);\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t \n\t\t\trc = send_cancel(server, &rqst, midQ);\n\t\t\tif (rc) {\n\t\t\t\tdelete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t \n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tdelete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(server, &rqst, midQ);\n\t\t\tspin_lock(&server->mid_lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t\t    midQ->mid_state == MID_RESPONSE_RECEIVED) {\n\t\t\t\t \n\t\t\t\tmidQ->callback = release_mid;\n\t\t\t\tspin_unlock(&server->mid_lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t}\n\n\t\t \n\t\trstart = 1;\n\t\tspin_lock(&server->srv_lock);\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\trc = cifs_sync_mid_result(midQ, server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_READY) {\n\t\trc = -EIO;\n\t\tcifs_tcon_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, server, 0);\nout:\n\tdelete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}\n\n \nint\ncifs_discard_remaining_data(struct TCP_Server_Info *server)\n{\n\tunsigned int rfclen = server->pdu_size;\n\tsize_t remaining = rfclen + HEADER_PREAMBLE_SIZE(server) -\n\t\tserver->total_read;\n\n\twhile (remaining > 0) {\n\t\tssize_t length;\n\n\t\tlength = cifs_discard_from_socket(server,\n\t\t\t\tmin_t(size_t, remaining,\n\t\t\t\t      CIFSMaxBufSize + MAX_HEADER_SIZE(server)));\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t\tremaining -= length;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__cifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid,\n\t\t     bool malformed)\n{\n\tint length;\n\n\tlength = cifs_discard_remaining_data(server);\n\tdequeue_mid(mid, malformed);\n\tmid->resp_buf = server->smallbuf;\n\tserver->smallbuf = NULL;\n\treturn length;\n}\n\nstatic int\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\n\treturn  __cifs_readv_discard(server, mid, rdata->result);\n}\n\nint\ncifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length, len;\n\tunsigned int data_offset, data_len;\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tchar *buf = server->smallbuf;\n\tunsigned int buflen = server->pdu_size + HEADER_PREAMBLE_SIZE(server);\n\tbool use_rdma_mr = false;\n\n\tcifs_dbg(FYI, \"%s: mid=%llu offset=%llu bytes=%u\\n\",\n\t\t __func__, mid->mid, rdata->offset, rdata->bytes);\n\n\t \n\tlen = min_t(unsigned int, buflen, server->vals->read_rsp_size) -\n\t\t\t\t\t\t\tHEADER_SIZE(server) + 1;\n\n\tlength = cifs_read_from_socket(server,\n\t\t\t\t       buf + HEADER_SIZE(server) - 1, len);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tif (server->ops->is_session_expired &&\n\t    server->ops->is_session_expired(buf)) {\n\t\tcifs_reconnect(server, true);\n\t\treturn -1;\n\t}\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server)) {\n\t\tcifs_discard_remaining_data(server);\n\t\treturn -1;\n\t}\n\n\t \n\trdata->iov[0].iov_base = buf;\n\trdata->iov[0].iov_len = HEADER_PREAMBLE_SIZE(server);\n\trdata->iov[1].iov_base = buf + HEADER_PREAMBLE_SIZE(server);\n\trdata->iov[1].iov_len =\n\t\tserver->total_read - HEADER_PREAMBLE_SIZE(server);\n\tcifs_dbg(FYI, \"0: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov[0].iov_base, rdata->iov[0].iov_len);\n\tcifs_dbg(FYI, \"1: iov_base=%p iov_len=%zu\\n\",\n\t\t rdata->iov[1].iov_base, rdata->iov[1].iov_len);\n\n\t \n\trdata->result = server->ops->map_error(buf, false);\n\tif (rdata->result != 0) {\n\t\tcifs_dbg(FYI, \"%s: server returned error %d\\n\",\n\t\t\t __func__, rdata->result);\n\t\t \n\t\treturn __cifs_readv_discard(server, mid, false);\n\t}\n\n\t \n\tif (server->total_read < server->vals->read_rsp_size) {\n\t\tcifs_dbg(FYI, \"%s: server returned short header. got=%u expected=%zu\\n\",\n\t\t\t __func__, server->total_read,\n\t\t\t server->vals->read_rsp_size);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tdata_offset = server->ops->read_data_offset(buf) +\n\t\tHEADER_PREAMBLE_SIZE(server);\n\tif (data_offset < server->total_read) {\n\t\t \n\t\tcifs_dbg(FYI, \"%s: data offset (%u) inside read response header\\n\",\n\t\t\t __func__, data_offset);\n\t\tdata_offset = server->total_read;\n\t} else if (data_offset > MAX_CIFS_SMALL_BUFFER_SIZE) {\n\t\t \n\t\tcifs_dbg(FYI, \"%s: data offset (%u) beyond end of smallbuf\\n\",\n\t\t\t __func__, data_offset);\n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n\tcifs_dbg(FYI, \"%s: total_read=%u data_offset=%u\\n\",\n\t\t __func__, server->total_read, data_offset);\n\n\tlen = data_offset - server->total_read;\n\tif (len > 0) {\n\t\t \n\t\tlength = cifs_read_from_socket(server,\n\t\t\t\t\t       buf + server->total_read, len);\n\t\tif (length < 0)\n\t\t\treturn length;\n\t\tserver->total_read += length;\n\t}\n\n\t \n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tuse_rdma_mr = rdata->mr;\n#endif\n\tdata_len = server->ops->read_data_length(buf, use_rdma_mr);\n\tif (!use_rdma_mr && (data_offset + data_len > buflen)) {\n\t\t \n\t\trdata->result = -EIO;\n\t\treturn cifs_readv_discard(server, mid);\n\t}\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (rdata->mr)\n\t\tlength = data_len;  \n\telse\n#endif\n\t\tlength = cifs_read_iter_from_socket(server, &rdata->iter,\n\t\t\t\t\t\t    data_len);\n\tif (length > 0)\n\t\trdata->got_bytes += length;\n\tserver->total_read += length;\n\n\tcifs_dbg(FYI, \"total_read=%u buflen=%u remaining=%u\\n\",\n\t\t server->total_read, buflen, data_len);\n\n\t \n\tif (server->total_read < buflen)\n\t\treturn cifs_readv_discard(server, mid);\n\n\tdequeue_mid(mid, false);\n\tmid->resp_buf = server->smallbuf;\n\tserver->smallbuf = NULL;\n\treturn length;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}