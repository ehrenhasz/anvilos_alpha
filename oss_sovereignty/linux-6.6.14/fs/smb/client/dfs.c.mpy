{
  "module_name": "dfs.c",
  "hash_id": "a1ae528147a0f0519f80cedee84c241c7998e82cb9594f734956a37fc55f838c",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/dfs.c",
  "human_readable_source": "\n \n\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"fs_context.h\"\n#include \"dfs.h\"\n\n \nint dfs_parse_target_referral(const char *full_path, const struct dfs_info3_param *ref,\n\t\t\t      struct smb3_fs_context *ctx)\n{\n\tint rc;\n\tconst char *prepath = NULL;\n\tchar *path;\n\n\tif (!full_path || !*full_path || !ref || !ctx)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(!ref->node_name || ref->path_consumed < 0))\n\t\treturn -EINVAL;\n\n\tif (strlen(full_path) - ref->path_consumed) {\n\t\tprepath = full_path + ref->path_consumed;\n\t\t \n\t\tif (*prepath == '/' || *prepath == '\\\\')\n\t\t\tprepath++;\n\t}\n\n\tpath = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\trc = smb3_parse_devname(path, ctx);\n\tif (rc)\n\t\tgoto out;\n\n\trc = dns_resolve_server_name_to_ip(path, (struct sockaddr *)&ctx->dstaddr, NULL);\n\nout:\n\tkfree(path);\n\treturn rc;\n}\n\nstatic int get_session(struct cifs_mount_ctx *mnt_ctx, const char *full_path)\n{\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tint rc;\n\n\tctx->leaf_fullpath = (char *)full_path;\n\trc = cifs_mount_get_session(mnt_ctx);\n\tctx->leaf_fullpath = NULL;\n\n\treturn rc;\n}\n\n \nstatic int add_root_smb_session(struct cifs_mount_ctx *mnt_ctx)\n{\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct dfs_root_ses *root_ses;\n\tstruct cifs_ses *ses = mnt_ctx->ses;\n\n\tif (ses) {\n\t\troot_ses = kmalloc(sizeof(*root_ses), GFP_KERNEL);\n\t\tif (!root_ses)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_LIST_HEAD(&root_ses->list);\n\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tcifs_smb_ses_inc_refcount(ses);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\troot_ses->ses = ses;\n\t\tlist_add_tail(&root_ses->list, &mnt_ctx->dfs_ses_list);\n\t}\n\t \n\tctx->dfs_root_ses = ses;\n\treturn 0;\n}\n\nstatic inline int parse_dfs_target(struct smb3_fs_context *ctx,\n\t\t\t\t   struct dfs_ref_walk *rw,\n\t\t\t\t   struct dfs_info3_param *tgt)\n{\n\tint rc;\n\tconst char *fpath = ref_walk_fpath(rw) + 1;\n\n\trc = ref_walk_get_tgt(rw, tgt);\n\tif (!rc)\n\t\trc = dfs_parse_target_referral(fpath, tgt, ctx);\n\treturn rc;\n}\n\nstatic int set_ref_paths(struct cifs_mount_ctx *mnt_ctx,\n\t\t\t struct dfs_info3_param *tgt,\n\t\t\t struct dfs_ref_walk *rw)\n{\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tchar *ref_path, *full_path;\n\tint rc;\n\n\tfull_path = smb3_fs_context_fullpath(ctx, CIFS_DIR_SEP(cifs_sb));\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\tif (!tgt || (tgt->server_type == DFS_TYPE_LINK &&\n\t\t     DFS_INTERLINK(tgt->flags)))\n\t\tref_path = dfs_get_path(cifs_sb, ctx->UNC);\n\telse\n\t\tref_path = dfs_get_path(cifs_sb, full_path);\n\tif (IS_ERR(ref_path)) {\n\t\trc = PTR_ERR(ref_path);\n\t\tkfree(full_path);\n\t\treturn rc;\n\t}\n\tref_walk_path(rw) = ref_path;\n\tref_walk_fpath(rw) = full_path;\n\treturn 0;\n}\n\nstatic int __dfs_referral_walk(struct cifs_mount_ctx *mnt_ctx,\n\t\t\t       struct dfs_ref_walk *rw)\n{\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct dfs_info3_param tgt = {};\n\tbool is_refsrv;\n\tint rc = -ENOENT;\n\nagain:\n\tdo {\n\t\tif (ref_walk_empty(rw)) {\n\t\t\trc = dfs_get_referral(mnt_ctx, ref_walk_path(rw) + 1,\n\t\t\t\t\t      NULL, ref_walk_tl(rw));\n\t\t\tif (rc) {\n\t\t\t\trc = cifs_mount_get_tcon(mnt_ctx);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = cifs_is_path_remote(mnt_ctx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ref_walk_num_tgts(rw)) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\twhile (ref_walk_next_tgt(rw)) {\n\t\t\trc = parse_dfs_target(ctx, rw, &tgt);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\n\t\t\tcifs_mount_put_conns(mnt_ctx);\n\t\t\trc = get_session(mnt_ctx, ref_walk_path(rw));\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\n\t\t\tis_refsrv = tgt.server_type == DFS_TYPE_ROOT ||\n\t\t\t\tDFS_INTERLINK(tgt.flags);\n\t\t\tref_walk_set_tgt_hint(rw);\n\n\t\t\tif (tgt.flags & DFSREF_STORAGE_SERVER) {\n\t\t\t\trc = cifs_mount_get_tcon(mnt_ctx);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = cifs_is_path_remote(mnt_ctx);\n\t\t\t\tif (!rc)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rc != -EREMOTE)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_refsrv) {\n\t\t\t\trc = add_root_smb_session(mnt_ctx);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trc = ref_walk_advance(rw);\n\t\t\tif (!rc) {\n\t\t\t\trc = set_ref_paths(mnt_ctx, &tgt, rw);\n\t\t\t\tif (!rc) {\n\t\t\t\t\trc = -EREMOTE;\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc != -ELOOP)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (rc && ref_walk_descend(rw));\n\nout:\n\tfree_dfs_info_param(&tgt);\n\treturn rc;\n}\n\nstatic int dfs_referral_walk(struct cifs_mount_ctx *mnt_ctx)\n{\n\tstruct dfs_ref_walk *rw;\n\tint rc;\n\n\trw = ref_walk_alloc();\n\tif (IS_ERR(rw))\n\t\treturn PTR_ERR(rw);\n\n\tref_walk_init(rw);\n\trc = set_ref_paths(mnt_ctx, NULL, rw);\n\tif (!rc)\n\t\trc = __dfs_referral_walk(mnt_ctx, rw);\n\tref_walk_free(rw);\n\treturn rc;\n}\n\nstatic int __dfs_mount_share(struct cifs_mount_ctx *mnt_ctx)\n{\n\tstruct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tstruct cifs_tcon *tcon;\n\tchar *origin_fullpath;\n\tint rc;\n\n\torigin_fullpath = dfs_get_path(cifs_sb, ctx->source);\n\tif (IS_ERR(origin_fullpath))\n\t\treturn PTR_ERR(origin_fullpath);\n\n\trc = dfs_referral_walk(mnt_ctx);\n\tif (rc)\n\t\tgoto out;\n\n\ttcon = mnt_ctx->tcon;\n\tspin_lock(&tcon->tc_lock);\n\tif (!tcon->origin_fullpath) {\n\t\ttcon->origin_fullpath = origin_fullpath;\n\t\torigin_fullpath = NULL;\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\n\tif (list_empty(&tcon->dfs_ses_list)) {\n\t\tlist_replace_init(&mnt_ctx->dfs_ses_list, &tcon->dfs_ses_list);\n\t\tqueue_delayed_work(dfscache_wq, &tcon->dfs_cache_work,\n\t\t\t\t   dfs_cache_get_ttl() * HZ);\n\t} else {\n\t\tdfs_put_root_smb_sessions(&mnt_ctx->dfs_ses_list);\n\t}\n\nout:\n\tkfree(origin_fullpath);\n\treturn rc;\n}\n\n \nstatic int update_fs_context_dstaddr(struct smb3_fs_context *ctx)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&ctx->dstaddr;\n\tint rc = 0;\n\n\tif (!ctx->nodfs && ctx->dfs_automount) {\n\t\trc = dns_resolve_server_name_to_ip(ctx->source, addr, NULL);\n\t\tif (!rc)\n\t\t\tcifs_set_port(addr, ctx->port);\n\t\tctx->dfs_automount = false;\n\t}\n\treturn rc;\n}\n\nint dfs_mount_share(struct cifs_mount_ctx *mnt_ctx, bool *isdfs)\n{\n\tstruct smb3_fs_context *ctx = mnt_ctx->fs_ctx;\n\tbool nodfs = ctx->nodfs;\n\tint rc;\n\n\trc = update_fs_context_dstaddr(ctx);\n\tif (rc)\n\t\treturn rc;\n\n\t*isdfs = false;\n\trc = get_session(mnt_ctx, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tctx->dfs_root_ses = mnt_ctx->ses;\n\t \n\tif (!nodfs) {\n\t\trc = dfs_get_referral(mnt_ctx, ctx->UNC + 1, NULL, NULL);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: no dfs referral for %s: %d\\n\",\n\t\t\t\t __func__, ctx->UNC + 1, rc);\n\t\t\tcifs_dbg(FYI, \"%s: assuming non-dfs mount...\\n\", __func__);\n\t\t\tnodfs = true;\n\t\t}\n\t}\n\tif (nodfs) {\n\t\trc = cifs_mount_get_tcon(mnt_ctx);\n\t\tif (!rc)\n\t\t\trc = cifs_is_path_remote(mnt_ctx);\n\t\treturn rc;\n\t}\n\n\t*isdfs = true;\n\tadd_root_smb_session(mnt_ctx);\n\treturn __dfs_mount_share(mnt_ctx);\n}\n\n \nstatic int update_server_fullpath(struct TCP_Server_Info *server, struct cifs_sb_info *cifs_sb,\n\t\t\t\t  const char *target)\n{\n\tint rc = 0;\n\tsize_t len = strlen(target);\n\tchar *refpath, *npath;\n\n\tif (unlikely(len < 2 || *target != '\\\\'))\n\t\treturn -EINVAL;\n\n\tif (target[1] == '\\\\') {\n\t\tlen += 1;\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"%s\", target);\n\t} else {\n\t\tlen += sizeof(\"\\\\\");\n\t\trefpath = kmalloc(len, GFP_KERNEL);\n\t\tif (!refpath)\n\t\t\treturn -ENOMEM;\n\n\t\tscnprintf(refpath, len, \"\\\\%s\", target);\n\t}\n\n\tnpath = dfs_cache_canonical_path(refpath, cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(refpath);\n\n\tif (IS_ERR(npath)) {\n\t\trc = PTR_ERR(npath);\n\t} else {\n\t\tmutex_lock(&server->refpath_lock);\n\t\tspin_lock(&server->srv_lock);\n\t\tkfree(server->leaf_fullpath);\n\t\tserver->leaf_fullpath = npath;\n\t\tspin_unlock(&server->srv_lock);\n\t\tmutex_unlock(&server->refpath_lock);\n\t}\n\treturn rc;\n}\n\nstatic int target_share_matches_server(struct TCP_Server_Info *server, char *share,\n\t\t\t\t       bool *target_match)\n{\n\tint rc = 0;\n\tconst char *dfs_host;\n\tsize_t dfs_host_len;\n\n\t*target_match = true;\n\textract_unc_hostname(share, &dfs_host, &dfs_host_len);\n\n\t \n\tcifs_server_lock(server);\n\tif (dfs_host_len != strlen(server->hostname) ||\n\t    strncasecmp(dfs_host, server->hostname, dfs_host_len)) {\n\t\tcifs_dbg(FYI, \"%s: %.*s doesn't match %s\\n\", __func__,\n\t\t\t (int)dfs_host_len, dfs_host, server->hostname);\n\t\trc = match_target_ip(server, dfs_host, dfs_host_len, target_match);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: failed to match target ip: %d\\n\", __func__, rc);\n\t}\n\tcifs_server_unlock(server);\n\treturn rc;\n}\n\nstatic void __tree_connect_ipc(const unsigned int xid, char *tree,\n\t\t\t       struct cifs_sb_info *cifs_sb,\n\t\t\t       struct cifs_ses *ses)\n{\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct cifs_tcon *tcon = ses->tcon_ipc;\n\tint rc;\n\n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\tif (cifs_chan_needs_reconnect(ses, server) ||\n\t    ses->ses_status != SES_GOOD) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\tcifs_server_dbg(FYI, \"%s: skipping ipc reconnect due to disconnected ses\\n\",\n\t\t\t\t__func__);\n\t\treturn;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\n\tcifs_server_lock(server);\n\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\tcifs_server_unlock(server);\n\n\trc = server->ops->tree_connect(xid, ses, tree, tcon,\n\t\t\t\t       cifs_sb->local_nls);\n\tcifs_server_dbg(FYI, \"%s: tree_reconnect %s: %d\\n\", __func__, tree, rc);\n\tspin_lock(&tcon->tc_lock);\n\tif (rc) {\n\t\ttcon->status = TID_NEED_TCON;\n\t} else {\n\t\ttcon->status = TID_GOOD;\n\t\ttcon->need_reconnect = false;\n\t}\n\tspin_unlock(&tcon->tc_lock);\n}\n\nstatic void tree_connect_ipc(const unsigned int xid, char *tree,\n\t\t\t     struct cifs_sb_info *cifs_sb,\n\t\t\t     struct cifs_tcon *tcon)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\n\t__tree_connect_ipc(xid, tree, cifs_sb, ses);\n\t__tree_connect_ipc(xid, tree, cifs_sb, CIFS_DFS_ROOT_SES(ses));\n}\n\nstatic int __tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t     struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t     struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tstruct cifs_ses *root_ses = CIFS_DFS_ROOT_SES(tcon->ses);\n\tchar *share = NULL, *prefix = NULL;\n\tstruct dfs_cache_tgt_iterator *tit;\n\tbool target_match;\n\n\ttit = dfs_cache_get_tgt_iterator(tl);\n\tif (!tit) {\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (; tit; tit = dfs_cache_get_next_tgt(tl, tit)) {\n\t\tconst char *target = dfs_cache_get_tgt_name(tit);\n\t\tDFS_CACHE_TGT_LIST(ntl);\n\n\t\tkfree(share);\n\t\tkfree(prefix);\n\t\tshare = prefix = NULL;\n\n\t\t \n\t\trc = dfs_cache_get_tgt_share(server->leaf_fullpath + 1, tit, &share, &prefix);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: failed to parse target share: %d\\n\", __func__, rc);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = target_share_matches_server(server, share, &target_match);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (!target_match) {\n\t\t\trc = -EHOSTUNREACH;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs_cache_noreq_update_tgthint(server->leaf_fullpath + 1, tit);\n\t\ttree_connect_ipc(xid, tree, cifs_sb, tcon);\n\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\%s\", share);\n\t\tif (!islink) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dfs_cache_find(xid, root_ses, cifs_sb->local_nls, cifs_remap(cifs_sb), target,\n\t\t\t\t   NULL, &ntl)) {\n\t\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, cifs_sb->local_nls);\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\n\t\t\trc = cifs_update_super_prepath(cifs_sb, prefix);\n\t\t} else {\n\t\t\t \n\t\t\trc = update_server_fullpath(server, cifs_sb, target);\n\t\t\tdfs_cache_free_tgts(tl);\n\n\t\t\tif (!rc) {\n\t\t\t\trc = -EREMOTE;\n\t\t\t\tlist_replace_init(&ntl.tl_list, &tl->tl_list);\n\t\t\t} else\n\t\t\t\tdfs_cache_free_tgts(&ntl);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tkfree(share);\n\tkfree(prefix);\n\n\treturn rc;\n}\n\nstatic int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb, char *tree, bool islink,\n\t\t\t\t   struct dfs_cache_tgt_list *tl)\n{\n\tint rc;\n\tint num_links = 0;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tchar *old_fullpath = server->leaf_fullpath;\n\n\tdo {\n\t\trc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);\n\t\tif (!rc || rc != -EREMOTE)\n\t\t\tbreak;\n\t} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);\n\t \n\tif (rc && server->leaf_fullpath != old_fullpath)\n\t\tcifs_signal_cifsd_for_reconnect(server, true);\n\n\tdfs_cache_free_tgts(tl);\n\treturn rc;\n}\n\nint cifs_tree_connect(const unsigned int xid, struct cifs_tcon *tcon, const struct nls_table *nlsc)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tconst struct smb_version_operations *ops = server->ops;\n\tDFS_CACHE_TGT_LIST(tl);\n\tstruct cifs_sb_info *cifs_sb = NULL;\n\tstruct super_block *sb = NULL;\n\tstruct dfs_info3_param ref = {0};\n\tchar *tree;\n\n\t \n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status == TID_GOOD) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn 0;\n\t}\n\n\tif (tcon->status != TID_NEW &&\n\t    tcon->status != TID_NEED_TCON) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn -EHOSTDOWN;\n\t}\n\n\ttcon->status = TID_IN_TCON;\n\tspin_unlock(&tcon->tc_lock);\n\n\ttree = kzalloc(MAX_TREE_SIZE, GFP_KERNEL);\n\tif (!tree) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->ipc) {\n\t\tcifs_server_lock(server);\n\t\tscnprintf(tree, MAX_TREE_SIZE, \"\\\\\\\\%s\\\\IPC$\", server->hostname);\n\t\tcifs_server_unlock(server);\n\t\trc = ops->tree_connect(xid, tcon->ses, tree, tcon, nlsc);\n\t\tgoto out;\n\t}\n\n\tsb = cifs_get_dfs_tcon_super(tcon);\n\tif (!IS_ERR(sb))\n\t\tcifs_sb = CIFS_SB(sb);\n\n\t \n\tif (!cifs_sb || !server->leaf_fullpath ||\n\t    dfs_cache_noreq_find(server->leaf_fullpath + 1, &ref, &tl)) {\n\t\trc = ops->tree_connect(xid, tcon->ses, tcon->tree_name, tcon,\n\t\t\t\t       cifs_sb ? cifs_sb->local_nls : nlsc);\n\t\tgoto out;\n\t}\n\n\trc = tree_connect_dfs_target(xid, tcon, cifs_sb, tree, ref.server_type == DFS_TYPE_LINK,\n\t\t\t\t     &tl);\n\tfree_dfs_info_param(&ref);\n\nout:\n\tkfree(tree);\n\tcifs_put_tcp_super(sb);\n\n\tif (rc) {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_NEED_TCON;\n\t\tspin_unlock(&tcon->tc_lock);\n\t} else {\n\t\tspin_lock(&tcon->tc_lock);\n\t\tif (tcon->status == TID_IN_TCON)\n\t\t\ttcon->status = TID_GOOD;\n\t\tspin_unlock(&tcon->tc_lock);\n\t\ttcon->need_reconnect = false;\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}