{
  "module_name": "xattr.c",
  "hash_id": "a4d81793b3943ca4d7b28de1560545353f0baeddb454c99d162602c79e65e506",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/xattr.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_ioctl.h\"\n\n#define MAX_EA_VALUE_SIZE CIFSMaxBufSize\n#define CIFS_XATTR_CIFS_ACL \"system.cifs_acl\"  \n#define CIFS_XATTR_CIFS_NTSD \"system.cifs_ntsd\"  \n#define CIFS_XATTR_CIFS_NTSD_FULL \"system.cifs_ntsd_full\"  \n#define CIFS_XATTR_ATTRIB \"cifs.dosattrib\"   \n#define CIFS_XATTR_CREATETIME \"cifs.creationtime\"   \n \n#define SMB3_XATTR_CIFS_ACL \"system.smb3_acl\"  \n#define SMB3_XATTR_CIFS_NTSD \"system.smb3_ntsd\"  \n#define SMB3_XATTR_CIFS_NTSD_FULL \"system.smb3_ntsd_full\"  \n#define SMB3_XATTR_ATTRIB \"smb3.dosattrib\"   \n#define SMB3_XATTR_CREATETIME \"smb3.creationtime\"   \n \n\nenum { XATTR_USER, XATTR_CIFS_ACL, XATTR_ACL_ACCESS, XATTR_ACL_DEFAULT,\n\tXATTR_CIFS_NTSD, XATTR_CIFS_NTSD_FULL };\n\nstatic int cifs_attrib_set(unsigned int xid, struct cifs_tcon *pTcon,\n\t\t\t   struct inode *inode, const char *full_path,\n\t\t\t   const void *value, size_t size)\n{\n\tssize_t rc = -EOPNOTSUPP;\n\t__u32 *pattrib = (__u32 *)value;\n\t__u32 attrib;\n\tFILE_BASIC_INFO info_buf;\n\n\tif ((value == NULL) || (size != sizeof(__u32)))\n\t\treturn -ERANGE;\n\n\tmemset(&info_buf, 0, sizeof(info_buf));\n\tattrib = *pattrib;\n\tinfo_buf.Attributes = cpu_to_le32(attrib);\n\tif (pTcon->ses->server->ops->set_file_info)\n\t\trc = pTcon->ses->server->ops->set_file_info(inode, full_path,\n\t\t\t\t&info_buf, xid);\n\tif (rc == 0)\n\t\tCIFS_I(inode)->cifsAttrs = attrib;\n\n\treturn rc;\n}\n\nstatic int cifs_creation_time_set(unsigned int xid, struct cifs_tcon *pTcon,\n\t\t\t\t  struct inode *inode, const char *full_path,\n\t\t\t\t  const void *value, size_t size)\n{\n\tssize_t rc = -EOPNOTSUPP;\n\t__u64 *pcreation_time = (__u64 *)value;\n\t__u64 creation_time;\n\tFILE_BASIC_INFO info_buf;\n\n\tif ((value == NULL) || (size != sizeof(__u64)))\n\t\treturn -ERANGE;\n\n\tmemset(&info_buf, 0, sizeof(info_buf));\n\tcreation_time = *pcreation_time;\n\tinfo_buf.CreationTime = cpu_to_le64(creation_time);\n\tif (pTcon->ses->server->ops->set_file_info)\n\t\trc = pTcon->ses->server->ops->set_file_info(inode, full_path,\n\t\t\t\t&info_buf, xid);\n\tif (rc == 0)\n\t\tCIFS_I(inode)->createtime = creation_time;\n\n\treturn rc;\n}\n\nstatic int cifs_xattr_set(const struct xattr_handler *handler,\n\t\t\t  struct mnt_idmap *idmap,\n\t\t\t  struct dentry *dentry, struct inode *inode,\n\t\t\t  const char *name, const void *value,\n\t\t\t  size_t size, int flags)\n{\n\tint rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\tpTcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\t \n\t \n\n\t \n\tif (size > MAX_EA_VALUE_SIZE) {\n\t\tcifs_dbg(FYI, \"size of EA value too large\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tswitch (handler->flags) {\n\tcase XATTR_USER:\n\t\tcifs_dbg(FYI, \"%s:setting user xattr %s\\n\", __func__, name);\n\t\tif ((strcmp(name, CIFS_XATTR_ATTRIB) == 0) ||\n\t\t    (strcmp(name, SMB3_XATTR_ATTRIB) == 0)) {\n\t\t\trc = cifs_attrib_set(xid, pTcon, inode, full_path,\n\t\t\t\t\tvalue, size);\n\t\t\tif (rc == 0)  \n\t\t\t\tCIFS_I(inode)->time = 0;\n\t\t\tbreak;\n\t\t} else if ((strcmp(name, CIFS_XATTR_CREATETIME) == 0) ||\n\t\t\t   (strcmp(name, SMB3_XATTR_CREATETIME) == 0)) {\n\t\t\trc = cifs_creation_time_set(xid, pTcon, inode,\n\t\t\t\t\tfull_path, value, size);\n\t\t\tif (rc == 0)  \n\t\t\t\tCIFS_I(inode)->time = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\t\tgoto out;\n\n\t\tif (pTcon->ses->server->ops->set_EA) {\n\t\t\trc = pTcon->ses->server->ops->set_EA(xid, pTcon,\n\t\t\t\tfull_path, name, value, (__u16)size,\n\t\t\t\tcifs_sb->local_nls, cifs_sb);\n\t\t\tif (rc == 0)\n\t\t\t\tinode_set_ctime_current(inode);\n\t\t}\n\t\tbreak;\n\n\tcase XATTR_CIFS_ACL:\n\tcase XATTR_CIFS_NTSD:\n\tcase XATTR_CIFS_NTSD_FULL: {\n\t\tstruct cifs_ntsd *pacl;\n\n\t\tif (!value)\n\t\t\tgoto out;\n\t\tpacl = kmalloc(size, GFP_KERNEL);\n\t\tif (!pacl) {\n\t\t\trc = -ENOMEM;\n\t\t} else {\n\t\t\tmemcpy(pacl, value, size);\n\t\t\tif (pTcon->ses->server->ops->set_acl) {\n\t\t\t\tint aclflags = 0;\n\t\t\t\trc = 0;\n\n\t\t\t\tswitch (handler->flags) {\n\t\t\t\tcase XATTR_CIFS_NTSD_FULL:\n\t\t\t\t\taclflags = (CIFS_ACL_OWNER |\n\t\t\t\t\t\t    CIFS_ACL_GROUP |\n\t\t\t\t\t\t    CIFS_ACL_DACL |\n\t\t\t\t\t\t    CIFS_ACL_SACL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase XATTR_CIFS_NTSD:\n\t\t\t\t\taclflags = (CIFS_ACL_OWNER |\n\t\t\t\t\t\t    CIFS_ACL_GROUP |\n\t\t\t\t\t\t    CIFS_ACL_DACL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase XATTR_CIFS_ACL:\n\t\t\t\tdefault:\n\t\t\t\t\taclflags = CIFS_ACL_DACL;\n\t\t\t\t}\n\n\t\t\t\trc = pTcon->ses->server->ops->set_acl(pacl,\n\t\t\t\t\tsize, inode, full_path, aclflags);\n\t\t\t} else {\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (rc == 0)  \n\t\t\t\tCIFS_I(inode)->time = 0;\n\t\t\tkfree(pacl);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int cifs_attrib_get(struct dentry *dentry,\n\t\t\t   struct inode *inode, void *value,\n\t\t\t   size_t size)\n{\n\tssize_t rc;\n\t__u32 *pattribute;\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif ((value == NULL) || (size == 0))\n\t\treturn sizeof(__u32);\n\telse if (size < sizeof(__u32))\n\t\treturn -ERANGE;\n\n\t \n\tpattribute = (__u32 *)value;\n\t*pattribute = CIFS_I(inode)->cifsAttrs;\n\n\treturn sizeof(__u32);\n}\n\nstatic int cifs_creation_time_get(struct dentry *dentry, struct inode *inode,\n\t\t\t\t  void *value, size_t size)\n{\n\tssize_t rc;\n\t__u64 *pcreatetime;\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((value == NULL) || (size == 0))\n\t\treturn sizeof(__u64);\n\telse if (size < sizeof(__u64))\n\t\treturn -ERANGE;\n\n\t \n\tpcreatetime = (__u64 *)value;\n\t*pcreatetime = CIFS_I(inode)->createtime;\n\treturn sizeof(__u64);\n}\n\n\nstatic int cifs_xattr_get(const struct xattr_handler *handler,\n\t\t\t  struct dentry *dentry, struct inode *inode,\n\t\t\t  const char *name, void *value, size_t size)\n{\n\tssize_t rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\tpTcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (handler->flags) {\n\tcase XATTR_USER:\n\t\tcifs_dbg(FYI, \"%s:querying user xattr %s\\n\", __func__, name);\n\t\tif ((strcmp(name, CIFS_XATTR_ATTRIB) == 0) ||\n\t\t    (strcmp(name, SMB3_XATTR_ATTRIB) == 0)) {\n\t\t\trc = cifs_attrib_get(dentry, inode, value, size);\n\t\t\tbreak;\n\t\t} else if ((strcmp(name, CIFS_XATTR_CREATETIME) == 0) ||\n\t\t    (strcmp(name, SMB3_XATTR_CREATETIME) == 0)) {\n\t\t\trc = cifs_creation_time_get(dentry, inode, value, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\t\tgoto out;\n\n\t\tif (pTcon->ses->server->ops->query_all_EAs)\n\t\t\trc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,\n\t\t\t\tfull_path, name, value, size, cifs_sb);\n\t\tbreak;\n\n\tcase XATTR_CIFS_ACL:\n\tcase XATTR_CIFS_NTSD:\n\tcase XATTR_CIFS_NTSD_FULL: {\n\t\t \n\t\tu32 acllen, extra_info;\n\t\tstruct cifs_ntsd *pacl;\n\n\t\tif (pTcon->ses->server->ops->get_acl == NULL)\n\t\t\tgoto out;  \n\n\t\tif (handler->flags == XATTR_CIFS_NTSD_FULL) {\n\t\t\textra_info = SACL_SECINFO;\n\t\t} else {\n\t\t\textra_info = 0;\n\t\t}\n\t\tpacl = pTcon->ses->server->ops->get_acl(cifs_sb,\n\t\t\t\tinode, full_path, &acllen, extra_info);\n\t\tif (IS_ERR(pacl)) {\n\t\t\trc = PTR_ERR(pacl);\n\t\t\tcifs_dbg(VFS, \"%s: error %zd getting sec desc\\n\",\n\t\t\t\t __func__, rc);\n\t\t} else {\n\t\t\tif (value) {\n\t\t\t\tif (acllen > size)\n\t\t\t\t\tacllen = -ERANGE;\n\t\t\t\telse\n\t\t\t\t\tmemcpy(value, pacl, acllen);\n\t\t\t}\n\t\t\trc = acllen;\n\t\t\tkfree(pacl);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\t \n\n\tif (rc == -EINVAL)\n\t\trc = -EOPNOTSUPP;\n\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nssize_t cifs_listxattr(struct dentry *direntry, char *data, size_t buf_size)\n{\n\tssize_t rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\treturn -EOPNOTSUPP;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\tpTcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto list_ea_exit;\n\t}\n\t \n\t \n\n\t \n\n\tif (pTcon->ses->server->ops->query_all_EAs)\n\t\trc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,\n\t\t\t\tfull_path, NULL, data, buf_size, cifs_sb);\nlist_ea_exit:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic const struct xattr_handler cifs_user_xattr_handler = {\n\t.prefix = XATTR_USER_PREFIX,\n\t.flags = XATTR_USER,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\n \nstatic const struct xattr_handler cifs_os2_xattr_handler = {\n\t.prefix = XATTR_OS2_PREFIX,\n\t.flags = XATTR_USER,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\nstatic const struct xattr_handler cifs_cifs_acl_xattr_handler = {\n\t.name = CIFS_XATTR_CIFS_ACL,\n\t.flags = XATTR_CIFS_ACL,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\n \nstatic const struct xattr_handler smb3_acl_xattr_handler = {\n\t.name = SMB3_XATTR_CIFS_ACL,\n\t.flags = XATTR_CIFS_ACL,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\nstatic const struct xattr_handler cifs_cifs_ntsd_xattr_handler = {\n\t.name = CIFS_XATTR_CIFS_NTSD,\n\t.flags = XATTR_CIFS_NTSD,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\n \nstatic const struct xattr_handler smb3_ntsd_xattr_handler = {\n\t.name = SMB3_XATTR_CIFS_NTSD,\n\t.flags = XATTR_CIFS_NTSD,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\nstatic const struct xattr_handler cifs_cifs_ntsd_full_xattr_handler = {\n\t.name = CIFS_XATTR_CIFS_NTSD_FULL,\n\t.flags = XATTR_CIFS_NTSD_FULL,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\n \nstatic const struct xattr_handler smb3_ntsd_full_xattr_handler = {\n\t.name = SMB3_XATTR_CIFS_NTSD_FULL,\n\t.flags = XATTR_CIFS_NTSD_FULL,\n\t.get = cifs_xattr_get,\n\t.set = cifs_xattr_set,\n};\n\nconst struct xattr_handler *cifs_xattr_handlers[] = {\n\t&cifs_user_xattr_handler,\n\t&cifs_os2_xattr_handler,\n\t&cifs_cifs_acl_xattr_handler,\n\t&smb3_acl_xattr_handler,  \n\t&cifs_cifs_ntsd_xattr_handler,\n\t&smb3_ntsd_xattr_handler,  \n\t&cifs_cifs_ntsd_full_xattr_handler,\n\t&smb3_ntsd_full_xattr_handler,  \n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}