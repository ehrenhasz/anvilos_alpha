{
  "module_name": "cifsglob.h",
  "hash_id": "d08c6fe42d511cb4c18d51cdf81b9e32806ee7b3c54e9a3872f42ce339cba86c",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifsglob.h",
  "human_readable_source": " \n \n#ifndef _CIFS_GLOB_H\n#define _CIFS_GLOB_H\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/mm.h>\n#include <linux/mempool.h>\n#include <linux/workqueue.h>\n#include <linux/utsname.h>\n#include <linux/sched/mm.h>\n#include <linux/netfs.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifsacl.h\"\n#include <crypto/internal/hash.h>\n#include <uapi/linux/cifs/cifs_mount.h>\n#include \"../common/smb2pdu.h\"\n#include \"smb2pdu.h\"\n#include <linux/filelock.h>\n\n#define SMB_PATH_MAX 260\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\n \n#define MAX_UID_INFO 16\n#define MAX_SES_INFO 2\n#define MAX_TCON_INFO 4\n\n#define MAX_TREE_SIZE (2 + CIFS_NI_MAXHOST + 1 + CIFS_MAX_SHARE_LEN + 1)\n\n#define CIFS_MIN_RCV_POOL 4\n\n#define MAX_REOPEN_ATT\t5  \n \n#define CIFS_DEF_ACTIMEO (1 * HZ)\n\n \n#define CIFS_MAX_ACTIMEO (1 << 30)\n\n \n#define SMB3_MAX_HANDLE_TIMEOUT 960000\n\n \n#define CIFS_MAX_REQ 32767\n\n#define RFC1001_NAME_LEN 15\n#define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)\n\n \n#define SERVER_NAME_LENGTH 80\n#define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)\n\n \n#define SMB_ECHO_INTERVAL_MIN 1\n#define SMB_ECHO_INTERVAL_MAX 600\n#define SMB_ECHO_INTERVAL_DEFAULT 60\n\n \n#define SMB_INTERFACE_POLL_INTERVAL\t600\n\n \n#define MAX_COMPOUND 5\n\n \n#define SMB2_MAX_CREDITS_AVAILABLE 32000\n\n#include \"cifspdu.h\"\n\n#ifndef XATTR_DOS_ATTRIB\n#define XATTR_DOS_ATTRIB \"user.DOSATTRIB\"\n#endif\n\n#define CIFS_MAX_WORKSTATION_LEN  (__NEW_UTS_LEN + 1)   \n\n#define CIFS_DFS_ROOT_SES(ses) ((ses)->dfs_root_ses ?: (ses))\n\n \n\n \nenum statusEnum {\n\tCifsNew = 0,\n\tCifsGood,\n\tCifsExiting,\n\tCifsNeedReconnect,\n\tCifsNeedNegotiate,\n\tCifsInNegotiate,\n};\n\n \nenum ses_status_enum {\n\tSES_NEW = 0,\n\tSES_GOOD,\n\tSES_EXITING,\n\tSES_NEED_RECON,\n\tSES_IN_SETUP\n};\n\n \nenum tid_status_enum {\n\tTID_NEW = 0,\n\tTID_GOOD,\n\tTID_EXITING,\n\tTID_NEED_RECON,\n\tTID_NEED_TCON,\n\tTID_IN_TCON,\n\tTID_NEED_FILES_INVALIDATE,  \n\tTID_IN_FILES_INVALIDATE\n};\n\nenum securityEnum {\n\tUnspecified = 0,\t \n\tNTLMv2,\t\t\t \n\tRawNTLMSSP,\t\t \n\tKerberos,\t\t \n};\n\nstruct session_key {\n\tunsigned int len;\n\tchar *response;\n};\n\n \nstruct cifs_secmech {\n\tstruct shash_desc *hmacmd5;  \n\tstruct shash_desc *md5;  \n\tstruct shash_desc *hmacsha256;  \n\tstruct shash_desc *sha512;  \n\tstruct shash_desc *aes_cmac;  \n\n\tstruct crypto_aead *enc;  \n\tstruct crypto_aead *dec;  \n};\n\n \nstruct ntlmssp_auth {\n\tbool sesskey_per_smbsess;  \n\t__u32 client_flags;  \n\t__u32 server_flags;  \n\tunsigned char ciphertext[CIFS_CPHTXT_SIZE];  \n\tchar cryptkey[CIFS_CRYPTO_KEY_SIZE];  \n};\n\nstruct cifs_cred {\n\tint uid;\n\tint gid;\n\tint mode;\n\tint cecount;\n\tstruct cifs_sid osid;\n\tstruct cifs_sid gsid;\n\tstruct cifs_ntace *ntaces;\n\tstruct cifs_ace *aces;\n};\n\nstruct cifs_open_info_data {\n\tbool adjust_tz;\n\tunion {\n\t\tbool reparse_point;\n\t\tbool symlink;\n\t};\n\tstruct {\n\t\t__u32 tag;\n\t\tunion {\n\t\t\tstruct reparse_data_buffer *buf;\n\t\t\tstruct reparse_posix_data *posix;\n\t\t};\n\t} reparse;\n\tchar *symlink_target;\n\tunion {\n\t\tstruct smb2_file_all_info fi;\n\t\tstruct smb311_posix_qinfo posix_fi;\n\t};\n};\n\n#define cifs_open_data_reparse(d) \\\n\t((d)->reparse_point || \\\n\t (le32_to_cpu((d)->fi.Attributes) & ATTR_REPARSE))\n\nstatic inline void cifs_free_open_info(struct cifs_open_info_data *data)\n{\n\tkfree(data->symlink_target);\n}\n\n \n\n \nstruct smb_rqst {\n\tstruct kvec\t*rq_iov;\t \n\tunsigned int\trq_nvec;\t \n\tsize_t\t\trq_iter_size;\t \n\tstruct iov_iter\trq_iter;\t \n\tstruct xarray\trq_buffer;\t \n};\n\nstruct mid_q_entry;\nstruct TCP_Server_Info;\nstruct cifsFileInfo;\nstruct cifs_ses;\nstruct cifs_tcon;\nstruct dfs_info3_param;\nstruct cifs_fattr;\nstruct smb3_fs_context;\nstruct cifs_fid;\nstruct cifs_readdata;\nstruct cifs_writedata;\nstruct cifs_io_parms;\nstruct cifs_search_info;\nstruct cifsInodeInfo;\nstruct cifs_open_parms;\nstruct cifs_credits;\n\nstruct smb_version_operations {\n\tint (*send_cancel)(struct TCP_Server_Info *, struct smb_rqst *,\n\t\t\t   struct mid_q_entry *);\n\tbool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);\n\t \n\tstruct mid_q_entry *(*setup_request)(struct cifs_ses *,\n\t\t\t\t\t     struct TCP_Server_Info *,\n\t\t\t\t\t     struct smb_rqst *);\n\t \n\tstruct mid_q_entry *(*setup_async_request)(struct TCP_Server_Info *,\n\t\t\t\t\t\tstruct smb_rqst *);\n\t \n\tint (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,\n\t\t\t     bool);\n\tvoid (*add_credits)(struct TCP_Server_Info *server,\n\t\t\t    const struct cifs_credits *credits,\n\t\t\t    const int optype);\n\tvoid (*set_credits)(struct TCP_Server_Info *, const int);\n\tint * (*get_credits_field)(struct TCP_Server_Info *, const int);\n\tunsigned int (*get_credits)(struct mid_q_entry *);\n\t__u64 (*get_next_mid)(struct TCP_Server_Info *);\n\tvoid (*revert_current_mid)(struct TCP_Server_Info *server,\n\t\t\t\t   const unsigned int val);\n\t \n\tunsigned int (*read_data_offset)(char *);\n\t \n\tunsigned int (*read_data_length)(char *, bool in_remaining);\n\t \n\tint (*map_error)(char *, bool);\n\t \n\tstruct mid_q_entry * (*find_mid)(struct TCP_Server_Info *, char *);\n\tvoid (*dump_detail)(void *buf, struct TCP_Server_Info *ptcp_info);\n\tvoid (*clear_stats)(struct cifs_tcon *);\n\tvoid (*print_stats)(struct seq_file *m, struct cifs_tcon *);\n\tvoid (*dump_share_caps)(struct seq_file *, struct cifs_tcon *);\n\t \n\tint (*check_message)(char *, unsigned int, struct TCP_Server_Info *);\n\tbool (*is_oplock_break)(char *, struct TCP_Server_Info *);\n\tint (*handle_cancelled_mid)(struct mid_q_entry *, struct TCP_Server_Info *);\n\tvoid (*downgrade_oplock)(struct TCP_Server_Info *server,\n\t\t\t\t struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t\t\t unsigned int epoch, bool *purge_cache);\n\t \n\tbool (*check_trans2)(struct mid_q_entry *, struct TCP_Server_Info *,\n\t\t\t     char *, int);\n\t \n\tbool (*need_neg)(struct TCP_Server_Info *);\n\t \n\tint (*negotiate)(const unsigned int xid,\n\t\t\t struct cifs_ses *ses,\n\t\t\t struct TCP_Server_Info *server);\n\t \n\tunsigned int (*negotiate_wsize)(struct cifs_tcon *tcon, struct smb3_fs_context *ctx);\n\t \n\tunsigned int (*negotiate_rsize)(struct cifs_tcon *tcon, struct smb3_fs_context *ctx);\n\t \n\tint (*sess_setup)(const unsigned int, struct cifs_ses *,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  const struct nls_table *);\n\t \n\tint (*logoff)(const unsigned int, struct cifs_ses *);\n\t \n\tint (*tree_connect)(const unsigned int, struct cifs_ses *, const char *,\n\t\t\t    struct cifs_tcon *, const struct nls_table *);\n\t \n\tint (*tree_disconnect)(const unsigned int, struct cifs_tcon *);\n\t \n\tint (*get_dfs_refer)(const unsigned int, struct cifs_ses *,\n\t\t\t     const char *, struct dfs_info3_param **,\n\t\t\t     unsigned int *, const struct nls_table *, int);\n\t \n\tvoid (*qfs_tcon)(const unsigned int, struct cifs_tcon *,\n\t\t\t struct cifs_sb_info *);\n\t \n\tint (*is_path_accessible)(const unsigned int, struct cifs_tcon *,\n\t\t\t\t  struct cifs_sb_info *, const char *);\n\t \n\tint (*query_path_info)(const unsigned int xid,\n\t\t\t       struct cifs_tcon *tcon,\n\t\t\t       struct cifs_sb_info *cifs_sb,\n\t\t\t       const char *full_path,\n\t\t\t       struct cifs_open_info_data *data);\n\t \n\tint (*query_file_info)(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t       struct cifsFileInfo *cfile, struct cifs_open_info_data *data);\n\t \n\tint (*query_reparse_point)(const unsigned int xid,\n\t\t\t\t   struct cifs_tcon *tcon,\n\t\t\t\t   struct cifs_sb_info *cifs_sb,\n\t\t\t\t   const char *full_path,\n\t\t\t\t   u32 *tag, struct kvec *rsp,\n\t\t\t\t   int *rsp_buftype);\n\t \n\tint (*get_srv_inum)(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t    struct cifs_sb_info *cifs_sb, const char *full_path, u64 *uniqueid,\n\t\t\t    struct cifs_open_info_data *data);\n\t \n\tint (*set_path_size)(const unsigned int, struct cifs_tcon *,\n\t\t\t     const char *, __u64, struct cifs_sb_info *, bool);\n\t \n\tint (*set_file_size)(const unsigned int, struct cifs_tcon *,\n\t\t\t     struct cifsFileInfo *, __u64, bool);\n\t \n\tint (*set_file_info)(struct inode *, const char *, FILE_BASIC_INFO *,\n\t\t\t     const unsigned int);\n\tint (*set_compression)(const unsigned int, struct cifs_tcon *,\n\t\t\t       struct cifsFileInfo *);\n\t \n\tbool (*can_echo)(struct TCP_Server_Info *);\n\t \n\tint (*echo)(struct TCP_Server_Info *);\n\t \n\tint (*posix_mkdir)(const unsigned int xid, struct inode *inode,\n\t\t\tumode_t mode, struct cifs_tcon *tcon,\n\t\t\tconst char *full_path,\n\t\t\tstruct cifs_sb_info *cifs_sb);\n\tint (*mkdir)(const unsigned int xid, struct inode *inode, umode_t mode,\n\t\t     struct cifs_tcon *tcon, const char *name,\n\t\t     struct cifs_sb_info *sb);\n\t \n\tvoid (*mkdir_setinfo)(struct inode *, const char *,\n\t\t\t      struct cifs_sb_info *, struct cifs_tcon *,\n\t\t\t      const unsigned int);\n\t \n\tint (*rmdir)(const unsigned int, struct cifs_tcon *, const char *,\n\t\t     struct cifs_sb_info *);\n\t \n\tint (*unlink)(const unsigned int, struct cifs_tcon *, const char *,\n\t\t      struct cifs_sb_info *);\n\t \n\tint (*rename_pending_delete)(const char *, struct dentry *,\n\t\t\t\t     const unsigned int);\n\t \n\tint (*rename)(const unsigned int, struct cifs_tcon *, const char *,\n\t\t      const char *, struct cifs_sb_info *);\n\t \n\tint (*create_hardlink)(const unsigned int, struct cifs_tcon *,\n\t\t\t       const char *, const char *,\n\t\t\t       struct cifs_sb_info *);\n\t \n\tint (*query_symlink)(const unsigned int xid,\n\t\t\t     struct cifs_tcon *tcon,\n\t\t\t     struct cifs_sb_info *cifs_sb,\n\t\t\t     const char *full_path,\n\t\t\t     char **target_path);\n\t \n\tint (*open)(const unsigned int xid, struct cifs_open_parms *oparms, __u32 *oplock,\n\t\t    void *buf);\n\t \n\tvoid (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);\n\t \n\tvoid (*close)(const unsigned int, struct cifs_tcon *,\n\t\t      struct cifs_fid *);\n\t \n\tvoid (*close_getattr)(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      struct cifsFileInfo *pfile_info);\n\t \n\tint (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);\n\t \n\tint (*async_readv)(struct cifs_readdata *);\n\t \n\tint (*async_writev)(struct cifs_writedata *,\n\t\t\t    void (*release)(struct kref *));\n\t \n\tint (*sync_read)(const unsigned int, struct cifs_fid *,\n\t\t\t struct cifs_io_parms *, unsigned int *, char **,\n\t\t\t int *);\n\t \n\tint (*sync_write)(const unsigned int, struct cifs_fid *,\n\t\t\t  struct cifs_io_parms *, unsigned int *, struct kvec *,\n\t\t\t  unsigned long);\n\t \n\tint (*query_dir_first)(const unsigned int, struct cifs_tcon *,\n\t\t\t       const char *, struct cifs_sb_info *,\n\t\t\t       struct cifs_fid *, __u16,\n\t\t\t       struct cifs_search_info *);\n\t \n\tint (*query_dir_next)(const unsigned int, struct cifs_tcon *,\n\t\t\t      struct cifs_fid *,\n\t\t\t      __u16, struct cifs_search_info *srch_inf);\n\t \n\tint (*close_dir)(const unsigned int, struct cifs_tcon *,\n\t\t\t struct cifs_fid *);\n\t \n\tunsigned int (*calc_smb_size)(void *buf);\n\t \n\tbool (*is_status_pending)(char *buf, struct TCP_Server_Info *server);\n\t \n\tbool (*is_session_expired)(char *);\n\t \n\tint (*oplock_response)(struct cifs_tcon *tcon, __u64 persistent_fid, __u64 volatile_fid,\n\t\t\t__u16 net_fid, struct cifsInodeInfo *cifs_inode);\n\t \n\tint (*queryfs)(const unsigned int, struct cifs_tcon *,\n\t\t       struct cifs_sb_info *, struct kstatfs *);\n\t \n\tint (*mand_lock)(const unsigned int, struct cifsFileInfo *, __u64,\n\t\t\t __u64, __u32, int, int, bool);\n\t \n\tint (*mand_unlock_range)(struct cifsFileInfo *, struct file_lock *,\n\t\t\t\t const unsigned int);\n\t \n\tint (*push_mand_locks)(struct cifsFileInfo *);\n\t \n\tvoid (*get_lease_key)(struct inode *, struct cifs_fid *);\n\t \n\tvoid (*set_lease_key)(struct inode *, struct cifs_fid *);\n\t \n\tvoid (*new_lease_key)(struct cifs_fid *);\n\tint (*generate_signingkey)(struct cifs_ses *ses,\n\t\t\t\t   struct TCP_Server_Info *server);\n\tint (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *,\n\t\t\t\tbool allocate_crypto);\n\tint (*set_integrity)(const unsigned int, struct cifs_tcon *tcon,\n\t\t\t     struct cifsFileInfo *src_file);\n\tint (*enum_snapshots)(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t     struct cifsFileInfo *src_file, void __user *);\n\tint (*notify)(const unsigned int xid, struct file *pfile,\n\t\t\t     void __user *pbuf, bool return_changes);\n\tint (*query_mf_symlink)(unsigned int, struct cifs_tcon *,\n\t\t\t\tstruct cifs_sb_info *, const unsigned char *,\n\t\t\t\tchar *, unsigned int *);\n\tint (*create_mf_symlink)(unsigned int, struct cifs_tcon *,\n\t\t\t\t struct cifs_sb_info *, const unsigned char *,\n\t\t\t\t char *, unsigned int *);\n\t \n\tbool (*is_read_op)(__u32);\n\t \n\tvoid (*set_oplock_level)(struct cifsInodeInfo *, __u32, unsigned int,\n\t\t\t\t bool *);\n\t \n\tchar * (*create_lease_buf)(u8 *lease_key, u8 oplock);\n\t \n\t__u8 (*parse_lease_buf)(void *buf, unsigned int *epoch, char *lkey);\n\tssize_t (*copychunk_range)(const unsigned int,\n\t\t\tstruct cifsFileInfo *src_file,\n\t\t\tstruct cifsFileInfo *target_file,\n\t\t\tu64 src_off, u64 len, u64 dest_off);\n\tint (*duplicate_extents)(const unsigned int, struct cifsFileInfo *src,\n\t\t\tstruct cifsFileInfo *target_file, u64 src_off, u64 len,\n\t\t\tu64 dest_off);\n\tint (*validate_negotiate)(const unsigned int, struct cifs_tcon *);\n\tssize_t (*query_all_EAs)(const unsigned int, struct cifs_tcon *,\n\t\t\tconst unsigned char *, const unsigned char *, char *,\n\t\t\tsize_t, struct cifs_sb_info *);\n\tint (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,\n\t\t\tconst char *, const void *, const __u16,\n\t\t\tconst struct nls_table *, struct cifs_sb_info *);\n\tstruct cifs_ntsd * (*get_acl)(struct cifs_sb_info *, struct inode *,\n\t\t\tconst char *, u32 *, u32);\n\tstruct cifs_ntsd * (*get_acl_by_fid)(struct cifs_sb_info *,\n\t\t\tconst struct cifs_fid *, u32 *, u32);\n\tint (*set_acl)(struct cifs_ntsd *, __u32, struct inode *, const char *,\n\t\t\tint);\n\t \n\tunsigned int (*wp_retry_size)(struct inode *);\n\t \n\tint (*wait_mtu_credits)(struct TCP_Server_Info *, unsigned int,\n\t\t\t\tunsigned int *, struct cifs_credits *);\n\t \n\tint (*adjust_credits)(struct TCP_Server_Info *server,\n\t\t\t      struct cifs_credits *credits,\n\t\t\t      const unsigned int payload_size);\n\t \n\tbool (*dir_needs_close)(struct cifsFileInfo *);\n\tlong (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,\n\t\t\t  loff_t);\n\t \n\tint (*init_transform_rq)(struct TCP_Server_Info *, int num_rqst,\n\t\t\t\t struct smb_rqst *, struct smb_rqst *);\n\tint (*is_transform_hdr)(void *buf);\n\tint (*receive_transform)(struct TCP_Server_Info *,\n\t\t\t\t struct mid_q_entry **, char **, int *);\n\tenum securityEnum (*select_sectype)(struct TCP_Server_Info *,\n\t\t\t    enum securityEnum);\n\tint (*next_header)(struct TCP_Server_Info *server, char *buf,\n\t\t\t   unsigned int *noff);\n\t \n\tint (*ioctl_query_info)(const unsigned int xid,\n\t\t\t\tstruct cifs_tcon *tcon,\n\t\t\t\tstruct cifs_sb_info *cifs_sb,\n\t\t\t\t__le16 *path, int is_dir,\n\t\t\t\tunsigned long p);\n\t \n\tint (*make_node)(unsigned int xid,\n\t\t\t struct inode *inode,\n\t\t\t struct dentry *dentry,\n\t\t\t struct cifs_tcon *tcon,\n\t\t\t const char *full_path,\n\t\t\t umode_t mode,\n\t\t\t dev_t device_number);\n\t \n\tint (*fiemap)(struct cifs_tcon *tcon, struct cifsFileInfo *,\n\t\t      struct fiemap_extent_info *, u64, u64);\n\t \n\tloff_t (*llseek)(struct file *, struct cifs_tcon *, loff_t, int);\n\t \n\tbool (*is_status_io_timeout)(char *buf);\n\t \n\tbool (*is_network_name_deleted)(char *buf, struct TCP_Server_Info *srv);\n\tint (*parse_reparse_point)(struct cifs_sb_info *cifs_sb,\n\t\t\t\t   struct kvec *rsp_iov,\n\t\t\t\t   struct cifs_open_info_data *data);\n};\n\nstruct smb_version_values {\n\tchar\t\t*version_string;\n\t__u16\t\tprotocol_id;\n\t__u32\t\treq_capabilities;\n\t__u32\t\tlarge_lock_type;\n\t__u32\t\texclusive_lock_type;\n\t__u32\t\tshared_lock_type;\n\t__u32\t\tunlock_lock_type;\n\tsize_t\t\theader_preamble_size;\n\tsize_t\t\theader_size;\n\tsize_t\t\tmax_header_size;\n\tsize_t\t\tread_rsp_size;\n\t__le16\t\tlock_cmd;\n\tunsigned int\tcap_unix;\n\tunsigned int\tcap_nt_find;\n\tunsigned int\tcap_large_files;\n\t__u16\t\tsigning_enabled;\n\t__u16\t\tsigning_required;\n\tsize_t\t\tcreate_lease_size;\n};\n\n#define HEADER_SIZE(server) (server->vals->header_size)\n#define MAX_HEADER_SIZE(server) (server->vals->max_header_size)\n#define HEADER_PREAMBLE_SIZE(server) (server->vals->header_preamble_size)\n#define MID_HEADER_SIZE(server) (HEADER_SIZE(server) - 1 - HEADER_PREAMBLE_SIZE(server))\n\n \n#define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \\\n\t\t\t CIFS_MOUNT_SERVER_INUM | CIFS_MOUNT_DIRECT_IO | \\\n\t\t\t CIFS_MOUNT_NO_XATTR | CIFS_MOUNT_MAP_SPECIAL_CHR | \\\n\t\t\t CIFS_MOUNT_MAP_SFM_CHR | \\\n\t\t\t CIFS_MOUNT_UNX_EMUL | CIFS_MOUNT_NO_BRL | \\\n\t\t\t CIFS_MOUNT_CIFS_ACL | CIFS_MOUNT_OVERR_UID | \\\n\t\t\t CIFS_MOUNT_OVERR_GID | CIFS_MOUNT_DYNPERM | \\\n\t\t\t CIFS_MOUNT_NOPOSIXBRL | CIFS_MOUNT_NOSSYNC | \\\n\t\t\t CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \\\n\t\t\t CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \\\n\t\t\t CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \\\n\t\t\t CIFS_MOUNT_UID_FROM_ACL | CIFS_MOUNT_NO_HANDLE_CACHE | \\\n\t\t\t CIFS_MOUNT_NO_DFS | CIFS_MOUNT_MODE_FROM_SID | \\\n\t\t\t CIFS_MOUNT_RO_CACHE | CIFS_MOUNT_RW_CACHE)\n\n \n#define CIFS_MS_MASK (SB_RDONLY | SB_MANDLOCK | SB_NOEXEC | SB_NOSUID | \\\n\t\t      SB_NODEV | SB_SYNCHRONOUS)\n\nstruct cifs_mnt_data {\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb3_fs_context *ctx;\n\tint flags;\n};\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}\n\nstatic inline void\ninc_rfc1001_len(void *buf, int count)\n{\n\tbe32_add_cpu((__be32 *)buf, count);\n}\n\nstruct TCP_Server_Info {\n\tstruct list_head tcp_ses_list;\n\tstruct list_head smb_ses_list;\n\tspinlock_t srv_lock;   \n\t__u64 conn_id;  \n\tint srv_count;  \n\t \n\tchar server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\tstruct smb_version_operations\t*ops;\n\tstruct smb_version_values\t*vals;\n\t \n\tenum statusEnum tcpStatus;  \n\tchar *hostname;  \n\tstruct socket *ssocket;\n\tstruct sockaddr_storage dstaddr;\n\tstruct sockaddr_storage srcaddr;  \n#ifdef CONFIG_NET_NS\n\tstruct net *net;\n#endif\n\twait_queue_head_t response_q;\n\twait_queue_head_t request_q;  \n\tspinlock_t mid_lock;   \n\tstruct list_head pending_mid_q;\n\tbool noblocksnd;\t\t \n\tbool noautotune;\t\t \n\tbool nosharesock;\n\tbool tcp_nodelay;\n\tunsigned int credits;   \n\tunsigned int max_credits;  \n\tunsigned int in_flight;   \n\tunsigned int max_in_flight;  \n\tspinlock_t req_lock;   \n\tstruct mutex _srv_mutex;\n\tunsigned int nofs_flag;\n\tstruct task_struct *tsk;\n\tchar server_GUID[16];\n\t__u16 sec_mode;\n\tbool sign;  \n\tbool ignore_signature:1;  \n\tbool session_estab;  \n\tint echo_credits;   \n\tint oplock_credits;   \n\tbool echoes:1;  \n\t__u8 client_guid[SMB2_CLIENT_GUID_SIZE];  \n\tu16 dialect;  \n\tbool oplocks:1;  \n\tunsigned int maxReq;\t \n\t \n\t \n\tunsigned int maxBuf;\t \n\t \n\t \n\t \n\tunsigned int max_rw;\t \n\t \n\t \n\tunsigned int capabilities;  \n\tint timeAdj;   \n\t__u64 CurrentMid;          \n\tchar cryptkey[CIFS_CRYPTO_KEY_SIZE];  \n\t \n\tchar workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\t__u32 sequence_number;  \n\t__u32 reconnect_instance;  \n\tstruct session_key session_key;\n\tunsigned long lstrp;  \n\tstruct cifs_secmech secmech;  \n#define\tCIFS_NEGFLAVOR_UNENCAP\t1\t \n#define\tCIFS_NEGFLAVOR_EXTENDED\t2\t \n\tchar\tnegflavor;\t \n\t \n\tbool\tsec_ntlmssp;\t\t \n\tbool\tsec_kerberosu2u;\t \n\tbool\tsec_kerberos;\t\t \n\tbool\tsec_mskerberos;\t\t \n\tbool\tlarge_buf;\t\t \n\t \n\tbool\trdma;\n\t \n\tstruct smbd_connection *smbd_conn;\n\tstruct delayed_work\techo;  \n\tchar\t*smallbuf;\t \n\tchar\t*bigbuf;\t \n\t \n\tunsigned int pdu_size;\n\tunsigned int total_read;  \n\tatomic_t in_send;  \n\tatomic_t num_waiters;    \n#ifdef CONFIG_CIFS_STATS2\n\tatomic_t num_cmds[NUMBER_OF_SMB2_COMMANDS];  \n\tatomic_t smb2slowcmd[NUMBER_OF_SMB2_COMMANDS];  \n\t__u64 time_per_cmd[NUMBER_OF_SMB2_COMMANDS];  \n\t__u32 slowest_cmd[NUMBER_OF_SMB2_COMMANDS];\n\t__u32 fastest_cmd[NUMBER_OF_SMB2_COMMANDS];\n#endif  \n\tunsigned int\tmax_read;\n\tunsigned int\tmax_write;\n\tunsigned int\tmin_offload;\n\t__le16\tcompress_algorithm;\n\t__u16\tsigning_algorithm;\n\t__le16\tcipher_type;\n\t  \n\t__u8\tpreauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];\n\tbool\tsigning_negotiated;  \n\tbool\tposix_ext_supported;\n\tstruct delayed_work reconnect;  \n\tstruct mutex reconnect_mutex;  \n\tunsigned long echo_interval;\n\n\t \n\tint nr_targets;\n\tbool noblockcnt;  \n\n\t \n#define SERVER_IS_CHAN(server)\t(!!(server)->primary_server)\n\tstruct TCP_Server_Info *primary_server;\n\t__u16 channel_sequence_num;   \n\n#ifdef CONFIG_CIFS_SWN_UPCALL\n\tbool use_swn_dstaddr;\n\tstruct sockaddr_storage swn_dstaddr;\n#endif\n\tstruct mutex refpath_lock;  \n\t \n\tchar *leaf_fullpath;\n};\n\nstatic inline bool is_smb1(struct TCP_Server_Info *server)\n{\n\treturn HEADER_PREAMBLE_SIZE(server) != 0;\n}\n\nstatic inline void cifs_server_lock(struct TCP_Server_Info *server)\n{\n\tunsigned int nofs_flag = memalloc_nofs_save();\n\n\tmutex_lock(&server->_srv_mutex);\n\tserver->nofs_flag = nofs_flag;\n}\n\nstatic inline void cifs_server_unlock(struct TCP_Server_Info *server)\n{\n\tunsigned int nofs_flag = server->nofs_flag;\n\n\tmutex_unlock(&server->_srv_mutex);\n\tmemalloc_nofs_restore(nofs_flag);\n}\n\nstruct cifs_credits {\n\tunsigned int value;\n\tunsigned int instance;\n};\n\nstatic inline unsigned int\nin_flight(struct TCP_Server_Info *server)\n{\n\tunsigned int num;\n\n\tspin_lock(&server->req_lock);\n\tnum = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\treturn num;\n}\n\nstatic inline bool\nhas_credits(struct TCP_Server_Info *server, int *credits, int num_credits)\n{\n\tint num;\n\n\tspin_lock(&server->req_lock);\n\tnum = *credits;\n\tspin_unlock(&server->req_lock);\n\treturn num >= num_credits;\n}\n\nstatic inline void\nadd_credits(struct TCP_Server_Info *server, const struct cifs_credits *credits,\n\t    const int optype)\n{\n\tserver->ops->add_credits(server, credits, optype);\n}\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server,\n\t\t\tconst struct cifs_credits *credits, const int optype)\n{\n\tif (credits->value) {\n\t\tserver->ops->add_credits(server, credits, optype);\n\t\twake_up(&server->request_q);\n\t}\n}\n\nstatic inline void\nset_credits(struct TCP_Server_Info *server, const int val)\n{\n\tserver->ops->set_credits(server, val);\n}\n\nstatic inline int\nadjust_credits(struct TCP_Server_Info *server, struct cifs_credits *credits,\n\t       const unsigned int payload_size)\n{\n\treturn server->ops->adjust_credits ?\n\t\tserver->ops->adjust_credits(server, credits, payload_size) : 0;\n}\n\nstatic inline __le64\nget_next_mid64(struct TCP_Server_Info *server)\n{\n\treturn cpu_to_le64(server->ops->get_next_mid(server));\n}\n\nstatic inline __le16\nget_next_mid(struct TCP_Server_Info *server)\n{\n\t__u16 mid = server->ops->get_next_mid(server);\n\t \n\treturn cpu_to_le16(mid);\n}\n\nstatic inline void\nrevert_current_mid(struct TCP_Server_Info *server, const unsigned int val)\n{\n\tif (server->ops->revert_current_mid)\n\t\tserver->ops->revert_current_mid(server, val);\n}\n\nstatic inline void\nrevert_current_mid_from_hdr(struct TCP_Server_Info *server,\n\t\t\t    const struct smb2_hdr *shdr)\n{\n\tunsigned int num = le16_to_cpu(shdr->CreditCharge);\n\n\treturn revert_current_mid(server, num > 0 ? num : 1);\n}\n\nstatic inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}\n\nstatic inline bool\ncompare_mid(__u16 mid, const struct smb_hdr *smb)\n{\n\treturn mid == le16_to_cpu(smb->Mid);\n}\n\n \n#define CIFS_MAX_WSIZE ((1<<24) - 1 - sizeof(WRITE_REQ) + 4)\n#define CIFS_MAX_RSIZE ((1<<24) - sizeof(READ_RSP) + 4)\n\n \n#define CIFS_MAX_RFC1002_WSIZE ((1<<17) - 1 - sizeof(WRITE_REQ) + 4)\n#define CIFS_MAX_RFC1002_RSIZE ((1<<17) - 1 - sizeof(READ_RSP) + 4)\n\n#define CIFS_DEFAULT_IOSIZE (1024 * 1024)\n\n \n#define CIFS_DEFAULT_NON_POSIX_RSIZE (60 * 1024)\n#define CIFS_DEFAULT_NON_POSIX_WSIZE (65536)\n\n \n\n#ifdef CONFIG_NET_NS\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn srv->net;\n}\n\nstatic inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)\n{\n\tsrv->net = net;\n}\n\n#else\n\nstatic inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)\n{\n\treturn &init_net;\n}\n\nstatic inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)\n{\n}\n\n#endif\n\nstruct cifs_server_iface {\n\tstruct list_head iface_head;\n\tstruct kref refcount;\n\tsize_t speed;\n\tsize_t weight_fulfilled;\n\tunsigned int num_channels;\n\tunsigned int rdma_capable : 1;\n\tunsigned int rss_capable : 1;\n\tunsigned int is_active : 1;  \n\tstruct sockaddr_storage sockaddr;\n};\n\n \nstatic inline void\nrelease_iface(struct kref *ref)\n{\n\tstruct cifs_server_iface *iface = container_of(ref,\n\t\t\t\t\t\t       struct cifs_server_iface,\n\t\t\t\t\t\t       refcount);\n\tkfree(iface);\n}\n\nstruct cifs_chan {\n\tunsigned int in_reconnect : 1;  \n\tstruct TCP_Server_Info *server;\n\tstruct cifs_server_iface *iface;  \n\t__u8 signkey[SMB3_SIGN_KEY_SIZE];\n};\n\n \nstruct cifs_ses {\n\tstruct list_head smb_ses_list;\n\tstruct list_head rlist;  \n\tstruct list_head tcon_list;\n\tstruct cifs_tcon *tcon_ipc;\n\tspinlock_t ses_lock;   \n\tstruct mutex session_mutex;\n\tstruct TCP_Server_Info *server;\t \n\tint ses_count;\t\t \n\tenum ses_status_enum ses_status;   \n\tunsigned int overrideSecFlg;  \n\tchar *serverOS;\t\t \n\tchar *serverNOS;\t \n\tchar *serverDomain;\t \n\t__u64 Suid;\t\t \n\tkuid_t linux_uid;\t \n\tkuid_t cred_uid;\t \n\tunsigned int capabilities;\n\tchar ip_addr[INET6_ADDRSTRLEN + 1];  \n\tchar *user_name;\t \n\tchar *domainName;\n\tchar *password;\n\tchar workstation_name[CIFS_MAX_WORKSTATION_LEN];\n\tstruct session_key auth_key;\n\tstruct ntlmssp_auth *ntlmssp;  \n\tenum securityEnum sectype;  \n\tbool sign;\t\t \n\tbool domainAuto:1;\n\t__u16 session_flags;\n\t__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];\n\t__u8 smb3encryptionkey[SMB3_ENC_DEC_KEY_SIZE];\n\t__u8 smb3decryptionkey[SMB3_ENC_DEC_KEY_SIZE];\n\t__u8 preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];\n\n\t \n\tspinlock_t iface_lock;\n\t \n\tstruct list_head iface_list;\n\tsize_t iface_count;\n\tunsigned long iface_last_update;  \n\t \n\n\tspinlock_t chan_lock;\n\t \n#define CIFS_MAX_CHANNELS 16\n#define CIFS_ALL_CHANNELS_SET(ses)\t\\\n\t((1UL << (ses)->chan_count) - 1)\n#define CIFS_ALL_CHANS_GOOD(ses)\t\t\\\n\t(!(ses)->chans_need_reconnect)\n#define CIFS_ALL_CHANS_NEED_RECONNECT(ses)\t\\\n\t((ses)->chans_need_reconnect == CIFS_ALL_CHANNELS_SET(ses))\n#define CIFS_SET_ALL_CHANS_NEED_RECONNECT(ses)\t\\\n\t((ses)->chans_need_reconnect = CIFS_ALL_CHANNELS_SET(ses))\n#define CIFS_CHAN_NEEDS_RECONNECT(ses, index)\t\\\n\ttest_bit((index), &(ses)->chans_need_reconnect)\n#define CIFS_CHAN_IN_RECONNECT(ses, index)\t\\\n\t((ses)->chans[(index)].in_reconnect)\n\n\tstruct cifs_chan chans[CIFS_MAX_CHANNELS];\n\tsize_t chan_count;\n\tsize_t chan_max;\n\tatomic_t chan_seq;  \n\n\t \n\tunsigned long chans_need_reconnect;\n\t \n\tstruct cifs_ses *dfs_root_ses;\n\tstruct nls_table *local_nls;\n};\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}\n\n \n\n#define CIFS_FATTR_JUNCTION\t\t0x1\n#define CIFS_FATTR_DELETE_PENDING\t0x2\n#define CIFS_FATTR_NEED_REVAL\t\t0x4\n#define CIFS_FATTR_INO_COLLISION\t0x8\n#define CIFS_FATTR_UNKNOWN_NLINK\t0x10\n#define CIFS_FATTR_FAKE_ROOT_INO\t0x20\n\nstruct cifs_fattr {\n\tu32\t\tcf_flags;\n\tu32\t\tcf_cifsattrs;\n\tu64\t\tcf_uniqueid;\n\tu64\t\tcf_eof;\n\tu64\t\tcf_bytes;\n\tu64\t\tcf_createtime;\n\tkuid_t\t\tcf_uid;\n\tkgid_t\t\tcf_gid;\n\tumode_t\t\tcf_mode;\n\tdev_t\t\tcf_rdev;\n\tunsigned int\tcf_nlink;\n\tunsigned int\tcf_dtype;\n\tstruct timespec64 cf_atime;\n\tstruct timespec64 cf_mtime;\n\tstruct timespec64 cf_ctime;\n\tu32             cf_cifstag;\n\tchar            *cf_symlink_target;\n};\n\n \nstruct cifs_tcon {\n\tstruct list_head tcon_list;\n\tint tc_count;\n\tstruct list_head rlist;  \n\tspinlock_t tc_lock;   \n\tatomic_t num_local_opens;   \n\tatomic_t num_remote_opens;  \n\tstruct list_head openFileList;\n\tspinlock_t open_file_lock;  \n\tstruct cifs_ses *ses;\t \n\tchar tree_name[MAX_TREE_SIZE + 1];  \n\tchar *nativeFileSystem;\n\tchar *password;\t\t \n\t__u32 tid;\t\t \n\t__u16 Flags;\t\t \n\tenum tid_status_enum status;\n\tatomic_t num_smbs_sent;\n\tunion {\n\t\tstruct {\n\t\t\tatomic_t num_writes;\n\t\t\tatomic_t num_reads;\n\t\t\tatomic_t num_flushes;\n\t\t\tatomic_t num_oplock_brks;\n\t\t\tatomic_t num_opens;\n\t\t\tatomic_t num_closes;\n\t\t\tatomic_t num_deletes;\n\t\t\tatomic_t num_mkdirs;\n\t\t\tatomic_t num_posixopens;\n\t\t\tatomic_t num_posixmkdirs;\n\t\t\tatomic_t num_rmdirs;\n\t\t\tatomic_t num_renames;\n\t\t\tatomic_t num_t2renames;\n\t\t\tatomic_t num_ffirst;\n\t\t\tatomic_t num_fnext;\n\t\t\tatomic_t num_fclose;\n\t\t\tatomic_t num_hardlinks;\n\t\t\tatomic_t num_symlinks;\n\t\t\tatomic_t num_locks;\n\t\t\tatomic_t num_acl_get;\n\t\t\tatomic_t num_acl_set;\n\t\t} cifs_stats;\n\t\tstruct {\n\t\t\tatomic_t smb2_com_sent[NUMBER_OF_SMB2_COMMANDS];\n\t\t\tatomic_t smb2_com_failed[NUMBER_OF_SMB2_COMMANDS];\n\t\t} smb2_stats;\n\t} stats;\n\t__u64    bytes_read;\n\t__u64    bytes_written;\n\tspinlock_t stat_lock;   \n\tFILE_SYSTEM_DEVICE_INFO fsDevInfo;\n\tFILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo;  \n\tFILE_SYSTEM_UNIX_INFO fsUnixInfo;\n\tbool ipc:1;    \n\tbool pipe:1;   \n\tbool print:1;  \n\tbool retry:1;\n\tbool nocase:1;\n\tbool nohandlecache:1;  \n\tbool nodelete:1;\n\tbool seal:1;       \n\tbool unix_ext:1;   \n\tbool posix_extensions;  \n\tbool local_lease:1;  \n\tbool broken_posix_open;  \n\tbool broken_sparse_sup;  \n\tbool need_reconnect:1;  \n\tbool need_reopen_files:1;  \n\tbool use_resilient:1;  \n\tbool use_persistent:1;  \n\tbool no_lease:1;     \n\tbool use_witness:1;  \n\t__le32 capabilities;\n\t__u32 share_flags;\n\t__u32 maximal_access;\n\t__u32 vol_serial_number;\n\t__le64 vol_create_time;\n\t__u64 snapshot_time;  \n\t__u32 handle_timeout;  \n\t__u32 ss_flags;\t\t \n\t__u32 perf_sector_size;  \n\t__u32 max_chunks;\n\t__u32 max_bytes_chunk;\n\t__u32 max_bytes_copy;\n\t__u32 max_cached_dirs;\n#ifdef CONFIG_CIFS_FSCACHE\n\tu64 resource_id;\t\t \n\tstruct fscache_volume *fscache;\t \n#endif\n\tstruct list_head pending_opens;\t \n\tstruct cached_fids *cfids;\n\t \n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct list_head dfs_ses_list;\n\tstruct delayed_work dfs_cache_work;\n#endif\n\tstruct delayed_work\tquery_interfaces;  \n\tchar *origin_fullpath;  \n};\n\n \nstruct tcon_link {\n\tstruct rb_node\t\ttl_rbnode;\n\tkuid_t\t\t\ttl_uid;\n\tunsigned long\t\ttl_flags;\n#define TCON_LINK_MASTER\t0\n#define TCON_LINK_PENDING\t1\n#define TCON_LINK_IN_TREE\t2\n\tunsigned long\t\ttl_time;\n\tatomic_t\t\ttl_count;\n\tstruct cifs_tcon\t*tl_tcon;\n};\n\nextern struct tcon_link *cifs_sb_tlink(struct cifs_sb_info *cifs_sb);\nextern void smb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst);\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n\nextern void cifs_put_tlink(struct tcon_link *tlink);\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}\n\n \nextern struct cifs_tcon *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);\n\n#define CIFS_OPLOCK_NO_CHANGE 0xfe\n\nstruct cifs_pending_open {\n\tstruct list_head olist;\n\tstruct tcon_link *tlink;\n\t__u8 lease_key[16];\n\t__u32 oplock;\n};\n\nstruct cifs_deferred_close {\n\tstruct list_head dlist;\n\tstruct tcon_link *tlink;\n\t__u16  netfid;\n\t__u64  persistent_fid;\n\t__u64  volatile_fid;\n};\n\n \nstruct cifsLockInfo {\n\tstruct list_head llist;\t \n\tstruct list_head blist;  \n\twait_queue_head_t block_q;\n\t__u64 offset;\n\t__u64 length;\n\t__u32 pid;\n\t__u16 type;\n\t__u16 flags;\n};\n\n \nstruct cifs_search_info {\n\tloff_t index_of_last_entry;\n\t__u16 entries_in_buffer;\n\t__u16 info_level;\n\t__u32 resume_key;\n\tchar *ntwrk_buf_start;\n\tchar *srch_entries_start;\n\tchar *last_entry;\n\tconst char *presume_name;\n\tunsigned int resume_name_len;\n\tbool endOfSearch:1;\n\tbool emptyDir:1;\n\tbool unicode:1;\n\tbool smallBuf:1;  \n};\n\n#define ACL_NO_MODE\t((umode_t)(-1))\nstruct cifs_open_parms {\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tint disposition;\n\tint desired_access;\n\tint create_options;\n\tconst char *path;\n\tstruct cifs_fid *fid;\n\tumode_t mode;\n\tbool reconnect:1;\n};\n\nstruct cifs_fid {\n\t__u16 netfid;\n\t__u64 persistent_fid;\t \n\t__u64 volatile_fid;\t \n\t__u8 lease_key[SMB2_LEASE_KEY_SIZE];\t \n\t__u8 create_guid[16];\n\t__u32 access;\n\tstruct cifs_pending_open *pending_open;\n\tunsigned int epoch;\n#ifdef CONFIG_CIFS_DEBUG2\n\t__u64 mid;\n#endif  \n\tbool purge_cache;\n};\n\nstruct cifs_fid_locks {\n\tstruct list_head llist;\n\tstruct cifsFileInfo *cfile;\t \n\tstruct list_head locks;\t\t \n};\n\nstruct cifsFileInfo {\n\t \n\tstruct list_head tlist;\t \n\tstruct list_head flist;\t \n\t \n\tstruct cifs_fid_locks *llist;\t \n\tkuid_t uid;\t\t \n\t__u32 pid;\t\t \n\tstruct cifs_fid fid;\t \n\tstruct list_head rlist;  \n\t \n\t \n\tstruct dentry *dentry;\n\tstruct tcon_link *tlink;\n\tunsigned int f_flags;\n\tbool invalidHandle:1;\t \n\tbool swapfile:1;\n\tbool oplock_break_cancelled:1;\n\tunsigned int oplock_epoch;  \n\t__u32 oplock_level;  \n\tint count;\n\tspinlock_t file_info_lock;  \n\tstruct mutex fh_mutex;  \n\tstruct cifs_search_info srch_inf;\n\tstruct work_struct oplock_break;  \n\tstruct work_struct put;  \n\tstruct delayed_work deferred;\n\tbool deferred_close_scheduled;  \n\tchar *symlink_target;\n};\n\nstruct cifs_io_parms {\n\t__u16 netfid;\n\t__u64 persistent_fid;\t \n\t__u64 volatile_fid;\t \n\t__u32 pid;\n\t__u64 offset;\n\tunsigned int length;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n};\n\nstruct cifs_aio_ctx {\n\tstruct kref\t\trefcount;\n\tstruct list_head\tlist;\n\tstruct mutex\t\taio_mutex;\n\tstruct completion\tdone;\n\tstruct iov_iter\t\titer;\n\tstruct kiocb\t\t*iocb;\n\tstruct cifsFileInfo\t*cfile;\n\tstruct bio_vec\t\t*bv;\n\tloff_t\t\t\tpos;\n\tunsigned int\t\tnr_pinned_pages;\n\tssize_t\t\t\trc;\n\tunsigned int\t\tlen;\n\tunsigned int\t\ttotal_len;\n\tunsigned int\t\tbv_need_unpin;\t \n\tbool\t\t\tshould_dirty;\n\t \n\tbool\t\t\tdirect_io;\n};\n\n \nstruct cifs_readdata {\n\tstruct kref\t\t\trefcount;\n\tstruct list_head\t\tlist;\n\tstruct completion\t\tdone;\n\tstruct cifsFileInfo\t\t*cfile;\n\tstruct address_space\t\t*mapping;\n\tstruct cifs_aio_ctx\t\t*ctx;\n\t__u64\t\t\t\toffset;\n\tssize_t\t\t\t\tgot_bytes;\n\tunsigned int\t\t\tbytes;\n\tpid_t\t\t\t\tpid;\n\tint\t\t\t\tresult;\n\tstruct work_struct\t\twork;\n\tstruct iov_iter\t\t\titer;\n\tstruct kvec\t\t\tiov[2];\n\tstruct TCP_Server_Info\t\t*server;\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tstruct smbd_mr\t\t\t*mr;\n#endif\n\tstruct cifs_credits\t\tcredits;\n};\n\n \nstruct cifs_writedata {\n\tstruct kref\t\t\trefcount;\n\tstruct list_head\t\tlist;\n\tstruct completion\t\tdone;\n\tenum writeback_sync_modes\tsync_mode;\n\tstruct work_struct\t\twork;\n\tstruct cifsFileInfo\t\t*cfile;\n\tstruct cifs_aio_ctx\t\t*ctx;\n\tstruct iov_iter\t\t\titer;\n\tstruct bio_vec\t\t\t*bv;\n\t__u64\t\t\t\toffset;\n\tpid_t\t\t\t\tpid;\n\tunsigned int\t\t\tbytes;\n\tint\t\t\t\tresult;\n\tstruct TCP_Server_Info\t\t*server;\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tstruct smbd_mr\t\t\t*mr;\n#endif\n\tstruct cifs_credits\t\tcredits;\n};\n\n \nstatic inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}\n\nstruct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file);\nvoid _cifsFileInfo_put(struct cifsFileInfo *cifs_file, bool wait_oplock_hdlr,\n\t\t       bool offload);\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file);\n\n#define CIFS_CACHE_READ_FLG\t1\n#define CIFS_CACHE_HANDLE_FLG\t2\n#define CIFS_CACHE_RH_FLG\t(CIFS_CACHE_READ_FLG | CIFS_CACHE_HANDLE_FLG)\n#define CIFS_CACHE_WRITE_FLG\t4\n#define CIFS_CACHE_RW_FLG\t(CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG)\n#define CIFS_CACHE_RHW_FLG\t(CIFS_CACHE_RW_FLG | CIFS_CACHE_HANDLE_FLG)\n\n#define CIFS_CACHE_READ(cinode) ((cinode->oplock & CIFS_CACHE_READ_FLG) || (CIFS_SB(cinode->netfs.inode.i_sb)->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE))\n#define CIFS_CACHE_HANDLE(cinode) (cinode->oplock & CIFS_CACHE_HANDLE_FLG)\n#define CIFS_CACHE_WRITE(cinode) ((cinode->oplock & CIFS_CACHE_WRITE_FLG) || (CIFS_SB(cinode->netfs.inode.i_sb)->mnt_cifs_flags & CIFS_MOUNT_RW_CACHE))\n\n \n\nstruct cifsInodeInfo {\n\tstruct netfs_inode netfs;  \n\tbool can_cache_brlcks;\n\tstruct list_head llist;\t \n\t \n\tstruct rw_semaphore lock_sem;\t \n\t \n\tstruct list_head openFileList;\n\tspinlock_t\topen_file_lock;\t \n\t__u32 cifsAttrs;  \n\tunsigned int oplock;\t\t \n\tunsigned int epoch;\t\t \n#define CIFS_INODE_PENDING_OPLOCK_BREAK   (0)  \n#define CIFS_INODE_PENDING_WRITERS\t  (1)  \n#define CIFS_INODE_FLAG_UNUSED\t\t  (2)  \n#define CIFS_INO_DELETE_PENDING\t\t  (3)  \n#define CIFS_INO_INVALID_MAPPING\t  (4)  \n#define CIFS_INO_LOCK\t\t\t  (5)  \n#define CIFS_INO_MODIFIED_ATTR            (6)  \n#define CIFS_INO_CLOSE_ON_LOCK            (7)  \n\tunsigned long flags;\n\tspinlock_t writers_lock;\n\tunsigned int writers;\t\t \n\tunsigned long time;\t\t \n\tu64  server_eof;\t\t \n\tu64  uniqueid;\t\t\t \n\tu64  createtime;\t\t \n\t__u8 lease_key[SMB2_LEASE_KEY_SIZE];\t \n\tstruct list_head deferred_closes;  \n\tspinlock_t deferred_lock;  \n\tbool lease_granted;  \n\tchar *symlink_target;\n};\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, netfs.inode);\n}\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}\n\n#define cifs_stats_inc atomic_inc\n\nstatic inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}\n\nstatic inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}\n\n\n \ntypedef int (mid_receive_t)(struct TCP_Server_Info *server,\n\t\t\t    struct mid_q_entry *mid);\n\n \ntypedef void (mid_callback_t)(struct mid_q_entry *mid);\n\n \ntypedef int (mid_handle_t)(struct TCP_Server_Info *server,\n\t\t\t    struct mid_q_entry *mid);\n\n \nstruct mid_q_entry {\n\tstruct list_head qhead;\t \n\tstruct kref refcount;\n\tstruct TCP_Server_Info *server;\t \n\t__u64 mid;\t\t \n\t__u16 credits;\t\t \n\t__u16 credits_received;\t \n\t__u32 pid;\t\t \n\t__u32 sequence_number;   \n\tunsigned long when_alloc;   \n#ifdef CONFIG_CIFS_STATS2\n\tunsigned long when_sent;  \n\tunsigned long when_received;  \n#endif\n\tmid_receive_t *receive;  \n\tmid_callback_t *callback;  \n\tmid_handle_t *handle;  \n\tvoid *callback_data;\t   \n\tstruct task_struct *creator;\n\tvoid *resp_buf;\t\t \n\tunsigned int resp_buf_size;\n\tint mid_state;\t \n\tunsigned int mid_flags;\n\t__le16 command;\t\t \n\tunsigned int optype;\t \n\tbool large_buf:1;\t \n\tbool multiRsp:1;\t \n\tbool multiEnd:1;\t \n\tbool decrypted:1;\t \n};\n\nstruct close_cancelled_open {\n\tstruct cifs_fid         fid;\n\tstruct cifs_tcon        *tcon;\n\tstruct work_struct      work;\n\t__u64 mid;\n\t__u16 cmd;\n};\n\n \nstatic inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n\tatomic_inc(&server->in_send);\n}\n\nstatic inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n\tatomic_dec(&server->in_send);\n}\n\nstatic inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)\n{\n\tatomic_inc(&server->num_waiters);\n}\n\nstatic inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)\n{\n\tatomic_dec(&server->num_waiters);\n}\n\n#ifdef CONFIG_CIFS_STATS2\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n\tmid->when_sent = jiffies;\n}\n#else\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}\n#endif\n\n \nstruct dir_notify_req {\n\tstruct list_head lhead;\n\t__le16 Pid;\n\t__le16 PidHigh;\n\t__u16 Mid;\n\t__u16 Tid;\n\t__u16 Uid;\n\t__u16 netfid;\n\t__u32 filter;  \n\tint multishot;\n\tstruct file *pfile;\n};\n\nstruct dfs_info3_param {\n\tint flags;  \n\tint path_consumed;\n\tint server_type;\n\tint ref_flag;\n\tchar *path_name;\n\tchar *node_name;\n\tint ttl;\n};\n\nstruct file_list {\n\tstruct list_head list;\n\tstruct cifsFileInfo *cfile;\n};\n\nstruct cifs_mount_ctx {\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb3_fs_context *fs_ctx;\n\tunsigned int xid;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct list_head dfs_ses_list;\n};\n\nstatic inline void __free_dfs_info_param(struct dfs_info3_param *param)\n{\n\tkfree(param->path_name);\n\tkfree(param->node_name);\n}\n\nstatic inline void free_dfs_info_param(struct dfs_info3_param *param)\n{\n\tif (param)\n\t\t__free_dfs_info_param(param);\n}\n\nstatic inline void zfree_dfs_info_param(struct dfs_info3_param *param)\n{\n\tif (param) {\n\t\t__free_dfs_info_param(param);\n\t\tmemset(param, 0, sizeof(*param));\n\t}\n}\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}\n\nstatic inline bool is_interrupt_error(int error)\n{\n\tswitch (error) {\n\tcase -EINTR:\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTARTNOINTR:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool is_retryable_error(int error)\n{\n\tif (is_interrupt_error(error) || error == -EAGAIN)\n\t\treturn true;\n\treturn false;\n}\n\n\n \n#define FIND_WR_ANY         0\n#define FIND_WR_FSUID_ONLY  1\n#define FIND_WR_WITH_DELETE 2\n\n#define   MID_FREE 0\n#define   MID_REQUEST_ALLOCATED 1\n#define   MID_REQUEST_SUBMITTED 2\n#define   MID_RESPONSE_RECEIVED 4\n#define   MID_RETRY_NEEDED      8  \n#define   MID_RESPONSE_MALFORMED 0x10\n#define   MID_SHUTDOWN\t\t 0x20\n#define   MID_RESPONSE_READY 0x40  \n\n \n#define   MID_WAIT_CANCELLED\t 1  \n#define   MID_DELETED            2  \n\n \n#define   CIFS_NO_BUFFER        0     \n#define   CIFS_SMALL_BUFFER     1\n#define   CIFS_LARGE_BUFFER     2\n#define   CIFS_IOVEC            4     \n\n \n#define   CIFS_BLOCKING_OP      1     \n#define   CIFS_NON_BLOCKING     2     \n#define   CIFS_TIMEOUT_MASK 0x003     \n#define   CIFS_LOG_ERROR    0x010     \n#define   CIFS_LARGE_BUF_OP 0x020     \n#define   CIFS_NO_RSP_BUF   0x040     \n\n \n#define   CIFS_ECHO_OP            0x080   \n#define   CIFS_OBREAK_OP          0x0100  \n#define   CIFS_NEG_OP             0x0200  \n#define   CIFS_CP_CREATE_CLOSE_OP 0x0400  \n \n#define   CIFS_SESS_OP            0x2000  \n#define   CIFS_OP_MASK            0x2780  \n\n#define   CIFS_HAS_CREDITS        0x0400  \n#define   CIFS_TRANSFORM_REQ      0x0800  \n#define   CIFS_NO_SRV_RSP         0x1000  \n\n \n#define   CIFSSEC_MAY_SIGN\t0x00001\n#define   CIFSSEC_MAY_NTLMV2\t0x00004\n#define   CIFSSEC_MAY_KRB5\t0x00008\n#define   CIFSSEC_MAY_SEAL\t0x00040  \n#define   CIFSSEC_MAY_NTLMSSP\t0x00080  \n\n#define   CIFSSEC_MUST_SIGN\t0x01001\n \n#define   CIFSSEC_MUST_NTLMV2\t0x04004\n#define   CIFSSEC_MUST_KRB5\t0x08008\n#ifdef CONFIG_CIFS_UPCALL\n#define   CIFSSEC_MASK          0x8F08F  \n#else\n#define\t  CIFSSEC_MASK          0x87087  \n#endif  \n#define   CIFSSEC_MUST_SEAL\t0x40040  \n#define   CIFSSEC_MUST_NTLMSSP\t0x80080  \n\n#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_NTLMSSP)\n#define   CIFSSEC_MAX (CIFSSEC_MUST_NTLMV2)\n#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)\n \n\n#define UID_HASH (16)\n\n \n\n \n\n#ifdef DECLARE_GLOBALS_HERE\n#define GLOBAL_EXTERN\n#else\n#define GLOBAL_EXTERN extern\n#endif\n\n \nextern struct list_head\t\tcifs_tcp_ses_list;\n\n \nextern spinlock_t\t\tcifs_tcp_ses_lock;\n\n \nextern unsigned int GlobalCurrentXid;\t \nextern unsigned int GlobalTotalActiveXid;  \nextern unsigned int GlobalMaxActiveXid;\t \nextern spinlock_t GlobalMid_Lock;  \n\n \nextern atomic_t sesInfoAllocCount;\nextern atomic_t tconInfoAllocCount;\nextern atomic_t tcpSesNextId;\nextern atomic_t tcpSesAllocCount;\nextern atomic_t tcpSesReconnectCount;\nextern atomic_t tconInfoReconnectCount;\n\n \nextern atomic_t buf_alloc_count;\t \nextern atomic_t small_buf_alloc_count;\n#ifdef CONFIG_CIFS_STATS2\nextern atomic_t total_buf_alloc_count;  \nextern atomic_t total_small_buf_alloc_count;\nextern unsigned int slow_rsp_threshold;  \n#endif\n\n \nextern bool enable_oplocks;  \nextern bool lookupCacheEnabled;\nextern unsigned int global_secflags;\t \nextern unsigned int sign_CIFS_PDUs;   \nextern bool enable_gcm_256;  \nextern bool require_gcm_256;  \nextern bool enable_negotiate_signing;  \nextern bool linuxExtEnabled; \nextern unsigned int CIFSMaxBufSize;   \nextern unsigned int cifs_min_rcv;     \nextern unsigned int cifs_min_small;   \nextern unsigned int cifs_max_pending;  \nextern unsigned int dir_cache_timeout;  \nextern bool disable_legacy_dialects;   \nextern atomic_t mid_count;\n\nvoid cifs_oplock_break(struct work_struct *work);\nvoid cifs_queue_oplock_break(struct cifsFileInfo *cfile);\nvoid smb2_deferred_work_close(struct work_struct *work);\n\nextern const struct slow_work_ops cifs_oplock_break_ops;\nextern struct workqueue_struct *cifsiod_wq;\nextern struct workqueue_struct *decrypt_wq;\nextern struct workqueue_struct *fileinfo_put_wq;\nextern struct workqueue_struct *cifsoplockd_wq;\nextern struct workqueue_struct *deferredclose_wq;\nextern __u32 cifs_lock_secret;\n\nextern mempool_t *cifs_mid_poolp;\n\n \n#define SMB1_VERSION_STRING\t\"1.0\"\n#define SMB20_VERSION_STRING    \"2.0\"\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nextern struct smb_version_operations smb1_operations;\nextern struct smb_version_values smb1_values;\nextern struct smb_version_operations smb20_operations;\nextern struct smb_version_values smb20_values;\n#endif  \n#define SMB21_VERSION_STRING\t\"2.1\"\nextern struct smb_version_operations smb21_operations;\nextern struct smb_version_values smb21_values;\n#define SMBDEFAULT_VERSION_STRING \"default\"\nextern struct smb_version_values smbdefault_values;\n#define SMB3ANY_VERSION_STRING \"3\"\nextern struct smb_version_values smb3any_values;\n#define SMB30_VERSION_STRING\t\"3.0\"\nextern struct smb_version_operations smb30_operations;\nextern struct smb_version_values smb30_values;\n#define SMB302_VERSION_STRING\t\"3.02\"\n#define ALT_SMB302_VERSION_STRING \"3.0.2\"\n   \nextern struct smb_version_values smb302_values;\n#define SMB311_VERSION_STRING\t\"3.1.1\"\n#define ALT_SMB311_VERSION_STRING \"3.11\"\nextern struct smb_version_operations smb311_operations;\nextern struct smb_version_values smb311_values;\n\nstatic inline char *get_security_type_str(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\t\treturn \"RawNTLMSSP\";\n\tcase Kerberos:\n\t\treturn \"Kerberos\";\n\tcase NTLMv2:\n\t\treturn \"NTLMv2\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic inline bool is_smb1_server(struct TCP_Server_Info *server)\n{\n\treturn strcmp(server->vals->version_string, SMB1_VERSION_STRING) == 0;\n}\n\nstatic inline bool is_tcon_dfs(struct cifs_tcon *tcon)\n{\n\t \n\tif (!tcon || !tcon->ses || !tcon->ses->server)\n\t\treturn false;\n\treturn is_smb1_server(tcon->ses->server) ? tcon->Flags & SMB_SHARE_IS_IN_DFS :\n\t\ttcon->share_flags & (SHI1005_FLAGS_DFS | SHI1005_FLAGS_DFS_ROOT);\n}\n\nstatic inline bool cifs_is_referral_server(struct cifs_tcon *tcon,\n\t\t\t\t\t   const struct dfs_info3_param *ref)\n{\n\t \n\treturn is_tcon_dfs(tcon) || (ref && (ref->flags & DFSREF_REFERRAL_SERVER));\n}\n\nstatic inline u64 cifs_flock_len(const struct file_lock *fl)\n{\n\treturn (u64)fl->fl_end - fl->fl_start + 1;\n}\n\nstatic inline size_t ntlmssp_workstation_name_size(const struct cifs_ses *ses)\n{\n\tif (WARN_ON_ONCE(!ses || !ses->server))\n\t\treturn 0;\n\t \n\tif (ses->server->dialect <= SMB20_PROT_ID)\n\t\treturn min_t(size_t, sizeof(ses->workstation_name), RFC1001_NAME_LEN_WITH_NULL);\n\treturn sizeof(ses->workstation_name);\n}\n\nstatic inline void move_cifs_info_to_smb2(struct smb2_file_all_info *dst, const FILE_ALL_INFO *src)\n{\n\tmemcpy(dst, src, (size_t)((u8 *)&src->AccessFlags - (u8 *)src));\n\tdst->AccessFlags = src->AccessFlags;\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->FileNameLength = src->FileNameLength;\n}\n\nstatic inline int cifs_get_num_sgs(const struct smb_rqst *rqst,\n\t\t\t\t   int num_rqst,\n\t\t\t\t   const u8 *sig)\n{\n\tunsigned int len, skip;\n\tunsigned int nents = 0;\n\tunsigned long addr;\n\tsize_t data_size;\n\tint i, j;\n\n\t \n\tskip = 20;\n\n\t \n\tfor (i = 0; i < num_rqst; i++) {\n\t\tdata_size = iov_iter_count(&rqst[i].rq_iter);\n\n\t\t \n\t\tif (data_size &&\n\t\t    WARN_ON_ONCE(user_backed_iter(&rqst[i].rq_iter)))\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif (data_size &&\n\t\t    WARN_ON_ONCE(iov_iter_extract_will_pin(&rqst[i].rq_iter)))\n\t\t\treturn -EIO;\n\n\t\tfor (j = 0; j < rqst[i].rq_nvec; j++) {\n\t\t\tstruct kvec *iov = &rqst[i].rq_iov[j];\n\n\t\t\taddr = (unsigned long)iov->iov_base + skip;\n\t\t\tif (unlikely(is_vmalloc_addr((void *)addr))) {\n\t\t\t\tlen = iov->iov_len - skip;\n\t\t\t\tnents += DIV_ROUND_UP(offset_in_page(addr) + len,\n\t\t\t\t\t\t      PAGE_SIZE);\n\t\t\t} else {\n\t\t\t\tnents++;\n\t\t\t}\n\t\t\tskip = 0;\n\t\t}\n\t\tif (data_size)\n\t\t\tnents += iov_iter_npages(&rqst[i].rq_iter, INT_MAX);\n\t}\n\tnents += DIV_ROUND_UP(offset_in_page(sig) + SMB2_SIGNATURE_SIZE, PAGE_SIZE);\n\treturn nents;\n}\n\n \nstatic inline void cifs_sg_set_buf(struct sg_table *sgtable,\n\t\t\t\t   const void *buf,\n\t\t\t\t   unsigned int buflen)\n{\n\tunsigned long addr = (unsigned long)buf;\n\tunsigned int off = offset_in_page(addr);\n\n\taddr &= PAGE_MASK;\n\tif (unlikely(is_vmalloc_addr((void *)addr))) {\n\t\tdo {\n\t\t\tunsigned int len = min_t(unsigned int, buflen, PAGE_SIZE - off);\n\n\t\t\tsg_set_page(&sgtable->sgl[sgtable->nents++],\n\t\t\t\t    vmalloc_to_page((void *)addr), len, off);\n\n\t\t\toff = 0;\n\t\t\taddr += PAGE_SIZE;\n\t\t\tbuflen -= len;\n\t\t} while (buflen);\n\t} else {\n\t\tsg_set_page(&sgtable->sgl[sgtable->nents++],\n\t\t\t    virt_to_page((void *)addr), buflen, off);\n\t}\n}\n\nstruct smb2_compound_vars {\n\tstruct cifs_open_parms oparms;\n\tstruct kvec rsp_iov[3];\n\tstruct smb_rqst rqst[3];\n\tstruct kvec open_iov[SMB2_CREATE_IOV_SIZE];\n\tstruct kvec qi_iov;\n\tstruct kvec io_iov[SMB2_IOCTL_IOV_SIZE];\n\tstruct kvec si_iov[SMB2_SET_INFO_IOV_SIZE];\n\tstruct kvec close_iov;\n\tstruct smb2_file_rename_info rename_info;\n\tstruct smb2_file_link_info link_info;\n};\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}