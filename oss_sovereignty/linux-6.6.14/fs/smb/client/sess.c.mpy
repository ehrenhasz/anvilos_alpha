{
  "module_name": "sess.c",
  "hash_id": "118b29a9b3d4dbe92956e5383a7210852355eea2c0e808dda8827450c44b4c36",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/sess.c",
  "human_readable_source": "\n \n\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include <linux/utsname.h>\n#include <linux/slab.h>\n#include <linux/version.h>\n#include \"cifsfs.h\"\n#include \"cifs_spnego.h\"\n#include \"smb2proto.h\"\n#include \"fs_context.h\"\n\nstatic int\ncifs_ses_add_channel(struct cifs_ses *ses,\n\t\t     struct cifs_server_iface *iface);\n\nbool\nis_server_using_iface(struct TCP_Server_Info *server,\n\t\t      struct cifs_server_iface *iface)\n{\n\tstruct sockaddr_in *i4 = (struct sockaddr_in *)&iface->sockaddr;\n\tstruct sockaddr_in6 *i6 = (struct sockaddr_in6 *)&iface->sockaddr;\n\tstruct sockaddr_in *s4 = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family != iface->sockaddr.ss_family)\n\t\treturn false;\n\tif (server->dstaddr.ss_family == AF_INET) {\n\t\tif (s4->sin_addr.s_addr != i4->sin_addr.s_addr)\n\t\t\treturn false;\n\t} else if (server->dstaddr.ss_family == AF_INET6) {\n\t\tif (memcmp(&s6->sin6_addr, &i6->sin6_addr,\n\t\t\t   sizeof(i6->sin6_addr)) != 0)\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool is_ses_using_iface(struct cifs_ses *ses, struct cifs_server_iface *iface)\n{\n\tint i;\n\n\tspin_lock(&ses->chan_lock);\n\tfor (i = 0; i < ses->chan_count; i++) {\n\t\tif (ses->chans[i].iface == iface) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&ses->chan_lock);\n\treturn false;\n}\n\n \n\nunsigned int\ncifs_ses_get_chan_index(struct cifs_ses *ses,\n\t\t\tstruct TCP_Server_Info *server)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ses->chan_count; i++) {\n\t\tif (ses->chans[i].server == server)\n\t\t\treturn i;\n\t}\n\n\t \n\tif (server)\n\t\tcifs_dbg(VFS, \"unable to get chan index for server: 0x%llx\",\n\t\t\t server->conn_id);\n\tWARN_ON(1);\n\treturn 0;\n}\n\nvoid\ncifs_chan_set_in_reconnect(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\tses->chans[chan_index].in_reconnect = true;\n}\n\nvoid\ncifs_chan_clear_in_reconnect(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\tses->chans[chan_index].in_reconnect = false;\n}\n\nbool\ncifs_chan_in_reconnect(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\treturn CIFS_CHAN_IN_RECONNECT(ses, chan_index);\n}\n\nvoid\ncifs_chan_set_need_reconnect(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\tset_bit(chan_index, &ses->chans_need_reconnect);\n\tcifs_dbg(FYI, \"Set reconnect bitmask for chan %u; now 0x%lx\\n\",\n\t\t chan_index, ses->chans_need_reconnect);\n}\n\nvoid\ncifs_chan_clear_need_reconnect(struct cifs_ses *ses,\n\t\t\t       struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\tclear_bit(chan_index, &ses->chans_need_reconnect);\n\tcifs_dbg(FYI, \"Cleared reconnect bitmask for chan %u; now 0x%lx\\n\",\n\t\t chan_index, ses->chans_need_reconnect);\n}\n\nbool\ncifs_chan_needs_reconnect(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\treturn CIFS_CHAN_NEEDS_RECONNECT(ses, chan_index);\n}\n\nbool\ncifs_chan_is_iface_active(struct cifs_ses *ses,\n\t\t\t  struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index = cifs_ses_get_chan_index(ses, server);\n\n\treturn ses->chans[chan_index].iface &&\n\t\tses->chans[chan_index].iface->is_active;\n}\n\n \nint cifs_try_adding_channels(struct cifs_ses *ses)\n{\n\tstruct TCP_Server_Info *server = ses->server;\n\tint old_chan_count, new_chan_count;\n\tint left;\n\tint rc = 0;\n\tint tries = 0;\n\tsize_t iface_weight = 0, iface_min_speed = 0;\n\tstruct cifs_server_iface *iface = NULL, *niface = NULL;\n\tstruct cifs_server_iface *last_iface = NULL;\n\n\tspin_lock(&ses->chan_lock);\n\n\tnew_chan_count = old_chan_count = ses->chan_count;\n\tleft = ses->chan_max - ses->chan_count;\n\n\tif (left <= 0) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tcifs_dbg(FYI,\n\t\t\t \"ses already at max_channels (%zu), nothing to open\\n\",\n\t\t\t ses->chan_max);\n\t\treturn 0;\n\t}\n\n\tif (server->dialect < SMB30_PROT_ID) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tcifs_dbg(VFS, \"multichannel is not supported on this protocol version, use 3.0 or above\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_MULTI_CHANNEL)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tcifs_server_dbg(VFS, \"no multichannel support\\n\");\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\twhile (left > 0) {\n\n\t\ttries++;\n\t\tif (tries > 3*ses->chan_max) {\n\t\t\tcifs_dbg(VFS, \"too many channel open attempts (%d channels left to open)\\n\",\n\t\t\t\t left);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&ses->iface_lock);\n\t\tif (!ses->iface_count) {\n\t\t\tspin_unlock(&ses->iface_lock);\n\t\t\tcifs_dbg(VFS, \"server %s does not advertise interfaces\\n\",\n\t\t\t\t      ses->server->hostname);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!iface)\n\t\t\tiface = list_first_entry(&ses->iface_list, struct cifs_server_iface,\n\t\t\t\t\t\t iface_head);\n\t\tlast_iface = list_last_entry(&ses->iface_list, struct cifs_server_iface,\n\t\t\t\t\t     iface_head);\n\t\tiface_min_speed = last_iface->speed;\n\n\t\tlist_for_each_entry_safe_from(iface, niface, &ses->iface_list,\n\t\t\t\t    iface_head) {\n\t\t\t \n\t\t\tif (iface->rdma_capable != ses->server->rdma)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!iface->is_active ||\n\t\t\t    (is_ses_using_iface(ses, iface) &&\n\t\t\t     !iface->rss_capable))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tiface_weight = iface->speed / iface_min_speed;\n\n\t\t\tif (iface->weight_fulfilled >= iface_weight)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tkref_get(&iface->refcount);\n\n\t\t\tspin_unlock(&ses->iface_lock);\n\t\t\trc = cifs_ses_add_channel(ses, iface);\n\t\t\tspin_lock(&ses->iface_lock);\n\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"failed to open extra channel on iface:%pIS rc=%d\\n\",\n\t\t\t\t\t &iface->sockaddr,\n\t\t\t\t\t rc);\n\t\t\t\tkref_put(&iface->refcount, release_iface);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tiface->num_channels++;\n\t\t\tiface->weight_fulfilled++;\n\t\t\tcifs_dbg(VFS, \"successfully opened new channel on iface:%pIS\\n\",\n\t\t\t\t &iface->sockaddr);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (list_entry_is_head(iface, &ses->iface_list, iface_head)) {\n\t\t\tlist_for_each_entry(iface, &ses->iface_list, iface_head)\n\t\t\t\tiface->weight_fulfilled = 0;\n\t\t\tspin_unlock(&ses->iface_lock);\n\t\t\tiface = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ses->iface_lock);\n\n\t\tleft--;\n\t\tnew_chan_count++;\n\t}\n\n\treturn new_chan_count - old_chan_count;\n}\n\n \nint\ncifs_chan_update_iface(struct cifs_ses *ses, struct TCP_Server_Info *server)\n{\n\tunsigned int chan_index;\n\tsize_t iface_weight = 0, iface_min_speed = 0;\n\tstruct cifs_server_iface *iface = NULL;\n\tstruct cifs_server_iface *old_iface = NULL;\n\tstruct cifs_server_iface *last_iface = NULL;\n\tstruct sockaddr_storage ss;\n\tint rc = 0;\n\n\tspin_lock(&ses->chan_lock);\n\tchan_index = cifs_ses_get_chan_index(ses, server);\n\tif (!chan_index) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\n\tif (ses->chans[chan_index].iface) {\n\t\told_iface = ses->chans[chan_index].iface;\n\t\tif (old_iface->is_active) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\tspin_lock(&server->srv_lock);\n\tss = server->dstaddr;\n\tspin_unlock(&server->srv_lock);\n\n\tspin_lock(&ses->iface_lock);\n\tif (!ses->iface_count) {\n\t\tspin_unlock(&ses->iface_lock);\n\t\tcifs_dbg(VFS, \"server %s does not advertise interfaces\\n\", ses->server->hostname);\n\t\treturn 0;\n\t}\n\n\tlast_iface = list_last_entry(&ses->iface_list, struct cifs_server_iface,\n\t\t\t\t     iface_head);\n\tiface_min_speed = last_iface->speed;\n\n\t \n\tlist_for_each_entry(iface, &ses->iface_list, iface_head) {\n\t\tif (!chan_index) {\n\t\t\t \n\t\t\tif (!cifs_match_ipaddr((struct sockaddr *) &ss,\n\t\t\t\t\t       (struct sockaddr *) &iface->sockaddr))\n\t\t\t\tcontinue;\n\n\t\t\tkref_get(&iface->refcount);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (iface->rdma_capable != server->rdma)\n\t\t\tcontinue;\n\n\t\tif (!iface->is_active ||\n\t\t    (is_ses_using_iface(ses, iface) &&\n\t\t     !iface->rss_capable)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tiface_weight = iface->speed / iface_min_speed;\n\n\t\tif (iface->weight_fulfilled >= iface_weight)\n\t\t\tcontinue;\n\n\t\tkref_get(&iface->refcount);\n\t\tbreak;\n\t}\n\n\tif (list_entry_is_head(iface, &ses->iface_list, iface_head)) {\n\t\trc = 1;\n\t\tiface = NULL;\n\t\tcifs_dbg(FYI, \"unable to find a suitable iface\\n\");\n\t}\n\n\tif (!chan_index && !iface) {\n\t\tcifs_dbg(FYI, \"unable to get the interface matching: %pIS\\n\",\n\t\t\t &ss);\n\t\tspin_unlock(&ses->iface_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (old_iface && iface) {\n\t\tcifs_dbg(FYI, \"replacing iface: %pIS with %pIS\\n\",\n\t\t\t &old_iface->sockaddr,\n\t\t\t &iface->sockaddr);\n\n\t\told_iface->num_channels--;\n\t\tif (old_iface->weight_fulfilled)\n\t\t\told_iface->weight_fulfilled--;\n\t\tiface->num_channels++;\n\t\tiface->weight_fulfilled++;\n\n\t\tkref_put(&old_iface->refcount, release_iface);\n\t} else if (old_iface) {\n\t\tcifs_dbg(FYI, \"releasing ref to iface: %pIS\\n\",\n\t\t\t &old_iface->sockaddr);\n\n\t\told_iface->num_channels--;\n\t\tif (old_iface->weight_fulfilled)\n\t\t\told_iface->weight_fulfilled--;\n\n\t\tkref_put(&old_iface->refcount, release_iface);\n\t} else if (!chan_index) {\n\t\t \n\t\tcifs_dbg(FYI, \"referencing primary channel iface: %pIS\\n\",\n\t\t\t &iface->sockaddr);\n\t\tiface->num_channels++;\n\t\tiface->weight_fulfilled++;\n\t} else {\n\t\tWARN_ON(!iface);\n\t\tcifs_dbg(FYI, \"adding new iface: %pIS\\n\", &iface->sockaddr);\n\t}\n\tspin_unlock(&ses->iface_lock);\n\n\tspin_lock(&ses->chan_lock);\n\tchan_index = cifs_ses_get_chan_index(ses, server);\n\tses->chans[chan_index].iface = iface;\n\n\t \n\tif (!iface && SERVER_IS_CHAN(server))\n\t\tses->chans[chan_index].server = NULL;\n\n\tspin_unlock(&ses->chan_lock);\n\n\tif (!iface && SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server, false);\n\n\treturn rc;\n}\n\n \nstruct cifs_chan *\ncifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server)\n{\n\tint i;\n\n\tspin_lock(&ses->chan_lock);\n\tfor (i = 0; i < ses->chan_count; i++) {\n\t\tif (ses->chans[i].server == server) {\n\t\t\tspin_unlock(&ses->chan_lock);\n\t\t\treturn &ses->chans[i];\n\t\t}\n\t}\n\tspin_unlock(&ses->chan_lock);\n\treturn NULL;\n}\n\nstatic int\ncifs_ses_add_channel(struct cifs_ses *ses,\n\t\t     struct cifs_server_iface *iface)\n{\n\tstruct TCP_Server_Info *chan_server;\n\tstruct cifs_chan *chan;\n\tstruct smb3_fs_context *ctx;\n\tstatic const char unc_fmt[] = \"\\\\%s\\\\foo\";\n\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)&iface->sockaddr;\n\tstruct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&iface->sockaddr;\n\tsize_t len;\n\tint rc;\n\tunsigned int xid = get_xid();\n\n\tif (iface->sockaddr.ss_family == AF_INET)\n\t\tcifs_dbg(FYI, \"adding channel to ses %p (speed:%zu bps rdma:%s ip:%pI4)\\n\",\n\t\t\t ses, iface->speed, iface->rdma_capable ? \"yes\" : \"no\",\n\t\t\t &ipv4->sin_addr);\n\telse\n\t\tcifs_dbg(FYI, \"adding channel to ses %p (speed:%zu bps rdma:%s ip:%pI6)\\n\",\n\t\t\t ses, iface->speed, iface->rdma_capable ? \"yes\" : \"no\",\n\t\t\t &ipv6->sin6_addr);\n\n\t \n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_xid;\n\t}\n\n\t \n\tctx->nosharesock = true;\n\n\t \n\tctx->domainauto = ses->domainAuto;\n\tctx->domainname = ses->domainName;\n\n\t \n\tctx->server_hostname = \"\";\n\n\tctx->username = ses->user_name;\n\tctx->password = ses->password;\n\tctx->sectype = ses->sectype;\n\tctx->sign = ses->sign;\n\n\t \n\t \n\tlen = sizeof(unc_fmt) + SERVER_NAME_LEN_WITH_NULL;\n\tctx->UNC = kzalloc(len, GFP_KERNEL);\n\tif (!ctx->UNC) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_ctx;\n\t}\n\tscnprintf(ctx->UNC, len, unc_fmt, ses->ip_addr);\n\tctx->prepath = \"\";\n\n\t \n\tctx->vals = ses->server->vals;\n\tctx->ops = ses->server->ops;\n\n\tctx->noblocksnd = ses->server->noblocksnd;\n\tctx->noautotune = ses->server->noautotune;\n\tctx->sockopt_tcp_nodelay = ses->server->tcp_nodelay;\n\tctx->echo_interval = ses->server->echo_interval / HZ;\n\tctx->max_credits = ses->server->max_credits;\n\n\t \n\tctx->local_nls = ses->local_nls;\n\n\t \n\tctx->rdma = iface->rdma_capable;\n\tmemcpy(&ctx->dstaddr, &iface->sockaddr, sizeof(ctx->dstaddr));\n\n\t \n\tmemcpy(&ctx->client_guid, ses->server->client_guid,\n\t       sizeof(ctx->client_guid));\n\tctx->use_client_guid = true;\n\n\tchan_server = cifs_get_tcp_session(ctx, ses->server);\n\n\tspin_lock(&ses->chan_lock);\n\tchan = &ses->chans[ses->chan_count];\n\tchan->server = chan_server;\n\tif (IS_ERR(chan->server)) {\n\t\trc = PTR_ERR(chan->server);\n\t\tchan->server = NULL;\n\t\tspin_unlock(&ses->chan_lock);\n\t\tgoto out;\n\t}\n\tchan->iface = iface;\n\tses->chan_count++;\n\tatomic_set(&ses->chan_seq, 0);\n\n\t \n\tcifs_chan_set_need_reconnect(ses, chan->server);\n\n\tspin_unlock(&ses->chan_lock);\n\n\tmutex_lock(&ses->session_mutex);\n\t \n\trc = smb311_crypto_shash_allocate(chan->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: crypto alloc failed\\n\", __func__);\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\trc = cifs_negotiate_protocol(xid, ses, chan->server);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, chan->server, ses->local_nls);\n\n\tmutex_unlock(&ses->session_mutex);\n\nout:\n\tif (rc && chan->server) {\n\t\t \n\t\tcancel_delayed_work_sync(&chan->server->echo);\n\t\tcancel_delayed_work_sync(&chan->server->reconnect);\n\n\t\tspin_lock(&ses->chan_lock);\n\t\t \n\t\tcifs_chan_clear_need_reconnect(ses, chan->server);\n\t\tses->chan_count--;\n\t\t \n\t\tWARN_ON(ses->chan_count < 1);\n\t\tspin_unlock(&ses->chan_lock);\n\n\t\tcifs_put_tcp_session(chan->server, 0);\n\t}\n\n\tkfree(ctx->UNC);\nout_free_ctx:\n\tkfree(ctx);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses,\n\t\t\t     struct TCP_Server_Info *server,\n\t\t\t     SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t \n\t \n\t \n\t \n\t \n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t \n\n\t \n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t \n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  \n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  \n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t \n\tif (ses->domainName == NULL) {\n\t\t \n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;   \n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t \n\n\t \n\tif (ses->user_name == NULL) {\n\t\t \n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  \n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint len;\n\n\t \n\t \n\t \n\tif (ses->user_name != NULL) {\n\t\tlen = strscpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tif (WARN_ON_ONCE(len < 0))\n\t\t\tlen = CIFS_MAX_USERNAME_LEN - 1;\n\t\tbcc_ptr += len;\n\t}\n\t \n\t*bcc_ptr = 0;\n\tbcc_ptr++;  \n\n\t \n\tif (ses->domainName != NULL) {\n\t\tlen = strscpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tif (WARN_ON_ONCE(len < 0))\n\t\t\tlen = CIFS_MAX_DOMAINNAME_LEN - 1;\n\t\tbcc_ptr += len;\n\t}  \n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t \n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kmalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tmemcpy(ses->serverOS, bcc_ptr, len);\n\t\tses->serverOS[len] = 0;\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kmalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS) {\n\t\tmemcpy(ses->serverNOS, bcc_ptr, len);\n\t\tses->serverNOS[len] = 0;\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t \n\t \n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}\n#endif  \n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset;  \n\tunsigned int tilen;  \n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\t__u32 server_flags;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tserver_flags = le32_to_cpu(pblob->NegotiateFlags);\n\tcifs_dbg(FYI, \"%s: negotiate=0x%08x challenge=0x%08x\\n\", __func__,\n\t\t ses->ntlmssp->client_flags, server_flags);\n\n\tif ((ses->ntlmssp->client_flags & (NTLMSSP_NEGOTIATE_SEAL | NTLMSSP_NEGOTIATE_SIGN)) &&\n\t    (!(server_flags & NTLMSSP_NEGOTIATE_56) && !(server_flags & NTLMSSP_NEGOTIATE_128))) {\n\t\tcifs_dbg(VFS, \"%s: requested signing/encryption but server did not return either 56-bit or 128-bit session key size\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!(server_flags & NTLMSSP_NEGOTIATE_NTLM) && !(server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC)) {\n\t\tcifs_dbg(VFS, \"%s: server does not seem to support either NTLMv1 or NTLMv2\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (ses->server->sign && !(server_flags & NTLMSSP_NEGOTIATE_SIGN)) {\n\t\tcifs_dbg(VFS, \"%s: forced packet signing but server does not seem to support it\\n\",\n\t\t\t __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif ((ses->ntlmssp->client_flags & NTLMSSP_NEGOTIATE_KEY_XCH) &&\n\t    !(server_flags & NTLMSSP_NEGOTIATE_KEY_XCH))\n\t\tpr_warn_once(\"%s: authentication has been weakened as server does not support key exchange\\n\",\n\t\t\t     __func__);\n\n\tses->ntlmssp->server_flags = server_flags;\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t \n\t \n\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\\n\",\n\t\t\t tioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tkfree_sensitive(ses->auth_key.response);\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}\n\nstatic int size_of_ntlmssp_blob(struct cifs_ses *ses, int base_size)\n{\n\tint sz = base_size + ses->auth_key.len\n\t\t- CIFS_SESS_KEY_SIZE + CIFS_CPHTXT_SIZE + 2;\n\n\tif (ses->domainName)\n\t\tsz += sizeof(__le16) * strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\telse\n\t\tsz += sizeof(__le16);\n\n\tif (ses->user_name)\n\t\tsz += sizeof(__le16) * strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\telse\n\t\tsz += sizeof(__le16);\n\n\tif (ses->workstation_name[0])\n\t\tsz += sizeof(__le16) * strnlen(ses->workstation_name,\n\t\t\t\t\t       ntlmssp_workstation_name_size(ses));\n\telse\n\t\tsz += sizeof(__le16);\n\n\treturn sz;\n}\n\nstatic inline void cifs_security_buffer_from_str(SECURITY_BUFFER *pbuf,\n\t\t\t\t\t\t char *str_value,\n\t\t\t\t\t\t int str_length,\n\t\t\t\t\t\t unsigned char *pstart,\n\t\t\t\t\t\t unsigned char **pcur,\n\t\t\t\t\t\t const struct nls_table *nls_cp)\n{\n\tunsigned char *tmp = pstart;\n\tint len;\n\n\tif (!pbuf)\n\t\treturn;\n\n\tif (!pcur)\n\t\tpcur = &tmp;\n\n\tif (!str_value) {\n\t\tpbuf->BufferOffset = cpu_to_le32(*pcur - pstart);\n\t\tpbuf->Length = 0;\n\t\tpbuf->MaximumLength = 0;\n\t\t*pcur += sizeof(__le16);\n\t} else {\n\t\tlen = cifs_strtoUTF16((__le16 *)*pcur,\n\t\t\t\t      str_value,\n\t\t\t\t      str_length,\n\t\t\t\t      nls_cp);\n\t\tlen *= sizeof(__le16);\n\t\tpbuf->BufferOffset = cpu_to_le32(*pcur - pstart);\n\t\tpbuf->Length = cpu_to_le16(len);\n\t\tpbuf->MaximumLength = cpu_to_le16(len);\n\t\t*pcur += len;\n\t}\n}\n\n \n\nint build_ntlmssp_negotiate_blob(unsigned char **pbuffer,\n\t\t\t\t u16 *buflen,\n\t\t\t\t struct cifs_ses *ses,\n\t\t\t\t struct TCP_Server_Info *server,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tNEGOTIATE_MESSAGE *sec_blob;\n\t__u32 flags;\n\tunsigned char *tmp;\n\tint len;\n\n\tlen = size_of_ntlmssp_blob(ses, sizeof(NEGOTIATE_MESSAGE));\n\t*pbuffer = kmalloc(len, GFP_KERNEL);\n\tif (!*pbuffer) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP allocation\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlm_neg_ret;\n\t}\n\tsec_blob = (NEGOTIATE_MESSAGE *)*pbuffer;\n\n\tmemset(*pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t \n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_ALWAYS_SIGN | NTLMSSP_NEGOTIATE_SEAL |\n\t\tNTLMSSP_NEGOTIATE_SIGN;\n\tif (!server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\ttmp = *pbuffer + sizeof(NEGOTIATE_MESSAGE);\n\tses->ntlmssp->client_flags = flags;\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\t \n\tcifs_security_buffer_from_str(&sec_blob->DomainName,\n\t\t\t\t      NULL,\n\t\t\t\t      CIFS_MAX_DOMAINNAME_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\tcifs_security_buffer_from_str(&sec_blob->WorkstationName,\n\t\t\t\t      NULL,\n\t\t\t\t      CIFS_MAX_WORKSTATION_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\t*buflen = tmp - *pbuffer;\nsetup_ntlm_neg_ret:\n\treturn rc;\n}\n\n \nint build_ntlmssp_smb3_negotiate_blob(unsigned char **pbuffer,\n\t\t\t\t u16 *buflen,\n\t\t\t\t struct cifs_ses *ses,\n\t\t\t\t struct TCP_Server_Info *server,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct negotiate_message *sec_blob;\n\t__u32 flags;\n\tunsigned char *tmp;\n\tint len;\n\n\tlen = size_of_ntlmssp_blob(ses, sizeof(struct negotiate_message));\n\t*pbuffer = kmalloc(len, GFP_KERNEL);\n\tif (!*pbuffer) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP allocation\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlm_smb3_neg_ret;\n\t}\n\tsec_blob = (struct negotiate_message *)*pbuffer;\n\n\tmemset(*pbuffer, 0, sizeof(struct negotiate_message));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t \n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_ALWAYS_SIGN | NTLMSSP_NEGOTIATE_SEAL |\n\t\tNTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_VERSION;\n\tif (!server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\tsec_blob->Version.ProductMajorVersion = LINUX_VERSION_MAJOR;\n\tsec_blob->Version.ProductMinorVersion = LINUX_VERSION_PATCHLEVEL;\n\tsec_blob->Version.ProductBuild = cpu_to_le16(SMB3_PRODUCT_BUILD);\n\tsec_blob->Version.NTLMRevisionCurrent = NTLMSSP_REVISION_W2K3;\n\n\ttmp = *pbuffer + sizeof(struct negotiate_message);\n\tses->ntlmssp->client_flags = flags;\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\t \n\tcifs_security_buffer_from_str(&sec_blob->DomainName,\n\t\t\t\t      NULL,\n\t\t\t\t      CIFS_MAX_DOMAINNAME_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\tcifs_security_buffer_from_str(&sec_blob->WorkstationName,\n\t\t\t\t      NULL,\n\t\t\t\t      CIFS_MAX_WORKSTATION_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\t*buflen = tmp - *pbuffer;\nsetup_ntlm_smb3_neg_ret:\n\treturn rc;\n}\n\n\n \nint build_ntlmssp_auth_blob(unsigned char **pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   struct TCP_Server_Info *server,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob;\n\t__u32 flags;\n\tunsigned char *tmp;\n\tint len;\n\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\n\tlen = size_of_ntlmssp_blob(ses, sizeof(AUTHENTICATE_MESSAGE));\n\t*pbuffer = kmalloc(len, GFP_KERNEL);\n\tif (!*pbuffer) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP allocation\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\tsec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = ses->ntlmssp->server_flags | NTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED;\n\t \n\tflags = flags & ~NTLMSSP_NEGOTIATE_VERSION;\n\ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(tmp - *pbuffer);\n\tif (ses->user_name != NULL) {\n\t\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\tsec_blob->NtChallengeResponse.Length =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\t \n\t\tsec_blob->NtChallengeResponse.Length = 0;\n\t\tsec_blob->NtChallengeResponse.MaximumLength = 0;\n\t}\n\n\tcifs_security_buffer_from_str(&sec_blob->DomainName,\n\t\t\t\t      ses->domainName,\n\t\t\t\t      CIFS_MAX_DOMAINNAME_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\tcifs_security_buffer_from_str(&sec_blob->UserName,\n\t\t\t\t      ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN,\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\tcifs_security_buffer_from_str(&sec_blob->WorkstationName,\n\t\t\t\t      ses->workstation_name,\n\t\t\t\t      ntlmssp_workstation_name_size(ses),\n\t\t\t\t      *pbuffer, &tmp,\n\t\t\t\t      nls_cp);\n\n\tif ((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) &&\n\t    (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess) &&\n\t    !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\n\t*buflen = tmp - *pbuffer;\nsetup_ntlmv2_ret:\n\treturn rc;\n}\n\nenum securityEnum\ncifs_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}\n\nstruct sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct sess_data *);\n\tint result;\n\n\t \n\tint buf0_type;\n\tstruct kvec iov[3];\n};\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t \n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t \n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tcifs_small_buf_release(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\tstruct kvec *iov = sess_data->iov;\n\n\t \n\tif (sess_data->buf0_type != CIFS_NO_BUFFER && iov[0].iov_base)\n\t\tmemzero_explicit(iov[0].iov_base, iov[0].iov_len);\n\n\tfree_rsp_buf(sess_data->buf0_type, iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree_sensitive(iov[2].iov_base);\n}\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\n\tcifs_server_lock(server);\n\tif (!server->session_estab) {\n\t\tif (server->sign) {\n\t\t\tserver->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!server->session_key.response) {\n\t\t\t\tcifs_server_unlock(server);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tserver->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tserver->sequence_number = 0x2;\n\t\tserver->session_estab = true;\n\t}\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\treturn 0;\n}\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tbe32_add_cpu(&smb_buf->smb_buf_length, count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3  ,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\nstatic void\nsess_auth_ntlmv2(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t \n\t \n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, server, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\n\t \n\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\n\tif (ses->user_name != NULL) {\n\t\t \n\t\trc = setup_ntlmv2_rsp(ses, sess_data->nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"Error %d during NTLMv2 authentication\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\t \n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength = 0;\n\t}\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tif (!IS_ALIGNED(sess_data->iov[0].iov_len, 2)) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\");  \n\n\tses->Suid = smb_buf->Uid;    \n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t \n\tif (bytes_remaining == 0) {\n\t\t \n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t \n\t\tif (!IS_ALIGNED((unsigned long)bcc_ptr - (unsigned long)smb_buf, 2)) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nsess_auth_kerberos(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\tstruct key *spnego_key = NULL;\n\tstruct cifs_spnego_msg *msg;\n\tu16 blob_len;\n\n\t \n\t \n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, server, pSMB);\n\n\tspnego_key = cifs_get_spnego_key(ses, server);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t \n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS, \"incorrect version of cifs.upcall (expected %d but got %d)\\n\",\n\t\t\t CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\\n\",\n\t\t\t msg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities = cpu_to_le32(capabilities);\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t \n\t\tif (!IS_ALIGNED(sess_data->iov[0].iov_len + sess_data->iov[1].iov_len, 2)) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\t\tunicode_domain_string(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\t \n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\");  \n\n\tses->Suid = smb_buf->Uid;    \n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_put_spnego_key;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\t \n\tif (bytes_remaining == 0) {\n\t\t \n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t \n\t\tif (!IS_ALIGNED((unsigned long)bcc_ptr - (unsigned long)smb_buf, 2)) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#endif  \n\n \nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\tcapabilities = cifs_ssetup_hdr(ses, server, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t \n\tif (!IS_ALIGNED(sess_data->iov[0].iov_len + sess_data->iov[1].iov_len, 2)) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tunsigned char *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t \n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t \n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t \n\trc = build_ntlmssp_negotiate_blob(&ntlmsspblob,\n\t\t\t\t     &blob_len, ses, server,\n\t\t\t\t     sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t \n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tses->Suid = smb_buf->Uid;    \n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\n\nout_free_ntlmsspblob:\n\tkfree_sensitive(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t \n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree_sensitive(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tunsigned char *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");\n\n\t \n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\trc = build_ntlmssp_auth_blob(&ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, server,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t \n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\");  \n\n\tif (ses->Suid != smb_buf->Uid) {\n\t\tses->Suid = smb_buf->Uid;\n\t\tcifs_dbg(FYI, \"UID changed! new UID = %llu\\n\", ses->Suid);\n\t}\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\n\t \n\tif (bytes_remaining == 0) {\n\t\t \n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t \n\t\tif (!IS_ALIGNED((unsigned long)bcc_ptr - (unsigned long)smb_buf, 2)) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\nout_free_ntlmsspblob:\n\tkfree_sensitive(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc)\n\t\trc = sess_establish_session(sess_data);\n\n\t \n\tkfree_sensitive(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree_sensitive(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic int select_sec(struct sess_data *sess_data)\n{\n\tint type;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\n\ttype = cifs_select_sectype(server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS, \"Unable to select appropriate authentication method!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n#endif  \n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nint CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct sess_data *sess_data;\n\n\tif (ses == NULL) {\n\t\tWARN(1, \"%s: ses == NULL!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->server = server;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\trc = select_sec(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\t \n\trc = sess_data->result;\n\nout:\n\tkfree_sensitive(sess_data);\n\treturn rc;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}