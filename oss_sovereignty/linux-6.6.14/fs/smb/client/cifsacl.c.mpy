{
  "module_name": "cifsacl.c",
  "hash_id": "af7e1cd91b2672b539fdeac0b770383e37ee56ab67b197b5a54296988b55af11",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifsacl.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <uapi/linux/posix_acl.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <keys/user-type.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"fs_context.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n\n \nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n \nstatic const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\n \nstatic const struct cifs_sid sid_unix_users = {1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct cifs_sid sid_unix_groups = { 1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \n\n \n\n \nstatic const struct cifs_sid sid_unix_NFS_users = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct cifs_sid sid_unix_NFS_groups = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n \nstatic const struct cifs_sid sid_unix_NFS_mode = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\nstatic const struct cred *root_cred;\n\nstatic int\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\n\t \n\tif (prep->datalen <= sizeof(key->payload)) {\n\t\tkey->payload.data[0] = NULL;\n\t\tmemcpy(&key->payload, prep->data, prep->datalen);\n\t} else {\n\t\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\treturn -ENOMEM;\n\t\tkey->payload.data[0] = payload;\n\t}\n\n\tkey->datalen = prep->datalen;\n\treturn 0;\n}\n\nstatic inline void\ncifs_idmap_key_destroy(struct key *key)\n{\n\tif (key->datalen > sizeof(key->payload))\n\t\tkfree(key->payload.data[0]);\n}\n\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t \n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t \n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t \n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}\n\n \nstatic int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t \n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;  \n}\n\nstatic bool\nis_well_known_sid(const struct cifs_sid *psid, uint32_t *puid, bool is_group)\n{\n\tint i;\n\tint num_subauth;\n\tconst struct cifs_sid *pwell_known_sid;\n\n\tif (!psid || (puid == NULL))\n\t\treturn false;\n\n\tnum_subauth = psid->num_subauth;\n\n\t \n\tif (num_subauth == 2) {\n\t\tif (is_group)\n\t\t\tpwell_known_sid = &sid_unix_groups;\n\t\telse\n\t\t\tpwell_known_sid = &sid_unix_users;\n\t} else if (num_subauth == 3) {\n\t\tif (is_group)\n\t\t\tpwell_known_sid = &sid_unix_NFS_groups;\n\t\telse\n\t\t\tpwell_known_sid = &sid_unix_NFS_users;\n\t} else\n\t\treturn false;\n\n\t \n\tif (psid->revision != pwell_known_sid->revision)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (psid->authority[i] != pwell_known_sid->authority[i]) {\n\t\t\tcifs_dbg(FYI, \"auth %d did not match\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (num_subauth == 2) {\n\t\tif (psid->sub_auth[0] != pwell_known_sid->sub_auth[0])\n\t\t\treturn false;\n\n\t\t*puid = le32_to_cpu(psid->sub_auth[1]);\n\t} else   {\n\t\t*puid = le32_to_cpu(psid->sub_auth[0]);\n\t\tif ((psid->sub_auth[0] != pwell_known_sid->sub_auth[0]) ||\n\t\t    (psid->sub_auth[1] != pwell_known_sid->sub_auth[1]))\n\t\t\treturn false;\n\n\t\t*puid = le32_to_cpu(psid->sub_auth[2]);\n\t}\n\n\tcifs_dbg(FYI, \"Unix UID %d returned from SID\\n\", *puid);\n\treturn true;  \n}\n\nstatic __u16\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\t__u16 size = 1 + 1 + 6;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n\tsize += (dst->num_subauth * 4);\n\n\treturn size;\n}\n\nstatic int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1];  \n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t \n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload :\n\t\t(struct cifs_sid *)sidkey->payload.data[0];\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}\n\nint\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc = 0;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->ctx->linux_uid;\n\tkgid_t fgid = cifs_sb->ctx->linux_gid;\n\n\t \n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL) ||\n\t    (cifs_sb_master_tcon(cifs_sb)->posix_extensions)) {\n\t\tuint32_t unix_id;\n\t\tbool is_group;\n\n\t\tif (sidtype != SIDOWNER)\n\t\t\tis_group = true;\n\t\telse\n\t\t\tis_group = false;\n\n\t\tif (is_well_known_sid(psid, &unix_id, is_group) == false)\n\t\t\tgoto try_upcall_to_get_id;\n\n\t\tif (is_group) {\n\t\t\tkgid_t gid;\n\t\t\tgid_t id;\n\n\t\t\tid = (gid_t)unix_id;\n\t\t\tgid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid)) {\n\t\t\t\tfgid = gid;\n\t\t\t\tgoto got_valid_id;\n\t\t\t}\n\t\t} else {\n\t\t\tkuid_t uid;\n\t\t\tuid_t id;\n\n\t\t\tid = (uid_t)unix_id;\n\t\t\tuid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid)) {\n\t\t\t\tfuid = uid;\n\t\t\t\tgoto got_valid_id;\n\t\t\t}\n\t\t}\n\t\t \n\t}\n\ntry_upcall_to_get_id:\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t \n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.data[0], sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.data[0], sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t \ngot_valid_id:\n\trc = 0;\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn rc;\n}\n\nint\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t \n\tcred = prepare_kernel_cred(&init_task);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t \n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nvoid\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}\n\n \nstatic __u32 copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd,\n\t\t\t\t__u32 sidsoffset,\n\t\t\t\tstruct cifs_sid *pownersid,\n\t\t\t\tstruct cifs_sid *pgrpsid)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t \n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t \n\tif (pownersid)\n\t\towner_sid_ptr = pownersid;\n\telse\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t \n\tif (pgrpsid)\n\t\tgroup_sid_ptr = pgrpsid;\n\telse\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn sidsoffset + (2 * sizeof(struct cifs_sid));\n}\n\n\n \nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pdenied, umode_t mask)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t \n\n\t \n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL &&\n\t\t\t\t!(*pmode & mask & 0777))\n\t\t\t*pdenied |= mask & 0777;\n\n\t\tif (((flags & GENERIC_WRITE) ||\n\t\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS)) &&\n\t\t\t\t!(*pmode & mask & 0222))\n\t\t\t*pdenied |= mask & 0222;\n\n\t\tif (((flags & GENERIC_READ) ||\n\t\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS)) &&\n\t\t\t\t!(*pmode & mask & 0444))\n\t\t\t*pdenied |= mask & 0444;\n\n\t\tif (((flags & GENERIC_EXECUTE) ||\n\t\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS)) &&\n\t\t\t\t!(*pmode & mask & 0111))\n\t\t\t*pdenied |= mask & 0111;\n\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t \n\n\tif ((flags & GENERIC_ALL) &&\n\t\t\t!(*pdenied & mask & 0777)) {\n\t\t*pmode |= mask & 0777;\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\n\tif (((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS)) &&\n\t\t\t!(*pdenied & mask & 0222))\n\t\t*pmode |= mask & 0222;\n\n\tif (((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS)) &&\n\t\t\t!(*pdenied & mask & 0444))\n\t\t*pmode |= mask & 0444;\n\n\tif (((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS)) &&\n\t\t\t!(*pdenied & mask & 0111))\n\t\t*pmode |= mask & 0111;\n\n\t \n\tif (flags & FILE_DELETE_CHILD) {\n\t\tif (mask == ACL_OWNER_MASK) {\n\t\t\tif (!(*pdenied & 01000))\n\t\t\t\t*pmode |= 01000;\n\t\t} else if (!(*pdenied & 01000)) {\n\t\t\t*pmode &= ~01000;\n\t\t\t*pdenied |= 01000;\n\t\t}\n\t}\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now %04o\\n\", flags, *pmode);\n\treturn;\n}\n\n \n\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t \n\t*pace_flags = 0x0;\n\n\t \n\tmode &= bits_to_use;\n\n\t \n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: %04o, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}\n\nstatic __u16 cifs_copy_ace(struct cifs_ace *dst, struct cifs_ace *src, struct cifs_sid *psid)\n{\n\t__u16 size = 1 + 1 + 2 + 4;\n\n\tdst->type = src->type;\n\tdst->flags = src->flags;\n\tdst->access_req = src->access_req;\n\n\t \n\tif (psid)\n\t\tsize += cifs_copy_sid(&dst->sid, psid);\n\telse\n\t\tsize += cifs_copy_sid(&dst->sid, &src->sid);\n\n\tdst->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode,\n\t\t\tumode_t bits, __u8 access_type,\n\t\t\tbool allow_delete_child)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = access_type;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\n\tif (access_type == ACCESS_ALLOWED && allow_delete_child)\n\t\taccess_req |= FILE_DELETE_CHILD;\n\n\tif (access_type == ACCESS_ALLOWED && !access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\telse if (access_type == ACCESS_DENIED)\n\t\taccess_req &= ~SET_MINIMUM_RIGHTS;\n\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\n\n#ifdef CONFIG_CIFS_DEBUG2\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t \n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t \n\t}\n\n\treturn;\n}\n#endif\n\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr, bool mode_from_special_sid)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t \n\n\tif (!pdacl) {\n\t\t \n\t\tfattr->cf_mode |= 0777;\n\t\treturn;\n\t}\n\n\t \n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t \n\tfattr->cf_mode &= ~(0777);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t denied_mode = 0;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc_array(num_aces, sizeof(struct cifs_ace *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (mode_from_special_sid &&\n\t\t\t    (compare_sids(&(ppace[i]->sid),\n\t\t\t\t\t  &sid_unix_NFS_mode) == 0)) {\n\t\t\t\t \n\t\t\t\tfattr->cf_mode &= ~07777;\n\t\t\t\tfattr->cf_mode |=\n\t\t\t\t\tle32_to_cpu(ppace[i]->sid.sub_auth[2]);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0) {\n\t\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type,\n\t\t\t\t\t\t\t&fattr->cf_mode,\n\t\t\t\t\t\t\t&denied_mode,\n\t\t\t\t\t\t\tACL_OWNER_MASK);\n\t\t\t\t} else if (compare_sids(&(ppace[i]->sid), pgrpsid) == 0) {\n\t\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type,\n\t\t\t\t\t\t\t&fattr->cf_mode,\n\t\t\t\t\t\t\t&denied_mode,\n\t\t\t\t\t\t\tACL_GROUP_MASK);\n\t\t\t\t} else if ((compare_sids(&(ppace[i]->sid), &sid_everyone) == 0) ||\n\t\t\t\t\t\t(compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)) {\n\t\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type,\n\t\t\t\t\t\t\t&fattr->cf_mode,\n\t\t\t\t\t\t\t&denied_mode,\n\t\t\t\t\t\t\tACL_EVERYONE_MASK);\n\t\t\t\t}\n\t\t\t}\n\n\n \n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}\n\nunsigned int setup_authusers_ACE(struct cifs_ace *pntace)\n{\n\tint i;\n\tunsigned int ace_size = 20;\n\n\tpntace->type = ACCESS_ALLOWED_ACE_TYPE;\n\tpntace->flags = 0x0;\n\tpntace->access_req = cpu_to_le32(GENERIC_ALL);\n\tpntace->sid.num_subauth = 1;\n\tpntace->sid.revision = 1;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] =  sid_authusers.authority[i];\n\n\tpntace->sid.sub_auth[0] =  sid_authusers.sub_auth[0];\n\n\t \n\tpntace->size = cpu_to_le16(ace_size);\n\treturn ace_size;\n}\n\n \nunsigned int setup_special_mode_ACE(struct cifs_ace *pntace, __u64 nmode)\n{\n\tint i;\n\tunsigned int ace_size = 28;\n\n\tpntace->type = ACCESS_DENIED_ACE_TYPE;\n\tpntace->flags = 0x0;\n\tpntace->access_req = 0;\n\tpntace->sid.num_subauth = 3;\n\tpntace->sid.revision = 1;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = sid_unix_NFS_mode.authority[i];\n\n\tpntace->sid.sub_auth[0] = sid_unix_NFS_mode.sub_auth[0];\n\tpntace->sid.sub_auth[1] = sid_unix_NFS_mode.sub_auth[1];\n\tpntace->sid.sub_auth[2] = cpu_to_le32(nmode & 07777);\n\n\t \n\tpntace->size = cpu_to_le16(ace_size);\n\treturn ace_size;\n}\n\nunsigned int setup_special_user_owner_ACE(struct cifs_ace *pntace)\n{\n\tint i;\n\tunsigned int ace_size = 28;\n\n\tpntace->type = ACCESS_ALLOWED_ACE_TYPE;\n\tpntace->flags = 0x0;\n\tpntace->access_req = cpu_to_le32(GENERIC_ALL);\n\tpntace->sid.num_subauth = 3;\n\tpntace->sid.revision = 1;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = sid_unix_NFS_users.authority[i];\n\n\tpntace->sid.sub_auth[0] = sid_unix_NFS_users.sub_auth[0];\n\tpntace->sid.sub_auth[1] = sid_unix_NFS_users.sub_auth[1];\n\tpntace->sid.sub_auth[2] = cpu_to_le32(current_fsgid().val);\n\n\t \n\tpntace->size = cpu_to_le16(ace_size);\n\treturn ace_size;\n}\n\nstatic void populate_new_aces(char *nacl_base,\n\t\tstruct cifs_sid *pownersid,\n\t\tstruct cifs_sid *pgrpsid,\n\t\t__u64 *pnmode, u32 *pnum_aces, u16 *pnsize,\n\t\tbool modefromsid)\n{\n\t__u64 nmode;\n\tu32 num_aces = 0;\n\tu16 nsize = 0;\n\t__u64 user_mode;\n\t__u64 group_mode;\n\t__u64 other_mode;\n\t__u64 deny_user_mode = 0;\n\t__u64 deny_group_mode = 0;\n\tbool sticky_set = false;\n\tstruct cifs_ace *pnntace = NULL;\n\n\tnmode = *pnmode;\n\tnum_aces = *pnum_aces;\n\tnsize = *pnsize;\n\n\tif (modefromsid) {\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\t\tnsize += setup_special_mode_ACE(pnntace, nmode);\n\t\tnum_aces++;\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\t\tnsize += setup_authusers_ACE(pnntace);\n\t\tnum_aces++;\n\t\tgoto set_size;\n\t}\n\n\t \n\n\tif (!memcmp(pownersid, pgrpsid, sizeof(struct cifs_sid))) {\n\t\t \n\t\tuser_mode = nmode & (nmode << 3) & 0700;\n\t\tgroup_mode = nmode & (nmode >> 3) & 0070;\n\t} else {\n\t\tuser_mode = nmode & 0700;\n\t\tgroup_mode = nmode & 0070;\n\t}\n\n\tother_mode = nmode & 0007;\n\n\t \n\tdeny_user_mode = ~(user_mode) & ((group_mode << 3) | (other_mode << 6)) & 0700;\n\tdeny_group_mode = ~(group_mode) & (other_mode << 3) & 0070;\n\n\t*pnmode = user_mode | group_mode | other_mode | (nmode & ~0777);\n\n\t \n\tif (nmode & 01000)\n\t\tsticky_set = true;\n\n\tif (deny_user_mode) {\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\t\tnsize += fill_ace_for_sid(pnntace, pownersid, deny_user_mode,\n\t\t\t\t0700, ACCESS_DENIED, false);\n\t\tnum_aces++;\n\t}\n\n\t \n\tif (deny_group_mode && !(deny_group_mode & (user_mode >> 3))) {\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\t\tnsize += fill_ace_for_sid(pnntace, pgrpsid, deny_group_mode,\n\t\t\t\t0070, ACCESS_DENIED, false);\n\t\tnum_aces++;\n\t}\n\n\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\tnsize += fill_ace_for_sid(pnntace, pownersid, user_mode,\n\t\t\t0700, ACCESS_ALLOWED, true);\n\tnum_aces++;\n\n\t \n\tif (deny_group_mode && (deny_group_mode & (user_mode >> 3))) {\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\t\tnsize += fill_ace_for_sid(pnntace, pgrpsid, deny_group_mode,\n\t\t\t\t0070, ACCESS_DENIED, false);\n\t\tnum_aces++;\n\t}\n\n\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\tnsize += fill_ace_for_sid(pnntace, pgrpsid, group_mode,\n\t\t\t0070, ACCESS_ALLOWED, !sticky_set);\n\tnum_aces++;\n\n\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\tnsize += fill_ace_for_sid(pnntace, &sid_everyone, other_mode,\n\t\t\t0007, ACCESS_ALLOWED, !sticky_set);\n\tnum_aces++;\n\nset_size:\n\t*pnum_aces = num_aces;\n\t*pnsize = nsize;\n}\n\nstatic __u16 replace_sids_and_copy_aces(struct cifs_acl *pdacl, struct cifs_acl *pndacl,\n\t\tstruct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\tstruct cifs_sid *pnownersid, struct cifs_sid *pngrpsid)\n{\n\tint i;\n\tu16 size = 0;\n\tstruct cifs_ace *pntace = NULL;\n\tchar *acl_base = NULL;\n\tu32 src_num_aces = 0;\n\tu16 nsize = 0;\n\tstruct cifs_ace *pnntace = NULL;\n\tchar *nacl_base = NULL;\n\tu16 ace_size = 0;\n\n\tacl_base = (char *)pdacl;\n\tsize = sizeof(struct cifs_acl);\n\tsrc_num_aces = le32_to_cpu(pdacl->num_aces);\n\n\tnacl_base = (char *)pndacl;\n\tnsize = sizeof(struct cifs_acl);\n\n\t \n\tfor (i = 0; i < src_num_aces; ++i) {\n\t\tpntace = (struct cifs_ace *) (acl_base + size);\n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\n\t\tif (pnownersid && compare_sids(&pntace->sid, pownersid) == 0)\n\t\t\tace_size = cifs_copy_ace(pnntace, pntace, pnownersid);\n\t\telse if (pngrpsid && compare_sids(&pntace->sid, pgrpsid) == 0)\n\t\t\tace_size = cifs_copy_ace(pnntace, pntace, pngrpsid);\n\t\telse\n\t\t\tace_size = cifs_copy_ace(pnntace, pntace, NULL);\n\n\t\tsize += le16_to_cpu(pntace->size);\n\t\tnsize += ace_size;\n\t}\n\n\treturn nsize;\n}\n\nstatic int set_chmod_dacl(struct cifs_acl *pdacl, struct cifs_acl *pndacl,\n\t\tstruct cifs_sid *pownersid,\tstruct cifs_sid *pgrpsid,\n\t\t__u64 *pnmode, bool mode_from_sid)\n{\n\tint i;\n\tu16 size = 0;\n\tstruct cifs_ace *pntace = NULL;\n\tchar *acl_base = NULL;\n\tu32 src_num_aces = 0;\n\tu16 nsize = 0;\n\tstruct cifs_ace *pnntace = NULL;\n\tchar *nacl_base = NULL;\n\tu32 num_aces = 0;\n\tbool new_aces_set = false;\n\n\t \n\tnacl_base = (char *)pndacl;\n\tnsize = sizeof(struct cifs_acl);\n\n\t \n\tif (!pdacl) {\n\t\tpopulate_new_aces(nacl_base,\n\t\t\t\tpownersid, pgrpsid,\n\t\t\t\tpnmode, &num_aces, &nsize,\n\t\t\t\tmode_from_sid);\n\t\tgoto finalize_dacl;\n\t}\n\n\tacl_base = (char *)pdacl;\n\tsize = sizeof(struct cifs_acl);\n\tsrc_num_aces = le32_to_cpu(pdacl->num_aces);\n\n\t \n\tfor (i = 0; i < src_num_aces; ++i) {\n\t\tpntace = (struct cifs_ace *) (acl_base + size);\n\n\t\tif (!new_aces_set && (pntace->flags & INHERITED_ACE)) {\n\t\t\t \n\t\t\tpopulate_new_aces(nacl_base,\n\t\t\t\t\tpownersid, pgrpsid,\n\t\t\t\t\tpnmode, &num_aces, &nsize,\n\t\t\t\t\tmode_from_sid);\n\n\t\t\tnew_aces_set = true;\n\t\t}\n\n\t\t \n\t\tif (((compare_sids(&pntace->sid, &sid_unix_NFS_mode) == 0) ||\n\t\t\t\t(compare_sids(&pntace->sid, pownersid) == 0) ||\n\t\t\t\t(compare_sids(&pntace->sid, pgrpsid) == 0) ||\n\t\t\t\t(compare_sids(&pntace->sid, &sid_everyone) == 0) ||\n\t\t\t\t(compare_sids(&pntace->sid, &sid_authusers) == 0))) {\n\t\t\tgoto next_ace;\n\t\t}\n\n\t\t \n\t\tpnntace = (struct cifs_ace *) (nacl_base + nsize);\n\n\t\tnsize += cifs_copy_ace(pnntace, pntace, NULL);\n\t\tnum_aces++;\n\nnext_ace:\n\t\tsize += le16_to_cpu(pntace->size);\n\t}\n\n\t \n\tif (!new_aces_set) {\n\t\tpopulate_new_aces(nacl_base,\n\t\t\t\tpownersid, pgrpsid,\n\t\t\t\tpnmode, &num_aces, &nsize,\n\t\t\t\tmode_from_sid);\n\n\t\tnew_aces_set = true;\n\t}\n\nfinalize_dacl:\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(nsize);\n\n\treturn 0;\n}\n\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t \n\n\t \n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t \n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}\n\n\n \nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr,\n\t\tbool get_mode_from_special_sid)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr;  \n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n \n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr, get_mode_from_special_sid);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\");  \n\n\treturn rc;\n}\n\n \nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u32 *pnsecdesclen, __u64 *pnmode, kuid_t uid, kgid_t gid,\n\tbool mode_from_sid, bool id_from_sid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr = NULL, *ngroup_sid_ptr = NULL;\n\tstruct cifs_acl *dacl_ptr = NULL;   \n\tstruct cifs_acl *ndacl_ptr = NULL;  \n\tchar *end_of_acl = ((char *)pntsd) + secdesclen;\n\tu16 size = 0;\n\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tif (dacloffset) {\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tif (end_of_acl < (char *)dacl_ptr + le16_to_cpu(dacl_ptr->size)) {\n\t\t\tcifs_dbg(VFS, \"Server returned illegal ACL size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\n\tif (pnmode && *pnmode != NO_CHANGE_64) {  \n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision =\n\t\t\tdacloffset ? dacl_ptr->revision : cpu_to_le16(ACL_REVISION);\n\n\t\tndacl_ptr->size = cpu_to_le16(0);\n\t\tndacl_ptr->num_aces = cpu_to_le32(0);\n\n\t\trc = set_chmod_dacl(dacl_ptr, ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t    pnmode, mode_from_sid);\n\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t \n\t\t*pnsecdesclen = copy_sec_desc(pntsd, pnntsd, sidsoffset,\n\t\t\t\tNULL, NULL);\n\n\t\t*aclflag |= CIFS_ACL_DACL;\n\t} else {\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision =\n\t\t\tdacloffset ? dacl_ptr->revision : cpu_to_le16(ACL_REVISION);\n\t\tndacl_ptr->num_aces = dacl_ptr ? dacl_ptr->num_aces : 0;\n\n\t\tif (uid_valid(uid)) {  \n\t\t\tuid_t id;\n\t\t\tnowner_sid_ptr = kzalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto chown_chgrp_exit;\n\t\t\t}\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\tif (id_from_sid) {\n\t\t\t\tstruct owner_sid *osid = (struct owner_sid *)nowner_sid_ptr;\n\t\t\t\t \n\t\t\t\tosid->Revision = 1;\n\t\t\t\tosid->NumAuth = 3;\n\t\t\t\tosid->Authority[5] = 5;\n\t\t\t\tosid->SubAuthorities[0] = cpu_to_le32(88);\n\t\t\t\tosid->SubAuthorities[1] = cpu_to_le32(1);\n\t\t\t\tosid->SubAuthorities[2] = cpu_to_le32(id);\n\n\t\t\t} else {  \n\t\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\t\tif (rc) {\n\t\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t\t __func__, rc, id);\n\t\t\t\t\tgoto chown_chgrp_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*aclflag |= CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) {  \n\t\t\tgid_t id;\n\t\t\tngroup_sid_ptr = kzalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto chown_chgrp_exit;\n\t\t\t}\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\tif (id_from_sid) {\n\t\t\t\tstruct owner_sid *gsid = (struct owner_sid *)ngroup_sid_ptr;\n\t\t\t\t \n\t\t\t\tgsid->Revision = 1;\n\t\t\t\tgsid->NumAuth = 3;\n\t\t\t\tgsid->Authority[5] = 5;\n\t\t\t\tgsid->SubAuthorities[0] = cpu_to_le32(88);\n\t\t\t\tgsid->SubAuthorities[1] = cpu_to_le32(2);\n\t\t\t\tgsid->SubAuthorities[2] = cpu_to_le32(id);\n\n\t\t\t} else {  \n\t\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\t\tif (rc) {\n\t\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t\t __func__, rc, id);\n\t\t\t\t\tgoto chown_chgrp_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*aclflag |= CIFS_ACL_GROUP;\n\t\t}\n\n\t\tif (dacloffset) {\n\t\t\t \n\t\t\tsize = replace_sids_and_copy_aces(dacl_ptr, ndacl_ptr,\n\t\t\t\t\towner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnowner_sid_ptr, ngroup_sid_ptr);\n\t\t\tndacl_ptr->size = cpu_to_le16(size);\n\t\t}\n\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t \n\t\t*pnsecdesclen = copy_sec_desc(pntsd, pnntsd, sidsoffset,\n\t\t\t\tnowner_sid_ptr, ngroup_sid_ptr);\n\nchown_chgrp_exit:\n\t\t \n\t\tkfree(nowner_sid_ptr);\n\t\tkfree(ngroup_sid_ptr);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstruct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      const struct cifs_fid *cifsfid, u32 *pacllen,\n\t\t\t\t      u32 __maybe_unused unused)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = READ_CONTROL,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\n \nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t       u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen, info);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}\n\n  \nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, access_flags;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\n\t\taccess_flags = WRITE_OWNER;\n\telse\n\t\taccess_flags = WRITE_DAC;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = access_flags,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Unable to open file to set ACL\\n\");\n\t\tgoto out;\n\t}\n\n\trc = CIFSSMBSetCIFSACL(xid, tcon, fid.netfid, pnntsd, acllen, aclflag);\n\tcifs_dbg(NOISY, \"SetCIFSACL rc = %d\\n\", rc);\n\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n#endif  \n\n \nint\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, bool mode_from_special_sid,\n\t\t  const char *path, const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct smb_version_operations *ops;\n\tconst u32 info = 0;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\tops = tlink_tcon(tlink)->ses->server->ops;\n\n\tif (pfid && (ops->get_acl_by_fid))\n\t\tpntsd = ops->get_acl_by_fid(cifs_sb, pfid, &acllen, info);\n\telse if (ops->get_acl)\n\t\tpntsd = ops->get_acl(cifs_sb, inode, path, &acllen, info);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else if (mode_from_special_sid) {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr, true);\n\t\tkfree(pntsd);\n\t} else {\n\t\t \n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr, false);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}\n\n \nint\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 *pnmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL;  \n\t__u32 secdesclen = 0;\n\t__u32 nsecdesclen = 0;\n\t__u32 dacloffset = 0;\n\tstruct cifs_acl *dacl_ptr = NULL;\n\tstruct cifs_ntsd *pntsd = NULL;  \n\tstruct cifs_ntsd *pnntsd = NULL;  \n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct smb_version_operations *ops;\n\tbool mode_from_sid, id_from_sid;\n\tconst u32 info = 0;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\tops = tlink_tcon(tlink)->ses->server->ops;\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t \n\n\tif (ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = ops->get_acl(cifs_sb, inode, path, &secdesclen, info);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID)\n\t\tmode_from_sid = true;\n\telse\n\t\tmode_from_sid = false;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL)\n\t\tid_from_sid = true;\n\telse\n\t\tid_from_sid = false;\n\n\t \n\tnsecdesclen = secdesclen;\n\tif (pnmode && *pnmode != NO_CHANGE_64) {  \n\t\tif (mode_from_sid)\n\t\t\tnsecdesclen += 2 * sizeof(struct cifs_ace);\n\t\telse  \n\t\t\tnsecdesclen += 5 * sizeof(struct cifs_ace);\n\t} else {  \n\t\t \n\t\tnsecdesclen = sizeof(struct cifs_ntsd) + (sizeof(struct cifs_sid) * 2);\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tif (dacloffset) {\n\t\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\t\tif (mode_from_sid)\n\t\t\t\tnsecdesclen +=\n\t\t\t\t\tle32_to_cpu(dacl_ptr->num_aces) * sizeof(struct cifs_ace);\n\t\t\telse  \n\t\t\t\tnsecdesclen += le16_to_cpu(dacl_ptr->size);\n\t\t}\n\t}\n\n\t \n\tnsecdesclen = max_t(u32, nsecdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(nsecdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, &nsecdesclen, pnmode, uid, gid,\n\t\t\t    mode_from_sid, id_from_sid, &aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t \n\t\trc = ops->set_acl(pnntsd, nsecdesclen, inode, path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}\n\nstruct posix_acl *cifs_get_acl(struct mnt_idmap *idmap,\n\t\t\t       struct dentry *dentry, int type)\n{\n#if defined(CONFIG_CIFS_ALLOW_INSECURE_LEGACY) && defined(CONFIG_CIFS_POSIX)\n\tstruct posix_acl *acl = NULL;\n\tssize_t rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\tpTcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\tacl = ERR_CAST(full_path);\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (sb->s_flags & SB_POSIXACL)\n\t\t\trc = cifs_do_get_acl(xid, pTcon, full_path, &acl,\n\t\t\t\t\t     ACL_TYPE_ACCESS,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (sb->s_flags & SB_POSIXACL)\n\t\t\trc = cifs_do_get_acl(xid, pTcon, full_path, &acl,\n\t\t\t\t\t     ACL_TYPE_DEFAULT,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tbreak;\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tacl = ERR_PTR(-EOPNOTSUPP);\n\t\telse\n\t\t\tacl = ERR_PTR(rc);\n\t}\n\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn acl;\n#else\n\treturn ERR_PTR(-EOPNOTSUPP);\n#endif\n}\n\nint cifs_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n\t\t struct posix_acl *acl, int type)\n{\n#if defined(CONFIG_CIFS_ALLOW_INSECURE_LEGACY) && defined(CONFIG_CIFS_POSIX)\n\tint rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tconst char *full_path;\n\tvoid *page;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\tpTcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\n\tif (!acl)\n\t\tgoto out;\n\n\t \n\t \n\n\t \n\tif (posix_acl_xattr_size(acl->a_count) > CIFSMaxBufSize) {\n\t\tcifs_dbg(FYI, \"size of EA value too large\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (sb->s_flags & SB_POSIXACL)\n\t\t\trc = cifs_do_set_acl(xid, pTcon, full_path, acl,\n\t\t\t\t\t     ACL_TYPE_ACCESS,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (sb->s_flags & SB_POSIXACL)\n\t\t\trc = cifs_do_set_acl(xid, pTcon, full_path, acl,\n\t\t\t\t\t     ACL_TYPE_DEFAULT,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tbreak;\n\t}\n\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}