{
  "module_name": "smb2pdu.c",
  "hash_id": "cbe9e6dc0768b1749a41d9314cfc702d1e7bc3a0751e975d99843243423886ae",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/smb2pdu.c",
  "human_readable_source": "\n \n\n  \n  \n  \n  \n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_spnego.h\"\n#include \"smbdirect.h\"\n#include \"trace.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n#include \"cached_dir.h\"\n\n \nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t  36,\n\t  25,\n\t  4,\n\t \t9,\n\t  4,\n\t  57,\n\t  24,\n\t  24,\n\t \t49,\n\t  49,\n\t \t48,\n\t  57,\n\t  4,\n\t  4,\n\t  33,\n\t  32,\n\t  41,\n\t  33,\n\t  24  \n};\n\nint smb3_encryption_required(const struct cifs_tcon *tcon)\n{\n\tif (!tcon || !tcon->ses)\n\t\treturn 0;\n\tif ((tcon->ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) ||\n\t    (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA))\n\t\treturn 1;\n\tif (tcon->seal &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void\nsmb2_hdr_assemble(struct smb2_hdr *shdr, __le16 smb2_cmd,\n\t\t  const struct cifs_tcon *tcon,\n\t\t  struct TCP_Server_Info *server)\n{\n\tstruct smb3_hdr_req *smb3_hdr;\n\n\tshdr->ProtocolId = SMB2_PROTO_NUMBER;\n\tshdr->StructureSize = cpu_to_le16(64);\n\tshdr->Command = smb2_cmd;\n\n\tif (server) {\n\t\t \n\t\tif (server->dialect >= SMB30_PROT_ID) {\n\t\t\tsmb3_hdr = (struct smb3_hdr_req *)shdr;\n\t\t\t \n\t\t\tif (SERVER_IS_CHAN(server))\n\t\t\t\tsmb3_hdr->ChannelSequence =\n\t\t\t\t\tcpu_to_le16(server->primary_server->channel_sequence_num);\n\t\t\telse\n\t\t\t\tsmb3_hdr->ChannelSequence =\n\t\t\t\t\tcpu_to_le16(server->channel_sequence_num);\n\t\t}\n\t\tspin_lock(&server->req_lock);\n\t\t \n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, 10));\n\t\tspin_unlock(&server->req_lock);\n\t} else {\n\t\tshdr->CreditRequest = cpu_to_le16(2);\n\t}\n\tshdr->Id.SyncId.ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t \n\t \n\tif (server && (server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\tshdr->CreditCharge = cpu_to_le16(1);\n\t \n\n\tshdr->Id.SyncId.TreeId = cpu_to_le32(tcon->tid);\n\t \n\tif (tcon->ses)\n\t\tshdr->SessionId = cpu_to_le64(tcon->ses->Suid);\n\n\t \n \n\n\tif (server && server->sign && !smb3_encryption_required(tcon))\n\t\tshdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\treturn;\n}\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon,\n\t       struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage = NULL;\n\tstruct cifs_ses *ses;\n\n\t \n\tif (tcon == NULL)\n\t\treturn 0;\n\n\t \n\tif (smb2_command == SMB2_TREE_CONNECT || smb2_command == SMB2_IOCTL)\n\t\treturn 0;\n\n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status == TID_EXITING) {\n\t\t \n\t\tif (smb2_command != SMB2_TREE_DISCONNECT) {\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\n\tses = tcon->ses;\n\tif (!ses)\n\t\treturn -EIO;\n\tspin_lock(&ses->ses_lock);\n\tif (ses->ses_status == SES_EXITING) {\n\t\tspin_unlock(&ses->ses_lock);\n\t\treturn -EIO;\n\t}\n\tspin_unlock(&ses->ses_lock);\n\tif (!ses->server || !server)\n\t\treturn -EIO;\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\t \n\t\tswitch (smb2_command) {\n\t\t \n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\tspin_unlock(&server->srv_lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tspin_unlock(&server->srv_lock);\n\nagain:\n\trc = cifs_wait_for_server_reconnect(server, tcon->retry);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&ses->chan_lock);\n\tif (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\tcifs_dbg(FYI, \"sess reconnect mask: 0x%lx, tcon reconnect: %d\",\n\t\t tcon->ses->chans_need_reconnect,\n\t\t tcon->need_reconnect);\n\n\tmutex_lock(&ses->session_mutex);\n\t \n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\tif (tcon->retry)\n\t\t\tgoto again;\n\n\t\trc = -EHOSTDOWN;\n\t\tgoto out;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tnls_codepage = ses->local_nls;\n\n\t \n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\tif (!cifs_chan_needs_reconnect(ses, server) &&\n\t    ses->ses_status == SES_GOOD) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\t\t \n\t\tif (tcon->need_reconnect)\n\t\t\tgoto skip_sess_setup;\n\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\n\trc = cifs_negotiate_protocol(0, ses, server);\n\tif (!rc) {\n\t\trc = cifs_setup_session(0, ses, server, nls_codepage);\n\t\tif ((rc == -EACCES) && !tcon->retry) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\trc = -EHOSTDOWN;\n\t\t\tgoto failed;\n\t\t} else if (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\nskip_sess_setup:\n\tif (!tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\tcifs_mark_open_files_invalid(tcon);\n\tif (tcon->use_persistent)\n\t\ttcon->need_reopen_files = true;\n\n\trc = cifs_tree_connect(0, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc) {\n\t\t \n\t\tcifs_dbg(VFS, \"reconnect tcon failed rc = %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (smb2_command != SMB2_INTERNAL_CMD)\n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t \n\t \n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\trc = -EAGAIN;\n\t}\nfailed:\n\treturn rc;\n}\n\nstatic void\nfill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon,\n\t       struct TCP_Server_Info *server,\n\t       void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_pdu *spdu = buf;\n\t \n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\n\t \n\tmemset(buf, 0, 256);\n\n\tsmb2_hdr_assemble(&spdu->hdr, smb2_command, tcon, server);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\n\t*total_len = parmsize + sizeof(struct smb2_hdr);\n}\n\n \nstatic int __smb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t\t\t struct TCP_Server_Info *server,\n\t\t\t\t void **request_buf, unsigned int *total_len)\n{\n\t \n\tswitch (smb2_command) {\n\tcase SMB2_SET_INFO:\n\tcase SMB2_QUERY_INFO:\n\t\t*request_buf = cifs_buf_get();\n\t\tbreak;\n\tdefault:\n\t\t*request_buf = cifs_small_buf_get();\n\t\tbreak;\n\t}\n\tif (*request_buf == NULL) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\tfill_small_buf(smb2_command, tcon, server,\n\t\t       (struct smb2_hdr *)(*request_buf),\n\t\t       total_len);\n\n\tif (tcon != NULL) {\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t\t       struct TCP_Server_Info *server,\n\t\t\t       void **request_buf, unsigned int *total_len)\n{\n\tint rc;\n\n\trc = smb2_reconnect(smb2_command, tcon, server);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb2_plain_req_init(smb2_command, tcon, server, request_buf,\n\t\t\t\t     total_len);\n}\n\nstatic int smb2_ioctl_req_init(u32 opcode, struct cifs_tcon *tcon,\n\t\t\t       struct TCP_Server_Info *server,\n\t\t\t       void **request_buf, unsigned int *total_len)\n{\n\t \n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO) {\n\t\treturn __smb2_plain_req_init(SMB2_IOCTL, tcon, server,\n\t\t\t\t\t     request_buf, total_len);\n\t}\n\treturn smb2_plain_req_init(SMB2_IOCTL, tcon, server,\n\t\t\t\t   request_buf, total_len);\n}\n\n \n\nstatic void\nbuild_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = SMB2_PREAUTH_INTEGRITY_SHA512;\n}\n\nstatic void\nbuild_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t  - sizeof(struct smb2_neg_context));\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(3);\n\tpneg_ctxt->CompressionAlgorithms[0] = SMB3_COMPRESS_LZ77;\n\tpneg_ctxt->CompressionAlgorithms[1] = SMB3_COMPRESS_LZ77_HUFF;\n\tpneg_ctxt->CompressionAlgorithms[2] = SMB3_COMPRESS_LZNT1;\n}\n\nstatic unsigned int\nbuild_signing_ctxt(struct smb2_signing_capabilities *pneg_ctxt)\n{\n\tunsigned int ctxt_len = sizeof(struct smb2_signing_capabilities);\n\tunsigned short num_algs = 1;  \n\n\tpneg_ctxt->ContextType = SMB2_SIGNING_CAPABILITIES;\n\t \n\tpneg_ctxt->DataLength = cpu_to_le16(ALIGN(sizeof(struct smb2_signing_capabilities) -\n\t\t\t\t\t    sizeof(struct smb2_neg_context) +\n\t\t\t\t\t    (num_algs * sizeof(u16)), 8));\n\tpneg_ctxt->SigningAlgorithmCount = cpu_to_le16(num_algs);\n\tpneg_ctxt->SigningAlgorithms[0] = cpu_to_le16(SIGNING_ALG_AES_CMAC);\n\n\tctxt_len += sizeof(__le16) * num_algs;\n\tctxt_len = ALIGN(ctxt_len, 8);\n\treturn ctxt_len;\n\t \n}\n\nstatic void\nbuild_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tif (require_gcm_256) {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(4);  \n\t\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES256_GCM;\n\t} else if (enable_gcm_256) {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(8);  \n\t\tpneg_ctxt->CipherCount = cpu_to_le16(3);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\t\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES256_GCM;\n\t\tpneg_ctxt->Ciphers[2] = SMB2_ENCRYPTION_AES128_CCM;\n\t} else {\n\t\tpneg_ctxt->DataLength = cpu_to_le16(6);  \n\t\tpneg_ctxt->CipherCount = cpu_to_le16(2);\n\t\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\t\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES128_CCM;\n\t}\n}\n\nstatic unsigned int\nbuild_netname_ctxt(struct smb2_netname_neg_context *pneg_ctxt, char *hostname)\n{\n\tstruct nls_table *cp = load_nls_default();\n\n\tpneg_ctxt->ContextType = SMB2_NETNAME_NEGOTIATE_CONTEXT_ID;\n\n\t \n\tpneg_ctxt->DataLength = cpu_to_le16(2 * cifs_strtoUTF16(pneg_ctxt->NetName, hostname, 100, cp));\n\t \n\treturn ALIGN(le16_to_cpu(pneg_ctxt->DataLength) + sizeof(struct smb2_neg_context), 8);\n}\n\nstatic void\nbuild_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t \n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void\nassemble_neg_contexts(struct smb2_negotiate_req *req,\n\t\t      struct TCP_Server_Info *server, unsigned int *total_len)\n{\n\tunsigned int ctxt_len, neg_context_count;\n\tstruct TCP_Server_Info *pserver;\n\tchar *pneg_ctxt;\n\tchar *hostname;\n\n\tif (*total_len > 200) {\n\t\t \n\t\tcifs_server_dbg(VFS, \"Bad frame length assembling neg contexts\\n\");\n\t\treturn;\n\t}\n\n\t \n\t*total_len = ALIGN(*total_len, 8);\n\n\tpneg_ctxt = (*total_len) + (char *)req;\n\treq->NegotiateContextOffset = cpu_to_le32(*total_len);\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\tctxt_len = ALIGN(sizeof(struct smb2_preauth_neg_context), 8);\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\tctxt_len = ALIGN(sizeof(struct smb2_encryption_neg_context), 8);\n\t*total_len += ctxt_len;\n\tpneg_ctxt += ctxt_len;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\tcifs_server_lock(pserver);\n\thostname = pserver->hostname;\n\tif (hostname && (hostname[0] != 0)) {\n\t\tctxt_len = build_netname_ctxt((struct smb2_netname_neg_context *)pneg_ctxt,\n\t\t\t\t\t      hostname);\n\t\t*total_len += ctxt_len;\n\t\tpneg_ctxt += ctxt_len;\n\t\tneg_context_count = 3;\n\t} else\n\t\tneg_context_count = 2;\n\tcifs_server_unlock(pserver);\n\n\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t*total_len += sizeof(struct smb2_posix_neg_context);\n\tpneg_ctxt += sizeof(struct smb2_posix_neg_context);\n\tneg_context_count++;\n\n\tif (server->compress_algorithm) {\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)\n\t\t\t\tpneg_ctxt);\n\t\tctxt_len = ALIGN(sizeof(struct smb2_compression_capabilities_context), 8);\n\t\t*total_len += ctxt_len;\n\t\tpneg_ctxt += ctxt_len;\n\t\tneg_context_count++;\n\t}\n\n\tif (enable_negotiate_signing) {\n\t\tctxt_len = build_signing_ctxt((struct smb2_signing_capabilities *)\n\t\t\t\tpneg_ctxt);\n\t\t*total_len += ctxt_len;\n\t\tpneg_ctxt += ctxt_len;\n\t\tneg_context_count++;\n\t}\n\n\t \n\treq->NegotiateContextCount = cpu_to_le16(neg_context_count);\n\n}\n\n \nstatic void decode_preauth_context(struct smb2_preauth_neg_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\t \n\tif (len < MIN_PREAUTH_CTXT_DATA_LEN) {\n\t\tpr_warn_once(\"server sent bad preauth context\\n\");\n\t\treturn;\n\t} else if (len < MIN_PREAUTH_CTXT_DATA_LEN + le16_to_cpu(ctxt->SaltLength)) {\n\t\tpr_warn_once(\"server sent invalid SaltLength\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->HashAlgorithmCount) != 1)\n\t\tpr_warn_once(\"Invalid SMB3 hash algorithm count\\n\");\n\tif (ctxt->HashAlgorithms != SMB2_PREAUTH_INTEGRITY_SHA512)\n\t\tpr_warn_once(\"unknown SMB3 hash algorithm\\n\");\n}\n\nstatic void decode_compress_ctx(struct TCP_Server_Info *server,\n\t\t\t struct smb2_compression_capabilities_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\t \n\tif (len < 10) {\n\t\tpr_warn_once(\"server sent bad compression cntxt\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->CompressionAlgorithmCount) != 1) {\n\t\tpr_warn_once(\"Invalid SMB3 compress algorithm count\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(ctxt->CompressionAlgorithms[0]) > 3) {\n\t\tpr_warn_once(\"unknown compression algorithm\\n\");\n\t\treturn;\n\t}\n\tserver->compress_algorithm = ctxt->CompressionAlgorithms[0];\n}\n\nstatic int decode_encrypt_ctx(struct TCP_Server_Info *server,\n\t\t\t      struct smb2_encryption_neg_context *ctxt)\n{\n\tunsigned int len = le16_to_cpu(ctxt->DataLength);\n\n\tcifs_dbg(FYI, \"decode SMB3.11 encryption neg context of len %d\\n\", len);\n\t \n\tif (len < MIN_ENCRYPT_CTXT_DATA_LEN) {\n\t\tpr_warn_once(\"server sent bad crypto ctxt len\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le16_to_cpu(ctxt->CipherCount) != 1) {\n\t\tpr_warn_once(\"Invalid SMB3.11 cipher count\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcifs_dbg(FYI, \"SMB311 cipher type:%d\\n\", le16_to_cpu(ctxt->Ciphers[0]));\n\tif (require_gcm_256) {\n\t\tif (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tcifs_dbg(VFS, \"Server does not support requested encryption type (AES256 GCM)\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (ctxt->Ciphers[0] == 0) {\n\t\t \n\t\tserver->cipher_type = 0;\n\t\tserver->capabilities &= ~SMB2_GLOBAL_CAP_ENCRYPTION;\n\t\tpr_warn_once(\"Server does not support requested encryption types\\n\");\n\t\treturn 0;\n\t} else if ((ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES128_CCM) &&\n\t\t   (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES128_GCM) &&\n\t\t   (ctxt->Ciphers[0] != SMB2_ENCRYPTION_AES256_GCM)) {\n\t\t \n\t\tpr_warn_once(\"Invalid SMB3.11 cipher returned\\n\");\n\t\treturn -EINVAL;\n\t}\n\tserver->cipher_type = ctxt->Ciphers[0];\n\tserver->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;\n\treturn 0;\n}\n\nstatic void decode_signing_ctx(struct TCP_Server_Info *server,\n\t\t\t       struct smb2_signing_capabilities *pctxt)\n{\n\tunsigned int len = le16_to_cpu(pctxt->DataLength);\n\n\t \n\tif ((len < 4) || (len > 16)) {\n\t\tpr_warn_once(\"server sent bad signing negcontext\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(pctxt->SigningAlgorithmCount) != 1) {\n\t\tpr_warn_once(\"Invalid signing algorithm count\\n\");\n\t\treturn;\n\t}\n\tif (le16_to_cpu(pctxt->SigningAlgorithms[0]) > 2) {\n\t\tpr_warn_once(\"unknown signing algorithm\\n\");\n\t\treturn;\n\t}\n\n\tserver->signing_negotiated = true;\n\tserver->signing_algorithm = le16_to_cpu(pctxt->SigningAlgorithms[0]);\n\tcifs_dbg(FYI, \"signing algorithm %d chosen\\n\",\n\t\t     server->signing_algorithm);\n}\n\n\nstatic int smb311_decode_neg_context(struct smb2_negotiate_rsp *rsp,\n\t\t\t\t     struct TCP_Server_Info *server,\n\t\t\t\t     unsigned int len_of_smb)\n{\n\tstruct smb2_neg_context *pctx;\n\tunsigned int offset = le32_to_cpu(rsp->NegotiateContextOffset);\n\tunsigned int ctxt_cnt = le16_to_cpu(rsp->NegotiateContextCount);\n\tunsigned int len_of_ctxts, i;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"decoding %d negotiate contexts\\n\", ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tcifs_server_dbg(VFS, \"Invalid response: negotiate context offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\tfor (i = 0; i < ctxt_cnt; i++) {\n\t\tint clen;\n\t\t \n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)(offset + (char *)rsp);\n\t\tclen = sizeof(struct smb2_neg_context)\n\t\t\t+ le16_to_cpu(pctx->DataLength);\n\t\t \n\t\tif (i + 1 != ctxt_cnt)\n\t\t\tclen = ALIGN(clen, 8);\n\t\tif (clen > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES)\n\t\t\tdecode_preauth_context(\n\t\t\t\t(struct smb2_preauth_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES)\n\t\t\trc = decode_encrypt_ctx(server,\n\t\t\t\t(struct smb2_encryption_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES)\n\t\t\tdecode_compress_ctx(server,\n\t\t\t\t(struct smb2_compression_capabilities_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE)\n\t\t\tserver->posix_ext_supported = true;\n\t\telse if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES)\n\t\t\tdecode_signing_ctx(server,\n\t\t\t\t(struct smb2_signing_capabilities *)pctx);\n\t\telse\n\t\t\tcifs_server_dbg(VFS, \"unknown negcontext of type %d ignored\\n\",\n\t\t\t\tle16_to_cpu(pctx->ContextType));\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\toffset += clen;\n\t\tlen_of_ctxts -= clen;\n\t}\n\treturn rc;\n}\n\nstatic struct create_posix *\ncreate_posix_buf(umode_t mode)\n{\n\tstruct create_posix *buf;\n\n\tbuf = kzalloc(sizeof(struct create_posix),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_posix, Mode));\n\tbuf->ccontext.DataLength = cpu_to_le32(4);\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_posix, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(16);\n\n\t \n\tbuf->Name[0] = 0x93;\n\tbuf->Name[1] = 0xAD;\n\tbuf->Name[2] = 0x25;\n\tbuf->Name[3] = 0x50;\n\tbuf->Name[4] = 0x9C;\n\tbuf->Name[5] = 0xB4;\n\tbuf->Name[6] = 0x11;\n\tbuf->Name[7] = 0xE7;\n\tbuf->Name[8] = 0xB4;\n\tbuf->Name[9] = 0x23;\n\tbuf->Name[10] = 0x83;\n\tbuf->Name[11] = 0xDE;\n\tbuf->Name[12] = 0x96;\n\tbuf->Name[13] = 0x8B;\n\tbuf->Name[14] = 0xCD;\n\tbuf->Name[15] = 0x7C;\n\tbuf->Mode = cpu_to_le32(mode);\n\tcifs_dbg(FYI, \"mode on posix create 0%o\\n\", mode);\n\treturn buf;\n}\n\nstatic int\nadd_posix_context(struct kvec *iov, unsigned int *num_iovec, umode_t mode)\n{\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_posix_buf(mode);\n\tif (mode == ACL_NO_MODE)\n\t\tcifs_dbg(FYI, \"%s: no mode\\n\", __func__);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_posix);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n\n \n\nint\nSMB2_negotiate(const unsigned int xid,\n\t       struct cifs_ses *ses,\n\t       struct TCP_Server_Info *server)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc;\n\tint resp_buftype;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(3);\n\t\ttotal_len += 6;\n\t} else if (strcmp(server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t \n\t\treq->Dialects[0] = cpu_to_le16(server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t \n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(server->vals->req_capabilities);\n\tif (ses->chan_max > 1)\n\t\treq->Capabilities |= cpu_to_le32(SMB2_GLOBAL_CAP_MULTI_CHANNEL);\n\n\t \n\tif (server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(server->vals->version_string,\n\t\t     SMB3ANY_VERSION_STRING) == 0) ||\n\t\t    (strcmp(server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, server, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t \n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_server_dbg(VFS, \"Dialect not supported by server. Consider  specifying vers=1.0 or vers=2.0 on mount for accessing older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\trc = -EIO;\n\tif (strcmp(server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\tgoto neg_exit;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\tgoto neg_exit;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\t\t \n\t\t\tserver->ops = &smb311_operations;\n\t\t\tserver->vals = &smb311_values;\n\t\t}\n\t} else if (strcmp(server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_server_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\tgoto neg_exit;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t \n\t\t\tserver->ops = &smb21_operations;\n\t\t\tserver->vals = &smb21_values;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\t\tserver->ops = &smb311_operations;\n\t\t\tserver->vals = &smb311_values;\n\t\t}\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tserver->vals->protocol_id) {\n\t\t \n\t\tcifs_server_dbg(VFS, \"Invalid 0x%x dialect returned: not requested\\n\",\n\t\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\tgoto neg_exit;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_server_dbg(VFS, \"Invalid dialect returned by server 0x%x\\n\",\n\t\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\tgoto neg_exit;\n\t}\n\n\trc = 0;\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t \n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t \n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t \n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t \n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\t \n\tif (server->dialect == SMB30_PROT_ID && (server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION))\n\t\tserver->cipher_type = SMB2_ENCRYPTION_AES128_CCM;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_hdr *)rsp);\n\t \n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_server_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tstruct validate_negotiate_info_req *pneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp = NULL;\n\tu32 rsplen;\n\tu32 inbuflen;  \n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t \n\tif (server->dialect == SMB311_PROT_ID)\n\t\treturn 0;\n\n\t \n\tif (tcon->ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST)\n\t\treturn 0;  \n\n\tif (tcon->ses->user_name == NULL) {\n\t\tcifs_dbg(FYI, \"Can't validate negotiate: null user mount\\n\");\n\t\treturn 0;  \n\t}\n\n\tif (tcon->ses->session_flags & SMB2_SESSION_FLAG_IS_NULL)\n\t\tcifs_tcon_dbg(VFS, \"Unexpected null user (anonymous) auth flag sent by server\\n\");\n\n\tpneg_inbuf = kmalloc(sizeof(*pneg_inbuf), GFP_NOFS);\n\tif (!pneg_inbuf)\n\t\treturn -ENOMEM;\n\n\tpneg_inbuf->Capabilities =\n\t\t\tcpu_to_le32(server->vals->req_capabilities);\n\tif (tcon->ses->chan_max > 1)\n\t\tpneg_inbuf->Capabilities |= cpu_to_le32(SMB2_GLOBAL_CAP_MULTI_CHANNEL);\n\n\tmemcpy(pneg_inbuf->Guid, server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tpneg_inbuf->SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tpneg_inbuf->SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tpneg_inbuf->SecurityMode = 0;\n\n\n\tif (strcmp(server->vals->version_string,\n\t\tSMB3ANY_VERSION_STRING) == 0) {\n\t\tpneg_inbuf->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\tpneg_inbuf->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\tpneg_inbuf->Dialects[2] = cpu_to_le16(SMB311_PROT_ID);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(3);\n\t\t \n\t\tinbuflen = sizeof(*pneg_inbuf) -\n\t\t\t\t(sizeof(pneg_inbuf->Dialects[0]));\n\t} else if (strcmp(server->vals->version_string,\n\t\tSMBDEFAULT_VERSION_STRING) == 0) {\n\t\tpneg_inbuf->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\tpneg_inbuf->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\tpneg_inbuf->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\tpneg_inbuf->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(4);\n\t\t \n\t\tinbuflen = sizeof(*pneg_inbuf);\n\t} else {\n\t\t \n\t\tpneg_inbuf->Dialects[0] =\n\t\t\tcpu_to_le16(server->vals->protocol_id);\n\t\tpneg_inbuf->DialectCount = cpu_to_le16(1);\n\t\t \n\t\tinbuflen = sizeof(*pneg_inbuf) -\n\t\t\t\tsizeof(pneg_inbuf->Dialects[0]) * 3;\n\t}\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO,\n\t\t(char *)pneg_inbuf, inbuflen, CIFSMaxBufSize,\n\t\t(char **)&pneg_rsp, &rsplen);\n\tif (rc == -EOPNOTSUPP) {\n\t\t \n\t\tcifs_tcon_dbg(VFS, \"Server does not support validate negotiate\\n\");\n\t\trc = 0;\n\t\tgoto out_free_inbuf;\n\t} else if (rc != 0) {\n\t\tcifs_tcon_dbg(VFS, \"validate protocol negotiate failed: %d\\n\",\n\t\t\t      rc);\n\t\trc = -EIO;\n\t\tgoto out_free_inbuf;\n\t}\n\n\trc = -EIO;\n\tif (rsplen != sizeof(*pneg_rsp)) {\n\t\tcifs_tcon_dbg(VFS, \"Invalid protocol negotiate response size: %d\\n\",\n\t\t\t      rsplen);\n\n\t\t \n\t\tif (rsplen > CIFSMaxBufSize || rsplen < sizeof(*pneg_rsp))\n\t\t\tgoto out_free_rsp;\n\t}\n\n\t \n\tif (pneg_rsp->Dialect != cpu_to_le16(server->dialect))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(server->sec_mode))\n\t\tgoto vneg_out;\n\n\t \n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != server->capabilities)\n\t\tgoto vneg_out;\n\n\t \n\trc = 0;\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\tgoto out_free_rsp;\n\nvneg_out:\n\tcifs_tcon_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\nout_free_rsp:\n\tkfree(pneg_rsp);\nout_free_inbuf:\n\tkfree(pneg_inbuf);\n\treturn rc;\n}\n\nenum securityEnum\nsmb2_select_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (requested) {\n\tcase Kerberos:\n\tcase RawNTLMSSP:\n\t\treturn requested;\n\tcase NTLMv2:\n\t\treturn RawNTLMSSP;\n\tcase Unspecified:\n\t\tif (server->sec_ntlmssp &&\n\t\t\t(global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn RawNTLMSSP;\n\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t(global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\treturn Kerberos;\n\t\tfallthrough;\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}\n\nstruct SMB2_sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct SMB2_sess_data *);\n\tint result;\n\tu64 previous_session;\n\n\t \n\tint buf0_type;\n\tstruct kvec iov[2];\n};\n\nstatic int\nSMB2_sess_alloc_buffer(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\tstruct smb2_sess_setup_req *req;\n\tunsigned int total_len;\n\tbool is_binding = false;\n\n\trc = smb2_plain_req_init(SMB2_SESSION_SETUP, NULL, server,\n\t\t\t\t (void **) &req,\n\t\t\t\t &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&ses->ses_lock);\n\tis_binding = (ses->ses_status == SES_GOOD);\n\tspin_unlock(&ses->ses_lock);\n\n\tif (is_binding) {\n\t\treq->hdr.SessionId = cpu_to_le64(ses->Suid);\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\t\treq->PreviousSessionId = 0;\n\t\treq->Flags = SMB2_SESSION_REQ_FLAG_BINDING;\n\t\tcifs_dbg(FYI, \"Binding to sess id: %llx\\n\", ses->Suid);\n\t} else {\n\t\t \n\t\treq->hdr.SessionId = 0;\n\t\t \n\t\treq->PreviousSessionId = cpu_to_le64(sess_data->previous_session);\n\t\treq->Flags = 0;  \n\t\tcifs_dbg(FYI, \"Fresh session. Previous: %llx\\n\",\n\t\t\t sess_data->previous_session);\n\t}\n\n\t \n\tif (server->credits >= server->max_credits)\n\t\treq->hdr.CreditRequest = cpu_to_le16(0);\n\telse\n\t\treq->hdr.CreditRequest = cpu_to_le16(\n\t\t\tmin_t(int, server->max_credits -\n\t\t\t      server->credits, 130));\n\n\t \n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)  \n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\treq->Capabilities = cpu_to_le32(SMB2_GLOBAL_CAP_DFS);\n#else\n\treq->Capabilities = 0;\n#endif  \n\n\treq->Channel = 0;  \n\n\tsess_data->iov[0].iov_base = (char *)req;\n\t \n\tsess_data->iov[0].iov_len = total_len - 1;\n\t \n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\treturn 0;\n}\n\nstatic void\nSMB2_sess_free_buffer(struct SMB2_sess_data *sess_data)\n{\n\tstruct kvec *iov = sess_data->iov;\n\n\t \n\tif (sess_data->buf0_type != CIFS_NO_BUFFER && iov[0].iov_base)\n\t\tmemzero_explicit(iov[0].iov_base, iov[0].iov_len);\n\n\tfree_rsp_buf(sess_data->buf0_type, iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n}\n\nstatic int\nSMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_rqst rqst;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t \n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req));\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = sess_data->iov;\n\trqst.rq_nvec = 2;\n\n\t \n\trc = cifs_send_recv(sess_data->xid, sess_data->ses,\n\t\t\t    sess_data->server,\n\t\t\t    &rqst,\n\t\t\t    &sess_data->buf0_type,\n\t\t\t    CIFS_LOG_ERROR | CIFS_SESS_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\nstatic int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\n\tcifs_server_lock(server);\n\tif (server->ops->generate_signingkey) {\n\t\trc = server->ops->generate_signingkey(ses, server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tcifs_server_unlock(server);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (!server->session_estab) {\n\t\tserver->sequence_number = 0x2;\n\t\tserver->session_estab = true;\n\t}\n\tcifs_server_unlock(server);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tbool is_binding = false;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tspnego_key = cifs_get_spnego_key(ses, server);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tif (rc == -ENOKEY)\n\t\t\tcifs_dbg(VFS, \"Verify user has a krb5 ticket and keyutils is installed\\n\");\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t \n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS, \"bad cifs.upcall version. Expected %d got %d\\n\",\n\t\t\t CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tspin_lock(&ses->ses_lock);\n\tis_binding = (ses->ses_status == SES_GOOD);\n\tspin_unlock(&ses->ses_lock);\n\n\t \n\tif (!is_binding) {\n\t\tkfree_sensitive(ses->auth_key.response);\n\t\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\\n\",\n\t\t\t\t msg->sesskey_len);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_put_spnego_key;\n\t\t}\n\t\tses->auth_key.len = msg->sesskey_len;\n\t}\n\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\t \n\tif (!is_binding) {\n\t\tses->Suid = le64_to_cpu(rsp->hdr.SessionId);\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\n\tif (rc) {\n\t\tkfree_sensitive(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tses->auth_key.len = 0;\n\t}\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}\n#else\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\tsess_data->result = -EOPNOTSUPP;\n\tsess_data->func = NULL;\n}\n#endif\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data);\n\nstatic void\nSMB2_sess_auth_rawntlmssp_negotiate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false;  \n\tu16 blob_length = 0;\n\tbool is_binding = false;\n\n\t \n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out_err;\n\n\trc = build_ntlmssp_smb3_negotiate_blob(&ntlmssp_blob,\n\t\t\t\t\t  &blob_length, ses, server,\n\t\t\t\t\t  sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out;\n\n\tif (use_spnego) {\n\t\t \n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\t \n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t\trsp->hdr.Status == STATUS_MORE_PROCESSING_REQUIRED)\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) !=\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tspin_lock(&ses->ses_lock);\n\tis_binding = (ses->ses_status == SES_GOOD);\n\tspin_unlock(&ses->ses_lock);\n\n\t \n\tif (!is_binding) {\n\t\tses->Suid = le64_to_cpu(rsp->hdr.SessionId);\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\nout:\n\tkfree_sensitive(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tif (!rc) {\n\t\tsess_data->result = 0;\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\nout_err:\n\tkfree_sensitive(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false;  \n\tu16 blob_length = 0;\n\tbool is_binding = false;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->hdr.SessionId = cpu_to_le64(ses->Suid);\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length,\n\t\t\t\t     ses, server,\n\t\t\t\t     sess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t \n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\tspin_lock(&ses->ses_lock);\n\tis_binding = (ses->ses_status == SES_GOOD);\n\tspin_unlock(&ses->ses_lock);\n\n\t \n\tif (!is_binding) {\n\t\tses->Suid = le64_to_cpu(rsp->hdr.SessionId);\n\t\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\t}\n\n\trc = SMB2_sess_establish_session(sess_data);\n#ifdef CONFIG_CIFS_DEBUG_DUMP_KEYS\n\tif (ses->server->dialect < SMB30_PROT_ID) {\n\t\tcifs_dbg(VFS, \"%s: dumping generated SMB2 session keys\\n\", __func__);\n\t\t \n\t\tcifs_dbg(VFS, \"Session Id    %*ph\\n\", (int)sizeof(ses->Suid),\n\t\t\t &ses->Suid);\n\t\tcifs_dbg(VFS, \"Session Key   %*ph\\n\",\n\t\t\t SMB2_NTLMV2_SESSKEY_SIZE, ses->auth_key.response);\n\t\tcifs_dbg(VFS, \"Signing Key   %*ph\\n\",\n\t\t\t SMB3_SIGN_KEY_SIZE, ses->auth_key.response);\n\t}\n#endif\nout:\n\tkfree_sensitive(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree_sensitive(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic int\nSMB2_select_sec(struct SMB2_sess_data *sess_data)\n{\n\tint type;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct TCP_Server_Info *server = sess_data->server;\n\n\ttype = smb2_select_sectype(server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS, \"Unable to select appropriate authentication method!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tstruct TCP_Server_Info *server,\n\t\tconst struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct SMB2_sess_data *sess_data;\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->server = server;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\tsess_data->previous_session = ses->Suid;\n\n\trc = SMB2_select_sec(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tmemcpy(ses->preauth_sha_hash, server->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\tif ((ses->session_flags & SMB2_SESSION_FLAG_IS_GUEST) && (ses->sign))\n\t\tcifs_server_dbg(VFS, \"signing requested but authenticated as guest\\n\");\n\trc = sess_data->result;\nout:\n\tkfree_sensitive(sess_data);\n\treturn rc;\n}\n\nint\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_logoff_req *req;  \n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t \n\tspin_lock(&ses->chan_lock);\n\tif (CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tgoto smb2_session_already_dead;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\trc = smb2_plain_req_init(SMB2_LOGOFF, NULL, ses->server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\t  \n\treq->hdr.SessionId = cpu_to_le64(ses->Suid);\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\telse if (server->sign)\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, ses->server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\t \n\nsmb2_session_already_dead:\n\treturn rc;\n}\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}\n\n#define MAX_SHARENAME_LENGTH (255   + 80   + 1  )\n\n \nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov = { NULL, 0 };\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\t__le16 *unc_path = NULL;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server;\n\n\t \n\tserver = ses->server;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif (!server || !tree)\n\t\treturn -EIO;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp);\n\tif (unc_path_len <= 0) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\tunc_path_len *= 2;\n\n\t \n\ttcon->tid = 0;\n\tatomic_set(&tcon->num_remote_opens, 0);\n\trc = smb2_plain_req_init(SMB2_TREE_CONNECT, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\t \n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req));\n\treq->PathLength = cpu_to_le16(unc_path_len);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\t \n\tif ((server->dialect == SMB311_PROT_ID) &&\n\t    !smb3_encryption_required(tcon) &&\n\t    !(ses->session_flags &\n\t\t    (SMB2_SESSION_FLAG_IS_GUEST|SMB2_SESSION_FLAG_IS_NULL)) &&\n\t    ((ses->user_name != NULL) || (ses->sectype == Kerberos)))\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\n\t \n\tif (server->credits >= server->max_credits)\n\t\treq->hdr.CreditRequest = cpu_to_le16(0);\n\telse\n\t\treq->hdr.CreditRequest = cpu_to_le16(\n\t\t\tmin_t(int, server->max_credits -\n\t\t\t      server->credits, 64));\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_tree_connect_rsp *)rsp_iov.iov_base;\n\ttrace_smb3_tcon(xid, tcon->tid, ses->Suid, tree, rc);\n\tif ((rc != 0) || (rsp == NULL)) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\ttcon->need_reconnect = true;\n\t\tgoto tcon_error_exit;\n\t}\n\n\tswitch (rsp->ShareType) {\n\tcase SMB2_SHARE_TYPE_DISK:\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\t\tbreak;\n\tcase SMB2_SHARE_TYPE_PIPE:\n\t\ttcon->pipe = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t\tbreak;\n\tcase SMB2_SHARE_TYPE_PRINT:\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t\tbreak;\n\tdefault:\n\t\tcifs_server_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities;  \n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tid = le32_to_cpu(rsp->hdr.Id.SyncId.TreeId);\n\tstrscpy(tcon->tree_name, tree, sizeof(tcon->tree_name));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_tcon_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\n\tif (tcon->seal &&\n\t    !(server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION))\n\t\tcifs_tcon_dbg(VFS, \"Encryption is requested but not supported\\n\");\n\n\tinit_copy_chunk_defaults(tcon);\n\tif (server->ops->validate_negotiate)\n\t\trc = server->ops->validate_negotiate(xid, tcon);\n\tif (rc == 0)  \n\t\tif (tcon->share_flags & SMB2_SHAREFLAG_ISOLATED_TRANSPORT)\n\t\t\tserver->nosharesock = true;\ntcon_exit:\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp && rsp->hdr.Status == STATUS_BAD_NETWORK_NAME)\n\t\tcifs_tcon_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\tgoto tcon_exit;\n}\n\nint\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_tree_disconnect_req *req;  \n\tint rc = 0;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\ttrace_smb3_tdis_enter(xid, tcon->tid, ses->Suid, tcon->tree_name);\n\tspin_lock(&ses->chan_lock);\n\tif ((tcon->need_reconnect) ||\n\t    (CIFS_ALL_CHANS_NEED_RECONNECT(tcon->ses))) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\tinvalidate_all_cached_dirs(tcon);\n\n\trc = smb2_plain_req_init(SMB2_TREE_DISCONNECT, tcon, ses->server,\n\t\t\t\t (void **) &req,\n\t\t\t\t &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, ses->server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\t\ttrace_smb3_tdis_err(xid, tcon->tid, ses->Suid, rc);\n\t}\n\ttrace_smb3_tdis_done(xid, tcon->tid, ses->Suid);\n\n\treturn rc;\n}\n\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic void\nparse_query_id_ctxt(struct create_context *cc, struct smb2_file_all_info *buf)\n{\n\tstruct create_disk_id_rsp *pdisk_id = (struct create_disk_id_rsp *)cc;\n\n\tcifs_dbg(FYI, \"parse query id context 0x%llx 0x%llx\\n\",\n\t\tpdisk_id->DiskFileId, pdisk_id->VolumeId);\n\tbuf->IndexNumber = pdisk_id->DiskFileId;\n}\n\nstatic void\nparse_posix_ctxt(struct create_context *cc, struct smb2_file_all_info *info,\n\t\t struct create_posix_rsp *posix)\n{\n\tint sid_len;\n\tu8 *beg = (u8 *)cc + le16_to_cpu(cc->DataOffset);\n\tu8 *end = beg + le32_to_cpu(cc->DataLength);\n\tu8 *sid;\n\n\tmemset(posix, 0, sizeof(*posix));\n\n\tposix->nlink = le32_to_cpu(*(__le32 *)(beg + 0));\n\tposix->reparse_tag = le32_to_cpu(*(__le32 *)(beg + 4));\n\tposix->mode = le32_to_cpu(*(__le32 *)(beg + 8));\n\n\tsid = beg + 12;\n\tsid_len = posix_info_sid_size(sid, end);\n\tif (sid_len < 0) {\n\t\tcifs_dbg(VFS, \"bad owner sid in posix create response\\n\");\n\t\treturn;\n\t}\n\tmemcpy(&posix->owner, sid, sid_len);\n\n\tsid = sid + sid_len;\n\tsid_len = posix_info_sid_size(sid, end);\n\tif (sid_len < 0) {\n\t\tcifs_dbg(VFS, \"bad group sid in posix create response\\n\");\n\t\treturn;\n\t}\n\tmemcpy(&posix->group, sid, sid_len);\n\n\tcifs_dbg(FYI, \"nlink=%d mode=%o reparse_tag=%x\\n\",\n\t\t posix->nlink, posix->mode, posix->reparse_tag);\n}\n\nint smb2_parse_contexts(struct TCP_Server_Info *server,\n\t\t\tstruct kvec *rsp_iov,\n\t\t\tunsigned int *epoch,\n\t\t\tchar *lease_key, __u8 *oplock,\n\t\t\tstruct smb2_file_all_info *buf,\n\t\t\tstruct create_posix_rsp *posix)\n{\n\tstruct smb2_create_rsp *rsp = rsp_iov->iov_base;\n\tstruct create_context *cc;\n\tsize_t rem, off, len;\n\tsize_t doff, dlen;\n\tsize_t noff, nlen;\n\tchar *name;\n\tstatic const char smb3_create_tag_posix[] = {\n\t\t0x93, 0xAD, 0x25, 0x50, 0x9C,\n\t\t0xB4, 0x11, 0xE7, 0xB4, 0x23, 0x83,\n\t\t0xDE, 0x96, 0x8B, 0xCD, 0x7C\n\t};\n\n\t*oplock = 0;\n\n\toff = le32_to_cpu(rsp->CreateContextsOffset);\n\trem = le32_to_cpu(rsp->CreateContextsLength);\n\tif (check_add_overflow(off, rem, &len) || len > rsp_iov->iov_len)\n\t\treturn -EINVAL;\n\tcc = (struct create_context *)((u8 *)rsp + off);\n\n\t \n\tif (buf)\n\t\tbuf->IndexNumber = 0;\n\n\twhile (rem >= sizeof(*cc)) {\n\t\tdoff = le16_to_cpu(cc->DataOffset);\n\t\tdlen = le32_to_cpu(cc->DataLength);\n\t\tif (check_add_overflow(doff, dlen, &len) || len > rem)\n\t\t\treturn -EINVAL;\n\n\t\tnoff = le16_to_cpu(cc->NameOffset);\n\t\tnlen = le16_to_cpu(cc->NameLength);\n\t\tif (noff + nlen >= doff)\n\t\t\treturn -EINVAL;\n\n\t\tname = (char *)cc + noff;\n\t\tswitch (nlen) {\n\t\tcase 4:\n\t\t\tif (!strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {\n\t\t\t\t*oplock = server->ops->parse_lease_buf(cc, epoch,\n\t\t\t\t\t\t\t\t       lease_key);\n\t\t\t} else if (buf &&\n\t\t\t\t   !strncmp(name, SMB2_CREATE_QUERY_ON_DISK_ID, 4)) {\n\t\t\t\tparse_query_id_ctxt(cc, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (posix && !memcmp(name, smb3_create_tag_posix, 16))\n\t\t\t\tparse_posix_ctxt(cc, buf, posix);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"%s: unhandled context (nlen=%zu dlen=%zu)\\n\",\n\t\t\t\t __func__, nlen, dlen);\n\t\t\tif (IS_ENABLED(CONFIG_CIFS_DEBUG2))\n\t\t\t\tcifs_dump_mem(\"context data: \", cc, dlen);\n\t\t\tbreak;\n\t\t}\n\n\t\toff = le32_to_cpu(cc->Next);\n\t\tif (!off)\n\t\t\tbreak;\n\t\tif (check_sub_overflow(rem, off, &rem))\n\t\t\treturn -EINVAL;\n\t\tcc = (struct create_context *)((u8 *)cc + off);\n\t}\n\n\tif (rsp->OplockLevel != SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = rsp->OplockLevel;\n\n\treturn 0;\n}\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server,\n\t\t  struct smb2_create_req *req,\n\t\t  struct kvec *iov,\n\t\t  unsigned int *num_iovec, u8 *lease_key, __u8 *oplock)\n{\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(lease_key, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct create_durable_v2 *\ncreate_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\t \n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable_handle_reconnect_v2 *\ncreate_reconnect_durable_v2_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable_handle_reconnect_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_handle_reconnect_v2),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t\t     dcontext));\n\tbuf->ccontext.DataLength =\n\t\tcpu_to_le32(sizeof(struct durable_reconnect_context_v2));\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t    Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->dcontext.Fid.VolatileFileId = fid->volatile_fid;\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tmemcpy(buf->dcontext.CreateGuid, fid->create_guid, 16);\n\n\t \n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic int\nadd_durable_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_durable_v2_buf(oparms);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_v2);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_reconnect_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tunsigned int num = *num_iovec;\n\n\t \n\toparms->reconnect = false;\n\n\tiov[num].iov_base = create_reconnect_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_handle_reconnect_v2);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms, bool use_persistent)\n{\n\tunsigned int num = *num_iovec;\n\n\tif (use_persistent) {\n\t\tif (oparms->reconnect)\n\t\t\treturn add_durable_reconnect_v2_context(iov, num_iovec,\n\t\t\t\t\t\t\t\toparms);\n\t\telse\n\t\t\treturn add_durable_v2_context(iov, num_iovec, oparms);\n\t}\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t \n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n \nstatic struct crt_twarp_ctxt *\ncreate_twarp_buf(__u64 timewarp)\n{\n\tstruct crt_twarp_ctxt *buf;\n\n\tbuf = kzalloc(sizeof(struct crt_twarp_ctxt), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct crt_twarp_ctxt, Timestamp));\n\tbuf->ccontext.DataLength = cpu_to_le32(8);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct crt_twarp_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'T';\n\tbuf->Name[1] = 'W';\n\tbuf->Name[2] = 'r';\n\tbuf->Name[3] = 'p';\n\tbuf->Timestamp = cpu_to_le64(timewarp);\n\treturn buf;\n}\n\n \nstatic int\nadd_twarp_context(struct kvec *iov, unsigned int *num_iovec, __u64 timewarp)\n{\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_twarp_buf(timewarp);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct crt_twarp_ctxt);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\n \n\tsids->owner.Revision = 1;\n\tsids->owner.NumAuth = 3;\n\tsids->owner.Authority[5] = 5;\n\tsids->owner.SubAuthorities[0] = cpu_to_le32(88);\n\tsids->owner.SubAuthorities[1] = cpu_to_le32(1);\n\tsids->owner.SubAuthorities[2] = cpu_to_le32(current_fsuid().val);\n\n\t \n\tsids->group.Revision = 1;\n\tsids->group.NumAuth = 3;\n\tsids->group.Authority[5] = 5;\n\tsids->group.SubAuthorities[0] = cpu_to_le32(88);\n\tsids->group.SubAuthorities[1] = cpu_to_le32(2);\n\tsids->group.SubAuthorities[2] = cpu_to_le32(current_fsgid().val);\n\n\tcifs_dbg(FYI, \"owner S-1-5-88-1-%d, group S-1-5-88-2-%d\\n\", current_fsuid().val, current_fsgid().val);\n}\n\n \nstatic struct crt_sd_ctxt *\ncreate_sd_buf(umode_t mode, bool set_owner, unsigned int *len)\n{\n\tstruct crt_sd_ctxt *buf;\n\t__u8 *ptr, *aclptr;\n\tunsigned int acelen, acl_size, ace_count;\n\tunsigned int owner_offset = 0;\n\tunsigned int group_offset = 0;\n\tstruct smb3_acl acl = {};\n\n\t*len = round_up(sizeof(struct crt_sd_ctxt) + (sizeof(struct cifs_ace) * 4), 8);\n\n\tif (set_owner) {\n\t\t \n\t\t*len += sizeof(struct owner_group_sids);\n\t}\n\n\tbuf = kzalloc(*len, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn buf;\n\n\tptr = (__u8 *)&buf[1];\n\tif (set_owner) {\n\t\t \n\t\towner_offset = ptr - (__u8 *)&buf->sd;\n\t\tbuf->sd.OffsetOwner = cpu_to_le32(owner_offset);\n\t\tgroup_offset = owner_offset + offsetof(struct owner_group_sids, group);\n\t\tbuf->sd.OffsetGroup = cpu_to_le32(group_offset);\n\n\t\tsetup_owner_group_sids(ptr);\n\t\tptr += sizeof(struct owner_group_sids);\n\t} else {\n\t\tbuf->sd.OffsetOwner = 0;\n\t\tbuf->sd.OffsetGroup = 0;\n\t}\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof(struct crt_sd_ctxt, sd));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof(struct crt_sd_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'S';\n\tbuf->Name[1] = 'e';\n\tbuf->Name[2] = 'c';\n\tbuf->Name[3] = 'D';\n\tbuf->sd.Revision = 1;   \n\n\t \n\tbuf->sd.Control = cpu_to_le16(ACL_CONTROL_SR | ACL_CONTROL_DP);\n\n\t \n\tbuf->sd.OffsetDacl = cpu_to_le32(ptr - (__u8 *)&buf->sd);\n\t \n\taclptr = ptr;\n\tptr += sizeof(struct smb3_acl);\n\n\t \n\tacelen = setup_special_mode_ACE((struct cifs_ace *)ptr, (__u64)mode);\n\tptr += acelen;\n\tacl_size = acelen + sizeof(struct smb3_acl);\n\tace_count = 1;\n\n\tif (set_owner) {\n\t\t \n\t\tacelen = setup_special_user_owner_ACE((struct cifs_ace *)ptr);\n\t\tptr += acelen;\n\t\tacl_size += acelen;\n\t\tace_count += 1;\n\t}\n\n\t \n\tacelen = setup_authusers_ACE((struct cifs_ace *)ptr);\n\tptr += acelen;\n\tacl_size += acelen;\n\tace_count += 1;\n\n\tacl.AclRevision = ACL_REVISION;  \n\tacl.AclSize = cpu_to_le16(acl_size);\n\tacl.AceCount = cpu_to_le16(ace_count);\n\t \n\tmemcpy(aclptr, &acl, sizeof(struct smb3_acl));\n\n\tbuf->ccontext.DataLength = cpu_to_le32(ptr - (__u8 *)&buf->sd);\n\t*len = round_up((unsigned int)(ptr - (__u8 *)buf), 8);\n\n\treturn buf;\n}\n\nstatic int\nadd_sd_context(struct kvec *iov, unsigned int *num_iovec, umode_t mode, bool set_owner)\n{\n\tunsigned int num = *num_iovec;\n\tunsigned int len = 0;\n\n\tiov[num].iov_base = create_sd_buf(mode, set_owner, &len);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = len;\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct crt_query_id_ctxt *\ncreate_query_id_buf(void)\n{\n\tstruct crt_query_id_ctxt *buf;\n\n\tbuf = kzalloc(sizeof(struct crt_query_id_ctxt), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(0);\n\tbuf->ccontext.DataLength = cpu_to_le32(0);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct crt_query_id_ctxt, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t \n\tbuf->Name[0] = 'Q';\n\tbuf->Name[1] = 'F';\n\tbuf->Name[2] = 'i';\n\tbuf->Name[3] = 'd';\n\treturn buf;\n}\n\n \nstatic int\nadd_query_id_context(struct kvec *iov, unsigned int *num_iovec)\n{\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_query_id_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct crt_query_id_ctxt);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nalloc_path_with_tree_prefix(__le16 **out_path, int *out_size, int *out_len,\n\t\t\t    const char *treename, const __le16 *path)\n{\n\tint treename_len, path_len;\n\tstruct nls_table *cp;\n\tconst __le16 sep[] = {cpu_to_le16('\\\\'), cpu_to_le16(0x0000)};\n\n\t \n\ttreename_len = strlen(treename);\n\tif (treename_len < 2 || !(treename[0] == '\\\\' && treename[1] == '\\\\'))\n\t\treturn -EINVAL;\n\n\ttreename += 2;\n\ttreename_len -= 2;\n\n\tpath_len = UniStrnlen((wchar_t *)path, PATH_MAX);\n\n\t \n\t*out_len = treename_len + (path[0] ? 1 : 0) + path_len;\n\n\t \n\t*out_size = round_up(*out_len * sizeof(__le16), 8);\n\t*out_path = kzalloc(*out_size + sizeof(__le16)  , GFP_KERNEL);\n\tif (!*out_path)\n\t\treturn -ENOMEM;\n\n\tcp = load_nls_default();\n\tcifs_strtoUTF16(*out_path, treename, treename_len, cp);\n\n\t \n\tif (path[0] != cpu_to_le16(0x0000)) {\n\t\tUniStrcat((wchar_t *)*out_path, (wchar_t *)sep);\n\t\tUniStrcat((wchar_t *)*out_path, (wchar_t *)path);\n\t}\n\n\tunload_nls(cp);\n\n\treturn 0;\n}\n\nint smb311_posix_mkdir(const unsigned int xid, struct inode *inode,\n\t\t\t       umode_t mode, struct cifs_tcon *tcon,\n\t\t\t       const char *full_path,\n\t\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[3];  \n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tchar *pc_buf = NULL;\n\tint flags = 0;\n\tunsigned int total_len;\n\t__le16 *utf16_path = NULL;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\n\tcifs_dbg(FYI, \"mkdir\\n\");\n\n\t \n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\tif (!ses || !server) {\n\t\trc = -EIO;\n\t\tgoto err_free_path;\n\t}\n\n\t \n\trc = smb2_plain_req_init(SMB2_CREATE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\tgoto err_free_path;\n\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(FILE_WRITE_ATTRIBUTES);\n\t \n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(FILE_CREATE);\n\treq->CreateOptions = cpu_to_le32(CREATE_NOT_FILE);\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req));\n\n\t \n\tif (tcon->share_flags & SHI1005_FLAGS_DFS) {\n\t\tint name_len;\n\n\t\treq->hdr.Flags |= SMB2_FLAGS_DFS_OPERATIONS;\n\t\trc = alloc_path_with_tree_prefix(&copy_path, &copy_size,\n\t\t\t\t\t\t &name_len,\n\t\t\t\t\t\t tcon->tree_name, utf16_path);\n\t\tif (rc)\n\t\t\tgoto err_free_req;\n\n\t\treq->NameLength = cpu_to_le16(name_len * 2);\n\t\tuni_path_len = copy_size;\n\t\t \n\t\tkfree(utf16_path);\n\t\tutf16_path = copy_path;\n\t} else {\n\t\tuni_path_len = (2 * UniStrnlen((wchar_t *)utf16_path, PATH_MAX)) + 2;\n\t\t \n\t\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t\tif (uni_path_len % 8 != 0) {\n\t\t\tcopy_size = roundup(uni_path_len, 8);\n\t\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\t\tif (!copy_path) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto err_free_req;\n\t\t\t}\n\t\t\tmemcpy((char *)copy_path, (const char *)utf16_path,\n\t\t\t       uni_path_len);\n\t\t\tuni_path_len = copy_size;\n\t\t\t \n\t\t\tkfree(utf16_path);\n\t\t\tutf16_path = copy_path;\n\t\t}\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = utf16_path;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (tcon->posix_extensions) {\n\t\t \n\t\trc = add_posix_context(iov, &n_iov, mode);\n\t\tif (rc)\n\t\t\tgoto err_free_req;\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\tsizeof(struct smb2_create_req) +\n\t\t\tiov[1].iov_len);\n\t\tpc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_iov;\n\n\t \n\ttrace_smb3_posix_mkdir_enter(xid, tcon->tid, ses->Suid, full_path, CREATE_NOT_FILE,\n\t\t\t\t    FILE_WRITE_ATTRIBUTES);\n\t \n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\ttrace_smb3_posix_mkdir_err(xid, tcon->tid, ses->Suid,\n\t\t\t\t\t   CREATE_NOT_FILE,\n\t\t\t\t\t   FILE_WRITE_ATTRIBUTES, rc);\n\t\tgoto err_free_rsp_buf;\n\t}\n\n\t \n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\tif (rsp == NULL) {\n\t\trc = -EIO;\n\t\tkfree(pc_buf);\n\t\tgoto err_free_req;\n\t}\n\n\ttrace_smb3_posix_mkdir_done(xid, rsp->PersistentFileId, tcon->tid, ses->Suid,\n\t\t\t\t    CREATE_NOT_FILE, FILE_WRITE_ATTRIBUTES);\n\n\tSMB2_close(xid, tcon, rsp->PersistentFileId, rsp->VolatileFileId);\n\n\t \n\nerr_free_rsp_buf:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(pc_buf);\nerr_free_req:\n\tcifs_small_buf_release(req);\nerr_free_path:\n\tkfree(utf16_path);\n\treturn rc;\n}\n\nint\nSMB2_open_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t       struct smb_rqst *rqst, __u8 *oplock,\n\t       struct cifs_open_parms *oparms, __le16 *path)\n{\n\tstruct smb2_create_req *req;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tint copy_size;\n\tint uni_path_len;\n\tunsigned int total_len;\n\tstruct kvec *iov = rqst->rq_iov;\n\t__le16 *copy_path;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CREATE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t \n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req));\n\n\t \n\tif (tcon->share_flags & SHI1005_FLAGS_DFS) {\n\t\tint name_len;\n\n\t\treq->hdr.Flags |= SMB2_FLAGS_DFS_OPERATIONS;\n\t\trc = alloc_path_with_tree_prefix(&copy_path, &copy_size,\n\t\t\t\t\t\t &name_len,\n\t\t\t\t\t\t tcon->tree_name, path);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\treq->NameLength = cpu_to_le16(name_len * 2);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t} else {\n\t\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t\t \n\t\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t\tcopy_size = round_up(uni_path_len, 8);\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t       uni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\n\tif ((!server->oplocks) || (tcon->no_lease))\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse if (!(server->capabilities & SMB2_GLOBAL_CAP_DIRECTORY_LEASING) &&\n\t\t  (oparms->create_options & CREATE_NOT_FILE))\n\t\treq->RequestedOplockLevel = *oplock;  \n\telse {\n\t\trc = add_lease_context(server, req, iov, &n_iov,\n\t\t\t\t       oparms->fid->lease_key, oplock);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\trc = add_durable_context(iov, &n_iov, oparms,\n\t\t\t\t\ttcon->use_persistent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (tcon->posix_extensions) {\n\t\trc = add_posix_context(iov, &n_iov, oparms->mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (tcon->snapshot_time) {\n\t\tcifs_dbg(FYI, \"adding snapshot context\\n\");\n\t\trc = add_twarp_context(iov, &n_iov, tcon->snapshot_time);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((oparms->disposition != FILE_OPEN) && (oparms->cifs_sb)) {\n\t\tbool set_mode;\n\t\tbool set_owner;\n\n\t\tif ((oparms->cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID) &&\n\t\t    (oparms->mode != ACL_NO_MODE))\n\t\t\tset_mode = true;\n\t\telse {\n\t\t\tset_mode = false;\n\t\t\toparms->mode = ACL_NO_MODE;\n\t\t}\n\n\t\tif (oparms->cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL)\n\t\t\tset_owner = true;\n\t\telse\n\t\t\tset_owner = false;\n\n\t\tif (set_owner | set_mode) {\n\t\t\tcifs_dbg(FYI, \"add sd with mode 0x%x\\n\", oparms->mode);\n\t\t\trc = add_sd_context(iov, &n_iov, oparms->mode, set_owner);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tadd_query_id_context(iov, &n_iov);\n\n\tif (n_iov > 2) {\n\t\t \n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\tsizeof(struct smb2_create_req) +\n\t\t\tiov[1].iov_len);\n\t\treq->CreateContextsLength = 0;\n\n\t\tfor (unsigned int i = 2; i < (n_iov-1); i++) {\n\t\t\tstruct kvec *v = &iov[i];\n\t\t\tsize_t len = v->iov_len;\n\t\t\tstruct create_context *cctx =\n\t\t\t\t(struct create_context *)v->iov_base;\n\n\t\t\tcctx->Next = cpu_to_le32(len);\n\t\t\tle32_add_cpu(&req->CreateContextsLength, len);\n\t\t}\n\t\tle32_add_cpu(&req->CreateContextsLength,\n\t\t\t     iov[n_iov-1].iov_len);\n\t}\n\n\trqst->rq_nvec = n_iov;\n\treturn 0;\n}\n\n \nvoid\nSMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct create_posix_rsp *posix,\n\t  struct kvec *err_iov, int *buftype)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_create_rsp *rsp = NULL;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct kvec iov[SMB2_CREATE_IOV_SIZE];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\trc = SMB2_open_init(tcon, server,\n\t\t\t    &rqst, oplock, oparms, path);\n\tif (rc)\n\t\tgoto creat_exit;\n\n\ttrace_smb3_open_enter(xid, tcon->tid, tcon->ses->Suid, oparms->path,\n\t\toparms->create_options, oparms->desired_access);\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_iov && rsp) {\n\t\t\t*err_iov = rsp_iov;\n\t\t\t*buftype = resp_buftype;\n\t\t\tresp_buftype = CIFS_NO_BUFFER;\n\t\t\trsp = NULL;\n\t\t}\n\t\ttrace_smb3_open_err(xid, tcon->tid, ses->Suid,\n\t\t\t\t    oparms->create_options, oparms->desired_access, rc);\n\t\tif (rc == -EREMCHG) {\n\t\t\tpr_warn_once(\"server share %s deleted\\n\",\n\t\t\t\t     tcon->tree_name);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto creat_exit;\n\t} else if (rsp == NULL)  \n\t\tgoto creat_exit;\n\telse\n\t\ttrace_smb3_open_done(xid, rsp->PersistentFileId, tcon->tid, ses->Suid,\n\t\t\t\t     oparms->create_options, oparms->desired_access);\n\n\tatomic_inc(&tcon->num_remote_opens);\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\toparms->fid->access = oparms->desired_access;\n#ifdef CONFIG_CIFS_DEBUG2\n\toparms->fid->mid = le64_to_cpu(rsp->hdr.MessageId);\n#endif  \n\n\tif (buf) {\n\t\tbuf->CreationTime = rsp->CreationTime;\n\t\tbuf->LastAccessTime = rsp->LastAccessTime;\n\t\tbuf->LastWriteTime = rsp->LastWriteTime;\n\t\tbuf->ChangeTime = rsp->ChangeTime;\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\n\trc = smb2_parse_contexts(server, &rsp_iov, &oparms->fid->epoch,\n\t\t\t\t oparms->fid->lease_key, oplock, buf, posix);\ncreat_exit:\n\tSMB2_open_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_ioctl_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tstruct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, u32 opcode,\n\t\tchar *in_data, u32 indatalen,\n\t\t__u32 max_response_size)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\tchar *in_data_buf;\n\n\trc = smb2_ioctl_req_init(opcode, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (indatalen) {\n\t\t \n\t\tin_data_buf = kmemdup(in_data, indatalen, GFP_NOFS);\n\t\tif (!in_data_buf) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t \n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer));\n\t\trqst->rq_nvec = 2;\n\t\tiov[0].iov_len = total_len - 1;\n\t\tiov[1].iov_base = in_data_buf;\n\t\tiov[1].iov_len = indatalen;\n\t} else {\n\t\trqst->rq_nvec = 1;\n\t\tiov[0].iov_len = total_len;\n\t}\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0;  \n\n\t \n\treq->MaxOutputResponse = cpu_to_le32(max_response_size);\n\treq->hdr.CreditCharge =\n\t\tcpu_to_le16(DIV_ROUND_UP(max(indatalen, max_response_size),\n\t\t\t\t\t SMB2_MAX_BUFFER_SIZE));\n\t \n\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\n\t \n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO)\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\treturn 0;\n}\n\nvoid\nSMB2_ioctl_free(struct smb_rqst *rqst)\n{\n\tint i;\n\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);  \n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}\n\n\n \nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, char *in_data, u32 indatalen,\n\t   u32 max_out_data_len, char **out_data,\n\t   u32 *plen  )\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_ioctl_rsp *rsp = NULL;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct kvec iov[SMB2_IOCTL_IOV_SIZE];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t \n\tif (plen)\n\t\t*plen = 0;\n\n\tif (!tcon)\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tif (!ses)\n\t\treturn -EIO;\n\n\tserver = cifs_pick_channel(ses);\n\tif (!server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_IOCTL_IOV_SIZE;\n\n\trc = SMB2_ioctl_init(tcon, server,\n\t\t\t     &rqst, persistent_fid, volatile_fid, opcode,\n\t\t\t     in_data, indatalen, max_out_data_len);\n\tif (rc)\n\t\tgoto ioctl_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\trsp = (struct smb2_ioctl_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0)\n\t\ttrace_smb3_fsctl_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, 0, opcode, rc);\n\n\tif ((rc != 0) && (rc != -EINVAL) && (rc != -E2BIG)) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t} else if (rc == -E2BIG) {\n\t\tif (opcode != FSCTL_QUERY_ALLOCATED_RANGES) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t \n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t \n\tif (rsp == NULL) {\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t \n\tif (*plen == 0)\n\t\tgoto ioctl_exit;  \n\telse if (*plen > rsp_iov.iov_len || *plen > 0xFF00) {\n\t\tcifs_tcon_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (rsp_iov.iov_len - *plen < le32_to_cpu(rsp->OutputOffset)) {\n\t\tcifs_tcon_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmemdup((char *)rsp + le32_to_cpu(rsp->OutputOffset),\n\t\t\t    *plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\nioctl_exit:\n\tSMB2_ioctl_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n \n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION,\n\t\t\t(char *)&fsctl_input  ,\n\t\t\t2  , CIFSMaxBufSize  ,\n\t\t\t&ret_data  , NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nSMB2_close_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tstruct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, bool query_attrs)\n{\n\tstruct smb2_close_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CLOSE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tif (query_attrs)\n\t\treq->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\telse\n\t\treq->Flags = 0;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nvoid\nSMB2_close_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);  \n}\n\nint\n__SMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t     u64 persistent_fid, u64 volatile_fid,\n\t     struct smb2_file_network_open_info *pbuf)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_close_rsp *rsp = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint rc = 0;\n\tint flags = 0;\n\tbool query_attrs = false;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\t \n\tif (pbuf)\n\t\tquery_attrs = true;\n\n\ttrace_smb3_close_enter(xid, persistent_fid, tcon->tid, ses->Suid);\n\trc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst, persistent_fid, volatile_fid,\n\t\t\t     query_attrs);\n\tif (rc)\n\t\tgoto close_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_close_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\ttrace_smb3_close_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t\tgoto close_exit;\n\t} else {\n\t\ttrace_smb3_close_done(xid, persistent_fid, tcon->tid,\n\t\t\t\t      ses->Suid);\n\t\tif (pbuf)\n\t\t\tmemcpy(&pbuf->network_open_info,\n\t\t\t       &rsp->network_open_info,\n\t\t\t       sizeof(pbuf->network_open_info));\n\t}\n\n\tatomic_dec(&tcon->num_remote_opens);\nclose_exit:\n\tSMB2_close_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\n\t \n\tif (is_interrupt_error(rc)) {\n\t\tint tmp_rc;\n\n\t\ttmp_rc = smb2_handle_cancelled_close(tcon, persistent_fid,\n\t\t\t\t\t\t     volatile_fid);\n\t\tif (tmp_rc)\n\t\t\tcifs_dbg(VFS, \"handle cancelled close fid 0x%llx returned error %d\\n\",\n\t\t\t\t persistent_fid, tmp_rc);\n\t}\n\treturn rc;\n}\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid)\n{\n\treturn __SMB2_close(xid, tcon, persistent_fid, volatile_fid, NULL);\n}\n\nint\nsmb2_validate_iov(unsigned int offset, unsigned int buffer_length,\n\t\t  struct kvec *iov, unsigned int min_buf_size)\n{\n\tunsigned int smb_len = iov->iov_len;\n\tchar *end_of_smb = smb_len + (char *)iov->iov_base;\n\tchar *begin_of_buf = offset + (char *)iov->iov_base;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"Invalid server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint\nsmb2_validate_and_copy_iov(unsigned int offset, unsigned int buffer_length,\n\t\t\t   struct kvec *iov, unsigned int minbufsize,\n\t\t\t   char *data)\n{\n\tchar *begin_of_buf = offset + (char *)iov->iov_base;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = smb2_validate_iov(offset, buffer_length, iov, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, minbufsize);\n\n\treturn 0;\n}\n\nint\nSMB2_query_info_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t     struct smb_rqst *rqst,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     u8 info_class, u8 info_type, u32 additional_info,\n\t\t     size_t output_len, size_t input_len, void *input)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tsize_t len;\n\tint rc;\n\n\tif (unlikely(check_add_overflow(input_len, sizeof(*req), &len) ||\n\t\t     len > CIFSMaxBufSize))\n\t\treturn -EINVAL;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = info_type;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\treq->AdditionalInformation = cpu_to_le32(additional_info);\n\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\tif (input_len) {\n\t\treq->InputBufferLength = cpu_to_le32(input_len);\n\t\t \n\t\treq->InputBufferOffset = cpu_to_le16(total_len - 1);\n\t\tmemcpy(req->Buffer, input, input_len);\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = len;\n\treturn 0;\n}\n\nvoid\nSMB2_query_info_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_buf_release(rqst->rq_iov[0].iov_base);  \n}\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class, u8 info_type,\n\t   u32 additional_info, size_t output_len, size_t min_len, void **data,\n\t\tu32 *dlen)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\tbool allocated = false;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (!ses)\n\t\treturn -EIO;\n\tserver = cifs_pick_channel(ses);\n\tif (!server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_query_info_init(tcon, server,\n\t\t\t\t  &rqst, persistent_fid, volatile_fid,\n\t\t\t\t  info_class, info_type, additional_info,\n\t\t\t\t  output_len, 0, NULL);\n\tif (rc)\n\t\tgoto qinf_exit;\n\n\ttrace_smb3_query_info_enter(xid, persistent_fid, tcon->tid,\n\t\t\t\t    ses->Suid, info_class, (__u32)info_type);\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\ttrace_smb3_query_info_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type, rc);\n\t\tgoto qinf_exit;\n\t}\n\n\ttrace_smb3_query_info_done(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type);\n\n\tif (dlen) {\n\t\t*dlen = le32_to_cpu(rsp->OutputBufferLength);\n\t\tif (!*data) {\n\t\t\t*data = kmalloc(*dlen, GFP_KERNEL);\n\t\t\tif (!*data) {\n\t\t\t\tcifs_tcon_dbg(VFS,\n\t\t\t\t\t\"Error %d allocating memory for acl\\n\",\n\t\t\t\t\trc);\n\t\t\t\t*dlen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto qinf_exit;\n\t\t\t}\n\t\t\tallocated = true;\n\t\t}\n\t}\n\n\trc = smb2_validate_and_copy_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t\tle32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t\t&rsp_iov, dlen ? *dlen : min_len, *data);\n\tif (rc && allocated) {\n\t\tkfree(*data);\n\t\t*data = NULL;\n\t\t*dlen = 0;\n\t}\n\nqinf_exit:\n\tSMB2_query_info_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint SMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\tu64 persistent_fid, u64 volatile_fid, struct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION, SMB2_O_INFO_FILE, 0,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), (void **)&data,\n\t\t\t  NULL);\n}\n\n#if 0\n \nint\nSMB311_posix_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid, struct smb311_posix_qinfo *data, u32 *plen)\n{\n\tsize_t output_len = sizeof(struct smb311_posix_qinfo *) +\n\t\t\t(sizeof(struct cifs_sid) * 2) + (PATH_MAX * 2);\n\t*plen = 0;\n\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  SMB_FIND_FILE_POSIX_INFO, SMB2_O_INFO_FILE, 0,\n\t\t\t  output_len, sizeof(struct smb311_posix_qinfo), (void **)&data, plen);\n\t \n}\n#endif\n\nint\nSMB2_query_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid,\n\t       void **data, u32 *plen, u32 extra_info)\n{\n\t__u32 additional_info = OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t\textra_info;\n\t*plen = 0;\n\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  0, SMB2_O_INFO_SECURITY, additional_info,\n\t\t\t  SMB2_MAX_BUFFER_SIZE, MIN_SEC_DESC_LEN, data, plen);\n}\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION, SMB2_O_INFO_FILE, 0,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  (void **)&uniqueid, NULL);\n}\n\n \n\nstatic int\nSMB2_notify_init(const unsigned int xid, struct smb_rqst *rqst,\n\t\t struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t u64 persistent_fid, u64 volatile_fid,\n\t\t u32 completion_filter, bool watch_tree)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_CHANGE_NOTIFY, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t \n\treq->OutputBufferLength =\n\t\tcpu_to_le32(SMB2_MAX_BUFFER_SIZE - MAX_SMB2_HDR_SIZE);\n\treq->CompletionFilter = cpu_to_le32(completion_filter);\n\tif (watch_tree)\n\t\treq->Flags = cpu_to_le16(SMB2_WATCH_TREE);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nint\nSMB2_change_notify(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid, bool watch_tree,\n\t\tu32 completion_filter, u32 max_out_data_len, char **out_data,\n\t\tu32 *plen  )\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct smb_rqst rqst;\n\tstruct smb2_change_notify_rsp *smb_rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint flags = 0;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"change notify\\n\");\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\tif (plen)\n\t\t*plen = 0;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_notify_init(xid, &rqst, tcon, server,\n\t\t\t      persistent_fid, volatile_fid,\n\t\t\t      completion_filter, watch_tree);\n\tif (rc)\n\t\tgoto cnotify_exit;\n\n\ttrace_smb3_notify_enter(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t(u8)watch_tree, completion_filter);\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CHANGE_NOTIFY_HE);\n\t\ttrace_smb3_notify_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t(u8)watch_tree, completion_filter, rc);\n\t} else {\n\t\ttrace_smb3_notify_done(xid, persistent_fid, tcon->tid,\n\t\t\tses->Suid, (u8)watch_tree, completion_filter);\n\t\t \n\t\tif ((rsp_iov.iov_base == NULL) ||\n\t\t    (rsp_iov.iov_len < sizeof(struct smb2_change_notify_rsp) + 1))\n\t\t\tgoto cnotify_exit;\n\n\t\tsmb_rsp = (struct smb2_change_notify_rsp *)rsp_iov.iov_base;\n\n\t\tsmb2_validate_iov(le16_to_cpu(smb_rsp->OutputBufferOffset),\n\t\t\t\tle32_to_cpu(smb_rsp->OutputBufferLength), &rsp_iov,\n\t\t\t\tsizeof(struct file_notify_information));\n\n\t\t*out_data = kmemdup((char *)smb_rsp + le16_to_cpu(smb_rsp->OutputBufferOffset),\n\t\t\t\tle32_to_cpu(smb_rsp->OutputBufferLength), GFP_KERNEL);\n\t\tif (*out_data == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cnotify_exit;\n\t\t} else if (plen)\n\t\t\t*plen = le32_to_cpu(smb_rsp->OutputBufferLength);\n\t}\n\n cnotify_exit:\n\tif (rqst.rq_iov)\n\t\tcifs_small_buf_release(rqst.rq_iov[0].iov_base);  \n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n\n\n \nstatic void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *rsp = (struct smb2_echo_rsp *)mid->resp_buf;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED\n\t    || mid->mid_state == MID_RESPONSE_MALFORMED) {\n\t\tcredits.value = le16_to_cpu(rsp->hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t}\n\n\trelease_mid(mid);\n\tadd_credits(server, &credits, CIFS_ECHO_OP);\n}\n\nvoid smb2_reconnect_server(struct work_struct *work)\n{\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, reconnect.work);\n\tstruct TCP_Server_Info *pserver;\n\tstruct cifs_ses *ses, *ses2;\n\tstruct cifs_tcon *tcon, *tcon2;\n\tstruct list_head tmp_list, tmp_ses_list;\n\tbool tcon_exist = false, ses_exist = false;\n\tbool tcon_selected = false;\n\tint rc;\n\tbool resched = false;\n\n\t \n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t \n\tmutex_lock(&pserver->reconnect_mutex);\n\n\tINIT_LIST_HEAD(&tmp_list);\n\tINIT_LIST_HEAD(&tmp_ses_list);\n\tcifs_dbg(FYI, \"Reconnecting tcons and channels\\n\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &pserver->smb_ses_list, smb_ses_list) {\n\t\tspin_lock(&ses->ses_lock);\n\t\tif (ses->ses_status == SES_EXITING) {\n\t\t\tspin_unlock(&ses->ses_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\ttcon_selected = false;\n\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->need_reconnect || tcon->need_reopen_files) {\n\t\t\t\ttcon->tc_count++;\n\t\t\t\tlist_add_tail(&tcon->rlist, &tmp_list);\n\t\t\t\ttcon_selected = tcon_exist = true;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (ses->tcon_ipc && ses->tcon_ipc->need_reconnect) {\n\t\t\tlist_add_tail(&ses->tcon_ipc->rlist, &tmp_list);\n\t\t\ttcon_selected = tcon_exist = true;\n\t\t\tcifs_smb_ses_inc_refcount(ses);\n\t\t}\n\t\t \n\t\tspin_lock(&ses->chan_lock);\n\t\tif (!tcon_selected && cifs_chan_needs_reconnect(ses, server)) {\n\t\t\tlist_add_tail(&ses->rlist, &tmp_ses_list);\n\t\t\tses_exist = true;\n\t\t\tcifs_smb_ses_inc_refcount(ses);\n\t\t}\n\t\tspin_unlock(&ses->chan_lock);\n\t}\n\t \n\tif (tcon_exist || ses_exist)\n\t\tserver->srv_count++;\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tlist_for_each_entry_safe(tcon, tcon2, &tmp_list, rlist) {\n\t\trc = smb2_reconnect(SMB2_INTERNAL_CMD, tcon, server);\n\t\tif (!rc)\n\t\t\tcifs_reopen_persistent_handles(tcon);\n\t\telse\n\t\t\tresched = true;\n\t\tlist_del_init(&tcon->rlist);\n\t\tif (tcon->ipc)\n\t\t\tcifs_put_smb_ses(tcon->ses);\n\t\telse\n\t\t\tcifs_put_tcon(tcon);\n\t}\n\n\tif (!ses_exist)\n\t\tgoto done;\n\n\t \n\ttcon = tcon_info_alloc(false);\n\tif (!tcon) {\n\t\tresched = true;\n\t\tlist_for_each_entry_safe(ses, ses2, &tmp_ses_list, rlist) {\n\t\t\tlist_del_init(&ses->rlist);\n\t\t\tcifs_put_smb_ses(ses);\n\t\t}\n\t\tgoto done;\n\t}\n\n\ttcon->status = TID_GOOD;\n\ttcon->retry = false;\n\ttcon->need_reconnect = false;\n\n\t \n\tlist_for_each_entry_safe(ses, ses2, &tmp_ses_list, rlist) {\n\t\ttcon->ses = ses;\n\t\trc = smb2_reconnect(SMB2_INTERNAL_CMD, tcon, server);\n\t\tif (rc)\n\t\t\tresched = true;\n\t\tlist_del_init(&ses->rlist);\n\t\tcifs_put_smb_ses(ses);\n\t}\n\ttconInfoFree(tcon);\n\ndone:\n\tcifs_dbg(FYI, \"Reconnecting tcons and channels finished\\n\");\n\tif (resched)\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 2 * HZ);\n\tmutex_unlock(&pserver->reconnect_mutex);\n\n\t \n\tif (tcon_exist || ses_exist)\n\t\tcifs_put_tcp_session(server, 1);\n}\n\nint\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov[1];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 1 };\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"In echo request for conn_id %lld\\n\", server->conn_id);\n\n\tspin_lock(&server->srv_lock);\n\tif (server->ops->need_neg &&\n\t    server->ops->need_neg(server)) {\n\t\tspin_unlock(&server->srv_lock);\n\t\t \n\t\tmod_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\treturn rc;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\trc = smb2_plain_req_init(SMB2_ECHO, NULL, server,\n\t\t\t\t (void **)&req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\tiov[0].iov_len = total_len;\n\tiov[0].iov_base = (char *)req;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, NULL,\n\t\t\t     server, CIFS_ECHO_OP, NULL);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\nvoid\nSMB2_flush_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);  \n}\n\nint\nSMB2_flush_init(const unsigned int xid, struct smb_rqst *rqst,\n\t\tstruct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\tu64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\treturn 0;\n}\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb_rqst rqst;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov = {NULL, 0};\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tint flags = 0;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = SMB2_flush_init(xid, &rqst, tcon, server,\n\t\t\t     persistent_fid, volatile_fid);\n\tif (rc)\n\t\tgoto flush_exit;\n\n\ttrace_smb3_flush_enter(xid, persistent_fid, tcon->tid, ses->Suid);\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t} else\n\t\ttrace_smb3_flush_done(xid, persistent_fid, tcon->tid,\n\t\t\t\t      ses->Suid);\n\n flush_exit:\n\tSMB2_flush_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\nstatic inline bool smb3_use_rdma_offload(struct cifs_io_parms *io_parms)\n{\n\tstruct TCP_Server_Info *server = io_parms->server;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\n\t \n\tif (!server || !tcon)\n\t\treturn false;\n\n\t \n\tif (!server->rdma || !server->smbd_conn)\n\t\treturn false;\n\n\t \n\tif (server->sign)\n\t\treturn false;\n\n\t \n\tif (smb3_encryption_required(tcon))\n\t\treturn false;\n\n\t \n\tif (io_parms->length < server->smbd_conn->rdma_readwrite_threshold)\n\t\treturn false;\n\n\treturn true;\n}\n#endif  \n\n \nstatic int\nsmb2_new_read_req(void **buf, unsigned int *total_len,\n\tstruct cifs_io_parms *io_parms, struct cifs_readdata *rdata,\n\tunsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\tstruct smb2_hdr *shdr;\n\tstruct TCP_Server_Info *server = io_parms->server;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, server,\n\t\t\t\t (void **) &req, total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->hdr;\n\tshdr->Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0;  \n\treq->ReadChannelInfoLength = 0;  \n\treq->Channel = 0;  \n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\ttrace_smb3_read_enter(0  ,\n\t\t\tio_parms->persistent_fid,\n\t\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\t\tio_parms->offset, io_parms->length);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t \n\tif (smb3_use_rdma_offload(io_parms)) {\n\t\tstruct smbd_buffer_descriptor_v1 *v1;\n\t\tbool need_invalidate = server->dialect == SMB30_PROT_ID;\n\n\t\trdata->mr = smbd_register_mr(server->smbd_conn, &rdata->iter,\n\t\t\t\t\t     true, need_invalidate);\n\t\tif (!rdata->mr)\n\t\t\treturn -EAGAIN;\n\n\t\treq->Channel = SMB2_CHANNEL_RDMA_V1_INVALIDATE;\n\t\tif (need_invalidate)\n\t\t\treq->Channel = SMB2_CHANNEL_RDMA_V1;\n\t\treq->ReadChannelInfoOffset =\n\t\t\tcpu_to_le16(offsetof(struct smb2_read_req, Buffer));\n\t\treq->ReadChannelInfoLength =\n\t\t\tcpu_to_le16(sizeof(struct smbd_buffer_descriptor_v1));\n\t\tv1 = (struct smbd_buffer_descriptor_v1 *) &req->Buffer[0];\n\t\tv1->offset = cpu_to_le64(rdata->mr->mr->iova);\n\t\tv1->token = cpu_to_le32(rdata->mr->mr->rkey);\n\t\tv1->length = cpu_to_le32(rdata->mr->mr->length);\n\n\t\t*total_len += sizeof(*v1) - 1;\n\t}\n#endif\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t \n\t\t\t*total_len = ALIGN(*total_len, 8);\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else  \n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t \n\t\t\tshdr->SessionId = cpu_to_le64(0xFFFFFFFFFFFFFFFF);\n\t\t\tshdr->Id.SyncId.TreeId = cpu_to_le32(0xFFFFFFFF);\n\t\t\treq->PersistentFileId = (u64)-1;\n\t\t\treq->VolatileFileId = (u64)-1;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n\nstatic void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = rdata->server;\n\tstruct smb2_hdr *shdr =\n\t\t\t\t(struct smb2_hdr *)rdata->iov[0].iov_base;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\tstruct smb_rqst rqst = { .rq_iov = &rdata->iov[1], .rq_nvec = 1 };\n\n\tif (rdata->got_bytes) {\n\t\trqst.rq_iter\t  = rdata->iter;\n\t\trqst.rq_iter_size = iov_iter_count(&rdata->iter);\n\t}\n\n\tWARN_ONCE(rdata->server != mid->server,\n\t\t  \"rdata server %p != mid server %p\",\n\t\t  rdata->server, mid->server);\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits.value = le16_to_cpu(shdr->CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\t \n\t\tif (server->sign && !mid->decrypted) {\n\t\t\tint rc;\n\n\t\t\tiov_iter_revert(&rqst.rq_iter, rdata->got_bytes);\n\t\t\tiov_iter_truncate(&rqst.rq_iter, rdata->got_bytes);\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_tcon_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t \n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t \n\t\t\trdata->got_bytes = 0;\n\t\t \n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\tcredits.value = le16_to_cpu(shdr->CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\tfallthrough;\n\tdefault:\n\t\trdata->result = -EIO;\n\t}\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t \n\tif (rdata->mr) {\n\t\tsmbd_deregister_mr(rdata->mr);\n\t\trdata->mr = NULL;\n\t}\n#endif\n\tif (rdata->result && rdata->result != -ENODATA) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\t\ttrace_smb3_read_err(0  ,\n\t\t\t\t    rdata->cfile->fid.persistent_fid,\n\t\t\t\t    tcon->tid, tcon->ses->Suid, rdata->offset,\n\t\t\t\t    rdata->bytes, rdata->result);\n\t} else\n\t\ttrace_smb3_read_done(0  ,\n\t\t\t\t     rdata->cfile->fid.persistent_fid,\n\t\t\t\t     tcon->tid, tcon->ses->Suid,\n\t\t\t\t     rdata->offset, rdata->got_bytes);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\trelease_mid(mid);\n\tadd_credits(server, &credits, 0);\n}\n\n \nint\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tchar *buf;\n\tstruct smb2_hdr *shdr;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 1 };\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tunsigned int total_len;\n\tint credit_request;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tif (!rdata->server)\n\t\trdata->server = cifs_pick_channel(tcon->ses);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.server = server = rdata->server;\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\trc = smb2_new_read_req(\n\t\t(void **) &buf, &total_len, &io_parms, rdata, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms.tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trdata->iov[0].iov_base = buf;\n\trdata->iov[0].iov_len = total_len;\n\n\tshdr = (struct smb2_hdr *)buf;\n\n\tif (rdata->credits.value > 0) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tcredit_request = le16_to_cpu(shdr->CreditCharge) + 8;\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, credit_request));\n\n\t\trc = adjust_credits(server, &rdata->credits, rdata->bytes);\n\t\tif (rc)\n\t\t\tgoto async_readv_out;\n\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     smb3_handle_read_data, rdata, flags,\n\t\t\t     &rdata->credits);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t\ttrace_smb3_read_err(0  , io_parms.persistent_fid,\n\t\t\t\t    io_parms.tcon->tid,\n\t\t\t\t    io_parms.tcon->ses->Suid,\n\t\t\t\t    io_parms.offset, io_parms.length, rc);\n\t}\n\nasync_readv_out:\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc;\n\tstruct smb2_read_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\tif (!io_parms->server)\n\t\tio_parms->server = cifs_pick_channel(io_parms->tcon->ses);\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, io_parms->server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid,\n\t\t\t\t\t    req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId, io_parms->tcon->tid,\n\t\t\t\t\t     ses->Suid, io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\tcifs_small_buf_release(req);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid,\n\t\t\t\t    req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}\n\n \nstatic void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = wdata->server;\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tstruct cifs_credits credits = { .value = 0, .instance = 0 };\n\n\tWARN_ONCE(wdata->server != mid->server,\n\t\t  \"wdata server %p != mid server %p\",\n\t\t  wdata->server, mid->server);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits.value = le16_to_cpu(rsp->hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\twdata->result = smb2_check_receive(mid, server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t \n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\tcredits.value = le16_to_cpu(rsp->hdr.CreditRequest);\n\t\tcredits.instance = server->reconnect_instance;\n\t\tfallthrough;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t \n\tif (wdata->mr) {\n\t\tsmbd_deregister_mr(wdata->mr);\n\t\twdata->mr = NULL;\n\t}\n#endif\n\tif (wdata->result) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t\ttrace_smb3_write_err(0  ,\n\t\t\t\t     wdata->cfile->fid.persistent_fid,\n\t\t\t\t     tcon->tid, tcon->ses->Suid, wdata->offset,\n\t\t\t\t     wdata->bytes, wdata->result);\n\t\tif (wdata->result == -ENOSPC)\n\t\t\tpr_warn_once(\"Out of space writing to %s\\n\",\n\t\t\t\t     tcon->tree_name);\n\t} else\n\t\ttrace_smb3_write_done(0  ,\n\t\t\t\t      wdata->cfile->fid.persistent_fid,\n\t\t\t\t      tcon->tid, tcon->ses->Suid,\n\t\t\t\t      wdata->offset, wdata->bytes);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\trelease_mid(mid);\n\tadd_credits(server, &credits, 0);\n}\n\n \nint\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_hdr *shdr;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = wdata->server;\n\tstruct kvec iov[1];\n\tstruct smb_rqst rqst = { };\n\tunsigned int total_len;\n\tstruct cifs_io_parms _io_parms;\n\tstruct cifs_io_parms *io_parms = NULL;\n\tint credit_request;\n\n\tif (!wdata->server)\n\t\tserver = wdata->server = cifs_pick_channel(tcon->ses);\n\n\t \n\t_io_parms = (struct cifs_io_parms) {\n\t\t.tcon = tcon,\n\t\t.server = server,\n\t\t.offset = wdata->offset,\n\t\t.length = wdata->bytes,\n\t\t.persistent_fid = wdata->cfile->fid.persistent_fid,\n\t\t.volatile_fid = wdata->cfile->fid.volatile_fid,\n\t\t.pid = wdata->pid,\n\t};\n\tio_parms = &_io_parms;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tshdr = (struct smb2_hdr *)req;\n\tshdr->Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = SMB2_CHANNEL_NONE;\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(0  ,\n\t\t\t       io_parms->persistent_fid,\n\t\t\t       io_parms->tcon->tid,\n\t\t\t       io_parms->tcon->ses->Suid,\n\t\t\t       io_parms->offset,\n\t\t\t       io_parms->length);\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t \n\tif (smb3_use_rdma_offload(io_parms)) {\n\t\tstruct smbd_buffer_descriptor_v1 *v1;\n\t\tsize_t data_size = iov_iter_count(&wdata->iter);\n\t\tbool need_invalidate = server->dialect == SMB30_PROT_ID;\n\n\t\twdata->mr = smbd_register_mr(server->smbd_conn, &wdata->iter,\n\t\t\t\t\t     false, need_invalidate);\n\t\tif (!wdata->mr) {\n\t\t\trc = -EAGAIN;\n\t\t\tgoto async_writev_out;\n\t\t}\n\t\treq->Length = 0;\n\t\treq->DataOffset = 0;\n\t\treq->RemainingBytes = cpu_to_le32(data_size);\n\t\treq->Channel = SMB2_CHANNEL_RDMA_V1_INVALIDATE;\n\t\tif (need_invalidate)\n\t\t\treq->Channel = SMB2_CHANNEL_RDMA_V1;\n\t\treq->WriteChannelInfoOffset =\n\t\t\tcpu_to_le16(offsetof(struct smb2_write_req, Buffer));\n\t\treq->WriteChannelInfoLength =\n\t\t\tcpu_to_le16(sizeof(struct smbd_buffer_descriptor_v1));\n\t\tv1 = (struct smbd_buffer_descriptor_v1 *) &req->Buffer[0];\n\t\tv1->offset = cpu_to_le64(wdata->mr->mr->iova);\n\t\tv1->token = cpu_to_le32(wdata->mr->mr->rkey);\n\t\tv1->length = cpu_to_le32(wdata->mr->mr->length);\n\t}\n#endif\n\tiov[0].iov_len = total_len - 1;\n\tiov[0].iov_base = (char *)req;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trqst.rq_iter = wdata->iter;\n\trqst.rq_iter_size = iov_iter_count(&rqst.rq_iter);\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\tif (wdata->mr)\n\t\tiov[0].iov_len += sizeof(struct smbd_buffer_descriptor_v1);\n#endif\n\tcifs_dbg(FYI, \"async write at %llu %u bytes iter=%zx\\n\",\n\t\t io_parms->offset, io_parms->length, iov_iter_count(&rqst.rq_iter));\n\n#ifdef CONFIG_CIFS_SMB_DIRECT\n\t \n\tif (!wdata->mr)\n\t\treq->Length = cpu_to_le32(io_parms->length);\n#else\n\treq->Length = cpu_to_le32(io_parms->length);\n#endif\n\n\tif (wdata->credits.value > 0) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tcredit_request = le16_to_cpu(shdr->CreditCharge) + 8;\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, credit_request));\n\n\t\trc = adjust_credits(server, &wdata->credits, io_parms->length);\n\t\tif (rc)\n\t\t\tgoto async_writev_out;\n\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, NULL,\n\t\t\t     wdata, flags, &wdata->credits);\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(0  ,\n\t\t\t\t     io_parms->persistent_fid,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset,\n\t\t\t\t     io_parms->length,\n\t\t\t\t     rc);\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\n \nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\tif (!io_parms->server)\n\t\tio_parms->server = cifs_pick_channel(io_parms->tcon->ses);\n\tserver = io_parms->server;\n\tif (server == NULL)\n\t\treturn -ECONNABORTED;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, server,\n\t\t\t    &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid,\n\t\t\t\t     req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid,\n\t\t\t\t      req->PersistentFileId,\n\t\t\t\t      io_parms->tcon->tid,\n\t\t\t\t      io_parms->tcon->ses->Suid,\n\t\t\t\t      io_parms->offset, *nbytes);\n\t}\n\n\tcifs_small_buf_release(req);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint posix_info_sid_size(const void *beg, const void *end)\n{\n\tsize_t subauth;\n\tint total;\n\n\tif (beg + 1 > end)\n\t\treturn -1;\n\n\tsubauth = *(u8 *)(beg+1);\n\tif (subauth < 1 || subauth > 15)\n\t\treturn -1;\n\n\ttotal = 1 + 1 + 6 + 4*subauth;\n\tif (beg + total > end)\n\t\treturn -1;\n\n\treturn total;\n}\n\nint posix_info_parse(const void *beg, const void *end,\n\t\t     struct smb2_posix_info_parsed *out)\n\n{\n\tint total_len = 0;\n\tint owner_len, group_len;\n\tint name_len;\n\tconst void *owner_sid;\n\tconst void *group_sid;\n\tconst void *name;\n\n\t \n\tif (!end) {\n\t\tconst struct smb2_posix_info *p = beg;\n\n\t\tend = beg + le32_to_cpu(p->NextEntryOffset);\n\t\t \n\t\tif (end == beg)\n\t\t\tend += 0xFFFF;\n\t}\n\n\t \n\tif (beg + sizeof(struct smb2_posix_info) > end)\n\t\treturn -1;\n\ttotal_len = sizeof(struct smb2_posix_info);\n\n\t \n\towner_sid = beg + total_len;\n\towner_len = posix_info_sid_size(owner_sid, end);\n\tif (owner_len < 0)\n\t\treturn -1;\n\ttotal_len += owner_len;\n\n\t \n\tgroup_sid = beg + total_len;\n\tgroup_len = posix_info_sid_size(group_sid, end);\n\tif (group_len < 0)\n\t\treturn -1;\n\ttotal_len += group_len;\n\n\t \n\tif (beg + total_len + 4 > end)\n\t\treturn -1;\n\tname_len = le32_to_cpu(*(__le32 *)(beg + total_len));\n\tif (name_len < 1 || name_len > 0xFFFF)\n\t\treturn -1;\n\ttotal_len += 4;\n\n\t \n\tname = beg + total_len;\n\tif (name + name_len > end)\n\t\treturn -1;\n\ttotal_len += name_len;\n\n\tif (out) {\n\t\tout->base = beg;\n\t\tout->size = total_len;\n\t\tout->name_len = name_len;\n\t\tout->name = name;\n\t\tmemcpy(&out->owner, owner_sid, owner_len);\n\t\tmemcpy(&out->group, group_sid, group_len);\n\t}\n\treturn total_len;\n}\n\nstatic int posix_info_extra_size(const void *beg, const void *end)\n{\n\tint len = posix_info_parse(beg, end, NULL);\n\n\tif (len < 0)\n\t\treturn -1;\n\treturn len - sizeof(struct smb2_posix_info);\n}\n\nstatic unsigned int\nnum_entries(int infotype, char *bufstart, char *end_of_buf, char **lastentry,\n\t    size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tchar *entryptr;\n\tFILE_DIRECTORY_INFO *dir_info;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = bufstart;\n\n\twhile (1) {\n\t\tif (entryptr + next_offset < entryptr ||\n\t\t    entryptr + next_offset > end_of_buf ||\n\t\t    entryptr + next_offset + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tentryptr = entryptr + next_offset;\n\t\tdir_info = (FILE_DIRECTORY_INFO *)entryptr;\n\n\t\tif (infotype == SMB_FIND_FILE_POSIX_INFO)\n\t\t\tlen = posix_info_extra_size(entryptr, end_of_buf);\n\t\telse\n\t\t\tlen = le32_to_cpu(dir_info->FileNameLength);\n\n\t\tif (len < 0 ||\n\t\t    entryptr + len < entryptr ||\n\t\t    entryptr + len > end_of_buf ||\n\t\t    entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(dir_info->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}\n\n \nint SMB2_query_directory_init(const unsigned int xid,\n\t\t\t      struct cifs_tcon *tcon,\n\t\t\t      struct TCP_Server_Info *server,\n\t\t\t      struct smb_rqst *rqst,\n\t\t\t      u64 persistent_fid, u64 volatile_fid,\n\t\t\t      int index, int info_level)\n{\n\tstruct smb2_query_directory_req *req;\n\tunsigned char *bufptr;\n\t__le16 asteriks = cpu_to_le16('*');\n\tunsigned int output_size = CIFSMaxBufSize -\n\t\tMAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\tMAX_SMB2_CLOSE_RESPONSE_SIZE;\n\tunsigned int total_len;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint len, rc;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_DIRECTORY, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treq->FileInformationClass = SMB_FIND_FILE_POSIX_INFO;\n\t\tbreak;\n\tdefault:\n\t\tcifs_tcon_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\tinfo_level);\n\t\treturn -EINVAL;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req));\n\treq->FileNameLength = cpu_to_le16(len);\n\t \n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\ttrace_smb3_query_dir_enter(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, output_size);\n\n\treturn 0;\n}\n\nvoid SMB2_query_directory_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);  \n\t}\n}\n\nint\nsmb2_parse_query_directory(struct cifs_tcon *tcon,\n\t\t\t   struct kvec *rsp_iov,\n\t\t\t   int resp_buftype,\n\t\t\t   struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_rsp *rsp;\n\tsize_t info_buf_size;\n\tchar *end_of_smb;\n\tint rc;\n\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov->iov_base;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO);\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\t \n\t\tinfo_buf_size = sizeof(struct smb2_posix_info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_tcon_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), rsp_iov,\n\t\t\t       info_buf_size);\n\tif (rc) {\n\t\tcifs_tcon_dbg(VFS, \"bad info payload\");\n\t\treturn rc;\n\t}\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry =\n\t\t(char *)rsp + le16_to_cpu(rsp->OutputBufferOffset);\n\tend_of_smb = rsp_iov->iov_len + (char *)rsp;\n\n\tsrch_inf->entries_in_buffer = num_entries(\n\t\tsrch_inf->info_level,\n\t\tsrch_inf->srch_entries_start,\n\t\tend_of_smb,\n\t\t&srch_inf->last_entry,\n\t\tinfo_buf_size);\n\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_tcon_dbg(VFS, \"Invalid search buffer type\\n\");\n\n\treturn 0;\n}\n\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb_rqst rqst;\n\tstruct kvec iov[SMB2_QUERY_DIRECTORY_IOV_SIZE];\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = 0;\n\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\tmemset(&iov, 0, sizeof(iov));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = SMB2_QUERY_DIRECTORY_IOV_SIZE;\n\n\trc = SMB2_query_directory_init(xid, tcon, server,\n\t\t\t\t       &rqst, persistent_fid,\n\t\t\t\t       volatile_fid, index,\n\t\t\t\t       srch_inf->info_level);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA &&\n\t\t    rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\ttrace_smb3_query_dir_done(xid, persistent_fid,\n\t\t\t\ttcon->tid, tcon->ses->Suid, index, 0);\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\ttrace_smb3_query_dir_err(xid, persistent_fid, tcon->tid,\n\t\t\t\ttcon->ses->Suid, index, 0, rc);\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\t}\n\t\tgoto qdir_exit;\n\t}\n\n\trc = smb2_parse_query_directory(tcon, &rsp_iov,\tresp_buftype,\n\t\t\t\t\tsrch_inf);\n\tif (rc) {\n\t\ttrace_smb3_query_dir_err(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, 0, rc);\n\t\tgoto qdir_exit;\n\t}\n\tresp_buftype = CIFS_NO_BUFFER;\n\n\ttrace_smb3_query_dir_done(xid, persistent_fid, tcon->tid,\n\t\t\ttcon->ses->Suid, index, srch_inf->entries_in_buffer);\n\nqdir_exit:\n\tSMB2_query_directory_free(&rqst);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_set_info_init(struct cifs_tcon *tcon, struct TCP_Server_Info *server,\n\t\t   struct smb_rqst *rqst,\n\t\t   u64 persistent_fid, u64 volatile_fid, u32 pid,\n\t\t   u8 info_class, u8 info_type, u32 additional_info,\n\t\t   void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int i, total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_SET_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.Id.SyncId.ProcessId = cpu_to_le32(pid);\n\treq->InfoType = info_type;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\treq->AdditionalInformation = cpu_to_le32(additional_info);\n\n\treq->BufferOffset = cpu_to_le16(sizeof(struct smb2_set_info_req));\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tmemcpy(req->Buffer, *data, *size);\n\ttotal_len += *size;\n\n\tiov[0].iov_base = (char *)req;\n\t \n\tiov[0].iov_len = total_len - 1;\n\n\tfor (i = 1; i < rqst->rq_nvec; i++) {\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\treturn 0;\n}\n\nvoid\nSMB2_set_info_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_buf_release(rqst->rq_iov[0].iov_base);  \n}\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, u8 info_class,\n\t       u8 info_type, u32 additional_info, unsigned int num,\n\t\tvoid **data, unsigned int *size)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = 0;\n\n\tif (!ses || !server)\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov = kmalloc_array(num, sizeof(struct kvec), GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = num;\n\n\trc = SMB2_set_info_init(tcon, server,\n\t\t\t\t&rqst, persistent_fid, volatile_fid, pid,\n\t\t\t\tinfo_class, info_type, additional_info,\n\t\t\t\tdata, size);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags,\n\t\t\t    &rsp_iov);\n\tSMB2_set_info_free(&rqst);\n\trsp = (struct smb2_set_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\t\ttrace_smb3_set_info_err(xid, persistent_fid, tcon->tid,\n\t\t\t\tses->Suid, info_class, (__u32)info_type, rc);\n\t}\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\ttrace_smb3_set_eof(xid, persistent_fid, tcon->tid, tcon->ses->Suid, le64_to_cpu(*eof));\n\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, SMB2_O_INFO_FILE,\n\t\t\t0, 1, &data, &size);\n}\n\nint\nSMB2_set_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct cifs_ntsd *pnntsd, int pacllen, int aclflag)\n{\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tcurrent->tgid, 0, SMB2_O_INFO_SECURITY, aclflag,\n\t\t\t1, (void **)&pnntsd, &pacllen);\n}\n\nint\nSMB2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid,\n\t    struct smb2_file_full_ea_info *buf, int len)\n{\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\tcurrent->tgid, FILE_FULL_EA_INFORMATION, SMB2_O_INFO_FILE,\n\t\t0, 1, (void **)&buf, &len);\n}\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tstruct smb_rqst rqst;\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tint flags = CIFS_OBREAK_OP;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = smb2_plain_req_init(SMB2_OPLOCK_BREAK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nvoid\nsmb2_copy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\t     struct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = kst->f_bavail =\n\t\t\tle64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}\n\nstatic void\ncopy_posix_fs_info_to_kstatfs(FILE_SYSTEM_POSIX_INFO *response_data,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(response_data->BlockSize);\n\tkst->f_blocks = le64_to_cpu(response_data->TotalBlocks);\n\tkst->f_bfree =  le64_to_cpu(response_data->BlocksAvail);\n\tif (response_data->UserBlocksAvail == cpu_to_le64(-1))\n\t\tkst->f_bavail = kst->f_bfree;\n\telse\n\t\tkst->f_bavail = le64_to_cpu(response_data->UserBlocksAvail);\n\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\tkst->f_files = le64_to_cpu(response_data->TotalFileNodes);\n\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\tkst->f_ffree = le64_to_cpu(response_data->FreeFileNodes);\n\n\treturn;\n}\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon,\n\t\t   struct TCP_Server_Info *server,\n\t\t   int level, int outbuf_len, u64 persistent_fid,\n\t\t   u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || server == NULL)\n\t\treturn -EIO;\n\n\trc = smb2_plain_req_init(SMB2_QUERY_INFO, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t \n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req));\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp));\n\n\tiov->iov_base = (char *)req;\n\tiov->iov_len = total_len;\n\treturn 0;\n}\n\nstatic inline void free_qfs_info_req(struct kvec *iov)\n{\n\tcifs_buf_release(iov->iov_base);\n}\n\nint\nSMB311_posix_qfs_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tFILE_SYSTEM_POSIX_INFO *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tFS_POSIX_INFORMATION,\n\t\t\t\tsizeof(FILE_SYSTEM_POSIX_INFO),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tfree_qfs_info_req(&iov);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto posix_qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (FILE_SYSTEM_POSIX_INFO *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), &rsp_iov,\n\t\t\t       sizeof(FILE_SYSTEM_POSIX_INFO));\n\tif (!rc)\n\t\tcopy_posix_fs_info_to_kstatfs(info, fsdata);\n\nposix_qfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tFS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tfree_qfs_info_req(&iov);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength), &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(ses);\n\tunsigned int rsp_len, offset;\n\tint flags = 0;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else if (level == FS_VOLUME_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_vol_info) + MAX_VOL_LABEL_LEN;\n\t\tmin_len = sizeof(struct smb3_fs_vol_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, server,\n\t\t\t\tlevel, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = &iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buftype, flags, &rsp_iov);\n\tfree_qfs_info_req(&iov);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = smb2_validate_iov(offset, rsp_len, &rsp_iov, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, offset\n\t\t\t+ (char *)rsp, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, offset\n\t\t\t+ (char *)rsp, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(offset + (char *)rsp);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t} else if (level == FS_VOLUME_INFORMATION) {\n\t\tstruct smb3_fs_vol_info *vol_info = (struct smb3_fs_vol_info *)\n\t\t\t(offset + (char *)rsp);\n\t\ttcon->vol_serial_number = vol_info->VolumeSerialNumber;\n\t\ttcon->vol_create_time = vol_info->VolumeCreationTime;\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\tunsigned int count;\n\tint flags = CIFS_NO_RSP_BUF;\n\tunsigned int total_len;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = smb2_plain_req_init(SMB2_LOCK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.Id.SyncId.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len - sizeof(struct smb2_lock_element);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\n\trc = cifs_send_recv(xid, tcon->ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags,\n\t\t\t    &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t\ttrace_smb3_lock_err(xid, persist_fid, tcon->tid,\n\t\t\t\t    tcon->ses->Suid, rc);\n\t}\n\n\treturn rc;\n}\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tstruct smb_rqst rqst;\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = CIFS_OBREAK_OP;\n\tunsigned int total_len;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\t__u64 *please_key_high;\n\t__u64 *please_key_low;\n\tstruct TCP_Server_Info *server = cifs_pick_channel(tcon->ses);\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = smb2_plain_req_init(SMB2_OPLOCK_BREAK, tcon, server,\n\t\t\t\t (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\ttotal_len += 12;\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\tflags |= CIFS_NO_RSP_BUF;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, server,\n\t\t\t    &rqst, &resp_buf_type, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tplease_key_low = (__u64 *)lease_key;\n\tplease_key_high = (__u64 *)(lease_key+8);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\ttrace_smb3_lease_err(le32_to_cpu(lease_state), tcon->tid,\n\t\t\tses->Suid, *please_key_low, *please_key_high, rc);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t} else\n\t\ttrace_smb3_lease_done(le32_to_cpu(lease_state), tcon->tid,\n\t\t\tses->Suid, *please_key_low, *please_key_high);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}