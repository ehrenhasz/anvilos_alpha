{
  "module_name": "cifssmb.c",
  "hash_id": "4bcc5c34a54b435d5fb5c4f6a70b30181274a0f4781f4b47241d79f81aeb4533",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifssmb.c",
  "human_readable_source": "\n \n\n  \n  \n  \n  \n  \n\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/uaccess.h>\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"fscache.h\"\n#include \"smbdirect.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n\n#ifdef CONFIG_CIFS_POSIX\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{POSIX_PROT, \"\\2POSIX 2\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#else\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#endif\n\n \n#ifdef CONFIG_CIFS_POSIX\n#define CIFS_NUM_PROT 2\n#else  \n#define CIFS_NUM_PROT 1\n#endif  \n\n\n \nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage = NULL;\n\n\t \n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t \n\tspin_lock(&tcon->tc_lock);\n\tif (tcon->status == TID_EXITING) {\n\t\tif (smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tspin_unlock(&tcon->tc_lock);\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\nagain:\n\trc = cifs_wait_for_server_reconnect(server, tcon->retry);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&ses->chan_lock);\n\tif (!cifs_chan_needs_reconnect(ses, server) && !tcon->need_reconnect) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\tmutex_lock(&ses->session_mutex);\n\t \n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsNeedReconnect) {\n\t\tspin_unlock(&server->srv_lock);\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\tif (tcon->retry)\n\t\t\tgoto again;\n\t\trc = -EHOSTDOWN;\n\t\tgoto out;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\tnls_codepage = ses->local_nls;\n\n\t \n\tspin_lock(&ses->ses_lock);\n\tspin_lock(&ses->chan_lock);\n\tif (!cifs_chan_needs_reconnect(ses, server) &&\n\t    ses->ses_status == SES_GOOD) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\t \n\t\tif (tcon->need_reconnect)\n\t\t\tgoto skip_sess_setup;\n\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\tspin_unlock(&ses->chan_lock);\n\tspin_unlock(&ses->ses_lock);\n\n\trc = cifs_negotiate_protocol(0, ses, server);\n\tif (!rc)\n\t\trc = cifs_setup_session(0, ses, server, nls_codepage);\n\n\t \n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\nskip_sess_setup:\n\tcifs_mark_open_files_invalid(tcon);\n\trc = cifs_tree_connect(0, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\n\tif (rc) {\n\t\tpr_warn_once(\"reconnect tcon failed rc = %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t \n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t \n\nout:\n\t \n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command,\n\t\t\ttcon, wct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = get_next_mid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t \n\n\t \n\n\treturn rc;\n}\n\n \nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n     \n     \n     \n     \n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\n \nstatic int\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t void **request_buf, void **response_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tspin_lock(&tcon->ses->chan_lock);\n\tif (cifs_chan_needs_reconnect(tcon->ses, tcon->ses->server) ||\n\t    tcon->need_reconnect) {\n\t\tspin_unlock(&tcon->ses->chan_lock);\n\t\treturn -EHOSTDOWN;\n\t}\n\tspin_unlock(&tcon->ses->chan_lock);\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t \n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t \n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t \n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}\n\nstatic int\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\n{\n\tint\trc = 0;\n\tu16\tcount;\n\tchar\t*guid = pSMBr->u.extended_response.GUID;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcount = get_bcc(&pSMBr->hdr);\n\tif (count < SMB1_CLIENT_GUID_SIZE)\n\t\treturn -EIO;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (server->srv_count > 1) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\n\t\t\tcifs_dbg(FYI, \"server UID changed\\n\");\n\t\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t\t}\n\t} else {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\n\t}\n\n\tif (count == SMB1_CLIENT_GUID_SIZE) {\n\t\tserver->sec_ntlmssp = true;\n\t} else {\n\t\tcount -= SMB1_CLIENT_GUID_SIZE;\n\t\trc = decode_negTokenInit(\n\t\t\tpSMBr->u.extended_response.SecurityBlob, count, server);\n\t\tif (rc != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nshould_set_ext_sec_flag(enum securityEnum sectype)\n{\n\tswitch (sectype) {\n\tcase RawNTLMSSP:\n\tcase Kerberos:\n\t\treturn true;\n\tcase Unspecified:\n\t\tif (global_secflags &\n\t\t    (CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint\nCIFSSMBNegotiate(const unsigned int xid,\n\t\t struct cifs_ses *ses,\n\t\t struct TCP_Server_Info *server)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tu16 count;\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL   ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Mid = get_next_mid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif (should_set_ext_sec_flag(ses->sectype)) {\n\t\tcifs_dbg(FYI, \"Requesting extended security\\n\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\t \n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tsize_t len = strlen(protocols[i].name) + 1;\n\n\t\tmemcpy(&pSMB->DialectsArray[count], protocols[i].name, len);\n\t\tcount += len;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcifs_dbg(FYI, \"Dialect: %d\\n\", server->dialect);\n\t \n\tif ((pSMBr->hdr.WordCount <= 13) || (server->dialect == BAD_PROT)) {\n\t\t \n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t \n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t \n\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcifs_dbg(FYI, \"share mode security\\n\");\n\n\t \n\tserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\t \n\tserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\n\t \n\tserver->max_read = server->maxBuf;\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcifs_dbg(NOISY, \"Max buf = %d\\n\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if (pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t\trc = decode_ext_sec_blob(ses, pSMBr);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO;  \n\t} else {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\t}\n\n\tif (!rc)\n\t\trc = cifs_enable_signing(server, ses->sign);\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcifs_dbg(FYI, \"negprot rc %d\\n\", rc);\n\treturn rc;\n}\n\nint\nCIFSSMBTDis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_hdr *smb_buffer;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In tree disconnect\\n\");\n\n\t \n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\t \n\tspin_lock(&tcon->ses->chan_lock);\n\tif ((tcon->need_reconnect) || CIFS_ALL_CHANS_NEED_RECONNECT(tcon->ses)) {\n\t\tspin_unlock(&tcon->ses->chan_lock);\n\t\treturn -EIO;\n\t}\n\tspin_unlock(&tcon->ses->chan_lock);\n\n\trc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\n\t\t\t    (void **)&smb_buffer);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)smb_buffer, 0);\n\tcifs_small_buf_release(smb_buffer);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Tree disconnect failed %d\\n\", rc);\n\n\t \n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\n \nstatic void\ncifs_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct cifs_credits credits = { .value = 1, .instance = 0 };\n\n\trelease_mid(mid);\n\tadd_credits(server, &credits, CIFS_ECHO_OP);\n}\n\nint\nCIFSSMBEcho(struct TCP_Server_Info *server)\n{\n\tECHO_REQ *smb;\n\tint rc = 0;\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\trc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\tif (server->capabilities & CAP_UNICODE)\n\t\tsmb->hdr.Flags2 |= SMBFLG2_UNICODE;\n\n\t \n\tsmb->hdr.Tid = 0xffff;\n\tsmb->hdr.WordCount = 1;\n\tput_unaligned_le16(1, &smb->EchoCount);\n\tput_bcc(1, &smb->hdr);\n\tsmb->Data[0] = 'a';\n\tinc_rfc1001_len(smb, 3);\n\n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = smb;\n\tiov[1].iov_len = get_rfc1002_length(smb);\n\tiov[1].iov_base = (char *)smb + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, cifs_echo_callback, NULL,\n\t\t\t     server, CIFS_NON_BLOCKING | CIFS_ECHO_OP, NULL);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(smb);\n\n\treturn rc;\n}\n\nint\nCIFSSMBLogoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In SMBLogoff for session disconnect\\n\");\n\n\t \n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tspin_lock(&ses->chan_lock);\n\tif (CIFS_ALL_CHANS_NEED_RECONNECT(ses)) {\n\t\tspin_unlock(&ses->chan_lock);\n\t\tgoto session_already_dead;  \n\t}\n\tspin_unlock(&ses->chan_lock);\n\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\tif (ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t \n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}\n\nint\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *fileName, __u16 type,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In POSIX delete\\n\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, fileName);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0;  \n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t \n\tpRqD = (struct unlink_psx_rq *)((char *)(pSMB) + offset + 4);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Posix delete returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}\n\nint\nCIFSSMBDelFile(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_FILE_REQ *pSMB = NULL;\n\tDELETE_FILE_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\nDelFileRetry:\n\trc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->fileName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->fileName, name);\n\t}\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMFile = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto DelFileRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBRmDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tDELETE_DIRECTORY_REQ *pSMB = NULL;\n\tDELETE_DIRECTORY_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRmDir\\n\");\nRmDirRetry:\n\trc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->DirName, name);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_rmdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in RMDir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto RmDirRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBMkDir(const unsigned int xid, struct inode *inode, umode_t mode,\n\t     struct cifs_tcon *tcon, const char *name,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tCREATE_DIRECTORY_REQ *pSMB = NULL;\n\tCREATE_DIRECTORY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBMkDir\\n\");\nMkDirRetry:\n\trc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t      PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t\t      remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->DirName, name);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_mkdirs);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Error in Mkdir = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto MkDirRetry;\n\treturn rc;\n}\n\nint\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, name);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t \n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\t \n\tpdata = (OPEN_PSX_REQ *)((char *)(pSMB) + offset + 4);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t \n\t\tgoto psx_create_err;\n\t}\n\n\t \n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;    \n\t \n\t \n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t \n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1);  \n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}\n\nstatic __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcifs_dbg(FYI, \"unknown disposition %d\\n\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND;  \n\t}\n\treturn ofun;\n}\n\nstatic int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t \n\treturn SMBOPEN_READWRITE;\n}\n\nint\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;        \n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;       \n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t} else {\n\t\tcount = 0;       \n\t\tname_len = copy_path_name(pSMB->fileName, fileName);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40);  \n\t \n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse  \n\t\tpSMB->FileAttributes = cpu_to_le16(0 );\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t \n \n\t \n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t \n\n   \n\n\t\t*netfid = pSMBr->Fid;    \n\t\t \n\t\t \n\t \n \n\t \n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0;  \n\t\t\tpfile_info->LastAccessTime = 0;  \n\t\t\tpfile_info->LastWriteTime = 0;  \n\t\t\tpfile_info->ChangeTime = 0;   \n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t \n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t \n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t \n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t \n\t\t \n\t\tcount = 0;\n\t\tname_len = copy_path_name(req->fileName, path);\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t \n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t \n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t \n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t \n\t*oplock = rsp->OplockLevel;\n\t \n\toparms->fid->netfid = rsp->Fid;\n\toparms->fid->access = desired_access;\n\n\t \n\t \n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t \n\t\tmemcpy(&buf->common_attributes,\n\t\t       &rsp->common_attributes,\n\t\t       sizeof(buf->common_attributes));\n\t\t \n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}\n\nstatic void\ncifs_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2,\n\t\t\t\t .rq_iter_size = iov_iter_count(&rdata->iter),\n\t\t\t\t .rq_iter = rdata->iter };\n\tstruct cifs_credits credits = { .value = 1, .instance = 0 };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\t \n\t\tif (server->sign) {\n\t\t\tint rc = 0;\n\n\t\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t\t  mid->sequence_number);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t \n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t \n\t\t\trdata->got_bytes = 0;\n\t\t \n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\trdata->result = -EIO;\n\t}\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\trelease_mid(mid);\n\tadd_credits(server, &credits, 0);\n}\n\n \nint\ncifs_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc;\n\tREAD_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2 };\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10;  \n\t\tif ((rdata->offset >> 32) > 0)  {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)rdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(rdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t \n\tsmb->Fid = rdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(rdata->offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tsmb->OffsetHigh = cpu_to_le32(rdata->offset >> 32);\n\tsmb->Remaining = 0;\n\tsmb->MaxCount = cpu_to_le16(rdata->bytes & 0xFFFF);\n\tsmb->MaxCountHigh = cpu_to_le32(rdata->bytes >> 16);\n\tif (wct == 12)\n\t\tsmb->ByteCount = 0;\n\telse {\n\t\t \n\t\tstruct smb_com_readx_req *smbr =\n\t\t\t(struct smb_com_readx_req *)smb;\n\t\tsmbr->ByteCount = 0;\n\t}\n\n\t \n\trdata->iov[0].iov_base = smb;\n\trdata->iov[0].iov_len = 4;\n\trdata->iov[1].iov_base = (char *)smb + 4;\n\trdata->iov[1].iov_len = get_rfc1002_length(smb);\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, cifs_readv_receive,\n\t\t\t     cifs_readv_callback, NULL, rdata, 0, NULL);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\telse\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}\n\nint\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10;  \n\t\tif ((offset >> 32) > 0)  {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t \n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;        \n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;   \n\telse {\n\t\t \n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1, &resp_buf_type,\n\t\t\t  CIFS_LOG_ERROR, &rsp_iov);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)rsp_iov.iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t \n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n   \n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, rsp_iov.iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t \n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t}  \n\n\t \n\treturn rc;\n}\n\n\nint\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t \n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t \n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t \n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t \n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (count != 0) {\n\t\t \n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t}  \n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1;  \n\telse  \n\t\tbyte_count = bytes_sent + 5;  \n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse {  \n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t \n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t \n\n\treturn rc;\n}\n\n \nstatic void\ncifs_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\n\tstruct cifs_credits credits = { .value = 1, .instance = 0 };\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\twdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le16_to_cpu(smb->CountHigh);\n\t\twritten <<= 16;\n\t\twritten += le16_to_cpu(smb->Count);\n\t\t \n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\trelease_mid(mid);\n\tadd_credits(tcon->ses->server, &credits, 0);\n}\n\n \nint\ncifs_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { };\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif (wdata->offset >> 32 > 0) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\tgoto async_writev_out;\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)wdata->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t \n\tsmb->Fid = wdata->cfile->fid.netfid;\n\tsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\n\tsmb->Reserved = 0xFFFFFFFF;\n\tsmb->WriteMode = 0;\n\tsmb->Remaining = 0;\n\n\tsmb->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\t \n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = smb;\n\tiov[1].iov_len = get_rfc1002_length(smb) + 1;\n\tiov[1].iov_base = (char *)smb + 4;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\trqst.rq_iter = wdata->iter;\n\trqst.rq_iter_size = iov_iter_count(&wdata->iter);\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\tsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\n\tsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\n\n\tif (wct == 14) {\n\t\tinc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\n\t\tput_bcc(wdata->bytes + 1, &smb->hdr);\n\t} else {\n\t\t \n\t\tstruct smb_com_writex_req *smbw =\n\t\t\t\t(struct smb_com_writex_req *)smb;\n\t\tinc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\n\t\tput_bcc(wdata->bytes + 5, &smbw->hdr);\n\t\tiov[1].iov_len += 4;  \n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, &rqst, NULL,\n\t\t\t     cifs_writev_callback, NULL, wdata, 0, NULL);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\telse\n\t\tkref_put(&wdata->refcount, release);\n\nasync_writev_out:\n\tcifs_small_buf_release(smb);\n\treturn rc;\n}\n\nint\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\tstruct kvec rsp_iov;\n\n\t*nbytes = 0;\n\n\tcifs_dbg(FYI, \"write2 at %lld %d bytes\\n\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t \n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t \n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t \n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t \n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse  \n\t\tinc_rfc1001_len(pSMB, count + 5);  \n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse     {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse  \n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0,\n\t\t\t  &rsp_iov);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error Write2 = %d\\n\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t \n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)rsp_iov.iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t \n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tfree_rsp_buf(resp_buf_type, rsp_iov.iov_base);\n\n\t \n\n\treturn rc;\n}\n\nint cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF;  \n\tpSMB->Fid = netfid;  \n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type,\n\t\t\t  CIFS_NO_RSP_BUF, &rsp_iov);\n\tcifs_small_buf_release(pSMB);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n   \n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t \n\t\tflags = CIFS_NO_SRV_RSP | CIFS_NON_BLOCKING | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP;  \n\t\tpSMB->Timeout = cpu_to_le32(-1); \n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t \n\tpSMB->Fid = smb_file_id;  \n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t \n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t \n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag)\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\telse\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t \n\treturn rc;\n}\n\nint\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);  \n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\t \n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *)pSMB) + offset + 4);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP;  \n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);   \n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1  ,\n\t\t\t\t&resp_buf_type, timeout, &rsp_iov);\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)rsp_iov.iov_base;\n\t}\n\tcifs_small_buf_release(pSMB);\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t \n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;       \n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t(le64_to_cpu(parm_data->length) ?\n\t\t\t\t le64_to_cpu(parm_data->length) - 1 : 0);\n\t\t\tpLockData->fl_pid = -le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tfree_rsp_buf(resp_buf_type, rsp_iov.iov_base);\n\n\t \n\n\treturn rc;\n}\n\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n \n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t \n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBFlush\\n\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in Flush = %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBRename(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *from_name, const char *to_name,\n\t      struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tRENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSSMBRename\\n\");\nrenameRetry:\n\trc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      from_name, PATH_MAX,\n\t\t\t\t\t      cifs_sb->local_nls, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;\t \n\t \n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1    + 1   ;\n\t\tname_len2 *= 2;\t \n\t} else {\n\t\tname_len = copy_path_name(pSMB->OldFileName, from_name);\n\t\tname_len2 = copy_path_name(pSMB->OldFileName+name_len+1, to_name);\n\t\tpSMB->OldFileName[name_len] = 0x04;   \n\t\tname_len2++;\t \n\t}\n\n\tcount = 1    + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in rename = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto renameRetry;\n\n\treturn rc;\n}\n\nint CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"Rename to File by handle\\n\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\t \n\tdata_offset = (char *)(pSMB) + offset + 4;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);  \n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t \n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t \n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str =\n\t\t\tcifsConvertToUTF16((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = sizeof(struct set_file_rename) + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Rename (by file handle) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\t \n\n\treturn rc;\n}\n\nint\nCIFSSMBCopy(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fromName, const __u16 target_tid, const char *toName,\n\t    const int flags, const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCOPY_REQ *pSMB = NULL;\n\tCOPY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"In CIFSSMBCopy\\n\");\ncopyRetry:\n\trc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->Tid2 = target_tid;\n\n\tpSMB->Flags = cpu_to_le16(flags & COPY_TREE);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t      fromName, PATH_MAX, nls_codepage,\n\t\t\t\t\t      remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;      \n\t\t \n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1    + 1   ;\n\t\tname_len2 *= 2;  \n\t} else {\n\t\tname_len = copy_path_name(pSMB->OldFileName, fromName);\n\t\tpSMB->OldFileName[name_len] = 0x04;   \n\t\tname_len2 = copy_path_name(pSMB->OldFileName+name_len+1, toName);\n\t\tname_len2++;     \n\t}\n\n\tcount = 1    + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in copy = %d with %d files copied\\n\",\n\t\t\t rc, le16_to_cpu(pSMBr->CopyCount));\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto copyRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Symlink Unix style\\n\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fromName,\n\t\t\t\t \n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, fromName);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t \n\tdata_offset = (char *)pSMB + offset + 4;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, toName,\n\t\t\t\t \n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t \n\t\tname_len_target *= 2;\n\t} else {\n\t\tname_len_target = copy_path_name(data_offset, toName);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo create symlink = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In Create Hard link Unix style\\n\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, toName);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t \n\tdata_offset = (char *)pSMB + offset + 4;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUTF16((__le16 *) data_offset, fromName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len_target++;\t \n\t\tname_len_target *= 2;\n\t} else {\n\t\tname_len_target = copy_path_name(data_offset, fromName);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetPathInfo (hard link) = %d\\n\",\n\t\t\t rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *from_name, const char *to_name,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tNT_RENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In CIFSCreateHardLink\\n\");\nwinCreateHardLinkRetry:\n\n\trc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\n\tpSMB->ClusterCount = 0;\n\n\tpSMB->BufferFormat = 0x04;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->OldFileName, from_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\n\t\t \n\t\tpSMB->OldFileName[name_len] = 0x04;\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;  \n\t\tname_len2 =\n\t\t    cifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\n\t\t\t\t       to_name, PATH_MAX, cifs_sb->local_nls,\n\t\t\t\t       remap);\n\t\tname_len2 += 1    + 1   ;\n\t\tname_len2 *= 2;\t \n\t} else {\n\t\tname_len = copy_path_name(pSMB->OldFileName, from_name);\n\t\tpSMB->OldFileName[name_len] = 0x04;\t \n\t\tname_len2 = copy_path_name(pSMB->OldFileName+name_len+1, to_name);\n\t\tname_len2++;\t \n\t}\n\n\tcount = 1    + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in hard link (NT rename) = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto winCreateHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage, int remap)\n{\n \n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcifs_dbg(FYI, \"In QPathSymLinkInfo (Unix) for path %s\\n\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   searchName, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, searchName);\n\t}\n\n\tparams = 2    + 4    + name_len   ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySymLinkInfo = %d\\n\", rc);\n\t} else {\n\t\t \n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t \n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t \n\t\t\t*symlinkinfo = cifs_strndup_from_utf16(data_start,\n\t\t\t\t\tcount, is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}\n\nint cifs_query_reparse_point(const unsigned int xid,\n\t\t\t     struct cifs_tcon *tcon,\n\t\t\t     struct cifs_sb_info *cifs_sb,\n\t\t\t     const char *full_path,\n\t\t\t     u32 *tag, struct kvec *rsp,\n\t\t\t     int *rsp_buftype)\n{\n\tstruct cifs_open_parms oparms;\n\tTRANSACT_IOCTL_REQ *io_req = NULL;\n\tTRANSACT_IOCTL_RSP *io_rsp = NULL;\n\tstruct cifs_fid fid;\n\t__u32 data_offset, data_count;\n\t__u8 *start, *end;\n\tint io_rsp_len;\n\tint oplock = 0;\n\tint rc;\n\n\tcifs_tcon_dbg(FYI, \"%s: path=%s\\n\", __func__, full_path);\n\n\tif (cap_unix(tcon->ses))\n\t\treturn -EOPNOTSUPP;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = FILE_READ_ATTRIBUTES,\n\t\t.create_options = cifs_create_options(cifs_sb,\n\t\t\t\t\t\t      OPEN_REPARSE_POINT),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = full_path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon,\n\t\t      (void **)&io_req, (void **)&io_rsp);\n\tif (rc)\n\t\tgoto error;\n\n\tio_req->TotalParameterCount = 0;\n\tio_req->TotalDataCount = 0;\n\tio_req->MaxParameterCount = cpu_to_le32(2);\n\t \n\tio_req->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tio_req->MaxSetupCount = 4;\n\tio_req->Reserved = 0;\n\tio_req->ParameterOffset = 0;\n\tio_req->DataCount = 0;\n\tio_req->DataOffset = 0;\n\tio_req->SetupCount = 4;\n\tio_req->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tio_req->ParameterCount = io_req->TotalParameterCount;\n\tio_req->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tio_req->IsFsctl = 1;\n\tio_req->IsRootFlag = 0;\n\tio_req->Fid = fid.netfid;\n\tio_req->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)io_req,\n\t\t\t (struct smb_hdr *)io_rsp, &io_rsp_len, 0);\n\tif (rc)\n\t\tgoto error;\n\n\tdata_offset = le32_to_cpu(io_rsp->DataOffset);\n\tdata_count = le32_to_cpu(io_rsp->DataCount);\n\tif (get_bcc(&io_rsp->hdr) < 2 || data_offset > 512 ||\n\t    !data_count || data_count > 2048) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\tend = 2 + get_bcc(&io_rsp->hdr) + (__u8 *)&io_rsp->ByteCount;\n\tstart = (__u8 *)&io_rsp->hdr.Protocol + data_offset;\n\tif (start >= end) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\t*tag = le32_to_cpu(((struct reparse_data_buffer *)start)->ReparseTag);\n\trsp->iov_base = io_rsp;\n\trsp->iov_len = io_rsp_len;\n\t*rsp_buftype = CIFS_LARGE_BUFFER;\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn 0;\n\nerror:\n\tcifs_buf_release(io_req);\n\tCIFSSMBClose(xid, tcon, fid.netfid);\n\treturn rc;\n}\n\nint\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_compr_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcifs_dbg(FYI, \"Set compression for %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\tpSMB->TotalParameterCount = 0;\n\tpSMB->TotalDataCount = cpu_to_le32(2);\n\tpSMB->MaxParameterCount = 0;\n\tpSMB->MaxDataCount = 0;\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = cpu_to_le32(2);\n\tpSMB->DataOffset =\n\t\tcpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4);   \n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = 0;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_SET_COMPRESSION);\n\tpSMB->IsFsctl = 1;  \n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid;  \n\t \n\tpSMB->ByteCount = cpu_to_le16(5);\n\tinc_rfc1001_len(pSMB, 5);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetCompression = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t \n\treturn rc;\n}\n\n\n#ifdef CONFIG_CIFS_POSIX\n\n#ifdef CONFIG_FS_POSIX_ACL\n \nstatic void cifs_init_posix_acl(struct posix_acl_entry *ace,\n\t\t\t\tstruct cifs_posix_ace *cifs_ace)\n{\n\t \n\tace->e_perm = cifs_ace->cifs_e_perm;\n\tace->e_tag = cifs_ace->cifs_e_tag;\n\n\tswitch (ace->e_tag) {\n\tcase ACL_USER:\n\t\tace->e_uid = make_kuid(&init_user_ns,\n\t\t\t\t       le64_to_cpu(cifs_ace->cifs_uid));\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\tace->e_gid = make_kgid(&init_user_ns,\n\t\t\t\t       le64_to_cpu(cifs_ace->cifs_uid));\n\t\tbreak;\n\t}\n\treturn;\n}\n\n \nstatic int cifs_to_posix_acl(struct posix_acl **acl, char *src,\n\t\t\t     const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tstruct posix_acl *kacl = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t \n\t\tif (size_of_data_area < size) {\n\t\t\tcifs_dbg(FYI, \"bad CIFS POSIX ACL size %d vs. %d\\n\",\n\t\t\t\t size_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t \n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t \n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tkacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!kacl)\n\t\treturn -ENOMEM;\n\n\tFOREACH_ACL_ENTRY(pa, kacl, pe) {\n\t\tcifs_init_posix_acl(pa, pACE);\n\t\tpACE++;\n\t}\n\n\t*acl = kacl;\n\treturn 0;\n}\n\n \nstatic void cifs_init_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t  const struct posix_acl_entry *local_ace)\n{\n\tcifs_ace->cifs_e_perm = local_ace->e_perm;\n\tcifs_ace->cifs_e_tag =  local_ace->e_tag;\n\n\tswitch (local_ace->e_tag) {\n\tcase ACL_USER:\n\t\tcifs_ace->cifs_uid =\n\t\t\tcpu_to_le64(from_kuid(&init_user_ns, local_ace->e_uid));\n\t\tbreak;\n\tcase ACL_GROUP:\n\t\tcifs_ace->cifs_uid =\n\t\t\tcpu_to_le64(from_kgid(&init_user_ns, local_ace->e_gid));\n\t\tbreak;\n\tdefault:\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t}\n}\n\n \nstatic __u16 posix_acl_to_cifs(char *parm_data, const struct posix_acl *acl,\n\t\t\t       const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tconst struct posix_acl_entry *pa, *pe;\n\tint count;\n\tint i = 0;\n\n\tif ((acl == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = acl->a_count;\n\tcifs_dbg(FYI, \"setting acl with %d entries\\n\", count);\n\n\t \n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS) {\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->default_entry_count = cpu_to_le16(0xFFFF);\n\t} else if (acl_type == ACL_TYPE_DEFAULT) {\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\t\tcifs_acl->access_entry_count = cpu_to_le16(0xFFFF);\n\t} else {\n\t\tcifs_dbg(FYI, \"unknown ACL type %d\\n\", acl_type);\n\t\treturn 0;\n\t}\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tcifs_init_ace(&cifs_acl->ace_array[i++], pa);\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t \n\t}\n\treturn rc;\n}\n\nint cifs_do_get_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const unsigned char *searchName, struct posix_acl **acl,\n\t\t    const int acl_type, const struct nls_table *nls_codepage,\n\t\t    int remap)\n{\n \n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetPosixACL (Unix) for path %s\\n\", searchName);\n\nqueryAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   searchName, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = 0;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, searchName);\n\t}\n\n\tparams = 2    + 4    + name_len   ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t\toffsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Query POSIX ACL = %d\\n\", rc);\n\t} else {\n\t\t \n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t \n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;       \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\trc = cifs_to_posix_acl(acl,\n\t\t\t\t(char *)&pSMBr->hdr.Protocol+data_offset,\n\t\t\t\tacl_type, count);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\t \n\tif (rc == -EAGAIN)\n\t\tgoto queryAclRetry;\n\treturn rc;\n}\n\nint cifs_do_set_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const unsigned char *fileName, const struct posix_acl *acl,\n\t\t    const int acl_type, const struct nls_table *nls_codepage,\n\t\t    int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tchar *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetPosixACL (Unix) for path %s\\n\", fileName);\nsetAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t\t   PATH_MAX, nls_codepage, remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, fileName);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tparm_data = ((char *)pSMB) + sizeof(pSMB->hdr.smb_buf_length) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\n\t \n\tdata_count = posix_acl_to_cifs(parm_data, acl, acl_type);\n\n\tif (data_count == 0) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto setACLerrorExit;\n\t}\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\n\tbyte_count = 3    + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set POSIX ACL returned %d\\n\", rc);\n\nsetACLerrorExit:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setAclRetry;\n\treturn rc;\n}\n#else\nint cifs_do_get_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const unsigned char *searchName, struct posix_acl **acl,\n\t\t    const int acl_type, const struct nls_table *nls_codepage,\n\t\t    int remap)\n{\n\treturn -EOPNOTSUPP;\n}\n\nint cifs_do_set_acl(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const unsigned char *fileName, const struct posix_acl *acl,\n\t\t    const int acl_type, const struct nls_table *nls_codepage,\n\t\t    int remap)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif  \n\nint\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetExtAttr\\n\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2   + 2  ;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t \n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in GetExtAttr\\n\", rc);\n\t} else {\n\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t \n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t \n\t\t\trc = -EIO;       \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\n\t\t\tif (count != 16) {\n\t\t\t\tcifs_dbg(FYI, \"Invalid size ret in GetExtAttr\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}\n\n#endif  \n\n \nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4  ;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count;  \n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}\n\nstatic int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2   + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t \n\tif (*ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parms start after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcifs_dbg(FYI, \"parm end after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data starts after end of smb\\n\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcifs_dbg(FYI, \"data %p + count %d (%p) past smb end %p start %p\\n\",\n\t\t\t *ppdata, data_count, (data_count + *ppdata),\n\t\t\t end_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcifs_dbg(FYI, \"parm count and data count larger than SMB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}\n\n \nint\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8  , tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t \n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid;  \n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11);  \n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1  , &buf_type,\n\t\t\t  0, &rsp_iov);\n\tcifs_small_buf_release(pSMB);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                 \n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n \n\t\trc = validate_ntransact(rsp_iov.iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)rsp_iov.iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;       \n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n \n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t \n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tvoid *pSMBr;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3    + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid;  \n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(aclflag);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset, pntsd, acllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcifs_dbg(FYI, \"SetCIFSACL bytes_returned: %d, rc: %d\\n\",\n\t\t bytes_returned, rc);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set CIFS ACL returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}\n\n\n \nint\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, search_name);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++;  \n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec64 ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t \n\t\t \n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t \n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO;  \n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2   + 2  ;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t \n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFileInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc)  \n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t \n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy  ,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t \n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t \nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, search_name);\n\t}\n\n\tparams = 2   + 4   + name_len  ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc)  \n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t \n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;   \n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t \n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2   + 2  ;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t \n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQFileInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t \n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n \n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QPathInfo (Unix) the path %s\\n\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, searchName);\n\t}\n\n\tparams = 2   + 4   + name_len  ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in UnixQPathInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\\n\");\n\t\t\trc = -EIO;\t \n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}\n\n \nint\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n \n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tstruct nls_table *nls_codepage;\n\tunsigned int lnoff;\n\t__u16 params, byte_count;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t \n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4;  \n\t\t\t \n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, searchName);\n\t\tif (msearch) {\n\t\t\tif (WARN_ON_ONCE(name_len > PATH_MAX-2))\n\t\t\t\tname_len = PATH_MAX-2;\n\t\t\t \n\t\t\tpSMB->FileName[name_len-1] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len] = '*';\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t}\n\n\tparams = 12 + name_len   ;\n\tpSMB->TotalDataCount = 0;\t \n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t \n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t \n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {\n\t\t \n\t\t \n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\t\tcifs_buf_release(pSMB);\n\t\t \n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t\treturn rc;\n\t}\n\t \n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc) {\n\t\tcifs_buf_release(pSMB);\n\t\treturn rc;\n\t}\n\n\tpsrch_inf->unicode = !!(pSMBr->hdr.Flags2 & SMBFLG2_UNICODE);\n\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\tpsrch_inf->smallBuf = false;\n\tpsrch_inf->srch_entries_start = (char *)&pSMBr->hdr.Protocol +\n\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\n\tparms = (T2_FFIRST_RSP_PARMS *)((char *)&pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.ParameterOffset));\n\tpsrch_inf->endOfSearch = !!parms->EndofSearch;\n\n\tpsrch_inf->entries_in_buffer = le16_to_cpu(parms->SearchCount);\n\tpsrch_inf->index_of_last_entry = 2   +\n\t\tpsrch_inf->entries_in_buffer;\n\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\tif (CIFSMaxBufSize < lnoff) {\n\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\tpsrch_inf->last_entry = NULL;\n\t} else {\n\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start + lnoff;\n\t\tif (pnetfid)\n\t\t\t*pnetfid = parms->SearchHandle;\n\t}\n\treturn 0;\n}\n\nint CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, __u16 search_flags,\n\t\t struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tunsigned int name_len;\n\tunsigned int lnoff;\n\t__u16 params, byte_count;\n\tchar *response_data;\n\tint bytes_returned;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"In FindNext\\n\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14;  \n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;        \n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;       \n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t \n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t}\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\n\n\tif (rc) {\n\t\tcifs_buf_release(pSMB);\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\trc = 0;  \n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"FindNext returned = %d\\n\", rc);\n\t\t}\n\t\treturn rc;\n\t}\n\n\t \n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc) {\n\t\tcifs_buf_release(pSMB);\n\t\treturn rc;\n\t}\n\t \n\tpsrch_inf->unicode = !!(pSMBr->hdr.Flags2 & SMBFLG2_UNICODE);\n\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\tle16_to_cpu(pSMBr->t2.ParameterOffset);\n\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\n\tif (psrch_inf->smallBuf)\n\t\tcifs_small_buf_release(psrch_inf->ntwrk_buf_start);\n\telse\n\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\n\tpsrch_inf->srch_entries_start = response_data;\n\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\tpsrch_inf->smallBuf = false;\n\tpsrch_inf->endOfSearch = !!parms->EndofSearch;\n\tpsrch_inf->entries_in_buffer = le16_to_cpu(parms->SearchCount);\n\tpsrch_inf->index_of_last_entry += psrch_inf->entries_in_buffer;\n\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\tif (CIFSMaxBufSize < lnoff) {\n\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\tpsrch_inf->last_entry = NULL;\n\t} else {\n\t\tpsrch_inf->last_entry =\n\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\t}\n\t \n\n\t \n\treturn 0;\n}\n\nint\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcifs_dbg(FYI, \"In CIFSSMBFindClose\\n\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t \n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in FindClose = %d\\n\", rc);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\n\n\t \n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *search_name, __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetSrvInodeNum for %s\\n\", search_name);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;      \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, search_name);\n\t}\n\n\tparams = 2    + 4    + name_len   ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in QueryInternalInfo\\n\", rc);\n\t} else {\n\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t \n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t \n\t\t\trc = -EIO;       \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t \n\t\t\tif (count < 8) {\n\t\t\t\tcifs_dbg(FYI, \"Invalid size ret in QryIntrnlInf\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}\n\nint\nCIFSGetDFSRefer(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst char *search_name, struct dfs_info3_param **target_nodes,\n\t\tunsigned int *num_of_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n \n\tTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\n\tTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\t*num_of_nodes = 0;\n\t*target_nodes = NULL;\n\n\tcifs_dbg(FYI, \"In GetDFSRefer the path %s\\n\", search_name);\n\tif (ses == NULL || ses->tcon_ipc == NULL)\n\t\treturn -ENODEV;\n\ngetDFSRetry:\n\t \n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, ses->tcon_ipc,\n\t\t\t\t   (void **)&pSMB, (void **)&pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\tpSMB->hdr.Tid = ses->tcon_ipc->tid;\n\tpSMB->hdr.Uid = ses->Suid;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\tif (ses->capabilities & CAP_DFS)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_DFS;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->RequestFileName,\n\t\t\t\t       search_name, PATH_MAX, nls_codepage,\n\t\t\t\t       remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\t \n\t\tname_len = copy_path_name(pSMB->RequestFileName, search_name);\n\t}\n\n\tif (ses->server->sign)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tparams = 2    + name_len   ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = 0;\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\n\tbyte_count = params + 3   ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->MaxReferralLevel = cpu_to_le16(3);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in GetDFSRefer = %d\\n\", rc);\n\t\tgoto GetDFSRefExit;\n\t}\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t \n\tif (rc || get_bcc(&pSMBr->hdr) < 17) {\n\t\trc = -EIO;       \n\t\tgoto GetDFSRefExit;\n\t}\n\n\tcifs_dbg(FYI, \"Decoding GetDFSRefer response BCC: %d  Offset %d\\n\",\n\t\t get_bcc(&pSMBr->hdr), le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t \n\trc = parse_dfs_referrals(&pSMBr->dfs_data,\n\t\t\t\t le16_to_cpu(pSMBr->t2.DataCount),\n\t\t\t\t num_of_nodes, target_nodes, nls_codepage,\n\t\t\t\t remap, search_name,\n\t\t\t\t (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE) != 0);\n\nGetDFSRefExit:\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto getDFSRetry;\n\n\treturn rc;\n}\n\n \nint\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct kstatfs *FSData)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"OldQFSInfo\\n\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;      \n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {                 \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;       \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcifs_dbg(FYI, \"qfsinf resp BCC: %d  Offset %d\\n\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\t \n\t\t\tif (FSData->f_bsize < 512)\n\t\t\t\tFSData->f_bsize = 4096;\n\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct kstatfs *FSData)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSInfo\\n\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t \n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\t \n\t\t\tif (FSData->f_bsize < 512)\n\t\t\t\tFSData->f_bsize = 4096;\n\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSAttributeInfo\\n\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t \n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSAttributeInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t \n\t\t\trc = -EIO;\t \n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t \n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t \n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSUnixInfo\\n\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t \n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t \n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n \n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcifs_dbg(FYI, \"In SETFSUnixInfo\\n\");\nSETFSUnixRetry:\n\t \n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t \n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1   + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t \n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t \n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SETFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t \n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}\n\n\n\nint\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n \n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSPosixInfo\\n\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t \n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1   ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t \n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t \n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\t \n\t\t\tif (FSData->f_bsize < 512)\n\t\t\t\tFSData->f_bsize = 4096;\n\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}\n\n\n \nint\nCIFSSMBSetEOF(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *file_name, __u64 size, struct cifs_sb_info *cifs_sb,\n\t      bool set_allocation)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint remap = cifs_remap(cifs_sb);\n\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcifs_dbg(FYI, \"In SetEOF\\n\");\nSetEOFRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, cifs_sb->local_nls, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, file_name);\n\t}\n\tparams = 6 + name_len;\n\tdata_count = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(4100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else    {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\n\tparm_data =\n\t    (struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (file size) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEOFRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileSize(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_allocation)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"SetFileSize (via SetFileInfo) %lld\\n\",\n\t\t (long long)size);\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)cfile->pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(cfile->pid >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\t \n\tparm_data =\n\t\t(struct file_end_of_file_info *)(((char *)pSMB) + offset + 4);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->Fid = cfile->fid.netfid;\n\tif (set_allocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else    {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in SetFileInfo (SetFileSize) = %d\\n\",\n\t\t\t rc);\n\t}\n\n\t \n\n\treturn rc;\n}\n\n \nint\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t \n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set File Disposition (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\t \n\tdata_offset = (char *)(pSMB) + offset + 4;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetFileDisposition = %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int\nCIFSSMBSetPathInfoFB(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *fileName, const FILE_BASIC_INFO *data,\n\t\t     const struct nls_table *nls_codepage,\n\t\t     struct cifs_sb_info *cifs_sb)\n{\n\tint oplock = 0;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tint rc;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_WRITE,\n\t\t.create_options = cifs_create_options(cifs_sb, 0),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = fileName,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = CIFSSMBSetFileInfo(xid, tcon, data, fid.netfid, current->tgid);\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage,\n\t\t     struct cifs_sb_info *cifs_sb)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, fileName);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\tif (rc == -EOPNOTSUPP)\n\t\treturn CIFSSMBSetPathInfoFB(xid, tcon, fileName, data,\n\t\t\t\t\t    nls_codepage, cifs_sb);\n\n\treturn rc;\n}\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\n\tu64 mode = args->mode;\n\n\tif (uid_valid(args->uid))\n\t\tuid = from_kuid(&init_user_ns, args->uid);\n\tif (gid_valid(args->gid))\n\t\tgid = from_kgid(&init_user_ns, args->gid);\n\n\t \n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(uid);\n\tdata_offset->Gid = cpu_to_le64(gid);\n\t \n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}\n\nint\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_small_buf_release(pSMB);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t \n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, file_name);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\t \n\tdata_offset = (FILE_UNIX_BASIC_INFO *)((char *) pSMB + offset + 4);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_XATTR\n \nssize_t\nCIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst unsigned char *searchName, const unsigned char *ea_name,\n\t\tchar *EAData, size_t buf_size,\n\t\tstruct cifs_sb_info *cifs_sb)\n{\n\t\t \n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint remap = cifs_remap(cifs_sb);\n\tstruct nls_table *nls_codepage = cifs_sb->local_nls;\n\tint rc = 0;\n\tint bytes_returned;\n\tint list_len;\n\tstruct fealist *ea_response_data;\n\tstruct fea *temp_fea;\n\tchar *temp_ptr;\n\tchar *end_of_smb;\n\t__u16 params, byte_count, data_offset;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\n\tcifs_dbg(FYI, \"In Query All EAs path %s\\n\", searchName);\nQAllEAsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tlist_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tlist_len++;\t \n\t\tlist_len *= 2;\n\t} else {\n\t\tlist_len = copy_path_name(pSMB->FileName, searchName);\n\t}\n\n\tparams = 2   + 4   + list_len  ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1   ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryAllEAs = %d\\n\", rc);\n\t\tgoto QAllEAsOut;\n\t}\n\n\n\t \n\t \n\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc || get_bcc(&pSMBr->hdr) < 4) {\n\t\trc = -EIO;\t \n\t\tgoto QAllEAsOut;\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\n\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\tea_response_data = (struct fealist *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\n\tlist_len = le32_to_cpu(ea_response_data->list_len);\n\tcifs_dbg(FYI, \"ea length %d\\n\", list_len);\n\tif (list_len <= 8) {\n\t\tcifs_dbg(FYI, \"empty EA list returned from server\\n\");\n\t\t \n\t\tif (ea_name)\n\t\t\trc = -ENODATA;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t \n\tend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\n\tif ((char *)ea_response_data + list_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"EA list appears to go beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t \n\tlist_len -= 4;\n\ttemp_fea = &ea_response_data->list;\n\ttemp_ptr = (char *)temp_fea;\n\twhile (list_len > 0) {\n\t\tunsigned int name_len;\n\t\t__u16 value_len;\n\n\t\tlist_len -= 4;\n\t\ttemp_ptr += 4;\n\t\t \n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tname_len = temp_fea->name_len;\n\t\tvalue_len = le16_to_cpu(temp_fea->value_len);\n\t\tlist_len -= name_len + 1 + value_len;\n\t\tif (list_len < 0) {\n\t\t\tcifs_dbg(FYI, \"EA entry goes beyond length of list\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    memcmp(ea_name, temp_ptr, name_len) == 0) {\n\t\t\t\ttemp_ptr += name_len + 1;\n\t\t\t\trc = value_len;\n\t\t\t\tif (buf_size == 0)\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\tif ((size_t)value_len > buf_size) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\t}\n\t\t\t\tmemcpy(EAData, temp_ptr, value_len);\n\t\t\t\tgoto QAllEAsOut;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trc += (5 + 1 + name_len);\n\t\t\tif (rc < (int) buf_size) {\n\t\t\t\tmemcpy(EAData, \"user.\", 5);\n\t\t\t\tEAData += 5;\n\t\t\t\tmemcpy(EAData, temp_ptr, name_len);\n\t\t\t\tEAData += name_len;\n\t\t\t\t \n\t\t\t\t*EAData = 0;\n\t\t\t\t++EAData;\n\t\t\t} else if (buf_size == 0) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttemp_ptr += name_len + 1 + value_len;\n\t\ttemp_fea = (struct fea *)temp_ptr;\n\t}\n\n\t \n\tif (ea_name)\n\t\trc = -ENODATA;\n\nQAllEAsOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QAllEAsRetry;\n\n\treturn (ssize_t)rc;\n}\n\nint\nCIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,\n\t     const char *fileName, const char *ea_name, const void *ea_value,\n\t     const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t     struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct fealist *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, byte_count, offset, count;\n\tint remap = cifs_remap(cifs_sb);\n\n\tcifs_dbg(FYI, \"In SetEA\\n\");\nSetEARetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t \n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = copy_path_name(pSMB->FileName, fileName);\n\t}\n\n\tparams = 6 + name_len;\n\n\t \n\tif (ea_name == NULL)\n\t\tname_len = 0;\n\telse\n\t\tname_len = strnlen(ea_name, 255);\n\n\tcount = sizeof(*parm_data) + 1 + ea_value_len + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t \n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_EA);\n\n\tparm_data = (void *)pSMB + offsetof(struct smb_hdr, Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3    + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tparm_data->list_len = cpu_to_le32(count);\n\tparm_data->list.EA_flags = 0;\n\t \n\tparm_data->list.name_len = (__u8)name_len;\n\t \n\tif (ea_name)\n\t\tstrncpy(parm_data->list.name, ea_name, name_len);\n\tparm_data->list.name[name_len] = '\\0';\n\tparm_data->list.value_len = cpu_to_le16(ea_value_len);\n\t \n\n\t \n\t \n\tif (ea_value_len)\n\t\tmemcpy(parm_data->list.name + name_len + 1,\n\t\t       ea_value, ea_value_len);\n\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (EA) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEARetry;\n\n\treturn rc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}