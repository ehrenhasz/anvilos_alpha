{
  "module_name": "inode.c",
  "hash_id": "37a29bca7188c2314fc21cf4d3488c945525437090569a58a9481773b0072b98",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/inode.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/sched/signal.h>\n#include <linux/wait_bit.h>\n#include <linux/fiemap.h>\n#include <asm/div64.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_unicode.h\"\n#include \"fscache.h\"\n#include \"fs_context.h\"\n#include \"cifs_ioctl.h\"\n#include \"cached_dir.h\"\n\nstatic void cifs_set_ops(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &cifs_file_inode_ops;\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_direct_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_direct_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\t\tinode->i_fop = &cifs_file_strict_nobrl_ops;\n\t\t\telse\n\t\t\t\tinode->i_fop = &cifs_file_strict_ops;\n\t\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tinode->i_fop = &cifs_file_nobrl_ops;\n\t\telse {  \n\t\t\tinode->i_fop = &cifs_file_ops;\n\t\t}\n\n\t\t \n\t\tif (cifs_sb_master_tcon(cifs_sb)->ses->server->max_read <\n\t\t\t\tPAGE_SIZE + MAX_CIFS_HDR_SIZE)\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops_smallbuf;\n\t\telse\n\t\t\tinode->i_data.a_ops = &cifs_addr_ops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (IS_AUTOMOUNT(inode)) {\n\t\t\tinode->i_op = &cifs_namespace_inode_operations;\n\t\t} else {\n\t\t\tinode->i_op = &cifs_dir_inode_ops;\n\t\t\tinode->i_fop = &cifs_dir_ops;\n\t\t}\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &cifs_symlink_inode_ops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ncifs_revalidate_cache(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifs_fscache_inode_coherency_data cd;\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct timespec64 mtime;\n\n\tcifs_dbg(FYI, \"%s: revalidating inode %llu\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is new\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t \n\tif (CIFS_CACHE_READ(cifs_i)) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is oplocked\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\t  \n\tfattr->cf_mtime = timestamp_truncate(fattr->cf_mtime, inode);\n\tmtime = inode_get_mtime(inode);\n\tif (timespec64_equal(&mtime, &fattr->cf_mtime) &&\n\t    cifs_i->server_eof == fattr->cf_eof) {\n\t\tcifs_dbg(FYI, \"%s: inode %llu is unchanged\\n\",\n\t\t\t __func__, cifs_i->uniqueid);\n\t\treturn;\n\t}\n\n\tcifs_dbg(FYI, \"%s: invalidating inode %llu mapping\\n\",\n\t\t __func__, cifs_i->uniqueid);\n\tset_bit(CIFS_INO_INVALID_MAPPING, &cifs_i->flags);\n\t \n\tcifs_fscache_fill_coherency(&cifs_i->netfs.inode, &cd);\n\tfscache_invalidate(cifs_inode_cookie(inode), &cd, i_size_read(inode), 0);\n}\n\n \nstatic void\ncifs_nlink_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\t \n\tif (fattr->cf_flags & CIFS_FATTR_UNKNOWN_NLINK) {\n\t\t \n\t\tif (inode->i_state & I_NEW) {\n\t\t\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY)\n\t\t\t\tset_nlink(inode, 2);\n\t\t\telse\n\t\t\t\tset_nlink(inode, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tset_nlink(inode, fattr->cf_nlink);\n}\n\n \nint\ncifs_fattr_to_inode(struct inode *inode, struct cifs_fattr *fattr)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (!(inode->i_state & I_NEW) &&\n\t    unlikely(inode_wrong_type(inode, fattr->cf_mode))) {\n\t\tCIFS_I(inode)->time = 0;  \n\t\treturn -ESTALE;\n\t}\n\n\tcifs_revalidate_cache(inode, fattr);\n\n\tspin_lock(&inode->i_lock);\n\tfattr->cf_mtime = timestamp_truncate(fattr->cf_mtime, inode);\n\tfattr->cf_atime = timestamp_truncate(fattr->cf_atime, inode);\n\tfattr->cf_ctime = timestamp_truncate(fattr->cf_ctime, inode);\n\t \n\tif (timespec64_compare(&fattr->cf_atime, &fattr->cf_mtime) < 0)\n\t\tinode_set_atime_to_ts(inode, fattr->cf_mtime);\n\telse\n\t\tinode_set_atime_to_ts(inode, fattr->cf_atime);\n\tinode_set_mtime_to_ts(inode, fattr->cf_mtime);\n\tinode_set_ctime_to_ts(inode, fattr->cf_ctime);\n\tinode->i_rdev = fattr->cf_rdev;\n\tcifs_nlink_fattr_to_inode(inode, fattr);\n\tinode->i_uid = fattr->cf_uid;\n\tinode->i_gid = fattr->cf_gid;\n\n\t \n\tif (inode->i_state & I_NEW ||\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM))\n\t\tinode->i_mode = fattr->cf_mode;\n\n\tcifs_i->cifsAttrs = fattr->cf_cifsattrs;\n\n\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\tcifs_i->time = 0;\n\telse\n\t\tcifs_i->time = jiffies;\n\n\tif (fattr->cf_flags & CIFS_FATTR_DELETE_PENDING)\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\telse\n\t\tclear_bit(CIFS_INO_DELETE_PENDING, &cifs_i->flags);\n\n\tcifs_i->server_eof = fattr->cf_eof;\n\t \n\tif (is_size_safe_to_change(cifs_i, fattr->cf_eof)) {\n\t\ti_size_write(inode, fattr->cf_eof);\n\n\t\t \n\t\tinode->i_blocks = (512 - 1 + fattr->cf_bytes) >> 9;\n\t}\n\n\tif (S_ISLNK(fattr->cf_mode)) {\n\t\tkfree(cifs_i->symlink_target);\n\t\tcifs_i->symlink_target = fattr->cf_symlink_target;\n\t\tfattr->cf_symlink_target = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (fattr->cf_flags & CIFS_FATTR_JUNCTION)\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\tif (inode->i_state & I_NEW)\n\t\tcifs_set_ops(inode);\n\treturn 0;\n}\n\nvoid\ncifs_fill_uniqueid(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\treturn;\n\n\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n}\n\n \nvoid\ncifs_unix_basic_to_fattr(struct cifs_fattr *fattr, FILE_UNIX_BASIC_INFO *info,\n\t\t\t struct cifs_sb_info *cifs_sb)\n{\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_uniqueid = le64_to_cpu(info->UniqueId);\n\tfattr->cf_bytes = le64_to_cpu(info->NumOfBytes);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastModificationTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->LastStatusChange);\n\t \n\n\tfattr->cf_mode = le64_to_cpu(info->Permissions);\n\n\t \n\tfattr->cf_mode &= ~S_IFMT;\n\tswitch (le32_to_cpu(info->Type)) {\n\tcase UNIX_FILE:\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tbreak;\n\tcase UNIX_SYMLINK:\n\t\tfattr->cf_mode |= S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tcase UNIX_DIR:\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\tbreak;\n\tcase UNIX_CHARDEV:\n\t\tfattr->cf_mode |= S_IFCHR;\n\t\tfattr->cf_dtype = DT_CHR;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_BLOCKDEV:\n\t\tfattr->cf_mode |= S_IFBLK;\n\t\tfattr->cf_dtype = DT_BLK;\n\t\tfattr->cf_rdev = MKDEV(le64_to_cpu(info->DevMajor),\n\t\t\t\t       le64_to_cpu(info->DevMinor) & MINORMASK);\n\t\tbreak;\n\tcase UNIX_FIFO:\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\tbreak;\n\tcase UNIX_SOCKET:\n\t\tfattr->cf_mode |= S_IFSOCK;\n\t\tfattr->cf_dtype = DT_SOCK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\tcifs_dbg(FYI, \"unknown type %d\\n\", le32_to_cpu(info->Type));\n\t\tbreak;\n\t}\n\n\tfattr->cf_uid = cifs_sb->ctx->linux_uid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)) {\n\t\tu64 id = le64_to_cpu(info->Uid);\n\t\tif (id < ((uid_t)-1)) {\n\t\t\tkuid_t uid = make_kuid(&init_user_ns, id);\n\t\t\tif (uid_valid(uid))\n\t\t\t\tfattr->cf_uid = uid;\n\t\t}\n\t}\n\t\n\tfattr->cf_gid = cifs_sb->ctx->linux_gid;\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)) {\n\t\tu64 id = le64_to_cpu(info->Gid);\n\t\tif (id < ((gid_t)-1)) {\n\t\t\tkgid_t gid = make_kgid(&init_user_ns, id);\n\t\t\tif (gid_valid(gid))\n\t\t\t\tfattr->cf_gid = gid;\n\t\t}\n\t}\n\n\tfattr->cf_nlink = le64_to_cpu(info->Nlinks);\n}\n\n \nstatic void cifs_create_junction_fattr(struct cifs_fattr *fattr,\n\t\t\t\t       struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\tcifs_dbg(FYI, \"%s: creating fake fattr\\n\", __func__);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_mode = S_IFDIR | S_IXUGO | S_IRWXU;\n\tfattr->cf_uid = cifs_sb->ctx->linux_uid;\n\tfattr->cf_gid = cifs_sb->ctx->linux_gid;\n\tktime_get_coarse_real_ts64(&fattr->cf_mtime);\n\tfattr->cf_atime = fattr->cf_ctime = fattr->cf_mtime;\n\tfattr->cf_nlink = 2;\n\tfattr->cf_flags = CIFS_FATTR_JUNCTION;\n}\n\n \nstatic int update_inode_info(struct super_block *sb,\n\t\t\t     struct cifs_fattr *fattr,\n\t\t\t     struct inode **inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tint rc = 0;\n\n\tif (!*inode) {\n\t\t*inode = cifs_iget(sb, fattr);\n\t\tif (!*inode)\n\t\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\t \n\tif (unlikely((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) &&\n\t\t     CIFS_I(*inode)->uniqueid != fattr->cf_uniqueid)) {\n\t\tCIFS_I(*inode)->time = 0;  \n\t\treturn -ESTALE;\n\t}\n\treturn cifs_fattr_to_inode(*inode, fattr);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int\ncifs_get_file_info_unix(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_fattr fattr = {};\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\n\txid = get_xid();\n\n\tif (cfile->symlink_target) {\n\t\tfattr.cf_symlink_target = kstrdup(cfile->symlink_target, GFP_KERNEL);\n\t\tif (!fattr.cf_symlink_target) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cifs_gfiunix_out;\n\t\t}\n\t}\n\n\trc = CIFSSMBUnixQFileInfo(xid, tcon, cfile->fid.netfid, &find_data);\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(&fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_junction_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t} else\n\t\tgoto cifs_gfiunix_out;\n\n\trc = cifs_fattr_to_inode(inode, &fattr);\n\ncifs_gfiunix_out:\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int cifs_get_unix_fattr(const unsigned char *full_path,\n\t\t\t       struct super_block *sb,\n\t\t\t       struct cifs_fattr *fattr,\n\t\t\t       struct inode **pinode,\n\t\t\t       const unsigned int xid)\n{\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tFILE_UNIX_BASIC_INFO find_data;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc, tmprc;\n\n\tcifs_dbg(FYI, \"Getting info on %s\\n\", full_path);\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\t \n\trc = CIFSSMBUnixQPathInfo(xid, tcon, full_path, &find_data,\n\t\t\t\t  cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tcifs_dbg(FYI, \"%s: query path info: rc = %d\\n\", __func__, rc);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tcifs_unix_basic_to_fattr(fattr, &find_data, cifs_sb);\n\t} else if (rc == -EREMOTE) {\n\t\tcifs_create_junction_fattr(fattr, sb);\n\t\trc = 0;\n\t} else {\n\t\treturn rc;\n\t}\n\n\tif (!*pinode)\n\t\tcifs_fill_uniqueid(sb, fattr);\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, fattr, full_path);\n\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\n\tif (S_ISLNK(fattr->cf_mode) && !fattr->cf_symlink_target) {\n\t\tif (!server->ops->query_symlink)\n\t\t\treturn -EOPNOTSUPP;\n\t\trc = server->ops->query_symlink(xid, tcon,\n\t\t\t\t\t\tcifs_sb, full_path,\n\t\t\t\t\t\t&fattr->cf_symlink_target);\n\t\tcifs_dbg(FYI, \"%s: query_symlink: %d\\n\", __func__, rc);\n\t}\n\treturn rc;\n}\n\nint cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\t     const unsigned char *full_path,\n\t\t\t     struct super_block *sb, unsigned int xid)\n{\n\tstruct cifs_fattr fattr = {};\n\tint rc;\n\n\trc = cifs_get_unix_fattr(full_path, sb, &fattr, pinode, xid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = update_inode_info(sb, &fattr, pinode);\nout:\n\tkfree(fattr.cf_symlink_target);\n\treturn rc;\n}\n#else\nstatic inline int cifs_get_unix_fattr(const unsigned char *full_path,\n\t\t\t\t      struct super_block *sb,\n\t\t\t\t      struct cifs_fattr *fattr,\n\t\t\t\t      struct inode **pinode,\n\t\t\t\t      const unsigned int xid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nint cifs_get_inode_info_unix(struct inode **pinode,\n\t\t\t     const unsigned char *full_path,\n\t\t\t     struct super_block *sb, unsigned int xid)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif  \n\nstatic int\ncifs_sfu_type(struct cifs_fattr *fattr, const char *path,\n\t      struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n\tint rc;\n\t__u32 oplock;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_io_parms io_parms = {0};\n\tchar buf[24];\n\tunsigned int bytes_read;\n\tchar *pbuf;\n\tint buf_type = CIFS_NO_BUFFER;\n\n\tpbuf = buf;\n\n\tfattr->cf_mode &= ~S_IFMT;\n\n\tif (fattr->cf_eof == 0) {\n\t\tfattr->cf_mode |= S_IFIFO;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\treturn 0;\n\t} else if (fattr->cf_eof < 8) {\n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t\treturn -EINVAL;\t  \n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = GENERIC_READ,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = path,\n\t\t.fid = &fid,\n\t};\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"check sfu type of %s, open rc = %d\\n\", path, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t \n\tio_parms.netfid = fid.netfid;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = 24;\n\n\trc = tcon->ses->server->ops->sync_read(xid, &fid, &io_parms,\n\t\t\t\t\t&bytes_read, &pbuf, &buf_type);\n\tif ((rc == 0) && (bytes_read >= 8)) {\n\t\tif (memcmp(\"IntxBLK\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Block device\\n\");\n\t\t\tfattr->cf_mode |= S_IFBLK;\n\t\t\tfattr->cf_dtype = DT_BLK;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t \n\t\t\t\t__u64 mjr;  \n\t\t\t\t__u64 mnr;  \n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxCHR\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"Char device\\n\");\n\t\t\tfattr->cf_mode |= S_IFCHR;\n\t\t\tfattr->cf_dtype = DT_CHR;\n\t\t\tif (bytes_read == 24) {\n\t\t\t\t \n\t\t\t\t__u64 mjr;  \n\t\t\t\t__u64 mnr;  \n\t\t\t\tmjr = le64_to_cpu(*(__le64 *)(pbuf+8));\n\t\t\t\tmnr = le64_to_cpu(*(__le64 *)(pbuf+16));\n\t\t\t\tfattr->cf_rdev = MKDEV(mjr, mnr);\n\t\t\t}\n\t\t} else if (memcmp(\"IntxLNK\", pbuf, 7) == 0) {\n\t\t\tcifs_dbg(FYI, \"Symlink\\n\");\n\t\t\tfattr->cf_mode |= S_IFLNK;\n\t\t\tfattr->cf_dtype = DT_LNK;\n\t\t} else if (memcmp(\"LnxFIFO\", pbuf, 8) == 0) {\n\t\t\tcifs_dbg(FYI, \"FIFO\\n\");\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\tfattr->cf_mode |= S_IFREG;  \n\t\t\tfattr->cf_dtype = DT_REG;\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tfattr->cf_mode |= S_IFREG;  \n\t\tfattr->cf_dtype = DT_REG;\n\t\trc = -EOPNOTSUPP;  \n\t}\n\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n#define SFBITS_MASK (S_ISVTX | S_ISGID | S_ISUID)   \n\n \nstatic int cifs_sfu_mode(struct cifs_fattr *fattr, const unsigned char *path,\n\t\t\t struct cifs_sb_info *cifs_sb, unsigned int xid)\n{\n#ifdef CONFIG_CIFS_XATTR\n\tssize_t rc;\n\tchar ea_value[4];\n\t__u32 mode;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (tcon->ses->server->ops->query_all_EAs == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = tcon->ses->server->ops->query_all_EAs(xid, tcon, path,\n\t\t\t\"SETFILEBITS\", ea_value, 4  ,\n\t\t\tcifs_sb);\n\tcifs_put_tlink(tlink);\n\tif (rc < 0)\n\t\treturn (int)rc;\n\telse if (rc > 3) {\n\t\tmode = le32_to_cpu(*((__le32 *)ea_value));\n\t\tfattr->cf_mode &= ~SFBITS_MASK;\n\t\tcifs_dbg(FYI, \"special bits 0%o org mode 0%o\\n\",\n\t\t\t mode, fattr->cf_mode);\n\t\tfattr->cf_mode = (mode & SFBITS_MASK) | fattr->cf_mode;\n\t\tcifs_dbg(FYI, \"special mode bits 0%o\\n\", mode);\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\n \nstatic void smb311_posix_info_to_fattr(struct cifs_fattr *fattr,\n\t\t\t\t       struct cifs_open_info_data *data,\n\t\t\t\t       struct cifs_sid *owner,\n\t\t\t\t       struct cifs_sid *group,\n\t\t\t\t       struct super_block *sb)\n{\n\tstruct smb311_posix_qinfo *info = &data->posix_fi;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\n\t \n\tfattr->cf_cifsattrs = le32_to_cpu(info->DosAttributes);\n\tfattr->cf_uniqueid = le64_to_cpu(info->Inode);\n\n\tif (info->LastAccessTime)\n\t\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\telse\n\t\tktime_get_coarse_real_ts64(&fattr->cf_atime);\n\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tif (data->adjust_tz) {\n\t\tfattr->cf_ctime.tv_sec += tcon->ses->server->timeAdj;\n\t\tfattr->cf_mtime.tv_sec += tcon->ses->server->timeAdj;\n\t}\n\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\n\tfattr->cf_nlink = le32_to_cpu(info->HardLinks);\n\tfattr->cf_mode = (umode_t) le32_to_cpu(info->Mode);\n\t \n\t \n\n\tif (data->symlink) {\n\t\tfattr->cf_mode |= S_IFLNK;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tfattr->cf_symlink_target = data->symlink_target;\n\t\tdata->symlink_target = NULL;\n\t} else if (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {  \n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\t \n\n\tsid_to_id(cifs_sb, owner, fattr, SIDOWNER);\n\tsid_to_id(cifs_sb, group, fattr, SIDGROUP);\n\n\tcifs_dbg(FYI, \"POSIX query info: mode 0x%x uniqueid 0x%llx nlink %d\\n\",\n\t\tfattr->cf_mode, fattr->cf_uniqueid, fattr->cf_nlink);\n}\n\nstatic inline dev_t nfs_mkdev(struct reparse_posix_data *buf)\n{\n\tu64 v = le64_to_cpu(*(__le64 *)buf->DataBuffer);\n\n\treturn MKDEV(v >> 32, v & 0xffffffff);\n}\n\nbool cifs_reparse_point_to_fattr(struct cifs_sb_info *cifs_sb,\n\t\t\t\t struct cifs_fattr *fattr,\n\t\t\t\t struct cifs_open_info_data *data)\n{\n\tstruct reparse_posix_data *buf = data->reparse.posix;\n\tu32 tag = data->reparse.tag;\n\n\tif (tag == IO_REPARSE_TAG_NFS && buf) {\n\t\tswitch (le64_to_cpu(buf->InodeType)) {\n\t\tcase NFS_SPECFILE_CHR:\n\t\t\tfattr->cf_mode |= S_IFCHR | cifs_sb->ctx->file_mode;\n\t\t\tfattr->cf_dtype = DT_CHR;\n\t\t\tfattr->cf_rdev = nfs_mkdev(buf);\n\t\t\tbreak;\n\t\tcase NFS_SPECFILE_BLK:\n\t\t\tfattr->cf_mode |= S_IFBLK | cifs_sb->ctx->file_mode;\n\t\t\tfattr->cf_dtype = DT_BLK;\n\t\t\tfattr->cf_rdev = nfs_mkdev(buf);\n\t\t\tbreak;\n\t\tcase NFS_SPECFILE_FIFO:\n\t\t\tfattr->cf_mode |= S_IFIFO | cifs_sb->ctx->file_mode;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t\tbreak;\n\t\tcase NFS_SPECFILE_SOCK:\n\t\t\tfattr->cf_mode |= S_IFSOCK | cifs_sb->ctx->file_mode;\n\t\t\tfattr->cf_dtype = DT_SOCK;\n\t\t\tbreak;\n\t\tcase NFS_SPECFILE_LNK:\n\t\t\tfattr->cf_mode = S_IFLNK | cifs_sb->ctx->file_mode;\n\t\t\tfattr->cf_dtype = DT_LNK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tswitch (tag) {\n\tcase IO_REPARSE_TAG_LX_SYMLINK:\n\t\tfattr->cf_mode |= S_IFLNK | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tcase IO_REPARSE_TAG_LX_FIFO:\n\t\tfattr->cf_mode |= S_IFIFO | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_FIFO;\n\t\tbreak;\n\tcase IO_REPARSE_TAG_AF_UNIX:\n\t\tfattr->cf_mode |= S_IFSOCK | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_SOCK;\n\t\tbreak;\n\tcase IO_REPARSE_TAG_LX_CHR:\n\t\tfattr->cf_mode |= S_IFCHR | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_CHR;\n\t\tbreak;\n\tcase IO_REPARSE_TAG_LX_BLK:\n\t\tfattr->cf_mode |= S_IFBLK | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_BLK;\n\t\tbreak;\n\tcase 0:  \n\tcase IO_REPARSE_TAG_SYMLINK:\n\tcase IO_REPARSE_TAG_NFS:\n\t\tfattr->cf_mode = S_IFLNK | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_LNK;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void cifs_open_info_to_fattr(struct cifs_fattr *fattr,\n\t\t\t\t    struct cifs_open_info_data *data,\n\t\t\t\t    struct super_block *sb)\n{\n\tstruct smb2_file_all_info *info = &data->fi;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(info->Attributes);\n\tif (info->DeletePending)\n\t\tfattr->cf_flags |= CIFS_FATTR_DELETE_PENDING;\n\n\tif (info->LastAccessTime)\n\t\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\telse\n\t\tktime_get_coarse_real_ts64(&fattr->cf_atime);\n\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\n\tif (data->adjust_tz) {\n\t\tfattr->cf_ctime.tv_sec += tcon->ses->server->timeAdj;\n\t\tfattr->cf_mtime.tv_sec += tcon->ses->server->timeAdj;\n\t}\n\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(info->CreationTime);\n\tfattr->cf_nlink = le32_to_cpu(info->NumberOfLinks);\n\n\tif (cifs_open_data_reparse(data) &&\n\t    cifs_reparse_point_to_fattr(cifs_sb, fattr, data))\n\t\tgoto out_reparse;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->ctx->dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t\t \n\t\tif (!tcon->unix_ext)\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\n\t\t \n\t\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\t\tfattr->cf_mode &= ~(S_IWUGO);\n\n\t\t \n\t\tif ((fattr->cf_nlink < 1) && !tcon->unix_ext &&\n\t\t    !info->DeletePending) {\n\t\t\tcifs_dbg(VFS, \"bogus file nlink value %u\\n\",\n\t\t\t\t fattr->cf_nlink);\n\t\t\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\t\t}\n\t}\n\nout_reparse:\n\tif (S_ISLNK(fattr->cf_mode)) {\n\t\tif (likely(data->symlink_target))\n\t\t\tfattr->cf_eof = strnlen(data->symlink_target, PATH_MAX);\n\t\tfattr->cf_symlink_target = data->symlink_target;\n\t\tdata->symlink_target = NULL;\n\t}\n\n\tfattr->cf_uid = cifs_sb->ctx->linux_uid;\n\tfattr->cf_gid = cifs_sb->ctx->linux_gid;\n}\n\nstatic int\ncifs_get_file_info(struct file *filp)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_open_info_data data = {};\n\tstruct cifs_fattr fattr;\n\tstruct inode *inode = file_inode(filp);\n\tstruct cifsFileInfo *cfile = filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (!server->ops->query_file_info)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\trc = server->ops->query_file_info(xid, tcon, cfile, &data);\n\tswitch (rc) {\n\tcase 0:\n\t\t \n\t\tdata.adjust_tz = false;\n\t\tif (data.symlink_target) {\n\t\t\tdata.symlink = true;\n\t\t\tdata.reparse.tag = IO_REPARSE_TAG_SYMLINK;\n\t\t}\n\t\tcifs_open_info_to_fattr(&fattr, &data, inode->i_sb);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\tcifs_create_junction_fattr(&fattr, inode->i_sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EOPNOTSUPP:\n\tcase -EINVAL:\n\t\t \n\t\trc = 0;\n\t\tCIFS_I(inode)->time = 0;\n\t\tgoto cgfi_exit;\n\tdefault:\n\t\tgoto cgfi_exit;\n\t}\n\n\t \n\tfattr.cf_uniqueid = CIFS_I(inode)->uniqueid;\n\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t \n\trc = cifs_fattr_to_inode(inode, &fattr);\ncgfi_exit:\n\tcifs_free_open_info(&data);\n\tfree_xid(xid);\n\treturn rc;\n}\n\n \nstatic __u64 simple_hashstr(const char *str)\n{\n\tconst __u64 hash_mult =  1125899906842597ULL;  \n\t__u64 hash = 0;\n\n\twhile (*str)\n\t\thash = (hash + (__u64) *str++) * hash_mult;\n\n\treturn hash;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n \nstatic int\ncifs_backup_query_path_info(int xid,\n\t\t\t    struct cifs_tcon *tcon,\n\t\t\t    struct super_block *sb,\n\t\t\t    const char *full_path,\n\t\t\t    void **resp_buf,\n\t\t\t    FILE_ALL_INFO **data)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_search_info info = {0};\n\tu16 flags;\n\tint rc;\n\n\t*resp_buf = NULL;\n\tinfo.endOfSearch = false;\n\tif (tcon->unix_ext)\n\t\tinfo.info_level = SMB_FIND_FILE_UNIX;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0)\n\t\tinfo.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\tinfo.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\telse  \n\t\tinfo.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\n\tflags = CIFS_SEARCH_CLOSE_ALWAYS |\n\t\tCIFS_SEARCH_CLOSE_AT_END |\n\t\tCIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = CIFSFindFirst(xid, tcon, full_path,\n\t\t\t   cifs_sb, NULL, flags, &info, false);\n\tif (rc)\n\t\treturn rc;\n\n\t*resp_buf = (void *)info.ntwrk_buf_start;\n\t*data = (FILE_ALL_INFO *)info.srch_entries_start;\n\treturn 0;\n}\n#endif  \n\nstatic void cifs_set_fattr_ino(int xid, struct cifs_tcon *tcon, struct super_block *sb,\n\t\t\t       struct inode **inode, const char *full_path,\n\t\t\t       struct cifs_open_info_data *data, struct cifs_fattr *fattr)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tint rc;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tif (*inode)\n\t\t\tfattr->cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\t\telse\n\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\treturn;\n\t}\n\n\t \n\trc = server->ops->get_srv_inum(xid, *inode ? NULL : tcon, cifs_sb, full_path,\n\t\t\t\t       &fattr->cf_uniqueid, data);\n\tif (rc) {\n\t\t \n\t\tif (*inode)\n\t\t\tfattr->cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\t\telse {\n\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\tcifs_autodisable_serverino(cifs_sb);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (fattr->cf_uniqueid == 0 && strlen(full_path) == 0) {\n\t\tcifs_dbg(FYI, \"Invalid (0) inodenum\\n\");\n\t\tif (*inode) {\n\t\t\t \n\t\t\tfattr->cf_uniqueid = CIFS_I(*inode)->uniqueid;\n\t\t} else {\n\t\t\t \n\t\t\tfattr->cf_flags |= CIFS_FATTR_FAKE_ROOT_INO;\n\t\t\tfattr->cf_uniqueid = simple_hashstr(tcon->tree_name);\n\t\t}\n\t}\n}\n\nstatic inline bool is_inode_cache_good(struct inode *ino)\n{\n\treturn ino && CIFS_CACHE_READ(CIFS_I(ino)) && CIFS_I(ino)->time != 0;\n}\n\nstatic int reparse_info_to_fattr(struct cifs_open_info_data *data,\n\t\t\t\t struct super_block *sb,\n\t\t\t\t const unsigned int xid,\n\t\t\t\t struct cifs_tcon *tcon,\n\t\t\t\t const char *full_path,\n\t\t\t\t struct cifs_fattr *fattr)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct kvec rsp_iov, *iov = NULL;\n\tint rsp_buftype = CIFS_NO_BUFFER;\n\tu32 tag = data->reparse.tag;\n\tint rc = 0;\n\n\tif (!tag && server->ops->query_reparse_point) {\n\t\trc = server->ops->query_reparse_point(xid, tcon, cifs_sb,\n\t\t\t\t\t\t      full_path, &tag,\n\t\t\t\t\t\t      &rsp_iov, &rsp_buftype);\n\t\tif (!rc)\n\t\t\tiov = &rsp_iov;\n\t}\n\n\trc = -EOPNOTSUPP;\n\tswitch ((data->reparse.tag = tag)) {\n\tcase 0:  \n\t\tif (server->ops->query_symlink) {\n\t\t\trc = server->ops->query_symlink(xid, tcon,\n\t\t\t\t\t\t\tcifs_sb, full_path,\n\t\t\t\t\t\t\t&data->symlink_target);\n\t\t}\n\t\tbreak;\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\tcifs_create_junction_fattr(fattr, sb);\n\t\trc = 0;\n\t\tgoto out;\n\tdefault:\n\t\tif (data->symlink_target) {\n\t\t\trc = 0;\n\t\t} else if (server->ops->parse_reparse_point) {\n\t\t\trc = server->ops->parse_reparse_point(cifs_sb,\n\t\t\t\t\t\t\t      iov, data);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcifs_open_info_to_fattr(fattr, data, sb);\nout:\n\tfree_rsp_buf(rsp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nstatic int cifs_get_fattr(struct cifs_open_info_data *data,\n\t\t\t  struct super_block *sb, int xid,\n\t\t\t  const struct cifs_fid *fid,\n\t\t\t  struct cifs_fattr *fattr,\n\t\t\t  struct inode **inode,\n\t\t\t  const char *full_path)\n{\n\tstruct cifs_open_info_data tmp_data = {};\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tvoid *smb1_backup_rsp_buf = NULL;\n\tint rc = 0;\n\tint tmprc = 0;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\t \n\n\tif (!data) {\n\t\trc = server->ops->query_path_info(xid, tcon, cifs_sb,\n\t\t\t\t\t\t  full_path, &tmp_data);\n\t\tdata = &tmp_data;\n\t}\n\n\t \n\n\tswitch (rc) {\n\tcase 0:\n\t\t \n\t\tif (cifs_open_data_reparse(data)) {\n\t\t\trc = reparse_info_to_fattr(data, sb, xid, tcon,\n\t\t\t\t\t\t   full_path, fattr);\n\t\t} else {\n\t\t\tcifs_open_info_to_fattr(fattr, data, sb);\n\t\t}\n\t\tbreak;\n\tcase -EREMOTE:\n\t\t \n\t\tcifs_create_junction_fattr(fattr, sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EACCES:\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t\t \n\t\tif (backup_cred(cifs_sb) && is_smb1_server(server)) {\n\t\t\t \n\t\t\tFILE_ALL_INFO *fi;\n\t\t\tFILE_DIRECTORY_INFO *fdi;\n\t\t\tSEARCH_ID_FULL_DIR_INFO *si;\n\n\t\t\trc = cifs_backup_query_path_info(xid, tcon, sb,\n\t\t\t\t\t\t\t full_path,\n\t\t\t\t\t\t\t &smb1_backup_rsp_buf,\n\t\t\t\t\t\t\t &fi);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tmove_cifs_info_to_smb2(&data->fi, fi);\n\t\t\tfdi = (FILE_DIRECTORY_INFO *)fi;\n\t\t\tsi = (SEARCH_ID_FULL_DIR_INFO *)fi;\n\n\t\t\tcifs_dir_info_to_fattr(fattr, fdi, cifs_sb);\n\t\t\tfattr->cf_uniqueid = le64_to_cpu(si->UniqueId);\n\t\t\t \n\t\t\tgoto handle_mnt_opt;\n\t\t} else {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n#else\n\t\tgoto out;\n#endif  \n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"%s: unhandled err rc %d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\n\tcifs_set_fattr_ino(xid, tcon, sb, inode, full_path, data, fattr);\n\n\t \n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nhandle_mnt_opt:\n#endif  \n\t \n\tif ((fattr->cf_cifsattrs & ATTR_SYSTEM) &&\n\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)) {\n\t\ttmprc = cifs_sfu_type(fattr, full_path, cifs_sb, xid);\n\t\tif (tmprc)\n\t\t\tcifs_dbg(FYI, \"cifs_sfu_type failed: %d\\n\", tmprc);\n\t}\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID) {\n\t\trc = cifs_acl_to_fattr(cifs_sb, fattr, *inode,\n\t\t\t\t       true, full_path, fid);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = 0;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: Get mode from SID failed. rc=%d\\n\",\n\t\t\t\t __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) {\n\t\trc = cifs_acl_to_fattr(cifs_sb, fattr, *inode,\n\t\t\t\t       false, full_path, fid);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = 0;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"%s: Getting ACL failed with error: %d\\n\",\n\t\t\t\t __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tcifs_sfu_mode(fattr, full_path, cifs_sb, xid);\n\n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, fattr, full_path);\n\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\nout:\n\tcifs_buf_release(smb1_backup_rsp_buf);\n\tcifs_put_tlink(tlink);\n\tcifs_free_open_info(&tmp_data);\n\treturn rc;\n}\n\nint cifs_get_inode_info(struct inode **inode,\n\t\t\tconst char *full_path,\n\t\t\tstruct cifs_open_info_data *data,\n\t\t\tstruct super_block *sb, int xid,\n\t\t\tconst struct cifs_fid *fid)\n{\n\tstruct cifs_fattr fattr = {};\n\tint rc;\n\n\tif (is_inode_cache_good(*inode)) {\n\t\tcifs_dbg(FYI, \"No need to revalidate cached inode sizes\\n\");\n\t\treturn 0;\n\t}\n\n\trc = cifs_get_fattr(data, sb, xid, fid, &fattr, inode, full_path);\n\tif (rc)\n\t\tgoto out;\n\n\trc = update_inode_info(sb, &fattr, inode);\nout:\n\tkfree(fattr.cf_symlink_target);\n\treturn rc;\n}\n\nstatic int smb311_posix_get_fattr(struct cifs_fattr *fattr,\n\t\t\t\t  const char *full_path,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  const unsigned int xid)\n{\n\tstruct cifs_open_info_data data = {};\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifs_sid owner, group;\n\tint tmprc;\n\tint rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t \n\n\trc = smb311_posix_query_path_info(xid, tcon, cifs_sb,\n\t\t\t\t\t  full_path, &data,\n\t\t\t\t\t  &owner, &group);\n\n\t \n\n\tswitch (rc) {\n\tcase 0:\n\t\tsmb311_posix_info_to_fattr(fattr, &data, &owner, &group, sb);\n\t\tbreak;\n\tcase -EREMOTE:\n\t\t \n\t\tcifs_create_junction_fattr(fattr, sb);\n\t\trc = 0;\n\t\tbreak;\n\tcase -EACCES:\n\t\t \n\t\tgoto out;\n\tdefault:\n\t\tcifs_dbg(FYI, \"%s: unhandled err rc %d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\t \n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) {\n\t\ttmprc = check_mf_symlink(xid, tcon, cifs_sb, fattr, full_path);\n\t\tcifs_dbg(FYI, \"check_mf_symlink: %d\\n\", tmprc);\n\t}\n\nout:\n\tcifs_put_tlink(tlink);\n\tcifs_free_open_info(&data);\n\treturn rc;\n}\n\nint smb311_posix_get_inode_info(struct inode **inode, const char *full_path,\n\t\t\t\tstruct super_block *sb, const unsigned int xid)\n{\n\tstruct cifs_fattr fattr = {};\n\tint rc;\n\n\tif (is_inode_cache_good(*inode)) {\n\t\tcifs_dbg(FYI, \"No need to revalidate cached inode sizes\\n\");\n\t\treturn 0;\n\t}\n\n\trc = smb311_posix_get_fattr(&fattr, full_path, sb, xid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = update_inode_info(sb, &fattr, inode);\nout:\n\tkfree(fattr.cf_symlink_target);\n\treturn rc;\n}\n\nstatic const struct inode_operations cifs_ipc_inode_ops = {\n\t.lookup = cifs_lookup,\n};\n\nstatic int\ncifs_find_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = opaque;\n\n\t \n\tif (CIFS_I(inode)->uniqueid != fattr->cf_uniqueid)\n\t\treturn 0;\n\n\t \n\tif (CIFS_I(inode)->createtime != fattr->cf_createtime)\n\t\treturn 0;\n\n\t \n\tif (inode_wrong_type(inode, fattr->cf_mode))\n\t\treturn 0;\n\n\t \n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry))\n\t\tfattr->cf_flags |= CIFS_FATTR_INO_COLLISION;\n\n\treturn 1;\n}\n\nstatic int\ncifs_init_inode(struct inode *inode, void *opaque)\n{\n\tstruct cifs_fattr *fattr = opaque;\n\n\tCIFS_I(inode)->uniqueid = fattr->cf_uniqueid;\n\tCIFS_I(inode)->createtime = fattr->cf_createtime;\n\treturn 0;\n}\n\n \nstatic bool\ninode_has_hashed_dentries(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tif (!d_unhashed(dentry) || IS_ROOT(dentry)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn false;\n}\n\n \nstruct inode *\ncifs_iget(struct super_block *sb, struct cifs_fattr *fattr)\n{\n\tunsigned long hash;\n\tstruct inode *inode;\n\nretry_iget5_locked:\n\tcifs_dbg(FYI, \"looking for uniqueid=%llu\\n\", fattr->cf_uniqueid);\n\n\t \n\thash = cifs_uniqueid_to_ino_t(fattr->cf_uniqueid);\n\n\tinode = iget5_locked(sb, hash, cifs_find_inode, cifs_init_inode, fattr);\n\tif (inode) {\n\t\t \n\t\tif (fattr->cf_flags & CIFS_FATTR_INO_COLLISION) {\n\t\t\tfattr->cf_flags &= ~CIFS_FATTR_INO_COLLISION;\n\n\t\t\tif (inode_has_hashed_dentries(inode)) {\n\t\t\t\tcifs_autodisable_serverino(CIFS_SB(sb));\n\t\t\t\tiput(inode);\n\t\t\t\tfattr->cf_uniqueid = iunique(sb, ROOT_I);\n\t\t\t\tgoto retry_iget5_locked;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcifs_fattr_to_inode(inode, fattr);\n\t\tif (sb->s_flags & SB_NOATIME)\n\t\t\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\t\tif (inode->i_state & I_NEW) {\n\t\t\tinode->i_ino = hash;\n\t\t\tcifs_fscache_get_inode_cookie(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\n \nstruct inode *cifs_root_iget(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr = {};\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct inode *inode = NULL;\n\tunsigned int xid;\n\tchar *path = NULL;\n\tint len;\n\tint rc;\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)\n\t    && cifs_sb->prepath) {\n\t\tlen = strlen(cifs_sb->prepath);\n\t\tpath = kzalloc(len + 2  , GFP_KERNEL);\n\t\tif (path == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0] = '/';\n\t\tmemcpy(path+1, cifs_sb->prepath, len);\n\t} else {\n\t\tpath = kstrdup(\"\", GFP_KERNEL);\n\t\tif (path == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\txid = get_xid();\n\tif (tcon->unix_ext) {\n\t\trc = cifs_get_unix_fattr(path, sb, &fattr, &inode, xid);\n\t\t \n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto iget_root;\n\t\tcifs_dbg(VFS, \"server does not support POSIX extensions\\n\");\n\t\ttcon->unix_ext = false;\n\t}\n\n\tconvert_delimiter(path, CIFS_DIR_SEP(cifs_sb));\n\tif (tcon->posix_extensions)\n\t\trc = smb311_posix_get_fattr(&fattr, path, sb, xid);\n\telse\n\t\trc = cifs_get_fattr(NULL, sb, xid, NULL, &fattr, &inode, path);\n\niget_root:\n\tif (!rc) {\n\t\tif (fattr.cf_flags & CIFS_FATTR_JUNCTION) {\n\t\t\tfattr.cf_flags &= ~CIFS_FATTR_JUNCTION;\n\t\t\tcifs_autodisable_serverino(cifs_sb);\n\t\t}\n\t\tinode = cifs_iget(sb, &fattr);\n\t}\n\n\tif (!inode) {\n\t\tinode = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\tif (rc && tcon->pipe) {\n\t\tcifs_dbg(FYI, \"ipc connection - fake read inode\\n\");\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_mode |= S_IFDIR;\n\t\tset_nlink(inode, 2);\n\t\tinode->i_op = &cifs_ipc_inode_ops;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_uid = cifs_sb->ctx->linux_uid;\n\t\tinode->i_gid = cifs_sb->ctx->linux_gid;\n\t\tspin_unlock(&inode->i_lock);\n\t} else if (rc) {\n\t\tiget_failed(inode);\n\t\tinode = ERR_PTR(rc);\n\t}\n\nout:\n\tkfree(path);\n\tfree_xid(xid);\n\tkfree(fattr.cf_symlink_target);\n\treturn inode;\n}\n\nint\ncifs_set_file_info(struct inode *inode, struct iattr *attrs, unsigned int xid,\n\t\t   const char *full_path, __u32 dosattr)\n{\n\tbool set_time = false;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct TCP_Server_Info *server;\n\tFILE_BASIC_INFO\tinfo_buf;\n\n\tif (attrs == NULL)\n\t\treturn -EINVAL;\n\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\n\tif (!server->ops->set_file_info)\n\t\treturn -ENOSYS;\n\n\tinfo_buf.Pad = 0;\n\n\tif (attrs->ia_valid & ATTR_ATIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastAccessTime =\n\t\t\tcpu_to_le64(cifs_UnixTimeToNT(attrs->ia_atime));\n\t} else\n\t\tinfo_buf.LastAccessTime = 0;\n\n\tif (attrs->ia_valid & ATTR_MTIME) {\n\t\tset_time = true;\n\t\tinfo_buf.LastWriteTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_mtime));\n\t} else\n\t\tinfo_buf.LastWriteTime = 0;\n\n\t \n\tif (set_time && (attrs->ia_valid & ATTR_CTIME)) {\n\t\tcifs_dbg(FYI, \"CIFS - CTIME changed\\n\");\n\t\tinfo_buf.ChangeTime =\n\t\t    cpu_to_le64(cifs_UnixTimeToNT(attrs->ia_ctime));\n\t} else\n\t\tinfo_buf.ChangeTime = 0;\n\n\tinfo_buf.CreationTime = 0;\t \n\tinfo_buf.Attributes = cpu_to_le32(dosattr);\n\n\treturn server->ops->set_file_info(inode, full_path, &info_buf, xid);\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n \nint\ncifs_rename_pending_delete(const char *full_path, struct dentry *dentry,\n\t\t\t   const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\t__u32 dosattr, origattr;\n\tFILE_BASIC_INFO *info_buf = NULL;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\t \n\tif (!(tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t.desired_access = DELETE | FILE_WRITE_ATTRIBUTES,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = full_path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0)\n\t\tgoto out;\n\n\torigattr = cifsInode->cifsAttrs;\n\tif (origattr == 0)\n\t\torigattr |= ATTR_NORMAL;\n\n\tdosattr = origattr & ~ATTR_READONLY;\n\tif (dosattr == 0)\n\t\tdosattr |= ATTR_NORMAL;\n\tdosattr |= ATTR_HIDDEN;\n\n\t \n\tif (dosattr != origattr) {\n\t\tinfo_buf = kzalloc(sizeof(*info_buf), GFP_KERNEL);\n\t\tif (info_buf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_close;\n\t\t}\n\t\tinfo_buf->Attributes = cpu_to_le32(dosattr);\n\t\trc = CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid);\n\t\t \n\t\tif (!rc)\n\t\t\tcifsInode->cifsAttrs = dosattr;\n\t\telse\n\t\t\tdosattr = origattr;  \n\t}\n\n\t \n\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid, NULL,\n\t\t\t\t   cifs_sb->local_nls,\n\t\t\t\t   cifs_remap(cifs_sb));\n\tif (rc != 0) {\n\t\trc = -EBUSY;\n\t\tgoto undo_setattr;\n\t}\n\n\t \n\tif (!test_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags)) {\n\t\trc = CIFSSMBSetFileDisposition(xid, tcon, true, fid.netfid,\n\t\t\t\t\t       current->tgid);\n\t\t \n\t\tif (rc == -ENOENT)\n\t\t\trc = 0;\n\t\telse if (rc != 0) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto undo_rename;\n\t\t}\n\t\tset_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags);\n\t}\n\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tkfree(info_buf);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n\n\t \nundo_rename:\n\tCIFSSMBRenameOpenFile(xid, tcon, fid.netfid, dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\nundo_setattr:\n\tif (dosattr != origattr) {\n\t\tinfo_buf->Attributes = cpu_to_le32(origattr);\n\t\tif (!CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,\n\t\t\t\t\tcurrent->tgid))\n\t\t\tcifsInode->cifsAttrs = origattr;\n\t}\n\n\tgoto out_close;\n}\n#endif  \n\n \nstatic void\ncifs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\n \nint cifs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tconst char *full_path;\n\tvoid *page;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct cifsInodeInfo *cifs_inode;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct iattr *attrs = NULL;\n\t__u32 dosattr = 0, origattr = 0;\n\n\tcifs_dbg(FYI, \"cifs_unlink, dir=0x%p, dentry=0x%p\\n\", dir, dentry);\n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\txid = get_xid();\n\tpage = alloc_dentry_path();\n\n\tif (tcon->nodelete) {\n\t\trc = -EACCES;\n\t\tgoto unlink_out;\n\t}\n\n\t \n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto unlink_out;\n\t}\n\n\tcifs_close_deferred_file_under_dentry(tcon, full_path);\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = CIFSPOSIXDelFile(xid, tcon, full_path,\n\t\t\tSMB_POSIX_UNLINK_FILE_TARGET, cifs_sb->local_nls,\n\t\t\tcifs_remap(cifs_sb));\n\t\tcifs_dbg(FYI, \"posix del rc %d\\n\", rc);\n\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\tgoto psx_del_no_retry;\n\t}\n#endif  \n\nretry_std_delete:\n\tif (!server->ops->unlink) {\n\t\trc = -ENOSYS;\n\t\tgoto psx_del_no_retry;\n\t}\n\n\trc = server->ops->unlink(xid, tcon, full_path, cifs_sb);\n\npsx_del_no_retry:\n\tif (!rc) {\n\t\tif (inode)\n\t\t\tcifs_drop_nlink(inode);\n\t} else if (rc == -ENOENT) {\n\t\td_drop(dentry);\n\t} else if (rc == -EBUSY) {\n\t\tif (server->ops->rename_pending_delete) {\n\t\t\trc = server->ops->rename_pending_delete(full_path,\n\t\t\t\t\t\t\t\tdentry, xid);\n\t\t\tif (rc == 0)\n\t\t\t\tcifs_drop_nlink(inode);\n\t\t}\n\t} else if ((rc == -EACCES) && (dosattr == 0) && inode) {\n\t\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\t\tif (attrs == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_reval;\n\t\t}\n\n\t\t \n\t\tcifs_inode = CIFS_I(inode);\n\t\torigattr = cifs_inode->cifsAttrs;\n\t\tif (origattr == 0)\n\t\t\torigattr |= ATTR_NORMAL;\n\t\tdosattr = origattr & ~ATTR_READONLY;\n\t\tif (dosattr == 0)\n\t\t\tdosattr |= ATTR_NORMAL;\n\t\tdosattr |= ATTR_HIDDEN;\n\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\tif (rc != 0)\n\t\t\tgoto out_reval;\n\n\t\tgoto retry_std_delete;\n\t}\n\n\t \n\tif (rc != 0 && dosattr != 0)\n\t\tcifs_set_file_info(inode, attrs, xid, full_path, origattr);\n\nout_reval:\n\tif (inode) {\n\t\tcifs_inode = CIFS_I(inode);\n\t\tcifs_inode->time = 0;\t \n\t\tinode_set_ctime_current(inode);\n\t}\n\tinode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));\n\tcifs_inode = CIFS_I(dir);\n\tCIFS_I(dir)->time = 0;\t \nunlink_out:\n\tfree_dentry_path(page);\n\tkfree(attrs);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ncifs_mkdir_qinfo(struct inode *parent, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tstruct inode *inode = NULL;\n\n\tif (tcon->posix_extensions)\n\t\trc = smb311_posix_get_inode_info(&inode, full_path, parent->i_sb, xid);\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\telse if (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, parent->i_sb,\n\t\t\t\t\t      xid);\n#endif  \n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, parent->i_sb,\n\t\t\t\t\t xid, NULL);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\t \n\t\t iput(inode);\n\t\t d_drop(dentry);\n\t\t return 0;\n\t}\n\t \n\tif (inode->i_nlink < 2)\n\t\tset_nlink(inode, 2);\n\tmode &= ~current_umask();\n\t \n\tif (parent->i_mode & S_ISGID)\n\t\tmode |= S_ISGID;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode,\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (parent->i_mode & S_ISGID)\n\t\t\t\targs.gid = parent->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID;  \n\t\t\targs.gid = INVALID_GID;  \n\t\t}\n\t\tCIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t       cifs_sb->local_nls,\n\t\t\t\t       cifs_remap(cifs_sb));\n\t} else {\n#else\n\t{\n#endif  \n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t\t    (mode & S_IWUGO) == 0 && server->ops->mkdir_setinfo)\n\t\t\tserver->ops->mkdir_setinfo(inode, full_path, cifs_sb,\n\t\t\t\t\t\t   tcon, xid);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\tinode->i_mode = (mode | S_IFDIR);\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\tinode->i_uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\tinode->i_gid = parent->i_gid;\n\t\t\telse\n\t\t\t\tinode->i_gid = current_fsgid();\n\t\t}\n\t}\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int\ncifs_posix_mkdir(struct inode *inode, struct dentry *dentry, umode_t mode,\n\t\t const char *full_path, struct cifs_sb_info *cifs_sb,\n\t\t struct cifs_tcon *tcon, const unsigned int xid)\n{\n\tint rc = 0;\n\tu32 oplock = 0;\n\tFILE_UNIX_BASIC_INFO *info = NULL;\n\tstruct inode *newinode = NULL;\n\tstruct cifs_fattr fattr;\n\n\tinfo = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (info == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tmode &= ~current_umask();\n\trc = CIFSPOSIXCreate(xid, tcon, SMB_O_DIRECTORY | SMB_O_CREAT, mode,\n\t\t\t     NULL  , info, &oplock, full_path,\n\t\t\t     cifs_sb->local_nls, cifs_remap(cifs_sb));\n\tif (rc == -EOPNOTSUPP)\n\t\tgoto posix_mkdir_out;\n\telse if (rc) {\n\t\tcifs_dbg(FYI, \"posix mkdir returned 0x%x\\n\", rc);\n\t\td_drop(dentry);\n\t\tgoto posix_mkdir_out;\n\t}\n\n\tif (info->Type == cpu_to_le32(-1))\n\t\t \n\t\tgoto posix_mkdir_get_info;\n\t \n\n\tcifs_unix_basic_to_fattr(&fattr, info, cifs_sb);\n\tcifs_fill_uniqueid(inode->i_sb, &fattr);\n\tnewinode = cifs_iget(inode->i_sb, &fattr);\n\tif (!newinode)\n\t\tgoto posix_mkdir_get_info;\n\n\td_instantiate(dentry, newinode);\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tcifs_dbg(FYI, \"instantiated dentry %p %pd to inode %p\\n\",\n\t\t dentry, dentry, newinode);\n\n\tif (newinode->i_nlink != 2)\n\t\tcifs_dbg(FYI, \"unexpected number of links %d\\n\",\n\t\t\t newinode->i_nlink);\n#endif\n\nposix_mkdir_out:\n\tkfree(info);\n\treturn rc;\nposix_mkdir_get_info:\n\trc = cifs_mkdir_qinfo(inode, dentry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\n\tgoto posix_mkdir_out;\n}\n#endif  \n\nint cifs_mkdir(struct mnt_idmap *idmap, struct inode *inode,\n\t       struct dentry *direntry, umode_t mode)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tconst char *full_path;\n\tvoid *page;\n\n\tcifs_dbg(FYI, \"In cifs_mkdir, mode = %04ho inode = 0x%p\\n\",\n\t\t mode, inode);\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tpage = alloc_dentry_path();\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto mkdir_out;\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif ((server->ops->posix_mkdir) && (tcon->posix_extensions)) {\n\t\trc = server->ops->posix_mkdir(xid, inode, mode, tcon, full_path,\n\t\t\t\t\t      cifs_sb);\n\t\td_drop(direntry);  \n\t\tgoto mkdir_out;\n\t}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_mkdir(inode, direntry, mode, full_path, cifs_sb,\n\t\t\t\t      tcon, xid);\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto mkdir_out;\n\t}\n#endif  \n\n\tif (!server->ops->mkdir) {\n\t\trc = -ENOSYS;\n\t\tgoto mkdir_out;\n\t}\n\n\t \n\trc = server->ops->mkdir(xid, inode, mode, tcon, full_path, cifs_sb);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_mkdir returned 0x%x\\n\", rc);\n\t\td_drop(direntry);\n\t\tgoto mkdir_out;\n\t}\n\n\t \n\trc = cifs_mkdir_qinfo(inode, direntry, mode, full_path, cifs_sb, tcon,\n\t\t\t      xid);\nmkdir_out:\n\t \n\tCIFS_I(inode)->time = 0;\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint cifs_rmdir(struct inode *inode, struct dentry *direntry)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tconst char *full_path;\n\tvoid *page = alloc_dentry_path();\n\tstruct cifsInodeInfo *cifsInode;\n\n\tcifs_dbg(FYI, \"cifs_rmdir, inode = 0x%p\\n\", inode);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto rmdir_exit;\n\t}\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\tif (unlikely(cifs_forced_shutdown(cifs_sb))) {\n\t\trc = -EIO;\n\t\tgoto rmdir_exit;\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rmdir) {\n\t\trc = -ENOSYS;\n\t\tcifs_put_tlink(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\n\tif (tcon->nodelete) {\n\t\trc = -EACCES;\n\t\tcifs_put_tlink(tlink);\n\t\tgoto rmdir_exit;\n\t}\n\n\trc = server->ops->rmdir(xid, tcon, full_path, cifs_sb);\n\tcifs_put_tlink(tlink);\n\n\tif (!rc) {\n\t\tspin_lock(&d_inode(direntry)->i_lock);\n\t\ti_size_write(d_inode(direntry), 0);\n\t\tclear_nlink(d_inode(direntry));\n\t\tspin_unlock(&d_inode(direntry)->i_lock);\n\t}\n\n\tcifsInode = CIFS_I(d_inode(direntry));\n\t \n\tcifsInode->time = 0;\n\n\tcifsInode = CIFS_I(inode);\n\t \n\tcifsInode->time = 0;\n\n\tinode_set_ctime_current(d_inode(direntry));\n\tinode_set_mtime_to_ts(inode, inode_set_ctime_current(inode));\n\nrmdir_exit:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic int\ncifs_do_rename(const unsigned int xid, struct dentry *from_dentry,\n\t       const char *from_path, struct dentry *to_dentry,\n\t       const char *to_path)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(from_dentry->d_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tint oplock;\n#endif  \n\tint rc;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->rename)\n\t\treturn -ENOSYS;\n\n\t \n\trc = server->ops->rename(xid, tcon, from_path, to_path, cifs_sb);\n\n\t \n\tif (rc == 0 || rc != -EBUSY)\n\t\tgoto do_rename_exit;\n\n\t \n\tif (server->vals->protocol_id != 0)\n\t\tgoto do_rename_exit;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t \n\tif (to_dentry->d_parent != from_dentry->d_parent)\n\t\tgoto do_rename_exit;\n\n\toparms = (struct cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.cifs_sb = cifs_sb,\n\t\t \n\t\t.desired_access = DELETE,\n\t\t.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),\n\t\t.disposition = FILE_OPEN,\n\t\t.path = from_path,\n\t\t.fid = &fid,\n\t};\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc == 0) {\n\t\trc = CIFSSMBRenameOpenFile(xid, tcon, fid.netfid,\n\t\t\t\t(const char *) to_dentry->d_name.name,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n#endif  \ndo_rename_exit:\n\tif (rc == 0)\n\t\td_move(from_dentry, to_dentry);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\ncifs_rename2(struct mnt_idmap *idmap, struct inode *source_dir,\n\t     struct dentry *source_dentry, struct inode *target_dir,\n\t     struct dentry *target_dentry, unsigned int flags)\n{\n\tconst char *from_name, *to_name;\n\tvoid *page1, *page2;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tunsigned int xid;\n\tint rc, tmprc;\n\tint retry_count = 0;\n\tFILE_UNIX_BASIC_INFO *info_buf_source = NULL;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tFILE_UNIX_BASIC_INFO *info_buf_target;\n#endif  \n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(source_dir->i_sb);\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tpage1 = alloc_dentry_path();\n\tpage2 = alloc_dentry_path();\n\txid = get_xid();\n\n\tfrom_name = build_path_from_dentry(source_dentry, page1);\n\tif (IS_ERR(from_name)) {\n\t\trc = PTR_ERR(from_name);\n\t\tgoto cifs_rename_exit;\n\t}\n\n\tto_name = build_path_from_dentry(target_dentry, page2);\n\tif (IS_ERR(to_name)) {\n\t\trc = PTR_ERR(to_name);\n\t\tgoto cifs_rename_exit;\n\t}\n\n\tcifs_close_deferred_file_under_dentry(tcon, from_name);\n\tif (d_inode(target_dentry) != NULL)\n\t\tcifs_close_deferred_file_under_dentry(tcon, to_name);\n\n\trc = cifs_do_rename(xid, source_dentry, from_name, target_dentry,\n\t\t\t    to_name);\n\n\tif (rc == -EACCES) {\n\t\twhile (retry_count < 3) {\n\t\t\tcifs_close_all_deferred_files(tcon);\n\t\t\trc = cifs_do_rename(xid, source_dentry, from_name, target_dentry,\n\t\t\t\t\t    to_name);\n\t\t\tif (rc != -EACCES)\n\t\t\t\tbreak;\n\t\t\tretry_count++;\n\t\t}\n\t}\n\n\t \n\tif (flags & RENAME_NOREPLACE)\n\t\tgoto cifs_rename_exit;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (rc == -EEXIST && tcon->unix_ext) {\n\t\t \n\t\tinfo_buf_source =\n\t\t\tkmalloc_array(2, sizeof(FILE_UNIX_BASIC_INFO),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (info_buf_source == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\n\t\tinfo_buf_target = info_buf_source + 1;\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, from_name,\n\t\t\t\t\t     info_buf_source,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\t\tif (tmprc != 0)\n\t\t\tgoto unlink_target;\n\n\t\ttmprc = CIFSSMBUnixQPathInfo(xid, tcon, to_name,\n\t\t\t\t\t     info_buf_target,\n\t\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t\t     cifs_remap(cifs_sb));\n\n\t\tif (tmprc == 0 && (info_buf_source->UniqueId ==\n\t\t\t\t   info_buf_target->UniqueId)) {\n\t\t\t \n\t\t\trc = 0;\n\t\t\tgoto cifs_rename_exit;\n\t\t}\n\t}\n\t \n\nunlink_target:\n#endif  \n\n\t \n\tif (d_really_is_positive(target_dentry) && (rc == -EACCES || rc == -EEXIST)) {\n\t\tif (d_is_dir(target_dentry))\n\t\t\ttmprc = cifs_rmdir(target_dir, target_dentry);\n\t\telse\n\t\t\ttmprc = cifs_unlink(target_dir, target_dentry);\n\t\tif (tmprc)\n\t\t\tgoto cifs_rename_exit;\n\t\trc = cifs_do_rename(xid, source_dentry, from_name,\n\t\t\t\t    target_dentry, to_name);\n\t}\n\n\t \n\tCIFS_I(source_dir)->time = CIFS_I(target_dir)->time = 0;\n\ncifs_rename_exit:\n\tkfree(info_buf_source);\n\tfree_dentry_path(page2);\n\tfree_dentry_path(page1);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic bool\ncifs_dentry_needs_reval(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cached_fid *cfid = NULL;\n\n\tif (cifs_i->time == 0)\n\t\treturn true;\n\n\tif (CIFS_CACHE_READ(cifs_i))\n\t\treturn false;\n\n\tif (!lookupCacheEnabled)\n\t\treturn true;\n\n\tif (!open_cached_dir_by_dentry(tcon, dentry->d_parent, &cfid)) {\n\t\tspin_lock(&cfid->fid_lock);\n\t\tif (cfid->time && cifs_i->time > cfid->time) {\n\t\t\tspin_unlock(&cfid->fid_lock);\n\t\t\tclose_cached_dir(cfid);\n\t\t\treturn false;\n\t\t}\n\t\tspin_unlock(&cfid->fid_lock);\n\t\tclose_cached_dir(cfid);\n\t}\n\t \n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (!cifs_sb->ctx->acdirmax)\n\t\t\treturn true;\n\t\tif (!time_in_range(jiffies, cifs_i->time,\n\t\t\t\t   cifs_i->time + cifs_sb->ctx->acdirmax))\n\t\t\treturn true;\n\t} else {  \n\t\tif (!cifs_sb->ctx->acregmax)\n\t\t\treturn true;\n\t\tif (!time_in_range(jiffies, cifs_i->time,\n\t\t\t\t   cifs_i->time + cifs_sb->ctx->acregmax))\n\t\t\treturn true;\n\t}\n\n\t \n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) &&\n\t    S_ISREG(inode->i_mode) && inode->i_nlink != 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint\ncifs_invalidate_mapping(struct inode *inode)\n{\n\tint rc = 0;\n\n\tif (inode->i_mapping && inode->i_mapping->nrpages != 0) {\n\t\trc = invalidate_inode_pages2(inode->i_mapping);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"%s: invalidate inode %p failed with rc %d\\n\",\n\t\t\t\t __func__, inode, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\ncifs_wait_bit_killable(struct wait_bit_key *key, int mode)\n{\n\tschedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nint\ncifs_revalidate_mapping(struct inode *inode)\n{\n\tint rc;\n\tunsigned long *flags = &CIFS_I(inode)->flags;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\t \n\tif (IS_SWAPFILE(inode))\n\t\treturn 0;\n\n\trc = wait_on_bit_lock_action(flags, CIFS_INO_LOCK, cifs_wait_bit_killable,\n\t\t\t\t     TASK_KILLABLE|TASK_FREEZABLE_UNSAFE);\n\tif (rc)\n\t\treturn rc;\n\n\tif (test_and_clear_bit(CIFS_INO_INVALID_MAPPING, flags)) {\n\t\t \n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RW_CACHE)\n\t\t\tgoto skip_invalidate;\n\n\t\trc = cifs_invalidate_mapping(inode);\n\t\tif (rc)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, flags);\n\t}\n\nskip_invalidate:\n\tclear_bit_unlock(CIFS_INO_LOCK, flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(flags, CIFS_INO_LOCK);\n\n\treturn rc;\n}\n\nint\ncifs_zap_mapping(struct inode *inode)\n{\n\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_revalidate_file_attr(struct file *filp)\n{\n\tint rc = 0;\n\tstruct dentry *dentry = file_dentry(filp);\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *) filp->private_data;\n#endif  \n\n\tif (!cifs_dentry_needs_reval(dentry))\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tif (tlink_tcon(cfile->tlink)->unix_ext)\n\t\trc = cifs_get_file_info_unix(filp);\n\telse\n#endif  \n\t\trc = cifs_get_file_info(filp);\n\n\treturn rc;\n}\n\nint cifs_revalidate_dentry_attr(struct dentry *dentry)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct super_block *sb = dentry->d_sb;\n\tconst char *full_path;\n\tvoid *page;\n\tint count = 0;\n\n\tif (inode == NULL)\n\t\treturn -ENOENT;\n\n\tif (!cifs_dentry_needs_reval(dentry))\n\t\treturn rc;\n\n\txid = get_xid();\n\n\tpage = alloc_dentry_path();\n\tfull_path = build_path_from_dentry(dentry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"Update attributes: %s inode 0x%p count %d dentry: 0x%p d_time %ld jiffies %ld\\n\",\n\t\t full_path, inode, inode->i_count.counter,\n\t\t dentry, cifs_get_time(dentry), jiffies);\n\nagain:\n\tif (cifs_sb_master_tcon(CIFS_SB(sb))->posix_extensions)\n\t\trc = smb311_posix_get_inode_info(&inode, full_path, sb, xid);\n\telse if (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, sb, xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, NULL, sb,\n\t\t\t\t\t xid, NULL);\n\tif (rc == -EAGAIN && count++ < 10)\n\t\tgoto again;\nout:\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\n\treturn rc;\n}\n\nint cifs_revalidate_file(struct file *filp)\n{\n\tint rc;\n\tstruct inode *inode = file_inode(filp);\n\n\trc = cifs_revalidate_file_attr(filp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\n \nint cifs_revalidate_dentry(struct dentry *dentry)\n{\n\tint rc;\n\tstruct inode *inode = d_inode(dentry);\n\n\trc = cifs_revalidate_dentry_attr(dentry);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cifs_revalidate_mapping(inode);\n}\n\nint cifs_getattr(struct mnt_idmap *idmap, const struct path *path,\n\t\t struct kstat *stat, u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct inode *inode = d_inode(dentry);\n\tint rc;\n\n\tif (unlikely(cifs_forced_shutdown(CIFS_SB(inode->i_sb))))\n\t\treturn -EIO;\n\n\t \n\tif ((request_mask & (STATX_CTIME | STATX_MTIME | STATX_SIZE | STATX_BLOCKS)) &&\n\t    !CIFS_CACHE_READ(CIFS_I(inode)) &&\n\t    inode->i_mapping && inode->i_mapping->nrpages != 0) {\n\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\tif (rc) {\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif ((flags & AT_STATX_SYNC_TYPE) == AT_STATX_FORCE_SYNC)\n\t\tCIFS_I(inode)->time = 0;  \n\n\t \n\tif (((flags & AT_STATX_SYNC_TYPE) != AT_STATX_DONT_SYNC) ||\n\t    (CIFS_I(inode)->time == 0)) {\n\t\trc = cifs_revalidate_dentry_attr(dentry);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tgeneric_fillattr(&nop_mnt_idmap, request_mask, inode, stat);\n\tstat->blksize = cifs_sb->ctx->bsize;\n\tstat->ino = CIFS_I(inode)->uniqueid;\n\n\t \n\tif (CIFS_I(inode)->createtime) {\n\t\tstat->result_mask |= STATX_BTIME;\n\t\tstat->btime =\n\t\t      cifs_NTtimeToUnix(cpu_to_le64(CIFS_I(inode)->createtime));\n\t}\n\n\tstat->attributes_mask |= (STATX_ATTR_COMPRESSED | STATX_ATTR_ENCRYPTED);\n\tif (CIFS_I(inode)->cifsAttrs & FILE_ATTRIBUTE_COMPRESSED)\n\t\tstat->attributes |= STATX_ATTR_COMPRESSED;\n\tif (CIFS_I(inode)->cifsAttrs & FILE_ATTRIBUTE_ENCRYPTED)\n\t\tstat->attributes |= STATX_ATTR_ENCRYPTED;\n\n\t \n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER) &&\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&\n\t    !tcon->unix_ext) {\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID))\n\t\t\tstat->uid = current_fsuid();\n\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID))\n\t\t\tstat->gid = current_fsgid();\n\t}\n\treturn 0;\n}\n\nint cifs_fiemap(struct inode *inode, struct fiemap_extent_info *fei, u64 start,\n\t\tu64 len)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_i->netfs.inode.i_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsFileInfo *cfile;\n\tint rc;\n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\t \n\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t    inode->i_mapping->nrpages != 0) {\n\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\tif (rc) {\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tcfile = find_readable_file(cifs_i, false);\n\tif (cfile == NULL)\n\t\treturn -EINVAL;\n\n\tif (server->ops->fiemap) {\n\t\trc = server->ops->fiemap(tcon, cfile, fei, start, len);\n\t\tcifsFileInfo_put(cfile);\n\t\treturn rc;\n\t}\n\n\tcifsFileInfo_put(cfile);\n\treturn -EOPNOTSUPP;\n}\n\nint cifs_truncate_page(struct address_space *mapping, loff_t from)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE - 1);\n\tstruct page *page;\n\tint rc = 0;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tzero_user_segment(page, offset, PAGE_SIZE);\n\tunlock_page(page);\n\tput_page(page);\n\treturn rc;\n}\n\nvoid cifs_setsize(struct inode *inode, loff_t offset)\n{\n\tstruct cifsInodeInfo *cifs_i = CIFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\ti_size_write(inode, offset);\n\tspin_unlock(&inode->i_lock);\n\n\t \n\tcifs_i->time = 0;\n\ttruncate_pagecache(inode, offset);\n}\n\nstatic int\ncifs_set_file_size(struct inode *inode, struct iattr *attrs,\n\t\t   unsigned int xid, const char *full_path)\n{\n\tint rc;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct TCP_Server_Info *server;\n\n\t \n\topen_file = find_writable_file(cifsInode, FIND_WR_FSUID_ONLY);\n\tif (open_file) {\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->set_file_size)\n\t\t\trc = server->ops->set_file_size(xid, tcon, open_file,\n\t\t\t\t\t\t\tattrs->ia_size, false);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifsFileInfo_put(open_file);\n\t\tcifs_dbg(FYI, \"SetFSize for attrs rc = %d\\n\", rc);\n\t} else\n\t\trc = -EINVAL;\n\n\tif (!rc)\n\t\tgoto set_size_out;\n\n\tif (tcon == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t\tserver = tcon->ses->server;\n\t}\n\n\t \n\tif (server->ops->set_path_size)\n\t\trc = server->ops->set_path_size(xid, tcon, full_path,\n\t\t\t\t\t\tattrs->ia_size, cifs_sb, false);\n\telse\n\t\trc = -ENOSYS;\n\tcifs_dbg(FYI, \"SetEOF by path (setattrs) rc = %d\\n\", rc);\n\n\tif (tlink)\n\t\tcifs_put_tlink(tlink);\n\nset_size_out:\n\tif (rc == 0) {\n\t\tcifsInode->server_eof = attrs->ia_size;\n\t\tcifs_setsize(inode, attrs->ia_size);\n\t\t \n\t\tinode->i_blocks = (512 - 1 + attrs->ia_size) >> 9;\n\n\t\t \n\t\tattrs->ia_ctime = attrs->ia_mtime = current_time(inode);\n\t\tattrs->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\n\t\tcifs_truncate_page(inode->i_mapping, inode->i_size);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\nstatic int\ncifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)\n{\n\tint rc;\n\tunsigned int xid;\n\tconst char *full_path;\n\tvoid *page = alloc_dentry_path();\n\tstruct inode *inode = d_inode(direntry);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_unix_set_info_args *args = NULL;\n\tstruct cifsFileInfo *open_file;\n\n\tcifs_dbg(FYI, \"setattr_unix on file %pd attrs->ia_valid=0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\txid = get_xid();\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = setattr_prepare(&nop_mnt_idmap, direntry, attrs);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto out;\n\t}\n\n\t \n\trc = filemap_write_and_wait(inode->i_mapping);\n\tif (is_interrupt_error(rc)) {\n\t\trc = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\n\tmapping_set_error(inode->i_mapping, rc);\n\trc = 0;\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\targs = kmalloc(sizeof(*args), GFP_KERNEL);\n\tif (args == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (attrs->ia_valid & ATTR_MODE)\n\t\targs->mode = attrs->ia_mode;\n\telse\n\t\targs->mode = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\targs->uid = attrs->ia_uid;\n\telse\n\t\targs->uid = INVALID_UID;  \n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\targs->gid = attrs->ia_gid;\n\telse\n\t\targs->gid = INVALID_GID;  \n\n\tif (attrs->ia_valid & ATTR_ATIME)\n\t\targs->atime = cifs_UnixTimeToNT(attrs->ia_atime);\n\telse\n\t\targs->atime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_MTIME)\n\t\targs->mtime = cifs_UnixTimeToNT(attrs->ia_mtime);\n\telse\n\t\targs->mtime = NO_CHANGE_64;\n\n\tif (attrs->ia_valid & ATTR_CTIME)\n\t\targs->ctime = cifs_UnixTimeToNT(attrs->ia_ctime);\n\telse\n\t\targs->ctime = NO_CHANGE_64;\n\n\targs->device = 0;\n\topen_file = find_writable_file(cifsInode, FIND_WR_FSUID_ONLY);\n\tif (open_file) {\n\t\tu16 nfid = open_file->fid.netfid;\n\t\tu32 npid = open_file->pid;\n\t\tpTcon = tlink_tcon(open_file->tlink);\n\t\trc = CIFSSMBUnixSetFileInfo(xid, pTcon, args, nfid, npid);\n\t\tcifsFileInfo_put(open_file);\n\t} else {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink)) {\n\t\t\trc = PTR_ERR(tlink);\n\t\t\tgoto out;\n\t\t}\n\t\tpTcon = tlink_tcon(tlink);\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, args,\n\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t    cifs_remap(cifs_sb));\n\t\tcifs_put_tlink(tlink);\n\t}\n\n\tif (rc)\n\t\tgoto out;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode)) {\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\t\tfscache_resize_cookie(cifs_inode_cookie(inode), attrs->ia_size);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attrs);\n\tmark_inode_dirty(inode);\n\n\t \n\tif (attrs->ia_valid & (ATTR_MTIME | ATTR_CTIME))\n\t\tcifsInode->time = 0;\nout:\n\tkfree(args);\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\treturn rc;\n}\n#endif  \n\nstatic int\ncifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)\n{\n\tunsigned int xid;\n\tkuid_t uid = INVALID_UID;\n\tkgid_t gid = INVALID_GID;\n\tstruct inode *inode = d_inode(direntry);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsInodeInfo *cifsInode = CIFS_I(inode);\n\tstruct cifsFileInfo *wfile;\n\tstruct cifs_tcon *tcon;\n\tconst char *full_path;\n\tvoid *page = alloc_dentry_path();\n\tint rc = -EACCES;\n\t__u32 dosattr = 0;\n\t__u64 mode = NO_CHANGE_64;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"setattr on file %pd attrs->ia_valid 0x%x\\n\",\n\t\t direntry, attrs->ia_valid);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tattrs->ia_valid |= ATTR_FORCE;\n\n\trc = setattr_prepare(&nop_mnt_idmap, direntry, attrs);\n\tif (rc < 0)\n\t\tgoto cifs_setattr_exit;\n\n\tfull_path = build_path_from_dentry(direntry, page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto cifs_setattr_exit;\n\t}\n\n\t \n\tif (attrs->ia_valid & (ATTR_MTIME | ATTR_SIZE | ATTR_CTIME)) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tif (is_interrupt_error(rc)) {\n\t\t\trc = -ERESTARTSYS;\n\t\t\tgoto cifs_setattr_exit;\n\t\t}\n\t\tmapping_set_error(inode->i_mapping, rc);\n\t}\n\n\trc = 0;\n\n\tif ((attrs->ia_valid & ATTR_MTIME) &&\n\t    !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\trc = cifs_get_writable_file(cifsInode, FIND_WR_ANY, &wfile);\n\t\tif (!rc) {\n\t\t\ttcon = tlink_tcon(wfile->tlink);\n\t\t\trc = tcon->ses->server->ops->flush(xid, tcon, &wfile->fid);\n\t\t\tcifsFileInfo_put(wfile);\n\t\t\tif (rc)\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t} else if (rc != -EBADF)\n\t\t\tgoto cifs_setattr_exit;\n\t\telse\n\t\t\trc = 0;\n\t}\n\n\tif (attrs->ia_valid & ATTR_SIZE) {\n\t\trc = cifs_set_file_size(inode, attrs, xid, full_path);\n\t\tif (rc != 0)\n\t\t\tgoto cifs_setattr_exit;\n\t}\n\n\tif (attrs->ia_valid & ATTR_UID)\n\t\tuid = attrs->ia_uid;\n\n\tif (attrs->ia_valid & ATTR_GID)\n\t\tgid = attrs->ia_gid;\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) ||\n\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID)) {\n\t\tif (uid_valid(uid) || gid_valid(gid)) {\n\t\t\tmode = NO_CHANGE_64;\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, &mode,\n\t\t\t\t\t\t\tuid, gid);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting id failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\t\t}\n\t} else\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID))\n\t\tattrs->ia_valid &= ~(ATTR_UID | ATTR_GID);\n\n\t \n\tif (attrs->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))\n\t\tattrs->ia_valid &= ~ATTR_MODE;\n\n\tif (attrs->ia_valid & ATTR_MODE) {\n\t\tmode = attrs->ia_mode;\n\t\trc = 0;\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) ||\n\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID)) {\n\t\t\trc = id_mode_to_cifs_acl(inode, full_path, &mode,\n\t\t\t\t\t\tINVALID_UID, INVALID_GID);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Setting ACL failed with error: %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\t\tgoto cifs_setattr_exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mode != attrs->ia_mode)\n\t\t\t\tattrs->ia_mode = mode;\n\t\t} else\n\t\tif (((mode & S_IWUGO) == 0) &&\n\t\t    (cifsInode->cifsAttrs & ATTR_READONLY) == 0) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs | ATTR_READONLY;\n\n\t\t\t \n\t\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM) == 0)\n\t\t\t\tattrs->ia_mode = inode->i_mode & ~S_IWUGO;\n\t\t} else if ((mode & S_IWUGO) &&\n\t\t\t   (cifsInode->cifsAttrs & ATTR_READONLY)) {\n\n\t\t\tdosattr = cifsInode->cifsAttrs & ~ATTR_READONLY;\n\t\t\t \n\t\t\tif (dosattr == 0)\n\t\t\t\tdosattr |= ATTR_NORMAL;\n\n\t\t\t \n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t\tattrs->ia_mode &= ~(S_IALLUGO);\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->ctx->dir_mode;\n\t\t\t\telse\n\t\t\t\t\tattrs->ia_mode |=\n\t\t\t\t\t\tcifs_sb->ctx->file_mode;\n\t\t\t}\n\t\t} else if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)) {\n\t\t\t \n\t\t\tattrs->ia_valid &= ~ATTR_MODE;\n\t\t}\n\t}\n\n\tif (attrs->ia_valid & (ATTR_MTIME|ATTR_ATIME|ATTR_CTIME) ||\n\t    ((attrs->ia_valid & ATTR_MODE) && dosattr)) {\n\t\trc = cifs_set_file_info(inode, attrs, xid, full_path, dosattr);\n\t\t \n\n\t\t \n\t\tif ((rc) && (attrs->ia_valid &\n\t\t\t\t(ATTR_MODE | ATTR_GID | ATTR_UID | ATTR_SIZE)))\n\t\t\trc = 0;\n\t}\n\n\t \n\tif (rc)\n\t\tgoto cifs_setattr_exit;\n\n\tif ((attrs->ia_valid & ATTR_SIZE) &&\n\t    attrs->ia_size != i_size_read(inode)) {\n\t\ttruncate_setsize(inode, attrs->ia_size);\n\t\tfscache_resize_cookie(cifs_inode_cookie(inode), attrs->ia_size);\n\t}\n\n\tsetattr_copy(&nop_mnt_idmap, inode, attrs);\n\tmark_inode_dirty(inode);\n\ncifs_setattr_exit:\n\tfree_xid(xid);\n\tfree_dentry_path(page);\n\treturn rc;\n}\n\nint\ncifs_setattr(struct mnt_idmap *idmap, struct dentry *direntry,\n\t     struct iattr *attrs)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint rc, retries = 0;\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\tstruct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);\n#endif  \n\n\tif (unlikely(cifs_forced_shutdown(cifs_sb)))\n\t\treturn -EIO;\n\n\tdo {\n#ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY\n\t\tif (pTcon->unix_ext)\n\t\t\trc = cifs_setattr_unix(direntry, attrs);\n\t\telse\n#endif  \n\t\t\trc = cifs_setattr_nounix(direntry, attrs);\n\t\tretries++;\n\t} while (is_retryable_error(rc) && retries < 2);\n\n\t \n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}