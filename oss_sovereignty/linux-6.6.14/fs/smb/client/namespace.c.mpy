{
  "module_name": "namespace.c",
  "hash_id": "e14a4843421cc09bbc5941179e9ff04d8b950ec308ba862cc598d58ecfbae315",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/namespace.c",
  "human_readable_source": "\n \n\n#include <linux/dcache.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/inet.h>\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"fs_context.h\"\n\nstatic LIST_HEAD(cifs_automount_list);\n\nstatic void cifs_expire_automounts(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(cifs_automount_task,\n\t\t\t    cifs_expire_automounts);\nstatic int cifs_mountpoint_expiry_timeout = 500 * HZ;\n\nstatic void cifs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &cifs_automount_list;\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list))\n\t\tschedule_delayed_work(&cifs_automount_task,\n\t\t\t\t      cifs_mountpoint_expiry_timeout);\n}\n\nvoid cifs_release_automount_timer(void)\n{\n\tif (WARN_ON(!list_empty(&cifs_automount_list)))\n\t\treturn;\n\tcancel_delayed_work_sync(&cifs_automount_task);\n}\n\n \nchar *\ncifs_build_devname(char *nodename, const char *prepath)\n{\n\tsize_t pplen;\n\tsize_t unclen;\n\tchar *dev;\n\tchar *pos;\n\n\t \n\tnodename += strspn(nodename, \"\\\\\");\n\tif (!*nodename)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tunclen = strlen(nodename);\n\tpos = nodename + unclen - 1;\n\n\t \n\twhile (*pos == '\\\\') {\n\t\t--pos;\n\t\t--unclen;\n\t}\n\n\t \n\tpplen = prepath ? strlen(prepath) : 0;\n\tdev = kmalloc(2 + unclen + 1 + pplen + 1, GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpos = dev;\n\t \n\t*pos = '/';\n\t++pos;\n\t*pos = '/';\n\t++pos;\n\n\t \n\tmemcpy(pos, nodename, unclen);\n\tpos += unclen;\n\n\t \n\tif (pplen) {\n\t\t*pos = '/';\n\t\t++pos;\n\t\tmemcpy(pos, prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t \n\t*pos = '\\0';\n\n\tconvert_delimiter(dev, '/');\n\treturn dev;\n}\n\nstatic bool is_dfs_mount(struct dentry *dentry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tbool ret;\n\n\tspin_lock(&tcon->tc_lock);\n\tret = !!tcon->origin_fullpath;\n\tspin_unlock(&tcon->tc_lock);\n\treturn ret;\n}\n\n \nstatic char *automount_fullpath(struct dentry *dentry, void *page)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tsize_t len;\n\tchar *s;\n\n\tspin_lock(&tcon->tc_lock);\n\tif (!tcon->origin_fullpath) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn build_path_from_dentry_optional_prefix(dentry,\n\t\t\t\t\t\t\t      page,\n\t\t\t\t\t\t\t      true);\n\t}\n\tspin_unlock(&tcon->tc_lock);\n\n\ts = dentry_path_raw(dentry, page, PATH_MAX);\n\tif (IS_ERR(s))\n\t\treturn s;\n\t \n\tif (!s[1])\n\t\ts++;\n\n\tspin_lock(&tcon->tc_lock);\n\tlen = strlen(tcon->origin_fullpath);\n\tif (s < (char *)page + len) {\n\t\tspin_unlock(&tcon->tc_lock);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\ts -= len;\n\tmemcpy(s, tcon->origin_fullpath, len);\n\tspin_unlock(&tcon->tc_lock);\n\tconvert_delimiter(s, '/');\n\n\treturn s;\n}\n\n \nstatic struct vfsmount *cifs_do_automount(struct path *path)\n{\n\tint rc;\n\tstruct dentry *mntpt = path->dentry;\n\tstruct fs_context *fc;\n\tvoid *page = NULL;\n\tstruct smb3_fs_context *ctx, *cur_ctx;\n\tstruct smb3_fs_context tmp;\n\tchar *full_path;\n\tstruct vfsmount *mnt;\n\n\tif (IS_ROOT(mntpt))\n\t\treturn ERR_PTR(-ESTALE);\n\n\tcur_ctx = CIFS_SB(mntpt->d_sb)->ctx;\n\n\tfc = fs_context_for_submount(path->mnt->mnt_sb->s_type, mntpt);\n\tif (IS_ERR(fc))\n\t\treturn ERR_CAST(fc);\n\n\tctx = smb3_fc2context(fc);\n\n\tpage = alloc_dentry_path();\n\tfull_path = automount_fullpath(mntpt, page);\n\tif (IS_ERR(full_path)) {\n\t\tmnt = ERR_CAST(full_path);\n\t\tgoto out;\n\t}\n\n\ttmp = *cur_ctx;\n\ttmp.source = NULL;\n\ttmp.leaf_fullpath = NULL;\n\ttmp.UNC = tmp.prepath = NULL;\n\ttmp.dfs_root_ses = NULL;\n\n\trc = smb3_fs_context_dup(ctx, &tmp);\n\tif (rc) {\n\t\tmnt = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\trc = smb3_parse_devname(full_path, ctx);\n\tif (rc) {\n\t\tmnt = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\tctx->source = smb3_fs_context_fullpath(ctx, '/');\n\tif (IS_ERR(ctx->source)) {\n\t\tmnt = ERR_CAST(ctx->source);\n\t\tctx->source = NULL;\n\t\tgoto out;\n\t}\n\tctx->dfs_automount = is_dfs_mount(mntpt);\n\tcifs_dbg(FYI, \"%s: ctx: source=%s UNC=%s prepath=%s dfs_automount=%d\\n\",\n\t\t __func__, ctx->source, ctx->UNC, ctx->prepath, ctx->dfs_automount);\n\n\tmnt = fc_mount(fc);\nout:\n\tput_fs_context(fc);\n\tfree_dentry_path(page);\n\treturn mnt;\n}\n\n \nstruct vfsmount *cifs_d_automount(struct path *path)\n{\n\tstruct vfsmount *newmnt;\n\n\tcifs_dbg(FYI, \"%s: %pd\\n\", __func__, path->dentry);\n\n\tnewmnt = cifs_do_automount(path);\n\tif (IS_ERR(newmnt)) {\n\t\tcifs_dbg(FYI, \"leaving %s [automount failed]\\n\" , __func__);\n\t\treturn newmnt;\n\t}\n\n\tmntget(newmnt);  \n\tmnt_set_expiry(newmnt, &cifs_automount_list);\n\tschedule_delayed_work(&cifs_automount_task,\n\t\t\t      cifs_mountpoint_expiry_timeout);\n\tcifs_dbg(FYI, \"leaving %s [ok]\\n\" , __func__);\n\treturn newmnt;\n}\n\nconst struct inode_operations cifs_namespace_inode_operations = {\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}