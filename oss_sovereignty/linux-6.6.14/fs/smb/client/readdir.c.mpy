{
  "module_name": "readdir.c",
  "hash_id": "d4ad68a7abcd8b2fc6edf9e5b320f18a74c5907c8ebadcba1b7ce49301f995d3",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/readdir.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifsfs.h\"\n#include \"smb2proto.h\"\n#include \"fs_context.h\"\n#include \"cached_dir.h\"\n\n \n#define UNICODE_NAME_MAX ((4 * NAME_MAX) + 2)\n\n#ifdef CONFIG_CIFS_DEBUG2\nstatic void dump_cifs_file_struct(struct file *file, char *label)\n{\n\tstruct cifsFileInfo *cf;\n\n\tif (file) {\n\t\tcf = file->private_data;\n\t\tif (cf == NULL) {\n\t\t\tcifs_dbg(FYI, \"empty cifs private file data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (cf->invalidHandle)\n\t\t\tcifs_dbg(FYI, \"Invalid handle\\n\");\n\t\tif (cf->srch_inf.endOfSearch)\n\t\t\tcifs_dbg(FYI, \"end of search\\n\");\n\t\tif (cf->srch_inf.emptyDir)\n\t\t\tcifs_dbg(FYI, \"empty dir\\n\");\n\t}\n}\n#else\nstatic inline void dump_cifs_file_struct(struct file *file, char *label)\n{\n}\n#endif  \n\n \nstatic void\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\n\t\t    struct cifs_fattr *fattr)\n{\n\tstruct dentry *dentry, *alias;\n\tstruct inode *inode;\n\tstruct super_block *sb = parent->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tcifs_dbg(FYI, \"%s: for %s\\n\", __func__, name->name);\n\n\tdentry = d_hash_and_lookup(parent, name);\n\tif (!dentry) {\n\t\t \n\t\tif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\n\t\t\treturn;\nretry:\n\t\tdentry = d_alloc_parallel(parent, name, &wq);\n\t}\n\tif (IS_ERR(dentry))\n\t\treturn;\n\tif (!d_in_lookup(dentry)) {\n\t\tinode = d_inode(dentry);\n\t\tif (inode) {\n\t\t\tif (d_mountpoint(dentry)) {\n\t\t\t\tdput(dentry);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\n\t\t\t\tfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\n\n\t\t\t \n\t\t\tif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid &&\n\t\t\t    cifs_fattr_to_inode(inode, fattr) == 0) {\n\t\t\t\tdput(dentry);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\tgoto retry;\n\t} else {\n\t\tinode = cifs_iget(sb, fattr);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-ENOMEM);\n\t\talias = d_splice_alias(inode, dentry);\n\t\td_lookup_done(dentry);\n\t\tif (alias && !IS_ERR(alias))\n\t\t\tdput(alias);\n\t}\n\tdput(dentry);\n}\n\nstatic bool reparse_file_needs_reval(const struct cifs_fattr *fattr)\n{\n\tif (!(fattr->cf_cifsattrs & ATTR_REPARSE))\n\t\treturn false;\n\t \n\tswitch (fattr->cf_cifstag) {\n\tcase IO_REPARSE_TAG_DFS:\n\tcase IO_REPARSE_TAG_DFSR:\n\tcase IO_REPARSE_TAG_SYMLINK:\n\tcase IO_REPARSE_TAG_NFS:\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\tcase 0:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\n{\n\tstruct cifs_open_info_data data = {\n\t\t.reparse = { .tag = fattr->cf_cifstag, },\n\t};\n\n\tfattr->cf_uid = cifs_sb->ctx->linux_uid;\n\tfattr->cf_gid = cifs_sb->ctx->linux_gid;\n\n\t \n\tif ((fattr->cf_cifsattrs & ATTR_REPARSE) &&\n\t    cifs_reparse_point_to_fattr(cifs_sb, fattr, &data))\n\t\tgoto out_reparse;\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode = S_IFDIR | cifs_sb->ctx->dir_mode;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\tfattr->cf_mode = S_IFREG | cifs_sb->ctx->file_mode;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\nout_reparse:\n\t \n\tif (reparse_file_needs_reval(fattr))\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\t \n\tfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\n\n\tif (fattr->cf_cifsattrs & ATTR_READONLY)\n\t\tfattr->cf_mode &= ~S_IWUGO;\n\n\t \n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) ||\n\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID))\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\n\t    fattr->cf_cifsattrs & ATTR_SYSTEM) {\n\t\tif (fattr->cf_eof == 0)  {\n\t\t\tfattr->cf_mode &= ~S_IFMT;\n\t\t\tfattr->cf_mode |= S_IFIFO;\n\t\t\tfattr->cf_dtype = DT_FIFO;\n\t\t} else {\n\t\t\t \n\t\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\t}\n\t}\n}\n\n \nstatic void\ncifs_posix_to_fattr(struct cifs_fattr *fattr, struct smb2_posix_info *info,\n\t\t    struct cifs_sb_info *cifs_sb)\n{\n\tstruct smb2_posix_info_parsed parsed;\n\n\tposix_info_parse(info, NULL, &parsed);\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_uniqueid = le64_to_cpu(info->Inode);\n\tfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le64_to_cpu(info->EndOfFile);\n\n\tfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(info->CreationTime);\n\n\tfattr->cf_nlink = le32_to_cpu(info->HardLinks);\n\tfattr->cf_cifsattrs = le32_to_cpu(info->DosAttributes);\n\n\t \n\tfattr->cf_mode = le32_to_cpu(info->Mode) & ~S_IFMT;\n\n\tcifs_dbg(FYI, \"posix fattr: dev %d, reparse %d, mode %o\\n\",\n\t\t le32_to_cpu(info->DeviceId),\n\t\t le32_to_cpu(info->ReparseTag),\n\t\t le32_to_cpu(info->Mode));\n\n\tif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\n\t\tfattr->cf_mode |= S_IFDIR;\n\t\tfattr->cf_dtype = DT_DIR;\n\t} else {\n\t\t \n\t\tfattr->cf_mode |= S_IFREG;\n\t\tfattr->cf_dtype = DT_REG;\n\t}\n\n\tif (reparse_file_needs_reval(fattr))\n\t\tfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tsid_to_id(cifs_sb, &parsed.owner, fattr, SIDOWNER);\n\tsid_to_id(cifs_sb, &parsed.group, fattr, SIDGROUP);\n}\n\nstatic void __dir_info_to_fattr(struct cifs_fattr *fattr, const void *info)\n{\n\tconst FILE_DIRECTORY_INFO *fi = info;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_cifsattrs = le32_to_cpu(fi->ExtFileAttributes);\n\tfattr->cf_eof = le64_to_cpu(fi->EndOfFile);\n\tfattr->cf_bytes = le64_to_cpu(fi->AllocationSize);\n\tfattr->cf_createtime = le64_to_cpu(fi->CreationTime);\n\tfattr->cf_atime = cifs_NTtimeToUnix(fi->LastAccessTime);\n\tfattr->cf_ctime = cifs_NTtimeToUnix(fi->ChangeTime);\n\tfattr->cf_mtime = cifs_NTtimeToUnix(fi->LastWriteTime);\n}\n\nvoid\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\t__dir_info_to_fattr(fattr, info);\n\tcifs_fill_common_info(fattr, cifs_sb);\n}\n\nstatic void cifs_fulldir_info_to_fattr(struct cifs_fattr *fattr,\n\t\t\t\t       SEARCH_ID_FULL_DIR_INFO *info,\n\t\t\t\t       struct cifs_sb_info *cifs_sb)\n{\n\t__dir_info_to_fattr(fattr, info);\n\n\t \n\tif (fattr->cf_cifsattrs & ATTR_REPARSE)\n\t\tfattr->cf_cifstag = le32_to_cpu(info->EaSize);\n\tcifs_fill_common_info(fattr, cifs_sb);\n}\n\nstatic void\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\n\t\t       struct cifs_sb_info *cifs_sb)\n{\n\tint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\n\n\tmemset(fattr, 0, sizeof(*fattr));\n\tfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\n\t\t\t\t\t    info->LastAccessTime, offset);\n\tfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\tfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\n\t\t\t\t\t    info->LastWriteTime, offset);\n\n\tfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\n\tfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\n\tfattr->cf_eof = le32_to_cpu(info->DataSize);\n\n\tcifs_fill_common_info(fattr, cifs_sb);\n}\n\n \n \n\nstatic int\n_initiate_cifs_search(const unsigned int xid, struct file *file,\n\t\t     const char *full_path)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tstruct cifsFileInfo *cifsFile;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\treturn PTR_ERR(tlink);\n\n\t\tcifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\t\tif (cifsFile == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error_exit;\n\t\t}\n\t\tspin_lock_init(&cifsFile->file_info_lock);\n\t\tfile->private_data = cifsFile;\n\t\tcifsFile->tlink = cifs_get_tlink(tlink);\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->query_dir_first) {\n\t\trc = -ENOSYS;\n\t\tgoto error_exit;\n\t}\n\n\tcifsFile->invalidHandle = true;\n\tcifsFile->srch_inf.endOfSearch = false;\n\n\tcifs_dbg(FYI, \"Full path: %s start at: %lld\\n\", full_path, file->f_pos);\n\nffirst_retry:\n\t \n\t \n\t \n\tif (tcon->unix_ext)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\n\telse if (tcon->posix_extensions)\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_POSIX_INFO;\n\telse if ((tcon->ses->capabilities &\n\t\t  tcon->ses->server->vals->cap_nt_find) == 0) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\n\t} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\n\t} else   {\n\t\tcifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\trc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\n\t\t\t\t\t  &cifsFile->fid, search_flags,\n\t\t\t\t\t  &cifsFile->srch_inf);\n\n\tif (rc == 0)\n\t\tcifsFile->invalidHandle = false;\n\t \n\telse if ((rc == -EOPNOTSUPP) &&\n\t\t(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tcifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\n\t\tgoto ffirst_retry;\n\t}\nerror_exit:\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstatic int\ninitiate_cifs_search(const unsigned int xid, struct file *file,\n\t\t     const char *full_path)\n{\n\tint rc, retry_count = 0;\n\n\tdo {\n\t\trc = _initiate_cifs_search(xid, file, full_path);\n\t\t \n\t\tif (rc != -EDEADLK)\n\t\t\tbreak;\n\n\t\tusleep_range(512, 2048);\n\t} while (retry_count++ < 5);\n\n\treturn rc;\n}\n\n \nstatic int cifs_unicode_bytelen(const char *str)\n{\n\tint len;\n\tconst __le16 *ustr = (const __le16 *)str;\n\n\tfor (len = 0; len <= PATH_MAX; len++) {\n\t\tif (ustr[len] == 0)\n\t\t\treturn len << 1;\n\t}\n\tcifs_dbg(FYI, \"Unicode string longer than PATH_MAX found\\n\");\n\treturn len << 1;\n}\n\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\n{\n\tchar *new_entry;\n\tFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\n\n\tif (level == SMB_FIND_FILE_INFO_STANDARD) {\n\t\tFIND_FILE_STANDARD_INFO *pfData;\n\t\tpfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\n\n\t\tnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) + 1 +\n\t\t\t\tpfData->FileNameLength;\n\t} else {\n\t\tu32 next_offset = le32_to_cpu(pDirInfo->NextEntryOffset);\n\n\t\tif (old_entry + next_offset < old_entry) {\n\t\t\tcifs_dbg(VFS, \"Invalid offset %u\\n\", next_offset);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_entry = old_entry + next_offset;\n\t}\n\tcifs_dbg(FYI, \"new entry %p old entry %p\\n\", new_entry, old_entry);\n\t \n\tif (new_entry >= end_of_smb) {\n\t\tcifs_dbg(VFS, \"search entry %p began after end of SMB %p old entry %p\\n\",\n\t\t\t new_entry, end_of_smb, old_entry);\n\t\treturn NULL;\n\t} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t    (new_entry + sizeof(FIND_FILE_STANDARD_INFO) + 1 > end_of_smb))\n\t\t  || ((level != SMB_FIND_FILE_INFO_STANDARD) &&\n\t\t   (new_entry + sizeof(FILE_DIRECTORY_INFO) + 1 > end_of_smb)))  {\n\t\tcifs_dbg(VFS, \"search entry %p extends after end of SMB %p\\n\",\n\t\t\t new_entry, end_of_smb);\n\t\treturn NULL;\n\t} else\n\t\treturn new_entry;\n\n}\n\nstruct cifs_dirent {\n\tconst char\t*name;\n\tsize_t\t\tnamelen;\n\tu32\t\tresume_key;\n\tu64\t\tino;\n};\n\nstatic void cifs_fill_dirent_posix(struct cifs_dirent *de,\n\t\t\t\t   const struct smb2_posix_info *info)\n{\n\tstruct smb2_posix_info_parsed parsed;\n\n\t \n\tif (posix_info_parse(info, NULL, &parsed) < 0) {\n\t\tcifs_dbg(VFS, \"Invalid POSIX info payload\\n\");\n\t\treturn;\n\t}\n\n\tde->name = parsed.name;\n\tde->namelen = parsed.name_len;\n\tde->resume_key = info->Ignored;\n\tde->ino = le64_to_cpu(info->Inode);\n}\n\nstatic void cifs_fill_dirent_unix(struct cifs_dirent *de,\n\t\tconst FILE_UNIX_INFO *info, bool is_unicode)\n{\n\tde->name = &info->FileName[0];\n\tif (is_unicode)\n\t\tde->namelen = cifs_unicode_bytelen(de->name);\n\telse\n\t\tde->namelen = strnlen(de->name, PATH_MAX);\n\tde->resume_key = info->ResumeKey;\n\tde->ino = le64_to_cpu(info->basic.UniqueId);\n}\n\nstatic void cifs_fill_dirent_dir(struct cifs_dirent *de,\n\t\tconst FILE_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}\n\nstatic void cifs_fill_dirent_full(struct cifs_dirent *de,\n\t\tconst FILE_FULL_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}\n\nstatic void cifs_fill_dirent_search(struct cifs_dirent *de,\n\t\tconst SEARCH_ID_FULL_DIR_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n\tde->ino = le64_to_cpu(info->UniqueId);\n}\n\nstatic void cifs_fill_dirent_both(struct cifs_dirent *de,\n\t\tconst FILE_BOTH_DIRECTORY_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\tde->namelen = le32_to_cpu(info->FileNameLength);\n\tde->resume_key = info->FileIndex;\n}\n\nstatic void cifs_fill_dirent_std(struct cifs_dirent *de,\n\t\tconst FIND_FILE_STANDARD_INFO *info)\n{\n\tde->name = &info->FileName[0];\n\t \n\tde->namelen = info->FileNameLength;\n\tde->resume_key = info->ResumeKey;\n}\n\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\n\t\tu16 level, bool is_unicode)\n{\n\tmemset(de, 0, sizeof(*de));\n\n\tswitch (level) {\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tcifs_fill_dirent_posix(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_fill_dirent_unix(de, info, is_unicode);\n\t\tbreak;\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_dir(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_full(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fill_dirent_search(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\n\t\tcifs_fill_dirent_both(de, info);\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_fill_dirent_std(de, info);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Unknown findfirst level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define UNICODE_DOT cpu_to_le16(0x2e)\n\n \nstatic int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\n{\n\tint rc = 0;\n\n\tif (!de->name)\n\t\treturn 0;\n\n\tif (is_unicode) {\n\t\t__le16 *ufilename = (__le16 *)de->name;\n\t\tif (de->namelen == 2) {\n\t\t\t \n\t\t\tif (ufilename[0] == UNICODE_DOT)\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 4) {\n\t\t\t \n\t\t\tif (ufilename[0] == UNICODE_DOT &&\n\t\t\t    ufilename[1] == UNICODE_DOT)\n\t\t\t\trc = 2;\n\t\t}\n\t} else   {\n\t\tif (de->namelen == 1) {\n\t\t\tif (de->name[0] == '.')\n\t\t\t\trc = 1;\n\t\t} else if (de->namelen == 2) {\n\t\t\tif (de->name[0] == '.' && de->name[1] == '.')\n\t\t\t\trc = 2;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic int is_dir_changed(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\n\n\tif (cifsInfo->time == 0)\n\t\treturn 1;  \n\telse\n\t\treturn 0;\n\n}\n\nstatic int cifs_save_resume_key(const char *current_entry,\n\tstruct cifsFileInfo *file_info)\n{\n\tstruct cifs_dirent de;\n\tint rc;\n\n\trc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (!rc) {\n\t\tfile_info->srch_inf.presume_name = de.name;\n\t\tfile_info->srch_inf.resume_name_len = de.namelen;\n\t\tfile_info->srch_inf.resume_key = de.resume_key;\n\t}\n\treturn rc;\n}\n\n \nstatic int\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\n\t\tstruct file *file, const char *full_path,\n\t\tchar **current_entry, int *num_to_ret)\n{\n\t__u16 search_flags;\n\tint rc = 0;\n\tint pos_in_buf = 0;\n\tloff_t first_entry_in_buffer;\n\tloff_t index_to_find = pos;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t \n\n\tif (!server->ops->query_dir_first || !server->ops->query_dir_next)\n\t\treturn -ENOSYS;\n\n\tif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\n\t\treturn -ENOENT;\n\n\t*current_entry = NULL;\n\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\n\t\t\t\t\tcfile->srch_inf.entries_in_buffer;\n\n\t \n\n\tdump_cifs_file_struct(file, \"In fce \");\n\tif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\n\t     is_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\n\t\t \n\t\tcifs_dbg(FYI, \"search backing up - close and restart search\\n\");\n\t\tspin_lock(&cfile->file_info_lock);\n\t\tif (server->ops->dir_needs_close(cfile)) {\n\t\t\tcfile->invalidHandle = true;\n\t\t\tspin_unlock(&cfile->file_info_lock);\n\t\t\tif (server->ops->close_dir)\n\t\t\t\tserver->ops->close_dir(xid, tcon, &cfile->fid);\n\t\t} else\n\t\t\tspin_unlock(&cfile->file_info_lock);\n\t\tif (cfile->srch_inf.ntwrk_buf_start) {\n\t\t\tcifs_dbg(FYI, \"freeing SMB ff cache buf on search rewind\\n\");\n\t\t\tif (cfile->srch_inf.smallBuf)\n\t\t\t\tcifs_small_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(cfile->srch_inf.\n\t\t\t\t\t\tntwrk_buf_start);\n\t\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\t}\n\t\trc = initiate_cifs_search(xid, file, full_path);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"error %d reinitiating a search on rewind\\n\",\n\t\t\t\t rc);\n\t\t\treturn rc;\n\t\t}\n\t\t \n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t}\n\n\tsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\n\tif (backup_cred(cifs_sb))\n\t\tsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\n\n\twhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\n\t       (rc == 0) && !cfile->srch_inf.endOfSearch) {\n\t\tcifs_dbg(FYI, \"calling findnext2\\n\");\n\t\trc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\n\t\t\t\t\t\t search_flags,\n\t\t\t\t\t\t &cfile->srch_inf);\n\t\t \n\t\tif (cfile->srch_inf.last_entry)\n\t\t\tcifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\n\t\tif (rc)\n\t\t\treturn -ENOENT;\n\t}\n\tif (index_to_find < cfile->srch_inf.index_of_last_entry) {\n\t\t \n\t\t \n\t\tint i;\n\t\tchar *cur_ent;\n\t\tchar *end_of_smb;\n\n\t\tif (cfile->srch_inf.ntwrk_buf_start == NULL) {\n\t\t\tcifs_dbg(VFS, \"ntwrk_buf_start is NULL during readdir\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tend_of_smb = cfile->srch_inf.ntwrk_buf_start +\n\t\t\tserver->ops->calc_smb_size(\n\t\t\t\t\tcfile->srch_inf.ntwrk_buf_start);\n\n\t\tcur_ent = cfile->srch_inf.srch_entries_start;\n\t\tfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\n\t\t\t\t\t- cfile->srch_inf.entries_in_buffer;\n\t\tpos_in_buf = index_to_find - first_entry_in_buffer;\n\t\tcifs_dbg(FYI, \"found entry - pos_in_buf %d\\n\", pos_in_buf);\n\n\t\tfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\n\t\t\t \n\t\t\tcur_ent = nxt_dir_entry(cur_ent, end_of_smb,\n\t\t\t\t\t\tcfile->srch_inf.info_level);\n\t\t}\n\t\tif ((cur_ent == NULL) && (i < pos_in_buf)) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"reached end of buf searching for pos in buf %d index to find %lld rc %d\\n\",\n\t\t\t\t pos_in_buf, index_to_find, rc);\n\t\t}\n\t\trc = 0;\n\t\t*current_entry = cur_ent;\n\t} else {\n\t\tcifs_dbg(FYI, \"index not in buffer - could not findnext into it\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\n\t\tcifs_dbg(FYI, \"can not return entries pos_in_buf beyond last\\n\");\n\t\t*num_to_ret = 0;\n\t} else\n\t\t*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\n\n\treturn rc;\n}\n\nstatic bool emit_cached_dirents(struct cached_dirents *cde,\n\t\t\t\tstruct dir_context *ctx)\n{\n\tstruct cached_dirent *dirent;\n\tbool rc;\n\n\tlist_for_each_entry(dirent, &cde->entries, entry) {\n\t\t \n\t\tif (ctx->pos > dirent->pos)\n\t\t\tcontinue;\n\t\t \n\t\tctx->pos = dirent->pos;\n\t\trc = dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t      dirent->fattr.cf_uniqueid,\n\t\t\t      dirent->fattr.cf_dtype);\n\t\tif (!rc)\n\t\t\treturn rc;\n\t\tctx->pos++;\n\t}\n\treturn true;\n}\n\nstatic void update_cached_dirents_count(struct cached_dirents *cde,\n\t\t\t\t\tstruct dir_context *ctx)\n{\n\tif (cde->ctx != ctx)\n\t\treturn;\n\tif (cde->is_valid || cde->is_failed)\n\t\treturn;\n\n\tcde->pos++;\n}\n\nstatic void finished_cached_dirents_count(struct cached_dirents *cde,\n\t\t\t\t\tstruct dir_context *ctx)\n{\n\tif (cde->ctx != ctx)\n\t\treturn;\n\tif (cde->is_valid || cde->is_failed)\n\t\treturn;\n\tif (ctx->pos != cde->pos)\n\t\treturn;\n\n\tcde->is_valid = 1;\n}\n\nstatic void add_cached_dirent(struct cached_dirents *cde,\n\t\t\t      struct dir_context *ctx,\n\t\t\t      const char *name, int namelen,\n\t\t\t      struct cifs_fattr *fattr)\n{\n\tstruct cached_dirent *de;\n\n\tif (cde->ctx != ctx)\n\t\treturn;\n\tif (cde->is_valid || cde->is_failed)\n\t\treturn;\n\tif (ctx->pos != cde->pos) {\n\t\tcde->is_failed = 1;\n\t\treturn;\n\t}\n\tde = kzalloc(sizeof(*de), GFP_ATOMIC);\n\tif (de == NULL) {\n\t\tcde->is_failed = 1;\n\t\treturn;\n\t}\n\tde->namelen = namelen;\n\tde->name = kstrndup(name, namelen, GFP_ATOMIC);\n\tif (de->name == NULL) {\n\t\tkfree(de);\n\t\tcde->is_failed = 1;\n\t\treturn;\n\t}\n\tde->pos = ctx->pos;\n\n\tmemcpy(&de->fattr, fattr, sizeof(struct cifs_fattr));\n\n\tlist_add_tail(&de->entry, &cde->entries);\n}\n\nstatic bool cifs_dir_emit(struct dir_context *ctx,\n\t\t\t  const char *name, int namelen,\n\t\t\t  struct cifs_fattr *fattr,\n\t\t\t  struct cached_fid *cfid)\n{\n\tbool rc;\n\tino_t ino = cifs_uniqueid_to_ino_t(fattr->cf_uniqueid);\n\n\trc = dir_emit(ctx, name, namelen, ino, fattr->cf_dtype);\n\tif (!rc)\n\t\treturn rc;\n\n\tif (cfid) {\n\t\tmutex_lock(&cfid->dirents.de_mutex);\n\t\tadd_cached_dirent(&cfid->dirents, ctx, name, namelen,\n\t\t\t\t  fattr);\n\t\tmutex_unlock(&cfid->dirents.de_mutex);\n\t}\n\n\treturn rc;\n}\n\nstatic int cifs_filldir(char *find_entry, struct file *file,\n\t\t\tstruct dir_context *ctx,\n\t\t\tchar *scratch_buf, unsigned int max_len,\n\t\t\tstruct cached_fid *cfid)\n{\n\tstruct cifsFileInfo *file_info = file->private_data;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_dirent de = { NULL, };\n\tstruct cifs_fattr fattr;\n\tstruct qstr name;\n\tint rc = 0;\n\n\trc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\n\t\t\t      file_info->srch_inf.unicode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (de.namelen > max_len) {\n\t\tcifs_dbg(VFS, \"bad search response length %zd past smb end\\n\",\n\t\t\t de.namelen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\n\t\treturn 0;\n\n\tif (file_info->srch_inf.unicode) {\n\t\tstruct nls_table *nlt = cifs_sb->local_nls;\n\t\tint map_type;\n\n\t\tmap_type = cifs_remap(cifs_sb);\n\t\tname.name = scratch_buf;\n\t\tname.len =\n\t\t\tcifs_from_utf16((char *)name.name, (__le16 *)de.name,\n\t\t\t\t\tUNICODE_NAME_MAX,\n\t\t\t\t\tmin_t(size_t, de.namelen,\n\t\t\t\t\t      (size_t)max_len), nlt, map_type);\n\t\tname.len -= nls_nullsize(nlt);\n\t} else {\n\t\tname.name = de.name;\n\t\tname.len = de.namelen;\n\t}\n\n\tswitch (file_info->srch_inf.info_level) {\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tcifs_posix_to_fattr(&fattr,\n\t\t\t\t    (struct smb2_posix_info *)find_entry,\n\t\t\t\t    cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_UNIX:\n\t\tcifs_unix_basic_to_fattr(&fattr,\n\t\t\t\t\t &((FILE_UNIX_INFO *)find_entry)->basic,\n\t\t\t\t\t cifs_sb);\n\t\tif (S_ISLNK(fattr.cf_mode))\n\t\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\t\tbreak;\n\tcase SMB_FIND_FILE_INFO_STANDARD:\n\t\tcifs_std_info_to_fattr(&fattr,\n\t\t\t\t       (FIND_FILE_STANDARD_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\tcifs_fulldir_info_to_fattr(&fattr,\n\t\t\t\t\t   (SEARCH_ID_FULL_DIR_INFO *)find_entry,\n\t\t\t\t\t   cifs_sb);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dir_info_to_fattr(&fattr,\n\t\t\t\t       (FILE_DIRECTORY_INFO *)find_entry,\n\t\t\t\t       cifs_sb);\n\t\tbreak;\n\t}\n\n\tif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\n\t\tfattr.cf_uniqueid = de.ino;\n\t} else {\n\t\tfattr.cf_uniqueid = iunique(sb, ROOT_I);\n\t\tcifs_autodisable_serverino(cifs_sb);\n\t}\n\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\n\t    couldbe_mf_symlink(&fattr))\n\t\t \n\t\tfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\n\n\tcifs_prime_dcache(file_dentry(file), &name, &fattr);\n\n\treturn !cifs_dir_emit(ctx, name.name, name.len,\n\t\t\t      &fattr, cfid);\n}\n\n\nint cifs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tint i;\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *cifsFile;\n\tchar *current_entry;\n\tint num_to_fill = 0;\n\tchar *tmp_buf = NULL;\n\tchar *end_of_smb;\n\tunsigned int max_len;\n\tconst char *full_path;\n\tvoid *page = alloc_dentry_path();\n\tstruct cached_fid *cfid = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(file_dentry(file), page);\n\tif (IS_ERR(full_path)) {\n\t\trc = PTR_ERR(full_path);\n\t\tgoto rddir2_exit;\n\t}\n\n\tif (file->private_data == NULL) {\n\t\ttlink = cifs_sb_tlink(cifs_sb);\n\t\tif (IS_ERR(tlink))\n\t\t\tgoto cache_not_found;\n\t\ttcon = tlink_tcon(tlink);\n\t} else {\n\t\tcifsFile = file->private_data;\n\t\ttcon = tlink_tcon(cifsFile->tlink);\n\t}\n\n\trc = open_cached_dir(xid, tcon, full_path, cifs_sb, false, &cfid);\n\tcifs_put_tlink(tlink);\n\tif (rc)\n\t\tgoto cache_not_found;\n\n\tmutex_lock(&cfid->dirents.de_mutex);\n\t \n\tif (ctx->pos == 0 && cfid->dirents.ctx == NULL) {\n\t\tcfid->dirents.ctx = ctx;\n\t\tcfid->dirents.pos = 2;\n\t}\n\t \n\tif (cfid->dirents.is_valid) {\n\t\tif (!dir_emit_dots(file, ctx)) {\n\t\t\tmutex_unlock(&cfid->dirents.de_mutex);\n\t\t\tgoto rddir2_exit;\n\t\t}\n\t\temit_cached_dirents(&cfid->dirents, ctx);\n\t\tmutex_unlock(&cfid->dirents.de_mutex);\n\t\tgoto rddir2_exit;\n\t}\n\tmutex_unlock(&cfid->dirents.de_mutex);\n\n\t \n\tclose_cached_dir(cfid);\n\tcfid = NULL;\n\n cache_not_found:\n\t \n\tif (file->private_data == NULL) {\n\t\trc = initiate_cifs_search(xid, file, full_path);\n\t\tcifs_dbg(FYI, \"initiate cifs search rc %d\\n\", rc);\n\t\tif (rc)\n\t\t\tgoto rddir2_exit;\n\t}\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto rddir2_exit;\n\n\t \n\tcifsFile = file->private_data;\n\tif (cifsFile->srch_inf.endOfSearch) {\n\t\tif (cifsFile->srch_inf.emptyDir) {\n\t\t\tcifs_dbg(FYI, \"End of search, empty dir\\n\");\n\t\t\trc = 0;\n\t\t\tgoto rddir2_exit;\n\t\t}\n\t}  \n\n\ttcon = tlink_tcon(cifsFile->tlink);\n\trc = find_cifs_entry(xid, tcon, ctx->pos, file, full_path,\n\t\t\t     &current_entry, &num_to_fill);\n\topen_cached_dir(xid, tcon, full_path, cifs_sb, false, &cfid);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"fce error %d\\n\", rc);\n\t\tgoto rddir2_exit;\n\t} else if (current_entry != NULL) {\n\t\tcifs_dbg(FYI, \"entry %lld found\\n\", ctx->pos);\n\t} else {\n\t\tif (cfid) {\n\t\t\tmutex_lock(&cfid->dirents.de_mutex);\n\t\t\tfinished_cached_dirents_count(&cfid->dirents, ctx);\n\t\t\tmutex_unlock(&cfid->dirents.de_mutex);\n\t\t}\n\t\tcifs_dbg(FYI, \"Could not find entry\\n\");\n\t\tgoto rddir2_exit;\n\t}\n\tcifs_dbg(FYI, \"loop through %d times filling dir for net buf %p\\n\",\n\t\t num_to_fill, cifsFile->srch_inf.ntwrk_buf_start);\n\tmax_len = tcon->ses->server->ops->calc_smb_size(\n\t\t\tcifsFile->srch_inf.ntwrk_buf_start);\n\tend_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;\n\n\ttmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);\n\tif (tmp_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto rddir2_exit;\n\t}\n\n\tfor (i = 0; i < num_to_fill; i++) {\n\t\tif (current_entry == NULL) {\n\t\t\t \n\t\t\tcifs_dbg(VFS, \"past SMB end,  num to fill %d i %d\\n\",\n\t\t\t\t num_to_fill, i);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\t*tmp_buf = 0;\n\t\trc = cifs_filldir(current_entry, file, ctx,\n\t\t\t\t  tmp_buf, max_len, cfid);\n\t\tif (rc) {\n\t\t\tif (rc > 0)\n\t\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tctx->pos++;\n\t\tif (cfid) {\n\t\t\tmutex_lock(&cfid->dirents.de_mutex);\n\t\t\tupdate_cached_dirents_count(&cfid->dirents, ctx);\n\t\t\tmutex_unlock(&cfid->dirents.de_mutex);\n\t\t}\n\n\t\tif (ctx->pos ==\n\t\t\tcifsFile->srch_inf.index_of_last_entry) {\n\t\t\tcifs_dbg(FYI, \"last entry in buf at pos %lld %s\\n\",\n\t\t\t\t ctx->pos, tmp_buf);\n\t\t\tcifs_save_resume_key(current_entry, cifsFile);\n\t\t\tbreak;\n\t\t}\n\t\tcurrent_entry =\n\t\t\tnxt_dir_entry(current_entry, end_of_smb,\n\t\t\t\t      cifsFile->srch_inf.info_level);\n\t}\n\tkfree(tmp_buf);\n\nrddir2_exit:\n\tif (cfid)\n\t\tclose_cached_dir(cfid);\n\tfree_dentry_path(page);\n\tfree_xid(xid);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}