{
  "module_name": "cifsfs.c",
  "hash_id": "cfa79f98ea98d27088ccc34db752d77bcd331f01724319193a010ba06875dc58",
  "original_prompt": "Ingested from linux-6.6.14/fs/smb/client/cifsfs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/filelock.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <linux/random.h>\n#include <linux/uuid.h>\n#include <linux/xattr.h>\n#include <uapi/linux/magic.h>\n#include <net/ipv6.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#define DECLARE_GLOBALS_HERE\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/mm.h>\n#include <linux/key-type.h>\n#include \"cifs_spnego.h\"\n#include \"fscache.h\"\n#ifdef CONFIG_CIFS_DFS_UPCALL\n#include \"dfs_cache.h\"\n#endif\n#ifdef CONFIG_CIFS_SWN_UPCALL\n#include \"netlink.h\"\n#endif\n#include \"fs_context.h\"\n#include \"cached_dir.h\"\n\n \n#define SMB_DATE_MAX (127<<9 | 12<<5 | 31)\n#define SMB_DATE_MIN (0<<9 | 1<<5 | 1)\n#define SMB_TIME_MAX (23<<11 | 59<<5 | 29)\n\nint cifsFYI = 0;\nbool traceSMB;\nbool enable_oplocks = true;\nbool linuxExtEnabled = true;\nbool lookupCacheEnabled = true;\nbool disable_legacy_dialects;  \nbool enable_gcm_256 = true;\nbool require_gcm_256;  \nbool enable_negotiate_signing;  \nunsigned int global_secflags = CIFSSEC_DEF;\n \nunsigned int sign_CIFS_PDUs = 1;\n\n \nunsigned int GlobalCurrentXid;\t \nunsigned int GlobalTotalActiveXid;  \nunsigned int GlobalMaxActiveXid;\t \nspinlock_t GlobalMid_Lock;  \n\n \natomic_t sesInfoAllocCount;\natomic_t tconInfoAllocCount;\natomic_t tcpSesNextId;\natomic_t tcpSesAllocCount;\natomic_t tcpSesReconnectCount;\natomic_t tconInfoReconnectCount;\n\natomic_t mid_count;\natomic_t buf_alloc_count;\natomic_t small_buf_alloc_count;\n#ifdef CONFIG_CIFS_STATS2\natomic_t total_buf_alloc_count;\natomic_t total_small_buf_alloc_count;\n#endif \nstruct list_head\tcifs_tcp_ses_list;\nspinlock_t\t\tcifs_tcp_ses_lock;\nstatic const struct super_operations cifs_super_ops;\nunsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;\nmodule_param(CIFSMaxBufSize, uint, 0444);\nMODULE_PARM_DESC(CIFSMaxBufSize, \"Network buffer size (not including header) \"\n\t\t\t\t \"for CIFS requests. \"\n\t\t\t\t \"Default: 16384 Range: 8192 to 130048\");\nunsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;\nmodule_param(cifs_min_rcv, uint, 0444);\nMODULE_PARM_DESC(cifs_min_rcv, \"Network buffers in pool. Default: 4 Range: \"\n\t\t\t\t\"1 to 64\");\nunsigned int cifs_min_small = 30;\nmodule_param(cifs_min_small, uint, 0444);\nMODULE_PARM_DESC(cifs_min_small, \"Small network buffers in pool. Default: 30 \"\n\t\t\t\t \"Range: 2 to 256\");\nunsigned int cifs_max_pending = CIFS_MAX_REQ;\nmodule_param(cifs_max_pending, uint, 0444);\nMODULE_PARM_DESC(cifs_max_pending, \"Simultaneous requests to server for \"\n\t\t\t\t   \"CIFS/SMB1 dialect (N/A for SMB3) \"\n\t\t\t\t   \"Default: 32767 Range: 2 to 32767.\");\nunsigned int dir_cache_timeout = 30;\nmodule_param(dir_cache_timeout, uint, 0644);\nMODULE_PARM_DESC(dir_cache_timeout, \"Number of seconds to cache directory contents for which we have a lease. Default: 30 \"\n\t\t\t\t \"Range: 1 to 65000 seconds, 0 to disable caching dir contents\");\n#ifdef CONFIG_CIFS_STATS2\nunsigned int slow_rsp_threshold = 1;\nmodule_param(slow_rsp_threshold, uint, 0644);\nMODULE_PARM_DESC(slow_rsp_threshold, \"Amount of time (in seconds) to wait \"\n\t\t\t\t   \"before logging that a response is delayed. \"\n\t\t\t\t   \"Default: 1 (if set to 0 disables msg).\");\n#endif  \n\nmodule_param(enable_oplocks, bool, 0644);\nMODULE_PARM_DESC(enable_oplocks, \"Enable or disable oplocks. Default: y/Y/1\");\n\nmodule_param(enable_gcm_256, bool, 0644);\nMODULE_PARM_DESC(enable_gcm_256, \"Enable requesting strongest (256 bit) GCM encryption. Default: n/N/0\");\n\nmodule_param(require_gcm_256, bool, 0644);\nMODULE_PARM_DESC(require_gcm_256, \"Require strongest (256 bit) GCM encryption. Default: n/N/0\");\n\nmodule_param(enable_negotiate_signing, bool, 0644);\nMODULE_PARM_DESC(enable_negotiate_signing, \"Enable negotiating packet signing algorithm with server. Default: n/N/0\");\n\nmodule_param(disable_legacy_dialects, bool, 0644);\nMODULE_PARM_DESC(disable_legacy_dialects, \"To improve security it may be \"\n\t\t\t\t  \"helpful to restrict the ability to \"\n\t\t\t\t  \"override the default dialects (SMB2.1, \"\n\t\t\t\t  \"SMB3 and SMB3.02) on mount with old \"\n\t\t\t\t  \"dialects (CIFS/SMB1 and SMB2) since \"\n\t\t\t\t  \"vers=1.0 (CIFS/SMB1) and vers=2.0 are weaker\"\n\t\t\t\t  \" and less secure. Default: n/N/0\");\n\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nextern mempool_t *cifs_mid_poolp;\n\nstruct workqueue_struct\t*cifsiod_wq;\nstruct workqueue_struct\t*decrypt_wq;\nstruct workqueue_struct\t*fileinfo_put_wq;\nstruct workqueue_struct\t*cifsoplockd_wq;\nstruct workqueue_struct\t*deferredclose_wq;\n__u32 cifs_lock_secret;\n\n \nvoid\ncifs_sb_active(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_inc_return(&server->active) == 1)\n\t\tatomic_inc(&sb->s_active);\n}\n\nvoid\ncifs_sb_deactive(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}\n\nstatic int\ncifs_read_super(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct timespec64 ts;\n\tint rc = 0;\n\n\tcifs_sb = CIFS_SB(sb);\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\n\t\tsb->s_flags |= SB_POSIXACL;\n\n\tif (tcon->snapshot_time)\n\t\tsb->s_flags |= SB_RDONLY;\n\n\tif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t \n\tif ((tcon->ses->server->vals->protocol_id == SMB10_PROT_ID) &&\n\t    ((tcon->ses->capabilities &\n\t      tcon->ses->server->vals->cap_nt_find) == 0) &&\n\t    !tcon->unix_ext) {\n\t\tsb->s_time_gran = 1000000000;  \n\t\tts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MIN), 0, 0);\n\t\tsb->s_time_min = ts.tv_sec;\n\t\tts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MAX),\n\t\t\t\t    cpu_to_le16(SMB_TIME_MAX), 0);\n\t\tsb->s_time_max = ts.tv_sec;\n\t} else {\n\t\t \n\t\tsb->s_time_gran = 100;\n\t\tts = cifs_NTtimeToUnix(0);\n\t\tsb->s_time_min = ts.tv_sec;\n\t\tts = cifs_NTtimeToUnix(cpu_to_le64(S64_MAX));\n\t\tsb->s_time_max = ts.tv_sec;\n\t}\n\n\tsb->s_magic = CIFS_SUPER_MAGIC;\n\tsb->s_op = &cifs_super_ops;\n\tsb->s_xattr = cifs_xattr_handlers;\n\trc = super_setup_bdi(sb);\n\tif (rc)\n\t\tgoto out_no_root;\n\t \n\tif (cifs_sb->ctx->rsize == 0)\n\t\tcifs_sb->ctx->rsize =\n\t\t\ttcon->ses->server->ops->negotiate_rsize(tcon, cifs_sb->ctx);\n\tif (cifs_sb->ctx->rasize)\n\t\tsb->s_bdi->ra_pages = cifs_sb->ctx->rasize / PAGE_SIZE;\n\telse\n\t\tsb->s_bdi->ra_pages = 2 * (cifs_sb->ctx->rsize / PAGE_SIZE);\n\n\tsb->s_blocksize = CIFS_MAX_MSGSIZE;\n\tsb->s_blocksize_bits = 14;\t \n\tinode = cifs_root_iget(sb);\n\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tgoto out_no_root;\n\t}\n\n\tif (tcon->nocase)\n\t\tsb->s_d_op = &cifs_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &cifs_dentry_ops;\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_no_root;\n\t}\n\n#ifdef CONFIG_CIFS_NFSD_EXPORT\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_dbg(FYI, \"export ops supported\\n\");\n\t\tsb->s_export_op = &cifs_export_ops;\n\t}\n#endif  \n\n\treturn 0;\n\nout_no_root:\n\tcifs_dbg(VFS, \"%s: get root inode failed\\n\", __func__);\n\treturn rc;\n}\n\nstatic void cifs_kill_sb(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\n\t \n\tif (cifs_sb->root) {\n\t\tclose_all_cached_dirs(cifs_sb);\n\n\t\t \n\t\tdput(cifs_sb->root);\n\t\tcifs_sb->root = NULL;\n\t}\n\n\tkill_anon_super(sb);\n\tcifs_umount(cifs_sb);\n}\n\nstatic int\ncifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int xid;\n\tint rc = 0;\n\n\txid = get_xid();\n\n\tif (le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength) > 0)\n\t\tbuf->f_namelen =\n\t\t       le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength);\n\telse\n\t\tbuf->f_namelen = PATH_MAX;\n\n\tbuf->f_fsid.val[0] = tcon->vol_serial_number;\n\t \n\tbuf->f_fsid.val[1] =  (int)le64_to_cpu(tcon->vol_create_time);\n\n\tbuf->f_files = 0;\t \n\tbuf->f_ffree = 0;\t \n\n\tif (server->ops->queryfs)\n\t\trc = server->ops->queryfs(xid, tcon, cifs_sb, buf);\n\n\tfree_xid(xid);\n\treturn rc;\n}\n\nstatic long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (server->ops->fallocate)\n\t\treturn server->ops->fallocate(file, tcon, mode, off, len);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cifs_permission(struct mnt_idmap *idmap,\n\t\t\t   struct inode *inode, int mask)\n{\n\tstruct cifs_sb_info *cifs_sb;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {\n\t\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\t\treturn -EACCES;\n\t\telse\n\t\t\treturn 0;\n\t} else  \n\t\treturn generic_permission(&nop_mnt_idmap, inode, mask);\n}\n\nstatic struct kmem_cache *cifs_inode_cachep;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_mid_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\nmempool_t *cifs_mid_poolp;\n\nstatic struct inode *\ncifs_alloc_inode(struct super_block *sb)\n{\n\tstruct cifsInodeInfo *cifs_inode;\n\tcifs_inode = alloc_inode_sb(sb, cifs_inode_cachep, GFP_KERNEL);\n\tif (!cifs_inode)\n\t\treturn NULL;\n\tcifs_inode->cifsAttrs = 0x20;\t \n\tcifs_inode->time = 0;\n\t \n\tcifs_set_oplock_level(cifs_inode, 0);\n\tcifs_inode->flags = 0;\n\tspin_lock_init(&cifs_inode->writers_lock);\n\tcifs_inode->writers = 0;\n\tcifs_inode->netfs.inode.i_blkbits = 14;   \n\tcifs_inode->server_eof = 0;\n\tcifs_inode->uniqueid = 0;\n\tcifs_inode->createtime = 0;\n\tcifs_inode->epoch = 0;\n\tspin_lock_init(&cifs_inode->open_file_lock);\n\tgenerate_random_uuid(cifs_inode->lease_key);\n\tcifs_inode->symlink_target = NULL;\n\n\t \n\t \n\tINIT_LIST_HEAD(&cifs_inode->openFileList);\n\tINIT_LIST_HEAD(&cifs_inode->llist);\n\tINIT_LIST_HEAD(&cifs_inode->deferred_closes);\n\tspin_lock_init(&cifs_inode->deferred_lock);\n\treturn &cifs_inode->netfs.inode;\n}\n\nstatic void\ncifs_free_inode(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(cinode->symlink_target);\n\tkmem_cache_free(cifs_inode_cachep, cinode);\n}\n\nstatic void\ncifs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (inode->i_state & I_PINNING_FSCACHE_WB)\n\t\tcifs_fscache_unuse_inode_cookie(inode, true);\n\tcifs_fscache_release_inode_cookie(inode);\n\tclear_inode(inode);\n}\n\nstatic void\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\n\tseq_puts(s, \",addr=\");\n\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tseq_printf(s, \"%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tseq_printf(s, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\tif (sa6->sin6_scope_id)\n\t\t\tseq_printf(s, \"%%%u\", sa6->sin6_scope_id);\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"(unknown)\");\n\t}\n\tif (server->rdma)\n\t\tseq_puts(s, \",rdma\");\n}\n\nstatic void\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\n{\n\tif (ses->sectype == Unspecified) {\n\t\tif (ses->user_name == NULL)\n\t\t\tseq_puts(s, \",sec=none\");\n\t\treturn;\n\t}\n\n\tseq_puts(s, \",sec=\");\n\n\tswitch (ses->sectype) {\n\tcase NTLMv2:\n\t\tseq_puts(s, \"ntlmv2\");\n\t\tbreak;\n\tcase Kerberos:\n\t\tseq_puts(s, \"krb5\");\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tseq_puts(s, \"ntlmssp\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tseq_puts(s, \"unknown\");\n\t\tbreak;\n\t}\n\n\tif (ses->sign)\n\t\tseq_puts(s, \"i\");\n\n\tif (ses->sectype == Kerberos)\n\t\tseq_printf(s, \",cruid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, ses->cred_uid));\n}\n\nstatic void\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\n{\n\tseq_puts(s, \",cache=\");\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\tseq_puts(s, \"strict\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\n\t\tseq_puts(s, \"none\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RW_CACHE)\n\t\tseq_puts(s, \"singleclient\");  \n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE)\n\t\tseq_puts(s, \"ro\");  \n\telse\n\t\tseq_puts(s, \"loose\");\n}\n\n \nstatic int cifs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\n\tchar *devname = kstrdup(cifs_sb->ctx->source, GFP_KERNEL);\n\n\tif (devname == NULL)\n\t\tseq_puts(m, \"none\");\n\telse {\n\t\tconvert_delimiter(devname, '/');\n\t\t \n\t\tseq_escape(m, devname, \" \\t\");\n\t\tkfree(devname);\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct sockaddr *srcaddr;\n\tsrcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;\n\n\tseq_show_option(s, \"vers\", tcon->ses->server->vals->version_string);\n\tcifs_show_security(s, tcon->ses);\n\tcifs_show_cache_flavor(s, cifs_sb);\n\n\tif (tcon->no_lease)\n\t\tseq_puts(s, \",nolease\");\n\tif (cifs_sb->ctx->multiuser)\n\t\tseq_puts(s, \",multiuser\");\n\telse if (tcon->ses->user_name)\n\t\tseq_show_option(s, \"username\", tcon->ses->user_name);\n\n\tif (tcon->ses->domainName && tcon->ses->domainName[0] != 0)\n\t\tseq_show_option(s, \"domain\", tcon->ses->domainName);\n\n\tif (srcaddr->sa_family != AF_UNSPEC) {\n\t\tstruct sockaddr_in *saddr4;\n\t\tstruct sockaddr_in6 *saddr6;\n\t\tsaddr4 = (struct sockaddr_in *)srcaddr;\n\t\tsaddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tif (srcaddr->sa_family == AF_INET6)\n\t\t\tseq_printf(s, \",srcaddr=%pI6c\",\n\t\t\t\t   &saddr6->sin6_addr);\n\t\telse if (srcaddr->sa_family == AF_INET)\n\t\t\tseq_printf(s, \",srcaddr=%pI4\",\n\t\t\t\t   &saddr4->sin_addr.s_addr);\n\t\telse\n\t\t\tseq_printf(s, \",srcaddr=BAD-AF:%i\",\n\t\t\t\t   (int)(srcaddr->sa_family));\n\t}\n\n\tseq_printf(s, \",uid=%u\",\n\t\t   from_kuid_munged(&init_user_ns, cifs_sb->ctx->linux_uid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)\n\t\tseq_puts(s, \",forceuid\");\n\telse\n\t\tseq_puts(s, \",noforceuid\");\n\n\tseq_printf(s, \",gid=%u\",\n\t\t   from_kgid_munged(&init_user_ns, cifs_sb->ctx->linux_gid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)\n\t\tseq_puts(s, \",forcegid\");\n\telse\n\t\tseq_puts(s, \",noforcegid\");\n\n\tcifs_show_address(s, tcon->ses->server);\n\n\tif (!tcon->unix_ext)\n\t\tseq_printf(s, \",file_mode=0%ho,dir_mode=0%ho\",\n\t\t\t\t\t   cifs_sb->ctx->file_mode,\n\t\t\t\t\t   cifs_sb->ctx->dir_mode);\n\tif (cifs_sb->ctx->iocharset)\n\t\tseq_printf(s, \",iocharset=%s\", cifs_sb->ctx->iocharset);\n\tif (tcon->seal)\n\t\tseq_puts(s, \",seal\");\n\telse if (tcon->ses->server->ignore_signature)\n\t\tseq_puts(s, \",signloosely\");\n\tif (tcon->nocase)\n\t\tseq_puts(s, \",nocase\");\n\tif (tcon->nodelete)\n\t\tseq_puts(s, \",nodelete\");\n\tif (cifs_sb->ctx->no_sparse)\n\t\tseq_puts(s, \",nosparse\");\n\tif (tcon->local_lease)\n\t\tseq_puts(s, \",locallease\");\n\tif (tcon->retry)\n\t\tseq_puts(s, \",hard\");\n\telse\n\t\tseq_puts(s, \",soft\");\n\tif (tcon->use_persistent)\n\t\tseq_puts(s, \",persistenthandles\");\n\telse if (tcon->use_resilient)\n\t\tseq_puts(s, \",resilienthandles\");\n\tif (tcon->posix_extensions)\n\t\tseq_puts(s, \",posix\");\n\telse if (tcon->unix_ext)\n\t\tseq_puts(s, \",unix\");\n\telse\n\t\tseq_puts(s, \",nounix\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS)\n\t\tseq_puts(s, \",nodfs\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\tseq_puts(s, \",posixpaths\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)\n\t\tseq_puts(s, \",setuids\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL)\n\t\tseq_puts(s, \",idsfromsid\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\tseq_puts(s, \",serverino\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tseq_puts(s, \",rwpidforward\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)\n\t\tseq_puts(s, \",forcemand\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\tseq_puts(s, \",nouser_xattr\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tseq_puts(s, \",mapchars\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tseq_puts(s, \",mapposix\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tseq_puts(s, \",sfu\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\tseq_puts(s, \",nobrl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_HANDLE_CACHE)\n\t\tseq_puts(s, \",nohandlecache\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID)\n\t\tseq_puts(s, \",modefromsid\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tseq_puts(s, \",cifsacl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\tseq_puts(s, \",dynperm\");\n\tif (root->d_sb->s_flags & SB_POSIXACL)\n\t\tseq_puts(s, \",acl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\tseq_puts(s, \",mfsymlinks\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tseq_puts(s, \",fsc\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)\n\t\tseq_puts(s, \",nostrictsync\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tseq_puts(s, \",noperm\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)\n\t\tseq_printf(s, \",backupuid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->ctx->backupuid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)\n\t\tseq_printf(s, \",backupgid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->ctx->backupgid));\n\n\tseq_printf(s, \",rsize=%u\", cifs_sb->ctx->rsize);\n\tseq_printf(s, \",wsize=%u\", cifs_sb->ctx->wsize);\n\tseq_printf(s, \",bsize=%u\", cifs_sb->ctx->bsize);\n\tif (cifs_sb->ctx->rasize)\n\t\tseq_printf(s, \",rasize=%u\", cifs_sb->ctx->rasize);\n\tif (tcon->ses->server->min_offload)\n\t\tseq_printf(s, \",esize=%u\", tcon->ses->server->min_offload);\n\tseq_printf(s, \",echo_interval=%lu\",\n\t\t\ttcon->ses->server->echo_interval / HZ);\n\n\t \n\tif (tcon->ses->server->max_credits != SMB2_MAX_CREDITS_AVAILABLE)\n\t\tseq_printf(s, \",max_credits=%u\", tcon->ses->server->max_credits);\n\tif (tcon->ses->server->tcp_nodelay)\n\t\tseq_puts(s, \",tcpnodelay\");\n\tif (tcon->ses->server->noautotune)\n\t\tseq_puts(s, \",noautotune\");\n\tif (tcon->ses->server->noblocksnd)\n\t\tseq_puts(s, \",noblocksend\");\n\tif (tcon->ses->server->nosharesock)\n\t\tseq_puts(s, \",nosharesock\");\n\n\tif (tcon->snapshot_time)\n\t\tseq_printf(s, \",snapshot=%llu\", tcon->snapshot_time);\n\tif (tcon->handle_timeout)\n\t\tseq_printf(s, \",handletimeout=%u\", tcon->handle_timeout);\n\tif (tcon->max_cached_dirs != MAX_CACHED_FIDS)\n\t\tseq_printf(s, \",max_cached_dirs=%u\", tcon->max_cached_dirs);\n\n\t \n\tif (cifs_sb->ctx->acdirmax == cifs_sb->ctx->acregmax)\n\t\tseq_printf(s, \",actimeo=%lu\", cifs_sb->ctx->acregmax / HZ);\n\telse {\n\t\tseq_printf(s, \",acdirmax=%lu\", cifs_sb->ctx->acdirmax / HZ);\n\t\tseq_printf(s, \",acregmax=%lu\", cifs_sb->ctx->acregmax / HZ);\n\t}\n\tseq_printf(s, \",closetimeo=%lu\", cifs_sb->ctx->closetimeo / HZ);\n\n\tif (tcon->ses->chan_max > 1)\n\t\tseq_printf(s, \",multichannel,max_channels=%zu\",\n\t\t\t   tcon->ses->chan_max);\n\n\tif (tcon->use_witness)\n\t\tseq_puts(s, \",witness\");\n\n\treturn 0;\n}\n\nstatic void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tspin_lock(&tcon->tc_lock);\n\tif ((tcon->tc_count > 1) || (tcon->status == TID_EXITING)) {\n\t\t \n\t\tspin_unlock(&tcon->tc_lock);\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\t \n\tspin_unlock(&tcon->tc_lock);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_close_all_deferred_files(tcon);\n\t   \n\t \n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);  \n\t\t \n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}\n\nstatic int cifs_freeze(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn 0;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tcifs_close_all_deferred_files(tcon);\n\treturn 0;\n}\n\n#ifdef CONFIG_CIFS_STATS2\nstatic int cifs_show_stats(struct seq_file *s, struct dentry *root)\n{\n\t \n\treturn 0;\n}\n#endif\n\nstatic int cifs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tfscache_unpin_writeback(wbc, cifs_inode_cookie(inode));\n\treturn 0;\n}\n\nstatic int cifs_drop_inode(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\t \n\treturn !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) ||\n\t\tgeneric_drop_inode(inode);\n}\n\nstatic const struct super_operations cifs_super_ops = {\n\t.statfs = cifs_statfs,\n\t.alloc_inode = cifs_alloc_inode,\n\t.write_inode\t= cifs_write_inode,\n\t.free_inode = cifs_free_inode,\n\t.drop_inode\t= cifs_drop_inode,\n\t.evict_inode\t= cifs_evict_inode,\n   \n\t.show_devname   = cifs_show_devname,\n    \n\t.show_options = cifs_show_options,\n\t.umount_begin   = cifs_umount_begin,\n\t.freeze_fs      = cifs_freeze,\n#ifdef CONFIG_CIFS_STATS2\n\t.show_stats = cifs_show_stats,\n#endif\n};\n\n \nstatic struct dentry *\ncifs_get_root(struct smb3_fs_context *ctx, struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)\n\t\treturn dget(sb->s_root);\n\n\tfull_path = cifs_build_path_to_root(ctx, cifs_sb,\n\t\t\t\tcifs_sb_master_tcon(cifs_sb), 0);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, \"Get root dentry for %s\\n\", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\ts = full_path;\n\n\tdo {\n\t\tstruct inode *dir = d_inode(dentry);\n\t\tstruct dentry *child;\n\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t \n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tchild = lookup_positive_unlocked(p, dentry, s - p);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\tkfree(full_path);\n\treturn dentry;\n}\n\nstatic int cifs_set_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tsb->s_fs_info = mnt_data->cifs_sb;\n\treturn set_anon_super(sb, NULL);\n}\n\nstruct dentry *\ncifs_smb3_do_mount(struct file_system_type *fs_type,\n\t      int flags, struct smb3_fs_context *old_ctx)\n{\n\tstruct cifs_mnt_data mnt_data;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\tint rc;\n\n\tif (cifsFYI) {\n\t\tcifs_dbg(FYI, \"%s: devname=%s flags=0x%x\\n\", __func__,\n\t\t\t old_ctx->source, flags);\n\t} else {\n\t\tcifs_info(\"Attempting to mount %s\\n\", old_ctx->source);\n\t}\n\n\tcifs_sb = kzalloc(sizeof(*cifs_sb), GFP_KERNEL);\n\tif (!cifs_sb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_sb->ctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);\n\tif (!cifs_sb->ctx) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\trc = smb3_fs_context_dup(cifs_sb->ctx, old_ctx);\n\tif (rc) {\n\t\troot = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\trc = cifs_setup_cifs_sb(cifs_sb);\n\tif (rc) {\n\t\troot = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\trc = cifs_mount(cifs_sb, cifs_sb->ctx);\n\tif (rc) {\n\t\tif (!(flags & SB_SILENT))\n\t\t\tcifs_dbg(VFS, \"cifs_mount failed w/return code = %d\\n\",\n\t\t\t\t rc);\n\t\troot = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\tmnt_data.ctx = cifs_sb->ctx;\n\tmnt_data.cifs_sb = cifs_sb;\n\tmnt_data.flags = flags;\n\n\t \n\tflags |= SB_NODIRATIME | SB_NOATIME;\n\n\tsb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);\n\tif (IS_ERR(sb)) {\n\t\tcifs_umount(cifs_sb);\n\t\treturn ERR_CAST(sb);\n\t}\n\n\tif (sb->s_root) {\n\t\tcifs_dbg(FYI, \"Use existing superblock\\n\");\n\t\tcifs_umount(cifs_sb);\n\t\tcifs_sb = NULL;\n\t} else {\n\t\trc = cifs_read_super(sb);\n\t\tif (rc) {\n\t\t\troot = ERR_PTR(rc);\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tsb->s_flags |= SB_ACTIVE;\n\t}\n\n\troot = cifs_get_root(cifs_sb ? cifs_sb->ctx : old_ctx, sb);\n\tif (IS_ERR(root))\n\t\tgoto out_super;\n\n\tif (cifs_sb)\n\t\tcifs_sb->root = dget(root);\n\n\tcifs_dbg(FYI, \"dentry root is: %p\\n\", root);\n\treturn root;\n\nout_super:\n\tdeactivate_locked_super(sb);\n\treturn root;\nout:\n\tkfree(cifs_sb->prepath);\n\tsmb3_cleanup_fs_context(cifs_sb->ctx);\n\tkfree(cifs_sb);\n\treturn root;\n}\n\n\nstatic ssize_t\ncifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tssize_t rc;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iocb->ki_flags & IOCB_DIRECT)\n\t\treturn cifs_user_readv(iocb, iter);\n\n\trc = cifs_revalidate_mapping(inode);\n\tif (rc)\n\t\treturn rc;\n\n\treturn generic_file_read_iter(iocb, iter);\n}\n\nstatic ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tssize_t written;\n\tint rc;\n\n\tif (iocb->ki_filp->f_flags & O_DIRECT) {\n\t\twritten = cifs_user_writev(iocb, from);\n\t\tif (written > 0 && CIFS_CACHE_READ(cinode)) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t \"Set no oplock for inode=%p after a write operation\\n\",\n\t\t\t\t inode);\n\t\t\tcinode->oplock = 0;\n\t\t}\n\t\treturn written;\n\t}\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\twritten = generic_file_write_iter(iocb, from);\n\n\tif (CIFS_CACHE_WRITE(CIFS_I(inode)))\n\t\tgoto out;\n\n\trc = filemap_fdatawrite(inode->i_mapping);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"cifs_file_write_iter: %d rc on %p inode\\n\",\n\t\t\t rc, inode);\n\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}\n\nstatic loff_t cifs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_tcon *tcon;\n\n\t \n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tint rc;\n\t\tstruct inode *inode = file_inode(file);\n\n\t\t \n\t\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t\t    inode->i_mapping->nrpages != 0) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tif (rc) {\n\t\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t \n\t\tCIFS_I(inode)->time = 0;\n\n\t\trc = cifs_revalidate_file_attr(file);\n\t\tif (rc < 0)\n\t\t\treturn (loff_t)rc;\n\t}\n\tif (cfile && cfile->tlink) {\n\t\ttcon = tlink_tcon(cfile->tlink);\n\t\tif (tcon->ses->server->ops->llseek)\n\t\t\treturn tcon->ses->server->ops->llseek(file, tcon,\n\t\t\t\t\t\t\t      offset, whence);\n\t}\n\treturn generic_file_llseek(file, offset, whence);\n}\n\nstatic int\ncifs_setlease(struct file *file, int arg, struct file_lock **lease, void **priv)\n{\n\t \n\tstruct inode *inode = file_inode(file);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\n\tif (!(S_ISREG(inode->i_mode)))\n\t\treturn -EINVAL;\n\n\t \n\tif (arg == F_UNLCK ||\n\t    ((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||\n\t    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))\n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse if (tlink_tcon(cfile->tlink)->local_lease &&\n\t\t !CIFS_CACHE_READ(CIFS_I(inode)))\n\t\t \n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse\n\t\treturn -EAGAIN;\n}\n\nstruct file_system_type cifs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"cifs\",\n\t.init_fs_context = smb3_init_fs_context,\n\t.parameters = smb3_fs_parameters,\n\t.kill_sb = cifs_kill_sb,\n\t.fs_flags = FS_RENAME_DOES_D_MOVE,\n};\nMODULE_ALIAS_FS(\"cifs\");\n\nstruct file_system_type smb3_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"smb3\",\n\t.init_fs_context = smb3_init_fs_context,\n\t.parameters = smb3_fs_parameters,\n\t.kill_sb = cifs_kill_sb,\n\t.fs_flags = FS_RENAME_DOES_D_MOVE,\n};\nMODULE_ALIAS_FS(\"smb3\");\nMODULE_ALIAS(\"smb3\");\n\nconst struct inode_operations cifs_dir_inode_ops = {\n\t.create = cifs_create,\n\t.atomic_open = cifs_atomic_open,\n\t.lookup = cifs_lookup,\n\t.getattr = cifs_getattr,\n\t.unlink = cifs_unlink,\n\t.link = cifs_hardlink,\n\t.mkdir = cifs_mkdir,\n\t.rmdir = cifs_rmdir,\n\t.rename = cifs_rename2,\n\t.permission = cifs_permission,\n\t.setattr = cifs_setattr,\n\t.symlink = cifs_symlink,\n\t.mknod   = cifs_mknod,\n\t.listxattr = cifs_listxattr,\n\t.get_acl = cifs_get_acl,\n\t.set_acl = cifs_set_acl,\n};\n\nconst struct inode_operations cifs_file_inode_ops = {\n\t.setattr = cifs_setattr,\n\t.getattr = cifs_getattr,\n\t.permission = cifs_permission,\n\t.listxattr = cifs_listxattr,\n\t.fiemap = cifs_fiemap,\n\t.get_acl = cifs_get_acl,\n\t.set_acl = cifs_set_acl,\n};\n\nconst char *cifs_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct delayed_call *done)\n{\n\tchar *target_path;\n\n\ttarget_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!target_path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&inode->i_lock);\n\tif (likely(CIFS_I(inode)->symlink_target)) {\n\t\tstrscpy(target_path, CIFS_I(inode)->symlink_target, PATH_MAX);\n\t} else {\n\t\tkfree(target_path);\n\t\ttarget_path = ERR_PTR(-EOPNOTSUPP);\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (!IS_ERR(target_path))\n\t\tset_delayed_call(done, kfree_link, target_path);\n\n\treturn target_path;\n}\n\nconst struct inode_operations cifs_symlink_inode_ops = {\n\t.get_link = cifs_get_link,\n\t.setattr = cifs_setattr,\n\t.permission = cifs_permission,\n\t.listxattr = cifs_listxattr,\n};\n\n \nstatic int cifs_precopy_set_eof(struct inode *src_inode, struct cifsInodeInfo *src_cifsi,\n\t\t\t\tstruct cifs_tcon *src_tcon,\n\t\t\t\tunsigned int xid, loff_t src_end)\n{\n\tstruct cifsFileInfo *writeable_srcfile;\n\tint rc = -EINVAL;\n\n\twriteable_srcfile = find_writable_file(src_cifsi, FIND_WR_FSUID_ONLY);\n\tif (writeable_srcfile) {\n\t\tif (src_tcon->ses->server->ops->set_file_size)\n\t\t\trc = src_tcon->ses->server->ops->set_file_size(\n\t\t\t\txid, src_tcon, writeable_srcfile,\n\t\t\t\tsrc_inode->i_size, true  );\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifsFileInfo_put(writeable_srcfile);\n\t\tcifs_dbg(FYI, \"SetFSize for copychunk rc = %d\\n\", rc);\n\t}\n\n\tif (rc < 0)\n\t\tgoto set_failed;\n\n\tnetfs_resize_file(&src_cifsi->netfs, src_end);\n\tfscache_resize_cookie(cifs_inode_cookie(src_inode), src_end);\n\treturn 0;\n\nset_failed:\n\treturn filemap_write_and_wait(src_inode->i_mapping);\n}\n\n \nstatic int cifs_flush_folio(struct inode *inode, loff_t pos, loff_t *_fstart, loff_t *_fend,\n\t\t\t    bool first)\n{\n\tstruct folio *folio;\n\tunsigned long long fpos, fend;\n\tpgoff_t index = pos / PAGE_SIZE;\n\tsize_t size;\n\tint rc = 0;\n\n\tfolio = filemap_get_folio(inode->i_mapping, index);\n\tif (IS_ERR(folio))\n\t\treturn 0;\n\n\tsize = folio_size(folio);\n\tfpos = folio_pos(folio);\n\tfend = fpos + size - 1;\n\t*_fstart = min_t(unsigned long long, *_fstart, fpos);\n\t*_fend   = max_t(unsigned long long, *_fend, fend);\n\tif ((first && pos == fpos) || (!first && pos == fend))\n\t\tgoto out;\n\n\trc = filemap_write_and_wait_range(inode->i_mapping, fpos, fend);\nout:\n\tfolio_put(folio);\n\treturn rc;\n}\n\nstatic loff_t cifs_remap_file_range(struct file *src_file, loff_t off,\n\t\tstruct file *dst_file, loff_t destoff, loff_t len,\n\t\tunsigned int remap_flags)\n{\n\tstruct inode *src_inode = file_inode(src_file);\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifsInodeInfo *src_cifsi = CIFS_I(src_inode);\n\tstruct cifsInodeInfo *target_cifsi = CIFS_I(target_inode);\n\tstruct cifsFileInfo *smb_file_src = src_file->private_data;\n\tstruct cifsFileInfo *smb_file_target = dst_file->private_data;\n\tstruct cifs_tcon *target_tcon, *src_tcon;\n\tunsigned long long destend, fstart, fend, new_size;\n\tunsigned int xid;\n\tint rc;\n\n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\treturn -EOPNOTSUPP;\n\tif (remap_flags & ~REMAP_FILE_ADVISORY)\n\t\treturn -EINVAL;\n\n\tcifs_dbg(FYI, \"clone range\\n\");\n\n\txid = get_xid();\n\n\tif (!smb_file_src || !smb_file_target) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out;\n\t}\n\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\t \n\tlock_two_nondirectories(target_inode, src_inode);\n\n\tif (len == 0)\n\t\tlen = src_inode->i_size - off;\n\n\tcifs_dbg(FYI, \"clone range\\n\");\n\n\t \n\trc = filemap_write_and_wait_range(src_inode->i_mapping, off,\n\t\t\t\t\t  off + len - 1);\n\tif (rc)\n\t\tgoto unlock;\n\n\t \n\tif (src_cifsi->netfs.remote_i_size < off + len) {\n\t\trc = cifs_precopy_set_eof(src_inode, src_cifsi, src_tcon, xid, off + len);\n\t\tif (rc < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tnew_size = destoff + len;\n\tdestend = destoff + len - 1;\n\n\t \n\tfstart = destoff;\n\tfend = destend;\n\n\trc = cifs_flush_folio(target_inode, destoff, &fstart, &fend, true);\n\tif (rc)\n\t\tgoto unlock;\n\trc = cifs_flush_folio(target_inode, destend, &fstart, &fend, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\t \n\tcifs_dbg(FYI, \"about to discard pages %llx-%llx\\n\", fstart, fend);\n\ttruncate_inode_pages_range(&target_inode->i_data, fstart, fend);\n\n\tfscache_invalidate(cifs_inode_cookie(target_inode), NULL,\n\t\t\t   i_size_read(target_inode), 0);\n\n\trc = -EOPNOTSUPP;\n\tif (target_tcon->ses->server->ops->duplicate_extents) {\n\t\trc = target_tcon->ses->server->ops->duplicate_extents(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\t\tif (rc == 0 && new_size > i_size_read(target_inode)) {\n\t\t\ttruncate_setsize(target_inode, new_size);\n\t\t\tnetfs_resize_file(&target_cifsi->netfs, new_size);\n\t\t\tfscache_resize_cookie(cifs_inode_cookie(target_inode),\n\t\t\t\t\t      new_size);\n\t\t}\n\t}\n\n\t \n\tCIFS_I(target_inode)->time = 0;\nunlock:\n\t \n\tunlock_two_nondirectories(src_inode, target_inode);\nout:\n\tfree_xid(xid);\n\treturn rc < 0 ? rc : len;\n}\n\nssize_t cifs_file_copychunk_range(unsigned int xid,\n\t\t\t\tstruct file *src_file, loff_t off,\n\t\t\t\tstruct file *dst_file, loff_t destoff,\n\t\t\t\tsize_t len, unsigned int flags)\n{\n\tstruct inode *src_inode = file_inode(src_file);\n\tstruct inode *target_inode = file_inode(dst_file);\n\tstruct cifsInodeInfo *src_cifsi = CIFS_I(src_inode);\n\tstruct cifsFileInfo *smb_file_src;\n\tstruct cifsFileInfo *smb_file_target;\n\tstruct cifs_tcon *src_tcon;\n\tstruct cifs_tcon *target_tcon;\n\tunsigned long long destend, fstart, fend;\n\tssize_t rc;\n\n\tcifs_dbg(FYI, \"copychunk range\\n\");\n\n\tif (!src_file->private_data || !dst_file->private_data) {\n\t\trc = -EBADF;\n\t\tcifs_dbg(VFS, \"missing cifsFileInfo on copy range src file\\n\");\n\t\tgoto out;\n\t}\n\n\trc = -EXDEV;\n\tsmb_file_target = dst_file->private_data;\n\tsmb_file_src = src_file->private_data;\n\tsrc_tcon = tlink_tcon(smb_file_src->tlink);\n\ttarget_tcon = tlink_tcon(smb_file_target->tlink);\n\n\tif (src_tcon->ses != target_tcon->ses) {\n\t\tcifs_dbg(VFS, \"source and target of copy not on same server\\n\");\n\t\tgoto out;\n\t}\n\n\trc = -EOPNOTSUPP;\n\tif (!target_tcon->ses->server->ops->copychunk_range)\n\t\tgoto out;\n\n\t \n\tlock_two_nondirectories(target_inode, src_inode);\n\n\tcifs_dbg(FYI, \"about to flush pages\\n\");\n\n\trc = filemap_write_and_wait_range(src_inode->i_mapping, off,\n\t\t\t\t\t  off + len - 1);\n\tif (rc)\n\t\tgoto unlock;\n\n\t \n\tif (src_cifsi->server_eof < off + len) {\n\t\trc = cifs_precopy_set_eof(src_inode, src_cifsi, src_tcon, xid, off + len);\n\t\tif (rc < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tdestend = destoff + len - 1;\n\n\t \n\tfstart = destoff;\n\tfend = destend;\n\n\trc = cifs_flush_folio(target_inode, destoff, &fstart, &fend, true);\n\tif (rc)\n\t\tgoto unlock;\n\trc = cifs_flush_folio(target_inode, destend, &fstart, &fend, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\t \n\ttruncate_inode_pages_range(&target_inode->i_data, fstart, fend);\n\n\trc = file_modified(dst_file);\n\tif (!rc) {\n\t\trc = target_tcon->ses->server->ops->copychunk_range(xid,\n\t\t\tsmb_file_src, smb_file_target, off, len, destoff);\n\t\tif (rc > 0 && destoff + rc > i_size_read(target_inode))\n\t\t\ttruncate_setsize(target_inode, destoff + rc);\n\t}\n\n\tfile_accessed(src_file);\n\n\t \n\tCIFS_I(target_inode)->time = 0;\n\nunlock:\n\t \n\tunlock_two_nondirectories(src_inode, target_inode);\n\nout:\n\treturn rc;\n}\n\n \nstatic int cifs_dir_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tcifs_dbg(FYI, \"Sync directory - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\treturn 0;\n}\n\nstatic ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,\n\t\t\t\tstruct file *dst_file, loff_t destoff,\n\t\t\t\tsize_t len, unsigned int flags)\n{\n\tunsigned int xid = get_xid();\n\tssize_t rc;\n\tstruct cifsFileInfo *cfile = dst_file->private_data;\n\n\tif (cfile->swapfile) {\n\t\trc = -EOPNOTSUPP;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\trc = cifs_file_copychunk_range(xid, src_file, off, dst_file, destoff,\n\t\t\t\t\tlen, flags);\n\tfree_xid(xid);\n\n\tif (rc == -EOPNOTSUPP || rc == -EXDEV)\n\t\trc = generic_copy_file_range(src_file, off, dst_file,\n\t\t\t\t\t     destoff, len, flags);\n\treturn rc;\n}\n\nconst struct file_operations cifs_file_ops = {\n\t.read_iter = cifs_loose_read_iter,\n\t.write_iter = cifs_file_write_iter,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.lock = cifs_lock,\n\t.flock = cifs_flock,\n\t.fsync = cifs_fsync,\n\t.flush = cifs_flush,\n\t.mmap  = cifs_file_mmap,\n\t.splice_read = filemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.llseek = cifs_llseek,\n\t.unlocked_ioctl\t= cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_file_strict_ops = {\n\t.read_iter = cifs_strict_readv,\n\t.write_iter = cifs_strict_writev,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.lock = cifs_lock,\n\t.flock = cifs_flock,\n\t.fsync = cifs_strict_fsync,\n\t.flush = cifs_flush,\n\t.mmap = cifs_file_strict_mmap,\n\t.splice_read = filemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.llseek = cifs_llseek,\n\t.unlocked_ioctl\t= cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_file_direct_ops = {\n\t.read_iter = cifs_direct_readv,\n\t.write_iter = cifs_direct_writev,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.lock = cifs_lock,\n\t.flock = cifs_flock,\n\t.fsync = cifs_fsync,\n\t.flush = cifs_flush,\n\t.mmap = cifs_file_mmap,\n\t.splice_read = copy_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.unlocked_ioctl  = cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.llseek = cifs_llseek,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_file_nobrl_ops = {\n\t.read_iter = cifs_loose_read_iter,\n\t.write_iter = cifs_file_write_iter,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.fsync = cifs_fsync,\n\t.flush = cifs_flush,\n\t.mmap  = cifs_file_mmap,\n\t.splice_read = filemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.llseek = cifs_llseek,\n\t.unlocked_ioctl\t= cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_file_strict_nobrl_ops = {\n\t.read_iter = cifs_strict_readv,\n\t.write_iter = cifs_strict_writev,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.fsync = cifs_strict_fsync,\n\t.flush = cifs_flush,\n\t.mmap = cifs_file_strict_mmap,\n\t.splice_read = filemap_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.llseek = cifs_llseek,\n\t.unlocked_ioctl\t= cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_file_direct_nobrl_ops = {\n\t.read_iter = cifs_direct_readv,\n\t.write_iter = cifs_direct_writev,\n\t.open = cifs_open,\n\t.release = cifs_close,\n\t.fsync = cifs_fsync,\n\t.flush = cifs_flush,\n\t.mmap = cifs_file_mmap,\n\t.splice_read = copy_splice_read,\n\t.splice_write = iter_file_splice_write,\n\t.unlocked_ioctl  = cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.llseek = cifs_llseek,\n\t.setlease = cifs_setlease,\n\t.fallocate = cifs_fallocate,\n};\n\nconst struct file_operations cifs_dir_ops = {\n\t.iterate_shared = cifs_readdir,\n\t.release = cifs_closedir,\n\t.read    = generic_read_dir,\n\t.unlocked_ioctl  = cifs_ioctl,\n\t.copy_file_range = cifs_copy_file_range,\n\t.remap_file_range = cifs_remap_file_range,\n\t.llseek = generic_file_llseek,\n\t.fsync = cifs_dir_fsync,\n};\n\nstatic void\ncifs_init_once(void *inode)\n{\n\tstruct cifsInodeInfo *cifsi = inode;\n\n\tinode_init_once(&cifsi->netfs.inode);\n\tinit_rwsem(&cifsi->lock_sem);\n}\n\nstatic int __init\ncifs_init_inodecache(void)\n{\n\tcifs_inode_cachep = kmem_cache_create(\"cifs_inode_cache\",\n\t\t\t\t\t      sizeof(struct cifsInodeInfo),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t      cifs_init_once);\n\tif (cifs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void\ncifs_destroy_inodecache(void)\n{\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}\n\nstatic int\ncifs_init_request_bufs(void)\n{\n\t \n\tsize_t max_hdr_size = MAX_SMB2_HDR_SIZE;\n\n\tif (CIFSMaxBufSize < 8192) {\n\t \n\t\tCIFSMaxBufSize = 8192;\n\t} else if (CIFSMaxBufSize > 1024*127) {\n\t\tCIFSMaxBufSize = 1024 * 127;\n\t} else {\n\t\tCIFSMaxBufSize &= 0x1FE00;  \n\t}\n \n\tcifs_req_cachep = kmem_cache_create_usercopy(\"cifs_request\",\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, 0,\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size,\n\t\t\t\t\t    NULL);\n\tif (cifs_req_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (cifs_min_rcv < 1)\n\t\tcifs_min_rcv = 1;\n\telse if (cifs_min_rcv > 64) {\n\t\tcifs_min_rcv = 64;\n\t\tcifs_dbg(VFS, \"cifs_min_rcv set to maximum (64)\\n\");\n\t}\n\n\tcifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\n\t\t\t\t\t\t  cifs_req_cachep);\n\n\tif (cifs_req_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tcifs_sm_req_cachep = kmem_cache_create_usercopy(\"cifs_small_rq\",\n\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\t\t0, MAX_CIFS_SMALL_BUFFER_SIZE, NULL);\n\tif (cifs_sm_req_cachep == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cifs_min_small < 2)\n\t\tcifs_min_small = 2;\n\telse if (cifs_min_small > 256) {\n\t\tcifs_min_small = 256;\n\t\tcifs_dbg(FYI, \"cifs_min_small set to maximum (256)\\n\");\n\t}\n\n\tcifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\n\t\t\t\t\t\t     cifs_sm_req_cachep);\n\n\tif (cifs_sm_req_poolp == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\tkmem_cache_destroy(cifs_sm_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}\n\nstatic int init_mids(void)\n{\n\tcifs_mid_cachep = kmem_cache_create(\"cifs_mpx_ids\",\n\t\t\t\t\t    sizeof(struct mid_q_entry), 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_mid_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tcifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\n\tif (cifs_mid_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_mid_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}\n\nstatic int __init\ninit_cifs(void)\n{\n\tint rc = 0;\n\tcifs_proc_init();\n\tINIT_LIST_HEAD(&cifs_tcp_ses_list);\n \n\tatomic_set(&sesInfoAllocCount, 0);\n\tatomic_set(&tconInfoAllocCount, 0);\n\tatomic_set(&tcpSesNextId, 0);\n\tatomic_set(&tcpSesAllocCount, 0);\n\tatomic_set(&tcpSesReconnectCount, 0);\n\tatomic_set(&tconInfoReconnectCount, 0);\n\n\tatomic_set(&buf_alloc_count, 0);\n\tatomic_set(&small_buf_alloc_count, 0);\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_set(&total_buf_alloc_count, 0);\n\tatomic_set(&total_small_buf_alloc_count, 0);\n\tif (slow_rsp_threshold < 1)\n\t\tcifs_dbg(FYI, \"slow_response_threshold msgs disabled\\n\");\n\telse if (slow_rsp_threshold > 32767)\n\t\tcifs_dbg(VFS,\n\t\t       \"slow response threshold set higher than recommended (0 to 32767)\\n\");\n#endif  \n\n\tatomic_set(&mid_count, 0);\n\tGlobalCurrentXid = 0;\n\tGlobalTotalActiveXid = 0;\n\tGlobalMaxActiveXid = 0;\n\tspin_lock_init(&cifs_tcp_ses_lock);\n\tspin_lock_init(&GlobalMid_Lock);\n\n\tcifs_lock_secret = get_random_u32();\n\n\tif (cifs_max_pending < 2) {\n\t\tcifs_max_pending = 2;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to min of 2\\n\");\n\t} else if (cifs_max_pending > CIFS_MAX_REQ) {\n\t\tcifs_max_pending = CIFS_MAX_REQ;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to max of %u\\n\",\n\t\t\t CIFS_MAX_REQ);\n\t}\n\n\t \n\tif (dir_cache_timeout > 65000) {\n\t\tdir_cache_timeout = 65000;\n\t\tcifs_dbg(VFS, \"dir_cache_timeout set to max of 65000 seconds\\n\");\n\t}\n\n\tcifsiod_wq = alloc_workqueue(\"cifsiod\", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!cifsiod_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_clean_proc;\n\t}\n\n\t \n\n\t \n\tdecrypt_wq = alloc_workqueue(\"smb3decryptd\",\n\t\t\t\t     WQ_UNBOUND|WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!decrypt_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_destroy_cifsiod_wq;\n\t}\n\n\tfileinfo_put_wq = alloc_workqueue(\"cifsfileinfoput\",\n\t\t\t\t     WQ_UNBOUND|WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!fileinfo_put_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_destroy_decrypt_wq;\n\t}\n\n\tcifsoplockd_wq = alloc_workqueue(\"cifsoplockd\",\n\t\t\t\t\t WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!cifsoplockd_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_destroy_fileinfo_put_wq;\n\t}\n\n\tdeferredclose_wq = alloc_workqueue(\"deferredclose\",\n\t\t\t\t\t   WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!deferredclose_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_destroy_cifsoplockd_wq;\n\t}\n\n\trc = cifs_init_inodecache();\n\tif (rc)\n\t\tgoto out_destroy_deferredclose_wq;\n\n\trc = init_mids();\n\tif (rc)\n\t\tgoto out_destroy_inodecache;\n\n\trc = cifs_init_request_bufs();\n\tif (rc)\n\t\tgoto out_destroy_mids;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\trc = dfs_cache_init();\n\tif (rc)\n\t\tgoto out_destroy_request_bufs;\n#endif  \n#ifdef CONFIG_CIFS_UPCALL\n\trc = init_cifs_spnego();\n\tif (rc)\n\t\tgoto out_destroy_dfs_cache;\n#endif  \n#ifdef CONFIG_CIFS_SWN_UPCALL\n\trc = cifs_genl_init();\n\tif (rc)\n\t\tgoto out_register_key_type;\n#endif  \n\n\trc = init_cifs_idmap();\n\tif (rc)\n\t\tgoto out_cifs_swn_init;\n\n\trc = register_filesystem(&cifs_fs_type);\n\tif (rc)\n\t\tgoto out_init_cifs_idmap;\n\n\trc = register_filesystem(&smb3_fs_type);\n\tif (rc) {\n\t\tunregister_filesystem(&cifs_fs_type);\n\t\tgoto out_init_cifs_idmap;\n\t}\n\n\treturn 0;\n\nout_init_cifs_idmap:\n\texit_cifs_idmap();\nout_cifs_swn_init:\n#ifdef CONFIG_CIFS_SWN_UPCALL\n\tcifs_genl_exit();\nout_register_key_type:\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\texit_cifs_spnego();\nout_destroy_dfs_cache:\n#endif\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tdfs_cache_destroy();\nout_destroy_request_bufs:\n#endif\n\tcifs_destroy_request_bufs();\nout_destroy_mids:\n\tdestroy_mids();\nout_destroy_inodecache:\n\tcifs_destroy_inodecache();\nout_destroy_deferredclose_wq:\n\tdestroy_workqueue(deferredclose_wq);\nout_destroy_cifsoplockd_wq:\n\tdestroy_workqueue(cifsoplockd_wq);\nout_destroy_fileinfo_put_wq:\n\tdestroy_workqueue(fileinfo_put_wq);\nout_destroy_decrypt_wq:\n\tdestroy_workqueue(decrypt_wq);\nout_destroy_cifsiod_wq:\n\tdestroy_workqueue(cifsiod_wq);\nout_clean_proc:\n\tcifs_proc_clean();\n\treturn rc;\n}\n\nstatic void __exit\nexit_cifs(void)\n{\n\tcifs_dbg(NOISY, \"exit_smb3\\n\");\n\tunregister_filesystem(&cifs_fs_type);\n\tunregister_filesystem(&smb3_fs_type);\n\tcifs_release_automount_timer();\n\texit_cifs_idmap();\n#ifdef CONFIG_CIFS_SWN_UPCALL\n\tcifs_genl_exit();\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\texit_cifs_spnego();\n#endif\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tdfs_cache_destroy();\n#endif\n\tcifs_destroy_request_bufs();\n\tdestroy_mids();\n\tcifs_destroy_inodecache();\n\tdestroy_workqueue(deferredclose_wq);\n\tdestroy_workqueue(cifsoplockd_wq);\n\tdestroy_workqueue(decrypt_wq);\n\tdestroy_workqueue(fileinfo_put_wq);\n\tdestroy_workqueue(cifsiod_wq);\n\tcifs_proc_clean();\n}\n\nMODULE_AUTHOR(\"Steve French\");\nMODULE_LICENSE(\"GPL\");\t \nMODULE_DESCRIPTION\n\t(\"VFS to access SMB3 servers e.g. Samba, Macs, Azure and Windows (and \"\n\t\"also older servers complying with the SNIA CIFS Specification)\");\nMODULE_VERSION(CIFS_VERSION);\nMODULE_SOFTDEP(\"ecb\");\nMODULE_SOFTDEP(\"hmac\");\nMODULE_SOFTDEP(\"md5\");\nMODULE_SOFTDEP(\"nls\");\nMODULE_SOFTDEP(\"aes\");\nMODULE_SOFTDEP(\"cmac\");\nMODULE_SOFTDEP(\"sha256\");\nMODULE_SOFTDEP(\"sha512\");\nMODULE_SOFTDEP(\"aead2\");\nMODULE_SOFTDEP(\"ccm\");\nMODULE_SOFTDEP(\"gcm\");\nmodule_init(init_cifs)\nmodule_exit(exit_cifs)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}